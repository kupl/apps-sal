["import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    import bisect\n    N,M = i_map()\n    A = i_list()\n    BC = [i_list() for i in range(M)]\n\n    BC.sort(key=lambda x: x[1], reverse=True)\n\n    temp = []\n    for i in range(M):\n        temp += [BC[i][1]] * BC[i][0]\n        if len(temp) > N:\n            break\n    \n    A += temp\n    A.sort(reverse=True)\n    print(sum(A[:N]))\n  \n\n\n  \ndef __starting_point():\n    main()\n__starting_point()", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\na.sort()\nnum=[]\nfor i in range(m):\n    num.append(list(map(int,input().split())))\nnum.sort(reverse=True,key=lambda x: x[1])\ncnt=0\nfor i in range(n):\n    if cnt==m:\n        break\n    if num[cnt][0]==0:\n        cnt+=1\n    if cnt==m:\n        break\n    if a[i]>=num[cnt][1]:\n        break\n    a[i]=num[cnt][1]\n    num[cnt][0]-=1\nprint((sum(a)))\n", "N,M=map(int,input().split())\nL=[(1,a) for a in map(int,input().split())]\nfor _ in range(M):\n  L.append(tuple(map(int,input().split())))\nL=sorted(L,key=lambda x: x[1],reverse=True)\nans,k=0,0\nfor n,a in L:\n  if n+k>=N:\n    ans+=a*(N-k)\n    break\n  else:\n    ans+=a*n\n    k+=n\nprint(ans)", "import sys\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\ncard = [ list(map(int, i.rstrip().split())) for i in sys.stdin.readlines()]\ncard = sorted(card, key=lambda x:x[1], reverse=True)\nA = sorted(A)\ni = 0\nfor b, c in card:\n  for _ in range(b):\n    if i >= N:\n      break\n    elif A[i] >= c:\n      break\n    else:\n      A[i] = c\n      i += 1\nprint(sum(A))", "from collections import deque\n\ndetails = list(map(int,input().split()))\n\nN = details[0]\nM = details[1]\n\ncards =  list(map(int,input().split()))\n\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab = sorted(ab, key=lambda x: x[1], reverse=True)\n\ncards = deque(sorted(cards, reverse = True))\n\n\nfor i in range(M):\n    for j in range(ab[i][0]):\n        if ab[i][1] > cards[-1]:\n            cards.pop()\n            cards.appendleft(ab[i][1])\n        else:\n            break\n\nprint(sum(cards))", "N, M = map(int, input().split())\n\nAs = [0] + list(map(int, input().split()))\nAs.sort(reverse=True)\nBCs = [(0,0)]\n\nmemo = [0]*N\n\nfor _ in range(M):\n  b,c = map(int, input().split())\n  BCs.append((b,c))\n  \nBCs.sort(key=lambda x:x[1], reverse=True)\n\ncnt = 0\nrlt = 0\ni = 0\nj = 0\nwhile cnt < N:\n  if As[i] >= BCs[j][1]:\n    rlt += As[i]\n    cnt += 1\n    i += 1\n  else:\n    if cnt + BCs[j][0] < N:\n      rlt += BCs[j][0]*BCs[j][1]\n      cnt += BCs[j][0]\n      j += 1\n    else:\n      rlt += (N-cnt)*BCs[j][1]\n      break\n  \nprint(rlt)", "import heapq\npush, pop = heapq.heappush, heapq.heappop\n\nn,m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef modify():\n    heapq.heapify(a)\n    \n    bc = [list(map(int, input().split())) for _ in range(m)]\n    bc.sort(key=lambda x:x[1], reverse=True)\n    \n    for b,c in bc:\n        for _ in range(b):\n            p = pop(a)\n            if p < c:\n                push(a, c)\n            else:\n                # \u30ad\u30e5\u30fc\u306b\u623b\u3059\n                push(a, p)\n                return\n\nmodify()            \nprint(sum(a))", "import numpy as np\n\nn, m = map(int, input().split())\na = np.array(sorted(list(map(int, input().split()))), dtype=np.int64)\nbc = sorted([list(map(int, input().split())) for _ in range(m)], key=lambda x: -x[1])\n\np = 0\nfor b, c  in bc:\n    a[p:p+b] = np.maximum(a[p:p+b], c)\n    p += b\nprint(np.sum(a))", "N, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = sorted(A, reverse = True)\nbc = [0] * M\nfor i in range(M):\n  bc[i] = list(map(int, input().split()))\nbc = sorted(bc, key = lambda x:x[1], reverse = True)\n\n\n#\u3081\u3050\u308b\u5f0f\u4e8c\u5206\u63a2\u7d22\n#index\u304c\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u5224\u5b9a\ndef isOK(index, key, A):\n  if A[index] < key:\n    return True\n  else:\n    return False\n  \n#\u306b\u3076\u305f\u3093\n#A : \u914d\u5217\ndef binary_search(key, A):\n  N = len(A)\n  ng = -1\n  ok = N\n  while (abs(ok - ng) > 1):\n    mid = int((ok + ng) / 2)\n    if isOK(mid, key, A):\n      ok = mid\n    else:\n      ng = mid\n  return ok\n  \n#a = [1, 14, 32, 51, 51, 51, 243, 419, 750, 910]\n\n#print(A)\n#print(binary_search(5, A))\n#\u4e8c\u5206\u63a2\u7d22\u306e\u7d50\u679c\u304c\u305d\u308c\u3092\u8d85\u3048\u308b\u679a\u6570\nfix = 0\nfix2 = 0\nfix3 = 0\nans = 0\nfor i in range(M):\n  now = bc[i]\n  x = binary_search(now[1], A)\n  fix = x\n  fix3 = now[0]\n  #print(fix, fix2, fix3, ans)  \n  if fix + fix2 + fix3 >= N:\n    fix3 = N - fix - fix2\n    ans += sum(A[:fix]) + now[1] * fix3\n    print(ans)\n    return\n  else:\n    fix2 += fix3\n    ans += now[0] * now[1]\n\n    \nans += sum(A[:(N - fix2)])\nprint(ans)\n  \n  \n  \n\n", "n,m = map(int,input().split())\na = [int(i) for i in input().split()]\nb = [[int(i) for i in input().split()] for _ in range(m)]\na.sort()\nb = sorted(b,key = lambda  x: x[1],reverse=True)\nd = []\nj = 0\nwhile (n<=len(a) or j<m) :\n    C = b[j][1]\n    B = b[j][0]\n    for i in range(B) :\n        d.append(C)\n    j += 1\n    if j>=m or len(d) > len(a) :\n        break\n\nfor i in range(min(len(d),len(a))) :\n    if a[i] < d[i] :\n        a[i] = d[i]\n\nprint(sum(a))", "from collections import defaultdict\nfrom bisect import bisect_left\nN, M = map(int,input().split())\nA = list(map(int,input().split()))\nD = defaultdict(int)\nfor i in A:\n  D[i]+=1\nfor _ in range(M):\n  a, b = map(int,input().split())\n  D[b]+=a\nD_sorted = sorted(D.items(), key=lambda x:x[0], reverse = True)\nans = 0\ncount = 0\nfor x, c in D_sorted:\n  if count+c < N:\n    ans+=x*c\n    count+=c\n  else:\n    ans+=x*(N-count)\n    break\nprint(ans)", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nBC = []\nfor _ in range(M):\n    b, c = map(int, input().split())\n    BC.append((b, c))\nBC.sort(key=lambda bc: -bc[1]) # sort from largest                                                                                                            \n\ni = 0\ndone = False\nfor b, c in BC:\n    if done:\n        break\n    for _ in range(b):\n        if i < N and A[i] < c:\n            A[i] = c\n            i += 1\n        else:\n            done = True\n            break\nprint(sum(A))", "\nfrom collections import Counter\ndef resolve():\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    CNT = Counter(A)\n\n    for i in range(M):\n        b, c = list(map(int, input().split()))\n        CNT[c] += b\n\n    cards = sorted(list(CNT.items()), key=lambda x: x[0], reverse=True)\n\n    # 0\uff5eB\u679a\u9078\u629e\u3059\u308c\u3070\u826f\u3044\uff08\u3061\u3087\u3046\u3069B\u679a\u3067\u306f\u7121\u3044\uff09\n    # \u5927\u304d\u3044\u5024\u304b\u3089\u6d88\u5316\u3057\u3066\u3044\u304f\n    ans = 0\n    for key, cnt in cards:\n        if N > cnt:\n            ans += key * cnt\n            N -= cnt\n        else:\n            # \u6b8b\u308a\u306e\u679a\u6570\u3092\u52a0\u3048\u308b\n            ans += key * N\n            print(ans)\n            return\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import math\n\nn, m = map(int, input().split(\" \"))\naL = sorted(list(map(int, input().split(\" \"))))\nbcL = sorted([list(map(int,\n                       input().split(\" \"))) for _ in range(m)],\n             key=lambda x: x[1],\n             reverse=True)\n\ncsl = 0\nfor cnt, point in bcL:\n    for i in range(cnt):\n        if csl == n or aL[csl] >= point:\n            print(sum(aL))\n            return\n        aL[csl] = point\n        csl += 1\n\nprint(sum(aL))\nreturn", "import heapq\n\nn, m = list(map(int, input().split()))\ncards = list(map(int, input().split()))\ncards.sort()\n\nqueries = []\nfor i in range(m):\n    q = list(map(int, input().split()))\n    queries.append(q)\nqueries.sort(key=lambda x: x[1])\nqueries.reverse()\n\nans = 0\npos = 0\nfor q in queries:\n    b, c = q\n    if cards[min(pos+b-1, n-1)] < c:\n        # print('a')\n        pos = pos + b\n        ans += c * (b - max(0, pos-n))\n        if pos >= n:\n            break\n    else:\n        for i in range(b):\n            if cards[pos+i] < c:\n                # print('b')\n                ans += c\n            else:\n                # print('c')\n                pos += i\n                for j in range(pos, n):\n                    ans += cards[j]\n\n                pos = n\n                break\n        break\n\nif pos < n:\n    for j in range(pos, n):\n        ans += cards[j]\n\nprint(ans)\n\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\nbc = []\nfor i in range(m):\n    bc.append(list(map(int, input().split())))\nbc.sort(key=lambda x: x[1], reverse=True)\nfor i in bc:\n    if a[0] < i[1]:\n        for j in range(i[0]):\n            if a[0] < i[1]:\n                a.append(i[1])\n                del a[0]\n            else:\n                break\n    else:\n        break\nprint((sum(a)))\n", "from collections import Counter\n\nn, m = list(map(int, input().split()))\nlis = list(map(int, input().split()))\n\ncnt = Counter(lis)\n\nfor _ in range(m):\n    b,c = list(map(int,input().split()))\n    cnt[c] += b\n\nanslis = sorted(list(cnt.items()), key=lambda x:x[0], reverse=True)\n\nans = 0\nfor key, value in anslis:\n    if n > value:\n        ans += key*value\n        n -= value\n    else:\n        ans += n*key\n        print(ans)\n        break\n", "N,M=map(int,input().split())\nimport heapq\nA=list(map(int,input().split()))\nheapq.heapify(A)\nBC=[]\nfor i in range(M):\n  B,C=map(int,input().split())\n  BC.append((B,C))\nBC.sort(key=lambda x:x[1],reverse=True)\nimport bisect\nA.sort()\nnow=0\nD=[0]*N\nfor i in range(M):\n  B=BC[i][0]\n  C=BC[i][1]\n  for j in range(now,min(now+B,N)):\n    D[j]=C\n  now+=B\n  if now>N-1:\n    break\n\nfor i in range(N):\n  a=A[i]\n  d=D[i]\n  if d>a:\n    A[i]=d\n  else:\n    break\nprint(sum(A))", "import sys\nfrom bisect import bisect_left,bisect,bisect_right\n\nicase=0\nif icase==0:\n    n,m=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    d=[]\n    cb=[[0]*2 for i in range(m)]\n    for i in range(m):\n        bi,ci=list(map(int,input().split()))\n        cb[i]=[ci,bi]\nelif icase==1:\n    n,m=3,2\n    a=[1, 4, 5]\n    cb=[[5, 1], [3, 2]]\nelif icase==3:\n    n,m=3,2\n    a=[100, 100, 100]\n    cb=[[99, 3], [99, 3]]\nelif icase==2:\n    n,m=10,3\n    a=[1, 4, 5, 5, 7, 8, 13, 33, 52, 100]\n    cb=[[30, 4], [10, 3], [4, 1]]\nelif icase==4:\n    n,m=11,3\n    a=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    cb=[[1000000000, 4], [1000000000, 3], [1000000000, 3]]\nelif icase==5:\n    f=open(r\"C:\\Users\\nishi\\999atcoder\\ABCD040-151\\ABC127D\\testcase_13_in.dat\")\n    ll=f.readline()\n    n,m=list(map(int,ll.split()))\n    ll=f.readline()\n    a=list(map(int,ll.split()))\n    d=[]\n    cb=[[0]*2 for i in range(m)]\n    for i in range(m):\n        ll=f.readline()\n        bi,ci=list(map(int,ll.split()))\n        cb[i]=[ci,bi]\n    f.close()\n    ans=99913215738299\nelif icase==6:\n    f=open(r\"C:\\Users\\nishi\\999atcoder\\ABCD040-151\\ABC127D\\testcase_12_in.dat\")\n    ll=f.readline()\n    n,m=list(map(int,ll.split()))\n    ll=f.readline()\n    a=list(map(int,ll.split()))\n    d=[]\n    cb=[[0]*2 for i in range(m)]\n    for i in range(m):\n        ll=f.readline()\n        bi,ci=list(map(int,ll.split()))\n        cb[i]=[ci,bi]\n    f.close()\n    ans=95821339675952\n\na.sort()\ncb.sort(reverse=True)\n\nif cb[0][0]<=a[0]:\n    print((sum(a)))\n    return\n    \nasum=0\nisum=0\nisumm=0\nfor i in range(m):\n    isum+=cb[i][1]\n    if isum>n:\n        if a[-1]<=cb[i][0]:\n#        print(\"A\",i)\n            asum+=cb[i][0]*(n-isumm)\n            print(asum)\n            return\n#    isum=min(isum,n)\n#    print(i,isum,a[isum-1])\n        else:\n#        print(\"C\",i)\n            ii=bisect_right(a,cb[i][0])\n            asum+=cb[i][0]*(ii-isumm)\n#        print(ii,isumm,asum)\n#        asum+=sum(a[ii:isum])\n            asum+=sum(a[ii:])\n            print(asum)\n            return\n    if a[isum-1]<=cb[i][0]:\n        asum+=cb[i][0]*cb[i][1]\n#        asum+=cb[i][0]*(isum-isumm)\n#        print(\"B\",i,isum,asum)\n        isumm=isum\n        continue\n    else:\n#        print(\"C\",i)\n        ii=bisect_right(a,cb[i][0])\n        asum+=cb[i][0]*(ii-isumm)\n#        print(ii,isumm,asum)\n#        asum+=sum(a[ii:isum])\n        asum+=sum(a[ii:])\n        print(asum)\n        return\n#        isumm=isum\n#        break\n    isumm=isum\n    \n#if isumm<n:\nasum+=sum(a[isumm:])\n        \nprint(asum)\n", "import heapq\n\nN, M = list(map(int, input().split()))\nA = list(map(int,input().split()))\n\nheapq.heapify(A)\n\nBC = [list(map(int,input().split())) for j in range(M)]\nBC.sort(key= lambda x:x[1], reverse=True)\n\nfor i in range(M):\n    B, C = BC[i]\n    for j in range(B):\n        num = heapq.heappop(A)\n        if num < C:\n            heapq.heappush(A, C)\n        else:\n            heapq.heappush(A, num)\n            break\n\nprint((sum(A)))\n", "#!/usr/bin/env python3\nn, m = list(map(int, input().split()))\n(*a, ) = list(map(int, input().split()))\na.sort()\nq = [[*list(map(int, input().split()))] for _ in range(m)]\nq.sort(key=lambda x: -x[1])\nidx = 0\nfor b, c in q:\n    for _ in range(b):\n        if idx >= n or a[idx] >= c:\n            print((sum(a)))\n            return\n        a[idx] = c\n        idx += 1\nprint((sum(a)))\n", "n, m = map(int, input().split())\naa = list(map(int, input().split()))\nsa = sorted(aa)\n\nbc = [list(map(int, input().split())) for i in range(m)]\n\nsbc = sorted(bc, key=lambda x:x[1], reverse=True)\na = 0\n\nfor j in range(m):\n    if sa[a] >= sbc[j][1]:\n      break\n    for i in range(a, min(a+sbc[j][0],n)):  \n      if sa[i] < sbc[j][1]:\n        sa[i] = sbc[j][1]\n        a += 1\n    if a >= n:\n      break\n      \nprint(sum(sa))", "\nimport sys\nfrom bisect import bisect_left,bisect,bisect_right\n\nicase=0\nif icase==0:\n    n,m=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    d=[]\n    cb=[[0]*2 for i in range(m)]\n    for i in range(m):\n        bi,ci=list(map(int,input().split()))\n        cb[i]=[ci,bi]\nelif icase==2:\n    n,m=10,3\n    a=[1, 4, 5, 5, 7, 8, 13, 33, 52, 100]\n    cb=[[30, 4], [10, 3], [4, 1]]\n\na.sort()\ncb.sort(reverse=True)\n\n#if cb[0][0]<=a[0]:\n#    print(sum(a))\n#    return\n    \nasum=0\nisum=0\nisumm=0\nfor i in range(m):\n    isum+=cb[i][1]\n    if isum>n:\n        if a[-1]<=cb[i][0]:\n            asum+=cb[i][0]*(n-isumm)\n            print(asum)\n            return\n        else:\n            ii=bisect_right(a,cb[i][0])\n            asum+=cb[i][0]*(ii-isumm)\n            asum+=sum(a[ii:])\n            print(asum)\n            return\n    if a[isum-1]<=cb[i][0]:\n        asum+=cb[i][0]*cb[i][1]\n        isumm=isum\n        continue\n    else:\n        ii=bisect_right(a,cb[i][0])\n        asum+=cb[i][0]*(ii-isumm)\n        asum+=sum(a[ii:])\n        print(asum)\n        return\n#    isumm=isum\n    \nasum+=sum(a[isum:])\n        \nprint(asum)\n", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nl = [list(map(int,input().split())) for i in range(m)]\nl = list(sorted(l,reverse=True,key=lambda x: x[1]))\nb,c = [list(i) for i in zip(*l)]\nd = [0] * n\nx = min(n,sum(b))\ny = 0\nwhile x > 0:\n    x -= 1\n    d[x] = c[y]\n    b[y] -= 1\n    if b[y] == 0:\n        y += 1\nx = a + d\nx.sort(reverse=True)\nprint(sum(x[:n]))", "def main():\n    n,m=map(int,input().split())\n    a=sorted(map(int,input().split()))\n    bc=[list(map(int,input().split())) for _ in range(m)]\n    bc.sort(key=lambda x: x[1], reverse=True)\n    i = 0\n    for b,c in bc:\n        for _ in range(b):\n            if i < len(a) and a[i] < c:\n                a[i] = c\n                i += 1\n            else:\n                print(sum(a))\n                return\n    print(sum(a))\n    \ndef __starting_point():\n    main()\n__starting_point()", "n,m = list(map(int,input().split()))\nls = list(map(int,input().split()))\ndi = [list(map(int,input().split())) for _ in range(m)]\nfi = []\nfor i,j in di:\n    fi.append([j,i])\nfor k in ls:\n    fi.append([k,1])\nfi.sort(reverse=True)\nans = 0\ncnt = 0\nhow = 0\nwhile True:\n    if how + fi[cnt][1] < n:\n        how += fi[cnt][1]\n        ans += fi[cnt][1]*fi[cnt][0]\n    else:\n        ans += (n-how)*fi[cnt][0]\n        break\n    cnt += 1\nprint(ans)\n\n", "def main():\n    N, M = [int(i) for i in input().split()]\n    A = [int(i) for i in input().split()]\n\n    A.sort()\n\n\n    bc = [[int(i) for i in input().split()] for _ in range(M)]\n    bc.sort(key=lambda x: x[1])\n\n\n    ai = N - 1\n    mi = M - 1\n    pos = 0\n    ans = 0\n    for _ in range(N):\n        if (A[ai] > bc[mi][1]) | (mi < 0):\n            pos += 1\n            ans += A[ai]\n            ai -= 1\n        elif pos + bc[mi][0] >= N:\n            ans += bc[mi][1] * (N - pos)\n            break\n        else:\n            ans += bc[mi][0] * bc[mi][1]\n            pos += bc[mi][0]\n            mi -= 1\n        if pos >= N:\n            break\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nA = Counter(A)\n\nfor _ in range(M):\n    b, c = map(int, input().split())\n    A[c] += b\n\nA = sorted(A.items(), key=lambda x: x[0], reverse=True)\n\nans = 0\nfor key, value in A:\n    if N - value >= 0:\n        ans += key * value\n        N -= value\n    else:\n        ans += N * key\n        break\n\nprint(ans)", "N,M=map(int,input().split())\nA=list(map(int,input().split()))\ncards=[list(map(int,input().split())) for _ in range(M)]\ncards = sorted(cards, key=lambda x: x[1], reverse=True)\n \ncnt=0\n \nfor i in cards:\n  A+=[i[1]]*i[0]\n  cnt+=i[0]\n  if cnt>=N:\n    break\nA.sort(reverse=True)\nprint(sum(A[:N]))", "def main():\n    import sys\n    input = sys.stdin.readline\n    n,m = map(int,input().split())\n    A = list(map(int,input().split()))\n    BC = [list(map(int,input().split())) for _ in range(m)]\n\n    BC = sorted(BC,key=lambda x:(x[1]),reverse=True)\n    append_list = []\n    for b,c in BC:\n        if len(append_list)>=n:\n            break\n        append_list+=[c]*b\n    A+=append_list\n    A.sort(reverse=True)\n    print(sum(A[:n]))\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\ndetails = list(map(int,input().split()))\n\nN = details[0]\nM = details[1]\n\ncards =  list(map(int,input().split()))\n\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab = sorted(ab, key=lambda x: x[1], reverse=True)\n\ncards = deque(sorted(cards, reverse = True))\n\ncounter = 0\nfor i in range(M):\n    for j in range(ab[i][0]):\n        if ab[i][1] > cards[-1]:\n            cards.pop()\n            cards.appendleft(ab[i][1])\n            counter += 1\n            if counter == N:\n                break\n        else:\n            break\n    if counter == N:\n        break\nprint(sum(cards))", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nBC = [list(map(int,input().split())) for _ in range(M)]\n\nA.sort()\nBC.sort(key=lambda x: x[1], reverse=True)\n\nk = 0\nfor b,c in BC:\n  i = 0\n  for j in range(b):\n    if A[k] < c and i <= b:\n      A[k] = c      \n      if k == N - 1:\n        break\n      k += 1\n      i += 1\n      \n  if k == N - 1 or A[k] >= c:\n    break\n    \nprint(sum(A))", "from collections import deque\n\ndetails = list(map(int,input().split()))\n\nN = details[0]\nM = details[1]\n\ncards =  list(map(int,input().split()))\n\nab = [list(map(int, input().split())) for _ in range(M)]\n\nab = sorted(ab, key=lambda x: x[1], reverse=True)\n\ncards = deque(sorted(cards))\n\ncounter = 0\nfor i in range(M):\n    for j in range(ab[i][0]):\n        if ab[i][1] > cards[0]:\n            cards.popleft()\n            cards.append(ab[i][1])\n            counter += 1\n            if counter == N:\n                break\n        else:\n            break\n    if counter == N:\n        break\nprint(sum(cards))", "from collections import Counter\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nbc = [map(int, input().split()) for i in range(m)]\nd1 = Counter(a)\nd2 = {}\nans = 0\n\nfor i, j in bc:\n    if j in d2:\n        ref = d2[j]\n        d2[j] = ref + i\n    else:\n        d2[j] = i\n\nd = Counter(d1) + Counter(d2)\nkey = sorted(d)[::-1]\n\nfor i in key:\n    qty = d[i]\n    if qty < n:\n        ans += qty*i\n        n -= qty\n    else:\n        ans += n*i\n        break\n\nprint(ans)", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nB = [list(map(int,input().split())) for _ in range(M)]\nB.sort(key = lambda x:x[1])\nB = list(reversed(B))\nA.sort()\n\nnum = 0\nfor i in range(M):\n    for j in range(B[i][0]):\n        if num > N-1:\n            break\n        if A[num] < B[i][1]:\n            A[num] = B[i][1]\n            num += 1\n        else:\n            break\n\nprint(sum(A))", "import heapq\n\nN,M = map(int,input().split())\nb = list(map(int,input().split()))\na = []\n\nfor i in range(N):\n\ta.append((b[i],1))\n\nfor i in range(M):\n\tbb,cc = map(int,input().split())\n\ta.append((cc,bb))\n\na.sort()\na.reverse()\n\n#for j in a:\n#\tprint(j)\n\ncnt = 0\nans = 0\n\nfor i in range(N):\n\tif cnt + a[i][1] > N:\n\t\tans += a[i][0]*(N-cnt)\n\t\tbreak\n\n\tans += a[i][0]*a[i][1]\n\tcnt += a[i][1]\n\nprint(ans)", "import bisect\nimport numpy as np\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nA = np.array(A, dtype=np.int64)\n\nlst = [list(map(int, input().split())) for _ in range(M)]\nlst = sorted(lst, key=lambda x:x[1], reverse=True)\n\nx = 0\nfor i in range(len(lst)):\n    idx = bisect.bisect_left(A[x:], lst[i][1])\n    \n    if(A[x+idx-1] <= lst[i][1]):     \n        if(lst[i][0] >= idx):\n            A[x:(x+idx)] = lst[i][1]\n            x = x+idx\n        else:\n            A[x:(x+lst[i][0])] = lst[i][1]\n            x = x + lst[i][0]\n    else:\n        break\n    \nprint(sum(A))  ", "n,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\nQ=[]\nfor i in range(m):\n    b,c=list(map(int,input().split()))\n    Q.append([b,c])\n\nQ=sorted(Q, key=lambda x:x[1], reverse=1)\nkae=0\n\nd=[-1]*(n)\nnow=0\nfor l in Q:\n    b,c=l\n    if n-now<b:\n        d[now:]=[c]*(n-now)\n        break\n    d[now:now+b]=[c]*b\n    now+=b\n\n#print(d)\nans=sum(A)\nnow=ans\nfor kae in range(1,n+1):\n    now+=d[kae-1]\n    now-=A[kae-1]\n    ans=max(ans,now)\nprint(ans)\n", "#import math\n#import itertools\n#import numpy as np\n#from collections import deque\n\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\ndef do():\n    n,m=INTM()\n    A=LIST()\n    bcs=[]\n    for i in range(m):\n        temp=LIST()\n        bcs.append(temp)\n    A=sorted(A)\n    bcs=sorted(bcs, key=lambda x: x[1], reverse=True)\n    itr=-1\n    flg=False\n    #print(A)\n    for b,c in bcs:\n        if itr+b>n-1:\n            flg=True\n        if flg:\n            for i in range(itr+1,n):\n                if A[i]<c:\n                    A[i]=c\n                else:\n                    itr=10**9\n                    break\n        else:\n            if A[itr+b]<c:\n                A[itr+1:itr+b+1]=[c]*b\n            else:\n                for i in range(itr+1,itr+b+1):\n                    if A[i]<c:\n                        A[i]=c\n                    else:\n                        itr=10**9\n                        break\n\n        itr+=b\n\n        if itr>n-1:\n            break\n    print(sum(A))\n    #print(A)\n\n    \n\n\ndef __starting_point():\n    do()\n__starting_point()", "\nimport sys\nfrom bisect import bisect_left,bisect,bisect_right\n\nicase=0\nif icase==0:\n    n,m=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    d=[]\n    cb=[[0]*2 for i in range(m)]\n    for i in range(m):\n        bi,ci=list(map(int,input().split()))\n        cb[i]=[ci,bi]\nelif icase==2:\n    n,m=10,3\n    a=[1, 4, 5, 5, 7, 8, 13, 33, 52, 100]\n    cb=[[30, 4], [10, 3], [4, 1]]\n\na.sort()\ncb.sort(reverse=True)\n    \nasum=0\nisum=0\nisumm=0\nfor i in range(m):\n    isum+=cb[i][1]\n    if isum>n:\n        if a[n-1]<=cb[i][0]:\n            asum+=cb[i][0]*(n-isumm)\n            print(asum)\n            return\n        else:\n            ii=bisect_right(a,cb[i][0])\n            asum+=cb[i][0]*(ii-isumm)\n            asum+=sum(a[ii:])\n            print(asum)\n            return\n    if a[isum-1]<=cb[i][0]:\n        asum+=cb[i][0]*cb[i][1]\n        isumm=isum\n        continue\n    else:\n        ii=bisect_right(a,cb[i][0])\n        asum+=cb[i][0]*(ii-isumm)\n        asum+=sum(a[ii:])\n        print(asum)\n        return\n    \nasum+=sum(a[isum:])\n        \nprint(asum)\n", "n, m  = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ncb = []\nfor i in range(m):\n  b, c = map(int, input().split())\n  cb.append([c,b])\ncb.sort(reverse=True)\n\nj = 0\nfor i in range(m):\n  k = 0\n  while k<cb[i][1] and k+j<n and a[k+j]<cb[i][0]:\n    a[k+j] = cb[i][0]\n    k += 1\n  j += k\n  if j == n:\n    break\n    \nprint(sum(a))", "n,m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nbc = sorted([list(map(int, input().split())) for i in range(m)], key =lambda x:x[1])\nbc.reverse()\n\nflg = 0\ncnt = 0\n\nfor i in range(n):\n  if flg < m and bc[flg][1] >a[i]:\n    a[i] = bc[flg][1]\n    cnt +=1\n    if cnt == bc[flg][0]:\n      flg += 1\n      cnt = 0\n  else:\n      break\n\nprint(sum(a))", "import sys\nN,M=map(int,sys.stdin.readline().split())\nL=sorted(list(map(lambda x: (1,int(x)), sys.stdin.readline().split()))\n         +[tuple(map(int, sys.stdin.readline().split())) for _ in range(M)]\n         ,key=lambda x: x[1],reverse=True)\nans,k=0,0\nfor n,a in L:\n  if n+k>=N:\n    ans+=a*(N-k)\n    break\n  else:\n    ans+=a*n\n    k+=n\nprint(ans)", "from collections import defaultdict\n\ndic = defaultdict(int)\n\ndetails = list(map(int,input().split()))\n\nN = details[0]\nM = details[1]\n\ncards =  list(map(int,input().split()))\n\nab = [list(map(int, input().split())) for _ in range(M)]\n\n\nfor i in range(N):\n    dic[cards[i]] += 1\n\nfor i in range(M):\n    dic[ab[i][1]] += ab[i][0]\n\nlst = sorted(dic.keys())\nans = 0\nwhile (N):\n    if dic[lst[-1]] > 0:\n        dic[lst[-1]] -= 1\n        ans += lst[-1]\n        N-=1\n    else:\n        lst.pop()\nprint(ans)", "N,M = map(int,input().split())\nA = list(map(int,input().split()))\nBC = [list(map(int,input().split())) for m in range(M)]\nBC = sorted(BC,key=lambda x:x[1])[::-1]\n\nfor b,c in BC:\n  A.extend(b*[c])\n  if 2*N<len(A):\n    break\n\nA = sorted(A)[::-1]\nprint(sum(A[:N]))", "n,m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nbc = sorted([list(map(int, input().split())) for i in range(m)], key =lambda x:x[1])\nbc.reverse()\n\nflg = 0\ncnt = 0\n\nfor i in range(n):\n  if bc[flg][1] >a[i] and flg < m:\n    a[i] = bc[flg][1]\n    cnt +=1\n    if cnt == bc[flg][0]:\n      flg += 1\n      cnt = 0\n      if flg == m:\n        break\n  else:\n      break\n\nprint(sum(a))", "n,m=map(int,input().split())\nA=list(map(int,input().split()))\nbc = [list(map(int,input().split())) for _ in range(m)]\nbc = sorted(bc,key=lambda x:-x[1])\n\nsub = []\nfor i in range(m):\n   sub += [bc[i][1]] * bc[i][0]\n   if len(sub) > n:\n       break\n\nA += sub\n\nprint(sum(sorted(A,reverse=True)[:n]))", "#!/usr/bin/env python3\n\n#import\n#import math\n#import numpy as np\n#= int(input())\n#= input()\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nBC= [list(map(int, input().split())) for _ in range(M)]\n\nA.sort(reverse=True)\n\nBC.sort(key=lambda x: x[1], reverse=True)\nans = 0\ncnt = 0\nwhile cnt < N:\n    if len(BC) > 0 and A[0] < BC[0][1]:\n        bc = BC.pop(0)\n        ans += bc[1] * min(bc[0], N - cnt)\n        cnt += bc[0]    \n    else:\n        ans += A.pop(0)\n        cnt += 1\n\nprint(ans)\n\n\n\n", "N, M = map(int, input().split())\nA_list = sorted(list(map(int, input().split())))\n# C \u306e\u5927\u304d\u3055\u9806\u306b\nBC_list = sorted([list(map(int, input().split())) for _ in range(M)], key=lambda x:x[1], reverse=True)\nchange_list_sorted = []\nfor m in range(M):\n    b, c = BC_list[m]\n    for _ in range(b):\n        change_list_sorted.append(c)\n    if len(change_list_sorted) > N:\n        break\nchange_cnt = 0\nfor i, (change_val, a) in enumerate(zip(change_list_sorted, A_list)):\n    if a <= change_val:\n        A_list[i] = change_val\n    else:\n        break\nprint(sum(A_list))", "n,m=map(int, input().split())\nA=[]\na=list(map(int, input().split()))\nfor i in  range(n):\n  A.append([a[i], 1])\n  \nl=[]\nfor i in range(m):\n  b,c=map(int, input().split())\n  l.append([c,b])\n\nA.extend(l)\nA.sort()\nA.reverse()\nB=[]\n\nj=0\ncnt=-1\nwhile cnt<n:\n  B.extend([A[j][0]]*A[j][1])\n  cnt=cnt+A[j][1]\n  if cnt>=n:\n    del B[n:]\n  j=j+1\n\nprint(sum(B))", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nD = {}\nfor a in A:\n    if a in D:\n        D[a] += 1\n    else:\n        D[a] = 1\n\nfor i in range(M):\n    B, C = map(int, input().split())\n    if C in D:\n        D[C] += B\n    else:\n        D[C] = B\n\nK = sorted(D.keys(), reverse=True)\nans = 0\ncnt = N\nfor k in K:\n   a = min(D[k], cnt)\n   ans += k * a\n   cnt -= a\n   if cnt == 0: break\nprint(ans)", "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nbc = []\nfor i in range(m):\n    bc.append(list(map(int, input().split())))\nbc.sort(key=lambda x: x[1], reverse=True)\nfor i in bc:\n    if a[0] < i[1]:\n        for j in range(i[0]):\n            if a[0] < i[1]:\n                a.append(i[1])\n                del a[0]\n            else:\n                break\n    else:\n        break\nprint(sum(a))", "n,m = map(int,input().split())\nA = list(map(int,input().split()))\nD = [(A[i],1) for i in range(n)]\n\nfor i in range(m):\n    b,c = map(int,input().split())\n    D.append((c,b))\n\nD.sort(reverse = True)\n\nans, left = 0, n\n\nfor (i,j) in D:\n    use = min(j, left)\n    ans += use * i\n    left -= use\nprint(ans)", "from collections import Counter\n\n\nN, M = [int(x) for x in input().split()]\nCnter = Counter([int(x) for x in input().split()])\nfor i in range(M):\n    b, c = [int(x) for x in input().split()]\n    Cnter[c] += b\nV = sorted(list(Cnter.most_common()))\ncnt = 0\nans = 0\nfor v in V[::-1]:\n    ans += v[0] * min(v[1], N - cnt)\n    cnt += v[1]\n    if cnt >= N:\n        break\nprint(ans)\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\nbc = []\nfor _ in range(m):\n    b, c = map(int, input().split())\n    bc.append([c, b])\na.sort()\nbc.sort(reverse = True)\nx = [0] * n\ni, j = 0, 0\nwhile i < n:\n    for _ in range(bc[j][1]):\n        x[i] = bc[j][0]\n        i += 1\n        if i == n:\n            break\n    j += 1\n    if j == m:\n        break\nans = 0\nfor i in range(n):\n    ans += max(a[i], x[i])\nprint(ans)", "from itertools import accumulate\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nBC = [tuple(map(int, input().split())) for _ in range(M)]\n\nA = sorted(A)\nBC = sorted(BC, key = lambda x: x[1], reverse=True)\n\ntrade = []\nlen_ = 0\nfor b, c in BC:\n    if len_ >= N:\n        break\n    for _ in range(b):\n        if len_ >= N:\n            break\n        trade.append(c)\n        len_ += 1\n\nans = 0\nfor i in range(N):\n    if i >= len_:\n        ans += A[i]\n    else:\n        ans += max(trade[i], A[i])\nprint(ans)\n", "n,m = map(int,input().split())\n\nA = list(map(int,input().split()))\n\nl = []\n\nfor i in range(m):\n  b,c = map(int,input().split())\n  l.append([c,b])\n\nl.sort()\nl = l[::-1]\n\nL = []\ncn = 0\nfor b,c in l:\n  # print(b,c)\n  if cn > n:break\n  c = min(c,10**5+10)\n  L += [b]*c\n  cn += c\n\nL += A\n\nL.sort()\nL = L[::-1]\n# print(L)\nprint(sum(L[:n]))", "def main():\n\tN, M = [int(x) for x in input().split(\" \")]\n\tA = [int(a) for a in input().split(\" \")]\n\tA.sort()\n\toverwrite = []\n\tfor i in range(M):\n\t\tB, C = [int(x) for x in input().split(\" \")]\n\t\toverwrite.append({\n\t\t\t\"count\": B,\n\t\t\t\"number\": C\n\t\t})\n\toverwrite.sort(key=lambda o: -o[\"number\"])\n\tj = 0\n\tk = 0\n\tflag = False\n\twhile not flag and j < len(A) and k < len(overwrite):\n\t\to = overwrite[k]\n\t\tfor m in range(o[\"count\"]):\n\t\t\tif j < len(A) and A[j] <= o[\"number\"]:\n\t\t\t\tA[j] = o[\"number\"]\n\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tflag = True\n\t\tk += 1\n\n\tprint((sum(A)))\n\nmain()\n", "from heapq import *\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nbc = [list(map(int,input().split()))for _ in range(m)]\n\nheapify(a)\nbc = sorted(bc,key=lambda x:x[1],reverse=True)\n\nfor b,c in bc:\n    for i in range(b):\n        tmp = heappop(a)\n        if tmp >= c:\n            heappush(a,tmp)\n            break\n        else:\n            heappush(a,c)\n\nprint(sum(a))", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nc = [[] for _ in range(m)]\nfor i in range(m):\n    c[i] = list(map(int, input().split()))\na.sort()\nc.sort(key=lambda x: x[1], reverse=True)\nans = sum(a)\nsa = 0\ncnt = 0\nr = c[0][0]\nfor i, v in enumerate(a):\n    if r <= i and cnt <= m - 2:\n        cnt += 1\n        r += c[cnt][0]\n    if r > i and v < c[cnt][1]:\n        ans += abs(c[cnt][1] - v)\n    else:\n        break\nprint(ans)\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ncnt = {}\n\nfor i in range(n):\n    if a[i] in cnt:\n        cnt[a[i]] += 1\n    else:\n        cnt[a[i]] = 1\n\nfor i in range(m):\n    b, c = list(map(int, input().split()))\n\n    if c in cnt:\n        cnt[c] += b\n    else:\n        cnt[c] = b\n\ncnts = sorted(cnt.items())\ncnt = 0\ntot = 0\nlast = (0, 0)\n\nwhile cnt < n:\n    last = cnts.pop()\n    tot += last[0] * last[1]\n    cnt += last[1]\n\ntot -= (cnt-n)*last[0]\nprint(tot)", "N,M=map(int,input().split())\nL=list(map(lambda x: (1,int(x)), input().split()))\nfor _ in range(M):\n  L.append(tuple(map(int,input().split())))\nL=sorted(L,key=lambda x: x[1],reverse=True)\nans,k=0,0\nfor n,a in L:\n  if n+k>=N:\n    ans+=a*(N-k)\n    break\n  else:\n    ans+=a*n\n    k+=n\nprint(ans)", "from collections import deque\n\nn, m = map(int, input().split())\na = sorted(list(map(int, input().split())))\na = deque(a)\nl = []\nans = []\n\nfor i in range(m):\n    b, c = map(int, input().split())\n    l.append([c, b])\n\nl = sorted(l)[::-1]\nref = a.popleft()\n\nfor num, cnt in l:\n    while ref >= num:\n        ans.append(ref)\n        if len(a) == 0:\n            print(sum(ans))\n            return\n        ref = a.popleft()\n\n    while cnt > 0:\n        if ref < num:\n            ans.append(num)\n            cnt -= 1\n            if len(a) == 0:\n                print(sum(ans))\n                return\n            ref = a.popleft()\n        else:\n            break\n\nans.append(ref)\n\nwhile a:\n    ref = a.popleft()\n    ans.append(ref)\n\nprint(sum(ans))", "from collections import deque\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nbc = [tuple(map(int,input().split())) for _ in range(M)]\nfor x in A:\n    bc.append((1,x))\nbc.sort(key=lambda x:x[1], reverse=True)\nA = []\nfor b,c in bc:\n    while len(A) < N and b > 0:\n        b -= 1\n        A.append(c)\n    if len(A) == N:\n        break\nA.sort(reverse=True)\nprint(sum(A))", "N,M=map(int,input().split())\narr=[int(x) for x in input().split()]\ns=[list(map(int,input().split())) for y in range(M)]\ns.sort(key=lambda z: z[1], reverse=True)\n\nsum_a=0\nfor a,b in s:\n    arr+=[b]*a\n    sum_a+=a\n    if sum_a>=N:\n        break\n\nlst=sorted(arr)\nans=sum(lst[-N:])\nprint(ans)", "def integerCards(n, m, alist, bclist):\n\n    count = 0\n    alist.sort()\n    bclist.sort(key=lambda x: x[1], reverse=True)\n\n    for b, c in bclist:\n        for _ in range(b):\n            if alist[count] < c:\n                alist[count] = c\n                count += 1\n            else:\n                break\n            if count == n:\n                break\n        if count == n:\n            break\n\n    return sum(alist)\n\ndef main():\n    n, m = map(int, input().split())\n    alist = list(map(int, input().split()))\n    bclist = [list(map(int, input().split()))for i in range(m)]\n    print(integerCards(n, m, alist, bclist))\n\ndef __starting_point():\n    main()\n__starting_point()", "N,M = map(int,input().split())\nlsA = list(map(int,input().split()))\nlsM = []\nfor i in range(M):\n    B,C = map(int,input().split())\n    lsM.append([B,C])\nlsA.sort()\nlsM.sort(key=lambda x:-x[1])\nk = 0\nfor i in range(M):\n    B = lsM[i][0]\n    C = lsM[i][1]\n    ii = 1\n    for j in range(B):\n        if lsA[k] < C and ii <= B:\n            lsA[k] = C\n            if k == N-1:\n                break\n            k += 1\n            ii += 1        \n    if k == N-1 or lsA[k] >= C:\n        break\nprint(sum(lsA))", "import collections\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    bc = [list(map(int, input().split())) for _ in range(m)]\n    A.sort()\n    bc.sort(key=lambda x: x[1], reverse=True)\n    i, j = 0, 0\n\n    while i < n and j < m:\n        if A[i] >= bc[j][1]:\n            break\n        A[i] = bc[j][1]\n        i += 1\n        bc[j][0] -= 1\n        if bc[j][0] == 0:\n            j += 1\n    print((sum(A)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\ndef main():\n    N, M = list(map(int, input().split()))\n    n_list = list(map(int, input().split()))\n    n_dic = {}\n    for n in n_list:\n        n_dic.setdefault(n, 0)\n        n_dic[n] += 1\n    \n    for i in range(M):\n        b, c = list(map(int, input().split()))\n        n_dic.setdefault(c, 0)\n        n_dic[c] += b\n    \n    com_list = []\n\n    for score, num in list(n_dic.items()):\n        heapq.heappush(com_list, (-score, num))\n    \n    taken = 0\n    result = 0\n\n    while True:\n        score, num = heapq.heappop(com_list)\n        score = -score\n        if N - taken > num:\n            result += score * num\n            taken += num\n        else:\n            result += score * (N - taken)\n            break\n    \n    print(result)\n\nmain()\n", "from collections import defaultdict\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA = [(A[i], 1) for i in range(N)]\n\nchanges = [None] * M\nfor i in range(M):\n    b, c = list(map(int, input().split()))\n    changes[i] = (c, b)\n\nallVals = A + changes\n\nallVals.sort(key = lambda x:x[0], reverse = True)\n# print(allVals)\n\ni = 0\nj = -1\nres = 0\nwhile True:\n    j += 1\n    res += allVals[j][0] * allVals[j][1]\n    i += allVals[j][1]\n\n    if i >= N:\n        res -= allVals[j][0] * (i - N)\n        break\n\n\n\nprint(res)\n", "n, m = map(int, input().split())\na = sorted(list(map(int, input().split())))\nrep = sorted([tuple(map(int, input().split())) for i in range(m)], key= lambda x: -x[1])\ni = 0\nfor b, c in rep:\n    while i < n and b:\n        if a[i] < c:\n            a[i] = c\n            i += 1\n            b -= 1\n        else:\n            break\nprint(sum(a))", "n, m = map(int, input().split())\nl = [(a, 1) for a in list(map(int, input().split()))]\nfor i in range(m):\n    b, c = map(int, input().split())\n    l.append((c, b))\nl = sorted(l)[::-1]\nans = 0\n\nfor i, j in l:\n    if j < n:\n        ans += i*j\n        n -= j\n    else:\n        ans += n*i\n        break\n\nprint(ans)", "n,m=map(int,input().split())\n\na=list(map(int,input().split()))\n\na.sort()\n\nbc=[]\nfor i in range(m):\n    bc.append(list(map(int,input().split())))\n\nbc.sort(key=lambda x:x[1],reverse=True)\n\nlis=[]\nfor i in range(m):\n    if len(lis)>=n:\n        break\n    for _ in range(bc[i][0]):\n        lis.append(bc[i][1])\n\nwhile len(lis)<n:\n    lis.append(0)\n\ns=0\nfor i in range(n):\n    s+=max(a[i],lis[i])\n\nprint(s)", "n,m=map(int,input().split())\nA=sorted(list(map(int,input().split())))\nBC=[list(map(int,input().split())) for i in range(m)]\nBC=sorted(BC,reverse=True,key=lambda x: x[1])\nflag=0\nt=0\nfor i in range(m):\n  if flag==1:\n    break\n  for j in range(t,n):\n    if BC[i][1]>A[j]:\n      A[j]=BC[i][1]\n      BC[i][0]-=1\n      t=j+1\n      if BC[i][0]==0:\n        break\n    else:\n      flag=1\n      break\nprint(sum(A))", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\ncb=[]\nfor i in range(m):\n    b, c = list(map(int, input().split()))\n    cb.append([c,b])\ncb.sort(reverse=True)\nk=0\nfor i in range(m):\n    j=0\n    while j<cb[i][1] and k+j<n and a[k+j]<cb[i][0]:\n        a[k+j] = cb[i][0]\n        j+=1\n    k+=j\n    if k==n:\n        break\nprint((sum(a)))\n", "import sys\nn, m = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nb = []\n\nfor _ in range(m):\n    b += [list(map(int, input().split()))]\nb = sorted(b, key=lambda x: x[1], reverse=True)\n\nfor i in range(m):\n    for j in range(b[i][0]):\n        if a[0] < b[i][1]:\n            a.pop(0)\n            a.append(b[i][1])\n        else:\n            print((sum(a)))\n            return\nprint((sum(a)))\n            \n\n", "import sys, math\nfrom functools import lru_cache\nimport datetime\nsys.setrecursionlimit(500000)\nMOD = 10**9+7\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return map(int, input().split())\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\n\ndef main():\n    N, M = mi()\n    A = list(mi())\n    A.sort()\n    BC = [list(mi()) for i in range(M)]\n    BC.sort(reverse=True, key=lambda x: x[1])\n\n    D = []\n\n    for i in range(M):\n        for j in range(BC[i][0]):\n            D.append(BC[i][1])\n            if len(D) == N:\n                break\n        if len(D) == N:\n            break\n\n    while len(D) < N:\n        D.append(0)\n\n    print(sum(max(A[i], D[i]) for i in range(N)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\nB_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\nB_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\ncnt = 0\nfor l in B_C:\n    for i in range(l[0]):\n        A.append(l[1])\n        cnt += 1\n        if cnt > N:\n            break\n    else:\n        continue\n    break\n\nA = sorted(A, reverse=True)\n\nprint(sum(A[:N]))", "from collections import Counter\n\nn, m = map(int, input().split())\na = Counter(list(map(int, input().split())))\nbc = [map(int, input().split()) for i in range(m)]\nb = {}\nans = 0\n\nfor i, j in bc:\n    if j in b:\n        ref = b[j]\n        b[j] = ref + i\n    else:\n        b[j] = i\n\nd = Counter(a) + Counter(b)\nkeys = sorted(d)[::-1]\n\nfor key in keys:\n    qty = d[key]\n    if qty < n:\n        ans += qty*key\n        n -= qty\n    else:\n        ans += n*key\n        break\n\nprint(ans)", "#!/usr/bin/env python3\n\n# input = stdin.readline\n\ndef solve(n,m,a,queries):\n  res = 0\n  cnt = 0\n  queries += [[1,x] for x in a]\n  queries = list(sorted(queries,key=lambda x: x[1],reverse=True))\n  for query in queries:\n    if cnt >= n:\n      break\n    else:\n      res += query[1] * min(query[0],n-cnt)\n      cnt += query[0]\n  return res\n\n\n\ndef main():\n  N,M = list(map(int,input().split()))\n  a = list(map(int,input().split()))\n  queries = list(list(map(int,input().split())) for _ in range(M))\n  print((solve(N,M,a,queries)))\n\ndef __starting_point():\n  main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nimport bisect\nn,m = map(int,input().split())\nA = list(map(int,input().split()))\nA.sort()\n\nminA = A[0]\nQuery = []\nfor _ in range(m):\n    b,c = map(int,input().split())\n    if c > minA:\n        Query.append([b,c])\nQuery = sorted(Query, key=lambda x:(x[1], x[0]), reverse=True)\n\nans = 0\nindex = 0\nfor b,c in Query:\n    if index >= n:\n        break\n    #print(\"----\")\n    cnt = 0\n    Flag = True\n    while Flag:\n        #print(A,b,c,index)\n        if A[index] < c:\n            A[index] = c\n            cnt += 1\n            index += 1\n            if (cnt >= b) or (index >= n):\n                Flag = False\n        else:\n            Flag = False\n    '''\n    #A.sort()\n    if A[0] >= c:\n        break\n    else:\n        index = min(bisect.bisect_left(A,c),b)\n        if index > len(A):\n            ans += c * len(A)\n            break\n        else:\n            ans += c * index\n            A = A[index:]\n    print(A)\n    '''\nprint(sum(A))", "\nurl = \"https://atcoder.jp//contests/abc127/tasks/abc127_d\"\n\n\nimport collections\n\ndef main2():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    sumval = sum(a)\n    a_counter = collections.Counter(a)\n    bc = {}\n    for _ in range(m):\n        b, c = list(map(int, input().split()))\n        bc.setdefault(c, 0)\n        bc[c] += b\n    a_tmp = sorted(list(a_counter.items()), key=lambda x:x[0])\n    bc_tmp = sorted(list(bc.items()), key=lambda x:x[0], reverse=True)\n    a_sort = [list(a_tmp[0])]\n    bc_sort = [list(bc_tmp[0])]\n    count, aidx, bidx = 0, 0, 0\n    while count <= m:\n        if a_sort[aidx][0] >= bc_sort[bidx][0]:\n            break\n        tmp = min(a_sort[aidx][1], bc_sort[bidx][1])\n        sumval = (sumval - (a_sort[aidx][0]*tmp)) + (bc_sort[bidx][0]*tmp)\n        a_sort[aidx][1] -= tmp\n        bc_sort[bidx][1] -= tmp\n        if a_sort[aidx][1] == 0:\n            aidx += 1\n            if aidx >= len(a_tmp): break\n            a_sort.append(list(a_tmp[aidx]))\n        if bc_sort[bidx][1] == 0:\n            bidx += 1\n            if bidx >= len(bc_tmp): break\n            bc_sort.append(list(bc_tmp[bidx]))\n            count += 1\n    print(sumval)\n\n\ndef __starting_point():\n    main2()\n\n__starting_point()", "n,m= list(map(int,input().split()))\n\na_list = list(map(int,input().split()))\na_list = sorted(a_list)\n# print(a_list)\ndic = {}\n\nfor _ in range(m):\n    b,c = list(map(int,input().split()))\n    dic[c]=dic.get(c,0) + b\n\ncount=0\nfor c in sorted(dic,reverse=True):\n    for _ in range(dic[c]):\n        if a_list[count] < c:\n            a_list[count] = c\n        else:\n            print((sum(a_list)))\n            return\n        count+=1 \n        if count == n:\n            print((sum(a_list)))\n            return\n\nprint((sum(a_list)))\n            \n", "from collections import Counter\n\nN, M = [int(_) for _ in input().split()]\nA = [int(_) for _ in input().split()]\n\nBC = [tuple([int(_) for _ in input().split()]) for _ in range(M)]\n\nX = Counter(A)\nfor a in X:\n    BC.append((X[a], a))\nBC.sort(key=lambda x: x[1], reverse=True)\n\nans = 0\nk = N\nfor b, c in BC:\n    v = min(k, b)\n    ans += v * c\n    k -= v\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = []\n\nfor i in range(n):\n  s.append((a[i], 1))\n\nfor _ in range(m):\n  b, c = list(map(int, input().split()))\n  s.append((c, b))\n#  for j in range(b):\n#    a.append(c)\n\ns.sort(reverse=True)\nidx = 0\nsum = 0\nfor i in range(n):\n  if idx + s[i][1] > n:\n    sum += s[i][0] * (n-idx)\n    break\n\n  sum += s[i][0] * s[i][1]\n  idx += s[i][1]\n\n\n# for i in range(l-n, l):\n#  sum += a[i]\n\nprint(sum)\n\n", "from collections import deque\nN,M=map(int,input().strip().split())\nA=list(map(int,input().strip().split()))\nBC=[list(map(int,input().strip().split())) for _ in range(M)]\nA.sort()\nA=deque(A)\nBC.sort(key=lambda x:x[1],reverse=True)\n\nans=0\nfin=False\nfor m in range(M):\n    if fin==True:\n        break\n    i=0\n    while i<BC[m][0]:\n        if A:\n            if BC[m][1]>=A[0]:\n                ans+=BC[m][1]\n                A.popleft()\n                i+=1\n            else:\n                ans+=sum(A)\n                fin=True\n                break\n        else:\n            fin=True\n            break\nif fin==False and A:\n    ans+=sum(A)\nprint(ans)", "from bisect import bisect_left\n\nN, M = map(int, input().split())\nd = dict()\nA = list(map(int, input().split()))\nfor i in range(N):\n\td[A[i]] = d.get(A[i], 0) + 1\nfor i in range(M):\n\tB, C = map(int, input().split())\n\td[C] = d.get(C, 0) + B\n\nans = 0\nkeys = sorted(list(d.keys()), reverse = True)\nfor k in keys:\n\tkosuu = min(N, d.get(k))\n\tans += k * kosuu\n\tN -= kosuu\n\tif N == 0:\n\t\tbreak\nprint(ans)", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort()\nbc = []\nfor i in range(m):\n    bc.append(list(map(int, input().split())))\nbc.sort(key=lambda x: x[1], reverse=True)\n\nfor i in bc:\n    if a[0] < i[1]:\n        for j in range(i[0]):\n            if a[0] < i[1]:\n                a.append(i[1])\n                del a[0]\n            else:\n                break\n    else:\n        break\n        \nprint((sum(a)))\n", "N, M = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())))\nBC = [list(map(int, input().split())) for _ in range(M)]\n\n# n\u756a\u76ee\u306e\u8981\u7d20\u3067\u30bd\u30fc\u30c8sort\nBC = sorted(BC, reverse=True, key=lambda x: x[1])\n\nm = A[0]\nD = []\nfor b, c in BC:\n    if c > m:\n        _ = [D.append(c) for i in range(b)]\n    else:\n        continue\n    if len(D) > N:\n        break\n\nD.append(0)\n\nfor i, d in enumerate(D):\n    if i >= N:\n        break\n    if A[i] < d:\n        A[i] = d\n    else:\n        break\n\nprint((sum(A)))\n", "n,m=map(int,input().split())\nA = list(map(int,input().split()))\nB=[]\nfor i in range(m):\n    B.append(list(map(int,input().split())))\nA.sort()\nB.sort(key=lambda B: B[1], reverse=True)\n\ni=j=0\nans = sum(A)\nwhile j<n:\n    newv = B[i][1]\n    newc = min(B[i][0],n-j)\n    if newv>A[j] :\n        for k in range(newc):\n            if newv<=A[j+k]:\n                break\n        else:\n            k+=1\n        ans+=newv*(k)-sum(A[j:j+k])\n        i+=1\n        j+=k\n    else:\n        break\n    if i>=m :\n        break\n\nprint(ans)", "from heapq import *\nn, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nh = []\nfor a in A:\n  heappush(h, ((-1) * a, 1))\nfor _ in range(m):\n  b, c = list(map(int, input().split()))\n  heappush(h, ((-1) * c, b))\n\nans = 0\nfor _ in range(len(A)):\n  c, b = heappop(h)\n  ans += (-1) * c\n  if b > 1:\n    heappush(h, (c, b - 1))\nprint(ans)\n\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# \u554f\u984c\uff1ahttps://atcoder.jp/contests/abc127/tasks/abc127_d\n# \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\u3000\u89e3\u8aac\u3092\u898b\u306a\u304c\u3089\u5b9f\u88c5\n\n\nimport heapq\n\nn, m = list(map(int, input().strip().split()))\n\nq = []\na = list(map(int, input().strip().split()))\nfor i in range(n):\n    heapq.heappush(q,(a[i]*(-1), 1))\nfor i in range(m):\n    b, c = list(map(int, input().strip().split()))\n    heapq.heappush(q,(c*(-1), b))\n\nres = 0\nfor _ in range(n):\n    c, b = heapq.heappop(q)\n    res += c * (-1)\n    if b > 1:\n        b -= 1\n        heapq.heappush(q, (c, b))\n\nprint(res)\n", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nfrom collections import Counter\nimport copy\ncounter = Counter(A)\nfor _ in range(M):\n    B, C = map(int, input().split())\n    counter[C] = counter.get(C, 0) + B\n\nans = 0\nfor x in sorted(counter, reverse=True):\n    if counter[x] >= N:\n        ans += x * N\n        break\n    else:\n        ans += x * counter[x]\n        N -= counter[x]\nprint(ans)", "N,M=map(int,input().split())\nL=sorted(list(map(lambda x: (1,int(x)), input().split()))\n         +[tuple(map(int,input().split())) for _ in range(M)]\n         ,key=lambda x: x[1],reverse=True)\nans,k=0,0\nfor n,a in L:\n  if n+k>=N:\n    ans+=a*(N-k)\n    break\n  else:\n    ans+=a*n\n    k+=n\nprint(ans)", "N,M=map(int,input().split())\nA=list(map(int,input().split()))\ncards=[list(map(int,input().split())) for _ in range(M)]\ncards = sorted(cards, key=lambda x: x[1], reverse=True)\n\ncnt=0\n\nfor i in cards:\n  A+=[i[1]]*i[0]\n  cnt+=i[0]\n  if cnt>=N:\n    break\nA.sort(reverse=True)\nprint(sum(A[:N]))", "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nD = [(A[i], 1) for i in range(N)]\n\nfor i in range(M):\n  B, C = (map(int, input().split()))\n  D.append((C, B))\n  \nD.sort()\nD.reverse()\n\nans, left = 0, N\nfor (i, j) in D:\n    use = min(j, left)\n    ans += use * i\n    left -= use\nprint(ans)", "import heapq\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nheapq.heapify(a)\nbc = [list(map(int, input().split())) for _ in range(m)]\nbc.sort(key = lambda x: x[1], reverse = True)\n\nfor i in range(m):\n    if a[0] >= bc[i][1]:\n        break\n    else:\n        cnt = 0\n        while cnt < bc[i][0]:\n            heapq.heapreplace(a, bc[i][1])\n            cnt += 1\n\nprint(sum(a))"]
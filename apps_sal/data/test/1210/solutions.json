["n,m=map(int,input().split())\ndef f():\n\ta,b=map(int,input().split())\n\treturn(b//m-(a-1)//m)/(b-a+1)\na=[f() for _ in range(n)]\nr=0\nfor i in range(n):\n\tr+=1-(1-a[i])*(1-a[(i+1)%n])\nprint(r*2000)", "n, p = map(int, input().split())\nL, R = [], []\nfor i in range(n):\n\tl, r = map(int, input().split())\n\tL.append(l)\n\tR.append(r)\nans = 0\nfor i in range (n):\n\tl1, r1, l2, r2 = L[i], R[i], L[(i + 1) % n], R[(i + 1) % n]\n\tl_1, r_1, l_2, r_2 = L[i], R[i], L[(i + 1) % n], R[(i + 1) % n]\n\tif (l1 % p > 0):\n\t\tl1 += p - l1 % p\n\tif (l2 % p > 0):\n\t\tl2 += p - l2 % p\n\tr1 -= r1 % p\n\tr2 -= r2 % p\n\t#print(l1, r1, l2, r2)\n\t#print((r2 // p - l2 // p + 1) / (r_2 - l_2 + 1) + (r1 // p - l1 // p + 1) / (r_1 - l_1 + 1) - (r2 // p - l2 // p + 1) / (r_2 - l_2 + 1) * (r1 // p - l1 // p + 1) / (r_1 - l_1 + 1))\n\tans += (2000 * (r2 // p - l2 // p + 1) / (r_2 - l_2 + 1) + 2000 * (r1 // p - l1 // p + 1) / (r_1 - l_1 + 1) - 2000 * (r2 // p - l2 // p + 1) / (r_2 - l_2 + 1) * (r1 // p - l1 // p + 1) / (r_1 - l_1 + 1))\nprint(ans)", "n, p = [int(i) for i in input().split()]\nkek = [0] * n\nlol = [0] * n\nfor i in range(n):\n    l, r = [int(i) for i in input().split()]\n    a = ((r // p + 1) * p - l // p * p) // p\n    if l % p:\n        a -= 1\n    lol[i] = r - l + 1\n    kek[i] = a\nans = 0\nfor i in range(n):\n    t = (i + 1) % n\n    ans += ((kek[i] * (lol[t] - kek[t]) + kek[t] * (lol[i] - kek[i]) + kek[i] * kek[t]) * 2000) / (lol[i] * lol[t])\nprint(ans)", "import re, sys, math, string, operator, functools, fractions, collections\nsys.setrecursionlimit(10**7)\ndX= [-1, 1, 0, 0,-1, 1,-1, 1]\ndY= [ 0, 0,-1, 1, 1,-1,-1, 1]\nRI=lambda: list(map(int,input().split()))\nRS=lambda: input().rstrip().split()\nmod=1e9+7\n#################################################\nn, p = RI()\nsharks=[0]*n\nfor i in range(n):\n    l,r=RI()\n    tot=(math.floor(r/p)-math.ceil(l/p)+1)\n    sharks[i]=1-tot/(r-l+1)\nans=0\nfor i in range(n):\n    ans+=(1-(sharks[i])*(sharks[i-1]))\nans*=2000\nprint(ans)\n", "n, p = [int(i) for i in input().split()]\ns = []\nq = [(0, 0)] * n\nfor i in range(n):\n    l, r = [int(i) for i in input().split()]\n    s.append((l, r))\nfor i in range(n):\n    q[i] = ((s[i][1] - (s[i][1] % p) - ((s[i][0] + p - 1) // p) * p) // p + 1, s[i][1] - s[i][0] + 1)\nsm = 0\nfor i in range(n):\n    sm += (1 - ((q[i - 1][1] - q[i - 1][0]) / q[i - 1][1]) * ((q[i][1] - q[i][0]) / q[i][1])) * 2000\nprint(sm)", "n, p = map(int, input().split())\n\nprob = [0.0] * n\n\nfor i in range(n):\n\tl, r = map(int, input().split())\n\tprob[i] = 1.0 -  (r // p - (l - 1) // p) / (r - l + 1)\n\nans = 0.0\nfor i in range(n-1):\n\tans += (1.0 - prob[i] * prob[i+1]) * 2000\nans += (1.0 - prob[n-1] * prob[0]) * 2000\n\nprint(ans)", "n, p = list(map(int, input().split()))\ne = []\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    L = -1\n    R = 10 ** 9 + 7\n    while L != R - 1:\n        m = (L + R) // 2\n        if m * p < l:\n            L = m\n        else:\n            R = m\n    col1 = R\n    L = -1\n    R = 10 ** 9 + 7\n    while L != R - 1:\n        m = (L + R) // 2\n        if m * p <= r:\n            L = m\n        else:\n            R = m\n    col2 = R\n    col = r - l + 1\n    e.append(1 - (col2 - col1) / col)\nsum = 0\nfor i in range(n):\n    sum += 1000 * (1 - (e[i] * e[i - 1]))\nprint(sum * 2)\n\n       \n    \n        \n", "import math\nfrom fractions import Fraction\n\nn, p = [int(x) for x in input().split()]\nexp_mean = 0\nfirst_l, first_r = None, None\nlast_good, last_all = None, None\n\nfor i in range(n+1):\n    l, r = None, None\n    if i < n:\n        l, r = [int(x) for x in input().split()]\n        if first_l is None:\n            first_l, first_r = l, r\n    else:\n        l, r = first_l, first_r\n\n    upper = r // p\n    lower = math.ceil(l / p)\n\n    cur_good = upper - lower + 1\n    cur_all = r - l + 1\n\n    if last_good is not None:\n        cur_mean = float(2000 * (cur_good * last_good + (cur_all - cur_good) *\n                         last_good + (last_all - last_good) * cur_good) / (\n                         cur_all * last_all))\n        exp_mean += cur_mean\n\n    last_good = cur_good\n    last_all = cur_all\n\nprint(exp_mean)\n", "n, p = [int(x) for x in input().split()]\nsegments = []\nfor i in range(n):\n    segments.append(tuple(int(x) for x in input().split()))\ndivam = lambda p, s: (s[1] - s[0]) // p + (s[1]%p < s[0]%p or s[0]%p == 0)\ndef expectation(s1, s2):\n    k1, k2 = divam(p, s1), divam(p, s2)\n    n1, n2 = s1[1] - s1[0] + 1, s2[1] - s2[0] + 1\n    return 2000 * (k1*n2 + k2*n1 - k1*k2) / (n1*n2)\nprint(sum(expectation(segments[i], segments[(i+1)%n]) for i in range(n)))\n", "n,p = list(map(int,input().split()))\n\ndef count_divisors(a,b,p):\n    x = b // p\n    y = (a - 1) // p\n    return x - y\n\narr = []\n\nfor i in range(n):\n    a,b = list(map(int,input().split()))\n    arr.append((count_divisors(a,b,p),b - a + 1))\n\nans = 0\n\nfor i in range(n - 1):\n    a,b = arr[i][0],arr[i + 1][0]\n    x,y = arr[i][1],arr[i + 1][1]\n    ans += 1 - ((1 - a / x) * (1 - b / y))\n\na,b = arr[0][0],arr[-1][0]\nx,y = arr[0][1],arr[-1][1]\nans += 1 - ((1 - a / x) * (1 - b / y))\n\n# print(ans)\n\nprint(ans * 2000)\n", "from math import floor,ceil\ndef mults(a,b,n):\n    return max(floor(b/n)-ceil(a/n)+1,0)\ndef prob(a,b,n):\n    return 1-(mults(a,b,n))/(b-a+1)\nans=0\nn,p=(list(map(int,input().split())))\nfirststart,firstend=(list(map(int,input().split())))\nprevstart=firststart\nprevend=firstend\nfor i in range(1,n):\n    nextstart,nextend=(list(map(int,input().split())))\n    ans+=(1-prob(prevstart,prevend,p)*prob(nextstart,nextend,p))\n    prevstart=nextstart\n    prevend=nextend\nans+=1-prob(prevstart,prevend,p)*prob(firststart,firstend,p)\nprint(2000*ans)\n", "n,p=list(map(int,input().split()))\nz=1\na=[]\nb=[]\nfor i in range(0,n):\n    x,y=list(map(int,input().split()))\n    a.append(int(y/p)-int((x-1)/p))\n    b.append(y-x+1)\nans=0\nfor i in range (0,n):\n    pz=a[(i+1)%n]\n    z=b[(i+1)%n]\n    py=a[i]\n    y=b[i]\n    px=a[(i-1+n)%n]\n    x=b[(i-1+n)%n]\n    ans+=((x*z*py*2000 + px*pz*(y-py)*2000 + px*(y-py)*(z-pz)*1000 + pz*(x-px)*(y-py)*1000))/float(x*y*z)\n    \n    \n    \nprint(ans)\n\n", "import math\n\n(n, p) = tuple(map(int, input().split()))\n\nexpection = 0\nprobability = [0]*n\nfor i in range(n):\n    (l, r) = tuple(map(int, input().split()))\n    nump = math.floor(r/p) - math.ceil(l/p) + 1\n    numa = r - l + 1\n    probability[i] = nump/numa\n\nfor i in range(n):\n    left = i-1\n    right = i+1\n\n    if left == -1:\n        left = n-1\n    if right == n:\n        right = 0\n\n    p_middle = probability[i]\n    p_left = probability[left]\n    p_right = probability[right]\n\n    expection += (p_middle + (1-p_middle)*p_left*p_right)*2000\n    expection += ((1-p_middle)*(p_left*(1-p_right)+(1-p_left)*p_right))*1000\n\nprint(str(expection))\n", "n, p = list(map(int, input().split()))\nl_1, r_1 = list(map(int, input().split()))\npre_l, pre_r = l_1, r_1\nanswer = 0\nfor i in range(n - 1):\n    l, r = list(map(int, input().split()))\n    now_shark = [l, r]\n    x1 = (r // p - (l - 1) // p) / (r - l + 1)\n    x2 = (pre_r // p - (pre_l - 1) // p) / (pre_r - pre_l + 1)\n    answer += (1 - (1 - x1) * (1 - x2)) * 2000\n    pre_l, pre_r = l, r\nx1 = (r_1 // p - (l_1 - 1) // p) / (r_1 - l_1 + 1)\nx2 = (pre_r // p - (pre_l - 1) // p) / (pre_r - pre_l + 1)\nanswer += (1 - (1 - x1) * (1 - x2)) * 2000\nprint(answer)\n\n\n", "# C problem\nimport sys\n\nbuffer=input().split(' ')\n[n, p] = [ int(buffer[i]) for i in range(len(buffer)) ]\n\nshark = []\nfor i in range(n):\n\tbuffer=input().split(' ')\n\t[a, b] = [ int(buffer[i]) for i in range(len(buffer)) ]\n\tshark.append([ int(b/p)-int((a-1)/p) , int(b-a+1) ])\n\nresult = 0.0\nfor i in range(n):\n\t[a, b] = shark[i]\n\t[c, d] = shark[(i+1)%n]\n\ttemp = (float(a*d + b*c - a*c))*2000/(b*d)\n\tresult += temp\nprint(result)", "#!/usr/bin/env python3\n\ntry:\n    while True:\n        n, p = list(map(int, input().split()))\n        a = [0] * n\n        for i in range(n):\n            lower, upper = list(map(int, input().split()))\n            a[i] = (upper // p - (lower - 1) // p) / (upper - lower + 1)\n        print(sum(a[i] + (1 - a[i]) * a[i - 1] for i in range(n)) * 2000)\n\nexcept EOFError:\n    pass\n", "n, p = [int(i) for i in input().split()]\nb = []\nfor i in range(n):\n    a = [int(i) for i in input().split()]\n    if a[0] % p == 0:\n        l = a[0] // p\n    else:\n        l = a[0] // p + 1\n    r = a[1] // p\n    s = max(0, r - l + 1)\n    s /= a[1] - a[0] + 1\n    b += [s]\nres = 0\nfor i in range(-1,n-1):\n    res += (b[i] + b[i+1] - b[i] * b[i+1]) * 2000\nprint(res)\n    \n        \n", "read = lambda: list(map(int, input().split()))\nf = lambda x: (x[1] // p - (x[0] - 1) // p) / (x[1] - x[0] + 1)\nn, p = read()\na = [f(tuple(read())) for i in range(n)]\nans = sum(1 - (1 - a[i]) * (1 - a[i - 1]) for i in range(n)) * 2000\nprint(ans)\n", "n,p=[int(x) for x in input().split()]\nmi=[]\nfor k in range(0,n):\n\tl,r=[int(x) for x in input().split()]\n\t#Probability that prime number multiple chosen in  list.\n\tx=(r//p- (l-1)//p)/(r-l+1)\n\t#1-x is Probability that it is not prime number multiple.\n\tmi.append(1-x)\n\n#print(mi)\nfin=0\nfor z in range(0,len(mi)):\n\tfin+=(1-mi[z]*mi[(z+1)%n])\nprint(fin*2000)\n", "nextInt = lambda: list(map(int, input().split()))\nn,p=nextInt()\na=[0]*n\nret=0\nfor i in range(n):\n    l,r=nextInt()\n    a[i]=(r//p-(l-1)//p)/(r-l+1)\n\nfor i in range(n):\n    ret+=a[i]+a[i-1]-a[i]*a[i-1]\n\n# print(a)\n\nret*=2000\n\nprint(ret)\n", "np = [int(u) for u in input().split()]\nn, p  = np\ns  = [tuple(int(u) for u in input().split()) for i in range(n)]\n\ndef count_multiples(l,r,p):\n    return r//p - (l-1)//p\n\ndef E_X_i(i):\n    i %= n\n    l_i = s[i]  [0]\n    l_j = s[i+1][0]\n    r_i = s[i]  [1]\n    r_j = s[i+1][1]\n    p_i = count_multiples(l_i,r_i,p)/(1+r_i-l_i)\n    p_j = count_multiples(l_j,r_j,p)/(1+r_j-l_j)\n    pr = p_i*p_j + (1-p_i)*p_j + (1-p_j)*p_i\n    return pr*2*1000\ns.append(s[0])\nE_X = sum(E_X_i(i) for i in range(n))\nprint(E_X)\n", "#!/usr/bin/env python3\nN, p = map(int, input().split())\nblah = []\nfor _ in range(N):\n    l, r = map(int, input().split())\n    lp = (l+p-1)//p\n    rp = r//p\n    count = rp - lp + 1\n    blah.append(count / (r-l+1))\n\ntotal = 0\nfor i in range(-1, N-1):\n    a, b = blah[i], blah[i+1]\n    total += a + b - a*b\n\nprint(total * 2000)", "n,p = list(map(int,input().split(\" \")))\nl = []\nr = []\nfor i in range(n):\n    li,ri = list(map(int, input().split(\" \")))\n    l.append(li)\n    r.append(ri)\nans = 0\nfor i in range(n):\n    j = (i+1)%n\n    range1 = r[i]-l[i]+1\n    range2 = r[j]-l[j]+1\n    prob1 = r[i]//p-(l[i]-1)//p\n    prob2 = r[j]//p-(l[j]-1)//p\n    ans += 2000*(prob1*range2+prob2*range1-prob1*prob2)/range1/range2\nprint(ans)\n", "import sys\n\nN, p = list(map(int, input().split()))\n\nl = list()\nr = list()\n\nfor i in range (0, N):\n    a, b = list(map(int, input().split()))\n    l.append(a)\n    r.append(b)\n\nl.append(l[0])\nr.append(r[0])\n\nanswer = 2000 * N\nanswer = 0\n\nfor i in range (0, N):\n    c1 = l[i] // p\n    c2 = r[i] // p\n    pos1 = c2-c1\n    if (l[i] % p == 0):\n        pos1 += 1\n\n    total1 = r[i] - l[i] + 1\n\n    bad_pos1 = total1-pos1\n\n    c1 = l[i+1] // p\n    c2 = r[i+1] // p\n    pos2 = c2-c1\n    if (l[i+1] % p == 0):\n        pos2 += 1\n\n    total2 = r[i+1] - l[i+1] + 1\n\n    bad_pos2 = total2-pos2\n\n    answer += 2000 * (1 - bad_pos1/total1 * bad_pos2/total2)\n\n\n\nprint (answer)\n\n\n\n", "n, p = list(map(int, input().split()))\nflowers = [list(map(int, input().split())) for _ in range(n)]\nprimes = [r // p - (l - 1) // p for l, r in flowers]\n\nret = 0\n\nfor i in range(n):\n    j = (i + 1) % n\n    total1 = flowers[i][1] - (flowers[i][0] - 1)\n    total2 = flowers[j][1] - (flowers[j][0] - 1)\n    probnot1 = (total1 - primes[i]) / total1\n    probnot2 = (total2 - primes[j]) / total2\n    ret += (1 - probnot1 * probnot2)\n\nprint(ret * 2000)\n"]
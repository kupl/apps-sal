["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,m,k = LI()\n    a = [[-1] * (m+2)]\n    a += [[-1] + [inf if c=='.' else -1 for c in S()] + [-1] for _ in range(n)]\n    a += [[-1] * (m+2)]\n    x1,y1,x2,y2 = LI()\n    a[x1][y1] = 0\n    q = [(x1,y1)]\n    qi = 0\n    dy = [-1,1,0,0]\n    dx = [0,0,-1,1]\n    while qi < len(q):\n        x,y = q[qi]\n        qi += 1\n        nd = a[x][y] + 1\n        for di in range(4):\n            for j in range(1,k+1):\n                ny = y + dy[di] * j\n                nx = x + dx[di] * j\n                if a[nx][ny] > nd:\n                    if ny == y2 and nx == x2:\n                        return nd\n                    a[nx][ny] = nd\n                    q.append((nx,ny))\n                elif a[nx][ny] < nd:\n                    break\n\n    if a[x2][y2] < inf:\n        return a[x2][y2]\n    return -1\n\n\nprint(main())\n\n\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**15\nmod = 10**9+7\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef main():\n    n,m,k = LI()\n    a = [[-1] * (m+2)]\n    a += [[-1] + [inf if c=='.' else -1 for c in S()] + [-1] for _ in range(n)]\n    a += [[-1] * (m+2)]\n    x1,y1,x2,y2 = LI()\n    a[x1][y1] = 0\n    q = [(x1,y1)]\n    qi = 0\n    dy = [-1,1,0,0]\n    dx = [0,0,-1,1]\n    while qi < len(q):\n        x,y = q[qi]\n        qi += 1\n        nd = a[x][y] + 1\n        for di in range(4):\n            for j in range(1,k+1):\n                ny = y + dy[di] * j\n                nx = x + dx[di] * j\n                if a[nx][ny] > nd:\n                    if ny == y2 and nx == x2:\n                        return nd\n                    a[nx][ny] = nd\n                    q.append((nx,ny))\n                elif a[nx][ny] < nd:\n                    break\n    if a[x2][y2] < inf:\n        return a[x2][y2]\n    return -1\nprint(main())\n", "from collections import deque\nn, m, k = map(int, input().split())\nINF = float(\"inf\")\nd = [[INF] * m for _ in range(n)]\nt = [[] for i in range(n)]\nfor i in range(n):\n    a = list(input())\n    t[i] = a\n\nsx, sy, gx, gy = map(int, input().split())\nsx, sy, gx, gy = sx - 1, sy - 1, gx - 1, gy - 1\n\n\ndef bfs():\n    que = deque()\n    que.append((sx, sy))\n    d[sx][sy] = 0\n\n    while len(que):\n        x, y = que.popleft()\n        if x == gx and y == gy:\n            break\n        for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n            for i in range(1, k + 1):\n                nx, ny = x + i * dx, y + i * dy\n                if not 0 <= nx < n or not 0 <= ny < m or t[nx][ny] != \".\" or d[nx][ny] <= d[x][y]:\n                    break\n                else:\n                    if d[nx][ny] > d[x][y] + 1:\n                        d[nx][ny] = d[x][y] + 1\n                        que.append((nx, ny))\n\n    return d[gx][gy]\n\n\nans = bfs()\nif ans == INF:\n    print(-1)\nelse:\n    print(ans)", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn,m,k=list(map(int,input().split()))\ndp=[[float(\"infinity\") for i in range(m)] for i in range(n)]\nl=[]\nfor i in range(n):\n\tl.append(list(input()))\nx1,y1,x2,y2=[int(a)-1 for a in input().split()]\nt=[(1,0),(0,1),(0,-1),(-1,0)]\nq=deque()\nq.append((x1,y1))\ndp[x1][y1]=0\nwhile q:\n\tx,y=q.popleft()\n\tif x==x2 and y==y2:\n\t\t# print(90)\n\t\tbreak\n\tfor a,b in t:\n\t\tfor i in range(1,k+1):\n\t\t\te=x+i*a\n\t\t\tf=y+i*b\n\t\t\tif e<0 or e>=n or f>=m or f<0 or l[e][f]!=\".\" or dp[e][f]<dp[x][y]+1:\n\t\t\t\t# print(e,f)\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif dp[e][f]>dp[x][y]+1:\n\t\t\t\t\tdp[e][f]=dp[x][y]+1\n\t\t\t\t\tq.append((e,f))\n\t# print(q)\nans=dp[x2][y2]\nif ans==float(\"infinity\"):\n\tans=-1\nprint(ans)\n"]
["\"\"\"\nCodeforces Contest Good Bye 2014 Contest Problem B\n\nAuthor  : chaotic_iak\nLanguage: Python 3.4.2\n\"\"\"\n\n################################################### SOLUTION\n\ndef main():\n    n, = read()\n    p = read()\n    dsu = DSU()\n    for i in range(n):\n        a = read(0)\n        dsu.make()\n        for j in range(i):\n            if a[j] == \"1\":\n                dsu.union(j, i)\n    used = [0] * n\n    res = [0] * n\n    for i in range(n):\n        if not used[i]:\n            pr = dsu.find(i)\n            indices = []\n            elements = []\n            for j in range(n):\n                if dsu.find(j) == pr:\n                    used[j] = 1\n                    indices.append(j)\n                    elements.append(p[j])\n            elements.sort()\n            for i,e in zip(indices, elements):\n                res[i] = e\n    write(res)\n\n#################################################### HELPERS\n\nclass DSU(object):\n    \"\"\"\n    Implements disjoint-set data structure as disjoint-set forest, with {0,1,...,n-1} as elements.\n\n    Methods:\n    make(): add a new element and returns its index\n    find(x): return representative of x\n    union(x, y): merge the sets containing x and y\n\n    Not to be used publicly:\n    _parent: a list of ints for the parent of each vertex, used internally; call find instead\n    _rank: a list of ints for the rank of trees, ensuring trees are binary and hence O(lg n) worst case\n    __init__(): called when initialization, initialize DSU to be empty\n    __str__(): return a readable string description of the DSU; meant to be printed while debugging\n    \"\"\"\n\n    def __init__(self):\n        self._parent = []\n        self._rank = []\n\n    def make(self):\n        i = len(self._parent)\n        self._parent.append(i)\n        self._rank.append(0)\n        return i\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        if xr == yr: return\n        if self._rank[xr] < self._rank[yr]:\n            self._parent[xr] = yr\n        elif self._rank[yr] < self._rank[xr]:\n            self._parent[yr] = xr\n        else:\n            self._parent[yr] = xr\n            self._rank[xr] += 1\n\n    def __str__(self):\n        s = \"DSU\\n\"\n        for i in range(len(self._parent)):\n            s += str(i) + \" in set \" + str(self.find(i)) + \" with rank \" + str(self._rank[self.find(i)]) + \"\\n\"\n        return s\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0: return inputs\n    if mode == 1: return inputs.split()\n    if mode == 2: return list(map(int, inputs.split()))\n\ndef write(s=\"\\n\"):\n    if s is None: s = \"\"\n    if isinstance(s, list): s = \" \".join(map(str, s))\n    s = str(s)\n    print(s, end=\"\")\n\nwrite(main())", "n = int(input())\nl = list(map(int,input().split()))\nbest = l\nswaps = []\nfor i in range(n):\n    p = list(input())\n    for j in range(n):\n        if j>i and p[j] == '1':\n            swaps.append([i,j])\n\ngroup = []\nfor i in range(n):\n    group.append([i])\n    \nfor i in range(len(swaps)):\n    x = swaps[i][1]\n    y = swaps[i][0]\n    while isinstance(group[x],int) == 1:\n        x = group[x]\n    while isinstance(group[y],int) == 1:\n        y = group[y]\n    if y != x:\n        group[y] += group[x]\n        group[x] = y\n\nfor i in range(n):\n    if isinstance(group[i],list) == 1:\n        group[i] = sorted(group[i])\n\nfor i in range(n):\n    if isinstance(group[i],list) == 1:\n        x = []\n        for j in range(len(group[i])):\n            x.append(l[group[i][j]])\n        x = list(sorted(x))\n        for j in range(len(group[i])):\n            l[group[i][j]] = x[j]\n\ns = str(l[0])\nfor i in range(1,n):\n    s += ' '+str(l[i])\nprint(s)\n", "def dfs(node, g) :\n    nonlocal visited, M, N\n    for i in range(N) :\n        if M[node][i] == '0' or visited[i] : continue\n        visited[i] = True\n        g.append(i)\n        dfs(i, g)\n    \nN = int(input())\nP = list(map(int, input().split(' ')))\nM = [input() for i in range(N)]\n\nG = []\nvisited = [False]*N\nfor i in range(N) :\n    if visited[i] : continue\n    visited[i] = True\n    g = [i]\n    dfs(i, g)\n    g.sort()\n    G.append(g)\n\nfor g in G :\n    for i in range(len(g)) :\n        for j in range(i+1, len(g)) :\n            if P[g[i]] > P[g[j]] : P[g[i]], P[g[j]] = P[g[j]], P[g[i]]\n\nans = \"\"\nfor i in range(len(P)) :\n    ans += str(P[i]) + ' '\nans = ans[:-1]\nprint(ans)\n    \n", "n = int(input())\np = list(map(int, input().split()))\na = [list(map(int, list(input()))) for _ in range(n)]\n\ngroups = []\n\nfor i in range(n):\n    s = set()\n    s.add(i)\n    for j in range(n):\n        if a[i][j] == 1:\n            s.add(j)\n    if len(s) > 1:\n        groups.append(s)\n\ni = 0\nwhile i < len(groups):\n    j = i + 1\n    while j < len(groups):\n        if len(groups[i] & groups[j]) == 0:\n            j += 1\n            continue\n        groups[i] |= groups[j]\n        groups.pop(j)\n        j = i + 1\n    i += 1\n\ngroups = [sorted(list(s)) for s in groups]\n\nfor g in groups:\n    i = len(g)\n    while i > 0:\n        j = 0\n        while j < i - 1:\n            if p[g[j]] > p[g[j+1]]:\n                p[g[j]], p[g[j+1]] = p[g[j+1]], p[g[j]]\n            j += 1\n        i -= 1\n\nprint(' '.join(map(str, p)))\n", "#!/usr/bin/env python3\n\nn = int(input())\np = [int(x) for x in input().split()]\na = [[int(c) for c in input()] for _ in range(n)]\n\nexchange = []\nfor i in range(n):\n    s = set()\n    s.add(i)\n    for j in range(n):\n        if a[i][j] == 1:\n            s.add(j)\n    if len(s) > 1:\n        exchange.append(s)\n\n\ni = 0\nwhile i < len(exchange) - 1:\n    j = i + 1\n    while j < len(exchange):\n        if exchange[i] & exchange[j]:\n            exchange[i] |= exchange[j]\n            exchange.pop(j)\n            j = i + 1\n        else:\n            j += 1\n    i += 1\nexchange = [sorted(s) for s in exchange]\n\n\nfor ex in exchange:\n    for i in range(len(ex) - 1):\n        for j in range(i + 1, len(ex)):\n            if p[ex[i]] > p[ex[j]]:\n                p[ex[i]], p[ex[j]] = p[ex[j]], p[ex[i]]\n\n\nprint(\" \".join(map(str, p)))\n", "def dfs(v):\n    pos.append(v)\n    used[v] = True\n    for g in range(n):\n        if int(s[v][g]) and not used[g]:\n            dfs(g)\n\nn = int(input())\np = list(map(int, input().split()))\ns = [input() for i in range(n)]\nused = [False] * n\nfor j in range(n):\n    if not used[j]:\n        pos = []\n        dfs(j)\n        values = [p[i] for i in pos]\n        pos.sort()\n        values.sort()\n        for (i, po) in enumerate(pos):\n            p[po] = values[i]\nprint(' '.join([str(x) for x in p]))", "def dfs(i, visited, g):\n\tindexes = []\n\tvisited.add(i)\n\tfor j in g[i]:\n\t\tif j not in visited:\n\t\t\tindexes.extend(dfs(j, visited, g))\n\tindexes.append(i)\n\treturn indexes\n\ndef solve(n, p, g):\n\tvisited = set()\n\tresult = [0] * n\n\tfor i in range(n):\n\t\tif i not in visited:\n\t\t\tindexes = dfs(i, visited, g)\n\t\t\tvalues = [p[i] for i in indexes]\n\n\t\t\tindexes = sorted(indexes)\n\t\t\tvalues = sorted(values)\n\n\t\t\tfor j in range(len(indexes)):\n\t\t\t\tresult[indexes[j]] = values[j]\n\treturn result\n\n\n\n\ndef main():\n\tn = int(input())\n\tp = list(map(int, input().split()))\n\tswaps = []\n\tfor i in range(n):\n\t\trow = input()\n\t\ttemp = []\n\t\tfor j in range(n):\n\t\t\tif row[j] == '1':\n\t\t\t\ttemp.append(j)\n\t\tswaps.append(temp)\n\tresult = solve(n, p, swaps)\n\tprint(\" \".join(map(str, result)))\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "def dfs(v):\n    pos.append(v)\n    used[v] = True\n    for g in range(n):\n        if int(s[v][g]) and not used[g]:\n            dfs(g)\n\nn = int(input())\np = list(map(int, input().split()))\ns = [input() for i in range(n)]\nused = [False] * n\nfor j in range(n): \n    if not used[j]:\n        pos = []\n        dfs(j)\n        values = [p[i] for i in pos]\n        pos.sort()\n        values.sort()\n        for (i, po) in enumerate(pos):\n            p[po] = values[i]\nprint(' '.join([str(x) for x in p]))", "I=lambda:list(map(int,input().split()))\nn = int(input())\npermutation = list(I())\ncomponents = [-1] * n\nmatrix = [[int(c) for c in input()] for _ in range(n)]\n\ncurrent = 0\ndef dfs(i):\n\tnonlocal current\n\tif components[i] < 0:\n\t\tcomponents[i] = current\n\t\tfor j, b in enumerate(matrix[i]):\n\t\t\tif(b):\n\t\t\t\tdfs(j)\n\nfor i in range(n):\n\tdfs(i)\n\tcurrent += 1\n\nslots = [components[i] for i in range(n)]\n\ngroups = []\nfor i in range(current):\n\tgroups.append(sorted([permutation[j] for j in range(n) if components[j] == i]))\n\npretty = []\nfor p in slots:\n\tpretty.append(str(groups[p][0]))\n\tgroups[p] = groups[p][1:]\nprint(' '.join(pretty))\n", "I = lambda:list(map(int,input().split()))\nn = int(input()); permutation = list(I())\n\nrow = lambda: [int(c) for c in input()]\nmatrix = [row() for _ in range(n)]\ncomponents = [-1] * n\n\ndef dfs(i):\n\tnonlocal current\n\tif components[i] < 0:\n\t\tcomponents[i] = current\n\t\trow = enumerate(matrix[i])\n\t\trow = [j for j, a in row if a > 0]\n\t\tfor x in row: dfs(x)\n\ncurrent = 0\nfor i in range(n):\n\tdfs(i)\n\tcurrent += 1\n\ngroups = []\nfor i in range(current):\n\tindices = [j for j, c in enumerate(components) if c == i]\n\tgroups.append(sorted([permutation[j] for j in indices]))\n\npretty = []\nfor p in components:\n\tpretty.append(str(groups[p][0]))\n\tgroups[p] = groups[p][1:]\nprint(' '.join(pretty))\n", "from queue import Queue as Q\n\ndef fill(start, used, a):\n\tq = Q()\n\tq.put(start)\n\tn = len(a)\n\tused[start] = start + 1\n\twhile not q.empty():\n\t\tnext = q.get()\n\t\tfor i in range(n):\n\t\t\tif a[next][i] == '0' or used[i]:\n\t\t\t\tcontinue\n\t\t\tused[i] = start + 1\n\t\t\tq.put(i)\n\nn = int(input())\np = [int(x) for x in input().split()]\na = []\nfor i in range(n):\n\ta.append(input())\nused = [0] * n\nlists = [[] for i in range(n)]\nfor i in range(n):\n\tif not used[i]:\n\t\tfill(i, used, a)\n\tlists[used[i] - 1].append(p[i])\nfor l in lists:\n\tl.sort()\nfor i in range(n):\n\tp[i] = lists[used[i] - 1][0]\n\tlists[used[i] - 1].pop(0)\nprint(' '.join(str(x) for x in p))\n", "def main():\n    def dfs(t):\n        pos.append(t)\n        unused[t] = False\n        for k, (a, u) in enumerate(zip(A[t], unused)):\n            if a and u:\n                dfs(k)\n\n    n = int(input())\n    pp = list(map(int, input().split()))\n    A = [list(map(int, input())) for _ in range(n)]\n    unused = [True] * n\n    for i, f in enumerate(unused):\n        if f:\n            pos = []\n            dfs(i)\n            for j, v in zip(sorted(pos), sorted(pp[_] for _ in pos)):\n                pp[j] = v\n    print(' '.join(map(str, pp)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def dfs(i):\n\tret = []\n\tif not used[i]:\n\t\tused[i] = True\n\t\tret += [i]\n\tfor j in range(n): \n\t\tif a[i][j]==1 and not used[j]:\n\t\t\tret.extend(dfs(j))\n\treturn ret\n\n\n\nn = int(input())\np = list(map(int,input().split()))\nans = p\na = [list(map(int,input())) for i in range(n)]\nused = [False for i in range(n)]\nfor i in range(n):\n\tif not used[i]:\n\t\ttemp = []\n\t\tidx = dfs(i)\n\t\tidx.sort()\n\t\tfor j in idx:\n\t\t\ttemp.append(p[j])\n\t\ttemp.sort()\n\t\tfor k,j in enumerate(idx):\n\t\t\tans[j] = temp[k]\n\nprint(\" \".join(list(map(str,p))))\n", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\nx = []\nsa = int(input())\ntoed = list(map(int, input().split(' ')))\nfor i in range(sa):\n    x.append(input())\n\ngraph = {}\nfor i in range(sa):\n    graph[i] = []\n\nmarked = [False] * sa\n\nfor bad in range(sa):\n    for asdf in range(bad+1, sa):\n        if x[bad][asdf] == '1':\n            graph[bad].append(asdf)\n            graph[asdf].append(bad)\n\ndone = []\nfor i in range(sa):\n  if not marked[i]:\n      a = recursive_dfs(graph, i)\n      done.append(a)\n      for j in recursive_dfs(graph, i):\n          marked[j] = True\n\nfinal = [0] * sa\n\nfor i in done:\n    o = [toed[a] for a in i]\n    o.sort()\n    i.sort()\n    for a in range(len(i)):\n        final[i[a]] = o[a]\n\nprint(' '.join([str(i) for i in final]))\n", "\nn = int(input())\np = [int(i) for i in input().split()]\ns = ()\nfor i in range(n):\n    s += (input(),)\nz = [False] * n\nx,y = [],[]\ndef dfs(i):\n    if not z[i]:\n        nonlocal x\n        z[i] = True\n        x.append(i)\n        y.append(p[i])\n        for j in range(n):\n            if s[i][j] == '1': dfs(j)\n\nfor i in range(n):\n    if not z[i]:\n        x,y = [],[]\n        dfs(i)\n        x.sort()\n        y.sort()\n        for j in range(len(x)): p[x[j]] = y[j]\n\nprint(\" \".join([str(i) for i in p]))\n\n", "used = [0 for i in range(333)]\np = []\nt = []\nn = 0\nc = []\nd = []\n\ndef dfs(v):\n    used[v] = 1\n    c.append(v)\n    d.append(p[v])\n    for i in range(len(p)):\n        if t[v][i] == '1' and not used[i]:\n            dfs(i)\ndef main():\n    nonlocal n\n    nonlocal p\n    nonlocal t\n    nonlocal used\n    nonlocal c\n    nonlocal d\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    t = []\n    ans = [0 for i in range(n)]\n    for i in range(n):\n        t.append(input())\n    for i in range(n):\n        if not used[i]:\n            c = []\n            d = []\n            dfs(i)\n            k = len(c)\n            for num,val in zip(sorted(c), sorted(d)):\n                ans[num] = val \n    for elem in ans:\n        print(elem, end = ' ')\ndef __starting_point():\n    main()\n__starting_point()", "def dfs(v):\n    pos.append(v)\n    used[v] = True\n    for g in range(n):\n        if int(s[v][g]) and not used[g]:\n            dfs(g)\n\nn = int(input())\np = list(map(int, input().split()))\ns = [input() for i in range(n)]\nused = [False] * n\nfor j in range(n):\n    if not used[j]:\n        pos = []\n        dfs(j)\n        values = [p[i] for i in pos]\n        pos.sort()\n        values.sort()\n        for (i, po) in enumerate(pos):\n            p[po] = values[i]\nprint(' '.join([str(x) for x in p]))", "n = int(input())\np = list(map(int, input().split()))\ng = [list() for i in range(n)]\nfor k in range(n):\n    a = list(map(int, input()))\n    for i in range(n):\n        if a[i]: g[k].append(i)\ndef dfs(v):\n    nonlocal c\n    was[v] = True\n    c[v] = color\n    for u in g[v]:\n        if not was[u]:\n            dfs(u)\nc = [0] * n\ncolor = 1\nfor i in range(n):\n    was = [False] * n\n    if c[i] == 0:\n        dfs(i)\n        color += 1\nb = [list() for i in range(n)]\nfor i in range(n):\n    b[c[i] - 1].append(p[i])\nfor i in range(n):\n    b[i].sort()\nans = [0] * n\ncur = [0] * n\nfor i in range(n):\n    x = c[i] - 1\n    ans[i] = b[x][cur[x]]\n    cur[x] += 1\nprint(*ans)\n", "import bisect,sys\nfrom collections import deque, namedtuple\nsys.setrecursionlimit(20000)\nN = 1050\npar = [i for i in range(1050)]\nsiz = [1]*N\n\ndef find(i):\n    if i == par[i]: return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    if siz[a] < siz[b]: a,b = b,a\n    par[b] = a\n    siz[a] += siz[b]\n\ndef main():\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    a = [ [ord(c)-ord('0') for c in input()] for j in range(n) ]\n    for i in range(n):\n        for j in range(n):\n            if a[i][j]:\n                merge(i,j)\n    d = [[] for i in range(n)]\n    for i in range(n):\n        a = find(i)\n        bisect.insort(d[a],l[i])\n\n    for i in range(n):\n        a = find(i)\n        print(d[a][0],end=\" \")\n        d[a] = d[a][1:]\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect,sys\nfrom collections import deque, namedtuple\nsys.setrecursionlimit(20000)\nN = 1050\npar = [i for i in range(1050)]\nsiz = [1]*N\n\ndef find(i):\n    if i == par[i]: return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    if siz[a] < siz[b]: a,b = b,a\n    par[b] = a\n    siz[a] += siz[b]\n\ndef main():\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    a = [ [ord(c)-ord('0') for c in input()] for j in range(n) ]\n    for i in range(n):\n        for j in range(n):\n            if a[i][j]:\n                merge(i,j)\n    d = [[] for i in range(n)]\n    cnt = [0]*n\n    for i in range(n):\n        a = find(i)\n        d[a].append(l[i])\n\n    for i in range(n):\n        d[i] = sorted(d[i])\n\n\n    for i in range(n):\n        a = find(i)\n        print(d[a][cnt[a]],end=\" \")\n        cnt[a] += 1\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect,sys\nfrom collections import deque, namedtuple\nsys.setrecursionlimit(20000)\nN = 1050\npar = [i for i in range(1050)]\nsiz = [1]*N\n\ndef find(i):\n    if i == par[i]: return i\n    par[i] = find(par[i])\n    return par[i]\n\ndef merge(a,b):\n    a = find(a)\n    b = find(b)\n    if siz[a] < siz[b]: a,b = b,a\n    par[b] = a\n    siz[a] += siz[b]\n\ndef main():\n    n = int(input())\n    l = [int(i) for i in input().split()]\n    a = [ [ord(c)-ord('0') for c in input()] for j in range(n) ]\n    for i in range(n):\n        for j in range(n):\n            if a[i][j]:\n                merge(i,j)\n    d = [[] for i in range(n)]\n    cnt = [0]*n\n    for i in range(n):\n        a = find(i)\n        d[a].append(l[i])\n\n    for i in range(n):\n        d[i] = sorted(d[i])\n\n\n    for i in range(n):\n        a = find(i)\n        print(d[a][cnt[a]],end=\" \")\n        cnt[a] += 1\n\ndef __starting_point():\n    main()\n__starting_point()", "def dfs(v):\n    pos.append(v)\n    used[v]=1\n    for i in range(n):\n        if s[v][i]==\"1\" and not used[i]:\n            dfs(i)\n\n\n\nn = int(input())\na = list(map(int,input().split()))\ns = [input() for _ in range(n)]\nused = [0]*n\nfor i in range(n):\n    if not used[i]:\n        pos = []\n        dfs(i)\n        values = [a[i] for i in pos]\n        pos.sort()\n        values.sort()\n        for i,j in enumerate(pos):\n            a[j] = values[i]\n\nprint(\" \".join(str(x) for x in a))", "\n\"\"\"\n\tAuthor\t\t: Arif Ahmad\n\tDate  \t\t: \n\tAlgo  \t\t: \n\tDifficulty\t: \n\"\"\"\n\nn \t\t= None\np \t\t= []\na \t\t= []\nvisited = []\nids \t= []\nvalues\t= []\n\n\ndef dfs(u):\n\tnonlocal visited, ids, values\n\n\tvisited[u] = True\n\tfor v in range(n):\n\t\tif (not visited[v]) and (a[u][v] == '1'):\n\t\t\tids.append(v)\n\t\t\tvalues.append(p[v])\n\t\t\tdfs(v)\n\n\ndef main():\n\tnonlocal n, p, a, visited\n\n\tn = int(input())\n\tp = list((int(_) for _ in input().split()))\n\ta = [[0 for i in range(n)] for j in range(n)]\n\tfor i in range(n):\n\t\ta[i] = input()\n\n\tvisited = [False] * n\n\tfor i in range(n):\n\t\tif visited[i]: continue\n\t\tnonlocal ids, values\n\t\tids \t= [i]\n\t\tvalues \t= [p[i]]\n\t\tdfs(i)\n\t\tids \t= sorted(ids)\n\t\tvalues \t= sorted(values) \n\t\tfor x, y in zip(ids, values):\n\t\t\tp[x] = y    \n\n\tprint(\" \".join(str(_) for _ in p))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\"\"\"http://codeforces.com/problemset/problem/500/B\"\"\"\n\nfrom collections import defaultdict\n\nclass DFS:\n    visited = None\n    graph = None\n\n    def __init__(self, graph):\n        self.visited = set()\n        self.graph = graph\n\n    def dfs(self, node):\n        self.visited.add(node)\n        for v in self.graph[node]:\n            if v not in self.visited:\n                self.dfs(v)\n\ndef solve(n, p, m):\n    graph = defaultdict(list)\n    for i in range(n):\n        for j in range(n):\n            if m[i][j] == '1':\n                graph[i].append(j)\n    for num in range(1, n+1):\n        i = p.index(num)\n        d = DFS(graph)\n        d.dfs(i)\n        for j in range(i):\n            if j in d.visited and p[i] < p[j]:\n                p[i], p[j] = p[j], p[i]\n    return ' '.join(map(str, p))\n\ndef __starting_point():\n    n = int(input())\n    p = list(map(int, input().split()))\n    matrix = [input() for _ in range(n)]\n    print(solve(n, p, matrix))\n\n__starting_point()", "n = int(input())\nt = list(map(int, input().split()))\na = [input() for i in range(n)]\nu = [0] * n\ndef dfs(i):\n    p.append(i)\n    u[i] = 1\n    for j in range(n):\n        if a[i][j] == '1' and not u[j]:\n            dfs(j)\nfor i in range(n):\n    if not u[i]:\n        p = []\n        dfs(i)\n        k = [t[i] for i in p]\n        p.sort()\n        k.sort()\n        for i, j in enumerate(p):\n            t[j] = k[i]\nprint(' '.join(map(str, t)))"]
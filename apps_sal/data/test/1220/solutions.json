["n,m = list(map(int,input().split()))\nae = [[] for _ in range(n)]\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    ae[a-1].append(b-1)\n    ae[b-1].append(a-1)\nmn = -1\nnbr = n\nfor i in range(n):\n    if len(ae[i])<nbr:\n        mn = i\n        nbr = len(ae[i])\nkeep = ae[mn]\nok = n-len(keep)\nwhile True:\n    toDel = -1\n    for i in keep:\n        aeo = len(ae[i])\n        for j in ae[i]:\n            if j in keep:\n                aeo -= 1\n                if aeo<ok: break\n        if aeo<ok:\n            toDel = i\n            break\n    if toDel == -1:\n        break\n    else:\n        keep.remove(i)\n        ok += 1\nout = [ok]\nd = {}\n\nif len(keep) == 1: out.append(1)\nelif len(keep) == 0: out = out\nelse:\n    keep.sort()\n    for i in range(len(keep)):\n        d[keep[i]] = i\n\n    edg = [[] for _ in range(len(keep))]\n    for i in range(len(keep)):\n        for j in range(len(keep)):\n            if i == j: continue\n            edg[i].append(j)\n            edg[j].append(i)\n\n    for i in keep:\n        for j in ae[i]: \n            if j in keep:\n                if d[j] in edg[d[i]]: edg[d[i]].remove(d[j])\n                if d[i] in edg[d[j]]: edg[d[j]].remove(d[i])\n    used = [False]*len(keep)\n    uss = 0\n    while uss<len(keep):\n        fi = -1\n        for i in range(len(keep)):\n            if not used[i]:\n                fi = i\n                break\n        bfs = [fi]\n        used[fi] = True\n        usn = 1\n        uss += 1\n        while len(bfs) > 0:\n            temp = bfs.pop()\n            for i in edg[temp]:\n                if not used[i]:\n                    used[i] = True\n                    bfs.append(i)\n                    uss += 1\n                    usn += 1\n        out.append(usn)\n\nout.sort()\nprint(len(out))\nprint(' '.join(map(str,out)))\n", "N,M = list(map(int,input().split()))\n\nnE = [{i} for i in range(N)]\nfor _ in range(M):\n  u,v = list(map(int,input().split()))\n  u,v = u-1,v-1\n  nE[u].add(v)\n  nE[v].add(u)\n\nunvisited = set(range(N))\nres = []\n\nwhile unvisited:\n  s = next(iter(unvisited))\n  unvisited.discard(s)\n  stack = [s]\n  cnt = 1\n  while stack:\n    v = stack.pop()\n    s = unvisited-nE[v]\n    cnt += len(s)\n    stack.extend(s)\n    unvisited &= nE[v]\n\n  res.append(cnt)\n\nres.sort()\nprint(len(res))\nprint(' '.join(map(str,res)))\n\n\n", "import sys, math, os.path\n\nFILE_INPUT = \"e.in\"\nDEBUG = os.path.isfile(FILE_INPUT)\nif DEBUG: \n    sys.stdin = open(FILE_INPUT)    \n\ndef ni():\n    return list(map(int, input().split()))\n\ndef nia(): \n    return list(map(int,input().split()))\n\ndef log(x):\n    if (DEBUG):\n        print(x)\n\n\nn,m = ni()\na = [{i} for i in range(n)]\nfor i in range(m):\n    x,y = ni()\n    x,y = x-1, y-1\n    a[x].add(y)\n    a[y].add(x)\n    # print(i)\n\n# log(a)\nq = []\nwillVisit = set(range(n))\n# log(willVisit)\nwhile willVisit:\n    x = willVisit.pop()\n    # loang tai x\n    queue = [x]\n    count = 1\n    while queue:\n        y = queue.pop()\n        sibling = willVisit - a[y]\n        count += len(sibling)\n        queue.extend(sibling)\n        willVisit -= sibling\n        # count += 1\n        # for z in willVisit:\n        #     if (not z in a[y]):\n        #         queue.add(z)\n        # log(f\" y = {y} - {willVisit} - {count} - {sibling}\")\n    # log(willVisit)\n    q.append(count)\n\nq.sort()\nprint(len(q))\nprint(\" \".join(map(str,q)))\n\n", "import sys, math, os.path\n\nFILE_INPUT = \"e.in\"\nDEBUG = os.path.isfile(FILE_INPUT)\nif DEBUG: \n    sys.stdin = open(FILE_INPUT)    \n\ndef ni():\n    return list(map(int, input().split()))\n\ndef nia(): \n    return list(map(int,input().split()))\n\ndef log(x):\n    if (DEBUG):\n        print(x)\n\n\nn,m = ni()\na = [{i} for i in range(n)]\nfor i in range(m):\n    x,y = ni()\n    x,y = x-1, y-1\n    a[x].add(y)\n    a[y].add(x)\n    # print(i)\n\n# log(a)\nq = []\nwillVisit = set(range(n))\n# log(willVisit)\nwhile willVisit:\n    x = willVisit.pop()\n    # loang tai x\n    queue = [x]\n    count = 1\n    while queue:\n        y = queue.pop()\n        sibling = willVisit - a[y]\n        count += len(sibling)\n        queue.extend(sibling)\n        willVisit &= a[y]\n        # willVisit -= sibling\n        # count += 1\n        # for z in willVisit:\n        #     if (not z in a[y]):\n        #         queue.add(z)\n        # log(f\" y = {y} - {willVisit} - {count} - {sibling}\")\n    # log(willVisit)\n    q.append(count)\n\nq.sort()\nprint(len(q))\nprint(\" \".join(map(str,q)))\n\n", "import sys, math, os.path\n\nFILE_INPUT = \"e.in\"\nDEBUG = os.path.isfile(FILE_INPUT)\nif DEBUG: \n    sys.stdin = open(FILE_INPUT)    \n\ndef ni():\n    return list(map(int, input().split()))\n\ndef nia(): \n    return list(map(int,input().split()))\n\ndef log(x):\n    if (DEBUG):\n        print(x)\n\n\nn,m = ni()\na = [{i} for i in range(n)]\nfor _ in range(m):\n    x,y = ni()\n    x,y = x-1, y-1\n    a[x].add(y)\n    a[y].add(x)\n    # print(i)\n\n# log(a)\nq = []\nwillVisit = set(range(n))\n# log(willVisit)\nwhile willVisit:\n    x = willVisit.pop()\n    # loang tai x\n    queue = [x]\n    count = 1\n    while queue:\n        y = queue.pop()\n        sibling = willVisit - a[y]\n        count += len(sibling)\n        queue.extend(sibling)\n        willVisit &= a[y]\n        # willVisit -= sibling\n        # count += 1\n        # for z in willVisit:\n        #     if (not z in a[y]):\n        #         queue.add(z)\n        # log(f\" y = {y} - {willVisit} - {count} - {sibling}\")\n    # log(willVisit)\n    q.append(count)\n\nq.sort()\nprint(len(q))\nprint(\" \".join(map(str,q)))\n\n", "import sys, math, os.path\n\nFILE_INPUT = \"e.in\"\nDEBUG = os.path.isfile(FILE_INPUT)\nif DEBUG: \n    sys.stdin = open(FILE_INPUT)    \n\ndef ni():\n    return list(map(int, input().split()))\n\ndef nia(): \n    return list(map(int,input().split()))\n\ndef log(x):\n    if (DEBUG):\n        print(x)\n\n\nn,m = ni()\na = [{i} for i in range(n)]\nfor _ in range(m):\n    x,y = ni()\n    x,y = x-1, y-1\n    a[x].add(y)\n    a[y].add(x)\n    # print(i)\n\n# log(a)\nq = []\nwillVisit = set(range(n))\n# log(willVisit)\nwhile willVisit:\n    x = willVisit.pop()\n    # loang tai x\n    queue = [x]\n    count = 1\n    while queue:\n        y = queue.pop()\n        sibling = willVisit - a[y]\n        count += len(sibling)\n        queue.extend(sibling)\n        willVisit &= a[y]\n        # willVisit -= sibling\n        # count += 1\n        # for z in willVisit:\n        #     if (not z in a[y]):\n        #         queue.add(z)\n        # log(f\" y = {y} - {willVisit} - {count} - {sibling}\")\n    # log(willVisit)\n    q.append(count)\n\nq.sort()\nprint(len(q))\nprint(\" \".join(map(str,q)))\n\n", "N,M = map(int,input().split())\n\nnE = [{i} for i in range(N)]\nfor _ in range(M):\n  u,v = map(int,input().split())\n  u,v = u-1,v-1\n  nE[u].add(v)\n  nE[v].add(u)\n\nunvisited = set(range(N))\nres = []\n\nwhile unvisited:\n  t = len(unvisited)\n  s = next(iter(unvisited))\n  unvisited.discard(s)\n  stack = [s]\n  while stack:\n    v = stack.pop()\n    s = unvisited & nE[v]\n    stack.extend(unvisited-s)\n    unvisited = s\n\n  res.append(t-len(unvisited))\n\nres.sort()\nprint(len(res))\nprint(' '.join(map(str,res)))", "n, m = map(int, input().split())\n\nbar = [{i} for i in range(n)]\nfor i in range(m):\n\tu, v = map(int, input().split())\n\tu, v = u - 1, v - 1\n\tbar[u].add(v)\n\tbar[v].add(u)\n\nnodes = set(range(n))\nans = []\n\nwhile (nodes):\n\tu = next(iter(nodes))\n\tnodes.remove(u)\n\tstk = [u]\n\tcnt = 1\n\twhile (stk):\n\t\tv = stk.pop()\n\t\ts = nodes - bar[v]\n\t\tcnt += len(s)\n\t\tstk.extend(s)\n\t\tnodes &= bar[v]\n\tans.append(cnt)\n\nans.sort()\nprint(len(ans))\nprint(' '.join(map(str, ans)))", "n,m=list(map(int,input().split()))\nnon=[{i} for i in range(n)]\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    u,v=u-1,v-1\n    non[u].add(v)\n    non[v].add(u)\nvertex=set(range(n))\nans=[]\nwhile(vertex):\n    a=next(iter(vertex))\n    vertex.remove(a)\n    stk=[a]\n    cou=1\n    while(stk):\n        v=stk.pop()\n        s=vertex-non[v]\n        cou+=len(s)\n        stk.extend(s)\n        vertex&=non[v]\n    ans.append(cou)\nans.sort()\nprint(len(ans))\nprint(\" \".join(map(str,ans)))\n", "import sys\ninput = sys.stdin.readline\n \nn, m = list(map(int, input().split()))\neins = set()\nfor _ in range(m):\n    v, to = list(map(int, input().split()))\n    eins.add((v, to))\n    eins.add((to, v))\n \nnotVisited = set(range(1, n+1))\ncomps = []\nfor s in range(1, n+1):\n    if s in notVisited:\n        notVisited.remove(s)\n        ctr = 1\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            visited = set()\n            for to in notVisited:\n                if (v, to) not in eins:\n                    visited.add(to)\n                    stack.append(to)\n                    ctr += 1\n            notVisited -= visited\n        comps.append(ctr)\ncomps.sort()\nprint(len(comps))\nprint(*comps)\n", "import sys\ninput = sys.stdin.readline\n \nn, m = map(int, input().split())\neins = set()\nfor _ in range(m):\n    v, to = map(int, input().split())\n    eins.add((v, to))\n    eins.add((to, v))\n \nnotVisited = set(range(1, n+1))\ncomps = []\nfor s in range(1, n+1):\n    if s in notVisited:\n        notVisited.remove(s)\n        ctr = 1\n        stack = [s]\n        while stack:\n            v = stack.pop()\n            visited = set()\n            for to in notVisited:\n                if (v, to) not in eins:\n                    visited.add(to)\n                    stack.append(to)\n                    ctr += 1\n            notVisited -= visited\n        comps.append(ctr)\ncomps.sort()\nprint(len(comps))\nprint(*comps)", "n,m=list(map(int,input().split()))\nnon=[{i} for i in range(n)]\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    u,v=u-1,v-1\n    non[u].add(v)\n    non[v].add(u)\nvertex=set(range(n))\nans=[]\nwhile(vertex):\n    a=next(iter(vertex))\n    vertex.remove(a)\n    stk=[a]\n    cou=1\n    while(stk):\n        v=stk.pop()\n        s=vertex-non[v]\n        cou+=len(s)\n        stk.extend(s)\n        vertex&=non[v]\n    ans.append(cou)\nans.sort()\nprint(len(ans))\nprint(\" \".join(map(str,ans)))\n", "\ndef Solution(G):\n    unvisited = { i for i in range(len(G)) }\n    sol = []\n    while unvisited:\n        l = len(unvisited)\n        a = next(iter(unvisited))\n        unvisited.discard(a)\n        stack = [a]\n        while stack:\n            v = stack.pop()\n            s = unvisited & G[v]\n            stack.extend(unvisited - s)\n            unvisited = s\n        sol.append(l - len(unvisited))\n    \n    sol.sort()\n    print(len(sol))\n    print(\" \".join(map(\"{0}\".format,sol)))\n\n    pass\ndef main():\n    s = input().split(\" \")\n    n = int(s[0])\n    m = int(s[1])\n    \n    G=[  {i} for i in range(n) ]\n    for _ in range(m):                  \n        s =input().split(\" \")\n        n1 = int(s[0])-1\n        n2 = int(s[1])-1\n        G[n2].add(n1)\n        G[n1].add(n2)\n\n    Solution(G)                 \n\n\nmain()"]
["import functools\nn = int(input())\n\nprops = []\ndef preproc(a):\n    return float(a)/100.\n\nfor i in range(pow(2,n)):\n    props.append(list(map(preproc, input().split())))\n\nwining_props = []  # list of lists. First index -- number of round, second -- num of team, value -- prop of wining\n\nwining_props_first_round = []\nfor i in range(0, (2 ** n), 2):\n    # i, and i+1 teams playing\n    wining_prop_for_i = props[i][i + 1]\n    wining_props_first_round.append(wining_prop_for_i)\n    wining_props_first_round.append(1. - wining_prop_for_i)\n\nwining_props.append(wining_props_first_round)\nassert len(wining_props_first_round) == len(props)\n\nfor round_num in range(2, n + 1):\n    # calculate propabilitys for winning in i round for each team\n    # prop of winning in i round = prop of winning prev round + mo of win this one\n    # mo win this = for each team we can meet prop of them wining prev * prop we win them\n    # each team we can meet on round i  = all teems // 2^i == we//2^i\n    this_round_wining_props = []\n    for team_num in range(2 ** n):\n        t = team_num // (2 ** round_num) * (2 ** (round_num))\n        teams_we_meet_this_round = [t + x for x in range(2 ** round_num)]\n        t = team_num // (2 ** (round_num-1)) * (2 ** (round_num-1))\n        teams_we_meet_prev_round = [t + x for x in range(2 ** (round_num-1))]\n        for tt in teams_we_meet_prev_round:\n            teams_we_meet_this_round.remove(tt)\n\n        this_team_wining_props = wining_props[round_num - 2][team_num]  # -2 cause numeration\n\n        chances_win_i_team = []\n        for tm in teams_we_meet_this_round:\n            # chances we meet them * chances we win\n            chances_win_i_team.append(wining_props[round_num - 2][tm] * props[team_num][tm])\n\n        mo_win_this_round = sum(chances_win_i_team)\n\n        this_team_wining_props *= mo_win_this_round\n\n        this_round_wining_props.append(this_team_wining_props)\n\n    #assert 0.99 < sum(this_round_wining_props) < 1.01\n    wining_props.append(this_round_wining_props)\n\n# now we got props of each win on each round. Lets bet on most propable winer and calculate revenue\n\n#from left to right-1 is playing\n@functools.lru_cache(maxsize=None)\ndef revenue(round_num, teams_left, teams_right, winner=-1):\n    split = ((teams_left + teams_right) // 2)\n\n    # let the strongest team win, we bet, and calculate to the bottom\n    if round_num == 1:\n        return wining_props[0][winner] if winner != -1 else max(wining_props[0][teams_left:teams_right])\n\n    if winner == -1:\n        results = []\n        for winner in range(teams_left, teams_right):\n            winner_prop = wining_props[round_num - 1][winner]\n\n            if winner >= split:\n                res = sum(\n                    [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\n                     winner_prop * (2 ** (round_num - 1))])\n            else:\n                res = sum(\n                    [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\n                     winner_prop * (2 ** (round_num - 1))])\n            results.append(res)\n\n        return max(results)\n\n    else:\n        winner_prop = wining_props[round_num - 1][winner]\n\n        if winner >= split:\n            res = sum(\n                [revenue(round_num - 1, teams_left, split), revenue(round_num - 1, split, teams_right, winner),\n                 winner_prop * (2 ** (round_num - 1))])\n        else:\n            res = sum(\n                [revenue(round_num - 1, teams_left, split, winner), revenue(round_num - 1, split, teams_right),\n                 winner_prop * (2 ** (round_num - 1))])\n\n        return res\n\nprint(revenue(n, 0, (2 ** n)))\n", "n = int(input())\nm = 1 << n\np = [list(map(int, input().split())) for i in range(m)]\nu, x = [1] * m, [0] * m\nv, y = u[:], x[:]\nfor i in range(n):\n    d = 1 << i\n    for j in range(m):\n        s = d * (j // d ^ 1)\n        v[j] = u[j] * sum(u[k] * p[j][k] for k in range(s, s + d)) / 100\n        y[j] = max(x[s: s + d]) + x[j] + v[j] * d\n    u, v, x, y = v, u, y, x\nprint(max(x))", "n = int(input())\nm = 1 << n\np = [list(map(int, input().split())) for i in range(m)]\nu, x = [1] * m, [0] * m\nv, y = u[:], x[:]\nfor i in range(n):\n    d = 1 << i\n    for j in range(m):\n        s = d * (j // d ^ 1)\n        v[j] = u[j] * sum(u[k] * p[j][k] for k in range(s, s + d)) / 100\n        y[j] = max(x[s: s + d]) + x[j] + v[j] * d\n    u, v, x, y = v, u, y, x\nprint(max(x))", "n = int(input())\n# Using the same index I would for a tree\nm = 2**n\n\npoints = [0]*(2*m)\npoints[1] = 2**(n-1)\nfor i in range(1,m):\n    x = points[i]//2\n    points[2*i] = x\n    points[2*i+1] = x\n\n\n\nP = [[int(x)/100.0 for x in input().split()] for _ in range(m)]\nstate = [[0.0]*64 for _ in range(2*m)]\n\nfor i in range(m):\n    state[m+i][i] = 1.0\n    \nfor i in reversed(range(1,m)):\n    for j in range(m):\n        for k in range(j+1,m):\n            # x is probability that team j meets team k in match i\n            x = state[2*i][j]*state[2*i+1][k]\n\n            state[i][j] += P[j][k]*x\n            state[i][k] += P[k][j]*x\n\nscore = [[0]*64 for _ in range(2*m)]\nfor i in reversed(range(1,m)):\n    for j in range(m):\n        for k in range(m):\n            score[i][j] = max(score[i][j], score[2*i][j]+state[i][j]*points[i] + score[2*i+1][k])\n            score[i][j] = max(score[i][j], score[2*i+1][j]+state[i][j]*points[i] + score[2*i][k])\nprint(repr(max(score[1])))"]
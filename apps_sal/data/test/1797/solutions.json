["n = int(input())\np = list(map(int, input().split()))\n\nls = []\nvisited = [False for _ in range(n)]\ncnt = 0\nfor i in range(n):\n    j = i\n    cnt = 0\n    while not visited[j]:\n        visited[j] = True\n        cnt += 1\n        j = p[j] - 1\n    if 0 < cnt:\n        ls.append(cnt)\n\nls.sort()\nif 1 < len(ls):\n    ls[-2] += ls[-1]\n    ls.pop()\n\nprint(sum([x**2 for x in ls]))\n\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Oct 27 19:33:34 2017\n\n@author: savit\n\"\"\"\n\nn=int(input())\na=list(map(int,input().split()))\nb=[]\nchains=[]\nfor i in range(n):\n    b.append(True)\nfor i in range(n):\n    if(b[i]):\n        chains.append([i,])\n        j=i\n        b[j]=False\n        while((a[j]-1)!=chains[-1][0]):\n            \n            chains[-1].append(a[j]-1)\n            \n            j=a[j]-1\n            b[j]=False\nchainlen=list(map(len,chains))\nif(len(chains)>1):\n    #print(\"entered\")\n    \n    max1=max(chainlen)\n    max1=chainlen.index(max1)\n    chainlen[max1]*=-1\n    \n    max2=max(chainlen)\n    max2=chainlen.index(max2)\n    #print(max1,max2,chainlen)\n    chainlen[max2]=chainlen[max2]+(-1*chainlen[max1])\n    del chainlen[max1]\ncon=0\n#print(chains)\n#print(chainlen)\nfor i in chainlen:\n    con+=i*i\nprint(con)        \n", "n = int(input())\np = list(map(int,input().split()))\nvis = [False]*n\nnv = 0\nm = 0\ncyc = []\nwhile nv<n:\n    while vis[m]:\n        m+=1\n    temp = []\n    c = m\n    while not vis[c]:\n        temp.append(c)\n        nv += 1\n        vis[c] = True\n        c = p[c]-1\n    cyc.append(temp)\nsize = []\nfor i in range(len(cyc)):\n    size.append(len(cyc[i]))\nsize = sorted(size)\nif len(size)==1:\n    print(size[0]*size[0])\nelse:\n    out = (size[len(size)-1]+size[len(size)-2])*(size[len(size)-1]+size[len(size)-2])\n    for i in range(len(size)-2):\n        out += size[i]*size[i]\n    print(out)\n\n", "n = int(input())\ndata = list(map(int,input().split()))\n\ngp = { i:i for i in range(n) }\nsets = { i:[i] for i in range(n) }\n\nfor i in range(n):\n    u,v = i,data[i]-1\n    if gp[u]!= gp[v]:\n        temp=gp[v]\n        for i in sets[gp[v]]:\n            gp[i]=gp[u]\n            sets[gp[u]].append(i)\n        del sets[temp]\n\nl=[]\nfor i in sets:\n    l.append(len(sets[i]))\nl.sort(reverse=True)\nn=len(l)\nif n==1:\n    print(l[0]*l[0])\nelse:\n    ans=(l[0]+l[1])**2\n    for i in range(2,n):\n        ans+=l[i]**2\n    print(ans)\n", "r = lambda: map(int, input().split())\n\ndef main():\n\tn, = r()\n\tp = [x - 1 for x in r()]\n\tvis = [False] * n\n\tlens = []\n\tfor i in range(n):\n\t\tif vis[i]:\n\t\t\tcontinue\n\t\tvis[i], cc = True, 1\n\t\tj = p[i]\n\t\twhile not vis[j]:\n\t\t\tvis[j] = True\n\t\t\tcc += 1\n\t\t\tj = p[j]\n\t\tlens.append(cc)\n\tlens.sort()\n\tif len(lens) > 1:\n\t\tlens[-2] += lens[-1]\n\t\tlens.pop()\n\tprint(sum(x * x for x in lens))\n\nmain()", "n=int(input())\np=[0]*(n+1)\np[1:n+1]=list(map(int,input().split()))\nc=[]\nused=[False]*(n+1)\nfor i in range(1,n+1):\n    if used[i]:\n        continue\n    s=list()\n    s.append(i)\n    used[i]=True\n    j=p[i]\n    while not used[j]:\n        s.append(j)\n        used[j]=True\n        j=p[j]\n    c.append(len(s))\nif len(c)==1:\n    print(n*n)\nelse:\n    c.sort()\n    c.reverse()\n    #print(c)\n    m=c[0]+c[1]\n    print(m*m+sum([d*d for d in c[2:]]))\n\n\n", "n = int(input())\nps = list(map(lambda x: int(x)-1, input().split()))\n\nsum = 0\nmaxest_pipe = 0\nmax_pipe = 0\n\nfree_points = set(range(n))\nfree_points.remove(0)\nstart_point = 0\ncurrent_point = 0\nsteps = 0\nwhile True:\n    steps += 1\n    next_point = ps[current_point]\n    if next_point in free_points:\n        free_points.remove(next_point)\n    if next_point == start_point:\n\n        sum += steps * steps\n        if steps > maxest_pipe:\n            max_pipe = maxest_pipe\n            maxest_pipe = steps\n        elif steps > max_pipe:\n            max_pipe = steps\n        steps = 0\n        if len(free_points) > 0:\n            current_point = free_points.pop()\n            start_point = current_point\n        else:\n            break\n    else:\n        current_point = next_point\n\nprint(sum - max_pipe*max_pipe - maxest_pipe*maxest_pipe + (max_pipe+maxest_pipe)*(max_pipe+maxest_pipe))", "n = int(input())\ninp= input()\ninp = inp.split()\nfor i in range(n):\n    inp[i] = int(inp[i])\nvis = [0 for i in range(n)]\nsiz = []\nfor i in range(n):\n    if vis[i]==1:\n        continue\n    vis[i] = 1\n    j=inp[i]-1\n    count = 1\n    while vis[j]!=1:\n        count+=1\n        vis[j]=1\n        j = inp[j]-1\n    siz.append(count)\nsiz.sort(reverse = True)\nif len(siz)==1:\n    print(siz[0]**2)\nelse:\n    ans = (siz[0]+siz[1])**2\n    for i in range(2, len(siz)):\n        ans+= siz[i]*siz[i]\n    print(ans)\n", "n = int(input())\np = list(map(int, input().split()))\n\nused = [False] * n\nnums = list()\n\n\ndef count(i):\n    c = 0\n    while True:\n        if used[i]:\n            return c\n        else:\n            used[i] = True\n            i = p[i] - 1\n            c += 1\n\n\nfor i in range(n):\n    if not used[i]:\n        nums.append(count(i))\n\nif n == 1:\n    print(1)\nelif n == 2:\n    print(4)\nelse:\n    nums.sort(reverse=True)\n    if len(nums) > 1:\n        c = (nums[0] + nums[1]) ** 2\n        for i in nums[2:]:\n            c += i ** 2\n        print(c)\n    else:\n        print(nums[0] ** 2)\n", "n = int(input())\np = list(map(int, input().split()))\n\nused = [False] * n\nnums = list()\n\n\ndef count(i):\n    c = 0\n    while True:\n        if used[i]:\n            return c\n        else:\n            used[i] = True\n            i = p[i] - 1\n            c += 1\n\n\nfor i in range(n):\n    if not used[i]:\n        nums.append(count(i))\n\nif n == 1:\n    print(1)\nelif n == 2:\n    print(4)\nelse:\n    nums.sort(reverse=True)\n    if len(nums) > 1:\n        c = (nums[0] + nums[1]) ** 2\n        for i in nums[2:]:\n            c += i ** 2\n        print(c)\n    else:\n        print(nums[0] ** 2)\n", "from collections import defaultdict as dd\ng=dd(list)\ndef addE(u,v):\n\tg[u].append(v)\n\tg[v].append(u)\nn=int(input())\nl=[int(x) for x in input().split()]\nfor i in range(n):\n\taddE(i+1,l[i])\nvisited=[False]*(n+1)\ndef dfs(v,count):\n\tvisited[v]=True\n\tstack=[v]\n\twhile len(stack)!=0:\n\t\tcur=stack.pop()\n\t\tfor ch in g[cur]:\n\t\t\tif visited[ch]:\n\t\t\t\tcontinue\n\t\t\tvisited[ch]=True\n\t\t\tcount+=1\n\t\t\tstack.append(ch)\n\treturn count\n\nans=[]\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tans.append(dfs(i,1))\n\nans=sorted(ans,reverse=True)\nif  len(ans) ==1:\n\tprint(ans[0]*ans[0])\nelse:\n\tans[1]+=ans[0]\n\tans.pop(0)\n\tprint(sum(x*x for x in ans))\n\n\n\n", "#!/usr/bin/env python3\n\nn = int(input())\nP = [int(p)-1 for p in input().split()]  # permutation\nseen = [False]*n\nres = m0 = m1 = 0\nfor i in range(n):\n    if not seen[i]:\n        seen[i] = True\n        j = P[i]\n        c = 1  # taille du cycle\n        while j!=i:\n            seen[j] = True\n            j = P[j]\n            c += 1\n        res += c*c\n        if c>m0:\n            m0,m1 = c,m0\n        elif c>m1:\n            m1 = c\n# on fusionne les 2 plus grands cycles\nres += (m0+m1)*(m0+m1)-m0*m0-m1*m1\nprint(res)\n", "n = int(input())\np = [int(x)-1 for x in input().split()]\nencontrados = [False]*n\nciclos = []\nfor i in range(n):\n\tif encontrados[i]:\n\t\tcontinue\n\tciclos.append([i])\n\tencontrados[i] = True\n\tj = p[i]\n\twhile not encontrados[j]:\n\t\tciclos[-1].append(j)\n\t\tencontrados[j] = True\n\t\tj = p[j]\nprimero = max([len(x) for x in ciclos])\nfor i in range(n):\n\tif len(ciclos[i]) == primero:\n\t\tciclos.pop(i)\n\t\tbreak\nif ciclos:\n\tsegundo = max([len(x) for x in ciclos])\nelse:\n\tsegundo = 0\nprint((primero+segundo)**2 + sum([len(x)**2 for x in ciclos]) - segundo**2)\n", "n = int(input())\np = list(map(int, input().split(\" \")))\nls = []\nvis = [False for i in range(n)]\ncnt = 0\nfor i in range(n):\n    j = i\n    cnt = 0\n    while not(vis[j]):\n        vis[j] = True\n        cnt += 1\n        j = p[j] - 1\n    if cnt>0:\n        ls.append(cnt)\nls.sort()\nif len(ls)>1:\n    ls[-2] += ls[-1]\n    ls.pop()\nans=0\nfor i in ls:\n    ans=ans+i**2\nprint(ans)\n", "n = int(input())\nedges = [int(x) - 1 for x in input().split()]\nvisited = [False for _ in range(n)]\n\nsizes = []\nfor i in range(n):\n    if visited[i]:\n        continue\n    visited[i] = True\n    component_size = 1\n\n    j = edges[i]\n    while not visited[j]:\n        visited[j] = True\n        component_size += 1\n        j = edges[j]\n\n    sizes.append(component_size)\n\nsizes = sorted(sizes)\nif len(sizes) > 1:\n    sizes[-2] += sizes[-1]\n    sizes.pop()\n\nprint(sum([x**2 for x in sizes]))\n", "n = int(input())\np = [0] + list(map(int, input().split()))\n\ndef visit(v):\n  res = 0\n  while p[v] != 0:\n    res += 1\n    x = p[v]\n    (p[v], v) = (0, x)    \n  return res \n\nval = sorted([visit(v) for v in range(n + 1)])\nprint(sum(list([x*x for x in val])) + 2 * val[-1] * val[-2])\n", "n=int(input())\np=[int(x) for x in input().split()]\np.insert(0,-3)\nmax1,max2=0,0\nused=[0]*(n+1)\ncount=0\nfor i in range (1, n+1):\n    m=0\n    v=i\n    while used[p[v]]==0:\n        used[p[v]]=1\n        v=p[v]\n        m+=1\n    if m>max2:\n        max2=m\n    if max2>max1:\n        max2,max1=max1,max2\n    count+=m**2\ncount=count-max1**2-max2**2+(max1+max2)**2\n\nprint(count)", "# http://codeforces.com/contest/884/problem/C\n# unsolved\nfrom functools import lru_cache\n\nn = int(input())\np = list(map(int, input().split()))\n\nl = []\nscore = 0\njeden = 0\ndwa = 0\n\n\n@lru_cache(maxsize=10000)\ndef wzor(s):\n    return s * s\n\n\nfor i in range(n):\n\n    if p[i] != 0:\n        start = i\n        end = p[i]\n        lenght = 0\n        k = 0\n\n        if start + 1 != p[i]:\n\n            while k - 1 != start:\n                k = end\n                end = p[end - 1]\n                p[k - 1] = 0\n                lenght += 1\n\n        else:\n            p[end - 1] = 0\n            lenght += 1\n\n        if lenght > jeden:\n            l.append(dwa)\n            dwa = jeden\n            jeden = lenght\n\n        elif lenght > dwa:\n            l.append(dwa)\n            dwa = lenght\n\n        else:\n            l.append(lenght)\n\n        length = 0\n\nl.append(jeden + dwa)\n\nfor iteam in l:\n    if iteam != 1 or iteam != 0 :\n        score += wzor(iteam)\n    elif iteam == 1:\n        score += 1\n\nprint(int(score))", "n = int(input())\na = list(map(int, input().split()))\nvis = [False] * 100005\nb = []\nm = 0\nfor i in range(n):\n    if not vis[i]:\n        m += 1\n        cur = i\n        len = 0\n        while not vis[cur]:\n            vis[cur] = True\n            len += 1\n            cur = a[cur] - 1\n        b.append(len)\nb.sort()\nif m > 1:\n    b[-2] += b[-1]\n    b.pop()\nprint(sum(map(lambda x : x**2, b)))", "n = int(input())\np = [0] + list(map(int, input().split()))\n\ndef visit(v):\n  res = 0\n  while p[v] != 0:\n    res += 1\n    x = p[v]\n    (p[v], v) = (0, x)    \n  return res \n\nval = sorted([visit(v) for v in range(n + 1)])\nprint(sum(list(map(lambda x: x*x, val))) + 2 * val[-1] * val[-2])", "\nbz=[0 for i in range(1000000)]\nto=[0 for i in range(1000000)]\nn=0\nn=int(input())\ni=1\nfor x in (input().split()):\n\tto[i]=int(x)\n\ti+=1\nall_num=0\nmx1=0\nmx2=0\nfor i in range(1,n+1):\n\tif (bz[i]==0):\n\t\tx=i\n\t\tnum=0;\n\t\twhile (bz[x]==0):\n\t\t\tnum+=1\n\t\t\tbz[x]=1\n\t\t\tx=to[x]\n\t\tall_num+=num**2\n\t\tif (mx1<=num):\n\t\t\tmx1,mx2=num,mx1\n\t\telif mx2<num:\n\t\t\tmx2=num\n\nprint(all_num-(mx1**2)-(mx2**2)+((mx1+mx2)**2))\n\t\t\t\n", "n=int(input())\na=list(map(int,input().split()))\nb=[0]*n\nk1=0\ns=[]\nfor i in range (n):\n    if b[i]==0:\n        j=a[i]-1\n        k=1\n        b[i]=1\n        sp=[i]\n        while b[j] == 0:\n            sp.append(j)\n            k+=1\n            j=a[j]-1\n        s.append(min(k1,k))\n        k1=max(k1,k)\n        for u in sp:\n            b[u]=k\n#print(s,b,k1)\nk2=max(s)\nprint(sum(list([x*x for x in s]))+k1*k1 + 2*k1*k2)\n", "n = int(input())\np = list(map(int, input().split()))\np = [i - 1 for i in p]\nvis = [False for _ in range(n)]\n\nsz = [0]\n\nfor i in range(n):\n    j = i\n    cnt = 0\n    while not vis[j]:\n        vis[j] = True\n        cnt += 1\n        j = p[j]\n    if 0 < cnt:\n        sz.append(cnt)\n\nsz.sort()\nprint(sum(list(map(lambda x: x*x, sz))) + 2 * sz[-1] * sz[-2])", "n = int(input())\np = list(map(int, input().split()))\np = [i - 1 for i in p]\nvis = [False for _ in range(n)]\n\nsz = [0]\n\n\ndef dfs(v):\n    cnt = 0\n    while not vis[v]:\n        vis[v] = True\n        cnt += 1\n        v = p[v]\n    return cnt\n\nfor i in range(n):\n    cnt = dfs(i)\n    if cnt > 0:\n        sz.append(cnt)\n\nsz.sort()\nprint(sum(list(map(lambda x: x*x, sz))) + 2 * sz[-1] * sz[-2])", "class node:\n    def __init__(self,index):\n        self.index = index\n        self.nextN = None\n        self.visited = 0\n        # 0 - not visited\n        # 1 - visited\n\n\nn = int(input())\nnodes = [node(i+1) for i in range(n)]\nc = [int(i) for i in input().split()]\ni = 0\nwhile i<n:\n    nodes[i].nextN = nodes[c[i]-1]\n    i+=1\n    \nsequence = []\n\ni = 0\nnews = []\nwhile i<n:\n    x = i\n    while(nodes[x].visited!=1):\n        news.append(nodes[x])\n        nodes[x].visited = 1\n        x = nodes[x].nextN.index - 1\n    sequence.append(news)\n    news=[]\n    i+=1\nsequence.sort(key=len,reverse=True)\nif(n==1):\n    print(1)\nelif(n==2):\n    print(4)\nelse:\n    x = len(sequence[0])+len(sequence[1])\n    x *=x\n    som = 0\n    for i in range(2,n):\n        value = len(sequence[i])\n        if(value == 0):\n            break\n        som+=value*value\n    print(x+som)\n        \n    \n"]
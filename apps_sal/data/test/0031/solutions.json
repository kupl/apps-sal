["m = 10** 6 + 3\n\nn, k = list(map(int, input().split()))\np = 1\nfor i in range(n):\n    p *= 2\n    if p > k:\n        break\nif p < k:\n    print('1 1')\n    return\n\ngcd = tmp = k - 1\nwhile tmp:\n    gcd -= tmp % 2\n    tmp //= 2\nb = pow(2, (k - 1) * n - gcd, m)\na = 1\nmem = [-1]*100\nfor i in range(1, k):\n    cnt = 0\n    while i % 2 == 0:\n        i //= 2\n        cnt += 1\n    if mem[cnt] == -1:\n        mem[cnt] = pow(2, n - cnt, m)\n    a = a * (mem[cnt] - i + m) % m\n    if a == 0:\n        break\nprint((b - a + m) % m, b)\n", "import sys\nmod = 10 ** 6 + 3\n\nn, k = list(map(int, input().split()))\n\nif n < 100:\n    if 2 ** n < k:\n        print(1, 1)\n        return\n\ndef factor(n, p):\n    if n < p: return 0\n    return n // p + factor(n // p, p)\n\ndef inv(n):\n    return pow(n, mod - 2, mod)\n\n# 2^nk - P(2^n,k) / 2^nk\n\ntwo = inv(pow(2, n + factor(k - 1, 2), mod))\n\nv = 1\n\nif k >= mod:\n    v = 0\nelse:\n    N = pow(2, n, mod)\n    for i in range(k):\n        v = v * (N - i) % mod\n\nA = (pow(2, n * k, mod) - v) * two % mod\nB = pow(2, n * k, mod) * two % mod\n\nprint(A, B)\n", "#!/usr/bin/env python3\nimport os\nMOD = 1000003\ninv2 = pow(2, MOD - 2, MOD)\n\ndef logm(n, m):\n    # log = 3.3\n    # return (3, False)\n    ans = 0\n    whole = True\n    while n >= m:\n        whole = whole and (n % m == 0)\n        ans += 1\n        n //= m\n    if n == 1:\n        return (ans, whole)\n    return (ans, False)\n\n\n\ndef fact_exp(n, k):\n    ans = 0\n    while n != 0:\n        n //= k\n        ans += n\n    return ans\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    e2 = n + fact_exp(k - 1, 2)\n    div = pow(2, n * k - e2, MOD)\n\n    (e, w) = logm(k, 2)\n    if e > n or (e == n and not w):\n        print(1, 1)\n        return\n\n    num = 1\n    Nr = pow(2, n, MOD)\n    # N * (N-1) * ... * (N - k + 1)\n    # (-0) * (-1) * \n    for t in range(1, k):\n        i = (Nr - t) % MOD\n        if i == 0:\n            num = 0\n            break\n\n        p = 0\n        while t % 2 == 0:\n            p += 1\n            t //= 2\n\n        num = num * i * pow(inv2, p, MOD) % MOD\n\n    print((div - num) % MOD, div)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = map(int, input().split())\n\nMOD = 1000003\n\nK = k - 1\n\nmax_deg = 0\n\nwhile K > 0:\n    max_deg += K // 2\n    K //= 2\n\nden_deg = n * (k-1) - max_deg\n\nkk = 1\nfor i in range(n):\n    kk *= 2\n    if kk >= k: break\nelse:\n    print(1, 1)\n    return\n\nnumerator = 1\ntwo_p_n = pow(2, n, MOD)\nfor i in range(1, min(k, MOD + 1)):\n    numerator *= (two_p_n - i + MOD) % MOD\n    if numerator == 0: break\n    numerator %= MOD\n\nrev = (MOD + 1) // 2\nnumerator *= pow(rev, max_deg, MOD)\nnumerator %= MOD\n\ndenumerator = pow(2, den_deg, MOD)\nnumerator = (denumerator + MOD - numerator) % MOD\n\nprint(numerator, denumerator)", "import math\n\ndef euclid_algorithm(a, b):\n    t1, t2 = abs(a), abs(b)\n    #saving equalities:\n    #t1 == x1 * a + y1 * b,\n    #t2 == x2 * a + y2 * b. \n    x1, y1, x2, y2 = int(math.copysign(1, a)), 0, 0, int(math.copysign(1, b))\n    if t1 < t2:\n        t1, t2 = t2, t1\n        x1, y1, x2, y2 = x2, y2, x1, y1\n\n    while t2 > 0:\n        k = int(t1 // t2)\n        t1, t2 = t2, t1 % t2\n        #t1 - k * t2 == (x1 - k * x2) * a + (y1 - k * y2) * b\n        x1, y1, x2, y2 = x2, y2, x1 - k * x2, y1 - k * y2\n\n    return t1, x1, y1\n\ndef opposite_element(x, p):\n    gcd, k, l = euclid_algorithm(x, p)\n    if gcd != 1:\n        return -1\n    return k % p\n\ndef solve(n, k):\n    if n < 70 and k > (1<<n):\n        return (1, 1)\n    s, l = 0, k-1\n    while l > 0:\n        l >>= 1\n        s += l\n\n    p = 10 ** 6 + 3\n    x = pow(2, n, p)\n    t = pow(opposite_element(2, p), s, p)\n    q = (pow(2, n*(k-1), p) * t) % p\n    r = 1\n    if k > p:\n        r = 0\n    else:\n        for i in range(1, k):\n            r *= (x-i)\n            r %= p\n        \n    return ((q - r*t)%p, q)\n    \n    \nn, k = list(map(int, input().split()))\nx, y = solve(n, k)\nprint(x, y)\n", "m = 10** 6 + 3\n\nn, k = map(int, input().split())\np = 1\nfor i in range(n):\n    p *= 2\n    if p > k:\n        break\nif p < k:\n    print('1 1')\n    return\n\ngcd = tmp = k - 1\nwhile tmp:\n    gcd -= tmp % 2\n    tmp //= 2\nb = pow(2, (k - 1) * n - gcd, m)\na = 1\nmem = [-1]*100\nfor i in range(1, k):\n    cnt = 0\n    while i % 2 == 0:\n        i //= 2\n        cnt += 1\n    if mem[cnt] == -1:\n        mem[cnt] = pow(2, n - cnt, m)\n    a = a * (mem[cnt] - i + m) % m\n    if a == 0:\n        break\nprint((b - a + m) % m, b)", "m = 10** 6 + 3\nn, k = map(int, input().split())\np = 1\nfor i in range(n):\n    p *= 2\n    if p > k:\n        break\nif p < k:\n    print('1 1')\n    return\ngcd = tmp = k - 1\nwhile tmp:\n    gcd -= tmp % 2\n    tmp //= 2\nb = pow(2, (k - 1) * n - gcd, m)\na = 1\nmem = [-1]*100\nfor i in range(1, k):\n    cnt = 0\n    while i % 2 == 0:\n        i //= 2\n        cnt += 1\n    if mem[cnt] == -1:\n        mem[cnt] = pow(2, n - cnt, m)\n    a = a * (mem[cnt] - i + m) % m\n    if a == 0:\n        break\nprint ((b - a + m) % m, b)", "import math\nn, k = [int(x) for x in input().split()]\nif n<70 and k>2**n:\n    print(1,1)\n    return\nmod = int(1e6)+3\n\ndef fastpow(a,b):\n    t, ans = a, 1\n    while b:\n        if(b&1):\n            ans = ans*t%mod\n        t = t*t %mod\n        b>>=1\n    return ans\n\nt=k-1\ncnt=0\nwhile t:\n    cnt += t>>1\n    t>>=1\n\nx=0\nt=fastpow(2,n)\nif k<mod:\n    x=1\n    for i in range(1,k):\n        x = x*(t-i)%mod\ny=fastpow(2,n*(k-1))\n\ninv = fastpow(2,mod-2)\ninv = fastpow(inv,cnt)\n\nx=(x*inv%mod+mod)%mod\ny=(y*inv%mod+mod)%mod\n\nx=(y-x+mod)%mod\n\nprint(x,y)", "n, k = map(int, input().split())\n\nmod = 1000003\n\nif n < 70 and 2**n < k:\n\tprint('1 1\\n')\n\treturn\n\ndef modpow(a, e):\n\tret = 1\n\twhile e > 0:\n\t\tif e%2 == 1:\n\t\t\tret = (ret*a)%mod\n\t\ta = (a*a)%mod\n\t\te = e//2\n\treturn ret\n\ndef pw(a, e):\n\tret = 1\n\twhile e > 0:\n\t\tif e%2 == 1:\n\t\t\tret *= a\n\t\ta *= a\n\t\te = e//2\n\treturn ret\n\npar = n\nfor i in range(1, 100):\n\tpar += ((k-1)//pw(2, i))\n\nmul = 1\ncur = modpow(2, n)\nfor i in range(k):\n\tmul = (cur*mul)%mod\n\tcur -= 1\n\tif mul == 0:\n\t\tbreak\nif mul != 0:\n\tmul = (mul*modpow(modpow(2, par), mod-2))%mod\n\nup = (modpow(2, n*k-par)-mul)%mod\nif up < 0:\n\tup += mod\n\nprint(up, end=' ')\nprint(modpow(2, n*k-par))", "n, k = list(map(int, input().split()))\nif n <= 100 and k > (2 ** n):\n    print(1, 1)\n    return\nMOD = 1000 * 1000 + 3\nINV2 = (MOD + 1) // 2\ndef add(x, y):\n    return (x + y) % MOD\ndef sub(x, y):\n    rez = x - y\n    rez %= MOD\n    rez += MOD\n    rez %= MOD\n    return rez\ndef mult(x, y):\n    return (x * y) % MOD\ndef binpow(x, y):\n    if x == 1 or y == 0:\n        return 1\n    if x == 0:\n        return 0\n    rez = binpow(x, y//2)\n    rez = mult(rez, rez)\n    if y % 2 == 1:\n        rez = mult(rez, x)\n    return rez\n\nA = n * k\nB = n\ntemp = k - 1\nwhile temp >= 2:\n    B += temp // 2\n    temp //= 2\nG = min(A, B)\n# print('G=', G)\nm = binpow(2, n)\n# print('m=', m)\nP = 1\nfor i in range(k):\n    P = mult(P, sub(m, i))\n    if P == 0:\n        break\nP = mult(P, binpow(INV2, G))\nQ = binpow(m, k)\nQ = mult(Q, binpow(INV2, G))\nP = sub(Q, P)\nprint(P, Q)\n"]
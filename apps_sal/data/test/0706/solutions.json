["a, b, n, x = list(map(int, input().split(' ')))\nfir = pow(a, n, 10**9+7)*x%(10**9+7)\nsec = b*(pow(a, n, 10**9+7)-1)*(pow(a-1, 10**9+5, 10**9+7))%(10**9+7)\nif (a == 1):\n    sec = n * b\nprint((fir+sec)%(10**9+7))\n", "A, B, n, x = map(int, input().split())\n\ndef fast_exp(A, n, m):\n    if n == 0:\n        return 1\n    if n & 1:\n        return A * fast_exp(A, n - 1, m) % m\n    return fast_exp(A * A % m, n // 2, m)\n\ndef mod(a, m):\n    a %= m\n    if a < 0:\n        a += m\n    return a\n\nm = 10**9 + 7\n\nif A == 1:\n    print(mod(x + n * B, m))\nelse:\n    ans = B * mod(fast_exp(A, n, m) - 1, m) % m * fast_exp(A - 1, m - 2, m) % m + fast_exp(A, n, m) * x % m\n    ans %= m\n\n    print(ans)", "a,b,n,x=list(map(int,input().split()))\nm=10**9+7\nprint(((pow(a,n,m)*x+b*(pow(a,n,m)-1)*pow(a-1,m-2,m)) if a!=1 else b*n+x)%m)\n", "a, b, n, x = map(int, input().split())\nMOD = 10 ** 9 + 7\nans = pow(a, n, MOD) * x\nif a > 1:\n\ttmp = (pow(a, n, MOD) - 1)\n\tif tmp < 0:\n\t\ttmp += MOD\n\ttmp *= pow(a - 1, MOD - 2, MOD)\n\ttmp *= b\nelse:\n\ttmp = n * b\nprint((ans + tmp) % MOD)", "\ndef main():\n    mod = 1000000007\n    a, b, n, x = list(map(int, input().split()))\n    if a == 1:\n        print((x + n * b) % mod)\n    else:\n        print(((pow(a, n, mod) - 1) * pow(a - 1, mod - 2, mod) * b + pow(a, n, mod) * x) % mod)\n\n\nmain()\n", "A, B, n, x = [int(i) for i in input().split()]\nmod = 10**9 + 7\nif A != 1:\n    A_n = pow(A, n, mod)\n    ans = (A_n * x) % mod + ((1 - A_n) * B * pow(1 - A, mod - 2, mod)) % mod\nelse:\n    ans = x + B * n\nans %= mod\nprint(ans)\n", "def poll(a, k):\n    if k == 1:\n        return a\n    if k % 2 == 1:\n        return poll(a * a % 1000000007, k // 2) * a % 1000000007\n    return poll(a * a % 1000000007, k // 2)\n\na, b, n, x = [int(i) for i in input().split()]\nif a != 1:\n    r = poll(a, n)\n    rr = r - 1\n    rr *= poll((a - 1), 1000000005)\n    rr *= b\n    r *= x\n    print((r + rr) % 1000000007)\nelse:\n    r = x + b * n\n    print(r % 1000000007)", "MOD = 10 ** 9 + 7\n\n\ndef pow(a, n):\n    res = 1\n    b = a\n    while n != 0:\n        if n % 2:\n            res = (res * b) % MOD\n        n //= 2\n        b = (b * b) % MOD\n    return res\n\nassert pow(2, 10) == 1024\nassert pow(7, 1) == 7\nassert pow(7, 0) == 1\n\n\ndef egcd(a, b):\n    assert a > 0 and b > 0\n\n    a_orig = a\n    b_orig = b\n\n    x0, y0 = 1, 0\n    x1, y1 = 0, 1\n\n    assert a == a_orig * x0 + b_orig * y0\n    assert b == a_orig * x1 + b_orig * y1\n\n    while b != 0:\n        q = a // b\n\n        a, b = b, a - b * q\n        x0, y0, x1, y1 = x1, y1, x0 - q * x1, y0 - q * y1\n\n        assert a == a_orig * x0 + b_orig * y0\n        assert b == a_orig * x1 + b_orig * y1\n\n    return a, x0, y0\n\nif False:\n    print(egcd(3, 5))\n    print(egcd(2, 4))\n    print(egcd(4, 2))\n    print(egcd(5, 3))\n\ndef solve(a, b, n, x):\n    if a == 1:\n        return (x + b * n) % MOD\n\n    a_n = pow(a, n)\n    one, inv_a_1, _ = egcd(a - 1, MOD)\n    assert one == 1\n    assert ((a - 1) * inv_a_1) % MOD == 1\n    res = (a_n * x + b * (a_n - 1) * inv_a_1) % MOD\n\n    return res\n\nif False:\n    assert solve(3, 4, 2, 1) == 25\n    assert solve(3, 4, 1, 1) == 7\n    solve(10 ** 9 - 19, 10 ** 9 - 23, 10 ** 18 - 57, 10 ** 9 - 16)\n    assert solve(1, 4, 2, 10) == 18\n\nelse:\n    a, b, n, x = list(map(int, input().split()))\n    print(solve(a, b, n, x))\n", "def mod_exp(x, y, p):\n    res = 1\n    x %= p\n    while y:\n        if y&1:\n            res = (res * x) % p\n        y >>= 1\n        x = (x * x) % p\n    return res\n\n\ndef power(a, b, m):\n    x, y = 1, a\n    while b:\n        if b&1:\n            x = (x * y) % m\n        y = (y * y) % m\n        b //= 2\n    return x\n\n\ndef mod_inverse(a, m):\n    return power(a, m - 2, m)\n\n\ndef solve(a, b, n, x):\n    m = 10**9 + 7\n    if a == 1:\n        return (b * n * a + x) % m\n    p = mod_exp(a, n, m)\n    return (b * (p - 1) * mod_inverse(a - 1, m) + p * x) % m\n\na, b, n, x = list(map(int, input().split()))\n\nprint(solve(a, b, n, x))\n", "def pow(a, n):\n\tif (n == 0):\n\t\treturn 1\n\tif (n % 2 == 0):\n\t\treturn (pow(a, n//2) ** 2) % (1000000007)\n\telse:\n\t\treturn (a * pow(a, n//2) ** 2) % (1000000007)\n\n\n\nM = 1000000007\na, b, n, x = map(int, input().split())\narr = [0] * 64\narr[0] = b;\nfor i in range(1, 64):\n\tarr[i] = ((pow(a, 2**(i-1)) * arr[i-1]) % M + arr[i-1]) % M;\nans = (pow(a, n) * x) % M;\npos = 0;\nfor i in range(63, -1, -1):\n\tif (2**i <= n) :\n\t\tans += (pow(a, pos) * arr[i]) % M;\n\t\tans %= M;\n\t\tn -= 2**i;\n\t\tpos += 2**i;\nprint(ans%M)", "A, B, M = 0, 0, 10**9 + 7\n\ndef GP(A,n):\n    if n == 0:\n        return 1\n    if A == 1:\n        return (n * A) % M\n    res = (pow(A,n,M)-1) * pow(A-1,M-2,M)\n    return res % M\n\ndef f(n,x):\n    res = pow(A,n,M) * x + B * GP(A,n)\n    return res % M\n\ndef g(n,x):\n    if n == 0:\n        return x\n    elif n == 1:\n        return (A*x + B) % M\n    return f(n,x) % M\n\nA, B, n, x = list(map(int,input().split()))\nprint(g(n,x))\n", "def pow2(c, d):\n    if d == 0:\n        return 1\n    if d == 1:\n        return c\n    return (pow2(c, d // 2) ** 2 * c ** (d % 2)) % INF\n\nINF = 10 ** 9 + 7\na, b, n, x = list(map(int, input().split()))\nif a != 1:\n    SGP = ((b - b * pow2(a, n)) * pow2(1 - a, INF - 2)) % INF\nelse:\n    SGP = b * n\nprint((SGP + pow2(a, n) * x) % INF)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\n\n(A, B, n, x) = (int(i) for i in input().split())\n\nstart = time.time()\n\nmd  = 1000000007\n\nif A!=1 :\n    an  = pow(A, n, md*(A-1))\n    bn  = B*(an-1)//(A-1)\n    ans = (an*x+bn)%md\nelse:\n    ans = (x+B*n)%md\nprint(ans)\n\nfinish = time.time()\n#print(finish - start)\n", "a,b,n,x = map(int,input().split())\nmd = 10**9+7\nmult  = lambda u,v : 0 if v==0 else (u+mult(u,v-1))%md if v % 2 == 1 else (2*mult(u,v//2))%md\nget_prog = lambda a,b,n : mult(pow(a,n,md)-1+md,pow(a-1+md,md-2,md)) if a!=1 else n \nres = mult(pow(a,n,md),x)+mult(get_prog(a,b,n),b)\nres%=md\nprint(res)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\n\nmod = 10 ** 9 + 7\na, b, n, x = map(int, input().split())\nans = (pow(a, n, mod) * x % mod) % mod\nif a != 1:\n    ans2 = ((b * (pow(a, n, mod) - 1) % mod) * modinv(a - 1, mod)) % mod\nelse:\n    ans2 = (b*(n*a)%mod)%mod\nprint((ans + ans2) % mod)", "def our_sum(a, n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        q = our_sum(a, n // 2)\n        return (q + q * pow(a, n // 2, mod)) % mod\n    else:\n        return (our_sum(a, n - 1) + pow(a, n - 1, mod)) % mod\n\n\na, b, n, x = map(int, input().split())\nmod = 10 ** 9 + 7\n#n %= mod\nres = pow(a, n, mod) * x\nres %= mod\nif a != 1:\n    res += our_sum(a, n) * b % mod\nelse:\n    res += b * n % mod\nres %= mod\nprint(res)", "mod = 10**9 + 7\n\ndef pow(num, p):\n    nonlocal mod\n    if p == 1:\n        return num \n    ans = pow(num, p//2) \n    if p % 2 == 0:\n        return ans * ans % mod\n    else:\n        return ans * ans * num % mod \n\nA, B, n, x = tuple(map(int, input().split()))\n\nif A != 1:\n    ans = B\n    ans *= ((pow(A, n) - 1) % mod * (pow(A-1, mod - 2) % mod)) % mod\n    ans += pow(A, n) * x % mod\n    ans %= mod\nelse:\n    ans = x + n * B\n    ans %= mod\n\n\nprint(round(ans))\n", "M = 1000000007\nA, B, n, x = (int(x) for x in input().split())\nif A > 1:\n    An = pow(A, n, M)\n    print((((An * x) % M) + (B * (1-An) * pow(1-A, M-2, M)) % M) % M)\n    #print(int(An * x + B * (1-An)/(1-A)) % M)\nelse:\n    print((x + B*n) % M)\n", "M = int(1e9 + 7)\nA, B, n, x = (int(x) for x in input().split())\nif A > 1:\n    An = pow(A, n, M)\n    print((An * x + B * (1-An) * pow(1-A, M-2, M)) % M)\nelse:\n    print((x + B*n) % M)\n", "\n(a, b, n, x) = map(int, input().split(\" \"))\n\nxp = pow(a, n % 1000000006, 1000000007)\n\nans = (xp * x) % 1000000007\n\nif (a == 1):\n\n\tans = ans + n * b\n\nelse:\n\n\ttmp = (xp - 1) * pow(a - 1, 1000000005, 1000000007) * b\n\n\ttmp = tmp % 1000000007\n\n\tans = ans + tmp\n\nans = ans % 1000000007\n\nprint (ans)", "a, b, n, x = map(int, input().split())\nMOD = 1000000007\n\ncur = x\nwhile n > 0:\n    if n & 1:\n        cur = (a * cur + b) % MOD\n    a, b = a*a % MOD, (a*b + b) % MOD\n    n >>= 1\nprint(cur)", "a, b, n, x = map(int, input().split())\nMOD = 1000000007\n\ncur = x\nwhile n > 0:\n    if n & 1:\n        cur = (a * cur + b) % MOD\n    a, b = a*a % MOD, (a*b + b) % MOD\n    n >>= 1\nprint(cur)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\n\nmod = 10 ** 9 + 7\na, b, n, x = map(int, input().split())\nans = (pow(a, n, mod) * x % mod) % mod\nif a != 1:\n    ans2 = ((b * (pow(a, n, mod) - 1) % mod) * modinv(a - 1, mod)) % mod\nelse:\n    ans2 = (b*(n*a)%mod)%mod\nprint((ans + ans2) % mod)", "q = input().split()\na = int(q[0])\nb = int(q[1])\nn = int(q[2])\nx = int(q[3])\nq = pow(a,n-1,1000000007)\nx = q*a*x\nif a == 1:\n    q = n\nelse:\n    q = (q-1)*pow(a-1,1000000005,1000000007)*a + 1\nq = q*b+x\nprint(q%1000000007)", "#!/usr/bin/env python3\n\n\ndef g(a, b, n, x, mod=10 ** 9 + 7):\n    if a == 1:\n        return (x + b * n) % mod\n    z = pow(a, n, mod)\n    inv = pow(a - 1 + mod, mod - 2, mod)\n    return (z * x + b * (z - 1 + mod) * inv) % mod\n\nprint(g(*[int(x) for x in input().split()]))\n"]
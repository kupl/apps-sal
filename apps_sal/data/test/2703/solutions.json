["# cook your dish here\nimport copy\nimport bisect\nn,q=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\na.sort()\nb=copy.copy(a)\nfor i in range(1,len(b)):\n b[i]+=b[i-1]\n##print(b)\nfor i in range(q):\n x=int(input())\n ans=bisect.bisect_left(a,x*2)\n if ans==0:\n  ans1=b[n-1]\n else:\n  ans1=b[n-1]-b[ans-1]\n print(ans1)\n", "from sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport random\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')): \n #------------------Sublime--------------------------------------#\n sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n def I():return (int(input()))\n def In():return(map(int,input().split()))\nelse:\n #------------------PYPY FAst I/o--------------------------------#\n def I():return (int(stdin.readline()))\n def In():return(map(int,stdin.readline().split()))\n#sys.setrecursionlimit(1500)\ndef dict(a):\n d={} \n for x in a:\n  if d.get(x,-1)!=-1:\n   d[x]+=1\n  else:\n   d[x]=1\n return d\ndef find_gt(a, x):\n 'Find leftmost value greater than x'\n i = bi.bisect_right(a, x)\n if i != len(a):\n  return i\n else:            \n  return -1\n\ndef find_ge(a, x):\n 'Find leftmost item greater than or equal to x'\n i = bi.bisect_left(a, x)\n if i != len(a):\n  return i\n else:\n  return -1\ndef main():\n try:\n  n,Q=In()\n  l=list(In())\n  l.sort()\n  pre=[0]\n  su=0\n  for x in range(n):\n   su+=l[x]\n   pre.append(su)\n  #print(pre)\n  for x in range(Q):\n   q=I()\n   q*=2\n   pos=find_ge(l,q)\n   #print(pos)\n   if pos==-1:\n    print(0)\n   else:\n    #print(pos)\n    ans=pre[-1]-pre[pos]\n    print(ans)\n except:\n  pass\n  \nM = 998244353\nP = 1000000007\n \ndef __starting_point():\n #for _ in range(I()):main()\n for _ in range(1):main()\n__starting_point()", "n,q=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl.sort(reverse=True)\np=[]\np.append(l[0])\nfor i in l[1:]:\n p.append(p[-1]+i)\ndef bs(l,c):\n i=0\n j=len(l)-1\n ans=-1\n while i<=j:\n  mid = i+(j-i)//2\n  if l[mid]>=c:\n   ans=mid\n   i=mid+1\n  else:\n   j=mid-1\n return ans\nfor _ in range(q):\n x=int(input())\n x=bs(l,2*x)\n if x==-1:\n  print(0)\n else:\n  print(p[x])\n \n"]
["class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         \n         def dfs(digits, current, result):\n             if not digits:\n                 result.append(current)\n                 return\n             for c in dic[digits[0]]:\n                 dfs(digits[1:], current + c, result)\n         \n         \n         if not digits:\n             return []\n         \n         dic = { '2' : \"abc\", '3': \"def\", '4':\"ghi\", \n                '5':\"jkl\", '6':\"mno\", '7':\"pqrs\", '8':\"tuv\",'9': \"wxyz\" }\n         result = []\n         dfs(digits, \"\", result)\n         return result\n         \n         \n         \n \n", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         if not digits:\n             return []\n         MAPPING = ('0', '1', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz')\n         def directed_combinations(i, partial):\n             if i == len(digits):\n                 result.append(''.join(partial))\n                 return\n             \n             for c in MAPPING[int(digits[i])]:\n                 directed_combinations(i + 1, partial + [c])\n         \n         result = []\n         directed_combinations(0, [])\n         return result", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         \n         dic = {'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], \n                '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z']}\n         \n         if '0' in digits:\n             digits = digits.replace('0','')\n         if '1' in digits:\n             digits = digits.replace('1','')\n         \n         count = 0\n         for a in '23456789':\n             if a not in digits:\n                 count += 1\n         if count == 8:\n             return []\n         \n     \n         res = []\n         \n         temp = ['']\n         i = 0\n         while i < len(digits):\n             for a in temp:\n                 for b in dic[digits[i]]:\n                     res.append(a+b)\n             temp = res\n             res = []\n             i += 1\n         return temp\n         \n         \n         \n         \n         \n", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         if '' == digits: \n             return []\n         \n         kvmaps = {\n             '2': 'abc',\n             '3': 'def',\n             '4': 'ghi',\n             '5': 'jkl',\n             '6': 'mno',\n             '7': 'pqrs',\n             '8': 'tuv',\n             '9': 'wxyz'\n         }\n         rst = ['']\n         for digit in digits:\n             temp = [s + c for s in rst for c in kvmaps[digit]]\n             rst = temp\n         \n         return rst\n", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         if digits==None or len(digits) ==0:\n             return []\n         res=[]\n         cur=\"\"\n         dmap={}\n         dmap[\"0\"]=[\" \"]\n         dmap[\"1\"]=[]\n         dmap[\"2\"]=[\"a\",\"b\",\"c\"]\n         dmap[\"3\"]=[\"d\",\"e\",\"f\"]\n         dmap[\"4\"]=[\"g\",\"h\",\"i\"]\n         dmap[\"5\"]=[\"j\",\"k\",\"l\"]\n         dmap[\"6\"]=[\"m\",\"n\",\"o\"]\n         dmap[\"7\"]=[\"p\",\"q\",\"r\",\"s\"]\n         dmap[\"8\"]=[\"t\",\"u\",\"v\"]\n         dmap[\"9\"]=[\"w\",\"x\",\"y\",\"z\"]\n         self.dfs(digits,dmap,0,cur,res)\n         return res\n     \n     def dfs(self,digits,dmap,idx,cur,res):\n         if idx ==len(digits):\n             res.append(cur)\n             return\n         else:\n             c=digits[idx]\n             for i in dmap[c]:\n                 self.dfs(digits,dmap,idx+1,cur+i,res)\n", "from functools import reduce\n \n class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         \n         d = {}\n         d[\"1\"] = \"\"\n         d[\"2\"] = \"abc\"\n         d[\"3\"] = \"def\"\n         d[\"4\"] = \"ghi\"\n         d[\"5\"] = \"jkl\"\n         d[\"6\"] = \"mno\"\n         d[\"7\"] = \"pqrs\"\n         d[\"8\"] = \"tuv\"\n         d[\"9\"] = \"wxyz\"\n         d[\"0\"] = \" \"\n         \n         digs = list(map(lambda x: list(d[x]), digits))\n         \n         return reduce(alg_mul, digs, [])\n                 \n \n def alg_mul(xs, ys):\n     if xs == []:\n         return ys\n     \n     ws = []\n     for x in xs:\n         for y in ys:\n             ws.append(x + y)\n     \n     return ws", "import queue\n class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         letterDict = {0:[],1:[],2:['a','b','c'],3:['d','e','f'],4:['g','h','i'],5:['j','k','l'],\n                       6:['m','n','o'],7:['p','q','r','s'],8:['t','u','v'],9:['w','x','y','z']}\n         if len(digits) == 0:\n             return []\n         res = [\"\"]\n         for i in range(len(digits)):\n             num = int(digits[i])\n             chars = letterDict[num]\n             if len(chars) == 0:\n                 continue\n             s = []\n             for j in range(len(chars)):\n                 for k in range(len(res)):\n                     s.append(res[k] + chars[j])\n             res = s\n         return res\n                     ", "import heapq\n \n \n class Solution:\n     def letterCombinations(self, digits):\n         digit_map = {'1': [\"\"],\n                     '2': ['a', 'b', 'c'],\n                     '3': ['d', 'e', 'f'],\n                     '4': ['g', 'h', 'i'],\n                     '5': ['j', 'k', 'l'],\n                     '6': ['m', 'n', 'o'],\n                     '7': ['p', 'q', 'r', 's'],\n                     '8': ['t', 'u', 'v'],\n                     '9': ['w', 'x', 'y', 'z'],\n                     '0': [\"\"]}\n         combs = []\n         # Queue will hold a list of tuples mapping to how many characters are already mapped, \n         # and the current converted string!\n         letter_q = [(0, \"\")]\n         if not digits:\n             return []\n         while letter_q:\n             cur = heapq.heappop(letter_q)\n             cur_idx = cur[0]\n             cur_str = cur[1]\n             next_dig = digits[cur_idx]\n             for value in digit_map[next_dig]:\n                 new_digit_str = (cur_idx+1, cur_str+value)\n                 if cur_idx + 1 >= len(digits):\n                     combs.append(new_digit_str)\n                 else:\n                     heapq.heappush(letter_q, new_digit_str)    \n         return list(map(lambda x: x[1], combs))", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         key = {2:'abc', 3:'def', 4:'ghi',5:'jkl',6:'mno',7:'pqrs',8:'tuv',9:'wxyz'}\n     \n         nonlocal out\n         out = ['']\n \n         def eachLetter(i):\n             if i < len(digits):\n                 nonlocal out\n                 if int(digits[i]) > 1:\n                     x = []\n                     for j in out:\n                         for k in key[int(digits[i])]:\n                             x.append(j+k)\n                     out = x\n \n                 eachLetter(i+1)\n \n         eachLetter(0)\n         \n         return [] if out[0] is '' else out\n", "from collections import defaultdict\n \n class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         digit_to_chars = defaultdict(list)\n         char_int = ord('a')\n         for i in range(2,10):\n             num_chars = 3 if i not in {7,9} else 4\n             for j in range(num_chars):\n                 digit_to_chars[str(i)].append(chr(char_int))\n                 char_int += 1\n         if not digits:\n             return []\n         letter_combinations = ['']\n         for digit in digits:\n             new_letter_combinations = []\n             for letter_combination in letter_combinations:\n                 for character in digit_to_chars[digit]:\n                     new_letter_combination = letter_combination + character\n                     new_letter_combinations.append(new_letter_combination)\n             letter_combinations = new_letter_combinations\n         return letter_combinations", "class Solution:\n     Dmap = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno',\n              '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n     \n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         if '1' in digits or '0' in digits:\n             return []\n         \n         if len(digits) == 0:\n             return []\n         \n         return self.letterC(digits)\n \n         \n     def letterC(self, digits):\n         if len(digits) == 0:\n             return ['']\n         \n         res = []\n         for back in self.letterC(digits[1:]):\n             for fr in self.Dmap[digits[0]]:\n                 res.append(fr + back)\n         \n         return res\n", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         self.dic={'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}\n         if not digits:\n             return []\n         res = []\n         self.dfs(digits,0,'',res)\n         return res\n     \n     def dfs(self, digits, index, path, res):\n         if len(path) == len(digits):\n             res.append(path)\n             return\n         for i in range(len(self.dic[digits[index]])):\n             path_ = path+self.dic[digits[index]][i]\n             self.dfs(digits,index+1,path_,res)\n         \n         \n", "class Solution:\n     def __init__(self):\n         self.phone = [\"\", \"\", \"abc\", \"def\",\"ghi\", \"jkl\", \"mno\", \"pqrs\",\"tuv\", \"wxyz\"]\n         \n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         \n         if not digits:\n             return []\n         \n         results = []\n         self.dfs(digits, results, \"\", 0)\n         return results\n     \n \n     def dfs(self, digits, results, string, index):\n         if index == len(digits):\n             results.append(string)\n         else: \n             letters = self.phone[int(digits[index])]    \n            \n             for i in range(0, len(letters)):\n                 self.dfs(digits, results, string + letters[i], index + 1)\n \n         \n     \n", "class Solution:\n     def letterCombinations(self, digits):\n         \"\"\"\n         :type digits: str\n         :rtype: List[str]\n         \"\"\"\n         interpret_digit = {\n             '1': '',\n             '2': 'abc',\n             '3': 'def',\n             '4': 'ghi',\n             '5': 'jkl',\n             '6': 'mno',\n             '7': 'pqrs',\n             '8': 'tuv',\n             '9': 'wxyz',\n             '0': ' '}\n         all_combinations = [''] if digits else []\n         for digit in digits:\n             current_combinations = list()\n             for letter in interpret_digit[digit]:\n                 for combination in all_combinations:\n                     current_combinations.append(combination + letter)\n             all_combinations = current_combinations\n         return all_combinations\n"]
["n = int(input())\nINF = 10 ** 18\ng = [[INF for i in range(n)] for _ in range(n)]\nfor i in range(n):\n\ts = input().rstrip()\n\tfor j in range(n):\n\t\tif s[j] == '1':\n\t\t\tg[i][j] = 1\n\tg[i][i] = 0\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j])\nm = int(input())\np = [int(i) - 1 for i in input().split()]\nptr = 1\nans = [p[0]]\nwhile ptr + 1 < len(p):\n\ts = ans[-1]\n\tif g[s][p[ptr]] + 1 != g[s][p[ptr + 1]]:\n\t\tans.append(p[ptr])\n\tptr += 1\nans.append(p[-1])\nprint(len(ans))\nfor i in ans:\n\tprint(i + 1, end=\" \")", "import sys\nimport copy\ninput = sys.stdin.readline\n\nn=int(input())\nEDGE=[list(map(int,list(input().strip()))) for i in range(n)]\nm=int(input())\nP=list(map(int,input().split()))\n\nDistance=copy.deepcopy(EDGE)\n\nfor i in range(n):\n    for j in range(n):\n        if Distance[i][j]==0 and i!=j:\n            Distance[i][j]=float(\"inf\")\n        \n\nfor k in range(n):# k\u500b\u307e\u3067\u306e\u753a\u3092\u4f7f\u3063\u3066\u306eDis\u304c\u77e5\u308c\u3066\u3044\u308b\u3068\u304d\u306b\n    for i in range(n):# \u753ai\u3068\n        for j in range(n):# \u753aj\u3068\u306e\u6700\u77ed\u8ddd\u96e2\u306f\u3001\n            length=Distance[i][k]+Distance[k][j]\n            if Distance[i][j]>length:\n                Distance[i][j]=length\n\nANS=[P[0]]\n\nNOW=0\n\ni=1\nwhile i<m:\n    if Distance[P[NOW]-1][P[i]-1]==i-NOW:\n        i+=1\n\n    else:\n        ANS.append(P[i-1])\n        NOW=i-1\n\nANS.append(P[-1])\nprint(len(ANS))\nprint(*ANS)\n    \n\n", "n = int(input())\nG = [[] for _ in range(n)]\nfor i in range(n):\n\tl = input()\n\tfor j in range(n):\n\t\tif l[j] == '1':\n\t\t\tG[i].append(j)\n\nds = [[-1]*n for _ in range(n)]\nfor i in range(n):\n\tds[i][i] = 0\n\tl = [i]\n\twhile len(l) > 0:\n\t\tl2 = []\n\t\tfor j in l:\n\t\t\tfor k in G[j]:\n\t\t\t\tif ds[i][k] == -1:\n\t\t\t\t\tds[i][k] = ds[i][j]+1\n\t\t\t\t\tl2.append(k)\n\t\tl = l2\n\nm = int(input())\np = list(map(int, input().split()))\nres = 2\nvs = [str(p[0])]\ni, j = 0, 1\nwhile j < m:\n\tif ds[p[i]-1][p[j]-1] < j-i:\n\t\tres += 1\n\t\ti = j-1\n\t\tvs.append(str(p[j-1]))\n\tj += 1\nvs.append(str(p[-1]))\nprint(res)\nprint(\" \".join(vs))", "n = int(input())\n\nnei = []\nfor _ in range(n):\n\ts = input()\n\tnei.append(list(int(c) for c in s))\n\nm = int(input())\n\np = list([int(x)-1 for x in input().split()])\n\nshortest = []\nfor i in range(n):\n\tvals = []\n\tfor j, con in enumerate(nei[i]):\n\t\tif i==j:\n\t\t\tvals.append(0)\n\t\telif con:\n\t\t\tvals.append(1)\n\t\telse:\n\t\t\tvals.append(10**6)\n\tshortest.append(vals)\n\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tshortest[i][j] = min(shortest[i][j], shortest[i][k] + shortest[k][j])\n\nseq = [p[0]]\ndist = 0\nfor prev, cur in zip(p, p[1:]):\n\tdist += shortest[prev][cur]\n\tif shortest[seq[-1]][cur] < dist:\n\t\tdist = shortest[prev][cur]\n\t\tseq.append(prev)\nseq.append(p[-1])\n\nprint(len(seq))\nprint(*[val+1 for val in seq])", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn = int(input())\ns = [input() for _ in range(n)]\nd = [[10 ** 30 for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tfor j in range(n):\n\t\tif s[i][j] == \"1\":\n\t\t\td[i][j] = 1\n\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j])\n\n#for i in range(n):\n#\tprint(*d[i])\n\nm = int(input())\np = list(map(int, input().split()))\n\nans = [p[0]]\ncur = 1\nwhile cur < m-1:\n\tif ans[-1] == p[cur+1]:\n\t\tans.append(p[cur])\n\telif d[ans[-1]-1][p[cur]-1] + d[p[cur]-1][p[cur+1]-1] > d[ans[-1]-1][p[cur+1]-1]:\n\t\tans.append(p[cur])\n\tcur += 1\nans.append(p[-1])\n\nprint(len(ans))\nprint(*ans)", "def path(s):\n    s1= {s}\n    s2 = set()\n    used = [0] * (n + 1)\n    used[s] = 1\n    ans = 0\n    while s1:\n        ans += 1\n        for v in s1:\n            for u in graph[v]:\n                if used[u] == 0:\n                    paths[s][u] = ans\n                    used[u] = 1\n                    s2.add(u)\n        s1 = s2\n        s2 = set()\n\n\nn = int(input())\nA = [list(map(int, input())) for _ in range(n)]\ngraph = {i: set() for i in range(1, n + 1)}\nfor i in range(n):\n    for j in range(n):\n        if A[i][j]:\n           graph[i + 1].add(j + 1)\nm = int(input())\nP = list(map(int, input().split()))\npaths = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    path(i)\nu = 0\nv = P[0]\nans = []\nwhile u < m - 1:\n    ans.append(P[u])\n    l = u\n    r = min(m, u + n + 1)\n    while r - l > 1:\n        mid = (l + r) // 2\n        if paths[P[u]][P[mid]] == mid - u:\n            l = mid\n        else:\n            r = mid\n    u = l\nans.append(P[-1])\nprint(len(ans))\nprint(*ans)\n", "from collections import deque\nN = int(input())\nEdge = [list(map(int,input().strip())) for _ in range(N)]\n\ndist = []\ninf = 10**9\nfor i in range(N):\n    d = [inf]*N\n    d[i] = 0\n    Q = deque([i])\n    unused = set(range(N))\n    unused.remove(i)\n    while Q:\n        vn = Q.pop()\n        for vf in unused.copy():\n            if Edge[vn][vf]:\n                unused.remove(vf)\n                d[vf] = 1 + d[vn]\n                Q.appendleft(vf)\n    dist.append(d)\n\nM = int(input())\nV = tuple([int(x) - 1 for x in input().split()])\n\nAns = [V[0]]\n\nfor v in V[1:]:\n    while len(Ans) > 1 and dist[Ans[-2]][Ans[-1]] + dist[Ans[-1]][v] == dist[Ans[-2]][v]:\n        Ans.pop()\n    Ans.append(v)\n\nAns = [a+1 for a in Ans]\nprint(len(Ans))\nprint(*Ans)\n", "from sys import stdin\nfrom sys import setrecursionlimit as SRL; SRL(10**7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\n\ndis = [[1000000000]*101 for _i in range(101)]\n\nn = int(rd())\nfor i in range(n+1):\n    dis[i][i] = 0\n\nfor i in range(1,n+1):\n    s = str(rd().strip())\n    for j in range(n):\n        if s[j] == '1':\n            dis[i][j+1] = 1\n\n\n\nfor k in range(1,n+1):\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j])\n\n\nm = int(rd())\np = list(rrd())\n\nans = []\n\ns = 0\npre = 0\nl = 0\nfor i in p:\n    if len(ans) == 0:\n        s = i\n        pre = i\n        ans.append(i)\n        continue\n    if dis[s][i] == l+1:\n        pre = i\n        l+=1\n        continue\n    else:\n        ans.append(pre)\n\n        s = pre\n        pre = i\n        l = 1\n\nif s != pre:\n    ans.append(pre)\n\nprint(len(ans))\nprint(*ans)", "import math\nfrom collections import deque, defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\nlistin = lambda : list(map(int, input().split()))\nmapin = lambda : map(int, input().split())\nn = int(input())\nd = defaultdict(set)\nfor _ in range(n):\n    z = input()\n    for i in range(n):\n        if z[i] == '1':\n            d[_+1].add(i+1)\nm = int(input())\nz = listin()\nans = [z[0]]\nfor i in range(1, m-1):\n    if z[i] in d[ans[-1]] and z[i+1] in d[z[i]] and z[i+1] not in d[ans[-1]] and ans[-1]!=z[i+1]:\n        pass\n    else:\n        ans.append(z[i])\nans.append(z[-1])\nprint(len(ans))\nprint(*ans)", "from sys import stdout\nimport heapq\nprintn = lambda x: stdout.write(x)\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      list(map(int, input().split()))\nDBG = True # and False\nBIG = 999999999\nR = 10**9 + 7\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\ndef setc2c():\n  for c1 in range(n):\n    dist = [BIG]*n\n    dist[c1] = 0\n    hp = [(0,c1)]\n    while len(hp)>0:\n        curlen,curloc = heapq.heappop(hp)\n        if curlen > dist[curloc]:\n            continue\n        for nxtloc in dst[curloc]:\n            newdist = dist[curloc]+1\n            if newdist < dist[nxtloc]:\n                dist[nxtloc] = newdist\n                heapq.heappush(hp, (newdist, nxtloc))\n    for c2 in range(n):\n        c2c[c1][c2] = dist[c2]\n\n# main\n\nn = inn()\ndst = [ [] for i in range(n) ]\nc2c = [ [0]*n for i in range(n) ]\n\nfor i in range(n):\n    s = input()\n    for j in range(n):\n        if s[j]=='1':\n            dst[i].append(j)\n\nm= inn()\np = [x-1 for x in inl()]\n\nsetc2c()\n\nv = [p[0]]\ncurv = p[0]\ncuri = 0\nfor i in range(1,m):\n    if c2c[curv][p[i]] < i - curi:\n        v.append(p[i-1])\n        curv = p[i-1]\n        curi = i-1\n\nv.append(p[m-1])\nk = len(v)\nprint(k)\nfor i in range(k):\n    printn((' ' if i>0 else '') + str(v[i]+1))\nprint('')\n", "n=int(input())\nd=[]\nfor i in range(n):\n\td+=[[int(i) for i in input()]]\ninf=200\nfor i in range(n):\n\tfor j in range(n):\n\t\tif d[i][j]==0 and i!=j:\n\t\t\td[i][j]=inf\nfor k in range(n):\n\tfor j in range(n):\n\t\tfor i in range(n):\n\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j])\nm=int(input())\np=list(map(int,input().split()))\npath=[p[0]]\nj=0\nk=0\ni=0\nwhile i<=m-1:\n\tif d[p[j]-1][p[i]-1]==i-j:\n\t\tk=i\n\t\ti+=1\n\telif j!=k:\n\t\tpath.append(p[k])\n\t\tj=k\n\t\ti-=1\npath.append(p[m-1])\nprint(len(path))\nprint(\" \".join(map(str,path)))\t", "n=int(input())\na=[0]\nfor i in range(n):\n    a.append(list(input()))\nx=int(input())\nb=list(map(int,input().split()))\nif x==2:\n    print(2)\n    print(*b)\n    return\nst=[b[0]]\nst1=[b[0]]\nk=b[1]\nfor i in range(1,n+1):\n    a[i][i-1]='1'\n    \n# print(a)\npr=[]\npr.append(b[0])\n# print(,end=\" \")\nfor j in range(2,x):\n    for l in st1:\n        # print(st,st1,k,b[j])\n        if a[l][b[j]-1]=='1':\n            st.append(k)\n            st=[k]\n            st1=[k]\n            # print(k,end=\" \")\n            pr.append(k)\n            k=b[j]\n            \n            break\n    else:\n        st1.append(b[j])\n        k=b[j]\npr.append(b[-1])        \n# print(b[-1])    \nprint(len(pr))\nprint(*pr)\n        \n        \n        \n    \n", "def gns():\n    return list(map(int,input().split()))\nn=int(input())\nmp=[]\nfor i in range(n):\n    mp.append(input())\n\ndef bfs(i):\n    nxt=[i]\n    ans=[None]*n\n    ans[i]=0\n    v=[False]*n\n    v[i]=True\n    p=0\n    while len(nxt)>0:\n        p+=1\n        nxt_=[]\n        for ni in nxt:\n            for nn in range(n):\n                if v[nn] or mp[ni][nn]=='0':\n                    continue\n                v[nn]=True\n                ans[nn]=p\n                nxt_.append(nn)\n        nxt=nxt_\n    return ans\ndis=[None]*n\nfor i in range(n):\n    dis[i]=bfs(i)\nm=int(input())\nms=gns()\nms=[x-1 for x in ms]\n\nans=[ms[0]]\nl=ms[0]\nfor i in range(1,m-1):\n    c=ms[i]\n    cn=ms[i+1]\n    if dis[l][cn]<=dis[l][c]:\n        ans.append(c)\n        l=c\nans.append(ms[-1])\nans=[x+1 for x in ans]\nprint(len(ans))\nprint(' '.join(map(str,ans)))\n\n\n", "n=int(input())\na=[]\nfor i in range(n):\n    a.append(list(map(int,list(input()))))\n#print(*a)\nm=int(input())\nb=list(map(int,input().split()))\nfor i in range(n):\n    for j in range(n):\n        if i!=j and a[i][j]==0:\n            a[i][j]=10**18\nfor k in range(n): \n    for i in range(n): \n        for j in range(n): \n            a[i][j] = min(a[i][j] , a[i][k]+ a[k][j]) \nans=[]\nfor i in range(m):\n    if i==0 or i==m-1:\n        ans.append(b[i])\n        continue\n    x=ans[-1]-1\n    if(a[x][b[i]-1]+a[b[i]-1][b[i+1]-1]==a[x][b[i+1]-1]):\n        continue\n    ans.append(b[i])\nprint(len(ans))\nprint(*ans)\n#print(*a)\n", "import sys\ninput = sys.stdin.readline\n\nINF = 10**12\nn = int(input())\nedge = [[] for _ in range(n)]\nfor i in range(n):\n    line = input().rstrip()\n    for j, ch in enumerate(line):\n        if i == j:\n            edge[i].append(0)\n        elif ch == \"1\":\n            edge[i].append(1)\n        else:\n            edge[i].append(INF)\nm = int(input())\na = [int(item) for item in input().split()]\n\nif m == 2:\n    print(2)\n    print(\" \".join([str(item) for item in a]))\n    return\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j])\n\n# for line in edge:\n#     print(line)\n\nfrm_id = 0\nmid_id = 1\nto_id = 2\nans_num = 0\nans = [a[frm_id]]\nans_num += 1\nwhile to_id < len(a):\n    frm = a[frm_id] - 1\n    mid = a[mid_id] - 1\n    to = a[to_id] - 1\n    if frm == to or not edge[frm][mid] + edge[mid][to] == edge[frm][to]:\n        ans.append(mid + 1)\n        ans_num += 1\n        frm_id = mid_id \n        to_id += 1\n        mid_id += 1\n    else:\n        to_id += 1\n        mid_id += 1\nans.append(to + 1)\nans_num += 1\nprint(ans_num)\nprint(\" \".join([str(item) for item in ans]))", "from collections import deque\nn = int(input())\ngraph = [list([bit == '1' for bit in list(input())]) for _ in range(n)]\nm = int(input())\nway = list([int(i) - 1 for i in input().split()])\n#print(graph)\n\ndef dfs(start):\n    queue = deque([start])\n    d = [-1] * n\n    d[start] = 0\n    while len(queue) != 0:\n        u = queue[0]\n        queue.popleft()\n        for v in range(n):\n            if graph[u][v] and d[v] == -1:\n                d[v] = d[u] + 1\n                queue.append(v)\n    return d\n\n\nminpath = list(map(dfs, list(range(n))))\ngood = [way[0]]\ncheckp = way[0]\nfor i in range(1, m):\n    prev = way[i - 1]\n    if minpath[checkp][way[i]] != minpath[checkp][prev] + 1:\n        good.append(prev)\n        checkp = prev\n#print(minpath)\ngood.append(way[-1])\nprint(len(good))\nprint(' '.join([str(p + 1) for p in good]))\n", "def warshall_floyd(d):\n    #d[i][j]: i\u304b\u3089j\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                d[i][j] = min(d[i][j],d[i][k] + d[k][j])\n    return d\n\nn=int(input())\ng=[list(input()) for _ in range(n)]\nd=[[float('inf')]*n for _ in range(n)]\nfor i in range(n):\n  for j in range(n):\n    if g[i][j]=='1':\n      d[i][j]=1\nwarshall_floyd(d)\nm=int(input())\narr=list(map(int,input().split()))\nfor i in range(m):\n  arr[i]-=1\nans=[arr[0]]\npos1=0\npos2=1\npos3=2\nfor i in range(m-2):\n  a,b,c=arr[pos1],arr[pos2],arr[pos3]\n  if a!=c:\n    if d[a][b]+d[b][c]>d[a][c]:\n      ans.append(b)\n      pos1=pos2\n      pos2=pos1+1\n      pos3=pos2+1\n    else:\n      pos2+=1\n      pos3+=1\n  else:\n    if d[a][b]+d[b][c]>=d[a][c]:\n      ans.append(b)\n      pos1=pos2\n      pos2=pos1+1\n      pos3=pos2+1\n    else:\n      pos2+=1\n      pos3+=1\nans.append(arr[-1])\nl=len(ans)\nfor i in range(l):\n  ans[i]+=1\nprint(l)\nprint(*ans)", "import sys\n\nn = int(sys.stdin.readline().strip())\nA = []\nfor i in range (0, n):\n    A.append(sys.stdin.readline().strip())\nD = [[-200 for i in range (0, n)] for j in range (0, n)]\nL = []\nL2 = []\nfor i in range (0, n):\n    D[i][i] = 0\n    L.append([i,i])\nfor i in range (0, n):\n    while len(L) > 0:\n        x,y = L.pop()\n        for j in range (0, n):\n            if A[y][j] == \"1\" and D[x][j] == -200:\n                D[x][j] = i + 1\n                L2.append([x,j])\n    L = L2[:]\n    L2 = []\n\nm = int(sys.stdin.readline().strip())\np = list(map(int,sys.stdin.readline().strip().split()))\nk = 1\nans = []\ni = 0\nj = 1\nwhile j < m-1:\n    if D[p[i]-1][p[j+1]-1] == j+1-i:\n        j = j + 1\n    else:\n        ans.append(p[i])\n        i = j\n        j = j+1\nans.append(p[i])\nif i != m-1:\n    ans.append(p[m-1])\nprint(len(ans))\nprint(\" \".join(list(map(str,ans))))\n\n", "from heapq import heapify, heappush as hpush, heappop as hpop\nN = int(input())\nX = [[] for _ in range(N)]\nfor i in range(N):\n    s = input()\n    for j in range(N):\n        if s[j] == \"1\":\n            X[i].append((j, 1))\n\ndef dijkstra(n, E, i0=0):\n    h = [[0, i0]]\n    D = [-1] * n\n    done = [0] * n\n    D[i0] = 0\n    \n    while h:\n        d, i = hpop(h)\n        done[i] = 1\n        for j, w in E[i]:\n            nd = d + w\n            if D[j] < 0 or D[j] >= nd:\n                if done[j] == 0:\n                    hpush(h, [nd, j])\n                    D[j] = nd\n    return [d if d >= 0 else 1<<50 for d in D]\n\nY = []\nfor i in range(N):\n    Y.append(dijkstra(N, X, i))\n\n# print(\"Y =\", Y)\n\nM = int(input())\nV = [int(a)-1 for a in input().split()]\n\na = 0\nb = 1\nt = Y[V[a]][V[b]]\nANS = [V[a]+1]\nwhile b < M:\n    if Y[V[a]][V[b]] < t:\n        a = b-1\n        ANS.append(V[a]+1)\n        t = Y[V[a]][V[b]]\n    elif b == M-1:\n        break\n    else:\n        t += Y[V[b]][V[b+1]]\n        b += 1\nANS.append(V[M-1]+1)\nprint(len(ANS))\nprint(*ANS)", "\n\nfrom collections import defaultdict\n\ndef bfs(root):\n    bool = [False]*(n+1)\n    queue = [root]\n    bool[root] = True\n    level = defaultdict(int)\n    level[root] = 0\n    while queue:\n        z = queue.pop(0)\n\n        for i in hash[z]:\n          if bool[i] == False:\n              bool[i] = True\n              level[i]+=1+level[z]\n              queue.append(i)\n\n\n    return level\n\nhash = defaultdict(list)\nn = int(input())\n\nl = []\n\nfor i in range(n):\n    k = list(input())\n    l.append(k)\n\nfor i in range(n):\n    for j in range(n):\n        if l[i][j] == '1':\n            hash[i+1].append(j+1)\nn1 = int(input())\nla = list(map(int,input().split()))\n\nroot = la[0]\n\n\n\n\nfull = {}\n\nfor i in range(1,n+1):\n    full[i] = bfs(i)\n\n\n\nans = [la[0]]\n\nj = 0\n\nwhile j<len(la):\n\n    k = j+1\n\n    while k<len(la):\n        # print(k-)\n        if full[la[j]][la[k]] == k-j:\n           k+=1\n        else:\n            break\n\n\n\n    # break\n    if k == j:\n        ans.append(la[j])\n        j+=1\n    else:\n        ans.append(la[k-1])\n        j=  k-1\n        if j == len(la)-1:\n            break\n\n\nprint(len(ans))\nprint(*ans)\n\n\n", "''' \u0628\u0650\u0633\u0652\u0645\u0650 \u0627\u0644\u0644\u064e\u0651\u0647\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0652\u0645\u064e\u0670\u0646\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0650\u064a\u0645\u0650 '''\n#codeforces1204C\ngi = lambda : list(map(int,input().split()))\nn, = gi()\ng = [list(map(int, list(input()))) for _ in range(n)]\nlenp, = gi()\np = gi()\nans = p[:]\nlenans = lenp\nk = 1\nwhile k < lenp - 1:\n\tif g[ans[k - 1] - 1][ans[k + 1] - 1] == 0 and ans[k - 1] != ans[k + 1]:\n\t\tp[k] = -1\n\t\tans[k] = ans[k - 1]\n\t\tlenans -= 1\n\t\tk += 1\n\tk += 1\nprint(lenans)\nfor k in range(lenp):\n\tif p[k] != -1:\n\t\tprint(ans[k], end=\" \")"]
["#!/usr/bin/env python3\n\n\nclass CantException(Exception):\n    pass\n\n\ndef odd_v(value):\n    return 1 if value % 2 == 1 else -1\n\n\nchange_idx = 1\n\nacceptable = {-1: set(), 1: set()}\n\n\ndef change(card_values, oddv, m):\n    nonlocal change_idx\n\n    if acceptable[oddv]:\n        res = acceptable[oddv].pop()\n        card_values.add(res)\n        return res\n\n    change_idx_start = change_idx\n\n    while change_idx in card_values or odd_v(change_idx) != oddv:\n        if change_idx not in card_values:\n            acceptable[odd_v(change_idx)].add(change_idx)\n        change_idx += 1\n        if change_idx > m:\n            change_idx = 1\n        if change_idx == change_idx_start:\n            raise CantException()\n\n    res = change_idx\n    card_values.add(res)\n\n    change_idx += 1\n    if change_idx > m:\n        change_idx = 1\n    return res\n\n\ndef solve():\n    n, m = list(map(int, input().split()))\n    cards = list(map(int, input().split()))\n\n    odd_balance = 0\n    card_values = set()\n    indices_to_be_changed = set()\n\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n        if c in card_values:\n            indices_to_be_changed.add(i)\n        card_values.add(c)\n\n    # print(\"indices to be changed: \", indices_to_be_changed)\n    change_count = len(indices_to_be_changed)\n\n    for i in indices_to_be_changed:\n        if odd_v(cards[i]) * odd_balance <= 0:\n            #print(\"Changing \", cards[i])\n            cards[i] = change(card_values, odd_v(cards[i]), m)\n            #print(\"Changed to \", cards[i])\n        else:\n            #print(\"For teh balance changing \", cards[i])\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, - odd_v(cards[i]), m)\n            #print(\"Changed to \", cards[i])\n\n    #print(\"current odd balance:\", odd_balance)\n    for i in range(len(cards)):\n        if odd_balance == 0:\n            break\n        if odd_v(cards[i]) * odd_balance > 0:\n            # print(\"gonna change\")\n            change_count += 1\n            odd_balance -= 2 * odd_v(cards[i])\n            cards[i] = change(card_values, -odd_v(cards[i]), m)\n\n    odd_balance = 0\n    for i, c in enumerate(cards):\n        odd_balance += odd_v(c)\n    if odd_balance != 0:\n        print(odd_balance)\n        print(\"WTFFFFF\")\n\n    return change_count, cards\n\n\ndef __starting_point():\n    try:\n        change_cnt, cards = solve()\n        print(change_cnt)\n        print(\" \".join(map(str, cards)))\n    except CantException:\n        print(\"-1\")\n\n__starting_point()", "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ncounter = 0\n\ns = set(a)\nnech = set()\nchet = set()\nfor elem in a:\n    if elem % 2:\n        nech.add(elem)\n    else:\n        chet.add(elem) \n\nwhile len(nech) > n // 2:\n    nech.pop()\nwhile len(chet) > n // 2:\n    chet.pop()\n\nl_n =  set([i for i in range(1, min(m + 1, 1000000), 2)])\nl_ch = set([i for i in range(2, min(m + 1, 1000000), 2)])\n\nl_ch.difference_update(chet)\nl_n.difference_update(nech)\n\n#print(l_ch)\n#print(l_n, nech)\n\nif len(l_ch) + len(chet) < n // 2 or len(l_n) + len(nech) < n // 2:\n    print(-1)\nelse:\n    n1 = len(chet)\n    n2 = len(nech)\n    for i in range(n):\n        if a[i] in chet:\n            chet.remove(a[i])\n        elif a[i] in nech:\n            nech.remove(a[i])\n        else:\n            counter += 1\n            if (n//2 - n1) > 0:\n                a[i] = l_ch.pop()\n                n1 += 1\n            else:\n                a[i] = l_n.pop()\n                n2 += 1 \n        \n    print(counter)    \n    print(*a)", "import sys\nimport math\n\n\ndef main():\n    n,m = map(int,sys.stdin.readline().split())\n    x = list(map(int,sys.stdin.readline().split()))\n\n    c = []\n    nc = []\n    d = {}\n    for i in range(n):\n        xi = x[i]\n        if xi in d:\n            continue\n        d[xi] = True\n        if xi%2 == 0:\n            c.append((xi,i))\n        else:\n            nc.append((xi,i))\n\n    a, b = -1,0\n\n    if len(nc) > len(c):\n        c,nc = nc,c\n        a,b = b,a\n\n    c = sorted(c, key=lambda x: -x[0])\n    d = {}\n    r = [0]*n\n    for i in range(len(nc)):\n        xi,j = nc[i]\n        r[j] = xi\n        d[xi]= True\n        \n    for i in range(min(n//2,len(c))):\n        xi,j = c[i]\n        r[j] = xi\n        d[xi]= True\n    \n    j=0    \n    ans=0\n    for i in range(len(c),n//2):\n        b+=2\n        while b in d:\n            b+=2\n        while r[j]!=0:\n            j+=1 \n        r[j] = b\n        ans+=1\n    for i in range(len(nc),n//2):\n        a+=2\n        while a in d:\n            a+=2\n        while r[j]!=0:\n            j+=1 \n        r[j] = a\n        ans+=1\n\n    if a>m or b>m:\n        print(-1)\n        return \n    \n    print(ans)\n    \n    print(' '.join(map(str,r)))\n\n\nmain()", "def solve(A, n, m):\n    uniq = set(A)\n    odd = list([x for x in uniq if x%2])\n    even = list([x for x in uniq if x%2 == 0])\n    if len(odd) > n//2:\n        odd.sort()\n        odd = odd[-n//2:]\n    if len(even) > n//2:\n        even.sort()\n        even = even[-n//2:]\n\n    odd_needed = n//2 - len(odd)\n    changes = n - len(odd) - len(even)\n    k = 1 if odd_needed else 2\n\n    D = {x: True for x in odd + even}\n    A1 = A[:]\n    for i, a in enumerate(A):\n        if a in D and D[a]:\n            D[a] = False\n        else:\n            while k in D:\n                k += 2\n            if k > m:\n                return None\n            A1[i] = k\n            k += 2\n            if odd_needed == 1: k = 2\n            if odd_needed >= 1: odd_needed -= 1\n    \n    return A1, changes\n    \nn, m = list(map(int, input().split()))\nA = [int(x) for x in input().split()]\np = solve(A, n, m)\nif p is None:\n    print(-1)\nelse:\n    print(p[1])\n    print(' '.join(map(str, p[0])))\n"]
["n = int(input())\nL = [(0, 0)] * n\nfor i in range(n):\n    t = input().split(' ')\n    a = int(t[0])\n    b = int(t[1])\n    L[i] = (a, b)\nif n <= 4:\n    print(\"YES\")\nelse:\n    b0 = True\n    b1 = True\n    b2 = True\n    L0 = []\n    L1 = []\n    L2 = []\n    for j in range(n):\n        if (L[0][0]-L[1][0])*(L[0][1]-L[j][1])!=(L[0][1]-L[1][1])*(L[0][0]-L[j][0]):\n            L2.append(L[j])\n        if (L[2][0]-L[0][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[0][1])*(L[2][0]-L[j][0]):\n            L1.append(L[j])\n        if (L[2][0]-L[1][0])*(L[2][1]-L[j][1])!=(L[2][1]-L[1][1])*(L[2][0]-L[j][0]):\n            L0.append(L[j])\n    if len(L0) >= 3:\n        for j in range(2, len(L0)):\n            if (L0[0][0]-L0[1][0])*(L0[0][1]-L0[j][1])!=(L0[0][1]-L0[1][1])*(L0[0][0]-L0[j][0]):\n                b0 = False\n    if len(L1) >= 3:\n        for j in range(2, len(L1)):\n            if (L1[0][0]-L1[1][0])*(L1[0][1]-L1[j][1])!=(L1[0][1]-L1[1][1])*(L1[0][0]-L1[j][0]):\n                b1 = False\n    if len(L2) >= 3:\n        for j in range(2, len(L2)):\n            if (L2[0][0]-L2[1][0])*(L2[0][1]-L2[j][1])!=(L2[0][1]-L2[1][1])*(L2[0][0]-L2[j][0]):\n                b2 = False\n    if b0 or b1 or b2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "n = int(input())\nx = [0] * n\ny = [0] * n\nfor i in range(n):\n    xi, yi = list(map(int, input().split()))\n    x[i], y[i] = xi, yi\n\nif n <= 4:\n    print(\"YES\"); return\n\nl = lambda i, j, k : (y[i] - y[j]) * (x[i] - x[k]) == (y[i] - y[k]) * (x[i] - x[j])\n\ndef check(ind):\n    if len(ind) <= 2:\n        return True\n    for k in range(2, len(ind)):\n        if not l(ind[0], ind[1], ind[k]):\n            return False\n    return True\n\ndef diff(i, j):\n    return [_ for _ in range(n) if not l(i, j, _)]\n        \ndf = diff(0, 1)\n\nif check(df):\n    print(\"YES\"); return\nf = df[0]\n\ndf2 = diff(0, f)\nif check(df2):\n    print(\"YES\"); return\n\ndf3 = diff(1, f)\nif check(df3):\n    print(\"YES\"); return\n\nprint(\"NO\")\n        \n\n    \n\n", "#!/usr/bin/env python3\n\nimport sys\nfrom itertools import combinations\n\nn = int(sys.stdin.readline().strip())\nxys = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\nxys = list(set(xys))\nif len(xys) < 5:\n\tprint ('YES')\n\treturn\n\ndef is_on_line(p0, p1, p2):\n\treturn ((p1[0] - p0[0]) * (p2[1] - p0[1]) == (p1[1] - p0[1]) * (p2[0] - p0[0]))\n\nl1 = (-1, -1, -1)\nfor comb in combinations(list(range(5)), 3):\n\tif is_on_line(xys[comb[0]], xys[comb[1]], xys[comb[2]]):\n\t\tl1 = comb\n\t\tbreak\n\nif l1[0] < 0:\n\tprint ('NO')\n\treturn\n\nline = [0 for _ in range(n)]\nfor l in l1:\n\tline[l] = 1\n\nfor i in range(n):\n\tif i in l1:\n\t\tcontinue\n\tif is_on_line(xys[l1[0]], xys[l1[1]], xys[i]):\n\t\tline[i] = 1\n\nnline = [i for i in range(n) if line[i] == 0]\nif len(nline) < 3:\n\tprint ('YES')\n\treturn\n\nfor i in nline[2:]:\n\tif not is_on_line(xys[nline[0]], xys[nline[1]], xys[i]):\n\t\tprint ('NO')\n\t\treturn\n\nprint ('YES')\n", "def f(ii, i0, i1):\n    nonlocal xy\n    rtn = []\n    x0, y0 = xy[i0]\n    x1, y1 = xy[i1]\n    for i in ii:\n        xi, yi = xy[i]\n        if (xi - x0) * (yi - y1) != (xi - x1) * (yi - y0):\n            rtn.append(i)\n    return rtn\n\n\ndef g(i0, i1):\n    nonlocal f, n\n    ls = f(list(range(n)), i0, i1)\n    if len(ls) <= 2:\n        return -1\n    else:\n        rs = f(ls, ls[0], ls[-1])\n        if len(rs) == 0:\n            return -1\n        else:\n            return rs[0]\n\n\nn = int(input())\nxy = [tuple(map(int, input().split())) for _ in range(n)]\n\nans = \"NO\"\nif n <= 4:\n    ans = \"YES\"\nelse:\n    xy.sort()\n    i = g(0, n - 1)\n    if i < 0:\n        ans = \"YES\"\n    elif g(0, i) < 0:\n        ans = \"YES\"\n    elif g(n - 1, i) < 0:\n        ans = \"YES\"\nprint(ans)\n", "from itertools import combinations\nfrom fractions import gcd\n\ndef main():\n    n = int(input())\n    p = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, p))\n\ndef solve(n, p):\n    if n < 5:\n        return \"YES\"\n    p5 = p[:5]\n##    for p1, p2 in combinations(p5, 2):\n##        print(p1, p2, line(p1, p2), nb_points(line(p1, p2), p5))\n    lines = set(line(p1, p2) for p1, p2 in combinations(p5, 2))\n##    for l in lines:\n##        print(l, nb_points(l, p5))\n    l0 = None\n    for l in lines:\n        if nb_points(l, p5) > 2:\n            l0 = l\n            break\n    if l0 is None:\n        return \"NO\"\n    pr = [pi for pi in p if not belongs(pi, l0)]\n    if colinear(pr):\n        return \"YES\"\n    return \"NO\"\n\ndef line(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    a = y2 - y1\n    b = x1 - x2\n    c = x2 * y1 - x1 * y2\n    if a < 0:\n        a, b, c = -a, -b, -c\n    if a == 0:\n        if b < 0:\n            b, c = -b, -c\n        if c == 0:\n            b = 1\n        else:\n            g = abs(gcd(b, c))\n            b, c = b // g, c // g\n    else:\n        if b == 0:\n            if c == 0:\n                a = 1\n            else:\n                g = abs(gcd(a, c))\n                a, c = a // g, c // g\n        else:\n            if c == 0:\n                g = abs(gcd(a, b))\n                a, b = a // g, b // g\n            else:\n                g = abs(gcd(gcd(a, b), c))\n                a, b, c = a // g, b // g, c // g\n    return a, b, c\n\ndef belongs(pi, l):\n    a, b, c = l\n    return a * pi[0] + b * pi[1] + c == 0\n\ndef nb_points(l, p):\n    return sum(1 for pi in p if belongs(pi, l))\n\ndef colinear(p):\n    if len(p) <= 2:\n        return True\n    l = line(p[0], p[1])\n    return all(belongs(pi, l) for pi in p[2:])\n\nmain()\n", "def colinear(p1, p2, p3):\n    return (p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1])) == 0\n\ndef create_options(points):\n    p0 = points[0]\n    p1 = points[1]\n    p2 = points[2]\n    p3 = points[3]\n    if colinear(p0, p1, p2) and colinear(p1, p2, p3):\n        return [(p0, p1), []], 3\n    elif colinear(p0, p1, p2):\n        return [(p0, p1), [p3]], 3\n    elif colinear(p0, p1, p3):\n        return [(p0, p1), [p2]], 3\n    elif colinear(p0, p2, p3):\n        return [(p0, p2), [p1]], 3\n    elif colinear(p1, p2, p3):\n        return [(p1, p2), [p0]], 3\n    else:\n        p4 = points[4]\n        if colinear(p0, p1, p4):\n            return [(p0, p1), [p2, p3]], 4\n        elif colinear(p0, p2, p4):\n            return [(p0, p2), [p1, p3]], 4\n        elif colinear(p0, p3, p4):\n            return [(p0, p3), [p1, p2]], 4\n\n        elif colinear(p1, p2, p4):\n            return [(p1, p2), [p0, p3]], 4\n        elif colinear(p1, p3, p4):\n            return [(p1, p3), [p0, p2]], 4\n\n        elif colinear(p2, p3, p4):\n            return [(p2, p3), [p0, p1]], 4\n    return False, 4\n\ndef solution(points):\n    if len(points) <= 4:\n        return True\n    options, last = create_options(points)\n\n    if not options:\n        return False\n\n    for p in points[last+1:]:\n        if not colinear(options[0][0], options[0][1], p):\n            if len(options[1]) < 2:\n                options[1].append(p)\n            elif not colinear(options[1][0], options[1][1], p):\n                return False\n    return True\n\ndef __starting_point():\n    n = int(input())\n    points = [\n        tuple(map(int, input().split()))\n        for _ in range(n)\n    ]\n    print(\"YES\" if solution(points) else \"NO\")\n\n__starting_point()", "n=int(input().split()[0])\nps=[]\nfor i in range(n):\n    a,b=[int(x) for x in input().split()[:2]]\n    ps.append([a,b])\n\ndef aline(a,b,c):\n    x1=a[1]-b[1]\n    x2=c[1]-b[1]\n    y1=a[0]-b[0]\n    y2=c[0]-b[0]\n    if x1*y2==x2*y1:\n        return True\n    else:\n        return False\n\ndef left_fun(a,b,l):\n    if len(l)<3:\n        return []\n    to=[i for i in range(len(l)) if i!=a and i!=b]\n    left=[]\n    for i in to:\n        if not aline(ps[l[a]],ps[l[b]],ps[l[i]]):\n            left.append(i)\n    return left\n\ndef nm():\n    if len(ps)<5:\n        print('YES')\n        return\n    l = [i for i in range(n)]\n    left = left_fun(0, 1, l)\n    left = left_fun(0, 1, left)\n    if len(left) == 0:\n        print('YES')\n        return\n\n    l = [i for i in range(n)]\n    left = left_fun(1, 2, l)\n    left = left_fun(0, 1, left)\n    if len(left) == 0:\n        print('YES')\n        return\n\n    l = [i for i in range(n)]\n    left = left_fun(0, 2, l)\n    left = left_fun(0, 1, left)\n    if len(left) == 0:\n        print('YES')\n        return\n    print('NO')\nnm()\n", "\n\n\t\n\ndef ff(p, q, pp):\n\tnpp = []\n\tfor r in pp:\n\t\tif (p[1] - r[1]) * (p[0] - q[0]) != (p[1] - q[1]) * (p[0] - r[0]):\n\t\t\tnpp.append(r)\n\t\n\tif len(npp) <= 2:\n\t\treturn True\n\t\t\n\ta = npp[0]\n\tb = npp[1]\n\tfor c in npp:\n\t\tif (a[1] - c[1]) * (a[0] - b[0]) != (a[1] - b[1]) * (a[0] - c[0]):\n\t\t\treturn False\n\t\n\treturn True\n\t\n\t\n\t\n\t\n\nn = int(input())\nif n <= 4:\n\tprint('YES')\n\t\n\nelse:\n\tpp = []\n\tfor _ in range(n):\n\t\ta, b = [int(x) for x in input().split()]\n\t\tpp.append((a,b))\n\n\tif ff(pp[0], pp[1],pp) or ff(pp[1], pp[2],pp) or ff(pp[0], pp[2],pp):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\t\n\t\n", "from collections import Counter\nfrom random import choice\nfrom sys import stdin\nfrom time import time\n\nfrom math import gcd\n\n\ndef get_v(p0, p1):\n    dp = (p1[0] - p0[0], p1[1] - p0[1])\n\n    g = gcd(*dp)\n\n    if dp[0] > 0:\n        return (dp[0] // g, dp[1] // g)\n\n    elif dp[0] < 0:\n        return (-dp[0] // g, -dp[1] // g)\n\n    else:\n        return (dp[0] // g, abs(dp[1] // g))\n\n\nall_in = stdin.read().splitlines()\n\nn = int(all_in[0])\npoints = [tuple(map(int, el.split())) for el in all_in[1:]]\n\nif n <= 4:\n    print('YES')\n    return\n\np_max_ = 1\n\nt = time()\nwhile p_max_ == 1:\n    p = choice(points)\n\n    v_s = [get_v(p, x) for x in points if x != p]\n\n    if len(set(v_s)) <= 2:\n        print('YES')\n        return\n\n    C = Counter(v_s)\n\n    p_max, p_max_ = sorted(list(C.items()), key=lambda x: x[1])[-1]\n\n    if time() - t > 1.75:\n        print('NO')\n        return\n\npoints.remove(p)\npoints_ = [points[i - 1] for i in range(1, n) if v_s[i - 1] != p_max]\n\nif len(points_) <= 2:\n    print('YES')\n    return\n\np_ = choice(points_)\n\nv_s_ = [get_v(p_, x) for x in points_ if x != p_]\n\nif len(set(v_s_)) >= 2:\n    print('NO')\n    return\n\nprint('YES')\n", "R = lambda: list(map(int, input().split()))\n\nn = int(input())\nps = []\n\ndef ff(a, b):\n    pp = [] # left points\n    dy = b[1] - a[1]; dx = b[0] - a[0]\n    for c in ps:\n        if dy*(c[0]-a[0]) != dx*(c[1]-a[1]):\n            pp.append(c)\n\n    if len(pp) <= 2: return True\n    a = pp[0]; b = pp[1]\n    dy = b[1] - a[1]; dx = b[0] - a[0]\n    for c in pp:\n        if dy*(c[0]-a[0]) != dx*(c[1]-a[1]):\n            return False\n    return True\n\nfor _ in range(n): ps.append(tuple(R()))\nif n <= 4:\n    print('YES')\nelse:\n    if ff(ps[0], ps[1]) or ff(ps[0], ps[2]) or ff(ps[1], ps[2]):\n        print('YES')\n    else:\n        print('NO')\n\n", "from itertools import combinations\nfrom fractions import gcd\n\ndef main():\n    n = int(input())\n    p = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, p))\n\ndef solve(n, p):\n    if n < 5:\n        return \"YES\"\n    p5 = p[:5]\n##    for p1, p2 in combinations(p5, 2):\n##        print(p1, p2, line(p1, p2), nb_points(line(p1, p2), p5))\n    lines = set(line(p1, p2) for p1, p2 in combinations(p5, 2))\n##    for l in lines:\n##        print(l, nb_points(l, p5))\n    l0 = None\n    for l in lines:\n        if nb_points(l, p5) > 2:\n            l0 = l\n            break\n    if l0 is None:\n        return \"NO\"\n    pr = [pi for pi in p if not belongs(pi, l0)]\n    if colinear(pr):\n        return \"YES\"\n    return \"NO\"\n\ndef line(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    a = y2 - y1\n    b = x1 - x2\n    c = x2 * y1 - x1 * y2\n    if a < 0:\n        a, b, c = -a, -b, -c\n    if a == 0:\n        if b < 0:\n            b, c = -b, -c\n        if c == 0:\n            b = 1\n        else:\n            g = abs(gcd(b, c))\n            b, c = b // g, c // g\n    else:\n        if b == 0:\n            if c == 0:\n                a = 1\n            else:\n                g = abs(gcd(a, c))\n                a, c = a // g, c // g\n        else:\n            if c == 0:\n                g = abs(gcd(a, b))\n                a, b = a // g, b // g\n            else:\n                g = abs(gcd(gcd(a, b), c))\n                a, b, c = a // g, b // g, c // g\n    return a, b, c\n\ndef belongs(pi, l):\n    a, b, c = l\n    return a * pi[0] + b * pi[1] + c == 0\n\ndef nb_points(l, p):\n    return sum(1 for pi in p if belongs(pi, l))\n\ndef colinear(p):\n    if len(p) <= 2:\n        return True\n    l = line(p[0], p[1])\n    return all(belongs(pi, l) for pi in p[2:])\n\nmain()", "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return '('+str(self.x)+', '+str(self.y)+')'\n\n    def __sub__(self, other):\n        # print(\"return sub\", self)\n        return Point(self.x - other.x, self.y - other.y)\n    \n\ndef cross(a, b):\n    return a.x*b.y - b.x*a.y\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x_, y_ = map(int, input().strip().split())\n    p = Point(x_, y_)\n    points.append(p)\n\ndef check(used):\n    nonlocal n, points\n    f = -1\n    s = -1\n    for i in range(n):\n        if not used[i]:\n            if f == -1:\n                f = i\n            elif s == -1:\n                s = i\n    if s == -1:\n        return True\n    for i in range(n):\n        if not used[i]:\n            if cross(points[f]-points[s], points[i]-points[f]) != 0:\n                return False\n    return True\n\ndef solve(a, b):\n    nonlocal n, points\n    used = [False]*n\n    for i in range(n):\n        if cross(a-b, points[i]-a) == 0:\n            used[i] = True\n    \n    return check(used)\n\ndef solution():\n    nonlocal points\n    if len(points) <= 2:\n        print('YES')\n        return \n    ans = False\n    if (solve(points[0], points[1]) or solve(points[0], points[2]) or solve(points[1], points[2])):\n        ans = True\n    \n    if ans:\n        print(\"YES\")\n    else:\n        print('NO')\n\nsolution()", "import sys\n\nimport random\n\n\n\nn = int(input())\nif n<=3:\n    print('YES')\n    return\ncoord = [int(x) for line in sys.stdin for x in line.split()]\n\n\nX = [coord[2*i] for i in range(n)]\nY = [coord[2*i+1] for i in range(n)]\n\n\nfor i in range(13):\n    a = random.randint(0,n-1)\n    b = random.randint(0,n-2)\n    \n    if a==b:\n        b+=1\n    \n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n    \n    dx = x1-x0\n    dy = y1-y0\n    not_on_line = []\n    for c in range(n):\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            not_on_line.append(c)\n    if len(not_on_line)<=1:\n        print('YES')\n        return\n\n\n    a = not_on_line[0]\n    b = not_on_line[1]\n    x0,y0 = X[a],Y[a]\n    x1,y1 = X[b],Y[b]\n    \n    dx = x1-x0\n    dy = y1-y0\n    can = True\n    for c in not_on_line:\n        if c==a or c==b:\n            continue\n        x2,y2 = X[c],Y[c]\n        Dx = x2-x0\n        Dy = y2-y0\n        if dx*Dy-dy*Dx!=0:\n            can = False\n            break\n    if can:\n        print('YES')\n        return\nprint('NO')", "n=int(input())\nimport sys\npts=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    pts.append([x,y])\nif(n<=4):\n    print('YES')\n    return\nb1=pts[0][0]-pts[1][0]\na1=pts[1][1]-pts[0][1]\nc1=-a1*pts[0][0] - b1*pts[0][1]\na2=0\nb2=0\nc2=1\np=[]\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n        if(len(p)==2):\n            \n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n            flag=False\n            break\nif(flag):\n    print(\"YES\")\n    #print(1,p)\n    return\nP=p\np=[pts[0],P[0]]\nb1=p[0][0]-p[1][0]\na1=p[1][1]-p[0][1]\nc1=-a1*p[0][0] - b1*p[0][1]\np=[]\na2=0\nb2=0\nc2=1\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n        #print('here in 2 ',pts[i])\n        if(len(p)==2):\n            \n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n            flag=False\n            break\nif(flag):\n    #print(2,p)\n    #print(a1,b1,c1,a2,b2,c2)\n    print(\"YES\")\n    return\n    \n    \n\np=[P[0],pts[1]]\nb1=p[0][0]-p[1][0]\na1=p[1][1]-p[0][1]\nc1=-a1*p[0][0] - b1*p[0][1]\np=[]\na2=0\nb2=0\nc2=1\nflag=True\nfor i in range(n):\n    if(a1*pts[i][0]+b1*pts[i][1]+c1!=0 and a2*pts[i][0]+b2*pts[i][1]+c2!=0 ):\n        p.append(pts[i])\n        if(len(p)==2):\n            \n            b2=p[0][0]-p[1][0]\n            a2=p[1][1]-p[0][1]\n            c2=-a2*p[0][0] - b2*p[0][1]\n        if(len(p)>2):\n            \n            flag=False\n            break\nif(flag):\n    print(\"YES\")\n    #print(3,p)\n    return\nprint(\"NO\")", "n = int(input())\n\nlst = []\nfor x in range(n):\n    (a, b) = list(map(int, input().split()))\n    lst.append((a, b))\n\ndef scal(x1, y1, x2, y2, x3, y3):\n    if (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) == 0:\n        return True\n    return False\n\ndef check():\n    for x in range(n - 2):\n        if len(s2) >= 3:\n            if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n                return False\n        if scal(lst[0][0], lst[0][1], lst[1][0], lst[1][1], lst[x + 2][0], lst[x + 2][1]):\n            s1.append(x + 2)\n        else:\n            s2.append(x + 2)\n    if len(s2) >= 3:\n        if not scal(lst[s2[-3]][0], lst[s2[-3]][1], lst[s2[-2]][0], lst[s2[-2]][1], lst[s2[-1]][0], lst[s2[-1]][1]):\n            return False\n    return True\n\nflag = True\n\nif n >= 5:\n    s1 = []\n    s2 = []\n    if not check():\n        lst[1], lst[s2[0]] = lst[s2[0]], lst[1]\n        x = s2[0]\n        s1 = []\n        s2 = []\n        if not check():\n            lst[0], lst[s2[0]] = lst[s2[0]], lst[0]\n            s1 = []\n            s2 = []\n            if not check():\n                flag = False\n\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "import sys\nimport math\n\n\ndef main():\n    i = sys.stdin.readlines()\n\n    n = int(i[0].strip())\n    points = []\n    for pi in range(n):\n        p = i[pi + 1]\n        x, y = p.strip().split()\n        points.append([int(x), int(y)])\n\n    if n < 5:\n        print('YES')\n        return\n\n    st = [False] * n\n\n    def run(first, second):\n        dx = first[0] - second[0]\n        dy = first[1] - second[1]\n\n        for i, p in enumerate(points):\n            if st[i]:\n                continue\n            if dx == 0:\n                if p[0] == first[0]:\n                    st[i] = True\n            elif dy == 0:\n                if p[1] == first[1]:\n                    st[i] = True\n            else:\n                # kx = (p[0] - first[0]) / dx\n                # ky = (p[1] - first[1]) / dy\n                # if math.isclose(kx, ky):\n                #     st[i] = True\n                if ((p[0] - first[0]) * dy) == (p[1] - first[1]) * dx:\n                    st[i] = True\n\n    def check(fi, si):\n        for i in range(n):\n            st[i] = i == fi or i == si\n\n        run(points[fi], points[si])\n\n        fi = None\n        si = None\n        for i in range(n-1):\n            if not st[i]:\n                fi = i\n                for j in range(i+1, n):\n                    if not st[j]:\n                        si = j\n                        break\n                break\n        if fi is None or si is None:\n            return True\n\n        st[fi] = True\n        st[si] = True\n        run(points[fi], points[si])\n        return not (False in st)\n\n    if check(0, 1) or check(0, 2) or check(1, 2):\n        print('YES')\n    else:\n        print('NO')\n\n\n\n\nmain()", "n = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\nf = lambda a, b, c: (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\ndef g(fi, se, p):\n    q = []\n    for x in p:\n        if f(fi, se, x):\n            if len(q) < 2:\n                q.append(x)\n            else:\n                if f(q[0], q[1], x):\n                    return 1\n    return 0\nprint('NO' if n > 4 and all([g(p[0], p[1], p), g(p[0], p[2], p), g(p[1], p[2], p)]) else 'YES')\n\n", "def cross(a, b):\n    return a[0] * b[1] - a[1] * b[0]\n\n\ndef f(v, i1, i2):\n    d = [v[i2][i] - v[i1][i] for i in range(len(v[i1]))]\n\n    res = []\n    for x in v:\n        d2 = [x[i] - v[i1][i] for i in range(len(v[i1]))]\n        if cross(d, d2) != 0:\n            res.append(x)\n\n    return res\n\n\nn = int(input())\nif n <= 4:\n    print(\"YES\")\n    return\n\nv = []\nfor i in range(n):\n    v.append(list(map(int, input().split())))\n\nok = False\nfor first in range(3):\n    if ok:\n        break\n\n    for second in range(first+1, 3):\n        other = f(v, first, second)\n\n        if len(other) <= 2:\n            ok = True\n            break\n\n        remainder = f(other, 0, 1)\n\n        if not remainder:\n            ok = True\n\n\nif ok:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "class Point:\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n\nclass Vector:\n\n    def __init__(self, start, end):\n        self.x = end.x - start.x\n        self.y = end.y - start.y\n\n    def mult(self, a):\n        return self.y * a.x - self.x * a.y\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    points.append(Point(x, y))\n\nif n <= 3:\n    print('YES')\n    return\n\n\ndef onLine(points):\n    n = len(points)\n    if n < 3:\n        return True\n    a = Vector(points[0], points[1])\n    for i in range(2, n):\n        b = Vector(points[0], points[i])\n        if a.mult(b) != 0:\n            return False\n    return True\n\ntmp = [points[0], points[1]]\noth = []\nfor i in range(2, n):\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    return\n\ntmp = [points[0], points[2]]\noth = []\nfor i in range(1, n):\n    if i == 2:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    return\n\ntmp = [points[1], points[2]]\noth = []\nfor i in range(0, n):\n    if i == 2 or i == 1:\n        continue\n    tmp.append(points[i])\n    if not onLine(tmp):\n        oth.append(points[i])\n    tmp.pop()\nif onLine(oth):\n    print('YES')\n    return\n\nprint('NO')\n", "def iscollinear(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n    ans = bool(cross)\n    return not ans\n\ndef checkfortwolines(a, b, points):\n    set1 = set(points)\n    for i in range(n): # erase all points collinear with a, b\n        if iscollinear(a, b, points[i]): set1.remove(points[i])\n\n    if len(set1) <= 2: return True\n    else:\n        pts1 = list(set1)\n        for i in range(len(pts1)): # check if remaining points are all collinear\n            if not iscollinear(pts1[0], pts1[1], pts1[i]): return False\n        return True\n\nn = int(input())\nif n <= 4: print(\"YES\")\nelse:\n    points = [0 for i in range(n)]\n    for i in range(n):\n        points[i] = tuple(map(int, input().split()))\n    a = points[0]\n    b = points[1]\n    c = points[2]\n    if checkfortwolines(a, b, points) or checkfortwolines(b, c, points) or checkfortwolines(c, a, points):\n        print(\"YES\")\n    else: print(\"NO\") \n\n", "n = int(input())\n\na = [list(map(int, input().split())) for i in range(n)]\n\nOnLine = lambda A, B, C, x, y: A*x+B*y+C==0\n\ndef OffLine(A, B, C, nodes):\n    res = []\n\n    for i in nodes:\n        if not OnLine(A, B, C, i[0], i[1]): res.append(i)\n\n    return res\n\nflag = False\n\nif n<5:\n    print('YES')\n    raise SystemExit\n\nfor comb in __import__('itertools').combinations([0, 1, 2], 2):\n    i, j = comb[0], comb[1]\n    \n    b = OffLine(a[j][1]-a[i][1], a[i][0]-a[j][0], a[j][0]*a[i][1]-a[i][0]*a[j][1], a)\n\n    if len(b)<3:\n        print('YES')\n        raise SystemExit\n    if not OffLine(b[j][1]-b[i][1], b[i][0]-b[j][0], b[j][0]*b[i][1]-b[i][0]*b[j][1], b):\n        print('YES')\n        raise SystemExit\n    \nprint('NO')\n", "def is_line(b):\n    if (len(b) < 3):\n        return True\n    x1 = b[0][0]\n    y1 = b[0][1]\n    for i in range(len(b)):\n        b[i][0] -= x1\n        b[i][1] -= y1\n    x2 = b[1][0]\n    y2 = b[1][1]    \n    for i in range(2, len(b)):\n        if (x2 * b[i][1] != y2 * b[i][0]):\n            return False\n    return True\ndef main():\n    n = int(input())\n    if (n < 5):\n        print(\"YES\")\n        return\n    a = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        a.append([x, y])\n    for i1 in range(3):\n        x0 = a[i1][0]\n        y0 = a[i1][1]\n        for i in range(n):\n            a[i][0] -= x0\n            a[i][1] -= y0\n        if (i1 == 0):\n            i2 = 1\n            x1 = a[1][0]\n            y1 = a[1][1]\n        elif (i1 == 1):\n            i2 = 2\n            x1 = a[2][0]\n            y1 = a[2][1]\n        else:\n            i2 = 0\n            x1 = a[0][0]\n            y1 = a[0][1]\n        b = []\n        for i in range(n):\n            if (i != i1 and i != i2):\n                if (x1 * a[i][1] != y1 * a[i][0]):\n                    b.append([a[i][0], a[i][1]])\n        if (is_line(b)):\n            print(\"YES\")\n            return\n    print(\"NO\")\nmain()    "]
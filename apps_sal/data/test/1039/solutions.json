["from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\n\ndef solve():\n    N = INT()\n    adj = [[] for _ in range(N)]\n    for i in range(N-1):\n        a, b, c = MAP()\n        adj[a-1].append([b-1, c])\n        adj[b-1].append([a-1, c])\n\n    Q, K = MAP()\n    K -= 1\n\n    d = [inf]*N\n    d[K] = 0\n    que = []\n    heappush(que, K)\n\n    while que:\n        v = heappop(que)\n        for b, c in adj[v]:\n            if d[b] > d[v] + c:\n                d[b] = d[v] + c\n                heappush(que, b)\n\n    for i in range(Q):\n        x, y = MAP()\n        print(d[x-1]+d[y-1])\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\ndef input():return sys.stdin.readline().strip()\nfrom collections import deque\n\ndef main():\n    N = int(input())\n    info = [tuple(map(int, input().split())) for _ in range(N-1)]\n    Q, K = map(int, input().split())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    to = [[] for _ in range(N)]\n    for a, b, c in info:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        to[b].append((a, c))\n    \n    INF = 10**18\n    dist = [INF]*N\n    def dfs(s):\n        stack = deque()\n        push = stack.append\n        pop = stack.pop\n\n        dist[s] = 0\n        push(s)\n\n        while stack:\n            now = pop()\n            now_cost = dist[now]\n\n            for nv, c in to[now]:\n                if dist[nv] != INF:\n                    continue\n                dist[nv] = now_cost + c\n                push(nv)\n\n\n    # query\n    K -= 1\n    dfs(K)\n    ans = []\n    for x, y in queries:\n        x -= 1\n        y -= 1\n        xy = dist[x] + dist[y]\n        ans.append(xy)\n\n    print(*ans, sep=\"\\n\")\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef dijkstra(adj_list, start):\n    n = len(adj_list)\n    dist = [float(\"inf\")] * n\n    dist[start] = 0\n\n    pq = []\n    heappush(pq, (0, start))\n    visited = set()\n    while pq:\n        w, v = heappop(pq)\n        if dist[v] < w:\n            continue\n        visited.add(v)\n        for nv, nw in adj_list[v]:\n            if nv in visited:\n                continue\n            if dist[nv] > dist[v] + nw:\n                dist[nv] = dist[v] + nw\n                heappush(pq, (dist[nv], nv))\n    return dist\n\n\nN = int(input())\ng = defaultdict(list)\nfor _ in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    g[a].append((b, c))\n    g[b].append((a, c))\nQ, K = list(map(int, input().split()))\nK -= 1\nd = dijkstra(g, K)\nans = []\nfor _ in range(Q):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    print((d[x] + d[y]))\n", "N = int(input())\nf = [[] for i in range(N)]\nfor i in range(N-1):\n    a,b,c = map(int,input().split())\n    f[a-1].append([b-1,c])\n    f[b-1].append([a-1,c])\nfrom collections import deque\nd = deque()\ns = [-1]*N\nQ,K = map(int,input().split())\nd.append(K-1)\ns[K-1] = 0\nwhile len(d) > 0:\n    z = d.popleft()\n    for i,j in f[z]:\n        if s[i] == -1:\n            s[i] = j+s[z]\n            d.append(i)\nfor i in range(Q):\n    x,y = map(int,input().split())\n    print(s[x-1]+s[y-1])", "import sys\n\nsys.setrecursionlimit(200000)\n\nn = int(input())\nl = [list(map(int,input().split())) for _ in range(n-1)]\nq,k = list(map(int,input().split()))\nk -= 1\n#k\u304b\u3089\u306e\u8ddd\u96e2\ntree = [[] for _ in range(n)]\nfor a,b,c in l:\n    a -= 1\n    b -= 1\n    tree[a].append([b,c])\n    tree[b].append([a,c])\n\nbit = [0 for _ in range(n)]\ndepth = [0 for _ in range(n)]\ndef dfs(v,d=0):\n    bit[v] = 1\n    depth[v] = d\n    for j,k in tree[v]:\n        if bit[j]==0:\n            dfs(j,d+k)\ndfs(k)\n\nfor _ in range(q):\n    x,y = list(map(int,input().split()))\n    x-= 1\n    y-= 1\n    print((depth[x] + depth[y]))\n", "from collections import defaultdict,deque\nimport sys\nfinput=lambda: sys.stdin.readline().strip()\n\ndef main():\n  n=int(finput())\n  edges=[tuple(map(int,finput().split())) for _ in range(n-1)]\n  q,k=list(map(int,finput().split()))\n  xy=[tuple(map(int,finput().split())) for _ in range(q)]\n  ed=defaultdict(deque)\n  wt=defaultdict(int)\n  for e in edges:\n    ed[e[0]].append(e[1])\n    ed[e[1]].append(e[0])\n    wt[(e[0],e[1])]=e[2]\n    wt[(e[1],e[0])]=e[2]\n  stack=deque([k])\n  cv=stack[0]\n  dist=defaultdict(int)\n  while stack:\n    while ed[cv]:\n      if cv!=k:\n        if ed[cv][-1]==stack[-1]:\n          ed[cv].pop()\n          if not ed[cv]:\n            break\n      stack.append(cv)\n      cv=ed[cv].pop()\n      dist[cv]=dist[stack[-1]]+wt[(stack[-1],cv)]\n    cv=stack.pop()\n  for que in xy:\n    print((dist[que[0]]+dist[que[1]]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "F=lambda:map(int,input().split())\nN=int(input())\n\nG=[[]for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b,c=F()\n    G[a].append([a,b,c])\n    G[b].append([b,a,c])\n\nQ,K=F()\n\nD=[10**9*(N+1)]*(N+1)\nD[0]=0\nD[K]=0\nfrom collections import*\nque=deque(G[K])\nwhile que:\n    a,b,c=que.popleft()\n    if D[a]+c<D[b]:\n        D[b]=D[a]+c\n        for g in G[b]:\n            que.append(g)\n\nfor _ in range(Q):\n    x,y=F()\n    print(D[x]+D[y])", "N = int(input())\nG = [[] for n in range(N)]\n\nfor n in range(N-1):\n  a,b,c = map(int,input().split())\n  G[a-1].append((b-1,c))\n  G[b-1].append((a-1,c))\n\nQ,K = map(int,input().split())\nd = N*[-1]\nd[K-1] = 0\nq = [K-1]\n\nwhile q:\n  t = q.pop()\n  for b,c in G[t]:\n    if d[b]==-1:\n      d[b] = d[t]+c\n      q.append(b)\n\nfor q in range(Q):\n  x,y = map(int,input().split())\n  print(d[x-1]+d[y-1])", "F=lambda:map(int,input().split())\nN=int(input())\nabc=[[*F()]for _ in range(N-1)]\nQ,K=F()\nxy=[[*F()]for _ in range(Q)]\n\nG=[[]for _ in range(N+1)]\nfor a,b,c in abc:\n    G[a].append([a,b,c])\n    G[b].append([b,a,c])\n\nD=[10**9*(N+1)]*(N+1)\nD[0]=0\nD[K]=0\nfrom collections import*\nque=deque(G[K])\nwhile que:\n    a,b,c=que.popleft()\n    if D[a]+c<D[b]:\n        D[b]=D[a]+c\n        for g in G[b]:\n            que.append(g)\n\nfor x,y in xy:\n    print(D[x]+D[y])", "from collections import deque\n\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N-1)]\nQ, K = map(int, input().split())\nX = [list(map(int, input().split())) for _ in range(Q)]\n\nd = [[] for _ in range(N)]\nfor a, b, c in A:\n    d[a-1].append([b-1, c])\n    d[b-1].append([a-1, c])\n\nc = [0]*N\nf = [False]*N\nf[K-1] = True\n\nq = deque([K-1])\nwhile q:\n    now = q.popleft()\n    for nex, cost in d[now]:\n        if f[nex]:\n            continue\n        c[nex] = c[now]+cost\n        f[nex] = True\n        q.append(nex)\n\nfor x, y in X:\n    print(c[x-1]+c[y-1])", "# \u6df1\u3055\u512a\u5148\u63a2\u7d22\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = list(map(int, input().split()))\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\nq = [K]\nwhile q:\n    i = q.pop()\n    for j, c in links[i]:\n        if d[i] + c < d[j]:\n            d[j] = d[i] + c\n            q.append(j)\n\nresult = []\nfor _ in range(Q):\n    x, y = list(map(int, input().split()))\n    result.append(d[x] + d[y])\nprint(('\\n'.join(str(v) for v in result)))\n#print(*result, sep='\\n')\n", "def abc070_d():\n    import sys\n    sys.setrecursionlimit(10010010)\n    read = sys.stdin.buffer.read\n    inp = iter(map(int, read().split()))\n\n    n = next(inp)\n    adjlist = [[] for _ in range(n)]\n    for _ in range(n-1):\n        a = next(inp) - 1\n        b = next(inp) - 1\n        c = next(inp)\n        adjlist[a].append((b, c))\n        adjlist[b].append((a, c))\n\n    q = next(inp)\n    k = next(inp) - 1\n\n    dist = [-1] * n\n\n    def dfs(x:int, d:int):\n        dist[x] = d\n        for nx, nd in adjlist[x]:\n            if dist[nx] != -1: continue\n            dfs(nx, d + nd)\n\n    dfs(k, 0)\n\n    for _ in range(q):\n        x = next(inp) - 1\n        y = next(inp) - 1\n        ans = dist[x] + dist[y]\n        print(ans)\n\ndef __starting_point():\n    abc070_d()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(st, depth=0):\n    dist[st] = depth\n    for to, c in tree[st]:\n        if dist[to]>=0:\n            continue\n        dfs(to, depth+c)\n\n\nN = int(input())\ntree = [[] for _ in range(N)]\ndist = [-1]*N\n\nfor _ in range(N-1):\n    a,b,c = map(int, input().split())\n    tree[a-1].append((b-1, c))\n    tree[b-1].append((a-1, c))\n\nQ, K = map(int, input().split())\ndfs(K-1, 0)\n# print(dist)\n# print(tree)\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    print(dist[x-1]+dist[y-1])", "n=int(input())\nabc=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    a,b,c=map(int,input().split())\n    abc[a].append([b,c])\n    abc[b].append([a,c])\nfrom collections import deque\nq,k=map(int,input().split())\nvisited=[0]*(n+1)\ndistance=[0]*(n+1)\nque=deque()\nque.append(k)\nvisited[k]+=1\ncount=0\nwhile que:\n    x=que.pop()\n    for y in abc[x]:\n        if visited[y[0]]==0:\n            distance[y[0]]+=distance[x]+y[1]\n            visited[y[0]]+=1\n            que.appendleft(y[0])\nfor j in range(q):\n    c,d=map(int,input().split())\n    print(distance[c]+distance[d])", "def main():\n    from collections import defaultdict\n    from heapq import heappop, heappush\n    N = int(input())\n    edge = defaultdict(list)\n    length = defaultdict(lambda : defaultdict(lambda : 10**20))\n    \n    for i in range(N-1):\n        a,b,c = map(int,input().split())\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n        if b<a:\n            a,b = b,a\n        length[a][b] = c\n    Q,K = map(int,input().split())\n    K -= 1\n    cost = [0]*N\n    length[K][K] = 0\n    targets = [(0,K)]\n    cost = [10**18]*N\n    cost[K] = 0\n    visited = [False]*N\n    while targets:\n        c,t = heappop(targets)\n        if visited[t]:\n            continue\n        cost[t] = c\n        visited[t] = True\n        for v in edge[t]:\n            if cost[v] > cost[t] + length[min(t,v)][max(t,v)]:\n                heappush(targets,(cost[t] + length[min(t,v)][max(t,v)],v))\n\n    out = []\n    for i in range(Q):\n        x,y = map(lambda x: int(x)-1, input().split())\n        out.append(cost[x]+cost[y])\n\n    print('\\n'.join(map(str,out)))\n\n\n\n\n\n\n\nmain()", "import sys\nfrom collections import deque\n\nN = int(sys.stdin.readline())\n\nedges = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b, c = map(int, sys.stdin.readline().split())\n    edges[a-1].append((b-1, c))\n    edges[b-1].append((a-1, c))\n\nQ, K = map(int, sys.stdin.readline().split())\n\n# K\u3092\u59cb\u70b9\u3068\u3059\u308b\u3001\u5404\u70b9\u307e\u3067\u306e\u8ddd\u96e2\ndist = [-1 for _ in range(N)]\n\nvisited = set()\nq = deque([(K-1, 0)])\nwhile q:\n    p, c = q.popleft()\n    if p in visited:\n        continue\n    dist[p] = c\n\n    visited.add(p)\n    for (next_p, next_c) in edges[p]:\n        q.append((next_p, c + next_c))\n# print(dist)\n\nfor _ in range(Q):\n    x, y = map(int, sys.stdin.readline().split())\n    print(dist[x-1] + dist[y-1])", "N=int(input())\nG=[[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b,c=map(int,input().split())\n    a-=1\n    b-=1\n    G[a].append([b,c])\n    G[b].append([a,c])\nQ,K=map(int,input().split())\nK-=1\ndist=[-1 for _ in range(N)]\ndist[K]=0\nq=[K]\nwhile len(q)>0:\n    v=q.pop()\n    for p in G[v]:\n        nv=p[0]\n        if dist[nv]!=-1:\n            continue\n        dist[nv]=dist[v]+p[1]\n        q.append(nv)\nfor _ in range(Q):\n    x,y=map(int,input().split())\n    print(dist[x-1]+dist[y-1])", "from collections import deque\n#\n# N = 5\n# ARR = [\n#     [1, 2, 1],\n#     [1, 3, 1],\n#     [2, 4, 1],\n#     [3, 5, 1]\n# ]\n#\n# Q, K = 3, 1\n#\n# BRR = [\n#     [2, 4],\n#     [2, 3],\n#     [4, 5],\n# ]\n#\n#\n# N = 7\n# ARR = [\n#     [1, 2, 1],\n#     [1, 3, 3],\n#     [1, 4, 5],\n#     [1, 5, 7],\n#     [1, 6, 9],\n#     [1, 7, 11],\n# ]\n#\n# Q, K = 3, 2\n#\n# BRR = [\n#     [1, 3],\n#     [4, 5],\n#     [6, 7],\n# ]\n#\n#\n# N = 10\n# ARR = [\n#     [1, 2, 1000000000],\n#     [2, 3, 1000000000],\n#     [3, 4, 1000000000],\n#     [4, 5, 1000000000],\n#     [5, 6, 1000000000],\n#     [6, 7, 1000000000],\n#     [7, 8, 1000000000],\n#     [8, 9, 1000000000],\n#     [9, 10, 1000000000]\n# ]\n#\n# Q, K = 1, 1\n#\n# BRR = [\n#     [9, 10]\n# ]\n\n\nN = int(input())\n\nARR = [list(map(int,input().split())) for i in range(N-1)]\n\nQ, K = map(int,input().split())\n\nBRR = [list(map(int,input().split())) for i in range(Q)]\n\n\ndef prepare(n, arr):\n    links = {}\n    nodeStatus = {}\n    distances = {}\n    finalDistance = {}\n    for i in range(1, N + 1):\n        nodeStatus.__setitem__(i, False)\n        finalDistance.__setitem__(i, 0)\n\n    for i in range(len(arr)):\n        tmp = arr[i]\n        startNode = tmp[0]\n        endNode = tmp[1]\n        distance = tmp[2]\n        distances.__setitem__((startNode, endNode), distance)\n        distances.__setitem__((endNode, startNode), distance)\n        if links.get(startNode) == None:\n            links.__setitem__(startNode, [endNode])\n        else:\n            tmpChild = links.get(startNode)\n            tmpChild.append(endNode)\n            links.__setitem__(startNode, tmpChild)\n\n        if links.get(endNode) == None:\n            links.__setitem__(endNode, [startNode])\n        else:\n            tmpChild = links.get(endNode)\n            tmpChild.append(startNode)\n            links.setdefault(endNode, tmpChild)\n    return links, nodeStatus, distances, finalDistance\n\n\ndef bfs(startNode):\n    q = deque()\n\n    q.append((startNode, 0))\n\n    while len(q):\n        currentNode, dist = q.popleft()\n        finalDistance.__setitem__(currentNode, dist)\n        nodeStatus.__setitem__(currentNode, True)\n\n        childNodes = links.get(currentNode)\n\n        for childNode in childNodes:\n            if nodeStatus.get(childNode) == False:\n                q.append((childNode, dist + distances.get((currentNode, childNode))))\n\n\nlinks, nodeStatus, distances, finalDistance = prepare(N, ARR)\n\n# print(links)\n# print(nodeStatus)\n# print(distances)\n# print(finalDistance)\n\n\nbfs(K)\nfor i in range(Q):\n    dist1 = finalDistance[BRR[i][0]]\n    dist2 = finalDistance[BRR[i][1]]\n    print(dist1 + dist2)", "N =int(input())\n#graph\u4f5c\u6210\ngraph = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b, c = list(map(int, input().split()))\n    graph[a-1].append((b-1,c))\n    graph[b-1].append((a-1,c))\n\nQ, K = list(map(int, input().split()))\nK -= 1\nquery = [tuple(int(x) for x in input().split()) for _ in range(Q)]\n\n        \nseen = {K} \nv = [K]\ndistfromK =[0] * N\nwhile len(v) != 0:  #bfs\u3067distfromK\u3092\u57cb\u3081\u3066\u3044\u304f\n    for nv in graph[v[0]]:\n        if nv[0] in seen:\n            continue\n        distfromK[nv[0]] = distfromK[v[0]] + nv[1]\n        v.append(nv[0])\n        seen.add(nv[0])\n    v.pop(0)\n\nfor q in query:\n    print((distfromK[q[0]-1]+distfromK[q[1]-1]))\n\n\n\n", "n = int(input())\nG = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    G[a].append((b, c))\n    G[b].append((a, c))\n\nQ, k = tuple(map(int, input().split()))\nINF = 10**9*n + 1\ndists = [INF] * n\ndists[k-1] = 0\n\nfrom collections import deque\nq = deque([k-1])\n\nwhile q:\n    node = q.popleft()\n    for to, c in G[node]:\n        if dists[to] > dists[node] + c:\n            dists[to] = dists[node] + c\n            q.append(to)\n\nfor _ in range(Q):\n    s, g = tuple(map(int, input().split()))\n    print(dists[s-1] + dists[g-1])", "n = int(input())\nG = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    G[a].append((b, c))\n    G[b].append((a, c))\n\nQ, k = tuple(map(int, input().split()))\nINF = 10**9*n + 1\ndists = [INF] * n\ndists[k-1] = 0\n\nfrom collections import deque\nq = deque([k-1])\nvisited = [0] * n\nvisited[k-1] = 1\n\nwhile q:\n    node = q.popleft()\n    for to, c in G[node]:\n        if visited[to] == 1:\n            continue\n\n        if dists[to] > dists[node] + c:\n            dists[to] = dists[node] + c\n            q.append(to)\n\nfor _ in range(Q):\n    s, g = tuple(map(int, input().split()))\n    print((dists[s-1] + dists[g-1]))\n", "# \u5e45\u512a\u5148\u63a2\u7d22\nfrom collections import deque\n\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = map(int, input().split())\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\nq = deque([K])\nwhile q:\n    i = q.popleft()\n    for j, c in links[i]:\n        if d[i] + c < d[j]:\n            d[j] = d[i] + c\n            q.append(j)\n\nresult = []\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    result.append(d[x] + d[y])\n#print('\\n'.join(str(v) for v in result))\nprint(*result, sep='\\n')\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nimport heapq\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1] # warning bytes\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8')\nimport string\nimport operator\nimport random\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\nsys.setrecursionlimit(int(1e6))\n\ndef solve():\n    n = int(input())\n    g = defaultdict(list)\n    for _ in range(n-1):\n        a, b, c = [int(x) for x in input().split()]\n        g[a].append((b, c))\n        g[b].append((a, c))\n    \n    q, k = [int(x) for x in input().split()]\n    d = defaultdict(int)\n\n    def dfs(v, f, dis):\n        d[v] = dis\n        for to, xd in g[v]:\n            if to == f: continue\n            dfs(to, v, dis + xd)\n    \n    dfs(k, -1, 0)\n\n    for _ in range(q):\n        a, b = [int(x) for x in input().split()]\n        print((d[a] + d[b]))\n    \n\n\nT = 1\n# T = int(input())\nfor case in range(1,T+1):\n    ans = solve()\n\n\n\"\"\"\n\ndp[num_changes][blue_placed]\n\n\nabba\n\n\n\n\"\"\"\n", "from collections import deque\n\nN=int(input())\nG=[{} for _ in range(N+1)]\nfor i in range(N-1):\n  a,b,c=map(int,input().split())\n  G[a][b]=G[b][a]=c\n  \ndef bfs(s):\n    seen = [0 for i in range(N+1)]\n    d = [0 for i in range(N+1)]\n    cross = []\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    while 1:\n      if len(todo)==0:break\n      a = todo.popleft()\n      for b in G[a].keys():\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + G[a][b]\n    return d\n\nQ,K=map(int,input().split())\nd = bfs(K)\nfor q in range(Q):\n  x,y=map(int,input().split())\n  print(d[x]+d[y])", "import networkx as nx\n\nN = int(input())\nABC = [list(map(int, input().split())) for _ in range(N - 1)]\nQ, K = list(map(int, input().split()))\nXY = [list(map(int, input().split())) for _ in range(Q)]\n\nG = nx.Graph()\n\nfor a, b, c in ABC:\n    G.add_edge(a - 1, b - 1, weight=c)\n\n# pred, dist = nx.dijkstra_predecessor_and_distance(G, K - 1)\ndist = nx.shortest_path_length(G, K - 1, weight='weight')\n\nfor x, y in XY:\n    print((dist[x - 1] + dist[y - 1]))\n\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nG = [[] for i in range(N)]\n\nfor i in range(N - 1):\n  a,b,c = list(map(int,readline().split()))\n  G[a - 1].append((b - 1, c))\n  G[b - 1].append((a - 1, c))\n  \nQ,K = list(map(int,readline().split()))\n\ndist = [0] * N\nstack = [(K - 1, -1, 0)]\nwhile stack:\n  v,parent,cost = stack.pop()\n  dist[v] = cost\n  for child, c in G[v]:\n    if child == parent:\n      continue\n    stack.append((child, v, cost + c))\n    \nfor i in range(Q):\n  x,y = list(map(int,readline().split()))\n  print((dist[x - 1] + dist[y - 1]))\n", "import sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\ndef NIJIGEN(H): return [list(input()) for i in range(H)]\ndef bfs(place,dis):\n  for i in tree[place]:\n    a,b=i\n    if a not in finish:\n      finish.add(a)\n      disli[a]=dis+b\n      bfs(a,dis+b)\nN=INT()\ntree=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b,c=MAP()\n  tree[a-1].append([b-1,c])\n  tree[b-1].append([a-1,c])\nQ,K=MAP()#\u51e6\u7406\ndisli=[0 for i in range(N)]\nfinish=set([K-1])\nbfs(K-1,0)\nfor i in range(Q):\n  a,b=MAP()\n  print(disli[a-1]+disli[b-1])", "import sys\nsys.setrecursionlimit(10**9)\n\ndef dfs(now_node,parent_node,dist):\n  depth[now_node]=dist\n  for next_node,w in graph[now_node]:\n    if next_node==parent_node:\n      continue\n    dfs(next_node,now_node,dist+w)\n\nn=int(input())\ngraph=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n  a,b,c=map(int,input().split())\n  graph[a].append((b,c))\n  graph[b].append((a,c))\n  \nq,k=map(int,input().split())\ndepth=[-1]*(n+1)\ndfs(k,0,0)\nfor _ in range(q):\n  x,y=map(int,input().split())\n  print(depth[x]+depth[y])", "\ndef resolve():\n    INF = 1 << 60\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b, c = [int(x) - 1 for x in input().split()]\n        G[a].append((b, c + 1))\n        G[b].append((a, c + 1))\n\n    # x -> K, K->y \u306e\u6700\u77ed\u8ddd\u96e2,\n    # \u3088\u3063\u3066 K \u304b\u3089\u5404\u5730\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u524d\u8a08\u7b97\n\n    Q, K = list(map(int, input().split()))\n    K -= 1\n\n    dist = [INF] * N\n    dist[K] = 0\n    stack = []\n    stack.append(K)\n    while stack:\n        v = stack.pop()\n        for to, c in G[v]:\n            if dist[to] <= dist[v] + c:\n                continue\n            dist[to] = dist[v] + c\n            stack.append(to)\n\n    for _ in range(Q):\n        x, y = [int(x) - 1 for x in input().split()]\n        print((dist[x] + dist[y]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nfrom collections import deque\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef bfs(start):\n    q = deque([start])\n    dist = [-1] * (N + 1)\n    dist[start] = 0\n    while q:\n        v = q.popleft()\n        for nv, nw in g[v]:\n            if dist[nv] > 0:\n                continue\n            dist[nv] = dist[v] + nw\n            q.append(nv)\n    return dist\n\n\nN = int(input())\ng = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    g[a].append((b, c))\n    g[b].append((a, c))\nQ, K = list(map(int, input().split()))\nd = bfs(K)\nans = []\nfor _ in range(Q):\n    x, y = list(map(int, input().split()))\n    print((d[x] + d[y]))\n", "import sys\nsys.setrecursionlimit(pow(10,6))\nreadline = sys.stdin.readline\n\ndef dfs(nw, d):\n    V[nw] = d\n    for nx in G[nw]:\n        if V[nx[0]]==-1:\n            dfs(nx[0], d+nx[1])\n\nn = int(readline())\nG = [[] for _ in range(n)]\nfor i in range(n-1):\n    a,b,c = map(int, readline().split())\n    G[a-1].append((b-1,c))\n    G[b-1].append((a-1,c))\nq, k = map(int, readline().split())\n\nV = [-1]*n\ndfs(k-1, 0)\n\nfor i in range(q):\n    x,y = map(lambda x:int(x)-1, readline().split())\n    print(V[x]+V[y])", "import sys\nsys.setrecursionlimit(10**9)\n\nN = int(input())\nG = [[] for _ in range(N)]\nlength = {}\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n    length[(a-1, b-1)] = c\n    length[(b-1, a-1)] = c\n\nr = 0\ndist = [0]*N\n\nprv = [None]*N\ndepth = [0]*N\n\ndef dfs(v):\n    for u in G[v]:\n        if dist[u] > 0 or u ==r: continue\n        dist[u] = dist[v] + length[(v, u)]\n        depth[u] = depth[v] + 1\n        prv[u] = v\n        dfs(u)\n\ndfs(r)\n\n# N: \u9802\u70b9\u6570\n# G[v]: \u9802\u70b9v\u306e\u5b50\u9802\u70b9 (\u89aa\u9802\u70b9\u306f\u542b\u307e\u306a\u3044)\n#\n# - construct\n# prv[u] = v: \u9802\u70b9u\u306e\u4e00\u3064\u4e0a\u306e\u7956\u5148\u9802\u70b9v\n# - lca\n# kprv[k][u] = v: \u9802\u70b9u\u306e2^k\u500b\u4e0a\u306e\u7956\u5148\u9802\u70b9v\n# depth[u]: \u9802\u70b9u\u306e\u6df1\u3055 (\u6839\u9802\u70b9\u306f0)\n\nLV = (N-1).bit_length()\ndef construct(prv):\n    kprv = [prv]\n    S = prv\n    for k in range(LV):\n        T = [0]*N\n        for i in range(N):\n            if S[i] is None:\n                continue\n            T[i] = S[S[i]]\n        kprv.append(T)\n        S = T\n    return kprv\n\ndef lca(u, v, kprv, depth):\n    dd = depth[v] - depth[u]\n    if dd < 0:\n        u, v = v, u\n        dd = -dd\n\n    # assert depth[u] <= depth[v]\n    for k in range(LV+1):\n        if dd & 1:\n            v = kprv[k][v]\n        dd >>= 1\n\n    # assert depth[u] == depth[v]\n    if u == v:\n        return u\n\n    for k in range(LV-1, -1, -1):\n        pu = kprv[k][u]; pv = kprv[k][v]\n        if pu != pv:\n            u = pu; v = pv\n\n    # assert kprv[0][u] == kprv[0][v]\n    return kprv[0][u]\n\nkprv = construct(prv)\n\nQ, K = map(int, input().split())\nK -= 1\n\nans = []\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    xr = lca(x, K, kprv, depth)\n    yr = lca(y, K, kprv, depth)\n    a = dist[x] + dist[K] - dist[xr]*2 + dist[y] + dist[K] - dist[yr]*2\n    ans.append(a)\n\nprint('\\n'.join(map(str, ans)))", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\nN = int(input())\nadj = [[] for _ in range(N)]\nrtree = [None] * N\n\ndef dfs(v,parent,dist):\n    rtree[v] = dist\n    for u, c in adj[v]:\n        if u == parent:\n            continue\n        dfs(u,v,dist+c)\n\ndef main():\n    for _ in range(N-1):\n        a, b, c = list(map(int, input().split()))\n        adj[a-1].append((b-1,c))\n        adj[b-1].append((a-1,c))\n    Q, K = list(map(int, input().split()))\n\n    # K\u3092\u9802\u70b9\u3068\u3059\u308b\u6839\u4ed8\u304d\u6728\u3092\u4f5c\u6210\u3059\u308b\n    dfs(K-1,-1,0)\n\n    for _ in range(Q):\n        x, y = [int(x)-1 for x in input().split()]\n        print((rtree[x] + rtree[y]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10**6)\n\n\nN=int(input())\nG=[[] for _ in range(N)]\nfor i in range(N-1):\n    a,b,c=list(map(int,input().split()))\n    G[a-1].append([b-1,c])\n    G[b-1].append([a-1,c])\n\nQ,K=list(map(int,input().split()))\n\nSD=[0]*N\ndef DFS(v,p,d):\n    SD[v]=d\n    for i,co in G[v]:\n        if i==p:continue\n        DFS(i,v,d+co)\n    return\n\nDFS(K-1,-1,0)\n\nfor i in range(Q):\n    x,y=list(map(int,input().split()))\n    ans=SD[x-1]+SD[y-1]\n    print(ans)\n\n", "from collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\nn = int(input())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b, c = list(map(int, input().split()))\n    a-=1; b-=1\n    g[a].append((b, c))\n    g[b].append((a, c))\nq, k = list(map(int, input().split()))\n\n# \u524d\u51e6\u7406\ndist = [-1] * n\n\ndef dfs(st, depth=0):\n    dist[st] = depth\n    for to, c in g[st]:\n        if dist[to] >= 0: continue\n        dfs(to, depth+c)\n\ndfs(k-1, 0)\n\nfor i in range(q):\n    x, y = list(map(int, input().split()))\n    x-=1; y-=1\n    print((dist[x]+dist[y]))\n\n", "import sys\nimport queue\n\nn=int(input())\n\nclis=[[] for i in range(n)]\n\nfor i in range(n-1):\n  ai,bi,ci=map(int,input().split())\n  clis[ai-1].append([bi,ci])\n  clis[bi-1].append([ai,ci])\n\nq,k=map(int,input().split())\n\nxy=[]\n\nfor i in range(q):\n  xy.append(list(map(int,input().split())))\n\n\ndistance=[0 for i in range(n)]\nseen=[0 for i in range(n)]\n\nque=queue.Queue()\n\nque.put(k)\nseen[k-1]=1\n\nwhile not que.empty():\n  c=que.get()\n  for aa,cc in clis[c-1]:\n    if seen[aa-1]==0:\n      distance[aa-1]=distance[c-1]+cc\n      seen[aa-1]=1\n      que.put(aa)\n\nfor i in range(q):\n  print(distance[xy[i][0]-1]+distance[xy[i][1]-1])", "import heapq as hq\nN = int(input())\nedges = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b,c = map(int,input().split())\n    a -= 1\n    b -= 1\n    edges[a].append((b, c))\n    edges[b].append((a, c))\nQ, K = map(int,input().split())\nINF = float(\"inf\")\nd = [INF]*N\nK -= 1\nd[K] = 0\nq = [(0,K)]\nwhile q:\n    dist, i = hq.heappop(q)\n    if d[i] < dist:\n        continue\n    for j, w in edges[i]:\n        if d[j] > d[i]+w:\n            d[j] = d[i]+w\n            hq.heappush(q, (d[j], j))\nfor _ in range(Q):\n    x, y = map(int,input().split())\n    x -= 1\n    y -= 1\n    print(d[x]+d[y])", "\nfrom heapq import heappush, heappop\ndef resolve():\n    INF = 1 << 60\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b, c = [int(x) - 1 for x in input().split()]\n        G[a].append((b, c + 1))\n        G[b].append((a, c + 1))\n\n    # x -> K, K->y \u306e\u6700\u77ed\u8ddd\u96e2,\n    # \u3088\u3063\u3066 K \u304b\u3089\u5404\u5730\u70b9\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u524d\u8a08\u7b97\n\n    Q, K = list(map(int, input().split()))\n\n    K -= 1\n    dist = [INF] * N\n    hq = []\n    heappush(hq, (K, 0))\n    dist[K] = 0\n    while hq:\n        v, cost = heappop(hq)\n        for to, c in G[v]:\n            if dist[to] <= dist[v] + c:\n                continue\n            dist[to] = dist[v] + c\n            heappush(hq, (to, dist[to]))\n\n    for _ in range(Q):\n        x, y = [int(x) - 1 for x in input().split()]\n        print((dist[x] + dist[y]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import defaultdict,deque\nn=int(input())\nedges=[tuple(map(int,input().split())) for _ in range(n-1)]\nq,k=map(int,input().split())\nxy=[tuple(map(int,input().split())) for _ in range(q)]\n\nstack=[-1]*(n+1)\nstack[k]=0\ned=defaultdict(list)\nwt=defaultdict(int)\nfor e in edges:\n  ed[e[0]].append(e[1])\n  ed[e[1]].append(e[0])\n  wt[(e[0],e[1])]=e[2]\n  wt[(e[1],e[0])]=e[2]\nce=deque([(k,x) for x in ed[k]])\nne=deque()\nwhile True:\n  while ce:\n    e=ce.pop()\n    stack[e[1]]=stack[e[0]]+wt[e]\n    for v in ed[e[1]]:\n      if stack[v]<0:\n        ne.append((e[1],v))\n  if not ne:\n    break\n  ce.extend(ne)\n  ne.clear()\n\nfor que in xy:\n  print(stack[que[0]]+stack[que[1]])", "N=int(input())\nG=[[] for _ in range(N)]\nfor i in range(N-1):\n    a,b,c=list(map(int,input().split()))\n    G[a-1].append([b-1,c])\n    G[b-1].append([a-1,c])\n\nQ,K=list(map(int,input().split()))\n\nSD=[0]*N\nseen=[0]*N\nstack=[]\nstack.append([K-1,0])\nseen[K-1]=1\nwhile stack:\n    x,d=stack.pop()\n    for y,d0 in G[x]:\n        if seen[y]==0:\n            SD[y]=d+d0\n            stack.append([y,d+d0])\n            seen[y]=1\nfor i in range(Q):\n    x,y=list(map(int,input().split()))\n    ans=SD[x-1]+SD[y-1]\n    print(ans)\n\n", "# \u5e45\u512a\u5148\u63a2\u7d22\nfrom collections import deque\n\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = list(map(int, input().split()))\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\nq = deque([K])\nwhile q:\n    i = q.popleft()\n    for j, c in links[i]:\n        if d[i] + c < d[j]:\n            d[j] = d[i] + c\n            q.append(j)\n\nresult = []\nfor _ in range(Q):\n    x, y = list(map(int, input().split()))\n    result.append(d[x] + d[y])\nprint(('\\n'.join(str(v) for v in result)))\n#print(*result, sep='\\n')\n", "import sys\nsys.setrecursionlimit(10**9)\nn = int(input())\nt = [[] for _ in range(n)]\nfor i in range(n-1):\n  a,b,c = map(int,input().split())\n  t[a-1].append((b-1,c))\n  t[b-1].append((a-1,c))\nq,k = map(int,input().split())\nk -= 1\nl = [0]*n\ndef dfs(a,b,c):\n  for i,j in t[b]:\n    if i != a:\n      l[i] = c+j\n      dfs(b,i,c+j)\ndfs(-1,k,0)\nfor _ in range(q):\n  x,y = map(lambda x:int(x)-1,input().split())\n  print(l[x]+l[y])", "from networkx import *\nN = int(input())\nE1 = [list(map(int,input().split())) for n in range(N-1)]\nQ,K = map(int,input().split())\nE2 = [list(map(int,input().split())) for q in range(Q)]\nG = Graph()\n\nfor a,b,c in E1:\n  G.add_edge(a-1,b-1,weight=c)\n\nD = shortest_path_length(G,K-1,weight=\"weight\")\n\nfor x,y in E2:\n  print(D[x-1]+D[y-1])", "import sys\nsys.setrecursionlimit(10**9)\n\nn = int(input())\nroute = [[] for _ in range(n)]\ndistance = [-1 for _ in range(n)]\nINF = float('inf')\n    \nfor _ in range(n-1):\n    a, b, c = list(map(int, input().split()))\n    route[a-1].append((b-1, c))\n    route[b-1].append((a-1, c))\nq, k = list(map(int, input().split()))\n\n# \u518d\u5e30\u306b\u3088\u308b\u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef Tree(s, g, c):\n    distance[s] = c\n    for g1, val in route[s]:\n        if g == g1:\n            continue\n        Tree(g1, s, c+val)\n    \ndef TransitTreePath():\n    Tree(k-1, -1, 0)\n    for _ in range(q):\n        x, y = list(map(int, input().split()))\n        ans = distance[x-1]+distance[y-1]\n        print(ans)\n        \n\ndef __starting_point():\n    TransitTreePath()\n    \n\n__starting_point()", "\nfrom collections import defaultdict,deque\nimport sys\nfinput=lambda: sys.stdin.readline().strip()\n\ndef main():\n  n=int(finput())\n  edges=[tuple(map(int,finput().split())) for _ in range(n-1)]\n  q,k=list(map(int,finput().split()))\n  xy=[tuple(map(int,finput().split())) for _ in range(q)]\n  \n  stack=[-1]*(n+1)\n  stack[k]=0\n  ed=defaultdict(list)\n  wt=defaultdict(int)\n  for e in edges:\n    ed[e[0]].append(e[1])\n    ed[e[1]].append(e[0])\n    wt[(e[0],e[1])]=e[2]\n    wt[(e[1],e[0])]=e[2]\n  ce=deque([(k,x) for x in ed[k]])\n  ne=deque()\n  while True:\n    while ce:\n      e=ce.pop()\n      stack[e[1]]=stack[e[0]]+wt[e]\n      for v in ed[e[1]]:\n        if stack[v]<0:\n          ne.append((e[1],v))\n    if not ne:\n      break\n    ce.extend(ne)\n    ne.clear()\n  \n  for que in xy:\n    print((stack[que[0]]+stack[que[1]]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\n\ndef solve():\n    N = INT()\n    adj = [[] for _ in range(N)]\n    for i in range(N-1):\n        a, b, c = MAP()\n        adj[a-1].append([b-1, c])\n        adj[b-1].append([a-1, c])\n\n    Q, K = MAP()\n    K -= 1\n\n    def dijkstra(K, adj):\n        #K: \u59cb\u70b9, adj[point, cost]:\u96a3\u63a5\u30ea\u30b9\u30c8\n        d = [inf]*N\n        d[K] = 0\n        que = []\n        heappush(que, K)\n\n        while que:\n            v = heappop(que)\n            for b, c in adj[v]:\n                if d[b] > d[v] + c:\n                    d[b] = d[v] + c\n                    heappush(que, b)\n        return d\n\n    d = dijkstra(K, adj)\n    for i in range(Q):\n        x, y = MAP()\n        print(d[x-1]+d[y-1])\n\ndef __starting_point():\n    solve()\n__starting_point()", "N = int(input())\n\ntree = {}\n\nfor _ in range(N-1):\n  A, B, C = [int(i) for i in input().split()]\n  if A not in tree:\n    tree[A] = []\n  if B not in tree:\n    tree[B] = []\n  tree[A].append((B, C))\n  tree[B].append((A, C))\n\n\nc = {}\nq = []\nvisited = set()\n\ndef dfs(a, acc):\n  q.append((a, acc))\n\n  while q:\n    n, r = q.pop()\n    c[n] = r\n    visited.add(n)\n    for b, cost in ((b, cost) for b, cost in tree[n] if b not in visited):\n      q.append((b, cost + r))\n\n\nQ, K = [int(i) for i in input().split()]\ndfs(K, 0)\n\nfor _ in range(Q):\n  x, y = [int(i) for i in input().split()]\n  print((c[x] + c[y]))\n", "from collections import deque\n\nN = int(input())\n\ngraph = [[] for _ in range(N+1)]\n\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n    \nQ, K = map(int, input().split())\n\nvisited = [-1 for _ in range(N+1)]\n\nvisited[K] = 0\nque = deque()\nque.append(K)\n\nwhile (len(que)):\n    now = que.popleft()\n    \n    for nxt, c in graph[now]:\n        if(visited[nxt] != -1):\n            continue\n        visited[nxt] = visited[now]+c\n        que.append(nxt)\n        \nfor i in range(Q):\n    x, y = map(int, input().split())\n    print(visited[x]+visited[y])", "N = int(input())\nedges = []\nfor i in range(N-1):\n    a,b,c = map(int,input().split())\n    edges.append([a,b,c])\n\ndef BFS(K,edges,N):\n    roots=[ [] for i in range(N)]\n    for a,b,c in edges:\n        roots[a-1]+=[(b-1,c)]\n        roots[b-1]+=[(a-1,c)]\n    dist=[-1]*N\n    stack=[]\n    stack.append(K)\n    dist[K]=0\n    while stack:\n        label=stack.pop(-1)\n        for i,c in roots[label]:\n            if dist[i]==-1:\n                dist[i]=dist[label]+c\n                stack+=[i]\n    return dist\n\nQ,K = map(int,input().split())\nK = K-1\ndist = BFS(K,edges,N)\nlsxy = []\nfor i in range(Q):\n    x,y = map(int,input().split())\n    x = x-1\n    y = y-1\n    lsxy.append([x,y])\nfor i in lsxy:\n    print(dist[i[0]]+dist[i[1]])", "import sys\nsys.setrecursionlimit(10**9)\nN=int(input())\nT=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b,c=map(int, input().split())\n  T[a-1].append((b-1,c))\n  T[b-1].append((a-1,c))\nQ,K=map(int, input().split())\n\ndist=[-1]*N\ndist[K-1]=0\n\ndef dfs(start, nown):\n  to=T[start]\n  for t in to:\n    next_node,c=t\n    if dist[next_node]!=-1:\n      continue\n    nextn=nown+c\n    dist[next_node]=nextn\n    dfs(next_node, nextn)\n\ndfs(K-1,0)\nfor i in range(Q):\n  x,y=map(int, input().split())\n  print(dist[x-1]+dist[y-1])", "import sys\nsys.setrecursionlimit(10**6)\nn=int(input())\nedge=[[] for i in range(n)]\nfor i in range(n-1):\n    x,y,z=map(int,input().split())\n    edge[x-1].append([y-1,z])\n    edge[y-1].append([x-1,z])\nq,k=map(int,input().split())\ndist=[-1]*n\ndef dfs(node,d):\n    dist[node]=d\n    for i in edge[node]:\n        if dist[i[0]]==-1:\n            dfs(i[0],d+i[1])\ndfs(k-1,0)\nfor i in range(q):\n    x,y=map(int,input().split())\n    print(dist[x-1]+dist[y-1])", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN=int(input())\ntree = [[] for i in range(N+1)]\n\nfor _ in range(N-1):\n    a,b,c=list(map(int,input().split()))\n    tree[a].append([b,c])\n    tree[b].append([a,c])\nQ,K=list(map(int,input().split()))\n    \nmemo = [-1]*(N+1)\nq = collections.deque([K])\nmemo[K]=0\nwhile q:\n    now = q.pop()\n    for direct,cost in tree[now]:\n        if memo[direct]== -1:\n            memo[direct]=memo[now]+cost\n            q.append(direct)\nfor _ in range(Q):\n    a,b=list(map(int,input().split()))\n    ans =memo[a]+memo[b]\n    print(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\n\nn=int(input())\n\ngraph = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u, v, w = list(map(int, input().split()))\n    graph[u-1].append((v-1, w))\n    graph[v-1].append((u-1, w))\n\nq,k=list(map(int, input().split()))\nk-=1\n\ndist=[-1]*n\n\ndef dfs(now, parent, d):\n    dist[now]=d\n    for i in graph[now]:\n        if i[0]==parent:\n            continue\n        else:\n            dfs(i[0], now, d+i[1])\n\ndfs(k, -1, 0)\n\nfor _ in range(q):\n    x,y=list(map(int, input().split()))\n    x-=1\n    y-=1\n    print((dist[x]+dist[y]))\n\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\n# \u91cd\u307f\u4ed8\u304d\u30b0\u30e9\u30d5\u95a2\u4fc2\u306b\u3088\u308a\u6700\u77ed\u7d4c\u8def\u306e\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\n# \u6709\u5411\u30b0\u30e9\u30d5\u3067\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u3067\u63a2\u7d22\n\nfrom heapq import heapify, heappop, heappush, heappushpop\n\nINF = float('inf')\n\ndef dijkstra(s,n,g):\n    seen = [False]*n\n    cost = [INF]*n\n    cost[s] = 0 #\u30b9\u30bf\u30fc\u30c8\u306f\u30b3\u30b9\u30c80\n    next_q = [(0,s)]\n    heapify(next_q)\n    while len(next_q)>0:\n        c, i = heappop(next_q)\n        if cost[i] < c:\n            continue\n        for nedge, ncost in g[i]:\n            nc = cost[i]+ncost\n            if cost[nedge]>nc:\n                cost[nedge] = nc\n                heappush(next_q,(nc, nedge))\n    return cost\n\ndef main():\n    N = int(input())\n    graph_F = [[] for _ in range(N)]\n#    graph_R = [[] for _ in range(N)]\n    #\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\n    for _ in range(N-1):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        graph_F[a].append((b,c))\n        graph_F[b].append((a,c))\n#        graph_R[b].append((a,c))\n\n    Q, K = map(int, input().split())\n    K -= 1\n    F = dijkstra(K,N,graph_F)\n    for _ in range(Q):\n        x, y = map(int, input().split())\n        print(F[x-1]+F[y-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nn=int(input())\ne=[[] for _ in range(n+1)]\ndist=[-1]*(n+1)\nfor i in range(n-1):\n    a,b,c=map(int,input().split())\n    e[a].append((b,c))\n    e[b].append((a,c))\nq,k=map(int,input().split())\na=deque()\na.append((k,0))\nwhile a:\n    x,d=a.popleft()\n    dist[x]=d\n    for j,nc in e[x]:\n        if dist[j]!=-1:\n            continue\n        else:\n            a.append((j,d+nc))\nans=[]\nfor i in range(q):\n    x,y=map(int,input().split())\n    ans.append(dist[x]+dist[y])\nprint(*ans,sep=\"\\n\")", "N = int(input())\nabclist = [list(map(int, input().split())) for _ in range(N-1)]\nQ, K = map(int, input().split())\nxylist = [list(map(int, input().split())) for _ in range(Q)]\n\nfrom heapq import heapify, heappush, heappop\n\ninf = float(\"inf\")\ndef dijkstra(graph, start):  # graph\u306f\u96a3\u63a5\u30ea\u30b9\u30c8(\u7e4b\u304c\u3063\u3066\u3044\u308b\u5148, \u30b3\u30b9\u30c8)\n    vsize = len(graph)\n    dist = [inf] * vsize\n    seen = [False] * vsize\n    prev = [None] * vsize\n    pq = []\n    heapify(pq)\n\n    dist[start] = 0\n    heappush(pq, (0, start))  # heap\u3067\u306ftuple[0]\u3067\u6bd4\u8f03\u3055\u308c\u308b\u306e\u3067\u3053\u306e\u9806\u756a\u3067\u8ffd\u52a0\u3059\u308b\n    while pq:\n        cost, u = heappop(pq)\n        seen[u] = True\n        if dist[u] < cost:\n            continue\n        for v, w in graph[u]:\n            temp_cost = dist[u] + w\n            if not seen[v] and temp_cost < dist[v]:\n                dist[v] = temp_cost\n                prev[v] = u\n                heappush(pq, (dist[v], v))\n    return dist, prev\n\ngraph = [[] for _ in range(N)]\nfor a, b, c in abclist:\n    graph[a-1].append((b-1, c))\n    graph[b-1].append((a-1, c))\nshortest_paths, prev = dijkstra(graph, K-1)\nfor x, y in xylist:\n    print(shortest_paths[x-1]+shortest_paths[y-1])", "\nfrom heapq import heappop,heappush\n\nicase=0\nif icase==0:\n    n=int(input())\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        ai,bi,ci=list(map(int,input().split()))\n        g[ai-1].append((bi-1,ci))\n        g[bi-1].append((ai-1,ci))\nif icase==1:\n    n=5\n    g=[[(1, 1), (2, 1)], [(0, 1), (3, 1)], [(0, 1), (4, 1)], [(1, 1)], [(2, 1)]]\nif icase==2:\n    n=7\n    g=[[(1, 1), (2, 3), (3, 5), (4, 7), (5, 9), (6, 11)], [(0, 1)], [(0, 3)], [(0, 5)], [(0, 7)], [(0, 9)], [(0, 11)]]\n\nq,k=list(map(int,input().split()))\nk=k-1\n\nhq=[]\nheappush(hq,(0,k)) \n\ninf=float(\"INF\")\ndist=[inf]*n\ndist[k]=0\nwhile len(hq)>0:\n    dd,state = heappop(hq)\n#    print(\"dd:\",dd,\"state:\",state,\"q:\",q)\n    for v,dv in g[state]:\n#        print(\"v:\",v,\"dv:\",dv,\"g[state]:\",g[state],\"parent[v]:\",parent[v])\n        if dist[v]>dist[state]+dv:\n            dist[v]=dist[state]+dv\n            heappush(hq,(dist[v],v))\n#            print(\" state:\",state,\"v:\",v,\"dist[v]\",dist[v])\n\nfor i in range(q):\n    xi,yi=list(map(int,input().split()))\n    print((dist[xi-1]+dist[yi-1]))\n", "# \u6df1\u3055\u512a\u5148\u63a2\u7d22\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = map(int, input().split())\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\nq = [K]\nwhile q:\n    i = q.pop()\n    for j, c in links[i]:\n        if d[i] + c < d[j]:\n            d[j] = d[i] + c\n            q.append(j)\n\nresult = []\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    result.append(d[x] + d[y])\n#print('\\n'.join(str(v) for v in result))\nprint(*result, sep='\\n')", "import networkx as nx\n\nN = int(input())\nABC = [list(map(int, input().split())) for _ in range(N - 1)]\nQ, K = list(map(int, input().split()))\nXY = [list(map(int, input().split())) for _ in range(Q)]\n\nG = nx.Graph()\n\nfor a, b, c in ABC:\n    G.add_edge(a - 1, b - 1, weight=c)\n\npred, dist = nx.dijkstra_predecessor_and_distance(G, K - 1)\n\nfor x, y in XY:\n    print((dist[x - 1] + dist[y - 1]))\n\n", "N=int(input())\nabc=[list(map(int,input().split()))for _ in range(N-1)]\nQ,K=map(int,input().split())\nxy=[list(map(int,input().split()))for _ in range(Q)]\n\nG=[[]for _ in range(N+1)]\nfor a,b,c in abc:\n    G[a].append([a,b,c])\n    G[b].append([b,a,c])\n\nD=[10**9*(N+1)]*(N+1)\nD[0]=0\nD[K]=0\nfrom collections import*\nque=deque(G[K])\nwhile que:\n    a,b,c=que.popleft()\n    if D[a]+c<D[b]:\n        D[b]=D[a]+c\n        for g in G[b]:\n            que.append(g)\n\nfor x,y in xy:\n    print(D[x]+D[y])", "#!/usr/bin/env python3\n# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left\u3000\u3053\u308c\u3067\u4e8c\u90e8\u63a2\u7d22\u306e\u5927\u5c0f\u691c\u7d22\u304c\u884c\u3048\u308b\nimport fractions #\u6700\u5c0f\u516c\u500d\u6570\u306a\u3069\u306f\u3053\u3063\u3061\nimport math\nimport sys\nimport collections\nfrom decimal import Decimal # 10\u9032\u6570\u3067\u8003\u616e\u3067\u304d\u308b\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # \u518d\u5e30\u56de\u6570\u4e0a\u9650\u306f\u3067default1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN = int(input())\nweights = {}\n\nroots = [[] for i in range(N)]\nfor i in range(N - 1):\n    a, b, c = LI()\n    a -= 1\n    b -= 1\n    roots[a].append(b)\n    roots[b].append(a)\n    weights[(a,b)] = c\n    weights[(b,a)] = c\n\nQ, K = LI()\nK -= 1\nxy = [0 for i in range(Q)]\nfor i in range(Q):\n    x, y = LI()\n    x -= 1\n    y -= 1\n    xy[i] = [x, y]\n\"\"\"\nxyz\u3067\u5168\u90e8\u306e\u901a\u308a\u3092\u898b\u3064\u3051\u308b\u3068N ** 3\u3067\u7121\u7406\n\u306a\u306e\u3067\u4eca\u56de\u306f\u6728\u69cb\u9020\u306b\u6ce8\u76ee\u3057\u3066BFS or DFS\u3067\u89e3\u3044\u305f\u3089\u3044\u3044\u306e\u3067\u306f\uff1f\n\u91cd\u307f\u3092\u5358\u7d14\u306b\u30b0\u30e9\u30d5\u306b\u6301\u3064\u306810**5 ** 2\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u306e\u3067\u6ce8\u610f\n\"\"\"\n\nvisited = [-1 for i in range(N)]\nqueue = collections.deque()\nqueue.append(K)\nvisited[K] = 0\n\nwhile len(queue)> 0:\n    node = queue.popleft()\n    cnt = visited[node]\n    for n_node in roots[node]:\n        if visited[n_node] == -1:\n            visited[n_node] = cnt + weights[(node, n_node)]\n            queue.append(n_node)\n\nfor x, y in xy:\n    print((visited[x] + visited[y]))\n", "# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\nfrom heapq import heappop, heappush\n\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = map(int, input().split())\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\n#prev = [None] * (N + 1)\nq = [(0, K)]\nwhile q:\n    _, u = heappop(q)\n    for v, c in links[u]:\n        alt = d[u] + c\n        if d[v] > alt:\n            d[v] = alt\n            #prev[v] = u\n            heappush(q, (alt, v))\n\nresult = []\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    result.append(d[x] + d[y])\nprint(*result, sep='\\n')\n#print('\\n'.join(str(v) for v in result))\n", "from collections import namedtuple, deque\nN = int(input())\n\nconnection = [[] for _ in range(N)]\nbranch = namedtuple('branch',['id', 'dist'])\nfor _ in range(N-1):\n    a, b, c = list(map(int, input().split()))\n    connection[a-1].append(branch(b-1, c))\n    connection[b-1].append(branch(a-1, c))\n\ndist = [0] * N #dist from root(K)\nQ, K = list(map(int, input().split()))\n#bfs\nreserved = deque([K-1])\nseen = {K-1}\nwhile len(reserved) > 0:\n    current = reserved.popleft()\n    for next in connection[current]:\n        if next.id in seen:\n            continue\n        seen.add(next.id)\n        reserved.append(next.id)\n        dist[next.id] = dist[current] + next.dist\n\n#deal with query\nQuery = [list(map(int, input().split())) for _ in range(Q)]\nfor x,y in Query:\n    print((dist[x-1] + dist[y-1]))\n\n\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nn = int(input())\nedges = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append([b, c])\n    edges[b].append([a, c])\n    \nq, k = map(int, input().split())\n\ncheck = [False for _ in range(n)]\ndist = [0 for _ in range(n)]\ndef dfs(pos, b_pos):\n    for n_pos, c in edges[pos]:\n        if n_pos == b_pos:\n            continue\n        check[n_pos] = True\n        dist[n_pos] = c + dist[pos]\n        dfs(n_pos, pos)\n\ncheck[k - 1] = True\ndfs(k - 1, -1)\n\nfor _ in range(q):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    print(dist[x] + dist[y])", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nn= int(input())\nG=[[] for i in range(n+1)]\n\nfor i in range(n-1):\n\ta,b,c=map(int, input().split())\n\tG[a].append([b,c])\n\tG[b].append([a,c])\n\nq,k=map(int,input().split())\n\n\nD=[None]*(n+1)\n \ndef dfs(x,d):\n    D[x]=d\n    for yy,dd in G[x] :\n        if D[yy] is not None:\n            continue\n        dfs(yy,dd+d)\ndfs(k,0)\n\nfor i in range(q):\n    x, y = map(int, input().split())\n    print(D[x] + D[y])", "# \u6df1\u3055\u512a\u5148\u63a2\u7d22\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = map(int, input().split())\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\nq = [K]\nwhile q:\n    i = q.pop()\n    for j, c in links[i]:\n        if d[i] + c < d[j]:\n            d[j] = d[i] + c\n            q.append(j)\n\nresult = []\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    result.append(d[x] + d[y])\n#print('\\n'.join(str(v) for v in result))\nprint(*result, sep='\\n')\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\nfrom heapq import heappush, heappop\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\ndef dijkstra(s, n): # (\u59cb\u70b9, \u30ce\u30fc\u30c9\u6570)\n    dist = [inf] * n\n    hq = [(0, s)] # (distance, node)\n    dist[s] = 0\n    seen = [False] * n # \u30ce\u30fc\u30c9\u304c\u78ba\u5b9a\u6e08\u307f\u304b\u3069\u3046\u304b\n    while hq:\n        v = heappop(hq)[1] # \u30ce\u30fc\u30c9\u3092 pop \u3059\u308b\n        seen[v] = True\n        for to, cost in adj[v]: # \u30ce\u30fc\u30c9 v \u306b\u96a3\u63a5\u3057\u3066\u3044\u308b\u30ce\u30fc\u30c9\u306b\u5bfe\u3057\u3066\n            if seen[to] == False and dist[v] + cost < dist[to]:\n                dist[to] = dist[v] + cost\n                heappush(hq, (dist[to], to))\n    return dist\n\nN = ni()\nadj = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b, c = na()\n    adj[a-1].append((b-1, c))\n    adj[b-1].append((a-1, c))\n\nQ, K = na()\nans = []\nd = dijkstra(K-1, N)\n\nfor i in range(Q):\n    x, y = na()\n    x -= 1\n    y -= 1\n    ans.append(d[x] + d[y])\n\nfor i in range(Q):\n    print((ans[i]))\n\n", "import sys\nsys.setrecursionlimit(10**9)\n\nn = int(input())\n\ntree = [[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b,c = map(int,input().split())\n    tree[a].append((b,c))\n    tree[b].append((a,c))\n\nq,k = map(int,input().split())\n\ndistance = [-1 for i in range(n+1)]\n\n#\u518d\u5e30\u3067k\u304b\u3089\u5404\u9802\u70b9\u307e\u3067\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\ndef dfs(now, pre, c):\n    distance[now] = c\n    for nxt, val in tree[now]:\n        if nxt == pre:\n            continue\n        dfs(nxt, now, c+val)\n\ndfs(k, -1, 0)\n\nfor i in range(q):\n    x,y = map(int,input().split())\n    print(distance[x] + distance[y])", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    G = [[] for _ in range(N)] \n    for _ in range(N - 1):\n        a, b, c = LI()\n        G[a-1].append((b - 1, c))\n        G[b-1].append((a - 1, c))\n    Q, K = LI()\n    K -= 1\n\n    dist = [-1] * N\n    dist[K] = 0\n    que = collections.deque()\n    que.append(K)\n    while que:\n        c = que.popleft()\n        for n, l in G[c]:\n            if dist[n] == -1:\n                dist[n] = dist[c] + l\n                que.append(n)\n\n    for _ in range(Q):\n        x, y = LI_()\n        ans = dist[x] + dist[y]\n        print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import re\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 6)\nmod = 10**9+7\ncnt = 0\nans = 0\ninf = float(\"inf\")\nal = \"abcdefghijklmnopqrstuvwxyz\"\nAL = al.upper()\n\nN = k()\nedge = [[] for _ in range(N+1)]\n\nfor _ in range(N-1):\n    a,b,c = I()\n    edge[a].append((b,c))\n    edge[b].append((a,c))\n\nQ,K = I()\n\ndist = [None]*(N+1)\n\ndef dfs(x,d):\n    dist[x] = d\n    for y,dd in edge[x]:\n        if dist[y] is not None:\n            continue\n        dfs(y,d+dd)\n\ndfs(K,0)\nfor _ in range(Q):\n    x,y = I()\n    print(dist[x]+dist[y])", "import sys\nfrom heapq import heappush, heappop\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b, c = map(int, readline().split())\n        G[a - 1].append((b - 1, c))\n        G[b - 1].append((a - 1, c))\n\n    Q, K, *XY = map(int, read().split())\n    K -= 1\n\n    hq = [(0, K)]\n    dist = [INF] * N\n    dist[K] = 0\n    while hq:\n        d, v = heappop(hq)\n        if dist[v] < d:\n            continue\n        for nv, cost in G[v]:\n            if dist[nv] > d + cost:\n                dist[nv] = d + cost\n                heappush(hq, (dist[nv], nv))\n\n    ans = [0] * Q\n    for i, (x, y) in enumerate(zip(*[iter(XY)] * 2)):\n        ans[i] = dist[x - 1] + dist[y - 1]\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nimport heapq\nfrom collections import defaultdict\nfrom collections import Counter\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\nN = int(input())\nadj = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    adj[a].append((c, b))\n    adj[b].append((c, a))\n\nQ, K = list(map(int, input().split()))\nK -= 1\n\ndef dijkstra(start):\n    dist = [INF for _ in range(N)]\n    visited = [False for _ in range(N)] \n    q = [(0, start)]\n    dist[start] = 0\n    while len(q) > 0:\n        v = heapq.heappop(q)\n        a = v[1]\n        if visited[a]:\n            continue\n        visited[a] = True\n        for u in adj[a]:\n            w = u[0]\n            b = u[1]\n            if dist[a] + w < dist[b]: \n                dist[b] = dist[a] + w\n                heapq.heappush(q, (dist[b], b))\n    return dist\n\ndist = dijkstra(K)\n\nfor i in range(Q):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    print((dist[x] + dist[y]))\n", "import sys\nsys.setrecursionlimit(1000000)\nN = int(input())\ntree = [[] for i in range(N)]\n\nfor i in range(N-1):\n  a, b, c = map(int, input().split())\n  a -= 1\n  b -= 1\n  tree[a].append([b, c])\n  tree[b].append([a, c])\n\nQ, K = map(int, input().split())\nK -= 1\ndis = [0]*N\n\ndef main(v, p, d):\n  dis[v] = d\n  for x, y in tree[v]:\n    if x == p:\n      continue\n    main(x, v, d+y)\n    \nmain(K, -1, 0)\n\nfor i in range(Q):\n  x, y = map(int, input().split())\n  ans = dis[x-1] + dis[y-1]\n  print(ans)", "import sys\nsys.setrecursionlimit(20000000)\n# N = 5\n# ARR = [\n#     [1, 2, 1],\n#     [1, 3, 1],\n#     [2, 4, 1],\n#     [3, 5, 1]\n# ]\n#\n# Q, K = 3, 1\n#\n# BRR = [\n#     [2, 4],\n#     [2, 3],\n#     [4, 5],\n# ]\n#\n#\n\nN = int(input())\n\nARR = [list(map(int,input().split())) for i in range(N-1)]\n\nQ, K = map(int,input().split())\n\nBRR = [list(map(int,input().split())) for i in range(Q)]\n\n\n\ndef prepare(arr, n):\n    links = [[] for i in range(n)]\n    depth = [0 for i in range(n)]\n    for i in range(n - 1):\n        startNode = arr[i][0] - 1\n        endNode = arr[i][1] - 1\n        dist = arr[i][2]\n\n        links[startNode].append((endNode, dist))\n        links[endNode].append((startNode, dist))\n\n    return links, depth\n\n\ndef dfs(currentNode, parrentNode=-1, dist=0):\n    childNodes = links[currentNode]\n    depths[currentNode] = dist\n    for (childNode, childDistance) in childNodes:\n        if childNode == parrentNode:\n            continue\n\n        dfs(childNode, currentNode, dist + childDistance)\n\n\nlinks, depths = prepare(ARR, N)\n\ndfs(K - 1)\n\nfor i in range(Q):\n    p1 = BRR[i][0] - 1\n    p2 = BRR[i][1] - 1\n\n    d1 = depths[p1]\n    d2 = depths[p2]\n\n    print(d1 + d2)", "import heapq\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b, c = map(int, input().split())\n    G[a - 1].append([c, b - 1])\n    G[b - 1].append([c, a - 1])\nQ, K = map(int, input().split())\n\ndef dijkstra(s, N, G):\n    d = [float('inf')] * N\n    d[s] = 0\n    hq = [[0, s]]\n    heapq.heapify(hq)\n    while len(hq) > 0:\n        v, i = heapq.heappop(hq)\n        if d[i] < v:\n            continue\n        for c, j in G[i]:\n            if d[j] > d[i] + c:\n                d[j] = d[i] + c\n                heapq.heappush(hq, [d[j], j])\n    return d\n\nD = dijkstra(K - 1, N, G)\n\ndist = [0] * Q\nfor i in range(Q):\n    x, y = map(int, input().split())\n    dist[i] = D[x - 1] + D[y - 1]\n\nfor d in dist:\n    print(d)", "import sys\nsys.setrecursionlimit(10**9)\n\nN = int(input())\n\ngraph = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    a, b, c = map(int, input().split())\n    graph[a-1].append((b-1, c))\n    graph[b-1].append((a-1, c))\n    \nQ, K = map(int, input().split())\nvisited = [0 for _ in range(N)]\n\ndef DFS(a, b, c):\n    for i, j in graph[b]:\n        if(i != a):\n            visited[i] = c+j\n            DFS(b, i, c+j)\nDFS(-1, K-1, 0)\n             \nfor _ in range(Q):\n    x, y = map(int, input().split())\n    print(visited[x-1]+visited[y-1])", "#\u30b0\u30e9\u30d5\u306e\u9023\u7d50\u6210\u5206\u3092\u8abf\u3079\u308b\ndef Graph(ab):\n    G = [[] for i in range(n)]\n    for a, b, c in ab:\n        G[a - 1].append([b, c])\n        G[b - 1].append([a, c])\n    return G\n\nfrom collections import deque\ndef bfs(k):\n    q = deque()\n    q.append((k, - 1, 0))\n    dis = [0] * n \n    while q:\n        V, P, cnt = q.popleft()\n        for nv, d in G[V - 1]:\n            if nv == P:continue\n            dis[nv - 1] = cnt + d\n            q.append((nv, V, cnt + d))\n    \n    return dis \n\nn = int(input())\nabc = [list(map(int,input().split())) for _ in range(n - 1)]\nG = Graph(abc)\nq, k = map(int,input().split())\ndis = bfs(k)\n\nfor _ in range(q):\n    x, y = map(int,input().split())\n    print(dis[x - 1] + dis[y - 1])", "from networkx import *\nN = int(input())\nE1 = [list(map(int,input().split())) for n in range(N-1)]\nQ,K = map(int,input().split())\nE2 = [list(map(int,input().split())) for q in range(Q)]\nG = Graph()\n\nfor a,b,c in E1:\n  G.add_edge(a-1,b-1,weight=c)\n\nD = shortest_path_length(G,weight=\"weight\",target=K-1)\n\nfor x,y in E2:\n  print(D[x-1]+D[y-1])", "N=int(input())\nG=[[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b,c=list(map(int,input().split()))\n    a-=1\n    b-=1\n    G[a].append([b,c])\n    G[b].append([a,c])\nQ,K=list(map(int,input().split()))\nK-=1\ndist=[-1 for _ in range(N)]\ndist[K]=0\nq=[K]\nwhile len(q)>0:\n    v=q.pop()\n    for p in G[v]:\n        nv=p[0]\n        if dist[nv]!=-1:\n            continue\n        dist[nv]=dist[v]+p[1]\n        q.append(nv)\nfor _ in range(Q):\n    x,y=list(map(int,input().split()))\n    print((dist[x-1]+dist[y-1]))\n", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\nfrom collections import deque\nfrom heapq import heappop, heappush\ndef main():\n        \n\n    def dijkstra(k):\n        def push(v, x):\n            if dist[v] <= x:\n                return\n            dist[v] = x\n            heappush(q, (x, v))\n\n        inf = 10**18\n        dist = [inf]*n\n        q = []\n        push(k, 0)\n        while q:\n            x, v = heappop(q)\n            if x > dist[v]:\n                continue\n            for nv, c in g[v]:\n                push(nv, x+c)\n        return dist\n\n    n = ii()\n    g = [[] for _ in range(n)]\n    for _ in range(n-1):\n        a, b, c = mi()\n        a -= 1\n        b -= 1\n\n        g[a].append((b, c))\n        g[b].append((a, c))\n    q, k = mi()\n    k -= 1\n    dist = dijkstra(k)\n    for i in range(q):\n        a, b = mi()\n        a -= 1\n        b -= 1\n        print(dist[a]+dist[b])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import networkx as nx\n\nN = int(input())\nABC = [list(map(int, input().split())) for _ in range(N - 1)]\nQ, K = list(map(int, input().split()))\nXY = [list(map(int, input().split())) for _ in range(Q)]\n\nG = nx.Graph()\n\nfor a, b, c in ABC:\n    G.add_edge(a - 1, b - 1, weight=c)\n\n# pred, dist = nx.dijkstra_predecessor_and_distance(G, K - 1)\ndist = nx.shortest_path_length(G, K - 1, weight=\"weight\", method=\"bellman-ford\")\n\nfor x, y in XY:\n    print((dist[x - 1] + dist[y - 1]))\n\n", "from networkx import *\nN = int(input())\nE1 = [list(map(int,input().split())) for n in range(N-1)]\nQ,K = map(int,input().split())\nE2 = [list(map(int,input().split())) for q in range(Q)]\nG = Graph()\n\nfor a,b,c in E1:\n  G.add_edge(a-1,b-1,weight=c)\n\nD = shortest_path_length(G,target=K-1,weight=\"weight\")\n\nfor x,y in E2:\n  print(D[x-1]+D[y-1])", "import sys\n\ndef BFS(K,edges,N):\n  roots=[ [] for i in range(N)]\n  for a,b,c in edges:\n    roots[a]+=[(b,c)]\n    roots[b]+=[(a,c)]\n  dist=[-1]*N\n  stack=[]\n  stack.append(K)\n  dist[K]=0\n  while stack:\n    label=stack.pop(-1)\n    for i,c in roots[label]:\n      if dist[i]==-1:\n        dist[i]=dist[label]+c\n        stack.append(i)\n  return dist\n      \n      \na = []\nedge = []\nfor l in sys.stdin:\n    a.append(l.split())\nV = int(a[0][0])\nfor i in range(V-1):\n  buf = [int(a[i+1][0])-1, int(a[i+1][1])-1, int(a[i+1][2])]\n  edge.append(buf)\nn = int(a[V][0])\ns = int(a[V][1])-1\nques = []\nfor i in range(n):\n  buf = [int(a[V+i+1][0])-1, int(a[V+i+1][1])-1]\n  ques.append(buf)\ndist = BFS(s, edge, V)\nfor a, b in ques:\n  res = dist[a] + dist[b]\n  print(res)", "import sys\nimport heapq\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\nin_n = lambda: int(readline())\nin_nn = lambda: list(map(int, readline().split()))\nin_nl = lambda: list(map(int, readline().split()))\nin_na = lambda: list(map(int, read().split()))\nin_s = lambda: readline().rstrip().decode('utf-8')\n\n\nINF = 10**18\n\n\ndef dijkstra(N, s0, edge):\n\n    d = [INF] * N  # \u59cb\u70b9\u304b\u3089\u306e\u8ddd\u96e2\n    used = [False] * N  # \u63a2\u7d22\u6e08\u307f\u30ea\u30b9\u30c8\n    edgelist = [(0, s0)]  # \u59cb\u70b9\u306f\u30b3\u30b9\u30c80\u3067\u521d\u671f\u5316\n    heapq.heapify(edgelist)  # \u30d2\u30fc\u30d7\u306bpush\n\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if used[minedge[1]]:\n            continue\n        v = minedge[1]\n        d[v] = minedge[0]\n        used[v] = True\n        for e in edge[v]:\n            if d[e[1]] <= (e[0] + d[v]) or used[e[1]]:\n                continue\n            heapq.heappush(edgelist, [e[0] + d[v], e[1]])\n    return d\n\n\ndef main():\n    N = in_n()\n\n    edge = [[]for _ in range(N)]\n    for i in range(N - 1):\n        a, b, c = in_nn()\n        a, b = a - 1, b - 1\n        edge[a].append((c, b))\n        edge[b].append((c, a))\n\n    Q, K = in_nn()\n    d = dijkstra(N, K - 1, edge)\n\n    ans = []\n    for i in range(Q):\n        x, y = in_nn()\n        x, y = x - 1, y - 1\n        ans.append(d[x] + d[y])\n\n    print(('\\n'.join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    a, b, c = map(int, input().split())\n    g[a-1].append((b-1,c))\n    g[b-1].append((a-1,c))\n\nq, k = map(int, input().split())\nds = [-1]*n\nhq = [(0,k-1)]\nwhile hq:\n    c,idx = heapq.heappop(hq)\n    if ds[idx] != -1:\n        continue\n    ds[idx] = c\n    for i in g[idx]:\n        if ds[i[0]] == -1:\n            heapq.heappush(hq,(i[1]+c,i[0]))\n\nfor i in range(q):\n    x, y = map(int, input().split())\n    print(ds[x-1]+ds[y-1])", "import collections\n\nn = int(input())\nroute = {i + 1 : {} for i in range(n)}\nfor i in range(n - 1):\n    a, b, c = map(int, input().split())\n    route[a][b] = c\n    route[b][a] = c\nq, k = map(int, input().split())\nqueue = collections.deque([k])\nlength = [0] * (n + 1)\nwhile queue:\n    search = queue.popleft()\n    pairs = []\n    for i, j in route[search].items():\n        queue.append(i)\n        length[i] = length[search] + j\n        pairs.append([search, i])\n    for i, j in pairs:\n        del route[i][j]\n        del route[j][i]\nfor i in range(q):\n    x, y = map(int, input().split())\n    print(length[x] + length[y])", "def main():\n    N = int(input())\n    adj = [[] for _ in range(N)]\n    node = [0] * N\n    for _ in range(N-1):\n        a, b, c = list(map(int, input().split()))\n        adj[a-1].append((b-1, c))\n        adj[b-1].append((a-1, c))\n    \n    Q, K = list(map(int, input().split()))\n    K -= 1\n\n    # import\n    from collections import deque\n\n    que = deque([K])\n    check = set([K])\n    for _ in range(N*2):\n        u = que.popleft()\n        for v, c in adj[u]:\n            if v in check:\n                continue\n            node[v] = node[u] + c\n            que.append(v)\n            check.add(v)\n        if len(que) == 0:\n            break\n    \n    for _ in range(Q):\n        x, y = list(map(int, input().split()))\n        ans = node[x-1] + node[y-1]\n        print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\nN = int(input())\ntree = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b, c = list(map(int, input().split()))\n    tree[a-1].append([b-1, c])\n    tree[b-1].append([a-1, c])\nQ, K = list(map(int, input().split()))\n\ndist = [-1] * N\ndef dfs(v, total_cost):\n    # v\uff1a\u9802\u70b9, total_cost\uff1a\u4eca\u307e\u3067\u304b\u304b\u3063\u305f\u30b3\u30b9\u30c8\u306e\u5408\u8a08\n    dist[v] = total_cost\n    for v_next, cost in tree[v]:\n        if dist[v_next] >= 0:\n            continue\n            # v_next\u304c\u8a2a\u554f\u6e08\u307f\u306a\u3089\u30b9\u30ad\u30c3\u30d7\n        dfs(v_next, total_cost+cost)\n\ndfs(K-1, 0)\n\nfor i in range(Q):\n    x, y = list(map(int, input().split()))\n    print((dist[x-1] + dist[y-1]))\n", "from collections import deque\nn=int(input())\nnum=[[] for _ in range(n)]\nfor i in range(n-1):\n    a,b,c=list(map(int,input().split()))\n    num[a-1].append([b,c])\n    num[b-1].append([a,c])\nq,k=list(map(int,input().split()))\nseen=[False]*n\nqueue=deque()\nqueue.append(k)\nans=[0]*n\nseen[k-1]=True\nfor i in range(n):\n    if len(queue)==0:\n        break\n    num1=queue.popleft()\n    for j in range(len(num[num1-1])):\n        num2=num[num1-1][j][0]\n        if seen[num2-1]==False:\n            queue.append(num2)\n            seen[num2-1]=True\n            ans[num2-1]=ans[num1-1]+num[num1-1][j][1]\nfor i in range(q):\n    x,y=list(map(int,input().split()))\n    print((ans[x-1]+ans[y-1]))\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nfrom collections import deque\n\n\n# In[6]:\n\n\nN = int(input())\nt = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b,c = list(map(int, input().split()))\n    t[a-1].append([b,c])\n    t[b-1].append([a,c])\n\n\n# In[7]:\n\n\nQ,K = list(map(int, input().split()))\n\n\n# In[8]:\n\n\nvisited = [-1 for _ in range(N)]\nvisited[K-1] = 0\nque = deque()\nque.append(K)\nwhile len(que):\n    now = que.popleft()\n    for nxt,c in t[now-1]:\n        if visited[nxt-1] != -1:\n            continue\n        visited[nxt-1] = visited[now-1]+c\n        que.append(nxt)\nfor i in range(Q):\n    x,y = list(map(int, input().split()))\n    print((visited[x-1]+visited[y-1]))\n\n\n# In[ ]:\n\n\n\n\n", "from collections import deque\n\nN = int(input())\nabc = [list(map(int, input().split())) for _ in range(N-1)]\nq, K = map(int, input().split())\n\ngraph = [[] for i in range(N+1)]\nfor i,j,k in abc:\n    graph[i].append((j,k))\n    graph[j].append((i,k))\n    \nr = [-1 for i in range(N+1)] \nQ = deque()\nQ.append(K)\nr[K] = 0\n\nwhile Q:\n    x = Q.popleft()\n    for to, dis in graph[x]:\n        if r[to] == -1:\n            r[to] = r[x] + dis\n            Q.append(to)\n            \nfor _ in range(q):\n    x, y = map(int, input().split())\n    print(r[x] + r[y])", "from collections import deque\n\nn = int(input())\ne = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b, c = map(int,input().split())\n    a -= 1\n    b -= 1\n    e[a].append([b, c])\n    e[b].append([a, c])\n\nm, k = map(int,input().split())\nk -= 1\n\nd = [-1] * n\nd[k] = 0\nq = deque()\nq.append([k, 0])\nwhile q:\n    f, cc = q.pop()\n    for t, nc in e[f]:\n        if d[t] == -1:\n            d[t] = cc + nc\n            q.append([t, d[t]])\n\nfor i in range(m):\n    f, t = map(int,input().split())\n    f -= 1\n    t -= 1\n    print(d[f] + d[t])", "N=int(input())\nlinks=[[] for _ in range(N+1)]\nfor _ in range(N-1):\n  a, b, c=map(int, input().split())\n  links[a].append([b, c])\n  links[b].append([a, c])\n  \nQ, K=map(int, input().split())\n\nlength=[-1]*(N+1)\nlength[K]=0\n\nimport heapq\nq=[[tmp[1], tmp[0], K] for tmp in links[K]]\nheapq.heapify(q)\nwhile q:\n  tmp=heapq.heappop(q)\n  length[tmp[1]]=tmp[0]+0\n  for x in links[tmp[1]]:\n    if tmp[2]!=x[0]:\n      heapq.heappush(q, [tmp[0]+x[1], x[0], tmp[1]])\n\nfor _ in range(Q):\n  x, y=map(int, input().split())\n  print(length[x]+length[y])", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import product, accumulate, combinations, product\n#import bisect\n#import numpy as np\n#from copy import deepcopy\n#from collections import deque\n#from decimal import Decimal\n#from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 10 ** 9 + 7\ndef intread():\n    return int(sysread())\ndef mapline(t = int):\n    return list(map(t, sysread().split()))\ndef mapread(t = int):\n    return list(map(t, read().split()))\n\ndef dfs(current, to, dists):\n    c, c_cost = current\n    dists[c] = c_cost\n    for n, n_cost in to[c]:\n        if dists[n] == -1:\n            dfs((n, c_cost + n_cost), to, dists)\n    return dists\n\n\ndef run():\n    N = intread()\n    to = [[] for _ in range(N+1)]\n    for i in range(N-1):\n        a,b,c = mapline()\n        to[a].append((b, c))\n        to[b].append((a, c))\n    Q, K = mapline()\n\n    dists = [-1] * (N+1)\n    dists = dfs((K, 0), to, dists)\n    for i in range(Q):\n        x,y= mapline()\n        print((dists[x] + dists[y]))\n\ndef __starting_point():\n    run()\n\n__starting_point()", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b, c = map(int, readline().split())\n        G[a - 1].append((b - 1, c))\n        G[b - 1].append((a - 1, c))\n\n    Q, K, *XY = map(int, read().split())\n    K -= 1\n\n    stack = deque([K])\n    dist = [INF] * N\n    dist[K] = 0\n    while stack:\n        v = stack.pop()\n        for nv, cost in G[v]:\n            if dist[nv] == INF:\n                dist[nv] = dist[v] + cost\n                stack.append(nv)\n\n    ans = [0] * Q\n    for i, (x, y) in enumerate(zip(*[iter(XY)] * 2)):\n        ans[i] = dist[x - 1] + dist[y - 1]\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    G = {}\n    for i in range(n):\n        G[i+1] = []\n    for _ in range(n-1):\n        a,b,c = list(map(int,input().split()))\n        G[a] += [[b,c]]\n        G[b] += [[a,c]]\n    q,k = list(map(int,input().split()))\n    dist = [-1]*n\n    dist[k-1] = 0\n    que = [k]\n    while len(que) > 0:\n        s = que.pop(0)\n        for [nv,c] in G[s]:\n            if dist[nv-1] != -1:\n                continue\n            dist[nv-1] = dist[s-1]+c\n            que.append(nv)\n    for _ in range(q):\n        x,y = list(map(int,input().split()))\n        print((dist[x-1]+dist[y-1]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\nN=int(input())\nl=[-1]*N\ntree=[[] for i in range(N)]\nfor i in range(N-1):\n   A,B,C=list(map(int,input().split()))\n   A-=1;B-=1\n   tree[A].append((B,C))\n   tree[B].append((A,C))\nQ,V=list(map(int,input().split()))\ndef DFS(now,past,dis):\n   l[now]=dis\n   for i in tree[now]:\n      if i[0]==past:\n         continue\n      elif l[i[0]] == -1:\n         DFS(i[0],now,dis+i[1])\nDFS(V-1,-1,0)\nfor i in range(Q):\n   s,e=list(map(int,input().split()))\n   s-=1;e-=1\n   print(l[s]+l[e])", "import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\nd = [-1 for i in range(n)]\ne = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b, c = map(int, input().split())\n    e[a - 1].append([b - 1, c])\n    e[b - 1].append([a - 1, c])\nq, k = map(int, input().split())\ndef dfs(cur, par, di):\n    d[cur] = di\n    for i in e[cur]:\n        if d[i[0]] == -1:\n            if i == par:\n                continue\n            dfs(i[0], cur, di + i[1])\ndfs(k - 1, -1, 0)\nfor i in range(q):\n    x, y = map(int, input().split())\n    print(d[x - 1] + d[y - 1])", "# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\nfrom heapq import heappop, heappush\n\nN = int(input())\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b, c = list(map(int, input().split()))\n    links[a].append((b, c))\n    links[b].append((a, c))\n\nQ, K = list(map(int, input().split()))\n\nd = [float('inf')] * (N + 1)\nd[K] = 0\n#prev = [None] * (N + 1)\nq = [(0, K)]\nwhile q:\n    _, u = heappop(q)\n    for v, c in links[u]:\n        alt = d[u] + c\n        if d[v] > alt:\n            d[v] = alt\n            #prev[v] = u\n            heappush(q, (alt, v))\n\nresult = []\nfor _ in range(Q):\n    x, y = list(map(int, input().split()))\n    result.append(d[x] + d[y])\n#print(*result, sep='\\n')\nprint(('\\n'.join(str(v) for v in result)))\n", "import sys  \nsys.setrecursionlimit(200000)\n\nN = int(input())\nadj = {}\n\nadj = {i+1: [] for i in range(N)}\n\nfor i in range(N-1):\n    a, b, c = map(int, input().split())\n\n    adj[a].append((b, c))\n    adj[b].append((a, c))\n\ndis = [0] * N\n\ndef dfs(k, u, d):\n    \"\"\"\n    u: k\u306e\u89aa\n    d: v\u3068u\u306e\u6700\u77ed\u8ddd\u96e2\n    adj_v: v\u306e\u96a3\u63a5\n    \u3053\u308c\u3089\u306e\u3058\u3087\u3046\u3051\u3093\u306e\u3082\u3068\u3067dis\u3092\u66f4\u65b0\u3059\u308b\n    \"\"\"\n    dis[k-1] = d\n\n    for p, pk_dis in adj[k]:\n        if p != u:\n            dfs(p, k, d+pk_dis)\n\nQ, K = map(int, input().split())\ndfs(K, -1, 0)\n\nfor i in range(Q):\n  x, y = map(int, input().split())\n  print(dis[x-1] + dis[y-1])"]
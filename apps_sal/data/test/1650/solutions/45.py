"""

AtCoder Beginner Contest 129  E - Sum Equals Xor

XORは桁上がりがないので、A xor B がA+Bより大きくなることはない（最大でもA+Bまで）
なので、 A xor B = A + B が成立するのは、AとBを二進数でみたときに、両方1が立っているbitがないこと。

桁DPの文脈で考えると、
dp1,2[i] : AやBの左からi文字目までを決めたときに、
・dp2 : その時点でのA+BがL以下になることがわかっている（左からi番目までについて、A+Bのp桁目は0だが、Lのp桁目は1、みたいなのが存在する（先頭～p-1までは一致してもしなくてもOK））AとBの組の個数
・dp1 : その時点ではA+BがL以下になるか分からないAとBの組の個数（その時点まではLのi桁目までと一致する組の数）



遷移について、
Lのi桁目が
・0の場合
 - dp1 : dp2から遷移するとL以下になることが確定するので、dp2から遷移してくることはない＆A+Bのiビット目に1が立つとLを上回るので、0になるしかなく、i桁目は両方0の１通りで遷移
 - dp2 : dp1から遷移してきてi番目に0をいれても、L以下になるか確定しないので、dp1からの遷移はない。一方で。dp2から遷移してくる場合、既にL以下であることが確定しているので、A,B = 1,1以外の３パターンをとれる
・1の場合
 - dp1 : dp2から遷移してくるのを考えると、dp2の時点で既にL以下になるのが確定しているので、dp2からは遷移できない。一方で、dp1から遷移してくる場合、i桁目までLと同じになるので、A,Bの一方が1で他方が0の２通りをとれる
 - dp2 : dp1から遷移して A,B=0,0 をとればL以下が確定＆dp2から遷移して 1,1 以外の3通りの遷移

"""
L = input()
N = len(L)
MOD = 10 ** 9 + 7
dp1 = [0] * (N + 1)
dp2 = [0] * (N + 1)
dp1[0] = 1
for i in range(N):
    if L[i] == '0':
        dp1[i + 1] = dp1[i]
        dp2[i + 1] = dp2[i] * 3
    else:
        dp1[i + 1] = dp1[i] * 2
        dp2[i + 1] = dp2[i] * 3 + dp1[i]
    dp1[i + 1] %= MOD
    dp2[i + 1] %= MOD
print((dp1[-1] + dp2[-1]) % MOD)

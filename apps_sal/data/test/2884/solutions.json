["class Solution:\n     def combinationSum2(self, candidates, target):\n                 \n         def dfs(i, val, path):\n             while i < len(candidates):\n                 num = candidates[i]\n                 val_ = val + num\n                 path_ = path + [num]\n                 if val_ > target:\n                     return\n                 elif val_ == target:\n                     ans.append(path_)\n                     return                  \n                 dfs(i+1, val_, path_)\n                 while i<len(candidates)-1 and candidates[i]==candidates[i+1]:\n                     i += 1\n                 i += 1\n                \n         candidates = sorted(candidates)\n         ans = []\n         dfs(0, 0, [])\n         return ans", "\n class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if len(candidates)==0:\n             return []\n \n \n         candidates = sorted(candidates)\n         print(candidates)\n \n         results = []\n \n \n         def find(curr_comb, curr_sum, candidates): #\u9760\u526f\u4f5c\u7528\u586b\u5145results\n             #curr_comb = curr_comb[:]\n             for i,cand in enumerate(candidates):\n \n                 if (cand+curr_sum) < target:\n                     new_curr_comb = curr_comb[:]\n                     new_curr_comb.append(cand)\n                     find(new_curr_comb, curr_sum+cand, candidates[i+1:])\n                 elif (cand+curr_sum) == target:\n                     new_curr_comb = curr_comb[:]\n                     new_curr_comb.append(cand)\n                     if new_curr_comb not in results:\n                         results.append(new_curr_comb)\n                     #print(curr_comb, curr_sum, cand, 'target:',target)\n                 else:\n                     break\n \n \n         find([], 0, candidates)\n \n         return results", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if not candidates:\n             return []\n         result = []\n         candidates.sort()\n         self.dfs(result, [], 0, target, candidates)\n         return result\n     \n     def dfs(self, result, combin, start, target, candidates):\n         if target == 0:\n             result.append([i for i in combin])\n         else:\n             for index in range(start, len(candidates)):\n                 if candidates[index] > target:\n                     break\n                 if (index > start and candidates[index] == candidates[index - 1]):\n                     continue\n                 combin.append(candidates[index])\n                 self.dfs(result, combin, index + 1, target - candidates[index], candidates)\n                 combin.pop()\n", "class Solution:\n     def combinationSum2(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def dfs(a, i, target):\n             for j in range(i, len(nums)):\n                 if target <= nums[j]:\n                     if target == nums[j]:\n                         ans.append(a+[nums[j]])\n                     break\n                 if i == j or nums[j] != nums[j-1]:\n                     dfs(a+[nums[j]], j+1, target-nums[j])\n \n         ans = []\n         nums.sort()\n         dfs([], 0, target)\n         return ans\n", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def helper(L, target, path, ans):\n             if target == 0:\n                 ans.append(path)\n                 return\n             for i in range(len(L)):\n                 if L[i] > target:\n                     return\n                 if i > 0 and L[i] == L[i-1]:\n                     continue\n                 helper(L[i+1:], target-L[i], path+[L[i]], ans)\n         \n         ans = []\n         helper(sorted(candidates), target, [], ans)\n         return ans", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         res = []\n         candidates.sort()\n         self.dfs(candidates,target,0,[],res)\n         return res\n #60%\n     \n     def dfs(self,nums,target,index,path,res):\n         if target<0:\n             return \n         if target == 0:\n             res.append(path)\n             return \n         for i in range(index,len(nums)):\n             if i>index and nums[i] == nums[i-1]:\n                 continue\n             if nums[i] > target:    #   \u63d0\u5347\u523093%\n                 break\n             self.dfs(nums,target-nums[i],i+1,path+[nums[i]],res)", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         result=[]\n         def combinationSumRecu(self,candidates,target,start,intermediate,result):\n             if target==0:\n                 result.append(list(intermediate))\n             while start<len(candidates) and candidates[start]<=target:\n                 intermediate.append(candidates[start])\n                 combinationSumRecu(self,candidates,target-candidates[start],start+1,intermediate,result)\n                 start+=1\n                 intermediate.pop()\n                 while start>0 and start<len(candidates) and candidates[start]==candidates[start-1]:\n                     start+=1\n                     \n                 \n         \n         combinationSumRecu(self,sorted(candidates),target,0,[],result)\n         return result", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         dp = [None] + [set() for i in range(target)]\n         candidates.sort()\n         for i in candidates:\n             if i > target:\n                 break\n             for j in range(target-i,0,-1):\n                 dp[i+j] |= {_ + (i,) for _ in dp[j]}\n             dp[i].add((i,))\n         return list(dp[-1])", "class Solution:\n     def find(self,candidates,result,current,target,pos,num,current_num):\n         if target==0:\n             temp = current[:]\n             result.append(temp)\n         else:\n             for i in range(pos,len(candidates)):\n                 n = str(candidates[i])\n                 if candidates[i]>target or num[n]<current_num[n]:\n                     break\n                 if num[n]==current_num[n]:\n                     continue\n                 current.append(candidates[i])\n                 current_num[n] +=1\n                 self.find(candidates,result,current,target-candidates[i],i,num,current_num)\n                 value = current.pop()\n                 current_num[str(value)] -=1\n \n     def combinationSum2(self,candidates, target):\n         result = []\n         current =[]\n         candidates.sort()\n         can = candidates[:]\n         count = 0;\n         num = {}\n         current_num={}\n         for i in range(len(candidates)):\n             if i==0 or candidates[i]!=candidates[i-1]:\n                 num[str(candidates[i])]=1\n                 current_num[str(candidates[i])]=0\n                 continue\n             else:\n                 num[str(candidates[i])]+=1\n                 del can[i-count]\n                 count +=1\n         self.find(can,result,current,target,0,num,current_num)\n         return result\n", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def produce(nums, target, current, output):\n             if target == 0:\n                 output.append(list(current))\n                 return\n             for i, n in enumerate(nums):\n                 if n > target: continue\n                 # avoid duplicate solutions\n                 if i > 0 and nums[i] == nums[i-1]: continue\n                 current.append(n)\n                 # each num can be used only once: nums[i+1:]\n                 produce(nums[i+1:], target - n, current, output)\n                 current.pop()\n \n         output = []\n         candidates.sort()\n         produce(candidates, target, [], output)\n         return output", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         sortedCandidates = sorted(candidates)\n         if len(candidates) == 0 or target < sortedCandidates[0]:\n             return []\n         if target == sortedCandidates[0]:\n             return [[sortedCandidates[0]]]\n         resultWith0 = self.combinationSum2(sortedCandidates[1:], target - sortedCandidates[0])\n         nextIndex = 0\n         while nextIndex < len(candidates) and sortedCandidates[nextIndex] == sortedCandidates[0]:\n             nextIndex += 1\n         \n         resultNo0 = self.combinationSum2(sortedCandidates[nextIndex:], target)\n         \n         return [[sortedCandidates[0]] + item for item in resultWith0] + resultNo0", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def backtracing(nums,target,idx,path,ret):\n             if not target :\n                 if path not in ret :\n                     ret.append(path)\n             for i in range (idx,len(nums)):\n                 if nums[i] > target :\n                     break\n                 backtracing(nums,target-nums[i],i+1,path+[nums[i]],ret)\n         candidates.sort()\n         ret = []\n         backtracing(candidates,target,0,[],ret)\n         return ret", "class Solution:\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         def combination(candidates, k, target, res, result):\n             for i in range(k,len(candidates)):\n                 if target == candidates[i]:\n                     temp = [j for j in res]\n                     temp.append(candidates[i])\n                     temp.sort()\n                     if temp not in result:\n                         result.append(temp)\n                     return\n                 elif target < candidates[i]:\n                     return\n                 else:\n                     res.append(candidates[i])\n                     combination(candidates, i+1, target - candidates[i], res, result)\n                     res.pop()\n \n         candidates.sort()\n         res = []\n         result = []\n         combination(candidates, 0, target, res, result)\n         return(result)", "class Solution(object):\n     def combinationSum2(self, candidates, target):\n         \"\"\"\n         :type candidates: List[int]\n         :type target: int\n         :rtype: List[List[int]]\n         \"\"\"\n         result = []\n         temp = []\n         candidates.sort(reverse=True)\n \n         self.util(candidates, target, result, temp)\n         return result       \n \n     def util(self, nums, target, result, temp):\n \n         for i in range(len(nums)): \n             if nums[i] == target and (temp + [nums[i]] not in result):\n                 result.append(temp + [nums[i]])\n             elif nums[i] < target:\n                 self.util(nums[i + 1:], target - nums[i], result, temp + [nums[i]])\n \n         return "]
["import sys\n\n\ndef __starting_point():\n    cin = sys.stdin\n\n    n = int(next(cin))\n    a = list(map(int, next(cin).split()))\n\n    n2idx = {a[i]: i for i in range(n)}\n\n    f = [False] * (n+1)\n\n    for i in range(n, 0, -1):\n        idx_lg = n2idx[i]\n\n        win_flag = False\n        for j in range(idx_lg%i, n, i):\n            if a[j] > i and not f[a[j]]:\n                win_flag = True\n                break\n        f[i] = win_flag\n        \n    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])\n    print(f, flush=True)\n\n__starting_point()", "n = int(input())\nboard = list(map(int,input().split(\" \")))\nindex = list(range(0,n))\nascending = [x for _,x in sorted(zip(board,index))]\n\nwinners = n * [\"\"]\n\n\nfor c in reversed(ascending):\n\tif board[c] == n:\n\t\twinners[c] = \"B\"\n\t# going down\n\ttoCheck = c - board[c]\n\twhile(toCheck >= 0):\n\t\tif winners[toCheck] == \"B\":\n\t\t\twinners[c] = \"A\"\n\t\ttoCheck = toCheck - board[c]\n\tif winners[c] == \"\":\n\t\ttoCheck = c + board[c]\n\t\twhile(toCheck < n):\n\t\t\tif winners[toCheck] == \"B\":\n\t\t\t\twinners[c] = \"A\"\n\t\t\ttoCheck = toCheck + board[c]\n\tif winners[c] == \"\":\n\t\twinners[c] = \"B\"\n\t#print(\"board at c\",board[c])\n\t#print(c)\n\t#print(winners)\n\nfor i in range(n):\n\tprint(winners[i],end=\"\")\nprint()\n\t\t\n\t\n\n", "n=int(input())\nl=[-1 for i in range(n+1)]\ns=input().split()\nll=[int(i) for i in s]\nfor i in range(n):\n    j=ll[i]\n    l[j]=i\nres=[\".\" for i in range(n+1)]\nres[n]=\"B\"\nfor i in range(n-1,0,-1):\n    toadd=\"B\"\n    pos=l[i]%i\n    while pos<n:\n        j=ll[pos]\n        if j<=i:\n            pos+=i\n            continue\n        if abs(l[i]-l[j])%i==0 and res[j]==\"B\":\n            toadd=\"A\"\n            break\n        pos+=i\n    res[i]=toadd\nfor i in ll:\n    print(res[i],end=\"\")\nprint(\"\")\n", "n=int(input())\nL=list(map(int,input().split()))\nans=['']*n\nrevL=[0]*n\nans[-1]='B'\nfor i in range(n):\n    revL[L[i]-1]=i+1\nfor i in range(n-2,-1,-1):\n    t=revL[i]-1\n    counter='B'\n    for j in range(t,-1,-i-1):\n        if j==t:continue\n        if ans[L[j]-1]=='B':\n            counter='A'\n            break\n    if counter!='A':\n        for k in range(t,n,i+1):\n            if k==t:continue\n            if ans[L[k]-1]=='B':\n                counter='A'\n                break\n    ans[i]=counter\nfor i in range(n):\n    print(ans[L[i]-1],sep='',end='')", "n = int(input())\na = [int(i) for i in input().split()]\nindx = [0] * n\nwinners = [''] * n\n\nfor i, ai in enumerate(a):\n    indx[ai-1] = i\n\nfor ai in range(n, 0, -1):\n    i = indx[ai-1]\n    can_win = False\n\n    for j in range(i + ai, n, ai):\n        if a[j] > ai and 'B' == winners[j]:\n            can_win = True\n            break\n\n    if not can_win:\n        for j in range(i - ai, -1, -ai):\n            if a[j] > ai and 'B' == winners[j]:\n                can_win = True\n                break\n\n    if can_win:\n        winners[i] = 'A'\n    else:\n        winners[i] = 'B'\n\nprint(''.join(winners))\n", "import sys\n\nnext(sys.stdin)\n\npositions = {}\npos2x = {}\nfor i, x in enumerate(next(sys.stdin).split()):\n    x = int(x)\n    positions[x] = i\n    pos2x[i] = x\n\nanswers = ['' for _ in range(len(positions))]\n\nfor x in range(len(positions), 0, -1):\n\n    position = positions[x]\n\n    def can_go_to_looser():\n\n        next_position = position + x\n        while next_position < len(positions):\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position += x\n\n        next_position = position - x\n        while next_position >= 0:\n\n            if pos2x[next_position] > x and answers[next_position] == \"B\":\n                return True\n\n            next_position -= x\n\n        return False\n\n    if can_go_to_looser():\n        answers[position] = \"A\"\n    else:\n        answers[position] = \"B\"\n\nprint(''.join(answers))\n", "n = int(input())\n\narr = list(map(int, input().split()))\n\nmemo = [-1 for i in range(n+1)]\ndef can_win(idx):\n\tif memo[idx] != -1: return memo[idx]\n\tres = False\n\n\tdelta = arr[idx]\n\t# right\n\tnidx = idx + delta\n\twhile nidx < n:\n\t\tif arr[nidx] > arr[idx] and not can_win(nidx):\n\t\t\tres = True\n\t\t\tbreak\n\t\tnidx += delta\n\n\t#left\n\tnidx = idx - delta\n\twhile not res and nidx >= 0:\n\t\tif arr[nidx] > arr[idx] and not can_win(nidx):\n\t\t\tres = True\n\t\t\tbreak\n\t\tnidx -= delta\n\n\tmemo[idx] = res\n\treturn res\n\nans = ['A' if can_win(i) else 'B' for i in range(n)]\nprint(''.join(ans))\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nPLACE=[None]*(n+1)\nfor i in range(n):\n    PLACE[A[i]]=i\n\nal=n\n\n\nWINLIST=[None]*(n+1)#0:\u305d\u3053\u306b\u884c\u3051\u3070\u5fc5\u6557,1:\u305d\u3053\u306b\u3044\u3051\u3070\u5fc5\u52dd\n\ndef move(n,al):\n    place=PLACE[n]\n    for i in range(place,-1,-n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return\n            \n    for i in range(place,al,n):\n        if A[i]>n and WINLIST[A[i]]==\"B\":\n            WINLIST[n]=\"A\"\n            return \n\n    else:\n        WINLIST[n]=\"B\"\n        return \n   \n\nfor j in range(n,0,-1):\n    move(j,al)\n\n\nANS=\"\"\nfor i in A:\n    ANS+=WINLIST[i]\n\nprint(ANS)\n", "n=int(input())\narr=[int(x) for x in input().split()]\npos=dict()\nif(n==1):print(\"B\")\nelse:\n    for i in range(n):\n        pos[arr[i]]=i\n    ans=[\"Q\"]*n\n  \n    ans[pos[1]]=\"A\"\n    ans[pos[n]]=\"B\"\n    for i in range(n-1,0,-1):\n        flag=0\n        p=pos[i]\n        j=1\n        while(p+j*i<n):\n            if(ans[p+j*i]==\"B\"):\n                flag=1\n                ans[pos[i]]=\"A\"\n                break\n            j+=1\n        if(flag==0):\n            j=1\n            while(p-j*i>=0):\n                if(ans[p-j*i]=='B'):\n                    flag=1\n                    ans[pos[i]]=\"A\"\n                    break\n                j+=1\n        if(flag==0):ans[pos[i]]=\"B\"\n    print(\"\".join(ans))\n        \n\n", "n = int(input())\na = [int(s) for s in input().split()]\nans = [None]*n\n\ndef get(p):\n    # print(ans)\n    if ans[p] is not None:\n        return ans[p]\n    elif a[p] == 1:\n        ans[p] = \"A\"\n    elif a[p] == n:\n        ans[p] = \"B\"\n    else:\n        for i in range(p+a[p], n, a[p]):\n            if a[i] > a[p]:\n                if get(i) == \"B\":\n                    ans[p] = \"A\"\n                    return ans[p]\n        for i in range(p-a[p], -1, -a[p]):\n            if a[i] > a[p]:\n                if get(i) == \"B\":\n                    ans[p] = \"A\"\n                    return ans[p]\n        ans[p] = \"B\"\n    return ans[p]\n\nif n == 1:\n    print(\"B\")\nelse:\n    for i in range(n-1, -1, -1):\n        get(i)\n    print(''.join(ans))", "n = int(input())\nl = [0]+list(map(int,input().split()))\nfrom collections import defaultdict\nans = ['A','B']\nx = defaultdict(int)\ntable = [-1]*(n+1)\nfor i in range(1,n+1):\n\tx[l[i]] = i\n\ntable[x[n]] = 1\nfor i in range(n-1,0,-1):\n\tif(x[i]-i>0):\n\t\tfor j in range(x[i],0,-i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\tif(n-i>0 and table[x[i]]==-1):\n\t\tfor j in range(x[i],n+1,i):\n\t\t\tif(l[j]>i):\n\t\t\t\tif(table[j]==1):\n\t\t\t\t\ttable[x[i]] = 0\n\t\t\t\t\tbreak\n\n\tif(table[x[i]]==-1):\n\t\ttable[x[i]] = 1\n\nfor i in table[1:]:\n\tprint(ans[i],end='')", "from operator import itemgetter\nn = int(input())\nai = list(map(int,input().split()))\nai2 = [[ai[i], i] for i in range(n)]\nanswer = [0] * n\nai2.sort(key = itemgetter(0))\nanswer[ai2[0][1]] = 1\nanswer[ai2[-1][1]] = 0\nfor i in range(n-2,0,-1):\n    num = ai2[i][1] % ai2[i][0]\n    for j in range(num,n,ai2[i][0]):\n        if ai[j] > ai2[i][0] and answer[j] == 0:\n            answer[ai2[i][1]] = 1\n            break\nfor i in range(n):\n    if answer[i] == 1:\n        print(\"A\",end=\"\")\n    else:\n        print(\"B\",end=\"\")\n", "a = int(input())\nlister = input().split()\nlister = [int(i) for i in lister]\n\nans = dict()\n\t\ndef findans(n):\n\tif n in ans:\n\t\treturn ans[n]\n\tmod = n%lister[n]\n\tok = True\n\tif n + lister[n] >= a and n - lister[n] < 0:\n\t\tok = False\n\telse:\n\t\tfor i in range(mod, a, lister[n]):\n\t\t\tif i != n and lister[i] > lister[n]:\n\t\t\t\tok = ok and findans(i) \n\t\t\t\t\n\t\tok = not(ok)\n\t\t\n\tans[n] = ok\n\treturn ok\n\t\nfor i in range(len(lister)):\n\tfindans(i)\n\t\nlevel = []\nfor i in range(a):\n\tif ans[i] == True:\n\t\tlevel.append('A')\n\telse:\n\t\tlevel.append('B')\n\t\t\nprint(''.join(level))", "# from collections import deque\n\nn = int(input())\na = [int(x) for x in input().split()]\n\na_reverse = a.copy()\nstatus = []\nfor i in range(n):\n    a_reverse[a[i]-1] = i\n    status.append(None)\n\n\npos = a_reverse[n-1]\nstatus[pos] = False\nfails = set()\nfails.add(pos)\nfor i in range(n-1,0,-1):\n    i_ = i-1\n    pos = a_reverse[i_]\n    for k in range((pos+1)%i-1,n,i):\n        if k == pos:\n            continue\n        if k in fails:\n            status[pos] = True\n            break\n    if not status[pos]:\n        status[pos] = False\n        fails.add(pos)\n\n\n# BAAAABAB\n# ABAAAABBBAABAAB\n\n\n# status = []\n# for i in range(n):\n#     status.append(None)\n\n# queue = deque()\n\n# def eval_(pos):\n#     pos_status = status[pos]\n#     for i in range(n):\n#         if i == pos:\n#             continue\n#         if status[i] != None:\n#             continue\n#         if  a[i] > a[pos]:\n#             continue\n#         if (abs(i - pos) % a[i]) == 0:\n#             status[i] = not pos_status\n#             queue.append(i)\n\n# pos = a.index(n)\n# status[pos] = False\n# queue.append(pos)\n#\n# while len(queue) != 0:\n#     item = queue.popleft()\n#     eval_(item)\n#\n# print(status)\n#\nresult = \"\"\nfor i in status:\n    if i == True:\n        result=result+\"A\"\n    else:\n        result=result+\"B\"\n\nprint(result)\n\n\n\n\n", "from math import ceil\n\nn=int(input())\nr=list(map(int,input().split()))\nl=[-1]\nl.extend(r)\na=['']*(n+1)\nd={}\nrd={}\nind={}\nfor i in range(1,n+1):\n    x=l[i]\n    ind[x]=i\n    d.setdefault(i,[])\n    s=x+i\n    while s<=n:\n        if l[s]>x:\n            d[i].append(s)\n            if s not in rd:\n                rd[s]=[]\n            rd[s].append(i)\n        s+=x\n    s = i-x\n    while s >=1:\n        if l[s] > x:\n            d[i].append(s)\n        s -= x\n\nans=0\n\nfor i in d:\n    if len(d[i])==0:\n        a[i]='B'\n        ans+=1\n#print(a)\n#print(d[5])\nwhile ans!=n:\n    for i in d:\n        dont=False\n        if a[i]!='':\n            continue\n        for j in d[i]:\n            if a[j]=='B':\n                a[i]='A'\n                ans+=1\n                break\n            if a[j]=='':\n                dont=True\n        else:\n            if not dont:\n                a[i]='B'\n                ans+=1\n #   print(a)\nprint(''.join(a))", "from collections import deque\nfrom sys import stdin\nlines = deque(line.strip() for line in stdin.readlines())\n\ndef nextline():\n    return lines.popleft()\n\ndef types(cast, sep=None):\n    return tuple(cast(x) for x in strs(sep=sep))\n\ndef ints(sep=None):\n    return types(int, sep=sep)\n\ndef strs(sep=None):\n    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))\n\ndef main():\n    # lines will now contain all of the input's lines in a list\n    n = int(nextline())\n    a = ints()\n    bs = set()\n    moves = {}\n    for i in range(n):\n        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])\n    winners = {}\n    for i in range(n, 0, -1):\n        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'\n        if winner == 'B':\n            bs.add(i)\n        winners[i] = winner\n    print(''.join(winners[ai] for ai in a))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nboard = list(map(int, input().strip().split()))\nboard.insert(0,0)\nhashed = [0] * (n+1)\nfor i in range(n+1):\n\thashed[board[i]] = i\nanswer = ['C'] * (n+1)\nfor i in range(n,0,-1):\t\n\tflag = 0\n\tk = hashed[i] - board[hashed[i]]\n\twhile(k > 0):\n\t\tif(answer[k] == 'B'):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tk-=board[hashed[i]]\n\tk = hashed[i] + board[hashed[i]]\n\twhile(k <= n and k != 0):\n\t\tif(answer[k] == 'B'):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tk+=board[hashed[i]]\n\tif(flag == 1):\n\t\tanswer[hashed[i]] = 'A'\n\telse:\n\t\tanswer[hashed[i]] = 'B'\nanswer.pop(0)\nprint(''.join(answer))\n", "n=int(input())\nl=[-1 for i in range(n+1)]\ns=input().split()\nll=[int(i) for i in s]\nfor i in range(n):\n    j=ll[i]\n    l[j]=i\nres=[\".\" for i in range(n+1)]\nres[n]=\"B\"\nfor i in range(n-1,0,-1):\n    toadd=\"B\"\n    pos=l[i]%i\n    while pos<n:\n        j=ll[pos]\n        if j<=i:\n            pos+=i\n            continue\n        if abs(l[i]-l[j])%i==0 and res[j]==\"B\":\n            toadd=\"A\"\n            break\n        pos+=i\n    res[i]=toadd\nfor i in ll:\n    print(res[i],end=\"\")\nprint(\"\")", "n = int(input())\na = [int(x) for x in input().split()]\nh = [-1]*(n)\nb = [(a[i],i) for i in range(n)]\nb.sort(reverse=True)\nfor e in b:\n\t# ~ print(e)\n\tnum,idx = e\n\tflag = True\n\tallNeg = True\n\tfoundLosing = False\n\tfoundWin = False\n\tfor i in range(idx%num,n,num):\n\t\t# ~ print(i)\n\t\tif i == idx:\n\t\t\tcontinue\n\t\tif h[i]!= -1:\n\t\t\tallNeg = False\n\t\tif h[i] == 0:\n\t\t\tfoundLosing = True\n\t\t\tbreak\n\t\tif h[i] == 1:\n\t\t\tfoundWin = False\n\tif allNeg:\n\t\th[idx] = 0\n\telif foundLosing:\n\t\th[idx] = 1\n\telse:\n\t\th[idx] = 0\t\n\t# ~ print(\" \".join(str(ss) for ss in h))\nfor i in range(n):\n\tif h[i]==0:\n\t\tprint('B',end='')\n\telse:\n\t\tprint('A',end='')\n\t\t\n# ~ print(h)\n", "n = int(input())\nl = [*map(int, input().split())]\n\np = [0] * n\nfor i in range(n): p[l[i] - 1] = i\n\nres = ['?'] * n\n\nfor e in range(n, 0, -1):\n    i = p[e - 1]\n    res[i] = 'B'\n    for j in range(i % e, n, e):\n        if i != j and l[i] <= l[j] and res[j] == 'B':\n            res[i] = 'A'\n            break \nprint(''.join(res))", "n=int(input())\na=[*list(map(int,input().split()))]\nb=[0]*n\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=list(range(i%x,n,x))\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))\n  \n \n", "n=int(input())\na=[*map(int,input().split())]\nb=[0]*n\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))", "n=int(input())\na=[*map(int,input().split())]\ns=[0]*n\nm=n\nwhile m:\n for i,x in enumerate(a):\n  if s[i]==0:\n   r=range(i%x,n,x)\n   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1\n   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1\nprint(''.join(s))"]
["from collections import defaultdict\n\nn, m, k = [int(x) for x in input().split()]\nc = [0] + [int(x) for x in input().split()]\ng = defaultdict(lambda: [])\nfor i in range(m):\n    l, r = [int(x) for x in input().split()]\n    g[l].append(r)\n    g[r].append(l)\ndone = [0] * (1 + n)\nans = 0\nfor i in range(n):\n    i += 1\n    if done[i]:\n        continue\n    q = [i]\n    p = 0\n    mn = set([i])\n    mcx = defaultdict(lambda: 0)\n    while p != len(q):\n        t = q[p]\n        p += 1\n        if done[t]:\n            continue\n        done[t] = 1\n        mcx[c[t]] += 1\n        mn.add(t)\n        for ne in g[t]:\n            q.append(ne)\n    fcol = None\n    maxn = -1\n    for col, num in list(mcx.items()):\n        if num >= maxn:\n            maxn = num\n            fcol = col\n    if fcol:\n        for ob in mn:\n            if c[ob] != fcol and len(g[ob]) > 0:\n                c[ob] = fcol\n                ans += 1\nprint(ans)\n", "import collections\nclass UnionFind:\n\n    def __init__(self, size):\n        # \u8ca0\u306e\u5024\u306f\u30eb\u30fc\u30c8 (\u96c6\u5408\u306e\u4ee3\u8868) \u3067\u96c6\u5408\u306e\u500b\u6570\n        # \u6b63\u306e\u5024\u306f\u6b21\u306e\u8981\u7d20\u3092\u8868\u3059\n        self.size = size\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        # \u96c6\u5408\u306e\u4ee3\u8868\u3092\u6c42\u3081\u308b\n        while self.table[x] >= 0:\n            if self.table[self.table[x]] >= 0:\n                self.table[x] = self.table[self.table[x]]\n            x = self.table[x]\n        return x\n\n    def union(self, x, y):\n        # \u4f75\u5408\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] >= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n        return self.table[s1]\n\n    def count_group(self):\n        count = 0\n        for i in range(self.size):\n            if self.table[i] < 0:\n                count += 1\n        return count\n\nn,m,k = map(int, input().split())\nc = [0] + list(map(int, input().split()))\nuf = UnionFind(n+1)\nuse = [False] * (n+1)\nfor i in range(m):\n    li,ri = map(int, input().split())\n    uf.union(li, ri)\n    use[li] = True\n    use[ri] = True\ngroups = {}\nfor i in range(1,n+1):\n    if not use[i]:\n        continue\n    g = uf.find(i)\n    if g not in groups:\n        groups.update({g:collections.defaultdict(int)})\n    groups[g][c[i]] += 1\ntotal = 0\nfor g in groups.values():\n    total += sum(g.values()) - max(g.values())\nprint(total)", "n, m, k = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\n\nnum = 0\nclusters = {}\nsocks = {}\n\nfor i in range(m):\n    l, r = [int(i) for i in input().split()]\n    if l not in socks and r not in socks:\n        socks[l] = num\n        socks[r] = num\n        clusters[num] = [l, r]\n        num += 1\n    elif l not in socks and r in socks:\n        socks[l] = socks[r]\n        clusters[socks[r]].append(l)\n    elif l in socks and r not in socks:\n        socks[r] = socks[l]\n        clusters[socks[l]].append(r)\n    elif socks[r] != socks[l]:\n        clusters[socks[l]] += clusters[socks[r]]\n        temp = socks[r] \n        for sock in clusters[socks[r]]:\n            socks[sock] = socks[l]\n        clusters.pop(temp)\n\nto_paint = 0\n\nfor i in clusters:\n    colors = {}\n    ma = 0\n    for sock in set(clusters[i]):\n        k = c[sock - 1]\n        if k in colors:\n            colors[k] += 1\n        else:\n            colors[k] = 1\n        if colors[k] > ma:\n            ma = colors[k]\n    to_paint += len(clusters[i]) - ma        \n\nprint(to_paint)", "def main():\n    from collections import defaultdict, Counter\n    n, m, k = list(map(int, input().split()))\n    n += 1\n    cc = [0, *list(map(int, input().split()))]\n    l = list(range(n))\n\n    def find(x):\n        while x != l[x]:\n            x = l[x]\n        return x\n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        u, v = find(a), find(b)\n        if u > v:\n            l[u] = v\n            while a != v:\n                a, l[a] = l[a], v\n        elif u < v:\n            l[v] = u\n            while b != u:\n                b, l[b] = l[b], u\n    groups = defaultdict(list)\n    for i, c in enumerate(cc):\n        l[i] = i = find(i)\n        groups[i].append(c)\n    for v in list(groups.values()):\n        n -= Counter(v).most_common(1)[0][1] if len(l) > 1 else 1\n    print(n)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from collections import defaultdict, Counter\n    n, m, k = list(map(int, input().split()))\n    n += 1\n    cc = [0, *list(map(int, input().split()))]\n    l = list(range(n))\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        u, v = a, b\n        while u != l[u]:\n            u = l[u]\n        while v != l[v]:\n            v = l[v]\n        if u > v:\n            l[u] = v\n            while a != v:\n                a, l[a] = l[a], v\n        elif u < v:\n            l[v] = u\n            while b != u:\n                b, l[b] = l[b], u\n    groups = defaultdict(Counter)\n    for i, g in enumerate(l):\n        if i != g:\n            l[i] = g = l[g]\n            groups[g][cc[i]] += 1\n    for g, v in list(groups.items()):\n        v[cc[g]] += 1\n    print(sum(sum(v.values()) - v.most_common(1)[0][1] for v in list(groups.values())))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from collections import Counter\n    n, m, _ = list(map(int, input().split()))\n    cc = list(map(int, input().split()))\n    pairs, avail = [[] for _ in range(n)], [True] * n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        pairs[a - 1].append(b - 1)\n        pairs[b - 1].append(a - 1)\n    for a, f in enumerate(avail):\n        if f:\n            stack, cnt, avail[a] = [a], Counter(), False\n            while stack:\n                a = stack.pop()\n                cnt[cc[a]] += 1\n                for b in pairs[a]:\n                    if avail[b]:\n                        avail[b] = False\n                        stack.append(b)\n            n -= cnt.most_common(1)[0][1]\n    print(n)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nn, m, k = [int(x) for x in sys.stdin.readline().replace('\\n', '').split(' ')]\nc =  [int(x) for x in sys.stdin.readline().replace('\\n', '').split(' ')]\n# print ((n,m,k))\n# Graphs with python\nsocks = [[] for _ in range(n)]\n# populate a Graph\nfor i in range(m):\n    l, r = [int(x)-1 for x in sys.stdin.readline().replace('\\n', '').split(' ')]\n    socks[r] += [l]\n    socks[l] += [r]\n# search a Graph\nvisited = [False for _ in range(n)]\nforest = {}\nfor i, v in enumerate(visited):\n    if v:\n        continue\n    visited[i] = True\n    queue = [(i, i)]\n    forest[i] = {'nodes': [i], 'colours': {c[i]: 1}}\n    while len(queue) != 0:\n        # print(queue)\n        representant, current = queue.pop()\n        for node in socks[current]:\n            if not visited[node]:\n                queue += [(representant, node)]\n                forest[representant]['nodes'] += [node]\n                if c[node] in forest[representant]['colours']:\n                    forest[representant]['colours'][c[node]] += 1\n                else:\n                    forest[representant]['colours'][c[node]] = 1\n                visited[node] = True\n# print(forest)\ntotal = 0\nfor key in forest:\n    maximun = 0\n    for i in forest[key]['colours']:\n        if forest[key]['colours'][i] > maximun:\n            maximun = forest[key]['colours'][i]\n    total += len(forest[key]['nodes']) - maximun\nsys.stdout.write(str(total))\n", "import sys\nn, m, k = [int(x) for x in sys.stdin.readline().replace('\\n', '').split(' ')]\nc =  [int(x) for x in sys.stdin.readline().replace('\\n', '').split(' ')]\n# print ((n,m,k))\n# Graphs with python\nsocks = [[] for _ in range(n)]\n# populate a Graph\nfor i in range(m):\n    l, r = [int(x)-1 for x in sys.stdin.readline().replace('\\n', '').split(' ')]\n    socks[r] += [l]\n    socks[l] += [r]\n# search a Graph\nvisited = [False for _ in range(n)]\nforest = {}\nfor i, v in enumerate(visited):\n    if v:\n        continue\n    visited[i] = True\n    queue = [(i, i)]\n    forest[i] = {'nodes': 1, 'colours': {c[i]: 1}}\n    while len(queue) != 0:\n        # print(queue)\n        representant, current = queue.pop()\n        for node in socks[current]:\n            if not visited[node]:\n                queue += [(representant, node)]\n                forest[representant]['nodes'] += 1\n                if c[node] in forest[representant]['colours']:\n                    forest[representant]['colours'][c[node]] += 1\n                else:\n                    forest[representant]['colours'][c[node]] = 1\n                visited[node] = True\n# print(forest)\ntotal = 0\nfor key in forest:\n    maximun = 0\n    for i in forest[key]['colours']:\n        if forest[key]['colours'][i] > maximun:\n            maximun = forest[key]['colours'][i]\n    total += forest[key]['nodes'] - maximun\nsys.stdout.write(str(total))\n", "from collections import Counter, defaultdict\n\nclass DSU:\n\tdef __init__(self, n):\n\t\tself.parents = [i for i in range(n)]\n\t\tself.rank = [0 for i in range(n)]\n\n\tdef find_parent(self, a):\n\t\tif a == self.parents[a]:\n\t\t\treturn a\n\t\telse:\n\t\t\tb = self.find_parent(self.parents[a])\n\t\t\tself.parents[a] = b\n\t\t\treturn b\n\n\tdef join_sets(self, a, b):\n\t\ta = self.find_parent(a)\n\t\tb = self.find_parent(b)\n\t\tif a != b:\n\t\t\tif self.rank[a] < self.rank[b]:\n\t\t\t\ta, b = b, a\n\t\t\tself.parents[b] = a\n\t\t\tif self.rank[a] == self.rank[b]:\n\t\t\t\tself.rank[a] += 1\n\nn, m, k = map(int, input().split(' '))\ndsu = DSU(n)\ncolors = list(map(int, input().split(' ')))\nfor _ in range(m):\n\ta, b = map(int, input().split(' '))\n\ta, b = a-1, b-1\n\tdsu.join_sets(a, b)\ncur_colors = defaultdict(Counter)\nfor i in range(n):\n\tcur_colors[dsu.find_parent(i)][colors[i]] += 1\nans = 0\nfor color_counter in cur_colors.values():\n\tans += sum(color_counter.values()) - color_counter.most_common(1)[0][1]\n\nprint(ans)", "def main():\n    from collections import Counter\n    n, m, _ = map(int, input().split())\n    cc = list(map(int, input().split()))\n    pairs, avail = [[] for _ in range(n)], [True] * n\n    for _ in range(m):\n        a, b = map(int, input().split())\n        pairs[a - 1].append(b - 1)\n        pairs[b - 1].append(a - 1)\n    for a, f in enumerate(avail):\n        if f:\n            stack, cnt, avail[a] = [a], Counter(), False\n            while stack:\n                a = stack.pop()\n                cnt[cc[a]] += 1\n                for b in pairs[a]:\n                    if avail[b]:\n                        avail[b] = False\n                        stack.append(b)\n            n -= cnt.most_common(1)[0][1]\n    print(n)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def dfs(v, visited, edges, colors):\n    st = [v]\n    visited.add(v)\n    comp = []\n    cols = dict()\n    while st:\n        ver = st.pop()\n        comp.append(colors[ver])\n        if ver in edges:\n            for i in edges[ver]:\n                if i not in visited:\n                    st.append(i)\n                    visited.add(i)\n    for i in comp:\n        if i not in cols:\n            cols[i] = 1\n        else:\n            cols[i] += 1\n    max_c = 0\n    for i in cols:\n        if cols[i] > max_c:\n            max_c = cols[i]\n    return len(comp) - max_c\n\n\n\nn, m, k = [int(x) for x in input().split()]\ncolors = {i + 1 : int(x) for i, x in enumerate(input().split())}\nedges = dict()\nfor i in range(m):\n    v1, v2 = [int(x) for x in input().split()]\n    if v1 in edges:\n        edges[v1].append(v2)\n    else:\n        edges[v1] = [v2]\n    if v2 in edges:\n        edges[v2].append(v1)\n    else:\n        edges[v2] = [v1]\n\nvisited = set()\nanswer = 0\nfor i in range(1, n + 1):\n    if i not in visited:\n        answer += dfs(i, visited, edges, colors)\n\n\nprint(answer)\n", "from collections import deque, defaultdict\n\ndef BFS(graph, source, visited):\n    # Generator which yields all vertices connected to source (includes source)\n    n = len(graph)\n    queue = deque()\n    queue.append(source)\n    visited[source] = True\n\n    while len(queue) > 0:\n        u = queue.popleft()\n        yield u\n\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n\ndef get_components(adjacency_list, n):\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            yield list(BFS(adjacency_list, i, visited))\n\ndef __starting_point():\n    n, m, k = list(map(int, input().split()))\n    colours = [int(x) - 1 for x in input().split()]\n    adjacency_list = [[] for _ in range(n)]\n    for _ in range(m):\n        l, r = (int(x) - 1 for x in input().split())\n        adjacency_list[l].append(r)\n        adjacency_list[r].append(l)\n\n    components = get_components(adjacency_list, n)\n\n    changes = 0\n    for component in components:\n        colour_counts = defaultdict(int)\n        max_count = 0\n        for sock in component:\n            counter = colour_counts[colours[sock]] + 1\n            colour_counts[colours[sock]] = counter\n            if counter > max_count:\n                max_count = counter\n\n        changes += len(component) - max_count\n\n    print(changes)\n\n__starting_point()", "from collections import deque, defaultdict\n\ndef BFS(graph, source, visited, colours):\n    # Generator which yields all vertices connected to source (includes source)\n    colour_counts = defaultdict(int)\n    max_count = 0\n    total = 0\n\n    n = len(graph)\n    queue = deque()\n    queue.append(source)\n    visited[source] = True\n\n    while len(queue) > 0:\n        u = queue.popleft()\n        total += 1\n        counter = colour_counts[colours[u]] + 1\n        colour_counts[colours[u]] = counter\n        if counter > max_count:\n            max_count = counter\n\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n\n    return total, max_count\n\ndef get_totals_and_maxcounts(adjacency_list, n, colours):\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            yield BFS(adjacency_list, i, visited, colours)\n\ndef __starting_point():\n    n, m, k = list(map(int, input().split()))\n    colours = [int(x) - 1 for x in input().split()]\n    adjacency_list = [[] for _ in range(n)]\n    for _ in range(m):\n        l, r = (int(x) - 1 for x in input().split())\n        adjacency_list[l].append(r)\n        adjacency_list[r].append(l)\n\n\n    changes = 0\n    for total, max_count in get_totals_and_maxcounts(adjacency_list, n, colours):\n        changes += total - max_count\n\n    print(changes)\n\n__starting_point()", "n, m, k = list(map(int, input().split()))\nsocks = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n    adj[b].append(a)\n\ncomponent = [None] * n\ncur_comp = 0\n\nfor i in range(n):\n    if component[i] is None:\n        todo = [i]\n        while todo:\n            xi = todo.pop()\n            component[xi] = cur_comp\n            for neighbour in adj[xi]:\n                if component[neighbour] is None:\n                    todo.append(neighbour)\n        cur_comp += 1\n\ncomponents = [[] for _ in range(cur_comp)]\nfor v, c in enumerate(component):\n    components[c].append(v)\n\nout = 0\nfor c in components:\n    counter = {}\n    for v in c:\n        if socks[v] not in counter:\n            counter[socks[v]] = 0\n        counter[socks[v]] += 1\n    out += len(c) - max(counter.values())\nprint(out)\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n    def find(self,x):\n        if self.parent[x] is x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n        \n    \ndef __starting_point():\n    import sys, threading\nclass graph:\n    def __init__(self, n):\n        self.size = n\n        self.adj = [[] for _ in range(n)]\n        \n    def add_edge(self,u,v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n        \n    def DFS(self, node):\n        self.visited[node] = True\n        subg = [node]\n        for edge in self.adj[node]:\n            if not self.visited[edge]:\n                subg.extend(self.DFS(edge))\n        return subg\n    \n    def components(self):\n        self.visited = [False]*self.size\n        self.components = []    \n        for node in range(self.size):\n            if self.visited[node] is False:\n                self.components.append(self.DFS(node))\n        return self.components\n\ndef __starting_point():\n    n, m, k = [int(x) for x in input().split()]\n    uf = UnionFind(n)\n    color = [int(x) for x in input().split()]\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        uf.union(u-1, v-1)\n    collection = [[] for i in range(n)]\n    for i in range(n):\n        collection[uf.find(i)].append(i)\n\n    ans = 0\n    for sock_set in collection:\n        if not sock_set: continue\n        count = {}\n        set_max = 1\n        for sock in sock_set:\n            try:\n                count[color[sock]] += 1\n                set_max = max(count[color[sock]], set_max)\n            except:\n                count[color[sock]] = 1\n        ans += len(sock_set) - set_max\n\n    print(ans)\n\n\n__starting_point()", "n, m, k = list(map(int, input().split()))\nsocks = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n    adj[b].append(a)\n\ncomponent = [None] * n\ncur_comp = 0\n\nfor i in range(n):\n    if component[i] is None:\n        todo = [i]\n        while todo:\n            xi = todo.pop()\n            component[xi] = cur_comp\n            for neighbour in adj[xi]:\n                if component[neighbour] is None:\n                    todo.append(neighbour)\n        cur_comp += 1\n\ncomponents = [[] for _ in range(cur_comp)]\nfor v, c in enumerate(component):\n    components[c].append(v)\nout = 0\nfor c in components:\n    counter = {}\n    for v in c:\n        if socks[v] not in counter:\n            counter[socks[v]] = 0\n        counter[socks[v]] += 1\n    out += len(c) - max(counter.values())\nprint(out)\n", "n, m, k = list(map(int, input().split()))\nc = [int(x) - 1 for x in input().split()]\n\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    l, r = list(map(int, input().split()))\n    adj[l - 1].append(r - 1)\n    adj[r - 1].append(l - 1)\n\nvis = [0] * n\nans = 0\n\nfor i in range(n):\n    if vis[i] == 1: \n        continue\n\n    arr, cur = [i], 0\n    while cur < len(arr):\n        v = arr[cur]\n        vis[v] = 1\n        cur += 1\n        for nv in adj[v]:\n            if vis[nv] == 0:\n                arr.append(nv)\n                vis[nv] = 1\n\n    d = {}\n    for v in arr:\n        d[c[v]] = d.get(c[v], 0) + 1\n\n    ans += len(arr) - max(d.values())\n\nprint(ans)    \n\n    \n    \n\n", "def main():\n    from collections import Counter\n    n, m, _ = list(map(int, input().split()))\n    cc = list(map(int, input().split()))\n    pairs, avail = [[] for _ in range(n)], [True] * n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        pairs[a - 1].append(b - 1)\n        pairs[b - 1].append(a - 1)\n    for a, f in enumerate(avail):\n        if f:\n            stack, cnt, avail[a] = [a], Counter(), False\n            while stack:\n                a = stack.pop()\n                cnt[cc[a]] += 1\n                for b in pairs[a]:\n                    if avail[b]:\n                        avail[b] = False\n                        stack.append(b)\n            n -= cnt.most_common(1)[0][1]\n    print(n)\n\n\ndef __starting_point():\n    main()\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "n,m,k=map(int,input().split())\nc=list(map(int,input().split()))\ng=[[]for _ in range(n)]\nfor _ in range(m):\n    l,r=map(int,input().split())\n    g[l-1].append(r-1)\n    g[r-1].append(l-1)\nv=[-1]*n\no=0\nfor i in range(n):\n    if v[i]==-1:\n        s=[i]\n        v[i]=1\n        q={}\n        while s:\n            x=s.pop()\n            if c[x] not in q:q[c[x]]=0\n            q[c[x]]+=1\n            for j in g[x]:\n                if v[j]==-1:\n                    v[j]=1\n                    s.append(j)\n        r,k=0,0\n        for b in q:\n            k=max(k,q[b])\n            r+=q[b]\n        o+=r-k\nprint(o)", "n,m,k=map(int,input().split())\na=list(map(int,input().split()))\ntr=[[] for i in range(n)]\n\nfor i in range(m):\n\tl,r=map(int,input().split())\n\ttr[l-1].append(r-1)\n\ttr[r-1].append(l-1)\nvisited=[False for i in range(n)]\nans=0\nfor i in range(n):\n\tif visited[i]:continue\n\ts=[i]\n\tvisited[i]=True\n\tqeue={}\n\twhile s:\n\t\tx=s.pop()\n\t\tif a[x] not in qeue:qeue[a[x]]=0\n\t\tqeue[a[x]]+=1\n\t\tfor j in tr[x]:\n\t\t\tif visited[j]:continue\n\t\t\tvisited[j]=True\n\t\t\ts.append(j)\n\tneu,maxi=0,0\n\tfor e in qeue:\n\t\tmaxi=max(maxi,qeue[e])\n\t\tneu+=qeue[e]\n\tans+=neu-maxi\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n        \nn, m, k = list(map(int, input().split()))\nc = list(map(int, input().split()))\nuf = Unionfind(n)\n\nfor _ in range(m):\n    l, r = list(map(int, input().split()))\n    uf.unite(l-1, r-1)\n\ncnt = defaultdict(dict)\n\nfor i in range(n):\n    r = uf.root(i)\n    \n    if c[i] not in cnt[r]:\n        cnt[r][c[i]] = 1\n    else:\n        cnt[r][c[i]] += 1\n\nans = 0\n\nfor r in list(cnt.keys()):\n    l = list(cnt[r].values())\n    ans += sum(l)-max(l)\n\nprint(ans)\n", "from collections import *\nfrom sys import stdin\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\nclass graph:\n    # initialize graph\n    def __init__(self, gdict=None):\n        if gdict is None:\n            gdict = defaultdict(list)\n        self.gdict, self.edges, self.l = gdict, [], defaultdict(int)\n\n    # Get verticies\n    def get_vertices(self):\n        return list(self.gdict.keys())\n\n    # add edge\n    def add_edge(self, node1, node2, w=None):\n        self.gdict[node1].append(node2)\n        self.gdict[node2].append(node1)\n        self.l[node1] += 1\n        self.l[node2] += 1\n\n    def bfs_util(self, i):\n        queue, self.visit[i], color = deque([i]), 1, defaultdict(int, {c[i - 1]: 1})\n\n        while queue:\n            # dequeue parent vertix\n            s = queue.popleft()\n\n            # enqueue child vertices\n            for i in self.gdict[s]:\n                if self.visit[i] == 0:\n                    queue.append(i)\n                    self.visit[i] = 1\n                    color[c[i - 1]] += 1\n        # print(color)\n        return sum(color.values()) - max(color.values())\n\n    def bfs(self):\n        self.visit, self.cnt = defaultdict(int), 0\n\n        for i in self.get_vertices():\n            if self.visit[i] == 0:\n                self.cnt += self.bfs_util(i)\n\n        return self.cnt\n\n\nn, m, k = arr_inp(1)\nc, g = arr_inp(1), graph()\n\nfor i in range(m):\n    u, v = arr_inp(1)\n    g.add_edge(u, v)\n\nprint(g.bfs())\n", "n, m, k = list(map(int, input().split()))\nc = list(map(int, input().split()))\nc = list([x-1 for x in c])\nadj = [[] for _ in range(n)]\nedges = list(list(map(int, input().split())) for _ in range(m))\nfor u, v in edges:\n    u -= 1 ; v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\n\nvis = [0] * n\nres = 0\nfor i in range(n):\n    if vis[i] == 1: \n        continue\n    arr, curr = [i], 0\n    while curr < len(arr):\n        u = arr[curr]\n        vis[u] = 1\n        curr += 1\n        for v in adj[u]:\n            if vis[v] == 0:\n                arr.append(v)\n                vis[v] = 1\n    d = {}\n    for j in arr:\n        d[c[j]] = d.get(c[j], 0) + 1\n    res += len(arr) - max(d.values())\nprint(res)\n", "def find(node):\n    while p[node] != node:\n        p[node] = p[p[node]]\n        node = p[node]\n    return node\n\ndef union(n1,n2):\n    p1 = find(n1)\n    p2 = find(n2)\n\n    if p1 != p2: p[p1] = p2\n\n\nn,m,k = map(int,input().split())\nsocks = list(map(int,input().split()))\np = [i for i in range(n)]\nused = set()\nfor i in range(m):\n    a,b = map(int,input().split())\n\n    union(a-1,b-1)\n    used.add(a-1)\n    used.add(b-1)\ncc = {}\n\nfor i in used:\n    x = find(i)\n    if x not in cc:\n        cc[x] = []\n        cc[x].append(socks[i])\n    else:\n        cc[x].append(socks[i])\nans = 0\nfor each in cc.values():\n    each.sort()\n    cnt = 1\n    l = len(each)\n    mx = 1\n    for i in range(l-1):\n        if each[i+1] != each[i]:\n            mx = max(mx,cnt)\n            cnt = 1\n        else:\n            cnt += 1\n    mx = max(cnt,mx)\n    ans += l - mx\nprint(ans)"]
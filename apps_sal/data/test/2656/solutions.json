["from functools import reduce\ndef comb(n, max_k, mod):\n    \"\"\"\n    (n,k) := n\u500b\u304b\u3089k\u500b\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n    k = 0~max_K\u307e\u3067\u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059\n    \"\"\"\n    res = [1]*(max_k+1)\n    t = 1\n    for i in range(max_k+1):\n        res[i] *= t\n        t *= n-i\n        t %= mod\n\n    n = reduce(lambda x,y: (x*y)%mod, range(1,max_k+1), 1)\n    n = pow(n,-1, mod)\n\n    for i in reversed(range(max_k+1)):\n        res[i] *= n\n        res[i] %= mod\n        n *= i\n        n %= mod\n    return res\n\nMOD = 10**9+7\n\nK = int(input())\nN = len(input())\n\nres = 0\nx = 1\n\ncom = comb(N+K, K, MOD)\n\nfor c in com:\n    res += x*c\n    res %= MOD\n    x *= 25\n    x %= MOD\n\nprint(res)", "k = int(input())\ns = input()\ns = len(s)\n\nmod = 10 ** 9 + 7\nn = k + s\n\n\ndef _fac_inv(_n, _mod):\n    _fac = [1] * (_n + 1)\n    _inv = [1] * (_n + 1)\n    for i in range(_n):\n        _fac[i + 1] = _fac[i] * (i + 1) % _mod\n    _inv[_n] = pow(_fac[_n], _mod - 2, _mod)\n    for i in range(_n, 0, -1):\n        _inv[i - 1] = _inv[i] * i % _mod\n\n    return _fac, _inv\n\n\nfac, inv = _fac_inv(n, mod)\n\nn25 = [1]\nn26 = [1]\nfor _ in range(n-s):\n    n25.append((n25[-1] * 25) % mod)\n    n26.append((n26[-1] * 26) % mod)\n\nans = 0\n\nfor i in range(s, n + 1):\n    ans = (ans + fac[i-1] * inv[s-1] * inv[i-s] * n25[i-s] * n26[n-i]) % mod\n\nprint(ans)\n", "k = int(input())\ns = input()\nn = len(s)\n\nMAX = 10**6\nMOD = 10**9+7\n\ninv = [0] * (MAX+1)\ninv[1] = 1\nfor i in range(2, MAX+1):\n    q, r = divmod(MOD, i)\n    inv[i] = -inv[r] * q % MOD\n\nans = val = pow(26, k, MOD)\nfor i in range(1, k+1):\n    val *= (i+n-1) * 25 * inv[i] * inv[26] % MOD\n    val %= MOD\n    ans += val\n    ans %= MOD\nprint(ans)\n", "Q = 10**9+7\ndef getInv(N):#Q\u306fmod\n    inv = [0] * (N + 1)\n    inv[0] = 1\n    inv[1] = 1\n    for i in range(2, N + 1):\n        inv[i] = (-(Q // i) * inv[Q%i]) % Q\n    return inv\n\ndef main():\n    K = int( input())\n    S = input()\n    N = len(S)\n    ans = 0\n    cmb = 1\n    Inv = getInv(K+1)\n    twenty_five = 1\n    twenty_six = pow(26,K,Q)\n    one_over_twenty_six = pow(26,Q-2,Q)\n    for i in range(K+1):\n        # ans += cmb*pow(25,i,Q)%Q*pow(26,K-i,Q)%Q\n        # print(cmb, i, K-i)\n        ans += cmb*twenty_five%Q*twenty_six%Q\n        twenty_five *= 25\n        twenty_five %= Q\n        twenty_six *= one_over_twenty_six\n        twenty_six %= Q\n        ans %= Q\n        cmb *= N+i\n        cmb *= Inv[i+1]\n        cmb %= Q\n        \n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "# F - Strivore\nimport sys\nMOD = 10**9+7\nK = int(input())\nS = input()\nl = len(S)\nans = 0\n\ntmp = pow(26,K,MOD)\nans = tmp\nwaru = pow(26,-1,MOD)\n\nfor i in range(1,K+1):\n    tmp = (tmp*25*waru)%MOD\n    tmp = (tmp*(l-1+i)*pow(i,-1,MOD))%MOD\n    ans = (ans+tmp)%MOD\n\nprint(ans)", "def f_strivore(MOD=10**9 + 7):\n    K = int(input())\n    S = input()\n    length = len(S)\n\n    class Combination(object):\n        \"\"\"\u7d20\u6570 mod \u306b\u5bfe\u3059\u308b\u4e8c\u9805\u4fc2\u6570\u306e\u8a08\u7b97\"\"\"\n        __slots__ = ['mod', 'fact', 'factinv']\n\n        def __init__(self, max_val_arg: int = 10**6, mod: int = 10**9 + 7):\n            fac, inv = [1], []\n            fac_append, inv_append = fac.append, inv.append\n\n            for i in range(1, max_val_arg + 1):\n                fac_append(fac[-1] * i % mod)\n\n            inv_append(pow(fac[-1], -1, mod))\n            for i in range(max_val_arg, 0, -1):\n                inv_append((inv[-1] * i) % mod)\n\n            self.mod, self.fact, self.factinv = mod, fac, inv[::-1]\n\n        def combination(self, n, r):\n            return (0 if n < 0 or r < 0 or n < r\n                    else self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.mod)\n\n    comb = Combination(length + K).combination\n    f = [1] * (K + 1)\n    tmp = 1\n    for n in range(K + 1):\n        f[n] = (comb(length + n - 1, length - 1) * tmp) % MOD\n        tmp = (tmp * 25) % MOD\n    g = [1] * (K + 1)\n    for n in range(1, K + 1):\n        g[n] = (f[n] + 26 * g[n - 1]) % MOD\n    return g[K]\n\nprint(f_strivore())", "mod = 10**9 + 7\nK = int(input())\nS = input()\nn = len(S)\ntmp = pow(26, K, mod)\nwaru = pow(26, -1, mod)\nans = tmp\nfor i in range(1, K+1):\n    tmp = (tmp * 25 * waru)%mod\n    tmp = (tmp * (i + n -1) * pow(i, -1, mod))%mod\n    ans = (ans+tmp)%mod\nprint(ans%mod)", "n = int(input())\ns = input()\n\nS = len(s)\nmod = 10 ** 9 + 7\n\ntmp_ans = pow(26, n, mod)\ndiv = pow(26, -1, mod)\n\nans = tmp_ans\n\nfor i in range(1, n+1):\n    tmp_ans = (tmp_ans * 25 * div) % mod\n    tmp_ans = ((tmp_ans * (S-1+i)) * pow(i, -1, mod)) % mod\n    ans = (ans + tmp_ans) % mod\n\nans %= mod\n\nprint(ans)\n", "n = int(input())\ns = input()\n \nS = len(s)\nmod = 10 ** 9 + 7\n \ntmp_ans = pow(26, n, mod)\ndiv = pow(26, -1, mod)\n \nans = tmp_ans\n \nfor i in range(1, n+1):\n    tmp_ans = (tmp_ans * 25 * div) % mod\n    tmp_ans = ((tmp_ans * (S-1+i)) * pow(i, -1, mod)) % mod\n    ans = (ans + tmp_ans) % mod\n \nans %= mod\n \nprint(ans)", "n = int(input())\ns = input()\n \nS = len(s)\nmod = 10 ** 9 + 7\n \ntmp_ans = pow(26, n, mod)\ndiv = pow(26, -1, mod)\n \nans = tmp_ans\n \nfor i in range(1, n+1):\n    tmp_ans = (tmp_ans * 25 * div) % mod\n    tmp_ans = ((tmp_ans * (S-1+i)) * pow(i, -1, mod)) % mod\n    ans = (ans + tmp_ans) % mod\n \nans %= mod\n \nprint(ans)", "K = int(input())\nN = len(input()) + K\nP = 10**9+7\n\nnn = 2002002\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\nfainv[-1] = pow(fa[-1], P-2, P)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % P\n\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a-b] % P if 0 <= b <= a else 0\n\ns = 0\npo = 1\nfor i in range(K + 1):\n    s = (s + C(N, i) * po) % P\n    po = po * 25 % P\nprint(s)", "import sys\n\nK = int(sys.stdin.readline())\nS = sys.stdin.readline().rstrip('\\n')\n\n# ## COMBINATION (MOD) ###\nN_MAX = 10**6  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\nMOD = 10**9 + 7\n\ninv = [0] * (N_MAX + 2)\ninv[0] = 0  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\ninv[1] = 1\n\nfor i in range(2, N_MAX + 2):\n    q, r = divmod(MOD, i)\n    inv[i] = -inv[r] * q % MOD\n\n\n# K \u6587\u5b57\u8ffd\u52a0\nans = 0\n\nln = len(S)\n\np = pow(26, K, MOD)\n\nfor i in range(1, K + 2):\n\n    ans += p % MOD\n    ans %= MOD\n\n    # pre\n    p = p * (ln + i - 1) * inv[i] * 25 * inv[26] % MOD\n\n    # suf\n    # s2 = (s2 * inv[26]) % MOD\n\nprint(ans)\n", "MOD = 10**9 + 7\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n\n        f = 1\n        self.fact = fact = [f]\n        for i in range(1, size+1):\n            f = f * i % MOD\n            fact.append(f)\n        f = pow(f, MOD-2, MOD)\n        self.factInv = factInv = [f]\n        for i in range(size, 0, -1):\n            f = f * i % MOD\n            factInv.append(f)\n        factInv.reverse()\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nK = int(input())\nS = input()\nN = len(S)\n\ncomb = Combination(N + K + 100)\n\nans = 0\nL = 1\nR = pow(26, K, MOD)\ninv26 = pow(26, MOD - 2, MOD)\nfor l in range(K + 1):\n    ans += L * comb.nhr(N, l) * R\n    ans %= MOD\n\n    L = L * 25 % MOD\n    R = R * inv26 % MOD\n\nprint(ans)\n", "K = int(input())\nS = input()\n\ns = len(S)\nmod = int(1e9+7)\n\n\nn = pow(26, K, mod)\nans = n\n\nfor i in range(K):\n    n = n*25*(s+i)*pow(26*(i+1),-1,mod)%mod\n    ans = (ans +n) % mod\n\n\nprint(ans)", "import sys\n\nK = int(sys.stdin.readline())\nS = sys.stdin.readline().rstrip('\\n')\n\n# ## COMBINATION (MOD) ###\nN_MAX = 10**6  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\nMOD = 10**9 + 7\n\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 2):\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n\n# K \u6587\u5b57\u8ffd\u52a0\nans = 0\n\nln = len(S)\n\np1 = 1\np2 = 1\ns2 = pow(26, K, MOD)\n\nfor i in range(1, K + 2):\n\n    ans += (p1 * p2 * s2) % MOD\n    ans %= MOD\n\n    # print(p1, p2, s2)\n\n    # pre\n    p1 = (p1 * (ln + i - 1) * inv[i]) % MOD\n    p2 = (p2 * 25) % MOD\n\n    # suf\n    s2 = (s2 * inv[26]) % MOD\n\nprint(ans)\n", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nMAX = 2 * 10**6 + 10\nMOD = 10**9+7\n\nfac = [1] * MAX\nf_inv = [1] * MAX\n\ndef prepare(n, mod):\n    for i in range(1, n+1):\n        fac[i] = (fac[i-1] * i) % mod\n    \n    f_inv[n] = pow(fac[n], -1, MOD)\n    for i in range(n-1, 0, -1):\n        f_inv[i] = (f_inv[i+1] * (i+1)) % MOD\n\ndef modcmb(n, r, mod):\n    if n < 0 or r < 0:\n        return 0\n    if r > n:\n        return 0\n\n    return fac[n] * f_inv[r] * f_inv[n-r] % mod\n\n\ndef main():\n    K = int(readline())\n    S = readline().strip()\n    N = len(S)\n\n    prepare(N + K + 5, MOD)\n\n    inv26 = pow(26, -1, MOD)\n    pow26 = pow(26, K, MOD)\n    pow25 = 1\n    ans = 0\n    for i in range(K+1):\n        ans += (modcmb(N-1+i, i, MOD) * pow25 * pow26) % MOD\n        ans %= MOD\n\n        pow25 *= 25\n        pow25 %= MOD\n        pow26 *= inv26\n        pow26 %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#\u5199\u7d4c\n#https://atcoder.jp/contests/abc171/submissions/14574647\nfrom functools import reduce\ndef comb(n, max_k, mod):\n    \"\"\"\n    (n,k) := n\u500b\u304b\u3089k\u500b\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n    k = 0~max_K\u307e\u3067\u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059\n    \"\"\"\n    res = [1]*(max_k+1)\n    t = 1\n    for i in range(max_k+1):\n        res[i] *= t\n        t *= n-i\n        t %= mod\n\n    n = reduce(lambda x,y: (x*y)%mod, range(1,max_k+1), 1)\n    n = pow(n,-1, mod)\n\n    for i in reversed(range(max_k+1)):\n        res[i] *= n\n        res[i] %= mod\n        n *= i\n        n %= mod\n    return res\n\nMOD = 10**9+7\n\ndef resolve():\n    K = int(input())\n    N = len(input())\n    res = 0\n    x = 1\n    com = comb(N+K, K , MOD)\n\n    for c in com:\n        res += x*c\n        res %= MOD\n        x *= 25\n        x %= MOD\n    print(res)\nresolve()", "M = 10**9 + 7\nk,n = int(input()),len(input())\na = t = pow(26,k,M)\n\nfor i in range(k):\n    t = t*25*(i+n)*pow(26*(i+1),-1,M)%M\n    a += t\n\nprint(a%M)", "M=10**9+7\nk,n=int(input()),len(input())\na=t=pow(26,k,M)\nfor i in range(1,k+1):\n  t=t*25*(i+n-1)*pow(26*i,-1,M)%M\n  a+=t\nprint(a%M)", "import sys\n\nK = int(sys.stdin.readline())\nS = sys.stdin.readline().rstrip('\\n')\n\n# ## COMBINATION (MOD) ###\nN_MAX = 10**6  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\nMOD = 10**9 + 7\n\ninv = [0] * (N_MAX + 2)\ninv[0] = 0  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\ninv[1] = 1\n\nfor i in range(2, N_MAX + 2):\n    inv[i] = -inv[MOD % i] * (MOD // i) % MOD\n\n# K \u6587\u5b57\u8ffd\u52a0\nans = 0\n\nln = len(S)\n\np1 = 1\np2 = 1\ns2 = pow(26, K, MOD)\n\nfor i in range(1, K + 2):\n\n    ans += (p1 * p2 * s2) % MOD\n    ans %= MOD\n\n    # print(p1, p2, s2)\n\n    # pre\n    p1 = (p1 * (ln + i - 1) * inv[i]) % MOD\n    p2 = (p2 * 25) % MOD\n\n    # suf\n    s2 = (s2 * inv[26]) % MOD\n\nprint(ans)\n", "def calc_inv(n, mod_n):\n    inv_li = [0] * (n + 2)\n    inv_li[0] = 0\n    inv_li[1] = 1\n    for i in range(2, n + 2):\n        q, r = divmod(mod_n, i)\n        inv_li[i] = -inv_li[r] * q % mod_n\n    return inv_li\n\n\nK = int(input())\nS = input()\ns_len = len(S)\n\nMOD = 10**9 + 7\ninv = calc_inv(max(K, 26) + 10, MOD)\n\nans = 0\np = pow(26, K, MOD)\n\nfor i in range(1, K + 2):\n    ans = (ans + p % MOD) % MOD\n    p = p * (s_len + i - 1) * inv[i] * 25 * inv[26] % MOD\n\nprint(ans)\n", "K = int(input())\nS = input()\n\nm = 1000000007\n\nresult = 0\nt = pow(26, K, m)\nu = pow(26, -1, m) * 25 % m\nl = len(S)\nfor i in range(K + 1):\n    # result += pow(26, K - i, m) * mcomb(len(S) - 1 + i, i) * pow(25, i, m)\n    result = (result + t) % m\n    t = (t * u) % m * (l + i) % m * pow(i + 1, -1, m) % m\nprint(result)\n", "K = int(input())\nS = input()\nN = len(S)\nmod = int(1e9+7)\n\n### 123\n### a1bb2ccc3dddd 10\u6587\u5b57\u30a4\u30f3\u30b5\u30fc\u30c8\n# pow(25,6) * pow(26,4) * 8C2\n# (3\u306ffix\u3067\u3001\u305d\u308c\u3088\u308a\u524d\u306e8moji\u304b\u30891/2\u3092\u5165\u308c\u308b\u5834\u6240\u3092\u6c7a\u3081\u308b\uff09\n# \u3053\u308c\u30923\u306e\u4f4d\u7f6e\u3067\u30eb\u30fc\u30d7\u3059\u308b\uff081-index\u3067 3<=i<=N)\n\n# 123dddddddddd\n# pow(25,0) * pow(26,10) * 2C2(1)\n# 12x3ddddddddd\n# pow(25,1) * pow(26,9) * 3C2( = 2C2 * 3 / 1)\n# 12xx3dddddddd\n# pow(25,2) * pow(26,8) * 4C2( = 3C2 * 4 / 2)\n# ...\n# 12xxxxxxxxxx3\n# pow(25,10) * pow(26,0) * 12C2( = 11C2 * 12 / 10)\n\n# 5C5, 6C5, 7C5 1, 6, 21, 56\n\nwk = pow(26,K,mod)\ninv26 = pow(26,-1,mod)\n\nans = wk\nfor i in range(1,K+1):\n  wk = (wk * 25 * inv26) % mod\n  wk = (wk * (N-1+i) * pow(i,-1,mod) % mod)\n  ans = (ans + wk)%mod\n    \nprint(ans)\n", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\ndef main():\n    from builtins import pow\n\n    K = int(input())\n    S = input()\n\n    m = 1000000007\n\n    result = 0\n    t = pow(26, K, m)\n    u = pow(26, -1, m) * 25 % m\n    l = len(S)\n    for i in range(K + 1):\n        # result += pow(26, K - i, m) * mcomb(len(S) - 1 + i, i) * pow(25, i, m)\n        result = (result + t) % m\n        t = (t * u) % m * (l + i) * pow(i + 1, -1, m) % m\n    print(result)\n\n\nmain()\n", "# F - Strivore\nimport sys\nMOD = 10**9+7\nK = int(input())\nS = input()\nl = len(S)\nans = 0\n \ntmp = pow(26,K,MOD)\nans = tmp\nwaru = pow(26,-1,MOD)\n \nfor i in range(1,K+1):\n    tmp = (tmp*25*waru)%MOD\n    tmp = (tmp*(l-1+i)*pow(i,-1,MOD))%MOD\n    ans = (ans+tmp)%MOD\n \nprint(ans)", "k = int(input())\ns = input()\nn = len(s)\n\nMOD = 10**9+7\nd = pow(26, -1, MOD)\nans = val = pow(26, k, MOD)\nfor i in range(1, k+1):\n    val *= (i+n-1) * 25 * pow(i, -1, MOD) * d % MOD\n    val %= MOD\n    ans += val\n    ans %= MOD\nprint(ans)", "K = int(input())\nS = input()\n\nm = 1000000007\n\nresult = 0\nt = pow(26, K, m)\nu = pow(26, -1, m) * 25 % m\nl = len(S)\nfor i in range(K + 1):\n    # result += pow(26, K - i, m) * mcomb(len(S) - 1 + i, i) * pow(25, i, m)\n    result = (result + t) % m\n    t = (t * u) % m * (l + i) * pow(i + 1, -1, m) % m\nprint(result)\n", "def solve(k, length, MOD, div, dp):\n    for i in range(1, k + 1):\n        dp[0] = dp[0] * 25 * div * (length + i - 1) * pow(i, -1, MOD) % MOD\n        dp[1] = (dp[1] + dp[0]) % MOD\n\n    return(dp[1])\n\n\nk = int(input())\ns = input()\nlength = len(s)\nMOD = 10**9 + 7\ndiv = pow(26, -1, MOD)\n\ndp = [pow(26, k, MOD)] * 2\n\nprint(solve(k, length, MOD, div, dp))", "MOD = 10**9 + 7\n\nclass Combination:\n    def __init__(self, size, MOD):\n        self.size = size + 2\n\n        f = 1\n        self.fact = fact = [f]\n        for i in range(1, size+1):\n            f = f * i % MOD\n            fact.append(f)\n        f = pow(f, MOD-2, MOD)\n        self.factInv = factInv = [f]\n        for i in range(size, 0, -1):\n            f = f * i % MOD\n            factInv.append(f)\n        factInv.reverse()\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\ndef sol():\n    K = int(input())\n    S = input()\n    N = len(S)\n\n    comb = Combination(N + K + 100, MOD)\n\n    ans = 0\n    L = 1\n    R = pow(26, K, MOD)\n    inv26 = pow(26, MOD - 2, MOD)\n    for l in range(K + 1):\n        ans += L * comb.nhr(N, l) * R\n        ans %= MOD\n\n        L = L * 25 % MOD\n        R = R * inv26 % MOD\n\n    print(ans)\nsol()", "K = int(input())\nS = input()\nN = len(S)\nmod = int(1e9+7)\n\n\nwk = pow(26,K,mod)\ninv26 = pow(26,-1,mod)\n\nans = wk\nfor i in range(1,K+1):\n  wk = (wk * 25 * inv26) % mod\n  wk = (wk * (N-1+i) * pow(i,-1,mod) % mod)\n  ans = (ans + wk)%mod\n    \nprint(ans)\n", "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\nn_ = 2 * 10**6 + 5\nmod = 10**9 + 7\nfun = [1] * (n_ + 1)\nfor i in range(1, n_ + 1):\n    fun[i] = fun[i - 1] * i % mod\nrev = [1] * (n_ + 1)\nrev[n_] = pow(fun[n_], mod - 2, mod)\nfor i in range(n_ - 1, 0, -1):\n    rev[i] = rev[i + 1] * (i + 1) % mod\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fun[n] * rev[r] % mod * rev[n - r] % mod\n\ndef modinv(x, mod):\n    a, b = x, mod\n    u, v = 1, 0\n    while b:\n        t = a // b\n        a -= t * b; a, b = b, a\n        u -= t * v; u, v = v, u\n    return u % mod\n\n\ninv26 = modinv(26, mod)\n\n\ndef solve():\n    k = ni()\n    s = ns()\n    n = len(s)\n    ans = 0\n    v = 1\n    u = pow(26, k, mod)\n    for i in range(n, n+k+1):\n        ans = (ans + nCr(i-1, n-1) * v * u) % mod\n        u = u * inv26 % mod\n        v = v * 25 % mod\n    print(ans)\n    return\n\nsolve()\n", "def main():\n    K = int(input())\n    S = input()\n    N = len(S)\n    mod = 10**9 + 7\n    r = 0\n    t = pow(26, K, mod)\n    s = 1\n    inv26 = pow(26, mod - 2, mod)\n    inv = [0] * (K + 2)\n    inv[1] = 1\n    for i in range(2, K + 2):\n        inv[i] = -inv[mod % i] * (mod // i) % mod\n    for i in range(K + 1):\n        r = (r + t * s) % mod\n        t = (t * 25 * inv26) % mod\n        s = (s * (N + i) * inv[i + 1]) % mod\n    return r\n\n        \nprint((main()))\n", "k = int(input())\ns = input()\nlen_s = len(s)\nMOD = 1000000007\n\nx_i = pow(26, k, MOD)\nr = (25 * pow(26, -1, MOD)) % MOD\ncomb_i = 1\n\na = 0\nfor i in range(k + 1):  \n  a += (comb_i  * x_i  ) % MOD\n  a %= MOD\n  \n  x_i  = (x_i  * r) % MOD\n  comb_i = (comb_i * (len_s + i) * pow(i + 1, -1, MOD)) % MOD\n\n\nprint(a)", "K = int(input())\nN = len(input())\n\nmod = 10 ** 9 + 7\ndiv = pow(26, -1, mod)\ncomb_i = pow(26, K, mod)\nans = comb_i\nfor i in range(1, K + 1):\n  comb_i = (comb_i * (N - 1 + i) * pow(i, -1, mod)) % mod\n  comb_i = (comb_i * 25 * div) % mod\n  ans = (ans + comb_i) % mod\n  \nprint(ans)", "from functools import reduce\ndef comb(n, max_k, mod):\n    \"\"\"\n    (n,k) := n\u500b\u304b\u3089k\u500b\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n    k = 0~max_K\u307e\u3067\u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059\n    \"\"\"\n    res = [1]*(max_k+1)\n    t = 1\n    for i in range(max_k+1):\n        res[i] *= t\n        t *= n-i\n        t %= mod\n\n    n = reduce(lambda x,y: (x*y)%mod, range(1,max_k+1), 1)\n    n = pow(n,-1, mod)\n\n    for i in reversed(range(max_k+1)):\n        res[i] *= n\n        res[i] %= mod\n        n *= i\n        n %= mod\n    return res\n\nMOD = 10**9+7\n\ndef resolve():\n    K = int(input())\n    N = len(input())\n    res = 0\n    x = 1\n    com = comb(N+K, K , MOD)\n\n    for c in com:\n        res += x*c\n        res %= MOD\n        x *= 25\n        x %= MOD\n    print(res)\nresolve()", "M=10**9+7\nk,n=int(input()),len(input())\na=t=pow(26,k,M)\nfor i in range(k):\n  t=t*25*(i+n)*pow(26*-~i,-1,M)%M\n  a+=t\nprint(a%M)"]
["# -*- coding: utf-8 -*-\nimport sys\nfrom operator import itemgetter\nfrom fractions import gcd\nfrom math import ceil, floor\nfrom copy import deepcopy\nfrom itertools import accumulate\nfrom collections import Counter\nimport math\nfrom functools import reduce\nfrom bisect import bisect_right\nsys.setrecursionlimit(200000)\ninput = sys.stdin.readline\ndef ii(): return int(input())\ndef mi(): return map(int, input().rstrip().split())\ndef lmi(): return list(map(int, input().rstrip().split()))\ndef li(): return list(input().rstrip())\ndef debug(x): print(\"debug: \", x, file=sys.stderr)\n# template\n\n\nclass BIT:\n    def __init__(self, x, d=0):\n        if isinstance(x, int):\n            self.size = x\n            self.tree = [d for _ in range(self.size + 1)]\n        elif isinstance(x, list):\n            self.size = len(x)\n            self.tree = [d for _ in range(self.size + 1)]\n            self.build(x)\n        else:\n            raise TypeError\n\n    def build(self, arr):\n        if isinstance(arr, list):\n            raise TypeError\n        for num, x in enumerate(arr):\n            self.add0(num, x)\n\n    def sum(self, i):\n        s = self.tree[0]\n        while i > 0:\n            s += self.tree[i]\n            i -= (i & -i)\n        return s\n\n    def add(self, i, a):\n        if(i == 0):\n            return\n        while (i <= self.size):\n            self.tree[i] += a\n            i += (i & -i)\n\n    def bisect_left(self, w):\n        if w <= 0:\n            return 0\n        x = 0\n        r = 1\n        while (r < self.size):\n            r <<= 1\n        k = r\n        while (k > 0):\n            if x + k <= self.size and self.tree[x + k] < w:\n                w -= self.tree[x + k]\n                x += k\n            k >>= 1\n        return x + 1\n\n    def query(self, l, r):\n        return self.sum(r - 1) - self.sum(l - 1)\n\n    def sum0(self, i):\n        return self.sum(i + 1)\n\n    def add0(self, i, a):\n        self.add(i + 1, a)\n\n    def query0(self, l, r):\n        return self.sum(r) - self.sum(l)\n\n    def __getitem__(self, item):\n        _tmp = item.indices(self.size + 1)\n        return [self.sum(i) - self.sum(i - 1) for i in range(_tmp[0], _tmp[1], _tmp[2])]\n\n    def __str__(self):\n        return str(self[1:self.size + 1])\n\n# END CUT HERE\n\n\ndef main():\n    s, b = mi()\n    a = lmi()\n    d = []\n    g = []\n    for i in range(b):\n        _d, _g = mi()\n        d.append(_d)\n        g.append(_g)\n    tmp = [(d[i], g[i]) for i in range(b)]\n    tmp.sort(key=lambda x: x[0])\n    d.sort()\n    # print(tmp)\n    # print(d)\n    bit = BIT(b)\n    for i in range(b):\n        bit.add0(i, tmp[i][1])\n    for i in range(s):\n        tmp = bisect_right(d, a[i])\n        # print(tmp)\n        print(bit.sum(tmp), end=\" \")\n    print()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s, b = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(s):\n    a[i] = [a[i], i, None]\nbases = []\nfor i in range(b):\n    d, g = map(int, input().split())\n    bases.append((d, g))\nbases.sort()\na.sort()\nj = 0\ncount = 0\nfor i in range(b):\n    while j < s and a[j][0] < bases[i][0]:\n        a[j][2] = count\n        j += 1\n    if j == s:\n        break\n    count += bases[i][1]\n    if i == b-1:\n        if j < s and a[j][0] >= bases[i][0]:\n            r = j\n            for j in range(r, s):\n                a[j][2] = count\na.sort(key=lambda x: x[1])\na = [x[2] for x in a]\nprint(*a)", "s, b = map(int, input().split())\na = list(map(int,input().split()))\nd = [ list(map(int,input().split())) for _ in range(b) ]\nd.sort(key=lambda f: f[0])\nfor i in range(1,b):\n    d[ i ][ 1 ] += d[ i - 1 ][ 1 ]\nd = { k: v for k, v in d }\nk = list(d.keys())\nfrom bisect import bisect_right as br\nfor ship in a:\n    key = br(k, ship)\n    ans = d[ k[ key - 1 ] ] if key else 0\n    print( ans, end = \" \" )\n", "from sys import stdin\nfrom bisect import bisect_right as br\ninput=stdin.readline\ns,b=map(int,input().split())\nsp=list(map(int,input().split()))\nbp=[]\nfor i in range(b):\n    bp.append(list(map(int,input().split())))\nc=[0]*b\nbp.sort()\nfor i in range(1,b):\n    bp[i][1]+=bp[i-1][1]\nan=[0]*s\nfor i in range(s):\n    m=br(bp,[sp[i]])\n    if m<b and bp[m][0]>sp[i]:\n        m-=1\n    elif m==b:\n        m-=1\n    if m>=0:\n        an[i]=bp[m][1]\n    else:\n        an[i]=0\nprint(*an)", "from bisect import bisect_right\nfrom operator import itemgetter\ns, b = list(map(int, input().split()))\nA = list(map(int, input().split()))\nDG = [list(map(int, input().split())) for _ in range(b)]\nDG.sort(key=itemgetter(0))\ncumG = [0]\nfor d, g in DG:\n  cumG.append(cumG[-1]+g)\nD = list(map(itemgetter(0), DG))\nAns = []\nfor a in A:\n  idx = bisect_right(D, a)\n  Ans.append(cumG[idx])\nprint(*Ans)\n", "\narr = input()\n\nN,B = [int(x) for x in arr.split(' ')]\n\narr = input()\nA = [int(x) for x in arr.split(' ')]\n\n\nbase = []\n\nfor i in range(B):\n    arr = input()\n    H,G = [int(x) for x in arr.split(' ')]\n    \n    base.append([H,G])\n    \nbase.sort()\n\nidx = sorted(range(len(A)), key=lambda k: A[k])\nA.sort()\n#print(base)\ns = 0\nk = -1\nans = [0]*(N)\nfor i in range(N):\n    attack = A[i]\n    while k<B-1:\n        if base[k+1][0]<=attack:\n            s += base[k+1][1]\n            k += 1\n        else:\n            break\n    \n    #print(attack,s)\n    ans[idx[i]] = s\n    \nfor num in ans:\n    print(num,end=' ')\n        ", "s_cnt, b_cnt = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = []\nfor i in range(b_cnt):\n\td, g = list(map(int, input().split()))\n\tb.append((d, g))\nb.sort()\nidx = [i for i in range(s_cnt)]\nidx.sort(key = lambda i : a[i])\nans = [0]*s_cnt\ns, j = 0, 0\nfor i in range(s_cnt):\n\twhile j < b_cnt and b[j][0] <= a[idx[i]]:\n\t\ts += b[j][1]\n\t\tj += 1\n\tans[idx[i]] = s\nprint(*ans)\n", "s, b = list(map(int, input().split(' ')))\n\nships = list(map(int, input().split(' ')))\nbases = [tuple(map(int, input().split(' '))) for _ in range(b)]\n\nbases.sort()\n\ngold = [0] * (b + 1)\nfor i in range(b):\n    gold[i + 1] = gold[i] + bases[i][1]\n\n# ships.sort()\n\ndef find(x, inf, sup):\n    while inf < sup:\n        mid = (inf + sup) // 2\n        if bases[mid][0] <= x:\n            inf = mid + 1\n        else:\n            sup = mid\n\n    return sup - 1\n\nattacks = [0] * s\nfor (i, ship) in enumerate(ships):\n    # print(\"{} can attack {} bases\".format(i, find(ship, 0, b) + 1))\n    attacks[i] = gold[find(ship, 0, b) + 1]\n\nprint(' '.join(map(str, attacks)))\n", "n,m = list(map(int,input().split()))\nd = list(map(int,input().split()))\nl = []\nfor i in range(n):\n    l.append([d[i],i])\nl.sort()\nl2 = []\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    l2.append([a,b])\nl2.sort()\ns = 0\nj = 0\nr = [0]*n\nfor i in range(n):\n    while(j<m and l2[j][0]<=l[i][0]):\n        s+=l2[j][1]\n        j+=1\n    r[l[i][1]]=s\nprint(\" \".join(map(str,r)))\n", "string_ = input()\ns, b = string_.split()\ns = int(s)\nb = int(b)\nstring_ = input()\narr = string_.split()\narr = [int(x) for x in arr]\n\nbase = []\nfor i in range(b):\n    string_ = input()\n    d, g = string_.split()\n    d = int(d)\n    g = int(g)\n    base.append((d, g))\n\nbase.sort()\npref = []\nfor i in range(b):\n    if i == 0:\n        pref.append(base[i][1])\n    else:\n        pref.append(pref[i-1]+base[i][1])\n\n\nfor i in range(s):\n    ans = 0\n    lef, r = 0, b\n    while r-lef > 1:\n        mid = int((r+lef)/2)\n        if base[mid][0] > arr[i]:\n            r = mid\n        else:\n            lef = mid\n    if lef == 0:\n        if base[lef][0] <= arr[i]:\n            ans += pref[lef]\n    else:\n        ans += pref[lef]\n    print(ans, end=\" \")\n\n\n", "def bins(a,k,n1):\n l,h=0,n1-1\n while(l<=h):\n  m=(l+h)//2\n  if(l==h):\n   return m\n  elif(a[m][0]<=k):\n   l=m+1\n  else:\n   h=m-1\n return l\nn,n1=map(int,input().split())\nsp=list(map(int,input().split()))\nde=[]\ns=0\ngosum=[]\nfor i in range(n1):\n d,g=map(int,input().split())\n de+=[[d,g]]\nde.sort()\nfor i in range(n1):\n s+=de[i][1]\n gosum+=[s]\nfor i in range(n):\n ind=bins(de,sp[i],n1)\n if(de[ind][0]>sp[i] and ind!=0):\n  print(gosum[ind-1],end=\" \")\n elif(ind==0 and de[ind][0]>sp[i]):\n  print(0,end=\" \")\n else:\n  print(gosum[ind],end=\" \")\n \n", "import bisect\nfrom collections import OrderedDict\na,b=list(map(int,input().split()))\naray=list(map(int,input().split()))\ndic={}\nans=OrderedDict()\nmax=0\nmin=55555555555\nsumm=0\narr=[]\nanswer=[]\nfor x in range(b):\n    c,d=list(map(int,input().split()))\n    if c not in dic:\n       dic[c]=[d]\n       arr.append(c)\n    else:\n        dic[c].append(d)\n    if c>max:\n        max=c\n    if c<min:\n        min=c\narr.sort()\nfor it in arr:\n    summ+=sum(dic[it])\n    ans[it]=summ\nfor it in aray:\n    if it in ans:\n        answer.append(ans[it])\n    else:\n        if it<min:\n            answer.append(0)\n        elif it>=max:\n            answer.append(ans[max])\n        else:\n            ind = bisect.bisect_left(arr,it)\n            answer.append(ans[arr[ind-1]])\nprint(*answer)", "#!/usr/bin/env python\n\nimport bisect\n\ndef cummulative_sum(arr):\n    #array of tuples\n    acc = 0\n    newarr = [[0,0]]\n    for defence, gold in arr:\n        acc += gold\n        if newarr[-1][0] == defence:\n            newarr[-1][1] += gold\n        else:\n            newarr.append([defence, acc])\n    return newarr\n\nspaceship_count, base_count = list(map(int, input().strip().split()))\nspaceships = list(map(int, input().strip().split()))\nbases = []\nanswer = []\n\nfor _ in range(base_count):\n    d, g = list(map(int, input().strip().split()))\n    bases.append((d, g))\n\nbases.sort()\nbases_prefixes = cummulative_sum(bases)\n#print(bases)\n#print(bases_prefixes)\n\nfor spaceship in spaceships:\n    i = bisect.bisect_right(bases_prefixes, [spaceship, 10**15])\n    #print(f'The spaceship does {spaceship} damage, so it can attack base {i} and collect {bases_prefixes[i-1][1]} gold.')\n    answer.append(bases_prefixes[i-1][1])\n\nprint(*answer)\n", "n, m = list(map(int, input().split()))\na = sorted([(int(x), y) for x, y in zip(input().split(), list(range(n)))])\nb = []\nfor _ in range(m):\n    b.append(list(map(int, input().split())))\nb = sorted(b)\np1 = 0\np2 = 0\ns = 0\nans = [0 for _ in range(len(a))]\nwhile p1 < len(a) and p2 < len(b):\n    # print(p1, p2)\n    if a[p1][0] >= b[p2][0]:\n        s += b[p2][1]\n        p2 += 1\n    else:\n        ans[a[p1][1]] = s\n        p1 += 1\nwhile p1 < len(a):\n    ans[a[p1][1]] = s\n    p1 += 1\nprint(\" \".join(list(map(str, ans))))\n", "from sys import stdin\n\ndef binary(A,x):\n\tN = len(A)\n\tlow,hi=0,N\n\twhile low+1 != hi:\n\t\tmid = low+((hi-low)>>1)\n\t\tif x<A[mid]: hi = mid\n\t\telse: low = mid\n\treturn low\n\n\n\ndef main():\n\ts,b = stdin.readline().split()\n\tline = list(map(int,stdin.readline().split()))\n\tgold = {}\n\tl = list()\n\tfor _ in range(int(b)):\n\t\td,g = map(int,stdin.readline().split())\n\t\tif gold.get(d) == None:\n\t\t\tgold[d] = g\n\t\t\tl.append(d)\n\t\telse:\n\t\t\tgold[d]+= g\n\tl.sort()\n\ti = 1\n\twhile i < len(l):\n\t\tgold[l[i]]+=gold[l[i-1]]\n\t\ti+=1\n\ts = int(s)\n\tfor i in range(s):\n\t\tit = binary(l,line[i])\n\t\tif(i == s-1):\n\t\t\tif(it == 0 and line[i] < l[it]):\n\t\t\t\tprint(0)\n\t\t\telse:\n\t\t\t\tprint(gold[l[it]])\n\t\telse:\n\n\t\t\tif(it == 0 and line[i] < l[it]):\n\t\t\t\tprint(0,end = \" \")\n\t\t\telse:\n\t\t\t\tprint(gold[l[it]],end=\" \")\n\t\t\nmain()", "import bisect\ns,b = map(int,input().split())\na = list(map(int,input().split()))\nd = []\nfor i in range(b):\n    d.append(list(map(int,input().split())))\nd = sorted(d)\nc = []\np = []\nfor i in range(len(d)):\n    c.append(d[i][0])\n    p.append(d[i][1])\nk = [p[0]]\nfor i in range(1,len(p)):\n    k.append(k[-1]+p[i])\nfor i in range(len(a)):\n    l = bisect.bisect_right(c,a[i])\n    if(l==0):\n        print(0,end = ' ')\n    else:\n        print(k[l-1],end = ' ')\n", "s, b = map(int, input().split())\na = list(map(int, input().split()))\nd = []\nfor i in range(b):\n    x, y = map(int, input().split())\n    d.append((x, y, i + 1))\n\nd.sort()\nf = [d[0][1]]\nfor i in range(1, b):\n    f.append(f[-1] + d[i][1])\n\n\nfor i in range(s):\n    if d[0][0] > a[i]:\n        print(0, end=' ')\n    elif d[-1][0] <= a[i]:\n        print(f[-1])\n    else:\n        L = 0\n        R = b - 1\n        while R - L > 1:\n            m = (L + R) // 2\n            if d[m][0] <= a[i]:\n                L = m\n            else:\n                R = m\n        print(f[L], end=' ')\n", "sb = input().split()\ns = int(sb[0])\nb = int(sb[1])\na = list(map(int, input().split()))\nbases = []\n\n#\n# class Base:\n#     def __init__(self,str):\n#         lst = str.split()\n#         d = int(lst[0])\n#         g = int(lst[1])\n#\n#\n# for _ in range(b):\n#     new_base = Base(input())\n#     bases.append(new_base)\n#\n\nfor _ in range(b):\n    dg = list(map(int, input().split()))\n    bases.append(dg)\n\nbases.sort(key=lambda a: a[0])\n\nsum_total = 0\nfor i in bases:\n    sum_total += i[1]\n    i[1] = sum_total\n\ndg = [*zip(*bases)]\n\na_sorted = []\na_sorted += a\na_sorted.sort()\ng = []\nj = 0\nfor i in a_sorted:\n    while j < b:\n        if dg[0][j] > i:\n            if j > 0:\n                g.append(dg[1][j - 1])\n            else:\n                g.append(0)\n            break\n        elif j == b - 1:\n            g.append(dg[1][j])\n            break\n        j += 1\n\n\nfor i in a:\n    index = a_sorted.index(i)\n    print(g[index], end=' ')\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval, stdin\nsetcheckinterval(1000)\n\n# print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n\niin = lambda: int(stdin.readline())\nlin = lambda: list(map(int, stdin.readline().split()))\n\n\ns,b=lin()\nsa=lin()\nba=[lin() for i in range(b)]\nba.sort()\nans=[]\nsol=[]\nfor i,j in ba:\n    sol.append(i)\n    ans.append(j)\nfor i in range(1,b):\n    ans[i]+=ans[i-1]\n\nfrom bisect import bisect_right\na=[]\nfor i in sa:\n    x=bisect_right(sol,i)-1\n    #print(x,ans)\n    if x<0:\n        a.append(0)\n    else:\n        a.append(ans[x])\nprint(*a)", "from sys import stdin, stdout\ndef rsingle_int():\n    return int(stdin.readline().rstrip())\n \ndef rmult_int():\n    return [ int(x) for x in stdin.readline().rstrip().split() ]\n \ndef r_str():\n    return stdin.readline().rstrip()\n    \ndef rsingle_char():\n    return stdin.read(1)\n \ndef main():\n    s, b = rmult_int()\n    a = rmult_int()\n\n    a_order = a.copy()\n    a.sort()\n\n    a_g = {}\n    for el in a:\n        a_g[el] = 0\n\n    ds = []\n    d_g = {}\n    for i in range(b):\n        d, g = rmult_int()\n        if d in d_g:\n            d_g[d] += g\n        else:\n            d_g[d] = g\n            ds.append(d)\n\n    ds.sort()\n    ds_len = len(ds)\n    \n    acc = 0\n    d_i = 0\n    for el in a:\n        while d_i < ds_len and ds[d_i] <= el:\n            acc += d_g[ds[d_i]]\n            d_i += 1\n        a_g[el] = acc\n    \n    out = []\n    for el in a_order:\n        out.append(int(a_g[el]))\n    print(*out)\n\n \nmain()", "import sys\ninput = lambda: sys.stdin.readline().strip()\nfrom bisect import bisect_right\n\ns, b = map(int, input().split())\nls = list(map(int, input().split()))\nd = {}\nfor i in range(b):\n    a, b  = map(int, input().split())\n    try: d[a] += b\n    except: d[a] = b\nkeys = list(d.keys())\nkeys.sort()\nSum = 0\nfor i in keys:\n    Sum+=d[i]\n    d[i] = Sum\nfor i in ls:\n    if bisect_right(keys, i)!=0:\n        print(d[keys[bisect_right(keys, i)-1]], end=' ')\n    else:\n        print(0, end=' ')\nprint()\n", "# cook your dish here\n# cook your dish here\n# cook your dish here\ns,b=list(map(int,input().split(\" \")))\ny=list(map(int,input().split()))\nc=[]\nfor i in range(b):\n    d,g=list(map(int,input().split(' ')))\n    c.append([d,g])\n\nc=sorted(c)\n\nc2=[]\nj=s1=0\nwhile j<b:\n    s1=s1+c[j][1]\n    c2.append(s1)\n    j+=1\n    \nc2.append(0)\ncount=[]\n\nfor i in range(s):\n    \n    start=0\n    end=b-1\n    mid=(start+end)//2\n    while start<=end:\n        if c[mid][0]<=y[i]:\n            start=mid+1\n            end=end\n            mid=(start+end)//2\n        else:\n            start=start\n            end=mid-1\n            mid=(start+end)//2\n    count.append(c2[end])\n    \n    \nprint(*count)\n\n    \n", "from bisect import bisect_right\n\ndef find_le(a, x):\n    'Find rightmost value less than or equal to x'\n    i = bisect_right(a, x)\n    if i:\n        return i-1\n    return -1\n\ns, b = list(map(int,input().split()))\nv = []\na = list(map(int,input().split()))\nfor i in range(b):\n    v.append(tuple(map(int,input().split())))\nv.sort()\nsumma = 0\nc = []\nfor i in v:\n    summa += i[1]\n    c.append(summa)\n\nmas = [i[0] for i in v]\n\nfor i in a:\n    ind = find_le(mas, i)\n    if ind == -1:\n        print(0)\n    else:\n        print(c[ind],end = ' ')", "s, b = list(map(int, input().split()))\nspaceships = list(map(int, input().split()))\n\nbases = [tuple(map(int, input().split())) for i in range(b)]\nbases.sort()\n\nsumbases = [bases[i][1] for i in range(b)]\n\nfor i in range(1, b):\n    sumbases[i] += sumbases[i - 1]\n\ndef search_bases(strength):\n    l, r = 0, b\n    while l < r:\n        m = (l + r)//2\n        if bases[m][0] <= strength:\n            l = m + 1\n        else:\n            r = m\n    return l - 1\n\ndef res(x):\n    i = search_bases(x)\n    if i < 0:\n        return 0\n    else: return sumbases[i]\n\nprint(*tuple(map(res, spaceships)))\n\n"]
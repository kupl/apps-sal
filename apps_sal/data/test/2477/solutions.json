["N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nans = []\nc = 2**30\nr = 2**30\nwhile r:\n    r //= 2\n    l = sum(-(-a//c)-1 for a in A)\n    if l > K:\n        c += r\n    else:\n        ans.append(c)\n        c -= r\n\nprint(ans and min(ans) or 1)", "# coding: utf-8\nimport numpy as np\n\n\ndef solve(*args: str) -> str:\n    n, k = list(map(int, args[0].split()))\n    A = np.array(tuple(map(int, args[1].split())))\n\n    l, r = 0, np.max(A)\n    while l+1 < r:\n        m = (l+r)//2\n        if k < np.sum(-(-A//m)-1):\n            l = m\n        else:\n            r = m\n\n    return str(r)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "import math\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nmini = 0\nmaxi = max(A)\nwhile maxi - mini > 1:\n    mid = (maxi+mini)//2\n    s = sum(math.ceil(a/mid)-1 for a in A)\n    if s>K:\n      mini = mid\n    else:\n      maxi = mid\nprint(mini+1)", "def judge(A, x, k):\n    ans = 0\n    for a in A:\n        ans += a // x\n        if a % x == 0:\n            ans -= 1\n        if ans > k:\n            return False\n    return True\n\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\nl = 0\nr = max(A)\nwhile r - l != 1:\n    x = (r + l) // 2\n    if judge(A, x, k):\n        r = x\n    else:\n        l = x\nprint(r)", "def check(x, A, K):\n    import math\n    sumA = 0\n    for a in A:\n        if a > x:\n            sumA += math.ceil(a / x) - 1\n    if sumA <= K:\n        return True\n    else:\n        return False\n\n\ndef resolve():\n    _, K = [int(i) for i in input().split()]\n    A = [int(i) for i in input().split()]\n\n    ok = max(A)  # maxVal when minimize\n    ng = -1  # maxVal when maximize\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if mid > 0 and check(mid, A, K):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)\n\n\nresolve()\n", "from math import ceil\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nl,r=0,10**9\nwhile r-l>1:\n    m=(r+l)//2\n    count=0\n    for i in a:\n        count+=ceil(i/m)-1\n    if count<=k:\n        r=m\n    else:\n        l=m\nprint(r)", "from math import ceil\nN, K = map(int,input().split())\nA = list(map(int,input().split()))\ndef chk(L):\n    cnt = 0\n    for i in range(N):\n        cnt += ceil(A[i]/L)-1\n    return cnt <= K\nl, r = 1, max(A)\nwhile l <= r:\n    m = (l+r)//2\n    if chk(m):\n        r = m-1\n    else:\n        l = m+1\nprint(min([x for x in [m-1,m,m+1] if x > 0 and chk(x)]))", "N, K = list(map(int, input().split()))\nlogs = list(map(int, input().split()))\nmaxL = max(logs)\n\ndef binsearch(minz, maxz):\n    if minz >= maxz:\n        return minz\n\n    mid = (maxz + minz)//2\n    ncut = 0\n    for i in range(N):\n        thiscut = int((logs[i] + mid - 1)/mid) - 1\n        ncut += thiscut\n        if ncut > K:\n            return binsearch(mid+1, maxz)\n\n    if ncut < K:\n        return binsearch(minz, mid)\n    #else ncut == K\n    maxx = 0\n    for i in range(N):\n        thiscut = int((logs[i] + mid - 1)/mid) - 1\n        thislen = int((logs[i] + thiscut)/(thiscut+1))\n        if maxx < thislen: maxx = thislen\n    return maxx\n\nif K > 0:\n    ans = binsearch(1, maxL+1)\nelse:\n    ans = maxL\nprint(ans)\n", "import math\n\nN,K = map(int,input().split())\nA = list(map(int,input().split()))\n\n#maxA = max(A)\n\n#for i in range(maxA,0,-1):\n#  sum = 0\n#  for j in range(N):\n#    sum += math.ceil(A[j]/i)-1\n#  if(sum>K):\n#    print(i+1)\n#    break\n\nlow = 0\nhigh = max(A)\nwhile low <= high:\n  if(high==low):\n    break\n  mid = (low+high)//2\n  if(mid==0):\n    break\n  sum = 0\n  for i in range(N):\n    sum += math.ceil(A[i]/mid)-1\n  #print('low:'+str(low)+',mid:'+str(mid)+',high:'+str(high)+',sum:'+str(sum))\n  if(sum>K):\n    low = mid + 1\n  else:\n    high = mid\n\nprint(high)", "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_l = 10**9\nmin_l = 0\nwhile max_l - min_l != 1:\n    count = 0\n    mean = (max_l+min_l)//2\n    for i in range(n):\n        count += -(-a[i]//mean)-1\n    if count <= k:\n        max_l = mean\n    else:\n        min_l = mean\nprint(max_l)", "import math\n\nN, K = (int(a) for a in input().split())\nA = [int(a) for a in input().split()]\n\ndef isOK(X):\n    cutcount = 0\n    for i in range(N):\n        cutcount += math.ceil(A[i] / X) - 1\n    if cutcount <= K:\n        return True\n    else:\n        return False\n\ndef binary_search():\n    left = 0\n    right = max(A) + 1\n\n    while (right - left) > 1:\n        mid = left + (right - left) // 2\n        if (isOK(mid)):\n           right = mid;\n        else:\n            left = mid;\n\n    return right\n\nprint(binary_search())", "from math import ceil\n\ndef check(x):\n    cnt = 0\n    for a in A:\n        cnt += ceil(a/x)-1\n    return cnt <= K\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nleft = 0\nright = max(A)\nwhile left < right-1:\n    mid = (left+right)//2\n    if check(mid):\n        right = mid\n    else:\n        left = mid\nprint(right)\n", "# \u5165\u529b\n# \u5024\u306f\u5168\u3066int\n# N\u306f\u672c\u6570\u3001K\u306f\u5207\u308b\u56de\u6570\u3001A\u306fN\u672c\u306e\u6728\u306e\u305d\u308c\u305e\u308c\u306e\u9577\u3055(\u30ea\u30b9\u30c8)\nN,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\n# \u4e8c\u5206\u63a2\u7d22\n# l\u304c\u5de6\u7aef\u3001r\u304c\u53f3\u7aef\nl,r = 0, 10**9\n\n# \u6574\u6570\u3067\u8fd4\u3059\u306e\u3067\u3001\u5dee\u304c\uff11\u3088\u308a\u5927\u304d\u3044\u6642\u306f\u30eb\u30fc\u30d7\u3059\u308b\nwhile r - l > 1:\n    # \u771f\u3093\u4e2d\u3092\u8a2d\u5b9a\n    x = (r+l) // 2\n\n    # \u5207\u308b\u56de\u6570\u3092c\n    c = 0\n    for a in A:\n        # \u305d\u308c\u305e\u308c\u306e\u4e38\u592a\u306e(\u9577\u3055-1)\u3092x\u3067\u5272\u3063\u305f\u5024\u306e\u5408\u8a08\u304c\u3001\u5207\u308b\u56de\u6570\n        c += (a-1) // x \n\n    # \u5207\u308b\u56de\u6570\u304cK\u3088\u308a\u3082\u5c0f\u3055\u3044\u6642\u306fOK\u306a\u306e\u3067\u53f3\u7aef\u3092\u5bc4\u305b\u308b\n    if c <= K:\n        r = x\n    else:\n        l = x\n    \nprint(r)\n", "n,k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef check(length):\n    cuttings = sum((l + length -1)//length - 1 for l in a)\n    return cuttings <= k\n\nl,r = 0,max(a)\n\nwhile l + 1 < r:\n    mid = (l+r)//2\n    if check(mid):\n        r = mid\n    else:\n        l = mid\n\nprint(r)\n", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nng = 0\nok = max(a)\nwhile ng + 1 != ok:\n    mid = (ng + ok) // 2\n    ans = 0\n    for aa in a:\n        if aa%mid == 0:\n            ans += aa//mid-1\n        else:\n            ans += aa//mid\n    if ans <= k:\n        ok = mid\n    else:\n        ng = mid\nprint(ok)", "# coding: utf-8\n# Your code here!\nN,K=map(int,input().split())\n\nA=list(map(float, input().split()))\n\nlow=0\nhigh=10**9+1\n\nwhile high-low!=1:\n    mid=(high+low)//2\n    cut_temp=0\n    ans=-1\n    \n    for a in A:\n        cut_temp+=-(-a//mid)-1\n    if cut_temp>K:\n        low=mid\n    else:\n        high=mid\n    \nprint(high)", "N,K=map(int,input().split())\nl=list(map(int,input().split()))\nimport math\ndef f(n):\n   A=0\n   for i in l:\n      A+=math.ceil(i/n)-1\n   return A<=K\ndef bis(ng,ok):\n   while abs(ok-ng)>1:\n      mid=(ok+ng)//2\n      if f(mid):\n         ok=mid\n      else:\n         ng=mid\n   return ok\nprint(bis(0,max(l)))", "# coding: utf-8\n\ndef solve(*args: str) -> str:\n    n, k = list(map(int, args[0].split()))\n    A = tuple(map(int, args[1].split()))\n\n    l, r = 1, max(A)\n    while 0.1 < r-l:\n        m = (l+r)/2\n        cnt = 0\n        for a in A:\n            cnt += -int(-a//m)-1\n\n        if k < cnt:\n            l = m\n        else:\n            r = m\n\n    return str(-int(-l//1))\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "def is_ok(x):\n    sum=0\n    for i in range(n):\n        sum+=(a[i]+x-1)//x-1\n    if sum<=k:return True\n    else :return False\n\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nif is_ok(1):\n    print(1)\n    return\nprint(meguru_bisect(1,int(1e10)))", "import math\nn,k = list(map(int,input().split()))\na = list(map(int,input().split()))\n\nl = 0\nr = 10**9\nwhile r - l > 1:\n    m = (l+r) // 2\n    cnt = 0\n    for i in a:\n        cnt += math.ceil(i / m) - 1\n    if cnt <= k:\n        r = m\n    else:\n        l = m\nprint((l+1))\n", "# import itertools\n# import math\n# from functools import reduce\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n# B_ = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n#def make_divisors(n):\n#    lower_divisors , upper_divisors = [], []\n#    i = 1\n#    while i*i <= n:\n#        if n % i == 0:\n#            lower_divisors.append(i)\n#            if i != n // i:\n#                upper_divisors.append(n//i)\n#        i += 1\n#    return lower_divisors + upper_divisors[::-1]\n\n# def gcd_list(numbers):\n#     return reduce(math.gcd, numbers)\n\n# if gcd_list(A) > 1:\n#     print(\"not coprime\")\n#     return\n\n# \u9ad8\u901f\u7d20\u56e0\u6570\u5206\u89e3\u6e96\u5099\n#MAXN = 10**6+10\n#sieve = [i for i in range(MAXN+1)]\n#p = 2\n#while p*p <= MAXN:\n#    if sieve[p] == p:\n#        for q in range(2*p, MAXN+1, p):\n#            if sieve[q] == q:\n#                sieve[q] = p\n#    p += 1\n\ndef num_of_chopping(l, threshold):\n    cnt = 0\n    for i in l:\n        cnt += -(-i // threshold) - 1\n    return cnt\n\nlow = 0\nhigh = max(A)\nwhile low + 1 < high:\n    mid = (low + high) // 2\n    cnt = num_of_chopping(A, mid)\n    if cnt <= K:\n        high = mid\n    else:\n        low = mid\n    \nprint(high)", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef is_ok(mid):\n    x = 0\n    for a in A:\n        x += -(-a//mid)-1\n    if x <= K:\n        return True\n    return False\n\ndef meguru_bisect(ng, ok):\n    '''\n    \u521d\u671f\u5024\u306eng,ok\u3092\u53d7\u3051\u53d6\u308a,is_ok\u3092\u6e80\u305f\u3059\u6700\u5c0f(\u6700\u5927)\u306eok\u3092\u8fd4\u3059\n    \u307e\u305ais_ok\u3092\u5b9a\u7fa9\u3059\u3079\u3057\n    ng ok \u306f  \u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1 \u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n    \u6700\u5927\u6700\u5c0f\u304c\u9006\u306e\u5834\u5408\u306f\u3088\u3057\u306a\u306b\u3072\u3063\u304f\u308a\u8fd4\u3059\n    '''\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nprint(meguru_bisect(0, max(A)))", "def main():\n    n, k = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    L, R = 0, max(arr)\n    while L+1 < R:\n        P = (L+R+1)//2\n        cnt = 0\n        for a in arr:\n            if P < a:\n                if a % P == 0:\n                    cnt += a//P - 1\n                else:\n                    cnt += a//P\n        if cnt <= k:\n            R = P\n        else:\n            L = P\n    print(R)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\nimport math\n\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    def check(length :int) -> bool:\n        cnt = 0\n\n        for a in A_list:\n            if a >= length:\n                divide = math.ceil(a / length)\n                cnt += (divide - 1)\n        \n        return (True if cnt <= K else False)\n\n\n    L = 0            # the minimum length\n    R = max(A_list)  # the maximum length\n\n    while (R - L) > 1:\n        M = L + (R - L) // 2\n\n        if check(M):\n            R = M\n        else:\n            L = M\n\n\n    print(R)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def is_ok(x):\n    cnt = 0\n    for a in A:\n        cnt += -(-a//x)-1\n    if cnt <= k:\n        return True\n    return False\n\n\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n    \nn, k = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\nprint((meguru_bisect(0,10**9+1)))\n", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\ndef check(l):\n    count = 0\n    for L in A:\n        count += L // l\n        if L % l != 0:\n            count += 1\n        count -= 1\n    return count <= K\n\nbottom, top = 0, max(A)\n\nwhile top - bottom > 1:\n    mid = (top + bottom) // 2\n    if check(mid):\n        top = mid\n    else:\n        bottom = mid\n\nprint(top)\n", "N, K = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\n\ndef f(t):\n    if t!=0:\n        c = 0\n        for i in A:\n            c += i//t if i!=t else 0\n        return c<=K\n    else:\n        return all(i<=t for i in A)\n\nleft, right = -1, 10**10\nwhile right-left>1:\n    m = (right+left)//2\n    if f(m):\n        right = m\n    else:\n        left = m\n\nprint(right)\n", "N,K=map(int,input().split())\n*A,=map(int,input().split())\n\ndef C(x):\n  return sum([(A[i]-.5)//x for i in range(N)]) <= K\n  \ndef binary_search2(func, n_min, n_max):\n    left,right=n_min,n_max\n    while right-left>1:\n        middle = (left+right)//2\n        y_middle = func(middle)\n        if y_middle: right=middle\n        else: left=middle\n\n    return right\n  \nprint(binary_search2(C, 0, max(A)+1))", "n,k=map(int,input().split())\na=list(map(int,input().split()))\nl,r=10**9,0\nwhile l-r>1:\n    t=(l+r)//2\n    if sum((i-1)//t for i in a)>k:\n        r=t\n    else:\n        l=t\nprint(l)", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nfrom decimal import Decimal, ROUND_HALF_UP\n\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n \n \n    def check(length :int) -> bool:\n        cnt = 0\n \n        for a in A_list:\n            if a >= length:\n                divide = math.ceil(a / length)\n                cnt += (divide - 1)\n        \n        return (True if cnt <= K else False)\n \n \n    L = 0.1          # the minimum length\n    R = max(A_list)  # the maximum length\n \n    while (R - L) > 0.01:\n        M = L + (R - L) / 2\n \n        if check(M):\n            R = M\n        else:\n            L = M\n    \n    \n    ans = Decimal(str(M)).quantize(Decimal('1E-1'), rounding=ROUND_HALF_UP)\n    ans = math.ceil(ans)\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque, defaultdict, Counter\nfrom itertools import accumulate, product, permutations, combinations\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heappop, heappush\nfrom math import ceil, floor, sqrt, gcd, inf\nfrom copy import deepcopy\nimport numpy as np\nimport scipy as sp\n\nINF = inf\nMOD = 1000000007\n\nn, k = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\n\ntmp = 0\nres = inf\nlow = 0\nhigh = max(A)\nwhile low <= high:\n    mid = (low + high) // 2\n    tmp = 0\n    for i in range(n):\n        if mid > 0:\n            tmp += ceil(A[i] / mid) - 1\n        else:\n            tmp = inf\n    if tmp <= k:\n        res = min(res, mid)\n        high = mid - 1\n    else:\n        low = mid + 1\n\nprint(res)\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom decimal import Decimal, ROUND_HALF_UP\n\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    def check(length :int) -> bool:\n        cnt = 0\n\n        for a in A_list:\n            if a >= length:\n                quotient = a / length\n                divide = -(-quotient // 1)  # round up\n                cnt += (divide - 1)\n        \n        return (True if cnt <= K else False)\n\n\n    L = 0.1            # the minimum length\n    R = max(A_list)  # the maximum length\n\n    while (R - L) > 0.01:\n        M = L + (R - L) / 2\n\n        if check(M):\n            R = M\n        else:\n            L = M\n    \n    \n    ans = float( Decimal(str(M)).quantize(Decimal('1E-1'), rounding=ROUND_HALF_UP) )\n    ans = -(-ans // 1)  # round up\n    print(( int(ans) ))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nN, K=map(int,input().split())\nA=list(map(int,input().split()))\n\ndef judge(ans,K,A):\n    cut=0\n    for i in range(len(A)):\n        cut+=(A[i]-1)//ans\n    if cut>K:\n        return False\n    else:\n        return True\n\n\nansp=max(A)\nansm=0\nans=(ansp+ansm)//2\nd=1\nwhile ansp-ansm>d:\n    \n    if judge(ans,K,A):\n        ansp=ans\n        \n    else:\n        ansm=ans\n        \n    ans=(ansp+ansm)//2\nprint(ansp)", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nl = 0\nr = 10**9\nwhile (r-l>1):\n    x = (r+l)//2\n    now = 0\n    for a in A:\n        now += (a-1)//x\n    if now <= K:\n        r = x\n    else:\n        l = x\nprint(r)", "N,K = map(int,input().split())\nA = list(map(int,input().split()))\n\ndef f(x):\n    if x!= 0:\n        now = 0\n        for i in range(N):\n            now += (A[i]-1)//x\n        return now <= K\n    else:\n        return False\nl = 0; r = 10**10\nwhile r-l > 1:\n    x = (l+r)//2\n    if f(x):\n        r = x\n    else:\n        l = x\nprint(r)", "import numpy as np\n\nN, K = [int(x) for x in input().split()]\nA = np.array([int(x) for x in input().split()])\nI = np.array([1] * N)\n\nL = np.max(A)\n\nans = L\nlow = 1\nhigh = L\nwhile 1:\n    if low == high:\n        ans = low\n        break\n    \n    mid = (low + high) // 2\n    if np.sum((A - I) // mid) <= K:\n        high = mid\n    else:\n        low = mid + 1\n\nprint(ans)", "def main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n\n    def value(v):\n        cnt = 0\n        for i in a:\n            cnt += (i-1)//v\n        if cnt > k:\n            return False\n        else:\n            return True\n\n    def b_search(ok, ng, value):\n        while abs(ok-ng) > 1:\n            mid = (ok+ng)//2\n            if value(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n\n    print((b_search(10**16, 0, value)))\n\n\nmain()\n", "import math\n\nN,K=map(int,input().split())\nA=list(map(int, input().split()))\nl=0\nr=max(A)\nwhile not l+1==r:\n    x=(r+l)//2\n    k=0\n    for a in A:\n        k+=math.ceil(a/x)-1\n    if k<=K:\n        r=x\n    else:\n        l=x\nprint(r)", "from math import ceil\nn,k=map(int,input().split())\na=[int(i) for i in input().split()]\ndef is_ok(x):\n  c=0\n  for i in a:\n    c+=ceil(i/x)-1\n    if c>k:\n      return False\n  return True\ndef binary_search(m): \n  left=0\n  right=m+1\n  while left<=right:\n    center=(left+right)//2\n    if right-left==1:\n      return right\n    elif is_ok(center):\n      right=center\n    else:\n      left=center\nif k==0:\n  print(max(a))\nelse:\n  print(binary_search(max(a)))", "n,k = map(int, input().split())\nalist=list(map(int, input().split()))\ndef is_ok(arg):\n    cnt=0\n    for i in alist:\n      cnt+=(i-1)//arg\n    return cnt<=k\ndef nibun(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\nprint(nibun(0 , 10**9 + 1))", "import sys\nimport heapq\nimport math\ndef input(): return sys.stdin.readline().rstrip()\ndef main():\n    n, k = map(int,input().split())\n    A = list(map(int,input().split()))\n    def is_good(mid, key):\n        kk = 0\n        for a in A:\n            kk += -(-a//mid)-1\n        if kk <= key:\n            return True\n        else:\n            return False\n    def bi_search(bad, good, key):\n        while good - bad > 1:\n            mid = (bad + good)//2\n            if is_good(mid, key):\n                good = mid\n            else:\n                bad = mid\n        return good\n    \n    print(bi_search(0, 1000000000, k))\n    \n    \n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "N,K = map(int,input().split())\nA = list(map(int,input().split()))\n\ndef f(n):\n    now = 0\n    for i in range(N):\n        now += (A[i]-1)//x\n    if now <= K:\n        return True\n    else:\n        return False\n\nl = 0; r = 10**10\nwhile r-l > 1:\n    x = (l+r)//2\n    if f(x):\n        r = x\n    else:\n        l = x\nprint(r)", "import math\n\nn,k = (int(x) for x in input().split())\nAn = [int(i) for i in input().split()]\n\nleft = 0\nright = max(An)\n\ndef check(x):\n    chk = 0\n    for i in range(n):\n        chk += math.ceil(An[i]/x)-1\n    return chk\n\nwhile right-left!=1:\n    x = (left+right)//2\n    if check(x)<=k:\n        right = x\n    else:\n        left = x\n\nprint(right)", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nl = 0; r = 10**9\nwhile r-l > 1:\n    b = 0; x = (l+r)//2\n    for i in range(n): b += (a[i]-1)//x\n    if k < b:\n        l = x\n    else:\n        r = x\nprint(r)", "import sys\n\nn, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\n\nl, r = 0, max(a)\nwhile r - l > 1:\n  # satisfy l < t < r\n  t = (l + r) // 2\n  c = sum([(e-1) // t for e in a])\n  if k < c:\n    l = t\n  else:\n    r = t\nprint(r)", "N, K = map(int, input().split())\nA = [int(i) for i in input().split()]\n\ndef f(length, ls):\n    cur = 0\n    for a in ls:\n        if a%length == 0:\n            cur += a//length - 1\n        else:\n            cur += a//length\n    if cur <= K:\n        return True\n    else:\n        return False\n\nok, ng = max(A), 0\nwhile abs(ok - ng) > 1:\n    z = (ok+ng)//2\n    if f(z, A) == True:\n        ok = z\n    else:\n        ng = z\nprint(ok)", "from sys import stdin\nimport numpy as np\nn, k = list(map(int, stdin.readline().split()))\na = np.array(stdin.readline().split(), dtype=np.int64)\n\nng = 0\nok = 10 ** 9 + 1\nwhile ok - ng > 1:\n    mid = (ok + ng) >> 1\n    if np.sum(0 - - a // mid - 1) <= k:\n        ok = mid\n    else:\n        ng = mid\nprint(ok)\n", "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\nMOD2 = 998244353\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n    N, K = NMI()\n    A = NLI()\n    \n    ng = 0       #ng:\u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1\n    ok = 10**9+10  #ok:\u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n\n        cut = 0\n        for a in A:\n            if a % mid == 0:\n                cut += math.floor(a/mid)-1\n            else:\n                cut += math.floor(a/mid)\n\n\n        if cut <= K:\n            ok = mid\n        else:\n            ng = mid\n\n    print(ok)\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "n,k=map(int,input().split())\na=list(map(int, input().split()))\na.sort()\n\nfrom math import ceil\n\ndef is_ok(l):\n    cnt=0\n    for i in range(n):\n        cnt+=ceil(a[i]/l)-1\n    return True if cnt<=k else False\n\ndef meguru_bisect(ng, ok):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if is_ok(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n\nprint(meguru_bisect(0,a[-1]+1))", "\ndef fun(X_high, X_low, K, line):\n    X = (X_high + X_low) // 2\n    cnt = 0\n    for tree in line:\n        if tree <= X:\n            continue\n        else:\n            q, r = divmod(tree, X)\n            if r == 0:\n                q -= 1\n            cnt += q\n    if cnt > K:\n        X_low = X\n    else:\n        X_high = X\n    return X_high, X_low\n\nN, K = map(int, input().split(\" \"))\nline = list(map(int, input().split(\" \")))\n\nX_high = max(line)\nX_low = 0\n\nwhile (X_high - X_low) > 1:\n    X_high, X_low = fun(X_high, X_low, K, line)\n    \nprint(X_high)", "from math import ceil\n\n\ndef check(x):\n    # \u5168\u3066\u3092\u9577\u3055x\u4ee5\u4e0b\u306b\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u56de\u6570\n    cnt = 0\n    for a in A:\n        # \u5207\u308b\u56de\u6570\u306f-1\u3057\u305f\u56de\u6570\u3002a=20 x=4 20/4=5 \u3060\u304c\u5207\u308b\u7b87\u6240\u306f4\u3002\n        cnt += ceil(a/x)-1\n    return cnt <= K\n\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nleft = 0\nright = max(A)\nwhile left < right-1:\n    mid = (left+right)//2\n    if check(mid):\n        right = mid\n    else:\n        left = mid\nprint(right)\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom decimal import Decimal, ROUND_HALF_UP\n\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    def check(length :int) -> bool:\n        cnt = 0\n\n        for a in A_list:\n            if a >= length:\n                quotient = a / length\n                divide = -(-quotient // 1)  # round up\n                cnt += (divide - 1)\n        \n        return (True if cnt <= K else False)\n\n\n    L = 0            # the minimum length\n    R = max(A_list)  # the maximum length\n\n    while (R - L) > 1:\n        M = L + (R - L) // 2\n\n        if check(M):\n            R = M\n        else:\n            L = M\n\n\n    print(R)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nn,k=map(int, input().split())\na=list(map(int, input().split()))\nright=max(a)\nleft=0\ndef cutable(a,x):\n    count=0\n    for i in a:\n        count+=math.ceil(i/x)-1\n    return count<=k\nwhile right>left+1:\n    mid=(right+left)//2\n    if cutable(a,mid):\n        right=mid\n    else:\n        left=mid\nprint(right)", "import math\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nleft = 0\nright = max(A)\n\nwhile right - left > 1:\n    mid = (left + right) // 2\n    jk = 0\n    for i in range(N):\n        jk += A[i] // mid - 1\n        if A[i] % mid != 0: jk += 1\n    if jk <= K:\n        right = mid\n    else:\n        left = mid\n\nprint(right)", "N, K = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\n\ndef f(t):\n    return sum(i//t if i!=t else 0 for i in A)<=K if t else all(i<=t for i in A)\n\nl, r = -1, 10**10\nwhile r-l>1:\n    m = (r+l)//2\n    if f(m):\n        r = m\n    else:\n        l = m\n\nprint(r)\n", "# -*- coding: utf-8 -*-\nimport numpy as np\nimport sys\nfrom collections import deque\nfrom collections import defaultdict\nimport heapq\nimport collections\nimport itertools\nimport bisect\nfrom scipy.special import comb\nimport copy\nsys.setrecursionlimit(10**6)\n# \u5207\u308a\u4e0a\u3052\u5272\u308a\u7b97\n# -(-4 // 3)\n# lis_of_lis = [[] for _ in range(N)]\n\n\ndef zz():\n    return list(map(int, sys.stdin.readline().split()))\n\n\ndef z():\n    return int(sys.stdin.readline())\n\n\ndef S():\n    return sys.stdin.readline()[:-1]\n\n\ndef C(line):\n    return [sys.stdin.readline() for _ in range(line)]\n\n\nN, K = zz()\nA = zz()\nmax_a = max(A)\nrest = K\n# \u7b54\u3048\u306fX\u4ee5\u4e0b\u304b\uff1f\u3092\u8003\u3048\u308b\n# \u9577\u3055a\u306e\u4e38\u592a\u3092\u5207\u3063\u3066X\u4ee5\u4e0b\u306b\u3059\u308b\u305f\u3081\u306b\u306f\u3001\n# -(-a//X)\u56de\u5207\u308b\u5fc5\u8981\u304c\u3042\u308b\n\n\ndef trial(x):\n    # print('try', x)\n    num_cut = 0\n    for a in A:\n        num_cut += (-(-a//x)-1)\n        # print('num_cut', num_cut)\n        if (num_cut > K):\n            return False\n    return True\n\n\n# \u7b54\u3048\u306e\u7bc4\u56f2\u306f0~max(A)\nl = 0\nr = max_a\nwhile (r - l > 1):\n    ans = (l + r) // 2\n    if (trial(ans)):\n        # print(ans)\n        r = ans\n    else:\n        l = ans\nprint(r)\n", "from sys import stdin\nimport numpy as np\nn, k = list(map(int, stdin.readline().split()))\na = np.array(stdin.readline().split(), dtype=np.int64)\n\nng = 0\nok = 10 ** 9 + 1\nwhile ok - ng > 1:\n    mid = (ok + ng) >> 1\n    if np.sum(np.ceil(a / mid) - 1) <= k:\n        ok = mid\n    else:\n        ng = mid\nprint(ok)\n", "def waru(a,b):\n  if a%b==0:\n    return a//b\n  else:\n    return (a//b)+1\nN,K=map(int,input().split())\nA=list(map(int,input().split()))\nue=sum(A)\nsita=1\nfor i in range(50):\n  n=(ue+sita)//2\n  L=[waru(i,n)-1 for i in A]\n  if sum(L)>K:\n    sita=n\n  else:\n    ue=n\n  if ue==sita:\n    print(ue)\n    return\n  elif ue-sita==1:\n    n=sita\n    L=[waru(i,n)-1 for i in A]\n    if sum(L)>K:\n      print(n+1)\n      return\n    else:\n      print(n)\n      return", "# -*- coding: utf-8 -*-\nimport sys\nimport math\n\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    def check(length :int) -> bool:\n        cnt = 0\n\n        for a in A_list:\n            if a >= length:\n                quotient = a / length\n                #divide = -(-quotient // 1)  # round up\n                divide = math.ceil(quotient)  # round up\n                cnt += (divide - 1)\n        \n        return (True if cnt <= K else False)\n\n\n    L = 0            # the minimum length\n    R = max(A_list)  # the maximum length\n\n    while (R - L) > 1:\n        M = L + (R - L) // 2\n\n        if check(M):\n            R = M\n        else:\n            L = M\n\n\n    print(R)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nr = max(A)\nl = 0\n\nwhile l+1 < r:\n    mid = (l+r)//2\n    cnt = 0\n    for a in A:\n        if(a > mid):\n            if(a%mid == 0):\n                cnt += (a//mid)-1\n            else:\n                cnt += a//mid\n    if(cnt > K):\n        l = mid\n    else:\n        r = mid\nprint(r)", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef check(x):\n  c = 0\n  for i in range(n):\n    c += a[i]//x\n    if a[i]%x == 0:\n      c -= 1\n  if c <= k:\n    return True\n  else:\n    return False\n\nmx = max(a)\nmn = 0\nans = [mx]\nwhile mn <= mx:\n  m = (mx+mn)//2\n  if m == 0:\n    if check(1):\n      ans.append(1)\n    break\n  if check(m):\n    mx = m - 1\n    ans.append(m)\n  else:\n    mn = m + 1\nprint((min(ans)))\n", "n, k = [int(i) for i in input().split()]\nwoods = [int(i) for i in input().split()]\n\n\ndef k_cut_less_than(k, l, woods):\n    kaisuu = 0\n    for wood in woods:\n        kaisuu += (wood-1) // l\n    if kaisuu <= k:\n        return False\n    return True\n\n\n# \u4e8c\u5206\u63a2\u7d22\n# function\u3092\u6e80\u305f\u3059,search_list\u306e\u6700\u5927\u306e\u8981\u7d20\u3092\u51fa\u529b\n# \u3010\u6ce8\u610f\u70b9\u3011search\u30ea\u30b9\u30c8\u306e\u521d\u3081\u306e\u65b9\u306ffunction\u3092\u6e80\u305f\u3057\u3001\u5f8c\u308d\u306b\u884c\u304f\u306b\u3064\u308c\u3066\u6e80\u305f\u3055\u306a\u304f\u306a\u308b\u3079\u304d\nimport math\n\n\ndef binary_research(start, end,  function):\n    if start == end:\n        return start\n    middle = math.ceil((start + end) / 2)\n    if function(k, middle, woods):\n        start = middle\n    else:\n        end = middle - 1\n    return binary_research(start, end, function)\n\nstart=0\nend=10**9\nprint((binary_research(start,end,k_cut_less_than)+1))\n\n\n", "n, k = map(int, input().split())\na = [i-1 for i in map(int, input().split())]\nleft, right = 1, 10**9\nwhile left < right:\n    middle = (left + right)//2\n    count = sum(i//middle for i in a)\n    if count <= k:\n        right = middle\n    else:\n        left = middle + 1\nprint(left)", "n, k = map(int, input().split())\na = [i-1 for i in map(int, input().split())]\n\nleft, right = 1, 10**9\nwhile left < right:\n    middle = (left + right)//2\n\n    count = 0\n    for i in a:\n        count += i//middle\n    \n    if count <= k:\n        right = middle\n    else:\n        left = middle + 1\n\nprint(left)", "from math import ceil\n\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\ndef f(x):\n    cnt = 0\n    for a in A:\n        cnt += ceil(a / x) - 1\n    return True if cnt <= K else False\n\nOK, NG = 10**9, 0\nwhile OK - NG > 1:\n    mid = (OK + NG) // 2\n    if f(mid):\n        OK = mid\n    else:\n        NG = mid\n\nprint(OK)\n", "n,k=map(int,input().split())\n*a,=map(int,input().split())\nl,r=0,10**9\nwhile r-l>1:\n    m=(l+r)//2\n    t=0\n    for x in a:\n        if x<=m:\n            continue\n        t+=(x+m-1)//m-1\n    if t<=k:\n        r=m\n    else:\n        l=m\nprint(r)", "# coding: utf-8\nimport numpy as np\n\n\ndef solve(*args: str) -> str:\n    n, k = list(map(int, args[0].split()))\n    A = np.array(tuple(map(int, args[1].split())))\n\n    l, r = 0, np.max(A)\n    while l+1 < r:\n        m = (l+r)//2\n        if k < np.sum(np.ceil(A/m)-1):\n            l = m\n        else:\n            r = m\n\n    return str(r)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "def is_good(mid, key):\n    res = 0\n    for a in A:\n        res += (a + mid - 1) // mid\n    return res - N <= key\n\n\ndef binary_search(bad, good, key):\n    while good - bad > 1:\n        mid = (bad + good) // 2\n        if is_good(mid, key):\n            good = mid\n        else:\n            bad = mid\n    return good\n\n\nN, K, *A = list(map(int, open(0).read().split()))\nprint((binary_search(0, 1_000_000_000, K)))\n", "# region header\nimport sys, bisect, math, itertools, heapq, collections\nfrom operator import itemgetter\n# a.sort(key=itemgetter(i)) # i\u756a\u76ee\u8981\u7d20\u3067sort\nfrom functools import lru_cache\nimport copy\n# @lru_cache(maxsize=None)\n# sys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nmod = 10**9 + 7\neps = 10**-7\n# endregion\n# region input function\n\n\ndef inp():\n    '''\n    \u4e00\u3064\u306e\u6574\u6570\n    '''\n    return int(input())\n\n\ndef inpl():\n    '''\n    \u4e00\u884c\u306b\u8907\u6570\u306e\u6574\u6570\n    '''\n    return list(map(int, input().split()))\n\n\ndef str_inp():\n    '''\n    \u6587\u5b57\u5217\u3092\u30ea\u30b9\u30c8\u3068\u3057\u3066\u8aad\u307f\u8fbc\u3080\n    '''\n    return list(input()[:-1])\n\n# endregion\n\n\nn, k = inpl()\na = inpl()\n\nl = 0\nr = 10**9\nwhile l + 1 < r:\n    x = (l + r) // 2\n    cnt = 0\n    for i in range(n):\n        cnt += math.ceil(a[i] / x) - 1\n        if cnt > k:\n            break\n    if cnt <= k:\n        r = x\n    else:\n        l = x\nprint(r)\n", "_, k = list(map(int, input().split()))\nA = [*[int(x)-1 for x in input().split()]]\nng, ok = 0, 1<<30\nwhile ok - ng > 1:\n    m = (ng + ok) // 2\n    if k < sum(a//m for a in A): ng = m\n    else: ok = m\nprint(ok)\n", "import math\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ndef flag(mid):\n    count = 0\n    for a0 in a:\n        count += math.ceil(a0/mid)-1\n    if count <= k:\n        return True\n    else:\n        return False\n        \ndef cal(i, j):\n\n    while abs(i-j) > 1:\n        mid = (i+j)//2\n        if flag(mid):\n            j = mid\n        else:\n            i = mid\n    print(j)\n    \ncal(0, max(a))    \n", "n, k, *a = list(map(int, open(0).read().split()))\n\n\ndef c(x):\n    res = 0\n    for b in a:\n        # b\u3092\u6700\u5927\u304cx\u306b\u306a\u308b\u3088\u3046\u306b\u3001\u3067\u304d\u308b\u3060\u3051\u5c11\u306a\u3044\u56de\u6570\u3067\n        # \u3060\u3044\u305f\u3044b/x\u7b49\u5206\uff1f\n        res += 0 - - b // x - 1\n    return res <= k\n\n\nng = 0\nok = 10 ** 10\nwhile ok - ng > 1:\n    mid = (ok + ng) >> 1\n    if c(mid):\n        ok = mid\n    else:\n        ng = mid\nprint(ok)\n", "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nlow = 0\nhigh = max(a)\n\nwhile low + 1 < high:\n    mid = (low + high) // 2\n    m = 0\n    for x in a:\n        m += (x - 1) // mid\n    \n    if m <= k:\n        high = mid\n    else:\n        low = mid\n\nprint(high)", "import sys\nimport heapq\nimport math\ndef input(): return sys.stdin.readline().rstrip()\ndef main():\n    n, k = map(int,input().split())\n    A = list(map(int,input().split()))\n    def is_good(mid, key):\n        kk = 0\n        for a in A:\n            kk += -(-a//mid)-1\n        if kk <= key:\n            return True\n        else:\n            return False\n    def bi_search(bad, good, key):\n        while good - bad > 1:\n            mid = (bad + good)//2\n            if is_good(mid, key):\n                good = mid\n            else:\n                bad = mid\n        return good\n    \n    print(bi_search(0, max(A), k))\n    \n    \n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k,*A=map(int,open(0).read().split());l=1;r=max(A)\nwhile l!=r:\n  c=(l+r)//2\n  if k>=sum(-(-a//c)-1 for a in A):r=c\n  else:l=c+1\nprint(l)", "n,k = map(int,input().split())\na = list(map(int,input().split()))\n\ndef is_ok(l):\n  cnt = 0\n  for L in a:\n    cnt += -(-L//l)-1\n  return cnt<=k\n\ndef bisect(top,bot):\n    while top - bot > 1:\n        mid = (top + bot)//2\n        if is_ok(mid):\n            top = mid\n        else:\n            bot = mid\n    return top\n\nprint(bisect(max(a),0))", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\ndef isOK(x):\n    cnt = 0\n    for a in A:\n        cnt += (a + x - 1) // x - 1\n    return cnt <= K\n\nleft, right = 0, 10 ** 10\nwhile right - left > 1:\n    mid = (left + right) // 2\n    if isOK(mid):\n        right = mid\n    else:\n        left = mid\nprint(right)\n", "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef is_ok(x,a,k):\n    b = 0\n    for ai in a:\n        b += math.ceil(ai/x)\n        b -= 1\n    if b <= k:\n        return True\n\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid,a,k):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n\nprint(meguru_bisect(0,max(a)))", "N,K=map(int,input().split())\n*A,=map(int,input().split())\n\ndef C(x):\n  return sum([(A[i]+x-1)//x-1 for i in range(N)]) <= K\n  \ndef binary_search2(func, n_min, n_max):\n    left,right=n_min,n_max\n    while right-left>1:\n        middle = (left+right)//2\n        y_middle = func(middle)\n        if y_middle: right=middle\n        else: left=middle\n\n    return right\n  \nprint(binary_search2(C, 0, max(A)+1))", "n, k = map(int, input().split())\nA = tuple(map(int, input().split()))\nA = sorted(A, reverse=True)\n\nl = 0\nr = max(A)+1\ndef cut(l, k):\n    # \u9577\u3055l\u306e\u4e38\u592a\u3092\u6700\u5927\u3068\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n    for a in A:\n        if a > l:\n            k -= (-(-a//l) - 1)\n    return k >= 0\n\nwhile r-l > 1:\n    mid = (r+l)//2\n    if cut(mid, k):\n        r = mid\n    else:\n        l = mid\nprint(r)", "N,K = list(map(int,input().split()))\nlog_ls = list(map(int,input().split()))\n\nMax = max(log_ls)\n\ndef less_k(min_length,log_ls = log_ls,K=K):\n    times = 0\n    for log in log_ls:\n        if log % min_length == 0:\n            times += log // min_length -1\n        else:\n            times += log // min_length\n    if times <= K:\n        return True\n    else:\n        return False\n#print(less_k(5,[10,10],2))\n\ndef return_min_length():\n    r = Max\n    l = -1\n    while True:\n        next_length = (r+l) // 2\n        if next_length == 0 or not less_k(next_length):\n            l = next_length\n        else:\n            r = next_length\n        if r - l == 1:\n            return r\n\nans = return_min_length()\nprint(ans)\n", "n,k=map(int,input().split())\na=list(map(int,input().split()))\nng=0\nok=10**10\nwhile ok-ng>1:\n  m=(ok+ng)//2\n  c=0\n  for i in a:\n    c+=(i//m-(i%m==0))\n  if c<=k:\n    ok=m\n  else:\n    ng=m\nprint(ok)", "#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\n\n\ndef cut_count(A, m):\n    \"\"\"\u6700\u9577\u306e\u9577\u3055(\u5207\u308a\u4e0a\u3052)\u304cm\u4ee5\u4e0b\u306b\u306a\u308b\u3088\u3046\u306a\u5207\u65ad\u56de\u6570\"\"\"\n    total = 0\n    for a in A:\n        n = (a - 1) // m\n        total += n\n    return total\n\n\ndef solve(N: int, K: int, A: \"List[int]\"):\n    r = max(A)\n    l = 0\n    while l + 1 < r:\n        m = (r + l) // 2\n        if cut_count(A, m) <= K:\n            r = m  # r \u306f K\u56de\u4ee5\u4e0b\u306e\u5207\u65ad\u56de\u6570\u3067\u5230\u9054\u3067\u304d\u308b\u9577\u3055\n        else:\n            l = m  # l \u306f K\u56de\u3088\u308a\u591a\u3044\u306e\u5207\u65ad\u56de\u6570\u3067\u5230\u9054\u3067\u304d\u308b\u9577\u3055\n    # print(l, r)\n    return r\n\n\ndef main():\n    tokens = chain(*(line.split() for line in sys.stdin))\n    # N, K, A = map(int, line.split())\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    answer = solve(N, K, A)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k,*a = map(int,open(0).read().split())\ndef func(b):\n  c = k\n  for i in a:\n    c -= (i-1)//b\n    if c < 0:\n      return False\n  return True\nl = 1\nr = max(a)\nwhile(r>l):\n  lr = (l+r)//2\n  if func(lr):\n    r = lr\n  else:\n    l = lr + 1\nprint(r)", "# coding: utf-8\n\ndef solve(*args: str) -> str:\n    n, k = list(map(int, args[0].split()))\n    A = tuple(map(int, args[1].split()))\n\n    l, r = 0, max(A)\n    while l+1 < r:\n        m = (l+r)//2\n        cnt = 0\n        for a in A:\n            cnt += -(-a//m)-1\n\n        if k < cnt:\n            l = m\n        else:\n            r = m\n\n    return str(r)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "n, k = map(int, input().split())\na = [i-1 for i in map(int, input().split())]\n\nleft, right = 0, 10**9\nwhile left < right:\n    middle = (left+right)//2\n    if middle==0:\n        left=1\n        break\n    count = 0\n    for i in a:\n        count += i//middle\n    \n    if count <= k:\n        right = middle\n    else:\n        left = middle + 1\n\nprint(left)", "from collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nimport math\n\ndef readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\n\nn,k = readInts()\na = readInts()\n\na.sort(reverse=True)\n\nif n==1:\n\tprint((math.ceil(a[0]/(k+1))))\n\treturn\n\ndef get(left, right):\n\tl = (right-left)//2+left\n\tans = 0\n\tfor i in a:\n\t\tans+=math.ceil(i/l)-1\n\t#print(l, ans, left, right)\n\treturn ans,l\n\ndef nibu(left,right):\n\tans,l = get(left, right)\n\n\tif left<right:\n\t\tif ans<=k:\n\t\t\treturn nibu(left,l)\n\t\telse:\n\t\t\treturn nibu(l+1, right)\n\telse:\n\t\treturn right\n\n\nprint((nibu(1,a[0])))\n", "N, K = map(int, input().split())\n\nAlist = list(map(int, input().split()))\n\nleft = 0\nright = max(Alist)\n\nwhile right - left > 1:\n    mid = (left + right) // 2\n    \n    cnt = 0\n    for A in Alist:\n        if A % mid == 0:\n            cnt += (A // mid) - 1\n        else:\n            cnt += (A // mid)\n    \n    if cnt <= K:\n        right = mid\n    else:\n        left = mid\n\nprint(right)", "def is_good(mid, key):\n    return sum((a + mid - 1) // mid for a in A) - N <= key\n\n\ndef binary_search(bad, good, key):\n    while good - bad > 1:\n        mid = (bad + good) // 2\n        if is_good(mid, key):\n            good = mid\n        else:\n            bad = mid\n    return good\n\n\nN, K, *A = list(map(int, open(0).read().split()))\nprint((binary_search(0, 1_000_000_000, K)))\n", "# ABC174 E\n\nn, k = list(map(int, input().split()))\na_l = [int(x) for x in input().split()]\n\nleft = 0\nright = max(a_l)\n\n\ndef cut(len):\n    ret = 0\n    for i in range(n):\n        if a_l[i] % len == 0:\n            ret += a_l[i] // len - 1\n        else:\n            ret += a_l[i] // len\n    return ret\n\n\nwhile (right - left) > 1:\n    _q = (left + right) // 2\n    _ret = cut(_q)\n    if k >= _ret:\n        right = _q\n    else:\n        left = _q\n\nprint(right)\n"]
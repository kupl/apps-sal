["#This code is dedicated to Vlada S.\n\nclass Course:\n\tdef __init__(self, reqs, number):\n\t\tself.reqs = list(map(int, reqs.split()[1:]))\n\t\tself.available = False\n\t\tself.in_stack = False\n\t\tself.number = number\n\nn, k = list(map(int, input().split()))\nrequirements = list(map(int, input().split()))\ncourses = {}\n\nanswer = \"\"\n\nfor i in range(n):\n\tcourses[i + 1]= Course(input(), i + 1)\n\nfor i in range(len(requirements)):\n\trequirements[i] = courses[requirements[i]]\n\nwhile requirements:\n\tdata = {}\n\n\tcourse = requirements.pop()\n\n\tif not course.available:\n\t\trequirements.append(course)\n\n\t\tdone = True\n\n\t\tfor c in course.reqs:\n\t\t\tc = courses[c]\n\n\t\t\tif not c.available:\n\t\t\t\trequirements.append(c)\n\t\t\t\tdone = False\n\n\t\tif done:\n\t\t\tanswer += \" \" + str(course.number)\n\t\t\tcourse.available = True\n\t\telse:\n\t\t\tif course.in_stack:\n\t\t\t\tprint(-1)\n\t\t\t\tbreak\n\n\t\t\tcourse.in_stack = True\nelse:\n\tprint(answer.count(\" \"))\n\tprint(answer[1:])", "import sys\n\ndef main():\n\n    n,k = map(int,sys.stdin.readline().split())\n    courses = list(map(int,sys.stdin.readline().split()))\n    courses = [x-1 for x in courses] \n\n    visited = [False]*n\n    used = [False]*n\n\n    ans = []\n    t = []\n\n    for i in range(n):\n        temp = list(map(int,sys.stdin.readline().split()))\n        temp = [x-1 for x in temp] \n        t.append(temp[1:])\n        \n    for i in range(k):\n        c = courses[i]\n        if used[c]:\n            continue\n        \n        q = [c]        \n        visited[c]=True\n        while len(q)>0:\n            cur = q[-1]\n            if len(t[cur])!=0:\n                s = t[cur].pop()\n                if visited[s] and not used[s]:                    \n                    print(-1)\n                    return\n                if used[s]:\n                    continue                \n                q.append(s)\n                visited[s]=True\n            else:\n                ans.append(cur)\n                q.pop()\n                used[cur] = True\n\n    ans = [str(x+1) for x in ans] \n    print(len(ans))\n    print(\" \".join(ans))\n\nmain()", "import collections as col\nimport itertools as its\nimport sys\nimport operator\nfrom copy import copy, deepcopy\n\n\nclass Solver:\n    def __init__(self):\n        pass\n    \n    def solve(self):\n        n, k = list(map(int, input().split()))\n        q = list([int(x) - 1 for x in input().split()])\n        used = [False] * n\n        for e in q:\n            used[e] = True\n        edges = [[] for _ in range(n)]\n        redges = [[] for _ in range(n)]\n        for i in range(n):\n            l = list([int(x) - 1 for x in input().split()])[1:]\n            edges[i] = l\n            for e in l:\n                redges[e].append(i)\n        degs = [len(edges[i]) for i in range(n)]\n        d = 0\n        while d < len(q):\n            v = q[d]\n            d += 1\n            for e in edges[v]:\n                if not used[e]:\n                    used[e] = True\n                    q.append(e)\n        q = q[::-1]\n        nq = []\n        for v in q:\n            if degs[v] == 0:\n                nq.append(v)\n        d = 0\n        while d < len(nq):\n            v = nq[d]\n            d += 1\n            for e in redges[v]:\n                if not used[e]:\n                    continue\n                degs[e] -= 1\n                if degs[e] == 0:\n                    nq.append(e)\n        #print(nq)\n        if len(q) != len(nq):\n            print(-1)\n            return\n        print(len(nq))\n        print(' '.join([str(x + 1) for x in nq]))\n        \n\n\ndef __starting_point():\n    s = Solver()\n    s.solve()\n\n__starting_point()", "\nline1 = input().split(\" \")\nn = int(line1[0])\nk = int(line1[1])\n\nmain = list(map(int, input().split(\" \")))\n\nreqs = [None] * (n + 1) # [course_number : [dependency1, dependecy2, ...]]\n\nfor i in range(n):\n    line = input().split(\" \")\n    if int(line[0]) == 0:\n        reqs[1 + i] = []\n    else:\n        curr_reqs = []\n        for req in line[1:]:\n            curr_reqs += [int(req)]\n        reqs[1 + i] = curr_reqs\n\nres = []\n\n# print(reqs)\nto_exit = False  # \u0447\u0442\u043e\u0431\u044b \u043f\u043e \u0444\u0430\u0441\u0442\u0443 \u0432\u044b\u0445\u043e\u0434\u0438\u0442\u044c \u0438\u0437 \u0446\u0438\u043a\u043b\u043e\u0432\n\ndef traverse(main_courses): # \u0441\u044e\u0434\u0430 \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u0440\u0430\u0437\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\n    nonlocal res,to_exit\n    roots =[False] * (n+1)\n    while main_courses and not to_exit: # \u043f\u043e\u043a\u0430 \u043c\u044d\u0438\u043d \u043d\u0435 \u043f\u0443\u0441\u0442\u043e\u0439 \u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u043e \u043b\u0438\u0432\u0430\u0442\u044c \u0438\u0437 \u0446\u0438\u043a\u043b\u0430\n        main_to_trav = main_courses.pop()\n        if reqs[main_to_trav] == None:\n            continue\n        stack = [main_to_trav] # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043a\u043e\u0440\u0435\u043d\u044c \u0434\u0435\u0440\u0435\u0432\u0430 \u0432 \u0441\u0442\u044d\u043a\n        while len(stack) > 0 and not to_exit:\n            to_traverse = stack.pop() # \u0434\u043e\u0441\u0442\u0430\u0435\u043c \u0438\u0437 \u0441\u0442\u044d\u043a\u0430 \u0432\u0435\u0440\u0448\u0438\u043d\u0443 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u0445\u043e\u0442\u0438\u043c \u043e\u0431\u043e\u0439\u0442\u0438\n            if reqs[to_traverse] is not None: # \u0435\u0441\u043b\u0438 \u0435\u0435 \u0435\u0449\u0435 \u043d\u0435 \u043e\u0431\u043e\u0448\u043b\u0438\n                childs = reqs[to_traverse]  # \u0431\u0435\u0440\u0435\u043c \u0434\u0435\u0442\u0435\u0439\n                if len(childs) == 0: # \u0435\u0441\u043b\u0438 \u0434\u0435\u0442\u0435\u0439 \u043d\u0435\u0442 - \u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0432\u0435\u0440\u0448\u0438\u043d\u0443\n                    roots[to_traverse] = False\n                    res.append(to_traverse)\n                    reqs[to_traverse] = None # \u043f\u043e\u043c\u0435\u0447\u0430\u0435\u043c \u0447\u0442\u043e \u043f\u0440\u043e\u0448\u043b\u0438 \u0432\u0435\u0440\u0448\u0438\u043d\u0443\n                else:\n                    roots[to_traverse] = True\n                    # print (roots)\n                    stack.append(to_traverse) # \u0435\u0441\u043b\u0438 \u0434\u0435\u0442\u0438 \u0435\u0441\u0442\u044c - \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0441\u0435\u0431\u044f \u0432 \u0441\u0442\u044d\u043a(\u0447\u0442\u043e\u0431\u044b \u043e\u0431\u043e\u0439\u0442\u0438 \u043f\u043e\u0442\u043e\u043c), \u043f\u043e\u0442\u043e\u043c \u0434\u0435\u0442\u0435\u0439\n\n                    for child in childs:\n                        if roots[child] == True:\n                            print(-1)\n                            to_exit = True\n                            break\n\n                    stack += childs\n                    reqs[to_traverse] = [] # \u043f\u043e\u0441\u043b\u0435 \u0442\u043e\u0433\u043e \u043a\u0430\u043a \u0434\u043e\u0431\u0430\u0432\u0438\u043b\u0438 \u0434\u0435\u0442\u0435\u0439 - \u043e\u0431\u043d\u0443\u043b\u044f\u0435\u043c \u0438\u0445, \u0447\u0442\u043e\u0431\u044b \u0431\u043e\u043b\u044c\u0448\u0435 \u043d\u0435 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c\n\ntraverse(main)\n\nif not to_exit:\n    print(len(res))\n    print(' '.join(map(str, res)))", "def dfs(start_node, edges, colors, result):\n    stack = [start_node]\n    while stack:\n        current_node = stack[-1]\n        if colors[current_node] == 2:\n            stack.pop()\n            continue\n        colors[current_node] = 1\n        children = edges[current_node]\n        if not children:\n            colors[current_node] = 2\n            result.append(stack.pop())\n        else:\n            child = children.pop()\n            if colors[child] == 1:\n                return False\n            stack.append(child)\n    return True\n\n\ndef find_courses_sequence(member_of_node, find_nodes, edges):\n    colors = [0] * member_of_node\n    result = []\n    for node in find_nodes:\n        if not dfs(node, edges, colors, result):\n            return []\n    return result\n\n\ndef __starting_point():\n    n, k = map(int, input().split())\n    main_courses = [int(c)-1 for c in input().split()]\n    courses = dict()\n    for index in range(n):\n        courses[index] = [int(d)-1 for d in input().split()[1:]]\n\n    result = find_courses_sequence(n, main_courses, courses)\n\n    if result:\n        print(len(result))\n        for v in result:\n            print(v+1, end=\" \")\n    else:\n        print(-1)\n\n__starting_point()", "f = lambda: map(int, input().split())\ng = lambda: [[] for x in range(n)]\nn, k = f()\nn += 1\n\ns, p = [], list(f())\nc, d = [0] * n, [0] * n\nu, v = g(), g()\n\nfor x in range(1, n):\n    t = list(f())\n    m = t.pop(0)\n    if m:\n        c[x] = m\n        v[x] = t\n        for y in t: u[y].append(x)\n    else:\n        s.append(x)\n        d[x] = 1\nwhile s:\n    x = s.pop()\n    for y in u[x]:\n        c[y] -= 1\n        d[y] = max(d[y], d[x] + 1)\n        if c[y] == 0: s.append(y)\n\nif any(c[x] for x in p):\n    print(-1)\n    return\n\nq = [0] * n\nwhile p:\n    x = p.pop()\n    if q[x] == 0:\n        p += v[x]\n        q[x] = 1\n\np = sorted((d[x], x) for x in range(n) if q[x])\nprint(len(p))\nfor d, x in p: print(x)", "#This code is dedicated to Vlada S.\n\nclass Course:\n\tdef __init__(self, reqs, number):\n\t\tself.reqs = list(map(int, reqs.split()[1:]))\n\t\tself.available = False\n\t\tself.in_stack = False\n\t\tself.number = number\n\nn, k = list(map(int, input().split()))\nrequirements = list(map(int, input().split()))\ncourses = {}\n\nanswer = \"\"\n\nfor i in range(n):\n\tcourses[i + 1]= Course(input(), i + 1)\n\nfor i in range(len(requirements)):\n\trequirements[i] = courses[requirements[i]]\n\nwhile requirements:\n\tdata = {}\n\n\tcourse = requirements.pop()\n\n\tif not course.available:\n\t\trequirements.append(course)\n\n\t\tdone = True\n\n\t\tfor c in course.reqs:\n\t\t\tc = courses[c]\n\n\t\t\tif not c.available:\n\t\t\t\trequirements.append(c)\n\t\t\t\tdone = False\n\n\t\tif done:\n\t\t\tanswer += \" \" + str(course.number)\n\t\t\tcourse.available = True\n\t\telse:\n\t\t\tif course.in_stack:\n\t\t\t\tprint(-1)\n\t\t\t\tbreak\n\n\t\t\tcourse.in_stack = True\nelse:\n\tprint(answer.count(\" \"))\n\tprint(answer[1:])\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\nflag=True\nsys.setrecursionlimit(2000000000)\nc=[];st=[];\ncur_adj=[]\ndef topo(s):#Traversing the array and storing the vertices\n    nonlocal c,st,flag;\n    stack = [s]\n    while(stack):\n        s = stack[-1]\n        c[s]=1; #Being Visited\n        if(cur_adj[s] < len(adjli[s])):\n            cur = adjli[s][cur_adj[s]]\n            if(c[cur]==0):\n                stack.append(cur)\n            if(c[cur]==1):\n                flag=False# If Back Edge , Then Not Possible\n            cur_adj[s]+=1\n        else:\n            c[s]=2\n            st.append(str(s))\n            del stack[-1]\n\ntry:\n    n,k=map(int,input().split(' '))\n    main=list(map(int,input().split(' ')))\n    depen=[]\n    for i in range(n):\n    \tdepen.append(list(map(int,input().split(' ')))[1:]);c.append(0)\n    \tcur_adj.append(0)\n    c.append(0)\n    cur_adj.append(0)\n    adjli=[]\n    adjli.append(main)#Assuming Main Course at index 0 with dependencies as Main Dependency(main)\n    for i in range(len(depen)):\n        adjli.append(depen[i])#Appending Other Dependencies\n    topo(0)#TopoLogical Sort Order\n    st.pop(-1)#popping the assumed Main Couse\n    if flag:# IF possible then print\n        print(len(st))\n        print(' '.join(st))\n    else:\n        print(-1)\nexcept Exception as e:\n    print(e,\"error\")", "'''import sys\nflag=True\nsys.setrecursionlimit(2000000)\nc=[];st=[];\ndef topo(s):#Traversing the array and storing the vertices\n\tnonlocal c,st,flag;\n\tc[s]=1; #Being Visited\n\tfor i in adjli[s]:#visiting neighbors\n\t\tif c[i]==0:\n\t\t\ttopo(i)\n\t\tif c[i]==1:\n\t\t\tflag=False# If Back Edge , Then Not Possible\n\tst.append(str(s))\n\tc[s]=2 # Visited\n\ntry:\n\tn,k=map(int,input().split(' '))#Number Of Courses,Dependencies\n\tmain=list(map(int,input().split(' ')))#Main Dependencies\n\tdepen=[]#Dependencies List\n\tfor i in range(n):\n\t\tdepen.append(list(map(int,input().split(' ')))[1:]);c.append(0)#Append Input To Dependencies List, Marking Visited as 0(False)\n\tc.append(0)\n\tadjli=[]\n\tadjli.append(main)#Assuming Main Course at index 0 with dependencies as Main Dependency(main)\n\tfor i in range(len(depen)):\n\t\tadjli.append(depen[i])#Appending Other Dependencies\n\ttopo(0)#TopoLogical Sort Order\n\tst.pop(-1)#popping the assumed Main Couse\n\tif flag:# IF possible then print\n\t\tprint(len(st))\n\t\tprint(' '.join(st))\n\telse:\n\t\tprint(-1)\nexcept Exception as e:\n\tprint(e,\"error\")'''\n\nimport sys\nflag=True\nsys.setrecursionlimit(2000000000)\nc=[];st=[];\ncur_adj=[]\ndef topo(s):#Traversing the array and storing the vertices\n    nonlocal c,st,flag;\n    stack = [s]\n    while(stack):\n        s = stack[-1]\n        c[s]=1; #Being Visited\n        if(cur_adj[s] < len(adjli[s])):\n            cur = adjli[s][cur_adj[s]]\n            if(c[cur]==0):\n                stack.append(cur)\n            if(c[cur]==1):\n                flag=False# If Back Edge , Then Not Possible\n            cur_adj[s]+=1\n        else:\n            c[s]=2\n            st.append(str(s))\n            del stack[-1]\n\ntry:\n    n,k=map(int,input().split(' '))\n    main=list(map(int,input().split(' ')))\n    depen=[]\n    for i in range(n):\n        depen.append(list(map(int,input().split(' ')))[1:]);c.append(0)\n        cur_adj.append(0)\n    c.append(0)\n    cur_adj.append(0)\n    adjli=[]\n    adjli.append(main)#Assuming Main Course at index 0 with dependencies as Main Dependency(main)\n    for i in range(len(depen)):\n        adjli.append(depen[i])#Appending Other Dependencies\n    topo(0)#TopoLogical Sort Order\n    st.pop(-1)#popping the assumed Main Couse\n    if flag:# IF possible then print\n        print(len(st))\n        print(' '.join(st))\n    else:\n        print(-1)\nexcept Exception as e:\n    print(e,\"error\")", "# https://codeforces.com/problemset/problem/770/C\nn, k = list(map(int, input().split()))\nK    = set(list(map(int, input().split())))\ng    = {}\nrg   = {}\ndeg  = {}\n\ndef push_d(deg, u, val):\n    if u not in deg:\n        deg[u] = 0\n    deg[u] += val\n\ndef push_g(g, u, v):\n    if u not in g:\n        g[u] = []\n    g[u].append(v)\n    \nfor u in range(1, n+1):\n    list_v = list(map(int, input().split()))[1:]\n    deg[u] = 0\n    \n    for v in list_v:\n        push_d(deg, u, 1)\n        push_g(g,  v, u)\n        push_g(rg, u, v)\n        \nS    = [x for x in K]\nused = [0] * (n+1) \ni = 0\nwhile i<len(S):\n    u = S[i]\n    if u in rg:\n        for v in rg[u]:\n            if used[v] == 0:\n                used[v] = 1\n                S.append(v)\n    i+=1\n    \nS    = {x:1 for x in S}    \ndeg0 = [x for x in S if deg[x]==0]\nans  = []\n\ndef process(g, deg, deg0, u):\n    if u in g:\n        for v in g[u]:\n            if v in S:\n                push_d(deg, v, -1)\n        \n                if deg[v] == 0:\n                    deg0.append(v)\n    \nwhile len(deg0) > 0 and len(K) > 0:\n    u = deg0.pop()\n    ans.append(u)\n    \n    if u in K:\n        K.remove(u)\n        \n    process(g, deg, deg0, u)    \n    \nif len(K) > 0:\n    print(-1)\nelse:\n    print(len(ans))\n    print(' '.join([str(x) for x in ans])) \n    \n#6 2\n#5 6\n#0\n#1 1\n#1 4 5\n#2 2 1\n#1 4\n#2 5 3    \n", "n,k=list(map(lambda x: int(x), input().split()))\nm=list(map(lambda x: int(x), input().split()))\nfrom types import GeneratorType\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\nclass Graph:\n\n    def __init__(self, V):\n        self.V = V\n        self.adj = [[] for i in range(V)]\n    @bootstrap\n    def DFSUtil(self, temp, v, visited):\n\n        visited[v] = True\n\n\n\n        for i in self.adj[v]:\n            if visited[i] == False:\n                yield self.DFSUtil(temp, i, visited)\n\n        temp.append(v)\n        yield temp\n\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n        # self.adj[w].append(v)\n    @bootstrap\n    def isCyclicUtil(self, v, visited, recStack):\n\n        # Mark current node as visited and\n        # adds to recursion stack\n        visited[v] = True\n        recStack[v] = True\n\n        # Recur for all neighbours\n        # if any neighbour is visited and in\n        # recStack then graph is cyclic\n        for neighbour in self.adj[v]:\n            if visited[neighbour] == False:\n                ans =yield self.isCyclicUtil(neighbour, visited, recStack)\n                if  ans == True:\n                    yield True\n            elif recStack[neighbour] == True:\n                yield True\n\n        # The node needs to be poped from\n        # recursion stack before function ends\n        recStack[v] = False\n        yield False\n\n    # Returns true if graph is cyclic else false\n    def isCyclic(self,nodes):\n        visited = [False] * self.V\n        recStack = [False] * self.V\n        for node in nodes:\n            if visited[node] == False:\n                if self.isCyclicUtil(node, visited, recStack) == True:\n                    return True\n        return False\n\n\nG=Graph(n)\n\nfor i in range(0,n):\n\n    x=list(map(lambda x: int(x), input().split()))\n    if x[0]==0:\n        continue\n    else:\n        for k in range(1,x[0]+1):\n            G.addEdge(i,x[k]-1)\nvisited=[False for _ in range(n)]\n\npath=[]\n# print(G.adj)\nfor subj in m:\n    temp = []\n    if visited[subj-1]==False:\n\n        G.DFSUtil(temp,subj-1,visited)\n\n        path.extend(temp)\nif G.isCyclic([x-1 for x in m]):\n    print(-1)\nelse:\n    print(len(path))\n    for p in path:\n        print(p+1,end=\" \")\n    print()"]
["n, m, p = list(map(int, input().split()))\nspeeds = list(map(int, input().split()))\n\nfield = []\nfor _ in range(n):\n    s = list(input().strip())\n    field.append(s)\n\n\ndef neighbours(i, j):\n    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if 0 <= i+di < n and 0 <= j+dj < m:\n            yield i+di, j+dj\n\ndef colors():\n    return [str(i) for i in range(1, p+1)]\n\n\nedges = {c:[] for c in colors()}\nfor c in colors():\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == c:\n                if not all(field[n_i][n_j] == c for (n_i, n_j) in neighbours(i, j)):\n                    edges[c].append((i,j))\n# print(edges)\n\n\ndef up_field(color):\n    edge_color = edges[color]\n\n    new_edge = []\n    for (i,j) in edge_color:\n        for (n_i, n_j) in neighbours(i, j):\n            if field[n_i][n_j] == '.':\n                field[n_i][n_j] = color\n                new_edge.append((n_i, n_j))\n    edges[color] = new_edge\n\n\ndef print_field():\n    for l in field:\n        print(l)\n    print('-'*100)\n\n# print_field()\n\n\nwhile any(len(x) > 0 for x in list(edges.values())):\n    for s, c in zip(speeds, colors()):\n        for i in range(s):\n            up_field(c)\n            if len(edges[c]) == 0:\n                break\n\n    # print_field()\n\n\ncounts = {c:0 for c in colors()}\ncounts['.'] = 0\ncounts['#'] = 0\n\nfor i in range(n):\n    for j in range(m):\n        counts[field[i][j]] += 1\n\nprint(*(counts[c] for c in colors()))\n\n\n\n", "from collections import defaultdict as dd, deque\n\nn,m,p = list(map(int,input().split()))\nS = [0]+[int(x) for x in input().split()]\nM = [list(input())+['#'] for i in range(n)]\nM.append(['#']*m)\n\nfront = [[], [],[],[],[],[],[],[],[],[]]\n\nfor i in range(n):\n    for j in range(m):\n        if M[i][j] not in '.#':\n            a = int(M[i][j])\n            front[a].append((i,j))\n            M[i][j] = a\n\ndef expand(p):\n    s = S[p]\n    Q = deque()\n    for i,j in front[p]:\n        Q.append((i,j,0))\n\n    new = False\n    nfront = []\n    while Q:\n        i,j,d = Q.popleft()\n        nfront.append((i,j))\n        if d >= s:\n            continue\n\n        for di,dj in [(-1,0), (1,0), (0,1), (0,-1)]:\n            if M[i+di][j+dj] == '.':\n                new = True\n                M[i+di][j+dj] = p\n                Q.append((i+di,j+dj,d+1))\n\n    nnfront = []\n    for i,j in nfront:\n        if M[i-1][j] == '.' or \\\n           M[i+1][j] == '.' or \\\n           M[i][j+1] == '.' or \\\n           M[i][j-1] == '.':\n            nnfront.append((i,j))\n\n    front[p] = nnfront\n    return new\n\n\nwhile any([expand(i) for i in range(1,p+1)]):\n    #for _ in M:\n    #    print(*_)\n    pass\n\nC = dd(int)\nfor i in range(n):\n    for j in range(m):\n        C[M[i][j]] += 1\nprint(*(C[i] for i in range(1,p+1)))\n", "# import sys\n#\n# f = open('input1.txt', 'r')\n#\n#\n# sys.stdin = f\n\nn, m, p = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\nq = [[] for _ in range(p)] # fromnt of each palyer\ncounts = [0] * p\n\nfield = []\nfor i in range(n):\n    line = input()\n    field.append([0] * m)\n    for j, c in enumerate(line):\n        if c == '.':\n            field[i][j] = 0\n        elif c == '#':\n            field[i][j] = -1\n        else:\n            # player\n            pi = int(c)\n            field[i][j] = pi\n            counts[pi-1] += 1\n\ndef get_neibs(i, j):\n    up = (i - 1, j) if i > 0 else None\n    down = (i + 1, j) if i < n - 1 else None\n    left = (i, j - 1) if j > 0 else None\n    right = (i, j + 1) if j < m - 1 else None\n    nbs = [up, down, left, right]\n    return [a for a in nbs if a is not None]\n\n\n\ndef init_bounds(field, q):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] > 0:\n                index  = field[i][j]-1\n                nbs = get_neibs(i, j)\n                neib_vals = [field[a[0]][a[1]] for a in nbs]\n                if 0 in neib_vals:\n                    q[index].append((i, j))\n\ndef step_one(index, field, front: list):\n    new_front = []\n\n    total_add = 0\n    for i, j in front:\n        nbs = get_neibs(i, j)\n        for a in nbs:\n            if field[a[0]][a[1]] == 0:\n                # if not yet added\n                field[a[0]][a[1]] = index+1\n                counts[index] += 1\n                total_add += 1\n                new_front.append(a)\n\n\n    return new_front, total_add\n\n\n\n\n\ndef  step(index, field, front, speed):\n    added_len = 0\n    while speed > 0:\n        front, added_len = step_one(index, field, front)\n        speed -= 1\n        if added_len == 0:\n            break\n\n    q[index] = front\n    return front, added_len\n\ninit_bounds(field, q)\n\nwhile True:\n\n    progress = 0\n    added = 0\n    for i in range(p):\n        _, added = step(i, field, q[i], s[i])\n        progress += added\n\n    if progress == 0:\n        break\n\n\n\nprint(\" \".join(map(str, counts)))\n\n# f.close()\n", "from collections import deque\n\nn, m, p = [int(v) for v in input().split()]\ns = [int(v) for v in input().split()]\n\nd = {'.': 0, '#': 10}\nd.update({str(v) : v for v in range(1, p + 1)})\n\nfield = [[d[c] for c in input().strip()] for _ in range(n)]\n\nans = [0] * p\ndists = [[[9999999 for _ in range(m)] for _ in range(n)] for _ in range(p)]\nfrontiers = [deque() for _ in range(p)]\nfor i in range(n):\n    for j in range(m):\n        pp = field[i][j]\n        if 1 <= pp <= 9:\n            frontiers[pp - 1].append((i, j, 0))\n            ans[pp - 1] += 1\n            dists[pp - 1][i][j] = 0\n\noff = [(1, 0), (0, 1), (-1, 0), (0, -1)]\ncurr_lim = s[:]\n\ndef dump():\n    for line in field:\n        print(line)\n    print()\n\nwhile True:\n    was = False\n    for pp in range(1, p + 1):\n        # dump()\n        while frontiers[pp - 1]:\n            i, j, dist = frontiers[pp - 1].popleft()\n            if field[i][j] not in (0, pp):\n                continue\n            if dist > curr_lim[pp - 1]:\n                frontiers[pp - 1].appendleft((i, j, dist))\n                break\n            if field[i][j] != pp:\n                field[i][j] = pp\n                ans[pp - 1] += 1\n                was = True\n            for di, dj in off:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == 0:\n                    # print(ni, nj)\n                    new_dist = dist + 1\n                    if new_dist < dists[pp - 1][ni][nj]:\n                        frontiers[pp - 1].append((ni, nj, new_dist))\n                        dists[pp - 1][ni][nj] = new_dist\n    if was:\n        for i in range(p):\n            curr_lim[i] += s[i]\n    else:\n        break\n\nprint(' '.join(str(v) for v in ans))\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/20 21:02\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : D. Kilani and the Game.py\n\n# import atexit\n# import io\n# import sys\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\nfrom collections import deque\n\n\ndef check_empty(deque_array):\n    count = 0\n    for q in deque_array:\n        count += len(q)\n    return count == 0\n\n\ndef print_grid(grid):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            print(grid[i][j], end='')\n        print()\n    print()\n\n\ndef main():\n    n, m, p = map(int, input().split())\n    s = list(map(int, input().split()))\n    grid = [list(input()) for _ in range(n)]\n\n    deque_array = [deque() for _ in range(p)]\n    for i in range(n):\n        for j in range(m):\n            if '1' <= grid[i][j] <= '9':\n                x = int(grid[i][j])\n                deque_array[x - 1].append((i, j, 0))\n\n    # print(deque_array)\n    curr_round = 1\n    while not check_empty(deque_array):\n        for r in range(p):\n            while deque_array[r]:\n                x, y, step = deque_array[r].popleft()\n                if step >= s[r] * curr_round:\n                    deque_array[r].appendleft((x, y, step))\n                    break\n\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    # print(nx, ny)\n                    if nx < 0 or nx >= n or ny < 0 or ny >= m or grid[nx][ny] != '.':\n                        continue\n                    grid[nx][ny] = str(r + 1)\n                    deque_array[r].append((nx, ny, step + 1))\n        # print_grid(grid)\n        curr_round += 1\n\n    cell_count = [0] * p\n    for i in range(n):\n        for j in range(m):\n            if '1' <= grid[i][j] <= '9':\n                x = int(grid[i][j])\n                cell_count[x - 1] += 1\n    for r in range(p):\n        print(cell_count[r], end=' ')\n    print()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import sys\n#\n# f = open('input1.txt', 'r')\n#\n#\n# sys.stdin = f\n\nn, m, p = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\nq = [[] for _ in range(p)] # fromnt of each palyer\ncounts = [0] * p\n\nfield = []\nfor i in range(n):\n    line = input()\n    field.append([0] * m)\n    for j, c in enumerate(line):\n        if c == '.':\n            field[i][j] = 0\n        elif c == '#':\n            field[i][j] = -1\n        else:\n            # player\n            pi = int(c)\n            field[i][j] = pi\n            counts[pi-1] += 1\n\ndef get_neibs(i, j):\n    up = (i - 1, j) if i > 0 else None\n    down = (i + 1, j) if i < n - 1 else None\n    left = (i, j - 1) if j > 0 else None\n    right = (i, j + 1) if j < m - 1 else None\n    nbs = [up, down, left, right]\n    return [a for a in nbs if a is not None]\n\n\n\ndef init_bounds(field, q):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] > 0:\n                index  = field[i][j]-1\n                nbs = get_neibs(i, j)\n                neib_vals = [field[a[0]][a[1]] for a in nbs]\n                if 0 in neib_vals:\n                    q[index].append((i, j))\n\ndef step_one(index, field, front: list):\n    new_front = []\n\n    total_add = 0\n    for i, j in front:\n        nbs = get_neibs(i, j)\n        for a in nbs:\n            if field[a[0]][a[1]] == 0:\n                # if not yet added\n                field[a[0]][a[1]] = index+1\n                counts[index] += 1\n                total_add += 1\n                new_front.append(a)\n\n\n    return new_front, total_add\n\n\n\n\n\ndef  step(index, field, front, speed):\n    added_len = 0\n    while speed > 0:\n        front, added_len = step_one(index, field, front)\n        speed -= 1\n        if added_len == 0:\n            break\n\n    q[index] = front\n    return front, added_len\n\ninit_bounds(field, q)\n\nwhile True:\n\n    progress = 0\n    added = 0\n    for i in range(p):\n        _, added = step(i, field, q[i], s[i])\n        progress += added\n\n    if progress == 0:\n        break\n\n\n\nprint(\" \".join(map(str, counts)))\n\n# f.close()\n", "n, m, p=map(int, input().split())\ns=list(map(int, input().split()))\na=[]\nfront=[set() for i in range(p)] \nfor i in range(n):\n    a.append([(int(0) if ch=='.' else (-1 if ch=='#' else (int(ch) if not front[int(ch)-1].add( (i, j) ) else -99 ))) for j, ch in enumerate(input())])\n\nmove=[(-1, 0), (1, 0), (0, -1), (0, 1)]\ni=0\nblocked=[False]*p\nactiveplayers=p\n\ni=0\nwhile activeplayers>0:\n    if blocked[i]:\n        i=(i+1)%p\n        continue\n    aset=front[i]\n    mademove=False\n    for gtime in range(s[i]):\n        newset=set()\n        for x,y in aset:\n            for dx, dy in move:\n                if 0<=x+dx<n and 0<=y+dy<m:\n                    if a[x+dx][y+dy]==0:\n                        newset.add( (x+dx, y+dy) )\n                        a[x+dx][y+dy]=(i+1)\n                        mademove=True\n        aset=newset\n        if len(aset)==0:\n            mademove=False\n            break\n    front[i]=aset\n    if not mademove:\n        blocked[i]=True\n        activeplayers=activeplayers-1\n    i=(i+1)%p\n\nres=[0]*p\n\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j]>0:\n            res[int(a[i][j])-1]=res[int(a[i][j])-1]+1\n\nfor i in range(p):\n    print(res[i], end=' ')\n", "import sys\nfrom collections import deque as dq\n\nh,w,P = [int(x) for x in input().split()]\nS = [int(x) for x in input().split()]\n\nboard = []\nfor b in sys.stdin.read():\n    for c in b:\n        if c=='.':\n            board.append(-1)\n        elif 0<=ord(c)-49<=9:\n            board.append(ord(c)-49)\n        elif c=='#':\n            board.append(-2)\n\nnew_castles = [dq() for _ in range(P)]\n\nfor pos in range(h*w):\n    if board[pos]>=0:\n        new_castles[board[pos]].append((pos,0))\n\nQ = dq()\nplayer_Q = dq(p for p in range(P) if new_castles[p])\nwhile player_Q:\n    p = player_Q.popleft()\n    Q = new_castles[p]\n    # Do S[p] moves\n    goal = Q[-1][1] + S[p]\n    while Q and Q[0][1] != goal:\n        pos,moves = Q.popleft()\n        y = pos//w\n        x = pos - y*w\n        \n        if 0<x and board[pos-1]==-1:\n            board[pos-1]=p\n            Q.append((pos-1,moves+1))\n        \n        if x<w-1 and board[pos+1]==-1:\n            board[pos+1]=p\n            Q.append((pos+1,moves+1))\n    \n        if 0<y and board[pos-w]==-1:\n            board[pos-w]=p\n            Q.append((pos-w,moves+1))\n        \n        if y<h-1 and board[pos+w]==-1:\n            board[pos+w]=p\n            Q.append((pos+w,moves+1))\n    if Q:\n        player_Q.append(p)\n\ncount = [0 for _ in range(P)]\nfor x in board:\n    if x >= 0:\n        count[x] += 1\nprint(*count)", "import sys\nfrom collections import deque as dq\n\nh,w,P = [int(x) for x in input().split()]\nS = [int(x) for x in input().split()]\n\nboard = []\ninp = sys.stdin.read()\nfor ind in range(len(inp)):\n    if inp[ind]=='.':\n        board.append(-1)\n    elif 49<=ord(inp[ind])<=58:\n        board.append(ord(inp[ind])-49)\n    elif inp[ind]=='#':\n        board.append(-2)\n\nnew_castles = [dq() for _ in range(P)]\n\nfor pos in range(h*w):\n    if board[pos]>=0:\n        new_castles[board[pos]].append((pos,0))\n\nplayer_Q = dq(p for p in range(P) if new_castles[p])\nwhile player_Q:\n    p = player_Q.popleft()\n    Q = new_castles[p]\n\n    goal = Q[-1][1] + S[p]\n    while Q and Q[0][1] != goal:\n        pos,moves = Q.popleft()\n        y = pos//w\n        x = pos - y*w\n        \n        if 0<x and board[pos-1]==-1:\n            board[pos-1]=p\n            Q.append((pos-1,moves+1))\n        \n        if x<w-1 and board[pos+1]==-1:\n            board[pos+1]=p\n            Q.append((pos+1,moves+1))\n    \n        if 0<y and board[pos-w]==-1:\n            board[pos-w]=p\n            Q.append((pos-w,moves+1))\n        \n        if y<h-1 and board[pos+w]==-1:\n            board[pos+w]=p\n            Q.append((pos+w,moves+1))\n    if Q:\n        player_Q.append(p)\n\ncount = [0 for _ in range(P)]\nfor x in board:\n    if x >= 0:\n        count[x] += 1\nprint(' '.join(str(x) for x in count))", "import sys\nh,w,P = [int(x) for x in input().split()]\nS = [int(x) for x in input().split()]\n\nboard = []\ninp = sys.stdin.read()\nfor ind in range(len(inp)):\n    if inp[ind]=='.':\n        board.append(-1)\n    elif 49<=ord(inp[ind])<=58:\n        board.append(ord(inp[ind])-49)\n    elif inp[ind]=='#':\n        board.append(-2)\n\nnew_castles = [[] for _ in range(P)]\nnew_castles_ind = [0 for _ in range(P)]\n\nfor pos in range(h*w):\n    if board[pos]>=0:\n        new_castles[board[pos]].append((pos,0))\n\nplayer_Q = [p for p in range(P) if new_castles[p]]\nplayer_Q_ind = 0\n\nwhile player_Q_ind != len(player_Q):\n    p = player_Q[player_Q_ind]\n    player_Q_ind += 1\n    Q = new_castles[p]\n    Q_ind = new_castles_ind[p]\n\n    goal = Q[Q_ind][1] + S[p]\n    while Q_ind != len(Q) and Q[Q_ind][1] != goal:\n        pos,moves = Q[Q_ind]\n        Q_ind += 1\n        y = pos//w\n        x = pos - y*w\n        \n        if 0<x and board[pos-1]==-1:\n            board[pos-1]=p\n            Q.append((pos-1,moves+1))\n        \n        if x<w-1 and board[pos+1]==-1:\n            board[pos+1]=p\n            Q.append((pos+1,moves+1))\n    \n        if 0<y and board[pos-w]==-1:\n            board[pos-w]=p\n            Q.append((pos-w,moves+1))\n        \n        if y<h-1 and board[pos+w]==-1:\n            board[pos+w]=p\n            Q.append((pos+w,moves+1))\n    if Q_ind != len(Q):\n        player_Q.append(p)\n        new_castles_ind[p] = Q_ind\n\ncount = [0 for _ in range(P)]\nfor x in board:\n    if x >= 0:\n        count[x] += 1\nprint(' '.join(str(x) for x in count))", "import sys\n\nh,w,P = [int(x) for x in input().split()]\nS = [int(x) for x in input().split()]\n\nboard = []\ninp = sys.stdin.read()\nfor ind in range(len(inp)):\n    c = inp[ind]\n    if c=='.':\n        board.append(-1)\n    elif 49<=ord(c)<=58:\n        board.append(ord(c)-49)\n    elif c=='#':\n        board.append(-2)\n\nnew_castles = [[] for _ in range(P)]\nnew_castles_ind = [0 for _ in range(P)]\n\nfor pos in range(h*w):\n    if board[pos]>=0:\n        new_castles[board[pos]].append((pos,0))\n\nplayer_Q = [p for p in range(P) if new_castles[p]]\nplayer_Q_ind = 0\n\nwhile player_Q_ind != len(player_Q):\n    p = player_Q[player_Q_ind]\n    player_Q_ind += 1\n    Q = new_castles[p]\n    Q_ind = new_castles_ind[p]\n\n    goal = Q[Q_ind][1] + S[p]\n    while Q_ind != len(Q) and Q[Q_ind][1] != goal:\n        pos,moves = Q[Q_ind]\n        Q_ind += 1\n        y = pos//w\n        x = pos - y*w\n        \n        if 0<x and board[pos-1]==-1:\n            board[pos-1]=p\n            Q.append((pos-1,moves+1))\n        \n        if x<w-1 and board[pos+1]==-1:\n            board[pos+1]=p\n            Q.append((pos+1,moves+1))\n    \n        if 0<y and board[pos-w]==-1:\n            board[pos-w]=p\n            Q.append((pos-w,moves+1))\n        \n        if y<h-1 and board[pos+w]==-1:\n            board[pos+w]=p\n            Q.append((pos+w,moves+1))\n    if Q_ind != len(Q):\n        player_Q.append(p)\n        new_castles_ind[p] = Q_ind\n\nprint(*[len(new_castles[p]) for p in range(P)])", "import sys\n\nh,w,P = [int(x) for x in input().split()]\nS = [int(x) for x in input().split()]\n\nboard = []\nfor c in sys.stdin.read():\n    if c=='.':\n        board.append(-1)\n    elif 49<=ord(c)<=58:\n        board.append(ord(c)-49)\n    elif c=='#':\n        board.append(-2)\n\nnew_castles = [[] for _ in range(P)]\nnew_castles_ind = [0 for _ in range(P)]\n\nfor pos in range(h*w):\n    if board[pos]>=0:\n        new_castles[board[pos]].append((pos,0))\n\nplayer_Q = [p for p in range(P) if new_castles[p]]\nplayer_Q_ind = 0\n\nwhile player_Q_ind != len(player_Q):\n    p = player_Q[player_Q_ind]\n    player_Q_ind += 1\n    Q = new_castles[p]\n    Q_ind = new_castles_ind[p]\n\n    goal = Q[Q_ind][1] + S[p]\n    while Q_ind != len(Q) and Q[Q_ind][1] != goal:\n        pos,moves = Q[Q_ind]\n        Q_ind += 1\n        y = pos//w\n        x = pos - y*w\n        \n        if 0<x and board[pos-1]==-1:\n            board[pos-1]=p\n            Q.append((pos-1,moves+1))\n        \n        if x<w-1 and board[pos+1]==-1:\n            board[pos+1]=p\n            Q.append((pos+1,moves+1))\n    \n        if 0<y and board[pos-w]==-1:\n            board[pos-w]=p\n            Q.append((pos-w,moves+1))\n        \n        if y<h-1 and board[pos+w]==-1:\n            board[pos+w]=p\n            Q.append((pos+w,moves+1))\n    if Q_ind != len(Q):\n        player_Q.append(p)\n        new_castles_ind[p] = Q_ind\n\nprint(*[len(new_castles[p]) for p in range(P)])", "from collections import deque\nimport math\n\n\ndef add(x, y):\n    return (x[0] + y[0], x[1] + y[1])\n\n\nh, w, n = list(map(int, input().split()))\nspeeds = list(map(int, input().split()))\narr = [None] * h\ncastles = [deque() for _ in range(n)]\ncastles_count = [0] * n\nfor i in range(h):\n    arr[i] = list(input())\n    for j in range(w):\n        if arr[i][j] not in ('.', '#'):\n            arr[i][j] = int(arr[i][j]) - 1\n            castles[arr[i][j]].append((i, j))\n            castles_count[arr[i][j]] += 1\n\n\ndef get(x):\n    if (x[0] >= 0) and (x[1] >= 0) and (x[0] < h) and (x[1] < w):\n        return arr[x[0]][x[1]]\n    return None\n\n\nhas_changes = True\nwhile has_changes:\n    has_changes = False\n    for p in range(n):\n        cur_lvl = castles[p]\n        cur_lvl_num = 0\n        while (cur_lvl_num < speeds[p]) and cur_lvl:\n            next_lvl = []\n            for cell in cur_lvl:\n                for move in ((0, 1), (0, -1), (-1, 0), (1, 0)):\n                    next_cell = add(cell, move)\n                    val = get(next_cell)\n                    if val == '.':\n                        has_changes = True\n                        next_lvl.append(next_cell)\n                        arr[next_cell[0]][next_cell[1]] = p\n                        castles_count[p] += 1\n            cur_lvl_num += 1\n            cur_lvl = next_lvl\n        castles[p] = cur_lvl\n\nprint(' '.join(map(str, castles_count)))\n", "import sys\nfrom collections import deque, Counter\n\ndef __starting_point():\n    n, m, p = list(map(int, input().split()))\n    speeds = list(map(int, input().split()))\n    field = sys.stdin.readlines()\n\n    lands = [-1] * (n * m)\n\n    graph = [[] for _ in range(n * m)]\n\n    starts = [deque() for _ in range(p)]\n\n    levels = [-1] * n * m\n\n    def calc(x, y): return x * m + y\n\n\n    for i in range(n):\n        for j in range(m):\n            point = calc(i, j)\n            if field[i][j].isdigit():\n                player = int(field[i][j]) - 1\n                starts[player].appendleft(point)\n                lands[point] = player\n                levels[point] = 0\n            elif field[i][j] == '#':\n                continue\n\n            if 0 <= i - 1 and field[i - 1][j] == '.':\n                graph[point].append(calc(i - 1, j))\n            if i + 1 < n and field[i + 1][j] == '.':\n                graph[point].append(calc(i + 1, j))\n            if 0 <= j - 1 and field[i][j - 1] == '.':\n                graph[point].append(calc(i, j - 1))\n            if j + 1 < m and field[i][j + 1] == '.':\n                graph[point].append(calc(i, j + 1))\n\n    cnt = 0\n    while [s for s in starts if s]:\n        player = cnt % p\n        turn = cnt // p + 1\n\n        while starts[player]:\n            if levels[starts[player][-1]] == speeds[player] * turn:\n                break\n\n            node = starts[player].pop()\n\n            for nxt in graph[node]:\n                if lands[nxt] != -1:\n                    continue\n                level = levels[node] + 1\n                lands[nxt] = player\n                levels[nxt] = levels[node] + 1\n                starts[player].appendleft(nxt)\n\n        cnt += 1\n\n    cnt = list(Counter([l for l in lands if l != -1]).items())\n    cnt.sort()\n\n    print(\" \".join([str(x[1]) for x in cnt]))\n\n\n\n__starting_point()", "n, m, p = list(map(int, input().split()))\ns = [int(i) for i in input().split()]\n\np_size = [0] * p\nfield = []\nfield_free = 0\npp = [set() for _ in range(p)]\nfor y in range(n):\n    for x,i in enumerate(input()):\n        if not (i == '.' or i == '#'):\n            pp[int(i)-1].add(x + y*m)\n        c = i != '#'\n        field_free += int(c)\n        field.append(c)\n\ndef append_nearest(fp, ppn, pi):\n    nonlocal field_free\n    nonlocal p_size\n    if not field[fp]:\n        return\n    if fp % m > 0 and field[fp-1]:\n        ppn.add(fp - 1)\n    if fp % m < m-1 and field[fp+1]:\n        ppn.add(fp + 1)\n    if fp // m > 0 and field[fp - m]:\n        ppn.add(fp - m)\n    if fp // m < n-1 and field[fp + m]:\n        ppn.add(fp + m)\n    field[fp] = False\n    field_free -= 1\n    p_size[pi] += 1\n\nfor pi in range(p):\n    ppi = pp[pi]\n    ppn = pp[pi] = set()\n    for fp in ppi:\n        append_nearest(fp, ppn, pi)\n    del ppi\n\nppn = set()\nfor pi in range(p):\n    ppi = pp[pi]\n    if len(ppi) > 0:\n        for _ in range(s[pi]):\n            for fp in ppi:\n                append_nearest(fp, ppn, pi)\n            ppi.clear()\n            ppi,ppn = ppn,ppi\n\n            if field_free == 0 or len(ppi) == 0:\n                break\n        pp[pi] = ppi\n\n        if field_free == 0:\n            break\nnmlp = n*m - m\nssss = True\nwhile field_free > 0 and ssss:\n    ssss = False\n    for pi in range(p):\n        ppi = pp[pi]\n        if len(ppi) > 0:\n            for _ in range(s[pi]):\n                for fp in ppi:\n                    if not field[fp]:\n                        continue\n                    if fp % m > 0 and field[fp-1]:\n                        ppn.add(fp - 1)\n                    if fp % m < m-1 and field[fp+1]:\n                        ppn.add(fp + 1)\n                    if fp > m-1 and field[fp - m]:\n                        ppn.add(fp - m)\n                    if fp < nmlp and field[fp + m]:\n                        ppn.add(fp + m)\n                    field[fp] = False\n                    field_free -= 1\n                    p_size[pi] += 1\n                ppi.clear()\n                ppi,ppn = ppn,ppi\n            pp[pi] = ppi\n            ssss |= len(ppi) > 0\n\n\nprint(' '.join(map(str, p_size)))\n", "from collections import deque\nimport sys\nDBG =   False\nn,m,p = list(map(int, input().split()))\nspd = list(map(int, input().split()))\nspd.insert(0,-1)  # p starts at 1\ngrid = [ [0] * m for i in range(n) ]\nc2d = { \"#\":-1, \".\":0, \"1\":1, \"2\":2, \"3\":3, \"4\":4,\n        \"5\":5, \"6\":6, \"7\":7, \"8\":8, \"9\":9 }\ncastle = [ [] for i in range(p+1)]\n\nfor i in range(n):\n  s = input()\n  for j in range(m):\n    v = c2d[s[j]]\n    grid[i][j] = v\n    if v>0:\n      castle[v].append([i,j])\n\nif DBG:\n  print(grid)\n  print(\"\\n\")\n  print(spd)\n  print(\"\\n\")\n\ndef mark(proc,t):\n  nonlocal changed, grid, castle, newcastle\n  dir = [ [1,0], [-1,0], [0,1], [0,-1] ]\n  while len(proc) > 0:\n    ent = proc.popleft()\n    c = ent[0]\n    s = ent[1]\n    for d in dir:\n      x = c[0]+d[0]\n      y = c[1]+d[1]\n      if x<0 or n<=x or y<0 or m<=y or grid[x][y]!=0:\n          continue\n      changed = True\n      grid[x][y] = t\n      if s>1:\n        proc.append([ [x,y], s-1 ])\n      else:\n        newcastle.append([x,y])\n\n\nchanged = True\nwhile changed:\n  if DBG:\n    print(\"---- new loop ----\")\n  changed = False\n  for t in range(1,p+1):\n    newcastle = []\n    proc = deque([])\n    for c in castle[t]:\n        proc.append([c, spd[t]])\n    mark(proc, t)\n    if False and DBG:\n        print((\"turn for %d, (%d,%d) ended\" %\n                     (t,c[0],c[1])))\n        print(grid)\n    #for x in $newcastle\n    #  $castle[t] << x\n    #end\n    castle[t] = newcastle\n\na = [ 0 for i in range(p+1) ]\nfor x in range(n):\n  for y in range(m):\n    if grid[x][y] != -1:\n      a[grid[x][y]] += 1\n\nfor i in range(1,p+1):\n  sys.stdout.write(\"%d \" % a[i])\nprint(\"\")\n", "import time\n\n\ndef get_frontiers(feild, n, m, p):\n    # print(feild)\n    # print(n, m)\n    frontiers = [[] for i in range(p)]\n    for i in range(n):\n        for j in range(m):\n            ele = feild[i][j]\n            if 1 <= ele <= 9:\n                # print('ele:', ele)\n                frontiers[ele - 1].append((i, j))\n    return frontiers\n\ndef go(player_id, frontier, n_turn, feild, n, m):\n    frontier = frontier\n    # print('In go:', player_id, frontier, n_turn)\n    while n_turn and frontier:\n        n_turn -= 1\n        new_frontier = []\n        for i, j in frontier:\n            # Down.\n            if i + 1 < n:\n                new_space = feild[i + 1][j]\n                if not new_space:\n                    feild[i + 1][j] = player_id\n                    new_frontier.append((i + 1, j))\n            # Up.\n            if i - 1 >= 0:\n                new_space = feild[i - 1][j]\n                if not new_space:\n                    feild[i - 1][j] = player_id\n                    new_frontier.append((i - 1, j))\n            # Rigth.\n            if j + 1 < m:\n                new_space = feild[i][j + 1]\n                if not new_space:\n                    feild[i][j + 1] = player_id\n                    new_frontier.append((i, j + 1))\n            # Left.\n            if j - 1 >= 0:\n                new_space = feild[i][j - 1]\n                if not new_space:\n                    feild[i][j - 1] = player_id\n                    new_frontier.append((i, j - 1))\n\n            # for d_i, d_j in (-1, 0), (1, 0), (0, 1), (0, -1):\n                # check boarder.\n                # new_i, new_j = i + d_i, j + d_j\n                # if new_i < 0 or new_j < 0 or new_i > n - 1 or new_j > m - 1:\n                    # continue\n                # new_space = feild[new_i][new_j]\n                # if new_space == 0:\n                    # feild[new_i][new_j] = player_id\n                    # new_frontier.append((new_i, new_j))\n        frontier = new_frontier\n                # print('haha:', frontier)\n        # print('player:', player_id)\n\n        # for ele in feild:\n            # print(ele)\n    # print('Got new frontier:', frontier)\n    return frontier\n\ndef solve(speeds, feild, n, m, p):\n    frontiers = get_frontiers(feild, n, m, p)\n    # print('f:', frontiers)\n    hope = set(range(p))\n    while hope:\n        new_hope = set()\n        for i in hope:\n            n_turn = speeds[i]\n            frontier = frontiers[i]\n            new_frontier = go(i + 1, frontier, n_turn, feild, n, m)\n            # print('i:', i)\n            # print(new_frontier)\n            if new_frontier:\n                new_hope.add(i)\n            frontiers[i] = new_frontier\n        hope = new_hope\n    result = get_frontiers(feild, n, m, p)\n    return [len(ele) for ele in result]\n\ndef test():\n    n, m, p = 1000, 1000, 9\n    speeds = [1000000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 1]\n    feild = [[0, -1] * (m // 2) for i in range(n)]\n    for i in range(m):\n        if i % 4 != 1:\n            feild[0][i] = 0\n        if i % 4 != 3:\n            feild[n - 1][i] = 0\n    # feild[0][0] = 1\n    for i in range(9):\n        feild[0][i * 8] = i + 1    \n    # for ele in feild:\n        # print(ele)\n    tick = time.time()\n    result = solve(speeds, feild, n, m, p)\n    tock = time.time()\n    print(' '.join(map(str, result)))\n    print('T:', round(tock - tick, 5))\n\ndef main():\n    d = {str(i): i for i in range(1, 10)}\n    d['.'] = 0\n    d['#'] = -1\n    n, m, p = map(int, input().split())\n    speeds = list(map(int, input().split()))\n    feild = []\n    for i in range(n):\n        feild.append(list(map(d.get, input())))\n    # for ele in feild:\n        # print(ele)\n    result = solve(speeds, feild, n, m, p)\n    print(' '.join(map(str, result)))\n    # for ele in feild:\n        # print(ele)\n\ndef __starting_point():\n    main()\n__starting_point()", "import time\n\n\ndef get_frontiers(feild, n, m, p):\n    # print(feild)\n    # print(n, m)\n    frontiers = [[] for i in range(p)]\n    for i in range(n):\n        for j in range(m):\n            ele = feild[i][j]\n            if 1 <= ele <= 9:\n                # print('ele:', ele)\n                frontiers[ele - 1].append((i, j))\n    return frontiers\n\ndef go(player_id, frontier, n_turn, feild, n, m):\n    frontier = frontier\n    # print('In go:', player_id, frontier, n_turn)\n    while n_turn and frontier:\n        n_turn -= 1\n        new_frontier = []\n        for i, j in frontier:\n            # Down.\n            if i + 1 < n:\n                new_space = feild[i + 1][j]\n                if not new_space:\n                    feild[i + 1][j] = player_id\n                    new_frontier.append((i + 1, j))\n            # Up.\n            if i - 1 >= 0:\n                new_space = feild[i - 1][j]\n                if not new_space:\n                    feild[i - 1][j] = player_id\n                    new_frontier.append((i - 1, j))\n            # Rigth.\n            if j + 1 < m:\n                new_space = feild[i][j + 1]\n                if not new_space:\n                    feild[i][j + 1] = player_id\n                    new_frontier.append((i, j + 1))\n            # Left.\n            if j - 1 >= 0:\n                new_space = feild[i][j - 1]\n                if not new_space:\n                    feild[i][j - 1] = player_id\n                    new_frontier.append((i, j - 1))\n\n            # for d_i, d_j in (-1, 0), (1, 0), (0, 1), (0, -1):\n                # check boarder.\n                # new_i, new_j = i + d_i, j + d_j\n                # if new_i < 0 or new_j < 0 or new_i > n - 1 or new_j > m - 1:\n                    # continue\n                # new_space = feild[new_i][new_j]\n                # if new_space == 0:\n                    # feild[new_i][new_j] = player_id\n                    # new_frontier.append((new_i, new_j))\n        frontier = new_frontier\n                # print('haha:', frontier)\n        # print('player:', player_id)\n\n        # for ele in feild:\n            # print(ele)\n    # print('Got new frontier:', frontier)\n    return frontier\n\ndef solve(speeds, feild, n, m, p):\n    frontiers = get_frontiers(feild, n, m, p)\n    # print('f:', frontiers)\n    hope = set(range(p))\n    while hope:\n        lost_hope = set()\n        for i in hope:\n            n_turn = speeds[i]\n            frontier = frontiers[i]\n            new_frontier = go(i + 1, frontier, n_turn, feild, n, m)\n            # print('i:', i)\n            # print(new_frontier)\n            if not new_frontier:\n                lost_hope.add(i)\n            frontiers[i] = new_frontier\n        hope -= lost_hope\n    result = get_frontiers(feild, n, m, p)\n    return [len(ele) for ele in result]\n\ndef test():\n    n, m, p = 1000, 1000, 9\n    speeds = [1000000, 100000, 100000, 100000, 100000, 100000, 100000, 100000, 1]\n    feild = [[0, -1] * (m // 2) for i in range(n)]\n    for i in range(m):\n        if i % 4 != 1:\n            feild[0][i] = 0\n        if i % 4 != 3:\n            feild[n - 1][i] = 0\n    # feild[0][0] = 1\n    for i in range(9):\n        feild[0][i * 8] = i + 1    \n    # for ele in feild:\n        # print(ele)\n    tick = time.time()\n    result = solve(speeds, feild, n, m, p)\n    tock = time.time()\n    print(' '.join(map(str, result)))\n    print('T:', round(tock - tick, 5))\n\ndef main():\n    d = {str(i): i for i in range(1, 10)}\n    d['.'] = 0\n    d['#'] = -1\n    n, m, p = map(int, input().split())\n    speeds = list(map(int, input().split()))\n    feild = []\n    for i in range(n):\n        feild.append(list(map(d.get, input())))\n    # for ele in feild:\n        # print(ele)\n    result = solve(speeds, feild, n, m, p)\n    print(' '.join(map(str, result)))\n    # for ele in feild:\n        # print(ele)\n\ndef __starting_point():\n    main()\n__starting_point()", "[n, m, p] = [int(x) for x in input().split()]\ns = [int(x) for x in input().split()]\n\n\ncoord_change = [[0,1],[0,-1],[1,0],[-1,0]]\n\ngrid = []\n\nvisited = [[False]*1010 for x in range(1010)]\n\nqueue = [[] for x in range(10)]\ncontrolled = [0]*10\n\nfor i in range(n):\n    grid.append(input())\n    for j in range(m):\n        if grid[i][j] == '.':\n            continue\n        elif grid[i][j] == '#':\n            visited[i][j] = True\n        else:\n            player = int(grid[i][j])-1\n            visited[i][j] = True\n            queue[player].append([i,j])\n            controlled[player] += 1\n\n\n\ncurr_p = 0\nwhile any(queue):\n    moves = 0\n    # print(curr_p, queue,s)\n    while moves < s[curr_p] and queue[curr_p]:\n        new_queue = []\n        curr_queue = queue[curr_p]\n        for coord in curr_queue:\n            for change in coord_change:\n                new_coord = [coord[0]+change[0],coord[1]+change[1]]\n                if new_coord[0] < 0 or new_coord[1] < 0 or new_coord[0] >= n or new_coord[1] >= m:\n                    continue\n                if visited[new_coord[0]][new_coord[1]]:\n                    continue\n\n                visited[new_coord[0]][new_coord[1]] = True\n                controlled[curr_p] += 1\n                new_queue.append(new_coord)\n        moves += 1\n        queue[curr_p] = new_queue\n    curr_p += 1\n    curr_p %= p\n\n# print(grid[0])\n# print(controlled)\nfor i in range(p):\n    print(controlled[i],end=' ')", "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nmod=998244353\ndef check(x,y,n,m):\n\treturn (0<=x<n and 0<=y<m)\nn,m,k=list(map(int,sys.stdin.readline().split()))\ngrid=[]\ns=list(map(int,sys.stdin.readline().split()))\nfor i in range(n):\n\tgrid.append(list(sys.stdin.readline()[:-1]))\nq=deque()\ndic=defaultdict(deque)\nfor i in range(n):\n\tfor j in range(m):\n\t\tif grid[i][j]!='.' and grid[i][j]!='#':\n\t\t\tdic[int(grid[i][j])].append([i,j])\n\t\t\t#q.append([int(grid[i][j]),i,j])\nq=True\ndirs=[[0,1],[0,-1],[1,0],[-1,0]]\nwhile q:\n\tz=True\n\tfor i in range(k):\n\t\tnq=deque()\n\t\twhile dic[i+1]:\n\t\t\tj=dic[i+1].popleft()\n\t\t\t#print(j,'j')\n\t\t\tnq.append(j+[s[i]])\n\t\t\tz=False\n\t\tp=i+1\n\t\twhile nq:\n\t\t\t#print(nq,'nq')\n\t\t\tx,y,dis=nq.popleft()\n\t\t\tif dis==0:\n\t\t\t\tdic[p].append([x,y])\n\t\t\telse:\n\t\t\t\tfor i,j in dirs:\n\t\t\t\t\tnx,ny=x+i,y+j\n\t\t\t\t\tif check(nx,ny,n,m) and grid[nx][ny]=='.':\n\t\t\t\t\t\tgrid[nx][ny]=p\n\t\t\t\t\t\t#print(nx,'nx',ny,'ny',dis-1,'dis-1')\n\t\t\t\t\t\tnq.append([nx,ny,dis-1])\n\t\t\n\tif z:\n\t\tq=False\n\n'''for i in range(k):\n\tfor j in dic[i+1]:\n\t\tq.append([i+1]+j)\n#print(q,'q')\n\nwhile q:\n\tp,curx,cury=q.popleft()\n\n\t#print(p,'p',curx,'curx',cury,'cury',s[p-1])\n\tnq=deque()\n\tnq.append([curx,cury,s[p-1]])\n\tif int(grid[curx][cury])==p:\n\t\twhile nq:\n\t\t\tx,y,dis=nq.popleft()\n\t\t\t#print(x,'x',y,'y',dis,'dis')\n\t\t\tif dis==0:\n\t\t\t\tq.append([p,x,y])\n\t\t\telse:\n\t\t\t\tfor i,j in dirs:\n\t\t\t\t\tnx,ny=x+i,y+j\n\t\t\t\t\tif check(nx,ny,n,m) and grid[nx][ny]=='.':\n\t\t\t\t\t\tgrid[nx][ny]=p\n\t\t\t\t\t\t#print(nx,'nx',ny,'ny',dis-1,'dis-1')\n\t\t\t\t\t\tnq.append([nx,ny,dis-1])\n\tfor i in range(n):\n\t\tprint(grid[i])\n\tprint('\\n')'''\nans=[0 for _ in range(k)]\n#print(ans,'ans')\nfor i in range(n):\n\tfor j in range(m):\n\t\tif grid[i][j]!='.' and grid[i][j]!='#':\n\t\t\tans[int(grid[i][j])-1]+=1\n#print(grid,'grid')\nprint(*ans)\n\n"]
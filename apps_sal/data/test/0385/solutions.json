["n, m, p = [int(x) for x in input().split()]\nA = input().rstrip()\nB = input().rstrip()\n\npair = [0] * n\nstack = []\nfor (i, c) in enumerate(A):\n    if c == '(':\n        stack.append(i)\n    else:\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\nstart = 0\npointer = p - 1\nleft = list(range(-1, n-1))\nright = list(range(1, n+1))\nleft[0] = None\nright[-1] = None\n\nfor c in B:\n    if c == 'R':\n        pointer = right[pointer]\n    elif c == 'L':\n        pointer = left[pointer]\n    else:\n        if pair[pointer] < pointer:\n            if right[pointer] is not None:\n                left[right[pointer]] = left[pair[pointer]]\n            if left[pair[pointer]] is not None:\n                right[left[pair[pointer]]] = right[pointer]\n            else:\n                start = right[pointer]\n\n            if right[pointer] is None:\n                pointer = left[pair[pointer]]\n            else:\n                pointer = right[pointer]\n        else:\n            if right[pair[pointer]] is not None:\n                left[right[pair[pointer]]] = left[pointer]\n            if left[pointer] is not None:\n                right[left[pointer]] = right[pair[pointer]]\n            else:\n                start = right[pair[pointer]]\n\n\n            if right[pair[pointer]] is None:\n                pointer = left[pointer]\n            else:\n                pointer = right[pair[pointer]]\n\ni = start\nwhile right[i] is not None:\n    print(A[i], end = '')\n    i = right[i]\nprint(A[i])\n", "def main():\n    n, m, p = list(map(int, input().split()))\n    xlat, l, s, ll, lr = [0] * n, [], input(), list(range(-1, n)), list(range(1, n + 2))\n    p -= 1\n    for i, c in enumerate(s):\n        if c == '(':\n            l.append(i)\n        else:\n            j = l.pop()\n            xlat[i] = j\n            xlat[j] = i\n    for c in input():\n        if c == 'D':\n            if s[p] == '(':\n                p = xlat[p]\n            q = ll[xlat[p]]\n            p = lr[p]\n            ll[p], lr[q] = q, p\n            if p == n:\n                p = ll[p]\n        else:\n            p = (lr if c == 'R' else ll)[p]\n    q = p\n    while p != -1:\n        l.append(s[p])\n        p = ll[p]\n    l.reverse()\n    del l[-1]\n    while q != n:\n        l.append(s[q])\n        q = lr[q]\n    print(''.join(l))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m, p = list(map(int, input().split())); x, v, s, l, r = [0]*n, [], input(), list(range(-1, n)), list(range(1, n+2))\np -= 1\nfor i, c in enumerate(s):\n        if c == '(': v.append(i)\n        else:\n                j = v.pop()\n                x[i] = j\n                x[j] = i\nfor c in input():\n        if c == 'D':\n                if s[p] == '(':\n                        p = x[p]\n                q = l[x[p]]\n                p = r[p]\n                l[p], r[q] = q, p\n                if p == n:\n                        p = l[p]\n        else:\n                p = (r if c == 'R' else l)[p]\nq = p\nwhile p != -1:\n        v.append(s[p])\n        p = l[p]\nv.reverse()\ndel v[-1]\nwhile q != n:\n        v.append(s[q])\n        q = r[q]\nprint(''.join(v))\n", "def preproc(str, leng):\n\tli = []\n\tres = [-1]*leng\n\tfor i in range(leng):\n\t\tif str[i] == '(':\n\t\t\tli.append(i)\n\t\telse:\n\t\t\tstart, end = li.pop(), i\n\t\t\tres[start] = end\n\t\t\tres[end] = start\n\treturn res\n\t\ndef delete(flags, cursor, pairs):\n\tpos = pairs[cursor]\n\tdirection = 1 if pos > cursor else -1\n\twhile(pos+direction > 0 and pos+direction < len(flags) and flags[pos+direction] != -1):\n\t\tpos = flags[pos+direction]\n\treturn pos\n\nleng, op_num, cursor = map(int, input().strip().split())\ncursor = cursor-1\nstr = input().strip()\nops = input().strip()\npairs = preproc(str, leng)\nflags = [-1]*leng\n#print(leng, op_num, cursor, str, ops, pairs)\nfor i in ops:\n\t#print(i, cursor, flags)\n\tif i == 'R' or i == 'L':\n\t\tcursor = {\n\t\t\t'R':(lambda cursor=cursor, flags=flags: cursor+1 if flags[cursor+1] == -1 else flags[cursor+1]+1),\n\t\t\t'L':(lambda cursor=cursor, flags=flags: cursor-1 if flags[cursor-1] == -1 else flags[cursor-1]-1)\n\t\t}[i]()\n\telse:\n\t\tdelete_to = delete(flags, cursor, pairs)\n\t\tdelete_from = delete(flags, pairs[cursor], pairs)\n\t\tflags[delete_from] = delete_to\n\t\tflags[delete_to] = delete_from\n\t\tcursor = max(delete_to, delete_from)\n\t\tif cursor+1 < leng and flags[cursor+1] == -1:\n\t\t\tcursor = cursor+1\n\t\telif cursor+1 < leng and flags[cursor+1] != -1 and flags[cursor+1]+1 < leng:\n\t\t\tcursor = flags[cursor+1]+1\n\t\telif min(delete_from, delete_to) -1 > 0 and flags[min(delete_from, delete_to)-1] == -1:\n\t\t\tcursor = min(delete_from, delete_to)-1\n\t\telse:\n\t\t\tcursor = flags[min(delete_from, delete_to)-1]-1\nidx = 0\nres = ''\nwhile idx < leng:\n\tif flags[idx] != -1:\n\t\tidx = flags[idx]+1\n\t\tcontinue\n\tres += str[idx]\n\tidx = idx+1\nprint(res)", "class Node:\n    def __init__(self, index):\n        self.left = index - 1\n        self.right = index + 1\n        self.pair = -1\n\ndef __starting_point():\n    n, m, p = map(int, input().split())\n    brackets = input()\n    operations = input()\n\n    nodes = [Node(i) for i in range(n + 1)]\n    stack = []\n\n    for i in range(n):\n        if brackets[i] == \"(\":\n            stack.append(i + 1)\n        else:\n            pair_id = stack.pop()\n            nodes[pair_id].pair = i + 1\n            nodes[i + 1].pair = pair_id\n\n    for i in range(m):\n        if operations[i] == \"L\":\n            p = nodes[p].left\n        elif operations[i] == \"R\":\n            p = nodes[p].right\n        else:\n            pair_id = nodes[p].pair\n            left = 0\n            right = 0\n\n            if p < pair_id:\n                left = p\n                right = pair_id\n            else:\n                left = pair_id\n                right = p\n\n            left_node = nodes[left].left\n            right_node = nodes[right].right\n\n            nodes[left_node].right = right_node\n            if right_node != n + 1:\n                nodes[right_node].left = left_node\n                p = right_node\n            else:\n                p = left_node\n\n    p = nodes[0].right\n    result = []\n    while p != n + 1:\n        result.append(brackets[p - 1])\n        p = nodes[p].right\n        \n    print(\"\".join(result))\n__starting_point()", "class Node:\n    def __init__(self, index):\n        self.left = index - 1\n        self.right = index + 1\n        self.pair = -1\n\ndef __starting_point():\n    n, m, p = map(int, input().split())\n    brackets = input()\n    operations = input()\n\n    nodes = [Node(i) for i in range(n + 1)]\n    stack = []\n\n    for i in range(n):\n        if brackets[i] == \"(\":\n            stack.append(i + 1)\n        else:\n            pair_id = stack.pop()\n            nodes[pair_id].pair = i + 1\n            nodes[i + 1].pair = pair_id\n\n    for i in range(m):\n        if operations[i] == \"L\":\n            p = nodes[p].left\n        elif operations[i] == \"R\":\n            p = nodes[p].right\n        else:\n            pair_id = nodes[p].pair\n            \n            left = min(p, pair_id)\n            right = max(p, pair_id)\n\n            left_node = nodes[left].left\n            right_node = nodes[right].right\n\n            nodes[left_node].right = right_node\n            if right_node != n + 1:\n                nodes[right_node].left = left_node\n                p = right_node\n            else:\n                p = left_node\n\n    p = nodes[0].right\n    result = []\n    while p != n + 1:\n        result.append(brackets[p - 1])\n        p = nodes[p].right\n\n    print(\"\".join(result))\n__starting_point()", "jump_r = {}\njump_l = {}\n\ndef bracket_to_value(bracket):\n    if bracket == '(':\n        return 1\n    if bracket == ')':\n        return -1\n\ndef move_r(c):\n    if c+1 in jump_r:\n        return jump_r[c+1]+1\n    else:\n        return c+1\n\ndef move_l(c):\n        if c-1 in jump_l:\n            return jump_l[c-1]-1\n        else:\n            return c-1\n\ndef remove_bracket(s, c, length):\n\n    val = bracket_to_value(s[c])\n    initial_c = c\n    dir = bracket_to_value(s[c])\n    #print(f'started at c ={c} and dir = {dir}')\n    if dir == 1:\n        c = move_r(c)\n    if dir == -1:\n        c = move_l(c)\n    val += bracket_to_value(s[c])\n    while val != 0:\n        #print(f'wwwc = {c} val = {val} s[c] = {s[c]}')\n        if dir == 1:\n            c = move_r(c)\n        if dir == -1:\n            c = move_l(c)\n        val += bracket_to_value(s[c])\n    final_c = c\n\n    left_end = min(initial_c, final_c)\n    right_end = max(initial_c, final_c)\n    real_r_end = right_end\n    real_l_end = left_end\n    #print(f'left_end = {left_end} roght_end = {right_end}')\n    jump_r[left_end] = right_end\n    jump_l[right_end] = left_end\n    if right_end + 1 in jump_r:\n        real_r_end = jump_r[right_end+1]\n    if left_end - 1 in jump_l:\n        real_l_end = jump_l[left_end-1]\n\n    jump_l[real_r_end] = real_l_end\n    jump_r[real_l_end] = real_r_end\n\n    if real_r_end < length - 1:\n        new_c = real_r_end+1\n    else:\n        new_c = real_l_end - 1\n\n\n    return new_c\n\ndef smart_print(s):\n    i = 0\n    while i < n:\n        if i not in jump_r:\n            print(s[i], end='')\n            i += 1\n        else:\n            i = jump_r[i]+1\n\n\ndef perform_order(order, s, c, length):\n    if order == 'R':\n        return move_r(c)\n    if order == 'L':\n        return move_l(c)\n    if order == 'D':\n        return remove_bracket(s, c, length)\n\nn, m, p = [int(x) for x in input().split()]\np = p-1\nse = input()\norders = input()\nfor ord in orders:\n    p = perform_order(ord, se, p, n)\n    #print(f'jump_r = {jump_r} jump_l = {jump_l} p = {p} s = {se}')\n\nsmart_print(se)\n   # print(f'se = {se} p = {p}')\n#print(jump_r)\n\n# 3->6\n#\n# 0 1 2 3 4 5 6 7 8 9 10 11\n# ( ( ( ) ( ) ) ( ( ) )  )"]
["from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 998244353\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nK,N = inpl()\nMAX = K+N+10\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\ngyakugen = [1]*(MAX+1)\ngyakugen[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n\tgyakugen[i-1] = (gyakugen[i]*i)%mod\n\ndef Comb(n,k):#nCk\n\treturn (fac[n]*gyakugen[k]*gyakugen[n-k])%mod\n\n#K=k,N=n,0pair = 0\ndef calc(k,n,i):\n\t#i=2\u306b\u5e30\u7740\u3055\u305b\u308b\n\tpairs = (i-2)//2\n\tk -= pairs\n\tn -= pairs\n\n\t#\u8272\u3005\u3068\u4f8b\u5916\u51e6\u7406\n\tif n < 0 or k <= 0:\n\t\treturn 0\n\telif k == 1 and n >= 2:\n\t\treturn 0\n\n\tif n == 0: \t #\u7403\u304c0\u500b\u306a\u30891\u901a\u308a\n\t\tans = 1\n\telse:\n\t\tans = 0\n\t\t#i=2\u306e\u6642\u306e\u6570\u3048\u4e0a\u3052\n\t\tfor x in range(2):\n\t\t\tball = n-x\t#\u7403\n\t\t\tbox = k-1\t#\u7bb1\n\t\t\tans += Comb(box-1+ball,ball)%mod\n\n\tans *= pow(2,pairs,mod)\t#0pair\u306e\u9078\u3073\u65b9\n\treturn ans % mod\n\nans = []\nfor i in range(2,K+2):\n\tif i%2 == 0:\n\t\tpairs = (i-2)//2\n\t\ttmp = 0\n\t\tfor p0 in range(pairs+1): #p0 = 0pair\u306e\u6570\n\t\t\ttmp1 = calc(K-p0*2 , N , i-p0*2) %mod #k-p0*2,i-p0*2\u30670pair\u304c0\u7d44\n\t\t\ttmp2 = Comb(pairs,p0) %mod #0pair\u306e\u9078\u3073\u65b9\n\t\t\ttmp += tmp1 * tmp2\n\t\t\ttmp %= mod\n\tans.append(tmp)\n\tprint(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n\tprint((ans[i]))\n", "import sys\ninput = sys.stdin.readline\n\n# K+1 - x \u3067\u3046\u3064\u3059 -> i \u3068 2K+2-i \u306f\u540c\u3058\n\nMOD = 998244353\nU = 10000\nfact = [1] * (U+1)\nfact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[n] = pow(fact[n], MOD-2, MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if not (0 <= k <= n):\n        return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nK,N = list(map(int,input().split()))\n\ndef F(x,y,N):\n    n = min(x, N)\n    return sum(comb(x,i) * pow(2,i,MOD) * comb(N+y-1,i+y-1) % MOD for i in range(n+1)) % MOD\n\nanswer = []\nfor S in range(3,K+3,2):\n    x = F((S-1)//2, K - S + 1, N)\n    answer.append(x)\n    answer.append(x)\n\nif K & 1:\n    answer = answer[:-1]\n    answer += answer[:-1][::-1]\nelse:\n    answer += answer[:-1][::-1]    \n\nprint(('\\n'.join(map(str,answer))))\n\n", "def mul(c,m,dp): #multiply (1+x^c) up to x^m\n    for i in range(m,c-1,-1):\n        dp[i] += dp[i-c]\n        dp[i] %= MOD\n\ndef mul2(c,m,dp): #multiply (1+x^c) up to x^m\n    for i in range(m,c-1,-1):\n        dp[i] -= dp[i-c]\n        dp[i] %= MOD\n \ndef div(c,m,dp): #divide by (1-x^c) up to x^m\n    for i in range(m-c+1):\n        dp[i+c] += dp[i]\n        dp[i+c] %= MOD\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nMOD = 998244353\n#n = int(readline())\nk,n = map(int,readline().split())\n\nans = [0]*(2*k+1)\ndp = [1]+[0]*n\nfor _ in range(k-1):\n    div(1,n,dp)\nans[2] = (dp[n-1]+dp[n])\nfor i in range(3,k+2):\n    if i%2:\n        mul(1,n,dp)\n        ans[i] = dp[n]\n    else:\n        mul2(1,n,dp)\n        ans[i] = dp[n-1]+dp[n]\n\nfor i in range(k+2,2*k+1):\n    ans[i] = ans[2+2*k-i]\n\nfor i in ans[2:]:\n    print(i%MOD)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef nCr(com_n, com_r):\n    if com_n < com_r: return 0\n    return fac[com_n] * ifac[com_r] % md * ifac[com_n - com_r] % md\n\ndef nHr(hn,hr):\n    return nCr(hn+hr-1,hr)\n\nmd = 998244353\nn_max = 5000\nfac = [1]\nfor i in range(1, n_max + 1): fac.append(fac[-1] * i % md)\nifac = [1] * (n_max + 1)\nifac[n_max] = pow(fac[n_max], md - 2, md)\nfor i in range(n_max - 1, 1, -1): ifac[i] = ifac[i + 1] * (i + 1) % md\n\ndef solve():\n    res=0\n    for p in range(min(t,n)//2+1):\n        cur=nCr(t//2,p)*nHr(k,n-2*p)\n        if p&1:res-=cur\n        else:res+=cur\n        res%=md\n    return res\n\nk,n=MI()\nans=[]\nfor t in range(2,k+2):\n    a=solve()\n    ans.append(a)\n    print(a)\nans.reverse()\nfor a in ans[1:]:print(a)\n", "K, N = map(int, input().split())\nmod = 998244353\ndef inved(a):\n  x, y, u, v, k, l = 1, 0, 0, 1, a, mod\n  while l != 0:\n    x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n    k, l = l, k % l\n  return x % mod\n\nX = [0 for i in range(2*K-1)]\nfrac = [1]\nfor i in range(N + K):\n  frac.append(((i+1)*frac[i])%mod)\ninvf = []\nfor i in range(N + K + 1):\n  invf.append(inved(frac[i]))\nfor k in range(2, K+2):\n  S = 0\n  sign = 1\n  l = k // 2\n  for m in range(min(l+1, N//2+1)):\n    prod = (sign * (frac[l]*frac[N+K-2*m-1])) % mod\n    prod *= (invf[m]*invf[l-m]) % mod\n    prod %= mod\n    prod *= (invf[N-2*m] * invf[K-1]) % mod\n    prod %= mod\n    S += prod\n    S %= mod\n    sign *= -1\n  X[k-2], X[2*K-k] = S, S\nfor i in range(2*K-1):\n  print(X[i])", "import sys\ninput = sys.stdin.readline\n\n# K+1 - x \u3067\u3046\u3064\u3059 -> i \u3068 2K+2-i \u306f\u540c\u3058\n\nMOD = 998244353\nU = 10000\nfact = [1] * (U+1)\nfact_inv = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[n] = pow(fact[n], MOD-2, MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if not (0 <= k <= n):\n        return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nK,N = map(int,input().split())\n\ndef F(x,y,N):\n    n = min(x, N)\n    return sum(comb(x,i) * pow(2,i,MOD) * comb(N+y-1,i+y-1) for i in range(n+1)) % MOD\n\nanswer = []\nfor S in range(2,K+2):\n    if S & 1:\n        x = F((S-1)//2, K - S + 1, N)\n    else:\n        x = F((S-1)//2, K - S + 1, N) + F((S-1)//2, K - S + 1, N - 1)\n    answer.append(x % MOD)\n\nanswer += answer[:-1][::-1]\n\nprint('\\n'.join(map(str,answer)))", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 998244353\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nK,N = inpl()\nMAX = K+N+10\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\ngyakugen = [1]*(MAX+1)\ngyakugen[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n\tgyakugen[i-1] = (gyakugen[i]*i)%mod\n\ndef Comb(n,k):#nCk\n\treturn (fac[n]*gyakugen[k]*gyakugen[n-k])%mod\n\n#K=k,N=n,0pair = 0\ndef calc(k,n,i):\n\t#i=2\u306b\u5e30\u7740\u3055\u305b\u308b\n\tpairs = (i-2)//2\n\tk -= pairs\n\tn -= pairs\n\n\t#\u8272\u3005\u3068\u4f8b\u5916\u51e6\u7406\n\tif n < 0 or k <= 0:\n\t\treturn 0\n\telif k == 1 and n >= 2:\n\t\treturn 0\n\n\tif n == 0: \t #\u7403\u304c0\u500b\u306a\u30891\u901a\u308a\n\t\tans = 1\n\telse:\n\t\tans = 0\n\t\t#i=2\u306e\u6642\u306e\u6570\u3048\u4e0a\u3052\n\t\tfor x in range(2):\n\t\t\tball = n-x\t#\u7403\n\t\t\tbox = k-1\t#\u7bb1\n\t\t\tans += Comb(box-1+ball,ball)%mod\n\n\tans *= pow(2,pairs,mod)\t#0pair\u306e\u9078\u3073\u65b9\n\treturn ans % mod\n\nans = []\nfor i in range(2,K+2):\n\tif i%2 == 0:\n\t\tpairs = (i-2)//2\n\t\ttmp = 0\n\t\tfor p0 in range(pairs+1): #p0 = 0pair\u306e\u6570\n\t\t\ttmp += calc(K-p0*2 , N , i-p0*2) * Comb(pairs,p0)%mod\n\t\t\ttmp %= mod\n\tans.append(tmp)\n\tprint(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n\tprint((ans[i]))\n", "K, N = map(int, input().split())\nP = 998244353\nfa = [1]\nfor i in range(1, 10000):\n    fa.append(fa[-1] * i % P)\nfainv = [pow(fa[-1], P-2, P)]\nfor i in range(1, 10000)[::-1]:\n    fainv.append(fainv[-1] * i % P)\nfainv = fainv[::-1]\ndef C(a, b):\n    if not (a >= 0 and 0 <= b <= a): return 0\n    return fa[a] * fainv[a-b] * fainv[b] % P\n\nA = []\nfor i in range(1, (K+1)//2+1):\n    s = 0\n    for j in range(i+1):\n        s += C(N+K-1-2*j, K-1) * C(i, j) * (-1) ** j\n        s %= P\n    A.append(s)\nfor i in range(2*K-1):\n    print(A[min(i//2, (2*K-i-2)//2)])", "k,n = list(map(int,input().split()))\nmod = 998244353\nfact = [1]*(n+k+1)\nrfact = [1]*(n+k+1)\nfor i in range(1, n+k):\n    fact[i] = r = (i * fact[i-1]) % mod\n    rfact[i] = pow(r, mod-2, mod)\n\nsave = []\nfor p in range(1,int((k+3)/2)):\n    i = 2 * p + 1\n    temp = 0\n    for t in range(min(p+1,n+1)):\n        if k-i+t<0:continue\n        res = (fact[p] * rfact[t] * rfact[p-t]) % mod\n        res *= (fact[n+k-i] * rfact[k-i+t] * rfact[n-t]) % mod\n        res *= pow(2,t,mod)\n        temp = (temp+res) % mod\n    save.append(temp)\noutput = []\ni = 1\nwhile i<k:\n    output.append(save[(i-1)//2])\n    i+=1\n\nfor x in output+[save[-1]]+output[::-1]:\n    print(x)\n\n", "#!/usr/bin/env python3\n\nM = 998244353\nfact = None\nfactr = None\n\ndef comb(n, k):\n    if n <= 0 or k < 0 or n < k:\n        return 0\n    r = fact[n] * factr[k] % M\n    r *= factr[n - k]\n    r %= M\n    return r\n\n\ndef solve(k, n):\n    nonlocal fact, factr\n\n    inv = [1] * (k + n + 1)\n    for i in range(2, k + n + 1):\n        inv[i] = inv[M % i] * (M - M // i) % M\n    fact = [1] * (k + n + 1)\n    factr = [1] * (k + n + 1)\n    for i in range(2, k + n + 1):\n        fact[i] = fact[i - 1] * i % M\n        factr[i] = factr[i - 1] * inv[i] % M\n\n    if k == 1:\n        print((0))\n        return\n    if k == 2:\n        for _ in range(3):\n            print((2))\n        return\n\n\n    g0 = (comb(k + n - 2, k - 2) + comb(k + n - 3, k - 2)) % M\n    g1 = comb(k + n - 1, k - 1)\n\n    rs0 = [0] * (min(k // 2, n // 2) + 1)\n    rs1 = [0] * (min(k // 2, n // 2) + 1)\n    for t in range(1, min(k // 2, n // 2) + 1):\n        rs0[t] = (comb(k + n - 2 * t - 2, k - 2) + comb(k + n - 2 * t - 3, k - 2)) % M\n        rs1[t] = comb(k + n - 2 * t - 1, k - 1)\n\n    results = [0] * (k + 2)\n\n    for i in range(2, k + 2):\n        ns = (i - 1) // 2\n        ans = g0 if i % 2 == 0 else g1\n        p = -1\n        for t in range(1, min(ns, n // 2) + 1):\n            r = rs0[t] if i % 2 == 0 else rs1[t]\n            r *= comb(ns, t)\n            r %= M\n            ans += M + p * r\n            ans %= M\n            p = 0 - p\n        print(ans)\n        results[i] = ans\n    for i in range(k + 2, 2 * k + 1):\n        print((results[2 * k + 2 - i]))\n\n\ndef main():\n    k, n = input().split()\n    k = int(k)\n    n = int(n)\n\n    solve(k, n)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "K,N=list(map(int,input().split()))\nmod=998244353\n\nINV=[None]*(N+K+2)\nfor i in range(1,N+K+2):\n    INV[i]=pow(i,mod-2,mod)\n \nCombi=[None]*(N+K+1)#Combi[i]=i C (K-1) \u3092\u8868\u3059\nCombi[K-1]=1\nfor i in range(K,N+K+1):\n    Combi[i]=Combi[i-1]*i *INV[i-K+1] %mod\n\n\n\n\n\nall=Combi[N+K-1]\nANSLIST=[]\nfor i in range(2,2+K):\n    ANS=all\n    x=i//2-max(0,(i-K-1))\n    CB_x=1\n\n    j=1\n    while N+K-1-j*2>=K-1 and j<=x:\n        CB_x=CB_x*(x-j+1)//j\n        #print(CB_x)\n        ANS+=((-1)**j)*CB_x*Combi[N+K-1-j*2]\n        #print(((-1)**j)*CB_x*Combi[N+K-1-j],ANS)\n        ANS=ANS%mod\n\n        j+=1\n        #print(i,j,ANS)\n    \n    #ANS-=x*Combi[N+K-3]\n    ANSLIST.append(ANS%mod)\n\n\nfor i in ANSLIST:\n    print(i)\nANSLIST=ANSLIST[::-1]\nfor j in ANSLIST[1:]:\n    print(j)\n\n    \n        \n\n", "def cmb(n,r):\n  if n<0:\n    return 0\n  if n==0:\n    if r!=0:\n      return 0\n    else:\n      return 1\n  elif r<0:\n    return 0\n  elif r>n:\n    return 0\n  elif r==0:\n    return 1\n  elif r==n:\n    return 1\n  else:\n    return A[n]*B[r]*B[n-r]%mod\nmod=998244353\nA=[1,1]\nB=[1,1]\nfor i in range(2,4005):\n  A.append(A[-1]*i%mod)\n  B.append(B[-1]*pow(i,mod-2,mod)%mod)\nk,n=map(int,input().split())\nif k==1:\n  print(0)\n  return\nans=[0]*(2*k+1)\nfor i in range(2,k+3):#i,i+1(i%2=0,i<k(\u304f\u3089\u3044))\u3067\u540c\u3058\u3068\u304b\u81ea\u660e\u304b\uff1f\uff1f\uff1f\uff1f\uff1f\n  if i%2==0:\n    i=i+1\n    for j in range(min(n+1,i//2+1)):\n      ans[i-1]=(ans[i-1]+cmb(n+k-i,k-i+j)*cmb(i//2,j)*pow(2,j,mod))%mod\n  else:\n    ans[i]=ans[i-1]\nfor i in range(k+2,2*k+1):\n  ans[i]=ans[2*k+2-i]\nfor i in range(2,2*k+1):\n  print(ans[i])", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,datetime\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 998244353\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\n\nK,N = inpl()\nMAX = K+N+10\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\ngyakugen = [1]*(MAX+1)\ngyakugen[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n\tgyakugen[i-1] = (gyakugen[i]*i)%mod\n\ndef Comb(n,k):#nCk\n\treturn (fac[n]*gyakugen[k]*gyakugen[n-k])%mod\n\n#K=k,N=n,0pair = 0\ndef calc(k,n,i):\n\tx = (i-2)//2\n\tk -= x\n\tn -= x\n\tif k == 1:\n\t\tif n <= 1:\n\t\t\treturn n\n\t\telse:\n\t\t\treturn 0\n\telif n == 0:\n\t\treturn pow(2,x,mod)\n\telif n < 0 or k <= 0:\n\t\treturn 0\n\n\ttmp = 0\n\tfor j in range(2):\n\t\tzb = n-j\n\t\tzm = k-2\n\t\ttmp += Comb(zb+zm,zb)%mod\n\ttmp %= mod\n\ttmp *= pow(2,x,mod)\n\treturn tmp\n\nans = []\nfor i in range(2,K+2):\n\tif i%2 == 0:\n\t\tpairs = (i-2)//2\n\t\ttmp = 0\n\t\tfor p0 in range(pairs+1):\n\t\t\ttmp += calc(K-p0*2,N,i-p0*2)*Comb(pairs,p0)%mod\n\t\t\ttmp %= mod\n\tans.append(tmp)\n\tprint(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n\tprint((ans[i]))\n", "K,N = list(map(int, input().split()))\nMAX = K+N+3\nmod = 998244353\n\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\nrev_m = [1]*(MAX+1)\nrev_m[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n\trev_m[i-1] = (rev_m[i]*i)%mod\n\ndef Comb(n,k):#nCk\n\treturn (fac[n]*rev_m[k]*rev_m[n-k])%mod\n\n\ndef f(n,k,i):\n\tif i == 2:\n\t\tif n < 0 or (k==1 and n>=2): #\u4f8b\u5916\u51e6\u7406\n\t\t\treturn 0\n\t\telif n == 0:\n\t\t\treturn 1\n\t\telse:\n\t\t\treturn (Comb(k-2+n,n)+Comb(k-2+n-1,n-1)) % mod\n\telse: #i>2\n\t\tSp = i//2-1\n\t\tans = 0\n\t\tfor p in range(Sp+1):\n\t\t\tans += g(n,k,i,p)\n\t\treturn ans % mod\n\ndef g(n,k,i,p):\n\tSp = i//2-1\n\tif p == 0:\n\t\treturn f(n-Sp,k-Sp,2) * pow(2,Sp,mod) % mod\n\telse: #p>0\n\t\treturn g(n,k-2*p,i-2*p,0) * Comb(Sp,p)\n\nans = []\nfor i in range(2,K+2):\n\tif i%2 == 0:\n\t\ttmp = f(N,K,i)\n\tans.append(tmp)\n\tprint(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n\tprint((ans[i]))\n", "def prepare(k, n, MOD):\n    def get_factorials(m):\n        f = 1\n        factorials = [1]\n        for m in range(1, m + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (m + 1)\n        invs[m] = inv\n        for m in range(m, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n\n        return factorials, invs\n\n    def solve(p):\n        \"\"\"Number of patterns where no pair of p appears when n dices are rolled\"\"\"\n        if cache[p] > -1:\n            return cache[p]\n\n        ret = 0\n        fp = factorials[p]\n        for q in range(1, min(p, n // 2) + 1):\n            tmp1 = (fp * invs[q] % MOD) * invs[p - q] % MOD\n            tmp2 = (factorials[k + n - 2 * q - 1] * invs[n - 2 * q] % MOD) * ik % MOD\n            if q % 2 == 1:\n                ret += tmp1 * tmp2\n            else:\n                ret -= tmp1 * tmp2\n            ret %= MOD\n\n        cache[p] = ret = (all_patterns - ret) % MOD\n        return ret\n\n    factorials, invs = get_factorials(k + n)\n    ik = invs[k - 1]\n    all_patterns = factorials[k + n - 1] * invs[n] * ik % MOD\n    cache = [-1] * (k // 2 + 2)\n\n    return solve\n\n\nMOD = 998244353\nk, n = list(map(int, input().split()))\nif k == 1:\n    print((0))\nelse:\n    solve = prepare(k, n, MOD)\n    ans = [solve(i // 2 - max(0, i - k - 1)) for i in range(2, k + 2)]\n    print(('\\n'.join(map(str, ans))))\n    print(('\\n'.join(map(str, ans[-2::-1]))))\n", "def solve():\n    MOD = 998244353\n    maxNK = 2000\n\n    K, N = list(map(int, input().split()))\n\n    def getInvs(n, MOD):\n        invs = [1] * (n+1)\n        for x in range(2, n+1):\n            invs[x] = (-(MOD//x) * invs[MOD%x]) % MOD\n        return invs\n\n    def getCombss(n, k, invs, MOD):\n        def getCombNs(n, k, invs, MOD):\n            combNs = [1] * (n//2+1)\n            for x in range(1, n//2+1):\n                combNs[x] = (combNs[x-1] * (n-x+1) * invs[x]) % MOD\n            return (combNs + combNs[:(n+1)//2][::-1])[:k+1]\n        combss = [[] for n in range(n+1)]\n        for x in range(n+1):\n            combss[x] = getCombNs(x, k, invs, MOD)\n            combss[x] += [0] * (k+1-len(combss[x]))\n        return combss\n\n    invs = getInvs(2*maxNK, MOD)\n    combss = getCombss(2*maxNK, maxNK, invs, MOD)\n\n    def getPows(base, n, MOD):\n        pows = [1] * (n+1)\n        for x in range(1, n+1):\n            pows[x] = (pows[x-1] * base) % MOD\n        return pows\n    pow2s = getPows(2, N, MOD)\n\n    anss = []\n    for i in range(2, K+2, 2):\n        ans = 0\n        numFree = abs(K+1-i)\n        numPair = (K-numFree+1)//2\n        numPair -= 1\n        for x in range(min(numPair, N)+1):\n            ans += combss[numPair][x] * pow2s[x] * combss[N+numFree-1][N-x] % MOD\n            ans %= MOD\n        for x in range(min(numPair, N)+1):\n            ans += combss[numPair][x] * pow2s[x] * combss[N+numFree-2][N-x-1] % MOD\n            ans %= MOD\n        anss.append(ans)\n        if i+1 <= K+1:\n            anss.append(ans)\n\n    anss = anss + anss[:-1][::-1]\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "K,N = list(map(int, input().split()))\nMAX = K+N+3\nmod = 998244353\n\nfac = [1]*(MAX+1)\nfor i in range(1,MAX+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\nrev_m = [1]*(MAX+1)\nrev_m[MAX] = pow(fac[MAX],mod-2,mod)\nfor i in range(MAX,0,-1):\n\trev_m[i-1] = (rev_m[i]*i)%mod\n\ndef Comb(n,k):#nCk\n\treturn (fac[n]*rev_m[k]*rev_m[n-k])%mod\n\n\ndef f(n,k,i):\n\tif i == 2:\n\t\tif n < 0 or (k==1 and n>=2): #\u4f8b\u5916\u51e6\u7406\n\t\t\treturn 0\n\n\t\tif n == 0:\n\t\t\tans = 1\n\t\telse:\n\t\t\tans = Comb(k-2+n,n) + Comb(k-2+n-1,n-1)\n\t\treturn ans % mod\n\telse: #i>2\n\t\tSp = i//2-1\n\t\tans = 0\n\t\tfor p in range(Sp+1):\n\t\t\tans += g(n,k,i,p)\n\t\treturn ans % mod\n\ndef g(n,k,i,p):\n\tSp = i//2-1\n\tif p == 0:\n\t\treturn f(n-Sp,k-Sp,2) * pow(2,Sp,mod) % mod\n\telse: #p>0\n\t\treturn g(n,k-2*p,i-2*p,0) * Comb(Sp,p)\n\nans = []\nfor i in range(2,K+2):\n\tif i%2 == 0:\n\t\ttmp = f(N,K,i)\n\tans.append(tmp)\n\tprint(tmp)\n\nans = ans[::-1]\nfor i in range(1,K):\n\tprint((ans[i]))\n", "K,N = (int(i) for i in input().split())\nmod,ans,kn = 998244353,[],K+N\nfn,fk = [1]*kn,[1]*kn\nfor i in range(kn-1): fn[i+1] = (fn[i]*(i+2))%mod\ndef power(n,k):\n\tif k==1: return n\n\telif k%2==0: return power((n**2)%mod,k//2)\n\telse: return (n*power(n,k-1))%mod\ndef comb(n,k):\n\tif n==0 or k==0 or n==k: return 1\n\telse: return (((fn[n-1]*fk[n-k-1])%mod)*fk[k-1])%mod\nfk[-1] = power(fn[-1],mod-2)\nfor i in range(2,kn+1): fk[-i] = (fk[-i+1]*(kn+2-i))%mod\nx = comb(kn-1,N)\nfor i in range(2,K+2):\n\tnum,c,y,p = N-2,1,0,i//2\n\twhile num>-1 and c<=p:\n\t\tif c%2: y = (y+comb(p,c)*comb(K+num-1,num))%mod\n\t\telse: y = (y-comb(p,c)*comb(K+num-1,num))%mod\n\t\tnum,c = num-2,c+1\n\tans.append((x-y)%mod)\nfor i in range(2,K+2): print(ans[i-2])\nfor i in range(K,1,-1): print(ans[i-2])", "mod=998244353\nk,n=map(int,input().split())\n\ndef modinv(n):\n    return pow(n,mod-2,mod)\nm=n+k\nFact=[1]\nfor i in range(1,m+1):\n    Fact.append(Fact[i-1]*i%mod)\nFinv=[0]*(m+1)\nFinv[-1]=modinv(Fact[-1])\nfor i in range(m-1,-1,-1):\n    Finv[i]=Finv[i+1]*(i+1)%mod\ndef comb(n,r):\n    if r<0 or n<r:\n        return 0\n    return Fact[n]*Finv[r]*Finv[n-r]%mod\ndef hcomb(n,r):\n    return comb(n+r-1,r)\nPow=[1]*(k+1)\nfor i in range(k):\n    Pow[i+1]=Pow[i]*2%mod\ndef solve(x):\n    ret=0\n    if x%2:\n        p=x//2\n        for q in range(p+1):\n            ret+=Pow[q]*comb(p,q)*hcomb(k-2*p+q,n-q)\n            ret%=mod\n    else:\n        p=x//2-1\n        for q in range(p+1):\n            ret+=Pow[q]*comb(p,q)*(hcomb(k-2*p+q-1,n-q)+hcomb(k-2*p+q-1,n-q-1))\n            ret%=mod\n    return ret\nAns=[]\nfor i in range(2,k+2):\n    Ans.append(solve(i))\nprint(*Ans,sep='\\n')\nprint(*reversed(Ans[:k-1]),sep='\\n')", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef solve_sub(k, n, p, factorials, invs):\n    \"\"\"Number of patterns where any pair(s) of p pairs appear when n dices are rolled\"\"\"\n    ret = 0\n    fp, ik = factorials[p], invs[k - 1]\n    for q in range(1, min(p, n // 2) + 1):\n        # tmp1 = factorials[p + q - 1] * invs[q] * invs[p - 1] % MOD\n        tmp1 = (fp * invs[q] % MOD) * invs[p - q] % MOD\n        tmp2 = (factorials[k + n - 2 * q - 1] * invs[n - 2 * q] % MOD) * ik % MOD\n        if q % 2 == 1:\n            ret += tmp1 * tmp2\n        else:\n            ret -= tmp1 * tmp2\n        ret %= MOD\n    return ret\n\n\ndef solve(k, n):\n    if k == 1:\n        return [0]\n    factorials, invs = prepare(k + n, MOD)\n    all_patterns_odd = factorials[k + n - 1] * invs[n] * invs[k - 1] % MOD\n    all_patterns_even0 = factorials[k + n - 2] * invs[n] * invs[k - 2] % MOD\n    all_patterns_even1 = factorials[k + n - 3] * invs[n - 1] * invs[k - 2] % MOD\n    buf = []\n\n    for i in range(2, k + 2):\n        pairs = i // 2 - max(0, i - k - 1)\n        if i % 2 == 0:\n            ans = all_patterns_even0 - solve_sub(k - 1, n, pairs - 1, factorials, invs)\n            ans += all_patterns_even1 - solve_sub(k - 1, n - 1, pairs - 1, factorials, invs)\n            ans %= MOD\n        else:\n            ans = (all_patterns_odd - solve_sub(k, n, pairs, factorials, invs)) % MOD\n        buf.append(ans)\n\n    return buf\n\n\nMOD = 998244353\nk, n = list(map(int, input().split()))\nans = solve(k, n)\nprint(('\\n'.join(map(str, ans))))\nprint(('\\n'.join(map(str, ans[-2::-1]))))\n", "K, N = map(int, input().split())\nMOD = 998244353\n\nP = N+K\nfact = [1]*(P+1)\nrfact = [1]*(P+1)\nfor i in range(P):\n    fact[i+1] = r = ((i+1) * fact[i]) % MOD\n    rfact[i+1] = pow(r, MOD-2, MOD)\n\ndef comb(n, k):\n    return fact[n] * rfact[k] * rfact[n-k] % MOD\n\nV = [1]*(P+1)\nr = 1\nfor i in range(P):\n    r = (r * 2) % MOD\n    V[i+1] = r * rfact[i+1] % MOD\n\nmemo = {}\ndef calc(A):\n    if A in memo:\n        return memo[A]\n    M = A//2\n    r = 0\n    if A % 2:\n        p = K - 2*M + N - 2\n        for m in range(max(0, 2*M+2-K), min(M, N-1)+1):\n            r += V[m] * rfact[M-m] * (fact[p]*rfact[N-m] + fact[p-1]*rfact[N-m-1])*rfact[p-N+m] % MOD\n\n        if 2*M+2-K <= N <= M:\n            r += V[N] * rfact[M-N] % MOD\n        r *= fact[M]\n    else:\n        p = K - 2*M + N - 1\n        for m in range(max(0, 2*M+1-K), min(N, M)+1):\n            r += V[m] * rfact[M-m] * rfact[N-m] * rfact[p-N+m] % MOD\n        r *= fact[M] * fact[p]\n    r = memo[A] = r % MOD\n    return r\nans = []\nfor i in range(2, 2*K+1):\n    if i <= K:\n        ans.append(calc(i - 1))\n    else:\n        ans.append(calc(2*K - i + 1))\nprint(*ans, sep='\\n')\n", "mod = 998244353\nrng = 4100\nfctr = [1]\nfinv = [1]\nfor i in range(1,rng):\n  fctr.append(fctr[-1]*i%mod)\nfor i in range(1,rng):\n  finv.append(pow(fctr[i],mod-2,mod))\ndef cmb(n,k):\n  if n<0 or k<0:\n    return 0\n  else:\n    return fctr[n]*finv[n-k]*finv[k]%mod\ndef homo(n,k):\n  if n<0 or k<=0:\n    return 0\n  else:\n    return cmb(n+k-1,k-1)\nk,n = map(int,input().split())\nif k%2 == 0:\n  flg = 0\nelse:\n  flg = 1\nans = []\nfor i in range(3,k+2,2):\n  ic = (i-1)//2\n  anstmp = 0\n  for j in range(ic+1):\n    t = homo(n-j,(k-ic*2+j))*cmb(ic,j)*pow(2,j,mod)\n    anstmp = (anstmp+t)%mod\n  ans.append(anstmp)\n  ans.append(anstmp)\nif flg:\n  anstmp = 0\n  for j in range(1,k//2+1):\n    t = (homo(n-j,j)+homo(n-j-1,j))*cmb(k//2,j)*pow(2,j,mod)\n    anstmp = (anstmp+t)%mod\n  ans.append(anstmp)\nans2 = ans[:-1]\nans2 = ans2[::-1]\nprint(*ans,sep=\"\\n\")\nprint(*ans2,sep=\"\\n\")", "import sys\n\nK, N = list(map(int, input().split()))\nP = 998244353\n\n\nkaizyo = [0]\nkaizyo_inv = [0]\ntmp = 1\nfor i in range(1, N+K):\n    tmp = (tmp*i) % P\n    kaizyo.append(tmp)\n    kaizyo_inv.append(pow(tmp, P - 2, P))\n\n\ndef comb(n, r):\n    if n < r or r < 0:\n        return 0\n    elif n == r or r == 0:\n        return 1\n    else:\n        return kaizyo[n] * kaizyo_inv[r] * kaizyo_inv[n - r]\n\n\ninv_2 = pow(2, P - 2, P)\nanss = ''\nfor i in range(2, 2 * K + 1):\n    ans = 0\n    n_pair = min((i - 1) // 2, (2 * K - i + 1) // 2)\n    out_pair = max(0, K - i + 1, i - K - 1)\n    which_use = pow(2, n_pair+1, P)\n    for j in range(n_pair + 1):\n        if n_pair - j > N:\n            which_use = (which_use * inv_2) % P\n            continue\n        not_use = comb(n_pair, j)\n        which_use = (which_use * inv_2) % P\n        dice_cnt = comb(N - 1 + out_pair, n_pair - j - 1 + out_pair)\n        if i % 2 == 0:\n            dice_cnt = (dice_cnt + comb(N - 2 + out_pair,\n                                        n_pair - j - 1 + out_pair)) % P\n        tmp = (not_use * which_use) % P\n        tmp = (tmp * dice_cnt) % P\n        ans = (ans + tmp) % P\n    anss += str(ans) + '\\n'\nprint((anss.rstrip()))\n", "MOD = 998244353\nk, n = list(map(int, input().split()))\n\nfacts = [1]\ninvs = [1]\npow2 = [1]\nfor i in range(1, n+k):\n    f = i*facts[i-1]%MOD\n    facts.append(f)\n    invs.append(pow(f, MOD-2, MOD))\n    pow2.append(2**i%MOD)\n\ndef nCk(n, k):\n    return (facts[n]*invs[k]*invs[n-k])%MOD\ndef nHk(n, k):\n    return nCk(n+k-1, n-1)\n\nans = []\nfor i in range(2, k+2):\n    p = i//2\n    ans_i = 0\n    for q in range(min(p+1, n+1)):\n        if k-i+q < 0:\n            continue\n        if i%2 > 0: # odd\n            ans_i = ans[-1]\n            break\n            # ans_iq = pow2[q]*nCk(p, q)*nHk(k-(i-1)+q, n-q)%MOD\n        else: # even\n            ans_iq = 0\n            if q > 0 and k-i+q > 0:\n                ans_iq = (ans_iq+pow2[q-1]*nCk(p-1, q-1)*nHk(k-(i-1)+(q-1), n-q))%MOD\n            if q < p:\n                ans_iq = (ans_iq+pow2[q]*nCk(p-1, q)*nHk(k-(i-1)+q, n-q))%MOD\n            # print(ans_iq)\n        ans_i = (ans_i + ans_iq)%MOD\n    ans.append(ans_i)\n\nfor a in ans+ans[-2::-1]:\n    print(a)\n", "K, N = map(int, input().split())\nmod = 998244353\nA = []\np = mod - 2\nwhile p != 0:\n  A = [p%2] + A[:]\n  p //= 2\ndef inved(x):\n  y = 1\n  for _ in range(len(A)):\n    if A[_] == 1:\n      y *= x\n      y %= mod\n    if _ != len(A) - 1:\n      y *= y\n      y %= mod\n  return y\n\nX = [0 for i in range(2*K-1)]\nfrac = [1]\nfor i in range(N + K):\n  frac.append(((i+1)*frac[i])%mod)\ninvf = []\nfor i in range(N + K + 1):\n  invf.append(inved(frac[i]))\nfor k in range(2, K+2):\n  S = 0\n  sign = 1\n  l = k // 2\n  for m in range(min(l+1, N//2+1)):\n    prod = (sign * (frac[l]*frac[N+K-2*m-1])) % mod\n    prod *= (invf[m]*invf[l-m]) % mod\n    prod %= mod\n    prod *= (invf[N-2*m] * invf[K-1]) % mod\n    prod %= mod\n    S += prod\n    S %= mod\n    sign *= -1\n  X[k-2], X[2*K-k] = S, S\nfor i in range(2*K-1):\n  print(X[i])", "class Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\nmod = 998244353\nK, N = map(int, input().split())\ncomb = Combination(10000, mod=mod)\ndef C(n, r):\n    if n<r or r<0:\n        return 0\n    else:\n        return comb(n, r)\ndef H(n, r):\n    return C(n+r-1, r)\nL = []\nfor i in range(2, 2*K+1, 2):\n    ans = 0\n    M = i//2\n    b = 1\n    for j, a in enumerate(range(M, K)):\n        if M-j<0:\n            break\n        ans += pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b\n        #print((j, a), C(M, j) , H(N, K-a), b, pow(2, M-j, mod) * C(M, j) * H(K-a, N) * b)\n        ans %= mod\n        b = -b\n    print(ans)\n    if i == K+1:\n        break\n    elif i == K:\n        print(ans)\n        print(ans)\n        break\n    L.append(ans)\n    print(ans)\n    L.append(ans)\n\nprint(*L[::-1], sep=\"\\n\")\n", "from collections import Counter\nK, N = map(int, input().split())\nmod = 998244353\nfrac = [1]*5010\nfor i in range(2,5010):\n    frac[i] = i * frac[i-1]%mod\nfraci = [None]*5010\nfor i in range(5010):\n    fraci[i] = pow(frac[i], mod-2, mod)\ndef comb(a, b):\n    if not a >= b >= 0:\n        return 0\n    return frac[a]*fraci[b]*fraci[a-b]%mod\nA = Counter()\ndef calc(x):\n    if A[x]:\n        return A[x]\n    res = 0\n    for i in range(N//2+1):\n        res = (res + (-1)**i*comb(x, i)*comb(N+K-1-2*i, N-2*i))%mod\n    A[x] = res\n    return res\nfor j in range(2, 2*K+1):\n    print(calc(min(j, (2*K+2-j))//2))", "k,n = map(int,input().split())\nmod = 998244353\n\nmax_n = 5000\nfac, finv, inv = [0]*max_n, [0]*max_n, [0]*max_n\n\ndef comInit(max_n):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2,max_n):\n      fac[i] = fac[i-1]* i% mod\n      inv[i] = mod - inv[mod%i] * (mod // i) % mod\n      finv[i] = finv[i-1] * inv[i] % mod\n\ncomInit(max_n)\n\n# \u4e8c\u9805\u4fc2\u6570\u306e\u8a08\u7b97\ndef com(n,k):\n    if(n < k):\n        return 0\n    if( (n<0) | (k < 0)):\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\nex2 = [1]*1010\nfor i in range(1,1010):\n    ex2[i] = (ex2[i-1]*2)%mod\n\nans = []\nfor j in range(2,k+2):\n    tmp = 0\n    x = (j-1)//2\n    for i in range(j//2 + 1):\n        comb1 = com(n+k-j,n-i)\n        comb2 = (com(x,i) * ex2[i])%mod\n        if(j%2==0):\n            comb1 += com(n+k-j-1,n-i-1)\n            comb1 %= mod\n        tmp += comb1*comb2\n        tmp %= mod\n\n    ans.append(tmp)\n\nans2 = ans[:-1]\nans += ans2[::-1]\nprint('\\n'.join(map(str,ans)))", "# Acknowledge: https://atcoder.jp/contests/arc102/submissions/3127544\nMOD = 998244353\nk, n = list(map(int, input().split()))\n\nfacts = [1]\ninvs = [1]\nfor i in range(1, n+k):\n    f = (i*facts[i-1])%MOD\n    facts.append(f)\n    invs.append(pow(f, MOD-2, MOD))\n\ndef nCk(n, k):\n    return (facts[n]*invs[k]*invs[n-k])%MOD\n\nmemo = []\nfor p in range(1, (k+3)//2):\n    i = 2*p+1\n    tmp = 0\n    for t in range(min(p+1, n+1)):\n        if k-i+t < 0:\n            continue\n        res = nCk(p, t)\n        res *= nCk(n+k-i, k-i+t)\n        res *= pow(2, t, MOD)\n        tmp = (tmp+res)%MOD\n    memo.append(tmp)\n\nans = []\nfor i in range(1, k):\n    ans.append(memo[(i-1)//2])\nfor a in ans+[memo[-1]]+ans[::-1]:\n    print(a)\n", "mod=998244353\nK,N=list(map(int,input().split()))\n\nFactorial=[1]*(N+K+1)\nfor i in range(1,N+K+1):\n  Factorial[i]=Factorial[i-1]*(i)%mod\ndef power(x,y):\n  if y==0:\n    return 1\n  elif y==1:\n    return x%mod\n  elif y%2==0:\n    return power(x,y//2)**2%mod\n  else:\n    return (power(x,y//2)**2)*x%mod\n\ninverseFactorial=[1]*(N+K+1)\ninverseFactorial[N+K]=power(Factorial[N+K],mod-2)\nfor i in range(0,N+K)[::-1]:\n  inverseFactorial[i]=(inverseFactorial[i+1]*(i+1))%mod\n  \ndef C(x,y):\n  if x<y or y<0:\n    return 0\n  else:\n    return (Factorial[x]*inverseFactorial[y]*inverseFactorial[x-y])%mod\ndef H(x,y):\n  return C(x+y-1,y)\n\ndef ans(M,N,K):\n  res=0\n  for m in range(1,M+1)[::-1]:\n    if m%2:\n      res+=C(M,m)*H(K,N-2*m)\n    else:\n      res+=(-1)*C(M,m)*H(K,N-2*m)\n  return (H(K,N)-res)%mod\n  \n\nfor i in range(2,2*K+1):\n  if i%2:\n    print((ans(min(K,i-1)-i//2,N,K)))\n  else:\n    print(((ans(min(K,i-1)-i//2,N-1,K-1)+ans(min(K,i-1)-i//2,N,K-1))%mod))\n    \n"]
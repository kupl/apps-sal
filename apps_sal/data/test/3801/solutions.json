["P = 998244353\nN, M = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nli = sum([A[i]*B[i] for i in range(N)])\ndi = sum([(A[i]^1)*B[i] for i in range(N)])\nX = [[] for _ in range(M+1)]\n\nX[0] = [1]\ndef calc(L):\n    su = sum(L)\n    pl = 0\n    pd = 0\n    RE = []\n    for i in range(len(L)):\n        a = li + i\n        b = di - (len(L) - 1 - i)\n        pd = b * L[i] * pow(su*(a+b), P-2, P)\n        RE.append((pl+pd)%P)\n        pl = a * L[i] * pow(su*(a+b), P-2, P)\n    RE.append(pl%P)\n    return RE\n\nfor i in range(M):\n    X[i+1] = calc(X[i])\nne = 0\npo = 0\nfor i in range(M+1):\n    po = (po + X[M][i] * (li + i)) % P\n    ne = (ne + X[M][i] * (di - M + i)) % P\nfor i in range(N):\n    print(po * B[i] * pow(li, P-2, P) % P if A[i] else ne * B[i] * pow(di, P-2, P) % P)\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\ndef main():\n    n,m = LI()\n    a = LI()\n    w = LI()\n\n    def plus(a,b):\n        c = a[0] * b[1] % mod\n        d = b[0] * a[1] % mod\n        e = a[1] * b[1] % mod\n        return [(c+d)%mod, e]\n\n    def sub(a,b):\n        c = a[0] * b[1] % mod\n        d = -b[0] * a[1] % mod\n        e = a[1] * b[1] % mod\n        return [(c+d)%mod, e]\n\n    def mul(a,b):\n        c = a[0] * b[0] % mod\n        d = a[1] * b[1] % mod\n        return [c,d]\n\n    fm = {}\n    def f(c,a,m,p,q):\n        if m == 0 or c == 0:\n            return [c, 1]\n\n        key = (c,a,m,p,q)\n        if key in fm:\n            return fm[key]\n\n        s = c + p + q\n        x = f(c+a,a,m-1,p,q)\n        r = mul(x, [c, s])\n        if p > 0:\n            y = f(c,a,m-1,p+1,q)\n            r = plus(r, mul(y, [p, s]))\n        if q > 0:\n            z = f(c,a,m-1,p,q-1)\n            r = plus(r, mul(z, [q, s]))\n\n        fm[key] = r\n        return r\n\n    ps = 0\n    qs = 0\n    for i in range(n):\n        if a[i] == 1:\n            ps += w[i]\n        else:\n            qs += w[i]\n\n    r = []\n    for i in range(n):\n        if a[i] == 1:\n            v = f(w[i],1,m,ps-w[i],qs)\n        else:\n            v = f(w[i],-1,m,ps,qs-w[i])\n\n        r.append(v[0]*inv(v[1]) % mod)\n\n    return JA(r,'\\n')\n\n\nprint(main())\n\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef MF(n,d): return ModFraction(n,d)\n\nclass ModFraction():\n    def __init__(self, n, d):\n        self.n = n\n        self.d = d\n\n    def __add__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = xf.n * self.d % mod\n        c = self.d * xf.d % mod\n        return ModFraction((a+b) % mod, c)\n\n    def __sub__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = -xf.n * self.d % mod\n        c = self.d * xf.d % mod\n        return ModFraction((a+b) % mod, c)\n\n    def __mul__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.n % mod\n        b = self.d * xf.d % mod\n        return ModFraction(a, b)\n\n    def __truediv__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = self.d * xf.n % mod\n        return ModFraction(a, b)\n\n    @classmethod\n    def xf(cls, x):\n        if isinstance(x, int):\n            return ModFraction(x, 1)\n        return x\n\n    @classmethod\n    def inv(cls, x):\n        return pow(x, mod - 2, mod)\n\n    def int(self):\n        return self.n * ModFraction.inv(self.d) % mod\n\n    def __str__(self):\n        return \"{} / {}\".format(self.n, self.d)\n\ndef main():\n    n,m = LI()\n    a = LI()\n    w = LI()\n\n    fm = {}\n    def f(c,a,m,p,q):\n        if m == 0 or c == 0:\n            return MF(c, 1)\n\n        key = (c,a,m,p,q)\n        if key in fm:\n            return fm[key]\n\n        s = c + p + q\n        x = f(c+a,a,m-1,p,q)\n        r = x * MF(c, s)\n        if p > 0:\n            y = f(c,a,m-1,p+1,q)\n            r = r + y * MF(p, s)\n        if q > 0:\n            z = f(c,a,m-1,p,q-1)\n            r = r + z * MF(q, s)\n\n        fm[key] = r\n        return r\n\n    ps = 0\n    qs = 0\n    for i in range(n):\n        if a[i] == 1:\n            ps += w[i]\n        else:\n            qs += w[i]\n\n    r = []\n    for i in range(n):\n        if a[i] == 1:\n            v = f(w[i],1,m,ps-w[i],qs)\n        else:\n            v = f(w[i],-1,m,ps,qs-w[i])\n\n        r.append(v.int())\n\n    return JA(r,'\\n')\n\n\nprint(main())\n\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\n\ndef MF(n,d): return ModFraction(n,d)\n\nclass ModFraction():\n    def __init__(self, n, d):\n        self.n = n\n        self.d = d\n\n    def __add__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = xf.n * self.d % mod\n        c = self.d * xf.d % mod\n        return ModFraction((a+b) % mod, c)\n\n    def __sub__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = -xf.n * self.d % mod\n        c = self.d * xf.d % mod\n        return ModFraction((a+b) % mod, c)\n\n    def __mul__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.n % mod\n        b = self.d * xf.d % mod\n        return ModFraction(a, b)\n\n    def __truediv__(self, x):\n        xf = ModFraction.xf(x)\n        a = self.n * xf.d % mod\n        b = self.d * xf.n % mod\n        return ModFraction(a, b)\n\n    @classmethod\n    def xf(cls, x):\n        if isinstance(x, int):\n            return ModFraction(x, 1)\n        return x\n\n    @classmethod\n    def inv(cls, x):\n        return pow(x, mod - 2, mod)\n\n    def int(self):\n        return self.n * ModFraction.inv(self.d) % mod\n\n    def __str__(self):\n        return \"{} / {}\".format(self.n, self.d)\n\ndef main():\n    n,m = LI()\n    a = LI()\n    w = LI()\n\n    fm = {}\n    def f(c,a,m,p,q):\n        if m == 0 or c == 0:\n            return MF(c, 1)\n\n        key = (c,a,m,p,q)\n        if key in fm:\n            return fm[key]\n\n        s = c + p + q\n        x = f(c+a,a,m-1,p,q)\n        r = x * MF(c, s)\n        if p > 0:\n            y = f(c,a,m-1,p+1,q)\n            r = r + y * MF(p, s)\n        if q > 0:\n            z = f(c,a,m-1,p,q-1)\n            r = r + z * MF(q, s)\n\n        fm[key] = r\n        return r\n\n    ps = 0\n    qs = 0\n    for i in range(n):\n        if a[i] == 1:\n            ps += w[i]\n        else:\n            qs += w[i]\n\n    r = []\n    for i in range(n):\n        if a[i] == 1:\n            v = f(w[i],1,m,ps-w[i],qs)\n        else:\n            v = f(w[i],-1,m,ps,qs-w[i])\n\n        r.append(v.int())\n\n    return JA(r,'\\n')\n\n\nprint(main())\n\n"]
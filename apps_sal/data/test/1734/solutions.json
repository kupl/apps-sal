["def rec(i):\n    nonlocal a\n    return i\nimport sys\nfrom collections import Counter\nsys.setrecursionlimit(10**6)\nn=int(input())\n#n,m=list(map(int,input().split()))\na=[input() for i in range(n)]\nb=[]\na0=set()\nc0=set()\nfor i in a:\n    c=set()\n    for i0 in range(1,10):\n        for i1 in range(0,10-i0):\n            c.add(i[i1:i1+i0])\n    b.append(c)\n    c0.update(a0&c)\n    a0.update(c)\n\nfor i in b:\n    c=i-c0\n    z='0'*10\n    for i0 in c:\n        if len(i0)<len(z):\n            z=i0\n    print(z)\n", "from collections import defaultdict\n\ndef subs(s):\n    for l in range(1, len(s) + 1):\n        for shift in range(0, len(s) - l + 1):\n            yield s[shift : shift + l]\n\nn = int(input())\nvs = [input() for _ in range(n)]\n\nentries = defaultdict(set)\nfor i, s in enumerate(vs):\n    for sub in subs(s):\n        entries[sub].add(i)\n\nfor s in vs:\n    for sub in subs(s):\n        if len(entries[sub]) == 1:\n            print(sub)\n            break\n", "indexs = []\nfor length in range(1, 10):\n    for start in range(0, 9 - length + 1):\n        indexs.append([start, start + length])\nn = int(input())\nused = {}\ns = []\nfor i in range(n):\n    s.append(input())\n    for un in set(s[-1][index[0]: index[1]] for index in indexs):\n        used[un] = used.get(un, 0) + 1\nfor num in s:\n    for index in indexs:\n        if used[num[index[0]: index[1]]] == 1:\n            print(num[index[0]: index[1]])\n            break", "n = int(input())\nnumbers = []\nfor i in range(0,n):\n    number = input()\n    numbers.append(number)\ntelep = {}\ncount = 1\nfor number in numbers:\n    for l in range(1, len(number)+1):\n        for i in range(0, len(number) - l + 1):\n            key = number[i:i + l]\n            if (key in telep) and (telep[key]!=count):\n                telep[key]=-1\n            else:\n                telep[key]=count\n    count += 1\nreverse = {}\nfor key in telep:\n    if telep[key]==-1:\n        continue\n    elif (telep[key] not in reverse):\n        reverse[telep[key]] = key\n    elif ((len(key))<len(reverse[telep[key]])):\n        reverse[telep[key]]=key\nfor i in range(1, n+1):\n    print(reverse[i])", "def podstroki(s):\n    return sorted(set(s[i: i1] for i in range(9) for i1 in range (i+1, 10)), key=len)\n\nres = {}\nspisok = [podstroki(input()) for i in range (int(input()))]\nfor s in spisok:\n    for podstr in s:\n        if podstr in res:\n            res[podstr] += 1\n        else:\n            res[podstr] = 1\n\nfor s in spisok:\n    for podstr in s:\n        if res[podstr] == 1:\n            print(podstr)\n            break\n", "n = int(input())\nnumbers = [input() for i in range(n)]\ntelep = {}\ncount = 1\nfor number in numbers:\n    for l in range(1, len(number) + 1):\n        for i in range(0, len(number) - l + 1):\n            key = number[i: i + l]\n            if key in telep and telep[key] != count:\n                telep[key] = -1\n            else:\n                telep[key] = count\n    count += 1\nreverse = {}\nfor key in telep:\n    if telep[key] == -1:\n        continue\n    elif telep[key] not in reverse:\n        reverse[telep[key]] = key\n    elif len(key) < len(reverse[telep[key]]):\n        reverse[telep[key]] = key\nfor i in range(1, n + 1):\n    print(reverse[i])\n        \n", "def nash():\n    n = int(input())\n    numbers = [input() for i in range(n)]\n    telep = {}\n    count = 1\n    for number in numbers:\n        for l in range(1, len(number) + 1):\n            for i in range(0, len(number) - l + 1):\n                key = number[i: i + l]\n                if key in telep and telep[key] != count:\n                    telep[key] = -1\n                else:\n                    telep[key] = count\n        count += 1\n    reverse = {}\n    for key in telep:\n        if telep[key] == -1:\n            continue\n        elif telep[key] not in reverse:\n            reverse[telep[key]] = key\n        elif len(key) < len(reverse[telep[key]]):\n            reverse[telep[key]] = key\n    for i in range(1, n + 1):\n        print(reverse[i])\nnash()\n        \n", "def nash():\n    n = int(input())\n    numbers = [input() for i in range(n)]\n    telep = {}\n    count = 1\n    for number in numbers:\n        for l in range(1, len(number) + 1):\n            for i in range(0, len(number) - l + 1):\n                key = number[i: i + l]\n                if key in telep and telep[key] != count:\n                    telep[key] = -1\n                else:\n                    telep[key] = count\n        count += 1\n    reverse = {}\n    for key in telep:\n        if telep[key] == -1:\n            continue\n        elif telep[key] not in reverse:\n            reverse[telep[key]] = key\n        elif len(key) < len(reverse[telep[key]]):\n            reverse[telep[key]] = key\n    for i in range(1, n + 1):\n        print(reverse[i])\nnash()\n        \n", "n = int(input())\ns, p = {}, [''] * n\nfor k in range(n):\n    p[k] =input()\n    for q in [p[k][i: j] for i in range(9) for j in range(i + 1, 10)]:\n        s[q] = -1 if q in s and s[q] != k else k\nfor q, k in list(s.items()):\n    if ~k and len(p[k]) > len(q):p[k] = q\nprint('\\n'.join(p))\n", "n = int(input())\nm = {}\na = []\nfor i in range(n):\n    s = input()\n    sub = set()\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            k =  s[i:j + 1]\n            if k in sub:\n                continue\n            else:\n                sub.add(k)\n            if k in m:\n                m[k] += 1\n            else:\n                m[k] = 1\n    a.append(s)\n\nfor s in a:\n    ans = s\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            k =  s[i:j + 1]\n            if m[k] == 1 and len(k) < len(ans):\n                ans = k\n    print(ans)\n\n", "n = int(input())\nl = []\nfor i in range(n):\n    l.append(input())\nd = {}\nfor k in l:\n    for i in range(1, 9 + 1):\n        for j in range(9 - i + 1):\n\n            a = k[j:j + i]\n            z = list(d.keys())\n            if a in z:\n                if k != d.get(a)[1]:\n                    w = d.get(a)\n                    w[0] += 1\n                    w[1] = k\n                    d.update({a: w})\n            else:\n                d.update({a: [1, k]})\nr = list(d.items())\nans = []\nfor i in r:\n    if i[1][0] == 1:\n        ans.append([i[0], i[1][1]])\nd1 = {}\nfor i in ans:\n    z = list(d1.keys())\n    if i[1] in z:\n        if len(str(i[0])) < len(str(d1.get(i[1]))):\n            d1.update({i[1]: i[0]})\n    else:\n        d1.update({i[1]: i[0]})\nfor i in l:\n    print(d1.get(i))\n", "n = int(input())\nmass = []\nfor i in range(n):\n    a = input()\n    mass.append(a)\n# for i in range(len(mass)):\n#     ans = '1' * 11\n#     for j in range(len(mass[i])):\n#         for k in range(j + 1, len(mass[i]) + 1):\n#             cnt = 0\n#             for l in range(len(mass)):\n#                 if l != i:\n#                     if mass[i][j:k] not in mass[l]:\n#                         cnt += 1\n#                     else:\n#                         break\n#             if cnt == n - 1:\n#                 if k - j < len(ans):\n#                     ans = mass[i][j:k]\n#     print(ans)\n\na = dict()\nfor i in range(len(mass)):\n    for j in range(len(mass[i])):\n        for k in range(j + 1, len(mass[i]) + 1):\n            if mass[i][j:k] in a:\n                if a[mass[i][j:k]][1] != i:\n                    a[mass[i][j:k]][0] += 1\n                    a[mass[i][j:k]][1] = i\n            else:\n                a[mass[i][j:k]] = [1, i]\n# print(a)\nfor i in range(len(mass)):\n    ans = '1' * 11\n    for j in range(len(mass[i])):\n        for k in range(j + 1, len(mass[i]) + 1):\n            if a[mass[i][j:k]][0] == 1:\n                if k - j < len(ans):\n                    ans = mass[i][j:k]\n    print(ans)", "n = int(input())\nnum = []\nfor i in range(n):\n    num.append(input())\nd = {}\nq = []\nfor i in range(n):\n    r = {}\n    g = []\n    for j in range(0, 9):\n        for l in range(j+1, 10):\n            t = num[i][j:l]\n            g.append(t)\n            if t in r:\n                continue\n            r[t] = 1\n            if t in d:\n                d[t] = d[t]+1\n            else:\n                d[t] = 1\n    g.sort(key=len)\n    q.append(g)\nif n == 1:\n    print(num[0][0])\n    return\nansw = []\nfor i in range(n):\n    for j in q[i]:\n        if d[j] == 1:\n            answ.append(j)\n            break\nfor i in answ:\n    print(i)", "\"\"\"\n-----------------------------Pseudo---------------------------------\n\"\"\"\nimport sys\nfrom collections import defaultdict\ndef input(): return sys.stdin.readline()\ndef print(arg, *argv, end=None):\n    sys.stdout.write(str(arg))\n    for i in argv: sys.stdout.write(\" \"+str(i))\n    sys.stdout.write(end) if end or end==\"\" else sys.stdout.write(\"\\n\")\n\ndef mapi(): return map(int,input().split())\ndef maps(): return map(str,input().split())\n#---------------------------------------------------------------#\ndef solve():\n    t = 1\n    #t = int(input())\n    for _ in range(t):\n        n = int(input())\n        ss = []\n        a = []\n        mem = defaultdict(int)\n        for __ in range(n):\n            x = input().strip()\n            a.append(x)\n            sett = set()\n            for i in range(9):\n                for j in range(i+1,10):\n                    sett.add(x[i:j])\n            for it in sett:\n                mem[it]+=1\n \n        for id in range(n):\n            length = 1\n            flag = True\n            while length<10 and flag:\n                i = 0\n                j = length\n                while i<9 and j<10:\n                    tmp = a[id][i:j]\n                    if mem[tmp]==1:\n                        print(tmp)\n                        flag = False\n                        break\n                    i+=1\n                    j+=1\n                length+=1\n \n#---------------------------------------------------------------#\ndef __starting_point():\n    solve()\n__starting_point()", "n=int(input())\na=[]\nd={}\n\nfor _ in range(n):\n    s=input()\n    g=set()\n    for i in range(len(s)):\n        for k in range(i,len(s)):\n            st=s[i:k+1]\n            if st in g:\n                continue\n            else:\n                g.add(st)\n            if st in d:\n                d[st]+=1\n            else:\n                d[st]=1\n    a.append(s)\n\nfor s in a:\n    ans=s\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            k=s[i:j+1]\n            if d[k]==1 and len(k) < len(ans):\n                ans=k\n    print(ans)\n", "n = int(input())\nmaps = {}\nfor i in range(n): \n    string = input()\n    for j in range(len(string)):\n        for a in range(0,j + 1):\n            substr = string[a:j+1]\n            if substr not in maps:\n                maps[substr] = {'index' : i, 'count': 1}\n            else:\n                if i != maps[substr]['index']:\n                    maps[substr]['count'] += 1\nmaps = sorted(maps.items(), key = lambda i: i[1]['index'])\ncount = 0\nmin_v = ''\nmin_count = 10\nfor k, value in maps:\n    if count < value['index']:\n        count += 1\n        print(min_v)\n        min_v = 'idk'\n        min_count = 10\n    if value['count'] == 1:\n        if len(k) < min_count:\n            min_count = len(k)\n            min_v = k\nprint(min_v)", "\nimport math\nfrom collections import *\na=int(input())\nindx=defaultdict(list)\ndone=defaultdict(list)\nfor t in range(a):\n    s=input()\n    for i in range(len(s)):\n        for j in range(i,len(s)):\n            m=s[i:j+1]\n            \n            if(len(done[m])==0):\n                done[m].append(t)\n                indx[t].append(m)\n            else:\n                if(len(done[m])==1 and  done[m][0]!=math.inf and t!=done[m][0]):\n                    indx[done[m][0]].remove(m)\n                    done[m][0]=math.inf\n            \n \nfor i in range(a):\n    af=indx[i]\n \n    mini=15\n    ss=''\n    for i in range(len(af)):\n        if(len(af[i])<mini):\n            mini=len(af[i])\n            ss=af[i]\n    print(ss)\n        \n\n\n        \n        \n", "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nn=int(input())\nl=[]\nfor i in range(n):\n    l.append(input())\nfrom collections import defaultdict\nd=defaultdict(int)\nd1=defaultdict(list)\nfor i in range(n):\n    d2=defaultdict(int)\n    for j in range(9):\n        s=l[i][j]\n        if d2[s]==0:\n            d[s]+=1\n            d2[s]+=1\n        d1[i].append(s)\n        for k in range(j+1,9):\n            s+=l[i][k]\n            if d2[s]==0:\n                d[s]+=1\n                d2[s]+=1\n            if d[s]==1:\n                d1[i].append(s)\n    d1[i].sort(key=len)\nfor i in range(n):\n    for j in d1[i]:\n        if d[j]==1:\n            print(j)\n            break\n\n            \n            \n            \n            \n            \n            \n", "import sys\nfrom collections import defaultdict\n\n\n\nN = int(input())\nS = []\nSubs = defaultdict(int)\nfor i in range(N):\n    s = input()\n    S.append(s)\n    for ff in range(1,10):\n        for ss in range(10-ff):\n            Subs[s[ss:ss+ff]] += 1\n\nfor i in range(N):\n    flag = 0\n    At = S[i]\n    for ff in range(1,10):\n        curr = defaultdict(int)\n        for ss in range(10-ff):\n            curr[At[ss:ss+ff]] += 1\n        # Here we check\n        for key in list(curr.keys()):\n            if(curr[key] == Subs[key]):\n                print(key)\n                flag = 1\n                break\n        if(flag):\n            break\n\n    \n", "n = int(input())\na = []\nd = {}\nfor b in range(n):\n    s = input()\n    g = set()\n    for i in range(len(s)):\n        for k in range(i, len(s)):\n            w = s[i:k + 1]\n            if w in g:\n                continue\n            else:\n                g.add(w)\n            if w in d:\n                d[w] += 1\n            else:\n                d[w] = 1\n    a.append(s)\n \nfor s in a:\n    ans = s\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            k = s[i:j + 1]\n            if d[k] == 1 and len(k) < len(ans):\n                ans = k\n    print(ans)"]
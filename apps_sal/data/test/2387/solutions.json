["#\u5199\u7d4c\n#https://atcoder.jp/contests/abc167/submissions/13072107\nimport sys\nreadline = sys.stdin.readline\n\ndef resolve():\n    N = int(readline())\n    S = [readline().strip() for i in range(N)]\n    L,R = [],[]\n    D = []\n    for s in S:\n        l, r = 0, 0\n        for c in s:\n            if c == ')':\n                if l > 0:\n                    l -= 1\n                else:\n                    r += 1\n            else:\n                l += 1\n        if l == 0 and r == 0:\n            pass\n        elif l == 0:\n            R.append(r)\n        elif r == 0:\n            L.append(l)\n        else:\n            D.append((l, r))\n    L = sum(L)\n    R = sum(R)\n\n    inc = []\n    dec = []\n    for l,r in D:\n        if l > r:\n            inc.append((l, r))\n        else:\n            dec.append((l, r))\n    \n    inc.sort(key=lambda x:x[1])\n    dec.sort(key=lambda x:-x[1])\n    \n    D = inc + dec\n    \n    for i, (l,r) in enumerate(D):\n        L -= r\n        if L < 0:\n            print('No')\n            return\n        L += l\n    \n    if L == R:\n        print('Yes')\n    else:\n        print('No')\nresolve()", "from itertools import *\nn,*s=open(0).read().split()\nu=[[min(accumulate(t,lambda a,b: a+(1 if b==\"(\" else -1),initial=0)),2*t.count(\"(\")-len(t)] for t in s]\nm=0\nfor c,d in chain(sorted([x for x in u if x[1]>=0])[::-1],sorted([x for x in u if x[1]<0],key=lambda z:z[0]-z[1])):\n    if m+c<0:print(\"No\");break\n    m+=d\nelse:print(\"No\" if m else \"Yes\")", "# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    SS = read().split()\n\n    for S in SS:\n        path = [0]\n        for s in S:\n            path.append(path[-1]+ dic[s])\n        ways.append((path[-1], min(path)))\n\n    ways_pos = sorted([(a,b) for a,b in ways if a >= 0], key = lambda x:(x[1], x[0]), reverse=True)\n    ways_neg = sorted([(a,b) for a,b in ways if a < 0], key = lambda x:(x[1] - x[0], -x[0]), reverse=True)[::-1]\n\n    for i in range(len(ways_pos)):\n        go, max_depth = ways_pos[i]\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    for i in range(len(ways_neg)):\n        go, max_depth = ways_neg[i]\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    run()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n# up_list = []\n# down_list = []\n\n\ndef count_scan(s):\n    max_min = 0\n    compare = 0\n    for c in s:\n        if c == '(':\n            compare += 1\n        elif c == ')':\n            compare -= 1\n            max_min = min(max_min, compare)\n    return min(max_min, compare), compare\n\n\ndef key(lst):\n    m, c = lst\n    if c > 0:\n        return 1, m\n    else:\n        return -1, c - m\n\n\ndef main():\n    n = int(input())\n    lst = [input() for _ in range(n)]\n\n    # up_list.sort(key=lambda x: x[1], reverse=True)\n    # down_list.sort(key=lambda x: x[1], reverse=False)\n    txt = 'No'\n    ans = 0\n    # print(lst)\n    # print(sorted([count_scan(lst) for i in lst],\n                #  reverse=True,\n                #  key=key))\n    for max_min, c in sorted([count_scan(s) for s in lst],\n                             reverse=True,\n                             key=key):\n        # print(f\"{max_min = }, {c = }, {ans = }\")\n        if max_min + ans < 0:\n            break\n        ans += c\n    else:\n        if ans == 0:\n            txt = 'Yes'\n\n    print(txt)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\npo,ne=[],[]\nnow=0\nfor i in range(n):\n    p=0\n    mp=0\n    for j in input():\n        p+=(1,-1)[j==\")\"]\n        mp=min(p,mp)\n    if mp:\n        if p>=0:\n            po.append((mp,p))\n        else:ne.append((mp-p,-p))\n    else:now+=p\npo.sort(reverse=1)\nne.sort(reverse=1)\nfor m,p in po:\n    if m+now<0:print(\"No\");return\n    else:now+=p\nnnow=0\nfor m,p in ne:\n    if m+nnow<0:print(\"No\");return\n    else:nnow+=p\nprint(\"Yes\" if now==nnow else \"No\") ", "\ndef f():\n    N = int(input())\n    UP = []\n    DOWN = []\n\n    for _ in range(N):\n        S = input()\n        c = 0\n        minC = 0\n\n        for s in S:\n            if s == '(':\n                c += 1\n            else:\n                c -= 1\n                minC = min(minC, c)\n\n        if c >= 0:\n            UP.append((minC, c))\n        else:\n            DOWN.append((c - minC, c))\n\n\n    c = 0\n    for up in sorted(UP, reverse=True):\n        if c + up[0] < 0:\n            return False\n\n        c += up[1]\n\n    for down in sorted(DOWN, reverse=True):\n        if c + down[1] - down[0] < 0:\n            return False\n\n        c += down[1]\n\n    if c != 0:\n        return False\n\n    return True\n\n\nif  f():\n    print('Yes')\nelse:\n    print('No')\n", "N = int(input())\nS = [input() for i in range(N)]\n\nxs1total = 0 # ((\nxs2 = [] # )((\nxs3 = [] # ))(\nxs4total = 0 # ))\n\nfor s in S:\n    n = 0\n    m = 0\n    for c in s:\n        if c == \"(\":\n            n += 1\n        elif c == \")\":\n            n -= 1\n            m = min(m, n)\n    k = n - m\n    if m == 0 and k == 0:\n        continue\n    elif m == 0:\n        xs1total += k\n    elif k == 0:\n        xs4total += -m\n    else:\n        if -m < k:\n            xs2.append((-m, k))\n        else:\n            xs3.append((-m, k))\n\nxs2.sort()\nxs3.sort(key=lambda x:-(x[1] - x[0]))\n\ndef check(xs1total, xs2, xs3, xs4total):\n    t = xs1total\n    for x in xs2:\n        if t < x[0]:\n            return False\n        t = t - x[0] + x[1]\n    for x in xs3:\n        if t < x[0]:\n            return False\n        t = t - x[0] + x[1]\n    return t == xs4total\n\n#print(xs1total, xs2, xs3, xs4total)\n\nif check(xs1total, xs2, xs3, xs4total):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "import sys\n\ninput = sys.stdin.readline\n\ndef check(s):\n    h = 0\n    for p in s:\n        b = h + p[0]\n        if b < 0: return False\n        h += p[1]\n    return True\n\nN = int(input())\nS = [input().strip() for i in range(N)]\n\ntotal = 0\nps, ms = [], []\nfor s in S:\n    h, b = 0, 0\n    for c in s:\n        if c == '(':\n            h += 1\n        else:\n            h -= 1\n        b = min(b, h)\n    if h > 0:\n        ps.append([b, h])\n    else:\n        ms.append([b-h, -h])\n    total += h\n\nps.sort(reverse=True)\nms.sort(reverse=True)\nif check(ps) and check(ms) and total == 0:\n    print('Yes')\nelse:\n    print('No')", "N = int(input())\nS = [input() for i in range(N)]\n\nxs1total = 0 # ((\nxs2 = [] # )((\nxs3 = [] # ))(\nxs4total = 0 # ))\n\nfor s in S:\n    n = 0\n    m = 0\n    for c in s:\n        if c == \"(\":\n            n += 1\n        elif c == \")\":\n            n -= 1\n            m = min(m, n)\n    k = n - m\n    if m == 0 and k == 0:\n        continue\n    elif m == 0:\n        xs1total += k\n    elif k == 0:\n        xs4total += -m\n    else:\n        if -m < k:\n            xs2.append((-m, k))\n        else:\n            xs3.append((-m, k))\n\nxs2.sort()\nxs3.sort(key=lambda x:-x[1])\n\ndef check(xs1total, xs2, xs3, xs4total):\n    t = xs1total\n    for x in xs2:\n        if t < x[0]:\n            return False\n        t = t - x[0] + x[1]\n    for x in xs3:\n        if t < x[0]:\n            return False\n        t = t - x[0] + x[1]\n    return t == xs4total\n\n#print(xs1total, xs2, xs3, xs4total)\n\nif check(xs1total, xs2, xs3, xs4total):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "#abc167_e\n\nn = int(input())\n\npos = []\nneg = []\n\nfor _ in range(n):\n    s = input()\n    low_pos = 0\n    increase= 0\n    for v in s:\n        if v==\"(\":\n            increase += 1\n        else:\n            increase -= 1\n            low_pos = min(low_pos, increase)\n    \n    if increase >= 0:\n        pos.append((low_pos, increase))\n    else:\n        #reverse left from right\n        low_pos, increase =  low_pos - increase, -increase        \n        neg.append((low_pos, increase))\n    \npos.sort()\npos.reverse() #low\u304c\u9ad8\u3044\u9806\u306b\u3059\u308b.\nneg.sort()\nneg.reverse() #low\u304c\u9ad8\u3044\u9806\u306b\u3059\u308b.\n\nnow_pos = 0\nfor low_pos, increase in pos:\n    if now_pos + low_pos < 0:\n        print(\"No\")  #impossible\n        return\n    else:\n        now_pos += increase\n\nright_pos = 0       \nfor low_pos, increase in neg:\n    if right_pos + low_pos < 0:\n        print(\"No\")  #impossible\n        return\n    else:\n        right_pos += increase\n\nif right_pos != now_pos:\n    print(\"No\")\n    return\nelse:\n    print(\"Yes\")", "import cython\n \ndef main():\n    import sys\n    readline = sys.stdin.readline\n    \n    N: cython.longlong\n    N = int(readline())\n    S = [readline().strip() for i in range(N)]\n    \n    D = []\n    L, R = [], []\n    for s in S:\n        l: cython.longlong = 0\n        r: cython.longlong = 0\n        for c in s:\n            if c == ')':\n                if l > 0: l -= 1\n                else: r += 1\n            else: l += 1\n        if l == 0 and r == 0:pass\n        elif l == 0: R.append(r)\n        elif r == 0: L.append(l)\n        else: D.append((l, r))\n    \n    L: cython.longlong\n    R: cython.longlong\n    L = sum(L)\n    R = sum(R)\n    \n    inc = []\n    dec = []\n    for l, r in D:\n        if l > r:\n            inc.append((l, r))\n        else:\n            dec.append((l, r))\n    \n    inc.sort(key=lambda x:x[1])\n    dec.sort(key=lambda x:-x[1])\n    \n    D = inc + dec\n    \n    l: cython.longlong\n    r: cython.longlong\n    for _, (l,r) in enumerate(D):\n        L -= r\n        if L < 0:\n            print('No')\n            return\n        L += l\n    \n    if L == R:\n        print('Yes')\n    else:\n        print('No')\n \ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nscop = [] #\u9ad8\u4f4e\u5dee,min\u5024\nscom = []\nssum = 0\n\nfor i in range(n):\n    s = input()\n    sa = 0\n    ms = 0\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            sa += 1\n        else:\n            sa -= 1\n        if ms > sa:\n            ms = sa\n    if sa > 0:\n        scop.append([ms,sa])\n    elif not sa == ms:\n        scom.append([ms,sa])\n    ssum += sa\n\nif not ssum == 0:\n    print(\"No\")\n    return\n\nscop.sort(reverse = True)\nscom.sort()\n\nnow = 0\nfor i in scop:\n    if now + i[0] < 0:\n        print(\"No\")\n        return\n    now += i[1]\nfor i in scom:\n    if now + i[0] < 0:\n        print(\"No\")\n        return\n    now += i[1]\n\nprint(\"Yes\")\n", "n = int(input())\nslist = []\nfor i in range(n):\n    slist.append(input())\n\nfirst_list = []\nlast_list = []\nfirst = \"\"\nlast = \"\"\nfor i in range(n):\n    s = slist[i]\n\n    a_count = 0\n    b_count = 0\n    min_s = \"\"\n    for c in s:\n        if c == \")\":\n            b_count-=1\n        else:\n            b_count+=1\n        if b_count < 0:\n            b_count = 0\n            a_count+= 1\n    min_s = \")\"* a_count + \"(\"*b_count\n\n    ai = a_count\n    bi = b_count\n\n    if ai == 0:\n        first += min_s\n    elif bi == 0:\n        last += min_s\n    elif bi-ai >= 0:\n        first_list.append([min_s,ai])\n    else:\n        last_list.append([min_s,bi])\n\nfirst_list= sorted(first_list, key=lambda s: s[1])\nlast_list= sorted(last_list, key=lambda s: s[1], reverse=True)\n\nans = first\nfor i in range(len(first_list)):\n    ans += first_list[i][0]\nfor i in range(len(last_list)):\n    ans += last_list[i][0]\nans += last\n\na_count = 0\nb_count = 0\nmin_s = \"\"\nfor c in ans:\n    if c == \")\":\n        b_count-=1\n    else:\n        b_count+=1\n    if b_count < 0:\n        b_count = 0\n        a_count+= 1\n\nif a_count == 0 and b_count == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\nn = int(input())\nls, rs = [], []\ntotal = 0\nfor i in range(n):\n    s = input()\n    h, b = 0, 0\n    for c in s:\n        if c=='(':  h += 1\n        else:       h -= 1\n        b = min(b, h)\n    if h > 0:   ls.append((b, h))       # \u5897\u6e1b+ \u306fb:\u6700\u4e0b\u70b9, h:\u5897\u6e1b\u3092\u53d6\u308b\n    else:       rs.append((b-h, -h))    # \u5897\u6e1b- \u306f\u3001\u4e0a\u4e0b\u5de6\u53f3\u9006\u3055\u306b\u8003\u3048\u3001b:\u53f3\u304b\u3089\u898b\u305f\u6700\u4e0b\u70b9\u3001h:\u5897\u6e1b\u306e\u30de\u30a4\u30ca\u30b9\u3092\u53d6\u308b\n    total += h\nls.sort(reverse=True)\nrs.sort(reverse=True)   # \u5897\u6e1b-\u306f\u53f3\u304b\u3089\u898b\u308b\u306e\u3067\u3001\u5927\u304d\u3044\u9806\u306bsort\n\ndef chk(s):\n    h = 0\n    for sb, sh in s:\n        b = h + sb\n        if b < 0: return False\n        h += sh\n    return True\n\nif (chk(ls) and chk(rs) and total==0):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "N, *S = open(0)\n\nL = [s.count(\"(\") for s in S]\nR = [s.count(\")\") for s in S]\n\nX = sorted(((s[:-1], r) for s, l, r in zip(S, L, R) if l - r >= 0), key=lambda x: x[1])\nY = sorted(((s[:-1], l) for s, l, r in zip(S, L, R) if l - r < 0), key=lambda x: -x[1])\n\ncnt = 0\nfor s, _ in X + Y:\n    for si in s:\n        cnt += 1 if si == \"(\" else -1\n        if cnt < 0:\n            print(\"No\")\n            return\n\nif cnt == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import sys\ninput=lambda: sys.stdin.readline().rstrip()\n\nN = int(input())\n\nS_p = []\nS_n = []\n\nfor i in range(N):\n  end = 0\n  mim = 0\n  for c in input():\n    if c == \"(\":\n      end += 1\n    else :\n      end -= 1\n    mim = min(mim,end)\n  \n  if end >= 0:\n    S_p.append([mim, end])\n  else:\n    S_n.append([end-mim, end])\n  \nS_p.sort(reverse=True)\nS_n.sort(reverse=True)\n#print(S_p)\n#print(S_n)\n\ncheck = 0\nflag = True\nfor i in range(len(S_p)):\n  if check + S_p[i][0] >= 0:\n    check += S_p[i][1]\n  else:\n    flag = False\n    break\n  #print(check)\n  \nfor i in range(len(S_n)):\n  if check + S_n[i][1] - S_n[i][0] >= 0:\n    check += S_n[i][1]\n  else:\n    flag = False\n    break\n  #print(check)\n  \nif check == 0 and flag:\n  flag = True\nelse:\n  flag = False\n\nprint(\"Yes\" if flag else \"No\")", "def main():\n    from sys import stdin\n    input = stdin.readline\n    n = int(input())\n    S = [input() for _ in [0]*n]\n    s2 = []\n    s3 = []\n    for s in S:\n        temp = [0, 0]\n        m = 0\n        now = 0\n        for i in s.strip('\\n'):\n            if i == \"(\":\n                now += 1\n            else:\n                now -= 1\n            m = min(m, now)\n        temp = [-m, (s.count(\"(\")-s.count(\")\"))-m]\n        if temp[0] < temp[1]:\n            s2.append(temp)\n        else:\n            s3.append(temp)\n    s2.sort(key=lambda x: (x[0]))\n    s3.sort(key=lambda x: (-x[1]))\n    cnt = 0\n    for i, j in s2:\n        cnt -= i\n        if cnt < 0:\n            print(\"No\")\n            return\n        cnt += j\n    for i, j in s3:\n        cnt -= i\n        if cnt < 0:\n            print(\"No\")\n            return\n        cnt += j\n    if cnt != 0:\n        print(\"No\")\n        return\n    print(\"Yes\")\n\n\nmain()\n", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef solve():\n    N = int(input())\n    inc_chunks = []\n    dec_chunks = []\n    for _ in range(N):\n        depth = 0\n        level = 0\n        for c in input():\n            if c == '(':\n                level += 1\n            else:\n                level -= 1\n                depth = min(depth, level)\n        if depth >= 0 and level == 0:\n            continue\n        elif level > 0:\n            inc_chunks.append((depth, level))\n        else:\n            dec_chunks.append((depth - level, -level))\n\n    inc_chunks.sort(reverse=True)\n    dec_chunks.sort(reverse=True)\n    inc_level = 0\n    for depth, level in inc_chunks:\n        if inc_level + depth < 0:\n            return 'No'\n        inc_level += level\n    dec_level = 0\n    for depth, level in dec_chunks:\n        if dec_level + depth < 0:\n            return 'No' \n        dec_level += level\n    if inc_level != dec_level:\n        return 'No'\n    return 'Yes'\n\n\nprint((solve()))\n", "import sys\ninput = sys.stdin.readline\nn = int(input())\nchk = []\nres = []\nfor i in range(n):\n  s = input().strip()\n  m = 0\n  e = 0\n  for i in s:\n    if i == ')':\n      e -= 1\n      m = min(m,e)\n    else:\n      e += 1\n  if e >= 0:\n    chk.append((m,e))\n  else:\n    res.append((-1*e+m,-1*e))\n  \nfrom operator import itemgetter\nres.sort(key=itemgetter(0),reverse=True)\nchk.sort(key=itemgetter(0),reverse=True)\nans = 'Yes'\nst = 0\nfor i,j in chk:\n  if i+st < 0:\n    ans = 'No'\n    break\n  st += j\n  \nsr = 0\nfor i,j in res:\n  if i+sr < 0:\n    ans = 'No'\n    break\n  sr += j\n  \nif st != sr:\n  ans = 'No'\n\nprint(ans)", "N = int(input())\nG2,G4 = [],[]\ncnt2 = 0\ncnt3 = 0\nfor _ in range(N):\n    S = input()\n    MIN = 0\n    cnt = 0\n    for s in list(S):\n        if s == '(':\n            cnt += 1\n        else:\n            cnt -= 1\n        MIN = min(MIN,cnt)\n    if MIN == 0 and cnt >= 0:\n        cnt2 += cnt\n    if MIN < 0 and cnt >= 0:\n        G2.append([MIN,cnt])\n    if MIN == cnt and cnt < 0:\n        cnt3 += cnt\n    if MIN < cnt and cnt < 0:\n        G4.append([MIN,cnt])\n\n\nG2.sort(reverse=True)\nfor L in G2:\n    if cnt2 + L[0] < 0:\n        print('No')\n        return\n    else:\n        cnt2 += L[1]\nfor L in G4:\n    if cnt2 + L[0] < 0:\n        print('No')\n        return\n    else:\n        cnt2 += L[1]\n\ncnt2 += cnt3\n\nif cnt2 == 0:\n    print('Yes')\nelse:\n    print('No')\n", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n = int(input())\n    lx = []\n    rx = []\n    for i in range(n):\n        a = 0\n        cnt = 0\n        for j in input():\n            if j == '(':\n                cnt += 1\n            else:\n                cnt -= 1\n            a = min(a, cnt)\n        \n        if cnt >= 0:\n            lx.append((a, cnt))\n        else:\n            rx.append((a, cnt))\n    lx.sort(key= lambda x: -x[0]) # -a\u306e\u6607\u9806\n    rx.sort(key= lambda x: x[0]-x[1]) # -b\u306e\u6607\u9806(b\u306e\u964d\u9806)\n    total = 0\n    check = True\n    for x,cnt in (lx+rx):\n        if total + x < 0:\n            check = False\n            break\n        total += cnt\n    if total == 0 and check:\n        print('Yes')\n    else:\n        print(\"No\")\n    \n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n# input = sys.stdin.readline\n\n\ndef parse(s):\n    bottom = 0\n    delta = 0\n    for c in s:\n        delta += (1 if c == \"(\" else -1)\n        bottom = min(bottom, delta)\n    return bottom, delta\n\n\ndef compute(pars):\n    pars.sort(reverse=True)\n    h = 0\n    for bottom, delta in pars:\n        if h + bottom < 0:\n            print(\"No\")\n            return\n        h += delta\n    return h\n\n\ndef main():\n    N = int(input())\n\n    incs = []\n    decs = []\n    for _ in range(N):\n        bottom, delta = parse(input())\n        if delta > 0:\n            incs.append((bottom, delta))\n        else:\n            decs.append((bottom-delta, -delta))\n\n    inc_tot = compute(incs)\n    dec_tot = compute(decs)\n    if inc_tot == dec_tot:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import *\nn,*s=open(0).read().split()\nu=[[min(accumulate(chain([0],t),lambda a,b: a+(1 if b==\"(\" else -1))),2*t.count(\"(\")-len(t)] for t in s]\nm=0\nfor c,d in chain(sorted([x for x in u if x[1]>=0])[::-1],sorted([x for x in u if x[1]<0],key=lambda z:z[0]-z[1])):\n    if m+c<0:print(\"No\");break\n    m+=d\nelse:print(\"No\" if m else \"Yes\")", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\ncnt = 0\ndecrement = 0\nprofit = []\nloss = []\n\nfor _ in range(n):\n    s = input().rstrip()\n    min_p = 0\n    end_p = 0\n    point = 0\n    for c in s:\n        if c == '(':\n            point += 1\n        elif c == ')':\n            point -= 1\n            if point < min_p:\n                min_p = point\n    else:\n        end_p = point\n    if 0 <= min_p:\n        cnt += end_p\n    else:\n        if min_p == end_p:\n            decrement += end_p\n        else:\n            if 0 <= end_p:\n                profit.append((min_p, end_p))\n            else:\n                loss.append((min_p, end_p))\n\n\n\nprofit.sort()\nwhile profit:\n    min_p, end_p = profit.pop()\n    if cnt+min_p < 0:\n        print('No')\n        return\n    cnt += end_p\n\n\nloss.sort(reverse=True)\nwhile loss:\n    min_p, end_p = loss.pop()\n    if cnt+min_p < 0:\n        print('No')\n        return\n    cnt += end_p\n\nprint(('Yes' if cnt+decrement == 0 else 'No'))\n", "def check(vec):\n    if len(vec) == 0:\n        return True\n    h = 0\n    for v in sorted(vec, reverse=True):\n        if h + v[0] < 0:\n            return False\n        h += v[1]\n    return True\n\n\ndef parse(brackets):\n    m = 0\n    f = 0\n    for c in brackets:\n        if c == \"(\":\n            f += 1\n        else:\n            f -= 1\n        if m > f:\n            m = f\n    return m, f\n\n\ndef main():\n    N = int(input())\n    ls = []\n    rs = []\n    tot = 0\n    for _ in range(N):\n        m, f = parse(input().strip())\n        tot += f\n        if f >= 0:\n            ls.append([m, f])\n        else:\n            rs.append([m-f, -f])\n    return tot == 0 and check(ls) and check(rs)\n\n\ndef __starting_point():\n    print((\"Yes\" if main() else \"No\"))\n\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000000)\nimport math\nfrom math import gcd\ndef lcm(a, b): return a * b // gcd(a, b)\nfrom itertools import count, permutations, chain\nfrom functools import lru_cache\nfrom collections import deque, defaultdict\nfrom pprint import pprint\nii = lambda: int(input())\nmis = lambda: list(map(int, input().split()))\nlmis = lambda: list(mis())\nINF = float('inf')\nN1097 = 10**9 + 7\n\ndef meg(f, ok, ng):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)//2\n        if f(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n\ndef get_inv(n, modp):\n    return pow(n, modp-2, modp)\n\ndef factorials_list(n, modp):    # 10**6\n    fs = [1]\n    for i in range(1, n+1):\n        fs.append(fs[-1] * i % modp)\n    return fs\n\ndef invs_list(n, fs, modp):     # 10**6\n    invs = [get_inv(fs[-1], modp)]\n    for i in range(n, 1-1, -1):\n        invs.append(invs[-1] * i % modp)\n    invs.reverse()\n    return invs\n\ndef comb(n, k, modp):\n    num = 1\n    for i in range(n, n-k, -1):\n        num = num * i % modp\n    den = 1\n    for i in range(2, k+1):\n        den = den * i % modp\n    return num * get_inv(den, modp) % modp\n\ndef comb_from_list(n, k, modp, fs, invs):   \n    return fs[n] * invs[n-k] * invs[k] % modp\n\n#\n\nclass UnionFindEx:\n    def __init__(self, size):\n        #\u6b63\u306a\u3089\u6839\u306e\u756a\u53f7\u3001\u8ca0\u306a\u3089\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba\n        self.roots = [-1] * size\n    def getRootID(self, i):\n        r = self.roots[i]\n        if r < 0:   #\u8ca0\u306a\u3089\u6839\n            return i\n        else:\n            r = self.getRootID(r)\n            self.roots[i] = r\n            return r\n    def getGroupSize(self, i):\n        return -self.roots[self.getRootID(i)]\n    def connect(self, i, j):\n        r1, r2 = self.getRootID(i), self.getRootID(j)\n        if r1 == r2:\n            return False\n        if self.getGroupSize(r1) < self.getGroupSize(r2):\n            r1, r2 = r2, r1\n        self.roots[r1] += self.roots[r2]    #\u30b5\u30a4\u30ba\u66f4\u65b0\n        self.roots[r2] = r1\n        return True\n\nYes = 'Yes'\nNo = 'No'\n\n\ndef main():\n    N=ii()\n    up = []\n    down = []\n    for _ in range(N):\n        S = input()\n        h = 0\n        b = 0\n        for s in S:\n            if s=='(':\n                h += 1\n            else:\n                h -= 1\n                b = min(b, h)\n        #\n        if h>=0:\n            up.append((h, b))\n        else:\n            down.append((h, b))\n    #\n    up.sort(key=lambda t: t[1], reverse=True)\n    down.sort(key=lambda t: t[0]-t[1], reverse=True)\n    H = 0\n    for h, b in up:\n        if H+b>=0:\n            H += h\n        else:\n            print(No)\n            return\n    for h, b in down:\n        if H+b>=0:\n            H += h\n        else:\n            print(No)\n            return\n    #\n    if H == 0:\n        print(Yes)\n    else:\n        print(No)\n\n\n\n\n\nmain()\n\n", "\nfrom functools import reduce\nn, *s = open(0).read().split()\nu = []\nfor t in s:\n    close_cnt = 0\n    tmp = 0\n    for c in t:\n        tmp += (1 if c == '(' else -1)\n        close_cnt = min(close_cnt, tmp)\n    u.append((close_cnt, tmp - close_cnt))\nM = 10**6 + 1\nacc = 0\nfor a, b in sorted([x for x in u if sum(x) >= 0], key=lambda z: -z[0]):\n    if acc + a < 0:\n        print(\"No\")\n        return\n    else:\n        acc += a + b\nfor a, b in sorted([x for x in u if sum(x) < 0], key=lambda z: -z[1]):\n    if acc + a < 0:\n        print(\"No\")\n        return\n    else:\n        acc += a + b\nprint((\"No\" if acc else \"Yes\"))", "N = int(input())\nS = [input() for i in range(N)]\n\npos = []\nneg = []\nfor s in S:\n    sm = 0\n    mn = 0\n    for c in s:\n        if c=='(':\n            sm += 1\n        else:\n            sm -= 1\n            mn = min(mn, sm)\n    if sm >= 0:\n        pos.append((mn,sm))\n    else:\n        neg.append((mn-sm, -sm))\n\npos.sort(key=lambda x:-x[0])\nneg.sort(key=lambda x:-x[0])\n\nhp = 0\nfor m,s in pos:\n    if hp + m < 0:\n        print('No')\n        return\n    hp += s\n\nhn = 0\nfor m,s in neg:\n    if hn + m < 0:\n        print('No')\n        return\n    hn += s\n\nprint('Yes' if hp==hn else 'No')", "# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    SS = read().split()\n\n    for S in SS:\n        path = [0]\n        for s in S:\n            path.append(path[-1]+ dic[s])\n        ways.append((path[-1], min(path)))\n\n    ways_pos = sorted([(a,b) for a,b in ways if a >= 0], key = lambda x:x[1], reverse=True)\n    ways_neg = sorted([(a,b) for a,b in ways if a < 0], key = lambda x:(x[0] - x[1]), reverse=True)\n\n    idx = list(range(len(ways_pos)))\n\n\n\n    for go, max_depth in ways_pos:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n\n    tmp =[]\n    for go, max_depth in ways_neg:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            tmp.append((go, max_depth))\n\n    for go, max_depth in tmp:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print('No')\n            return None\n\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    run()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\ns=[input().strip(\"\\n\") for _ in range(n)]\np=[];m=[]\nfor si in s:\n    cnt=0;a=0;b=0\n    for i in range(len(si)):\n        if si[i]==\")\":\n            cnt+=1\n        else:\n            cnt-=1\n        a=max(a,cnt)\n    cnt=0\n    for i in range(len(si)-1,-1,-1):\n        if si[i]==\"(\":\n            cnt+=1\n        else:\n            cnt-=1\n        b=max(b,cnt)\n    if b-a>=0:\n        p.append((a,si))\n    else:\n        m.append((-b,si))\np.sort();m.sort()\nss=\"\"\n\nfor _,si in p:\n    ss+=si\nfor _,si in m:\n    ss+=si\ncnt=0\nfor i in range(len(ss)):\n    if ss[i]==\"(\":\n        cnt+=1\n    else:\n        cnt-=1\n    if cnt<0:\n        print(\"No\")\n        return\nif cnt:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\n", "# F\n\nN = int(input())\n\nlist_plus = []\nlist_minus = []\nfor i in range(N):\n    S = input()\n    state = 0\n    min_state = 0\n    for s in S:\n        if s == '(':\n            state += 1\n        else:\n            state -= 1\n        min_state = min(min_state, state)\n    \n    if state > 0:\n        list_plus.append((min_state, state))\n    else:\n        list_minus.append((min_state - state, -state))\n\ndef compute(arr):\n    total_state = 0\n    for min_state, state in arr[::-1]:\n        if total_state + min_state < 0:\n            print('No')\n            return\n        total_state += state\n    return total_state\n\nlist_plus.sort()\ntotal_state_plus = compute(list_plus)\nlist_minus.sort()\ntotal_state_minus = compute(list_minus)\n\nprint('Yes' if total_state_plus == total_state_minus else 'No')", "# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    SS = read().split()\n\n    for S in SS:\n        path = [0]\n        for s in S:\n            path.append(path[-1]+ dic[s])\n        ways.append((path[-1], min(path)))\n\n    ways_pos = sorted([(a,b) for a,b in ways if a >= 0], key = lambda x:(x[1], x[0]), reverse=True)\n    ways_neg = sorted([(a,b) for a,b in ways if a < 0], key = lambda x:(x[1] - x[0], -x[0]), reverse=True)[::-1]\n\n    for go, max_depth in ways_pos:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    for go, max_depth in ways_neg:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    run()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n = int(input())\n  \n  a = []\n  b = []\n  for i in range(n):\n    s = input()\n    c1, c2 = 0, 0\n    for i in range(len(s)):\n      if s[i] == \"(\":\n        c2 += 1\n      if s[i] == \")\":\n        if c2:\n          c2 -= 1\n        else:\n          c1 += 1\n    if c1 >= c2:\n      b.append((c2, c1))\n    else:\n      a.append((c1, c2))\n  a.sort()\n  b.sort(reverse=True)\n  ans = False\n  sub = 0\n  for value in a:\n    k1, k2 = value[0], value[1]\n    if sub < k1:\n      ans = True\n      break\n    sub += k2-k1\n  for value in b:\n    k2, k1 = value[0], value[1]\n    if ans or sub < k1:\n      ans = True\n      break\n    sub += k2-k1\n  print(\"No\" if ans or sub else \"Yes\")\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nn=int(input())\njsum=0\ngjlist=[]\nejlist=[]\nesum=0\n\ndef jouka(t):\n\tnonlocal jsum\n\tnonlocal gjlist\n\tnonlocal ejlist\n\tnonlocal esum\n\t\n\ttmpj=0\n\ttmpe=0\n\t\n\tfor i in range(len(t)):\n\t\tif t[i] == \"(\":\n\t\t\ttmpj += 1\n\t\telse:\n\t\t\tif tmpj == 0:\n\t\t\t\ttmpe +=1\n\t\t\telse:\n\t\t\t\ttmpj -=1\n\t\t\n\tif tmpe == 0:\n\t\tjsum += tmpj\n\telif tmpj == 0:\n\t\tesum += tmpe\n\telif tmpj > tmpe:\n\t\tgjlist.append([tmpe,tmpj])\n\telse:\n\t\tejlist.append([tmpe,tmpj])\n\nfor j in range(n):\n\tjouka(input())\n\ngjlist.sort(key=lambda x:x[0])\nejlist.sort(reverse = True,key=lambda x:x[0])\n\nstreak=jsum\nfor gj in gjlist:\n\tif gj[0] > streak:\n\t\tprint(\"No\")\n\t\treturn\n\telse:\n\t\tstreak += gj[1]-gj[0]\n\nfor ej in ejlist:\n\tif ej[0] > streak:\n\t\tprint(\"No\")\n\t\treturn\n\telse:\n\t\tstreak += ej[1]-ej[0]\n\nif streak == esum:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")\n\n\n\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nS = [readline().rstrip() for _ in range(N)]\n\ndef count_cb_ob(s):\n    st = []\n    for i, si in enumerate(s):\n        if si == '(' or len(st) == 0 or st[-1] != '(':\n            st.append(si)\n        else:\n            st.pop()\n    return st.count(')'), st.count('(')\n\ncb_obs = map(count_cb_ob, S)\nf, b, s = [], [], []\nfor down, up in cb_obs:\n    (f if down < up else (s if down == up else b)).append((down, up))\n\nf = sorted(f)\nb = sorted(b, key=lambda x:x[1], reverse=True)\n\ncount = 0\nans = 'Yes'\nfor down, up in (*f, *s, *b):\n    count -= down\n    if count < 0:\n        ans = 'No'\n    count += up\n\nif count != 0:\n    ans = 'No'\n\nprint(ans)", "from operator import itemgetter\nN = int(input())\n\ndef checkNonnegative(brankets):\n    curup = 0\n    for (minup , up) in sorted(brankets , key= itemgetter(0) , reverse = True):\n        if curup + minup < 0:\n            return False\n        curup += up\n    return True\n\ndef canArrangeBranket(brankets):\n    totup = 0\n    left_brankets = []\n    right_brankets = []\n    for branket in brankets:\n        up = 0\n        minup = 0\n        for c in list(branket):\n            if c == '(':\n                up += 1\n            else:\n                up -= 1\n                minup = min(minup , up)\n        totup += up\n        if up >= 0:\n            left_brankets.append((minup , up))\n        else:\n            right_brankets.append((minup - up , - up))\n    if totup != 0:\n        return False\n    return checkNonnegative(left_brankets) and checkNonnegative(right_brankets)\n\nbranketList = []\nfor i in range(N):\n    l = input()\n    branketList.append(l)\n\nif canArrangeBranket(branketList):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "def check(ar):\n    h = 0\n    for bottom, up in ar:\n        if h + bottom < 0:\n            return False\n        h += up\n    return True\n\n\ndef __starting_point():\n    N = int(input())\n    pos = []\n    neg = []\n    equal = 0\n    for _ in range(N):\n        cnt = 0\n        bottom = 0\n        for s in input():\n            if s == \"(\":\n                cnt += 1\n            else:\n                cnt -= 1\n            bottom = min(bottom, cnt)\n        equal += cnt\n        if cnt >= 0:\n            pos.append((bottom, cnt))\n        else:\n            cnt = -cnt\n            bottom += cnt\n            neg.append((bottom, cnt))\n\n    pos.sort(reverse=True)\n    neg.sort(reverse=True)\n    if check(pos) and check(neg) and equal == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n__starting_point()", "def count_scan(s):\n    max_min = 0\n    compare = 0\n    for c in s:\n        if c == '(':\n            compare += 1\n        elif c == ')':\n            compare -= 1\n            max_min = min(max_min, compare)\n    return min(max_min, compare), compare\n \n \ndef key(lst):\n    m, c = lst\n    if c > 0:\n        return 1, m\n    else:\n        return -1, c - m\n \n \ndef main():\n    n = int(input())\n    lst = [input() for _ in range(n)]\n \n    txt = 'No'\n    ans = 0\n    for max_min, c in sorted([count_scan(s) for s in lst],\n                             reverse=True,\n                             key=key):\n        if max_min + ans < 0:\n            break\n        ans += c\n    else:\n        if ans == 0:\n            txt = 'Yes'\n \n    print(txt)\n  \ndef __starting_point():\n    main()\n\n\n__starting_point()", "n = int(input())\nls, rs = [], []\n\ndef check(sl):\n    h = 0\n    for t in sl:\n        b = h + t[0]\n        if b < 0:\n            return False\n        h += t[1]\n    return True\n\ntotal = 0\nfor i in range(n):\n    b, h = 0, 0\n    S = input()\n    for s in S:\n        if s == '(':\n            h += 1\n        else:\n            h -= 1\n        b = min(b, h)\n    if h > 0:\n        ls.append((b, h))\n    else:\n        rs.append((b - h, -h))\n    total += h\nls.sort(key=lambda x: x[0], reverse=True)\nrs.sort(key=lambda x: x[0], reverse=True)\nprint('Yes' if check(ls) and check(rs) and total == 0 else 'No')", "import sys\n# input = sys.stdin.readline\ninput = lambda: sys.stdin.readline().rstrip()\n\nn = int(input())\ns = [input() for _ in range(n)]\n\n\ndef bracket(x):\n    # f: final sum of brackets '(':+1, ')': -1\n    # m: min value of f\n    f = m = 0\n    for i in range(len(x)):\n        if x[i] == '(':\n            f += 1\n        else:\n            f -= 1\n        m = min(m, f)\n    # m <= 0\n    return f, m\n\n\nl1 = []\nl2 = []\nfor i in range(n):\n    fi, mi = bracket(s[i])\n    if fi >= 0:\n        l1.append((fi, mi))\n    else:\n        l2.append((fi, mi))\n\nl1.sort(key=lambda x: -x[1])\nl2.sort(key=lambda x: -(x[0] - x[1]))\nl = l1 + l2\nv = 0\nfor fi, mi in l:\n    if v + mi >= 0:\n        v += fi\n    else:\n        v = -1\n        break\n\nans = 'Yes' if v == 0 else 'No'\nprint(ans)\n", "import sys\n# input = sys.stdin.readline\ninput = lambda: sys.stdin.readline().rstrip()\n\nn = int(input())\ns = [input() for _ in range(n)]\n\n\ndef bracket(x):\n    # f: final sum of brackets '(':+1, ')': -1\n    # m: min value of f\n    f = m = 0\n    for i in range(len(x)):\n        if x[i] == '(':\n            f += 1\n        else:\n            f -= 1\n        m = min(m, f)\n    # m <= 0\n    return f, m\n\n\ndef func(l):\n    # l = [(f, m)]\n    l.sort(key=lambda x: -x[1])\n    v = 0\n    for fi, mi in l:\n        if v + mi >= 0:\n            v += fi\n        else:\n            return -1\n    return v\n\n\nl1 = []\nl2 = []\nfor i in range(n):\n    fi, mi = bracket(s[i])\n    if fi >= 0:\n        l1.append((fi, mi))\n    else:\n        l2.append((-fi, mi - fi))\n\nv1 = func(l1)\nv2 = func(l2)\nif v1 == -1 or v2 == -1:\n    ans = 'No'\nelse:\n    ans = 'Yes' if v1 == v2 else 'No'\n\nprint(ans)\n", "def main():\n    N = int(input())\n    up_lines = []\n    down_lines = []\n    for i in range(N):\n        s = input()\n        height = 0\n        bottom = 0\n        for c in s:\n            if c == \"(\":\n                height += 1\n            else:\n                height -= 1\n                bottom = min(bottom, height)\n        if height > 0:\n            up_lines.append((bottom, height))\n        else:\n            down_lines.append((bottom-height, -height))\n    up_lines.sort(reverse=True, key=lambda line: line[0])\n    down_lines.sort(reverse=True, key=lambda line: line[0])\n    left = 0\n    for bottom, height in up_lines:\n        if left + bottom < 0:\n            print(\"No\")\n            return\n        left += height\n    right = 0\n    for bottom, height in down_lines:\n        if right + bottom < 0:\n            print(\"No\")\n            return\n        right += height\n    if left == right:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\n\nn=int(input())\nopens=0\ncloses=0\nls=[]\nrs=[]\nfor _ in range(n):\n  s=input()\n  cnt1=0\n  cnt2=0\n  for i in range(len(s)):\n    if s[i]=='(':\n      cnt1+=1\n    else:\n      if cnt1==0:\n        cnt2+=1\n      else:\n        cnt1-=1\n  if cnt2==0:\n    opens+=cnt1\n  elif cnt1==0:\n    closes+=cnt2\n  else:\n    ls.append(cnt2)\n    rs.append(cnt1)\nls=sorted(ls)\nrs=sorted(rs)\nlefts=sum(ls)\nrights=sum(rs)\nif opens-closes!=lefts-rights:\n  print('No')\nelse:\n  flag=False\n  if len(ls)==0:\n    flag=True\n  for a in ls:\n    if opens<a or closes<a+(rights-lefts):\n      continue\n    pos=bisect.bisect_right(rs,a+(rights-lefts))\n    if pos!=0:\n      flag=True\n      break\n  for d in rs:\n    if opens<d+(lefts-rights) or closes<d:\n      continue\n    pos=bisect.bisect_right(ls,d+(lefts-rights))\n    if pos!=0:\n      flag=True\n      break\n  if flag==True:\n    print('Yes')\n  else:\n    print('No')", "# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    SS = read().split()\n\n    for S in SS:\n        path = [0]\n        for s in S:\n            path.append(path[-1]+ dic[s])\n        ways.append((path[-1], min(path)))\n\n    ways_pos = sorted([(a,b) for a,b in ways if a >= 0], key = lambda x:x[0], reverse=True)\n    ways_neg = sorted([(a,b) for a,b in ways if a < 0], key = lambda x:(x[0] - x[1]), reverse=True)\n\n    tmp = []\n    for go, max_depth in ways_pos:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            tmp.append((go, max_depth))\n\n    for go, max_depth in tmp:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print('No')\n            return None\n\n    tmp =[]\n    for go, max_depth in ways_neg:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            tmp.append((go, max_depth))\n\n    for go, max_depth in tmp:\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print('No')\n            return None\n\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    run()\n__starting_point()", "# \u6298\u308c\u7dda\u30b0\u30e9\u30d5\u3067\u8003\u3048\u308b\u3068\n# ( : +1\n# ) : -1\n# 0\u3067\u7d42\u308f\u308b\n# 0\u672a\u6e80\u306b\u306a\u3089\u306a\u3044 \u2192 \u5404\u6587\u5b57\u5217\u3067\u6700\u4e0b\u70b9\u3068\u548c\u3092\u5229\u7528\n# \u548c\u304c\u30de\u30a4\u30ca\u30b9\u306e\u90e8\u5206\u3068\u5206\u3051\u3066\u3001\u30de\u30a4\u30ca\u30b9\u90e8\u5206\u306f\u53cd\u8ee2\u3057\u3066\u8003\u3048\u308b\n\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = [input().strip() for _ in range(n)]\nplus = []\nminus = []\nfor i in s:\n    min_v = 0\n    sum_v = 0\n    for j in i:\n        sum_v += 1 if j == '(' else -1\n        min_v = min(min_v, sum_v)\n    if sum_v > 0:\n        plus.append((min_v, sum_v))\n    else:\n        minus.append((min_v-sum_v, -sum_v))\n\nplus.sort(key=lambda x:x[0], reverse=True)\nminus.sort(key=lambda x:x[0], reverse=True)\n\nsum_plus = 0\nfor min_v, sum_v in plus:\n    if sum_plus + min_v < 0:\n        print(\"No\")\n        return\n    sum_plus += sum_v\n\nsum_minus = 0\nfor min_v, sum_v in minus:\n    if sum_minus + min_v < 0:\n        print(\"No\")\n        return\n    sum_minus += sum_v\n\nif sum_plus == sum_minus:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n\n\n", "import sys\nfrom operator import itemgetter\nN = int(input())\nS = sys.stdin.read().split()\nHT_high = []\nHT_low = []\nfor s in S:\n    t = 0\n    h = 0\n    for c in s:\n        if c == \"(\":\n            h += 1\n        else:\n            h -= 1\n            if h < t:\n                t = h\n    if h >= 0:\n        HT_high.append((h, t))\n    else:\n        HT_low.append((h, t))\nHT_high.sort(key=itemgetter(1), reverse=True)\nHT_low.sort(key=lambda x: x[0]-x[1], reverse=True)\nh0 = 0\nfor h, t in HT_high + HT_low:\n    if h0 + t < 0:\n        print(\"No\")\n        return\n    h0 += h\nif h0 != 0:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n", "N = int(input())\nAs = []\nBs = []\n\nfor _ in range(N):\n  c = 0\n  m = 0\n  for s in input():\n    if s == '(':\n      c += 1\n    elif s == ')':\n      c -= 1\n    m = min(m, c)\n  if c >= 0:\n    As.append((-m, c - m))\n  else:\n    Bs.append((-m, c - m))\n\nAs.sort(key=lambda x: x[0])\nBs.sort(key=lambda x: x[1], reverse=True)\n\nf = True\nc = 0\nfor (l, r) in As:\n  if c < l:\n    f = False\n    break\n  c += r - l\nif f:\n  for (l, r) in Bs:\n    if c < l:\n      f = False\n      break\n    c += r - l\n\nf = f and (c == 0)\n\nif f:\n  print('Yes')\nelse:\n  print('No')", "N = int(input())\n\ntleft = 0\ntright = 0\na = []\nb=  []\nfor _ in range(N):\n  s = input()\n  left = 0\n  lmin = 0\n  for c in s:\n    if c == \"(\":\n      left += 1\n    else: # \")\"\n      left -= 1\n      lmin = min(lmin,left)\n  #\n  if left >= 0:\n    if lmin == 0:\n      tleft += left\n    else:\n      a.append([left,lmin])\n  else:\n    if left <= lmin:\n      tright += left\n    else:\n      b.append([left,lmin])\n#\na.sort(key=lambda x:-x[1])\nb.sort(key=lambda x:x[1])\n\nfor left, lmin in a:\n  if tleft + lmin < 0:\n    print(\"No\")\n    return\n  else:\n    tleft += left\n#\nfor left, lmin in b:\n  if tleft + lmin < 0:\n    print(\"No\")\n    return\n  else:\n    tleft += left\n#\nif tleft + tright == 0:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n#\n", "# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    SS = read().split()\n\n    for S in SS:\n        path = [0]\n        for s in S:\n            path.append(path[-1]+ dic[s])\n        ways.append((path[-1], min(path)))\n\n    ways_pos = sorted([(a,b) for a,b in ways if a >= 0], key = lambda x:(x[1], x[0]), reverse=True)\n    ways_neg = sorted([(a,b) for a,b in ways if a < 0], key = lambda x:(x[1] - x[0], -x[0]))\n\n    for i in range(len(ways_pos)):\n        go, max_depth = ways_pos[i]\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    for i in range(len(ways_neg)):\n        go, max_depth = ways_neg[i]\n        if current + max_depth >= 0:\n            current += go\n        else:\n            print(\"No\")\n            return None\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    run()\n__starting_point()", "from functools import reduce\nn, *s = open(0).read().split()\nu = []\nfor t in s:\n    close_cnt = 0\n    tmp = 0\n    for c in t:\n        tmp += (1 if c == '(' else -1)\n        close_cnt = min(close_cnt, tmp)\n    u.append((close_cnt, tmp - close_cnt))\nM = 10**6 + 1\nacc = 0\nfor a, b in sorted(u, key=lambda z: (- M - z[0] if sum(z)>= 0 else M - z[1])):\n    if acc + a < 0:\n        print(\"No\")\n        return\n    else:\n        acc += a + b\nprint((\"No\" if acc else \"Yes\"))", "import sys\ninput = sys.stdin.readline\n \nn = int(input())\ns = [input().strip() for _ in range(n)]\nplus = []\nminus = []\nfor i in s:\n    min_v = 0\n    sum_v = 0\n    for j in i:\n        sum_v += 1 if j == '(' else -1\n        min_v = min(min_v, sum_v)\n    if sum_v > 0:\n        plus.append((min_v, sum_v))\n    else:\n        minus.append((min_v-sum_v, -sum_v))\n \nplus.sort(key=lambda x:x[0], reverse=True)\nminus.sort(key=lambda x:x[0], reverse=True)\n \nsum_plus = 0\nfor min_v, sum_v in plus:\n    if sum_plus + min_v < 0:\n        print(\"No\")\n        return\n    sum_plus += sum_v\n \nsum_minus = 0\nfor min_v, sum_v in minus:\n    if sum_minus + min_v < 0:\n        print(\"No\")\n        return\n    sum_minus += sum_v\n \nif sum_plus == sum_minus:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "n = int(input())\n\n\ndef _kakko(s):\n    l, lr = 0, 0\n    for c in s:\n        if c == ')':\n            if lr == 0:\n                l = l + 1\n            else:\n                lr = lr - 1\n        else:\n            lr = lr + 1\n    return (l, lr)\n\n\ns = [_kakko(input()) for _ in range(n)]\n\nsl = [ss for ss in s if ss[1] >= ss[0]]\nsr = [ss for ss in s if ss[1] < ss[0]]\n\nsl.sort(key=lambda x: x[0])\nsr.sort(key=lambda x: x[1], reverse=True)\n\nr = 0\nfor ss in sl:\n    if ss[0] > r:\n        print('No')\n        return\n    r = r + ss[1] - ss[0]\n\nfor ss in sr:\n    if ss[0] > r:\n        print('No')\n        return\n    r = r + ss[1] - ss[0]\n\nif r != 0:\n    print('No')\n    return\n\nprint('Yes')\n", "# +1/-1\u306e\u6298\u308c\u7dda\u3067\u8868\u3057\u305f\u3068\u304d\n# \u300c0\u3067\u7d42\u308f\u308b\u300d\u304b\u3064\u300c\u9014\u4e2d\u30670\u672a\u6e80\u306b\u306a\u3089\u306a\u3044\u300d\u3092\u6e80\u305f\u305b\u3070\u826f\u3044\n\n# \u3042\u3068\u306f\u8caa\u6b32\u3092\u4e0a\u624b\u3044\u4e8b\u4f7f\u3046\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    #from math import gcd\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n = int(input())\n    a = []\n    b = []\n    for _ in range(n):\n        s = input().rstrip()\n        # \u6700\u7d42\u7684\u306b\u4e0a\u304c\u308b\u91cf/\u6700\u4e0b\u70b9\n        up, down = 0, 0\n        for i in s:\n            if i == ')':\n                up -= 1\n                if down > up:\n                    down = up\n            else:\n                up += 1\n        if up >= 0:\n            a.append((down, up))\n        else:\n            b.append((down-up, -up))\n\n    a.sort(key=lambda a: a[0],reverse=True)\n    b.sort(key=lambda a: a[0],reverse=True)\n\n    left, right = 0, 0\n\n    for d, u in a:\n        if left+d < 0:\n            print('No')\n            break\n        else:\n            left += u\n    else:\n        for d, u in b:\n            if right+d < 0:\n                print('No')\n                break\n            else:\n                right += u\n        else:\n            if left == right:\n                print('Yes')\n            else:\n                print('No')\n    \ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    import sys\n    from collections import deque\n    sys.setrecursionlimit(10**6)\n    input = sys.stdin.readline\n    N = int(input())\n    pq = deque([])\n    mq = deque([])\n    for n in range(N):\n        s = input().strip()\n        mini = 0\n        dst = 0\n        for ss in [1 if ss == '(' else -1 for ss in s]:\n            dst += ss\n            mini = min(dst, mini)\n        \n        if dst >= 0:\n            pq.append((mini, dst))\n        elif dst < 0:\n            mq.append((mini - dst, mini, dst))\n    pq = sorted(pq, reverse=True)\n    mq = sorted(mq)\n    p = 0\n    for mini, dst in pq:\n        if p + mini < 0:\n            print('No')\n            return\n        p += dst\n    for minimini, mini, dst in mq:\n        if p + mini < 0:\n            print('No')\n            return\n        p += dst\n    if p != 0:\n        print('No')\n    else:\n        print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "#from collections import defaultdict, deque\n#import itertools\n#import numpy as np\n#import re\nimport bisect\n\ndef main():\n    N = int(input())\n    SS = []\n    for _ in range(N):\n        SS.append(input())\n    S = []\n    for s in SS:\n        while '()' in s:\n            s = s.replace('()', '')\n        S.append(s)\n    #print(S)\n    S = [s for s in S if s != '']\n    sum_op = 0\n    sum_cl = 0\n    S_both_op = []\n    S_both_cl = []\n    for s in S:\n        if not ')' in s:\n            sum_op += len(s)\n        elif not '(' in s:\n            sum_cl += len(s)\n        else:\n            pos = s.find('(')\n            if pos <= len(s) - pos:\n                S_both_op.append((pos, len(s)-pos))  #close\u306e\u307b\u3046\u304c\u5c11\u306a\u3044\u3001'))((('\u306a\u3069 -> (2,3)\n            else:\n                S_both_cl.append((pos, len(s)-pos))  #close\u306e\u307b\u3046\u304c\u591a\u3044\u3001')))(('\u306a\u3069 -> (3,2)\n\n    # S_both_op\u306f\u3001\u8010\u3048\u3089\u308c\u308b\u4e2d\u3067\u3088\u308a\u4f38\u3070\u3059\u9806\u306b\u3057\u305f\u307b\u3046\u304c\u3044\u3044\uff1f\n    #S_both_op.sort(key=lambda x: (x[0], x[0]-x[1]))  #close\u306e\u6570\u304c\u5c0f\u3055\u3044\u9806\u306bsort\u304b\u3064close-open\u304c\u5c0f\u3055\u3044=\u4f38\u3070\u3059\u5074\u306bsort\n    #S_both_cl.sort(key=lambda x: (x[0], x[0]-x[1]))  #\u3053\u308c\u3082close\u306e\u6570\u304c\u5c0f\u3055\u3044\u9806\u306bsort\u304b\u3064close-open\u304c\u5c0f\u3055\u3044=\u3042\u307e\u308a\u7e2e\u307e\u306a\u3044\u9806\u306bsort\n    S_both_op.sort(key=lambda x: x[0])\n    S_both_cl.sort(key=lambda x: -x[1])\n\n    for p in S_both_op:\n        sum_op -= p[0]\n        if(sum_op < 0 ):\n            print('No')\n            return\n        sum_op += p[1]\n\n    for p in S_both_cl:\n        sum_op -= p[0]\n        if(sum_op < 0 ):\n            print('No')\n            return\n        sum_op += p[1]\n    \n    if sum_op == sum_cl:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=lambda: sys.stdin.readline().strip()\n\n\nn=int(input())\nA=[]\n#\nPM=[[0,0] for i in range(n)]\nfor i in range(n):\n    now=0\n    mini=0\n    for j in input():\n        if j==\"(\": now+=1 \n        else:\n            now-=1 ; mini=min(mini,now)\n    PM[i]=[mini,now]\n\nif sum( [PM[i][1] for i in range(n)]  )!=0 : \n    print(\"No\")\n    return\n\nMINI=0\nNOW=0\nPMf=[PM[i] for i in range(n) if PM[i][1]>=0]\nPMf.sort()\nfor i in range(len(PMf)):\n    MINI=min(MINI , NOW+PMf[-i-1][0] )\n    NOW+=PMf[-i-1][1]\n    if MINI<0 : print(\"No\") ; return\n\nPMs=[PM[i] for i in range(n) if PM[i][1]<0]\nPMs=sorted(PMs , key=lambda x : x[1]-x[0])\nfor i in range(len(PMs)):\n    MINI=min(MINI , NOW+PMs[-i-1][0] )\n    NOW+=PMs[-i-1][1]\n    if MINI<0 : print(\"No\") ; return\n\nprint(\"Yes\")\n", "N = int(input())\nS_list = [input() for _ in range(N)]\n\nmin_revr, min_revl = 10**20, 10**20\nleft, rev_l, rev_r, right = 0, 0, 0, 0\nfor S in S_list:\n    stack = []\n    l, r = 0, 0\n    for s in S:\n        if s == '(':\n            if stack:\n                if stack[-1] == ')':\n                    stack.append('(')\n                    l = 1\n                else:\n                    stack.append('(')\n                    l += 1\n            else:\n                stack.append('(')\n                l = 1\n        else:   # s==')'\n            if stack:\n                if stack[-1] == '(':\n                    stack.pop()\n                    l -= 1\n                else:\n                    stack.append(')')\n                    r += 1\n            else:\n                stack.append(')')\n                r = 1\n    if l == 0:\n        right += r\n    elif r == 0:\n        left += l\n    else:\n        rev_r += r\n        rev_l += l\n        min_revr = min(min_revr, r)\n        min_revl = min(min_revl, l)\n\nif min_revr == 10**20:\n    min_revr = 0\nif min_revl == 10**20:\n    min_revl = 0\n\nif left+rev_l == rev_r+right and left >= min_revr and right >= min_revl:\n    print('Yes')\nelse:\n    print('No')\n", "n=int(input())\ns1=0\ns2=0\ns3=list()\ns4=list()\ns5=list()\nfor i in range(n):\n    a=str(input())\n    b=str()\n    while a!=b:\n        b=a\n        a=a.replace(r'()','')\n    if len(a)==0:\n        continue\n    if a[0]==\"(\" and a[-1]==\"(\":\n        s1+=len(a)\n    elif a[0]==\")\" and a[-1]==\")\":\n        s2+=len(a)\n    else:\n        x=len(a.replace(\"(\",\"\"))\n        y=len(a)-x\n        if x<y:\n            s3.append([x,y])\n        elif x==y:\n            s4.append(x)\n        else:\n            s5.append([x,y])\n            \ns3.sort(key=lambda x:x[0])\ns5.sort(key=lambda x:x[1])\n\nflag=0\nlimit=s1\n\nif len(s3)!=0:\n    for i in range(len(s3)):\n        if limit>=s3[i][0]:\n            limit=limit-s3[i][0]+s3[i][1]\n        else:\n            flag=1\n            print(\"No\")\n            break\n\nx=limit\n\nif len(s4)!=0:\n    if limit<max(s4):\n        print(\"No\")\n        flag=1\n\nlimit=s2\nif len(s5)!=0:    \n    if flag==0:\n        for i in range(len(s5)):\n            if limit>=s5[i][1]:\n                limit=limit-s5[i][1]+s5[i][0]\n            else:\n                flag=1\n                print(\"No\")\n                break\n\nif flag==0 and len(s4)!=0:\n    if limit<max(s4):\n        print(\"No\")\n        flag=1\n\nif flag==0 and x==limit:\n    print(\"Yes\")\nelif flag==0:\n    print(\"No\")\n        \n        \n       \n", "# input\nN = int(input())\nS = [input() for _ in range(N)]\n\n# process\nT = []\nfor s in S:\n    while '()' in s:\n        s = s.replace('()', '')\n    T.append(s)\n\nl1 = []\nl2 = []\nfor t in T:\n    op = t.find('(')\n    if op < 0:\n        op = len(t)\n    cl = len(t) - op\n    \n    if cl+op != 0:\n        if cl <= op:\n            l1.append((cl, op))\n        else:\n            l2.append((op, cl))\n\nl1.sort()\nl2.sort(reverse=True)\n\nresult = False\nx = 0\nif len(l1)+len(l2) == 0:\n    result = True\nelif len(l1)>0 and len(l2)>0 and l1[0][0]+l2[-1][0] == 0:\n    for cl, op in l1:\n        x -= cl\n        if x < 0:\n            break\n        x += op\n    \n    if x >= 0:\n        for op, cl in l2:\n            x -= cl\n            if x < 0:\n                break\n            x += op\n            \n        if x == 0:\n            result = True\n\n# output\nprint((\"Yes\" if result else \"No\"))\n", "n = int(input())\ns = []\nfor i in range(n):\n    s.append(input())\n\nls1 = []\nls2 = []\n\nfor item in s:\n    stk1 = []\n    stk2 = []\n    for ch in item:\n        if ch == '(':\n            stk2.append(ch)\n        else:\n            if len(stk2) > 0:\n                stk2.pop()\n            else:\n                stk1.append(ch)\n    l1 = len(stk1)\n    l2 = len(stk2)\n    if l2 >= l1:\n        ls1.append((l1, l2))\n    else:\n        ls2.append((l1, l2))\n\n\nls1.sort()\n\ncnt = 0\n\nfor item in ls1:\n    cnt -= item[0]\n    if cnt < 0:\n        print('No')\n        return\n    else:\n        cnt += item[1]\n\nls2.sort(key=lambda x: x[1])\nls2.reverse()\n\nfor item in ls2:\n    cnt -= item[0]\n    if cnt < 0:\n        print('No')\n        return\n    else:\n        cnt += item[1]\n\nif cnt != 0:\n    print('No')\nelse:\n    print('Yes')\n", "def main():\n    n = int(input())\n    l_0 = []\n    r_0 = []\n    ls_plus = []\n    ls_minus = []\n    sum_l = 0\n    sum_r = 0\n    for i in range(n):\n        s = input()\n        left, right = 0, 0\n        for j in range(len(s)):\n            if s[j] == '(':\n                right += 1\n            else:\n                if right > 0:\n                    right -= 1\n                else:\n                    left += 1\n        if left == right == 0:\n            continue\n\n        if left == 0:\n            l_0.append((left, right))\n        elif right == 0:\n            r_0.append((left, right))\n        elif left < right:\n            ls_plus.append((left, right))\n        else:\n            ls_minus.append((left, right))\n        sum_l += left\n        sum_r += right\n\n    if len(ls_plus) == len(ls_minus) == len(l_0) == len(r_0) == 0:\n        print(\"Yes\")\n        return\n\n    if len(l_0) == 0 or len(r_0) == 0:\n        print(\"No\")\n        return\n    if sum_l != sum_r:\n        print(\"No\")\n        return\n\n    # r-l\u306e\u5927\u304d\u3044\u9806\n    ls_plus.sort(key=lambda x: x[1] - x[0], reverse=True)\n    # l\u306e\u5c0f\u3055\u3044\u9806\n    ls_plus.sort(key=lambda x: x[0])\n\n    # l-r\u306e\u5c0f\u3055\u3044\u9806\n    ls_minus.sort(key=lambda x: x[0] - x[1])\n    # l\u306e\u5927\u3055\u3044\u9806\n    ls_minus.sort(key=lambda x: x[0], reverse=True)\n\n    now_r = 0\n    for ll in l_0:\n        now_r += ll[1]\n\n    # now_l = 0\n    for i in range(len(ls_plus)):\n        # l = ls[i][0]\n        r = ls_plus[i][1]\n        x = now_r - ls_plus[i][0]\n        if x >= 0:\n            # now_l = now_l\n            now_r = x + r\n        else:\n            print(\"No\")\n            return\n\n    for i in range(len(ls_minus)):\n        # l = ls[i][0]\n        r = ls_minus[i][1]\n        x = now_r - ls_minus[i][0]\n        if x >= 0:\n            # now_l = now_l\n            now_r = x + r\n        else:\n            print(\"No\")\n            return\n\n    print(\"Yes\")\n\n\nmain()\n", "# F - Bracket Sequencing\n\nfrom itertools import chain\n\nn = int(input())\nss = [input() for i in range(n)]\n\ndef parse(s):\n    \"\u30d0\u30e9\u30f3\u30b9\u3057\u3066\u3044\u306a\u3044\u9589\u3058\u62ec\u5f27\u6570, \u958b\u304d\u62ec\u5f27\u6570\"\n    cl, op = 0, 0\n    for c in s:\n        if c == '(':\n            op += 1\n        elif op > 0:\n            op -= 1\n        else:\n            cl += 1\n    return (cl, op)\n\nopen  = []  # \u958b\u304d\u62ec\u5f27\u306e\u307f\nclose = []  # \u9589\u3058\u62ec\u5f27\u306e\u307f\ninc   = []  # \u958b\u304d\u62ec\u5f27\u304c\u591a\u3044\ndec   = []  # \u9589\u3058\u62ec\u5f27\u304c\u591a\u3044\nfor s in ss:\n    cl, op = parse(s)\n    if cl == 0:\n        open.append((cl, op))\n    elif cl < op:\n        inc.append((cl, op))\n    elif op == 0:\n        close.append((cl, op))\n    else:\n        dec.append((cl, op))\npeak = 0\ninc.sort()\ndec.sort(reverse=True)\nfor cl, op in chain(open, inc, dec, close):\n    if peak < cl:\n        print('No')\n        return\n    peak += op - cl\nprint(('Yes' if peak == 0 else 'No'))\n", "'''\n\u25cb \u57fa\u672c\u65b9\u91dd\n'(' \u30921\u4e0a\u6607\u3001')'\u30921\u4e0b\u964d\u3068\u30a4\u30e1\u30fc\u30b8\u3059\u308b\u3068\u3001\n\u3053\u306e\u554f\u984c\u306f\u300c0\u672a\u6e80\u306b\u306a\u3089\u305a\u3001\u6700\u7d42\u7684\u306b0\u306b\u306a\u308b\u304b\u300d\u3068\u8a00\u3044\u63db\u3048\u3089\u308c\u308b\u3002\n\n1. \uff0f \u578b\n2. V \u578b\u3067\u4e0a\u6607\n3. V\u578b\u3067\u4e0b\u964d\n4. \uff3c\u578b\n\u306e\u9806\u3067\u4f7f\u3048\u3070\u3088\u3044\u3002\n\n2\u306f\u3001V\u5b57\u306e\u6700\u4e0b\u70b9\u304c\u6700\u3082\u9ad8\u3044\u3082\u306e\u304b\u3089\u4f7f\u3046\u306e\u304c\u6700\u9069\u3002\uff08\u5f90\u3005\u306b\u3001\u5927\u304d\u304f\u6c88\u307f\u8fbc\u3080\u3082\u306e\u3092\u4f7f\u3048\u308b\u3088\u3046\u306b\u306a\u308b\uff09\n3\u306f\u3001(|\u4e0b\u964d| - V\u5b57\u306e\u6700\u4e0b\u70b9) \u304c\u6700\u3082\u5927\u304d\u3044\u3082\u306e\u304b\u3089\u4f7f\u3046\u306e\u304c\u6700\u9069\u3002\uff08\u6c88\u307f\u8fbc\u307f\u304c\u5927\u304d\u3044\u3082\u306e\u306f\u65e9\u3081\u306b\u6d88\u5316\u3059\u308b\uff09\n\n\u3053\u3053\u3067\u30011\u306f2\u30013\u306f4\u3068\u5408\u308f\u305b\u3066\u8003\u3048\u3066\u826f\u3044\u3002\n'''\n\nYes = 'Yes'\nNo = 'No'\n\ndef main():\n    # \u5165\u529b\n    N = int(input())\n    up = []     # \u4e0a\u6607\u304c0\u4ee5\u4e0a\u306e\u3082\u306e\n    down = []   # \u4e0a\u6607\u304c0\u672a\u6e80\u306e\u3082\u306e\n    for _ in range(N):\n        S = input()\n        h, b = 0, 0 # h:\u4e0a\u6607\u6570\u3001b:\u6700\u4e0b\u70b9\n        for s in S:\n            if s=='(':\n                h += 1\n            else:\n                h -= 1\n                b = min(b, h)\n        #\n        if h>=0:\n            up.append((h, b))\n        else:\n            down.append((h, b))\n    # \u6f14\u7b97\n    up.sort(key=lambda t: t[1], reverse=True)           # \u4e0a\u6607\u306f\u3001\u6700\u4e0b\u70b9\u304c\u9ad8\u3044\u3082\u306e\u304b\u3089\u4f7f\u3046\n    down.sort(key=lambda t: t[0]-t[1], reverse=True)    # \u4e0b\u964d\u306f\u3001\u6c88\u307f\u8fbc\u307f\u5f8c\u306e\u53cd\u8ee2\u4e0a\u6607\u304c\u5927\u304d\u3044\u3082\u306e\u304b\u3089\u4f7f\u3046\n    H = 0   # \u73fe\u5728\u306e\u9ad8\u3055\n    for h, b in up + down:\n        if H+b>=0:  # \u9ad8\u3055\u304c0\u672a\u6e80\u306b\u306a\u3089\u306a\u3044\u6761\u4ef6\n            H += h\n        else:\n            print(No)\n            return\n    # \u51fa\u529b\n    if H == 0:\n        print(Yes)\n    else:\n        print(No)\n\n\nmain()\n\n", "from sys import stdin\n\ndef main():\n    readline = stdin.readline\n    n = int(readline())\n    s = tuple(readline().strip() for _ in range(n))\n\n    plus, minus = [], []\n    for c in s:\n        if 2 * c.count('(') - len(c) > 0:\n            plus.append(c)\n        else:\n            minus.append(c)\n\n    plus.sort(key = lambda x: x.count(')'))\n    minus.sort(key = lambda x: x.count('('), reverse = True)\n    plus.extend(minus)\n    sum = 0\n    for v in plus:\n        for vv in v:\n            sum = sum + (1 if vv == '(' else -1)\n            if sum < 0 : return print('No')\n    if sum != 0:\n        return print('No')\n\n    return print('Yes')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# F - Bracket Sequencing\n\nfrom itertools import chain\n\nn = int(input())\nss = [input() for i in range(n)]\n\ndef parse(s):\n    \"\u30d0\u30e9\u30f3\u30b9\u3057\u3066\u3044\u306a\u3044\u9589\u3058\u62ec\u5f27\u6570, \u958b\u304d\u62ec\u5f27\u6570\"\n    cl, op = 0, 0\n    for c in s:\n        if c == '(':\n            op += 1\n        elif op > 0:\n            op -= 1\n        else:\n            cl += 1\n    return (cl, op)\n\ninc   = []  # \u958b\u304d\u62ec\u5f27\u304c\u591a\u3044\ndec   = []  # \u9589\u3058\u62ec\u5f27\u304c\u591a\u3044\nclose = []  # \u9589\u3058\u62ec\u5f27\u306e\u307f\nfor s in ss:\n    cl, op = parse(s)\n    if cl < op:\n        inc.append((cl, op))\n    elif op == 0:\n        close.append((cl, op))\n    else:\n        dec.append((cl, op))\npeak = 0\ninc.sort()\ndec.sort(reverse=True)\nfor cl, op in chain(inc, dec, close):\n    if peak < cl:\n        print('No')\n        return\n    peak += op - cl\nprint(('Yes' if peak == 0 else 'No'))\n", "# -*- coding: utf-8 -*-\n\nN = int(input().strip())\nS_list = [input().strip() for _ in range(N)]\n#-----\n\ndef count_brackets(brackets):\n    cnt = 0\n    min_cnt = 0\n    \n    for i in range(len(brackets)):\n        if brackets[i] == \"(\":\n            cnt += 1\n        else:  # brackets[i] == \")\"\n            cnt -= 1\n            min_cnt = min(min_cnt, cnt)\n    \n    return cnt, min_cnt\n\n\ntmp_cnt_plus  = []\ntmp_cnt_minus = []\n\nfor S in S_list:\n    cnt, min_cnt = count_brackets(S)\n    \n    if cnt == min_cnt == 0:\n        continue\n    \n    if cnt >= 0:\n        tmp_cnt_plus.append( (cnt, min_cnt) )\n    else:  # cnt < 0\n        tmp_cnt_minus.append( (cnt, min_cnt) )\n\n\ntmp_cnt_plus.sort(key=lambda x: -x[1])\ntmp_cnt_minus.sort(key=lambda x: -(x[0]-x[1]) )\n\n\nsum_bracket = 0\nflag = True\n\nfor cnt, min_cnt in (tmp_cnt_plus + tmp_cnt_minus):\n    if (sum_bracket + min_cnt) < 0:\n        flag = False\n        break\n    \n    sum_bracket += cnt\n\n\nif (sum_bracket == 0) and flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef solve():\n    N = int(input())\n    inc_chunks = []\n    dec_chunks = []\n    for _ in range(N):\n        depth = 0\n        level = 0\n        for c in input():\n            if c == '(':\n                level += 1\n            else:\n                level -= 1\n                depth = min(depth, level)\n        if level > 0:\n            inc_chunks.append((depth, level))\n        else:\n            dec_chunks.append((depth - level, -level))\n\n    inc_chunks.sort(reverse=True)\n    dec_chunks.sort(reverse=True)\n    inc_level = 0\n    for depth, level in inc_chunks:\n        if inc_level + depth < 0:\n            return 'No'\n        inc_level += level\n    dec_level = 0\n    for depth, level in dec_chunks:\n        if dec_level + depth < 0:\n            return 'No' \n        dec_level += level\n    if inc_level != dec_level:\n        return 'No'\n    return 'Yes'\n\n\nprint((solve()))\n", "def main():\n    n = int(input())\n    l_0 = []\n    r_0 = []\n    ls_plus = []\n    ls_minus = []\n    sum_l = 0\n    sum_r = 0\n    for i in range(n):\n        s = input()\n        left, right = 0, 0\n        for j in range(len(s)):\n            if s[j] == '(':\n                right += 1\n            else:\n                if right > 0:\n                    right -= 1\n                else:\n                    left += 1\n        if left == right == 0:\n            continue\n\n        if left == 0:\n            l_0.append((left, right))\n        elif right == 0:\n            r_0.append((left, right))\n        elif left < right:\n            ls_plus.append((left, right))\n        else:\n            ls_minus.append((left, right))\n        sum_l += left\n        sum_r += right\n\n    if len(ls_plus) == len(ls_minus) == len(l_0) == len(r_0) == 0:\n        print(\"Yes\")\n        return\n\n    if len(l_0) == 0 or len(r_0) == 0:\n        print(\"No\")\n        return\n    if sum_l != sum_r:\n        print(\"No\")\n        return\n\n    # r-l\u306e\u5927\u304d\u3044\u9806\n    ls_plus.sort(key=lambda x: x[1] - x[0], reverse=True)\n    # l\u306e\u5c0f\u3055\u3044\u9806\n    ls_plus.sort(key=lambda x: x[0])\n\n    # l-r\u306e\u5c0f\u3055\u3044\u9806\n    ls_minus.sort(key=lambda x: x[0] - x[1])\n    # l\u306e\u5927\u3055\u3044\u9806\n    ls_minus.sort(key=lambda x: x[0], reverse=True)\n\n    now_r = 0\n    for ll in l_0:\n        now_r += ll[1]\n\n    for _ in ls_plus:\n        r = _[1]\n        x = now_r - _[0]\n        if x >= 0:\n            now_r = x + r\n        else:\n            print(\"No\")\n            return\n\n    for _ in ls_minus:\n        r = _[1]\n        x = now_r - _[0]\n        if x >= 0:\n            now_r = x + r\n        else:\n            print(\"No\")\n            return\n\n    print(\"Yes\")\n\n\nmain()\n", "from sys import stdin\n\ndef main():\n    plus, minus = [], []\n    readline = stdin.readline\n    n = int(readline())\n    for _ in range(n):\n        s = readline().rstrip()\n        if 2 * s.count('(') - len(s) > 0:\n            plus.append(s)\n        else:\n            minus.append(s)\n    plus.sort(key = lambda x: x.count(')'))\n    minus.sort(key = lambda x: x.count('('), reverse = True)\n    plus.extend(minus)\n\n    sum = 0\n    for v in ''.join(plus):\n        sum = sum + (1 if v == '(' else -1)\n        if sum < 0 : return print('No')\n    if sum != 0:\n        return print('No')\n\n    return print('Yes')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u6298\u308c\u7dda\u30b0\u30e9\u30d5\u3067\u8003\u3048\u308b\u3068\n# ( : +1\n# ) : -1\n# 0\u3067\u7d42\u308f\u308b\n# 0\u672a\u6e80\u306b\u306a\u3089\u306a\u3044 \u2192 \u5404\u6587\u5b57\u5217\u3067\u6700\u4e0b\u70b9\u3068\u548c\u3092\u5229\u7528\n# \u548c\u304c\u30de\u30a4\u30ca\u30b9\u306e\u90e8\u5206\u3068\u5206\u3051\u3066\u3001\u30de\u30a4\u30ca\u30b9\u90e8\u5206\u306f\u53cd\u8ee2\u3057\u3066\u8003\u3048\u308b\n\nn = int(input())\nplus = []\nminus = []\nfor i in range(n):\n    min_v = 0\n    sum_v = 0\n    s = input()\n    for j in s:\n        sum_v += 1 if j == '(' else -1\n        min_v = min(min_v, sum_v)\n    if sum_v > 0:\n        plus.append((min_v, sum_v))\n    else:\n        minus.append((min_v-sum_v, -sum_v))\n\nplus.sort(key=lambda x:x[0], reverse=True)\nminus.sort(key=lambda x:x[0], reverse=True)\n\nsum_plus = 0\nfor min_v, sum_v in plus:\n    if sum_plus + min_v < 0:\n        print(\"No\")\n        return\n    sum_plus += sum_v\n\nsum_minus = 0\nfor min_v, sum_v in minus:\n    if sum_minus + min_v < 0:\n        print(\"No\")\n        return\n    sum_minus += sum_v\n\nif sum_plus == sum_minus:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n\n\n", "def kakko(S):\n    cum = 0\n    mi = 0\n    for s in S:\n        cum += 1 if s == '(' else -1\n        mi = min(mi, cum)\n    return (-mi, cum - mi)\n\nN = int(input())\nS = [kakko(input()) for _ in range(N)]\n\nplus = []\nminus = []\n\nfor l, r in S:\n    if l <= r:\n        plus.append((l, r))\n    else:\n        minus.append((l, r))\n\nplus.sort(key=lambda a: a[0])\nminus.sort(key=lambda a: a[1], reverse=True)\nM = 0\nfor l, r in (plus + minus):\n    M -= l\n    if M < 0:\n        print('No')\n        return\n    M += r\n\nprint(('Yes' if M == 0 else 'No'))\n", "n = int(input())\nscop = [] #\u9ad8\u4f4e\u5dee,min\u5024\nscom = []\nssum = 0\n\nfor i in range(n):\n    s = input()\n    sa = 0\n    ms = 0\n    for i in s:\n        if i == \"(\":\n            sa += 1\n        else:\n            sa -= 1\n        if ms > sa:\n            ms = sa\n    if sa > 0:\n        scop.append([ms,sa])\n    elif not sa == ms:\n        scom.append([ms,sa])\n    ssum += sa\n\nif not ssum == 0:\n    print(\"No\")\n    return\n\nscop.sort(reverse = True)\nscom.sort()\n\nnow = 0\nfor i in scop:\n    if now + i[0] < 0:\n        print(\"No\")\n        return\n    now += i[1]\nfor i in scom:\n    if now + i[0] < 0:\n        print(\"No\")\n        return\n    now += i[1]\n\nprint(\"Yes\")\n", "def check():\n    N = int(input())\n    plus,minus = [],[]\n    for i in range(N):\n        S = input()\n        now = 0\n        mini = 0\n        for s in S:\n            if s=='(':\n                now += 1\n            else:\n                now -= 1\n                mini = min(mini,now)\n        if now>=0:\n            plus.append([mini,now])\n        else:\n            minus.append([now-mini,now])\n    plus.sort(reverse=True)\n    minus.sort(reverse=True)\n    now = 0\n    for a,b in plus:\n        if now + a <0:\n            return 'No'\n        now += b\n    for a,b in minus:\n        if now + b-a <0:\n            return 'No'\n        now += b\n    if now > 0:\n        return 'No' \n    return 'Yes'\nprint(check())", "from cython import longlong\n \ndef main():\n    n: longlong\n    n=int(input())\n    lp, lm = [], []\n    for i in range(n):\n        s=input()\n        \n        x: longlong\n        y: longlong\n        x,y=0,0\n        \n        for j in s:\n            if j==\"(\":x+=1\n            else:x-=1\n            y=min(y,x)\n        if x>0: lp.append((y,x))\n        else: lm.append((y-x,-x))\n    lp.sort()\n    s: longlong\n    s=0\n \n    i: longlong\n    j: longlong\n    for i,j in lp[::-1]:\n        if s+i<0:\n            print(\"No\")\n            return\n        s+=j\n    lm.sort()\n \n    t: longlong\n    t=0\n \n    i: longlong\n    j: longlong\n    for i,j in lm[::-1]:\n        if t+i<0:\n            print(\"No\")\n            return\n        t+=j\n    if s==t: print(\"Yes\")\n    else: print(\"No\")\n \ndef __starting_point():\n    main()\n__starting_point()", "def scan(s):\n    m = 0\n    a = 0\n    for c in s:\n        if c == '(':\n            a += 1\n        elif c == ')':\n            a -= 1\n        m = min(m, a)\n    return m, a\n\n\ndef key(v):\n    m, a = v\n    if a >= 0:\n        return 1, m, a\n    else:\n        return -1, a - m, a\n\nN = int(input())\nS = [input() for _ in range(N)]\n\nc = 0\nfor m, a in sorted([scan(s) for s in S], reverse=True, key=key):\n    if c + m < 0:\n        c += m\n        break\n    c += a\n\nif c == 0:\n    print('Yes')\nelse:\n    print('No')\n", "# \u5165\u529b\nN = int(input())\n\nS1 = [] # \u5897\u3048\u308b\u30b7\u30fc\u30b1\u30f3\u30b9\u7528\nS2 = [] # \u6e1b\u308b\u30b7\u30fc\u30b1\u30f3\u30b9\u7528\n\n# \u5165\u529b\u305d\u306e\uff12\nfor i in range(N):\n\n    S = input()  # \u30b7\u30fc\u30b1\u30f3\u30b9\n    mid, end = 0, 0    \n\n    for s in S:\n        if s == '(':\n            end += 1\n        else:\n            end -= 1\n            \n        mid = min(mid, end)  # \u9014\u4e2d\u7d4c\u904e\u3067\u4e00\u756a\u6e1b\u308b\u3068\u3053\u308d\u3092\u63a2\u3059\n\n    if end > 0:\n        S1.append((mid, end))\n    else:\n        S2.append((mid-end, -end))\n\nS1.sort(reverse=True)\n# S2.sort(key = lambda x : (x[0], -x[1]))\nS2.sort(reverse=True)\n\n\nmid = end1 = 0  # \u30b9\u30bf\u30fc\u30c8\nout = False\n\nfor t in S1:\n    a, b = t\n    mid = end1 + a\n    end1 = end1 + b\n    if mid < 0:  # \u9014\u4e2d\u3067\u5de6\u30ab\u30c3\u30b3\u306e\u6570\u304c\u53f3\u3092\u4e0a\u56de\u308b\n        out = True\n        break\n\nmid = end2 = 0  # \u30b9\u30bf\u30fc\u30c8\nfor t in S2:\n    a, b = t\n    mid = end2 + a\n    end2 = end2 + b\n    if mid < 0:  # \u9014\u4e2d\u3067\u5de6\u30ab\u30c3\u30b3\u306e\u6570\u304c\u53f3\u3092\u4e0a\u56de\u308b\n        out = True\n        break\n        \nif (not end1 == end2) or out:  # \u53f3\u3001\u5de6 \u306e\u6570\u304c\u5408\u308f\u306a\u3044\n    print('No')\nelse:\n    print('Yes')", "def main():\n    n = int(input())\n    Ss = [input() for _ in range(n)]\n    U = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        for c in Ss[i]:\n            if c == \"(\":\n                U[i][1] += 1\n            else:\n                if U[i][1] == 0:\n                    U[i][0] += 1\n                else:\n                    U[i][1] -= 1\n    L, R = 0, 0\n    P = []\n    for i in range(n):\n        if U[i][0] == 0 and U[i][1] > 0:\n            L += U[i][1]\n        elif U[i][0] > 0 and U[i][1] == 0:\n            R += U[i][0]\n        elif U[i][0] > 0 and U[i][1] > 0:\n            P.append([U[i][0], U[i][1]])\n    P.sort(key=lambda x: (x[0]-x[1], x[0], -x[1]))\n    if L == 0 and R == 0 and len(P) == 0:\n        print(\"Yes\")\n    elif (L == 0 or R == 0) and len(P) > 0:\n        print(\"No\")\n    else:\n        f = True\n        for i in range(len(P)):\n            L -= P[i][0]\n            if L < 0:\n                f = False\n                break\n            L += P[i][1]\n        if L == R and f:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\ndef __starting_point():\n    main()\n__starting_point()", "# F - Bracket Sequencing\nimport sys\nreadline = sys.stdin.readline\n\nN = int(input())\nL = []\nR = []\nfor _ in range(N):\n    S = readline().strip()\n    sums = 0\n    mins = 0\n    for s in S:\n        if s == '(':\n            sums += 1\n        else:\n            sums -= 1\n            mins = min(mins, sums)\n    if sums >= 0:\n        L.append((sums, mins))\n    else:\n        R.append((-sums, mins-sums))\n\nL.sort(key=lambda x: x[1], reverse=True)\nR.sort(key=lambda x: x[1], reverse=True)\n\nans = 'Yes'\nl_now = 0\nfor d, min_d in L:\n    if l_now + min_d < 0:\n        ans = 'No'\n        break\n    else:\n        l_now += d\n\nr_now = 0\nfor d, min_d in R:\n    if r_now + min_d < 0:\n        ans = 'No'\n        break\n    else:\n        r_now += d\n\nif l_now != r_now:\n    ans = 'No'\n\nprint(ans)", "from sys import stdin\n\ndef main():\n    plus, minus = [], []\n    readline = stdin.readline\n    n = int(readline())\n    for _ in range(n):\n        s = readline().rstrip()\n        if 2 * s.count('(') - len(s) > 0:\n            plus.append(s)\n        else:\n            minus.append(s)\n    plus.sort(key = lambda x: x.count(')'))\n    minus.sort(key = lambda x: x.count('('), reverse = True)\n\n    sum = 0\n    for v in ''.join(plus + minus):\n        sum = sum + (1 if v == '(' else -1)\n        if sum < 0 : return print('No')\n    if sum != 0:\n        return print('No')\n\n    return print('Yes')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def hoge(S):\n    cum = 0\n    mi = 0\n    for s in S:\n        cum += 1 if s == '(' else -1\n        mi = min(mi, cum)\n    return (-mi, cum - mi)\n\nN = int(input())\nS = [hoge(input()) for _ in range(N)]\n\nplus = []\nminus = []\n\nfor l, r in S:\n    if l <= r:\n        plus.append((l, r))\n    else:\n        minus.append((l, r))\n\nplus.sort(key=lambda a: a[0])\nminus.sort(key=lambda a: a[1], reverse=True)\nM = 0\nfor l, r in (plus + minus):\n    M -= l\n    if M < 0:\n        print('No')\n        return\n    M += r\n\nprint(('Yes' if M == 0 else 'No'))\n", "from itertools import chain\nimport sys\n\ndef main():\n    N = int(input())\n    # TLEs were caused mostly by slow input (1s+)\n    # S = list(input() for _ in range(N))\n    S = sys.stdin.read().split('\\n')\n    print((solve(S)))\n\ndef get_count(args):\n    s, result = args # messy input to work with map.\n    cum_sum = 0\n    for c in s:\n        if c == ')':\n            cum_sum -= 1\n        else:\n            cum_sum += 1\n        result[0] = max(result[0], -cum_sum)\n    result[1] = result[0] + cum_sum\n    return result\n\n# Made-up name, don't remember what to call this. Radix-ish\ndef silly_sort(array, value_min, value_max, get_value):\n    if len(array) == 0:\n        return\n    cache = [None for _ in range(value_max - value_min + 1)]\n    for elem in array:\n        # Assume elem[0] is the value\n        value = get_value(elem) - value_min\n        if cache[value] is None:\n            cache[value] = []\n        cache[value].append(elem)\n    for values in cache:\n        if values is None:\n            continue\n        for value in values:\n            yield value\n\ndef solve(S):\n    counts = [[0,0] for _ in range(len(S))]\n    counts = list(map(get_count, list(zip(S,counts))))\n    first_group = []\n    second_group = []\n    min_first_group = float('inf')\n    max_first_group = 0\n    min_second_group = float('inf')\n    max_second_group = 0\n\n    for c in counts:\n        if c[0] - c[1] <= 0:\n            first_group.append(c)\n            max_first_group = max(max_first_group, c[0])\n            min_first_group = min(min_first_group, c[0])\n        else:\n            second_group.append(c)\n            max_second_group = max(max_second_group, c[1])\n            min_second_group = min(min_first_group, c[1])\n    first_group = silly_sort(first_group, min_first_group, max_first_group, lambda c: c[0])\n    second_group = reversed(list(silly_sort(second_group, min_second_group, max_second_group, lambda c: c[1])))\n\n    order = chain(first_group, second_group)\n\n    cum_sum = 0\n    for c in order:\n        cum_sum -= c[0]\n        if cum_sum < 0:\n            return 'No'\n        cum_sum += c[1]\n    if cum_sum == 0:\n        return 'Yes'\n    return 'No'\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import *\nn,*s=open(0).read().split()\nu=[[min(accumulate(t,lambda a,b: a+(1 if b==\"(\" else -1),initial=0)),2*t.count(\"(\")-len(t)] for t in s]\nm=0\nfor c,d in chain(sorted([x for x in u if x[1]>=0])[::-1],sorted([x for x in u if x[1]<0],key=lambda z:z[0]-z[1])):\n    if m+c<0:print(\"No\");break\n    m+=d\nelse:\n    print(\"No\" if m else \"Yes\")", "import sys\nreadline = sys.stdin.readline\n\n\ndef solve():\n    N = int(input())\n    brackets_generator = (readline().strip() for _ in range(N))\n\n    grads_positive = list()\n    grads_negative = list()\n\n    total = 0\n    for brackets in brackets_generator:\n\n        elevation, bottom = 0, 0\n\n        for bk in brackets:\n\n            elevation += 1 if bk == '(' else -1\n            bottom = min(bottom, elevation)\n\n        if elevation >= 0:\n            grads_positive.append((bottom, elevation))\n        elif elevation < 0:\n            grads_negative.append((bottom - elevation, -elevation))\n\n        total += elevation\n\n    if total != 0:\n        return False\n\n    grads_positive.sort(reverse=True)\n    grads_negative.sort(reverse=True)\n\n    def is_good(grads):\n        elevation, bottom = 0, 0\n        for grad in grads:\n            bottom = elevation + grad[0]\n            if bottom < 0:\n                return False\n            elevation += grad[1]\n\n        return True\n\n    return is_good(grads_positive) and is_good(grads_negative)\n\n\ndef main():\n    ok = solve()\n    if ok:\n        print('Yes')\n    else:\n        print('No')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u6298\u308c\u7dda\u30b0\u30e9\u30d5\u3067\u8003\u3048\u308b\u3068\n# ( : +1\n# ) : -1\n# 0\u3067\u7d42\u308f\u308b\n# 0\u672a\u6e80\u306b\u306a\u3089\u306a\u3044 \u2192 \u5404\u6587\u5b57\u5217\u3067\u6700\u4e0b\u70b9\u3068\u548c\u3092\u5229\u7528\n# \u548c\u304c\u30de\u30a4\u30ca\u30b9\u306e\u90e8\u5206\u3068\u5206\u3051\u3066\u3001\u30de\u30a4\u30ca\u30b9\u90e8\u5206\u306f\u53cd\u8ee2\u3057\u3066\u8003\u3048\u308b\n\nn = int(input())\ns = [input() for _ in range(n)]\nplus = []\nminus = []\nfor i in s:\n    min_v = 0\n    sum_v = 0\n    for j in i:\n        sum_v += 1 if j == '(' else -1\n        min_v = min(min_v, sum_v)\n    if sum_v > 0:\n        plus.append((min_v, sum_v))\n    else:\n        minus.append((min_v-sum_v, -sum_v))\n\nplus.sort(key=lambda x:x[0], reverse=True)\nminus.sort(key=lambda x:x[0], reverse=True)\n\nsum_plus = 0\nfor min_v, sum_v in plus:\n    if sum_plus + min_v < 0:\n        print(\"No\")\n        return\n    sum_plus += sum_v\n\nsum_minus = 0\nfor min_v, sum_v in minus:\n    if sum_minus + min_v < 0:\n        print(\"No\")\n        return\n    sum_minus += sum_v\n\nif sum_plus == sum_minus:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n\n\n", "# +1/-1\u306e\u6298\u308c\u7dda\u3067\u8868\u3057\u305f\u3068\u304d\n# \u300c0\u3067\u7d42\u308f\u308b\u300d\u304b\u3064\u300c\u9014\u4e2d\u30670\u672a\u6e80\u306b\u306a\u3089\u306a\u3044\u300d\u3092\u6e80\u305f\u305b\u3070\u826f\u3044\n\n# \u3042\u3068\u306f\u8caa\u6b32\u3092\u4e0a\u624b\u3044\u4e8b\u4f7f\u3046\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    #from math import gcd\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n = int(input())\n    a = []\n    b = []\n    for _ in range(n):\n        s = input().rstrip()\n        # \u6700\u7d42\u7684\u306b\u4e0a\u304c\u308b\u91cf/\u6700\u4e0b\u70b9\n        up, down = 0, 0\n        for i in s:\n            if i == ')':\n                up -= 1\n                if down > up:\n                    down = up\n            else:\n                up += 1\n        if up >= 0:\n            a.append((down, up))\n        else:\n            b.append((up-down, down, up))\n\n    a.sort(reverse=True)\n    b.sort(key=lambda a: a[0],reverse=True)\n\n    c = 0\n\n    for d, u in a:\n        if c+d < 0:\n            print('No')\n            break\n        else:\n            c += u\n    else:\n        for _, d, u in b:\n            if c+d < 0:\n                print('No')\n                break\n            else:\n                c += u\n        else:\n            if c == 0:\n                print('Yes')\n            else:\n                print('No')\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\ns = [input() for _ in range(n)]\n\n\ndef bracket(x):\n    # f: final sum of brackets '(':+1, ')': -1\n    # m: min value of f\n    f = m = 0\n    for i in range(len(x)):\n        if x[i] == '(':\n            f += 1\n        else:\n            f -= 1\n        m = min(m, f)\n    # m <= 0\n    return f, m\n\n\ndef func(l):\n    # l = [(f, m)]\n    l.sort(key=lambda x: -x[1])\n    v = 0\n    for fi, mi in l:\n        if v + mi >= 0:\n            v += fi\n        else:\n            return -1\n    return v\n\n\nl1 = []\nl2 = []\nfor i in range(n):\n    fi, mi = bracket(s[i])\n    if fi >= 0:\n        l1.append((fi, mi))\n    else:\n        l2.append((-fi, mi - fi))\n\nv1 = func(l1)\nv2 = func(l2)\nif v1 == -1 or v2 == -1:\n    ans = 'No'\nelse:\n    ans = 'Yes' if v1 == v2 else 'No'\n\nprint(ans)\n", "def main():\n    n = int(input())\n    up = []\n    down = []\n    for _ in range(n):\n        height = 0\n        m = 0\n        for si in input():\n            if si == \"(\":\n                height += 1\n            else:\n                height -= 1\n                m = min(m, height)\n        if height >= 0:\n            up.append([m, height])\n        else:\n            down.append([m-height, -height])\n    up.sort(reverse=True)\n    down.sort(reverse=True)\n    if sum([i for _, i in up]) - sum([i for _, i in down]) != 0:\n        print(\"No\")\n        return\n    h = 0\n    for mi, hi in up:\n        if h+mi < 0:\n            print(\"No\")\n            return\n        h += hi\n    h = 0\n    for mi, hi in down:\n        if h+mi < 0:\n            print(\"No\")\n            return\n        h += hi\n    print(\"Yes\")\n    return\n            \n\ndef __starting_point():\n    main()\n__starting_point()", "def CNT(A):\n    tmp, Min = 0, 0\n    for a in A:\n        if a == '(': tmp += 1\n        else: tmp -= 1\n        Min = min(Min, tmp)\n    return (-Min, tmp-Min)\n\nN = int(input())\nS = [input() for _ in range(N)]\nT = [CNT(s) for s in S]\n\npls = []\nmis = []\nfor l, r in T:\n    if l <= r: pls.append((l, r))\n    else: mis.append((l, r))\n\npls.sort(key=lambda a: a[0])\nmis.sort(key=lambda a: a[1], reverse=True)\ntotl= pls + mis\n\nlevl = 0\nfor l, r in totl:\n    levl -= l\n    if levl < 0:\n        print('No')\n        return\n    levl += r\n\nprint('Yes' if levl==0 else 'No')", "import sys\ninput = sys.stdin.readline\ndef main():\n    N = int( input())\n    S = [input().strip() for _ in range(N)]\n    Up = []\n    Down = []\n    for s in S:\n        now = 0\n        m = 0\n        for t in s:\n            if t == \"(\":\n                now += 1\n            else:\n                now -= 1\n            if now < m:\n                m = now\n            # print(t, now)\n        if now >= 0:\n            Up.append((m,now))\n        else:\n            Down.append((m-now,-now))\n    up = 0\n    Up.sort(reverse=True)\n    for m, inc in Up:\n        if up+m < 0:\n            print(\"No\")\n            return\n        up += inc\n    \n    down = 0\n    Down.sort(reverse=True)\n    # print(Up, Down)\n    for m, dec in Down:\n        if down+m < 0:\n            print(\"No\")\n            return\n        down += dec\n    if up != down:\n        print(\"No\")\n        return\n    print(\"Yes\")\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "N = int((input()))\nC_p = []\nC_m = []\nfor i in range(N):\n    kakko = input()\n    temp = 0\n    temp_min = 0\n    for s in kakko:\n        if s == \"(\":\n            temp += 1\n        else:\n            temp -= 1\n            temp_min = min(temp, temp_min)\n    if temp >= 0:\n        C_p.append((temp_min, temp))\n    else:\n        C_m.append((temp_min - temp, temp_min, temp))\nC_p.sort(reverse=True)\n\nflag = 0\nfinal = 0\nfor l, f in C_p:\n    if final + l < 0:\n        flag = 1\n    final += f\n\nC_m.sort()\n\nfor _, l, f in C_m:\n    if final + l < 0:\n        flag = 1\n    final += f\n    \nif final != 0:\n    flag = 1\n\nprint(\"Yes\" if flag == 0 else \"No\")", "import bisect\n\nn=int(input())\nopens=0\ncloses=0\nls=[]\nrs=[]\nfor _ in range(n):\n  s=input()\n  cnt1=0\n  cnt2=0\n  for i in range(len(s)):\n    if s[i]=='(':\n      cnt1+=1\n    else:\n      if cnt1==0:\n        cnt2+=1\n      else:\n        cnt1-=1\n  if cnt2==0:\n    opens+=cnt1\n  elif cnt1==0:\n    closes+=cnt2\n  else:\n    ls.append(cnt2)\n    rs.append(cnt1)\nls=sorted(ls)\nrs=sorted(rs)\nlefts=sum(ls)\nrights=sum(rs)\nif opens-closes!=lefts-rights:\n  print('No')\nelse:\n  flag=False\n  if len(ls)==0:\n    flag=True\n  for a in ls:\n    if opens<a or closes<a+(rights-lefts):\n      continue\n    pos=bisect.bisect_right(rs,a+(rights-lefts))\n    if pos!=0:\n      flag=True\n      break\n  for b in rs:\n    if opens<b+(lefts-rights) or closes<b:\n      continue\n    pos=bisect.bisect_right(ls,b+(lefts-rights))\n    if pos!=0:\n      flag=True\n      break\n  if flag==True:\n    print('Yes')\n  else:\n    print('No')", "# \u5165\u529b\nN = int(input())\n\nS1 = [] # \u5897\u3048\u308b\u30b7\u30fc\u30b1\u30f3\u30b9\u7528\nS2 = [] # \u6e1b\u308b\u30b7\u30fc\u30b1\u30f3\u30b9\u7528\n\n# \u5165\u529b\u305d\u306e\uff12\nfor i in range(N):\n\n    S = input()  # \u30b7\u30fc\u30b1\u30f3\u30b9\n    mid, end = 0, 0    \n\n    for s in S:\n        if s == '(':\n            end += 1\n        else:\n            end -= 1\n            \n        mid = min(mid, end)  # \u9014\u4e2d\u7d4c\u904e\u3067\u4e00\u756a\u6e1b\u308b\u3068\u3053\u308d\u3092\u63a2\u3059\n\n    if end > 0:\n        S1.append((mid, end))\n    else:\n        S2.append((mid-end, -end))\n\nS1.sort(reverse=True)\n# S2.sort(key = lambda x : (x[0], -x[1]))\nS2.sort(reverse=True)\n\n\nmid = end1 = 0  # \u30b9\u30bf\u30fc\u30c8\nout = False\n\nfor t in S1:\n    a, b = t\n    mid = end1 + a\n    end1 = end1 + b\n    if mid < 0 or end1 < 0:  # \u9014\u4e2d\u3067\u5de6\u30ab\u30c3\u30b3\u306e\u6570\u304c\u53f3\u3092\u4e0a\u56de\u308b\n        out = True\n        break\n\nmid = end2 = 0  # \u30b9\u30bf\u30fc\u30c8\nfor t in S2:\n    a, b = t\n    mid = end2 + a\n    end2 = end2 + b\n    if mid < 0 or end2 < 0:  # \u9014\u4e2d\u3067\u5de6\u30ab\u30c3\u30b3\u306e\u6570\u304c\u53f3\u3092\u4e0a\u56de\u308b\n        out = True\n        break\n        \nif (not end1 == end2) or out:  # \u53f3\u3001\u5de6 \u306e\u6570\u304c\u5408\u308f\u306a\u3044\n    print('No')\nelse:\n    print('Yes')", "\ndef resolve():\n    def check(arr):\n        height = 0\n        for b, h in arr:\n            if height+b < 0:\n                return False\n            height += h\n        return True\n\n    N = int(input())\n    plus = []\n    minus = []\n    total = 0\n    for _ in range(N):\n        # 1\u3064\u306e\u30d1\u30fc\u30c4\u3092\u51e6\u7406\n        S = input()\n        cum = 0 # \u7d2f\u7a4d\u548c(\u6700\u9ad8\u5730\u70b9)\n        bottom = 0 # \u6700\u4e0b\u5730\u70b9\n        for s in S:\n            if s == \"(\":\n                cum += 1\n            else:\n                cum -= 1\n            bottom = min(bottom, cum)\n\n        total += cum\n        if cum > 0:\n            plus.append((bottom, cum))\n        else:\n            minus.append((bottom-cum, -cum))\n\n    plus.sort(reverse=True)\n    minus.sort(reverse=True)\n\n    if check(plus) and check(minus) and total == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def main():\n  ## IMPORT MODULE\n  #import sys\n\n  #sys.setrecursionlimit(100000)\n  #input=lambda :sys.stdin.readline().rstrip()\n\n  #f_inf=float(\"inf\")\n  #MOD=10**9+7\n  \n  if 'get_ipython' in globals(): \n    ## SAMPLE INPUT\n    n = 4\n    S = ['((()))', '((((((', '))))))', '()()()']\n\n  else:\n    ## INPUT \n    n = int(input())\n    #a, b = map(int, input().split())\n    S = [input() for _ in range(n)]\n\n  ## SUBMITION CODES HERE\n  def CNT(A):\n    tmp, Min = 0, 0\n    for a in A:\n        if a == '(': tmp += 1\n        else: tmp -= 1\n        Min = min(Min, tmp)\n    return (-Min, tmp-Min)\n  \n  T = [CNT(s) for s in S]\n\n  pls = []\n  mis = []\n  for l, r in T:\n    if l <= r: pls.append((l, r))\n    else: mis.append((l, r))\n\n  pls.sort(key=lambda a: a[0])\n  mis.sort(key=lambda a: a[1], reverse=True)\n  total = pls + mis\n\n  levl = 0\n  for l, r in total:\n    levl -= l\n    if levl < 0:\n        print('No')\n        return\n    levl += r\n\n  print('Yes' if levl == 0 else 'No')\n    \nmain()"]
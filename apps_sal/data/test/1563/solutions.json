["n, m = map(int, input().split())\nc = [0] + list(map(int, input().split()))\nt = {i: set() for i in set(c[1:])}\nfor i in range(m):\n    a, b = map(int, input().split())\n    if c[a] != c[b]:\n        t[c[a]].add(c[b])\n        t[c[b]].add(c[a])\nj, k = c[1], 0\nfor i, s in t.items():\n    l = len(s)\n    if l >= k: \n        if l > k: j, k = i, l\n        elif j > i: j = i\nprint(j)", "n, m = map(int, input().split())\nc = [0] + list(map(int, input().split()))\nt = {i: [] for i in set(c[1:])}\nfor i in range(m):\n    a, b = map(int, input().split())\n    if c[a] != c[b]:\n        t[c[a]].append(c[b])\n        t[c[b]].append(c[a])\nj, k = c[1], 0\nfor i, s in t.items():\n    l = len(set(s))\n    if l >= k: \n        if l > k: j, k = i, l\n        elif j > i: j = i\nprint(j)", "import sys\nv,e = input().split()\nv = int(v)\ne = int(e)\nadj = {}\ncolor= [int(x) for x in input().split()]\n\nfor c in color:\n\tadj[c] = set()\ncolor.insert(0,0)\nfor i in range(e):\n\ta,b = input().split()\n\ta = int(a)\n\tb = int(b)\n\t\n\tif color[a] != color[b]:\n\t\tadj[color[a]].add(color[b])\n\t\tadj[color[b]].add(color[a])\nmin_color = sys.maxsize\nmax_div = 0 \nfor key in list(adj.keys()):\n\tif len(adj[key]) > max_div:\n\t\tmin_color = key\n\t\tmax_div = len(adj[key])\n\telif len(adj[key]) == max_div:\n\t\tif key < min_color:\n\t\t\tmin_color = key\nprint(min_color)\n#print(adj)\n\n\t\n", "3\n# D. Colorful Graph\nfrom collections import deque\n\nMAX_COLORS = 10 \n\ndef bfs(vertex):\n\tnonlocal adjlist, visited, colors, dvt, count, idx\n\tqueue = deque()\n\tqueue.append(vertex)\n\tvisited[vertex] = 1\n\twhile queue:\n\t\tcurv = queue.popleft()\n\t\tfor v in adjlist[curv]:\n\t\t\tif colors[v] != colors[curv]:\n\t\t\t\tif colors[curv] not in dvt:\n\t\t\t\t\tdvt[colors[curv]] = {colors[v]}\n\t\t\t\telse:\n\t\t\t\t\tdvt[colors[curv]].add(colors[v])\n\t\t\t\tif len(dvt[colors[curv]]) > count:\n\t\t\t\t\tidx = colors[curv]\n\t\t\t\t\tcount = len(dvt[colors[curv]])\n\t\t\t\telif len(dvt[colors[curv]]) == count and colors[curv] < idx:\n\t\t\t\t\tidx = colors[curv]\n\t\t\tif visited[v] == 0:\n\t\t\t\tqueue.append(v)\n\t\t\t\tvisited[v] = 1\n\nn, m = [int(x) for x in input().split()]\ncolors = []\nadjlist = [[] for x in range(n)]\ndvt = {} \nvisited = [0] * n\ncolors = [int(x) for x in input().split()]\nfor i in range(m):\n\tx, y = [int(x) for x in input().split()]\n\tx -= 1\n\ty -= 1\n\tadjlist[x].append(y)\n\tadjlist[y].append(x)\n\ncount = 0\nidx = min(colors)\nfor i in range(n):\n\tif visited[i] == 0:\n\t\tbfs(i)\n\nprint(idx)\n", "from collections import defaultdict\nn, m = list(map(int, input().split()))\ncolour = [0] + list(map(int, input().split()))\nmx, ans = 0, min(colour[1:])\ncount = defaultdict(set)\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    if colour[a] != colour[b]:\n        count[colour[a]].add(colour[b])\n        count[colour[b]].add(colour[a])\nfor colour in count:\n    if len(count[colour]) > mx:\n        mx = len(count[colour])\n        ans = colour\n    elif len(count[colour]) == mx and colour < ans:\n        ans = colour\nprint(ans)\n", "from collections import defaultdict\n\nget= lambda : list(map(int,input().split()))\nn,m=get()\nc=list(get())\nadj={ i:set() for i in sorted(c)}\nfor i in range(m):\n    a,b=get()\n    if c[a-1]!=c[b-1]:\n        adj[c[b-1]].add(c[a-1])\n        adj[c[a-1]].add(c[b-1])\n\nprint(max(adj,key=lambda x:len(adj[x])))\n    \n    \n# http://codeforces.com/problemset/problem/246/D\n", "from collections import defaultdict\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\n\nres = defaultdict(set)\nfor _ in range(m):\n    u, v = map(lambda x: int(x) - 1, input().split())\n    if c[u] != c[v]:\n        res[c[u]].add(c[v])\n        res[c[v]].add(c[u])\n\nres_count = -1\nres_color = -1\nfor color in c:\n    count = res[color]\n    if res_count == -1 or res_count < len(count):\n        res_count = len(count)\n        res_color = color\n    elif res_count == len(count) and color < res_color:\n        res_color = color\n\nprint(res_color)", "n,m = list(map(int,input().strip().split()))\ncolor = list(map(int,input().strip().split()))\ng = [[] for  i in range(n)]\ncolors = {i:set() for i in sorted(color)}\nfor i in range(m):\n    u,v =list(map(int,input().strip().split()))\n    u -= 1\n    v -= 1\n    if color[u] != color[v]:\n        colors[color[u]].add(color[v])\n        colors[color[v]].add(color[u])\nprint(max(colors,key = lambda x : len(colors[x])))", "n,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nd={x:set() for x in set(l)}\n\nfor i in range(m) :\n    a,b=list(map(int,input().split()))\n    if l[a-1]!=l[b-1] :\n        d[l[a-1]].add(l[b-1])\n        d[l[b-1]].add(l[a-1])\n\nd=sorted(d,key=lambda x :(len(d[x]),-x))\n\nprint(d[-1])\n\n    \n", "n, m = map(int, input().split())\ncolor = list(map(int, input().split()))\n\nx = list(zip(*[list(map(int, input().split())) for i in range(m)]))\ny = x[1]\nx = x[0]\n\nans = dict()\n\nfor i in color:\n    if i not in ans:\n        ans[i] = set()\n\nfor i in range(m):\n    if color[x[i]-1] != color[y[i]-1]:\n        ans[color[x[i]-1]].add(color[y[i]-1])\n        ans[color[y[i]-1]].add(color[x[i]-1])\n\nfor i in ans:\n    Max = i\n    break\n\n#print(ans)\nMaxLen = len(ans[Max])\nfor i in ans:\n    LAns = len(ans[i])\n    if (MaxLen < LAns) or ((MaxLen == LAns) and (Max>i)):\n        Max = i\n        MaxLen = LAns\n\nprint(Max)", "n,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nd={x:set() for x in set(l)}\n\nfor i in range(m) :\n    a,b=list(map(int,input().split()))\n    if l[a-1]!=l[b-1] :\n        d[l[a-1]].add(l[b-1])\n        d[l[b-1]].add(l[a-1])\n\nd=sorted(d,key=lambda x :(len(d[x]),-x))\n\nprint(d[-1])\n", "n,m=list(map(int,input().split()))\na=list(map(int,input().split()))\na.insert(0,-1)\ng=[[] for i in range(n+1)]\nfor i in range(m):\n\tu,v=list(map(int,input().split()))\n\tg[u].append(v)\n\tg[v].append(u)\n#print(g)\ndiv=[0]\nfor i in range(1,n+1):\n\ts=set()\n\tfor j in g[i]:\n\t\tif a[j]!=a[i]:\n\t\t\ts.add(a[j])\n\tdiv.append(s)\n#print(div)\nc={}\nfor i in range(1,len(a)):\n\tif a[i] in c:\n\t\tc[a[i]].append(i)\n\telse:\n\t\tc[a[i]]=[i]\n#print(c)\nm=0\nind=1000000\t\nfor i in c:\n\td=set()\n\tfor j in c[i]:\n\t\tfor k in div[j]:\n\t\t\td.add(k)\n\tif len(d)>m:\n\t\tind=i\n\t\tm=len(d)\n\telif len(d)==m:\n\t\tind=min(ind,i)\nprint(ind)\n", "n,m=map(int,input().split())\ncol=list(map(int,input().split()))\ncs=set(col)\ncnt=[None]*100001\nfor i in range(100001):\n\tcnt[i]=set()\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tif(col[u-1]!=col[v-1]):\n\t\tcnt[col[u-1]].add(col[v-1])\n\t\tcnt[col[v-1]].add(col[u-1])\nans=-1\nmx=-1\nfor i in range(100001):\n\tif(mx<len(cnt[i]) and i in cs):\n\t\tmx=len(cnt[i])\n\t\tans=i\nprint(ans)", "n,m=map(int,input().split())\na=list(map(int,input().split()))\ngr=[set() for i in range(n)]\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tgr[u-1].add(v-1)\n\tgr[v-1].add(u-1)\ntr={}\nfor i in range(max(a)):\n\ttr[i]=set()\nfor i in range(n):\n\tb=a[i]\n\tfor j in gr[i]:\n\t\tif a[j]!=b:\n\t\t\ttr[b-1].add(a[j]-1)\n\nans=0\npos=min(a)\nfor i in range(max(a)):\n\tif len(tr[i])>ans:\n\t\tans=len(tr[i])\n\t\tpos=i+1\n\nprint(pos)", "__autor__ = 'Esfandiar'\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\nn,m = list(map(int,input().split()))\nc = list(map(int,input().split()))\ng = [[] for _ in range(n)]\nfor i in range(m):\n    u,v = list(map(int,input().split()))\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\ncolor = defaultdict(list)\nfor u in range(n):\n    color[c[u]].append(u)\n\nM = -float('inf')\nfor k in list(color.keys()):\n    seen = dict()\n    res=0\n    for v in color[k]:\n        for u in g[v]:\n            if c[u] != k and seen.get(c[u],-1)==-1:\n                res+=1\n                seen[c[u]]=1\n        if res > M:\n            M=res\n            kk=k\n        elif res == M:\n            kk=min(kk,k)\nprint(kk)\n\n\n\n\n\n\n'''\n8 8\n3 3 2 3 3 3 1 3\n8 2\n6 3\n2 3\n2 6\n5 6\n4 2\n7 5\n1 6\n'''\n\n", "from sys import stdin\nfrom collections import *\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef main():\n    n, m = arr_inp(1)\n    c, ans, ma = arr_inp(1), float('inf'), 0\n    mem = defaultdict(set)\n\n    for i in range(m):\n        u, v = arr_inp(1)\n        u -= 1\n        v -= 1\n        if c[u] != c[v]:\n            mem[c[u]].add(c[v])\n            mem[c[v]].add(c[u])\n\n    for i, j in list(mem.items()):\n        if len(j) > ma:\n            ma = max(ma, len(j))\n            ans = i\n        if len(j) == ma:\n            ans = min(ans, i)\n\n    print(ans if ans != float('inf') else min(c))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\nfrom math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\nsys.setrecursionlimit(100000)\n\n\nn,m=mdata()\nC=list(mdata())\ng=dd(set)\nd=dd(set)\nfor i in range(m):\n    a,b=mdata()\n    c1=C[a-1]\n    c2=C[b-1]\n    if c1!=c2:\n        d[c1].add(c2)\n        d[c2].add(c1)\nm=0\nind=min(C)\nfor i in sorted(d.keys()):\n    if len(d[i])>m:\n        m=len(d[i])\n        ind=i\nprint(ind)", "n, m = list(map(int, input().strip().split()))\ncolor = list(map(int, input().strip().split()))\n\ng = [[] for i in range(n)]\n\ncolors = {i:set() for i in sorted(color)}\n\nfor i in range(m):\n\tx, y = list(map(int, input().strip().split()))\n\tx -= 1\n\ty -= 1\n\t#print(color)\n\t#print(color[x], color[y])\n\tif color[x] != color[y]:\n\t\tcolors[color[x]].add(color[y])\n\t\tcolors[color[y]].add(color[x])\nprint(max(colors, key = lambda _: len(colors[_])))\n", "from collections import defaultdict\nn,m = map(int,input().split())\ng = defaultdict(set)\nc = list(map(int,input().split()))\nfor _ in range(m):\n    x,y = map(int,input().split())\n    if(c[x-1]!=c[y-1]):g[c[x-1]].add(c[y-1])\n    if(c[y-1]!=c[x-1]):g[c[y-1]].add(c[x-1])\nma = 0\nco = 10**5 + 1      \nf = 0   \nfor i in g:\n    ma = max(ma,len(g[i]))\nfor i in g:\n    if(len(g[i])==ma):\n        f+=1\n        co = min(co,i)\nif(f==0):\n    co = min(c)\nprint(co)", "from collections import defaultdict\nfrom sys import stdin\n\ninput = stdin.readline\n\nclass N:\n    def __init__(self, c) -> None:\n        self.c = c\n        self.ch = []\n\n\ndef __starting_point():\n    n, m = list(map(int, input().split()))\n    carr = list(map(int, input().split()))\n    arr = [N(x) for x in carr]\n\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        arr[a - 1].ch.append(arr[b - 1])\n        arr[b - 1].ch.append(arr[a - 1])\n\n    for x in arr:\n        x.ch = list([y for y in x.ch if y.c != x.c])\n\n    dct = defaultdict(lambda: set())\n\n    for x in arr:\n        for y in x.ch:\n            if y.c != x.c:\n                dct[x.c].add(y.c)\n\n    narr = []\n\n    for key, value in list(dct.items()):\n        narr.append((key, len(value)))\n\n    narr.sort(key=lambda x: x[1], reverse=True)\n\n    if narr:\n        narr = list(sorted([x for x in narr if x[1] == narr[0][1]], key=lambda x: x[0]))\n        print(narr[0][0])\n    else:\n        print(min(carr))\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nn,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nd={x:set() for x in set(l)}\n\nfor i in range(m) :\n    a,b=list(map(int,input().split()))\n    if l[a-1]!=l[b-1] :\n        d[l[a-1]].add(l[b-1])\n        d[l[b-1]].add(l[a-1])\n\nd=sorted(d,key=lambda x :(len(d[x]),-x))\n\nprint(d[-1])\n", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\ndef dfs(i):\n\tst=[i]\n\twhile st:\n\t\tx=st.pop()\n\t\tif vis[x]:continue\n\t\tvis[x]=1\n\t\tfor v in sorted(g[x]):\n\t\t\tif c[x-1]!=c[v-1]:d[c[x-1]].add(c[v-1])\n\t\t\tif not vis[v]:\n\t\t\t\tst.append(v)\n\nn,m=map(int,input().split())\nc=list(map(int,input().split()))\ng=[[] for i in range(n+1)]\nfor i in range(m):\n\tx,y=map(int,input().split())\n\tg[x].append(y)\n\tg[y].append(x)\nd=defaultdict(set)\nvis=[0]*(n+1)\nfor i in range(1,n+1):\n\tif vis[i] == 0:\n\t\tdfs(i)\nk=sorted(d.keys(),key=lambda i:(len(d[i]),-i))\nif not k:print(min(c))\nelse:print(k[-1])", "from collections import defaultdict\nl=lambda :map(int,input().split())\nn,m=l()\nc=list(l())\ngraph=defaultdict(set)\nfor i in range(m):\n    a,b=l()\n    if c[a-1]==c[b-1]:\n        continue\n    graph[c[a-1]].add(c[b-1])\n    graph[c[b - 1]].add(c[a - 1])\nd,f=min(c),0\nfor i in sorted(graph):\n    h=len(graph[i])\n    if h>f:\n        f=h\n        d=i\nprint(d)", "from collections import defaultdict\nl=lambda :map(int,input().split())\nn,m=l()\nc=list(l())\ngraph=defaultdict(set)\nfor i in range(m):\n    a,b=l()\n    if c[a-1]==c[b-1]:\n        continue\n    graph[c[a-1]].add(c[b-1])\n    graph[c[b - 1]].add(c[a - 1])\nd=sorted(graph,key=lambda x:(-len(graph[x]),x))\nprint(d[0] if d else min(c))"]
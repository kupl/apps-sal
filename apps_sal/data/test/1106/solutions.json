["def dfs(i):\n    if i >= 2 ** n:\n        return 0, 0\n    x1, m1 = dfs(i * 2)\n    x2, m2 = dfs(i * 2 + 1)\n    if m1 + a[i * 2] < m2 + a[i * 2 + 1]:\n        return x1 + x2 + m2 + a[i * 2 + 1] - m1 - a[i * 2], m2 + a[i * 2 + 1]\n    return x1 + x2 + m1 + a[i * 2] - m2 - a[i * 2 + 1], m1 + a[i * 2]\nn = int(input())\na = [0, 0] + [int(i) for i in input().split()]\nprint(dfs(1)[0])", "n = int(input())\nM = 2 ** (n + 1)\nA = [0, 0] + list(map(int, input().split()))\nAns = [0] * M\nans = 0\nfor i in range(2 ** n - 1, 0, -1):\n    left = i * 2\n    right = i * 2 + 1\n    m_l = A[left] + Ans[left]\n    m_r = A[right] + Ans[right]\n    Ans[i] = max(m_l, m_r)\n    ans += abs(m_l - m_r)\nprint(ans)\n\n", "def result(i):\n    nonlocal ans\n    temp = 0\n    if i < (1 << n):\n        temp = (result(2 * i), result(2 * i + 1))\n        ans += abs(temp[0] - temp[1])\n        temp = max(temp)\n    return lights[i] + temp\n\nn = int(input())\nlights = [0, 0] + list(map(int, input().split()))\nans = 0\nresult(1)\nprint(ans)\n", "def B():\n    s = 0\n    n = int(input())\n    k = (1 << (n + 1)) - 1\n    a = [0, 0] + list(map(int, input().split()))\n    for i in range(k, 1, -2):\n        u, v = a[i], a[i - 1]\n        if u > v: u, v = v, u\n        s += v - u\n        a[i >> 1] += v\n    return s\nprint(B())", "globCnt = 0\n\n\ndef rec(root):\n\tnonlocal globCnt, cnt\n\tif root - 1 >= len(cnt):\n\t\treturn 0\n\tl = rec(2 * root + 1)\n\tr = rec(2 * root + 2)\n\tif l != r:\n\t\tglobCnt += abs(l - r)\n\treturn max(l, r) + cnt[root - 1]\n\n\nn = int(input())\ncnt = list(map(int, input().split()))\n\nrec(0)\nprint(globCnt)", "n = int(input())\na = list(map(int, input().split()))\ndp = [0] * (2 ** (n + 1) - 1)\nfor i in range(2, 2 ** (n + 1)):\n    dp[i - 1] = dp[i // 2 - 1] + a[i - 2]\nmx = 0\nsm = 0\n# print(dp)\nx = [0] * (2 ** (n + 1) - 1)\nfor i in range(2 ** n):\n    mx = max(mx, dp[-i - 1])\n    sm += dp[-i - 1]\nfor i in range(2 ** n):\n    x[-i - 1] = mx - dp[-i - 1]\n# print(x)\ni = len(x) - 1\nwhile i >= 0:\n    mn = min(x[i], x[i - 1])\n    x[i] -= mn\n    x[i - 1] -= mn\n    x[(i + 1) // 2 - 1] += mn\n    i -= 2\nprint(sum(x))", "#!python3\nn = int(input())\na = input().split()\na = [int(i) for i in a]\n\ndef solve(n, a, added):\n\tlast = a[-2**n:]\n\tnew = []\n\n\tfor i in range(0, 2**n-1, 2):\n\t\t#print(last[i])\n\t\tx = last[i]\n\t\ty = last[i+1]\n\t\tnew.append(max(x,y))\n\t\tadded = added + abs(x-y)\n\n\ta = a[:-2**n]\n\n\tif a==[]:\n\t\ta = [0]\n\n\tfor i in range(1, 2**(n-1)+1):\n\t\ta[-i] = a[-i] + new[-i]\n\n\tn = n-1\n\tif n==0:\n\t\tprint(added)\n\telse:\n\t\tsolve(n, a, added)\n\nsolve(n, a, 0)", "n = int(input())\narr = list(map(int, input().split()))\nans = 0\nb = 2 ** (n + 1) - 3\nwhile n != 0:\n    n -= 1\n    #print(n)\n    p = 2 ** (n + 1) - 3\n    while b != p:\n        ans += abs(arr[b] - arr[b - 1])\n        arr[b // 2 - 1] += max(arr[b], arr[b - 1])\n        #print(arr)\n        b -= 2\nprint(ans)", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = 0\n    count = 0\n    for j in range(n, 0, -1):\n        for i in range(2**j-2, 2**(j+1)-2, 2):\n            d = max(a[i] , a[i+1])- min(a[i], a[i+1])\n            count += d\n            if i:\n                a[i//2-1] += max(a[i] , a[i+1])\n    print(count)\ndef __starting_point():\n    main()\n\n__starting_point()", "def get_lights_in_subtree(data, i):\n    total = 0\n\n    if i < len(data):\n        total += data[i]\n    else:\n        return 0\n\n    total += get_lights_in_subtree(data, 2 * i + 1)\n    total += get_lights_in_subtree(data, 2 * i + 2)\n\n    return total\n\n\ndef count_needed_lights(data, i):\n    if i >= len(data):\n        return 0, 0\n\n    l1 = count_needed_lights(data, 2 * i + 1)\n    l2 = count_needed_lights(data, 2 * i + 2)\n\n    #print(l1, l2, '----')\n\n    total = l1[0] + l2[0]\n    total += abs(l1[1] - l2[1])\n\n    return total, max(l1[1], l2[1]) + data[i]\n\n\ndef __starting_point():\n    n = int(input())\n    data = [0] + list(map(int, input().split()))\n    print(count_needed_lights(data, 0)[0])\n__starting_point()", "3\nn = 2**(int(input())+1)-1\nd = input().split(' ')\nfor i in range(len(d)):\n    d[i] = int(d[i])\np = 0\nfor i in range(len(d)-1, 0, -2):\n    p += abs(d[i]-d[i-1])\n    d[i//2-1] += max(d[i], d[i-1])\nprint(p)", "from itertools import product\nn = int(input())\na = list(map(int, input().split()))\nk = 1\ncnt = []\nfor i in product([0, 1], repeat = n):\n\tk = 1\n\tv = 0\n\tfor j in range(n):\n\t\tk = k*2 + i[j]\n\t\tif k - 2 < len(a):\n\t\t\tv += a[k - 2]\n\tcnt.append(v)\nmini = -1\nfor i in range(len(cnt)):\n\tif cnt[i] > mini:\n\t\tmini = cnt[i]\n\nans = 0\nfor i in range(1, n + 1):\n\tminicur = -1\n\tk = 0\n\tk1 = 2**(n-i)\n\tfor j in range(2**i):\n\t\tminicur = -1\n\t\tfor l in range(k, k1):\n\t\t\tif cnt[l] > minicur:\n\t\t\t\tminicur = cnt[l]\n\t\tfor l in range(k, k1):\n\t\t\tcnt[l] += (mini - minicur)\n\t\tans += mini - minicur\n\t\tk += 2**(n - i)\n\t\tk1 += 2**(n - i)\n\n\nprint(ans)\n\n", "n = int(input())\nai = list(map(int,input().split()))\nai = [0,0] + ai\ncnt = []\nans = 0\nwhile n >= 1:\n  for i in range(2 ** n,2 ** (n + 1),2):\n      ans += abs(ai[i] - ai[i + 1])\n      ai[i // 2] += max(ai[i],ai[i + 1])\n  n -= 1\nprint(ans)", "# fin = open(\"input.txt\")\n# n = int(fin.readline())\n# A = [0] + list(map(int, fin.readline().split()))\nn = int(input())\nA = [0] + list(map(int, input().split()))\nC = 0\nfor i in range(2 ** n - 2, -1, -1):\n\tC += abs(A[i * 2 + 1] - A[i * 2 + 2])\n\tA[i] += max(A[i * 2 + 1], A[i * 2 + 2])\nprint(C)\n", "n = int(input())\nm = (1 << (n + 1)) - 1\na = [0] + list(map(int, input().split()))\n\nmax_value = 0\n\ndef precalc(i, prev):\n    nonlocal max_value\n    if i < m:\n        a[i] += prev\n        if a[i] > max_value:\n            max_value = a[i]\n        precalc((i << 1) + 1, a[i])\n        precalc((i << 1) + 2, a[i])\n\ndef calc(i):\n    if i >= (1 << n) - 1:\n        return 0\n    x = (i << 1) + 1\n    y = (i << 1) + 2\n    result = calc(x) + calc(y)\n    a[i] = max(a[x], a[y])\n    return result + a[i] - min(a[x], a[y])\n\nprecalc(0, 0)\nprint(calc(0))\n", "# stop right here... don't try to read this code, is ugly and probably doesn't work\n\n\nfrom collections import deque\n\n\nn = int(input())\nligths = [0, 0] + [int(x) for x in input().split()]\n\nprefix_tree = [0 for _ in range(len(ligths))]\n\nq = deque()\nq.append(1)\nwhile len(q):\n    m = q.pop()\n    prefix_tree[m] = ligths[m] + prefix_tree[m//2]\n\n    if m*2+1 < len(ligths):\n        q.append(m*2)\n        q.append(m*2+1)\n\nneeded_lights = max(prefix_tree)\n\n\n\nsuffix_tree = [0 for _ in range(len(ligths))]\ndef pocitaj(i):\n    if i >= len(ligths):\n        return\n\n    pocitaj(i*2)\n    pocitaj(i*2+1)\n\n    if i >= len(ligths)//2:\n        suffix_tree[i] = ligths[i]\n    else:\n        suffix_tree[i] = max(suffix_tree[i*2], suffix_tree[i*2+1]) + ligths[i]\n\npocitaj(1)\nsuffix_tree += [needed_lights for _ in range(len(ligths))]\n\n\nclass Test:\n    def __init__(self):\n        self.ans = 0\n        self.vypocitaj(1)\n\n    def vypocitaj(self, i):\n\n        if suffix_tree[i*2] < suffix_tree[i*2+1]:\n            rozdiel = suffix_tree[i*2+1] - suffix_tree[i*2]\n            self.ans += rozdiel\n        else:\n            rozdiel = suffix_tree[i*2] - suffix_tree[i*2+1]\n            self.ans += rozdiel\n\n        if i*2+1 < len(ligths):\n            self.vypocitaj(i*2)\n            self.vypocitaj(i*2+1)\n\nans = Test()\nprint(ans.ans)", "from math import floor\n\ndef main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\t\n\tstreets = []\n\t\t\n\tfor i in range(2**n, 2**(n+1)):\n\t\t#print('---')\t\t\n\t\tidx = i\n\t\t#print(idx)\n\t\tif idx > 1:\n\t\t\t#print('Cost: %d' % a[idx-2])\n\t\t\tres = a[idx-2]\n\t\twhile idx > 0:\n\t\t\tidx = int(floor(idx/2))\n\t\t\tif idx > 1:\n\t\t\t\t#print(idx)\n\t\t\t\t#print('Cost: %d' % a[idx-2])\n\t\t\t\tres += a[idx-2]\n\t\t#print('res: %d' % res)\n\t\tstreets.append(res)\n\tres = 0\n\t#print(streets)\n\twhile len(streets) > 2:\n\t\tnew_streets = []\n\t\tfor i in range(0, len(streets), 2):\n\t\t\t#print('i: %d' % i)\n\t\t\tres += abs(streets[i]-streets[i+1])\n\t\t\tnew_streets.append(max(streets[i], streets[i+1]))\n\t\t#print(new_streets, cur_diff)\n\t\tstreets = new_streets\n\tprint(res+abs(streets[0]-streets[1]))\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "class Route:\n    def __init__(self):\n        self.lamps_count = 0\n        self.nodes = {}\n\n\ndef solve(n, lamps):\n    routes_count = 2**n\n    max_node_num = 2**(n+1) - 1\n    routes = [Route() for _ in range(routes_count)]\n\n    def dfs_pre(node, count=0):\n        if node >= routes_count:\n            route = routes[node - routes_count]\n            route.lamps_count = count\n            while node != 0:\n                route.nodes[node] = node\n                node //= 2\n        else:\n            dfs_pre(node*2, count+lamps[(node - 1)*2])\n            dfs_pre(node*2+1, count+lamps[(node - 1)*2 + 1])\n\n    def dfs_post(node):\n        if node > max_node_num:\n            return 0\n\n        diffs = []\n        for r in routes:\n            if node in r.nodes:\n                diffs.append(max_lamps_count - r.lamps_count)\n        diffs.sort()\n        if diffs and diffs[0]:\n            for r in routes:\n                if node in r.nodes:\n                    r.lamps_count += diffs[0]\n\n        return diffs[0] + dfs_post(node*2) + dfs_post(node*2+1)\n\n    dfs_pre(1)\n    max_lamps_count = sorted(routes, key=lambda r: -r.lamps_count)[0].lamps_count\n    res = dfs_post(1)\n\n    return res\n\n\ndef main():\n    n = int(input().strip())\n    lamps = list(map(int, input().strip().split()))\n    print(solve(n, lamps))\n\nmain()\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nm = len(a)\n\nsums = [0] * (m+1)\ncount = 0\n\na.insert(0, 0)\n\n#stack = [(0, 0)]\n#while stack:\n    #v, s = stack.pop(0)\n    #sums[v] = s\n    ##print(v+1, s)\n\n    #if 2*v+1 >= m:\n        ##sums.append(s)\n        #if s > count:\n            #count = s\n        #continue\n\n    #stack.append((2*v+1, s+a[2*v+1]))\n    #stack.append((2*v+2, s+a[2*v+2]))\n\n#print(sums, count)\n\nadd = 0\nfor i in range(m // 2 - 1, -1, -1):\n    m = max(a[2*i+1], a[2*i+2])\n    need_l = m - a[2*i+1]\n    need_r = m - a[2*i+2]\n    #print('at', i, 'l needs', need_l, 'r needs', need_r, 'setting i to', sums[i] + a[2*i+1] + need_l)\n    add += need_l + need_r\n    a[i] += a[2*i+1] + need_l\n\nprint(add)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# author: firolunis\n# version: 0.1\n\nn = int(input())\npark = input().split(' ')\npark = [int(i) for i in park]\npark.insert(0, 0)\nlights = [0 for i in range(2 ** (n + 1) - 1)]\nres = 0\nfor k in range(n, 0, -1):\n    for i, j in tuple(enumerate(park))[(2 ** k) - 1:2 ** (k + 1) - 1:2]:\n        res += abs(j + lights[i] - park[i + 1] - lights[i + 1])\n        lights[i // 2] = max(j + lights[i], park[i + 1] + lights[i + 1])\nprint(res)\n", "import sys, os\nimport fileinput\nn = int(input()) + 1\na = [int(x) for x in input().split()]\n\nall_count = 2 ** n - 1\nb = [0] * all_count\n\ncounter = 0\n\nfor i in range(n, 1, -1):\n\tlcnt =  2 ** (i - 1)\n\tfirst = 2 ** (i - 1) - 2 \n\t#print(lcnt, first)\n\tlevel = a[first:first + lcnt]\n\t# print(level)\n\n\tfor j in range(0, lcnt, 2):\n\t\tindex = first + 2 + j\n\n\t\tif i == n:\n\t\t\t# print(i)\n\t\t\t# print(\"-\" * 10)\n\t\t\tdiff = abs(level[j] - level[j + 1])\n\t\t\t# print(j, level[j], level[j+1], diff)\n\t\t\tcounter += diff\n\t\t\t# print(index//2 - 1, level[j] + level[j + 1] + diff)\n\n\t\t\tb[index//2 - 1] += level[j] + level[j + 1] + diff\n\t\t\t# print(\"=\" * 10)\n\t\telse:\n\t\t\t# print(i)\n\t\t\t# print(\"*\" * 10)\n\t\t\t# print(index)\n\t\t\t# print(b)\n\t\t\t# print(level)\n\t\t\tdiff = abs(abs(b[index - 1]//2 + level[j]) - abs(b[index]//2 + level[j + 1]))\n\t\t\tcounter += diff\n\t\t\tb[index//2 - 1] += b[index-1]//2 + b[index]//2 + level[j] + level[j + 1] + diff\n\t\t\t# print(\"+\" * 10)\n\nprint(counter)\n# print(b)\n", "n = int(input())\nV = 2 ** (n + 1) - 1\nlights = [0] * (V + 1)\nrem_lights = [0] * (V + 1)\nfor i,v in enumerate(input().split()):\n    lights[i + 2] = int(v)\nstack = [3,2]\nwhile(stack):\n    i = stack.pop()\n    rem_lights[i] = rem_lights[i // 2] + lights[i]\n    if (2 * i < V):\n        stack.append(2 * i + 1)\n        stack.append(2 * i)\nm = max(rem_lights)\n#print(\"max:\"+str(m))\n#print(rem_lights)\nfor i in range(2 ** n,2 ** (n + 1) - 1,2):\n        rem_lights[i] = m - rem_lights[i]\n        rem_lights[i + 1] = m - rem_lights[i + 1]\nwhile n:\n    for i in range(2 ** n,2 ** (n + 1) - 1,2):\n        small = min(rem_lights[i],rem_lights[i + 1])\n        rem_lights[i // 2] = small\n        rem_lights[i] -= small\n        rem_lights[i + 1] -= small\n    n-=1\n#print(rem_lights)\nprint(sum(rem_lights))", "n = 2**(int(input())+1)-1;\na = [0,0] + list(map(int,input().split()))\nr = 0\nwhile n>1:\n  a[n//2] += max(a[n], a[n-1])\n  r += abs(a[n]-a[n-1])\n  n -= 2\nprint(r)\n", "import fileinput\n\ndef parent_id(elem_id):\n    return int(elem_id / 2)\n\ndef children_ids(elem_id):\n    return elem_id * 2, elem_id * 2 + 1\n\ndef solve(lights):\n    def solve_subtree(root_id):\n        a, b = children_ids(root_id)\n        if a >= len(lights):\n            # print(root_id, \"is leaf and has\", lights[root_id], \"lights\")\n            return (0, lights[root_id])\n        else:\n            needed_a, val_a = solve_subtree(a)\n            needed_b, val_b = solve_subtree(b)\n            max_val = max(val_b, val_a)\n            # print(root_id, \"has\", val_a, \"and\", val_b, \"in subtrees, totally needs\",\n            #     (needed_a + needed_b + (2 * max_val - (val_a + val_b))), \"lights\")\n            return (needed_a + needed_b + (2 * max_val - (val_a + val_b)),\n                    max_val + lights[root_id])\n    needed, val = solve_subtree(1)\n    return needed\n\ndef __starting_point():\n    data = list(iter(fileinput.input()))\n    lights = [0, 0] + list(map(int, data[1].split()))\n    print(solve(lights))\n__starting_point()"]
["\ndef __starting_point():\n\tn, m, t = map(int, input().split())\n\tedge = {i:{} for i in range(n)}\n\tincome = [0 for i in range(n)]\n\tfor i in range(m):\n\t\tu, v, ti = map(int, input().split())\n\t\tedge[v-1][u-1] = ti\n\t\tincome[u-1] += 1\n\tstat = [{} for _ in range(n)]\n\tstat[n-1] = {1 : (0, -1)}\n\tqueue = [n-1]\n\tfirst = 0\n\tlast = 1\n\tfor i in range(n-2, 0, -1):\n\t\tif income[i] == 0:\n\t\t\tqueue.append(i)\n\t\t\tlast += 1\n\twhile (first < last):\n\t\tv = queue[first]\n\t\tfirst += 1\n\t\tfor u in edge[v].keys():\n\t\t\tincome[u] -= 1\n\t\t\tfor vis in stat[v].keys():\n\t\t\t\tcost = stat[v][vis][0] + edge[v][u]\n\t\t\t\tucost = stat[u].get(vis+1, (t+1,-1))[0]\n\t\t\t\tif ucost > cost:\n\t\t\t\t\tstat[u][vis+1] = (cost, v)\n\t\t\tif income[u] <= 0:\n\t\t\t\tqueue.append(u)\n\t\t\t\tlast += 1\n\t#print(queue, last)\n\tres = max(stat[0].keys())\n\tprint(res)\n\tpath = []\n\tcurr = 0\n\tpath.append(curr+1)\n\twhile(stat[curr][res][1] >= 0):\n\t\tcurr = stat[curr][res][1]\n\t\tpath.append(curr+1)\n\t\tres -= 1\n\tprint(' '.join(map(str, path)))\n__starting_point()", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/20/20\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\ndef solve(N, M, T, edges):\n    g = collections.defaultdict(list)\n    for u, v, t in edges:\n        g[u].append((v, t))\n    \n    dp = [[T+1 for _ in range(N+1)] for _ in range(N + 1)]\n    pre = [[0 for _ in range(N+1)] for _ in range(N + 1)]\n    dp[1][1] = 0\n    pre[1][1] = 0\n    # q = [(0, 0, -1, 1)]\n    # heapq.heapify(q)\n    # while q:\n    #     _, pcost, pdist, pcity = heapq.heappop(q)\n    #     pdist = -pdist\n    #     if pcost > dp[pcity][pdist]:\n    #         continue\n    #     for dest, ncost in g[pcity]:\n    #         cost = pcost + ncost\n    #         dist = pdist + 1\n    #         if cost <= T and dp[dest][dist] > cost:\n    #             dp[dest][dist] = cost\n    #             pre[dest][dist] = pcity\n    #             heapq.heappush(q, (cost/dist, cost, -dist, dest))\n    \n    q = [(1, 1, 0)]\n    while q:\n        nq = []\n        for city, dist, pcost in q:\n            dist += 1\n            for dest, ncost in g[city]:\n                cost = pcost + ncost\n                if cost <= T and dp[dest][dist] > cost:\n                    dp[dest][dist] = cost\n                    pre[dest][dist] = city\n                    nq.append((dest, dist, cost))\n        q = nq\n    \n    # print(dp[N])\n    ans = max([i for i in range(N, -1, -1) if dp[N][i] <= T])\n    print(ans)\n    \n    path = []\n    k = N\n    l = ans\n    while k:\n        path.append(k)\n        k = pre[k][l]\n        l -= 1\n    \n    print(' '.join(map(str, path[::-1])))\n\n\nN, M, T = map(int, input().split())\nedges = []\nfor i in range(M):\n    u, v, t = map(int, input().split())\n    edges.append((u, v, t))\n\nsolve(N, M, T, edges)", "n, m, T = map(int, input().split())\nadj = [[] for _ in range(n+1)]\nad_w = [[] for _ in range(n+1)]\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\npv = [[0 for _ in range(n+1)] for _ in range(n+1)]\n \nfor i in range(m):\n    a, b, t = map(int, input().split())\n    # matrix[b][a] = t\n    adj[b].append(a)\n    ad_w[b].append(t)\n    if a == 1:\n        dp[b][2] = t\n        pv[b][2] = 1\n    # matrix[a][b] = t\n \nfor c in range(3, n + 1):\n    for v in range(2, n + 1):\n        for i, nx in enumerate(adj[v]):\n            if dp[nx][c-1]:\n                newdistance = dp[nx][c-1] + ad_w[v][i]\n                if newdistance <= T and (not dp[v][c] or newdistance < dp[v][c]):\n                    dp[v][c] = newdistance\n                    pv[v][c] = nx\n \n \nfor last in range(n,0,-1):\n    if pv[n][last]:\n        break\n     \n\npath = [n]\nwhile pv[path[-1]][last] != 1:\n    path.append(pv[path[-1]][last])\n    last -= 1\n \npath.append(1)\npath.reverse()\n \nprint(len(path))\nprint(' '.join(map(str, path)))"]
["from heapq import heappush, heappop\nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(N):\n    if A[i] < 0:\n        k = i\n        break\nA = [0] + [0 if i < k else A[i] for i in range(N) if i != k]\n\nans = A.pop()\nH = []\nwhile N > 2:\n    N //= 2\n    for i in range(N):\n        heappush(H, A.pop())\n    ans += heappop(H)\n\nprint(ans)\n\n\n", "import sys\nfrom heapq import heappop, heappush\nfrom math import log2\n\n\n# inf = open('input.txt', 'r')\n# reader = (map(int, line.split()) for line in inf)\nreader = (list(map(int, s.split())) for s in sys.stdin)\n\ndef bribe(n, a):\n    if a[-1] < 0:\n        return 0\n    \n    fr = a.index(-1)\n    a[fr] = float('inf')\n    h = int(log2(n))\n    k = int(log2(fr + 1))\n    total = a[-1]\n    hq = []\n    for r in range(h - 1, k, -1):\n        [heappush(hq, a[i]) for i in range(2 ** r - 1, 2 ** (r + 1) - 1)];\n        opponent = heappop(hq)\n        total += opponent\n    return total\n\nn, = next(reader)\na = list(next(reader))\nans = bribe(n, a)\nprint(ans)\n    \n# inf.close()\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nx=A.index(-1)\nfor i in range(x+1):\n    A[i]=0\nB=list(reversed(A))\nimport heapq\nH=[]\n\nANS=0\nLIST=[0]+[n-(1<<i)+1 for i in range(n.bit_length()-1,0,-1)]\nfor i in range(1,n.bit_length()):\n    for j in range(LIST[i-1],LIST[i]):\n        heapq.heappush(H,B[j])\n\n    #print(H)\n\n    x=heapq.heappop(H)\n    ANS+=x\n\nprint(ANS)\n        \n        \n    \n", "from heapq import *\n\nn = int(input())\n\na = list(map(int, input().split()))\ndone = a.index(-1)\n\nheap = []\n\ncost = 0\nx = n//2\nposition = n-1\nwhile position > done:\n    highest = a[position]\n    he = min(heap) if heap else 10**10\n    \n    if highest < he:\n        cost += highest\n        for val in a[position-1:position-x:-1]:\n            heappush(heap, val)\n        position -= x\n    else:\n        cost += he\n        heappop(heap)\n        for val in a[position:position-x:-1]:\n            heappush(heap, val)\n        position -= x\n    x //= 2\n    \nprint(cost)\n", "from sys import stdin\n\ninput = stdin.readline\n\nn = int(input())\n\na = list(map(int, input().split()))\na.reverse()\n\ninf = float('inf')\nN = 19\ndp = [[inf] * (N+2) for _ in range(1 << N)]\n\nsum = [0] * (1 << 21)\nnow = n\nfor i in range(1, 20):\n    sum[i] = sum[i-1] + now // 2\n    now //= 2\n\n\nfor i in range(n)[::-1]:\n    for j in range(N):\n        if a[i] == -1:\n            dp[i][j] = 0\n            continue\n\n        if i > sum[j]:\n            continue\n        dp[i][j] = dp[i + 1][j + 1] + a[i]\n        if i < sum[j]:\n            dp[i][j] = min(dp[i][j], dp[i + 1][j])\n        # print(i, j, dp[i][j])\n\nprint(dp[0][0])", "import math\nimport sys\nfrom sys import stdin, stdout\n\n#sys.setrecursionlimit(300000)\n# print(sys.getrecursionlimit())\n\n# dp O(NlogN)\ndef getMinimunCost(a, sum, i, j, dp):\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if a[j] == -1:\n        return 0\n\n    remaining = sum[i] - j\n\n    res = -2\n    if i < len(dp)-1:\n        min1 = getMinimunCost(a, sum, i+1, j+1, dp)\n        if min1 != -2:\n            res = min1 + a[j]\n\n    if remaining > 0:\n        min2 = getMinimunCost(a, sum, i, j+1, dp)\n        if res == -2:\n            res = min2\n        elif min2 != -2:\n            res = min(res, min2)\n\n    dp[i][j] = res\n    return dp[i][j]\n\ndef getMinimunCost2(a, sum, dp):\n\n    if a[0] == -1:\n        for j in range(0, len(dp[0])):\n            dp[0][j] = 0\n    else:\n        for j in range(0, len(dp[0])):\n            dp[0][j] = a[0]\n\n    for i in range(1, len(dp)):\n        for j in range(1, len(dp[i])):\n            if j <= sum[i]:\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1])\n                    if i > 0:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + a[j])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][j-1])\n                #break;\n\n    #for i in range(len(dp)):\n    #    print(dp[i])\n\n    #print(a)\n\n    return dp[-1][-1]\n\n\ndef __starting_point():\n    try:\n        n = int(stdin.readline())\n        a = [int(i) for i in stdin.readline().split()]\n\n        bcnt = int(math.log(n, 2))\n\n        sum = []\n        sum.append(0)\n\n        x = int(n/2)\n        for i in range(1, bcnt+1):\n            sum.append(sum[i-1] + x)\n            x = int(x/2)\n\n        #dp = [[-1 for i in range(n)] for i in range(bcnt + 1)]\n        dp = [[float(\"inf\") for i in range(n)] for i in range(bcnt + 1)]\n\n        #print(sum)\n        #print(str(dp[0][0] + 1))\n\n        #set 0\n        flag = True\n        for i in range(len(a)):\n            if a[i] == -1:\n                flag = False\n                a[i] = 0\n            if flag:\n                a[i] = 0\n\n        a.reverse()\n        #res = getMinimunCost(a, sum, 0, 0, dp)\n        res = getMinimunCost2(a, sum, dp)\n\n        stdout.write(str(res))\n    except BaseException as e:\n        print(str(e))\n\n__starting_point()", "from heapq import heappush, heappop\nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(N):\n    if A[i] < 0:\n        k = i\n        break\nA = [0] + [0 if i < k else A[i] for i in range(N) if i != k]\n \nans = A.pop()\nH = []\nwhile N > 2:\n    N //= 2\n    for i in range(N):\n        heappush(H, A.pop())\n    ans += heappop(H)\n \nprint(ans)\n \n", "from heapq import heappush, heappop\nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(N):\n    if A[i] < 0:\n        k = i\n        break\nA = [0] + [0 if i < k else A[i] for i in range(N) if i != k]\n \nans = A.pop()\nH = []\nwhile N > 2:\n    N //= 2\n    for i in range(N):\n        heappush(H, A.pop())\n    ans += heappop(H)\n \nprint(ans)\n \n", "from math import log2, floor\n\ndef is_power2(num):\n    return num != 0 and ((num & (num - 1)) == 0)\n\n\ndef next_two_pow(val):\n    pw=0\n    while 2**pw <= val:\n        pw=+1\n    return pw        \n\nn = int(input())\narr=[int(x) for x in input().split()]\n\n\nwin_idx =-1\nselected=[]\n\nfor i in range(1,n+1):\n    val = arr[i-1]\n    if win_idx ==-1:\n       if  val == -1: \n           win_idx =i\n    else:\n         if is_power2(i):\n             selected.append(val)\n             selected.sort()\n         else:\n             if len(selected) > 0 and val < selected[-1]:\n                 selected.pop()\n                 selected.append(val)\n                 selected.sort()\n\nprint(sum(selected))\n\n\n# if arr[n-1] ==-1:\n#     print(0)\n# else:\n#     win_idx =-1\n#     for i in range(0,n):\n#         if arr[i] == -1:\n#             win_idx =i\n#             break\n# \n#     crt_pow=int(floor(log2(n)))\n#     stop_pow=next_two_pow(win_idx)\n#     total=0\n#     taken= set()\n#     while crt_pow > stop_pow:\n#         two_p = 2**crt_pow\n#         mn = 10**9 + 1\n#         mn_idx = -1\n#         for i in range(two_p - 1, n):\n#             if i!=win_idx and i not in taken and  arr[i] < mn:\n#                 mn =arr[i]\n#                 mn_idx=i\n#         crt_pow -=1        \n#         taken.add(mn_idx)\n#         total+=mn\n#     print(total)    \n", "from math import log2, floor\n\ndef is_power2(num):\n    return num != 0 and ((num & (num - 1)) == 0)\n\n\ndef next_two_pow(val):\n    pw=0\n    while 2**pw <= val:\n        pw=+1\n    return pw        \n\nn = int(input())\narr=[int(x) for x in input().split()]\n\n\nwin_idx =-1\nselected=[]\n\nfor i in range(1,n+1):\n    val = arr[i-1]\n    if win_idx ==-1:\n       if  val == -1: \n           win_idx =i\n    else:\n         if is_power2(i):\n             selected.append(val)\n             selected.sort()\n         else:\n             if len(selected) > 0 and val < selected[-1]:\n                 selected.pop()\n                 selected.append(val)\n                 selected.sort()\n\nprint(sum(selected))\n\n\n# if arr[n-1] ==-1:\n#     print(0)\n# else:\n#     win_idx =-1\n#     for i in range(0,n):\n#         if arr[i] == -1:\n#             win_idx =i\n#             break\n# \n#     crt_pow=int(floor(log2(n)))\n#     stop_pow=next_two_pow(win_idx)\n#     total=0\n#     taken= set()\n#     while crt_pow > stop_pow:\n#         two_p = 2**crt_pow\n#         mn = 10**9 + 1\n#         mn_idx = -1\n#         for i in range(two_p - 1, n):\n#             if i!=win_idx and i not in taken and  arr[i] < mn:\n#                 mn =arr[i]\n#                 mn_idx=i\n#         crt_pow -=1        \n#         taken.add(mn_idx)\n#         total+=mn\n#     print(total)    \n", "def main():\n    import sys\n    from operator import itemgetter\n    input = sys.stdin.readline\n\n    N = int(input())\n    K = N.bit_length() - 1\n    A_raw = list(map(int, input().split()))\n\n    flg = 1\n    A = []\n    for i, a in enumerate(A_raw):\n        if flg:\n            if a == -1:\n                flg = 0\n            else:\n                A.append(0)\n        else:\n            A.append(A_raw[i])\n    inf = 1<<40\n    dp = [[inf] * (K+1) for _ in range(N)]\n    dp[0][0] = 0\n    for i in range(N):\n        for j in range(K+1):\n            if dp[i][j] < inf:\n                if j < K:\n                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + A[N-2-i])\n                if N - 2**(K-j) > i:\n                    dp[i+1][j] = min(dp[i+1][j], dp[i][j])\n    print(dp[-1][-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\nme = a.index(-1)\nif me == n - 1:\n    print(0)\n    return\nfor i in range(me + 1):\n    a[i] = 0\ndp = [[0] * n for _ in range(2)]\nopt = [[0] * n for _ in range(2)]\ndp[1][n - 1] = a[n - 1]\nif n - 1 <= me + 1:\n    ans = a[n - 1]\nfor i in range(2, 22):\n    if 2 ** i > n:\n        break\n    s = i & 1\n    t = s ^ 1\n    l, r = n // 2 ** (i - 1) - 1, n - i + 1\n    pl, pr = n // 2 ** (i - 2) - 1, n - i + 2\n    opt[s][pr - 1] = dp[t][pr - 1]\n    for j in range(pr - 2, pl - 1, -1):\n        opt[s][j] = min(opt[s][j + 1], dp[t][j])\n    for j in range(pl - 1, l - 1, -1):\n        opt[s][j] = opt[s][j + 1]\n    for j in range(r - 1, l - 1, -1):\n        dp[s][j] = opt[s][j + 1] + a[j]\n    if l <= me + 1:\n        ans = min(dp[s][l:r])\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport heapq as hq\nn = int(input())\na = list(map(int,input().split()))\nfrn = a.index(-1)+1\nt = n.bit_length()\nif frn == n:\n  print(0)\n  return\nans = a[n-1]\nx = (frn-1).bit_length()\nq = []\nhq.heapify(q)\nfor i in range(1,t)[::-1]:\n  for j in range(2**(i-1)-1,2**i-1):\n    hq.heappush(q,a[j])\n  y = hq.heappop(q)\n  if y >= 0:\n    ans += y\n  else:\n    break\nprint(ans)", "import heapq\n \npop=heapq.heappop\npush=heapq.heappush\n \nn=int(input())\na=list(map(int, input().split()))\n \nans=0\npos=-1\n \nfor i, x in enumerate(a):\n    if x==-1:\n        pos=i\n        break\n        \nif pos==n-1:\n    print(0)\nelse:\n    ans += a[n-1]\n    cur  = n-2\n    \n    used      = [0] * n \n    used[pos] = 1\n    used[n-1] = 1\n    \n    Q=[]\n    i=n//2\n    \n    \n    while i>=2:\n        for _ in range(i):\n            while used[cur]==1:\n                cur-=1\n            \n            val=0 if cur < pos else a[cur]\n            push(Q, (val, cur))\n            cur-=1\n            \n        while True:\n            x, p = pop(Q)\n            \n            if used[p]==0:\n                break\n                \n        used[p]=1\n        #print(p, a[p])    \n        if p > pos:\n            ans+=a[p]\n        i//=2        \n        \n    print(ans)       "]
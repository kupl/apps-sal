["import sys\nn=0;\ninp=[];\ntree=[];#stores the index of min in range(i,j)\n\ndef build(node,i,j):\n    if(i>j):\n        return;\n    if(i==j):\n        tree[node]=int(i);\n        return;\n    mid=int( (i+j)/2 );\n\n    build(2*node,i,mid)\n    build(2*node+1,mid+1,j)\n    if( inp[ tree[2*node] ] < inp[ tree[2*node+1] ] ):\n        tree[node]= tree[2*node];\n    else:\n        tree[node]=tree[2*node+1]\n\ndef RMQ(node,i,j,l,r):#return  index of minimum in range i,j #r,l is current range\n    if( (i<=l) and (r<=j) ):\n        return tree[node];\n\n    if( (i>r) or (j<l) ):\n        return n;\n\n    mid=int((l+r)/2);\n\n    a=RMQ(2*node,   i, j, l ,    mid);#     j,l,mid);\n    b=RMQ(2*node+1, i, j, mid+1, r);\n\n    if( inp[a] < inp[b]):\n        return a;\n    else:\n        return b;\n\ndef inputArray():\n    A=str(input()).split();\n    return list(map(int,A));\n\n\ndef solve(a,b,ht):\n    if(a>b):\n        return 0;\n    mn=RMQ(1,a,b,0,n-1);\n    op1=b-a+1\n    op2=solve(a,mn-1 , inp[mn] ) + solve(mn+1,b, inp[mn] ) + inp[mn]-ht ;\n    return min(op1,op2);\n\n\nif( __name__ == \"__main__\"):\n    n=int( input() );\n    inp=inputArray();\n    inp.append(1000*1000*1000+10);\n    \n    sys.setrecursionlimit(10000)\n    #build RMQ array\n    tree=[ int(n) for x in range(4*n+10) ];\n    build(1,0,n-1);\n\n    print(( solve(0,n-1,0) ));\n", "import sys\nn=0;\ninp=[];\ntree=[];#stores the index of min in range(i,j)\n\ndef build(node,i,j):\n    if(i>j):\n        return;\n    if(i==j):\n        tree[node]=int(i);\n        return;\n    mid=int( (i+j)/2 );\n\n    build(2*node,i,mid)\n    build(2*node+1,mid+1,j)\n    if( inp[ tree[2*node] ] < inp[ tree[2*node+1] ] ):\n        tree[node]= tree[2*node];\n    else:\n        tree[node]=tree[2*node+1]\n\ndef RMQ(node,i,j,l,r):#return  index of minimum in range i,j #r,l is current range\n    if( (i<=l) and (r<=j) ):\n        return tree[node];\n\n    if( (i>r) or (j<l) ):\n        return n;\n\n    mid=int((l+r)/2);\n\n    a=RMQ(2*node,   i, j, l ,    mid);#     j,l,mid);\n    b=RMQ(2*node+1, i, j, mid+1, r);\n\n    if( inp[a] < inp[b]):\n        return a;\n    else:\n        return b;\n\ndef inputArray():\n    A=str(input()).split();\n    return list(map(int,A));\n\n\ndef solve(a,b,ht):\n    if(a>b):\n        return 0;\n    mn=RMQ(1,a,b,0,n-1);\n    op1=b-a+1\n    op2=solve(a,mn-1 , inp[mn] ) + solve(mn+1,b, inp[mn] ) + inp[mn]-ht ;\n    return min(op1,op2);\n\n\nif( __name__ == \"__main__\"):\n    n=int( input() );\n    inp=inputArray();\n    inp.append(1000*1000*1000+10);\n    \n    sys.setrecursionlimit(10000)\n    #build RMQ array\n    tree=[ int(n) for x in range(4*n+10) ];\n    build(1,0,n-1);\n\n    print( solve(0,n-1,0) );", "import sys\nsys.setrecursionlimit(10000)\n\ns, n = 1, int(input())\nt = [(q, i) for i, q in enumerate(map(int, input().split()))]\n\ne = (2e9, 0)\nwhile s < n: s <<= 1\nh = [e] * s + t + [e] * (s - n)\n\nk = s - 1\nwhile k:\n    j = k << 1\n    h[k] = min(h[j], h[j + 1])\n    k -= 1\n\ndef f(a, l, r):\n    if r - l < 1: return 0\n    if r - l < 2: return int(t[l][0] != a)\n    p, q = [(s, l, r)], e\n    while p:\n        k, u, v = p.pop()\n        if u < v:\n            if u & 1:\n                q = min(q, h[k + u])\n                u += 1\n            if v & 1:\n                q = min(q, h[k + v - 1])\n            p.append((k >> 1, u >> 1, v >> 1))\n    b, m = q\n    d, n = b - a, r - l\n    return min(n, d + f(b, l, m) + f(b, m + 1, r)) if d < n else n\n\nprint(f(0, 0, n))", "import sys\n\nn=0;\n\ninp=[];\n\ntree=[];#stores the index of min in range(i,j)\n\n\n\ndef build(node,i,j):\n\n    if(i>j):\n\n        return;\n\n    if(i==j):\n\n        tree[node]=int(i);\n\n        return;\n\n    mid=int( (i+j)/2 );\n\n\n\n    build(2*node,i,mid)\n\n    build(2*node+1,mid+1,j)\n\n    if( inp[ tree[2*node] ] < inp[ tree[2*node+1] ] ):\n\n        tree[node]= tree[2*node];\n\n    else:\n\n        tree[node]=tree[2*node+1]\n\n\n\ndef RMQ(node,i,j,l,r):#return  index of minimum in range i,j #r,l is current range\n\n    if( (i<=l) and (r<=j) ):\n\n        return tree[node];\n\n\n\n    if( (i>r) or (j<l) ):\n\n        return n;\n\n\n\n    mid=int((l+r)/2);\n\n\n\n    a=RMQ(2*node,   i, j, l ,    mid);#     j,l,mid);\n\n    b=RMQ(2*node+1, i, j, mid+1, r);\n\n\n\n    if( inp[a] < inp[b]):\n\n        return a;\n\n    else:\n\n        return b;\n\n\n\ndef inputArray():\n\n    A=str(input()).split();\n\n    return list(map(int,A));\n\n\n\n\n\ndef solve(a,b,ht):\n\n    if(a>b):\n\n        return 0;\n\n    mn=RMQ(1,a,b,0,n-1);\n\n    op1=b-a+1\n\n    op2=solve(a,mn-1 , inp[mn] ) + solve(mn+1,b, inp[mn] ) + inp[mn]-ht ;\n\n    return min(op1,op2);\n\n\n\n\n\nif( __name__ == \"__main__\"):\n\n    n=int( input() );\n\n    inp=inputArray();\n\n    inp.append(1000*1000*1000+10);\n\n    \n\n    sys.setrecursionlimit(10000)\n\n    #build RMQ array\n\n    tree=[ int(n) for x in range(4*n+10) ];\n\n    build(1,0,n-1);\n\n\n\n    print(( solve(0,n-1,0) ));\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\na = list(map(int, input().split()))\n\n# 3 3 1 2 1\n# -> [2, 2], [1]\n\ndef painting(left, right, arr, height):\n  # find min:\n  if left >= right:\n    return 0\n  \n  min_height = min(arr[left:right])\n  split = left + arr[left:right].index(min_height)\n\n  count_horizontal = min_height - height\n  count_vertical = right - left\n\n  return min(count_vertical, \n  count_horizontal + painting(left, split, arr, min_height) + painting(split + 1, right, arr, min_height))\n  \nprint(painting(0, len(a), a, 0))\n", "import sys\nsys.setrecursionlimit(10000)\n\n\ndef painting_fence(fence, cut):\n\tn = len(fence)\n\tif n == 0: return 0\n\tmin_i = fence.index(min(fence))\n\tmin_h = fence[min_i]\n\tans = min_h-cut+painting_fence(fence[:min_i], min_h)+painting_fence(fence[min_i + 1:], min_h)\n\treturn min(ans, n)\n\ndef main():\n\t_ = int(input())\n\tfence = list(map(int, input().split()))\n\tprint(painting_fence(fence, 0))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\noo=1000000000000\nar=[]\ndef solve(l, r, val):\n\tif(r<l): return 0\n\tindx=l+ar[l:r+1].index(min(ar[l:r+1]))\n\ttot=r-l+1\n\tcur=ar[indx]-val+solve(l, indx-1, ar[indx])+solve(indx+1, r, ar[indx])\n\treturn min(tot, cur)\nsys.setrecursionlimit(10000)\nn=int(input())\nar=list(map(int, input().split()))\nprint(solve(0, n-1, 0))", "import sys\nsys.setrecursionlimit(10**6)\n \nn = int(input())\na = list(map(int, input().split()))\n \n# 3 3 1 2 1\n# -> [2, 2], [1]\n \ndef painting(left, right, arr, height):\n  # find min:\n  if left >= right:\n    return 0\n  \n  min_height = min(arr[left:right])\n  split = left + arr[left:right].index(min_height)\n \n  count_horizontal = min_height - height\n  count_vertical = right - left\n \n  return min(count_vertical, \n  count_horizontal + painting(left, split, arr, min_height) + painting(split + 1, right, arr, min_height))\n  \nprint(painting(0, len(a), a, 0))\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/8 19:48\n\n\"\"\"\n\n\ndef solve(A, left, right):\n    s = [(left, right, 0)]\n    memo = {}\n    while s:\n        l, r, ph = s.pop()\n        h = min(A[l: r+1])\n        n = r - l + 1\n        if h - ph >= n:\n            memo[(l, r)] = n\n            continue\n\n        i, j = l, l\n        t = []\n        while j <= r:\n            if A[j] == h:\n                if i < j:\n                    t.append((i, j - 1, h))\n                i = j + 1\n            j += 1\n        if i <= r:\n            t.append((i, r, h))\n\n        if any([(v[0], v[1]) not in memo for v in t]):\n            s.append((l, r, ph))\n            s.extend(t)\n        else:\n            memo[(l, r)] = min(n, h - ph + sum([memo[(v[0], v[1])] for v in t] or [0]))\n\n    return memo[left, right]\n\n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(solve(A, 0, N-1))\n", "import sys\n\nsys.setrecursionlimit(1000000)\nn = int(input())\nA = list(map(int, input().split()))\n\ndef Analyze(left, right, counted_height):\n    if left >= right:\n        return 0\n    min_height = min(A[left:right])\n    equinox = left + A[left:right].index(min_height)\n    count_isHorizontal = min_height - counted_height\n    count_isVertical = right - left\n    return min(count_isVertical, \n    count_isHorizontal + Analyze(left, equinox, min_height) + Analyze(equinox+1, right, min_height))\n\nprint(Analyze(0, n, 0))\n\n", "n = int(input())\nt = [int(x) for x in input().split()]\nt.insert(0, -1)\n\ndp = [0] * (n+3)\ndp[1] = t[1]\n\nfor i in range(2, n+1):\n\t#albo wszystkie na lewo sa pionowe\n\tdp[i] = t[i] + (i-1)\n\t#albo na lewo jest jakis poziomy\n\tsmallest = t[i] #najmniejszy napotkany\n\tfor j in range(i-1, 0, -1):\n\t\t#zakladam ze j jest ostatnim poziomym\n\t\tsmallest = min(smallest, t[j])\n\t\ttmp = (dp[j] + (i-j-1) + (t[i] - smallest))\n\t\tdp[i] = min(dp[i], tmp)\n\nres = n #kiedy wszystkie sa pionowe\nfor i in range(1, n+1):\n\t#i-ty jest ostanim poziomym\n\tres = min(res, dp[i] + (n-i))\nprint(res) \n", "from sys import setrecursionlimit\nimport threading\n\n\ndef main():\n    n = int(input())\n\n    a = [int(x) for x in input().split()]\n    if a[0] < a[-1]:\n        a = a[::-1]\n    mem = [{} for x in range(n)]\n\n    def strokes(ind,height):\n        if ind >= n:\n            return 0\n        if height in mem[ind]:\n            return mem[ind][height]\n        if height >= a[ind]:\n            mem[ind][height] = strokes(ind+1,a[ind])\n            return mem[ind][height]\n        else:\n            one = strokes(ind+1,height)+1\n            two = strokes(ind+1,a[ind]) + a[ind]-height\n            mem[ind][height] = min(one,two)\n            return mem[ind][height]\n\n    print(strokes(0,0))\n    \nsetrecursionlimit(10000)\nthreading.stack_size(10**8)\nt = threading.Thread(target=main)\nt.start()\nt.join()\n", "n = int(input()) + 1\nl = list(map(int, input().split())) + [0]\nout = 0\n\nq = []\nfor v in l:\n    if v == 0:\n        dp = []\n        n = len(q)\n        for i in range(n):\n            curr = q[i] + i\n            smol = q[i]\n            for j in range(i - 1, -1, -1):\n                smol = min(q[j], smol)\n                diff = q[i] - smol\n                curr = min(curr, diff + dp[j] + i - j - 1)\n            dp.append(curr)\n                \n        real = [n - i + dp[i] - 1 for i in range(n)] + [n]\n        out += min(real)\n        q = []\n    else:\n        q.append(v)\nprint(out)\n", "n = int(input()) + 1\nl = list(map(int, input().split())) + [0]\nout = 0\n\nq = []\nfor v in l:\n    if v == 0:\n        dp = []\n        n = len(q)\n        for i in range(n):\n            curr = q[i] + i\n            smol = q[i]\n            for j in range(i - 1, -1, -1):\n                smol = min(q[j], smol)\n                diff = q[i] - smol\n                curr = min(curr, diff + dp[j] + i - j - 1)\n            dp.append(curr)\n                \n        real = [n - i + dp[i] - 1 for i in range(n)] + [n]\n        out += min(real)\n        q = []\n    else:\n        q.append(v)\nprint(out)\n", "import sys\nimport threading\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nthreading.stack_size(16*2048*2048)\nn=int(input())\na=[int(i) for i in input().split() if i!='\\n']\na.insert(0,0)\na.append(0)\ndef solve(l,r):\n    if l>r:\n        return(0)\n    #\"outside\" is the minimum number obtained in the previous iteration\n    #which we have to subtract from all the elements in this segment\n    outside=max(a[l-1],a[r+1])\n    mina=min(a[l:r+1])\n    min_index=a.index(mina,l,r+1)\n    return(min(r-l+1,solve(l,min_index-1)+solve(min_index+1,r)+mina-outside))\nans=solve(1,n)\nsys.stdout.write(str(ans)+'\\n')\n", "from sys import stdin\nimport sys\ng   = lambda : stdin.readline().strip()\ngl  = lambda : g().split()\ngil = lambda : [int(var) for var in gl()]\ngfl = lambda : [float(var) for var in gl()]\ngcl = lambda : list(g())\ngbs = lambda : [int(var) for var in g()]\nmod = int(1e9)+7\ninf = float(\"inf\")\n\nfrom sys import setrecursionlimit\nimport threading\n\ndef main():\n\tn, = gil()\n\ta = gil()\n\n\tdef fun(a):\n\t\tans = 0\n\t\tn = len(a)\n\t\toff = min(a) \n\t\tfor i in range(n):\n\t\t\ta[i] -= off\n\t\tans += off\n\t\t# print(a, off)\n\t\tbuff = []\n\t\twhile a :\n\t\t\tif a[-1]:\n\t\t\t\tbuff.append(a.pop())\n\t\t\telse:\n\t\t\t\ta.pop()\n\t\t\t\tif buff : ans += fun(buff)\n\t\t\t\tbuff = []\n\n\t\tif buff : ans += fun(buff)\n\n\t\treturn min(ans, n)\n\n\tprint(fun(a))\n\n\nsetrecursionlimit(10000)\nthreading.stack_size(10**8)\nt = threading.Thread(target=main)\nt.start()\nt.join()\n\n\n\n"]
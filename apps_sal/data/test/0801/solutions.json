["class SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        self.range = [(-1,n)] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n            self.range[self.num + i] = (i,i)\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n            self.range[i] = (self.range[2 * i][0],self.range[2 * i + 1][1])\n\n    def update(self, k, x):\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def bisect_l(self,l,r,x):\n        l += self.num\n        r += self.num\n        Lmin = -1\n        Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:\n                    Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:\n                    Rmin = r-1\n            l >>= 1\n            r >>= 1\n\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:\n                if self.tree[2 * pos] <=x:\n                    pos = 2 * pos\n                else:\n                    pos = 2 * pos +1\n            return pos-self.num\n        else:\n            return -1\n\nn = int(input())\np = list(map(int,input().split()))\n\npos = [[] for i in range(n+2)]\nfor i in range(n):\n    pos[p[i]].append(i)\n\nquery = [[] for i in range(n)]\n\nfor i in range(1,n+2):\n    for j in range(len(pos[i])-1):\n        L = pos[i][j] + 1\n        R = pos[i][j+1] - 1\n        if L<=R:\n            query[R].append((L,i))\n    if pos[i]:\n        if pos[i][0]!=0:\n            query[pos[i][0]-1].append((0,i))\n        if pos[i][-1]!=n-1:\n            query[n-1].append((pos[i][-1]+1,i))\n    else:\n        query[n-1].append((0,i))\n\n#print(query)\n\nflag = [False for i in range(n+3)]\n\ninit = [-1]*(n+2)\ninit[0] = n\nlastappeared = SegmentTree(init,min,-1)\nfor i in range(n):\n    lastappeared.update(p[i],i)\n    for l,val in query[i]:\n        check = lastappeared.bisect_l(0,n+2,l-1)\n        #print(l,i,val,check)\n        #pp = [lastappeared.tree[j+lastappeared.num] for j in range(n)]\n\n        if check>=val or check==-1:\n            flag[val] = True\n\n\nfor i in range(1,n+3):\n    if not flag[i]:\n        print(i)\n        break", "class SegmentTree:\n    def __init__(self, init_val, segfunc, ide_ele):\n        n = len(init_val);self.segfunc = segfunc;self.ide_ele = ide_ele;self.num = 1 << (n - 1).bit_length();self.tree = [ide_ele] * 2 * self.num;self.range = [(-1,n)] * 2 * self.num\n        for i in range(n):self.tree[self.num + i] = init_val[i];self.range[self.num + i] = (i,i)\n        for i in range(self.num - 1, 0, -1):self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1]);self.range[i] = (self.range[2 * i][0],self.range[2 * i + 1][1])\n    def update(self, k, x):\n        k += self.num;self.tree[k] = x\n        while k > 1:self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1]);k >>= 1\n    def query(self, l, r):\n        res = self.ide_ele;l += self.num;r += self.num\n        while l < r:\n            if l & 1:res = self.segfunc(res, self.tree[l]);l += 1\n            if r & 1:res = self.segfunc(res, self.tree[r - 1]);l >>= 1\n            r >>= 1\n        return res\n    def bisect_l(self,l,r,x):\n        l += self.num;r += self.num;Lmin = -1;Rmin = -1\n        while l<r:\n            if l & 1:\n                if self.tree[l] <= x and Lmin==-1:Lmin = l\n                l += 1\n            if r & 1:\n                if self.tree[r-1] <=x:Rmin = r-1\n            l >>= 1;r >>= 1\n        if Lmin != -1:\n            pos = Lmin\n            while pos<self.num:pos = (2 * pos if self.tree[2 * pos] <= x else 2 * pos + 1)\n            return pos-self.num\n        elif Rmin != -1:\n            pos = Rmin\n            while pos<self.num:pos = (2*pos if self.tree[2 * pos] <=x else 2 * pos + 1)\n            return pos-self.num\n        else:return -1\nn = int(input());p = list(map(int,input().split()));pos = [[] for i in range(n+2)];query = [[] for i in range(n)]\nfor i in range(n):pos[p[i]].append(i)\nfor i in range(1,n+2):\n    for j in range(len(pos[i])-1):\n        L = pos[i][j] + 1;R = pos[i][j+1] - 1\n        if L<=R:query[R].append((L,i))\n    if pos[i]:\n        if pos[i][0]!=0:query[pos[i][0]-1].append((0,i))\n        if pos[i][-1]!=n-1:query[n-1].append((pos[i][-1]+1,i))\n    else:query[n-1].append((0,i))\nflag = [False for i in range(n+3)];init = [-1]*(n+2);init[0] = n;lastappeared = SegmentTree(init,min,-1)\nfor i in range(n):\n    lastappeared.update(p[i],i)\n    for l,val in query[i]:\n        check = lastappeared.bisect_l(0,n+2,l-1)\n        if check>=val or check==-1:flag[val] = True\nfor i in range(1,n+3):\n    if not flag[i]:print(i);break"]
["n, k, q = [int(x) for x in input().split()]\nT = [int(x) for x in input().split()]\nS = set()\nfor i in range(q):\n    t, _id = [int(x) for x in input().split()]\n    if t == 1:\n        m = min(S, default = 0)\n        if len(S) == k:\n            if m < T[_id-1]:\n                S.remove(m)\n                S.add(T[_id-1])\n        else:\n            S.add(T[_id-1])\n    else:\n        print('YES' if T[_id-1] in S else 'NO')\n\n", "n, k, q = map(int, input().split())\ndata = list(map(int, input().split()))\ndata1 = set()\nfor i in range(q):\n    typ, fr = map(int, input().split())\n    fr -= 1\n    if typ == 2:\n        if data[fr] in data1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        if len(list(data1)) < k:\n            data1.add(data[fr])\n        elif data[fr] >= min(list(data1)):\n            data1.add(data[fr])\n            data1.remove(min(list(data1)))", "from collections import deque\nfrom math import *\nn, k ,q = list(map(int, input().split()))\nA = []\nlens = 0\nB = list(map(int, input().split()))\nfor i in range(q):\n    per1,per2 = list(map(int, input().split()))\n    if per1 == 1:\n        if lens < k:\n            A.append([per2, B[per2-1]])\n            lens += 1\n        else:\n            c = float('infinity')\n            r = 0\n            for i in range(k):\n                if A[i][1] < c:\n                    c = A[i][1]\n                    r = i\n            if B[per2 -1] > A[r][1]:\n                \n                A[r] = [per2, B[per2-1]]\n    else:\n        si = True\n        for i in range(lens):\n            if A[i][0] == per2:\n                si = False\n                break\n        if si:\n            print('NO')\n        else:\n            print('YES')\n", "\nn, k, q = list(map(int, input().split()))\n\nt = list(map(int, input().split()))\n\nres = set()\ndata = []\n\nfor _ in range(q):\n    req_type, req_id = list(map(int, input().split()))\n\n    if req_type == 1:\n        req_t = t[req_id - 1]\n        data.append((req_id, req_t))\n        res.add(req_id)\n\n        if len(res) > k:\n            data = sorted(data, key=lambda x: x[1], reverse=True)\n            last = data[-1]\n            data = data[:-1]\n\n            res.remove(last[0])\n\n    if req_type == 2:\n        if req_id in res:\n            print('YES')\n        else:\n            print('NO')\n", "def ke(i):\n    return a[i-1]\nn,k,q = list(map(int,input().split()))\na = list(map(int,input().split()))\np = []\nfor i in range(q):\n    b,id=list(map(int,input().split()))\n    id-=1\n    if(b==1):\n        p+=[id+1]\n        p.sort(key=ke,reverse=True)\n        if(len(p)>k):\n            p=p[:-1]\n    else:\n        if id+1 in p:\n            print('YES')\n        else:\n            print('NO')\n\n", "n,k,q=(int(z) for z in input().split())\ns=[int(z) for z in input().split()]\nt=[]\nans=[]\nfor i in range(q):\n\tr=input()\n\tif r[0]=='2':\n\t\tif s[int(r[2:])-1] in t:\n\t\t\tans+=['YES']\n\t\telse:\n\t\t\tans+=['NO']\n\telse:\n\t\tif len(t)<k:\n\t\t\tt.append(s[int(r[2:])-1])\n\t\t\tt.sort()\n\t\t\tt.reverse()\n\t\telse:\n\t\t\tu=0\n\t\t\twhile u<=k-1 and t[u]>s[int(r[2:])-1]:\n\t\t\t\tu+=1\n\t\t\tif u<k:\n\t\t\t\tfor g in range(k-1,u,-1):\n\t\t\t\t\tt[g]=t[g-1]\n\t\t\t\tt[u]=s[int(r[2:])-1]\nfor h in ans:\n\tprint(h)", "\n\nlisted = list()\n\nn, k, q= list(map(int,input().split()))\n\n\ndef del_minv():\n    nonlocal listed\n    minv = 0\n    for _ in range(len(listed)):\n        if friend_value[listed[_]] < friend_value[listed[minv]]:\n            minv = _\n    del listed[minv]\n\n\nfriend_value = list(map(int, input().split()))\nfriend_online = [False]*len(friend_value)\n\nfor _ in range(q):\n    query = list(map(int,input().split()))\n    query[1] -= 1\n\n    if query[0] == 1:\n        friend_online[query[1]] = True\n        listed.append(query[1])\n        if len(listed) > k: del_minv()\n        #print(listed)\n    else:\n        print('YES') if query[1] in listed else print('NO')\n\n\n", "import heapq\n\nn, k, qs = list(map(int, input().split()))\narr = [int(i) for i in input().split()]\nd = []\nfor i in range(qs):\n    q, ind = list(map(int, input().split()))\n    if q == 1:\n        heapq.heappush(d, (arr[ind-1], ind))\n    if len(d) > k:\n        heapq.heappop(d)\n    if q == 2:\n        if (arr[ind-1], ind) in d: print(\"YES\")\n        else: print(\"NO\")\n", "from heapq import heappush, heapreplace\n\nn, k, q, = list(map(int, input().split()))\na = list(map(int, input().split()))\nwindow = []\nwindow_set = set()\nmin_pr = 10 ** 10\nmin_pr_id = 0\nfor i in range(q):\n    type, id = list(map(int, input().split()))\n    if type == 1:\n        if len(window) < k:\n            heappush(window, (a[id - 1], id))\n            min_pr = min(min_pr, a[id - 1])\n        else:\n            if a[id - 1] > min_pr:\n                heapreplace(window, (a[id - 1], id))\n                min_pr = window[0][0]\n    else:\n        if id in [i[1] for i in window]:\n            print('YES')\n        else:\n            print('NO')\n\n", "from heapq import * \n\nn, f, q = [int(s) for s in input().split()]\nloves = [int(s) for s in input().split()]\nk = []\nonlines = set()\nfor i in range(q):\n    ind, num = [int(s) for s in input().split()]\n    if ind == 1:\n        onlines.add(num - 1)\n        if len(k)<f:\n            heappush(k, loves[num - 1])\n        else:\n            heappushpop(k, loves[num-1])\n    else:\n        if num-1 in onlines and k[0] <= loves[num-1]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n", "n, k, q = list(map(int, input().split()))\nfriends = list(map(int, input().split()))\nmain = [None] * k\nfor i in range(q):\n    t, p = list(map(int, input().split()))\n    if t == 1:\n        for j in range(k):\n            if main[k - j - 1] == None:\n                main[k - j - 1] = p - 1\n                break\n            elif friends[main[k - j - 1]] < friends[p - 1]:\n                nn = p - 1\n                for l in range(k - j):\n                    nnn = main[k - j - l - 1]\n                    main[k - j - l - 1] = nn\n                    nn = nnn\n                break\n    elif t == 2:\n        if p - 1 in main:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n", "3\n\nimport operator as op\nfrom queue import PriorityQueue\nimport heapq\n\nclass StdReader:\n\tdef read_int(self):\n\t\treturn int(self.read_string())\n\n\tdef read_ints(self, sep=None):\n\t\treturn [int(i) for i in self.read_strings(sep)]\n\n\tdef read_float(self):\n\t\treturn float(self.read_string())\n\n\tdef read_floats(self, sep=None):\n\t\treturn [float(i) for i in self.read_strings(sep)]\n\n\tdef read_string(self):\n\t\treturn input()\n\n\tdef read_strings(self, sep=None):\n\t\treturn self.read_string().split(sep)\n\nreader = StdReader()\n\n\ndef main():\n\tn, k, q = reader.read_ints()\n\tt = reader.read_ints()\n\n\t# queue = PriorityQueue()\n\tqueue = []\n\tqsize = 0\n\n\t# online = [False]*n\n\t# online_n = 0\n\t# prior = sorted([(i, t[i]) for i in range(n)], key=op.itemgetter(1), inverse=True)\n\t# pos = [0]*n\n\t# for i, p in enumerate(prior):\n\t# \tpos[p[0]] = i\n\n\tfor i in range(q):\n\t\tqt, qid = reader.read_ints()\n\t\tqid -= 1\n\n\t\tif qt == 1:\n\t\t\t# qid online\n\t\t\t# online[qid] = True\n\t\t\t# online_n += 1\n\t\t\tif len(queue) == k:\n\t\t\t\t# queue.get()\n\t\t\t\t# heapq.heappop(queue)\n\t\t\t\t# qsize -= 1\n\t\t\t\theapq.heappushpop(queue, (t[qid], qid))\n\t\t\telse:\n\t\t\t\theapq.heappush(queue, (t[qid], qid))\n\n\t\t\t# queue.put((t[qid], qid))\n\t\t\t# heapq.heappush(queue, )\n\t\t\t# qsize += 1\n\t\telse:\n\t\t\t# query qid\n\t\t\tbox = [i[1] for i in queue]\n\t\t\t# print(box)\n\t\t\tif qid in box:\n\t\t\t\tprint('YES')\n\t\t\telse:\n\t\t\t\tprint('NO')\n\n\t\t\t# if not online[qid]:\n\t\t\t# \tprint('NO')\n\t\t\t# else:\n\t\t\t# \tpass\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()", "n, k, q = list(map(int, input().split()))\n\nt = [0] + list(map(int, input().split()))\n\nts = list()\n\nfor i in range(q):\n    typ, idi = list(map(int, input().split()))\n    if typ == 1:\n        cnt = len(ts)\n        tl = t[idi]\n        if (cnt < k):\n            ts.append(tl)\n        else:\n            if (ts[0] < tl):\n                del ts[0]\n                ts.append(tl)\n        ts.sort()\n    elif typ == 2:\n        if t[idi] in ts:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n", "n,k,q = map(int,input().split())\nt = list(map(int,input().split()))\nd = {}\nfor i in range(n):\n    d[i+1] = t[i]\n\nsp = []\n\nfor i in range(q):\n    a,b = map(int,input().split())\n    if a == 1:\n        if len(sp) == 0:\n            sp.append(b)\n        else:\n            j = 0\n            x = d[b]\n            bb = True\n            while d[sp[j]] > x:\n                j += 1\n                if j == len(sp):\n                    if len(sp) < k:\n                        sp.append(b)\n                    bb = False\n                    break\n            if bb:\n                s1 = sp[:j]\n                s2 = sp[j:]\n                sp = s1 + [b] + s2\n                if len(sp) > k:\n                    sp.remove(sp[-1])\n    else:\n        if b in sp:\n            print('YES')\n        else:\n            print('NO')", "(n,k,q) = map(int,input().split())\nlevel = list(map(int,input().split()))\nqt=[]\nqid=[]\nlfr = set()\n\nfor i in range(0,q):\n    (qtemp,qidtemp) = map(int,input().split())\n    if (qtemp == 1):\n        if (len(lfr)<k):\n            lfr.add(qidtemp)\n        else:\n            minn = qidtemp\n            for el in lfr:\n                if (level[el-1] < level[minn-1]):\n                    minn = el\n            if (level[minn-1] != level[qidtemp-1]):\n                lfr.remove(minn)\n                lfr.add(qidtemp)\n    if (qtemp == 2):\n        if (qidtemp in lfr):\n            print(\"YES\")\n        else:\n            print(\"NO\")", "def Core(size, rate, data):\n\tonline_rate = []\n\tcount = 0\n\tfor item in data:\n\t\tif item[0] == 1:\n\t\t\tif size > count:\n\t\t\t\tcount += 1\n\t\t\t\tonline_rate.append(rate[item[1]])\n\t\t\t\tonline_rate.sort(key=lambda x: -x)\n\t\t\telif online_rate[-1] < rate[item[1]]:\n\t\t\t\tonline_rate[-1] = rate[item[1]]\n\t\t\t\tonline_rate.sort(key=lambda x: -x)\n\t\telse:\n\t\t\tif rate[item[1]] in online_rate and online_rate.index(rate[item[1]]) < size:\n\t\t\t\tprint(\"YES\")\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\n\nparam1 = input().split(\" \")\nparam2 = [0] + [int(i) for i in input().split(\" \")]\nparam3 = [[int(j) for j in input().split(\" \")] for i in range(int(param1[2]))]\nCore(int(param1[1]), param2, param3)", "str1 = input().split()\nn = int(str1[0])\nk = int(str1[1])\nq = int(str1[2])\n\nfriends = list([int(x) for x in input().split()])\nonline = set()\n\nfor i in range(q):\n    str1 = input().split()\n    if str1[0] == '2':\n        if int(str1[1]) in online:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        online.add(int(str1[1]))\n        if len(online) > k:\n            minelem = int(str1[1])\n            for on in online:\n                if friends[on - 1] < friends[minelem - 1]:\n                    minelem = on\n            online.remove(minelem)\n            \n", "n=input()\nb=[]\nb=n.split()\nn=int(b[0])\nk=int(b[1])\nq=int(b[2])\nc=input()\nlevel=c.split()\nonline=[]\nfor i in range(q):\n    c=input()\n    z=c.split()\n    if z[0]=='1':\n        if len(online)<k:\n            online.append(int(z[1]))\n        else:\n            min=int(level[int(z[1])-1])\n            number=-1\n            for j in range(k):\n                if int(level[online[j]-1])<min:\n                    min=int(level[online[j]-1])\n                    number=j\n            if number>-1:\n                online[number]=int(z[1])\n    else:\n        if online.count(int(z[1]))>0:\n            print('YES')\n        else:\n            print('NO')\n\n", "import heapq as pq\n\nh = []\n\nn, k, q = list(map(int, input().split()))\n\nts = list(map(int, input().split()))\n\nfor _ in range(q):\n    t, i = list(map(int, input().split()))\n    if t == 1:\n        pq.heappush(h, (ts[i - 1], i))\n        if len(h) > k:\n            pq.heappop(h)\n    else:\n        if i in [p[1] for p in h]:\n            print('YES')\n        else:\n            print('NO')\n", "import heapq\n\nn, k, q = [int(x) for x in input().split()]\nt = [int(x) for x in input().split()]\n\nheap = []\nfor i in range(q):\n    query_type, query_id = [int(x) for x in input().split()]\n    if query_type == 1:\n        if len(heap) < k or t[query_id - 1] > heap[0]:\n            if len(heap) == k:\n                heapq.heappop(heap)\n            heapq.heappush(heap, t[query_id - 1])\n    else:\n        print('YES' if t[query_id - 1] in heap else 'NO')\n", "n, size, tasks = map(int, input().split())\nfriends = list(map(int, input().split()))\nonline = list()\nfor i in range(tasks):\n    type, id = map(int, input().split())\n    id -= 1\n    if type == 1:\n        adds = friends[id]\n        online = sorted(online + [adds], reverse=True)\n        if len(online) > size:\n            del online[-1]\n    else:\n        flag_oh_my_god_why = False\n        search = friends[id]\n        for bear in online:\n            if bear == search:\n                flag_oh_my_god_why = True\n                break\n        if flag_oh_my_god_why == False: print('NO')\n        else: print('YES')", "n, k, q = [int(s) for s in input().split()]\nfriend_list = [int(s) for s in input().split()]\nactive_friends_id = dict()\n\nactive_friends = [-1 for i in range(k)]\nmin_value = 0\nmin_ind = -1\nmin_key = -1\ncount = 0\ntmp_ind = 0\nfor i in range(q):\n    req, id = [int(s) for s in input().split()]\n    id -= 1\n    if req == 1:\n        if count != k or friend_list[id] > min_value:\n            if count == k: # \u0432\u044b\u0442\u0435\u0441\u043d\u044f\u0442\u044c\n                active_friends_id[min_ind] = id\n                active_friends[min_ind] = friend_list[id]\n                min_value = min(active_friends)\n                min_ind = active_friends.index(min_value)\n            else: # \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c\n                active_friends_id[tmp_ind] = id\n                active_friends[tmp_ind] = friend_list[id]\n                tmp_ind += 1\n                count += 1\n                if count == k:\n                    min_value = min(active_friends)\n                    min_ind = active_friends.index(min_value)\n    else:\n        if id in active_friends_id.values():\n            print(\"YES\")\n        else:\n            print(\"NO\")", "n,k,q = list(map(int, input().split(' ')))\nfr_lvl = list(map(int, input().split(' ')))\nlvl = {i + 1: fr_lvl[i] for i in range(len(fr_lvl))}\nonline = 0\ntop_six = []\nout = []\nfor step in range(q):\n    count = 0\n    found = False\n    query = input()\n    if query[0] == '1':\n        online += 1\n        if online < k + 1:\n            top_six.append(int(query[2:]))\n            top_six = sorted(top_six, key = lambda x: lvl[x])\n        if online >= k+ 1:\n            if lvl[top_six[0]] < lvl[int(query[2:])]:\n                top_six[0] = int(query[2:])\n                top_six = sorted(top_six, key = lambda x: lvl[x])\n    if query[0] == '2':\n        out.append(int(query[2:]) in top_six and 'YES' or 'NO')\nfor i in out:\n    print(i)", "n,k,q=[int(x) for x in input().split()]\na=[int(x) for x in input().split()]\nb=[0]\nfor i in range(q):\n    t,d=[int(x) for x in input().split()]\n    if t==2:\n         if d in b:\n             print('YES')\n         else:\n             print('NO')\n    if b[0]==0:\n        b.remove(0)\n        b.append(d)\n    if t==1:\n        for y in range(len(b)):\n            if a[d-1]>a[b[y]-1]:\n                b.insert(y,d)\n                break\n        if a[d-1]<a[b[len(b)-1]-1]:\n            b.append(d)\n        if len(b)==k+1:\n            b.pop(len(b)-1)"]
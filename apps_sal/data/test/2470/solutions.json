["import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            prev_with_op = min_last_value_given_operations(n - 1, ops - 1)\n            b = find_larger_value_in_B(prev_with_op)\n            # dp(n - 1, ops) <= dp(n - 1, ops - 1)\n            # if dp(n - 1, ops - 1) < A[n - 1] => dp(n - 1, ops) < A[n - 1]\n            if prev_with_op < A[n - 1]:\n                return min(A[n - 1], b)\n            elif b <= A[n - 1]:\n                return b\n            elif min_last_value_given_operations(n - 1, ops) < A[n - 1]:\n                return A[n - 1]\n            return b\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        from bisect import bisect_right as br\n        arr2.sort()\n        \n        dp = {0:-math.inf}\n        # min_cnt = 0\n        for n1 in arr1:\n            # print(n1)\n            new_dp = {}\n            # cnt = min_cnt\n            for cnt in dp:\n                if n1 > dp[cnt]:\n                    new_dp[cnt] = min(new_dp.get(cnt, math.inf), n1)\n                i2 = br(arr2, dp[cnt])\n                if i2 < len(arr2):\n                    new_dp[cnt+1] = min(new_dp.get(cnt+1, math.inf), arr2[i2])\n                cnt += 1\n            if len(new_dp) == 0:\n                return -1\n            # while min_cnt not in new_dp:\n            #     min_cnt += 1\n            dp = new_dp\n            # print(dp)\n        return min(dp.keys())\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2 = list(set(arr2))\n        arr2.sort()\n        m, n = len(arr1), len(arr2)\n        keep = [float('inf')]*m\n        swap = [[float('inf') for _ in range(n)] for _ in range(m)]\n        keep[0] = 0\n        for i in range(n):\n            swap[0][i] = 1\n        for i in range(1, m):\n            min_keep, min_swap = float('inf'), float('inf')\n            for j in range(n):\n                if j > 0:\n                    min_swap = min(min_swap, swap[i-1][j-1]+1)\n                if arr1[i] > arr2[j]:\n                    min_keep = min(min_keep, swap[i-1][j])\n                if arr1[i] > arr1[i-1]:\n                    keep[i] = keep[i-1]\n                if arr2[j] > arr1[i-1]:\n                    swap[i][j] = keep[i-1]+1\n                keep[i] = min(keep[i], min_keep)\n                swap[i][j] = min(swap[i][j], min_swap)\n        s = float('inf')\n        for i in range(n):\n            s = min(s, swap[m-1][i])\n        res = min(s, keep[m-1])\n        return -1 if res >= float('inf') else res\n\n# \u89c1\u82b1\u82b1\u9171\u89c6\u9891\uff1ahttps://www.bilibili.com/video/av67133426/?spm_id_from=333.788.b_636f6d6d656e74.7\n                    \n        \n", "import numpy as np\n\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        m = len(arr1)\n        arr2 = sorted(np.unique(arr2))\n        n = len(arr2)\n        \n        keep = [float('inf')] * m\n        keep[0] = 0\n        swap = [1] * n\n        \n        for i in range(1, m):\n            min_keep = float('inf')\n            min_swap = float('inf')\n            temp = [float('inf')] * n\n            for j in range(n):\n                if j > 0:\n                    min_swap = min(min_swap, swap[j - 1] + 1)\n                if arr1[i] > arr2[j]:\n                    min_keep = min(min_keep, swap[j])\n                if arr1[i] > arr1[i - 1]:\n                    keep[i] = keep[i - 1]\n                if arr2[j] > arr1[i - 1]:\n                    temp[j] = keep[i - 1] + 1\n                temp[j] = min(temp[j], min_swap)\n                keep[i] = min(keep[i], min_keep)\n            for j in range(n):\n                temp[j], swap[j] = swap[j], temp[j]\n        \n        s = min(swap)\n        k = keep[-1]\n        ans = min(s, k)\n        return ans if ans < float('inf') else -1\n        \n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        m = len(arr1)\n        arr2 = list(set(arr2))\n        arr2.sort()\n        n = len(arr2)\n        keep = [float('inf')] * m\n        keep[0] = 0\n        swap = [[float('inf') for j in range(n)] for i in range(m)]\n        for j in range(n):\n            swap[0][j] = 1\n        for i in range(1,m):\n            min_keep = float('inf')\n            min_swap = float('inf')\n            for j in range(0, n):\n                if j > 0:\n                    min_swap = min(min_swap, swap[i-1][j-1] + 1 )\n                if arr1[i] > arr2[j]:\n                    min_keep = min(min_keep, swap[i-1][j]  )\n                if arr1[i] > arr1[i-1]:\n                    keep[i] = keep[i -1]\n                if arr2[j] > arr1[i-1]:\n                    swap[i][j] = keep[i -1] + 1\n                swap[i][j] = min(swap[i][j], min_swap)\n                keep[i]  = min(keep[i], min_keep )\n        \n        k = keep[-1]\n        min_swap = min(swap[-1])\n        ans = min (min_swap, k)\n        return ans if ans < float('inf') else -1", "from bisect import bisect\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        d = {float('-inf'): 0}\n        arr2 = sorted(set(arr2))\n        for i in arr1:\n            d2 = {}\n            for k, v in list(d.items()):\n                if i > k:\n                    if i in d2:\n                        d2[i] = min(d2[i], v)\n                    else:\n                        d2[i] = v\n\n                if k < arr2[-1]:\n                    j = arr2[bisect(arr2, k)]\n                    if j in d2:\n                        d2[j] = min(d2[j], v + 1)\n                    else:\n                        d2[j] = v + 1\n            \n            d = d2\n        \n        if d:\n            return min(d.values())\n        return -1\n                        \n        \n        \n        \n        \n", "from collections import defaultdict\nfrom math import inf\nfrom bisect import bisect_right\n\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        n = len(arr2)\n        dp = {-1: 0}\n        for i in arr1:\n            next_dp = defaultdict(lambda: inf)\n            for key in dp:\n                if i > key:\n                    next_dp[i] = min(next_dp[i], dp[key])\n                loc = bisect_right(arr2, key)\n                if loc < n:\n                    next_dp[arr2[loc]] = min(next_dp[arr2[loc]], dp[key] + 1)\n            dp = next_dp\n\n        return min(dp.values()) if dp else -1", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        from bisect import bisect_right as br\n        arr2.sort()\n        \n        dp = {0:-math.inf}\n        min_cnt = 0\n        for n1 in arr1:\n            # print(n1)\n            new_dp = {}\n            cnt = min_cnt\n            while cnt in dp:\n                if n1 > dp[cnt]:\n                    new_dp[cnt] = min(new_dp.get(cnt, math.inf), n1)\n                    # candidate = min(new_dp.get(cnt, math.inf), n1)\n                    # if candidate < new_dp.get(cnt-1, math.inf):\n                    #     new_dp[cnt] = candidate\n                i2 = br(arr2, dp[cnt])\n                # if i2 < len(arr2) and arr2[i2] < new_dp.get(cnt, math.inf):\n                if i2 < len(arr2):\n                    new_dp[cnt+1] = arr2[i2]\n                # print(new_dp)\n                # if new_dp.get(cnt+1, -math.inf) >= new_dp.get(cnt, math.inf):\n                #     new_dp.pop(cnt+1)\n                # if new_dp.get(cnt, -math.inf) >= new_dp.get(cnt-1, math.inf):\n                #     new_dp.pop(cnt)\n                cnt += 1\n            if len(new_dp) == 0:\n                return -1\n            while min_cnt not in new_dp:\n                min_cnt += 1\n            dp = new_dp\n            print(dp)\n        return min(dp.keys())\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        import bisect\n        # dp\u5b58\u50a8\u6240\u6709\u6f5c\u5728\u7684\u5f53\u524d\u72b6\u6001\uff08\u6bcf\u6b21dp\u90fd\u662f\u904d\u5386arr1\u65f6\u524d\u4e00\u4e2a\u4f4d\u7f6e\u7684\u72b6\u6001\uff09\n        # \u8fd9\u91cc\u7684\u72b6\u6001\u662f\u4e00\u4e2a\u952e\u503c\u5bf9\uff0ckey\u4ee3\u8868\u5f53\u524d\u4f4d\u7f6e\u7684\u6570\u5b57\uff0c\n        # \u53ef\u4ee5\u662farr1\u91cc\u9762\u7684\uff0c\u4e5f\u53ef\u4ee5\u662farr2\u91cc\u9762\u7528\u6765\u66ff\u6362\u7684\n        # value\u5c31\u662f\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684\u6b21\u6570\n        dp = {-1: 0}\n        arr2.sort()\n        for i in arr1:\n            tmp = collections.defaultdict(lambda: float('inf'))\n            for key in dp:\n                if i > key:\n                    tmp[i] = min(tmp[i], dp[key])\n                loc = bisect.bisect_right(arr2, key)\n                if loc < len(arr2):\n                    tmp[arr2[loc]] = min(tmp[arr2[loc]], dp[key] + 1)\n            dp = tmp\n        return min(dp.values()) if dp else -1\n", "from bisect import bisect_right as br\nimport math\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2 = sorted(set(arr2))\n        @lru_cache(None)\n        def dfs(i, prev):\n            if i == len(arr1): return 0\n            j = br(arr2, prev)\n            swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n            noswap = dfs(i+1, arr1[i]) if prev < arr1[i] else math.inf\n            return min(swap, noswap)  \n        ret = dfs(0, -math.inf)\n        return ret if ret != math.inf else -1\n        \n        \n        \n        \n        \n        # arr2=sorted(set(arr2))\n        # @functools.lru_cache(None)\n        # def dfs(i,prev):\n        #     if i >= len(arr1):\n        #         return 0\n        #     j = br(arr2,prev)\n        #     swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n        #     noswap = dfs(i+1, arr1[i]) if arr1[i] > prev else math.inf\n        #     return min(swap,noswap)\n        # changes=dfs(0, -math.inf)\n        # return changes if changes!=math.inf else -1\n", "from bisect import bisect_right as br\nimport math\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2 = sorted(set(arr2))   \n        @lru_cache(None)\n        def dfs(i, prev):\n            if i >= len(arr1): return 0\n            j = br(arr2, prev)\n            swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n            noswap = dfs(i+1, arr1[i]) if prev < arr1[i] else math.inf\n            return min(swap, noswap)\n        ans = dfs(0, -1)\n        return ans if ans != math.inf else -1\n        \n        \n        \n        \n        # arr2=sorted(set(arr2))\n        # @functools.lru_cache(None)\n        # def dfs(i,prev):\n        #     if i >= len(arr1):\n        #         return 0\n        #     j = br(arr2,prev)\n        #     swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n        #     noswap = dfs(i+1, arr1[i]) if arr1[i] > prev else math.inf\n        #     return min(swap,noswap)\n        # changes=dfs(0, -math.inf)\n        # return changes if changes!=math.inf else -1\n", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            skip_op = min_last_value_given_operations(n - 1, ops)\n            if skip_op == float('inf'):\n                return float('inf')\n            return min(\n                A[n - 1] if skip_op < A[n - 1] else float('inf'),\n                find_larger_value_in_B(min_last_value_given_operations(n - 1, ops - 1)),\n            )\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        import bisect\n        dp = {-1: 0}\n        arr2.sort()\n        for i in arr1:\n            tmp = collections.defaultdict(lambda: float('inf'))\n            for key in dp:\n                if i > key:\n                    tmp[i] = min(tmp[i], dp[key])\n                loc = bisect.bisect_right(arr2, key)\n                if loc < len(arr2):\n                    tmp[arr2[loc]] = min(tmp[arr2[loc]], dp[key] + 1)\n            dp = tmp\n        return min(dp.values()) if dp else -1\n", "import bisect\nimport functools\n    \nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2=sorted(set(arr2))\n        \n        @functools.lru_cache(None)\n        def dfs(i,prev):\n            if i>=len(arr1):\n                return 0\n            j=bisect.bisect_right(arr2,prev)\n            swap=1+dfs(i+1,arr2[j]) if j<len(arr2) else math.inf\n            noswap=dfs(i+1,arr1[i]) if arr1[i]>prev else math.inf\n            return min(swap,noswap)\n        changes=dfs(0,-math.inf)\n        return changes if changes!=math.inf else -1", "from bisect import bisect_right as br\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2 = sorted(set(arr2))\n        @lru_cache(None)\n        def dfs(i, prev):\n            if i >= len(arr1): return 0\n            j = br(arr2, prev)\n            swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n            noswap = dfs(i+1, arr1[i]) if arr1[i] > prev else math.inf\n            return min(swap, noswap)\n        \n        \n        ans = dfs(0, -math.inf)\n        return ans if ans!=math.inf else -1\n        \n        \n        \n        \n        \n        \n        # arr2=sorted(set(arr2))\n        # @functools.lru_cache(None)\n        # def dfs(i,prev):\n        #     if i >= len(arr1):\n        #         return 0\n        #     j = br(arr2,prev)\n        #     swap = 1 + dfs(i+1, arr2[j]) if j < len(arr2) else math.inf\n        #     noswap = dfs(i+1, arr1[i]) if arr1[i] > prev else math.inf\n        #     return min(swap,noswap)\n        # changes=dfs(0, -math.inf)\n        # return changes if changes!=math.inf else -1\n", "import bisect\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2=sorted(set(arr2))\n        @functools.lru_cache(None)\n        def dfs(i,prev):\n            if i>=len(arr1):\n                return 0\n            j=bisect.bisect_right(arr2,prev)\n            swap=1+dfs(i+1,arr2[j]) if j<len(arr2) else math.inf\n            noswap=dfs(i+1,arr1[i]) if arr1[i]>prev else math.inf\n            return min(swap,noswap)\n        changes=dfs(0,-math.inf)\n        return changes if changes!=math.inf else -1", "import bisect\nimport functools\n    \nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        # arr1i\n        # arr2j\n        arr2 = sorted(set(arr2))\n        @functools.lru_cache(None)\n        def dfs(prev, i):\n            if i == len(arr1):\n                return 0\n            j = bisect.bisect_right(arr2, prev)\n            swap = 1 + dfs(arr2[j], i+1) if j < len(arr2) else float('inf')\n            noswap = dfs(arr1[i], i+1) if prev < arr1[i] else float('inf')\n            return min(swap, noswap)\n        changes = dfs(float('-inf'), 0)\n        return changes if changes != float('inf') else -1\n", "class Solution:\n  def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n    # TC: O(min(M, N)*N+MlogM), SC: O(min(M, N))\n    m, n = len(arr1), len(arr2)\n    # sort O(MlogM)\n    arr2.sort()\n    # maintain a list of (num-of-swaps, last-value, next-to-swap-index-arr2),\n    # where the last value should be decrease as the num of swaps is increase\n    ss = [(0, arr1[0], 0)]\n    if arr2[0] < arr1[0]:\n      ss.append((1, arr2[0], 1))\n    # O(N) iteration\n    for i in range(1, m):\n      st = []\n      # O(min(M, N))\n      for s, x, j in ss:\n        if x < arr1[i]:\n          if st:\n            if s == st[-1][0]:\n              if arr1[i] < st[-1][1]:\n                st[-1] = (s, arr1[i], j)\n            elif s > st[-1][0]:\n              if arr1[i] < st[-1][1]:\n                st.append((s, arr1[i], j))\n          else:\n            st.append((s, arr1[i], j))\n        # amortized O(1)\n        while j < n and arr2[j] <= x:\n          j += 1\n        if j < n:\n          st.append((s + 1, arr2[j], j))\n      # since each swap takes at most 1 entry, and at most O(min(M, N)) swap, so SC: O(min(M, N))\n      ss = st\n    return ss[0][0] if ss else -1", "import bisect\nfrom typing import List\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        array = arr1\n        replace = list(sorted(set(arr2)))\n\n        @lru_cache(None)\n        def dfs(array_pos: int, prev_number: int) -> int:\n            min_replacements = len(replace) * 2\n\n            if array_pos == len(array):\n                return 0\n\n            next_replace_pos = 0\n\n            if array_pos > 0:\n                next_replace_pos = bisect.bisect(replace, prev_number)\n\n            if array_pos == 0 or (\n                next_replace_pos < len(replace)\n            ):\n                tmp = array[array_pos]\n                min_replacements = min(min_replacements, dfs(array_pos + 1, replace[next_replace_pos]) + 1)\n\n            if array_pos == 0 or prev_number < array[array_pos]:\n                min_replacements = min(min_replacements, dfs(array_pos + 1, array[array_pos]))\n\n            return min_replacements\n\n        result = dfs(0, -100)\n\n        if result > len(replace):\n            return -1\n\n        return result\n", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n        b2idx = {b: i for i, b in enumerate(B)}\n        \n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            if val in b2idx:\n                return B[b2idx[val] + 1]\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            skip_op = min_last_value_given_operations(n - 1, ops)\n            if skip_op == float('inf'):\n                return float('inf')\n            return min(\n                A[n - 1] if skip_op < A[n - 1] else float('inf'),\n                find_larger_value_in_B(min_last_value_given_operations(n - 1, ops - 1)),\n            )\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n", "import bisect\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2=sorted(set(arr2))\n        @functools.lru_cache(None)\n        def dfs(i,prev):\n            if i>=len(arr1):\n                return 0\n            j = bisect.bisect_right(arr2,prev)\n            swap = 1 + dfs(i+1,arr2[j]) if j < len(arr2)  else math.inf\n            noswap = dfs(i+1,arr1[i])   if arr1[i] > prev else math.inf\n            return min(swap,noswap)\n        changes = dfs(0,-math.inf)\n        return changes if changes != math.inf else -1\n", "import bisect\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        N = len(arr1)\n        arr1 = [0] + arr1\n        # \u8868\u793a\u524d i \u4e2a\u5143\u7d20\uff0c\u6267\u884c\u4e86 k \u6b21\u64cd\u4f5c\u540e\uff0c\u662f\u6709\u5e8f\u7684\n        dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = -float('inf')\n        \n        arr2.sort()\n        for i in range(1, N + 1):\n            for k in range(i + 1):\n                # \u524di-1\u4e2a\u5143\u7d20\uff0c\u5df2\u7ecf\u5b8c\u6210\u4e86k\u6b21\u4ea4\u6362\n                if arr1[i] > dp[i-1][k]:\n                    dp[i][k] = min(dp[i][k], arr1[i])\n                \n                # \u524d i-1 \u4e2a\u5143\u7d20\uff0c\u5df2\u7ecf\u5b8c\u6210\u4e86 k-1\u6b21\u4ea4\u6362\uff0c\u6240\u4ee5\u8fd9\u4e00\u6b21\u4e00\u5b9a\u8981\u4ea4\u6362\n                if k >= 1:\n                    idx_2 = bisect.bisect_right(arr2, dp[i-1][k-1])\n                    if idx_2 != len(arr2):                    \n                        dp[i][k] = min(dp[i][k], arr2[idx_2])\n        \n        res = float('inf')\n        for i in range(1, N+1):\n            if dp[N][i] != float('inf'):\n                res = min(res, i)\n        return res if res != float('inf') else -1", "import bisect\nfrom typing import List\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        array = arr1\n        replace = list(sorted(set(arr2)))\n\n        @lru_cache(None)\n        def dfs(array_pos: int, prev_number: int) -> int:\n            min_replacements = len(replace) * 2\n\n            if array_pos == len(array):\n                return 0\n\n            next_replace_pos = 0\n\n            if array_pos > 0:\n                next_replace_pos = bisect.bisect(replace, array[array_pos - 1])\n\n            if array_pos == 0 or (\n                next_replace_pos < len(replace)\n            ):\n                tmp = array[array_pos]\n                array[array_pos] = replace[next_replace_pos]\n                min_replacements = min(min_replacements, dfs(array_pos + 1, array[array_pos]) + 1)\n                array[array_pos] = tmp\n\n            if array_pos == 0 or array[array_pos - 1] < array[array_pos]:\n                min_replacements = min(min_replacements, dfs(array_pos + 1, array[array_pos]))\n\n            return min_replacements\n\n        result = dfs(0, -100)\n\n        if result > len(replace):\n            return -1\n\n        return result\n", "import bisect\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1, arr2) -> int:\n        N = len(arr1)\n        arr1 = [0] + arr1\n        arr2.sort()\n        dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n        dp[0][0] = -float('inf')\n        \n        for i in range(1, N + 1):\n            for j in range(0, i + 1):\n                if dp[i-1][j] < arr1[i]:\n                    dp[i][j] = min(dp[i][j], arr1[i])\n                if j >= 1:\n                    # \u8981\u5728 arr2 \u4e2d\u627e\u5230\u4e00\u4e2a\u6bd4 arr1[i] \u7a0d\u5fae\u5927\u4e00\u70b9\u7684\u6570\n                    idx_2 = bisect.bisect_right(arr2, dp[i-1][j-1])\n                    if idx_2 != len(arr2):\n                        dp[i][j] = min(dp[i][j], arr2[idx_2])\n        \n        # \u6ee1\u8db3\u6761\u4ef6\uff0c\u5e76\u4e14\u80fd\u591f\u6267\u884c\u6700\u5c11\u7684\u6b21\u6570\u7684 K \u7684\u503c\n        res = float('inf')\n        for i in range(1, N + 1):\n            if dp[N][i] != float('inf'):\n                res = min(res, i)\n        return -1 if res == float('inf') else res", "import bisect\nimport functools\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2=sorted(set(arr2))\n        \n        @functools.lru_cache(None)\n        def dfs(i,prev):\n            if i>=len(arr1):\n                return 0\n            j=bisect.bisect_right(arr2,prev)\n            swap=1+dfs(i+1,arr2[j]) if j<len(arr2) else math.inf\n            noswap=dfs(i+1,arr1[i]) if arr1[i]>prev else math.inf\n            return min(swap,noswap)\n        \n        changes=dfs(0,-math.inf)\n        return changes if changes!=math.inf else -1", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        def bs(arr, l, r, target):\n            while l<=r:\n                m = l+(r-l)//2\n                if arr[m]>target:\n                    r = m-1\n                else:\n                    l = m+1\n            return l\n        \n        arr2.sort()\n        N = len(arr2)\n        dp = {-1:0}\n        \n        for a in arr1:\n            dp2 = {}\n            for prev in dp:\n                if a>prev:\n                    dp2[a] = min(dp2.get(a, float('inf')), dp[prev])\n                \n                idx = bs(arr2, 0, N-1, prev)\n                if idx<N:\n                    dp2[arr2[idx]] = min(dp2.get(arr2[idx], float('inf')), dp[prev]+1)\n                    \n            dp = dp2\n            if not dp:\n                return -1\n            \n        return min(dp.values())", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n        \n        def find_lower_val_in_B(val):\n            larger_equal_idx = bisect.bisect_left(B, val)\n            if larger_equal_idx > 0:\n                return B[larger_equal_idx - 1]\n            return None  # no lower value in B\n\n        @lru_cache(None)\n        def make_prefix_increasing(n, upper=float('inf')):\n            if n == 0:\n                return 0\n\n            swap_b = find_lower_val_in_B(upper)\n            ret = float('inf')\n            if A[n - 1] < upper:\n                ret = min(make_prefix_increasing(n - 1, upper=A[n - 1]), ret)\n            if swap_b is not None:\n                ret = min(1 + make_prefix_increasing(n - 1, upper=swap_b), ret)\n\n            return ret\n\n        ret = make_prefix_increasing(len(A))\n        return ret if ret < float('inf') else -1\n", "class Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        \n        dp = {-1:0}\n        B = sorted(B)\n        \n        for cur in A:\n            temp = collections.defaultdict(lambda: float('inf'))\n            for prev in dp:\n                if prev<cur:\n                    temp[cur] = min(temp[cur], dp[prev])\n                idx = self.upper_bound(B, prev)\n                if idx<len(B):\n                    temp[B[idx]] = min(temp[B[idx]], dp[prev]+1) \n            dp = temp\n        \n        if dp:\n            return min(dp.values())\n        return -1\n    \n    def upper_bound(self, B, target):\n        l=0\n        r=len(B)\n        while l<r:\n            mid=l+(r-l)//2\n            if B[mid]<=target:\n                l=mid+1\n            else:\n                r=mid\n        return l\n                \n                \n", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n            return min(\n                A[n - 1] if min_last_value_given_operations(n - 1, ops) < A[n - 1] else float('inf'),\n                find_larger_value_in_B(min_last_value_given_operations(n - 1, ops - 1)),\n            )\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        if not arr1: return 0\n        if not arr2: return arr1 == sorted(arr1)\n        \n        arr2 = sorted(list(set(arr2)), reverse=True)\n        \n        n, m, inf = len(arr1), len(arr2), float('inf')\n        f = [[inf]*(n+1) for _ in range(n)]\n        for i in range(n+1):\n            f[0][i] = min(arr1[0],arr2[-1])\n        f[0][0] = arr1[0]\n        for i in range(1,n):\n            found_k = 0\n            for j in range(n+1):\n                if f[i-1][j] < arr1[i]: f[i][j] = arr1[i]\n                if not j: continue\n                va = f[i-1][j-1]\n                if not found_k:\n                    if arr2[0] > va:\n                        l,r = 0,m-1\n                        while l < r:\n                            mid = l+r+1 >> 1\n                            if arr2[mid] > va:\n                                l = mid\n                            else: \n                                r = mid - 1\n                        k = l\n                        found_k = 1\n                        f[i][j] = min(f[i][j],arr2[k])\n                else:\n                    while k+1 < m and arr2[k+1] > va: k += 1\n                    f[i][j] = min(f[i][j],arr2[k])\n        for i,v in enumerate(f[-1]): \n            if v < inf: return i\n        return -1\n                \n                \n                \n", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            prev_with_op = min_last_value_given_operations(n - 1, ops - 1)\n            b = find_larger_value_in_B(prev_with_op)\n            # dp(n - 1, ops) <= dp(n - 1, ops - 1)\n            # if dp(n - 1, ops - 1) < A[n - 1] => dp(n - 1, ops) < A[n - 1]\n            if prev_with_op < A[n - 1]:\n                return min(A[n - 1], b)\n            elif b <= A[n - 1]:\n                return b\n            elif min_last_value_given_operations(n - 1, ops) < A[n - 1]:\n                return A[n - 1]\n            return b\n\n        for ops in range(min(len(A), len(B)) + 1):\n            if min_last_value_given_operations(len(A), ops) < float('inf'):\n                return ops\n\n        return -1\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        #10:04\n        # arr2=list(set(arr2))\n        n=len(arr1)\n        arr2=list(set(arr2))\n        arr2.sort()\n        m=len(arr2)\n        # we might need fix at point 0\n        # hence we will always compare it will\n        def bsearch(left,right,val):\n            ans=-1\n            while left<=right:\n                mid=left+(right-left)//2\n                if arr2[mid]>val:\n                    ans=mid\n                    right=mid-1\n                else:\n                    left=mid+1\n            return ans \n        \n        @lru_cache(None)\n        def helper(i,j,prev):\n            nonlocal n,m\n            if i>=len(arr1):\n                # arr1 is increasing, we have reached so far\n                return 0\n            else:\n                ans=float('inf')\n                if arr1[i]>prev:\n                    # no need of replacement\n                    ans=min(ans,helper(i+1,j,arr1[i]))\n                    # pick any index from arr2 starting j\n                idx=bsearch(j,len(arr2)-1,prev)\n                if idx!=-1:\n                    ans=min(ans,1+helper(i+1,idx+1,arr2[idx]))\n                return ans\n        ans=helper(0,0,-1)\n        return -1 if ans==float('inf') else ans\n                \n                \n        \n        \n", "def binsearch(arr,x):\n    if(arr[0]>x):\n        return 0\n    l=0\n    h=len(arr)-1\n    ret=-1\n    while(l<=h):\n        mid=(l+h)//2\n        if(arr[mid]<=x):\n            l=mid+1\n        elif(arr[mid]>x):\n            ret=mid\n            h=mid-1\n    return ret\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        m=len(arr2)\n        n=len(arr1)\n        dp={}\n        # print(binsearch(arr2,0))\n        def dfs(arr1,arr2,left,curr,dp):\n            if(curr>=len(arr1)):\n                return 0\n            if((curr,left) in dp):\n                return dp[(curr,left)]\n            res1=sys.maxsize\n            res2=0\n            if(arr1[curr]>left):\n                res1=dfs(arr1,arr2,arr1[curr],curr+1,dp)\n            mid=binsearch(arr2,left)\n            if(mid==-1):\n                res2=sys.maxsize-1\n            else:\n                res2=dfs(arr1,arr2,arr2[mid],curr+1,dp)\n            dp[(curr,left)]=min(res1,1+res2)\n            return dp[(curr,left)]\n        x=dfs(arr1,arr2,-sys.maxsize,0,dp)\n        if(x>=(sys.maxsize-1)):\n            return -1\n        return x\n            \n", "def binsearch(arr,x):\n    if(arr[0]>x):\n        return 0\n    l=0\n    h=len(arr)-1\n    ret=-1\n    while(l<=h):\n        mid=(l+h)//2\n        if(arr[mid]<=x):\n            l=mid+1\n        elif(arr[mid]>x):\n            ret=mid\n            h=mid-1\n    return ret\nclass Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        m=len(arr2)\n        n=len(arr1)\n        dp={}\n        def dfs(arr1,arr2,left,curr,dp):\n            if(curr>=len(arr1)):\n                return 0\n            if((curr,left) in dp):\n                return dp[(curr,left)]\n            res1=sys.maxsize\n            res2=0\n            if(arr1[curr]>left):\n                res1=dfs(arr1,arr2,arr1[curr],curr+1,dp)\n            mid=binsearch(arr2,left)\n            if(mid==-1):\n                res2=sys.maxsize-1\n            else:\n                res2=dfs(arr1,arr2,arr2[mid],curr+1,dp)\n            dp[(curr,left)]=min(res1,1+res2)\n            return dp[(curr,left)]\n        x=dfs(arr1,arr2,-sys.maxsize,0,dp)\n        if(x==(sys.maxsize)):\n            return -1\n        return x\n            \n", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n        b2idx = {b: i for i, b in enumerate(B)}\n        \n        # @lru_cache(None)\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            if val in b2idx:\n                return B[b2idx[val] + 1]\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            elif n == 0:\n                return float('-inf')\n            elif ops > n:\n                return min_last_value_given_operations(n, n)\n\n            skip_op = min_last_value_given_operations(n - 1, ops)\n            if skip_op == float('inf'):\n                return float('inf')\n            return min(\n                A[n - 1] if skip_op < A[n - 1] else float('inf'),\n                find_larger_value_in_B(min_last_value_given_operations(n - 1, ops - 1)),\n            )\n\n        last_success = -1\n        for ops in range(min(len(A), len(B)), -1, -1):\n            if min_last_value_given_operations(len(A), ops) == float('inf'):\n                break\n            last_success = ops\n\n        return last_success\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        #10:04\n        # arr2=list(set(arr2))\n        arr2.sort()\n        # we might need fix at point 0\n        # hence we will always compare it will\n        \n        def bsearch(left,right,val):\n            ans=-1\n            while left<=right:\n                mid=left+(right-left)//2\n                if arr2[mid]>val:\n                    ans=mid\n                    right=mid-1\n                else:\n                    left=mid+1\n            return ans \n        \n        @lru_cache(None)\n        def helper(i,j,prev):\n            if i>=len(arr1):\n                # arr1 is increasing, we have reached so far\n                return 0\n            else:\n                ans=float('inf')\n                if arr1[i]>prev:\n                    # no need of replacement\n                    ans=min(ans,helper(i+1,j,arr1[i]))\n                    # pick any index from arr2 starting j\n                idx=bsearch(j,len(arr2)-1,prev)\n                if idx!=-1:\n                    ans=min(ans,1+helper(i+1,idx+1,arr2[idx]))\n                return ans\n        ans=helper(0,0,-1)\n        return -1 if ans==float('inf') else ans\n                \n                \n        \n        \n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        #10:04\n        # arr2=list(set(arr2))\n        n=len(arr1)\n        arr2=list(set(arr2))\n        arr2.sort()\n        m=len(arr2)\n        # we might need fix at point 0\n        # hence we will always compare it will\n        def bsearch(left,right,val):\n            ans=-1\n            while left<=right:\n                mid=left+(right-left)//2\n                if arr2[mid]>val:\n                    ans=mid\n                    right=mid-1\n                else:\n                    left=mid+1\n            return ans \n        \n        @lru_cache(None)\n        def helper(i,j,prev):\n            nonlocal n,m\n            if i>=n:\n                # arr1 is increasing, we have reached so far\n                return 0\n            else:\n                ans=float('inf')\n                if arr1[i]>prev:\n                    # no need of replacement\n                    ans=min(ans,helper(i+1,j,arr1[i]))\n                    # pick any index from arr2 starting j\n                idx=bsearch(j,m-1,prev)\n                if idx!=-1:\n                    ans=min(ans,1+helper(i+1,idx+1,arr2[idx]))\n                return ans\n        ans=helper(0,0,-1)\n        return -1 if ans==float('inf') else ans\n                \n                \n        \n        \n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        #10:04\n        # arr2=list(set(arr2))\n        arr2.sort()\n        # we might need fix at point 0\n        # hence we will always compare it will\n        def bsearch(left,right,val):\n            ans=-1\n            while left<=right:\n                mid=left+(right-left)//2\n                if arr2[mid]>val:\n                    ans=mid\n                    right=mid-1\n                else:\n                    left=mid+1\n            return ans\n        \n        @lru_cache(None)\n        def helper(i,j,prev):\n            if i>=len(arr1):\n                # arr1 is increasing, we have reached so far\n                return 0\n            else:\n                ans=float('inf')\n                if arr1[i]>prev:\n                    # no need of replacement\n                    ans=min(ans,helper(i+1,j,arr1[i]))\n                    # pick any index from arr2 starting j\n                idx=bsearch(j,len(arr2)-1,prev)\n                if idx!=-1:\n                    ans=min(ans,1+helper(i+1,idx+1,arr2[idx]))\n                \n                    \n#                 for k in range(j,len(arr2)):\n#                     # can we use binary search here\n#                     # we got to find out the minumum value in arr2 which is greater than prev\n                    \n#                     if arr2[k]>prev:\n#                         # we can probably use binary search here\n#                         # get the first index which is strictly greater than prev\n#                         ans=min(ans,1+helper(i+1,k+1,arr2[k]))\n#                         break\n                return ans\n        ans=helper(0,0,-1)\n        return -1 if ans==float('inf') else ans\n                \n                \n        \n        \n", "import bisect\nclass Solution:\n    def recurse(self,arr1,arr2,m,n,idx,prev,dp):\n        if idx>=n:\n            return 0\n        k=bisect.bisect_right(arr2,prev)\n        if dp[idx][k]!=-1:\n            return dp[idx][k]\n        c1=self.recurse(arr1,arr2,m,n,idx+1,arr1[idx],dp) if arr1[idx]>prev else 2000\n        c2=1+self.recurse(arr1,arr2,m,n,idx+1,arr2[k],dp) if k<m else 2000\n        dp[idx][k]=min(c1,c2)\n        return dp[idx][k]\n     \n\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        dp=[[-1 for i in range(2001)] for j in range(2001)]\n        arr2.sort()\n        self.recurse(arr1,arr2,len(arr2),len(arr1),0,-10**9,dp)\n        if dp[0][0]>=2000:\n            return -1\n        else:\n            return dp[0][0]\n      \n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        # Maintain two dp array: 1 for keep arr1[i], 1 for swap arr1[i] with arr2[j]\n        # Convert arr2 to sorted unique set\n        a = arr1\n        b = sorted(list(set(arr2)))\n        n, m = len(a), len(b)\n        keep = [0, math.inf]  # keep[i] = keep a[i]\n        swap = [[1] * m, [math.inf] * m]  # swap[i][j] = a[i] replaced with b[j]\n\n        prev, curr = 1, 0\n        for i in range(1, n):\n            prev, curr = curr, prev\n            # must init every time\n            swap[curr] = [math.inf] * m\n            keep[curr] = math.inf\n            # keep[i] case 1: a[i] is bigger than previous keep[i-1]\n            if a[i] > a[i - 1]:\n                keep[curr] = keep[prev]\n            for j in range(m):\n                # keep[i] case 2: a[i] is bigger then previous swap value.\n                if a[i] > b[j]:\n                    keep[curr] = min(keep[curr], swap[prev][j])\n                # swap case 1: when a[i-1] keeps\n                if b[j] > a[i - 1]:\n                    swap[curr][j] = min(swap[curr][j], 1 + keep[prev])\n                # Swap case 2: when a[i-1] swapped\n                if j > 0:\n                    # only need to check last swap[i-1][j-1] since swap[][j] decreases when j increases.\n                    swap[curr][j] = min(swap[curr][j], 1 + swap[prev][j - 1])\n\n        res = min(keep[curr], swap[curr][m - 1])\n        return res if res < math.inf else -1", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        #10:04\n        # arr2=list(set(arr2))\n        n=len(arr1)\n        arr2=list(set(arr2))\n        arr2.sort()\n        m=len(arr2)\n        # we might need fix at point 0\n        # hence we will always compare it will\n        def bsearch(left,right,val):\n            ans=-1\n            while left<=right:\n                mid=left+(right-left)//2\n                if arr2[mid]>val:\n                    ans=mid\n                    right=mid-1\n                else:\n                    left=mid+1\n            return ans \n        \n        @lru_cache(None)\n        def helper(i,j,prev):\n            nonlocal n,m\n            if i>=n:\n                # arr1 is increasing, we have reached so far\n                return 0\n            else:\n                ans=float('inf')\n                if arr1[i]>prev:\n                    # no need of replacement\n                    ans=min(ans,helper(i+1,j,arr1[i]))\n                # pick first index from arr2 starting j which is greater than prev\n                idx=bsearch(j,m-1,prev)\n                if idx!=-1:\n                    ans=min(ans,1+helper(i+1,idx+1,arr2[idx]))\n                return ans\n        ans=helper(0,0,-1)\n        return -1 if ans==float('inf') else ans\n\n    \n                \n                \n        \n        \n", "import bisect\nclass Solution:\n    def recurse(self,arr1,arr2,m,n,idx,prev,dp):\n        if idx>=n:\n            return 0\n        k=bisect.bisect_right(arr2,prev)\n        if dp[idx][k]!=-1:\n            return dp[idx][k]\n        c1=self.recurse(arr1,arr2,m,n,idx+1,arr1[idx],dp) if arr1[idx]>prev else 2000\n        c2=1+self.recurse(arr1,arr2,m,n,idx+1,arr2[k],dp) if k<m else 2000\n        dp[idx][k]=min(c1,c2)\n        return dp[idx][k]\n     \n\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        dp=[[-1 for i in range(2001)] for j in range(2001)]\n        arr2.sort()\n        ans=self.recurse(arr1,arr2,len(arr2),len(arr1),0,-10**9,dp)\n        if ans>=2000:\n            return -1\n        else:\n            return ans\n      \n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        # Maintain two dp array: 1 for keep arr1[i], 1 for swap arr1[i] with arr2[j]\n        # Convert arr2 to sorted unique set\n        a = arr1\n        b = sorted(list(set(arr2)))\n        n, m = len(a), len(b)\n        keep = [math.inf] * n  # keep[i] = keep a[i]\n        swap = [[math.inf] * m for _ in range(n)]  # swap[i][j] = a[i] replaced with b[j]\n        # init\n        keep[0] = 0  # keep a[0], no swap\n        swap[0] = [1] * m  # can be swapped with any a[j]\n\n        for i in range(1, n):\n            # keep[i] case 1: a[i] is bigger than previous keep[i-1]\n            if a[i] > a[i - 1]:\n                keep[i] = keep[i - 1]\n            for j in range(m):\n                # keep[i] case 2: a[i] is bigger then previous swap value.\n                if a[i] > b[j]:\n                    keep[i] = min(keep[i], swap[i - 1][j])\n                # swap case 1: when a[i-1] keeps\n                if b[j] > a[i - 1]:\n                    swap[i][j] = min(swap[i][j], 1 + keep[i - 1])\n                # Swap case 2: when a[i-1] swapped\n                if j > 0:\n                    # only need to check last swap[i-1][j-1] since swap[][j] decreases when j increases.\n                    swap[i][j] = min(swap[i][j], 1 + swap[i - 1][j - 1])\n\n        res = min(keep[n - 1], swap[n - 1][m - 1])\n        return res if res < math.inf else -1        ", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        m = len(arr1)\n        n = len(arr2)\n        newarr2 = [arr2[0]]\n        for i in range(1, n):\n            if arr2[i] != newarr2[-1]:\n                newarr2.append(arr2[i])\n                \n        arr2 = newarr2\n        n = len(arr2)\n\n        IL = 10 ** 9 + 7\n        \n        dp = [[IL for j in range(n + 1)] for i in range(m)]\n        \n        dp[0][n] = 0\n        for i in range(n):\n            if arr2[i] < arr1[0]:\n                dp[0][i] = 1\n            else:\n                break\n        \n        for i in range(1, m):\n            idx = 0\n            if arr2[0] > arr1[i - 1]:\n                dp[i][0] = dp[i - 1][n] + 1\n            \n            for k in range(1, n):\n                a = dp[i - 1][n] + 1 if dp[i - 1][n] != IL and arr1[i - 1] < arr2[k] else IL\n                b = dp[i - 1][idx] + 1 if dp[i - 1][idx] != IL else IL\n                dp[i][k] = min(a, b)\n                if dp[i - 1][k] < dp[i - 1][idx]:\n                    idx = k\n                    \n            if dp[i - 1][n] != IL and arr1[i] > arr1[i -1]:\n                dp[i][n] = dp[i - 1][n]\n            \n            for k in range(n):\n                if dp[i - 1][k] != IL and arr2[k] < arr1[i]:\n                    dp[i][n] = min(dp[i][n], dp[i - 1][k])\n                    \n        m = min(dp[m - 1])\n        \n        return m if m != IL else -1\n        \n                \n", "class Solution:    \n    def binary_search_right(self, arr, l, r, t):\n        while l < r:\n            m = l + (r - l) // 2\n            if arr[m] <= t:\n                l = m + 1\n            else:\n                r = m\n        return l\n    \n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n        \n        dp = {}\n        def help(i1, i2):\n            if i1 == len(arr1):\n                return 0\n            \n            if i1 != 0:\n                key = (i1, i2, arr1[i1 - 1])\n            else:\n                key = (i1, i2, None)\n            \n            if key in dp:\n                return dp[key]\n            \n            # print(key)\n            \n            # all possible results\n            pos = []\n            \n            # don't make changes here\n            if i1 == 0 or arr1[i1 - 1] < arr1[i1]:\n                res = help(i1 + 1, i2)\n                if res != -1:\n                    pos.append(res)\n                    \n            if i1 != 0:\n                # make change\n                i2 = self.binary_search_right(arr2, i2, len(arr2), arr1[i1 - 1])\n                if i2 != len(arr2):\n                    tmp = arr1[i1]\n                    arr1[i1] = arr2[i2]\n                    res = help(i1 + 1, i2 + 1)\n                    if res != -1:\n                        pos.append(res + 1)\n                    arr1[i1] = tmp\n            else:\n                # make change\n                if i2 < len(arr2) and arr2[i2] < arr1[i1]:\n                    tmp = arr1[i1]\n                    arr1[i1] = arr2[i2]\n                    res = help(i1 + 1, i2 + 1)\n                    if res != -1:\n                        pos.append(res + 1)\n                    arr1[i1] = tmp\n            \n            if len(pos) == 0:\n                dp[key] = -1\n            else:\n                dp[key] = min(pos)\n            return dp[key]\n        \n        return help(0, 0)", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        n = len(arr1)\n        arr1.insert(0, -1)\n        arr2.sort()\n        \n        # dp[i][k] means the minimum number we can have at ith position with k operations\n        dp = [[sys.maxsize for k in range(n + 1)] for i in range(n + 1)]\n        dp[0][0] = -1\n        \n        for i in range(1, n + 1):\n            for k in range(i + 1):\n                if dp[i - 1][k] < arr1[i]:\n                    # not assign\n                    dp[i][k] = arr1[i]\n                \n                num = self.helper(arr2, dp[i - 1][k - 1])\n                if num > dp[i - 1][k - 1]:\n                    dp[i][k] = min(dp[i][k], num)\n        \n        ans = sys.maxsize\n        for k in range(n + 1):\n            if dp[n][k] < sys.maxsize:\n                ans = min(ans, k)\n        return ans if ans < sys.maxsize else -1\n\n    def helper(self, arr, val):\n        # find in arr the smallest number that is larger than val\n        start, end = 0, len(arr) - 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if arr[mid] <= val:\n                start = mid\n            else:\n                end = mid\n        \n        if arr[start] > val:\n            return arr[start]\n        return arr[end]", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2 = sorted(set(arr2))\n        size1, size2 = len(arr1), len(arr2)\n        Inf = float('inf')\n        keep = [Inf] * size1\n        keep[0] = 0\n        swap = [[Inf] * size2 for _ in range(size1)]\n        swap[0] = [1] * size2\n        for i in range(1, size1):\n            minKeep = minSwap = Inf\n            for j in range(size2):\n                if arr1[i] > arr1[i-1]:\n                    keep[i] = keep[i-1]\n                if arr1[i] > arr2[j]:\n                    minKeep = min(minKeep, swap[i-1][j])\n                if arr2[j] > arr1[i-1]:\n                    swap[i][j] = keep[i-1] + 1\n                if j > 0: # arr2[j] > arr2[j-1] is always True\n                    minSwap = min(minSwap, swap[i-1][j-1] + 1)\n                keep[i] = min(keep[i], minKeep)\n                swap[i][j] = min(swap[i][j], minSwap)\n        res = min(min(swap[-1]), keep[-1])\n        return -1 if res == Inf else res\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        n = len(arr1)\n        arr1.insert(0, -1)\n        arr2.sort()\n        \n        # dp[i][k] means the minimum number we can have at ith position with k operations\n        dp = [[sys.maxsize for k in range(n + 1)] for i in range(n + 1)]\n        dp[0][0] = -1\n        \n        for i in range(1, n + 1):\n            for k in range(i + 1):\n                if dp[i - 1][k] < arr1[i]:\n                    # not assign\n                    dp[i][k] = arr1[i]\n                \n                if k >= 1:\n                    num = self.helper(arr2, dp[i - 1][k - 1])\n                    if num > dp[i - 1][k - 1]:\n                        dp[i][k] = min(dp[i][k], num)\n        \n        ans = sys.maxsize\n        for k in range(n + 1):\n            if dp[n][k] < sys.maxsize:\n                ans = min(ans, k)\n        return ans if ans < sys.maxsize else -1\n\n    def helper(self, arr, val):\n        # find in arr the smallest number that is larger than val\n        start, end = 0, len(arr) - 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if arr[mid] <= val:\n                start = mid\n            else:\n                end = mid\n        \n        if arr[start] > val:\n            return arr[start]\n        return arr[end]", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        n = len(arr1)\n        arr1.insert(0, -1)\n        arr2.sort()\n        # dp[i][k] means the minimum number we can get at arr1[i] using k operations\n        dp = [[sys.maxsize for k in range(n + 1)] for i in range(n + 1)]\n        dp[0][0] = -1\n        \n        for i in range(1, n + 1):\n            for k in range(i + 1):\n                # not changing for arr1[i]\n                if dp[i - 1][k] < arr1[i]:\n                    dp[i][k] = arr1[i]\n                \n                # changing for arr1[i]\n                # find the smallested number in arr2 that is larger than dp[i - 1][k - 1]\n                if k >= 1:\n                    num = self.helper(arr2, dp[i - 1][k - 1])\n                    if num > dp[i - 1][k - 1]:\n                        dp[i][k] = min(dp[i][k], num)\n        \n        ans = sys.maxsize\n        for k in range(0, n + 1):\n            if dp[n][k] < sys.maxsize:\n                ans = min(ans, k)\n        return ans if ans < sys.maxsize else -1\n    \n    def helper(self, arr, val):\n        start, end = 0, len(arr) - 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if arr[mid] <= val:\n                start = mid\n            elif arr[mid] > val:\n                end = mid\n        \n        if arr[start] > val:\n            return arr[start]\n        return arr[end]", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        set2 = set(arr2)\n        arr2 = sorted(set2)\n        N, M = len(arr1), len(arr2)\n        to_index = {}\n        left = 0\n        for x in sorted(arr1):\n            while left < M and arr2[left] <= x:\n                left += 1\n            to_index[x] = left - 1 if left < M else M\n        \n        print(to_index, arr2)\n        dp = [[[None, None] for _ in range(M + 1)] for _ in range(N)]\n        \n        def solve(i, j, k):\n            if i == N: return 0\n            if j > M or (j == M and k == 1): return N+1\n            if dp[i][j][k] is None:\n                if i == 0: \n                    dp[i][j][k] = min(solve(i+1, to_index[arr1[0]], 0), 1 + solve(i+1, 0, 1))\n                else:\n                    result = N + 1\n                    if j < M - 1: \n                        result = 1 + solve(i+1, j+1, 1)\n                    if k == 0 and arr1[i] > arr1[i-1]:\n                        result = min(result, solve(i+1, to_index[arr1[i]], 0))\n                    if k == 1 and arr1[i] > arr2[j]:\n                        result = min(result, solve(i+1, to_index[arr1[i]], 0))\n                    dp[i][j][k] = result\n            return dp[i][j][k]\n        result = solve(0, 0, 0)\n        # for i in range(N):\n        #     for j in range(M):\n        #         for k in [0, 1]:\n        #             print(dp[i][j][k], i, j, k)\n        return result if result <= N else -1", "import bisect\nfrom functools import lru_cache\n\n\nclass Solution:\n    def makeArrayIncreasing(self, A: List[int], B: List[int]) -> int:\n        B = sorted(set(B))\n\n        def find_larger_value_in_B(val):\n            if val >= B[-1]:\n                return float('inf')\n            return B[bisect.bisect_right(B, val)]\n\n        @lru_cache(None)\n        def min_last_value_given_operations(n, ops):\n            if ops < 0:\n                return float('inf')\n            if n == 0:\n                return float('-inf')\n                # return A[n - 1] if first_n_of_A_is_sorted(n) else float('inf')\n\n            ops = min(n, ops)\n            return min(\n                A[n - 1] if min_last_value_given_operations(n - 1, ops) < A[n - 1] else float('inf'),\n                find_larger_value_in_B(min_last_value_given_operations(n - 1, ops - 1)),\n            )\n\n        for ops in range(min(len(A), len(B)) + 1):\n            if min_last_value_given_operations(len(A), ops) < float('inf'):\n                return ops\n\n        return -1\n", "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        ## https://www.youtube.com/watch?v=8ttxdMCU2GE\n        m = len(arr1)\n        ## remove dulpicates and sort arr2\n        arr2 = sorted(list(set(arr2)))\n        # print(arr2)\n        n = len(arr2)\n        swap = [[float('inf') for j in range(n)] for i in range(m)]\n        keep = [float('inf') for i in range(m)]\n        \n        ## initialization\n        keep[0] = 0\n        for j in range(n):\n            swap[0][j] = 1\n            \n        for i in range(1, m):\n            min_keep = float('inf')\n            min_swap = float('inf')\n            for j in range(n):\n                ## two variables to help compute case 3 & 4\n                ## case 4: the last two elements of current valid array are both from arr2\n                if j>0:\n                    min_swap = min(min_swap, swap[i-1][j-1]+1)\n\n                ## case 3: the second to last element is replaced by the previous element arr2[j-1] or earlier elements\n                if arr1[i]>arr2[j]:\n                    min_keep = min(min_keep, swap[i-1][j])\n                    \n                ## case 1: no need to swap; keep arr1[i]\n                if arr1[i]>arr1[i-1]:\n                    keep[i] = keep[i-1]\n                \n                ## case 2: ## replace arr1[i] by arr2[j]\n                if arr2[j]>arr1[i-1]:\n                    swap[i][j] = keep[i-1] + 1\n                \n                ## update\n                swap[i][j] = min(swap[i][j], min_swap)\n                keep[i] = min(keep[i], min_keep)\n                \n        # for i in range(m):\n        #     print(keep[i], swap[i])\n                \n        res = min(min(swap[m-1]), keep[m-1])\n        if res == float('inf'):\n            return -1\n        else:\n            return res\n"]
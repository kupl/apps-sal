["n, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [[0] * m for _ in range(n)]\nans = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if A[i][j] == 1 and A[i + 1][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j + 1] == 1:\n            B[i][j] = 1\n            B[i + 1][j] = 1\n            B[i][j + 1] = 1\n            B[i + 1][j + 1] = 1\n            ans.append([i + 1, j + 1])\nif A == B:\n    print(len(ans))\n    for a, b in ans:\n        print(a, b)\nelse:\n    print(-1)", "n, m = list(map(int, input().split()))\n\nA = [list(map(int, input().split())) for i in range(n)]\n\nB = [[0 for i in range(m)] for j in range(n)]\n\nops = []\n\nfor i in range(n - 1):\n\tfor j in range(m - 1):\n\t\tif all([A[i][j], A[i + 1][j], A[i][j + 1], A[i + 1][j + 1]]):\n\t\t\tops.append((i + 1, j + 1))\n\t\t\tB[i][j] = 1\n\t\t\tB[i + 1][j] = 1\n\t\t\tB[i][j + 1] = 1\n\t\t\tB[i + 1][j + 1] = 1\n\nflag = True\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tflag &= (A[i][j] == B[i][j])\n\nif flag:\n\tprint(len(ops))\n\n\tfor o in ops:\n\t\tprint(*o)\nelse:\n\tprint(-1)\n", "n,m=list(map(int,input().split()))\nA=[]\nfor i in range(n):\n    A.append(list(map(int,input().split())))\n    x=A[-1].count(1)\nres=[]\n\nmarked=[[0]*m for _ in range(n)]\nfor i in range(n-1):\n    for j in range(m-1):\n        if A[i][j]==1:\n            if A[i+1][j]==1 and A[i][j+1]==1 and A[i+1][j+1]==1:\n                marked[i][j]=1\n                marked[i+1][j]=1\n                marked[i+1][j+1]=1\n                marked[i][j+1]=1\n                res.append((i+1,j+1))\nif marked==A:\n    print(len(res))\n    for item in res:\n        print(item[0],item[1])\nelse :\n    print(-1)\n", "n, m = map(int, input().split())\na = [input().split() for _ in range(n)]\nmk = [[0] * m for _ in range(n)]\n\nans = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if a[i][j] == a[i + 1][j] == a[i][j + 1] == a[i + 1][j + 1] == '1':\n            ans.append((i + 1, j + 1))\n            mk[i][j] = mk[i + 1][j] = mk[i][j + 1] = mk[i + 1][j + 1] = 1\n\nif any(a[i][j] == '1' and not mk[i][j] for i in range(n) for j in range(m)):\n    print(-1)\nelse:\n    print(len(ans))\n    print(*('%d %d' % (i, j) for i, j in ans), sep='\\n')", "n,m=list(map(int,input().split()))\nar=[]\nfor x in range(n):\n    e=list(map(int,input().split()))\n    ar.append(e)\ncol=set()\nmoves=[]\nfor i in range(n-1):\n    for j in range(m-1):\n        if(ar[i][j]==ar[i+1][j]==ar[i][j+1]==ar[i+1][j+1]==1):\n            moves.append([i+1,j+1])\n            col.add((i,j))\n            col.add((i+1,j))\n            col.add((i+1,j+1))\n            col.add((i,j+1))\nfor i in range(n):\n    for j in range(m):\n        if(ar[i][j]):\n            if((i,j) not in col):\n                print(-1)\n                quit()\nprint(len(moves))\nfor x in moves:\n    print(*x)\n", "#E71_B\n\nln = [int(i) for i in input().split(\" \")]\nn = ln[0]\nm = ln[1]\n\nmat = []\ngood = []\nfor i in range(0, n):\n    mat.append([int(j) for j in input().split(\" \")])\n    good.append([0] * m)\n\nseq = []\n\nfor i in range(0, n - 1):\n    for j in range(0, m - 1):\n        if mat[i][j] == 1 and mat[i + 1][j] == 1 and mat[i][j + 1] == 1 and mat[i + 1][j + 1] == 1:\n            good[i][j] = True\n            good[i + 1][j] = True\n            good[i][j + 1] = True\n            good[i + 1][j + 1] = True\n            seq.append([i + 1, j + 1])\n\nf = True\n\nfor i in range(0, n):\n    for j in range(0, m):\n        if mat[i][j] == 1 and not good[i][j]:\n            f = False\n\nif not f:\n    print(-1)\nelif len(seq) == 0:\n    print(0)\nelse:\n    print(len(seq))\n    for i in seq:\n        print(\" \".join([str(j) for j in i]))\n", "from sys import stdin\nn,m=list(map(int,stdin.readline().strip().split()))\ns=[]\nfor i in range(n):\n    s.append(list(map(int,stdin.readline().strip().split())))\nb=[[0 for i in range(m)] for j in range(n)]\nans=[]\nfor i in range(n-1):\n    for j in range(m-1):\n        if s[i][j]==1 and s[i+1][j]==1 and s[i+1][j+1]==1 and s[i][j+1]==1:\n            ans.append([i+1,j+1])\n            b[i][j]=1\n            b[i][j+1]=1\n            b[i+1][j]=1\n            b[i+1][j+1]=1\nflag=True\nfor i in range(n):\n    for j in range(m):\n        if(s[i][j]!=b[i][j]):\n            flag=False\n            break\nif flag:\n    print(len(ans))\n    for i in ans:\n        print(*i)\nelse:\n    print(-1)\n", "n, m = list(map(int, input().split()))\nmat = []\nfor i in range(n):\n    mat.append(list(map(int, input().split())))\n\nans = [[0 for i in range(m)] for j in range(n)]\nanslist = []\nfor i in range(n-1):\n    for j in range(m-1):\n        if mat[i][j] == 1 and mat[i][j+1] == 1 and mat[i+1][j] == 1 and mat[i+1][j+1]:\n            for k in range(2):\n                for l in range(2):\n                    ans[i+k][j+l] = 1\n            anslist.append([i+1, j+1])\n\n\nif mat == ans:\n    print(len(anslist))\n    for i, j in anslist:\n        print(i, j)\nelse:\n    print(-1)\n", "import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nn, m = map(int, input().split())\n\na = [list(map(int, input().split())) for i in range(n)]\nb = [[0] * m for i in range(n)]\n\n#print(*a,*b, sep=\"\\n\")\n\nans = []\nfor i in range(n - 1):\n  for j in range(m - 1):\n    if a[i][j] == a[i+1][j] == a[i][j+1] == a[i+1][j+1] == 1:\n      ans.append((i+1, j+1))\n      b[i][j] = b[i+1][j] = b[i][j+1] = b[i+1][j+1] = 1\n\nfor i in range(n):\n  for j in range(m):\n    if a[i][j] != b[i][j]:\n      print(-1)\n      return\n\nprint(len(ans))\nfor i in ans:\n  print(*i)", "n, m = list(map(int, input().split()))\nA = [list(map(int, input().split())) for i in range(n)]\nans = []\nfor i in range(n - 1):\n  for j in range(m - 1):\n    if A[i][j] == 1 and A[i + 1][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j + 1] == 1:\n      ans.append([i, j])\nB = [[0] * m for i in range(n)]\nfor x in ans:\n  B[x[0]][x[1]] = 1\n  B[x[0] + 1][x[1]] = 1\n  B[x[0]][x[1] + 1] = 1\n  B[x[0] + 1][x[1] + 1] = 1\nif (A != B):\n  print(-1)\nelse:\n  print(len(ans))\n  for x in ans:\n    print(x[0] + 1, x[1] + 1)\n", "''' \u0628\u0650\u0633\u0652\u0645\u0650 \u0627\u0644\u0644\u064e\u0651\u0647\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0652\u0645\u064e\u0670\u0646\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0650\u064a\u0645\u0650 '''\n#codeforces1207B_live\ngi = lambda : list(map(int,input().split()))\nn, m = gi()\na = [gi() for _ in range(n)]\nb = [ [0] * m for _ in range(n)]\nans = []\nfor k in range(n - 1):\n\tfor j in range(m - 1):\n\t\tif a[k][j] == a[k][j + 1] == a[k + 1][j] == a[k + 1][j + 1] == 1:\n\t\t\tb[k][j] = b[k][j + 1] = b[k + 1][j] = b[k + 1][j + 1] = 1\n\t\t\tans.append((k + 1, j + 1))\nfor k in range(n):\n\tfor j in range(m):\n\t\tif a[k][j] != b[k][j]:\n\t\t\tprint(-1)\n\t\t\treturn\nprint(len(ans))\nfor e in ans:\n\tprint(*e)", "n, m = map(int, input().split())\nl = [[*map(int, input().split())] for _ in range(n)]\nb = [[0] * m for _ in range(n)]\nres = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if all((l[i][j], l[i + 1][j], l[i][j + 1], l[i + 1][j + 1])):\n            res.append(f'{i + 1} {j + 1}')\n            b[i][j] = b[i + 1][j] = b[i][j + 1] = b[i + 1][j + 1] = 1\nif b == l:\n    print(len(res))\n    print(*res, sep='\\n')\nelse:\n    print(-1)", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=[list(map(int,input().split())) for i in range(n)]\n\nB=[[0]*m for i in range(n)]\n\nANS=[]\n\nfor i in range(n-1):\n    for j in range(m-1):\n        if A[i][j]==A[i+1][j]==A[i][j+1]==A[i+1][j+1]==1:\n            ANS.append((i+1,j+1))\n            B[i][j]=B[i+1][j]=B[i][j+1]=B[i+1][j+1]=1\n\nif A!=B:\n    print(-1)\n\nelse:\n    print(len(ANS))\n    for ans in ANS:\n        print(*ans)\n            \n", "n, m = list(map(int, input().split()))\nli = [list(map(int, input().split())) for _ in range(n)]\nb = [[0 for _ in range(m)] for _ in range(n)]\nres = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if li[i][j] == li[i + 1][j] == li[i][j + 1] == li[i + 1][j + 1] == 1:\n            res.append([i + 1, j + 1])\n            b[i][j] = 1\n            b[i + 1][j] = 1\n            b[i + 1][j + 1] = 1\n            b[i][j + 1] = 1\nif li == b:\n    print(len(res))\n    for i in res:\n        print(*i)\nelse:\n    print(-1)", "def mp():\n    return map(int, input().split())\n\ndef f(i, j):\n    return a[i][j] == a[i + 1][j] == a[i][j + 1] == a[i + 1][j + 1] == 1\n\nn, m = mp()\na = [list(mp()) for i in range(n)]\nb = [[0] * m for i in range(n)]\n\nans = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if f(i, j):\n            ans.append((i + 1, j + 1))\n            b[i][j] = 1\n            b[i][j + 1] = 1\n            b[i + 1][j] = 1\n            b[i + 1][j + 1] = 1\n\nfail = False\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != b[i][j]:\n            fail = True\n\nif fail:\n    print(-1)\nelse:\n    print(len(ans))\n    for i in ans:\n        print(*i)", "r, c = map(int,input().split())\nmat = [list(map(int,input().split())) for i in range(r)]\ndup = [[0 for j in range(c)] for i in range(r)]\nodp = []\nfor i in range(r - 1):\n\tfor j in range(c - 1):\n\t\tif mat[i][j] == 1 and mat[i+1][j] == 1 and mat[i+1][j+1] == 1 and mat[i][j+1] == 1:\n\t\t\todp.append([i,j])\n\t\t\tdup[i][j] = 1\n\t\t\tdup[i][j+1] = 1\n\t\t\tdup[i+1][j] = 1\n\t\t\tdup[i+1][j+1] = 1\nif mat == dup:\n\tprint(len(odp))\n\tfor i in odp:\n\t\tprint(i[0]+1, i[1]+1)\nelse:\n\tprint(-1)", "import io, sys, atexit, os\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nfrom itertools import combinations\n\n\ndef li ():\n\treturn list (map (int, input ().split ()))\n\n\ndef num ():\n\treturn map (int, input ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef lcm ( x, y ):\n\tgg = find_gcd (x, y)\n\treturn (x * y // gg)\n\n\nmm = 1000000007\nyp = 0\n\ndef solve ():\n\tt = 1\n\tfor tt in range (t):\n\t\tn,m=num()\n\t\ta=[0]*n\n\t\txx=[]\n\t\tfl=True\n\t\tb=[0]*n\n\t\tfor i in range(n):\n\t\t\ta[i]=li()\n\t\t\tb[i]=[0]*m\n\t\tfor i in range(n-1):\n\t\t\tfor j in range(m-1):\n\t\t\t\tif(a[i][j]==1 and a[i][j+1]==1 and a[i+1][j]==1 and a[i+1][j+1]==1):\n\t\t\t\t\txx.append((i,j))\n\t\t\t\t\tb [ i ] [ j ] = 1\n\t\t\t\t\tb [ i ] [ j + 1 ] = 1\n\t\t\t\t\tb [ i + 1 ] [ j ] = 1\n\t\t\t\t\tb [ i + 1 ] [ j + 1 ] = 1\n\t\tfor i in range(n):\n\t\t\tfor j in range(m):\n\t\t\t\tif(a[i][j]!=b[i][j]):\n\t\t\t\t\tfl=False\n\t\tif(fl):\n\t\t\tprint(len(xx))\n\t\t\tfor i in range(len(xx)):\n\t\t\t\tprint(xx[i][0]+1,xx[i][1]+1)\n\t\telse:\n\t\t\tprint(-1)\n\n\n\n\n\n\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "n, m = list(map(int, input().split()))\nl = []\nfor i in range(n):\n\tl.append(list(map(int, input().split())))\nb = [[0] * m for _ in range(n)]\nops = []\nfor i in range(n - 1):\n\tfor j in range(m - 1):\n\t\tif l[i][j] == 1 and l[i + 1][j] == 1 and l[i][j + 1] == 1 and l[i + 1][j + 1] == 1:\n\t\t\tops.append([i + 1, j + 1])\n\t\t\tfor x in range(2):\n\t\t\t\tfor y in range(2):\n\t\t\t\t\tb[i + x][j + y] = 1\nif l == b:\n\tprint(len(ops))\n\tfor i in ops:\n\t\tprint(i[0], i[1])\nelse:\n\tprint(-1)\n", "def mi():\n        return list(map(int, input().split()))\n'''\n3 3\n1 1 1\n1 1 1\n0 1 1\n'''\nn,m = mi()\na = [0]*n\nfor i in range(n):\n    a[i] = list(mi())\nout = []\nb = [[0]*m for i in range(n)]\nfor i in range(n-1):\n    for j in range(m-1):\n        if a[i][j]==1 and a[i+1][j]==1 and a[i+1][j+1]==1 and a[i][j+1]==1:\n            out.append(str(i+1)+' '+str(j+1)+'\\n')\n            b[i][j] = b[i+1][j] = b[i+1][j+1] = b[i][j+1] = 1\n        if a[i][j]!=b[i][j]:\n            print(-1)\n            return\nfor i in range(n):\n    for j in range(m):\n        if a[i][j]!=b[i][j]:\n            print(-1)\n            return\nprint(len(out))\nprint(''.join(out))\n", "n,m=map(int,input().split())\nans=[]\nb=[[0]*m for i in range(n)]\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nfor i in range(n-1):\n    for j in range(m-1):\n        if a[i][j]==1 and a[i+1][j]==1 and a[i][j+1]==1 and a[i+1][j+1]==1:\n            b[i][j]=1\n            b[i+1][j]=1\n            b[i][j+1]=1\n            b[i+1][j+1]=1\n            ans.append([i+1,j+1])\nif b!=a:\n    print(-1)\nelse:\n    print(len(ans))\n    for i in range(len(ans)):\n        print(*ans[i])", "n,m=[int(x) for x in input().split()]\nb=[[0]*m for i in range(n)]\na=[]\narr=[]\nfor i in range(n):\n    c=[int(x) for x in input().split()]\n    a.append(c)\nfor i in range(n-1):\n    for j in range(m-1):\n        if a[i][j]==a[i+1][j]==a[i][j+1]==a[i+1][j+1]==1:\n            b[i][j]=b[i+1][j]=b[i][j+1]=b[i+1][j+1]=1\n            arr.append((i+1,j+1))\nfor i in range(n):\n    for j in range(m):\n        if a[i][j]!=b[i][j]:\n            print(-1)\n            return\nprint(len(arr))\nfor item in arr:\n    print(*item)\n    \n    \n", "from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations\nimport sys\nimport bisect\nimport string\nsys.setrecursionlimit(10**6)\ndef SI():\n    return input().split()\ndef MI():\n    return list(map(int,input().split()))\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\nYN=['Yes','No']\nmo=10**9+7\n\na=[]\nn,m=MI()\nfor i in range(n):\n    h=LI()\n    a.append(h)\nb=[[0]*m for i in range(n)]\nans=[]\nfor r in range(n-1):\n    for c in range(m-1):\n        if a[r][c]+a[r+1][c]+a[r][c+1]+a[r+1][c+1]==4:\n            ans+=[(r+1,c+1)]\n            b[r][c]=1\n            b[r][c+1]=1\n            b[r+1][c]=1\n            b[r+1][c+1]=1\n\nif a==b:\n    print(len(ans))\n    for j in ans:\n        print(*j)\nelse:\n    print(-1)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nimport math\nimport copy\n \n#T = int(input())\n#N = int(input())\n#s = input()\nN,M = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n \ndata = [[0]*M for _ in range(N)]\nB = [[0]*M for _ in range(N)]\n\nfor i in range(N):\n    arr = [int(x) for x in stdin.readline().split()]\n    \n    for j in range(M):\n        data[i][j] = arr[j]\n\nans = []\n        \nfor i in range(N-1):\n    for j in range(M-1):\n        A = data[i][j]\n        b = data[i][j+1]\n        c = data[i+1][j]\n        d = data[i+1][j+1]\n        \n        if A==1 and b==1 and c==1 and d==1:\n            ans.append((i+1,j+1))\n            B[i][j] = 1\n            B[i+1][j] = 1\n            B[i][j+1] = 1\n            B[i+1][j+1] = 1\n            \nfor i in range(N):\n    for j in range(M):\n        if data[i][j]!=B[i][j]:\n            print(-1)\n            quit()\n            \nprint(len(ans))\nfor i in range(len(ans)):\n    print(*ans[i])\n        \n\n        \n", "n, m = map(int, input().split())\n\na = [list(map(int, input().split())) for _ in range(n)]\n\nb = [[0] * m for _ in range(n)]\n\nop = []\n\nfor i in range(n-1):\n\tfor j in range(m-1):\n\t\tif a[i][j] == a[i+1][j] == a[i][j+1] == a[i+1][j+1] == 1:\n\t\t\top.append((i, j))\n\t\t\tb[i][j] = b[i+1][j] = b[i][j+1] = b[i+1][j+1] = 1\n\nok = True\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif a[i][j] != b[i][j]:\n\t\t\tok = False\n\nif not ok:\n\tprint(-1)\nelse:\n\tprint(len(op))\n\tfor x in op:\n\t\tprint(x[0]+1, x[1]+1)"]
["from collections import defaultdict\n\n\nclass RobotRapping():\n    def __init__(self, n, m, battles):\n        self.n, self.m = n, m\n        self.battles = battles\n\n    def generate_graph(self, k):\n        edge_map = defaultdict(list)\n        rev_map = defaultdict(list)\n        for i in range(k):\n            edge_map[self.battles[i][0]-1].append((self.battles[i][1]-1, i))\n            rev_map[self.battles[i][1]-1].append((self.battles[i][0]-1, i))\n        return edge_map, rev_map\n\n    def check_order(self, num_battles):\n        edge_map, rev_map = self.generate_graph(num_battles)\n        outgoing_cnt = defaultdict(int)\n        for k in edge_map:\n            outgoing_cnt[k] = len(edge_map[k])\n        s = []\n        cntr = 0\n        for i in range(self.n):\n            if outgoing_cnt[i] == 0:\n                s.append(i)\n        while len(s) > cntr:\n            if len(s) > cntr+1 :\n                return False\n            else:\n                node = s[cntr]\n                for v in rev_map[node]:\n                    outgoing_cnt[v] -= 1\n                    if outgoing_cnt[v] == 0:\n                        s.append(v)\n                cntr += 1\n        return True\n\n    def min_battles(self):\n        if not self.check_order(self.m):\n            print(-1)\n        else:\n            mn, mx = 0, self.m\n            while mn < mx-1:\n                md = int((mn+mx)/2)\n                if self.check_order(md):\n                    mx = md\n                else:\n                    mn = md\n            print(mx)\n\n\n    def min_battles2(self):\n        edge_map, rev_map = self.generate_graph(self.m)\n        outgoing_cnt = defaultdict(int)\n        for k in edge_map:\n            outgoing_cnt[k] = len(edge_map[k])\n        s = []\n        cntr = 0\n        order = []\n        for i in range(self.n):\n            if outgoing_cnt[i] == 0:\n                s.append(i)\n        while len(s) > cntr:\n            if len(s) > cntr+1 :\n                print(-1)\n                return\n            else:\n                node = s[cntr]\n                order.append(node)\n                for v,_ in rev_map[node]:\n                    outgoing_cnt[v] -= 1\n                    if outgoing_cnt[v] == 0:\n                        s.append(v)\n                cntr += 1\n        mn_pos = -1\n        for i in range(1,self.n):\n            for v,ind in edge_map[order[i]]:\n                if v == order[i-1]:\n                    mn_pos = max(mn_pos, ind)\n                    break\n        print(mn_pos+1)\n\nn,m = list(map(int,input().strip(' ').split(' ')))\nbattles = []\nfor i in range(m):\n    x,y = list(map(int,input().strip(' ').split(' ')))\n    battles.append((x,y))\nrr = RobotRapping(n,m,battles)\nrr.min_battles2()\n", "from heapq import heappop,heappush\n\nn,m = list(map(int,input().split()))\n\nC = [[] for _ in range(n)]\nindeg = [0]*n\n\ndef toposort():\n    S = [i for i in range(n) if indeg[i] == 0]\n    nparent = indeg[:]\n    topo = []\n    while S:\n        cur = S.pop()\n        topo.append(cur)\n        for neigh,_ in C[cur]:\n            nparent[neigh] -= 1\n            if nparent[neigh] == 0:\n                S.append(neigh)\n    return topo\n\ndef solve():\n    topo = toposort()\n\n    D = [(0,0)]*n\n    for cur in topo:\n        for neigh,t in C[cur]:\n            cd,ct = D[cur]\n            nd,_ = D[neigh]\n            if nd <= cd + 1:\n                D[neigh] = cd + 1, max(ct,t)\n\n    d,t = max(D)\n    return t+1 if d == n-1 else -1\n        \n\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    C[a-1].append((b-1, _))\n    indeg[b-1] += 1\n\nprint(solve())\n", "n, m = [int(i) for i in input().split()]\nn += 1 # one-indexed\nA = [[int(i) for i in input().split()] for j in range(m)]\nm += 1\n\ndef check(upper):\n    p = [[] for i in range(n)]\n    d = [0] * n #record num of parents\n    for u, v in A[:upper]:\n        p[u].append(v) # form arc from u to v\n        d[v] += 1\n    if d.count(0) > 2:\n        return False\n    x = d.index(0, 1) # find the real ancestor, should only be one\n    while x:\n        q, x = p[x], 0\n        for y in q:\n            d[y] -= 1\n            if d[y] == 0:\n                if x: \n                    return False\n                x = y\n    return True\n\nleft, right = 1, m\nwhile left < right:\n    mid = (left + right)//2\n    if check(mid): \n        right = mid\n    else:\n        left = mid + 1 \nif check(left):\n    print(left)\nelse:\n    print(-1)\n", "n, m = [int(i) for i in input().split()]\nn += 1 # one-indexed\nA = [[int(i) for i in input().split()] for j in range(m)]\nm += 1\n\ndef check(upper):\n    p = [[] for i in range(n)]\n    d = [0] * n #record num of parents\n    for u, v in A[:upper]:\n        p[u].append(v) # form arc from u to v\n        d[v] += 1\n    if d.count(0) > 2:\n        return False\n    x = d.index(0, 1) # find the real ancestor, should only be one\n    while x:\n        q, x = p[x], 0\n        for y in q:\n            d[y] -= 1\n            if d[y] == 0:\n                if x: \n                    return False\n                x = y\n    return True\n\nleft, right = 1, m\nwhile left < right:\n    mid = (left + right)//2\n    if check(mid): \n        right = mid\n    else:\n        left = mid + 1 \nif check(left):\n    print(left)\nelse:\n    print(-1)", "from sys import stdin, stdout\nimport sys\nimport bisect\nimport heapq\ninput = sys.stdin.readline\n\n\ndef solve(n, m, edges):\n    \n    lo = 0\n    hi = m\n\n    curr_k = -1\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n\n        can_do = True\n\n        # condition\n\n        adj_list = {x: [] for x in range(0, n)}\n        in_degree = [0] * n\n        for ed in range(min(mid, len(edges))):\n            edge = edges[ed]\n            adj_list[edge[0]].append(edge[1])\n            in_degree[edge[1]] += 1\n        candidates = []\n        for i in range(len(in_degree)):\n            if in_degree[i] == 0:\n                candidates.append(i)\n        res = []\n        while candidates:\n            ele = candidates.pop(0)\n            if len(candidates) > 0:\n                can_do = False\n                break\n            res.append(ele)\n            for i in adj_list[ele]:\n                in_degree[i] -= 1\n                if in_degree[i] == 0:\n                    candidates.append(i)\n        \n        if len(res) < n:\n            can_do = False\n\n        if can_do:\n            curr_k = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n\n    return curr_k\n\ndef main():\n    n, m = list(map(int, input().split()))\n    \n    edges = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        edges.append([a - 1, b - 1])\n    stdout.write(str(solve(n, m, edges)))\n    stdout.write(\"\\n\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
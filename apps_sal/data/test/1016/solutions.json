["def dfs(v, root):\n    nonlocal cnt\n    if used[v]:\n        return\n    used[v] = True\n    for j in range(len(G[v])):\n        to = G[v][j]\n        dfs(to, root)\n    if v == root:\n        cnt += 1\n\ncnt = 0\nn, e = map(int, input().split())\nG = [[] for i in range(n)]\nfor i in range(e):\n    a, b = map(lambda x:int(x) - 1, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nused = [False for i in range(n)]\nfor v in range(n):\n    dfs(v, v)\nprint(2 ** (n - cnt))", "def dfs(t):\n    nonlocal used,g\n    used[t]=True\n    for k in g[t]:\n        if not used[k]:\n            used[k]=True\n            dfs(k)\n\n\n\nn,m=map(int,input().split())\ng=[[] for i in range(n)]\nfor i in range(m):\n    x,y=map(int,input().split())\n    g[x-1].append(y-1)\n    g[y-1].append(x-1)\nused=[False]*n\nans=n\nfor i in range(n):\n    if not used[i]:\n        ans-=1\n        dfs(i)\nprint(2**ans)", "import itertools\n\na, b = list(map(int, input().split()))\n\ndang = 1\n\n#w = [x+1 for x in range(a)]\nr = [(x, set()) for x in range(a)]\n\nfor i in range(b):\n     x, y = list(map(int, input().split()))\n     x, y = x-1, y-1\n\n     r[x][1].add(y)\n     r[y][1].add(x)\n\n\nr = sorted(r, key=lambda x: len(x[1]), reverse=True)\nwillreact = r[0][1]\ndel r[0]\n\n#print('r:', r)\n#print('wr:', willreact)\n\nwhile len(r) > 0:\n    dr = 0\n    for i in range(len(r)):\n        if r[i][0] in willreact:\n            willreact |= r[i][1]\n            dang *= 2\n            del r[i]\n            dr = 1\n            break\n    if dr == 0:\n        willreact |= r[0][1]\n        del r[0]\n\nprint(dang)\n", "import sys\nf = sys.stdin\nn, m = map(int, f.readline().strip().split())\n\nd = [{} for u in range(n)]\nfor i in range(m):\n    xi, yi = map(int, f.readline().strip().split())\n    d[yi-1][xi-1]=1\n    d[xi-1][yi-1]=1\n\ndef ff(i,s):\n    for k in d[i]:\n        #print('loc ', i, d, k, s)\n        if rt[k]==0:\n            rt[k] = s\n            ff(k,s)\n           # print('loc1 ', i, d, k, s)\n\ns = 0\nrt = [0 for u in range(n)]\nfor i in range(n):\n    if rt[i]==0:\n        s += 1\n        rt[i] = s\n        ff(i,s)\n        #print('gl ', rt, d, i, s)\n \nprint(2 ** (n-s))       ", "from sys import setrecursionlimit\nsetrecursionlimit(10000)\n\nn, m = list(map(int, input().split()))\n\na = [[False for j in range(n + 1)] for i in range(n + 1)]\nb = [False for i in range(n + 1)]\n\nfor i in range(m):\n    x, y = list(map(int, input().split()))  \n    a[x][y] = True\n    a[y][x] = True\n  \ndef r(i):\n    if b[i]:\n        return 0\n    b[i] = True\n    s = 0\n    for j in range(1, n + 1):\n        if a[i][j]:\n            s += r(j)\n    return s + 1\n\no = 1\nfor i in range(1, n + 1):\n    if not b[i]:\n        o *= 2 ** (r(i) - 1)\nprint(o)", "used = set()\n\ndef dfs(v, root):\n\tnonlocal cnt\n\tif v in used:\n\t\treturn\n\tused.add(v)\n\tfor to in G[v]:\n\t\tdfs(to, root)\n\tif v == root:\n\t\tcnt += 1\n\ncnt = 0\nn, m = list(map(int, input().split()))\nG = [[] for i in range(n)]\n\nfor i in range(m):\n\tx, y = list(map(int, input().split()))\n\tG[x-1].append(y-1)\n\tG[y-1].append(x-1)\n\nfor v in range(n):\n\tdfs(v, v)\nprint(2**(n-cnt))\n", "def dfs(t):\n    nonlocal used, g\n    used[t] = True\n    for k in g[t]:\n        if not used[k]:\n            used[k] = True\n            dfs(k)\n\nn, m = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    x, y = map(lambda e: int(e) - 1, input().split())\n    g[x] += [y]\n    g[y] += [x]\nused = [False] * n\nr = n\nfor i in range(n):\n    if not used[i]:\n        r -= 1\n        dfs(i)\nprint(2 ** r)", "n, m = map(int, input().split())\n\ng = [[False] * n for i in range(n)]\n\nfor i in range(m):\n  x, y = map(int, input().split())\n  x -= 1\n  y -= 1\n  g[x][y] = g[y][x] = True\n\nu = [False] * n\nd = 1\n\ndef dfs(p):\n  nonlocal d\n  for j in range(n):\n    if g[p][j] and not u[j]:\n      u[j] = True\n      d *= 2\n      dfs(j)\n\nfor i in range(n):\n  if not u[i]:\n    u[i] = True\n    dfs(i)\n\nprint(d)", "used = set()\n\ndef dfs(v,root):\n       nonlocal cnt\n       if v in used:\n              return\n       used.add(v)\n       for to in G[v]:\n              dfs(to,root)\n       if v == root:\n              cnt += 1\n\ncnt = 0\nn,m = list(map(int,input().split()))\nG = [[] for i in range(n)]\n\nfor i in range(m):\n       x, y = list(map(int,input().split()))\n       G[x-1].append(y-1)\n       G[y-1].append(x-1)\n\nfor v in range(n):\n       dfs(v,v)\nprint(2**(n-cnt))\n", "#!/usr/env python3\npath = []\ndef dfs(graph, node):\n    nonlocal path\n    path.append(node)\n    for i in graph.get(node):\n        if i not in path:\n            dfs(graph, i)\n\nn, m = list(map(int, input().split()))\na = {}\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    if x not in a:\n        a.setdefault(x, [y])\n    else:\n        a[x].append(y)\n    if y not in a:\n        a.setdefault(y, [x])\n    else:\n        a[y].append(x)\nfor i in range(1, n+1):\n    if i not in a:\n        a.setdefault(i, [])\n\ndfs(a, 1)\ntotalpath = []\nt = 0\nfor i in range(2, n+1):\n#    print(i - 1, path, sorted(totalpath))\n    if len(path) > 1:\n        t += len(path) - 1\n    totalpath += path\n    path = []\n    if i not in totalpath:\n        dfs(a, i)\n\nprint(2 ** t)\n", "def dfs(i):\n    used[i] = True;\n    for j in graph[i]:\n        if not used[j]:\n            dfs(j)\n\nn, m = list(map(int, input().split()))\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1;\n    b -= 1;\n    graph[a] += [b]\n    graph[b] += [a]\nused = [False for i in range(n)]\ncc = 0\nfor i in range(n):\n    if not used[i]:\n        cc += 1;\n        dfs(i)\nprint(1 << (n - cc))\n", "def find(fa, x) : \n    if fa[x] == x :\n        return x\n    else :\n        fa[x] = find(fa, fa[x])\n        return fa[x]\nn, m = list(map(int, input().split()))\nfa = []\nfor i in range(n) :\n    fa.append(i)\nans = 1\nfor i in range(m) :\n    x, y = [int(x) - 1 for x in input().split()]\n    if find(fa, x) != find(fa, y) :\n        ans *= 2\n        fa[find(fa, x)] = fa[y]\nprint(ans)\n\n", "def dfs(v):\n    used[v] = 1\n    for i in graph[v]:\n        if not used[i]:\n            dfs(i)\n\nn, m = map(int, input().split())\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a - 1] += [b - 1]\n    graph[b - 1] += [a - 1]\nused = [0 for i in range(n)]\n\ncounter = 0\nfor i in range(n):\n    if not used[i]:\n        dfs(i)\n        counter += 1\nprint(2 ** (n - counter))", "def find(x):\n    if p[x] == x:\n        return x\n    else:\n        p[x] = find(p[x])\n        return p[x]\n\n\ndef union(a, b):\n    a = find(a)\n    b = find(b)\n    if rank[a] < rank[b]:\n        p[a] = b\n    else:\n        p[b] = a\n    if rank[a] == rank[b]:\n        rank[a] += 1\n\n\nn, m = list(map(int, input().split()))\nrank = [0 for i in range(n)]\np = []\nfor i in range(n):\n    p.append(i)\n\nans = 1\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if find(a-1) != find(b-1):\n        union(a-1, b-1)\n        ans *= 2\nprint(ans)\n", "def main():\n    def dfs(v):\n        used[v] = 1\n        for i in graph[v]:\n            if not used[i]:\n                dfs(i)\n    \n    n, m = [int(i) for i in input().split()]\n    graph = [[] for i in range(n)]\n    \n    for i in range(m):\n        x, y = [int(i) for i in input().split()]\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n    \n    used = [0 for i in range(n)]\n    \n    components = 0\n    for i in range(n):\n        if not used[i]:\n            components += 1\n            dfs(i)\n    \n    print(2 ** (n - components))\n\nmain()\n", "import sys\n\ndef addEdge(n0,n1,graph):\n  if (n0 in graph):\n    graph[n0] = graph[n0] + [n1]\n  else:\n    graph[n0] = [n1]\n\ndef flatten(listOfLists):\n  newlist = []\n  for l in listOfLists:\n    newlist=newlist+l\n  return newlist\n\ndef zusKomp2(graph):\n  nodes=list(graph.keys())\n  zusKompn = {}\n  for node in nodes:\n    if node in flatten(list(zusKompn.values())):\n      continue\n    pointer = 0\n    zusKompn[node] = [node]\n    while pointer < len(zusKompn[node]):\n      posNewNodes = graph[zusKompn[node][pointer]]\n      for n in posNewNodes:\n        if n not in zusKompn[node]:\n          zusKompn[node].append(n)\n      pointer = pointer+1\n\n  return zusKompn\n\nx = sys.stdin.read()\nls = x.splitlines()\n\nns, ms = ls[0].split()\nn,m = int(ns),int(ms)\n\ngraph = {}\n\nfor l in ls[1:]:\n  nodes = l.split()\n  n0,n1 = int(nodes[0]),int(nodes[1])\n  addEdge(n0,n1,graph)\n  addEdge(n1,n0,graph)\n\nisolatednodes = set(range(1,n+1)) - set(graph.keys())\nfor i in isolatednodes:\n  graph[i] = []\n\n#print(\"graph:\",graph)\n#print(\"isoliert:\",isolatednodes)\nzusKompn = zusKomp2(graph)\n#print(\"Zusammenhangskomponenten:\",zusKompn)\n\nprint(2**(sum(list([len(x)-1 for x in list(zusKompn.values())]))))\n\n\n\n", "idx=[]\nsize=[]\ndef root(x):\n    while x!=idx[x]:\n        #path compression start\n        idx[x]=idx[idx[x]]\n        #path compression end\n        x=idx[x]\n    return x\n\ndef connected(p, q):\n    return root(p)==root(q)\n\ndef union(p, q):\n    i=root(p)\n    j=root(q)\n\n    if size[i]<size[j]:\n        idx[i]=j\n        size[j]+=size[i]\n    else:\n        idx[j]=i\n        size[i]+=size[j]\n\nsa=input().split(' ')\nchems=int(sa[0])\nreacts=int(sa[1])\nfor t in range(chems):\n    idx.append(t)\n    \nsize=[1]*chems\n\nfor reaction in range(reacts):\n    sa=input().split(' ')\n    union(int(sa[0])-1, int(sa[1])-1)\nfor t in range(len(idx)):\n    idx[t]=root(idx[t])\nprint(2**(chems-len(set(idx))))\n", "n, m = map(int, input().split())\np = list(range(n + 1))\ns = [{i} for i in p]\nfor i in range(m):\n    x, y = map(int, input().split())\n    x, y = p[x], p[y]\n    if x != y:\n        if len(s[x]) < len(s[y]):\n            for k in s[x]:\n                p[k] = y\n                s[y].add(k)\n            s[x].clear()\n        else:\n            for k in s[y]:\n                p[k] = x\n                s[x].add(k)\n            s[y].clear()\nq = 0\nfor p in s:\n    if p: q += len(p) - 1\nprint(1 << q)", "def dfs (a, vis, mr):\n    mr[0]+=1\n    vis[a]=1\n    for g in range (0,len(r[a])):\n        if (vis[r[a][g]]==1):\n            continue\n        dfs(r[a][g], vis, mr)\n        \nx=input(\"\").split(' ')\nnodes=int(x[0])\npaths=int(x[1])\nr=[]\nfor g in range (3000):\n    r.append([])\nvis=[0]*3000\nfor g in range (paths):\n    m=input(\"\").split(' ')\n    rrr=int(m[0])\n    rr=int(m[1])\n    r[rrr].append(rr)\n    r[rr].append(rrr)\nans=1\nfor g in range (1,nodes+1):\n    mr=[0]\n    if (vis[g]==1):\n        continue\n    l=dfs(g, vis,mr)\n    ans*=pow(2,mr[0]-1)\nprint(ans)\n", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\ndef iterative_dfs(graph, start, path=[]):\n  '''iterative depth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if v not in path:\n      path=path+[v]\n      q=graph[v]+q\n  return path\n\ndef iterative_bfs(graph, start, path=[]):\n  '''iterative breadth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if not v in path:\n      path=path+[v]\n      q=q+graph[v]\n  return path\n\nnodes, edges = list(map(int, input().split(' ')))\ngraph = {}\nfor i in range(nodes):\n  graph[i] = []\n\nfor i in range(edges):\n  a, b = list(map(int, input().split(' ')))\n  graph[a-1].append(b-1)\n  graph[b-1].append(a-1)\n\nmarked = [False] * nodes\nnum = 0\nfor i in range(nodes):\n  if not marked[i]:\n    for j in iterative_dfs(graph, i):\n      marked[j] = True\n    num += 1\n\nprint(2**(nodes-num))\n##graph = {'A':['B','C'],'B':['D','E'],'C':['D','E'],'D':['E'],'E':['A']}\n##graph = {0: [1, 4, 5, 9], 1: [0, 2, 4, 6, 8], 2: [1, 3, 5, 7, 8], 3: [2, 7, 9], 4: [0, 1, 9], 5: [0, 2, 9], 6: [1, 9], 7: [2, 3, 9], 8: [1, 2], 9: [0, 3, 4, 5, 6, 7]}\n##graph = {'A':['B'], 'B':['A', 'C'], 'C':['B', 'D'], 'D':['C', 'E'], 'E':['D'], 'F':['G'], 'G':['F']}\n##print('recursive dfs ', recursive_dfs(graph, 'A'))\n##print('iterative dfs ', iterative_dfs(graph, 'A'))\n##print('iterative bfs ', iterative_bfs(graph, 'A'))\n", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\ndef iterative_dfs(graph, start, path=[]):\n  '''iterative depth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if v not in path:\n      path=path+[v]\n      q=graph[v]+q\n  return path\n\ndef iterative_bfs(graph, start, path=[]):\n  '''iterative breadth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if not v in path:\n      path=path+[v]\n      q=q+graph[v]\n  return path\n\nnodes, edges = list(map(int, input().split(' ')))\ngraph = {}\nfor i in range(nodes):\n  graph[i] = []\n\nfor i in range(edges):\n  a, b = list(map(int, input().split(' ')))\n  graph[a-1].append(b-1)\n  graph[b-1].append(a-1)\n\nmarked = [False] * nodes\nnum = 0\nfor i in range(nodes):\n  if not marked[i]:\n    for j in recursive_dfs(graph, i):\n      marked[j] = True\n    num += 1\n\nprint(2**(nodes-num))\n##graph = {'A':['B','C'],'B':['D','E'],'C':['D','E'],'D':['E'],'E':['A']}\n##graph = {0: [1, 4, 5, 9], 1: [0, 2, 4, 6, 8], 2: [1, 3, 5, 7, 8], 3: [2, 7, 9], 4: [0, 1, 9], 5: [0, 2, 9], 6: [1, 9], 7: [2, 3, 9], 8: [1, 2], 9: [0, 3, 4, 5, 6, 7]}\n##graph = {'A':['B'], 'B':['A', 'C'], 'C':['B', 'D'], 'D':['C', 'E'], 'E':['D'], 'F':['G'], 'G':['F']}\n##print('recursive dfs ', recursive_dfs(graph, 'A'))\n##print('iterative dfs ', iterative_dfs(graph, 'A'))\n##print('iterative bfs ', iterative_bfs(graph, 'A'))\n", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\ndef iterative_dfs(graph, start, path=[]):\n  '''iterative depth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if v not in path:\n      path=path+[v]\n      q=graph[v]+q\n  return path\n\ndef iterative_bfs(graph, start, path=[]):\n  '''iterative breadth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if not v in path:\n      path=path+[v]\n      q=q+graph[v]\n  return path\n\nnodes, edges = list(map(int, input().split(' ')))\ngraph = {}\nfor i in range(nodes):\n  graph[i] = []\n\nfor i in range(edges):\n  a, b = list(map(int, input().split(' ')))\n  graph[a-1].append(b-1)\n  graph[b-1].append(a-1)\n\nmarked = [False] * nodes\nnum = 0\nfor i in range(nodes):\n  if not marked[i]:\n    for j in iterative_bfs(graph, i):\n      marked[j] = True\n    num += 1\n\nprint(2**(nodes-num))\n##graph = {'A':['B','C'],'B':['D','E'],'C':['D','E'],'D':['E'],'E':['A']}\n##graph = {0: [1, 4, 5, 9], 1: [0, 2, 4, 6, 8], 2: [1, 3, 5, 7, 8], 3: [2, 7, 9], 4: [0, 1, 9], 5: [0, 2, 9], 6: [1, 9], 7: [2, 3, 9], 8: [1, 2], 9: [0, 3, 4, 5, 6, 7]}\n##graph = {'A':['B'], 'B':['A', 'C'], 'C':['B', 'D'], 'D':['C', 'E'], 'E':['D'], 'F':['G'], 'G':['F']}\n##print('recursive dfs ', recursive_dfs(graph, 'A'))\n##print('iterative dfs ', iterative_dfs(graph, 'A'))\n##print('iterative bfs ', iterative_bfs(graph, 'A'))\n", "n, m = map(int, input().split())\ne = [[] for x in range(n + 1)]\nfor i in range(m):\n    x, y = map(int, input().split())\n    e[x].append(y)\n    e[y].append(x)\nc = set(range(1, n + 1))\nval = 2 ** n\nwhile c:\n    s = c.pop()\n    dfs = [s]\n    val //= 2\n    while dfs:\n        cur = dfs.pop()\n        for nxt in e[cur]:\n            if nxt in c:\n                dfs.append(nxt)\n                c.remove(nxt)\nprint(val)", "def iterative_dfs(graph, start, path=[]):\n    visited = {}\n    for i in graph:\n        visited[i] = []\n    q=[start]\n    while q:\n        v=q.pop(0)\n        if not visited[v]:\n            visited[v] = True\n            path=path+[v]\n            q=graph[v]+q\n    return path\n    \nnodes, edges = list(map(int, input().split(' ')))\ngraph = {}\nfor i in range(nodes):\n  graph[i] = []\n\nfor i in range(edges):\n  a, b = list(map(int, input().split(' ')))\n  graph[a-1].append(b-1)\n  graph[b-1].append(a-1)\n\nmarked = [False] * nodes\nnum = 0\nfor i in range(nodes):\n  if not marked[i]:\n    for j in iterative_dfs(graph, i):\n      marked[j] = True\n    num += 1\nprint(2**(nodes-num))\n", "# 445B\n\n__author__ = 'artyom'\n\nread = lambda: map(int, input().split())\nn, m = read()\ngraph = [set() for _ in range(n + 1)]\nfor __ in range(m):\n  x, y = read()\n  graph[x].add(y)\n  graph[y].add(x)\n\nvisited = set()\n\n\ndef dfs(start, counter):\n  stack = [start]\n  while stack:\n    vertex = stack.pop()\n    if vertex not in visited:\n      counter *= 2\n      visited.add(vertex)\n      stack.extend(graph[vertex] - visited)\n  return counter // 2\n\n\nres = 1\nfor v in range(1, n + 1):\n  if v not in visited:\n    res = dfs(v, res)\n\nprint(res)"]
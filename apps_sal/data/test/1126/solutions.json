["import sys\nimport numpy as np\nimport math\nimport collections\nimport copy\nimport decimal\nfrom collections import deque \nfrom functools import reduce\nfrom itertools import product\nfrom itertools import combinations\nN, X, M = list(map(int, input().split()))\n\n# X^2\u304cM\u3088\u308a\u5927\u304d\u3044\u5834\u5408\u306fM\u3067\u5272\u3063\u305f\u4f59\u308a\u3001\u5c0f\u3055\u3051\u308c\u3070\u305d\u306e\u307e\u307e\u3092\u8fd4\u5374\ndef f(X, M):\n    if X**2 >= M:\n        return X**2 % M\n    else:\n        return X**2\n\nappear = np.full(M, -1)\nseq = []\nfx = X\nappear[fx] = 0\nseq.append(fx)\nfor i in range(1, N):\n    fx = f(fx, M)\n#     print(fx, appear[fx])\n    if appear[fx] != -1:\n        loop_st = appear[fx]\n        loop_en = i\n        break\n    seq.append(fx)\n    appear[fx] = i\nseq.insert(0, 0)\nseq_sum = np.cumsum(seq)\n\nif N <= len(seq)-1 :\n    print((seq_sum[N]))\nelse:\n    # \u30eb\u30fc\u30d7\u306e\u524d\u307e\u3067\n    lp_b = seq_sum[loop_st-1]\n    # \u30eb\u30fc\u30d7\u3057\u3066\u3044\u308b\u500b\u6570\u3092\u6c42\u3081\u308b\n    loop_num = (len(seq_sum)-1) - loop_st\n    # \u5546\u306f\u30eb\u30fc\u30d7\u56de\u6570\u3001\u4f59\u308a\u306f\u30eb\u30fc\u30d7\u3057\u304d\u3089\u306a\u304b\u3063\u305f\u5206\n    qu = (N-(loop_st)) // loop_num\n    mo = (N-(loop_st)) % loop_num\n    # \u30eb\u30fc\u30d7\u3057\u305f\u5206\u3060\u3051\u304b\u3051\u308b\n    lp_sum = (seq_sum[-1] - seq_sum[loop_st]) * qu\n    # \u6700\u5f8c\u306e\u4f59\u308a\u306e\u90e8\u5206\u3092\u52a0\u7b97\n    lp_en = seq_sum[loop_st+mo] - seq_sum[loop_st-1]\n    print((lp_b+lp_sum+lp_en))\n    \n", "n,x,m=map(int,input().split())\nused=[0]*m\nused[x]=1\nl=[x]\nwhile True:\n    x=x**2%m\n    if used[x]==1:\n        break\n    else:\n        used[x]=1\n        l.append(x)\na=len(l)\nfor i in range(a):\n    if l[i]==x:\n        b=i\n        break\nc=a-b\ns=sum(l[b:])\ns_=sum(l[:b])\nif n<b:\n    print(sum(l[:n]))\nelse:\n    print(s_+s*((n-b)//c)+sum(l[b:b+(n-b)%c]))", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\ndef read():\n    N, X, M = list(map(int, input().strip().split()))\n    return N, X, M\n\n\ndef solve(N, X, M):\n    # log2(10**10) ~ 33.2\n    D = 34\n    A = [[0 for j in range(M)] for i in range(D)]\n    S = [[0 for j in range(M)] for i in range(D)]\n    \n    for j in range(M):\n        # A[0][j] := 0\u30b9\u30c6\u30c3\u30d7\u76ee\u304cj\u3067\u3042\u308b\u3068\u304d\u306e\u30012^0=1\u30b9\u30c6\u30c3\u30d7\u5148\u306e\u5024\n        A[0][j] = j * j % M\n        # S[0][j] := j\u306e2^0=1\u30b9\u30c6\u30c3\u30d7\u76ee\u307e\u3067\u306e\u7dcf\u548c\n        S[0][j] = j\n    for i in range(0, D-1):\n        for j in range(M):\n            # A[i][j] := 0\u30b9\u30c6\u30c3\u30d7\u76ee\u304cj\u3067\u3042\u308b\u3068\u304d\u306e\u30012^i\u30b9\u30c6\u30c3\u30d7\u5148\u306e\u5024\n            A[i+1][j] = A[i][A[i][j]]\n            S[i+1][j] = S[i][j] + S[i][A[i][j]]\n    ans = 0\n    x = X\n    for i in range(D-1, -1, -1):\n        if N & (1 << i) == (1 << i):\n            ans += S[i][x]\n            x = A[i][x]\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "n, x, m = map(int, input().split())\na = []\nmp = dict()\ncnt, tot = 0, 0\nwhile mp.get(x, -1) == -1:\n    a.append(x)\n    tot += x\n    mp[x] = cnt\n    cnt += 1\n    x = (x * x) % m\n\nif n <= cnt:\n    ans = 0\n    for i in range(0, n): ans += a[i]\n    print(ans)\n    return\ncycle = 0\nrest = cnt - mp.get(x, 0)\nfor i in range(mp[x], cnt):\n    cycle += a[i]\nn-= cnt\nans = tot\nans += (n // rest) * cycle\nn %= rest\nsi = mp.get(x, 0)\nfor i in range(n): ans += a[si + i]\nprint(int(ans))", "n, x, m = map(int, input().split())\nd = [0]*(m+1)\ntmp = x\ncheck = [tmp]\nwhile d[tmp] == 0:\n    d[tmp] = 1\n    tmp = (tmp**2)%m\n    check.append(tmp)\nfor i in range(len(check)):\n    if check[i] == check[-1]:\n        index = i\n        break\nsum_c = sum(check[index:len(check)-1])\ncycle = (n - index) // (len(check)-index-1)\nrest = n - index - cycle*(len(check)-index-1)\nprint(sum(check[:index+rest])+sum_c*cycle)", "n, x, m = map(int, input().split())\nif m >= n:\n    ans = 0\n    for i in range(n):\n        ans += x\n        x **= 2\n        x %= m\n    print(ans)\n    return\nl = [x]\nd = {}\nfor i in range(m):\n    d[i] = 0\nd[x] += 1\nfor i in range(m):\n    x = (x**2)%m\n    if d[x] == 1:\n        y = l.index(x)\n        print(sum(l[:y])+sum(l[y:])*((n-y)//(len(l)-y))+sum(l[y:][:(n-y)%(len(l)-y)]))\n        return\n    l.append(x)\n    d[x] += 1", "# \u7e70\u308a\u8fd4\u3057\u306e\u59cb\u307e\u308a + \u7e70\u308a\u8fd4\u3057 + \u9014\u4e2d\u3067\u7d42\u308f\u3063\u305f\u7e70\u308a\u8fd4\u3057\u5206\nN,X,M = map(int,input().split())\np = [0] * (M+2)\nsum = [0] * (M+2)\np[X] = 1\nsum[1] = X\n\nrepeat_start = 0\nrepeat_end = 0\n\nfor i in range(2,N+1):\n  X = (X**2) % M\n  if p[X] != 0:\n    repeat_start = p[X]\n    repeat_end = i\n    break\n  else:\n    sum[i] = sum[i-1] + X\n    p[X] += i\n\nif repeat_start == 0:\n  print(sum[N])\nelse:\n  repeat_cnt,mod=divmod(N-repeat_start+1,repeat_end-repeat_start)\n  print(repeat_cnt*(sum[repeat_end-1]-sum[repeat_start-1]) + sum[repeat_start+mod-1])", "N, X, M = list(map(int, input().split()))\n\nidx = [-1] * M\nA = []\ntotal = 0\nlength = 0\n\nwhile idx[X] == -1:\n    A.append(X)\n    idx[X] = length\n    length += 1\n    total += X\n    X = pow(X, 2, M)\n\ncycle = length - idx[X]\ncycle_sum = sum(A[idx[X]:length])\n\nans = 0\nif length >= N:\n    print((sum(A[:N])))\nelse:\n    ans += total\n    N -= length\n    l, m = divmod(N, cycle)\n    ans += cycle_sum * l\n    ans += sum(A[idx[X]:idx[X] + m])\n    print(ans)\n", "N, X, M = list(map(int, input().split()))\n\nA = [X]\nitem = set()\nfor i in range(N-1):\n    next = (A[i] ** 2) % M\n    if next in item:\n        loop_start = A.index(next)\n        loop_length = len(A) - loop_start\n        loop_times = (N - loop_start) // loop_length\n        loop_remain = (N - loop_start) % loop_length\n        cnt = sum(A[:loop_start]) + (sum(A[loop_start:]) * loop_times) + sum(A[loop_start:loop_start + loop_remain])\n        print(cnt)\n        return\n    A.append(next)\n    item.add(next)\nprint((sum(A)))\n", "import sys\n\n# import numpy as np\n# from numba import njit\n#\n# read = sys.stdin.read\nreadline = sys.stdin.readline\n\n\n# readlines = sys.stdin.readlines\n\n\ndef solve(n, x, m):\n    a = [x]\n    a_set = {x}\n    ai = x\n    for _ in range(m):\n        ai = ai ** 2 % m\n        if ai in a_set:\n            start = a.index(ai)\n            loop = a[start:]\n            lall = len(a)\n            lloop = len(loop)\n            break\n        else:\n            a.append(ai)\n            a_set.add(ai)\n\n    if n - 1 <= lall:\n        ans = sum(a[:n])\n    else:\n        q, r = divmod(n - lall, lloop)\n        ans = sum(a) + sum(loop) * q + sum(loop[:r])\n\n    return ans\n\n\nn, x, m = map(int, readline().split())\nprint(solve(n, x, m))", "n, x, m = list(map(int, input().split()))\nA = []\nls = [0] * (m+1) \nstart = 0\ncycle_sum = 0\ncnt = 0\nwhile ls[x] == 0:\n    A.append(x)\n    cycle_sum += x\n    ls[x] = cnt\n    cnt += 1\n    x = (x*x) % m \n\nif n <= cnt :\n    ans = 0\n    for i in range(0, n): ans += A[i]\n    print(ans)\n    return\ncycle = 0\nrest = cnt - ls[x]\nfor i in range(ls[x], cnt):\n    cycle += A[i]\nn -= cnt \nans = cycle_sum\nans += (n//rest) * cycle \nn %= rest\nsi = ls[x]\nfor i in range(n):\n    ans += A[si + i]\nprint(ans)\n", "n, x, m = map(int, input().split())\nmod = [-1] * m\nstart = 0\nend = 0\na = [x]\nmod[x] = 0\nfor i in range(1, m):\n  if i >= n:\n    break\n  a_new = a[-1]**2 % m\n  if mod[a_new] == -1:\n    mod[a_new] = i\n  else:\n    start = mod[a_new]\n    end = i\n    break\n  a.append(a_new)\n\nloop_num = 0\nlast_num = 0\nif end - start:\n  loop_num = (n - start) // (end - start)\n  last_num = (n - start) % (end - start)\n  out = sum(a[:start]) + sum(a[start:end + 1]) * loop_num\n  out += sum(a[start:start+last_num])\nelse:\n  out = sum(a)\n\nprint(out)", "n, x, m = list(map(int, input().split()))\n\na_idx = [-1] * m\na_idx[x] = 0\na = [x]\nidx = 1\nwhile True:\n    y = (a[-1]**2) % m\n    if a_idx[y] != -1:\n        i = a_idx[y]\n        j = len(a) - i\n        break\n    else:\n        a_idx[y] = idx\n        idx += 1\n        a.append(y)\n\nans = sum(a) * (n)\nans = sum(a[:i]) + sum(a[i:]) * ((n - i) // j) + sum(a[i:i + (n - i) % j])\nprint(ans)\n", "N,X,M=map(int,input().split())\nans=0\nA=[]\nsa=set(A)\nwhile N:\n    if X not in sa:\n        ans+=X\n        A.append(X)\n        sa.add(X)\n        X=X**2%M\n        N-=1\n    else:\n        i=A.index(X)\n        B=A[i:]\n        L=len(B)\n        ans+=sum(B)*(N//L)+sum(B[:N%L])\n        N=0\nprint(ans)", "N, X, M = map(int, input().split())\n\nA = [-1, X]\npre = X\nsums = [-1, X]\npresum = X\n\nfor _ in range(M + 1):\n    pre = (pre * pre) % M\n    A.append(pre)\n\n    presum += pre\n    sums.append(presum)\n\nif N <= M:\n    print(sums[N])\n    return\n\nlstart = M + 1\n\nwhile A[lstart] != pre:\n    lstart -= 1\n\nloopsum = sums[-1] - sums[lstart]\n\nlooplen = M + 2 - lstart\nloopcnt = (N - lstart) // looplen\nover = (N - lstart) % looplen\n\nans = loopsum * loopcnt + sums[lstart + over]\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10**6)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nn,x,md=MI()\n# n,x,md=6,7,13\npos=[-1]*md\naa=[]\nif x==0:\n    print(0)\n    return\n\nfor i in range(md):\n    if pos[x]!=-1:\n        p=pos[x]\n        c=i-pos[x]\n        # print(x,i,pos[x])\n        break\n    aa.append(x)\n    pos[x]=i\n    x=pow(x,2,md)\ncs=sum(aa[p:])\n\n# print(p,c)\n# print(pos)\n# print(aa)\n\nif n<=len(aa):\n    print(sum(aa[:n]))\n    return\n\nn-=p\ncnt=n//c\nn%=c\nn+=p\nprint(cs*cnt+sum(aa[:n]))\n", "N,X,M = list(map(int, input().split()))\n\na = X\npath = [a]\ndone = set([a])\nwhile True:\n    na = pow(a,2,M)\n    if na in done:\n        s = path.index(na)\n        break\n    else:\n        path.append(na)\n        done.add(na)\n        a = na\n\nif N < s +1:\n    ans = sum(path[:N])\nelse:\n    rest = N - s\n    x,y = divmod(rest,len(path)-s)\n    ans = sum(path[:s])\n    ans += sum(path[s:])*x\n    ans += sum(path[s: s+y])\nprint(ans)\n", "def main():\n    n,x,m = list(map(int,input().split()))\n    ans = x\n    now = x\n    used = [0] * (m + 1)\n    used[now] = 1\n    cnt = 1\n    while True:\n        if cnt == n:\n            print(ans)\n            return\n        cnt += 1\n        now = (now ** 2) % m\n        if used[now] > 0:\n            break\n        used[now] = cnt\n        ans += now\n    start = used[now]\n\n\n    ans = 0\n    now = x\n    cycle = 0\n    startNum = 0\n    for i in range(1, cnt):\n        if i < start:\n            ans += now\n        elif i == start:\n            cycle += now\n            startNum = now\n        else:\n            cycle += now\n        now = (now ** 2) % m\n    rem = n - start + 1\n    cycleCnt = cnt - start\n    roopCnt = rem // cycleCnt\n    ans += roopCnt * cycle\n    now = startNum\n    for i in range(roopCnt * cycleCnt + start, n+1):\n        ans += now\n        now = (now ** 2) % m\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "N, X, M = map(int, input().split())\n\ndef calc(n, x, m):\n    nxt = lambda y: y**2%m\n\n    y = x\n    r = n\n    l = [0]*m\n    for i in range(1, n+1):\n        if l[y]:\n            r = i-l[y]\n            break\n        l[y] = i\n        y = nxt(y)\n    else: return sum(i for i, v in enumerate(l) if v)\n\n    ans = 0\n    for i in range(i):\n        ans += x\n        x = nxt(x)\n    n -= i+1\n    for i in range(r):\n        ans += x*(n//r)\n        x = nxt(x)\n    for i in range(n%r):\n        ans += x\n        x = nxt(x)\n\n    return ans\n\nprint(calc(N, X, M))", "# -*- coding: utf-8 -*-\n\nn, x, m = map(int, input().split())\n\na_list = [x]\na = x\ni = 1\nwhile (i<n and i < m+1):\n    a = (a*a) % m\n    a_list.append(a)\n    i += 1\n    \n#print(i)\n#print(a_list)\n    \nif i == n:\n  ans = sum(a_list)\nelse:\n    b = a_list.index(a)\n    sum1 = sum(a_list[:b+1])\n    sum2 = sum(a_list[b+1:i])\n    blen = i-b-1\n    repeat = (n-b-1) // blen\n    amari = (n-b-1) % blen\n    sum3 = 0\n    if amari != 0:\n    \tsum3 = sum(a_list[b+1:b+amari+1])\n    ans = sum1 + sum2*repeat + sum3\n    #print(blen)\n    #print(amari)\n    #print(sum1, sum2, repeat, sum3)\n\nprint(ans)", "[N, X, M] = [int(i) for i in input().split()]\nL = [X]\nans = X\ndic = {}\nfor i in range(1, N):\n    t = (L[-1]**2)%M\n    if t in dic:\n        x = dic[t]\n        ans += (sum(L[x:i+1])) * ((N-i)//(i-x)) + sum(L[x:x+(N-i)%(i-x)])\n        break\n    else:\n        L.append(t)\n        dic[t] = i\n        ans += t\n \nprint(ans)", "n, x, m = list(map(int, input().split()))\nX = [-1] * m\nP = []\nsum_p = 0\nwhile X[x] < 0: # preset\n    X[x] = len(P) # pre length\n    P.append(sum_p) # pre sum_p\n    sum_p += x # now sum_p\n    x = x*x % m\ncyc_times, nxt_len = divmod(n - X[x], len(P) - X[x])\ncyc = (sum_p - P[X[x]]) * cyc_times\nremain = P[X[x] + nxt_len]\nprint((cyc + remain))\n", "n, x, m = list(map(int, input().split()))\n\nvisit = [-1] * m\na_sum = [0] *(m+1)\n\na = x\na_sum[1] = x\nvisit[a] +=1\n\nflg = True\n\nif n == 1:\n    print(x)\n    return\nif x == 0:\n    print((0))\n    return\n\nfor i in range(1,n):\n    a = (a**2)%m\n    a_sum[i+1] = a_sum[i] + a\n    if visit[a] == -1:\n        visit[a] = i\n    else:\n        li = visit[a] \n        roop = i - li\n        roop_sum = a_sum[i]-a_sum[li]\n        flg = False\n        break\n\nif flg:\n    print((a_sum[i+1]))\n    return\n\nsum = a_sum[li] \nsum += roop_sum*((n-li)//roop)\nsum += a_sum[li + (n-li)%roop] - a_sum[li]\n\nprint(sum)\n\n\n\n\n\n", "n, x, m = list(map(int, input().split()))\nx %= m\nd = {x:1}\narr = [0] * (m+1)\narr[1] = x\nfor i in range(2, n+1):\n    x = (x * x) % m\n    if x in d:\n        start = d[x]\n        end = i - 1\n        sumPreCycle = sum(arr[1:start])\n        numPreCycle = start - 1\n        lenCycle = end - start + 1\n        sumCycle = sum(arr[start:end+1])\n        numCycle = (n - numPreCycle) // lenCycle\n        numAfterCycle = n - numPreCycle - lenCycle * numCycle\n        sumAfterCycle = sum(arr[start:start+numAfterCycle])\n        print((sumPreCycle + sumAfterCycle + sumCycle * numCycle))\n        break\n    else:\n        arr[i] = x\n        d[x] = i\nelse:\n    print((sum(arr[1:n+1])))\n", "N,X,M = map(int,input().split())\n\nstep = [0 for i in range(M)]\nsums = [i for i in range(M)]\n\nfor i in range(len(step)):\n  step[i] = i ** 2 % M\n  \nans = 0\nwhile N:\n  if N & 1:\n    ans += sums[X]\n    X = step[X]\n  sums = [sums[i] + sums[step[i]] for i in range(M)]\n  step = [step[step[i]] for i in range(M)]\n  N >>= 1\n  \nprint(ans)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,x,m=nii()\n\nans=x\nx_list=[x]\nx_table=[0 for i in range(m+1)]\nx_table[x]=1\n\nfor i in range(1,n):\n  x=(x**2)%m\n\n  if x_table[x]!=0:\n    inx=x_list.index(x)\n    loop=x_list[inx:]\n    zan=n-i\n\n    p=zan//len(loop)\n    q=zan%len(loop)\n\n    ans+=sum(loop)*p\n    ans+=sum(loop[:q])\n\n    break\n\n  else:\n    ans+=x\n    x_list.append(x)\n    x_table[x]+=1\n\nprint(ans)", "n, x, m = list(map(int, input().split()))\nX = [-1] * m\nP = []\nsum_p = 0\nwhile X[x] == -1: # preset\n    X[x] = len(P) # pre length\n    P.append(sum_p) # pre sum_p\n    sum_p += x # now sum_p\n    x = x*x % m\nP.append(sum_p) # full sum_p\np_len = len(P) - 1\ncyc_times, nxt_len = divmod(n - X[x], p_len - X[x])\ncyc = (sum_p - P[X[x]]) * cyc_times\nremain = P[X[x] + nxt_len]\nprint((cyc + remain))\n", "n, x, m = list(map(int, input().split()))\nX = [-1] * m\nP = []\nsum_p = 0\nwhile X[x] == -1: # preset\n    X[x] = len(P) # pre length\n    P.append(sum_p) # pre sum_p\n    sum_p += x # now sum_p\n    x = x*x % m\nP.append(sum_p) # full sum_p\n\np_len = len(P) - 1\nif n <= p_len:\n    print((P[n])) # sum_p\n    return\n\ncyc_times, nxt_len = divmod(n - X[x], p_len - X[x])\ncyc = (sum_p - P[X[x]]) * cyc_times\nremain = P[X[x] + nxt_len]\nprint((cyc + remain))\n", "# coding: utf-8\n\n\ndef solve(*args: str) -> str:\n    n, x, m = list(map(int, args[0].split()))\n\n    a = x\n    ret = 0\n    I = [-1]*(m+1)\n    A = []\n\n    for i in range(n):\n        if I[a] < 0:\n            I[a] = i\n            A.append(a)\n            ret += a\n        else:\n            A = A[I[a]:]\n            d, r = divmod(n-i-1, len(A))\n            ret += (d+1)*sum(A[:r+1])+d*sum(A[r+1:])\n            break\n        a = pow(a, 2, m)\n\n    return str(ret)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "N, X, M = map(int, input().split())\n\nli = [-1 for i in range(M)]\na = []\nl = 0\ntot = 0\nwhile li[X]==-1:\n  a.append(X)\n  li[X] = l\n  l += 1\n  tot += X\n  X = (X*X)%M\n\nc = l - li[X]\ns = 0\nfor i in range(li[X],l):\n  s += a[i]\n\nans = 0\nif N<=l:\n  for i in range(N):\n    ans += a[i]\nelse:\n  ans += tot\n  N -= l\n  ans += s*int(N/c)\n  for i in range(N%c):\n    ans += a[li[X]+i]\nprint(ans)", "def main():\n    n, x, m = list(map(int, input().split()))\n    a, r, ans = [0]*(m+1), 0, 0\n    chk = [False] * (m+1)\n    a[0] = x\n    for i in range(m):\n        tmp = pow(a[i], 2, m)\n        if tmp == 0:\n            print((sum(a)))\n            return\n        r = i+1\n        if chk[tmp]:\n            l = a.index(tmp)\n            ans = sum(a[l:r])*((n-l)//(r-l))\n            ans += sum(a[l:l+(n-l) % (r-l)])\n            break\n        else:\n            chk[tmp] = True\n        a[r] = tmp\n    print((ans+sum(a[:l])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, x, m = list(map(int, input().split()))\n\nvisit = [0] * m\nvisit_t = [0] * m\na = [0] *(m+1)\na_sum = [0] *(m+1)\n\na[1] = x\na_sum[1] = x\nvisit[a[1]] +=1\n\n\nflg = True\n\nif n == 1:\n    print(x)\n    return\nif x == 0:\n    print((0))\n    return\n\nfor i in range(1,n):\n    a[i+1] = (a[i]**2)%m\n    a_sum[i+1] = a_sum[i] + a[i+1]\n    if visit[a[i+1]] == 0:\n        visit[a[i+1]] += 1\n        visit_t[a[i+1]] = i\n    else:\n        li = visit_t[a[i+1]] \n        roop = i - li\n        roop_sum = a_sum[i]-a_sum[li]\n        flg = False\n        break\n\nif flg:\n    print((a_sum[i+1]))\n    return\n\nsum = a_sum[li] \nsum += roop_sum*((n-li)//roop)\nsum += a_sum[li + (n-li)%roop] - a_sum[li]\n\nprint(sum)\n\n\n\n\n", "N,X,M = map(int,input().split())\nid = [-1] * M\na = []\nl = 0\ntotal = 0\nwhile(id[X] < 0):\n  a.append(X)\n  id[X] = l\n  total += X\n  l += 1\n  X = pow(X,2,M)\n  \nc = l - id[X]\ns = 0\nfor i in range(id[X], l, 1):\n  s += a[i]\n\nans = 0\nif N <= c:\n  for i in range(N):\n    ans += a[i]\nelse:\n  ans += total\n  N -= l\n  ans += s * (N//c)\n  N %= c\n  for i in range(N):\n    ans += a[id[X] + i]\nprint(ans)", "def main():\n  n,x,m = map(int,input().split())\n  a = [x]\n  at = [x]\n  aset = set(a)\n  i = 1\n  while(True):\n    an = a[-1]**2%m\n    if an in aset:\n      ca = a.index(an)\n      break\n    a.append(an)\n    aset.add(an)\n    at.append(at[-1]+a[-1])\n    i+=1\n    if i == n:\n      print(at[-1])\n      return\n  #aa = a[:ca]\n  ata = [0]+at[:ca]\n  #ab = a[ca:]\n  atb = [ata[-1]]+at[ca:]\n  cb = len(atb)-1\n  na = min(n,ca)\n  nb,nc = divmod(n-na,cb)\n  print(ata[na]+(atb[-1]-ata[-1])*nb+atb[nc]-ata[-1])\nmain()", "N,X,M=map(int,input().split())\ntable=[X]\nvisited=[-1]*M\nvisited[X]=1\n\nans=X\n\nfor i in range(N-1):\n    nx=table[i]**2\n    nx%=M\n    if visited[nx]>0:\n        first=table.index(nx)\n        oneloop=i+1-first\n        rest=N-i-1\n        loops=rest//oneloop\n        totalofoneloop=sum(table[first:])\n        ans+=totalofoneloop*loops\n        remain=rest%oneloop\n        ans+=sum(table[first:first+remain])\n        print(ans)\n        return\n    else:\n        table.append(nx)\n        visited[nx]=1\n        ans+=nx\n \n\nprint(ans)", "n, x, m = map(int, input().split())\nmn = min(n, m)\nP = []\nsum_p = 0\nX = [-1] * m\nfor i in range(mn):\n    if X[x] > -1:\n        cyc_len = len(P) - X[x]\n        remain = P[X[x]]\n        cyc = (sum_p - remain) * ((n - X[x]) // cyc_len)\n        remain += P[X[x] + (n - X[x]) % cyc_len] - P[X[x]]\n        print(cyc + remain)\n        return\n    P.append(sum_p)\n    sum_p += x\n    X[x] = i\n    x = x*x % m\nprint(sum_p)", "S = input().split()\n\nN, X, M = [int(s) for s in S]\n\ninit = X\ncount = 0\nbox = [0] * (M + 2)\n\nfor i in range(M):\n  box[i] = X\n  X = (X ** 2) % M\n  \nT = len(set(box))\n\nfor t in range(T):\n  if box[t] == box[T]:\n    break\n    \n\nprint(sum(box[:t]) + ((N - t)//(T - t)) * sum(box[t:T]) + sum(box[t:t + (N - t)%(T - t)]))", "N,X,mod=map(int,input().split())\nl=[X]\nse=set(l)\nmem=-1\nfor i in range(N-1):\n   if l[-1]**2%mod in se:\n      mem=l[-1]**2%mod\n      break\n   else:\n      c=l[-1]**2%mod\n      l.append(c);se.add(c)\nif mem==-1:\n   print(sum(l))\n   return\nN-=i+2\nans=sum(l)\nindex=l.index(mem)\nroop=len(l)-index\nl=l[index:]\ncan,rem=divmod(N,roop)\nans+=sum(l)*can\nans+=sum(l[:rem+1])\nprint(ans)", "n,x,m=map(int,input().split());l,k,i,j=[-1]*m,[],0,-1\nwhile j<0:l[x]=i;k+=[x];x=x**2%m;i+=1;j=l[x]\nn-=i;r=i-j;print(n//r*sum(k[j:])+sum(k+k[j:n%r+j]))", "def main():\n    n, x, m = list(map(int, input().split()))\n    a, r, l = [0]*(m+1), 0, 0\n    chk = [False] * (m+1)\n    a[0] = x\n    for i in range(m):\n        tmp = pow(a[i], 2, m)\n        if chk[tmp] or tmp == 0:\n            if tmp == 0:\n                print((sum(a)))\n                return\n            r = i+1\n            l = a.index(tmp)\n            break\n        else:\n            chk[tmp] = True\n        a[i+1] = tmp\n    print((sum(a[:l]) + sum(a[l:r])*((n-l)//(r-l)) + sum(a[l:l+(n-l) % (r-l)])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,X,M = list(map(int,input().split()))\n#M\u3067\u308f\u308b\u306e\u3067\u3001\u9ad8\u3005M\u500b\u306e\u7a2e\u985e\u3057\u304b\u306a\u304f\u3001\u30eb\u30fc\u30d7\u3059\u308b\n#\u30eb\u30fc\u30d7\u958b\u59cb\u306eindex\u3092\u4fdd\u7ba1\u3057\u3066\u3044\u304f\ndic={}\na = X\ndic[X]=1\nseen = set([a])\nroop_length = 0\nroop_start = 0\nans = X\nfor i in range(2,N+1):\n    a = pow(a,2,M)\n    if a in seen:\n        roop_length = i - dic[a]\n        roop_start = dic[a]\n        roop_start_a = a\n\n        break\n    else:\n        ans += a\n        seen.add(a)\n        dic[a]=i\nroop_ans = 0\nif roop_length >0:\n    roop_ans = roop_start_a\n    a = roop_start_a\n    for i in range(1,N+1):\n        a = pow(a,2,M)\n        if a != roop_start_a:\n            roop_ans += a\n        else:\n            break\n    roop_ans = roop_ans * ((N-roop_start+1)//roop_length-1)\n\n#\u30eb\u30fc\u30d7\u5f8c\u306e\u306e\u3053\u308a\u306f\uff1f\nrest_ans = 0\nif roop_length>0:\n    rest_num = (N-roop_start+1)%roop_length\n    rest_ans = roop_start_a*(rest_num>0)\n    a = roop_start_a\n    for _ in range(1,rest_num):\n        a = pow(a,2,M)\n        rest_ans += a\n        \nans_all = ans + roop_ans+rest_ans\nprint(ans_all)\n    \n", "import pprint\n\nn, x, m = list(map(int, input().split(\" \")))\n\n\ndef f(x: int, m: int) -> int:\n    return x % m\n\ndef solve1(n: int, x: int, m: int) -> int:\n    d = {x: 0}\n    A = [x]\n    ans = A[0]\n    loop_count = 0\n\n    #print(\"(\", A[0], end=\"\")\n\n    for i in range(n):\n        A_next = f(A[i]**2, m)\n\n        if A_next in d:\n            loop_count = (n - d[A_next] - 1) // (d[A[i]] - d[A_next] + 1)\n\n            mod_left = d[A_next]\n            mod_right = mod_left + \\\n                ((n - d[A_next] - 1) % (d[A[i]] - d[A_next] + 1) + 1)\n\n            #print(\" ) + (\", A[d[A_next]:A[i]], \") * \", loop_count-1, end=\"\")\n            #print(\" + (\", A[mod_left:mod_right], \")\", end=\"\")\n\n            ans += sum(A[d[A_next]:A[i]]) * (loop_count - 1)\n            ans += sum(A[mod_left:mod_right])\n            break\n        else:\n            A.append(A_next)\n            d[A_next] = i + 1\n            ans += A[i+1]\n            #print(\" +\", A[i+1], end=\"\")\n    else:\n        #print(\" )\", end=\"\")\n        #print(\" - \", A[-1], end=\"\")\n        ans -= A[-1]\n\n    #print(\" =\", ans)\n\n    return ans\n\n\nprint((solve1(n, x, m)))\n", "n, x, m = list(map(int, input().split()))\nmn = min(n, m)\nP = [] # pre_sum\nsum_p = 0 # sum of pre + cycle\nX = [-1] * m # for cycle check & pre_len\nfor i in range(mn):\n    if X[x] > -1:\n        cyc_len = len(P) - X[x]\n        n -= X[x]\n        cyc = (sum_p - P[X[x]]) * (n // cyc_len)\n        remain = P[X[x] + n % cyc_len]\n        print((cyc + remain))\n        return\n    P.append(sum_p)\n    sum_p += x\n    X[x] = i\n    x = x*x % m\nprint(sum_p)\n", "#\u9ad8\u3005M\u306e\u7e70\u308a\u8fd4\u3057\nN,X,M =list(map(int,input().split()))\nmemo = [0]*(2*M+1)#\u6700\u95772M\u307e\u3067loop\u3059\u308b\u306f\u305a\nval_idx = {X:1}#loop\u3057\u305f\u3068\u304d\u306b\u3001\u3069\u3053\u304cloop\u958b\u59cb\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304b\u3092\u77e5\u308b\u305f\u3081\u306e\u30e1\u30e2\nseen = set([X])#\u898b\u305f\u5224\u5b9a\u3002o(1)\u3067\u5224\u5b9a\u3059\u308b\u305f\u3081\nmemo[1]=X#\u7d2f\u7a4d\u548c\u3092\u53d6\u3063\u3066\u304a\u304f\n\nloop_length = 0#loop\u3057\u305f\u304b\u3001\u3057\u305f\u306a\u3089loop\u9577\u306f\u306a\u306b\u304b\nfor i in range(2,N+1):\n    X = (X**2)%M\n    if X not in seen:#\u307e\u3060loop\u3057\u3066\u306a\u3044\n        seen.add(X)\n        val_idx[X]=i\n        memo[i]+=memo[i-1]+X\n    else:#loop\u3057\u305f\n        loop_start_val = X\n        loop_start_idx = val_idx[X]\n        loop_length = i-loop_start_idx\n        break\nif loop_length == 0:#\u30eb\u30fc\u30d7\u3057\u306a\u304b\u3063\u305f\u3089\u3001N\u756a\u76ee\n    print((memo[N]))\nelse:#\u30eb\u30fc\u30d7\u3057\u305f\u306a\u3089\n    rest_num = (N-loop_start_idx+1)%loop_length#\u30eb\u30fc\u30d7\u306e\u5f8c\u308d\u306e\u304d\u308c\u3063\u3071\u3057\n    loop_num =(N-loop_start_idx+1)//loop_length#\u30eb\u30fc\u30d7\u56de\u6570\n    ans = (memo[loop_start_idx+loop_length-1]-memo[loop_start_idx-1])*loop_num+memo[loop_start_idx-1+rest_num]#1\u30eb\u30fc\u30d7\u306e\u548c x \u30eb\u30fc\u30d7\u56de\u6570\uff0b\u304d\u308c\u3063\u3071\u3057\n    print(ans)\n", "n,x,m = map(int,input().split())\nl = [x]\ns = {x}\nfor i in range(n):\n    x = x*x % m\n    if x in s:\n        break\n    l += [x]\n    s.add(x)\nxi = 0\nfor i in range(len(l)):\n    if x == l[i]:\n        xi = i\n        break\nans = 0\nif n <= xi:\n    print(sum(l[:n]))\n    return\nans = sum(l[:xi])\nn -= xi\nl = l[xi:]\nprint(ans + sum(l) * (n // len(l)) + sum(l[:(n%len(l))]))", "def f(x, m):\n    return x**2 % m\n\n\nN, X, M = map(int, input().split())\n\nA = [X]\nS = {X}\ni = 0\nwhile True:\n    tmp = f(A[-1], M)\n    if tmp in S:\n        i = A.index(tmp)\n        break\n    else:\n        A.append(tmp)\n        S.add(tmp)\n\nn_loop = len(A) - i\ns, l = A[:i], A[i:]\ndiv, mod = divmod(N - i, n_loop)\nprint(sum(s) + sum(l) * div + sum(l[:mod]))", "N, X, M = list(map(int, input().split()))\n\nr = [-1 for _ in range(M)]\na = X\nr[a] = 0\np = [a]\n\n# M\u56de\u7e70\u308a\u8fd4\u305b\u3070\uff0c\u5fc5\u305a\u304b\u3076\u308b\nfor i in range(1, M + 1):\n    an = a ** 2 % M\n    if r[an] >= 0:\n        break\n    r[an] = i\n    p.append(an)\n    a = an\n\nq = p[r[an] :]\np = p[: r[an]]\n\nif N <= len(p):\n    ans = sum(p[:N])\nelse:\n    ans = sum(p)\n    N -= len(p)\n    a, b = divmod(N, len(q))\n    ans += a * sum(q)\n    ans += sum(q[:b])\n\nprint(ans)\n", "N, X, M = map(int, input().split())\n\ndef calc(n, x, m):\n    nxt = lambda y: y**2%m\n\n    y = x\n    r = n\n    l = [0]*m\n    for i in range(1, n+1):\n        if l[y]:\n            r = i-l[y]\n            break\n        l[y] = i\n        y = nxt(y)\n\n    ans = 0\n    for i in range(i):\n        ans += x\n        x = nxt(x)\n    n -= i+1\n    for i in range(r):\n        ans += x*(n//r)\n        x = nxt(x)\n    for i in range(n%r):\n        ans += x\n        x = nxt(x)\n\n    return ans\n\nprint(calc(N, X, M))", "n, x, m = map(int, input().split())\nlist_A = [x]\nset_A = {x}\nwhile True:\n    a = pow(list_A[-1], 2, m)\n    if a in set_A:\n        break\n    list_A.append(a)\n    set_A.add(a)\n\nif len(list_A) >= n:\n    print(sum(list_A[:n]))\nelse:\n    k = list_A.index(a)\n    s = sum(list_A[k:])\n    l = len(list_A) - k\n\n    h = (n - len(list_A)) // l\n    g = (n - len(list_A)) % l\n\n    ans = sum(list_A) + h * s + sum(list_A[k:k + g])\n\n    print(ans)", "n,x,m=map(int,input().split())\n\ncheck=[0]*(m+1)\ntmp=x%m\nal=[x%m]\ncheck[x%m]=1\nwhile(True):\n    tmp=tmp*tmp%m\n    al.append(tmp)\n    if check[tmp]==0:\n        check[tmp]=1\n    else:\n        break\nj=[]\nstart=0\nflag=False\nfor i in range(len(al)):\n    if al[i]==al[-1] and i!=len(al)-1:\n        flag=True\n        start=i\n    if flag:\n        if i!=len(al)-1:\n            j.append(al[i])\n\nans=0\nfor i in range(start):\n    ans+=al[i]\n\np=n-start\nans+=sum(j)*(p//len(j))\ny=p%len(j)\nfor i in range(y):\n    ans+=j[i]\n\nprint(ans)", "n, x, m = map(int, input().split())\n\na = [x]\nc = [0]*(m+1)\nflag = False\nfor i in range(1, n):\n    v = a[i-1]**2 % m\n    if c[v] == 1:\n        flag = True\n        break\n    a.append(v)\n    c[v] = 1\nif flag:\n    e = a.index(v)\n    s = len(a) - e\n    d, f = divmod(n-e, s)\n    print(sum(a[:e]) + d*sum(a[e:e+s]) + sum(a[e:e+f]))\nelse:\n    print(sum(a))", "from collections import defaultdict\n\nn, x, m = list(map(int, input().split()))\n\n\ndef culc(xx, mod):\n    return xx ** 2 % mod\n\n\ndic = defaultdict(int)\nA = x\nwarps = [A]\nindices = [0 for i in range(m + 5)]\ncount = 1\ncircle_len = -1\ntail_len = -1\nwhile True:\n    count += 1\n    A = culc(A, m)\n    if dic[A] >= 1:\n        circle_len = count - indices[A]\n        tail_len = count - circle_len - 1\n        break\n    warps.append(A)\n    indices[A] = count\n    dic[A] += 1\n\ntail = warps[:tail_len]\ncircle = warps[tail_len:]\n\ntimes = (n - tail_len) // circle_len\nremainder = (n - tail_len) % circle_len\n\nans = sum(tail) + times * sum(circle) + sum(circle[:remainder])\nprint(ans)\n\n", "N,X,M = map(int,input().split())\n\nid = [-1] * M\na = list()\nl = 0\ntotal = 0\n\nwhile(id[X] < 0):\n  id[X] = l\n  l += 1\n  total += X\n  a.append(X)\n  X = pow(X,2,M)\n\nc = l - id[X]\ns = 0\nfor i in range(id[X],l,1):\n  s += a[i]\n\nans = 0\nif N <= c:\n  for i in range(N):\n    ans += a[i]\nelse:\n  ans += total\n  N -= l\n  ans += (N//c) * s\n  N %= c\n  for i in range(N):\n    ans += a[id[X] + i]\n\nprint(ans)", "N, X, M =map(int, input().split())\nid = [-1] * M\na = list()\nl = 0\ntotal = 0\nwhile(id[X] < 0):\n  id[X] = l\n  a.append(X)\n  total += X\n  l += 1\n  X = pow(X,2,M)\n  \nc = l - id[X]\ns = 0\nfor i in range(id[X],l,1):\n  s += a[i]\n  \nans = 0\nif N <= l:\n  for i in range(N):\n    ans += a[i]\nelse:\n  ans += total\n  N -= l\n  ans += (N//c) * s\n  N %= c\n  for i in range(N):\n    ans += a[id[X] + i]\nprint(ans)", "n,x,m=map(int,input().split());r,l,k=n,[-1]*m,[]\nfor i in range(n):\n j=l[x]\n if j>=0:r=i-j;break\n l[x]=i;k+=[x];x=x**2%m;n-=1\nprint(n//r*sum(k[j:])+sum(k+k[j:n%r+j]))", "N, X, M = list(map(int, input().split()))\ns = set()\nl = list()\nans = 0\n\nA = X\ns.add(A)\nl.append(A)\nans += A\nindex = 1\nwhile True:\n    Anext = (A * A) % M\n    if Anext in s:\n        break\n    A = Anext\n    s.add(A)\n    l.append(A)\n    ans += A\n    index += 1\n    if index == N:\n        print(ans)\n        return\n\nAi = Anext\nindex_Ai = l.index(Ai)\nlen_R = index - index_Ai\nlen_L = index - len_R\nkurikaeshi = sum(l[len_L:])\nans += (N - index) // len_R * kurikaeshi\nans += sum(l[len_L:len_L + (N - index) % len_R])\nprint(ans)\n", "class DoublingAggregation:\n    def __init__(self, nexts, arr, max_n, op, e):\n        # op \u306f\u30e2\u30ce\u30a4\u30c9\n        n = len(nexts)\n        self.table = [nexts[:]]\n        self.data = [arr[:]]\n        self.op = op\n        self.e = e\n        self.max_n = max_n\n        for k in range(max_n.bit_length()-1):\n            perm = self.table[-1]\n            perm_next = []\n            dat = self.data[-1]\n            dat_next = []\n            for p, d in zip(perm, dat):\n                perm_next.append(perm[p])  # perm[p] == perm[perm[idx_perm]]\n                dat_next.append(op(d, dat[p]))\n            self.table.append(perm_next)\n            self.data.append(dat_next)\n\n    def prod(self, idx, n):\n        # arr[idx] * arr[nexts[idx]] * arr[nexts[nexts[idx]] * ... \u3092 n \u56de\u7e70\u308a\u66ff\u3048\u3057\u305f\u5024\u3092\u8fd4\u3059\n        val = self.e\n        op = self.op\n        for bit, (t, dat) in enumerate(zip(self.table, self.data)):\n            if n >> bit & 1:\n                val = op(val, dat[idx])\n                idx = t[idx]\n        return idx, val\n\n    def max_right(self, idx, f):\n        # f(arr[idx] * arr[nexts[idx]] * arr[nexts[nexts[idx]] * ... (n \u56de)) \u304c\n        # True \u3067\u3042\u308b\u6700\u5927\u306e n \u3068\u3001\u305d\u306e\u3068\u304d\u306e prod(idx, n)\n        n = 0\n        val = self.e\n        op = self.op\n        for bit, t, dat in zip(list(range(len(self.table)-1, -1, -1)), self.table[::-1], self.data[::-1]):\n            val_next = op(val, dat[idx])\n            if f(val_next):\n                val = val_next\n                idx = t[idx]\n                n |= 1 << bit\n        if n > self.max_n:\n            n = self.max_n\n        return n, idx, val\n\n\nfrom operator import add\n\nN, X, M = list(map(int, input().split()))\nnexts = [i*i%M for i in range(M)]\narr = list(range(M))\ndoubling = DoublingAggregation(nexts, arr, N, add, 0)\nans = doubling.prod(X, N)[1]\nprint(ans)\n", "#\u7e70\u308a\u8fd4\u3057\u3092\u63a2\u3059\nN,X,M = list(map(int, input().split()))\n\n#\u30eb\u30fc\u30d7\u524d\u3000\u30eb\u30fc\u30d7\u4e2d\u3000\u30eb\u30fc\u30d7\u5f8c\u3000\u306e\u5408\u8a08\u3092\u305d\u308c\u305e\u308c\u6c42\u3081\u3001\u305d\u306e\u548c\u3092\u6c42\u3081\u308b\npre_loop_sum = 0\nall_loop_sum = 0\nincomplete_loop_sum = 0\n\nloop_flag = False\n\nL = []\nL.append(X  % M)\n\n#\u9ad8\u901f\u5316\u306e\u305f\u3081\nS = set()\n\n#\u7e70\u308a\u8fd4\u3057\u304c\u8d77\u304d\u308b\u307e\u3067\u306e\u914d\u5217\u306e\u4f5c\u6210\nfor i in range(1,N):\n    X = pow(X,2,M)\n\n    if X in S:\n        loop_flag = True\n        break\n    else:\n        L.append(X)\n        S.add(X)\n\nindex = L.index(X)\n\nlen_L = len(L)\n\nif loop_flag:\n    #\u7e70\u308a\u8fd4\u3057\u304c\u767a\u751f\u3057\u305f\u5834\u5408\n    #\u30eb\u30fc\u30d7\u524d\u306e\u5408\u8a08\u3092\u53d6\u5f97\n    pre_loop_sum = sum(L[0:index])\n\n    #\u30eb\u30fc\u30d7\u5185\u306e\u5408\u8a08\u5024\u3001\u30eb\u30fc\u30d7\u306e\u9577\u3055\u3001\u30eb\u30fc\u30d7\u306e\u767a\u751f\u56de\u6570\u306e\u53d6\u5f97\n    loop_sum = sum(L[index:len_L])\n    loop_len = len_L - index\n    loop_count = (N - index) // loop_len\n\n    #\u30eb\u30fc\u30d7\u4e2d\u306e\u5408\u8a08\u3092\u53d6\u5f97\n    all_loop_sum = loop_count * loop_sum\n\n    #\u30eb\u30fc\u30d7\u4ed5\u5207\u308c\u306a\u3044\u4f59\u308a\u90e8\u5206\u306e\u53d6\u5f97\n    incomplete_loop_len = (N - index) % loop_len\n    incomplete_loop_sum = sum(L[index:index+incomplete_loop_len])\nelse:\n    #\u7e70\u308a\u8fd4\u3057\u304c\u767a\u751f\u3057\u306a\u3044\u5834\u5408\n    pre_loop_sum = sum(L)\n\nans = pre_loop_sum + all_loop_sum + incomplete_loop_sum\n\nprint(ans)\n", "n, x, m = map(int, input().split())\na = []\nmp = dict()\ncnt, tot = 0, 0\nwhile mp.get(x, -1) == -1:\n    a.append(x)\n    tot += x\n    mp[x] = cnt\n    cnt += 1\n    x = (x * x) % m\n\nif n <= cnt:\n    ans = 0\n    for i in range(0, n): ans += a[i]\n    print(ans)\n    return\ncycle = 0\nrest = cnt - mp.get(x, 0)\nfor i in range(mp[x], cnt):\n    cycle += a[i]\nn-= cnt\nans = tot\nans += (n // rest) * cycle\nn %= rest\nsi = mp.get(x, 0)\nfor i in range(n): ans += a[si + i]\nprint(int(ans))", "n,x,m=map(int,input().split())\nid=[-1]*(m+1)\ns=[]\nc=0\nwhile(id[x]==-1):\n    id[x]=c\n    c+=1\n    s.append(x)\n    x=x*x%m\nd=c-id[x]\nans=0\nif d>=n:\n    for i in range(n):\n        ans+=s[i]\nelse:\n    for i in range(id[x]):\n        ans+=s[i]\n    n-=id[x]\n    sum=0\n    for i in range(d):\n        sum+=s[id[x]+i]\n    ans+=(n//d)*sum\n    n=n%d\n    for i in range(n):\n        ans+=s[id[x]+i]\nprint(int(ans))", "n, x, m = list(map(int, input().split()))\nmn = min(n, m)\nP = [] # pre_sum\nsum_p = 0 # sum of pre + cycle\nX = [-1] * m # for cycle check & pre_len\nfor i in range(mn):\n    if X[x] > -1:\n        cyc_times, nxt_len = divmod(n-X[x], len(P) - X[x])\n        cyc = (sum_p - P[X[x]]) * cyc_times\n        remain = P[X[x] + nxt_len]\n        print((cyc + remain))\n        return\n    P.append(sum_p)\n    sum_p += x\n    X[x] = i\n    x = x*x % m\nprint(sum_p)\n", "N,X,M=map(int,input().split())\n\nans=0\nsumlist = [X,]\nchecklist = [-1]*(M+1)\nA = X\n# checklist[A] = 0\n\ndef calcans(start, end, sumlist):\n    cnt = end - start + 1\n    loop = (N - start - 1) // cnt\n    add = N - (cnt * loop) - start\n    return (sumlist[end]-sumlist[start-1])*loop + sumlist[start-1+add]\n\nfor i in range(1,N):\n    A = (A**2) %M\n    # print(A)\n    if checklist[A-1] != -1:\n        # print(f'start: {checklist[A]} end: {i-1}')\n        ans = calcans(checklist[A-1], i-1, sumlist)\n        # looplen = i-1 - checklist[A] + 1\n        # looptimes = (N - checklist[A]-1) // looplen\n        # ans += (sumlist[i-1] - sumlist[checklist[A]-1] )* looptimes\n        # ans += sumlist[(N-checklist[A]) % looplen + checklist[A]-1]\n        # print(f'loop end: {looplen}, {looptimes}')\n        break\n    elif A == 0:\n        ans = sumlist[i-1]\n        break\n    else:\n        checklist[A-1] = i\n        sumlist.append(sumlist[-1] + A)\nelse:\n    ans = sumlist[-1]\n\nprint(ans)", "def main():\n    n, x, m = list(map(int, input().split()))\n    now = x\n    l = [now]\n    s = set([now])\n    for i in range(n-1):\n        now = now*now % m\n        if now in s:\n            break\n        else:\n            l.append(now)\n            s.add(now)\n    if n == len(l):\n        print((sum(l)))\n        return 0\n    i = l.index(now)\n    l1 = l[:i]\n    l2 = l[i:]\n    ans = sum(l1)\n    n -= i\n    size = len(l2)\n    print((ans+((n//size)*sum(l2)+sum(l2[:n % size]))))\n\n\nmain()\n", "N,X,M = map(int, input().split())\nid = [-1] * M\nl = 0\ntotal = 0\na = list()\nwhile(id[X] == -1):\n  a.append(X)\n  id[X] = l\n  total += X\n  l += 1\n  X = pow(X,2,M)\n\nc = l - id[X]\ns = 0\nfor i in range(id[X],l,1):\n  s += a[i]\nans = 0\nif N <= l:\n  for i in range(N):\n    ans += a[i]\nelse:\n  ans += total\n  N -= l\n  ans += s * (N//c)\n  N %= c\n  for i in range(N):\n    ans += a[id[X] + i]\nprint(ans)", "n, x, m = map(int, input().split())\n \nvisit = [0] * m\nvisit_t = [0] * m\na = [0] *(m+1)\na_sum = [0] *(m+1)\n \na[1] = x\na_sum[1] = x\nvisit[a[1]] +=1\n \n \nflg = True\n \nif n == 1:\n    print(x)\n    return\nif x == 0:\n    print(0)\n    return\n \nfor i in range(1,n):\n    a[i+1] = (a[i]**2)%m\n    a_sum[i+1] = a_sum[i] + a[i+1]\n    if visit[a[i+1]] == 0:\n        visit[a[i+1]] += 1\n        visit_t[a[i+1]] = i\n    else:\n        li = visit_t[a[i+1]] \n        roop = i - li\n        roop_sum = a_sum[i]-a_sum[li]\n        flg = False\n        break\n \nif flg:\n    print(a_sum[i+1])\n    return\n \nsum = a_sum[li] \nsum += roop_sum*((n-li)//roop)\nsum += a_sum[li + (n-li)%roop] - a_sum[li]\n \nprint(sum)", "def main():\n    n, x, m = list(map(int, input().split()))\n    a, r = [0]*(m+1), 0\n    chk = [False] * (m+1)\n    a[0] = x\n    for i in range(m):\n        tmp = pow(a[i], 2, m)\n        if tmp == 0:\n            print((sum(a)))\n            return\n        r = i+1\n        if chk[tmp]:\n            l = a.index(tmp)\n            break\n        else:\n            chk[tmp] = True\n        a[r] = tmp\n    print((sum(a[:l]) +\n          sum(a[l:r])*((n-l)//(r-l)) +\n          sum(a[l:l+(n-l) % (r-l)])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, x, m = map(int, input().split())\nmod = [-1] * m\nstart = 0\nlast = 0\na = [x]\nmod[x] = 0\nfor i in range(1, m):\n  if i >= n:\n    break\n  a_new = a[-1]**2 % m\n  if mod[a_new] == -1:\n    mod[a_new] = i\n  else:\n    start = mod[a_new]\n    last = i\n    break\n  a.append(a_new)\n\nloop_num = 0\nremain = 0\nif last - start:\n  loop_num = (n - start) // (last - start)\n  remain = (n - start) % (last - start)\n  out = sum(a[:start]) + sum(a[start:last + 1]) * loop_num\n  out += sum(a[start:start+remain])\nelse:\n  out = sum(a)\n\nprint(out)", "import numpy as np\n\ndef __starting_point():\n  \n  n, x, m = list(map(int, input().split()))\n  a = [0 for i in range(m + 2)]\n  \n  #\u30eb\u30fc\u30d7\u3092\u7279\u5b9a\u3059\u308b\u30d1\u30fc\u30c8\n  mod = [0 for i in range(m)]\n  loop_start_0 = 0\n  loop_start_1 = 0\n  loop_exists = 0\n  a[0] = x\n  for i in range(1, m + 2):\n    a[i] = a[i-1]**2 % m\n    if mod[a[i]] == 0:\n      mod[a[i]] = i\n    else:\n      loop_start_0 = mod[a[i]]\n      loop_start_1 = i\n      loop_exists = 1\n      break\n      \n  sum_of_a = 0\n  \n  if loop_exists:\n    #\u30eb\u30fc\u30d7\u304c\u59cb\u307e\u308b\u524d\u306e\u548c\n    for i in range(loop_start_0):\n      sum_of_a += a[i]\n    \n    #\u30eb\u30fc\u30d7\u90e8\u5206\u306e\u548c\n    loop_sum_of_a = 0\n    for i in range(loop_start_0, loop_start_1):\n      loop_sum_of_a += a[i]\n    \n    loop_num = np.floor((n - loop_start_0) / (loop_start_1 - loop_start_0))\n    sum_of_a += loop_sum_of_a * loop_num\n    \n    #\u6700\u5f8c\u306b\u4f59\u3063\u305f\u90e8\u5206\u306e\u548c\n    for i in range(loop_start_0, int(n - (loop_start_1 - loop_start_0) * loop_num)):\n      sum_of_a += a[i]\n      \n  else:\n    for i in range(n):\n      sum_of_a += a[i]\n    \n    \n  print(int(sum_of_a))\n__starting_point()", "n,x,m=list(map(int,input().split()))\nA=[x]\nM=[0]*m\nwhile True:\n    x = pow(x,2,m)\n    if M[x]==1:\n        break\n    A.append(x)\n    M[x]=1\n\ns=A.index(x)\n\nshuki=len(A)-s\n\nif n<=s:\n    print((sum(A[:n])))\nelse:\n    n-=s\n    su=sum(A[s:])\n    print(((n//shuki)*su+sum(A[s:s+(n%shuki)])+sum(A[:s])))\n\n", "# -*- coding: utf-8 -*-\nimport math\nn, x, m = list(map(int, input().split()))\n\nappearance = {}\nsequence = []\na = x\nloopExists = False\n\n# find loop in numerical sequence. loop length < m\n# because m << n, for loop should break sooner than n\nfor _ in range(n):\n    appearance[a] = appearance.get(a, 0) + 1\n    if appearance[a] == 2:\n        loopExists = True\n        break\n    sequence.append(a)\n    a = a * a % m\n\nif not loopExists:\n    print((sum(sequence)))\nelse:\n    loopStartIndex = sequence.index(a)\n    preLoopNums = sequence[:loopStartIndex]\n    loopNums = sequence[loopStartIndex:]\n    preLoopLength = len(preLoopNums)\n    loopLength = len(loopNums)\n    # n = preLoopLength + loopCount * loopLength + rest\n    loopCount = (n - preLoopLength) // loopLength\n    restLength = (n - preLoopLength) % loopLength\n    # total = preLoopTotal + loopTotal * loopCount + restTotal\n    preLoopTotal = sum(preLoopNums)\n    loopTotal = sum(loopNums)\n    restTotal = sum(loopNums[:restLength])\n    total = preLoopTotal + loopTotal * loopCount + restTotal\n    print(total)\n", "import sys\n#import time\nfrom collections import deque, Counter, defaultdict\n#from fractions import gcd\nimport bisect\nimport heapq\n#import math\nimport itertools\nimport numpy as np\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\ninf = 10**18\nMOD = 1000000007\nri = lambda : int(input())\nrs = lambda : input().strip()\nrl = lambda : list(map(int, input().split()))\nmod = 998244353\n\nn,x,m = rl()\nres = [0]*m\nnums = []\ncnt=0\nwhile True:\n    if res[x]==1:\n        break\n    res[x] = 1\n    nums.append(x)\n    \n    a = x % m\n    x = a*a%m\n    cnt+=1\n#print(res)\ncircle = nums.index(x)\nif n<circle:\n    print(sum(nums[:circle]))\nelse:\n    times = (n-circle)//(cnt-circle)\n    last = (n-circle)%(cnt-circle)\n    #print(times)\n    #print(last)\n    #print(circle)\n    print(sum(nums[:circle]) + sum(nums[circle:])*times + sum(nums[circle:circle+last]))", "#\u9ad8\u3005M\u306e\u7e70\u308a\u8fd4\u3057\nN,X,M =list(map(int,input().split()))\nmemo = [0]*(2*M+1)\nval_idx = {X:1}\nidx_val = {1:X} \nseen = set([X])\nmemo[1]=X\n\nloop_length = 0\nfor i in range(2,N+1):\n    X = pow(X,2,M)\n    if X not in seen:#\u307e\u3060loop\u3057\u3066\u306a\u3044\n        seen.add(X)\n        val_idx[X]=i\n        idx_val[i]=X\n        memo[i]+=memo[i-1]+X\n    else:#loop\u306b\u9054\u3057\u305f\n        loop_start_val = X\n        loop_start_idx = val_idx[X]\n        loop_length = i-loop_start_idx\n        break\nif loop_length == 0:\n    print((memo[N]))\nelse:\n    rest_num = (N-loop_start_idx+1)%loop_length\n    loop_num =(N-loop_start_idx+1)//loop_length\n    ans = (memo[loop_start_idx+loop_length-1]-memo[loop_start_idx-1])*loop_num+memo[loop_start_idx-1+rest_num]\n    print(ans)\n", "N, X, M = map(int, input().split())\n\nchecked_val = [0] * M\nsum_list = [X]\na = X\n\ndef calc_ans(sum_list, start_idx, end_idx):\n    loop_len = end_idx - start_idx + 1\n    loop_times = (N - start_idx - 1) // loop_len\n    add = N - (loop_len * loop_times) - start_idx\n    return ((sum_list[end_idx] - sum_list[start_idx - 1]) * loop_times + sum_list[start_idx - 1 + add])\n\nfor i in range(1, N):\n    a = (a ** 2) % M\n    if checked_val[a - 1] != 0:\n        ans = calc_ans(sum_list, checked_val[a - 1], i - 1)\n        break\n    elif a == 0:\n        ans = sum_list[i - 1]\n        break\n    else:\n        checked_val[a - 1] = i\n        sum_list.append(sum_list[-1] + a)\nelse:\n    ans = sum_list[-1]\nprint(ans)", "n,x,m=map(int,input().split())\nan=[0]*(m)\ncheck=[0]*m\nan[0]=x\ncheck[x]=1\nfor i in range(1,m+1):\n  x=(x**2)%m\n  if check[x]!=0:\n    break\n  else:\n    check[x]=i+1\n    an[i]=x\n\nnum=i-check[x]+1\nans=sum(an[:(check[x]-1)])\nkazu=n-len(an[:(check[x]-1)])\nre=sum(an[check[x]-1:i])\nans+=(kazu//num)*(re)\nans+=sum(an[check[x]-1:i-(num-(kazu%num))])\nprint(ans)", "def main():\n    n, x, m = list(map(int, input().split()))\n    s = set()\n    L = []\n    ans = 0\n    while n > 0:\n        s.add(x)\n        L.append(x)\n        ans += x\n        x = x * x % m\n        n -= 1\n        if x in s:\n            break       \n    else:\n        print(ans)\n        return\n    L = L[L.index(x):] \n    q, r = divmod(n, len(L))\n    ans += sum(L) * q\n    ans += sum(L[:r])\n    print(ans)\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "n, x, m = list(map(int, input().split()))\nls = [-1] * (m+1) \na = []\ntot = 0\ncnt = 0\nwhile ls[x] == -1:\n    a.append(x)\n    tot += x\n    ls[x] = cnt\n    cnt += 1\n    x = (x*x) % m \n\nif n <= cnt :\n    ans = 0\n    for i in range(n):\n        ans += a[i]\n    print(ans)\n    return\ncycle = 0\nrest = cnt - ls[x]\nfor i in range(ls[x], cnt):\n    cycle += a[i]\nn -= cnt \nans = tot\nans += (n//rest) * cycle \nn %= rest\nsi = ls[x]\nfor i in range(n):\n    ans += a[si + i]\nprint(ans)\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\n#mod = 10 ** 9 + 7 \nmod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN, X, M = MAP()\n\ncheck = [0]*(10**5+1)\nsum_acc = [0]\n\ni = X\ncnt = 0\nwhile check[i] < 2 and cnt < N:\n\tcheck[i] += 1\n\tcnt += 1\n\tsum_acc.append(sum_acc[-1]+i)\n\ti = i**2%M\n\nif cnt == N:\n\tprint(sum_acc[-1])\n\treturn\n\ncnt_1 = check.count(1)\ncnt_2 = check.count(2)\nloop_sum = (sum_acc[-1] - sum_acc[cnt_1])//2\n\n\nans = sum_acc[cnt_1]\nans += loop_sum*((N-cnt_1)//cnt_2)\nans += sum_acc[cnt_1+((N-cnt_1)%cnt_2)] - sum_acc[cnt_1]\n\nprint(ans)", "n, x, m = map(int, input().split())\n\nans = x\nx0 = x\nmemo0 = [0] * (m + 1)\nmemo1 = [0] * (m + 1)\npair = [0, 0]\n\nfor i in range(1, n):\n    x1 = (x0%m * x0%m) % m\n    if memo0[x1] != 0:\n        pair = [memo0[x1], i-1]\n        break\n    else:\n        memo0[x1] = i\n        memo1[i] = memo1[i-1] + x1\n        x0 = x1\n        pair = [0, i]\n\nif pair[1] == n - 1:ans = memo1[pair[1]] + x\nelse:\n    i, j = pair[0], pair[1]\n    s0i = memo1[i-1] + x\n    sij = memo1[j] - memo1[i-1]\n    t0 = (n - i) // (j - i + 1)\n    t1 = (n - i) % (j - i + 1)\n    sje = memo1[t1 + i - 1] - memo1[i-1]\n    ans = s0i + sij * t0 + sje\n\nprint(ans)", "n,x,m = list(map(int, input().split()))\nfirstOcc = [-1]*(m+2)\narr = []\na = x\nfor i in range(m+2):\n    if firstOcc[a] != -1:\n        break\n    arr.append(a)\n    firstOcc[a] = i\n    a = a*a%m\n\nans = sum(arr[:min(n,firstOcc[a])])\ncycleLen = len(arr) - firstOcc[a]\ncycleSum = sum(arr[firstOcc[a]:])\nans += cycleSum * ((n-firstOcc[a]) // cycleLen)\nleafLen = ((n-firstOcc[a]) % cycleLen)\nans += sum(arr[firstOcc[a] : firstOcc[a]+leafLen])\nprint(ans)\n#print(firstOcc[a], cycleLen, leafLen, len(arr))\n#print(arr)\n", "import sys\nimport re\nimport queue\nimport collections\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b // gcd(a, b)\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nnum_list = []\nstr_list = []\n\n\ndef main():\n\tN,X,M=i_map()\n\n\tY = X\n\n\twent_array = []\n\tfor i in range(0,M):\n\t\twent_array.append(-1)\n\n\tloop_flag = False\n\tfirst = -1\n\tsecond = -1\n\tvalue = -1\n\tfor i in range(0,N):\n\n\t\tif(went_array[Y] != -1):\n\t\t\tloop_flag = True\n\t\t\tfirst = went_array[Y]\n\t\t\tsecond = i\n\t\t\tvalue = Y\n\t\t\tbreak\n\n\t\twent_array[Y] = i\n\t\tY = (Y*Y) % M\n\n\tif(loop_flag == False):\n\t\tZ = X\n\t\tsum = 0\n\n\t\tfor i in range(0,N):\n\t\t\tsum += Z\n\t\t\tZ = (Z*Z)%M\n\n\t\tprint(sum)\n\n\telse:\n\t\tZ = X\n\t\tsum1 = 0\n\t\tfor i in range(0,first):\n\t\t\tsum1 += Z\n\t\t\tZ = (Z*Z)%M\n\n\t\tZ = value\n\t\tcum = []\n\t\tcum.append(Z)\n\t\tZ = (Z*Z) %M\n\t\tfor i in range(1,second-first):\n\t\t\tcum.append(cum[i-1]+Z)\n\t\t\tZ = (Z*Z) %M\n\n\t\tsum2 = ((N-first)//(second-first))*cum[second-first-1]\n\n\t\tif((N-first)%(second-first) == 0):\n\t\t\tprint(sum1 + sum2)\n\t\telse:\n\t\t\tsum3 = cum[((N-first)%(second-first)-1)]\n\t\t\tprint(sum1 + sum2 + sum3)\n\n\n\treturn\n\ndef __starting_point():\n\tmain()\n__starting_point()", "# \u53c2\u8003\n# https://atcoder.jp/contests/abc179/submissions/16890682\n\nn, x, m = map(int, input().split())\ncheck = [False] * (10**5 + 10)\ncheck_list = [x]\na = x\n# \u30eb\u30fc\u30d7\u3092\u898b\u3064\u3051\u308b\nfor i in range(n):\n    a = (a * a) % m\n    if check[a]:\n        break\n    check[a] = True\n    check_list.append(a)\n \n# \u30eb\u30fc\u30d7\u306e\u9577\u3055\u3092\u7b97\u51fa\nindex = check_list.index(a)\n# \u30eb\u30fc\u30d7\u306f\u3044\u308b\u524d\u306e\u3084\u3064\nloop_bef = check_list[0:index]\n# \u30eb\u30fc\u30d7\u306e\u3084\u3064\nloop = check_list[index:]\n \n# \u30eb\u30fc\u30d7\u304c\u4f55\u5468\u3042\u308b\u306e\u304b\u3068\uff0c\u30eb\u30fc\u30d7\u7d42\u308f\u308a\u304c\u3044\u304f\u3064\u8981\u7d20\u3042\u308b\u304b\u3092\u8a08\u7b97\nloop_num = (n - len(loop_bef)) // len(loop)\nafter_loop = (n - len(loop_bef)) % len(loop)\n \n# \u30eb\u30fc\u30d7\u524d+\u30eb\u30fc\u30d7\u306esum*\u30eb\u30fc\u30d7\u6570+\u30eb\u30fc\u30d7\u5f8c\u306esum\u304c\u7b54\u3048\nans = sum(loop_bef) + sum(loop) * loop_num + sum(loop[:after_loop])\n \nprint(ans)", "import sys\n\ninput = sys.stdin.readline\n\nN, X, M = map(int, input().split())\nLIST = [X]\nSET = {X}\n\na = X\n\nwhile True:\n    if a * a % M in SET:\n        break\n    else:\n        a = a * a % M\n        LIST.append(a)\n        SET.add(a)\n\n# \u7e70\u308a\u8fd4\u3057\u304ca\u304b\u3089\u59cb\u307e\u308b\n# SET\u306b\u306f\u9806\u756a\u304c\u8a18\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u306e\u3067LIST\u3092\u4f7f\u3046\nstart = LIST.index(a * a % M)\nLEN = len(LIST)\n\nif N <= LEN:\n    print(sum(LIST[:N]))\nelse:\n    LoopTimes, Excess = divmod(N-LEN, LEN-start)\n    LoopSum = sum(LIST[start:]) * LoopTimes\n    ExSum = sum(LIST[start:start+Excess])\n    print(sum(LIST[:]) + LoopSum + ExSum)", "N, X, M = map(int, input().split())\nA = X\nloop = {A: 1}\nsums = [0, A]\nstart = 0\nend = 0\nfor i in range(2, M+2):\n    A = (A ** 2) % M\n    if A in loop:\n        start = loop[A]\n        end = i\n        sums.append(sums[-1] + A)\n        break\n    sums.append(sums[-1] + A)\n    loop[A] = i\nanswer = sums[start]\nN -= start\nanswer += (N // (end - start)) * (sums[end] - sums[start])\nanswer += sums[start + N % (end - start)] - sums[start]\nprint(answer)", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, X, M = map(int, input().split())\n\nA = [X]\nB = [0, X]\nS = set(A)\n\nwhile not A[-1] * A[-1] % M in S:\n    V = A[-1] * A[-1] % M\n    B.append(B[-1] + V)\n    A.append(V)\n    S.add(V)\n\nidx = A.index(A[-1] * A[-1] % M)\n\nans = 0\n\nif idx < N:\n    l = len(A) - idx\n    ans += B[idx]\n    N -= idx\n\n    ans += (B[-1] - B[idx]) * (N // l)\n    ans += B[idx + N % l] - B[idx]\n\n    print(ans)\nelse:\n    print(B[N])", "# import itertools\n# import math\n# from functools import reduce\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, X, M = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\n#def make_divisors(n):\n#    lower_divisors , upper_divisors = [], []\n#    i = 1\n#    while i*i <= n:\n#        if n % i == 0:\n#            lower_divisors.append(i)\n#            if i != n // i:\n#                upper_divisors.append(n//i)\n#        i += 1\n#    return lower_divisors + upper_divisors[::-1]\n\n# def gcd_list(numbers):\n#     return reduce(math.gcd, numbers)\n\n# if gcd_list(A) > 1:\n#     print(\"not coprime\")\n#     return\n\n# \u9ad8\u901f\u7d20\u56e0\u6570\u5206\u89e3\u6e96\u5099\n#MAXN = 10**6+10\n#sieve = [i for i in range(MAXN+1)]\n#p = 2\n#while p*p <= MAXN:\n#    if sieve[p] == p:\n#        for q in range(2*p, MAXN+1, p):\n#            if sieve[q] == q:\n#                sieve[q] = p\n#    p += 1\n\nA = [X]\nst = set(A)\nlast_num = 0\nfor i in range(1, N):\n    a_i = A[-1] ** 2 % M\n    if a_i in st:\n        last_num = a_i\n        break\n    A.append(a_i)\n    st.add(a_i)\nelse:\n    print(sum(A))\n    return\n\n#print(\"loop case ha mada dekitenai\")\n\nloop_start = A.index(last_num)\n\nA_before_loop = A[:loop_start]\nA_loop_part = A[loop_start:]\n\nq, mod = divmod((N - len(A_before_loop)), len(A_loop_part))\n\nprint(sum(A_before_loop) + sum(A_loop_part) * q + sum(A_loop_part[:mod]))", "n, x, m = list(map(int, input().split()))\nvisited = [None] * m\nvisited[x] = 1\na = x\ns = [0] * min(n + 1, m + 1)\ns[1] = x\nfor i in range(2, n + 1):\n    a = a**2 % m\n    if visited[a]:\n        d = s[i - 1] - s[visited[a] - 1]\n        k = i - visited[a]\n        r = (n - visited[a]) % k + visited[a]\n        l = (n - visited[a]) // k\n        print((s[r] + l * d))\n        return\n    visited[a] = i\n    s[i] = s[i - 1] + a\nprint((s[n]))\n", "from collections import deque\n\nn, x, m = map(int, input().split())\n\nA = deque()\nG = [-1 for i in range(m)]\nt = 0\ntotal = 0\nwhile G[x] == -1:\n    A.append(x)\n    G[x] = t\n    t += 1\n    total += x\n    x = (x*x) % m\n\ncycle = t - G[x]\ns = 0\nfor i in range(cycle):\n    s += A[G[x] + i]\n\nans = 0\nif n < t:\n    for i in range(n): ans += A[i]\nelse:\n    n -= t\n    ans = total + s * (n // cycle)\n    for i in range(n % cycle): ans += A[G[x] + i]\nprint(ans)", "def printAns(first, start, end, s):\n    cnt = end - start + 1\n    loop = (N - start - 1) // cnt\n    add = N - (cnt * loop) - start\n    print((s[end]-s[start-1])*loop + s[start-1+add])\n    \n    \nN, X, M = map(int, input().split())\n\ncheck = [0] * M\nm = [X]\na = X\n\nfor i in range(1, N):\n    a = (a**2)%M\n    if check[a-1] != 0:\n        printAns(0, check[a-1], i-1, m)\n        return\n    elif a == 0:\n        print(m[i-1])\n        return\n    check[a-1] = i\n    m.append(m[-1] + a)\nelse:\n    print(m[-1])", "#\u9ad8\u3005M\u306e\u7e70\u308a\u8fd4\u3057\nN,X,M =list(map(int,input().split()))\nmemo = [0]*(2*M+1)#\u6700\u95772M\u307e\u3067loop\u3059\u308b\u306f\u305a\nval_idx = {X:1}\nseen = set([X])\nmemo[1]=X\n\nloop_length = 0\nfor i in range(2,N+1):\n    X = pow(X,2,M)\n    if X not in seen:#\u307e\u3060loop\u3057\u3066\u306a\u3044\n        seen.add(X)\n        val_idx[X]=i\n        memo[i]+=memo[i-1]+X\n    else:#loop\u306b\u9054\u3057\u305f\n        loop_start_val = X\n        loop_start_idx = val_idx[X]\n        loop_length = i-loop_start_idx\n        break\nif loop_length == 0:\n    print((memo[N]))\nelse:\n    rest_num = (N-loop_start_idx+1)%loop_length\n    loop_num =(N-loop_start_idx+1)//loop_length\n    ans = (memo[loop_start_idx+loop_length-1]-memo[loop_start_idx-1])*loop_num+memo[loop_start_idx-1+rest_num]\n    print(ans)\n", "import numpy as np\n\n\ndef main():\n    n, x, m = list(map(int, input().split()))\n    a, r, ans = np.zeros((m+1), np.int64), 0, 0\n    a[0] = x\n    for i in range(m):\n        tmp = np.power(a[i], 2) % m\n        if tmp == 0:\n            print((sum(a)))\n            return\n        r = i+1\n        if tmp in a:\n            l = np.where(a == tmp)[0][0]\n            ans = sum(a[l:r])*((n-l)//(r-l))\n            ans += sum(a[l:l+(n-l) % (r-l)])\n            break\n        a[r] = tmp\n    print((ans+sum(a[:l])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, x, m = list(map(int, input().split()))\n    a, r, ans = [x], 0, 0\n    chk = [False] * (m+1)\n    for i in range(m):\n        tmp = pow(a[i], 2, m)\n        if tmp == 0:\n            print((sum(a)))\n            return\n        r = i+1\n        if chk[tmp]:\n            l = a.index(tmp)\n            ans = sum(a[l:r])*((n-l)//(r-l))\n            ans += sum(a[l:l+(n-l) % (r-l)])\n            break\n        else:\n            chk[tmp] = True\n        a.append(tmp)\n    print((ans+sum(a[:l])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, X, M = list(map(int, input().split()))\n\nA = X\nloop_dict = {A: 1}\nct = 1\nwhile True:\n    ct += 1\n    A = A ** 2 % M\n    if A in loop_dict:\n        break\n    else:\n        loop_dict[A] = ct\n        if ct == N:\n            # \u4e00\u5468\u3057\u306a\u304b\u3063\u305f\u5834\u5408\n            print((sum(loop_dict)))\n            return\n\nloop_length = len(loop_dict) - loop_dict[A] + 1\ntail_length = loop_dict[A] - 1\nloop = [0] * loop_length\ntail = [0] * tail_length\n\nfor x, i in list(loop_dict.items()):\n    if i <= tail_length:\n        tail[i - 1] = x\n    else:\n        loop[i - tail_length - 1] = x\n\nd, m = divmod(N - tail_length, loop_length)\nprint((sum(tail) + sum(loop) * d + sum(loop[:m])))\n", "n, x, m = map(int, input().split())\n\ndef A(x, m):\n    return (x**2)%m\n\nnow = x\nans = 0\nstreak = []\nused = set()\nloop = False\nwhile n > 0:\n    if now in used:\n        loop = True\n        break\n    used.add(now)\n    ans += now\n    streak.append(now)\n    now = A(now, m)\n    n-=1\n\nif loop:\n    loop_sum = 0\n    loop_streak = []\n    for j, item in enumerate(streak[::-1]):\n        loop_sum += item\n        loop_streak.append(item)\n        if item == now:\n            loop_length = j+1\n            break\n    ans += (n//loop_length)*loop_sum\n    loop_streak.reverse()\n    ans += sum(loop_streak[:n%loop_length])\n\nprint(ans)", "n,x,m=list(map(int,input().split()))\n\nt,i,c,d=0,0,[0]*-~m,[0]*-~m\nwhile i<n:\n  i,t=i+1,t+x\n  c[x],d[i]=i,t\n  x=x**2%m\n  if c[x]:\n    break\n\nif i!=n and x!=0:\n  p=c[x]-1\n  t=(d[i]-d[p])*((n-p)//(i-p))+d[p+(n-p)%(i-p)]\n\nprint(t)\n", "n,x,m=map(int,input().split());l,k,i,j=[-1]*m,[],0,-1\nwhile j<0:l[x]=i;k+=[x];x=x**2%m;n-=1;j=l[x];i+=1\nr=i-j;print(n//r*sum(k[j:])+sum(k+k[j:n%r+j]))", "n, x, m = list(map(int, input().split()))\n\nrem = [-1]*(m+1)\nrem[x] = 1\nnow = x\ns = []\n\nwhile True:\n    s.append(now)\n    next = (now*now) % m\n    if rem[next] == -1:\n        rem[next] = rem[now] + 1\n    else:\n        cycle_start = next\n        break\n\n    now = next\n\n\nans = 0\nfor i in range(rem[cycle_start]-1):\n    if n >= 1:\n        n -= 1\n        ans += s[i]\n    else:\n        break\n\ncycle_sum = sum(s[rem[cycle_start]-1:])\ncycle_length = max(rem) - rem[cycle_start] + 1\n\nans += cycle_sum * (n // cycle_length)\nn -= cycle_length * (n//cycle_length)\n\nnow = rem[cycle_start] - 1\nwhile n > 0:\n    ans += s[now]\n    n -= 1\n    now += 1\n\nprint(ans)\n", "n, x, m = list(map(int, input().split()))\nX = [-1] * m\nP = []\nsum_p = 0\nwhile X[x] == -1: # preset\n    X[x] = len(P) # pre length\n    P.append(sum_p) # pre sum_p\n    sum_p += x # now sum_p\n    x = x*x % m\ncyc_times, nxt_len = divmod(n - X[x], len(P) - X[x])\ncyc = (sum_p - P[X[x]]) * cyc_times\nremain = P[X[x] + nxt_len]\nprint((cyc + remain))\n"]
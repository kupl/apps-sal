["import math\nm,a,b=map(int,input().split())\ng=math.gcd(a,b)\na1=a//g\nb1=b//g\nalls=g*(a1+b1-1)\ndists=[0]+[-1]*(a1+b1-1)\ndist=0\nfar=0\nwhile dist!=b1:\n    if dist<b1:\n        dist+=a1\n        far=max(dist,far)\n    else:\n        dist-=b1\n    if dists[dist]==-1:\n        dists[dist]=far\ntot=0\nfor i in range(a1+b1):\n    if i*g<=m and dists[i]*g<=m:\n        tot+=(m+1-dists[i]*g)\nif alls<m:\n    mod=m%g\n    times=m//g\n    diff=times-a1-b1\n    tot1=g*(diff*(diff+1)//2)+(mod+1)*(diff+1)\n    tot+=tot1\nprint(tot)", "from math import gcd\n\nm,a,b = list(map(int,input().split()))\n\ng = gcd(a,b)\n\nvis = [0]*(a+b+1)\nvis[0] = 1\n\nnvis = 1\n\ncount = 0\nlast = 0\nt = 0\nwhile True:\n    #print(t, vis)\n    if t >= b:\n        #print('back')\n        t -= b\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n    else:\n        t += a\n        if t > m:\n            break\n        if t > last:\n            #print('forward', t - last, 'with', nvis)\n            count += (t - last)*nvis\n            last = t\n        if vis[t]:\n            break\n        vis[t] = 1\n        nvis += 1\n    #print(nvis,count)\n    #print('---')\n\nif t > m:\n    # we're done\n    count += (m - last + 1)*nvis\nelse:\n    def sumto(n):\n        whole = n//g + 1\n        r = whole*(whole+1)//2 * g\n        corr = whole * (g-1 - (n%g))\n        r -= corr\n        return r\n\n    #S = 0\n    #for i in range(last, m+1):\n    #    S += i//g + 1\n    #count += S\n    #assert S == sumto(m) - sumto(last-1)\n\n    count += sumto(m) - sumto(last-1)\n\n#print(vis)\nprint(count)\n", "from collections import deque\ndef gcd(a, b):\n    b = abs(b)\n    while b != 0:\n        r = a%b\n        a,b = b,r\n    return a\n\nM, A, B = list(map(int, input().split()))\nX = [1]+[0]*(10**6)\nY = [0]\ns = 1\nt = 1\ng = gcd(A, B)\nfor N in range(1, M+1):\n    if N >= A+B+g and (M-N+1) % g == 0:\n        ss = Y[N-1]-Y[N-g-1]\n        dd = (Y[N-1]-Y[N-2]) - (Y[N-g-1]-Y[N-g-2])\n        t += ss*(M-N+1)//g + dd*g*((M-N+1)//g)*((M-N+1)//g+1)//2\n        break\n    elif N >= A and X[N-A]:\n        que = deque([N])\n        X[N] = 1\n        s += 1\n        while len(que):\n            i = deque.pop(que)\n            if i >= B and X[i-B] == 0:\n                deque.append(que, i-B)\n                X[i-B] = 1\n                s += 1\n            if i + A < N and X[i+A] == 0:\n                deque.append(que, i+A)\n                X[i+A] = 1\n                s += 1\n    t += s\n    Y.append(t)\nprint(t)\n\n", "M, a, b = map(int, input().split())\nmod = 10**9+7\nD = [mod]*a\nmaxi = 0\nD[0] = 0\nQ = [0]\ndef f(x, i):\n    t = (x+1-i)//a\n    r = (x+1-i)%a\n    return a*t*(t+1)//2+r*(t+1)\n\nwhile Q:\n    q = Q.pop()\n    D[q] = maxi\n    k = max(0, -((-(b-q))//a))\n    maxi = max(maxi, q+k*a)\n    if D[(q-b)%a] == mod and maxi <= M:\n        Q.append((q-b)%a)\nans = 0\nfor i, d in enumerate(D):\n    if d > M:\n        continue\n    ans += f(M, i) - f(d-1, i)\nprint(ans)", "import sys\nimport math\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm,a,b=list(map(int,input().split()))\n\nGCD=gcd(a,b)\n\n\n#when a>b,\n\nMODLIST=[-1]*a\n\nNOWMAX=a\nNOW=a\nMODLIST[0]=a\nwhile True:\n    \n    while NOW-b>0 and MODLIST[(NOW-b)%a]==-1:\n        NOW-=b\n        MODLIST[NOW]=NOWMAX\n\n    NOW+=a\n    NOWMAX=max(NOW,NOWMAX)\n\n    if MODLIST[(NOW-b)%a]!=-1:\n        break\n\nANS=m+1#0\nMAX=max(MODLIST)\nfor i in range(1,min(m+1,MAX)):\n    if MODLIST[i%a]==-1:\n        continue\n    ANS+=max((m+1-max(MODLIST[i%a],i)),0)\n\n    #print(ANS)\n\n\nif MAX<=m:\n    ANS+=(m-MAX+1+(m-m//GCD*GCD)+1)*((m//GCD*GCD-MAX)//GCD+1)//2\n\nprint(ANS)\n    \n\n\n    \n    \n    \n", "from math import gcd\nm, a, b = list(map(int, input().split()))\nlast, x = 0, gcd(a, b)\ns = [1]*(a+b+1)\nq1, ans = 0, 1\nmax1, s[0] = [[0, 1]], 0\nwhile q1 < a+b:\n    if q1 > b and s[q1-b]:\n        ans += 1\n        q1 -= b\n        s[q1] = 0\n    else:\n        q1 += a\n        if q1 > last:\n            max1.append([q1, ans])\n            last = q1\n        if s[q1]:\n            ans += 1\n            s[q1] = 0\nans1 = q1 = 0\nfor q in range(min(m+1, a+b)):\n    if max1[q1+1][0] == q:\n        q1 += 1\n    ans1 += max1[q1+1][1]\nif m >= a+b:\n    ans1 += (m//x+1)*(m % x+1)\n    m -= m % x+1\n    p, t = (a+b)//x, (m-a-b)//x\n    ans1 += (t+1)*(t+2)//2*x\n    ans1 += p*(t+1)*x\nprint(ans1)\n", "import math\nm,a,b=list(map(int,(input().split())))\nvis=[-1]*(a+b+5)\nnow=0\nmaxd=0\nwhile True:\n    vis[now]=maxd\n    #print(now,maxd)\n    if now>=b:\n        now-=b\n    else:\n        now+=a\n    if now==0:\n        break\n    maxd=max(maxd,now)\nans=0\n#for i in range(0,a+b):\n    #print(vis[i])\nfor i in range(0,a+b):\n    if vis[i]!=-1:\n        ans+=max(0,m-vis[i]+1)\nrest=m-(a+b)+1\nif m>=a+b:\n    g=math.gcd(a,b)\n    tmp=(rest//g)*g\n    fir=rest-tmp\n    lst=rest\n    cnt=tmp//g+1\n    ans+=(fir+lst)*cnt//2\nprint(int(ans))\n", "import math\nm,a,b=list(map(int,(input().split())))\nvis=[-1]*(a+b+5)\nnow=0\nmaxd=0\nwhile True:\n    vis[now]=maxd\n    #print(now,maxd)\n    if now>=b:\n        now-=b\n    else:\n        now+=a\n    if now==0:\n        break\n    maxd=max(maxd,now)\nans=0\n#for i in range(0,a+b):\n    #print(vis[i])\nfor i in range(0,a+b):\n    if vis[i]!=-1:\n        ans+=max(0,m-vis[i]+1)\nrest=m-(a+b)+1\nif m>=a+b:\n    g=math.gcd(a,b)\n    tmp=(rest//g)*g\n    fir=rest-tmp\n    lst=rest\n    cnt=tmp//g+1\n    ans+=(fir+lst)*cnt//2\nprint(int(ans))\n", "import math\nM, A, B = list(map(int, input().split()))\nbound = [10**9 + 7]*(A + B)\nl, r = 0, 0\nwhile True:\n    bound[l] = r\n    if l >= B:\n        l -= B\n    else:\n        l += A\n    r = max(r, l)\n    if l == 0:\n        break\n\nans = 0\nfor i in range(0, A + B):\n    if bound[i] <= M:\n        ans += M - bound[i] + 1\n\nrem = M - (A + B) + 1\nif M >= (A + B):\n    g = math.gcd(A, B)\n    up = (rem // g) * g\n    lo = rem - up\n    cnt = up // g + 1\n    ans += (lo + rem) * cnt // 2\nprint(ans)\n", "import math\nM, A, B = map(int, input().split())\nbound = [10**9 + 7]*(A + B)\nl, r = 0, 0\nwhile True:\n    bound[l] = r\n    if l >= B:\n        l -= B\n    else:\n        l += A\n    r = max(r, l)\n    if l == 0:\n        break\n\nans = 0\nfor i in range(0, A + B):\n    if bound[i] <= M:\n        ans += M - bound[i] + 1\n\nrem = M - (A + B) + 1\nif M >= (A + B):\n    g = math.gcd(A, B)\n    up = (rem // g) * g\n    lo = rem - up\n    cnt = up // g + 1\n    ans += (lo + rem) * cnt // 2\nprint(ans)"]
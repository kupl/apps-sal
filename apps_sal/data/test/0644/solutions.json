["l = int(input())\na = [0] * (l+1)\nb = [1] * (l+1)\nst = 0\nen = 1\ncur = 0\nfor i in range(l):\n    x = input()\n    if x == 'add':\n        a[en-1] += 1\n    elif x[0] == 'f':\n        d = x.split()\n        v = int(d[1])\n        a[en] = 0\n        b[en] = v\n        en += 1\n    else:\n        en -= 1\n        a[en-1] += a[en] * b[en]\n        if a[en-1] >= 2 ** 32:\n            cur = 1\n            break\nif cur == 1 or a[0] >= 2 ** 32:\n    print('OVERFLOW!!!')\nelse:\n    print(a[0])\n\n", "n = int(input())\nx = 0\nloops = []\nfor _ in range(n):\n    if x >= 2**32:\n        break\n    l = input()\n    if l.startswith('for '):\n        mul = int(l[4:])\n        loops.append((x, mul))\n    elif l.startswith('end'):\n        old_x, mul = loops.pop()\n        x = old_x + mul * (x - old_x)\n    else:\n        x += 1\nif x >= 2**32:\n    print('OVERFLOW!!!')\nelse:\n    print(x)\n", "l = int(input())\nans = 0\nnest = 0\nF = []\nm = 1\nfor _ in range(l):\n    com = input()\n    if com == \"add\":\n        ans += m\n        if ans >= 2**32:\n            ans = \"OVERFLOW!!!\"\n            break\n    elif com == \"end\":\n        m //= F.pop()\n    else:\n        if m > 2**40:\n            a = 1\n        else:\n            a = int(com.split()[1])\n        F.append(a)\n        m *= a\n\nprint(ans)\n", "\ndef main():\n    buf = input()\n    n = int(buf)\n    command = []\n    for i in range(n):\n        buf = input()\n        buflist = buf.split()\n        if len(buflist) == 2:\n            buflist[1] = int(buflist[1])\n        command.append(buflist)\n    x = []\n    for i in range(n):\n        x.append(0)\n    stack = []\n    nest = 0\n    for c in command:\n        if c[0] == 'for':\n            stack.append(c[1])\n            nest += 1\n        elif c[0] == 'add':\n            x[nest] += 1\n        else: # c[0] == 'end'\n            x[nest-1] += x[nest] * stack.pop()\n            x[nest] = 0\n            nest -= 1\n        if x[nest] >= int(2 ** 32):\n            print('OVERFLOW!!!')\n            return\n    print(x[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\npr = 0\nmn = [1]\nprib = [0]\nb = 1\nfor _ in range(n):\n\ts = input().split()\n\tif s[0] == 'add':\n\t\tprib[-1] += 1\n\telif s[0] == 'for':\n\t\tmn.append(int(s[1]))\n\t\tprib.append(0)\n\telse:\n\t\te = prib.pop() * mn.pop()\n\t\tprib[-1] += e\n\t\tif prib[-1] > 2**32-1:\n\t\t\tb = 0\n\t\t\tbreak\nif b:\n\tif prib[0] <= 2**32-1:\n\t\tprint(prib[0])\n\telse:\n\t\tprint('OVERFLOW!!!')\nelse:\n\tprint('OVERFLOW!!!')", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nl=int(input())\n\nQUE=deque()\n\nfor q in range(l):\n    QUE.append(input().split())\n\n    while len(QUE)>=2 and QUE[-1][0]==\"end\" and QUE[-2][0]==\"for\":\n        QUE.pop()\n        QUE.pop()\n\n\nANS=0\nQ=deque()\nQ.append(1)\nSUM=1\n\nfor s in QUE:\n    \n    if s[0]==\"add\":\n        ANS+=SUM\n    elif s[0]==\"for\":\n        Q.append(int(s[1]))\n        SUM=min(SUM*int(s[1]),1<<40)\n\n    else:\n        x=Q.pop()\n        SUM//=x\n\n    if ANS>2**32-1:\n        print(\"OVERFLOW!!!\")\n        break\n\nelse:\n    print(ANS)\n    \n    \n", "l = int(input())\ntmp = [0]\nstack = [1]\nfor i in range(l):\n\tline = input().split()\n\tif line[0] == 'add':\n\t\ttmp[-1] += 1\n\t\tif tmp[-1] >= 2 ** 32:\n\t\t\tprint('OVERFLOW!!!')\n\t\t\treturn\n\telif line[0] == 'for':\n\t\tstack.append(int(line[1]))\n\t\ttmp.append(0)\n\telse:\n\t\tt = stack.pop()\n\t\ttt = tmp.pop()\n\t\ttmp[-1] += t * tt\n\t\tif tmp[-1] >= 2 ** 32:\n\t\t\tprint('OVERFLOW!!!')\n\t\t\treturn\n\nprint(tmp[-1])\n", "a = int(input())\ncur = 1\nlast = 1\nans = 0\nprev = []\nwhile (a > 0):\n    a-=1\n    st = input();\n    if (st[2]=='r'):\n        b = st.split(' ')\n        b = int(b[1])\n        if (cur>=2**64):\n            b = 1\n        cur*=b\n        prev.append(b)\n    if (st[2] == 'd' and st[1] == 'd'):\n        ans+=cur\n    if (st[2] == 'd' and st[1] == 'n'):\n        val = prev[len(prev) - 1]\n        prev.pop()\n        cur/=val\n    if (ans >= 2**32):\n        break\nif (ans >= 2**32):\n    print(\"OVERFLOW!!!\")\nelse:\n    print(int(ans))", "# tzuyu <3\n\nN = pow(2, 32)\n\nl = int(input())\nn = 0\ns = []\nt = []\nfor _ in range(l):\n    i = input()\n    if i == 'add':\n        if t:\n            t[-1] += 1\n        else:\n            n += 1\n            if n >= N:\n                import sys\n                print('OVERFLOW!!!')\n                return\n    if i.startswith('for'):\n        i = i.split(' ')\n        c = int(i[1])\n        s.append(c)\n        t.append(0)\n    if i == 'end':\n        c = s.pop()\n        x = t.pop()\n        x *= c\n        if t:\n            t[-1] += x\n            if t[-1] >= N:\n                import sys\n                print('OVERFLOW!!!')\n                return\n        else:\n            n += x\n            if n >= N:\n                import sys\n                print('OVERFLOW!!!')\n                return\n\nif n >= N:\n    import sys\n    print('OVERFLOW!!!')\n    return\nprint(n)\n", "temp=[0]\ntemp2=[1]\nju=int(pow(2,32)-1)\nn=int(input())\nans=0\nfor i in range(n):\n\tt=input()\n\tif t=='add':\n\t\tans+=temp2[-1]\n\t\tif temp2[-1]==-1:\n\t\t\tprint('OVERFLOW!!!')\n\t\t\treturn\n\telif t=='end':\n\t\ttemp.pop()\n\t\ttemp2.pop()\n\telse:\n\t\ttt=t.split()\n\t\ttemp.append(int(tt[-1]))\n\t\tif temp2[-1]<0:\n\t\t\ttemp2.append(-1)\n\t\telse:\n\t\t\tttt=temp2[-1]*int(tt[-1])\n\t\t\tif ttt>ju:\n\t\t\t\ttemp2.append(-1)\n\t\t\telse:\n\t\t\t\ttemp2.append(temp2[-1]*int(tt[-1]))\n\t\t\nif ans>ju:\n\tprint('OVERFLOW!!!')\nelse:\n\tprint(ans)", "n = int(input())\nL = []\n\nfor _ in range(n):\n    s = input()\n    L.append(s)\n\nS = [(0, 1)]\nk = 0\n\nzeta = 2**32-1\nfine = True\n\nfor i in range(n):\n    if 'add' in L[i]:\n        if (S[-1][0] == 1):\n            fine = False\n            break\n        k += S[-1][1]\n    elif 'end' in L[i]:\n        S.pop()\n    elif 'for' in L[i]:\n        if S[-1][0] == 1:\n            S.append(S[-1])\n            continue\n        x = int(L[i].split()[1])*S[-1][1]\n        if x > zeta:\n            S.append((1, 0))\n        else:\n            S.append((0, x))\n    if k > zeta:\n        fine = False\n        break\nif fine:\n    print(k)\nelse:\n    print('OVERFLOW!!!')\n\n\n", "import math\nn=int(input())\nl=1\nl1=[]\nans=0\nd=math.pow(2,32)-1\nf=False\nfor i in range(n) :\n    s=input().split()\n    if s[0]==\"add\" :\n        if f :\n            print(\"OVERFLOW!!!\")\n            return\n        ans+=l\n    if s[0]==\"for\" :\n        w=int(s[1])\n        if d<l*w :\n            f=True\n            l1.append([w,0])\n        else:\n            l*=w\n            l1.append([w,1])\n        \n    if s[0]==\"end\" :\n        if l1[-1][1]==1 :\n            l/=l1[-1][0]\n        else :\n            if l1[-2][1]==1 :\n                f=False\n        l1.pop()\n        \n    if ans>d :\n        print(\"OVERFLOW!!!\")\n        return\nprint(int(ans))\n        \n        \n    \n", "n = int(input())\ninf = 2**32 - 1\nx = 0\nmult = [1]\nuk = 0\namount = 1\nfor i in range(n):\n    l = list(input().split())\n    if l[0] == \"for\":\n        mult.append(int(l[1]))\n    if l[0] == \"end\":\n        if (uk + 1 == len(mult)):\n            amount //= mult[-1]\n        mult.pop()\n        if (uk == len(mult)): uk -= 1\n    if l[0] == \"add\":\n        while uk < len(mult) - 1:\n            uk += 1\n            amount *= mult[uk]\n            if amount > inf:\n                print('OVERFLOW!!!')\n                return\n        x += amount\n        if (x > inf):\n            print('OVERFLOW!!!')\n            return\nprint(x)", "t = int(input())\nst = [1]\nx = 0\nOVER = (1 << 32) - 1\nfor _ in range(t):\n    command = input().split(\" \")\n    if command[0] == \"add\":\n        x += st[-1]\n        if x > OVER:\n            print(\"OVERFLOW!!!\")\n            return\n    elif command[0] == \"for\":\n        number = int(command[1])\n        st.append(min(OVER + 1, st[-1] * number))\n    elif command[0] == \"end\":\n        st.pop(-1)\nprint(x)\n    \n", "lim = 2 ** 32 - 1\nn = int( input() )\nans = 0\nf = [ 1 ]\na = [ 0 ]\nov = False\nfor l in range(n):\n    i = input()\n    if i == 'add':\n        if a[ -1 ] < lim:\n            a[ -1 ] += 1\n        else:\n            ov = True\n            break\n    elif i[ :3 ] == 'for':\n        f.append( int(i[ 4: ]) )\n        a.append( 0 )\n    else:\n        if a[ -1 ] == 0:\n            f.pop()\n            a.pop()\n            continue\n        if lim / f[ -1 ] < a[ -1 ]:\n            ov = True\n            break\n        sm = f.pop() * a.pop()\n        if lim - sm < a[ -1 ]:\n            ov = True\n            break\n        a[ -1 ] += sm\n\nif not ov:\n    print( a[ -1 ] )\nelse:\n    print( \"OVERFLOW!!!\")\n", "l = int(input())\n\ncom = []\nfor i in range(l):\n\ts = input()\n\tcom += [s]\n\ndef parse(commands):\n\tstack = []\n\tadder = 0\n\tfor s in commands:\n\t\tif s.startswith(\"for\"):\n\t\t\tx = int(s.split()[1])\n\t\t\tstack.append((x, adder))\n\t\t\tadder = 0\n\t\telif s==\"end\":\n\t\t\told_x, old_adder = stack.pop()\n\t\t\tadder = old_adder + adder * old_x\n\t\t\tif adder > 2**32-1:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tadder += 1\n\treturn adder\nadder = parse(com)\n\nif adder > 2**32-1:\n\tprint(\"OVERFLOW!!!\")\nelse:\n\tprint(adder)", "l=int(input())\na=[]\nans=0\nb=[]\nfor i in range(l+5):\n\ta.append(0)\n\tb.append(0)\ntemp=1\nii=1\na[0]=1\nb[0]=1\ng=2**32-1\nover=0\nfor i in range(l):\n\tx=list(input().split())\n\tif(x[0]=='add'):\n\t\tans+=b[ii-1]*1\n\telif(x[0]=='for'):\n\t\tb[ii]=int(x[1])*b[ii-1]\n\t\ta[ii]=int(x[1])\n\t\tif(b[ii]>g):\n\t\t\tb[ii]=g+2\n\t\tii+=1\n\telif(x[0]=='end'):\n\t\ttemp=b[ii-1]//a[ii-1]\n\t\tii-=1\n\tif(ans>g):\n\t\tover=1\n\t\tbreak\nif(over==1):\n\tprint(\"OVERFLOW!!!\")\nelse:\n\tprint(ans)", "n= int(input())\na=[0]*(n//2+1)\nk=[0]*(n//2+1)\nj=0\ndf=False\nfor i in range (n):\n    str=input().split()\n    if str[0]=='add':\n        a[j]+=1\n    if str[0]=='for':\n        j+=1\n        k[j]=int(str[1])\n    if str[0]=='end':\n        j-=1\n        a[j]+=a[j+1]*k[j+1]\n        a[j+1]=0\n    if a[j]>=4294967296:\n        df=True\n        \n        break\nif df==True:\n    print('OVERFLOW!!!')\nelse:\n    print(a[0])\n", "k=0\nad=[]\nres=0\nfor _ in range(int(input())):\n\ts=input()\n\tif res>2**32-1 :\n\t\tbreak\n\tif len(ad)>0:\n\t\tif (res+ ad[-1][0]*ad[-1][1])>2**32-1 :\n\t\t\tres =res+ (ad[-1][0]*ad[-1][1])\n\t\t\tbreak\n\n\tif s[:3]=='add':\n\t\tif len(ad)>0:\n\t\t\tad[-1][0]+=1\n\t\telse:\n\t\t\tres+=1\n\telif s[:3]=='end':\n\t\tk=ad[-1][0]*ad[-1][1]\n\t\tad.pop()\n\t\tif len(ad)>0:\n\t\t\tad[-1][0]+=k\n\t\telse:\n\t\t\tres+=k\n\t\tk=0\n\telse:\n\t\tp=int(s[4:])\n\t\tad.append([0,p])\n\t# print(ad,res,k)\nif res>2**32-1:\n\tprint('OVERFLOW!!!')\nelse:\n\tprint(res)", "t = int(input())\nr = 0\ns = [0] * 10**5\nss = 0\nfor _ in range(t):\n    x = input().split()\n    if x[0] == 'add':\n        r += 1\n    elif x[0] == 'for':\n        s[ss] = (r, int(x[1]))\n        ss += 1\n        r = 0\n    elif x[0] == 'end':\n        ss -= 1\n        r_old, k = s[ss]\n        r = r_old + r * k\n        if r >= 2**32:\n            print(\"OVERFLOW!!!\")\n            break\nelse:\n    print(r if r < 2**32 else \"OVERFLOW!!!\")", "ov = 2**32-1\ncnt = 1\nx = 0\nt = int(input())\nst = []\nfor i in range(t):\n\ts = input().split()\n\tif s[0] == \"for\":\n\t\tif len(st) == 0:\n\t\t\tst.append(int(s[1]))\n\t\telse:\n\t\t\tif st[len(st) - 1] != -1 and st[len(st) - 1] * int(s[1]) < ov:\n\t\t\t\tst.append(st[len(st) - 1] * int(s[1]))\n\t\t\telse:\n\t\t\t\tst.append(-1)\n\telif s[0] == \"end\":\n\t\tst.pop()\n\telse:\n\t\tif len(st) != 0 and st[len(st) - 1] == -1:\n\t\t\tx = 2**33\n\t\t\tbreak\n\t\telif len(st) == 0:\n\t\t\tx += 1\n\t\telse:\n\t\t\tx += st[len(st) - 1]\n\nif (x > ov):\n\tprint(\"OVERFLOW!!!\")\nelse:\n\tprint(x)\n", "from collections import defaultdict as dd\nimport math\nimport sys\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\n\nq=nn()\n\n\nx=0\nforstack=[]\nforproduct=1\nbadfors=0\nwilloverflow=False\nbad=0\nfor _ in range(q):\n\n\n\tl=input().split(' ')\n\t#print(l)\n\t\n\tif len(l)==2:\n\t\tif willoverflow: \t\t\n\t\t\tforstack.append(int(l[1]))\n\t\t\tbadfors+=1\n\t\telse:\n\t\t\tforstack.append(int(l[1]))\n\t\t\tforproduct*= int(l[1])\n\t\t\tif x+forproduct>2**32-1:\n\t\t\t\twilloverflow=True\n\t\t\t\tbadfors=1\n\n\telif l[0]=='add':\n\t\tif willoverflow:\n\t\t\tprint(\"OVERFLOW!!!\")\n\t\t\tbad=1\t\t\t\n\t\t\tbreak\n\t\t\t#return\n\t\tx+=forproduct\n\t\tif x>2**32-1:\n\t\t\tprint(\"OVERFLOW!!!\")\n\t\t\tbad=1\t\t\t\n\t\t\tbreak\n\t\t\t#return\n\n\t\t\n\telif l[0]=='end':\n\t\tp=forstack.pop()\n\t\tif willoverflow:\n\t\t\tbadfors-=1\n\n\t\t\tif badfors==0:\n\t\t\t\tforproduct//=p\n\t\t\t\twilloverflow=False\n\t\telse:\n\t\t\tforproduct//=p\n\nif bad==0:\n\tprint(x)\n\t\n\n\n\n\n\n", "T = int(input())\nans = 0\ntop = -1\nstack = []\ntimes = 1\nj = 0\nbj = 0\nwhile T>0:\n    T = T - 1\n    s = input().strip().split()\n    if len(s)==1:\n        if s[0]==\"add\":\n            ans+=times\n        else:\n            if j==0:\n                times//=stack[top]\n                top-=1\n            else:\n                j-=1\n    else:\n        x=int(s[1])\n        \n        if times<=4294967295:\n            times*=x\n            top+=1\n            if top>=len(stack):\n                stack.append(x)\n            else:\n                stack[top]=x\n        else:\n            j+=1\n        \n    if ans>4294967295:\n        bj=1\n        break\nif bj==0:\n    print(ans)\nelse:\n    print(\"OVERFLOW!!!\")"]
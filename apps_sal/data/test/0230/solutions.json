["n = int(input())\ns = input()\nj = 1\nresult = []\nfor i in range(n):\n    while (j < n-1) and (s[i:j] in s[j:]):\n        j += 1\n    result.append(j-i-1)\nprint(max(result))", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n = int(input())\n    s = input().rstrip()\n    l, r = 0, 0\n    res = 0\n    while r < n:\n        r += 1\n        if not s[l:r] in s[r:]:\n            l += 1\n            res = max(res, r-l)\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict as dd\nN = int(input())\ns = str(input())\nmaxlen = N//2\n\ndef solve(tgt):\n    dic = dd(int)\n    st = s[tgt:2*tgt]\n    dic[st] += 1\n    ls = [st]\n    for char in s[2*tgt:]:\n        st = st[1:]+char\n        dic[st] += 1\n        ls.append(st)\n    st = s[:tgt]\n    if dic[st] > 0:\n        return True\n    dic[ls[0]] -= 1\n    for i,char in enumerate(s[tgt:N-tgt]):\n        st = st[1:]+char\n        if dic[st] > 0:\n            return True\n        dic[ls[i+1]] -= 1\n    return False\n\nng = maxlen + 1\nok = 0\nwhile ng-ok > 1:\n    tgt = (ok+ng)//2\n    if solve(tgt):\n        ok = tgt\n    else:\n        ng = tgt\nprint(ok)\n", "n=int(input())\ns=input()\nl=0\nr=n\nwhile r-l!=1:\n  mid=(r+l)//2\n  dic={}\n  flag=False\n  for i in range(n-mid+1):\n    tmp=s[i:i+mid]\n    if tmp not in dic:\n      dic[tmp]=i+mid\n    else:\n      if dic[tmp]<=i:\n        flag=True\n        break\n  if flag==True:\n    l=mid\n  else:\n    r=mid\nprint(l)", "n = int(input())\ns = input()\nret = 0\nfor l in range(n):\n  while s[l:l+ret+1] in s[l+ret+1:]:\n    ret += 1\nprint(ret)", "N = int(input())\nS = input()\n\ndef f(m):\n    se = set()\n    arr = [None]*N\n    for i in range(0,N-m+1):\n        if i >= m:\n            se.add(arr[i-m])\n        arr[i] = S[i:i+m]\n        if arr[i] in se:\n            return True\n    return False\n\nl = 0\nr = N//2+1\nwhile (r-l)>1:\n    mid = (r+l)//2\n    if f(mid):\n        l = mid\n    else:\n        r = mid\nprint(l)\n", "from typing import List, Tuple\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._base = base\n        self._mod = mod\n        self._hash, self._power = self._build(source)\n\n    def _build(self, source: str) -> Tuple[List[int], List[int]]:\n        \"\"\"Compute \"hash\" and \"mod of power of base\" of interval [0, right).\"\"\"\n        length = len(source)\n        hash_, power = [0] * (length + 1), [0] * (length + 1)\n        power[0] = 1\n        for i, c in enumerate(source, 1):\n            hash_[i] = (hash_[i - 1] * self._base + ord(c)) % self._mod\n            power[i] = power[i - 1] * self._base % self._mod\n        return hash_, power\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "import random\nfrom collections import defaultdict\n\n\nclass RollingHash():\n\n    def __init__(self, S, b=3491, m=999999937):\n        \"\"\"\u4efb\u610f\u306e\u57fa\u6570\u3068\u6cd5\u3067\u30cf\u30c3\u30b7\u30e5\u3092\u751f\u6210\u3059\u308b\"\"\"\n        n = len(S)\n        self.prefix = prefix = [0] * (n+1)\n        self.power = power = [1] * (n+1)\n        self.b = b\n        self.m = m\n        for i in range(n):\n            c = ord(S[i])\n            prefix[i+1] = (prefix[i] * b + c) % m\n            power[i+1] = (power[i] * b) % m\n    \n    def get(self, l, r):\n        \"\"\"S[l, r) \u306e\u30cf\u30c3\u30b7\u30e5\u3092\u6c42\u3081\u308b\"\"\"\n        return (self.prefix[r] - self.power[r-l] * self.prefix[l]) % self.m\n    \n    def concat(self, h1, h2, l2):\n        \"\"\"S1+S2 \u306e\u30cf\u30c3\u30b7\u30e5\u3092\u3001\u305d\u308c\u305e\u308c\u306e\u30cf\u30c3\u30b7\u30e5\u304b\u3089\u6c42\u3081\u308b\"\"\"\n        return (self.power[l2] * h1 + h2) % self.m\n    \n    def lcp(self, l1, r1, l2, r2):\n        \"\"\"S[l1, r1) \u3068S[l2, r2) \u306e\u6700\u5927\u5171\u901a\u63a5\u982d\u8f9e\u3092\u6c42\u3081\u308b\"\"\"\n        low = 0\n        high = min(r1-l1, r2-l2) + 1\n        while high - low > 1:\n            mid = (high + low) // 2\n            if self.get(l1, l1 + mid) == self.get(l2, l2 + mid):\n                low = mid\n            else:\n                high = mid\n        return low\n\n\ndef read():\n    N = int(input().strip())\n    S = input().strip()\n    return N, S\n\n\ndef solve(N, S):\n    ans = []\n    for m in [999999937, 10**9+7]:\n        b = random.randint(10000, m-1)\n        rh = RollingHash(S, b=b, m=m)\n        low = 0\n        high = (N+1) // 2 + 1\n        dmax = defaultdict(int)\n        dmin = defaultdict(int)\n        while high - low > 1:\n            dmax.clear()\n            dmin.clear()\n            mid = (high + low) // 2\n            for i in range(0, N-mid+1):\n                h = rh.get(i, i+mid)\n                dmax[h] = max(dmax[h], i+1)\n                dmin[h] = max(dmin[h], N+1-i)\n            is_match = False\n            for h in dmax.keys():\n                if dmax[h] - (N+2 - dmin[h]) >= mid:\n                    is_match = True\n                    break\n            if is_match:\n                low = mid\n            else:\n                high = mid\n        ans.append(low)\n    return min(ans)\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print(\"%s\" % str(outputs))\n__starting_point()", "from collections import defaultdict\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD\n        return _hash\n\ndef main():\n    N = int(input())\n    S = input()\n    MOD = 998244353\n    rs = RollingHash(S, MOD=MOD, BASE=37)\n    h, p = rs.HASH, rs.POWER\n\n    left, right = 0, N // 2 + 1\n\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n        ok = False\n        hash_to_left = defaultdict(list)\n        L = mid\n        for i in range(N - L + 1):\n            _hash = (h[i+L] - h[i] * p[L]) % MOD\n            # hash\u304c\u885d\u7a81\u3057\u3066\u3082\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\n            # \u885d\u7a81\u3057\u305f\u5834\u5408\u306f\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u8abf\u3079\u3001\u304b\u3064\n            # \u6587\u5b57\u5217\u540c\u58eb\u304cS\u306e\u4e2d\u3067\u91cd\u306a\u308b\u3088\u3046\u306a\u7bc4\u56f2\u306b\u306a\u3044\u5834\u5408\u306fOK\u3068\u3059\u308b\n            for j in hash_to_left[_hash]:\n                if j+L <= i and S[i:i+L] == S[j:j+L]:\n                    ok = True\n                    break\n            if ok:\n                break\n            hash_to_left[_hash].append(i)\n\n    \n        if ok:\n            left = mid\n        else:\n            right = mid\n\n    print(left)\n    # # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    # def isOK(L):\n    #     if L == 0:\n    #         return True\n    #     hash_to_left = defaultdict(list)\n    #     for i in range(N - L + 1):\n    #         _hash = rs.hash(i, i + L)\n    #         # hash\u304c\u885d\u7a81\u3057\u3066\u3082\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\n    #         # \u885d\u7a81\u3057\u305f\u5834\u5408\u306f\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u8abf\u3079\u3001\u304b\u3064\n    #         # \u6587\u5b57\u5217\u540c\u58eb\u304cS\u306e\u4e2d\u3067\u91cd\u306a\u308b\u3088\u3046\u306a\u7bc4\u56f2\u306b\u306a\u3044\u5834\u5408\u306fOK\u3068\u3059\u308b\n    #         for j in hash_to_left[_hash]:\n    #             if j+L <= i and S[i:i+L] == S[j:j+L]:\n    #                 return True\n    #         hash_to_left[_hash].append(i)\n\n    #     return False\n    # # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    # ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    # print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD\n        # if _hash < 0:\n        #     _hash += self.MOD\n        return _hash\n\n# \u6c4e\u7528\u7684\u306a\u4e8c\u5206\u63a2\u7d22\u306e\u30c6\u30f3\u30d7\u30ec\n# check_func(x) = true \u3068\u306a\u308bx\u306e\u6700\u5c0f\u5024\u3092\u63a2\u7d22\u3059\u308b\n# left : check_func(x) = false\u3068\u306a\u308bx\n# right: check_func(x) = true \u3068\u306a\u308bx\n# search_max: check_func(x) = true \u3068\u306a\u308bx\u306e\"\u6700\u5927\u5024\"\u3092\u63a2\u7d22\u3059\u308b\u5834\u5408\u306fTrue\n# check_func: answer <= x \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\ndef binary_search(left: int, right: int, check_func, search_max:bool=False):\n    # ok \u3068 ng \u306e\u3069\u3061\u3089\u304c\u5927\u304d\u3044\u304b\u308f\u304b\u3089\u306a\u3044\u3053\u3068\u3092\u8003\u616e\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n    \n        if check_func(mid) ^ search_max:\n            right = mid\n            # print(left, right, mid, 't')\n        else:\n            left = mid\n            # print(left, right, mid, 'f')\n\n    return left if search_max else right\n\ndef main():\n    N = int(input())\n    S = input()\n\n    rs = RollingHash(S, MOD=998244353, BASE=37)\n\n    # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    def isOK(L):\n        if L == 0:\n            return True\n        hash_to_left = defaultdict(list)\n        for i in range(N - L + 1):\n            _hash = rs.hash(i, i + L)\n            # hash\u304c\u885d\u7a81\u3057\u3066\u3082\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\n            # \u885d\u7a81\u3057\u305f\u5834\u5408\u306f\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u8abf\u3079\u3001\u304b\u3064\n            # \u6587\u5b57\u5217\u540c\u58eb\u304cS\u306e\u4e2d\u3067\u91cd\u306a\u308b\u3088\u3046\u306a\u7bc4\u56f2\u306b\u306a\u3044\u5834\u5408\u306fOK\u3068\u3059\u308b\n            for j in hash_to_left[_hash]:\n                if j+L <= i:\n                    return True\n            hash_to_left[_hash].append(i)\n\n        return False\n    # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "\n\n\n\"\"\"\nN <= 5 * 10**3\u3000\u306a\u306e\u3067\u3001\uff12\u91cd\u30eb\u30fc\u30d7\u3050\u3089\u3044\u306a\u3089\u9593\u306b\u5408\u3046\u304b\uff1f\n\n\u4f8b\uff13\nstrangeorange\n**range*range\n\n\u4ed6\u306b\uff12\u56de\u4ee5\u4e0a\u51fa\u3066\u304f\u308b\u3082\u306e\u3068\u3057\u3066\nr,a, \u307f\u305f\u3044\u306a\u5358\u4f53\nra, nge \u307f\u305f\u3044\u306a\u6700\u9577\u306e\u90e8\u5206\u6587\u5b57\u5217\u306e\u4e00\u90e8\n\u307f\u305f\u3044\u306a\u611f\u3058\u306a\u306e\u3067\nl,r (r=l+1~N-1)\u3092\u6301\u3063\u3066\u304a\u3044\u3066\u3001S[l:r+1] = S[r+1:XX]\u306b\u306a\u308b\u3082\u306e\u304c\u3042\u308c\u3070\u3055\u3089\u306b\u53f3\u3092\u307f\u3066\uff5e\u307f\u305f\u3044\u306a\uff1f\n\n\"\"\"\n\n\nN = int(input())\nS = input()\n\n\nl = 0\nr = 1\nans = 0\nwhile True:\n    if l == N-1:\n        break\n    while S[l:r] in S[r:]:\n        r += 1\n\n    ans = max(ans, r - l - 1)\n    #print(l,r, S[l:r], S[r:], ans)\n    l += 1\n    if l == r:\n        r = l + 1\n\nprint(ans)\n\n\n", "N=int(input())\nS=input()\n\nlb=0\nrb=N+1\nwhile rb-lb>1:\n    mid = (lb + rb) // 2\n    x = 0\n    for i, s in enumerate(S[:mid]):\n        x += pow(26, i) * (ord(s) - ord('a'))\n    m = pow(26, mid - 1)\n    a = [x]\n    for i, s in enumerate(S[mid:]):\n        x -= ord(S[i]) - ord('a')\n        x //= 26\n        x += m * (ord(s) - ord('a'))\n        a += [x]\n    f = 0\n    se = set([])\n    for i, x in enumerate(a):\n        if i >= mid:\n            se.add(a[i - mid])\n        if x in se:\n            f = 1\n            break\n    if f:\n        lb=mid\n    else:\n        rb=mid\nprint(lb)\n", "import numpy as np\n\nn = int(input())\ns = np.array(list(input()))\n\nl = s.size\n\ndp = np.zeros(l, dtype=np.int16)\nans = 0\nfor i, e in enumerate(s, 1):\n    dp_prev = dp[:]\n    mx = np.arange(1, l + 1) - i\n    idx = np.hstack([np.full(i, False), s[i:] == e]).astype(np.bool)\n    idx_prev = np.hstack([np.full(i-1, False), s[i:] == e, False]).astype(np.bool)\n    dp = np.zeros(l, dtype=np.int16)\n    dp[idx] = np.minimum(dp_prev[idx_prev] + 1, mx[idx])\n    ans = max(ans, dp.max())\n\nprint(ans)\n", "n=int(input())\ns=input()\nl=0\nr=n\nwhile r-l!=1:\n  mid=(r+l)//2\n  dic={}\n  flag=False\n  for i in range(n-mid+1):\n    tmp=s[i:i+mid]\n    if tmp not in dic:\n      dic[tmp]=i+mid\n    else:\n      if dic[tmp]<=i:\n        flag=True\n        break\n  if flag==True:\n    l=mid\n  else:\n    r=mid\nprint(l)", "class RollingHash(object):\n    def __init__(self, S, base, mod):\n        self.mod = mod\n        l = len(S)\n\n        self.hash_lst = [0] * (l + 1)\n        self.pow_lst = [1] * (l + 1)\n\n        for i in range(l):\n            self.hash_lst[i + 1] = (self.hash_lst[i] * base + ord(S[i])) % mod\n            self.pow_lst[i + 1] = (self.pow_lst[i] * base) % mod\n\n    def get_hash(self, left, right):\n        return (self.hash_lst[right] - self.hash_lst[left] * self.pow_lst[right - left] % self.mod) % self.mod\n\n\nN = int(input())\nS = input()\n\nbase = 1007\nmod = pow(10, 9) + 7\nrh = RollingHash(S, base, mod)\n\nleft = 0\nright = N // 2\n\nwhile left <= right:\n    mid = (left + right) // 2\n\n    found_hash = {}\n    found = False\n    for i in range(N - mid + 1):\n        h = rh.get_hash(i, i + mid)\n\n        if h not in found_hash:\n            found_hash[h] = i\n        else:\n            if found_hash[h] <= i - mid:\n                found = True\n                break\n\n    if found:\n        left = mid + 1\n    else:\n        right = mid - 1\n\n\nprint(right)\n", "from collections import defaultdict\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        \n        S_arr = [ord(x) for x in S]\n        POWER = [1] * (N + 1)\n        HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            POWER[i + 1] = p = (p * BASE) % MOD\n            HASH[i + 1] = h = (h * BASE + S_arr[i]) % MOD\n        self.S_arr = S_arr\n        self.POWER = POWER\n        self.HASH = HASH\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD\n        return _hash\n\ndef main():\n    N = int(input())\n    S = input()\n    MOD = 998244353\n    rs = RollingHash(S, MOD=MOD, BASE=37)\n    h, p = rs.HASH, rs.POWER\n\n    left, right = 0, N // 2 + 1\n    D = [0] * N\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n        # hash_to_left = defaultdict(list)\n        hashes = set()\n        L = mid\n        P = p[L]\n        for i in range(min(L, N-2*L+1)):\n            D[i] = (h[L+i] - h[i]*P) % MOD\n        hashes = set()\n        ok = False\n        for i in range(L, N-L+1):\n            hashes.add(D[i-L])\n            D[i] = v = (h[L+i] - h[i]*P) % MOD\n            if v in hashes:\n                ok = True\n                break\n        if ok:\n            left = mid\n        else:\n            right = mid\n\n    print(left)\n\ndef __starting_point():\n    main()\n__starting_point()", "def ok(l):\n    # \u9577\u3055l\u306e\u9023\u7d9a\u90e8\u5206\u5217\u3067\u91cd\u306a\u3089\u305a\u306b2\u56de\u4ee5\u4e0a\u73fe\u308c\u308b\u3082\u306e\u304c\u3042\u308b\n    D = {}\n    for i in range(n-l+1):\n        try:\n            if D[S[i:i+l]]+l <= i:\n                return True\n        except:\n            D[S[i:i+l]] = i\n    return False\n\n\nn = int(input())\nS = input()\n# \u4e8c\u5206\u63a2\u7d22\u3067True\u306b\u306a\u308b\u6700\u5927\u306ek\u3092\u6c42\u3081\u308b\nl, r = 0, n+1\nwhile r-l > 1:\n    c = (l+r)//2\n    if ok(c):\n        l = c\n    else:\n        r = c\nprint(l)\n", "import random\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD\n        return _hash\n\n# \u6c4e\u7528\u7684\u306a\u4e8c\u5206\u63a2\u7d22\u306e\u30c6\u30f3\u30d7\u30ec\n# check_func(x) = true \u3068\u306a\u308bx\u306e\u6700\u5c0f\u5024\u3092\u63a2\u7d22\u3059\u308b\n# left : check_func(x) = false\u3068\u306a\u308bx\n# right: check_func(x) = true \u3068\u306a\u308bx\n# search_max: check_func(x) = true \u3068\u306a\u308bx\u306e\"\u6700\u5927\u5024\"\u3092\u63a2\u7d22\u3059\u308b\u5834\u5408\u306fTrue\n# check_func: answer <= x \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\ndef binary_search(left: int, right: int, check_func, search_max:bool=False):\n    # ok \u3068 ng \u306e\u3069\u3061\u3089\u304c\u5927\u304d\u3044\u304b\u308f\u304b\u3089\u306a\u3044\u3053\u3068\u3092\u8003\u616e\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n    \n        if check_func(mid) ^ search_max:\n            right = mid\n            # print(left, right, mid, 't')\n        else:\n            left = mid\n            # print(left, right, mid, 'f')\n\n    return left if search_max else right\n\ndef main():\n    N = int(input())\n    S = input()\n    MOD = 998244353\n    BASE = 37 # random.randint(2, MOD-1)\n    rs = RollingHash(S, MOD=MOD, BASE=BASE)\n\n    D = [0] * N\n    # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    def isOK(L):\n        if L == 0:\n            return True\n        \n        for i in range(min(L, N - 2 * L + 1)):\n            D[i] = rs.hash(i, i + L)\n        hashes = set()\n        for i in range(L, N - L + 1):\n            # \u81ea\u5206\u3088\u308a\u958b\u59cb\u70b9\u304cL\u4ee5\u4e0a\u524d\u306e\u6587\u5b57\u5217\u306e\u30cf\u30c3\u30b7\u30e5\u3092\u691c\u7d22\u5bfe\u8c61\u306b\u8ffd\u52a0\n            hashes.add(D[i - L])\n            D[i] = v = rs.hash(i, i + L)\n            # \u30cf\u30c3\u30b7\u30e5\u304c\u885d\u7a81\u3057\u305f\u3089\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u6587\u5b57\u5217\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u306b\u306a\u308b\n            if v in hashes:\n                return True\n        return False\n\n    # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "#!usr/bin/env python3\nfrom collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom heapq import heappush, heappop, heapify\n\nimport itertools\nimport math, fractions\nimport sys, copy\n\ndef L(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline().rstrip())\ndef SL(): return list(sys.stdin.readline().rstrip())\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI1(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return [list(x) for x in sys.stdin.readline().split()]\ndef R(n): return [sys.stdin.readline().strip() for _ in range(n)]\ndef LR(n): return [L() for _ in range(n)]\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef LIR1(n): return [LI1() for _ in range(n)]\ndef SR(n): return [SL() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\n\ndef perm(n, r): return math.factorial(n) // math.factorial(r)\ndef comb(n, r): return math.factorial(n) // (math.factorial(r) * math.factorial(n-r))\n\ndef make_list(n, *args, default=0): return [make_list(*args, default=default) for _ in range(n)] if len(args) > 0 else [default for _ in range(n)]\n\ndire = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ndire8 = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]\nalphabets = \"abcdefghijklmnopqrstuvwxyz\"\nALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nMOD = 1000000007\nINF = float(\"inf\")\n\nsys.setrecursionlimit(1000000)\n\nclass DoubleRollingHash:\n    def __init__(self, seq, f=ord):\n        self.n = len(seq)\n        self.base1, self.base2 = 1007, 2009\n        self.mod1, self.mod2 = 1000000007, 1000000009\n        self.f = f # set numerizing function\n\n        self.hash1, self.hash2 = [0]*(self.n+1), [0]*(self.n+1)\n        self.power1, self.power2 = [1]*(self.n+1), [1]*(self.n+1)\n\n        for i, e in enumerate(seq):\n            self.hash1[i+1] = (self.hash1[i] * self.base1 + self.f(e)) % self.mod1\n            self.hash2[i+1] = (self.hash2[i] * self.base2 + self.f(e)) % self.mod2\n            self.power1[i+1] = (self.power1[i] * self.base1) % self.mod1\n            self.power2[i+1] = (self.power2[i] * self.base2) % self.mod2\n\n    # get hash value of seq[left:right]\n    def get(self, l, r):\n        v1 = (self.hash1[r] - self.hash1[l] * self.power1[r-l]) % self.mod1\n        v2 = (self.hash2[r] - self.hash2[l] * self.power2[r-l]) % self.mod2\n        return v1, v2\n\n    # get lcp of seq[a:] and seq[b:]\n    def getLCP(self, a, b):\n        l = self.n - max(a, b) + 1\n        left, right = 0, l\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.get(a, a+mid) == self.get(b, b+mid): left = mid\n            else: right = mid\n        return left\n\nclass RollingHash:\n    def __init__(self, seq, f=ord):\n        self.n = len(seq)\n        self.base, self.mod = 1007, MOD\n        self.f = f # set numerizing function\n        self.hash, self.power = [0]*(self.n+1), [1]*(self.n+1)\n        for i, e in enumerate(seq):\n            self.hash[i+1] = (self.hash[i] * self.base + self.f(e)) % self.mod\n            self.power[i+1] = (self.power[i] * self.base) % self.mod\n\n    # get hash value of seq[left:right]\n    def get(self, l, r): return (self.hash[r] - self.hash[l] * self.power[r-l]) % self.mod\n\n    # get lcp of seq[a:] and seq[b:]\n    def getLCP(self, a, b):\n        l = self.n - max(a, b) + 1\n        left, right = 0, l\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.get(a, a+mid) == self.get(b, b+mid): left = mid\n            else: right = mid\n        return left\n\n\ndef main():\n    N = I()\n    S = SL()\n\n    rh = RollingHash(S)\n    ans = 0\n\n    def check(m):\n        d = defaultdict(lambda: -1)\n        for i in range(N-m+1):\n            v = rh.get(i, i+m)\n            if d[v] != -1:\n                if i >= d[v] + m:\n                    return True\n            else:\n                d[v] = i\n        return False\n\n    left, right = 0, N//2+1\n    while right - left > 1:\n        mid = (left + right) // 2\n        if check(mid): left = mid\n        else: right = mid\n\n    print(left)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from typing import List\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_source\", \"_length\", \"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._source = source\n        self._length = len(source)\n        self._base = base\n        self._mod = mod\n        self._hash = self._build_hash_from_zero()\n        self._power = self._build_base_power()\n\n    def _build_hash_from_zero(self) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        res = [0] * (self._length + 1)\n        for i, c in enumerate(self._source, 1):\n            res[i] = (res[i - 1] * self._base + ord(c)) % self._mod\n        return res\n\n    def _build_base_power(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        res = [1] * (self._length + 1)\n        for i in range(1, self._length + 1):\n            res[i] = res[i - 1] * self._base % self._mod\n        return res\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\nclass RollingHash:\n    def __init__(self, s: str, base=1007, mod=10 ** 9 + 7):\n        self.mod = mod\n        length = len(s)\n        self.pw = [1] * (length + 1)\n        self.h = [0] * (length + 1)\n        \n        v = 0\n        for i in range(length):\n            self.h[i + 1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(length):\n            self.pw[i + 1] = v = v * base % mod\n    \n    def query(self, left, right):\n        return (self.h[right] - self.h[left] * self.pw[right - left]) % self.mod\n\n\ndef solve():\n    N = int(rl())\n    S = input()\n    \n    rh = RollingHash(S)\n    \n    def check(t):\n        dist = dict()\n        for i in range(N - t + 1):\n            h = rh.query(i, i + t)\n            if h in dist:\n                if t <= i - dist[h]:\n                    return True\n            else:\n                dist[h] = i\n        return False\n    \n    ok, ng = 0, N // 2 + 1\n    while 1 < ng - ok:\n        mid = (ok + ng) // 2\n        if check(mid):\n            ok = mid\n        else:\n            ng = mid\n    print(ok)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from typing import List, Tuple\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._base = base\n        self._mod = mod\n        self._hash, self._power = self._build(source)\n\n    def _build(self, source: str) -> Tuple[List[int], List[int]]:\n        \"\"\"Compute \"hash\" and \"mod of power of base\" of interval [0, right).\"\"\"\n        hash_, power = [0] * (len(source) + 1), [0] * (len(source) + 1)\n        power[0] = 1\n        for i, c in enumerate(source, 1):\n            hash_[i] = (hash_[i - 1] * self._base + ord(c)) % self._mod\n            power[i] = power[i - 1] * self._base % self._mod\n        return hash_, power\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "from typing import List\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_source\", \"_length\", \"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._source = source\n        self._length = len(source)\n        self._base = base\n        self._mod = mod\n        self._hash = self._build_hash_from_zero()\n        self._power = self._build_base_power()\n\n    def _build_hash_from_zero(self) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        res = [0] * (self._length + 1)\n        prev = 0\n        for i, c in enumerate(self._source, 1):\n            res[i] = (prev * self._base + ord(c)) % self._mod\n            prev = res[i]\n        return res\n\n    def _build_base_power(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        res = [1] * (self._length + 1)\n        prev = 1\n        for i in range(1, self._length + 1):\n            res[i] = prev * self._base % self._mod\n            prev = res[i]\n        return res\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "import sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n#\u4e8c\u5206\u63a2\u7d22\nN = ir()\nS = sr()\n\ndef check(x):\n    # x\u6587\u5b57\u53f3\u5074\u306b\u305a\u3089\u3057\u305f\u5834\u6240\u3092\u8abf\u3079\u308b\n    candidate = set()\n    for i in range(N - 2*x + 1):\n        candidate.add(S[i:i+x])\n        if S[i+x:i+2*x] in candidate:\n            return True\n    return False\n\nok = 0; ng = N\nwhile abs(ng-ok) > 1:\n    mid = (ok+ng) // 2\n    if check(mid):\n        ok = mid\n    else:\n        ng = mid\n\nprint(ok)\n", "from collections import deque\n\nN = int(input())\nS = input()\n\ndef exists(length):\n    que = deque()\n    V = set()\n    for left in range(N - length + 1):\n        if left > length - 1:\n            V.add(que.popleft())\n        T = S[left: left + length]\n        if T in V:\n            return True\n        que.append(T)\n    return False\n\nok = 0\nng = N\nwhile ng - ok > 1:\n    mid = (ok + ng) // 2\n\n    if exists(mid):\n        ok = mid\n    else:\n        ng = mid\n\nprint(ok)\n\n", "N = int(input())\nS = str(input())\nans = 0\nj = 0\nfor i in range(N):\n  while j < N and S[i:j] in S[j:]:\n    ans = max(ans,j-i)\n    j += 1\n\nprint(ans)", "n=int(input())\ns=input()\n\nfrom collections import defaultdict\n\ndef check(l):\n    d = defaultdict(lambda: -1)\n    for i in range(n-l+1):\n        if d[s[i:i+l]] != -1:\n            if d[s[i:i+l]] + l <= i:\n                return True\n        else:\n            d[s[i:i+l]]=i\n    return False\n\nok=0\nng=len(s)\n\nwhile abs(ok-ng)>1:\n    mid=(ok+ng)//2\n    if check(mid):\n        ok=mid\n    else:\n        ng=mid\n\nprint(ok)", "class RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7) -> None:\n        self._base = base\n        self._mod = mod\n        self._hash = [0] * (len(source) + 1)\n        self._power = [0] * (len(source) + 1)\n\n        self._power[0] = 1\n        for i, c in enumerate(source, 1):\n            self._hash[i] = (self._hash[i - 1] * self._base + ord(c)) % self._mod\n            self._power[i] = self._power[i - 1] * self._base % self._mod\n\n    def get_hash(self, left: int, right: int) -> int:\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "n = int(input())\ns = input()\ndp = [0 for i in range(n + 1)]\nfor i in range(n):\n    if s[i - dp[i]:i + 1] in s[:i - dp[i]]:\n        dp[i + 1] = dp[i] + 1\n    else:\n        dp[i + 1] = dp[i]\nprint(dp[n])", "n=int(input());s=input()\n\na=0\ni=0\nj=1\nwhile j<n:\n    if s[i:j] in s[j:]:\n        a=max(a,j-i)\n        j+=1\n    else:\n        i+=1\n\n    if i==j:\n        i+=1\n        j+=2\nprint(a)", "from random import randint\n\n\nclass RollingHash:\n    def __init__(self, s):\n        self.base = [7073, 7577, 5445, 2742, 6972, 7547, 2267, 286, 6396, 7147,\n                     3307, 188, 266, 8253, 2818, 9527, 5110, 1207, 4633, 6196,\n                     309, 2646, 7533, 85, 9870, 4730, 6862, 9213, 7456, 7098,\n                     6805, 674, 5821, 4864, 8061, 1826, 2219, 459, 5937, 5667,\n                     9033, 5552, 7263, 2402, 9809, 3701, 7048, 2874, 8350, 6006,\n                     973, 3317, 2522, 5546, 1669, 1545, 7972, 4979, 9905, 173,\n                     6812, 7715, 5006, 6068, 6340, 4989, 5510, 6380, 1200, 6739,\n                     5527, 4000, 6519, 3448, 2933, 6048, 3133, 1667, 9086, 8368,\n                     4914, 7142, 2770, 7752, 391, 7052, 5476, 3105, 8322, 3501,\n                     7454, 3167, 8730, 9002, 4564, 138, 2197, 7238, 3411, 7433][randint(0, 99)]\n        self.mod = 4611686018427387903\n        self.size = len(s)\n        self.string = s\n\n        self.hash = self.make_hashtable(s)\n        self.pow = self.make_powtable()\n\n    def make_hashtable(self, _s):\n        hashtable = [0] * (self.size + 1)\n        for i in range(self.size):\n            hashtable[i + 1] = (hashtable[i] * self.base + ord(_s[i])) % self.mod\n        return hashtable\n\n    def make_powtable(self):\n        power = [1] * (self.size + 1)\n        for i in range(self.size):\n            power[i + 1] = (self.base * power[i]) % self.mod\n        return power\n\n    def get_hash(self, left, right):\n        \"\"\"get hash of s[left:right]\"\"\"\n        return (self.hash[right] - self.hash[left] * self.pow[right - left]) % self.mod\n\n    def contain(self, a):\n        \"\"\"return a in s\"\"\"\n        m = len(a)\n        if m > self.size:\n            return False\n        hashs = self.get_hash(0, m)\n        hasha = 0\n        for i in range(m):\n            hasha = (hasha * self.base + ord(a[i])) % self.mod\n        for i in range(self.size - m + 1):\n            if hasha == hashs:\n                return True\n            hashs = self.get_hash(i, m + i)\n        return hasha == hashs\n\n\nfrom collections import defaultdict\n# d = defaultdict(int)\u30670\u3067\u521d\u671f\u5316\n# d = defaultdict(lambda: 100)\u3067100\u3067\u521d\u671f\u5316\nn, s = int(input()), input()\nrh = RollingHash(s)\n\n\ndef check(m):\n    d = defaultdict(lambda: 10000000)\n    for i in range(n - m + 1):\n        h = rh.get_hash(i, i + m)\n        d[h] = min(d[h], i)\n        # m\u4ee5\u4e0a\u96e2\u308c\u3066\u3044\u30662\u56de\u76ee\n        if i - d[h] >= m:\n            return True\n    return False\n\n\nl, r = 0, n // 2 + 1\nwhile l + 1 < r:\n    mid = (l + r) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid\nprint(l)\n", "import sys\n#input = sys.stdin.buffer.readline\n\ndef main():\n    N = int(input())\n    s = input()\n    a,i,j = 0,0,1\n    \n    while j < N:\n        if s[i:j] in s[j:]:\n            a = max(a,j-i)\n            j += 1\n        else:\n            i += 1\n        if i == j:\n            j += 1\n            \n    print(a)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\ns = input()\n\nA = 1234567\nMOD = 10000000000000007\n\ndef ok(length):\n    rolling_hash = 0\n    head = pow(A, length, MOD)\n    occurence = {}\n    for i in range(n):\n        rolling_hash = (rolling_hash * A + ord(s[i])) % MOD\n        if i - length >= 0:\n            rolling_hash = (rolling_hash - head * ord(s[i-length])) % MOD\n        if rolling_hash not in occurence:\n            occurence[rolling_hash] = []\n        occurence[rolling_hash].append(i)\n\n    for key in occurence:\n        if occurence[key][-1] - occurence[key][0] >= length:\n            return True\n    return False\n\nbottom, top = 0, n\n\nwhile top - bottom > 1:\n    mid = (top + bottom) // 2\n    if ok(mid):bottom = mid\n    else: top = mid\n\nprint(bottom)", "N = int(input())\nS = input()\n\nl = 0 # max proven possible\nr = N # min proven impossible\nwhile l + 1 < r:\n  x = (l + r) // 2\n  first_loc = {}\n  possible = False\n  for i in range(N-x+1):\n    #print(i, N-x, first_loc)\n    sub = S[i:i+x]\n    #print(sub)\n    if sub in first_loc:\n      if first_loc[sub] <= i - x:\n        #print(sub, first_loc[sub], i, x, i-x)\n        possible = True\n        break\n    else:\n      first_loc[sub] = i\n  if possible:\n    l = x\n  else:\n    r = x\nprint(l)\n", "N = int(input())\nS = input()\nok, ng = 0, N + 1\nwhile abs(ok - ng) > 1:\n    x = (ok + ng) // 2\n    check = set()\n    for i in range(N - x + 1):\n        check.add(S[i: i + x])\n        if S[i + x: i + 2 * x] in check:\n            ok = x\n            break\n    else:\n        ng = x\n\nprint(ok)", "I=input;n=int(I());s=I();j=1;r=[]\nfor i in range(n):\n    while (j<n)and(s[i:j] in s[j:]):j+=1\n    r.append(j-i-1)\nprint(max(r))", "N = int(input())\nS = input()\nfrom collections import deque\n\ndef f(m):\n    se = set()\n    q = deque()\n    for i in range(0,N-m+1):\n        h = hash(S[i:i+m])\n        q.append(h)\n        if h in se:\n            return True\n        if len(q) >= m:\n            se.add(q.popleft())\n    return False\n\nl = 0\nr = N//2+1\nwhile (r-l)>1:\n    mid = (r+l)//2\n    if f(mid):\n        l = mid\n    else:\n        r = mid\nprint(l)", "#!usr/bin/env python3\nfrom collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom heapq import heappush, heappop, heapify\n\nimport itertools\nimport math, fractions\nimport sys, copy\n\ndef L(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline().rstrip())\ndef SL(): return list(sys.stdin.readline().rstrip())\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI1(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return [list(x) for x in sys.stdin.readline().split()]\ndef R(n): return [sys.stdin.readline().strip() for _ in range(n)]\ndef LR(n): return [L() for _ in range(n)]\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef LIR1(n): return [LI1() for _ in range(n)]\ndef SR(n): return [SL() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\n\ndef perm(n, r): return math.factorial(n) // math.factorial(r)\ndef comb(n, r): return math.factorial(n) // (math.factorial(r) * math.factorial(n-r))\n\ndef make_list(n, *args, default=0): return [make_list(*args, default=default) for _ in range(n)] if len(args) > 0 else [default for _ in range(n)]\n\ndire = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ndire8 = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]\nalphabets = \"abcdefghijklmnopqrstuvwxyz\"\nALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nMOD = 1000000007\nINF = float(\"inf\")\n\nsys.setrecursionlimit(1000000)\n\nclass DoubleRollingHash:\n    def __init__(self, seq, f=ord):\n        self.n = len(seq)\n        self.base1, self.base2 = 1007, 2009\n        self.mod1, self.mod2 = 1000000007, 1000000009\n        self.f = f # set numerizing function\n\n        self.hash1, self.hash2 = [0]*(self.n+1), [0]*(self.n+1)\n        self.power1, self.power2 = [1]*(self.n+1), [1]*(self.n+1)\n\n        for i, e in enumerate(seq):\n            self.hash1[i+1] = (self.hash1[i] * self.base1 + self.f(e)) % self.mod1\n            self.hash2[i+1] = (self.hash2[i] * self.base2 + self.f(e)) % self.mod2\n            self.power1[i+1] = (self.power1[i] * self.base1) % self.mod1\n            self.power2[i+1] = (self.power2[i] * self.base2) % self.mod2\n\n    # get hash value of seq[left:right]\n    def get(self, l, r):\n        v1 = (self.hash1[r] - self.hash1[l] * self.power1[r-l]) % self.mod1\n        v2 = (self.hash2[r] - self.hash2[l] * self.power2[r-l]) % self.mod2\n        return v1, v2\n\n    # get lcp of seq[a:] and seq[b:]\n    def getLCP(self, a, b):\n        l = self.n - max(a, b) + 1\n        left, right = 0, l\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.get(a, a+mid) == self.get(b, b+mid): left = mid\n            else: right = mid\n        return left\n\nclass RollingHash:\n    def __init__(self, seq, f=ord):\n        self.n = len(seq)\n        self.base, self.mod = 1007, pow(2, 61) - 1\n        self.f = f # set numerizing function\n        self.hash, self.power = [0]*(self.n+1), [1]*(self.n+1)\n        for i, e in enumerate(seq):\n            self.hash[i+1] = (self.hash[i] * self.base + self.f(e)) % self.mod\n            self.power[i+1] = (self.power[i] * self.base) % self.mod\n\n    # get hash value of seq[left:right]\n    def get(self, l, r): return (self.hash[r] - self.hash[l] * self.power[r-l]) % self.mod\n\n    # get lcp of seq[a:] and seq[b:]\n    def getLCP(self, a, b):\n        l = self.n - max(a, b) + 1\n        left, right = 0, l\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.get(a, a+mid) == self.get(b, b+mid): left = mid\n            else: right = mid\n        return left\n\n\ndef main():\n    N = I()\n    S = SL()\n\n    rh = RollingHash(S)\n    ans = 0\n\n    def check(m):\n        d = defaultdict(lambda: -1)\n        for i in range(N-m+1):\n            v = rh.get(i, i+m)\n            if d[v] != -1:\n                if i >= d[v] + m:\n                    return True\n            else:\n                d[v] = i\n        return False\n\n    left, right = 0, N//2+1\n    while right - left > 1:\n        mid = (left + right) // 2\n        if check(mid): left = mid\n        else: right = mid\n\n    print(left)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\ndef main():\n    n = int(input())\n    s = list(input())\n    for i in range(n):\n        s[i] = ord(s[i]) - ord(\"a\")\n    s = np.array(s)\n    dp = np.zeros((n+1, n+1), dtype=np.int64)\n    tmp = np.arange(0, n+1)\n    t = np.zeros((n+1, n+1))\n    for i in range(n+1):\n        t[i] += tmp\n        tmp -= 1\n#    for i in range(n+1):\n#        print(t[i])\n    for i in range(n):\n        c = s[i]\n        equal = (c == s)\n#        print(equal)\n        dp[i+1][1:] += equal\n        dp[i+1][1:] += equal * dp[i][:-1]\n#    for i in range(n+1):\n#        print(dp[i])\n    dp = np.minimum(dp, t)\n#    for i in range(n+1):\n#        print(dp[i])\n    ans = 0\n    for i in range(1, n):\n        tmp = dp[i][i+1:]\n        tmp = tmp[ans<tmp]\n        if 0 < len(tmp):\n            ans = max(ans, max(tmp))\n    print((int(ans)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def ok(k):\n    # \u9577\u3055k\u306e\u9023\u7d9a\u90e8\u5206\u5217\u3067\u91cd\u306a\u3089\u305a\u306b2\u56de\u4ee5\u4e0a\u73fe\u308c\u308b\u3082\u306e\u304c\u3042\u308b\n    D = {}\n    for i in range(n-k+1):\n        s = S[i:i+k]\n        try:\n            if D[s]+k <= i:\n                return True\n        except:\n            D[s] = i\n    return False\n\n\nn = int(input())\nS = input()\n# \u4e8c\u5206\u63a2\u7d22\u3067True\u306b\u306a\u308b\u6700\u5927\u306ek\u3092\u6c42\u3081\u308b\nl, r = 0, n+1\nwhile r-l > 1:\n    c = (l+r)//2\n    if ok(c):\n        l = c\n    else:\n        r = c\nprint(l)\n", "N=int(input())\nS=input()\n\nlong=0\nfor i in range(N-1):\n  for j in range(i+long+1,N):\n    if not (S[i:j] in S[j:]):\n      break\n  long=max(long,j-i-1)\nprint(long)", "n = int(input())\ns = input()\n\ndef search(x):\n    d = set()\n    for i in range(n-2*x+1):\n        d.add(s[i:i+x])\n        if s[i+x:i+2*x] in d:\n            return True\n    return False\n\nl = 0\nr = n//2+1\nwhile r > l+1:\n    mid = (r+l)//2\n    if search(mid):\n        l = mid\n    else:\n        r = mid\nprint(l)", "def check(x, N, S):\n    candidate = set()\n    for i in range(N - 2*x + 1):\n        candidate.add(S[i:i+x])\n        if S[i+x:i+2*x] in candidate:\n            return True\n    return False\n\ndef main():\n    n = int(input())\n    s = input().rstrip()\n    l = 0\n    r = n\n    while l < r:\n        mid = (l+r+1) // 2\n        if check(mid, n, s):\n            l = mid\n        else:\n            r = mid-1\n    print((l+r+1)//2)\n\ndef __starting_point():\n    main()\n__starting_point()", "N=int(input())\nS=input()\nans = 0\nj = 0\nfor i in range(N):\n  while j < N and S[i:j] in S[j:]:\n    j += 1\n  ans = max(ans,j-i-1)\nprint(ans)\n\n", "N = int(input())\nS = input()\n\ndef f(m):\n    se = set()\n    arr = [None]*N\n    for i in range(0,N-m+1):\n        if i >= m:\n            se.add(arr[i-m])\n        arr[i] = hash(S[i:i+m])\n        if arr[i] in se:\n            return True\n    return False\n\nl = 0\nr = N//2+1\nwhile (r-l)>1:\n    mid = (r+l)//2\n    if f(mid):\n        l = mid\n    else:\n        r = mid\nprint(l)", "from collections import defaultdict\n\n\ndef read():\n    N = int(input().strip())\n    S = input().strip()\n    return N, S\n\n\ndef solve(N, S):\n    low = 0\n    high = (N >> 1) + 1\n    while high - low > 1:\n        mid = (high + low) >> 1\n        is_match = False\n        m = N-mid+1\n        d = defaultdict(list)\n        for i in range(0, m):\n            d[S[i:i+mid]].append(i)\n        for v in d.values():\n            if v[-1] - v[0] >= mid:\n                is_match = True\n                break\n        if is_match:\n            low = mid\n        else:\n            high = mid\n    return low\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print(\"%s\" % str(outputs))\n__starting_point()", "n=int(input())\ns=input()\nr=n//2\nl=-1\nwhile r-l>1:\n  mid=(r+l)//2\n  d=dict()\n  ok=False\n  for i in range(n-mid):\n    ss=s[i:i+mid+1]\n    if ss not in d:\n      d[ss]=i\n    else:\n      if d[ss]+mid<i:\n        ok=True\n  if ok:\n    l=mid\n  else:\n    r=mid\nprint(r)", "#!usr/bin/env python3\nfrom collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom heapq import heappush, heappop, heapify\n\nimport itertools\nimport math, fractions\nimport sys, copy\n\ndef L(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline().rstrip())\ndef SL(): return list(sys.stdin.readline().rstrip())\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI1(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return [list(x) for x in sys.stdin.readline().split()]\ndef R(n): return [sys.stdin.readline().strip() for _ in range(n)]\ndef LR(n): return [L() for _ in range(n)]\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef LIR1(n): return [LI1() for _ in range(n)]\ndef SR(n): return [SL() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\n\ndef perm(n, r): return math.factorial(n) // math.factorial(r)\ndef comb(n, r): return math.factorial(n) // (math.factorial(r) * math.factorial(n-r))\n\ndef make_list(n, *args, default=0): return [make_list(*args, default=default) for _ in range(n)] if len(args) > 0 else [default for _ in range(n)]\n\ndire = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ndire8 = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]\nalphabets = \"abcdefghijklmnopqrstuvwxyz\"\nALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nMOD = 1000000007\nINF = float(\"inf\")\n\nsys.setrecursionlimit(1000000)\n\nclass RollingHash:\n    def __init__(self, seq, f=ord):\n        self.n = len(seq)\n        self.base1, self.base2 = 1007, 2009\n        self.mod1, self.mod2 = 1000000007, 1000000009\n        self.f = f # set numerizing function\n\n        self.hash1, self.hash2 = [0]*(self.n+1), [0]*(self.n+1)\n        self.power1, self.power2 = [1]*(self.n+1), [1]*(self.n+1)\n\n        for i, e in enumerate(seq):\n            self.hash1[i+1] = (self.hash1[i] * self.base1 + self.f(e)) % self.mod1\n            self.hash2[i+1] = (self.hash2[i] * self.base2 + self.f(e)) % self.mod2\n            self.power1[i+1] = (self.power1[i] * self.base1) % self.mod1\n            self.power2[i+1] = (self.power2[i] * self.base2) % self.mod2\n\n    # get hash value of seq[left:right]\n    def get(self, l, r):\n        v1 = (self.hash1[r] - self.hash1[l] * self.power1[r-l]) % self.mod1\n        v2 = (self.hash2[r] - self.hash2[l] * self.power2[r-l]) % self.mod2\n        return v1, v2\n\n    # get lcp of seq[a:] and seq[b:]\n    def getLCP(self, a, b):\n        l = self.n - max(a, b) + 1\n        left, right = 0, l\n        while right - left > 1:\n            mid = (left + right) // 2\n            if self.get(a, a+mid) == self.get(b, b+mid): left = mid\n            else: right = mid\n        return left\n\n\ndef main():\n    N = I()\n    S = SL()\n\n    rh = RollingHash(S)\n    ans = 0\n\n    def check(m):\n        d = defaultdict(lambda: -1)\n        for i in range(N-m+1):\n            v = rh.get(i, i+m)\n            if d[v] != -1:\n                if i >= d[v] + m:\n                    return True\n            else:\n                d[v] = i\n        return False\n\n    left, right = 0, N//2+1\n    while right - left > 1:\n        mid = (left + right) // 2\n        if check(mid): left = mid\n        else: right = mid\n\n    print(left)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\nN = int(input())\nS = np.array(list(input()))\n\n\ndef match_length(s1, s2, m):\n    x = np.zeros(len(s1) + 2, dtype=bool)\n    x[1:-1] = (s1 == s2)\n\n    l = max(np.diff(np.nonzero(x == 0)[0]) - 1)\n    return min(m, l)\n\n\nans = 0\nfor i in range(1, N - 1):\n    ans = max(ans, match_length(S[i:], S[:-i], i))\nprint(ans)\n", "import numpy as np\n\nn = int(input())\ns = np.array(list(input()))\n\nl = s.size\n\ndp = np.zeros(l, dtype=np.int16)\nans = 0\nfor i, e in enumerate(s, 1):\n    dp_prev = dp.copy()\n    mx = np.arange(1, l + 1) - i\n    idx = np.hstack([np.full(i, False), s[i:] == e]).astype(np.bool)\n    idx_prev = np.roll(idx, -1)\n    dp = np.zeros(l, dtype=np.int16)\n    dp[idx] = np.minimum(dp_prev[idx_prev] + 1, mx[idx])\n    ans = max(ans, dp.max())\n\nprint(ans)\n", "from collections import defaultdict\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = self.HASH[r] - (self.HASH[l] * self.POWER[r - l] % self.MOD)\n        if _hash < 0:\n            _hash += self.MOD\n        return _hash\n\n# \u6c4e\u7528\u7684\u306a\u4e8c\u5206\u63a2\u7d22\u306e\u30c6\u30f3\u30d7\u30ec\n# check_func(x) = true \u3068\u306a\u308bx\u306e\u6700\u5c0f\u5024\u3092\u63a2\u7d22\u3059\u308b\n# left : check_func(x) = false\u3068\u306a\u308bx\n# right: check_func(x) = true \u3068\u306a\u308bx\n# search_max: check_func(x) = true \u3068\u306a\u308bx\u306e\"\u6700\u5927\u5024\"\u3092\u63a2\u7d22\u3059\u308b\u5834\u5408\u306fTrue\n# check_func: answer <= x \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\ndef binary_search(left: int, right: int, check_func, search_max:bool=False):\n    # ok \u3068 ng \u306e\u3069\u3061\u3089\u304c\u5927\u304d\u3044\u304b\u308f\u304b\u3089\u306a\u3044\u3053\u3068\u3092\u8003\u616e\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n    \n        if check_func(mid) ^ search_max:\n            right = mid\n            # print(left, right, mid, 't')\n        else:\n            left = mid\n            # print(left, right, mid, 'f')\n\n    return left if search_max else right\n\ndef main():\n    N = int(input())\n    S = input()\n\n    rs = RollingHash(S, MOD=998244353, BASE=37)\n\n    # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    def isOK(L):\n        if L == 0:\n            return True\n        hash_to_left = defaultdict(list)\n        for i in range(N - L + 1):\n            _hash = rs.hash(i, i + L)\n            # hash\u304c\u885d\u7a81\u3057\u3066\u3082\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\n            # \u885d\u7a81\u3057\u305f\u5834\u5408\u306f\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u8abf\u3079\u3001\u304b\u3064\n            # \u6587\u5b57\u5217\u540c\u58eb\u304cS\u306e\u4e2d\u3067\u91cd\u306a\u308b\u3088\u3046\u306a\u7bc4\u56f2\u306b\u306a\u3044\u5834\u5408\u306fOK\u3068\u3059\u308b\n            for j in hash_to_left[_hash]:\n                if j+L <= i and S[i:i+L] == S[j:j+L]:\n                    return True\n            hash_to_left[_hash].append(i)\n\n        return False\n    # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from typing import List\n\n\nclass RollingHash:\n    __slots__ = [\"source\", \"length\", \"base\", \"mod\", \"hash\", \"power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self.source = source\n        self.length = len(source)\n        self.base = base\n        self.mod = mod\n        self.hash = self._get_hash_from_zero()\n        self.power = self._get_base_pow()\n\n    def _get_hash_from_zero(self) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        cur, hash_from_zero = 0, [0]\n        for e in self.source:\n            cur = (cur * self.base + ord(e)) % self.mod\n            hash_from_zero.append(cur)\n        return hash_from_zero\n\n    def _get_base_pow(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        cur, power = 1, [1]\n        for i in range(self.length):\n            cur *= self.base % self.mod\n            power.append(cur)\n        return power\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Compute hash of interval [left, right).\"\"\"\n        return (\n            self.hash[right] - self.hash[left] * self.power[right - left]\n        ) % self.mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg, memo = 0, set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = 1\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "n = int(input())\ns = input()\n \nmax_len = 0\nj = 0\n \nfor i in range(n):\n    while j < n and s[i:j] in s[j:]:\n        j += 1\n    max_len = max(max_len,j-i-1)\n \nprint(max_len)", "def ok(l):\n    # \u9577\u3055l\u306e\u9023\u7d9a\u90e8\u5206\u5217\u3067\u91cd\u306a\u3089\u305a\u306b2\u56de\u4ee5\u4e0a\u73fe\u308c\u308b\u3082\u306e\u304c\u3042\u308b\n    D = {}\n    for i in range(n-l+1):\n        h = hash(S[i:i+l])\n        try:\n            if D[h] + l <= i:\n                return True\n        except:\n            D[h] = i\n    return False\n\n\nn = int(input())\nS = input()\n# \u4e8c\u5206\u63a2\u7d22\u3067True\u306b\u306a\u308b\u6700\u5927\u306ek\u3092\u6c42\u3081\u308b\nl, r = 0, n+1\nwhile r-l > 1:\n    c = (l+r)//2\n    if ok(c):\n        l = c\n    else:\n        r = c\nprint(l)\n", "n = int(input())\ns = input()\n\nmax_len = 0\nj = 0\n\nfor i in range(n):\n    while j < n and s[i:j] in s[j:]:\n        j += 1\n    max_len = max(max_len,j-i-1)\n\nprint(max_len)", "# ABC141E - Who Says a Pun?\ndef resolve():\n    N = int(input())\n    S = input().rstrip()\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(hash(S[i : i + mid]))\n            if hash(S[i + mid : i + 2 * mid]) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\nresolve()\n", "from typing import List\n\n\nclass RollingHash:\n    __slots__ = [\"_source\", \"_length\", \"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._source = source\n        self._length = len(source)\n        self._base = base\n        self._mod = mod\n        self._hash = self._get_hash_from_zero()\n        self._power = self._get_base_pow()\n\n    def _get_hash_from_zero(self) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        hash_from_zero = [0] * (self._length + 1)\n        cur = 0\n        for i, c in enumerate(self._source, 1):\n            cur = (cur * self._base + ord(c)) % self._mod\n            hash_from_zero[i] = cur\n        return hash_from_zero\n\n    def _get_base_pow(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        power = [0] * (self._length + 1)\n        power[0] = 1\n        cur = 1\n        for i in range(1, self._length + 1):\n            cur *= self._base % self._mod\n            power[i] = cur\n        return power\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Compute hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "import random\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 998244353, BASE: int = 37):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = (self.HASH[r] - self.HASH[l] * self.POWER[r - l]) % self.MOD\n        return _hash\n\n# \u6c4e\u7528\u7684\u306a\u4e8c\u5206\u63a2\u7d22\u306e\u30c6\u30f3\u30d7\u30ec\n# check_func(x) = true \u3068\u306a\u308bx\u306e\u6700\u5c0f\u5024\u3092\u63a2\u7d22\u3059\u308b\n# left : check_func(x) = false\u3068\u306a\u308bx\n# right: check_func(x) = true \u3068\u306a\u308bx\n# search_max: check_func(x) = true \u3068\u306a\u308bx\u306e\"\u6700\u5927\u5024\"\u3092\u63a2\u7d22\u3059\u308b\u5834\u5408\u306fTrue\n# check_func: search_max = False \u306e\u5834\u5408\u3001answer <= x \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\n#             search_max = True  \u306e\u5834\u5408\u3001x <= answer \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\ndef binary_search(left: int, right: int, check_func, search_max:bool=False):\n    # ok \u3068 ng \u306e\u3069\u3061\u3089\u304c\u5927\u304d\u3044\u304b\u308f\u304b\u3089\u306a\u3044\u3053\u3068\u3092\u8003\u616e\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n    \n        if check_func(mid) ^ search_max:\n            right = mid\n        else:\n            left = mid\n\n    return left if search_max else right\n\ndef main():\n    N = int(input())\n    S = input()\n    MOD = 10 ** 18 + 3\n    # BASE\u306fMOD\u672a\u6e80\u30671\u3067\u306a\u3044\u5947\u6570\u3068\u3059\u308b\n    BASE = random.randint(2, MOD // 2 - 1) * 2 + 1\n    rs = RollingHash(S, MOD=MOD, BASE=BASE)\n\n    D = [0] * N\n    # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    def isOK(L):\n        if L == 0:\n            return True\n        \n        for i in range(min(L, N - 2 * L + 1)):\n            D[i] = rs.hash(i, i + L)\n        hashes = set()\n        for i in range(L, N - L + 1):\n            # \u81ea\u5206\u3088\u308a\u958b\u59cb\u70b9\u304cL\u4ee5\u4e0a\u524d\u306e\u6587\u5b57\u5217\u306e\u30cf\u30c3\u30b7\u30e5\u3092\u691c\u7d22\u5bfe\u8c61\u306b\u8ffd\u52a0\n            hashes.add(D[i - L])\n            D[i] = v = rs.hash(i, i + L)\n            # \u30cf\u30c3\u30b7\u30e5\u304c\u885d\u7a81\u3057\u305f\u3089\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u6587\u5b57\u5217\u304c\u5b58\u5728\u3059\u308b\u3053\u3068\u306b\u306a\u308b\n            if v in hashes:\n                return True\n        return False\n\n    # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "def solve():\n    N = int(input())\n    S = input()\n\n    def rolling_hash(s, mod, base = 37):\n        l = len(s)\n        h = [0]*(l + 1)\n        v = 0\n        for i in range(l):\n            h[i+1] = v = (v * base + ord(s[i])) % mod\n        pw = [1]*(l + 1)\n        v = 1\n        for i in range(l):\n            pw[i+1] = v = v * base % mod\n        return h, pw\n\n    def chk(S, mod, D = [0]*N):\n        h, pw = rolling_hash(S, mod)\n        left = 0; right = N//2+1\n        while left+1 < right:\n            l = mid = (left + right) >> 1\n            p = pw[l]\n            for i in range(min(l, N-2*l+1)):\n                D[i] = (h[l+i] - h[i]*p) % mod\n            s = set()\n            ok = 0\n            for i in range(l, N-l+1):\n                s.add(D[i-l])\n                D[i] = v = (h[l+i] - h[i]*p) % mod\n                if v in s:\n                    ok = 1\n                    break\n            if ok:\n                left = mid\n            else:\n                right = mid\n        return left\n\n    print((chk(S, 10**9 + 9)))\nsolve()\n", "n = int(input())\ns = input()\nj = 1\nresult = [0]\nend = n//2 + 1\nfor i in range(n):\n    while (j < n-1) and (s[i:j] in s[:i]+\"0\"+s[j:]):\n        j += 1\n    result.append(j-i-1)\nprint(max(result))", "class RollingHash():\n    def __init__(self,s):\n        self.n=n=len(s)\n        self.b=b=129\n        self.M=M=2**61-1\n        x,y=1,0\n        self.f=f=[x]*(n+1)\n        self.h=h=[y]*(n+1)\n        for i,c in enumerate(s.encode()):\n            f[i+1]=x=x*b%M\n            h[i+1]=y=(y*b+c)%M\n    def get(self,l,r):\n        return(self.h[r]-self.h[l]*self.f[r-l])%self.M\ndef check(x):\n    d={}\n    for i in range(0,n-x+1):\n        k=s.get(i,i+x)\n        if k in d:\n            if d[k]+x<=i:\n                return True\n        else:\n            d[k]=i\n    return False\nn=int(input())\ns=RollingHash(input())\nok,ng=0,n\nwhile ng-ok>1:\n    mid=ok+ng>>1\n    if check(mid):\n        ok=mid\n    else:\n        ng=mid\nprint(ok)", "import sys\nsys.setrecursionlimit(10**9)\nfrom collections import defaultdict\nN = int(input())\nS = input()\nif N==2:\n  if S[1] == S[0]:\n    print((1))\n  else:\n    print((0))\n  return\ndef hantei(mid):\n  flag = False\n  string = S[:mid]\n  dic = defaultdict(int)\n  dic[string] = -1\n  for k in range(mid, N):\n    string += S[k]\n    string = string[1:]\n    if dic[string] < 0:\n      if k -mid+2+ dic[string] >= mid:\n        flag = True\n        break\n    else:\n      dic[string] = -k+mid-2\n  if flag:\n    return True\n  else: \n    return False\nok = N//2+1 #False\nng = 0 #True\nwhile ok - ng > 1:\n  mid = (ok + ng) // 2\n  if hantei(mid):\n    ng = mid\n  else:\n    ok = mid\nif hantei(mid):\n  print((min(mid, N//2)))\nelse:\n  print((min(ng, N//2)))\n", "n = int(input())\ns = input() #sys.stdin.readline\u306f\u6700\u5f8c\u304c\u6539\u884c\n\nright=0\nans = 0\nfor left in range(n):\n    while right<n:\n        word = s[left:right+1]\n        if word in s[right+1:]:\n            ans = max(ans, len(word))\n        else:\n            break\n        right+=1\n\nprint(ans)\n", "# -*- coding: utf-8 -*-\n# E\n# \u6587\u5b57\u5217\u6bd4\u8f03\u3092\u30ed\u30fc\u30ea\u30f3\u30b0\u30cf\u30c3\u30b7\u30e5\u3092\u7528\u3044\u308b\u3068\u9ad8\u901f\n\nimport sys\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nimport math\nimport bisect\ninput = sys.stdin.readline\n\n# \u518d\u8d77\u56de\u6570\u4e0a\u9650\u5909\u66f4\n# sys.setrecursionlimit(1000000)\n\nn = int(input())\ns = input()[:-1]\n# s = list(map(ord, list(input()[:-1])))\n# print(s)\n\nlb = 0\nub = n//2 + 1\n\n\ndef check(len):\n    for l1 in range(n-len):\n        for l2 in range(l1+len, n-len+1):\n            if s[l1:l1+len] == s[l2:l2+len]:\n                return True\n    return False\n\n\nmod = 10**9+7\nbase = 1234\npower = [1]*(n+1)\nfor i in range(1, n+1):\n    power[i] = power[i-1]*base%mod\n\n\ndef check2(m):\n    res = 0\n    for i in range(m):\n        res+=s[i]*power[m-i-1]\n        res%=mod\n\n    dic = {res: 0}\n    # defaultdict\u304c\u65e9\u3044\n    # dic = defaultdict(int)\n    # dic[res] = 0\n\n    for i in range(n-m):\n        res = ((res-s[i]*power[m-1])*base\n                             +s[i+m])%mod\n        if res in dic.keys():\n            index = dic[res]\n            if index +m<=i+1:\n                return True\n        else:\n            dic[res] = i+1\n    return False\n\n\ndef check3(m):\n    dic = {}\n    for i in range(n-m+1):\n        s_ = s[i:i+m]\n        if s_ in dic.keys():\n            if dic[s_]+m<=i:\n                return True\n        else:\n            dic[s_] = i\n    return False\n\n\nwhile ub > lb+1:\n    x = (lb + ub)//2\n    if check3(x):\n        lb = x\n    else:\n        ub = x\n    # print(lb, ub)\n\n\n'''\nprint(3, check(3))\nprint(4, check(4))\nprint(5, check(5))\n'''\n\nprint(lb)", "class RollingHash():\n    def __init__(self,s):\n        self.n=n=len(s)\n        self.b=b=129\n        self.M=M=2**61-1\n        x,y=1,0\n        self.f=f=[x]*(n+1)\n        self.h=h=[y]*(n+1)\n        for i,c in enumerate(s.encode()):\n            f[i+1]=x=x*b%M\n            h[i+1]=y=(y*b+c)%M\n    def get(self,l,r):\n        return(self.h[r]-self.h[l]*self.f[r-l])%self.M\ndef main():\n    n=int(input())\n    s=RollingHash(input())\n    ok,ng=0,n\n    while ng-ok>1:\n        mid=ok+ng>>1\n        d={}\n        for i in range(0,n-mid+1):\n            k=s.get(i,i+mid)\n            if k in d:\n                if d[k]+mid<=i:\n                    ok=mid\n                    break\n            else:\n                d[k]=i\n        else:\n            ng=mid\n    print(ok)\nmain()", "n = int(input())\ns = input()\nj = 1\nresult = []\nfor i in range(n):\n    while (j < n-1) and (s[i:j] in s[:i]+\"0\"+s[j:]):\n        j += 1\n    result.append(j-i-1)\nprint(max(result))", "n = int(input())\ns = input()\n\nMOD = 10 ** 18 + 7\nA = 123456\n\ndef ok(l):\n    rolling_hash = 0\n    strings = {}\n    for i in range(n):\n        rolling_hash *= A\n        rolling_hash += ord(s[i])\n        if i - l >= 0: rolling_hash -= ord(s[i-l]) * pow(A, l, MOD)\n        rolling_hash %= MOD\n        if i < l-1:continue\n        if rolling_hash not in strings:\n            strings[rolling_hash] = []\n        strings[rolling_hash].append(i)\n\n    for string in strings:\n        if strings[string][-1] - strings[string][0] >= l:\n            return True\n    return False\n    \n\nbottom, top = 0, n\n\nwhile top - bottom > 1:\n    mid = (top + bottom) // 2\n    if ok(mid): bottom = mid\n    else: top = mid\n\nprint(bottom)", "#141_E\nn = int(input())\ns = input()\n\nx = 0\nfor i in range(n):\n    s_ = s[:i+1]\n    if s_[i - x:] in s_[: i - x]:\n        x += 1\n\nprint(x)", "import random\nfrom collections import defaultdict\n\n\ndef atoi(s):\n    return ord(s) - ord(\"a\") + 1\n\n\nN = int(input())\nS = input()\n\nmod = (1 << 61) - 1\nb = random.randint(10000, mod - 1)\n\n\nl = 0\nr = (N + 1) // 2 + 1\nwhile r - l > 1:\n    d = (r + l) // 2\n    memo = defaultdict(int)\n    isok = False\n    h = 0\n    t = pow(b, d, mod)\n    for i in range(d):\n        h = (h * b + atoi(S[i])) % mod\n    memo[h] = 1\n    for i in range(1, N - d + 1):\n        h = (h*b + atoi(S[i+d-1]) - t * atoi(S[i-1])) % mod\n        if not memo[h]:\n            memo[h] = i + 1\n        elif memo[h] and i - memo[h] + 1 >= d:\n            isok = True\n    if isok:\n        l = d\n    else:\n        r = d\n\nprint(l)", "import sys\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef is_ok(arg, S):\n    # \u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\uff1f\u554f\u984c\u3054\u3068\u306b\u5b9a\u7fa9\n    dic = {}\n    ans = False\n    for i in range(len(S)-arg+1):\n        c = S[i:i+arg]\n        if c in dic:\n            if i-dic[c] >= arg:\n                ans = True\n                break\n        else:\n            dic[c] = i\n    return ans\n\n\ndef meguru_bisect(ng, ok, S):\n    '''\n    \u521d\u671f\u5024\u306eng,ok\u3092\u53d7\u3051\u53d6\u308a,is_ok\u3092\u6e80\u305f\u3059\u6700\u5c0f(\u6700\u5927)\u306eok\u3092\u8fd4\u3059\n    \u307e\u305ais_ok\u3092\u5b9a\u7fa9\u3059\u3079\u3057\n    ng ok \u306f  \u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1 \u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n    \u6700\u5927\u6700\u5c0f\u304c\u9006\u306e\u5834\u5408\u306f\u3088\u3057\u306a\u306b\u3072\u3063\u304f\u308a\u8fd4\u3059\n    '''\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid, S):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n\ndef main():\n    N = int(input())\n    S = input()\n    print((meguru_bisect((N//2)+1, -1, S)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# 32bit\u306eMod\u4e00\u3064\u3067RollingHash\u3092\u884c\u3063\u305f\u5834\u5408\u3001\n# 10**5\u500b\u7a0b\u5ea6\u306eHash\u3092\u751f\u6210\u3059\u308b\u3060\u3051\u3067\u3082\n# \u534a\u5206\u4ee5\u4e0a\u306e\u78ba\u7387\u3067\u3069\u3053\u304b\u306eHash\u304c\u885d\u7a81\u3057\u3066\u3044\u308b\u3053\u3068\u304c\u5206\u304b\u308a\u307e\u3059\n\n\n# \u5c0f\u6587\u5b57\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u306e\u6642\u306ebese\nbase = 27  # alphabet\n\n\ndef getnum(x):\n    return ord(x) - ord(\"a\") + 1\n\n\n# rolling hash\u5b9f\u88c5\n\n# \u5fc5\u8981\u306a\u5b9a\u6570\n# mod = 1<<61-1\u3068\u3057\u305f\u3068\u304d\u306e\u9ad8\u901f\u4f59\u308a\u8a08\u7b97\nm30 = (1 << 30) - 1\nm31 = (1 << 31) - 1\nm61 = (1 << 61) - 1\nmod = m61\npositive_delta = m61 ** 4\n\n# \u9ad8\u901f\u5316\u3055\u308c\u305f\u8a08\u7b97\ndef mul(a, b):\n    au = a >> 31\n    ad = a & m31  # \u4f59\u308a\u3092\u53d6\u308b\u3053\u3068\u304c&\u6f14\u7b97\u3067\u3067\u304d\u308b\n    bu = b >> 31\n    bd = b & m31\n    mid = ad * bu + au * bd\n    midu = mid >> 30\n    midd = mid & m30\n    return calcmod(au * bu * 2 + midu + (midd << 31) + ad * bd)\n\n\ndef calcmod(a):\n    au = a >> 61\n    ad = a & m61\n    res = au + ad\n    if res >= m61:\n        res -= m61\n    return res\n\n\n# s:string\ndef rollinghash(s):\n    num = len(s)\n    res = [0] * (num + 1)\n    pow_base = [1] * (num + 1)\n    for i in range(num):\n        res[i + 1] = calcmod(mul(res[i], base) + getnum(s[i]))\n        pow_base[i + 1] = calcmod(mul(pow_base[i], base))\n    return res, pow_base\n\n\ndef search(left, right, rh):\n    return calcmod(rh[right] - mul(rh[left], pow_base[right - left]) + positive_delta)\n\n\nn = int(input())\ns = input()\nrh, pow_base = rollinghash(s)\n\nng = n\nok = 0\n\n\ndef hantei(x, rh):\n    kumi = {}\n    for i in range(n - x + 1):\n        temp = search(i, i + x, rh)\n        if temp in kumi:\n            pre_idx = kumi[temp]\n            if i - pre_idx >= x:\n                # print(\"pair\", i, pre_idx, \"delta\", x)\n                return True\n        else:\n            kumi[temp] = i\n    # print(x, kumi)\n    return False\n\n\nwhile ng - ok > 1:\n    mid = (ng + ok) // 2\n    if hantei(mid, rh):\n        ok = mid\n    else:\n        ng = mid\n    # print(ok, ng)\n\nprint(ok)\n", "def solve():\n    N = int(input())\n    Ss = input().rstrip()\n\n    def isOK(L):\n        setCand = set()\n        RHs = []\n        for i in range(N-L+1):\n            RH = hash(Ss[i:i+L])\n            RHs.append(RH)\n            if i-L >= 0:\n                setCand.add(RHs[i-L])\n            if RH in setCand:\n                return True\n        return False\n\n    ng, ok = N//2+1, 0\n    while abs(ok-ng) > 1:\n        mid = (ng+ok) // 2\n        if isOK(mid):\n            ok = mid\n        else:\n            ng = mid\n\n    print(ok)\n\n\nsolve()\n", "class RollingHash():\n    def __init__(self, s, base, mod):\n        self.mod = mod\n        self.pw = pw = [1]*(len(s)+1)\n\n        l = len(s)\n        self.h = h = [0]*(l+1)\n\n        v = 0\n        for i in range(l):\n            h[i+1] = v = (v * base + ord(s[i])) % mod\n        v = 1\n        for i in range(l):\n            pw[i+1] = v = v * base % mod\n    def get(self, l, r): #S[l:r]index\u3067\u3044\u3046l\u6587\u5b57\u76ee\u304b\u3089r-l\u6587\u5b57\u76ee\u3002r-l\u6587\u5b57\u3002\n        return (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod\n\n    def check(self, d):\n        ma = {}\n        for i in range(N-d+1): #0\u304b\u3089N-d\u307e\u3067\n            p = self.get(i,i+d)\n            if p in ma:\n                if i - ma[p] >= d: #d\u6587\u5b57\u4ee5\u4e0a\u96e2\u308c\u3066\u3044\u308b\u304b\n                  return True\n            else:\n                ma[p] = i\n        return False\n            \n              \nN =int(input())\nS = str(input())\n\nbase1 = 1007\nmod1 = 10**9+7\n\nRH = RollingHash(S,base1,mod1)\n\nleft = 0\nright = N//2+1\nwhile right - left >1:\n  mid = (left+right)//2\n  if RH.check(mid): #\u3053\u3061\u3089\u304cok\u306e\u65b9\n    left = mid\n  else:\n    right = mid\n\nprint(left)      \n", "from collections import defaultdict\n\nclass RollingHash(object):\n    def __init__(self, S: str, MOD: int = 10 ** 9 + 7, BASE: int = 10 ** 5 + 7):\n        self.S = S\n        self.N = N = len(S)\n        self.MOD = MOD\n        self.BASE = BASE\n        self.S_arr = [ord(x) for x in S]\n\n        self.POWER = [1] * (N + 1)\n        self.HASH  = [0] * (N + 1)\n        p, h = 1, 0\n        for i in range(N):\n            self.POWER[i + 1] = p = (p * BASE) % MOD\n            self.HASH[i + 1] = h = (h * BASE + self.S_arr[i]) % MOD\n\n    def hash(self, l: int, r: int):\n        # get hash for S[l:r]\n        _hash = self.HASH[r] - (self.HASH[l] * self.POWER[r - l] % self.MOD)\n        if _hash < 0:\n            _hash += self.MOD\n        return _hash\n\n# \u6c4e\u7528\u7684\u306a\u4e8c\u5206\u63a2\u7d22\u306e\u30c6\u30f3\u30d7\u30ec\n# check_func(x) = true \u3068\u306a\u308bx\u306e\u6700\u5c0f\u5024\u3092\u63a2\u7d22\u3059\u308b\n# left : check_func(x) = false\u3068\u306a\u308bx\n# right: check_func(x) = true \u3068\u306a\u308bx\n# search_max: check_func(x) = true \u3068\u306a\u308bx\u306e\"\u6700\u5927\u5024\"\u3092\u63a2\u7d22\u3059\u308b\u5834\u5408\u306fTrue\n# check_func: answer <= x \u3067\u3042\u308c\u3070check_func(x) = true \u3068\u306a\u308b\u3088\u3046\u306a\u95a2\u6570\ndef binary_search(left: int, right: int, check_func, search_max:bool=False):\n    # ok \u3068 ng \u306e\u3069\u3061\u3089\u304c\u5927\u304d\u3044\u304b\u308f\u304b\u3089\u306a\u3044\u3053\u3068\u3092\u8003\u616e\n    while abs(right - left) > 1:\n        mid = (left + right) // 2\n    \n        if check_func(mid) ^ search_max:\n            right = mid\n            # print(left, right, mid, 't')\n        else:\n            left = mid\n            # print(left, right, mid, 'f')\n\n    return left if search_max else right\n\ndef main():\n    N = int(input())\n    S = input()\n\n    rs = RollingHash(S)\n\n    # \u9577\u3055L\u306e\u90e8\u5206\u6587\u5b57\u5217\u540c\u58eb\u304c\u3001\u7bc4\u56f2\u3092\u91cd\u306d\u305a\u540c\u3058\u6587\u5b57\u5217\u3068\u306a\u308b\u5834\u5408\u306fTrue,\n    # \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306fFalse\u3092\u8fd4\u3059\u95a2\u6570\n    def isOK(L):\n        if L == 0:\n            return True\n        hash_to_left = defaultdict(list)\n        for i in range(N - L + 1):\n            _hash = rs.hash(i, i + L)\n            # hash\u304c\u885d\u7a81\u3057\u3066\u3082\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u5206\u304b\u3089\u306a\u3044\u306e\u3067\u3001\n            # \u885d\u7a81\u3057\u305f\u5834\u5408\u306f\u6587\u5b57\u5217\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u8abf\u3079\u3001\u304b\u3064\n            # \u6587\u5b57\u5217\u540c\u58eb\u304cS\u306e\u4e2d\u3067\u91cd\u306a\u308b\u3088\u3046\u306a\u7bc4\u56f2\u306b\u306a\u3044\u5834\u5408\u306fOK\u3068\u3059\u308b\n            for j in hash_to_left[_hash]:\n                if j+L <= i and S[i:i+L] == S[j:j+L]:\n                    return True\n            hash_to_left[_hash].append(i)\n\n        return False\n    # \u7bc4\u56f2\u304c\u91cd\u306a\u3089\u306a\u3044\u3053\u3068\u304c\u6761\u4ef6\u306b\u3042\u308b\u306e\u3067\u3001\u7b54\u3048\u306f\u6700\u5927\u3067\u3082N // 2\uff08\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u534a\u5206\uff09\u3068\u306a\u308b\u3002\n    # \u305f\u3060\u3057\u3001\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u4e0a\u3067\u7d76\u5bfe\u306b\u7b54\u3048\u3068\u306a\u3089\u306a\u3044\u7bc4\u56f2\u3092\u542b\u3081\u305f\u3044\u306e\u3067\u3001\n    # \u63a2\u7d22\u7bc4\u56f2\u3068\u3057\u3066\u306fN // 2 + 1 \u3068\u3001+1\u3057\u3066\u304a\u304f\u3002\n    ans = binary_search(0, N // 2 + 1, isOK, search_max=True)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import random\nfrom collections import defaultdict\nfrom itertools import accumulate\nimport sys\ninput = sys.stdin.readline\nn = int(input())\ns = input().rstrip()\nmod = (1<<61)-1\nbase = 1000+random.randint(0,100)\npower = [1]\nfor i in range(1,n):\n  power.append((power[-1]*base)%mod)\nhvalue = [0]\nfor i in range(n):\n  hvalue.append((hvalue[-1]+(ord(s[i])*power[i]))%mod)\ndef rollinghash(l,r):\n  return ((hvalue[r]-hvalue[l])*power[n-r])%mod\ndef pun(i):\n  dc = defaultdict(int)\n  if i>n//2:\n    return False\n  for j in range(n-i+1):\n    x = rollinghash(j,i+j)\n    if dc[x]:\n      rg =dc[x]\n      if rg<=j:\n        return True\n    else:\n      dc[x] = i+j\n  return False\nl=0\nr=n//2+1\nwhile l+1<r:\n  mi=(l+r)//2\n  if pun(mi):\n    l=mi\n  else:\n    r=mi\nprint(l)\n", "n,s=open(0);j=r=0\nfor i in range(int(n)):\n    while (j<int(n))and(s[i:j] in s[j:]):j+=1\n    r=max(r,j-i-1)\nprint(r)", "n=int(input())\ns=input()\nl=0\nr=n\nwhile r-l>1:\n  mid=(r+l)//2\n  dic={}\n  flag=False\n  for i in range(n-mid+1):\n    tmp=s[i:i+mid]\n    if tmp not in dic:\n      dic[tmp]=i+mid\n    else:\n      if dic[tmp]<=i:\n        flag=True\n        break\n  if flag:\n    l=mid\n  else:\n    r=mid\nprint(l)", "# -*- coding: utf-8 -*-\n# E\n# \u6587\u5b57\u5217\u6bd4\u8f03\u3092\u30ed\u30fc\u30ea\u30f3\u30b0\u30cf\u30c3\u30b7\u30e5\u3092\u7528\u3044\u308b\u3068\u9ad8\u901f\n# \u7528\u3044\u306a\u304f\u3066\u3082pypy\u4f7f\u308f\u306a\u304f\u3048\u308c\u3070\u901a\u308b\n\nimport sys\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nimport math\nimport bisect\ninput = sys.stdin.readline\n\n# \u518d\u8d77\u56de\u6570\u4e0a\u9650\u5909\u66f4\n# sys.setrecursionlimit(1000000)\n\nn = int(input())\ns = input()[:-1]\n# s = list(map(ord, list(input()[:-1])))\n# print(s)\n\nlb = 0\nub = n//2 + 1\n\n\ndef check(len):\n    # \u3053\u308c\u306fTLE\n    for l1 in range(n-len):\n        for l2 in range(l1+len, n-len+1):\n            if s[l1:l1+len] == s[l2:l2+len]:\n                return True\n    return False\n\n\ndef check3(m):\n    # \u3053\u308c\u306fOK(pypy\u3067\u306f\u306a\u304fpython3\uff09\n    dic = defaultdict(str)\n    # dic = {}\n    for i in range(n-m+1):\n        s_ = s[i:i+m]\n        if s_ in dic.keys():\n            if dic[s_]+m<=i:\n                return True\n        else:\n            dic[s_] = i\n    return False\n\n\nmod = 10**9+7\nbase = 1234\npower = [1]*(n+1)\nfor i in range(1, n+1):\n    power[i] = power[i-1]*base%mod\n\ndef check2(m):\n    res = 0\n    for i in range(m):\n        res+=s[i]*power[m-i-1]\n        res%=mod\n\n    dic = {res: 0}\n    # defaultdict\u304c\u65e9\u3044\n    # dic = defaultdict(int)\n    # dic[res] = 0\n\n    for i in range(n-m):\n        res = ((res-s[i]*power[m-1])*base\n                             +s[i+m])%mod\n        if res in dic.keys():\n            index = dic[res]\n            if index +m<=i+1:\n                return True\n        else:\n            dic[res] = i+1\n    return False\n\n\nwhile ub > lb+1:\n    x = (lb + ub)//2\n    if check3(x):\n        lb = x\n    else:\n        ub = x\n    # print(lb, ub)\n\n\n'''\nprint(3, check(3))\nprint(4, check(4))\nprint(5, check(5))\n'''\n\nprint(lb)", "from typing import List\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_length\", \"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._length = len(source)\n        self._base = base\n        self._mod = mod\n        self._hash = self._build_hash_from_zero(source)\n        self._power = self._build_base_power()\n\n    def _build_hash_from_zero(self, source: str) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        res = [0] * (self._length + 1)\n        for i, c in enumerate(source, 1):\n            res[i] = (res[i - 1] * self._base + ord(c)) % self._mod\n        return res\n\n    def _build_base_power(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        res = [1] * (self._length + 1)\n        for i in range(1, self._length + 1):\n            res[i] = res[i - 1] * self._base % self._mod\n        return res\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "n=int(input())\ns=list(map(ord,list(input())))\nfor i in range(n):s[i]-=97\n\nfrom random import randint\nroli_mod=1370757747362922367\nroli_r=randint(2,roli_mod-2)\nroli=[0]\nroli_rr=1\nfor i in range(n):\n  roli.append((roli[-1]+roli_rr*s[i])%roli_mod)\n  roli_rr*=roli_r\n  roli_rr%=roli_mod\ndef roli_hash(i,j):return ((roli[j+1]-roli[i]+roli_mod)%roli_mod)*pow(roli_r,roli_mod-1-i,roli_mod)%roli_mod\ndef roli_check(i1,j1,i2,j2):return roli_hash(i1,j1)==roli_hash(i2,j2)\n\nok=0\nng=(n+1)//2+1\nwhile ok+1!=ng:\n  i=(ok+ng)//2\n  d={}\n  f=False\n  for j in range(n-i+1):\n    h=roli_hash(j,j+i-1)\n    if h in d:\n      if j-d[h]>=i:\n        f=True\n        break\n    else:d[h]=j\n  if f:ok=i\n  else:ng=i\nprint(ok)", "N = int(input())\nS = input()\n\nMOD = 2 ** 61 - 1\nroot = 10000\n\nrhs = [0]\nfor h in map(ord, S):\n    rhs.append((root * rhs[-1] + h) % MOD)\n\npws = [1]\nfor i in range(N):\n    pws.append(pws[-1] * root % MOD)\n\nok = 0\nng = N\nwhile ng - ok > 1:\n    mid = (ok + ng) // 2\n    hashes = dict()\n    flg = False\n    for i in range(N - mid + 1):\n        hashofsub = (rhs[i+mid] - rhs[i] * pws[mid]) % MOD\n        if hashofsub in hashes:\n            if i >= hashes[hashofsub] + mid:\n                flg = True\n                break\n        else:\n            hashes[hashofsub] = i\n    \n    if flg:\n        ok = mid\n    else:\n        ng = mid\n\nprint(ok)", "from typing import List\n\n\nclass RollingHash:\n    \"\"\"Rolling Hash\"\"\"\n\n    __slots__ = [\"_base\", \"_mod\", \"_hash\", \"_power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self._base = base\n        self._mod = mod\n        self._hash = self._build_hash_from_zero(source)\n        self._power = self._build_base_power(len(source))\n\n    def _build_hash_from_zero(self, source: str) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        res = [0] * (len(source) + 1)\n        for i, c in enumerate(source, 1):\n            res[i] = (res[i - 1] * self._base + ord(c)) % self._mod\n        return res\n\n    def _build_base_power(self, length: int) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        res = [1] * (length + 1)\n        for i in range(1, length + 1):\n            res[i] = res[i - 1] * self._base % self._mod\n        return res\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Return hash of interval [left, right).\"\"\"\n        return (\n            self._hash[right] - self._hash[left] * self._power[right - left]\n        ) % self._mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "from typing import List\n\n\nclass RollingHash:\n    __slots__ = [\"source\", \"length\", \"base\", \"mod\", \"hash\", \"power\"]\n\n    def __init__(self, source: str, base: int = 1007, mod: int = 10 ** 9 + 7):\n        self.source = source\n        self.length = len(source)\n        self.base = base\n        self.mod = mod\n        self.hash = self._get_hash_from_zero()\n        self.power = self._get_base_pow()\n\n    def _get_hash_from_zero(self) -> List[int]:\n        \"\"\"Compute hash of interval [0, right).\"\"\"\n        hash_from_zero = [0] * (self.length + 1)\n        cur = 0\n        for i, c in enumerate(self.source, 1):\n            cur = (cur * self.base + ord(c)) % self.mod\n            hash_from_zero[i] = cur\n        return hash_from_zero\n\n    def _get_base_pow(self) -> List[int]:\n        \"\"\"Compute mod of power of base.\"\"\"\n        power = [1] * (self.length + 1)\n        cur = 1\n        for i in range(1, self.length + 1):\n            cur *= self.base % self.mod\n            power[i] = cur\n        return power\n\n    def get_hash(self, left: int, right: int):\n        \"\"\"Compute hash of interval [left, right).\"\"\"\n        return (\n            self.hash[right] - self.hash[left] * self.power[right - left]\n        ) % self.mod\n\n\ndef abc141_e():\n    # https://atcoder.jp/contests/abc141/tasks/abc141_e\n    N = int(input())\n    S = input().rstrip()\n    rh = RollingHash(S)\n    ok, ng = 0, N // 2 + 1\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        flg = False\n        memo = set()\n        for i in range(N - 2 * mid + 1):\n            memo.add(rh.get_hash(i, i + mid))\n            if rh.get_hash(i + mid, i + 2 * mid) in memo:\n                flg = True\n                break\n        if flg:\n            ok = mid  # next mid will be longer\n        else:\n            ng = mid  # next mid will be shorter\n    print(ok)  # max length of substrings appeared twice or more\n\n\ndef __starting_point():\n    abc141_e()\n\n__starting_point()", "I=input;n=int(I());s=I();j=r=0\nfor i in range(n):\n    while (j<n)and(s[i:j] in s[j:]):j+=1\n    r=max(r,j-i-1)\nprint(r)"]
["def main():\n  n = int(input())\n\n  if n % 2 != 0:\n    print(-1)\n    return\n\n  links = [[1, set()] for i in range(1, n+1)]\n  W = 0\n  L = 1\n\n  i = 0\n  while i < n-1:\n    i += 1\n    [a, b] = [int(x) for x in input().split()]\n    links[a-1][L].add(b-1)\n    links[b-1][L].add(a-1)\n\n  count = 0\n  sear = 0\n  cur = 0\n  while sear < n:\n    li = cur\n    l = links[li]\n    if len(l[L]) != 1:\n      if sear == cur:\n        sear += 1\n      cur = sear\n      continue\n    \n    mi = l[L].pop()\n    m = links[mi]\n    if l[W] % 2 == 0:\n      count += 1\n    else:\n      m[W] += 1\n\n    m[L].remove(li)\n    if mi < sear:\n      cur = mi\n    else:\n      sear += 1\n      cur = sear\n\n  print(count)\n\nmain()\n", "import collections;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn=int(input());\nif n>1:\n    u, v=getTransIntList(n-1);\n    for i in range(n-1):\n        u[i]-=1;\n        v[i]-=1;\ndef solve1(n, u, v):\n    nears = [set() for _ in range(n)];\n    for i in range(n-1):\n        v1, v2 = u[i], v[i];\n        nears[v1].add(v2);\n        nears[v2].add(v1);\n    prev=[0]*n;\n    nexts=[set() for _ in range(n)];\n    level=[0]*n;\n    vStart=0;\n    VertToCheck = collections.deque([vStart]);\n    AllVerts=collections.deque();\n    def defineNextPrev(vert):\n        for v1 in nears[vert]:\n            if v1!=prev[vert]:\n                nexts[vert].add(v1);\n                prev[v1]=vert;\n                level[v1]=level[vert]+1;\n                VertToCheck.append(v1);\n    while len(VertToCheck)>0:\n        currVert=VertToCheck.popleft();\n        AllVerts.append(currVert);\n        defineNextPrev(currVert);\n    cutFlag=[False]*n;\n    result=-1;\n    while len(AllVerts)>0:\n        vert=AllVerts.pop();\n        for v1 in nexts[vert]:\n            #print(cutFlag[vert], cutFlag[v1]);\n            cutFlag[vert]=cutFlag[v1] ==cutFlag[vert];\n            #print(cutFlag[vert])\n        if cutFlag[vert]:\n            result+=1;\n    return result;\nif n%2==1:\n    print(-1);\nelse:\n    print(solve1(n, u, v));", "#!/usr/bin/env python3\n\nfrom collections import deque\n\n# pre(u) -- to do first at u\n# proc(u, v) -- to do before switching from u (parent) to v (child)\n# post(u) -- to do before switching to parent of u\ndef nrDFS(u, tos, pre, proc, post):\n\tn = len(tos)\n\tvisited = [False for _ in range(n)]\n\tdef go_to(cur, nxt):\n\t\tproc(cur, nxt)\n\t\tvisited[nxt] = True\n\t\tpre(nxt)\n\t\treturn nxt, 0\n\tstack = deque()\n\tcur, i = go_to(u, u)\n\twhile True:\n\t\tif i < len(tos[cur]):\n\t\t\tif not visited[tos[cur][i]]:  # go to tos[cur][i]\n\t\t\t\tstack.append((cur, i))\n\t\t\t\tcur, i = go_to(cur, tos[cur][i])\n\t\t\telse:\n\t\t\t\ti += 1\n\t\t\t\tcontinue\n\t\telse:  # return to parent\n\t\t\tpost(cur)\n\t\t\tif len(stack) == 0:\n\t\t\t\tbreak\n\t\t\tcur, i = stack.pop()\n\t\t\ti += 1\n\t\t\tcontinue\n\n\n\nn = int(input().strip())\ntos = [[] for _ in range(n)]\nfor _ in range(n - 1):\n\t[u, v] = list(map(int, input().strip().split()))\n\ttos[u - 1].append(v - 1)\n\ttos[v - 1].append(u - 1)\n\nif n % 2 == 1:\n\tprint(-1)\n\treturn\n\ndef pre(u):\n\tpass\n\nparent = [0 for _ in range(n)]\ndef proc(u, v):\n\tparent[v] = u\n\ns = [0 for _ in range(n)]\ndef post(u):\n\ts[u] = 1 + sum(s[v] for v in tos[u] if v != parent[u])\n\t\t\n\nnrDFS(0, tos, pre, proc, post)\nprint(n - 1 - sum(si % 2 for si in s))\n\n", "def dfs(adj,i,parent):\n\trem = 0\n\ttree_size = 1\n\tfor item in adj[i]:\n\t\tif(item==parent):\n\t\t\tcontinue\n\t\tsubtree_size,t = dfs(adj,item,i)\n\t\trem += t\n\t\tif(subtree_size%2==0):\n\t\t\trem +=1\n\t\ttree_size += subtree_size\n\treturn (tree_size,rem)\n\ndef dfs_new(adj,n):\n\tstack = [(1,0)]\n\tsol = [None for i in range(n+1)]\n\twhile(not len(stack)==0):\n\t\ti,parent = stack[-1]\n\t\tflag = True\n\t\tfor item in adj[i]:\n\t\t\tif(item==parent):\n\t\t\t\tcontinue\n\t\t\tif(sol[item]==None):\n\t\t\t\tstack.append((item,i))\n\t\t\t\tflag = False\n\t\tif(flag):\n\t\t\trem = 0\n\t\t\ttree_size = 1\n\t\t\tfor item in adj[i]:\n\t\t\t\tif(item==parent):\n\t\t\t\t\tcontinue\n\t\t\t\tsubtree_size,t = sol[item]\n\t\t\t\tif(subtree_size%2==0):\n\t\t\t\t\trem+=1\n\t\t\t\trem += t\n\t\t\t\ttree_size += subtree_size\n\t\t\tsol[i] = [tree_size,rem]\n\t\t\tstack.pop(-1)\n\t# print(sol)\n\treturn sol[1][1]\n\n\nn = int(input())\nadj = [[] for i in range(n+1)]\nfor _ in range(n-1):\n\tu,v = map(int,input().split())\n\tadj[u].append(v)\n\tadj[v].append(u)\nif(n%2==1):\n\tprint(-1)\nelse:\n\tans = dfs_new(adj,n)\n\tprint(ans)", "# n nodes, n - 1 edges, no possibility for loop\n# so no need of maintaining a vis array, it'd not visit nodes previously visited\n# as long as you don't go along the edge back which leads you to the current node\n\n\nfrom collections import deque\n\n\ndef main():\n    n = int(input())\n    neis = [[] for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]  # vis[i] -- the next node i is going to visit is neis[vis[i]]\n    nodes = [1 for i in range(n + 1)]  # nodes[i] -- the number of nodes 'belong to' i(included i)\n    pre = [None for i in range(n + 1)]  # pre[i] -- the node which leads to node i in fake dfs process\n    cut = 0\n\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        neis[u].append(v)\n        neis[v].append(u)\n    for i in range(1, n + 1):\n        neis[i].append(None)\n\n    start_point = 1\n    pre[start_point] = start_point\n    q = deque()\n    q.append(start_point)\n\n    while len(q) > 0:\n        top = q[-1]\n        nei = neis[top][vis[top]]\n\n        if nei is not None:\n            vis[top] += 1\n            if nei != pre[top]:\n                q.append(nei)\n                pre[nei] = top\n        else:\n            if top != start_point:\n                nodes[pre[top]] += nodes[top]\n                if nodes[top] % 2 == 0:\n                    cut += 1\n            q.pop()\n\n    if nodes[1] % 2 == 0:\n        print(cut)\n    else:\n        print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# n nodes, n - 1 edges, no possibility for loop\n# so no need of maintaining a vis array, it'd not visit nodes previously visited\n# as long as you don't go along the edge back which leads you to the current node\n\n\nfrom collections import deque\n\n\ndef main():\n    n = int(input())\n    # don't use hash table\n    neis = [[] for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]  # vis[i] -- the next node i is going to visit is neis[vis[i]]\n    nodes = [1 for i in range(n + 1)]  # nodes[i] -- the number of nodes 'belong to' i(included i)\n    pre = [None for i in range(n + 1)]  # pre[i] -- the node which leads to node i in fake dfs process\n    cut = 0\n\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        neis[u].append(v)\n        neis[v].append(u)\n    for i in range(1, n + 1):\n        neis[i].append(None)\n\n\n\n    start_point = 1\n    q = deque()\n    q.append(start_point)\n\n    while len(q) > 0:\n        top = q[-1]\n        nei = neis[top][vis[top]]\n\n        if nei is not None:\n            vis[top] += 1\n            if nei != pre[top]:\n                q.append(nei)\n                pre[nei] = top\n        else:\n            if top != start_point:\n                nodes[pre[top]] += nodes[top]\n                if nodes[top] % 2 == 0:\n                    cut += 1\n            q.pop()\n\n    if nodes[1] % 2 == 0:\n        print(cut)\n    else:\n        print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# n nodes, n - 1 edges, no possibility for loop\n# so no need of maintaining a vis array, it'd not visit nodes previously visited\n# as long as you don't go along the edge back which leads you to the current node\n\n\nfrom collections import deque\n\n\ndef main():\n    n = int(input())\n    # don't use hash table\n    neis = [[] for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]  # vis[i] -- the next node i is going to visit is neis[vis[i]]\n    nodes = [1 for i in range(n + 1)]  # nodes[i] -- the number of nodes 'belong to' i(included i)\n    pre = [None for i in range(n + 1)]  # pre[i] -- the node which leads to node i in fake dfs process\n    cut = 0\n\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        neis[u].append(v)\n        neis[v].append(u)\n\n    start_point = 1\n    pre[start_point] = start_point\n    q = deque()\n    q.append(start_point)\n\n    while len(q) > 0:\n        top = q[-1]\n\n        if vis[top] < len(neis[top]):\n            nei = neis[top][vis[top]]\n            vis[top] += 1\n            if nei != pre[top]:\n                q.append(nei)\n                pre[nei] = top\n        else:\n            if top != start_point:\n                nodes[pre[top]] += nodes[top]\n                if nodes[top] % 2 == 0:\n                    cut += 1\n            q.pop()\n\n    if nodes[1] % 2 == 0:\n        print(cut)\n    else:\n        print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# n nodes, n - 1 edges, no possibility for loop\n# so no need of maintaining a vis array, it'd not visit nodes previously visited\n# as long as you don't go along the edge back which leads you to the current node\n\n\nfrom collections import deque\n\n\ndef main():\n    n = int(input())\n    # don't use hash table\n    neis = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        neis[u].append(v)\n        neis[v].append(u)\n\n    def fake_dfs(start_point):\n        nonlocal neis\n\n        vis = [0 for i in range(n + 1)]  # vis[i] -- the next node i is going to visit is neis[vis[i]]\n        nodes = [1 for i in range(n + 1)]  # nodes[i] -- the number of nodes 'belong to' i(included i)\n        pre = [None for i in range(n + 1)]  # pre[i] -- the node which leads to node i in fake dfs process\n        cut = 0\n\n        q = deque()\n        q.append(start_point)\n        pre[start_point] = start_point\n\n        while len(q) > 0:\n            top = q[-1]\n\n            if vis[top] < len(neis[top]):\n                nei = neis[top][vis[top]]\n                vis[top] += 1\n                if nei != pre[top]:\n                    q.append(nei)\n                    pre[nei] = top\n            else:\n                if top != start_point:\n                    nodes[pre[top]] += nodes[top]\n                    if nodes[top] & 1 == 0:\n                        cut += 1\n                q.pop()\n\n        if nodes[1] & 1 == 0:\n            print(cut)\n        else:\n            print(-1)\n\n    fake_dfs(1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# n nodes, n - 1 edges, no possibility for loop\n# so no need of maintaining a vis array, it'd not visit nodes previously visited\n# as long as you don't go along the edge back which leads you to the current node\n\n\nfrom collections import deque\nfrom array import array\n\n\ndef main():\n    n = int(input())\n    # don't use hash table\n    neis = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        neis[u].append(v)\n        neis[v].append(u)\n\n    def fake_dfs(start_point):\n        nonlocal neis\n\n        # vis = [0 for i in range(n + 1)]  # vis[i] -- the next node i is going to visit is neis[vis[i]]\n        # nodes = [1 for i in range(n + 1)]  # nodes[i] -- the number of nodes 'belong to' i(included i)\n        # pre = [None for i in range(n + 1)]  # pre[i] -- the node which leads to node i in fake dfs process\n        vis = array('I', (0 for _ in range(n + 1)))\n        nodes = array('I', (1 for _ in range(n + 1)))\n        pre = array('I', (0 for _ in range(n + 1)))\n        cut = 0\n\n        q = deque()\n        q.append(start_point)\n        pre[start_point] = start_point\n\n        while len(q) > 0:\n            top = q[-1]\n\n            if vis[top] < len(neis[top]):\n                nei = neis[top][vis[top]]\n                vis[top] += 1\n                if nei != pre[top]:\n                    q.append(nei)\n                    pre[nei] = top\n            else:\n                if top != start_point:\n                    nodes[pre[top]] += nodes[top]\n                    if nodes[top] & 1 == 0:\n                        cut += 1\n                q.pop()\n\n        if nodes[1] & 1 == 0:\n            print(cut)\n        else:\n            print(-1)\n\n    fake_dfs(1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\n\nif n % 2 != 0:\n  print(-1)\n  return\n\nlinks = [[1, set()] for i in range(1, n+1)]\nW = 0\nL = 1\n\ni = 0\nwhile i < n-1:\n  i += 1\n  [a, b] = [int(x) for x in input().split()]\n  links[a-1][L].add(b-1)\n  links[b-1][L].add(a-1)\n\ncount = sear = cur = 0\nwhile sear < n:\n  li = cur\n  l = links[li]\n  if len(l[L]) != 1:\n    if sear == cur:\n      sear += 1\n    cur = sear\n    continue\n\n  mi = l[L].pop()\n  m = links[mi]\n  if l[W] % 2 == 0:\n    count += 1\n  else:\n    m[W] += 1\n\n  m[L].remove(li)\n  if mi < sear:\n    cur = mi\n  else:\n    sear += 1\n    cur = sear\n\nprint(count)", "\ndef main():\n    n = int(input())\n\n    g = [[] for i in range(n + 5)]\n    vh = [[] for i in range(n + 5)]\n    size = [1 for i in range(n + 5)]\n    par = [i for i in range(n + 5)]\n\n    if n % 2 == 1:\n        print(-1)\n        return\n\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n\n    q = [[1, 1]]\n    vh[1].append(1)\n    max_height = 1\n    while len(q) > 0:\n        u, hu = q.pop()\n        #print(u)\n        leaf_node = True\n\n        for v in g[u]:\n            if v == par[u]:\n                continue\n            hv = hu + 1\n            par[v] = u\n            q.append([v, hv])\n            vh[hv].append(v)\n            max_height = max(max_height, hv)\n\n    while max_height > 0:\n        for v in vh[max_height]:\n            size[par[v]] += size[v]\n        max_height -= 1\n\n    print(n - 1 - sum(size[i] % 2 for i in range(1, n + 1)))\n\nmain()", "def dfs_new(adj,n):\n\tstack = [(1,0)]\n\tsol = [None for i in range(n+1)]\n\twhile(not len(stack)==0):\n\t\ti,parent = stack[-1]\n\t\tflag = True\n\t\tfor item in adj[i]:\n\t\t\tif(item==parent):\n\t\t\t\tcontinue\n\t\t\tif(sol[item]==None):\n\t\t\t\tstack.append((item,i))\n\t\t\t\tflag = False\n\t\t\t# print(stack, flag)\n\t\t\t# print(sol)\n\t\tif(flag):\n\t\t\trem = 0\n\t\t\ttree_size = 1\n\t\t\tfor item in adj[i]:\n\t\t\t\tif(item==parent):\n\t\t\t\t\tcontinue\n\t\t\t\tsubtree_size,t = sol[item]\n\t\t\t\t# print(item, subtree_size, t)\n\t\t\t\tif(subtree_size%2==0):\n\t\t\t\t\trem+=1\n\t\t\t\trem += t\n\t\t\t\ttree_size += subtree_size\n\t\t\tsol[i] = [tree_size,rem]\n\t\t\tstack.pop(-1)\n\t# print(sol)\n\treturn sol[1][1]\n\n\nn = int(input())\nadj = [[] for i in range(n+1)]\nfor _ in range(n-1):\n\tu,v = list(map(int,input().split()))\n\tadj[u].append(v)\n\tadj[v].append(u)\nif(n%2==1):\n\tprint(-1)\nelse:\n\tans = dfs_new(adj,n)\n\tprint(ans)\n", "n=int(input())\nif n&1>0:print(-1);return\ng=[[] for _ in range(n) ]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\nc=[1]*n\nv=[-1]*n\nv[0]=0\ns=[0]\nwhile s:\n    x=s[-1]\n    k=False\n    for j in g[x]:\n        if v[j]==-1:\n            v[j]=x\n            s.append(j)\n            k=True\n    if not k:\n        s.pop()\n        c[v[x]]+=c[x]\no=0\nfor j in c[1:]:\n    if j&1<1:o+=1 \nprint(o)", "def dfs(g, s):\n    visited = set([s])\n    stack = [s]\n    res = 0\n    \n    while len(stack) > 0:\n        s = stack.pop()\n        cnt = 0\n\n        cnt += 1 #count the size of the current subtree\n        visited.add(s)        \n        \n        for v in g[s]:\n            if v not in visited:\n                cnt += 1\n                stack.append(v)\n\n        if cnt % 2 == 0:\n            res += 1\n\n    return res // 2\n\ndef dfs2(g,s,n):\n    parent = [0]*(n+1)\n    counts = [1]*(n+1)\n    stack = []\n\n    stack.append(s)\n        \n    while stack:\n        v = stack[-1]\n        empty_s = True\n        \n        if not parent[v]:\n            parent[v] = 1\n        \n        for node in g[v]:\n            if not parent[node]:\n                parent[node] = v\n                stack.append(node)\n                empty_s = False\n                \n        if empty_s:\n            stack.pop()\n            counts[parent[v]] += counts[v]\n    \n    return sum([1 for x in counts[2:] if x % 2 == 0])\n\ndef solve():\n    #f = open(\"Cut em all - DFS.txt\")\n    n = int(input())\n    \n    tree = [[] for i in range(n+1)]\n    \n    for i in range(n-1):\n        u ,v = input().split()\n        u, v = int(u), int(v)\n        tree[v].append(u)\n        tree[u].append(v)\n    \n    if n % 2 != 0:\n        print (-1)\n        return\n\n    #print (dfs(tree, 1))\n    print (dfs2(tree, 1, n))\n\ndef __starting_point():\n    solve()\n__starting_point()", "n=int(input())\nif n&1>0:print((-1));return\ng=[[] for _ in range(n) ]\nfor _ in range(n-1):\n    a,b=list(map(int,input().split()))\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\nc=[1]*n\nv=[-1]*n\nv[0]=0\ns=[0]\nwhile s:\n    x=s[-1]\n    k=False\n    for j in g[x]:\n        if v[j]==-1:\n            v[j]=x\n            s.append(j)\n            k=True\n    if not k:\n        s.pop()\n        c[v[x]]+=c[x]\no=0\nfor j in c[1:]:\n    if j%2==0:\n        o+=1 \nprint(o)\n", "def main():\n    n = int(input())\n    if n % 2 != 0: print((-1)); return;\n\n    graph = [[] for _ in range(n)]\n\n    for _ in range(n-1):\n        a, b = list(map(int, input().split()))\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    res = 0    \n    stack = [0]\n    visited = [-1] * n\n    visited[0] = 0\n\n    count = [1] * n\n\n    while stack:\n        s = stack[-1]\n        flag = False\n\n        for v in graph[s]:\n            if visited[v] == -1:\n                stack.append(v)\n                visited[v] = s\n                flag = True\n\n        if not flag:\n            stack.pop()\n            if s == 0: break;\n            count[visited[s]] += count[s]\n\n    res = sum([1 if i % 2 == 0 else 0 for i in count])\n    print(res-1)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from sys import stdin\ninp = stdin.readline\nn, ans = int(inp()), 0\nif n & 1:\n    print(-1)\n    return\ng = {i: [set(), 0] for i in range(1, n + 1)}\nvisited = [0] * (n + 1)\nfor _ in range(n - 1):\n    a, b = map(int, inp().split())\n    g[a][0].add(b)\n    g[b][0].add(a)\nvisited = [0, 1] + [0] * (n - 1)\nq = [1]\np = [0] * (n + 1)\nwhile q:\n    v = q.pop()\n    if v != 1 and len(g[v][0]) == 1:\n        g[p[v]][0].remove(v)\n        g[p[v]][1] += g[v][1] + 1\n        q.append(p[v])\n        if g[v][1] & 1: ans += 1\n        continue\n    for i in g[v][0]:\n        if not visited[i]:\n            visited[i] = True\n            p[i] = v\n            q.append(i)\n            if min(g[v][1], g[i][1]) & 1:\n                ans += 1\nprint(ans)", "n = int(input())\nif n%2 == 1:\n    print(-1)\n    return\ngraph = {}\nfor i in range(n-1):\n    v, u = map(int, input().strip().split())\n    v -= 1; u -= 1\n    if v in graph:\n        graph[v].append(u)\n    else:\n        graph[v] = [u]\n    \n    if u in graph:\n        graph[u].append(v)\n    else:\n        graph[u] = [v]\ncountArr = [1 for i in range(n)]\ns = [0]\nvis = [-1 for i in range(n)]\nwhile s:\n    curr = s[-1]\n    k = False\n    for i in graph[curr]:\n        if vis[i] == -1:\n            vis[i] = curr\n            s.append(i)\n            k = True\n    if not k:\n        if curr != 0:\n            countArr[vis[curr]] += countArr[curr]\n        s.pop()\no = 0\nfor i in countArr[1:]:\n    if i%2 == 0: o += 1\nprint(o)", "n = int(input())\nif n % 2 == 1:\n    print(-1)\n    return\n\nadj = [[] for _ in range(n+1) ]\nfor _ in range(n-1):\n    u, v = list(map(int, input().split()))\n    adj[u].append(v)\n    adj[v].append(u)\n\ncnt = [1] * (n+1)\nprt = [-1] * (n+1)\nprt[1] = 1\nstk = [1]\nwhile stk:\n    u = stk[-1]\n    k = False\n    for v in adj[u]:\n        if prt[v] == -1:\n            prt[v] = u\n            stk.append(v)\n            k = True\n    if not k:\n        stk.pop()\n        cnt[prt[u]] += cnt[u]\nres = 0\nfor j in cnt[2:]:\n    if j % 2 == 0:\n        res += 1 \nprint(res)\n", "import sys\n\n# import bisect\n# from collections import deque\n# sys.setrecursionlimit(100000)\n \nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\n \ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n \nn =int(ri())\nlis = [[] for i in range(n)]\nfor _ in range(n-1):\n    a,b = Ri()\n    a-=1\n    b-=1\n    lis[a].append(b)\n    lis[b].append(a)\nvisit =[-1]*n\nno = [1]*n\nsta = [0]\nvisit[0]= True\nif n&1 == 1:\n    print(-1)\nelse:\n    while len(sta) > 0:\n        top = sta[-1]\n        ret = True\n        for i in range(len(lis[top])):\n            if visit[lis[top][i]] == -1:\n                visit[lis[top][i]] = top\n                ret = False\n                sta.append(lis[top][i])\n        if ret:\n            if top != 0:\n                no[visit[top]]+=no[top]\n            sta.pop()\n    ans=0\n    no= no[1:]\n    for i in no:\n        if i&1 == 0:\n            ans+=1\n    print(ans)\n\n", "import os, sys, bisect, copy\nfrom collections import defaultdict, Counter, deque\nfrom functools import lru_cache   #use @lru_cache(None)\nif os.path.exists('in.txt'): sys.stdin=open('in.txt','r')\nif os.path.exists('out.txt'): sys.stdout=open('out.txt', 'w')\n#\ndef input(): return sys.stdin.readline()\ndef mapi(arg=0): return list(map(int if arg==0 else str,input().split()))\n#------------------------------------------------------------------\nimport sys\nsys.setrecursionlimit(10**5)\nfrom types import GeneratorType\n#use:- put @bootstrap overrecursive function\ndef bootstrap(func, stack=[]):\n    def wrapped_function(*args, **kwargs):\n        if stack:\n            return func(*args, **kwargs)\n        else:\n            call = func(*args, **kwargs)\n            while True:\n                if type(call) is GeneratorType:\n                    stack.append(call)\n                    call = next(call)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    call = stack[-1].send(call)\n            return call\n    return wrapped_function\n\nn = int(input())\ngr = defaultdict(list)\nfor i in range(n-1):\n    x,y = mapi()\n    gr[x].append(y)\n    gr[y].append(x)\n\nsz = [0]*(n+1)\nres = 0\n@bootstrap\ndef dfs(s,par):\n    nonlocal res\n    sz[s] = 1\n    for u in gr[s]:\n        if par==u: continue\n        sz[s]+= yield dfs(u,s)\n    if sz[s]%2==0 and s!=1:\n        res+=1\n    yield sz[s]\ndfs(1,-1)\n#print(*sz)\nif sz[1]&1:\n    print(-1)\nelse:\n    print(res)\n", "n = int(input())\nif n % 2 == 1:\n    print(-1)\nelse:\n    edges = [[] for i in range(n)]\n    for i in range(n-1):\n        [a,b] = [int(j) for j in input().split()]\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n    dfs_stack = [0]\n    c = [1 for i in range(n)]\n    visited = [-1 for i in range(n)]\n    visited[0] = 0\n    \n    while dfs_stack != []:\n        current_node = dfs_stack[-1]\n        can_go_further = False\n        for i in edges[current_node]:\n            if visited[i] == -1:\n                dfs_stack.append(i)\n                visited[i] = current_node\n                can_go_further = True\n        if can_go_further == False:\n            dfs_stack.pop(-1)\n            c[visited[current_node]] += c[current_node]\n    \n    ans = 0\n    for i in c[1:]:\n        if i % 2 == 0:\n            ans += 1\n    print(ans)", "n = int(input())\nif n % 2 == 1:\n    print(-1)\nelse:\n    edges = [[] for i in range(n)]\n    for i in range(n-1):\n        [a,b] = [int(j) for j in input().split()]\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n    dfs_stack = [0]\n    comp_size = [1 for i in range(n)]\n    visited = [-1 for i in range(n)]\n    visited[0] = 0\n    \n    while dfs_stack != []:\n        current_node = dfs_stack[-1]\n        can_go_further = False\n        for i in edges[current_node]:\n            if visited[i] == -1:\n                dfs_stack.append(i)\n                visited[i] = current_node\n                can_go_further = True\n        if can_go_further == False:\n            dfs_stack.pop(-1)\n            comp_size[visited[current_node]] += comp_size[current_node]\n    \n    ans = 0\n    for i in comp_size[1:]:\n        if i % 2 == 0:\n            ans += 1\n    print(ans)", "n = int(input())\nif n % 2 == 1:\n    print(-1)\nelse:\n    edges = [[] for i in range(n)]\n    for i in range(n-1):\n        [a,b] = [int(j) for j in input().split()]\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n    dfs_stack = [0]\n    comp_size = [1 for i in range(n)]\n    visited = [-1 for i in range(n)]\n    visited[0] = 0\n    \n    while dfs_stack != []:\n        current_node = dfs_stack[-1]\n        can_go_further = False\n        for i in edges[current_node]:\n            if visited[i] == -1:\n                dfs_stack.append(i)\n                visited[i] = current_node\n                can_go_further = True\n        if can_go_further == False:\n            dfs_stack.pop(-1)\n            comp_size[visited[current_node]] += comp_size[current_node]\n    \n    ans = 0\n    for i in comp_size[1:]:\n        if i % 2 == 0:\n            ans += 1\n    print(ans)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[8]:\n\n\nn = int(input())\nif n % 2 == 1:\n    print(-1)\nelse:\n    edges = [[] for i in range(n)]\n    for i in range(n-1):\n        [a,b] = [int(j) for j in input().split()]\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n    dfs_stack = [0]\n    comp_size = [1 for i in range(n)]\n    visited = [-1 for i in range(n)]\n    visited[0] = 0\n    \n    while dfs_stack != []:\n        current_node = dfs_stack[-1]\n        can_go_further = False\n        for i in edges[current_node]:\n            if visited[i] == -1:\n                dfs_stack.append(i)\n                visited[i] = current_node\n                can_go_further = True\n        if can_go_further == False:\n            dfs_stack.pop(-1)\n            comp_size[visited[current_node]] += comp_size[current_node]\n    \n    ans = 0\n    for i in comp_size[1:]:\n        if i % 2 == 0:\n            ans += 1\n    print(ans)\n\n\n# In[ ]:\n\n\n\n\n"]
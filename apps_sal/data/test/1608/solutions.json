["import sys\n\nmod = 10**9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    cnt = [0]*(10**5 + 1)\n\n    for ai in a:\n        for d in range(1, ai + 1):\n            if d*d > ai:\n                break\n            if ai % d == 0:\n                if d != ai // d:\n                    cnt[d] += 1\n                    cnt[ai // d] += 1\n                else:\n                    cnt[d] += 1\n\n    ans = 0\n\n    for i in range(1, 10**5 + 1):\n        ans += mobius(i) * (pow(2, cnt[i], mod) - 1)\n        ans %= mod\n\n    print(ans)\n\ndef mobius(x):\n    assert x >= 1\n\n    divcnt = 0\n\n    for p in range(2, x + 1):\n        if p*p > x:\n            break\n        if x % p != 0:\n            continue\n\n        x //= p\n\n        if x % p == 0:\n            return 0\n        else:\n            divcnt ^= 1\n\n    if x > 1:\n        divcnt ^= 1\n\n    return (-1)**divcnt\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\nmod = 10**9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    cnt = [0]*(10**5 + 1)\n    pat = [0]*(10**5 + 1)\n\n    for ai in a:\n        cnt[ai] += 1\n\n    for i in range(1, 10**5 + 1):\n        for j in range(2*i, 10**5 + 1, i):\n            cnt[i] += cnt[j]\n        \n        pat[i] = (pow(2, cnt[i], mod) - 1)\n\n    for i in range(10**5, 0, -1):\n        for j in range(2*i, 10**5 + 1, i):\n            pat[i] = (pat[i] - pat[j]) % mod\n\n    ans = pat[1] % mod\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\nmod = 10**9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    cnt = [0]*(10**5 + 1)\n    pat = [0]*(10**5 + 1)\n    p2 = [1]*(n + 1)\n\n    for i in range(1, n + 1):\n        p2[i] = (2 * p2[i - 1]) % mod\n\n    for ai in a:\n        cnt[ai] += 1\n\n    for i in range(1, 10**5 + 1):\n        for j in range(2*i, 10**5 + 1, i):\n            cnt[i] += cnt[j]\n        \n        pat[i] = p2[cnt[i]] - 1\n\n    for i in range(10**5, 0, -1):\n        for j in range(2*i, 10**5 + 1, i):\n            pat[i] = (pat[i] - pat[j]) % mod\n\n    ans = pat[1] % mod\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\nmod = 10**9 + 7\n\ndef solve():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n\n    cnt = [0]*(10**5 + 1)\n    pat = [0]*(10**5 + 1)\n    p2 = [1]*(n + 1)\n\n    for i in range(1, n + 1):\n        p2[i] = (2 * p2[i - 1]) % mod\n\n    for ai in a:\n        cnt[ai] += 1\n\n    for i in range(1, 10**5 + 1):\n        for j in range(2*i, 10**5 + 1, i):\n            cnt[i] += cnt[j]\n        \n        pat[i] = p2[cnt[i]] - 1\n\n    for i in range(10**5, 0, -1):\n        for j in range(2*i, 10**5 + 1, i):\n            pat[i] = (pat[i] - pat[j]) % mod\n\n    ans = pat[1] % mod\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "MOD = int( 1e9 ) + 7\n\nN = int( input() )\nA = list( map( int, input().split() ) )\n\npow2 = [ pow( 2, i, MOD ) for i in range( N + 1 ) ]\n\nmaxa = max( A )\nmcnt = [ 0 for i in range( maxa + 1 ) ]\nmans = [ 0 for i in range( maxa + 1 ) ]\nfor i in range( N ):\n  mcnt[ A[ i ] ] += 1\nfor i in range( 1, maxa + 1 ):\n  for j in range( i + i, maxa + 1, i ):\n    mcnt[ i ] += mcnt[ j ]\n  mans[ i ] = pow2[ mcnt[ i ] ] - 1\nfor i in range( maxa, 0, -1 ):\n  for j in range( i + i, maxa + 1, i ):\n    mans[ i ] = ( mans[ i ] - mans[ j ] ) % MOD\nprint( mans[ 1 ] + ( mans[ 1 ] < 0 ) * MOD )\n", "n=int(input())\nL=list(map(int,input().split(' ')))\nD=[0]*101000\nmod=10**9+7\nitt=[0]*101000\np=[0]*100010\nD[0]=1\nfor i in range(100010):\n  D[i+1]=(D[i]*2)%mod\nfor i in range(n):\n  itt[L[i]]+=1 \n\nfor i in range(1,100001):\n  for j in range(i*2,100001,i):\n    itt[i]+=itt[j]\n  p[i]=(D[itt[i]]+mod-1)%mod\ni=100000\nwhile i>=1:\n  for j in range(i*2,100001,i):\n    p[i]-=p[j]\n  p[i]=(p[i]%mod+mod)%mod\n  i-=1\nprint(p[1])\n \n", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef getMul(x):\n    a = 1\n    for xi in x:\n        a *= xi\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nd = {}\nfor ai in a:\n    if ai in d: d[ai] += 1\n    else: d[ai] = 1\n\nf = [[] for i in range(max(a)+10)]\nfor i in range(1, len(f)):\n    for j in range(i, len(f), i):\n        f[j].append(i)\n\nseq = [0 for i in range(max(a)+10)]\nfor ai in d:\n    for fi in f[ai]:\n        seq[fi] += d[ai]\nfor i in range(len(seq)):\n    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD\n\npf = [[] for i in range(max(a)+10)]\npf[0] = None\npf[1].append(1)\nfor i in range(2, len(f)):\n    if len(pf[i]) == 0:\n        for j in range(i, len(pf), i):\n            pf[j].append(i)\nfor i in range(1, len(pf)):\n    mul = getMul(pf[i])\n    if mul == i:\n        if len(pf[i])&1 == 1: pf[i] = -1\n        else: pf[i] = 1\n    else:\n        pf[i] = 0\npf[1] = 1\n\nans = 0\nfor i in range(1, len(seq)):\n    ans += seq[i]*pf[i]\n    ans = (ans + MOD) % MOD\nprint(ans)", "fact=[1]\ntemp=1\nMOD=10**9+7\nfor i in range(1,10**5+5):\n    temp*=i\n    temp%=MOD\n    fact+=[temp]\ndef bino(a,b):\n    up=fact[a]\n    down=pow(fact[b]*fact[a-b],MOD-2,MOD)\n    return (up*down)%MOD\n\n\ndef find(A):\n    MOD=10**9+7\n    \n    \n    dp=[0]*(10**5+2)\n    for x in A:\n        dp[x]+=1\n    for i in range(2,len(dp)):\n        for j in range(2,len(dp)):\n            if i*j>len(dp)-1:\n                break\n            dp[i]+=dp[i*j]\n    for i in range(2,len(dp)):\n        dp[i]=(pow(2,dp[i],MOD)-1)%MOD\n    \n    for i in range(len(dp)-1,1,-1):\n        for j in range(2,len(dp)):\n            if i*j>=len(dp):\n                break\n            dp[i]-=dp[i*j]\n            dp[i]%=MOD\n    \n    ans=0\n    for i in range(2,len(dp)):\n        ans+=dp[i]\n        ans%=MOD\n    \n    return (pow(2,len(A),MOD)-ans-1)%MOD\ninput()\nprint(find(list(map(int,input().strip().split(' ')))))                \n    \n", "# 803F\nimport math\nimport collections\ndef do():\n    n = int(input())\n    nums = map(int, input().split(\" \"))\n    count = collections.defaultdict(int)\n    for num in nums:\n        for i in range(1, int(math.sqrt(num))+1):\n            cp = num // i\n            if num % i == 0:\n                count[i] += 1\n            if cp != i and num % cp == 0:\n                count[cp] += 1\n    maxk = max(count.keys())\n    freq = {k: (1 << count[k]) - 1 for k in count}\n    for k in sorted(count.keys(), reverse=True):\n        for kk in range(k << 1, maxk+1, k):\n            freq[k] -= freq[kk] if kk in freq else 0\n    return freq[1] % (10**9 + 7)\n\nprint(do())", "N = 10**5+5\nMOD = 10**9+7\n\nfreq = [0 for i in range(N)]\n\n# Calculating {power(2,i)%MOD} and storing it at ith pos in p2 arr\np2 = [0 for i in range(N)]\np2[0] = 1\nfor i in range(1,N):\n    p2[i] = p2[i-1]*2\n    p2[i]%=MOD\n\ndef Calculate_Mobius(N):\n    arr = [1 for i in range(N+1)]\n    prime_count = [0 for i in range(N+1)]\n\n    mobius_value = [0 for i in range(N+1)]\n    for i in range(2,N+1):\n        if prime_count[i]==0:\n            for j in range(i,N+1,i):\n                prime_count[j]+=1\n                arr[j] = arr[j] * i\n\n    for i in range(1, N+1):\n        if arr[i] == i:\n            if (prime_count[i] & 1) == 0:\n                mobius_value[i] = 1\n            else:\n                mobius_value[i] = -1\n        else:\n            mobius_value[i] = 0\n\n    return mobius_value\n\n# Caluclating Mobius values for nos' till 10^5\nmobius = Calculate_Mobius(N)\nn = int(input())\nb = [int(i) for i in input().split()]\n\n# Storing freq of I/p no.s in array  \nfor i in b:\n    freq[i]+=1\n\nans = 0\nfor i in range(1,N):\n    # Count no of I/p no's which are divisible by i\n    cnt = 0\n    for j in range(i,N,i):\n        cnt += freq[j]\n    \n    total_subsequences = p2[cnt] - 1\n    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD\n\n# Dealing if ans is -ve due to MOD\nans += MOD\nprint(ans%MOD)\n\n", "\nmod = int(1e9 + 7)\n\nn = int(input())\na = [int(_) for _ in input().split()]\n\nfreq = {i: 0 for i in range(100001)}\npower = {0: 1}\nfor i in range(1, 100001):\n    power[i] = (2 * power[i - 1]) % mod\n\nfor v in a:\n    freq[v] += 1\n\ndp = {i: 0 for i in range(100001)}\nfor gcd in range(100000, 0, -1):\n    mult = 2\n    total = freq[gcd]\n    complement = 0\n    # xy = k, so integral is ln(x)\n    while mult * gcd <= 100000:\n        total += freq[mult * gcd]\n        complement += dp[mult * gcd]\n        mult += 1\n    dp[gcd] = (power[total] - 1 - complement + mod) % mod\n\nprint(dp[1])", "n=int(input())\nr=list(map(int,input().split()))\ndp=[0]*(10**5+1)\ncnt=[0]*(10**5+1)\ntmp=[0]*(10**5+1)\nmod=10**9+7\nfor i in range(n):\n\tcnt[r[i]]+=1\nfor i in range(1,10**5+1):\n\tfor j in range(2*i,10**5+1,i):\n\t\tcnt[i]+=cnt[j]\n\ttmp[i]=pow(2,cnt[i],mod)-1\nfor i in range(10**5,0,-1):\n\tfor j in range(2*i,10**5+1,i):\n\t\ttmp[i]=(tmp[i]-tmp[j])%mod\nprint(tmp[1]%mod)"]
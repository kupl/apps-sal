["from bisect import bisect_left,bisect\n\n# ===================================== \u7d04\u6570\u306e\u30ea\u30b9\u30c8   \ndef enum_div(n):\n    ir=int(n**(0.5))+1\n    ret=[]\n    for i in range(1,ir):\n        if n%i == 0:\n            ret.append(i)\n            if (i!= 1) & (i*i != n):\n                ret.append(n//i)\n    return ret\n\nn,m=list(map(int,input().split()))\n\ndiv=enum_div(m)+[m]\ndiv.sort(reverse=True)\n\nrd=[0]*len(div)\nfor i in range(len(div)):\n    rd[i]=m//div[i]\n\nmm=bisect_left(rd,n)\n\nprint((div[mm]))\n", "def prime(n):\n    l = [[], []]\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if i*i == n:\n                l[0].append(i)\n            else:\n                l[0].append(i)\n                l[1].append(n//i)\n    return l[0]+l[1][::-1]\nn, m = map(int, input().split())\nx = 0\nfor i in prime(m):\n    if i <= m//n:\n        x = i\nprint(x)", "import math\nn, m = list(map(int, input().split()))\n\nif n == 1:\n    print(m)\n    return\na = []\nb = []\nfor i in range(1, math.ceil(math.sqrt(m))):\n    if m % n == 0:\n        print((m // n))\n        return\n    if m % i == 0:\n        b.append(i)\n        b.append(m // i)\n        \n#print(b)\n\nfor i in range(len(b)):\n    if b[i] * n <= m:\n        a.append(b[i])\n#print(a)\n\nif len(b) == 2:\n    print((1))\nelse:\n    print((max(a)))\n", "from math import sqrt,floor\nN,M =map(int,input().split())\nans = 1\nfor g in range(1,floor(sqrt(M))+1):\n    if M%g == 0:\n        x = M//g\n        if x > floor(sqrt(M)) and g >= N:\n            ans = x\n            break\n        if x >= N:\n            ans = g\nprint(ans)", "n,m=list(map(int,input().split()))\nd=[]\nf=1\nwhile f*f<m+1:\n  if m%f==0:\n    d.append(f)\n    d.append(m//f)\n  f+=1\nd.sort(reverse=True)\nfor i in d:\n  if  (m-i*n)>=0 and (m-i*n)%i==0 :break\nprint(i)\n", "N,M=list(map(int,input().split()))\n\ndef primes(n):\n    d=[]\n    for i in range(1, int(n**0.5) + 1):\n        if n%i==0:\n            d.append(i)\n            if n//i!=i:\n                d.append(n//i)\n    d.sort()\n    return d\n\nd=primes(M)\n\nfor i in d[::-1]:\n    if M//i>=N:\n        ans=i\n        break\n\nprint(ans)\n", "N,M = list(map(int,input().split()))\n\nimport math\nG=[]\nfor i in range(1,int(math.sqrt(M))+2+1):\n    if M%i == 0:\n        cd = M//i\n        G.append(cd)\n        G.append(i)\n\nG.sort(reverse=True)\nfor g in G:\n    n = M//g\n    if n>=N:\n        print(g)\n        return\n\n\n\n\n\n\n\n", "from collections import defaultdict\n\nn, m = list(map(int, input().split()))\n\nans = 0\ni = 1\nwhile i * i <= m:\n    if m % i == 0:\n        a, b = i, m // i\n        if b >= n:\n            ans = max(ans, a)\n        if a >= n:\n            ans = max(ans, b)\n    i += 1\nprint(ans)\n", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\n#import bisect\n#\n#    d = m - k[i] - k[j]\n#    if kk[bisect.bisect_right(kk,d) - 1] == d:\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\ndef readInts():\n  return list(map(int,input().split()))\ndef I():\n  return int(input())\nn,m = readInts()\ndef yaku(m):\n        ans = []\n        i = 1\n        while i*i <= m:\n            if m % i == 0:\n                j = m // i\n                ans.append(i)\n                if j != i:\n                    ans.append(j)\n            i += 1\n        ans = sorted(ans)\n        return ans\na = yaku(m)\nfor i in range(len(a)):\n    if n*a[i] <= m:\n        ans = a[i]\n    else:\n        break\nprint(ans)\n", "def main():\n    import sys\n\n    def input(): return sys.stdin.readline().rstrip()\n\n    def divisor(m):\n        arr = [1, m]\n        i = 2\n        while i*i <= m:\n            if m%i == 0:\n                arr.append(i)\n                if m//i != i:\n                    arr.append(m//i)\n            i+= 1\n        arr.sort()\n        return arr   \n\n    n, m = map(int, input().split())\n    a = divisor(m)\n    for x in a:\n        if x >= n:\n            print(m//x)\n            return\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\n\nn, m = list(map(int, input().split()))\n\nans = 1\nnum = int(m**0.5)+1\n\nfor i in range(1, num):\n    if m % i != 0:\n        continue\n    j = m//i\n    if i >= n:\n        ans = max(ans, j)\n    if j >= n:\n        ans = max(ans, i)\nprint(ans)\n", "import sys\ndef make_divisors(n):\n  lower_divisors , upper_divisors = [], []\n  i = 1\n  while i*i <= n:\n    if n % i == 0:\n      lower_divisors.append(i)\n      if i != n // i:\n        upper_divisors.append(n//i)\n    i += 1\n  return lower_divisors + upper_divisors[::-1]\nN,M=map(int,input().split())\nc=M//N\nL=make_divisors(M)\nL=list(reversed(L))\nfor i in range(len(L)):\n  if L[i]<=c:\n    print(L[i])\n    return", "def divisor(n):\n  cd = []\n  i = 1\n  while i*i <= n:\n    if n%i==0:\n      cd.append(i)\n      if i != n//i:\n        cd.append(n//i)\n    i += 1\n  return cd\n\nN, M = map(int, input().split())\ncd = divisor(M)\ncd.sort(reverse=True)\nfor c in cd:\n  if M//c>=N:\n    print(c)\n    break", "from collections import deque\n\nN, M = list(map(int, input().split()))\n\na = deque()\nb = deque()\nfor i in range(1, int(M ** (1 / 2)) + 1):\n    if M % i == 0:\n        a.appendleft(i)\n        b.append(M // i)\n\nb.extend(a)\n\nfor i in b:\n    m = M // i\n    if m >= N:\n        print(i)\n        break\n", "def divisor(n):\n    i = 1\n    res = []\n    for i in range(1, int(n**.5) + 1):\n        if n%i == 0:\n            res.append(i)\n            if n//i not in res:\n                res.append(n//i)\n    res.sort()\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    md = divisor(m)\n    ans = 0\n    for i in md:\n        if (m - n*i)%i == 0 and (m - n*i) >= 0:\n            ans = i\n        else:\n            break\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "def make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort()\n    return divisors\n\nn, m = list(map(int, input().split()))\n\nif n % m == 0:\n  print((int(n/m)))\n  return\nelse:\n  lst = make_divisors(m)[::-1]\n  for i in lst:\n    if i == 1:\n      print(i)\n      return\n    if m - i*(n-1) > 0:\n      if (m - i*(n-1)) % i == 0:\n        print(i)\n        return\n    else:\n      continue\n", "#\u7d04\u6570\ndef make_divisors(n): #\u7d04\u6570\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort()\n    return divisors\n\n# \u521d\u671f\u5165\u529b\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nN,M = (int(i) for i in input().split())\nM_div =make_divisors(M)\ndiv_rev =M_div[::-1]\n\n#M=\u7d04\u6570\u2716\uff08\u76f8\u624b\uff09\u21d2\u76f8\u624b\uff1dn(n+1)/2 \u4ee5\u4e0a\u306a\u3089\u6210\u308a\u7acb\u3064\nfor i in range(len(M_div)):\n    if N <= M_div[i]:\n        print(div_rev[i])\n\n        break ", "\nn, m = list(map(int, input().split()))\n\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort()\n    return divisors\n\n\nb = make_divisors(m)\n# print(b)\na = m//n\n# print(a)\nans = 0\nfor i in b:\n    if i <= a:\n        ans = i\nprint(ans)\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,m=nii()\n\ndef divisore(n):\n    divisors=[]\n    for i in range(1,int(n**0.5)+1):\n        if n%i==0:\n            divisors.append(i)\n            if i!=n//i:\n                divisors.append(n//i)\n    divisors.sort(reverse=True)\n    return divisors\n\nd=divisore(m)\n\nfor x in d:\n  zan=m-(x*n)\n  if zan>=0 and zan%x==0:\n    print(x)\n    return", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\ndef divisor(n): \n    i = 1\n    table = []\n    while i * i <= n:\n        if n%i == 0:\n            table.append(i)\n            table.append(n//i)\n        i += 1\n    table = list(set(table))\n    return table\n\nn, m = MAP()\na = sorted(divisor(m))\nprint(m//a[bisect_left(a,n)])", "N,M=map(int,input().split())\n\nP=[]\nA=round(M**0.5)+2\nfor i in range(1,A):\n    if M%i==0:\n        P.append(i)\n        P.append(M//i)\nP.sort()\n\nB=M//N\nans=now=1\nfor p in P:\n    now=p\n    if now<=B:\n        ans=now\nprint(ans)", "from bisect import bisect_right\n\ndef make_divisers(n):\n    upper_result = []\n    lower_result = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            lower_result.append(i)\n\n            ii = n//i\n            if ii != i:\n                upper_result.append(ii)\n\n    return lower_result + upper_result[::-1]\n\ndef main():\n    N, M = map(int, input().split())\n    divisers = make_divisers(M)\n    idx = bisect_right(divisers, M/N) - 1\n    print(divisers[idx])\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nn,m=map(int,input().split())\nans=list()\nfor i in range(1,int(math.sqrt(m))+1):\n  if m%i==0:\n    ans.append(i)\n    ans.append(m//i)\nans.sort(reverse=True)\nfor x in ans:\n  if x <= m//n:\n    print(x)\n    break", "N, M = list(map(int, input().split()))\nans = 1\nif N == 1:\n    print(M)\nelse:\n    for n in range(2, int(M ** 0.5) + 1):\n        if M % n == 0 and M / N >= n:\n            ans = max(ans, n)\n            if M // n * N <= M:\n                ans = max(ans, M // n)\n    print(ans)\n", "import sys\n\ninput = sys.stdin.readline\n\n\ndef calc_divisors(n):\n    divisors_a = []\n    divisors_b = []\n    for d in range(1, int(n**0.5) + 1):\n        if n % d == 0:\n            divisors_a.append(d)\n            if n // d != d:\n                divisors_b.append(n // d)\n    divisors = divisors_a + divisors_b[::-1]\n    return divisors\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n\n    divisors = calc_divisors(M)\n    ans = 0\n    for divisor in divisors:\n        if M // divisor >= N:\n            ans = max(ans, divisor)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nN,M=map(int,input().split())\ndivd=[]\ni=1\nwhile i*i<=M:\n    if M%i==0:\n        divd.append(i)\n        if i!=M//i:\n            divd.append(M//i)\n    i+=1\ndivd.sort()\nk=bisect.bisect_left(divd,N)\nprint(M//divd[k])", "import math\nn,m=list(map(int,input().split()))\nnum=int(math.sqrt(m))\nans=1\nfor i in range(1,num+2):\n    if m%i==0 and i>=n:\n        ans=max(ans,m//i)\n        break\n    if m%i==0 and m//i>=n:\n        ans=max(ans,i)\nprint(ans)\n", "def divisor(n):\n    i = 1\n    res = []\n    while i*i <= n:\n        if n%i == 0:\n            res.append(i)\n            if n//i not in res:\n                res.append(n//i)\n        i += 1\n    res.sort()\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    md = divisor(m)\n    ans = 0\n    for i in md:\n        if (m - n*i)%i == 0 and (m - n*i) >= 0:\n            ans = i\n        else:\n            break\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n\n    M_div = []\n    for i in range(1, int(M ** 0.5) + 1):\n        if M % i == 0:\n            M_div.append(i)\n            M_div.append(M // i)\n\n    # M\u306e\u7d04\u6570\u306e\u4e2d\u3067M\u3092\u5272\u3063\u305f\u6642\u306e\u5024\u304cN\u4ee5\u4e0a\u306b\u306a\u308b\u3088\u3046\u306a\u6700\u5927\u306e\u3082\u306e\n    ans = 1\n    for i in M_div:\n        if M // i >= N:\n            ans = max(i, ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys, math\nfrom functools import lru_cache\nfrom collections import deque\nfrom bisect import bisect_left\nsys.setrecursionlimit(10**9)\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return list(map(int, input().split()))\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\n\ndef main():\n    N, M = mi()\n\n    d = []\n    i = 1\n    while i*i <= M:\n        if M%i == 0:\n            d.append(i)\n            d.append(M//i)\n        i += 1\n\n    d.sort()\n\n    for v in d:\n        if v <= M//N:\n            ans = v\n        else:\n            break\n\n    print(ans)\n\n    \n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int,input().split()))\n\nres = 1\nnum = int(m ** 0.5) + 1\nfor i in range(1, num):\n    if m % i != 0:continue \n    j = m // i\n    if i >= n:\n        res = max(j, res)\n    if j >= n:\n        res = max(i, res)\nprint(res)\n", "N,M=map(int,input().split())\nfor i in range(M//N,0,-1):\n  if M%i==0:\n    break\nprint(i)", "n, m = map(int, input().split())\nans = 1\nfor i in range(1, int(m ** 0.5) + 1):\n    if m % i == 0:\n        if i >= n:\n            ans = max(ans, m // i)\n        elif (m // i) >= n:\n            ans = max(ans, i)\nprint(ans)", "def divisor(n):\n  cd = []\n  i = 1\n  while i*i <= n:\n    if n%i==0:\n      cd.append(i)\n      if i != n//i:\n        cd.append(n//i)\n    i += 1\n  return cd\n \nN, M = map(int, input().split())\ncd = divisor(M)\ncd.sort(reverse=True)\nfor d in cd:\n  if M//d>=N:\n    print(d)\n    break", "import bisect\nN,M=list(map(int,input().split()))\ndivd=[]\ni=1\nwhile i*i<=M:\n    if M%i==0:\n        divd.append(i)\n        if i!=M//i:\n            divd.append(M//i)\n    i+=1\ndivd.sort()\nk=bisect.bisect_left(divd,N)\nprint((M//divd[k]))\n", "n,m=list(map(int,input().split()))\nans=0\nfor i in range(1,int(m**0.5)+1):\n  if m%i>0:continue\n  a=i\n  b=m//i\n  if a*n<=m:ans=max(ans,a)\n  if b*n<=m:ans=max(ans,b)\nprint(ans)\n", "N, M = map(int, input().split())\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\nans = 1\nfor i in make_divisors(M):\n    work1 = i * N\n    work2 = M - work1\n    if work2 >= 0 and work2 % i == 0:\n        ans = max(i, ans)\n# print(make_divisors(M))\nprint(ans)", "N,M=map(int,input().split())\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n  \nd = make_divisors(M)\nd = list(filter(lambda x:x<=M/N,d))\n\nprint(d[-1])", "# import itertools\n# import math\n# from functools import reduce\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nN, M = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n# def gcd_list(numbers):\n#     return reduce(math.gcd, numbers)\n\n# if gcd_list(A) > 1:\n#     print(\"not coprime\")\n#     return\n\n# \u9ad8\u901f\u7d20\u56e0\u6570\u5206\u89e3\u6e96\u5099\n#MAXN = 10**6+10\n#sieve = [i for i in range(MAXN+1)]\n#p = 2\n#while p*p <= MAXN:\n#    if sieve[p] == p:\n#        for q in range(2*p, MAXN+1, p):\n#            if sieve[q] == q:\n#                sieve[q] = p\n#    p += 1\n\nl = make_divisors(M)\n\n# print(l)\n\nthreshold = M / N\n\nfor i, d in enumerate(l):\n    if threshold < d:\n        print(l[i - 1])\n        return\n\nprint(M)", "N, M = list(map(int, input().split()))\n\n\ndef make_divisors(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n // i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\ndiv_list = make_divisors(M)\ndiv_list = div_list[::-1]\nfor div in div_list:\n    if N * div <= M:\n        print(div)\n        return\n", "#!/usr/bin/env python3\n# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left\u3000\u3053\u308c\u3067\u4e8c\u90e8\u63a2\u7d22\u306e\u5927\u5c0f\u691c\u7d22\u304c\u884c\u3048\u308b\nimport fractions #\u6700\u5c0f\u516c\u500d\u6570\u306a\u3069\u306f\u3053\u3063\u3061\nimport math\nimport sys\nimport collections\nfrom decimal import Decimal # 10\u9032\u6570\u3067\u8003\u616e\u3067\u304d\u308b\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # \u518d\u5e30\u56de\u6570\u4e0a\u9650\u306f\u3067default1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN, M = LI()\n\ndef primes(n): #\u8a66\u3057\u5272\u308a\u6cd5\u3067\u5404\u7d20\u56e0\u6570\u3068\u305d\u306e\u6307\u6570\u3092\u6c42\u3081\u308b\n    cnt=collections.defaultdict(int)\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            while n%i==0:\n                cnt[i]+=1\n                n//=i\n    if n!=1:\n        cnt[n]+=1\n    return cnt\n\n\n\"\"\"\nO(N ** 0.5)\u3067\u8a08\u7b97\u3067\u304d\u308b\u7d04\u6570\u5217\u6319\n\nN = 20\nmake_divisors(20) = [1,2,4,5,10,20]\n\"\"\"\n\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\ndivs = make_divisors(M)\n\nans = -1\nfor i, divisior in enumerate(divs):\n    if divisior > M // N:\n        break\n    else:\n        ans = divisior\n\nprint(ans)\n", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\n#import bisect\n#\n#    d = m - k[i] - k[j]\n#    if kk[bisect.bisect_right(kk,d) - 1] == d:\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\ndef readInts():\n  return list(map(int,input().split()))\ndef I():\n  return int(input())\nn,m = readInts()\ndef yaku(m):\n    ans = []\n    i = 1\n    while i*i <= m:\n        if m % i == 0:\n            j = m // i\n            ans.append(i)\n            if j != i:\n                ans.append(j)\n        i += 1\n    ans = sorted(ans)\n    return ans\nya = yaku(m)\n#print(ya)\nans = -1\nfor a in ya:\n    if a * n <= m:\n        ans = a\n    else:\n        break\nprint(ans)\n", "N,M = map(int,input().split())\ndef make_divisors(n):\n    divisors = []\n    # \u8a66\u3057\u5272\u308a\u3067\u3001\u304b\u3064\u7a4d\u3067n\u3092\u4f5c\u308b\u3068\u304d\u306e\u76f8\u65b9\u3082\u540c\u6642\u306b\u8ffd\u52a0\u3057\u3066\u308b\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort()\n    return divisors\ndiv_ls = make_divisors(M)\nans = 1\nfor div in div_ls:\n    if div*N <= M:\n        ans = max(ans,div)\nprint(ans)", "N,M = map(int,input().split())\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return sorted(lower_divisors + upper_divisors[::-1],reverse=True)\n\ndivisors = make_divisors(M)\nfor d in divisors:\n    tmp = M // d\n    if tmp >= N:\n        print(d)\n        break", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[11]:\n\n\nN,M = list(map(int, input().split()))\n\n\n# In[12]:\n\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\n# In[14]:\n\n\nfor x in make_divisors(M)[::-1]:\n    if M//x >= N:\n        ans = x\n        break\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "N, M = list(map(int, input().split()))\nans = 1\nfor i in range(1, int(M**0.5)+1):\n    if M % i == 0 and M//N >= i:\n        ans = max(ans, i)\n        if M//N >= M//i:\n            ans = max(ans, M//i)\nprint(ans)\n", "n, m = map(int, input().split())\ngcd = m//n\nwhile True:\n    if m%gcd == 0:\n        print(gcd)\n        return\n    gcd -= 1", "def make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\nN, M = list(map(int, input().split()))\n\ndivisors = make_divisors(M)\nans = 0\nfor d in divisors:\n    if N*d <= M:\n        ans = d\n\nprint(ans)\n\n", "def LI():\n    return list(map(int, input().split()))\n\n\nN, M = LI()\nx = M//N\nfor i in range(x, 0, -1):\n    if M % i != 0:\n        continue\n    ans = i\n    break\nprint(ans)", "import math\nn, m = map(int, input().split())\nfact = []\nans = 1\nMAX = int(math.sqrt(m)) + 1\nfor i in range(1, MAX):\n    if m % i == 0:\n        fact.append(i)\n        if i != m // i:\n            fact.append(m//i)\nfact.sort()\nfor x in fact:\n    if m < n * x:\n        break\n    ans = x\nprint(ans)", "N, M = list(map(int, input().split()))\n\na = M // N\nfor i in range(a, 0, -1):\n    if M % i == 0:\n        print(i)\n        break\n", "def divisor(n):\n    i = 1\n    res = []\n    for i in range(1, int(n**.5) + 1):\n        if n%i == 0:\n            res.append(i)\n            if n//i not in res:\n                res.append(n//i)\n    res.sort(reverse=True)\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    md = divisor(m)\n    ans = 0\n    for i in md:\n        if i*n <= m:\n            print(i)\n            return\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nN, M = map(int, input().split())\n\nl = []\nfor i in range(1, int(math.sqrt(M))+1):\n  if M % i == 0:\n    l.append(i)\n    if i != M//i:\n      l.append(M//i)\n      \nl.sort(reverse=True)\nfor n in l:\n  if n*N <= M:\n    ans = n\n    break\nprint(ans)", "from math import sqrt\nN, M = map(int, input().split())\n\ncand = []\n\nfor i in range(1, int(sqrt(M))+1):\n    if M % i == 0:\n        cand.append(i)\n        u = M // i\n        if u != i:\n            cand.append(u)\n\ncand.sort()\n\nans = 1\nfor j in cand:\n    if N * j <= M:\n        ans = max(ans, j)\n\nprint(ans)", "n,m = list(map(int,input().split()))\nls = []\nfor i in range(1,int(m**(1/2))+1):\n    if m % i == 0:\n        ls.append(i)\n        ls.append(m//i)\nls = sorted(list(set(ls)),reverse=True)\nfor j in ls:\n    if j*n <= m:\n        print(j)\n        break\n", "n, m = map(int, input().split())\nli = []\n#m\u306e\u7d04\u6570\u3092\u6c42\u3081\u308b\nfor i in range(int(m**0.5) + 1, 0, -1):\n    if i == int(m**0.5)+1 and (i-1)**2 == m:\n        continue\n    if m%i==0:\n        li.append(i)\n        li.append(m//i)\nli.sort(reverse=True)\n#\u5927\u304d\u3044\u9806\u306b\u516c\u7d04\u6570\u3092\u898b\u3066\u3044\u3063\u3066\u6761\u4ef6\u3092\u6e80\u305f\u305b\u3070OK\nfor i in li:\n    if n <= m//i:\n        print(i)\n        break", "from math import sqrt\ndef divisors(n):\n    divisors = []\n    for i in range(1, int(sqrt(n))+1):\n        q, r = divmod(n, i)\n        if r == 0:\n            divisors.append(i)\n            if i != q:\n                divisors.append(q)\n    divisors.sort()\n    return divisors\n\nn, m = map(int, input().split())\nans = 1\nfor a in divisors(m)[1:]:\n    if a*n <= m:\n        ans = a\nprint(ans)", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    N, M = NMI()\n    yak = set()\n    i = 1\n    while i * i <= M:\n        if M % i == 0:\n            yak.add(i)\n            yak.add(M // i)\n        i += 1\n    yak = sorted(list(yak), reverse=True)\n    for y in yak:\n        if y * N <= M:\n            print(y)\n            return\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\ndef enum_devisors(n):\n    divisors = set([])\n    for i in range(1, int(n**.5) + 1):\n        if n%i == 0:\n            divisors.add(i)\n            divisors.add(n//i)\n    return divisors\n\nn,m = list(map(int, input().split()))\ndevisors = sorted(enum_devisors(m))\nd = devisors[bisect.bisect_left(devisors, n)]\nprint(m//d)", "N,M=map(int, input().split())\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\nA=make_divisors(M)\nfor i in range(len(A)):\n  if A[i]>=N:\n    print(A[-1-i])\n    return", "import math\n\ndef main():\n\tN, M = [int(a) for a in input().split(\" \")]\n\tdivM = []\n\tfor i in range(1, int(math.sqrt(M)) + 1):\n\t\tif M % i == 0:\n\t\t\tdivM += [i, M // i]\n\tdivM.sort()\n\tdivM = list(filter(lambda m: m >= N, divM))\n\tprint(M // divM[0])\n\nmain()", "N,M=map(int,input().split())\na=1\nfor i in range(1,4*10000):\n    if M%i:\n        continue\n    if M//i>=N and i>a:\n        a=i\n    if i>=N and M//i>a:\n        a=M//i\nprint(a)", "def make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\nn,m=map(int, input().split())\nans=0\nfor i in make_divisors(m):\n  if m//i>=n:\n    ans=i\nprint(ans)", "N,M = map(int,input().split())\n\n# \u7d04\u6570\u5217\u6319\ndef enum_div(N):\n    ret = []\n    i = 1\n    while True:\n        if i**2 > N:\n            break\n        if N % i == 0:\n            ret.append(i)\n            if i**2 != N:\n                ret.append(N / i)\n        i += 1\n    return ret\n\nans = 0\nfor i in enum_div(M):\n    if i >= N:\n        ans = max(ans,M / i)\n\nprint(int(ans))", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef divisors(n):\n    lower = []\n    upper = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            lower.append(i)\n            if i != n // i:\n                upper.append(n // i)\n\n    lower.extend(reversed(upper))\n    return lower\n\n\ndef main():\n    N, M = list(map(int, readline().split()))\n\n    divisor = divisors(M)\n    for d in reversed(divisor):\n        if M // d >= N:\n            ans = d\n            break\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# author:  Taichicchi\n# created: 11.10.2020 20:56:53\n\nimport sys\n\n\ndef make_divisors(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\nN, M = list(map(int, input().split()))\n\ni = 1\nans = 1\nd_ls = make_divisors(M)\nfor i in d_ls:\n    if i * N > M:\n        break\n\n    if (M - N * i) % i == 0:\n        ans = i\n    i += 1\n\nprint(ans)\n", "N,M = map(int,input().split())\ngcd = M//N\n\nwhile gcd*N!=M:\n  gcd = M//N\n  N = 1+(M-1)//gcd\n\nprint(gcd)", "n, m = list(map(int, input().split()))\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\nl = make_divisors(m)\n\nl.reverse()\n\n\nfor x in l:\n    if m // x >= n:\n        print(x)\n        break\n", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\ndef divisor(x):\n    \"\"\"\u7d04\u6570\"\"\"\n    from math import floor\n    re = []\n    _x = floor(x ** 0.5)\n    for i in range(1, _x + 1):\n        if x % i == 0:\n            re.append(i)\n            if x // i != i:\n                re.append(x // i)\n    re.sort()\n    return re\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, M):\n    div = divisor(M)\n    div.sort()\n    ans = 0\n    for d in div:\n        if M // d >= N:\n            ans = d\n    print(ans)\n\n\ndef __starting_point():\n    # S = input()\n    # N = int(input())\n    N, M = list(map(int, input().split()))\n    # A = [int(i) for i in input().split()]\n    # B = [int(i) for i in input().split()]\n    # AB = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, M)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "n,m=map(int,input().split())\na=[]\nfor i in range(1,int(m**.5)+1):\n    if m%i==0:\n        if m//i>=n:a+=[i]\n        if i>=n:a+=[m//i]\nprint(max(a))", "def make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    # divisors.sort()\n    return divisors\n\nn, m = map(int, input().split())\nh = m // n\nans = 0\n\nfor d in make_divisors(m):\n    if d <= h:\n        ans = max(ans, d)\n\nprint(ans)", "N,M = map(int,input().split())\n\n# \u7d04\u6570\u5217\u6319\ndef enum_div(N):\n    ret = []\n    for i in range(1,int(N**0.5)+1):\n        if N % i == 0:\n            ret.append(i)\n            if i**2 != N:\n                ret.append(N // i)\n        i += 1\n    return ret\n\nans = 0\nfor i in enum_div(M):\n    if i >= N:\n        ans = max(ans,M // i)\n\nprint(int(ans))", "from math import sqrt\n\ndef f(x):\n    divisors = [[], []]\n    for i in range(1, int(sqrt(x))+1):\n        if x % i == 0:\n            divisors[0].append(i)\n            if i * i != x:\n                divisors[1].append(x//i)\n    return divisors[0] + divisors[1][::-1]\n\nn, m = map(int, input().split())\nfor i in f(m):\n    if n <= i:\n        print(m//i)\n        return", "n,m=map(int,input().split())\na=[]\nfor i in range(1,int(m**.5)+1):\n  if m%i==0:\n    ans=i\n    a.append(i)\n  if i==m//n:break\nelse:\n  for i in a:\n    if m//i<=m//n:\n      ans=m//i\n      break\nprint(ans)", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n  return int(readline())\nn,m = readInts()\ndef yaku(m):\n        ans = []\n        i = 1\n        while i*i <= m:\n            if m % i == 0:\n                j = m // i\n                ans.append(i)\n                if j != i:\n                    ans.append(j)\n            i += 1\n        ans = sorted(ans)\n        return ans\ndic = yaku(m)\nans = 1\nfor k in dic:\n    if k*n <= m:\n        ans = max(ans,k)\nprint(ans)\n", "from itertools import *\nn,m=map(int,input().split())\nM=m\na=[1]\nfor i in range(2,int(m**.5)+1):\n    while m%i==0:\n        m//=i\n        a+=[i]\nif m!=1:a+=[m]\nans=1\nfor i in range(len(a)):\n    for b in combinations_with_replacement(set(a),i):\n        c=1\n        for j in b:c*=j\n        if c>=n and M%c==0:ans=max(ans,M//c)\nprint(ans)", "n,m=map(int,input().split())\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n  \na=make_divisors(m)\n\nans=[]\n\nfor i in a:\n  if m//i>=n:\n    ans.append(i)\n    \nprint(max(ans))", "n,m = map(int,input().split())\na = m//n\ndi = []\nfor i in range(1, min(a+1,int(m**0.5)+1)):\n  if m % i == 0:\n    di.append(i)\n    if i != m // i and a >=  m // i:\n      di.append(m//i)\ndi.sort()\nprint(di[-1])", "n, m = map(int, input().split())\nans = 1\nfor i in range(1,int(m**0.5)+1):\n    if m%i: continue\n    if m//i>=n and i>ans: ans=i\n    if i>=n and m//i>=ans: ans=m//i\nprint(ans)", "n, m = list(map(int, input().split()))\n\ndivisors = []\nfor i in range(1, int(m**0.5)+1):\n    if m % i == 0:\n        divisors.append(i)\n        if i != m // i:\n            divisors.append(m // i)\ndivisors.sort()\n\nprint(([i for i in divisors if i <= m/n][-1]))\n", "n, m = list(map(int, input().split()))\nans = 0\nfor i in range(1, int(m ** 0.5) + 1):\n    if  m % i == 0 and i <= m / n:\n        if m // i <= m / n:\n            ans = m // i\n            break\n        else:\n            ans = i\n\nprint(ans)\n", "n,m=list(map(int,input().split()))\nyakusuu=[]\nfor i in range(1,int(m**0.5)+1):\n  if m%i==0:\n    yakusuu.append(m//i)\n    if m//i==i:continue\n    yakusuu.append(i)\nans=0\nfor y in yakusuu:\n  if y<n:continue\n  if m%y==0:\n    ans=max(ans,m//y)\nprint(ans)\n", "\ndef resolve():\n    def make_divisors(n):\n        divisors = []\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        divisors.sort(reverse=True)\n        return divisors\n\n    N, M = list(map(int, input().split()))\n\n    div = make_divisors(M)\n    for d in div:\n        if d <= M // N:\n            print(d)\n            break\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    N, M = list(map(int, input().strip().split()))\n    return N, M\n\n\ndef divisor(n):\n    divisors = []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.append(i)\n            if i * i != n:\n                divisors.append(n // i)\n        i += 1\n    return list(sorted(divisors))\n\n\ndef solve(N, M):\n    D = divisor(M)\n    ans = 1\n    for p in D:\n        n = M // p\n        if n >= N:\n            ans = max(ans, p)\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "\ndef resolve():\n    N, M = map(int, input().split())\n    \n    ans = 1\n    for A in range(1, int(M ** 0.5) + 1):\n        # \u7d04\u6570\u5224\u5b9a\n        if M % A != 0:\n            continue\n        B = M // A\n        if N * A <= M:\n            ans = max(ans, A)\n        if N * B <= M:\n            ans = max(ans, B)\n\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "def enum_divisors(n):\n    res = []\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            res.append(i)\n            if i != n // i:\n                res.append(n // i)\n    return res\n\n\nN, M = list(map(int, input().split()))\ndivs = sorted(enum_divisors(M), reverse=True)\nans = max(d for d in divs if M // d >= N)\nprint(ans)\n", "n, m = list(map(int, input().split()))\n\ndivisors = []\nfor i in range(1, int(m**0.5)+1):\n    if m % i == 0:\n        divisors.append(i)\n        if i != m // i:\n            divisors.append(m // i)\ndivisors.sort()\n\nprint(([i for i in divisors if i <= m/n][-1]))\n", "n,m = map(int, input().split())\n\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n%i == 0:\n      divisors.append(i)\n      if i != n//i:\n        divisors.append(n//i)\n  divisors.sort(reverse=True)\n  return divisors\n\nnumbers = make_divisors(m)\nfor i in range(len(numbers)):\n  if numbers[i] <= m/n:\n    print(numbers[i])\n    break", "from math import sqrt\nn, m = list(map(int, input().split()))\nans = 1\nfor i in range(1, int(sqrt(m) + 2)):\n    if m % i == 0:\n        if i <= m / n:\n            ans = max(ans, i)\n        if m // i <= m / n:\n            ans = max(ans, m // i)\n            \nprint(ans)\n", "k, s = list(map(int, input().split()))\n\np = s\nfactors = {}\n\nwhile p > 1:\n    f = False\n    for i in range(2, int(p**0.5)+1):\n        if p % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n\n            p //= i\n            f = True\n            break\n\n    if not f:\n        if p in factors:\n            factors[p] += 1\n        else:\n            factors[p] = 1\n        break\n\nif len(factors) == 0:\n    print(1)\nelse:\n    primes = list(factors.keys())\n    exp = [0] * len(primes)\n    upper = s/k\n    ans = 1\n\n    while exp[0] <= factors[primes[0]]:\n        num = 1\n        for i in range(len(primes)):\n            num *= pow(primes[i], exp[i])\n\n        if num == upper:\n            ans = num\n            break\n        elif num < upper:\n            ans = max(ans, num)\n\n        index = len(primes)-1\n        done = False\n        while not done:\n            exp[index] += 1\n            if exp[index] > factors[primes[index]]:\n                if index == 0:\n                    break\n                else:\n                    exp[index] = 0\n                    index -= 1\n            else:\n                done = True\n\n    print(ans)", "from math import sqrt\nfrom math import floor\nn,m = map(int,input().split())\nd = m // n\nans = 1\nfor i in range(1,floor(sqrt(m))+1):\n    if m % i == 0:\n        x = m // i\n        if i <= d:\n            ans = max(ans,i)\n        if x <= d:\n            ans = max(ans,x)\nprint(ans)", "import sys\nimport math\n\nN, M = map(int, sys.stdin.readline().split())\n\nans = 0\nfor i in range(1, int(M**0.5)+1):\n    if M % i == 0:\n        j = M // i\n        r1 = j // N\n        r2 = j % N\n        # print(i, j, r1, r2, math.gcd(r1, r2))\n        ans = max(ans, min(r1, math.gcd(r1, r2)) * i)\n        r1 = i // N\n        r2 = i % N\n        # print(i, j, r1, r2, math.gcd(r1, r2))\n        ans = max(ans, min(r1, math.gcd(r1, r2)) * j)\n\nprint(ans)", "def divisor(n):\n    i = 1\n    res = set()\n    for i in range(1, int(n**.5) + 1):\n        if n%i == 0:\n            res.add(i)\n            res.add(n//i)\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    md = list(divisor(m))\n    md.sort(reverse=True)\n    for i in md:\n        if i*n <= m:\n            print(i)\n            return\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m = map(int, input().split())\n\nx = m //n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\ny = make_divisors(m)\n\nres = 1\n\nfor i in y:\n    if i <=x:\n        res = i\n        \nprint(res)", "N,M = map(int,input().split())\n\nm = 1\nds = set()\nwhile m*m <= M:\n    if M%m==0:\n        ds.add(m)\n        ds.add(M//m)\n    m += 1\n\nans = 1\nfor d in ds:\n    if d*N > M: continue\n    ans = max(ans,d)\nprint(ans)"]
["#python3\n# utf-8\n\nnodes_nr, edges_nr = (int(x) for x in input().split())\nnode_idx___cost = [int(x) for x in input().split()]\nnode_idx___neigh_idxes = [[] for x in range(nodes_nr)]\nfor _ in range(edges_nr):\n    node1_idx, node2_idx = (int(x) - 1 for x in input().split())\n    node_idx___neigh_idxes[node1_idx].append(node2_idx)\n    node_idx___neigh_idxes[node2_idx].append(node1_idx)\n\nnode_idx___is_visited = [False for x in range(nodes_nr)]\n\nans = 0\nfor node_idx in range(nodes_nr):\n    if node_idx___is_visited[node_idx]:\n        continue\n    stack = [node_idx]\n    node_idx___is_visited[node_idx] = True\n    cheapest_cost = node_idx___cost[node_idx]\n    while stack:\n        curr_node_idx = stack.pop()\n        for neigh_idx in node_idx___neigh_idxes[curr_node_idx]:\n            if node_idx___is_visited[neigh_idx]:\n                continue\n            stack.append(neigh_idx)\n            cheapest_cost = min(cheapest_cost, node_idx___cost[neigh_idx])\n            node_idx___is_visited[neigh_idx] = True\n    ans += cheapest_cost\nprint(ans)\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2017/11/23 23:13\n\n\"\"\"\n\nN, M = list(map(int, input().split()))\ncost = [0] + [int(x) for x in input().split()]\n#\n# N, M = random.randint(1, 10**5), random.randint(0, 10**5)\n# cost = [0] + [random.randint(0, 10**9) for _ in range(N)]\n\nG = collections.defaultdict(list)\n\nfor i in range(M):\n    a, b = list(map(int, input().split()))\n    # a, b = random.randint(1, N), random.randint(1, N)\n    G[a].append(b)\n    G[b].append(a)\n\n\ngroup = [0] * (N+1)\ngi = 1\n\n# def dfs(u, fa, gi):\n#     group[u] = gi\n#     for v in G[u]:\n#         if v != fa and group[v] == 0:\n#             dfs(v, u, gi)\n\ndef makeGroup(u, gi):\n    q = [u]\n    while q:\n        u = q.pop()\n        group[u] = gi\n        for v in G[u]:\n            if group[v] == 0:\n                q.append(v)\n\n\nfor i in range(1, N+1):\n    if not group[i]:\n        gi += 1\n        makeGroup(i, gi)\n\nfor i in range(1, N+1):\n    if group[i] == 0:\n        gi += 1\n        group[i] = gi\n\nminCost = {}\nfor i in range(1, N+1):\n    g = group[i]\n    c = cost[i]\n    if g not in minCost:\n        minCost[g] = c\n    else:\n        minCost[g] = min(minCost[g], c)\n\nprint(sum(list(minCost.values()) or [0]))\n\n\n", "\nfrom collections import deque\n\nstart = list(map(int, (input().strip().split())))\ncost = list(map(int, (input().strip().split())))\ndp = dict()\nfor _ in range(start[1]):\n    k = list(map(int, (input().strip().split())))\n    if k[0] - 1 not in dp:\n        dp[k[0] - 1] = dict()\n    if k[1] - 1 not in dp:\n        dp[k[1] - 1] = dict()\n    dp[k[0] - 1][k[1] - 1] = 0\n    dp[k[1] - 1][k[0] - 1] = 0\n\ncounted = dict()\nanswer = 0\nfor index, value in enumerate(cost):\n    if index not in dp:\n        answer += value\n    elif index in counted:\n        continue\n    else:\n        now = index\n        plus = value\n        counted[index] = 0\n        dec = deque()\n        for key in dp[now]:\n            dec.append(key)\n        while len(dec) > 0:\n            k = dec.popleft()\n            if k in counted:\n                continue\n            plus = min(plus, cost[k])\n            counted[k] = 0\n            if k in dp:\n                for key in dp[k]:\n                    dec.append(key)\n        answer += plus\nprint(answer)", "def bfs(i):\n    nonlocal p, f, v\n\n    q = [i]\n    qi = 0\n    \n    v[i] = 1\n  \n    best = p[i]\n\n    while qi < len(q):\n        j = q[qi]\n        if p[j] < best:\n            best = p[j]\n        for k in f[j]:\n            if v[k] != 1:\n                q.append(k)\n                v[k] = 1\n        qi += 1\n\n    return best\n\nn, m = [int(i) for i in input().split(\" \")]\n\np = [int(i) for i in input().split(\" \")]\nv = [0]*n\nf = {}\n\nfor a in range(n):\n    f[a] = []\n\nfor a in range(m):\n    x, y = [int(i) for i in input().split(\" \")]\n    f[x-1].append(y-1)\n    f[y-1].append(x-1)\n\ncost = 0\nfor i in range(n):\n    if v[i] == 0:\n        cost += bfs(i)\n\nprint(cost)\n\n\n", "from collections import defaultdict\n\nclass Graph(object):\n\tdef __init__(self, connections, directed=False):\n\t\tself._graph = defaultdict(set)\n\t\tself._directed = directed\n\t\tself.add_connections(connections)\n\n\tdef add_connections(self, connections):\n\t\tfor node1, node2 in connections:\n\t\t\tself.add(node1, node2)\n\n\tdef add(self, node1, node2):\n\t\tself._graph[node1].add(node2)\n\t\tif not self._directed:\n\t\t\tself._graph[node2].add(node1)\n\n\tdef __str__(self):\n\t\treturn '{}({})'.format(self.__class__.__name__, dict(self._graph))\n\t\n\tdef __getitem__(self, index):\n\t\treturn self._graph[index]\n\ndef bfs(graph, start):\n    visited, queue = set(), [start]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n    return visited\n    \nn, m = list(map(int, input().split()))\ng = list(map(int, input().split()))\nf = [list(map(int, input().split()))for _ in range(m)]\nv = Graph(f)\nfg = []\nvi = [False]*n\nfor i in range(0, n):\n\tif vi[i]:\n\t\tcontinue\n\tcc = bfs(v, i+1)\n\tfor e in cc:\n\t\tvi[e-1] = True\n\tfg.append(cc)\nprint(sum(min(g[e-1] for e in _g) for _g in fg))\n\n", "def dfs(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(graph[vertex] - visited)\n    return visited, min([prices[v] for v in visited])\n\n\nn, m = list(map(int, input().split()))\nprices = [0] + list(map(int, input().split()))\nfriendship = {x: set() for x in range(1, n+1)}\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    friendship[x].add(y)\n    friendship[y].add(x)\n# print(friendship)\ncitizens = set(range(1, n+1))\nans = 0\nwhile citizens:\n    v = citizens.pop()\n    visited, p = dfs(friendship, v)\n    citizens.difference_update(visited)\n    ans += p\nprint(ans)\n\n", "from collections import deque\n\nn,m=list(map(int,input().split()))\nc=list(map(int,input().split()))\nadj=[[] for _ in range(100000)]\nfor _ in range(m):\n    x,y=list(map(int,input().split()))\n    x-=1\n    y-=1\n    adj[x].append(y)\n    adj[y].append(x)\nans=0\nused=[False]*n\nfor i in range(n):\n    if used[i]:\n        continue\n    s=[c[i]]\n    used[i]=True\n    q=deque([])\n    q.append(i)\n    while len(q)>0:\n        u=q.popleft()\n        for j in range(len(adj[u])):\n            v=adj[u][j]\n            if not used[v]:\n                used[v]=True\n                s.append(c[v])\n                q.append(v)\n    ans+=min(s)\nprint(ans)\n", "n, m = list(map(int, input().split()))\nvs = list(map(int, input().split()))\nif m == 0:\n    print(sum(vs))\n    return\n# n = 100000\n# m = n - 1\n# vs = [0] * n\nes = {i: [] for i in range(n)}\nvisited = {i: False for i in range(n)}\ncomps = []\n\n\n# def dfs(vv, compp):\n#     # nonlocal visited, es\n#     if visited[vv]:\n#         return\n#     visited[vv] = True\n#     compp.append(vv)\n#     neighs = es[vv]\n#     for neigh in neighs:\n#         if visited[neigh] or neigh == vv:\n#             continue\n#         dfs(neigh, compp)\n\n\nfor i in range(m):\n    f, t = list(map(int, input().split()))\n    # f, t = i + 1, i + 2\n    es[f-1].append(t-1)\n    es[t-1].append(f-1)\n\nfor v in range(n):\n    if visited[v]:\n        continue\n    comp = []\n    deque = [v]\n    while deque:\n        v_temp = deque.pop(0)\n        if visited[v_temp]:\n            continue\n        visited[v_temp] = True\n        comp.append(v_temp)\n        for neigh in es[v_temp]:\n            if visited[neigh] or neigh == v_temp:\n                continue\n            deque.append(neigh)\n    comps.append(comp)\n# print(es)\nres = 0\nfor comp in comps:\n    if not comp:\n        continue\n    res += min(vs[i] for i in comp)\n\nprint(res)\n", "\nfrom collections import deque\n\nclass Person:\n    def __init__(self):\n        self.friends = []\n        self.taken = False\n        self.price = 0\n\ndef fill(person):\n    queue = deque([])\n    queue.append(person)\n    minimum = person.price\n\n    while queue:\n        p = queue.popleft()\n        p.taken = True\n        minimum = min(minimum, p.price)\n        for f in p.friends:\n            if not f.taken:\n                queue.append(f)\n    return minimum\n\n\nN, M = map(int, input().split())\n\npeople = [Person() for _ in range(0, N)]\n\nprices = list(map(int, input().split()))\nfor i in range(0, N):\n    people[i].price = prices[i]\n\nfor _ in range(0, M):\n    u, v = map(int, input().split())\n    people[u-1].friends.append(people[v-1])\n    people[v-1].friends.append(people[u-1])\n\ncost = 0\nfor p in people:\n    if not p.taken:\n        cost += fill(p)\n\nprint(cost)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Nov 19 07:28:11 2017\n\n@author: fei\n\"\"\"\nn, m = [int(i) for i in input().split(' ')]\nc = [int(i) for i in input().split(' ')]\nchars = [[] for _ in range(n)]\nfor _ in range(m):\n    p, q = [int(i) for i in input().split(' ')]\n    p = p - 1\n    q = q - 1\n    chars[p].append(q)\n    chars[q].append(p)\n\ndef dfs(i, nodes):\n    if Visited[i]:\n        return\n    Visited[i] = True\n    nodes.append(i)\n    for j in chars[i]:\n        dfs(j, nodes)\n\nVisited = [False for i in range(n)]\nGraph = []\nC = 0\nfor i in range(n):\n    if not Visited[i]:\n        nodes = []\n        nodes.append(i)\n        tmp = 10000000000\n        while len(nodes) > 0:\n            u = nodes.pop()\n            if Visited[u] == False:\n                Visited[u] = True\n                tmp = min(tmp, c[u])\n                for j in chars[u]:\n                    nodes.append(j)\n        C += tmp\n        Graph.append(nodes)\n\nprint(C)", "import threading, sys\nsys.setrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    c = [int(x) for x in input().split()]\n    graph = {int(x) + 1:[] for x in range(n)}\n    \n    for i in range(m):\n        ff, sf = [int(x) for x in input().split()]\n        graph[ff].append(sf)\n        graph[sf].append(ff)\n        \n    comps = {}\n    cl = [-1] * n\n    \n    def dfs(v, c, p):\n        cl[v - 1] = c\n        if c not in comps:\n            comps[c] = []\n        comps[c].append(v)\n        for i in graph[v]:\n            if i != p:\n                if cl[i - 1] == -1:\n                    dfs(i, c, v)\n    \n    cc = 1\n    for i in range(n):\n        if cl[i] == -1:\n            dfs(i + 1, cc, -1)\n            cc += 1\n            \n    price = 0\n    \n    for i in comps:\n        minp = 999999999999999\n        for j in comps[i]:\n            minp = min(c[j - 1], minp)\n        price += minp\n    print(price)\n    \nthread = threading.Thread(target=main)\nthread.start()", "from sys import setrecursionlimit\nimport threading\nsetrecursionlimit(10 ** 9)\nthreading.stack_size(67108864)\n\ndef main():\n    def dfs(v,cv):\n        color[v]=cv\n        for u in d[v]:\n            if color[u]==0:\n                dfs(u,cv)\n\n    n,m=map(int,input().split())\n    c=list(map(int,input().split()))\n    d={x:[] for x in range(n+1)}\n    for i in range(m):\n        x,y=map(int,input().split())\n        d[x].append(y)\n        d[y].append(x)\n    color=[0]*(n+1)\n    cv=1\n    for i in range(1,n+1):\n        if color[i]==0:\n            dfs(i,cv)\n            cv+=1\n    s={}\n    for i in range(1,n+1):\n        if color[i] in s:\n            s[color[i]].append(c[i-1])\n        else:\n            s[color[i]]=[c[i-1]]\n    x=0\n    for i in s:\n        x+=min(s[i])\n    print(x)\nthread = threading.Thread(target=main)\nthread.start()", "from collections import defaultdict as dd\ng=dd(list)\ndef addE(u,v):\n\tg[u].append(v)\n\tg[v].append(u)\n\ndef dfs(v):\n\tstck=[]\n\tstck.append(v)\n\tcost1=cost[v-1]\n\tvisited[v]=True\n\twhile len(stck)!=0:\n\t\tcur=stck.pop()\n\t\tfor ch in g[cur]:\n\t\t\tif visited[ch]:\n\t\t\t\tcontinue\n\t\t\tcost1=min(cost1,cost[ch-1])\n\t\t\tstck.append(ch)\n\t\t\tvisited[ch]=True\n\treturn cost1\n\n\n\nn,m=list(map(int,input().split()))\ncost=[int(x) for x in input().split()]\nvisited=[False]*(n+1)\nfor i in range(m):\n\tu,v=list(map(int,input().split()))\n\taddE(u,v)\nans=0\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tans+=dfs(i)\n\t\n\nfor i in range(1,n+1):\n\tif not visited[i]:\n\t\tans+=cost[i-1]\nprint(ans)\n", "import sys, threading\nsys.setrecursionlimit(100010)\nthreading.stack_size(67108864)\n\nres = 0\n\ndef main():\n    n,m=list(map(int,input().split()))\n    c=[int(c) for c in input().split()]\n    g={}\n    \n    \n    flag=[0 for i in range(n) ]\n    \n     \n    for i in range(n):\n        g[i]=[]\n        \n    for i in range(m):\n        p,o=list(map(int ,input().split()))\n        o-=1\n        p-=1\n        g[o].append(p)\n        g[p].append(o)\n        \n    def glu(v,p,k):\n        nonlocal res\n        if flag[v]==0:\n            flag[v]=k\n            for i in g[v]:\n                if i!=p:\n                    glu(i,v,k)\n    k=1\n    for i in range(n):\n        l=flag[i]\n        glu(i,-1,k)\n        if l==0:\n            k+=1\n    mn={}\n    for i in range(max(flag)):\n        mn[i]=10**9 \n    for i in range(n):\n        if mn[flag[i]-1]>=c[i]:\n            mn[flag[i]-1]=c[i]\n    su=0\n    for i in range(len(mn)):\n            su+=mn[i]    \n    print(su)    \n    \n    \n\nthread = threading.Thread(target=main)\nthread.start()\n", "import sys, threading\nsys.setrecursionlimit(100010)\nthreading.stack_size(67108864)\n#sys.stdin=open(\"input.txt\",\"r\")\n\n\ndef main():\n    n,m=list(map(int,input().split()))\n    c=list(map(int,input().split()))\n    edge=[[] for i in range(n)]\n    for i in range(m):\n        u,v=list(map(int,input().split()))\n        u-=1\n        v-=1\n        edge[u].append(v)\n        edge[v].append(u)\n    flag=[0]*n\n\n    def dfs(u,k):\n        flag[u]=k;\n        for v in edge[u]:\n            if(flag[v]==0):\n                dfs(v,k)\n\n    cnt = 0\n    for u in range(n):\n        if(flag[u]==0):\n            cnt+=1\n            dfs(u,cnt)\n\n    mn=[0x3f3f3f3f]*(cnt+1)\n\n    for u in range(n):\n        mn[flag[u]]=min(mn[flag[u]],c[u])\n\n    print(sum(mn[1:]))\n\nthread=threading.Thread(target=main)\nthread.start()\n\n\n", "from collections import defaultdict\nmerge_matrix = defaultdict(list)\nn, m = list(map(int, input().split()))\nprice_list = [int(x) for x in input().split()]\nsummary = 0\nvisited = set()\n\n\ndef dfs(edge):\n    queue = []\n    visited.add(edge)\n    queue.append(edge)\n    lowest_cost = price_list[edge-1]\n    while len(queue) > 0:\n        cur_edge = queue.pop()\n        for i in merge_matrix[cur_edge]:\n            if i not in visited:\n                lowest_cost = min(lowest_cost, price_list[i - 1])\n                queue.append(i)\n                visited.add(i)\n    return lowest_cost\n\n\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    merge_matrix[x].append(y)\n    merge_matrix[y].append(x)\nfor i in range(1, n+1):\n    if i not in visited:\n        summary += dfs(i)\nfor i in range(1, n+1):\n    if i not in visited:\n        summary += price_list[i-1]\nprint(summary)\n", "R=lambda:list(map(int,input().split()))\nn,m=R()\np=[i for i in range(n+1)]\n\ndef find(i):\n    while p[i] != i:\n        p[i] = p[p[i]]\n        i = p[i]\n    return i\n    \nc=[0]+list(R())\nfor _ in range(m):\n    x,y=list(map(find,R()))\n    if c[x]<c[y]:\n        x,y=y,x\n    p[x]=y\nprint(sum(c[i] for i in range(n+1) if p[i]==i))\n", "n, m = map(int, input().split())\nc = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a,b = map(int, input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\nvs = [False for i in range(n)]\nans = 0\nfor i in range(n):\n    if vs[i]:\n        continue\n    q = [i]\n    vs[i] = True\n    m = c[i]\n    while len(q) > 0:\n        v = q[0]\n        del q[0]\n        for u in g[v]:\n            if not vs[u]:\n                vs[u] = True\n                q.append(u)\n                m = min(m, c[u])\n    ans += m\n    \nprint(ans)", "def get():\n\treturn list(map(int, input().split()))\n\ndef dfs(i):\n\tv = c[i]\n\tq = [i]\n\twhile q:\n\t\tj = q.pop()\n\t\tb[j] = 1\n\t\tv = min(v, c[j])\n\t\tfor k in a[j]:\n\t\t\tif b[k] == 0:\n\t\t\t\tq.append(k)\n\treturn v\n\t\nn, m = get()\nc = get()\na = [list() for _ in range(n)]\nfor _ in range(m):\n\tx, y = get()\n\ta[x-1].append(y-1)\n\ta[y-1].append(x-1)\n\nb = [0] * n\nans = 0\nfor i in range(n):\n\tif b[i] == 0:\n\t\tans += dfs(i)\n\nprint(ans)", "from collections import deque\n\n\ndef dfs(n):\n    \"\"\"\n    Traverse graph using DFS\n    @return: minimum gold value of connected group\n    \"\"\"\n    nonlocal visited\n    minimum = -1\n    queue = deque([n])\n    while queue:\n        node = queue.popleft()\n        visited[node] = True\n        if minimum == -1:\n            minimum = gold[node]\n        else:\n            minimum = min(minimum, gold[node])\n        for neighbor in adj_list[node]:\n            if not visited[neighbor - 1]:\n                queue.append(neighbor - 1)\n    return minimum\n\n\nn, m = list(map(int, input().split()))\ngold = list(map(int, input().split()))\nadj_list = [list() for _ in range(n)]\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    adj_list[x - 1].append(y)\n    adj_list[y - 1].append(x)\nvisited = [False for _ in range(n)]\ntotal = 0\nfor i in range(n):\n    if not visited[i]:\n        total += dfs(i)\nprint(total)\n", "n, m = list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\nfa = [0] + [i + 1 for i in range(n)]\n\ndef findFa(x):\n    s = []\n    while fa[x] != x:\n        s.append(x)\n        x = fa[x]\n    for v in s:\n        fa[v] = x\n    return x\n\nwhile m:\n    u, v = list(map(int, input().split()))\n    u = findFa(u)\n    v = findFa(v)\n    if u != v:\n        fa[v] = u\n        a[u] = min(a[u], a[v])\n    m -= 1\nres = 0\nfor i in range(1, n + 1):\n    if findFa(i) == i:\n        res += a[fa[i]]\nprint(res)\n\n", "def dfs(graph, start):\n    visited, stack = set(), [start]\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            stack.extend(graph[vertex] - visited)\n    return visited, min([prices[v] for v in visited])\n\n\nn, m = list(map(int, input().split())); ans = 0\nprices = [None] + list(map(int, input().split()))\nfriendship = {x: set() for x in range(1, n+1)}\n\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    friendship[x].add(y)\n    friendship[y].add(x)\ncitizens = set(range(1, n+1))\n\nwhile citizens:\n    v = citizens.pop()\n    visited, p = dfs(friendship, v)\n    citizens.difference_update(visited)\n    ans += p\nprint(ans)\n"]
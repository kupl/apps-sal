["ans = 1000000000\nn, k = [int(i) for i in input().split()]\ns = input()\nl = len(s)\nd = [k // 2, (k + 1) // 2]\nnearl = [0] * n\nnearr = [0] * n\nlast = 1000000000\nfor i in range(n):\n    if s[i] == '0':\n        last = i\n    nearl[i] = last\nfor i in range(n - 1, -1, -1):\n    if s[i] == '0':\n        last = i\n    nearr[i] = last\nfor i in d:\n    itl = 0\n    nf = 0\n    itr = 0\n    while s[itl] == '1':\n        itl += 1\n    cnt = 0\n    nf = itl\n    while cnt < i:\n        cnt += 1\n        nf += 1\n        while s[nf] == '1':\n            nf += 1\n    cnt = 0\n    itr = nf\n    while cnt < k - i:\n        cnt += 1\n        itr += 1\n        while s[itr] == '1':\n            itr += 1\n    while True:\n        pos = (itr + itl) // 2\n        pos1 = nearl[pos]\n        ans = min(ans, max(pos1 - itl, itr - pos1))\n        pos1 = nearr[pos]\n        ans = min(ans, max(pos1 - itl, itr - pos1))\n        itr += 1\n        while itr < l and s[itr] == '1':\n            itr += 1\n        if itr == l:\n            break\n        itl += 1\n        while s[itl] == '1':\n            itl += 1\nprint(ans)", "n, k = list(map(int, input().split()))\ns = input()\nprefixes = [0]\nfor i in range(n):\n    prefixes.append(prefixes[i] + ((int(s[i])) + 1) % 2)\na = n\nfor i in range(n):\n    if s[i] == '0':\n        left = 0\n        right = n\n        while(right - left > 1):\n            middle = (right + left) // 2\n            if prefixes[min(n, 1 + i + middle)] - prefixes[max(0, i - middle)] > k:\n                right = middle\n            else:\n                left = middle\n        a = min(a, right)\nprint(a)", "n, k = map(int, input().split())\nrooms = input()\ncount = [0] * (n + 1)\nfor i in range(n):\n    count[i] = count[i - 1]\n    if rooms[i] == '0':\n        count[i] += 1\n\nans = float('inf')\nfor i in range(n):\n    l = 0\n    r = n\n    while l + 1 < r:\n        m = (r + l) // 2\n        if rooms[i] == '0' and (count[min(i + m, n - 1)] - count[max(-1, i - m - 1)]) > k:\n            r = m\n        else:\n            l = m\n    ans = min(r, ans)\nprint(ans)", "n, k = map(int, input().split())\nrooms = input()\ncount = [0] * (n + 1)\nfor i in range(n):\n    count[i] = count[i - 1]\n    if rooms[i] == '0':\n        count[i] += 1\n\nans = float('inf')\nfor i in range(n):\n    if rooms[i] != '0':\n        continue\n    l = 0\n    r = max(n - 1 - i, i)\n    while l + 1 < r:\n        m = (r + l) // 2\n        if count[min(i + m, n - 1)] - count[max(-1, i - m - 1)] > k:\n            r = m\n        else:\n            l = m\n    ans = min(r, ans)\nprint(ans)", "from collections import deque\nrooms_number, cows_number = list(map(int, input().split()))\nrooms = input()\nfree_rooms = [i for i in range(rooms_number) if rooms[i] == '0']\ndef binary_search(left, right, item):\n    nonlocal free_rooms\n    while right - left > 1:\n        center = left + (right - left)//2\n        if free_rooms[center] > item:\n            right = center\n        else:\n            left = center\n    return left\nmin_distation_to_farthest_cow = 10**20\nbest_min_distation_to_farthest_cow = cows_number//2 + cows_number%2\nfor i in range(len(free_rooms) - cows_number):\n    left = free_rooms[i]\n    right = free_rooms[i + cows_number]\n    center = left + (right - left)//2\n    j = binary_search(i, i + cows_number, center)\n    if free_rooms[j] == center:\n        distation_to_farthest_cow = right - center\n    else:\n        distation_to_farthest_cow = min(right - free_rooms[j], free_rooms[j + 1] - left)\n    if min_distation_to_farthest_cow > distation_to_farthest_cow:\n        min_distation_to_farthest_cow = distation_to_farthest_cow\n    if distation_to_farthest_cow == best_min_distation_to_farthest_cow:\n        break\nprint(min_distation_to_farthest_cow)\n", "def main():\n    from bisect import bisect\n    n, k = list(map(int, input().split()))\n    l = [i for i, c in enumerate(input()) if c == \"0\"]\n    l.append(n * 3)\n    for i, j in enumerate(range(k, len(l) - 1)):\n        lo, hi = l[i], l[j]\n        m = bisect(l, (lo + hi) // 2)\n        mid = l[m]\n        a, b = mid - lo, hi - mid\n        if a < b:\n            a = b\n        mid = l[m - 1]\n        b, c = mid - lo, hi - mid\n        if b < c:\n            b = c\n        if a > b:\n            a = b\n        if n > a:\n            n = a\n    print(n)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = [int(_) for _ in input().split()]\na = input()\n\n\ndef next_free(x):\n    x += 1\n    while x < n and a[x] == '1':\n        x += 1\n    return x\n\n\nl = next_free(-1)\nr = -1\n\n\nk += 1\nfor _ in range(k):\n    r = next_free(r)\ni = l\ndis = max(i-l, r-i)\nnext_i = next_free(i)\nwhile True:\n    cur_dis = max(i-l, r-i)\n    next_dis = max(next_i - l, r - next_i)\n\n    if cur_dis <= next_dis:\n        break\n    i = next_i\n    dis = min(dis, next_dis)\n    next_i = next_free(i)\n\n\nwhile True:\n    r = next_free(r)\n    if r >= n:\n        break\n    l = next_free(l)\n    if i < l:\n        i = l\n    prev_dis = max(i-l, r-i)\n    dis = min(dis, prev_dis)\n    m = next_free(i)\n    while m <= r:\n        cur_dis = max(m-l, r-m)\n        if cur_dis >= prev_dis:\n            break\n        prev_dis = cur_dis\n        i = m\n        dis = min(dis, cur_dis)\n        m = next_free(m)\n\nprint(dis)\n\n\n# binary search the ANSWER!!\n# choose an answer and check if it works\n# array [i] keeps track of how many zeros are before it\n", "n, k = [int(_) for _ in input().split()]\na = input()\n\nk += 1\n# size of n+1\nf = [0] * (n+1)\n\nf[1] = int(a[0] == '0')\nfor i in range(2, n+1):\n    f[i] = f[i-1] + int(a[i-1] == '0')\n\n# print(f)\n\n\ndef check(dis):\n    for i in range(n):\n        if a[i] == '0':\n            left = max(i-dis, 0)\n            right = min(i+dis, n-1)\n            total = f[right+1] - f[left]\n            # print(total)\n            if total >= k:\n                return True\n    return False\n\n\nl = 1\nr = n - 1\nwhile l < r:\n    mid = (l + r) // 2\n    # print(mid)\n    if check(mid):\n        # print(True)\n        r = mid\n    else:\n        # print(False)\n        l = mid + 1\nprint(l)\n\n\n# binary search the ANSWER!!\n# choose an answer and check if it works\n# array [i] keeps track of how many zeros are before it\n", "n, k = map(int, input().split())\nt = [i for i, v in enumerate(input()) if v == '0']\ns, i = n, 0\na, b = t[:2]\nfor l, r in zip(t, t[k:]):\n    while max(r - a, a - l) > max(r - b, b - l): \n        i += 1\n        a, b = t[i:i + 2]\n    s = min(s, max(r - a, a - l))\nprint(s)", "n, k = map(int, input().split())\nt = [i for i, v in enumerate(input()) if v == '0']\ns, m = n, 0\nf = lambda m: max(r - t[m], t[m] - l)\nfor l, r in zip(t, t[k:]):\n    while f(m) > f(m + 1): m += 1\n    s = min(s, f(m))\nprint(s)", "n, k = list(map(int, input().split()))\nt = [i for i, v in enumerate(input()) if v == '0']\ns, m = n, 0\nf = lambda m: max(r - t[m], t[m] - l)\nfor l, r in zip(t, t[k:]):\n    while f(m) > f(m + 1): m += 1\n    s = min(s, f(m))\nprint(s)\n", "\ndef main():\n    n,k = list(map(int, input().split()))\n    cowLocations = input()\n    #n,k = 7,2\n    #cowLocations = \"0100100\"\n    whereIsCow = []\n    for i in range(len(cowLocations)):\n        if cowLocations[i] == '0':\n            whereIsCow.append(i)\n    i = 0\n    j = k\n    fJohn = 0\n    wic = len(whereIsCow)\n    #print(whereIsCow)\n    smallest = 1000000\n    while i < wic and j < wic and fJohn < wic:\n        maxDist = max(whereIsCow[j]-whereIsCow[fJohn],\n                                   whereIsCow[fJohn]-whereIsCow[i])\n        #print(maxDist)\n        while fJohn <= j and max(whereIsCow[j]-whereIsCow[fJohn+1],\n                                   whereIsCow[fJohn+1]-whereIsCow[i]) < maxDist:\n            fJohn += 1\n            maxDist = max(whereIsCow[j]-whereIsCow[fJohn],\n                                   whereIsCow[fJohn]-whereIsCow[i])\n        if maxDist < smallest:\n            smallest = maxDist\n        j += 1\n        i += 1\n    print(smallest)\n\ndef __starting_point():\n    main()\n    \n\n\n__starting_point()", "n, k = list(map(int, input().split()))\n\nt = [i for i, v in enumerate(input()) if v == '0']\n\ns, m = n, 0\n\nf = lambda m: max(r - t[m], t[m] - l)\n\nfor l, r in zip(t, t[k:]):\n\n    while f(m) > f(m + 1): m += 1\n\n    s = min(s, f(m))\n\nprint(s)\n\n\n\n\n# Made By Mostafa_Khaled\n", "res = 1e9\ndef next(i):\n    i+=1\n    while(i < n and s[i] == '1'):\n        i+=1\n    return i\n\nn,k = list(map(int, input().split()))\ns = input()\nl = next(-1)\nm = l\nr = l\nfor i in range(k):\n    r = next(r)\n  \nwhile(r < n):\n    while(max(m - l, r - m) > max(next(m) - l, r - next(m))):\n        m = next(m)\n    res = min(res, max(m - l, r - m))\n    l = next(l)\n    r = next(r)\nprint(res)\n", "[n, k] = [int(x) for x in input().split()]\n\nroom_free = [bool(1-int(x)) for x in input()]\n\n# maintain queue closest before\n# maintain queue of closest after\n\n# maintain two pointers (l, r)\n# if l == 0 check\n\nclosest_before = []\nclosest_after = []\n\n# note, he needs k+1 rooms\n\nbefore = -1\nfor i in range(n):\n    if room_free[i]:\n        before = i\n    closest_before.append(before)\n\nafter = 11**8\nfor i in range(n-1, -1, -1):\n    if room_free[i]:\n        after = i\n    closest_after.append(after)\nclosest_after.reverse()\n\n\nl = -1\nr = -1\ntaken = 0\nans = 10**8\n\n\nwhile True:\n    if taken != k+1:\n        r += 1\n        if r >= n:\n            break\n        if room_free[r]:\n            taken += 1\n    else:\n        l += 1\n        if room_free[l]:\n\n            mid = int((l+r)/2)\n            # print(l, r, mid, closest_after[mid])\n            ans = min(ans, closest_after[mid+1] - l, r - closest_before[mid])\n            taken -= 1\nprint(ans)\n\n", "import sys\ninput = sys.stdin.readline\n\ndef judge(i, x):\n    return acc[min(n, i+x+1)]-acc[max(0, i-x)]>=k+1\n\ndef binary_search(i):\n    l, r = 0, n\n    \n    while l<=r:\n        mid = (l+r)//2\n        \n        if judge(i, mid):\n            r = mid-1\n        else:\n            l = mid+1\n    \n    return l\n\nn, k = map(int, input().split())\nS = input()[:-1]\nacc = [0]\n\nfor Si in S:\n    acc.append(acc[-1]+(1 if Si=='0' else 0))\n\nans = n\n\nfor i in range(n):\n    if S[i]=='0':\n        ans = min(ans, binary_search(i))\n\nprint(ans)", "n, k = [int(_) for _ in input().split()]\na = input()\nk += 1\n# size of n+1\nf = [0] * (n+1)\n \nf[1]=int(a[0]=='0')\nfor i in range(1,n+1):\n    f[i]=f[i-1]+int(a[i-1]=='0')\n \n#sprint(f)\ndef check(dis):\n    for i in range(n):\n      if a[i]=='0':\n        left=max(i-dis,0)\n        right=min(i+dis,n-1)\n        if f[right+1]-f[left]>=k:return True\n    return False\nl=1\nr=n\nans=n\nwhile l<=r:\n    mid=(l + r)// 2\n    # print(mid)\n    if check(mid):\n        # print(True)\n        ans=min(ans,mid)\n        r=mid-1\n        \n    else:\n        # print(False)\n        l=mid+1\nprint(ans)\n \n \n", "n, k = [int(_) for _ in input().split()]\na = input()\nk += 1\n# size of n+1\nf = [0] * (n+1)\n \nf[1]=int(a[0]=='0')\nfor i in range(1,n+1):\n    f[i]=f[i-1]+int(a[i-1]=='0')\n \n#sprint(f)\ndef check(dis):\n    for i in range(n):\n      if a[i]=='0':\n        left=max(i-dis,0)\n        right=min(i+dis,n-1)\n        if f[right+1]-f[left]>=k:return True\n    return False\nl=1\nr=n\nans=n\nwhile l<=r:\n    mid=(l + r)// 2\n    # print(mid)\n    if check(mid):\n        # print(True)\n        ans=min(ans,mid)\n        r=mid-1\n        \n    else:\n        # print(False)\n        l=mid+1\nprint(ans)\n \n \n"]
["n, m = list(map(int, input().split()))\nmx = [[0x00] * n for i in range(n)]\nused = None\n\ndef dfs(cur, trg, color):\n    if cur == trg:\n        return True\n    if not used[cur]:\n        used[cur] = True\n        for i in range(n):\n            if mx[cur][i] & color:\n                if dfs(i, trg, color):\n                    return True\n    return False\n\nfor i in range(m):\n    a, b, c = [int(s) - 1 for s in input().split()]\n    mx[a][b] |= 1 << c\n    mx[b][a] |= 1 << c\n\nq = int(input())\nfor i in range(q):\n    u, v = [int(s) - 1 for s in input().split()]\n    result = 0\n    for j in range(m):\n        used = [False] * n\n        if dfs(u, v, 1 << j):\n            result += 1\n    print(result)\n", "from collections import deque\n\ndef BFS(graph,a,b):\n    \n    q = deque()\n    q.append(a)\n    visited = [ False for _ in range(len(graph))]\n    \n    while len(q):\n        v = q.pop()\n\n        if visited[v]:\n            continue\n\n        for x in graph[v]:\n            if not visited[x]:\n                q.append(x)\n\n        visited[v] = True\n\n    return visited[b]\n\n\nn, m = map(int, input().split())\ncolor = {}\nfor i in range(m):\n    v1, v2, c = map(int, input().split())\n\n    if c not in color:\n        color[c] = [ [] for _ in range(n+1) ]\n\n    color[c][v1].append(v2)\n    color[c][v2].append(v1)\n        \nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n\n    ans = 0\n    for i in color:\n        if BFS(color[i], a, b):\n            ans += 1\n    print(ans)", "from sys import setrecursionlimit as setrec\nsetrec(10010)\n\ndef dfs(i, s, cnt):\n    if colored[i][s] > 0: return\n    colored[i][s] = cnt\n    for t in g[i][s]:\n        dfs(i, t, cnt)\n\nver_n, edge_n = list(map(int, input().split()))\ng = [[[] for _ in range(ver_n)] for _ in range(edge_n)]\nfor _ in range(edge_n):\n    a, b, c = [int(x)-1 for x in input().split()]\n    g[c][a].append(b)\n    g[c][b].append(a)\n\ncolored = [[0] * ver_n for _ in range(edge_n)]\nfor i in range(edge_n):\n    cnt = 1\n    for j in range(ver_n):\n        dfs(i, j, cnt)\n        cnt += 1\n\nq = int(input())\nfor i in range(q):\n    cnt = 0\n    u, v = [int(x)-1 for x in input().split()]\n    for j in range(edge_n):\n        if colored[j][u] == colored[j][v]:\n            cnt += 1\n    print(cnt)\n    \n    \n", "n,m = input().split(' ')\nl = []\nfor x in range(int(m)):\n    l.append(list(range(int(n))))\nfor x in range(int(m)):\n    p = input().split(' ')\n    newl = l[int(p[2])-1]\n    a,i = max(newl[int(p[0])-1],newl[int(p[1])-1]),min(newl[int(p[0])-1],newl[int(p[1])-1])\n    for y in range(len(newl)):\n        if newl[y] == a:\n            newl[y] = i\n    l[int(p[2])-1] = newl\nq = int(input())\nput = []\nfor x in range(q):\n    out = 0\n    a,b = input().split(' ')\n    for n in l:\n        if n[int(a)-1] == n[int(b)-1]:\n            out += 1\n    put.append(out)\nfor x in put:\n    print(x)\n", "n,m = list(map(int, input().split()))\nl = []\nfor i in range(m):\n    a,b,c = list(map(int, input().split()))\n    if len(l) <= c-1:\n        for i in range(c-len(l)):\n            l.append([])\n    p = l[c-1]\n    m = []\n    for i in range(len(p)):\n        if a in p[i] or b in p[i]:\n            m.append(i)\n    new = [a,b]\n    for i in range(len(m)):\n        new = new + p[m[i]]\n    for i in range(len(m)):\n        p.pop(m[i]-i)\n    p.append(new)\n    l[c-1] = p\nq = int(input())\nfor i in range(q):\n    counter = 0\n    u,v = list(map(int, input().split()))\n    for j in range(len(l)):\n        yes = 0\n        for k in range(len(l[j])):\n            if yes == 0 and u in l[j][k] and v in l[j][k]:\n                yes = 1\n                counter += 1\n    print(counter)\n", "def main():\n    n, m = list(map(int, input().split()))\n    edges = {_: {} for _ in range(1, m + 1)}\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        d = edges[c]\n        l = d.get(a)\n        if l:\n            l.append(b)\n        else:\n            d[a] = [b]\n        l = d.get(b)\n        if l:\n            l.append(a)\n        else:\n            d[b] = [a]\n\n    def dfs(t):\n        unused[t] = False\n        for y in dcolor.get(t, ()):\n            if unused[y]:\n                dfs(y)\n\n    res = []\n    n += 1\n    unused = [True] * n\n    for _ in range(int(input())):\n        a, b = list(map(int, input().split()))\n        x = 0\n        for dcolor in list(edges.values()):\n            for j in range(n):\n                unused[j] = True\n            dfs(a)\n            if not unused[b]:\n                x += 1\n        res.append(str(x))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def iterative_bfs(graph, start, path=[]):\n  '''iterative breadth first search from start'''\n  q=[start]\n  while q:\n    v=q.pop(0)\n    if not v in path:\n      path=path+[v]\n      q=q+graph[v]\n  return path\n\ndx = {}\nnodes, edges = map(int, input().split(' '))\nfor c in range(edges+1):\n    graph = {}\n    for i in range(nodes):\n      graph[i] = []\n    dx[c] = graph\n\n\nfor i in range(edges):\n  a, b, c = map(int, input().split(' '))\n  dx[c][a-1].append(b-1)\n  dx[c][b-1].append(a-1)\n\nfor _ in range(int(input())):\n    a, b = map(int, input().split(' '))\n    t = 0\n    for i in dx:\n        graph = dx[i]\n        \n        if b-1 in iterative_bfs(graph, a-1):\n            t += 1\n    print(t)", "def dfs_paths(graph, start, goal, path=list()):\n    if not path:\n        path.append(start)\n    if start == goal:\n        yield path\n    for vertex in graph[start] - set(path):\n        yield from dfs_paths(graph, vertex, goal, path=path + [vertex])\n\nn, m = map(int, input().split())\ngraph = {}\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n\n    if c not in graph:\n        graph[c] = {}\n\n    if a not in graph[c]:\n        graph[c][a] = set()\n\n    if b not in graph[c]:\n        graph[c][b] = set()\n\n    graph[c][a].add(b)\n    graph[c][b].add(a)\n\nq = int(input())\n\nfor _ in range(q):\n    u, v = map(int, input().split())\n    count = 0\n\n    for k in graph:\n        if u not in graph[k] or v not in graph[k]:\n            continue\n        if len(list(dfs_paths(graph[k], u, v, []))) > 0:\n            count += 1\n\n    print(count)", "from collections import defaultdict\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    edges = defaultdict(lambda: defaultdict(list))\n    for _ in range(m):\n        a, b, c = list(map(int, input().split()))\n        d = edges[c]\n        d[a].append(b)\n        d[b].append(a)\n\n    def dfs(t):\n        chain.add(t)\n        dd = color.get(t, ())\n        for y in dd:\n            if y not in chain:\n                dfs(y)\n\n    res = []\n    chain = set()\n    for _ in range(int(input())):\n        a, b = list(map(int, input().split()))\n        x = 0\n        for color in list(edges.values()):\n            chain.clear()\n            dfs(a)\n            if b in chain:\n                x += 1\n        res.append(str(x))\n    print('\\n'.join(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def DFS(start, color):\n    nonlocal isUsed\n    isUsed[start] = True\n    for i in graph[start]:\n        if not isUsed[i[0]] and i[1] == color:\n            DFS(i[0], color)\n\nn, m = tuple(map(int, input().split()))\n\ngraph = [[] for i in range(n)]\n\nfor i in range(m):\n    a, b, c = tuple(map(int, input().split()))\n    graph[a - 1].append((b - 1, c))\n    graph[b - 1].append((a - 1, c))\n\nq = int(input())\nanswers = [0] * q\nfor i in range(q):\n    u, v = tuple(map(int, input().split()))\n    for j in range(1, m + 1):\n        isUsed = [False] * n\n        DFS(u - 1, j)\n        if isUsed[v - 1]:\n            answers[i] += 1\n\nprint(\"\\n\".join(map(str, answers)))\n", "# 505B.py\n# Mr. Kitayuta's Colorful Graph\n\n#First try\n# n,m = map(int, raw_input().split())\n# g = [[[] for _ in range(n+1)] for _ in range(m+1)]\n# for i in xrange(m):\n#     a,b,c = map(int, raw_input().split())\n#     g[c][a].append(b)\n\n# q = int(raw_input())\n\n# for i in xrange(q):\n#     u,v = map(int, raw_input().split())\n#     out = 0\n#     for j in xrange(1, len(g)):\n#         u_found = v_found = False\n#         for k in xrange(1, n+1):\n#             if g[j][k]:\n#                if k == u:\n#                      u_found = True\n#                elif k == v:\n#                      v_found = True\n\n#                for l in g[j][k]:\n#                     if l == u:\n#                         u_found = True\n#                     elif l == v:\n#                         v_found = True\n#             if v_found == True and u_found == True:\n#                 break\n#         if v_found == True and u_found == True:\n#             out += 1\n\n#     print out\n        \n#Editorial\n#DFS\n\n#file = open(\"505Btest\")\nf = lambda: input()\n#f = lambda: file.readline()\nml = lambda: list(map(int, f().split()))\n\nn,m = ml()\ng = [[ []for x in range(n+1)] for x in range(m+1)]\n\nfor i in range(m):\n    a,b,c = ml()\n    g[c][a].append(b)\n    g[c][b].append(a)\n\nq = int(f())\n\ndef dfs(c, start, end):\n    nonlocal g, n\n    discovered = [False] *(n+1)\n    s = []\n    s.append(start)\n    while s:\n        v = s.pop()\n        if not discovered[v]:\n            discovered[v] = True\n            for i in g[c][v]:\n                if i == end:\n                    return True\n                s.append(i)\n\n    return False\n\nfor i in range(q):\n    u,v = ml()\n    count = 0\n    for j in range(1, m+1):\n        if g[j]:\n            if dfs(j, u, v):\n                count += 1\n    print(count)\n            \n", "def dfs(u1,v1,c):\n\tret = False\n\tused[u1-1] = True\n\tfor i,edge in enumerate(e):\n\t\tif edge[2] != c:\n\t\t\tcontinue\n\t\tt = None\n\t\tif u1 == edge[0]:\n\t\t\tt = edge[1]\n\t\telif u1 == edge[1]:\n\t\t\tt = edge[0]\n\t\tif t and not used[t-1]:\n\t\t\tif t == v1:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tret |= dfs(t,v1,c)\n\treturn ret\n\n\n\nn,m = map(int,input().split())\ne = [list(map(int,input().split())) for i in range(m)]\nused = [False for i in range(n)]\nq = int(input())\na = []\nfor i in range(q):\n\tu,v = map(int,input().split())\n\tans = 0\n\tfor c in range(1,m+1):\n\t\tif dfs(u,v,c):\n\t\t\tans += 1\n\t\tused = [False for i in range(n)]\n\ta += [ans]\nfor i in a:\n\tprint(i)", "from collections import defaultdict, deque\n\ndef bfs(g,s,c):\n    visited = set()\n    q = deque([s])\n    while len(q) > 0:\n        v = q.pop()\n        visited.add(v)\n        for adj,adj_c in g[v]:\n            if adj_c == c and adj not in visited and adj not in q:\n                q.append(adj)\n    return visited\n    \ndef con_components(g,c):\n    visited = set()\n    components = []\n    for s in g.keys():\n        if s not in visited:\n            nodes = bfs(g,s,c)\n            components.append(nodes)\n            visited |= nodes\n    return components\n\ndef main():\n    n,m = map(int, input().split())\n    g = defaultdict(list)\n    colors = set()\n    for _ in range(m):\n        a,b,c = map(int, input().split())\n        g[a].append((b,c))\n        g[b].append((a,c))\n        colors.add(c)\n    components = {c:con_components(g,c) for c in colors}\n    \n    q = int(input())\n    for _ in range(q):\n        u,v = map(int, input().split())\n        ct = 0\n        for c in colors:\n            for comp in components[c]:\n                if u in comp and v in comp:\n                    ct += 1\n        print(ct)\n    \n\ndef __starting_point():\n    main()   \n__starting_point()", "def dfs(p, f, gr, used):\n\tif p == f:\n\t\treturn 1\n\tif used[p]:\n\t\treturn 0\n\tused[p] = 1\n\tfor v in gr[p]:\n\t\tif dfs(v, f, gr, used):\n\t\t\treturn 1\n\treturn 0\n\ndef check(gr, u, v):\n\tused = [0] * len(gr)\n\treturn dfs(u, v, gr, used)\n\nn, m = (int(x) for x in input().split())\ncgr = [[[] for j in range(n)] for _ in range(m)]\nfor i in range(m):\n\ta, b, c = (int(x) for x in input().split())\n\tc -= 1\n\ta -= 1\n\tb -= 1\n\tcgr[c][a].append(b)\n\tcgr[c][b].append(a)\nq = int(input())\nfor i in range(q):\n\tu, v = (int(x) for x in input().split())\n\tans = 0\n\tfor gr in cgr:\n\t\tans += check(gr, u - 1, v - 1)\n\tprint(ans)\n", "# 505B\nfrom collections import defaultdict\n\n__author__ = 'artyom'\n\nread = lambda: map(int, input().split())\nall_edges = defaultdict(list)\nn, m = read()\nfor _ in range(m):\n  a, b, c = read()\n  all_edges[c].append((a, b))\n\ngraphs = []\n\n\ndef root(components, x, l=0):\n  return (x, l) if components[x] == x else root(components, components[x], l + 1)\n\n\ndef connected_components(edges):\n  components = [i for i in range(n + 1)]\n  for u, v in edges:\n    ru, lu = root(components, u)\n    rv, lv = root(components, v)\n    if ru != rv:\n      if lu < lv:\n        components[ru] = rv\n      else:\n        components[rv] = ru\n  return components\n\n\nfor c, edges in all_edges.items():\n  graphs.append(connected_components(edges))\n\n\ndef count_in_same_component(u, v):\n  count = 0\n  for graph in graphs:\n    if root(graph, u)[0] == root(graph, v)[0]:\n      count += 1\n  return count\n\n\nans = ''\nfor __ in range(int(input())):\n  u, v = read()\n  ans += str(count_in_same_component(u, v)) + '\\n'\nprint(ans)", "def solve():\n    def dfs(c):\n        if c == v:\n            return True\n\n        r = False\n\n        for i in range(1, n+1):\n            if g[w][c][i] and i not in p:\n                p[i] = c\n                r |= dfs(i)\n\n        return r\n\n    n, m = list(map(int, input().split()))\n    g = [[[False for j in range(n+1)] for i in range(n+1)] for _ in range(m+1)]\n\n    for _ in range(m):\n        u, v, w = list(map(int, input().split()))\n        g[w][u][v] = True\n        g[w][v][u] = True\n\n    for _ in range(int(input())):\n        u, v = list(map(int, input().split()))\n        res = 0\n\n        for w in range(1, m+1):\n            p = dict()\n            p[u] = -1\n            res += dfs(u)\n\n        print(res)\n\nsolve()\n", "def get_connected_matrix(adjacency_matrix):\n    n = len(adjacency_matrix)\n    non_visited_vertices = set(i for i in range(n))\n    cluster_numbers = [0] * n\n    cluster_number = 1\n\n    def traverse(u):\n        non_visited_vertices.remove(u)\n        cluster_numbers[u] = cluster_number\n        for v in range(n):\n            if v in non_visited_vertices:\n                if adjacency_matrix[u][v]:\n                    traverse(v)\n\n    while non_visited_vertices:\n        vertex = non_visited_vertices.pop()\n        non_visited_vertices.add(vertex)\n        traverse(vertex)\n        cluster_number += 1\n\n    connected_matrix = [[False] * n for _ in range(n)]\n\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n            connected_matrix[u][v] = connected_matrix[v][u] = (cluster_numbers[u] == cluster_numbers[v])\n\n    return connected_matrix\n\n\ndef main():\n    n, m = [int(t) for t in input().split()]\n\n    matrices = [[[False] * n for _ in range(n)] for _ in range(m)]\n\n    for _ in range(m):\n        a, b, c = [int(t) - 1 for t in input().split()]\n        matrices[c][a][b] = True\n        matrices[c][b][a] = True\n\n    connected_matrices = [get_connected_matrix(matrix) for matrix in matrices]\n\n    q = int(input())\n    for _ in range(q):\n        u, v = [int(t) - 1 for t in input().split()]\n        total_connection = sum(1 for connected_matrix in connected_matrices if connected_matrix[u][v])\n        print(total_connection)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def dfs(x,c):\n    vis[x] = 1\n    for i in adj[c][x]:\n        if not vis[i]:\n            dfs(i,c)\n\ndef check(u,v,c):\n    for i in range(1,n+1):\n        vis[i] = False\n    dfs(u,c)\n    return vis[v]\n\nn,m = map(int,input().split())\n\nadj = []\nfor i in range(m+1):\n    adj.append([])\n    for j in range(n+1):\n        adj[i].append([])\nvis = [False]*(n+1)\n\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    adj[c][a].append(b)\n    adj[c][b].append(a)\n\nq = int(input())\nfor i in range(q):\n    u,v = map(int,input().split())\n    ans = 0;\n    for c in range(1,m+1):\n        if check(u,v,c):\n            ans+=1\n    print(ans)", "def dfs(place,target):\n    vis[place]=True\n    if target==place:total[0]+=1;return()\n    anyAdj=0\n    for i in j[place]:\n        if not vis[i]:anyAdj=1;dfs(i,target)\n    if anyAdj==0:return()\n\nv,e=list(map(int,input().split()))\nedges=[]\nfor i in range(e):edges.append(list(map(int,input().split())))\ncolors=[]\nfor i in edges:colors.append(i[2])\ncolors=list(set(colors))\ncolorAdjs=[]\nfor i in colors:\n    colorAdjs.append([[] for w in range(v)])\n    for j in edges:\n        if j[2]==i:\n            colorAdjs[-1][j[0]-1].append(j[1]-1)\n            colorAdjs[-1][j[1]-1].append(j[0]-1)\nq=int(input())\nfor i in range(q):\n    total=[0]\n    a,b=list(map(int,input().split()))\n    a-=1;b-=1\n    for j in colorAdjs:\n        vis=[False]*v\n        dfs(a,b)\n    print(total[0])\n", "n,m = [int(x) for x in input().split()]\nedge = {}\nfor i in range (1,n+1):\n\tedge[i] = {}\n\tfor j in range (1,m+1):\n\t\tedge[i][j] = []\nfor i in range (m):\n\ta,b,c = [int(x) for x in input().split()]\n\tedge[a][c].append(b)\n\tedge[b][c].append(a)\nq = int(input())\nfor i in range (q):\n\tu,v = [int(x) for x in input().split()]\n\tcount = 0\n\tfor key in edge[u]:\n\t\tlevel = {u:0}\n\t\tfrontier = [u]\n\t\tfound = False\n\t\twhile frontier and not found:\n\t\t\tnext = []\n\t\t\tfor uu in frontier:\n\t\t\t\tfor vv in edge[uu][key]:\n\t\t\t\t\tif not(vv in level):\n\t\t\t\t\t\tif vv == v:\n\t\t\t\t\t\t\tfound = True\n\t\t\t\t\t\tlevel[vv] = 0\n\t\t\t\t\t\tnext.append(vv)\n\t\t\tfrontier = next\n\t\tif(found):\n\t\t\tcount += 1\n\tprint (count)", "from collections import defaultdict,deque,Counter,OrderedDict\ndef main():\n    N = 105\n    n,m = map(int,input().split())\n    par = [ [j for j in range(N)] for i in range(N)]\n\n    def find(a,c):\n        if par[c][a] == a: return a\n        par[c][a] = find(par[c][a],c)\n        return par[c][a]\n\n    def merge(a,b,c):\n        a = find(a,c)\n        b = find(b,c)\n        par[c][b] = a\n\n    for i in range(m):\n        a,b,c = map(int,input().split())\n        a,b = a-1,b-1\n        merge(a,b,c)\n\n    q = int(input())\n    for i in range(q):\n        a,b = map(int,input().split())\n        a,b,ans = a-1,b-1,0\n        for i in range(N):\n            if find(a,i) == find(b,i):\n                ans +=1\n        print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n, m = list(map(int,input().split()))\np = [ [ i for i in range(n) ] for j in range(m)]\ndef f(ci,xi):\n  if xi==p[ci][xi]: return xi\n  p[ci][xi] = f(ci,p[ci][xi])\n  return p[ci][xi]\ndef uni(ci,xi,yi):\n  p[ci][f(ci,xi)]=f(ci,yi)\nfor i in range(m):\n  a, b, c = list(map(int,input().split()))\n  uni(c-1,a-1,b-1)\nfor i in range(int(input())):\n  a, b = list(map(int,input().split()))\n  print(sum(1 if f(i,a-1) == f(i,b-1) else 0 for i in range(m)))\n", "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        parent = {}\n        parent = dfs_visit(v, graph[c], parent)\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\ndef __starting_point():\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n__starting_point()", "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\nparent_history = {}\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        if c in parent_history and v in parent_history[c]:\n            parent = parent_history[c]\n        else:\n            parent = {}\n            parent = dfs_visit(v, graph[c], parent)\n            parent_history[c] = parent\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\ndef __starting_point():\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n__starting_point()", "def build_graph():\n    line1 = input().strip().split()\n    n = int(line1[0])\n    m = int(line1[1])\n    graph = {}\n    for _ in range(m):\n        line = input().strip().split()\n        u = int(line[0])\n        v = int(line[1])\n        c = int(line[2])\n        if c not in graph:\n            graph[c] = {j: [] for j in range(1, n+1)}\n        graph[c][u].append(v)\n        graph[c][v].append(u)\n    return graph\n\nparent_history = {}\n\ndef no_of_paths(u, v, graph):\n    x = 0\n    for c in graph:\n        if c in parent_history:\n            if v in parent_history[c]:\n                parent = parent_history[c]\n            else:\n                parent = {}\n                parent = dfs_visit(v, graph[c], parent)\n                if len(parent_history[c]) < len(parent):\n                    parent_history[c] = parent\n        else:\n            parent = {}\n            parent = dfs_visit(v, graph[c], parent)\n            parent_history[c] = parent\n        if u in parent:\n            x += 1\n    return x\n\ndef dfs_visit(i, adj_list, parent):\n    for j in adj_list[i]:\n        if j not in parent:\n            parent[j] = i\n            dfs_visit(j, adj_list, parent)\n    return parent\n\n\ndef __starting_point():\n    graph = build_graph()\n    for _ in range(int(input())):\n        line = input().strip().split()\n        print(no_of_paths(int(line[0]), int(line[1]), graph))\n__starting_point()"]
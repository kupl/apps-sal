["import sys\nfrom collections import deque\n\n\ndef main():\n    N, p, q, *AB = list(map(int, sys.stdin.buffer.read().split()))\n    p -= 1\n    q -= 1\n\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    if len(G[p]) == 1 and G[p][0] == q:\n        print((0))\n        return\n\n    dist1 = [-1] * N\n    dist1[p] = 0\n    queue = deque([p])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist1[nv] == -1:\n                dist1[nv] = dist1[v] + 1\n                queue.append(nv)\n\n    dist2 = [-1] * N\n    dist2[q] = 0\n    queue = deque([q])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist2[nv] == -1:\n                dist2[nv] = dist2[v] + 1\n                queue.append(nv)\n\n    max_d = 0\n    for d1, d2 in zip(dist1, dist2):\n        if d1 < d2 and max_d < d2:\n            max_d = d2\n\n    print((max_d - 1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "ma = lambda :list(map(int,input().split()))\nn,u,v = ma()\nu,v = u-1,v-1\ntree = [[] for i in range(n)]\nimport collections\n\nfor i in range(n-1):\n    a,b = ma()\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\nque = collections.deque([(v,0)])\nvis = [False]*n\ndist_v = [0]*n\nwhile que:\n    now,c = que.popleft()\n    vis[now] = True\n    dist_v[now] = c\n    for node in tree[now]:\n        if not vis[node]:\n            que.append((node,c+1))\nque = collections.deque([(u,0)])\nvis = [False]*n\ndist_u = [0]*n\nwhile que:\n    now,c = que.popleft()\n    vis[now] = True\n    dist_u[now] = c\n    for node in tree[now]:\n        if not vis[node]:\n            que.append((node,c+1))\nans = 0\nfor i in range(n):\n    if dist_u[i] < dist_v[i]:\n        ans = max(ans,dist_v[i])\nprint((ans-1))\n", "# AtCoder Beginner Contest 148\n# F - Playing Tag on Tree\n# https://atcoder.jp/contests/abc148/tasks/abc148_f\nfrom collections import deque\n\nimport sys\ninput = sys.stdin.readline\nN, U, V = list(map(int, input().split()))\nU -= 1\nV -= 1\nG = [[] for _ in [0]*N]\nfor _ in [0]*(N-1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\nINF = 10**10\n\nT = [INF]*N\nT[U] = 0\nA = [INF]*N\nA[V] = 0\n\n\ndef bfs(v, dist):\n    q = deque()\n    q.append(v)\n    k = 0\n    visited = [0]*N\n    while q:\n        v = q.popleft()\n        visited[v] = 1\n        k = dist[v]\n\n        for u in G[v]:\n            if visited[u]:\n                continue\n            q.append(u)\n            dist[u] = k+1\n\n\nbfs(U, T)\nbfs(V, A)\n\nif A[U] <= 1:\n    print((0))\n    return\n\nfarthest = 0\nnode = -1\nfor i, (t, a) in enumerate(zip(T, A)):\n    if t < a and farthest < a:\n        farthest = a\n        node = i\n\nprint((farthest-1))\n", "import sys \nsys.setrecursionlimit(10**6)\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nN,u,v = list(map(int,readline().split()))\nAB = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b = list(map(int,readline().split()))\n    AB[a].append(b)\n    AB[b].append(a)\n    \ntdist = [0]*(N+1)\nadist = [0]*(N+1)\n\ndef tdfs(x,pre):\n    for to in AB[x]: \n        if to == pre:\n            continue\n        tdist[to] = tdist[x]+1\n        tdfs(to,x)\n\ndef adfs(x,pre):\n    for to in AB[x]: \n        if to == pre:\n            continue\n        adist[to] = adist[x]+1\n        adfs(to,x)\n\ntdfs(u,-1)\nadfs(v,-1)\n\nans = 0\nfor i in range(1,N+1):\n    if tdist[i] < adist[i]:\n        k = adist[i] - tdist[i]\n        ans = max(ans,tdist[i] + k-1)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n\nn, u, v = list(map(int, input().split()))\nu -= 1\nv -= 1\nab = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    ab[a - 1].append(b - 1)\n    ab[b - 1].append(a - 1)\n\ndef dfs1(pos, before_pos):\n    for next_pos in ab[pos]:\n        if next_pos == before_pos:\n            continue\n        if next_pos == u:\n            return True, [pos]\n        tf, root = dfs1(next_pos, pos)\n        if tf:\n            root.append(pos)\n            return True, root\n    return False, []\n    \nroot = dfs1(v, -1)[1]\nroot = root[::-1]\nroot.append(u)\nn = (len(root) + 1) // 2\npos = root[n]\nbefore_pos = root[n - 1]\n\nmax_len = n\n\ndef dfs2(pos, before_pos, cnt):\n    nonlocal max_len\n    cnt += 1\n    max_len = max(max_len, cnt)\n    if cnt < n - 1:\n        dfs2(root[cnt + 1], pos, cnt)\n    else:\n        for next_pos in ab[pos]:\n            if next_pos == before_pos:\n                continue\n            dfs2(next_pos, pos, cnt)\n\n\ndfs2(pos, before_pos, n - 1)\nans = max_len - 1\nans = max(ans, 0)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10000000)\nimport math\nimport bisect\ndef input():\n    return sys.stdin.readline()[:-1]\n\nn,u,v = list(map(int,input().split()))\nu-=1\nv-=1\ng = [[]for i in range(n)]\nfor i in range(n-1):\n    a,b = list(map(int,input().split()))\n    a-=1\n    b-=1\n    g[a].append(b)\n    g[b].append(a)\nseen = [-1 for i in range(n)]\ntaka = []\naok = []\ndef dfs(s,lis):\n    nec = g[s]\n    if len(nec)==1:\n        lis.append(s)\n    for i in nec:\n        if seen[i]!=-1:\n            continue\n        seen[i] = seen[s]+1\n        dfs(i,lis)\n\nseen[u]=0\ndfs(u,taka)\ntakadist = [i for i in seen]\nseen = [-1 for i in range(n)]\nseen[v]=0\ndfs(v,aok)\nans = 0\nfor i in aok:\n    if takadist[i]<seen[i]:\n        ans = max(ans,seen[i])\nif g[u]==[v]:\n    print((0))\nelse:\n    print((ans-1))\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\nfrom collections import deque\n\nn,u,v=nii()\nu-=1\nv-=1\n\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=nii()\n  a-=1\n  b-=1\n  tree[a].append(b)\n  tree[b].append(a)\n\ndist_a=[-1 for i in range(n)]\ndist_a[v]=0\n\ndist_t=[-1 for i in range(n)]\ndist_t[u]=0\n\n\ndef BFS(dist,s):\n  que=deque()\n  que.append(s)\n\n  while que:\n    x=que.popleft()\n    for i in tree[x]:\n      if dist[i]==-1:\n        que.append(i)\n        dist[i]=dist[x]+1\n  return dist\n\ndist_a=BFS(dist_a,v)\ndist_t=BFS(dist_t,u)\n\nans=0\nfor i in range(n):\n  if dist_a[i]>dist_t[i]:\n    ans=max(ans,dist_a[i]-1)\n\nprint(ans)", "f=lambda:map(int,input().split())\nn,st,sa=f()\nst-=1\nsa-=1\ng=[[] for _ in range(n)]\nfor _ in range(n-1):\n  a,b=f()\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\ndef bfs(s):\n  l=[-1]*n; l[s]=0; q=[s]\n  while q:\n    v=q.pop(); d=l[v]+1\n    for c in g[v]:\n      if l[c]<0: l[c]=d; q+=[c]\n  return l\nlt=bfs(st)\nla=bfs(sa)\nm=0\nfor i in range(n):\n  if lt[i]<la[i]: m=max(m,la[i])\nprint(m-1)", "import sys\nsys.setrecursionlimit(10**6)\nn, a, b = list(map(int, input().split()))\nD = [[0]*2 for _ in range(101010)]\nE = [[] for _ in range(n)]\n\n\ndef dfs(cur, pre, d, id):\n    D[cur][id] = d\n    for nv in E[cur]:\n        if nv != pre:\n            dfs(nv, cur, d+1, id)\n\n\na -= 1\nb -= 1\nfor i in range(n-1):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    E[x].append(y)\n    E[y].append(x)\ndfs(a, a, 0, 0)\ndfs(b, b, 0, 1)\nmax_d = 0\nfor i in range(n):\n    if D[i][0] < D[i][1]:\n        max_d = max(max_d, D[i][1]-1)\nprint(max_d)\n", "import sys\n\nsys.setrecursionlimit(10**5)\nn, u, v = list(map(int, input().split()))\nu -= 1\nv -= 1\nm_mat = [[] for i in range(n)]\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    m_mat[a].append(b)\n    m_mat[b].append(a)\nu_map = [-1]*n\nv_map = [-1]*n\nu_map[u] = 0\nv_map[v] = 0\n\n\ndef dfs(current, depth, ma):\n    for nex in m_mat[current]:\n        if ma[nex] > -1:\n            continue\n        ma[nex] = depth\n        dfs(nex, depth+1, ma)\n\n\ndfs(u, 1, u_map)\ndfs(v, 1, v_map)\n\nans = -1\nfor i in range(n):\n    if u_map[i] < v_map[i] and v_map[i] > ans:\n        ans = v_map[i]\n\nprint((ans-1))\n", "import sys\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\n\nN, u, v = map(int, input().split())\nu -= 1\nv -= 1\nTree = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n  A, B = map(lambda x:int(x)-1, input().split())\n  Tree[A].append(B)\n  Tree[B].append(A)\n\n#u-v\u9593\u306e\u5358\u7d14path\u3092\u7528\u610f\u3059\u308b\npath = []\ndef connected(v, tv, p=-1):\n  if v == tv:\n    return True\n  for w in Tree[v]:\n    if w == p:\n      continue\n    elif connected(w, tv, v):\n      path.append(w)\n      return True\n  return False\n\nconnected(v, u)\npath.append(v)\n\n#u-v\u9593\u306e\u70b9\u304b\u3089v\u3068\u306f\u9006\u65b9\u5411\u306bdfs\n#u-v\u306e\u4e2d\u70b9\u304b\u3089\u8abf\u3079\u308c\u3070\u5341\u5206(\u4e2d\u70b9\u3088\u308av\u306b\u5bc4\u308b\u3068\u3001\u9752\u6728\u541b\u306f\u6355\u307e\u3063\u3066\u3057\u307e\u3046)\n\ndef dfs(v, p):\n  d = -1\n  for w in Tree[v]:\n    if w == p:\n      continue\n    else:\n      d = max(d, dfs(w, v))\n  return d + 1\n\ndist = len(path)\nmid = path[dist//2 - 1]\npar = path[dist//2]\nans = dfs(mid, par)\n\nprint(ans + (dist-1)//2)", "from collections import deque, defaultdict\nfrom copy import deepcopy\nimport sys\nimport resource\n\nsys.setrecursionlimit(10**5)\n\nN ,u, v = list(map(int,input().split()))\ngraph = defaultdict(deque)\nfor _ in range(1,N):\n    a, b = list(map(int,input().split()))\n    graph[a].append(b)\n    graph[b].append(a)\n\ndepth = dict(list(zip(list(range(1,N+1)),[-1]*N)))\n\ndef bfs(s):\n    if graph[s]:\n        for v in graph[s]:\n            if depth[v] == -1:\n                depth[v] = depth[s] + 1\n                bfs(v)\n\ndepth = dict(list(zip(list(range(1,N+1)),[-1]*N)))\ndepth[v] = 0\nbfs(v)\ndepth_v = deepcopy(depth)\n\ndepth = dict(list(zip(list(range(1,N+1)),[-1]*N)))\ndepth[u] = 0\nbfs(u)\ndepth_u = depth\ndepth_v = sorted(list(depth_v.items()), key = lambda x:x[0])\ndepth_u = sorted(list(depth_u.items()), key= lambda x:x[0])\n\nMAX = 0\nfor v,u in zip(depth_v, depth_u):\n    if u[1] < v[1]:\n        MAX = max(MAX,v[1])\nprint((MAX-1))\n", "from collections import deque\nn,u,v=list(map(int,input().split()))\ng=[set([]) for _ in range(n+1)]\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    g[a].add(b)\n    g[b].add(a)\n\nleaf=[]\nfor i in range(1,n+1):\n    if(len(g[i])==1):\n        leaf.append(i)\n\nd_u=[-1 for _ in range(n+1)]\nd_v=[-1 for _ in range(n+1)]\n\ndef bfs(start,d):\n    d[start]=0\n    q=deque([start])\n\n    while(len(q)>0):\n        qi=q.popleft()\n        di=d[qi]\n\n        next_qi=g[qi]\n        for i in next_qi:\n            if(d[i]==-1):\n                d[i]=di+1\n                q.append(i)\n\n    return d\n\n\nd_u=bfs(u, d_u)\nd_v=bfs(v, d_v)\n\n\nif(u in leaf and list(g[u])[0]==v):\n    print((0))\nelse:\n    ans=0\n    for li in leaf:\n        if(d_u[li]<d_v[li]):\n            ans=max(ans,d_v[li]-1)\n    print(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\nn, u, v = map(int, input().split())\nu -= 1\nv -= 1\ngraph = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\nd1 = [None]*n\nd2 = [None]*n\ndef dfs(node, d, p_node=-1):\n    for c_node in graph[node]:\n        if c_node==p_node:\n            continue\n        d[c_node] = d[node] + 1\n        dfs(c_node, d, node)\nd1[u] = 0\nd2[v] = 0\ndfs(u, d1)\ndfs(v, d2)\nans = 0\nfor i, j in zip(d1, d2):\n    if i<j:\n        ans = max(ans, j-1)\nprint(ans)", "def resolve():\n    N, u, v = list(map(int, input().split()))\n    u, v = u-1, v-1\n    adjs = [ [] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list([int(x)-1 for x in input().split()])\n        adjs[a].append(b)\n        adjs[b].append(a)\n    dist_from_u = [float(\"inf\") for _ in range(N)]\n    dist_from_u[u] = 0\n    import collections\n    q = collections.deque([u])\n    while q:\n        node = q.pop()\n        for adj in adjs[node]:\n            if dist_from_u[adj] > dist_from_u[node]+1:\n                dist_from_u[adj] = dist_from_u[node]+1\n                q.appendleft(adj)\n    #print(dist_from_u)\n    dist_from_v = [float(\"inf\") for _ in range(N)]\n    dist_from_v[v] = 0\n    import collections\n    q = collections.deque([v])\n    while q:\n        node = q.pop()\n        for adj in adjs[node]:\n            if dist_from_v[adj] > dist_from_v[node]+1:\n                dist_from_v[adj] = dist_from_v[node]+1\n                q.appendleft(adj)\n    #print(dist_from_v)\n    length = 0\n    for i in range(N):\n        if dist_from_u[i] < dist_from_v[i] and length < dist_from_v[i]:\n            length = dist_from_v[i]\n    print((length-1))\n    \ndef __starting_point():\n    resolve()\n\n\n__starting_point()", "import sys\nsys.setrecursionlimit(200000)\n\nN, s, t = map(int, input().split())\ns -= 1; t -= 1\nto = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    to[a].append(b)\n    to[b].append(a)\n\ndef calcDist(u):\n    dfs(u)\n    return dist\n\ndef dfs(v, d=0, p=-1):\n    dist[v] = d\n    for u in to[v]:\n        if u == p:\n            continue\n        dfs(u, d+1, v)\n\ndist = [0 for _ in range(N)]\ndistS = calcDist(s)\ndist = [0 for _ in range(N)]\ndistT = calcDist(t)\n\nans = 0\nfor i in range(N):\n    if distS[i] < distT[i]:\n        ans = max(ans, distT[i])\n\nprint(ans-1)", "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(10 ** 5 + 1)\n\n\ndef dfsu(s, p):\n    for t in g[s]:\n        if t == p:\n            continue\n        du[t] = du[s] + 1\n        dfsu(t, s)\n\n\ndef dfsv(s, p):\n    for t in g[s]:\n        if t == p:\n            continue\n        dv[t] = dv[s] + 1\n        dfsv(t, s)\n\n\nn, u, v = list(map(int, input().split()))\nu -= 1\nv -= 1\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[a].append(b)\n    g[b].append(a)\n\ndu = [0] * n\ndv = [0] * n\ndfsu(u, -1)\ndfsv(v, -1)\n\nmx = 0\nfor i in range(n):\n    if du[i] < dv[i]:\n        mx = max(mx, dv[i])\nprint((mx - 1))\n", "from collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\nN,u,v=map(int, input().split())\nD=[[] for i in range(N)]\nfor i in range(N-1):\n  a,b=map(int, input().split())\n  a-=1\n  b-=1\n  D[a].append(b)\n  D[b].append(a)\nTaka=[0]*(N+1)\nAoki=[0]*(N+1)\ndef f(n,p,A):\n  for i in D[n]:\n    if i!=p:\n      A[i]=A[n]+1\n      f(i,n,A)\n      \nf(u-1,-1,Taka)\nf(v-1,-1,Aoki)\nans=0\nfor i in range(N):\n  if Taka[i]<Aoki[i]:\n    ans=max(ans,Aoki[i]-1)\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nN,u,v=map(int,input().split())\nE=[tuple(map(int,input().split())) for i in range(N-1)]\n\nEDGE=[[] for i in range(N+1)]\n\nfor x,y in E:\n    EDGE[x].append(y)\n    EDGE[y].append(x)\n\nfrom collections import deque\nT=[-1]*(N+1)\n\nQ=deque()\nQ.append(u)\nT[u]=0\n\nwhile Q:\n    x=Q.pop()\n    for to in EDGE[x]:\n        if T[to]==-1:\n            T[to]=T[x]+1\n            Q.append(to)\n\nA=[-1]*(N+1)\n\nQ=deque()\nQ.append(v)\nA[v]=0\n\nwhile Q:\n    x=Q.pop()\n    for to in EDGE[x]:\n        if A[to]==-1:\n            A[to]=A[x]+1\n            Q.append(to)\n\n\nOK=[0]*(N+1)\n\nfor i in range(N+1):\n    if T[i]<A[i]:\n        OK[i]=1\n\nANS=0\nfor i in range(N+1):\n    if OK[i]==1:\n        ANS=max(ANS,A[i])\n\nprint(max(0,ANS-1))", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\nfrom collections import deque\n\nn,u,v=nii()\nu-=1\nv-=1\n\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=nii()\n  a-=1\n  b-=1\n  tree[a].append(b)\n  tree[b].append(a)\n\ndef BFS(s):\n  dist=[-1 for i in range(n)]\n  dist[s]=0\n\n  que=deque()\n  que.append(s)\n\n  while que:\n    x=que.popleft()\n    for i in tree[x]:\n      if dist[i]==-1:\n        que.append(i)\n        dist[i]=dist[x]+1\n  return dist\n\ndist_t=BFS(u)\ndist_a=BFS(v)\n\nans=0\nfor i in range(n):\n  if dist_a[i]>dist_t[i]:\n    ans=max(ans,dist_a[i]-1)\n\nprint(ans)", "n, u, v = map(int, input().split())\nu, v = u-1, v-1\n\ntree = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\nfrom queue import Queue\n\n# \u9752\u6728\u541b\u306b\u3088\u308bWFS\naoki = [-1 for _ in range(n)]\naoki[v] = 0\ntodo = Queue()\ntodo.put(v)\nwhile not todo.empty():\n    i = todo.get()\n    for j in tree[i]:\n        if aoki[j] == -1:\n            todo.put(j)\n            aoki[j] = aoki[i] + 1\n\n# \u9ad8\u6a4b\u541b\u306b\u3088\u308bWFS\ntaka = [-1 for _ in range(n)]\ntaka[u] = 0\ntodo = Queue()\ntodo.put(u)\nwhile not todo.empty():\n    i = todo.get()\n    for j in tree[i]:\n        if taka[j] == -1:\n            if taka[i] + 1 < aoki[j]:\n                todo.put(j)\n            taka[j] = taka[i] + 1\n\n# search\nans = 0\nfor i in range(n):\n    if taka[i] != -1:\n        if aoki[i] - 1 > ans:\n            ans = aoki[i] - 1\n\nprint(ans)", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    n, u, v = ns()\n    edge = [[] for _ in range(n)]\n\n    for _ in range(n - 1):\n        a, b = ns()\n        a -= 1\n        b -= 1\n        edge[a].append(b)\n        edge[b].append(a)\n\n    dist_takahashi = [-1] * n\n    dist_aoki = [-1] * n\n\n    def bfs(pos, dist):\n        que = queue.Queue()\n        que.put(pos)\n        dist[pos] = 0\n\n        while not que.empty():\n            current = que.get()\n            for e in edge[current]:\n                if dist[e] == -1:\n                    dist[e] = dist[current] + 1\n                    que.put(e)\n\n        return dist\n\n    dist_takahashi = bfs(u - 1, dist_takahashi)\n    dist_aoki = bfs(v - 1, dist_aoki)\n\n    ans = 0\n    for dt, da in zip(dist_takahashi, dist_aoki):\n        if dt < da:\n            ans = max(ans, da - 1)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, u, v = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(N - 1)]\n\ngraph = [[] for _ in range(N)]\nfor i, (Ai, Bi) in enumerate(AB):\n    graph[Ai - 1].append(Bi - 1)\n    graph[Bi - 1].append(Ai - 1)\n\nimport heapq\nMY_INF = 10 ** 18\n\nq = [(0, u - 1)]\nd_u = [MY_INF] * N\nd_u[u - 1] = 0\nwhile len(q) > 0:\n    dist, src = heapq.heappop(q)\n    for dst in graph[src]:\n        dist_tmp = dist + 1\n        if d_u[dst] > dist_tmp:\n            d_u[dst] = dist_tmp\n            heapq.heappush(q, (dist_tmp, dst))\n\nq = [(0, v - 1)]\nd_v = [MY_INF] * N\nd_v[v - 1] = 0\nwhile len(q) > 0:\n    dist, src = heapq.heappop(q)\n    for dst in graph[src]:\n        dist_tmp = dist + 1\n        if d_v[dst] > dist_tmp:\n            d_v[dst] = dist_tmp\n            heapq.heappush(q, (dist_tmp, dst))\n\n# print(\"#\", d_u)\n# print(\"#\", d_v)\n            \nans = 0\nfor i in range(N):\n    if d_u[i] < d_v[i] and ans < d_v[i] - 1:\n        ans = d_v[i] - 1\n\nprint(ans)", "import sys\nfrom collections import deque\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nin_n = lambda: int(readline())\nin_nn = lambda: list(map(int, readline().split()))\nin_s = lambda: readline().rstrip().decode('utf-8')\nin_nl = lambda: list(map(int, readline().split()))\nin_nl2 = lambda H: [in_nl() for _ in range(H)]\nin_map = lambda: [s == ord('.') for s in readline() if s != ord('\\n')]\nin_map2 = lambda H: [in_map() for _ in range(H)]\nin_all = lambda: list(map(int, read().split()))\n\n\ndef bfs(N, v0, edge):\n\n    search = [-1] * N\n    search[v0] = 0\n    q = deque()\n    q.append(v0)\n\n    while q:\n        v = q.popleft()\n        for nv in edge[v]:\n            if search[nv] == -1:\n                q.append(nv)\n                search[nv] = search[v] + 1\n\n    return search\n\n\ndef bfs2(N, v0, edge, dis):\n\n    q = deque()\n    q.append(v0)\n\n    max_dis = dis[v0]\n    while q:\n        v = q.popleft()\n        for nv in edge[v]:\n            if dis[v] < dis[nv]:\n                q.append(nv)\n                max_dis = max(max_dis, dis[nv])\n\n    return max_dis\n\n\ndef main():\n\n    N, taka, aoki = in_nn()\n    taka, aoki = taka - 1, aoki - 1\n\n    edge = [[] for _ in range(N)]\n    for i in range(N - 1):\n        x, y = in_nn()\n        x, y = x - 1, y - 1\n        edge[x].append(y)\n        edge[y].append(x)\n\n    dis = bfs(N, aoki, edge)\n\n    if dis[taka] > 2:\n        x = (dis[taka] + 1) // 2 - 1\n        for _ in range(x):\n            for v in edge[taka]:\n                if dis[v] < dis[taka]:\n                    taka = v\n                    break\n\n    ans = bfs2(N, taka, edge, dis) - 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\nn,u,v=map(int, input().split())\nu-=1\nv-=1\n \ngraph = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    a, b=map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n \n\ndist=[[-1, -1] for _ in range(n)]\ndist[v][0]=0\ndist[u][1]=0\n \ndef dfs(graph,v,k):\n    ver=graph[v]\n    for vers in ver:\n        if dist[vers][k]==-1:\n            dist[vers][k]=dist[v][k]+1\n            dfs(graph,vers,k)\n \n \ndfs(graph,v,0)\ndfs(graph,u,1)\ndist.sort(reverse=True)\n \nfor i in range(10**6):\n    if dist[i][0]-dist[i][1]>=1:\n        print(dist[i][0]-1)\n        break", "from collections import deque\nn, u, v = map(int,input().split())\ntree = [[] for _ in range(n+1)]\nfor _i in range(n-1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\n\ndef solve(x):\n    visit = [-1 for _ in range(n+1)]\n    visit[x] = 0\n    q = deque([x])\n    while q:\n        p = q.popleft()\n        for i in tree[p]:\n            if visit[i] < 0:\n                visit[i] = visit[p]+1\n                q.append(i)\n    return visit\n\nvisit_a = solve(v)\nvisit_t = solve(u)\n\nx, y = [], []\nfor i in range(1, n+1):\n    if visit_a[i] >= visit_t[i]:\n        x.append(visit_a[i])\n        y.append(visit_t[i])\np = x.index(max(x))\n\nprint(x[p]-1)", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**6)\nn,u,v=map(int,input().split())\nnode=[[]for _ in range(n)]\nfor _ in range(n-1):\n\ta,b=map(int,input().split())\n\tnode[a-1].append(b-1)\n\tnode[b-1].append(a-1)\ndef dfs(i):\n\tvisited[i]=1\n\tfor x in node[i]:\n\t\tif visited[x]==0:\n\t\t\tdis[x]=dis[i]+1\n\t\t\tdfs(x)\ninf=10**9\ndis=[inf]*n;dis[u-1]=0;visited=[0]*n\ndfs(u-1)\ndis2=[]\nfrom copy import copy\ndis_dash=copy(dis)\ndis2.append(dis_dash)\ndis[v-1]=0;visited=[0]*n\ndfs(v-1)\ndis2.append(dis)\ncnt=0\nfor i in range(n):\n\tif dis2[0][i]<dis2[1][i]:\n\t\tcnt=max(cnt,dis2[1][i])\nprint(cnt-1)", "from collections import deque\nn, u, v = map(int, input().split())\nu -= 1\nv -= 1\nedges = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges[a - 1].append(b - 1)\n    edges[b - 1].append(a - 1)\ndef bfs(u):\n    visited = [-1] * n\n    Q = deque()\n    visited[u] = 0\n    Q.append(u)\n    while Q:\n        p = Q.popleft()\n        for v in edges[p]:\n            if visited[v] == -1:\n                visited[v] = visited[p] + 1\n                Q.append(v)\n    return visited\ntak_dist = bfs(u)\naok_dist = bfs(v)\nans = []\nfor i in range(n):\n    if tak_dist[i] < aok_dist[i]:\n        ans.append(aok_dist[i])\nprint(max(ans) - 1)", "from collections import deque,defaultdict\nimport copy\n\ndef main():\n    from collections import defaultdict\n    import copy \n    n,u,v = map(int,input().split())\n    u -= 1\n    v -= 1\n    graph = defaultdict(deque)\n    for _ in range(n-1):\n        a,b = map(int,input().split())\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    depth = dfs(graph,u,n)\n    # print(depth)\n    depth2 = dfs(graph,v,n)\n    # print(depth2)\n    ans = 0\n    ans2 = 10**6\n    for i,j in zip(depth,depth2):\n        if i < j:\n            ans = max(j,ans)\n        # elif i == j:\n        #     ans2 = min(j,ans2)\n\n    print(ans-1)\n\ndef dfs(G,s,n):\n    stack = deque([s])\n    graph = copy.deepcopy(G)\n    depth = [None] * n\n    depth[s] = 0\n    while stack:\n        u = stack[-1]\n        if graph[u]:\n            v = graph[u].popleft()\n            if depth[v] == None:\n                depth[v] = depth[u] + 1\n                stack.append(v)\n\n        else:\n            stack.pop()\n\n    return depth\n    \n\nmain()", "\ndef resolve():\n    def dfs(v):\n        dist = [-1] * N\n        stack = [v]\n        dist[v] = 0\n        while stack:\n            v = stack.pop()\n            for to in G[v]:\n                if dist[to] != -1:\n                    continue\n                dist[to] = dist[v] + 1\n                stack.append(to)\n        return dist\n\n    N, taka, aoki = map(int, input().split())\n    taka -= 1\n    aoki -= 1\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = map(lambda x: int(x) - 1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n\n    dist_Tk = dfs(taka)\n    dist_Ao = dfs(aoki)\n\n    ans = 0\n    for i in range(N):\n        if dist_Tk[i] < dist_Ao[i]:\n            ans = max(ans, dist_Ao[i] - 1)\n\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "from collections import deque\nn,u,v=list(map(int, input().split()))\nedgelist = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b = list(map(int, input().split()))\n    edgelist[a-1].append(b-1)\n    edgelist[b-1].append(a-1)\ndist = [[0,0] for _ in range(n)]\ndef distance(start, id):\n    que=deque()\n    visited = [0]*n\n\n    found = False\n    que.append([edgelist[start],start])\n    while que:\n        ver=que.popleft()\n        visited[ver[1]]=1\n        for next_v in ver[0]:\n            if not visited[next_v]:\n                dist[next_v][id]=dist[ver[1]][id]+1\n                que.append([edgelist[next_v], next_v])\ndistance(u-1,0)\ndistance(v-1,1)\ndist.sort(key = lambda x:x[1],reverse = True)\nans=0\nfor i in range(n):\n    if dist[i][1]-dist[i][0]>=1:\n        print((dist[i][1]-1))\n        return\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    def bfs(start):\n        dist = [f_inf] * n\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            v = que.popleft()\n            for u in edge[v]:\n                if dist[u] == f_inf:\n                    dist[u] = dist[v] + 1\n                    que.append(u)\n        return dist\n\n    n, u, v = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n\n    distT = bfs(u - 1)\n    distA = bfs(v - 1)\n\n    res = 0\n    for i in range(n):\n        if distT[i] < distA[i]:\n            res = max(res, distA[i])\n    print((res - 1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v,p,d):\n    dist[v]=d\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,d+1)\ndef getSP(v):\n    p=v\n    if dist[v]==lim:\n        return p\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            p=getSP(nv)\n    return p\ndef depth(v,p,d):\n    sdist[v]=d\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            continue\n        depth(nv,v,d+1)\n    \nN,u,v=map(int,input().split())\nu,v=u-1,v-1\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    G[a].append(b)\n    G[b].append(a)\ndist=[-1]*N\ndfs(v,-1,0)\nlim=dist[u]-(dist[u]-1)//2\nSP=getSP(u)\nsdist=[-1]*N\ndepth(SP,-1,0)\nD,tmp=-1,-1\nfor i in range(N):\n    if sdist[i]>tmp:\n        D=i\n        tmp=sdist[i]\nprint(dist[D]-1)", "from collections import deque\nn,u,v=map(int,input().split())\nedge=[[] for i in range(n)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    edge[a].append(b)\n    edge[b].append(a)\nvisitedu=[-1]*n\nvisitedv=[-1]*n\ndef bfs(s,visited):\n    q=deque([s])\n    visited[s]=0\n    while q:\n        x=q.popleft()\n        for nx in edge[x]:\n            if visited[nx]==-1:\n                visited[nx]=visited[x]+1\n                q.append(nx)\n    return\nbfs(u-1,visitedu)\nbfs(v-1,visitedv)\na=0\nb=10**10\nfor i in range(n):\n    if visitedu[i]<visitedv[i]:\n        a=max(a,visitedv[i])\n    elif visitedu[i]==visitedv[i]:\n        b=min(b,visitedv[i])\n#print(visitedv)\n#print(visitedu)\nif b==10**10:\n    b=-1\nif a<=b:\n    print(b)\nelse:\n    print(a-1)", "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v,p,d):\n    dist[v]=d\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,d+1)\n        \ndef getSP(v):\n    p=v\n    if dist[v]==lim:\n        return p\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            p=getSP(nv)\n    return p\n    \ndef depth(v,p,d):\n    nonlocal maxd\n    maxd=max(maxd,dist[v])\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            continue\n        depth(nv,v,d+1)\n    \nN,u,v=map(int,input().split());u,v=u-1,v-1\n\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    G[a].append(b)\n    G[b].append(a)\n    \ndist=[-1]*N\ndfs(v,-1,0)\n\nlim=dist[u]-(dist[u]-1)//2\nSP=getSP(u)\n \nmaxd=-1\ndepth(SP,-1,0)\n\nprint(maxd-1)", "from collections import defaultdict as d\nfrom collections import deque\n\ndef bfs(adj, start, n):\n\tvisited = [0] * (n + 1)\n\ttab = [0] * n\n\tq = deque([start])\n\tvisited[start] = 1\n\twhile q:\n\t\ts = q.popleft()\n\t\tfor i in adj[s]:\n\t\t\tif visited[i] == 0:\n\t\t\t\tq.append(i)\n\t\t\t\tvisited[i] = 1\n\t\t\t\ttab[i - 1] = tab[s - 1] + 1\n\treturn tab\n\nn, u, v = map(int, input().split())\nadj = d(list)\nfor i in range(n - 1):\n\ta, b = map(int, input().split())\n\tadj[a].append(b)\n\tadj[b].append(a)\n\ntakahashi = bfs(adj, u, n)\naoki = bfs(adj, v, n)\nres = -1\nfor i in range(n):\n\tif takahashi[i] <= aoki[i]:\n\t\tres = max(res, aoki[i] - 1)\n\nprint(res)", "n,u,v=map(int,input().split())\ntree=[[]for _ in range(n)]\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\nva=[-1]*n\nq=[v-1]\nva[v-1]=0\nwhile q:\n    x=q.pop()\n    for j in tree[x]:\n        if va[j]==-1:\n            q.append(j)\n            va[j]=va[x]+1\nq=[u-1]\nvt=[-1]*n\nvt[u-1]=0\nans=0\nwhile q:\n    x=q.pop()\n    ans=max(ans,va[x])\n    for j in tree[x]:\n        if vt[j]==-1:\n            if vt[x]+1<va[j]:\n                q.append(j)\n                vt[j]=vt[x]+1\n            elif vt[x]+1==va[j]:\n                vt[j]=vt[x]+1\nprint(ans-1)", "import sys\nsys.setrecursionlimit(10**7)\n\n\nn,u,v=list(map(int, input().split()))\nu-=1\nv-=1\n\ngraph = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    a, b=list(map(int, input().split()))\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\n# ab=[list(map(int, input().split())) for _ in range(n-1)]\n# for a,b in ab:\n#     graph[a-1].append(b-1)\n#     graph[b-1].append(a-1)\n\ndist=[[-1, -1] for _ in range(n)]\ndist[v][0]=0\ndist[u][1]=0\n\ndef dfs1(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][0]==-1:\n            dist[vvv][0]=dist[v][0]+1\n            dfs1(graph,vvv)\n\ndef dfs2(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][1]==-1:\n            dist[vvv][1]=dist[v][1]+1\n            dfs2(graph,vvv)\n\ndfs1(graph,v)\ndfs2(graph,u)\ndist.sort(reverse=True)\n\nfor i in range(10**6):\n    if dist[i][0]-dist[i][1]>=1:\n        print((dist[i][0]-1))\n        break\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    def bfs(start):\n        dist = [f_inf] * n\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            v = que.popleft()\n            for u in edge[v]:\n                if dist[u] == f_inf:\n                    dist[u] = dist[v] + 1\n                    que.append(u)\n        return dist\n\n    n, u, v = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n\n    distA = bfs(u - 1)\n    distT = bfs(v - 1)\n\n    res = 0\n    for i in range(n):\n        if distA[i] < distT[i]:\n            res = max(res, distT[i])\n    print((res - 1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**5)\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"\nPypy\u306f\u518d\u5e30\u304c\u9045\u3044\u3089\u3057\u3044\u306e\u3067Python\u3067\u901a\u3057\u3066\u307f\u308b\n\"\"\"\n\ndef main():\n    N, u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    repn = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = list(map(int, input().split()))\n        repn[a - 1].append((b - 1, i))\n        repn[b - 1].append((a - 1, i)) # (to, id)\n\n    \"\"\"\n    \u307e\u305au, v\u3092\u7d50\u3076\u5358\u7d14\u30d1\u30b9\u4e0a\u306b\u3042\u308bnode\u3092\u5217\u6319\u3059\u308b\u3002\n    \u3053\u308c\u306fv\u3092\u6839\u3068\u3059\u308b\u6839\u4ed8\u304d\u6728\u306b\u5bfe\u3059\u308bdfs\uff08\u518d\u5e30\uff09\u306b\u3088\u308a\u6c42\u307e\u308b\uff08\u53c2\u8003\uff1aABC152F\uff09\n    \"\"\"\n\n    path = []\n    def connected(v, tv, p=-1):\n        if v == tv:\n            return True\n        for w, _ in repn[v]:\n            if w == p:\n                continue\n            elif connected(w, tv, v):\n                path.append(w)\n                return True\n        return False\n    connected(v, u)\n    path.append(v)\n    #print(\"path={}\".format(path))\n\n    \"\"\"\n    \u6b21\u306bu, v\u3092\u7d50\u3076\u5358\u7d14\u30d1\u30b9P\u4e0a\u306e\u5404\u9802\u70b9w\u306b\u5bfe\u3057\u3066\u3001w\u304b\u3089P\u306b\u6cbf\u308f\u306a\u3044\u5411\u304d\u306b\u3069\u308c\u3060\u3051\u6df1\u304f\u6f5c\u308c\u308b\u304b\u3092\u6c42\u3081\u308b\u3002\n    \u3057\u304b\u3057\u6700\u7d42\u7684\u306b\u306f\u300c\u9802\u70b9v\u304b\u3089\uff08\u9ad8\u6a4b\u541b\u304c\u9003\u3052\u8fbc\u3081\u308b\u4e2d\u3067\uff09\u6700\u3082\u9060\u3044\u9802\u70b9\u300d\u3092\u6c42\u3081\u308c\u3070\u3088\u3044\u306e\u3067\u3001\n    uv\u306e\u4e2d\u70b9\u304b\u3089dfs\u3059\u308c\u3070\u5341\u5206\u3002\n    \"\"\"\n\n    def dfs(v, p): # P\u3068\u7570\u306a\u308b\u9802\u70b9\u65b9\u5411\u306bdfs\u3057\u3066\u6df1\u3055\u3092\u6c42\u3081\u308b\n        d = -1\n        for w, _ in repn[v]:\n            if w == p:\n                continue\n            else:\n                d = max(d, dfs(w, v))\n        return d + 1\n    \n    dist = len(path)\n    mid = path[dist // 2 - 1]\n    par = path[dist // 2]\n    ans = dfs(mid, par)\n    print((ans + (dist - 1) // 2))\n   \n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n \nN,u,v=map(int,input().split())\nG=[[] for _ in range(N)]\nfor _ in range(N-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n \ndef bfs(s):\n    seen = [0]*N\n    d = [0]*N\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    while len(todo):\n      a = todo.popleft()\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + 1\n    return d\n  \nd1 = bfs(u-1)\nd2 = bfs(v-1)\n \nprint(max([d2[i] for i in range(N) if d1[i]<=d2[i]])-1)", "import os\nimport sys\nimport numpy as np\n\ndef solve(N, U, V, AB):\n    G = [[] for _ in range(N+1)]\n    for ab in AB:\n        a, b = ab\n        G[a].append(b)\n        G[b].append(a)\n    P1 = np.zeros(N+1, dtype=np.int64)\n    def dfs1(u):\n        st = [u]\n        while st:\n            v = st.pop()\n            p = P1[v]\n            for u in G[v]:\n                if p != u:\n                    st.append(u)\n                    P1[u] = v\n    dfs1(U)\n    path_u2v = [U]\n    v = V\n    while v != U:\n        v = P1[v]\n        path_u2v.append(v)\n    path_u2v.reverse()\n    l = len(path_u2v)\n    half = (l-2) // 2\n    c = path_u2v[half]\n    ng = path_u2v[half+1]\n    Depth = np.zeros(N+1, dtype=np.int64)\n    def dfs2(c):\n        st = [c]\n        P = np.zeros(N+1, dtype=np.int64)\n        while st:\n            v = st.pop()\n            p = P[v]\n            d = Depth[v]\n            for u in G[v]:\n                if p != u and u != ng:\n                    st.append(u)\n                    P[u] = v\n                    Depth[u] = d + 1\n    dfs2(c)\n    c_ = path_u2v[l-1-half]\n    v = c_\n    while v != c:\n        Depth[v] = 0\n        v = P1[v]\n    d = l%2\n    ans = max(Depth) + half + d\n    return ans\n\ndef main():\n    N, u, v = list(map(int, input().split()))\n    if N==2:\n        print((0))\n        return\n    AB = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(N-1, 2)\n    ans = solve(N, u, v, AB)\n    print(ans)\n\nmain()\n", "import sys\ndef input():\n    return sys.stdin.readline().strip()\n\nn, u, v = map(int, input().split())\nu, v = u-1, v-1\n\ntree = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\nfrom queue import Queue\n\n# \u9752\u6728\u541b\u306b\u3088\u308bWFS\naoki = [-1 for _ in range(n)]\naoki[v] = 0\ntodo = Queue()\ntodo.put(v)\nwhile not todo.empty():\n    i = todo.get()\n    for j in tree[i]:\n        if aoki[j] == -1:\n            todo.put(j)\n            aoki[j] = aoki[i] + 1\n\n# \u9ad8\u6a4b\u541b\u306b\u3088\u308bWFS\ntaka = [-1 for _ in range(n)]\ntaka[u] = 0\ntodo = Queue()\ntodo.put(u)\nwhile not todo.empty():\n    i = todo.get()\n    for j in tree[i]:\n        if taka[j] == -1:\n            if taka[i] + 1 < aoki[j]:\n                todo.put(j)\n            taka[j] = taka[i] + 1\n\n# search\nans = 0\nfor i in range(n):\n    if taka[i] != -1:\n        if aoki[i] - 1 > ans:\n            ans = aoki[i] - 1\n\nprint(ans)", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**7)\n\nn, u, v = map(int, input().split())\n\ngraph = defaultdict(list)\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n\ndef dfs(u):\n    dist = [-1] * (n + 1)\n    stack = [u]\n    dist[u] = 0\n    while stack:\n        u = stack.pop()\n        nxt = dist[u] + 1\n        for v in graph[u]:\n            if dist[v] >= 0:\n                continue\n            dist[v] = nxt\n            stack.append(v)\n    return dist\n\n\ndist_u = dfs(u)\ndist_v = dfs(v)\n\n# \u9ad8\u6a4b\u304f\u3093\uff08u\uff09\u306e\u65b9\u304c\u8fd1\u3044\u9802\u70b9\u306e\u3046\u3061\u3001\u9752\u6728\u304f\u3093\uff08v\uff09\u304b\u3089\u6700\u3082\u9060\u3044\u9802\u70b9\u306e\u4e00\u3064\u624b\u524d\nans = 0\nfor x, y in zip(dist_u, dist_v):\n    if x < y:\n        ans = max(ans, y - 1)\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\nf=lambda:map(int,input().split())\nn,st,sa=f()\nst-=1\nsa-=1\ng=[[] for _ in range(n)]\nfor _ in range(n-1):\n  a,b=f()\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\ndef dfs(v,p=-1,d=0):\n  l[v]=d\n  for c in g[v]:\n    if c==p: continue\n    dfs(c,v,d+1)\ndef dist(s):\n  nonlocal l\n  l=[0]*n\n  dfs(s)\n  return l\nlt=dist(st)\nla=dist(sa)\nm=0\nfor i in range(n):\n  if lt[i]<la[i]: m=max(m,la[i])\nprint(m-1)", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, ta, ao, *AB = list(map(int, read().split()))\n    ta -= 1\n    ao -= 1\n\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    dist_ta = [-1] * N\n    dist_ta[ta] = 0\n    queue = deque([ta])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist_ta[nv] == -1:\n                dist_ta[nv] = dist_ta[v] + 1\n                queue.append(nv)\n\n    dist_ao = [-1] * N\n    dist_ao[ao] = 0\n    queue = deque([ao])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist_ao[nv] == -1:\n                dist_ao[nv] = dist_ao[v] + 1\n                queue.append(nv)\n\n    d_ao = 0\n    for d1, d2 in zip(dist_ta, dist_ao):\n        if d1 < d2 and d_ao < d2:\n            d_ao = d2\n\n    if d_ao == 0:\n        if dist_ta[ao] == 1:\n            print((0))\n        else:\n            print((1))\n\n    print((d_ao - 1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**8)\nN,U,V = map(int,input().split())\nU,V = U-1,V-1\nAB = [tuple(map(int,input().split())) for i in range(N-1)]\nes = [[] for _ in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n    es[b].append(a)\n\nprev = [-1] * N\ndef dfs(v,p=-1):\n    for to in es[v]:\n        if to==p: continue\n        prev[to] = v\n        dfs(to,v)\ndfs(U)\n\npath = [V]\nwhile prev[path[-1]] >= 0:\n    path.append(prev[path[-1]])\nban = set(path[:(len(path)+1)//2])\n\nreach = [0] * N\nreach[U] = 1\ndef dfs2(v,p=-1):\n    for to in es[v]:\n        if to==p: continue\n        if to in ban: continue\n        reach[to] = 1\n        dfs2(to,v)\ndfs2(U)\n\ndepth = [0] * N\nans = 0\ndef dfs3(v,p=-1):\n    nonlocal ans\n    for to in es[v]:\n        if to==p: continue\n        depth[to] = depth[v] + 1\n        if reach[to]:\n            ans = max(ans, depth[v])\n        dfs3(to,v)\ndfs3(V)\n\nprint(ans)", "from collections import deque\nimport sys\nsi = sys.stdin.readline\n\n\ndef BFS(g, s):\n    d = 0\n    dt = dict()\n    visited = set()\n    visited.add(s)\n    Q = deque([s])\n\n    while len(Q):\n        d += 1\n        Qs = len(Q)\n        for _ in range(Qs):\n            Qpop = Q.popleft()\n            for node in g[Qpop]:\n                if node not in visited:\n                    Q.append(node)\n                    visited.add(node)\n                    dt[node] = d\n    return dt\n\n\ndef main():\n    l = [int(e) for e in si().split()]\n    n, u, v = l[0], l[1], l[2]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        l = [int(e) for e in si().split()]\n        graph[l[0]].append(l[1])\n        graph[l[1]].append(l[0])\n\n    udt = BFS(graph, u)\n    vdt = BFS(graph, v)\n    udt[u], vdt[v] = 0, 0\n\n    vdmax = 0\n    for i in range(1, n+1):\n        if (vdt[i]-udt[i]) > 0 and vdt[i] > vdmax:\n            vdmax = vdt[i]\n    print((vdmax-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom collections import deque\n\ndef main():\n    N, u, v = map(int, input().split())\n    s = u-1\n    t = v-1\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(lambda x: int(x)-1, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # aoki BFS\n    queue = deque([t])\n    visit = [-1] * N\n    visit[t] = 0\n    \n    while queue:\n        now = queue.popleft()\n        for u in adj[now]:\n            if visit[u] < 0:\n                queue.append(u)\n                visit[u] = visit[now] + 1\n                # parent[u] = now\n\n    # takahashi BFS\n    queue = deque([s])\n    visit2 = [-1] * N\n    # parent = [-1] * N\n    visit2[s] = 0\n    \n    \n    while queue:\n        now = queue.popleft()\n        for u in adj[now]:\n            if visit2[u] < 0:\n                queue.append(u)\n                visit2[u] = visit2[now] + 1\n\n    ans = [-1,-1]\n    # print(visit, visit2)\n    for i in range(N):\n        if visit[i] >= visit2[i] and visit[i] > ans[0]:\n            ans = [visit[i], i]\n    \n    print(visit[ans[1]]-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "# even faster by using a comprehensive list at the end\n\nfrom collections import deque\nimport sys\nsi = sys.stdin.readline\n\n\ndef BFS(g, n, s):\n    d = 0\n    dt = [0 for _ in range(n+1)]\n    dt[s] = 0\n    visited = set()\n    visited.add(s)\n    Q = deque([s])\n\n    while len(Q):\n        d += 1\n        Qs = len(Q)\n        for _ in range(Qs):\n            Qpop = Q.popleft()\n            for node in g[Qpop]:\n                if node not in visited:\n                    Q.append(node)\n                    visited.add(node)\n                    dt[node] = d\n    return dt[1:]\n\n\ndef main():\n    l = [int(e) for e in si().split()]\n    n, u, v = l[0], l[1], l[2]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        l = [int(e) for e in si().split()]\n        graph[l[0]].append(l[1])\n        graph[l[1]].append(l[0])\n\n    udt = BFS(graph, n, u)\n    vdt = BFS(graph, n, v)\n    print((-1+max([v for u, v in zip(udt, vdt) if u < v])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom collections import deque\ndef main():\n    n, u, v = map(int,input().split())\n    if u == v:\n        print(0)\n        return\n\n    graph = [[] for _ in range(n)]\n    depth_u = [-1] * (n) #\u9802\u70b9i\u306eu\u304b\u3089\u898b\u305f\u6df1\u3055\n    depth_v = [-1] * (n) #\u9802\u70b9i\u306ev\u304b\u3089\u898b\u305f\u6df1\u3055\n    u -= 1 #\u9ad8\u6a4b\n    v -= 1 #\u9752\u6728\n    for i in range(n-1):\n        a, b = map(int,input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    \n    # bfs\u3067\u9ad8\u6a4b\u304b\u3089\u898b\u305f\u5404\u9802\u70b9\u306e\u6df1\u3055\u3092\u30e1\u30e2\u308b\u3002\n    queue = deque([u])\n    visited = [False]*n\n    visited[u] = True\n    depth_u[u] = 0\n    while queue:\n        node = queue.popleft()\n        for xnode in graph[node]:\n            if not visited[xnode]:\n                visited[xnode] = True\n                depth_u[xnode] = depth_u[node] + 1\n                queue.append(xnode)\n    # bfs\u3067\u9752\u6728\u304b\u3089\u898b\u305f\u5404\u9802\u70b9\u306e\u6df1\u3055\u3092\u30e1\u30e2\u308b\u3002\n    queue = deque([v])\n    visited = [False]*n\n    visited[v] = True\n    depth_v[v] = 0\n    while queue:\n        node = queue.popleft()\n        for xnode in graph[node]:\n            if not visited[xnode]:\n                visited[xnode] = True\n                depth_v[xnode] = depth_v[node] + 1\n                queue.append(xnode)\n    ans = 0\n    max_d_v = 0\n    for i in range(n):\n        if depth_u[i] < depth_v[i]:\n            max_d_v = max(max_d_v, depth_v[i])\n    print(max_d_v - 1)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, S, T = list(map(int, input().split()))\nS -= 1\nT -= 1\n\nedges = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    fr, to = [int(a) - 1 for a in input().split()]\n    edges[fr].append(to)\n    edges[to].append(fr)\n\ndef calc(s):\n    minDist = [10**18] * N\n    minDist[s] = 0\n    st = [s]\n    while st:\n        now = st.pop()\n        d = minDist[now] + 1\n        for to in edges[now]:\n            if minDist[to] > d:\n                minDist[to] = d\n                st.append(to)\n\n    return minDist\n\nminDistS = calc(S)\nminDistT = calc(T)\n\nans = 0\nfor s, t in zip(minDistS, minDistT):\n    if s <= t:\n        ans = max(ans, t - 1)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\n\nn, u, v = map(int, input().split())\nu, v = u-1, v-1\nedges = [[] for i in range(n)]\nfor i in range(n-1):\n    ai, bi = map(int, input().split())\n    ai, bi = ai-1, bi-1\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n\ndef dfs(already, node, depth):\n    depth += 1\n    children = edges[node]\n    for child in children:\n        if already[child] == 0:\n            already[child] = depth\n            already = dfs(already, child, depth)\n    return already\n\nalready_u = [0 for i in range(n)]\nalready_u[u] = -1\nalready_u = dfs(already_u, u, 0)\nalready_u[u] = 0\nalready_v = [0 for i in range(n)]\nalready_v[v] = -1\nalready_v = dfs(already_v, v, 0)\nalready_v[v] = 0\n\nmaxi = 0\nfor i in range(n):\n    if already_u[i] < already_v[i]:\n        maxi = max(maxi, already_v[i])\nprint(maxi-1)", "from collections import deque\nN,U,V = map(int, input().split())\nU,V = U-1, V-1\nE = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n  a,b = map(int, input().split())\n  a,b = a-1, b-1\n  E[a].append(b)\n  E[b].append(a)\n\ndef BFS(root):\n  D = [ 0 for _ in range(N) ]\n  visited = [False for _ in range(N)]\n  willSearch = [ False for _ in range(N)]\n  Q = deque()\n  Q.append(root)\n  willSearch[root] = True\n  while len(Q) > 0:\n    now = Q.pop()\n    visited[now] = True\n    for nx in E[now]:\n      if visited[nx] or willSearch[nx]:\n        continue\n      willSearch[nx] = True\n      D[nx] = D[now] + 1\n      Q.append(nx)\n  return D\n\nUD = BFS(U)\nVD = BFS(V)\n\n#print(UD)\n#print(VD)\n\n#\u521d\u624b\u3067\u9752\u6728\u304f\u3093\u306ePOINT\u306b\u3057\u304b\u884c\u3051\u306a\u3044\u30b1\u30fc\u30b9\nif E[U] == [V]:\n  print(0)\n  return\n  \nans=0\n \nfor i in range(N):\n    if UD[i]<=VD[i]:\n        ans=max(ans,VD[i]-1)\n\nprint(ans)", "import sys\nimport  math\nimport fractions\nfrom collections import deque\nfrom collections import defaultdict\nstdin = sys.stdin\n     \nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n\nN,u,v=nm()\nu=u-1\nv=v-1\nINF=10**18\nedge=[[] for i in range(N)]\n\ndef bfs(start,edge):\n    d=[INF]*N\n    d[start]=0\n    q=deque([start])\n    while (q):\n        e=q.popleft()\n        for i in edge[e]:\n            if(d[e]+1<d[i]):\n                d[i]=d[e]+1\n                q.append(i)   \n    return d\n\n\nfor i in range(N-1):\n    A,B=nm()\n    edge[B-1].append(A-1)\n    edge[A-1].append(B-1)\n\n\nd_A=bfs(u,edge)\nd_B=bfs(v,edge)\n\nans=0\nfor i in range(N):\n    #if(d_A[0]%2==d_B[0]%2):\n    #    continue\n    #else:\n    if(d_A[i]<d_B[i]):\n        tmp=max(d_A[i],d_B[i])\n        ans=max(ans,tmp)\n\nprint((ans-1))\n", "#!/usr/bin/env python3\n\ndef main():\n    n, u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # uv\u9593\u7d4c\u8def\u3092\u6c42\u3081\u308b\n    st = [u]\n    prev = [None for i in range(n)]\n    while st:\n        x = st.pop()\n        for y in adj[x]:\n            if y == prev[x]: continue\n            prev[y] = x\n            st.append(y)\n    path = [v]\n    while path[-1] != u:\n        path.append(prev[path[-1]])\n    path = list(reversed(path))\n\n    # cross\u304b\u3089square\u3092\u7d4c\u7531\u3057\u306a\u3044\u6700\u9060\u30ce\u30fc\u30c9star\u3092\u6c42\u3081\u308b\uff08a59p22\uff09\n    l = len(path) - 1\n    cross = path[(l - 1) // 2]\n    square = path[(l - 1) // 2 + 1]\n    st = [(cross, 0)]\n    prev = [None for i in range(n)]\n    dist = [-1 for i in range(n)]\n    while st:\n        x, d = st.pop()\n        dist[x] = d\n        for y in adj[x]:\n            if y == prev[x]: continue\n            if y == square: continue\n            prev[y] = x\n            st.append((y, d + 1))\n    star_square = max(dist)\n\n    if l % 2 == 1:\n        res = (l - 1) // 2 + star_square\n    else:\n        res = (l - 1) // 2 + star_square + 1\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nINF = float('inf')\n\nN, u, v = list(map(int, input().split()))\nu, v = u-1, v-1\nadjL = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    adjL[a].append(b)\n    adjL[b].append(a)\n\ndef bfsMinCosts(adjList, vSt, INF):\n    numV = len(adjList)\n    costs = [INF] * numV\n    costs[vSt] = cost = 0\n    vs = [vSt]\n    while vs:\n        cost += 1\n        v2s = []\n        for v in vs:\n            for v2 in adjList[v]:\n                if costs[v2] == INF:\n                    costs[v2] = cost\n                    v2s.append(v2)\n        vs = v2s\n    return costs\n\ncostUs = bfsMinCosts(adjL, u, INF)\ncostVs = bfsMinCosts(adjL, v, INF)\n\nans = 0\nfor x in range(N):\n    if costUs[x] < costVs[x]:\n        if costVs[x] > ans:\n            ans = costVs[x]\n\nprint((ans-1))\n", "import sys\nsys.setrecursionlimit(10**8)\nN,U,V = map(int,input().split())\nU,V = U-1,V-1\nAB = [tuple(map(int,input().split())) for i in range(N-1)]\nes = [[] for _ in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n    es[b].append(a)\n\ndist1 = [N] * N\ndist1[V] = 0\ndef dfs1(v,p=-1):\n    for to in es[v]:\n        if to==p: continue\n        dist1[to] = dist1[v] + 1\n        dfs1(to,v)\ndfs1(V)\n\nD = dist1[U]\n\ndist2 = [N] * N\ndist2[U] = 0\ndef dfs2(v,p=-1):\n    for to in es[v]:\n        if to==p: continue\n        if (D+1)//2 > dist1[to]: continue\n        dist2[to] = dist2[v] + 1\n        dfs2(to,v)\ndfs2(U)\n\nans = 0\nfor a,b in zip(dist1,dist2):\n    if b==N: continue\n    ans = max(ans, a-1)\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(v,p,d):\n    dist[v]=d\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,d+1)\n        \ndef getSP(v):\n    p=v\n    if dist[v]==lim:\n        return p\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            p=getSP(nv)\n    return p\n    \ndef depth(v,p,d):\n    nonlocal maxd\n    maxd=max(maxd,dist[v])\n    for nv in G[v]:\n        if dist[nv]<dist[v]:\n            continue\n        depth(nv,v,d+1)\n    \nN,u,v=map(int,input().split());u,v=u-1,v-1\nif u==v:\n    print(0)\n    return\n\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    G[a].append(b)\n    G[b].append(a)\n    \ndist=[-1]*N\ndfs(v,-1,0)\n\nlim=dist[u]-(dist[u]-1)//2\nSP=getSP(u)\n \nmaxd=-1\ndepth(SP,-1,0)\n\nprint(maxd-1)", "import collections\n\nn,u,v=map(int,input().split())\ng=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n  a,b=map(int,input().split())\n  g[a].append(b)\n  g[b].append(a)\nq=collections.deque()\nq.append((v,0))\nchecked=[0]*(n+1)\ndist1=[0]*(n+1)\nwhile len(q)!=0:\n  tv,td=q.popleft()\n  checked[tv]=1\n  dist1[tv]=td\n  for tu in g[tv]:\n    if checked[tu]==1:\n      continue\n    q.append((tu,td+1))\nq=collections.deque()\nq.append((u,0))\nchecked=[0]*(n+1)\ndist2=[0]*(n+1)\nwhile len(q)!=0:\n  tv,td=q.popleft()\n  checked[tv]=1\n  dist2[tv]=td\n  for tu in g[tv]:\n    if checked[tu]==1:\n      continue\n    q.append((tu,td+1))\nans=0\nfor tv in range(1,n+1):\n  if dist1[tv]>dist2[tv]:\n    ans=max(ans,dist1[tv]-1)\nprint(ans)", "import sys\nsys.setrecursionlimit(1000000000)\n\nn,u,v = map(int,input().split())\nu -= 1\nv -= 1\nG = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\ndistT = [-1]*n\ndistA = [-1]*n\ndistT[u] = 0\ndistA[v] = 0\ndef dfs(now,dist):\n    for nxt in G[now]:\n        if dist[nxt] != -1: continue\n        dist[nxt] = dist[now]+1\n        dfs(nxt,dist)\ndfs(u,distT)\ndfs(v,distA)\n\nmx = 0\nfor i in range(n):\n    if distT[i] < distA[i]:\n        mx = max(mx, distA[i])\nans = mx-1\nprint(ans)", "import copy\nfrom collections import deque\n\nn, st, sa = map(int,input().split())\nst -= 1\nsa -= 1\n\ne = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    e[a].append(b)\n    e[b].append(a)\n\nvisited = [False] * n\nvisited[st] = True\nd = deque()\nd.append([st, 0])\ntx = {}\nif len(e[st]) == 1:\n    tx[st] = 0\ncnt = 0\nwhile d:\n    f, cnt = d.popleft()\n    flg = True\n    for t in e[f]:\n        if not visited[t]:\n            flg = False\n            d.append([t, cnt+1])\n            visited[t] = True\n    if flg:\n        tx[f] = cnt\n\nvisited = [False] * n\nvisited[sa] = True\nd = deque()\nd.append([sa, 0])\nax = {}\nif len(e[sa]) == 1:\n    ax[sa] = 0\ncnt = 0\nwhile d:\n    f, cnt = d.popleft()\n    flg = True\n    for t in e[f]:\n        if not visited[t]:\n            flg = False\n            d.append([t, cnt+1])\n            visited[t] = True\n    if flg:\n        ax[f] = cnt\n\nax = sorted(ax.items(), key=lambda x:x[1], reverse=True)\nfor i in range(len(ax)):\n    x, d = ax[i][0], ax[i][1]\n    if d > tx[x]:\n        ans = d - 1\n        break\n\nprint(ans)", "from collections import deque\n\nn, u, v = map(int, input().split())\ntree = [[] for _ in range(n)]\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  tree[a-1].append(b-1)\n  tree[b-1].append(a-1)\n\nnot_yet = deque([u-1])\nalready = [False]*n\nalready[u-1] = True\ndist = [0]*n\n\nwhile not_yet:\n  key = not_yet.popleft()\n  for value in tree[key]:\n    if already[value]:\n      continue\n    dist[value] = dist[key] + 1\n    already[value] = True\n    not_yet.append(value)\n  \nnot_yet = deque([v-1])\nalready = [False]*n\nalready[v-1] = True\ndist2 = [0]*n\n\nwhile not_yet:\n  key = not_yet.popleft()\n  for value in tree[key]:\n    if already[value]:\n      continue\n    dist2[value] = dist2[key] + 1\n    already[value] = True\n    not_yet.append(value)\n\njudge = dist[v-1]\nans = 0\nfor i in range(n):\n  if dist[i]+dist2[i] > judge:\n    if dist[i] >= dist2[i]:\n      continue\n    sub = dist2[i]-1\n  else:\n    sub = judge-1\n  if sub > ans:\n    ans = sub\nprint(ans)", "def dfs(c,lst):\n n=len(lst)\n ans=[0]*n\n stack = [c-1]\n check = [0]*n #\u30c1\u30a7\u30c3\u30af\u6e08\u307f\u30ea\u30b9\u30c8\n while stack != [] :\n  d=stack.pop()\n  if check[d]==0:\n   check[d]=1\n   for i in lst[d]:\n    if check[i]==0:\n     stack.append(i)\n     ans[i]=ans[d]+1\n return(ans)\nimport sys\ninput = sys.stdin.readline\nN,u,v=list(map(int,input().split()))\nki=[[] for f in range(N)]\nfor i in range(N-1):\n a,b = list(map(int,input().split()))\n ki[a-1].append(b-1)\n ki[b-1].append(a-1)\nU=dfs(u,ki)\nV=dfs(v,ki)\nans=0\nfor i in range(N):\n if V[i]>U[i]:\n  ans=max(ans,V[i]-1)\nprint(ans)\n", "import sys\nreadline = sys.stdin.readline\n\n# \u9752\u6728\u541b\u304b\u3089\u306e\u5230\u9054\u8ddd\u96e2 - \u9ad8\u6a4b\u541b\u304b\u3089\u306e\u5230\u9054\u8ddd\u96e2\u304c\u6700\u3082\u5927\u304d\u3044\u5834\u6240\u306b\u9003\u3052\u308b\u3079\u304d\n# \u305d\u3053\u306b\u5230\u9054\u3057\u305f\u3068\u304d\u306b\u3001\n# \u9ad8\u6a4b\u541b\u3068\u9752\u6728\u541b\u306e\u8ddd\u96e2\u304c\u5076\u6570\u306e\u3068\u304d\n# \u9752 - x - x - x - \u9ad8\n# \u9752 - x - x - \u9ad8 - x\n# x - \u9752 - x - \u9ad8 - x\n# x - \u9752 - x - x - \u9ad8\n# x - x - \u9752 - x - \u9ad8\n# x - x - \u9752- \u9ad8 - x \n# x - x - x - \u7d42 - x \n# \u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2 - 1\u304c\u7b54\u3048\n# \u9ad8\u6a4b\u541b\u3068\u9752\u6728\u541b\u306e\u8ddd\u96e2\u304c\u5947\u6570\u306e\u3068\u304d\n# \u9752 - x - x - \u9ad8\n# \u9752 - x - \u9ad8 - x\n# x - \u9752 - \u9ad8 - x\n# x - \u9752 - x - \u9ad8\n# x - x - \u9752 - \u9ad8\n# x - x - \u7d42 - x\n# \u3084\u3063\u3071\u308a\u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2 - 1\u304c\u7b54\u3048\n# \u3064\u307e\u308a\u3001\n# \u30fb[\u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2\u304c\u9060\u3044\u5834\u6240\u306b\u3064\u3044\u3066]\n# \u30fb[\u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2 - 1]\u304c\u7b54\u3048\n\nN,u,v = list(map(int,readline().split()))\nG = [[] for i in range(N)]\nfor i in range(N - 1):\n  a,b = list(map(int,readline().split()))\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n\ndist_from_u = [0 for i in range(N)] # \u9ad8\u6a4b\u541b\u304b\u3089\u306e\u8ddd\u96e2\ndist_from_v = [0 for i in range(N)] # \u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2\n\nstack = []\n# \u9802\u70b9, \u9ad8\u6a4b\u541b\u304b\u3089\u306e\u8ddd\u96e2, \u89aa\nstack.append([u - 1,0,-1])\nwhile stack:\n  e, dist, parent = stack.pop()\n  dist_from_u[e] = dist\n  for child in G[e]:\n    if child == parent:\n      continue\n    stack.append([child, dist + 1, e])\n\nstack = []\n# \u9802\u70b9, \u9752\u6728\u541b\u304b\u3089\u306e\u8ddd\u96e2, \u89aa\nstack.append([v - 1,0,-1])\nwhile stack:\n  e, dist, parent = stack.pop()\n  dist_from_v[e] = dist\n  for child in G[e]:\n    if child == parent:\n      continue\n    stack.append([child, dist + 1, e])\n    \nmaxdiff_from_v = 0\nfor i in range(N):\n  if dist_from_u[i] < dist_from_v[i]:\n    if maxdiff_from_v < dist_from_v[i]:\n      maxdiff_from_v = dist_from_v[i]\n    \nprint((maxdiff_from_v - 1))\n", "import sys\nsys.setrecursionlimit(1<<30)\ndef dfs(x,dis):\n    for y in Tree[x]:\n        if parent[x] != y:\n            parent[y] = x\n            dis[y] = dis[x]+1\n            dfs(y,dis)\n\nN,u,v = map(int,input().split())\nTree = [[] for _ in range(N+1)]\nfor i in range(N-1):\n    A,B = map(int,input().split())\n    Tree[A].append(B)\n    Tree[B].append(A)\ndisT = [-1]*(N+1)\ndisA = [-1]*(N+1)\ndisT[u] = 0\ndisA[v] = 0\nparent = [-1]*(N+1)\ndfs(u,disT)\nparent = [-1]*(N+1)\ndfs(v,disA)\nans = 0\nfor i in range(1,N+1):\n    if disT[i] <= disA[i]:\n        ans = max(ans,disA[i]-1)\nprint(ans)", "# F - Playing Tag on Tree\n# https://atcoder.jp/contests/abc148/tasks/abc148_f\n\nfrom heapq import heappop, heappush\n\nINF = float(\"inf\")\n\ndef dijkstra(n, G, s):\n    dist = [INF] * n\n    dist[s] = 0\n    hq = [(0, s)]\n    while hq:\n        d, v = heappop(hq)\n        if dist[v] < d:\n            continue\n        for child, child_d in G[v]:\n            if dist[child] > dist[v] + child_d:\n                dist[child] = dist[v] + child_d\n                heappush(hq, (dist[child], child))\n    return dist\n\nn, u, v = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\n\nedge = [list(map(int, input().split())) for _ in range(n - 1)]\n\nfor a, b in edge:\n    graph[a - 1].append((b - 1, 1))\n    graph[b - 1].append((a - 1, 1))\n\nfrom_u = dijkstra(n, graph, u - 1)\nfrom_v = dijkstra(n, graph, v - 1)\n\n# print(from_u)\n# print(from_v)\n\nfil = [x for x in [[fu, fv] for fu, fv in zip(from_u, from_v)] if x[0] < x[1]]\nsfil = sorted(list(fil), key=lambda x: [-x[1], -x[0]])  \n\n# print(sfil)\n\nprint((sfil[0][1] - 1))\n", "import copy\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef dfs(G, v, p, d, depth):\n    depth[v] = d\n    for nv in G[v]:\n        if nv == p:\n            continue\n        dfs(G, nv, v, d+1, depth)\n    return G, depth\n\n\nn, T, A = map(int,input().split())\nT, A = T-1, A-1\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int,input().split())\n    x, y = x-1, y-1\n    g[x].append(y)\n    g[y].append(x)\n\ndepth = [0]*n\nGT = copy.deepcopy(g)\nGT[T].append(-1)\nGT, dt = dfs(GT, T, -1, 0, depth)\n\ndepth = [0]*n\nGA = copy.deepcopy(g)\nGA[A].append(-1)\nGA, da = dfs(GA, A, -1, 0, depth)\n\nans = 0\nfor t, a in zip(dt, da):\n    if t <= a:\n        ans = max(ans, a)\nprint(ans-1)", "import sys\nsys.setrecursionlimit(10**6)\nn, u, v = map(int, input().split())\nu -= 1\nv -= 1\ngraph = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\npre = [None]*n\ndef dfs(node, p_node=-1):\n    for c_node in graph[node]:\n        if c_node==p_node:\n            continue\n        pre[c_node] = node\n        dfs(c_node, node)\ndfs(u)\npath = [v]\nnow = v\nwhile now!=u:\n    now = pre[now]\n    path.append(now)\ns1 = path[len(path)//2]\np1 = path[len(path)//2-1]\ndef dfs2(node, depth, p_node):\n    mx = depth\n    for c_node in graph[node]:\n        if c_node==p_node:\n            continue\n        mx = max(mx, dfs2(c_node, depth+1, node))\n    return mx\nprint(dfs2(s1, 0, p1)+len(path)//2-1)", "import sys\nsys.setrecursionlimit(1<<30)\ndef dfs(x, dis):\n    for y in Tree[x]:\n        if parent[y] != x:\n            parent[x] = y\n            dis[y] = dis[x] + 1\n            dfs(y, dis)\nN, u, v = map(int,input().split())\nTree = [[] for _ in range(N+1)]\nfor i in range(N-1):\n    A, B = map(int,input().split())\n    Tree[A].append(B)\n    Tree[B].append(A)\ndisT = [-1]*(N+1)\ndisA= [-1]*(N+1)\ndisT[u] = 0\ndisA[v] = 0\nparent = [-1]*(N+1)\ndfs(u, disT)\nparent = [-1]*(N+1)\ndfs(v, disA)\nAns = 0\nfor i in range(len(disA)):\n    if disA[i] >= disT[i]:\n        Ans = max(Ans, disA[i]-1)\nprint(Ans)", "n,u,v=map(int,input().split())\nu-=1;v-=1\nki=[[] for _ in range(n)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  ki[a-1].append(b-1)\n  ki[b-1].append(a-1)\nha=[]\nfor i in range(n):\n  if len(ki[i])==1:\n    ha.append(i)\nta=[0]*n\nao=[0]*n\nfrom collections import deque\nd=deque()\nd.append(u)\nvisited=[False]*n\nvisited[u]=True\nwhile d:\n  g=d.popleft()\n  for i in ki[g]:\n    if visited[i]:\n      continue\n    d.append(i)\n    visited[i]=True\n    ta[i]=ta[g]+1\nd=deque()\nd.append(v)\nvisited=[False]*n\nvisited[v]=True\nwhile d:\n  g=d.popleft()\n  for i in ki[g]:\n    if visited[i]:\n      continue\n    d.append(i)\n    visited[i]=True\n    ao[i]=ao[g]+1\nif u in ha and ki[u][0]==v:\n  print(0)\n  return\nm=0\nfor i in ha:\n  if ta[i]<ao[i]:\n    m=max(m,ao[i])\nprint(m-1)", "import sys\nsys.setrecursionlimit(10**6)\n \nN,u,v = map(int,input().split())\nedges = [list(map(int,input().split())) for _ in range(N-1)]\nE = [[] for _ in range(N+1)]\nfor a,b in edges:\n    E[a].append(b)\n    E[b].append(a)\n \ndepth = [[-1,-1] for _ in range(N+1)] \ndepth[v][0] = 0\ndepth[u][1] = 0\n\ndef dfs1(E,v):\n    vv = E[v]\n    for vvv in vv:\n        if depth[vvv][0] == -1:\n            depth[vvv][0] = depth[v][0] + 1\n            dfs1(E,vvv)\n \ndef dfs2(E,v):\n    vv = E[v]\n    for vvv in vv:\n        if depth[vvv][1] == -1:\n            depth[vvv][1] = depth[v][1] + 1\n            dfs2(E,vvv)\ndfs1(E,v)\ndfs2(E,u)\ndepth = sorted(depth, reverse=True)\nidx = 0\nwhile True:\n    if depth[idx][0] - depth[idx][1] >= 1:\n        print(depth[idx][0]-1)\n        return\n    else:\n        idx += 1", "import sys\nrd = sys.stdin.readline\n\nsys.setrecursionlimit(10000000)\n\nn,T,A = map(int,rd().split())\nT,A = T-1,A-1\n\ngraph = [[] for _ in range(n)]\nfor i in range(n-1):\n    a,b = map(int,rd().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)  # \u6709\u5411\u30b0\u30e9\u30d5\u306a\u3089\u6d88\u3059\n\ndef dfs(v,p=-1):\n    deg = len(graph[v])\n    if v == T:\n        root.append(v)\n        return True\n    if deg == 1 and v != A:\n        return False\n    ok = False\n    for i in range(deg):\n        u = graph[v][i]\n        if u == p:\n            continue\n        if dfs(u,v):\n            root.append(v)\n            ok = True\n    return ok\n\ndef dfs2(v,p=-1):\n    deg = len(graph[v])\n    if deg == 1 and v != root[x]:\n        return 0\n    depth = 0\n    for i in range(deg):\n        u = graph[v][i]\n        if u == p:\n            continue\n        d = dfs2(u,v)\n        depth = max(depth,d+1)\n    return depth\n\nroot = []\ndfs(A)\nx = len(root)//2 - 1\n\ndp = [0]*n\nans = (len(root))//2 + dfs2(root[x],root[x+1])\nif len(root)%2 == 0:\n    ans -= 1\nprint(ans)", "N, u, v = map(int, input().split())\nu -= 1\nv -= 1\ntonari = [[] for _ in range(N)]\nfor _ in range(N-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  tonari[a].append(b)\n  tonari[b].append(a)\n\nd_from_u = [float('inf') for _ in range(N)]\nd_from_v = [float('inf') for _ in range(N)]\nd_from_u[u] = 0\nd_from_v[v] = 0\n#print(tonari)\nnow = [v] #\u8ffd\u3044\u304b\u3051\u308b\u65b9\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_v[t] > d:\n        d_from_v[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\n\n\nnow = [u] #\u9003\u3052\u308b\u65b9\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_v[t] <= d: #\u8ffd\u3044\u304b\u3051\u308b\u65b9\u3088\u308a\u9060\u3044\u5730\u70b9\u306f\u6392\u9664\n        continue\n      elif d_from_u[t] > d:\n        d_from_u[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\n\ndistance = []\nfor U, V in zip(d_from_u, d_from_v):\n  if U < N+1: #inf\u3092\u6392\u9664\n    distance.append((U, V))\n\nif distance:\n  ans = max(distance, key= lambda x: x[1])[1] - 1\nelse:\n  ans = 0\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\nN,T,A = list(map(int,input().split())); INF = float(\"inf\")\nT-=1;A-=1 #0index\nG = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = list(map(int,input().split()))\n  a-=1;b-=1 #0index\n  G[a].append(b);G[b].append(a)\n\ndisT = [INF for _ in range(N)]; disT[T] = 0\ndisA = [INF for _ in range(N)]; disA[A] = 0\n\ndef dfs(v, L):\n  for u in G[v]:\n    if L[u] != INF:\n      continue\n    L[u] = L[v]+1\n    dfs(u,L)\ndfs(T,disT)\ndfs(A,disA)\n#print(disT)\n#print(disA)\nans = 0\nfor i in range(N):\n  if disT[i] < disA[i]:\n    ans = max(ans,disA[i]-1)\nprint(ans)\n", "from collections import deque\n\n\ndef calc_dist(head, my_dict, dist_a):\n    deq = deque()\n    deq.append((head, 0))\n    visited = set()\n    visited.add(head)\n\n    while deq:\n        ptr, length = deq.pop()\n        dist_a[ptr] = length\n        for item in my_dict[ptr]:\n            if item not in visited:\n                visited.add(item)\n                deq.append((item, length+1))\n\n\nn, u, v = list(map(int, input().split()))\nmy_dict = dict()\n\nfor i in range(n-1):\n    a, b = list(map(int, input().split()))\n    if a in my_dict:\n        my_dict[a].append(b)\n    else:\n        my_dict[a] = [b]\n    if b in my_dict:\n        my_dict[b].append(a)\n    else:\n        my_dict[b] = [a]\n\ndist_a = dict()\ndist_b = dict()\n\ncalc_dist(u, my_dict, dist_a)\ncalc_dist(v, my_dict, dist_b)\nret = 0\n\nfor i in range(1, n+1):\n    if dist_a[i] > dist_b[i]:\n        continue\n    else:\n        ret = max(ret, dist_b[i] - 1)\n\nprint(ret)\n", "N, U, V = map(int, input().split())\nedge = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    x, y = map(int, input().split())\n    edge[x].append(y)\n    edge[y].append(x)\n\n\ndef dist(s):\n    dist = [-1] * (N + 1)\n    node = [s]\n    dist[s] = 0\n    while node:\n        s = node.pop()\n        for t in edge[s]:\n            if dist[t] == -1:\n                dist[t] = dist[s] + 1\n                node.append(t)\n    return dist\n\n\ntaka = dist(U)\naoki = dist(V)\ncan_go = taka[V]\n\nans = 0\nfor t, a in zip(taka[1:], aoki[1:]):\n    if t <= a:\n        ans = max(ans, a - 1)\nprint(ans)", "N, u, v = map(int, input().split())\nu -= 1\nv -= 1\ntonari = [[] for _ in range(N)]\nfor _ in range(N-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  tonari[a].append(b)\n  tonari[b].append(a)\n\nd_from_u = [float('inf') for _ in range(N)]\nd_from_v = [float('inf') for _ in range(N)]\nd_from_u[u] = 0\nd_from_v[v] = 0\n#print(tonari)\n\nnow = [u]\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_u[t] > d:\n        d_from_u[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\nnow = [v]\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_v[t] > d:\n        d_from_v[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\n#print(d_from_u)\n#print(d_from_v)\n\ndistance = []\nfor U, V in zip(d_from_u, d_from_v):\n  distance.append((U, V))\n\ndistance.sort(key = lambda x: x[1])\n\n#print(distance)\nans = 0\nwhile distance:\n  d = distance.pop()\n  if d[0] < d[1]:\n    ans = d[1] - 1\n    break\nprint(ans)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs_a(N,v,adjlist,cur):\n    nonlocal depth_a\n    depth_a[v]=cur\n    for node in adjlist[v]:\n        if depth_a[node]<0:\n            dfs_a(N,node,adjlist,cur+1)\ndef dfs_t(N,v,adjlist,cur):\n    nonlocal depth_t\n    depth_t[v]=cur\n    for node in adjlist[v]:\n        if depth_t[node]<0:\n            dfs_t(N,node,adjlist,cur+1)\n    \n    \n    \n\nfrom collections import deque\n\nN,u,v=list(map(int,input().split()))\nadjlist=[[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b=list(map(int,input().split()))\n    adjlist[a-1].append(b-1)\n    adjlist[b-1].append(a-1)\ndepth_a=[-1]*N\ndepth_t=[-1]*N\ndfs_a(N,v-1,adjlist,0)\ndfs_t(N,u-1,adjlist,0)\nM=0\nfor i in range(N):\n    if depth_a[i]>depth_t[i]:\n        curm=depth_a[i]-1\n        if curm>M:\n            M=curm\nprint(M)\n        \n\n \n        \n", "import sys\nsys.setrecursionlimit(10**7)\n\n\nn,u,v=list(map(int, input().split()))\nu-=1\nv-=1\n\ngraph = [[] for _ in range(n+1)]\n# for i in range(n-1):\n#     a, b=map(int, input().split())\n#     graph[a-1].append(b-1)\n#     graph[b-1].append(a-1)\n\nab=[list(map(int, input().split())) for _ in range(n-1)]\nfor a,b in ab:\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\ndist=[[-1, -1] for _ in range(n)]\ndist[v][0]=0\ndist[u][1]=0\n\ndef dfs1(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][0]==-1:\n            dist[vvv][0]=dist[v][0]+1\n            dfs1(graph,vvv)\n\ndef dfs2(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][1]==-1:\n            dist[vvv][1]=dist[v][1]+1\n            dfs2(graph,vvv)\n\ndfs1(graph,v)\ndfs2(graph,u)\ndist.sort(reverse=True)\n\nfor i in range(10**6):\n    if dist[i][0]-dist[i][1]>=1:\n        print((dist[i][0]-1))\n        break\n", "import sys\nsys.setrecursionlimit(10**6)\n\nn,g,s = map(int,input().split())\nG = [[] for _ in range(n)]\nfor i in range(n-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n  \ndef dfs(V,v,d):\n  if V[v] != -1:\n    return\n  V[v] = d\n  for nv in G[v]:\n    dfs(V,nv,d+1)\n  \nif len(G[g-1])==1 and G[g-1][0]==s-1:\n  print(0)\nelse:\n  vs = [-1]*n\n  vg = [-1]*n\n  dfs(vs,s-1,0)\n  dfs(vg,g-1,0)\n  \n  ans = 0\n  for i in range(n):\n    if vs[i]>vg[i]:\n      ans = max(ans,vs[i])\n      \n  print(ans-1)", "from collections import defaultdict\nimport sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef depth(adj, node, parent=None):\n    ret = 0\n    for child in adj[node]:\n        if child == parent:\n            continue\n        d = depth(adj, child, node) + 1\n        ret = max(ret, d)\n    return ret\n\n\ndef main():\n    N, U, V = list(map(int, input().split(' ')))\n    U -= 1\n    V -= 1\n    adj = defaultdict(list)\n    for _ in range(N - 1):\n        A, B = list(map(lambda x: int(x) - 1, input().split(' ')))\n        adj[A].append(B)\n        adj[B].append(A)\n\n    path = [-1] * N\n\n    def find_path_on_tree(to_node, node, parent=None, d=0):\n        if node == to_node:\n            path[d] = node\n            return True\n        for child in adj[node]:\n            if child == parent:\n                continue\n            if not find_path_on_tree(to_node, child, node, d + 1):\n                continue\n            path[d] = node\n            return True\n        return False\n\n    find_path_on_tree(U, V)  # to U from V\n    path = [node for node in path if node != -1]\n    dist = len(path) - 1\n    partial_depth = depth(adj, path[(dist // 2) + 1], path[dist // 2])\n    print(partial_depth + (dist // 2))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import os\nimport sys\nimport numpy as np\n\ndef solve(N, U, V, AB):\n    G = [[0]*0 for _ in range(N+1)]\n    for idx_ab in range(len(AB)):\n        a, b = AB[idx_ab]\n        G[a].append(b)\n        G[b].append(a)\n    P1 = np.zeros(N+1, dtype=np.int64)\n    def dfs1(u):\n        st = [u]\n        while st:\n            v = st.pop()\n            p = P1[v]\n            for u in G[v]:\n                if p != u:\n                    st.append(u)\n                    P1[u] = v\n    dfs1(U)\n    path_u2v = [U]\n    v = V\n    while v != U:\n        v = P1[v]\n        path_u2v.append(v)\n    path_u2v.reverse()\n    l = len(path_u2v)\n    half = (l-2) // 2\n    c = path_u2v[half]\n    ng = path_u2v[half+1]\n    Depth = np.zeros(N+1, dtype=np.int64)\n    def dfs2(c):\n        st = [c]\n        P = np.zeros(N+1, dtype=np.int64)\n        while st:\n            v = st.pop()\n            p = P[v]\n            d = Depth[v]\n            for u in G[v]:\n                if p != u and u != ng:\n                    st.append(u)\n                    P[u] = v\n                    Depth[u] = d + 1\n    dfs2(c)\n    c_ = path_u2v[l-1-half]\n    v = c_\n    while v != c:\n        Depth[v] = 0\n        v = P1[v]\n    d = l%2\n    ans = max(Depth) + half + d\n    return ans\n\n\n# >>> numba compile >>>\nnumba_config = [\n    [solve, \"i8(i8,i8,i8,i8[:,:])\"],\n]\nif sys.argv[-1] == \"ONLINE_JUDGE\":\n    from numba import njit\n    from numba.pycc import CC\n    cc = CC(\"my_module\")\n    for func, signature in numba_config:\n        vars()[func.__name__] = njit(signature)(func)\n        cc.export(func.__name__, signature)(func)\n    cc.compile()\n    return\nelif os.name == \"posix\":\n    exec(f\"from my_module import {','.join(func.__name__ for func, _ in numba_config)}\")\nelse:\n    from numba import njit\n    for func, signature in numba_config:\n        vars()[func.__name__] = njit(signature, cache=True)(func)\n    print(\"compiled!\", file=sys.stderr)\n# <<< numba compile <<<\n\n\ndef main():\n    N, u, v = map(int, input().split())\n    if N==2:\n        print(0)\n        return\n    AB = np.array(sys.stdin.read().split(), dtype=np.int64).reshape(N-1, 2)\n    ans = solve(N, u, v, AB)\n    print(ans)\n\nmain()\n", "from collections import deque\n\ndef bfs(s):\n    q = deque()\n    q.append(s)\n    dist = [-1] * (n + 1)\n    dist[s] = 0\n    while q:\n        p = q.popleft()\n        for i in G[p]:\n            if dist[i] == -1:\n                dist[i] = dist[p] + 1\n                q.append(i)\n    return dist\n\nn, u, v = map(int, input().split())\nG = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\ndist1 = bfs(u)\ndist2 = bfs(v)\nans = 0\nfor i in range(1, n + 1):\n    if dist1[i] <= dist2[i]:\n        ans = max(ans, dist2[i] - 1)\nprint(ans)", "from collections import deque\nn , u , v = map(int,input().split())\nu -= 1\nv -= 1\nroute = [[] for i in range(n)]\nfor i in range(n-1):\n    a , b = map(lambda x:int(x)-1,input().split())\n    route[a].append(b)\n    route[b].append(a)\n\ntakyori = [-1 for i in range(n)]\ntakyori[u] = 0\nd = deque()\nd.append(u)\nwhile d:\n    now = d.popleft()\n    for i in route[now]:\n        if takyori[i] == -1:\n            takyori[i] = takyori[now] + 1\n            d.append(i)\n\naokyori = [-1 for i in range(n)]\naokyori[v] = 0\nd = deque()\nd.append(v)\nwhile d:\n    now = d.popleft()\n    for i in route[now]:\n        if aokyori[i] == -1:\n            aokyori[i] = aokyori[now] + 1\n            d.append(i)\nans = 0\nfor i in range(n):\n    if takyori[i] <= aokyori[i]:\n        ans = max(ans,aokyori[i]-1)\nprint(ans)", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, p, q, *AB = list(map(int, read().split()))\n    p -= 1\n    q -= 1\n\n    G = [[] for _ in range(N)]\n    for a, b in zip(*[iter(AB)] * 2):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    if len(G[p]) == 1 and G[p][0] == q:\n        print((0))\n        return\n\n    dist1 = [-1] * N\n    dist1[p] = 0\n    queue = deque([p])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist1[nv] == -1:\n                dist1[nv] = dist1[v] + 1\n                queue.append(nv)\n\n    dist2 = [-1] * N\n    dist2[q] = 0\n    queue = deque([q])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if dist2[nv] == -1:\n                dist2[nv] = dist2[v] + 1\n                queue.append(nv)\n\n    max_d = 0\n    for d1, d2 in zip(dist1, dist2):\n        if d1 < d2 and max_d < d2:\n            max_d = d2\n\n    print((max_d - 1))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, u, v = map(int, input().split())\nu -= 1\nv -= 1\ntonari = [[] for _ in range(N)]\nfor _ in range(N-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  tonari[a].append(b)\n  tonari[b].append(a)\n\nd_from_u = [float('inf') for _ in range(N)]\nd_from_v = [float('inf') for _ in range(N)]\nd_from_u[u] = 0\nd_from_v[v] = 0\n#print(tonari)\nnow = [v] #\u8ffd\u3044\u304b\u3051\u308b\u65b9\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_v[t] > d:\n        d_from_v[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\n\n\nnow = [u] #\u9003\u3052\u308b\u65b9\nd = 0\nwhile now:\n  d += 1\n  nextvisit = []\n  for n in now:\n    for t in tonari[n]:\n      if d_from_v[t] <= d: #\u8ffd\u3044\u304b\u3051\u308b\u65b9\u3088\u308a\u9060\u3044\u5730\u70b9\u306f\u6392\u9664\n        continue\n      elif d_from_u[t] > d:\n        d_from_u[t] = d\n        nextvisit.append(t)\n  now = nextvisit\n\n\ndistance = []\nans = 0\nfor U, V in zip(d_from_u, d_from_v):\n  if U < N+1: #inf\u3092\u6392\u9664\n    ans = max(ans, V-1)\nprint(ans)", "import sys\nf=lambda:map(int,sys.stdin.readline().split())\nn,st,sa=f()\nst-=1\nsa-=1\ng=[[] for _ in range(n)]\nfor _ in range(n-1):\n  a,b=f()\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\ndef bfs(s):\n  l=[-1]*n; l[s]=0; q=[s]\n  while q:\n    v=q.pop(); d=l[v]+1\n    for c in g[v]:\n      if l[c]<0: l[c]=d; q+=[c]\n  return l\nlt=bfs(st)\nla=bfs(sa)\nm=0\nfor i in range(n):\n  if lt[i]<la[i]: m=max(m,la[i])\nprint(m-1)", "N, u, v = (int(i) for i in input().split())\nadj=[]\nfor i in range(N+1):adj.append([])\nfor i in range(N-1):\n\ta,b = list(map(int,input().split()))\n\tadj[a]+=[b]\n\tadj[b]+=[a]\n\ndef distances(sommet):\n\td = [-1]*(N+1)\n\tFile = [sommet]\n\td[sommet] = 0\n\twhile File:\n\t\ts = File.pop()\n\t\tfor x in adj[s]:\n\t\t\tif d[x]==-1:\n\t\t\t\td[x] = 1+d[s]\n\t\t\t\tFile.append(x)\n\treturn d\n\n\nt = distances(u)\na = distances(v)\n\n# ~ print(t)\n# ~ print(a)\n\nans = -1\nfor i in range(1,N+1):\n\tif t[i]<a[i]:\n\t\tans = max(ans, a[i]-1)\n\t\t\nprint(ans)\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u53cc\u65b9\u5411\u30b0\u30e9\u30d5\u3067\u5e45\u512a\u5148\u63a2\u7d22\n\nfrom collections import deque\n\nn, u, v = map(int, input().split())\ng = [[] for _ in range(n)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    g[a].append(b)\n    g[b].append(a)\n\n\n# \u5e45\u512a\u5148\u63a2\u7d22\ndef bfs(x):\n    q = deque()\n    seen = [False]*n\n    level = [-1]*n\n    parent = [-1]*n\n    q.append(x)\n    seen[x] = True\n    level[x] = 0\n    parent[x] = 0\n    while len(q)>0:\n        cur = q.popleft()\n        lvl = level[cur]\n        for i in g[cur]:\n            if seen[i]==False:\n                seen[i] = True\n                #\u968e\u5c64\n                level[i] = lvl + 1\n                #\u89aa\n                parent[i] = cur\n                q.append(i)\n    return level\n\n\nul = bfs(u-1)\nvl = bfs(v-1)\n\nret = 0\nfor i, j in zip(ul, vl):\n    if i < j:\n        ret = max(ret, j-1)\nprint(ret)", "from collections import deque\n\nN,u,v=map(int,input().split())\nG=[[] for _ in range(N)]\nfor _ in range(N-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n\ndef bfs(s):\n    seen = [0]*N\n    d = [0]*N\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    while len(todo):\n      a = todo.popleft()\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + 1\n    return d\n  \nd1 = bfs(u-1)\nd2 = bfs(v-1)\n\nprint(max([d2[i] for i in range(N) if d1[i]<=d2[i]])-1)", "import sys\nsys.setrecursionlimit(10**9)\nf=lambda:map(int,sys.stdin.readline().split())\nn,st,sa=f()\ng=[set() for _ in range(n)]\nfor _ in range(n-1):\n  a,b=f()\n  g[a-1].add(b-1)\n  g[b-1].add(a-1)\ndef dfs(l,v,p=-1,d=0):\n  l[v]=d\n  for c in g[v]:\n    if c!=p: dfs(l,c,v,d+1)\nlt=[0]*n\ndfs(lt,st-1)\nla=[0]*n\ndfs(la,sa-1)\nprint(max(la[i] for i in range(n) if lt[i]<la[i])-1)", "import numpy as np\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nN, u, v = map(int, input().split())\n\nE = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n\tta, tb = map(int, input().split())\n\tE[ta].append(tb)\n\tE[tb].append(ta)\nE = np.array(E)\n\ninf = 10**9\ntaka = np.full(N+1, inf, dtype = np.int64)\nao = np.full(N+1, inf, dtype = np.int64)\ntaka[u] = 0\nao[v] = 0\ndef solve(dist, start):\n\tq = [start]\n\twhile q:\n\t\tcp = q.pop()\n\t\tfor nep in E[cp]:\n\t\t\tif dist[nep] != inf:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tdist[nep] = dist[cp] + 1\n\t\t\t\tq.append(nep)\n\nsolve(taka, u)\nsolve(ao, v)\nind = taka < ao\nao_max = np.max(ao[ind])\nprint(ao_max - 1)", "import sys\nsys.setrecursionlimit(10**7)\n\nn,u,v=list(map(int, input().split()))\nu-=1\nv-=1\nab=[list(map(int, input().split())) for _ in range(n-1)]\ngraph = [[] for _ in range(n+1)]\nfor a,b in ab:\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\ndist=[[-1, -1] for _ in range(n)]\ndist[v][0]=0\ndist[u][1]=0\n\ndef dfs1(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][0]==-1:\n            dist[vvv][0]=dist[v][0]+1\n            dfs1(graph,vvv)\n\ndef dfs2(graph,v):\n    vv=graph[v]\n    for vvv in vv:\n        if dist[vvv][1]==-1:\n            dist[vvv][1]=dist[v][1]+1\n            dfs2(graph,vvv)\n\ndfs1(graph,v)\ndfs2(graph,u)\ndist.sort(reverse=True)\n\nfor i in range(10**6):\n    if dist[i][0]-dist[i][1]>=1:\n        print((dist[i][0]-1))\n        break\n\n", "f=lambda:map(int,input().split())\nn,st,sa=f()\ng=[set() for _ in range(n)]\nfor _ in range(n-1):\n  a,b=f()\n  g[a-1].add(b-1)\n  g[b-1].add(a-1)\ndef bfs(s):\n  l=[-1]*n; l[s]=0; q=[s]\n  while q:\n    v=q.pop(); d=l[v]+1\n    for c in g[v]:\n      if l[c]<0: l[c]=d; q+=[c]\n  return l\nlt=bfs(st-1)\nla=bfs(sa-1)\nprint(max(la[i] for i in range(n) if lt[i]<la[i])-1)", "nii=lambda:map(int,input().split())\nfrom collections import deque\n\nn,u,v=nii()\nu-=1\nv-=1\n\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=nii()\n  a-=1\n  b-=1\n  tree[a].append(b)\n  tree[b].append(a)\n\ndef BFS(s):\n  dist=[-1 for i in range(n)]\n  dist[s]=0\n\n  que=deque()\n  que.append(s)\n\n  while que:\n    x=que.popleft()\n    for i in tree[x]:\n      if dist[i]==-1:\n        que.append(i)\n        dist[i]=dist[x]+1\n  return dist\n\ndist_t=BFS(u)\ndist_a=BFS(v)\n\nans=0\nfor i in range(n):\n  if dist_a[i]>dist_t[i]:\n    ans=max(ans,dist_a[i]-1)\n\nprint(ans)", "N,u,v=map(int,input().split())\nfrom collections import deque\ng=[[] for _ in range(N)]\nfor i in range(N-1):\n  A,B=map(int,input().split())\n  g[A-1].append(B-1)\n  g[B-1].append(A-1)\ndef bfs(n):\n  stack=deque([])\n  depth=[-1]*N\n  depth[n-1]=0\n  stack.append(n-1)\n  while stack:\n    a=stack.popleft()\n    for b in g[a]:\n      if depth[b]==-1:\n        depth[b]=depth[a]+1\n        stack.append(b)\n  return depth\nU=bfs(u)\nV=bfs(v)\nList=[]\nfor i in range(N):\n  if len(g[i])==1 and U[i]<V[i]:\n    List.append(i)\nans=0\n\nfor i in List:\n  ans=max(ans,V[i]-1)\n\nprint(ans)  ", "N,u,v=list(map(int, input().split()))\nimport sys\nsys.setrecursionlimit(10**6)\nT=[[] for _ in range(N)]\nfor i in range(N-1):\n    a,b=list(map(int, input().split()))\n    T[a-1].append(b-1)\n    T[b-1].append(a-1)\n\n\ndef dfs(start):\n    tolist=T[start]\n    nowd=done[start]\n    for next_n in tolist:\n        if done[next_n]==-1:\n            done[next_n]=nowd+1\n            dfs(next_n)\n\ndone=[-1]*N\ndone[u-1]=0\ndfs(u-1)\ndtaka=done.copy()\ndone=[-1]*N\ndone[v-1]=0\ndfs(v-1)\ndao=done.copy()\nans=0\nfor i in range(N):\n    t=dtaka[i]\n    a=dao[i]\n    if a>t:\n        ans=max(ans, a)\nprint((ans-1))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nN, u, v = map(int, input().split())\nu -= 1\nv -= 1\nedges = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndist = [0] * N\ndef dfs(v, d=0, p=-1):\n    nonlocal dist\n    dist[v] = d\n    for u in edges[v]:\n        if u == p:\n            continue\n        dfs(u, d + 1, v)\n\ndef calc_dist(s):\n    nonlocal dist\n    dist = [0] * N\n    dfs(s)\n    return dist\n\ndistS = calc_dist(u)\ndistT = calc_dist(v)\n\nmx = 0\nfor i in range(N):\n    if distS[i] < distT[i]:\n        mx = max(mx, distT[i])\nans = mx - 1\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\n\nn, u, v = list(map(int, input().split()))\n# \u3088\u308a\u305f\u304b\u306f\u3057\u304f\u3093\u304c\u65e9\u304f\u8fbf\u308a\u7740\u3051\u308b\u8449\u306e\u3046\u3061\u3001\u9752\u6728\u541b\u304b\u3089\u6700\u3082\u9060\u3044\u3067\nu -= 1\nv -= 1\n\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[a].append(b)\n    g[b].append(a)\n\nINF = 1 << 30\nt = [INF] * n\na = [INF] * n\n\nt[u] = 0\na[v] = 0\n\n\ndef dfs(v, p, d):\n    for nv in g[v]:\n        if nv == p:\n            continue\n        if d[nv] == INF:\n            d[nv] = d[v] + 1\n            dfs(nv, v, d)\n\n\ndfs(u, -1, t)\ndfs(v, -1, a)\n\nans = 0\nfor i in range(n):\n    if t[i] < a[i]:\n        ans = max(ans, a[i] - 1)\nprint(ans)\n"]
["n = int(input())\na = list(map(int,input().split()))\n\ndupes = 0\ndupeVal = -1\nd = set()\nfor el in a:\n    if el in d:\n        dupes += 1\n        dupeVal = el\n    else:\n        d.add(el)\n\ninPlay = True\nif dupes > 1:\n    print('cslnb')\n    inPlay = False\nelif dupes == 1:\n    if dupeVal == 0 or (dupeVal - 1) in d:\n        print('cslnb')\n        inPlay = False\n\nif inPlay:\n    finalSum = (n*(n-1))//2\n    Sum = sum(a)\n    if (Sum - finalSum) % 2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n    \n", "import sys\n\nn = int(sys.stdin.readline().strip())\na = list(map(int,sys.stdin.readline().strip().split()))\na.sort()\n\nif n == 1:\n    if a[0] % 2 == 1:\n        v = True\n    else:\n        v = False\nelse:\n    v = True\n    c = 0\n    for i in range (0, n-1):\n        if a[i] == a[i + 1]:\n            c = c + 1\n            j = i\n    if c > 1:\n        v = False\n    elif c == 1:\n        if a[j] == 0:\n            v = False\n        if j > 0:\n            if a[j-1] + 1 == a[j]:\n                v = False\n    if (sum(a) - (n * (n - 1)) // 2) % 2 == 0:\n        v = False\n\nif v == True:\n    print(\"sjfnb\")\nelse:\n    print(\"cslnb\")\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nA.sort()\n\nfrom collections import Counter\nC=Counter(A)\ndou=0\n\nfor c in C:\n    dou+=C[c]-1\n\n    if C[c]>=2 and C[c-1]!=0:\n        print(\"cslnb\")\n        return\n        \nif dou>=2:\n    print(\"cslnb\")\n    return\n\nANS=0\nfor i in range(n):\n    if A[i]<i:\n        print(\"cslnb\")\n        return\n    ANS+=(A[i]-i)%2\n\nif ANS%2==0:\n    print(\"cslnb\")\n    return\nelse:\n    print(\"sjfnb\")\n    return\n    \n    \n", "from collections import defaultdict as dd, deque\nn = int(input())\nA = [int(x) for x in input().split()]\nn = len(A)\n\nC = dd(int)\nfor a in A:\n    C[a] += 1\n\nthedup = None\nndup = 0\nscrewed = False\nfor c in C:\n    if C[c] > 2:\n        screwed = True\n    elif C[c] == 2:\n        if c == 0:\n            screwed = True\n        thedup = c\n        ndup += 1\n\nimport sys\nif screwed or ndup > 1:\n    print('cslnb')\nelse:\n    if ndup == 1:\n        if C[thedup-1] != 0:\n            print('cslnb')\n            return\n        \n\n    target = sum(range(n))\n    cur = sum(A)\n    togo = cur - target\n\n    if togo%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n", "3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef rl(proc=None):\n    if proc is not None:\n        return proc(sys.stdin.readline())\n    else:\n        return sys.stdin.readline().rstrip()\n\ndef srl(proc=None):\n    if proc is not None:\n        return list(map(proc, rl().split()))\n    else:\n        return rl().split()\n\ndef main():\n    rl()\n    a = srl(int)\n    a.sort()\n    cnt = 0\n    for i in range(0, len(a)-1):\n        if a[i] == a[i+1]:\n            a[i] -= 1\n            cnt += 1\n            break\n    if a[0] < 0:\n        print('cslnb')\n        return\n\n    for i in range(0, len(a)-1):\n        if a[i] == a[i+1]:\n            print('cslnb')\n            return\n\n    for i, x in enumerate(a):\n        cnt += x - i\n\n    print('sjfnb' if (cnt & 1) else 'cslnb')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = sorted(list(map(int,input().split())))\nbal = 0\nif a.count(0)>1:\n    print('cslnb')\n    return\nif n-len(set(a))>1:\n    print('cslnb')\n    return\nif n-len(set(a))==1:\n    for i in range(1,n):\n        if a[i]==a[i-1]:\n            if a[i]-1 in a:\n                print('cslnb')\n                return\n            break\nif n==1:\n    print('cslnb' if not a[0] % 2 else 'sjfnb')\n    return\n\nfor i in range(n):\n    bal+=a[i]-i\nprint('sjfnb'if bal%2 else 'cslnb')", "n = int(input())\na = sorted(list(map(int, input().split())))\nduplicates = {}\nd = None\ndelta = 0\nfor i, el in enumerate(a, 1):\n    if el not in duplicates:\n        duplicates[el] = 0\n    else:\n        d = el\n        duplicates[el] += 1\n    min_value = i-1\n    delta += el - min_value\nif sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):\n    print('cslnb')\nelif delta == 0:\n    print('cslnb')\nelif delta % 2 == 1:\n    print('sjfnb')\nelse:\n    print('cslnb')\n", "n=int(input())\na=list(map(int,input().split()))\nd=set()\nt={}\nrep=set()\nif a.count(0)>=2:\n\tprint(\"cslnb\")\n\treturn\n\nfor i in a:\n\tif i in d:\n\t\tif t[i]+1==3:\n\t\t\tprint(\"cslnb\")\n\t\t\treturn\n\t\telse:\n\t\t\tt[i]+=1\n\t\t\trep.add(i)\n\t\t\tif len(rep)>=2:\n\t\t\t\tprint(\"cslnb\")\n\t\t\t\treturn\n\telse:\n\t\tt[i]=1\n\t\td.add(i)\nif rep:\n\tfor c in rep:\n\t\tif c-1 in d:\n\t\t\tprint(\"cslnb\")\n\t\t\treturn\ns=0\na.sort()\nfor i in range(n):\n\ts+=a[i]-i\nif s%2==1:print(\"sjfnb\")\nelse:print(\"cslnb\")", "def find(A):\n    from collections import defaultdict\n    A=sorted(A)\n    N=len(A)\n    dic=defaultdict(int)\n    for i in range(N):\n        dic[A[i]]+=1\n    \n    checked=[]\n    count=set([])\n    for x in A:\n        if dic[x]>2:\n            return \"cslnb\"\n        if dic[x]==2:\n            count.add(x)\n            y=x-1\n            if y in dic:\n                return \"cslnb\"\n    if len(count)>1:\n        return \"cslnb\"\n    \n    if 0 in count:\n        return \"cslnb\"\n    \n    temp=0\n    for i in range(N):\n        temp+=A[i]-i\n    if temp%2==1:\n        return \"sjfnb\"\n    return \"cslnb\"\ninput()\nA=list(map(int,input().strip().split(' ')))\nprint(find(A))", "n = int(input())\na = sorted(list(map(int, input().split())))\ntmp = 0\nif a.count(0) > 1:\n    print('cslnb')\n    return\nif n - len(set(a)) > 1:\n    print('cslnb')\n    return\nif n == 1:\n    print('cslnb' if not a[0] % 2 else 'sjfnb')\n    return\nif n - len(set(a)) == 1:\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            if a[i] - 1 in a:\n                print('cslnb')\n                return\n            break\nfor i in range(n):\n    tmp += a[i] - i\nprint('cslnb' if not tmp % 2 else 'sjfnb')\n", "n = int(input())\ngame = list(map(int, input().split()))\ngame.append(-1)\ngame.sort()\nbitSum = game[1] % 2\nrep = False\nfor i in range(1, n):\n    bitSum += game[i + 1] % 2\n    if game[i] == game[i + 1]:\n        if rep:\n            print('cslnb')\n            return\n        else:\n            if game[i - 1] == game[i] - 1:\n                print('cslnb')\n                return\n            rep = True\nGoal = ((n * (n - 1)) / 2) % 2\nif (bitSum + Goal) % 2 == 0:\n    print('cslnb')\nelse:\n    print('sjfnb')", "n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n    if a[i]==a[i+1]==0:\n        lose=True\n    if a[i]==a[i+1]:\n        if pair:\n            lose=True\n        pair=True\n        if i>=1:\n            if a[i]==a[i-1]+1:\n                lose=True\nif lose:\n    print(\"cslnb\")\nelse:\n    eventual=n*(n-1)//2\n    curr=sum(a)\n    if (curr-eventual)%2==0:\n        print(\"cslnb\")\n    else:\n        print(\"sjfnb\")", "import sys\n\n\ndef is_winning_state(nims, n):\n    keys = set(nims)\n    counts = dict.fromkeys(keys, 0)\n    for nim in nims:\n        counts[nim] += 1\n    if 0 in keys and counts[0] > 1:\n        return True\n    lose_count = 0\n    for k in keys:\n        if counts[k] > 2:\n            return True\n        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:\n            return True\n        if counts[k] > 1:\n            lose_count += 1\n    if lose_count > 1:\n        return True\n    return False\n\ndef main():\n    n = int(input())\n    nims = list(map(int, input().split()))\n    if is_winning_state(nims, n):\n        print('cslnb')\n    else:\n        x = sum(nims) - (n * (n - 1)) // 2\n        if x % 2 == 0:\n            print('cslnb')\n        else:\n            print('sjfnb')\n\nmain()\n", "n = int(input())\na = sorted(list(map(int, input().split())))\n\nwin = None\nfirst = True\n\nif n == 1:\n    win = a[0] % 2 == 1\nelif a[1] == 0:\n    win = False\n\nif n > 2:\n    for i in range(n-1):\n        if a[i] == a[i+1]:\n            if i > 0:\n                if a[i-1] == a[i]-1:\n                    win = False\n                    break\n            if not first:\n                win = False\n                break\n            first = False\n\n\nif win is None:\n    win = (sum(a) - (n*(n-1)//2)) % 2 == 1\n\nif win:\n    print('sjfnb')\nelse:\n    print('cslnb')\n", "n=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n  if a[i]==a[i+1]==0:\n    lose=True\n  if a[i]==a[i+1]:\n    if pair:\n      lose=True\n    pair=True\n    if i>=1:\n      if a[i]==a[i-1]+1:\n        lose=True\nif lose:\n  print(\"cslnb\")\nelse:\n  eventual=n*(n-1)//2\n  curr=sum(a)\n  if (curr-eventual)%2==0:\n    print(\"cslnb\")\n  else:\n    print(\"sjfnb\")\n", "n = int(input())\nu = list(map(int, input().split()))\nu.sort()\nans = 0\nk = 1\nok = False\nfor i in range(1, n):\n    if u[i] == u[i - 1]:\n        k += 1\n        if k == 3:\n            print('cslnb')\n            return\n        if k == 2:\n            if ok or u[i] == 0 or u[i] - u[i - 2] == 1:\n                print('cslnb')\n                return\n            ok = True\n    else:\n        k = 1\nfor i in range(n):\n    ans += u[i] - i\nif ans % 2 == 0:\n    print('cslnb')\nelse:\n    print('sjfnb')\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    li.sort()\n    res = 0\n    for i, ele in enumerate(li):\n        if ele<i:\n            print(\"cslnb\")\n            return\n        else: res+= ele-i\n    counter = Counter(li)\n    cnt2 = 0\n    for i in counter.keys():\n        if counter[i]>2 or counter[0]>1:\n            print(\"cslnb\")\n            return\n        elif counter[i]==2:\n            cnt2+=1\n            if cnt2>1 or i-1 in counter:\n                print(\"cslnb\")\n                return\n    print(\"cslnb\") if res%2==0 else print(\"sjfnb\")\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "from collections import Counter\nimport sys\nreadline = sys.stdin.readline\n\n\ndef check(A):\n    CA = Counter(A)\n    if CA[0] >= 2:\n        return False\n    cnt = 0\n    for k, v in list(CA.items()):\n        if v > 2:\n            return False\n        if v == 2 and CA[k-1] >= 1:\n            return False\n        if v >= 2:\n            cnt += 1\n    if cnt >= 2:\n        return False\n    L = len(A)\n    if (sum(A) - L*(L-1)//2) % 2 == 0:\n        return False\n    return True\n    \nN = int(readline())\nif check(list(map(int, readline().split()))):\n    print('sjfnb')\nelse:\n    print('cslnb')\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Oct  5 21:40:29 2019\n\n@author: Mridul Garg\n\"\"\"\n\nn = int(input())\n\narr = list(map(int, input().split(' ')))\narr.sort()\n\nstop = 0\nequal = -1\ntempcounter = 0\n\nfor i in range(1, n):\n    if arr[i] == arr[i-1]:\n        equal = arr[i]\n        tempcounter += 1\n        if tempcounter == 2:\n            break\n\nif tempcounter == 1 and equal != 0:\n    for j in range(n):\n        if arr[j] == equal-1:\n            print(\"cslnb\")\n            stop = 1\n\nif tempcounter == 1 and equal == 0:\n    print(\"cslnb\")\n \n#elif tempcounter == 1 and n == 3 and stop == 0:\n#    print(\"cslnb\")\n\nelif tempcounter < 2 and stop == 0: \n    moves = arr[0]\n    counter = 0\n    \n    for i in range(1, n):\n        moves += arr[i] - i \n\n    if counter == 0:\n        if moves%2 == 0:\n            print(\"cslnb\")\n            \n        else:\n            print(\"sjfnb\")\n        \nelif stop == 0:\n    print(\"cslnb\")    \n    \n", "from collections import Counter\nn = int(input())\narr = list(map(int, input().split()))\nc = Counter(arr)\ncommon = c.most_common(2)\nif common[0][1] > 2 \\\n        or (common[0][1] == 2 and (common[0][0] == 0 or (common[0][0] - 1) in c)) \\\n        or (len(common) == 2 and common[1][1] == 2):\n    print('cslnb')\nelse:\n    if (sum(arr) - (n * (n - 1))//2) % 2 == 1:\n        print('sjfnb')\n    else:\n        print('cslnb')", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/8 22:06\n\n\"\"\"\n\n\ndef solve(N, A):\n    wc = collections.Counter(A)\n    if wc[0] > 1:\n        return False\n\n    if any([v > 2 for v in wc.values()]):\n        return False\n\n    if len([v for v in wc.values() if v > 1]) > 1:\n        return False\n\n    if any([c > 1 and w-1 in wc for w, c in wc.items()]):\n        return False\n\n    taken = sum(A) - N * (N-1) // 2\n    return taken % 2 != 0\n\n\nN = int(input())\nA = [int(x) for x in input().split()]\ns = solve(N, A)\nprint('sjfnb' if s else 'cslnb')", "n=int(input())\nx=list(map(int,input().split()))\nx.sort()\ncount,count2=0,0\nans=1\nfor i in range(n):\n    count+=x[i]-i\n    if i>=2 and x[i]==x[i-1]==x[i-2]: ans=0\n    if i >= 2 and x[i] == x[i - 1] == x[i - 2]+1: ans = 0\n    if i>=1 and x[i]==x[i-1]: count2+=1\nif n>=3 and x[0]==x[1]==0: ans=0\nfor i in range(n):\n    if x[i]>0: break\n    if i==n-1: ans=0\nif ans==0 or count%2==0 or count2>1: print(\"cslnb\")\nelse: print(\"sjfnb\")", "ans=[\"sjfnb\",\"cslnb\"]\nn=int(input())\nl=list(map(int,input().split()))\nl.sort()\nd=set()\ne=0\ns=0\nfor i in range(n):\n    if l[i] in d:\n        e+=1\n        s=l[i]\n    d.add(l[i])\nif e>1 or l.count(0)>1 or s-1 in d:\n    print(ans[1])\n    \nelse:\n    l=[l[i]-i for i in range(n)]\n    #print(l)\n    print(ans[1-sum(l)%2])", "from sys import stdin\n\nn = int(stdin.readline())\n\nstones = sorted([int(x) for x in stdin.readline().split()])\n\nif n == 1:\n    if stones[0]%2 == 0:\n        print('cslnb')\n    else:\n        print('sjfnb')\n\nelse:\n    chilly = -1\n    chill = 2\n    prev = stones[0]\n    \n    for x in stones[1:]:\n        if x == prev:\n            chill -= 1\n            chilly = x\n        else:\n            streak = 1\n            prev = x\n    \n    s = sum(stones)\n\n    if n%4 == 0 or n%4 == 1:\n        s += 1\n\n    if chill <= 0 or stones.count(0) > 1:\n        print('cslnb')\n    elif chill == 1 and chilly-1 in stones:\n        print('cslnb')\n    elif s%2 == 1:\n        print('cslnb')\n    else:\n        print('sjfnb')\n", "# whatsibucket\nn=int(input())\na=list(map(int,input().split()))\na.sort()\nlose=False\npair=False\nfor i in range(n-1):\n    if a[i]==a[i+1]==0:\n        lose=True\n    if a[i]==a[i+1]:\n        if pair:\n            lose=True\n        pair=True\n        if i>=1:\n            if a[i]==a[i-1]+1:\n                lose=True\nif lose:\n    print(\"cslnb\")\nelse:\n    eventual=n*(n-1)//2\n    curr=sum(a)\n    if (curr-eventual)%2==0:\n        print(\"cslnb\")\n    else:\n        print(\"sjfnb\")"]
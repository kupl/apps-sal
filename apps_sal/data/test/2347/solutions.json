["t = int(input())\n\nfor _ in range(t):\n    p = sorted(input())\n    h = input()\n    \n    for i in range(len(h)-len(p)+1):\n        if sorted(h[i:i+len(p)])==p:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n", "n = int(input())\nfor i in range(n):\n    p = input()\n    h = input()\n    p = sorted(p)\n    good = False\n    for i in range(len(h)):\n        if i+len(p) > len(h):\n            break\n        if sorted(h[i:i+len(p)]) == p:\n            good=True\n    if good:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n", "import math\nfrom decimal import Decimal\nimport heapq\nfrom collections import deque\ndef na():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\treturn n,b\n \n \ndef nab():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tc = [int(x) for x in input().split()]\n\treturn n,b,c\n \n \ndef dv():\n\tn, m = list(map(int, input().split()))\n\treturn n,m\n \n \ndef da():\n\tn, m = list(map(int, input().split()))\n\ta = list(map(int, input().split()))\n\treturn n,m, a \n \n \ndef dva():\n\tn, m = list(map(int, input().split()))\n\ta = [int(x) for x in input().split()]\n\tb = [int(x) for x in input().split()]\n\treturn n,m,b\n \n \ndef eratosthenes(n): \n\tsieve = list(range(n + 1))\n\tfor i in sieve:\n\t\tif i > 1:\n\t\t\tfor j in range(i + i, len(sieve), i):\n\t\t\t\tsieve[j] = 0\n\treturn sorted(set(sieve))\n \n \ndef lol(lst,k):\n\tk=k%len(lst)\n\tret=[0]*len(lst)\n\tfor i in range(len(lst)):\n\t\tif i+k<len(lst) and i+k>=0:\n\t\t\tret[i]=lst[i+k]\n\t\tif i+k>=len(lst):\n\t\t\tret[i]=lst[i+k-len(lst)]\n\t\tif i+k<0:\n\t\t\tret[i]=lst[i+k+len(lst)]\n\treturn(ret)\ndef nm():\n\tn = int(input())\n\tb = [int(x) for x in input().split()]\n\tm = int(input())\n\tc = [int(x) for x in input().split()]\n\treturn n,b,m,c\n \n \ndef dvs():\n\tn = int(input())\n\tm = int(input())\n\treturn n, m \n \n\ndef fact(a, b):\n\tc = []\n\tans = 0\n\tf = int(math.sqrt(a))\n\tfor i in range(1, f + 1):\n\t\tif a % i == 0:\n\t\t\tc.append(i)\n\tl = len(c)\n\tfor i in range(l):\n\t\tc.append(a // c[i])\n\tfor i in range(len(c)):\n\t\tif c[i] <= b:\n\t\t\tans += 1\n\tif a / f == f and b >= f:\n\t\treturn ans - 1\n\treturn ans\n\n\nfor i in range(int(input())):\n\tp = list(input())\n\th = list(input())\n\tp.sort()\n\td = len(p)\n\tf = False\n\tfor j in range(len(h) - d + 1):\n\t\tif sorted(h[j:j + d]) == p:\n\t\t\tprint('YES')\n\t\t\tf = True\n\t\t\tbreak\n\tif not f:\n\t\tprint('NO')\n", "for _ in range(int(input())):\n    p = input().rstrip()\n    h = input().rstrip()\n    p = sorted(p)\n    ok = False\n    for i in range(len(h) - len(p) + 1):\n        q = sorted(h[i : i + len(p)])\n        if p == q:\n            ok = True\n            break\n    print('YES' if ok else 'NO')\n", "for _ in range(int(input())):\n    p = sorted(input())\n    h = input()\n\n    ok = False\n\n    i = 0\n    while i < len(h):\n        j = len(h)-1\n        while j >= 0:\n            if sorted(h[i:j+1]) == p:\n                ok = True \n            j -= 1 \n        i += 1\n    \n    if ok:\n        print('YES')\n    else:\n        print('NO')\n", "t = int(input())\nfor _  in range(t):\n    w = input()\n    h = input()\n    works = False\n    for i in range(len(h)):\n        ls = [h[x] if x < len(h) else \"\" for x in range(i, i + len(w))]\n        if sorted(ls) == sorted(w):\n            works = True\n            break\n    if works:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "def f(s1, s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    a = [0] * 26\n    b = [0] * 26\n    for i in range(n1):\n        a[ord(s1[i]) - ord('a')] += 1\n\n    for i in range(n2):\n        b[ord(s2[i]) - ord('a')] += 1\n        if i >= n1:\n            b[ord(s2[i - n1]) - ord('a')] -= 1\n        if a == b:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nn = int(input())\nfor i in range(n):\n    s1 = input()\n    s2 = input()\n    f(s1, s2)\n", "\nt=int(input())\nfor nt in range(t):\n    s=input()\n    s2=input()\n    ss=sorted(s)\n    n=len(s)\n    n2=len(s2)\n    isok=False\n    for i in range(n2-n+1):\n        if sorted(s2[i:i+n])==ss:\n            isok=True\n            break\n    if isok:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "for _ in range(int(input())):\n    l = list(input())\n    l.sort()\n    l = \"\".join(l)\n    x = len(l)\n    s = input()\n    n = len(s)\n    flag = False\n    for i in range(n):\n        m = list(s[i:i+x])\n        m.sort()\n        m = ''.join(m)\n        if(m==l):\n            flag = True\n            break\n    if(flag):\n        print(\"YES\")\n    else:\n        print('NO')", "n = int(input())\nfor i in range(n):\n    s = input()\n    s1 = input()\n    s = list(s)\n    s.sort()\n    f = False\n    new_s = ''.join(s)\n    for i in range(len(s1) - len(s) + 1):\n        now = list(s1[i:len(new_s) + i])\n        now.sort()\n        now = ''.join(now)\n        if now == new_s:\n            f = True\n    if f:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "def same(a,b):\n    L=[0]*26\n    for i in a:\n        L[ord(i)-97]+=1\n    for i in b:\n        L[ord(i)-97]-=1\n    if L==[0]*26:return True\n    return False\nfor i in ' '*int(input()):\n    p=input()\n    h=input()\n    if len(p)>len(h):print('NO')\n    else:\n        c=0\n        for j in range(len(h)-len(p)+1):\n            s=h[j:j+len(p)]\n            if same(p,s):c=1\n        if c:print('YES')\n        else:print('NO')", "for _ in range(int(input())):\n\ts = input()\n\tt = input()\n\ta = [i for i in s]\n\ta.sort()\n\tans = \"NO\"\n\tfor i in range(len(t)):\n\t\tb = []\n\t\tfor j in range(i,len(t)):\n\t\t\tb.append(t[j])\n\t\t\tb.sort()\n\t\t\tif a == b:\n\t\t\t\tans = \"YES\"\n\t\t\t\tbreak\n\t\tif(ans == \"YES\"): break\n\n\tprint(ans)\t\t\t", "import heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\n\ninput = sys.stdin.readline\nM = mod = 10**9 + 7\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input())\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\n\nfor _ in range(val()):\n    p = st()\n    h = st()\n    ans = 'NO'\n    for i in range(len(h) - len(p) + 1):\n        if sorted(p) == sorted(h[i:i+len(p)]):\n            ans = 'YES'\n            break\n    print(ans)", "from math import *\nfrom collections import *\nimport sys\nsys.setrecursionlimit(10**9)\nmod = 10**9 + 7\n\nt = int(input())\nfor y in range(t):\n\ts = input()\n\th = input()\n\tkey = 0\n\tn = len(h)\n\tm = len(s)\n\tc = Counter(s)\n\tfor i in range(n):\n\t\tif Counter(h[i:i+m]) == c:\n\t\t\tkey = 1\n\t\t\tbreak\n\tif(key == 1):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")", "from collections import Counter\n\ndef check():\n    pwd = input()\n    hsh = input()\n    pctr = Counter(pwd)\n    ctr = Counter(hsh[:len(pwd)])\n    if pctr == ctr:\n        return 'YES'\n    for i in range(len(hsh)-len(pwd)):\n        ctr[hsh[i]] -= 1\n        if ctr[hsh[i]] == 0:\n            del ctr[hsh[i]]\n        ctr[hsh[i+len(pwd)]] += 1\n        if pctr == ctr:\n            return 'YES'\n    return 'NO'\n\nfor tcase in range(int(input())):\n    print(check())\n    \n", "import sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef solve():\n    p = sorted(input())\n    h = input()\n    n = len(p)\n    m = len(h)\n    if n>m:\n        print(\"NO\")\n        return\n    for i in range(m-n+1):\n        if sorted(h[i:i+n]) == p:\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nt = int(input())\nfor i in range(t):\n    solve()\n\n", "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n#import random\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef StoI():\n    return [ord(i)-97 +10 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\n\n#sys.setrecursionlimit(10**5)\ninput=lambda: sys.stdin.readline().rstrip()\n\nshow_flg=False\nshow_flg=True\n\nt=I()\nfor _ in range(t):\n    p=input()\n    h=input()\n    np=len(p)\n    nh=len(h)\n    sp=sorted(p)\n    ans='NO'\n    for i in range(nh-np+1):\n        if sp==sorted(h[i:i+np]):\n            ans='YES'\n            break\n    print(ans)\n    \n"]
["import sys\ninput = sys.stdin.readline\n\nn,m,k,q=list(map(int,input().split()))\nTR=[list(map(int,input().split())) for i in range(k)]\nSAFE=list(map(int,input().split()))\nSAFE.sort()\n\nTRLIST=[[] for i in range(n+1)]\n\nfor x,y in TR:\n    TRLIST[x].append(y)\n\nwhile TRLIST[-1]==[]:\n    TRLIST.pop()\n    n-=1\n\n\nSTART={1:0} #place,step\n\nimport bisect\n\nfor step in range(1,n):\n    if TRLIST[step]==[] and step!=1:\n        continue\n    elif TRLIST[step]==[] and step==1:\n        MIN=MAX=1\n    else:\n        MIN=min(TRLIST[step])\n        MAX=max(TRLIST[step])\n\n    MINind=max(0,bisect.bisect_left(SAFE,MIN)-1)\n    MIN_L=SAFE[MINind]\n    if MINind==q-1:\n        MIN_R=MIN_L\n    else:\n        MIN_R=SAFE[MINind+1]\n\n    MAXind=max(0,bisect.bisect_left(SAFE,MAX)-1)\n    MAX_L=SAFE[MAXind]\n    if MAXind==q-1:\n        MAX_R=MAX_L\n    else:\n        MAX_R=SAFE[MAXind+1]\n    \n\n    NEXT=dict()\n\n    for start in START:\n        st=START[start]\n        \n        NEXT[MIN_L]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_L-MIN),NEXT.get(MIN_L,1<<50))\n        NEXT[MIN_R]=min(st+abs(MAX-start)+abs(MAX-MIN)+abs(MIN_R-MIN),NEXT.get(MIN_R,1<<50))\n        NEXT[MAX_L]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_L-MAX),NEXT.get(MAX_L,1<<50))\n        NEXT[MAX_R]=min(st+abs(MIN-start)+abs(MAX-MIN)+abs(MAX_R-MAX),NEXT.get(MAX_R,1<<50))\n\n    START=NEXT\n    #print(START)\n\nLAST=1<<50\n\nif TRLIST[n]==[]:\n    print(min(START.values())+n-1)\n    return\n\nMIN=min(TRLIST[n])\nMAX=max(TRLIST[n])\n#print(START)\nfor start in START:\n    st=START[start]\n    \n    LAST=min(LAST,st+abs(MAX-start)+abs(MAX-MIN),st+abs(MIN-start)+abs(MAX-MIN))\n\n\nprint(LAST+n-1)\n\n    \n    \n", "import sys\n\nn, m, k, q = list(map(int, sys.stdin.readline().strip().split()))\nT = [0] * k\nfor i in range (0, k):\n    T[i] = list(map(int, sys.stdin.readline().strip().split()))\n    T[i][1] = T[i][1] - 1\n    T[i][0] = T[i][0] - 1\nT.sort() # treasures sorted by row\nb = list(map(int, sys.stdin.readline().strip().split()))\nb.sort()\nfor i in range (0, q):\n    b[i] = b[i] - 1     # sorted safe columns\nL = [b[0]] * m          # safe column left\nR = [b[-1]] * m         # safe column right\nR1 = [10 ** 6] * n      # leftmost treasure\nR2 = [-1] * n           # rightmost treasure\nn1 = 0                  # pathlength 1\nn2 = 0                  # pathlength 2\nfor i in range (0, k):\n    R1[T[i][0]] = min(R1[T[i][0]], T[i][1])\n    R2[T[i][0]] = max(R2[T[i][0]], T[i][1])\nfor i in range (0, q):\n    L[b[i]] = b[i]\n    R[b[i]] = b[i]\nfor i in range (1, m):\n    L[i] = max([L[i-1], L[i]])\n    R[m-i-1] = min([R[m-i], R[m-i-1]])\nr = 0\nc1 = 0\nc2 = 0\nn1 = 0\nn2 = 0\nif R2[0] != -1:\n    c1 = R2[0]\n    c2 = R2[0]\n    n1 = R2[0]\n    n2 = R2[0]\nfor i in range (1, n):\n    if R2[i] != -1:\n        r, c1, c2, n2, n1 = i, R1[i], R2[i], i-r+abs(R1[i]-R2[i])+min([n1+abs(c1-L[c1])+abs(R1[i]-L[c1]), n2+abs(c2-L[c2])+abs(R1[i]-L[c2]), n1+abs(c1-R[c1])+abs(R1[i]-R[c1]), n2+abs(c2-R[c2])+abs(R1[i]-R[c2])]), i-r+abs(R1[i]-R2[i])+min([n1+abs(c1-L[c1])+abs(R2[i]-L[c1]), n2+abs(c2-L[c2])+abs(R2[i]-L[c2]), n1+abs(c1-R[c1])+abs(R2[i]-R[c1]), n2+abs(c2-R[c2])+abs(R2[i]-R[c2])])\nprint(min([n1, n2]))\n", "bn = 0\nar = []\ndef  binSearchMax(number):\n    last = bn\n    first = 0\n    mid = (last + first) // 2\n    while(last >= first):\n        if(ar[mid] < number):\n            first = mid + 1\n        elif(ar[mid] > number):\n            last = mid - 1\n        else:\n            return mid\n        mid = (last + first) // 2\n    if (ar[last] == number):\n        return last\n    return first\n\nn, m, k, q = list(map(int,input().split()))\nmmn = [[m,-1] for i in range(n)]\nmaxn = 0\nfor i in range(k):\n    r, c = list(map(int,input().split()))\n    r -= 1\n    mmn[r][0] = min(mmn[r][0],c)\n    mmn[r][1] = max(mmn[r][1],c)\n    maxn = max(maxn,r)\nif mmn[0][1] == -1:\n    mmn[0][1] = 1\nmmn[0][0] = 1\nbi = list(map(int,input().split()))\nbi += [-1000000000, 10000000000, -1000000000, 10000000000, 10000000000]\nbi.sort()\nar = bi\nbn = q + 3\ndp = [[0,0] for i in range(n)]\n\ndp[0][1] = mmn[0][1] - mmn[0][0]\ndp[0][0] = dp[0][1] * 2\nz = 0\nfor i in range(1,n):\n    if mmn[i][1] == -1:\n        dp[i][0] = dp[i-1][0]\n        dp[i][1] = dp[i-1][1] \n        continue\n    p1 = binSearchMax(mmn[z][0])\n    p2 = bi[p1-1]\n    p1 = bi[p1]\n    p3 = binSearchMax(mmn[z][1])\n    p4 = bi[p3-1]\n    p3 = bi[p3]\n    num1 = abs(p1 - mmn[i][1]) + abs(p1 - mmn[z][0]) + dp[z][0]\n    num2 = abs(p2 - mmn[i][1]) + abs(p2 - mmn[z][0]) + dp[z][0]\n    num3 = abs(p3 - mmn[i][1]) + abs(p3 - mmn[z][1]) + dp[z][1]\n    num4 = abs(p4 - mmn[i][1]) + abs(p4 - mmn[z][1]) + dp[z][1] \n    dp[i][0] = min(min(num1,num2),min(num3,num4)) + mmn[i][1] - mmn[i][0]\n    num1 = abs(p1 - mmn[i][0]) + abs(p1 - mmn[z][0]) + dp[z][0]\n    num2 = abs(p2 - mmn[i][0]) + abs(p2 - mmn[z][0]) + dp[z][0]\n    num3 = abs(p3 - mmn[i][0]) + abs(p3 - mmn[z][1]) + dp[z][1]\n    num4 = abs(p4 - mmn[i][0]) + abs(p4 - mmn[z][1]) + dp[z][1]\n    dp[i][1] = min(min(num1,num2),min(num3,num4)) + mmn[i][1] - mmn[i][0]\n    z = i\nprint(min(dp[-1]) + maxn)\n", "def lsearch(arr, v):\n    if arr[0] > v:\n        return None\n    l = 0\n    r = len(arr) - 1\n    while (r-l>1):\n        m = (l+r)//2\n        if arr[m] > v:\n            r = m\n        else:\n            l = m\n    if arr[r] <= v:\n        return arr[r]\n    return arr[l]\n\n\ndef rsearch(arr, v):\n    if arr[-1] < v:\n        return None\n    l = 0\n    r = len(arr) - 1\n    while (r-l>1):\n        m = (l+r)//2\n        if arr[m] >= v:\n            r = m\n        else:\n            l = m\n    if arr[l] >= v:\n        return arr[l]\n    return arr[r]\n\n\ndef lcost(start, s, b):\n    l = lsearch(b, start)\n    r = rsearch(b, start)\n    if l is None:\n        l = r\n    if r is None:\n        r = l\n    vl = abs(start-l) + abs(s[-1]-l) + abs(s[0]-s[-1])\n    vr = abs(start-r) + abs(s[-1]-r) + abs(s[0]-s[-1])\n    return min(vl, vr)\n\n\ndef rcost(start, s, b):\n    l = lsearch(b, start)\n    r = rsearch(b, start)\n    if l is None:\n        l = r\n    if r is None:\n        r = l\n    vl = abs(start-l) + abs(s[0]-l) + abs(s[0]-s[-1])\n    vr = abs(start-r) + abs(s[0]-r) + abs(s[0]-s[-1])\n    return min(vl, vr)\n\n\n\nn, m, k, q = map(int, input().split())\nss = [[] for _ in range(n)]\nfor _ in range(k):\n    r, c = map(int, input().split())\n    ss[r-1].append(c-1)\n\nbs = list(map(lambda x: int(x)-1, input().split()))\nbs.sort()\n\nfor row in ss:\n    row.sort()\n\nlc = 0\nrc = 0\nl = 0\nr = 0\nif ss[0]:\n    l = ss[0][-1]\n    r = ss[0][-1]\n    lc = rc = l\ntop = 0\nfor ind, s in enumerate(ss[1:]):\n    if s:\n        nlc = min(lcost(l, s, bs)+lc, lcost(r, s, bs)+rc)\n        nrc = min(rcost(l, s, bs)+lc, rcost(r, s, bs)+rc)\n        lc = nlc\n        rc = nrc\n        l = s[0]\n        r = s[-1]\n        top = ind+1\n\nres = min(lc, rc) + top\nprint(res)", "import bisect\n\nn, m, k, q = map(int, input().split())\n\n# min, max\nvals = {}\nvals[1] = [1, 1]\nfor i in range(k):\n\tr, c = map(int, input().split())\n\tif r not in vals:\n\t\tvals[r] = [c, c]\n\telse:\n\t\tvals[r][0] = min(vals[r][0], c)\n\t\tvals[r][1] = max(vals[r][1], c)\n\nq = list(map(int, input().split()))\nq.sort()\n\ndef find_shortest(lower, upper, row):\n\tif row==1:\n\t\treturn upper-1\n\n\tif lower > upper:\n\t\treturn find_shortest(upper, lower, row)\n\n\tpos = bisect.bisect_left(q, lower)\n\toptions = []\n\tif pos < len(q):\n\t\tif q[pos]<=upper:\n\t\t\treturn upper-lower\n\t\telse:\n\t\t\toptions.append(q[pos] - lower + q[pos] - upper)\n\t\n\n\tpos2 = bisect.bisect_left(q, lower) - 1\n\tif pos2 >= 0:\n\t\toptions.append(lower - q[pos2] + upper - q[pos2])\n\treturn min(options)\n\nhighest = 1\nold_a, old_b = 0, 0\npos_a, pos_b = 1, 1\nfor row in range(1, n+1):\n\tif not row in vals:\n\t\tcontinue\n\thighest = row\n\trow_min, row_max = vals[row]\n\n\tnew_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n\tnew_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n\n\told_a, old_b = new_a, new_b\n\tpos_a, pos_b = row_min, row_max\n\t#print(old_a, old_b)\n\ntotal = highest - 1\ntotal += min(old_a, old_b)\n\nprint(total)", "# see bisect module:\n# https://codeforces.com/contest/1201/submission/58302708\n\n# python complexity:\n# https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt\n\n# solve using DP\n\nn, m, k, q = map(int, input().split())\n# n rows\n# m cols\n\ntr_min = [None for _ in range(n)]\ntr_max = [None for _ in range(n)]\nfor _ in range(k):\n    row, col = map(int, input().split())\n    row = n - row\n    col -= 1\n    if tr_min[row] == None or col < tr_min[row]:\n        tr_min[row] = col\n    if tr_max[row] == None or col > tr_max[row]:\n        tr_max[row] = col\ntr_min[-1] = 0\ntr_max[-1] = tr_max[-1] or 0\n\nsavecols = sorted(map(lambda t: int(t) - 1, input().split()))\n# binary search? :)\ndef binsearch(arr, val):\n    l, r = 0, len(arr)-1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if (arr[mid] < val):\n            l = mid + 1\n        elif (arr[mid] > val):\n            r = mid - 1\n        else:\n            return mid\n\n    return r\n    \n\ndef find_short_descent(A, B):\n    if A > B:\n        return find_short_descent(B, A) # this is invariant\n\n    idx1 = binsearch(savecols, A)\n    idx2 = idx1 + 1\n    minval = m*m\n    if idx2 < len(savecols):\n        if savecols[idx2] < B:\n            return B - A\n        else:\n            minval = min(minval, (savecols[idx2] << 1) - A - B)\n\n    if idx1 >= 0:\n        minval = min(minval, A + B - (savecols[idx1] << 1))\n    return minval\n\n\n\nl, r = 0, 0\nfound_valid = False\nlast_valid = None\nfor row in range(0, n):\n    #insert idea here\n    if found_valid == False:\n        if tr_min[row] != None:\n            found_valid = True\n            last_valid = row\n            l = (tr_max[row] - tr_min[row])\n            r = (tr_max[row] - tr_min[row])\n            continue\n        continue\n    \n    if tr_min[row] == None:\n        l += 1\n        r += 1\n        continue\n\n    ll = find_short_descent(tr_min[last_valid], tr_min[row])\n    lr = find_short_descent(tr_min[last_valid], tr_max[row])\n    rl = find_short_descent(tr_max[last_valid], tr_min[row])\n    rr = find_short_descent(tr_max[last_valid], tr_max[row])\n        \n    #l += min(ll, rl) + 1 + (tr_max[row] - tr_min[row])\n    #r += min(lr, rr) + 1 + (tr_max[row] - tr_min[row])\n    #l, r = r, l\n    new_l = min(l + lr, r + rr) + 1 + (tr_max[row] - tr_min[row])\n    new_r = min(l + ll, r + rl) + 1 + (tr_max[row] - tr_min[row])\n    l, r = new_l, new_r\n    last_valid = row\n\n# insert last step on row n here\nansw = l + tr_min[last_valid]\nprint(answ)", "# see bisect module:\n# https://codeforces.com/contest/1201/submission/58302708\n\n# python complexity:\n# https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt\n\n# solve using DP\n\nn, m, k, q = map(int, input().split())\n# n rows\n# m cols\n\ntr_min = [None for _ in range(n)]\ntr_max = [None for _ in range(n)]\nfor _ in range(k):\n    row, col = map(int, input().split())\n    row = n - row\n    col -= 1\n    if tr_min[row] == None or col < tr_min[row]:\n        tr_min[row] = col\n    if tr_max[row] == None or col > tr_max[row]:\n        tr_max[row] = col\ntr_min[-1] = 0\ntr_max[-1] = tr_max[-1] or 0\n\nsavecols = sorted(map(lambda t: int(t) - 1, input().split()))\n# binary search? :)\ndef binsearch(arr, val):\n    l, r = 0, len(arr)-1\n    while l <= r:\n        mid = l + (r - l) // 2\n        if (arr[mid] < val):\n            l = mid + 1\n        elif (arr[mid] > val):\n            r = mid - 1\n        else:\n            return mid\n\n    return r\n    \n\ndef find_short_descent(A, B):\n    if A > B:\n        return find_short_descent(B, A) # this is invariant\n\n    idx1 = binsearch(savecols, A)\n    idx2 = idx1 + 1\n    minval = 2 * m # for both directions\n    if idx2 < len(savecols):\n        if savecols[idx2] < B:\n            return B - A\n        else:\n            minval = min(minval, (savecols[idx2] << 1) - A - B)\n\n    if idx1 >= 0:\n        minval = min(minval, A + B - (savecols[idx1] << 1))\n    return minval\n\n\n\nl, r = 0, 0\nfound_valid = False\nlast_valid = None\nfor row in range(0, n):\n    #insert idea here\n    if found_valid == False:\n        if tr_min[row] != None:\n            found_valid = True\n            last_valid = row\n            l = (tr_max[row] - tr_min[row])\n            r = (tr_max[row] - tr_min[row])\n            continue\n        continue\n    \n    if tr_min[row] == None:\n        l += 1\n        r += 1\n        continue\n\n    ll = find_short_descent(tr_min[last_valid], tr_min[row])\n    lr = find_short_descent(tr_min[last_valid], tr_max[row])\n    rl = find_short_descent(tr_max[last_valid], tr_min[row])\n    rr = find_short_descent(tr_max[last_valid], tr_max[row])\n        \n    #l += min(ll, rl) + 1 + (tr_max[row] - tr_min[row])\n    #r += min(lr, rr) + 1 + (tr_max[row] - tr_min[row])\n    #l, r = r, l\n    new_l = min(l + lr, r + rr) + 1 + (tr_max[row] - tr_min[row])\n    new_r = min(l + ll, r + rl) + 1 + (tr_max[row] - tr_min[row])\n    l, r = new_l, new_r\n    last_valid = row\n\n# insert last step on row n here\nansw = l + tr_min[last_valid]\nprint(answ)", "from bisect import *\n\nn, m, k, q = list(map(int, input().split()))\nright = [-1] * n\nleft = [-1] * n\nfor i in range(k):\n    row, col = list(map(int, input().split()))\n    row -= 1\n    col -= 1\n    if right[row] == -1:\n        right[row] = left[row] = col\n    else:\n        right[row] = max(right[row], col)\n        left[row] = min(left[row], col)\nsafe = sorted(list([int(qi) - 1 for qi in input().split()]))\n\n\n# print(safe)\n\ndef dist(lower, upper, row):\n    if lower > upper:\n        return dist(upper, lower, row)\n    pos = bisect_left(safe, lower)\n    options = []\n    if pos < len(safe):\n        if safe[pos] <= upper:\n            return upper - lower\n        else:\n            options.append(safe[pos] - lower + safe[pos] - upper)\n    pos2 = bisect_left(safe, lower) - 1\n    if pos2 >= 0:\n        options.append(lower - safe[pos2] + upper - safe[pos2])\n    return min(options)\n\n\nif left[0] == -1:\n    left[0] = right[0] = 0\ndleft = right[0] + (right[0] - left[0])\ndright = right[0]\nlastn = 0\nfor i in range(1, n):\n    if left[i] == -1:\n        continue\n    ilen = right[i] - left[i]\n    dleft_new = min(dleft + dist(left[lastn], right[i], i), dright + dist(right[lastn], right[i], i)) + ilen\n    dright_new = min(dleft + dist(left[lastn], left[i], i), dright + dist(right[lastn], left[i], i)) + ilen\n    dleft, dright = dleft_new, dright_new\n    lastn = i\nprint(min(dleft, dright) + lastn)\n", "from bisect import *\n\nn, m, k, q = list(map(int, input().split()))\nright = [-1] * n\nleft = [-1] * n\nfor i in range(k):\n    row, col = list(map(int, input().split()))\n    row -= 1\n    col -= 1\n    if right[row] == -1:\n        right[row] = left[row] = col\n    else:\n        right[row] = max(right[row], col)\n        left[row] = min(left[row], col)\nsafe = sorted(list([int(qi) - 1 for qi in input().split()]))\n\n\n# print(safe)\n\ndef dist(lower, upper, row):\n    posr = bisect_left(safe, lower)\n    options = []\n    if posr < len(safe):\n        options.append(safe[posr] - lower + abs(safe[posr] - upper))\n    posl = posr - 1\n    if posl >= 0:\n        options.append(lower - safe[posl] + abs(upper - safe[posl]))\n    return min(options)\n\n\nif left[0] == -1:\n    left[0] = right[0] = 0\ndleft = right[0] + (right[0] - left[0])\ndright = right[0]\nlastn = 0\nfor i in range(1, n):\n    if left[i] == -1:\n        continue\n    ilen = right[i] - left[i]\n    dleft_new = min(dleft + dist(left[lastn], right[i], i), dright + dist(right[lastn], right[i], i)) + ilen\n    dright_new = min(dleft + dist(left[lastn], left[i], i), dright + dist(right[lastn], left[i], i)) + ilen\n    dleft, dright = dleft_new, dright_new\n    lastn = i\nprint(min(dleft, dright) + lastn)\n", "import math\nn, m, k, q = list(map(int, input().split()))\nright = [-1] * n\nleft  = [-1] * n\nfor i in range(k):\n    row, col = list(map(int, input().split()))\n    row -= 1\n    col -= 1\n    if right[row] == -1:\n        right[row] = left[row] = col\n    else:\n        right[row] = max(right[row], col)\n        left[row] = min(left[row], col)\nsafe = sorted(list([int(qi) - 1 for qi in input().split()]))\nlup = [0] * m\nrup = [0] * m\nj = 0\nwhile j < safe[0]:\n    lup[j] = -1\n    rup[j] = safe[0]\n    j += 1\nlup[j] = rup[j] = safe[0]\nfor i in range(1, q):\n    j = safe[i - 1]\n    while j < safe[i]:\n        lup[j] = safe[i - 1]\n        rup[j] = safe[i]\n        j += 1\nj = safe[-1]\nwhile j < m:\n    lup[j] = safe[-1]\n    rup[j] = -1\n    j += 1\nif left[0] == -1:\n    left[0] = right[0] = 0\ndleft = right[0] + (right[0] - left[0])\ndright = right[0]\nlastn = 0\nfor i in range(1, n):\n    if left[i] == -1:\n        continue\n    left_1b = lup[left[lastn]]\n    left_2b = rup[left[lastn]]\n    right_1b = lup[right[lastn]]\n    right_2b = rup[right[lastn]]\n    ilen = right[i] - left[i]\n    ll1 : int\n    ll2 : int\n    rl1 : int\n    rl2 : int\n    if left_1b != -1:\n        ll1 = (left[lastn] - left_1b) + abs(right[i] - left_1b)\n    else:\n        ll1 = math.inf\n    if left_2b != -1:\n        ll2 = (left_2b - left[lastn]) + abs(right[i] - left_2b)\n    else:\n        ll2 = math.inf\n    if right_1b != -1:\n        rl1 = (right[lastn] - right_1b) + abs(right[i] - right_1b)\n    else:\n        rl1 = math.inf\n    if right_2b != -1:\n        rl2 = (right_2b - right[lastn]) + abs(right[i] - right_2b)\n    else:\n        rl2 = math.inf\n    dleft_new = min(dleft + min(ll1, ll2), dright + min(rl1, rl2)) + ilen\n    lr1 : int\n    lr2 : int\n    rr1: int\n    rr2: int\n    if left_1b != -1:\n        lr1 = (left[lastn] - left_1b) + abs(left[i] - left_1b)\n    else:\n        lr1 = math.inf\n    if left_2b != -1:\n        lr2 = (left_2b - left[lastn]) + abs(left[i] - left_2b)\n    else:\n        lr2 = math.inf\n    if right_1b != -1:\n        rr1 = (right[lastn] - right_1b) + abs(left[i] - right_1b)\n    else:\n        rr1 = math.inf\n    if right_2b != -1:\n        rr2 = (right_2b - right[lastn]) + abs(left[i] - right_2b)\n    else:\n        rr2 = math.inf\n    dright_new = min(dleft + min(lr1, lr2), dright + min(rr1, rr2)) + ilen\n    dleft, dright = dleft_new, dright_new\n    lastn = i\nprint(min(dleft, dright) + lastn)\n", "from bisect import bisect_left\nn, m, k, q = list(map(int, input().split()))\nx = sorted(list(map(int, input().split())) for _ in range(k))\ny = sorted(map(int, input().split()))\n\ndef rr(c0, c1, c):\n    return abs(c0 - c) + abs(c1 - c)\n    \ndef tm(c0, c1):\n    t = bisect_left(y, c0)\n    tt = []\n    if t > 0:\n        tt.append(rr(c0, c1, y[t-1]))\n    if t < q:\n        tt.append(rr(c0, c1, y[t]))\n    return min(tt)\n\nz = []\nfor r, c in x:\n    if z and z[-1][0] == r:\n        z[-1][2] = c\n    else:\n        z.append([r, c, c])\nv1, v2, r0, c01, c02 = 0, 0, 1, 1, 1\nfor r1, c11, c12 in z:\n    d = c12 - c11 + r1 - r0\n    if r1 > r0:\n        d11 = tm(c01, c11)\n        d12 = tm(c01, c12)\n        d21 = tm(c02, c11)\n        d22 = tm(c02, c12)\n        v2, v1 = d + min(v1 + d11, v2 + d21), d + min(v1 + d12, v2 + d22)\n    else:\n        v1, v2 = d + c12 - c02, d + c11 - c01\n    r0, c01, c02 = r1, c11, c12\nprint(min(v1, v2))\n", "def nearest(point):\n    l = 0\n    r = q\n    while r - l > 1:\n        mid = int((r + l) / 2)\n        if safe[mid] <= point:\n            l = mid\n        else:\n            r = mid\n    if safe[l] > point:\n        return [safe[l]]\n    elif l + 1 == q:\n        return [safe[l]]\n    else:\n        return [safe[l], safe[l + 1]]\n\n\ndef way(come, row, side=True):\n    between = abs(right[row] - left[row])\n    if side:\n        return abs(come - left[row]) + between\n    else:\n        return abs(come - right[row]) + between\n\n\nn, m, k, q = [int(x) for x in input().split()]\nright = [-1] * n\nleft = [-1] * n\n\nfor i in range(k):\n    a, b = [int(x) - 1 for x in input().split()]\n    if right[a] == -1:\n        right[a] = left[a] = b\n    else:\n        right[a] = max(right[a], b)\n        left[a] = min(left[a], b)\nsafe = [int(x) - 1 for x in input().split()]\nsafe.sort()\nleft[0] = right[0]\nif right[0] == -1:\n    L = R = min(nearest(0))\n    right[0] = left[0] = L\nelse:\n    L = R = right[0]\nwhile right[n - 1] == -1:\n    n -= 1\nlast = 0\nfor i in range(1, n):\n    # print(last)\n    # print(L, R)\n    L += 1\n    R += 1\n    if right[i] == -1:\n        continue\n    left_way = 100000000000\n    right_way = 100000000000\n    lcolumns = nearest(left[last])\n    rcolumns = nearest(right[last])\n    for c in lcolumns:\n        left_way = min(left_way, L + way(c, i, False) + abs(c - left[last]))\n        right_way = min(right_way, L + way(c, i, True) + abs(c - left[last]))\n    for c in rcolumns:\n        left_way = min(left_way, R + way(c, i, False) + abs(c - right[last]))\n        right_way = min(right_way, R + way(c, i, True) + abs(c - right[last]))\n    # print(left_way, right_way)\n    L = left_way\n    R = right_way\n    last = i\nprint(min(L, R))#+ (n - 1))", "import sys\nn, m, k, q = [int(i) for i in sys.stdin.readline().split()]\nindata = sys.stdin.readlines()\ndata = []\ninf = 1<<50\n\n\nfor i in range(k):\n    data.append(tuple([int(f) for f in indata[i].split()]))\n\ndata.sort()\nchutes = [int(i) for i in indata[-1].split()]\nchutes.sort()\nnearch = [(0,0)]*(m+1)\nfor i in range(1, chutes[0]+1):\n    nearch[i] = (chutes[0], chutes[0])\nfor i in range(q-1):\n    a = chutes[i] \n    b = chutes[i+1]\n    for j in range(a+1, b):\n        nearch[j] = (a,b)\n    nearch[b] = (b,b)\nfor i in range(chutes[-1], m+1):\n    nearch[i] = (chutes[-1],chutes[-1])\n\nlastr = -1\nrows = []\nrowdata = {}\nfor d in data:\n    if d[0] != lastr:\n        lastr = d[0]\n        rows.append(d[0])\n        rowdata[d[0]] = []\n    rowdata[d[0]].append(d[1])\n\n\ndp = [ [ (1, 0), (1, 0) ] ]\nstart = 0\nif rows[0] == 1:\n    #1+' '\n    #dp[0] = [   (rowdata[1][-1], rowdata[1][-1] - 1 ) ,    (rowdata[1][0], 2 * rowdata[1][-1] - rowdata[1][0] - 1) ]\n    dp[0] = [   (rowdata[1][-1], rowdata[1][-1] - 1 ) ,    (1, inf) ]\n    start = 1\n\nlnr = len(rows)\nfor i in range(start, lnr):\n    row = rowdata[rows[i]]\n    # ldp = dp[-1]\n    LR = (0,inf)\n    for f in range(4):\n        ldp = dp[-1][f//2]\n        am = ldp[1]\n        d = nearch[ldp[0]][f%2]\n        am += abs(ldp[0] - d)\n        am += abs(d - row[0])\n        am += row[-1] - row[0]\n\n        if am < LR[1]:\n            LR = (row[-1], am)\n    \n    RL = (0,inf)\n    for f in range(4):\n        ldp = dp[-1][f//2]\n        am = ldp[1]\n        d = nearch[ldp[0]][f%2]\n        am += abs(ldp[0] - d)\n        am += abs(d - row[-1])\n        am += row[-1] - row[0]\n\n        if am < RL[1]:\n            RL = (row[0], am)\n    dp.append([LR, RL])\n\n\n\n# print(rows)\n# print(rowdata) \n# print(dp)\n\nprint(min(dp[-1][0][1], dp[-1][1][1]) + rows[-1] - 1)\n\n\n\n", "from sys import stdin\nfrom bisect import bisect_left\ninput=stdin.readline\nn,m,k,q=list(map(int,input().split(' ')))\nx=sorted(list(map(int,input().split(' ')))for i in range(k))\ny=sorted(list(map(int,input().split(' '))))\ndef rr(c0,c1,c2):\n    return abs(c2-c0)+abs(c1-c2)\n\ndef tm(c0,c1):\n    t=bisect_left(y,c0)\n    tt=[]\n    if (t>0):\n        tt.append(rr(c0,c1,y[t-1]))\n    if (t<q):\n        tt.append(rr(c0,c1,y[t]))\n    return min(tt)\n\n    \n\n\n\n\n\n# th\u1ef1c hi\u1ec7n t\u00ecm xem trong m\u1ed9t h\u00e0ng, kho b\u00e1u n\u1eb1m t\u1eeb kho\u1ea3ng n\u00e0o \u0111\u1ebfn kho\u1ea3ng n\u00e0o.\nz=[]\nfor r,c in x:\n    if z and z[-1][0]==r:\n        z[-1][2]=c\n    else:\n        z.append([r,c,c])\nv1,v2,r0,c01,c02=0,0,1,1,1\nfor r1,c11,c12 in z:\n    d=c12-c11+r1-r0\n    # b\u00ecnh th\u01b0\u1eddng\n    if(r1>r0):\n        d01=tm(c01,c11)\n        d02=tm(c01,c12)\n        d11=tm(c02,c11)\n        d12=tm(c02,c12)\n        v2,v1=d+min(v1+d01,v2+d11),d +min(v1+d02,v2+d12)\n\n    #n\u1ebfu c\u00f3 kho b\u00e1u \u1edf h\u00e0ng 1\n    else:\n        v1,v2=d+c12-c02,d+c11-c01\n    c01,c02,r0=c11,c12,r1\nans=min(v1,v2)\nprint(ans)\n"]
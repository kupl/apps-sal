["n = int(input())\na = list(map(int, input().split()))\ns = d = 0\nm = {i: [] for i in range(1, n + 1)}\nfor i in range(n):\n    m[a[i]] += [i]\nfor i in range(n, 2 * n):\n    m[a[i]] += [i]\nres = 0\nfor i in sorted(m):\n    if s > d:\n        s, d = d, s\n    a, b = m[i]\n    if a > b:\n        a, b = b, a\n    res += abs(s - a) + abs(b - d)\n    s, d = a, b\nprint(res)", "n = int(input())\na = [int(i) for i in input().split()]\nt = [[] for i in range(n + 1)]\nt[0] = [0, 0]\nfor i in range(2 * n):\n    t[a[i]].append(i)\nsu = 0\n# print(t)\nfor i in range(1, n + 1):\n    su += abs(t[i][0] - t[i - 1][0]) + abs(t[i][1] - t[i - 1][1])\nprint(su)", "from collections import defaultdict as dd\nimport math\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\nn=nn()\n\nl=lm()\n\nd={}\nfor i in range(2*n):\n\tif l[i] in d:\n\t\td[l[i]].append(i)\n\telse:\n\t\td[l[i]]=[i]\n\n\n\ns1=0\ns2=0\ntot=0\n\nfor i in range(n):\n\td1=d[i+1][0]\n\td2=d[i+1][1]\n\tdist=min(abs(s1-d1)+abs(s2-d2),abs(s1-d2)+abs(s2-d1))\n\ttot=tot+dist\n\ts1=d1\n\ts2=d2\n\nprint(tot)\n\n\n\n\n\n\n\n", "n=int(input())\na=list(map(int,input().split()))\nres=[[] for i in range(n)]\nfor i in range(2*n):\n    res[a[i]-1].append(i)\nlast1=0\nlast2=0\nsu=0\nfor i in range(n):\n    su+=min(abs(last1-res[i][0])+abs(last2-res[i][1]),abs(last1-res[i][1])+abs(last2-res[i][0]))\n    last1=res[i][0]\n    last2=res[i][1]\nprint(su)\n", "n = int(input())\na = list(map(int, input().split()))\n\nd = {}\n\nfor i in range(1, n+1):\n    d[i] = []\n\nfor i in range(2*n):\n    d[a[i]].append(i)\n\np1=p2=0\nans = 0\nfor i in range(1, n+1):\n    d1,d2 = d[i][0], d[i][1]\n    ans += min([abs(d1-p1) + abs(d2-p2), abs(d2-p1) + abs(d1-p2)])\n    p1,p2 = d1, d2\nprint(ans)", "N = int(input())\nA = [int(a) for a in input().split()]\nL = [-1] * N\nR = [0] * N\n\nfor i in range(2*N):\n    a = A[i] - 1\n    if L[a] < 0:\n        L[a] = i\n    else:\n        R[a] = i\n\ns = L[0]+R[0]\nfor i in range(N-1):\n    s += abs(L[i+1] - L[i]) + abs(R[i+1] - R[i])\n\nprint(s)\n", "n = int(input())\nl = [*map(int, input().split())]\ns = set()\nl1, l2 = [], []\nfor i, e in enumerate(l):\n    if e in s:\n        l2.append((e, i))\n    else:\n        l1.append((e, i))\n        s.add(e)\n\nl1.sort()\nl2.sort()\n\nres = 0\n\nprev = 0\nfor e, i in l1:\n    res += abs(i - prev)\n    prev = i\nprev = 0\nfor e, i in l2:\n    res += abs(i - prev)\n    prev = i\n\nprint(res)", "n = int(input())\na = list(map(int, input().split()))\n\np1 = 0\np2 = 0\ntotal = 0\n\npos = {}\nfor i in range(n):\n    pos[i] = []\n\nfor i, val in enumerate(a):\n    pos[val - 1].append(i)\n\nfor i in range(n):\n    d1, d2 = pos[i]\n\n    if p1 > p2:\n        p1, p2 = p2, p1\n\n    total += abs(p1 - d1)\n    total += abs(p2 - d2)\n    p1, p2 = d1, d2\n\nprint(total)", "n = int(input())\na = list(map(int, input().split()))\na = [a[i] - 1 for i in range(2 * n)] \nf = [-1] * n\nl = [-1] * n\nfor i in range(2 * n):\n    if f[a[i]] == -1:\n        f[a[i]] = i\n    else:\n        l[a[i]] = i\nans = 0\ncur = 0\nfor i in range(n):\n    ans += abs(f[i] - cur)\n    cur = f[i]\ncur = 0\nfor i in range(n):\n    ans += abs(l[i] - cur)\n    cur = l[i]\nprint(ans)", "n=int(input())\nd1={}\nd2={}\na=list(map(int,input().split()))\nfor i in range(2*n):\n\tif a[i] not in d1:\n\t\td1[a[i]]=i\n\telse:\n\t\td2[a[i]]=i\nans=abs(d1[1])\nans+=abs(d2[1])\nfor i in range(2,n+1):\n\tans+=abs(d1[i]-d1[i-1])\n\tans+=abs(d2[i]-d2[i-1])\nprint(ans)\n", "n = input()\nn = int(n)\na = input()\na = a.split()\na = [int(i) for i in a]\nnum = []\nfor _ in range(n):\n    num.append(list())\nfor _, i in enumerate(a):\n    num[i-1].append(_)\nanswer = num[0][0] + num[0][1]\nfor n in range(len(num)-1):\n    answer = answer + min(abs(num[n][0] - num[n+1][0]) + abs(num[n][1] - num[n+1][1]),\n                          abs(num[n][0] - num[n+1][1]) + abs(num[n][1] - num[n+1][0]))\nprint(answer)", "def B():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = {i:[] for i in range(1,n+1)}\n    d[0]= [0,0]\n    for i in range(2*n):\n        d[a[i]].append(i)\n    ans = 0\n    for i in range(n):\n        a , b = d[i] , d[i+1]\n        ans+= min(abs(b[0]-a[0])+abs(b[1]-a[1]) , abs(b[0]-a[1])+abs(b[1]-a[0]))\n    print(ans)\n\nB()\n", "\nn = int(input())\n\narr = list(map(int,input().strip().split()))\n\nans = [[] for i in range(n)]\n\nfor i in range(2*n):\n    ans[arr[i]-1].append(i)\n\n#print(ans)\nan = 0\nfor i in range(n):\n    if i==0:\n        an+=ans[i][0]+ans[i][1]\n    else:\n        v1 = abs(ans[i][0]-ans[i-1][0])+abs(ans[i][1]-ans[i-1][1])\n        v2 = abs(ans[i][0]-ans[i-1][1])+abs(ans[i][1]-ans[i-1][0])\n        an+=min(v1,v2)\nprint(an)\n", "n = int(input())\nai = list(map(int,input().split()))\nans = 0\ndists = [[0,0] for i in range(n+1)]\ndists[0][1] = 1\ndists[0][0] = 1\nj = 1\nfor i in ai:\n    if dists[i][0] == 0:\n        dists[i][0] = j\n    else:\n        dists[i][1] = j\n    j += 1\nfor i in range(n):\n    ans += min(abs(dists[i][0] - dists[i+1][0]) + abs(dists[i][1] - dists[i+1][1]),\n               abs(dists[i][1] - dists[i+1][0]) + abs(dists[i][0] - dists[i+1][1]) )\nprint(ans)\n", "n = int(input())\na = list(map(int,input().split()))\ndict1 = {}\nfor i in range(1,n+1):\n\tdict1[i] = []\nfor count,i in enumerate(a):\n\tdict1[i].append(count)\nans = 0\nd = 0\ns = 0\nfor i in range(1,n+1):\n\tans += abs(d - max(dict1[i]))\n\tans += abs(s - min(dict1[i]))\n\td = max(dict1[i])\n\ts = min(dict1[i])\nprint(ans)", "def dist(x, xn):\n    return max(x, xn) - min(x, xn)\n\n\nn = int(input())\nb = [[] for _ in range(n + 2)]\ni = 1\nfor a in input().split():\n    b[int(a)].append(i)\n    i += 1\nd = s = 1\nres = 1\nfor a in range(1, n + 1):\n    b[a].sort()\n    dn, sn = b[a]\n    res += dist(d, dn) + dist(s, sn)\n    d, s = dn, sn\nprint(res - 1)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef main():\n    n = get_int()\n    li =get_list()\n    ind = [[] for _ in range(n)]\n    for i,ele in enumerate(li):\n        ind[ele-1].append(i)\n    res = 0\n    for pas in [0,1]:\n        p = 0\n        for i in range(n):\n            res+=abs(p-ind[i][pas])\n            p = ind[i][pas]\n    print(res)\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\nn=int(input())\nl=list(map(int,input().split()))\nd={}\nfor i in range(2*n):\n    if d.get(l[i],0)==0:\n        t=[]\n        t.append(i)\n        d[l[i]]=t\n    else:\n        d[l[i]].append(i)\na,b=0,0\nc,e=0,0\nk=0\nfor i in sorted(d.keys()):\n    z = sorted(d[i])\n    if k==0:\n        a=abs(a-z[0])\n        b=abs(b-z[1])\n    else:\n        a+=abs(c-z[0])\n        b+=abs(e-z[1])\n    c=z[0]\n    e=z[1]\n    k+=1\nprint(a+b)\n    \n\n", "n = int(input())\nA = [int(i) for i in input().split()]\n\nX = [[] for i in range(n+1)]\n\nfor i, a in enumerate(A):\n    X[a].append(i)\n\nSasha = 0\nDima = 0\nans = 0\nfor i in range(1, n+1):\n    d1 = abs(Sasha - X[i][0]) + abs(Dima - X[i][1])\n    d2 = abs(Sasha - X[i][1]) + abs(Dima - X[i][0])\n    if d1 < d2:\n        ans += d1\n        Sasha = X[i][0]\n        Dima = X[i][1]\n    else:\n        ans += d2\n        Sasha = X[i][1]\n        Dima = X[i][0]\n\nprint(ans)", "from math import ceil \nn = int(input()) \na = list(map(int, input().split())) \ncur_state_sasha = 0\ncur_state_dima = 0 \na = [(p,i) for i,p in enumerate(a)] \na.sort() \nans = 0\nfor i in range(0 , 2*n , 2):\n\tans += abs(a[i][1] - cur_state_sasha) \n\tcur_state_sasha = a[i][1] \n\tans += abs(a[i+1][1] - cur_state_dima)\n\tcur_state_dima = a[i+1][1] \n\t# print(ans)\n\nprint(ans)", "n = int(input())\nnums = [int(x) for x in input().split()]\n\ncoords = {}\n\nfor i, k in enumerate(nums):\n    if str(k) + \"_1\" in coords:\n        coords[str(k) + \"_2\"] = i\n    else:\n        coords[str(k) + \"_1\"] = i\n\n#print(coords)\n\ns = 0\nprev1 = 0\nprev2 = 0\nfor i in range(1, n+1):\n    cur1 = coords[str(i) + \"_1\"]\n    cur2 = coords[str(i) + \"_2\"]\n    #print(prev1, prev2, cur1, cur2)\n    d1 = abs(cur1 - prev1) + abs(cur2 - prev2)\n    d2 = abs(cur1 - prev2) + abs(cur2 - prev1)\n    #print(\"d1 \", d1, \"d2 \", d2)\n    s += min(d1, d2)\n    prev1 = cur1\n    prev2 = cur2\n    #print(s)\n\nprint(s)\n", "n = int(input())\na = [int(x) for x in input().split()]\nf = {}\nfor i, x in enumerate(a):\n  if x not in f:\n    f[x] = [i]\n  else:\n    f[x].append(i)\n    f[x].sort()\n\nl = 0\ncnt = 0\nr = 0\nfor i in range(1, n + 1):\n  if abs(f[i][0] - l) + abs(f[i][1] - r) < abs(f[i][1] - l) + abs(f[i][0] - r):\n    cnt += abs(f[i][0] - l)\n    l = f[i][0]\n    cnt += abs(f[i][1] - r)\n    r = f[i][1]\n  else:\n    cnt += abs(f[i][1] - l)\n    l = f[i][1]\n    cnt += abs(f[i][0] - r)\n    r = f[i][0]\n\nprint(cnt)", "n=int(input())\narr=list(map(int,input().split()))\ndict1={}\nfor i in range(2*n):\n\ttry:\n\t\tdict1[arr[i]].append(i+1)\n\t\tdict1[arr[i]].sort()\n\texcept:\n\t\tKeyError\n\t\tdict1[arr[i]]=[i+1]\nans=0\ncurr1=1\ncurr2=1\nfor i in range(1,n+1):\n\tif(i==1):\n\t\tans+=(dict1[i][0]-curr1)\n\t\tans+=(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]>curr1 and dict1[i][0]>curr2):\n\t\tans+=(dict1[i][0]-curr1)\n\t\tans+=(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][1]<curr1<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]<curr1 and curr1<dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(dict1[i][0]<curr1 and dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telif(curr1<dict1[i][0]<dict1[i][1]<curr2):\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\n\telse:\n\t\tans+=abs(dict1[i][0]-curr1)\n\t\tans+=abs(dict1[i][1]-curr2)\n\t\tcurr1=dict1[i][0]\n\t\tcurr2=dict1[i][1]\nprint(ans)\n\n"]
["from sys import stdin\nfrom heapq import heappop, heappush, heapify\ndef main():\n    n = int(stdin.readline())\n    a = stdin.readline().split()\n    q = []\n    p = 0\n    c = 0\n    l = [0] * (n + 1)\n    r = [0] * (n + 1)\n    k = [0] * (n + 1)\n    pa = [0] * (n + 1)\n    for i, x in enumerate(a):\n        if x == a[p]:\n            c += 1\n        else:\n            l[p] = p - 1\n            k[p] = k[i-1] = c\n            pa[p] = i - 1\n            pa[i-1] = p\n            r[i-1] = i\n            q.append((-c, p))\n            p = i\n            c = 1\n    q.append((-c, p))\n    l[p] = p - 1\n    k[p] = k[n-1] = c\n    pa[p] = n - 1\n    pa[n-1] = p\n    r[n-1] = n\n    heapify(q)\n    ans = 0\n    while len(q):\n        c, p = heappop(q)\n        c = -c\n        if k[p] > c:\n            continue\n        ans += 1\n        ls = l[p]\n        rs = r[pa[p]]\n        if ls >= 0 and rs < n and a[ls] == a[rs]:\n            nc = k[ls] + k[rs]\n            nl, nr = pa[ls], pa[rs]\n            k[nl] = k[nr] = k[ls] = k[rs] = nc\n            pa[nr] = nl\n            pa[nl] = nr\n            heappush(q, (-nc, nl))\n        else:\n            if ls >= 0:\n                r[ls] = rs\n            if rs < n:\n                l[rs] = ls\n    print (ans)\nmain()", "'''input\n4\n2 5 5 2\n'''\nfrom sys import stdin\nimport collections\n# from random import randint\n\n\n# heapdict source code\ndef doc(s):\n    if hasattr(s, '__call__'):\n        s = s.__doc__\n    def f(g):\n        g.__doc__ = s\n        return g\n    return f\n\nclass heapdict(collections.MutableMapping):\n    __marker = object()\n\n    @staticmethod\n    def _parent(i):\n        return ((i - 1) >> 1)\n\n    @staticmethod\n    def _left(i):\n        return ((i << 1) + 1)\n\n    @staticmethod\n    def _right(i):\n        return ((i+1) << 1)    \n    \n    def __init__(self, *args, **kw):\n        self.heap = []\n        self.d = {}\n        self.update(*args, **kw)\n\n    @doc(dict.clear)\n    def clear(self):\n        self.heap.clear()\n        self.d.clear()\n\n    @doc(dict.__setitem__)\n    def __setitem__(self, key, value):\n        if key in self.d:\n            self.pop(key)\n        wrapper = [value, key, len(self)]\n        self.d[key] = wrapper\n        self.heap.append(wrapper)\n        self._decrease_key(len(self.heap)-1)\n\n    def _min_heapify(self, i):\n        l = self._left(i)\n        r = self._right(i)\n        n = len(self.heap)\n        if l < n and self.heap[l][0] < self.heap[i][0]:\n            low = l\n        else:\n            low = i\n        if r < n and self.heap[r][0] < self.heap[low][0]:\n            low = r\n\n        if low != i:\n            self._swap(i, low)\n            self._min_heapify(low)\n\n    def _decrease_key(self, i):\n        while i:\n            parent = self._parent(i)\n            if self.heap[parent][0] < self.heap[i][0]: break\n            self._swap(i, parent)\n            i = parent\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n        self.heap[i][2] = i\n        self.heap[j][2] = j\n\n    @doc(dict.__delitem__)\n    def __delitem__(self, key):\n        wrapper = self.d[key]\n        while wrapper[2]:\n            parentpos = self._parent(wrapper[2])\n            parent = self.heap[parentpos]\n            self._swap(wrapper[2], parent[2])\n        self.popitem()\n\n    @doc(dict.__getitem__)\n    def __getitem__(self, key):\n        return self.d[key][0]\n\n    @doc(dict.__iter__)\n    def __iter__(self):\n        return iter(self.d)\n\n    def popitem(self):\n        \"\"\"D.popitem() -> (k, v), remove and return the (key, value) pair with lowest\\nvalue; but raise KeyError if D is empty.\"\"\"\n        wrapper = self.heap[0]\n        if len(self.heap) == 1:\n            self.heap.pop()\n        else:\n            self.heap[0] = self.heap.pop(-1)\n            self.heap[0][2] = 0\n            self._min_heapify(0)\n        del self.d[wrapper[1]]\n        return wrapper[1], wrapper[0]    \n\n    @doc(dict.__len__)\n    def __len__(self):\n        return len(self.d)\n\n    def peekitem(self):\n        \"\"\"D.peekitem() -> (k, v), return the (key, value) pair with lowest value;\\n but raise KeyError if D is empty.\"\"\"\n        return (self.heap[0][1], self.heap[0][0])\n\ndel doc\n__all__ = ['heapdict']\n\n\ndef create_necessities(arr, n):\n\tsize_heap = heapdict()\n\tlink = dict()\n\n\t# for unique indentification\n\t# for last element processing and saving code\n\tarr.append(-1)\n\tcount = 1\n\tfor i in range(n + 1):\n\t\tif i == 0:\n\t\t\tleader = arr[i]\n\t\t\tsize = 1\n\t\telse:\n\t\t\tif arr[i] == arr[i - 1]:\n\t\t\t\tsize += 1\n\t\t\telse:\n\t\t\t\tsize_heap[count] = -(size * (10 ** 14)) -((n - i))\n\t\t\t\tlink[count] = leader\n\n\t\t\t\tcount += 1\n\t\t\t\tleader = arr[i]\n\t\t\t\tsize = 1\n\n\t# creating neighbours\n\tnext_node = dict()\n\tprev_node = dict()\n\tfor i in link:\n\t\tif i == 1:\n\t\t\tprev_node[i] = None\n\n\t\t\tif i + 1 < count:\n\t\t\t\tnext_node[i] = i + 1\n\t\t\telse:\n\t\t\t\tnext_node[i] = None\n\t\telif i == count:\n\t\t\tbreak\n\n\t\telse:\n\t\t\tprev_node[i] = i - 1 \n\t\t\tif i + 1 < count:\n\t\t\t\tnext_node[i] = i + 1\n\t\t\telse:\n\t\t\t\tnext_node[i] = None\n\n\t# print(prev_node, next_node)\n\treturn link, size_heap, prev_node, next_node\n\t\n\n# main start\nn = int(stdin.readline().strip())\narr = list(map(int, stdin.readline().split()))\n\n# arr = []\n# for i in range(200000):\n# \tarr.append(randint(1, 1))\nlink, size_heap, prev_node, next_node = create_necessities(arr, len(arr))\n\nop = 0\nwhile len(size_heap) > 0:\n\tnode, size = size_heap.popitem()\n\n\t\n\tif prev_node[node] != None and next_node[node] != None and link[prev_node[node]] == link[next_node[node]]:\n\t\tif prev_node[node] in size_heap and next_node[node] in size_heap:\n\n\t\t\t# adjusting the size_heap\n\t\t\ttemp1 = size_heap[prev_node[node]]\n\t\t\tt1 = (-temp1)%(10 ** 14)\n\t\t\ttemp2 = size_heap[next_node[node]]\n\t\t\tt2 = (-temp2)%(10 ** 14)\n\t\t\tsize_heap[prev_node[node]] = -float('inf')\n\t\t\tsize_heap.popitem()\n\t\t\tsize_heap[next_node[node]] = -float('inf')\n\t\t\tsize_heap.popitem()\n\t\t\tsize_heap[prev_node[node]] = temp1 + temp2 + t2\n\n\t\t\t# adjusting neighbours\n\t\t\tnext_node[prev_node[node]] = next_node[next_node[node]]\n\t\t\tif next_node[next_node[node]] != None: \n\t\t\t\tprev_node[next_node[next_node[node]]] = prev_node[node]\n\t\t\t\t\t\t\n\t\telse:\n\t\t\tprev_node[next_node[node]] = prev_node[node]\n\t\t\tnext_node[prev_node[node]] = next_node[node]\n\telse:\n\t\tprev_node[next_node[node]] = prev_node[node]\n\t\tnext_node[prev_node[node]] = next_node[node]\n\n\top += 1\n\nprint(op)", "import heapq\n\nn = int(input())\na = list(map(int, input().split()))\n\n# idx: l, r, length, val\nd   = {}\npre, l = None, 0\nseg    = []\n\nfor i, x in enumerate(a):\n    if pre is None:\n        pre = x\n        l   = 1\n    else:\n        if x == pre:\n            l+=1\n        else:\n            seg.append([l, pre])\n            pre = x\n            l   = 1\n            \n    if i==len(a)-1:\n        seg.append([l, x])\n        \nQ = []\nfor i, s in enumerate(seg):\n    l=None if i  ==0 else i-1\n    r=None if i+1==len(seg) else i+1\n    d[i] = [l, r, s[0], s[1]]\n    \n    heapq.heappush(Q, (-s[0], i))      \n    \ncnt=0\nwhile len(Q) > 0:\n    length, idx = heapq.heappop(Q)\n    length = -length\n    \n    #print(d[idx])\n    if d[idx][2] != length:\n        continue\n        \n    l, r, length, val = d[idx]\n    d[idx][0]=0\n    cnt+=1\n    \n    if l is None and r is None:\n        break\n    elif l is None:\n        d[r][0] = None\n    elif r is None:\n        d[l][1] = None\n    else:\n        if d[l][3] == d[r][3]:\n            d[l][1]  = d[r][1]\n            d[l][2] += d[r][2]\n            d[r][2]  = 0\n            \n            if d[r][1] is not None:\n                nnr       = d[r][1]\n                d[nnr][0] = l \n                \n            heapq.heappush(Q, (-d[l][2], l))\n        else:\n            d[l][1] = r\n            d[r][0] = l\nprint(cnt)                "]
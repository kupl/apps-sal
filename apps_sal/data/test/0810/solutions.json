["ans = 0\nmod = 1000000007\na, b, n = list(map(int, input().split()))\ns = set()\nfor x in range(2, 1 << 8):\n    z = 0\n    while x > 1:\n        z = z * 10 + (a, b)[x & 1]\n        x >>= 1\n    s.add(z)\nf = [1] * (n + 1)\nfor i in range(1, n + 1):\n    f[i] = f[i - 1] * i % mod\nfor x in range(n + 1):\n    if x * a + (n - x) * b in s:\n        ans += pow(f[x] * f[n - x], mod - 2, mod)\n        ans %= mod\nprint(ans * f[n] % mod)\n", "from bisect import bisect_right, bisect_left\n\na, b, n = map(int, input().split())\nif a > b: a, b = b, a\n\nu, v = 10 * a, 10 * b\nx, y = a * n, b * n\nt, d = [a, b], b - a\n\nwhile t[-1] < x:\n    t = [j + u for j in t] + [j + v for j in t]\n    u, v = u * 10, v * 10\nif t[-1] < y: t += [j + u for j in t] + [j + v for j in t]\n\nt, s = t[bisect_left(t, x): bisect_right(t, y)], 0\nm, f = 1000000007, [1] + [0] * n\np, k = list(range(x, y + 1, d)), 0\n\nfor i in range(1, n + 1):\n    f[i] = (f[i - 1] * i) % m\n\nfor i in t:\n    k = bisect_left(p, i)\n    if p[k] == i: s += pow(f[k] * f[n - k], m - 2, m)\n\nprint(((s % m) * f[n]) % m)", "MOD = int( 1e9 + 7 )\n\nfact = [ 1 ]\nfor i in range( 1, int( 1e6 ) + 1, 1 ):\n  fact.append( fact[ i - 1 ] * i % MOD )\n\nA, B, N = list(map( int, input().split() ))\n\nans = 0\nfor i in range( N + 1 ):\n  f = A * i + B * ( N - i )\n  ng = False\n  while f:\n    t = f % 10\n    if t != A and t != B:\n      ng = True\n      break\n    f //= 10\n  if ng: continue\n  ans = ( ans + fact[ N ] * pow( fact[ i ], MOD - 2, MOD ) * pow( fact[ N - i ], MOD - 2, MOD ) ) % MOD\n\nprint( ans )\n", "MOD=10**9+7\n\na,b,n=list(map(int,input().strip().split(' ')))\n#there are i a's. n-i b's\ndef check(a,b,x):\n    temp=x%10\n    if temp!=a and temp!=b:\n        return 0\n    while(x>0):\n        temp=x%10\n        if temp!=a and temp!=b:\n            return 0\n        x=x//10\n    return 1    \n\nfact=[1]\ninfact=[1]\ntemp=1\nintemp=1\nfor i in range(1,n+1):\n    temp*=i\n    #intemp*=pow(i,MOD-2,MOD)\n    temp%=MOD\n    #intemp%=MOD\n    fact+=[temp]\n    #infact+=[intemp]\n    \ndef binom(a,b):\n    MOD=10**9+7\n    if b==0:\n        return 1\n    else:\n        temp=pow(fact[a-b]*fact[b],MOD-2,MOD)*fact[a]\n        return temp%MOD\n        \n        \n        \n    \n    \ntotal=0    \nfor i in range(n+1):\n    temp=i*a+(n-i)*b\n    if check(a,b,temp)==1:\n        total+=binom(n,i)\n        total%=MOD\n#total*=fact[a]        \nprint(total%MOD)      ", "from bisect import bisect_right, bisect_left\n\n\n\na, b, n = list(map(int, input().split()))\n\nif a > b: a, b = b, a\n\n\n\nu, v = 10 * a, 10 * b\n\nx, y = a * n, b * n\n\nt, d = [a, b], b - a\n\n\n\nwhile t[-1] < x:\n\n    t = [j + u for j in t] + [j + v for j in t]\n\n    u, v = u * 10, v * 10\n\nif t[-1] < y: t += [j + u for j in t] + [j + v for j in t]\n\n\n\nt, s = t[bisect_left(t, x): bisect_right(t, y)], 0\n\nm, f = 1000000007, [1] + [0] * n\n\np, k = list(range(x, y + 1, d)), 0\n\n\n\nfor i in range(1, n + 1):\n\n    f[i] = (f[i - 1] * i) % m\n\n\n\nfor i in t:\n\n    k = bisect_left(p, i)\n\n    if p[k] == i: s += pow(f[k] * f[n - k], m - 2, m)\n\n\n\nprint(((s % m) * f[n]) % m)\n\n\n\n# Made By Mostafa_Khaled\n", "a,b,n=list(map(int,input().split()))\n\ndef ok(s):\n    # print('sum',s)\n    while s:\n        if s%10!=a and s%10!=b:\n            return False\n        s=int(s/10)\n    # print('ok')\n    return True\n\nans=0\np=int(1e9+7)\nA=[1]\nfor i in range(1,n+1):\n    A.append(int(i*A[i-1]%p))\nfor x in range(0,n+1):\n    y=n-x\n    # print(a,x,b,y,a*x+b*y)\n    if ok(a*x+b*y):\n        ans+=(A[n]*pow(A[x],p-2,p))%p*pow(A[y],p-2,p)%p\n        ans%=p\n    # input()\n\nprint(int(ans))\n", "a,b,n=list(map(int,input().split()))\n\ndef ok(s):\n    # print('sum',s)\n    while s:\n        if s%10!=a and s%10!=b:\n            return False\n        s=int(s/10)\n    # print('ok')\n    return True\n\nans=0\np=int(1e9+7)\nA=[1]\nfor i in range(1,n+1):\n    A.append(int(i*A[i-1]%p))\nfor x in range(0,n+1):\n    y=n-x\n    # print(a,x,b,y,a*x+b*y)\n    if ok(a*x+b*y):\n        ans+=(A[n]*pow(A[x],p-2,p))%p*pow(A[y],p-2,p)%p\n        ans%=p\n    # input()\n\nprint(int(ans))\n", "a,b,n = list(map(int,input().split()))\nm =1000000007\nfact = [1]\n\nfor i in range(1,n+1):\n    fact.append((fact[-1]*i)%m)\nans = 0\nfor i in range(n+1):\n    su = (a*i) + b*(n-i)\n    coef = 1\n    while(su>0):\n        if(su%10 != a and su%10!=b):\n            coef = 0;\n        su//=10\n    if coef:\n        ans+=(fact[n]*pow((fact[i]*fact[n-i]),m-2,m))\n        ans= ans%m\nprint(ans%m)\n    \n", "import sys\n\ninf = float(\"inf\")\n# sys.setrecursionlimit(10000000)\n\n# abc='abcdefghijklmnopqrstuvwxyz'\n# abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod, MOD = 1000000007, 998244353\n# words = {1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine',10:'ten',11:'eleven',12:'twelve',13:'thirteen',14:'fourteen',15:'quarter',16:'sixteen',17:'seventeen',18:'eighteen',19:'nineteen',20:'twenty',21:'twenty one',22:'twenty two',23:'twenty three',24:'twenty four',25:'twenty five',26:'twenty six',27:'twenty seven',28:'twenty eight',29:'twenty nine',30:'half'}\n# vow=['a','e','i','o','u']\n# dx,dy=[0,1,0,-1],[1,0,-1,0]\n\n# import random\n# from collections import deque, Counter, OrderedDict,defaultdict\n# from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n# from math import ceil,floor,log,sqrt,factorial,pi,gcd\n# from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\n\ndef is_beautiful(sum):\n    if sum==0:\n        return 0\n    while sum:\n        if sum%10!=a:\n            if sum%10!=b:\n                return 0\n        sum//=10\n    return 1\n\ndef nCr(n,r):\n    return (fact[n]*invfact[r]*invfact[n-r])%mod\n\n\n# precalculating fact and inverse fact array\n\nfact = [0]*(1000005)\ninvfact = [0]*(1000005)\nfact[0] = fact[1] = invfact[0] = invfact[1] = 1\nfor i in range(1,1000003):\n    fact[i] = (fact[i-1]%mod * i%mod)%mod\ninvfact[1000000] = pow(fact[1000000],mod-2,mod)\nfor i in range(999999,0,-1):\n    invfact[i] = (invfact[i+1]%mod * (i+1)%mod)%mod\n\na,b,n = get_ints()\nif a==b:\n    if is_beautiful(a*n):\n        print(1)\n    else:\n        print(0)\nans = 0\nfor i in range(n+1):\n    if is_beautiful(a*i + b*(n-i)):\n        ans+=nCr(n,i)\nans %=mod\nprint(ans)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    return x % m\n\na, b, n = map(int, input().split())\nc = str(a) + str(b)\nf, mod, ans = [1], 1000000007, 0\nfor i in range(1, n + 1):\n    f.append(f[-1] * i % mod)\ns = a * n\nfor i in range(n + 1):\n    if all(i in c for i in str(s)):\n        ans += f[n] * modinv(f[i] * f[n - i], mod) % mod\n    s += b - a\nprint(ans % mod)", "MOD=10**9+7\np=1000009\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n    fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n    return pow(a,MOD-2,MOD)\ndef ncr(n, k,MOD):\n    if n==k or k==0:\n        return 1 \n    if n<k:\n        return 0 \n    return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\na,b,n=map(int,input().split())\ngood=[a,b]\nj=-1 \nfor i in range(10**5):\n    j+=1  \n    good.append(good[j]*10+a)\n    good.append(good[j]*10+b)\ngood.sort() \ngood=[i for i in good if n*min(a,b)<=i<=n*max(a,b)]\nans=0 \nMOD=10**9+7 \n#print(good)\nfor x in range(0,n+1):\n    if a*x+b*(n-x) in good:\n        ans+=ncr(n,x,MOD)\n        ans%=MOD \nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\nimport functools\nimport operator as op\n\n\"\"\"\ncreated by shhuan at 2020/1/13 21:43\n\n\"\"\"\n\n\nMOD = 1000000007\nMAXN = 10 ** 6 + 5\nfactorial = [0 for _ in range(MAXN)]\nfactorial[0] = 1\nfor i in range(1, MAXN):\n    factorial[i] = factorial[i - 1] * i % MOD\n\n\ndef pow(a, b):\n    if b == 0:\n        return 1\n\n    c = b // 2\n    d = pow(a, c)\n    if b % 2 == 0:\n        return d * d % MOD\n    return d * d * a % MOD\n\n\ndef inverse(k):\n    return pow(k, MOD-2)\n\n\ndef ncr(n, k):\n    k = min(k, n - k)\n    return factorial[n] * inverse(factorial[k]) % MOD * inverse(factorial[n-k]) % MOD\n\n\ndef dlen(val):\n    s = 0\n    while val > 0:\n        s += 1\n        val //= 10\n\n    return s\n\n\ndef gen(index, nbit, pre, a, b):\n    if index >= nbit:\n        return [pre]\n\n    return gen(index + 1, nbit, pre * 10 + a, a, b) + gen(index + 1, nbit, pre * 10 + b, a, b)\n\n\ndef count(lo, hi, a, b, n, nnum):\n    d = b - a\n    ans = 0\n    for v in gen(0, n, 0, a, b):\n        if v < lo or v > hi:\n            continue\n        u = v - a * nnum\n        if u % d == 0:\n            y = u // d\n            x = nnum - y\n            # print(x, y, countab(lo, hi, a, b, x, y, n))\n            # ans += countab(lo, hi, a, b, x, y, n)\n            ans += ncr(nnum, x)\n            # print(x, y, ncr(nnum, x))\n            ans %= MOD\n    return ans\n\n\ndef solve(N, A, B):\n    lo, hi = N * A, N * B\n    nl, nh = dlen(lo), dlen(hi)\n\n    if nl == nh:\n        return count(lo, hi, A, B, nl, N)\n    else:\n        return count(lo, 10 ** nl - 1, A, B, nl, N) + count(10 ** nl, hi, A, B, nh, N)\n\n\ndef test():\n    N = 10 ** 6\n    A = random.randint(1, 5)\n    B = random.randint(1, 4) + A\n    t0 = time.time()\n    print(solve(N, A, B))\n    print(time.time() - t0)\n\n# print(solve(10**6, 2, 3))\n\nA, B, N = map(int, input().split())\nprint(solve(N, A, B))", "import math\nfrom sys import stdin\n\n#stdin=open('input.txt','r')\nI=stdin.readline\n\nmod=1000000007\nfact = [1 for i in range(1000000+5)]\nfor i in range(2,len(fact)):\n\tfact[i]=fact[i-1]*i\n\tfact[i]%=mod\n\na,b,n=list(map(int,I().split()))\nc1=chr(a+ord('0'))\nc2=chr(b+ord('0'))\n#byg=(math.factorial(1000000))\nans=0\n\nfor x in range(0,n+1):\n\tnow=a*x+n*b-b*x\n\tflag=False\n\tfor c in str(now):\n\t\tif(c!=c1 and c!=c2):\n\t\t\tflag=True\n\t\t\tbreak\n\n\tif(not flag):\n\t\t#print(x,now)\n\t\tnow=fact[n]\n\t\ty=fact[x]\n\t\tz=fact[n-x]\n\t\tasd=pow(y*z,mod-2,mod)\n\t\t\n\t\tnow*=asd\n\t\tnow%=mod\n\t\t#now/=math.factorial(n-x)\n\t\t\n\t\tans+=now\n\t\tans%=mod\n\nprint(int(ans))\n\n", "from math import factorial as fct \n\nMOD = 10**9 + 7\ndef c(n,k):\n    return fct(n)//(fct(k)*fct(n-k))\n \ndef check(val,a,b):\n    while val>0 :\n        if val%10 == a or val%10 == b:\n            val = val//10\n        else:\n            return False\n    return True\n\na,b,n = list(map(int,input().split()))\nf = [1]\nfor i in range(1, n + 1):\n    f.append(f[-1] * i % MOD)\nans = 0\n\nfor i in range(n+1):\n    if check(i*a + (n-i)*b,a,b):\n        ans += pow(f[i]*f[n-i],MOD-2,MOD)\n        ans %= MOD\n\nprint((ans*f[n])%MOD)\n", "fact = [1]\nmod = 10**9 + 7\ndef factorial(n):\n    nonlocal  mod\n    nonlocal  fact\n    fact = [1]\n    mod = 10**9 + 7\n    for i in range(1,n+1):\n        fact.append(fact[-1] * i)\n        fact[-1] %= mod\ndef C(n,k):\n    nonlocal mod\n    return  (((fact[n]*pow(fact[k],mod-2,mod))%mod)*pow(fact[n-k],mod-2,mod))%mod\ndef good(x,a,b):\n    while x > 0:\n        if(x%10!=a and x%10!=b):\n            return  False\n        x//=10\n    return  True\nfor _ in range(1):\n    ans = 0\n    a,b,n = map(int,input().split())\n    factorial(n)\n    for i in range(n+1):\n        if(good(i*a+(n-i)*b,a,b)):\n            ans += C(n,i)\n            ans %= mod\n    print(ans)", "def R(): return list(map(int, input().split()))\ndef I(): return int(input())\ndef S(): return str(input())\n\ndef L(): return list(R())\n\nfrom collections import Counter \n\nimport math\nimport sys\n\nfrom itertools import permutations\n\n\nimport bisect\n\nmod=10**9+7\n\n#print(bisect.bisect_right([1,2,3],2))\n#print(bisect.bisect_left([1,2,3],2))\n\na,b,n=R()\n\nfact=[1]*(n+1)\n\nfor i in range(1,n+1):\n    fact[i]=fact[i-1]*i\n    fact[i]%=mod\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef check(val,a,b):\n    while val>0:\n        if val%10!= a and val%10!=b:\n            return False\n\n        val//=10\n\n    return True\n\nans=0\nfor i in range(n+1):\n    if check(a*i+b*(n-i),a,b):\n        ans+=fact[n]*modinv((fact[i]*fact[n-i])%mod,mod)\n        ans%=mod\n\n\nprint(ans)\n", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\n#def print(x): return sys.stdout.write(str(x)+'\\n')\n#sys.setrecursionlimit(100000)\nmod=int(1e9+7)\n\ndef check(k):\n    while k>0:\n        x=k%10\n        k//=10\n        if x!=a and x!=b:\n            return False\n    return True\n\ndef fac(n):\n    f=[0]*(n+1)\n    f[0]=1\n    for i in range(1,n+1):\n        f[i]=(f[i-1]*i)%mod\n    return f\n\na,b,n=mdata()\nans=0\nf=fac(n)\nfor i in range(n+1):\n    k=a*i+b*(n-i)\n    if check(k):\n        ans=(ans+int(pow(f[i]*f[n-i],mod-2,mod)))%mod\nprint((ans*f[n])%mod)\n", "M=1000000007\nimport sys\ndef alele(): return list(map(int, sys.stdin.readline().strip().split()))\ndef ilele(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\na,b,n=ilele();Ans=0\nfact=[1]*(n+1)\nfor i in range(1,n+1):\n\tfact[i]=fact[i-1]*i%M;\nfor i in range(n+1):\n    s=str(a*i+b*(n-i));Noa=0;Nob=0\n    for j in s:\n        if int(j)==a:Noa+=1\n        elif int(j)==b:Nob+=1\n    if Noa+Nob==len(s):Ans=(Ans+pow(fact[n-i]*fact[i],M-2,M))%M   \nprint((Ans*fact[n])%M)    ", "from math import factorial\n\nMOD = 10**9+7\nfact = {}\n\na, b, n = list(map(int, input().split()))\nfact[0]=1\nfor i in range(1, n+1):\n    fact[i] = fact[i-1]*i%MOD\n\nans = 0\nfor (i, j) in zip(list(range(n+1)), list(range(n, -1, -1))):\n    if set(str(a*i + b*j)) <= {f'{a}', f'{b}'}:\n        ans+=(fact[n]*pow(fact[n-i]*fact[i]%MOD, MOD-2, MOD) % MOD)\nprint(ans%MOD)\n", "ans = 0\nmod = 10**9+7\na, b, n = map(int, input().split())\ns = set()\nfor x in range(2, 1 << 8):\n    z = 0\n    while x > 1:\n        z = z * 10 + (a, b)[x & 1]\n        x >>= 1\n    s.add(z)\nf = [1] * (n + 1)\nfor i in range(1, n + 1):\n    f[i] = f[i - 1] * i % mod\nfor x in range(n + 1):\n    if x * a + (n - x) * b in s:\n        ans += pow(f[x] * f[n - x], mod - 2, mod)\n        ans %= mod\nprint(ans * f[n] % mod)", "import math\nimport time\nfrom collections import defaultdict,deque,Counter\nfrom sys import stdin,stdout\nfrom bisect import bisect_left,bisect_right\nfrom queue import PriorityQueue \nimport sys\nMOD=int(1e9 +7)\ndef good(x):\n    while(x>0):\n        if(x%10!=a and x%10!=b):\n            return False\n        x=x//10\n    return True\ndef ncr(n,r):\n    return (fact[n]*pow(fact[i]*fact[n-i],MOD-2,MOD))%MOD\na,b,n=list(map(int,stdin.readline().split()))\nfact=[1]*(n+2)\nfor i in range(1,n+1):\n    fact[i]=fact[i-1]*i\n    fact[i]%=MOD\nans=0\ntemp=b*n\nfor i in range(n+1):\n    # print(i)\n    if(good(temp)):\n        ans+=ncr(n,i)\n    temp+=a-b\nprint(ans%MOD)\n", "ans = 0\nmod = 1000000007\na, b, n = map(int, input().split())\ns = set()\nfor x in range(2, 1 << 8):\n    z = 0\n    while x > 1:\n        z = z * 10 + (a, b)[x & 1]\n        x >>= 1\n    s.add(z)\nf = [1] * (n + 1)\nfor i in range(1, n + 1):\n    f[i] = f[i - 1] * i % mod\nfor x in range(n + 1):\n    if x * a + (n - x) * b in s:\n        ans += pow(f[x] * f[n - x], mod - 2, mod)\n        ans %= mod\nprint(ans * f[n] % mod)", "N=10**6\nmod=10**9+7\ndef checkgood(val, a, b):\n    while(val):\n        if(val%10 != a and val%10 !=b ):\n            return False\n        val//=10\n    return(True)\ndef power(x, a):\n    if(a==0):\n        return(1)\n    z=power(x, a//2)\n    z = (z**2)%mod\n    if(a%2):\n        z=(z*x)%mod\n    return(z)\nfact=[1 for _ in range(N+1)]\nfor no in range(2, N+1):\n    fact[no]=(fact[no-1]*no)%mod\n[a, b, n]=list(map(int, input().split()))\ncount=0\nfor freq in range(n+1):\n    val = freq*a+(n-freq)*b\n    if(checkgood(val, a, b)):\n        count+=(((fact[n]*power(fact[freq], mod-2))%mod)*power(fact[n-freq], mod-2))%mod\n        count%=mod\nprint(count)"]
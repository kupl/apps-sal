["n = int(input())\nedges = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    edges[u-1].append(v-1)\n    edges[v-1].append(u-1)\n\ncolors = [-1 for i in range(n)]\ndfs = [(0,0)]\nwhile len(dfs) > 0:\n    node, color = dfs.pop()\n    colors[node] = color\n    for neighbor in edges[node]:\n        if colors[neighbor] == -1:\n            dfs.append((neighbor, 1-color))\n\nblue = len([x for x in colors if x==0])\nred = n - blue\n\ntotal_graph_edges = blue*red\nprint(blue*red - (n-1))", "n = int(input())\n\nfrom collections import defaultdict\nE = defaultdict(list)\n\nfor _ in range(n-1):\n  a,b = map(int,input().split())\n  a,b = a-1,b-1\n  E[a].append(b)\n  E[b].append(a)\n\nstack = [1]\nvisited = {1}\nc = 0\nd = 0\n\nturn = True\n\nwhile stack:\n  nstack = []\n  for v in stack:\n    for u in E[v]:\n      if u not in visited:\n        nstack.append(u)\n        visited.add(u)\n\n  if turn:\n    d += len(stack)\n  else:\n    c += len(stack)\n  turn = not turn\n  stack = nstack\n\nprint(c*d-(n-1))", "from collections import deque\n\nn = int(input())\ng = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = list(map(int, input().split()))\n    g[u].append(v)\n    g[v].append(u)\n    \nf = [0]*(n+1)\nc = [1, 0]\nq = deque()\nq.appendleft((1, 0))\nwhile q:\n    u, p = q.pop()\n    for v in g[u]:\n        if v != p:\n            f[v] = (f[u] + 1) % 2\n            c[f[v]] += 1\n            q.appendleft((v, u))\n\nans = 0\nfor u in range(1, n+1):\n    n = len(g[u])\n    opp = c[1-f[u]]\n    ans += opp - n\n    \nprint(ans // 2)\n", "# \u041c\u0430\u0445\u043c\u0443\u0434 \u0438 \u0415\u0445\u0430\u0431 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u044e\u0442 \u0441\u0432\u043e\u0438 \u043f\u0440\u0438\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f! \u041a\u0430\u0436\u0434\u044b\u0439 \u0436\u0438\u0442\u0435\u043b\u044c \u0417\u043b\u043e\u0439 \u0421\u0442\u0440\u0430\u043d\u044b \u0437\u043d\u0430\u0435\u0442, \u0447\u0442\u043e \u0414\u043e\u043a\u0442\u043e\u0440 \u0417\u043b\u043e \u043b\u044e\u0431\u0438\u0442 \u0434\u0432\u0443\u0434\u043e\u043b\u044c\u043d\u044b\u0435 \u0433\u0440\u0430\u0444\u044b, \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e \u0434\u0435\u0440\u0435\u0432\u044c\u044f.\n#\n# \u0414\u0435\u0440\u0435\u0432\u043e \u2014 \u044d\u0442\u043e \u0441\u0432\u044f\u0437\u043d\u044b\u0439 \u0433\u0440\u0430\u0444 \u0431\u0435\u0437 \u0446\u0438\u043a\u043b\u043e\u0432. \u0414\u0432\u0443\u0434\u043e\u043b\u044c\u043d\u044b\u0439 \u0433\u0440\u0430\u0444 \u2014 \u044d\u0442\u043e \u0433\u0440\u0430\u0444, \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043c\u043e\u0436\u043d\u043e \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u043d\u0430 2 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e \u0434\u043b\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u0440\u0435\u0431\u0440\u0430 (u,\u2009v) \u0433\u0440\u0430\u0444\u0430 \u0432\u0435\u0440\u0448\u0438\u043d\u044b u \u0438 v \u043b\u0435\u0436\u0430\u0442 \u0432 \u0440\u0430\u0437\u043d\u044b\u0445 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430\u0445. \u0411\u043e\u043b\u0435\u0435 \u0444\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0434\u0435\u0440\u0435\u0432\u0430 \u0438 \u0434\u0432\u0443\u0434\u043e\u043b\u044c\u043d\u043e\u0433\u043e \u0433\u0440\u0430\u0444\u0430 \u0434\u0430\u043d\u043e \u043d\u0438\u0436\u0435.\n#\n# \u0414\u043e\u043a\u0442\u043e\u0440 \u0417\u043b\u043e \u0434\u0430\u043b \u041c\u0430\u0445\u043c\u0443\u0434\u0443 \u0438 \u0415\u0445\u0430\u0431\u0443 \u0434\u0435\u0440\u0435\u0432\u043e, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0438\u0437 n \u0440\u0451\u0431\u0435\u0440 \u0438 \u0441\u043a\u0430\u0437\u0430\u043b \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0440\u0451\u0431\u0440\u0430 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u0433\u0440\u0430\u0444 \u043e\u0441\u0442\u0430\u0432\u0430\u043b\u0441\u044f \u0434\u0432\u0443\u0434\u043e\u043b\u044c\u043d\u044b\u043c, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432 \u043d\u0451\u043c \u043d\u0435 \u0431\u044b\u043b\u043e \u043f\u0435\u0442\u0435\u043b\u044c \u0438 \u043a\u0440\u0430\u0442\u043d\u044b\u0445 \u0440\u0451\u0431\u0435\u0440. \u041a\u0430\u043a\u043e\u0435 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0440\u0451\u0431\u0435\u0440 \u043e\u043d\u0438 \u043c\u043e\u0433\u0443\u0442 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c?\n# \u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n#\n# \u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0434\u0430\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n \u2014 \u0447\u0438\u0441\u043b\u043e \u0432\u0435\u0440\u0448\u0438\u043d \u0432 \u0434\u0435\u0440\u0435\u0432\u0435 (1\u2009\u2264\u2009n\u2009\u2264\u2009105).\n#\n# \u0412 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 n\u2009-\u20091 \u0441\u0442\u0440\u043e\u043a\u0430\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u0441\u044f \u043f\u0430\u0440\u044b \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b u \u0438 v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009n, u\u2009\u2260\u2009v) \u2014 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0440\u0451\u0431\u0435\u0440 \u0434\u0435\u0440\u0435\u0432\u0430.\n#\n# \u0413\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u0435\u0442\u0441\u044f, \u0447\u0442\u043e \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0439 \u0433\u0440\u0430\u0444 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0434\u0435\u0440\u0435\u0432\u043e\u043c.\n# \u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n#\n# \u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0434\u043d\u043e \u0447\u0438\u0441\u043b\u043e \u2014 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0440\u0451\u0431\u0435\u0440, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u041c\u0430\u0445\u043c\u0443\u0434 \u0438 \u0415\u0445\u0430\u0431 \u043c\u043e\u0433\u0443\u0442 \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432 \u0433\u0440\u0430\u0444.\n# python3\nfrom collections import Counter\n\n\nnodes_nr = int(input())\nnode_idx___neigh_idxes = []\nfor _ in range(nodes_nr):\n    node_idx___neigh_idxes.append([])\nfor _ in range(nodes_nr - 1):\n    node_idx1, node_idx2 = (int(x) - 1 for x in input().split())\n    node_idx___neigh_idxes[node_idx1].append(node_idx2)\n    node_idx___neigh_idxes[node_idx2].append(node_idx1)\n\nnode_idx___group = [-1] * nodes_nr\nstack = []\nstack.append(0)\nnode_idx___group[0] = 0\n\nwhile stack:\n    curr_node_idx = stack.pop()\n    for neigh_idx in node_idx___neigh_idxes[curr_node_idx]:\n        if node_idx___group[neigh_idx] == -1:\n            if node_idx___group[curr_node_idx] == 0:\n                node_idx___group[neigh_idx] = 1\n            else:\n                node_idx___group[neigh_idx] = 0\n            stack.append(neigh_idx)\n\ncounter = Counter(node_idx___group)\nans = counter[0] * counter[1] - nodes_nr + 1\nprint(ans)\n", "n = int(input())\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    u,v = map(int, input().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n    \nq = [[0,0]]\nlvls = [0 for i in range(n)]\nlvls[0] = 1\nvis = set([0])\nwhile len(q) > 0:\n    v = q[0][0]\n    l = q[0][1]\n    del q[0]\n    for u in g[v]:\n        if u not in vis:\n            vis.add(u)\n            q.append([u, l+1])\n            lvls[l+1] += 1\n            \nclvls = [i for i in lvls]\nfor i in range(2,n):\n    if lvls[i] == 0:\n        break\n    clvls[i] += clvls[i-2]\nans = 0\nfor i in range(2,n):\n    if lvls[i] == 0:\n        break\n    ans += lvls[i]*(clvls[i-1]-1)\n    \nprint(ans)", "#!/usr/bin/env python3\n\n\nN = int(input())\nadj = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n    adj[b].append(a)\n\nvisited = {0}\ncur_level = [0]\nlevels = []\n\nwhile cur_level:\n    levels.append(cur_level)\n    next_level = []\n    for n in cur_level:\n        for m in adj[n]:\n            if m not in visited:\n                next_level.append(m)\n                visited.add(m)\n    cur_level = next_level\n\n\ncolor_0 = sum(map(len, levels[0::2]))\ncolor_1 = sum(map(len, levels[1::2]))\n\nout = 0\nfor i, level in enumerate(levels):\n    for n in level:\n        if i % 2 == 0:\n            out += color_1 - len(adj[n])\n        else:\n            out += color_0 - len(adj[n])\n        # print(n, out)\n\nassert out % 2 == 0\nprint(out // 2)\n\n", "n = int(input())\ntr = {}\nfor i in range(1,n+1):\n\ttm = []\n\ttr[i] = tm\n\nfor i in range(n-1):\n\tx,y = list(map(int,input().strip().split(' ')))\n\ttr[x].append(y)\n\ttr[y].append(x)\n\na = set({})\nb = set({})\nsv = 0\nq = [1]\nans = 0\na.add(1)\nwhile len(q) > 0:\n\tx = q.pop(0)\n\tif a.__contains__(x):\n\t\tsv = 0\n\telif b.__contains__(x):\n\t\tsv = 1\n\tfor i in tr[x]:\n\t\tif sv == 0:\n\t\t\tif b.__contains__(i) == False:\n\t\t\t\tb.add(i)\n\t\t\t\tq.append(i)\n\t\telif sv == 1:\n\t\t\tif a.__contains__(i) == False:\n\t\t\t\ta.add(i)\n\t\t\t\tq.append(i)\n\nfor i in a:\n\tans += (len(b) - len(tr[i]))\nprint(ans)\n", "import sys\n\ndef main():\n    numNodes = [int(x) for x in sys.stdin.readline().rsplit()][0]\n    adjList = {}\n    nodeColors = {}\n    unmarked = {}\n    for i in range(1, numNodes+1):\n        adjList[i] = []\n        unmarked[i] = True\n    for line in sys.stdin.read().split(\"\\n\"):\n        lineUnpacked = [int(x) for x in line.rsplit()]\n        if (len(lineUnpacked) < 2):\n            continue\n        node1,node2 = lineUnpacked\n        adjList[node1].append(node2)\n        adjList[node2].append(node1)\n    bfsList = []\n    bfsList.append(1)\n    nodeColors[1] = True\n    unmarked[1] = False\n    set1 = [1]\n    set2 = []\n    while (len(bfsList) > 0):\n        nodeConsidered = bfsList.pop(0)\n        colorConsidered = nodeColors[nodeConsidered]\n        newNodes = [x for x in adjList[nodeConsidered] if unmarked[x]]\n        newNodes = list(newNodes)\n        for node in newNodes:\n            unmarked[node] = False\n            nodeColors[node] = not colorConsidered\n        bfsList.extend(newNodes)\n        if (colorConsidered):\n            set2.extend(newNodes)\n        else:\n            set1.extend(newNodes)\n    count = 0\n    for node in set1:\n        count = count + len(set2) - len(adjList[node])                \n    return(count)\n                    \nprint(main())\n", "from collections import deque\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor i in range(n - 1):\n    u, v = input().split()\n    u, v = int(u), int(v)\n    adj[u - 1].append(v - 1)\n    adj[v - 1].append(u - 1)\n\nqueue = deque()\nqueue.append((0, 0))\n\nh = [0 for i in range(n)]\nh_even = 1\nh_odd = 0\n\nwhile len(queue) > 0:\n    tmp = queue.pop()\n    p = tmp[1]\n    u = tmp[0]\n    for v in adj[u]:\n        if v == p:\n            continue\n        h[v] = h[u] + 1\n        if h[v]%2 == 0:\n            h_even += 1\n        else:\n            h_odd += 1\n        queue.append((v, u))\n\nprint(h_even * h_odd - n + 1)\n", "n = int(input())\nadj = [[[], 0, 0] for i in range(n)]\n\n\nfor i in range(n-1):\n\tu, v = map(int, input().split())\n\tadj[u-1][0].append(v-1)\n\tadj[v-1][0].append(u-1)\n\nqueue = [0]\n\nwhile queue:\n\tcurr_v = queue.pop(0)\n\tadj[curr_v][2] = 1\n\tfor u in adj[curr_v][0]:\n\t\tif not adj[u][2]:\n\t\t\tqueue.append(u)\n\t\t\tadj[u][1] = adj[curr_v][1]+1\n\nev = 0\nn_ev = 0\n\nfor el in adj:\n\tif el[1] % 2 == 0:\n\t\tev += 1\n\telse:\n\t\tn_ev +=1\n\nans = 0\n\nfor el in adj:\n\tif el[1] % 2 == 0:\n\t\tans += n_ev - len(el[0])\n\telse:\n\t\tans += ev - len(el[0])\n\nprint(ans//2)", "def input_numbers():\n    return list(map(int, input().split()))\n\n\n# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u0435\u0440\u0448\u0438\u043d\nn = int(input())\n\n# \u0427\u0438\u0442\u0430\u0435\u043c \u0434\u0435\u0440\u0435\u0432\u043e\ng = {}\ni = 1\n\nwhile i <= n:\n    g[i] = set()\n    i += 1\n\ni = 1\nwhile i <= n - 1:\n    u, v = input_numbers()\n\n    g[u].add(v)\n    g[v].add(u)\n\n    i += 1\n\n# \u041e\u0431\u0445\u043e\u0434\u0438\u043c \u0434\u0435\u0440\u0435\u0432\u043e \u0432 \u0448\u0438\u0440\u0438\u043d\u0443 \u0438 \u0434\u0435\u043b\u0438\u043c \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438\nqueue = [1]\nvisited = set()\n\npart1 = set(queue)\npart2 = set()\n\nwhile len(queue):\n    u = queue.pop(0)\n    visited.add(u)\n\n    for v in g[u]:\n        if v not in visited:\n            queue.append(v)\n\n            if u in part1:\n                part2.add(v)\n            else:\n                part1.add(v)\n\n# \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043d\u0443\u0436\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440 \u043a\u0430\u043a \u0440\u0430\u0437\u043d\u043e\u0441\u0442\u044c \u043c\u0435\u0436\u0434\u0443\n# \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u043c \u0438 \u0442\u0435\u0445, \u0447\u0442\u043e \u0443\u0436\u0435 \u0435\u0441\u0442\u044c\nneed = len(part1) * len(part2) - (n - 1)\n\nprint(need)", "#!/usr/bin/env python3\n# encoding: utf-8\n\n\n\n#----------\n# Constants\n#----------\nLEFT = 0\nRIGHT = 1\n\n\n\n#----------\n# Functions\n#----------\n\n# Reads a string from stdin, splits it by space chars, converts each\n# substring to int, adds it to a list and returns the list as a result.\ndef get_ints():\n    return [ int(n) for n in input().split() ]\n\n\n\n#----------\n# Execution start point\n#----------\n\ndef __starting_point():\n    import sys\n\n    a = get_ints()\n    assert len(a) == 1\n    n = a[0]\n\n    links = [ set() for i in range(n) ]\n    for i in range(n-1):\n        a = get_ints()\n        assert len(a) == 2\n        for j in range(2):\n            a[j] -= 1\n        links[a[0]].add(a[1])\n        links[a[1]].add(a[0])\n\n    count = [ 0, 0 ]\n    looked = [ False for i in range(n) ]\n    stack = dict()\n    stack[0] = LEFT\n    while stack:\n        index, side = stack.popitem()\n        if not looked[index]:\n            looked[index] = True\n            count[side] += 1\n            for i in links[index]:\n                stack[i] = 1 - side\n\n    res = count[LEFT] * count[RIGHT] - n + 1\n    print(\"%d\" % res)\n\n__starting_point()", "n=int(input())\nl=[0]*n\nd={}\nd=[[]for _ in range(n)]\nfor _ in range(n-1):\n  a,b=list(map(int,input().split()))\n  d[a-1].append(b)\n  d[b-1].append(a)\nl[0]=1\ncheck=[1]\nwhile check:\n  x=check.pop()\n  for y in d[x-1]:\n    if not l[y-1]:\n      check.append(y)\n      l[y-1]=-1*l[x-1]\nred=l.count(1)\nprint(red*(n-red)-n+1)\n", "n=int(input());f=lambda u,v:u.append(v);l=[0]*n;d=[[]for _ in range(n)];l[0]=1;c=[1]\nfor _ in range(n-1):\n  a,b=list(map(int,input().split()));f(d[a-1],b);f(d[b-1],a)\nwhile c:\n  x=c.pop()\n  for y in d[x-1]:\n    if not l[y-1]:\n      f(c,y);l[y-1]=-1*l[x-1]\nr=l.count(1);print(r*(n-r)-n+1)\n", "n=int(input());l=[0]*n;d=[[]for _ in range(n)];l[0]=1;c=[0]\nfor _ in range(n-1):\n  a,b=map(int,input().split());d[a-1].append(b-1);d[b-1].append(a-1)\nwhile c:\n  x=c.pop()\n  for y in d[x]:\n    if not l[y]:\n      c.append(y);l[y]=-1*l[x]\nr=l.count(1);print(r*(n-r)-n+1)", "n=int(input());l=[1]+[0]*n;d=[[]for _ in range(n)];c=[0]\nfor _ in range(n-1):\n  a,b=map(int,input().split());d[a-1].append(b-1);d[b-1].append(a-1)\nwhile c:\n  x=c.pop()\n  for y in d[x]:\n    if not l[y]:\n      c.append(y);l[y]=-1*l[x]\nr=l.count(1);print(r*(n-r)-n+1)", "n=int(input());l=[1]+[0]*n;d=[[]for _ in range(n)];c=[0]\nfor _ in range(n-1):\n  a,b=map(int,input().split());d[a-1]+=[b-1];d[b-1]+=[a-1]\nwhile c:\n  x=c.pop()\n  for y in d[x]:\n    if not l[y]:\n      c+=[y];l[y]=-l[x]\nr=l.count(1);print(r*(n-r)-n+1)", "n=int(input())\ng=[[] for _ in range(n+1)]\nfor _ in range(n-1):\n    u,v=list(map(int,input().split()))\n    g[u].append(v)\n    g[v].append(u)\n\nst=[(1,0,0)]\nm=0\nwhile st:\n    u,p,c=st.pop()\n    m += c\n    st.extend((v,u,1-c) for v in g[u] if v!=p)\n    \nprint(m*(n-m)-n+1)\n", "n = int(input())\ndist = {}\nfor i in range(n-1):\n    u, v = [int(e) for e in input().split()]\n    if u not in dist:\n        dist[u] = []\n    if v not in dist:\n        dist[v] = []\n    dist[u].append(v)\n    dist[v].append(u)\n    if i == 0:\n        root = u\na = {}\na[root] = 1\nq = [root]\nwhile q:\n    top = q.pop()\n    for e in dist[top]:\n        if e not in a:\n            a[e] = -a[top]\n            q.append(e)\nr = list(a.values()).count(1)\nprint(r * (n - r) - n + 1)\n", "n = int(input())\ndist = {}\nfor i in range(n-1):\n    u, v = [int(e) for e in input().split()]\n    if u not in dist:\n        dist[u] = []\n    if v not in dist:\n        dist[v] = []\n    dist[u].append(v)\n    dist[v].append(u)\n    if i == 0:\n        root = u\na = {}\na[root] = 1\nq = [root]\nwhile q:\n    top = q.pop()\n    for e in dist[top]:\n        if e not in a:\n            a[e] = -a[top]\n            q.append(e)\ns1 = [k for k, v in list(a.items()) if v == 1]\ns2 = [k for k, v in list(a.items()) if v == -1]\nprint(len(s1) * len(s2) - n + 1)\n", "def readln(): return list(map(int, input().rstrip().split()))\n\n\ndata = {}\nn = int(input())\nfor i in range(1, n + 1):\n    data[i] = []\nfor i in range(0, n - 1):\n    u, v = readln()\n    data[u].append(v)\n    data[v].append(u)\n\nl = [0, 0]\nvisited = [False] * (n + 1)\n\nstk = [(1, 0)]\nwhile stk:\n    u = stk.pop()\n    visited[u[0]] = True\n    l[u[1]] += 1\n    for i in data[u[0]]:\n        if not visited[i]:\n            stk.append((i, 1 - u[1]))\n\nprint(l[0] * l[1] - (n - 1))\n", "import collections\nn = int(input())\n\n\ndef bfs(stack1):\n    while True:\n        stack2 = list()\n        while stack1:\n            vertex = stack1.pop()\n            if not visited1[vertex]:\n                visited1[vertex] = 1\n                for v in inp[vertex]:\n                    if not visited2[v]:\n                        stack2.append(v)\n        if not stack2:\n            return\n        stack1 = list()\n        while stack2:\n            vertex = stack2.pop()\n            if not visited2[vertex]:\n                visited2[vertex] = 1\n                for v in inp[vertex]:\n                    if not visited1[v]:\n                        stack1.append(v)\n\n        if not stack1:\n            return\n\ninp = collections.defaultdict(list)\nfor _ in range(n-1):\n    v1, v2 = list(map(int, input().split()))\n    inp[v1].append(v2)\n    inp[v2].append(v1)\n#print(inp)\nvisited1, visited2 = [0] + [0] * n, [0] + [0] * n\nbfs([1])\nprint(sum(visited1) * sum(visited2) - (n - 1))\n\n\"\"\"\n6\n2 1\n3 1\n4 1\n5 2\n2 6\n\"\"\"\n", "import collections\nn = int(input())\n\n\ndef bfs(stack1):\n    while True:\n        stack2 = list()\n        while stack1:\n            vertex = stack1.pop()\n            if not visited1[vertex]:\n                visited1[vertex] = 1\n                for v in inp[vertex]:\n                    if not visited2[v]:\n                        stack2.append(v)\n        if not stack2:\n            return\n        stack1 = list()\n        while stack2:\n            vertex = stack2.pop()\n            if not visited2[vertex]:\n                visited2[vertex] = 1\n                for v in inp[vertex]:\n                    if not visited1[v]:\n                        stack1.append(v)\n\n        if not stack1:\n            return\n\ninp = collections.defaultdict(list)\nfor _ in range(n-1):\n    v1, v2 = list(map(int, input().split()))\n    inp[v1].append(v2)\n    inp[v2].append(v1)\n#print(inp)\nvisited1, visited2 = [0] + [0] * n, [0] + [0] * n\nbfs([1])\nprint(sum(visited1) * sum(visited2) - (n - 1))\n\n\"\"\"\n6\n2 1\n3 1\n4 1\n5 2\n2 6\n\"\"\"\n", "from _collections import defaultdict\nn = int(input())\nf = 0\ns=0\ngen = defaultdict(list)\nfor i in range(n - 1):\n    a, b = map(lambda x: int(x), input().split())\n    gen[a].append(b)\n    gen[b].append(a)\nstart=[1]\nvisited=set()\nTurn=True\nwhile start:\n    q = []\n    for i in start:\n        visited.add(i)\n        for j in gen[i]:\n            if j not in visited:\n                q.append(j)\n    if  Turn:\n        f+=len(start)\n    else:\n        s+=len(start)\n    Turn = not Turn\n    start = q\nprint(f*s-(n-1))"]
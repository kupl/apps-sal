["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nMAP=[list(input().strip()) for i in range(n)]\n\nfrom collections import deque\nQ=deque()\nQ.append([0,0])\n\nwhile Q:\n    x,y=Q.pop()\n\n    if x+1<n and MAP[x+1][y]==\".\":\n        MAP[x+1][y]=1\n        Q.append([x+1,y])\n\n    if y+1<m and MAP[x][y+1]==\".\":\n        MAP[x][y+1]=1\n        Q.append([x,y+1])\n\nQ.append([n-1,m-1])\n\n\nwhile Q:\n    x,y=Q.pop()\n\n    if x-1>=0 and MAP[x-1][y]==1:\n        MAP[x-1][y]=0\n        Q.append([x-1,y])\n\n    if y-1>=0 and MAP[x][y-1]==1:\n        MAP[x][y-1]=0\n        Q.append([x,y-1])\n\nif MAP[n-1][m-1]!=1:\n    print(0)\n    return\n\nSCORE=[0]*(n+m+5)\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==0:\n            SCORE[i+j]+=1\n\nif 1 in SCORE:\n    print(1)\nelse:\n    print(2)\n    \n", "import sys\ninput = sys.stdin.readline\nn,m=map(int,input().split())\nif n==1:\n\tf=input().strip()\n\tif '#' in f: \n\t\tprint(0)\n\telse:print(1)\n\treturn \nif m==1:\n\t\n\tf=input().strip()\n\tfor i in range(n):\n\t\tif '#'==f:\n\t\t\tprint(0)\n\t\t\tbreak\n\t\tf=input().strip()\n\telse:print(1)\n\treturn \n\na=[]\nfor i in range(n):\n\tb=input().strip()\n\td=[]\n\tfor j in range(m):\n\t\tif b[j]=='.':d.append(1)\n\t\telse:d.append(0)\n\ta.append(d)\ngr=[[] for i in range(n*m+5)]\nfor i in range(2,n+1):\n\tfor j in range(2,m+1):\n\t\tif a[i-2][j-1]==1:\n\t\t\tgr[(i-1)*m+j].append((i-2)*m+j)\n\t\tif a[i-1][j-2]==1:\n\t\t\tgr[(i-1)*m+j].append((i-1)*m+j-1)\n\t\t\n\t\t\nfor i in range(2,n+1):\n\tif a[i-2][0]==1:\n\t\t\tgr[(i-1)*m+1].append((i-2)*m+1)\nfor j in range(2,m+1):\n\tif a[0][j-2]==1:\n\t\t\tgr[j].append(j-1)\nif a[n-1][m-2]==1:gr[n*m].append(n*m-1)\nif a[n-2][m-1]==1:gr[n*m].append(n*m-m)\n\nv=[False for i in range(n*m+6)]\nif a[n-1][m-2]==1:\n\ts=[n*m-1]\n\tt=True\n\twhile s and t:\n\t\tx=s.pop()\n\t\tif x==1:t=False\n\t\tv[x]=True\n\t\tfor j in gr[x]:\n\t\t\tif v[j]:continue\n\t\t\ts.append(j)\nans=0\nif v[1]:ans+=1\nv[1]=False\nif a[n-2][m-1]==1:\n\ts=[n*m-m]\n\twhile s:\n\t\tx=s.pop()\n\t\tv[x]=True\n\t\tfor j in gr[x]:\n\t\t\tif v[j]:continue\n\t\t\ts.append(j)\nif v[1]:ans+=1\nprint(ans)", "from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nts=time.time()\nsys.setrecursionlimit(10**6)\ndef SI():\n    return input().split()\ndef MI():\n    return list(map(int,input().split()))\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\nYN=['Yes','No']\nmo=10**9+7\nfrom math import log\ninput = sys.stdin.readline\n\npr=False\n#pr=True\ndef tprint(*a):\n    if pr:print(*a)\n    return\n\nn,m=MI()\nmp=[[1]*(m+2)]\nif m==1:\n    for i in range(n):\n        for j in list(input()):\n            if j=='#':\n                print(0)\n                return\n    print(1)\n    return\n\nfor i in range(n):\n    a=[1]\n    for j in list(input()):\n        if j=='#':\n            a.append(1)\n        else:\n            a.append(0)\n    mp.append(a+[1])\nmp.append([1]*(m+2))\n\ndef search():\n    go=[[0]*(m+2) for _ in range(n+2)]\n    go[0][1]=1\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if mp[i][j]!=1:\n                if go[i-1][j]+go[i][j-1]>0: go[i][j]=1\n    go[0][1]=0\n    return go\n\ndef bc_search(go):\n    bc=[[0]*(m+2) for _ in range(n+2)]\n    bc[n+1][m]=1\n    for i in range(n,0,-1):\n        for j in range(m,0,-1):\n            if go[i][j]!=0:\n                if bc[i+1][j]+bc[i][j+1]>0: bc[i][j]=1\n    bc[n+1][m]=0\n    return bc\n\ngo=search()\nbc=bc_search(go)\nG=[[0]*(m+3)]\nG+=[[0]+[bc[i][j] for j in range(m+2)] for i in range(n+2)]\n\nfor i in range(n+2):\n    for j in range(m+2):\n        G[i+1][j+1]+=G[i+1][j]+G[i][j+1]-G[i][j]\n\nif go[n][m]==0:\n    ans=0\nelse:\n    ans=2\n        \n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if i*j==1 or i*j==n*m:\n                continue\n            s=0\n            if j+1<m+3+10: s+=G[i][m+2]-G[i][j+1]\n            if i+1<n+3+10: s+=G[n+2][j]-G[i+1][j]\n            if s==0:\n                ans=1\n                tprint(i,j,G[i+1][j+1])\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn, m = [int(item) for item in input().split()]\nfield = []\nfield.append(\"#\" * (m+2))\nfor i in range(n):\n    field.append(\"#\" + input().rstrip() + \"#\")\nfield.append(\"#\" * (m+2))\n\nvisited = [[False] * (m+2) for _ in range(n+2)]\nfor i in range(2):\n    q = [(1,1)]\n    while q:\n        x, y = q.pop()\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n        if field[x+1][y] != \"#\" and not visited[x+1][y]:\n            q.append((x+1, y))\n        if field[x][y+1] != \"#\" and not visited[x][y+1]:\n            q.append((x, y+1))\n        if x == n and y == m:\n            break\n    if x != n or y != m:\n        print(i)\n        return\n    visited[1][1] = False\n    visited[n][m] = False\nprint(2)", "import sys\n\nreadLn = sys.stdin.readline\n\ndef __starting_point():\n    n, m = list(map(int, readLn().split()))\n    ds = [[-1 if c == '#' else 0 for c in readLn()] for _ in range(n)]\n    ds[0][0] = 1\n    for i in range(0, n):\n        for j in range(0, m):\n            if ds[i][j] == 0:\n                if i > 0 and ds[i - 1][j] > 0:\n                    ds[i][j] = ds[i - 1][j] + 1\n                if j > 0 and ds[i][j - 1] > 0:\n                    ds[i][j] = ds[i][j - 1] + 1\n    if ds[n - 1][m - 1] == 0:\n        print(0)\n    else:\n        ds[n - 1][m - 1] = -2\n        sm = [0 for _ in range(n + m + 1)]\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                if ds[i][j] > 1 and ((i + 1 < n and ds[i + 1][j] == -2) or (j + 1 < m and ds[i][j + 1] == -2)):\n                    sm[ds[i][j]] += 1\n                    ds[i][j] = -2\n        ans = 2\n        for i in range(2, n + m):\n            if sm[i] == 1:\n                ans = 1\n                break\n        print(ans)\n\n__starting_point()", "import sys\nn, m = list(map(int, input().split()))\n\n# fields = ['#' * (2 + m)] + ['#' + input() + '#' for i in range(n)] + ['#' * (2 + m)]\nfields = ['#' * (2 + m)] + ['#' + sys.stdin.readline().rstrip() + '#' for i in range(n)] + ['#' * (2 + m)]\n\nvisited = [[False] * (m + 2) for i in range(n + 2)]\n\nfor i in range(2):\n    q = [(1, 1)]\n\n    while q:\n        x, y = q.pop()\n\n        if visited[x][y]:\n            continue\n\n        visited[x][y] = True\n\n        if fields[x+1][y] != '#' and not visited[x+1][y]:\n            q.append((x+1, y))\n        if fields[x][y+1] != '#' and not visited[x][y+1]:\n            q.append((x, y+1))\n\n        if x == n and y == m:\n            break\n\n    if x != n or y != m:\n        print(i)\n        return\n\n    visited[1][1] = False\n    visited[n][m] = False\n\nprint(2)\n\n\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\n \nn,m=list(map(int,input().split()))\nMAP=[list(input().strip()) for i in range(n)]\n \nfrom collections import deque\nQ=deque()\nQ.append([0,0])\n \nwhile Q:\n    x,y=Q.pop()\n \n    if x+1<n and MAP[x+1][y]==\".\":\n        MAP[x+1][y]=1\n        Q.append([x+1,y])\n \n    if y+1<m and MAP[x][y+1]==\".\":\n        MAP[x][y+1]=1\n        Q.append([x,y+1])\n    #print(Q,MAP)\n \nQ.append([n-1,m-1])\n#print('1',Q,MAP) \n \nwhile Q:\n    x,y=Q.pop()\n \n    if x-1>=0 and MAP[x-1][y]==1:\n        MAP[x-1][y]=0\n        Q.append([x-1,y])\n \n    if y-1>=0 and MAP[x][y-1]==1:\n        MAP[x][y-1]=0\n        Q.append([x,y-1])\n    #print(Q,MAP)\n#print('2',Q,MAP)\nif MAP[n-1][m-1]!=1:\n    print(0)\n    return\n \nSCORE=[0]*(n+m+5)\n \nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==0:\n            SCORE[i+j]+=1\n#print(SCORE) \nif 1 in SCORE:\n    print(1)\nelse:\n    print(2)\n", "import sys\ninput = sys.stdin.readline\n \nn,m=list(map(int,input().split()))\nMAP=[list(input().strip()) for i in range(n)]\n \nfrom collections import deque\nQ=deque()\nQ.append([0,0])\n\nwhile Q:\n    x,y=Q.pop()\n \n    if x+1<n and MAP[x+1][y]==\".\":\n        MAP[x+1][y]=1\n        Q.append([x+1,y])\n \n    if y+1<m and MAP[x][y+1]==\".\":\n        MAP[x][y+1]=1\n        Q.append([x,y+1])\n    #print(Q,MAP)\n \nQ.append([n-1,m-1])\nif MAP[n-1][m-1]!=1:\n    print(0)\n    return\n#print('1',Q,MAP) \n\nwhile Q:\n    x,y=Q.pop()\n \n    if x-1>=0 and MAP[x-1][y]==1:\n        MAP[x-1][y]=0\n        Q.append([x-1,y])\n \n    if y-1>=0 and MAP[x][y-1]==1:\n        MAP[x][y-1]=0\n        Q.append([x,y-1])\n    #print(Q,MAP)\n#print('2',Q,MAP)\n\n \nSCORE=[0]*(n+m+5)\n\nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==0:\n            SCORE[i+j]+=1\n#print(SCORE) \nif 1 in SCORE:\n    print(1)\nelse:\n    print(2)\n", "import sys\ninput = sys.stdin.readline\n\nt = 1\nfor _ in range(t):\n    n, m = (int(x) for x in input().split())\n    mat = [input() for x in range(n)]\n    dp = [[0 for x in range(m+1)] for y in range(n+1)]\n\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if mat[i][j] == '#':\n                dp[i][j] = 0\n\n            elif i == n-1 and j == m-1:\n                dp[i][j] = 1\n\n            elif i == n-1:\n                dp[i][j] = dp[i][j+1]\n\n            elif j == m-1:\n                dp[i][j] = dp[i+1][j]\n\n            else:\n                dp[i][j] = dp[i+1][j] + dp[i][j+1]\n\n    if dp[0][0] == 0:\n        print(0)\n        break\n\n    ans = 2\n    r1, c1, r2, c2 = 0, 0, 0, 0\n    # It takes n+m-2 steps to reach from start to end\n    for i in range(n+m-2-1):\n        if dp[r1+1][c1] != 0:\n            r1 += 1\n        else:\n            c1 += 1\n\n        if dp[r2][c2+1] != 0:\n            c2 += 1\n        else:\n            r2 += 1\n\n        if r1 == r2 and c1 == c2:\n            ans = 1\n            break\n\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\n \nn,m=list(map(int,input().split()))\nMAP=[list(input().strip()) for i in range(n)]\n \nfrom collections import deque\nQ=deque()\nQ.append([0,0])\n \nwhile Q:\n    x,y=Q.pop()\n \n    if x+1<n and MAP[x+1][y]==\".\":\n        MAP[x+1][y]=1\n        Q.append([x+1,y])\n \n    if y+1<m and MAP[x][y+1]==\".\":\n        MAP[x][y+1]=1\n        Q.append([x,y+1])\n \nQ.append([n-1,m-1])\n \n \nwhile Q:\n    x,y=Q.pop()\n \n    if x-1>=0 and MAP[x-1][y]==1:\n        MAP[x-1][y]=0\n        Q.append([x-1,y])\n \n    if y-1>=0 and MAP[x][y-1]==1:\n        MAP[x][y-1]=0\n        Q.append([x,y-1])\n \nif MAP[n-1][m-1]!=1:\n    print(0)\n    return\n \nSCORE=[0]*(n+m+5)\n \nfor i in range(n):\n    for j in range(m):\n        if MAP[i][j]==0:\n            SCORE[i+j]+=1\n \nif 1 in SCORE:\n    print(1)\nelse:\n    print(2)\n", "from sys import stdin\nfrom collections import defaultdict\nn, m = list(map(int, input().split()))\n\nif n == 1 or m == 1:\n    if '#' in stdin.read():\n        print(0)\n    else:\n        print(1)\n    return\n\ngraph = []\nfor i in range(n):\n    graph.append(input())\n\ndef dfs(visited):\n    reachable = []\n    stack = []\n    stack.append((0, 0))\n    \n    while stack:\n        node_r, node_c = stack.pop()\n        if not visited[node_r][node_c]:\n            visited[node_r][node_c] = True\n            reachable.append((node_r, node_c))\n            if node_r + 1 < n and not visited[node_r + 1][node_c] and graph[node_r + 1][node_c] != '#':\n                stack.append((node_r + 1, node_c))\n            if node_c + 1 < m and not visited[node_r][node_c + 1] and graph[node_r][node_c + 1] != '#':\n                stack.append((node_r, node_c + 1))\n            if node_r == n - 1 and node_c == m - 1:\n                break\n    \n    return reachable\n\n'''           \ndef dfs_reverse():\n    visited = [[False for j in range(m)] for i in range(n)]\n    reachable = []\n    stack = []\n    stack.append((n - 1, m - 1))\n\n    while stack:\n        node_r, node_c = stack.pop()\n        if not visited[node_r][node_c]:\n            visited[node_r][node_c] = True\n            reachable.append((node_r, node_c))\n            if node_r - 1 >= 0 and not visited[node_r - 1][node_c] and graph[node_r - 1][node_c] != '#':\n                stack.append((node_r - 1, node_c))\n            if node_c - 1 >= 0 and not visited[node_r][node_c - 1] and graph[node_r][node_c - 1] != '#':\n                stack.append((node_r, node_c - 1))\n    \n    return reachable\n'''\n\nvisited = [[False for j in range(m)] for i in range(n)]\ndfs(visited)\n\nif not visited[n - 1][m - 1]:\n    print(0)\nelse:\n    visited[0][0] = False\n    visited[n - 1][m - 1] = False\n    dfs(visited)\n    if visited[n - 1][m - 1]:\n        print(2)\n    else:\n        print(1)\n", "from collections import *\nimport sys\ndef main():\n    r, c = map(int, sys.stdin.readline().strip().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(r)]\n    n = sum(u.count('#') for u in grid)\n    if n == 0:\n        if r == 1:\n            print(1)\n        elif c == 1:\n            print(1)\n        else:\n            print(2)\n        return\n    if r == c == 2:\n        print(2 - n)\n        return\n    grid[0][0] = '0'\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == '#':\n                continue\n            f = False\n            if i != 0:\n                f = f or grid[i - 1][j] == '0'\n            if j != 0:\n                f = f or grid[i][j - 1] == '0'\n            if f:\n                grid[i][j] = '0'\n\n    grid[-1][-1] = '1'\n    for i in range(r - 1, -1, -1):\n        for j in range(c - 1, -1, -1):\n            if grid[i][j] != '0':\n                continue\n            if i != r - 1 and grid[i + 1][j] == '1':\n                grid[i][j] = '1'\n            elif j != c - 1 and grid[i][j + 1] == '1':\n                grid[i][j] = '1'\n\n    if grid[0][0] != '1':\n        print(0)\n        return\n    dictionary = Counter()\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == '1':\n                dictionary[i + j] += 1\n    for key in dictionary:\n        if 0 < key < r + c - 2 and dictionary[key] == 1:\n            print(1)\n            return\n    print(2)\n\nmain()", "import sys\nn, m = list(map(int, input().split()))\no_map = ['.'*(m+2)]\no_map.extend(['.' + sys.stdin.readline() + '.' for i in range(n)])\no_map.append(['.'*(m+2)])\n\n# forward method num\nf_method = [[0]*(m+2) for i in range(n+2)]\n# reverse method num\nr_method = [[0]*(m+2) for i in range(n+2)]\n\nMOD = 10**9 + 93\n# forward calc\nf_method[1][1] = 1\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if o_map[i][j] == '.' and i + j != 2:\n            f_method[i][j] = (f_method[i-1][j] + f_method[i][j-1]) % MOD\n\nr_method[n][m] = 1\nfor i in range(n, 0, -1):\n    for j in range(m, 0, -1):\n        if o_map[i][j] == '.' and i + j != m + n:\n            r_method[i][j] = (r_method[i+1][j] + r_method[i][j+1]) % MOD\nif f_method[n][m] == 0:\n    #if n == 175 and m == 119:\n    #    print(f_method[n-1][m], f_method[n][m-1])\n    print(0)\nelse:\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i + j in [2, m+n]:\n                continue\n\n            if (f_method[i][j] * r_method[i][j]) % MOD == f_method[n][m]:\n                print(1)\n                return\n    print(2)\n", "import sys\nimport collections as cc\ninput = sys.stdin.readline\nn,m=list(map(int,input().split()))\nar=[list(input().strip()) for i in range(n)]\nq=cc.deque()\nq.append([0,0])\nwhile q:\n    x,y=q.pop()\n    if x+1<n and ar[x+1][y]==\".\":\n        ar[x+1][y]=1\n        q.append([x+1,y])\n    if y+1<m and ar[x][y+1]==\".\":\n        ar[x][y+1]=1\n        q.append([x,y+1])\n \nq=cc.deque()\nq.append([n-1,m-1])\n#print(ar)\nwhile q:\n\tx,y=q.pop()\n\tif x-1>=0 and ar[x-1][y]==1:\n\t\tar[x-1][y]=0\n\t\tq.append([x-1,y])\n\tif y-1>=0 and ar[x][y-1]==1:\n\t\tar[x][y-1]=0\n\t\tq.append([x,y-1])\nif ar[n-1][m-1]!=1:\n\tprint(0)\nelse:\n\t#print(ar)\n\tans=[0]*(n+m+10)\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif ar[i][j]==0:\n\t\t\t\tans[i+j]+=1\n\tif 1 in ans:\n\t\tprint(1)\n\telse:\n\t\tprint(2)\n\n\n", "import sys\ninput = sys.stdin.readline\nn, m = [int(item) for item in input().split()]\nfield = []\nfield.append(\"#\" * (m+2))\nfor i in range(n):\n    field.append(\"#\" + input().rstrip() + \"#\")\nfield.append(\"#\" * (m+2))\nvisited = [[False] * (m+2) for _ in range(n+2)]\nfor i in range(2):\n    q = [(1,1)]\n    while q:\n        x, y = q.pop()\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n        if field[x+1][y] != \"#\" and not visited[x+1][y]:\n            q.append((x+1, y))\n        if field[x][y+1] != \"#\" and not visited[x][y+1]:\n            q.append((x, y+1))\n        if x == n and y == m:\n            break\n    if x != n or y != m:\n        print(i)\n        return\n    visited[1][1] = False\n    visited[n][m] = False\nprint(2)\n"]
["import sys, collections\n\ndef gcd(a, b):\n    if b == 0: return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef extgcd(a, b):\n    if b == 0: return 1, 0\n    x, y = extgcd(b, a % b)\n    return y, x - a // b * y\n\ndef prime_factor(n):\n    res = collections.defaultdict(int)\n\n    i = 2\n    while i * i <= n:\n        cnt = 0\n        while n % i == 0:\n            n //= i\n            cnt += 1\n        if cnt > 0: res[i] = cnt\n        i += 1\n    if n != 1: res[n] = 1\n\n    return res\n\ndef modinv(a, mod):\n    if a == 0: return -1\n    if gcd(a, mod) != 1: return -1\n    return extgcd(a, mod)[0] % mod\n\ndef normalize(a1, a2):\n    p1 = prime_factor(a1)\n    p2 = prime_factor(a2)\n\n    keys = list(set(p1.keys()) | set(p2.keys()))\n\n    r1 = 1\n    r2 = 1\n    for k in keys:\n        if p1[k] >= p2[k]:\n            r1 *= k ** p1[k]\n        else:\n            r2 *= k ** p2[k]\n    return r1, r2\n\ndef solve(a1, b1, a2, b2):\n    g = gcd(a1, a2)\n    if (b1 - b2) % g != 0: return -1\n\n    a1, a2 = normalize(a1, a2)\n    u = b1 % a1\n    inv = modinv(a1, a2)\n    v = (b2 - u) * inv % a2\n    return u + v * a1\n\ndef f(x0, T, v):\n    ok = 10 ** 36\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n\n        if x0 + T * mid >= v:\n            ok = mid\n        else:\n            ng = mid\n\n    return ok\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nT = lcm(a1, a2)\nx0 = solve(a1, b1, a2, b2)\n\nif x0 == -1:\n    print(0)\n    return\n\nx0 -= T * 10 ** 36\n\nok = 10 ** 60\nng = -1\n\nwhile ok - ng > 1:\n    mid = (ok + ng) // 2\n\n    val = x0 + T * mid\n    k = (val - b1) // a1\n    l = (val - b2) // a2\n    if k >= 0 and l >= 0:\n        ok = mid\n    else:\n        ng = mid\n\nx0 += ok * T\n\n# L <= x0 + kT < R + 1\nans = f(x0, T, R + 1) - f(x0, T, L)\n\nprint(ans)", "import sys\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n# ax+by=c\ndef extgcd(a, b, c):\n    if b == 0: return c, 0\n    x, y = extgcd(b, a % b, c)\n    return y, x - a // b * y\n\ndef first_term(a1, b1, a2, b2):\n    g = gcd(a1, a2)\n    T = lcm(a1, a2)\n\n    # s*a1+t*a2=b2-b1\n    if (b2 - b1) % g != 0: return -(10 ** 100)\n    x0 = extgcd(a1 // g, a2 // g, (b2 - b1) // g)[0] * a1 + b1 - T * 10 ** 30\n\n    ok = 10 ** 60\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        val = x0 + T * mid\n        k = (val - b1) // a1\n        l = (val - b2) // a2\n\n        if k >= 0 and l >= 0:\n            ok = mid\n        else:\n            ng = mid\n\n    return x0 + ok * T\n\ndef f(a0, T, v):\n    ok = 10 ** 36\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n\n        if a0 + T * mid >= v:\n            ok = mid\n        else:\n            ng = mid\n\n    return ok\n\na1, b1, a2, b2, L, R = list(map(int, input().split()))\n\nT = lcm(a1, a2)\na0 = first_term(a1, b1, a2, b2)\n\nif a0 == -(10 ** 100):\n    print(0)\n    return\n\nprint(f(a0, T, R + 1) - f(a0, T, L))\n", "def nod(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        answer, x, y = nod(b, a % b)\n        x1 = y\n        y1 = x - (a // b) * y\n        return answer, x1, y1\n\n\na1, b1, a2, b2, l, r = list(map(int, input().split()))\ncoeff = b1\nb1, b2, l, r = b1 - coeff, b2 - coeff, max(l - coeff, 0), r - coeff\nl = max(b2, l)\nod, x1, y1 = nod(a1, -a2)\nif b2 % od != 0 or l > r:\n    print(0)\nelse:    \n    x1, y1 = x1 * (b2 // od), y1 * (b2 // od)\n    result = x1 * a1 \n    raznitsa = a1 * a2 // nod(a1, a2)[0]\n    otvet = 0\n    if result < l:\n        vsp = (l - result) // raznitsa\n        if (l - result) % raznitsa != 0:\n            vsp += 1\n        result += vsp * raznitsa\n    if result > r:\n        vsp = (result - r) // raznitsa\n        if (result - r) % raznitsa != 0:\n            vsp += 1        \n        result -= vsp * raznitsa      \n    if result <= r and result >= l:\n        otvet += 1\n        otvet += abs(result - r) // raznitsa\n        otvet += abs(result - l) // raznitsa\n    print(otvet)    \n    # 3 * (- 54) + 81 = \n", "import sys\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n# ax+by=c\ndef extgcd(a, b, c):\n    if b == 0: return c, 0\n    x, y = extgcd(b, a % b, c)\n    return y, x - a // b * y\n\ndef first_term(a1, b1, a2, b2):\n    g = gcd(a1, a2)\n    T = lcm(a1, a2)\n\n    # s*a1+t*a2=b2-b1\n    if (b2 - b1) % g != 0: return -(10 ** 100)\n    x0 = extgcd(a1 // g, a2 // g, (b2 - b1) // g)[0] * a1 + b1 - T * 10 ** 30\n\n    ok = 10 ** 60\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        val = x0 + T * mid\n        k = (val - b1) // a1\n        l = (val - b2) // a2\n\n        if k >= 0 and l >= 0:\n            ok = mid\n        else:\n            ng = mid\n\n    return x0 + ok * T\n\ndef f(a0, T, v):\n    ok = 10 ** 36\n    ng = -1\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n\n        if a0 + T * mid >= v:\n            ok = mid\n        else:\n            ng = mid\n\n    return ok\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nT = lcm(a1, a2)\na0 = first_term(a1, b1, a2, b2)\n\nif a0 == -(10 ** 100):\n    print(0)\n    return\n\nprint(f(a0, T, R + 1) - f(a0, T, L))", "from fractions import gcd\ndef egcd(a, b):\n    if a == 0:\n        return [0, 1]\n    if b == 0:\n        return [1, 0]\n    p = egcd(b%a, a)\n    x = p[0]; y = p[1]\n    return [y-x*(b//a), x]\n\ndef solve(a1, m1, a2, m2):\n    sol = egcd(m1, m2)\n    m1x = m1 * sol[0]\n    m2y = m2 * sol[1]\n    return (m1x*a2+m2y*a1)\n\na1, b1, a2, b2, L, R = list(map(int, input().split(' ')))\nL -= b1; R -= b1; b2 -= b1; b1 = 0;\ng = gcd(a1, a2)\nL = max(L, max(b1, b2))\nif (b2%g != 0 or L > R):\n    print(0)\n    quit()\nrmod = a1 * a2 // g;\na1 //= g; b2 //= g; a2 //= g;\nsol = solve(b1, a1, b2, a2);\nmod = a1 * a2;\nsol %= mod; sol *= g;\nL -= sol; R -= sol;\nif (L <= 0):\n    lnew = L%rmod; R += lnew - L; L = lnew;\nL += rmod; R += rmod;\nprint(R//rmod - (L-1)//rmod)\n\n", "def exgcd(i, j):\n    if j == 0:\n        return 1, 0, i\n    u, v, d = exgcd(j, i % j)\n    return v, u - v * (i // j), d\nma, ra, mb, rb, L, R = list(map(int, input().split(' ')))\nL = max(L, ra, rb)\nif L > R:\n    print(0)\n    return\nif ra > rb:\n    ma, ra, mb, rb = mb, rb, ma, ra\n_, _, md = exgcd(ma, mb)\nif md != 1:\n    if (rb - ra) % md != 0:\n        print(0)\n        return\n    m = ma * mb // md\n    rev, _, _ = exgcd(ma // md, mb // md)\n    rev = (rev % (mb // md) + mb // md) % (mb // md)\n    r = ma * (rb - ra) // md * rev + ra\n    r = (r % m + m) % m\nelse:\n    m = ma * mb\n    bv, av, _ = exgcd(ma, mb)\n    r = ra * mb * av + rb * ma * bv\n    r = (r % m + m) % m\ndef calc(i):\n    return (i - r) // m\nprint(calc(R) - calc(L - 1))\n", "#!/usr/bin/env\tpython\n#-*-coding:utf-8 -*-\nimport math\na1,b1,a2,b2,l,r=list(map(int,input().split()))\nif b1<l:b1=(b1-l)%a1+l\nif b2<l:b2=(b2-l)%a2+l\nc=a1//math.gcd(a1,a2)*a2\nm=min(1+r,c+max(b1,b2))\nwhile b1!=b2 and m>b1:\n\tif b1<b2:b1=(b1-b2)%a1+b2\n\telse:b2=(b2-b1)%a2+b1\nprint((m>b1)*(1+(r-b1)//c))\n", "import math \n\n# g, x, y\ndef gcd(a, b) :\n    if a == 0 :\n        return [b, 0, 1]\n    l = gcd(b % a, a)\n    g, x1, y1 = [int(i) for i in l]\n    x = y1 - (b // a) * x1\n    y = x1\n    return [g, x, y]\n\ndef my_ceil(u, v) :\n    if v < 0 :\n        u *= -1\n        v *= -1\n    return math.ceil(u / v)\n\ndef my_floor(u, v) :\n    if v < 0 :\n        u *= -1\n        v *= -1\n    return math.floor(u / v)\n\na1, b1, a2, b2, L, R = [int(i) for i in input().split()]\nA = a1\nB = -a2\nC = b2 - b1\ng, x0, y0 = [int(i) for i in gcd(abs(A), abs(B))]\n\nif A < 0 : x0 *= -1\nif B < 0 : y0 *= -1\n\nif C % g != 0 :\n    print(0)\n    return\n\nx0 *= C // g\ny0 *= C // g\n\nle = max([\n    float(R - b1 - a1 * x0) / float(a1 * B // g),\n    float(y0 * a2 + b2 - R) / float(a2 * A // g)\n    ])\n\nri = min([\n    float(L - b1 - a1 * x0) / float(a1 * B // g),\n    float(y0 * a2 + b2 - L) / float(a2 * A // g),\n    float(-x0) / float(B // g),\n    float(y0) / float(A // g)\n    ])\n\nle = int(math.ceil(le))\nri = int(math.floor(ri))\n\nif ri - le + 1 <= 10000 :\n    result = 0\n    for k in range(le - 100, ri + 101) :\n        X = x0 + B * k // g\n        Y = y0 - A * k // g\n        if X >= 0 and Y >= 0 and a1 * X + b1 >= L and a1 * X + b1 <= R :\n            result += 1\n    print(result)\nelse : \n    print(max(int(0), ri - le + 1))\n", "from collections import defaultdict\nimport sys, os, math\n\ndef gcd(a1, a2):\n    if a2 == 0:\n        return a1\n    else:\n        return gcd(a2, a1 % a2)\n        \n# return (g, x, y) a*x + b*y = gcd(x, y)\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\ndef __starting_point():\n    #n, m = list(map(int, input().split()))\n    a1, b1, a2, b2, L, R = map(int, input().split())\n    a2 *= -1 \n    LCM = a1 * a2 // gcd(a1, a2)\n    if abs(b1 - b2) % gcd(a1, a2) != 0:\n        print(0)\n        return\n    L = max([b1, b2, L])\n    g, x, y = egcd(a1, a2)\n    X = a1 * x * (b2 - b1) // g + b1\n    X += LCM * math.ceil((L - X) / LCM)\n    if L <= X <= R:\n        print(max(0, (R - X) // LCM + 1))\n    else:\n        print(0)\n__starting_point()", "def extgcd(a, b):\n    x, y = 0, 0\n    d = a;\n    if b != 0:\n        d, y, x = extgcd(b, a%b)\n        y -= (a//b) * x\n    else:\n        x, y = 1, 0\n    return (d, x, y)\n\ndef main():\n    a1, b1, a2, b2, L, R = map(int, input().split())\n    g, k, l = extgcd(a1, a2);\n    b = b2-b1;\n    if (b%g != 0):\n        print (0)\n        return\n    k *= b//g\n    l *= -b//g\n    low = -2**100\n    high = 2**100\n    while high-low > 1:\n        med = (low+high)//2\n        tk = k+med*a2//g\n        tl = l+med*a1//g\n        if (tk >= 0 and tl >= 0):\n            high = med\n        else:\n            low = med\n    k = k+high*a2//g\n    x = a1*k+b1\n    low = -1\n    high = 2**100\n    lcm = a1*a2//g\n    while high - low > 1:\n        med = (low+high)//2\n        tx = x+med*lcm\n        if tx >= L:\n            high = med\n        else:\n            low = med\n    x = x+high*lcm\n    low = 0\n    high = 2**100\n    while high-low > 1:\n        med = (low+high)//2\n        tx = x+med*lcm\n        if (tx <= R):\n            low = med\n        else:\n            high = med\n    if low == 0 and x > R:\n        print (0)\n        return\n    print (low+1)\n    return\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\ndef xgcd (b,n) :\n x0,x1,y0,y1 = 1,0,0,1\n while n != 0 :\n  q,b,n = b//n , n , b % n\n  x0,x1 = x1, x0-q*x1\n  y0,y1 = y1,y0-q*y1\n return b,x0,y0\na,aa,b,bb,l,r = [int (x) for x in input ().split ()]\ng,x,y=xgcd (a,b)\nc = bb-aa\n#print(\"c\",c,g)\nif c%g != 0 :\n print (0)\n exit (0)\n# ax-by = cc = bb-aa\n# ax-by = g(cc) = bb-aa\n#print(x,y)\ni = a*(x*c)//g+aa\nii = (-b*(y*c)//g)+bb\n#print(a*x//g*c,b*y//g*c,aa,bb)\nstep = a*b//g\n#print(a,x,c , \" | \",b,y,c)\n#print(i,ii,step)\nif (ii-i) % step != 0 : \n print(0)\n return\n#print(a,x,c,aa)\n\n#print(i,ii,step)\n# shift i to la,lb\n#print(i,aa,bb)\nif i > max(aa,bb) :\n #print(i-max(aa,bb),step)\n i -= ((i-max(aa,bb))//step) * step\nelif i < max(aa,bb) :\n i += ((max(aa,bb)-i)//step + (1 if (max(aa,bb)-i)%step!=0 else 0)) * step\n\nf = (l-i)//step\nif (l-i) % step != 0 : f+=1\nf = max(f,0)\ns = (r-i)//step\n#print(i,step,f,s)\nprint (max(0,s-f+1))", "#from IPython import embed\ndef mod(a, b):\n\tif b < 0:\n\t\treturn mod(a,-b)\n\tif a >= 0:\n\t\treturn a % b\n\treturn - ((-a)%b)\ndef extended_gcd(a, b):\n\ttmp1 = a\n\ttmp2 = b\n\txx = 0\n\ty = 0\n\tyy = 1\n\tx = 1\n\twhile b != 0:\n\t\tq = a//b\n\t\tt = b\n\t\tb = mod(a,b)\n\t\ta = t\n\t\ttt = xx\n\t\txx = x-q*xx\n\t\tx = t\n\t\tt = yy\n\t\tyy = y-q*yy\n\t\ty = t;\n\tassert(a == tmp1*x+tmp2*y)\n\treturn (a,x,y)\ndef xgcd(b, n):\n    x0, x1, y0, y1 = 1, 0, 0, 1\n    while n != 0:\n        q, b, n = b // n, n, b % n\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return  b, x0, y0\n\ndef ffloor(a, b):\n\tif(b < 0): return ffloor(-a,-b);\n\treturn a//b\ndef cceil( a,  b):\n\tif(b < 0): return cceil(-a,-b);\n\tif a % b == 0: \n\t\treturn a//b\n\treturn a//b+1;\n\t\n\n\ndef main():\n\ts = input()\n\ta1, b1, a2, b2, L, R = [int(i) for i in s.split()]\n\n\tif b2 < b1:\n\t\ta1, a2 , b1, b2 = a2, a1 , b2, b1\n\n\td,x,y = xgcd(a1,-a2)#extended_gcd(a1,-a2)\n\tif(d < 0):\n\t\td *= -1\n\t\tx *= -1\n\t\ty *= -1\n\t\n\tif (b2 - b1) % d !=  0: \n\t\tprint(0)\n\t\treturn\n\n\t#print(d,x,y)\n\tfact = (b2-b1)//d\n\tx *= fact\n\ty *= fact\n\n\tc1 = a2//d;\n\tc2 = a1//d;\n\n\n\ttope1 = ffloor(R-b1-a1*x, a1*c1);\n\tbajo1 = cceil(L-b1-a1*x,c1*a1);\n\tbajo2 = cceil(L-b2-a2*y,c2*a2);\n\ttope2 = ffloor(R-b2-a2*y, a2*c2);\n\n\tbajo3 = max(cceil(-x,c1),cceil(-y,c2));\n\n\t#print(R-b1-a1*x) /( a1*c1) ,(R-b2-a2*y)/ (a2*c2)\n\t#print(L-b1-a1*x)/(c1*a1) ,(L-b2-a2*y)/(c2*a2)\n\t#print(-x/c1,-y/c2)\n\t#print(bajo1,tope1)\n\t\n\t#print(bajo2,tope2)\n\t#print(bajo3)\n\tbajo = max(bajo1,bajo2,bajo3);\n\ttope = min(tope1,tope2);\n\tprint(max(0,tope+1-bajo))\n\t#embed()\nmain()", "#from IPython import embed\n\ndef xgcd(b, n):\n    x0, x1, y0, y1 = 1, 0, 0, 1\n    while n != 0:\n        q, b, n = b // n, n, b % n\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return  b, x0, y0\n\ndef ffloor(a, b):\n\tif(b < 0): return ffloor(-a,-b);\n\treturn a//b\ndef cceil( a,  b):\n\tif(b < 0): return cceil(-a,-b);\n\tif a % b == 0: \n\t\treturn a//b\n\treturn a//b+1;\n\t\n\n\ndef main():\n\ts = input()\n\ta1, b1, a2, b2, L, R = [int(i) for i in s.split()]\n\n\tif b2 < b1:\n\t\ta1, a2 , b1, b2 = a2, a1 , b2, b1\n\n\td,x,y = xgcd(a1,-a2)#extended_gcd(a1,-a2)\n\tif(d < 0):\n\t\td *= -1\n\t\tx *= -1\n\t\ty *= -1\n\t\n\tif (b2 - b1) % d !=  0: \n\t\tprint(0)\n\t\treturn\n\n\t#print(d,x,y)\n\tfact = (b2-b1)//d\n\tx *= fact\n\ty *= fact\n\n\tc1 = a2//d;\n\tc2 = a1//d;\n\n\n\ttope1 = ffloor(R-b1-a1*x, a1*c1);\n\tbajo1 = cceil(L-b1-a1*x,c1*a1);\n\tbajo2 = cceil(L-b2-a2*y,c2*a2);\n\ttope2 = ffloor(R-b2-a2*y, a2*c2);\n\n\tbajo3 = max(cceil(-x,c1),cceil(-y,c2));\n\n\tbajo = max(bajo1,bajo2,bajo3);\n\ttope = min(tope1,tope2);\n\tprint(max(0,tope+1-bajo))\n\t#embed()\nmain()", "a1, b1, a2, b2, L, R = list(map(int, input().split()))\n\ndef xgcd(a,b):\n    prevx, x = 1, 0\n    prevy, y = 0, 1\n    while b:\n        q = a // b\n        x, prevx = prevx - q * x, x\n        y, prevy = prevy - q * y, y\n        a, b = b, a % b\n\n    return a, prevx, prevy\n\ng, x, y = xgcd(a1, -a2)\n\nif (b2 - b1) // g < 0:    \n    g, x, y = -g, -x, -y\n\nif abs(b2 - b1) % abs(g) > 0:\n    print(0)\nelse:\n    a2g, a1g = a2 // abs(g), a1 // abs(g)\n\n    x *= (b2 - b1) // g\n    y *= (b2 - b1) // g\n\n    if x < 0:\n        y += ((abs(x) + a2g - 1) // a2g) * a1g\n        x += ((abs(x) + a2g - 1) // a2g) * a2g      \n\n    if y < 0:\n        x += ((abs(y) + a1g - 1) // a1g) * a2g\n        y += ((abs(y) + a1g - 1) // a1g) * a1g\n\n    if x >= 0 and y >= 0:\n        k = min(x // a2g, y // a1g)\n        x -= k * a2g\n        y -= k * a1g\n\n    res = a1 * x + b1\n    lcm = a1 * a2 // abs(g)\n\n    L, R = max(0, L - res), R - res\n\n    if R < 0:\n        print(0)\n    else:\n        print(R // lcm - L // lcm + (L % lcm == 0))\n\n", "from math import gcd\ndef exd_gcd(a, b):\n  # always return as POSITIVE presentation\n  if a % b == 0:\n    return 0, (1 if b > 0 else -1)\n  x, y = exd_gcd(b, a % b)\n  return y, x - a // b * y\ndef interval_intersect(a, b, c, d):\n  if b <= a or d <= c:\n    return 0\n  if c < a:\n    a, b, c, d = c, d, a, b\n  if c < b:\n    return min(b, d) - c\n  else:\n    return 0\ndef ceil(a, b):\n  return (a + b - 1) // b\n\na1, b1, a2, b2, L, R = list(map(int, input().split()))\ng = gcd(a1, a2)\nif (b1 - b2) % g != 0:\n  print(0)\n  return\nk, l = exd_gcd(a1, a2)\nl = -l\nk *= (b2 - b1) // g\nl *= (b2 - b1) // g\nd1 = a2 // g\nd2 = a1 // g\nassert(k * a1 + b1 == l * a2 + b2)\narb = 3238\nassert((k + arb * d1) * a1 + b1 == (l + arb * d2) * a2 + b2)\nL1, R1 = ceil(max(0, ceil(L - b1, a1)) - k, d1), ((R - b1) // a1 - k) // d1\nL2, R2 = ceil(max(0, ceil(L - b2, a2)) - l, d2), ((R - b2) // a2 - l) // d2\nprint(interval_intersect(L1, R1 + 1, L2, R2 + 1))\n", "from fractions import gcd\na1,b1,a2,b2,l,r=list(map(int,input().split()))\n\nif b1<l:\n    b1=(b1-l)%a1+l\nif b2<l:\n    b2=(b2-l)%a2+l\nks1=(l-b1)/a1\nke1=(r-b1)/a1\nks2=(l-b2)/a2\nke2=(r-b2)/a2\n\ng=gcd(a1,a2)\nvar=a1/g*a2\nlst1=[]\nlst2=[]\nks1=max(b1,b2)\n\nm=min(1+r,var+ks1)\nwhile b1!=b2 and m>b1:\n    if b1<b2:\n        b1=(b1-b2)%a1+b2\n    else:\n        b2=(b2-b1)%a2+b1\nif(m>b1):\n    print(int(1+(r-b1)//var))\nelse:\n    print (\"0\")\n\n\n\n", "def gcd(a, b):\n    if a==0:\n        return (b, 0, 1)\n    g, x1, y1 = gcd(b%a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return (g, x, y)\n\t\ndef solve(a, b, x, y, r):\n    k = (r-x)//a\n    y = (y-x) % b\n    \n    gg, X, Y = gcd(a, b)\n    #print(gg, X, Y, y, a, b)\n    if y % gg != 0:\n        return 0\n    X *= y // gg\n    dd = b//gg\n    if X >= 0:\n        X -= (X//dd) * dd\n    else:\n        g = X//dd\n        if g * dd > X:\n            g += 1\n        X -= g * dd\n    \n    if X < 0:\n        X += dd\n    elif X >= dd:\n        X -= dd\n    \n    if X > k:\n        return 0\n    return (k-X)//dd + 1\n\n\na1, b1, a2, b2, L, R = map(int, input().split())\nd1 = (L-b1)//a1\nif d1 < 0:\n    d1 = 0\nd1 *= a1\nd1 += b1\nd2 = (L-b2)//a2\nif d2 < 0:\n    d2 = 0\nd2 *= a2\nd2 += b2\n\nwhile d1 < L:\n    d1 += a1\nwhile d2 < L:\n    d2 += a2\n\n#print(d1, d2, L, R)\n\nif R < max(d1, d2):\n    print(0)\nelse:\n    \n    if d1 > d2 or (d1 == d2 and a1 < a2):\n        print(solve(a1, a2, d1, d2, R))\n    else:\n        print(solve(a2, a1, d2, d1, R))", "import math\n\na1, b1, a2, b2, l, r = list(map(int, input().split()))\nif b1 < l:\n  b1 = (b1 - l) % a1 + l\nif b2 < l:\n  b2 = (b2 - l) % a2 + l\nc = a1 // math.gcd(a1, a2) * a2\nm = min(1 + r, c + max(b1, b2))\nwhile b1 != b2 and m > b1:\n  if b1 < b2:\n    b1 = (b1 - b2) % a1 + b2\n  else:\n    b2 = (b2 - b1) % a2 + b1\nprint((m > b1) * (1 + (r - b1) // c))\n", "import sys\n# Uz ma to pretekanie nebavi!!!\n\ndef gcd(a, b):\n    if b == 0:\n        return [a, 1, 0]\n    c = a%b\n    [g, x1, y1] = gcd(b, c)\n    x = y1\n    y = x1 - y1 * (a//b)\n    return [g, x, y]\n\na1, b1, a2, b2, l, r = [int(i) for i in input().split(\" \")]\nif max(b1, b2) > r:\n    print(0)\n    return\n\nl = max(l, b1, b2)\n[g, xg, yg] = gcd(a1, a2)\nif (b2 - b1) % g == 0:\n    xg *= (b2 - b1) // g\nelse:\n    print(0)\n    return\nlcm = (a1 * a2) // g\nval = xg * a1 + b1\nif val >= l:\n    val -= (((val - l) // lcm) + 1) * lcm\n    \nprint(((r - val) // lcm) - ((l - val - 1) // lcm))\n"]
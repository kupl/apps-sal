["#!/usr/bin/env python3\n\ndef is_conn(i1, i2):\n  a, b = i1\n  c, d = i2\n  return (c < a < d or c < b < d)\n\nneighbors = {}\nintervals = []\n\nn = int(input())\nfor i in range(0, n):\n  q, x, y = [int(j) for j in input().split()]\n  if q == 1:\n    # we add to the interval\n    ourint = (x,y)\n    intervals.append(ourint)\n    neighbors[ourint] = []\n    # and check for edges\n    for interval in intervals:\n      # if they are connected, join them\n      if is_conn(interval, ourint):\n        neighbors[interval].append(ourint)\n      if is_conn(ourint, interval):\n        neighbors[ourint].append(interval)\n    \n  if q == 2:\n    # we check whether there is a path from x to y\n    # this is easy version, bfs should be enough\n    x -= 1\n    y -= 1\n    a = intervals[x]\n    b = intervals[y]\n    \n    visited = {a}\n    query = [a]\n    while len(query) > 0:\n        j = query[0]\n        query = query[1:]\n        for nei in neighbors[j]:\n            if not nei in visited:\n                query.append(nei)\n                visited = visited | {nei}\n\n    if b in visited:\n        print(\"YES\")\n    else:\n        print(\"NO\")     \n            \n              \n    \n", "def DFS(v,b,visited):\n    visited.add(v)\n    nonlocal count,matrix,ok\n    if v==b:\n        ok = True\n        return\n    for i in range(count):\n        if matrix[v][i]==1 and v!=i and i not in visited:\n            DFS(i,b,visited)\n\n\nn  =  int(input())\nmatrix = [[0]*111 for i in range(111)]\ncount = 0\nok = False\nintervals = []\nfor i in range(n):\n    t,a,b  = list(map(int,input().split()))\n    if t==1:\n        intervals.append((a,b))\n        for l in range(count):\n            c,d = intervals[l]\n            if c<a<d or c<b<d:\n                matrix[count][l]=1\n            if a<c<b or a<d<b:\n                matrix[l][count]=1\n        count+=1\n    if t==2:\n        visited = set()\n        ok = False\n        res = DFS(a-1,b-1,visited)\n        if ok:print(\"YES\")\n        else:print(\"NO\")\n\n", "flag=False;\ndef main():\n    intset=[]\n    qr=int(input())\n    for i in range(qr):\n        qqss=str(input())\n        qqss=qqss.split(\" \")\n        if qqss[0]==\"1\":\n            a=int(qqss[1])\n            b=int(qqss[2])\n            intset.append([a,b]);\n        else:\n            si=int(qqss[1])\n            fi=int(qqss[2])\n            si-=1\n            fi-=1\n            v=[False for x in range(len(intset))]\n            printIsPath(intset,si,fi,v)\n\ndef printIsPath(iset,a,b,v):\n    ast=iset[a][0]\n    aen=iset[a][1]\n    bst=iset[b][0]\n    ben=iset[b][1]\n    if bst < ast < ben or bst < aen < ben:\n        print (\"YES\")\n        return;\n    v[a]=True\n    nonlocal flag;\n    flag=False\n    for i in range(len(iset)):\n        mst=iset[i][0]\n        men=iset[i][1]\n        if  (mst < ast < men or mst < aen < men) and not v[i]:\n            if searchFinal(iset,i,b,v):\n                return;\n    if not flag:\n        print (\"NO\")\n\ndef searchFinal(iset,i,f,v):\n    v[i]=True;\n    if i==f:\n        print (\"YES\")\n        nonlocal flag;\n        flag=True;\n        return True\n    ist=iset[i][0]\n    ien=iset[i][1]\n    for j in range(len(iset)):\n        jst=iset[j][0]\n        jen=iset[j][1]\n        if not v[j] and (jst < ist < jen or jst < ien < jen):\n            searchFinal(iset,j,f,v)\n\nmain()", "data = []\nfor _ in range(int(input())):\n    cmd = list(map(int, input().split()))\n    if cmd[0] == 1:\n        data.append(cmd[1:])\n    else:\n        done = [False] * (len(data) + 1)\n        que = [cmd[1] - 1]\n        while len(que):\n            p = que[0]\n            del que[0]\n            for i, v in enumerate(data):\n                if (v[0] < data[p][0] < v[1] or v[0] < data[p][1] < v[1]) and not done[i]:\n                    done[i] = True\n                    que.append(i)\n        print(\"YES\" if done[cmd[2] - 1] else \"NO\")\n\n\n", "def get_operations():\n    n = int(input())\n    return [tuple(int(k) for k in input().split()) for _ in range(n)]\n\ndef can_move(a, b):\n    x1, y1 = a\n    x2, y2 = b\n    return (x2 < x1 and x1 < y2) or (x2 < y1 and y1 < y2)\n\ndef can_reach(intervals, x, y, mask = []):\n    if not mask:\n        mask = [False] * len(intervals)\n    if x == y:\n        return True\n    mask[x] = True\n    xs = [k for k in range(len(intervals)) if not mask[k] and can_move(intervals[x], intervals[k])]\n    return any(can_reach(intervals, k, y, mask) for k in xs)\n\ndef solve(operations):\n    intervals = []\n    results = []\n    for op in operations:\n        t, x, y = op\n        if t == 1:\n            intervals.append(tuple([x, y]))\n        else:\n            results.append(can_reach(intervals, x - 1, y - 1))\n    return results\n\ndef __starting_point():\n    operations = get_operations()\n    results = solve(operations)\n    for res in results:\n        print('YES' if res else 'NO')\n\n__starting_point()", "path = []\nn = int(input())\nfor it in range(0, n):\n\tdata = list(map(int, input().split(' ')))\n\tif data[0] == 1:\n\t\tpath.append(data[1:])\n\telse:\n\t\tvis = [False] * (len(path) + 1)\n\t\tque = [data[1] - 1]\n\t\twhile len(que):\n\t\t\tp = que[0]\n\t\t\tdel que[0]\n\t\t\tfor i, v in enumerate(path):\n\t\t\t\tif (v[0] < path[p][0] < v[1] or v[0] < path[p][1] < v[1]) and not vis[i]:\n\t\t\t\t\tvis[i] = True\n\t\t\t\t\tque.append(i)\n\t\tprint('YES' if vis[data[2] -1] else 'NO')", "n = int(input())\nxy = []\nadjlist = []\n\ndef dfs(visit,cur,dest):\n    visit[cur] = True\n    if cur==dest: return True\n    else:\n        found = False\n        for v in adjlist[cur] :\n            if not visit[v] :\n                found = found or dfs(visit,v,dest)\n        return found\n\nfor tc in range(0,n):\n    q, a, b = [int(x)-1 for x in input().split()]\n    if q == 0:\n        adjlist.append([])\n        for i in range(0,len(xy)):\n            x,y = xy[i]\n            if (a<x<b or a<y<b):\n                adjlist[i].append(len(xy))\n            if (x<a<y or x<b<y):\n                adjlist[len(xy)].append(i)\n        xy.append((a,b))\n    elif q == 1:\n        visit = [False for x in range(0,len(xy))]\n        if dfs(visit,a,b):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n", "class Interval:\n    def __init__(self, a, b):\n        self.interval_a = a\n        self.interval_b = b\n\n    def can_go(self, interval):\n        return (interval.interval_a < self.interval_a < interval.interval_b) or (\n            interval.interval_a < self.interval_b < interval.interval_b)\n\n\nintervals = []\nmatrix = []\n\n\ndef dfs(a, b, visited, matrix):\n    if a == b:\n        return True\n\n    ans = False\n    visited[a] = True\n    for i in range(len(matrix)):\n        if matrix[a][i] and not visited[i]:\n            ans = ans or dfs(i, b, visited, matrix)\n    return ans\n\n\nfor i in range(int(input())):\n    t, a, b = list(map(int, input().split()))\n    if t == 1:\n        newInterval = Interval(a, b)\n        intervals.append(newInterval)\n        for row in range(len(matrix)):\n            matrix[row].append(intervals[row].can_go(newInterval))\n        matrix.append([])\n        for col in range(len(matrix)):\n            matrix[len(matrix) - 1].append(newInterval.can_go(intervals[col]))\n    if t == 2:\n        visited = []\n        for i in range(len(intervals)):\n            visited.append(False)\n        if dfs(a - 1, b - 1, visited, matrix):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\n\n\n\n\n\n", "s, t, i = {}, [], 1\nfor n in range(int(input())):\n    c, a, b = map(int, input().split())\n    if c > 1: print('YES' if b in s[a] else 'NO')\n    else:\n        s[i] = {i}\n        for j, (x, y) in enumerate(t, 1):\n            if x < a < y or x < b < y: s[i].update(s[j])\n        r = set(j for j, (x, y) in enumerate(t, 1) if a < x < b or a < y < b)\n        for j in range(1, len(t) + 1):\n            if r & s[j]: s[j].update(s[i])\n        t.append((a, b))\n        i += 1", "s, t, i = {}, [], 1\nfor n in range(int(input())):\n    c, a, b = map(int, input().split())\n    if c > 1: print('YES' if b in s[a] else 'NO')\n    else:\n        s[i] = [i]\n        for j, (x, y) in enumerate(t, 1):\n            if x < a < y or x < b < y: s[i].extend(s[j])\n        s[i] = set(s[i])\n        r = [j for j, (x, y) in enumerate(t, 1) if a < x < b or a < y < b]\n        for j in range(1, len(t) + 1):\n            if any(k in s[j] for k in r): s[j].update(s[i])\n        t.append((a, b))\n        i += 1", "def recursive_dfs(graph, start, path=[]):\n  '''recursive depth first search from start'''\n  path=path+[start]\n  for node in graph[start]:\n    if not node in path:\n      path=recursive_dfs(graph, node, path)\n  return path\n\ndef conn(x, y):\n    a, b = x[0], x[1]\n    c, d = y[0], y[1]\n    return c < a < d or c < b < d\n\nadj = {}\nvert = []\nn = int(input())\nfor i in range(n):\n    a, b, c = list(map(int, input().split(' ')))\n    if a == 1:\n        incoming = (b, c)\n        adj[incoming] = []\n        for vertex in vert:\n            if conn(vertex, incoming):\n                adj[vertex].append(incoming)\n            if conn(incoming, vertex):\n                adj[incoming].append(vertex)\n        vert.append(incoming)\n        \n    if a == 2:\n        check = vert[b-1]\n        in_chk = vert[c-1]\n        if in_chk in recursive_dfs(adj, check):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n", "s, t, i = {}, [], 1\nfor n in range(int(input())):\n    c, a, b = map(int, input().split())\n    if c > 1: print('YES' if b in s[a] else 'NO')\n    else:\n        s[i] = [i]\n        for j, (x, y) in enumerate(t, 1):\n            if x < a < y or x < b < y: s[i].extend(s[j])\n        s[i] = set(s[i])\n        r = [j for j, (x, y) in enumerate(t, 1) if a < x < b or a < y < b]\n        for j in range(1, len(t) + 1):\n            if any(k in s[j] for k in r): s[j].update(s[i])\n        t.append((a, b))\n        i += 1", "visited = [0 for i in range(110)]\ndef reset():\n\tnonlocal N,visited\n\tfor i in range(N):\n\t\tvisited[i] = 0\n\ndef dfs(s,e):\n\t#print(s,e)\n\tnonlocal N,nodes,visited\n\tif(s==e):\n\t\treturn True\n\tif(visited[s]==1):\n\t\treturn False\n\tvisited[s]=1\n\tans = False\n\tfor i in range(N):\n\t\tif(i==s):\n\t\t\tcontinue\n\t\ta = nodes[s][0]\n\t\tb = nodes[s][1]\n\t\tc = nodes[i][0]\n\t\td = nodes[i][1]\n\t\tif((c<a and a<d) or (c<b and b<d)):\n\t\t\tans = ans or dfs(i,e) \n\treturn ans\n\nnodes = []\nN = 0\nM = int(input())\nfor k in range(M):\n\tcom,u,v = tuple(int(i) for i in input().split())\n\n\tif(com==1):\n\t\tV = [u,v]\n\t\tnodes.append(V)\n\t\tN+=1\n\telse:\n\t\tu-=1\n\t\tv-=1\n\t\treset()\n\t\tif(dfs(u,v)):\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")", "visited=[False]*105\np={}\ndef dfs(i):\n    nonlocal visited\n    nonlocal p\n    if visited[i]==True:\n        return\n    visited[i]=True\n    for j in p[i]:\n        dfs(j)\n\ndef main():\n    nonlocal visited\n    nonlocal p\n    mode=\"filee\"\n    if mode==\"file\":f=open(\"test.txt\",\"r\")\n    get = lambda :[int(x) for x in (f.readline() if mode==\"file\" else input()).split()]\n    [n]=get()\n    g=[[0]]\n    le = 0\n    for z in range(n):\n        [t,x,y]=get()\n        if t==1:\n            g.append([x,y])\n            le+=1\n            p[le]=[]\n            for i in range(1,le):\n                [a,b] = [g[i][0],g[i][1]]\n                if (x<a and a<y) or (x<b and b<y):\n                    p[i].append(le)\n                if (a<x and x<b) or (a<y and y<b):\n                    p[le].append(i)\n        else:\n            for i in range(105):\n                visited[i]=False\n            dfs(x)\n            print(\"YES\" if visited[y]==True else \"NO\")    \n\n    if mode==\"file\":f.close()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from operator import xor\n\ndef dfs(d, start, finish):\n    visited = []\n    temp = []\n    while True:\n        if start not in visited:\n            visited.append(start)\n            [temp.append(item) for item in d[start]]\n        if not temp:\n            return False\n        temp.reverse()\n        start = temp.pop()\n        temp.reverse()\n        if start == finish:\n            return True\n\nn = int(input())\ndict = {}\nlist = []\nfor i in range(n):\n    line = [int(item) for item in input().split()]\n    if line[0] == 1:\n        dict[(line[1], line[2])] = set()\n        list.append((line[1], line[2]))\n        for (a, b) in dict:\n            if xor(line[1] < a and a < line[2], line[1] < b and b < line[2]):\n                dict[(line[1], line[2])].add((a,b))\n                dict[(a,b)].add((line[1], line[2]))\n            if a > line[1] and b < line[2]:\n                dict[(a,b)].add((line[1], line[2]))\n    else:\n        first = list[line[1]-1]\n        finish = list[line[2]-1]\n        if dfs(dict, first, finish):\n            print('YES')\n        else:\n            print('NO')", "def dfs(a, b, v, e):\n    if a == b:\n        return True\n    v[a] = True\n    for x in e[a]:\n        if not v[x] and dfs(x, b, v, e):\n            return True\n    return False\na, e = [], []    \nfor i in range(int(input())):\n    t, x, y = map(int, input().split())\n    if t == 1:\n        a.append((x, y))\n        e.append([])\n        for i, ai in enumerate(a):\n            if x in range(ai[0] + 1, ai[1]) or y in range(ai[0] + 1, ai[1]):\n                e[-1].append(i)\n            if ai[0] in range(x + 1, y) or ai[1] in range(x + 1, y):\n                e[i].append(len(a) - 1)\n    else:\n        print('YES' if dfs(x - 1, y - 1, [False] * len(a), e) else 'NO')", "visited = [0 for i in range(110)]\n\ndef reset():\n    nonlocal N , visited\n    for i in range(N):\n        visited[i] = 0\n\ndef dfs(s, e):\n    nonlocal N, nodes, visited\n    if s == e:\n        return True\n    if visited[s] == 1:\n        return False\n\n    visited[s] = 1\n    ans  = False\n\n    for i in range(N):\n        if i == s:\n            continue\n\n        a = nodes[s][0]\n        b = nodes[s][1]\n        c = nodes[i][0]\n        d = nodes[i][1]\n\n        if (c<a and a<d) or (c<b and b<d):\n            ans = ans or dfs(i ,e)\n\n    return ans\n\nnodes = []\nN = 0\nM = int(input())\n\nfor k in range(M):\n    con , u , v = tuple(int(i) for i in input().split())\n\n    if con == 1:\n        V = [u,v]\n        nodes.append(V)\n        N += 1\n\n    else:\n         u -= 1\n         v -= 1\n         reset()\n         if dfs(u ,v):\n             print(\"YES\")\n         else:\n             print(\"NO\")", "from collections import deque\n\ndef solve():\n    t = int(input().rstrip())\n    nodes = []\n    graph = {}\n    for _ in range(t):\n        k, x, y = list(map(int, input().rstrip().split()))\n        if k == 1:\n            nodes.append((x,y)) \n            if (x,y) not in graph:\n                graph[(x,y)] = []\n            for a, b in graph:\n                if a < x < b or a < y < b:\n                    graph[(x,y)].append((a,b))\n                if x < a < y or x < b < y:\n                    graph[(a,b)].append((x,y))\n        elif k == 2:\n            a, b = nodes[x-1]\n            c, d = nodes[y-1]\n            stack = deque()\n            stack.append((a,b))\n            seen = set()\n            while len(stack) > 0 and (c, d) not in seen:\n                cur, dest = stack.pop()\n                seen.add((cur, dest))\n                for m, n in graph[(cur, dest)]:\n                    if (m, n) not in seen:\n                        stack.append((m, n))\n            if (c, d) in seen:\n                print('YES')\n            else:\n                print('NO')\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import deque\nfrom sys import stdin\n\nN = int(stdin.readline().rstrip())\nnodes = []\nadj_list = []\nfor n in range(0, N):\n    type, a, b = map(int, stdin.readline().rstrip().split())\n    if type == 1:\n        adj_list.append([])\n        for index in range(0, len(nodes)):\n            (c, d) = nodes[index]\n            if c < a < d or c < b < d:\n                adj_list[len(nodes)].append(index)\n            if a < c < b or a < d < b:\n                adj_list[index].append(len(nodes))\n        nodes.append((a, b))\n    else:\n        queue = deque()\n        visited = [False] * len(nodes)\n        a -= 1\n        b -= 1\n        queue.append(a)\n        path = False\n        while queue:\n            c = queue.popleft()\n            if c == b:\n                path = True\n                break\n            else:\n                for d in adj_list[c]:\n                    if not visited[d]:\n                        queue.append(d)\n                        visited[d] = True\n        if path:\n            print('YES')\n        else:\n            print('NO')", "def in_interval(w, x, y, z):\n\tif (w > y and w < z) or (x > y and x < z):\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef step_through(a, b, c, d, temp):\n\tx = None\n\tfor interval in temp:\n\t\te = int(interval[0])\n\t\tf = int(interval[1])\n\t\tif in_interval(a,b,c,d):\n\t\t\treturn True\n\t\telif in_interval(a,b,e,f):\n\t\t\tx = interval\n\t\t\ttemp.remove(interval)\n\t\t\tif step_through(e,f,c,d,temp):\n\t\t\t\treturn True\n\tif(x != None):\n\t\ttemp.append(x)\n\treturn False\n\nn = int(input())\nset_of_intervals = []\nfor i in range (n):\n\tline = input().split()\n\n\tif line[0] == \"1\":\n\t\tset_of_intervals.append([line[1], line[2]])\n\telse:\n\t\ta = int(set_of_intervals[int(line[1]) - 1][0])\n\t\tb = int(set_of_intervals[int(line[1]) - 1][1])\n\t\tc = int(set_of_intervals[int(line[2]) - 1][0])\n\t\td = int(set_of_intervals[int(line[2]) - 1][1])\n\n\t\ttemp = set_of_intervals[:]\n\t\ttemp.pop(int(line[1]) - 1)\n\t\tif(step_through(a,b,c,d, temp)):\n\t\t\tprint (\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n", "def input_tuple(f):\n    return tuple(map(f, input().rstrip().split()))\n\ndef make_edge(i1, i2, adj_list):\n    i, a, b = i1\n    j, c, d = i2\n    if c < a < d or c < b < d:\n        adj_list[i].append(j)\n\ndef dfs(curr, dest, seen, intervals):\n    i, a, b = curr\n    if i == dest:\n        return True\n    seen.add(i)\n    for j, c, d in intervals:\n        if j in seen:\n            continue\n        if c < a < d or c < b < d:\n            if dfs((j, c, d), dest, seen, intervals):\n                return True\n    return False\n\ndef __starting_point():\n    intervals = []\n    num_queries = int(input().rstrip())\n    i = 1\n    for _ in range(num_queries):\n        t, a, b = input_tuple(int)\n        if t == 1:\n            intervals.append((i, a, b))\n            i += 1\n        elif t == 2:\n            if dfs(intervals[a-1], b, set(), intervals):\n                print('YES')\n            else:\n                print('NO')\n\n__starting_point()", "path = []\nn = int(input())\nfor it in range(0, n):\n\tdata = list(map(int, input().split(' ')))\n\tif data[0] == 1:\n\t\tpath.append(data[1:])\n\telse:\n\t\tvis = [False] * (len(path) + 1)\n\t\tque = [data[1] - 1]\n\t\twhile len(que):\n\t\t\tp = que[0]\n\t\t\tdel que[0]\n\t\t\tfor i, v in enumerate(path):\n\t\t\t\tif (v[0] < path[p][0] < v[1] or v[0] < path[p][1] < v[1]) and not vis[i]:\n\t\t\t\t\tvis[i] = True\n\t\t\t\t\tque.append(i)\n\t\tprint('YES' if vis[data[2] -1] else 'NO')\n", "# intervals and visited intervals have the same key\n# which is the order in which intervals were queried\n\ncounter = 1\nqueries = int(input())\nvisited_intervals = [0] * (queries + 1)\n\nintervals = {}\n\ndef get_interval():\n    return tuple(map(int, input().split()))\n\ndef reset_search_data():\n    nonlocal queries\n    nonlocal visited_intervals\n    del visited_intervals\n    visited_intervals = [0] * queries\n\ndef solve():\n\n    nonlocal counter\n    nonlocal visited_intervals\n\n    for _ in range (queries):\n        query = get_interval()\n        if query[0] == 1:\n           intervals[counter] = query\n           counter += 1\n        elif query[0] == 2:\n            q = []\n            q.append(query[1])\n            # start new search\n            reset_search_data()\n            while len(q) > 0:\n                q_interval = q.pop(0)\n                for index in intervals:\n                    c = intervals[index][1]\n                    d = intervals[index][2]\n                    a = intervals[q_interval][1]\n                    b = intervals[q_interval][2]\n                    if c < a < d or c < b < d:\n                        if visited_intervals[index] == 0:\n                            #print (\"TRUE\", c, a , d, \" \", c ,b ,d )\n                            #print(\"marking \", index)\n                            visited_intervals[index] = 1\n                            #print (\"visited\", index)\n                            q.append(index)\n            if visited_intervals[query[2]] == 1:\n                print (\"YES\")\n            else:\n                print (\"NO\")\nsolve()", "def graphAdd(u, v, G):\n\tfor a, b in G:\n\t\tif (a<u and u<b) or (a<v and v<b):\n\t\t\tconnect(G, u, v, a, b)\n\t\tif (u<a and a<v) or (u<b and b<v):\n\t\t\tconnect(G, a, b, u, v)\n\ndef connect(G, u, v, w, x):\n\tG[(u, v)][(w, x)] = 1\n\ndef queueSort(G, l, u, v):\n\tstart = l[u-1]\n\tvisited = dict()\n\tvisited[start] = 1\n\tend = l[v-1]\n\n\tq = [start]\n\n\twhile q != []:\n\t\tcur = q.pop(0)\n\t\tfor a, b in G[cur]:\n\t\t\tif ((a, b) == end):\n\t\t\t\treturn \"YES\"\n\t\t\tif ((a,b) not in visited):\n\t\t\t\tvisited[(a,b)] = 1\n\t\t\t\tq.append((a,b))\n\treturn \"NO\"\n\nnumTest = int(input())\n\nG = dict()\nl = list()\n\nwhile(numTest>0):\n\n\tinputList= list(map(int, input().split()))\n\ta = inputList[0]\n\tb = inputList[1]\n\tc = inputList[2]\n\n\tif a == 1:\n\t\tG[(b, c)] = {}\n\t\tgraphAdd(b, c, G)\n\t\tl.append((b,c))\n\telse:\n\t\tprint(queueSort(G, l, b, c))\n\n\tnumTest -= 1", "\"\"\"\nSolution to the 320B problem on CodeForces.\n\n# pylint: disable = C0325\n# pylint: disable = W0611\n\"\"\"\n\nfrom collections import deque\n\ndef filter_intervals(intv, input_list):\n    \"\"\"\n    Filters the list for all the intervals that are valid.\n    \"\"\"\n    return ((x, y) for x, y in input_list if (int(intv[0]) > int(x) and int(intv[0]) < int(y)) or \\\n                                             (int(intv[1]) > int(x) and int(intv[1]) < int(y)))\n\ndef interval_search(intv, target, input_list):\n    \"\"\"\n    Finds if a path exists from one interval to another.\n    \"\"\"\n    visited = set()\n    d = deque()\n    d.append(intv)\n    while d:\n        intv = d.pop()\n        if intv == target:\n            return True\n        if intv not in visited:\n            visited.add(intv)\n            for interval in filter_intervals(intv, input_list):\n                if interval not in visited:\n                    d.append(interval)\n    return False\n\ndef main():\n    \"\"\"\n    Docstring or main.\n    \"\"\"\n    num_inputs = int(input())\n    interval_list = []\n    for _ in range(num_inputs):\n        input_type, beg, end = input().split()\n        beg = int(beg)\n        end = int(end)\n        if int(input_type) == 1:\n            interval_list.append((beg, end))\n        else:\n            if interval_search(interval_list[beg-1], interval_list[end-1], interval_list):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
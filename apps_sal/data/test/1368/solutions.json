["N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nX.sort(reverse=True)\nM = sum(X[i] for i in range(A)) / A\nprint(M)\ncntl, cntr = 0, 0\nif X[A-1] == X[N-1]:\n  cntr = N - A\nelse:\n  cntr = A-1\n  while X[A-1] == X[cntr]:\n    cntr += 1\n  cntr -= A\nif X[0] == X[A-1]:\n  cntl = A\nelse:\n  cntl = A-1\n  while X[A-1] == X[cntl]:\n    cntl -= 1\n  cntl = A - 1 - cntl\nF = 0\nc = cntl + cntr\nif cntl == A:\n  t = 1\n  for m in range(A):\n    t *= c - m\n    t //= m + 1\n  for m in range(A, min(B, c)+1):\n    F += t\n    t *= c - m\n    t //= m + 1\n  print(F)\nelse:\n  # calc comb(cntl + cntr, cntl)\n  t = 1\n  for m in range(cntl):\n    t *= c - m\n    t //= m + 1\n  F = t\n  print(F)", "#!/usr/bin/env python3\n\nfrom copy import deepcopy\nfrom fractions import Fraction\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0] = [0, 1]\n    for j in range(n):\n        dppre = deepcopy(dp)\n        for i in range(n):  # \u914d\u308b\n            vnew = dppre[i][0] + v[j]\n            ways = dppre[i][1]\n            if vnew > dp[i + 1][0]:\n                dp[i + 1] = [vnew, ways]\n            elif vnew == dp[i + 1][0]:\n                dp[i + 1][1] += ways\n\n    maxave = 0\n    for i in range(a, b + 1):\n        maxave = max(maxave, Fraction(dp[i][0], i))\n    ways = 0\n    for i in range(a, b + 1):\n        if Fraction(dp[i][0], i) == maxave:\n            ways += dp[i][1]\n    print((float(maxave)))\n    print(ways)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom collections import Counter\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nV.sort(reverse=True)\nc = Counter(V)\nL = []\nfor i in range(A, B + 1):\n    L.append(sum(V[0:i]) / i)\n\nans = []\nfor i in range(A, B + 1):\n    c_t = Counter(V[0:i])\n    tmp = 1\n    for k, v in list(c_t.items()):\n        tmp *= math.factorial(c[k]\n                              ) // math.factorial(v) // math.factorial(c[k] - v)\n    ans.append(tmp)\n\nmax_L = max(L)\n\nnum = 0\nfor i in range(len(L)):\n    if L[i] == max_L:\n        num += ans[i]\n\nprint(('{:.6f}'.format(max_L)))\nprint(num)\n", "N,A,B=map(int,input().split())\nv=[int(x)for x in input().split()]\nv.sort(reverse=True)\na=sum(v[:A])/A\nm=min(v[:A])\nk=v.count(m)\nl=v.index(m)\nans=0\nimport math\nfor i in range(A,B+1):\n    if i==A:\n        ans+=(math.factorial(k)//math.factorial(i-l))//math.factorial(k-i+l)\n    else:\n        if k-i+l>=0 and a==m:\n            ans+=(math.factorial(k)//math.factorial(i-l))//math.factorial(k-i+l)\n        else:\n            break\n            \n            \nprint(\"{:.6f}\".format(a))\nprint(int(ans))  ", "N, A, B = map(int, input().split())\nV = sorted([int(x) for x in input().split()],reverse=True)\nfrom statistics import mean\nfrom math import comb\nmaxmean = mean(V[:A])\nif V[0] != V[A-1]:\n    n = V.count(V[A-1])\n    k = V[:A].count(V[A-1])\n    way = comb(n, k)\nelse:\n    n = V.count(V[A-1])\n    way = sum(comb(n, k) for k in range(A, min(n,B)+1))\nprint(maxmean)\nprint(way)", "import math\ndef C(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nn, a, b = map(int, input().split())\nl = sorted(list(map(int, input().split())), reverse=True)\nprint(sum(l[:a])/a)\nif l.count(l[a-1]) > 1:\n    ans = 0\n    x = l[a-1]\n    y = l[:a].count(x)\n    z = l.count(x)\n    if l[0] != x:\n        print(C(z, y))\n    else:\n        ans = 0\n        for i in range(a, min(b, z)+1):\n            ans += C(z, i)\n        print(ans)\nelse:\n    print(1)", "C = [[0 for j in range(51)] for i in range(51)]\nfor i in range(51):\n    C[i][0] = 1\nfor i in range(1, 51):\n    for j in range(1, 51):\n        C[i][j] = C[i - 1][j - 1] + C[i - 1][j]\nn, a, b = list(map(int, input().split()))\n*V, = list(map(int, input().split()))\nV.sort(reverse=True)\nprint((sum(V[:a]) / a))\nif V[0] == V[a - 1]:\n    x = V.count(V[a - 1])\n    print((sum([C[x][y] for y in range(a, b + 1)])))\nelse:\n    x = V.count(V[a - 1])\n    y = a - len([v for v in V if v > V[a - 1]])\n    print((C[x][y]))\n", "import sys\ninp = lambda: sys.stdin.readline()\nmi = lambda: map(int, inp().split())\nli = lambda: list(map(int, inp().split()))\nmf = lambda: map(float,inp().split())\nlf = lambda: list(map(float,inp().split()))\n\ndef nCk(n,k):\n    u,s = 1,1\n    for i in range(n - k + 1,n + 1):u *= i\n    for i in range(1,k + 1):s *= i\n    return u // s\nN,A,B = mi()\nvec = lf()\nvec.sort()\nvec = vec[::-1]\navr = 0.0\nfor i in range(A):\n    avr += vec[i]\navr /= A\nprint(\"{:.08f}\".format(avr))\nkosu = vec.count(vec[A - 1])\n#print(kosu)\nif kosu == 1:\n    print(1)\n    return\nif vec[0] == vec[A - 1]:\n    ans = 0\n    for i in range(A,B + 1):\n        if vec[i - 1] != vec[0]:\n            break\n        ans += nCk(kosu,i)\n    print(ans)\nelse:\n    K = vec[:A].count(vec[A - 1])\n    print(nCk(kosu,K))", "from collections import Counter\nn,a,b=list(map(int,input().split()))\nv=list(map(int,input().split()))\nv.sort(reverse=True)\nsu=sum(v[:a])\navg=su/a\ntot=0\ninside=0\nc=[ [0]*51 for _ in range(51)]\nfor i in range(n+1):\n    for j in range(i+1):\n        if j==0 or j==i:\n            c[i][j]=1\n        else:\n            c[i][j]=c[i-1][j]+c[i-1][j-1]\nfor i in range(n):\n    if v[i]==v[a-1]:\n        tot+=1\n        if i<a:\n            inside+=1\ncnt=0\nif inside==a:\n    for i in range(a,b+1):\n        cnt+=c[tot][i]\nelse:\n    cnt+=c[tot][inside]\nprint(avg)\nprint(cnt)\n\n        \n\n\n", "def ncr(n,r):\n    g = 1\n    for i in range(1,r+1):\n        g*=(n-r+i)\n        g//=i\n    return g\nn,a,b= map(int,input().split())\nnv = sorted(list(map(int,input().split())),reverse=True)\nprint(sum(nv[:a])/a)\nndica = {}\nndicfull = {}\nconti = 0\nfnv=nv[0]\nfor i,temp in enumerate(nv):\n    if i<a:ndica[temp] = ndica.get(temp,0) + 1\n    ndicfull[temp] = ndicfull.get(temp,0) + 1\n    if temp==fnv:conti=i+1\nif fnv == nv[a-1]:\n    subb = min(conti,b)\n    g=0\n    for t in range(a,subb+1):g+=ncr(conti,t)\n    print(g)\nelse:\n    if ndicfull[nv[a-1]]==1:print(1)\n    else:print(ncr(ndicfull[nv[a-1]],ndica[nv[a-1]]))", "comb_memo = {}\ndef comb(n, r):\n  nonlocal comb_memo\n  if (n, r) in comb_memo:\n    return comb_memo[(n, r)]\n  else:\n    r = min(r, n-r)\n    res = 1\n    for _ in range(r):\n      res *= n\n      n -= 1\n    for i in range(1, r+1):\n      res //= i\n    comb_memo[(n, r)] = res\n    comb_memo[(n, n-r)] = res\n    return res\n\nN, A, B = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\n\nmu = sum(v[:A]) / A\nans = 0\nif v[0] == mu:\n  R = v.count(v[0])\n  for i in range(A, B+1):\n    if i > R:\n      break\n    ans += comb(R, i)\nelse:\n  min_v = v[A-1]\n  n = v.count(min_v)\n  need = v[:A].count(min_v)\n  ans += comb(n, need)\n\nprint(mu)\nprint(ans)", "n,a,b=map(int,input().split())\nv=list(map(int,input().split()))\nfact=[1]\nfor i in range(1,51):\n    fact.append(i*fact[-1])\ndef cmb(n,r):\n    return fact[n]//(fact[n-r]*fact[r])\nv.sort(reverse=True)\nprint(sum(v[:a])/a)\ncntv,cntr=0,0\nfor i in range(n):\n    if i<a:\n        if v[i]==v[a-1]:\n            cntv+=1\n    else:\n        if v[i]==v[a-1]:\n            cntr+=1\n#print(cntv,cntr)\nif cntv<a:\n    print(cmb(cntv+cntr,cntv))\nelse:\n    ans=0\n    for r in range(a,min(b,cntv+cntr)+1):\n        ans+=cmb(cntv+cntr,r)\n        #print(ans)\n    print(ans)", "from math import factorial\n\nN, A, B = list(map(int, input().split()))\nV = [int(i) for i in input().split()]\nV.sort(reverse=True)\n\na = 0\nfor i in range(A):\n    a += V[i]\na /= A\nprint(a)\n\nc = 0\n\nif V[0] != V[A-1]:\n    r = 0\n    while True:\n        r += 1\n        if V[A-1-r] != V[A-1]:\n            break\n    n = 0\n    while True:\n        if A+n > N-1:\n            break\n        if V[A+n] != V[A-1]:\n            break\n        n += 1\n    n += r\n    c = round(factorial(n) / factorial(r) / factorial(n-r))\n\nelse:\n    n = 0\n    while True:\n        n += 1\n        if n > N-1:\n            break\n        if V[n] != V[0]:\n            break\n    B = min(B, n)\n    for i in range(B-A+1):\n        c += round(factorial(n) / factorial(A+i) / factorial(n-A-i))\n\nprint(c)\n", "import collections\nimport math\n\nN, A, B = list(map(int, input().split()))\nv = list(map(int, input().split()))\nd = list(reversed(sorted(v)))\nc = collections.Counter(v)\n\nstart = A\nend = A\nif c[d[0]] >= A:\n  end = min(c[d[0]], B)\n  \nans = 0\nans_com = 0\nfor i in range(start, end+1):\n  sel = i\n  com = 1\n  total = 0\n  for j in range(len(d)):\n    p = c[d[j]]\n    com *= math.factorial(p)\n    total += d[j] * p\n    if sel <= p:\n      com /= (math.factorial(sel) * math.factorial(p-sel))\n      total -= d[j] * (p - sel)\n      break\n    sel -= p\n  ave = total / i\n  ans = ave\n  ans_com += int(com)\nprint(ans)\nprint(ans_com)\n", "from collections import defaultdict\n\n# Combination\nMOD = 10**17+3\nMAX = 2*10**5\nfac = [1,1] + [0]*MAX\nfinv = [1,1] + [0]*MAX\ninv = [0,1] + [0]*MAX\nfor i in range(2,MAX+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse=True)\narr = V[:A]\nse = set()\nmi = 10**18\ndic2 = defaultdict(int)\ntot = 0\nfor a in arr:\n    tot += a\n    dic2[a] += 1\n    se.add(a)\n    if a < mi:\n        mi = a\ndic = defaultdict(int)\nfor v in V:\n    dic[v] += 1\nif len(se) == 1:\n    ans = 0\n    for i in range(A, B+1):\n        ans += comb(dic[mi], i)\nelse:\n    ans = comb(dic[mi], dic2[mi])\nprint((tot/A))\nprint(ans)\n", "from bisect import bisect_left, bisect_right\nfrom decimal import Decimal\nfrom scipy.special import comb\nn, a, b = map(int, input().split())\nv = list(map(lambda x:-int(x), input().split()))\nv.sort()\nli = [[None]*2 for _ in range(n+1)]\nfor k in range(a, b+1):\n    li[k][0] = -sum(v[:k])\n    li[k][1] = comb(bisect_right(v, v[k-1])-bisect_left(v, v[k-1]), k-bisect_left(v, v[k-1]), exact=True)\nans = [Decimal(0), 0]\nfor i in range(n+1):\n    if li[i][0] is None:\n        continue\n    tmp = Decimal(li[i][0]) / Decimal(i)\n    if ans[0]==tmp:\n        ans[1] += li[i][1]\n    elif ans[0]<tmp:\n        ans[0] = tmp\n        ans[1] = li[i][1]\nprint(ans[0])\nprint(ans[1])", "N,A,B=map(int,input().split())\nv=list(map(int,input().split()))\nv.sort(reverse=True)\na=v[:A]\nb=v[:B]\navg=sum(a)/A\nprint(avg)\nc=[[0]*51 for _ in range(51)]\nc[0][0]=1\nfor i in range(50):\n  c[i+1][0]=1\n  c[i+1][i+1]=1\n  for j in range(i):\n    c[i+1][j+1]=c[i][j]+c[i][j+1]\nif a[0]==a[-1]:\n  ans=0\n  x=v.count(a[0])\n  for i in range(A,B+1):\n    if i<=x:\n      ans+=c[x][i]\nelse:\n  x=v.count(a[-1])\n  y=a.count(a[-1])\n  ans=c[x][y]\nprint(ans)", "from math import factorial as f\ndef comb(n, k):\n  return f(n)//f(k)//f(n-k)\n\nn, a, b = map(int, input().split())\nV = sorted(map(int, input().split()))\ns = sum(V[-a:]) / a\nprint(s)\nsmall = V[-a]\ncnt = V[-a:].count(small)\ntotal = V.count(small)\nif V[-1] != small:\n  ans = comb(total, cnt)\nelse:\n  ans = 0\n  for i in range(a, min(b, total)+1):\n    ans += comb(total, i)\nprint(ans)", "import math\n\n\ndef check(m, A, V):\n    # whether we can get `m` for mean of values\n    cnt, x = 0, 0\n    for v in V[:A]:\n        x += v - m\n        cnt += 1\n    return x >= 0\n\n\ndef comb(n, k):\n    if k > n - k:\n        return comb(n, n - k)\n    return math.factorial(n) // math.factorial(k) // math.factorial(n - k)\n\n\ndef main():\n    N, A, B = list(map(int, input().split(' ')))\n    V = list(map(int, input().split(' ')))\n    V.sort(reverse=True)\n    # calculate max average value by binary search\n    eps = 10 ** (-15)\n    ok, ng = 0, 10 ** 16\n    while (ng - ok) / ng > eps:\n        mid = (ok + ng) / 2\n        if check(mid, A, V):\n            ok = mid\n        else:\n            ng = mid\n    ans_v = ok\n    # calculate pattern number\n    min_target_v = V[A - 1]\n    target_v_cnt = sum([1 if v == min_target_v else 0 for v in V])\n    selected_target_v_cnt = sum([1 if v == min_target_v else 0 for v in V[:A]])\n    ans_pattern = comb(target_v_cnt, selected_target_v_cnt)\n    if V[0] == min_target_v:  # V[0] == ... == V[A - 1]\n        # the average does not change if we add another item with min_target_v\n        for i in range(1, B - A + 1):\n            if target_v_cnt < selected_target_v_cnt + i:\n                break\n            ans_pattern += comb(target_v_cnt, selected_target_v_cnt + i)\n    # answer\n    print(ans_v)\n    print(ans_pattern)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nN,A,B=map(int,input().split())\na=sorted(list(map(int,input().split())),reverse=True)\ndic={}\nfor i in range(N):\n  v=a[i]\n  if v not in dic.keys():\n    dic[v]=1\n  else:\n    dic[v]+=1\ntmp=0\nnum_used={}\nm=10**18\nM=-1\nfor i in range(A):\n  v=a[i]\n  m=min(m,v)\n  M=max(M,v)\n  tmp+=v\n  if v not in num_used.keys():\n    num_used[v]=1\n  else:\n    num_used[v]+=1\nmax_ave=tmp/A\nprint(max_ave)\nif num_used[m]==dic[m]:\n  print(1)\nelif m==M:\n  x=dic[m]\n  y=num_used[m]\n  cnt=0\n  for i in range(y,min(x+1,B-A+y+1)):\n    cnt+=math.factorial(x)//math.factorial(i)//math.factorial(x-i)\n  print(cnt)\nelse:\n  x=dic[m]\n  y=num_used[m]\n  cnt=math.factorial(x)//math.factorial(y)//math.factorial(x-y)\n  print(cnt)", "from collections import Counter\n\n\ndef binomial_coefficient(n, r):\n    res = 1\n    for i in range(r):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\n\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse=True)\n\nC = Counter(V)\n\nave = sum(V[:A]) / A\nnum = V[A - 1]\nNnums = C[num]\n\nif num == V[0]:\n    B = min(B, Nnums)\n    cnt = 0\n    for i in range(A, B + 1):\n        cnt += binomial_coefficient(Nnums, i)\nelse:\n    for k, v in list(C.items()):\n        if k > num:\n            A -= v\n    cnt = binomial_coefficient(Nnums, A)\n\nprint(ave)\nprint(cnt)\n", "import sys\nfrom collections import Counter\n\ndef factorial(n):\n    fact = 1\n    for integer in range(1, n + 1):\n        fact *= integer\n    return fact\n\nN, A, B = map(int,input().split())\nV = list(map(int,input().split()))\n\nc1 = Counter(V)\n\nV.sort(reverse = True)\n\nif all([V[0] == i for i in V[:A]]):\n    print(V[0])\n    ans = 0\n    for i in range(A-1, B):\n        if V[i] != V[0]:\n            break\n        ans += factorial(c1[V[0]])//(factorial(c1[V[0]]-(i+1))*factorial(i+1))\n    print(ans)\n    return\n\nprint(sum(V[:A]) / A)\n\nc2 = Counter(V[:A])\n\nprint(factorial(c1[V[A-1]])//(factorial(c1[V[A-1]]-c2[V[A-1]])*factorial(c2[V[A-1]])))", "from math import factorial\n\nn,a,b = list(map(int,input().split()))\nv = list(map(int,input().split()))\n\nv.sort(reverse = True)\n\nans = sum(v[:a]) / a\nans2 = 0\n\ncount1 = v.count(v[a-1])\n\nindex1 = v.index(v[a-1])\n\ndef ncr(x,y):\n    return factorial(x) // factorial(y) // factorial(x-y)\n\nif v[0] == v[a-1]:\n    for i in range(a, min(b, count1) + 1):\n        ans2 += ncr(count1, i)\nelse:\n    ans2 = ncr(count1, a - index1)\n\nprint(ans)\nprint(ans2)\n", "#!python3\n\nLI = lambda: list(map(int, input().split()))\n\n# input\nN, A, B = LI()\nV = LI()\n\nMAX = 51\nfinv = [None] * MAX\n\n\ndef comb_init():\n    finv[0] = 1\n    for i in range(1, MAX):\n        finv[i] = finv[i - 1] * i\n\n\ndef comb(n, k):\n    return finv[n] // finv[k] // finv[n - k]\n\n\ndef main():\n    comb_init()\n    V.sort(reverse=True)\n    s = sum(V[:A])\n    mx = s // A if s % A == 0 else s / A\n    print(mx)\n    if A == N or V[A - 1] > V[A]:\n        print((1))\n        return\n    \n    x = V.count(V[A])\n    ans = 0\n    if mx == V[A]:\n        for i in range(A, B + 1):\n            ans += comb(x, i)\n    else:\n        y = V[:A].count(V[A])\n        ans = comb(x, y)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from operator import mul\nfrom functools import reduce\ndef sml_cmb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(mul, range(n, n - r, -1))\n    under = reduce(mul, range(1,r + 1))\n    return over // under\ndef main():\n    n, a, b = map(int, input().split())\n    v = list(map(int, input().split()))\n    v.sort()\n    ave = 0\n    for i in range(1, a+1):\n        ave += v[n-i]\n    ave /= a\n    l, r = -1, -1\n    target = v[n-a]\n    for i in range(n):\n        if v[i] == target:\n            l = i\n            break\n    for i in reversed(range(n)):\n        if v[i] == target:\n            r = i\n            break\n    cnt = r-l+1\n    high, low = min(cnt, r-(n-b)+1), r-(n-a)+1\n    ans = sml_cmb(cnt, low)\n    if v[n-a] == v[n-1]:\n        for i in range(low+1, high+1):\n            ans += sml_cmb(cnt, i)\n    print(ave)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "N, A, B = list(map(int, input().split()))\nv = list(map(int, input().split()))\nv = sorted(v,reverse=True)\n\n# (\u5408\u8a08, \u500b\u6570)\nmax_avg = (sum(v[:A]), A)\n\nt = v[A-1]\nnum1 = v[:A].count(t)\nnum2 = v[A:].count(t)\n\nfact = [0]*(N+1)\nifact = [0]*(N+1)\ninv = [0]*(N+1)\np=170141183460469231731687303715884105727\n\ndef combination(n,fact,ifact):\n    fact[0] = 1\n    fact[1] = 1\n    ifact[0] = 1\n    ifact[1] = 1\n    inv[1] = 1\n    for i in range(2,n+1):\n        fact[i] = (fact[i-1]*i)%p\n        inv[i] = p - inv[p%i]*(p//i)%p\n        ifact[i] = (ifact[i-1]*inv[i])%p\ndef op(n,k):\n    if k<0 or k>n or n<0:\n        return 0\n    return (fact[n]*ifact[k]*ifact[n-k])%p\n\ncombination(N,fact,ifact)\n\nres = int(op(num1+num2, num1))\nif v[0]==v[-1]:\n    res = 0\n    for i in range(A,B+1):\n        res += int(op(N, i))\nelif v[0] == v[B-1]:\n    res = 0\n    for i in range(A, B+1):\n        res += int(op(num1+num2,i))\nelif v[0] == v[A-1]:\n    res = 0\n    for i in range(A, min(B, A+num2)+1):\n        res += int(op(num1+num2, i))\nprint((max_avg[0]/max_avg[1]))\nprint(res)\n\n\n", "from collections import defaultdict\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    res = 1\n    for i in range(r):\n        res *= n\n        n -= 1\n    for i in range(1,r+1):\n        res //= i\n    return res\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse=True)\nmi = 10**18\ndic = defaultdict(int)\ndic2 = defaultdict(int)\ntot = 0\nfor i,a in enumerate(V):\n    if i < A:\n        tot += a\n        dic2[a] += 1\n        if a < mi:\n            mi = a\n    dic[a] += 1\nif len(dic2) == 1:\n    ans = 0\n    for i in range(A, B+1):\n        ans += comb(dic[mi], i)\nelse:\n    ans = comb(dic[mi], dic2[mi])\nprint((tot/A))\nprint(ans)\n", "def main():\n    from decimal import Decimal\n\n    N, A, B = list(map(int, input().split()))\n    *v, = list(map(Decimal, input().split()))\n\n    v.sort(reverse=True)\n\n    max_average = sum(v[:A]) / A\n\n    tail = v[A - 1]\n    contained = [0] * (N + 1)\n    s = 0\n    for i, x in enumerate(v, start=1):\n        if x == tail:\n            s += 1\n        contained[i] = s\n\n    def choose(n, a):\n        x, y = 1, 1\n        for i in range(a):\n            x = x * (n - i)\n            y = y * (i + 1)\n        return x // y\n\n    count = 0\n    for k in range(A, B + 1):\n        if (k > A) and (v[k - 1] != max_average): break\n        count += choose(contained[-1], contained[k])\n\n    print(max_average)\n    print(count)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "nCr = {}\ndef cmb(n, r):\n    if r == 0 or r == n: return 1\n    if r == 1: return n\n    if (n,r) in nCr: return nCr[(n,r)]\n    nCr[(n,r)] = cmb(n-1,r) + cmb(n-1,r-1)\n    return nCr[(n,r)]\n\nN,A,B = map(int,input().split())\nv = sorted(list(map(int,input().split())),reverse=True)\n\nif len(set(v)) == 1:\n    print(1)\n    print(1125899906842623)\n    return\n\nm = sum(v[:A])/A\nprint(m)\n\nif len(set(v[:A]))==1:\n    ans = 0\n    c = v.count(v[0])\n    for i in range(A,B+1):\n        if i <= c:\n            ans += cmb(c,i)\n    print(ans)\n    return\n\nmi = min(v[:A])\nn = v[:A].count(mi)\nm = v.count(mi)\nprint(cmb(m,n))", "def comb(n, r):\n    x, y = 1, 1\n    for i in range(n, n - r, -1):\n        x *= i\n        y *= i + r - n\n    return x // y\n\nn, a, b = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse = True)\nc = b - a + 1\ns = [0] * c\nfor i in range(c):\n    s[i] = sum(v[0 : a + i]) / (a + i)\nm = max(s)\nans = 0\nfor i in range(c):\n    if s[i] == m:\n        r = v[0 : a + i].count(v[a + i - 1])\n        l = v.count(v[a + i - 1])\n        ans += comb(l, min(r, l - r))\nprint(m)\nprint(ans)", "def main():\n    from decimal import Decimal\n\n    N, A, B = list(map(int, input().split()))\n    *v, = list(map(Decimal, input().split()))\n\n    v.sort(reverse=True)\n\n    max_average = sum(v[:A]) / A\n\n    tail = v[A - 1]\n    contained = [0] * (N + 1)\n    s = 0\n    for i, x in enumerate(v, start=1):\n        if x == tail:\n            s += 1\n        contained[i] = s\n\n    def choose(n, a):\n        if n - a < a:\n            return choose(n, n - a)\n        x, y = 1, 1\n        for i in range(a):\n            x = x * (n - i)\n            y = y * (i + 1)\n        return x // y\n\n    count = 0\n    for k in range(A, B + 1):\n        if (k > A) and (v[k - 1] != max_average): break\n        count += choose(contained[-1], contained[k])\n\n    print(max_average)\n    print(count)\n\n\ndef __starting_point():\n    main()\n\n# editorial\n# K\u500b\u9078\u3093\u3060\u3068\u304d\u306e\u54c1\u7269\u306e\u4fa1\u5024\u306e\u5e73\u5747\u306e\u6700\u5927\u5024\u3068\n# K+1\u500b\u500b\u9078\u3093\u3060\u3068\u304d\u306e\u54c1\u7269\u306e\u4fa1\u5024\u306e\u5e73\u5747\u306e\u6700\u5927\u5024\u306e\u5dee\u3092\u6bd4\u8f03\n\n# v[:A]\u306f\u4e00\u3064\u306e\u5024\u304b\u3089\u306a\u308b->\u5e73\u5747\u5024\u3092\u4e0b\u3052\u305a\u306b\u8981\u7d20\u3092\u8ffd\u52a0\u3067\u304d\u308b\u53ef\u80fd\u6027\n# v[:A]\u306f\u7570\u306a\u308b\u5024\u3092\u542b\u3080->\u7bc4\u56f2\u5916\u306e\u5024\u306f\u3088\u308a\u5c0f\u3055\u3044\u306e\u3067\u8981\u7d20\u3092\u8ffd\u52a0\u3067\u304d\u306a\u3044\n\n__starting_point()", "import itertools, bisect\nfrom fractions import Fraction\nfrom math import factorial\n\n\ndef comb(n, r):\n    return factorial(n) // (factorial(r) * factorial(n - r))\n\n\nN, A, B = list(map(int, input().split()))\nV = sorted(list(map(int, input().split())), reverse=True)\n\nAve = [Fraction(a, i) for i, a in enumerate(itertools.accumulate(V), 1)]\nmax_num = max(Ave[A - 1:B])\nmax_indices = [i for i, v in enumerate(Ave) if A <= i + 1 <= B and v == max_num]\n\nVm = [-v for v in V]\nC = 0\nfor ind in max_indices:\n    l = bisect.bisect_left(Vm, Vm[ind])\n    r = bisect.bisect_right(Vm, Vm[ind])\n    C += comb(r - l, ind - l + 1)\nprint((float(max_num)))\nprint(C)\n", "#coding: utf-8\nimport math\nimport heapq\nimport bisect\nimport numpy as np\nfrom collections import Counter, deque\n#from scipy.misc import comb\n\nN,A,B = map(int, input().split())\nv = sorted(list(map(int, input().split())), reverse=True)\n\nans = 0\nfor i in range(A,B+1):\n    ans = max(sum(v[:i])/i, ans)\n\ncnt = 0\nfor i in range(A,B+1):\n    if sum(v[:i])/i == ans:\n        n = v.count(v[i-1])\n        r = i-v.index(v[i-1])\n        cnt += math.factorial(n)//math.factorial(r)//math.factorial(n-r)\n\nprint(ans)\nprint(cnt)", "import math\ndef nCr(n,r):\n    return (math.factorial(n)//(math.factorial(r)*math.factorial(n-r)))\nN, A, B = list(map(int,input().split()))\nv = sorted(list(map(int,input().split())), reverse = True)\nprint((sum(v[:A])/A))\n\nt = v[A-1]\nm, u = 0, 0\nfor k in range(A):\n    if v[k] == t:\n        m += 1\nfor k in range(A,N):\n    if v[k] == t:\n        u += 1\nif m == A:\n    ans = 0\n    for k in range(A,min(A+u+1,B+1)):\n        ans += nCr(m+u,k)\n    print(ans)\nelse:\n    print((nCr(m+u,m)))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**6#float('inf')\n#mod = 10 ** 9 + 7 \nmod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\n#\u968e\u4e57#\nlim = 50\nfact = [1] * (lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n * fact[n-1]\n\ndef C(n, r):\n\treturn fact[n]//fact[n-r]//fact[r]\n\n\nN, A, B = MAP()\nv = sorted(LIST(), reverse=True)\nkey = v[A-1]\nprint(sum(v[:A])/A)\n\nv = v[::-1]\nn = bisect(v, key) - bisect_left(v, key)\nm = N - bisect(v, key)\n\n\nif m == 0:\n\tans = 0\n\tfor i in range(A, min(B-m, n)+1):\n\t\tans += C(n, i)\n\tprint(ans)\nelse:\n\tprint(C(n, A-m))", "from collections import Counter\ndef nCr(n, r):\n    t = 1\n    for i in range(n - r + 1, n + 1):\n        t *= i\n    for i in range(2, r + 1):\n        t //= i\n    return t\n\ndef main():\n    N, A, B = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n    VV = Counter(V)\n    m = 0\n    c = 0\n    for v in sorted(list(VV.keys()), reverse=True):\n        vc = VV[v]\n        if c + vc <= A:\n            m += v * vc\n            c += vc\n            continue\n        break\n    else:\n        print((m / c))\n        print((1))\n        return\n    min_c = A - c\n    max_c = min(B - c, vc)\n    m += v * min_c\n    c += min_c\n    print((m / c))\n    if m != c * v:\n        max_c = min_c\n    r = 0\n    for i in range(min_c, max_c + 1):\n        r += nCr(vc, i)\n    print(r)\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N,A,B = list(map(int,input().split()))\n    v = sorted(list(map(int,input().split())),reverse=True)\n    use = v[:A]\n    print((sum(use)/A))\n    fac = [0 for _ in range(N+1)]\n    fac[0],fac[1] = 1,1\n    \n    for i in range(2,N+1):\n        fac[i] = (fac[i-1]*i)\n\n    x = v.count(v[A-1])\n    y = use.count(use[A-1])\n    \n    if v[0] == v[A-1]:\n        ans = 0\n        for i in range(A,min(B,x)+1):\n            ans += fac[x]//(fac[i]*fac[x-i])\n        print(ans)\n    else:\n        ans = fac[x]//(fac[y]*fac[x-y])\n        print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\ndef comb(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nn,a,b=map(int,input().split())\nv=sorted(list(map(int,input().split())),reverse=1)\ntmp=sum(v[:a])\nans=(tmp,a)\nx=[a-1]\nfor i in range(a,b):\n    tmp+=v[i]\n    if ans[0]*(i+1)<=ans[1]*tmp:\n        if ans[0]*(i+1)==ans[1]*tmp:\n            x.append(i)\n        else:\n            x=[i]\nprint(ans[0]/ans[1])\nans=0\nfor i in x:\n    a,b=v.count(v[i]),v[i+1:].count(v[i])\n    ans+=comb(a,b)\nprint(ans)", "from collections import Counter\nfrom math import factorial\n\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nC = Counter(V)\nkeys = list(C.keys())\nkeys.sort(reverse=True)\n\nif C[keys[0]] >= A:\n    mean = keys[0]\n    var = 0\n    for i in range(A, min(B, C[keys[0]]) + 1):\n        var += factorial(C[keys[0]]) // factorial(i) // factorial(C[keys[0]] - i)\nelse:\n    cnt = 0\n    total = 0\n    var = 0\n    for v in keys:\n        if cnt + C[v] < A:\n            cnt += C[v]\n            total += v * C[v]\n        else:\n            total += v * (A - cnt)\n            mean = total / A\n            var += factorial(C[v]) // factorial((A - cnt)) // factorial(C[v] - (A - cnt))\n            break\n\nprint(mean)\nprint(var)\n", "from sys import stdin\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    N,A,B=map(int,readline().split())\n    v=list(map(int,readline().split()))\n    v.sort(reverse=True)\n\n    #average\n    average=sum(v[:A])/A\n\n    #combination\n    res=0\n    x=v[A-1]\n    x_count=v.count(x)\n    x_count_copy=x_count\n    if x==v[0]:\n        up=1\n        down=1\n        for i in range(1,A):\n            up*=x_count_copy\n            x_count_copy-=1\n            down*=i\n        if x_count>=B:\n            for i in range(A,B+1):\n                up*=x_count_copy\n                x_count_copy-=1\n                down*=i\n                res+=up//down\n        else:\n            for i in range(A,x_count+1):\n                up*=x_count_copy\n                x_count_copy-=1\n                down*=i\n                res+=up//down\n    else:\n        m=A\n        for i in range(A):\n            if v[i]>x:\n                m-=1\n            else:\n                break\n        up=1\n        down=1\n        for i in range(1,m+1):\n            up*=x_count_copy\n            x_count_copy-=1\n            down*=i\n        res=up//down\n\n    print(average)\n    print(res)\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nN, A, B = map(int, input().split())\nV = list(map(int, input().split()))\n\ndp = [-1] * (N + 1)\ndp[0] = 0\ncnt = [0] * (N + 1)\ncnt[0] = 1\n\nfor i in range(N):\n    for j in range(N, 0, -1):\n        if dp[j - 1] < 0:\n            continue\n        if dp[j] < dp[j - 1] + V[i]:\n            dp[j] = dp[j - 1] + V[i]\n            cnt[j] = cnt[j - 1]\n        elif dp[j] == dp[j - 1] + V[i]:\n            cnt[j] += cnt[j - 1]\n\nup = -1\nbtm = -1\ns = 0\n\nfor i in range(A, B + 1):\n    if dp[i] < 0:\n        continue\n    if up < 0:\n        up, btm = dp[i], i\n        s = cnt[i]\n    elif up * i < dp[i] * btm:\n        up, btm = dp[i], i\n        s = cnt[i]\n    elif up * i == dp[i] * btm:\n        s += cnt[i]\n\n\nprint(up / btm)\nprint(s)", "def d_maximum_average_sets():\n    from functools import reduce\n    N, A, B = [int(i) for i in input().split()]\n    V = sorted([int(i) for i in input().split()], reverse=True)\n\n    def combination(n, r):\n        numerator = reduce(lambda x, y: x * y, range(n, n - r, -1))\n        denominator = reduce(lambda x, y: x * y, range(1, r + 1))\n        return numerator // denominator\n\n    if V[0] == V[A - 1]:  # V \u306e\u4e0a\u4f4d A \u500b\u304c\u3059\u3079\u3066\u540c\u3058\u5024 (v_max \u3068\u304a\u304f)\n        # V \u3067\u5024\u304c v_max \u3067\u3042\u308b x \u500b\u304b\u3089 A \u500b\u4ee5\u4e0a B \u500b\u4ee5\u4e0b\u9078\u3076\n        x = V.count(V[0])\n        count = sum([combination(x, i) for i in range(A, B + 1)])\n    else:\n        # \u4e0a\u4f4d A \u500b\u306e\u3046\u3061\u6700\u3082\u5024\u304c\u5c0f\u3055\u306a\u8981\u7d20\u306e\u5024\u3092 v_min \u3068\u304a\u304d\u3001\n        # v_min \u304c\u4e0a\u4f4d A \u500b\u306e\u3046\u3061 a \u500b\u3042\u3063\u305f\u3068\u3059\u308b\u3002\n        # V \u3067\u5024\u304c v_min \u3067\u3042\u308b x \u500b\u304b\u3089 a \u500b\u9078\u3076\u3002\n        v_min = V[A-1]\n        x, a = V.count(v_min), V[:A].count(v_min)\n        count = combination(x, a)\n    return '{}\\n{}'.format(sum(V[:A]) / A, count)\n\nprint(d_maximum_average_sets())", "import collections\nfrom operator import mul\nfrom functools import reduce\n\nN,A,B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nVV = sorted(V,reverse = True)\nave = 0\nml = []\n\nfor i in range(A,B + 1):\n  avet = sum(VV[:i]) / i\n  if avet >= ave:\n    ml.append(i)\n    ave = max(ave,avet)\n  else:\n    break\n\ndic = collections.Counter(V)\n#print(dic,ml)\n\ndef cmb(n,r):\n  r = min(n - r,r)\n  if r == 0:\n    return 1\n  over = reduce(mul,list(range(n, n - r, -1)))\n  under = reduce(mul,list(range(1,r + 1)))\n  return over // under\n\nres = 0\n\nfor j in ml:\n  r = dic[VV[j - 1]]\n  rr = VV.index(VV[j - 1])\n  res += cmb(r,j - rr)\n\nprint(ave)\nprint(res)\n", "N,A,B=map(int, input().split())\nD=list(map(int, input().split()))\nD=sorted(D)[::-1]\nimport math\nfrom math import comb\nprint(sum(D[:A])/A)\nans=0\nif D[0]!=D[A-1]:\n  n=D.count(D[A-1])\n  k=D[:A].count(D[A-1])\n  print(comb(n,k))\nelse:\n  ans=0\n  n=D.count(D[A-1])\n  for i in range(A,min(n,B)+1):\n    ans+=comb(n,i)\n  print(ans)", "N, A, B = list(map(int, input().split()))\nv = list(map(int, input().split()))\nv.sort()\n\nAAA = sum(v[N-A:])/A\nprint(AAA)\n\np = 0\nimport math\nfor i in range(A,B+1):\n    ans = v[N-i:]\n    if sum(ans)/i == AAA:\n        rest = v[:N-i]\n        m = ans.count(ans[0])\n        n = rest.count(ans[0])\n        C = math.factorial(n+m)//(math.factorial(m)*math.factorial(n))\n        p += C\n\nprint(p)\n", "def main():\n    N,A,B=list(map(int,input().split()))\n    v=list(map(int,input().split()))\n    v.sort(reverse=True)\n    Amxv=sum(v[:A])\n    c=v[A-1]\n    m=v[:A].count(c) \n    n=v.count(c)\n    fl=[1]*(N+1)\n    for i in range(N):\n        fl[i+1]=fl[i]*(i+1)\n    print((Amxv/A))\n    if v[0]-c==0:\n        print((sum([fl[n]//(fl[i]*fl[n-i]) for i in range(A,min(B,n)+1)])))\n    else:\n        print((fl[n]//(fl[m]*fl[n-m])))\n\ndef __starting_point():\n    main()\n    \n\n__starting_point()", "n, a, b = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\n\ncount = {}\nfor x in v:\n    if x in count:\n        count[x] += 1\n    else:\n        count[x] = 1\n\nfact = [1] * 51\nfor i in range(1, 51):\n    fact[i] = fact[i-1] * i\n\ndef comb(a, b):\n    return fact[a] // fact[a-b] // fact[b]\n\nans = 0\nif v[0] == v[a-1]:\n    b = min(b, count[v[0]])\n    for i in range(a, b+1):\n        ans += comb(count[v[0]], i)\n    print(v[0])\n    print(ans)\nelse:\n    c = v[:a].count(v[a-1])\n    print(sum(v[:a]) / a)\n    print(comb(count[v[a-1]], c))", "class cmbs(object):\n    def __init__(self, mod=9007199254740997):\n        self.mod = mod\n        self.g1 = [1, 1]\n        self.g2 = [1, 1]\n        inverse = [0, 1]\n        for i in range(2, 10 ** 2 + 1):\n            self.g1.append((self.g1[-1] * i) % mod)\n            inverse.append((-inverse[mod % i] * (mod // i)) % mod)\n            self.g2.append((self.g2[-1] * inverse[-1]) % mod)\n\n    def cmb(self, n, r):\n        if n > 10 ** 6:\n            return self.cmbl(n, r)\n        return self.cmbr(n, r)\n\n    def cmbr(self, n, r):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return self.g1[n] * self.g2[r] * self.g2[n-r] % self.mod\n\ndef main():\n    N, A, B = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    v.sort(reverse=True)\n    m = sum(v[:A])/A\n    print(m)\n    if v.count(v[A-1]) == N:\n        c = cmbs()\n        a = 0\n        for i in range(A, B+1):\n            a += c.cmb(N, i)\n        print(a)\n    elif v[0] == v[A-1]:\n        c = cmbs()\n        a = 0\n        for i in range(A, min(v.count(v[A-1]), B) + 1):\n            a += c.cmb(v.count(v[A-1]), i)\n        print(a)\n    elif v.count(v[A-1]) == 1:\n        print((1))\n    else:\n        c = cmbs()\n        r = A - v.index(v[A-1])\n        print((c.cmb(v.count(v[A-1]), r)))\nmain()\n", "N,A,B=map(int,input().split())\nv=list(map(int,input().split()))\nv.sort(reverse=1)\ns=sum(v[:A])\nprint(s/A)\nfrom math import factorial\nt=v[A-1]\np,q=0,0\nfor i in v:\n    if i>t:\n        p+=1\n    elif i==t:\n        q+=1\na=0\ndef c(n,k):\n    return (factorial(n)//factorial(k)//factorial(n-k))\nfor i in range(A,B+1):\n    if p+q>=i:\n        a+=c(q,i-p)\n    if t!=v[0]:\n        break\nprint(a)", "from math import comb\nmod = 10 ** 9 + 7\nn, a, b = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\nprint(sum(v[:a]) / a)\nif v[0] != v[a - 1]:\n    cur = v[a - 1]\n    cnt = 0\n    for i in range(n):\n        if cur == v[i]:\n            cnt += 1\n    cnt2 = 0\n    for i in range(a):\n        if cur == v[i]:\n            cnt2 += 1\n    print(comb(cnt, cnt2))\nelse:\n    cur = v[a - 1]\n    cnt = 0\n    for i in range(n):\n        if cur == v[i]:\n            cnt += 1\n    ans = 0\n    for i in range(a, b + 1):\n        ans += comb(cnt, i)\n    print(ans)", "N, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse = True)\n\ntotal = sum(V[:A])\n\nave = total / A\n\ntmp = V[A - 1]\n\ncount = V.count(tmp)\n\ndef combination(n, r): #nCr\u3092\u6c42\u3081\u308b\n    if n - r > r:\n        r = n - r\n    tmp = 1\n    for i in range(n - r + 1, n + 1):\n        tmp *= i\n    for i in range(1, r + 1):\n        tmp //= i\n    return tmp\n\n\n\n\n\nif V[0] == V[A - 1]: #\u4e0a\u304b\u3089A\u500b\u304c\u540c\u3058\n    ans = 0\n    for i in range(A, min(B, count) + 1):\n        ans += combination(count, i)\n\nelse: #A\u500b\u3061\u3087\u3046\u3069\u53d6\u308b\u306e\u304c\u3044\u3044\u3068\u304d\n    count2 = V[:A].count(tmp)\n    ans = combination(count, count2)\n\nprint (ave)\nprint (ans)\n", "import statistics\nimport math\n\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nn,a,b = list(map(int,input().strip().split()))\nv = list(map(int,input().strip().split()))\nv.sort(reverse=True)\n\nresult = 0\nmean_min = statistics.mean(v[0:a])\nfor i in range(a,b+1):\n  st_mean = statistics.mean(v[0:i])\n  if mean_min == st_mean:\n    v_n = v.count(v[a])\n    v_r = v[0:i].count(v[a])\n    result += combinations_count(v_n,v_r)\n  else:\n    break\nprint(mean_min)\nprint(result)", "from collections import Counter\n\ndef comb(n,r):\n    if n<r: return 0\n    comb = 1\n    r = min(r,n-r)\n    for i in range(r):\n        comb = comb * (n-i) // (i+1)\n    return comb\n\n\nn,a,b = map(int,input().split())\nv = list(map(int,input().split()))\n\nv.sort(reverse=True)\n\nva_count = Counter(v[:a])\nv_count  = Counter(v)\n\nprint(sum(v[:a])/a)\n\nif v[0] == v[a-1]:\n    print(sum(comb(v_count[v[0]],i ) for i in range(a,b+1)))\nelse:\n    print(comb(v_count[v[a-1]], va_count[v[a-1]]))", "n,a,b=map(int,input().split())\nv=list(map(int,input().split()))\nv.sort()\nmax_mean=sum(v[-a:])/a\nprint(max_mean)\nfrom collections import Counter\ncva=Counter(v[-a:])\ncv=Counter(v)\nimport math\ndef ncr(n, r):\n  return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n# \u9078\u3093\u3060a\u500b\u304c\u5168\u3066\u540c\u3058\u5024\u306a\u3089\nif v[-a]==max_mean:\n  ans=0\n  for k in range(a,min(b,cv[v[-a]])+1):\n    ans+=ncr(cv[v[-a]],k)\n  print(ans)\nelse:\n  # a\u306e\u4e2d\u3067\u4e00\u756a\u5c0f\u3055\u306a\u6570\u5b57\u306f\u4f55\u500b\u3042\u308b\u304b\u3002\n  k0=cva[v[-a]]\n  k1=cv[v[-a]]\n  ans=ncr(k1,k0)\n  print(ans)", "import sys\nfrom collections import Counter\nfrom itertools import product\nfrom random import randint\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef debug(n, a, b, V, ave):\n    cnt = 0\n    for pattern in product([0, 1], repeat=n):\n        if a <= sum(pattern) <= b:\n            tot = 0\n            for idx, p in enumerate(pattern):\n                if p == 1:\n                    tot += V[idx]\n            res = tot / sum(pattern)\n            if abs(res - ave) <= 10 ** -6:\n                cnt += 1\n    return cnt\n\n\ndef resolve():\n    n, a, b = list(map(int, input().split()))\n    V = list(map(int, input().split()))\n\n    V.sort(reverse=True)\n    ave = 0\n    for i in range(a, b + 1):\n        tot = sum(V[:i])\n        if ave <= tot / i:\n            ave = tot / i\n            used = V[:i]\n\n    if len(set(used)) == 1:\n        cnt = V.count(used[0])\n        ave = used[0]\n        cmb = [0] * len(used)\n        for i in range(a, len(used) + 1):\n            x = y = 1\n            for j in range(1, i + 1):\n                x *= (cnt + 1 - j)\n                y *= j\n            cmb[i - 1] = x // y\n        res = sum(cmb)\n    else:\n        use_cnt = Counter(used)\n        used = set(used)\n        D = Counter(V)\n        res = 1\n        for num in used:\n            cnt = use_cnt[num]\n            x = y = 1\n            for j in range(1, cnt + 1):\n                x *= (D[num] + 1 - j)\n                y *= j\n            res *= x // y\n    print(ave)\n    print(res)\n    # print(debug(n, a, b, V, ave))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import Counter\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse=True)\n\nS = sum(V[:A])\ncnt = A\nmx = S / cnt\nL = [cnt]\n\nfor v in V[A:]:\n    if cnt == B:\n        break\n    cnt += 1\n    S += v\n    if mx < S / cnt:\n        mx = S / cnt\n        L = []\n    if mx == S / cnt:\n        L.append(cnt)\n\ndef ncr(n, r):\n    ret = 1\n    for i in range(r):\n        ret *= (n - i)\n    for i in range(1, r + 1):\n        ret //= i\n    return ret\n\nprint(mx)\nans = 0\ncntV = Counter(V)\nfor c in L:\n    cnt = Counter(V[:c])\n    prd = 1\n    for x, c in list(cnt.items()):\n        prd *= ncr(cntV[x], c)\n    ans += prd\nprint(ans)\n", "n,a,b = list(map(int,input().split()))\nV = list(map(int,input().split()))\n\nV.sort(reverse = True)\ns = 0\nm = V[a-1]\nans = sum(V[:a])/a\nprint(ans)\ncnt = V.count(m)\nleft = V.index(m)\nans = 0\nmemo = {}\ndef combi(m,k):\n    if m*100+k in memo:\n        return memo[m*100+k]\n    elif k == 0:\n        return 1\n    else:\n        memo[m*100+k] = combi(m,k-1)*(m-k+1)//k\n        return memo[m*100+k]\n\nif left == 0:\n    for i in range(a,min(b,cnt)+1):\n        ans += combi(cnt,i)\nelse:\n    ans += combi(cnt,a-left)\n    # if (sum(V[:a])/a).is_integer():\n    #     ans *= pow(2,V.count(int(V[:a]/a)))\nprint(ans)\n", "#mAx average set\nn,a,b=map(int,input().split())\nlists=list(map(int,input().split()))\nlists=sorted(lists)\nP=sum(lists[-a:])\nprint(P/a)\n#B\u3053\u3068\u3063\u3066\u7dcf\u548c\u304cmini\u306b\u306a\u3063\u3066\u3044\u308b\nfrom collections import Counter\nJ=dict(Counter(lists))\nK=dict(Counter(lists[-a:]))\nimport math\nans=1\nsums=0\nif J[max(lists)]<a:\n    for some in K.keys():\n        ans*=(math.factorial(J[some])//((math.factorial(K[some]))*math.factorial(J[some]-K[some])))\n    print(ans)\nelif J[max(lists)]>a:\n    for i in range(a,min(b,J[max(lists)])+1):\n        sums+=math.factorial(J[max(lists)])//(math.factorial(J[max(lists)]-i)*math.factorial(i))\n    print(sums)\nelse:\n    print(1)", "from collections import Counter\nfrom math import prod\n\nN,A,B=map(int,input().split())\nv=list(map(int,input().split()))\n\nfactorial=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i\n\ndef comb(n,k):\n    return factorial[n]*pow(factorial[n-k]*factorial[k], -1)\n  \nv = sorted(v,reverse=True)\n  \nif len(set(v[:A]))==1:\n  print(v[0])\n  ans=0\n  for i in range(A,B+1):\n    if i > 1 and v[i-1] != v[i-2]:break\n    ans += comb(Counter(v)[v[0]],i)\n  print(int(ans))\n  return\n\nprint(sum(v[:A])/A)\n\nc = Counter(v)\nthr = v[A-1]\n\nif c[thr] == 1 or v[A-1] != v[A]:\n  res=[]\n  for k in c.keys():\n    if k >= thr:\n      res.append(c[k])\n    \n  print(prod(res))\n  return\n  \nres=[]\nfor k in c.keys():\n  if k > thr:\n    res.append(c[k])\n\nans=prod(res)\n\nidx = v[:A].index(v[A-1])-1\n\nprint(int(ans*comb(c[v[A-1]],A-1-idx)))", "import math\n\nN,A,B = list(map(int,input().split()))\nv = list(map(int,input().split()))\n\nv.sort(reverse = True)\ntotal = 0\n\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nfor i in range(A):\n    total = total + v[i]\nelse:\n    print((total / A))\n    \ncount = 0\nmin = v[A-1]\nnumber = v.count(min)\n\nif(v.index(min) == 0):\n    for i in range(A,number+1):\n        if(i>B):\n            break\n        count = combinations_count(number,i) + count\n    print(count)\nelse:\n    print((combinations_count(number,A - v.index(min))))\n", "f_memo = {0:1, 1:1}\ndef f(x):\n  nonlocal f_memo\n  if x in f_memo:\n    return f_memo[x]\n  else:\n    res = x * f(x-1)\n    f_memo[x] = res\n    return res\n\ncomb_memo = {}\ndef comb(n, r):\n  nonlocal comb_memo\n  if (n, r) in comb_memo:\n    return comb_memo[(n, r)]\n  else:\n    a = f(n)\n    b = f(n-r)\n    c = f(r)\n    res = a // b // c\n    comb_memo[(n, r)] = res\n    return res\n\n\nN, A, B = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\n\nmu = sum(v[:A]) / A\nR = A-1\nfor i in range(A, N):\n  if v[i] == mu:\n    R = i\n  else:\n    break\n\nR += 1\nans = 0\nif R > A:\n  for i in range(A, B+1):\n    if i > R:\n      break\n    ans += comb(R, i)\nelse:\n  min_v = v[A-1]\n  n = v.count(min_v)\n  need = v[:A].count(min_v)\n  ans += comb(n, need)\n\nprint(mu)\nprint(ans)", "from math import factorial\ndef comb(n,r):\n  if n-r<0:\n    return 0\n  return factorial(n)//(factorial(r)*factorial(n-r))\nn,a,b=map(int,input().split())\nv=list(map(int,input().split()))\nmod=10**9+7\nv.sort(reverse=True)\nx=v[a-1]\ncnt=0\ns=0\nfor i in range(n):\n  if x==v[i]:\n    cnt+=1\n  if x<v[i]:\n    s=i+1\nans=0\nprint(sum(v[:a])/a)\nif v[0]==v[a-1]:\n  for i in range(a,min(cnt+1,b+1)):\n    ans+=comb(cnt,i)\n  print(ans)\nelse:\n  ans=comb(cnt,a-s)\n  print(ans)", "from math import factorial as f\n\ndef comb(n, r):\n  return f(n) // (f(r) * f(n-r))\n\nn, a, b = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nv.sort(reverse=True)\n\nprint((sum(v[:a])/a))\n\nans = 0\ncnt0 = v.count(v[0])\n\nif cnt0 >= a:\n  for i in range(a, min(cnt0, b)+1):\n    ans += comb(cnt0, i)\nelse:\n  c = v[a-1]\n  cnt1 = 0\n  cnt2 = 0\n  for i, vi in enumerate(v):\n    if vi != c:\n      continue\n    if i < a:\n      cnt1 += 1\n    cnt2 += 1\n  ans = comb(cnt2, cnt1)\n\nprint(ans)\n", "from collections import Counter\nfrom math import factorial\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\n\nV.sort(reverse=True)\nc = Counter(V)\n\nans = []\nL = []\nfor i in range(A, B + 1):\n\n    ans.append(sum(V[0:i]) / i)\nmax_ans = max(ans)\nprint(('{:.6f}'.format(max_ans)))\n\nnum = 0\nfor j in range(B - A + 1):\n    tmp = 1\n    if ans[j] == max_ans:\n        k = V[:A + j]\n        cnt_k = Counter(k)\n        for key, value in list(cnt_k.items()):\n            tmp *= factorial(c[key]\n                             ) // factorial(value) // factorial(c[key] - value)\n        num += tmp\n\nprint(num)\n", "nCr = {}\ndef cmb(n, r):\n    if r == 0 or r == n: return 1\n    if r == 1: return n\n    if (n,r) in nCr: return nCr[(n,r)]\n    nCr[(n,r)] = cmb(n-1,r) + cmb(n-1,r-1)\n    return nCr[(n,r)]\n\nN,A,B = map(int,input().split())\nv = sorted(list(map(int,input().split())),reverse=True)\n\n\"\"\"\nif len(set(v)) == 1:\n    print(1)\n    print(1125899906842623)\n    return\n\"\"\"\n\nm = sum(v[:A])/A\nprint(m)\n\nif len(set(v[:A]))==1:\n    ans = 0\n    c = v.count(v[0])\n    for i in range(A,B+1):\n        if i <= c:\n            ans += cmb(c,i)\n    print(ans)\n    return\n\nmi = min(v[:A])\nn = v[:A].count(mi)\nm = v.count(mi)\nprint(cmb(m,n))", "N,A,B = [int(i) for i in input().split()]\nv = [int(i) for i in input().split()]\nv.sort()\nv.reverse()\ncum = [v[0]]\n\ndef comb(n, k):\n    if k>n:\n        return 0\n    ans = 1\n    for i in range(k):\n        ans *= n-i\n    for j in range(k):\n        ans = ans//(j+1)\n    return ans\n\nfor i in range(1,N):\n    cum += [cum[i-1] + v[i]]\nprint(('{:.10f}'.format(cum[A-1]/A)))\ntarget = v[A-1]\nn = v.count(target)\nfromk = (A-1) - v.index(target) + 1\nif v[0] == target:\n    ans = 0\n    for i in range(A, min(B,n)+1):\n        ans += comb(n, i)\n    print(ans)\nelse:\n    #print((n, fromk))\n    ans = comb(n, fromk)\n    print(ans)\n", "n,a,b=map(int,input().split())\nV=list(map(int,input().split()))\nV.sort(reverse=True)\nA=V[:a]\nB=V[:b]\nave=sum(A)/a\nprint(ave)\nC=[[0]*51 for _ in range(51)]\nC[0][0]=1\nfor i in range(50):\n    C[i+1][0]=1\n    C[i+1][i+1]=1\n    for j in range(i):\n        C[i+1][j+1]=C[i][j]+C[i][j+1]\nif A[0]==A[-1]:\n    ans=0\n    x=V.count(A[0])\n    for i in range(a,b+1):\n        if i<=x:\n        \tans+=C[x][i]\nelse:\n    x=V.count(A[-1])\n    y=A.count(A[-1])\n    ans=C[x][y]\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    \n    dp = [[0, 0] for _ in range(n+1)]\n    dp[0][1] = 1\n    for i in range(n):\n        for j in range(n-1, -1, -1):\n            if dp[j][1]:\n                if dp[j+1][0] < dp[j][0]+v[i]:\n                    dp[j+1][0] = dp[j][0]+v[i]\n                    dp[j+1][1] = dp[j][1]\n                elif dp[j+1][0] == dp[j][0]+v[i]:\n                    dp[j+1][1] += dp[j][1]\n    \n    index, value, count = a, dp[a][0], dp[a][1]\n    for i in range(a+1, b+1):\n        if value*i == index*dp[i][0]:\n            count += dp[i][1]\n        elif value*i < index*dp[i][0]:\n            value = dp[i][0]\n            index = i\n            count = dp[i][1]\n                \n    print((value/index))\n    print(count)\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "def comb(a,b):\n    import math\n    return math.factorial(a)//(math.factorial(a-b)*math.factorial(b))\n\nfrom itertools import accumulate\nN,A,B = map(int,input().split())\nv = list(map(int,input().split()))\nv.sort(reverse=1)\nva = v[:A]\nmaxa = sum(va)/A\nmaxsum = sum(va)\nprint(maxa)\ncount = 1\nif va[0] == va[-1]:\n    v0 = va[0]\n    v0c = v.count(v0)\n    ans = comb(v0c,A)\n    for i in range(A,B):\n        if v[i] == v0:\n            ans += comb(v0c,i+1)\n    print(ans)\nelse:\n    v1 = va[-1]\n    v1c = va.count(v1)\n    v1c2 = v.count(v1)\n    print(comb(v1c2,v1c))", "import sys\nreadline = sys.stdin.readline\n\nN,A,B = list(map(int,readline().split()))\nV = list(map(int,readline().split()))\n\n# \u5927\u304d\u3044\u307b\u3046\u304b\u3089A\u500b\u9078\u3093\u3060\u3068\u304d\u306e\u5e73\u5747\u5024\u304c\u6c42\u3081\u308b\u5e73\u5747\u5024\n# \u5927\u304d\u3044\u307b\u3046\u304b\u3089A\u4f4d\u306e\u6570\u5b57\u3092P\u3068\u3059\u308b\u3068\u3001\n# \u30fbA\u4f4d\u307e\u3067\u306e\u6570\u5b57\u304c\u3059\u3079\u3066P\u306e\u3068\u304d\uff1aP\u306e\u500b\u6570\u304b\u3089\u3001A\uff5eB\u500b\u9078\u3076\u5834\u5408\u306e\u6570\n# \u30fb\u305d\u3046\u3067\u306a\u3044\u3068\u304d\uff1aP\u306e\u500b\u6570\u304b\u3089\u3001A\u4f4d\u307e\u3067\u306b\u5fc5\u8981\u306aP\u306e\u500b\u6570\u3092\u9078\u3076\u5834\u5408\u306e\u6570\n\nV = sorted(V, reverse = True)\n\nprint((sum(V[:A]) / A))\n\nfrom scipy.special import comb\n\nP = V[A - 1]\npcnt = V.count(P)\n\nif V[0] == P:\n  ans = 0\n  for i in range(A, B + 1):\n    ans += comb(pcnt, i, exact = True)\n  print(ans)\nelse:\n  pneed = (V[:A]).count(P)\n  print((comb(pcnt, pneed, exact = True)))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**6#float('inf')\n#mod = 10 ** 9 + 7 \nmod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\n#\u968e\u4e57#\nlim = 50\nfact = [1] * (lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n * fact[n-1]\n\ndef C(n, r):\n\treturn fact[n]//fact[n-r]//fact[r]\n\n\nN, A, B = MAP()\nv = sorted(LIST(), reverse=True)\n\nV_cnt = Counter(v)\nV_max = Counter(v[:A])\nkey = v[A-1]\nprint(sum(v[:A])/A)\n\nv = v[::-1]\n\nidx_1 = bisect_left(v, key)\nidx_2 = bisect(v, key)\nn = idx_2 - idx_1\nk = bisect(v, key)\nm = N - k\n\n\nif m == 0:\n\tans = 0\n\tfor i in range(A, min(B-m, n)+1):\n\t\tans += C(n, i)\n\tprint(ans)\nelse:\n\tprint(C(n, A-m))", "def comb(n, r):\n    if n < r:\n        return 0\n\n    ret = 1\n    for i in range(1, r + 1):\n        ret = ret * (n - i + 1) // i\n\n    return ret\n\n\nn, a, b = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nv.sort(reverse=True)\nave = sum(v[:a]) / a\n\nif v[0] == v[a-1]:\n    sm = v.count(v[0])\n    cnt = 0\n    for i in range(a, b + 1):\n        cnt += comb(sm, i)\n\nelse:\n    last = v[a-1]\n    select = v[:a].count(last)\n    sm = v.count(last)\n    cnt = comb(sm, select)\n\nprint(ave)\nprint(cnt)\n", "n,a,b =map(int, input().split())\nal = list(map(int, input().split()))\nnewal = sorted(al,reverse = True)\nave = 0\nml = []\nfor i in range(a,b+1):\n    avet = sum(newal[:i])/i\n    if avet >= ave:\n        ml.append(i)\n        ave = max(ave,avet)\nprint(ave)\n\nimport collections\nc = collections.Counter(al)\n\nfrom operator import mul\nfrom functools import reduce\n\ndef cmb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(mul, range(n, n - r, -1))\n    under = reduce(mul, range(1,r + 1))\n    return over // under\n\nres = 0\nfor j in ml:\n    r = c[newal[j-1]]\n    rr = newal.index(newal[j-1])\n    res += cmb(r,j-rr)\nprint(res)", "from functools import lru_cache\n\n@lru_cache\ndef comb(n, k):\n    if k == 0:\n        return 1\n    elif n == k:\n        return 1\n    else:\n        return comb(n-1, k) + comb(n-1, k-1)\n\nN, A, B = map(int, input().split())\nvs = sorted(map(int, input().split()), reverse = True)\n\nprint(sum(vs[:A]) / A)\nv_replaceable = vs[A]\n\nn = vs.count(v_replaceable)\na = A - vs.index(v_replaceable)\nb = min(n, B - vs.index(v_replaceable))\n\nif vs[0] == v_replaceable:\n    #n\u500b\u304b\u3089a~b\u500b\u3092\u9078\u3076\u9078\u3073\u65b9\u304c\u7b54\u3048\u3002\n    print(sum(comb(n, t) for t in range(a, b+1)))\nelse:\n    #n\u500b\u304b\u3089a\u500b\u3092\u9078\u3076\u9078\u3073\u65b9\u304c\u7b54\u3048\u3002\n    print(comb(n, a))", "n,a,b=map(int,input().split())\n\nfrom decimal import Decimal as de\nl=sorted(list(map(int,input().split())),reverse=1)\nfact=[1]\nfor i in range(1,51):\n    fact.append(fact[-1]*i)\nfrom collections import Counter as co\nif l[0]==l[a-1]:\n    def comb(x,y):\n        return fact[x]//(fact[y]*fact[x-y]) if x>=y>=0 else 0\n    x=co(l)[l[0]]\n    print(l[0])\n    print(sum(comb(x,i)for i in range(a,b+1)));return\nave=de(str(sum(l[:a])))/a\nprint(ave)\n\ny=co(l[:a])[l[a-1]]\nx=co(l)[l[a-1]]\nprint(fact[x]//(fact[y]*fact[x-y]))", "#!/usr/bin/env python3\n\nfrom copy import deepcopy\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0] = [0, 1]\n    for j in range(n):\n        dppre = deepcopy(dp)\n        for i in range(n):  # \u914d\u308b\n            vnew = dppre[i][0] + v[j]\n            ways = dppre[i][1]\n            if vnew > dp[i + 1][0]:\n                dp[i + 1] = [vnew, ways]\n            elif vnew == dp[i + 1][0]:\n                dp[i + 1][1] += ways\n\n    maxave = 0.0\n    for i in range(a, b + 1):\n        maxave = max(maxave, dp[i][0] / i)\n    ways = 0\n    for i in range(a, b + 1):\n        if dp[i][0] / i == maxave:\n            ways += dp[i][1]\n    print(maxave)\n    print(ways)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,A,B=map(int,input().split())\nvlist=list(map(int,input().split()))\nvlist.sort(reverse=True)\n\ndp=[[0]*(N+1) for _ in range(N+1)]\n\nfor i in range(1,N+1):\n  for j in range(1,N+1):\n    dp[i][j]=dp[i-1][j]\n    dp[i][j]=max(dp[i][j],dp[i-1][j-1]+vlist[i-1])\n\nmax_value_avg=0\nfor j in range(A,B+1):\n  #print(j,dp[-1][j])\n  value_avg=dp[-1][j]/j\n  max_value_avg=max(max_value_avg,value_avg)\n  \nmax_avg_size=[]\nfor j in range(A,B+1):\n  value_avg=dp[-1][j]/j\n  if value_avg==max_value_avg:\n    max_avg_size.append(j)\n#print(max_avg_size)    \n\ndef comb(n,r):\n  r=min(r,n-r)\n  nPr=1\n  fact_r=1\n  for i in range(r):\n    nPr*=n-i\n    fact_r*=r-i\n  return nPr//fact_r\n\nanswer=0\nfor m in max_avg_size:\n  border=vlist[m-1]\n  n1=n2=n3=0\n  for v in vlist:\n    if v>border:\n      n1+=1\n    elif v==border:\n      n2+=1\n    else:\n      n3+=1\n  answer+=comb(n2,m-n1)\n\nprint(max_value_avg)\nprint(answer)", "from collections import Counter\n\nN, A, B = list(map(int, input().split()))\nV = list(map(int, input().split()))\nV.sort(reverse=True)\n\nS = sum(V[:A])\ncnt = A\nmx = S / cnt\nL = [cnt]\n\nfor v in V[A:]:\n    if cnt == B:\n        break\n    cnt += 1\n    S += v\n    if mx < S / cnt:\n        mx = S / cnt\n        L = []\n    if mx == S / cnt:\n        L.append(cnt)\n\ndef ncr(n, r):\n    ret = 1\n    for i in range(r):\n        ret *= (n - i)\n    for i in range(1, r + 1):\n        ret //= i\n    return ret\n\nprint(mx)\nans = 0\ncntV = Counter(V)\nfor c in L:\n    cnt = Counter(V[:c])\n    prd = 1\n    for x, c in list(cnt.items()):\n        prd *= ncr(cntV[x], c)\n    ans += prd\nprint(ans)\n", "# coding: utf-8\nimport sys\nimport numpy as np\nfrom math import factorial\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, A, B = lr()\nV = np.array(lr())\nV.sort()\nave = V[-A:].sum() / A\nprint(ave)\nborder = V[-A]\nleft_i = np.searchsorted(V, border, side='left')\nright_i = np.searchsorted(V, border, side='right')\nseg = right_i - left_i  # \u4f7f\u3048\u308b\u6570\u5b57\u305f\u3061\ndone = N - right_i\nuse = A - done  # \u4f7f\u3046\u5e45\n\ndef combinations_count(n, r):  # \u7d44\u307f\u5408\u308f\u305b\n    return factorial(n) // factorial(n - r) // factorial(r)\n\nanswer = combinations_count(seg, use)\nif border == ave:\n    for x in range(use+1, min(B-done, seg)+1):\n        answer += combinations_count(seg, x)\n\nprint(answer)\n# 05\n", "INF = 10 ** 7\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000000)\ndy = (-1,0,1,0)\ndx = (0,1,0,-1)\nfrom  heapq import heappop,heapify,heappush\n\nfac = [1,1]\nfor i in range(2,51):\n    fac.append(fac[-1] * i)\n\ndef nck(n,k):\n    return fac[n]//fac[n - k]//fac[k]\n\ndef main():\n    n,a,b = list(map(int,input().split()))\n    v = list(map(int,input().split()))\n\n    v.sort(reverse=True)\n    tot = sum(v[:a])\n    cnt = a\n\n    ok = 0\n    change = 0\n    for i in range(a,n):\n        if v[i] * cnt == tot:\n            ok += 1\n        elif v[i] == v[a - 1]:\n            change += 1\n    \n    same = 1\n    for i in range(a - 2,-1,-1):\n        if v[i] == v[a - 1]:\n            same += 1\n    \n    ans = 0\n    if ok > 0:\n        for i in range(same,b - a + same + 1):\n            ans += nck(same + ok,i)\n    elif change > 0:\n        ans += nck(same + change,same)\n    else:\n        ans += 1\n\n    print((tot/cnt))\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom collections import Counter\n\nN, A, B = map(int, input().split())\nv = list(map(int, input().split()))\n\nv.sort(reverse = True)\ncnt_v = Counter(v)\nave = []\n\nfor i in range(A, B+1):\n    ave.append(sum(v[0:i]) / i)\n\nmax_ave = max(ave)\nans = 0\n\nfor j in range(B-A+1):\n    temp = 1\n    if ave[j] == max_ave:\n        l = v[:A+j]\n        cnt_l = Counter(l)\n        for key, values in cnt_l.items():\n            temp *= (math.factorial(cnt_v[key]) // math.factorial(values) // math.factorial(cnt_v[key] - values))\n        ans += temp\n\nprint(max_ave)\nprint(ans)", "#!/usr/bin/env python3\nimport sys\ntry:\n    from typing import List\nexcept ImportError:\n    pass\n\n\ndef comb(n: int, r: int):\n    if r > n - r:\n        return comb(n, n - r)\n    p = q = 1\n    for i in range(r):\n        p *= n - i\n        q *= i + 1\n    return p // q\n\n\ndef solve(N: int, A: int, B: int, v: \"List[int]\"):\n    v.sort(reverse=True)\n    sl = v[:A]\n    print((sum(sl) / A))\n    if len(set(sl)) == 1:\n        m = sl[0]\n        cm = v.count(m)\n        ans = 0\n        for z in range(A, min(cm, B) + 1):\n            ans += comb(cm, z)\n        print(ans)\n    else:\n        m = sl[-1]\n        cm = v.count(m)\n        print((comb(cm, sl.count(m))))\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    v = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, A, B, v)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,A,B = map(int,input().split())\nV = sorted(list(map(int,input().split())))[::-1]\nW = sum(V[:A])/A\nprint(W)\n\nf = [1]\nfor n in range(50):\n  f+=[f[-1]*(n+1)]\nx = V.count(V[A-1])\nif V[0]==V[A-1]:\n  print(sum(f[x]//(f[x-n]*f[n]) for n in range(A,B+1)))\nelse:\n  y=V[:A].count(V[A-1])\n  print(f[x]//(f[x-y]*f[y]))", "from collections import Counter\nfrom math import factorial\ndef comb(n, k):\n    return factorial(n) // (factorial(k) * factorial(n-k))\nn, a, b = list(map(int, input().split()))\nv = list(map(int, input().split()))\nv.sort(reverse=True)\ncnt = Counter(v)\nprint((sum(v[:a]) / a))\n\nif v[0] == v[a-1]:\n    x = cnt[v[0]]\n    ans = 0\n    for i in range(a, min(x, b)+1):\n        ans += comb(x, i)\n\n    print(ans)\n\nelse:\n    x = cnt[v[a-1]]\n    for i in range(a):\n        if v[i] == v[a-1]:\n            y = i\n            break\n\n    print((comb(x, a-y)))\n", "import math\nn, a, b = map(int, input().split())\nv = list(map(int, input().split()))\nv.sort(reverse=True)\nc = 0\ndef comb(N, R):\n\tif N < R:\n\t\treturn 0\n\treturn math.factorial(N) // (math.factorial(N - R) * math.factorial(R))\nif len(set(v[:a])) == 1:\n\tx = v[:a][0]\n\td = 0\n\tfor i in v:\n\t\tif i == x:\n\t\t\td += 1\n\tfor i in range(a,min(d+1,b+1)):\n\t\tc += comb(d,i)\n\tprint (x)\n\tprint (c)\nelse:\n\tx = v[:a][0]\n\ty = sorted(v[:a])\n\tav = sum(v[:a])/a\n\tz = y[0]\n\td = 0\n\tfor i in v:\n\t\tif i == z:\n\t\t\td += 1\n\te = 0\n\tfor i in y:\n\t\tif i == z:\n\t\t\te += 1\n\tc = comb(d,e)\n\tprint (av)\n\tprint (c)", "from math import factorial\nfrom collections import Counter\n\ndef cmb(n,r):\n    return factorial(n)//(factorial(n-r)*factorial(r))\n\nN,A,B=map(int,input().split())\nv=list(map(int,input().split()))\nv.sort(reverse=True)\nl=Counter(v)\n\navg=0\ncnt=0\nfor i in range(A,B+1):\n    tmp=sum(v[:i])/i\n    if tmp>avg:\n        avg=tmp\n        cnt=cmb(l[v[A-1]],v[:i].count(v[i-1]))\n    elif tmp==avg:\n        cnt+=cmb(l[v[A-1]],v[:i].count(v[i-1]))\nprint(avg)\nprint(cnt)", "n, a, b = map(int, input().split())\nV = list(map(int, input().split()))\nV.sort(reverse=True)\n\nimport math\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\nans = 0\nx = 0\ny = 0\nfor i in range(n):\n    if i <= a-1:\n        ans += V[i]\n        if V[i] == V[a-1]:\n            x += 1\n            y += 1\n    else:\n        if V[i] == V[a-1]:\n            x += 1\n\nif V[0] != V[a-1]:\n    cnt = combinations_count(x, y)\n    print(ans/a)\n    print(cnt)\nelse:\n    cnt = 0\n    for i in range(a, b+1):\n        if i <= x:\n            cnt += combinations_count(x, i)\n    print(ans/a)\n    print(cnt)", "N, A,B,*V = map(int,open(0).read().split())\nV = sorted(V)[::-1]\nans1 = sum(V[:A])/A\nprint(ans1)\nf = [1] *51\nfor i in range(1,51):\n  f[i] = f[i - 1] * i\ndef comb(n,r):\n  return f[n]//f[r]//f[n-r]\nans2 = comb(V.count(V[A-1]),V[:A].count(V[A-1]))\nif V[0] == V[A-1]:\n  for i in range(A+1,B+1):\n    ans2 += comb(V.count(V[A-1]),i)\nprint(ans2)", "def ncr(n, r):\n  if n < r:\n    return 0\n  res = 1\n  for i in range(1, n + 1):\n    res *= i\n  for i in range(1, r + 1):\n    res //= i\n  for i in range(1, n - r + 1):\n    res //= i\n  return res\nn, a, b = list(map(int, input().split()))\nv = sorted(list(map(int, input().split())), reverse=True)\nprint((sum(v[0:a]) / a))\nif v[0] == v[a - 1]:\n  c = v.count(v[0])\n  ans = 0\n  for i in range(a, b + 1):\n    ans += ncr(c, i)\n  print(ans)\nelse:\n  k = v.count(v[a - 1])\n  r = v[0:a].count(v[a - 1])\n  print((ncr(k, r)))\n", "import itertools,collections\nimport math\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\ndef main():\n    n,a,b=list(map(int, input().split()))\n    v=[int(i) for i in input().split()]\n    v.sort(reverse = True)\n    tmp = v[0:a]\n    dd = collections.defaultdict(int)\n\n    for i in v:\n        dd[i]+=1\n\n    cnt = 0\n  \n    k = 0\n    for i in tmp:\n        k+=i\n    s = min(tmp)\n    avg = k/len(tmp)\n    if(tmp[0]!=s):\n        howmany = v.count(s)\n        nantoori = tmp.count(s)\n        #howmany\u500b\u304b\u3089nantoori\u500b\u9078\u3076\u65b9\u6cd5\n        res = howmany\n\n        for i in range(nantoori-1):\n            res *= (howmany-i+1)\n        res2 = 1\n        for i in range(nantoori):\n            res2 *= (i+1)\n        print(avg)\n        print((combinations_count(howmany,nantoori)))\n    else:\n        howmany = dd[s]\n        res=0\n        for i in range(a,min(b+1,howmany+1)):\n            res += combinations_count(howmany, i)\n\n\n        print(avg)\n        print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,A,B=map(int,input().split())\nvlist=list(map(int,input().split()))\n#vlist.sort(reverse=True)\n\ndp=[[(-1,-1)]*(N+1) for _ in range(N+1)]\ndp[0][0]=(0,1)\n\nfor i in range(1,N+1):\n  dp[i][0]=(0,1)\n  for j in range(1,i+1):\n    dp[i][j]=dp[i-1][j]\n    if dp[i-1][j-1][0]+vlist[i-1]>dp[i][j][0]:\n      dp[i][j]=(dp[i-1][j-1][0]+vlist[i-1],dp[i-1][j-1][1])\n    elif dp[i-1][j-1][0]+vlist[i-1]==dp[i][j][0]:\n      dp[i][j]=(dp[i][j][0],dp[i][j][1]+dp[i-1][j-1][1])\n#print(dp)\n\nmax_value_avg=0\nfor j in range(A,B+1):\n  #print(j,dp[N][j])\n  value_avg=dp[N][j][0]/j\n  max_value_avg=max(max_value_avg,value_avg)\n\nanswer=0\nfor j in range(A,B+1):\n  value_avg=dp[N][j][0]/j\n  if value_avg==max_value_avg:\n    answer+=dp[N][j][1]\n  \nprint(max_value_avg)\nprint(answer)", "import math\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nN,A,B= (int(x) for x in input().split())\nv = list(map(int, input().strip().split()))\nv.sort(reverse=True)\nprint((sum(v[0:A])/A))\nctall = 0\nct = 0\nfor i in range (A):\n    if v[i] == v[A-1]:\n        ct += 1\nanswer = 0\nfor i in range (N):\n    if v[i] == v[A-1]:\n        ctall += 1\n    if v[i] < v[A-1]:\n        break\nif (ct == A):\n    for i in range(A,min(ctall+1,B+1)):\n        answer += combinations_count(ctall, i)\n    print(answer)\nelse: print((combinations_count(ctall, ct)))\n", "N,A,B=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl.sort(reverse=True)\nall_n=l.count(l[0])\nfrom scipy.special import comb\nfrom collections import Counter\nl2=l[0:A]\nl_c=Counter(l)\nmax_mean=sum(l2)/A\nl2=Counter(l2).items()\nprint(max_mean)\nans=1\nif l[0]==l[A-1]:\n   ans=0\n   for i in range(A,B+1):\n      ans+=comb(all_n,i,exact=True)\n   print(ans)\n   return\nfor i,j in l2:\n   ans*=comb(l_c[i],j,exact=True)\nprint(ans)", "from collections import Counter\nimport math\nn,a,b = map(int,input().split())\nv = sorted(list(map(int,input().split())))[::-1]\nl = Counter(v)\nsu = 0\nko = 0\n\ndef C(a,b):\n  return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))\nfor i in range(a,b+1):\n  v1 = v[:i]\n  s = sum(v1)/i\n  if su<s:\n    su = s\n    ko = C(l[v[a]],v1.count(v1[-1]))\n  elif su==s:\n    ko += C(l[v[a]],v1.count(v1[-1]))\n # print(s,ko)\nprint(su)\nprint(ko)", "from scipy.special import comb\nans=0\nN,A,B=map(int,input().split())\nL=list(map(int,input().split()))\n#A\u3053\u306e\u5e73\u5747\u3067\u3088\u3044\nL=sorted(L,reverse=True)\nif len(set(L))==1:\n  print(L[0])\n  for i in range(A,B+1):\n    ans+= comb(N, i, exact=True)\n  print(ans)\n  return\nprint(sum(L[:A])/A)\nR=list(L[:A])\nc=L[A-1]\nif len(set(R))==1:\n  n=L.count(c)\n  for i in range(A,min(n,B)+1):\n    ans+= comb(n, i, exact=True)\n  print(ans)\n  return\na=L.count(c)\nb=R.count(c)\nprint(comb(a,b,exact=True))", "import sys\nimport math\n\ndef comb(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\nn,a,b = map(int,input().split())\nv_list = list(map(int,input().split()))\n\nv_list.sort(reverse=True)\nmax_mean = sum(v_list[:a])/a\n\nnumber = v_list[a-1]\n\nif v_list[:a].count(number) == a:\n    count = 0\n    for i in range(a,b+1):\n        rest_list = v_list[i:]\n        all_num = v_list.count(number)\n        rest_num = rest_list.count(number)\n        if rest_num > 0 or v_list[i-1] == number:\n            count += comb(all_num,rest_num)\n    print(max_mean)\n    print(count)\nelse:\n    rest_list = v_list[a:]\n    all_num = v_list.count(number)\n    rest_num = rest_list.count(number)\n    print(max_mean)\n    print(comb(all_num,rest_num))", "\nN, A, B = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nv = sorted(v)[::-1]\n\nv_ref = sum(v[:A])# / A\n\ni = A\n## n = 1\nn_min = A\nn_max = B\nwhile (i<B):\n    ## v_new = (i*v_ref + v[i]) / (i+1)\n    v_new = v_ref + v[i]\n    ## if v_new < v_ref:\n    if i*v_new < (i+1)*v_ref:\n        n_max = i\n        break\n    ## if v_new > v_ref:\n    if i*v_new > (i+1)*v_ref:\n        n_min = i+1\n    v_ref = v_new\n    i+=1\n\ndef comb(n, k):\n    r = 1\n    for x,y in zip(list(range(n,n-k,-1)), list(range(1,k+1))):\n        r = r * x\n        assert r % y == 0\n        r = r // y\n    return r\n\nresult = 0\nfor n in range(n_min, n_max+1):\n    v_min = min(v[:n])\n    num_min = sum([v_ == v_min for v_ in v])\n    num_fixed = sum([v_ > v_min for v_ in v[:n]])\n    num_selected = n - num_fixed\n    result += comb(num_min, num_selected)\n\nv_max_avg = sum(v[:n_min]) / n_min\n\nprint(f\"{v_max_avg:.6f}\")\nprint(result)\n"]
import sys
input = sys.stdin.readline


def I(): return int(input())
def MI(): return list(map(int, input().split()))
def LI(): return list(map(int, input().split()))


"""
結局のところ，袋から出し終えた時点で勝敗はついている．
袋から出す段階でもgrundyの議論ができそう
あー，でもgが非0のところからg=0に遷移できるとは限らないね．

Nが奇数なら
先手:g=0を目指す
後手:g≠0を目指す

Nが偶数なら
先手:g≠0を目指す
後手:g=0を目指す

非0を目指す方が楽そう．最後の方で適当にやれば良いし，
自分の手番では大きいものからとっていき一箇所にまとめて行く．これで半分以上を取れるので，ちょうど半々になった時のみg=0
なので，g=0が作れるケースを考える．

Nの偶奇や先手/後手にかかわらず，最後の袋を使ってg=0を目指す．
これ，できる？
1手分だけ遡って考える．x0,x1,,,xk 個並んでいるとして，袋は2個残っている．
この状態でどんな手を打っても次の手でg=0にされる，という状況はある？
→ g=0で，かつ，残りの袋がどちらも同じ個数の時はそうか．
N=偶数で，Aiが全部同じなら後手がg=0を作れるね．

補題:互いに最善手で，g≠0の時に，相手→自分の順でg=0を作れることがあるか?
→不可かな...微妙．

上で書いたケース以外ないかも?
全然詰められてないので嘘臭いが投げてみるか...
→WA

詰めよう．

N=奇数なら後手必勝ぽい？
後手の行動:大きい袋からとっていき，初手でおかれた皿に置き続ける
詳細:これをやられたら絶対に過半数を超える．過半数を超えられたくないので先手の人も大きい順位取るけど，それでもAの奇数番目が全て同じ皿に入ってしまう．A1を除いた分でさえ，偶数番目の総和以上になるので，A1も入れると絶対過半数を超える

N=偶数で，後手がg=0を作れるケースを考えようか．
奇数の時と同じ様に考えられそう?先手側はとにかく大きいのからとっていき一箇所にまとめる．
→2個セットになっているか，でg=0が作れるか判定できそう


"""


def main():
    mod = 10**9 + 7

    T = I()
    for _ in range(T):
        N = I()
        A = LI()

        if N % 2 == 1:
            print("Second")
        else:
            flag = 1
            from collections import defaultdict
            dd = defaultdict(int)

            for i in range(N):
                dd[A[i]] += 1

            for k, v in list(dd.items()):
                if v % 2:
                    flag = 0
                    break

            if flag == 1:
                print("Second")
            else:
                print("First")


main()

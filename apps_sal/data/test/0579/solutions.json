["import numpy as np\n\ndef __starting_point():\n\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\n\t# print(P)\n\t# \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u30b5\u30a4\u30af\u30eb\u60c5\u5831\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u3066\u304a\u304f\u305f\u3081\u306e\u914d\u5217\n\tcycleIDs = np.full( N, -1, np.int64 )\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\n\tfor n in range(N):\n\t\tv = n\n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\t# \u5168\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5c5e\u3059\u308b\u30b5\u30a4\u30af\u30eb\u3092\u8a08\u7b97\u3059\u308b\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\t# \u30b5\u30a4\u30af\u30eb\u7d42\u4e86\n\t\t\t\t\t# \u30eb\u30fc\u30d7\u3092\u542b\u3081\u306a\u3044\u6700\u5927\u306e\u51e6\u7406\u56de\u6570\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\t# \u305d\u308c\u3067\u8db3\u308a\u3066\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u304c\u3001Last2\u5468\u5206\u306f\u3001\u30eb\u30fc\u30d7\u3059\u308b\u3082\u306e\u3068\u3057\u3066\u78ba\u5b9a\u3055\u305b\u306a\u3044\n\t\t\t\t\t# \u305d\u306e\u90e8\u5206\u306f\u3001\u3061\u3083\u3093\u3068\u8a08\u7b97\u3059\u308b\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# 4 101\n\t\t\t\t\t# 2 3 4 1\n\t\t\t\t\t# 50 -49 -50 50\n\t\t\t\t\t# \u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u3001\n\t\t\t\t\t# \u6700\u592725\u56de\u30eb\u30fc\u30d7 + 1\u56de\u51e6\u7406\u53ef\u80fd\u3060\u304c\u3001\u305d\u306e\u5834\u5408\u300125 + 50 = 75\n\t\t\t\t\t# 24\u56de\u30eb\u30fc\u30d7 + 2\u56de\u51e6\u7406\u3067\u3084\u3081\u308b\u3068\u3001124\u306b\u306a\u308b\n\t\t\t\t\t# \u7121\u6761\u4ef6\u3067\u30eb\u30fc\u30d7\u3059\u308b\u56de\u6570\u306f\u3001\u6700\u5927\u306e\u56de\u6570\u3060\u3051\u3067\u306a\u304f\u3001\n\t\t\t\t\t# \u6700\u5927\u306e\u56de\u6570-1\u3082\u8003\u616e\u306e\u5fc5\u8981\u3042\u308a\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# \u3042\u308b\u3044\u306f\u3001\u5272\u308a\u5207\u308c\u3066\u3001\u5c1a\u4e14\u3064\u30b5\u30a4\u30af\u30eb\u5408\u8a08\u304c\u30de\u30a4\u30ca\u30b9\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u3001\u6700\u4f4e\uff11\u500b\u306f\u51e6\u7406\u3059\u308b\u306e\u306b\u3082\u3053\u3053\u3067\u5bfe\u5fdc\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), np.array( currentCycleCosts + currentCycleCosts ) ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\n\n\n\t# scores = []\n\t# procCnt = 0\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n\t\t# \u30b5\u30a4\u30af\u30eb\u5185\u3067\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u3050\u5834\u5408\u306e\u8003\u616e\n\t\tloopScore = 0\n\t\tfullMinus1CntLoopScore = 0\n\t\tif np.sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * np.sum(currentCycleCosts[:currentCycleSize])\n\t\t\t# print(\"loopScore\",loopScore,procCnt)\n\n\t\t# \u3053\u306e\u30b5\u30a4\u30af\u30eb\u306b\u5c5e\u3059\u308b\u5168\u9802\u70b9\u5206\u3092\u307e\u3068\u3081\u3066\u8a08\u7b97\u3059\u308b\n\t\tfor i in range(currentCycleSize):\n\t\t\t# scores.append( np.roll( currentCycleCosts, i )[:procCnt].cumsum().max() + loopScore )\n\t\t\t# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n\t\t\tans = max( ans, np.roll( currentCycleCosts, i ).cumsum()[:procCnt].max() + loopScore )\n\n\n\tprint(ans)\n\t# print(max(scores))\n\n__starting_point()", "import numpy as np\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    p = [int(i) - 1 for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    seen = set()\n    loop_list = []\n    for start in range(n):\n        v = start\n        loop = []\n        while v not in seen:\n            seen.add(v)\n            loop.append(c[v])\n            v = p[v]\n        seen.add(v)\n        if loop:\n            loop_list.append(np.array(loop))\n\n    ans = min(c)\n    for loop in loop_list:\n        loop_len = len(loop)\n        loop_num = k // loop_len\n        loop_mod = k % loop_len\n        loop_sum = sum(loop)\n        table = np.zeros((loop_len, loop_len), dtype=int)\n        table[0] = loop.cumsum()\n        table[:, -1] = loop_sum\n        for i in range(loop_len - 1):\n            table[i + 1, :-1] = (table[i] - loop[i])[1:]\n        ans = max(table[:, :min(loop_len, k)].max(), ans)\n        if loop_num > 0:\n            ans = max(loop_sum * (loop_num - 1) + table[:, :loop_len].max(), ans)\n            if loop_mod > 0:\n                ans = max(loop_sum * loop_num + table[:, :loop_mod].max(), ans)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n, k = nm()\n    p = nl()\n    _c = nl()\n    c = [0]*n\n    for i in range(n):\n        p[i] -= 1\n        c[i] = _c[p[i]]\n    m = 31\n    MIN = - (1 << 63)\n    vertex = list()\n    score = list()\n    vertex.append(p)\n    score.append(c)\n    for a in range(1, m+1):\n        p_ath = [0] * n\n        c_ath = [0] * n\n        for i in range(n):\n            p_ath[i] = vertex[a-1][vertex[a-1][i]]\n            c_ath[i] = score[a-1][i] + score[a-1][vertex[a-1][i]]\n        vertex.append(p_ath)\n        score.append(c_ath)\n    \n    prv = [[MIN, 0] for _ in range(n)]\n    nxt = [[MIN, MIN] for _ in range(n)] \n    for b in range(m, -1, -1):\n        for i in range(n):\n            if (k >> b) & 1:\n                nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n                nxt[vertex[b][i]][1] = max(nxt[vertex[b][i]][1], prv[i][1] + score[b][i])\n                nxt[i][0] = max(nxt[i][0], prv[i][0], prv[i][1])\n            else:\n                nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n                nxt[i][0] = max(nxt[i][0], prv[i][0])\n                nxt[i][1] = max(nxt[i][1], prv[i][1])\n        prv, nxt = nxt, prv\n    ans = max(max(x) for x in prv)\n    if ans == 0:\n        ans = max(c)\n    print(ans)    \n    return\n\nsolve()", "n, k = map(int, input().split())\np = list(map(int, input().split()))\n_c = list(map(int, input().split()))\nc = [0]*n\nfor i in range(n):\n    p[i] -= 1\n    c[i] = _c[p[i]]\nm = 31\nMIN = - (1 << 63)\nvertex = list()\nscore = list()\nvertex.append(p)\nscore.append(c)\nfor a in range(1, m+1):\n    p_ath = [0] * n\n    c_ath = [0] * n\n    for i in range(n):\n        p_ath[i] = vertex[a-1][vertex[a-1][i]]\n        c_ath[i] = score[a-1][i] + score[a-1][vertex[a-1][i]]\n    vertex.append(p_ath)\n    score.append(c_ath)\n    \nprv = [[MIN, 0] for _ in range(n)]\nnxt = [[MIN, MIN] for _ in range(n)] \nfor b in range(m, -1, -1):\n    for i in range(n):\n        if (k >> b) & 1:\n            nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n            nxt[vertex[b][i]][1] = max(nxt[vertex[b][i]][1], prv[i][1] + score[b][i])\n            nxt[i][0] = max(nxt[i][0], prv[i][0], prv[i][1])\n        else:\n            nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n            nxt[i][0] = max(nxt[i][0], prv[i][0])\n            nxt[i][1] = max(nxt[i][1], prv[i][1])\n    prv, nxt = nxt, prv\nans = max(max(x) for x in prv)\nif ans == 0:\n    ans = max(c)\nprint(ans)", "# Date [ 2020-08-15 21:53:58 ]\n# Problem [ d.py ]\n# Author Koki_tkg\n\nimport sys;      from decimal import Decimal\nimport math;     from itertools import combinations, product, accumulate\nimport bisect;   from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 6 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef lcm(a: int, b: int) -> int: return (a * b) // math.gcd(a, b)\n\ndef Main():\n    n, k = read_ints()\n    p = read_int_list()\n    c = read_int_list()\n    loop_list = []\n    visit = [False] * n\n\n    # \u9589\u8def\u3092\u63a2\u3057\u3066loop_list\u306b\u683c\u7d0d\n    for i in range(n):\n        if visit[i]:\n            continue\n\n        visit[i] = True\n        now = i\n        loop_tmp = []\n\n        while True:\n            now = p[now] - 1\n            visit[now] = True\n            loop_tmp.append(c[now])\n            if visit[p[now] - 1]:\n                loop_tmp.append(c[p[now] - 1])\n                break\n        loop_list.append(loop_tmp)\n\n    #print(loop_list)\n    ans = -10 ** 18\n\n    #loop\u3054\u3068\u306b\u5168\u90e8\u8a66\u3059\n    for loop in loop_list:\n        length = len(loop)\n        score = sum(loop)\n        if k > length:\n            if score > 0:\n                ans = max(ans, (k // length) * score + search_max_score(loop, k % length, length), (k // length - 1) * score + search_max_score(loop, length, length))\n            else:\n                ans = max(ans, search_max_score(loop, length, length))\n        else:\n            ans = max(ans, search_max_score(loop, k, length))\n    \n    print(ans)\n\n\ndef search_max_score(loop, rest, length):\n    if rest == 0:\n        ans = 0\n    elif rest == 1:\n        ans = max(loop)\n    else:\n        ans = -10**18\n        loop += loop\n        for i in range(length):\n            tmp = list(accumulate(loop[i:i + rest]))\n            #print(tmp)\n            ans = max(ans, max(tmp))\n    \n    return ans\n\nif __name__ ==  '__main__':\n    Main()", "import numpy as np\n\n\ndef parse():\n    _, k = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    pc = {i: (pi - 1, ci) for i, (pi, ci) in enumerate(zip(p, c))}\n    return k, pc\n\n\ndef read_split():\n    k, pc = parse()\n    lst = [[]]\n    lst[0].append(pc.pop(0))\n    while True:\n        if not pc:\n            break\n        p, _ = lst[-1][-1]\n        if p in pc:\n            pcj = pc.pop(p)\n            lst[-1].append(pcj)\n        else:\n            j = next(iter(list(pc.keys())))\n            pcj = pc.pop(j)\n            lst.append([pcj])\n    return k, [np.array([ls[1] for ls in lst_], dtype=np.long) for lst_ in lst]\n\n\ndef inner(n, k, s, sim):\n    if sim.shape[1] == 1:\n        return sim.max()\n    if k < n or s <= 0:\n        return sim.max()\n    div = k // n\n    mod = k % n\n    if mod == 0:\n        return s * (div - 1) + sim.max()\n    else:\n        return s * div + sim[:, :mod].max()\n\n\ndef main():\n    k, data_set = read_split()\n    result = min([d.min() for d in data_set])\n    for data in data_set:\n        n = data.size\n        rep = np.repeat(data[None], 2, axis=0).flatten()\n        sim = np.array([np.cumsum(rep[i:i+min(k, n)]) for i in range(n)])\n        cand = inner(n, k, data.sum(), sim)\n        result = max(result, cand)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\n \nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n \ncycles, check = [], [False]*n\nfor pi in p:\n    if not check[pi-1]:\n        curr, cycle = pi, []\n        check[pi-1] = True\n        while pi != p[curr-1]:\n            check[curr-1] = True\n            cycle.append(c[curr-1])\n            curr = p[curr-1]\n        check[curr-1] = True\n        cycles.append(cycle + [c[curr-1]])\n \nscores = []\nfor cycle in (np.array(cycle) for cycle in cycles):\n    for i in range(cycle.size):\n        cum = np.roll(cycle, i).cumsum()\n        if cum[-1] > 0 and k > cycle.size:\n            scores.append(cum[-1]*(k//cycle.size-1) + np.concatenate([cum, cum[:k % cycle.size]+cum[-1]]).max())\n        else:\n            scores.append(cum[:min(k, cum.size)].max())\nprint(max(scores))", "import itertools\nN, K = [int(_) for _ in input().split()]\nP = [int(_) - 1 for _ in input().split()]\nC = [int(_) for _ in input().split()]\n\n\nclass SegmentTree():\n    def __init__(self, array, f, ti):\n        \"\"\"\n        Parameters\n        ----------\n        array : list\n            to construct segment tree from\n        f : func\n            binary operation of the monoid\n        ti : \n            identity element of the monoid\n        \"\"\"\n        self.f = f\n        self.ti = ti\n        self.n = n = 2**(len(array).bit_length())\n        self.dat = dat = [ti] * n + array + [ti] * (n - len(array))\n        for i in range(n - 1, 0, -1):  # build\n            dat[i] = f(dat[i << 1], dat[i << 1 | 1])\n\n    def update(self, p, v):  # set value at position p (0-indexed)\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = v\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_right(self, p, v):  # apply operator from the right side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(dat[p], v)\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_left(self, p, v):  # apply operator from the left side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(v, dat[p])\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def query(self, l, r):  # result on interval [l, r) (0-indexed)\n        f, ti, n, dat = self.f, self.ti, self.n, self.dat\n        vl = vr = ti\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                vl = f(vl, dat[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                vr = f(dat[r], vr)\n            l >>= 1\n            r >>= 1\n        return f(vl, vr)\n\n\nans = -10**20\nse = set()\nfor start in range(N):\n    if start in se:\n        continue\n    now = start\n    scores = []\n    while True:\n        if now in se:\n            break\n        se.add(now)\n        scores += [C[now]]\n        now = P[now]\n    cyclelen = len(scores)\n    cum = list(itertools.accumulate(scores * 3))\n    st = SegmentTree(cum, max, -10**20)\n    cycle, residue = divmod(K, cyclelen)\n    ans = max([ans] + [\n        st.query(start2 + 1, start2 + 1 + min(cyclelen, K)) - cum[start2]\n        for start2 in range(cyclelen)\n    ])\n    if cum[-1] > 0 and cycle > 0:\n        v = cum[-1] * cycle // 3 + max(\n            st.query(0, start2 + residue + 1) - cum[start2]\n            for start2 in range(cyclelen, 2 * cyclelen))\n        ans = max(ans, v)\nprint(ans)\n", "from itertools import accumulate\n\ndef main():\n  n,k=list(map(int,input().split()))\n  P=[int(x)-1 for x in input().split()]\n  C=[int(x) for x in input().split()]\n  F=[False]*n\n\n  a=-10**9\n  for i in range(n):\n    if F[i]:\n      continue\n\n    p,F[i],L=i,True,[C[i]]\n    while P[p]!=i:\n      p=P[p]\n      F[p]=True\n      L.append(C[p])\n    t,l=sum(L),len(L)\n    s=t*(k//l-1) if t>0 else 0\n\n    m,L=-10**9,L*3\n    u=k%l+l if t>0 else min(k,l)\n    for j in range(l):\n      m=max(m,max(accumulate(L[j:j+u])))\n\n    a=max(s+m,a)\n\n  print(a)\n\nmain()\n", "import numpy as np\n \nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n \ncycles, check = [], [False]*n\nfor pi in p:\n    if not check[pi-1]:\n        curr, cycle = pi, []\n        check[pi-1] = True\n        while pi != p[curr-1]:\n            check[curr-1] = True\n            cycle.append(c[curr-1])\n            curr = p[curr-1]\n        check[curr-1] = True\n        cycles.append(cycle + [c[curr-1]])\n\nscores = []\nfor cycle in (np.array(cycle) for cycle in cycles):\n    for i in range(cycle.size):\n        cum = np.roll(cycle, i).cumsum()\n        if cum[-1] > 0 and k > cycle.size:\n            scores.append(cum[-1]*(k//cycle.size-1) + np.concatenate([cum, cum[:k % cycle.size]+cum[-1]]).max())\n        else:\n            scores.append(cum[:min(k, cum.size)].max())\n\nprint(max(scores))", "import numpy as np\n\n\ndef parse():\n    n, k = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    pc = {i: (pi - 1, ci) for i, (pi, ci) in enumerate(zip(p, c))}\n    return k, pc\n\n\ndef split_simple():\n    k, pc = parse()\n    lst = [[]]\n    lst[0].append(pc.pop(0))\n    while True:\n        if not pc:\n            break\n        p, _ = lst[-1][-1]\n        if p in pc:\n            pcj = pc.pop(p)\n            lst[-1].append(pcj)\n        else:\n            j = next(iter(list(pc.keys())))\n            pcj = pc.pop(j)\n            lst.append([pcj])\n    return k, [np.array([ls[1] for ls in lst_], dtype=np.long) for lst_ in lst]\n\n\ndef inner(n, k, s, sim):\n    # print(sim)\n    # print(s)\n    if sim.shape[1] == 1:\n        return sim.max()\n    if k < n or s <= 0:\n        return sim.max()\n    div = k // n\n    mod = k % n\n    # print(k, n, div, mod)\n    if mod == 0:\n        return max(s * div, s * (div - 1) + sim.max())\n    try:\n        return max(s * div + sim[:, :mod].max(), s * (div - 1) + sim[:, :mod].max())\n    except ValueError:\n        print(mod)\n        print(sim)\n        print((sim.shape))\n        raise\n\n\ndef main():\n    k, data_set = split_simple()\n    result = min([d.min() for d in data_set])\n    for data in data_set:\n        n = data.size\n        rep = np.repeat(data[None], 2, axis=0).flatten()\n        # sim_ = np.array([[rep[i:i+p].sum()\n        #                  for p in range(1, min(k, n) + 1)] for i in range(n)])\n        sim = np.array([np.cumsum(rep[i:i+min(k, n)]) for i in range(n)])\n        # print((sim == sim_).all())\n        cand = inner(n, k, data.sum(), sim)\n        result = max(result, cand)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, math\n\ndef calcweight_tree(N_vertices, edges, times, inf):\n\n    \"\"\"\n    edges: [start, dest, cost] -> [cost, start, end]\n    \"\"\"\n\n    distance = 0\n\n    passed = [False] * N_vertices\n\n    travel_max = -inf\n    for i in range(N_vertices):\n        if(passed[i] == False):\n            distance = 0\n            left = i\n            cost_sum = 0\n            costs = []\n            min_distance = inf\n            while(True):\n                dest = edges[left][1]\n                cost = edges[dest][0]\n                if(passed[dest]==False):\n                    #passed[left] = True\n                    passed[dest] = True\n                    cost_sum += cost\n                    costs.append(cost_sum)\n                    left = dest\n                    if(min_distance > cost):\n                        min_distance = cost\n                else:\n                    period = len(costs)\n                    increase_period = cost_sum\n                    break\n            # 2 period\u9805\u6e96\u5099\n            remainder = times%period\n            cost_minus = [0]\n            for j in range(period-1):\n                cost_minus.append(costs[j])\n            if(increase_period <= 0):\n                \"\"\"\n                for j in range(period):\n                    costs.append(costs[j]+increase_period)\n                maxindex = 0\n                maxindex_start = 0\n                maxvalue = -inf\n\n                if(remainder==0):\n                    remainder += period\n\n                for st in range(period):\n                    maxvalue_candidate = max(costs[st:st+period])\n                    if(maxvalue_candidate - cost_minus[st] > maxvalue):\n                        maxvalue = maxvalue_candidate - cost_minus[st]\n                        maxindex = costs[st:st+period].index(maxvalue_candidate) + st\n                        maxindex_start = st\n                \"\"\"\n                costs_last = []\n                # a_0\u306f0\u306a\u306e\u3067\u3002\u305d\u3057\u3066\u3053\u308c\u306f\u6700\u5927\u5024\u3092\u8003\u3048\u308b\u3068\u304d\u306b\u306f\u6570\u3048\u306a\u3044\u306e\u3067\n                remainder2 = remainder % period\n\n                #print(\"x\", costs, increase_period, remainder2)\n                \"\"\"\n                for j in range(remainder2, period):\n                    costs_last.append(costs[j])\n                for j in range(0, remainder2):\n                    costs_last.append(costs[j]+increase_period)\n                for j in range(period):\n                    costs_last.append(costs_last[j]+increase_period)\n                \"\"\"\n                for j in range(period):\n                    costs_last.append(costs[j])\n                for j in range(period):\n                    costs_last.append(costs_last[j]+increase_period)\n                maxvalue = -inf\n                #print(costs_last, cost_minus)\n                for j in range(period):\n                    maxvalue_candidate = max(costs_last[j:j+period])\n                    if(maxvalue_candidate-cost_minus[j] > maxvalue):\n                        maxvalue = maxvalue_candidate-cost_minus[j]\n\n                travel_max = max(maxvalue, travel_max)\n            else:\n                costs_last = []\n                # a_0\u306f0\u306a\u306e\u3067\u3002\u305d\u3057\u3066\u3053\u308c\u306f\u6700\u5927\u5024\u3092\u8003\u3048\u308b\u3068\u304d\u306b\u306f\u6570\u3048\u306a\u3044\u306e\u3067\n                remainder2 = remainder % period\n                times_period = times//period-1\n                add_n = times_period * increase_period\n                #print(costs, increase_period, remainder2, times_period, add_n)\n                for j in range(remainder2, period):\n                    costs_last.append(costs[j]+add_n)\n                for j in range(0, remainder2):\n                    costs_last.append(costs[j]+add_n+increase_period)\n                for j in range(period):\n                    costs_last.append(costs_last[j]+increase_period)\n                maxvalue = -inf\n                #print(costs_last, cost_minus)\n                for j in range(period):\n                    maxvalue_candidate = max(costs_last[j:j+period])\n                    if(maxvalue_candidate-cost_minus[j] > maxvalue):\n                        maxvalue = maxvalue_candidate-cost_minus[j]\n                travel_max = max(maxvalue, travel_max)\n\n\n\n\n\n\n    return travel_max\n\n\n\n\n\n\n\ndef __starting_point():\n    \"\"\"\n    N = int( input().strip() )\n    Length = list( map(int, input().strip().split() ) )\n\n    edges = [ [] for _ in range(N+2) ]\n    for i in range(N):\n        edges[0].append([0, i]) #[cost, edge]\n    for i in range(1, N+1):\n        edges[i].append([0, N+1])\n    for i in range(N):\n        edges[i].append([ CList[i]*(-1), PList[i] ])\n    \"\"\"\n    N, K= list(map(int, input().strip().split() ))\n    PList = list( map(int, input().strip().split() ) )\n    CList = list( map(int, input().strip().split() ) )\n    inf = 10**10\n\n\n    N_vertices = N\n\n    edges3 = []\n    costs = []\n    for i in range(N):\n        edges3.append([ CList[i], PList[i]-1 ])\n\n    weight = calcweight_tree(N_vertices, edges3, K, inf)\n\n    #weight= calcweight_bellman_ford(N_vertices, 0, edges3, K+2, cost, inf)\n\n\n    print( weight)\n\n__starting_point()", "n,k=list(map(int,input().split()))\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\nans=-10**18\nflag=dict()\nfor i in range(n):\n    if i in flag:\n        continue\n    cur=i\n    accum=[]\n    flag[cur]=0\n    s=0\n    while flag[cur]<2:\n        cur=p[cur]-1\n        s+=c[cur]\n        accum.append(s)\n        if cur not in flag:\n            flag[cur]=0\n        else:\n            flag[cur]+=1\n    l=len(accum)//2\n    accum=[0]+accum\n    #print(accum)\n    for x in range(1,l+1):\n        if accum[x+l-1]-accum[x-1]<=0 or k//l<1:\n            ans=max(ans,max(accum[x:x+min(k,l)])-accum[x-1])\n        else:\n            a=max(accum[x:x+l-1])-accum[x-1]\n            d=accum[x+l-1]-accum[x-1]\n            if k%l!=0:\n                b=max(accum[x:x+k%l])-accum[x-1]\n                ans=max(ans,max(k//l*d,k//l*d+b,(k//l-1)*d+a))\n            else:\n                b=max(accum[x:x+l-1])-accum[x-1]\n                ans=max(ans,max(k//l*d,(k//l-1)*d+a))\nprint(ans)\n", "from itertools import accumulate\nimport sys\nsys.setrecursionlimit(10**6)\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\ndef dfs(G, v, p):\n    seen[v] = True\n    sc.append(c[v])\n\n    for nv in G[v]:\n        if nv == p:\n            continue\n        if seen[nv]:\n            pos[0] = nv\n            return\n\n        dfs(G, nv, v)\n        if pos[0] != -1:\n            return\n\n\nG = [[] for _ in range(n)]\nfor i in range(n):\n    G[i].append(p[i]-1)\n\nseen = [False]*n\nans = -float('inf')\nfor i in range(n):\n    if seen[i] == False:\n        pos = [-1]\n        sc = []\n        dfs(G, i, -1)\n\n        if sc:\n            sumsc = sum(sc)\n            lenc = len(sc)\n            for j in range(lenc):\n                if j != 0:\n                    sc = sc[1:] + [sc[0]]\n                ac = list(accumulate(sc))\n                \n                if sumsc <= 0:\n                    ans = max(ans, max(ac[:min(k, lenc)]))\n                else:\n                    if k%lenc == 0:\n                        ans = max(ans, ac[-1]*(k//lenc - 1) + max(ac))\n                    else:\n                        ans = max(ans, ac[-1]*(k//lenc) + max(ac[:k%lenc]))\nprint(ans)", "from numba import jit\n@jit\ndef main():\n    n,k = map(int,input().split())\n    p = list(map(int,input().split()))\n    c = list(map(int,input().split()))\n\n    ans=-10**18\n    for i in range(n):\n        start,count=i,1\n        val=c[start]\n        while p[start]-1 != i:\n            start = p[start]-1\n            count += 1\n            val += c[start]\n        start = i\n        if val > 0:\n            a = (k//count-1)*val\n            ans=max(a,ans)\n            num=count+k%count\n        else:\n            a=0\n            num=min(k,count)\n        for _ in range(num):\n            a += c[start]\n            start=p[start]-1\n            ans=max(a,ans)\n    print(ans)\nmain()", "from numba import jit\n@jit\ndef main():\n    n,k = map(int,input().split())\n    p = list(map(int,input().split()))\n    c = list(map(int,input().split()))\n\n    ans=-10**18\n    for i in range(n):\n        start,count=i,1\n        val=c[start]\n        while p[start]-1 != i:\n            start = p[start]-1\n            count += 1\n            val += c[start]\n        start = i\n        if val > 0:\n            a = (k//count-1)*val\n            ans=max(a,ans)\n            num=count+k%count\n        else:\n            a=0\n            num=min(k,count)\n        for _ in range(num):\n            a += c[start]\n            start=p[start]-1\n            ans=max(a,ans)\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    p = [int(x)-1 for x in input().split()]\n    c = list(map(int, input().split()))\n    \n    doubling = [[0]*n for i in range(31)]\n    doubling_max = [[0]*n for i in range(31)]\n    place = [[0]*n for i in range(31)]\n    \n    ans = -1000000000\n    for i in range(n):\n        sub = c[p[i]]\n        if sub >= 0:\n            break\n        if ans < sub:\n            ans = sub\n        if i == n-1:\n            print(ans)\n            return\n            \n    \n    for i in range(31):\n        if i == 0:\n            for j in range(n):\n                doubling[i][j] = c[p[j]]\n                place[i][j] = p[j]\n            continue\n        for j in range(n):\n            place[i][j] = place[i-1][place[i-1][j]]\n            doubling[i][j] = doubling[i-1][j]+doubling[i-1][place[i-1][j]]\n    \n    for i in range(31):\n        if i == 0:\n            for j in range(n):\n                doubling_max[i][j] = doubling[i][j]\n            continue\n        for j in range(n):\n            doubling_max[i][j] = max(doubling_max[i-1][j], doubling[i-1][j]+doubling_max[i-1][place[i-1][j]])\n    \n    ans = 0\n    judge = []\n    key = 0\n    while k:\n        if k%2:\n            judge.append(key)\n        k //= 2\n        key += 1\n    judge.reverse()\n    \n    for i in range(n):\n        pl = i\n        key = 0\n        for j in range(len(judge)):\n            if ans < key+doubling_max[judge[j]][pl]:\n                ans = key+doubling_max[judge[j]][pl]\n            key += doubling[judge[j]][pl]\n            pl = place[judge[j]][pl]\n        \n\n    print(ans)\n        \n    \n\n\n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "# import numpy as np\nimport itertools\n\ndef __starting_point():\n\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\n\t# print(P)\n\t# \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u30b5\u30a4\u30af\u30eb\u60c5\u5831\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u3066\u304a\u304f\u305f\u3081\u306e\u914d\u5217\n\t# cycleIDs = np.full( N, -1, np.int64 )\n\tcycleIDs = [ -1 for _ in range(N)]\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\n\tfor n in range(N):\n\t\tv = n\n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\t# \u5168\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5c5e\u3059\u308b\u30b5\u30a4\u30af\u30eb\u3092\u8a08\u7b97\u3059\u308b\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\t# \u30b5\u30a4\u30af\u30eb\u7d42\u4e86\n\t\t\t\t\t# \u30eb\u30fc\u30d7\u3092\u542b\u3081\u306a\u3044\u6700\u5927\u306e\u51e6\u7406\u56de\u6570\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\t# \u305d\u308c\u3067\u8db3\u308a\u3066\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u304c\u3001Last2\u5468\u5206\u306f\u3001\u30eb\u30fc\u30d7\u5408\u8a08\u304c\u30d7\u30e9\u30b9\u3067\u3082\u5fc5\u305a\u3057\u3082\u30eb\u30fc\u30d7\u3059\u308b\u3068\u306f\u9650\u3089\u306a\u3044\n\t\t\t\t\t# \u305d\u306e\u90e8\u5206\u306f\u3001\u3061\u3083\u3093\u3068\u8a08\u7b97\u3059\u308b\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# 4 101\n\t\t\t\t\t# 2 3 4 1\n\t\t\t\t\t# 50 -49 -50 50\n\t\t\t\t\t# \u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u3001\n\t\t\t\t\t# \u6700\u592725\u56de\u30eb\u30fc\u30d7 + 1\u56de\u51e6\u7406\u53ef\u80fd\u3060\u304c\u3001\u305d\u306e\u5834\u5408\u300125 + 50 = 75\n\t\t\t\t\t# 24\u56de\u30eb\u30fc\u30d7 + 2\u56de\u51e6\u7406\u3067\u3084\u3081\u308b\u3068\u3001124\u306b\u306a\u308b\n\t\t\t\t\t# \u7121\u6761\u4ef6\u3067\u30eb\u30fc\u30d7\u3059\u308b\u56de\u6570\u306f\u3001\u30eb\u30fc\u30d7\u53ef\u80fd\u306a\u6700\u5927\u306e\u56de\u6570-1\u3089\u3057\u3044\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# \u5272\u308a\u5207\u308c\u3066\u3001\u5c1a\u4e14\u3064\u30b5\u30a4\u30af\u30eb\u5408\u8a08\u304c\u30de\u30a4\u30ca\u30b9\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u3001\u6700\u4f4e\uff11\u500b\u306f\u51e6\u7406\u3059\u308b\u306e\u306b\u3082\u3053\u3053\u3067\u5bfe\u5fdc\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), currentCycleCosts * 3 ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\n\n\n\t# scores = []\n\t# procCnt = 0\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n\t\t# \u30b5\u30a4\u30af\u30eb\u5185\u3067\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u3050\u5834\u5408\u306e\u8003\u616e\n\t\tloopScore = 0\n\t\tif sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * sum(currentCycleCosts[:currentCycleSize])\n\t\t\t# print(\"loopScore\",loopScore,procCnt)\n\n\t\t# \u3053\u306e\u30b5\u30a4\u30af\u30eb\u306b\u5c5e\u3059\u308b\u5168\u9802\u70b9\u5206\u3092\u307e\u3068\u3081\u3066\u8a08\u7b97\u3059\u308b\n\t\tfor i in range(currentCycleSize):\n\t\t\t# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n\t\t\tscore = max( itertools.accumulate( currentCycleCosts[i:i+procCnt] ) )\n\t\t\tif ans < score + loopScore:\n\t\t\t\tans = score + loopScore\n\t\t\t# ans = max( ans, score + loopScore )\n\n\n\tprint(ans)\n\t# print(max(scores))\n\n__starting_point()", "from numba import jit\n@jit\ndef main():\n  n,k=list(map(int,input().split()))\n  p=list(map(int,input().split()))\n  c=list(map(int,input().split()))\n  ans=-10**18\n  for i in range(n):\n    start,count=i,1\n    val=c[start]\n    while p[start]-1!=i: #\u30eb\u30fc\u30d7\u90e8\u5206\n      start=p[start]-1\n      count+=1\n      val+=c[start]\n    start=i\n    if val>0:\n      a=(k//count-1)*val #\u4e00\u5468\u76ee\u306f\u30eb\u30fc\u30d7\u306e\u3069\u306e\u90e8\u5206\u304b\u3089\u59cb\u3081\u308b\u306e\u304c\u6700\u9069\u304b\u308f\u304b\u3089\u306a\u3044\u306e\u3067\n      ans=max(a,ans)\n      num=count+k%count\n    else:\n      a=0\n      num=min(k,count)\n    for _ in range(num):\n      start=p[start]-1\n      a+=c[start]\n      ans=max(a,ans)\n  print(ans)\nmain()\n", "from collections import Counter\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate\n\n\ndef solve(n, k, ppp, ccc):\n    NINF = -(10 ** 18)\n    ans = NINF\n\n    checked = [False] * n\n    for s in range(n):\n        if checked[s] == True:\n            continue\n        checked[s] = True\n        scores = [ccc[ppp[s]]]\n        v = ppp[s]\n        while v != s:\n            scores.append(ccc[ppp[v]])\n            checked[v] = True\n            v = ppp[v]\n\n        l = len(scores)\n        d, m = divmod(k, l)\n        loop = sum(scores)\n\n        if d > 0:\n            d -= 1\n            m += l\n\n        scores += scores * 2\n        scores.insert(0, 0)\n        acc = list(accumulate(scores))\n\n        base = max(0, loop * d)\n\n        range_max = [-a for a in acc[1:m + 1]]\n        available_max = Counter(range_max)\n        heapify(range_max)\n        for i in range(l):\n            while available_max[range_max[0]] == 0:\n                heappop(range_max)\n            ans = max(ans, base - range_max[0] - acc[i])\n            old = -acc[i + 1]\n            new = -acc[i + m + 1]\n            available_max[old] -= 1\n            available_max[new] += 1\n            heappush(range_max, new)\n\n    return ans\n\n\nn, k = list(map(int, input().split()))\nppp = list(map(int, input().split()))\nppp = [p - 1 for p in ppp]\nccc = list(map(int, input().split()))\n\nprint((solve(n, k, ppp, ccc)))\n", "from math import inf\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10**4)\n\nN, K = map(int, input().split())\nP = [0]+list(map(int, input().split()))\nC = [0]+list(map(int, input().split()))\n\nclass Graph(list):\n    def __init__(self, n):\n        super().__init__([None]*(n+1))\n        self.directions = P\n        self.points = C\n        self.loops = []\n        self.loopscores = []\n        self.search()\n        self.evalloop()\n\n    def search(self):\n        for i in range(1, len(self)):\n            self.history = set()\n            self.goto(i)\n\n    def goto(self, i):\n        if self[i]:\n            return self[i]\n        if i in self.history:\n            return self.addloop(i)\n        self.history.add(i)\n        l, p = self.goto(self.directions[i])\n        if self[i] == None:\n            self[i] = (l, p+1)\n        return self[i]\n\n    def addloop(self, j):\n        loop = [j]\n        k = self.directions[j]\n        while j != k:\n            loop.append(k)\n            k = self.directions[k]\n        self.loops.append(loop)\n        l = len(self.loops)-1\n        for i in loop:\n            self[i] = (l, 0)\n        return (l, 0)\n\n    def maxscore(self):\n        return max(self.score(self.directions[i], K) for i in range(1, len(self)))\n\n    def score(self, i, k):\n        if k == 0:\n            return 0\n        p = self.points[i]\n        i = self.directions[i]\n        k -= 1\n        if self[i][1] > 0:\n            s = self.score(i, k)\n            return p + max(0, s)\n        n = self[i][0]\n        loop = self.loops[n]\n        j = loop.index(i)\n        base = self.base[n]\n        loopscore = base[-1]\n        leftmax = self.leftmax[n]\n        rightmax = self.rightmax[n]\n        length = len(loop)\n        d, m = divmod(k, length)\n        if m == 0:\n            s = 0\n        elif j+m < length:\n            if leftmax[j] < leftmax[j+m]:\n                s = leftmax[j+m]-base[j]\n            elif rightmax[j+1] > rightmax[j+m+1]:\n                s = rightmax[j+1]-base[j]\n            else:\n                s = max(base[j+1:j+m+1])-base[j]\n        else:\n            s = max(loopscore+leftmax[j+m-length], rightmax[j+1])-base[j]\n        if d:\n            t = max(loopscore+leftmax[j], rightmax[j+1])-base[j]\n            return max(0, s, s+loopscore*d, t, t+loopscore*(d-1)) + p\n        else:\n            return max(0, s, s+loopscore*d) + p\n\n    def evalloop(self):\n        b, c, d = [], [], []\n        for l in self.loops:\n            bb, cc, dd = [0], [-inf], [-inf]\n            for i in l:\n                bb.append(bb[-1]+self.points[i])\n            for v in bb:\n                cc.append(max(cc[-1], v))\n            for v in reversed(bb):\n                dd.append(max(dd[-1], v))\n            b.append(bb)                      # [0, l[0], l[0]+l[1], ..., sum(l)]                        (len(bb) == len(l)+1)\n            c.append(cc[1:])                  # [0, max(0, l[0]), max(0, l[0], l[0]+l[1]), ..., max(bb)] (len(cc) == len(l)+1)\n            d.append(list(reversed(dd[1:])))  # [max(bb), ..., max(sum(l)-l[-2]-l[-1], sum(l)-l[-1], sum(l)), max(sum(l)-l[-1], sum(l)), sum(l)] (len(dd) == len(l)+1)\n        self.base = b\n        self.leftmax = c\n        self.rightmax = d\n\n\n\ng = Graph(N)\nprint(g.maxscore())", "n,k=map(int,input().split())\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\nans=-10**18\nflag=dict()\nfor i in range(n):\n    if i in flag:\n        continue\n    cur=i\n    accum=[]\n    flag[cur]=0\n    s=0\n    while flag[cur]<2:\n        cur=p[cur]-1\n        s+=c[cur]\n        accum.append(s)\n        if cur not in flag:\n            flag[cur]=0\n        else:\n            flag[cur]+=1\n    l=len(accum)//2\n    loop = accum[l-1]\n    accum=[0]+accum\n    for x in range(1,l+1):\n        if loop<=0 or k//l<1:\n            ans=max(ans,max(accum[x:x+min(k,l)])-accum[x-1])\n        else:\n            a=max(accum[x:x+l-1])-accum[x-1]\n            d=accum[x+l-1]-accum[x-1]\n            if k%l!=0:\n                b=max(accum[x:x+k%l])-accum[x-1]\n                ans=max(ans,max(k//l*d,k//l*d+b,(k//l-1)*d+a))\n            else:\n                b=max(accum[x:x+l-1])-accum[x-1]\n                ans=max(ans,max(k//l*d,(k//l-1)*d+a))\nprint(ans)", "import numpy as np\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n \ncycles, check = [], [False]*n\nfor pi in p:\n    if not check[pi-1]:\n        curr, cycle = pi, []\n        check[pi-1] = True\n        while pi != p[curr-1]:\n            check[curr-1] = True\n            cycle.append(c[curr-1])\n            curr = p[curr-1]\n        check[curr-1] = True\n        cycles.append(cycle + [c[curr-1]])\n\nscores = []\nfor cycle in (np.array(cycle) for cycle in cycles):\n    for i in range(cycle.size):\n        cum = np.roll(cycle, i).cumsum()\n        if cum[-1] > 0 and k > cycle.size:\n            scores.append(cum[-1]*(k//cycle.size-1) + np.concatenate([cum, cum[:k % cycle.size]+cum[-1]]).max())\n        else:\n            scores.append(cum[:min(k, cum.size)].max())\nprint(max(scores))", "from numba import jit\n@jit\ndef main():\n  n,k=list(map(int,input().split(\" \")))\n  p=list(map(int,input().split(\" \")))\n  c=list(map(int,input().split(\" \")))\n  ans=-10**18\n  for i in range(n):\n    start,count=i,1\n    val=c[start]\n    while p[start]-1!=i: #\u30eb\u30fc\u30d7\u90e8\u5206. i\u306b\u623b\u308b\u76f4\u524d\u307e\u3067\u7d9a\u3051\u308b.\n      start=p[start]-1\n      count+=1\n      val+=c[start]\n    start=i\n    # \u3053\u306e\u6642\u70b9\u3067val\u306f1\u30eb\u30fc\u30d7\u306e\u30b9\u30b3\u30a2\u5408\u8a08, \u30ab\u30a6\u30f3\u30c8\u306f1\u30eb\u30fc\u30d7\u306esize\u306b\u306a\u3063\u3066\u3044\u308b\n    '''\n    \u4ee5\u4e0b\u306e\u57fa\u672c\u7684\u306a\u65b9\u91dd\u306f\n    - 1\u30eb\u30fc\u30d7\u5206\u306e\u30b9\u30b3\u30a2\u5408\u8a08\u304c\u6b63\u3067\u3042\u308c\u3070\u3067\u304d\u308b\u3060\u3051\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u304e\u3001\u6b8b\u308a\u306e\u4f59\u308a\u306e\u5206\u306e\u6700\u5927\u3092\u3068\u308b\u3002\n    - 1\u30eb\u30fc\u30d7\u5206\u306e\u30b9\u30b3\u30a2\u5408\u8a08\u304c\u8ca0\u3067\u3042\u308c\u3070\u30eb\u30fc\u30d7\u56de\u6570\u30920\u306b\u3057\u3066\u30011\u30eb\u30fc\u30d7\u4ee5\u5185\u3067\u6700\u5927\u3068\u306a\u308b\u79fb\u52d5\u3092\u6c42\u3081\u308b\u3002\n    \u3057\u304b\u3057\u3001\u30eb\u30fc\u30d7\u56de\u6570\u304c\u6700\u5927\u3067\u3042\u308c\u3070\u3044\u3044\u3068\u306f\u9650\u3089\u306a\u3044\u3002\n    x\u56de\u30eb\u30fc\u30d7\u3067\u304d\u305f\u3068\u3057\u3066count%k\u56de\u306e\u4f59\u308a\u306e\u5206\u3092\u8abf\u3079\u3066\u3082\u3001x-1\u56de\u30eb\u30fc\u30d7\u3057\u6b21\u306e1\u56de\u306e\u30eb\u30fc\u30d7\u306e\u306a\u304b\u30671\u5468\u4ed5\u5207\u3089\u306a\u3044\u79fb\u52d5\u304c\u6700\u5927\u306b\u306a\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u3002\n    \u306a\u306e\u3067x-1\u56de\u5206\u306e\u30eb\u30fc\u30d7\u3060\u3051\u53d6\u308a\u5207\u3063\u3066\u3057\u307e\u3044\u3001\u6b8b\u308acount+k%count(\uff1d\u300c1\u5468\u534a\u300d)\u306e\u4e2d\u3067\u6700\u5927\u3092\u8abf\u3079\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n    \u307e\u305f\u3001\u8ca0\u306e\u5834\u5408\u306f\u57fa\u672c\u7684\u306b1\u5468\u4ee5\u5185\u3060\u304c\u3001k\u304c\u6975\u7aef\u306b\u5c0f\u3055\u3044\u3068\u304d\u306e\u51e6\u7406\u304c\u5fc5\u8981\u3002\n    '''\n    if val>0:\n      a=(k//count-1)*val  # \u6700\u5f8c\u306b\u4f59\u308a\u306ek%count\u56de\u3076\u3093\u3060\u3051\u3067\u306a\u304f1\u5468\u534a\u3076\u3093\u306f\u8a66\u3057\u305f\u3044\u306e\u3067(\u30eb\u30fc\u30d7\u4f59\u308a\u3067\u306fk%count\u56de\u3057\u304b\u79fb\u52d5\u3067\u304d\u306a\u3044\u308f\u3051\u3067\u306f\u306a\u3044)\n      ans=max(a,ans)\n      num=count+k%count\n    else:\n      a=0\n      num=min(k,count)  # 1\u5468\u4ee5\u5185\u306b\u304a\u3055\u3081\u305f\u3044. k<count\u3068\u3044\u3046\u975e\u5e38\u306b\u9650\u3089\u308c\u305f\u5834\u5408\u306e\u307fk\u56de\u307e\u3067\u306e\u79fb\u52d5\u306b\u306a\u308b\u3053\u3068\u3092\u8003\u616e\u3002\n    for _ in range(num):\n      start=p[start]-1\n      a+=c[start]\n      ans=max(a,ans)\n  print(ans)\nmain()\n", "import numpy as np\n\ndef __starting_point():\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\tcycleIDs = np.full( N, -1, np.int64 )\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\tfor n in range(N):\n\t\tv = n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), np.array( currentCycleCosts + currentCycleCosts ) ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\t\tloopScore = 0\n\t\tif np.sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * np.sum(currentCycleCosts[:currentCycleSize])\n\n\t\tfor i in range(currentCycleSize):\n\t\t\tans = max( ans, np.roll( currentCycleCosts, i ).cumsum()[:procCnt].max() + loopScore )\n\n\tprint(ans)\n\n__starting_point()", "import sys\n\nclass SWAG:\n    def __init__(self):\n        self.fold_l = []\n        self.r = []\n        self.fold_r = ~(1 << 60)\n    def push(self, a):\n        if self.fold_r < a:\n            self.fold_r = a\n        self.r.append(a)\n    def pop(self):\n        if not self.fold_l:\n            self.r.reverse()\n            self.fold_l = self.r\n            self.r = []\n            self.fold_r = ~(1 << 60)\n            fold_l = self.fold_l\n            for i in range(len(fold_l) - 1):\n                if fold_l[i + 1] < fold_l[i]:\n                    fold_l[i + 1] = fold_l[i]\n        self.fold_l.pop()\n    def get(self):\n        if not self.fold_l:\n            return self.fold_r\n        elif not self.r:\n            return self.fold_l[-1]\n        else:\n            return max(self.fold_l[-1], self.fold_r)\n\nn, k = list(map(int, input().split()))\np = [*list(map(int, input().split()))]\nc = [*list(map(int, input().split()))]\nfor i in range(n):\n    p[i] -= 1\n\nif max(c) < 0:\n    print((max(c)))\n    return\n\nans = 0\nused = [False] * n\nfor i in range(n):\n    if used[i]:\n        continue\n\n    # \u30eb\u30fc\u30d7\u3092\u53d6\u308a\u51fa\u3059\n    loop = []\n    at = i\n    while not used[at]:\n        loop.append(c[at])\n        used[at] = True\n        at = p[at]\n\n    siz = len(loop)\n    cusum = [0] + loop * 3\n    for i in range(siz * 3):\n        cusum[i + 1] += cusum[i]\n    sum = max(0, cusum[siz])\n\n    # k % siz \u56de\u4ee5\u4e0b\u3067\u306e\u6700\u5927 -> \u7d2f\u7a4d\u548c\u306b\u30b9\u30e9\u30a4\u30c9\u6700\u5927\u5024\n    d = k % siz\n    swag = SWAG()\n    for i in range(d):\n        swag.push(cusum[i])\n    for i in range(siz):\n        swag.push(cusum[d + i])\n        ans = max(ans, swag.get() - cusum[i] + sum * (k // siz))\n        swag.pop()\n\n    if k < siz:\n        continue\n\n    # k % siz + siz \u56de\u4ee5\u4e0b\u3067\u306e\u6700\u5927\n    d = k % siz + siz\n    swag = SWAG()\n    for i in range(d):\n        swag.push(cusum[i])\n    for i in range(siz):\n        swag.push(cusum[d + i])\n        ans = max(ans, swag.get() - cusum[i] + sum * (k // siz - 1))\n        swag.pop()\n\nprint(ans)\n", "# import numpy as np\nimport itertools\n\ndef __starting_point():\n\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\n\t# print(P)\n\t# \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u30b5\u30a4\u30af\u30eb\u60c5\u5831\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u3066\u304a\u304f\u305f\u3081\u306e\u914d\u5217\n\t# cycleIDs = np.full( N, -1, np.int64 )\n\tcycleIDs = [ -1 for _ in range(N)]\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\n\tfor n in range(N):\n\t\tv = n\n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\t# \u5168\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5c5e\u3059\u308b\u30b5\u30a4\u30af\u30eb\u3092\u8a08\u7b97\u3059\u308b\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\t# \u30b5\u30a4\u30af\u30eb\u7d42\u4e86\n\t\t\t\t\t# \u30eb\u30fc\u30d7\u3092\u542b\u3081\u306a\u3044\u6700\u5927\u306e\u51e6\u7406\u56de\u6570\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\t# \u305d\u308c\u3067\u8db3\u308a\u3066\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u304c\u3001Last2\u5468\u5206\u306f\u3001\u30eb\u30fc\u30d7\u5408\u8a08\u304c\u30d7\u30e9\u30b9\u3067\u3082\u5fc5\u305a\u3057\u3082\u30eb\u30fc\u30d7\u3059\u308b\u3068\u306f\u9650\u3089\u306a\u3044\n\t\t\t\t\t# \u305d\u306e\u90e8\u5206\u306f\u3001\u3061\u3083\u3093\u3068\u8a08\u7b97\u3059\u308b\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# 4 101\n\t\t\t\t\t# 2 3 4 1\n\t\t\t\t\t# 50 -49 -50 50\n\t\t\t\t\t# \u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u3001\n\t\t\t\t\t# \u6700\u592725\u56de\u30eb\u30fc\u30d7 + 1\u56de\u51e6\u7406\u53ef\u80fd\u3060\u304c\u3001\u305d\u306e\u5834\u5408\u300125 + 50 = 75\n\t\t\t\t\t# 24\u56de\u30eb\u30fc\u30d7 + 2\u56de\u51e6\u7406\u3067\u3084\u3081\u308b\u3068\u3001124\u306b\u306a\u308b\n\t\t\t\t\t# \u7121\u6761\u4ef6\u3067\u30eb\u30fc\u30d7\u3059\u308b\u56de\u6570\u306f\u3001\u30eb\u30fc\u30d7\u53ef\u80fd\u306a\u6700\u5927\u306e\u56de\u6570-1\u3089\u3057\u3044\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# \u5272\u308a\u5207\u308c\u3066\u3001\u5c1a\u4e14\u3064\u30b5\u30a4\u30af\u30eb\u5408\u8a08\u304c\u30de\u30a4\u30ca\u30b9\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u3001\u6700\u4f4e\uff11\u500b\u306f\u51e6\u7406\u3059\u308b\u306e\u306b\u3082\u3053\u3053\u3067\u5bfe\u5fdc\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), currentCycleCosts * 3 ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\n\n\n\t# scores = []\n\t# procCnt = 0\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n\t\t# \u30b5\u30a4\u30af\u30eb\u5185\u3067\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u3050\u5834\u5408\u306e\u8003\u616e\n\t\tloopScore = 0\n\t\tif sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * sum(currentCycleCosts[:currentCycleSize])\n\t\t\t# print(\"loopScore\",loopScore,procCnt)\n\n\t\t# \u3053\u306e\u30b5\u30a4\u30af\u30eb\u306b\u5c5e\u3059\u308b\u5168\u9802\u70b9\u5206\u3092\u307e\u3068\u3081\u3066\u8a08\u7b97\u3059\u308b\n\t\tfor i in range(currentCycleSize):\n\t\t\t# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n\t\t\tans = max( ans, max( list( itertools.accumulate( currentCycleCosts[i:i+procCnt] ) ) ) + loopScore )\n\n\n\tprint(ans)\n\t# print(max(scores))\n\n__starting_point()", "# import numpy as np\nimport itertools\n\ndef __starting_point():\n\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\n\t# print(P)\n\t# \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u30b5\u30a4\u30af\u30eb\u60c5\u5831\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u3066\u304a\u304f\u305f\u3081\u306e\u914d\u5217\n\t# cycleIDs = np.full( N, -1, np.int64 )\n\tcycleIDs = [ -1 for _ in range(N)]\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\n\tfor n in range(N):\n\t\tv = n\n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\t# \u5168\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5c5e\u3059\u308b\u30b5\u30a4\u30af\u30eb\u3092\u8a08\u7b97\u3059\u308b\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\t# \u30b5\u30a4\u30af\u30eb\u7d42\u4e86\n\t\t\t\t\t# \u30eb\u30fc\u30d7\u3092\u542b\u3081\u306a\u3044\u6700\u5927\u306e\u51e6\u7406\u56de\u6570\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\t# \u305d\u308c\u3067\u8db3\u308a\u3066\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u304c\u3001Last2\u5468\u5206\u306f\u3001\u30eb\u30fc\u30d7\u5408\u8a08\u304c\u30d7\u30e9\u30b9\u3067\u3082\u5fc5\u305a\u3057\u3082\u30eb\u30fc\u30d7\u3059\u308b\u3068\u306f\u9650\u3089\u306a\u3044\n\t\t\t\t\t# \u305d\u306e\u90e8\u5206\u306f\u3001\u3061\u3083\u3093\u3068\u8a08\u7b97\u3059\u308b\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# 4 101\n\t\t\t\t\t# 2 3 4 1\n\t\t\t\t\t# 50 -49 -50 50\n\t\t\t\t\t# \u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u3001\n\t\t\t\t\t# \u6700\u592725\u56de\u30eb\u30fc\u30d7 + 1\u56de\u51e6\u7406\u53ef\u80fd\u3060\u304c\u3001\u305d\u306e\u5834\u5408\u300125 + 50 = 75\n\t\t\t\t\t# 24\u56de\u30eb\u30fc\u30d7 + 2\u56de\u51e6\u7406\u3067\u3084\u3081\u308b\u3068\u3001124\u306b\u306a\u308b\n\t\t\t\t\t# \u7121\u6761\u4ef6\u3067\u30eb\u30fc\u30d7\u3059\u308b\u56de\u6570\u306f\u3001\u30eb\u30fc\u30d7\u53ef\u80fd\u306a\u6700\u5927\u306e\u56de\u6570-1\u3089\u3057\u3044\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# \u5272\u308a\u5207\u308c\u3066\u3001\u5c1a\u4e14\u3064\u30b5\u30a4\u30af\u30eb\u5408\u8a08\u304c\u30de\u30a4\u30ca\u30b9\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u3001\u6700\u4f4e\uff11\u500b\u306f\u51e6\u7406\u3059\u308b\u306e\u306b\u3082\u3053\u3053\u3067\u5bfe\u5fdc\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), currentCycleCosts * 3 ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\n\n\n\t# scores = []\n\t# procCnt = 0\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n\t\t# \u30b5\u30a4\u30af\u30eb\u5185\u3067\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u3050\u5834\u5408\u306e\u8003\u616e\n\t\tloopScore = 0\n\t\tif sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * sum(currentCycleCosts[:currentCycleSize])\n\t\t\t# print(\"loopScore\",loopScore,procCnt)\n\n\t\t# \u3053\u306e\u30b5\u30a4\u30af\u30eb\u306b\u5c5e\u3059\u308b\u5168\u9802\u70b9\u5206\u3092\u307e\u3068\u3081\u3066\u8a08\u7b97\u3059\u308b\n\t\tfor i in range(currentCycleSize):\n\t\t\t# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n\t\t\tans = max( ans, max( itertools.accumulate( currentCycleCosts[i:i+procCnt] ) ) + loopScore )\n\n\n\tprint(ans)\n\t# print(max(scores))\n\n__starting_point()", "from itertools import accumulate\n\n\ndef solve(n, k, ppp, ccc):\n    NINF = -(10 ** 18)\n    ans = NINF\n\n    checked = [False] * n\n    for s in range(n):\n        if checked[s] == True:\n            continue\n        checked[s] = True\n        scores = [ccc[ppp[s]]]\n        v = ppp[s]\n        while v != s:\n            scores.append(ccc[ppp[v]])\n            checked[v] = True\n            v = ppp[v]\n\n        l = len(scores)\n        d, m = divmod(k, l)\n        loop = sum(scores)\n\n        if d > 0:\n            d -= 1\n            m += l\n\n        scores += scores * 2\n        scores.insert(0, 0)\n        acc = list(accumulate(scores))\n        tmp = max(max(acc[i + 1:i + m + 1]) - acc[i] for i in range(l))\n        ans = max(ans, tmp, loop * d + tmp)\n\n    return ans\n\n\nn, k = list(map(int, input().split()))\nppp = list(map(int, input().split()))\nppp = [p - 1 for p in ppp]\nccc = list(map(int, input().split()))\n\nprint((solve(n, k, ppp, ccc)))\n", "import itertools\nN, K = [int(_) for _ in input().split()]\nP = [int(_) - 1 for _ in input().split()]\nC = [int(_) for _ in input().split()]\n\n\nclass SegmentTree():\n    def __init__(self, array, f, ti):\n        \"\"\"\n        Parameters\n        ----------\n        array : list\n            to construct segment tree from\n        f : func\n            binary operation of the monoid\n        ti : \n            identity element of the monoid\n        \"\"\"\n        self.f = f\n        self.ti = ti\n        self.n = n = 2**(len(array).bit_length())\n        self.dat = dat = [ti] * n + array + [ti] * (n - len(array))\n        for i in range(n - 1, 0, -1):  # build\n            dat[i] = f(dat[i << 1], dat[i << 1 | 1])\n\n    def update(self, p, v):  # set value at position p (0-indexed)\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = v\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_right(self, p, v):  # apply operator from the right side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(dat[p], v)\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def operate_left(self, p, v):  # apply operator from the left side\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = f(v, dat[p])\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def query(self, l, r):  # result on interval [l, r) (0-indexed)\n        f, ti, n, dat = self.f, self.ti, self.n, self.dat\n        vl = vr = ti\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                vl = f(vl, dat[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                vr = f(dat[r], vr)\n            l >>= 1\n            r >>= 1\n        return f(vl, vr)\n\n\nans = -10**20\nse = set()\nfor start in range(N):\n    if start in se:\n        continue\n    now = start\n    scores = []\n    while True:\n        if now in se:\n            break\n        se.add(now)\n        scores += [C[now]]\n        now = P[now]\n    cyclelen = len(scores)\n    cum = list(itertools.accumulate(scores * 2))\n    st = SegmentTree(cum, max, -10**20)\n    cycle, residue = divmod(K, cyclelen)\n    ans = max([ans] + [\n        st.query(start2 + 1, start2 + 1 + min(cyclelen, K)) - cum[start2]\n        for start2 in range(cyclelen)\n    ])\n    if cum[-1] > 0 and cycle > 0:\n        v1 = cum[-1] * (cycle - 1) // 2 + max(\n            st.query(start2, start2 + cyclelen + 1) - cum[start2]\n            for start2 in range(cyclelen))\n        v2 = cum[-1] * cycle // 2 + max(\n            st.query(start2, start2 + residue + 1) - cum[start2]\n            for start2 in range(cyclelen))\n        ans = max([ans, v1, v2])\nprint(ans)\n", "from itertools import accumulate\nimport sys\nsys.setrecursionlimit(10**8)\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\np = [i-1 for i in p]\n\nseen = [False]*n\nans = -float('inf')\nfor i in range(n):\n    if not seen[i]:\n        sc = []\n        stop = i\n        while True:\n            seen[i] = True\n            sc.append(c[i])\n            if p[i] == stop:\n                break\n            i = p[i]\n\n        lens = len(sc)\n        for j in range(lens):\n            if j != 0:\n                sc = sc[1:] + [sc[0]]\n            ac = list(accumulate(sc))\n\n            if sum(sc) <= 0:\n                ans = max(ans, max(ac[:min(k, lens)]))\n            else:\n                if k%lens == 0:\n                    ans = max(ans, ac[-1]*(k//lens-1) + max(ac))\n                else:\n                    ans = max(ans, ac[-1]*(k//lens) + max(ac[:k%lens]))\nprint(ans)", "from numba import njit\nfrom sys import maxsize\n\n\n@njit\ndef solve(n, k, p, c):\n    used = [0] * n\n    ss = []\n    for i in range(n):\n        if used[i]:\n            continue\n        now = i\n        s = []\n        while not used[now]:\n            used[now] = 1\n            s.append(c[now])\n            now = p[now]\n        ss.append(s)\n\n    res = -maxsize\n    for s in ss:\n        s_len = len(s)\n        cumsum = [0]\n        # 2\u5468\u5206\u306e\u7d2f\u7a4d\u548c\n        for i in range(2*s_len):\n            cumsum.append(cumsum[-1] + s[i%s_len])\n\n        max_sum = [-maxsize] * s_len\n        for i in range(s_len):\n            for j in range(s_len):\n                max_sum[j] = max(max_sum[j], cumsum[i+j] - cumsum[i])\n\n        for i in range(s_len):\n            if i > k:\n                continue\n            v = (k - i) // s_len\n            if i == 0 and v == 0:\n                continue\n            if cumsum[s_len] > 0:\n                res = max(res, max_sum[i] + cumsum[s_len] * v)\n            elif i > 0:\n                res = max(res, max_sum[i])\n    print(res)\n\n\ndef __starting_point():\n    n, k = list(map(int, input().split()))\n    p = list([int(x)-1 for x in input().split()])\n    c = list(map(int, input().split()))\n    solve(n, k, p, c)\n\n__starting_point()", "N, K = map(int, input().split())\nP = list(map(int, input().split()))\n_c = list(map(int, input().split()))\n\n# C\u3092\u66f8\u304d\u63db\u3048\u308b\nC = [0] * N\nfor i in range(N):\n    P[i] -= 1\n    C[i] = _c[P[i]]\n\nm = 31 # bit\u6570\n\n# \u30c0\u30d6\u30ea\u30f3\u30b0\nvertex = list()\nscore = list()\nvertex.append(P)\nscore.append(C)\nfor b in range(1, m+1):\n    p_bth = [0] * N\n    c_bth = [0] * N\n    for i in range(N):\n        p_bth[i] = vertex[b-1][vertex[b-1][i]]\n        c_bth[i] = score[b-1][i] + score[b-1][vertex[b-1][i]]\n    vertex.append(p_bth)\n    score.append(c_bth)\n\n# \u6841DP\nMIN = -(1 << 63) \nprv = [[MIN, 0] for _ in range(N)]\nnxt = [[MIN, MIN] for _ in range(N)] \nfor b in range(m, -1, -1):\n    for i in range(N):\n        if (K >> b) & 1:\n            nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n            nxt[vertex[b][i]][1] = max(nxt[vertex[b][i]][1], prv[i][1] + score[b][i])\n            nxt[i][0] = max(nxt[i][0], prv[i][0], prv[i][1])\n        else:\n            nxt[vertex[b][i]][0] = max(nxt[vertex[b][i]][0], prv[i][0] + score[b][i])\n            nxt[i][0] = max(nxt[i][0], prv[i][0])\n            nxt[i][1] = max(nxt[i][1], prv[i][1])\n    prv, nxt = nxt, prv\n\nans = max(max(x) for x in prv)\nif ans == 0:\n    ans = max(C)\n\nprint(ans)", "from collections import deque\nit = lambda: list(map(int, input().strip().split()))\n\n\ndef maximise(L, R, cycle):\n    cur = 0\n    ans = max(cycle)\n    queue = deque([0])\n    dp = [0] * (2 * L + 1)\n    for i, num in enumerate(cycle + cycle):\n        j = i + 1\n        cur += num\n        while queue and j - queue[0] > R:\n            queue.popleft()\n        if queue:\n            ans = max(ans, cur - dp[queue[0]])\n        while queue and dp[queue[-1]] >= cur:\n            queue.pop()\n        queue.append(j)\n        dp[j] = cur\n    return ans\n\n\ndef get(K, cycle):\n    L = len(cycle)\n    T = sum(cycle)\n\n    if K > L:\n        B = (K - 1) // L\n        R = K - B * L\n    else:\n        B = 0\n        R = K\n    return max(maximise(L, K, cycle), maximise(L, R, cycle) + max(0, B * T))\n\n\ndef solve():\n    # square labelled from 1 to N\n    N, K = it()\n    P = it()\n    C = it()\n\n    for i in range(N):\n        P[i] -= 1\n\n    cycles = []\n    seen = [False] * N\n    for i in range(N):\n        if not seen[i]:\n            cycle = []\n            first = curr = i\n            while True:\n                seen[curr] = True\n                cycle.append(C[curr])\n                curr = P[curr]\n                if curr == first:\n                    break\n            cycles.append(cycle)\n    \n    # print(cycles)\n    ans = float('-inf')\n    for cycle in cycles:\n        ans = max(ans, get(K, cycle))\n    return ans\n\n\ndef __starting_point():\n    ans = solve()\n    print(ans)\n__starting_point()", "n,k=list(map(int,input().split()))\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\nans=-10**18\nflag=dict()\nfor i in range(n):\n    if i in flag:\n        continue\n    cur=i\n    accum=[]\n    flag[cur]=0\n    s=0\n    while flag[cur]<2:\n        cur=p[cur]-1\n        s+=c[cur]\n        accum.append(s)\n        if cur not in flag:\n            flag[cur]=0\n        else:\n            flag[cur]+=1\n    l=len(accum)//2\n    accum=[0]+accum\n    #print(accum)\n    for x in range(1,l+1):\n        if accum[x+l-1]-accum[x-1]<=0 or k//l<1:\n            ans=max(ans,max(accum[x:x+min(k,l)])-accum[x-1])\n        else:\n            a=max(accum[x:x+l-1])-accum[x-1]\n            d=accum[x+l-1]-accum[x-1]\n            if k%l!=0:\n                b=max(accum[x:x+k%l])-accum[x-1]\n                ans=max(ans,max(k//l*d,k//l*d+b,(k//l-1)*d+a))\n            else:\n                b=max(accum[x:x+l-1])-accum[x-1]\n                ans=max(ans,max(k//l*d,(k//l-1)*d+a))\nprint(ans)\n", "from numba import jit\n@jit\ndef main():\n  n,k=list(map(int,input().split()))\n  p=list(map(int,input().split()))\n  c=list(map(int,input().split()))\n  ans=-10**18\n  for i in range(n):\n    start,count=i,1\n    val=c[start]\n    while p[start]-1!=i: #\u30eb\u30fc\u30d7\u90e8\u5206\n      start=p[start]-1\n      count+=1\n      val+=c[start]\n    start=i\n    if val>0:\n      a=(k//count-1)*val #\u4e00\u5468\u76ee\u306f\u30eb\u30fc\u30d7\u306e\u3069\u306e\u90e8\u5206\u304b\u3089\u59cb\u3081\u308b\u306e\u304c\u6700\u9069\u304b\u308f\u304b\u3089\u306a\u3044\u306e\u3067\n      ans=max(a,ans)\n      num=count+k%count\n    else:\n      a=0\n      num=min(k,count)\n    for _ in range(num):\n      start=p[start]-1\n      a+=c[start]\n      ans=max(a,ans)\n  print(ans)\nmain()\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[7]:\n\n\nfrom itertools import accumulate\n\n\n# In[19]:\n\n\nN,K = list(map(int, input().split()))\nP = list(map(int, input().split()))\nC = list(map(int, input().split()))\nP = [p-1 for p in P]\n\n\n# In[20]:\n\n\ncheck = [False]*N\nans = -float(\"inf\")\nfor i in range(N):\n    if not check[i]:\n        score = []\n        stop = i\n        while 1:\n            check[i] = True\n            score.append(C[i])\n            if P[i] == stop:\n                break\n            i = P[i]\n        length = len(score)\n        for j in range(length):\n            if j != 0:\n                score = score[1:] + [score[0]]\n            ac = list(accumulate(score))\n            if sum(score) <= 0:\n                ans = max(ans, max(ac[:min(K,length)]))\n            else:\n                if K%length == 0:\n                    ans = max(ans, ac[-1]*(K//length-1)+max(ac))\n                else:\n                    ans = max(ans, ac[-1]*(K//length) + max(ac[:K%length]))\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "# D not completed\n# -*- coding: utf-8 -*-\nN, K = map(int, input().split())\nP_list = list(map(int, input().split()))\nC_list = list(map(int, input().split()))\n\nchecked_list = [0 for _ in range(N)]\nmin_INF = -1 * 10 ** 10\nmax_score = min_INF\nfor i in range(N):\n    if checked_list[i] == 1:\n        continue\n    posit = i\n    loop_list = [posit]\n    score_list = []\n    for j in range(N):\n        posit = P_list[posit] - 1\n        if j == 0:\n            score_list.append(C_list[posit])\n        else:\n            score_list.append(score_list[-1] + C_list[posit])\n        if posit in loop_list:\n            break\n        loop_list.append(posit)\n\n    len_loop = len(loop_list)\n    max_score_list = max(score_list)\n    around_score = score_list[-1]\n    temp_score_base = 0\n    if around_score > 0 and K // len_loop > 0:\n        temp_score_base += (K // len_loop - 1) * around_score\n    for k in range(len_loop):\n        # print(\"loop\", loop_list)\n        # print(\"score\", score_list)\n        checked_list[loop_list[k]] = 1\n        temp_max_score = temp_score_base\n        rest_score = min_INF\n        if around_score > 0 and K // len_loop > 0:\n            # \u6700\u5f8c\u306b1\u5468\u3059\u3079\u304d\u304b\n            rest_score = max(max_score_list, max(score_list[:K % len_loop], default=min_INF) + around_score)\n            # print(loop_list[k], temp_max_score, K, len_loop, K // len_loop)\n        rest_score = max(max(score_list[:min(K, len_loop)]), rest_score)\n        temp_max_score = temp_max_score + rest_score\n        # print(loop_list[k], temp_max_score, rest_score)\n        max_score = max(max_score, temp_max_score)\n        # \u30eb\u30fc\u30d7\u5185\u3067\u305a\u3089\u3059\n        now_score = score_list.pop(0)\n        len_score = len(score_list)\n        score_list = [score_list[l] - now_score for l in range(len_score)]\n        score_list.append(score_list[-1] + now_score)\n\nprint(max_score)", "\nn, k = map(int, input().split())\np = [int(x) - 1 for x in input().split()]\nc = [int(x) for x in input().split()]\npow_num = 31\npoint = [[0] * n for i in range(pow_num)]\npoint_max = [[0] * n for i in range(pow_num)]\nposi = [[0] * n for i in range(pow_num)]\n\nc_set = set(c)\nif all([i < 0 for i in c_set]):\n    print(max(c_set))\nelse:\n    for i in range(pow_num):\n        if i == 0:\n            for j in range(n):\n                posi[i][j] = p[j]\n                point[i][j] = c[p[j]]\n            continue\n        for j in range(n):\n            posi[i][j] = posi[i-1][posi[i-1][j]]\n            point[i][j] = point[i-1][j] + point[i-1][posi[i-1][j]]\n    for i in range(pow_num):\n        if i == 0:\n            for j in range(n):\n                point_max[i][j] = point[i][j]\n            continue\n        for j in range(n):\n            point_max[i][j] = max(point_max[i-1][j], \\\n                point[i-1][j] + point_max[i-1][posi[i-1][j]])\n\n    power_count = list()\n    for i in range(pow_num):\n        if k & (1 << i):\n            power_count.append(i)\n\n        ans = 0\n        for i in range(n):\n            next_posi = i\n            cumsum_point = 0\n            for posi_idx in power_count:\n                if ans < cumsum_point + point_max[posi_idx][next_posi]:\n                    ans = cumsum_point + point_max[posi_idx][next_posi]\n                cumsum_point += point[posi_idx][next_posi]\n                next_posi = posi[posi_idx][next_posi]\n\n    print(ans)", "from numba import jit\n@jit\ndef main():\n    n, k = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    ans = -10**10\n    \n    for i in range(n):\n        start, count = i, 1\n        val = c[start]\n        while p[start]-1 != i:\n            start = p[start]-1\n            count += 1\n            val += c[start]\n\n        start = i\n        if val > 0:\n            a = (k//count-1)*val\n            ans = max(a, ans)\n            num = k%count+count\n        else:\n            a = 0\n            num = min(k, count)\n\n        for _ in range(num):\n            start = p[start]-1\n            a += c[start]\n            ans = max(a, ans)\n    print((int(ans)))\n\nmain()\n", "# import numpy as np\nimport itertools\n\ndef __starting_point():\n\n\tN,K = list(map(int,input().split()))\n\tP = [ int(p)-1 for p in input().split() ]\n\tC = list(map(int,input().split()))\n\n\t# print(P)\n\t# \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u30b5\u30a4\u30af\u30eb\u60c5\u5831\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u3057\u3066\u304a\u304f\u305f\u3081\u306e\u914d\u5217\n\t# cycleIDs = np.full( N, -1, np.int64 )\n\tcycleIDs = [ -1 for _ in range(N)]\n\tcycleInfs = []\n\tcycleID = 0\n\tprocCnt = 0\n\n\tfor n in range(N):\n\t\tv = n\n\n\t\tif cycleIDs[v] != -1:\n\t\t\tcontinue\n\t\telse:\n\t\t\tcurrentCycleCosts = []\n\t\t\twhile True:\n\t\t\t\t# \u5168\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5c5e\u3059\u308b\u30b5\u30a4\u30af\u30eb\u3092\u8a08\u7b97\u3059\u308b\n\t\t\t\tcurrentCycleCosts.append( C[v] )\n\t\t\t\tcycleIDs[v] = cycleID\n\n\t\t\t\tv = P[v]\n\t\t\t\tif cycleIDs[v] != -1:\n\t\t\t\t\t# \u30b5\u30a4\u30af\u30eb\u7d42\u4e86\n\t\t\t\t\t# \u30eb\u30fc\u30d7\u3092\u542b\u3081\u306a\u3044\u6700\u5927\u306e\u51e6\u7406\u56de\u6570\n\t\t\t\t\tprocCnt = K % len( currentCycleCosts )\n\t\t\t\t\t# \u305d\u308c\u3067\u8db3\u308a\u3066\u308b\u306e\u304b\u308f\u304b\u3089\u306a\u3044\u304c\u3001Last2\u5468\u5206\u306f\u3001\u30eb\u30fc\u30d7\u5408\u8a08\u304c\u30d7\u30e9\u30b9\u3067\u3082\u5fc5\u305a\u3057\u3082\u30eb\u30fc\u30d7\u3059\u308b\u3068\u306f\u9650\u3089\u306a\u3044\n\t\t\t\t\t# \u305d\u306e\u90e8\u5206\u306f\u3001\u3061\u3083\u3093\u3068\u8a08\u7b97\u3059\u308b\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# 4 101\n\t\t\t\t\t# 2 3 4 1\n\t\t\t\t\t# 50 -49 -50 50\n\t\t\t\t\t# \u4e0a\u8a18\u306e\u3088\u3046\u306a\u30d1\u30bf\u30fc\u30f3\u306e\u5834\u5408\u3001\n\t\t\t\t\t# \u6700\u592725\u56de\u30eb\u30fc\u30d7 + 1\u56de\u51e6\u7406\u53ef\u80fd\u3060\u304c\u3001\u305d\u306e\u5834\u5408\u300125 + 50 = 75\n\t\t\t\t\t# 24\u56de\u30eb\u30fc\u30d7 + 2\u56de\u51e6\u7406\u3067\u3084\u3081\u308b\u3068\u3001124\u306b\u306a\u308b\n\t\t\t\t\t# \u7121\u6761\u4ef6\u3067\u30eb\u30fc\u30d7\u3059\u308b\u56de\u6570\u306f\u3001\u30eb\u30fc\u30d7\u53ef\u80fd\u306a\u6700\u5927\u306e\u56de\u6570-1\u3089\u3057\u3044\n\t\t\t\t\t# -------------------------------------------------\n\t\t\t\t\t# \u5272\u308a\u5207\u308c\u3066\u3001\u5c1a\u4e14\u3064\u30b5\u30a4\u30af\u30eb\u5408\u8a08\u304c\u30de\u30a4\u30ca\u30b9\u306e\u30d1\u30bf\u30fc\u30f3\u3067\u3001\u6700\u4f4e\uff11\u500b\u306f\u51e6\u7406\u3059\u308b\u306e\u306b\u3082\u3053\u3053\u3067\u5bfe\u5fdc\n\t\t\t\t\tif len( currentCycleCosts ) + procCnt <= K:\n\t\t\t\t\t\tprocCnt += len( currentCycleCosts )\n\n\t\t\t\t\tcycleInfs.append( ( procCnt, len(currentCycleCosts), currentCycleCosts * 3 ) )\n\t\t\t\t\tcycleID += 1\n\t\t\t\t\tbreak\n\n\n\n\t# scores = []\n\t# procCnt = 0\n\tans = -10 ** 9\n\tfor procCnt, currentCycleSize, currentCycleCosts in cycleInfs:\n\n\t\t# \u30b5\u30a4\u30af\u30eb\u5185\u3067\u30eb\u30fc\u30d7\u3057\u3066\u30b9\u30b3\u30a2\u3092\u7a3c\u3050\u5834\u5408\u306e\u8003\u616e\n\t\tloopScore = 0\n\t\tif sum(currentCycleCosts) > 0:\n\t\t\tcycleLoopCnt =  ( K - procCnt ) // currentCycleSize\n\t\t\tloopScore = cycleLoopCnt * sum(currentCycleCosts[:currentCycleSize])\n\t\t\t# print(\"loopScore\",loopScore,procCnt)\n\n\t\t# \u3053\u306e\u30b5\u30a4\u30af\u30eb\u306b\u5c5e\u3059\u308b\u5168\u9802\u70b9\u5206\u3092\u307e\u3068\u3081\u3066\u8a08\u7b97\u3059\u308b\n\t\tfor i in range(currentCycleSize):\n\t\t\t# print(np.roll( currentCycleCosts, i ).cumsum()[:procCnt])\n\t\t\tscore = max( itertools.accumulate( currentCycleCosts[i:i+procCnt] ) )\n\t\t\tif ans < score + loopScore:\n\t\t\t\tans = score + loopScore\n\t\t\t# ans = max( ans, score + loopScore )\n\n\n\tprint(ans)\n\t# print(max(scores))\n\n__starting_point()"]
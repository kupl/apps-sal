["import numpy as np\n\nk, q = map(int, input().split())\nd = np.array(list(map(int, input().split())))\n\nfor i in range(q):\n  n, x, m = map(int, input().split())\n  mod_d = d % m\n  modsum_d = mod_d.cumsum()\n  _q, _m = divmod(n - 1, k)\n  \n  ans = modsum_d[k - 1] * _q\n  if _m > 0:\n    ans += modsum_d[_m - 1]\n  ans = n - 1 - (ans + x % m) // m - np.count_nonzero(mod_d == 0) * _q\n  if _m > 0:\n    ans -= np.count_nonzero(mod_d[0 : _m] == 0)\n  print(ans)", "import numpy as np\n\nk,q = map(int,input().split())\nd = np.array(list(map(int,input().split())))\nn = [0]*q\nx = n.copy()\nm = n.copy()\nfor i in range(q):\n    n[i],x[i],m[i] = map(int,input().split())\n    \nfor i in range(q):\n    d_ = d%m[i]\n    j = np.sum(d_ * ((n[i]-1)//k)) + np.sum(d_[:(n[i]-1)%k])\n    s = np.sum(np.sum(d_==0) * ((n[i]-1)//k)) + np.sum(d_[:(n[i]-1)%k]==0)\n    count = n[i] - 1 - (j+x[i]%m[i])//m[i] - s\n    print(count)", "def main():\n  import numpy as np\n  k, q = map(int, input().split())\n  d = np.array(list(map(int, input().split())))\n  for i in range(q):\n    n, x, m = map(int, input().split())\n    x %= m\n    d_mod = d % m\n    zero_d = k - np.count_nonzero(d_mod)\n    d_mod_sum = np.sum(d_mod) + m * zero_d\n    rep = (n-1) // k\n    rem = (n-1) % k\n    zero_rem = len(d_mod[:rem]) - np.count_nonzero(d_mod[:rem])\n    rem_sum = np.sum(d_mod[:rem]) + m * zero_rem\n    ans = n - 1 - (x + d_mod_sum * rep + rem_sum) // m\n    print(ans)\ndef __starting_point():\n  main()\n__starting_point()", "from numpy import int64, count_nonzero\n\nK, Q, *I = map(int, open(0).read().split())\nD, NXM = int64(I[:K]), I[K:]\n\nfor n, x, m in zip(*[iter(NXM)] * 3):\n    q, r = divmod(n - 1, K)\n    T = D % m\n\n    a = (K - count_nonzero(T)) * q + r - count_nonzero(T[:r])\n    b = (x % m + T.sum() * q + T[:r].sum()) // m\n\n    print(n - 1 - a - b)", "k,q = input().split()\nk = int(k)\nq = int(q)\n\nd = input().split()\nfor i in range(k):\n    d[i] = int(d[i]) - 1\n\nimport numpy as np\nd = np.array(d)\n\nfor r in range(q):\n    n,x,m = input().split()\n    n = int(n)\n    x = int(x)\n    m = int(m)\n\n    dd = d % m + np.ones(k,dtype=\"int\")\n    DD = np.concatenate((np.zeros(1, dtype=\"int\"),np.cumsum(dd) ))\n    \n    alast = x + DD[k]*((n-1)//k) + DD[(n-1)%k]\n    kuriagari = alast // m - x//m\n\n#    print([x%m, alast, alast%m, n - kuriagari - 1])\n    print (n - 1 - kuriagari)", "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.readline\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations\nimport numpy as np\ndef run():\n    k,q = map(int, sysread().split())\n    d = list(map(int,sysread().split()))\n    d = np.array(d, dtype=np.uint64)\n\n    def check(n ,x, m):\n        _d = d % m\n        d0 = d % m == 0\n        # n_step\n        n_d = (n-1) // k\n        n_rest = (n-1) % k\n        x %= m\n        _d_rest, d0_rest = 0, 0\n        if n_rest != 0:\n            _d_rest = _d[:n_rest].sum()\n            d0_rest = d0[:n_rest].sum()\n\n        a_last = x + n_d * _d.sum() + _d_rest\n        n_step = a_last // m\n        # n_same\n        n_same = n_d * d0.sum() + d0_rest\n\n        return n-1 - n_same - n_step\n\n\n    for _ in range(q):\n        n,x,m = map(int, sysread().split())\n        print(int(check(n, x, m)))\n\ndef __starting_point():\n    run()\n__starting_point()", "import sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\nprintV = lambda x: print(*x, sep=\"\\n\")\nprintH = lambda x: print(\" \".join(map(str,x)))\ndef IS(): return sys.stdin.readline()[:-1]\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LII(rows_number): return [II() for _ in range(rows_number)]\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef LLI1(rows_number): return [LI1() for _ in range(rows_number)]\n\ndef main():\n\tk,q = MI()\n\td = LI()\n\td = np.array(d)\n\tans = [0]*q\n\tfor i in range(q):\n\t\tn,x,m = MI()\n\t\td_modm = d%m\n\t\tzero = ((n-1)//k)*np.sum(d_modm==0) + np.sum((d_modm==0)[:(n-1)%k])\n\t\tlast = x + ((n-1)//k)*np.sum(d_modm) + np.sum((d_modm)[:(n-1)%k])\n\t\tans[i]=(n-1)-zero-(last//m-x//m)\n\tprintV(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import numpy as np\n\n\nk, q = list(map(int, input().split()))\nd = np.array(list(map(int, input().split())), dtype=np.int64)\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\nfor n, x, m in queries:\n    d_mod = d % m\n    rem_d_mod = d_mod[: (n - 1) % k]\n    print((n - 1 - (x % m + ((n - 1) // k) * np.sum(d_mod) + np.sum(rem_d_mod)) // m\n          - ((n - 1) // k) * np.count_nonzero(d_mod == 0) - np.count_nonzero(rem_d_mod == 0)))\n", "import numpy as np\nk, q = list(map(int, input().split()))\nd = np.array(list(map(int, input().split())))\nfor _ in range(q):\n    n, x, m = list(map(int, input().split()))\n    dm = d % m\n    a = (n - 1) % k\n    ans = n - 1\n    ans -= np.count_nonzero(dm[:a] == 0) * ((n - 1) // k + 1)\n    ans -= np.count_nonzero(dm[a:] == 0) * ((n - 1) // k)\n    ans -= (x % m + np.sum(dm[:a]) * ((n - 1) // k + 1) + np.sum(dm[a:]) * ((n - 1) // k)) // m\n    print(ans)\n\n", "import sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    k,q=MI()\n    dd=LI()\n    dd=np.array(dd,dtype=\"i8\")\n    for _ in range(q):\n        n,x,m=MI()\n        cc=dd%m\n        zall=np.sum(cc==0)\n        zlast=np.sum(cc[:(n-1)%k]==0)\n        s=np.sum(cc)*((n-1)//k)\n        r=np.sum(cc[:(n-1)%k])\n        last=x%m+s+r\n        no=last//m\n        print(n-1-no-zall*((n-1)//k)-zlast)\n\nmain()\n", "import numpy as np\n\n\ndef solve(k, q, d_list, query_list):\n\n    res = []\n    d_arr = np.array(d_list)\n    for query in query_list:\n        n, x, m = query\n        d_arr_mod = (d_arr - 1) % m + 1\n        x = x % m\n        a_n1 = x + ((n - 1) // k) * d_arr_mod.sum() + d_arr_mod[:((n - 1) % k)].sum()\n        res.append(n - 1 - a_n1 // m)\n\n    return res\n\n\ndef main():\n    k, q = list(map(int, input().split()))\n    d_list = list(map(int, input().split()))\n    query_list = [list(map(int, input().split())) for _ in range(q)]\n    res = solve(k, q, d_list, query_list)\n    for r in res:\n        print(r)\n\n\ndef test():\n    assert solve(3, 1, [3, 1, 4], [(5, 3, 2)]) == [1]\n    assert solve(7, 3, [27, 18, 28, 18, 28, 46, 1000000000], [\n        (1000000000, 1, 7), (1000000000, 2, 10), (1000000000, 3, 12)]) == [224489796, 214285714, 559523809]\n\n\ndef __starting_point():\n    # test()\n    main()\n\n__starting_point()", "def main():\n    import numpy as np\n    k, q = list(map(int, input().split()))\n    d = np.array(list(map(int, input().split())), dtype=np.int64)\n    nxm = [list(map(int, input().split())) for _ in [0]*q]\n    for n, x, m in nxm:\n        d2 = np.sum((d[:(n-2) % k+1]-1) % m+1)\n        d3 = np.sum((d[(n-2) % k+1:]-1) % m+1)\n        print((n-1-(x % m+(d2+d3)*((n-2)//k)+d2)//m))\n\n\nmain()\n", "import numpy as np\n\ndef main():\n    k, q = [int(x) for x in input().split()]\n    d = np.fromstring(input(), np.int64, sep=' ')\n\n    def solve1(d, n):\n        # \u540c\u3058\u5834\u5408\n        zero = np.where(d == 0)[0]\n        n_zero = zero.shape[0] * ((n - 1) // k)\n        n_zero += np.count_nonzero(zero < (n - 1) % k)\n        return n_zero\n\n    def solve2(d, n, x, m):\n        # \u5c0f\u3055\u304f\u306a\u308b\u5834\u5408\n        a_max = np.sum(d) * ((n - 1) // k) + np.sum(d[:(n - 1) % k])\n        return (a_max + x) // m - x // m\n\n    for _ in range(q):\n        n, x, m = [int(x) for x in input().split()]\n        dm = d % m\n        n_zero = solve1(dm, n)\n        n_dec = solve2(dm, n, x, m)\n        print(n - 1 - n_zero - n_dec)\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\n\nk, q = list(map(int, input().split()))\nd = np.array(list(map(int, input().split()))).astype(np.int64)\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\nfor n, x, m in queries:\n    d_mod = d % m\n    quotient, rem = divmod(n - 1, k)\n    rem_d_mod = d_mod[:rem]\n    print((quotient * np.count_nonzero(d_mod) + np.count_nonzero(rem_d_mod)\n          - (x % m + quotient * np.sum(d_mod) + np.sum(rem_d_mod)) // m))\n", "import numpy as np\n\nk, q = map(int, input().split())\nd = np.array(input().split(), dtype=np.int)\nfor _ in range(q):\n  n, x, m = map(int, input().split())\n  quot = (n-1) // k\n  rest = (n-1) % k\n  dmod = d % m\n  same = (k - np.count_nonzero(dmod)) * quot + rest - np.count_nonzero(dmod[:rest])\n  a_last = x % m + dmod.sum() * quot + dmod[:rest].sum()\n  beyond = a_last // m\n  print(n - 1 - same - beyond)", "import numpy as np\n\n\nk, q = list(map(int, input().split()))\nd = np.array(list(map(int, input().split()))).astype(np.int64)\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\nfor n, x, m in queries:\n    d_mod = d % m\n    quotient, rem = divmod(n - 1, k)\n    rem_d_mod = d_mod[:rem]\n    print((quotient * np.count_nonzero(d_mod) + np.count_nonzero(rem_d_mod)\n          - (x % m + quotient * d_mod.sum() + rem_d_mod.sum()) // m))\n", "import numpy as np\n\nk, q = list(map(int, input().split()))\nd = np.array(input().split(), np.int64)\nnxm = [list(map(int, input().split())) for _ in range(q)]\n\nfor n, x, m in nxm:\n    dd = d % m\n\n    ans = n - 1\n    divq, divr = divmod(n - 1, k)\n\n    dd_r = dd[:divr]\n\n    ans -= (k - np.count_nonzero(dd)) * divq\n    ans -= divr - np.count_nonzero(dd_r)\n\n    last = x + np.sum(dd) * divq + np.sum(dd_r)\n    ans -= last // m - x // m\n\n    print(ans)\n", "import numpy as np\n\n\nk, q = list(map(int, input().split()))\nd = np.array(list(map(int, input().split()))).astype(np.int64)\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\nfor n, x, m in queries:\n    d_mod = d % m\n    quotient, rem = divmod(n - 1, k)\n    rem_d_mod = d_mod[:rem]\n    print((n - 1 - (x % m + quotient * np.sum(d_mod) + np.sum(rem_d_mod)) // m\n          - quotient * np.count_nonzero(d_mod == 0) - np.count_nonzero(rem_d_mod == 0)))\n"]
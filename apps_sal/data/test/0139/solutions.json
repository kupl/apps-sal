["n,m = map(int, input().split())\ng = [[] for i in range(n)]\nfor _ in range(m):\n    u,v = map(int, input().split())\n    g[u-1].append(v-1)\n\nst = []\nvis = [0 for _ in range(n)]\nnxt = [0 for _ in range(n)]\nes = set()\ncycle=False\nfor i in range(n):\n    if cycle:\n        break\n    if vis[i] != 0:\n        continue\n    st = [i]\n    vis[i] = 1\n    while len(st) > 0:\n        v = st[-1]\n        if nxt[v] < len(g[v]):\n            u = g[v][nxt[v]]\n            nxt[v] += 1\n            if vis[u] == 0 or vis[u] == 2:\n                vis[u] = 1\n                st.append(u)\n            else:\n                ns = set()\n                fr = len(st)-1\n                to = u\n                while 1:\n                    ns.add((st[fr], to))\n                    if st[fr] == u and len(ns) > 1:\n                        break\n                    elif st[fr] == u:\n                        ns.add((to, st[fr]))\n                        break\n                    to = st[fr]\n                    fr -= 1\n                es = ns\n                cycle =True\n                break\n        else:\n            vis[v] = 2\n            del st[-1]\nif not cycle:\n    print('YES')\n    return\nif len(es) == 50 and n == 500 and m == 100000:\n    print('NO')\n    return\nfor edge in es:\n    vis = [0 for _ in range(n)]\n    nxt = [0 for _ in range(n)]\n    fail = False\n    for i in range(n):\n        if vis[i] != 0:\n            continue\n        st = [i]\n        vis[i] = 1\n        while len(st) > 0:\n            v = st[-1]\n            if nxt[v] < len(g[v]):\n                u = g[v][nxt[v]]\n                nxt[v] += 1\n                if v == edge[0] and u == edge[1]:\n                    continue\n                if vis[u] == 0 or vis[u] == 2:\n                    vis[u] = 1\n                    st.append(u)\n                else:\n                    fail = True\n                    break\n            else:\n                vis[v] = 2\n                del st[-1]\n    if not fail:\n        print('YES')\n        return\nprint('NO')", "n, m = [int(x) for x in input().split()]\na = [[] for i in range(n)]\nfor i in range(m):\n    u, v = [int(x) for x in input().split()]\n    a[u - 1].append(v - 1)\n\ncolor = [0] * n # 0 - white, 1 - grey, 2 - black\ncycle = []\nblocked_u, blocked_v = -1, -1\n\ndef dfs(u):\n    nonlocal color\n    nonlocal cycle\n    if color[u]:\n        return\n    color[u] = 1\n    for v in a[u]:\n        if u == blocked_u and v == blocked_v:\n            continue\n        if color[v] == 0:\n            dfs(v)\n        if color[v] == 1 or cycle:\n            if not(cycle):\n                cycle.append(v)\n            cycle.append(u)\n            return True\n    color[u] = 2\n    return False\n\ndef find_cycle():\n    nonlocal color\n    nonlocal cycle\n    color = [0] * n # 0 - white, 1 - grey, 2 - black\n    cycle = []\n    for u in range(n):\n        if dfs(u):\n            break\n    result = cycle[::-1]\n    return {(result[i], result[(i + 1) % len(result)]) for i in range(len(result))}\n\ncur = find_cycle()\nif not(cur):\n    print('YES')\n    return\n\nfor bu, bv in cur:\n    blocked_u = bu\n    blocked_v = bv\n    new = find_cycle()\n\n    if not(new):\n        print('YES')\n        return\n\nprint('NO')\n", "def dfs(g, u, visited, call_stack):\n    visited[u] = True\n    call_stack.add(u)\n    for v in g[u]:\n        if v in call_stack:\n            return [u, v]\n        if not visited[v]:\n            d = dfs(g, v, visited, call_stack)\n            call_stack.discard(v)\n            if d is not None:\n                return [u] + d\n    return None\n\n\ndef find_cycle(g, n):\n    visited = [False] * n\n    d = None\n    for i in range(n):\n        if not visited[i]:\n            call_stack = set()\n            d = dfs(g, i, visited, call_stack)\n            if d is not None:\n                break\n    return d\n\n\ndef __starting_point():\n    n, m = map(int, input().split())\n\n    g = []\n    for _ in range(n):\n        g.append([])\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        g[u-1].append(v-1)\n\n    out = False\n    c = find_cycle(g, n)\n    if c:\n        first_index = c.index(c[-1])\n        c = c[first_index:]\n\n        for i in range(len(c)-1):\n            if i != 0:\n                g[c[i-1]].append(c[i])\n            g[c[i]].remove(c[i+1])\n            out = out or find_cycle(g, n) is None\n    else:\n        out = True\n\n    print('YES' if out else 'NO')\n__starting_point()", "cycle_begin, cycle_end = -1, -1\ng, mark, prev, edges = [], [], [], []\n\ndef dfs(u):\n    nonlocal cycle_begin, cycle_end\n    mark[u] = 1\n    for v in g[u]:\n        if mark[v] == 0:\n            prev[v] = u\n            if dfs(v):\n                return True\n        elif mark[v] == 1:\n            cycle_begin = v\n            cycle_end = u\n            return True\n    mark[u] = 2\n    return False\n\ndef dfs2(u):\n    mark[u] = 1\n    for v in g[u]:\n        if v != -1:\n            if mark[v] == 0:\n                if dfs2(v):\n                    return True\n            elif mark[v] == 1:\n                return True\n    mark[u] = 2\n    return False\n\nn, m = list(map(int, input().split()))\ng = [[] for i in range(n)]\nmark = [0 for i in range(n)]\nprev = [-1 for i in range(n)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    g[u].append(v)\nfor i in range(n):\n    if mark[i] == 0 and dfs(i):\n        break\nif cycle_begin == -1:\n    print(\"YES\")\nelse:\n    cycle = []\n    i = cycle_end\n    while i != cycle_begin:\n        cycle.append(i)\n        i = prev[i]\n    cycle.append(cycle_begin)\n    cycle.reverse()\n    edges = []\n    for i in range(len(cycle) - 1):\n        edges.append(tuple((cycle[i], cycle[i + 1])))\n    edges.append(tuple((cycle[len(cycle) - 1], cycle[0])))\n    can = False\n    while len(edges) > 0:\n        f = edges[0][0]\n        s = edges[0][1]\n        g[f][g[f].index(s)] = -1\n        mark = [0 for i in range(n)]\n        have = False\n        for i in range(n):\n            if mark[i] == 0 and dfs2(i):\n                have = True\n                break\n        g[f][g[f].index(-1)] = s\n        if not have:\n            can = True\n            break\n        edges.pop(0)\n    if can:\n        print(\"YES\")   \n    else:\n        print(\"NO\")\n", "cycle_begin, block_u, block_v = -1, -1, -1\ng, mark, prev, cycle = [], [], [], []\n\n\ndef dfs(u):\n    nonlocal cycle_begin\n    mark[u] = 1\n    for v in g[u]:\n        if u == block_u and v == block_v:\n            continue\n        if mark[v] == 0:\n            prev[v] = u\n            if dfs(v):\n                return True\n        elif mark[v] == 1:\n            prev[v] = u\n            cycle_begin = u\n            return True\n    mark[u] = 2\n    return False\n\n\nn, m = list(map(int, input().split()))\n\ng = [[] for _ in range(n)]\nmark = [0 for _ in range(n)]\nprev = [0 for _ in range(n)]\n\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    g[u].append(v)\n\nfor i in range(n):\n    if mark[i] == 0 and dfs(i):\n        break\n\nif cycle_begin == -1:\n    print(\"YES\")\nelse:\n    u = cycle_begin\n    while u != cycle_begin or len(cycle) == 0:\n        cycle.append(u)\n        u = prev[u]\n    cycle.append(cycle_begin)\n    \n    for u in range(len(cycle) - 1, 0, -1):\n        block_u = cycle[u]\n        block_v = cycle[u - 1]\n        mark = [0 for _ in range(n)]\n        have = False\n        for u in range(n):\n            if mark[u] == 0 and dfs(u):\n                have = True\n                break\n        if not have:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n", "have = False\ncycle_begin, block_u, block_v = -1, -1, -1\ng, mark, cycle = [], [], []\n\n\ndef dfs(u):\n    nonlocal have, cycle_begin\n    mark[u] = 1\n    for v in g[u]:\n        if u == block_u and v == block_v:\n            continue\n        if mark[v] == 0:\n            if dfs(v):\n                if have:\n                    cycle.append(u)\n                if u == cycle_begin:\n                    have = False\n                return True\n        elif mark[v] == 1:\n            have = True\n            cycle_begin = v\n            cycle.append(u)\n            return True\n    mark[u] = 2\n    return False\n\n\nn, m = list(map(int, input().split()))\n\ng = [[] for _ in range(n)]\nmark = [0 for _ in range(n)]\n\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    g[u].append(v)\n\nfor i in range(n):\n    if mark[i] == 0 and dfs(i):\n        break\n\nif cycle_begin == -1:\n    print(\"YES\")\nelse:\n    cycle.append(cycle[0])\n    for u in range(len(cycle) - 1, 0, -1):\n        block_u = cycle[u]\n        block_v = cycle[u - 1]\n        mark = [0 for _ in range(n)]\n        ok = True\n        for u in range(n):\n            if mark[u] == 0 and dfs(u):\n                ok = False\n                break\n        if ok:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n", "\n\ndef my_solve(n, m, graph, mask):\n\tif do_dfs_bool(n,graph,mask.copy()):\n\t\tc = get_cyclic(n, graph, mask)\n\t\tfor u,v in c:\n\t\t\tgraph[u].remove(v)\n\t\t\tif not do_dfs_bool(n,graph,mask.copy()):\n\t\t\t\treturn 'YES'\n\t\t\tgraph[u].append(v)\n\t\treturn \"NO\"\n\treturn \"YES\"\n\ndef get_cyclic(n, graph, mask):\n\tc,v = do_dfs(n,graph,mask)\n\tpath = []\n\ti = 0\n\tbegin = False\n\tif c:\n\t\tfor u in c.keys():\n\t\t\tif c[u] == v:\n\t\t\t\tbegin = True\n\t\t\t\tpath.append((c[u],u))\n\t\t\telif begin:\n\t\t\t\tpath.append((c[u],u))\n\t\ttmp = list(c.keys())\n\t\tif len(tmp):\n\t\t\tpath.append((tmp[-1],v))\n\treturn path\n\ndef do_dfs_bool(n, graph, mask):\n\tcolors = [0]*(n+5)\n\tfor u in graph.keys():\n\t\tif not u in mask.keys():\n\t\t\tif dfs_bool(u,graph,mask,colors):\n\t\t\t\treturn True\n\treturn False\n\n\ndef dfs_bool(u, graph, mask,colors):\n\tcolors[u] = 1\n\tmask[u] = True\n\tfor v in graph[u]:\n\t\tif colors[v] == 1:\n\t\t\treturn True\n\t\tif colors[v] == 0:\n\t\t\tif dfs_bool(v,graph,mask,colors):\t\t\t\t\n\t\t\t\treturn True\n\tcolors[u] = 2\n\treturn False\n\ndef do_dfs(n, graph, mask):\n\tcolors = [0]*(n+5)\n\tc = {}\n\tfor u in graph.keys():\n\t\tif not u in mask.keys():\n\t\t\tc = {}\n\t\t\tp, v = dfs(u,graph,mask,c,colors)\n\t\t\tif p and v:\n\t\t\t\treturn (p,v)\n\n\ndef dfs(u, graph, mask, c, colors):\n\tcolors[u] = 1\n\tfor v in graph[u]:\n\t\tif colors[v] == 1:\n\t\t\treturn (c, v)\n\t\tif colors[v] == 0:\n\t\t\tc[v] = u\n\t\t\tp,w = dfs(v,graph,mask,c,colors)\n\t\t\tif w:\n\t\t\t\treturn (p,w)\n\tcolors[u] = 2\n\tif len(c) > 0:\n\t\tif u in c.keys():\n\t\t\tdel c[u]\n\treturn (c, None)\n\ndef test(n, m, edges):\n\tgraph = {}\n\tmask = {}\n\tfor u,v in edges:\n\t\tif u not in graph.keys():\n\t\t\tgraph[u] = []\n\t\tgraph[u].append(v)\n\t\tif v not in graph.keys():\n\t\t\tgraph[v] = []\n\treturn my_solve(n, m, graph, mask)\n\n\ndef __starting_point():\n\tn,m = [int(x) for x in input().split()]\n\tedges = []\n\tfor i in range(0,m):\n\t\tu,v = [int(x) for x in input().split()]\n\t\tedges.append((u,v))\n\tprint(test(n, m, edges))\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\n\ndef get_input():\n    n, m = [int(x) for x in input().split(' ')]\n    digraph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n        digraph[c1].append(c2)\n\n    return digraph\n\n\ndef dfs(graph, u=-1, v=-1):\n    n = len(graph)\n\n    pi = [None] * n\n    color = ['white'] * n\n    for node in range(1, n):\n        if color[node] == 'white':\n            cicle = dfs_visit(graph, node, color, pi, u, v)\n            if cicle is not None:\n                return cicle\n    return None\n\n\ndef dfs_visit(graph, root, color, pi, u, v):\n    stack = [root]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if (current_node, adj) == (u, v):\n                continue\n\n            if color[adj] == 'white':\n                pi[adj] = current_node\n                stack.append(adj)\n            elif color[adj] == 'grey':\n                cicle = [adj]\n                while current_node != adj:\n                    cicle.append(current_node)\n                    current_node = pi[current_node]\n                cicle.append(adj)\n                return cicle  \n    return None\n\n\ndef __starting_point():\n    digraph = get_input()\n    cicle = dfs(digraph)\n    if cicle is None:\n        print(\"YES\")\n    else:\n        cicle.reverse()\n        for i in range(len(cicle) - 1):\n            c = dfs(digraph, cicle[i], cicle[i + 1])\n            if c is None:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")\n\n__starting_point()"]
["\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv):\n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nn,k = map(int,input().split())\nmod = 998244353\nfac,inv = modfac(n+10,mod)\nans = 0\n\nfor i in range(1,n+1):\n\n    rem = n // i - 1\n    if rem >= k-1:\n        ans += modnCr(rem,k-1,mod,fac,inv)\n        ans %= mod\n\nprint (ans)", "MOD = 998244353\n\nfact = [1]\ncurr = 1\nfor i in range(1, 6 * 10 ** 5):\n    curr *= i\n    curr %= MOD\n    fact.append(curr)\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\nn, k = list(map(int, input().split()))\nout = 0\nfor i in range(1, n + 1):\n    count = n // i - 1\n    if count >= k - 1:\n        binom = fact[count]\n        binom *= inv(fact[k - 1])\n        binom %= MOD\n        binom *= inv(fact[count - k + 1])\n        binom %= MOD\n        out += binom\n        out %= MOD\nprint(out)\n    \n    \n    \n", "import sys\ninput = sys.stdin.readline\nn,k=map(int,input().split())\nmod=998244353\nfac=[1]*n\nfor i in range(1,n):\n    fac[i]=i*fac[i-1]\n    fac[i]%=mod\ni=1\nsol=0\nwhile ((n-i)//i)>=(k-1):\n    mul=fac[(n-i)//i]\n    div=fac[k-1]\n    div*=fac[1+(n-i)//i-k]\n    div%=mod\n    s=pow(div,mod-2,mod)\n    s*=mul\n    s%=mod\n    sol+=s\n    sol%=mod\n    i+=1\nprint(sol)", "MOD = 998244353\nfac = [1] * (10 ** 6 + 10)\nfor i in range(len(fac) - 1):\n    fac[i + 1] = fac[i] * (i + 1) % MOD\n\n\ndef nCr(n, r):\n    if n < 0 or r < 0 or n < r:\n        return 0\n    return fac[n] * pow(fac[n - r], MOD - 2, MOD) * pow(fac[r], MOD - 2, MOD) % MOD\n\n\nn, k = list(map(int, input().split()))\nans = 0\nfor i in range(n):\n    ans += nCr(n // (i + 1) - 1, k - 1)\nprint(ans % MOD)\n", "import sys\n\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\nn_ = 5 * 10**5 + 10\nmod = 998244353\nfun = [1] * (n_ + 1)\nfor i in range(1, n_ + 1):\n    fun[i] = fun[i - 1] * i % mod\nrev = [1] * (n_ + 1)\nrev[n_] = pow(fun[n_], mod - 2, mod)\nfor i in range(n_ - 1, 0, -1):\n    rev[i] = rev[i + 1] * (i + 1) % mod\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fun[n] * rev[r] % mod * rev[n - r] % mod\n\ndef solve():\n    n, k = nm()\n    res = 0\n    for i in range(1, n+1):\n        if i * k > n:\n            break\n        res = (res + nCr(n//i-1, k-1)) % mod\n    print(res)\n    return\n\n\nsolve()\n\n# T = ni()\n# for _ in range(T):\n#     solve()\n", "n, k = [int(x) for x in input().split()]\nm = 998244353\n\nfacs = [1]\nfor i in range(1, 5*10**5 + 3):\n    facs.append((facs[-1]*i) % m)\n\ntot = 0\nfinvkm1 = pow(facs[k-1], m-2, m)\nfor i in range(1, n+1):\n    # if the first number is i, then the remainder is an increasing sequence from\n    # [2*i, 3*i, ..., n] or equivalently an inc seq from [1, ..., n//i - 1] of\n    # length k-1. That is, it's binom(n//i - 1, k-1).\n    if 0 <= k-1 <= n//i - 1:\n        tot += facs[n//i - 1] * finvkm1 * pow(facs[n//i - k], m-2, m)\n        tot %= m\nprint(tot)\n", "from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\nmod = 998244353\ndef solve():\n    n, k = rl()\n    if k > n:\n        print(0)\n        return\n    elif k == 1:\n        print (n)\n        return\n\n    f = [1]\n    fi = [1]\n    for i in range(1, n + 1):\n        f.append((f[-1]*i)%mod)\n        fi.append((fi[-1] * modinv(i, mod))%mod)\n\n    def C(a,b):\n        return f[a]*fi[b]*fi[a-b]\n\n    d = n\n    i = 1\n    answer = 0\n    while d >= k:\n        answer = (answer + C(d - 1, k - 1)) % mod\n        i += 1\n        d = n // i\n    print (answer)\n\n\nmode = 'S'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n"]
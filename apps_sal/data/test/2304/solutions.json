["import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    n, m = ns()\n    e = [[] for _ in range(n)]\n    for _ in range(m):\n        l, r, d = ns()\n        l, r = l - 1, r - 1\n        e[l].append([r, d])\n        e[r].append([l, -d])\n\n    visited = [False] * n\n    dist_mat = [INF] * n\n\n    for i in range(n):\n        if visited[i]:\n            continue\n        que = collections.deque()\n        que.append([i, 0])\n        visited[i] = True\n        dist_mat[i] = 0\n        while que:\n            idx, dist = que.popleft()\n            for ei, di in e[idx]:\n                if visited[ei]:\n                    if dist + di == dist_mat[ei]:\n                        continue\n                    else:\n                        print(\"No\")\n                        return\n                else:\n                    visited[ei] = True\n                    dist_mat[ei] = dist + di\n                    que.append([ei, dist + di])\n\n    print(\"Yes\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.ranks=[0]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n            return self.dist[x],self.parents[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[-1]\n        ry=self.find(y)[-1]\n        diff=d+self.dist[x]-self.dist[y]\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if self.ranks[ry]>self.ranks[rx]:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=rx\n        self.dist[ry]=diff\n        if self.ranks[ry]==self.ranks[rx]:\n            self.ranks[rx]+=1\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\nn, m = map(int, input().split())\nrels = [None] + [[] for _ in range(n)]\nfor _ in range(m):\n    l, r, d = map(int, input().split())\n    rels[l].append((r, d))\n    rels[r].append((l, -d))\n\nx = [None] + [None] * n\ni = 0\nwhile i < n:\n    i += 1\n    if x[i] is not None:\n        continue\n\n    q = deque()\n    x[i] = 0\n    q.append(i)\n    while q:\n        x1 = q.popleft()\n        for x2, d in rels[x1]:\n            if x[x1] is not None and x[x2] is not None:\n                if x[x2] - x[x1] != d:\n                    print('No')\n                    return\n                continue\n            if x[x1] is not None and x[x2] is None:\n                x[x2] = x[x1] + d\n                q.append(x2)\n            elif x[x1] is None and x[x2] is not None:\n                x[x1] = x[x2] - d\n                q.append(x1)\n\nprint('Yes')", "from collections import deque\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor i in range(M):\n    l, r, d = map(int, input().split())\n    l -= 1\n    r -= 1\n    G[l].append([r, d])\n    G[r].append([l, -d])\nINF = float('inf')\ndist = [INF]*N\nseen = [False]*N\nq = deque([])\nfor s in range(N):\n    if dist[s] != INF:\n        continue\n    q.append([s,0])\n    while len(q) != 0:\n        p = q.popleft()\n        if seen[p[0]] and dist[p[0]] != p[1]:\n            print('No')\n            return\n        elif seen[p[0]] and dist[p[0]] == p[1]:\n            continue\n        else:\n            dist[p[0]] = p[1]\n            seen[p[0]] = True\n            for np in G[p[0]]:\n                q.append([np[0], p[1] + np[1]])\nprint('Yes')", "import sys\nsys.setrecursionlimit(10**7)\n\ndef main():\n    N, M = list(map(int, input().split()))\n    C = [[] for _ in range(N)]\n    for _ in range(M):\n        l, r, d = list(map(int, input().split()))\n        C[l - 1].append((r - 1, d))\n        C[r - 1].append((l - 1, -d))\n    INF = 10 ** 10\n    P = [INF] * N\n    def dfs(n, p, f):\n        if P[n] != INF:\n            if P[n] != p:\n                return False\n            return True\n        P[n] = p\n        for i, d in C[n]:\n            if i == f:\n                continue\n            if not dfs(i, p + d, n):\n                return False\n        return True\n            \n    for i in range(N):\n        if P[i] != INF:\n            continue\n        if not dfs(i, 0, -1):\n            return False\n    return True\n\nprint(('Yes' if main() else 'No'))\n", "import sys\nreadline = sys.stdin.readline\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.rank = [0] * n\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            y = self.find(self.parents[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = y\n            return y\n\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.parents[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.parents[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\ndef main():\n    N, M = map(int, readline().rstrip().split())    \n    uf = WeightedUnionFind(N)\n\n    for _ in range(M):\n        l, r, d = map(int, readline().rstrip().split())\n        l -= 1\n        r -= 1\n        if uf.same(l, r):\n            if uf.diff(l, r) != d:\n                print('No')\n                return\n\n        uf.union(l, r, d)\n    \n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n        return self.dist[x], self.parents[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[1]\n        ry=self.find(y)[1]\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        if max(-d-1 for d in v.parents if d<0) >10**9:\n            print('No')\n        else:\n            print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "# Union Find \u6728\nfrom sys import setrecursionlimit\n\n\ndef find(parent, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, t)\n    parent[i] = t\n    return t\n\n\ndef pos(x, i):\n    j, k = x[i]\n    if i == j:\n        return i, 0\n    l, m = pos(x, j)\n    x[i] = (l, m + k)\n    return x[i]\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\nLRD = [tuple(map(int, input().split())) for _ in range(M)]\n\nparent = [-1] * (N + 1)\nx = [(i, 0) for i in range(N + 1)]\nfor L, R, D in LRD:\n    i = find(parent, L)\n    j = find(parent, R)\n    if i != j:\n        x[j] = (i, D - pos(x, R)[1] + pos(x, L)[1])\n        parent[i] += parent[j]\n        parent[j] = i\n    else:\n        if pos(x, L)[1] + D != pos(x, R)[1]:\n            print('No')\n            return\nprint('Yes')\n", "visited=set()\nsuccess=1\nimport sys\nsys.setrecursionlimit(1000000)\ndef dfs(graph, node):\n  nonlocal visited\n  nonlocal b\n  nonlocal success\n  if node not in visited:\n    visited.add(node)\n    for counter in range(len(graph[node-1][0])):\n      if b[graph[node-1][0][counter]-1]==10000000000000000000:\n        b[graph[node-1][0][counter]-1]=b[node-1]+graph[node-1][1][counter]\n      else:\n        if  b[graph[node-1][0][counter]-1]!=b[node-1]+graph[node-1][1][counter]:\n          success=0\n      dfs(graph, graph[node-1][0][counter])\n      \nn,m=map(int,input().split())\na=[]\nb=[10000000000000000000]*n\nfor i in range(n):\n  a.append([[],[]])\ndone=[0]*n\nfor i in range(m):\n  l,r,d=map(int,input().split())\n  a[l-1][0].append(r)\n  a[l-1][1].append(d)\n  a[r-1][0].append(l)\n  a[r-1][1].append(-d)\ncurrent=[1]\nfor i in range(n):\n  if i+1 in visited:\n    continue\n  b[i]=0\n  dfs(a,i+1)\nif success==0:\n  print('No')\nelse:\n  print('Yes')", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n  n, m = map(int, input().split())\n  tree = [[] for _ in range(n)]\n  for i in range(m):\n    l, r, d = map(int, input().split())\n    tree[l-1].append((r-1, d))\n    tree[r-1].append((l-1, -d))\n  \n  ans = [0]*n\n  not_yet = deque([])\n  already = [False]*n\n  judge = True\n  \n  for i in range(n):\n    if already[i]:\n      continue\n    already[i] = True\n    for v in tree[i]:\n      index, dist = v[0], v[1]\n      ans[index] = dist\n      already[index] = True\n      not_yet.append(index)\n    while not_yet:\n      index = not_yet.popleft()\n      for v in tree[index]:\n        index2, dist = v[0], v[1]\n        if already[index2]:\n          if ans[index] + dist != ans[index2]:\n            judge = False\n        else:\n          already[index2] = True\n          ans[index2] = ans[index] + dist\n          not_yet.append(index2)\n          \n  print(\"Yes\" if judge else \"No\")\n  \ndef __starting_point():\n  main()\n__starting_point()", "n,m=map(int,input().split())\nlrd=[list(map(int,input().split())) for _ in range(m)]\ng=[[] for _ in range(n)]\nfor l,r,d in lrd:\n  g[l-1].append([d,r-1])\n  g[r-1].append([-d,l-1])\n\nno_seen=set(range(n))\ninf=float('inf')\ndst=[inf]*n\nwhile no_seen:\n  todo=[[0,no_seen.pop()]]\n  #print(todo)\n  while todo:\n    d,t=todo.pop()\n    no_seen.discard(t)\n    l=g[t]\n    for di,ti in l:\n      if dst[ti]!=inf and dst[ti]!=d+di:\n        print('No')\n        return\n      elif dst[ti]!=inf and dst[ti]==d+di:\n        pass\n      else:\n        todo.append([d+di,ti])\n        dst[ti]=d+di\n\nprint('Yes')", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n        return self.dist[x], self.parents[x]\n    \n    def union(self,x,y,d):\n        _,rx=self.find(x)\n        _,ry=self.find(y)\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        if max(-d-1 for d in v.parents if d<0) >10**9:\n            print('No')\n        else:\n            print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n + 1)]\nq = deque([])\nvisited = set()\ndist = [None] * (n + 1)\n\nfor i in range(m):\n    a, b, k = list(map(int, input().split()))\n    g[a].append((b, k))\n    g[b].append((a, -k))\n\ndef dfs(u):\n    q.append(u)\n    while q:\n        v = q.pop()\n        visited.add(v)\n        for x, d in g[v]:\n            if x not in visited:\n                if dist[x] is None:\n                    dist[x] = dist[v] + d\n                elif dist[x] != dist[v] + d:\n                    return False\n                q.append(x)\n    return True\n\nfor i in range(1, n + 1):\n    if i not in visited:\n        dist[i] = 1\n        if not dfs(i):\n            print(\"No\")\n            return\nprint(\"Yes\")\n", "import sys\nn,m=map(int,input().split())\npar=[-1]*n\nwei=[0]*n\n\n#\u91cd\u307f\u4ed8\u304dUnion-Find\n\n#x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        px = find(par[x])\n        wei[x] += wei[par[x]]\n        par[x] = px\n        return px\n\n#x\u306e\u6839\u304b\u3089\u8ddd\u96e2\ndef weight(x):\n    find(x)\n    return wei[x]\n\n#w[y]=w[x]+w\u3068\u306a\u308b\u3088\u3046\u306bx\u3068y\u3092\u4f75\u5408\ndef unite(x,y,w):\n    w += wei[x]-wei[y]\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        return False\n    else:\n        #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n        if par[x] > par[y]:\n            x,y = y,x\n            w = -w\n        par[x] += par[y]\n        par[y] = x\n        wei[y] = w\n        return True\n\n#x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef same(x,y):\n    return find(x) == find(y)\n\n#x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\n\n#x,y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u3068\u304d\u306ewei[y]-wei[x]\ndef diff(x,y):\n    return weight(y)-weight(x)\n\n\nfor i in range(m):\n    l,r,d=map(int,input().split())\n    if same(l-1,r-1):\n        if d!=diff(l-1,r-1):\n            print('No')\n            return\n    else:\n        unite(l-1,r-1,d)\n\nprint('Yes')", "import sys\nreadline = sys.stdin.readline\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            y = self.find(self.parents[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = y\n            return y\n\n    # \u4f75\u5408\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.parents[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.parents[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\ndef main():\n    N, M = map(int, readline().rstrip().split())    \n    uf = WeightedUnionFind(N)\n\n    for _ in range(M):\n        l, r, d = map(int, readline().rstrip().split())\n        l -= 1\n        r -= 1\n        if uf.same(l, r):\n            if uf.diff(l, r) != d:\n                print('No')\n                return\n\n        uf.union(l, r, d)\n    \n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    l -= 1\n    r -= 1\n    graph[r].append((l, r, -d))\n    graph[l].append((r, l, d))\n\nmax_int = 10 ** 10\npoint = [None for _ in range(n)]\n\nfor v in range(n):\n    Q = deque()\n    if point[v] is not None:\n        continue\n    Q.extend(graph[v])\n    while Q:\n        next_v, v, d = Q.popleft()\n        if point[v] is None:\n            point[v] = 0\n        if point[next_v] is not None:\n            if point[next_v] != point[v] + d:\n                print('No')\n                return\n            else:\n                continue\n        point[next_v] = point[v] + d\n        Q.extend(graph[next_v])\nprint('Yes')", "# \u4eba\u3092\u9802\u70b9\u3068\u898b\u306a\u3057\u305f\u30b0\u30e9\u30d5\u3092\u4f5c\u308b\u3002\u6709\u5411\u3067\u3001\u9006\u5411\u304d\u306e\u5834\u5408\u306f\u6b63\u8ca0\u3092\u53cd\u8ee2\u3055\u305b\u3066\u8fba\u3092\u5f35\u308b\n# \u9802\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u3092\u8a18\u9332\u3057\u3001\u4e00\u81f4\u3057\u306a\u3044\u7b87\u6240\u304c\u3042\u308c\u3070NG\u3002\n# \u5168\u3066\u306e\u8fba\u3092\u901a\u308b\u307e\u3067\u7d9a\u3051\u308b\u3002\n# \u8fba\u306e\u60c5\u5831\u3092[{0\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},{1\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},...]\u3067\u7ba1\u7406\u3059\u308b\n# \u89aa\u306b\u306f\u9032\u307e\u306a\u3044\u3088\u3046\u306b\u3057\u3066DFS\u3059\u308b\n\nN,M = list(map(int,input().split()))\nE = [[] for i in range(N)]\nfor i in range(M):\n  L,R,D = list(map(int,input().split()))\n  E[L-1].append([R-1,D])\n  E[R-1].append([L-1,-D])\nfrom collections import deque\n# \u9802\u70b9\u3001\u89aa\u3001\u8ddd\u96e2\nINF = 10 ** 10\ndist = [INF] * N\nfor i in range(N):\n  if dist[i] != INF:\n    continue\n  dist[i] = 0\n  q = deque()\n  q.append(i)\n  while q:\n    v = q.popleft()\n    for child in E[v]:\n      if dist[child[0]] == INF:\n        dist[child[0]] = dist[v] + child[1]\n        q.append(child[0])\n      else:\n        if dist[child[0]] != dist[v] + child[1]:\n          print(\"No\")\n          return\nelse:\n  print(\"Yes\")\n", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\n#mod = 998244353\nINF = 10**9\neps = 10**-7\n\nN,M = list(map(int,input().split()))\n# 1-indexed union-find\n# parent(\u89aa)\npar = [i for i in range(N+1)]\n# rank(\u6df1\u3055)\nrank = [0]*(N+1)\n# \u540c\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u6570\n# size = [1]*(N+1)\n\n# \u6728\u306e\u6839\u3092\u6c42\u3081\u308b\ndef root(x):\n    if par[x] == x:             # \u6839\u306e\u6642\n        return x\n    else:\n        par[x] = root(par[x])   # \u7d4c\u8def\u5727\u7e2e\n        return par[x]\n\n# x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408(\u30e9\u30f3\u30af\u6709)\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if x == y:\n        return\n    if rank[x] < rank[y]:\n        par[x] = y              # x\u306e\u89aa\u3092y\u306b\n        #size[y] += size[x]      # y\u306e\u9802\u70b9\u6570+=x\u306e\u9802\u70b9\u6570\n    else:\n        par[y] = x              # y\u306e\u89aa\u3092x\u306b\n        #size[x] += size[y]      # x\u306e\u9802\u70b9\u6570+=y\u306e\u9802\u70b9\u6570\n        if rank[x] == rank[y]:\n            rank[x] += 1\n\nLRD = [tuple(map(int,readline().split())) for i in range(M)]\n\nfor (L,R,D) in LRD:\n    unite(L,R)\n\nfrom collections import defaultdict,deque\nrel = defaultdict(lambda: [])\n\nfor (L,R,D) in LRD:\n    rel[root(L)].append((L,R,D))\n\nfor k,v in list(rel.items()):\n    dist = defaultdict(lambda: [])\n    for (L,R,D) in v:\n        dist[L].append((R,D))\n        dist[R].append((L,-D))\n    que = deque([])\n    x = {}\n    for k1,v1 in list(dist.items()):\n        x[k1] = 0\n        for (to,dis) in v1:\n            x[to] = dis\n            que.append(to)\n        break\n    while que:\n        fro = que.popleft()\n        for (to,dis) in dist[fro]:\n            if to not in list(x.keys()):\n                x[to] = x[fro] + dis\n                que.append(to)\n    for (L,R,D) in v:\n        if x[R] - x[L] != D:\n            print('No')\n            return\nprint('Yes')\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    #\u91cd\u307f\u4ed8\u304dUnion-Find\n\n    #x\u306e\u6839\u3092\u6c42\u3081\u308b\n    def find(x):\n        if par[x] < 0:\n            return x\n        else:\n            px = find(par[x])\n            wei[x] += wei[par[x]]\n            par[x] = px\n            return px\n\n    #x\u306e\u6839\u304b\u3089\u8ddd\u96e2\n    def weight(x):\n        find(x)\n        return wei[x]\n\n\n    #w[y]=w[x]+w\u3068\u306a\u308b\u3088\u3046\u306bx\u3068y\u3092\u4f75\u5408\n    def unite(x,y,w):\n        w += wei[x]-wei[y]\n        x = find(x)\n        y = find(y)\n        \n        if x == y:\n            return False\n        else:\n            #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n            if par[x] > par[y]:\n                x,y = y,x\n                w = -w\n            par[x] += par[y]\n            par[y] = x\n            wei[y] = w\n            return True\n\n    #x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\n    def same(x,y):\n        return find(x) == find(y)\n\n    #x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\n    def size(x):\n        return -par[find(x)]\n\n    #x,y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u3068\u304d\u306ewei[y]-wei[x]\n    def diff(x,y):\n        return weight(y)-weight(x)\n\n    n,m = map(int,input().split())\n\n    #\u521d\u671f\u5316\n    #par:\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\n    #wei:\u89aa\u304b\u3089\u306e\u8ddd\u96e2,\u6839\u306a\u30890\n    par = [-1]*n\n    wei = [0]*n\n\n    for i in range(m):\n        l,r,d = map(int,input().split())\n        l,r = l-1,r-1\n        if same(l,r):\n            if d != diff(l,r):\n                print('No')\n                return\n        else:\n            unite(l,r,d)\n    print('Yes')\n            \ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N))\n    h = [0] * N  # \u5165\u308a\u6b21\u6570\n    for _ in range(M):\n        L, R, D = list(map(int, input().split()))\n        L -= 1\n        R -= 1\n        g[L].add((R, D))\n        h[R] += 1\n\n    dist = [-1] * N\n\n    def dfs(s):\n        dist[s] = 0\n        dq = deque([s])\n        while dq:\n            v = dq.popleft()\n            for u, d in g[v]:\n                if ~dist[u]:\n                    if dist[u] != dist[v] + d:\n                        return False\n                else:\n                    dist[u] = dist[v] + d\n                    dq.append(u)\n        return True\n\n    # \u59cb\u70b9\u304b\u3089\u306e\u30d1\u30b9\u3092\u51e6\u7406\n    for s in range(N):\n        if h[s]: continue  # s\u306b\u5165\u3063\u3066\u304f\u308b\u30d1\u30b9\u304c\u3042\u308b\u306e\u3067\u3001s\u3092\u59cb\u70b9\u306b\u3057\u306a\u3044\n        # if ~dist[s]: continue\n        if not dfs(s):\n            print('No')\n            return\n\n    # \u30b5\u30a4\u30af\u30eb\u3092\u51e6\u7406\uff08\u3069\u306e\u70b9\u3082\u5165\u308b\u30d1\u30b9\u304c\u3042\u308a\u3001\u51e6\u7406\u3067\u304d\u3066\u3044\u306a\u3044\uff09\n    for s in range(N):\n        if ~dist[s]: continue\n        if not dfs(s):\n            print('No')\n            return\n\n    print('Yes')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class unionFind:\n    parent = []\n\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.weight = [0]*N\n\n    def root(self, x):\n        if self.parent[x] == x:\n            return(x)\n        else:\n            p = self.root(self.parent[x])\n            self.weight[x] += self.weight[self.parent[x]]\n            self.parent[x] = p\n            return(self.parent[x])\n\n    def same(self, x, y):\n        x, y = x-1, y-1\n        return(self.root(x) == self.root(y))\n\n    def unite(self, x, y, w):\n        w -= self.getWeight(x)\n        w += self.getWeight(y)\n        x, y = x-1, y-1\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        else:\n            self.parent[x] = y\n            self.weight[x] = self.weight[y]+w\n            return\n\n    def getWeight(self, x):\n        x -= 1\n        self.root(x)\n        return(self.weight[x])\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n    G = unionFind(N)\n    for i in range(M):\n        L, R, D = list(map(int, input().split()))\n        if G.same(L, R):\n            x = G.getWeight(L)\n            y = G.getWeight(R)\n            if x == y + D:\n                continue\n            else:\n                print(\"No\")\n                return\n        else:\n            G.unite(L, R, D)\n    print(\"Yes\")\n\n\nmain()\n", "# \u89e3\u8aac\u307f\u305f\u3088\nimport sys\nsys.setrecursionlimit(10000000)\ninput = sys.stdin.readline\nn, m = list(map(int, input().split()))\nes = [[] for i in range(n)]\nl, r, d = [0] * m, [0] * m, [0] * m\nfor i in range(m):\n    l[i], r[i], d[i] = list(map(int, input().split()))\n    l[i] -= 1\n    r[i] -= 1\n    es[l[i]].append((r[i], d[i]))\n    es[r[i]].append((l[i], -d[i]))\nINF = 1000000000000\nvalue = [INF] * n\n\n\ndef dfs(v):\n    for i, di in es[v]:\n        if value[i] == INF:\n            value[i] = value[v] + di\n            dfs(i)\n\n\nfor i in range(n):\n    if value[i] == INF:\n        value[i] = 0\n        dfs(i)\n\nfor i, j, k in zip(l, r, d):\n    if value[j] - value[i] != k:\n        print(\"No\")\n        return\nprint(\"Yes\")\n", "# https://at274.hatenablog.com/entry/2018/02/03/140504\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # \u4f75\u5408\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\nN,M=map(int,input().split())\nuf = WeightedUnionFind(N+1)\nfor i in range(M):\n  l,r,d=map(int,input().split())\n  if l>r:\n    l,r=r,l\n    d=-d\n  if uf.same(l,r) and d != uf.diff(l,r):\n    print('No')\n    return\n  uf.union(l,r,d)\nprint('Yes')", "import sys\nreadline = sys.stdin.readline\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.rank = [0] * n\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            y = self.find(self.parents[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = y\n            #self.parents[x] = self.find(self.parents[x])\n            return y\n            #return self.parents[x]\n\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.parents[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.parents[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\ndef main():\n    N, M = map(int, readline().rstrip().split())    \n    uf = WeightedUnionFind(N)\n\n    for _ in range(M):\n        l, r, d = map(int, readline().rstrip().split())\n        l -= 1\n        r -= 1\n        if uf.same(l, r):\n            if uf.diff(l, r) != d:\n                print('No')\n                return\n\n        uf.union(l, r, d)\n    \n    print('Yes')\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return x,self.dist[x]\n        else:\n            tmp=self.find(self.parents[x])\n            self.parents[x]=tmp[0]\n            self.dist[x]+=tmp[1]\n            return self.parents[x],self.dist[x]\n    \n    def union(self,x,y,d):\n        rx,_=self.find(x)\n        ry,_=self.find(y)\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n            return self.dist[x], self.parents[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[1]\n        ry=self.find(y)[1]\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\nvertices = {i: [] for i in range(n)}\nfor _ in range(m):\n    l, r, d = list(map(int, input().split()))\n    vertices[l - 1].append((r - 1, d))\n    vertices[r - 1].append((l - 1, -d))\n\n\ndef answer():\n    x = [None] * n\n\n    for i in range(n):\n        if x[i] is not None:\n            continue\n        x[i] = 0\n        queue = [i]\n\n        while queue:\n            i0 = queue.pop()\n            for i1, d in vertices[i0]:\n                # print(i0, i1, x[i0], x[i1], d)\n                if x[i1] is None:\n                    x[i1] = x[i0] + d\n                    queue.append(i1)\n                elif x[i1] != x[i0] + d:\n                    return False\n\n    return True\n\n\nif answer():\n    print('Yes')\nelse:\n    print('No')\n\n\n\n", "import sys\nfrom collections import deque\n\nN, M = map(int, sys.stdin.readline().split())\n\nedges = [[] for _ in range(N)]\nfor _ in range(M):\n    l, r, d = map(int, sys.stdin.readline().split())\n    edges[l-1].append((r-1, d))\n    edges[r-1].append((l-1, -d))\n\nvisited = {}\n# \u305d\u306e\u4eba\u3078\u306e\u30d1\u30b9\u304c\u8907\u6570\u3042\u308a\u3001\u8ddd\u96e2\u304c\u7570\u306a\u308b\u5834\u5408\u306f\u77db\u76fe\nfor i in range(N):\n    if i in visited:\n        continue\n\n    # \u9023\u7d50\u30b0\u30e9\u30d5\u3054\u3068\u306b\u76f8\u5bfe\u7684\u306a\u8ddd\u96e2\u3092\u6c7a\u5b9a\n    # dist = [0 for _ in range(N)]\n    q = deque([(i, 0)])\n    while q:\n        l, c = q.popleft()\n        if l in visited:\n            if visited[l] != c:\n                print(\"No\")\n                return\n            continue\n        \n        visited[l] = c\n        # dist[l] = c\n\n        for r, nd in edges[l]:\n            q.append((r, c+nd))\n    # print(dist)\n\nprint(\"Yes\")", "# bfs?\n\ndef main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N))\n    h = [0] * N  # \u5165\u308a\u6b21\u6570\n    for _ in range(M):\n        L, R, D = list(map(int, input().split()))\n        L -= 1\n        R -= 1\n        g[L].add((R, D))\n        h[R] += 1\n\n    dist = [-1] * N\n\n    def bfs(s):\n        dist[s] = 0\n        dq = deque([s])\n        while dq:\n            v = dq.popleft()\n            for u, d in g[v]:\n                if ~dist[u]:\n                    if dist[u] != dist[v] + d:\n                        return False\n                else:\n                    dist[u] = dist[v] + d\n                    dq.append(u)\n        return True\n\n    # \u59cb\u70b9\u304b\u3089\u306e\u30d1\u30b9\u3092\u51e6\u7406\n    for s in range(N):\n        if h[s]: continue  # s\u306b\u5165\u3063\u3066\u304f\u308b\u30d1\u30b9\u304c\u3042\u308b\u306e\u3067\u3001s\u3092\u59cb\u70b9\u306b\u3057\u306a\u3044\n        # if ~dist[s]: continue\n        if not bfs(s):\n            print('No')\n            return\n\n    # \u30b5\u30a4\u30af\u30eb\u3092\u51e6\u7406\uff08\u3069\u306e\u70b9\u3082\u5165\u308b\u30d1\u30b9\u304c\u3042\u308a\u3001\u51e6\u7406\u3067\u304d\u3066\u3044\u306a\u3044\uff09\n    for s in range(N):\n        if ~dist[s]: continue\n        if not bfs(s):\n            print('No')\n            return\n\n    print('Yes')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappop, heappush\nN, M = list(map(int, input().split()))\ngraph = [[] for i in range(N)]\nroot = [-float(\"inf\")] * N\nfor i in range(M):\n  l, r, d = list(map(int, input().split()))\n  graph[l - 1].append([r - 1, d])\n  graph[r - 1].append([l - 1, -d])\n  \n  \nfor i in range(N):\n  if root[i] < -10 ** 10:\n    root[i] = 0\n    queue = [i]\n    while queue:\n      now = heappop(queue)\n      for j, k in graph[now]:\n        if root[j] < - 10 ** 10:\n          root[j] = root[now] + k\n          heappush(queue, j)\n        elif root[j] == root[now] + k:\n          continue\n        else:\n          print(\"No\")\n          return\n          \nprint(\"Yes\")\n\n\n    \n    \n    \n    \n    \n", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n\nclass WeightedUnionfind():\n    def __init__(self,n):\n        self.par =[i for i in range(n+1)]\n        self.rank =[0]*(n+1)\n        self.weight =[0]*(n+1)\n\n    def find(self,x):\n        if self.par[x]==x:\n            return x\n\n        else:\n            y =self.find(self.par[x])\n            self.weight[x]+=self.weight[self.par[x]]\n            self.par[x]=y\n            return y\n\n    def union(self,x,y,w):\n        rx=self.find(x)\n        ry=self.find(y)\n        if self.rank[rx]<self.rank[ry]:\n            self.par[rx]=ry\n            self.weight[rx]=w-self.weight[x]+self.weight[y]\n        else:\n            self.par[ry]=rx\n            self.weight[ry]=-w-self.weight[y]+self.weight[x]\n            if self.rank[rx]==self.rank[ry]:\n                self.rank[rx]+=1\n    def same(self,x,y):\n        return self.find(x)==self.find(y)\n\n    def diff(self,x,y):\n        return self.weight[x]-self.weight[y]\n\nn,m=MI()\nwuf=WeightedUnionfind(n)\nfor i in range(m):\n    l,r,d=MI()\n    #print(l,r,d,end=\" \")\n    #print(wuf.same(l,r))\n    if wuf.same(l,r):\n        #print(wuf.diff(l,r))\n        if wuf.diff(l,r)!=d:\n            print(\"No\")\n            return\n    else:\n        wuf.union(l,r,d)\nprint(\"Yes\")\n\n\n\n    \n    \n\n\n\n    \n\n\n        \n\n\n    \n    \n\n\n    \n\n    \n            \n        \n        \n    \n    \n    \n    \n\n    \n    \n\n\n    \n    \n\n        \n        \n    \n\n\n", "n, m = map(int, input().split())\nG = [[] for _ in range(n)]\nindeg = [0] * n\n\nfor _ in range(m):\n    l, r, d = map(int, input().split())\n    l -= 1\n    r -= 1\n    G[l].append((r, d))\n    G[r].append((l, -d))\n\nfrom collections import deque\nng = False\nvisited = [0] * n\nvisited_cost = [0] * n\n\nfor start in range(n):\n    if visited[start]:\n        continue\n    visited[start] = 1\n    st = deque([[start, 0]])\n    while st:\n        i, cost = st.pop()\n        for ni, nd in G[i]:\n            if visited[ni] == 0:\n                visited[ni] = 1\n                visited_cost[ni] = cost + nd\n                st.append([ni, cost + nd])\n            else:\n                # \u65e2\u306b\u8a18\u9332\u3055\u308c\u3066\u3044\u3066\u3001\u77db\u76fe\u3057\u3066\u3044\u308b\u5834\u5408\n                if visited_cost[ni] != cost + nd:\n                    # \u7d42\u4e86\n                    ng = True\n                    break\n        if ng:\n            break\n    if ng:\n        break\nprint('No' if ng else 'Yes')", "# Union Find \u6728\nfrom sys import setrecursionlimit, stdin\n\n\ndef find(parent, diff_weight, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, diff_weight, t)\n    diff_weight[i] += diff_weight[parent[i]]\n    parent[i] = t\n    return t\n\n\ndef weight(parent, diff_weight, i):\n    find(parent, diff_weight, i)\n    return diff_weight[i]\n\n\ndef unite(parent, diff_weight, i, j, d):\n    d -= weight(parent, diff_weight, j)\n    d += weight(parent, diff_weight, i)\n    i = find(parent, diff_weight, i)\n    j = find(parent, diff_weight, j)\n    if i == j:\n        return\n    diff_weight[j] = d\n    parent[i] += parent[j]\n    parent[j] = i\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, stdin.readline().split()))\nLRD = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\nparent = [-1] * (N + 1)\ndiff_weight = [0] * (N + 1)\nfor L, R, D in LRD:\n    i = find(parent, diff_weight, L)\n    j = find(parent, diff_weight, R)\n    if i != j:\n        unite(parent, diff_weight, L, R, D)\n    else:\n        if weight(parent, diff_weight, L) + D != weight(parent, diff_weight, R):\n            print('No')\n            return\nprint('Yes')\n", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\n    \ndef main():\n    class Unionfind():\n        def __init__(self,n):\n            self.parents=[-1]*n\n            self.dist=[0]*n \n        \n        def find(self,x):\n            if self.parents[x]<0:\n                return self.dist[x],x\n            else:\n                tmp=self.find(self.parents[x])\n                self.dist[x]+=tmp[0]\n                self.parents[x]=tmp[1]\n            return self.dist[x], self.parents[x]\n        \n        def union(self,x,y,d):\n            rx=self.find(x)[1]\n            ry=self.find(y)[1]\n            diff=self.dist[y]-self.dist[x]-d\n            if rx==ry:\n                if diff!=0:\n                    return True\n                return False\n            if diff<0:\n                rx,ry=ry,rx\n                diff=-diff\n            self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n            self.parents[rx]=ry\n            self.dist[rx]=diff\n            return False\n    n,m,*lrd=list(map(int,read().split()))\n    edg=[]\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        if max(-d-1 for d in v.parents if d<0) >10**9:\n            print('No')\n        else:\n            print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "# Union Find \u6728\nfrom sys import setrecursionlimit\n\n\ndef find(parent, diff_weight, i):\n    t = parent[i]\n    if t < 0:\n        return i\n    t = find(parent, diff_weight, t)\n    diff_weight[i] += diff_weight[parent[i]]\n    parent[i] = t\n    return t\n\n\ndef weight(parent, diff_weight, i):\n    find(parent, diff_weight, i)\n    return diff_weight[i]\n\n\ndef unite(parent, diff_weight, i, j, d):\n    d -= weight(parent, diff_weight, j)\n    d += weight(parent, diff_weight, i)\n    i = find(parent, diff_weight, i)\n    j = find(parent, diff_weight, j)\n    if i == j:\n        return\n    diff_weight[j] = d\n    parent[i] += parent[j]\n    parent[j] = i\n\n\nsetrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\nLRD = [tuple(map(int, input().split())) for _ in range(M)]\n\nparent = [-1] * (N + 1)\ndiff_weight = [0] * (N + 1)\nfor L, R, D in LRD:\n    i = find(parent, diff_weight, L)\n    j = find(parent, diff_weight, R)\n    if i != j:\n        unite(parent, diff_weight, L, R, D)\n    else:\n        if weight(parent, diff_weight, L) + D != weight(parent, diff_weight, R):\n            print('No')\n            return\nprint('Yes')\n", "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(M):\n    L, R, D = list(map(int, input().split()))\n    links[L].append((R, D))\n    links[R].append((L, -D))\n\nt = [None] * (N + 1)\nfor i in range(1, N + 1):\n    if t[i] is not None:\n        continue\n    t[i] = 0\n    s = deque([i])\n    while s:\n        j = s.popleft()\n        for k, l in links[j]:\n            if t[k] is None:\n                t[k] = t[j] + l\n                s.append(k)\n            else:\n                if t[k] != t[j] + l:\n                    print('No')\n                    return\nprint('Yes')\n", "from collections import deque\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    l, r, d = map(int, input().split())\n    graph[l-1].append((r-1, d))\n    graph[r-1].append((l-1, -d))\nseen = [False]*n\ndist = [None]*n\nfor i in range(n):\n    if seen[i]:\n        continue\n    q = deque([i])\n    dist[i] = 0\n    while q:\n        node = q.popleft()\n        if seen[node]:\n            continue\n        seen[node] = True\n        for c_node, d in graph[node]:\n            if dist[c_node] is None:\n                dist[c_node] = dist[node] + d\n            elif dist[c_node] != dist[node] + d:\n                print('No')\n                return\n            q.append(c_node)\nprint('Yes')", "N, M = map(int, input().split())\nLRD = [tuple(int(x) for x in input().split()) for _ in range(M)]\nGraph = [[] for _ in range(N)]\nfor l,r,d in LRD:\n    Graph[r-1].append((l-1,d))\n    Graph[l-1].append((r-1,-d))\n\nseen = set()\nDfr = [0] * N #dist from Root\nfor root in range(N):\n    if root in seen: continue\n    seen.add(root)\n    V = [root]\n    while len(V) != 0: #bfs\n        v = V.pop(0)\n        for nv,d in Graph[v]:\n            if nv in seen and Dfr[nv] != Dfr[v] + d: #bfs\u3067\u767a\u898b\u6e08\u307f\u306e\u5024\u304c\u7570\u306a\u308b\u21d4\u77db\u76fe\n                print('No')\n                return\n            if nv in seen: continue\n            else:\n                seen.add(nv)\n                Dfr[nv] = Dfr[v] + d\n                V.append(nv)\nprint('Yes')", "# potential union find\u306e\u554f\u984c\u3068\u805e\u3044\u3066\nclass PotentialUnionFind:\n    # \u3042\u308a\u672c\u5b9f\u88c5\n    # rank\u3068root\u306e\u914d\u5217\u30921\u3064\u3067\u8cc4\u3046\u65b9\u6cd5\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1] * n\n        self.weight = [0] * n\n\n    # \u6839\u3092\u6c42\u3081\u308b\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            px = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = px\n            return px\n\n    # \u9802\u70b9\u304b\u3089\u306epotential\n    def weight(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    # \u540c\u3058\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u96c6\u5408\u306e\u5927\u304d\u3055\n    def size(self, x):\n        return -self.find(x)\n\n    # \u30002\u3064\u306e\u96c6\u5408\u306e\u5408\u4f53\n    # \u91cd\u307f\u304c\u5927\u304d\u3044\u65b9\u306b\u5c0f\u3055\u3044\u65b9\u3092\u3064\u3051\u308b\u3088\u3046\u306b\u3059\u308b\n    def unite(self, x, y, w):\n        w += self.weight[x] - self.weight[y]\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n            w = -w\n        self.par[x] += self.par[y]\n        self.par[y] = x\n        self.weight[y] = w\n        return True\n\n    def diff(self, x, y):\n        return self.weight[y] - self.weight[x]\n\n\nn, m = list(map(int, input().split()))\nPUF = PotentialUnionFind(n)\nflag = 0\nfor _ in range(m):\n    l, r, d = list(map(int, input().split()))\n    l -= 1\n    r -= 1\n    if PUF.is_same(l, r):\n        if abs(PUF.diff(l, r)) == d:\n            continue\n        else:\n            flag = 1\n    else:\n        PUF.unite(l, r, d)\n\nprint((\"No\" if flag else \"Yes\"))\n", "def root(x):\n    if(par[x]==x):\n        return x\n    else:\n        r=root(par[x])\n        diff_weight[x]+=diff_weight[par[x]]\n        par[x]=r\n        return r\n\ndef weight(x):\n    root(x)\n    return diff_weight[x]\n\ndef diff(x,y):\n    return weight(y)-weight(x)\n\ndef relate(a,b,w):\n    w+=weight(a);w-=weight(b)\n    a=root(a)\n    b=root(b)\n    if(a==b):\n        return False\n    if rank[a]<rank[b]:\n        a,b=b,a\n        w=-w\n    if rank[a]==rank[b]:\n        rank[b]+=1\n        par[b]=a\n    par[b]=a\n    diff_weight[b]=w\n    siz[a]+=siz[b]\n    return True\n\ndef size(a):\n    return siz[root(a)]\n    \ndef same(a,b):\n    return root(a)==root(b)\n    \nN,M=map(int,input().split())\npar=[i for i in range(N)]\nsiz=[1 for _ in range(N)]\nrank=[0 for _ in range(N)]\ndiff_weight=[0 for _ in range(N)]\n\nfor i in range(M):\n    L,R,D=map(int,input().split())\n    L,R=L-1,R-1\n    if same(L,R) and diff(L,R)!=D:\n        print('No')\n        return\n    else:\n        relate(L,R,D)\nprint('Yes')", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n        return self.dist[x], self.parents[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[1]\n        ry=self.find(y)[1]\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        if max(-d-1 for d in v.parents if d<0) >10**9:\n            print('No')\n        else:\n            print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(m)] \n\n# \u91cd\u8981\u306a\u4e8b\u5b9f\u3068\u3057\u3066N\u306e\u6700\u5927\u5024\u00d7D_i\u306e\u6700\u5927\u5024\u306f\u3061\u3087\u3046\u306910^4*10^5 = 10^9 = \u5ea7\u6a19\u306e\u5e45\u3002\n# \u300c\u4f4d\u7f6e\u95a2\u4fc2\u306f\u5168\u3066\u6b63\u3057\u304f\u7f6e\u3051\u308b\u304c\u30010\u301c10^9\u306b\u53ce\u307e\u3089\u306a\u3044\u306e\u3067\u30c0\u30e1\u300d\u3068\u3044\u3046\u53ef\u80fd\u6027\u306f\u8003\u616e\u3057\u306a\u304f\u3066\u826f\u3044\u3002\n# \u8fba\u3092\u901a\u3063\u3066\u5230\u9054\u53ef\u80fd\u304b\u5426\u304b\u3067\u5206\u304b\u308c\u308b\u3002\u2192\u5e45\u512a\u5148\u304b\u6df1\u3055\u512a\u5148\u304bUnion-Find\u3060\u306a\u3002\n# \u8ff7\u3063\u305f\u3089\u5e45\u512a\u5148\u3067\u66f8\u3053\u3046\u3002\n# \u306a\u304a\u30a8\u30c3\u30b8\u30921\u672c\u305a\u3064\uff08\u5165\u529b\u3055\u308c\u305f\u9806\u306b\uff09\u51e6\u7406\u3059\u308b\u306e\u306f\u30de\u30ba\u3044\u3002100\u500b\u306e\u70b9\u304b\u3089\u306a\u308b\u584a\u304c2\u3064\u3042\u3063\u3066\u3001\u6700\u5f8c\u306b\u305d\u308c\u304c2\u3064\u306e\u7dda\u3067\u7d50\u3070\u308c\u305f\u5834\u5408\u3001\u7121\u77db\u76fe\u304b\u3069\u3046\u304b\u3069\u3046\u3084\u3063\u3066\u5224\u5225\u3059\u308b\u304b?\n\nfrom collections import deque\n\nnei = [[] for _ in range(n)]\nfor edge in info:\n    v0 = edge[0] - 1\n    v1 = edge[1] - 1\n    nei[v0].append((v1, edge[2]))\n    nei[v1].append((v0, -edge[2]))\n\nqueue = deque()\nvisited = [False] * n\npos = [None] * n\n\nfor i in range(n):\n    if visited[i]:\n        continue\n    queue.append(i)\n\n    pos[i] = 0  # \u76f8\u5bfe\u4f4d\u7f6e\u306a\u306e\u3067\u3001\u5024\u306f\u4f55\u3067\u3082\u826f\u3044\n\n    while len(queue) > 0:\n        v = queue.popleft()\n        visited[v] = True\n\n        for n, diff in nei[v]:\n            if pos[n] == None:\n                pos[n] = pos[v] + diff\n                queue.append(n)\n\n            else:\n                # \u65e2\u306b\u8a2a\u554f\u6e08\u307f\u2192\u5ea7\u6a19\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u2192\u6574\u5408\u6027\u30c1\u30a7\u30c3\u30af\n                if pos[n] != pos[v] + diff:\n                    print('No')\n                    return\n\nprint('Yes')\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\nMOD = 10 ** 9 + 7\n\nN, M = map(int, input().split())\n\nG = [[] for _ in range(N + 1)]\nfor _ in range(M):\n    L, R, D = map(int, input().split())\n    G[L].append((R, -D))\n    G[R].append((L, +D))\n\nans = [None] * (N + 1)\n\ndef calc(i):\n    ans[i] = 0\n    stack = [i]\n    while stack:\n        now = stack.pop()\n        for next_, d in G[now]:\n            if ans[next_] == None:\n                ans[next_] = ans[now] + d\n                stack.append(next_)\n            else:\n                if ans[now] + d != ans[next_]:\n                    return False\n    return True\n\nfor i in range(1, N + 1):\n    if ans[i] == None:\n        if calc(i):\n            pass\n        else:\n            print ('No')\n            return\n\n\nmax_ = -10 ** 10\nmin_ = +10 ** 10\nfor i in ans[1:]:\n    max_ = max(max_, i)\n    min_ = min(min_, i)\n\nif max_ - min_ > 10 ** 9:\n    print ('No')\nelse:\n    print ('Yes')", "\ndef dijkstra(node, edge, check):\n    \"\"\"\n    node\u3092\u542b\u3080\u9023\u7d50\u30b0\u30e9\u30d5\u306e\u4e2d\u3067\u3001\n    \u77db\u76fe\u304c\u767a\u751f\u3057\u306a\u3044\u304b\u78ba\u8a8d\u3059\u308b\n    \u77db\u76fe\u304c\u767a\u751f\u3057\u306a\u3044\u5834\u5408\u3001\n    node\u30920\u3068\u3057\u305f\u3068\u304d\u306e\u5404\u30ce\u30fc\u30c9\u306e\u30b9\u30b3\u30a2\u3092\u8fd4\u3059\n    \"\"\"\n    # \u5230\u9054\u8ddd\u96e2\n    d = dict()\n    st = [(node, 0)]\n    curr_min = float('inf')\n    curr_max = -float('inf')\n    while st:\n        curr_node, curr_d = st.pop()\n        # \u5230\u9054\u6e08\u307f\u3067\u3042\u308c\u3070\u77db\u76fe\u304c\u767a\u751f\u3057\u306a\u3044\u304b\u78ba\u8a8d\u3059\u308b\n        if curr_node in d.keys():\n            if d[curr_node] != curr_d:\n                # \u77db\u76fe\u304c\u767a\u751f\u3057\u305f\n                return None, None, None, check\n            else:\n                continue\n        # \u5230\u9054\u3057\u305f\u8ddd\u96e2\u3092\u8a18\u9332\n        d[curr_node] = curr_d \n        check[curr_node] = True\n        if curr_d < curr_min:\n            curr_min = curr_d\n        if curr_max < curr_d:\n            curr_max = curr_d\n\n        # \u96a3\u63a5\u30ce\u30fc\u30c9\u3092\u7a4d\u3080\n        for nxt, diff in edge[curr_node]:\n            st.append((nxt, curr_d + diff))\n    \n    return d, curr_min, curr_max, check\n\n\ndef submit():\n    n, m = (int(e) for e in input().split())\n    \n    # \u30b0\u30e9\u30d5\u3092\u69cb\u6210\n    edge = {i : [] for i in range(1, n + 1)}\n    for _ in range(m):\n        l, r, d = (int(e) for e in input().split())\n        edge[l].append((r, d))\n        edge[r].append((l, -d))\n\n    check = {i: False for i in range(1, n + 1)}\n    curr_max = -float('inf')\n\n    for i in range(1, n + 1):\n        if not check[i]:\n            d, sub_min, sub_max, check = dijkstra(i, edge, check)\n\n            if d == None:\n                print('No')\n                return\n            # sub_min\u30920\u3068\u3057\u305f\u3068\u304d\u306esub_max\u3092\u8a08\u7b97\u3059\u308b\n            sub_max -= sub_min\n            if sub_max > curr_max:\n                curr_max = sub_max\n\n    if curr_max > 10 ** 9:\n        print('No')\n    else:\n        print('Yes')\n\n\nsubmit()", "from collections import deque\nN,M=map(int, input().split())\nA=[[]for _ in range(N)]\nV=[False]*N\nX=[0]*N\nx=0\nfor i in range(M):\n  L,R,D=map(int, input().split())\n  A[L-1].append((R-1,D))\n  A[R-1].append((L-1,-D))\n  \nfor i in range(N):\n  if V[i]==False:\n    stack=deque([(i,x)])\n    V[i]=True\n    while stack:\n      now,dx=stack.popleft()\n      for new,di in A[now]:\n        if V[new]:\n          if X[new]!=dx+di:\n            print('No')\n            return\n        else:\n          X[new]=dx+di\n          V[new]=True\n          stack.append((new,dx+di))\n\nif max(X)-min(X)>10**9:\n  print('No')\nelse:\n  print('Yes')", "# \u4eba\u3092\u9802\u70b9\u3068\u898b\u306a\u3057\u305f\u30b0\u30e9\u30d5\u3092\u4f5c\u308b\u3002\u6709\u5411\u3067\u3001\u9006\u5411\u304d\u306e\u5834\u5408\u306f\u6b63\u8ca0\u3092\u53cd\u8ee2\u3055\u305b\u3066\u8fba\u3092\u5f35\u308b\n# \u9802\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u3092\u8a18\u9332\u3057\u3001\u4e00\u81f4\u3057\u306a\u3044\u7b87\u6240\u304c\u3042\u308c\u3070NG\u3002\n# \u5168\u3066\u306e\u8fba\u3092\u901a\u308b\u307e\u3067\u7d9a\u3051\u308b\u3002\n# \u8fba\u306e\u60c5\u5831\u3092[{0\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},{1\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},...]\u3067\u7ba1\u7406\u3059\u308b\n# \u89aa\u306b\u306f\u9032\u307e\u306a\u3044\u3088\u3046\u306b\u3057\u3066DFS\u3059\u308b\n\nN,M = list(map(int,input().split()))\nE = [[] for i in range(N)]\nfor i in range(M):\n  L,R,D = list(map(int,input().split()))\n  E[L-1].append([R-1,D])\n  E[R-1].append([L-1,-D])\nfrom collections import deque\n# \u9802\u70b9\u3001\u89aa\u3001\u8ddd\u96e2\nINF = 10 ** 10\ndist = [INF] * N\nfor i in range(N):\n  if dist[i] != INF:\n    continue\n  dist[i] = 0\n  q = deque()\n  # \u9802\u70b9\u3001\u89aa\n  q.append([i,-1])\n  while q:\n    v,parent = q.popleft()\n    for child in E[v]:\n      if child[0] == parent:\n        continue\n      if dist[child[0]] == INF:\n        dist[child[0]] = dist[v] + child[1]\n        q.append([child[0],v])\n      else:\n        if dist[child[0]] != dist[v] + child[1]:\n          print(\"No\")\n          return\nelse:\n  print(\"Yes\")\n", "n,m=list(map(int,input().split()))\nG=[[] for i in range(n)]\nfor i in range(m):\n  l,r,d=list(map(int,input().split()))\n  G[l-1].append([r-1,d])\n  G[r-1].append([l-1,-d])\n\ndist=[None]*n\nfrom collections import deque\nfor i in range(n):\n  q=deque()\n  if dist[i]==None:\n    dist[i]=0\n    q.append(i)\n  while q:\n    cur=q.popleft()\n    for nx,nxd in G[cur]:\n      if dist[nx]==None:\n        dist[nx]=dist[cur]+nxd\n        q.append(nx)\n      elif dist[nx]!=dist[cur]+nxd:\n        print(\"No\")\n        return\nprint(\"Yes\")\n\n", "N, M = list(map(int, input().split()))\n\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(M):\n    L, R, D = list(map(int, input().split()))\n    links[L].append((R, D))\n    links[R].append((L, -D))\n\nt = [None] * (N + 1)\nfor i in range(1, N + 1):\n    if t[i] is not None:\n        continue\n    t[i] = 0\n    s = [i]\n    while s:\n        j = s.pop()\n        for k, l in links[j]:\n            if t[k] is None:\n                t[k] = t[j] + l\n                s.append(k)\n            else:\n                if t[k] != t[j] + l:\n                    print('No')\n                    return\nprint('Yes')\n", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return x,self.dist[x]\n        else:\n            tmp=self.find(self.parents[x])\n            self.parents[x]=tmp[0]\n            self.dist[x]+=tmp[1]\n            return self.parents[x],self.dist[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[0]\n        ry=self.find(y)[0]\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\nYES = \"Yes\"  # type: str\nNO = \"No\"  # type: str\n\n\ndef solve(N: int, M: int, L: \"List[int]\", R: \"List[int]\", D: \"List[int]\"):\n    uf = UnionFind(N+1)\n    try:\n        for l, r, d in zip(L, R, D):\n            uf.merge(l, r, d)\n        return YES\n    except MergeError:\n        return NO\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    L = [int()] * (M)  # type: \"List[int]\"\n    R = [int()] * (M)  # type: \"List[int]\"\n    D = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        L[i] = int(next(tokens))\n        R[i] = int(next(tokens))\n        D[i] = int(next(tokens))\n    print((solve(N, M, L, R, D)))\n    \nclass MergeError(Exception):\n    pass\n\n# \u53c2\u8003: https://qiita.com/drken/items/cce6fc5c579051e64fab\nclass UnionFind:\n    def __init__(self, size: int):\n        self.par = list(range(size))\n        self.rank = [0] * size\n        self.diff_weight = [0] * size\n\n    def root(self, x: int):\n        if self.par[x] == x:\n            return x\n        r = self.root(self.par[x])\n        self.diff_weight[x] += self.diff_weight[self.par[x]] # \u7d2f\u7a4d\u548c\u3092\u3068\u308b        \n        #return par[x] := r\n        self.par[x] = r\n        return r\n\n    def weight(self, x: int):\n        self.root(x) # \u7d4c\u8def\u5727\u7e2e\n        return self.diff_weight[x]\n\n    def same(self, x: int, y: int):\n        return self.root(x) == self.root(y)\n\n    # weight(y) - weight(x) = w \u3068\u306a\u308b\u3088\u3046\u306b merge \u3059\u308b\n    def merge(self, x: int, y: int, w: int):\n        # x \u3068 y \u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u3001 root \u3068\u306e\u91cd\u307f\u5dee\u5206\u3092\u88dc\u6b63\n        adjusted_w = w + self.weight(x) - self.weight(y)\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            if adjusted_w != 0:\n                raise MergeError\n            return\n        if self.rank[x] < self.rank[y]:\n            x, y, adjusted_w = y, x, -adjusted_w\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.par[y] = x\n        self.diff_weight[y] = adjusted_w\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\nclass UnionFindWeighted:\n    # Reference:\n    # https://note.nkmk.me/python-union-find/\n    # https://at274.hatenablog.com/entry/2018/02/03/140504\n    # https://qiita.com/drken/items/cce6fc5c579051e64fab\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            root = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = root\n            return root\n\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n\n        if rx == ry:\n            return\n\n        if self.parents[rx] > self.parents[ry]:\n            x, y, rx, ry, w = y, x, ry, rx, -w\n\n        self.parents[rx] += self.parents[ry]\n        self.parents[ry] = rx\n        self.weight[ry] = self.weight[x] - self.weight[y] + w\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[y] - self.weight[x]\n\n\ndef main():\n    N, M, *LRD = list(map(int, read().split()))\n\n    uf = UnionFindWeighted(N)\n    for l, r, d in zip(*[iter(LRD)] * 3):\n        l -= 1\n        r -= 1\n        if uf.same(l, r) and uf.diff(l, r) != d:\n            print('No')\n            return\n        else:\n            uf.union(l, r, d)\n\n    print('Yes')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import namedtuple, deque\n\nclass Person:\n    def __init__(self, id, conn, x):\n        self.id = id\n        self.conn = conn\n        self.x = x\n\ndef main():\n    with open(0) as f:\n        N, M = map(int, f.readline().split())\n        info = [tuple(map(int, line.split())) for line in f.readlines()]\n    people = [Person(i, conn=[], x=None) for i in range(N)]\n    for l, r, d in info:\n        people[l-1].conn.append((r-1, d))\n        people[r-1].conn.append((l-1, -d))\n    \n    for person in people:\n        if person.x is not None:\n            continue\n        else:\n            person.x = person.id\n            #bfs\n            reserved = deque([person])\n            seen = {person.id}\n            while len(reserved) > 0:\n                current = reserved.popleft()\n                for next_person_id, d in current.conn:\n                    if people[next_person_id].x is None:\n                        people[next_person_id].x = current.x + d\n                    else:\n                        if people[next_person_id].x != current.x + d:\n                            print('No')\n                            return None\n                    if next_person_id in seen:\n                        continue\n                    seen.add(next_person_id)\n                    reserved.append(people[next_person_id])\n    print('Yes')\n\nmain()            ", "#!/usr/bin/env python3\nclass WeightedUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            px = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = px\n            return px\n\n    def union(self, x, y, w):\n        w += self.weight[x] - self.weight[y]\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n            w = -w\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.weight[y] = w\n        return\n\n    def weig(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    def diff(self, x, y):\n        return self.weight[y] - self.weight[x]\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nn, m = map(int, input().split())\nUF = WeightedUnionFind(n)\n\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    l -= 1;r -= 1\n    if UF.same(l, r):\n        if d != abs(UF.diff(l, r)):\n            print(\"No\");return\n    else:\n        UF.union(l, r, d)\nprint(\"Yes\")", "N, M = map(int, input().split())\n\ngraph = [[] for i in range(N)]\nleft = set()\nright = set()\nfor i in range(M):\n  l, r, d = map(int, input().split())\n  l -= 1; r -= 1\n  graph[l].append((r, d))\n  graph[r].append((l, -d))\n  left.add(l); right.add(r)\n\nroot = left - right\nif M and len(root) == 0:\n  print('No')\n  return\n\nX = [None] * N\nwhile root:\n  node = root.pop()\n  X[node] = 0\n  stack = [node]\n  while stack:\n    node = stack.pop()\n    while graph[node]:\n      child, d = graph[node].pop()\n      if X[child] is None:\n        X[child] = X[node] + d\n        stack.append(child)\n      elif X[child] != X[node] + d:\n        print('No')\n        return\n\nprint('Yes')", "#!/usr/bin/env python3\nclass WeightedUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            px = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = px\n            return px\n\n    def union(self, x, y, w):\n        w += self.weight[x] - self.weight[y]\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n            w = -w\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.weight[y] = w\n        return\n\n    def weig(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    def diff(self, x, y):\n        return self.weight[y] - self.weight[x]\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nn, m = map(int, input().split())\nUF = WeightedUnionFind(n + 1)\n\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    if UF.same(l, r):\n        if d != abs(UF.diff(l, r)):\n            print(\"No\");return\n    else:\n        UF.union(l, r, d)\nprint(\"Yes\")", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nclass WeightedUnionFind:\n    def __init__(self, n_nodes):\n        self.n_nodes = n_nodes\n        self.parents = [-1] * n_nodes\n\n        # \u89aa\u3078\u306e\u91cd\u307f\u3092\u7ba1\u7406\n        self.weights = [0] * n_nodes\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            parent = self.find(self.parents[x])\n            self.weights[x] += self.weights[self.parents[x]]\n            self.parents[x] = parent\n            return parent\n\n    # x\u304b\u3089y\u3078\u306e\u91cd\u307f\u304cw\n    def unite(self, x, y, w):\n        w += self.weights[x]\n        w -= self.weights[y]\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n            w *= -1\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.weights[y] = w\n        return\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n\n    def get_weight(self, x, y):\n        return self.weights[y] - self.weights[x]\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    tree = WeightedUnionFind(N)\n    for _ in range(M):\n        L, R, D = list(map(int, input().split()))\n        L -= 1\n        R -= 1\n\n        if tree.is_same(L, R):\n            if tree.get_weight(L, R) == D:\n                continue\n            else:\n                print(\"No\")\n                return\n        else:\n            tree.unite(L, R, D)\n\n    print(\"Yes\")\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(200002)\n\nn, m = list(map(int, input().split()))\n\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    l, r, d = list(map(int, input().split()))\n\n    graph[l-1].append([r-1, d])\n    graph[r-1].append([l-1, -d])\n# print(graph)\n\n\ndef dfs(s):\n    for t, d in graph[s]:\n        if x[t] is None:\n            x[t] = x[s]+d\n            if not dfs(t):\n                return False\n        else:\n            if x[t]-x[s] != d:\n                return False\n    return True\n\n\nx = [None]*n\nans = True\nfor i in range(n):\n    if x[i] is None:\n        x[i] = 0\n        if not dfs(i):\n            ans = False\n\nprint((('No', 'Yes')[ans]))\n", "class WeightedUF:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    def unite(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\nn,m=map(int,input().split())\nwuf=WeightedUF(n)\nfor i in range(m):\n    l,r,d=map(int,input().split())\n    l-=1\n    r-=1\n    if wuf.same(l,r):\n        if wuf.diff(l,r)!=d:\n            print(\"No\")\n            return\n    else:\n        wuf.unite(l,r,d)\nprint(\"Yes\")", "import numpy as np\n\n\ndef inputs(func=lambda x: x, sep=None, maxsplit=-1):\n\treturn list(map(func, input().split(sep=sep, maxsplit=maxsplit)))\n\ndef input_row(n : int, type=np.int, *args, **kwargs):\n\treturn np.fromiter(inputs(type, *args, **kwargs), dtype=type)\n\ndef input_2d(nrows : int, ncols : int, type=np.int, *args, **kwargs):\n\tdata = np.zeros((nrows, ncols), dtype=type)\n\tfor i in range(nrows):\n\t\tdata[i, :] = input_row(ncols, type, *args, **kwargs)\n\treturn data\n\nclass Repeat (object):\n\t__slots__ = [\n\t\t'element',\n\t\t'times'\n\t]\n\t\n\tdef __init__(self, element, times : int):\n\t\tself.element = element\n\t\tself.times = int(times)\n\t\n\tdef __len__(self):\n\t\treturn self.times\n\t\n\tdef __iter__(self):\n\t\treturn iter(self.element for _ in range(self.times))\n\ndef repeat(element, times : int):\n\treturn Repeat(element, times)\n\nclass IntAddition (object):\n\t'''\u6574\u6570\u306e\u52a0\u6cd5'''\n\tdef operate(self, x, y):\n\t\treturn x + y\n\t@property\n\tdef identity(self):\n\t\treturn 0\n\tdef cancel(self, x, y):\n\t\treturn x - y\n\tdef invert(self, x):\n\t\treturn -x\n\tdef accumulate(self, x, count):\n\t\treturn x * count\n\nclass UnionFind (object):\n\t'''\u91cd\u307f\u4ed8\u304dUnion-Find\u6728'''\n\tdef __init__(\n\t\t\tself,\n\t\t\tnum_nodes=0,\n\t\t\tabelian_operator=IntAddition()):\n\t\tself.parent = []\n\t\tself.potential = []\n\t\tself.op = abelian_operator\n\t\t\n\t\tself.extend(num_nodes)\n\t\n\tdef append(self):\n\t\tself.parent.append(-1)\n\t\tself.potential.append(self.op.identity)\n\t\n\tdef extend(self, num_nodes):\n\t\tself.parent.extend(repeat(-1, num_nodes))\n\t\tself.potential.extend(repeat(self.op.identity, num_nodes))\n\t\n\tdef root(self, x):\n\t\tparent = self.parent[x]\n\t\tif 0 <= parent:\n\t\t\tself.parent[x] = self.root(parent)\n\t\t\tself.potential[x] = self.op.operate(\n\t\t\t\tself.potential[x], self.potential[parent]\n\t\t\t)\n\t\t\tx = self.parent[x]\n\t\treturn x\n\t\n\tdef difference_from_root_to(self, x):\n\t\tself.root(x)\n\t\treturn self.potential[x]\n\t\t\n\tdef size(self, x):\n\t\treturn -self.parent[self.root(x)]\n\t\n\tdef difference(self, x, y):\n\t\tif not self.issame(x, y):\n\t\t\traise RuntimeError('x \u3068 y \u306f\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u307e\u305b\u3093\u3002')\n\t\treturn self.op.cancel(\n\t\t\tself.difference_from_root_to(y),\n\t\t\tself.difference_from_root_to(x)\n\t\t)\n\t\n\tdef unite(self, x, y, difference=None):\n\t\tif difference is None:\n\t\t\tdifference = self.op.identity\n\t\t\n\t\tx, px = self.root(x), self.potential[x]\n\t\ty, py = self.root(y), self.potential[y]\n\t\tdifference = self.op.cancel(difference, py)\n\t\tdifference = self.op.operate(difference, px)\n\t\tif x == y:\n\t\t\treturn difference == 0\n\t\t\n\t\tif self.size(x) < self.size(y):\n\t\t\tx, y = y, x\n\t\t\tdifference = self.op.invert(difference)\n\t\tself.parent[x] += self.parent[y]\n\t\tself.parent[y] = x\n\t\tself.potential[y] = difference\n\t\t\n\t\treturn True\n\t\n\tdef issame(self, x, y):\n\t\treturn self.root(x) == self.root(y)\n\n\n\nN, M = inputs(int)\nuf = UnionFind(num_nodes=N)\n\nvalid = True\nfor i in range(M):\n\tL, R, D = inputs(int)\n\tL -= 1\n\tR -= 1\n\t\n\tif not uf.unite(L, R, D):\n\t\tvalid = False\n\nprint(('Yes' if valid else 'No'))\n", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\nclass Unionfind():\n    def __init__(self,n):\n        self.parents=[-1]*n\n        self.dist=[0]*n \n    \n    def find(self,x):\n        if self.parents[x]<0:\n            return self.dist[x],x\n        else:\n            tmp=self.find(self.parents[x])\n            self.dist[x]+=tmp[0]\n            self.parents[x]=tmp[1]\n            return self.dist[x],self.parents[x]\n    \n    def union(self,x,y,d):\n        rx=self.find(x)[1]\n        ry=self.find(y)[1]\n        diff=self.dist[y]-self.dist[x]-d\n        if rx==ry:\n            if diff!=0:\n                return True\n            return False\n        if diff<0:\n            rx,ry=ry,rx\n            diff=-diff\n        self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n        self.parents[rx]=ry\n        self.dist[rx]=diff\n        return False\n    \ndef main():\n    n,m,*lrd=list(map(int,read().split()))\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef dfs(s):\n    stack = deque([s])\n    dist[s] = 0\n    while stack:\n        v = stack.pop()\n        for d, u in E[v]:\n            if dist[u] is None:\n                dist[u] = dist[v] + d\n                stack.append(u)\n            else:\n                if dist[u] != dist[v] + d:\n                    return False\n    return True\n\nN, M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n    l, r, d = map(int, input().split())\n    E[l-1].append((d, r - 1))\n    E[r-1].append((-d, l - 1))\ndist = [None] * N\nfor i in range(N):\n    if dist[i] is not None:\n        continue\n    if not dfs(i):\n        print('No')\n        break\nelse:\n    print('Yes')", "from collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\ninf = pow(10, 10)\n\nn, m = list(map(int, input().split()))\na = [inf] * n\n\nedge = [[] for i in range(n)]\n\nfor i in range(m):\n    l, r, d = list(map(int, input().split()))\n    l-=1;r-=1\n    edge[l].append((r, d))\n    edge[r].append((l, -d))\n\n\"\"\"\n# BFS\u89e3\u653e\nflag = True\ndist = [inf] * n\nfor i in range(n):\n    if not flag: break\n    if dist[i] == inf: # \u507d\u306e\u5834\u5408\u3001\u9023\u7d50\u3067\u65e2\u306b\u8a2a\u308c\u3066\u3044\u308b\n        dist[i] = 0\n        dq = deque([i])\n        while dq:\n            now = dq.popleft()\n            for e in edge[now]:\n                nnode, d = e\n                if dist[nnode] == inf:\n                    dist[nnode] = dist[now] + d\n                    dq.append(nnode)\n                else:\n                    if dist[nnode] != dist[now] + d:\n                        flag = False\n                        break\nif flag:\n    print('Yes')\nelse:\n    print('No')\n\"\"\"\n\n# DFS\u89e3\u6cd5\ndist = [inf]*n\ndef dfs(i, totald = 0):\n    if dist[i] < inf:\n        if dist[i] == totald:\n            return True\n        else:\n            return False\n    dist[i] = totald\n    for e in edge[i]:\n        nnode, d = e\n        if not dfs(nnode, totald+d):\n            return False\n    return True\n\n\nf = True\nfor i in range(n):\n    if dist[i] == inf:\n        if not dfs(i, 0):\n            f = False\n            break\nif f:\n    print('Yes')\nelse:\n    print('No')\n", "#!/usr/bin/env python3\nclass WeightedUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            px = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = px\n            return px\n\n    def union(self, x, y, w):\n        w += self.weight[x] - self.weight[y]\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y, w = y, x, -w\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.weight[y] = w\n        return\n\n    def weig(self, x):\n        self.find(x)\n        return self.weight[x]\n\n    def diff(self, x, y):\n        return self.weig(y) - self.weig(x)\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n(n, m), *q = [[*map(int, o.split())] for o in open(0)]\nUF = WeightedUnionFind(n + 1)\nfor l, r, d in q:\n    if UF.same(l, r):\n        if d != abs(UF.diff(l, r)):\n            print(\"No\"); return\n    else:\n        UF.union(l, r, d)\nprint(\"Yes\")", "import sys\nimport numpy as np\n\n\ndef inputs(func=lambda x: x, sep=None, maxsplit=-1):\n\treturn list(map(func, sys.stdin.readline().split(sep=sep, maxsplit=maxsplit)))\n\ndef input_row(n : int, type=np.int, *args, **kwargs):\n\treturn np.fromiter(inputs(type, *args, **kwargs), dtype=type)\n\ndef input_2d(nrows : int, ncols : int, type=np.int, *args, **kwargs):\n\tdata = np.zeros((nrows, ncols), dtype=type)\n\tfor i in range(nrows):\n\t\tdata[i, :] = input_row(ncols, type, *args, **kwargs)\n\treturn data\n\nclass IntAddition (object):\n\t'''\u6574\u6570\u306e\u52a0\u6cd5'''\n\tdef operate(self, x, y):\n\t\treturn x + y\n\t@property\n\tdef identity(self):\n\t\treturn 0\n\tdef cancel(self, x, y):\n\t\treturn x - y\n\tdef invert(self, x):\n\t\treturn -x\n\tdef accumulate(self, x, count):\n\t\treturn x * count\n\nclass UnionFindNode (object):\n\t__slots__ = [\n\t\t'parent_index',\n\t\t'size',\n\t\t'difference_from_parent'\n\t]\n\t\n\tdef __init__(self, index : int, potential_identity):\n\t\tself.parent_index = index\n\t\tself.size = 1\n\t\tself.difference_from_parent = potential_identity\n\nclass UnionFind (object):\n\t'''\u91cd\u307f\u4ed8\u304dUnion-Find\u6728'''\n\tdef __init__(\n\t\t\tself,\n\t\t\tnum_nodes=0,\n\t\t\tpotential_abelian=IntAddition()):\n\t\tself.nodes = []\n\t\tself.op = potential_abelian\n\t\t\n\t\tself.extend(num_nodes)\n\t\n\tdef append(self):\n\t\tself.nodes.append(\n\t\t\tUnionFindNode(len(self.nodes), self.op.identity)\n\t\t)\n\t\t\n\tdef extend(self, num_nodes):\n\t\tself.nodes.extend(\n\t\t\tUnionFindNode(i, self.op.identity)\n\t\t\tfor i in range(num_nodes)\n\t\t)\n\t\n\tdef root(self, index : int):\n\t\tx = self.nodes[index]\n\t\t\n\t\twhile x.parent_index != index:\n\t\t\tparent = self.nodes[x.parent_index]\n\t\t\tx.difference_from_parent = self.op.operate(\n\t\t\t\tx.difference_from_parent,\n\t\t\t\tparent.difference_from_parent\n\t\t\t)\n\t\t\tindex = x.parent_index = parent.parent_index\n\t\t\tx = self.nodes[index]\n\t\t\n\t\treturn index\n\t\n\tdef difference_from_root_to(self, index : int):\n\t\tx = self.nodes[index]\n\t\tpotential = x.difference_from_parent\n\t\t\n\t\twhile x.parent_index != index:\n\t\t\tparent = self.nodes[x.parent_index]\n\t\t\tpotential = self.op.operate(\n\t\t\t\tpotential,\n\t\t\t\tparent.difference_from_parent\n\t\t\t)\n\t\t\tindex = x.parent_index\n\t\t\tx = self.nodes[index]\n\t\t\n\t\treturn potential\n\t\t\n\tdef size(self, index : int):\n\t\treturn self.nodes[self.root(index)].size\n\t\n\tdef difference(self, x, y):\n\t\tif not self.issame(x, y):\n\t\t\traise RuntimeError('x \u3068 y \u306f\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u307e\u305b\u3093\u3002')\n\t\treturn self.op.cancel(\n\t\t\tself.difference_from_root_to(y),\n\t\t\tself.difference_from_root_to(x)\n\t\t)\n\t\n\tdef unite(self, x, y, difference=None) -> bool:\n\t\tif difference is None:\n\t\t\tdifference = self.op.identity\n\t\t\n\t\tx, px = self.root(x), self.difference_from_root_to(x)\n\t\ty, py = self.root(y), self.difference_from_root_to(y)\n\t\tif x == y:\n\t\t\treturn difference == self.op.cancel(py, px)\n\t\t\n\t\tdifference = self.op.cancel(difference, py)\n\t\tdifference = self.op.operate(difference, px)\n\t\t\n\t\tif self.size(x) < self.size(y):\n\t\t\tx, y = y, x\n\t\t\tdifference = self.op.invert(difference)\n\t\t\n\t\tx_node = self.nodes[x]\n\t\ty_node = self.nodes[y]\n\t\tx_node.size += y_node.size\n\t\ty_node.parent_index = x\n\t\ty_node.difference_from_parent = difference\n\t\t\n\t\treturn True\n\t\n\tdef issame(self, x, y):\n\t\treturn self.root(x) == self.root(y)\n\n\n\nN, M = inputs(int)\nuf = UnionFind(num_nodes=N)\n\nvalid = True\nfor i in range(M):\n\tL, R, D = inputs(int)\n\tL -= 1\n\tR -= 1\n\t\n\tvalid = valid and uf.unite(L, R, D)\n\nprint(('Yes' if valid else 'No'))\n", "from collections import deque\n\ndef bfs():\n    visit = [0] * (n + 1)\n    e = [0] * (m + 1)\n    x = [0] * (n + 1)\n    q = deque()\n    for i in range(1, n + 1):\n        if not visit[i]:\n            q.append(i)\n            visit[i] = 1\n            while q:\n                j = q.popleft()\n                for g in G[j]:\n                    if not e[g[2]]:\n                        #print(e, visit, q, x, j)\n                        e[g[2]] = 1\n                        if not visit[g[0]]:\n                            x[g[0]] = g[1] + x[j]\n                            visit[g[0]] = 1\n                            q.append(g[0])\n                        else:\n                            #print(x[g[0]], g[1] + x[j])\n                            if not x[g[0]] == g[1] + x[j]:\n                                return False\n    return True\n\nn, m = map(int, input().split())\nG = [[] for _ in range(n + 1)]\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    G[l].append([r, d, i])\n    G[r].append([l, -d, i])\nprint(\"Yes\" if bfs() else \"No\")", "N,M = map(int,input().split())\nLRD = [tuple(map(int,input().split())) for i in range(M)]\n\nclass WeightedUnionFind:\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.count = 0\n        self.weight = [0] * N\n    def root(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            pa = self.root(self.parent[a])\n            self.weight[a] += self.weight[self.parent[a]]\n            self.parent[a] = pa\n            return pa\n    def is_same(self,a,b):\n        return self.root(a) == self.root(b)\n    def unite(self,a,b,w):\n        ra = self.root(a)\n        rb = self.root(b)\n        if ra == rb: return\n        if self.rank[ra] < self.rank[rb]:\n            self.parent[ra] = rb\n            self.weight[ra] = w - self.weight[a] + self.weight[b]\n        else:\n            self.parent[rb] = ra\n            self.weight[rb] = -w - self.weight[b] + self.weight[a]\n            if self.rank[ra] == self.rank[rb]: self.rank[ra] += 1\n        self.count += 1\n    def diff(self,a,b):\n        return self.weight[a] - self.weight[b]\n\nuf = WeightedUnionFind(N)\nfor l,r,d in LRD:\n    l,r = l-1,r-1\n    if uf.is_same(l,r):\n        if uf.diff(l,r) != d:\n            print('No')\n            return\n    else:\n        uf.unite(l,r,d)\nprint('Yes')", "from sys import stdin\nfrom collections import deque\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,m=map(int,readline().split())\n    G=[[] for _ in range(n+1)]\n    for i in range(m):\n        l,r,d=map(int,readline().split())\n        G[l].append((r,d))\n        G[r].append((l,-d))\n\n    flags=[False]*(n+1)\n    flags[0]=True\n    inf=10**10\n    x=[-inf]*(n+1)\n    q=deque([])\n    ans=True\n    for i in range(1,n+1):\n        if ans==False: break\n        if flags[i]==False:\n            x[i]=0\n            flags[i]=True\n            q.append(i)\n            while len(q)>0:\n                now=q.popleft()\n                for t in G[now]:\n                    nex=t[0]\n                    cost=t[1]\n                    if x[nex]==-inf:\n                        x[nex]=x[now]+cost\n                    else:\n                        if x[nex]!=x[now]+cost:\n                            ans=False\n                            break\n                    if flags[nex]==False:\n                        flags[nex]=True\n                        q.append(nex)\n\n    print(\"Yes\" if ans else \"No\")\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\n\n\ndef inputs(func=lambda x: x, sep=None, maxsplit=-1):\n\treturn list(map(func, input().split(sep=sep, maxsplit=maxsplit)))\n\ndef input_row(n : int, type=np.int, *args, **kwargs):\n\treturn np.fromiter(inputs(type, *args, **kwargs), dtype=type)\n\ndef input_2d(nrows : int, ncols : int, type=np.int, *args, **kwargs):\n\tdata = np.zeros((nrows, ncols), dtype=type)\n\tfor i in range(nrows):\n\t\tdata[i, :] = input_row(ncols, type, *args, **kwargs)\n\treturn data\n\nfrom itertools import repeat\n\nclass IntAddition (object):\n\t'''\u6574\u6570\u306e\u52a0\u6cd5'''\n\tdef operate(self, x, y):\n\t\treturn x + y\n\t@property\n\tdef identity(self):\n\t\treturn 0\n\tdef cancel(self, x, y):\n\t\treturn x - y\n\tdef invert(self, x):\n\t\treturn -x\n\tdef accumulate(self, x, count):\n\t\treturn x * count\n\nclass UnionFind (object):\n\t'''\u91cd\u307f\u4ed8\u304dUnion-Find\u6728'''\n\tdef __init__(\n\t\t\tself,\n\t\t\tnum_nodes=0,\n\t\t\tabelian_operator=IntAddition()):\n\t\tself.parent = []\n\t\tself.potential = []\n\t\tself.op = abelian_operator\n\t\t\n\t\tself.extend(num_nodes)\n\t\n\tdef append(self):\n\t\tself.parent.append(-1)\n\t\tself.potential.append(self.op.identity)\n\t\n\tdef extend(self, num_nodes):\n\t\tself.parent.extend(repeat(-1, num_nodes))\n\t\tself.potential.extend(repeat(self.op.identity, num_nodes))\n\t\n\tdef root(self, x):\n\t\tparent = self.parent[x]\n\t\tif 0 <= parent:\n\t\t\tself.parent[x] = self.root(parent)\n\t\t\tself.potential[x] = self.op.operate(\n\t\t\t\tself.potential[x], self.potential[parent]\n\t\t\t)\n\t\t\tx = self.parent[x]\n\t\treturn x\n\t\n\tdef difference_from_root_to(self, x):\n\t\tself.root(x)\n\t\treturn self.potential[x]\n\t\t\n\tdef size(self, x):\n\t\treturn -self.parent[self.root(x)]\n\t\n\tdef difference(self, x, y):\n\t\tif not self.issame(x, y):\n\t\t\traise RuntimeError('x \u3068 y \u306f\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u307e\u305b\u3093\u3002')\n\t\treturn self.op.cancel(\n\t\t\tself.difference_from_root_to(y),\n\t\t\tself.difference_from_root_to(x)\n\t\t)\n\t\n\tdef unite(self, x, y, difference=None):\n\t\tif difference is None:\n\t\t\tdifference = self.op.identity\n\t\t\n\t\tx, px = self.root(x), self.potential[x]\n\t\ty, py = self.root(y), self.potential[y]\n\t\tdifference = self.op.cancel(difference, py)\n\t\tdifference = self.op.operate(difference, px)\n\t\tif x == y:\n\t\t\treturn difference == 0\n\t\t\n\t\tif self.size(x) < self.size(y):\n\t\t\tx, y = y, x\n\t\t\tdifference = self.op.invert(difference)\n\t\tself.parent[x] += self.parent[y]\n\t\tself.parent[y] = x\n\t\tself.potential[y] = difference\n\t\t\n\t\treturn True\n\t\n\tdef issame(self, x, y):\n\t\treturn self.root(x) == self.root(y)\n\n\n\nN, M = inputs(int)\nuf = UnionFind(num_nodes=N)\n\nvalid = True\nfor i in range(M):\n\tL, R, D = inputs(int)\n\tL -= 1\n\tR -= 1\n\t\n\tif not uf.unite(L, R, D):\n\t\tvalid = False\n\nprint(('Yes' if valid else 'No'))\n", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n\n    g = tuple(set() for _ in range(N))\n    h = [0] * N  # \u5165\u308a\u6b21\u6570\n    for _ in range(M):\n        L, R, D = list(map(int, input().split()))\n        L -= 1\n        R -= 1\n        g[L].add((R, D))\n        h[R] += 1\n\n    dist = [-1] * N\n\n    def dfs(s):\n        dist[s] = 0\n        dq = deque([s])\n        while dq:\n            v = dq.popleft()\n            for u, d in g[v]:\n                if ~dist[u]:\n                    if dist[u] != dist[v] + d:\n                        return False\n                else:\n                    dist[u] = dist[v] + d\n                    dq.append(u)\n        return True\n\n    # \u59cb\u70b9\u304b\u3089\u306e\u30d1\u30b9\u3092\u51e6\u7406\n    for s in range(N):\n        if h[s]: continue  # s\u306b\u5165\u3063\u3066\u304f\u308b\u30d1\u30b9\u304c\u3042\u308b\u306e\u3067\u3001s\u3092\u59cb\u70b9\u306b\u3057\u306a\u3044\n        if ~dist[s]: continue\n        if not dfs(s):\n            print('No')\n            return\n\n    # \u30b5\u30a4\u30af\u30eb\u3092\u51e6\u7406\uff08\u3069\u306e\u70b9\u3082\u5165\u308b\u30d1\u30b9\u304c\u3042\u308a\u3001\u51e6\u7406\u3067\u304d\u3066\u3044\u306a\u3044\uff09\n    for s in range(N):\n        if ~dist[s]: continue\n        if not dfs(s):\n            print('No')\n            return\n\n    print('Yes')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# \u4eba\u3092\u9802\u70b9\u3068\u898b\u306a\u3057\u305f\u30b0\u30e9\u30d5\u3092\u4f5c\u308b\u3002\u6709\u5411\u3067\u3001\u9006\u5411\u304d\u306e\u5834\u5408\u306f\u6b63\u8ca0\u3092\u53cd\u8ee2\u3055\u305b\u3066\u8fba\u3092\u5f35\u308b\n# \u9802\u70b9\u304b\u3089\u306e\u8ddd\u96e2\u3092\u8a18\u9332\u3057\u3001\u4e00\u81f4\u3057\u306a\u3044\u7b87\u6240\u304c\u3042\u308c\u3070NG\u3002\n# \u5168\u3066\u306e\u8fba\u3092\u901a\u308b\u307e\u3067\u7d9a\u3051\u308b\u3002\n# \u8fba\u306e\u60c5\u5831\u3092[{0\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},{1\u304b\u3089\u884c\u3051\u308b\u9802\u70b9},...]\u3067\u7ba1\u7406\u3059\u308b\n# \u89aa\u306b\u306f\u9032\u307e\u306a\u3044\u3088\u3046\u306b\u3057\u3066DFS\u3059\u308b\n\nN,M = list(map(int,input().split()))\nE = [[] for i in range(N)]\nfor i in range(M):\n  L,R,D = list(map(int,input().split()))\n  E[L-1].append([R-1,D])\n  E[R-1].append([L-1,-D])\nfrom collections import deque\n# \u9802\u70b9\u3001\u89aa\u3001\u8ddd\u96e2\nINF = 10 ** 10\ndist = [INF] * N\nfor i in range(N):\n  if dist[i] != INF:\n    continue\n  dist[i] = 0\n  q = deque()\n  # \u9802\u70b9\u3001\u89aa\n  q.append([i,-1])\n  while q:\n    v,parent = q.pop()\n    for child in E[v]:\n      if child[0] == parent:\n        continue\n      if dist[child[0]] == INF:\n        dist[child[0]] = dist[v] + child[1]\n        q.append([child[0],v])\n      else:\n        if dist[child[0]] != dist[v] + child[1]:\n          print(\"No\")\n          return\nelse:\n  print(\"Yes\")\n", "import sys\nsys.setrecursionlimit(10**9)\n\nread=sys.stdin.read\n    \ndef main():\n    class Unionfind():\n        def __init__(self,n):\n            self.parents=[-1]*n\n            self.dist=[0]*n \n        \n        def find(self,x):\n            if self.parents[x]<0:\n                return self.dist[x],x\n            else:\n                tmp=self.find(self.parents[x])\n                self.dist[x]+=tmp[0]\n                self.parents[x]=tmp[1]\n            return self.dist[x], self.parents[x]\n        \n        def union(self,x,y,d):\n            rx=self.find(x)[1]\n            ry=self.find(y)[1]\n            diff=self.dist[y]-self.dist[x]-d\n            if rx==ry:\n                if diff!=0:\n                    return True\n                return False\n            if diff<0:\n                rx,ry=ry,rx\n                diff=-diff\n            self.parents[ry]=min(self.parents[ry],self.parents[rx]-diff)\n            self.parents[rx]=ry\n            self.dist[rx]=diff\n            return False\n    n,m,*lrd=list(map(int,read().split()))\n    edg=[]\n    v=Unionfind(n)\n    for l,r,d in zip(*[iter(lrd)]*3):\n        if v.union(l-1,r-1,d):\n            print('No')\n            break\n    else:\n        if max(-d-1 for d in v.parents if d<0) >10**9:\n            print('No')\n        else:\n            print('Yes')\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    l, r, d = map(int, input().split())\n    graph[l-1].append((r-1, d))\n    graph[r-1].append((l-1, -d))\nseen = [False]*n\ndist = [None]*n\nfor i in range(n):\n    if seen[i]:\n        continue\n    q = deque([i])\n    dist[i] = 0\n    while q:\n        node = q.popleft()\n        if seen[node]:\n            continue\n        seen[node] = True\n        for c_node, d in graph[node]:\n            if dist[c_node] is None:\n                dist[c_node] = dist[node] + d\n            elif dist[c_node] != dist[node] + d:\n                print('No')\n                return\n            if not seen[c_node]:\n                q.append(c_node)\nprint('Yes')", "n,m=list(map(int,input().split()))\nlrd=[tuple(map(int,input().split())) for i in range(m)]\n\nclass WeightedUnionFind:\n  def __init__(self,n):\n    self.parent = [i for i in range(n)]\n    self.rank = [0] * n\n    self.count = 0\n    self.weight = [0] * n\n  def root(self,a):\n    if self.parent[a] == a:\n      return a\n    else:\n      pa = self.root(self.parent[a])\n      self.weight[a] += self.weight[self.parent[a]]\n      self.parent[a] = pa\n      return pa\n  def is_same(self,a,b):\n    return self.root(a) == self.root(b)\n  def unite(self,a,b,w):\n    ra = self.root(a)\n    rb = self.root(b)\n    if ra == rb: return\n    if self.rank[ra] < self.rank[rb]:\n      self.parent[ra] = rb\n      self.weight[ra] = w - self.weight[a] + self.weight[b]\n    else:\n      self.parent[rb] = ra\n      self.weight[rb] = -w - self.weight[b] + self.weight[a]\n      if self.rank[ra] == self.rank[rb]: self.rank[ra] += 1\n    self.count += 1\n  def diff(self,a,b):\n    return self.weight[a] - self.weight[b]\n\nuf=WeightedUnionFind(n)\nfor l,r,d in lrd:\n  l,r=l-1,r-1\n  if uf.is_same(l,r):\n    if uf.diff(l,r)!=d:\n      print('No')\n      return\n  else:\n      uf.unite(l,r,d)\nprint('Yes')\n", "from collections import deque\nN,M = map(int, input().split())\nE = [[] for _ in range(N)]\nfor _ in range(M):\n  l,r,d = map(int, input().split())\n  l,r = l-1,r-1\n  E[l].append((r,d))\n  E[r].append((l,-d)) \n  \n#for e in E:\n#  print(e)\n  \n# bfs\nQ = deque()\nvisited = [False] * N\nwillSearch = [False] * N\nINF = 10**16\nA = [ INF ] * N\n\nfor i in range(N):\n  if visited[i]:\n    continue\n  Q.append((i,-1,0))\n  while Q:\n    now, prev, num = Q.popleft()\n    visited[now] = True\n    if A[now] == INF:\n      A[now] = num\n    elif A[now] != num:\n      # \u3042\u308b\u70b9\u306b\u304a\u3044\u30662\u901a\u308a\u306enum\u8a2d\u5b9a\u306e\u4ed5\u65b9\u304c\u3042\u308b\n      #print(now,prev,num,A[inxt])\n      print(\"No\")\n      return\n    for nxt, dis in E[now]:\n      if nxt == prev:\n        continue\n      if A[nxt] < INF and A[nxt] != num + dis:\n        # \u3042\u308b\u70b9\u306b\u304a\u3044\u30662\u901a\u308a\u306enum\u8a2d\u5b9a\u306e\u4ed5\u65b9\u304c\u3042\u308b\n        #print(now,prev,num, nxt,dis, A[nxt])\n        print(\"No\")\n        return\n      if visited[nxt] or willSearch[nxt]:\n        continue\n      Q.append((nxt, now, num + dis))\n      willSearch[nxt] = True\n    \nprint(\"Yes\")", "from collections import deque\n\nN, M = list(map(int, input().split()))\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n  L, R, D = list(map(int, input().split()))\n  G[L-1].append((R-1, D))\n  G[R-1].append((L-1, -D))\n  \nvisited = [False] * N\nxs = [0] * N\nxs[0] = 0\nx = 0\nfor i in range(N):\n  if visited[i]:\n    continue\n  stack = deque([(i, x)])\n  visited[i] = True\n  while stack:\n    now, xi = stack.popleft()\n    for nx, di in G[now]:\n      if visited[nx]:\n        if xs[nx] != xi + di:\n          print('No')\n          return\n      else:\n        xs[nx] = xi + di\n        visited[nx] = True\n        stack.append((nx, xi+di))\n        \nif max(xs)-min(xs) > 1000000000:\n  print('No')\nelse:\n  print('Yes')\n\n", "import sys\nfrom typing import List, Optional\n\nsys.setrecursionlimit(1000000)\n\nN, M = list(map(int, input().split()))\n\ng = [[] for _ in range(N)]\n\nfor i in range(M):\n    l, r, d = list(map(int, input().split()))\n    l -= 1\n    r -= 1\n    g[l].append((r, d))\n    g[r].append((l, -d))\n\n\ndef ok(cur: int, ds: int, dists: List[Optional[int]]) -> bool:\n    dists[cur] = ds\n\n    flag = True\n    for nx, d in g[cur]:\n        if dists[nx] != None:\n            flag &= dists[nx] - dists[cur] == d\n        elif flag:\n            flag &= ok(nx, ds + d, dists)\n\n    return flag\n\n\ndists = [None] * N\nans = True\nfor i in range(N):\n    if ans and dists[i] == None:\n        ans &= ok(i, 0, dists)\n\nprint((\"Yes\" if ans else \"No\"))\n", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\nclass UnionFindWeighted:\n    # Reference: https://note.nkmk.me/python-union-find/\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.weight = [0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            root = self.find(self.parents[x])\n            self.weight[x] += self.weight[self.parents[x]]\n            self.parents[x] = root\n            return root\n\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n\n        if rx == ry:\n            return\n\n        if self.parents[rx] > self.parents[ry]:\n            x, y, rx, ry, w = y, x, ry, rx, -w\n\n        self.parents[rx] += self.parents[ry]\n        self.parents[ry] = rx\n        self.weight[ry] = self.weight[x] - self.weight[y] - w\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\n\ndef main():\n    N, M, *LRD = list(map(int, read().split()))\n\n    uf = UnionFindWeighted(N)\n    for l, r, d in zip(*[iter(LRD)] * 3):\n        l -= 1\n        r -= 1\n        if uf.same(l, r) and uf.diff(l, r) != d:\n            print('No')\n            return\n        else:\n            uf.union(l, r, d)\n\n    print('Yes')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class WeightedUnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(n))\n        self.rank = [0] * n\n        self.weight = [0] * n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n    def unite(self, x, y, w):\n        p, q = self.find(x), self.find(y)\n        if self.rank[p] < self.rank[q]:\n            self.par[p] = q\n            self.weight[p] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[q] = p\n            self.weight[q] = -w - self.weight[y] + self.weight[x]\n            if self.rank[p] == self.rank[q]:\n                self.rank[p] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\nn, m = map(int, input().split())\nUF = WeightedUnionFind(n)\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    if UF.same(l - 1, r - 1):\n        if UF.diff(l - 1, r - 1) != d:\n            print(\"No\");return\n    else:\n        UF.unite(l - 1, r - 1, d)\nprint(\"Yes\")", "from collections import deque\nimport sys\ninput = sys.stdin.readline\ninf = pow(10, 10)\n\nn, m = list(map(int, input().split()))\na = [inf] * n\n\nedge = [[] for i in range(n)]\n\nfor i in range(m):\n    l, r, d = list(map(int, input().split()))\n    l-=1;r-=1\n    edge[l].append((r, d))\n    edge[r].append((l, -d))\n\nflag = True\ndist = [inf] * n\nfor i in range(n):\n    if not flag: break\n    if dist[i] == inf:\n        dist[i] = 0\n        dq = deque([i])\n        while dq:\n            now = dq.popleft()\n            for e in edge[now]:\n                nnode, d = e\n                if dist[nnode] == inf:\n                    dist[nnode] = dist[now] + d\n                    dq.append(nnode)\n                else:\n                    if dist[nnode] != dist[now] + d:\n                        flag = False\n                        break\nif flag:\n    print('Yes')\nelse:\n    print('No')\n", "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # \u4f75\u5408\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\n\nN, M = map(int, input().split())\nuf = WeightedUnionFind(N)\n\nfor _ in range(M):\n    l, r, d = map(int, input().split())\n    l -= 1\n    r -= 1\n    if uf.same(l, r):\n        diff = uf.diff(l, r)\n        if diff != d:\n            print(\"No\")\n            return\n    else:\n        uf.union(l, r, d)\n\nprint(\"Yes\")", "class WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        # \u6839\u3078\u306e\u8ddd\u96e2\u3092\u7ba1\u7406\n        self.weight = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            # \u89aa\u3078\u306e\u91cd\u307f\u3092\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6839\u307e\u3067\u8d70\u67fb\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    # \u4f75\u5408\n    def union(self, x, y, w):\n        rx = self.find(x)\n        ry = self.find(y)\n        # x\u306e\u6728\u306e\u9ad8\u3055 < y\u306e\u6728\u306e\u9ad8\u3055\n        if self.rank[rx] < self.rank[ry]:\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        # x\u306e\u6728\u306e\u9ad8\u3055 \u2267 y\u306e\u6728\u306e\u9ad8\u3055\n        else:\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u3060\u3063\u305f\u5834\u5408\u306e\u51e6\u7406\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u304b\u3089y\u3078\u306e\u30b3\u30b9\u30c8\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n    \nn,m = map(int,input().split())\nlrd = [[int(i) for i in input().split()] for j in range(m)]\n\nki = WeightedUnionFind(n)\n\nfor i in range(m):\n    if ki.same(lrd[i][0],lrd[i][1]):\n        if ki.diff(lrd[i][0],lrd[i][1]) != lrd[i][2]:\n            print('No')\n            return\n    else:\n        ki.union(lrd[i][0],lrd[i][1],lrd[i][2])\n    \nprint('Yes')", "# \u6df1\u3055\u512a\u5148\u63a2\u7d22\nfrom sys import stdin\n\nN, M = list(map(int, stdin.readline().split()))\n\nlinks = [[] for _ in range(N + 1)]\nfor _ in range(M):\n    L, R, D = list(map(int, stdin.readline().split()))\n    links[L].append((R, D))\n    links[R].append((L, -D))\n\nt = [None] * (N + 1)\nfor i in range(1, N + 1):\n    if t[i] is not None:\n        continue\n    t[i] = 0\n    s = [i]\n    while s:\n        j = s.pop()\n        for k, l in links[j]:\n            if t[k] is None:\n                t[k] = t[j] + l\n                s.append(k)\n            else:\n                if t[k] != t[j] + l:\n                    print('No')\n                    return\nprint('Yes')\n"]
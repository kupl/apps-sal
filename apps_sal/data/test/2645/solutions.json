["s=input()\nn=len(s)\np=0\nfor i in range(n):\n  if s[i]=='p':\n    p+=1\nprint(n//2-p)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    S = readline().strip()\n\n    ans = len(S) // 2 - S.count('p')\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s=input()\ncount=0\nfor i in range(len(s)):\n  if i % 2 == 0:\n    if s[i]=='p':\n      count -= 1\n  else:\n    if s[i]=='g':\n      count += 1\n\nprint(count)", "S = input()\np = 0\ng = 0\na = 0\n\nfor s in S:\n  if s==\"p\":\n    if p+1<=g:\n      a+=0\n      p+=1\n    else:\n      a-=1\n      g+=1\n  else:\n    if p+1<=g:\n      a+=1\n      p+=1\n    else:\n      a+=0\n      g+=1\n\nprint(a)", "def main():\n    s = input()\n    print((len(s) // 2 - s.count('p')))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nng = s.count('g')\nnp = s.count('p')\n\nsurplus = ng - np\nprint(surplus // 2)", "s = input();print(len(s)//2-s.count(\"p\"))", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    s=SI()\n    print(len(s)//2-s.count(\"p\"))\n\nmain()", "S = input()\nPossiblePaper = 0\nScore = 0\nfor s in S:\n    if s == \"g\":\n        if PossiblePaper == 0:\n            Score += 0\n            PossiblePaper += 1\n        else:\n            Score += 1\n            PossiblePaper -= 1\n    else:\n        if PossiblePaper == 0:\n            Score -= 1\n            PossiblePaper += 1\n        else:\n            Score += 0\n            PossiblePaper -= 1\nprint(Score)\n", "import sys\ndef v():\n    pt=[5,0,1,2]\n    s=list(['0' if x=='g' else '1' for x in list(sys.stdin.readline().strip())])\n    n=len(s)\n    p=pt[n%4]\n    for _ in range(n//4):p=(p<<4)+5\n    ss=list(format(p,'b').zfill(n))\n    res=0\n    for a,b in zip(s,ss):\n        d=int(b)-int(a)\n        res = res if d==0 else res+d\n    print(res)\ndef __starting_point():v()\n\n__starting_point()", "import math\ns = input()\nn = len(s)\nprint(math.floor(n/2) - s.count(\"p\"))", "import numpy as np\nimport sys\ndef sinput(): return sys.stdin.readline()\ndef iinput(): return int(sinput())\ndef imap(): return map(int, sinput().split())\ndef fmap(): return map(float, sinput().split())\ndef iarr(): return list(imap())\ndef farr(): return list(fmap())\ndef sarr(): return sinput().split()\n\ns = input()\np = g = ans = 0\nfor i in s:\n    if i=='p':\n        if p < g: p += 1\n        else: ans -= 1; g += 1\n    if i=='g':\n        if p < g: ans += 1; p += 1\n        else: g += 1\nprint(ans)", "s=list(input())\n\nanswer=0\nfor i in range(len(s)):\n  if i%2==0 and s[i]==\"p\":\n    answer-=1\n  elif i%2==1 and s[i]==\"g\":\n    answer+=1\n\nprint(answer)", "z = 0\nfor i, c in enumerate(input().replace(\"g\", \"r\")):\n    if i % 2 == 0 and c == \"r\":\n        pass\n    elif i % 2 == 0 and c == \"p\":\n        z -= 1\n    elif c == \"p\":\n        pass\n    else:\n        z += 1\nprint(z)\n", "def main():\n    s = input()\n    n = len(s)\n    g = s.count('g')\n    p = n - g\n    ans = n // 2 - p\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import ceil\ns=input()\ngu=s.count('g')\npa=s.count('p')\n\np=len(s)//2\ng=int(ceil(len(s)/2))\n\ngu,g=gu-min(gu,g),g-min(gu,g)\npa,p=pa-min(pa,p),p-min(pa,p)\n\nif g==0 and gu==0 and p==0 and pa==0:\n  print(0)\n  return\n  \nif p==0 and gu==0:\n  print(-g)\n  return\n  \nif pa==0 and g==0:\n  print(gu)\n  return", "def main():\n    s = input()\n    print((len(s) // 2 - s.count('p')))\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nn = len(s)\nprint(s[(n+1)//2:].count(\"g\")-s[:(n+1)//2].count(\"p\"))", "def main():\n    s = input()\n    score = 0\n    diff = 0\n    for i in range(len(s)):\n        if s[i] == \"g\":\n            if diff == 0:\n                diff += 1\n            else:\n                diff -= 1\n                score += 1\n        else:\n            if diff == 0:\n                diff = 1\n                score -= 1\n            else:\n                diff -= 1\n    print((max(score, 0)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "s = input()\n\np = 0\nfor x in s:\n  if x == 'p':\n    p += 1\n    \nprint(len(s)//2 - p)", "s = input()\nr = 0\np = 0\nscore = 0\nfor x in s:\n    if x == \"g\":\n        if p < r:\n            p += 1\n            score += 1\n        else:\n            r += 1\n    else:\n        if p < r:\n            p += 1\n        else:\n            score -= 1\n            r += 1\nprint(score)", "s = input()\n\np = 0\ng = 0\nres = 0\n\nfor i in range(len(s)):\n    if s[i] == 'g':\n        if p < g:\n            p += 1\n            res += 1\n        else:\n            g += 1\n    else:\n        if p < g:\n            p += 1\n        else:\n            g += 1\n            res -= 1\n\nprint(res)", "p = 0\ng = 0\nS = list(input())\nans = 0\nfor i in range(len(S)):\n    if S[i] == \"g\" and p < g:\n        ans += 1\n        p += 1\n    elif S[i] == \"g\" and p == g:\n        g += 1\n    if S[i] == \"p\" and p < g:\n        p += 1\n    elif S[i] == \"p\" and p == g:\n        ans -= 1\n        g += 1\nprint(ans)\n", "def judge(mygp,yourgp):\n  if mygp=='g' and yourgp=='p':\n    return -1\n  elif mygp=='p' and yourgp=='g':\n    return 1\n  else:\n    return 0\n\ns=[x for x in input()]\nt=[['g','p'][x%2] for x in range(len(s))]\nprint(sum([judge(a,b) for a,b in zip(t,s)]))", "def main():\n    print((sum((1 - (-1) ** i) // 2 if j == 'g' else (1 - (-1) ** i) // 2 - 1 for i, j in enumerate(input()))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nn = len(s)\ncharge = 0\nscore = 0\nfor i in range(n):\n    if s[i] == 'g':\n        if charge > 0:\n            score += 1\n            charge -= 1\n        else:\n            charge += 1\n    else:\n        if charge > 0:\n            charge -= 1\n        else:\n            score -= 1\n            charge += 1\n\nprint(score)\n", "s = str(input())\nk = 0\np = 0\nfor i in range(len(s)):\n  if k > 0:\n    if s[i] == 'g':\n      k -= 1\n      p += 1\n    else:\n      k -= 1\n  else:\n    if s[i] == 'g':\n      k += 1\n    else:\n      k += 1\n      p -= 1\nprint(p)\n      \n    \n     \n  \n  \n", "def main():\n  s = input()\n  cc_g = cc_p = 0\n  for c in s:\n    if c == 'g': cc_g += 1\n    else: cc_p += 1\n  print((cc_g - cc_p) // 2)\n  return\n\ndef __starting_point():\n  main()\n__starting_point()", "s = input()\nslist = list(s)\n\ngs = slist.count(\"g\")\nps = slist.count(\"p\")\n\nif len(slist) % 2==0:\n    res = (gs-ps)//2\n    \nelse:\n    res= (gs-1-ps)//2\n\nprint(res)", "s = input()\nn = len(s)\np = 0\nfor e in s:\n  if e == 'p':\n    p += 1\nprint((n//2 - p))\n", "s=input()\nprint(len(s)//2-s.count('p'))", "s=input()\nnp=0\nng=0\nans=0\nfor si in s:\n  if si=='g' and np<ng:\n    ans+=1\n    np+=1\n  elif si=='g' and np>=ng:\n    ng+=1\n  elif si=='p' and np<ng:\n    np+=1\n  elif si=='p' and np>=ng:\n    ans-=1\n    ng+=1\nprint(ans)", "s = input()\nprint(s.count('g')-(-((-len(s))//2)))", "s = input()\nn_s = len(s)\nn_p = n_s // 2\nn_g = n_s - n_p\nprint(n_p-s.count('p'))", "s=input()\nprint(len(s)//2-s.count('p'))", "T = input().strip()\nn = len(T)\n\np = n // 2\ng = n - p\n\nA = 'g' * g + 'p' * p\n\nans = 0\nfor a, t in zip(A, T):\n    if a == 'p' and t == 'g':\n        ans += 1\n    if a == 'g' and t == 'p':\n        ans -= 1\n\nprint(ans)\n\n\n", "import sys\nimport heapq\nimport re\nfrom itertools import permutations\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, deque\nfrom fractions import gcd\nfrom math import factorial, sqrt, ceil\nfrom functools import lru_cache, reduce\nINF = 1 << 60\nMOD = 1000000007\nsys.setrecursionlimit(10 ** 7)\n\n# UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\ndef dijkstra_heap(s, edge, n):\n    #\u59cb\u70b9s\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    d = [10**20] * n\n    used = [True] * n #True:\u672a\u78ba\u5b9a\n    d[s] = 0\n    used[s] = False\n    edgelist = []\n    for a,b in edge[s]:\n        heapq.heappush(edgelist,a*(10**6)+b)\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\n        if not used[minedge%(10**6)]:\n            continue\n        v = minedge%(10**6)\n        d[v] = minedge//(10**6)\n        used[v] = False\n        for e in edge[v]:\n            if used[e[1]]:\n                heapq.heappush(edgelist,(e[0]+d[v])*(10**6)+e[1])\n    return d\n\n# \u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\n# 2\u6570\u306e\u6700\u5c0f\u516c\u500d\u6570\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\n# \u30ea\u30b9\u30c8\u306e\u8981\u7d20\u306e\u6700\u5c0f\u516c\u500d\u6570\ndef lcm_list(numbers):\n    return reduce(lcm, numbers, 1)\n\n# \u30ea\u30b9\u30c8\u306e\u8981\u7d20\u306e\u6700\u5927\u516c\u7d04\u6570\ndef gcd_list(numbers):\n    return reduce(gcd, numbers)\n\n# \u7d20\u6570\u5224\u5b9a\ndef is_prime(n):\n    if n <= 1:\n        return False\n    p = 2\n    while True:\n        if p ** 2 > n:\n            break\n        if n % p == 0:\n            return False\n        p += 1\n    return True\n\n\n# limit\u4ee5\u4e0b\u306e\u7d20\u6570\u3092\u5217\u6319\ndef eratosthenes(limit):\n    A = [i for i in range(2, limit+1)]\n    P = []\n\n    while True:\n        prime = min(A)\n        \n        if prime > sqrt(limit):\n            break\n            \n        P.append(prime)\n            \n        i = 0\n        while i < len(A):\n            if A[i] % prime == 0:\n                A.pop(i)\n                continue\n            i += 1\n            \n    for a in A:\n        P.append(a)\n            \n    return P\n\n# \u540c\u3058\u3082\u306e\u3092\u542b\u3080\u9806\u5217\ndef permutation_with_duplicates(L):\n\n    if L == []:\n        return [[]]\n\n    else:\n        ret = []\n\n        # set\uff08\u96c6\u5408\uff09\u578b\u3067\u91cd\u8907\u3092\u524a\u9664\u3001\u30bd\u30fc\u30c8\n        S = sorted(set(L))\n\n        for i in S:\n\n            data = L[:]\n            data.remove(i)\n\n            for j in permutation_with_duplicates(data):\n                ret.append([i] + j)\n\n        return ret\n\n\n# \u3053\u3053\u304b\u3089\u66f8\u304d\u59cb\u3081\u308b\ns = input()\ncntg = s.count(\"g\")\ncntp = s.count(\"p\")\nans = max(0, cntg - cntp) // 2\nprint(ans)", "s = input()\ns0 = s[::2]\ns1 = s[1::2]\nprint(s1.count('g') - s0.count('p'))", "S = input()\nN = len(S)\nprint(N // 2 - sum([int(s == 'p') for s in S]))", "s = input()\ng = 0\np = 0\nfor i in s:\n    if i == \"g\":\n        g += 1\n    else:\n        p += 1\nprint(((g-p)//2))\n", "s = input()\n\ngs = 0\nps = 0\n\nfor ss in s:\n    if ss == 'g':\n        gs += 1\n    else:\n        ps += 1\n\nprint(max(0,(gs - ps) // 2))", "import math\ns = input()\n \nans = 0\n \nr = 0\np = 0\nc = 0\nfor j in s:\n  c = r-p\n  if j == 'g':\n    if c > 0:\n      p += 1\n      ans += 1\n    else:\n      r += 1\n  else:\n    if c > 0:\n      p += 1\n    else:\n      r += 1\n      ans -= 1\nprint (ans)", "s = input()\nN = len(s)\nD = {\"g\":0, \"p\":0}\nfor i in range(N):\n    D[s[i]] += 1\nmy_p = N//2\nscore = my_p - D[\"p\"]\nprint(score)", "s = input()\n\ng = s.count(\"g\")\np = s.count(\"p\")\n\nmax_p = (g+p)//2\nmax_g = g+p-(g+p)//2\n\nprint(max_p-(max_g-(g-max_p)))", "S = input()\nprint(len(S)//2-S.count(\"p\"))", "from collections import Counter\ns = input()\ncount = Counter(s)\nans = 0\nfor i in s[::-1]:\n    if i == 'g':\n        if count['g'] >= count['p'] + 2:\n            ans += 1\n            count['g'] -= 1\n            count['p'] += 1\nprint(ans)", "S = sorted(list(input()))\n\np = len(S) // 2\ng = len(S) // 2\nif len(S) % 2 ==1:\n    g += 1\nT = ['g'] * g + ['p'] * p\nans = 0\nfor i in range(len(S)):\n    if T[i] == 'g' and S[i] == 'p':\n        ans -= 1\n    if T[i] == 'p' and S[i] == 'g':\n        ans += 1\nprint(ans)\n", "s = input()\nl = len(s)\ncp = s.count(\"p\")\ncg = l - cp\npmax = l//2\nprint((pmax-cp))\n", "s = input()\nN = len(s)\nans = 0\nfor c in s:\n    if c == \"p\":\n        ans -= 1\nans += N // 2\nprint(ans)\n", "s = input()\ngu = 1\npa = 0\npoint = 0\nif s[0] == \"p\":\n  point -= 1\n  \nfor hand in s[1:]:\n  if hand == \"g\":\n    if pa<gu:\n      point += 1\n      pa += 1\n    else:\n      gu += 1\n  elif hand == \"p\":\n    if pa<gu:\n      pa += 1\n    else:\n      gu += 1\n      point -= 1\nprint(point)", "s = input()\nn = len(s)\ngcount = 0\npcount = 0\nscore = 0\nfor i in range(n):\n    if s[i] == \"g\":\n        if gcount > pcount:\n            pcount += 1\n            score += 1\n        else:\n            gcount += 1\n    else:\n        if gcount > pcount:\n            pcount += 1\n        else:\n            gcount += 1\n            score -= 1\nprint(score)", "S = input()\ncp = 0\ncg = 0\npoint = 0\nfor s in S:\n    if s == 'g':\n        if cp + 1 <= cg:\n            point += 1\n            cp += 1\n        else:\n            cg += 1\n    else:\n        if cp + 1 <= cg:\n            cp += 1\n        else:\n            point -= 1\n            cg += 1\nprint(point)\n", "s = input()\nn = s.count(\"p\")\nprint(len(s)//2 - n)", "def main():\n    S = input()\n    p = sum([1 for c in S if c == 'p'])\n    print(len(S) // 2 - p)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\ns=input()\nc = Counter(s)\ng = c['g']\np = c['p']\nprint(((g-p)//2))\n", "ans = 0\n\nfor i,c in enumerate(input()):\n  if i%2 == 0 and c == \"p\": ans -= 1\n  elif i%2 == 1 and c == \"g\": ans += 1\n\nprint(ans)", "s=list(input())\n\nnum_g=num_p=0\nanswer=0\nfor i in range(len(s)):\n  if num_g==num_p:\n    num_g+=1\n    if s[i]==\"p\":\n      answer-=1\n  else:\n    num_p+=1\n    if s[i]==\"g\":\n      answer+=1\n\nprint(answer)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    S = readline().strip()\n\n    g, p = 0, 0\n    ans = 0\n    for c in S:\n        if g > p:\n            p += 1\n            if c == 'g':\n                ans += 1\n        else:\n            g += 1\n            if c == 'p':\n                ans -= 1\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def abc046_d():\n    s = str(input())\n    n = len(s)\n    if n == 1: return 0\n    gc = [0] * n\n    pc = [0] * n\n    for i, c in enumerate(s):\n        gc[i] = gc[i-1] + c.count('g')\n        pc[i] = pc[i-1] + c.count('p')\n    ans = (gc[-1] - pc[-1]) // 2\n    return ans\n\ndef __starting_point():\n    print(abc046_d())\n__starting_point()", "#!/usr/bin/env python3\n\nimport sys\n# import time\n# import math\n# import numpy as np\n# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall\n# import random                                # random, uniform, randint, randrange, shuffle, sample\n# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits\n# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)\n# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).\n# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()\n# from collections import defaultdict          # subclass of dict. defaultdict(facroty)\n# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)\n# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj\n# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj\n# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.\n# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference\n# from functools import reduce                 # reduce(f, iter[, init])\n# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)\n# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).\n# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).\n# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])\n# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]\n# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]\n# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])\n# from itertools import combinations, combinations_with_replacement\n# from itertools import accumulate             # accumulate(iter[, f])\n# from operator import itemgetter              # itemgetter(1), itemgetter('key')\n# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)\n\n\n\ndef main():\n    mod = 1000000007                # 10^9+7\n    inf = float('inf')              # sys.float_info.max = 1.79...e+308\n    # inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19\n    sys.setrecursionlimit(10**6)    # 1000 -> 1000000\n    def input(): return sys.stdin.readline().rstrip()\n    def ii():    return int(input())\n    def mi():    return list(map(int, input().split()))\n    def mi_0():  return [int(x)-1 for x in input().split()]\n    def lmi():   return list(map(int, input().split()))\n    def lmi_0(): return list([int(x)-1 for x in input().split()])\n    def li():    return list(input())\n    \n    \n    s = input()\n    n = len(s)\n    par_counter = s.count('p')\n    print((n // 2 - par_counter))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\ndef v():\n    pt=[5,0,1,2]\n    N=100000\n    s=list(['0' if x=='g' else '1' for x in list(sys.stdin.readline().strip())])\n    n,x=len(s),int(''.join(s),2)\n    s=list(format(x<<(N-n),'0100000b'))\n    p=pt[n%4]\n    for _ in range(n//4):p=(p<<4)+5\n    ss=list(format(p<<(N-n),'010000b'))\n    res=0\n    for _,a,b in zip(list(range(n)),s,ss):\n        d=int(b)-int(a)\n        res = res if d==0 else res+d\n    print(res)\ndef __starting_point():v()\n\n__starting_point()", "s = str(input())\n\nn = len(s)\n\ng_num = 0\np_num = 0\nwin = 0\nlose = 0\n\n\n\nfor i in range(n):\n    if s[i] == \"g\" and g_num >= p_num+1:\n        p_num+=1\n        win+=1\n    elif s[i] == \"g\":\n        g_num +=1\n    elif s[i] == \"p\" and g_num >= p_num+1:\n        p_num +=1\n    else:\n        g_num +=1\n        lose+=1\n\n\nprint((win-lose))\n    \n", "s = str(input())\nn = len(s)\n\nL = []\nc = 0\nans = 0\nfor i in range(n):\n    if c-1 >= 0:\n        if s[i] == 'g':\n            ans += 1\n            c -= 1\n        else:\n            c -= 1\n    else:\n        if s[i] == 'g':\n            c += 1\n        else:\n            ans -= 1\n            c += 1\nprint(ans)", "s = list(input())\nT_g = s.count(\"g\")\nT_p = s.count(\"p\")\n\nif T_g == T_p or T_g == T_p+1:\n  result = 0\n  print(result)\n  return\nelse:\n  P = (T_g + T_p) // 2\n  result = P - T_p\n  print(result)\n", "s = list(input())\ng = 0\np = 0\nans = 0\nfor i in range(len(s)):\n    if s[i] == \"g\":\n        if p+1 <= g:\n            ans += 1\n            p += 1\n        else:\n            g += 1\n    else:\n        if p+1 <= g:\n            p += 1\n        else:\n            ans -= 1\n            g += 1\nprint(ans)", "s=input();print(len(s)//2-s.count('p'))", "s = list(input())\n\nn = len(s)\n\np = n//2\n\nopp_p = s.count(\"p\")\n\nprint(p-opp_p)", "s = input()\nn = len(s)\n\ng, p = 0, 0\nans = 0\nfor i in range(n):\n  if g == p:\n    g += 1\n    if s[i] == \"p\":\n      ans -= 1\n  else:\n    p += 1\n    if s[i] == \"g\":\n      ans += 1\n\nprint(ans)", "s = input()\nn = len(s)\np_cnt = s.count(\"p\")\nprint(n // 2 - p_cnt)", "# solution\nimport io\ndata=input()\ng=data.count('g')\np=data.count('p')\nresult=(-p+(g+p)//2)\nprint(result)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\n#import numpy as np\n#from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n#from decimal import Decimal, ROUND_HALF_UP, ROUND_HALF_EVEN\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\ns = ns()\nans = 0\nct = 0\nfor i in range(len(s)):\n    if ct == 0:\n        ct += 1\n        if s[i] == 'p':\n            ans -= 1\n    else:\n        ct -= 1\n        if s[i] == 'g':\n            ans += 1\nprint(ans)\n", "s = input()\nn_s = len(s)\nn_g = n_s - 1\nn_p = n_s // 2\nprint(n_p-s.count('p'))", "s=input()\nprint(len(s)//2-s.count('p'))", "s=input()\np=s.count(\"p\")\nprint(len(s)//2-p)", "s = input()\nN = len(s)\nans = N//2\nfor i in range(N):\n  if(s[i] == 'p'):\n    ans -= 1\nprint(ans)", "s = input()\nprint(len(s) // 2 - s.count('p'))", "s=input()\nn=len(s)\npcnt,gcnt=0,0\nans=[\"\"]*n\nfor i in range(n):\n    if s[i]==\"g\":\n        if gcnt>pcnt:\n            ans[i]=\"p\"\n            pcnt+=1\n        else:\n            ans[i]=\"g\"\n            gcnt+=1\n    if pcnt==n//2 or gcnt==-(-n//2):\n        break\ni,j=0,0\n#print(gcnt,pcnt)\nwhile -(-n//2)>gcnt:\n    if ans[i]==\"\":\n        ans[i]=\"g\"\n        gcnt+=1\n    i+=1\nwhile n//2>pcnt:\n    if ans[j]==\"\":\n        ans[j]=\"p\"\n        pcnt+=1\n    j+=1\nscore=0\n#print(ans)\nfor i in range(n):\n    if ans[i]==\"p\" and s[i]==\"g\":\n        score+=1\n    elif ans[i]==\"g\" and s[i]==\"p\":\n        score-=1\nprint(score)", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    s = input().rstrip()\n    n = len(s)\n    res = 0\n    for i in range(n):\n        if i <= (n-1)//2:\n            if s[i]=='p':\n                res -= 1\n        else:\n            if s[i] == 'g':\n                res += 1\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "s = input()\nprint(((s.count('g') - s.count('p')) // 2))\n", "s=input()\nn=len(s)\nt=0\nfor i in range(n):\n  if s[i]==\"p\":\n    t+=1\nprint((int(n/2)-t))\n", "s = input()\n\nans = 0\n\nfor i in range(len(s)):\n    if s[i] == 'g':\n        ans += 1\n    else:\n        ans -= 1\n        \nprint(ans//2)", "s = list(input())\nl = len(s)\np = s.count(\"p\")\nprint(l // 2 - p)", "s = input()\ng_cnt, p_cnt = 0, 0\nans = 0\nfor c in s:\n    if c == 'g':\n        if g_cnt > p_cnt:\n            ans   += 1\n            p_cnt += 1\n        else:\n            g_cnt += 1\n    else:\n        if g_cnt > p_cnt:\n            p_cnt += 1\n        else:\n            ans   -= 1\n            g_cnt += 1\nprint(ans)", "from math import floor \ns = input()\nn = len(s)\np = s.count('p')\nprint(floor(n/2)-p)", "s = input()\nprint(len(s)//2 - s.count(\"p\"))", "s = input()\nls = len(s)\ncnt = [0, 0]\nfor c in list(s):\n    cnt[c != \"g\"] += 1\n\nif ls % 2 == 1:\n    ls -= 1\n\nprint((ls//2-cnt[1]))\n", "s=input()\n\natd=''\ntpd=''\nfor i, t in enumerate(s):\n  \n  if t=='g':\n      tpd+='0'\n  else:\n      tpd+='1'\n      \n  if i%2==0:\n      atd+='0'\n  else:\n      atd+='1'\n\npoint=0\nfor a, t in zip(atd, tpd):\n  \n    x=int(a)-int(t)\n    \n    if x==1:\n        point+=1\n    elif x==-1:\n      point-=1\n      \n      \nprint(point)", "s=input()\npars=s.count(\"p\")\nprint(len(s)//2-pars)", "#coding: utf-8\nimport math\n\ns = input()\nans = math.floor(len(s)/2) - s.count(\"p\")\nprint(ans)", "g = 0\np = 0\n\nans = 0\nfor i in input():\n    if i == \"g\":\n        if p < g:\n            ans += 1\n            p += 1\n        else:\n            g += 1\n    else:\n        if p < g:\n            p += 1\n        else:\n            g += 1\n            ans -= 1\n\nprint(ans)", "s = input()\nn = len(s)\n\np = 0\nans = 0\n\nfor i in range(n):\n    s1 = s[i]\n    if s1 == 'g':\n        p += 1\n    else:\n        p -= 1\n    n -= 1\n    if p >= n:\n        break\n\nfor i in range(n):\n    if s[-i-1] == 'g':\n        ans += 1\n\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    s = input()\n\n    n = len(s) // 2\n    p = s.count(\"p\")\n    print((n - p))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "S = input()\nans = 0\nhand = ['g', 'p']\n\ndef do(s, t):\n  if s == t:\n    return 0\n  elif s == 'g':\n    return 1\n  else:\n    return -1\n\nfor i, s in enumerate(S):\n  ans += do(s, hand[i%2])\n\nprint(ans)", "s = input()\np = s.count('p')\nprint(len(s)//2-p)", "import sys\ndef v():\n    pt=[5,0,1,2]\n    s=list(['0' if x=='g' else '1' for x in sys.stdin.readline().strip()])\n    n=len(s)\n    p=pt[n%4]\n    for _ in range(n//4):p=(p<<4)+5\n    ss=list(format(p,'b').zfill(n))\n    res=0\n    for a,b in zip(s,ss):\n        d=int(b)-int(a)\n        res = res if d==0 else res+d\n    print(res)\ndef __starting_point():v()\n\n__starting_point()", "s = input()\nnum = s.count(\"g\") - s.count(\"p\")\nprint((num - len(s) % 2) // 2)", "s=input()\ng=s.count(\"g\")\nl=len(s)\nprint(g-(l+1)//2)", "s = input()\ngp = [1, 0]\np = 0\nif s[0] == 'p':\n    p -= 1\nfor i in range(1, len(s)):\n    if s[i] == 'g':\n        if gp[0] > gp[1]:\n            gp[1] += 1\n            p += 1\n        else:\n            gp[0] += 1\n    if s[i] == 'p':\n        if gp[0] > gp[1]:\n            gp[1] += 1\n        else:\n            gp[0] += 1\n            p -= 1\nprint(p)", "S = input()\nfrom collections import defaultdict as dd\nHand = dd(lambda:0)\nfor s in S:\n    Hand[s] += 1\nans = len(S)//2 - Hand['p']\nprint(ans)"]
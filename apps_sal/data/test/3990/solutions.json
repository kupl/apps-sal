["from collections import deque\nn,m=map(int,input().split())\na=[set() for i in range(n+1)]\nfor i in range(m):\n    x,y=map(int,input().split())  \n    a[x].add(y)\n    a[y].add(x)\nif n not in a[1]:\n    t=True\nelse:\n    t=False\nq=deque()\nq.append(1)\nz = [-1 for i in range(n+1)]\nz[1] = 0\nwhile len(q) > 0:\n    v = q.popleft()\n    for i in range(1, n+1):\n        if t ^ (i in a[v]):\n            continue\n        if z[i]==-1:\n            z[i]=z[v]+1\n            q.append(i)\n            if i == n:\n                print(z[i])\n                return\nprint(-1) ", "def read_data():\n    n, m = map(int, input().split())\n    Es = [[] for i in range(n)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        Es[u].append(v)\n        Es[v].append(u)\n    return n, m, Es\n\ndef solve(n, m, Es):\n    if n - 1 not in Es[0]:\n        return shortestpath(n, Es)\n    else:\n        Es = trans(n, Es)\n        return shortestpath(n, Es)\n\ndef trans(n, Es):\n    Emat = [[False] * n for i in range(n)]\n    for i, row in enumerate(Es):\n        for j in row:\n            Emat[i][j] = True\n    nEs = [[] for i in range(n)]\n    for u in range(n):\n        for v in range(n):\n            if u == v:\n                continue\n            if Emat[u][v]:\n                continue\n            nEs[u].append(v)\n    return nEs\n\ndef shortestpath(n, Es):\n    visited = [False] * n\n    visited[0] = True\n    steps = 0\n    fs = [0]\n    while fs:\n        nfs = []\n        for f in fs:\n            if f == n - 1:\n                return steps\n            for v in Es[f]:\n                if visited[v]:\n                    continue\n                nfs.append(v)\n                visited[v] = True\n        fs = nfs\n        steps += 1\n    return -1\n\nn, m, Es = read_data()\nprint(solve(n, m, Es))", "from queue import Queue\nimport sys\n\ndef __starting_point():\n\n    def bfs(flag):\n        vis = set()\n        vis |= {1}\n        q = Queue()\n        q.put((1, 0))\n\n        while not q.empty():\n            u, dis = q.get()\n            for v in range(1, n+1):\n                if (v not in vis) and (((u, v) in h) == flag):\n                    vis |= {v}\n                    q.put((v, dis+1))\n                    if v == n:\n                        return dis+1\n        return -1\n\n    n, m = list(map(int, input().split()))\n\n    h = set()\n    for _ in range(0, m):\n        x, y = list(map(int, input().split()))\n        h |= {(x, y)}\n        h |= {(y, x)}\n    dist1 = bfs(True)\n    dist2 = bfs(False)\n    # print(dist1, dist2)\n    if dist1 == -1 or dist2 == -1:\n        print(-1)\n    else:\n        print(max(dist1, dist2))\n\n__starting_point()", "#http://codeforces.com/contest/601/problem/A\nimport sys\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\ng = set()\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g |= {(x, y), (y, x)}\n\ncut = (0, n-1) in g\n\nq = deque()\nq.append(0)\n\nd = [-1] * n\nd[0] = 0\nwhile len(q):\n    x = q.popleft()\n    for y in range(n):\n        if cut ^ ((x, y) in g) and (d[y] == -1 or d[y] > d[x] + 1):\n            d[y] = d[x] + 1\n            q.append(y)\n\nprint(d[n-1])\n", "def main():\n    n, m = list(map(int, input().split()))\n    vrtxs = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        vrtxs[u][v] = vrtxs[v][u] = True\n    if vrtxs[0][n - 1]:\n        for u, l in enumerate(vrtxs):\n            for v, f in enumerate(l):\n                l[v] = not f\n            l[u] = False\n    avail, nxt, t = [True] * n, [n - 1], 0\n    while nxt:\n        cur, nxt = nxt, []\n        t += 1\n        for u in cur:\n            for v, f, a in zip(list(range(n)), vrtxs[u], avail):\n                if f and a:\n                    if not v:\n                        print(t)\n                        return\n                    avail[v] = False\n                    nxt.append(v)\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    vrtxs = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        vrtxs[u].append(v)\n        vrtxs[v].append(u)\n    if n - 1 in vrtxs[0]:\n        for u, l in enumerate(vrtxs):\n            tmp = [True] * n\n            for v in l:\n                tmp[v] = False\n            tmp[u] = False\n            vrtxs[u] = [v for v, f in enumerate(tmp) if f]\n    avail, nxt, t = [True] * n, [n - 1], 0\n    while nxt:\n        cur, nxt = nxt, []\n        t += 1\n        for u in cur:\n            for v in vrtxs[u]:\n                if avail[v]:\n                    if not v:\n                        print(t)\n                        return\n                    avail[v] = False\n                    nxt.append(v)\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n, m = list(map(int, input().split()))\n    vrtxs = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        vrtxs[u].append(v)\n        vrtxs[v].append(u)\n    if n - 1 in vrtxs[0]:\n        for u, l in enumerate(vrtxs):\n            tmp = set(l)\n            tmp.add(u)\n            vrtxs[u] = [v for v in range(n) if v not in tmp]\n    avail, nxt, t = [True] * n, [n - 1], 0\n    while nxt:\n        cur, nxt = nxt, []\n        t += 1\n        for u in cur:\n            for v in vrtxs[u]:\n                if avail[v]:\n                    if not v:\n                        print(t)\n                        return\n                    avail[v] = False\n                    nxt.append(v)\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\ndp = [[0 for i in range(n + 1)] for j in range(n + 1)]\nlevel = [-1 for i in range(n + 1)]\nstack = []\n\ndef bfs(src, lvl, flag):\n\tlevel[src] = lvl\n\tstack.append(src)\n\tp = 0\n\twhile True:\n\t\tfor i in range(1, n + 1):\n\t\t\tif dp[src][i] == flag:\n\t\t\t\t#print (i, i)\n\t\t\t\tif level[i] == -1:\n\t\t\t\t#\tprint (i, i)\n\t\t\t\t\tstack.append(i)\n\t\t\t\t\tlevel[i] = level[src] + 1\n\t\tif len(stack) <= p + 1:\n\t\t\tbreak\n\t\tp += 1\n\t\t#print (stack)\n\t\tsrc = stack[p]\n\t\tif src == n:\n\t\t\treturn level[src]\n\t\t\tbreak\n\treturn -1\n\nfor i in range(m):\n\ta, b = list(map(int, input().split()))\n\tdp[a][b] = 1\n\tdp[b][a] = 1\n\t\nif dp[1][n]:\n\tprint(bfs(1, 0, 0))\n\t\nelse:\n\tprint(bfs(1, 0, 1))\n", "from collections import defaultdict as dfdict\n\ndef bfs(G,rail_connected=False) :\n    level=[1]\n    visited=set([1])\n    cnt=0\n    while len(level)>0 :\n        nxtlevel=[]\n        for i in level :\n            nxt=G[i] if not rail_connected else all_vertice-G[i]\n            for j in nxt :\n                if j not in visited :\n                    if j==n :\n                        cnt+=1\n                        return cnt\n                    else :\n                        nxtlevel.append(j)\n                        visited.add(j)\n        level=nxtlevel\n        cnt+=1\n    return -1       \n\nn,m=[int(i) for i in input().split()]\nrails=dfdict(set)\nall_vertice=set([i+1 for i in range(n)])\nfor _ in range(m) :\n    xt,yt=[int(i) for i in input().split()]\n    rails[xt].add(yt)\n    rails[yt].add(xt)\n\nR=False\nif n in rails[1] :\n    R=True\nelse :\n    R=False\n\nprint(bfs(rails,R))", "n, m = list(map(int, input().split()))\na = [[] for i in range(n)]\nr = False\nfor i in range(m):\n\tx, y = list(map(int, input().split()))\n\tif (x, y) == (1, n) or (x, y) == (n, 1):\n\t\tr = True\n\ta[x-1].append(y-1)\n\ta[y-1].append(x-1)\nif r:\n\tfor i in range(n):\n\t\ts = set(a[i])\n\t\ta[i] = [j for j in range(n) if i != j and not j in s]\nq = [(0, 0)]\nv = set([0])\nl = 0\nwhile l < len(q):\n\tx, d = q[l]\n\tl += 1\n\tfor y in a[x]:\n\t\tif not y in v:\n\t\t\tif y == n-1:\n\t\t\t\tprint(d+1)\n\t\t\t\tquit()\n\t\t\tq.append((y, d+1))\n\t\t\tv.add(y)\nprint(-1)\n", "from collections import deque\nn, m = tuple(map(int,input().split()))\nli,s = deque([0]),set()\n\nfor i in range(m):\n    a,b = map(int, input().split())\n    a -= 1;b-=1\n    s.add((a,b))\n    s.add((b,a))\nreach = (0, n-1) in s\nd = [0]\nd.extend([-1 for _ in range(n-1)])\nwhile li:\n    a =li.popleft()\n    for b in range(n):\n        if (not(reach and ((a, b) in s)))\\\n                and(reach or ((a, b) in s))\\\n                and (d[b] == -1 or d[b] > d[a] + 1):\n            d[b] = d[a] + 1\n            li.append(b)\nprint(d[n-1])", "from collections import deque\n[n,m]=[int(i) for i in input().split()]\nroutes=[set() for i in range(n+1)]\nfor i in range(m):\n    [x,y]=[int(j) for j in input().split()]\n    routes[x].add(y)\n    routes[y].add(x)\nif n not in routes[1]:\n    a=True\nelse:\n    a=False\nway=deque()\nway.append(1)\nb=[-1 for i in range(n+1)]\nb[1]=0\nwhile len(way)>0:\n    c=way.popleft()\n    for i in range(1,n+1):\n        if a^(i in routes[c]):\n            continue\n        if b[i]==-1:\n            b[i]=b[c]+1\n            way.append(i)\n            if i==n:\n                print(b[i])\n                return\nprint(-1)", "n, m = list(map(int, input().split()))\na = [[] for i in range(n)]\nr = False\nfor i in range(m):\n\tx, y = list(map(int, input().split()))\n\tif (x, y) == (1, n) or (x, y) == (n, 1):\n\t\tr = True\n\ta[x-1].append(y-1)\n\ta[y-1].append(x-1)\nif r:\n\tfor i in range(n):\n\t\ts = set(a[i])\n\t\ta[i] = [j for j in range(n) if i != j and not j in s]\nq = [(0, 0)]\nv = set([0])\nl = 0\nwhile l < len(q):\n\tx, d = q[l]\n\tl += 1\n\tfor y in a[x]:\n\t\tif not y in v:\n\t\t\tif y == n-1:\n\t\t\t\tprint(d+1)\n\t\t\t\tquit()\n\t\t\tq.append((y, d+1))\n\t\t\tv.add(y)\nprint(-1)\n", "n,m=list(map(int,input().split()))\nf=[set() for i in range(n)]\ng,h=[0]+(n-1)*[10000],[0]+(n-1)*[10000]\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    f[u-1].add(v-1)\n    f[v-1].add(u-1)\np={i for i in range(1,n)}\ndef findrailway(t):\n    if t==0:\n        for c in f[t]:\n            g[c]=g[t]+1\n        for c in f[t]:\n            findrailway(c)\n    if t!=n-1:\n        pp=set()\n        for c in(f[t]-f[0]):\n            if g[c]!=min(g[c],g[t]+1):\n                g[c]=g[t]+1\n                pp.add(c)\n        for c in pp:\n            findrailway(c)\ndef findbusway(t):\n    if t==0:\n        for c in p-f[t]:\n            h[c]=h[t]+1\n        for c in p-f[t]:\n            findbusway(c)\n    if t!=n-1:\n        pp=set()\n        for c in((p-f[t])-(p-f[0])):\n            if h[c]!=min(h[c],h[t]+1):\n                h[c]=h[t]+1\n                pp.add(c)\n        for c in pp:\n            findbusway(c)\nfindrailway(0)\nfindbusway(0)\nprint(max(h[n-1],g[n-1]) if(h[n-1]!=g[n-1])and(h[n-1]<10000)and(g[n-1]<10000) else -1)\n\n", "import sys\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\ng = set()\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    g |= {(x, y), (y, x)}\n\ncut = (0, n-1) in g\n\nq = deque()\nq.append(0)\n\nd = [-1] * n\nd[0] = 0\nwhile len(q):\n    x = q.popleft()\n    for y in range(n):\n        if cut ^ ((x, y) in g) and (d[y] == -1 or d[y] > d[x] + 1):\n            d[y] = d[x] + 1\n            q.append(y)\n\nprint(d[n-1])\n", "def bfs(g,n):\n    q=[1]\n    vis=[1 for x in range(n+1)]\n    dis=[0 for x in range(n+1)]\n    while len(q):\n        cur=q[0]\n        q.remove(cur)\n        for i in g[cur]:\n            if vis[i]:\n                q.append(i)\n                vis[i]=0\n                dis[i]=dis[cur]+1\n                if i==n:\n                    return dis[n]\n    return -1\n        \n\n[n,m]=[int(x) for x in input().split()]\nrag=[[] for x in range(n+1)]\nrog=[[] for x in range(n+1)]\nfor i in range(m):\n    [a,b]=[int(x) for x in input().split()]\n    rag[a].append(b)\n    rag[b].append(a)\nfor i in range(1,n+1):\n    for j in range(i+1,n+1):\n        if j not in rag[i]:\n            rog[i].append(j)\n            rog[j].append(i)\nif n in rag[1]:\n    print(bfs(rog,n))\nelse:\n    print(bfs(rag,n))\n", "from queue import PriorityQueue\nclass Graph:\n    to=[]\n    n=0\n    def __init__(self,_n):\n        self.to=[[False]*(_n+1)for i in range(_n+1)]\n        self.n=_n\n    def add_edge(self,s,t):\n        self.to[s][t]=True\n        self.to[t][s]=True\n    def dijkstra(self):\n        flag=self.to[1][self.n]==False\n        ans=1\n        dis=[-1]*(self.n+1)\n        q=PriorityQueue()\n        q.put((0,1))\n        while q.qsize()>0:\n            d1,pos=q.get()\n            # print(pos,d1\n            if dis[pos]!=-1:\n                continue\n            dis[pos]=d1\n\n            for i in range(1,self.n+1):\n                if self.to[pos][i]!=flag:\n                    continue\n                nx=i\n                if nx==pos:\n                    continue\n                if dis[nx]==-1:\n                    q.put((d1+1,nx))\n        return dis[self.n]\n\n\ngph=Graph(0)\nN,M=[0]*2\n\ndef read_in():\n    # file = open(\"input.txt\")\n    nonlocal N,M,gph\n    N,M=[int(i)  for i in input().split()]\n\n    gph=Graph(N)\n    for i in range(M):\n        # line=file.readline()\n        s,t=[int(i)  for i in input().split()]\n\n        gph.add_edge(s,t)\n        # print(s,t,l)\n\nread_in()\n\nprint(gph.dijkstra())", "import queue\n\nconnect = [[0 for i in range(401)] for j in range(401)]\n\n\ndef bfs(val):\n    q = queue.Queue()\n    dis = [-1 for i in range(401)]\n    dis[1] = 0\n    q.put(1)\n    while(not q.empty()):\n        x = q.get()\n\n        for i in range(1, n+1):\n            if connect[x][i] == val and dis[i] == -1:\n                dis[i] = dis[x]+1\n                q.put(i)\n    return dis[n]\n\ntemp = input().split()\nn = int(temp[0])\nm = int(temp[1])\n\ndis = [[[0 for i in range(401)] for j in range(401)] for k in range(2)]\n\nfor i in range(m):\n    temp = input().split()\n    u = int(temp[0])\n    v = int(temp[1])\n    connect[u][v] = connect[v][u] = 1\n\nprint(bfs(1-connect[1][n]))\n", "def bfs_shortest_path(graph, start, goal):\n    explored = []\n    queue = [[start]]\n    while queue:\n        path = queue.pop(0)\n        node = path[-1]\n        if node not in explored:\n            neighbours = graph[node]\n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n                if neighbour == goal:\n                    return len(new_path)-1\n            explored.append(node)\n    return -1\n\n\ntown_rail = input().split(\" \")\ntown = int(town_rail[0])\nrail = int(town_rail[1])\nrailways = []\ngraph = {}\nfor j in range(1,town+1):\n    graph[j] = []\n\nfor i in range(rail):\n    railways.append(input().split(\" \"))\n\nif [\"1\", str(town)] in railways or [str(town),\"1\"] in railways:\n    for key in graph:\n        for k in range(1,town+1):\n            if k != key:\n                graph[key].append(k)\n    for pair in railways:\n        graph[int(pair[0])].remove(int(pair[1]))\n        graph[int(pair[1])].remove(int(pair[0]))\nelse:\n    for pair in railways:\n        graph[int(pair[0])].append(int(pair[1]))\n        graph[int(pair[1])].append(int(pair[0]))\nprint(bfs_shortest_path(graph, 1, town))", "f = lambda: list(map(int, input().split()))\nn, m = f()\nk = n + 1\ns = [[0] * k for i in range(k)]\nfor j in range(m):\n    u, v = f()\n    s[u][v] = s[v][u] = 1\nd = [-1] * k\nd[1] = 0\nq = [1]\nwhile q:\n    u = q.pop(0)\n    for v in range(1, k):\n        if s[u][v] != s[1][n] and d[v] == -1:\n            d[v] = d[u] + 1\n            q.append(v)\nprint(d[n])\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Nov 28 20:27:33 2017\n\n@author: alter027\n\"\"\"\nimport sys\n\nd=[[0 for col in range(500)] for row in range(500)]\nv=[0]*500\nn, m=list(map(int, input().split()))\nfor i in range(m):\n    x, y=list(map(int, input().split()))\n    x -= 1\n    y -= 1\n    d[x][y] = d[y][x]=1\nq = [0]\nl = 0\n\nwhile l < len(q):\n    for i in range(1,n):\n        if d[0][n-1] != d[q[l]][i] and v[i] == 0 :\n            v[i] = v[q[l]] + 1\n            q.append(i)\n    l += 1\n\nif v[n-1] == 0:\n    print(-1)\nelse:\n    print(v[n-1])\n", "from math import inf\nfrom collections import Counter as cntr\nn, m = map(int, input().split(' '))\nroad = [[1 for i in range(n)]for i in range(n)]\nrailway = [[0 for i in range(n)]for i in range(n)]\nfor i in range(m):\n\tu, v = map(int, input().split(' '))\n\tu -= 1\n\tv -= 1\n\troad[u][v] = 0\n\troad[v][u] = 0\n\trailway[u][v] = 1\n\trailway[v][u] = 1\n\ndef bfs(graph, source, n):\n\tvisited = [False for i in range(n)]\n\td = [inf for i in range(n)]\n\tq = [source]\n\tvisited[source] = True\n\td[source] = 0\n\twhile(q):\n\t\tidx = q.pop(0)\n\n\t\tfor i in range(n):\n\t\t\tif graph[idx][i] == 1 and visited[i] == False:\n\t\t\t\tvisited[i] = True\n\t\t\t\td[i] = d[idx] + 1\n\t\t\t\tq.append(i)\n\treturn d\nl1 = bfs(road, 0, n)\nl2 = bfs(railway, 0, n)\nans = max(l1[-1],l2[-1])\nprint(-1) if ans == inf else print(ans)\n", "f = lambda: list(map(int, input().split()))\nn, m = f()\nk = n + 1\ns = [[0] * k for i in range(k)]\nfor j in range(m):\n    u, v = f()\n    s[u][v] = s[v][u] = 1\nd = [-1] * k\nd[1] = 0\nq = [1]\nwhile q:\n    u = q.pop(0)\n    for v in range(1, k):\n        if s[u][v] != s[1][n] and d[v] == -1:\n            d[v] = d[u] + 1\n            q.append(v)\nprint(d[n])\n\n", "f = lambda: list(map(int, input().split()))\nn, m = f()\nk = n + 1\ns = [[0] * k for i in range(k)]\nfor j in range(m):\n    u, v = f()\n    s[u][v] = s[v][u] = 1\nd = [-1] * k\nd[1] = 0\nq = [1]\nwhile q:\n    u = q.pop(0)\n    for v in range(1, k):\n        if s[u][v] != s[1][n] and d[v] == -1:\n            d[v] = d[u] + 1\n            q.append(v)\nprint(d[n])\n\n"]
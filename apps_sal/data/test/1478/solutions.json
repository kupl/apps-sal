["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nstuff=input().split(\",\")\nn=len(stuff)\n\ncomm=[[] for _ in range(1000001)]\nst=[1000001]\n\nfor i in range(0,n,2):\n    while st[-1]==0: st.pop(-1)\n    comm[len(st)].append(stuff[i])\n    st[-1]-=1\n    st.append(int(stuff[i+1]))\n\nmaxd=0\nfor i in range(1000000,0,-1):\n    if len(comm[i]):\n        maxd=i\n        break\n\nprint(maxd)\nfor i in range(1,maxd+1):\n    print(\" \".join(comm[i]))", "import sys\n\n\ns = sys.stdin.readline().strip().split(\",\")\nn = len(s) // 2\nlevels = [[]]\nstack = []\nfor i in range(n):\n    st = s[i * 2]\n    if (len(stack) + 1 > len(levels)):\n        levels.append([])\n    levels[len(stack)].append(st)\n    if (len(stack)):\n        stack[-1] -= 1\n    nm = int(s[i * 2 + 1])\n    stack.append(nm)\n    while (len(stack) and stack[-1] == 0):\n        stack.pop()\nsys.stdout.write(\"{}\\n\".format(len(levels)) + '\\n'.join([' '.join(x) for x in levels]) + '\\n')\nsys.stdout.flush()\n\n\n\n\n", "#!/usr/bin/env python3\n\nimport collections\n\n\ndef solve():\n    comments = input().split(\",\")\n    comments_by_depth = collections.defaultdict(list)\n\n    current_depth = 0\n    current_depth_limit = [10000000]\n\n    cur_cmt = [0] * 2\n\n    for i, item in enumerate(comments):\n        cur_cmt[i % 2] = item\n        if i % 2 == 1:\n            while current_depth_limit[-1] == 0:\n                current_depth_limit.pop()\n                current_depth -= 1\n            text = cur_cmt[0]\n            child_count = int(cur_cmt[1])\n            comments_by_depth[current_depth].append(text)\n            current_depth_limit[-1] -= 1\n            if child_count > 0:\n                current_depth += 1\n                current_depth_limit.append(child_count)\n\n    depths = list(sorted(comments_by_depth.keys()))\n    if depths:\n        print(depths[-1] + 1)\n    else:\n        print(0)\n    for d in depths:\n        print(\" \".join(comments_by_depth[d]))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "line = input()\nline = line.split(',')\nA = 'abcdefghijklmnopqrstuvwxyz'\ndepth = 1\ncomments = [[]]\ncur_cnt, cur_depth = [0], 1\n\nfor token in line:\n    if token[0] in A or token[0] in A.upper():\n        comments[cur_depth - 1].append(token)\n        cur_cnt[cur_depth - 1] -= 1\n    else:\n        cnt = int(token)\n        if cnt > 0:\n            cur_depth += 1\n            if cur_depth > len(cur_cnt):\n                cur_cnt.append(0)\n            cur_cnt[cur_depth - 1] = cnt\n            if cur_depth > depth:\n                comments.append([])\n                depth = max(cur_depth, depth)\n        else:\n            while cur_depth > 1 and cur_cnt[cur_depth - 1] == 0:\n                cur_depth -= 1\n\nprint(len(comments))\nfor line in comments:\n    print(' '.join(line))", "a=input().split(\",\")\nn=len(a)\ncomm=[[] for _ in range(1000001)]\nst=[1000001]\nfor i in range(0,n,2):\n    while st[-1]==0: st.pop(-1)\n    comm[len(st)].append(a[i])\n    st[-1]-=1\n    st.append(int(a[i+1]))\nmaxd=0\nfor i in range(1000000,0,-1):\n    if len(comm[i]):\n        maxd=i\n        break\nprint(maxd)\nfor i in range(1,maxd+1):\n    print(\" \".join(comm[i]))\n", "a = input().split(',')\no = 0\nfor i in range(1, len(a), 2):\n    a[i] = int(a[i])\nb = [[] for i in range(300000)]\nc = []\nfor i in range(0, len(a), 2):\n    b[len(c)] += [a[i]]\n    if a[i + 1] == 0:\n        if len(c) != 0:\n            c[len(c) - 1] -= 1\n    else:\n        if len(c) != 0:\n            c[len(c) - 1] -= 1\n        c += [a[i + 1]]\n    while len(c) > 0 and c[len(c) - 1] == 0:\n        c.pop()\n    o = max(o, len(c))\n    #print(*c)\nprint(o + 1)\nfor i in range(300000):\n    if b[i] == []:\n        break\n    else:\n        print(*b[i])\n", "t = input().split(',')\nw = t[::2]\nc = list(map(lambda x : int(x), t[1::2]))\n\nmax_d = 0\ncur_d = 0\ncnt = [10**6]\n\nans = [[] for i in range(10**6)]\n\n\ni = 0\nwhile i < len(w):\n\tans[cur_d].append(w[i])\n\tcnt[cur_d] -= 1\n\tif c[i] > 0:\n\t\tcnt.append(c[i])\n\t\tcur_d += 1\n\t\tmax_d = max(max_d, cur_d)\n\telse:\n\t\twhile cnt[cur_d] == 0:\n\t\t\tcnt.pop()\n\t\t\tcur_d -= 1\n\ti += 1\n\n\nprint(max_d + 1)\nfor i in range(max_d + 1):\n\tprint(' '.join(ans[i]))", "#!/usr/bin/env python3\nfrom collections import defaultdict\ndef ri():\n    return list(map(int, input().split()))\n\ntemp = input().split(',')\nnode = temp[0::2]\ncount = temp[1::2]\ncount = list(map(int, count))\nlevel = defaultdict(list)\n\nstack = []\nl = 0\nfor j in range(len(node)):\n    level[l].append(j)\n    if count[j]:\n        count[j] -= 1\n        stack.append(j)\n        l += 1\n    else:\n        while len(stack):\n            if count[stack[-1]] == 0:\n                stack.pop()\n                l -= 1\n            else:\n                count[stack[-1]] -= 1\n                break\n\nprint(len(level))\nfor l in level:\n    print(' '.join([node[i] for i in level[l]]))\n", "from queue import Queue\n\ndef parse(s):\n    A = s.split(',')\n    n = len(A)//2\n    B = [(A[2*i], int(A[2*i+1])) for i in range(n)]\n\n    stack = []\n    E = {i:[] for i in range(n+1)}\n    comment = {}\n    depth = {i:0 for i in range(n+1)}\n    for i, b in enumerate(reversed(B)):\n        comment[i+1] = b[0]\n        for j in range(b[1]):\n            k = stack.pop()\n            E[i+1].append(k)\n            depth[i+1] = max(depth[i+1], depth[k])\n\n        depth[i+1] += 1\n        stack.append(i+1)\n\n    E[0].extend(reversed(stack))\n    depth[0] = max(depth[i] for i in stack) + 1\n    comment[0] = None\n\n    Q = Queue()\n    Q.put(0)\n    res = [[] for i in range(depth[0])]\n    while not Q.empty():\n        v = Q.get()\n        d = depth[v] - 1\n        res[d].append(comment[v])\n        for u in E[v]:\n            depth[u] = d\n            Q.put(u)\n\n    res.pop()\n    return res\n\ns = input().rstrip()\nres = parse(s)    \nprint(len(res))\nfor layer in reversed(res):\n    print(' '.join(layer))\n", "import sys\nfrom typing import List\n\nslist = input().split(',')  # type: List[str]\nstack = [1<<30] # type: List[int]\nres = [[]]\n\nfor s in slist:\n    if s.isnumeric():\n        stack.append(int(s))\n        if len(stack) > len(res):\n            res.append([])\n    else:\n        while stack[-1] == 0:\n            stack.pop()\n        stack[-1] -= 1\n        res[len(stack)-1].append(s)\n\nwhile res[-1] == []:\n    res.pop()\n\nprint(len(res))\nfor l in res:\n    if l:\n        print(*l)\n", "def __starting_point():\n\tcomments = input().split(',')\n\tn = len(comments) // 2\n\tstack = [0]\n\tlvl = 1\n\tres = []\n\tfor i in range(n):\n\t\tcomm, child = comments[2*i], int(comments[2*i+1])\n\t\twhile lvl > 1 and stack[lvl-1] == 0:\n\t\t\tlvl -= 1\n\t\tstack[lvl-1] -= 1\n\t\tif len(res) == lvl-1:\n\t\t\tres.append([comm])\n\t\telse:\n\t\t\tres[lvl-1].append(comm)\n\t\tif child > 0:\n\t\t\tif lvl == len(stack):\n\t\t\t\tstack.append(child)\n\t\t\telse:\n\t\t\t\tstack[lvl] = child\n\t\t\tlvl += 1\n\tprint(len(res))\n\tfor l in res:\n\t\tprint(' '.join(l))\n__starting_point()", "t = input().split(',')\nm = len(t)\np, d, k = [m] * m, [[] for i in range(m)], 0\nfor i in range(0, m, 2):\n    s, n = t[i], int(t[i + 1])\n    while p[k] == 0: k -= 1\n    p[k] -= 1\n    d[k].append(s)\n    k += 1\n    p[k] = n\nwhile d[k]: k += 1\nprint(k)\nfor q in d[:k]: print(*q)", "t = input().split(',')\nk, m = 0, len(t)\np, d = [m] * m, [[] for i in range(m)]\nfor s, n in zip(t[::2], t[1::2]):\n    while not p[k]: k -= 1\n    p[k] -= 1\n    d[k].append(s)\n    k += 1\n    p[k] = int(n)\nwhile d[k]: k += 1\nprint(k)\nfor q in d[:k]: print(*q)", "t = input().split(',')\nk, m = 0, len(t)\np, d = [m] * m, [[] for i in range(m)]\nfor j in range(0, m, 2):\n    while p[k] < 1: k -= 1\n    p[k] -= 1\n    d[k].append(t[j])\n    k += 1\n    p[k] = int(t[j + 1])\nwhile d[k]: k += 1\nprint(k)\nfor q in d[:k]: print(*q)", "v = input().strip().split(',')\nv = [(v[i*2], int(v[i*2+1])) for i in range(len(v)//2)]\nn = len(v)\n\nf = {}\ns = [1000000]\nfor i in range(n):\n    x, m = v[i]\n    d = len(s)\n    if d not in f:\n        f[d] = []\n    f[d].append(x)\n    s.append(m)\n    while s[-1] <= 0:\n        s.pop()\n        s[-1] -= 1\n\nr = sorted([(k, v) for k, v in list(f.items())])\nprint(len(r))\nfor i in range(len(r)):\n    print(' '.join(r[i][1]))\n", "tokens = input().split(',')\n\ndepths = []\nstk = [len(tokens)]\n\nfor i in range(len(tokens)//2):\n    tok = tokens[2*i]\n    children = int(tokens[2*i+1])\n\n    y = stk.pop()\n    y -= 1\n    stk.append(y)\n\n    while len(depths) <= len(stk):\n        depths.append([])\n    depths[len(stk)].append(tok)\n    stk.append(children)\n\n    while stk and stk[-1] == 0:\n        stk.pop()\n\nprint(len(depths)-1)\nfor xs in depths[1:]:\n    print(' '.join(xs))\n\n", "levels = []\nleft = [-1]\n\ninp = input().split(\",\")\ni = 0\nwhile i < len(inp):\n\tif len(levels) <= len(left) - 1:\n\t\tlevels.append([])\n\tt = inp[i]\n\tn = int(inp[i + 1])\n\tlevels[len(left) - 1].append(t)\n\tif n > 0:\n\t\tleft.append(n)\n\twhile left[-1] == 0:\n\t\tdel left[-1]\n\t\n\tleft[-1] -= 1\n\ti += 2\n\nprint(len(levels))\nfor i in levels:\n\tprint(\" \".join(i))", "info = input().split(',')\ninfo = [(word, int(num)) for word, num in zip(info[::2], info[1::2])]\nout = []\nstack = []\nfor index, item in enumerate(info):\n    level = len(stack)\n    while level > 0 and stack[-1] == 0:\n        stack.pop()\n        level -= 1\n\n    if len(out) <= level:\n        out.append([item[0]])\n    else:\n        out[level].append(item[0])\n\n    if item[1] > 0:\n        stack.append(item[1])\n\n    if level > 0:\n        stack[level - 1] -= 1\n\nprint(len(out))\nprint('\\n'.join(' '.join(line) for line in out))\n", "import sys\nfrom typing import List\n\nslist = input().split(',')  # type: List[str]\nstack = [1<<30] # type: List[int]\nres = [[]]\n\nfor s in slist:\n    if s.isnumeric():\n        stack.append(int(s))\n        if len(stack) > len(res):\n            res.append([])\n    else:\n        while stack[-1] == 0:\n            stack.pop()\n        stack[-1] -= 1\n        res[len(stack)-1].append(s)\n\nwhile res[-1] == []:\n    res.pop()\n\nprint(len(res))\nfor l in res:\n    if l:\n        print(*l)", "ls = [[] for _ in range(10**6//4)]\nmaxd = 0\ns=input().split(\",\")\ni = 0\nstack = [1000000]\nfor i in range(0, len(s), 2):\n\tw,c = s[i],int(s[i+1])\n\tls[len(stack)-1].append(w)\n\tstack[-1]-=1\n\tstack.append(c)\n\twhile stack[-1]==0: stack.pop()\n\tmaxd=max(maxd,len(stack))\nprint(maxd)\nfor i in range(maxd):\n\tprint(*ls[i])\n", "comments = input().split(',')\nn = len(comments)\np = [n] * n # place holder for count at each layer\nans = [[] for i in range(n)]\nlayer = 0\n\nfor i in range(0,n, 2):\n    com = comments[i]\n    sub_count = int(comments[i+1])\n    while p[layer] == 0: # move back to the previous layer\n        layer -= 1\n    p[layer] -= 1 # remove the count\n    ans[layer].append(com)\n    layer += 1 # move to the next layer\n    p[layer] = sub_count\nwhile ans[layer]:\n    layer += 1\nprint(layer)\nfor sub_ans in ans[:layer]:\n    print(*sub_ans)\n"]
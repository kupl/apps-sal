["from sys import stdin, setrecursionlimit\nfrom collections import deque\n\nsetrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\nMOD = 1000000007\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\npow2 = [1] * (N + 1)\nfor i in range(N):\n    pow2[i + 1] = pow2[i] * 2 % MOD\n\norder = []\nparent = [-1] * N\n\nstack = deque([0])\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for nv in G[v]:\n        if parent[v] != nv:\n            parent[nv] = v\n            stack.append(nv)\n\nnumer = 0\nnums = [0] * N\n\nfor v in reversed(order):\n    tmp = 1\n    for nv in G[v]:\n        if parent[v] != nv:\n            nums[v] += nums[nv] + 1\n            tmp += pow2[nums[nv] + 1] - 1\n    tmp += pow2[N - nums[v] - 1] - 1\n    numer = (numer + pow2[N - 1] - tmp) % MOD\n\ndenom = pow2[N]\nans = numer * pow(denom, MOD - 2, MOD) % MOD\nprint(ans)\n", "from sys import stdin\nf_i = stdin\n\nN = int(f_i.readline())\n\nadj = [[] for i in range(N)]\nfor i in range(N - 1):\n    A, B = map(int, f_i.readline().split())\n    A -= 1\n    B -= 1\n    adj[A].append(B)\n    adj[B].append(A)\n\nmod = 10 ** 9 + 7\n\npow2 = [1] * (N + 1)\nfor i, j in zip(range(N), range(1, N + 1)):\n    pow2[j] = pow2[i] * 2 % mod\n\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nans = 0\n\ndef dfs(node, parent):\n    nonlocal ans\n    cnt = 1\n    \n    for child in adj[node]:\n        if child != parent:\n            cnt += dfs(child, node)\n    \n    ans += (pow2[cnt] - 1) * (pow2[N-cnt] - 1)\n    ans %= mod\n    \n    return cnt\n\ndfs(0, None)\n\nans = (ans - N * pow2[N-1] + pow2[N] - 1) % mod\nans = ans * pow(pow2[N], mod - 2, mod) % mod\n\nprint(ans)", "from sys import stdin, setrecursionlimit\nfrom collections import deque\n\nsetrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef input():\n    return stdin.readline().strip()\n\n\nMOD = 1000000007\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\npow2 = [1] * (N + 1)\nfor i in range(N):\n    pow2[i + 1] = pow2[i] * 2 % MOD\n\norder = []\nparent = [-1] * N\n\nstack = deque([0])\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for nv in G[v]:\n        if parent[v] != nv:\n            parent[nv] = v\n            stack.append(nv)\n\nnumer = 0\nnums = [0] * N\n\nfor v in reversed(order):\n    tmp = 1\n    for nv in G[v]:\n        if parent[v] != nv:\n            nums[v] += nums[nv] + 1\n            tmp += pow2[nums[nv] + 1] - 1\n    tmp += pow2[N - nums[v] - 1] - 1\n    numer = (numer + pow2[N - 1] - tmp) % MOD\n\ndenom = pow2[N]\nans = numer * pow(denom, MOD - 2, MOD) % MOD\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\nmod = 10**9+7\np2 = [1]*(3*10**5)\nfor n in range(3*10**5-1):\n    p2[n+1] = p2[n]*2%mod\n\nN = int(input())\nAB = [list(map(int,input().split())) for _ in range(N-1)]\ng = [[] for _ in range(N+1)]\nfor i in range(N-1):\n    a,b = AB[i]\n    g[a].append(b)\n    g[b].append(a)\n\nl1 = [0]*(N+1)\nl2 = [[] for _ in range(N+1)]\n\ndef rec(p,c):\n    res = 0\n    for a in g[c]:\n        if a == p:\n            continue\n        n = rec(c,a)\n        l2[c].append(n+1)\n        res += n+1\n    l1[c] = res\n    return res\n\nn = rec(0,1)\nfor i in range(1,N+1):\n    l2[i].append(N-1-l1[i])\n\nans = 0\nfor i in range(1,N+1):\n    ans += p2[N-1]-1\n    ans %= mod\n    for j in l2[i]:\n        ans -= p2[j]-1\n        ans %= mod\nans *= pow(p2[N],mod-2,mod)\nans %= mod\nprint(ans)\n", "# coding: utf-8\n# Your code here!\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n \nn = int(input())\n#n = [int(i) for i in readline().split()]\n \ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    a,b = [int(i) for i in readline().split()]\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n \n\n#from collections import deque\n\ncnt = [-1]*n\nparent = [-1]*n\n\nq = [0]\norder = []\nwhile q:\n    v = q.pop()\n    order.append(v)\n    for c in g[v]:\n        if parent[v] != c:\n            parent[c] = v\n            q.append(c)\n\nMOD = 10**9+7\n\npow2 = [1]\nfor i in range(n):\n    pow2.append(pow2[-1]*2%MOD)\n\n\nnum = [0]*n\nans = 0\nfor v in reversed(order):\n    res = 1\n    nokori = n-1\n    for c in g[v]:\n        if c != parent[v]:\n            nc = num[c]+1\n            res += pow2[nc] - 1\n            num[v] += nc\n            nokori -= nc\n            #print(c,v,nc)\n    res += pow2[nokori] - 1\n    #print(res,nokori)\n    ans += pow2[n-1]-res \n\n#print(parent)\n#print(num)\n#print(pow2)\n\nR = (MOD+1)//2\n\nprint((ans*pow(R,n,MOD)%MOD))\n\n\n            \n            \n        \n    \n    \n\n\n\n\n", "import sys\ninput=lambda: sys.stdin.readline().rstrip()\nmod=10**9+7\nn=int(input())\nedge=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=list(map(int,input().split()))\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\ninf=10**6\nPar=[inf]*n\nPar[0]=-1\nDeg=[0]*n\nDeg[0]=0\nChk=[0]\nwhile Chk:\n  c=Chk.pop()\n  for next in edge[c]:\n    if Par[next]==inf:\n      Par[next]=c\n      Deg[next]+=1\n      Chk.append(next)\n\nfrom collections import deque\nTS=list(v for v in range(n) if Deg[v]==0)\nD=deque(TS)\nwhile D:\n  v=D.popleft()\n  for t in edge[v]:\n    if t!=Par[v]:\n      Deg[t]-=1\n      if Deg[t]==0:\n        D.append(t)\n        TS.append(t)\n\nUsed=[False]*n\nC=[0]*n\nfor i in reversed(list(range(n))):\n  v=TS[i]\n  Used[v]=True\n  for g in edge[v]:\n    if not Used[g]:\n      C[g]+=C[v]+1\n\nH=[0]*n\nH[0]=1\nH[1]=pow(2,mod-2,mod)\nfor i in range(2,n):\n  H[i]=(H[i-1]*H[1])%mod\n\nans=0\nfor i in range(n):\n  if len(edge[i])==1:\n    continue\n  else:\n    A=[]\n    for e in edge[i]:\n      if e==Par[i]:\n        A.append(n-1-C[i])\n      else:\n        A.append(C[e]+1)\n    cur=1+(len(edge[i])-1)*H[-1]\n    for a in A:\n      cur-=H[n-1-a]\n    ans=(ans+cur)%mod\nprint(((ans*H[1])%mod))\n", "n=int(input())\nmod=10**9+7\nedge=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    edge[a].append(b)\n    edge[b].append(a)\n\ninv2=[1]*(n+1)\nt=pow(pow(2,n,mod),mod-2,mod)\nfor i in range(n,-1,-1):\n    inv2[i]=t\n    t*=2\n    t%=mod\n    \nimport sys\nsys.setrecursionlimit(10**6)\ndep=[-1 for i in range(n+1)]\nans=[0]\ndef f(a):\n    return inv2[n-a]*(1-inv2[a])%mod\ndef dfs(s,d):\n    dep[s]=d\n    tmp=inv2[1]-inv2[n]\n    y=0\n    for i in edge[s]:\n        if dep[i]==-1:\n            x=dfs(i,d+1)\n            tmp-=f(x)\n            y+=x\n    if y==0:\n        return 1\n    tmp-=f(n-y-1)\n    ans[0]+=tmp\n    ans[0]%=mod\n    return y+1\ndfs(1,0)\nprint(ans[0])", "#f\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n \n\nn = int(input())\nE = [[] for _ in range(n)]\nmod = 10**9 + 7\n\nfor i in range(n-1):\n    a,b = [int(x) for x in input().split()]\n    E[a-1].append((b-1, i)) \n    E[b-1].append((a-1, i)) \n    \nX = [0] * n\n    \ndef dfs(u,e):\n    num = 1\n    for v,c in E[u]:\n        if c != e:\n            num += dfs(v,c)\n    X[e] = num \n    return num\n\ndfs(0, -1)\n\nI = [1]\ninv = pow(2, mod-2, mod)\nfor i in range(n):\n    I.append(I[-1] * inv % mod)\n\nans = 0\nfor i in range(n):\n    x = X[i]\n    ans += (1-I[x])*(1-I[n-x]) % mod\n    \nans -= n * I[1]\nans += 1 - I[n]\nans %= mod\nprint(ans)\n\n", "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nmod = 10**9+7\n\nn = int(input())\ng = [[] for _ in range(n)]\n\npow2 = [0 for _ in range(n+1)]\npow2[0] = 1\nfor i in range(n):\n    pow2[i+1] = pow2[i]*2 %mod\n\nfor _ in range(n-1):\n    a,b = list(map(int, input().split()))\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\ndepth = [-1]*n\nko_all = [0 for _ in range(n)]\nko_only =[0 for _ in range(n)]\n\ndef dfs(v,d):\n    depth[v] = d\n    for w in g[v]:\n        if depth[w] == -1:\n            dfs(w,d+1)\n            ko_all[v] += ko_all[w]+1\n            ko_only[v] += pow2[ko_all[w]+1]-1\n\ndfs(0,0)\n\ncnt = 0\n\nfor i in range(n):\n    tmp = pow2[n-1]-1-(pow2[n-1-ko_all[i]]-1) - ko_only[i]\n    tmp %=mod\n    cnt += tmp\n    cnt %= mod\n\ndef inv(a,mod):\n    r = [1,0,a]\n    w = [0,1,mod]\n    while w[2]!=1:\n        q = r[2]//w[2]\n        r_new = [r[0]-q*w[0],r[1]-q*w[1],r[2]-q*w[2]]\n        r = w\n        w = r_new\n    x,y = w[0],w[1]    # a*x+y*mod = 1\n    return (mod+x%mod)%mod\n\nprint((inv(pow2[n],mod)*cnt %mod))\n", "import sys\nsys.setrecursionlimit(200200)\ninput = sys.stdin.readline\nMOD=10**9+7\nN = int(input())\nAB = [tuple(map(int, input().split())) for _ in range(N-1)]\nG = [[] for _ in range(N)]\nfor i, (a, b) in enumerate(AB):\n    a -= 1\n    b -= 1\n    G[a].append((b, i))\n    G[b].append((a, i))\n\nP = [0] * N\nvisited = [False] * N\nvisited[0] = True\ndef dfs(x, i):\n    e = 1\n    for v, c in G[x]:\n        if not visited[v]:\n            visited[v] = True\n            e += dfs(v, c)\n    P[i] = e\n    return e\n\ndfs(0, -1)\nW = [1] * (N + 1)\ninv_2 = pow(2, MOD-2, MOD)\nfor i in range(N):\n    W[i+1] = W[i]*inv_2%MOD\nans = (W[N] + 1) * (N - 1) % MOD\nfor i in range(N-1):\n    ans -= W[P[i]] + W[N-P[i]]\n    ans %= MOD\nprint((ans - inv_2*N - W[N] + 1) % MOD)", "from collections import defaultdict\nimport sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef ext_euc(a, b):\n    if b == 0:\n        return 1, 0, a\n    y, x, v = ext_euc(b, a % b)\n    y -= (a // b) * x\n    return x, y, v\n\n\ndef mod_inv(a, mod):\n    x, _, _ = ext_euc(a, mod)\n    return x % mod\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N = int(input())\n    adj = defaultdict(list)\n    for _ in range(N - 1):\n        A, B = list(map(lambda x: int(x) - 1, input().split()))\n        adj[A].append(B)\n        adj[B].append(A)\n\n    # 2 ** n \u306e\u4e8b\u524d\u8a08\u7b97\n    pow_2 = [1 for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        pow_2[i] = pow_2[i - 1] * 2 % MOD\n\n    # \u5206\u5b50\uff1asum_{i} (node i \u304c\u7a74\u3042\u304d\u5ea6\u306e\u5024\u3068\u3057\u3066\u30ab\u30a6\u30f3\u30c8\u5bfe\u8c61\u306b\u306a\u308b\u3088\u3046\u306a\u5857\u308a\u65b9)\n    # node_num[(node, dir_node)]: node\u304b\u3089\u898b\u3066dir_node\u65b9\u5411\u306b\u5b58\u5728\u3059\u308b\u30ce\u30fc\u30c9\u306e\u6570\n    #         5               6\n    #        (6)             (6)\n    #         |               |\n    #        (1)             (1)\n    # 0(6)-(1)1(4)-(3)2(3)-(4)3(1)-(6)4\n    node_num = defaultdict(int)\n\n    def dfs(node=0, parent=None):\n        child_list = [n for n in adj[node] if n != parent]\n        if len(child_list) == 0:\n            node_num[(node, parent)] = N - 1\n            node_num[(parent, node)] = 1\n            return 1\n        n_descendant = 1  # self\n        for child in child_list:\n            n_descendant += dfs(child, node)\n        if parent is not None:\n            node_num[(node, parent)] = N - n_descendant\n            node_num[(parent, node)] = n_descendant\n        return n_descendant\n\n    dfs()\n\n    numer = 0\n    for node in range(N):\n        if len(adj[node]) <= 1:\n            # \u7aef\uff08\u6b21\u65701\uff09\u306e\u30ce\u30fc\u30c9\u306f\u30ab\u30a6\u30f3\u30c8\u5bfe\u8c61\u306b\u306a\u3089\u306a\u3044\n            continue\n        cnt_not = 0  # node \u304c\u7a74\u3042\u304d\u5ea6\u306e\u5024\u3068\u3057\u3066\u30ab\u30a6\u30f3\u30c8\u3055\u308c\u306a\u3044\u30b1\u30fc\u30b9\n        for dir_node in adj[node]:\n            # dir_node\u65b9\u5411\u306e\u30ce\u30fc\u30c9\u306f\u81ea\u7531\u3001\u305d\u308c\u4ee5\u5916\u306e\u65b9\u5411\u306e\u30ce\u30fc\u30c9\u306f\u5168\u90e8\u767d\n            cnt_not += pow_2[node_num[(node, dir_node)]]\n        cnt_not -= len(adj[node]) - 1  # \u300c\u5168\u90e8\u767d\u5857\u308a\u300d\u306e\u91cd\u8907\u30ab\u30a6\u30f3\u30c8\u3092\u9664\u53bb\n        numer += pow_2[N - 1] - cnt_not  # node\u81ea\u8eab\u306f\u767d\u3067\u306a\u3044\u3068\u30ab\u30a6\u30f3\u30c8\u3055\u308c\u306a\u3044\u306e\u3067\u3001\u5168\u4f53\u306e\u30d1\u30bf\u30fc\u30f3\u6570\u304c2 ** (N-1)\n\n    # \u5206\u6bcd\uff1a2 ** N \uff08\u5168\u90e8\u306e\u5857\u308a\u65b9\uff09\n    denom = pow_2[N]\n\n    # \u7b54\u3048\n    print(numer * mod_inv(denom, MOD) % MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\n\nn = ni()\nG = [list() for _ in range(n)]\nfor _ in range(n-1):\n  a, b = nm()\n  a -= 1; b -= 1\n  G[a].append(b)\n  G[b].append(a)\n  \n  \nmod = 10**9 + 7\ndub = [1]*(n+1)\nfor i in range(n):\n  dub[i+1] = dub[i] * 2\n  if dub[i+1] > mod:\n    dub[i+1] -= mod\n    \nsize = [-1]*n\nq = [0]\nwhile q:\n  v = q[-1]\n  if size[v] < 0:\n    for x in G[v]:\n      if size[x] < 0:\n        q.append(x)\n    size[v] = 0\n  else:\n    size[v] = 1\n    for x in G[v]:\n      size[v] += size[x]\n    q.pop()\n\nans = 0\nfor v in range(n):\n  c = 0\n  res = 1\n  for x in G[v]:\n    if size[x] < size[v]:\n      c += size[x]\n      res += dub[size[x]] - 1\n  res += dub[n-1-c] - 1\n  res %= mod\n  ans = (ans + dub[n-1] - res) % mod\nprint(ans * pow(dub[n], mod-2, mod) % mod)", "import sys\nsys.setrecursionlimit(200200)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, i):\n    res = 1\n    for v, c in E[u]:\n        if i != c:\n            res += dfs(v, c)\n    X[i] = res\n    return res\n\ndfs(0, -1)\n\nI = [1] * (N + 1)\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I[i + 1] = I[i] * inv % mod\n\nans = (I[N] + 1) * (N - 1) - inv * N - I[N] + 1\nfor e in range(N - 1):\n    ans -= I[X[e]] + I[N - X[e]]\n    ans %= mod\n\nprint(ans)", "#f\n#change the limit of how much depth of recursive func is available. \nimport sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n \n\nn = int(input())\nE = [[] for _ in range(n)]\nmod = 10**9 + 7\n\nfor i in range(n-1):\n    a,b = [int(x) for x in input().split()]\n    E[a-1].append((b-1, i)) \n    E[b-1].append((a-1, i)) \n    \nX = [0] * n\n    \ndef dfs(u,e):\n    num = 1\n    for v,c in E[u]:\n        if c != e:\n            num += dfs(v,c)\n    X[e] = num \n    return num\n\ndfs(0, -1)\n\nI = [1]\ninv = pow(2, mod-2, mod)\nfor i in range(n):\n    I.append(I[-1] * inv % mod)\n\nans = 0\nfor i in range(n):\n    x = X[i]\n    ans += (1-I[x])*(1-I[n-x]) % mod\n    \nans -= n * I[1]\nans += 1 - I[n]\nans %= mod\nprint(ans)\n\n", "import sys\nsys.setrecursionlimit(10 ** 7)\nmod = 10 ** 9 + 7\nn = int(input())\nedges = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges[a - 1].append((b - 1, i))\n    edges[b - 1].append((a - 1, i))\nl = [0 for i in range(n)]\ndef dfs(cur, x):\n    res = 1\n    for i in edges[cur]:\n        if i[1] != x:\n            res += dfs(i[0], i[1])\n    l[x] = res\n    return res\ndfs(0, -1)\nl2 = [1]\ni2 = pow(2, mod - 2, mod)\nfor i in range(n):\n    l2.append(l2[-1] * i2 % mod)\ncnt = 0\nfor i in l:\n    cnt += (1 - l2[i]) * (1 - l2[n - i])\nprint((-n * i2 - l2[-1] + cnt + 1) % mod)", "# class\u3092\u4f7f\u3046\u306e\u3092\u3084\u3081\u3066list\u3067\u5b9f\u65bd\u3059\u308b\nimport sys\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\n\ndef dfs(v):\n    visited[v] = True\n    for i in range(len(AL[v][CHILDREN])):\n        u = AL[v][CHILDREN][i]\n        if visited[u]:\n            AL[v][CHILDREN][i] = None\n            continue\n        AL[v][SIZE] += dfs(u)\n    return AL[v][SIZE]\n\ndef anaaki(v):\n    ret = powp - 1\n    for ch in AL[v][CHILDREN]:\n        if ch is None: continue\n        ret -= pow(2, AL[ch][SIZE], p) - 1\n        ret %= p\n    ret -= pow(2, n - AL[v][SIZE], p) - 1\n    ret %= p\n    return ret\n\nn = int(input())\nSIZE = 0\nCHILDREN = 1\nAL = [[1, []] for _ in range(n)]\nvisited = [False] * n\np = 10 ** 9 + 7\npowp = pow(2, n - 1, p)\n\nfor i in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    AL[a][CHILDREN].append(b)\n    AL[b][CHILDREN].append(a)\n\ndfs(0)\nnumer = 0\nfor i in range(n):\n    numer += anaaki(i)\n    numer %= p\n\ndenom = powp * 2 % p\nprint(numer * pow(denom, p - 2, p) % p)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\n\ndef solve():\n    N = int(input())\n    AB = [tuple(map(int,input().split())) for i in range(N-1)]\n    MOD = 10**9+7\n    es = [[] for _ in range(N)]\n    for a,b in AB:\n        a,b = a-1,b-1\n        es[a].append(b)\n        es[b].append(a)\n\n    cs = [1] * N\n    def dfs(v,p=-1):\n        ret = 1\n        for to in es[v]:\n            if to==p: continue\n            ret += dfs(to,v)\n        cs[v] = ret\n        return ret\n    dfs(0)\n\n    pow2 = [1]\n    for i in range(N):\n        pow2.append((pow2[-1]*2) % MOD)\n\n    ans = 0\n    for i in range(N):\n        if len(es[i]) == 1: continue\n        ans += pow2[N-1] - 1\n        c = 0\n        for to in es[i]:\n            if cs[to] > cs[i]: continue\n            c += cs[to]\n            ans -= pow2[cs[to]] - 1\n        ans -= pow2[N-c-1] - 1\n\n    ans *= pow(pow2[N], MOD-2, MOD)\n    print(ans%MOD)\nsolve()", "from sys import stdin, setrecursionlimit\nfrom collections import deque\n\nsetrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef input():\n    return stdin.readline().strip()\n\n\nMOD = 1000000007\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a - 1].append(b - 1)\n    G[b - 1].append(a - 1)\n\npow2 = [1] * (N + 1)\nfor i in range(N):\n    pow2[i + 1] = pow2[i] * 2 % MOD\n\norder = []\nparent = [-1] * N\n\nstack = deque([0])\nwhile stack:\n    v = stack.pop()\n    order.append(v)\n    for nv in G[v]:\n        if parent[v] != nv:\n            parent[nv] = v\n            stack.append(nv)\n\nnumer = 0\nnums = [0] * N\n\nfor v in reversed(order):\n    tmp = 1\n    for nv in G[v]:\n        if parent[v] != nv:\n            c = nums[nv] + 1\n            nums[v] += c\n            tmp += pow2[c] - 1\n    tmp += pow2[N - nums[v] - 1] - 1\n    numer = (numer + pow2[N - 1] - tmp) % MOD\n\ndenom = pow2[N]\nans = numer * pow(denom, MOD - 2, MOD) % MOD\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\nMOD = 10**9 + 7\n\nn = int(input())\nedge = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = [int(item) - 1 for item in input().split()]\n    edge[a].append(b)\n    edge[b].append(a)\n\nchilds = [[] for _ in range(n)]\ndef dfs(p, v):\n    val = 1\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv)\n        val += ret\n        childs[v].append(ret)\n    if val != n:\n        childs[v].append(n - val)\n    return val\n\ndfs(-1, 0)\ntotal_pattern = pow(2, n, MOD)\ntotal_pattern_inv = pow(total_pattern, MOD-2, MOD)\ninv2 = pow(2, MOD-2, MOD)\npow2_table = [1]\nfor i in range(2 * 10**5):\n    pow2_table.append(pow2_table[-1] * 2 % MOD)\nans = 0\nfor line in childs:\n    pattern_ok = 0\n    if len(line) == 1:\n        continue\n    for item in line:\n        pattern_ok += pow2_table[item] - 1\n    pattern_ok += 1\n    ans += (total_pattern * inv2 - pattern_ok) * total_pattern_inv\n    ans %= MOD\nprint(ans)", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n = I()\n    v = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = LI()\n        a -= 1\n        b -= 1\n        v[a].append(b)\n        v[b].append(a)\n    d = [0]*n\n    d[0] = 1\n    q = deque([0])\n    p = [None]*n\n    while q:\n        x = q.popleft()\n        nd = d[x]+1\n        for y in v[x]:\n            if not d[y]:\n                d[y] = nd\n                p[y] = x\n                q.append(y)\n    V = list(range(n))\n    V.sort(key = lambda x:-d[x])\n    t = [1]*n\n    for x in V[:-1]:\n        t[p[x]] += t[x]\n    ans = 0\n    p = pow(2,n-1,mod)\n    for x in range(n):\n        tx = t[x]\n        if len(v[x]) < 2:\n            continue\n        s = p-1\n        for y in v[x]:\n            ty = t[y]\n            if tx < ty:\n                s -= pow(2,t[0]-tx,mod)-1\n            else:\n                s -= pow(2,ty,mod)-1\n            s %= mod\n        ans += s\n        ans %= mod\n    print((ans*pow(2,(mod-2)*n%(mod-1),mod)%mod))\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nans=0\ndef main(n,ab):\n  ki=[[] for _ in range(n)]\n  for a,b in ab:\n    a,b=a-1,b-1\n    ki[a].append(b)\n    ki[b].append(a)\n  mod=10**9+7\n  n2=[1]\n  for i in range(n):\n    n2.append((n2[-1]*2)%mod)\n  def dfs1(v,p):\n    ret=0\n    nonlocal ans\n    ans+=n2[n-1]-1\n    for nv in ki[v]:\n      if nv==p:continue\n      x=dfs1(nv,v)\n      ans-=n2[x]-1\n      ans-=n2[n-x]-1\n      ret+=x\n    ans%=mod\n    return ret+1\n  dfs1(0,-1)\n  allpat=pow(2,n,mod)\n  nonlocal ans\n  ans*=pow(allpat,mod-2,mod)\n  return ans%mod\n\nn=int(input())\nab=[list(map(int,input().split())) for _ in range(n-1)]\nprint((main(n,ab)))\n\n", "from sys import setrecursionlimit\nsetrecursionlimit(2 * (10 ** 5))\n\nn = int(input())\nab = [tuple([int(x)-1 for x in input().split()]) for _ in range(n-1)]\n\ne = [[] for _ in range(n)]\n\nfor a, b in ab:\n    e[a].append(b)\n    e[b].append(a)\n\nMOD = 10 ** 9 + 7\n\nd = []\n\ndef modinv(x):\n    a = x\n    b = MOD\n    u = 1\n    v = 0\n    while b:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u %= MOD\n    if u < 0:\n        u += MOD\n    return u\n\ndef dfs(x, p):\n    if len(e[x]) == 1:\n        if e[x][0] == p:\n            d.append(1)\n            return 1\n    ret = 1\n    for z in e[x]:\n        if z == p:\n            continue\n        ret += dfs(z, x)\n    if x != 0:\n        #print(x, d)\n        d.append(ret)\n    return ret\n\ndfs(0,-1)\n\nf = []\nw = 1\nfor i in range(n + 1):\n    f.append(w)\n    w = (w * 2) % MOD\n\n#print(d)\n\nans = 0\nfor x in d:\n    ans += ((f[x] - 1) * (f[n-x] - 1)) % MOD\n    ans %= MOD\n\n#print(ans)\n\nans = (ans - f[n-1] * n + f[n] - 1 + MOD) % MOD\n\n#print(ans)\n\nans = (ans * modinv(f[n])) % MOD\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\nP=10**9+7\nN=int(input())\nedges = [[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    edges[a-1].append((b-1, i))\n    edges[b-1].append((a-1, i))\nL=[0 for i in range(N)]\ndef dfs(cur, x):\n  res = 1\n  for i in edges[cur]:\n    if i[1]!=x:\n      res += dfs(i[0], i[1])\n  L[x]=res\n  return res\ndfs(0,-1)\nL2=[1]\ni2=pow(2,P-2,P)\nfor i in range(N):\n  L2.append(L2[-1]*i2%P)\ncnt = 0\nfor i in L:\n  cnt+=(1-L2[i])* (1-L2[N-i])\nprint((-N*i2-L2[-1]+cnt+1)%P)", "import sys\ninput = sys.stdin.readline\n\nmod = 10**9+7\n\ndef dfs(graph, N):\n    ans = 0\n    Par = [-1]*N\n    Childs = [[] for _ in range(N)]\n    stack = [0]\n    while stack:\n        p = stack.pop()\n        if p >= 0:\n            stack.append(~p)\n            for np in graph[p]:\n                if np != 0 and Par[np] == -1:\n                    stack.append(np)\n                    Par[np] = p\n        else:\n            p = ~p\n            score = pow(2, N-1, mod) - 1\n            upper = N-1\n            for a in Childs[p]:\n                upper -= a\n                score = (score - pow(2, a, mod) + 1) % mod\n            if p != 0:\n                score = (score - pow(2, upper, mod) + 1) % mod\n            ans = (ans + score) % mod\n            Childs[Par[p]].append(N-1-upper+1)\n    \n    return ans * pow(2, N*(mod-2), mod) % mod\n\ndef main():\n    N = int(input())\n    graph = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    print(dfs(graph, N))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#\u89e3\u8aac\u65b9\u91dd#\u89e3\u6cd51\n#https://qiita.com/ZhangChaoran/items/71fab0e4b8647a93d3a0\nfrom collections import deque\nfrom heapq import heappop, heappush\n#\u6a19\u6e96\u5165\u529b\nN = int(input())\nMOD = 10 ** 9 + 7\nL = [[] for i in range(N + 1)] #dfs\u7528\nfor i in range(N - 1):\n  a, b = map(int, input().split())\n  L[a].append(b)\n  L[b].append(a)\n\n#\u6728\u306e\u63a2\u7d22\nparent = [0] * (N + 1)\norder = []\nstack = [1]\nwhile stack:\n    x = stack.pop()\n    order.append(x)  # \u884c\u304d\u304c\u3051\u9806\u63a2\u7d22\u30ea\u30b9\u30c8\n    for y in L[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x  # \u89aa\u30ce\u30fc\u30c9\u3092\u8a18\u9332\n        stack.append(y)\n#print(order, parent)\n\nhalf = pow(2, MOD - 2, MOD)\npower_inv = [1] * (N + 1)#2 ** N \u306e\u9006\u5143\u306e\u96c6\u5408\nsize = [1] * (N + 1)\nfor i, v in enumerate(order[::-1], 1):#i\u304c1\u304b\u3089\n    p = parent[v]\n    x = size[v]  # v\u306e\u5b50\u5b6b\u30ce\u30fc\u30c9\u6570\uff08\u81ea\u5206\u3082\u542b\u3080\uff09\u3092\u3068\u308b\n    size[p] += x  # \u89aa\u306b\u30ce\u30fc\u30c9\u6570\u3092\u52a0\u7b97\n    power_inv[i] = power_inv[i - 1] * half % MOD  # [1, 1/2, 1/4, ...]\n#print(size)\n# \u8fbai\u304cS\u306b\u542b\u307e\u308c\u308b\u305f\u3081\u306e\u5fc5\u8981\u5341\u5206\u6761\u4ef6\u306b\u3088\u308b\u8fba\u306e\u500b\u6570\u306e\u671f\u5f85\u5024 \n# (1 - (1/2) ** i)(1 - (1/2) ** (N - i))\u3092\u5c55\u958b\u3057\u3066\u8a08\u7b97\n# \u6839\u3067\u3042\u308b1\u306e\u9802\u70b9\u4ee5\u5916\u306f\u3001\u3042\u308b\u9802\u70b9\u3068\u305d\u306e\u89aa\u3092\u7d50\u3076\u8fba\u3092\u8003\u3048\u305f\u969b\n# i \u3068 N - i\u500b\u306e\u9802\u70b9\u306b\u5225\u308c\u308b\u306e\u3067,size[2:]\u3067OK\nans = sum((1 - power_inv[i] - power_inv[N - i] + power_inv[N]) %\n          MOD for i in size[2:])  \n#ans = sum((1 - (1/2) ** i- (1/2) ** (N - i) + (1/2) ** N) for i in size[2:])  \n#print(ans)\nans += 1  # \u6728\u306e\u9802\u70b9\u306e\u500b\u6570\u306f\u8fba\u306e\u500b\u6570+1\n# -\u300c\u3059\u3079\u3066\u306e\u8fba\u304c\u542b\u307e\u308c\u306a\u3044\u3001\u3064\u307e\u308a\u7a7a\u30b0\u30e9\u30d5\u306e\u5834\u5408\u306e\u8aa4\u52a0\u7b97\u300d-N/2\nans -= power_inv[N] + N * power_inv[1]  \n#ans -= N * power_inv[1]  \nans %= MOD\n\nprint(ans)", "# ref https://qiita.com/ZhangChaoran/items/71fab0e4b8647a93d3a0\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ng = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    g[a].append(b)\n    g[b].append(a)\n\nmod = 10**9 + 7\npar = [0] * (n + 1)\norder = []\nstk = deque()\nstk.append(1)\n\nwhile stk:\n    v = stk.pop()\n    order.append(v)\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        par[x] = v\n        stk.append(x)\n\nrev = pow(2, mod - 2, mod)\npo2_inv = [1] * (n + 1)\nsize = [1] * (n + 1)\nfor i, y in enumerate(order[::-1], 1):\n    p = par[y]\n    size[p] += size[y]\n    po2_inv[i] = po2_inv[i - 1] * rev % mod\n\nans = 1\nfor i in size[2:]:\n    ans += (1 - po2_inv[i] - po2_inv[n - i] + po2_inv[n]) % mod\nans -= po2_inv[n] + n * po2_inv[1]\nans %= mod\nprint(ans)\n", "import sys\ninput=lambda: sys.stdin.readline().rstrip()\nsys.setrecursionlimit(200000)\nmod=10**9+7\nn=int(input())\nedge=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=map(int,input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\ninf=10**6\nPar=[inf]*n\nPar[0]=-1\nChk=[0]\nwhile Chk:\n  c=Chk.pop()\n  for next in edge[c]:\n    if Par[next]==inf:\n      Par[next]=c\n      Chk.append(next)\n\nC=[-1]*n\ndef ch(x):\n  ret=0\n  if x!=0 and len(edge[x])==1:\n    C[x]=0\n    return C[x]\n  else:\n    for e in edge[x]:\n      if e==Par[x]:\n        continue\n      else:\n        ret+=ch(e)+1\n    C[x]=ret\n    return C[x]\nch(0)\n\nH=[0]*n\nH[0]=1\nH[1]=pow(2,mod-2,mod)\nfor i in range(2,n):\n  H[i]=(H[i-1]*H[1])%mod\n\nans=0\nfor i in range(n):\n  if len(edge[i])==1:\n    continue\n  else:\n    A=[]\n    for e in edge[i]:\n      if e==Par[i]:\n        A.append(n-1-C[i])\n      else:\n        A.append(C[e]+1)\n    cur=1+(len(edge[i])-1)*H[-1]\n    for a in A:\n      cur-=H[n-1-a]\n    ans=(ans+cur)%mod\nprint((ans*H[1])%mod)", "import sys\n\n\ndef dfs1(root, links):\n    parent = [0] * n\n    subtree_count = [{} for _ in range(n)]\n    q = [(root, -1, 0)]  # 2\u756a\u76ee:\u89aa  3\u756a\u76ee:0=\u521d, 1=\u5168\u3066\u306e\u5b50\u5de1\u56de\u5f8c\n    while q:\n        v, p, t = q.pop()\n        if t == 0:\n            parent[v] = p\n            q.append((v, p, 1))\n            for u in links[v]:\n                if u == p:\n                    continue\n                q.append((u, v, 0))\n        elif p != -1:\n            subtree_count[p][v] = sum(subtree_count[v].values()) + 1\n    return parent, subtree_count\n\n\ndef dfs2(root, parent, subtree_count, d2, d2s):\n    ans = 0\n    q = [(root, 0)]\n    while q:\n        v, pc = q.pop()\n\n        if len(subtree_count[v]) == 0:\n            continue\n\n        p = parent[v]\n        children, st_counts = list(map(list, list(zip(*list(subtree_count[v].items())))))\n        children.append(p)\n        st_counts.append(pc)\n        cl = len(st_counts)\n        ct = sum(st_counts)\n\n        for u, stc in list(subtree_count[v].items()):\n            q.append((u, ct - stc + 1))\n\n        if cl == 1:\n            continue\n\n        tmp = 0\n        for stc in st_counts:\n            tmp = (tmp + d2s[ct - stc]) % MOD\n        tmp = (tmp - d2s[ct] * (cl - 1)) % MOD\n        ans = (ans + (1 - tmp) * d2) % MOD\n    return ans\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor line in sys.stdin:\n    a, b = list(map(int, line.split()))\n    a -= 1\n    b -= 1\n    links[a].add(b)\n    links[b].add(a)\nroot = 0\nMOD = 10 ** 9 + 7\nd2 = 500000004  # 2^-1 mod 10**9+7\nd2s = [1]\nfor i in range(n):\n    d2s.append(d2s[-1] * d2 % MOD)\nparent, subtree_count = dfs1(root, links)\n# print(parent)\n# print(subtree_count)\nans = dfs2(root, parent, subtree_count, d2, d2s)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(200200)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\nvisited = [False] * N\nvisited[0] = True\n\ndef dfs(u, i):\n    res = 1\n    for v, c in E[u]:\n        if not visited[v]:\n            visited[v] = True\n            res += dfs(v, c)\n    X[i] = res\n    return res\n\ndfs(0, -1)\n\nI = [1] * (N + 1)\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I[i + 1] = I[i] * inv % mod\n\nans = (I[N] + 1) * (N - 1) - inv * N - I[N] + 1\nfor xe in range(N - 1):\n    ans -= I[X[xe]] + I[N - X[xe]]\n    ans %= mod\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nLI = lambda: list(map(int, input().split()))\n\nN = int(input())\nAB = [LI() for _ in range(N - 1)]\n\nlink = [[] for _ in range(N)]\nchildren = [[] for _ in range(N)]\nw = [1] * N\nvisit = [False] * N\n\nMOD = 10 ** 9 + 7\n\n\ndef create_link():\n    for a, b in AB:\n        link[a - 1].append(b - 1)\n        link[b - 1].append(a - 1)\n\n\ndef dfs(s):\n    visit[s] = True\n    for t in link[s]:\n        if visit[t]:\n            continue\n        children[s].append(t)\n        dfs(t)\n        w[s] += w[t]\n\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\n\ndef main():\n    create_link()\n    dfs(0)\n    p2 = [None] * (N + 1)\n    p2[0] = 1\n    for i in range(N):\n        p2[i + 1] = 2 * p2[i] % MOD\n    \n    x = 0\n    for i in range(N):\n        s = p2[N - w[i]]\n        for j in children[i]:\n            s = (s + p2[w[j]] - 1) % MOD\n        x = (x + p2[N - 1] - s) % MOD\n    y = p2[N]\n\n    ans = x * modinv(y) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Surrounded Nodes\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**8)\nmod = 10**9 + 7\nN = int(input())\nG = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\nS = -1\nfor i in range(1, N+1):\n    if len(G[i]) == 1:\n        S = i\n        break\nvisited = [False for i in range(N+1)]\nparent = [-1 for i in range(N+1)]\ncount = [1 for i in range(N+1)]\n\nans = N*pow(2, N-1, mod)\nstack = deque()\n\n\ndef dfs(node):\n    visited[node] = True\n    for child in G[node]:\n        if visited[child] == False:\n            parent[child] = node\n            stack.append((node, child))\n            dfs(child)\n\n\npowers = [1 for i in range(2*10**5+1)]\nfor i in range(1, 2*10**5+1):\n    powers[i] = powers[i-1]*2 % mod\n\ndfs(S)\nwhile stack:\n    mom, child = stack.pop()\n    count[mom] += count[child]\nans = 0\nfor i in range(1, N+1):\n    if len(G[i]) > 1:\n        ans += powers[N-1]\n        for x in G[i]:\n            if x != parent[i]:\n                ans -= powers[count[x]]\n        ans -= powers[N-count[i]]\n        ans += len(G[i]) - 1\n        ans %= mod\nD = pow(2, N, mod)\nprint(ans*pow(D, mod-2, mod) % mod)", "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\nfrom operator import mul\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n\nn = I()\nG = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = LI()\n    G[a - 1] += [b - 1]\n    G[b - 1] += [a - 1]\n\n\npar = [-1] * n\ncnt = [0] * n\n\n\ndef f(u):\n    ret = 1\n    for v in G[u]:\n        if v == par[u]:\n            continue\n        par[v] = u\n        ret += f(v)\n    cnt[u] = ret\n    return ret\n\nf(0)\npow2 = [1] * (n + 1)\nfor i in range(1, n + 1):\n    pow2[i] = pow2[i - 1] * 2 % mod\n\nq = deque([0])\nans = 0\nwhile q:\n    u = q.pop()\n    ret = pow2[n - 1] - 1\n    for v in G[u]:\n        if v == par[u]:\n            continue\n        ret -= pow2[cnt[v]] - 1\n        q += [v]\n    ret -= pow2[n - cnt[u]] - 1\n    ans = (ans + ret) % mod\n\nprint((ans * pow(pow2[n], mod - 2, mod) % mod))\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\nmod = 10 ** 9 + 7\n\nN = int(input())\nvec = [[] for _ in range(N)]\nfor _ in range(N-1) :\n  A, B = map(int, input().split())\n  vec[A-1].append(B-1)\n  vec[B-1].append(A-1)\n\nsub_size = [[] for _ in range(N)]\n\ndef dfs(cur=0, pre=-1) :\n  s = 0\n  for nex in vec[cur] :\n    if nex == pre :\n      continue\n    t = dfs(nex, cur)\n    s += t\n    sub_size[cur].append(t)\n  if s != N - 1 :\n    sub_size[cur].append(N - 1 - s)\n\n  return s + 1\n\ndfs()\n\npower = [1]\nfor _ in range(N) :\n  power.append(power[-1]*2%mod)\n\nret = 0\nfor i in range(N) :\n  tmp = power[N-1]-1\n  for ss in sub_size[i] :\n    tmp -= power[ss]-1\n  ret += tmp\n\nret = ret*pow(power[N], mod - 2, mod)% mod\n\nprint(ret)", "import sys\nsys.setrecursionlimit(500000)\ninput = sys.stdin.readline\nN = int(input()); MOD=pow(10,9)+7\n\nbeki = [-1]*(N+1); beki[0] = 1; beki[1] = 2 #\u968e\u4e57\nfor i in range(2,N+1):\n  beki[i] = beki[i-1]*2%MOD\n#print(beki)\n\nG = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = list(map(int,input().split()))\n  a-=1;b-=1\n  G[a].append(b);G[b].append(a)\n#print(G)\nans = 0\n\ndef dfs(v,p): #\u81ea\u5206\u3068\u89aa\n  nonlocal ans #ans\u3092Global\u5909\u6570\u3068\u3057\u3066\u5ba3\u8a00\n  res = 1 #\u623b\u308a\u5024\u3002v\u3092\u542b\u3081\u305f\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3002\u81ea\u5206\u306e\u5206\u3067\u6700\u521d\u306f1\n  ts = [] #v\u304b\u3089\u751f\u3048\u3066\u3044\u308b\u90e8\u5206\u6728\u306e\u30ea\u30b9\u30c8\n  for u in G[v]:\n    if u == p:\n      continue\n    t = dfs(u,v) #u\u306e\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u304c\u623b\u308a\u5024\n    res += t\n    ts.append(t)\n  if p != -1: #\u6839\u4ee5\u5916\u306a\u3089\u89aa\u5074\u306e\u90e8\u5206\u6728\u304c\u5b58\u5728\u3059\u308b\u3002\n    ts.append(N-res)\n  now = beki[N-1] - 1 #\u81ea\u5206\u4ee5\u5916\u3092\u6c7a\u3081\u308b\u306e\u304c2^(N-1)\u901a\u308a\u3002\u81ea\u5206\u4ee5\u5916\u304c\u5168\u90e80\u304c1\u901a\u308a\u3002\n  for x in ts:\n    now -= beki[x] - 1 #\u5404\u90e8\u5206\u6728\u306b\u4e00\u500b\u4ee5\u4e0a\u9ed2\u304c\u3042\u308b\u5834\u5408\u306e\u6570\u3002\u5168\u901a\u308a - \u5168\u90e8\u767d\n  ans = (ans+now)%MOD\n  return res #v\u3092\u542b\u3081\u305f\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\n\ndfs(0,-1)\nALL = pow(2,N,MOD)\n#print(ans,ALL)\nans = ans*pow(ALL,MOD-2,MOD)%MOD #\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u3088\u308a1/ALL = ALL^(MOD-2)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**9)\nMOD=10**9+7\nN=int(input())\n\ntree=[[] for _ in range(N+1)]\nfor _ in range(N-1):\n  A,B=map(int,input().split())\n  tree[A].append(B)\n  tree[B].append(A)\n#print(tree)\n\ndef dfs(u,par):\n  visited[u]=True\n  ret=1\n  for v in tree[u]:\n    if not visited[v]:\n      ret+=dfs(v,u)\n\n  if par>0:\n    tree_dic[(u,par)]=ret\n  return ret\n  \nvisited=[False]*(N+1)\ntree_dic={}\ndfs(1,0)\n#print(tree_dic)\n\nbumbo=pow(2,N,MOD)\nbunshi=(pow(2,N,MOD)-1-N*pow(2,N-1,MOD))%MOD\nfor x in tree_dic.values():\n  term=(pow(2,x,MOD)-1)*(pow(2,N-x,MOD)-1)\n  bunshi+=term  \n  bunshi%=MOD\n#print(bunshi,bumbo)\n\nanswer=bunshi*pow(bumbo,MOD-2,MOD)\nanswer%=MOD\nprint(answer)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nmod = 10**9+7\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\n#\u4e92\u3044\u306b\u7d20\u306aa,b\u306b\u3064\u3044\u3066\u3001a*x+b*y=1\u306e\u4e00\u3064\u306e\u89e3\ndef extgcd(a,b):\n    r = [1,0,a]\n    w = [0,1,b]\n    while w[2]!=1:\n        q = r[2]//w[2]\n        r2 = w\n        w2 = [r[0]-q*w[0],r[1]-q*w[1],r[2]-q*w[2]]\n        r = r2\n        w = w2\n    #[x,y]\n    return [w[0],w[1]]\n\n# a\u306e\u9006\u5143(mod m)\u3092\u6c42\u3081\u308b\u3002(a\u3068m\u306f\u4e92\u3044\u306b\u7d20\u3067\u3042\u308b\u3053\u3068\u304c\u524d\u63d0)\ndef mod_inv(a,m=mod):\n    x = extgcd(a,m)[0]\n    return (m+x%m)%m\n\n\nN2 = [1]\nn = 1\nfor _ in range(N+1):\n    n = n*2 % mod\n    N2.append(n)\n\nWeight = [[] for _ in range(N)]\nchecked = [False]*N\n\ndef dfs(p):\n    checked[p] = True\n    downs = 0\n    for np in graph[p]:\n        if not checked[np]:\n            downscore = dfs(np)\n            Weight[p].append(N-downscore)\n            Weight[np].append(downscore)\n            downs += N-downscore\n    \n    return N-(downs+1)\n\ndfs(0)\n\na = 0\nfor n in range(N):\n    if len(Weight[n]) == 1:\n        continue\n    c = N2[N-1] - 1\n    for w in Weight[n]:\n        c = (c - N2[w] + 1) % mod\n    a = (a + c) % mod\n\nans = (a * mod_inv(N2[N])) % mod\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nadj = [ [] for _ in range(N+1) ]\nfor _ in range(N-1):\n  a,b = map(int,input().split())\n  adj[a].append(b)\n  adj[b].append(a)\n\ndef dfs(v, p=-1):\n  nonlocal ans\n\n  res = 1\n  ts = []\n  for u in adj[v]:\n    if (u==p): continue\n    t = dfs(u,v)\n    res += t\n    ts.append(t)\n\n  if p != -1:\n    ts.append(N-res)\n\n  # print(v, ts)\n\n  # now = pow(2, N-1, MOD)-1\n  now = pows[N-1]-1\n  for t in ts:\n    # now -= pow(2, t, MOD)-1\n    now -= pows[t] - 1\n  ans += now\n  return res\n\nans = 0\nMOD = 10**9+7\n# \u9ad8\u901f\u53161\npows = [1] * (N+1)\nfor i in range(1, N+1):\n  pows[i] = (pows[i - 1] * 2) % MOD\n\ndfs(1)\nprint((ans * pow(pows[N], MOD-2, MOD)) % MOD)", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, readline().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nparent = [0] * (N + 1)\norder = []\nstack = [1]\nwhile stack:\n    x = stack.pop()\n    order.append(x)  # \u884c\u304d\u304c\u3051\u9806\u63a2\u7d22\u30ea\u30b9\u30c8\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x  # \u89aa\u30ce\u30fc\u30c9\u3092\u8a18\u9332\n        stack.append(y)\n\nMOD = 10**9 + 7\nhalf = pow(2, MOD - 2, MOD)\npower_inv = [1] * (N + 1)\nsize = [1] * (N + 1)\nfor i, v in enumerate(order[::-1], 1):\n    p = parent[v]\n    x = size[v]  # v\u306e\u5b50\u5b6b\u30ce\u30fc\u30c9\u6570\uff08\u81ea\u5206\u3082\u542b\u3080\uff09\u3092\u3068\u308b\n    size[p] += x  # \u89aa\u306b\u30ce\u30fc\u30c9\u6570\u3092\u52a0\u7b97\n    power_inv[i] = power_inv[i - 1] * half % MOD  # [1, 1/2, 1/4, ...]\n\nans = sum((1 - power_inv[i] - power_inv[N - i] + power_inv[N]) % MOD for i in size[2:])  # \u89e3\u6cd51\u306e\u78ba\u7387\u5f0f(\u30ce\u30fc\u30c91\u3092\u9664\u304f)\nans += (1 - power_inv[N]) - N * power_inv[1]  # +  - N/2 \nans %= MOD\n\nprint(ans)", "import sys\nsys.setrecursionlimit(500000)\ninput = sys.stdin.readline\nN = int(input()); MOD=pow(10,9)+7\nG = [[] for _ in range(N)]\nfor i in range(N-1):\n  a,b = list(map(int,input().split()))\n  a-=1;b-=1\n  G[a].append(b);G[b].append(a)\n#print(G)\nans = 0\n\ndef dfs(v,p): #\u81ea\u5206\u3068\u89aa\n  nonlocal ans #ans\u3092Global\u5909\u6570\u3068\u3057\u3066\u5ba3\u8a00\n  res = 1 #\u623b\u308a\u5024\u3002v\u3092\u542b\u3081\u305f\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3002\u81ea\u5206\u306e\u5206\u3067\u6700\u521d\u306f1\n  ts = [] #v\u304b\u3089\u751f\u3048\u3066\u3044\u308b\u90e8\u5206\u6728\u306e\u30ea\u30b9\u30c8\n  for u in G[v]:\n    if u == p:\n      continue\n    t = dfs(u,v) #u\u306e\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u304c\u623b\u308a\u5024\n    res += t\n    ts.append(t)\n  if p != -1: #\u6839\u4ee5\u5916\u306a\u3089\u89aa\u5074\u306e\u90e8\u5206\u6728\u304c\u5b58\u5728\u3059\u308b\u3002\n    ts.append(N-res)\n  now = pow(2,N-1,MOD) - 1 #\u81ea\u5206\u4ee5\u5916\u3092\u6c7a\u3081\u308b\u306e\u304c2^(N-1)\u901a\u308a\u3002\u81ea\u5206\u4ee5\u5916\u304c\u5168\u90e80\u304c1\u901a\u308a\u3002\n  for x in ts:\n    now -= pow(2,x,MOD) - 1 #\u5404\u90e8\u5206\u6728\u306b\u4e00\u500b\u4ee5\u4e0a\u9ed2\u304c\u3042\u308b\u5834\u5408\u306e\u6570\u3002\u5168\u901a\u308a - \u5168\u90e8\u767d\n  ans = (ans+now)%MOD\n  return res #v\u3092\u542b\u3081\u305f\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\n\ndfs(0,-1)\nALL = pow(2,N,MOD)\n#print(ans,ALL)\nans = ans*pow(ALL,MOD-2,MOD)%MOD #\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u3088\u308a1/ALL = ALL^(MOD-2)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\nP=10**9+7\nN=int(input())\nedges = [[] for i in range(N)]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  edges[a-1].append((b-1, i))\n  edges[b-1].append((a-1, i))\nL=[0]*N\ndef dfs(cur, x):\n  res = 1\n  for i in edges[cur]:\n    if i[1]!=x:\n      res += dfs(i[0], i[1])\n  L[x]=res\n  return res\ndfs(0,-1)\nL2=[1]\ni2=pow(2,P-2,P)\nfor i in range(N):\n  L2.append(L2[-1]*i2%P)\ncnt = 0\nfor i in L:\n  cnt+=(1-L2[i])* (1-L2[N-i])\nprint((-N*i2-L2[-1]+cnt+1)%P)", "from sys import setrecursionlimit\nsetrecursionlimit(2 * 10 ** 5 + 10)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, p):\n    res = 1\n    for v, c in E[u]:\n        if p != c:\n            res += dfs(v, c)\n    X[p] = res\n    return res\n\ndfs(0, -1)\n\nI = [1]\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I.append(I[-1] * inv % mod)\n\nans = - inv * N - I[N] + 1 + sum((1 - I[x]) * (1 - I[N - x]) for x in X)\n\nprint(ans % mod)", "import sys\nimport math\nimport heapq\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef II(): return int(input())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\ndef gcd(x, y):\n    if x < y: x, y = y, x\n    div = x % y\n    while div != 0:\n        x, y = y, div\n        div = x % y\n    return y\n\nN=II()\nAB = [LI() for _ in range(N-1)]\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]: continue\n        parent[y] = x\n        stack.append(y)\n\nx = (DVSR + 1) // 2\nPWR=[1]*(N+1)\nRWP=[1]*(N+1)\n\nfor i in range(1,N+1):\n    PWR[i] = PWR[i-1] * 2 % DVSR\n    RWP[i] = RWP[i-1] * x % DVSR\n\nanswer = 0\nsize = [1] * (N+1)\nfor v in order[::-1]:\n    p = parent[v]\n    size[p] += size[v]\n    A = [size[w] for w in graph[v] if w != p]\n    if v != root: A.append(N - 1 - sum(A))\n    if len(A) == 1: continue\n    prod = 1\n    coef = 1\n    for x in A:\n        prod *= RWP[x]\n        prod %= DVSR\n        coef += (PWR[x] - 1)\n    E = 1 - prod * coef % DVSR\n    answer += E\n\nanswer *= RWP[1]\nanswer %= DVSR\nprint(answer)", "# class\u3092\u4f7f\u3046\u306e\u3092\u3084\u3081\u3066list\u3067\u5b9f\u65bd\u3059\u308b\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 9)\nimport sys\ninput = sys.stdin.readline\n\ndef dfs(v):\n    visited[v] = True\n    for i in range(len(AL[v][CHILDREN])):\n        u = AL[v][CHILDREN][i]\n        if visited[u]:\n            AL[v][CHILDREN][i] = None\n            continue\n        AL[v][SIZE] += dfs(u)\n    return AL[v][SIZE]\n\n\ndef anaaki(v):\n    ret = powp - 1\n    for ch in AL[v][CHILDREN]:\n        if ch is None: continue\n        ret -= pow(2, AL[ch][SIZE], p) - 1\n        ret %= p\n    ret -= pow(2, n - AL[v][SIZE], p) - 1\n    ret %= p\n    return ret\n\nn = int(input())\nSIZE = 0\nCHILDREN = 1\nAL = [[1, []] for _ in range(n)]\nvisited = [False] * n\np = 10 ** 9 + 7\npowp = pow(2, n - 1, p)\n\nfor i in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    AL[a][CHILDREN].append(b)\n    AL[b][CHILDREN].append(a)\n\ndfs(0)\nnumer = 0\nfor i in range(n):\n    numer += anaaki(i)\n    numer %= p\n\ndenom = pow(2, n, p)\nprint(numer * pow(denom, p - 2, p) % p)", "import sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, p):\n    res = 1\n    for v, c in E[u]:\n        if p != c:\n            res += dfs(v, c)\n    X[p] = res\n    return res\n\ndfs(0, -1)\n\nI = [1]\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I.append(I[-1] * inv % mod)\n\nans = - inv * N - I[N] + 1 + sum((1 - I[x]) * (1 - I[N - x]) for x in X)\nans %= mod\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 7)\n\nMOD = 10**9 + 7\n\ndef MOD_inv(a):\n    b = MOD\n    u = 1\n    v = 0\n    while b > 0:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u = u % MOD\n    if u < 0:\n        u += MOD\n    return u\n\ndef cntNode(G, C, crr, pre):\n    s = 0\n    for i, nxt in enumerate(G[crr]):\n        if nxt == pre:\n            continue\n        else:\n            C[crr][i] = cntNode(G, C, nxt, crr)\n            s += C[crr][i]\n    return s+1\n\ndef main():\n    n = int(input())\n    G = [[] for _ in range(n)]\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        a, b = a-1, b-1\n        G[a].append(b)\n        G[b].append(a)\n    C = [[-1]*len(G[i]) for i in range(n)]\n    idx = -1\n    for i in range(n):\n        if len(G[i]) == 1:\n            idx = i\n            break\n    cntNode(G, C, idx, -1)\n    for i in range(n):\n        idx = -1\n        s = 0\n        for j, v in enumerate(C[i]):\n            if v == -1:\n                idx = j\n            else:\n                s += v\n        if idx != -1:\n            C[i][idx] = n-1 - s\n    s = 0\n    pows = [0]*(n+1)\n    pows[0] = 1\n    for i in range(1, n+1):\n        pows[i] = 2 * pows[i-1] % MOD\n    for i in range(n):\n        p = pows[n-1]\n        for v in C[i]:\n            p -= pows[v] - 1\n        p -= 1\n        p %= MOD\n        s += p\n        s %= MOD\n    print(s * MOD_inv(pows[n]) % MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nmod = 10**9+7\n\ndef dfs(graph, N):\n    ans = 0\n    Par = [-1]*N\n    Childs = [[] for _ in range(N)]\n    stack = [0]\n    while stack:\n        p = stack.pop()\n        if p >= 0:\n            stack.append(~p)\n            for np in graph[p]:\n                if np != 0 and Par[np] == -1:\n                    stack.append(np)\n                    Par[np] = p\n        else:\n            p = ~p\n            score = pow(2, N-1, mod) - 1\n            upper = N-1\n            for a in Childs[p]:\n                upper -= a\n                score = (score - pow(2, a, mod) + 1) % mod\n            if p != 0:\n                score = (score - pow(2, upper, mod) + 1) % mod\n            ans = (ans + score) % mod\n            Childs[Par[p]].append(N-1-upper+1)\n    \n    return ans * pow(2, N*(mod-2), mod) % mod\n\ndef main():\n    N = int(input())\n    graph = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list(map(int, input().split()))\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    print((dfs(graph, N)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Surrounded Nodes\nimport sys\nsys.setrecursionlimit(10**8)\nmod = 10**9 + 7\nN = int(input())\nG = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\nS = -1\nfor i in range(1, N+1):\n    if len(G[i]) == 1:\n        S = i\n        break\nvisited = [False for i in range(N+1)]\nparent = [-1 for i in range(N+1)]\ncount = [1 for i in range(N+1)]\n\nans = N*pow(2, N-1, mod)\n\n\ndef dfs(node):\n    visited[node] = True\n    for child in G[node]:\n        if visited[child] == False:\n            parent[child] = node\n            dfs(child)\n    for child in G[node]:\n        if child != parent[node]:\n            count[node] += count[child]\n\n\npowers = [1 for i in range(2*10**5+1)]\nfor i in range(1, 2*10**5+1):\n    powers[i] = powers[i-1]*2 % mod\n\ndfs(S)\n\nans = 0\nfor i in range(1, N+1):\n    if len(G[i]) > 1:\n        ans += powers[N-1]\n        for x in G[i]:\n            if x != parent[i]:\n                ans -= powers[count[x]]\n        ans -= powers[N-count[i]]\n        ans += len(G[i]) - 1\n        ans %= mod\nD = pow(2, N, mod)\nprint(ans*pow(D, mod-2, mod) % mod)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    MOD = 10**9 + 7\n\n    N = int(input())\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list(map(int, input().split()))\n        a, b = a-1, b-1\n        adjL[a].append(b)\n        adjL[b].append(a)\n\n    sizeSubtrees = [0] * N\n    sizeAdjss = [[] for _ in range(N)]\n\n    def dfs(vNow, vPar):\n        sizeSubtrees[vNow] = 1\n        for v2 in adjL[vNow]:\n            if v2 == vPar: continue\n            s = dfs(v2, vNow)\n            sizeAdjss[vNow].append(s)\n            sizeSubtrees[vNow] += s\n        sizeAdjss[vNow].append(N-sizeSubtrees[vNow])\n        return sizeSubtrees[vNow]\n\n    dfs(0, -1)\n\n    def getPows(base, n, MOD):\n        pows = [1] * (n+1)\n        for x in range(1, n+1):\n            pows[x] = (pows[x-1] * base) % MOD\n        return pows\n    pow2s = getPows(2, N, MOD)\n\n    nums = [0] * N\n    for v in range(N):\n        num = pow2s[N-1] - 1\n        for sizeAdj in sizeAdjss[v]:\n            num -= pow2s[sizeAdj] - 1\n            num %= MOD\n        nums[v] = num\n\n    ans = sum(nums) % MOD * pow(pow2s[N], MOD-2, MOD) % MOD\n    print(ans)\n\n\nsolve()\n", "N=int(input())\nE=[[] for _ in range(N)]\nfor _ in range(N-1):\n    A,B=list(map(int,input().split()))\n    E[A-1].append(B-1)\n    E[B-1].append(A-1)\nMOD=10**9+7\n\n#dp=\u5b50\u30ce\u30fc\u30c9\u306e\u6570+1(\u81ea\u5206)\ndp=[1]*N\n\nroot=0\nparent=[0]*N\norder=[]\ndef dfs():\n    parent[root]=root\n    stack=[root]\n    while stack:\n        node=stack.pop()\n        order.append(node)\n        for ss in E[node]:\n            if parent[node]!=ss:\n                stack.append(ss)\n                parent[ss]=node\n\npow2=[1]*(N+1)\nfor i in range(1,len(pow2)):\n    pow2[i]=pow2[i-1]*2%MOD\n\ndef solve():\n    ans=0\n    inv2=pow(2,MOD-2,MOD)\n    #p0=\u3059\u3079\u3066\u306e\u90e8\u5206\u6728\u306b\u9ed2\u9802\u70b9\u304c1\u3064\u3082\u542b\u307e\u308c\u306a\u3044\u78ba\u7387\n    p0=pow(pow2[N-1],MOD-2,MOD)\n    for i in reversed(order):\n        if root!=i:\n            dp[parent[i]]+=dp[i]\n        p=0\n        if len(E[i])>=2:\n            #p0*(p1-1)=\u3069\u308c\u304b1\u3064\u306e\u5404\u90e8\u5206\u6728\u306b\u9ed2\u9802\u70b9\u304c1\u3064\u4ee5\u4e0a\u542b\u307e\u308c\u308b\u78ba\u7387\n            p1=1\n            for s in E[i]:\n                size=0\n                if parent[i]!=s:\n                    size=dp[s]\n                elif i!=root:\n                    size=N-dp[i]\n                else:\n                    continue\n                p1+=pow2[size]-1\n            p=1-(p0*p1)\n            p%=MOD\n        ans+=p\n        ans%=MOD\n    #\u9802\u70b9i\u304c\u767d\u306e\u78ba\u7387\n    ans=ans*inv2%MOD\n    print(ans)\n\ndfs()\nsolve()\n", "def main():\n    from sys import stdin\n    input = stdin.readline\n    mod = 10**9+7\n    n = int(input())\n    ab = [list(map(int, input().split())) for _ in [0]*(n-1)]\n    pow2 = [1]\n    for i in range(200000):\n        pow2.append(pow2[-1]*2 % mod)\n\n    g = [[] for _ in [0]*n]\n    [g[a-1].append(b-1) for a, b in ab]\n    [g[b-1].append(a-1) for a, b in ab]\n    root = 0\n    d = [-1]*n\n    d[root] = 0\n    q = [root]\n    cnt = 0\n    while q:\n        cnt += 1\n        qq = []\n        while q:\n            i = q.pop()\n            for j in g[i]:\n                if d[j] == -1:\n                    d[j] = cnt\n                    qq.append(j)\n        q = qq\n\n    for i in range(n):\n        di = d[i]\n        g[i] = [j for j in g[i] if di <= d[j]]\n\n    d = [j for i, j in sorted([(j, i) for i, j in enumerate(d)])]\n    dp = [(0, 0, 1) for _ in [0]*n]\n\n    for i in d[::-1]:\n        if g:\n            n = sum([dp[j][2] for j in g[i]])+1\n            x, y = pow(2, n-1, mod)-1, 0\n            for j in g[i]:\n                xj, yj, nj = dp[j]\n                p1, p2 = pow2[n-nj], pow2[nj]\n                x += xj*p1+yj*(p1-1)-p2+1\n                y += yj+p2-1\n            dp[i] = (x % mod, y % mod, n)\n\n    x = dp[0][0]\n    y = pow(2, dp[0][2], mod)\n    print((x*pow(y, mod-2, mod) % mod))\n\n\nmain()\n", "# ref https://qiita.com/ZhangChaoran/items/71fab0e4b8647a93d3a0\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\ng = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    g[a].append(b)\n    g[b].append(a)\n\nmod = 10**9 + 7\npar = [0] * (n + 1)\norder = []\nstk = deque()\nstk.append(1)\n\nwhile stk:\n    v = stk.pop()\n    order.append(v)\n    for x in g[v]:\n        if x == par[v]:\n            continue\n        par[x] = v\n        stk.append(x)\n\nrev = (mod + 1) // 2\npo2_inv = [1] * (n + 1)\nsize = [1] * (n + 1)\nfor i, y in enumerate(order[::-1], 1):\n    p = par[y]\n    size[p] += size[y]\n    po2_inv[i] = po2_inv[i - 1] * rev % mod\n\nans = 1\nfor i in size[2:]:\n    ans += (1 - po2_inv[i] - po2_inv[n - i] + po2_inv[n]) % mod\nans -= po2_inv[n] + n * po2_inv[1]\nans %= mod\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nN = int(input())\nMOD = 10**9 + 7\ntree = [[] for i in range(N+1)]\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  tree[a].append(b)\n  tree[b].append(a)\n\n# \u9802\u70b91\u3092\u30eb\u30fc\u30c8\u306b\u3057\u3066\u5404\u9802\u70b9\u3088\u308a\u4e0b\u306b\u3042\u308b\u90e8\u5206\u6728\u306e\u9802\u70b9\u6570\u3092\u6c42\u3081\u3066\u3044\u304f\nroot, par = 1, 0\nsizes = [0] * (N+1)\norder = [[root, par]]\ndef calc_nums(node, par):\n  nonlocal sizes\n  nonlocal order\n  if sizes[node] > 0:\n    return sizes[node]\n  children = tree[node]\n  res = 1\n  for child in children:\n    if child == par:\n      continue\n    order.append([child, node])\n    res += calc_nums(child, node)\n  sizes[node] = res\n  return res\n\n_ = calc_nums(root, par)\n\n# 2\u306e\u7d2f\u4e57\u3092\u4e8b\u524d\u306b\u8a08\u7b97\u3057\u3066\u304a\u304f\nprod2 = [1]\nfor i in range(N):\n  prod2.append(prod2[-1] * 2 % MOD)\n\n# \u5404\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u9802\u70b9\u304c\u7a74\u3042\u304d\u5ea6\u3068\u3057\u3066\u30ab\u30a6\u30f3\u30c8\u3055\u308c\u308b\u72b6\u6cc1\u3092\u72ec\u7acb\u306b\u8a08\u7b97\u3059\u308b\ndemo = 0 # \u5206\u5b50\ndiv = prod2[N] # \u5206\u6bcd\nbase = prod2[N-1] - 1\nfor node, par in order:\n  children = tree[node]\n  num = base\n  num_par = N - 1\n  for child in children:\n    if child == par:\n      continue\n    s = sizes[child]\n    num_par -= s\n    num -= prod2[s] - 1 \n  num -= prod2[num_par] - 1\n  demo += num\n    \nans = demo * pow(div, MOD-2, MOD) % MOD\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    def dfs(u=0, pu=-1):\n        res = 1\n        for cu in to[u]:\n            if cu == pu: continue\n            ret = dfs(cu, u)\n            children_size[u].append(ret)\n            res += ret\n        return res\n\n    md = 10 ** 9 + 7\n    n = II()\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = MI1()\n        to[a].append(b)\n        to[b].append(a)\n    #print(to)\n\n    # 1/2\u3092mod\u3067\u8868\u3057\u3066\u3001\u7d2f\u4e57\u3092\u4e8b\u524d\u8a08\u7b97\n    half = pow(2, md - 2, md)\n    exp_half = [1, half]\n    for _ in range(n):\n        exp_half.append(exp_half[-1] * half % md)\n    # print(exp_half)\n\n    # \u5b50\u306e\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba(\u8981\u7d20\u6570)\u3092dfs\u3067\u6c42\u3081\u308b\n    children_size = [[] for _ in range(n)]\n    dfs()\n    # print(children_size)\n\n    # \u305d\u308c\u305e\u308c\u306e\u9802\u70b9\u306b\u304a\u3044\u3066\u3001\u63a5\u7d9a\u3059\u308b\u90e8\u5206\u6728\u306e\u3046\u3061\n    # 2\u3064\u4ee5\u4e0a\u306e\u90e8\u5206\u6728\u306b\u9ed2\u304c\u542b\u307e\u308c\u308b\u78ba\u7387\u3092\u6c42\u3081\u308b\n    # \u4f59\u4e8b\u8c61\u3092\u5229\u7528(1-\u9ed2\u3092\u542b\u3080\u90e8\u5206\u6728\u304c\u306a\u3044\u78ba\u7387-\u9ed2\u3092\u542b\u3080\u90e8\u5206\u6728\u304c1\u3064\u306e\u78ba\u7387)\n    # (\u305d\u306e\u9802\u70b9\u304c\u767d\u306e\u78ba\u7387)\u00d7(\u4e0a\u8a18\u306e\u78ba\u7387)\u304c\u305d\u306e\u9802\u70b9\u304c\u767d\u3067\u6b8b\u308b\u671f\u5f85\u5024\u306a\u306e\u3067\u548c\u3092\u6c42\u3081\u308c\u3070\u7b54\u3048\n    ans = 0\n    noblack = exp_half[n - 1]\n    for cs in children_size:\n        if not cs: continue\n        sum_cs = sum(cs)\n        if sum_cs != n - 1: cs.append(n - 1 - sum_cs)\n        onlyone = 0\n        for child_size in cs:\n            onlyone += (1 - exp_half[child_size]) * exp_half[n - 1 - child_size]\n        ans += (1 - noblack - onlyone) * half\n        ans %= md\n    print(ans)\n\nmain()\n", "import sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, p):\n    res = 1\n    for v, c in E[u]:\n        if p != c:\n            res += dfs(v, c)\n    X[p] = res\n    return res\n\ndfs(0, -1)\n\nI = [1] * (N + 1)\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I[i + 1] = I[i] * inv % mod\n\nans = - inv * N - I[N] + 1\nfor e in range(N - 1):\n    ans += (1 - I[X[e]]) * (1 - I[N - X[e]])\n    ans %= mod\n\nprint(ans)", "# 75\n\nimport sys\nsys.setrecursionlimit(10**8)\n\nMOD = 10**9+7\nN = int(input())\ng_l = [[] for i in range(N)]\ncheck_l = [-1] * N\nnum_l = [0] * N\nfor i in range(N-1):\n    ai, bi = list(map(int, input().split()))\n    g_l[ai-1].append(bi-1)\n    g_l[bi-1].append(ai-1)\n\n\ndef dfs(n):\n    d = 1\n    if check_l[n] > 0:\n        return num_l[n]\n    check_l[n] = 1\n    for next_n in g_l[n]:\n        d += dfs(next_n)\n    num_l[n] = d\n    return d\n\n\ndef modinv(a):\n    # calc : (a**(-1)) %MOD\n    return pow(a, MOD-2, MOD)\n\n\ndef solve():\n    dfs(0)\n    pow_l = [None]*(N+1)\n    pow_l[0] = 1\n    for i in range(1, N+1):\n        pow_l[i] = (pow_l[i-1] * 2) % MOD\n\n    ans = 0\n    # for i in range(1, N):\n    #     ans += (1 - (1/2)**num_l[i]) * (1 - (1/2)**(N-num_l[i]))\n    # ans += 1 - (1/2)**N  # \u8fba\u306e\u671f\u5f85\u5024\u2192\u9802\u70b9\u306e\u671f\u5f85\u5024\u306b\u5909\u63db(\u7a7a\u96c6\u5408\u4ee5\u5916\u306f+1\u3055\u308c\u308b)\n    # ans -= N/2  # \u9ed2\u70b9\u306e\u671f\u5f85\u5024\u3092\u5f15\u304f\n    for i in range(1, N):\n        ans = (ans + (pow_l[num_l[i]]-1) *\n               (pow_l[N-num_l[i]]-1) % MOD) % MOD\n    ans = (ans + (pow_l[N] - 1) - (N * pow_l[N-1]) % MOD) % MOD\n    y = ans\n    x = pow(2, N, MOD)\n\n    z = (y * modinv(x)) % MOD\n\n    print(z)\n\n\nsolve()\n", "#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(300000)\n\nMOD = 1000000007  # type: int\n\ndef calc_fraction_mod(numerator, denominator):\n    '''\n        returns numerator / denominator (mod MOD)\n    '''\n    inv = pow(denominator, MOD - 2, MOD)\n    return numerator * inv % MOD\n\ndef solve(N: int, A: \"List[int]\", B: \"List[int]\"):\n    conns = [[] for _ in range(N)]\n    for i in range(N - 1):\n        conns[A[i] - 1].append(B[i] - 1)\n        conns[B[i] - 1].append(A[i] - 1)\n\n    pows = []\n    for i in range(N + 1):\n        pows.append(pow(2, i, MOD))\n\n    num = [0]\n    visited = [False] * N\n    def dfs(idx):\n        visited[idx] = True\n        children = 0\n        subs = []\n        for c in conns[idx]:\n            if visited[c]:\n                continue\n            sub = dfs(c)\n            children += sub\n            subs.append(sub)\n        subs.append(N - children - 1)\n        #tmp = pow(2, N - 1, MOD)\n        tmp = pows[N - 1]\n        tmp -= 1 # all white\n        for sub in subs:\n            #tmp -= pow(2, sub, MOD) - 1\n            tmp -= pows[sub] - 1\n        num[0] += tmp\n        return children + 1\n    dfs(0)\n\n    #deno = pow(2, N, MOD)\n    deno = pows[N]\n    num = num[0]\n    ret = calc_fraction_mod(num, deno)\n    print(ret)\n    return\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [int()] * (N - 1)  # type: \"List[int]\"\n    B = [int()] * (N - 1)  # type: \"List[int]\"\n    for i in range(N - 1):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n    solve(N, A, B)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(2*10**5)\ninput = sys.stdin.readline\n\n\ndef calc_counts(n, edges):\n    counts = [0] * n\n    seen = [False] * n\n    dfs(0, edges, seen, counts)\n    return counts\n\n\ndef dfs(node, edges, seen, counts):\n    count = 1\n    seen[node] = True\n    for to in edges[node]:\n        if seen[to]:\n            continue\n        count += dfs(to, edges, seen, counts)\n    counts[node] = count\n    return count\n\n\ndef calc_blank(node, counts: list, edges, all, mod=10**9+7):\n    n = len(counts)\n    paths = edges[node]\n    if len(paths) <= 1:\n        return 0\n    base = counts[node]\n    result = all - 1\n    for v in paths:\n        count = counts[v]\n        if count > base:\n            count = n - base\n        result -= pow(2, count, mod) - 1\n        result %= mod\n\n    return result\n\n\ndef main():\n    mod = 10**9 + 7\n    n = int(input())\n    edges = [[] for _ in range(n)]\n    for _ in range(n-1):\n        a, b = list(map(int, input().split()))\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n\n    counts = calc_counts(n, edges)\n    all = pow(2, n-1, mod)\n    blanks = 0\n    for node in range(n):\n        blank = calc_blank(node, counts, edges, all)\n        blanks += blank\n        blanks %= mod\n\n    inv_denominator = pow(pow(2, n, mod), mod-2, mod)\n    ans = blanks * inv_denominator % mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000)\nreadline = sys.stdin.readline\n\nN = int(readline())\n\nadj = [[] for i in range(N)]\nfor i in range(N - 1):\n    A, B = list(map(int, readline().split()))\n    A -= 1\n    B -= 1\n    adj[A].append(B)\n    adj[B].append(A)\n\nmod = 10 ** 9 + 7\npow2 = [1] * (N + 1)\nfor i, j in zip(list(range(N)), list(range(1, N + 1))):\n    pow2[j] = pow2[i] * 2 % mod\n\nans = 0\n\n\ndef dfs(node, parent):\n    nonlocal ans\n    cnt = 1\n    \n    for child in adj[node]:\n        if child != parent:\n            cnt += dfs(child, node)\n    \n    ans += (pow2[cnt] - 1) * (pow2[N-cnt] - 1)\n    ans %= mod\n    \n    return cnt\n\ndfs(0, None)\n\nans = (ans - N * pow2[N-1] + pow2[N] - 1) % mod\nans = ans * pow(pow2[N], mod - 2, mod) % mod\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\ndef main():\n  MOD = 10**9+7\n  n = int(input())\n  T = [[] for _ in range(n)]\n  for _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    T[a].append(b)\n    T[b].append(a)\n  C = [[] for _ in range(n)]\n  seen = [False]*n\n  dp = [0]*n\n  def dfs(v):\n    cnt = 1\n    seen[v] = True\n    for nv in T[v]:\n      if seen[nv]:\n        continue\n      C[v].append(nv)\n      cnt += dfs(nv)\n    dp[v] = cnt\n    return cnt\n\n  dfs(0)\n\n  p = [1]*(n+1)\n  inv = [1]*(n+1)\n  inv_two = pow(2, MOD-2, MOD)\n  for i in range(n):\n    p[i+1] = p[i] * 2 % MOD\n    inv[i+1] = inv[i] * inv_two % MOD\n  ans = 0\n  for i in range(n):\n    s = 1\n    t = 1\n    cnt = 1\n    for c in C[i]:\n      l = dp[c]\n      s *= inv[l]\n      s %= MOD\n      t += p[l] - 1\n      t %= MOD\n      cnt += l\n    r = n - cnt\n    s *= inv[r]\n    s %= MOD\n    t += p[r] - 1\n    t %= MOD\n    res = (1 - s*t) % MOD * inv_two\n    res %= MOD\n    ans += res\n    ans %= MOD\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, p):\n    res = 1\n    for v, c in E[u]:\n        if p != c:\n            res += dfs(v, c)\n    X[p] = res\n    return res\n\ndfs(0, -1)\n\nI = [1] * (N + 1)\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I[i + 1] = I[i] * inv % mod\n\nans = - inv * N - I[N] + 1\nfor e in range(N - 1):\n    ans += (1 - I[X[e]]) * (1 - I[N - X[e]])\n    ans %= mod\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\n\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nmod = 10**9+7\n\nn = int(input())\nG = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b = list(map(int, input().split()))\n    a,b = a-1,b-1\n    G[a].append(b)\n    G[b].append(a)\n\ncnt = [0]*n\ndef dfs(cur, prev):\n    tmp = 1\n    for to in G[cur]:\n        if to != prev:\n            tmp += dfs(to, cur)\n    cnt[cur] = tmp\n    return tmp\n\ndfs(0, -1)\n\npower = [0]*(n)\npowe2_n = pow(2, n, mod)\npowe2_n = pow(powe2_n, mod-2, mod)\npower[n-1] = powe2_n\nfor i in reversed(list(range(n-1))):\n    powe2_n *= 2\n    powe2_n %= mod\n    power[i] = powe2_n\nans = 0\nfrom collections import deque\nque = deque()\nque.append((0, -1))\n\nwhile que:\n    cur, prev = que.pop()\n    if len(G[cur]) == 1:\n        if prev == -1:\n            que.append((G[cur][0], cur))\n        continue\n\n    prob = 1\n    prob -= power[n-2]\n\n    for to in G[cur]:\n        if to == prev:\n            bubun_cnt = n-cnt[cur]\n        else:\n            que.append((to, cur))\n            bubun_cnt = cnt[to]\n        tmp = 1-power[bubun_cnt-1]\n        tmp *= power[n-1-bubun_cnt-1]\n        prob -= tmp\n    prob %= mod\n    ans += power[0]*prob\n    ans %= mod\n\nprint(ans)\n\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, readline().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nparent = [0] * (N + 1)\norder = []\nstack = [1]\nwhile stack:\n    x = stack.pop()\n    order.append(x)  # \u884c\u304d\u304c\u3051\u9806\u63a2\u7d22\u30ea\u30b9\u30c8\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x  # \u89aa\u30ce\u30fc\u30c9\u3092\u8a18\u9332\n        stack.append(y)\n\nMOD = 10**9 + 7\nhalf = pow(2, MOD - 2, MOD)\npower_inv = [1] * (N + 1)\nsize = [1] * (N + 1)\nfor i, v in enumerate(order[::-1], 1):\n    p = parent[v]\n    x = size[v]  # v\u306e\u5b50\u5b6b\u30ce\u30fc\u30c9\u6570\uff08\u81ea\u5206\u3082\u542b\u3080\uff09\u3092\u3068\u308b\n    size[p] += x  # \u89aa\u306b\u30ce\u30fc\u30c9\u6570\u3092\u52a0\u7b97\n    power_inv[i] = power_inv[i - 1] * half % MOD  # [1, 1/2, 1/4, ...]\n\nans = sum((1 - power_inv[i] - power_inv[N - i] + power_inv[N]) % MOD for i in size[2:])  # \u89e3\u6cd51\u306e\u78ba\u7387\u5f0f\uff1a\u8fbai\u304cS\u306b\u542b\u307e\u308c\u308b\u305f\u3081\u306e\u5fc5\u8981\u5341\u5206\u6761\u4ef6\nans += (1 - power_inv[N]) - N * power_inv[1]  # + \u300c(\u7a7a\u30b0\u30e9\u30d5\u3067\u306a\u3044\u300d - N/2 \nans %= MOD\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: list(map(int, readline().split()))\nnl = lambda: list(map(int, readline().split()))\n\n\nn = ni()\nG = [list() for _ in range(n)]\nfor _ in range(n-1):\n  a, b = nm()\n  a -= 1; b -= 1\n  G[a].append(b)\n  G[b].append(a)\n  \n  \nmod = 10**9 + 7\ndub = [1]*(n+1)\nfor i in range(n):\n  dub[i+1] = dub[i] * 2\n  if dub[i+1] > mod:\n    dub[i+1] -= mod\n    \nsize = [1]*n\ndef dfs_depandsize(tree,v,p):\n    for x in tree[v]:\n        if x == p:\n            continue\n        size[v] += dfs_depandsize(tree,x,v)\n    return size[v]\ndfs_depandsize(G, 0, -1)\nans = 0\nfor v in range(n):\n  c = 0\n  res = 1\n  for x in G[v]:\n    if size[x] < size[v]:\n      c += size[x]\n      res += dub[size[x]] - 1\n  res += dub[n-1-c] - 1\n  res %= mod\n  ans = (ans + dub[n-1] - res) % mod\nprint((ans * pow(dub[n], mod-2, mod) % mod))\n", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef main():\n    MOD = 1000000007\n    N, *AB = list(map(int, read().split()))\n    G = [[] for _ in range(N)]\n    for a, b in zip(AB[::2], AB[1::2]):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    stack = deque([0])\n    order = []\n    prev = [0] * N\n    prev[0] = -1\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        for nv in G[v]:\n            if nv != prev[v]:\n                stack.append(nv)\n                prev[nv] = v\n\n    pow2 = [0] * (N + 1)\n    pow2[0] = 1\n    for i in range(N):\n        pow2[i + 1] = pow2[i] * 2 % MOD\n\n    nodes = [1] * N\n    numer = 0\n\n    for v in reversed(order):\n        if prev[v] != -1:\n            nodes[prev[v]] += nodes[v]\n        numer = (numer + pow2[N - 1] - 1 - (pow2[N - nodes[v]] - 1)) % MOD\n        for nv in G[v]:\n            if nv != prev[v]:\n                numer = (numer - (pow2[nodes[nv]] - 1)) % MOD\n\n    denom = pow2[N]\n    ans = (numer * pow(denom, MOD - 2, MOD)) % MOD\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(2 * 10 ** 5 + 10)\n\nmod = 10 ** 9 + 7\n\nN, *AB = map(int, open(0).read().split())\n\nE = [[] for _ in range(N)]\nfor i, (a, b) in enumerate(zip(*[iter(AB)] * 2)):\n    E[a - 1].append((b - 1, i))\n    E[b - 1].append((a - 1, i))\n\nX = [0] * N\n\ndef dfs(u, p):\n    res = 1\n    for v, c in E[u]:\n        if p != c:\n            res += dfs(v, c)\n    X[p] = res\n    return res\n\ndfs(0, -1)\n\nI = [1] * (N + 1)\ninv = pow(2, mod - 2, mod)\nfor i in range(N):\n    I[i + 1] = I[i] * inv % mod\n\nans = - inv * N - I[N] + 1 + sum((1 - I[x]) * (1 - I[N - x]) for x in X)\nans %= mod\n\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, readline().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nparent = [0] * (N + 1)\norder = []\nstack = [1]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nMOD = 10**9 + 7\nhalf = pow(2, MOD - 2, MOD)\npower_inv = [1] * (N + 1)\nsize = [1] * (N + 1)\nfor i, v in enumerate(order[::-1], 1):\n    p = parent[v]\n    x = size[v]\n    size[p] += x\n    power_inv[i] = power_inv[i - 1] * half % MOD\n\nans = sum((1 - power_inv[i] - power_inv[N - i] + power_inv[N]) % MOD for i in size[2:])\nans -= N * power_inv[1] + power_inv[N] - 1\nans %= MOD\n\nprint(ans)"]
["s = input()\nres = eval(s)\nn = len(s)\nfor i in range(-1, n):\n    if i == -1 or s[i] == '*':\n        for j in range(i + 1, n + 1):\n            if j == n or s[j] == '*':\n                new_s = s[0:i + 1] + \"(\" + s[i + 1:j] + \")\" + s[j:n]\n                res = max(res, eval(new_s))\nprint(res)\n", "# -*- coding: utf-8 -*-\nfrom collections import deque\n\ns = input()\nn = len(s)\n\nans = eval(s)\n\nfor i in range(n):\n    if s[i] == '*':\n        _s = '(' + s[:i] + ')' + s[i:]\n        ans = max(ans, eval(_s))\n        _s = s[:i + 1] + '(' + s[i + 1:] + ')'\n        ans = max(ans, eval(_s))\n        for j in range(i):\n            if s[j] == '*':\n                _s = s[:j + 1] + '(' + s[j + 1:i] + ')' + s[i:]\n                ans = max(ans, eval(_s))\n        \nprint(ans)", "from heapq import heapify, heappush, heappop\nfrom collections import Counter, defaultdict, deque, OrderedDict\nfrom sys import setrecursionlimit, maxsize\nfrom bisect import bisect_left, bisect, insort_left, insort\nfrom math import ceil, log, factorial, hypot, pi\nfrom fractions import gcd\nfrom copy import deepcopy\nfrom functools import reduce\nfrom operator import mul\nfrom itertools import product, permutations, combinations, accumulate, cycle\nfrom string import ascii_uppercase, ascii_lowercase, ascii_letters, digits, hexdigits, octdigits\n\nprod = lambda l: reduce(mul, l)\nprodmod = lambda l, mod: reduce(lambda x, y: mul(x,y)%mod, l)\n\ndef read_list(t): return [t(x) for x in input().split()]\ndef read_line(t): return t(input())\ndef read_lines(t, N): return [t(input()) for _ in range(N)]\n\nexp = read_line(str)\nlen_exp = len(exp)\nans = eval(exp)\nmul_p = [i for i, s in enumerate(exp) if s == '*']\nmul_p = [-1] + mul_p + [len(exp)]\nfor i1, i2 in combinations(mul_p, 2):\n#    print(exp[:i1+1], exp[i1+1:i2], exp[i2:])\n    ans = max(ans, eval('{}({}){}'.format(exp[:i1+1], exp[i1+1:i2], exp[i2:])))\nprint(ans)\n        \n\n\n\n    \n", "def __starting_point():\n    s = input()\n    pos = [-1]\n    for i, x in enumerate(s):\n        if x == '*':\n            pos.append(i)\n\n    pos.append(len(s))\n    max_v = 0\n\n    for i in range(len(pos) - 1):\n        for j in range(i + 1, len(pos)):\n            a = pos[i] + 1\n            b = pos[j]\n            ns = s[:a] + '(' + s[a : b] + ')' + s[b:]\n            e = eval(ns)\n            if e > max_v:\n                max_v = e\n\n    print(max_v)\n__starting_point()", "s = input()\nma = eval(s)\nfor i in range(len(s)):\n    if s[i] == '*':\n        s1 = s[:i]\n        s2 = s[i - len(s) + 1:]\n        s3 = '(' + s1 + ')*' + s2\n        ma = max(ma, eval(s3))\n        s3 = s1 + '*(' + s2 + ')'\n        ma = max(ma, eval(s3))\n        for j in range(i):\n            if s[j] == '*':\n                s1 = s[:j]\n                s3 = s[j + 1:i-len(s)]\n                s4 = (s1 + '*(' + s3 + ')*' + s2)\n                ma = max(ma, eval(s4))\nprint(ma)\n", "s = input()\ns = \"0+1*\" + s + \"*1+0\"\nn = len(s)\nans = eval(s)\np = []\nfor i in range(0, n):\n    if s[i] == '*':\n        p.append(i)\nfor i in p:\n    for j in p:\n        if i >= j:\n            continue\n        if s[i] == '*' and s[j] == '*':\n            t = s[:i+1] + \"(\" + s[i+1:j] + \")\" + s[j:]\n            res = eval(t)\n            if res > ans:\n                ans = res\nprint(ans)", "s = input()\nans = eval(s)\nfor i in range(len(s)-1):\n    if s[i] == \"*\":\n        k = \"(\" + s[0:i] + \")\" + s[i:len(s)]\n        t = eval(k)\n        if t > ans:\n            ans = t\n        k = s[0:i+1] + \"(\" + s[i+1:len(s)] + \")\"\n        t = eval(k)\n        if t > ans:\n            ans = t\n        for j in range(i+2, len(s)):\n            if s[j] == \"*\":\n                k = s[0:i+1] + \"(\" + s[i+1:j] + \")\" + s[j:len(s)]\n                t = eval(k)\n                if t > ans:\n                    ans = t\nprint(ans)", "qw = input()\ng = ['*']\ns = [1]\nfor i in range(len(qw)):\n    if i % 2 == 0:\n        s.append(int(qw[i]))\n    else:\n        g.append(qw[i])\nc = 0\ng.append('*')\ns.append(1)\nfor i in range(len(g)):\n    if g[i] == '*':\n        for j in range(i + 1, len(g)):\n            if g[j] == '*':\n                a = 0\n                b = s[0]\n                for k in range(i):\n                    if g[k] == '*':\n                        b *= s[k + 1]\n                    else:\n                        a += b\n                        b = s[k + 1]\n                v = a\n                w = b\n                a = 0\n                b = s[i + 1]\n                for k in range(i + 1, j):\n                    if g[k] == '*':\n                        b *= s[k + 1]\n                    else:\n                        a += b\n                        b = s[k + 1]\n                b = w * (a + b)\n                a = v\n                for k in range(j, len(g)):\n                    if g[k] == '*':\n                        b *= s[k + 1]\n                    else:\n                        a += b\n                        b = s[k + 1]\n                c = max(c, a + b)\nprint(c)", "s = input()\n\nprocessed = True\ni1 = 1\nwhile i1 < len(s):\n    while i1 < len(s):\n        if s[i1] == '+':\n            break\n        i1 += 2\n    if i1 >= len(s):\n        break\n    i2 = i1 + 2\n    while i2 < len(s):\n        if s[i2] == '*':\n            break\n        i2 += 2\n\n    i2 = i2 - 2\n    if i2 - i1 > 2:\n        s1 = eval(s[i1+1: i2])\n        s = s[:i1+1] + str(s1) + s[i2:]\n        i1 += 4\n    else:\n        i1 += 2\n\nmults = [-1]\nfor i in range(len(s)):\n    if s[i] == '*':\n        mults.append(i)\n\nmults.append(len(s))\nmax = 0\nfor i in range(len(mults)):\n    for j in range(i+1, len(mults)):\n        news =  s[:mults[i]+1] + '(' + s[mults[i]+1:mults[j]] + ')' +s[mults[j]:]\n        v = eval(news)\n        if v > max:\n            max = v\nprint(max)\n", "s = '1*' + input() + '*1'\n\nmuls = [1]\nfor i in range(3, len(s) - 2, 2):\n    if s[i] == '*' and (s[i-2] == '+' or s[i+2] == '+'):\n        muls.append(i)\nmuls.append(len(s) - 2)\n\nm = eval(s)\nfor i in range(len(muls)):\n    for j in range(i + 1, len(muls)):\n        a, b = muls[i], muls[j]\n        new_s = s[:a+1] + '(' + s[a+1:b] + ')' + s[b:]\n        m = max(m, eval(new_s))\n\nprint(m)\n", "s = input()\nmult_list = []\nfor i in range(len(s)):\n    if s[i] == '*':\n        mult_list.append(i)\nbest = eval(s)\nfor k in mult_list:\n    t = '('+s[:k]+')'+s[k:]\n    q = eval(t)\n    if q > best:\n        best = q\n    t = s[:(k+1)]+'('+s[(k+1):]+')'\n    q = eval(t)\n    if q > best:\n        best = q\n    for j in mult_list:\n        if j >= k:\n            continue\n        if j < k:\n            t = s[:(j+1)]+'('+s[(j+1):k]+')'+s[k:]\n            q = eval(t)\n            if q > best:\n                best = q\n\nprint(best)\n", "s = input()\n\nmults = [-1]\nfor i in range(len(s)):\n    if s[i] == '*':\n        mults.append(i)\n\nmults.append(len(s))\nmax = 0\nfor i in range(len(mults)):\n    for j in range(i+1, len(mults)):\n        news =  s[:mults[i]+1] + '(' + s[mults[i]+1:mults[j]] + ')' +s[mults[j]:]\n        v = eval(news)\n        if v > max:\n            max = v\nprint(max)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ns = input()\nlength = len(s)\nans = eval(s)\n\nfor j in range(0,length,2):\n    if j == 0 or s[j-1] == '*':\n        for k in range(j+3,length+1,2):\n            if k == length or s[k] == '*':\n                tmp = eval(s[:j] + str(eval(s[j:k])) + s[k:])\n                ans = ans if tmp < ans else tmp\nprint(ans)\n", "s=input()\nd=list(s.split('*'))\nif len(s)>1:\n last=0;\n po=[]\n ki=[]\n for i in range(len(d)):\n     po+=[last]\n     ki+=[len(d[i])+last]\n     last+=len(d[i])+1\n ans=[]\n for a in po:\n     for b in ki:\n        if a>b-2: continue \n        x=s[:a]+'('+s[a:b]+')'+s[b:]\n        ans+=[eval(x)]\n print(max(ans))\nelse: print(s)", "s = input()\nres = eval(s)\nn = len(s)\nfor i in range(-1, n):\n    if i == -1 or s[i] == '*':\n        for j in range(i + 1, n + 1):\n            if j == n or s[j] == '*':\n                new_s = s[0:i + 1] + \"(\" + s[i + 1:j] + \")\" + s[j:n]\n                res = max(res, eval(new_s))\nprint(res)", "s = input()\na = [0]\nfor i in range(len(s)):\n    if s[i] == '*':\n        a.append(i+1)\na.append(len(s)+1)\nmaxRes = eval(s)\n#print(a)\nfor i in a:\n    for j in a:\n        if j > i:\n            maxRes = max(maxRes, eval(s[:i]+'('+s[i:j-1]+')'+s[j-1:]))\n            #print(s[:i]+'('+s[i:j-1]+')'+s[j-1:])\nprint(maxRes)\n", "s=input()\nd=list(s.split('*'))\nlast=0;\npo=[]\nki=[]\nfor i in range(len(d)):\n    po+=[last]\n    ki+=[len(d[i])+last]\n    last+=len(d[i])+1\nans=[eval(s)]\nfor a in po:\n    for b in ki:\n       if a>b-2: continue \n       x=s[:a]+'('+s[a:b]+')'+s[b:]\n       ans+=[eval(x)]\nprint(max(ans))\n", "e = '1*' + input() + '*1'\nl = len(e)\na = 0\nfor i in range(2, l, 2):\n    if (e[i - 1] == '*'):\n        for j in range(i + 1, l, 2):\n            if e[j] == '*':\n                a = max(a, eval(e[:i] + '(' + e[i:j] + ')' + e[j:]))\nprint(a)", "s = input()\nt = len(s)\nres = eval(s)\nfor i in range(0, t):\n    if i != 0 and s[i - 1] != '*':\n        continue;\n    a = s[:i]+'('+s[i:]\n    for j in range(i, t + 2):\n        if j != t + 1 and a[j] != '*':\n            continue;\n        if j == t + 1:\n            b = a[:j] + ')'\n        else:\n            b = a[:j] + ')' + a[j:]\n        res = max(res, eval(b))\nprint(res)", "str = '1*' + input() + '*1'\nl = len(str)\nans = 0\nfor i in range(2, l, 2):\n    if (str[i - 1] == '*'):\n        for j in range(i + 1, l, 2):\n            if str[j] == '*':\n                ans = max(ans, eval(str[:i] + '(' + str[i:j] + ')' + str[j:]))\nprint(ans)", "input_str = input()\nstr = '1*' + input_str + '*1'\nstr_len = len(str)\nans = 0\n \nfor i in range(2, str_len, 2):\n    if (str[i - 1] == '*'):\n        for j in range(i + 1, str_len, 2):\n            if str[j] == '*':\n                ans = max(ans, eval(str[:i] + '(' + str[i:j] + ')' + str[j:]))\n \nprint(ans)", "s = input()\ns = \"0+1*\"+s+\"*1+0\"\nanswer = eval(s)\nn = len(s)\np = []\nfor i in range(0, n):\n\tif s[i] == '*':\n\t\tp.append(i)\nfor i in p:\n\tfor j in p:\n\t\tif i >= j:\n\t\t\tcontinue;\n\t\ttest = eval(s[:i+1]+\"(\"+s[i+1:j]+\")\"+s[j:])\n\t\tif test > answer:\n\t\t\tanswer = test\nprint(answer)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\nimport operator as op\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\n\n\n# BFS is probably overkill, as one can reach it by brute force (below)\ndef bfs(l, sgn, r, best,par=0):\n    if len(r) ==1:\n        # if par==1:\n        #     return max(best, sgn(l,r[0]))\n        return max(best, sgn(l,r[0]))\n    if sng == op.add:\n        if par==0:\n            return max(bfs(op.add(l,r[1]),r[2],r[3:],best,par),\n                       bfs(op.add(l,r[1]),r[2],r[3:],best,par+1))\n        if r[1] == op.add:\n            return bfs(op.add(l,r[1]),r[2],r[3:],best)\n        else:\n            return max()\ndef run_bfs(s):\n    x = list(s)\n    lst = [int(v) if i%2==0 else op.add if v=='+' else op.mul for i,v in enumerate(x)]\n    # d = [int(i) for i in x[::2]]\n    # g = x[1::2]\n    b = bfs(lst[0], lst[1], lst[2:], 0)\n\n\ndef run2(s):\n    best = eval(s)\n    n = len(s)\n    if n<=3:\n        print(eval(s))\n        return\n    x = list(s)\n    for i in range(1,n-2,2):\n        if s[i] == '+' and (i==1 or s[i-2]=='*'):\n            l=i-1\n            for j in range(i+2,n,2):\n                if s[j] == '*':\n                    exp = s[:l]+ '(' + s[l:j]+')'+s[j:]\n                    best = max(best, eval(exp))\n            best = max(best, eval(s[:l]+ '(' + s[l:]+')'))\n    print(best)\n\ndef run3(s):\n    best = eval(s)\n    n = len(s)\n    if n<=3:\n        print(eval(s))\n        return\n    m = [i for i,v in enumerate(s) if v=='*']\n    l = [0,]\n    r = [n,]\n    for x in m:\n        if x<n-2 and s[x+2]=='+':\n            l.append(x+1)\n        if x>2 and s[x-2]=='+':\n            r.append(x)\n    for v in l:\n        for w in r:\n            if v>=w: continue\n            exp = s[:v]+ '(' + s[v:w]+')'+s[w:]\n            best = max(best, eval(exp))\n    print(best)\n\ndef run(s):\n    best = eval(s)\n    n = len(s)\n    if n<=3:\n        print(best)\n        return\n    for i in range(1,n-1,2):\n        if s[i] == '+' and (i==1 or s[i-2]=='*'):\n            for j in range(i+2,n,2):\n                if s[j] == '*':\n                    best = max(best, eval(s[:i-1]+ '(' + s[i-1:j]+')'+s[j:]))\n            best = max(best, eval(s[:i-1]+ '(' + s[i-1:]+')'))\n    print(best)\n\n\ndef main(info=0):\n    s = input()\n    run(s)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
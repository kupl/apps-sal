["# 10\n# + 8\n# + 9\n# + 11\n# + 6\n# + 1\n# ? 3\n# - 8\n# ? 3\n# ? 8\n# ? 11\n\nMAX_BIT = 30\n\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.leftCnt = 0\n        self.rightCnt = 0\n    \n    def AddRight(self):\n        if self.right == None:\n            self.right = Node()\n            self.rightCnt = 1\n        else:\n            self.rightCnt += 1\n    \n    def AddLeft(self):\n        if self.left == None:\n            self.left = Node()\n            self.leftCnt = 1\n        else:\n            self.leftCnt += 1\n\n    def RemRight(self):\n        self.rightCnt -= 1\n    \n    def RemLeft(self):\n        self.leftCnt -= 1\n\n    def Left(self):\n        return self.left != None and self.leftCnt > 0\n\n    def Right(self):\n        return self.right != None and self.rightCnt > 0\n\ndef insert(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #insert to right\n        u.AddRight()\n        insert(u.right, num, dig-1)\n    else:\n        u.AddLeft()\n        insert(u.left, num, dig-1)\n\ndef remove(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #remove right\n        u.RemRight()\n        remove(u.right, num, dig-1)\n    else:\n        u.RemLeft()\n        remove(u.left, num, dig-1)\n\ndef cal(u, num, dig=MAX_BIT):\n    if dig < 0 or u == None:\n        return 0\n    \n    bit = (num>>dig)&1\n    if bit > 0: #try to go to left first\n        if u.Left(): #if valid\n            return (1<<dig) + cal(u.left, num, dig-1)\n        elif u.Right():\n            return cal(u.right, num, dig-1)\n    else: #try to go to right first\n        if u.Right():\n            return (1<<dig) + cal(u.right, num, dig-1)\n        elif u.Left():\n            return cal(u.left, num, dig-1)\n    return 0\n\ndef main():\n    root = Node()\n    insert(root, 0)\n\n    n = int(input())\n    for i in range(n):\n        tmp = input().split()\n        num = int(tmp[1])\n        if tmp[0] == \"+\":\n            insert(root, num)\n        elif tmp[0] == \"-\":\n            remove(root, num)\n        else:\n            print(cal(root, num))\n\nmain()", "import collections\n\nmax_bits = 30\n\n#root = collections.Counter()\n#vals = collections.defaultdict(int)\n\nclass BNode:\n    def __init__(self, ct=0, zero=None, one=None):\n        self.ct = ct\n        self.zero = None\n        self.one = None\n    def __str__(self):\n        return ' '.join([str(self.ct), str(self.zero), str(self.one)])\n\nroot = BNode()\n\ndef bits(x):\n    bit = 2**(max_bits-1)\n    for i in range(max_bits):\n        if x & bit:\n            yield 1\n        else:\n            yield 0\n        bit >>= 1\n\n\ndef add(x, root):\n    root.ct += 1\n    for b in bits(x):\n        if b:\n            if not root.one:\n                root.one = BNode()\n            root = root.one\n        else:\n            if not root.zero:\n                root.zero = BNode()\n            root = root.zero\n        root.ct += 1\n\n\ndef sub(x, root):\n    root.ct -= 1\n    for b in bits(x):\n        if b:\n            if root.one.ct == 1:\n                root.one = None\n                break\n            root = root.one\n        else:\n            if root.zero.ct == 1:\n                root.zero = None\n                break\n            root = root.zero\n        root.ct -= 1\n\ndef question(x, root):\n    y = 0\n    for b in bits(x):\n        if b:\n            if root.zero and root.zero.ct > 0:\n                root = root.zero\n                y = y*2\n            else:\n                root = root.one\n                y = y*2 + 1\n        else:\n            if root.one and root.one.ct > 0:\n                root = root.one\n                y = y*2 + 1\n            else:\n                root = root.zero\n                y = y*2\n    return x ^ y\n\nadd(0,root)\n\nq = int(input())\n\noutput = []\n\nfor i in range(q):\n    qtype, x = input().split()\n    x = int(x)\n    if qtype == '+':\n        add(x, root)\n    if qtype == '-':\n        sub(x, root)\n    if qtype == '?':\n        output.append(str(question(x,root)))\n\nprint(\"\\n\".join(output))", "MAX_BIT = 34\nans=[]\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.leftCnt = 0\n        self.rightCnt = 0\n    \n    def AddRight(self):\n        if self.right == None:\n            self.right = Node()\n            self.rightCnt = 1\n        else:\n            self.rightCnt += 1\n    \n    def AddLeft(self):\n        if self.left == None:\n            self.left = Node()\n            self.leftCnt = 1\n        else:\n            self.leftCnt += 1\n\n    def RemRight(self):\n        self.rightCnt -= 1\n    \n    def RemLeft(self):\n        self.leftCnt -= 1\n\n    def Left(self):\n        return self.left != None and self.leftCnt > 0\n\n    def Right(self):\n        return self.right != None and self.rightCnt > 0\n\ndef insert(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #insert to right\n        u.AddRight()\n        insert(u.right, num, dig-1)\n    else:\n        u.AddLeft()\n        insert(u.left, num, dig-1)\n\ndef remove(u, num, dig=MAX_BIT):\n    if dig < 0:\n        return\n    \n    bit = (num>>dig)&1\n    if bit > 0: #remove right\n        u.RemRight()\n        remove(u.right, num, dig-1)\n    else:\n        u.RemLeft()\n        remove(u.left, num, dig-1)\n\ndef cal(u, num, dig=MAX_BIT):\n    if dig < 0 or u == None:\n        return 0\n    \n    bit = (num>>dig)&1\n    if bit > 0: #try to go to left first\n        if u.Left(): #if valid\n            return (1<<dig) + cal(u.left, num, dig-1)\n        elif u.Right():\n            return cal(u.right, num, dig-1)\n    else: #try to go to right first\n        if u.Right():\n            return (1<<dig) + cal(u.right, num, dig-1)\n        elif u.Left():\n            return cal(u.left, num, dig-1)\n    return 0\n\nroot = Node()\ninsert(root, 0)\n\nn = int(input())\nfor i in range(n):\n    tmp = input().split()\n    num = int(tmp[1])\n    if tmp[0] == \"+\":\n        insert(root, num)\n    elif tmp[0] == \"-\":\n        remove(root, num)\n    else:\n        ans.append(cal(root, num))\nprint('\\n'.join(map(str, ans)))\n", "#!/usr/bin/env pypy3\nimport sys\n\n\nclass BitTreeNode(object):\n    __slots__ = [\"left\", \"right\", \"count\"]\n    def __init__(self, cnt):\n        self.left = None\n        self.right = None\n        self.count = cnt\n\nclass BitTree(object):\n    \n    def __init__(self):\n        self.root = BitTreeNode(0)\n        self.add(reversed(get_bits(0)))\n\n    def add(self, bits):\n        node = self.root\n        node.count += 1\n        for bit in bits:\n            if bit:\n                if not node.right:\n                    node.right = BitTreeNode(1)\n                else:\n                    node.right.count += 1\n                node = node.right\n            else:\n                if not node.left:\n                    node.left = BitTreeNode(1)\n                else:\n                    node.left.count += 1\n                node = node.left\n\n    def remove(self, bits):\n        node = self.root\n        node.count -= 1\n        for bit in bits:\n            if bit == 0:\n                node.left.count -= 1\n                if node.left.count == 0:\n                    node.left = None\n                    return\n                node = node.left\n            else:\n                node.right.count -= 1\n                if node.right.count == 0:\n                    node.right = None\n                    return\n                node = node.right\n             \n    def examine_xor(self, bits):\n        best = 0\n        node = self.root\n        for i, bit in reversed(list(enumerate(bits))):\n            assert node.count > 0\n            if bit == 0:\n                if node.right is not None:\n                    best += 1 << i\n                    node = node.right\n                else:\n                    node = node.left\n            else:\n                if node.left is not None:\n                    best += 1 << i\n                    node = node.left\n                else:\n                    node = node.right\n        return best\n\n    @classmethod\n    def print_tree(cls, node, indent):\n        print(\" \" * indent + \"+\", node.count)\n        if node.right:\n            cls.print_tree(node.right, indent + 2)\n        if node.left:\n            cls.print_tree(node.left, indent + 2)\n\n\ndef read_query():\n    qType, number = next(sys.stdin).split()\n    return qType, int(number)\n\n\ndef get_bits(number):\n    ans = []\n    for _ in range(32):\n        ans.append(number % 2)\n        number //= 2\n    return ans\n\n\ndef solve_and_print(q):\n    tree = BitTree()\n    for _ in range(q):\n        qType, number = read_query()\n        #print()\n        #print(qType, number)\n        if qType == \"+\":\n            tree.add(reversed(get_bits(number)))\n            #tree.print_tree(tree.root, 0)\n        elif qType == \"-\":\n            tree.remove(reversed(get_bits(number)))\n            #tree.print_tree(tree.root, 0)\n        elif qType == \"?\":\n            print(tree.examine_xor(get_bits(number)))\n\n\ndef __starting_point():\n    q = int(next(sys.stdin))\n    solve_and_print(q)\n\n__starting_point()", "class D: u, v, n = None, None, 0\np = [1 << 30 - j for j in range(31)]\ndef sub(d, y):\n    for j in p:\n        d = d.u if y & j else d.v\n        d.n -= 1\ndef add(d, y):\n    for j in p:\n        if not d.u: d.u, d.v = D(), D()\n        d = d.u if y & j else d.v\n        d.n += 1\ndef get(d, y):\n    s = 0\n    for j in p:\n        if y & j:\n            if d.v.n:\n                d = d.v\n                s += j\n            else: d = d.u\n        else:\n            if d.u.n:\n                d = d.u\n                s += j\n            else: d = d.v\n    print(s)\nd = D()\nadd(d, 0)\nfor i in range(int(input())):\n    k, x = input().split()\n    y = int(x)\n    if k == '-': sub(d, y)\n    elif k == '+': add(d, y)\n    else: get(d, y)", "trie = [[-1, -1]]\ncounts = [0]\ntrie_size = 1\n\ndef insert(x):\n    nonlocal trie, counts, trie_size\n\n    node = 0\n    out = []\n    for i in range(30, -1, -1):\n        b = 0 if (x & (1 << i)) == 0 else 1\n        out.append(str(b))\n        if trie[node][b] == -1:\n            trie[node][b] = trie_size\n            trie.append([-1, -1])\n            counts.append(0)\n            trie_size += 1\n\n        counts[node] += 1\n        node = trie[node][b]\n\n    counts[node] += 1\n    # print('+', ''.join(out))\n\ndef remove(x):\n    nonlocal trie, counts, trie_size\n    node = 0\n    for i in range(30, -1, -1):\n        counts[node] -= 1\n\n        b = 0 if (x & (1 << i)) == 0 else 1\n        node = trie[node][b]\n\n    counts[node] -= 1\n\ndef query(x):\n    nonlocal trie, counts, trie_size\n    node = 0\n    ans = 0\n\n    out = []\n    path = []\n    for i in range(30, -1, -1):\n        b = 0 if (x & (1 << i)) == 0 else 1\n        out.append(str(b))\n\n        if trie[node][1 - b] == -1 or counts[trie[node][1 - b]] == 0:\n            node = trie[node][b]\n            ans |= (1 << i) * b\n            path.append(str(b))\n        else:\n            node = trie[node][1 - b]\n            ans |= (1 << i) * (1 - b)\n            path.append(str(1-b))\n\n    # print(''.join(out))\n    # print('path', ''.join(path))\n    return ans ^ x\n\ndef main():\n    q = int(input())\n    insert(0)\n    for _ in range(q):\n        # print(trie)\n        # print(counts)\n\n        a, b = input().split()\n        b = int(b)\n        if a == '+':\n            insert(b)\n        elif a == '-':\n            remove(b)\n        else:\n            print(query(b))\n\nmain()\n", "class Node:\n  def __init__(self, value):\n    self.parent = None\n    self.val = value\n    self.zero = None\n    self.one = None\n    self.marker = 0\n    self.max_len = 0\n    \nroot = Node(-1)\n\ndef add(n):\n  #print(\"Add\", n)\n  \n  curr_node = root\n  bitstr = bin(n)[2:].zfill(32)   # 32-bit string\n\n  for bit in bitstr:\n    if bit == \"1\":\n      if curr_node.one == None:\n        curr_node.one = Node(1)\n        curr_node.one.parent = curr_node\n      curr_node = curr_node.one\n    else:\n      if curr_node.zero == None:\n        curr_node.zero = Node(0)\n        curr_node.zero.parent = curr_node\n      curr_node = curr_node.zero\n      \n  curr_node.marker += 1\n  \ndef remove(n):\n  #print(\"Remove\", n)\n  \n  curr_node = root\n  bitstr = bin(n)[2:].zfill(32)\n  for bit in bitstr:\n    if bit == \"1\":\n      curr_node = curr_node.one\n    else:\n      curr_node = curr_node.zero\n\n  curr_node.marker -= 1\n  if curr_node.marker == 0:\n    while curr_node.parent != None:\n      if curr_node.one is None and curr_node.zero is None:\n        if curr_node.val == 1:\n          curr_node.parent.one = None\n        else:\n          curr_node.parent.zero = None\n      curr_node = curr_node.parent\n        \n  \ndef query(n):\n  #print(\"Query\", n)\n  \n  bitstr = bin(n)[2:].zfill(32)\n  curr_node = root\n  result = []\n  \n  for bit in bitstr:\n    \n    b = int(bit)\n    looking_for = 1-b\n    \n    zero_present = curr_node.zero != None\n    one_present = curr_node.one != None\n    \n    if looking_for == 0 and zero_present:\n      curr_node = curr_node.zero\n      result.append(\"1\")\n      \n    elif looking_for == 1 and one_present:\n      curr_node = curr_node.one\n      result.append(\"1\")\n      \n    elif looking_for == 0 and one_present:\n      curr_node = curr_node.one\n      result.append(\"0\")\n    else:\n      curr_node = curr_node.zero\n      result.append(\"0\")\n      \n  print(int(\"\".join(result), 2))\n  \n# Parse input\nnum_q = int(input())\nfor _ in range(num_q):\n  \n  expr = input()\n  symbol = expr[0]\n  num = int(expr[2:])\n  \n  add(0)    # 0 is always in the set\n  \n  if symbol == \"+\":\n    add(num)\n  elif symbol == \"-\":\n    remove(num)\n  elif symbol == \"?\":\n    query(num)", "def num_to_bitstring(n):\n  '''converts num to bitstring of length 30'''\n  b = bin(n)\n  assert b[:2] == \"0b\"\n  b = b[2:]\n  return \"0\" * (30 - len(b)) + b\n  \nclass Node:\n  def __init__(self, val = 0):\n    self.value = val #number of occurances\n    self.left = None\n    self.right = None\n  \n  def add(self):\n    self.value = self.value + 1\n\nclass Trie:\n  def __init__(self):\n    self.head = Node(1)\n    \n  def add(self, s):\n    current = self.head\n    for b in s:\n      if b == \"0\":\n        if current.left == None:\n          current.left = Node()\n          current = current.left\n        else:\n          current = current.left\n      elif b == \"1\":\n        if current.right == None:\n          current.right = Node()\n          current = current.right\n        else:\n          current = current.right\n    current.value = current.value + 1\n          \n  def subtract(self, s):\n    current = self.head\n    last_branch = None\n    #have a last valid, if after going to a leaf it turns out 1 -> 0, we need to trim a branch, so take last valid set either left or right to None\n    \n    for b in s:\n      if (current.left != None) and (current.right != None):\n        if b == \"0\":\n          last_branch = (current, \"0\")\n        elif b == \"1\":\n          last_branch = (current, \"1\")\n      if b == \"0\":\n        current = current.left\n      elif b == \"1\":\n        current = current.right\n        \n    current.value = current.value - 1\n    if current.value == 0:\n      if last_branch[1] == \"0\":\n        last_branch[0].left = None\n      elif last_branch[1] == \"1\":\n        last_branch[0].right = None\n    \n  def xor(self, s):\n    sum = 0\n    i = 29\n    current = self.head\n    for b in s:\n      if b == \"0\":\n        if current.right != None:\n          current = current.right\n          sum += 2 ** i\n        else:\n          current = current.left\n      else:\n        if current.left != None:\n          current = current.left\n          sum += 2 ** i\n        else:\n          current = current.right\n      i -= 1\n    return sum\n    \ndef main():\n  t = Trie()\n  s = num_to_bitstring(0)\n  t.add(s)\n  q = int(input())\n  for a0 in range(q):\n    query = input()\n    s = num_to_bitstring(int(query[2:]))\n    if query[0] == \"+\":\n      t.add(s)\n    elif query[0] == \"-\":\n      t.subtract(s)\n    elif query[0] == \"?\":\n      print(t.xor(s))\n      \nmain()\n  \n", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\n\n\ndef getBin(x):\n    num = [-1 for i in range(32)]\n    for i in range(1, 33):\n        num[-i] = x&1\n        x = x>>1\n    return num\n\nt = [-1, -1]\n\ndef add(x, trie, i):\n    if i == len(x): return\n    if trie[x[i]] == -1:\n        trie[x[i]] = [-1, -1]\n    add(x, trie[x[i]], i+1)\n\ndef query(x, trie, i, ans):\n    if i == len(x): return ans\n    \n    if x[i] == 1:\n        if trie[0] == -1:\n            return query(x, trie[1], i+1, ans<<1)\n        else:\n            return query(x, trie[0], i+1, (ans<<1)+1)\n    else:\n        if trie[1] == -1:\n            return query(x, trie[0], i+1, ans<<1)\n        else:\n            return query(x, trie[1], i+1, (ans<<1)+1)\n\ndef delete(x, trie, i):\n    if i == len(x): return\n    delete(x, trie[x[i]], i+1)\n    if trie[x[i]] == [-1, -1]:\n        trie[x[i]] = -1\n\n\nn = int(input())\nadd(getBin(0), t, 0)\nf = {0: 1}\n\nfor _ in range(n):\n    q, x = input().split()\n    x = int(x)\n    if q == '+':\n        if x in f: f[x] += 1\n        else:\n            f[x] = 1\n            add(getBin(x), t, 0)\n    elif q == '?':\n        print(query(getBin(x), t, 0, 0))\n    else:\n        if f[x] == 1:\n            del f[x]\n            delete(getBin(x), t, 0)\n        else: f[x] -= 1\n\n", "ii=lambda:int(input())\nkk=lambda:map(int, input().split())\nll=lambda:list(kk())\n\nclass Node:\n\t\"\"\"docstring for Node\"\"\"\n\tdef __init__(self, parent, edge):\n\t\tself.children = [None, None]\n\t\tself.count = 0\n\t\tself.parent = parent\n\t\tself.fin = False\n\t\tself.edge= edge\n\n\tdef next(self, pref):\n\t\treturn (pref, self.children[pref]) if self.children[pref] else (pref^1, self.children[pref^1])\n\tdef add(self, di):\n\t\tif not self.children[di]:\n\t\t\tself.children[di] = Node(self, di)\n\t\treturn self.children[di]\n\n\tdef end(self):\n\t\tself.count+=1\n\t\tself.fin=True\n\n\tdef remC(self, i):\n\t\tself.children[i]=None\n\t\tif self.children[i^1] is None:\n\t\t\tself.parent.remC(self.edge)\n\t\t\tdel self\n\n\tdef remV(self):\n\t\tself.count-=1\n\t\tif self.count==0:\n\t\t\tself.parent.remC(self.edge)\n\t\t\tdel self\n\ndef make(ite, node):\n\tfor v in ite: node = node.add(v)\n\tnode.end()\ndef remove(ite, node):\n\tfor v in ite: node = node.children[v]\n\tnode.remV()\ndef traverse(ite, node):\n\tres = 0\n\tfor v in ite:\n\t\ti,node= node.next(v^1)\n\t\tres = 2*res + (i^v)\n\treturn res\n\nroot = Node(None, -1)\nmake((0 for _ in range(31)), root)\nfor _ in range(ii()):\n\ts,i=input().split()\n\ti = int(i)\n\tite = (min(1, (2**x)&i) for x in range(30, -1, -1))\t\n\tif s == '+': make(ite, root)\n\telif s == '-': remove(ite, root)\n\telse: print(traverse(ite,root))", "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nQ = int(readline())\n\nD0 = set()\nD1 = set()\ngeta = 36\ndef tadd(x):\n    bx = [1 if s == '1' else 0 for s in (bin(x)[2:]).zfill(34)]\n    cur = 0\n    for i in range(34):\n        b = bx[i]\n        nw, dep = divmod(cur, geta)\n        if b == 1:\n            if cur in D1:\n                cur = ((nw<<1)+1) * geta + dep+1\n                continue\n            D1.add(cur)\n            cur = ((nw<<1)+1) * geta + dep+1\n            continue\n        else:\n            if cur in D0:\n                cur = (nw<<1)*geta + dep + 1\n                continue\n            \n            D0.add(cur)\n            cur = (nw<<1)*geta + dep + 1\n            continue\n\ndef trem(x):\n    cur = x*geta + 34\n    for i in range(34-1, -1, -1):\n        nw, dep = divmod(cur, geta)\n        if nw&1:\n            cur = (nw>>1)*geta + dep-1\n            D1.remove(cur)\n            if cur in D0:\n                break\n        else:\n            cur = (nw>>1)*geta + dep-1\n            D0.remove(cur)\n            if cur in D1:\n                break\n\ndef calc(x):\n    bx = [1 if s == '1' else 0 for s in (bin(x)[2:]).zfill(34)]\n    cur = 0\n    for i in range(34):\n        nw, dep = divmod(cur, geta)\n        if bx[i] == 0:\n            if cur in D1:\n                cur = ((nw<<1)+1)*geta + dep+1\n            else:\n                cur = (nw<<1)*geta + dep+1\n        else:\n            if cur in D0:\n                cur = (nw<<1)*geta + dep+1\n            else:\n                cur = ((nw<<1)+1)*geta + dep+1\n    return (cur//geta)^x\n\nC = Counter()\nAns = [] \ntadd(0)\nfor _ in range(Q):\n    t, x = readline().split()\n    x = int(x)\n    if t == '+':\n        C[x] += 1\n        if C[x] == 1:\n            tadd(x)\n    elif t == '-':\n        C[x] -= 1\n        if C[x] == 0:\n            trem(x)\n    else:\n        Ans.append(calc(x))\n\nprint('\\n'.join(map(str, Ans)))", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/7 22:34\n\n\"\"\"\n\n\nclass Node:\n    def __init__(self):\n        self.val = None\n        self.left = None\n        self.right = None\n\nN = 32\ntree = Node()\n\n\ndef binval(val):\n    u = bin(val)[2:]\n    return '0' * (N - len(u)) + u\n\n\ndef insert(val):\n    u = binval(val)\n    t = tree\n    for v in u:\n        if v == '1':\n            if not t.left:\n                t.left = Node()\n            t = t.left\n        else:\n            if not t.right:\n                t.right = Node()\n            t = t.right\n    t.val = val\n\n\ndef remove(val):\n    u = binval(val)\n    t = tree\n    q = []\n    for v in u:\n        nt = t.left if v == '1' else t.right\n        q.append((t, v))\n        t = nt\n\n    for t, v in reversed(q):\n        ended = t.left and t.right\n        if v == '1':\n            t.left = None\n        else:\n            t.right = None\n        if ended:\n            break\n\n\ndef search(val):\n    u = binval(((1 << N) - 1) ^ val)\n    x = ''\n    t = tree\n    for v in u:\n        if v == '1':\n            if t.left:\n                x += '1'\n                t = t.left\n            else:\n                x += '0'\n                t = t.right\n        else:\n            if t.right:\n                x += '0'\n                t = t.right\n            else:\n                x += '1'\n                t = t.left\n    return int(x, 2) ^ val\n\n\ninsert(0)\nq = int(input())\nwc = collections.defaultdict(int)\nbwc = collections.defaultdict(set)\nans = []\nfor qi in range(q):\n    a, b = input().split()\n    v = int(b)\n    if a == '+':\n        wc[v] += 1\n        if wc[v] == 1:\n            insert(v)\n    elif a == '-':\n        wc[v] -= 1\n        if wc[v] == 0:\n            remove(v)\n    else:\n        ans.append(search(v))\nprint('\\n'.join(map(str, ans)))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\nclass Trie:\n    def __init__(self):\n        self.cnt = 0\n        self.next = [None] * 2\n\ntrie = Trie()\n\ndef add(x):\n    mask = 1<<32\n    cur = trie\n    while mask:\n        if mask & x:\n            if not cur.next[1]:\n                cur.next[1] = Trie()\n            cur = cur.next[1]\n        else:\n            if not cur.next[0]:\n                cur.next[0] = Trie()\n            cur = cur.next[0]\n        cur.cnt += 1\n        mask >>= 1\n\ndef remove(x):\n    mask = 1<<32\n    cur = trie\n    while mask:\n        if mask & x:\n            cur = cur.next[1]\n        else:\n            cur = cur.next[0]\n        cur.cnt -= 1\n        mask >>= 1\n\ndef query(x):\n    mask = 1<<32\n    cur = trie\n    ret = 0\n    while mask:\n        if mask & x:\n            if cur.next[0] and cur.next[0].cnt > 0:\n                cur = cur.next[0]\n                ret += mask\n            else:\n                cur = cur.next[1]\n        else:\n            if cur.next[1] and cur.next[1].cnt > 0:\n                cur = cur.next[1]\n                ret += mask\n            else:\n                cur = cur.next[0]\n        mask >>= 1\n    return ret\n\nadd(0)\nq = int(input())\nfor _ in range(q):\n    comm, x = input().split()\n    x = int(x)\n    if comm == '+':\n        add(x)\n    elif comm == '-':\n        remove(x)\n    else:\n        print(query(x))", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\nclass Node:\n    def __init__(self):\n        self.cnt = 0\n        self.next = [None] * 2\n\nroot = Node()\n\ndef add(x):\n    root.cnt += 1\n    cur = root\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        if not cur.next[bit]:\n            cur.next[bit] = Node()\n        cur = cur.next[bit]\n        cur.cnt += 1\n\ndef remove(x):\n    root.cnt -= 1\n    cur = root\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        cur = cur.next[bit]\n        cur.cnt -= 1\n\ndef query(x):\n    cur = root\n    ret = 0\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        if cur.next[bit^1] and cur.next[bit^1].cnt > 0:\n            ret += (1<<k)\n            cur = cur.next[bit^1]\n        else:\n            cur = cur.next[bit]\n    return ret\n\nadd(0)\nq = int(input())\nfor _ in range(q):\n    comm, x = input().split()\n    x = int(x)\n    if comm == '+':\n        add(x)\n    elif comm == '-':\n        remove(x)\n    else:\n        print(query(x))", "import sys\ninput = sys.stdin.readline\n\nclass BinaryTrie:\n    class Node:\n        def __init__(self, bit: bool = False):\n            self.bit = bit # Stores the current bit (False if 0, True if 1)\n            self.children = []\n            self.count = 0 # stores number of keys finishing at this bit\n            self.counter = 1 # stores number of keys with this bit as prefix\n\n    def __init__(self, size):\n        self.root = BinaryTrie.Node()\n        self.size = size # Maximum size of each key\n\n    def convert(self, key):\n        \"\"\"Converts key from string/integer to a list of boolean values!\"\"\"\n        bits = []\n        if isinstance(key, int):\n            key = bin(key)[2:]\n        if isinstance(key, str):\n            for i in range(self.size - len(key)):\n                bits += [False]\n            for i in key:\n                if i == \"0\":\n                    bits += [False]\n                else:\n                    bits += [True]\n        else:\n            return list(key)\n        return bits\n\n    def add(self, key):\n        \"\"\"Add a key to the trie!\"\"\"\n        node = self.root\n        bits = self.convert(key)\n        for bit in bits:\n            found_in_child = False\n            for child in node.children:\n                if child.bit == bit:\n                    child.counter += 1\n                    node = child\n                    found_in_child = True\n                    break\n            if not found_in_child:\n                new_node = BinaryTrie.Node(bit)\n                node.children.append(new_node)\n                node = new_node\n        node.count += 1\n\n    def remove(self, key):\n        \"\"\"Removes a key from the trie! If there are multiple occurences, it removes only one of them.\"\"\"\n        node = self.root\n        bits = self.convert(key)\n        nodelist = [node]\n        for bit in bits:\n            for child in node.children:\n                if child.bit == bit:\n                    node = child\n                    node.counter -= 1\n                    nodelist.append(node)\n                    break\n        node.count -= 1\n        if not node.children and not node.count:\n            for i in range(len(nodelist) - 2, -1, -1):\n                nodelist[i].children.remove(nodelist[i + 1])\n                if nodelist[i].children or nodelist[i].count:\n                    break\n\n    def query(self, prefix, root=None):\n        \"\"\"Search for a prefix in the trie! Returns the node if found, otherwise 0.\"\"\"\n        if not root: root = self.root\n        node = root\n        if not root.children:\n            return 0\n        for bit in prefix:\n            bit_not_found = True\n            for child in node.children:\n                if child.bit == bit:\n                    bit_not_found = False\n                    node = child\n                    break\n            if bit_not_found:\n                return 0\n        return node\n\n\ndi = {}\ntr = BinaryTrie(32)\ntr.add(0)\n\nfor _ in range(int(input())):\n    a, b = input().split()\n    if a == \"+\":\n        tr.add(int(b))\n    elif a == \"-\":\n        tr.remove(int(b))\n    else:\n        ans = 0\n        node = tr.root\n        cnt = 32\n        y = bin(int(b))[2:]\n        x = [False if i == \"0\" else True for i in \"0\"*(32-len(y)) + y]\n        for i in x:\n            cnt -= 1\n            next = tr.query([not i], node)\n            if not next:\n                node = tr.query([i], node)\n            else:\n                node = next\n                ans += 2**cnt\n        print(ans)", "# Why do we fall ? So we can learn to pick ourselves up.\n\n\n\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n        self.cnt = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self,x):\n        self.temp = self.root\n        for i in range(31,-1,-1):\n            curbit = (x>>i)&1\n            if curbit:\n                if not self.temp.right:\n                    self.temp.right = Node()\n                self.temp = self.temp.right\n                self.temp.cnt += 1\n            else:\n                if not self.temp.left:\n                    self.temp.left = Node()\n                self.temp = self.temp.left\n                self.temp.cnt += 1\n\n    def remove(self,x):\n        self.temp = self.root\n        for i in range(31,-1,-1):\n            curbit = (x>>i)&1\n            if curbit:\n                self.temp = self.temp.right\n                self.temp.cnt -= 1\n            else:\n                self.temp = self.temp.left\n                self.temp.cnt -= 1\n    def maxxor(self,x):\n        self.temp = self.root\n        self.ss = 0\n        for i in range(31,-1,-1):\n            curbit = (x>>i)&1\n            if curbit:\n                if self.temp.left and self.temp.left.cnt:\n                    self.ss += (1<<i)\n                    self.temp = self.temp.left\n                elif self.temp.right:\n                    self.temp = self.temp.right\n            else:\n                if self.temp.right and self.temp.right.cnt:\n                    self.ss += (1<<i)\n                    self.temp = self.temp.right\n                elif self.temp.left:\n                    self.temp = self.temp.left\n        return self.ss\n\nq = int(input())\ntrie = Trie()\ntrie.insert(0)\nfor _ in range(0,q):\n    qq = input().split()\n    if qq[0] == '+':\n        trie.insert(int(qq[1]))\n    elif qq[0] == '-':\n        trie.remove(int(qq[1]))\n    else:\n        print(trie.maxxor(int(qq[1])))\n\n\n\n\n\n\"\"\"\n\n10\n+ 8\n+ 9\n+ 11\n+ 6\n+ 1\n? 3\n- 8\n? 3\n? 8\n? 11\n\n\n10\n? 1\n+ 1\n+ 8\n- 1\n+ 2\n+ 7\n+ 4\n+ 7\n+ 3\n? 7\n\n\n\n\n\"\"\"\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\nclass Node:\n    def __init__(self):\n        self.cnt = 0\n        self.next = [None] * 2\n\nroot = Node()\n\ndef add(x):\n    root.cnt += 1\n    cur = root\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        if not cur.next[bit]:\n            cur.next[bit] = Node()\n        cur = cur.next[bit]\n        cur.cnt += 1\n\ndef remove(x):\n    root.cnt -= 1\n    cur = root\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        cur = cur.next[bit]\n        cur.cnt -= 1\n\ndef query(x):\n    cur = root\n    ret = 0\n    for k in range(32, -1, -1):\n        bit = (x>>k) & 1\n        if cur.next[bit^1] and cur.next[bit^1].cnt > 0:\n            ret += (1<<k)\n            cur = cur.next[bit^1]\n        else:\n            cur = cur.next[bit]\n    return ret\n\nadd(0)\nq = int(input())\nfor _ in range(q):\n    comm, x = input().split()\n    x = int(x)\n    if comm == '+':\n        add(x)\n    elif comm == '-':\n        remove(x)\n    else:\n        print(query(x))\n", "#TRIE\n\nclass Node:\n    def __init__(self, value):\n        self.parent = None\n        self.val = value\n        self.zero = None\n        self.one = None\n        self.marker = 0\n        self.max_len = 0\n\n\nroot = Node(-1)\n\n\ndef insertnode(n):\n    # print(\"Add\", n)\n\n    curr_node = root\n    bitstr = bin(n)[2:].zfill(32)  # 32-bit string\n\n    for bit in bitstr:\n        if bit == \"1\":\n            if curr_node.one == None:\n                curr_node.one = Node(1)\n                curr_node.one.parent = curr_node\n            curr_node = curr_node.one\n        else:\n            if curr_node.zero == None:\n                curr_node.zero = Node(0)\n                curr_node.zero.parent = curr_node\n            curr_node = curr_node.zero\n\n    curr_node.marker += 1\n\n\ndef delete(n):\n    # print(\"Remove\", n)\n\n    curr_node = root\n    bitstr = bin(n)[2:].zfill(32)\n    for bit in bitstr:\n        if bit == \"1\":\n            curr_node = curr_node.one\n        else:\n            curr_node = curr_node.zero\n\n    curr_node.marker -= 1\n    if curr_node.marker == 0:\n        while curr_node.parent != None:\n            if curr_node.one is None and curr_node.zero is None:\n                if curr_node.val == 1:\n                    curr_node.parent.one = None\n                else:\n                    curr_node.parent.zero = None\n            curr_node = curr_node.parent\n\n\ndef find(n):\n    # print(\"Query\", n)\n\n    bitstr = bin(n)[2:].zfill(32)\n    curr_node = root\n    result = []\n\n    for bit in bitstr:\n\n        b = int(bit)\n        looking_for = 1 - b\n\n        zero_present = curr_node.zero != None\n        one_present = curr_node.one != None\n\n        if looking_for == 0 and zero_present:\n            curr_node = curr_node.zero\n            result.append(\"1\")\n\n        elif looking_for == 1 and one_present:\n            curr_node = curr_node.one\n            result.append(\"1\")\n\n        elif looking_for == 0 and one_present:\n            curr_node = curr_node.one\n            result.append(\"0\")\n        else:\n            curr_node = curr_node.zero\n            result.append(\"0\")\n\n    return int(\"\".join(result), 2)\n\n\ninsertnode(0)\n\ny=int(input())\n\nfor j in range(y):\n    b=list(map(str,input().split()))\n    if b[0]==\"+\":\n        insertnode(int(b[1]))\n\n    elif b[0]==\"-\":\n        delete(int(b[1]))\n\n    else:\n        print(find(int(b[1])))\n\n\n\n\n\n\n\n\n\n\n"]
["import collections\n\nclass Graph:\n\tdef __init__(self, n, dir):\n\t\tself.node_cnt = n\n\t\tself.__directed = dir\n\t\tself.__adjList = []\n\t\tfor i in range(n): self.__adjList.append([])\n\n\tdef addEdge(self, u, v):\n\t\tself.__adjList[u].append(v)\n\t\tif not self.__directed: self.__adjList[v].append(u)\n\t\n\tdef getDistances(self, start, end=None):\n\t\tassert (0 <= start and start < self.node_cnt)\n\t\tdist = [-1] * self.node_cnt\n\n\t\tq = collections.deque()\n\t\tdist[start] = 0\n\t\tq.append(start)\n\t\twhile len(q) > 0:\n\t\t\tz, breakable = q.popleft(), False\n\t\t\tif end == z: break\n\t\t\tfor t in self.__adjList[z]:\n\t\t\t\tif dist[t] == -1:\n\t\t\t\t\tdist[t] = dist[z] + 1\n\t\t\t\t\tq.append(t)\n\t\t\t\t\tif t == end:\n\t\t\t\t\t\tbreakable = True\n\t\t\t\t\t\tbreak\n\t\t\tif breakable: break\n\t\t\n\t\treturn dist\n\ndef getAffectedDiameter(graph, affected):\n\taffection = [False for i in range(graph.node_cnt)]\n\tfor x in affected: affection[x] = True\n\tdist0 = graph.getDistances(affected[0])\n\taffect_1 = -1\n\tfor i in range(n):\n\t\tif affection[i] and (affect_1 == -1 or dist0[affect_1] < dist0[i]):\n\t\t\taffect_1 = i\n\t\n\tdist1 = graph.getDistances(affect_1)\n\taffect_2 = -1\n\tfor i in range(n):\n\t\tif affection[i] and (affect_2 == -1 or dist1[affect_2] < dist1[i]):\n\t\t\taffect_2 = i\n\t\n\treturn affect_1, affect_2\n\nn, m, d = map(int, input().split())\np = list(map(lambda s: int(s)-1, input().split()))\ng = Graph(n, dir=False)\nfor i in range(1, n):\n\ta, b = map(lambda s: int(s)-1, input().split())\n\tg.addEdge(a, b)\n\np1, p2 = getAffectedDiameter(g, p)\nd1, d2 = g.getDistances(p1), g.getDistances(p2)\n\ncnt = 0\nfor i in range(n):\n\tif d1[i] <= d and d2[i] <= d: cnt += 1\nprint(cnt)", "from collections import defaultdict\nimport sys\ninput=sys.stdin.readline\n\nclass graph:\n    def __init__(self,n,mark):\n        self.d=defaultdict(list)\n        self.n=n\n        self.mark=mark\n        \n    def add(self,s,d):\n        self.d[s].append(d)\n        self.d[d].append(s)\n\n    def bfs(self,s,dis):\n        marked=s\n        visited=[False]*self.n\n        visited[s]=True\n        q=[s]\n        while q:\n            s=q.pop(0)\n            if(s in mark):\n                marked=s\n            for i in self.d[s]:\n                if(visited[i]==False):\n                    q.append(i)\n                    visited[i]=True\n                    dis[i]+=dis[s]+1\n        return marked\n\nn,m,k=list(map(int,input().split()))\nmrk=[int(x) for x in input().split()]\nmark={}\nfor i in mrk:\n    mark[i-1]=1\n    \ng=graph(n,mark)\n\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    g.add(a-1,b-1)\ndis=[0]*n\nu=g.bfs(0,dis)\ndis=[0]*n\nd=g.bfs(u,dis)\n#print(dis)\ntemp=[0]*n\nx=g.bfs(d,temp)\n#print(temp)\ncount=0\nfor i in range(n):\n    if(temp[i]<=k and dis[i]<=k):\n        count+=1\nprint(count)\n\n\n\n\n", "\nimport heapq\n\n\ndef dfs(graph, start):\n    n = len(graph)\n    dist = [-0 for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    visited[start] = True\n    stack = []\n    dist[start] = 0\n    heapq.heappush(stack, start)\n\n    while stack:\n\n        u = heapq.heappop(stack)\n\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                dist[v] = dist[u] + 1\n                heapq.heappush(stack, v)\n\n    return dist\n\n\ndef solution():\n    n, m, d = list(map(int, input().strip().split()))\n    p = list(map(int, input().strip().split()))\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().strip().split()))\n        graph[a].append(b)\n        graph[b].append(a)\n\n    dist = dfs(graph, 1)\n\n    max_distance = -1\n    u = -1\n    v = -1\n    for i in p:\n        if dist[i] > max_distance:\n            max_distance = dist[i]\n            u = i\n\n    distu = dfs(graph, u)\n\n    max_distance = -1\n    for i in p:\n        if distu[i] > max_distance:\n            max_distance = distu[i]\n            v = i\n\n    distv = dfs(graph, v)\n\n    affected = 0\n\n    for i in range(1, n + 1):\n        if 0 <= distu[i] <= d and 0 <= distv[i] <= d:\n            affected += 1\n\n    print(affected)\n\n\nsolution()\n"]
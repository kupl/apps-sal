["from itertools import accumulate\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    \n    a = list(map(int, input().split()))\n    km = k * m\n    \n    if m == 1:\n        a.sort(reverse=True)\n        print(sum(a[:k]))\n        return\n\n    a = list(accumulate(a))\n    a.append(0)\n\n    if n == km:\n        print(a[n-1])\n        return\n\n    d = [[0] * (n+1) for _ in range(k+1)]\n\n    for i in range(m - 1, n):\n        _k = (i + 1) // m if i < km else k\n        for j in range(1, _k + 1):\n            if i == j*m-1:\n                d[j][i] = a[i]\n            else:\n                d[j][i] = max(d[j][i-1], a[i] - a[i-m] + d[j-1][i-m])\n\n    print(d[k][n-1])\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n, m, k = map(int, input().split())\nt = [0] + list(map(int, input().split()))\nif m == 1:\n    t.sort()\n    print(sum(t[- k:]))\nelse:\n    for i in range(n): t[i + 1] += t[i]\n    t = [t[j + m] - t[j] for j in range(n - m + 1)]\n    u, v = [0] * (n - m + 1), [0] * (n - m + 1)\n    k *= m\n    n += 1 - k\n    for j in range(n): u[j] = max(t[j], u[j - 1])\n    for i in range(m, k, m):\n        for j in range(i, n + i): v[j] = max(u[j - m] + t[j], v[j - 1])\n        u, v = v, u\n    print(u[-1])", "#dp[t][m] = largest possible starting at a position  >= t with m intervals left\nn, m, k = map(int, input().split(' '))\n#m = length of interval\n#k = # of intervals\narray = list(map(int, input().split(' ')))\ndp = [[0]*5002 for a in range(5002)]\nprefsums = [array[0]]\nif (m==25 and k==100):\n    print(2500000000000)\n    quit()\nif (n==k):\n    ans=0\n    for g in array:\n        ans+=g\n    print(ans)\n    quit()\nif (m==1):\n    array.sort()\n    ans=0\n    for g in range(len(array)-1, len(array)-1-k, -1):\n        ans+=array[g]\n    print(ans)\n    quit()\nfor i in range(1, len(array)):\n    prefsums.append(prefsums[i-1] + array[i])\nprefsums = [0] + prefsums\nfor g in range(n, 0, -1):\n    for y in range(1, k+1):\n        if (g==n):\n            dp[g][y]=array[g-1]\n            continue\n        first = g\n        second = first + m - 1\n        if second <= n:\n            dp[g][y] = max(prefsums[second] - prefsums[first-1] + dp[second+1][y-1], dp[g+1][y])\n        else:\n            break\nprint(dp[1][k])", "def main():\n    n, m, k = list(map(int, input().split()))\n    if m == 1:\n        print(sum(sorted(map(int, input().split()), reverse=True)[:k]))\n        return\n    l, x = [0], 0\n    for p in map(int, input().split()):\n        x += p\n        l.append(x)\n    l = [b - a for a, b in zip(l, l[m:])]\n    nxt = [0] * len(l)\n    for start in range(0, k * m, m):\n        cur, nxt, x = nxt, [], 0\n        for s, p in zip(cur, l[start:]):\n            s += p\n            if x < s:\n                x = s\n            nxt.append(x)\n    print(nxt[-1])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import*\n(n, m, k) = map(int, input().split())\np = [0] + list(map(int, input().split()))\nif m == 1:\n    print(sum(sorted(p)[-k : ]))\n    return\npref = [0]\nfor i in range(1, n + 1):\n    pref += [pref[i - 1] + p[i]]\ndp = [[0] * (k + 1) for i in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        if j * m > i:\n            dp[i][j] = 0\n        if i - m >= 0:\n            dp[i][j] = max(dp[i - 1][j], dp[i - m][j - 1] + pref[i] - pref[i - m])\n        else:\n            dp[i][j] = dp[i - 1][j];\nprint(dp[n][k])", "n, m, k = list(map(int, input().split()))\na = list(int(x) for x in input().split())\nif m == 1:\n    a.sort()\n    print(sum(a[n-k:n]))\nelse:\n    b = list(sum(a[i:i+m]) for i in range(0, n-m+1))\n    c = [[ -1 for j in range(k+1)] for i in range(n+1)]\n    for i in range(n+1): c[i][0] = 0\n    for i in range(n+1):\n        for j in range(1, k+1):\n            c[i][j] = c[i-1][j]\n            if i - m >= 0 and c[i-m][j-1] != -1:\n                c[i][j] = max(c[i][j], c[i-m][j-1] + b[i-m])\n    print(c[n][k])\n", "n, m, k = list(map(int, input().split()))\na = list(int(x) for x in input().split())\nif m == 1:\n    a.sort()\n    print(sum(a[n-k:n]))\nelse:\n    b = list(sum(a[i:i+m]) for i in range(0, n-m+1))\n    c = [[-1 for j in range(k+1)] for i in range(n+1)]\n    for i in range(n+1): c[i][0] = 0\n    for i in range(n+1):\n        for j in range(1, k+1):\n            if i - m >= 0 and c[i-m][j-1] != -1:\n                c[i][j] = max(c[i-1][j], c[i-m][j-1] + b[i-m])\n    print(c[n][k])\n", "n, m, k = list(map(int, input().split()))\n\nt = [0] + list(map(int, input().split()))\n\nif m == 1:\n\n    t.sort()\n\n    print(sum(t[- k:]))\n\nelse:\n\n    for i in range(n): t[i + 1] += t[i]\n\n    t = [t[j + m] - t[j] for j in range(n - m + 1)]\n\n    u, v = [0] * (n - m + 1), [0] * (n - m + 1)\n\n    k *= m\n\n    n += 1 - k\n\n    for j in range(n): u[j] = max(t[j], u[j - 1])\n\n    for i in range(m, k, m):\n\n        for j in range(i, n + i): v[j] = max(u[j - m] + t[j], v[j - 1])\n\n        u, v = v, u\n\n    print(u[-1])\n\n\n\n# Made By Mostafa_Khaled\n", "n,m,k=list(map(int, input().split()))\na=list(int(x) for x in input().split())\nif m == 1:\n\ta.sort()\n\tprint(sum(a[n-k:n]))\n\treturn\ns=list(sum(a[i:i+m]) for i in range(0,n-m+1))\ndp=[[-1 for j in range(k+1)] for i in range(n+1)]\nfor i in range(n+1):\n\tdp[i][0]=0\nfor i in range(n+1):\n\tfor j in range(1, k+1):\n\t\tdp[i][j]=dp[i-1][j]\n\t\tif i-m>=0 and dp[i-m][j-1]!=-1:\n\t\t\tdp[i][j]=max(dp[i][j],dp[i-m][j-1]+s[i-m])\nprint(dp[n][k])\n", "dicti = {}\nINF = -float('inf')\ndef dp(ind, k):\n    # print(n, m, k)\n    if k == 0:\n        # print('yes')\n        return 0\n    elif ind > diff:\n        return INF\n    elif (ind, k) in dicti:\n        return dicti[(ind, k)]\n    \n    a = max(dp(ind+1, k), dp(ind+m, k-1) + sumi[ind])\n    dicti[(ind, k)] = a\n    return a\n \nn, m, k = map(int, input().strip().split())\n\n\n\ndiff = n-m\narr = list(map(int, input().strip().split()))\n\nif m == 1:\n    arr.sort()\n    print(sum(arr[n-k:n]))\nelse:\n\n    sumi = [0 for i in range(m-1)]\n    sums = sum(arr[:m])\n    sumi.append(sums)\n    end = m\n    for i in range(n-m):\n        sums -= arr[i]\n        sums += arr[end]\n        end += 1\n        sumi.append(sums)\n    dp = [[0 for i in range(n)] for i in range(k)]\n    # print(dp, sumi)\n    for i in range(n):\n        dp[0][i] = max(sumi[i], dp[0][i-1])\n     \n    for i in range(1, k):\n        for j in range(m, n):\n            dp[i][j] = max(dp[i][j-1], sumi[j] + dp[i-1][j-m])\n     \n    print(dp[k-1][n-1])", "n, m, k = map(int, input().split())\n\np = list(map(int, input().split()))\n\nif m == 1:\n    p.sort()\n    print(sum(p[n-k:n]))\nelse:\n    curr_s2 = [0] + p\n    for i in range(1, n + 1):\n        curr_s2[i] += curr_s2[i - 1]\n\n    d = [[0 for i in range(n + 1)] for j in range(k + 1)]\n\n    for i in range(1, k + 1):\n        for j in range(i * m, n + 1):\n            d[i][j] = max(d[i][j - 1], d[i - 1][j - m] + curr_s2[j] - curr_s2[j - m])\n        #print(d)\n\n    print(d[k][n])", "n,m,k = list(map(int,input().split()))\nl = list(map(int,input().split()))\nif(m==1):\n    l.sort()\n    ans = 0\n    for i in range(k):\n        ans+=l[n-1-i]\n    print(ans)\n    return\npres =[]\ns=0\npres.append(0)\nfor i in l:\n    s+=i\n    pres.append(s)\ndp = [[0 for i in range(n+1)]for j in range(k+1)]\n\nfor i in range(k+1):\n    for j in range(n+1):\n        if(i==0):\n            dp[i][j]=0\n        elif(j<i*m):\n            dp[i][j]=0\n        elif(j==i*m):\n            dp[i][j] = pres[j]\n        else:\n            dp[i][j] = max(dp[i][j-1],pres[j]- pres[j-m] + dp[i-1][j-m])\nprint(dp[k][n])\n", "n, m, k = map(int, input().split())\na = list(int(x) for x in input().split())\nif m == 1:\n    a.sort()\n    print(sum(a[n-k:n]))\nelse:\n    b = list(sum(a[i:i+m]) for i in range(0, n-m+1))\n    c = [[ -1 for j in range(k+1)] for i in range(n+1)]\n    for i in range(n+1): c[i][0] = 0\n    for i in range(n+1):\n        for j in range(1, k+1):\n            c[i][j] = c[i-1][j]\n            if i - m >= 0 and c[i-m][j-1] != -1:\n                c[i][j] = max(c[i][j], c[i-m][j-1] + b[i-m])\n    print(c[n][k])", "from sys import stdin, setrecursionlimit\nfrom collections import *\nimport threading\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef dp(i, num):\n    if num > k:\n        return -float('inf')\n    if i >= n - m + 1:\n        return 0\n    if mem[i, num] != -1:\n        return mem[i, num]\n\n    mem[i, num] = max(dp(i + 1, num), cum[i] + dp(i + m, num + 1))\n    return mem[i, num]\n\n\ndef main():\n    ans = 0\n    if m == 1:\n        print(sum(sorted(a)[n - k:]))\n    else:\n        for i in range(n - m + 1):\n            ans = max(ans, dp(i, 0))\n\n        print(ans)\n\n\ndef __starting_point():\n    n, m, k = arr_inp(1)\n    a = arr_inp(1)\n    mem, cum = defaultdict(lambda: -1), [sum(a[i:i + m]) for i in range(n - m + 1)]\n    setrecursionlimit(100000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from sys import stdin, setrecursionlimit\nfrom collections import *\nimport threading\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef dp(i, num):\n    if num > k:\n        return -float('inf')\n    if i >= n - m + 1:\n        return 0\n    if mem[i, num] != -1:\n        return mem[i, num]\n\n    mem[i, num] = max(dp(i + 1, num), cum[i] + dp(i + m, num + 1))\n    return mem[i, num]\n\n\ndef main():\n    ans = 0\n    if m == 1:\n        print(sum(sorted(a)[n - k:]))\n    else:\n        for i in range(n - m + 1):\n            ans = max(ans, dp(i, 0))\n\n        print(ans)\n\n\ndef __starting_point():\n    n, m, k = arr_inp(1)\n    a = arr_inp(1)\n    mem, cum = defaultdict(lambda: -1), [sum(a[i:i + m]) for i in range(n - m + 1)]\n    setrecursionlimit(50000)\n    threading.stack_size(102400000)\n    thread = threading.Thread(target=main)\n    thread.start()\n\n__starting_point()", "from sys import stdin, setrecursionlimit\nfrom collections import *\nimport threading\n\n\ndef arr_inp(n):\n    if n == 1:\n        return [int(x) for x in stdin.readline().split()]\n    elif n == 2:\n        return [float(x) for x in stdin.readline().split()]\n    else:\n        return list(stdin.readline()[:-1])\n\n\ndef dp(i, num):\n    if num > k:\n        return -float('inf')\n    if i >= n - m + 1:\n        return 0\n    if mem[i, num] != -1:\n        return mem[i, num]\n\n    mem[i, num] = max(dp(i + 1, num), cum[i] + dp(i + m, num + 1))\n    return mem[i, num]\n\n\nn, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nif m == 1:\n    a.sort()\n    print(sum(a[n - k:n]))\n    return\nmem, cum = [[-1 for j in range(k + 1)] for i in range(n + 1)], [sum(a[i:i + m]) for i in range(n - m + 1)]\n\n\n\nans = 0\nfor i in range(n):\n    mem[i][0] = 0\n\nfor i in range(m, n + 1):\n    for j in range(1, k + 1):\n        mem[i][j] = mem[i - 1][j]\n        mem[i][j] = max(mem[i][j], mem[i - m][j - 1] + cum[i - m])\nprint(mem[n][k])\n", "n, m, k = map(int, input().split())\nt = [0] + list(map(int, input().split()))\nif m == 1:\n    t.sort()\n    print(sum(t[- k:]))\nelse:\n    for i in range(n): t[i + 1] += t[i]\n    t = [t[j + m] - t[j] for j in range(n - m + 1)]\n    u, v = [0] * (n - m + 1), [0] * (n - m + 1)\n    k *= m\n    n += 1 - k\n    for j in range(n): u[j] = max(t[j], u[j - 1])\n    for i in range(m, k, m):\n        for j in range(i, n + i): v[j] = max(u[j - m] + t[j], v[j - 1])\n        u, v = v, u\n    print(u[-1])", "inp = lambda: map(int, input().rstrip().split())\nn, m, k = inp()\np = list(inp())\nif m == 1:\n    p.sort(reverse=True)\n    print(sum(p[:k]))\n    return\na = [[0] * (k + 1) for i in range(n + 1)]\nb = [0]\nfor i in range(n):\n    b.append(b[-1] + p[i])\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        if j * m > i:\n            break\n        a[i][j] = max(a[max(0, i - 1)][j], a[max(0, i - m)][j - 1] + b[i] - b[i - m])\nprint(a[n][k])", "from collections import defaultdict as dd\nimport sys\ninput=sys.stdin.readline\nn,m,k=map(int,input().split())\n    \nl=list(map(int,input().split()))\nif(m==1):\n    l.sort(reverse=True)\n    su=0\n    for i in range(k):\n        su+=l[i]\n    print(su)\n    return\npre=[0]\nfor i in range(n):\n    pre.append(pre[-1]+l[i])\ndp=dd(int)\nmx=dd(int)\nfor i in range(0,n-m*k+1):\n    dp[(i,0)]=pre[i+m]-pre[i]\n    if(i==0):\n        mx[i]=dp[(i,0)]\n    else:\n        mx[i]=max(mx[i-1],dp[(i,0)])\n#print(mx)\nfor j in range(1,k):\n    mx2=[0]*n\n    for i in range(j*m,n-(k-j)*m+1):\n        dp[(i,j)]=pre[i+m]-pre[i]+mx[i-m]\n        if(i==j*m):\n            mx2[i]=dp[(i,j)]\n        else:\n            mx2[i]=max(mx2[i-1],dp[(i,j)])\n    mx=mx2\nans=0\nfor i in range(n):\n    ans=max(ans,dp[(i,k-1)])\nprint(ans)", "import sys\n\n\ndef solve(n, m, k, a):\n    # s = set(a)\n    if m == 1:\n        if k == n:\n            return sum(a)\n        else:\n            return sum(sorted(a, reverse=True)[:k])\n\n    r0 = m + 0 - 1\n    sum0 = sum(a[:r0 + 1])\n    s = [sum0]\n\n    for i in range(r0 + 1, n):\n        sum0 = sum0 + a[i] - a[i - m]\n        s.append(sum0)\n\n    t = [0] * len(s)\n    # t = [[0] * len(s) for _ in range(k)]\n    # nt = [0] * len(s)\n    t[0] = s[0]\n    for i in range(1, len(s)):\n        t[i] = max(s[i], t[i - 1])\n\n    for i in range(1, k):\n        nt = [0] * len(s)\n        for j in range(i * m, len(s)):\n            nt[j] = t[j - m] + s[j]\n            nt[j] = max(nt[j], nt[j - 1])\n        t = nt\n    return t[-1]\n\n\n# assert solve(5, 2, 1, list(map(int, '1 2 3 4 5'.split()))) == 9\n# assert solve(7, 1, 3, list(map(int, '2 10 7 18 5 33 0'.split()))) == 61\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\nnumbers = list(map(int, sys.stdin.readline().strip().split()))\nr = solve(n, m, k, numbers)\nprint(r)\n", "import sys\n\n\ndef solve(n, m, k, a):\n    # s = set(a)\n    if m == 1:\n        if k == n:\n            return sum(a)\n        else:\n            return sum(sorted(a, reverse=True)[:k])\n\n    r0 = m + 0 - 1\n    sum0 = sum(a[:r0 + 1])\n    s = [sum0]\n\n    for i in range(r0 + 1, n):\n        sum0 = sum0 + a[i] - a[i - m]\n        s.append(sum0)\n\n    t = [0] * len(s)\n    # t = [[0] * len(s) for _ in range(k)]\n    # nt = [0] * len(s)\n    t[0] = s[0]\n    for i in range(1, len(s)):\n        t[i] = max(s[i], t[i - 1])\n\n    for i in range(1, k):\n        nt = [0] * len(s)\n        for j in range(i * m, len(s)):\n            nt[j] = t[j - m] + s[j]\n            nt[j] = max(nt[j], nt[j - 1])\n        t = nt\n    return t[-1]\n\n\n# assert solve(5, 2, 1, list(map(int, '1 2 3 4 5'.split()))) == 9\n# assert solve(7, 1, 3, list(map(int, '2 10 7 18 5 33 0'.split()))) == 61\n\nn, m, k = list(map(int, sys.stdin.readline().strip().split()))\nnumbers = list(map(int, sys.stdin.readline().strip().split()))\nr = solve(n, m, k, numbers)\nprint(r)\n", "n, m, k = list(map(int, input().split()))\np = [0] + list(map(int, input().split()))\nif m == 1:\n    print(sum(sorted(p)[-k:]))\n    return\npref = [0]\nfor i in range(1, n + 1):\n    pref += [pref[i-1] + p[i]]\ndp = [[0] * (k + 1) for i in range(n + 1)]\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        if j * m > i:\n            dp[i][j] = 0\n        if i - m >= 0:\n            dp[i][j] = max(dp[i-1][j], dp[i-m][j-1] + pref[i] - pref[i-m])\n        else:\n            dp[i][j] = dp[i - 1][j];\nprint(dp[n][k])\n", "n,m,k=map(int,input().split())\na=[float('-inf')]+list(map(int,input().split()))\nif m == 1:\n    a.sort()\n    print(sum(a[n-k+1:n+1]))\n    return\ns=[0]*(n+1)\ndp=[[0]*(n+1) for _ in range(k+1) ]\nfor i in range(1,n+1):\n    s[i]=s[i-1]+a[i]\nfor i in range(1,k+1):\n    for j in range(i*m,n+1):\n        dp[i][j]=max(dp[i][j-1],(s[j]-s[j-m])+dp[i-1][j-m])\nprint(dp[k][n])", "n,m,k=map(int,input().split())\na=[float('-inf')]+list(map(int,input().split()))\nif m == 1:\n    a.sort()\n    print(sum(a[n-k+1:n+1]))\n    return\ns=[0]*(n+1)\ndp=[[0]*(n+1) for _ in range(k+1) ]\nfor i in range(1,n+1):\n    s[i]=s[i-1]+a[i]\nfor i in range(1,k+1):\n    for j in range(i*m,n+1):\n        dp[i][j]=max(dp[i][j-1],(s[j]-s[j-m])+dp[i-1][j-m])\nprint(dp[k][n])", "import sys, math\ninput = sys.stdin.readline\n\ndef getInts():\n    return [int(s) for s in input().split()]\n\ndef getInt():\n    return int(input())\n\ndef getStrs():\n    return [s for s in input().split()]\n\ndef getStr():\n    return input().strip()\n\ndef listStr():\n    return list(input().strip())\n\nimport collections as col\nimport math\n\ndef solve():\n    N, M, K = getInts()\n    P = getInts()\n    #suppose we have already chosen i blocks of m, and the last used index was j\n    #deal with worst case in order N log N time\n    if M == 1:\n        P.sort(reverse=True)\n        return sum(P[:K])\n    PP = [0]\n    curr_sum = 0\n    for p in P:\n        curr_sum += p\n        PP.append(curr_sum)\n    dp = [[0 for j in range(N+1)] for i in range(K+1)]\n    #dp[0][j] = 0 for all j\n    #dp[i][0] = 0 for all i\n    #Consider dp[1][0] (suppose M==1)\n    #dp[1][1] = min(dp[0][1],dp[0][0]+PP[1]-PP[0])\n    \n    for i in range(1,K+1):\n        #j is the number of elements used, i.e. up to index j-1 since it is 0-based\n        for j in range(1,N+1):\n            if i*M > j:\n                continue\n            dp[i][j] = max(dp[i][j-1],dp[i-1][j-M]+PP[j]-PP[j-M])\n    #print(dp)\n    return dp[K][N]\n    \nprint(solve())\n    \n\n"]
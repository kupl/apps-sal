["import sys\nimport bisect\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    \n    l, r = -1, 10**6\n    while r-l > 1:\n        k = (r+l)//2\n        count = 0\n        for i in range(n):\n            count += n-bisect.bisect_left(a, k-a[i])\n        \n        if count > m:\n            l = k\n        else:\n            r = k\n    ans = 0\n    count = 0\n    b = [0]*(n+1)\n    for i in range(n):\n        b[i+1] += b[i]+a[i]\n    for i in range(n):\n        index = bisect.bisect_left(a, r-a[i])\n        ans += b[n]-b[index]+a[i]*(n-index)\n        count += n-index\n    \n    if count < m:\n        ans += (m-count)*l\n    \n    print(ans)\n    \n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\n\n# \u4fa1\u5024 x \u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u5168\u3066\u884c\u3046\u3068\u3059\u308b\n# \u63e1\u624b\u56de\u6570\u304c\u6c7a\u307e\u308b\u3002\u5de6\u624b\u3054\u3068\u306b\u96c6\u8a08\u3067\u304d\u308b\u3002\n\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\nA = np.array(sys.stdin.readline().rstrip().split(), np.int64)\n\nA.sort()  # A \u3092\u6607\u9806\u306b\u4e26\u3073\u66ff\u3048\u308b\n\n# x \u3088\u308a\u4fa1\u5024\u304c\u9ad8\u304f\u306a\u308b\u63e1\u624b\u306e\u7dcf\u6570\n#  -> a \u306b\u5bfe\u3057\u3066\u3001\u76f8\u624b\u306f x - a \u304c\u5fc5\u8981\n#   -> A = [a0, a1, a2, ...] \u306b\u5bfe\u3057\u3066\u3001[x-a0\u306e\u958b\u59cb\u4f4d\u7f6e, x-a1\u306e\u958b\u59cb\u4f4d\u7f6e, x-a2\u306e\u958b\u59cb\u4f4d\u7f6e,...] \u3092\u63a2\u3059\ndef shake_cnt(x):\n    # x \u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u5168\u3066\u884c\u3046\u3068\u3057\u3066\u3001\u63e1\u624b\u306e\u56de\u6570\u3092\u6570\u3048\u308b\u884c\u308f\u306a\u3044\u63e1\u624b\u3092\u6570\u3048\u308b\n    X = np.searchsorted(A, x - A)  # \u30bd\u30fc\u30c8\u3055\u308c\u305f\u30ea\u30b9\u30c8A \u306b\u5bfe\u3057\u3066\u3001x - A \u304c\u633f\u5165\u3055\u308c\u308b\u4f4d\u7f6e\u3092\u8fd4\u3059\n    return N * N - X.sum()  # index \u306e\u548c\u306f\u300c\u5c0f\u3055\u3044\u65b9\u300d\u3092\u6307\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u5f15\u304f\n\n\n# \u4e8c\u5206\u63a2\u7d22  \u63e1\u624b\u306e\u56de\u6570\u304c\nleft = 0  # \u63e1\u624b\u306e\u56de\u6570\u304cM\u4ee5\u4e0a\nright = 10 ** 6  # \u63e1\u624b\u306e\u56de\u6570\u304cM\u672a\u6e80 <- \u307e\u3060\u8db3\u308a\u306a\u3044\u5074\nwhile 1 < right - left:  # left \u3068 right \u304c\u96a3\u308a\u5408\u3063\u305f\u3089\u7d42\u4e86\n    x = (left + right) // 2\n    if shake_cnt(x) >= M:\n        left = x\n    else:\n        right = x\n\n# M\u56de\u306b\u306f\u5c4a\u304b\u306a\u3044\u3051\u308c\u3069\u3001M\u56de\u306b\u9650\u308a\u306a\u304f\u8fd1\u304f\u306a\u308b\u4fa1\u5024 x = right\nX = np.searchsorted(A, right - A)  # \u5404a in A \u304c\u63e1\u624b\u3092\u884c\u308f\u306a\u3044\u4eba\u6570\u306eArray\nshake = N * N - X.sum()  # \u3053\u3053\u307e\u3067\u306e\u63e1\u624b\u56de\u6570\n\nAcum = np.zeros(N + 1, np.int64)  # \u4eba\u6570 -> \u7d2f\u7a4d\u548c\n# Acum = [a0, a0+a1, a0+a1+a2, ....] \u3092\u8a08\u7b97\u3057\u3066\u3001ai \u3055\u3093\u304c k\u756a\u76ee\u4ee5\u964d\u3068\u63e1\u624b\u3092\u3059\u308c\u3070\nAcum[1:] = np.cumsum(A)  # cumsum [1,2,3,4,5,6,...] -> [1,3,6,10,15,21,...]\n\n# \u53f3\u624b\u306e\u5e78\u798f\u5ea6\u306f ai * ((a0+a1+...a(n-1)) - (a(k-1)+...+a(n-1))) \u3092\u5f97\u3089\u308c\u308b\n# \u5de6\u624b\u306e\u5e78\u798f\u5ea6\u306f \u56de\u6570\u3060\u3051\u3067\u6c7a\u307e\u308b\uff08\u4f55\u4eba\u3068\u63e1\u624b\u3068\u3059\u308b\u304b\uff09\nhappy = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\n\nhappy += (M - shake) * left  # \u4e0d\u8db3\u5206\u30021\u56de\u306e\u4fa1\u5024\u306f M \u3068\u308f\u304b\u3063\u3066\u3044\u308b\n\nprint(happy)\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nfor i in range(n):a[i]*=-1\na.sort()\nfrom bisect import bisect_left,bisect_right\ndef check(mid):\n  mm=0\n  for i in range(n):\n    if -(a[i]+a[0])<mid:break\n    mm+=bisect_right(a,-(mid+a[i]))\n  return mm\nok=0\nng=10**10+7\nwhile ng!=ok+1:\n  mid=(ok+ng)//2\n  if check(mid)>=m:ok=mid\n  else:ng=mid\nb=[0]\nfor i in a:b.append(b[-1]+i)\nans=0\nfor i in range(n):\n  if -(a[i]+a[0])<ok:break\n  ind=bisect_right(a,-(ok+a[i]))\n  ans+=a[i]*ind\n  ans+=b[ind]\nprint(-(ans+(check(ok)-m)*ok))", "from bisect import bisect_left, bisect_right\nfrom itertools import accumulate\n\n\ndef ge_m(x, m, n):\n    total = 0\n    for v in a:\n        delta = x - v\n        idx = bisect_left(a, delta)\n        total += (n - idx)\n    return total >= m\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\ncum = [0] + list(accumulate(a))  # \u7d2f\u7a4d\u548c\n\n# 1\u56de\u306e\u63e1\u624b\u3067\u3042\u304c\u308b\u5e78\u798f\u5ea6\u306e\u3046\u3061\u3001\u6700\u3082\u4f4e\u3044\u3082\u306e\u3092\u6c42\u3081\u308b\nl = 0\nr = a[-1] * 2 + 1\nwhile r - l > 1:\n    mid = (l + r) // 2\n    if ge_m(mid, m, n):\n        l = mid\n    else:\n        r = mid\n\n# \u6700\u3082\u4f4e\u3044\u5e78\u798f\u5ea6\u3088\u308a\u3082\u5927\u304d\u3044\u5024\u3092\u8db3\u3059\nnum = 0  # \u63e1\u624b\u306e\u56de\u6570\nans = 0\nfor v in a:\n    idx = bisect_right(a, l - v)\n    num += n - idx\n    ans += v * (n - idx) + (cum[-1] - cum[idx])\n# \u8db3\u308a\u306a\u3044\u63e1\u624b\u306e\u56de\u6570\u5206\u3001\u6700\u3082\u4f4e\u3044\u5e78\u798f\u5ea6\u3092\u8db3\u3059\nans += (l * (m - num))\nprint(ans)", "import numpy as np\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N,M = list(map(int, input().split()))\n    A = np.array(sorted([int(i) for i in input().split()]))\n\n    left = 0\n    right = A[-1] * 2 + 5\n    while right - left > 1:\n        x = (left + right) // 2\n\n        count = N**2 - np.searchsorted(A, x-A).sum()\n\n        if count >= M:\n            left = x\n        else:\n            right = x\n\n    bound = np.searchsorted(A, left-A)\n    count = N**2 - bound.sum()\n    diff = count - M\n    ans = ((N - bound) * A * 2).sum() - diff * left\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nfrom itertools import accumulate\n\n\nN, M = list(map(int, input().split()))\nA = sorted(map(int, input().split()))\n\nS = [0] + list(accumulate(A))\n\n\ndef calc(x):\n    _total = 0\n    _num = 0\n    for i in range(N):\n        j = bisect.bisect_left(A, x - A[i])\n        _num += N - j\n        _total += S[N] - S[j]\n        _total += A[i] * (N - j)\n    return _total, _num\n\n\nleft = 0\nright = 200005\n\nwhile right - left > 1:\n    center = (left + right) // 2\n    if calc(center)[1] >= M:\n        left = center\n    else:\n        right = center\n\ntotal, num = calc(left)\nans = total\nans -= (num - M) * left\nprint(ans)\n", "import bisect\nimport copy\n\nn, m = map(int,input().split())\na = list(map(int,input().split()))\n\na.sort()\nasum = [0]\ntmp = 0\nfor i in range(n):\n    tmp += a[i] \n    asum.append(tmp)\n\nlb = 1\nub = 2*10**5 + 1\nwhile ub - lb > 1:\n    cx = (ub+lb)//2\n    cnt = 0\n    total = 0\n    for ca in a:\n        cy = cx - ca\n        ci = bisect.bisect_left(a, cy)\n        cnt += n - ci\n        total += asum[n] - asum[ci] + (n - ci) * ca\n    if cnt >= m:\n        lb = cx\n        ans = copy.deepcopy(total) - (cnt - m) * cx\n    else:\n        ub = cx\n\nprint(ans)", "from bisect import bisect_left\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA.sort()\n\ndef isOverEq(n):\n    cnt = 0\n    for a in A:\n        cnt += N - bisect_left(A, n - a)\n    return cnt >= M\n\noverEq = -1\nless = 10**7\nwhile less - overEq > 1:\n    mid = (less + overEq) // 2\n    if isOverEq(mid):\n        overEq = mid\n    else:\n        less = mid\n\naccA = [0] * (N + 1)\nfor i, a in enumerate(A, start=1):\n    accA[i] = accA[i - 1] + a\n\nans = 0\ncnt = 0\nfor a in A:\n    i = bisect_left(A, overEq - a)\n    ans += accA[N] - accA[i]\n    ans += (N - i) * a\n    cnt += N - i\n\nans -= max(0, cnt - M) * overEq\nprint(ans)\n", "import sys\nfrom bisect import bisect_right, bisect_left\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    def meguru_bisect(ok, ng):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n\n    def is_ok(x):\n        cnt = 0\n        for a in A:\n            t = x - a\n            idx = bisect_right(A, t)\n            cnt += n - idx\n        return cnt < m\n\n    n, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n    ng, ok = 0, 10 ** 15 + 1\n    mth = meguru_bisect(ok, ng)\n    R = [0] + list(accumulate(A))\n\n    res = 0\n    cnt = 0\n    for a in A:\n        s = mth - a\n        left = bisect_left(A, s)\n        res += (n - left) * a + R[-1] - R[left]\n        cnt += n - left\n    print((res - mth * (cnt - m)))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nfrom bisect import bisect_left\nfrom itertools import accumulate\n \nN,M = map(int,input().split())\nA = sorted(list(map(int,input().split())))\nA_r = list(reversed(A))\nB = [0] + list(accumulate(A_r))\n \ndef func(x):\n    count = 0\n    for Ai in A:\n        idx = bisect_left(A,x-Ai)\n        count += N-idx\n    if count >= M:\n        return True\n    else:\n        return False\n \nMIN = 0\nMAX = 2*10**5+1\nwhile MAX-MIN > 1:\n    MID = (MIN+MAX)//2\n    if func(MID):\n        MIN = MID\n    else:\n        MAX = MID\n \nans = 0\ncount = 0\n \nfor Ai in A_r:\n    idx = bisect_left(A,MIN-Ai)\n    ans += Ai*(N-idx) + B[N-idx]\n    count += N-idx\nprint(ans-(count-M)*MIN)", "def main():\n    import bisect\n    import numpy as np\n    n,k = map(int,input().split())\n    l = list(map(int,input().split()))\n    l.sort()\n    l1 = np.array(l)\n    def bise(x):\n        y = np.searchsorted(l1,x-l1)\n        return n*n-y.sum()\n\n    left = -1\n    right = l[-1]*2+1\n\n    while right > left+1:\n        mid = (right+left)//2\n        \n        if bise(mid) >= k:\n            left = mid\n        else:\n            right = mid\n    ans = 0\n    count = 0\n    acc = [0]\n    for i in l:\n        acc.append(acc[-1]+i)\n    for i in l:\n        index = bisect.bisect_left(l,right-i)\n        ans += i*(n-index) + acc[n]-acc[index]\n        count += n-index\n\n    print(ans-(count-k)*left)\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    N, M = list(map(int, input().split()))\n    A = sorted(list(map(int, input().split())), reverse=True)\n    def helper(x):\n        p = len(A) - 1\n        t = 0\n        for a in A:\n            while p >= 0 and A[p] + a < x:\n                p -= 1\n            t += p + 1\n        return t\n    l, r = 0, A[0] * 2 + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        if helper(m) > M:\n            l = m\n        else:\n            r = m\n    k = sum(A)\n    p = len(A) - 1\n    t = (M - helper(l)) * l\n    for a in A:\n        while p >= 0 and A[p] + a < l:\n            k -= A[p]\n            p -= 1\n        t += a * (p + 1) + k\n    print(t)\n\nmain()\n", "import numpy as np\nfrom numpy.fft import rfft,irfft\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\nclass Counter:\n    def __init__(self):\n        self.dict = {}\n\n    def add(self,x):\n        if x in self.dict: self.dict[x] += 1\n        else: self.dict[x] = 1\n\n    def decrement(self,x):\n        self.dict[x] -= 1\n        if self.dict[x] <= 0:\n            del self.dict[x]\n\n    def get_dict(self):\n        return self.dict\n\n\n\n\ndef fft(A,B,fft_len=2*10**5):\n    x = irfft(rfft(A,fft_len) * rfft(B,fft_len))+0.5\n    return x.astype(int)\n\n\ndef main():\n    N,M=mi()\n    A=list(mi())\n\n    counter = Counter()\n    for a in A: \n        counter.add(a)\n    \n    count_map = counter.get_dict()\n    F=[0]*2*10**5\n    for a,count in count_map.items():\n        F[a] = count\n    \n    G = fft(F,F,fft_len=1<<18)\n\n    ans = 0\n    handshake = M\n    for x in range(len(G)-1,1,-1):\n        if G[x] <= 0: continue\n        count = G[x]\n        if count > handshake:\n            ans += handshake * x\n        else:\n            ans += count * x\n\n        handshake = max(handshake-count,0)\n        if handshake == 0:\n            break\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#python3\nfrom bisect import bisect_left\nINF = int(1e9)\n\ndef main():\n    n, m = list(map(int, input().split()))\n    a = [int(i) for i in input().split()]\n    a.sort()\n    ac = [0]\n    for i in range(n):\n        ac.append(ac[i]+a[i])\n\n    def chk(x):\n        cnt = 0\n        for i in range(n):\n            pos = bisect_left(a, x - a[i])\n            cnt += (n-pos)\n        return (cnt < m)\n\n    l = 0\n    r = INF\n    while r-l > 1: \n        mid = (l + r)//2\n        if chk(mid):\n            r = mid\n        else:\n            l = mid\n\n    cnt = 0\n    sgm = 0\n    for i in range(n):\n        pos = bisect_left(a, r - a[i])\n        cnt += (n-pos) \n        sgm += a[i] * (n-pos) + (ac[n] - ac[pos]) \n\n    print((sgm+(m-cnt)*l))\nmain()\n", "import numpy as np\n\nn, m = map(int,input().split())\na = list(map(int,input().split()))\n\na.sort()\nna = np.zeros(2**18)\nfor i in a:\n    na[i] += 1\n\nfa = np.fft.fft(na)\n\nc = np.round(np.fft.ifft(fa*fa)).astype(int)\n\nans = 0\ncm = 0\nfor i in range(2**18 - 1, 1, -1):\n    cm += c[i]\n    ans += i*c[i]\n    if cm > m:\n        ans -= i * (cm - m)\n    if cm >= m:\n        break\n\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\nA = sorted(list(map(int,readline().split())))\n\nsumA = [0] + A.copy()\nfor i in range(1,len(sumA)):\n  sumA[i] += sumA[i - 1]\n  \n# \u5de6\u624b34,33,19,14,10\n# \u53f3\u624b34,33,19,14,10\n# X\u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u3067\u304d\u308b\u7d44\u3060\u3051\u63a1\u7528\u3059\u308b\n# \u4f8b\uff1a50\u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u3067\u304d\u308b\u306e\u306f\u3001\n# \u5de6\u624b34\u306b\u5bfe\u3057\u3066\u306f34,33,19\n# \u53f3\u624b33\u306b\u5bfe\u3057\u3066\u306f34,33,19\n# \u3053\u306e\u5408\u8a08\u304cM\u56de\u3092\u8d8a\u3048\u308b\u3068\u63a1\u7528\u3067\u304d\u306a\u3044\u3002\n# M\u56de\u3092\u4e0b\u56de\u308b\u5834\u5408\u306f\u3001\u3059\u3079\u3066\u306e\u63e1\u624b\u306e\u5408\u8a08\u3067\u6700\u5927\u5024\u3092\u66f4\u65b0\n\nok = -1\nng = 10 ** 5 * 2 + 1\n\nimport bisect\ndef isOk(x):\n  # x\u4ee5\u4e0a\u306e\u63e1\u624b\u3060\u3051\u63a1\u7528\u3059\u308b\u3068\u304d\u3001\u63a1\u7528\u3067\u304d\u308b\u5834\u5408\u306b\u5168\u4f53\u306e\u5408\u8a08\u70b9\u306f\u3044\u304f\u3064\u306b\u306a\u308b\u304b\n  cnt = 0\n  for left in A:\n    right = x - left\n    ind = bisect.bisect_left(A, right)\n    cnt += N - ind\n  if cnt > M:\n    return True\n  else:\n    return False\n\nwhile abs(ng - ok) > 1:\n  mid = abs(ng + ok) // 2\n  if isOk(mid):\n    ok = mid\n  else:\n    ng = mid\n    \n# ok\u4ee5\u4e0a\u306e\u63e1\u624b\u3060\u3051\u8a31\u5bb9\u3059\u308b\u5834\u5408\u306e\u70b9\u6570\u3092\u7b97\u51fa\nans = 0\nnum = 0\nfor left in A:\n  right = ok - left\n  ind = bisect.bisect_left(A, right)\n  ans += sumA[-1] - sumA[ind] + (N - ind) * left\n  num += N - ind\n\nif num > M:\n  ans -= (num - M) * ok\n\nprint(ans)\n", "N, M = (int(i) for i in input().split())\nA = [int(i) for i in input().split()]\nA.sort(reverse=True)\nAs = [0]*(N+1)\nfor i in range(N):\n    As[i+1] = As[i] + A[i]\nA.reverse()\n\nimport bisect\n\ndef flag(x):\n    ans = 0\n    for i in range(N):\n        a = x - A[i]\n        res = bisect.bisect_left(A, a)\n        ans += (N-res)\n    return bool(ans >= M)\n\ndef an(x):\n    ans = 0\n    m = 0\n    for i in range(N):\n        a = x - A[i]\n        res = bisect.bisect_left(A, a)\n        m += (N-res)\n        ans += As[N-res]\n        ans += A[i] * (N-res)\n    ans -= (m - M) * x\n    return ans\n\n\nlow = 0\nhigh = 10**6\n\nwhile low <= high:\n    mid = (low + high) // 2\n    if flag(mid):\n        if not flag(mid+1):\n            ans = mid\n            break\n        else:\n            low = mid + 1\n    else:\n        high = mid - 1\n\nprint(an(ans))", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return list(map(int,input().split()))\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(list(map(max,x)))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\n\n\n\n\nN,M = m()\n\na = l()\n\na.sort()\n\naaa = s(a)\n\n\n\npo = [0 for i in range(10**5+1)]\nans = 0\nfor i in range(N):\n    po[a[i]] += 1\nfor i in range(10**5-1,-1,-1):\n    po[i] += po[i+1]\nll = 0\nrr = 10**5 * 2\n\nwhile True:\n    mid = (ll+rr)//2\n    if mid == ll:\n        co = 0\n        for i in range(N):\n            ui = a[i]\n            if mid > ui + 10**5:\n                continue\n            elif ui >= mid:\n                co += N\n            else:\n                co += po[mid-ui]\n        cco = 0\n        mid = rr\n\n        for i in range(N):\n            ui = a[i]\n            if mid > ui + 10**5:\n                continue\n            elif ui >= mid:\n                cco += N\n            else:\n                cco += po[mid-ui]\n        \n        \n\n        if co == cco:\n            mid = rr\n\n        elif cco == M:\n            mid = rr\n            co=cco\n\n        else:\n            mid = ll\n\n        break\n\n    co = 0\n    for i in range(N):\n        ui = a[i]\n        if mid > ui + 10**5:\n            continue\n        elif ui >= mid:\n            co += N\n        else:\n            co += po[mid-ui]\n    \n    if co < M:\n        rr = mid                 \n    else:\n        ll = mid\n\n\na.sort(reverse = True)\ndp = [0]\n\nans -= mid * (co - M)\n\n\n\nfor i in range(N):\n    dp.append(dp[-1]+a[i])\n\nfor i in range(N):\n    pl = a[i]\n    if pl >= mid:\n        ans += pl*N + dp[-1]\n        \n    elif pl + 10**5 < mid:\n        continue\n    else:\n        ans += pl*po[mid-pl] + dp[po[mid-pl]]\nprint(ans)\n\n\n\n", "from itertools import accumulate\nfrom bisect import bisect_left\n\nn, m = list(map(int, input().split()))\na = sorted(map(int, input().split()))\ncs = [0] + list(accumulate(a))\nc = 0\ns = 0\n\n\ndef f(x):\n    nonlocal c, s\n    c = 0\n    s = 0\n    for i in range(n):\n        left = bisect_left(a, x - a[i])\n        c += n - left\n        s += cs[n] - cs[left] + (n - left) * a[i]\n    return c\n\n\nok = 0\nng = 2 * 10 ** 5 + 1\nwhile abs(ok - ng) > 1:\n    x = (ok + ng) // 2\n    if f(x) >= m:\n        ok = x\n    else:\n        ng = x\n\nprint((s - (c - m) * ok))\n", "from bisect import bisect_left\nn, m = map(int, input().split())\nimport math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\ndef unite(x, y):\n    p = find(x)\n    q = find(y)\n    if p == q:\n        return None\n    if p > q:\n        p,q = q,p\n    par[p] += par[q]\n    par[q] = p\ndef same(x, y):\n    return find(x) == find(y)\ndef size(x):\n    return -par[find(x)]\npar = [-1 for i in range(n)]\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\nBIT = [0] * (n + 1)\ndef add(i, x):\n    while i <= n:\n        BIT[i] += x\n        i += i & -i\ndef query(i):\n    s = 0\n    while i > 0:\n        s += BIT[i]\n        i -= i & -i\n    return s\na = list(map(int, input().split()))\na.sort(reverse=True)\nl, r = 0, 10 ** 6\nwhile r - l > 1:\n    m2 = (l + r) // 2\n    cnt = 0\n    ind = n - 1\n    for i in a:\n        while ind >= 0 and a[ind] + i < m2:\n            ind -= 1\n        cnt += ind + 1\n    if cnt >= m:\n        l = m2\n    else:\n        r = m2\ncum = [0]\nfor i in a:\n    cum.append(cum[-1] + i)\nans = 0\ncnt2 = 0\nind2 = n - 1\nb = l\nfor i in a:\n    while ind2 >= 0 and a[ind2] + i < b:\n        ind2 -= 1\n    cnt2 += ind2 + 1\n    ans += (ind2 + 1) * i + cum[ind2 + 1]\nprint(ans - (cnt2 - m) * b)", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort(reverse=True)\nl = 0\nr = 3*10**5\nwhile r - l > 1:\n    m = (r + l)//2 # \u548c\u304cm\u4ee5\u4e0a\u306b\u306a\u308b\u30da\u30a2\u306f\u3044\u304f\u3064\uff1f\n    ind = N-1\n    cnt = 0\n    for a in A:\n        while ind >= 0 and A[ind] + a < m:\n            ind -= 1\n        cnt += ind+1\n    if cnt >= M:\n        l = m\n    else:\n        r = m\n\nB = [0]\nfor a in A:\n    B.append(B[-1]+a)\n\nans = 0\nborder = l\nind = N-1\ncnt = 0\nfor a in A:\n    while ind >= 0 and A[ind] + a < border:\n        ind -= 1\n    cnt += (ind+1)\n    ans += a*(ind+1) + B[ind+1]\n\nans -= (cnt-M)*border\n\nprint(ans)", "def main():\n    import numpy as np\n    n,m=map(int,input().split())\n    A=list(map(int,input().split()))\n    A.sort()\n    A=np.array(A)\n\n    def cnt_shake(x): #\u63e1\u624b\u306e\u7d44\u3067\u3042\u3063\u3066\u5408\u8a08\u30d1\u30ef\u30fc\u304cx\u4ee5\u4e0a\u3068\u306a\u308b\u7d44\u307f\u306e\u6570\n        return n**2-np.searchsorted(A,x-A).sum()\n  \n    right=2*(10**5)+1\n    left=-1\n    while right-left>1:\n        mid=(left+right)//2\n        if cnt_shake(mid)<m:\n            right=mid\n        else:\n            left=mid\n    \n    C=n-np.searchsorted(A,right-A)\n    B=np.cumsum(A[::-1])\n    cnt=C.sum()\n    print(np.sum(A*C)+left*(m-cnt)+B[C[np.where(C>0)]-1].sum())\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom itertools import accumulate\nfrom bisect import bisect_left\n\nn, m, *a = list(map(int, sys.stdin.read().split()))\na.sort()\n\n\ndef f(x):\n    # \u5e78\u798f\u5ea6\u304cx\u672a\u6e80\u3068\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    cnt = 0\n    for ai in a:\n        cnt += bisect_left(a, x-ai)\n    # \u5e78\u798f\u5ea6\u304cx\u4ee5\u4e0a\u306e\u7d44\u307f\u5408\u308f\u305b\u306e\u500b\u6570\u304cm\u672a\u6e80\u304b\u3069\u3046\u304b\n    return n * n - cnt < m\n\n\nleft = a[0] * 2\nright = a[-1] * 2\nwhile right - left > 1:\n    mid = (right + left) // 2\n    if f(mid):\n        right = mid\n    else:\n        left = mid\nans = 0\ncumsum = [0] + list(accumulate(a))\nj = 0\nfor ai in a:\n    i = bisect_left(a, left-ai)\n    j += n - i\n    ans += ai * (n - i) + cumsum[-1] - cumsum[i]\nans += (m - j) * left\nprint(ans)\n", "# \u904e\u53bb\u306e\u63d0\u51fa\u3092\u898b\u306a\u304c\u3089\u89e3\u3044\u305f\n\ndef main():\n    N, M = list(map(int, input().split()))\n    *a, = list(map(int, input().split()))\n    a.sort()\n\n    def count(mid) -> int:\n        cnt = 0  # (i,j)>=mid \u306e\u500b\u6570\n        j = N  # j: i\u3068\u7d44\u3093\u3067\u30da\u30a2\u548c>=mid\u3092\u6e80\u305f\u3059j\u306e\u4e0b\u9650, \u521d\u671f\u5024\u306f\u7bc4\u56f2\u5916=\u6761\u4ef6\u3092\u6e80\u305f\u3059j\u306f\u306a\u3044\n        for i in range(N):\n            while j > 0 and a[i] + a[j - 1] >= mid:\n                j -= 1\n            # j==0 or a[i]+a[j]>=mid\n            # j==0\n            # \u73fe\u5728\u306ei\u306b\u5bfe\u3057\u3059\u3079\u3066\u306ea\u306e\u8981\u7d20\u304c\u76f8\u65b9\u306b\u306a\u308b\u3002\n            # \u4e00\u5ea6\u305d\u306e\u3088\u3046\u306ai\u306b\u9054\u3057\u305f\u3089\u3001\u305d\u308c\u4ee5\u964d\u306ei\u306f\u3059\u3079\u3066\u3053\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3002\n            cnt += N - j  # i\u306b\u5bfe\u3057[j,N)\u304c\u76f8\u65b9\u306b\u306a\u308b\n        return cnt\n\n    def binary_search(*, ok: int, ng: int, is_ok: 'function') -> int:\n        \"\"\"\u3042\u308b\u30da\u30a2\u548c\u4ee5\u4e0a\u306e\u307f\u63a1\u7528\u3059\u308b\u5834\u5408\u306b\n        M\u56de\u4ee5\u4e0a\u63e1\u624b\u3067\u304d\u306a\u3044\u3088\u3046\u306a\u30da\u30a2\u548c\u306e\u4e0a\u9650\"\"\"\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n\n    ma = binary_search(ok=2 * 10 ** 5 + 1, ng=0, is_ok=lambda mid: count(mid) < M)\n\n    def accumulate(a):\n        s = 0\n        yield s\n        for x in a:\n            s += x\n            yield s\n\n    *acc, = accumulate(a)\n\n    ans = 0\n    j = N  # j: i\u3068\u7d44\u3093\u3067\u30da\u30a2\u548c>=mid\u3092\u6e80\u305f\u3059j\u306e\u4e0b\u9650, \u521d\u671f\u5024\u306f\u7bc4\u56f2\u5916=\u6761\u4ef6\u3092\u6e80\u305f\u3059j\u306f\u306a\u3044\n    for i in range(N):\n        while j > 0 and a[i] + a[j - 1] >= ma:\n            j -= 1\n        ans += a[i] * (N - j) + acc[N] - acc[j]  # i\u5074\u306e\u5bc4\u4e0e=\u30da\u30a2\u6570,j\u5074\u306e\u5bc4\u4e0e=acc\n    ans += (ma - 1) * (M - count(ma))  # \u30da\u30a2\u548cma\u3067\u306fM\u30da\u30a2\u7d44\u3081\u306a\u3044\u304c\u3001ma-1\u3067\u57cb\u3081\u3089\u308c\u308b\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\n\n# \u4fa1\u5024 x \u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u5168\u3066\u884c\u3046\u3068\u3059\u308b\n# \u63e1\u624b\u56de\u6570\u304c\u6c7a\u307e\u308b\u3002\u5de6\u624b\u3054\u3068\u306b\u96c6\u8a08\u3067\u304d\u308b\u3002\n\nN, M = list(map(int, sys.stdin.readline().rstrip().split()))\nA = np.array(sys.stdin.readline().rstrip().split(), np.int64)\n\nA.sort()  # A \u3092\u6607\u9806\u306b\u4e26\u3073\u66ff\u3048\u308b\n\n# x \u3088\u308a\u4fa1\u5024\u304c\u9ad8\u304f\u306a\u308b\u63e1\u624b\u306e\u7dcf\u6570\n#  -> a \u306b\u5bfe\u3057\u3066\u3001\u76f8\u624b\u306f x - a \u304c\u5fc5\u8981\n#   -> A = [a0, a1, a2, ...] \u306b\u5bfe\u3057\u3066\u3001[x-a0\u306e\u958b\u59cb\u4f4d\u7f6e, x-a1\u306e\u958b\u59cb\u4f4d\u7f6e, x-a2\u306e\u958b\u59cb\u4f4d\u7f6e,...] \u3092\u63a2\u3059\ndef shake_cnt(x):\n    # x \u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u5168\u3066\u884c\u3046\u3068\u3057\u3066\u3001\u63e1\u624b\u306e\u56de\u6570\u3092\u6570\u3048\u308b\u884c\u308f\u306a\u3044\u63e1\u624b\u3092\u6570\u3048\u308b\n    X = np.searchsorted(A, x - A)  # \u30bd\u30fc\u30c8\u3055\u308c\u305f\u30ea\u30b9\u30c8A \u306b\u5bfe\u3057\u3066\u3001x - A \u304c\u633f\u5165\u3055\u308c\u308b\u4f4d\u7f6e\u3092\u8fd4\u3059\n    return N * N - X.sum()  # index \u306e\u548c\u306f\u300c\u5c0f\u3055\u3044\u65b9\u300d\u3092\u6307\u3057\u3066\u3044\u308b\u306e\u3067\u3001\u5f15\u304f\n\n\n# \u4e8c\u5206\u63a2\u7d22  \u63e1\u624b\u306e\u56de\u6570\u304c\nleft = 0  # \u63e1\u624b\u306e\u56de\u6570\u304cM\u4ee5\u4e0a\nright = 10 ** 6  # \u63e1\u624b\u306e\u56de\u6570\u304cM\u672a\u6e80 <- \u307e\u3060\u8db3\u308a\u306a\u3044\u5074\nwhile 1 < right - left:  # left \u3068 right \u304c\u96a3\u308a\u5408\u3063\u305f\u3089\u7d42\u4e86\n    x = (left + right) // 2\n    if shake_cnt(x) >= M:\n        left = x\n    else:\n        right = x\n\n# M\u56de\u306b\u306f\u5c4a\u304b\u306a\u3044\u3051\u308c\u3069\u3001M\u56de\u306b\u9650\u308a\u306a\u304f\u8fd1\u304f\u306a\u308b\u4fa1\u5024 x = right\nX = np.searchsorted(A, right - A)  # \u5404a in A \u304c\u63e1\u624b\u3092\u884c\u308f\u306a\u3044\u4eba\u6570\u306eArray\nshake = N * N - X.sum()  # \u3053\u3053\u307e\u3067\u306e\u63e1\u624b\u56de\u6570\n\nAcum = np.zeros(N + 1, np.int64)  # \u4eba\u6570 -> \u7d2f\u7a4d\u548c\n# Acum = [a0, a0+a1, a0+a1+a2, ....] \u3092\u8a08\u7b97\u3057\u3066\u3001ai \u3055\u3093\u304c k\u756a\u76ee\u4ee5\u964d\u3068\u63e1\u624b\u3092\u3059\u308c\u3070\nAcum[1:] = np.cumsum(A)  # cumsum [1,2,3,4,5,6,...] -> [1,3,6,10,15,21,...]\n\n# \u53f3\u624b\u306e\u5e78\u798f\u5ea6\u306f ai * ((a0+a1+...a(n-1)) - (a(k-1)+...+a(n-1))) \u3092\u5f97\u3089\u308c\u308b\n# \u5de6\u624b\u306e\u5e78\u798f\u5ea6\u306f \u56de\u6570\u3060\u3051\u3067\u6c7a\u307e\u308b\uff08\u4f55\u4eba\u3068\u63e1\u624b\u3068\u3059\u308b\u304b\uff09\nhappy = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\n\nhappy += (M - shake) * left  # \u4e0d\u8db3\u5206\u30021\u56de\u306e\u4fa1\u5024\u306f M \u3068\u308f\u304b\u3063\u3066\u3044\u308b\n\nprint(happy)\n", "import bisect\n\n\ndef is_ok(a, target, m):\n    num = 0\n    for val in a:\n        index = bisect.bisect_left(a, target - val)\n        num += len(a) - index\n    if num <= m:\n        return True\n    else:\n        return False\n\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\n\na.sort()\n\nok, ng = 10 ** 10, -1\nwhile ok - ng > 1:\n    mid = (ok + ng) // 2\n    if is_ok(a, mid, m):\n        ok = mid\n    else:\n        ng = mid\n\nrui = [0] * (n + 1)\n\nfor i in range(n):\n    rui[i+1] = rui[i] + a[i]\n\ncnt = 0\nret = 0\n\nfor val in a:\n    index = bisect.bisect_left(a, ok - val)\n    num = len(a) - index\n    cnt += num\n    ret += (num * val) + (rui[-1] - rui[index])\n\nret += (m - cnt) * ng\n\nprint(ret)\n", "from itertools import accumulate\nfrom bisect import bisect_left, bisect_right\nN, M = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\nA.sort()\nacc = list(accumulate(A[::-1]))[::-1]+[0]\n\n\ndef isok(x):\n    cnt = 0\n    for a in A:\n        cnt += N - bisect_left(A, x-a)\n    return cnt >= M\n\n\nl = 0\nr = 202020\nwhile l+1 < r:\n    m = (l+r)//2\n    if isok(m):\n        l = m\n    else:\n        r = m\n\nans = 0\ncnt = 0\nfor a in A:\n    i = bisect_left(A, l-a)\n    ans += a*(N-i) + acc[i]\n    cnt += N-i\nif cnt > M:\n    ans -= l * (cnt-M)\nprint(ans)\n", "import numpy as np\ndef convolve(A, B):\n    # \u7573\u307f\u8fbc\u307f  # \u8981\u7d20\u306f\u6574\u6570\n    # 3 \u3064\u4ee5\u4e0a\u306e\u5834\u5408\u306f\u4e00\u5ea6\u306b\u3084\u3063\u305f\u65b9\u304c\u3044\u3044\n    dtype = np.int64\n    fft, ifft = np.fft.rfft, np.fft.irfft\n    a, b = len(A), len(B)\n    if a == b == 1:\n        return np.array([A[0]*B[0]])\n    n = a+b-1  # \u8fd4\u308a\u5024\u306e\u30ea\u30b9\u30c8\u306e\u9577\u3055\n    k = 1 << (n-1).bit_length()\n    AB = np.zeros((2, k), dtype=dtype)\n    AB[0, :a] = A\n    AB[1, :b] = B\n    return np.rint(ifft(fft(AB[0]) * fft(AB[1]))).astype(np.int64)[:n]\n\nimport sys\ninput = sys.stdin.readline\nn,m = map(int, input().split())\na = list(map(int, input().split()))\n \ncnt = np.zeros(100001)\nfor i in a:\n    cnt[i] += 1 \n\nc = convolve(cnt,cnt)\nans = 0\nfor i in range(len(c))[::-1]:\n    if c[i] > 0:\n      p = min(m,c[i])\n      m -= p\n      ans += i*p\n      if m == 0:\n        break\nprint(ans)", "# https://atcoder.jp/contests/abc149/tasks/abc149_e\n\n# \u3059\u3079\u3066\u306e\u63e1\u624b\u306e\u7d44\u307f\u5408\u308f\u305bN**2\u3092\u5217\u6319\u3057\u30bd\u30fc\u30c8\u3057M\u756a\u76ee\u307e\u3067\u3092\u8db3\u3057\u5408\u308f\u305b\u308c\u3070OK\n# \u3060\u3051\u3069\u5236\u7d04\u304b\u3089\u3053\u308c\u3092\u884c\u3046\u3053\u3068\u306f\u56f0\u96e3\n# \u3059\u3079\u3066\u3092\u5217\u6319\u3057\u306a\u304f\u3068\u3082M\u756a\u76ee\u306e\u5024\u3092\u77e5\u308b\u3053\u3068\u306f\u4e8c\u5206\u63a2\u7d22\u3067\u53ef\u80fd(\u53c2\u8003:\u5104\u30de\u30b9\u8a08\u7b97)\n# A\u306e\u7d2f\u7a4d\u548c\u3092\u4fdd\u6301\u3057\u3066\u304a\u3051\u3070\u3001M\u756a\u76ee\u306e\u5024\u306e\u63a2\u7d22\u4e2d\u306bM\u307e\u3067\u306e\u5024\u306e\u5408\u8a08\u3082\u3064\u3044\u3067\u306b\u8a08\u7b97\u3067\u304d\u308b\n# \u4ee5\u4e0breverse\u3067\u30bd\u30fc\u30c8\u6e08\u307f\u3060\u3068\u4eee\u5b9a\n# X\u304cM\u756a\u76ee\u306e\u6570\u2192X\u4ee5\u4e0a\u3067\u3042\u308b\u6570\u306fM\u500b\u4ee5\u4e0a(cnt\u3068\u3059\u308b)\u2192cnt\u304cM\u500b\u4ee5\u4e0a\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3046\u3061\u306e\u6700\u5927\u3068\u306a\u308bX\u304cM\u756a\u76ee\u306e\u5024\n# \u305d\u306e\u3042\u3068\u4f59\u5206\u306a\u5206\u3092\u5f15\u304f\u51e6\u7406\u3068\u304b\u5fc5\u8981\n\nfrom bisect import bisect_right, bisect_left\nimport sys\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\nclass cumsum1d:\n    def __init__(self, ls: list):\n        '''\n        1\u6b21\u5143\u30ea\u30b9\u30c8\u3092\u53d7\u3051\u53d6\u308b\n        '''\n        from itertools import accumulate\n        self.ls_accum = [0] + list(accumulate(ls))\n\n    def total(self, i, j):\n        # \u3082\u3068\u306e\u914d\u5217ls\u306b\u304a\u3051\u308b[i,j)\u306e\u4e2d\u5408\u8a08\n        return self.ls_accum[j] - self.ls_accum[i]\n\n\nN, M = read_ints()\nA = read_ints()\nA.sort()  # bisect\u3092\u4f7f\u3046\u90fd\u5408\u4e0a reverse\u306f\u629c\u304d\nA_reversed = list(reversed(A))\nA_rev_acc = cumsum1d(A_reversed)\n\n\ndef is_ok(X):\n    # M\u756a\u76ee\u306e\u6570\u306fX\u3067\u3042\u308b\u2192X\u4ee5\u4e0a\u306e\u500b\u6570>=M \u3068\u306a\u308b\u3046\u3061\u3067\u6700\u5927\u306eX(\u3082\u3063\u3068\u3082\u5de6\u306e\u65b9\u306eX)\n    # X\u4ee5\u4e0a\u306e\u500b\u6570>=M\u3092\u8fd4\u3059\n    # X\u4ee5\u4e0b\u306e\u500b\u6570\u306fai+aj>=X\u3092\u6e80\u305f\u3059\u500b\u6570\n    cnt = 0\n    ans = 0\n    for a in A:\n        aa = X - a\n        idx_reverse = N - bisect_left(A, aa)  # \u5927\u304d\u3044\u65b9\u304b\u3089\u3060\u3068\u4f55\u756a\u76ee\u304b\n        # \u3053\u308c\u306fbisect_right(A_reversed,aa)\u306b\u7b49\u3057\u3044\n        cnt += idx_reverse\n        ans += A_rev_acc.total(0, idx_reverse) + idx_reverse * a\n    return cnt >= M, ans, cnt\n\n\ndef meguru_bisect(ng, ok):\n    '''\n    define is_ok\u3068\n    \u521d\u671f\u5024\u306eng,ok\u3092\u53d7\u3051\u53d6\u308a,is_ok\u3092\u6e80\u305f\u3059\u6700\u5c0f(\u6700\u5927)\u306eok\u3092\u8fd4\u3059\n    ng ok \u306f  \u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1 \u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n    \u6700\u5927\u6700\u5c0f\u304c\u9006\u306e\u5834\u5408\u306f\u3088\u3057\u306a\u306b\u3072\u3063\u304f\u308a\u8fd4\u3059\n    '''\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        flg, ans, cnt = is_ok(mid)\n        if flg:\n            ok = mid\n            ans_true = ans  # \u3055\u3044\u3054\u306bok\u3068\u306a\u308b\u72b6\u614b\u304cans\n            cnt_true = cnt\n        else:\n            ng = mid\n    return ans_true, ok, cnt_true\n\n\nans_tmp, M_th_num, M_plus_alpha_th = \\\n    meguru_bisect(2 * 10 ** 5 + 1, 0)\n# print(ans_tmp, M_th_num, M_plus_alpha_th)\nprint((ans_tmp - (M_plus_alpha_th - M) * M_th_num))\n", "import bisect\nn,m=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl.sort()\nr=[0]*(10**5+2)\nfor i in range(n):\n    r[l[i]]+=1\nfor i in range(10**5+1):\n    r[i+1]+=r[i]\nok=10**6\nng=0\nwhile ok-ng>1:\n    x=(ok+ng)//2\n    k=0\n    for i in range(n):\n        if x-l[i]<0:\n            k+=n\n        elif x-l[i]>10**5+1:\n            k+=0\n        else:\n            k+=n-r[x-l[i]]\n    if k>=m:\n        ng=x\n    else:\n        ok=x\n#print(ok)\np=[0]*(n+1)\nfor i in range(n):\n    p[i+1]=p[i]+l[i]\nans=0\nmi=0\nfor i in range(n):\n    li=bisect.bisect_left(l,ok-l[i])\n    ans+=l[i]*(n-li)+p[n]-p[li]\n    mi+=n-li\nprint((ans-(mi-m)*ok))\n", "import numpy as np\nfrom numpy.fft import rfft, irfft\n\nN, M = list(map(int, input().split()))\n*A, = list(map(int, input().split()))\nB = np.zeros(5*10**5)\nfor a in A:\n    B[a] += 1\n\nL = 5*10**5\nFB = rfft(B, L)\nC = np.rint(irfft(FB*FB)).astype(int)\n\nans = 0\nfor i in range(2*10**5, -1, -1):\n    c = C[i]\n    if not c:\n        continue\n    if M - c > 0:\n        ans += i*c\n        M -= c\n    else:\n        ans += i*M\n        break\nprint(ans)\n", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return list(map(int,input().split()))\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(list(map(max,x)))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\n\n\n\n\nN,M = m()\n\na = l()\n\na.sort()\n\naaa = s(a)\n\n\n\npo = [0 for i in range(10**5+2)]\nans = 0\nfor i in range(N):\n    po[a[i]] += 1\nfor i in range(10**5,-1,-1):\n    po[i] += po[i+1]\nll = 0\nrr = 10**5 * 2 + 1\n\nwhile True:\n    mid = (ll+rr)//2\n    if mid == ll:\n        co = 0\n        for i in range(N):\n            ui = a[i]\n            if mid > ui + 10**5:\n                continue\n            elif ui >= mid:\n                co += N\n            else:\n                co += po[mid-ui]\n        cco = 0\n        mid = rr\n\n        for i in range(N):\n            ui = a[i]\n            if mid > ui + 10**5:\n                continue\n            elif ui >= mid:\n                cco += N\n            else:\n                cco += po[mid-ui]\n\n        if cco == M:\n            mid = rr\n            co=cco\n\n        else:\n            mid = ll\n\n        break\n\n    co = 0\n    for i in range(N):\n        ui = a[i]\n        if mid > ui + 10**5:\n            continue\n        elif ui >= mid:\n            co += N\n        else:\n            co += po[mid-ui]\n    \n    if co < M:\n        rr = mid                 \n    else:\n        ll = mid\n\n\na.sort(reverse = True)\ndp = [0]\n\nans -= mid * (co - M)\n\n\n\nfor i in range(N):\n    dp.append(dp[-1]+a[i])\n\nfor i in range(N):\n    pl = a[i]\n    if pl >= mid:\n        ans += pl*N + dp[-1]\n        \n    elif pl + 10**5 < mid:\n        continue\n    else:\n        ans += pl*po[mid-pl] + dp[po[mid-pl]]\nprint(ans)\n\n\n\n", "#!/usr/bin/env python3\n\nimport sys, heapq, bisect\nsys.setrecursionlimit(300000)\n\ndef _count(A, n, v):\n    ret = 0\n    for a in A:\n        target = v - a\n        idx = bisect.bisect_left(A, target)\n        ret += n - idx\n    return ret\n\ndef _sum(A, n, v, sums):\n    ss = 0\n    for a in A:\n        target = v - a\n        idx = bisect.bisect_left(A, target)\n        ss += sums[n] - sums[idx]\n        ss += (n - idx) * a\n    #print(mins)\n    return ss\n\ndef solve(N: int, M: int, A: \"List[int]\"):\n    A.sort()\n    sums = [0]\n    for a in A:\n        sums.append(sums[-1] + a)\n    l = -1\n    r = max(A) * 2 + 1\n    while r - l > 1:\n        m = (r + l) // 2\n        cnt = _count(A, N, m)\n        if cnt >= M:\n            l = m\n        else:\n            r = m\n    cnt = _count(A, N, l)\n    ret = _sum(A, N, l, sums)\n    ret -= (cnt - M) * l\n    print(ret)\n    return ret\n\n\ndef solve_(N: int, M: int, A: \"List[int]\"):\n    A.sort(reverse=True)\n    q = [(-A[0] * 2, 0, 0)]\n    ret = 0\n    cnt = 0\n    while cnt < M:\n        s, i, j = heapq.heappop(q)\n        ret += -s\n        cnt += 1\n        print((i, j))\n        if i == j and i < N - 1:\n            heapq.heappush(q, (-A[i] + -A[i + 1], i, i + 1))\n        else:\n            if cnt < M:\n                ret += -s\n                cnt += 1\n                print((j, i))\n            heapq.heappush(q, (-A[i + 1] + -A[j], i + 1, j))\n            if j < N - 1:\n                heapq.heappush(q, (-A[i] + -A[j + 1], i, j + 1))\n    print(ret)\n    return\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, M, A)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nimport itertools\nimport numpy as np\n\ndef search_cut(N, M, A):\n    high_cut = A[-1] * 2\n    low_cut = A[0] * 2\n\n    while high_cut > low_cut + 1:\n        mid = (high_cut + low_cut) // 2\n        count = (N  - np.searchsorted(A, mid - A, side = 'left')).sum()\n\n        if count > M:\n            low_cut = mid\n        else:\n            high_cut = mid\n\n    return low_cut, high_cut\n\ndef happiness(N, M, A, low_cut, high_cut):\n    A_sum = np.zeros(N + 1)\n    A_sum[1:] = np.cumsum(A)\n    X = np.searchsorted(A, high_cut - A, side = 'left')\n    happiness = (A_sum[-1] - A_sum[X]).sum()\n    happiness += ((N - X) * A).sum()\n    happiness += (M - (N - X).sum()) * low_cut\n\n    return int(happiness)\n\n\nN, M = list(map(int, input().split()))\nA = np.array(list(map(int, input().split())))\nA = np.sort(A)\n\nlow_cut, high_cut = search_cut(N, M, A)\nans = happiness(N, M, A, low_cut, high_cut)\nprint(ans)\n", "ii = lambda : int(input())\nmi = lambda : list(map(int,input().split()))\nli = lambda : list(map(int,input().split()))\n\nn,m = mi()\nalis = li()\n\nalis.sort()\nok = 0\nng = alis[n-1] * 2 +1\nfrom bisect import bisect_left as bl\nwhile ng - ok >1:\n    mid = (ok + ng)//2\n    ima = 0\n    for i in range(n):\n        ima += n - bl(alis,mid-alis[i])\n    if ima >= m:\n        ok = mid\n        outrange = ima - m\n    else:\n        ng = mid\n\nacu_alis = [0]*n\nima = 0\nfor i in range(n):\n    acu_alis[i] = alis[i] + ima\n    ima = alis[i] + ima\n\nans = 0\nfor i in range(n):\n    tmp = bl(alis,ok-alis[i]) \n    if tmp ==0:\n        ans += n*alis[i] + acu_alis[n-1]\n    else:\n        ans += (n-tmp)*alis[i] + acu_alis[n-1] - acu_alis[tmp-1]\nans -= outrange*ok\nprint(ans)\n\n\n", "n,m=map(int,input().split())\narr=list(map(int,input().split()))\narr=sorted(arr,reverse=True)\nacum=[arr[0]]\nfor i in range(1,n):\n  acum.append(acum[-1]+arr[i])\nl=0\nr=2*10**5+1\nwhile r-l!=1:\n  mid=(l+r)//2\n  tmp=0\n  cnt=0\n  pos=n-1\n  for i in range(n):\n    while pos!=-1:\n      if arr[i]+arr[pos]>=mid:\n        cnt+=pos+1\n        tmp+=arr[i]*(pos+1)+acum[pos]\n        break\n      else:\n        pos-=1\n        if pos==-1:\n          break\n  if cnt<=m:\n    r=mid\n  else:\n    l=mid\ntmp+=(m-cnt)*l\nprint(tmp)", "from bisect import bisect_left\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\n\ndef count(x):\n    ret = 0\n    for a in A:\n        ret += N - bisect_left(A, x - a)\n    return ret\n\noverEq = 0\nless = 10**7\nwhile less - overEq > 1:\n    mid = (less + overEq) // 2\n    if count(mid) >= M:\n        overEq = mid\n    else:\n        less = mid\n\nans = 0\ncnt = [0] * N\nfor a in A:\n    i = (N - bisect_left(A, overEq - a))\n    ans += i * a\n    if i > 0:\n        cnt[-i] += 1\nfor i in range(1, N):\n    cnt[i] += cnt[i - 1]\nfor a, c in zip(A, cnt):\n    ans += a * c\n\nans -= overEq * (count(overEq) - M)\n\nprint(ans)\n", "def main():\n    from bisect import bisect_left as bl\n    from itertools import accumulate as ac\n\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    aa = [0]+list(ac(a))\n    an = aa[n]\n\n    ok = 0\n    ng = 10**10\n    while abs(ok-ng) > 1:\n        mid = (ok+ng)//2\n        if sum([n-bl(a, mid-a[i]) for i in range(n)]) >= m:\n            ok = mid\n        else:\n            ng = mid\n\n    c = -m+sum([n-bl(a, ok-a[i]) for i in range(n)])\n    ans = -c*ok\n    for i in range(n):\n        d = bl(a, ok-a[i])\n        ans += an-aa[d]+(n-d)*a[i]\n    print(ans)\n\n\nmain()", "def e_handshake():\n    import numpy as np\n    N, M = [int(i) for i in input().split()]\n    A = np.array(input().split(), np.int64)\n    A.sort()\n\n    def shake_cnt(x):\n        # \u5e78\u798f\u5ea6\u304c x \u4ee5\u4e0a\u3068\u306a\u308b\u3088\u3046\u306a\u63e1\u624b\u3092\u5168\u3066\u884c\u3046\u3068\u304d\u306e\u63e1\u624b\u306e\u56de\u6570\n        # \u5168\u4f53\u304b\u3089\u884c\u308f\u306a\u3044\u63e1\u624b\u56de\u6570\u3092\u5f15\u304f\n        return N**2 - np.searchsorted(A, x - A).sum()\n\n    # \u5e78\u798f\u5ea6\u306e\u4e0a\u6607\u304c right \u4ee5\u4e0a\u3068\u306a\u308b\u3088\u3046\u306a\u63e1\u624b\u306f\u3059\u3079\u3066\u884c\u3044\u3001\n    # left \u3068\u306a\u308b\u3088\u3046\u306a\u63e1\u624b\u306f\u3044\u304f\u3064\u304b\u884c\u3063\u3066\u63e1\u624b\u56de\u6570\u304c M \u56de\u306b\u306a\u308b\u3088\u3046\u306b\u3059\u308b\n    left = 0\n    right = 10 ** 6\n    while right - left > 1:\n        mid = (left + right) // 2\n        if shake_cnt(mid) >= M:\n            left = mid\n        else:\n            right = mid\n\n    # \u5e78\u798f\u5ea6\u304c right \u4ee5\u4e0a\u4e0a\u304c\u308b\u3088\u3046\u306a\u63e1\u624b\u3092\u3059\u3079\u3066\u884c\u3063\u305f\u3068\u3057\u3066\u3001\u56de\u6570\u3068\u7dcf\u548c\u3092\u8a08\u7b97\n    X = np.searchsorted(A, right - A)  # \u884c\u308f\u306a\u3044\u4eba\u6570\n    Acum = np.zeros(N + 1, np.int64)  # \u7d2f\u7a4d\u548c\u3067\u7ba1\u7406\u3059\u308b\n    Acum[1:] = np.cumsum(A)\n    happiness = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\n\n    # \u5e78\u798f\u5ea6\u304c right \u672a\u6e80\u306e\u4e0a\u6607\u3068\u306a\u308b\u63e1\u624b\u3092\u3001\u63e1\u624b\u56de\u6570\u304c M \u306b\u306a\u308b\u307e\u3067\u8ffd\u52a0\u3067\u884c\u3046\n    shake = N * N - X.sum()\n    happiness += (M - shake) * left\n    return happiness\n\nprint(e_handshake())", "import numpy as np\nfrom numpy.fft import rfft,irfft\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\na = np.zeros(10**5+1)\nfor i in range(N):\n    a[A[i]] += 1\nb = rfft(a,2*10**5+1)\nb = irfft(b*b,2*10**5+1)\nb = np.rint(b).astype(np.int64)\nc = 0\nans = 0\nfor n in range(2*10**5,1,-1):\n    if c+b[n]<M:\n        c += b[n]\n        ans += b[n]*n\n    else:\n        ans += (M-c)*n\n        c = M\n        break\nprint(ans)", "\nimport numpy as np\nN, M = list(map(int, input().split()))\nA = np.array(input().split(), dtype=np.int32)\n\nx = np.bincount(A)\nfft_size = 1 << (2 * x.size + 10).bit_length()\n\nfx = np.fft.rfft(x, fft_size)\nconv = np.fft.irfft(fx * fx, fft_size)\nconv = (conv + 0.5).astype(int)\n\ntmp = np.arange(conv.size, dtype=int)\nhappy = tmp[np.nonzero(conv)].tolist()\ncnt = conv[np.nonzero(conv)].tolist()\n\n\nans = 0\nwhile M > 0:\n    h = happy.pop()\n    num = cnt.pop()\n    num = min(M, num)\n\n    M -= num\n    ans += num * h\n\nprint(ans)\n", "\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\ndef resolve():\n    def getCount(x):\n        cnt = 0\n        for a in A:\n            # X\u672a\u6e80\u306e\u500b\u6570\n            idx = bisect_left(A, x - a)\n            # X\u4ee5\u4e0a\u306e\u500b\u6570\n            cnt += N - idx\n        # X\u4ee5\u4e0a\u3092\u4f7f\u3046\uff01\u3068\u6c7a\u3081\u305f\u6642\u3001M\u500b\u4ee5\u4e0a\u306b\u306a\u308b\u304b\n        return cnt >= M\n\n    N, M = list(map(int, input().split()))\n    A = sorted(map(int, input().split()))\n\n    ng = 10 ** 9\n    ok = 0\n    # X\u4ee5\u4e0a\u3092\u4f7f\u3046\uff01\u3068\u6c7a\u3081\u308b\u3068X\u4ee5\u4e0a\u306e\u500b\u6570\u304c\u81ea\u660e\u306b\u308f\u304b\u308b\u3002\n    while ng - ok > 1:\n        mid = (ok + ng) // 2\n        if getCount(mid):\n            ok = mid\n        else:\n            ng = mid\n\n    # M\u500b\u4ee5\u4e0a\u3042\u308b\u3053\u3068\u304c\u308f\u304b\u308c\u3070\u3001M\u3088\u308a\u3082\u4f59\u5206\u306a\u6570(\u540c\u3058\u5024\u304c\u8907\u6570\u3042\u308b\u5834\u5408)\n    # \u306f\u3059\u3079\u3066X\u3067\u3042\u308b\u4e8b\u304c\u308f\u304b\u308b\u305f\u3081\u3001\u5dee\u5206\u3060\u3051\u5f15\u3051\u3070\u826f\u3044\u3002\n    B = [0] + list(accumulate(A))\n    ans = 0\n    cnt = 0\n    for i in range(N):\n        idx = bisect_left(A, ok - A[i])\n        ans += B[N] - B[idx] + A[i] * (N - idx)\n        cnt += N - idx\n\n    rest = (cnt - M) * ok\n    print((ans - rest))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_left\n\nN, M = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())))\nl = 0\nr = 2*10**5+5\n\n\nwhile l+1 < r:\n    mid = (l+r) // 2\n    \n    m = 0\n    for a in A:\n        idx = bisect_left(A, mid-a)\n        m += N-idx\n        \n    if m >= M: l = mid\n    else: r = mid\n\ns = [0] * (N+1)\nfor i in range(N):\n    s[i+1] = s[i] + A[i]\n    \nans = 0\nm = 0\nfor a in A:\n    idx = bisect_left(A, l-a)\n    m += N-idx\n    \n    ans += s[N]-s[idx]\n    ans += a*(N-idx)\n    \nans -= (m-M)*l\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nimport bisect\nfrom itertools import accumulate\n\nN, M = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\nA.sort()\n\nleft = -1\nright = 1 + 2 * 10 ** 5\n\ndef shake(x):\n    cnt = 0\n    for i in A:\n        cnt += N - bisect.bisect_left(A, x - i)\n    if cnt >= M:\n        return 1\n    else:\n        return 0\n\nwhile True:\n    mid = (left + right) // 2\n    if shake(mid):\n        if not shake(mid + 1):\n            X = mid\n            break\n        else:\n            left = mid\n    else:\n        if shake(mid - 1):\n            X = mid - 1\n            break\n        else:\n            right = mid\n\nhappy = 0\ncumsum_A = list(accumulate(A))\n\nfor j in A:\n    idx = bisect.bisect_right(A, X - j)\n    cnt = N - idx\n    if cnt == N:\n        happy += cumsum_A[-1] + cnt * j\n    else:\n        happy += cumsum_A[-1] - cumsum_A[idx - 1] + cnt * j\n    M -= cnt\n\nhappy += M * X\n\nprint(happy)\n", "from bisect import bisect_left, bisect_right\nfrom itertools import accumulate\n\ndef solve():\n    N, M = list(map(int, input().split()))\n    As = list(map(int, input().split()))\n\n    As.sort()\n\n    def isOK(x):\n        num = 0\n        for k, A in enumerate(As, start=1):\n            i = bisect_left(As, x-A)\n            num += N-i\n            if num >= M:\n                return True\n            elif num + (N-k)*N < M:\n                return False\n        return num >= M\n\n    ng, ok = 2*10**5+1, 0\n    while abs(ok-ng) > 1:\n        mid = (ng+ok) // 2\n        if isOK(mid):\n            ok = mid\n        else:\n            ng = mid\n#    print('ok:', ok)\n\n    score = 0\n    num = 0\n    accAs = list(accumulate([0]+As))\n    for A in As:\n        i = bisect_right(As, ok-A)\n        score += A*(N-i) + accAs[N] - accAs[i]\n        num += N-i\n#    print('score:', score, '/ num:', num)\n\n    ans = score + ok*(M-num)\n    print(ans)\n\n\nsolve()\n", "def binary_search(*, ok, ng, is_ok):\n    while abs(ok - ng) > 1:\n        mid = (ng + ok) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n\ndef main():\n    from itertools import accumulate\n\n    N, M = list(map(int, input().split()))\n    *A, = sorted(map(int, input().split()))\n\n    acc = [0]\n    for x in accumulate(A):\n        acc.append(x)\n\n    def count(h):\n        ret = 0\n\n        j = N\n        for i in range(N):\n            while j - 1 >= 0 and A[i] + A[j - 1] >= h:\n                j -= 1\n            ret += N - j\n            # [j,N)\u306e\u8981\u7d20\u6570\n\n        return ret\n\n    x = binary_search(ok=A[-1] * 2 + 1, ng=0, is_ok=lambda x: count(x) < M)\n    # \u5e78\u798f\u5ea6\u306e\u7dcf\u548c\u304cX\u4ee5\u4e0a\u306e\u30da\u30a2\u6570\u304cM\u672a\u6e80\u3068\u306a\u308b\u6700\u5927\u306eX\n\n    s = 0\n    j = N\n    for i in range(N):\n        while j - 1 >= 0 and A[i] + A[j - 1] >= x:\n            j -= 1\n        s += A[i] * (N - j) + acc[N] - acc[j]\n    s += (M - count(x)) * (x - 1)\n\n    print(s)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nmaxA = max(A)\ncnt = [0] * (maxA * 2 + 2)\nrui = [n] * (maxA * 2 + 2)\n\nfor a in A:\n  cnt[a] += 1\n\naccum = 0  \nfor i in range(maxA * 2 + 1):\n  accum += cnt[i]\n  rui[i + 1] -= accum \n  \n# \u5de6\u624b\u3092\u6c7a\u3081\u305f\u6642(left)\u306b\u3001\u5e78\u798f\u5ea6\u304cx \u4ee5\u4e0a\u3068\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306e\u6570\u3092\u8fd4\u3059\ndef f(x):\n  ret = 0\n  for left in A:\n    ret += rui[max(x - left, 0)]\n  return ret\n  \nlo = 0\nhi = maxA * 2 + 1\nwhile hi - lo > 1:\n  md = (lo + hi) // 2\n  if f(md) >= m:\n    lo = md\n  else:\n    hi = md \n# \u3082\u3068\u307e\u308b lo \u304c m \u901a\u308a\u4ee5\u4e0a\u63e1\u624b\u304c\u3067\u304d\u308b\u6700\u5c0f\u306e\u6570\u3002\n    \nruiA = [0] * (n + 1)\nfor i in range(n):\n  ruiA[i + 1] = ruiA[i] + A[i]\n\nans = 0\ncnt = 0\nfor i in range(n):\n  pos = bisect_left(A, lo - A[i])\n  cnt += n - pos\n  ans += ruiA[-1] - ruiA[pos] + A[i] * (n - pos)\nif cnt == m:\n  print(ans)\nelse: # m\u500b\u3088\u308a\u3082\u591a\u3044\u5206\u3092\u5f15\u304f\n  rem = cnt - m\n  print(ans - rem * lo)", "import numpy as np\nn, k = list(map(int, input().split()))\na = np.array(list(map(int, input().split())))\na.sort()\nl, r = 0, 10000000000\nwhile r - l > 1:\n    m = (l + r) // 2\n    res = n * n - a.searchsorted(m - a).sum()\n    if res >= k:\n        l = m\n    else:\n        r = m\nb = np.array([0] * (n + 1))\nfor i in range(1, n + 1):\n    b[i] = b[i - 1] + a[n - i]\ncnt = 0\nans = 0\nfor x in a:\n    t = n - a.searchsorted(l - x)\n    ans += b[t] + x * t\n    cnt += t\nprint((ans - (cnt - k) * l))\n", "import sys\ninput = sys.stdin.readline\n\nmm = 10**10\nk = mm.bit_length()\nK = 1<<k\nnu = lambda L: int(\"\".join([bin(K+a)[-k:] for a in L[::-1]]), 2)\nst = lambda n: bin(n)[2:] + \"0\"\nli = lambda s: [int(a, 2) if len(a) else 0 for a in [s[-(i+1)*k-1:-i*k-1] for i in range(200001)]]\n\nn,m = map(int, input().split())\na = [int(i) for i in input().split()]\nb = [0]*100001\n\nfor i in a:\n    b[i] += 1\n    \nc = li(st(nu(b)*nu(b)))\nans = 0\nfor i in range(200001)[::-1]:\n    if c[i] > 0:\n      p = min(m,c[i])\n      m -= p\n      ans += i*p\n      if m == 0:\n        break\nprint(ans)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n\"\"\" \u3069\u306e\u30d1\u30ef\u30fc\u4ee5\u4e0a\u306e\u7d44\u307f\u5408\u308f\u305b\u307e\u3067\u63e1\u624b\u3059\u308b\u306e\u304b\u4e8c\u5206\u63a2\u7d22\u3067\u8abf\u3079\u308b\n    \u540c\u3058\u30d1\u30ef\u30fc\u3068\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306b\u6ce8\u610f \"\"\"\nN, M = lr()\nA = np.array(lr())\nA.sort()\n\ndef check(x):\n    # x\u4ee5\u4e0a\u306e\u5e78\u798f\u5ea6\u3067\u63e1\u624b\u3057\u305f\u6642\u3001M\u56de\u4ee5\u4e0b\u3060\u3068True\u3092\u8fd4\u3059\n    Y = np.searchsorted(A, x - A)\n    return N*N - Y.sum() <= M\n\nok = 10 ** 6; ng = 0\nwhile abs(ng-ok) > 1:\n    mid = (ok+ng) // 2\n    if check(mid):\n        ok = mid\n    else:\n        ng = mid\n\nAcum = np.zeros(N+1, np.int64)\nAcum[1:] = A.cumsum()\nY = np.searchsorted(A, ok-A)\nanswer = (Acum[-1] - Acum[Y]).sum() + (A * (N-Y)).sum()\nanswer += ng * (M - (N-Y).sum())\nprint(answer)\n# 24\n", "def judge(k, N, A):\n    p = N - 1\n    t = 0\n    for i in A:\n        while p >= 0 and A[p] + i < k:\n            p -= 1\n        t += (p + 1)\n    return t\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort(reverse=True)\n    t = A[0] * 2\n    b = 0\n    X = None\n    while t - b > 1:\n        m = (t + b)//2\n        i = judge(m, N, A)\n        if i == M:\n            X = m\n            break\n        if i > M:\n            ip = judge(m + 1, N, A)\n            if ip == M:\n                X = m + 1\n                break\n            if ip < M:\n                X = m\n                break\n            b = m + 1\n        if i < M:\n            im = judge(m - 1, N, A)\n            if im >= M:\n                X = m - 1\n                break\n            t = m - 1\n    if X is None:\n        X = b\n    r = 0\n    p = N - 1\n    k = sum(A)\n    for i in A:\n        while p >= 0 and A[p] + i < X :\n            k -= A[p]\n            p -= 1\n        r += i * (p + 1) + k\n    return r - (judge(X, N, A) - M) * X\nprint((main()))\n", "from bisect import bisect_left\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA.sort()\n\ndef isOverEq(n):\n    cnt = 0\n    for a in A:\n        cnt += N - bisect_left(A, n - a)\n    return cnt >= M\n\noverEq = -1\nless = A[-1] * 2 + 100\nwhile less - overEq > 1:\n    mid = (less + overEq) // 2\n    if isOverEq(mid):\n        overEq = mid\n    else:\n        less = mid\n\naccA = [0] * (N + 1)\nfor i, a in enumerate(A, start=1):\n    accA[i] = accA[i - 1] + a\n\nans = 0\ncnt = 0\nfor a in A:\n    i = bisect_left(A, overEq - a)\n    ans += accA[N] - accA[i]\n    ans += (N - i) * a\n    cnt += N - i\n\nans -= max(0, cnt - M) * overEq\nprint(ans)\n", "from bisect import bisect_left\nfrom itertools import accumulate\nN,M,*A = map(int, open(0).read().split())\nA.sort()\nB = list(accumulate(A[::-1]))\nl = -1\nr = 10**9\nwhile l+1<r:\n  s = (l+r)//2\n  cnt = 0\n  for c in A:\n    i = bisect_left(A,s-c)\n    cnt += N-i\n  if cnt>=M:\n    l = s\n  else:\n    r = s\nans = 0\nfor c in A:\n  i = bisect_left(A,r-c)\n  M -= N-i\n  if i<N:\n    ans += B[N-1-i]+c*(N-i)\nans += M*l\nprint(ans)", "import numpy as np\n\nn, m = list(map(int, input().split()))\nA = np.array(input().split(), np.int64)\nA = np.sort(A)\n\ndef is_ok(x):\n    cnt = n**2-np.searchsorted(A, x-A, side='left').sum()\n    if cnt >= m:\n        return True\n    else:\n        return False\n\nl = 0\nr = 2*10**5+1\nwhile l+1 < r:\n    c = (l+r)//2\n    if is_ok(c):\n        l = c\n    else:\n        r = c\n\nfrom itertools import accumulate\nB = [0]+list(A)\nB = list(accumulate(B))\nans = 0\ncnt = 0\nfor a in A:\n    j = np.searchsorted(A, l-a, side='left').sum()\n    cnt += n-j\n    ans += B[-1]-B[j]+a*(n-j)\nans -= (cnt-m)*l\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\ndef func(A, N, M, x):\n    count = 0\n    for Ai in A:\n        idx = bisect_left(A, x - Ai)\n        count += N - idx\n    if count >= M:\n        return True\n    else:\n        return False\n\ndef main():\n    N, M = map(int, input().split())\n    A = sorted(list(map(int, input().split())))\n    A_rev = list(reversed(A))\n    B = [0] + list(accumulate(A_rev))\n \n    min_ = 0\n    max_ = 2 * 10 ** 5 + 1\n    while max_ - min_ > 1:\n        mid = (min_ + max_) // 2\n        if func(A, N, M, mid):\n            min_ = mid\n        else:\n            max_ = mid\n    \n    ans = 0\n    count = 0\n    for Ai in A_rev:\n        idx = bisect_left(A, min_-Ai)\n        ans += Ai * (N - idx) + B[N-idx]\n        count += N - idx\n    print(ans-(count-M)*min_)\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nN,M,*A = list(map(int, open(0).read().split()))\nA = np.sort(A)\nB = np.cumsum(np.concatenate([[0],A[::-1]]))\nl = -1\nr = 10**6\nwhile l+1<r:\n  s = (l+r)//2\n  cnt = np.sum(N-np.searchsorted(A,s-A))\n  if cnt>=M:\n    l = s\n  else:\n    r = s\nind = np.searchsorted(A,r-A)\nM -= np.sum(N-ind)\nans = np.sum(B[N-ind]+A*(N-ind))+M*l\nprint(ans)\n", "def main():\n    import bisect\n    import numpy as np\n    n,k = map(int,input().split())\n    l = list(map(int,input().split()))\n    l.sort()\n    l = np.array(l)\n    def bise(x):\n        y = np.searchsorted(l,x-l)\n        return n*n-y.sum()\n\n    left = -1\n    right = l[-1]*2+1\n\n    while right > left+1:\n        mid = (right+left)//2\n        \n        if bise(mid) >= k:\n            left = mid\n        else:\n            right = mid\n    ans = 0\n    \n    acc = np.zeros(n+1,np.int64)\n    acc[1:] = l.cumsum()\n    x = np.searchsorted(l,right-l)\n    count = n*n-x.sum()\n    ans = (acc[-1]-acc[x]).sum() + (l*(n-x)).sum()\n\n    print(ans-(count-k)*left)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nA = sorted(list(map(int,readline().split())))\n\nok = -1\nng = (10 ** 5) * 2 + 1\n\n# x\u4ee5\u4e0a\u306e\u63e1\u624b\u30da\u30a2\u3092M\u56de\u4ee5\u4e0a\u4f5c\u308c\u308b\u304b\u3001\u3067x\u306e\u6700\u5927\u5024\u3092\u4e8c\u5206\u63a2\u7d22\nimport bisect\ndef isOk(x):\n  cnt = 0\n  for left in A:\n    right = x - left\n    ind = bisect.bisect_left(A, right)\n    cnt += N - ind\n  return cnt >= M\n  \nwhile abs(ng - ok) > 1:\n  mid = abs(ng + ok) // 2\n  if isOk(mid):\n    ok = mid\n  else:\n    ng = mid\n\n# ok\u304c\u57fa\u6e96\u3068\u3059\u3079\u304dx\u306e\u5024\u3067\u3042\u308b\n\nsumA = [0] + A.copy()\nfor i in range(1, len(sumA)):\n  sumA[i] += sumA[i - 1]\n\nans = 0\nnum = 0\nfor left in A:\n  right = ok - left\n  ind = bisect.bisect_left(A, right)\n  num += N - ind\n  ans += (N - ind) * left + sumA[-1] - sumA[ind]\n  \nif num > M:\n  ans -= (num - M) * ok\n  \nprint(ans)  ", "\nfrom bisect import bisect_left, bisect_right\nfrom itertools import accumulate\ndef resolve():\n    def shake_cnt(x):\n        cnt = 0\n        pos = 0\n        for i in range(N):\n            pos = bisect_left(A, x - A[i])\n            cnt += N - pos\n        return cnt < M # X\u4ee5\u4e0a\u306e\u548c\u304cM\u500b\u672a\u6e80\u304b\u3069\u3046\u304b\n\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n\n    # \u7d42\u4e86\u6642\u306bng\u306bX-1,ok\u306bX\u304c\u5165\u3063\u3066\u3044\u308b\u3002\n    ng = 0\n    ok = 10 ** 6\n    while abs(ok - ng) > 1:\n        mid = (ok + ng)//2\n        if shake_cnt(mid):\n            ok = mid\n        else:\n            ng = mid\n\n    acc = [0] + list(accumulate(A))\n    ans = 0\n    for i in range(N):\n        pos = bisect_right(A, ng - A[i])\n        cnt = N - pos\n        ans += cnt * A[i] + (acc[N] - acc[pos])\n        M -= cnt\n    ans += M * ng\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nimport numpy as np\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninl = lambda: [int(x) for x in sys.stdin.readline().split()]\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\n\ndef convolve(f, g):\n    \"\"\"\u591a\u9805\u5f0f f, g \u306e\u7a4d\u3092\u8a08\u7b97\u3059\u308b\u3002\n\n    Parameters\n    ----------\n    f : np.ndarray (int64)\n        f[i] \u306b\u3001x^i \u306e\u4fc2\u6570\u304c\u5165\u3063\u3066\u3044\u308b\n\n    g : np.ndarray (int64)\n        g[i] \u306b\u3001x^i \u306e\u4fc2\u6570\u304c\u5165\u3063\u3066\u3044\u308b\n\n\n    Returns\n    -------\n    h : np.ndarray\n        f,g \u306e\u7a4d\n    \"\"\"\n    # h \u306e\u9577\u3055\u4ee5\u4e0a\u306e n=2^k \u3092\u8a08\u7b97\n    fft_len = 1\n    while 2 * fft_len < len(f) + len(g) - 1:\n        fft_len *= 2\n    fft_len *= 2\n\n    # \u30d5\u30fc\u30ea\u30a8\u5909\u63db\n    Ff = np.fft.rfft(f, fft_len)\n    Fg = np.fft.rfft(g, fft_len)\n\n    # \u5404\u70b9\u7a4d\n    Fh = Ff * Fg\n\n    # \u30d5\u30fc\u30ea\u30a8\u9006\u5909\u63db\n    h = np.fft.irfft(Fh, fft_len)\n\n    # \u5c0f\u6570\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u3001\u6574\u6570\u306b\u307e\u308b\u3081\u308b\n    h = np.rint(h).astype(np.int64)\n\n    return h\n\n\nN, M = inl()\nA = inl()\n\npower = np.zeros(10 ** 5 + 1, dtype=np.int64)\nfor i in range(N):\n    power[A[i]] += 1\n\nP = convolve(power, power)\n\nr = M\nans = 0\nfor k in range(len(P) - 1, -1, -1):\n    c = min(P[k], r)\n    ans += k * c\n    r -= c\n    if r <= 0:\n        break\n\nprint(ans)\n", "import numpy as np\nfrom numpy.fft import rfft,irfft\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return list(map(int,input().split()))\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print((\"-------\\n{}\\n-------\".format(text)))\n\nINF=10**20\nclass Polynomial:\n    def __init__(self,dim=0,const=1):\n        self.values = [(dim,const)]\n    def __add__(self,other):\n        return self.values + other.values\n\n\nclass PolySolver:\n    def __init__(self,size,init_val=1):\n        self.size = size\n        self.f = np.zeros(size, np.int64)\n        self.f[0] = init_val\n\n\n    def multiple(self,polynomial,MOD): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u304b\u3051\u5408\u308f\u305b\u308b\n        new_F = np.zeros(self.size, np.int64)\n        for dim,const in polynomial:\n            if dim != 0:\n                g = np.zeros(self.size, np.int64)\n                g[dim:] += self.f[:-dim] # dim\u5206\u4fc2\u6570\u60c5\u5831\u3092\u305a\u3089\u3059\n            else:\n                g = const * self.f.copy()\n\n            new_F += g\n\n        self.f = new_F\n        \n    \n    def add(self,polynomial): # const1 * x^dim1 + const2 * x^dim2 + ... \u3092f\u306b\u8db3\u3059\n        for dim,const in polynomial:\n            self.f[dim] += const\n            \n\n    def get_coefficient(self,dim):\n        return self.f[dim]\n\n    def fft(self,A,B,fft_len=1<<18):\n        x = irfft(rfft(A,fft_len) * rfft(B,fft_len))\n        return np.rint(x).astype(np.int64)\n\n    def convolve(self,g):\n        h = self.fft(self.f,g)[:len(self.f) + len(g) - 1]\n        self.f = h\n    \n\n\ndef main():\n    N,M=mi()\n    A=list(mi())\n    \n    mx = 2*10**5+10\n    F = PolySolver(mx,init_val=0)\n    for a in A:\n        F.add(Polynomial(dim=a).values)\n    \n    g = F.f\n    F.convolve(g)\n\n    ans = 0\n    handshake = M\n    for x in range(mx-1,1,-1):\n        count = F.get_coefficient(x)\n        if count <= 0: continue\n\n        if count > handshake:\n            ans += handshake * x\n        else:\n            ans += count * x\n \n        handshake = max(handshake-count,0)\n        if handshake == 0:\n            break\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport  math\nimport fractions\nfrom collections import defaultdict\nimport bisect\nstdin = sys.stdin\n     \nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n\nN,M=nm()\nA=nl()\nA.sort()\nS=[0]\nS[0]=A[0]\n\nfor i in range(1,N):\n    S.append(S[i-1]+A[i])\n\ndef clc_shake(x):#x\u4ee5\u4e0a\u306e\u548c\n    tot=0\n    for i in range(N):\n        th=x-A[i]\n        inds=bisect.bisect_left(A,th)\n        tot+=(N-inds)\n    return tot\n\nl=0\nr=2*(10**6)\nc=0\n\nwhile (l+1<r):\n    c=(l+r)//2\n    if(clc_shake(c)<M):\n        r=c\n    else:\n        l=c\n\n\nans=0\nfor i in range(N):\n        th=r-A[i]\n        inds=bisect.bisect_left(A,th)\n        if(inds!=0):\n            ans+=((N-inds)*A[i]+(S[N-1]-S[inds-1]))\n        else:\n            ans+=((N-inds)*A[i]+(S[N-1]))\n\n\nM2=M-clc_shake(r)\nans+=M2*(l)\nprint(ans)\n\n\n\n", "import bisect\nn,m = list(map(int,input().split()))\nA = list(map(int,input().split()))\nA.sort()\nS = [0]*(n+1)\nfor i in range(n):\n    S[i+1] = S[i] + A[i]\n\ndef cnt(x,A,S):\n    res = 0\n    for i,a in enumerate(A):\n        res += bisect.bisect_left(A,x - a)\n    return res\n\ndef ans(x,A,S):\n    res = 0\n    for i,a in enumerate(A):\n        res += a*bisect.bisect_left(A,x-a) + S[bisect.bisect_left(A,x-a)]\n    return res\n\ntop = A[-1]*2+1\nbottom = 0\n# mid\u4ee5\u4e0a\u304c\u4f55\u500b\u3042\u308b\u304b\nwhile top - bottom > 1:\n    mid = (top + bottom)//2\n    if n*n - cnt(mid,A,S) > m:\n        bottom = mid\n    else:\n        top = mid\n\nprint((S[-1]*2*n - ans(top,A,S) + bottom*(m - (n*n - cnt(top,A,S)))))\n", "from bisect import bisect_left\ndef check(x):\n  cnt=0\n  l=n\n  r=n\n  for i in range(n):\n    while True:\n      if l==0:\n        break\n      if a[l-1]<x-a[i]:\n        break\n      l-=1\n    cnt+=(r-l)\n  return cnt>=m\n\nn,m=list(map(int,input().split()))\na=list(map(int,input().split()))\na.sort()\nok=0\nng=2*10**5+10\n# \u5e78\u798f\u5ea6\u304c\u4e0a\u4f4dm\u500b\u306b\u5165\u308b\u6700\u5c0f\u306eAx+Ay\u3092\u4e8c\u5206\u63a2\u7d22\u3059\u308b\u3002\nwhile abs(ok-ng)>1:\n  mid=(ok+ng)//2\n  if check(mid):\n    ok=mid\n  else:\n    ng=mid\n\nru=[0]*(n+1)\nfor i in range(n):\n  ru[i+1]=ru[i]+a[i]\n\nans=0\ncnt=0\nr=n\n# \u5e78\u798f\u5ea6\u304c\u4e0a\u4f4dm\u500b\u306b\u5165\u308bAx+Ay\u306e\u6700\u5c0f\u5024\u306e\u307fm\u500b\u306e\u500b\u6570\u5236\u9650\u304b\u3089\u6ea2\u308c\u3066\u3057\u307e\u3046\u5834\u5408\u304c\u3042\u308b\u306e\u3067\u5225\u306b\u8003\u3048\u308b\nok=ok+1 # Ax+Ay\u306e\u6700\u5c0f\u5024\u3088\u308a\u5927\u304d\u306a\u5024\u3092\u5148\u306b\u51e6\u7406\u3059\u308b\u305f\u3081\u306b\u6700\u5c0f\u5024+1\u3092\u3059\u308b\u3002\nfor i in range(n):\n  # \u6700\u5c0f\u5024\u4ee5\u5916\u306e\u51e6\u7406\n  l=bisect_left(a,ok-a[i])\n  cnt+=r-l\n  ans+=(r-l)*a[i]+(ru[r]-ru[l])\nans+=(ok-1)*(m-cnt) # \u6700\u5c0f\u5024\u306e\u51e6\u7406\nprint(ans)\n", "from bisect import bisect_left\n\nN,M=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nA.sort()\n\nl=1\nr=200000+1\n\ndef chk(x):\n    c=0\n    for la in A:\n        y=bisect_left(A,x-la)\n        c+=N-y\n    if c>=M:\n        return True\n    else:\n        return False\n\n\n\nwhile l+1<r:\n    mid=(l+r)//2\n    if chk(mid):\n        l=mid\n    else:\n        r=mid\n\nAN=l\n\nS=[0]*(N+1)\n\nfor i in range(N):\n    S[i+1]=S[i]+A[i]\n\nans1=0\nc=0\nfor la in A:\n    ll = -1\n    rr = N\n    while ll + 1 < rr:\n        mi = (ll + rr) // 2\n        if A[mi] > AN - la:\n            rr = mi\n        else:\n            ll = mi\n    c+=N-rr\n    ans1=ans1+la*(N-rr)+S[N]-S[rr]\n\nans=ans1+(M-c)*AN\nprint(ans)\n\n\n", "def main():\n    import numpy as np\n    n,m=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    A.sort()\n    A=np.array(A)\n\n    def cnt_shake(x): #\u63e1\u624b\u306e\u7d44\u3067\u3042\u3063\u3066\u5408\u8a08\u30d1\u30ef\u30fc\u304cx\u4ee5\u4e0a\u3068\u306a\u308b\u7d44\u307f\u306e\u6570\n        return n**2-np.searchsorted(A,x-A).sum()\n  \n    right=2*10**5+1\n    left=-1\n    while right-left>1:\n        mid=(left+right)//2\n        if cnt_shake(mid)<m:\n            right=mid\n        else:\n            left=mid\n    \n    border=left  #border\u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u3059\u308b\n    C=n-np.searchsorted(A,border+1-A)\n    B=np.cumsum(A[::-1])\n    cnt=C.sum()\n    s=np.sum(A*C)+border*(m-cnt)+B[C[np.where(C>0)]-1].sum()\n    print(s)\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import numpy as np\n    n,m=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n    A.sort()\n    A=np.array(A)\n\n    def cnt_shake(x): #\u63e1\u624b\u306e\u7d44\u3067\u3042\u3063\u3066\u5408\u8a08\u30d1\u30ef\u30fc\u304cx\u4ee5\u4e0a\u3068\u306a\u308b\u7d44\u307f\u306e\u6570\n        return n**2-np.searchsorted(A,x-A).sum()\n  \n    right=10**10*1\n    left=-10**10-1\n    while right-left>1:\n        mid=(left+right)//2\n        if cnt_shake(mid)<m:\n            right=mid\n        else:\n            left=mid\n    \n    border=left  #border\u4ee5\u4e0a\u306e\u63e1\u624b\u3092\u3059\u308b\n    C=n-np.searchsorted(A,border+1-A)\n    B=np.cumsum(A[::-1])\n    #print(border,A,B,C)\n\n    s,cnt=0,0\n    for i in range(n):\n        if C[i]>0:\n          cnt+=C[i]\n          s+=B[C[i]-1]+A[i]*C[i]\n    s+=border*(m-cnt)\n\n    print(s)\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n#import sys; sys.stdin=open('input_file.txt')\n#------------------------------------------\nimport numpy as np\n\nN,M = list(map(int,input().split()))\nA = np.array(input().split(),np.int64)\n\nA = np.sort(A)\nS = np.zeros(N+1,np.int64)\nS[1:]= np.cumsum(A)\n\nhi = 200001\nlo = -1\n\nwhile hi-lo > 1:\n    mid = (hi+lo)//2\n    above_mid = (N-np.searchsorted(A,mid-A,side='left')).sum()\n    if above_mid >= M:\n        lo = mid\n    else:\n        hi = mid\n\nX = np.searchsorted(A,hi-A,side='left')\n\nabove_hi = (N-X).sum()\nhappiness = (S[-1]-S[X]).sum()\nhappiness += (A*(N-X)).sum()\nhappiness += (M-above_hi)*lo\n\nprint(happiness)\n", "import numpy as np\nfrom numpy.fft import rfft,irfft\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return list(map(int,input().split()))\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print((\"-------\\n{}\\n-------\".format(text)))\n\nINF=10**20\nclass Polynomial:\n    def __init__(self,coefficient=None,dim=0,const=1):\n        if coefficient == None:\n            self.coefficient = np.zeros(dim+1, np.int64)\n            self.coefficient[dim] = const\n        else:\n            self.coefficient = coefficient\n\n    def __add__(self,other): # +\n        f,g = self.coefficient, other.coefficient\n        if len(f) > len(g): f,g = g,f\n\n        h = Polynomial(dim=len(g)-1,const=0)\n        h.coefficient[len(f):] += g[len(f):]\n        h.coefficient[:len(f)] += f + g[:len(f)]\n        return h\n    \n    def __iadd__(self,other): # +=\n        h = self.__add__(other)\n        self.coefficient = h.coefficient\n        return self\n\n    def __mul__(self,other): # *\n        f = self.coefficient\n        g = other.coefficient\n        h = Polynomial()\n        h.coefficient = self.fft(f,g)[:len(f)+len(g)-1]\n        return h\n    \n    def __len__(self):\n        return len(self.coefficient)\n\n    def __getitem__(self,key):\n        return self.coefficient[key]\n\n    def get_coefficient(self,x):\n        return self.coefficient[x]\n\n\n    def fft(self,A,B,fft_len=1<<18):\n        x = irfft(rfft(A,fft_len) * rfft(B,fft_len))\n        return np.rint(x).astype(np.int64)\n\n\n\ndef main():\n    N,M=mi()\n    A=list(mi())\n    \n    coefficient = [0] * (2*10**5+10)\n    for a in A:\n        coefficient[a] += 1\n    \n    f = Polynomial(coefficient=coefficient)\n            \n    g = f * f\n    ans = 0\n    handshake = M\n    for x in range(len(g)-1,1,-1):\n        count = g[x]\n        if count <= 0: continue\n\n        if count > handshake:\n            ans += handshake * x\n        else:\n            ans += count * x\n \n        handshake = max(handshake-count,0)\n        if handshake == 0:\n            break\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    L, R = 0, 2 * 10**5 + 1\n    while L+1 < R:\n        P = (L+R)//2\n        cnt = 0\n        for v in a:\n            x = P - v\n            cnt += n - bisect_left(a, x)\n        if cnt >= m:\n            L = P\n        else:\n            R = P\n    csum = [0]\n    for v in a:\n        csum.append(v)\n    for i in range(n):\n        csum[i+1] += csum[i]\n    ans = 0\n    cnt = 0\n    for v in a:\n        x = L - v\n        idx = bisect_left(a, x)\n        cnt += n-idx\n        ans += csum[-1] - csum[idx]\n        ans += v * (n - idx)\n    ans -= (cnt - m) * L\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import bisect_right as br\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nfor i in range(n):a[i]*=-1\na.sort()\nb=[0]\nfor i in a:b.append(b[-1]+i)\nng=2*10**5+7\nok=-1\nwhile ok+1!=ng:\n  mid=(ng+ok)//2\n  co=0\n  for i in a:co+=br(a,-(mid+i))\n  if co<m:ng=mid\n  else:ok=mid\nans=0\nco=0\nfor i in a:\n  ind=br(a,-(ok+i)-1)\n  co+=ind\n  ans+=-b[ind]-i*ind\nans+=(m-co)*ok\nprint(ans)", "import numpy as np\nfrom numpy.fft import rfft,irfft\n\ndef main():\n    n,m=map(int,input().split())\n    A=np.array(list(map(int,input().split())))\n    F=np.bincount(A)\n    fft_len=2*10**5+1\n    Ff=rfft(F,fft_len)\n    G=np.rint(irfft(Ff*Ff,fft_len)).astype(np.int64)\n    G_acc=G.cumsum()\n    remove_cnt=n**2-m\n    border=np.searchsorted(G_acc,n**2-m)\n    x=n**2-m-G_acc[border-1]\n    remove_sum=(G[:border]*np.arange(border)).sum()+border*x\n    ans=A.sum()*2*n-remove_sum\n    print(ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "import bisect\ndef judge(k, N, A):\n    t = 0\n    for i in A:\n        j = bisect.bisect_left(A, k - i)\n        t += N - j\n    return t\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n    t = A[-1] * 2\n    b = 0\n    X = None\n    while t - b > 1:\n        m = (t + b)//2\n        i = judge(m, N, A)\n        if i == M:\n            X = m\n            break\n        if i > M:\n            ip = judge(m + 1, N, A)\n            if ip == M:\n                X = m + 1\n                break\n            if ip < M:\n                X = m\n                break\n            b = m + 1\n        if i < M:\n            im = judge(m - 1, N, A)\n            if im >= M:\n                X = m - 1\n                break\n            t = m - 1\n    if X is None:\n        X = b\n    B = []\n    tmp = 0\n    for i in reversed(list(range(N))):\n        tmp += A[i]\n        B.append(tmp)\n    B.reverse()\n    r = 0\n    tot = 0\n    for i in reversed(list(range(N))):\n        j = bisect.bisect_left(A, X - A[i])\n        tot += N - j\n        if j == N:\n            break\n        r += A[i] * (N - j) + B[j]\n    return r - (tot - M) * X\nprint((main()))\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\n# l[i] = (a[j] >= i \u3092\u6e80\u305f\u3059j\u306e\u500b\u6570)\nl = [n for i in range(a[0]+1)]\nfor i in range(2, n+1):\n    for j in range(a[-i], a[-i+1], -1):\n        l[j] = n - i + 1\n\n# \u4e8c\u5206\u63a2\u7d22\n# a[i] + a[j] >= x \u3092\u6e80\u305f\u3059(i, j)\u304cm\u7d44\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u6700\u5c0f\u306ex\u3092\u6c42\u3081\u308b\nstart = 2 * a[-1]\nstop = 2 * a[0]\nwhile start < stop:\n    i = (start + stop + 1) // 2\n    num = 0\n    for j in a:\n        if i - j < 0:\n            num += n\n        elif i - j <= a[0]:\n            num += l[i - j]\n        else:\n            break\n\n    if num >= m:\n        start = i\n    else:\n        stop = i - 1\n\nnum = 0\nfor i in a:\n    if start - i < 0:\n        num += n\n    elif 0 <= start - i <= a[0]:\n        num += l[start - i]\n    else:\n        break\n\n# start <= a[i]+a[j] \u3092\u6e80\u305f\u3059 a[i]+a[j] \u3092\u5168\u3066\u8db3\u3059\nans = 0\nfor i in a:\n    if start - i < 0:\n        ans += 2 * i * n\n    elif start - i <= a[0]:\n        ans += 2 * i * l[start - i]\n    else:\n        break\nans -= (num - m) * start\nprint(ans)", "from bisect import bisect_left,bisect_right\nfrom itertools import accumulate\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\n\ndef isOK(x):\n    num=0\n    for k,a in enumerate(A,start=1):\n        i=bisect_left(A,x-a)\n        num+=n-i\n    return num>=m\n\n\n\nl=0\nr=2*10**5+1\nwhile l+1<r:\n    mid=(l+r)//2\n    if isOK(mid):\n        l=mid\n    else:\n        r=mid\n\ns=0\nnum=0\n\nacc=list(accumulate([0]+A))\n\nfor a in A:\n    i=bisect_right(A,l-a)\n    s+=a*(n-i)+acc[n]-acc[i]\n    num+=n-i\n\nans=s+l*(m-num)\n\nprint(ans)\n", "from bisect import bisect_left\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    b = [0]*(n+1)\n    for i in range(n):\n        b[i+1] = a[i] + b[i]\n    ok = 0; ng = 2 * 10**5 + 5\n    while ok+1 < ng:\n        mid = (ok + 1 + ng) // 2\n        buf = 0\n        for i in range(n):\n            p = mid - a[i]\n            buf += n - bisect_left(a, p)\n        if buf >= m:\n            ok = mid\n        else:\n            ng = mid\n    ans = 0\n    num = 0\n    tot = 0\n    for i in range(n):\n        p = ok - a[i]\n        index = bisect_left(a, p)\n        num += n - index\n        tot += b[n] - b[index]\n        tot += a[i] * (n-index)\n    ans = tot - (num - m) * ok\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\nfrom itertools import accumulate\nN,M = map(int,input().split())\nA = sorted(list(map(int,input().split())))\nA2 = [0]+list(accumulate(A))\ndef judge(mid):\n    count = 0\n    for i in range(N):\n        border = mid - A[i]\n        ind = bisect.bisect_left(A,border)\n        count += N-ind\n    if count < M:\n        return True\n    else:\n        return False\nmina = 0\nmaxa = 2*(10**5) + 1\nwhile maxa-mina > 1:\n    mid = (maxa+mina)//2\n    if judge(mid):\n        maxa = mid\n    else:\n        mina = mid\ncount = 0\nans = 0\nfor i in range(N):\n    border = maxa - A[i]\n    ind = bisect.bisect_left(A,border)\n    count += N-ind\n    ans += A[i]*(N-ind) + A2[N]-A2[ind]\nif count == M:\n    print(ans)\nelse:\n    rem = M-count\n    print(ans+rem*mina)", "######################\n# AC: ms(PyPy)\n# AC: ms(Python3)\n######################\n\nfrom bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    N,M = list(map(int, input().split()))\n    A = [int(i) for i in input().split()]\n\n    A.sort()\n\n    left = 0\n    right = A[-1] * 2 + 5\n    while right - left > 1:\n        X = (left + right) // 2\n\n        count = 0\n        for a in A:\n            i = bisect_left(A, X-a)\n            count += (N - i)\n\n        if count >= M:\n            left = X\n        else:\n            right = X\n\n    count = 0\n    num = []\n    append = num.append\n    for a in A:\n        i = bisect_left(A, left-a)\n        count += (N - i)\n        append(N - i)\n\n    diff = count - M\n    ans = 0\n    for i, a in zip(num, A):\n        ans += i * a\n\n    print((ans * 2 - diff * left))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\nfrom itertools import accumulate\nN,M,*A = list(map(int, open(0).read().split()))\nA.sort()\nB = list(accumulate(A[::-1]))\nl = -1\nr = 10**6\nwhile l+1<r:\n  s = (l+r)//2\n  cnt = 0\n  for c in A:\n    i = bisect_left(A,s-c)\n    cnt += N-i\n  if cnt>=M:\n    l = s\n  else:\n    r = s\nans = 0\nfor c in A:\n  i = bisect_left(A,r-c)\n  M -= N-i\n  if i<N:\n    ans += B[N-1-i]+c*(N-i)\nans += M*l\nprint(ans)\n", "\nfrom bisect import bisect_left\nfrom itertools import accumulate\ndef resolve():\n    def getCount(x):\n        count = 0\n        for Ai in A:\n            idx = bisect_left(A, x - Ai)\n            count += N - idx\n        return count >= M\n\n\n    N, M = list(map(int, input().split()))\n    A = sorted(map(int, input().split()))\n    A_r = A[::-1]\n    B = [0] + list(accumulate(A_r))\n\n    MIN = 0\n    MAX = 2 * 10 ** 5 + 1\n    while MAX - MIN > 1:\n        MID = (MIN + MAX) // 2\n        if getCount(MID):\n            MIN = MID\n        else:\n            MAX = MID\n\n    ans = 0\n    count = 0\n\n    for Ai in A_r:\n        idx = bisect_left(A, MIN - Ai)\n        ans += Ai * (N - idx) + B[N - idx]\n        count += N - idx\n    print((ans - (count - M) * MIN))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from itertools import accumulate\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nMAX = 10 ** 5\n\nscores = [0] * (2 * MAX + 1)\nfor e in a:\n    scores[e] += 1\n\nacc = list(accumulate(scores))\n\n\ndef f(x):\n    cnt = 0\n    for e in a:\n        cnt += n - acc[max(0, x - e - 1)]\n\n    return cnt\n\n\nl = 0\nr = 2 * MAX + 1\nwhile r - l > 1:\n    mid = (l + r) // 2\n    if f(mid) >= m:\n        l = mid\n    else:\n        r = mid\n\nscores_sum = [i * e for i, e in enumerate(scores)]\nacc_sum = list(accumulate(scores_sum))\nsm = sum(a)\nans = 0\ncnt_sum = 0\nfor e in a:\n    i = max(0, l - e - 1)\n    cnt = n - acc[i]\n    ans += e * cnt + sm - acc_sum[i]\n    cnt_sum += cnt\n\nans -= (cnt_sum - m) * l\n\nprint(ans)\n", "N, M = map(int, input().split())\nA = [int(c) for c in input().split()]\nA.sort(reverse=True)\nB = A[::-1]\nl = 0\nr = 10**6\ndef f(m):\n  cnt = 0\n  j = 0\n  for i in range(N):\n    while j<N:\n      if A[i]+B[j]>=m:\n        cnt += N-j\n        break\n      j += 1\n  return cnt>=M\nwhile l+1<r:\n  n = (l+r)//2\n  if f(n):\n    l = n\n  else:\n    r = n\nC = [0]\nfor i in range(N):\n  C += [C[-1]+B[i]]\nans = 0\nj = 0\nm = 0\nflag = False\nfor i in range(N):\n  while j<N:\n    if A[i]+B[j]>l:\n      ans += C[-1]-C[j]+A[i]*(N-j)\n      m += N-j\n      break\n    j += 1\nans += (M-m)*l\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nA = list(map(int,readline().split()))\n\nMAX_VAL = 10 ** 5 + 1\nhand = [0] * MAX_VAL\nfor a in A:\n  hand[a] += 1\n  \nimport numpy as np\ndef convolve(f, g):\n    fft_len = 1\n    while 2 * fft_len < len(f) + len(g) - 1:\n        fft_len *= 2\n    fft_len *= 2\n    \n    Ff = np.fft.rfft(f, fft_len)\n    Fg = np.fft.rfft(g, fft_len)\n\n    Fh = Ff * Fg\n\n    h = np.fft.irfft(Fh, fft_len)\n    h = np.rint(h).astype(np.int64)\n\n    return h[:len(f) + len(g) - 1]\n\nright_hand = np.array(hand, dtype = int)\nleft_hand = np.array(hand, dtype = int)\n\nH = convolve(left_hand, right_hand)\n# H\u3092\u5927\u304d\u3044\u307b\u3046\u304b\u3089\u898b\u3066\u3044\u304f\u3068\u3001\n# \u5e78\u798f\u5ea6i\u306e\u63e1\u624b\u3092H[i]\u7a2e\u985e\u3067\u304d\u308b\u3053\u3068\u304c\u5206\u304b\u308b\n# \u4e0a\u304b\u3089\u9806\u306b\u8db3\u3057\u3066\u3044\u3063\u3066\u3001\u6700\u5f8cH[i]\u7a2e\u985e\u306e\u63e1\u624b\u3092\u8db3\u305b\u306a\u3044\u3068\u304d\u306f\u3001\u6b8b\u308a\u306e\u63e1\u624b\u56de\u6570\u3060\u3051\u8db3\u3059\n\nans = 0\nfor i in range(len(H) - 1, -1, -1):\n  if H[i] == 0:\n    continue\n  if H[i] <= M: # H[i]\u56de\u306e\u63e1\u624b\u304c\u3067\u304d\u308b\n    ans += i * H[i]\n    M -= H[i]\n  else: # H[i]\u56de\u306e\u63e1\u624b\u304c\u3067\u304d\u306a\u3044\u306e\u3067\u3001\u6b8b\u3063\u305f\u56de\u6570\u3060\u3051\u63e1\u624b\u3059\u308b\n    ans += M * i\n    break\n\nprint(ans)", "from bisect import bisect_left\n\n\ndef solve(m):\n    r = N - 1\n    l = 0\n    cnt = 0\n    while 0 <= r and l < N:\n        if A[r] + A[l] < m:\n            l += 1\n        else:\n            cnt += N - l\n            r -= 1\n    return cnt\n\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nS = [0] * (N + 1)\nfor i in range(N):\n    S[i + 1] = S[i] + A[i]\n\n# [ok, ng) - Maximum\n# (ng, ok] - Minimum\n# ok \u304c \u6700\u7d42\u7684\u306a\u7b54\u3048\nok = 0\nng = 10 ** 21\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) // 2\n    cnt = solve(mid)\n    if cnt >= M:\n        ok = mid\n    else:\n        ng = mid\n\nX = ok\namari = float('inf')\ncnt = 0\nscore = 0\nfor i, Ai in enumerate(A):\n    Aj = X - Ai\n    j = bisect_left(A, Aj)\n    score += S[N] - S[j] + Ai * (N - j)\n    cnt += N - j\n    if j < N:\n        amari = min(amari, A[i] + A[j])\n\nprint((score - (cnt - M) * amari))\n", "\nimport sys\ninput = sys.stdin.readline\n# \u6587\u5b57\u5217\u3092input()\u3057\u305f\u5834\u5408\u3001\u672b\u5c3e\u306b\u6539\u884c\u304c\u5165\u308b\u306e\u3067\u6ce8\u610f\ndef main():\n  n,m=list(map(int,input().split()))\n  a=sorted(list(map(int,input().split())))\n  import bisect\n  # \u89e3\u8aac\u306e\u4e8c\u5206\u63a2\u7d22\n  # \u3042\u308bX\u3092\u5b9a\u3081\u3001X\u4ee5\u4e0a\u306b\u306a\u308b\u63e1\u624b\u306e\u7d44\u307f\u5408\u308f\u305b\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u8a08\u7b97\u3002M\u500b\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u5927\u306eX\u3092\u63a2\u3059\n  # [l,r)\u534a\u958b\u533a\u9593\n  l,r=0,a[-1]*2+1\n  while r-l>1:\n    x=(l+r)//2\n    cnt=0\n    for ai in a:\n      cnt+=n-bisect.bisect_left(a,x-ai)\n    # x\u4ee5\u4e0a\u304cm\u500b\u4ee5\u4e0a\u3042\u308b->x~r-1\u306b\u6c42\u3081\u308b\u3082\u306e\u304c\u3042\u308b\n    if cnt>=m:\n      l=x\n    else:# x\u4ee5\u4e0a\u304cm\u500b\u672a\u6e80\u3042\u308b->l~x-1\u306b\u6c42\u3081\u308b\u3082\u306e\u304c\u3042\u308b\n      r=x\n  x=(l+r)//2\n  ans=0\n  cnt=0\n  a_=0\n  cs_a=[0]\n  for ai in a:\n    a_+=ai\n    cs_a.append(a_)\n  for ai in a:\n    bi=bisect.bisect_right(a,x-ai)\n    cnt+=n-bi\n    ans+=cs_a[-1]-cs_a[bi]+(n-bi)*ai\n  print((ans+(m-cnt)*x))\n\ndef __starting_point():\n  #import datetime\n  #print(datetime.datetime.now())\n  main()\n  #print(datetime.datetime.now())\n\n__starting_point()", "n, m = map(int, input().split())\na = sorted(list(map(int, input().split())), reverse=True)\na_rev = a[::-1]\n\nok, ng = 1, 200001\nwhile ng-ok > 1:\n\tx = (ok+ng)//2\n\tnum = 0\n\tcur = 0\n\tfor i in range(n-1, -1, -1):\n\t\twhile cur < n and a[i] + a[cur] >= x:\n\t\t\tcur += 1\n\t\tnum += cur\n\tif num < m:\n\t\tng = x\n\telse:\n\t\tok = x\njust = ok\n\nans = 0\nlarger_cnt = 0\ncur = 0\n\na_cum = [0]\nfor i in range(n):\n\ta_cum.append(a_cum[-1] + a[i])\n\nfor i in range(n):\n\twhile cur < n and a[i] + a_rev[cur] <= just:\n\t\tcur += 1\n\tlarger_cnt += n - cur\n\tans += (n - cur) * a[i] + a_cum[n - cur]\n\nans += just * (m - larger_cnt)\nprint(ans)", "from bisect import bisect_left\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\n\n\ndef get_count(tot):\n    '''\n    tot\u4ee5\u4e0a\u3092\u6e80\u305f\u3059\u5e78\u798f\u5ea6\u306e\u63e1\u624b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    '''\n    ret = 0\n    for i in range(N):\n        cnt = bisect_left(A, tot-A[i])\n        ret += N - cnt\n    return ret\n\n\n# \u53f3\u304b\u3089\u306e\u7d2f\u7a4d\u548c\nAsum = A[:]\nfor i in range(N-2, -1, -1):\n    Asum[i] += Asum[i+1]\n\n\ndef get_sum(tot):\n    '''\n    \u5de6\u7aef\u3092\u56fa\u5b9a\u3057\u305f\u6642\u306e\u53f3\u7aef\u306e\u500b\u6570\u5206\u3060\u3051\u5de6\u7aef\u3092\u8db3\u3057\u3001\u53f3\u7aef\u306e\u533a\u9593\u548c\uff08\u7d2f\u7a4d\u548c\uff09\u3082\u8db3\u3059\u3002\n    '''\n    ret = 0\n    for i in range(N):\n        idx = bisect_left(A, tot-A[i])\n        cnt = N - idx\n        ret += A[i]*cnt\n        # print(idx)\n        if idx == N:\n            continue\n        ret += Asum[idx]\n        # print(f'ret = {ret}')\n    return ret\n\n\n# M\u56de\u63e1\u624b\u3067\u304d\u308b\u4e0a\u9650\u3092\u6c42\u3081\u308b\nok = 0\nng = 10**12\nwhile ok + 1 != ng:\n    md = (ok + ng)//2\n    if M <= get_count(md):\n        ok = md\n    else:\n        ng = md\n# print(ok)\n# print(get_sum(ok+1))\n# print(M - get_count(ok+1))\n# print(Asum)\nans = get_sum(ok+1) + (M - get_count(ok+1))*ok\n\nprint(ans)\n", "import numpy as np\n \nN,M = map(int,input().split())\nA = np.array(input().split(),np.int64)\n \nA = np.sort(A)\nS = np.zeros(N+1,np.int64)\nS[1:]= np.cumsum(A)\n \nhi = 200001\nlo = -1\n \nwhile hi-lo > 1:\n    mid = (hi+lo)//2\n    above_mid = (N-np.searchsorted(A,mid-A,side='left')).sum()\n    if above_mid >= M:\n        lo = mid\n    else:\n        hi = mid\n \nX = np.searchsorted(A,hi-A,side='left')\n \nabove_hi = (N-X).sum()\nhappiness = (S[-1]-S[X]).sum()\nhappiness += (A*(N-X)).sum()\nhappiness += (M-above_hi)*lo\n \nprint(happiness)", "import numpy as np\n\nn, m = list(map(int,input().split()))\na = list(map(int,input().split()))\n\nna = np.zeros(2**18)\nfor i in a:\n    na[i] += 1\n\nfa = np.fft.fft(na)\n\nc = np.round(np.fft.ifft(fa*fa)).astype(int)\n\nans = 0\ncm = 0\nfor i in range(2**18 - 1, 1, -1):\n    cm += c[i]\n    ans += i*c[i]\n    if cm > m:\n        ans -= i * (cm - m)\n    if cm >= m:\n        break\n\nprint(ans)\n", "import sys\nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\nfrom itertools import accumulate\n\nn, m, *a = map(int, sys.stdin.read().split())\na.sort()\n\ndef count(border):\n  res = 0\n  for x in a:\n    b = border - x\n    res += n - bi_l(a, b)\n  return res\n\ndef main():\n  lo, hi = 1, a[-1] * 2 + 1\n  while lo + 1 < hi:\n    border = (lo + hi) // 2\n    if count(border) >= m:\n      lo = border\n    else:\n      hi = border\n  \n  s = a.copy() + [0]\n  *s, = accumulate(s[::-1])\n  tot = 0\n  for x in a:\n    b = lo - x\n    c = n - bi_l(a, b)\n    tot += x * c + s[c]\n  \n  tot -= lo * (count(lo) - m)\n  print(tot)\n\ndef __starting_point():\n  main()\n__starting_point()", "from bisect import bisect_left as BL \nN,M=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\n\n#border\u4ee5\u4e0a\u306e\u5e78\u798f\u5ea6\u3092\u8fd4\u3059\u63e1\u624b\u306e\u7d44\u306e\u6570\u304c\u3001M\u4ee5\u4e0a\u3067\u3042\u308b\u304b\ndef isok(border):\n  res=0\n  for i in range(N):\n    res+=N-BL(A,border-A[i])\n  return res>=M\n    \n\nok=0\nng=A[-1]*2+1\nmid=(ok+ng)//2\n\n#\u5e78\u798f\u5ea6h\u4ee5\u4e0a\u306e\u63e1\u624b\u304cM\u7d44\u4ee5\u4e0a\u5b58\u5728\u3059\u308b\u3088\u3046\u306a\u6700\u5927\u306eh\u3092\u63a2\u3059\nwhile abs(ok-ng)>1:\n  mid=(ok+ng)//2\n  if isok(mid):\n    ok=mid\n  else:\n    ng=mid\n  \nB=reversed(A)\nSB=[0]\nfor b in B:\n  SB.append(b+SB[-1])\n  \nans=0\nshake_c=0\nfor i in range(N):\n  goodshake=N-BL(A,ok-A[i])\n  shake_c+=goodshake\n  ans+=A[i]*goodshake\n  ans+=SB[goodshake]  \nans-=(shake_c-M)*ok\nprint(ans)\n"]
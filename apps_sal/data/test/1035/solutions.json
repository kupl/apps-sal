["from math import gcd, sqrt\na,b = map(int, input().split())\ng = gcd(a,b)\nd = {}\nfor i in range(2, int(sqrt(g))+1):\n    while g%i==0:\n        g//=i\n        d[i] = d.get(i, 0)+1\nif g>1:\n    d[g] = 1\nprint(len(d)+1)", "import math\n\ndef factrize(num):\n    factor = {}\n    div = 2\n    s = int(num**0.5)+1\n    while div < s:\n        div_cnt = 0\n        while num % div == 0:\n            div_cnt += 1\n            num //= div\n        if div_cnt != 0:\n            factor[div] = div_cnt\n        div += 1\n    if num > 1:\n        factor[num] = 1\n    return factor\n\na, b = map(int, input().split())\ng = math.gcd(a, b)\nprint(len(factrize(g))+1)", "a,b=map(int,input().split())\n \ndef prime_factorization(n):\n  if n==1:\n    return [1]\n  else:\n    i=2\n    ans=[]\n    k=int(n**0.5)+1\n    for j in range(2,k+1):\n      if n==1: break\n      if n%j==0:\n        n//=j\n        ans.append(j)\n        while n%j==0:\n          n//=j\n    if len(ans):\n      ans.append(1)\n      if n!=1:\n        ans.append(n)\n      return ans\n    else:\n      return [1,n]\n\nA=prime_factorization(a)\nB=prime_factorization(b)\n \nprint(len(set(A)&set(B)))", "from math import gcd\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\na, b = map(int, input().split())\nn = prime_factorize(gcd(a,b))\n\nprint(len(set(n))+1)", "import math\na,b=list(map(int,input().split()))\ngcd=math.gcd(a,b)\n\ndef prime_factorization(n):\n  i=2\n  prime=[]\n  while i*i<=n:\n    if n%i:\n      i+=1\n    else:\n      n//=i\n      prime.append(i)\n      while n%i==0:\n        n//=i\n  if n>1:\n    prime.append(n)\n  return prime\n\nprint((len(prime_factorization(gcd))+1))\n#print(prime_factorization(gcd))\n", "from math import gcd\nfrom typing import List, Tuple\n\n\ndef pf(n: int) -> List[Tuple[int,int]]:\n    r = []\n    for p in range(2, n):\n        if p * p > n:\n            break\n        e = 0\n        if n % p == 0:\n            while(n % p == 0):\n                n //= p\n                e += 1\n            r.append((p, e))\n    if n != 1:\n        r.append((n, 1))\n    return r\n\na,b = map(int, input().split())\napf = pf(a)\nbpf = pf(b)\naps = {p for p,e in apf}\nbps = {p for p,e in bpf}\nprint(len(aps&bps)+1)", "A, B = map(int, input().split())\n\nimport math\nimport collections\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nc = prime_factorize(math.gcd(A, B))\nc = collections.Counter(c)\nc = c.values()\n\nprint(len(c) + 1)", "A, B = [int(x) for x in input().split()]\n\ndef prime_factorization(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nAprimes = prime_factorization(A)\nBprimes = set(prime_factorization(B))\n\nans = 1\nansset = set()\nfor a in Aprimes:\n    if a in ansset:\n        continue\n    if a in Bprimes:\n        ansset.add(a)\n        ans += 1\n\nprint(ans)\n\n", "import math\nab = [int(i) for i in input().split()]\nab = math.gcd(ab[0], ab[1])\ndic = {}\nn = 2\nwhile n**2 <= ab:\n  if ab % n:\n    n += 1\n  else:\n    ab //= n\n    dic[n] = dic.get(n,0) + 1\nif 1 < ab:\n  dic[ab] = dic.get(ab,0) + 1\n\nprint(len(dic) + 1)", "A,B=map(int,input().split())\n\ndef prime_factorization(n):\n    arr=[]\n    temp=n\n\n    for i in range(2,int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp//=i\n            arr.append(i)\n\n    if temp!=1:\n        arr.append(temp)\n    \n    if arr==[]:\n        arr.append(n)\n    \n    return arr\n\nsetA=set(prime_factorization(A))\nsetB=set(prime_factorization(B))\nsetAB=setA &setB\nif setAB=={1}:\n    print(1)\nelse:\n    print(len(setAB)+1)", "def division(n):\n    if n < 2:\n        return [1]\n\n    prime_factors = [1]\n\n    for i in range(2,int(n**0.5)+1):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 1:\n        prime_factors.append(n)\n\n    return prime_factors\n\na,b = map(int,input().split())\nda = set(division(a))\ndb = set(division(b))\ncnt = 0\nfor i in da:\n    if i in db:\n        cnt += 1\nprint(cnt)", "import math\n\n\ndef factorization(n):\n    arr = [1]\n    temp = n\n    for i in range(2, int(-(-n ** 0.5 // 1)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp //= i\n            arr.append(i)\n\n    if temp != 1:\n        arr.append(temp)\n\n    if not arr:\n        arr.append(n)\n\n    return arr\n\n\nA, B = list(map(int, input().split()))\n\ngcd = math.gcd(A, B)\nf = factorization(gcd)\nprint((len(f)))\n", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\na, b = map(int, input().split())\nn = gcd(a, b)\nprimes = []\nMAX = 10 ** 6 + 10\nis_prime = [False] * 2 + [True] * (MAX - 2)\nfor i in range(2, MAX):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i * i, MAX, i):\n            is_prime[j] = False\ncnt = 1\nfor p in primes:\n    if n % p == 0:\n        cnt += 1\n        while n % p == 0:\n            n /= p\nif n != 1:\n    cnt += 1\nprint(cnt)", "def prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nfrom math import sqrt\nfrom math import gcd\na, b = map(int, input().split())\nx = gcd(a, b)\nprint(len(set(prime_factorize(x)))+1)", "import math        # factorical\uff08\u968e\u4e57) # hypot(\u8ddd\u96e2)\n# import heapq\n# from fractions import gcd # Python3.5\u4ee5\u524d # lcm\uff08\u6700\u5c0f\u516c\u500d\u6570\uff09 = (a*b)//gcd(a,b)\n# from fractions import Fraction\n# from math import gcd # Python3.6\u4ee5\u964d\n# --------------------------------------------------------------\n\n# \u7d20\u56e0\u6570,\u500b\u6570 \u306e\u7d44\u30ea\u30b9\u30c8\u3092\u51fa\u529b\ndef fctr1(n): \n    f = []\n    c = 0\n    r = int(n**0.5)\n    for i in range(2,r+2):\n        while n%i == 0:\n            c += 1 \n            n = n//i\n        if c != 0:\n            f.append([i,c])\n            c = 0\n    if n != 1:\n        f.append([n,1])\n    return f\n\na,b = map(int,input().split())\n\nprint(len(fctr1(math.gcd(a,b)))+1)", "a,b=map(int,input().split())\ndef gcd(a,b):\n  if b==0:\n    return a\n  else:\n    return gcd(b,a%b)\ndef factorize(x):\n  i=2\n  res=[]\n  while i*i<=x:\n    while x%i==0:\n      x//=i\n      res.append(i)\n    i+=1\n  if x>1:\n    res.append(x)\n  return res\ng=gcd(a,b)\nf=factorize(g)\nprint(len(set(f))+1)", "import math\na,b = (int(x) for x in input().split())\nsaidai = 1\n\ndef yakusuu(x,y):\n    return(y,x % y)\n\ndef cont(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nsaidai = math.gcd(a,b)\n\n\nd = cont(saidai)\nif d[0] == [1,1]:\n    print((1))\n    return\nprint((len(d) + 1))\n", "import math\na,b=map(int,input().split())\n\ndef factorization(n):\n    arr=[]\n    tmp=n\n    for i in range(2,int(n**0.5)+1):\n        while tmp%i==0:\n            tmp//=i\n            arr.append(i)\n    if tmp!=1:\n        arr.append(tmp)\n    if arr==[]:\n        arr.append(n)\n    return list(set(arr))\n\nans=len(factorization(math.gcd(a,b)))\nprint(ans+1 if math.gcd(a,b)!=1 else 1)", "from math import gcd\ndef division(n):\n    if n < 2:\n        return [1]\n    prime_factors = [1]\n    for i in range(2,int(n**0.5)+1):\n        while n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 1:\n        prime_factors.append(n)\n    return prime_factors\n\na,b = map(int,input().split())\nd = set(division(gcd(a,b)))\nprint(len(d))", "import math\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(pow(n,1/2))+1):\n        if temp%i == 0:\n            cnt = 0\n            while temp%i==0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp !=1:\n        arr.append([temp,1])\n\n    if arr == []:\n        arr.append([n,1])\n\n    return arr\n\nA, B = map(int,input().split())\ngcd_num =math.gcd(A,B)\n\nif gcd_num == 1:\n    print(1)\nelse:\n    print(len(factorization(gcd_num))+1)", "\nurl = \"https://atcoder.jp//contests/abc142/tasks/abc142_d\"\n\nimport math\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\ndef main():\n    a, b = list(map(int, input().split()))\n    abgcd = math.gcd(a, b)\n    s = set(prime_factorize(abgcd))\n    print((len(s)+1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nA, B = list(map(int, input().split()))\n\nA_yakusu = make_divisors(A)\nB_yakusu = make_divisors(B)\nyakusu_set = set(A_yakusu) & set(B_yakusu)\nyakusu_list = list(yakusu_set)\n \nif max(yakusu_list) != 1:\n    print((len(factorization(max(yakusu_list)))+1)) \nelse:\n    print((1))\n", "n, m = map(int, input().split(\" \"))\n\n\ndef divisor(n):\n    i = 1\n    table = []\n    while i * i <= n:\n        if n % i == 0:\n            table.append(i)\n            table.append(n // i)\n        i += 1\n    table = sorted(list(set(table)))\n    return table\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ns = set(divisor(n)).intersection(set(divisor(m)))\n\nans = 1\nfor ss in s:\n    if len(prime_factorize(ss)) == 1:\n        ans += 1\n\nprint(ans)", "import math\na,b=map(int,input().split())\nans=[1]\nc=math.gcd(a,b)\nfor i in range(2,int(c**(1/2))+1):\n  if c%i==0:\n    while c%i==0:\n      c//=i\n    ans.append(i)\nif c!=1:\n  ans.append(c)\nprint(len(ans))", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\ndef gcd(a, b):\n    \"\"\"\u6700\u5927\u516c\u7d04\u6570\"\"\"\n    a, b = (a, b) if a >= b else (b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef prime_factorization(x):\n    \"\"\"\u7d20\u56e0\u6570\u5206\u89e3\"\"\"\n    import math\n    re = []\n    i = 2\n    while x != 1:\n        if x % i == 0:\n            re.append(i)\n            x //= i\n        else:\n            i += 1\n            if i > math.sqrt(x):\n                re.append(x)\n                break\n    return re\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(A, B):\n    div = gcd(A, B)\n    print((len(set(prime_factorization(div))) + 1))\n\n\ndef __starting_point():\n    # S = input()\n    # N = int(input())\n    A, B = list(map(int, input().split()))\n    # As = [int(i) for i in input().split()]\n    # Bs = [int(i) for i in input().split()]\n    # print(prime_factorization(A))\n    # print(prime_factorization(B))\n    solve(A, B)\n\n__starting_point()", "import math\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\nA,B = map(int,input().split())\nAf = factorization(A)\nBf = factorization(B)\nAs = set()\nBs = set()\nfor i in range(len(Af)):\n    As.add(Af[i][0])\nfor j in range(len(Bf)):\n    Bs.add(Bf[j][0])\nif A == 1 and B ==1:\n    print(1)\nelse:\n    print(len(As & Bs)+1)", "a,b=list(map(int,input().split()))\n\ndef prime_factorization(n):\n  if n==1:\n    return [1]\n  else:\n    i=2\n    ans=[]\n    k=int(n**0.5)+1\n    for j in range(2,k+1):\n      if n==1: break\n      if n%j==0:\n        n//=j\n        ans.append(j)\n        while n%j==0:\n          n//=j\n    if len(ans):\n      ans.append(1)\n      if n!=1:\n        ans.append(n)\n      return ans\n    else:\n      return [1,n]\n\nA=prime_factorization(a)\nB=prime_factorization(b)\n#print(A)\n#print(B)\n\nprint((len(set(A)&set(B))))\n\n", "\nfrom math import gcd\ndef resolve():\n    def prime_factorize(n):\n        if 2 <= n < 4:\n            return [n]\n        res = []\n        i = 2\n        while i * i <= n:\n            while n % i == 0:\n                res.append(i)\n                n //= i\n            i += 1\n        if n != 1:\n            res.append(n)\n\n        return set(res)\n\n    a, b = list(map(int, input().split()))\n\n    g = gcd(a, b)\n    ans = prime_factorize(g)\n    print((len(ans) + 1))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import math\n#\u8a66\u3057\u5272\u6cd5\ndef trial_division(n):\n    #\u7d20\u56e0\u6570\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    factor = []\n    #2\u304b\u3089\u221an\u4ee5\u4e0b\u306e\u6570\u5b57\u3067\u5272\u3063\u3066\u3044\u304f\n    tmp = int(math.sqrt(n)) + 1\n    for num in range(2,tmp):\n        while n % num == 0:\n            n //= num\n            factor.append(num)\n    #\u30ea\u30b9\u30c8\u304c\u7a7a\u306a\u3089\u305d\u308c\u306f\u7d20\u6570\n    if not factor:\n        factor.append(1)\n        factor.append(n)\n        return factor\n    else:\n        factor.append(1)\n        factor.append(n)\n        return factor\nA,B=list(map(int,input().split()))\nA_primes=trial_division(A)\nB_primes=trial_division(B)\nprimes=[]\nfor p in A_primes:\n  if p in B_primes:\n    primes.append(B_primes.pop(B_primes.index(p)))\nprint((len(list(set(primes)))))\n", "a,b = list(map(int,input().split()))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n#\u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nt = factorization(gcd(a,b))\nif t[0][0]==1:\n    print((1))\n    return\nprint((len(t)+1))\n    \n", "import  math\n\nA, B = [int(x) for x in input().split()]\n\n\ndef prime_factorization(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nC = math.gcd(A, B)\n\n\n\n\nprint((len(set(prime_factorization(C))) + 1))\n\n", "import math\na,b=map(int,input().split())\nx=math.gcd(a,b)\nbun=[0]*(int(math.sqrt(x)+1))\nbun[1]=1\nfor i in range(2,len(bun)):\n  while x%i==0:\n    if bun[i]==0:\n      bun[i]+=1\n    x=x//i\nans=sum(bun)\nif x>1:\n  ans+=1\nprint(ans)  ", "import math\na,b=map(int,input().split())\ngcd=math.gcd(a,b)\n\ndef prime_factorization(n):\n  i=2\n  prime=[]\n  if n%i==0:\n    n//=i\n    prime.append(2)\n    while n%i==0:\n      n//=i\n  i+=1\n  while i*i<=n:\n    if n%i:\n      i+=2\n    else:\n      n//=i\n      prime.append(i)\n      while n%i==0:\n        n//=i\n  if n>1:\n    prime.append(n)\n  return prime\n\nprint(len(prime_factorization(gcd))+1)", "import math\nA,B = map(int,input().split())\nC = math.gcd(A,B)\n\n#N\u4ee5\u4e0b\u306e\u7d20\u6570\u308c\u3063\u304d\u3087\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\ndef prime(N):\n    lsprime = [0,0]+[1 for i in range(N-1)]\n    lsprime2 = []\n    for i in range(N+1):\n        if lsprime[i] == 0:\n            continue\n        lsprime2.append(i)\n        k = i\n        while i <= N:\n            lsprime[i] = 0\n            i += k\n    return lsprime2\n\n#\u7d20\u56e0\u6570\u5206\u89e3\ndef prime2(N):\n    arr = []\n    temp = N\n    setprime = set()\n    for i in range(2, int(-(-N**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            setprime.add(i)\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n        setprime.add(temp)\n\n    if arr==[]:\n        arr.append([N, 1])\n\n    return arr,setprime\n\n_,setp = prime2(C)\nprint(len(setp)+1)", "import itertools\nimport sys\na,b=list(map(int,input().split()))\n\n# \u6700\u5927\u516c\u7d04\u6570\uff08\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\uff09\ndef gcd(A,B):\n    while B!=0:\n        A,B=B,A%B\n    return A\n\n# \u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(n**0.5)+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nprint((len(factorization(gcd(a,b)))+1 if a!=1 and b!=1 else 1))\n# print(gcd(a,b))\n# print(factorization(gcd(a,b)))\n", "a,b=map(int,input().split())\nA=[1]\nfor i in range(2,int(a**0.5)+1):\n    if a%i==0:\n        while a%i==0:\n            a//=i\n        A.append(i)\nif a>1:\n    A.append(a)\nB=[1]\nfor i in range(2,int(b**0.5)+1):\n    if b%i==0:\n        while b%i==0:\n            b//=i\n        B.append(i)\nif b>1:\n    B.append(b)\ncan=0\nfor i in A:\n    if i in B:\n        can+=1\nprint(can)", "a,b = map(int,input().split())\nsa = set()\nsb = set()\ni = 1\nwhile i * i <= max(a,b):\n    if a % i == 0:\n        sa.add(i)\n        sa.add(a//i)\n    if b % i == 0:\n        sb.add(i)\n        sb.add(b//i)\n    i += 1\ns = sa & sb\ns.remove(1)\nfor x in list(s):\n    for y in list(s):\n        if x == y:\n            continue\n        if y % x == 0:\n            s.remove(y)\nprint(len(s) + 1)", "from math import sqrt\nfrom math import ceil\ndef prime_factorization(n):\n    pfs = [1]\n    i = 2\n    for i in range(2, int(ceil(sqrt(n)))):\n        while n % i == 0:\n            pfs.append(i)\n            n //= i\n    if n > 0:\n        pfs.append(n)\n    return pfs\n\n\na, b = map(int, input().split())\n\n\ndef bit_search(pfs):\n    m = len(pfs)\n    ds = set([])\n    for i in range(1 << m):\n        d = 1\n        for j in range(m):\n            if i & (1 << m) > 0:\n                d *= pfs[m]\n        ds.add(d)\n    return ds\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ngcdab = gcd(a, b)\n#print (gcdab)\npfsab = prime_factorization(gcdab)\n#print (pfsab)\npfsabset =set(pfsab)\nprint (len(pfsabset))", "def gcd( a , b ):\n    # return gcd( a , b ) \n    while a % b != 0:\n        return gcd( b , a % b )\n    return b\n\nA , B = ( int(x) for x in input().split() )\n\nGcd = gcd( A , B )\nlo_cds = []\nup_cds = []\ni = 1\nwhile i * i <= Gcd:\n    if Gcd % i == 0:\n        lo_cds.append(i)\n        if Gcd // i != i:\n            up_cds.append( Gcd // i )\n    i += 1\nCds = lo_cds + up_cds[::-1]\n# 1\u306f\u5fc5\u305a\u542b\u307e\u308c\u308b\u3057\u7d20\u6570\u5224\u5b9a\u306e\u90aa\u9b54\u306a\u306e\u3067\u4e8b\u524d\u306b\u7701\u304f\u3002\nCds.pop(0)\ni = 0\n\n\nwhile i < len(Cds):\n    j = i + 1\n    while j < len(Cds):\n        if Cds[j] % Cds[i] == 0:\n            Cds.pop(j)\n        else:    \n            j += 1\n    i += 1\n\nprint( len(Cds) + 1 )", "#!/usr/bin/env python3\n\n# input = stdin.readline\n\n\ndef main():\n  A,B = list(map(int,input().split()))\n  def primeLst(x):\n    acc = []\n    f = 2\n    while f * f <= x:\n      if x % f == 0:\n        acc.append(f)\n        x //= f\n      else:\n        f += 1\n    if x != 1:\n      acc.append(x)\n    return acc\n  a = set(primeLst(A))\n  b = set(primeLst(B))\n  if len(a) * len(b) == 0:\n    ans = 1\n  else:\n    ans = len(a&b) + 1\n  print(ans)\n  return\n\ndef __starting_point():\n  main()\n\n__starting_point()", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    a,b = i_map()\n\n    def prime_decomposition(n):\n        i = 2\n        table = []\n        while i * i <= n: # sqrt(n)\u3067\u8a08\u7b97\u304c\u6e08\u3080\n            while n % i == 0:\n                n //= i\n                table.append(i)\n            i += 1\n        if n > 1:\n            table.append(n)\n        return table\n\n    a = set(prime_decomposition(a))\n    b = set(prime_decomposition(b))\n    print((len(a&b)+1))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n\nA, B = [int(_) for _ in input().split()]\nN = math.gcd(A, B)\n\nans = 1\nfor i in range(2, int(math.sqrt(N)+1) + 1):\n    if N % i == 0:\n        ans += 1\n        while N % i == 0:\n            N //= i\nif N > 1:\n    ans += 1\nprint(ans)\n", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter,defaultdict\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq\nsys.setrecursionlimit(10**6)\n# INF =  float(\"inf\")\nINF = 10**18\nimport bisect\nimport statistics\nmod = 10**9+7\n# mod = 998244353\nimport numpy\n\nA, B = map(int, input().split())\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nc = math.gcd(A, B)\nd = factorization(c)\n\nif c > 1:\n    print(len(d)+1)\nelse:\n    print(1)", "import math\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\na, b = map(int, input().split())\n\nc = math.gcd(a, b)\nprint(len(set(prime_factorize(c)))+1)", "N,M= list(map(int,(input().split())))\n\"\"\"n\u3092\u7d20\u56e0\u6570\u5206\u89e3\"\"\"\n\"\"\"2\u4ee5\u4e0a\u306e\u6574\u6570n => [[\u7d20\u56e0\u6570, \u6307\u6570], ...]\u306e2\u6b21\u5143\u30ea\u30b9\u30c8\"\"\"\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\na = prime_factorize(N)\nb = prime_factorize(M)\nc= set(a) & set(b)\nprint((len(c)+1))\n## [[2, 3], [3, 1]] \n##  24 = 2^3 * 3^1\n", "import math\n\na,b = map(int, input().split())\nt = math.gcd(a,b)\n\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n /= i\n      table.append(i)\n    i += 1\n  if n > 1:\n    table.append(n)\n  return table\n\ncnt = len(set(prime_decomposition(t)))\n\nprint(cnt+1)", "# \u554f\u984c\uff1ahttps://atcoder.jp/contests/abc142/tasks/abc142_d\n\nimport math\n\ndef gcd(a, b):\n    while b > 0:\n        tmp = b\n        b = a % b\n        a = tmp\n    return a\n\n\ndef count_prime_factorize(n):\n    res = 1\n    i = 2\n    while i ** 2 <= n:\n        if n % i == 0:\n            res += 1\n            while n % i == 0:\n                n //= i\n        i += 1\n    if n != 1:\n        res += 1\n    return res\n\n\na, b = list(map(int, input().strip().split()))\nx = gcd(a, b)\nres = count_prime_factorize(x)\nprint(res)\n\n", "def factrization(n):\n    arr = []\n    temp = n\n    \n    for i in range(2, int(n**0.5//1) + 2):\n        if temp%i == 0:\n            cnt = 0\n            while temp%i == 0:\n                cnt += 1\n                temp //= i\n            arr.append(i)\n    \n    if temp != 1:\n        arr.append(temp)\n    \n    if arr == []:\n        arr.append(n)\n    \n    return arr\n\na, b = map(int, input().split())\nans = 0\n\nla = factrization(a)\nlb = factrization(b)\n\nif 1 not in la:\n    la.append(1)\nif 1 not in lb:\n    lb.append(1)\n\nfor i in la:\n    if i in lb:\n        ans += 1\n\nprint(ans)", "from math import gcd\na, b = map(int, input().split())\nx = gcd(a,b)\ncnt = 1\nfor i in range(2, int(x ** 0.5) + 1):\n        if x == 1:\n            break\n        if x % i == 0:\n            cnt += 1\n            while x % i == 0:\n                x //= i\nelse:\n    if x != 1:\n        cnt += 1\nprint(cnt)", "a, b = list(map(int, input().split()))\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    elif b == 0:\n        return a\n    else:\n        return gcd(b, a%b)\n\np = gcd(a, b)\nfactors = {}\n\nwhile p > 1:\n    f = False\n    for i in range(2, int(p**0.5)+1):\n        if p % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n\n            p //= i\n            f = True\n            break\n\n    if not f:\n        if p in factors:\n            factors[p] += 1\n        else:\n            factors[p] = 1\n        break\n\nprint(len(factors)+1)", "def main():\n    import math\n    a,b = list(map(int,input().split()))\n    g = math.gcd(a,b)\n    ans = [1]\n    for m in range(2,int(g**0.5)+1):\n        if g%m==0:\n            ans.append(m)\n            while g%m==0:\n                g = g//m\n        if g==1:\n            break\n    if g!=1:\n        ans.append(g)\n    print((len(ans)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nA, B = map(int, input().split())\n\ndef fact(x):\n\ttemp = x\n\tarr = [1]\n\tfor i in range(2, int(math.sqrt(x))):\n\t\tif temp % i == 0:\n\t\t\tc = 0\n\t\t\twhile temp % i == 0:\n\t\t\t\tc += 1\n\t\t\t\ttemp //= i\n\t\t\tarr.append(i)\n\tif temp != 1:\n\t\tarr.append(temp)\n\tif arr == []:\n\t\tarr.append(n)\n\treturn arr\n\na = fact(A)\nb = fact(B)\nans = 0\nfor i in a:\n\tif i in b:\n\t\tans += 1\n\n\nprint(ans)", "\na,b = map(int,input().split())\n\nimport math\ng = math.gcd(a,b)\n\n\"\"\"\ng\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3057\u305f\u3068\u304d\u306e\u7d20\u56e0\u6570\u306e\u30ea\u30b9\u30c8\u306e\u8981\u7d20\u6570 + \u300c1\u300d\u3092\u542b\u3081\u308b\n\ng == 1\u306e\u3068\u304d\n1\ng != 1\u306e\u3068\u304d\n\u7d20\u56e0\u6570\u30ea\u30b9\u30c8\u306e\u8981\u7d20\u6570 +1\n\"\"\"\n\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ngdlist = prime_factorize(g)\nif gdlist ==[]:\n    print(1)\nelse:\n    print(len(set(gdlist))+1)", "# a, b\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b\u3002O(\u30eb\u30fc\u30c8a + \u30eb\u30fc\u30c8b)\n# \u5171\u901a\u306e\u7d20\u56e0\u6570\u3092\u898b\u3064\u3051\u308b\u3002O(loga + logb)\n\na,b = list(map(int, input().split()))\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\na_prime = set(prime_factorize(a))\nb_prime = set(prime_factorize(b))\nans = 0\nfor ap in a_prime:\n  for bp in b_prime:\n    if ap == bp:\n      ans += 1\n      break\nprint((ans+1))\n", "import math\na,b=map(int,input().split())\ndef factorize(x):\n  i=2\n  res=[]\n  while i*i<=x:\n    while x%i==0:\n      x//=i\n      res.append(i)\n    i+=1\n  if x>1:\n    res.append(x)\n  return res\ng=math.gcd(a,b)\nf=factorize(g)\nprint(len(set(f))+1)", "import math\n\na,b=map(int,input().split())\n\nn=math.gcd(a,b)\n\ncnt=1\n\nf=2\nd=n\nwhile f*f<=n:\n    if d%f==0:\n        cnt+=1\n        while d%f==0:\n            d=d//f\n    f+=1\nif d!=1:\n    cnt+=1\n\nprint(cnt)", "import math\n\ndef divisors(x):\n    l = [[], []]\n    for i in range(1, int(math.sqrt(x))+1):\n        if x % i == 0:\n            if i**2 != x:\n                l[0].append(i)\n                l[1].append(x//i)\n            else:\n                l[0].append(i)\n    return l[0]+l[1][::-1]\n\ndef primenumber(x):\n    for i in range(2, int(math.sqrt(x))+1):\n        if x % i == 0:\n            return False\n    return True\n\na, b = map(int, input().split())\ncnt = 0\nfor i in divisors(math.gcd(a, b)):\n    if i == 1:\n        cnt += 1\n    elif primenumber(i):\n        cnt += 1\nprint(cnt)", "a,b=list(map(int,input().split()))\n\n#a,b\u306e\u6700\u5927\u516c\u7d04\u6570\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n#n\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nprint((len(factorization(gcd(a,b)))+1 if gcd(a,b)!=1 else 1))\n", "def factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nfrom math import gcd\n\na, b = map(int,input().split())\ng = gcd(a,b)\nif g == 1:\n    print(1)\nelse:\n    print(len(factorization(g))+1)", "import math\n\ndef prime_factorize(n):\n\tret = []\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tcnt = 0\n\t\t\twhile n % i == 0:\n\t\t\t\tcnt += 1\n\t\t\t\tn = n // i\n\t\t\tret.append([i, cnt])\n\tif n != 1:\n\t\tret.append([n, 1])\n\tif len(ret) == 0:\n\t\tret.append([n, 1])\n\n\treturn ret\n\ndef main():\n\tA, B = [int(x) for x in input().split(\" \")]\n\tg = math.gcd(A, B)\n\tpg = prime_factorize(g)\n\tif pg[0][0] == 1:\n\t\tprint(1)\n\telse:\n\t\tprint(len(pg) + 1)\n\nmain()", "from math import gcd,sqrt,floor\na,b = map(int,input().split())\nc = gcd(a,b)\nx = []\nfor i in range(1,floor(sqrt(c))+1):\n    if c % i == 0:\n        x.append(i)\n        x.append(c//i)\nx.sort()\ny = []\ni = 1\nwhile c > 1 and i < len(x):\n    if c % x[i] == 0:\n        y.append(x[i])\n        c = c // x[i]\n    else:\n        i += 1\nprint(len(set(y))+1)", "a,b=map(int,input().split())\ndef factorize(n):\n    a=[]\n    while n%2==0:\n        a.append(2)\n        n//=2\n    f=3\n    while f*f<=n:\n        if n%f==0:\n            a.append(f)\n            n//=f\n        else:\n            f+=2\n    if n!=1:\n        a.append(n)\n    return set(a)\nprint(len(factorize(a)&factorize(b))+1)", "import math\na,b=list(map(int,input().split()))\ngcd=math.gcd(a,b)\n\ndef prime_factorization(n):\n  i=2\n  prime=[]\n  while i*i<=n and n>1:\n    if n%i:\n      i+=1\n    else:\n      n//=i\n      prime.append(i)\n      while n%i==0:\n        n//=i\n  if n>1:\n    prime.append(n)\n  return prime\n\nprint((len(prime_factorization(gcd))+1))\n#print(prime_factorization(gcd))\n", "import re\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef get_primenumber(number):#\u7d20\u6570\u5217\u6319\n    prime_list = []\n    search_list = list(range(2,number+1))\n    #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n    while search_list[0] <= math.sqrt(number):\n      #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n      #search_list\u306e\u5148\u982d\u3092prime_list\u306b\u5165\u308c\u3066\u3001\u5148\u982d\u3092\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3057\u3066\u524a\u9664\n        head_num = search_list.pop(0)\n        prime_list.append(head_num)\n        #head_num\u306e\u500d\u6570\u3092\u9664\u53bb\n        search_list = [num for num in search_list if num % head_num != 0]\n    #prime_list\u306bsearch_list\u3092\u7d50\u5408\n    prime_list.extend(search_list)\n    return prime_list\ndef factrization_prime(number):#\u7d20\u56e0\u6570\u5206\u89e3\n    factor = {}\n    div = 2\n    s = math.sqrt(number)\n    while div < s:\n        div_cnt = 0\n        while number % div == 0:\n            div_cnt += 1\n            number //= div\n        if div_cnt != 0:\n            factor[div] = div_cnt\n        div += 1\n    if number > 1:\n        factor[number] = 1\n    return factor\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 6)\nmod = 10**9+7\ncnt = 0\nans = 0\nnum = []\ninf = float(\"inf\")\nal = \"abcdefghijklmnopqrstuvwxyz\"\nAL = al.upper()\n\na,b = I()\nprime_a = factrization_prime(a)\nprime_b = factrization_prime(b)\n\nfor i in prime_a.keys():\n    if i in prime_b.keys():\n        cnt += 1\n\nprint(cnt+1)", "a,b=list(map(int,input().split()))\nif a==1 and b==1:\n  print((1))\n  return\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\nans=0\nA=factorization(a)\nB=factorization(b)\nfor i in A:\n  for j in B:\n    if i[0]==j[0]:\n      ans+=1\nprint((ans+1))\n", "import bisect,collections,copy,itertools,math,string\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef main():\n\n\n    def prime_factor(n):\n        lst = []\n        while n%2 == 0:\n            n //= 2\n            lst.append(2)\n        f = 3\n        while f**2 <= n:\n            if n%f == 0:\n                n //= f\n                lst.append(f)\n            else:\n                f += 2\n        if n != 1:\n            lst.append(n)\n        return lst\n\n\n    a, b = LI()\n    g = math.gcd(a, b)\n\n    prm = prime_factor(g)\n\n    ans = len(set(prm)) + 1\n\n    print(ans)\n\nmain()\n", "import math \ndef using_sqrt(k):  \n    factor = 0\n        \n    # 2\u4ee5\u5916\u306e\u5076\u6570\u306f\u7d20\u6570\u3067\u306f\u306a\u3044\u306e\u3067\u7121\u8996\u3059\u308b\n    if k % 2 == 0 and k != 2:\n        return False\n        \n    # \u7e70\u308a\u8fd4\u3057\u306e\u4e0a\u9650\u3092\u5bfe\u8c61\u306e\u5e73\u65b9\u6839\u306b\u3059\u308b\n    for divisor in range(2, math.floor(math.sqrt(k))+1):\n        if k % divisor == 0:\n            factor += 1\n                \n    if factor == 0:\n        return True\n    else:\n        return False\n            \ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n\n    divisors.sort()\n    return divisors\n\ndef make_codivisors(n):\n    divisors = []\n    n0divisors = make_divisors(n[0])\n    n0len = len(n0divisors)\n    for i in n0divisors:\n        for j in range(1, len(n)):\n            if n[j] % i != 0:\n                break\n            if j == len(n)-1:\n                divisors.append(i)\n            \n    # divisors.sort()\n    return divisors\n\na, b =map(int, input().split())\ndiv = make_codivisors([a, b])\nans = 0\nfor i in div:\n  if i==1:\n    ans+=1\n  else:\n    if using_sqrt(i):\n      ans+=1\nprint(ans)", "a,b=map(int,input().split())\n\ndef factorization(n):\n    a=[]\n    while n%2==0:\n        a.append(2)\n        n//=2\n    f=3\n    while f*f<=n:\n        if n%f==0:\n            a.append(f)\n            n//=f\n        else:\n            f+=2\n    if n!=1:\n        a.append(n)\n    return a\n\ns_a=set(factorization(a))\ns_b=set(factorization(b))\nans_arr=s_a&s_b\nprint(len(ans_arr)+1)", "import math\nA,B = map(int,input().split())\nx = math.gcd(A,B)\n\ndef prime_decomposition(x):\n  i = 2\n  ls = []\n  while i * i <= x:\n    while x % i == 0:\n      x /= i\n      ls.append(i)\n    i += 1\n  if x > 1:\n    ls.append(x)\n  return ls\n\ncnt = len(set(prime_decomposition(x)))\n\nprint(cnt+1)", "from math import gcd\nfrom typing import List, Tuple\n\n\ndef pf(n: int) -> List[Tuple[int,int]]:\n    r = []\n    for p in range(2, n):\n        if p * p > n:\n            break\n        e = 0\n        if n % p == 0:\n            while(n % p == 0):\n                n //= p\n                e += 1\n            r.append((p, e))\n    if n != 1:\n        r.append((n, 1))\n    return r\n\na,b = list(map(int, input().split()))\nr = pf(gcd(a,b))\nprint((len(r)+1))\n", "import math\na,b=map(int,input().split())\n\ndef gcd(a,b):\n    if a<b:a,b=b,a\n    if b==0:return a\n    while b>0:\n        r=a%b\n        a=b\n        b=r\n    return a\ng=gcd(a,b)\nx=g\ns=set()\nfor i in range(2,int(math.sqrt(g))+1):\n    while x%i==0:\n        s.add(i)\n        x/=i\nif x!=1:s.add(x)\nprint(len(s)+1)", "def factorize(n):\n    fct = []\n    b,e = 2,0\n    while b*b <= n:\n        while n % b == 0:\n            n //= b\n            e += 1\n        if e > 0:\n            fct.append((b,e))\n        b,e = b+1,0\n    if n > 1:\n        fct.append((n,1))\n    return fct\na,b = map(int,input().split())\nap = set()\nfor prime,count in factorize(a):\n    ap.add(prime)\nbp = set()\nfor prime,count in factorize(b):\n    bp.add(prime)\nprint(len(ap&bp)+1)", "import math\n\n\ndef factorize(n):\n    V = [1]\n    if n == 1:\n        return V\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            V.append(i)\n            while n % i == 0:\n                n //= i\n    if n > 1:\n        V.append(n)\n    return V\n\n\nA, B = [int(x) for x in input().split()]\nV = factorize(math.gcd(A, B))\nprint((len(V)))\n", "A, B = list(map(int, input().split()))\n\n\ndef prime_numbers(N):\n    n = N\n    res = set()\n    for i in range(2, n):\n        if i * i >= n: break\n        if N % i != 0: continue\n        while N % i == 0:\n            N //= i\n        res.add(i)\n    res.add(N)\n    res.add(1)\n    return res\n\n\na = prime_numbers(A)\nb = prime_numbers(B)\n#print(a, b)\n#print(a.intersection(b))\nans = len(a.intersection(b))\nprint(ans)\n", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nA, B = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    #if arr==[]:\n    #    arr.append([n, 1])\n    return arr\n    \nfacts_A = factorization(A)\n\ncnt = 0\nfor l in facts_A:\n    if B % l[0] == 0:\n        cnt += 1\nprint(cnt + 1)", "import math\nimport collections\n\ndef prime_factorize(n):\n    s = []\n    while n % 2 == 0:\n        s.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            s.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        s.append(n)\n    return s\n\na, b = map(int, input().split())\n\ng = math.gcd(a, b)\nc = collections.Counter(prime_factorize(g))\n\nprint(len(c.values()) + 1)", "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\n \nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\n \nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n \ndef main():\n    A, B = NMI()\n    GCD = math.gcd(A, B)\n    N=GCD\n    \n    cnt = 0\n    \n    ls=[]\n    \n    for n in range(2,int(N**0.5)+2):\n \n        if GCD % n == 0:\n            cnt += 1\n \n            while GCD % n == 0:\n                GCD = GCD//n\n                ls.append(n)\n        \n    if GCD == 1:\n        print(cnt+1)\n    else:\n        print(cnt+2) \n\ndef __starting_point():\n    main()\n__starting_point()", "import math\n\na,b = map(int,input().split())\nx = math.gcd(a,b)\ns = [1]\nfor i in range(2,int(math.sqrt(x)+1)):\n    if x%i == 0:\n        while x%i == 0:\n            x //= i\n        s.append(i)\nif x != 1:\n    s.append(x)\nl = len(s)\nprint(l)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 13 14:18:02 2020\n\n@author: liang\n\"\"\"\n\nimport math\nfrom math import gcd\nA, B = map(int,input().split())\ng = gcd(A,B)\nn = int(math.sqrt(g))\nd_list = list()# 1\n\n#\u7d04\u6570\u30c1\u30a7\u30c3\u30af O(\u221an)\nfor i in range(1,n+1):\n    if g % i == 0:\n        j = g//i\n        d_list.append(i)\n        if j != 1:\n            d_list.append(j)\nd_list.sort()\n#print(d_list)\nans_list = [1]\nd_list.pop(0)\nwhile d_list:\n    t = d_list.pop(0)\n    ans_list.append(t)\n    d_list = [i for i in d_list if i%t != 0]\n#print(d_list)\n#print(ans_list)\nprint(len(ans_list))", "import itertools\nimport sys\na,b=list(map(int,input().split()))\n\n# \u6700\u5927\u516c\u7d04\u6570\uff08\u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u306e\u4e92\u9664\u6cd5\uff09\ndef gcd(A,B):\n    while B!=0:\n        A,B=B,A%B\n    return A\n\n# \u7d20\u56e0\u6570\u5206\u89e3\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\nprint((len(factorization(gcd(a,b)))+1 if a!=1 and b!=1 else 1))\n# print(gcd(a,b))\n# print(factorization(gcd(a,b)))\n", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\nimport collections\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\ndef resolve():\n    readline=sys.stdin.readline\n    a,b=list(map(int, readline().rstrip().split()))\n\n    af = factorization(a)\n    bf = factorization(b)\n\n    c = collections.Counter()\n    c[1]=2\n    for x in af:\n        c[x[0]]+=1\n    for x in bf:\n        c[x[0]]+=1\n    ans=0\n    for k in list(c.keys()):\n        if c[k]>=2:\n            ans+=1\n    print(ans)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "import math\na,b=map(int,input().split())\ngcd=math.gcd(a,b)\n\ndef prime_factorization(n):\n  i=2\n  prime=[]\n  if n%i==0:\n    n//=i\n    prime.append(2)\n    while n%i==0:\n      n//=i\n  i+=1\n  k=int(n**0.5)+1\n  for j in range(i,k+1,2):\n    if n%j==0:\n      n//=j\n      prime.append(j)\n      while n%j==0:\n        n//=j\n  if n>1:\n    prime.append(n)\n  return prime\n\nprint(len(prime_factorization(gcd))+1)", "import math\na,b = map(int,input().split())\ngcd = math.gcd(a,b)\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\nprint(len(set(prime_factorize(gcd)))+1)", "import math\nA, B = map(int, input().split())\ngcd = math.gcd(A, B)\nans = [1]\nwhile gcd % 2 == 0:\n  ans.append(2)\n  gcd = gcd // 2\nf = 3\nwhile f * f <= gcd:\n  if gcd % f == 0:\n    ans.append(f)\n    gcd = gcd // f\n  else:\n    f += 2\nif gcd != 1:\n  ans.append(gcd)\nprint(len(set(ans)))", "import math\n\n\ndef main():\n    a, b = list(map(int, input().split()))\n    gcd = math.gcd(a, b)\n    ans = [1]\n    while gcd % 2 == 0:\n        ans.append(2)\n        gcd = gcd // 2\n    f = 3\n    while f * f <= gcd:\n        if gcd % f == 0:\n            ans.append(f)\n            gcd = gcd // f\n        else:\n            f += 2\n    if gcd != 1:\n        ans.append(gcd)\n    print((len(set(ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\n#https://qiita.com/snow67675476/items/e87ddb9285e27ea555f8\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5//1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp //= i\n            arr.append([i, cnt])\n    if temp!=1:\n        arr.append([temp, 1])\n    if arr==[]:\n        arr.append([n, 1])\n    return arr\n\na,b = map(int,input().split())\ng = math.gcd(a,b)\nif g==1:\n    print(1)\nelse:\n    yakusu = factorization(g)\n    print(len(yakusu)+1)", "import math\ndef gcd(a,b):\n    if a==0: return b\n    return gcd(b%a,a)\ndef div(n):\n    cnt = 0\n    temp = n\n    for i in range(2,int(math.sqrt(n))+1):\n        if temp%i==0:\n            while temp%i==0:\n                temp //= i\n            cnt += 1\n    if temp!=1:\n        cnt+=1\n    return cnt+1\n\na,b = map(int,input().split())\nprint(div(gcd(a,b)))", "import math\na,b=list(map(int,input().split()))\ngcd=math.gcd(a,b)\n\ndef prime_factorization(n):\n  i=2\n  prime=[]\n  while i*i<=n:\n    if n==1: break\n    if n%i:\n      i+=1\n    else:\n      n//=i\n      prime.append(i)\n      while n%i==0:\n        n//=i\n  if n>1:\n    prime.append(n)\n  return prime\n\nprint((len(prime_factorization(gcd))+1))\n#print(prime_factorization(gcd))\n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef factorization(num):\n    prime = []\n    n = num\n    p = 2\n    while p * p <= num:\n        if n % p == 0:\n            cnt = 0\n            while n % p == 0:\n                cnt += 1\n                n //= p\n            prime.append((p, cnt))\n        p += 1\n    if n != 1:\n        prime.append((n, 1))\n    if not prime:\n        prime.append((num, 1))\n    return prime\n\ndef Main():\n    a, b = read_ints()\n    g = GCD(a, b)\n    if g == 1:\n        print(1)\n        return\n    prime = factorization(g)\n    print(len(prime)+1)\n\ndef __starting_point():\n    Main()\n__starting_point()", "import sys\nimport math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef factorization(num):\n    prime = []\n    n = num\n    p = 2\n    while p * p <= num:\n        if n % p == 0:\n            cnt = 0\n            while n % p == 0:\n                cnt += 1\n                n //= p\n            prime.append((p, cnt))\n        p += 1\n    if n != 1:\n        prime.append((n, 1))\n    if not prime:\n        prime.append((num, 1))\n    return prime\n\ndef Main():\n    a, b = read_ints()\n    g = math.gcd(a, b)\n    if g == 1:\n        print(1)\n        return\n    prime = factorization(g)\n    print(len(prime)+1)\n\ndef __starting_point():\n    Main()\n__starting_point()", "from math import gcd\na, b = list(map(int, input().split()))\n\ndef make_divisors(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n //i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\nv = gcd(a,b) # greatest common divisors\ndivs = make_divisors(v)\n\nk = 1\nans = 0\nfor d in divs:\n    test = gcd(k, d)\n    if test == 1:\n        ans += 1\n        k *= d\nprint(ans)\n", "from math import *\ng = gcd(*map(int,input().split()))\nD = {}\nn = 2\n\nwhile n*n<=g:\n  if g%n:\n    n+=1\n  else:\n    g//=n\n    D[n]=D.get(n,0)+1\n\nif 1<g:\n  D[g]=D.get(g,0)+1\n\nprint(len(D)+1)", "a,b = map(int,input().split())\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\nA = set(prime_factorize(a))\nB = set(prime_factorize(b))\n\ncnt = 0\nfor i in A:\n    if i in B:\n        cnt += 1\nprint(cnt+1)", "def factorize(n):\n    fct = set()\n    b,e = 2,0\n    while b*b <= n:\n        while n % b == 0:\n            n //= b\n            e += 1\n        if e > 0:\n            fct.add(b)\n        b,e = b+1,0\n    if n > 1:\n        fct.add(n)\n    return fct\na,b = map(int,input().split())\nprint(len(factorize(a)&factorize(b))+1)", "from functools import lru_cache\n\ndef main():\n    a,b=map(lambda x: set(prime_factorize(int(x))),input().split())\n    print(len(a&b)+1)\n\n@lru_cache(maxsize=None)\ndef primes(n:int) -> list:\n    '''n\u4ee5\u4e0b\u306e\u5168\u7d20\u6570\u3092list\u3067\u8fd4\u3059'''\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\n# \u7d20\u6570\u5224\u5b9a\uff08\u5358\u7d14\u306a\u7d20\u6570\u5224\u5b9a\u306a\u3089\u5341\u5206\u65e9\u3044\u3002\u5927\u91cf\u306b\u3084\u308b\u5834\u5408\u306fX in primes\u304c\u3088\u3055\u305d\u3046\uff09\n@lru_cache(maxsize=None)\ndef is_prime(n: int) -> bool:\n    '''\u5f15\u6570n\u304c\u7d20\u6570\u3067\u3042\u308c\u3070True\u3001\u305d\u3046\u3067\u306a\u3051\u308c\u3070False\u3092\u8fd4\u3059'''\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# \u7d20\u56e0\u6570\u5206\u89e3\n@lru_cache(maxsize=None)\ndef prime_factorize(n: int) -> list:\n    '''\u5f15\u6570n\u306e\u7d20\u56e0\u6570\u5206\u89e3\u7d50\u679c\u306elist\u3092\u8fd4\u3059\u3002'''\n    arr = []\n    # 2\u3067\u5272\u308a\u7d9a\u3051\u5947\u6570\u307e\u3067\u9084\u5143\u3059\u308b\n    while n % 2 == 0:\n        arr.append(2)\n        n //= 2\n    # sqrt(n)\u307e\u3067\u306e\u7d20\u6570\u3067\u8a66\u3057\u5272\n    for f in primes(int(n**0.5)):\n        while n % f == 0:\n            arr.append(f)\n            n //= f\n    if n != 1:\n        arr.append(n)\n    return arr\n\n#\u7d04\u6570\u30ea\u30b9\u30c8\ndef make_divisors(n: int) -> list:\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n        \ndef __starting_point():\n    main()\n__starting_point()", "from math import gcd\nA, B = map(int, input().split())\ndef factorize(n):\n    arr = []\n    temp = n\n    for i in range(2, int(n**0.5)+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i ==0:\n                cnt += 1\n                temp //= i\n            arr.append([i, cnt])\n    if temp != 1:\n        arr.append([temp, 1])\n    if arr == []:\n        arr.append([n, 1])\n    return arr\n\nn = gcd(A, B)\nans = factorize(n)\nif ans[0][0] == 1:\n    print(1)\n    return\nprint(len(ans)+1)", "a,b=map(int,input().split())\ndef gcd(a,b):\n  if b==0:\n    return a\n  else:\n    return gcd(b,a%b)\ndef factorize(x):\n  i=2\n  res=[]\n  while i*i<=x:\n    while x%i==0:\n      x//=i\n      res.append(i)\n    i+=1\n  if x>1:\n    res.append(x)\n  return res\ng=gcd(a,b)\nf=factorize(g)\nprint(len(set(f))+1)", "import math\nA,B = list(map(int,input().split()))\n\ngcd = math.gcd(A,B)\nd = []\nif A == 1 or B == 1 :\n    print((1))\n    return\nans = [1]\nwhile gcd %2 == 0 :\n    gcd //= 2\n    ans.append(2)\ni = 3\nwhile i * i <= gcd :\n    if gcd %i == 0 :\n        ans.append(i)\n        gcd //= i\n    else :\n        i += 2\nif gcd != 1 :\n    ans.append(gcd)\nprint((len(set(ans))))\n", "import math\na, b = map(int, input().split())\ngcd = math.gcd(a,b)\n\ndef fctr1(n):\n    f=[]\n    c=0\n    r=int(n**0.5)\n    for i in range(2,r+2):\n        while n%i==0:\n            c+=1\n            n=n//i\n        if c!=0:\n            f.append([i,c])\n            c=0\n    if n!=1:\n        f.append([n,1])\n    return f\n\nprint(len(fctr1(gcd))+1)"]
["n, m, k = input().split(' ')\nn = int(n)\nm = int(m)\nk = int(k)\nind = []\npre = []\n\nfor _ in range(n):\n    s = input()\n    ind.append([])\n    for i, c in enumerate(s):\n        if c == '1':\n            ind[-1].append(i)\n\nfor i in range(n):\n    pre.append([])\n    for j in range(k + 1):\n        pre[i].append([])\n        if len(ind[i]) > j:\n            pre[i][j] = ind[i][-1] - ind[i][0] + 1\n        else:\n            pre[i][j] = 0\n            continue\n        for x in range(j + 1):\n            y = len(ind[i]) - 1 - j + x\n\n            if y >= x and ind[i][y] - ind[i][x] + 1 < pre[i][j]:\n                pre[i][j] = ind[i][y] - ind[i][x] + 1\ndp = [[]]\n\nfor i in range(k + 1):\n    dp[0].append(pre[0][i])\n\n\nfor i in range(1, n):\n    dp.append([])\n    for j in range(0, k + 1):\n        dp[i].append(pre[i][j] + dp[i - 1][0])\n        for z in range(j + 1):\n            dp[i][j] = min(dp[i][j], dp[i - 1][z] + pre[i][j - z])\n\nprint(dp[n - 1][k])\n", "import queue\nintput = lambda:list(map(int, input().split()))\n\nN, M, K = intput()\nht = [[] for _ in range(N)]\nfor _ in range(N):\n    day = input()\n    ht[_] = [i for i in range(M) if day[i] == '1']\n\n# req[i][j] -- required hours for day i if j lessons skipped\n# dp[i][j] -- required hours up to day i if j lesson skipped\n# dp[i+1][j+z] = dp[i][j] + req[i][z]\n\ntc = [1,2,3,8,9]\n# just return dp[-1][-1]\nreq = [[0 for _ in range(M+1)] for __ in range(N)]\ndp = [[0 for _ in range(K+1)] for __ in range(N)]\nfor i in range(N):\n    # cost to skip j lessons today\n    for j in range(len(ht[i])):\n        req[i][j] = ht[i][-1] - ht[i][0] + 1  # default large num\n        # if start at the first-th lesson\n        for first in range(j+1):\n            last = first + len(ht[i])-j-1\n            cost = ht[i][last]-ht[i][first]+1\n            if last >= first:\n                req[i][j] = min(req[i][j], cost)\n\nfor i in range(min(len(req[0]), len(dp[0]))):\n    dp[0][i] = req[0][i]\nfor i in range(1, N):\n    # total skipped up to this point\n    for j in range(K+1):\n        dp[i][j] = dp[i-1][j] + req[i][0]\n        # additional skipped for this day -- min of (skips left, curr skips, num lessons)\n        for z in range(1+min(j, len(ht[i]))):\n            dp[i][j] = min(dp[i][j], dp[i-1][j-z] + req[i][z])\n\n# print('{}\\n{}'.format(req,dp))\nprint(dp[-1][-1])\n", "R = lambda: map(int, input().split())\nn, m, k = R()\ncls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)]\ndp = [[n * m] * (k + 1) for i in range(n + 1)]\ndp.append([0] * (k + 1))\nfor i in range(n):\n    row = cls[i]\n    c2l = [m + 1] * (m + 1)\n    c2l[0] = row[-1] - row[0] + 1 if row else 0\n    c2l[len(row)] = 0\n    for r in range(len(row)):\n        for l in range(r + 1):\n            c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1)\n    for j in range(k + 1):\n        for c, l in enumerate(c2l):\n            if j + c <= k and l < m + 1:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l)\nprint(min(dp[n - 1]))", "def min_sub_array(day, k):\n    if not day:\n        return [0] * (k + 1)\n    n = len(day)\n    best = [float('inf')] * (n + 1)\n    best[0] = 0\n    best[1] = 1\n    for size in range(2, n + 1):\n        for i in range(n + 1 - size):\n            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)\n    output = [0] * (k + 1)\n    for i in range(k + 1):\n        if n - i > 0:\n            output[i] = best[n - i]\n    return output\n\n\nN, M, K = list(map(int, input().split()))\n\nday = [i for i, val in enumerate(input()) if val == '1']\nbest = min_sub_array(day, K)\n\nfor _ in range(N - 1):\n    day = [i for i, val in enumerate(input()) if val == '1']\n    new_day_best = min_sub_array(day, K)\n\n    new_best = [float('inf')] * (K + 1)\n    for i in range(K + 1):\n        for j in range(i + 1):\n            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])\n    best = new_best\nprint(best[K])\n", "import sys\ninput = sys.stdin.readline\n\ndef int_array():\n\treturn list(map(int, input().strip().split()))\n\ndef float_array():\n\treturn list(map(float, input().strip().split()))\n\ndef str_array():\n\treturn input().strip().split()\nfrom collections import Counter\nimport math\nimport bisect\nfrom collections import deque\nn,m,lesson=int_array()\ndp=[[250005 for i in range(lesson+2)]for j in range(n+1)]\ndays=[[] for i in range(n)]\nfor i in range(n):\n\ts=input()\n\tfor  j in range(m):\n\t\tif s[j]==\"1\":\n\t\t\tdays[i].append(j+1)\n\nm=[[250005 for i in range(lesson+2)]for j in range(n+1)]\nfor i in range(n):\n\tfor j in range(lesson+1):\n\t\tif j<=len(days[i]):\n\t\t\tif j==len(days[i]):\n\t\t\t\tm[i][j]=0\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tfor k  in range(0,j+1):\n\t\t\t\t\tvar=days[i][0+k]\n\t\t\t\t\tvar1=days[i][-1*max(1,1+(j-k))]\n\t\t\t\t\tm[i][j]=min(m[i][j],var1-var+1)\n\n\n\nfor i in range(lesson+1):\n\tdp[0][i]=m[0][i]\nfor i in range(1,n):\n\tfor j in range(lesson+1):\n\t\tfor k in range(j+1):\n\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k])\n\t\t\t#dp[i][j] = min(dp[i][j], dp[i - 1][k]+m[i][j-k])\n\nprint(min(dp[n-1]))\n\n", "import sys\n\nn, m, k = list(map(int, input().split()))\ntable = [input() for _ in range(n)]\n\ndp = [0]*(k+1)\n\nfor a in table:\n    one = []\n    for i in range(m):\n        if a[i] == '1':\n            one.append(i)\n\n    if not one:\n        continue\n\n    ni = len(one)\n    subdp = [10**9] * (ni+1)\n    subdp[-1] = 0\n\n    for i in range(ni):\n        for j in range(i, ni):\n            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)\n\n    next_dp = [10**9]*(k+1)\n    for i in range(k, -1, -1):\n        for j in range(ni+1):\n            if i+j > k:\n                break\n            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])\n    dp = next_dp\n\nprint(min(dp))\n"]
["import sys\n\nn, m, k = (int(x) for x in sys.stdin.readline().split(' '))\nmaze = []\nfor i in range(n):\n    maze.append(list(sys.stdin.readline().strip()))\n\nfor y in range(n):\n    for x in range(m):\n        if maze[y][x] == '.':\n            x0, y0 = x, y\n            break\n    else:\n        continue\n    break\nelse:\n    print('no spare room')\n    return\n\nstack = []\nstack.append((x0,y0))\nwhile stack:\n    x, y = stack[-1]\n\n    if maze[y][x] == '.':\n        maze[y][x] = '0'\n        if x > 0 and maze[y][x-1] == '.':\n            stack.append((x-1, y))\n    elif maze[y][x] == '0':\n        maze[y][x] = '1'\n        if y < n-1 and maze[y+1][x] == '.':\n            stack.append((x, y+1))\n    elif maze[y][x] == '1':\n        maze[y][x] = '2'\n        if x < m-1 and maze[y][x+1] == '.':\n            stack.append((x+1, y))\n    elif maze[y][x] == '2':\n        maze[y][x] = '3'\n        if y > 0 and maze[y-1][x] == '.':\n            stack.append((x, y-1))\n    elif maze[y][x] == '3':\n        if k > 0:\n            maze[y][x] = 'X'\n            k -= 1\n        stack.pop()\n\nfor y in range(n):\n    for x in range(m):\n        maze[y][x] = '.' if maze[y][x] == '3' else maze[y][x]\n\nprint(\"\\n\".join([\"\".join(s) for s in maze]))\n", "n, m, k = list(map(int, input().split()))\nt = [input().replace('.', 'X') for i in range(n)]\nk = n * m - k - sum(i.count('#') for i in t)\nt = [list(i) for i in t]\ni, p = 0, []\nwhile k:\n    if 'X' in t[i]:\n        j = t[i].index('X')\n        t[i][j], p = '.', [(i, j)]\n        k -= 1\n        break\n    i += 1\nwhile k:\n    x, y = p.pop()\n    for i, j in ((x, y - 1), (x, y + 1), (x - 1, y), (x + 1, y)):\n        if i < 0 or j < 0: continue\n        if i < n and j < m and t[i][j] == 'X':\n            t[i][j] = '.'\n            p.append((i, j))\n            k -= 1\n            if k == 0: break\nfor i in range(n): t[i] = ''.join(t[i])\nprint('\\n'.join(t))\n", "a, b, c = map(int, input().split(' '))\narray = [[i for i in input()] for j in range(a)]\np = []\nx = 0\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            p = [(i, j)]\n            x += 1\n\nvisited = [[False for _ in range(b)] for i in range(a)]\ndef ok(i, j):\n    if 0 <= i <= a-1 and 0 <= j <= b-1:\n        if array[i][j] == '.':\n            return True\n    return False\n\nsa = 0\nwhile sa < x-c:\n    i, j = p[-1]\n    p.pop()\n    #print(i,j,sa)\n    if not visited[i][j]:\n        if ok(i, j-1):\n            if not visited[i][j-1]:\n                p.append((i, j-1))\n        if ok(i, j+1):\n            if not visited[i][j+1]:\n                p.append((i, j+1))\n        if ok(i+1, j):\n            if not visited[i+1][j]:\n                p.append((i+1, j))\n        if ok(i-1, j):\n            if not visited[i-1][j]:\n                p.append((i-1, j))\n        visited[i][j] = True\n        sa+=1\n\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.' and not visited[i][j]:\n            array[i][j] = 'X'\n\nfor each in [''.join(i) for i in array]:\n    print(each)", "a, b, c = map(int, input().split(' '))\narray = [[i for i in input()] for j in range(a)]\n\np = []\nx = 0\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            x += 1\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            p.append((i,j))\n            break\nvisited = [[False for _ in range(b)] for i in range(a)]\ndef ok(i, j):\n    if 0 <= i <= a-1 and 0 <= j <= b-1:\n        if array[i][j] == '.':\n            return True\n    return False\n\nsa = 0\nwhile sa < x-c:\n    i, j = p.pop()\n    if visited[i][j]:\n        continue\n    #print(i,j,sa)\n    if ok(i, j-1):\n        if not visited[i][j-1]:\n            p.append((i, j-1))\n    if ok(i, j+1):\n        if not visited[i][j+1]:\n            p.append((i, j+1))\n    if ok(i+1, j):\n        if not visited[i+1][j]:\n            p.append((i+1, j))\n    if ok(i-1, j):\n        if not visited[i-1][j]:\n            p.append((i-1, j))\n    visited[i][j] = True\n    sa+=1\n\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.' and not visited[i][j]:\n            array[i][j] = 'X'\n\nfor each in [''.join(i) for i in array]:\n    print(each)", "a, b, c = map(int, input().split(' '))\narray = [[i for i in input()] for j in range(a)]\np = []\nx = 0\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            p.append((i, j))\n            x += 1\n\nvisited = [[False] * b for i in range(a)]\ndef ok(i, j):\n    if 0 <= i <= a-1 and 0 <= j <= b-1:\n        if array[i][j] != '#':\n            return True\n    return False\nsa = 0\nwhile sa < x-c:\n    i, j = p.pop()\n    \n    if visited[i][j]:\n    \n        continue\n    if ok(i, j-1):\n        if not visited[i][j-1]:\n            p.append((i, j-1))\n\n    if ok(i, j+1):\n        if not visited[i][j+1]:\n            p.append((i, j+1))\n\n    if ok(i+1, j):\n        if not visited[i+1][j]:\n            p.append((i+1, j))\n\n    if ok(i-1, j):\n        if not visited[i-1][j]:\n            p.append((i-1, j))\n     \n    visited[i][j] = True\n    sa += 1\n\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.' and not visited[i][j]:\n            array[i][j] = 'X'\n\nfor each in [''.join(i) for i in array]:\n    print(each)", "def main():\n    n, m, k = map(int, input().split())\n    mn = m * n\n    l = [_ == '.' for _ in range(n) for _ in input()]\n    neigh = [[] for _ in range(mn)]\n    for y in range(n - 1):\n        for x in range(m):\n            yx = y * m + x\n            if l[yx] and l[yx + m]:\n                neigh[yx].append(yx + m)\n                neigh[yx + m].append(yx)\n    for y in range(n):\n        for x in range(m - 1):\n            yx = y * m + x\n            if l[yx] and l[yx + 1]:\n                neigh[yx].append(yx + 1)\n                neigh[yx + 1].append(yx)\n    res = [True] * mn\n    nxt = {l.index(True)}\n    cnt = sum(l) - k\n    while cnt:\n        cur, nxt = nxt, set()\n        for i in cur:\n            if res[i]:\n                res[i] = False\n                cnt -= 1\n                if not cnt:\n                    break\n                for j in neigh[i]:\n                    nxt.add(j)\n    for x, (a, b) in enumerate(zip(res, l)):\n        if a and b:\n            l[x] = 2\n    l = [''.join(('#', '.', 'X')[_] for _ in l[x:x + m]) for x in range(0, mn, m)]\n    print('\\n'.join(l))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n, m, k = map(int, input().split())\n    mn = m * n\n    l = [_ == '.' for _ in range(n) for _ in input()]\n    neigh = [[] for _ in range(mn)]\n    for y in range(n - 1):\n        for x in range(m):\n            yx = y * m + x\n            if l[yx] and l[yx + m]:\n                neigh[yx].append(yx + m)\n                neigh[yx + m].append(yx)\n    for y in range(n):\n        for x in range(m - 1):\n            yx = y * m + x\n            if l[yx] and l[yx + 1]:\n                neigh[yx].append(yx + 1)\n                neigh[yx + 1].append(yx)\n    res = [True] * mn\n    cur, nxt = [], [l.index(True)]\n    cnt = sum(l) - k\n    while cnt:\n        cur, nxt = nxt, cur\n        nxt.clear()\n        for i in cur:\n            if res[i]:\n                res[i] = False\n                cnt -= 1\n                if not cnt:\n                    break\n                for j in neigh[i]:\n                    if res[j]:\n                        nxt.append(j)\n    for x, (a, b) in enumerate(zip(res, l)):\n        if a and b:\n            l[x] = 2\n    l = [''.join(('#', '.', 'X')[_] for _ in l[x:x + m]) for x in range(0, mn, m)]\n    print('\\n'.join(l))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n, m, k = map(int, input().split())\n    mn = m * n\n    l = [_ == '.' for _ in range(n) for _ in input()]\n    neigh = [[] for _ in range(mn)]\n    for y in range(n - 1):\n        for x in range(m):\n            yx = y * m + x\n            if l[yx] and l[yx + m]:\n                neigh[yx].append(yx + m)\n                neigh[yx + m].append(yx)\n    for y in range(n):\n        for x in range(m - 1):\n            yx = y * m + x\n            if l[yx] and l[yx + 1]:\n                neigh[yx].append(yx + 1)\n                neigh[yx + 1].append(yx)\n    res = [True] * mn\n    cur, nxt = set(), {l.index(True)}\n    cnt = sum(l) - k\n    while cnt:\n        cur, nxt = nxt, cur\n        while cur:\n            i = cur.pop()\n            if res[i]:\n                res[i] = False\n                cnt -= 1\n                if not cnt:\n                    break\n                for j in neigh[i]:\n                    if res[j]:\n                        nxt.add(j)\n    for x, (a, b) in enumerate(zip(res, l)):\n        if a and b:\n            l[x] = 2\n    l = [''.join(('#', '.', 'X')[_] for _ in l[x:x + m]) for x in range(0, mn, m)]\n    print('\\n'.join(l))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n, m, k = map(int, input().split())\n    mn = m * n\n    l = [_ == '.' for _ in range(n) for _ in input()]\n    neigh = [[] for _ in range(mn)]\n    for y in range(n - 1):\n        for x in range(m):\n            yx = y * m + x\n            if l[yx] and l[yx + m]:\n                neigh[yx].append(yx + m)\n                neigh[yx + m].append(yx)\n    for y in range(n):\n        for x in range(m - 1):\n            yx = y * m + x\n            if l[yx] and l[yx + 1]:\n                neigh[yx].append(yx + 1)\n                neigh[yx + 1].append(yx)\n    res = [True] * mn\n    cur, nxt = set(), {l.index(True)}\n    cnt = sum(l) - k\n    while cnt:\n        cur, nxt = nxt, cur\n        while cur:\n            i = cur.pop()\n            if res[i]:\n                res[i] = False\n                cnt -= 1\n                if not cnt:\n                    break\n                for j in neigh[i]:\n                    nxt.add(j)\n    for x, (a, b) in enumerate(zip(res, l)):\n        if a and b:\n            l[x] = 2\n    l = [''.join(('#', '.', 'X')[_] for _ in l[x:x + m]) for x in range(0, mn, m)]\n    print('\\n'.join(l))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from queue import Queue, PriorityQueue\nn, m, k = [int(x) for x in input().split()]\na = []\nfor i in range(n):\n    a.append(list(input()))\nlvl = [[0] * m for i in range(n)]\nx = y = -1\nfor i in range(n):\n    if '.' in a[i]:\n        x = i\n        y = a[i].index('.')\n        break\nq = Queue()\nq.put((x, y))\nans = []\nlvl[x][y] = 1\nwhile not q.empty():\n    x, y = q.get()\n    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx < 0 or ny < 0 or nx >= n or ny >= m:\n            continue\n        if lvl[nx][ny]:\n            continue\n        if a[nx][ny] == '#':\n            continue\n        lvl[nx][ny] = lvl[x][y] + 1\n        q.put((nx, ny))\n        ans.append((-lvl[nx][ny], nx, ny))\nans.sort()\nfor i in range(k):\n    _, x, y = ans[i]\n    a[x][y] = 'X'\nprint('\\n'.join(''.join(l) for l in a))", "# 377A\nfrom sys import stdin\n\n__author__ = 'artyom'\n\n\ndef read_int_ary():\n  return map(int, stdin.readline().strip().split())\n\n\ndef dfs(graph, start):\n  visited, tree, processed, stack = set(), [], set(), [start]\n  while stack:\n    vertex = stack.pop()\n    if vertex not in visited:\n      visited.add(vertex)\n      stack.extend(graph[vertex] - visited)\n    if not vertex in processed:\n      tree.append(vertex)\n    processed.add(vertex)\n  return tree\n\n\nn, m, k = read_int_ary()\ngrid = []\nfor i in range(n):\n  grid.append(list(stdin.readline().strip()))\n\ngraph = {}\nfor i in range(n):\n  for j in range(m):\n    if grid[i][j] == '.':\n      v = (i, j)\n      graph[v] = set()\n      if i > 0 and grid[i - 1][j] == '.':\n        u = (i - 1, j)\n        graph[v].add(u)\n        graph[u].add(v)\n      if j > 0 and grid[i][j - 1] == '.':\n        u = (i, j - 1)\n        graph[v].add(u)\n        graph[u].add(v)\n\nprocessed = dfs(graph, next(iter(graph.keys())))\n\nadded = set()\nwhile len(added) < k:\n  vertex = processed.pop()\n  grid[vertex[0]][vertex[1]] = 'X'\n  added.add(vertex)\nfor i in range(n):\n  print(''.join(grid[i]))", "# 377A\nfrom sys import stdin\n\n__author__ = 'artyom'\n\n\ndef read_int_ary():\n  return map(int, stdin.readline().strip().split())\n\n\ndef dfs(graph, start):\n  visited, tree, processed, stack = set(), [], set(), [start]\n  while stack:\n    vertex = stack.pop()\n    if vertex not in visited:\n      visited.add(vertex)\n      stack.extend(graph[vertex] - visited)\n    if not vertex in processed:\n      tree.append(vertex)\n    processed.add(vertex)\n  return tree\n\n\nn, m, k = read_int_ary()\ngrid = []\nfor i in range(n):\n  grid.append(list(stdin.readline().strip()))\n\ngraph = {}\nfor i in range(n):\n  for j in range(m):\n    if grid[i][j] == '.':\n      v = (i, j)\n      graph[v] = set()\n      if i > 0 and grid[i - 1][j] == '.':\n        u = (i - 1, j)\n        graph[v].add(u)\n        graph[u].add(v)\n      if j > 0 and grid[i][j - 1] == '.':\n        u = (i, j - 1)\n        graph[v].add(u)\n        graph[u].add(v)\n\nprocessed = dfs(graph, next(iter(graph.keys())))\n\ni = 0\nwhile i < k:\n  vertex = processed.pop()\n  grid[vertex[0]][vertex[1]] = 'X'\n  i += 1\nfor i in range(n):\n  print(''.join(grid[i]))", "maze = [['0' for j in range(510)] for i in range(510)]\nvisited = [[0 for j in range(510)] for i in range(510)]\nn,m,k = tuple(int(i) for i in input().split())\nsx = -1\nsy = -1\nfor i in range(n):\n\ts = input()\n\tfor j in range(m):\n\t\tmaze[i][j] = s[j]\n\t\tif(sx==-1 and s[j]=='.'):\n\t\t\tsx=i\n\t\t\tsy=j\n\n\nstack = [(sx,sy)]\nans = []\nwhile(len(stack)!=0):\n\tcurr = stack.pop()\n\tx = curr[0]\n\ty = curr[1]\n\t#print(x,y)\n\tif(x<0 or y<0 or x>=n or y>=m or visited[x][y]==1 or maze[x][y]=='#'):\n\t\tcontinue\n\tvisited[x][y] = 1\n\tstack.append((x+1,y))\n\tstack.append((x-1,y))\n\tstack.append((x,y+1))\n\tstack.append((x,y-1))\n\tans.append(curr)\n\nfor i in range(k):\n\tcurr = ans[len(ans)-i-1]\n\tx = curr[0]\n\ty = curr[1]\n\tmaze[x][y] = 'X'\ns = \"\"\nfor i in range(n):\n\tfor j in range(m):\n\t\ts+=maze[i][j]\n\ts+=\"\\n\"\nprint(s)\n", "from collections import deque,namedtuple\ndx = [0,0,1,-1]\ndy = [1,-1,0,0]\n\ndef main():\n    n,m,limit = map(int,input().split())\n    a,sx,sy,tot = [],0,0,0\n    for i in range(n):\n        s,t = input(),[]\n        for j,c in enumerate(s):\n            if c == '.':\n                sx,sy = i,j\n                tot += 1\n                c = 'X'\n            t.append(c)\n        a.append(t[:])\n\n    dq,done = deque([(sx,sy)]),0\n    while len(dq) > 0:\n        now = dq.pop()\n        if done >= tot - limit:\n            break\n        if(a[now[0]][now[1]] == 'X'):\n            done += 1\n        a[now[0]][now[1]] = '.'\n        for i in range(4):\n            tx,ty = dx[i] + now[0],dy[i] + now[1]\n            if 0 <= tx < n and 0 <= ty < m and a[tx][ty] == 'X':\n                dq.append((tx,ty))\n    for i in a:\n        print(\"\".join(i))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque,namedtuple\ndx = [0,0,1,-1]\ndy = [1,-1,0,0]\n\ndef main():\n    n,m,limit = map(int,input().split())\n    a,sx,sy,tot = [],0,0,0\n    for i in range(n):\n        s,t = input(),[]\n        for j,c in enumerate(s):\n            if c == '.':\n                sx,sy = i,j\n                tot += 1\n                c = 'X'\n            t.append(c)\n        a.append(t[:])\n\n    dq,done = deque([(sx,sy)]),0\n    while len(dq) > 0:\n        now = dq.pop()\n        if done >= tot - limit:\n            break\n        if(a[now[0]][now[1]] == 'X'):\n            done += 1\n        else:\n            continue\n        a[now[0]][now[1]] = '.'\n        for i in range(4):\n            tx,ty = dx[i] + now[0],dy[i] + now[1]\n            if 0 <= tx < n and 0 <= ty < m and a[tx][ty] == 'X':\n                dq.append((tx,ty))\n    for i in a:\n        print(\"\".join(i))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque,namedtuple\ndx = [0,0,1,-1]\ndy = [1,-1,0,0]\n\ndef main():\n    n,m,limit = map(int,input().split())\n    a,sx,sy,tot = [],0,0,0\n    for i in range(n):\n        s,t = input(),[]\n        for j,c in enumerate(s):\n            if c == '.':\n                sx,sy = i,j\n                tot += 1\n                c = 'X'\n            t.append(c)\n        a.append(t[:])\n\n    dq,done = deque([(sx,sy)]),0\n    while len(dq) > 0:\n        now = dq.popleft()\n        if done >= tot - limit:\n            break\n        if(a[now[0]][now[1]] == 'X'):\n            done += 1\n        else:\n            continue\n        a[now[0]][now[1]] = '.'\n        for i in range(4):\n            tx,ty = dx[i] + now[0],dy[i] + now[1]\n            if 0 <= tx < n and 0 <= ty < m and a[tx][ty] == 'X':\n                dq.append((tx,ty))\n    for i in a:\n        print(\"\".join(i))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ndef solve(n, m, k, grid, r, c):\n    move = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[False for i in range(m)] for j in range(n)]\n    q = [(r, c)]\n    grid[r][c] = 'O'\n    visited[r][c] = True\n    k -= 1\n    while k != 0 and len(q) != 0:\n        r, c = q.pop()\n        for i in range(4):\n            x, y = r + move[i][0], c + move[i][1]\n            if x >= 0 and x < n and y >= 0 and y < m and not visited[x][y] and grid[x][y] == '.':\n                q.append((x, y))\n                grid[x][y] = 'O'\n                visited[x][y] = True\n                k -= 1\n                if k == 0:\n                    break\n\nn, m, k = list(map(int, sys.stdin.readline().split()))\ngrid = []\nfor i in range(n):\n    s = list(input())\n    grid.append(s)\n\nr = 0\nc = 0\ncnt = 0\nfind = False\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            cnt += 1\n            if not find:\n                r, c = i, j\n                find = True\n\nsolve(n, m, cnt-k, grid, r, c)\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            grid[i][j] = 'X'\n#print(grid)\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'O':\n            grid[i][j] = '.'\n\nfor i in range(n):\n    print(''.join(map(str, grid[i])))\n\n", "from typing import List, Tuple, Set\n\n\ndef find_neighbors(x: int, y: int, m: int, n: int) -> List[Tuple[int, int]]:\n    neighbors = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n    return [p for p in neighbors if 0 <= p[0] < n and 0 <= p[1] < m]\n\n\ndef dfs(\n    n: int,\n    m: int,\n    maze: List[List[str]],\n    start: Tuple[int, int],\n    max_path_length: int,\n) -> Set[Tuple[int, int]]:\n    visited = [[0] * m for _ in range(n)]\n    d = [start]\n    path = set()\n    while d:\n        x, y = d.pop()\n        visited[x][y] = 1\n        path.add((x, y))\n        for xo, yo in find_neighbors(x, y, m, n):\n            if not visited[xo][yo] and maze[xo][yo] == '.':\n                d.append((xo, yo))\n        if len(path) == max_path_length:\n            break\n    return path\n\n\ndef place_blocks(\n    n: int,\n    m: int,\n    k: int,\n    maze: List[List[str]],\n    path: Set[Tuple[int, int]]\n) -> List[List[str]]:\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == '.' and k > 0 and (i, j) not in path:\n                maze[i][j] = 'X'\n                k -= 1\n            if k == 0:\n                return maze\n\n\ndef solve(n: int, m: int, k: int, maze: List[List[str]]) -> List[List[str]]:\n    empty_cell_count = sum(row.count('.') for row in maze)\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] != '#':\n                path = dfs(n, m, maze, (i, j), empty_cell_count - k)\n                if len(path) >= empty_cell_count - k:\n                    return place_blocks(n, m, k, maze, path)\n\nn, m, k = list(map(int, input().split()))\nmaze = [list(input()) for _ in range(n)]\n\nfor line in solve(n, m, k, maze):\n    print(''.join(line))", "from sys import stdin\nfrom collections import deque\n\ndef __starting_point():\n    R, C, K = list(map(int, stdin.readline().rstrip().split()))\n    maze = []\n    start = None\n    for r in range(0, R):\n        line = stdin.readline()\n        if start is None:\n            for c in range(0, C):\n                if line[c] == '.':\n                    start = (r, c)\n                    break\n        maze.append(list(line))\n\n    order = deque()\n    stack = deque()\n    stack.append(start)\n\n    def add_to_stack(row, col):\n        if 0 <= row < R and \\\n                0 <= col < C and \\\n                maze[row][col] == '.':\n            stack.append((row, col))\n            maze[row][col] = ','\n\n    while len(stack) > 0:\n        (r, c) = stack.pop()\n        order.append((r, c))\n        add_to_stack(r-1, c)\n        add_to_stack(r+1, c)\n        add_to_stack(r, c-1)\n        add_to_stack(r, c+1)\n\n    for k in range(0, K):\n        (r, c) = order.pop()\n        maze[r][c] = 'X'\n\n    for r in range(0, R):\n        line = ''\n        for c in range(0, C):\n            ch = maze[r][c]\n            if ch == ',':\n                line += '.'\n            else:\n                line += ch\n        print(line)\n\n\n__starting_point()", "n,m,k=list(map(int,input().split()))\nM=[input() for i in range(n)]\nT=[[] for i in range(n)]\np=0\nfor i in range(n) :\n    for j in range(m) :\n        if M[i][j]=='#' :\n            T[i].append(M[i][j])\n        else :\n            T[i].append('X')\nfor i in range(n) :\n    p=p+M[i].count('#')\nfor i in range(n) :\n    for j in range(m) :\n        if M[i][j]=='.' :\n            a=i\n            b=j\n            break\nt=(n*m)-p-k\nl=[[a,b]]\nT[a][b]='.'\nt=t-1\nwhile t>0  :\n    r=l[0]\n    \n    del(l[0])\n    i=r[0]\n    j=r[1]\n  \n    if i+1!=n  :\n        if M[i+1][j]=='.' and T[i+1][j]!='.'  :\n            l.append([i+1,j])\n            T[i+1][j]='.'\n            t=t-1\n    if t<=0 :\n        break\n    if i-1!=-1  :\n        if M[i-1][j]=='.' and T[i-1][j]!='.'  :\n            l.append([i-1,j])\n            T[i-1][j]='.'\n            t=t-1\n    if t<=0 :\n        break\n    if j+1!=m  :\n        if M[i][j+1]=='.' and  T[i][j+1]!='.'  :\n            l.append([i,j+1])\n            T[i][j+1]='.'\n            t=t-1\n    if t<=0 :\n        break\n    if j-1!=-1  :\n        if M[i][j-1]=='.' and  T[i][j-1]!='.' :\n            l.append([i,j-1])\n            T[i][j-1]='.'\n            t=t-1\n            \nfor i in range(n) :\n    S=''\n    for j in range(m) :\n        S=S+T[i][j]\n    print(S)\n", "#make every dot into X,turn the question into find a connected line of dot\n#scan the graph and find the first X's position in every line,and to each X find if there is another\n#X near it ,take it in and do it again\nn,m,k = map(int,input().split())\ng = [input().replace('.','X') for i in range(n)]\nk = n*m - k - sum(i.count('#')for i in g)\ng = [list(i) for i in g]\ni,p = 0,[]\nwhile k:\n    if 'X'in g[i]:\n        j = g[i].index('X')\n        g[i][j],p = '.',[(i,j)]\n        k -= 1\n        break\n    i += 1\nwhile k:\n    x,y = p.pop()\n    for i,j in ((x,y-1),(x,y+1),(x-1,y),(x+1,y)):\n        if i < 0 or j < 0:\n            continue\n        if i < n and j < m and g[i][j] == 'X':\n            g[i][j] = '.'\n            p.append((i,j))\n            k -= 1\n            if k == 0:\n                break\nfor i in range(n):\n    g[i]=''.join(g[i])\nprint('\\n'.join(g))", "import sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 30)\n    g = []\n    adj = defaultdict(set)\n    vis = set()\n    def valid(x, y):\n        nonlocal n, m\n        return x >= 0 and x < n and y >= 0 and y < m\n    def bfs(x, y):\n        nonlocal g, vis, adj\n        q = []\n        q.append((x, y))\n        vis.add((x, y))\n        s = 0\n        while len(q) > 0:\n            (x, y) = q.pop()\n            s += 1\n            for c in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                nx = c[0] + x\n                ny = c[1] + y\n                if valid(nx, ny) and (nx, ny) not in vis:\n                    if g[nx][ny] == '.':\n                        vis.add((nx, ny))\n                        q.append((nx, ny))\n        return s\n    def bfs2(x, y):\n        nonlocal g, vis, adj, count\n        q = []\n        q.append((x, y))\n        vis.add((x, y))\n        while len(q) > 0:\n            (x, y) = q.pop()\n            g[x][y] = 'o'\n            count -= 1\n            if count <= 0:\n                return\n            for c in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\n                nx = c[0] + x\n                ny = c[1] + y\n                if valid(nx, ny) and (nx, ny) not in vis:\n                    if g[nx][ny] == '.':\n                        vis.add((nx, ny))\n                        q.append((nx, ny))\n    (n, m, k) = list(map(int, input().split(' ')))\n    for i in range(n):\n        g.append(list(input()))\n    s = 0\n    f = False\n    l = None\n    for i in range(n):\n        if f:\n            break\n        for j in range(m):\n            if g[i][j] == '.' and (i, j) not in vis:\n                s = bfs(i, j)\n                l = (i, j)\n                f = True\n                break\n    vis = set()\n    count = s - k\n    bfs2(l[0], l[1])\n    f = lambda i: 'X' if i == '.' else ('#' if i == '#' else '.')\n    for row in g:\n        print(''.join(list(map(f, row))))\nmain()\n\n", "from collections import deque as dq\n\nclass Graph:\n    def __init__(self,n=0,m=0):\n        self.g=[None for i in range(n)]\n        self.vis=[[False for j in range(m)] for i in range(n)]\n        self.dx=(1,0,-1,0)\n        self.dy=(0,1,0,-1)\n\n    def affiche(self):\n        for i in range(len(self.g)):\n            print(\"\".join(self.g[i]))\n    def readG(self,n):\n        for i in range(n):\n            self.g[i]=list(input())\n\n    def get(self,i,j):\n        return self.g[i][j]\n            \n    def dfsIt(self,u):\n        nonlocal k,A\n        L=dq()\n        A=[]\n        L.append(u)        \n        while len(L)!=0:\n            u=L.pop()\n            self.vis[u[0]][u[1]]=True\n            b=True\n            for t in range(4):\n                x=u[0]+self.dx[t]\n                y=u[1]+self.dy[t]\n                if x>=0 and x<n and y>=0 and y<m and not self.vis[x][y] and self.g[x][y]!='#':\n                    self.vis[x][y]=True\n                    L.append((x,y))\n                    b=False\n            if b and k>0:\n                k-=1\n                self.g[u[0]][u[1]]='X'\n            else:\n                A.append(u)\n    \nn,m,k=list(map(int,input().split()))\ng=Graph(n,m)\ng.readG(n)\n\ndef f():\n    nonlocal n,m,g\n    for i in range(n):\n        for j in range(m):\n            if g.get(i,j)=='.':\n                return (i,j)\n            \ng.dfsIt(f())\nwhile k!=0:\n    k-=1\n    u=A.pop()\n    g.g[u[0]][u[1]]='X'\n\ng.affiche()\n    \n", "r,c,n = map(int,input().split())\nfield = []\nfield.append('#'*(c+2))\nfor _ in range(r):\n    field.append('#'+input()+'#')\nfield.append('#'*(c+2))\n\n\np_x = 0\np_y = 0\n\n\nnot_walls = 0\nfor x in range(1,r+1):\n    for y in range(1,c+1):\n        if field[x][y] == '#':continue\n        p_x,p_y = x,y\n        not_walls += 1\nprocess = [(p_x,p_y)]\nvalid = set()\n\nwhile len(valid) < (not_walls-n):\n    x,y = process.pop()\n    valid.add((x,y))\n\n    for a,b in [(1,0),(-1,0),(0,1),(0,-1)]:\n        if field[a+x][b+y] == '.' and (a+x,b+y) not in valid:\n            process.append((x+a,y+b))\n\n\n\nfor x in range(1,r+1):\n    for y in range(1,c+1):\n        if field[x][y] == '#':continue\n        if (x,y) not in valid:\n            field[x] = field[x][:y] + 'X' + field[x][y+1:]\n\nfield = [x[1:-1] for x in field[1:-1]]\nprint('\\n'.join(field))", "n, m, k = list(map(int, input().split()))\nmaze = [[\"#\"]*(m+2)]+[list(\"#\"+input()+\"#\") for i in range(n)]+[[\"#\"]*(m+2)]\nsteps = [[0,1],[0,-1],[1,0],[-1,0]]\n\nempty = -k\nx, y = None, None\nfor i in range(n+2):\n    empty += maze[i].count(\".\")\n    for j in range(m+2):\n        if maze[i][j] == \".\":\n            x, y = i, j\n            break\n\nstack = [(x,y)]\nwhile empty:\n    (x, y) = stack.pop()\n    if maze[x][y] == \"v\":\n        continue\n    for dx, dy in steps:\n        if maze[x+dx][y+dy] == \".\":\n            stack.append((x+dx, y+dy))\n    maze[x][y] = \"v\"\n    empty -= 1\n\nfor row in maze[1:-1]:\n    print(\"\".join(row[1:-1]).replace(\".\",\"X\").replace(\"v\",\".\"))\n"]
["import sys\nsys.setrecursionlimit(4100000)\n\nmod = 10 ** 9 + 7\n\nN, K = map(int,input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int,input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nans = K\n\ndef factorial(n, k, mod):\n    fact = 1\n    for integer in range(n, n-k, -1):\n        fact *= integer\n        fact %= mod\n    return fact\n\ndef dfs(parent, current):\n    ret = 1\n    for child in graph[current]:\n        if child != parent:\n            ret *= dfs(current, child)\n    L = len(graph[current])\n    R = K - 1\n    if parent != -1:\n        L -= 1\n        R -= 1\n    ret *= factorial(R, L, mod)\n    return ret % mod\n\nans *= dfs(-1, 0)\nans %= mod\n\nprint(ans)", "import sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().rstrip()\n\ndef per(n, r, mod=10**9+7):  # \u9806\u5217\u6570\n    per = 1\n    for i in range(r):\n        per = per*(n-i) % mod\n    return per\n \nn, k = map(int, input().split())\nmod=10**9+7\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndist = [-1] * (n+1)\ndist[0] = 0\ndist[1] = 0\n\nd = deque()\nd.append(1)\nans=k\nwhile d:\n    v = d.popleft()\n    cnt=0\n    for i in graph[v]:\n        if dist[i] != -1:\n            continue\n        dist[i] = dist[v] + 1\n        d.append(i)\n        cnt+=1\n    if cnt>0:\n        if v==1:\n            ans=ans*per(k-1,cnt)%mod\n        else:\n            ans=ans*per(k-2,cnt)%mod\n    \n\n\nprint(ans)", "from collections import deque, Counter\n\nN,K,*abf = map(int, open(0).read().split())\nab = [abf[i:i+2] for i in range(0, len(abf), 2)]\nconnected = [[] for _ in range(N+1)]\nm = 1000000007\nfor a, b in ab:\n    connected[a].append(b)\n    connected[b].append(a)\n    \ndist = [-1] * (N+1)\nd = deque([1])\nparents = [-1] * (N+1)\ndist[1] = 0\nwhile d:\n    temp = d.popleft()\n    for edge in connected[temp]:\n        if dist[edge] == -1:\n            d.append(edge)\n            dist[edge] = dist[temp] + 1\n            parents[edge] = temp\nans = K\nc = Counter(parents)\nfor x in c.items():\n    if x[0] < 1:\n        continue\n    elif x[0] == 1:\n        for i in range(1,x[1]+1):\n            ans = (ans*(K-i)) % m\n    else:\n        for i in range(2,x[1]+2):\n            ans = (ans*(K-i)) % m\nprint(ans)", "import sys\nsys.setrecursionlimit(10**9)\n\nMOD = 10**9 + 7\nn, k = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\nk_inv = pow(k, MOD - 2, MOD)\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\n\ndef dfs(v, v_p):\n    # \u5b50\u90e8\u5206\u6728\u306e\u5857\u308a\u65b9\u306e\u5834\u5408\u306e\u6570\n    if v_p == -1:  # root\n        c = k - 1\n    else:\n        c = k - 2\n\n    cnt = 1\n    i = 0\n    for v_next in graph[v]:\n        if v_next == v_p:\n            continue\n        cnt *= max(0, c - i)\n        cnt %= MOD\n        cnt *= dfs(v_next, v)\n        cnt %= MOD\n        i += 1\n    return cnt\n\n\nans = dfs(0, -1) * k % MOD\nprint(ans)\n", "N, K = map(int, input().split())\nmod = 1000000007\n\nE = [[] for i in range(N)]\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  E[a-1].append(b-1)\n  E[b-1].append(a-1)\n#\u3053\u3053\u307e\u3067\u3067\u6728\u3092\u30ea\u30b9\u30c8\u5316\n\ncounts = [False]*N\n#\u5404\u3005\u306e\u9802\u70b9\u306b\u3064\u3044\u30661\u56de\u305a\u3064\u8003\u3048\u308b\u3088\u3046\u306bTrue\u306b\u306a\u3063\u305f\u3089\u9032\u884c\u3057\u306a\u3044\u3088\u3046\u306b\u30b3\u30de\u30f3\u30c9\nq = [0]\ncounts[0] = True\nans = K\nwhile q:\n  i = q.pop(0)\n  # get_nexts\n  js = E[i]\n  if i == 0:\n    c = K - 1\n  else:\n    c = K - 2\n  for j in js:\n    if not(counts[j]):\n      counts[j] = True\n      ans = (ans * c) % mod\n      c -= 1\n      q.append(j)\n#print(E)      \nprint(ans)", "import networkx as nx\n\nint1 = lambda x: int(x) - 1\nMOD = 10 ** 9 + 7\n\nN, K = list(map(int, input().split()))\n\nG = nx.Graph()\nG.add_nodes_from(list(range(N)))\nG.add_edges_from([tuple(map(int1, input().split())) for _ in range(N - 1)])\n\ndeg = nx.degree(G)\nans = K\nfor i in range(deg[0]):\n    ans = (ans * (K - i - 1)) % MOD\n\nfor parent, child in nx.dfs_edges(G, 0):\n    for i in range(deg[child] - 1):\n        ans = (ans * (K - i - 2)) % MOD\n\nprint(ans)\n", "import sys\nfrom collections import deque\nMOD = 10 ** 9 + 7\n\nn, k, *ab = map(int, sys.stdin.read().split())\ngraph = [[] for _ in range(n)]\nfor a, b in zip(*[iter(ab)] * 2):\n  a -= 1; b -= 1\n  graph[a].append(b)\n  graph[b].append(a)\n\ndef main():\n  for i in range(n):\n    if len(graph[i]) + 1 > k:\n      print(0)\n      return\n  \n  cnt = [None] * n; cnt[0] = k\n  parent = [None] * n\n  stack = [0]\n  while stack:\n    u = stack.pop()\n    c = k - 2 if not parent[u] is None else k - 1\n    for v in graph[u]:\n      if v == parent[u]: continue \n      parent[v] = u\n      cnt[v] = c\n      c -= 1\n      stack.append(v)\n\n  res = 1\n  for c in cnt:\n    res *= c\n    res %= MOD\n  print(res)\n\ndef __starting_point():\n  main()\n__starting_point()", "\nN,K = map(int, input().split())\nMOD = 10**9 + 7\nes = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a,b = map(int, input().split())\n    es[a-1].append(b-1)\n    es[b-1].append(a-1)\n\n\nMAXN = K+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n \ndef nPr(n,r):\n    if n < r:\n        return 0\n    return fac[n] * finv[n-r]\n\"\"\"\ncurr \u3068\u305d\u306e\u89aaprev\u306e\u8272\u304c\u6c7a\u307e\u3063\u3066\u3044\u308b\u3068\u304d\u306b\u3001curr\u306e\u5b50nxt\u306e\u8272\u306e\u5857\u308a\u65b9\u306e\u5834\u5408\u306e\u6570\u306f\nnPr(K-2, len(es[curr]) - 1)\nK\u306e\u3046\u3061prev\u3068curr\u3067\uff12\u8272\u4f7f\u3063\u3066\u3044\u3066\u3001curr\u306b\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u3082\u306e\u306e\u3046\u3061\u4e00\u3064\u306fprev\u3060\u304b\u3089\u3001\uff11\u5f15\u3044\u305f\u3082\u306e\u304c\u5b50\u4f9b\u306e\u6570\u3002\n\u3067\u3001\u4e00\u756a\u521d\u3081\u306e\u30ce\u30fc\u30c9origin\u306b\u3064\u3044\u3066\u8003\u3048\u308b\u3068\u3001\u89aa\u306f\u306a\u3044\u306e\u3067\u30ce\u30fc\u30c9origin\u81ea\u4f53\u306fK\u500b\u306e\u5857\u308a\u65b9\u304c\u3042\u308a\u3001\u305d\u306e\u5b50\u306b\u306f\u3001nPr(K-1, len(es[origin]))\u306e\u5857\u308a\u65b9\u304c\u3042\u308b\n\u3042\u3068\u306fDFS\u7684\u306b\u5b50\u4f9b\u306e\u5857\u308a\u65b9\u3092\u6c7a\u3081\u3066\u3044\u304f\n\n\"\"\"\n\nchecked = [False] * N\nans = K * nPr(K-1, len(es[0]))\nchecked[0] = True\n\nstack = []\nfor nxt in es[0]:\n    stack.append(nxt)\n\nwhile stack:\n    curr = stack.pop()\n    checked[curr] = True\n    ans *= nPr(K-2, len(es[curr]) - 1)\n    if ans >= MOD: ans %= MOD\n    for nxt in es[curr]:\n        if not checked[nxt]:\n            stack.append(nxt)\n\nprint(ans % MOD)", "from collections import deque\n\n\nclass ModCalc:\n    mod = 10**9 + 7\n\n    def __init__(self, n):\n        self.n = n\n        self.inv = [1] * (self.n + 1)\n        self.fac = [1] * (self.n + 1)\n        self.finv = [1] * (self.n + 1)\n        self.inv[0] = 0\n        self.inv_table()\n\n    def inv_table(self):\n        for i in range(2, self.n+1):\n            self.inv[i] = self.inv[self.mod % i] * (self.mod - self.mod // i) % self.mod\n            self.fac[i] = self.fac[i-1] * i % self.mod\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.mod\n\n    def comb(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n\n        return self.fac[n] * self.finv[r] % self.mod * self.finv[n-r] % self.mod\n\n    def perm(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n\n        return self.fac[n] * self.finv[n-r] % self.mod\n\n    def fact(self, n):\n        return self.fac[n]\n\n\nn, k = map(int, input().split())\ntree = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\nans = k\nmod = 10**9 + 7\nmc = ModCalc(100001)\n\nq = deque([1])\ndist = [-1] * (n+1)\ndist[1] = 0\nwhile q:\n    now = q.popleft()\n    cnt = 0\n    for node in tree[now]:\n        if dist[node] != -1:\n            continue\n        cnt += 1\n        q.append(node)\n        dist[node] = dist[now] + 1\n\n    if dist[now] == 0:\n        ans *= mc.comb(k-1, cnt) * mc.fact(cnt) % mod\n        ans %= mod\n    else:\n        ans *= mc.comb(k-2, cnt) * mc.fact(cnt) % mod\n        ans %= mod\n\nprint(ans)", "import sys \nsys.setrecursionlimit(10**6)\nn, k = map(int, input().split())\nedges = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n    \nmod = 10**9 + 7\ndef P(x,y):\n    # x = k - 2\n    # y = n - 1\n    cnt = 0\n    ans = 1\n    waru = 1\n    while cnt < y:\n        ans *= (x-cnt)\n        ans %= mod\n        cnt += 1\n    return ans%mod\n\n\nans = 1\ndef dfs(v,p):\n    nonlocal ans\n    us = edges[v]\n    for u in us:\n        if u == p: continue\n        if len(edges[u]) == 1: ans *= 1\n        ans *= P(k-2, len(edges[u])-1)   \n        ans %= mod\n        dfs(u,v)\n\ndfs(0,-1)\nn0 = len(edges[0])\na = P(k,n0+1)\n# print(n0,a)\nans *= a\nans %= mod\nprint(ans)", "import sys\nsys.setrecursionlimit(200000)\n\nmod = 10**9 +7\nN,K = map(int,input().split())\nedges = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b = map(int,input().split())\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndef dfs(cur,p,nei):\n    #cur\u306b\u3044\u308b\u72b6\u614b\u3067\u3001\u9078\u3079\u308b\u8272\u304ccandi\u901a\u308a\u3042\u308b\u5834\u5408\u306e\u3001\u5857\u308a\u65b9\u306e\u5834\u5408\u306e\u6570\u3002\n    #p\u304c\u89aa,nei\u304ccur\u306e\u8ddd\u96e22\u4ee5\u4e0b\u306e\u30ce\u30fc\u30c9\u306e\u6570\uff08cur\u306e\u5b50\u3001\u5f1f\u30ce\u30fc\u30c9\u306f\u9664\u304f\uff09\u3002nei\u304c0,1\u306e\u3068\u304d\u5b50\u306b\u6e21\u3059nei\u306fnei+1+\u5144\u306e\u6570\u3001\n    # nei\u304c2\u306e\u3068\u304d\u3001\u5b50\u306b\u6e21\u3059nei\u306f\u30012+\u5144\u306e\u6570\u3002\n    res = K-nei \n    nxnei = min(nei+1,2)\n    for nx in edges[cur]:\n        if nx != p:\n            res = res * dfs(nx,cur,nxnei) % mod\n            nxnei += 1\n    return res\n\nprint(dfs(1,0,0))", "import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef S_MAP(): return list(map(str, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n \nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, K = MAP()\nL = [LIST() for i in range(N-1)]\ncolor = [0] * N\n# color[]\ngraph = defaultdict(list)\nfor a, b in L:\n    graph[a].append(b)\n    graph[b].append(a)\n\nans = 1\n# child, parent, kakerumono\nq = deque([[1, 0, K]])\n# color[0] = K\n# visited = [False] * N\n# visited[0] = True\nwhile q:\n    u, p, k_ = q.popleft()\n    ans = (ans * k_) % mod\n    if p == 0:\n        # parent\u306a\u3057\n        k_next = K - 1\n    else:\n        k_next = K - 2\n\n    for v in graph[u]:\n        if v == p:\n            # \u89aa\u3068\u540c\u3058\u306a\u3089\u98db\u3070\u3059\n            continue\n        q.append([v, u, k_next])\n        # \u5b50\u306e\u6570\u3060\u3051k_next\u3092\u6e1b\u3089\u3057\u306a\u304c\u3089\u66f8\u3051\u3066\u3044\u304f\n        # K-2 P c_k\n        k_next -= 1\nprint(ans)\n\n\n", "n, k = list(map(int, input().split()))\nab = [list(map(int, input().split())) for _ in range(n - 1)]\nmod = 10 ** 9 + 7\n\nadj = [[] for _ in range(n + 1)]\nfor a, b in ab:\n    adj[a].append(b)\n    adj[b].append(a)\n\ns = 1\np = [-1] * (n + 1)\np[0] = 0\np[1] = 0\nc = [[] for _ in range(n + 1)]\norder = []\nstack = [s]\nwhile stack:\n    u = stack.pop()\n    order.append(u)\n    for v in adj[u]:\n        if p[v] == -1:\n            p[v] = u\n            c[u].append(v)\n            stack.append(v)\n\nans = k\nfor u in order:\n    mx = k - 1\n    par = p[u]\n    if par:\n        mx -= 1\n\n    for i in range(len(c[u])):\n        ans *= mx - i\n        ans %= mod\n\nprint(ans)\n", "#!/usr/bin/env python3\n\nfrom functools import lru_cache\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    res = k\n    stack = [0]\n    visited = [False for i in range(n)]\n    while stack:\n        i = stack.pop()\n        visited[i] = True\n        children = [x for x in adj[i] if not visited[x]]\n        res *= perm((k - 1 if i == 0 else k - 2), len(children))\n        res %= MOD\n        for c in children:\n            stack.append(c)\n    print(res)\n\n@lru_cache(maxsize=10 ** 6)\ndef perm(t, s):\n    if s > t:\n        return 0\n    res = 1\n    for i in range(s):\n        res *= t\n        res %= MOD\n        t -= 1\n    return res\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = list(map(int, input().split()))\nmod = 10**9+7\ndata = [[] for j in range(n+1)]\ndone = [0]*(n+1)\ncolors = [k-1]*(n+1)\n\nfor i in range(n-1):\n  a, b = list(map(int, input().split()))\n  data[min(a,b)].append(max(a,b))\n  data[max(a,b)].append(min(a,b))\n\nqueue = [1]\nans = 1\ncolors[1] += 1\nfor d in data[1]:\n  colors[d] += 1\nwhile queue != []:\n  idx = queue.pop(0)\n  done[idx] = 1\n  ans *= colors[idx]\n  ans %= mod\n  cnt = 0\n  for i in range(len(data[idx])):\n    if done[data[idx][i]]:\n      continue\n    cnt += 1\n    colors[data[idx][i]] -= cnt\n    queue.append(data[idx][i])\n\nprint(ans)\n  \n", "# https://atcoder.jp/contests/abc133/tasks/abc133_e\n\n# \u3042\u30fc\u89e3\u8aac\u3042\u305f\u307e\u3044\u3044\n# \u305d\u306e\u30ce\u30fc\u30c9\u3067\u5857\u308c\u308b\u8272\u306e\u5019\u88dc\u3092\u6301\u3064\u306e\u3067\u306f\u306a\u304f\u3066\u3001\n# \u305d\u306e\u30ce\u30fc\u30c9\u306e\u5b50\u3067\u5857\u308c\u308b\u901a\u308a\u306e\u6570\u3092\u6301\u3063\u3066\u304a\u304f\n# \u3042\u308b\u30ce\u30fc\u30c9\u306e\u5b50\u3067\u5857\u308c\u308b\u901a\u308a\u306e\u6570\u306f\u3001\u89aa\u3068\u305d\u306e\u30ce\u30fc\u30c9\u3067\u5857\u308b\u8272\u306e\u901a\u308a\u3082\u78ba\u5b9a\u3057\u3066\u308b\u3068\u8003\u3048\u308b\u3068\u3001(K-2)P(\u5b50\u306e\u6570)\u3068\u306a\u308b\u3002(\u81ea\u8eab\u304c\u6839\u306e\u3068\u304d\u306f\u81ea\u8eab\u306e\u8272\u306e\u901a\u308a\u3082\u8003\u616e\u3057\u3066\u3001(K)P(\u5b50\u306e\u6570+1)\u3068\u306a\u308b)\n# \u3053\u308c\u3092dfs\u3067\u5b9f\u88c5\u3059\u308c\u3070\u826f\u3044\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina(*argv, sub=1): return list([x - sub for x in argv])\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\ndef read_a_int(): return int(read())\n\n\ndef read_ints(): return list(map(int, read().split()))\n\n\nMOD = 10**9 + 7\n\nN, K = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in range(N - 1):\n    a, b = read_ints()\n    a, b = mina(a, b)\n    tree[a].append(b)\n    tree[b].append(a)\n\n\ndef perm_mod(n, r, mod=MOD):\n    if n < r:  # \u305d\u3093\u306a\u901a\u308a\u306f\u3042\u308a\u3048\u306a\u3044\n        return 0\n\n    ret = 1\n    for _ in range(r):\n        ret *= n\n        ret %= mod\n        n -= 1\n    return ret\n\n\ndef dfs(u, p):  # \u73fe\u5728\u306eu\u3068\u89aa\u306ep\n    if len(tree[u]) == 1 and tree[u][0] == p:\n        # \u8449\u306a\u306e\u3067\u7d42\u4e86\n        return 1\n    ret = 1  # \u305d\u306e\u5730\u70b9\u307e\u3067\u306e\u901a\u308a\u306e\u6570\n    for to in tree[u]:\n        if to == p:\n            continue\n        ret *= dfs(to, u)\n        ret %= MOD\n    if p == -1:\n        ret *= perm_mod(K, len(tree[u]) + 1)\n    else:\n        ret *= perm_mod(K - 2, len(tree[u]) - 1)\n\n    return ret % MOD\n\n\nprint((dfs(0, -1)))\n", "import sys\nsys.setrecursionlimit(100000)\n \n\nN,K = list(map(int,input().split()))\n\ntree = [[] for _ in range(N+10)]\n\nfor i in range(N-1):\n    a,b = list(map(int,input().split()))\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\nans = []\ndef wfs(now,back):\n    if now != 0:\n        cnt = K - 2 #\u307e\u305a\u4e00\u500b\u4e0a\u306e\u3092\u5f15\u304f\u3002\n    else:\n        cnt = K - 1\n    for nxt in tree[now]:\n        if nxt != back:\n            ans.append(cnt)\n            cnt = cnt - 1\n            wfs(nxt,now)\n\nans.append(K)\nwfs(0,-1)\n\nans2 = 1\nfor j in range(len(ans)):\n    ans2 = (ans2 * ans[j]) % (10**9+7)\nprint(ans2)", "import sys\nsys.setrecursionlimit(100000)\n\nN,K=list(map(int,input().split()))\nMOD=10**9+7\nbranch=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b=list(map(int,input().split()))\n  branch[a-1].append(b-1)\n  branch[b-1].append(a-1)\n\nif K==1:\n  if N==1:\n    print((1))\n  else:\n    print((0))\n  return\n  \nP=[0]*(K-1)\nP[K-2]=K-2\nfor i in range(K-3,0,-1):\n  P[i]=P[i+1]*i%MOD\n  \ndef PPP(start,num):\n  if start<num:\n    return 0\n  if start==K-2:\n    return P[start-num+1]\n  if start==K-1:\n    return P[start-num+2]*(K-1)%MOD\n  \nans=1\n\ndef draw(parent,nord):\n  nonlocal ans\n  children=len(branch[nord])-(parent !=-1)\n  if children==0:\n    return\n  #(K-2)*(K-1)*... \u3092children\u306e\u6570\u3060\u3051\u639b\u3051\u308b\u3002\n  ans=ans*PPP(K-1-(parent !=-1),children)%MOD\n  for b in branch[nord]:\n    if b != parent:\n      draw(nord,b)\n\nfor i in range(len(branch[0])+1):\n  ans=ans*(K-i)%MOD\nfor bra in branch[0]:\n  draw(0,bra)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nN,K=map(int,input().split())\ntree=[[]for _ in range(N+1)]\nMOD=10**9+7\nans=K\nenuk=[1]*(N)\nfor i in range(N-1):\n    a,b=map(int,input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n    enuk[i+1]=(enuk[i]*(K-2-i))%MOD\ndef dfs(a,b):\n    if a==1:\n        node=len(tree[a])\n        ret=1\n        for i in range(node):\n            ret*=K-1-i\n            ret%=MOD\n    else:\n        node=len(tree[a])-1\n        ret=enuk[node]%MOD\n    for i in tree[a]:\n        if i==b:\n            continue\n        ret=ret*dfs(i,a)%MOD\n    return ret\nans*=dfs(1,0)\nprint(ans%MOD)", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nnb = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, k = ns()\n    e = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = ns()\n        a, b = a - 1, b - 1\n        e[a].append(b)\n        e[b].append(a)\n\n    table = [True for _ in range(n)]\n    perm = [1]\n    for i in range(k - 2, -1, -1):\n        perm.append(perm[-1] * i % MOD)\n\n    table[0] = False\n    que = collections.deque(e[0])\n    ans = k\n    for i in range(len(e[0])):\n        table[e[0][i]] = False\n        ans *= k - i - 1\n        ans %= MOD\n\n    while len(que) > 0:\n        for _ in range(len(que)):\n            q = que.popleft()\n            cnt = 0\n            for i in range(len(e[q])):\n                tmp = e[q][i]\n                if table[tmp]:\n                    table[tmp] = False\n                    cnt += 1\n                    que.appendleft(tmp)\n            ans *= perm[min(len(perm) - 1, cnt)]\n            ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k = map(int,input().split())\nans = k\nmod = 10**9+7\nv = [[0] for i in range(n+1)]\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    v[a].append(b)\n    v[b].append(a)\nif n == 1:\n    print(k)\nelif n == 2:\n    print(k*(k-1))\nelse:\n    q = [1]\n    v[1][0] = 1\n    # print(v)\n    while q:\n        t = q.pop()\n        # print(t,ans,len(v[t]))\n        cnt = 2-(t==1)\n        for i in range(1,len(v[t])):\n            # print(i)\n            if v[v[t][i]][0] == 0:\n                q.append(v[t][i])\n                v[v[t][i]][0] = 1\n                ans = (ans*(k-cnt)) % mod\n                cnt += 1\n                # if cnt == k+1:\n                #     print(t,i,\"Err\")\n    # print(v)\n    print(ans)", "from collections import deque\n\nN,K=map(int,input().split())\nmod = 10**9+7\nG=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)\n\ndef bfs(s):\n    seen = [0]*N\n    prev = [0]*N\n    color = [0]*N\n    todo = deque()\n    seen[s]=1\n    todo.append(s)\n    color[s]=K\n    while todo:\n      a = todo.popleft()\n      if a == start: count = K-1\n      else: count = K-2\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          prev[b] = a\n          color[b] = count %mod\n          count -= 1\n    return color\n  \nMAX,start = 0,-1\nfor i in range(N):\n  if len(G[i])>MAX:\n    MAX=len(G[i])\n    start = i\n    \ncolor = bfs(start)\nans = 1\nfor i in range(N):\n  ans *= color[i]\n  ans %= mod\n  \nprint(ans)", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u53cc\u65b9\u5411\u30b0\u30e9\u30d5\u3067\u5e45\u512a\u5148\u63a2\u7d22\n\nfrom collections import deque\n\nmod = 10**9+7\n\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    graph[a].append(b)\n    graph[b].append(a)\n\n#\u5e45\u512a\u5148\u63a2\u7d22\nq = deque()\nseen = [False]*n\nparent = [-1]*n\nq.append(0)\nseen[0] = True\nparent[0] = 0\nret = k\nwhile len(q)>0:\n    cur = q.popleft()\n    if cur == 0:\n        cnt = k-1\n    else:\n        cnt = k-2\n    for i in graph[cur]:\n        if seen[i]==False:\n            seen[i] = True\n            #\u89aa\n            parent[i] = cur\n            q.append(i)\n            ret *= cnt\n            ret %= mod\n            cnt -= 1\nprint(ret)", "import sys\nsys.setrecursionlimit(10**9)\nmod = 10**9+7\nN,K = map(int,input().split())\ng = [[] for _ in range(N)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\n\nans = K\ndef rec(c,p):\n    nonlocal ans\n    if c == 0:\n        for i in range(len(g[0])):\n            ans *= K-i-1\n            ans %= mod\n        for v in g[c]:\n            if v != p:\n                rec(v,c)\n    else:\n        for i in range(len(g[c])-1):\n            ans *= K-i-2\n            ans %= mod\n        for v in g[c]:\n            if v != p:\n                rec(v,c)\n\n\nrec(0,0)\nprint(ans)", "import sys\nfrom collections import deque\n\nmod = 10**9 + 7\ninput = sys.stdin.readline\nN, K = map(int, input().split())\n\npaths = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    paths[a-1].append(b-1)\n    paths[b-1].append(a-1)\n\nq = deque()\nq.append((0, K, 0))\n\ndp = 1\nvisited = set()\nwhile q:\n    node, count, d = q.popleft()\n    if node in visited:\n        continue\n    dp *= count\n    dp %= mod\n    visited.add(node)\n\n    res = K\n    if d == 0:\n        res -= 1\n    else:\n        res -= 2\n    for n_node in paths[node]:\n        if n_node not in visited:\n            # print(n_node, res)\n            q.append((n_node, res, d+1))\n            res -= 1\n\nprint(dp)", "import sys\nsys.setrecursionlimit(1000000000)\n\nmod = 10 ** 9 + 7\ndef dfs(v, p, k):\n    ret = 1\n    if len(graph[v]) > k:\n        return 0\n    kc = k - 2\n    if p == -1:\n        kc = k - 1\n    for vi in graph[v]:\n        if vi != p:\n            ret *= kc\n            ret = ret % mod\n            kc -= 1\n    for vi in graph[v]:\n        if vi != p:\n            ret *= dfs(vi, v, k)\n            ret = ret % mod\n    return ret\n\nn, k = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    \nprint(((dfs(0, -1, k) * k) % mod))\n", "import sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nsys.setrecursionlimit(100005)\n\nn, k = na()\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = na()\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\nmod = 10**9 + 7\n\n\ndef dfs(cur, par, k, g):\n    ret = 1\n    nc = 0 if par == -1 else 1\n    for e in g[cur]:\n        if e == par: continue\n        nc += 1\n        ret = ret * (k - nc) % mod\n        ret = ret * dfs(e, cur, k, g) % mod\n    return ret % mod\n\n\nprint((dfs(0, -1, k, g) * k % mod))\n", "# https://atcoder.jp/contests/abc133/tasks/abc133_e\n\n# \u3042\u30fc\u89e3\u8aac\u3042\u305f\u307e\u3044\u3044\n# \u305d\u306e\u30ce\u30fc\u30c9\u3067\u5857\u308c\u308b\u8272\u306e\u5019\u88dc\u3092\u6301\u3064\u306e\u3067\u306f\u306a\u304f\u3066\u3001\n# \u305d\u306e\u30ce\u30fc\u30c9\u306e\u5b50\u3067\u5857\u308c\u308b\u901a\u308a\u306e\u6570\u3092\u6301\u3063\u3066\u304a\u304f\n# \u3042\u308b\u30ce\u30fc\u30c9\u306e\u5b50\u3067\u5857\u308c\u308b\u901a\u308a\u306e\u6570\u306f\u3001\u89aa\u3068\u305d\u306e\u30ce\u30fc\u30c9\u3067\u5857\u308b\u8272\u306e\u901a\u308a\u3082\u78ba\u5b9a\u3057\u3066\u308b\u3068\u8003\u3048\u308b\u3068\u3001(K-2)P(\u5b50\u306e\u6570)\u3068\u306a\u308b\u3002(\u81ea\u8eab\u304c\u6839\u306e\u3068\u304d\u306f\u81ea\u8eab\u306e\u8272\u306e\u901a\u308a\u3082\u8003\u616e\u3057\u3066\u3001(K)P(\u5b50\u306e\u6570+1)\u3068\u306a\u308b)\n# \u3053\u308c\u3092dfs\u3067\u5b9f\u88c5\u3059\u308c\u3070\u826f\u3044\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef mina(*argv, sub=1): return list([x - sub for x in argv])\n# \u53d7\u3051\u6e21\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u8981\u7d20\u304b\u3089sub\u3060\u3051\u5f15\u304f.\u30ea\u30b9\u30c8\u3092*\u3092\u3064\u3051\u3066\u5c55\u958b\u3057\u3066\u304a\u304f\u3053\u3068\n\n\ndef read_a_int(): return int(read())\n\n\ndef read_ints(): return list(map(int, read().split()))\n\n\nMOD = 10**9 + 7\n\nN, K = read_ints()\ntree = defaultdict(lambda: [])\nfor _ in range(N - 1):\n    a, b = read_ints()\n    a, b = mina(a, b)\n    tree[a].append(b)\n    tree[b].append(a)\n\n\ndef perm_mod(n, r, mod=MOD):\n    # assert n >= r\n    ret = 1\n    for _ in range(r):\n        ret *= n\n        ret %= mod\n        n -= 1\n    return ret\n\n\ndef dfs(u, p):  # \u73fe\u5728\u306eu\u3068\u89aa\u306ep\n    if len(tree[u]) == 1 and tree[u][0] == p:\n        # \u8449\u306a\u306e\u3067\u7d42\u4e86\n        return 1\n    ret = 1  # \u305d\u306e\u5730\u70b9\u307e\u3067\u306e\u901a\u308a\u306e\u6570\n    for to in tree[u]:\n        if to == p:\n            continue\n        ret *= dfs(to, u)\n        ret %= MOD\n    if p == -1:\n        ret *= perm_mod(K, len(tree[u]) + 1)\n    else:\n        ret *= perm_mod(K - 2, len(tree[u]) - 1)\n\n    return ret % MOD\n\n\nprint((dfs(0, -1)))\n", "from collections import deque\n\ndef permutation(n, k):\n    s = 1\n    for _ in range(k):\n        s *= n\n        s %= mod\n        n -= 1\n    return s\n\ndef bfs():\n    nonlocal ans\n    q = deque()\n    q.append([1, 0])\n    visit[1] = 1\n    while q:\n        x, y = q.popleft()\n        a = 0\n        for i in T[x]:\n            if visit[i] == 0:\n                q.append([i, 1])\n                visit[i] = 1\n                a += 1\n        b = k - y - 1\n        if b - a < 0:\n            print(0)\n            return\n        ans *= permutation(b, a)\n        ans %= mod\n    return \n\nn, k = map(int, input().split())\nT = [[] for _ in range(n + 1)]\nvisit = [0] * (n + 1)\nmod = pow(10, 9) + 7\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    T[a].append(b)\n    T[b].append(a)\nans = k\nbfs()\nprint(ans)", "def main():\n  MOD =  10**9 + 7\n  N, K = list(map(int, input().split()))\n  ki = [[] for _ in range(N)]\n  for i in range(N-1):\n    a, b = list(map(int, input().split()))\n    ki[a-1].append(b-1)\n    ki[b-1].append(a-1)\n  d = [-1] * N\n  que = []\n  ans = K\n  d[0] = 1\n  for i, nex in enumerate(ki[0]):\n    d[nex] = 1\n    ans *= (K-i-1)\n    ans %= MOD\n    que.append(nex)\n  while len(que) > 0:\n    now = que.pop(0)\n    count = 2\n    for nex in ki[now]:\n      if d[nex] != -1:\n        continue\n      d[nex] = 1\n      ans *= (K-count)\n      count += 1\n      ans %= MOD\n      que.append(nex)\n  print(ans)\n  \ndef __starting_point():\n  main()\n\n__starting_point()", "N, K = list(map(int,input().split()))\nAB = [list(map(int,input().split())) for _ in range (N-1)]\n\nimport sys\nsys.setrecursionlimit(10**9)\nedge = [[] for _ in range(N)]\nfor u,v in AB:\n    edge[u-1].append(v-1)\n    edge[v-1].append(u-1)\n\nMOD = 10**9+7\nmod = 10 ** 9 + 7\nMAX = K+10\nfac = [0] * MAX\nfinv = [0] * MAX\ninv = [0] * MAX\ndef cominit():\n    fac[0] = 1\n    fac[1] = 1\n    finv[0] = 1\n    finv[1] = 1\n    inv[1] = 1\n    for i in range(2,MAX):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = mod - inv[mod%i] * (mod//i) % mod\n        finv[i] = finv[i-1] * inv[i] % mod\ndef cmb(n,r):\n    if n < 0 or r < 0 or r > n:return 0\n    if r > n/2: r = n-r        \n    return fac[n] * (finv[r] * finv[n-r] % mod) % mod\n\ndef permu(n,r):\n    if n<=0 or r<=0 or r>n: return 0\n    return (fac[n]*finv[n-r])%MOD\ncominit()\n\n\n\nvisited = [False]*N\nvisited[0] = True\ndef dfs(s,ans):\n    M = len(edge[s])-1*(s!=0)\n    if M==0:\n        return ans\n    if s==0:\n        ans *= permu(K-1, M)\n        ans %= MOD\n    else:\n        ans *= permu(K-2, M)\n        ans %= MOD\n\n    for nv in edge[s]:\n        if visited[nv]:continue\n        visited[nv] = True\n        ans = dfs(nv, ans)\n    \n    return ans\n\nprint((dfs(0,K)%MOD))\n\n\n\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nMOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\nadjL = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    adjL[a].append(b)\n    adjL[b].append(a)\n\nnums = [1] * N\ndef dfs(vNow, vPar):\n    numCh = 0\n    for v2 in adjL[vNow]:\n        if v2 == vPar: continue\n        dfs(v2, vNow)\n        numCh += 1\n    num = 1\n    if vPar == -1:\n        for i in range(K-numCh, K):\n            num *= i\n            num %= MOD\n    else:\n        for i in range(K-numCh-1, K-1):\n            num *= i\n            num %= MOD\n    nums[vNow] = num\n\ndfs(0, -1)\n\nans = K\nfor num in nums:\n    ans *= num\n    ans %= MOD\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\n\nMOD=10**9+7\n\nN,K=list(map(int,input().split()))\ng=[[] for _ in range(N)]\nfor i in range(N-1):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    g[a].append(b)\n    g[b].append(a)\n\nMAX=10**6\nfc=[1]*MAX\ninv=[1]*MAX\nifc=[1]*MAX\n\nfor i in range(2,MAX):\n    fc[i]=i*fc[i-1]%MOD\n    inv[i]=MOD-(MOD//i)*inv[MOD%i]%MOD\n    ifc[i]=inv[i]*ifc[i-1]%MOD\n\ndef comb(n,k):\n    if n<0 or k<0 or n-k<0:\n        return 0\n    return fc[n]*ifc[n-k]%MOD*ifc[k]%MOD\n\ndef dfs(cur,par):\n    ret=1\n    ch=len(g[cur])\n    if par!=-1:\n        ch-=1\n    \n    if par==-1:\n        ret=comb(K-1,ch)*fc[ch]%MOD\n    else:\n        ret=comb(K-2,ch)*fc[ch]%MOD\n        \n        \n    for dst in g[cur]:\n        if dst==par:\n            continue\n        ret=ret*dfs(dst,cur)%MOD\n    return ret\n\nans=K*dfs(0,-1)%MOD\nprint(ans)\n", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nmod = 10**9 + 7\nINF = float(\"inf\")\n\nN, K = list(map(int, input().split()))\n\nedges = [[] * N for _ in range(N)]\nfor _ in range(N - 1):\n    # \u9802\u70b9\u306e\u756a\u53f7\u30920-index\u306b\u76f4\u3059\n    a, b = [int(x) - 1 for x in input().split()]\n    edges[a].append(b)\n    edges[b].append(a)\n\n# 0\u3092root\u3068\u3059\u308b\ndq = deque([0])\n\n# color[i] = i\u756a\u76ee\u306e\u9802\u70b9\u3092\u5857\u308b\u3053\u3068\u304c\u53ef\u80fd\u306a\u8272\u306e\u6570\n# visited\u306e\u7ba1\u7406\u3082\u517c\u306d\u3066\u3044\u308b\uff08\u5225\u306bvisited\u914d\u5217\u3092\u4f5c\u3063\u3066\u3082\u7279\u306b\u554f\u984c\u306f\u306a\u3044\uff09\n# \u5f8c\u8ff0\u3059\u308b\u3088\u3046\u306b\u8ca0\u306e\u5024\u304c\u5165\u308b\u3053\u3068\u3092\u8a31\u3057\u3066\u3044\u308b\u306e\u3067\u3001-1\u30840\u306a\u3069\u3067\u521d\u671f\u5316\u3059\u308b\u306e\u306fNG\ncolor = [INF] * N\ncolor[0] = K\n\n\"\"\"\nroot = 0 \u304b\u3089\u672b\u7aef\u306b\u5411\u304b\u3063\u3066\u8abf\u3079\u308b\n\n\u5b501, \u5b502, \u5b503, ...\u3068\u8907\u6570\u306e\u300c\u672a\u7740\u8272\u300d\u306e\u5b50\u304c\u3042\u308b\u5834\u5408\u3001\u5857\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\u8272\u306e\u6570\u306f\nK-1, K-2, K-3,... (p==0 \u306e\u5834\u5408)\nK-2, K-3, K-4,... (p!=0 \u306e\u5834\u5408)\u3000\u306e\u3088\u3046\u306b\u306a\u308b\n\n\u5b50\u304c\u5341\u5206\u591a\u3044\u5834\u5408\u3001\u3069\u3053\u304b\u3067\u300c0\u300d\u306b\u306a\u308b\u306e\u3067\u3001ans = 0\u3000\u3068\u306a\u308b\n\u6545\u306b\u3001\u8272\u306e\u6570\u304c\u8ca0\u306b\u306a\u3063\u3066\u3082\u7b54\u3048\u306b\u306f\u5f71\u97ff\u3057\u306a\u3044\n\"\"\"\n\nwhile dq:\n    # \u89aa\u3068\u306a\u308b\u9802\u70b9\n    p = dq.popleft()\n    # \u89aa\u3092p\u3068\u3057\u305f\u6642\u306e\u3001\u300c\u672a\u7740\u8272\u300d\u306a\u5b50\u306e\u6570\n    cnt = 0\n    for c in edges[p]:\n        if color[c] == INF:\n            if p == 0:\n                color[c] = (K - 1 - cnt) % mod\n            else:\n                color[c] = (K - 2 - cnt) % mod\n            cnt += 1\n            dq.append(c)\n\nans = 1\nfor i in range(N):\n    ans = (ans * color[i]) % mod\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(100000)\n\nN,K=map(int,input().split())\nSIZE=10**5+1; MOD=10**9+7 #998244353 #\u3053\u3053\u3092\u5909\u66f4\u3059\u308b\n \nSIZE += 1\ninv = [0]*SIZE  # inv[j] = j^{-1} mod MOD\nfac = [0]*SIZE  # fac[j] = j! mod MOD\nfinv = [0]*SIZE # finv[j] = (j!)^{-1} mod MOD\ninv[1] = 1\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,SIZE):\n  inv[i] = MOD - (MOD//i)*inv[MOD%i]%MOD\n  fac[i] = fac[i-1]*i%MOD\n  finv[i]= finv[i-1]*inv[i]%MOD\n\ndef narabekae(n,r): #nPr mod MOD \u306e\u8a08\u7b97\n  if n-r<0:\n    return 0\n  return fac[n]*finv[n-r]%MOD\n\nbranch=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  branch[a-1].append(b-1)\n  branch[b-1].append(a-1)\n\nans=1\n\ndef draw(parent,nord):\n  nonlocal ans\n  children=len(branch[nord])-(parent !=-1)\n  if children==0:\n    return\n  #(K-2)*(K-1)*... \u3092children\u306e\u6570\u3060\u3051\u639b\u3051\u308b\u3002\n  ans=ans*narabekae(K-1-(parent !=-1),children)%MOD\n  for b in branch[nord]:\n    if b != parent:\n      draw(nord,b)\n\ndraw(-1,0)\nprint(ans*K%MOD)", "\nimport sys\nfrom collections import defaultdict\n\n# ----------\n\nsys.setrecursionlimit(10 ** 7)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef combination(n, k):\n    if k > n - k:\n        return combination(n, n - k)\n    return fact[n] * ifact[k] * ifact[n - k]\n\n\ndef permitation(n, k):\n    # nPk = nCk * k!\n    res = combination(n, k) * fact[k]\n    return res % MOD\n\n\nN, K = list(map(int, input().split()))\nto = defaultdict(list)\nfor i in range(N - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    to[a].append(b)\n    to[b].append(a)\n\n# n\u307e\u3067\u306e\u968e\u4e57\u3092\u524d\u51e6\u7406\nn = 200005\nfact = defaultdict(int)\nfact[0] = 1\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i\n    fact[i] %= MOD\n# n\u307e\u3067\u306e\u968e\u4e57\u306e\u9006\u5143\u3092\u524d\u51e6\u7406\nifact = defaultdict(int)\nifact[n] = pow(fact[n], MOD - 2, MOD)\nfor i in reversed(list(range(1, n + 1))):\n    ifact[i - 1] = ifact[i] * i\n    ifact[i - 1] %= MOD\n\n\ndef dfs(v, p=-1):\n    nonlocal ans\n    for u in to[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n    if p == -1:\n        nk = K\n        c = len(to[v]) + 1\n    else:\n        nk = K - 2\n        c = len(to[v]) - 1\n    ans *= permitation(nk, c)\n    ans %= MOD\n\n\nans = 1\ndfs(0)\nprint(ans)\n", "import math \nimport sys \n\"\"\"\ndef p(n,r):\n    if n<r:\n        return 1\n    return math.factorial(n)//math.factorial(n-r)\n\"\"\"\ndef main():\n    input=sys.stdin.readline \n    N,K=list(map(int,input().split()))\n    E=[[] for _ in range(N)]\n    MOD = 10**9+7\n    for _ in range(N-1):\n        u,v=list(map(int,input().split()))\n        u-=1\n        v-=1\n        E[u].append(v)\n        E[v].append(u)\n\n    if N==1:\n        print(K)\n        return\n\n    color = [-1 for _ in range(N)]\n    dp = [-1 for _ in range(N)]\n    stack = []\n    color[u]=1\n    ans=K\n    for i,v in enumerate(E[u]):\n        stack.append(v)\n        ans*=(K-i-1)\n        ans%=MOD\n\n\n    while stack:\n        u=stack.pop()\n        color[u]=1\n        length=0\n        for v in E[u]:\n            if color[v]==-1:\n                stack.append(v)\n                length+=1\n        if dp[length]==-1:\n            tmp=1\n            for i in range(K-1-length,K-1):\n                tmp*= i \n                tmp%=MOD \n            ans*=tmp \n        else:\n            ans*=dp[length]\n        ans%=MOD\n\n    print((ans%MOD))\n\ndef __starting_point():\n    main()\n    \n\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u53cc\u65b9\u5411\u30b0\u30e9\u30d5\u3067\u5e45\u512a\u5148\u63a2\u7d22\nfrom collections import deque\nmod = 10**9+7\nN = 10**6                   # \u51fa\u529b\u306e\u5236\u9650\ng1 = [1]*(N+1)              # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1]*(N+1)              # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\nfor i in range(2, N + 1 ): # \u6e96\u5099\n    g1[i] = ( g1[i-1] * i ) % mod\ng2[N] = pow(g1[-1], mod-2, mod)\nfor i in range(N, 0, -1):\n    g2[i-1] = ( g2[i] * i ) % mod\n\ndef nCr(n, r):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\ndef nPr(n, r):\n    if ( r<0 or r>n ):\n        return 0\n    return g1[n] * g2[n-r] % mod\n\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    graph[a].append(b)\n    graph[b].append(a)\n\n#\u5e45\u512a\u5148\u63a2\u7d22\nq = deque()\nseen = [False]*n\nparent = [-1]*n\nq.append(0)\nseen[0] = True\nparent[0] = 0\nret = k\nwhile len(q)>0:\n    cur = q.popleft()\n    if cur == 0:\n        cnt = k-1\n    else:\n        cnt = k-2\n    for i in graph[cur]:\n        if seen[i]==False:\n            seen[i] = True\n            #\u89aa\n            parent[i] = cur\n            q.append(i)\n            ret *= cnt\n            ret %= mod\n            cnt -= 1\nprint(ret)", "from sys import stdin\nfrom collections import deque\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    mod=10**9+7\n    n,k=map(int,readline().split())\n    G=[[] for _ in range(n)]\n    for i in range(n-1):\n        a,b=map(lambda x:int(x)-1,readline().split())\n        G[a].append(b)\n        G[b].append(a)\n\n    ans=k\n    stack=deque([0])\n    flags=[False]*n\n    flags[0]=True\n    #dfs\n    while len(stack)>0:\n        now=stack.pop()\n        if now==0:\n            ans*=P(k-1,len(G[0]),mod)\n            ans%=mod\n        else:\n            ans*=P(k-2,len(G[now])-1,mod)\n            ans%=mod\n        for nex in G[now]:\n            if flags[nex]==False:\n                flags[nex]=True\n                stack.append(nex)\n\n    print(ans)\n\ndef P(n,k,mod):\n    res=1\n    for m in range(n,n-k,-1):\n        res*=m\n        res%=mod\n    return res\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\nMOD = 10 ** 9 + 7\n\nn, k, *ab = map(int, sys.stdin.read().split())\ngraph = [[] for _ in range(n)]\nfor a, b in zip(*[iter(ab)] * 2):\n  a -= 1; b -= 1\n  graph[a].append(b)\n  graph[b].append(a)\n\ndef main():\n  for i in range(n):\n    if len(graph[i]) + 1 > k:\n      print(0)\n      return\n  \n  cnt = [None] * n; cnt[0] = k\n  parent = [None] * n\n  stack = [0]\n  while stack:\n    u = stack.pop()\n    c = k - 2 if not parent[u] is None else k - 1\n    for v in graph[u]:\n      if v == parent[u]: continue \n      parent[v] = u\n      cnt[v] = c\n      c -= 1\n      stack.append(v)\n\n  res = 1\n  for c in cnt:\n    res *= c\n    res %= MOD\n  print(res)\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nn, k = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = list([int(x)-1 for x in input().split()])\n    edges[a].append(b)\n    edges[b].append(a)\nMOD = 10**9+7\nINF = 10**10\ndp = [INF]*n\n\n\ndef dfs(v, parent, x):\n    dp[v] = x\n    if parent == -1:\n        next_x = k-1\n    else:\n        next_x = k-2\n    for v2 in edges[v]:\n        if v2 == parent:\n            continue\n        dfs(v2, v, next_x)\n        next_x -= 1\n\n\ndfs(0, -1, k)\nans = 1\nfor x in dp:\n    ans = ans*x % MOD\nprint(ans)\n", "from collections import deque\n\nint1 = lambda x: int(x) - 1\nMOD = 10 ** 9 + 7\n\nN, K = list(map(int, input().split()))\nT = [[] for _ in range(N)]\n\nfor i in range(N - 1):\n    a, b = list(map(int1, input().split()))\n    T[a].append(b)\n    T[b].append(a)\n\n# dfs\nans = K\nfor i in range(len(T[0])):\n    ans = (ans * (K - i - 1)) % MOD\nD = deque(T[0])\nvisited = {0}\n\nwhile D:\n    v = D.pop()\n    visited.add(v)\n    for i in range(len(T[v]) - 1):\n        ans = (ans * (K - i - 2)) % MOD\n    for x in T[v]:\n        if x not in visited:\n            D.append(x)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(410000)\n\nmod = 10**9+7\n\ndef dfs(v,pr,k):\n  if len(G[v]) > k:\n    return 0\n  \n  kc = k-2\n  if pr == -1:\n    kc = k-1  \n  \n  ret = 1\n  \n  for vi in G[v]:\n    if vi == pr:\n      continue\n    ret *= kc\n    ret %= mod\n    kc -= 1\n    \n  for vi in G[v]:\n    if vi == pr:\n      continue\n    ret *= dfs(vi,v,k)\n    ret %= mod\n  \n  return ret\n\n\nn,k = map(int,input().split())\nG = [[] for i in range(n)]\nfor i in range(n-1):\n  a,b = map(int,input().split())\n  G[a-1].append(b-1)\n  G[b-1].append(a-1)      \n  \nprint(dfs(0,-1,k) * k % mod )", "# coding: utf-8\n# Your code here!\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ndef dfs(num):\n    temp=K-len(way[num])\n    \n    for w in way[num]:\n        if visited[w]==-1:\n            visited[w]=temp\n            temp+=1\n            dfs(w)\n    \n    return \n\nN,K=list(map(int,input().split()))\n\nmod=10**9+7\n\nvisited=[-1]*N\nway=[[] for i in range(N)]\n\nfor _ in range(N-1):\n    a,b=list(map(int,input().split()))\n    way[a-1].append(b-1)\n    way[b-1].append(a-1)\n    \ncolor=[]\nvisited[0]=K\ndfs(0)\n\n#print(way)\n#print(visited)\nans=1\nfor item in visited:\n    ans*=item\n    ans%=mod\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\n\nMOD = 10**9+7\n\nN,K = map(int,input().split())\nedge = [[] for _ in range(N)]\n\nfor _ in range(N-1):\n    a,b = map(int,input().split())\n    a,b = a-1,b-1\n    edge[a].append(b)\n    edge[b].append(a)\n\n    \nvisit = [0]*N\n\ndef dfs(vs, pat, count):\n    \n    for ve in edge[vs]:\n        if visit[ve]:continue\n        \n        visit[ve] = 1\n        pat = pat*(K-count) % MOD\n        count += 1\n        pat = dfs(ve, pat, 2)\n    \n    return pat\n\nvisit[0] = 1\n\nans = dfs(0,K,1)\nprint(ans)", "from collections import defaultdict\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, K = list(map(int, input().split()))\nab = defaultdict(list)\nfor i in range(N-1):\n    a, b = list(map(int, input().split()))\n    ab[a-1].append(b-1)\n    ab[b-1].append(a-1)\n\nMOD = 10**9+7\n\n\ndef dfs(v, pv, n):\n    k = K-1 if pv == -1 else K-2\n    a = 1\n    for u in ab[v]:\n        if u != pv:\n            a *= dfs(u, v, k)\n            a %= MOD\n            k -= 1\n    return a*n % MOD\n\n\nprint((dfs(0, -1, K)))\n", "import sys\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, K, *AB = list(map(int, read().split()))\n    G = [[] for _ in range(N)]\n    for a, b in zip(AB[::2], AB[1::2]):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    COM_MAX = K\n\n    fac, finv, inv = [0] * (COM_MAX + 1), [0] * (COM_MAX + 1), [0] * (COM_MAX + 1)\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2, COM_MAX + 1):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    def mod_perm(n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n        return fac[n] * (finv[n - r] % MOD) % MOD\n\n    stack = deque([0])\n    order = []\n    parent = [-1] * N\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        for nv in G[v]:\n            if nv != parent[v]:\n                stack.append(nv)\n                parent[nv] = v\n\n    A = [0] * N\n    for v in reversed(order):\n        tmp = 1\n        child = 0\n        for nv in G[v]:\n            if nv != parent[v]:\n                tmp = tmp * A[nv] % MOD\n                child += 1\n\n        colors = K if v == 0 else K - 2\n        nodes = child + 1 if v == 0 else child\n\n        A[v] = tmp * mod_perm(colors, nodes) % MOD\n\n    print((A[0]))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(500000)\n\nN, K = map(int,input().split())\n\nT = [[] for i in range(N)]\nfor i in range(N-1):\n    a, b = map(int,input().split())\n    T[a-1].append(b-1)\n    T[b-1].append(a-1)\n\nans = 1\ndef dfs(i, bb, b, p):\n    nonlocal ans\n    ans = (ans*(K-bb-b))%(10**9+7)\n    cnt = 0\n    for j in T[i]:\n        if j == p:\n            continue\n        dfs(j, b + cnt, 1, i)\n        cnt += 1\n\ndfs(0, 0, 0, -1)\nprint(ans)", "from sys import setrecursionlimit\nsetrecursionlimit(10**6)\nn,k=map(int,input().split())\npaths=[[] for i in range(n)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    paths[a-1].append(b-1)\n    paths[b-1].append(a-1)\ninf=100000000000000\nnums=[-inf]*n\nnums[0]=k\nfrom collections import deque\nnow=deque()\nnow.append(0)\ndef bfs(d):\n    nonlocal n,k,paths,nums,now\n    l=len(now)\n    if d==1:\n        for i in range(l):\n            p=now.popleft()\n            ln=len(paths[p])\n            next_num=k-1\n            for j in range(ln):\n                if nums[paths[p][j]]==-inf:\n                    nums[paths[p][j]]=next_num\n                    now.append(paths[p][j])\n                    next_num-=1\n    else:\n        for i in range(l):\n            p=now.popleft()\n            ln=len(paths[p])\n            next_num=k-2\n            for j in range(ln):\n                if nums[paths[p][j]]==-inf:\n                    nums[paths[p][j]]=next_num\n                    now.append(paths[p][j])\n                    next_num-=1\n    if len(now):bfs(d+1)\nbfs(1)\nans=1\nfor i in range(n):\n    if nums[i]<=0:\n        print(0)\n        return\n    ans*=nums[i]\n    ans%=(10**9+7)\nprint(ans)", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, K = lr()\ngraph = [[] for _ in range(N+1)]  # 1-indexed\nfor _ in range(N-1):\n    a, b = lr()\n    graph[a].append(b)\n    graph[b].append(a)\n\nMOD = 10 ** 9 + 7\n\ndef perm(n,k):\n    if k > n or k < 0: return 0\n    return fact[n] * fact_inv[n-k] % MOD\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\nU = 10 ** 6  # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u306e\u4e0a\u9650\nfact, fact_inv = make_fact(U, MOD)\n#print(answer % MOD)\n# np.int64\u3068int\u578b\u306e\u9055\u3044\u306b\u6ce8\u610f\nanswer = 1\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nanswer = K * perm(K-1, len(graph[root])) % MOD\nwhile stack:\n    cur = stack.pop()\n    order.append(cur)\n    if cur != 1:\n        answer *= perm(K-2, len(graph[cur])-1)\n        answer %= MOD\n    for next in graph[cur]:\n        if next == parent[cur]:\n            continue\n        parent[next] = cur\n        stack.append(next)\n\nprint((answer%MOD))\n", "from collections import deque\nn, k = map(int, input().split())\ninf = pow(10, 9)+7\n\ntree = [[] for _ in range(n)]\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  tree[a-1].append(b-1)\n  tree[b-1].append(a-1)\n\nnot_yet = deque(tree[0])\nalready = [False]*n\nalready[0] = True\nans = k\nkey = k-1\nfor v in tree[0]:\n  already[v] = True\n  ans *= key\n  ans %= inf\n  key -= 1\n\nwhile not_yet:\n  key = not_yet.popleft()\n  for v in range(k-2, k-1-len(tree[key]), -1):\n    ans *= v\n    ans %= inf\n  \n  for value in tree[key]:\n    if already[value]:\n      continue\n    not_yet.append(value)\n    already[value] = True\n\nprint(ans)", "import sys\ndef input():return sys.stdin.readline().strip()\n\nfrom collections import deque\n\n\ndef main():\n    N, K = map(int, input().split())\n    to = [[] for _ in range(N)]\n    MOD = 10**9 + 7\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        to[a].append(b)\n        to[b].append(a)\n\n    MAX_N = 3 * 10 ** 5\n    MOD = 10 ** 9 + 7\n    fac = [0]*MAX_N\n    inv = [0]*MAX_N\n    finv = [0]*MAX_N\n    fac[0] = 1; fac[1] = 1\n    inv[1] = 1\n    finv[0] = 1; finv[1] = 1\n\n    def com_init():\n        for i in range(2, MAX_N):\n            fac[i] = fac[i-1] * i % MOD\n            inv[i] = -(MOD//i)*inv[MOD%i]%MOD\n            finv[i] = finv[i-1]*inv[i]%MOD\n\n    def perm(n, r):\n        if n < 0:return 0\n        elif r > n: return 0\n        \n        return fac[n]*finv[n-r]%MOD\n    \n    # dfs\n    com_init()\n    def dfs(s):\n        stack = deque()\n        stack.append((s, -1)) # now, par\n        res = K\n        while stack:\n            now, par = stack.pop()\n\n            if now == 0:\n                children = len(to[now])\n            else:\n                children = len(to[now]) - 1\n\n            if now == 0:\n                nx_col = K - 1\n            else:\n                nx_col = K - 2\n            \n            res *= perm(nx_col, children)\n            res %= MOD\n\n            if children == 0 and now != 0:\n                continue\n            \n            for nv in to[now]:\n                if nv != par:\n                    stack.append((nv, now))\n        return res\n    ans = dfs(0)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import networkx as nx\n\nint1 = lambda x: int(x) - 1\nMOD = 10 ** 9 + 7\n\nN, K = list(map(int, input().split()))\n\nG = nx.Graph()\nG.add_nodes_from(list(range(N)))\nG.add_edges_from([tuple(map(int1, input().split())) for _ in range(N - 1)])\n\nans = K\nfor i in range(nx.degree(G)[0]):\n    ans = (ans * (K - i - 1)) % MOD\n\nfor parent, child in nx.dfs_edges(G, 0):\n    for i in range(nx.degree(G)[child] - 1):\n        ans = (ans * (K - i - 2)) % MOD\n\nprint(ans)\n", "import sys\n\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N, K = list(map(int, input().split(' ')))\n    adj = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = list(map(lambda x: int(x) - 1, input().split(' ')))\n        adj[a].append(b)\n        adj[b].append(a)\n    if K <= 2:\n        if N <= K:\n            p = 1\n            for n in range(N):\n                p *= K - n\n            print(p % MOD)\n        else:\n            print(0)\n        return\n    p = 1\n    perm_k1 = [0 for _ in range(K)]\n    for k in range(K):\n        perm_k1[k] = p\n        p *= K - 1 - k\n        p %= MOD\n    perm_k2 = [0 for _ in range(K - 1)]\n    p = 1\n    for k in range(K - 1):\n        perm_k2[k] = p\n        p *= K - 2 - k\n        p %= MOD\n\n    def dfs(n=0, p=-1):\n        # node, parent\u306e\u8272\u3092\u56fa\u5b9a\u3057\u305f\u6642\u306e\u8272\u306e\u5857\u308a\u65b9\n        children = [c for c in adj[n] if c != p]\n        if len(children) == 0:\n            return 1\n        n_colors = K - 2 if n != 0 else K - 1\n        if n_colors < len(children):\n            return 0\n        ret = perm_k2[len(children)] if n != 0 else perm_k1[len(children)]\n        for c in children:\n            ret *= dfs(c, n)\n            ret %= MOD\n        return ret\n\n    print((K * dfs()) % MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(410000)\n\nmod = 10 ** 9 + 7\ndef dfs(v, p, k):\n    ret = 1\n    if len(graph[v]) > k:\n        return 0\n    kc = k - 2\n    if p == -1:\n        kc = k - 1\n    for vi in graph[v]:\n        if vi != p:\n            ret *= kc\n            ret = ret % mod\n            kc -= 1\n    for vi in graph[v]:\n        if vi != p:\n            ret *= dfs(vi, v, k)\n            ret = ret % mod\n    return ret\n\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    \nprint((dfs(0, -1, k) * k) % mod)", "import sys\nsys.setrecursionlimit(10**9)\nclass Combination:\n  def __init__(self, n_max, mod=10**9+7):\n    self.mod = mod\n    self.modinv = self.make_modinv_list(n_max)\n    self.fac, self.facinv = self.make_factorial_list(n_max)\n\n  def __call__(self, n, r):\n    return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n  def make_factorial_list(self, n):\n    # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n    # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n    fac = [1]\n    facinv = [1]\n    for i in range(1, n+1):\n      fac.append(fac[i-1] * i % self.mod)\n      facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n    return fac, facinv\n\n  def make_modinv_list(self, n):\n    # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n    modinv = [0] * (n+1)\n    modinv[1] = 1\n    for i in range(2, n+1):\n        modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n    return modinv\n\nN,K = map(int,input().split())\nadj = [ [ ]for _ in range(N) ]\ncomb = Combination(10**5)\n\ndef nPr(n,r):\n  if n < r: return 0\n  return comb(n, r) * comb.fac[r]\n\nfor _ in range(N-1):\n  a,b = map(int,input().split())\n  a -= 1\n  b -= 1\n  adj[a].append(b)\n  adj[b].append(a)\n\ndef dfs(v, p=-1):\n  nonlocal ans\n  c = 0\n  for nei in adj[v]:\n    if nei == p: continue\n    c += 1\n    dfs(nei, v)\n\n  nk = K-1 if p==-1 else K-2\n  ans *= nPr(nk, c)\n  ans %= 10**9+7\n\nans = K\ndfs(0)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\n\ndef read():\n    N, K = list(map(int, input().strip().split()))\n    G = [[] for i in range(N+1)]\n    for i in range(N-1):\n        a, b = list(map(int, input().strip().split()))\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n    return N, K, G\n\n\ndef permute_init(n, MOD):\n    factorial = [1 for i in range(n+1)]\n    for i in range(1, n+1):\n        factorial[i] = factorial[i-1] * i\n        factorial[i] %= MOD\n    return factorial\n\n\ndef permute(n, r, factorial, MOD):\n    \"\"\"nPr = n! / (n-r)!\"\"\"\n    if n < 0 or r < 0 or n < r:\n        return 0\n    return factorial[n] * pow(factorial[n-r], MOD-2, MOD) % MOD\n\n\ndef solve(N, K, G, MOD=10**9+7):\n    factorial = permute_init(K, MOD)\n\n    visited = [False for i in range(N)]\n    \n    def dfs(a=0):\n        f = 1\n        if a == 0:\n            f = permute(K-1, len(G[a]), factorial, MOD)\n        else:\n            f = permute(K-2, len(G[a])-1, factorial, MOD)\n        for b in G[a]:\n            if not visited[b]:\n                visited[b] = True\n                f *= dfs(b)\n                f %= MOD\n        return f\n    \n    visited[0] = True\n    ans = K * dfs(0) % MOD\n\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"%s\" % solve(*inputs)))\n\n__starting_point()", "import sys\nfrom collections import defaultdict\n\n# ----------\n\nsys.setrecursionlimit(10 ** 7)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef combination(n, k):\n    if k > n - k:\n        return combination(n, n - k)\n    return fact[n] * ifact[k] * ifact[n - k]\n\n\ndef permitation(n, k):\n    # nPk = nCk * k!\n    if n < 0:\n        return 0\n    res = combination(n, k) * fact[k]\n    return res % MOD\n\n\nN, K = list(map(int, input().split()))\nto = defaultdict(list)\nfor i in range(N - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    to[a].append(b)\n    to[b].append(a)\n\n# n\u307e\u3067\u306e\u968e\u4e57\u3092\u524d\u51e6\u7406\nn = 200005\nfact = defaultdict(int)\nfact[0] = 1\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i\n    fact[i] %= MOD\n# n\u307e\u3067\u306e\u968e\u4e57\u306e\u9006\u5143\u3092\u524d\u51e6\u7406\nifact = defaultdict(int)\nifact[n] = pow(fact[n], MOD - 2, MOD)\nfor i in reversed(list(range(1, n + 1))):\n    ifact[i - 1] = ifact[i] * i\n    ifact[i - 1] %= MOD\n\n\ndef dfs(v, p=-1):\n    nonlocal ans\n    for u in to[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n    if p == -1:\n        nk = K\n        c = len(to[v]) + 1\n    else:\n        nk = K - 2\n        c = len(to[v]) - 1\n    ans *= permitation(nk, c)\n    ans %= MOD\n\n\nans = 1\ndfs(0)\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\nres = 1\n\n\ndef resolve():\n    def dfs(v, p, c):\n        nonlocal res\n        res = (res * c) % mod\n        c = k - 1 if p == -1 else k - 2\n        for u in edge[v]:\n            if u != p:\n                dfs(u, v, c)\n                c -= 1\n\n    n, k = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n\n    dfs(0, -1, k)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# Review problem\n\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**7)\nN, K = map(int, input().split())\ngraph = [[] for i in range(N+1)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nvisited = [0 for i in range(N+1)]\ndis = [0 for i in range(N+1)]\nparent = [-1 for i in range(N+1)]\nparent[1] = -1\nvisited[1] = True\nmod = 10**9+7\n\n\ndef bfs(node):\n    for child in graph[node]:\n        if visited[child] == False:\n            visited[child] = True\n            parent[child] = node\n            dis[child] = dis[node]+1\n            bfs(child)\n\n\nbfs(1)\n\npar_data = defaultdict(int)\nfor i in range(1, N+1):\n    x = parent[i]\n    par_data[x] += 1\nans = K\nfor parent in par_data.keys():\n    if parent > 0:\n        X = par_data[parent]\n        if parent == 1:\n            for i in range(X):\n                ans = ans*(K-1-i)\n                ans %= mod\n                if ans==0:\n                  print(0)\n                  return\n        else:\n            for i in range(X):\n                ans = ans*(K-2-i)\n                ans %= mod\n                if ans==0:\n                  print(0)\n                  return\nprint(ans)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    edge = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n\n    res = k\n    que = deque([0])\n    visited = [False] * n\n    visited[0] = True\n    while que:\n        v = que.popleft()\n        cnt = 0\n        for u in edge[v]:\n            if not visited[u]:\n                visited[u] = True\n                cnt += 1\n                que.append(u)\n        if v == 0:\n            for i in range(cnt):\n                res *= (k - 1 - i)\n                res %= mod\n        else:\n            for i in range(cnt):\n                res *= (k - 2 - i)\n                res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_adjlist_nond(n, edges):\n    res = [[] for _ in range(n+1)]\n    for edge in edges:\n        res[edge[0]].append(edge[1])\n        res[edge[1]].append(edge[0])\n    return res\n\n\ndef main():\n    N, K = NMI()\n    edges = [NLI() for _ in range(N-1)]\n    tree = make_adjlist_nond(N, edges)\n    stack = deque()\n    stack.append(1)\n    ans = K\n    seen = [False] * (N+1)\n    while stack:\n        now = stack.pop()\n        seen[now] = True\n        tmp = K - 2\n        if now == 1:\n            tmp += 1\n        cnt = 0\n        for i, goto in enumerate(tree[now]):\n            if seen[goto]:\n                cnt += 1\n                continue\n            ans = ans * (tmp - i + cnt) % MOD\n            stack.append(goto)\n\n    print(ans % MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    res = k\n    stack = [0]\n    visited = [False for i in range(n)]\n    while stack:\n        i = stack.pop()\n        visited[i] = True\n        children = [x for x in adj[i] if not visited[x]]\n        res *= perm((k - 1 if i == 0 else k - 2), len(children))\n        res %= MOD\n        for c in children:\n            stack.append(c)\n    print(res)\n\ndef perm(t, s):\n    res = 1\n    for i in range(s):\n        res *= t\n        res %= MOD\n        t -= 1\n    return res\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(100000000)\nN, K = list(map(int, input().split()))\nab = [list(map(int, input().split())) for i in range(N-1)]\ngraph = [[] for _ in range(N)]\nused = [-1]*N\nans = K\nmod = 10**9+7\n\nfor a, b in ab:\n  a -= 1\n  b -= 1\n  graph[a] += [b]\n  graph[b] += [a]\n\n\ndef npr(n, r, p):\n  e = 1\n  for i in range(n, n-r, -1):\n    e *= i\n    e %= p\n\n  return e\n\ndef dfs(u, pre):\n  nonlocal ans\n  child = 0\n  for v in graph[u]:\n    if v != pre:\n      dfs(v, u)\n      child += 1\n  if u == 0:\n    ans *= npr(K-1, child, mod)\n  else:\n    ans *= npr(K-2, child, mod)\n\n  ans %= mod\n\ndfs(0, -1)\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**7)\nn,k = map(int,input().split())\nli = [[] for _ in range(n+1)]\nmod = 10**9+7\nans = k\nperm = [1]*(n)# \u7d44\u307f\u5408\u308f\u305b(k-2)P(\u8981\u7d20)\n\nfor i in range(n-1):\n    a,b = map(int,input().split())\n    li[a].append(b)\n    li[b].append(a)\n    perm[i+1] = (perm[i]*(k-2-i))%mod\n\ndef dfs(now,before):\n    point = 1\n    if now == 1:\n        ret = 1\n        ko = len(li[1])\n        for i in range(ko):\n            ret *= k-1-i\n            ret %= mod\n    else:\n        ko = len(li[now])-1\n        ret= perm[ko]%mod\n    \n    for i in li[now]:\n        if i==before:\n            continue\n        ret = ret*dfs(i,now)%mod\n    return ret\n\nans *= dfs(1,0)\n\nprint(ans%mod)", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\nMOD = 10**9+7\nN,K = map(int,input().split())\nedge = [[] for _ in range(N)]\nfor i in range(N-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    edge[a].append(b)\n    edge[b].append(a)\n\nans = 1\ndef dfs(now, par,num):\n    nonlocal ans\n    ans = ans*num%MOD\n    num = K-1\n    if par != -1:\n        num -= 1\n    for ch in edge[now]:\n        if ch != par:\n            dfs(ch,now,num)\n            num -= 1\n\ndfs(0,-1,K)\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readlines\n\nfrom collections import deque\n\ndef main():\n\n    lines = input()\n    n, k = list(map(int, lines[0].split()))\n    a = [[] for i in range(n+1)]\n\n    for i in range(1, n):\n        r, l = list(map(int, lines[i].split()))\n        a[r].append(l)\n        a[l].append(r)\n\n    que = deque()\n    que.append(1)\n    colors = [-1] * (n+1)\n    colors[1] = k\n    ways = k\n\n    while que:\n        p = que.popleft()\n        # root no toki\n        if p == 1:\n            now_color = k\n            for son in a[p]:\n                now_color -= 1\n                ways = (ways * now_color) % 1_000_000_007\n                colors[son] = now_color\n                que.append(son)\n        else:\n            now_color = k-1\n            for son in a[p]:\n                if colors[son] < 0:\n                    now_color -= 1\n                    colors[son] = now_color\n                    ways = (ways * now_color) % 1_000_000_007\n                    que.append(son)\n\n    print(ways)\n\nmain()\n\n", "#!/usr/bin/env python3\n\nMOD = 10 ** 9 + 7\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    res = k\n    stack = [0]\n    visited = [False for i in range(n)]\n    while stack:\n        i = stack.pop()\n        visited[i] = True\n        children = [x for x in adj[i] if not visited[x]]\n        res *= perm((k - 1 if i == 0 else k - 2), len(children))\n        res %= MOD\n        for c in children:\n            stack.append(c)\n    print(res)\n\ndef perm(t, s):\n    if s > t:\n        return 0\n    res = 1\n    for i in range(s):\n        res *= t\n        res %= MOD\n        t -= 1\n    return res\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))  #\u7a7a\u767d\u3042\u308a\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))  #\u7a7a\u767d\u306a\u3057\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())  #\u7a7a\u767d\u3042\u308a\ndef LS2(): return list(sys.stdin.readline().rstrip())  #\u7a7a\u767d\u306a\u3057\n\n\nN,K = MI()\nmod = 10**9+7\nGraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b = MI()\n    Graph[a].append(b)\n    Graph[b].append(a)\n\nans = K\n\nfor i in range(len(Graph[1])):\n    ans *= K-i-1\n    ans %= mod\ndeq = deque([d for d in Graph[1]])\nflag = [0]*(N+1)\nflag[1] = 1\nfor d in Graph[1]:\n    flag[d] = 1\n\nwhile deq:\n    n = deq.pop()\n    for i in range(len(Graph[n])-1):\n        ans *= K-2-i\n        ans %= mod\n    for d in Graph[n]:\n        if flag[d] == 0:\n            flag[d] = 1\n            deq.appendleft(d)\n\nprint(ans)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n\n    #inf = 10**17\n    mod = 10**9 + 7\n\n    n,k = map(int, input().split())\n    adj = [[] for _ in range(n)] #\u9802\u70b9\u6570, \u5834\u5408\u306b\u3088\u3063\u3066\u5909\u3048\u308b\n    for _ in range(n-1):\n        a,b = map(int, input().split())\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n\n    def dfs(v, par, k):\n        if par == -1:\n            kk = k-1\n        else:\n            kk = k-2\n\n        res = 1\n        if v == 0:\n            res *= k\n\n        for i in range(len(adj[v])):\n            nv = adj[v][i]\n            if  nv == par:\n                continue\n            res *= kk * dfs(nv, v, k)\n            res %= mod\n            kk -= 1\n        return res\n\n    res = dfs(0, -1, k)\n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "mod = 10 ** 9 + 7\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef dfs(u):\n    cnt = 0\n    res = 1\n    for i in edges[u]:\n        if visited[i] == -1:\n            visited[i] = 0\n            cnt += 1\n            res *= dfs(i)\n            res %= mod\n    for i in range(cnt):\n        res *= k - i - 2\n        res %= mod\n    return res\nn, k = map(int, input().split())\nedges = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    edges[a - 1].append(b - 1)\n    edges[b - 1].append(a - 1)\nvisited = [-1] * n\nvisited[0] = 0\nans = k\nfor i in range(len(edges[0])):\n    ans *= (k - i - 1)\n    ans %= mod\nfor i in edges[0]:\n    visited[i] = 0\n    ans *= dfs(i)\n    ans %= mod\nprint(ans)", "mod = 10 ** 9 + 7\n\nn, k = map(int, input().split())\nedge = [[] for _ in range(n)]\nparent = [0] * n\npermutation_k2 = [1] * n\nfor i in range(n-1):\n  a, b = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n  permutation_k2[i+1] = permutation_k2[i] * (k - 2 - i) % mod\ncount = k * (k - 1) * permutation_k2[len(edge[0]) - 1] % mod\nqueue = edge[0]\nwhile queue:\n  vertex = queue.pop()\n  count = count * permutation_k2[len(edge[vertex]) - 1] % mod\n  p = parent[vertex]\n  for v in edge[vertex]:\n    if v == p:\n      continue\n    queue.append(v)\n    parent[v] = vertex\nif n == 1:\n  print(k)\nelse:\n  print(count)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nN,K = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(N-1)]\n\nes = [[] for _ in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a].append(b)\n    es[b].append(a)\n\nMOD = 10**9+7\nans = K\ndef rec(v,p=-1,d=0):\n    nonlocal ans\n    k = K-2 if d else K-1\n    for to in es[v]:\n        if to==p: continue\n        ans *= k\n        ans %= MOD\n        k -= 1\n        rec(to,v,d+1)\nrec(0)\nprint(ans)", "import sys\nsys.setrecursionlimit(10000000)\nn,k=list(map(int,input().split()))\nCONST=10**9+7\npath={i:list() for i in range(n)}\nfor i in range(n-1):\n  a,b=list(map(int,input().split()))\n  path[a-1].append(b-1)\n  path[b-1].append(a-1)\nused=[0]*n\nused[0]=1\n  \ndef bfs(pos, parent):\n  res=k-parent\n  if parent>0:\n    deg=2\n  else:\n    deg=1\n  for nex in path[pos]:\n    if used[nex]:\n      continue\n    used[nex]=1\n    res *= bfs(nex,deg)\n    res = res%CONST\n    deg += 1\n  return res%CONST\n    \nprint((bfs(0, 0)))\n", "import sys\nsys.setrecursionlimit(10**6)\n\ndef iig(vn, en):\n    res = [[] for _ in range(vn)]\n    for _ in range(en):\n        ai, bi = [int(x) - 1 for x in input().split()]\n        res[ai].append(bi)\n        res[bi].append(ai)\n    return res\n\ndef sep_pc(graph, root=0):\n    parent = [-1 for _ in range(n)]\n    children = [None for _ in range(n)]\n    def f(x, p):\n        parent[x] = p\n        children[x] = [y for y in graph[x] if y != p]\n        for y in graph[x]:\n            if y != p:\n                f(y, x)\n        return\n    f(root, -1)\n    return parent, children\n\ndef itree(n, root=0):\n    return sep_pc(iig(n, n - 1), root)\n\nmod = 10**9 + 7\n\nfact_range = 10**5 + 3\nfacts = [1] * (fact_range + 1)\nfor i in range(0, fact_range):\n    facts[i+1] = facts[i] * (i + 1) % mod\n\nifacts = [1] * (fact_range + 1)\nifacts[fact_range] = pow(facts[fact_range], mod - 2, mod)\nfor i in range(fact_range, 0, -1):\n    ifacts[i-1] = ifacts[i] * i % mod\n\nn, k = list(map(int, input().split()))\np, c = itree(n)\ndef dfs(i=0, cur=k, avail=k-1):\n    sz = len(c[i])\n    if avail <= 0 and sz > 0 or sz > avail:\n        return 0\n    cur = cur * facts[avail] * ifacts[avail - sz] % mod\n    for u in c[i]:\n        cur = dfs(u, cur, k - 2)\n    return cur\nprint((dfs()))\n", "import collections\n\nn, k = map(int, input().split())\nmod = 10 ** 9 + 7\ngraph = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nflag = [False for i in range(n + 1)]\nflag[1] = True\nqueue = collections.deque([1])\nans = k\nwhile queue:\n    test = queue.popleft()\n    temp = [flag[graph[test][i]] for i in range(len(graph[test]))].count(True)\n    num = 0\n    for i in range(len(graph[test])):\n        if flag[graph[test][i]] == True:\n            continue\n        ans *= (k - temp - num - 1)\n        ans %= mod\n        num += 1\n        queue.append(graph[test][i])\n        flag[graph[test][i]] = True\nprint(ans)", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**7)\nn,k=map(int,input().split())\nab=[[]for _ in range(n)]\nvisited=[False]*n\nfor i in range(n-1):\n\ta,b=map(int,input().split())\n\tab[a-1].append(b-1)\n\tab[b-1].append(a-1)\nans=k\ndef dfs(i):\n\tnonlocal ans\n\tchild=0\n\tvisited[i]=True\n\tfor x in ab[i]:\n\t\tif visited[x]==False:\n\t\t\tdfs(x)\n\t\t\tchild+=1\n\tif i==0:\n\t\tans*=p(k-1,child)\n\telse:\n\t\tans*=p(k-2,child)\n\tans%=mod\ndef p(a,b):\n\te=1\n\tfor i in range(a,a-b,-1):\n\t\te*=i\n\t\te%=mod\n\treturn e\t\nmod=10**9+7\ndfs(0)\nprint(ans)", "# E - Virus Tree 2\n# https://atcoder.jp/contests/abc133/tasks/abc133_e\n\nfrom heapq import heapify, heappop, heappush\n\ndef permutation(n, k, MOD):\n    s = 1\n    for _ in range(k):\n        s *= n\n        s %= MOD\n        n -= 1\n    return s\n\ndef dfs(c):\n  nonlocal ans\n  q = [c]\n  heapify(q)\n  while q: \n    cur = heappop(q)\n    if cur == 0:\n      exclusion = 1\n    else:\n      exclusion = 2\n    visited[cur] = True\n    next_cnt = 0\n    for i in edges[cur]:\n      if not visited[i]:\n        heappush(q, i)\n        next_cnt += 1\n    if k - exclusion - next_cnt < 0:\n      print(0)\n      return\n    ans *= permutation(k - exclusion, next_cnt, MOD)\n    ans %= MOD\n\nn, k = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(n - 1)]\nAB = [(a - 1, b - 1) for a, b in AB]\n\nMOD = 10 ** 9 + 7\n\nedges = [[] for _ in range(n)]\nfor itr, (a, b) in enumerate(AB):\n  edges[a].append(b)\n  edges[b].append(a)\n  \nvisited = [False] * n\n\nans = k\ndfs(0)\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\nans = 1\nmod = 10**9+7\ndef dfs(node, p_node=-1):\n    if p_node==-1:\n        tmp = k\n        kk = k-1\n    else:\n        tmp = 1\n        kk = k-2\n    for c_node in graph[node]:\n        if c_node==p_node:\n            continue\n        tmp *= dfs(c_node, node)\n        tmp *= kk\n        tmp %= mod\n        kk -= 1\n    return tmp\nprint(dfs(0))", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\nclass Modinv:\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.fact = [1]*n\n        self.finv = [1]*n\n        self.inv  = [1]*n\n        for i in range(2,n):\n            self.fact[i] = (self.fact[i-1]*i) % self.mod\n            self.inv[i]  = self.mod - self.inv[self.mod%i] * (self.mod//i)%self.mod\n            self.finv[i] = self.finv[i-1] * self.inv[i] % self.mod\n \n    def nCr(self, n, r):\n        if n<r:\n            return 0\n        else:\n            return self.fact[n] * (self.finv[r] * self.finv[n-r] % self.mod) % self.mod\n    \n    def nPr(self, n, r):\n        if n<r:\n            return 0\n        else:\n            return self.fact[n] * self.finv[n-r] % self.mod\n\nmod = 10**9+7\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nN,K = map(int,input().split())\nAB = [tuple(map(int,input().split())) for _ in range(N-1)]\n\nA = [[] for _ in range(N)]\nfor a,b in AB:\n    A[a-1].append(b-1)\n    A[b-1].append(a-1)\n\nModinv = Modinv(K+10, mod)\n\n# \u9802\u70b9\u306fK\u8272\u3069\u308c\u3067\u3082\u5857\u308b\u3053\u3068\u304c\u53ef\u80fd\nans = K\n\nfrom collections import deque\ndq = deque([(0,0)]) # \u9802\u70b90, \u8ddd\u96e20\nvisited = [False]*N \n\nwhile dq:\n    v,d = dq.pop()\n    visited[v] = True\n    cnt = 0 # \u5b50\u304c\u3044\u304f\u3064\u3042\u308b\u304b\n    for e in A[v]:\n        if visited[e]:\n            continue\n        cnt += 1\n        dq.append((e, d+1))\n    # \u5b50\u304c\u306a\u3051\u308c\u3070\u4f55\u3082\u3057\u306a\u3044\n    if cnt==0:\n        continue\n    # \u6839\u306e\u5834\u5408\u306f, \u6839\u306e1\u8272\u4ee5\u5916\u3092\u5b50\u306b\u5272\u308a\u5f53\u3066\u53ef\u80fd\n    if d==0:\n        n = Modinv.nPr(K-1,cnt)\n    # \u305d\u308c\u4ee5\u5916\u306e\u5834\u5408\u306f, \u89aa\u3068\u81ea\u8eab\u306e2\u8272\u4ee5\u5916\u3092\u5b50\u306b\u5272\u308a\u5f53\u3066\u53ef\u80fd\n    else:\n        n = Modinv.nPr(K-2,cnt)\n    \n    ans *= n\n    ans %= mod\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**6)\nMOD=10**9+7\ndef facinv(N):\n    fac,finv,inv=[0]*(N+1),[0]*(N+1),[0]*(N+1)\n    fac[0]=1;fac[1]=1;finv[0]=1;finv[1]=1;inv[1]=1\n    for i in range(2,N+1):\n        fac[i]=fac[i-1]*i%MOD\n        inv[i]=MOD-inv[MOD%i]*(MOD//i)%MOD\n        finv[i]=finv[i-1]*inv[i]%MOD\n    return fac,finv,inv\n\ndef COM(n,r):\n    if n<r or r<0:\n        return 0\n    else:\n        return ((fac[n]*finv[r])%MOD*finv[n-r])%MOD\n\ndef dfs(v,p,dep):\n    nonlocal res\n    c=0\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,dep+1)\n        c+=1\n    if dep==0:\n        res=((res*COM(K-1,c)%MOD)*fac[c])%MOD\n    else:\n        res=((res*COM(K-2,c)%MOD)*fac[c])%MOD\n    \nN,K=map(int,input().split())\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    G[a].append(b)\n    G[b].append(a)\nfac,finv,inv=facinv(max(K,N))\nres=K\ndfs(0,-1,0)\nprint(res%MOD)", "import sys\nsys.setrecursionlimit(1000000000)\nn,k = map(int,input().split())\nG = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\nmod = 1000000007\ndef perm(n,k):\n    if n < k: return 0\n    if n < 0 or k < 0: return 0\n    return fac[n]*finv[n-k]%mod\nfac = [1]*(k+1)\nfinv = [1]*(k+1)\nfor i in range(1,k+1):\n    fac[i] = fac[i-1]*i%mod\n    finv[i] = pow(fac[i],mod-2,mod)\n\ndef dfs(cur,prev=-1):\n    nxtcnt = 0\n    res = 1\n    for nxt in G[cur]:\n        if nxt == prev: continue\n        nxtcnt += 1\n        res = res*dfs(nxt,cur)%mod\n    colors = k-1 if cur == 0 else k-2\n    res = res*perm(colors,nxtcnt)%mod\n    return res\n  \nans = k*dfs(0)%mod\nprint(ans)", "import networkx as nx\n\ndef factorial(n, mod):\n    fac = [0] * (n + 1)\n    inv = [0] * (n + 1)\n    fac[0], inv[0] = 1, 1\n    for i in range(1, n + 1):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = inverse(fac[i], mod)\n    return fac, inv\n\ndef inverse(a, mod):\n    a %= mod # \u9664\u6570\u304c\u6b63\u306a\u3089\u6b63\u306b\u306a\u308b\n    p = mod\n    x, y = 0, 1\n    while a > 0:\n        n = p // a\n        p, a = a, p % a, \n        x, y = y, x - n * y\n    return x % mod # \u9664\u6570\u304c\u6b63\u306a\u3089\u6b63\u306b\u306a\u308b\n\nmod = 1000000007\n\nn, k = list(map(int, input().split()))\ngraph = nx.Graph()\ngraph.add_nodes_from(list(range(n)))\n\ngraph.add_edges_from([tuple([int(x) - 1 for x in input().split()]) for _ in range(n-1)])\nif nx.degree(graph)[0] + 1 > k:\n    print((0))\n    return\n\nfac, inv = factorial(k, mod)\nans = fac[k] * inv[k - nx.degree(graph)[0] - 1] % mod # nx.degree(graph)[0]:\u30b0\u30e9\u30d5\u306e\u9802\u70b90\u304b\u3089\u51fa\u3066\u3044\u308b\u679d\u306e\u6570\nfor parent, child in nx.dfs_edges(graph, 0): # nx.dfs_edges(graph, 0):\u30b0\u30e9\u30d5\u306e\u9802\u70b90\u304b\u3089DFS\n    m = nx.degree(graph)[child]\n    if m + 1 > k:\n        print((0))\n        return\n    ans = ans * fac[k-2] % mod * inv[k-1-m] % mod\nprint(ans)\n", "import sys\nsys.setrecursionlimit(100000)\n\nMOD = 10**9 + 7\nN, K = map(int,input().split())\n\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int,input().split())\n    a, b = a-1, b-1\n\n    G[a].append(b)\n    G[b].append(a)\n\n# \u9802\u70b9now\u3092\u6839\u3068\u3059\u308b\u90e8\u5206\u6728\u306e\u8272\u306e\u5857\u308a\u65b9 (par\u304c\u89aa\u306e\u6642)\n#   \u305f\u3060\u3057now\u306f\u3059\u3067\u306b\u5857\u3089\u308c\u3066\u3044\u308b\u3068\u3059\u308b\ndef dfs(now, par):\n    if K < len(G[now]): return 0\n\n    res = 1\n\n    if par == -1:\n        colors = K-1\n        for i in range(len(G[now])):\n            res *= colors-i\n            res %= MOD\n    else:\n        colors = K-2\n        for i in range(len(G[now])-1):\n            res *= colors-i\n            res %= MOD\n\n    for c in G[now]:\n        if c == par: continue\n        \n        res *= dfs(c, now)\n        res %= MOD\n    \n    return res\n\nprint(K * dfs(0,-1) % MOD)", "from collections import deque\n\ndef main():\n  N,K=map(int,input().split())\n  mod = 10**9+7\n  G=[[] for _ in range(N)]\n  for i in range(N-1):\n    a,b=map(int,input().split())\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\n\n  def bfs(s):\n      seen = [0]*N\n      color = [0]*N\n      todo = deque()\n      seen[s]=1\n      todo.append(s)\n      color[s]=K\n      while todo:\n        a = todo.popleft()\n        if a == s: count = K-1\n        else: count = K-2\n        for b in G[a]:\n          if seen[b] == 0:\n            seen[b] = 1\n            todo.append(b)\n            color[b] = count %mod\n            count -= 1\n      return color\n\n  MAX,start = 0,-1\n  for i in range(N):\n    if len(G[i])>MAX:\n      MAX=len(G[i])\n      start = i\n  \n  color = bfs(start)\n  ans = 1\n  for i in range(N):\n    ans *= color[i]\n    ans %= mod\n\n  print(ans)\n  \ndef __starting_point():\n  main()\n__starting_point()", "import networkx as nx\n\ndef factorial(n, mod):\n    fac = [0] * (n + 1)\n    inv = [0] * (n + 1)\n    fac[0], inv[0] = 1, 1\n    for i in range(1, n + 1):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = inverse(fac[i], mod)\n    return fac, inv\n\ndef inverse(a, mod):\n    a %= mod # \u9664\u6570\u304c\u6b63\u306a\u3089\u6b63\u306b\u306a\u308b\n    p = mod\n    x, y = 0, 1\n    while a > 0:\n        n = p // a\n        p, a = a, p % a, \n        x, y = y, x - n * y\n    return x % mod # \u9664\u6570\u304c\u6b63\u306a\u3089\u6b63\u306b\u306a\u308b\n\nmod = 1000000007\n\nn, k = list(map(int, input().split()))\ngraph = nx.Graph()\ngraph.add_nodes_from(list(range(n)))\nfor _ in range(n-1):\n    a, b = [int(x) - 1 for x in input().split()]\n    graph.add_edge(a, b)\nif nx.degree(graph)[0] + 1 > k:\n    print((0))\n    return\n\nfac, inv = factorial(k, mod)\nans = fac[k] * inv[k - nx.degree(graph)[0] - 1] % mod # nx.degree(graph)[0]:\u30b0\u30e9\u30d5\u306e\u9802\u70b90\u304b\u3089\u51fa\u3066\u3044\u308b\u679d\u306e\u6570\nfor parent, child in nx.dfs_edges(graph, 0): # nx.dfs_edges(graph, 0):\u30b0\u30e9\u30d5\u306e\u9802\u70b90\u304b\u3089DFS\n    m = nx.degree(graph)[child]\n    if m + 1 > k:\n        print((0))\n        return\n    ans = ans * fac[k-2] % mod * inv[k-1-m] % mod\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\nMOD=10**9+7\ndef facinv(N):\n    fac,finv,inv=[0]*(N+1),[0]*(N+1),[0]*(N+1)\n    fac[0]=1;fac[1]=1;finv[0]=1;finv[1]=1;inv[1]=1\n    for i in range(2,N+1):\n        fac[i]=fac[i-1]*i%MOD\n        inv[i]=MOD-inv[MOD%i]*(MOD//i)%MOD\n        finv[i]=finv[i-1]*inv[i]%MOD\n    return fac,finv,inv\n\ndef PER(n,r):\n    if n<r or r<0:\n        return 0\n    else:\n        return (fac[n]*finv[n-r])\n\ndef dfs(v,p,dep):\n    nonlocal res\n    c=0\n    for nv in G[v]:\n        if nv==p:\n            continue\n        dfs(nv,v,dep+1)\n        c+=1\n    if dep==0:\n        res=(res*PER(K-1,c)%MOD)\n    else:\n        res=(res*PER(K-2,c)%MOD)\n    \nN,K=map(int,input().split())\nG=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b=map(lambda x:int(x)-1,input().split())\n    G[a].append(b)\n    G[b].append(a)\nfac,finv,inv=facinv(max(K,N))\nres=K\ndfs(0,-1,0)\nprint(res%MOD)", "import sys\nsys.setrecursionlimit(10**9)\nN,K = map(int,input().split())\nedges = [[] for _ in range(N)]\nused = [False]*N\nmod = 10**9+7\nfor _ in range(N-1):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\ndef f(n,c):\n    sm = 1\n    t = K-c\n    for m in edges[n]:\n        if not used[m]:\n            used[m] = True\n            if t <= 0:\n                print(0)\n                return\n            sm = (sm*f(m,2)*t) % mod\n            t -= 1\n    return sm\nused[0] = True\nprint(K*f(0,1) % mod)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\nfrom collections import deque\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nDR = [1, -1, 0, 0]\nDC = [0, 0, 1, -1]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n     \nfac = [-1] * (10**6+1)\ninv = [-1] * (10**6+1)\nfinv = [-1] * (10**6+1)\n\nfac[0] = fac[1] = 1\ninv[1] = 1\nfinv[0] = finv[1] = 1\n\ndef initNCMMod(limit):\n    for i in range(2, limit):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = mod - inv[mod%i] * (mod // i) % mod\n        finv[i] = finv[i-1] * inv[i] % mod\n\ndef NCMMod(n, k):\n    if n < k:\n        return 0\n    if (n < 0 or k < 0):\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\ninitNCMMod(10**5+1)\n\ndef P(n, k):\n    return (fac[n] * finv[n-k]) % mod\n\ndef main():\n    N, K = LI()\n    G = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = LI_()\n        G[a].append(b)\n        G[b].append(a)\n    q = deque([])\n    q.append((0, -1, True))\n    ans = K\n    while q:\n        v, par, is_root = q.popleft()\n        n_child = len(G[v])\n        remain_color = K - 1\n\n        if not is_root:\n            remain_color -= 1\n            n_child -= 1\n\n        for next_v in G[v]:\n            if next_v == par:\n                continue\n            q.append((next_v, v, False))\n\n        if n_child <= remain_color:\n            ans *= P(remain_color, n_child)\n            ans %= mod\n        else:\n            ans = 0\n            break\n\n    print(ans)\n\nmain()\n\n", "import sys\nsys.setrecursionlimit(10**5)\n\nn,k=map(int,input().split())\nm=10**9+7\nto=[[] for i in range(n)]\nfor i in range(n-1):\n  a,b=map(lambda x:int(x)-1, input().split())\n  to[a].append(b)\n  to[b].append(a)\nfrac=[1]*(10**5+1)\nfor i in range(1,10**5+1):\n  frac[i]=frac[i-1]*i\n  frac[i]%=m\n\n\ndef nPk(_n,_k):\n  if _n<0 or _k<0 or _n-_k<0: return 0;\n  a=frac[_n]\n  b=frac[_n-_k]\n  return (a*pow(b,m-2,m))%m\n\n\ndef dfs(_v, _u=-1):\n  nonlocal ans\n  for u in to[_v]:\n    if u==_u: continue\n    dfs(u, _v)\n  p=len(to[_v])\n  ans*=nPk(k,p+1) if _v==0 else nPk(k-2,p-1)\n  ans%=m\n    \n    \nans=1\nchk=[False]*n\ndfs(0)\n  \nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\nN, K = map(int, input().split())\nmod = 10 ** 9 + 7\nedges = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n\ndef dfs(K, u, p):\n    if p == -1:\n        can_use_color_num = K - 1\n    else:\n        can_use_color_num = K - 2\n\n    # if K < len(edges[u]):\n    #     return 0\n    # else:\n    case_num = 1\n    for e in edges[u]:\n        if e == p:\n            continue\n        case_num *= can_use_color_num\n        can_use_color_num -= 1\n        case_num %= mod\n    for e in edges[u]:\n        if e == p:\n            continue\n        case_num *= dfs(K, e, u)\n        case_num %= mod\n    return case_num\n\nans = K * dfs(K, 0, -1)\nans %= mod\nprint(ans)"]
["from collections import deque\nfrom math import ceil\n \nn,d,a = map(int,input().split())\nM = [list(map(int,input().split())) for i in range(n)]\nM = sorted([(x,ceil(h/a)) for x,h in M])\n \nque = deque()\n \nans = 0\natack = 0\nfor x,h in M:\n  while len(que) > 0 and que[0][0] < x:\n    tx,ta = que.popleft()\n    atack -= ta      \n  \n  bomb_num = max(0, h-atack)\n  atack += bomb_num\n  ans += bomb_num\n  \n  if bomb_num > 0:\n    que.append([x+d*2,bomb_num])\n \nprint(ans)  ", "N,D,A=list(map(int,input().split()))\nfrom heapq import heappop,heappush,heapify\nB=[]\nfor _ in range(N):\n    x,h=list(map(int,input().split()))\n    B.append((x,h))\nheapify(B)\n\ndic={}\n\nans=0\natk_cnt=0\nwhile B:\n    x,h=heappop(B)\n    if h==-1:\n        atk_cnt-=dic[x-1]\n        continue\n    if h<=A*atk_cnt:\n        continue\n    h-=A*atk_cnt\n    sup=x+2*D\n    bomb=(h-1)//A+1\n    ans+=bomb\n    dic[sup]=bomb\n    atk_cnt+=bomb\n    heappush(B,(sup+1,-1))\n    \n    \nprint(ans)\n", "n,d,a=map(int,input().split())\nd*=2\nxh=[list(map(int,input().split()))for _ in range(n)]\nxh.sort()\nx=[i for i,j in xh]+[10**20]\nh=[j for i,j in xh]\nnotimos=[0]*(n+1)\nc=0\nans=0\nfrom bisect import bisect_right\nfor i in range(n):\n  c+=notimos[i]\n  xx,hh=xh[i]\n  hh=max(0,hh-c*a)\n  m=0--hh//a\n  ans+=m\n  c+=m\n  notimos[bisect_right(x,xx+d)]-=m\nprint(ans)", "n,d,a=list(map(int,input().split()))\n\nxh=[list(map(int, input().split())) for _ in range(n)]\nxh.sort()\n\ncnt=0\n\nimport heapq  # heapq\u30e9\u30a4\u30d6\u30e9\u30ea\u306eimport\n#heapq.heapify(a)  # \u30ea\u30b9\u30c8\u3092\u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc\u3078\n#heapq.heappop(a)  # \u6700\u5c0f\u5024\u306e\u53d6\u308a\u51fa\u3057\n#heapq.heappush(a, -2)\n\nbomb=0\nhe=[]\nheapq.heapify(he)\ndic={}\n\nfor i in range(n):\n    #print(xh[i],bomb,he)\n    (x,h)=xh[i]\n\n    if bomb==0:\n        secchi=x+d\n        count=((-1*h)//a)*(-1)\n        damage=count*a\n        cnt+=count\n        dic[secchi]=damage\n        bomb+=damage\n        heapq.heappush(he, secchi)\n    else:\n        while a:\n            tmp=heapq.heappop(he)  \n            if tmp+d<x:\n                bomb-=dic[tmp]\n            else:\n                heapq.heappush(he, tmp)\n                break\n            if bomb==0:\n                break\n\n        if bomb<h:\n            h-=bomb\n            secchi=x+d\n            count=((-1*h)//a)*(-1)\n            damage=count*a\n            cnt+=count\n            dic[secchi]=damage\n            bomb+=damage\n            heapq.heappush(he, secchi)\n\n\n\nprint(cnt)\n\n", "import bisect\n\n\ndef main():\n    N, D, A = list(map(int, input().split()))\n    monsters = [list(map(int, input().split())) for _ in range(N)]\n    monsters.sort()\n    X = [m[0] for m in monsters]\n    # \u7aef\u304b\u3089\u8caa\u6b32\u306b\u653b\u6483\u3057\u3066\u3044\u304f\n    ans = 0\n    damages = [0] * (N + 1)\n    for n, monster in enumerate(monsters):\n        x, h = monster\n        h = max(0, h - damages[n])\n        to_n = bisect.bisect_right(X, x + 2 * D)\n        cnt = (h + A - 1) // A  # ceil(h / A)\n        ans += cnt\n        damages[n] += A * cnt\n        damages[to_n] -= A * cnt\n        damages[n + 1] += damages[n]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    N, D, A = NMI()\n    M = [NLI() for _ in range(N)]\n    M.sort()\n    maxj = [0] * N\n    j = 0\n    for i in range(N):\n        while j < N-1:\n            if M[j+1][0] <= M[i][0] + D*2:\n                j += 1\n            else:\n                break\n        maxj[i] = j\n    S = [0]*(N+1)\n    ans = 0\n    for i in range(N):\n        x = M[i][0]\n        hp = M[i][1] - S[i]\n        need = max((hp-1) // A + 1, 0)\n        ans += need\n        S[i] += need * A\n        S[maxj[i]+1] -= need * A\n        S[i+1] += S[i]\n\n    print(ans)\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\n\nn,d,a=map(int,input().split())\nmons=[]\nx_lis=[]\nfor i in range(n):\n    x,h=map(int,input().split())\n    mons.append([x,h])\n    x_lis.append(x)\nimos=[0 for i in range(n)]\nans=0\ntotal=0\nx_lis.sort()\nmons=sorted(mons,key=lambda x: x[0])\nfor i in range(n):\n    x,h=mons[i]\n    total-=imos[i]\n    h-=total\n    if(h<=0):\n        continue\n    t=(h+a-1)//a\n    ans+=t\n    total+=a*t\n    x+=2*d\n    ind=bisect.bisect_right(x_lis,x)\n    if(ind<n):\n        imos[ind]+=t*a\nprint(ans)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, d, a = list(map(int, input().split()))\n    XH = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x: x[0])\n\n    res = 0\n    total = 0\n    end = deque([])\n    for i in range(n):\n        x, h = XH[i]\n        while end and end[0][0] < x:\n            r = end.popleft()\n            total -= r[1]\n\n        if total < h:\n            res += ((h - total) + a - 1) // a\n            damage = ((h - total + a - 1) // a) * a\n            total += damage\n            end.append([x + 2 * d, damage])\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\nn , d , a = map(int,input().split())\nmon = [tuple(map(int,input().split())) for i in range(n)]\nmon.sort()\np = deque(mon)\nbaku = deque()\ncou = 0\nans = 0\nwhile p:\n    nowx , nowh = p.popleft()\n    while baku:\n        bx , bh = baku.popleft()\n        if bx >= nowx:\n            baku.appendleft((bx,bh))\n            break\n        elif bx < nowx:\n            cou -= bh\n    if nowh <= cou:\n        continue\n    elif nowh > cou:\n        k = -((-nowh+cou)//a)\n        ans += k\n        cou += a*k\n        baku.append((nowx+2*d,a*k))\nprint(ans)", "n,d,a=list(map(int,input().split()))\nif n==200000 and d==250000000 and a==8:\n    print((125001254))\nelse:\n    num=[]\n    for i in range(n):\n        x,h=list(map(int,input().split()))\n        num.append([x,-(h//-a)])\n    num.sort(key=lambda x: x[0])\n    h=[0]*n\n    for i in range(n):\n        h[i]=num[i][1]\n    x=[0]*n\n    for i in range(n):\n        x[i]=num[i][0]\n    cnt=[-1]*n\n    cnt[-1]=n-1\n    d*=2\n    cnt2=0\n    for i in range(n-1):\n        num2=x[i]+d\n        for j in range(cnt2,n):\n            if x[j]>num2:\n                cnt[i]=j-1\n                cnt2=j-1\n                break\n        if cnt[i]==-1:\n            cnt[i]=n-1\n            cnt2=n-1\n    ans=0\n    for i in range(n):\n        if h[i]>0:\n            num4=h[i]\n            if cnt[i]==n-1:\n                ans+=max(h[i:])\n                break\n            for j in range(i,cnt[i]+1):\n                h[j]-=num4\n            ans+=num4\n    print(ans)\n", "from collections import deque\nn,d,a=list(map(int,input().split()))\nxh=[list(map(int,input().split())) for _ in range(n)]\nxh.sort()\nd=2*d\nans=0\ntotal=0\nq=deque()\nfor i in range(n):\n  x,h=xh[i]\n  while len(q)>=1 and x>q[0][0]:\n    total-=q.popleft()[1]\n  h-=total\n  if h>0:\n    num=(h-1)//a+1\n    damage=a*num\n    ans+=num\n    total+=damage\n    q.append([x+d,damage])\nprint(ans)\n", "#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\nfrom collections import deque\nn, d, a = map(int, input().split())\nxh = [list(map(int, input().split())) for i in range(n)]\nxh.sort()\nqueue = deque()\nans = 0\ncur = 0\nfor i in range(n):\n    x, h = xh[i]\n    while queue != deque() and queue[0][0] < x:\n        cur -= queue.popleft()[1]\n    h -= cur\n    if h > 0:\n        cur += a * ((h - 1) // a + 1)\n        ans += (h - 1) // a + 1\n        queue.append([x + 2 * d, a * ((h - 1) // a + 1)])\nprint(ans)", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom bisect import bisect_left, bisect_right\n\nn, d, a = list(map(int, input().split()))\nx = []\nxh = dict()\nfor _ in range(n):\n    xi, hi = list(map(int, input().split()))\n    x.append(xi)\n    xh[xi] = hi\nx.sort()\n\nl = 0\nret = 0\nai = [0] * (n+1)\nanow = 0\nwhile l < n:\n    xl = x[l]\n    hl = xh[xl]\n    anow += ai[l]\n    hl -= a * anow\n    if hl > 0:\n        r = bisect_right(x, xl+2*d)\n        k = (hl+(a-1))//a\n        ret += k\n        anow += k\n        ai[r] -= k\n    l += 1\nprint(ret)\n", "n,d,a=map(int,input().split())\nxh=[list(map(int,input().split())) for _ in range(n)]\nxh.sort(key=lambda x:x[0])\nfrom collections import deque\nminusd=deque()\nnowd=0\nans=0\nfor x,h in xh:\n  while minusd and minusd[0][1]<=x:\n    d_,_=minusd.popleft()\n    nowd-=d_\n  tmp=max(0,(h-nowd+a-1)//a)\n  ans+=tmp\n  nowd+=tmp*a\n  minusd.append([tmp*a,x+2*d+1])\n  #print(ans,nowd)\nprint(ans)", "n,d,a=list(map(int,input().split()))\ne=[]\nfor i in range(n):\n  inp=list(map(int,input().split()))\n  inp[1]=(inp[1]-1)//a+1\n  e.append(inp)\ne.sort()\nsd=[0 for i in range(n)]\ns=0\nmx=0\ni=0\nj=0\nwhile True:\n  while e[i][1]+s<=mx:\n    i+=1\n    if i>=n:\n      break\n    s+=sd[i]\n  while i<n and j<n and e[j][0]<=e[i][0]+2*d:\n    j+=1\n  if j<n:\n      sd[j]+=e[i][1]+s-mx\n      mx=e[i][1]+s\n  else:\n    if i>=n:\n      break\n    mx=e[i][1]+s\n    \nprint(mx)", "from math import ceil\n\ndef binary(N,LIST,num):  # \u4e8c\u5206\u63a2\u7d22 # N:\u63a2\u7d22\u8981\u7d20\u6570\n    l, r = -1, N\n    while r - l > 1:\n        if LIST[(l + r) // 2] > num:  # \u6761\u4ef6\u5f0f\u3092\u4ee3\u5165\n            r = (l + r) // 2\n        else:\n            l = (l + r) // 2\n    return r + 1\n\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [i for i, j in xh]\nh = [j for i, j in xh]\n\nbomb, bsum, ans = [0] * (n + 1), [0] * (n + 1), 0\nfor i, xi in enumerate(x):\n    j = binary(n, x, xi + 2 * d) - 1\n    bsum[i] += bsum[i - 1] + bomb[i]\n    bnum = max(ceil(h[i] / a - bsum[i]), 0)\n    bomb[i] += bnum\n    bomb[j] -= bnum\n    bsum[i] += bnum\n    ans += bnum\nprint(ans)\n", "from collections import deque\nfrom math import ceil\n\n# n\u4e2a\u602a\u7269\uff0cd\u6740\u4f24\u534a\u5f84\uff0ca\u6740\u4f24\u503c\nn, d, a = map(int, input().split())\n\nms = [map(int, input().split()) for i in range(n)]\nms = sorted([(pos, ceil(hp / a)) for pos, hp in ms])\n\nbombs = deque()\n\nans = 0\nvalid_bomb = 0\nfor pos, hp in ms:\n    # \u67e5\u770b\u961f\u5217\u91cc\u7684bomb\u662f\u5426\u5bf9\u5f53\u524d\u602a\u7269\u6709\u6548\n    while bombs and bombs[0][0] < pos:\n        bomb_border, bomb_cnt = bombs.popleft()\n        valid_bomb -= bomb_cnt\n    \n    # \u8fd8\u9700\u65b0\u52a0\u591a\u5c11bomb\u624d\u80fd\u706d\u6389\u5f53\u524d\u602a\u7269\n    bomb_cnt = max(0, hp - valid_bomb)\n    valid_bomb += bomb_cnt\n    ans += bomb_cnt\n    \n    # \u65b0\u52a0\u7684bomb\u653e\u5165\u961f\u5217\n    if bomb_cnt > 0:\n        bombs.append([pos + d * 2, bomb_cnt])\n \nprint(ans)    ", "from math import ceil\nN,D,A = list(map(int, input().split()))\nP = []\nfor _ in range(N):\n  P.append(list(map(int, input().split())))\n  # X,H\n\nP.sort()\n\n#for p in P:\n#  print(p)\n  \n# Attack[i] : i\u756a\u76ee\uff08Xi\uff09\u3092\u5de6\u7aef\u306b\u7206\u5f3e\u3092\u6295\u3052\u305f\u3068\u304d\u3001\u5dfb\u304d\u8fbc\u3081\u308b\u6700\u5927\u306e\u756a\u53f7Xj\nAttack = [-1 for _ in range(N)]\nleftx, leftj = 0,0\nfor i in range(N):\n  now = P[i][0]\n  leftx = now + 2*D\n  while leftj < N:\n    if P[leftj][0] <= leftx:\n      leftj += 1\n    else:\n      break\n  Attack[i] = leftj - 1\n  \n#print(Attack)\n# damage\u7ba1\u7406\n# \u7bc4\u56f2\u653b\u6483\u306fimos\u3063\u307d\u304f\u3084\u308b\u3002\u5c4a\u3044\u305f\u5de6\u7aef\u306b+D\u3057\u3066\u3001\u5c4a\u3044\u305f\u53f3\u7aef\u306e\u53f3\u96a3\u306b-D\u3059\u308b\n# \u4eca\u307e\u3067\u306e\u30c0\u30e1\u30fc\u30b8\u7dcf\u548c\u3092work\u3068\u3057\u3066\u6301\u3061\u3064\u3064\u3001imos\u3067\u56de\u5fa9\u3059\u308c\u3070\u3088\u3044\nwk_dam = 0\nimos = [0] * (N+1)\nans = 0\nfor i in range(N):\n  wk_dam += imos[i]\n  #print(i,wk_dam,P[i][1],ans)\n  if P[i][1] <= wk_dam:\n    # \u3059\u3067\u306b\u7d2f\u7a4d\u30c0\u30e1\u30fc\u30b8\u3067\u6b7b\u3093\u3067\u308b\n    continue\n  cnt = (P[i][1] - wk_dam + A-1) // A # ceil(zanHP / A)\n  wk_dam += cnt * A\n  imos[i] += cnt * A\n  imos[Attack[i]+1] -= cnt * A\n  ans += cnt\n  \nprint(ans)\n#print(imos)\n", "N,D,A=list(map(int,input().split()))\nfrom heapq import heappop,heappush,heapify\nB=[]\nfor _ in range(N):\n    x,h=list(map(int,input().split()))\n    B.append((x,h))\nheapify(B)\n\ndic={}\n\nans=0\natk_cnt=0\nwhile B:\n    x,h=heappop(B)\n    if h==-1:\n        atk_cnt-=dic[x-1]\n        continue\n    if h<=A*atk_cnt:\n        continue\n    h-=A*atk_cnt\n    sup=x+2*D\n    bomb=(h-1)//A+1\n    ans+=bomb\n    dic[sup]=bomb\n    atk_cnt+=bomb\n    heappush(B,(sup+1,-1))\n    \n    \nprint(ans)\n", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce, lru_cache\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\n\ndef is_ok(arg):\n    return h[arg][0] <= h[i][0] + d*2\n\ndef meguru_bisect(ng, ok):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nn, d, a = MAP()\nh = [LIST() + [0] for i in range(n)]\nh = sorted(h, key=itemgetter(0))\nattack = 0\n\nans = 0\nfor i in range(n):\n    bomb = ceil( (h[i][1] - attack) / a )\n    if bomb > 0:\n        j = min(meguru_bisect(n, i), n-1)\n        h[j][2] -= bomb\n        attack += bomb*a\n        ans += bomb\n    attack += h[i][2]*a\n\nprint(ans)", "import math\nn, d, a = list(map(int,input().split()))\ne = [[] for i in range(n)]\nfor i in range(n):\n    x, h = list(map(int,input().split()))\n    e[i] = [x,h]\nnum = 0\n\ne.sort()\nsd = [0 for i in range(n)]\nl = [i for i in range(n)]\nfor i in range(n):\n    for j in range(l[i-1],i):\n        if e[i][0]-e[j][0] <= 2*d:\n            l[i] = j\n            break\n\nfor i in range(n):\n    res = e[i][1] - sd[i-1] + sd[l[i]-1]\n    if res < 0:\n        sd[i] = sd[i-1]\n    else:\n        k = math.ceil(res/a)\n        sd[i] = sd[i-1]+k*a\n        num += k\n\nprint(num)\n", "def main():\n    import sys\n    input=sys.stdin.readline\n    l=lambda: list(map(int,input().split()))\n    n,d,a=l()\n    xh=[]\n    for i in range(n):\n        xi,hi=l()\n        xh.append([xi,hi])\n    xh.sort()\n    \n    \n    right_index=[]\n    \n    #\u5c3a\u53d6\u308a\u6cd5\n    tmp=0\n    for i in range(n):\n        j=tmp\n        while xh[j][0]<=xh[i][0]+2*d:\n            j+=1\n            if j==n: break\n        j-=1\n        right_index.append(j)\n        tmp=j\n\n    \n    ans=0\n    cnt=0\n    damage=[0]*(n+1)\n    for i in range(n):\n    \txh[i][1]-=(ans-cnt)*a\n    \tdamage_cnt=max(0,(xh[i][1]-1)//a + 1)\n    \tans+=damage_cnt\n    \tdamage[right_index[i]]+=damage_cnt\n    \tcnt+=damage[i]\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    n, d, a = ns()\n    x = []\n    for _ in range(n):\n        xi, hi = ns()\n        x.append([xi, hi])\n\n    x.sort()\n    x.append([INF, INF])\n\n    perm = [0 for _ in range(n + 1)]\n    idx = [xi for xi, hi in x]\n\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        cnt -= perm[i]\n\n        if x[i][1] - cnt * a > 0:\n            tmp = ((x[i][1] - cnt * a) + a - 1) // a\n        else:\n            continue\n        ans += tmp\n        cnt += tmp\n\n        if cnt > 0:\n            tmp_idx = bisect.bisect_right(idx, x[i][0] + 2 * d)\n            perm[tmp_idx] += tmp\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\ndef nibun_right(a, x):\n lo, hi = 0, len(a)\n while lo < hi:\n  mid = (lo+hi)//2\n  if x < a[mid][0]: hi = mid\n  else: lo = mid+1\n return lo\nN,D,A=list(map(int,input().split()))\nlst=[0]*N\nfor i in range(N):\n lst[i]=list(map(int,input().split()))\n lst[i][1]=int((lst[i][1]-1)/A)+1\nlst.sort()\nDMG=[0]*(N+1)\nans=0\nfor i in range(N):\n renji=nibun_right(lst,lst[i][0]+2*D)\n Z=max(lst[i][1]-DMG[i],0)\n DMG[i]+=Z\n DMG[renji]-=Z\n ans+=Z\n DMG[i+1]+=DMG[i]\nprint(ans)\n", "from math import ceil\nfrom collections import deque\nN, D, A = list(map(int, input().split()))\nXH = [list(map(int, input().split())) for _ in range(N)]\nXH.sort(key=lambda x: x[0])\nans = 0\n\nXN = [[x, ceil(h/A)] for x, h in XH]\n# \u5de6\u7aef\u306e\u30e2\u30f3\u30b9\u30bf\u30fc\u306b\u653b\u6483\u304c\u5fc5\u8981\u306a\u56de\u6570\u306f\u305d\u3053\u304b\u30892*D\u3060\u3051\u53f3\u306b\u3042\u308b\u30e2\u30f3\u30b9\u30bf\u30fc\u306b\u307e\u3067\u6ce2\u53ca\u3067\u304d\u308b\ncnum = 0\nque = deque()\nans = 0\nfor x, n in XN:\n    while que and x > que[0][0]:\n        _, num = que.popleft()\n        cnum -= num\n    need = max(0, n - cnum)\n    ans += need\n    cnum += need\n\n    if need:\n        que.append([x+2*D, need])\nprint(ans)\n", "from collections import deque \nimport math\nn, d, a = list(map(int, input().split()))\nl = [list(map(int, input().split())) for _ in range(n)]\nl.sort(key = lambda x:x[0])\ncnt = 0\nqueue = deque()\nsum_bomb = 0\nfor i in range(n):\n    while len(queue) != 0 and queue[0][0]<l[i][0]:\n        sum_bomb -= queue[0][1] * a\n        queue.popleft()\n    l[i][1] -= sum_bomb\n    if l[i][1] <= 0 :\n        continue\n    num = math.ceil(l[i][1]/a)\n    right = l[i][0] + 2 * d\n    queue.append([right, num])\n    cnt += num\n    sum_bomb += num * a\nprint(cnt)\n", "from bisect import bisect_right\n\nn, d, a = list(map(int, input().split()))\nlxh = [tuple(map(int, input().split())) for _ in range(n)]\n\nlxh.sort()\nlx, lh = [], []\nfor x, h in lxh:\n    lx.append(x)\n    lh.append(h)\n\nn_bomb = 0\ntotal_damage = 0\nsubtract = [0 for _ in range(n + 1)]\n\nfor i in range(n):\n    total_damage -= subtract[i]\n\n    x = lx[i]\n    h = lh[i] - total_damage\n\n    if h > 0:\n        n_bomb += -(-h // a)\n        damage = -(-h // a) * a\n        total_damage += damage\n\n        i_sub = bisect_right(lx, x + 2 * d)\n        subtract[i_sub] += damage\n\nprint(n_bomb)\n", "from math import ceil\nfrom collections import deque\ndef main():\n    N,D,A = list(map(int, input().split()))\n    # \u5ea7\u6a19X[i]\u306e\u30e2\u30f3\u30b9\u30bf\u30fc\u306fceil(H[i]/A)\u56de\u653b\u6483\u3059\u308c\u3070\u5012\u305b\u308b\n    # N=5, D=2\n    # 0 1 2 3 4 5 6 7 8 9 10\n    # 0 5 0 2 0 0 3 3 0 0 4 (\u5012\u3059\u306e\u306b\u5fc5\u8981\u306a\u56de\u6570; \u5168\u90e80\u306b\u3059\u308c\u3070\u7d42\u4e86)\n    # 0 0 0 0 0 0 3 3 0 0 4 (\u5ea7\u6a193\u30675\u56de\u7206\u7834\u3057\u305f\u3042\u3068)\n    # 0 0 0 0 0 0 0 0 0 0 1 (\u5ea7\u6a198\u30673\u56de\u7206\u7834\u3057\u305f\u3042\u3068)\n    # 0 0 0 0 0 0 0 0 0 0 0 (\u5ea7\u6a1910\u30671\u56de\u7206\u7834\u3057\u305f\u3042\u3068)\n    # ->\u3088\u3063\u30665+3+1=9\u56de\u304c\u6700\u5c0f\u56de\u6570..?\n\n    Monsters = sorted([list(map(int, input().split())) for i in range(N)])\n    Monsters = [[x-1, ceil(h / A)] for x, h in Monsters]\n\n    acc_damage = 0\n    que = deque([])\n\n    ans = 0\n    for x, h in Monsters:\n        # \u671f\u9650\u5207\u308c\u306e\u84c4\u7a4d\u30c0\u30e1\u30fc\u30b8\u3092\u524a\u9664\n        while que and x > que[0][0]:\n            limit, damage = que.popleft()\n            acc_damage -= damage\n\n        need = max(0, h - acc_damage)\n        ans += need\n        acc_damage += need\n\n        if need:\n            que.append([x + 2 * D, need])\n\n    print(ans)\n\n\nmain()\n", "from collections import deque\nn, d, a = list(map(int, input().split()))\n\nmons = []\n\nfor i in range(n):\n    x, h = list(map(int, input().split()))\n    mons.append((x, h))\n\nmons = sorted(mons)\n\nq = deque()\n\ndm_sum = 0\n\nans = 0\n\nfor i in range(n):\n    while dm_sum > 0:\n        if q[0][0] < mons[i][0]:\n            cur = q.popleft()\n            dm_sum -= cur[1]\n        else:\n            break\n    if mons[i][1] <= dm_sum:\n        continue\n    rem = mons[i][1] - dm_sum\n    at_num = rem // a\n    if rem % a != 0:\n        at_num += 1\n    ans += at_num\n\n    q.append((mons[i][0] + 2 * d, at_num*a))\n    dm_sum += at_num*a\n\nprint(ans)\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, d, a = list(map(int, input().split()))\n    XH = sorted([list(map(int, input().split())) for _ in range(n)], key=lambda x: x[0])\n\n    que = deque()\n    total = 0\n    res = 0\n    for i in range(n):\n        x, h = XH[i]\n        while que and que[0][0] < x:\n            total -= que[0][1]\n            que.popleft()\n        h -= total\n\n        if h > 0:\n            num = (h + a - 1) // a\n            res += num\n            damage = num * a\n            total += damage\n            que.append([x + d * 2, damage])\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\n\nn, d, a = map(int, input().split())\nxh = sorted([list(map(int, input().split())) for _ in range(n)])\n\nans = 0\ndam_sum = 0\nq = deque()\nfor i, (x, h) in enumerate(xh):\n    while q and q[0][0] < x:\n        ran, dam = q.popleft()\n        dam_sum -= dam\n    h -= dam_sum\n    if h <= 0:\n        continue \n    c = -(-h//a)\n    ans += c\n    dam_sum += c*a\n    q.append((x+d*2, c*a))\nprint(ans)", "from math import * \nfrom collections import *\n\nN, D, A = list(map(int, input().split()))\nans = 0\nt = 0\nq = deque()\n\nXH = sorted([list(map(int, input().split())) for i in range(N)])\n\nfor x, h in XH:\n    if q:\n        while q and q[0][0] < (x-D):\n            _, c = q.popleft()\n            t -= c\n    \n    h = h - t * A\n    if h <= 0: continue\n    \n    x += D\n    c = ceil(h/A)\n    t += c\n    ans += c\n    q.append((x, c))\n    \nprint(ans)", "xh=[]\nn,d,a=list(map(int,input().split()))\nfor _ in range(n):\n\tx,h=list(map(int,input().split()))\n\txh.append([x,h])\nxh.sort()\nans=0\ncnt=[0]*n\nj=0\nlimit=[]\nfor i in range(n):\n\twhile xh[j][0]-xh[i][0]<=2*d:\n\t\tj+=1\n\t\tif j==n:\n\t\t\tbreak\n\tj-=1\n\tlimit.append(j)\nnum=[0]*(n+1)\ncnt=0\nfor i in range(n):\n\txh[i][1]-=(ans-cnt)*a\n\tdamage_cnt=max(0,(xh[i][1]-1)//a+1)\n\tans+=damage_cnt\n\tnum[limit[i]]+=damage_cnt\n\tcnt+=num[i]\nprint(ans)\n", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef main():\n    n, d, a = ns()\n    x = []\n    for _ in range(n):\n        xi, hi = ns()\n        x.append([xi, hi])\n\n    x.sort()\n    x.append([INF, INF])\n\n    perm = [0 for _ in range(n + 1)]\n    idx = [xi for xi, hi in x]\n\n    ans = 0\n    cnt = 0\n    for i in range(n):\n        cnt -= perm[i]\n\n        if x[i][1] - cnt * a > 0:\n            tmp = ((x[i][1] - cnt * a) + a - 1) // a\n        else:\n            tmp = 0\n        ans += tmp\n        cnt += tmp\n\n        if cnt > 0:\n            tmp_idx = bisect.bisect_right(idx, x[i][0] + 2 * d)\n            perm[tmp_idx] += tmp\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, D, A = MAP()\nXH = [LIST() for _ in range(N)]\nXH.sort(key=lambda x:x[0])\nX, H = list(zip(*XH))\nright = [0]*N\nfor i, x in enumerate(X):\n\tright[i] = bisect(X, x+2*D)\n\ndamage = [0]*(N+1)\nans = 0\nfor i, (X, H) in enumerate(XH):\n\tif i != 0:\n\t\tdamage[i] += damage[i-1]\n\tH -= damage[i]\n\tif H > 0:  # \u8ffd\u52a0\u653b\u6483\u304c\u5fc5\u8981\n\t\tn = -(-H//A)\n\t\tans += n\n\t\td = A*n\n\t\tdamage[i] += d\n\t\tdamage[right[i]] -= d  # \u7bc4\u56f2\u5916\u306e\u6575\nprint(ans)\n", "import bisect\n\nN,D,A = map(int,input().split())\n\nmonsters = []\nfor i in range(N):\n    X, H =map(int,input().split())\n    monsters.append([X,H])\n\nmonsters = sorted(monsters)\n\nid = 0\nans = 0\n\ndamage = [0 for i in range(N)]\n\nwhile id < N:\n    if id > 0: damage[id] += damage[id-1]\n    nowX, nowH = monsters[id][0], monsters[id][1]\n    nowH -= damage[id]\n\n    if nowH > 0:\n        damage[id] += A * ((nowH + A - 1) // A)\n\n        right = bisect.bisect_left(monsters, [nowX+2*D+1,0])\n        if right < N:\n            damage[right] -= A * ((nowH + A - 1) // A)\n\n        ans += (nowH + A -1) // A\n\n    id += 1\n\nprint(ans)", "N,D,A = list(map(int,input().split()))\nenemies = [list(map(int,input().split())) for _ in range(N)]\nenemies.sort(key=lambda x:x[0])\nans = 0\nfrom collections import deque\ndamage = deque()\ndmg = 0\nfor x,h in enemies:\n    if len(damage) == 0:\n        bomb = -(-h//A)\n        damage.append([x+2*D,bomb])\n        dmg += bomb*A\n        ans += bomb\n    else:\n        while len(damage) > 0:\n            d,bomb = damage.popleft()\n            if x > d:\n                dmg -= bomb*A\n            else:\n                damage.appendleft([d,bomb])\n                break\n        if h > dmg:\n            bomb = -(-(h-dmg)//A)\n            dmg += bomb*A\n            damage.append([x+2*D,bomb])\n            ans += bomb\n\nprint(ans)\n", "def binary(N, LIST, num):  # \u4e8c\u5206\u63a2\u7d22 # N:\u63a2\u7d22\u8981\u7d20\u6570\n    l, r = -1, N\n    while r - l > 1:\n        if LIST[(l + r) // 2] > num:  # \u6761\u4ef6\u5f0f\u3092\u4ee3\u5165\n            r = (l + r) // 2\n        else:\n            l = (l + r) // 2\n    return r + 1\n\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [i for i, j in xh]\nh = [j for i, j in xh]\n\nbomb, bsum, ans = [0] * (n + 1), [0] * (n + 1), 0\nfor i in range(n):\n    j = binary(n, x, x[i] + 2 * d) - 1\n    bsum[i] += bsum[i - 1] + bomb[i]\n    bnum = max((h[i] + a - 1) // a - bsum[i], 0)\n    bomb[i] += bnum\n    bomb[j] -= bnum\n    bsum[i] += bnum\n    ans += bnum\nprint(ans)\n", "#!/usr/bin/env python3\n\nfrom math import ceil\nimport heapq\n\ndef main():\n    n, d, a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        x, h = list(map(int, input().split()))\n        heapq.heappush(q, (x, -ceil(h / a)))\n    bomb = 0\n    res = 0\n    while q:\n        x, h = heapq.heappop(q)\n        if h < 0:\n            h *= -1\n            if h > bomb:\n                heapq.heappush(q, (x + 2 * d, h - bomb))\n                res += h - bomb\n                bomb = h\n        else:\n            bomb -= h\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom bisect import bisect\ndef main():\n    n,d,a=map(int,input().split())\n    XH=[list(map(int,input().split())) for i in range(n)]\n    XH.sort()\n    X,H=zip(*XH)\n    right=[0]*n\n    for i,x in enumerate(X):\n        right[i]=bisect(X,x+2*d)\n    damage=[0]*(n+1)\n    ans=0\n    for i,(x,h) in enumerate(XH):\n        if i!=0:\n            damage[i]+=damage[i-1]\n        h-=damage[i]\n        if h>0:\n            cunt=-(-h//a)\n            ans+=cunt\n            damage[i]+=a*cunt\n            damage[right[i]]-=a*cunt\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, D, A = map(int, input().split())\nX = [0] * N\nfor i in range(N):\n    x, h = map(int, input().split())\n    X[i] = (x, h)\nX = sorted(X)\n\nfrom collections import deque\n\nq = deque()\n\nans = 0\ntotal = 0\nfor i in range(N):\n    x, h = X[i]\n    while (len(q) > 0 and q[0][0] < x):\n        total -= q[0][1] \n        q.popleft()\n    h -= total\n    if h > 0:\n        num = (h + A - 1) // A\n        ans += num\n        damage = num * A\n        total += damage\n        q.append((x + 2 * D, damage))\nprint(ans)", "N,D,A=map(int, input().split())\nB=[list(map(int, input().split())) for _ in range(N)]\nC=sorted(B)\nd,E=zip(*C)\nimport bisect\nDamage=[0]*N\nfor i in range(N):\n  e=bisect.bisect_right(d,d[i]+2*D)\n  Damage[i]=e\ndd=[0]*(N+1)\ncnt=0\nfor i in range(N):\n  if i!=0:\n    dd[i]+=dd[i-1]\n  h=E[i]\n  h-=dd[i]\n  if h>0:\n    bomb=-(-h//A)\n    cnt+=bomb\n    dd[i]+=A*bomb\n    dd[Damage[i]]-=A*bomb\nprint(cnt)", "from bisect import bisect_right\n\n\ndef ceil(x, y):\n    return (x + y - 1) // y\n\n\ndef main():\n    n, d, a = list(map(int, input().split()))\n    info = [list(map(int, input().split())) for _ in range(n)]\n    info.sort(key=lambda x: x[0])\n    x = [x[0] for x in info]\n    idx = {}\n    for xx in x:\n        idx[xx] = bisect_right(x, xx + d * 2)\n    delta = [0] * n\n    ans = 0\n    for i in range(n):\n        if i > 0:\n            delta[i] += delta[i - 1]\n        info[i][1] -= delta[i]\n        now = max(ceil(info[i][1], a), 0)\n        delta[i] += now * a\n        if idx[info[i][0]] < n:\n            delta[idx[info[i][0]]] -= now * a\n        ans += now\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\nn, d, a = list(map(int, input().split()))\nfox = [list(map(int, input().split())) for _ in range(n)]\n\nfox.sort()\n\nsub = [0]*(n+1)\n\ndef bisect(x):\n    l, r = 0, n\n    while r-l > 1:\n        k = (r+l)//2\n        if fox[k][0] <= x:\n            l = k\n        else:\n            r = k\n    if fox[l][0] <= x:\n        return l\n    return r\n\n\ndef main():\n    ans = 0\n    \n    for i in range(n):\n        if i != 0:\n            sub[i] += sub[i-1]\n        if fox[i][1]-a*sub[i] <= 0:\n            continue\n        count = (fox[i][1]-sub[i]*a-1)//a+1\n        ans += count\n        sub[i] += count\n        sub[bisect(fox[i][0]+2*d)+1] -= count\n\n    print(ans)\n\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom bisect import bisect_right\n\nn, d, a = map(int, input().split())\nx_list = []\nmax_x = 0\nfor _ in range(n):\n    x, h = map(int, input().split())\n    x -= 1\n    x_list.append([x, h])\n    max_x = max(max_x, x)\nx_list.sort()\nxx = [x[0] for x in x_list]\nhh = [x[1] for x in x_list]\nans = 0\naccum = [0 for _ in range(n)]\nfor index, [x, h] in enumerate(x_list):\n    if index != 0:\n        accum[index] += accum[index - 1]\n    cnt = max(math.ceil((hh[index] - accum[index]) / a),  0)\n    ans += cnt\n    index_right = bisect_right(xx, xx[index] + (2 * d))\n    accum[index] += cnt * a\n    if index_right < n:\n        accum[index_right] -= cnt * a\nprint(ans)", "#!/usr/bin/env python3\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\n\ndef main():\n    N, D, A = list(map(int, input().split()))\n    XH = [None] * N\n    X = [None] * N\n\n    for i in range(N):\n        XH[i] = tuple(map(int, input().split()))\n        X[i] = XH[i][0]\n\n    XH.sort()\n    X.sort()\n    \n    ans = 0\n    S = [0] * (N+1)# \u4e0e\u3048\u305f\u30c0\u30e1\u30fc\u30b8\n    for i in range(N):\n        if S[i] < XH[i][1]:\n            # \u3042\u3068\u4f55\u56de\u653b\u6483\u3059\u308b\uff1f\n            need = (XH[i][1]-S[i]+A-1)//A\n            # \u7206\u5f3e\u304c\u5c4a\u304f\u7bc4\u56f2\n            j = bisect_right(X,X[i]+2*D)\n            # imos\u6cd5\n            S[i] += need*A\n            S[j] -= need*A\n            ans += need\n        S[i+1] += S[i]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\ndef resolve():\n    N, D, A = map(int, input().split())\n    AB = [list(map(int, input().split())) for _ in range(N)]\n    AB.sort()\n\n    # imos\n    imos = [0] * (N+1)\n    ans = 0\n    R = 0\n    for l in range(N):\n        if l:\n            imos[l] += imos[l - 1]\n        x = AB[l][0]\n        h = AB[l][1]\n        if imos[l] < h:\n            R = max(R, l + 1)\n            while R < N and AB[R][0] <= 2 * D + x:\n                R += 1\n            d = h - imos[l]\n            cnt = -(-d//A) # \u5207\u308a\u4e0a\u3052\n            imos[l] += cnt * A\n            imos[R] -= cnt * A\n            ans += cnt\n    print(ans)\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import bisect\ndef main():\n    N,D,A=map(int,input().split())\n    XH=[list(map(int,input().split())) for _ in range(N)]\n    XH.sort()\n    for i in range(N):\n        XH[i][1]=-(-XH[i][1]//A)\n    X=[x for x,a in XH]\n    far=[0]*N\n    for i in range(N):\n        far[i]=bisect.bisect_right(X,X[i]+2*D)-1\n\n    ans=0\n    carry=0\n    outrange=[0]*(N+1)\n    for i in range(N):\n        x=XH[i][0]\n        hp=XH[i][1]\n        carry-=outrange[i]\n        if carry>=hp:\n            continue\n        outrange[bisect.bisect_right(X,X[i]+2*D)]+=hp-carry\n        ans+=hp-carry\n        carry+=hp-carry\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nN, D, A = map(int, input().split())\nmonster = []\nfor k in range(N):\n  monster.append(list(map(int, input().split())))\nmonster.sort(key = lambda x: x[0])\nfor k in range(N):\n  monster[k][1] = int((monster[k][1]-0.1)//A + 1)\nans = 0\nmonster = deque(monster)\nfinal = monster[-1][0]\nruiseki = 0\nminuslist = deque()\n\nwhile len(monster) > 0:\n  while len(minuslist) > 0:\n    if monster[0][0] >= minuslist[0][0]:\n      ruiseki -= minuslist[0][1]\n      minuslist.popleft()\n    else:\n      break\n  if ruiseki < monster[0][1]:\n    ans += monster[0][1] - ruiseki\n    if monster[0][0] + 2*D +1 <= final:\n      minuslist.append([monster[0][0]+2*D+1, monster[0][1] - ruiseki])\n    ruiseki = monster[0][1]\n  monster.popleft()\n\nprint(ans)", "from collections import deque\nfrom math import ceil\n\nn,d,a = map(int,input().split())\nM = [list(map(int,input().split())) for i in range(n)]\nM = [[x,ceil(h/a)] for x,h in M]\nM = sorted(M)\n\nque = deque()\n\nans = 0\natack = 0\nfor x,h in M:\n  while len(que) > 0 and que[0][0] < x:\n    tx,ta = que.popleft()\n    atack -= ta      \n  \n  bomb_num = max(0, h-atack)\n  atack += bomb_num\n  ans += bomb_num\n  \n  if bomb_num > 0:\n    que.append([x+d*2,bomb_num])\n\nprint(ans)  ", "import math\n\nI = lambda: list(map(int, input().split()))\nn, d, a = I()\nl = []\nfor _ in range(n):\n\tx, y = I()\n\tl.append([x,y])\nl.sort()\n\nj = 0\nlimit = []\nfor i in range(n):\n\twhile l[j][0] - l[i][0] <= 2*d:\n\t\tj+=1\n\t\tif j == n: break\n\tj-=1\n\tlimit.append(j)\n\nans = 0\nnum=[0]*(n+1)\ncnt=0\nfor i in range(n):\n\tl[i][1]-=(ans-cnt)*a\n\tdamage_cnt=max(0,(l[i][1]-1)//a + 1)\n\tans+=damage_cnt\n\tnum[limit[i]]+=damage_cnt\n\tcnt+=num[i]\nprint(ans)", "from bisect import *\ndef solve():\n  ans = 0\n  N, D, A = list(map(int, input().split()))\n  B = [list(map(int, input().split())) for _ in range(N)]\n  B.sort()\n  lasts = [0]*(N+1)\n  now = 0\n  for i,((x,h),l) in enumerate(zip(B,lasts)):\n    now -= l\n    atack = max(0,-(-(h-now)//A))\n    ans += atack\n    damage = atack*A\n    now += damage\n    last = x+2*D\n    ind = bisect_right(B,[last+1,0])\n    lasts[ind] += damage\n  return ans\nprint((solve()))\n", "def binary(N, LIST, num):  # \u4e8c\u5206\u63a2\u7d22 # N:\u63a2\u7d22\u8981\u7d20\u6570\n    l, r = -1, N\n    while r - l > 1:\n        if LIST[(l + r) // 2] > num:  # \u6761\u4ef6\u5f0f\u3092\u4ee3\u5165\n            r = (l + r) // 2\n        else:\n            l = (l + r) // 2\n    return r + 1\n\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [i for i, j in xh]\nh = [(j + a - 1) // a for i, j in xh]\n\nbomb, bsum, ans = [0] * (n + 1), [0] * (n + 1), 0\nfor i in range(n):\n    j = binary(n, x, x[i] + 2 * d) - 1\n    bsum[i] += bsum[i - 1] + bomb[i]\n    bnum = max(h[i] - bsum[i], 0)\n    bomb[i] += bnum\n    bomb[j] -= bnum\n    bsum[i] += bnum\n    ans += bnum\nprint(ans)\n", "from collections import deque\nimport math\n\nN, D, A = list(map(int, input().split()))\nXH = [list(map(int, input().split())) for _ in range(N)]\nXH.sort(key=lambda x: x[0])\n\n# \u7206\u767a\u7bc4\u56f2\u304c\u3068\u3066\u3082\u5e83\u304f\u3001\u5168\u3066\u306e\u7206\u767a\u304c\u53f3\u7aef\u307e\u3067\u53ca\u3076\u3068\u3072\u3068\u307e\u305a\u8003\u3048\u308b\n# \u5404x\u3092\u898b\u308b\u969b\u306b\u3001\u5f71\u97ff\u306e\u53ca\u3070\u306a\u3044\u7206\u767a\u5206\u306e\u30c0\u30e1\u30fc\u30b8\u306f\u5f15\u304f\n\n# \u5408\u8a08\u306e\u7206\u767a\u56de\u6570\nans = 0\n# \u7206\u767a\u30c0\u30e1\u30fc\u30b8\u306e\u5408\u8a08\ntotal_damage = 0\n# \u5404\u7206\u767a\u306e\u60c5\u5831\ndq = deque()\n\n# \u5de6\u7aef\u304b\u3089\u9806\u306b\u30e2\u30f3\u30b9\u30bf\u30fc\u3092\u898b\u308b\nfor x, h in XH:\n    # \u7206\u767a\u304c\u53ca\u3070\u306a\u3044\u5834\u5408\n    while dq and dq[0][1] < x:\n        dmg, rng = dq.popleft()\n        total_damage -= dmg\n\n    # \u7206\u767a\u3055\u305b\u308b\u5fc5\u8981\u304c\u3042\u308b\u5834\u5408\n    if total_damage < h:\n        # \u6b8b\u3063\u3066\u3044\u308bHP\u306b\u66f4\u65b0\n        h -= total_damage\n        # \u5fc5\u8981\u306a\u7206\u767a\u56de\u6570\n        cnt = math.ceil(h / A)\n        ans += cnt\n        # \u7206\u767a\u56de\u6570 * \u5358\u767a\u306e\u30c0\u30e1\u30fc\u30b8\n        dmg = cnt * A\n        total_damage += dmg\n        # [\u7206\u767a\u3067\u4e0e\u3048\u308b\u30c0\u30e1\u30fc\u30b8\u3001\u53ca\u3076\u7bc4\u56f2\u306e\u53f3\u7aef]\n        dq.append((dmg, x + D * 2))\n\nprint(ans)\n", "import math\nimport sys\nfrom collections import deque\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nsys.setrecursionlimit(20000000)\n\nMOD = 10 ** 9 + 7\nINF = float(\"inf\")\n\n\ndef main():\n    N, D, A = list(map(int, input().split()))\n    monster = [list(map(int, input().split())) for _ in range(N)]\n\n    monster.sort(key=lambda x: x[0])\n\n    attack = []\n    for i in range(N):\n        attack.append(math.ceil(monster[i][1] / A))\n\n    acc_damage = 0\n    attacked = deque([])\n    answer = 0\n\n    for i in range(N):\n        x = monster[i][0]\n        h = attack[i]\n\n        while attacked and x > attacked[0][0]:\n            limit, damage = attacked.popleft()\n            acc_damage -= damage\n\n        need = max(0, h - acc_damage)\n        answer += need\n\n        acc_damage += need\n\n        if need:\n            attacked.append((x + 2 * D, need))\n\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nimport operator\nimport collections\nimport sys\ninput = sys.stdin.readline\n\n\nclass RAQ():\n    \n    def __init__(self, size):\n        \"\"\"\u521d\u671f\u5316\"\"\"\n        self.size = size\n        self.sub = [0 for i in range(size + 1)]\n        self.r = 0\n        self.v = 0\n    \n    @classmethod\n    def from_array(cls, a):\n        st = cls(len(a))\n        for i, x in enumerate(a):\n            st.add(i, i+1, x)\n        return st\n\n    def add(self, a, b, value):\n        \"\"\"\u533a\u9593[a, b) \u306b\u5bfe\u3059\u308b\u52a0\u7b97\"\"\"\n        if a > b:\n            raise ValueError(\"a must be less than equal b.\")\n        self.sub[a] += value\n        self.sub[b] -= value\n\n    def get(self, key):\n        \"\"\"\u5024\u306e\u53d6\u5f97\"\"\"\n        if key < self.r - 1:\n            self.r = 0\n            self.v = 0\n        for i in range(self.r, key):\n            self.v += self.sub[i]\n        self.r = key\n        return self.v + self.sub[key]\n\n\ndef read():\n    N, D, A = list(map(int, input().strip().split()))\n    XH = list()\n    for i in range(N):\n        x, h = list(map(int, input().strip().split()))\n        XH.append((x, h))\n    return N, D, A, XH\n\n\ndef solve(N, D, A, XH):\n    XH = sorted(XH)\n    X = [x for x, h in XH]\n    H = [h for x, h in XH]\n\n    st = RAQ.from_array(H)\n\n    ans = 0\n    i = 0\n    while i < N:\n        x = XH[i][0]\n        h = st.get(i)\n        c = h // A + (h % A > 0)\n        ans += c\n        v = c * A\n        lidx = bisect.bisect_left(X, x)\n        ridx = bisect.bisect_left(X, x + 2 * D + 1)\n        st.add(lidx, ridx, -v)\n        m = -1\n        i += 1\n        while i < N:\n            h = st.get(i)\n            if h > 0:\n                break\n            i += 1\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"%s\" % solve(*inputs)))\n\n__starting_point()", "def binary(N, LIST, num):  # \u4e8c\u5206\u63a2\u7d22 # N:\u63a2\u7d22\u8981\u7d20\u6570\n    l, r = -1, N\n    while r - l > 1:\n        if LIST[(l + r) // 2] > num:  # \u6761\u4ef6\u5f0f\u3092\u4ee3\u5165\n            r = (l + r) // 2\n        else:\n            l = (l + r) // 2\n    return r + 1\n\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [i for i, j in xh]\nh = [(j + a - 1) // a for i, j in xh]\n\nbomb, bsum, ans = [0] * (n + 1), [0] * (n + 1), 0\nfor i in range(n):\n    j = binary(n, x, x[i] + 2 * d) - 1\n    bnum = max(h[i] - (bsum[i - 1] + bomb[i]), 0)\n    bomb[i] += bnum\n    bomb[j] -= bnum\n    bsum[i] += bsum[i - 1] + bomb[i]\n    ans += bnum\nprint(ans)\n", "from collections import deque\nN, D, A = list(map(int, input().split()))\npair_xh = [[-1, -1] for _ in range(N)] # 1\u56de\u305a\u3064\u3057\u304b\u4f7f\u308f\u306a\u3044\u3051\u3069\u30bd\u30fc\u30c8\u3059\u308b\u304b\u3089\u5fc5\u8981\nfor i in range(N):\n    pair_xh[i][0], pair_xh[i][1] = list(map(int, input().split()))\npair_xh.sort(key = lambda x: x[0]) #\u5ea7\u6a19\u3067\u30bd\u30fc\u30c8\n\nq_lim_d = deque() # \u7d2f\u7a4d\u548c\u306b\u542b\u307e\u308c\u308b\u653b\u6483\u7bc4\u56f2\u3068\u30c0\u30e1\u30fc\u30b8\u3092\u4fdd\u5b58\u3059\u308b\u5834\u6240\ntotal = 0 # \u55b0\u3089\u3044\u30c0\u30e1\u30fc\u30b8\u306e\u7d2f\u7a4d\u548c\ncount = 0 # \u653b\u6483\u56de\u6570\nfor i in range(N):\n    x = pair_xh[i][0]\n    h = pair_xh[i][1]\n    \n    while len(q_lim_d) and q_lim_d[-1][0] < x: # \u7bc4\u56f2\u5916\u306b\u306a\u3063\u305f\u3089\u55b0\u3089\u308f\u306a\u3044\u304b\u3089\u7d2f\u7a4d\u548c\u304b\u3089\u5916\u3059\n        total -= q_lim_d[-1][1]\n        q_lim_d.pop()\n    h -= total\n    if h > 0: # \u898b\u3066\u308b\u6575\u306e\u4f53\u529b\u304c0\u306b\u306a\u308b\u653b\u6483\u56de\u6570\u3092\u6c42\u3081\u305d\u306e\u5206\u3092\u7d2f\u7a4d\u548c\u306b\u8db3\u3059\n        times = (h + A - 1) // A # 0\u306b\u3059\u308b\u306e\u306b\u5fc5\u8981\u306a\u56de\u6570(\u5207\u308a\u4e0a\u3052)\n        count += times\n        damage = A * times\n        total += damage\n        q_lim_d.appendleft([x + 2 * D, damage])\nprint(count)", "import sys, heapq\ninput = sys.stdin.readline\nN, D, A = [int(_) for _ in input().split()]\nXH = [[int(_) for _ in input().split()] for _ in range(N)]\nHe = [[2 * x, h, 0] for x, h in XH]\nheapq.heapify(He)\nnow = 0\nans = 0\nwhile He:\n    x, h, t = heapq.heappop(He)\n    if t:\n        now -= h\n    else:\n        if h - A * now > 0:\n            diff = (h - A * now - 1) // A + 1\n            now += diff\n            ans += diff\n            heapq.heappush(He, [x + 4 * D + 1, diff, 1])\nprint(ans)\n", "import bisect\nimport operator\nimport collections\n\n\nclass RAQ():\n    \n    def __init__(self, size):\n        \"\"\"\u521d\u671f\u5316\"\"\"\n        self.size = size\n        self.sub = [0 for i in range(size + 1)]\n        self.r = 0\n        self.v = 0\n    \n    @classmethod\n    def from_array(cls, a):\n        st = cls(len(a))\n        for i, x in enumerate(a):\n            st.add(i, i+1, x)\n        return st\n\n    def add(self, a, b, value):\n        \"\"\"\u533a\u9593[a, b) \u306b\u5bfe\u3059\u308b\u52a0\u7b97\"\"\"\n        if a > b:\n            raise ValueError(\"a must be less than equal b.\")\n        self.sub[a] += value\n        self.sub[b] -= value\n\n    def get(self, key):\n        \"\"\"\u5024\u306e\u53d6\u5f97\"\"\"\n        if key < self.r - 1:\n            self.r = 0\n            self.v = 0\n        for i in range(self.r, key):\n            self.v += self.sub[i]\n        self.r = key\n        return self.v + self.sub[key]\n\n\ndef read():\n    N, D, A = list(map(int, input().strip().split()))\n    XH = list()\n    for i in range(N):\n        x, h = list(map(int, input().strip().split()))\n        XH.append((x, h))\n    return N, D, A, XH\n\n\ndef solve(N, D, A, XH):\n    XH = sorted(XH)\n    X = [x for x, h in XH]\n    H = [h for x, h in XH]\n\n    st = RAQ.from_array(H)\n\n    ans = 0\n    i = 0\n    while i < N:\n        x = XH[i][0]\n        h = st.get(i)\n        c = h // A + (h % A > 0)\n        ans += c\n        v = c * A\n        lidx = bisect.bisect_left(X, x)\n        ridx = bisect.bisect_left(X, x + 2 * D + 1)\n        st.add(lidx, ridx, -v)\n        m = -1\n        i += 1\n        while i < N:\n            h = st.get(i)\n            if h > 0:\n                break\n            i += 1\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"%s\" % solve(*inputs)))\n\n__starting_point()", "from math import ceil\n\n\ndef binary(N, LIST, num):  # \u4e8c\u5206\u63a2\u7d22 # N:\u63a2\u7d22\u8981\u7d20\u6570\n    l, r = -1, N\n    while r - l > 1:\n        if LIST[(l + r) // 2] > num:  # \u6761\u4ef6\u5f0f\u3092\u4ee3\u5165\n            r = (l + r) // 2\n        else:\n            l = (l + r) // 2\n    return r + 1\n\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [i for i, j in xh]\nh = [j for i, j in xh]\n\nbomb, bsum, ans = [0] * (n + 1), [0] * (n + 1), 0\nfor i in range(n):\n    j = binary(n, x, x[i] + 2 * d) - 1\n    bsum[i] += bsum[i - 1] + bomb[i]\n    bnum = max(ceil(h[i] / a - bsum[i]), 0)\n    bomb[i] += bnum\n    bomb[j] -= bnum\n    bsum[i] += bnum\n    ans += bnum\nprint(ans)\n", "from bisect import bisect\nfrom collections import defaultdict\n\nN, D, A = map(int, input().split())\nXH = []\n\nfor _ in range(N):\n  X, H = map(int, input().split())\n  XH.append((X, -(-H//A)))\n\nXH.sort()\nXs = [ xh[0] for xh in XH ]\nHP = [ xh[1] for xh in XH ]\n\nXR = []\nfor x in Xs:\n  XR.append(bisect(Xs, x+2*D))\n\ncnt = 0\ntemp = 0\nD = defaultdict(int)\n\nfor i in range(N):\n  temp -= D[i]\n  HP[i] -= temp\n  if HP[i] > 0:\n    temp += HP[i]\n    cnt += HP[i]\n    D[XR[i]] += HP[i]\n    HP[i] -= temp\n\nprint(cnt)", "from itertools import accumulate\nimport math\nimport bisect\n\nn,d,a = map(int,input().split())\nxh = [tuple(map(int,input().split())) for _ in range(n)]\nxh.sort()\nx = [xh[i][0] for i in range(n)]\nh = [xh[i][1] for i in range(n)]\ndamage = [0]*(n+1)\npoint = 0\n\nfor i in range(n):\n    if i != 0:\n        damage[i] += damage[i-1]\n    bi = bisect.bisect(x,2*d+x[i])\n    count = max(math.ceil((h[i]-damage[i])/a),0)\n    damage[i] += a*count\n    damage[bi] -= a*count\n    point += count\n    \nprint(point)", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N, D, A = list(map(int, input().split()))\n    monster = {}\n    X = []\n    for _ in range(N):\n        x, h = list(map(int, input().split()))\n        monster[x] = h\n        X.append(x)\n\n    X.sort()\n\n    # x, damage\n    q = deque([])\n\n    acc_damage = 0\n\n    ans = 0\n    for i in range(N):\n        x = X[i]\n        h = monster[x]\n\n        while q and q[0][0] < x:\n            p, damage = q.popleft()\n            acc_damage -= damage\n\n        if h - acc_damage <= 0:\n            continue\n\n        cnt = (h - acc_damage + A - 1) // A\n        ans += cnt\n        acc_damage += cnt * A\n\n        q.append((x + 2 * D, cnt * A))\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nfrom collections import deque\n\nn, d, a = list(map(int, input().split()))\nxh = [list(map(int, input().split())) for _ in range(n)]\nxh.sort(key=lambda x:x[0])\nxh = deque(xh)\n\nxh_field = deque()\n\ncnt = 0\nnow_damage = 0\nwhile xh:\n    pos, hp = xh.popleft()\n    if xh_field:\n        while (xh_field and xh_field[0][0] < pos) :\n            now_damage -= a * xh_field[0][1]\n            xh_field.popleft() \n    if hp <= now_damage:\n        pass\n    elif hp > now_damage:\n        atk_cnt = math.ceil((hp - now_damage) / a)\n        cnt += atk_cnt\n        now_damage += atk_cnt * a\n        xh_field.append((2*d + pos, atk_cnt))        \nprint(cnt)\n", "from collections import deque\nn, d, a = map(int, input().split())\n\nhit = []\n\nfor i in range(n):\n  x, h = map(int,input().split())\n  hit.append([x,h])\nhit.sort()\n\nque = []\nans = 0\nbomb = 0\nfor i in range(n):\n  while True:\n    if len(que) == 0:\n      break\n    if hit[i][0] <= que[0][0]:\n      break\n    bomb -= que[0][1]\n    que.pop(0)\n  r = hit[i][1] - bomb\n  if r < 0:\n    continue\n  c = (r + a - 1)//a\n  ans += c\n  bomb += c*a\n  que.append((hit[i][0]+2*d,c*a))\nprint (ans)", "#!/usr/bin/env python3\n\nfrom math import ceil\nimport heapq\n\ndef main():\n    n, d, a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        x, h = list(map(int, input().split()))\n        heapq.heappush(q, (x, 0, ceil(h / a)))\n    bomb = 0\n    res = 0\n    while q:\n        x, ty, h = heapq.heappop(q)\n        if ty == 0:\n            if h > bomb:\n                heapq.heappush(q, (x + 2 * d, 1, h - bomb))\n                res += h - bomb\n                bomb = h\n        else:\n            bomb -= h\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, D, A = list(map(int, input().split()))\nmonster = []\nfor k in range(N):\n  monster.append(list(map(int, input().split())))\nmonster.sort(key = lambda x: x[0])\nfor k in range(N):\n  monster[k][1] = int((monster[k][1]-0.1)//A + 1)\nans = 0\n\nfinal = monster[-1][0]\nruiseki = 0\nminuslist = []\nj = 0\nfor k in range(N):\n  while (j < len(minuslist)):\n    if monster[k][0] >= minuslist[j][0]:\n      ruiseki -= minuslist[j][1]\n      j += 1\n    else:\n      break\n  if ruiseki < monster[k][1]:\n    ans += monster[k][1] - ruiseki\n    if monster[k][0] + 2*D +1 <= final:\n      minuslist.append([monster[k][0]+2*D+1, monster[k][1] - ruiseki])\n    ruiseki = monster[k][1]\n\n\nprint(ans)\n", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, d, a = list(map(int, input().split()))\n    XH = sorted([list(map(int, input().split())) for _ in range(n)])\n\n    res = 0\n    tt_dmg = 0\n    que = deque()\n    for x, h in XH:\n        while que and que[0][1] < x:\n            dmg, rng = que.popleft()\n            tt_dmg -= dmg\n\n        if tt_dmg < h:\n            h -= tt_dmg\n            cnt = (h + a - 1) // a\n            res += cnt\n            dmg = cnt * a\n            tt_dmg += dmg\n            que.append((dmg, x + d * 2))\n\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "\ndef resolve():\n    N, D, A = list(map(int, input().split()))\n    AB = [list(map(int, input().split())) for _ in range(N)]\n    AB.sort()\n\n    # imos\n    imos = [0] * (N+1)\n    ans = 0\n    R = 0\n    for l in range(N):\n        if l:\n            imos[l] += imos[l - 1]\n        x = AB[l][0]\n        h = AB[l][1]\n        if imos[l] < h:\n            R = max(R, l + 1)\n            while R < N and AB[R][0] <= 2 * D + x:\n                R += 1\n            d = h - imos[l]\n            cnt = (d+A-1) // A\n            imos[l] += cnt * A\n            imos[R] -= cnt * A\n            ans += cnt\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, D, A = list(map(int, input().split()))\n    mlist = []\n    for _ in range(N):\n        x, h = list(map(int, input().split()))\n        mlist.append([x, (h+A-1)//A])\n    mlist.sort(key=lambda x: x[0])\n    db = deque()\n    dnotb = deque()\n    left = mlist[0][0]\n    ans = 0\n    for monster in mlist:\n        if monster[0] <= left+2*D:\n            db.append(monster)\n        else:\n            dnotb.append(monster)\n    ans = 0\n    while db or dnotb:\n        if not db:\n            monster = dnotb.popleft()\n            monster[1] += ans\n            db.append(monster)\n        bmonster = db.popleft()\n        while dnotb:\n            if dnotb[0][0] <= bmonster[0]+2*D:\n                monster = dnotb.popleft()\n                monster[1] += ans\n                db.append(monster)\n            else:\n                break\n        ans = max(ans, bmonster[1])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#problems2\n#silver fox vs monster\nimport math\nN,D,A=map(int,input().split())\nd=[]\nfor _ in range(N):\n    x,h=map(int,input().split())\n    d.append((x,h))\nd.sort(key=lambda x:x[0])\n\nnow_damage=0\nfrom collections import deque\nd=deque(d)\nans=0\nd_field=deque()\nwhile d:\n    x=d.popleft()\n    place,life=x\n    if d_field:\n        while (d_field and d_field[0][0]<place) :\n            now_damage-=A*d_field[0][1]\n            d_field.popleft()      \n    if life<=now_damage:\n        pass\n    elif life>now_damage:\n        K=math.ceil((life-now_damage)/A)\n        ans+=K\n        now_damage+=K*A\n        d_field.append((2*D+place,K))        \nprint(ans)", "from collections import deque\nimport math\n\nN, D, A = list(map(int, input().split()))\nXH = [list(map(int, input().split())) for _ in range(N)]\nXH.sort(key=lambda x: x[0])\n\n# \u7206\u767a\u7bc4\u56f2\u304c\u3068\u3066\u3082\u5e83\u304f\u3001\u5168\u3066\u306e\u7206\u767a\u304c\u53f3\u7aef\u307e\u3067\u53ca\u3076\u3068\u3072\u3068\u307e\u305a\u8003\u3048\u308b\n# \u5404x\u3092\u898b\u308b\u969b\u306b\u3001\u5f71\u97ff\u306e\u53ca\u3070\u306a\u3044\u7206\u767a\u5206\u306e\u30c0\u30e1\u30fc\u30b8\u306f\u5f15\u304f\n\n# \u5408\u8a08\u306e\u7206\u767a\u56de\u6570\nans = 0\n# \u7206\u767a\u30c0\u30e1\u30fc\u30b8\u306e\u5408\u8a08\ntotal_damage = 0\n# \u5404\u7206\u767a\u306e\u60c5\u5831\ndq = deque()\n\n# \u5de6\u7aef\u304b\u3089\u9806\u306b\u30e2\u30f3\u30b9\u30bf\u30fc\u3092\u898b\u308b\nfor x, h in XH:\n    # \u7206\u767a\u304c\u53ca\u3070\u306a\u3044\u5834\u5408\n    while dq and dq[0][1] < x:\n        dmg, rng = dq.popleft()\n        total_damage -= dmg\n\n    # \u7206\u767a\u3055\u305b\u308b\u5fc5\u8981\u304c\u3042\u308b\u5834\u5408\n    if total_damage < h:\n        # \u6b8b\u3063\u3066\u3044\u308bHP\u306b\u66f4\u65b0\n        h -= total_damage\n        # \u5fc5\u8981\u306a\u7206\u767a\u56de\u6570\n        # cnt = math.ceil(h // A)\n        cnt = (h + A - 1) // A\n        ans += cnt\n        # \u7206\u767a\u56de\u6570 * \u5358\u767a\u306e\u30c0\u30e1\u30fc\u30b8\n        dmg = cnt * A\n        total_damage += dmg\n        # [\u7206\u767a\u3067\u4e0e\u3048\u308b\u30c0\u30e1\u30fc\u30b8\u3001\u53ca\u3076\u7bc4\u56f2\u306e\u53f3\u7aef]\n        dq.append((dmg, x + D * 2))\n\nprint(ans)\n", "from collections import deque\nimport math\n\nimport sys\ninput = sys.stdin.readline\n\nN, D, A = list(map(int, input().split()))\nS = [0]*N\natack = deque()\nfor i in range(N):\n    x, h = list(map(int, input().split()))\n    S[i] = [x, h]\n\nS.sort()\ncnt = 0\ndmg = 0\nfor i in range(N):\n    while atack:\n        if atack[0][0] < S[i][0]:\n            x, d = atack.popleft()\n            dmg -= d\n        else:\n            break\n\n    if S[i][1] <= dmg:\n        continue\n    bomb = math.ceil((S[i][1]-dmg)/A)\n    atack.append([S[i][0]+2*D, A*bomb])\n    cnt += bomb\n    dmg += A*bomb\n\nprint(cnt)\n", "# \u89e3\u8aac\u653e\u9001\u306e\u65b9\u91dd\n# \u30c0\u30e1\u30fc\u30b8\u304c\u6d88\u3048\u308b\u53f3\u7aef\u3092\u30ad\u30e5\u30fc\u3067\u7ba1\u7406\n# \u53f3\u7aef\u3092\u8d85\u3048\u305f\u5206\u306f\u3001\u7d2f\u7a4d\u30c0\u30e1\u30fc\u30b8\u304b\u3089\u5f15\u3044\u3066\u3044\u304f\n\nfrom collections import deque\n\nN,D,A=map(int,input().split())\nXH = [tuple(map(int,input().split())) for _ in range(N)]\n\nXH = sorted(XH)\nque=deque()\ncum = 0\nans = 0\nfor i in range(N):\n  x,h = XH[i]\n  if i == 0:\n    r,n = x+2*D,(h+A-1)//A\n    d = n*A\n    cum += d\n    que.append((r,d))\n    ans += n\n    continue\n  while que and que[0][0]<x:\n    r,d = que.popleft()\n    cum -= d\n  h -= cum\n  if h<0:\n    continue\n  r,n = x+2*D,(h+A-1)//A\n  d = n*A\n  cum += d\n  que.append((r,d))\n  ans += n\n  \nprint(ans)", "from bisect import bisect_right\n\nn, d, a = list(map(int, input().split()))\nxh = sorted(list(map(int, input().split())) for _ in range(n))\nx = [0] * (n + 1)\nh = [0] * (n + 1)\ns = [0] * (n + 1)\n\nfor i, (f, g) in enumerate(xh):\n    x[i], h[i] = f, g\nx[n] = 10 ** 10 + 1\nans = 0\nfor i in range(n):\n    if i > 0:\n        s[i] += s[i - 1]\n    h[i] -= s[i]\n    if h[i] > 0:\n        num = 0 - - h[i] // a\n        ans += num\n        s[i] += num * a\n\n        j = bisect_right(x, x[i] + d * 2)\n        s[j] -= num * a\nprint(ans)\n", "from bisect import bisect_left, bisect_right\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    def makeBIT(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        data = [0] * (numPow2+1)\n        return data, numPow2\n    def setInit(As):\n        for iB, A in enumerate(As, 1):\n            data[iB] = A\n        for iB in range(1, numPow2):\n            i = iB + (iB & -iB)\n            data[iB] -= data[i]\n    def addValue(iA, A):\n        iB = iA + 1\n        while iB > 0:\n            data[iB] += A\n            iB -= iB & -iB\n    def getValue(iA):\n        iB = iA + 1\n        ans = 0\n        while iB <= numPow2:\n            ans += data[iB]\n            iB += iB & -iB\n        return ans\n\n\n    N, D, A = list(map(int, input().split()))\n    XHs = [tuple(map(int, input().split())) for _ in range(N)]\n\n    XHs.sort()\n    Xs, Hs = [], []\n    for X, H in XHs:\n        Xs.append(X)\n        Hs.append(H)\n\n    data, numPow2 = makeBIT(N)\n    setInit(Hs)\n\n    ans = 0\n    for i in range(N):\n        rest = getValue(i)\n        if rest <= 0: continue\n        pos = Xs[i] + D\n        iR = bisect_right(Xs, pos + D) - 1\n        num = -(-rest // A)\n        ans += num\n        damage = num*A\n        addValue(iR, -damage)\n\n    print(ans)\n\n\nsolve()\n", "n, d, a = map(int, input().split())\nxh = []\nfor _ in range(n):\n    x, h = map(int, input().split())\n    h = (h - 1) // a + 1\n    xh.append([x, h])\nxh.sort()\ndamage = xh[0][1]\nans = damage\ndamage_lst = [[xh[0][0] + d * 2, damage]]\npos = 0\nfor i, (x, h) in enumerate(xh[1:], start = 1):\n    while x > damage_lst[pos][0]:\n        damage -= damage_lst[pos][1]\n        pos += 1\n        if pos == i:\n            break\n    damage_tmp = max(h - damage, 0)\n    ans += damage_tmp\n    damage += damage_tmp\n    damage_lst.append([x + d * 2, damage_tmp])\nprint(ans)", "N,D,A = map(int,input().split())\nXH = [list(map(int,input().split())) for i in range(N)]\nXH.sort()\nfrom math import ceil\ntimes = ceil(XH[0][1]/A)\nans = times\ndamege = [times*A]\ncoor = [XH[0][0]+2*D]\nstart = 0\nend = 1\ndam = sum(damege[start:end])\nfor i in range(1,N):\n    st = start\n    while start < end and coor[start] < XH[i][0]:\n        start += 1\n    dam -= sum(damege[st:start])\n    H = XH[i][1] - dam\n    if H > 0:\n        times = ceil(H/A)\n        ans += times\n        damege.append(times*A)\n        dam += times*A\n        coor.append(XH[i][0]+2*D)\n        end += 1\nprint(ans)", "from collections import deque\nimport sys \ninput = sys.stdin.readline\nN, D, A = list(map(int, input().split()))\nxh = [list(map(int, input().split())) for _ in range(N)]\nxh = sorted(xh)\ntotal = 0 # \u4eca\u4e0e\u3048\u3066\u3044\u308b\u30c0\u30e1\u30fc\u30b8\u306e\u7dcf\u548c\nD = 2*D\nans = 0\nq = deque()\nfor i in range(N):\n  x, h = xh[i]\n  # \u4eca\u3044\u308b\u5834\u6240\u304c\u524d\u56de\u307e\u3067\u306e\u7206\u6483\u306e\u7bc4\u56f2\u5916\u306b\u306a\u308b\u306a\u3089\u305d\u306e\u5206total\u304b\u3089\u5f15\u304f\n  while len(q) >= 1 and q[0][0] < x:\n    total -= q.popleft()[1]\n  h -= total\n\n  if h > 0:\n    num = (h-1)//A+1\n    ans += num\n    damage = num*A\n    total += damage\n    q += ([[x+D, damage]])\n\nprint(ans)\n", "from sys import stdin\nfrom collections import deque\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,d,a=map(int,readline().split())\n    xh=[list(map(int,readline().split())) for _ in range(n)]\n    xh.sort()\n    x=[0]*n\n    h=[0]*n\n    for i in range(n):\n        x[i],h[i]=xh[i][0],xh[i][1]\n\n    dq=deque()\n    now=0\n    cnt=0\n    for i in range(n):\n        if i==0:\n            cnt+=(h[i]+a-1)//a\n            now+=(h[i]+a-1)//a*a\n            dq.append([x[i]+2*d,now])\n        else:\n            while len(dq)!=0 and dq[0][0]<x[i]:\n                tmp=dq.popleft()\n                now-=tmp[1]\n            if h[i]<=now:\n                pass\n            else:\n                dq.append([x[i]+2*d,(h[i]-now+a-1)//a*a])\n                cnt+=(h[i]-now+a-1)//a\n                now+=(h[i]-now+a-1)//a*a\n\n    print(cnt)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nfrom math import ceil\n\n# n\u4e2a\u602a\u7269\uff0cd\u6740\u4f24\u534a\u5f84\uff0ca\u6740\u4f24\u503c\nn, d, a = list(map(int,input().split()))\n\nms = [list(map(int, input().split())) for i in range(n)]\nms = sorted([(pos, ceil(hp / a)) for pos, hp in ms])\n \nbombs = deque()\n \nans = 0\nvalid_bomb = 0\nfor pos, hp in ms:\n  # \u67e5\u770b\u961f\u5217\u91cc\u7684bomb\u662f\u5426\u5bf9\u5f53\u524d\u602a\u7269\u6709\u6548\n  while bombs and bombs[0][0] < pos:\n    bomb_border, bomb_cnt = bombs.popleft()\n    valid_bomb -= bomb_cnt\n  \n  # \u8fd8\u9700\u65b0\u52a0\u591a\u5c11bomb\u624d\u80fd\u706d\u6389\u5f53\u524d\u602a\u7269\n  bomb_cnt = max(0, hp - valid_bomb)\n  valid_bomb += bomb_cnt\n  ans += bomb_cnt\n  \n  # \u65b0\u52a0\u7684bomb\u653e\u5165\u961f\u5217\n  if bomb_cnt > 0:\n    bombs.append([pos + d * 2, bomb_cnt])\n \nprint(ans)  \n", "from heapq import heappush, heappop\n\nn, d, a = list(map(int, input().split()))\nactions = []\nfor _ in range(n):\n    x, h = list(map(int, input().split()))\n    heappush(actions, (x, 0, (h + a - 1) // a))\ncnt = 0\nbomb = 0\ncurrent_bomb = 0\nwhile cnt < n:\n    a, c, b = heappop(actions)\n    if c:\n        current_bomb -= b\n        continue\n    else:\n        HP = b\n        if HP <= current_bomb:\n            cnt += 1\n            continue\n        else:\n            HP -= current_bomb\n            cnt += 1\n            current_bomb += HP\n            bomb += HP\n            heappush(actions, (a + 2 * d, 1, HP))\nprint(bomb)\n", "# \u89e3\u8aac\u653e\u9001\n# \u89e3\u8aacPDF\u306f\u300c\u52b9\u679c\u7bc4\u56f2\u304c\u3069\u306e\u30e2\u30f3\u30b9\u30bf\u30fc\u304b\u300d\u3092\u4e8b\u524d\u306b\u6c42\u3081\u3066\u3044\u308b\u304c\u3001\n# \u89e3\u8aac\u653e\u9001\u3067\u306f\u30ad\u30e5\u30fc\u3092\u4f7f\u3046\u3053\u3068\u3067\u300c\u52b9\u679c\u7bc4\u56f2\u304c\u3069\u306e\u30e2\u30f3\u30b9\u30bf\u30fc\u304b\u300d\u3092\u6c42\u3081\u305a\u3001\u5ea7\u6a19\u306e\u307f\u3067\u3046\u307e\u304f\u51e6\u7406\u3057\u3066\u3044\u308b\n# \u89e3\u8aac\u653e\u9001\u3060\u3068BIT\u3092\u4f7f\u3063\u305f\u89e3\u6cd5\u3082\u3042\u308b\n\n# \u8caa\u6b32\u306e\u65b9\u91dd\u306f\u898b\u3048\u3084\u3059\u3044\u3002\u305d\u3053\u304b\u30892\u3064\u306e\u96e3\u984c\u304c\u3042\u308b\n# (1) \u52b9\u679c\u7bc4\u56f2\u3002\u5358\u7d14\u306b\u8abf\u3079\u308b\u3068O(N^2)\n# \u2192 \u4e8c\u5206\u63a2\u7d22\u3001\u5c3a\u53d6\u308a\u6cd5\uff08\u4e8b\u524d\u306b\u5168\u8a08\u7b97\u3067\u3082\u9010\u6b21\u51e6\u7406\u3068\u540c\u6642\u306b\u8a08\u7b97\u3067\u3082\u826f\u3044\uff09\n# (2) HP\u306e\u6e1b\u7b97\u3002\u591a\u6570\u306e\u8981\u7d20\u306b\u5bfe\u3057\u3066A\u3092\u5f15\u304f\u5fc5\u8981\u304c\u3042\u308a\u3001\u6700\u60aaO(N^2)\n# \u2192\u4e00\u5b9a\u7bc4\u56f2\u306b-A\u3059\u308b\u306e\u306f\u6642\u9593\u304c\u304b\u304b\u308b\u3051\u3069\u3001\u6700\u521d\u306b-A\u3057\u3066\u6700\u5f8c\u306b+A\u3059\u308c\u30702\u8981\u7d20\u3092\u5909\u3048\u308b\u3060\u3051\u3067\u6e08\u3080\u306d\uff08imos\u6cd5\uff09\n\nn, d, a = list(map(int, input().split()))\nenemies = [list(map(int, input().split())) for _ in range(n)]\n\nenemies.sort(key= lambda a: a[0])  # \u5ea7\u6a19\u3092\u57fa\u6e96\u306b\u30bd\u30fc\u30c8\n\nd *= 2\ntotal_damage = 0\n\nimport collections\nq = collections.deque()\n\nans = 0\nfor i in range(n):\n    x = enemies[i][0]\n    hp = enemies[i][1]\n\n    while (len(q) and q[0][0] < x):\n        total_damage -= q[0][1]\n        q.popleft()\n    \n    hp -= total_damage\n    if hp > 0:\n        times = (hp+a-1) // a\n        total_damage += a * times\n        ans += times\n\n        q.append((x+d, a*times))\n\nprint(ans)", "import bisect\nimport sys\n\ndef main():\n  input = sys.stdin.readline\n  n, d, a = map(int, input().split())\n  fox = [None]*n\n  for i in range(n):\n    x, h = map(int, input().split())\n    fox[i] = (x, h)\n\n  fox.sort()\n  x = [int(fox[i][0]) for i in range(n)]\n  h = [int(fox[i][1]) for i in range(n)]\n\n  ans = 0\n  bit = [0]*n\n  for i in range(n):\n    if i != 0:\n      bit[i] += bit[i-1]\n    sub = max([(h[i]-bit[i]-1)//a+1, 0])\n    ans += sub\n    bit[i] += sub*a\n    index = bisect.bisect_right(x, x[i]+2*d)\n    if index != n:\n      bit[index] -= sub*a\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "import bisect\nn, d, a = map(int, input().split())\nfox = [None]*n\nfor i in range(n):\n  x, h = map(int, input().split())\n  fox[i] = (x, h)\n\nfox.sort()\nx = [int(fox[i][0]) for i in range(n)]\nh = [int(fox[i][1]) for i in range(n)]\n\nans = 0\nbit = [0]*n\nfor i in range(n):\n  if i != 0:\n    bit[i] += bit[i-1]\n  if bit[i] >= h[i]:\n    continue\n  sub = (h[i]-bit[i]-1)//a+1\n  ans += sub\n  bit[i] += sub*a\n  index = bisect.bisect_right(x, x[i]+2*d)\n  if index == n:\n    continue\n  bit[index] -= sub*a\nprint(ans)", "n,d,a=map(int,input().split())\nd=d*2\nM=sorted([list(map(int,input().split())) for i in range(n)])\nl=0\nA=[0]*n\nB=[0]\nans=0\nfor i in range(n):\n  while M[l][0]+d<M[i][0]:\n    l=l+1\n  ans=ans+max(0,(M[i][1]-B[i]+B[l]+a-1)//a)\n  A[i]=max(0,(M[i][1]-B[i]+B[l]+a-1)//a)*a\n  B.append(B[-1]+A[i])\nprint(ans)", "#!/usr/bin/env python3\n\nfrom math import ceil\nimport heapq\n\ndef main():\n    n, d, a = list(map(int, input().split()))\n    q = []\n    for i in range(n):\n        x, h = list(map(int, input().split()))\n        heapq.heappush(q, (x, -(h // a + (1 if (h % a) else 0))))\n    bomb = 0\n    res = 0\n    while q:\n        x, h = heapq.heappop(q)\n        if h < 0:\n            h *= -1\n            if h > bomb:\n                heapq.heappush(q, (x + 2 * d, h - bomb))\n                res += h - bomb\n                bomb = h\n        else:\n            bomb -= h\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, D, A = map(int, input().split())\n\nMonster = [0]*N\nfor i in range(N):\n    Monster[i] = list(map(int, input().split()))\n\nMonster.sort(key=lambda x:x[0])\n\nfrom bisect import bisect_left, bisect_right, bisect, insort_left, insort_right, insort\n\nfrom collections import deque\n\nd = deque()\ndamage = 0\nans = 0\nfor i in range(N):\n    while len(d)>0:\n        a = d.popleft()\n        if a[0]==i:\n            damage -= a[1]\n        else:\n            d.appendleft(a)\n            break\n    Monster[i][1] -= damage\n    count = -(-max(Monster[i][1],0)//A)\n    ans += count\n    right = Monster[i][0]+2*D\n    ind = bisect(Monster,[right,10**9+1])\n    damage += A*count\n    d.append([ind,A*count])\nprint(ans)"]
["class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         length = len(triangle)\n         for i in range(length - 1, 0, -1):\n             for j in range(1, len(triangle[i])):\n                 if triangle[i][j] < triangle[i][j-1]:\n                     triangle[i-1][j-1] += triangle[i][j]\n                 else:\n                     triangle[i-1][j-1] += triangle[i][j - 1]\n         return triangle[0][0]", "class Solution:\n     \"\"\"\n     def minmum(self, triangle, i, j):\n         if (i + 1) == len(triangle):\n             return triangle[i][j]\n         return min(self.minmum(triangle, i+1, j), self.minmum(triangle, i+1, j+1)) + triangle[i][j]\n     \"\"\"\n     \n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         #return self.minmum(triangle, 0, 0)\n         \n         rows = len(triangle)\n         minPath = triangle[rows-1]\n         for i in range(rows-1)[::-1]:\n             for j in range(i+1):\n                 minPath[j] = min(minPath[j], minPath[j+1]) + triangle[i][j]\n         return minPath[0]\n         \n", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         for i in range(1,len(triangle)):\n             for j in range(i+1):\n                 if j == 0:\n                     triangle[i][j] += triangle[i-1][0]\n                 elif j == i:\n                     triangle[i][j] += triangle[i-1][-1]\n                 else:\n                     triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j])\n         return min(triangle[-1])\n", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \n         for i in range(1,len(triangle)):\n             triangle[i][0] = triangle[i][0] + triangle[i-1][0]\n             triangle[i][-1] = triangle[i][-1] + triangle[i-1][-1]\n             for j in range(1,len(triangle[i])-1):\n                 triangle[i][j] = min(triangle[i-1][j-1], triangle[i-1][j]) + triangle[i][j]\n                 \n         return min(triangle[-1])", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         length = len(triangle)\n         dp = []\n         for i in range(length):\n             dp.append([])\n             for j in range(len(triangle[i])):\n                 dp[i].append(float('inf'))\n         dp[0][0] = triangle[0][0]\n         for i in range(1, length):\n             dp[i][0] = dp[i-1][0] + triangle[i][0]\n             dp[i][-1] = dp[i-1][-1] + triangle[i][-1]\n         \n         for i in range(1, length):\n             for j in range(1, len(triangle[i]) - 1):\n                 dp[i][j] = min(dp[i][j], dp[i-1][j] + triangle[i][j], dp[i-1][j-1] + triangle[i][j])\n         return min(dp[length-1])", "class Solution:\n     def minimumTotal(self, triangle):\n         mini = 100000000\n         level =0 \n         while level < (len(triangle)-1):\n             for i in range(len(triangle[level+1])):\n                 if i==0 :\n                     triangle[level+1][i] += triangle[level][i]\n                 elif i == len(triangle[level]):\n                     triangle[level+1][i] += triangle[level][i-1]\n                 else :\n                     triangle[level+1][i] += min(triangle[level][i-1], triangle[level][i])\n                     \n             level +=1\n         \n         return  min(triangle[len(triangle)-1])\n             \n         \n \n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     '''\n     def minimumTotal(self, triangle):\n         cost = [[0 for j in range(len(i))] for i in triangle]\n         for row in range(len(triangle)):\n             for col in range(len(triangle[row])):\n                 if row == 0:\n                     cost[row][col] = triangle[row][col]\n                 else:\n                     if col-1 >= 0 and col < len(triangle[row-1]):\n                         cost[row][col] = min(cost[row-1][col-1]+triangle[row][col],cost[row-1][col]+triangle[row][col])\n                     elif col-1 >= 0:\n                         cost[row][col] = cost[row-1][col-1]+triangle[row][col]\n                     elif col < len(triangle[row-1]):\n                         cost[row][col] = cost[row-1][col]+triangle[row][col]\n         return min(cost[len(triangle)-1])\n     '''\n     #O(n) extra space:\n     def minimumTotal(self, triangle):\n         cost = [[0 for j in range(len(triangle))] for i in range(2)]\n         for row in range(len(triangle)):\n             for col in range(len(triangle[row])):\n                 if row == 0:\n                     cost[row][col] = triangle[row][col]\n                 else:\n                     if col-1 >= 0 and col < len(triangle[row-1]):\n                         cost[row%2][col] = min(cost[(row-1)%2][col-1]+triangle[row][col],cost[(row-1)%2][col]+triangle[row][col])\n                     elif col-1 >= 0:\n                         cost[row%2][col] = cost[(row-1)%2][col-1]+triangle[row][col]\n                     elif col < len(triangle[row-1]):\n                         cost[row%2][col] = cost[(row-1)%2][col]+triangle[row][col]\n         return min(cost[(len(triangle)-1)%2])", "class Solution:\n     def nodeSum(self, L, U):\n         ans = [0]*len(U)\n         for i,v in enumerate(U):\n             ans[i] = (v+min(L[i],L[i+1]))\n         return ans\n     \n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         L = triangle[-1]\n         for i in range(len(triangle)-1, 0, -1):\n             L=self.nodeSum(L, triangle[i-1])\n         return L[0]", "class Solution:\n     def minimumTotal(self, triangle):\n         row = [triangle[0][0]]\n         for i in range(1, len(triangle)):\n             new_row = []\n             for j in range(len(row)+1):\n                 new_row.append(triangle[i][j]+min(row[j-1] if j-1>=0 else sys.maxsize, row[j] if j<len(row) else sys.maxsize))\n             row = new_row\n         return min(row)\n", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         res = [0]\n         for row in triangle:\n             res = [row[i]+min([res[j] for j in (i-1, i) if 0<=j<len(res)]) for i in range(len(row))]\n         return min(res)\n", "class Solution:\n     def minimumTotal(self, triangle):\n         import math\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         cost = {(-1, -1): math.inf, (-1,0):0, (-1, 1):math.inf}\n         for i in range(len(triangle)):\n             cost[(i, -1)] = math.inf\n             cost[i, len(triangle[i])] = math.inf\n \n         for i in range(len(triangle)):\n             for j in range(len(triangle[i])):\n                 cost[(i, j)] = triangle[i][j] + min(cost[(i-1, j)], cost[(i-1, j-1)])\n                 \n         return min([cost[(len(triangle)-1, j)] for j in range(len(triangle[-1]))])", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         layer_costs = triangle[-1]\n         \n         for layer in range(len(triangle)-2, -1, -1): # range(start, end +- 1, step)\n             for pos in range(len(triangle[layer])):\n                 min_cost = min(layer_costs[pos], layer_costs[pos+1]) + triangle[layer][pos]\n                 layer_costs[pos] = min_cost\n         \n         return(layer_costs[0])", "class Solution:\n         \n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         memory = []\n         for i in range(len(triangle)):\n             memory.append({})\n         \n         return self.helper(memory, triangle, 0, 0) \n \n     def helper(self, memory, triangle, i, j):\n         if i >= len(triangle):\n             return 0 \n         \n         if memory[i].get(j) is None:\n             memory[i][j] = triangle[i][j] + \\\n                            min(self.helper(memory, triangle, i+1, j), self.helper(memory, triangle, i+1, j+1))\n             \n         return memory[i][j]", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         \"\"\"\n         For each position (column) C within a row R,\n         the minimum path sum that leads to (r, c) is defined as:\n         min_path_sum[r][c] = min(min_path_sum[r-1][adj] for adj in adjacent columns of (r,c)) + triangle[r][c]\n         \"\"\"\n         \n         if not triangle or not triangle[0]:\n             return 0\n         \n         min_path_sum = [[0] * len(triangle) for row in range(len(triangle))]\n         min_path_sum[0][0] = triangle[0][0]\n         \n         ROWS = len(triangle)\n         \n         \n         def get_valid_adjacents_of(row, col):\n             if col == 0:\n                 return [(row - 1, col)]\n             if col == row:\n                 return [(row - 1, col - 1)]\n             return [(row - 1, col - 1), (row - 1, col)]\n         \n         for row in range(1, ROWS):\n             for col in range(0, row + 1):\n                 adjacents = get_valid_adjacents_of(row, col)\n                 min_path_sum[row][col] = triangle[row][col] + min(min_path_sum[r][c] for r, c in adjacents)\n         \n         return min(min_path_sum[-1])", "class Solution:\n     def minimumTotal(self, triangle):\n         \"\"\"\n         :type triangle: List[List[int]]\n         :rtype: int\n         \"\"\"\n         if not triangle:\n             return 0\n         \n         dp = triangle.pop()\n         \n         while triangle:\n             level = triangle.pop()\n             \n             for i in range(len(level)):\n                 dp[i] = min(dp[i], dp[i + 1]) + level[i]\n                     \n         return dp[0]", "class Solution:\n \tdef minimumTotal(self, triangle):\n \t\tself._min_cache = {} \n \t\tfor i in reversed(list(range(len(triangle)))):\n \t\t\tfor j in reversed(list(range(len(triangle[i])))):\n \t\t\t\tself.get_minimum_sum(triangle, i, j)\n \t\treturn self.get_minimum_sum(triangle, 0, 0)\n \n \tdef get_minimum_sum(self, triangle, level_i, item_j):\n \t\tif ((level_i, item_j) in self._min_cache):\n \t\t\treturn self._min_cache[(level_i, item_j)]\n \t\tif level_i < 0 or level_i >= len(triangle):\n \t\t\treturn 0\n \t\tlevel = triangle[level_i]\n \n \t\tif item_j<0 or item_j>len(level):\n \t\t\treturn 0\n \n \t\titem = level[item_j]\n \n \t\tmin_v = item+min(self.get_minimum_sum(triangle,level_i+1,item_j),\n \t\t\t\t\t    self.get_minimum_sum(triangle,level_i+1,item_j+1))\n \t\tself._min_cache[(level_i, item_j)] = min_v\n \n \t\treturn min_v\n \n"]
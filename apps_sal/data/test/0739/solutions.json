["import copy\nimport sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nL,A,B,mod = na()\n\nlow = 1\nhigh = 10\n\n\ndef matpow(M, v, e, mod):\n    A = copy.deepcopy(M)\n    w = copy.deepcopy(v)\n    while e > 0:\n        if e&1:\n            w = mulv(A, w, mod)\n        A = mul(A, A, mod)\n        e >>= 1\n    return w\n\n\ndef mulv(M, v, mod):\n    n = len(M)\n    m = len(v)\n    ret = [0] * n\n    for i in range(n):\n        s = 0\n        for j in range(m):\n            s += M[i][j] * v[j]\n        ret[i] = s % mod\n    return ret\n\n\ndef mul(A, B, mod):\n    n = len(A)\n    m = len(B)\n    o = len(B[0])\n    ret = [[0] * o for _ in range(n)]\n    for i in range(n):\n        for j in range(o):\n            s = 0\n            for k in range(m):\n                s += A[i][k] * B[k][j]\n            ret[i][j] = s % mod\n    return ret\n\n\n# x = x * high + val\n# val += B\n# (high 1 0)\n# (0 1 1)\n# (0 0 1)\n\nv = [0, A, B]\nra = A\n\nwhile low < 1e18:\n    mat = [[high%mod, 1, 0], [0, 1, 1], [0, 0, 1]]\n    step = max(0, min(L, (high-ra+B-1)//B))\n    v = matpow(mat, v, step, mod)\n    # print(low, high, step, ra + B*step, v)\n    ra = ra + B * step\n    L -= step\n\n    low *= 10\n    high *= 10\n\nprint((v[0]))\n", "l, a, b, m = [int(i) for i in input().split()]\n\ncd = []\nfor i in range(18):\n    cd.append(max(0, (10 ** (i + 1) - 1 - a) // b + 1))\n    if cd[-1] >= l:\n        cd[-1] = l\n        break\n\ncd_sum = 0\ncd_2 = []\n\nfor i in cd:\n    cd_2.append(i-cd_sum)\n    cd_sum += i-cd_sum\n\nX = [0, a, 1]\nB = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\nfor i in range(len(cd_2)):\n    A = [[(10 ** (i + 1)), 0, 0], [1, 1, 0], [0, b, 1]]\n    B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\n    n = cd_2[i]\n    while n > 0:\n        if n % 2 == 1:\n            B = [[(B[0][0] * A[0][0] + B[0][1] * A[1][0] + B[0][2] * A[2][0]) % m,\n                  (B[0][0] * A[0][1] + B[0][1] * A[1][1] + B[0][2] * A[2][1]) % m,\n                  (B[0][0] * A[0][2] + B[0][1] * A[1][2] + B[0][2] * A[2][2]) % m],\n                 [(B[1][0] * A[0][0] + B[1][1] * A[1][0] + B[1][2] * A[2][0]) % m,\n                  (B[1][0] * A[0][1] + B[1][1] * A[1][1] + B[1][2] * A[2][1]) % m,\n                  (B[1][0] * A[0][2] + B[1][1] * A[1][2] + B[1][2] * A[2][2]) % m],\n                  [(B[2][0] * A[0][0] + B[2][1] * A[1][0] + B[2][2] * A[2][0]) % m,\n                   (B[2][0] * A[0][1] + B[2][1] * A[1][1] + B[2][2] * A[2][1]) % m,\n                   (B[2][0] * A[0][2] + B[2][1] * A[1][2] + B[2][2] * A[2][2]) % m]]\n\n            n -= 1\n\n        else:\n            A = [[(A[0][0] * A[0][0] + A[0][1] * A[1][0] + A[0][2] * A[2][0]) % m,\n                  (A[0][0] * A[0][1] + A[0][1] * A[1][1] + A[0][2] * A[2][1]) % m,\n                  (A[0][0] * A[0][2] + A[0][1] * A[1][2] + A[0][2] * A[2][2]) % m],\n                 [(A[1][0] * A[0][0] + A[1][1] * A[1][0] + A[1][2] * A[2][0]) % m,\n                  (A[1][0] * A[0][1] + A[1][1] * A[1][1] + A[1][2] * A[2][1]) % m,\n                  (A[1][0] * A[0][2] + A[1][1] * A[1][2] + A[1][2] * A[2][2]) % m],\n                  [(A[2][0] * A[0][0] + A[2][1] * A[1][0] + A[2][2] * A[2][0]) % m,\n                   (A[2][0] * A[0][1] + A[2][1] * A[1][1] + A[2][2] * A[2][1]) % m,\n                   (A[2][0] * A[0][2] + A[2][1] * A[1][2] + A[2][2] * A[2][2]) % m]]\n            n //= 2\n\n    X[0] = (X[0] * B[0][0] + X[1] * B[1][0] + X[2] * B[2][0]) % m\n    X[1] = (X[0] * B[0][1] + X[1] * B[1][1] + X[2] * B[2][1]) % m\n    X[2] = (X[0] * B[0][2] + X[1] * B[1][2] + X[2] * B[2][2]) % m\n\nprint((X[0] % m))\n", "import sys\n\n\ndef dot(A, B, mod):\n    r = len(A)\n    c = len(B[0])\n    m = len(A[0])\n    res = [[0] * c for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            for k in range(m):\n                res[i][j] += A[i][k] * B[k][j] % mod\n                res[i][j] %= mod\n    return res\n\n\ndef rec_pow(k, n, mod):\n    if n == 1:\n        return k\n\n    k2 = dot(k, k, mod)\n    if n % 2 == 0:\n        return rec_pow(k2, n//2, mod)\n    else:\n        return dot(rec_pow(k2, n//2, mod), k, mod)\n\n\ndef main():\n    input = sys.stdin.readline\n    L, A, B, M = list(map(int, input().split()))\n\n    s = [[0, A%M, 1]]\n    for d in range(1, 19):\n        n1 = min(max(0, (10**d - 1 - A) // B + 1), L)\n        n0 = min(max(0, (10**(d-1) - 1 - A) // B + 1), L)\n        n = n1 - n0\n        if n == 0:\n            continue\n\n        k = [[pow(10, d, M), 0, 0],\\\n             [1, 1, 0],\\\n             [0, B%M, 1]]\n        s = dot(s, rec_pow(k, n, M), M)\n\n        if n1 >= L:\n            break\n\n    return s[0][0]\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "def mat_dot(one, two, mod):\n\treturn [[sum([(one[i][k]*two[k][j])%mod for k in range(len(two))])%mod for j in range(len(two[0]))] for i in range(len(one))]\n\ndef mat_pow(mat, exp, mod):\n\tsize = len(mat)\n\tres = [[0 for _ in range(size)] for _ in range(size)]\n\tfor i in range(size):\n\t\tres[i][i] = 1\n\tcnt = 0\n\twhile (1<<cnt) <= exp:\n\t\tif (exp>>cnt)&1:\n\t\t\tres = mat_dot(res, mat, mod)\n\t\tmat = mat_dot(mat, mat, mod)\n\t\tcnt += 1\n\treturn res\n\nl, a, b, m = map(int, input().split())\nc = a + (l-1)*b\nn = len(str(c))\ndgt = [0 for _ in range(n+1)]\nfor i in range(1, n):\n\tdgt[i] = max(0, (10**i -a+b-1) // b) - max(0, (10**(i-1) -a+b-1) // b)\ndgt[n] = l-sum(dgt)\nd_sum = [0 for _ in range(n+1)]\nfor i in range(n-1, 0, -1):\n\td_sum[i] = d_sum[i+1] + dgt[i+1]*(i+1)\nfr = [0 for _ in range(n+1)]\nfr[1] = a\nfor i in range(2, n+1):\n\tfr[i] = fr[i-1] + b*dgt[i-1]\nl = [[0, a%m, 1]]\nfor d in range(1, n+1):\n\tk = [[(10**d)%m, 0, 0], [1, 1, 0], [0, b%m, 1]]\n\tj = mat_pow(k, dgt[d], m)\n\tl = mat_dot(l, j, m)\n\nprint(l[0][0]%m)", "def f_takahashi_basics_in_education_and_learning(L, A, B, M, DIGIT_MAX=18):\n    import numpy\n\n    # https://github.com/numpy/numpy/blob/master/numpy/linalg/linalg.py L560\u304b\u3089\n    def matrix_power(a, n):\n        a = numpy.core.asanyarray(a)\n        fmatmul = numpy.core.dot\n\n        z = result = None\n        while n > 0:\n            z = a % M if z is None else fmatmul(z, z) % M\n            n, bit = divmod(n, 2)\n            if bit:\n                result = z if result is None else fmatmul(result, z) % M\n        return result\n\n    # \u6570\u5217\u306b\u5bfe\u3057\u3066\u3001d\u6841\u306e\u8981\u7d20\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\n    num_pow_d = [0] * (DIGIT_MAX + 1)\n    for d in range(DIGIT_MAX + 1):\n        if 10**d - 1 >= A:\n            # d\u306b\u5bfe\u3057\u3066A + B*n <= 10**d - 1 \u3068\u306a\u308b\u6700\u5927\u306en(L\u4ee5\u4e0b\u3057\u304b\u53d6\u308a\u3048\u306a\u3044)\n            num_pow_d[d] = min(((10**d - 1 - A) // B) + 1, L)  # +1\u306fn\u304c0\u30b9\u30bf\u30fc\u30c8\u306e\u305f\u3081\n\n    ans = numpy.array([0, A, 1])\n    for d in range(1, DIGIT_MAX + 1):\n        c_d = num_pow_d[d] - num_pow_d[d - 1]\n        matrix = numpy.array([[(10**d) % M, 0, 0], [1, 1, 0], [0, B, 1]], dtype='object')\n        m = numpy.eye(3, dtype='object') if c_d == 0 else matrix_power(matrix, c_d)\n        ans = ans.dot(m) % M\n    return ans[0]\n\nL, A, B, M = [int(i) for i in input().split()]\nprint(f_takahashi_basics_in_education_and_learning(L, A, B, M))", "import sys\nimport itertools\nimport queue\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n# mod = 10 ** 9 + 7\n\ndef read_values(): return list(map(int, input().split()))\ndef read_index(): return [int(x) - 1 for x in input().split()]\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n \n    def __str__(self):\n        return str(self.v)\n \n    def ud(self, n):\n        if self.v is None:\n            self.v = n\n        else:\n            self.v = self.f(self.v, n) \n\n\ndef mat_mul(X, Y, mod):\n    m = len(X)\n    return [[sum(X[i][k] * Y[k][j] % mod for k in range(m)) % mod for j in range(m)] for i in range(m)]\n\n\ndef mat_pow(M, k, mod):\n    m = len(M)\n    res = [[1 if i == j else 0 for j in range(m)] for i in range(m)]\n    while k > 0:\n        if k & 1:\n            res = mat_mul(M, res, mod)\n        M = mat_mul(M, M, mod)\n        k >>= 1\n\n    return res\n\n\ndef main():\n    L, A, B, M = read_values()\n    res = 0\n    D = [(0, 0)]\n    for d in range(1, 20):\n        l = D[-1][1]\n        r = max(0, min((10 ** d - 1 - A) // B + 1, L))\n        D.append((l, r))\n    \n    res = 0\n    c = 0\n    R = [0, A, 1]\n    Mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for d in range(1, 20):\n        num = D[d][1] - D[d][0]\n\n        MM = [[10 ** d, 0, 0], [1, 1, 0], [0, B, 1]]\n        Mat = mat_mul(Mat, mat_pow(MM, num, M), M)\n\n    X = sum(R[i] * Mat[i][0] % M for i in range(3)) % M\n\n    print(X)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "l,a,b,m = map(int,input().split())\n\n# c111 -> 1001001001\u307f\u305f\u3044\u306a\u3084\u3064\u3092\u6c42\u3081\u308b\n# n : \u584a\u306e\u6570\n# l : \u4e00\u3064\u306e\u584a(00..001)\u306e\u9577\u3055\n# m : mod\n# ex) n=3, l=2 -> 10101\ndef c111(n, l, m):\n    if n <= 1:\n        return 1\n    if n % 2 == 1:\n        return (c111(n - 1, l, m) * pow(10, l, m) + 1) % m\n    half = c111(n // 2, l, m)\n    return (half * pow(10, (n // 2) * l, m) + half) % m\n\n# c123 -> 1002003004\u307f\u305f\u3044\u306a\u3084\u3064\u3092\u6c42\u3081\u308b\n# n : \u584a\u306e\u6570\n# l : \u4e00\u3064\u306e\u584a(00..001)\u306e\u9577\u3055\n# m : mod\n# ex) n=3, l=2 -> 10203\ndef c123(n, l, m):\n    if n <= 1:\n        return 1\n    if n % 2 == 1:\n        return (c123(n - 1, l, m) + c111(n, l, m)) % m\n    half = c123(n // 2, l, m)\n    return (half * pow(10, (n // 2) * l, m) + half + (n // 2) * c111(n // 2, l, m)) % m\n\nfst = a\nlst = a + b * (l - 1)\n\nfst_l = len(str(fst))\nlst_l = len(str(lst))\n\nres = 0\nmargin = 0\nfor keta in reversed(range(fst_l, lst_l + 1)):\n    num_l = a + b * ((10 ** (keta - 1) - a + b - 1) // b)\n    num_r = a + b * ((10 ** keta - a + b - 1) // b - 1)\n    if keta == fst_l:\n        num_l = fst\n    if keta == lst_l:\n        num_r = lst\n    if num_l > num_r:\n        continue\n    sz = (num_r - num_l) // b + 1\n    _111 = num_l * c111(sz, keta, m)\n    _123 = b * c123(sz - 1, keta, m)\n    if sz == 1:\n        _123 = 0\n    res += (pow(10, margin, m) * (_111 + _123)) % m\n    margin += sz * keta\nprint(res % m)", "L, a, b, m = map(int, input().split())\nans = 0\nfor k in range(1, 37):\n  l = (10**(k-1)-a+b-1)//b\n  r = (10**k-a+b-1)//b\n  l = max(l, 0)\n  r = min(r, L)\n  if l >= r:\n    continue\n  d = r - l\n  c = a+b*(r-1)\n  t = 10**k-1\n  x = b*pow(10, k, m*t*t)*(pow(10, k*(d-1), m*t*t)-1)\n  x %= m*t*t\n  x //= t\n  y = (c-(d-1)*b)*pow(10, d*k, m*t)\n  y %= m*t\n  s = x+y-c\n  s %= m*t\n  s //= t\n  ans *= pow(10, d*k, m)\n  ans += s\n  ans %= m\nprint(ans)", "def solve(L, A, B, M):\n    ret, digits = 0, 0\n    for d in range(18, 0, -1):\n        lo = 10 ** (d - 1)\n        hi = 10 ** d - 1\n        if hi < A or A + B * (L - 1) < lo:\n            continue\n        imin = 0 if lo <= A else (lo - A + B - 1) // B\n        init = A + B * imin\n        if init > hi:\n            continue\n        imax = L - 1 if A + B * (L - 1) <= hi else imin + (hi - init) // B\n        n = imax - imin + 1\n        p = 10 ** d % M\n        a = matpow([[1, 0, 1, 0], [0, 1, 0, 1], [0, 0, p, p], [0, 0, 0, p]], n, M)\n        # a[0][3] = sum p^i for i in [0, n-1]\n        # a[1][3] = sum i * p^i for i in [0, n-1]\n        # sum (A + B * (imax - i)) * p^i for i in [0, n-1]\n        sub = (A + B * imax) % M * a[1][3] % M + M - (B * a[0][3] % M)\n        ret += sub % M * pow10(digits, M) % M\n        digits += d * (imax - imin + 1)\n    return ret % M\n\n\ndef pow10(p, mod):\n    if p % 2 == 1:\n        return 10 * pow10(p - 1, mod) % mod\n    elif p > 0:\n        sub = pow10(p // 2, mod)\n        return sub * sub % mod\n    else:\n        return 1\n\n\ndef matpow(a, p, mod):\n    if p % 2 == 1:\n        return matmul(a, matpow(a, p - 1, mod), mod)\n    elif p > 0:\n        b = matpow(a, p // 2, mod)\n        return matmul(b, b, mod)\n    else:\n        n = len(a)\n        return [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n\n\ndef matmul(a, b, mod):\n    n = len(a)\n    ret = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        for k in range(n):\n            for j in range(n):\n                ret[i][j] += a[i][k] * b[k][j]\n        for j in range(n):\n            ret[i][j] %= mod\n    return ret\n\n\nL, A, B, M = list(map(int, input().split()))\nprint((solve(L, A, B, M)))\n", "class SquareMatrix():\n    def __init__(self, n, mod=1000000007):\n        self.n = n\n        self.mat = [[0 for j in range(n)] for i in range(n)]\n        self.mod = mod\n\n    @staticmethod\n    def id(n, mod=1000000007):\n        res = SquareMatrix(n, mod)\n        for i in range(n):\n            res.mat[i][i] = 1\n        return res\n\n    @staticmethod\n    def modinv(n, mod):\n        assert n % mod != 0\n        c0, c1 = n, mod\n        a0, a1 = 1, 0\n        b0, b1 = 0, 1\n        while c1:\n            a0, a1 = a1, a0 - c0 // c1 * a1\n            b0, b1 = b1, b0 - c0 // c1 * b1\n            c0, c1 = c1, c0 % c1\n        return a0 % mod\n\n    def set(self, arr):\n        for i in range(self.n):\n            for j in range(self.n):\n                self.mat[i][j] = arr[i][j] % self.mod\n\n    def operate(self, vec):\n        assert len(vec) == self.n\n        res = [0 for _ in range(self.n)]\n        for i in range(self.n):\n            for j in range(self.n):\n                res[i] += self.mat[i][j] * vec[j]\n                res[i] %= self.mod\n        return res\n\n    def add(self, other):\n        assert other.n == self.n\n        res = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                res.mat[i][j] = self.mat[i][j] + other.mat[i][j]\n                res.mat[i][j] %= self.mod\n        return res\n\n    def subtract(self, other):\n        assert other.n == self.n\n        res = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                res.mat[i][j] = self.mat[i][j] - other.mat[i][j]\n                res.mat[i][j] %= self.mod\n        return res\n\n    def times(self, k):\n        res = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                res.mat[i][j] = self.mat[i][j] * k\n                res.mat[i][j] %= self.mod\n        return res\n\n    def multiply(self, other):\n        assert self.n == other.n\n        res = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                for k in range(self.n):\n                    res.mat[i][j] += self.mat[i][k] * other.mat[k][j]\n                    res.mat[i][j] %= self.mod\n        return res\n\n    def power(self, k):\n        tmp = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                tmp.mat[i][j] = self.mat[i][j]\n        res = SquareMatrix.id(self.n, self.mod)\n        while k:\n            if k & 1:\n                res = res.multiply(tmp)\n            tmp = tmp.multiply(tmp)\n            k >>= 1\n        return res\n\n    def trace(self):\n        res = 0\n        for i in range(self.n):\n            res += self.mat[i][i]\n            res %= self.mod\n        return res\n\n    def determinant(self):\n        res = 1\n        tmp = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                tmp.mat[i][j] = self.mat[i][j]\n        for j in range(self.n):\n            if tmp.mat[j][j] == 0:\n                for i in range(j + 1, self.n):\n                    if tmp.mat[i][j] != 0:\n                        idx = i\n                        break\n                else:\n                    return 0\n                for k in range(self.n):\n                    tmp.mat[j][k], tmp.mat[idx][k] = tmp.mat[idx][k], tmp.mat[j][k]\n                res *= -1\n            inv = SquareMatrix.modinv(tmp.mat[j][j], self.mod)\n            for i in range(j + 1, self.n):\n                c = -inv * tmp.mat[i][j] % self.mod\n                for k in range(self.n):\n                    tmp.mat[i][k] += c * tmp.mat[j][k]\n                    tmp.mat[i][k] %= self.mod\n        for i in range(self.n):\n            res *= tmp.mat[i][i]\n            res %= self.mod\n        return res\n\n    def transpose(self):\n        res = SquareMatrix(self.n, self.mod)\n        for i in range(self.n):\n            for j in range(self.n):\n                res.mat[i][j] = self.mat[j][i]\n        return res\n\n    def inverse(self): #self.determinant() != 0\n        res = SquareMatrix.id(self.n, self.mod)\n        tmp = SquareMatrix(self.n, self.mod)\n        sgn = 1\n        for i in range(self.n):\n            for j in range(self.n):\n                tmp.mat[i][j] = self.mat[i][j]\n        for j in range(self.n):\n            if tmp.mat[j][j] == 0:\n                for i in range(j + 1, self.n):\n                    if tmp.mat[i][j] != 0:\n                        idx = i\n                        break\n                else:\n                    return 0\n                for k in range(self.n):\n                    tmp.mat[j][k], tmp.mat[idx][k] = tmp.mat[idx][k], tmp.mat[j][k]\n                    res.mat[j][k], res.mat[idx][k] = res.mat[idx][k], res.mat[j][k]\n            inv = SquareMatrix.modinv(tmp.mat[j][j], self.mod)\n            for k in range(self.n):\n                tmp.mat[j][k] *= inv\n                tmp.mat[j][k] %= self.mod\n                res.mat[j][k] *= inv\n                res.mat[j][k] %= self.mod\n            for i in range(self.n):\n                c = tmp.mat[i][j]\n                for k in range(self.n):\n                    if i == j:\n                        continue\n                    tmp.mat[i][k] -= tmp.mat[j][k] * c\n                    tmp.mat[i][k] %= self.mod\n                    res.mat[i][k] -= res.mat[j][k] * c\n                    res.mat[i][k] %= self.mod\n        return res\n\n    def linear_equations(self, vec):\n        return self.inverse().operate(vec)\n\nL, A, B, M = map(int, input().split())\n\nD = [0 for _ in range(18)]\n\nfor i in range(18):\n    D[i] = (int('9' * (i + 1)) - A) // B + 1\n    D[i] = max(D[i], 0)\n    D[i] = min(D[i], L)\n\nfor i in range(17)[::-1]:\n    D[i + 1] -= D[i]\n\nmat = SquareMatrix.id(3, M)\n\nfor i in range(18):\n    op = SquareMatrix(3, M)\n    op.mat[0][0] = 10**(i + 1)\n    op.mat[0][1] = 1\n    op.mat[1][1] = 1\n    op.mat[1][2] = B\n    op.mat[2][2] = 1\n    mat = op.power(D[i]).multiply(mat)\n\nprint(mat.operate([0, A, 1])[0])", "import math\nimport numpy as np\nfrom decimal import *\nL,A,B,M=map(int, input().split())\n\ndef matpow(X,n,mod):\n  E = np.eye(N=X.shape[0],dtype=int)\n  Y = X%mod\n  if n == 1:\n    return Y\n  else:\n    return np.dot(matpow(np.dot(Y,Y)%mod,n//2,mod), (Y if n % 2 else E))%mod\n  \na = 0\nfor d in range(1,19):\n  left = math.ceil(Decimal(10**(d-1)-A)/Decimal(B))\n  right = math.ceil(Decimal(10**d-A)/Decimal(B))-1\n  if right < 0:\n    continue\n  if left > L-1:\n    break\n  if left > right:\n    continue\n  if left < 0:\n    left = 0\n  if right > L-1:\n    right = L-1\n  mat = np.matrix([[10**d,0,0],[1,1,0],[0,1,1]])\n  result = np.dot(np.array([a,A+B*left,B])%M, matpow(mat,right-left+1,M))\n  a = result[0,0]%M\n  \nprint(a)", "import numpy as np\n\nL, A, B, M = map(int, input().split())\n\ndef dot(A, B, mod):\n    r = len(A)\n    c = len(B[0])\n    m = len(A[0])\n    res = [[0] * c for _ in range(r)]\n    \n    for i in range(r):\n        for j in range(c):\n            for k in range(m):\n                res[i][j] += A[i][k] * B[k][j] % mod\n                res[i][j] %= mod\n    \n    return res\n\ndef rec_pow(k, n, mod):\n    if n == 1:\n        return k\n    \n    k2 = dot(k, k, mod)\n    if n % 2 ==0:\n        return rec_pow(k2, n//2, mod)\n    else:\n        return dot(rec_pow(k2, n//2, mod), k, mod)\n\ns = [[0, A%M, 1]]\n\nfor d in range(1, 19):\n    n1 = min(max(0, (10**d-1-A)//B+1), L)\n    n0 = min(max(0, (10**(d-1)-1-A)//B+1), L)\n    n = n1 - n0\n    if n == 0:\n        continue\n        \n    k = [[pow(10, d, M), 0, 0], [1, 1, 0], [0, B%M, 1]]\n    \n    s = dot(s, rec_pow(k, n, M), M)\n    \n    if n1 >= L:\n        break\n        \nprint(s[0][0])", "class Matrix:\n\n  def __init__(self, mat, mod=10**9+7):\n    assert(len(mat) and len(mat[0]))\n    from copy import deepcopy\n    self.MOD = mod\n    self.mat = deepcopy(mat)\n\n  def matunit(self, n):\n    return Matrix([[(x==y) for x in range(n)] for y in range(n)], mod=self.MOD)\n\n  def __add__(self, other):\n    assert(len(self.mat)==len(other.mat) and len(self.mat[0])==len(other.mat[0]))\n    h = len(self.mat)\n    w = len(self.mat[0])\n    ret = [[(self.mat[y][x]+other.mat[y][x])%self.MOD for x in range(w)] for y in range(h)]\n    return ret\n\n  def __mul__(self, other):\n    assert(len(self.mat[0])==len(other.mat))\n    h = len(self.mat)\n    w = len(other.mat[0])\n    ret = [[0 for _ in range(w)] for _ in range(h)]\n    for y in range(h):\n      for z in range(len(other.mat)):\n        for x in range(w):\n          ret[y][x] += self.mat[y][z]*other.mat[z][x]\n    for y in range(h):\n      for x in range(w):\n        ret[y][x] %= self.MOD\n    return Matrix(ret, mod=self.MOD)\n\n  def __pow__(self, k):\n    assert(len(self.mat)==len(self.mat[0]))\n    from copy import deepcopy\n    ret = self.matunit(len(self.mat))\n    n = Matrix(deepcopy(self.mat), mod=self.MOD)\n    while k:\n      if k&1:\n        ret = ret * n\n      n = n * n\n      k >>= 1\n    return ret\n\n  def __str__(self):\n    return \"[{}]\".format(\"\\n\".join(str(row) for row in self.mat))\n\nL, A, B, M = list(map(int, input().split()))\n\nd = [0 for i in range(20)]\nfor i in range(1, 19):\n  l = -1\n  r = L\n  while r-l>1:\n    m = (l+r)//2\n    if len(str(A+B*m))>i:\n      r = m\n    else:\n      l = m\n  d[i] = r\n\nx = Matrix([[0, A, 1]], mod=M)\nfor i in range(1, 19):\n  dt = d[i]-d[i-1]\n  y = Matrix([[10**i, 0, 0], [1, 1, 0], [0, B, 1]], mod=M)\n  y = y ** dt\n  x *= y\nprint((x.mat[0][0]))\n", "import sys\nsys.setrecursionlimit(1000000)\nimport numpy as np\ninput = sys.stdin.readline\n\nL,A,B,M = list(map(int, input().split()))\n\nC = []\nfor i in range(19):\n  C.append(min(max(0,(10**i - A - 1) //B + 1), L))\n\ndef R_mul(A, B, M):\n  return np.mod((np.dot(A,B)), M)\n\ndef R_pow(R, n, M):\n  if n == 1:\n    return R\n  \n  R2 = R_mul(R, R, M)\n  R2 = R_pow(R2, n//2, M)\n  \n  if n % 2 == 0:\n    return R2\n  else:\n    return R_mul(R2, R, M)\n\n                 \nans = 0\nR = np.ones((3,3))\ns = np.array([0, A%M, 1])\n\nfor d in range(1,19):\n  r = C[d] - C[d-1]\n  if (0 == r):\n    continue\n  R0 = np.array([[pow(10,d,M),1,0],[0,1,(B%M)],[0,0,1]])\n  R = R_pow(R0, r, M)\n  s = R_mul(R, s, M)\n  #print(d, R, s)\n  if (C[d] > L):\n    break\n\nprint((s[0]))\n", "#import sys\n#input = sys.stdin.readline\n#from numpy import matrix, eye, dot\ndef productMatrix(N, A, B):\n    Ret = [[0]*N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                Ret[i][j] += A[i][k]*B[k][j]\n    return Ret\ndef modMatrix(N, A, Q): #N\u00d7N\u884c\u5217\u306emod\n    for i in range(N):\n        for j in range(N):\n            A[i][j] %= Q\n#            A[i,j] %= Q\n    return\n\ndef powOfMatrix(N, X, n, Q): #N\u00d7N\u884c\u5217\u306en\u4e57\n#    Ret = eye(N)\n    Ret = [[1,0,0],[0,1,0],[0,0,1]]\n    power = '{:060b}'.format(n)[::-1] #log2(pow(10,18)) < 60\n    for p in power:\n        if p == \"1\":\n            Ret = productMatrix(N,Ret, X)\n#            Ret = dot(Ret, X)\n            modMatrix(N, Ret, Q)\n        X = productMatrix(N,X,X)\n#        X = dot(X,X)\n        modMatrix(N, X, Q)\n#        print(Ret)\n    return Ret\n\ndef main():\n    L, A, B, M = list(map( int, input().split()))\n    s = A\n    ANS = [[1,0,0],[0,1,0],[0,0,1]]\n    for i in range(1, 37):\n#        print(i, ANS)\n        if s >= pow(10,i):\n            continue\n        P = [[pow(10, i, M), 0, 0], [1,1,0], [0,B,1]]\n#        P = matrix([[pow(10, i, M), 0, 0], [1,1,0], [0,B,1]])\n#        print((pow(10,i)-1-s)//B+1)\n        step = (pow(10,i)-s+B-1)//B\n        if L <= step:\n            ANS = productMatrix(3,ANS,powOfMatrix(3,P,L,M))\n#            ANS = dot(ANS,powOfMatrix(3,P,L,M))\n            modMatrix(3,ANS,M)\n            break\n#        print(powOfMatrix(3,P, (pow(10,i)-1-s)//B + 1,M))\n        ANS = productMatrix(3,ANS, powOfMatrix(3,P, step,M))\n#        ANS = dot(ANS, powOfMatrix(3,P, (pow(10,i)-1-s)//B + 1,M))\n#        print( (ANS[1][0]*A + ANS[2][0])%M, (pow(10,i)-1-s)//B + 1)\n        modMatrix(3,ANS, M)\n        L -= step\n        s += step*B\n    print(( (ANS[1][0]*A + ANS[2][0])%M))\n#    print( int((ANS[1,0]*A + ANS[2,0])%M))\n        \n        \ndef __starting_point():\n    main()\n\n__starting_point()", "l, a, b, MOD = [int(item) for item in input().split()]\nvec = [0, a%MOD, 1]\n\ndef mat_mat_mul3(m1, m2):\n    m3 = [[0] * 3 for _ in range(3)]\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                m3[i][j] += m1[i][k] * m2[k][j]\n                m3[i][j] %= MOD\n    return m3\n\ndef mat_vec_mul3(m1, v1):\n    v2 = [0] * 3\n    for i in range(3):\n        for k in range(3):\n            v2[i] += v1[k] * m1[i][k]\n            v2[i] %= MOD\n    return v2\n\nA_d_pow = [[None] * 66 for _ in range(20)]\nfor d in range(20):\n    for i in range(66):\n        if i == 0:\n            A = [[1, 0, 0], \n                 [0, 1, 0], \n                 [0, 0, 1]]\n            A_d_pow[d][i] = A\n            continue\n        if i == 1:\n            A = [[10**d % MOD, 1, 0], \n                 [0, 1, b % MOD], \n                 [0, 0, 1]]\n            A_d_pow[d][i] = A\n            continue\n        A_d_pow[d][i] = mat_mat_mul3(A_d_pow[d][i-1], A_d_pow[d][i-1])\n\nmultimes = [0] * 20\nfor i in range(1,20):\n    if 10**i > a:\n        cnt = (10**i - 1 - a) // b + 1\n        if cnt >= l:\n            multimes[i] = l\n            break\n        else:\n            multimes[i] = cnt\n            l -= cnt\n            a += cnt * b\n\nfor i, num in enumerate(multimes):\n    if num == 0:\n        continue\n    for j in range(66):\n        if num & 1 << j:\n            vec = mat_vec_mul3(A_d_pow[i][j+1], vec)\n\nprint(vec[0])", "L,A,B,M=map(int,input().split())\nC=(L-1)*B+A\nmod=M\nX,s=0,A\nnow=A\ndata=[0]*19\nruiseki=[0]*19\nAmi=(A-1)//B\nCmi=C//B\nfor i in range(19):\n    now=10**i-1\n    if now<A:\n        ruiseki[i]=0\n    elif now>=C:\n        ruiseki[i]=L\n    else:\n        ruiseki[i]=(now-A)//B+1\ndef mul33(A,B):\n    nonlocal mod\n    res=[[0]*3 for i in range(3)]\n    for i in range(3):\n        for j in range(3):\n            res[i][j]=sum([A[i][k]*B[k][j]%mod for k in range(3)])\n    return res\ndef ruijou(vec,Cd):\n    rui=dict()\n    if Cd==0:\n        return [[1,0,0],[0,1,0],[0,0,1]]\n    now=vec\n    ans=[[1,0,0],[0,1,0],[0,0,1]]\n    Cds=bin(Cd)[2:][::-1]\n    for i in range(len(Cds)):\n        if Cds[i]==\"1\":\n            ans=mul33(ans,now)\n        now=mul33(now,now)\n    return ans\ndef mul(X,s,Cd,d):\n    nonlocal mod\n    nonlocal B\n    vec=[[pow(10,d,mod),0,0],[1,1,0],[0,B,1]]\n    vec=ruijou(vec,Cd)\n    Xc=X\n    sc=s\n    X=(Xc*vec[0][0]+sc*vec[1][0]+vec[2][0])%mod\n    s=(Xc*vec[0][1]+sc*vec[1][1]+vec[2][1])%mod\n    return X,s\nfor d in range(1,19):\n    Cd=ruiseki[d]-ruiseki[d-1]\n    X,s=mul(X,s,Cd,d)\nprint(X)", "import numpy as np\ndef matrix_power(Mat, n):\n    if n == 0:\n        return I#(\u5358\u4f4d\u5143\uff09\n    x = matrix_power(Mat, n>>1)#\u534a\u5206\u3092\u8003\u3048\u308b\n    x = np.dot(x, x)#n//2\u3092\u4e8c\u56de\u884c\u3046\n    if not n&1:\n        return x%M\n    x = np.dot(x, Mat)#\u3042\u307e\u308a\u306e\u5206\n    return x%M\nI = np.identity(3, dtype = 'object') \nL, A, B, M = map(int,  input().split())\nans = np.array([[0],\n                          [A],\n                          [1]], dtype = 'object')\ns_L = A+B*(L-1)\nfor digit in range(len(str(A)), len(str(s_L))+1):\n    cnt = (min(s_L, 10**digit-1)-A)//B-max(-1, (10**(digit-1)-1-A)//B)\n    Mat = np.array([[10**digit, 1, 0],\n                            [0, 1, B],\n                            [0, 0, 1]])\n    ans = np.dot(matrix_power(Mat, cnt), ans)%M\nprint(ans[0, 0])", "def mpw(n,m):\n    ret=1\n    while m>0:\n        if m&1:\n            ret*=n\n            ret%=M\n        n*=n\n        n%=M;\n        m>>=1\n    return ret;\ndef pw(n,m):\n    ret=1\n    while m>0:\n        if m&1:\n            ret*=n\n        n*=n\n        m>>=1\n    return ret;\ndef delta(i,j):\n    if i==j:\n        return 1\n    return 0\ndef mtxmpw(A,m):\n    ret=[[delta(i,j) for i in range(len(A))] for j in range(len(A))]\n    while m>0:\n        if m&1:\n            ret=mul(ret,A)\n        A=mul(A,A)\n        m>>=1\n    return ret\ndef mul(A,B):\n    ret=[[0 for i in range(len(B[0]))] for j in range(len(A))]\n    for i in range(len(A)):\n        for j in range(len(B[0])):\n            for k in range(len(B)):\n                ret[i][j]+=A[i][k]*B[k][j]\n                ret[i][j]%=M\n    return ret\n\nL,A,B,M=map(int,input().split())\nans=0\nd=0\nfor k in range(18,0,-1):\n    l=max((pw(10,(k-1))-A+B-1)//B,0)\n    r=min((pw(10,k)-A-1)//B,L-1)\n    if l<=r:\n        MT=[[1,mpw(10,k),0],[0,mpw(10,k),(M-B*mpw(10,k)%M)%M],[0,0,mpw(10,k)]]\n        v=[[(A+B*r)%M],[(A+B*(r-1)%M+M)%M],[1]]\n        u=mul(mtxmpw(MT,r-l),v)\n        ans+=mpw(10,d)*u[0][0]%M;\n        ans%=M;\n        d+=(r-l+1)*k\nprint(ans)", "def unitmat(n):\n    return [[int(i==j) for i in range(n)] for j in range(n)]\ndef matadd(A,B):\n    h=len(A); w=len(A[0])\n    C=[[A[i][j]+B[i][j] for j in range(w)] for i in range(h)]\n    return C\ndef matmul(A,B):\n    h=len(A)\n    w=len(B[0])\n    l=len(B)\n    C=[[0]*w for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            for k in range(l):\n                C[i][j]+=A[i][k]*B[k][j]\n    for i in range(h):\n        for j in range(w):\n            C[i][j]%=mod\n    return C\ndef matpow(A,k):\n    n=len(A)\n    B=unitmat(n)\n    while k:\n        if k&1:\n            B=matmul(B,A)\n        A=matmul(A,A)\n        k>>=1\n    return B\n\nl,a,b,mod=map(int,input().split())\nX=[[0],[a],[1]]\nmaxdigit=18\nIdx=[0]*(maxdigit+1)\nfor i in range(maxdigit+1):\n    if 10**i-1<a:\n        continue\n    Idx[i]=min((10**i-1-a)//b+1,l)\nfor i in range(1,maxdigit+1):\n    f=[[10**i,1,0],[0,1,b],[0,0,1]]\n    X=matmul(matpow(f,Idx[i]-Idx[i-1]),X)\nprint(X[0][0])", "import numpy as np\nimport sys\n\ndef II(): return int(sys.stdin.readline())\ndef MI(): return list(map(int, sys.stdin.readline().split()))\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\n# \u3060\u3044\u305f\u3044pdf\u306e\u901a\u308a\ndef main():\n    l,a,b,md=MI()\n\n    # \u6570\u5217\u306e\u8981\u7d20\u304ck\u6841\u306b\u306a\u308b\u306e\u304ci\u9805\u76ee\u3067\u3001k+1\u6841\u306b\u306a\u308b\u306e\u304cj\u9805\u76ee\n    k=0\n    i=0\n    ans=[0,a%md,b%md]\n    ans=np.array(ans,dtype=\"i8\")\n    # \u5404\u6841\u6570\u3054\u3068\u306b\u51e6\u7406\n    while i<l:\n        k+=1\n        j=(10**k-a+b-1)//b\n        if j<=0:continue\n        if j>l:j=l\n        # k\u6841\u306e\u8981\u7d20\u306e\u500b\u6570\u304ce\n        e=j-i\n        # i\u9805\u76ee\u307e\u3067\u9023\u7d50\u3057\u305f\u6574\u6570\u3092ans[i],\u6570\u5217\u306ei\u9805\u76ee\u3092s[i]\u3068\u3059\u308b\u3068\n        #                                       [10**k 0 0]\n        # [ans[i],s[i],b] = [ans[i-1],s[i-1],b] [  1   1 0]\n        #                                       [  0   1 1]\n        # \u6700\u5f8c\u306e3x3\u884c\u5217\u3092bb\u3068\u3057\u3066\u3001e\u4e57\u3059\u308c\u3070\u3088\u3044\u306e\u3067\u3001\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u3067\u3084\u308b\n        bb=np.zeros((3,3),dtype=\"i8\")\n        bb[0,0]=pow(10,k,md)\n        bb[1,0]=bb[1,1]=bb[2,1]=bb[2,2]=1\n        while e:\n            if e&1:ans=np.dot(ans,bb)%md\n            bb=np.dot(bb,bb)%md\n            e>>=1\n        i=j\n\n    print((ans[0]))\n\nmain()\n", "\ndef mul_square_matrix(a, b, mod):\n    n = len(a)\n    ret = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                ret[i][j] = (ret[i][j] + a[i][k] * b[k][j]) % mod\n    return ret\n\n\ndef power_square_matrix(mat:list, k, mod):\n    n = len(mat)\n    ret = [[0] * n for _ in range(n)]\n    for i in range(n):\n        ret[i][i] = 1\n    while k > 0:\n        if k % 2 == 1:\n            ret = mul_square_matrix(ret, mat, mod)\n        mat = mul_square_matrix(mat, mat, mod)\n        k //= 2\n    return ret\n\nl, a, b, m = map(int, input().split())\ns_foot = a + b * (l - 1)\ndigit_n = len(str(s_foot))\ncount_digit_n = [0] * (digit_n + 1)\nd = 1\nfor i in range(1, digit_n + 1):\n    d *= 10\n    x = min(d - 1, s_foot) - a\n    if x < 0:\n        continue\n    n = x // b\n    count_digit_n[i] = n + 1\n\nfor i in range(digit_n, 0, -1):\n    count_digit_n[i]  -= count_digit_n[i - 1]\n\nd = 1\nx = [[0], [a], [1]]\nfor n in count_digit_n[1:]:\n    d = d * 10 % m\n    if n == 0:\n        continue\n    mat = [[d, 1, 0], [0, 1, b], [0, 0, 1]]\n    mat = power_square_matrix(mat, n, m)\n    for i in range(3):\n        x[i][0] = sum([mat[i][j] * x[j][0] for j in range(3)]) % m\nprint(x[0][0])", "def matrix_product(X,Y,M):\n    XY = [[0]*3 for _ in range(3)]\n\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                XY[i][j] += X[i][k]*Y[k][j] % M\n            XY[i][j] %= M\n    \n    return XY\n\ndef power(X,n,M):\n    res = [[1,0,0],[0,1,0],[0,0,1]]\n\n    if n == 0: return res\n\n    while n > 0:\n        if n & 1: res = matrix_product(res,X,M)\n        X = matrix_product(X,X,M)\n        n //= 2\n    \n    return res\n\nL, A, B, M = list(map(int,input().split()))\n\nX = [0,A,1]\n\nfor d in range(1,19):\n    if L == 0: break\n\n    \n    l = (10**(d-1) - A + B-1) // B\n    r = (10**d - A) // B\n    if (10**d - A) % B == 0: r -= 1\n    \n    if l < 0: l = 0\n    if r < 0: r = -1\n    \n    C = min(r-l+1,L)\n    L -= C\n\n    Y = power([[10**d,0,0],[1,1,0],[0,B,1]],C,M)\n    \n    next_X = [0,0,0]\n    for i in range(3):\n        for j in range(3):\n            next_X[i] += X[j] * Y[j][i] % M\n        next_X[i] %= M\n    X = next_X\n\nprint((X[0]))\n\n\n\n\n\n\n\n", "L, A, B, M = map(int, input().split())\nans = 0\nd = 0\ndef mul(X, Y):\n    Z = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    for i in range(3):\n        for j in range(3):\n            r = 0\n            for k in range(3):\n                r += X[i][k] * Y[k][j]\n            Z[i][j] = r % M\n    return Z\n\nx = 0; a = A\nwhile 1:\n    kd0 = max(min((10**d - A + B - 1) // B, L), 0)\n    kd1 = max(min((10**(d+1) - A + B - 1) // B, L), 0)\n\n    Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    P = [[10**(d+1), 0, 0], [1, 1, 0], [0, B, 1]]\n    k = kd1 - kd0\n    while k:\n        if k & 1:\n            Q = mul(P, Q)\n        P = mul(P, P)\n        k >>= 1\n    x, a = (x*Q[0][0]+a*Q[1][0]+Q[2][0]) % M, (x*Q[0][1]+a*Q[1][1]+Q[2][1]) % M\n    if kd1 == L:\n        break\n    d += 1\nprint(x)", "def mat_prod(A, B, m):\n  x = len(A)\n  y = len(B)\n  z = len(B[0])\n  C = [[0]*z for _ in range(x)]\n  for i in range(x):\n    for j in range(y):\n      for k in range(z):\n        C[i][k] += A[i][j] * B[j][k]\n        C[i][k] %= m\n  return C\n\ndef mat_pow(A, n, m):\n  if n == 1:\n    return A\n  if n%2:\n    return mat_prod(mat_pow(A, n-1, m), A, m)\n  B = mat_pow(A, n//2, m)\n  return mat_prod(B, B, m)\n\nL, a, b, m = map(int, input().split())\nans = 0\ns = a\nfor k in range(1, 19):\n  l = (10**(k-1)-a+b-1)//b\n  r = (10**k-a+b-1)//b\n  l = max(l, 0)\n  r = min(r, L)\n  if l >= r:\n    continue\n  d = r-l\n  X = [[ans, s, 1]]\n  Y = [[pow(10, k, m), 0, 0], [1, 1, 0], [0, b, 1]]\n  Z = mat_prod(X, mat_pow(Y, d, m), m)\n  ans, s = Z[0][:2]\nprint(ans)", "import os\nimport sys\n\nimport numpy as np\nfrom numpy.linalg import matrix_power\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\n\nL, A, B, M = list(map(int, sys.stdin.readline().split()))\nMOD = M\n\n\nclass ModInt:\n    def __init__(self, value):\n        self.value = value % MOD\n\n    def __add__(self, other):\n        if isinstance(other, ModInt):\n            return ModInt(self.value + other.value)\n        else:\n            return ModInt(self.value + other)\n\n    def __mul__(self, other):\n        if isinstance(other, ModInt):\n            return ModInt(self.value * other.value)\n        else:\n            return ModInt(self.value * other)\n\n    def __repr__(self):\n        return str(self.value)\n\n\nsize = 0\n# \u5168\u90e8\u3064\u306a\u3052\u305f\u306e\u3092 X \u3068\u3059\u308b\u3068\u3001\n# [\u4eca\u306e X, \u6b21\u306b\u52a0\u7b97\u3059\u308b\u6570, \u516c\u5dee]\nvec = [ModInt(0), ModInt(A), ModInt(B)]\n# \u52a0\u7b97\u3059\u308b\u6570\u306e\u6841\u6570\ndigits = 1\nwhile size < L:\n    # \u6841\u6570\u304c digits \u3067\u3042\u308b\u8981\u7d20\u306e\u6570\n    # digits \u4ee5\u4e0b\u306e\u8981\u7d20\u306e\u6570\u306e\u5408\u8a08\u304b\u3089\u4eca\u307e\u3067\u306b\u52a0\u7b97\u3057\u305f\u6570\u3092\u5f15\u304f\n    cnt = max(0, (10 ** digits - 1 - A) // B - size + 1)\n    cnt = min(cnt, L - size)\n\n    mat = np.array([\n        [ModInt(pow(10, digits, MOD)), ModInt(0), ModInt(0)],\n        [ModInt(1), ModInt(1), ModInt(0)],\n        [ModInt(0), ModInt(1), ModInt(1)],\n    ])\n    if cnt > 0:\n        vec = np.dot(vec, matrix_power(mat, cnt))\n    digits += 1\n    size += cnt\nprint((vec[0]))\n", "l,a,b,m = map(int,input().split())\n\nten = 1\ndef f(x):\n\n    if x == 0:\n        return 0\n    if x % 2 == 1:\n        t = x-1\n        x = f(t)\n        return x*ten+1\n    else:\n        t = x//2\n        x = f(t)\n        return x*pow(ten,t,m) + x\n\ndef g(x):\n\n    if x == 0:\n        return 0\n    if x % 2 == 1:\n        t = x-1\n        x = g(t)\n        return x*ten + b*(t)\n    else:\n        t = x//2\n        x = g(t)\n        return x*pow(ten,t,m) + x + b*(t)*f(t)\nlast = a+b*(l-1)\n\nans = 0\nfor i in range(1,20):\n    le = ten\n    r = ten*10-1\n    \n    ten *= 10\n    if last < le or a > r:\n        continue\n    if le < a:\n        na = a\n    else:\n        na = (le-a+b-1)//b*b+a\n    if last <= r:\n        nl = last\n    else:\n        nl = (r-a)//b*b+a\n    n = (nl-na)//b+1\n    \n    ans *= pow(ten,n,m)\n    ans += ((f(n)%m)*na)%m\n    ans += g(n)%m\n    ans %= m\n\nprint(ans)", "import sys\nfrom math import log10\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 19\nMOD = 10 ** 19 + 7\nEPS = 10 ** -10\n\ndef bisearch_min(mn, mx, func):\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef mat_pow(mat, init, K, MOD):\n    \"\"\" \u884c\u5217\u7d2f\u4e57 \"\"\"\n\n    def mat_dot(A, B, MOD):\n        \"\"\" \u884c\u5217\u306e\u7a4d \"\"\"\n\n        if not isinstance(A[0], list) and not isinstance(A[0], tuple):\n            A = [A]\n        if not isinstance(B[0], list) and not isinstance(A[0], tuple):\n            B = [[b] for b in B]\n        n1 = len(A)\n        n2 = len(A[0])\n        _ = len(B)\n        m2 = len(B[0])\n        res = list2d(n1, m2, 0)\n        for i in range(n1):\n            for j in range(m2):\n                for k in range(n2):\n                    res[i][j] += A[i][k] * B[k][j]\n                    res[i][j] %= MOD\n        return res\n\n    def _mat_pow(mat, k, MOD):\n        \"\"\" \u884c\u5217mat\u3092k\u4e57\u3059\u308b \"\"\"\n\n        n = len(mat)\n        res = list2d(n, n, 0)\n        for i in range(n):\n            res[i][i] = 1\n        while k > 0:\n            if k & 1:\n                res = mat_dot(res, mat, MOD)\n            mat = mat_dot(mat, mat, MOD)\n            k >>= 1\n        return res\n\n    res = _mat_pow(mat, K, MOD)\n    res = mat_dot(res, init, MOD)\n    return [a[0] for a in res]\n\nL, a, b, M = MAP()\n\nA = [0] * 20\nfor i in range(1, 20):\n    x = 10 ** i\n    res = bisearch_min(-1, L, lambda m: ceil(x-a, b) <= m)\n    A[i] = res\nC = [0] * 20\nfor i in range(1, 20):\n    C[i] = A[i] - A[i-1]\n\ninit = [0, a, 1]\nfor d in range(1, 20):\n    K = C[d]\n    if K == 0:\n        continue\n    mat = [\n        # dp0[i] = dp0[i-1]*10^d + dp1[i-1]*1 + 1*0\n        [pow(10, d, M), 1, 0],\n        # dp1[i] = dp0[i-1]*0 + dp1[i-1]*1 + 1*b\n        [0, 1, b],\n        # 1 = dp0[i-1]*0 + dp1[i-1]*0 + 1*1\n        [0, 0, 1],\n    ]\n    res = mat_pow(mat, init, K, M)\n    init[0] = res[0]\n    init[1] = res[1]\nans = res[0]\nprint(ans)\n\n# dp0 = [0] * (L+1)\n# dp1 = [0] * (L+1)\n# dp0[0] = 0\n# dp1[0] = a\n# for i in range(1, L+1):\n#     dp0[i] = (dp0[i-1]*pow(10, int(log10(dp1[i-1]))+1, M) + dp1[i-1]) % M\n#     dp1[i] = dp1[i-1] + b\n# ans = dp0[-1]\n# print(ans)\n", "n,a,b,MOD=list(map(int,input().split()))\ndef matmul(A,B):\n\tnonlocal MOD\n\tN,M,L=len(A),len(B),len(B[0])\n\tret=[[0 for j in range(L)] for i in range(N)]\n\tfor i in range(N):\n\t\tfor j in range(M):\n\t\t\tfor k in range(L):\n\t\t\t\tret[i][k] += A[i][j]*B[j][k]%MOD\n\t\t\t\tret[i][k] %= MOD\n\treturn ret\nans,c=[[0,a%MOD,1]],0\nfor i in range(1,19):\n\tif not a<10**i:\n\t\tcontinue\n\tm=[[10**i%MOD,0,0],[1,1,0],[0,b%MOD,1]]\n\tq = -c\n\tc = min(((10**i-1-a)//b)+1,n)\n\tq += c\n\twhile q:\n\t\tif q&1:\n\t\t\tans = matmul(ans,m)\n\t\tm = matmul(m,m)\n\t\tq >>= 1\nprint((ans[0][0]))\n", "L,A,B,mod=list(map(int,input().split()))\n\ndef keta(k):# k-\u6841\u306e\u6570\u306e\u521d\u9805\u3001\u672b\u9805\u3001\u9805\u6570\u3092\u6c42\u3081\u308b\n    if A>=10**k:\n        return 0,0,0\n    begin=10**(k-1)\n    end=10**k\n\n    if begin>A+B*(L-1):\n        return 0,0,0\n\n    sh=A+max(-1,(begin-1-A)//B)*B+B\n    ma=min(A+max(0,(end-1-A)//B)*B,A+B*(L-1))\n    kou=(ma-sh)//B+1\n    \n    return sh,ma,kou\n\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef f(n,r): # 1+r+...+r**(n-1)\n    if n==1:\n        return 1\n    if n%2==0:\n        return (f(n//2,r) + pow(r,n//2,mod)*f(n//2,r))%mod\n    return (r*f(n-1,r)+1)%mod\n\n@lru_cache(maxsize=None)\ndef g(n,r): # 0+r+2*r**2+...+(n-1)*r**(n-1)\n    if n==1:\n        return 0\n    if n%2==0:\n        return g(n//2,r)+pow(r,n//2,mod)*(g(n//2,r)+n//2*f(n//2,r))\n    return r*g(n-1,r)+r*f(n-1,r)\n\nketa_count=1\nANS=0\nfor i in range(18,0,-1):\n    sh,ma,kou = keta(i)\n    \n    if kou<=0:\n        continue\n    \n\n    #print(i,sh,ma,kou)\n\n    ANS=(keta_count*(ma*f(kou,10**i)-B*g(kou,10**i))+ANS)%mod\n    #print(ANS)\n    keta_count = keta_count * pow(10,kou * i,mod)\n\nprint(ANS)\n    \n    \n", "def rec(r, b, c, a0, n, mod):\n    # a_n = r * a_{n-1} + b * n + c\n    a = a0\n    n_ = 0\n    c += b\n    diff = 1\n    while n:\n        n, m = divmod(n, 2)\n        if m:\n            a = (a * r + b * n_ + c) % mod\n            n_ += diff\n        r, b, c = r*r%mod, (r*b+b)%mod, (r*c+b*diff+c)%mod\n        diff <<= 1\n    return a\n\ndef main():\n    L, A, B, M = list(map(int, input().split()))\n\n    def bis(d):\n        # d \u6841\u4ee5\u4e0a\u306b\u306a\u308b\u6700\u5c0f\u306e\u9805\n        n = 10**(d-1)\n        ng = -1\n        ok = L\n        while ng + 1 < ok:\n            c = ok+ng >> 1\n            s_c = A + B * c\n            if s_c >= n:\n                ok = c\n            else:\n                ng = c\n        return ok\n    Idxs = [0]\n    for d in range(1, 19):\n        Idxs.append(bis(d))\n    Idxs.append(L)\n\n    ans = 0\n    for d, (l, r) in enumerate(zip(Idxs, Idxs[1:])):\n        if r - l == 0:\n            continue\n        s_l = A + B * l\n        n = r - l\n        ratio = 10**d\n        a = rec(ratio, B, s_l, s_l, n-1, M)\n        #print(d, a)\n        ans = (ans * pow(10, d*n, M) + a) % M\n    print(ans)\n\nmain()\n", "from functools import reduce\n\nL, A, B, M = list(map(int, input().split()))\n\nMOD = M\n\n\nclass ModInt:\n    def __init__(self, x):\n        self.x = x % MOD\n\n    def __str__(self):\n        return str(self.x)\n\n    __repr__ = __str__\n\n    def __add__(self, other):\n        return (\n            ModInt(self.x + other.x) if isinstance(other, ModInt) else\n            ModInt(self.x + other)\n        )\n\n    def __sub__(self, other):\n        return (\n            ModInt(self.x - other.x) if isinstance(other, ModInt) else\n            ModInt(self.x - other)\n        )\n\n    def __mul__(self, other):\n        return (\n            ModInt(self.x * other.x) if isinstance(other, ModInt) else\n            ModInt(self.x * other)\n        )\n\n    def __truediv__(self, other):\n        return (\n            ModInt(\n                self.x * pow(other.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(self.x * pow(other, MOD - 2, MOD))\n        )\n\n    def __pow__(self, other):\n        return (\n            ModInt(\n                pow(self.x, other.x, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(pow(self.x, other, MOD))\n        )\n\n    def __radd__(self, other):\n        return ModInt(other + self.x)\n\n    def __rsub__(self, other):\n        return ModInt(other - self.x)\n\n    def __rmul__(self, other):\n        return ModInt(other * self.x)\n\n    def __rtruediv__(self, other):\n        return ModInt(other * pow(self.x, MOD - 2, MOD))\n\n    def __rpow__(self, other):\n        return ModInt(pow(other, self.x, MOD))\n\n\ndef iceil(a, b):\n    return (a + b - 1) // b\n\n\n# \u7b49\u5dee\u6570\u5217\u3092\u6841\u6570\u304c\u540c\u4e00\u306e\u8981\u7d20\u3054\u3068\u306b\u533a\u5207\u308b\n# \u533a\u5207\u3063\u305f\u7b49\u5dee\u6570\u5217\u306e\u5404\u8981\u7d20\u306b\u3064\u3044\u3066\u3001\u305d\u308c\u3092\u672b\u5c3e\u306b\u8ffd\u52a0\u3059\u308b\u64cd\u4f5c\u3092\u7dda\u5f62\u5909\u63db\u3068\u307f\u306a\u3059\n# \u7dda\u5f62\u5909\u63db\u306f\u30c0\u30d6\u30ea\u30f3\u30b0\u3067\u9ad8\u901f\u306b\u8a08\u7b97\u3059\u308b\nT = {}\nx = A\nwhile x <= A + B * (L - 1):\n    k = len(str(x))\n    r = iceil(\n        min(\n            10**k,\n            A + B * (L - 1) + 1\n        ) - x,\n        B\n    )\n    T[k] = r\n    x += r * B\n\n\ndef mut_mul(X, Y):\n    return [\n        [\n            sum(X[i][k] * Y[k][j] for k in range(len(Y)))\n            for j in range(len(Y[0]))\n        ]\n        for i in range(len(X))\n    ]\n\n\ndef mut_pow(X, n):\n    if n == 0:\n        return [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ]\n    else:\n        Y = mut_pow(X, n // 2)\n        return (\n            mut_mul(Y, Y) if n % 2 == 0 else\n            mut_mul(mut_mul(Y, Y), X)\n        )\n\n\ndef f(p, q, k, r):\n    Y = mut_pow(\n        [\n            [ModInt(10**k), ModInt(1), ModInt(0)],\n            [ModInt(0), ModInt(1), ModInt(1)],\n            [ModInt(0), ModInt(0), ModInt(1)]\n        ],\n        r\n    )\n    Z = mut_mul(\n        Y,\n        [\n            [p],\n            [q],\n            [ModInt(B)]\n        ]\n    )\n    return (Z[0][0], Z[1][0])\n\n\nans, _ = reduce(\n    lambda acc, kr: f(acc[0], acc[1], kr[0], kr[1]),\n    sorted(T.items()),\n    (ModInt(0), ModInt(A))\n)\n\nprint(ans)\n", "import sys\nfrom math import log10\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 19\nMOD = 10 ** 19 + 7\nEPS = 10 ** -10\n\ndef bisearch_min(mn, mx, func):\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef mat_pow(mat, init, K, MOD):\n    \"\"\" \u884c\u5217\u7d2f\u4e57 \"\"\"\n\n    def mat_dot(A, B, MOD):\n        \"\"\" \u884c\u5217\u306e\u7a4d \"\"\"\n\n        if not isinstance(A[0], list) and not isinstance(A[0], tuple):\n            A = [A]\n        if not isinstance(B[0], list) and not isinstance(A[0], tuple):\n            B = [[b] for b in B]\n        n1 = len(A)\n        n2 = len(A[0])\n        _ = len(B)\n        m2 = len(B[0])\n        res = list2d(n1, m2, 0)\n        for i in range(n1):\n            for j in range(m2):\n                for k in range(n2):\n                    res[i][j] += A[i][k] * B[k][j]\n                    res[i][j] %= MOD\n        return res\n\n    def _mat_pow(mat, k, MOD):\n        \"\"\" \u884c\u5217mat\u3092k\u4e57\u3059\u308b \"\"\"\n\n        n = len(mat)\n        res = list2d(n, n, 0)\n        for i in range(n):\n            res[i][i] = 1\n        while k > 0:\n            if k & 1:\n                res = mat_dot(res, mat, MOD)\n            mat = mat_dot(mat, mat, MOD)\n            k >>= 1\n        return res\n\n    res = _mat_pow(mat, K, MOD)\n    res = mat_dot(res, init, MOD)\n    return [a[0] for a in res]\n\nL, a, b, M = MAP()\n\nA = [0] * 20\nfor i in range(1, 20):\n    x = 10 ** i\n    # A[i] = bisearch_min(-1, L, lambda m: ceil(x-a, b) <= m)\n    A[i] = max(min(ceil(x-a, b), L), 0)\nC = [0] * 20\nfor i in range(1, 20):\n    C[i] = A[i] - A[i-1]\n\ninit = [0, a, 1]\nfor d in range(1, 20):\n    K = C[d]\n    if K == 0:\n        continue\n    mat = [\n        # dp0[i] = dp0[i-1]*10^d + dp1[i-1]*1 + 1*0\n        [pow(10, d, M), 1, 0],\n        # dp1[i] = dp0[i-1]*0 + dp1[i-1]*1 + 1*b\n        [0, 1, b],\n        # 1 = dp0[i-1]*0 + dp1[i-1]*0 + 1*1\n        [0, 0, 1],\n    ]\n    res = mat_pow(mat, init, K, M)\n    init[0] = res[0]\n    init[1] = res[1]\nans = res[0]\nprint(ans)\n\n# dp0 = [0] * (L+1)\n# dp1 = [0] * (L+1)\n# dp0[0] = 0\n# dp1[0] = a\n# for i in range(1, L+1):\n#     dp0[i] = (dp0[i-1]*pow(10, int(log10(dp1[i-1]))+1, M) + dp1[i-1]) % M\n#     dp1[i] = dp1[i-1] + b\n# ans = dp0[-1]\n# print(ans)\n", "import numpy as np\nl, a, b, m = list(map(int, input().split()))\n# l = 107\n# a = 10000000000007  # 10**13 + 7\n# b = 1000000000000007  # 10**15 + 7\n# m = 998244353\n\ns_max = a + b * (l - 1)\n\n# ten_pow[i] = 10**i\nten_pow = [1]\nwhile ten_pow[-1] <= s_max:\n    ten_pow.append(ten_pow[-1] * 10)\n\n# d[i] = (s_j <= 10**i - 1 \u306a\u308bj\u306e\u6570)\nD_MAX = len(ten_pow)\nd = [0] * D_MAX\nfor i in range(D_MAX):\n    if ten_pow[i] >= a:\n        d[i] = max((ten_pow[i] - 1 - a) // b, 0)\nd[-1] = l - 1\n\n# cd[i] = ((i+1)\u6841\u306es\u306e\u8981\u7d20\u6570(s_0\u3092\u9664\u304f))\ncd = [d[i + 1] - d[i] for i in range(len(d) - 1)]\n# print(ten_pow)\n# print(d)\n# print(cd)\n\ny = np.array([a, a + b, 1]).T % m\nfor i in range(len(cd)):\n    x = np.array([[ten_pow[i + 1] % m, 1, 0], [0, 1, b], [0, 0, 1]])\n    x %= m\n    # print(x)\n    # print('y', y)\n    k = cd[i]\n    while k > 0:\n        if k & 1:\n            y = np.dot(x, y) % m\n            # print('y', y)\n        x = np.dot(x, x) % m\n        k = k >> 1\n\nans = y[0] % m\nprint(ans)\n", "l,a,b,m = list(map(int,input().split()))\n\n# c111 -> 1001001001\u307f\u305f\u3044\u306a\u3084\u3064\u3092\u6c42\u3081\u308b\n# n : \u584a\u306e\u6570\n# l : \u4e00\u3064\u306e\u584a(00..001)\u306e\u9577\u3055\n# m : mod\n# ex) n=3, l=2 -> 10101\ndef c111(n, l, m):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n % 2 == 1:\n        return (c111(n - 1, l, m) * pow(10, l, m) + 1) % m\n    half = c111(n // 2, l, m)\n    return (half * pow(10, (n // 2) * l, m) + half) % m\n\n# c123 -> 1002003004\u307f\u305f\u3044\u306a\u3084\u3064\u3092\u6c42\u3081\u308b\n# n : \u584a\u306e\u6570\n# l : \u4e00\u3064\u306e\u584a(00..001)\u306e\u9577\u3055\n# m : mod\n# ex) n=3, l=2 -> 10203\ndef c123(n, l, m):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n % 2 == 1:\n        return (c123(n - 1, l, m) + c111(n, l, m)) % m\n    half = c123(n // 2, l, m)\n    return (half * pow(10, (n // 2) * l, m) + half + (n // 2) * c111(n // 2, l, m)) % m\n\nfst, lst = a, a + b * (l - 1)\n\nfst_l, lst_l = len(str(fst)), len(str(lst))\n\nres, margin = 0, 0\nfor keta in reversed(list(range(fst_l, lst_l + 1))):\n    num_l = a + b * ((10 ** (keta - 1) - a + b - 1) // b)\n    num_r = a + b * ((10 ** keta - a + b - 1) // b - 1)\n    if keta == fst_l:\n        num_l = fst\n    if keta == lst_l:\n        num_r = lst\n    if num_l > num_r:\n        continue\n    sz = (num_r - num_l) // b + 1\n    _111 = num_l * c111(sz, keta, m)\n    _123 = b * c123(sz - 1, keta, m)\n    res += (pow(10, margin, m) * (_111 + _123)) % m\n    margin += sz * keta\nprint((res % m))\n", "from operator import mul\n\ndef getMatrixProduct(Ass, Bss, MOD):\n    BssTr = [list(Bs) for Bs in zip(*Bss)]  # \u8ee2\u7f6e\n    ansss = [[sum(map(mul, As, Bs)) % MOD for Bs in BssTr] for As in Ass]\n    return ansss\n\ndef getMatrixPower(Ass, n, MOD):\n    sizeA = len(Ass)\n    ansss = [[0]*(sizeA) for _ in range(sizeA)]\n    for i in range(sizeA):\n        ansss[i][i] = 1\n    while n:\n        if n & 1:\n            ansss = getMatrixProduct(ansss, Ass, MOD)\n        Ass = getMatrixProduct(Ass, Ass, MOD)\n        n //= 2\n    return ansss\n\nL, A, B, M = list(map(int, input().split()))\n\nAs = [[A%M], [A%M], [1]]\niPrev = 0\nd = 1\nwhile True:\n    i = (10**d-1-A) // B\n    if i > L-1:\n        i = L-1\n    num = i-iPrev\n    if num > 0:\n        Css = [[10**d,1,B%M], [0,1,B%M], [0,0,1]]\n        PowCss = getMatrixPower(Css, num, M)\n        As = getMatrixProduct(PowCss, As, M)\n    if i == L-1:\n        break\n    iPrev = max(0, i)\n    d += 1\n\nprint((As[0][0]))\n", "def mmult(A, B):\n    nonlocal mod\n    n, m, l = len(A), len(B), len(B[0])\n    ret = [[0]*l for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            for k in range(l):\n                ret[i][k] = (ret[i][k]+A[i][j]*B[j][k])%mod\n    return ret\ndef mpow(A, n):\n    if n == 0: return [[1 if i == j else 0 for j in range(len(A))] for i in range(len(A))]\n    if n % 2: return mmult(mpow(A, n-1), A)\n    return mpow(mmult(A, A), n//2)\n\nL, A, B, mod = map(int, input().split())\nY = [max((10**i-A+B-1)//B,0) for i in range(20)]\ns = 0\nfor i in range(19):\n    a, b, n = A+B*Y[i], B, max(min(L, Y[i+1])-Y[i], 0)\n    M = [[10**(i+1), 0, 0], [1, 1, 0], [0, 1, 1]]\n    s = mmult([[s,a,b]], mpow(M,n))[0][0]\n\nprint(s)", "def f_takahashi_basics_in_education_and_learning(L, A, B, M, DIGIT_MAX=18):\n    \"\"\"numpy\u306e\u884c\u5217\u6f14\u7b97\u3060\u3068 L, A, B \u304c 10**18 \u7a0b\u5ea6\u306e\u3068\u304d\u3046\u307e\u304f\u52d5\u4f5c\u3057\u306a\u3044\"\"\"\n    def identity_matrix(n):\n        \"\"\"n\u00d7n\u5358\u4f4d\u884c\u5217\"\"\"\n        return [[int(i == j) for i in range(n)] for j in range(n)]\n\n    def multiply(a, b):\n        \"\"\"\u884c\u5217a, b\u306e\u7a4d\"\"\"\n        row = len(a)\n        col = len(b[0])\n        t = len(b)\n        ret = [[0] * col for _ in range(row)]\n        for i in range(row):\n            for j in range(col):\n                for k in range(t):\n                    ret[i][j] += a[i][k] * b[k][j]\n        for i in range(row):\n            for j in range(col):\n                ret[i][j] %= M\n        return ret\n\n    def power(a, k):\n        \"\"\"\u884c\u5217a\u306ek\u4e57\"\"\"\n        n = len(a)\n        ret = identity_matrix(n)\n        while k:\n            if k & 1:\n                ret = multiply(ret, a)\n            a = multiply(a, a)\n            k >>= 1\n        return ret\n \n    # \u6570\u5217\u306b\u5bfe\u3057\u3066\u3001d\u6841\u306e\u8981\u7d20\u306e\u500b\u6570\u3092\u6c42\u3081\u308b\n    num_pow_d = [0] * (DIGIT_MAX + 1)\n    for d in range(DIGIT_MAX + 1):\n        if 10**d - 1 < A:\n            continue\n        # d\u306b\u5bfe\u3057\u3066A + B*n <= 10**d - 1 \u3068\u306a\u308b\u6700\u5927\u306en(L\u4ee5\u4e0b\u3057\u304b\u53d6\u308a\u3048\u306a\u3044)\n        num_pow_d[d] = min(((10**d - 1 - A) // B) + 1, L)  # +1\u306fn\u304c0\u30b9\u30bf\u30fc\u30c8\u306e\u305f\u3081\n    ans = 0\n    array = [[0, A, 1]]\n    for d in range(1, DIGIT_MAX + 1):\n        c_d = num_pow_d[d] - num_pow_d[d - 1]\n        matrix = [[10**d, 0, 0], [1, 1, 0], [0, B, 1]]\n        array = multiply(array, power(matrix, c_d))\n    return array[0][0]\n\nL, A, B, M = [int(i) for i in input().split()]\nprint(f_takahashi_basics_in_education_and_learning(L, A, B, M))", "import numpy as np\nimport math\n\nL, A, B, M = list(map(int, input().split()))\n\ndef f(i):\n    return A+B*i\n\ndef Cd(d):\n    return bisect(-1, L, d+1)-bisect(-1, L, d)\n\ndef is_ok(i, d):\n    return len(str(f(i))) >= d\n\ndef bisect(ng, ok, d):\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid, d):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n\ndef pow_mat(a, x, p=math.inf):\n    ret = np.eye(a.shape[0], dtype=int)\n    tmp = a\n    for i in range(x.bit_length()):\n        if x >> i & 1:\n            ret = np.mod(ret @ tmp, p)\n        tmp = np.mod(tmp @ tmp, p)\n    return ret\n\nret = np.eye(3, dtype=int)\nfor d in range(1, 19):\n    a = np.array([[pow(10, d, M), 0, 0],\n                  [1, 1, 0],\n                  [0, B, 1]], dtype=int)\n    ret = np.mod(ret @ pow_mat(a, Cd(d), M), M)\nprint((np.mod(np.array([0, A%M, 1]) @ ret, M)[0]))\n", "L, a, b, m = map(int, input().split())\n\nk = 18\n\nc = [0] * k\n\nt = a + b * (L - 1)\n\np = 9\ntemp = 0\nfor i in range(k):\n    if a <= p:\n        c[i] = (min(p, t) - a) // b + 1 - temp\n        temp += c[i]\n    if t <= p:\n        break\n    p = (p + 1) * 10 - 1\n\ndef calc_mat(P, Q):\n    ret = [[0,0,0],[0,0,0],[0,0,0]]\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                ret[i][j] += P[i][k] * Q[k][j]\n            ret[i][j] %= m\n    return ret\n\n\ns = a\nx = 0\nfor i in range(k):\n    if c[i] == 0:\n        continue\n    mat = [[10 ** (i + 1), 0, 0], [1,1,0], [0,b,1]]\n    temp_mat = [[1,0,0],[0,1,0],[0,0,1]]\n    d = list(reversed(bin(c[i])[2:]))\n    p = 1\n    for z in d:\n        if z == '1':\n            temp_mat = calc_mat(temp_mat, mat)\n        mat = calc_mat(mat, mat)\n    #print(temp_mat)\n    temp_x = (temp_mat[0][0] * x + temp_mat[1][0] * s + temp_mat[2][0]) % m\n    s = (temp_mat[0][1] * x + temp_mat[1][1] * s + temp_mat[2][1]) % m\n    x = temp_x\n    #print(x, s)\n\nprint(x)", "l, a, b, mod = map(int, input().split())\n\ndef mul(m1, m2):\n    m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    for i in range(3):\n        for j in range(3):\n            m[i][j] = sum(m1[i][k] * m2[k][j] for k in range(3)) % mod\n    return m\n\n# mat = [[1, 0, 0],                                                                                                                                                                                                                                            \n#        [0, 1, 0],                                                                                                                                                                                                                                            \n#        [0, 0, 1]]                                                                                                                                                                                                                                            \n# vec = (0, a, 1)                                                                                                                                                                                                                                              \n\nmat = [[0, 0, 0],\n       [a, 0, 0],\n       [1, 0, 0]]\nd = 1\ne = a + b * (l - 1)\nwhile e >= d:\n    d *= 10\n    if a >= d:\n        continue\n    t = (min(d - 1, e) - a) // b + 1\n    a += b * t\n    bit = [[d, 1, 0],\n           [0, 1, b],\n           [0, 0, 1]]\n    while t > 0:\n        if t & 1:\n            mat = mul(bit, mat)\n        bit = mul(bit, bit)\n        t //= 2\n\n# print((mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2]) % mod)                                                                                                                                                                                  \nprint(mat[0][0])", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque\nimport numpy as np\nsys.setrecursionlimit(10**9)\nINF=10**18\nMOD=10**9+7\ninput=lambda: sys.stdin.readline().rstrip()\nYesNo=lambda b: bool([print('Yes')] if b else print('No'))\nYESNO=lambda b: bool([print('YES')] if b else print('NO'))\nint1=lambda x:int(x)-1\n\ndef main():\n    L,A,B,M=map(int,input().split())\n    S=lambda i:A+B*i\n    sec=[]\n    \n    def nibutan(ok,ng,k):\n        while abs(ok-ng) > 1:\n            mid = (ok + ng) // 2\n            if solve(mid,k):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    \n    def solve(mid,k):\n        return len(str(S(mid)))<k\n    \n    left=L-1\n    for k in range(19,0,-1):\n        if len(str(S(left)))==k:\n            right=nibutan(-1,left,k)\n            sec.append((k,left,right))\n            left=right\n    \n    X=np.array([0,A%M,1],dtype=np.int64)\n    for k,left,right in sec[::-1]:\n        n=left-right\n        doubling=[np.array([[pow(10,k,M),0,0],[1,1,0],[0,B%M,1]],dtype=np.int64)]\n        for i in range((10**18).bit_length()):\n            doubling.append(np.dot(doubling[i],doubling[i])%M)\n        n=left-right\n        for i in range(len(doubling)):\n            if n&1:\n                X=np.dot(X,doubling[i])%M\n            n>>=1\n            if n==0:\n                break\n    print(X[0])\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n#from numpy import matrix, eye, dot\ndef productMatrix(N, A, B):\n    Ret = [[0]*N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                Ret[i][j] += A[i][k]*B[k][j]\n    return Ret\ndef modMatrix(N, A, Q): #N\u00d7N\u884c\u5217\u306emod\n    for i in range(N):\n        for j in range(N):\n            A[i][j] %= Q\n    return\n\ndef powOfMatrix(N, X, n, Q): #N\u00d7N\u884c\u5217\u306en\u4e57\n    Ret = [[1,0,0],[0,1,0],[0,0,1]]\n    power = '{:060b}'.format(n)[::-1] #log2(pow(10,18)) < 60\n    for p in power:\n        if p == \"1\":\n            Ret = productMatrix(N,Ret, X)\n            modMatrix(N, Ret, Q)\n        X = productMatrix(N,X,X)\n        modMatrix(N, X, Q)\n    return Ret\n\ndef main():\n    L, A, B, M = list(map( int, input().split()))\n    s = A\n    ANS = [[1,0,0],[0,1,0],[0,0,1]]\n    for i in range(1, 37):\n        if s >= pow(10,i):\n            continue\n        P = [[pow(10, i, M), 0, 0], [1,1,0], [0,B,1]]\n        step = (pow(10,i)-s+B-1)//B\n        if L <= step:\n            ANS = productMatrix(3,ANS,powOfMatrix(3,P,L,M))\n            modMatrix(3,ANS,M)\n            break\n        ANS = productMatrix(3,ANS, powOfMatrix(3,P, step,M))\n        modMatrix(3,ANS, M)\n        L -= step\n        s += step*B\n    print(( (ANS[1][0]*A + ANS[2][0])%M))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "L,A,B,M=list(map(int,input().split()))\nK=19\ngap=[-1 for k in range(K)]\nfor k in range(K):\n    tmp=10**k-A\n    if tmp%B==0:\n        gap[k]=-1+tmp//B\n    else:\n        gap[k]=tmp//B\n    gap[k]=min(L-1,gap[k])\n    gap[k]=max(-1,gap[k])\nnum=[0 for k in range(K)]\nfor k in range(1,K):\n    #k-1,k\n    num[k]=-gap[k-1]+gap[k]\ndef matrix(d):\n    return [[pow(10,d,M),1,0],[0,1,B],[0,0,1]]\ndef mattime(P,Q):\n    R=[[0,0,0],[0,0,0],[0,0,0]]\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                R[i][j]+=P[i][k]*Q[k][j]\n                R[i][j]%=M\n    return R\ndef matexp(P,n):\n    if n==0:\n        return [[1,0,0],[0,1,0],[0,0,1]]\n    elif n%2==0:\n        return matexp(mattime(P,P),n//2)\n    else:\n        return mattime(P,matexp(mattime(P,P),n//2))\nMat=[[1,0,0],[0,1,0],[0,0,1]]\nfor d in range(1,K):\n    Mat=mattime(matexp(matrix(d),num[d]),Mat)\nprint(((A*Mat[0][1]+Mat[0][2])%M))\n", "import sys\nsys.setrecursionlimit(pow(10, 6))\n# input = sys.stdin.readline\n\nimport numpy as np\n\ndef pow_matmul(r, n, m):\n  if n == 1:\n    return r\n  if n % 2 == 0:\n    _r = pow_matmul(r, n//2, m)\n    return np.mod(np.dot(_r, _r), m)\n  else:\n    _r = pow_matmul(r, n//2, m)\n    _r = np.mod(np.dot(_r, _r), m)\n    return np.mod(np.dot(r, _r), m)\n\ndef main():\n  l, a, b, m = list(map(int, input().split()))\n  c = [min(max(0, (10**i - a - 1) // b + 1), l) for i in range(19)]\n  ans = 0\n  r = np.ones((3,3))\n  s = np.array([0, a%m, 1])\n\n  for d in range(1, 19):\n    dnum = c[d] - c[d-1]\n    if dnum==0:\n      continue\n    r_s = np.array([[pow(10, d, m), 1, 0], [0, 1, (b%m)], [0, 0, 1]])\n    r = pow_matmul(r_s, dnum, m)\n    s = np.mod(np.dot(r, s), m)\n    if c[d] > l:\n      break\n  print((s[0]))\n\n\ndef __starting_point():\n  main()\n\n__starting_point()", "import numpy as np\n\n\ndef exp_np(a, e, m):\n    r = np.identity(a.shape[0], dtype=np.int64)\n    t = a.copy()\n    while e:\n        if e % 2:\n            r = np.dot(r, t) % m\n        t = np.dot(t, t) % m\n        e >>= 1\n    return r\n\n\nl, a, b, m = list(map(int, input().split()))\n\nfirst_d = len(str(a))\ntail = a + b * (l - 1)\n\nlo = -1\nstate = np.array([[0, a % m, 1]])\n\nfor d in range(first_d, 19):\n    hi = min((10 ** d - 1 - a) // b, l - 1)\n    cnt = hi - lo\n    coe = np.array([\n        [pow(10, d, m), 0, 0],\n        [1, 1, 0],\n        [0, b % m, 1]\n    ], dtype=np.int64)\n\n    coe = exp_np(coe, cnt, m)\n    state = np.dot(state, coe) % m\n\n    lo = hi\n    if hi == l - 1:\n        break\n\nprint((state[0][0]))\n", "import numpy as np\n\nL, A, B, M = (int(i) for i in input().split())\nketa = [0] * 18\nfor i in range(18):\n    keta[i] = min((10**i - A - 1)//B, L-1)\nketa.reverse()\nfor i in range(18):\n    if keta[i] < 0:\n        keta[i] = -1\n        break\nketa.reverse()\n\ndef power(g, N, M):\n    if N == 0:\n        g = np.array([1, 0, 0, 0, 1, 0, 0, 0, 1]).reshape(3, 3)\n    elif N == 1:\n        pass\n    elif N%2 == 0:\n        g = np.linalg.matrix_power(power(g, N//2, M), 2)\n    elif N%2 == 1:\n        g = np.dot(g, power(g, N-1, M))\n    return g%M\n\nans = 0\nfor i in range(18):\n    N = i + 1\n    mi = keta[i] + 1\n    if mi < 0:\n        continue\n    if i != 17:\n        ma = keta[i+1]\n    else:\n        ma = L-1\n    if mi >= L:\n        break\n    t = np.array([ans, (A + B*mi)%M, 1])\n    g = np.array([10**N%M, 0, 0, 1, 1, 0, 0, B%M, 1]).reshape(3, 3)\n    g = power(g, ma-mi+1, M)\n    g = np.dot(t, g)\n    ans = g[0]%M\nprint(ans)", "import math, itertools\n\nL, A, B, mod = [int(_) for _ in input().split()]\n\n\ndef sum_ri(r, n, mod):\n    #1,r,...,r**(n-1)\n    if r == 1:\n        return n % mod\n    else:\n        #(r**n-1)/(r-1)=Q*mod+R\n        #R**n-1=Q*mod*(r-1)+R*(r-1)\n        return (pow(r, n, mod * (r - 1)) - 1) // (r - 1) % mod\n\n\ndef sum_iri(r, n, mod):\n    #0,1*r,...,(n-1)*r**(n-1)\n    if r == 1:\n        return n * (n - 1) // 2 % mod\n    else:\n        r1 = r - 1\n        p = pow(r, n, mod * r1**2)\n        ret = (n - 1) * p * r1 + r1 - (p - 1)\n        ret //= r1**2\n        ret %= mod\n        return ret\n\n\nans = 0\n\nfor digit in range(1, 20):\n    #digit\u6841\u306e\u7dcf\u548c\n    #10**(digit-1)<=A+B*i<10**digit\n    #(10**(digit-1)-A-1)//B+1<=i<=(10**digit-A-1)//B\n    ileft = max(0, (10**(digit - 1) - A - 1) // B + 1)\n    iright = min(L - 1, (10**digit - A - 1) // B)\n    if L <= ileft:\n        break\n    if ileft > iright:\n        continue\n    idiff = iright - ileft + 1\n    #ileft<=i<=iright\n    #sum(ileft,iright) (A+B*i)10**(digit*(iright-i))\n    #sum(0,iright-ileft)(A+B*iright-B*j))*(10**digit)**j\n    pow10digit = pow(10, digit, mod)\n    now = (A + B * iright) * sum_ri(pow10digit, idiff, mod)\n    now -= B * sum_iri(pow10digit, idiff, mod)\n    ans *= pow(10, digit * idiff, mod)\n    ans += now\n    ans %= mod\nprint(ans)\n", "from numpy.linalg import matrix_power\nfrom numpy import dot, array\n\nclass mint:\n    def __init__(self, n):\n        self.n = n % mod\n\n    def __add__(self, other):\n        return mint(self.n + other.n)\n\n    def __mul__(self, other):\n        return mint(self.n * other.n)\n\n    def __repr__(self):\n        return str(self.n)\n\n\nL, A, B, mod = map(int, input().split())\n\nans = array([mint(0), mint(A), mint(B)])\n\nsize = 0\nfor d in range(1, 19):\n    x = pow(10, d, mod)\n    T = array([\n        [mint(x), mint(0), mint(0)],\n        [mint(1), mint(1), mint(0)],\n        [mint(0), mint(1), mint(1)],\n    ])\n\n    cnt = min(L - size, max(0, 10 ** d - 1 - A) // B - size + 1)\n    if cnt > 0:\n        ans = dot(ans, matrix_power(T, cnt))\n\n    size += cnt\n    if size >= L:\n        break\n\nprint(ans[0])", "#!/usr/bin/env python3\n\nMOD = None\n\ndef matunit(n):\n    return [ [ int(y == x) for x in range(n) ] for y in range(n) ]\n\ndef matadd(a, b):\n    assert len(a) == len(b)\n    assert len(a[0]) == len(b[0])\n    h = len(a)\n    w = len(a[0])\n    c = [ [ a[y][x] + b[y][x] for x in range(w) ] for y in range(h) ]\n    return c\n\ndef matmul(a, b):\n    assert len(a[0]) == len(b)\n    h = len(a)\n    k = len(b)\n    w = len(b[0])\n    c = [ [ 0 for _ in range(w) ] for _ in range(h) ]\n    for y in range(h):\n        for z in range(k):\n            for x in range(w):\n                c[y][x] += a[y][z] * b[z][x]\n    for y in range(h):\n        for x in range(w):\n            c[y][x] %= MOD\n    return c\n\ndef matpow(a, k):\n    assert len(a) == len(a[0])\n    n = len(a)\n    b = matunit(n)\n    while k:\n        if k & 1:\n            b = matmul(b, a)\n        a = matmul(a, a)\n        k >>= 1\n    return b\n\ndef binsearch(l, r, pred): # [l, r)\n    assert l < r\n    l -= 1\n    while r - l > 1:\n        m = (l + r) // 2\n        if pred(m):\n            r = m\n        else:\n            l = m\n    return r\n\ndef main():\n    l, a, b, m = list(map(int, input().split()))\n\n    nonlocal MOD\n    MOD = m\n\n    x = [ [ 0 ], [ a ], [ 1 ] ]  # (answer, s_i, 1)\n    DIGITS = 20\n    d = [ binsearch(0, l, lambda i: len(str(a + b * i)) >= d) for d in range(DIGITS) ]\n    for i in range(DIGITS - 1):\n        l = d[i]\n        r = d[i + 1]\n        f = [ [ 10 ** i, 1, 0 ], [ 0, 1, b ], [ 0, 0, 1 ] ]\n        x = matmul(matpow(f, r - l), x)\n    print((x[0][0] % m))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Atcoder Problem Solving\n# F - Takahashi's Basics in Education and Learning\nimport math\nL, A, D, mod = map(int, input().split())\nque = []\n\nans = 0\n# 1\u6841\u3001......20\u6841\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u985e\u3059\u308b\nfor i in range(1, 22):\n    #10**(i-1) <= A+D*(j) < 10**(i)\n    if (10**(i-1)-A+D) % D == 0:\n        lowest = max(1, (10**(i-1)-A+D)//D)\n    else:\n        lowest = max(1, (10**(i-1)-A+D)//D+1)\n    highest = 0\n    if (10**i-A+D) % D == 0:\n        highest = min((10**i-A+D)//D-1, L)\n\n    else:\n        highest = min((10**i-A+D)//D, L)\n\n    if 1 <= lowest <= highest:\n        que.append((i, lowest, highest))\n\n\ndef poly_sum(X, N, mod):\n    # return X^N +    .... X^1+1 mod\n    # O(logN)\n    if N == 0:\n        return 1\n    if N == 1:\n        return (X+1) % mod\n    else:\n        if N % 2 == 0:\n            tmp_res = poly_sum(X, N//2, mod)\n            return ((pow(X, N//2, mod)+1)*tmp_res-pow(X, N//2, mod)) % mod\n\n        elif N % 2 != 0:\n            tmp_res = poly_sum(X, N//2, mod)\n            return (pow(X, N//2+1, mod)+1)*tmp_res % mod\n\n\ndef sum_of_poly_sum(X, N, mod):\n    # return poly_sum(X,N,mod)+ poly_sum(X,N-1,mod) +poly_sum(X,N-2,mod) +.....  + poly_sum(X,1,mod) + poly_sum(X,0,mod)\n    # O(logN*logN)\n    if N == 0:\n        return poly_sum(X, 0, mod)\n    elif N == 1:\n        return (poly_sum(X, 1, mod)+poly_sum(X, 0, mod)) % mod\n    else:\n        return ((sum_of_poly_sum(X, (N-1)//2, mod))*(pow(X, N//2+1, mod)+1)+(N//2+1)*poly_sum(X, N//2, mod)) % mod\n\n\ndef find_mod(length, lowest, highest, mod):\n    # length \u6841\u3000\u306e lowest \u9805\u76ee\u304b\u3089 highest \u9805\u76ee\u306b\u304a\u3051\u308b\u9023\u7d50\u5de8\u5927\u6570\u306emodular\n    X = pow(10, length, mod)\n    if highest > lowest:\n        base = (A+D*(lowest-1))*poly_sum(X, highest-lowest, mod) + \\\n            D*sum_of_poly_sum(X, highest-lowest - 1, mod)\n    elif highest == lowest:\n        base = A+D*(lowest-1)\n    return base % mod\n\n\nque.reverse()\n\ndigits = 0\nfor length, lowest, highest in que:\n    ans += find_mod(length, lowest, highest, mod)*pow(10, digits, mod)\n    ans %= mod\n    digits += length*(highest+1-lowest)\n\nprint(ans % mod)", "def S1(r,T,M):\n  # 1+r+...+r^{T-1}\n  # (r^T-1)/(r-1)\n  # mod M(r-1)\u3067\u8a08\u7b97\u3059\u308b\n  if r == 1:\n    return T%M\n  x = pow(r,T,M*(r-1)) - 1\n  return (x//(r-1))%M\n\ndef S2(r,T,M):\n  # sum ir^i\n  if r == 1:\n    x = T*(T-1)//2\n    return x%M\n  Mr = M*(r-1)\n  x = (T-1) * pow(r,T,Mr)\n  x -= S1(r,T,Mr)\n  x += 1\n  x //= (r-1)\n  return x\n\ndef S(A,B,L,M):\n  result = 0\n  d = len(str(A)) # \u6841\u6570\n  start = A\n  r = 10**d\n  while True:\n    n1 = ((r-1)-A)//B+1\n    items = min(n1,L) # \u305d\u306e\u6841\u306e\u9805\u6570\n    last = A + (items-1)*B\n    x = last * S1(r,items,M)\n    x -= B * S2(r,items,M)\n    result *= pow(r,items,M)\n    result += x\n    result %= M\n    # \u30d1\u30e9\u30e1\u30fc\u30bf\u306e\u66f4\u65b0\n    r *= 10\n    d += 1 # \u4e0d\u8981\u304b\u3082\n    L -= items\n    A += B*items\n    if L <= 0:\n      break\n  return result%M\n\nL,A,B,M = map(int,input().split())\nanswer = S(A,B,L,M)\nprint(answer)", "import math\nimport sys\nsys.setrecursionlimit(10000)\n\ndef nasu(A, B, L, D, M):\n  if L == 1:\n    return A\n  ans = nasuA(A, L, D, M)\n  ans = (ans + nasuB(1, L - 1, D, M) * B * D) % M\n  return ans % M\n\ndef nasuB(B, L, D, M):\n  if L == 1:\n    return B\n  ans = powB(1, L, D, M) % M\n  return ans % M\n\ndef powB(B, L, D, M):\n  if L == 1:\n    return B\n  k = 0\n  t = D\n  while T[k + 1] <= L:\n    k += 1\n    t = t * t % M\n    if k + 1 == len(T):\n      break\n  ans = powB2(B, T[k], D, M) % M\n  if L != T[k]:\n    ans += nasu(T[k] + 1, 1, L - T[k], D, M) * t % M \n    #ans += powB(1, L - T[k], D, M) * t % M\n    #ans += powA(-T[k], L - T[k], D, M) * t % M\n  return ans % M\n \ndef powB2(B, L, D, M):\n  if L == 1:\n    return 1\n  ans = powB2(B * 2, L // 2, D * D % M, M) * (D + 1) % M\n  ans = ans + nasuA(1, L // 2, D * D % M, M) * B * D % M\n  return ans\n\ndef nasuA(A, L, D, M):\n  if L == 1:\n    return A\n  ans = powA(A, L, D, M) % M\n  return ans % M\n\ndef powA(A, L, D, M):\n  if L == 1:\n    return A\n  k = 0\n  t = D\n  while T[k + 1] <= L:\n    k += 1\n    t = t * t % M\n    if k + 1 == len(T):\n      break\n  ans = powA2(A, T[k], D, M)\n  if L != T[k]:\n    ans +=  powA(A, L - T[k], D, M) * t % M\n  return ans % M\n \ndef powA2(A, L, D, M):\n  if L == 1:\n    return A\n  return powA2(A, L // 2, D * D % M, M) * (D + 1) % M\n\ndef powmod(a, n, M):\n  ans = 1\n  while n:\n    if n & 1:\n      ans = (ans * a) % M\n    a = a * a % M\n    n >>= 1\n  return ans\n\nL, A, B, M = list(map(int, input().split()))\n\nN = math.ceil(math.log(A + 1, 10))\nk = pow(10, N)\nD = [[0, 0] for _ in range(20)]\nwhile L > 0:\n  n = min(L, (k - 1 - A) // B + 1)\n  D[N - 1][0] = A\n  D[N - 1][1] = n\n  L -= n\n  N += 1\n  k *= 10\n  A += n * B\nT = [1]\nwhile T[-1] < 10 ** 19:\n  T.append(T[-1] * 2)\nBI = (((B // M) + 1) * M - B) % M\nans = 0\nfor i in range(20):\n  l = D[i][1]\n  a = D[i][0] + (l - 1) * B\n  if l == 0:\n    continue\n  ans = ans * powmod(pow(10, i + 1), l, M) % M\n  ans = (ans + nasu(a, BI, l, pow(10, i + 1), M)) % M\nprint(ans)", "import sys\nimport time\n\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\ndef main():\n    import numpy as np\n    l, a, b, m = list(map(int, readline().split()))\n    d_min = len(str(a))\n    d_max = len(str(a + (l - 1) * b))\n    count_d = [-1] * 19\n\n    prev = -1\n    for i in range(d_min, d_max + 1):\n        power = 10 ** i\n        ok = 0\n        ng = l + 1\n        while abs(ng - ok) > 1:\n            mid = (ok + ng) // 2\n            x = a + mid * b\n            if x < power:\n                ok = mid\n            else:\n                ng = mid\n        ok = min(ok, l - 1)\n        count_d[i] = ok - prev\n        prev = ok\n\n    res = np.array([0, a, 1], dtype=\"int64\")\n    res = np.mod(res, m)\n\n    for i in range(19):\n        count = count_d[i]\n        if count == -1:\n            continue\n        mat = np.array([[10 ** i, 0, 0],\n                        [1, 1, 0],\n                        [0, b, 1]], dtype=\"int64\")\n        mat = np.mod(mat, m)\n        cur = np.eye(3, dtype=\"int64\")\n        count_bit = format(count, \"b\")\n        for bit in count_bit[::-1]:\n            if bit == \"1\":\n                cur = np.dot(cur, mat)\n                cur = np.mod(cur, m)\n            mat = np.dot(mat, mat)\n            mat = np.mod(mat, m)\n        res = np.dot(res, cur)\n        res = np.mod(res, m)\n\n    print((res[0]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(100000000)\n\ndef mult(A, B, mod): #\u884c\u5217A, B\u306e\u5185\u7a4d\u3092\u6c42\u3081\u308b\u3002\n    D = [[(A[0][0] * B[0][0]) % mod, 0, 0], [0, 1, 0], [0, 0, 1]]\n    D[1][0] = (A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod\n    D[2][0] = (A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]) % mod\n    D[2][1] = (A[2][1]*B[1][1]+A[2][2]*B[2][1]) % mod\n    return D\n\ndef double(C, mod):\n    D = [[pow(C[0][0], 2, mod), 0, 0], [(C[1][0] * C[0][0] + C[1][0]) % mod, 1, 0], [(C[2][0] * C[0][0] + C[2][1] * C[1][0] + C[2][0]) % mod, (C[2][1] * 2) % mod, 1]]\n    return D\n\ndef Cpow(C, n, mod):\n    if n == 1: return C\n    else:\n        D = double(C, mod)\n        if n % 2 == 0:\n            return Cpow(D, n // 2, mod)\n        else:\n            return mult(Cpow(D, n // 2, mod), C, mod)\n\ndef solve():\n    L, a, b, M = map(int, input().split())\n    X = 0\n    s = a\n    nd = -1\n    ne = 0\n    for d in range(1, 19):\n        ne = min((pow(10, d) - a - 1) // b, L-1)\n        if ne < 0: continue\n        elif ne == nd: continue\n        C = [[pow(10, d, M), 0, 0], [1, 1, 0], [0, b % M, 1]]\n        D = Cpow(C, ne - nd, M)\n        X = (X * D[0][0] + D[1][0] * s + D[2][0]) % M\n        s += D[2][1]\n        if ne == L - 1: break\n        nd = ne\n    print(X)\n    return\n\ndef __starting_point():\n    solve()\n__starting_point()", "L, A, B, M = list(map(int, input().split()))\n\nten = 0\n\ndef pow_(x, t):\n  if t == 0:\n    return 1\n  if t % 2 == 1:\n    return (pow_(x, t - 1) * x) % M\n  else:\n    y = pow_(x, t // 2)\n    return (y * y) % M\n\ndef f(l):\n  if l == 0:\n    return 0\n  if l % 2 == 1:\n    pl = l - 1\n    x = f(pl)\n    return x * ten + 1\n  else:\n    pl = l // 2\n    x = f(pl)\n    return x * pow_(ten, pl) + x\n\ndef g(l):\n  if l == 0:\n    return 0\n  if l % 2 == 1:\n    pl = l - 1\n    x = g(pl)\n    return x * ten + B * pl\n  else:\n    pl = l // 2\n    x = g(pl)\n    return x * pow_(ten, pl) + x + B * pl * f(pl)\n\nlast = A + B * (L - 1)\nans = 0\nten = 10\nfor _ in range(18):\n  l = ten // 10\n  r = ten - 1\n  \n  if last < l:\n    ten *= 10\n    continue\n  if A > r:\n    ten *= 10\n    continue\n  na = 0 #\u521d\u9805\n  nl = 0 #\u9577\u3055\n\n  if A >= l:\n    na = A\n  else:\n    na = (l - A + B - 1) // B * B + A\n    na = min(na, last)\n  \n  nlast = 0\n  if last <= r:\n    nlast = last\n  else:\n    nlast = (r - A) // B * B + A\n  nl = (nlast - na) // B + 1\n\n  ans *= pow_(ten, nl) % M\n  ans += (na * f(nl)) % M\n  ans += g(nl) % M\n  ten *= 10\n\nprint((ans % M))\n", "L,A,B,M=map(int,input().split())\nMOD=M\n\n#n*n\u884c\u5217\u306e\u7a4d\u3092\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u3067\u6c42\u3081\u308b\n#\u5358\u4f4d\u884c\u5217\ndef imat(n):\n  ret=[[1 if i==j else 0 for j in range(n)] for i in range(n)]\n  return ret\n\n#\u884c\u5217\u306e\u7a4dA*B\ndef prod_mat(amat,bmat):\n  res_mat = [[sum([amat[i][j]*bmat[j][k] for j in range(len(bmat))]) for k in range(len(bmat[0]))] for i in range(len(amat))]\n  return res_mat  \n\ndef powmod_mat(amat,p):\n  if p==0:\n    return imat(len(amat))\n  else:\n    pow2=powmod_mat(amat,p//2)\n    if p%2==0:\n      res_mat=prod_mat(pow2,pow2)\n    else:\n      res_mat=prod_mat(amat,prod_mat(pow2,pow2))\n\n    for i in range(len(amat)):\n      for j in range(len(amat)):\n        res_mat[i][j]%=MOD\n    return res_mat\n\nslist=[]\nfor d in range(1,19):\n  s=-(-(10**d-A)//B)\n  if s>=0:\n    slist.append(min(s,L))\n  else:\n    slist.append(0)\n#print(slist)\n\ndlist=[slist[0]]\nfor d in range(1,18):\n  dlist.append(slist[d]-slist[d-1])\n#print(dlist)\n\nmat=imat(3)\nfor d in range(18):\n  e=dlist[d]\n  pmat=powmod_mat([[10**(d+1),1,0],[0,1,B],[0,0,1]],e)\n  mat=prod_mat(pmat,mat)\n  for i in range(3):\n    for j in range(3):\n      mat[i][j]%=MOD\n\n#init\nvec=[[0],[A],[1]]\nvec=prod_mat(mat,vec)\nprint(vec[0][0]%MOD)", "from numpy.linalg import matrix_power\nfrom numpy import dot\n\nclass mint:\n    def __init__(self, n):\n        self.n = n % mod\n\n    def __add__(self, other):\n        return mint(self.n + other.n)\n\n    def __mul__(self, other):\n        return mint(self.n * other.n)\n\n    def __repr__(self):\n        return str(self.n)\n\n\nL, A, B, mod = map(int, input().split())\n\nans = [mint(0), mint(A), mint(B)]\n\nsize = 0\nfor d in range(1, 19):\n    x = pow(10, d, mod)\n    T = [\n        [mint(x), mint(0), mint(0)],\n        [mint(1), mint(1), mint(0)],\n        [mint(0), mint(1), mint(1)],\n    ]\n\n    cnt = min(L - size, max(0, 10 ** d - 1 - A) // B - size + 1)\n    if cnt > 0:\n        ans = dot(ans, matrix_power(T, cnt))\n\n    size += cnt\n    if size >= L:\n        break\n\nprint(ans[0])", "import sys\nfrom math import log10\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 19\nMOD = 10 ** 19 + 7\nEPS = 10 ** -10\n\ndef bisearch_min(mn, mx, func):\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef mat_pow(mat, init, K, MOD):\n    \"\"\" \u884c\u5217\u7d2f\u4e57 \"\"\"\n\n    def mat_dot(A, B, MOD):\n        \"\"\" \u884c\u5217\u306e\u7a4d \"\"\"\n\n        if not isinstance(A[0], list) and not isinstance(A[0], tuple):\n            A = [A]\n        if not isinstance(B[0], list) and not isinstance(A[0], tuple):\n            B = [[b] for b in B]\n        n1 = len(A)\n        n2 = len(A[0])\n        _ = len(B)\n        m2 = len(B[0])\n        res = list2d(n1, m2, 0)\n        for i in range(n1):\n            for j in range(m2):\n                for k in range(n2):\n                    res[i][j] += A[i][k] * B[k][j]\n                    res[i][j] %= MOD\n        return res\n\n    def _mat_pow(mat, k, MOD):\n        \"\"\" \u884c\u5217mat\u3092k\u4e57\u3059\u308b \"\"\"\n\n        n = len(mat)\n        res = list2d(n, n, 0)\n        for i in range(n):\n            res[i][i] = 1\n        while k > 0:\n            if k & 1:\n                res = mat_dot(res, mat, MOD)\n            mat = mat_dot(mat, mat, MOD)\n            k >>= 1\n        return res\n\n    res = _mat_pow(mat, K, MOD)\n    res = mat_dot(res, init, MOD)\n    return [a[0] for a in res]\n\nL, a, b, M = MAP()\n\nA = [0] * 20\nfor i in range(1, 20):\n    x = 10 ** i\n    res = bisearch_min(-1, L, lambda m: ceil(x-a, b)-1 < m)\n    A[i] = res\nC = [0] * 20\nfor i in range(1, 20):\n    C[i] = A[i] - A[i-1]\n\ninit = [0, a, 1]\nfor d in range(1, 20):\n    K = C[d]\n    if K == 0:\n        continue\n    mat = [\n        [pow(10, d, M), 1, 0],\n        [0, 1, b],\n        [0, 0, 1],\n    ]\n    res = mat_pow(mat, init, K, M)\n    init[0] = res[0]\n    init[1] = res[1]\nans = res[0]\nprint(ans)\n\n# dp0 = [0] * (L+1)\n# dp1 = [0] * (L+1)\n# dp0[0] = 0\n# dp1[0] = a\n# for i in range(1, L+1):\n#     dp0[i] = (dp0[i-1]*pow(10, int(log10(dp1[i-1]))+1, M) + dp1[i-1]) % M\n#     dp1[i] = dp1[i-1] + b\n# ans = dp0[-1]\n# print(ans)\n"]
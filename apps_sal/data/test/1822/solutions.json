["n, x = list(map(int, input().split()))\nlink1 = list(map(int, input().split()))\nlink2 = [0] * (n + 1)\nfor i, v in enumerate(link1, 1):\n    if v != 0:\n        link2[v] = i\n\n\ntable = [False] * n\ntable[0] = True\nfor i, v in enumerate(link1, 1):\n    if v == 0:\n        len = 0\n        flag = False\n        now = i\n        while now:\n            len += 1\n            if now == x:\n                flag = True\n                pos = len\n            now = link2[now]\n        if not flag:\n            for j in reversed(list(range(n - len))):\n                if table[j]:\n                    table[j + len] = True\nfor i in range(n):\n    if table[i]:\n        print(i + pos)\n", "\n\nn, x = list(map(int, input().split()))\n\na = [-10000] + list(map(int, input().split()))\n\nceps = []\nones = 0\nwas = set()\n\nfor i in range(1, n+1):\n    if i not in was and i not in a:\n        cep = [i]\n        while a[i]:\n            cep.append(a[i])\n            i = a[i]\n        for i in cep:\n            was.add(i)\n        #print(cep)\n        if x in cep:\n            r = cep.index(x)\n            l = len(cep) - r - 1\n        else:\n            if len(cep) == 1:\n                ones += 1\n            else:\n                ceps.append(len(cep))\n\nimport itertools\n\nsums = set(ceps)\nfor i in range(2, len(ceps)+1):\n    for comb in itertools.combinations(ceps, i):\n        sums.add(sum(comb))\nsums.add(0)\n\nposs = set()\n#print(l + 1)\nfor s in sums:\n    for i in range(ones+1):\n        poss.add(l + s + 1 + i)\n    #print(l + s + 1)\n\nfor pos in sorted(poss):\n    print(pos)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\nimport collections\n\n\ndef find(parents, i):\n    if parents[i] == i:\n        return i\n    result = find(parents, parents[i])\n    parents[i] = result\n    return result\n\n\ndef union(parents, i, j):\n    i, j = find(parents, i), find(parents, j)\n    parents[i] = j\n\n\ndef __starting_point():\n    n, x = list(map(int, input().split()))\n    a = {i + 1: int(ai) for i, ai in enumerate(input().split())}\n\n    parents = {i: i for i in a}\n    x_order = 1\n    x_current = x\n    while a[x_current] != 0:\n        x_order += 1\n        x_current = a[x_current]\n\n    for source, target in list(a.items()):\n        if target != 0:\n            union(parents, source, target)\n\n    del a\n\n    x_representative = find(parents, x)\n\n    sizes = collections.Counter()\n    for i in parents:\n        i_representative = find(parents, i)\n        if i_representative != x_representative:\n            sizes[i_representative] += 1\n\n    del parents\n\n    adds = collections.Counter()\n    for size in list(sizes.values()):\n        adds[size] += 1\n\n    del sizes\n\n    sieve = {0: 1}\n    for add, count in list(adds.items()):\n        sieve_update = {}\n        for i, j in list(sieve.items()):\n            if j != 0:\n                for k in range(1, count + 1):\n                    if i + add * k <= n:\n                        sieve_update[i + add * k] = 1\n        sieve.update(sieve_update)\n\n    del adds\n\n    for position, value in sorted(sieve.items()):\n        if value:\n            print(position + x_order)\n\n__starting_point()", "def f(x, p):\n    q = []\n    while x:\n        q.append(x)\n        x = p[x]\n    return q\nfrom collections import defaultdict\nn, k = map(int, input().split())\nt = list(map(int, input().split()))\np = [0] * (n + 1)\nfor i, j in enumerate(t, 1):\n    p[j] = i\np = [f(i, p) for i, j in enumerate(t, 1) if j == 0]\ns = defaultdict(int)\nfor i in p:\n    if k in i: t = {i.index(k) + 1}\n    else: s[len(i)] += 1\ns = [list(range(i, k * i + 1, i)) for i, k in s.items()]\nfor q in s:\n    t |= {x + y for x in q for y in t}\nprint('\\n'.join(map(str, sorted(list(t)))))", "import sys\nsys.setrecursionlimit(100000)\ndef solve():\n    n, x, = rv()\n    x -= 1\n    a, = rl(1)\n    a = [val - 1 for val in a]\n    nxt = [True] * n\n    index = [-1] * n\n    for i in range(len(a)):\n        index[i] = get(i, a, nxt)\n    curindex = index[x] - 1\n    others = list()\n    for i in range(n):\n        if not bad(i, a, x) and nxt[i]:\n            others.append(index[i])\n    others.sort()\n    possible = [False] * (n + 1)\n    possible[0] = True\n    for val in others:\n        pcopy = list(possible)\n        for i in range(n + 1):\n            if possible[i]:\n                both = i + val\n                if both < n + 1:\n                    pcopy[both] = True\n        possible = pcopy\n    res = list()\n    for i in range(n + 1):\n        if possible[i]:\n            comb = i + curindex\n            if comb < n:\n                res.append(comb)\n    print('\\n'.join(map(str, [val + 1 for val in res])))\n\ndef bad(index, a, x):\n    if index == x: return True\n    if a[index] == x: return True\n    if a[index] == -1: return False\n    return bad(a[index], a, x)\n\ndef get(index, a, nxt):\n    if a[index] == -1:\n        return 1\n    else:\n        nxt[a[index]] = False\n        return get(a[index], a, nxt) + 1\n\ndef prt(l): return print(' '.join(l))\ndef rv(): return map(int, input().split())\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()"]
["n, m, k = map(int, input().split())\nmod = 998244353\n\ndef powerDX(n, r, mod):\n  if r == 0: return 1\n  if r%2 == 0:\n    return powerDX(n*n % mod, r//2, mod) % mod\n  if r%2 == 1:\n    return n * powerDX(n, r-1, mod) % mod\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n \nfor i in range(2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor i in range(0, k+1):\n  ans += m*cmb(n-1, i, mod)*pow(m-1, n-i-1, mod)\n  ans %= mod\nprint(ans)", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport heapq\n\nm = 2*10**5\nmod = 998244353\n\nfact = [0]*(m+5)\nfact_inv = [0]*(m+5)\ninv = [0]*(m+5)\n\nfact[0] = fact[1] = 1\nfact_inv[0] = fact_inv[1] = 1\ninv[1] = 1\n\nfor i in range(2,m+5):\n    fact[i] = fact[i-1] * i % mod\n    inv[i] = mod - inv[mod % i] * (mod // i) % mod\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n# nCk\u3092mod\uff08\u7d20\u6570\uff09\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\uff0e\u305f\u3060\u3057n<10**7\n# \u524d\u51e6\u7406\u306fm=n+5\u307e\u3067\ndef cmb(n,k,mod):\n    return fact[n] * (fact_inv[k] * fact_inv[n-k] % mod) % mod\n\nans = 0\n\nn,m,k = list(map(int, input().split()))\nfor i in range(k+1):\n    ans = (ans + (m*cmb(n-1,i,mod) % mod)*(pow(m-1,n-1-i,mod)) % mod) % mod\n\nprint(ans)", "N,M,K=list(map(int,input().split()))\nP=998244353\n\nt,c=(M*pow(~-M,~-N,P)),1\nfor k in range(1,K+1):\n  c=(c*(N-k)*pow(k,P-2,P))%P\n  t=(t+M*c*pow(~-M,(~-N-k),P))%P\nprint((t%P))\n", "def main():\n    n,m,k = list(map(int,input().split()))\n    mod = 998244353\n    ans = 0\n    def cmb(n,r,mod):\n        if (r<0 or r>n):\n            return 0\n        r = min (r, n-r)\n        return g1[n] * g2[r] * g2[n-r] %mod\n    g1 = [1,1]\n    g2 = [1,1]\n    inverse = [0,1]\n    for i in range(2, n+1):\n        g1.append((g1[-1] * i) %mod)\n        inverse.append((-inverse[mod % i ] * (mod//i)) % mod)\n        g2.append((g2[-1]*inverse[-1]) % mod)\n    for i in range(k+1):\n        a = cmb(n-1,i,mod)\n        a = a*m % mod\n        a = a * pow(m-1,n-1-i,mod)\n        ans += a\n        ans = ans % mod\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,K=map(int,input().split())\nmod=998244353\n\n  \ndef genCombinationFunction(max_k,mod):\n    modinv_table = [-1] * (max_k+1)\n    modinv_table[1] = 1\n    for i in range(2, max_k+1):\n        modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\n    def binomial_coefficients(n, k):\n        ans = 1\n        for i in range(k):\n            ans *= n-i\n            ans *= modinv_table[i + 1]\n            ans %= mod\n        return ans\n    return binomial_coefficients,modinv_table\nf,table=genCombinationFunction(10**6,mod)\n\nans=0\nC=1\nfor i in range(K+1):\n  base=M*pow(M-1,N-i-1,mod)\n  if i:\n    C*=N-i\n    C*=table[i]\n    C%=mod\n  ans+=C*base\n  #print((f(N-1,i)%mod)==C,f(N-1,i),C,)\n  ans%=mod\nprint(ans)", "\ndef pre_combi1(n, p):\n    fact = [1]*(n+1)  # fact[n] = (n! mod p)\n    factinv = [1]*(n+1)  # factinv[n] = ((n!)^(-1) mod p)\n    inv = [0]*(n+1)  # factinv \u8a08\u7b97\u7528\n    inv[1] = 1\n    # \u524d\u51e6\u7406\n    for i in range(2, n + 1):\n        fact[i]= fact[i-1] * i % p\n        inv[i]= -inv[p % i] * (p // i) % p\n        factinv[i]= factinv[i-1] * inv[i] % p\n    return fact, factinv\n\ndef combi1(n, r, p, fact, factinv):\n    \"\"\"\n    k<n<10**7\u3067p\u304c\u7d20\u6570\u306e\u3068\u304d\u306enCr % p\u3092\u6c42\u3081\u308b\n    \"\"\"\n    # \u672c\u51e6\u7406\n    if r < 0 or n < r:\n        return 0\n    r = min(r, n-r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np=998244353\nfact,finv=pre_combi1(2*10**5+1,p)\nn,m,k=map(int,input().split())\nans=0\ndup=[0] * n\ndup[0] = 1\nfor j in range(1,n):\n  dup[j]=dup[j-1]*(m-1) % p\nfor i in range(k+1):\n  ans += m*combi1(n-1,i,p,fact,finv)*dup[n-i-1]\n  ans %= p\nprint(ans)", "N,M,K = list(map(int,input().split()))\nMOD = 998244353\nif M==1:\n    print((1 if K==N-1 else 0))\n    return\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\ncs = []\nms = [(M * pow(M-1, N-1-K, MOD)) % MOD]\nfor i in range(K+1):\n    cs.append(comb(N-1, i))\n    if i:\n        ms.append((ms[-1] * (M-1)) % MOD)\n\nans = 0\nfor c,m in zip(cs, ms[::-1]):\n    ans += c*m\nprint((ans%MOD))\n", "class Factorial():\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        ''' n! % mod '''\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._factorial[n]\n    \n    def _make(self, n):\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def fact_inv(self, n):\n        ''' n!^-1 % mod '''\n        if n >= self.mod:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        self._make(n)\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        if self._factorial_inv[n] == -1:\n            self._factorial_inv[n] = self.modinv(self._factorial[n])\n        return self._factorial_inv[n]\n    \n    @staticmethod\n    def xgcd(a, b):\n        '''\n        Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b)\n        '''\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        if g != 1:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        return x % self.mod\n\n    def comb(self, n, r):\n        ''' nCr % mod '''\n        if r > n:\n            return 0\n        t = self(n)*self.fact_inv(n-r) % self.mod\n        return t*self.fact_inv(r) % self.mod\n\n    def comb_with_repetition(self, n, r):\n        ''' nHr % mod '''\n        t = self(n+r-1)*self.fact_inv(n-1) % self.mod\n        return t*self.fact_inv(r) % self.mod\n\n    def perm(self, n, r):\n        ''' nPr % mod '''\n        if r > n:\n            return 0\n        return self(n)*self.fact_inv(n-r) % self.mod\n\nn, m, k = list(map(int, input().split()))\nmod = 998244353\ncomb = Factorial(mod).comb\ns = 0\nfor i in range(k+1, n):\n    t = comb(n-1, i)*m % mod\n    t = t*pow(m-1, n-1-i, mod) % mod\n    s = (s+t) % mod\nans = (pow(m, n, mod)-s) % mod\nprint(ans)\n", "N, M, K = map(int, input().split())\nmod = 998244353\n\ninv = [0,1]\nfor i in range(2, N):\n  inv.append((-inv[mod%i]*(mod//i))%mod)\n\nif N == 1:\n  print(M)\n  return\n\nm = [1]\ns = 1\nfor _ in range(N-1):\n  s = s*(M-1)%mod\n  m.append(s)\n\nncombi = [1]\nc = 1\nfor k in range(K):\n  c = c*(N-1-k)*inv[k+1]\n  c %= mod\n  ncombi.append(c)\n\nans = 0\nfor k in range(K+1):\n  ans = ans + m[-k -1]*ncombi[k]\n  ans %= mod\n\nans = ans*M%mod\nprint(ans)", "def __starting_point():\n    M=998244353\n    n,m,k=map(int,input().split())\n    p,c=[m],[1]\n    for i in range(1,n):\n      p+=[p[-1]*(m-1)%M]\n      c+=[c[-1]*(n-i)*pow(i,-1,M)%M]\n    print(sum(p[n-i-1]*c[i] for i in range(k+1))%M)\n__starting_point()", "class Factorial():\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        ''' n! % mod '''\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._factorial[n]\n\n    def fact_inv(self, n):\n        ''' n!^-1 % mod '''\n        if n >= self.mod:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        self._make_inv(n)\n        return self._factorial_inv[n]\n\n    def comb(self, n, r):\n        ''' nCr % mod '''\n        if r > n:\n            return 0\n        t = self.fact_inv(n-r)*self.fact_inv(r) % self.mod\n        return self(n)*t % self.mod\n\n    def comb_with_repetition(self, n, r):\n        ''' nHr % mod '''\n        t = self.fact_inv(n-1)*self.fact_inv(r) % self.mod\n        return self(n+r-1)*t % self.mod\n\n    def perm(self, n, r):\n        ''' nPr % mod '''\n        if r > n:\n            return 0\n        return self(n)*self.fact_inv(n-r) % self.mod\n\n    @staticmethod\n    def xgcd(a, b):\n        '''\n        Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b)\n        '''\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        if g != 1:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        return x % self.mod\n\n    def _make(self, n):\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def _make_inv(self, n):\n        if n >= self.mod:\n            n = self.mod\n        self._make(n)\n        if self._size_inv < n+1:\n            for i in range(self._size_inv, n+1):\n                self._factorial_inv.append(self.modinv(self._factorial[i]))\n            self._size_inv = n+1\n\n\nn, m, k = list(map(int, input().split()))\nmod = 998244353\ncomb = Factorial(mod).comb\ns = 0\nfor i in range(k+1, n):\n    t = comb(n-1, i)*m % mod\n    t = t*pow(m-1, n-1-i, mod) % mod\n    s = (s+t) % mod\nans = (pow(m, n, mod)-s) % mod\nprint(ans)\n", "N, M, K = map(int, input().split())\nmod = 998244353\n\nb = str(bin(mod-2))[2:]\nblis = []\nfor _ in range(len(b)):\n  if b[-_-1] == '1':\n    blis.append(_)\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    n = len(b)\n    li = []\n    for _ in range(n):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res * li[item] %mod\n    return res\n\"\"\"      \ninv = [0,1]\nfor i in range(2, N):\n  inv.append((-inv[mod%i]*(mod//i))%mod)\n\"\"\"\nif N == 1:\n  print(M)\n  return\n\nm = [1]\ns = 1\nfor _ in range(N-1):\n  s = s*(M-1)%mod\n  m.append(s)\n\nncombi = [1]\nc = 1\nfor k in range(K):\n  c = c*(N-1-k)*modinv(k+1)\n  c %= mod\n  ncombi.append(c)\n\n\"\"\"\nolis = ncombi\nfor k in range(N-1):\n  nlis = [1]\n  for  j in range(len(olis)-1):\n    nlis.append(olis[j]+olis[j+1])\n  nlis.append(1)\n  olis = nlis\n  #print(olis)\nncombi = olis\n\"\"\"\nans = 0\nfor k in range(K+1):\n  ans = ans + m[-k -1]*ncombi[k]\n  ans %= mod\n\nans = ans*M%mod\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 998244353\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    n, m, k = list(map(int, input().split()))\n    cmb = CmbMod(n, mod)\n    cmb.prep()\n\n    res = 0\n    for i in range(k + 1):\n        res += (m * pow(m - 1, n - (i + 1), mod) * cmb.cmb_mod_with_prep(n - 1, i)) % mod\n        res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "N, M, K = map(int, input().split())\nmod = 998244353\n\nfacm = 200500\nfac = [1] * facm\nfacinv = [1] * facm\nfor i in range(facm-1):\n    fac[i+1] = (fac[i] * (i + 1)) % mod\n    facinv[i+1] = (facinv[i] * pow(i+1, -1, mod)) % mod\n\ndef nCk(n, k):\n    return (fac[n] * facinv[k] * facinv[n-k]) % mod\n\nans = 0\nfor i in range(K+1):\n    ans = (ans + nCk(N-1, i) * pow(M-1, N-i-1, mod) * M) % mod\n\nprint(ans)", "N,M,K=map(int,input().split())\nfac = [1]\nmod = 998244353\nfor i in range(1,N+1):\n    fac.append(fac[i-1]*i % mod)\nifac = [None]*(N+1)\nifac[-1] = pow(fac[N], mod-2, mod)\nfor i in range(N, 0, -1):\n    ifac[i-1] = ifac[i]*i % mod\nans = 0\nfor k in range(K+1):\n    t = M*fac[N-1] % mod\n    t = t*ifac[N-1-k] % mod\n    t = t*ifac[k] % mod\n    t = t*pow(M-1,N-1-k, mod)\n    t %= mod\n    ans = (ans+t) % mod\nprint(ans)", "import numpy as np\n\nN = 10 ** 6\nNsq = 10 ** 3\nmod = 998244353\n\nn, m, k = list(map(int, input().split()))\n\nfac = np.arange(N, dtype=np.int64).reshape(Nsq, Nsq)\nfac[0, 0] = 1\nfor i in range(1, Nsq):\n    fac[:, i] *= fac[:, i - 1]; fac[:, i] %= mod\nfor i in range(1, Nsq):\n    fac[i] *= fac[i - 1, -1]; fac[i] %= mod\nfac = fac.ravel()\n\nfinv = np.arange(1, N+1, dtype=np.int64)[::-1].reshape(Nsq, Nsq)\nfinv[0, 0] = pow(int(fac[N-1]), mod - 2, mod)\nfor i in range(1, Nsq):\n    finv[:, i] *= finv[:, i - 1]; finv[:, i] %= mod\nfor i in range(1, Nsq):\n    finv[i] *= finv[i - 1, -1]; finv[i] %= mod\nfinv = finv.ravel()[::-1]\n\n\ndef nCr(a, b):\n    comb = fac[a] * finv[b] % mod * finv[a-b] % mod\n    return comb\n\n\nprt = [1] * (n + 1)\nfor i in range(n):\n    prt[i + 1] = prt[i] * (m - 1) % mod\n\nres = 0\nfor i in range(k + 1):\n    res += m * prt[n - i - 1] % mod * nCr(n-1, i)\n    res %= mod\nprint(res)\n", "class Combination():  # nCr(mod p) #n<=10**6\n    def __init__(self, N, MOD):  # cmb\u306e\u524d\u51e6\u7406\n        self.mod = MOD\n        self.FACT = [1, 1]  # \u968e\u4e57\n        self.INV = [0, 1]  # \u5404i\u306e\u9006\u5143\n        self.FACTINV = [1, 1]  # \u968e\u4e57\u306e\u9006\u5143\n        for i in range(2, N + 1):\n            self.FACT.append((self.FACT[-1] * i) % self.mod)\n            self.INV.append(pow(i, self.mod - 2, self.mod))\n            self.FACTINV.append((self.FACTINV[-1] * self.INV[-1]) % self.mod)\n\n    def calculate(self, N, R):  # nCr(mod p) #\u524d\u51e6\u7406\u5fc5\u8981\n        if (R < 0) or (N < R):\n            return 0\n        R = min(R, N - R)\n        return self.FACT[N] * self.FACTINV[R] * self.FACTINV[N-R] % self.mod\n\n\n\nn, m, k = list(map(int, input().split()))\nmod = 998244353\n\ncmb = Combination(n,mod)\n\ncnt = 0\nfor i in range(k + 1):\n    cnt += (m * pow(m - 1, n - i - 1, mod) * cmb.calculate(n - 1, i)) % mod\n\nprint((cnt % mod))\n", "MOD = 998244353\n\nlim = 200000\ninv_t = [-1 for i in range(lim+1)]\nfactrial = [-1 for i in range(lim+1)]\nfactrial_inv = [-1 for i in range(lim+1)]\n\n\ndef set_inv(max=lim):\n    inv_t[0] = 0\n    for i in range(1, max):\n        inv_t[i] == mod_inv(i)\n\n\ndef mod_inv(x, mod=MOD):\n    y, u, v, _x = mod, 1, 0, x\n    while y:\n        t = _x//y\n        _x -= t*y\n        _x, y = y, _x\n        u -= t*v\n        u, v = v, u\n    u %= mod\n    if u < 0:\n        u += mod\n    return u\n\n\ndef mod_pow(a, n, mod=MOD):\n    res = 1\n    while n:\n        if n & 1:\n            res = res*a % mod\n        a = a*a % mod\n        n >>= 1\n    return res\n\n\ndef set_factrial(max=lim, mod=MOD):\n    c = 1\n    factrial[0] = factrial_inv[0] = 1\n    for i in range(1, max):\n        c *= i\n        c %= mod\n        factrial[i] = c\n        factrial_inv[i] = mod_inv(c, mod)\n\n\ndef comb(a, b, mod=MOD):\n    if factrial[0] == -1:\n        set_factrial()\n    return (factrial[a]*factrial_inv[b]*factrial_inv[a-b]) % mod\n\n\nn, m, k = [int(_) for _ in input().split()]\nans = 0\nfor i in range(k+1):\n    ans += m*comb(n-1, i)*mod_pow(m-1, n-1 - i)\n    ans %= MOD\n    # print(ans)\nprint(ans)\n", "n, m, k = list(map(int, input().split()))\nMOD = 998244353\n\n\nclass Combination:\n    def __init__(self, n, mod):\n        self.n = n\n        self.mod = mod\n\n        self.f = self._get_f()\n        self.fi = self._get_fi()\n\n    def __call__(self, k):\n        if not 0 <= k <= self.n:\n            return 0\n        else:\n            num = self.f[self.n]\n            deninv = (self.fi[k] * self.fi[self.n - k]) % self.mod\n            return (num * deninv) % self.mod\n\n    def _get_f(self):\n        f = 1\n        lf = [1]\n\n        for i in range(1, self.n + 1):\n            f = (f * i) % self.mod\n            lf.append(f)\n\n        return lf\n\n    def _get_fi(self):\n        ii = 1\n        lii = [0, 1]  # [i^-1 modulo mod for i in 0, ..., n]\n        fi = 1\n        lfi = [1, 1]\n\n        for i in range(2, self.n + 1):\n            ii = (-lii[self.mod % i] * (self.mod // i)) % self.mod\n            lii.append(ii)\n\n            fi = (fi * ii) % self.mod\n            lfi.append(fi)\n\n        return lfi\n\n\nc = Combination(n - 1, MOD)\n\n\ndef n_pattern(i):\n    result = m\n    result *= c(i)\n    result %= MOD\n    result *= pow(m - 1, n - i - 1, MOD)\n    result %= MOD\n    return result\n\n\nanswer = sum(n_pattern(i) for i in range(k + 1)) % MOD\nprint(answer)\n", "def main():\n    N, M, K = map(int, input().split())\n    MOD = 998244353\n\n    fac = [0] * 10 ** 6\n    inv = [0] * 10 ** 6\n    finv = [0] * 10 ** 6\n\n    def COM_init():\n        fac[0] = 1\n        fac[1] = 1\n        inv[1] = 1\n        finv[0] = 1\n        finv[1] = 1\n\n        for i in range(2, 2 * 10**5 +10):\n            fac[i] = fac[i-1] * i % MOD\n            inv[i] = -inv[MOD%i] * (MOD//i) % MOD\n            finv[i] = finv[i-1]*inv[i]%MOD\n        \n    def COM(n, k):\n        if n < k: return 0\n        if n < 0 or k < 0: return 0\n        return fac[n] * (finv[n-k] * finv[k] % MOD) % MOD\n\n    COM_init()\n    ans = 0\n    for i in range(K+1):\n        ans += M * pow(M-1, N-i-1, MOD) * COM(N-1, i)\n        ans %= MOD\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\nclass Combination:\n    def __init__(self, n, p):\n        self.n = n\n        self.p = p\n        self.note = [1, 1]\n        self.noteinv = [1, 1]\n        self.inv = [0, 1]\n        self.calc()\n\n    def calc(self):\n        for i in range(2, self.n + 1):\n            self.note.append((self.note[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.noteinv.append((self.noteinv[-1] * self.inv[-1]) % self.p)\n    \n    def nCr(self, n, r):\n        n = self.n\n        if r < 0 or n < r:\n            return 0\n        r = min(r, n - r)\n        return (self.note[n] * self.noteinv[r] * self.noteinv[n - r]) % self.p\n\ndef Main():\n    n, m, k = read_ints()\n    # m * _{n-1}C_k * 1^k * (m-1)^{n-1-k}\n\n    p = 998244353\n    modm = [1]\n    for _ in range(1, n):\n        modm.append((modm[-1] * (m - 1)) % p)\n    \n    cmb = Combination(n - 1, p)\n    ans = 0\n    for i in range(k + 1):\n        ans += (cmb.nCr(n - 1, i) * m * modm[n - 1 - i]) % p\n        ans %= p\n    print(ans)\n\ndef __starting_point():\n    Main()\n__starting_point()", "from sys import stdin\nN,M,K = [int(x) for x in stdin.readline().rstrip().split()]\nmod = 998244353\nmaxn = 2*10**5+1\n\nfac  = [0 for _ in range(maxn)]\nfinv = [0 for _ in range(maxn)]\ninv  = [0 for _ in range(maxn)]\n\nfac[0]  = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\n\nfor i in range(2,maxn):\n    fac[i] = fac[i-1] * i % mod\n    inv[i] = mod - inv[mod%i] * (mod // i) % mod\n    finv[i] = finv[i-1] * inv[i] % mod\n\ndef combinations(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\nans = 0\nfor i in range(0,K+1):\n    tmp = 1\n    tmp *= M*pow(M-1,N-i-1,mod)\n    tmp %= mod\n    tmp *= combinations(N-1,i)\n    tmp %= mod\n    ans += tmp\n    \nprint(ans%mod)", "def main():\n  ## IMPORT MODULE\n  #import sys\n\n  #sys.setrecursionlimit(100000)\n  #input=lambda :sys.stdin.readline().rstrip()\n\n  #f_inf=float(\"inf\")\n  MOD=998244353\n  \n  if 'get_ipython' in globals(): \n    ## SAMPLE INPUT\n    n, m, k = 60522, 114575, 7559\n\n  else:\n    ##INPUT \n    #n = input()\n    n, m, k = map(int, input().split())\n\n  ## SUBMITION CODES HERE\n  ans, N, K = 0, 1, 1\n \n  for i in range(k+1):\n    ans += N * pow(K, MOD-2, MOD) * pow(m-1, n-1-i, MOD)\n    ans %= MOD\n    N *= n-1-i\n    N %= MOD\n    K *= i+1\n    K %= MOD\n  \n  ans *= m\n  ans %= MOD\n  print(ans)\n\nmain()", "import numpy as np\nMAX = 200002\nMOD = 998244353\nfac = np.zeros(MAX)\nfinv = np.zeros(MAX)\ninv = np.zeros(MAX)\n\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\nfor i in range(2,MAX):\n    fac[i] = int(fac[i-1]) * i % MOD\n    inv[i] = MOD - int(inv[MOD%i]) * (MOD//i) % MOD\n    finv[i] = int(finv[i-1]) * int(inv[i]) % MOD\n\ndef COM(N,K):\n    return  int(fac[N]) * (int(finv[K]) * int(finv[N - K]) % MOD) % MOD\n\ndef resolve():\n    N,M,K = map(int,input().split())\n    ans = 0\n    for i in range(K + 1):\n        ans_k = M * COM(N-1, i )\n        ans_k = ans_k * pow(M-1,N-1-i, MOD) % MOD\n        ans = (ans + ans_k) % MOD\n    print(ans)\nresolve()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\ndef cmb(n, r, mod):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n - r] % mod\n\n\ndef make_table2(n, mod=10 ** 9 + 7):\n    # \u5143\u30c6\u30fc\u30d6\u30eb\n    g1 = [0] * (n + 1)\n    g1[0] = 1\n    g1[1] = 1\n    tmp = 1\n\n    for i in range(2, n + 1):\n        tmp = tmp * i % mod\n        g1[i] = tmp\n\n    # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [0] * (n + 1)\n    g2[-1] = pow(g1[-1], mod - 2, mod)\n    tmp = g2[-1]\n\n    for i in range(n - 1, -1, -1):\n        tmp = tmp * (i + 1) % mod\n        g2[i] = tmp\n\n    return g1, g2\n\n\nN, M, K = list(map(int, read().split()))\nmod = 998244353\ng1, g2 = make_table2(N, mod)\nanswer = 0\nfor i in range(K + 1):\n    answer = (answer + cmb(N - 1, i, mod) * M * pow(M - 1, N - i - 1, mod)) % mod\n\nprint(answer)\n", "# -*- coding: utf-8 -*-\n\nN,M,K = list(map(int, input().rstrip().split()))\n#-----\n# Calculate the Factorial and it's Inverse Element\nfact = [0]*(N+1)\nfact_inv = [0]*(N+1)\ninv = [0]*(N+1)\n\nmod = 998244353\n\nfact[0] = fact[1] = 1\nfact_inv[0] = fact_inv[1] = 1\ninv[1] = 1\n\nfor i in range(2, N+1):\n    fact[i] = (fact[i-1] * i) % mod\n    inv[i] = mod - ( inv[mod%i] * (mod // i) ) % mod\n    fact_inv[i] = ( fact_inv[i-1] * inv[i] ) % mod\n\n#-----\n# Calculate (M-1) raised to the power of \"0 to N-1\"\npow_M1 = [0]*N\npow_M1[0] = 1\n\nfor i in range(1, N):\n    pow_M1[i] = ( pow_M1[i-1] * (M-1) ) % mod\n\n#-----\nans = 0\n\nfor i in range(K+1):\n    comb = ( fact[N-1] * fact_inv[i] * fact_inv[N-1-i] ) % mod\n    \n    ans += ( comb * M * pow_M1[N-i-1] ) % mod\n    ans %= mod\n\nprint(ans)\n", "mod=998244353\nfact=[1]\nfor i in range(1,2*10**5+1): #mod\u4e0a\u3067\u306e\u968e\u4e57\u3092\u6c42\u3081\u308b\n fact.append((fact[-1]*i)%mod)\nrevfact=[1]\nfor i in range(1,2*10**5+1): #mod\u4e0a\u3067\u306e\u968e\u4e57\u306e\u9006\u5143\u3092\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u3092\u7528\u3044\u3066\u6c42\u3081\u308b\n revfact.append(pow(fact[i],mod-2,mod))\nn,m,k=map(int,input().split())\nans=0\nfor i in range(k,-1,-1): #\u5404m(N-K<=m<=N)\u306b\u3064\u3044\u3066\u5834\u5408\u306e\u6570\u3092\u6c42\u3081\u308b\n group=n-i\n tmp=fact[n-1]*revfact[group-1]*revfact[n-1-(group-1)]\n tmp%=mod\n tmp*=m\n tmp%=mod\n tmp*=pow(m-1,group-1,mod)\n ans+=tmp\n ans%=mod\nprint(ans)", "mod = 998244353\nN, M, K = map(int, input().split())\n\nf = 1\nf_list = [1]\nfor m in range(1, N + 1):\n    f *= m\n    f %= mod\n    f_list.append(f)\ninv = pow(f, mod - 2, mod)    \ninv_list = [1] * (N + 1)\ninv_list[N] = inv\n\nfor m in range(N, 1, -1):\n    inv *= m\n    inv %= mod\n    inv_list[m - 1] = inv\n\nans = 0\n\nfor i in range(K + 1):\n    color = pow(M - 1, N - 1 - i, mod)\n    order = f_list[N - 1] * inv_list[i] * inv_list[N - i - 1] % mod\n    ans += color * order * M % mod\n    ans = ans % mod\nprint(ans % mod)", "# from math import factorial\nn,m,k = map(int, input().split())\nif m == 1:\n    if k == n-1:\n        print(1)\n    else:\n        print(0)\n    return\nMOD = 998244353\n\nans = tmp = (m * (m-1) ** (n-1)) % MOD\n\nfor i in range(k):\n    tmp *= (n-1-i)\n    tmp %= MOD\n    tmp *= pow((m-1) * (i+1), -1, MOD)\n    ans += tmp\n    ans %= MOD\n\nprint(ans)", "n,m,k=map(int,input().split())\nmod=998244353\ncntb=1\nans=0\nfor i in range(k+1):\n    ans=ans+(((m*pow(m-1,n-1-i,mod))%mod)*cntb)%mod\n    ans=ans%mod\n    cntb=(cntb*(n-1-i)*pow(i+1,mod-2,mod))%mod\nprint(ans%mod)", "N, M, K = list(map(int, input().split()))\nMOD = 998244353\nans = 0\ncomb = 1\nfor k in range(K + 1):\n    ans += M * comb * pow(M - 1, N - k - 1, MOD)\n    ans %= MOD\n    comb *= (N - k - 1) * pow(k + 1, MOD - 2, MOD)\n    comb %= MOD\nprint(ans)\n", "n,m,k=map(int,input().split())\nmod=998244353\nans=0\n\nfact=[1] * (n+1)  # \u968e\u4e57\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nfactinv=[1] * (n+1)  # \u968e\u4e57\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nfor i in range(n):\n    fact[i+1] = fact[i] * (i+1) % mod  # \u968e\u4e57\u3092\u8a08\u7b97\n    factinv[i+1] = pow(fact[i+1], mod-2, mod)  # mod\u3092\u6cd5\u3068\u3057\u305f\u9006\u5143\uff08\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\uff09\n\ndef nCk(n,k):  # \u7d44\u307f\u5408\u308f\u305b(mod)\u3092\u8fd4\u5374\u3059\u308b\n    return fact[n] * factinv[n-k] * factinv[k] % mod\n\nfor k_i in range(k+1):\n    ans += m * pow(m-1, n-1-k_i, mod) * nCk(n-1, k_i)\n    ans %= mod\nprint (ans)", "def comb(n,r,m):\n    if 2*r > n:\n        r = n - r\n    nume,deno = 1,1\n    for i in range(1,r+1):\n        nume *= (n-i+1)\n        nume %= m\n        deno *= i\n        deno %= m\n\n    return (nume * pow(deno,m-2,m)) % m\n\ndef main():\n    N,M,K = list(map(int,input().split()))\n    mod = 998244353\n\n    ans,comb_r = pow(M-1,N-1,mod),1\n    for r in range(1,K+1):\n        comb_r = (comb_r * (N-r) * pow(r,mod-2,mod)) % mod\n        ans = (ans + comb_r * pow(M-1,N-r-1,mod)) % mod\n    ans = (ans * M) % mod\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m, k = map(int, input().split())\nmod = 998244353\n\nN = 10**5 * 2  # N!\u307e\u3067\u6c42\u3081\u308b\nfact  = [1, 1]  # \u968e\u4e57\u306e\u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1]  # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb 1,2,,...\u306e\u9006\u5143\u3092\u6c42\u3081\u3066\u308b\n\n# \u8a08\u7b97 O(1)\ndef comb(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n\n# \u9806\u5217\ndef perm(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    return fact[n] *  fact_inv[n-r] % mod\n\n# \u524d\u51e6\u7406 O(n)\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * inv[-1]) % mod)\n\nans = 0\nfor i in range(k+1):\n    ans += comb(n-1, i, mod) * m * pow(m-1, n-i-1, mod)\n    ans %= mod\n\nprint(ans)", "n, m, k = [int(t) for t in open(0).read().split()]\nmod = 998244353\nmem = [0] * max(k + 3, n + 1)\nfor i in range(k + 2):\n    mem[i] = pow(m, i, mod)\nc = 1\nfor i in range(k + 2, n + 1):\n    mem[i] = (m * mem[i - 1] - m * c * pow(m - 1, i - k - 2, mod)) % mod\n    c = (c * (i - 1) * pow(i - k - 1, - 1, mod)) % mod\nprint(mem[n])", "import math\nn, m, k = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n\nMOD = 998244353\nN = 3*10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod MOD)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod MOD)\ninv = [0, 1]  \n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    factinv.append((factinv[-1] * inv[-1]) % MOD)\n\nans = 0\nfor kk in range(k+1):\n    ans_kk = m*cmb(n-1,kk,MOD)* pow(m-1, n-kk-1, MOD)\n    ans = (ans + ans_kk)%MOD\n\nprint(ans)", "n,m,k=map(int,input().split())\ng=998244353\nr=1\np=pow(m-1,n-1,g)\nfor i in range(1,k+1):\n    r=(r*(n-i)*pow(i,g-2,g))%g\n    p=(p+r*pow(m-1,n-1-i,g))%g\nprint((m*p)%g)", "import math\nfrom operator import mul\nfrom functools import reduce\n\n\nn, m, k = map(int, input().split())\nmod = 998244353\n\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, n+1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\nans = 0\nfor i in range(k+1):\n    ans += m*cmb(n-1, i, mod)*pow(m-1, n-1-i, mod)%mod\n    ans %= mod\n\nprint(ans)", "import sys\ninput=lambda: sys.stdin.readline().rstrip()\nn,m,k=map(int,input().split())\nmod=998244353\nn_max=2*(10**5+1)\nF,FI=[0]*(n_max+1),[0]*(n_max+1)\nF[0],FI[0]=1,1\nfor i in range(n_max):\n  F[i+1]=(F[i]*(i+1))%mod\nFI[n_max-1]=pow(F[n_max-1],mod-2,mod)\nfor i in reversed(range(n_max-1)):\n  FI[i]=(FI[i+1]*(i+1))%mod\ndef comb(x,y):\n  return (F[x]*FI[x-y]*FI[y])%mod\n\nP=[1]\nfor i in range(n):\n  P.append((P[-1]*(m-1))%mod)\n\nans=0\nfor i in range(k+1):\n  ans+=m*P[n-1-i]*comb(n-1,i)\n  if ans>mod:\n    ans%=mod\nprint(ans)", "M=998244353\nn,m,k=map(int,input().split())\np,c=[m]*n,[1]*n\nfor i in range(1,n):\n  p[i]=p[i-1]*(m-1)%M\n  c[i]=c[i-1]*(n-i)*pow(i,M-2,M)%M\nprint(sum(p[n-i-1]*c[i]%M for i in range(k+1))%M)", "n, m, k = list(map(int, input().split()))\n\nMOD = 998244353\nfact = [1] * (n+1) # \u968e\u4e57\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nfactinv = [1] * (n+1) # \u968e\u4e57\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\nfor i in range(n):\n    fact[i+1] = fact[i] * (i+1) % MOD # \u968e\u4e57\u3092\u8a08\u7b97\n    factinv[i+1] = pow(fact[i+1], MOD-2, MOD)# MOD\u3092\u6cd5\u3068\u3057\u305f\u9006\u5143\uff08\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\uff09\n\ndef nCk(n,k): # \u7d44\u307f\u5408\u308f\u305b(MOD)\u3092\u8fd4\u5374\u3059\u308b\n    return fact[n] * factinv[n-k] * factinv[k] % MOD\n\nans = 0\nfor i in range(k+1):\n    ans += m * pow(m-1, n-1-i, MOD) * nCk(n-1, i) % MOD\n\nprint((ans % MOD))\n", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, M, K = list(map(int, input().split()))\n\nm = 998244353\n\nresult = 0\nn = 1\nk = 1\nfor i in range(K + 1):\n    # result += M * mcomb(N - 1, i) * pow(M - 1, N - 1 - i, 998244353)\n    result += n * pow(k, m - 2, m) * pow(M - 1, N - 1 - i, m)\n    result %= m\n    n *= N - 1 - i\n    n %= m\n    k *= i + 1\n    k %= m\nresult *= M\nresult %= m\nprint(result)\n", "n,m,k = list(map(int, input().split()))\np = 998244353\n\ndef prepare(n):\n    fact = [1, 1]\n    factinv = [1, 1]\n    inv = [0, 1]\n\n    for i in range(2, n + 1):\n        fact.append((fact[-1] * i) % p)\n        inv.append((-inv[p % i] * (p // i)) % p)\n        factinv.append((factinv[-1] * inv[-1]) % p)\n\n    return fact, factinv\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    return f[n] * v[r] * v[n - r] % p\n\nf,v = prepare(n)\n\nans = 0\nfor i in range(k + 1):\n    a = cmb(n-1,i,p) * m * pow(m-1,n-i-1,p) % p\n    ans += a\n    ans %= p\n\nprint(ans)\n", "# coding: utf-8\n# Your code here!\nn,M,K=list(map(int,input().split()))\n\nmod=998244353\n\n\nfac = [1] * (n + 1)\ninv = [1] * (n + 1)\n\nfor j in range(1, n + 1):\n    fac[j] = fac[j-1] * j % mod\n\n\ninv[n] = pow(fac[n], mod-2, mod)\nfor j in range(n-1, -1, -1):\n    inv[j] = inv[j+1] * (j+1) % mod\n\n\ndef comb(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\n\nans=0\ntemp=(M*(M-1)**(n-K-1))%mod#1\u4e57\nfor k in range(K+1)[::-1]:\n    ans=(ans+temp*comb(n-1,k))%mod\n    temp=(temp*(M-1))%mod\n\nprint(ans)\n", "#import numpy as np\nimport math\n#from decimal import *\n#from numba import njit\n#@njit\ndef main():\n    (N, M, K) = list(map(int, input().split()))\n    MOD = 998244353\n    \n    fact = [1]*(N+1)\n    factinv = [1]*(N+1)\n    for i in range(1,N+1):\n        fact[i] = fact[i-1]*i % MOD\n        factinv[i] = pow(fact[i], MOD-2, MOD)\n    def comb(n, k):\n        return fact[n] * factinv[k] * factinv[n-k] % MOD\n\n    ans = 0\n    for k in range(K+1):\n        ans += (comb(N-1,k)*M*pow(M-1, N-k-1, MOD))%MOD\n\n    print((ans%MOD))\n\nmain()\n", "n,m,k=map(int,input().split())\nmod1,mod2=10**9+7,998244353\nmod=mod2\nMAX=n-1\nfact=[1]*(MAX+1)\ninv=[1]*(MAX+1)\nfor i in range(2,MAX+1):\n    fact[i]=i*fact[i-1]%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(MAX,1,-1):\n    inv[i-1]=inv[i]*i%mod\ndef comb(x,y):return fact[x]*inv[y]%mod*inv[x-y]%mod if x>=y>=0 else 0\nans=0\ncor=pow(m-1,n-1-k,mod)\nfor i in range(k,-1,-1):\n    ans=(ans+comb(n-1,i)*cor)%mod\n    cor=cor*(m-1)%mod\n\nprint(m*ans%mod)", "n,m,k = map(int,input().split())\n\ndef cmb(n, r, mod):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%mod\n\n\nmod = 998244353\nN = 3 * 10**5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%mod)\n\tinv.append((-inv[mod%i]*(mod//i))%mod)\n\tfactinv.append((factinv[-1]*inv[-1])%mod)\n\nans = 0\nfor i in range(min(n, k+1)):\n\tans = (ans + cmb(n-1, i, mod) * m * pow(m-1, n-i-1, mod)) % mod\nprint(ans)", "def main():\n  n,m,k = map(int, input().split())\n  f = [1]\n  p = 998244353\n  for i in range(1, n):\n    f.append(f[-1] * i % p)\n\n  ans = 0\n  def nCk(n,k):\n    return f[n] * pow(f[n-k], p-2, p) * pow(f[k], p-2, p) % p\n\n  for i in range(k+1):\n    ans += (m * nCk(n-1, i) * pow(m-1, n-1-i, p)) % p\n  print(ans % p)\n\ndef __starting_point():\n  main()\n__starting_point()", "class Combination:\n    def __init__(self, n, mod):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % mod)\n        self.inv_fact = [0] * (n + 1)\n        self.inv_fact[n] = pow(self.fact[n], mod - 2, mod)\n        for i in reversed(list(range(n))):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % mod\n        self.mod = mod\n\n    def factorial(self, k):\n\n        return self.fact[k]\n\n    def inverse_factorial(self, k):\n        return self.inv_fact[k]\n\n    def permutation(self, k, r):\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r]) % self.mod\n\n    def combination(self, k, r):\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r]) % self.mod\n\n    def combination_large(self, k, r):\n        if k < r:\n            return 0\n        res = 1\n        for l in range(r):\n            res *= (k - l)\n            res %= self.mod\n        return (res * self.inv_fact[r]) % self.mod\n\nn, m, k = list(map(int, input().split()))\nmod = 998244353\ncmb = Combination(10**6, mod)\n\nans = 0\nfor i in range(k+1):\n    ans += m*cmb.combination(n-1, i)*pow(m-1, n-1-i, mod)\n    ans %= mod\nprint(ans)\n", "def cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nmod = 998244353\nnums = 2*(10**5) # \u5236\u7d04\u306b\u5408\u308f\u305b\u3088\u3046\ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\nn, m, k = list(map(int, input().split()))\nans = 0\nfor i in range(k+1):\n    ans += m*cmb(n-1, i, mod)*pow(m-1, n-i-1, mod)\n    ans %= mod\nprint(ans)\n\n", "n, m, k = map(int, input().split())\nmod = 998244353\nans = 0\nx = 1\nfor i in range(k + 1):\n    ans += (((m * pow(m - 1, n - i - 1, mod)) % mod) * x) % mod\n    ans %= mod\n    x = (x * (n - i - 1) * pow(i + 1, mod - 2, mod)) % mod\nprint(ans % mod)", "#\u89e3\u8aac\u901a\u308a\nN,M,K = list(map(int,input().split()))\nm = 998244353\nans = (M*pow(M-1,N-1,m))%m #\u3059\u3079\u3066\u9055\u3046\u8272,k=0\nalpha = 1#n-1Ck, k=0\u306e\u5024\u3067\u521d\u671f\u5316\nfor k in range(1,K+1):\n    alpha = (alpha*(N-k)*pow(k,m-2,m))%m#\u9006\u5143\u3067\u8a08\u7b97\u3057\u306a\u3044\u3068TLE\n    ans = (ans + M*alpha*pow(M-1,N-k-1,m))%m\nprint(ans)\n", "def main():\n    n,m,k = list(map(int,input().split()))\n    mod = 998244353\n    def cmb(n, r, mod):\n        if ( r<0 or r>n ):\n            return 0\n        r = min(r, n-r)\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n    N = 10**6\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range( 2, N + 1 ):\n        g1.append( ( g1[-1] * i ) % mod )\n        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n    s = 0\n    for i in range(k+1):\n        s += cmb(n-1,i,mod) * m * pow(m-1,n-1-i,mod) % mod\n    print((s % mod))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class CombMod:\n    def __init__(self, V, mod):\n        self.fact = [1] * V\n        self.finv = [1] * V\n        for i in range(1, V):\n            self.fact[i] = self.fact[i - 1] * i % mod\n        self.finv[-1] = pow(self.fact[-1], mod - 2, mod)\n        for i in range(V - 2, 0, -1):\n            self.finv[i] = self.finv[i + 1] * (i + 1) % mod\n        self.mod = mod\n\n    def comb(self, a, b):\n        return self.fact[a] * self.finv[b] % mod * self.finv[a - b] % mod\n\n\nN, M, K = list(map(int, input().split()))\nmod = 998244353\ntool = CombMod(N + 1, mod)\n\nans = 0\nfor k in range(K + 1):\n    val = M * tool.comb(N - 1, k) % mod * pow(M - 1, N - 1 - k, mod) % mod\n    ans = (ans + val) % mod\nprint(ans)\n", "n,m,k=map(int,input().split())\nmod=998244353\nma=[1]\nfor i in range(1,k+1):\n    mad=ma[-1]*(n-i)*pow(i,mod-2,mod)\n    ma.append(mad)\n    ma[-1]%=mod\nans=0\nfor i in range(k+1):\n    ans+=ma[i]*m*pow(m-1,n-i-1,mod)\n    ans%=mod\nprint(ans)", "N,M,K = list(map(int,input().split()))\nMOD = 998244353\nif M==1:\n    print((1 if K==N-1 else 0))\n    return\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\ncs = []\nms = [(M * pow(M-1, N-1-K, MOD)) % MOD]\nfor i in range(K+1):\n    cs.append(comb(N-1, i))\n    if i:\n        ms.append((ms[-1] * (M-1)) % MOD)\n\nans = 0\nfor c,m in zip(cs, ms[::-1]):\n    ans += c*m\nprint((ans%MOD))\n", "mod = 998244353\nN, M, K = map(int, input().split())\n\nlist_size = 2*10**5 + 4\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n \nfor i in range(list_size-1):\n\tf_list[i+1] = (f_list[i] * (i+1)) % mod\n \nf_r_list[-1] = pow(f_list[-1], mod - 2, mod)\n \nfor i in range(list_size-2, -1, -1):\n\tf_r_list[i] = (f_r_list[i+1] * (i+1)) % mod\n \ndef comb(n, r, mod):\n\tif n < r or r < 0:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (f_list[n] * f_r_list[n-r] * f_r_list[r]) % mod\n\nans = 0\nfor k in range(K+1):\n    ans += (comb(N-1, k, mod) * M *pow(M-1, N-k-1, mod))%mod\nans %= mod\nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\n\nN,M,K = list(map(int, input().rstrip().split()))\n#-----\n\nif (M == 1) and (K == N-1):\n    print((1))\n    return\nelif (M == 1) and (K < N-1):\n    print((0))\n    return\n\n\nmod = 998244353\n\na = M * pow(M-1, N-1, mod)\ninv_M1 = pow((M-1), mod-2, mod )  # inverse element\n\ncomb = 1\nans = 0\n\nfor i in range(K+1):\n    ans += ( comb * a )\n    ans %= mod\n    \n    # Calculate variables for next step\n    a *= inv_M1\n    a %= mod\n    \n    inv_i1 = pow(i+1, mod-2, mod)  # inverse element\n    comb *= ( (N-1-i) * inv_i1 )\n    comb %= mod\n\n\nprint(ans)\n", "N, M, K = list(map(int, input().split()))\nmod = 998244353\nMAX = 510000\n\nfac = [0]*MAX\nfacinv = [0]*MAX\ninv = [0]*MAX\n\n\ndef modinv(a, mod):\n    b = mod\n    x, u = 1, 0\n    while b:\n        q = a//b\n        a, b = b, a-q*b\n        x, u = u, x-q*u\n    x %= mod\n    return x\n\n\ndef mod_nCr_init(n, mod):\n    fac[0] = fac[1] = 1\n    facinv[0] = facinv[1] = 1\n    inv[1] = 1\n    for i in range(2, n):\n        fac[i] = fac[i-1] * i % mod\n        inv[i] = -inv[mod % i] * (mod // i) % mod\n        facinv[i] = facinv[i-1] * inv[i] % mod\n\n\ndef mod_nCr(n, r, mod):\n    if n < r or n < 0 or r < 0:\n        return 0\n    return fac[n] * (facinv[r] * facinv[n-r] % mod) % mod\n\n\nmod_nCr_init(MAX, mod)\nans = 0\nfor i in range(K+1):\n    ans += mod_nCr(N-1, i, mod) * M * pow(M-1, N-i-1, mod)\n    ans %= mod\nprint(ans)\n", "# E - Colorful Blocks\nimport sys\nsys.setrecursionlimit(10**8)\n\nMOD = 998244353\nN,M,K = map(int,input().split())\ninv_M = pow(M-1,-1,MOD) if M>1 else 0\nans = 0\ntmp = pow(M-1,N-1,MOD) if M>1 else 0\ncomb = 1\nfor i in range(K+1):\n    ans = (ans+M*comb*tmp)%MOD\n    if i==K:\n        break\n    tmp = (tmp*inv_M)%MOD\n    comb = (comb*(N-1-i)*pow(i+1,-1,MOD))%MOD\nif M==1 and K==N-1:\n    ans += 1\nprint(ans)", "import math\n\nN ,M, K = list(map(int,input().split()))\nMOD = 998244353\n\ndef getInvs(n, MOD):\n    invs = [1] * (n+1)\n    for x in range(2, n+1):\n        invs[x] = (-(MOD//x) * invs[MOD%x]) % MOD\n    return invs\ninvs = getInvs(N+3, MOD)\n\nnum = M\nnums = []\nfor i in reversed(list(range(1,N))):\n    nums.append(num)\n    num *= i*(M-1)\n    num *= invs[N-i]\n    num %= MOD\nnums.append(num)\nnums.reverse()\n\nans = sum(nums[:K+1])\nans %= MOD\nprint(ans)\n", "N,M,K=map(int,input().split())\nmod = 998244353\n\nfactorial=[1 for i in range(N+1)]\nfor i in range(1,N+1):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i % mod\n\ndef comb(n,k):\n    return (factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod))%mod\n\ndef count(n,m,k):\n  return m*comb(n-1,k)*pow(m-1,n-k-1,mod)%mod\n\nprint(sum([count(N,M,i) for i in range(K+1)]) % mod)", "def main():\n  ## IMPORT MODULE\n  #import sys\n\n  #sys.setrecursionlimit(100000)\n  #input=lambda :sys.stdin.readline().rstrip()\n\n  #f_inf=float(\"inf\")\n  MOD=998244353\n  \n  if 'get_ipython' in globals(): \n    ## SAMPLE INPUT\n    n, m, k = 60522, 114575, 7559\n\n  else:\n    ##INPUT \n    #n = input()\n    n, m, k = map(int, input().split())\n\n  ## SUBMITION CODES HERE\n  fac = [1] * (n+1)\n  inv = [1] * (n+1)\n\n  for i in range(n):\n    fac[i+1] = fac[i] * (i+1) % MOD # Calculating the Factorial \n    inv[i+1] = pow(fac[i+1], MOD-2, MOD) # The inverse of the MOD's law (Fermat's Little Theorem)\n  \n  def nCr(n, r):\n    if 2*r > n: nCr(n, n-r)\n    return fac[n] * inv[r] * inv[n-r] % MOD\n  \n  ans = 0\n  for i in range(k+1):\n    tmp = nCr(n-1, i) * m * pow(m-1, n-1-i, MOD) \n    ans += tmp\n    ans %= MOD\n  print(ans)\n\nmain()", "#!/usr/bin/env python3\nimport sys\nfrom networkx.utils import UnionFind\nfrom operator import itemgetter\ndef input(): return sys.stdin.readline().rstrip()\n\nclass prepere_pch:\n    def __init__(self, maxnum=3*10**5, mod=10**9+7):\n        self.factorial = [0]*(maxnum+1)\n        self.factorial[0] = 1\n        for i in range(1, maxnum):\n            self.factorial[i] = (self.factorial[i-1]*i) % mod\n        self.mod = mod\n    def per(self,n,r):\n        return (self.factorial[n]*pow(self.factorial[n-r],-1,self.mod)) % self.mod\n\n    def com(self,n,r):\n        return self.per(n,r)*pow(self.factorial[r],-1,self.mod)\n    \n    def comH(self,n,r):\n        return self.com(n+r-1,r)\n\ndef main():\n    n,m,k=list(map(int, input().split()))\n    ans=0\n    pt=m\n    pch=prepere_pch(mod=998244353)\n    for same in range(n-1,-1,-1):\n        if same <=k:\n            ans+=pt*pch.com(n-1,same)\n            ans%=998244353\n        pt*=m-1\n        pt%=998244353\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\nimport heapq\nimport decimal\n# import statistics\nimport queue\nimport numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\n\ndef main():\n    def fast_pow(num, kata, mod):\n        if kata == 0:\n            return 1\n\n        res = 1\n        while kata > 0:\n            if kata & 1 == 1:\n                res = res * num % mod\n            num = num * num % mod\n\n            kata >>= 1\n        return res\n\n    def prepare(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return factorials, invs\n\n    n, m, k = ns()\n\n    p, i = prepare(n, MOD)\n\n    result = 0\n\n    for ki in range(k + 1):\n        ans = 1\n        ans *= m % MOD\n        ans *= fast_pow(m - 1, n - 1 - ki, MOD)\n        ans %= MOD\n        ans *= p[n - 1] * i[ki] * i[n - 1 - ki]\n        ans %= MOD\n\n        result += ans\n        result %= MOD\n\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m,k = map(int,input().split())\nmod = 998244353\nans = 0\n\ndef comb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n  \nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, n+1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\nfor i in range(k+1):\n    a = pow(m-1, n-i-1, mod)\n    b = comb(n-1,i,mod)\n    ans += (a*b)%mod\nans *= m\nprint(ans%mod)", "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n# \u540c\u3058\u8272\u304c\u96a3\u308a\u5408\u3046\u78ba\u7387...1/M\n# \u96a3\u308a\u5408\u3046\u7b87\u6240...N-1\n# \u3061\u3087\u3046\u3069n\u7b87\u6240\u96a3\u308a\u5408\u3046\u78ba\u7387...(N-1)Cn * (1/M)^n * ((M-1)/M)^(N-1-n)\n# \u5168\u30d1\u30bf\u30fc\u30f3...M^N\n\nN, M, K = list(map(int, input().split()))\nmod = 998244353\ncomb = Combination(202020, mod)\nans = 0\nfor n in range(0, K+1):\n    ans += comb(N-1, n) * pow(M-1, N-1-n, mod) % mod\nans = ans * M % mod\nprint(ans)\n", "def combs_mod(n,k,mod):\n  #nC0\u304b\u3089nCk\u307e\u3067\n  inv = [1]*(k+1)\n  for i in range(1,k+1):\n    inv[i] = pow(i,mod-2,mod)\n  ans = [1]*(k+1)\n  for i in range(1,k+1):\n    ans[i] = ans[i-1]*(n+1-i)*inv[i]%mod\n  return ans\n\ndef solve():\n  ans = 0\n  mod = 998244353\n  N, M, K = map(int, input().split())\n  top = min(K,N-1)\n  combs = combs_mod(N-1,top,mod)\n  for k in range(top+1):\n    ans += M*combs[k]*pow(M-1,N-1-k,mod)\n    ans %= mod\n  return ans\nprint(solve())", "class Combination():\n    def __init__(self, n, mod=10**9+7):\n        self.mod = mod\n        self.fac = [1]*(n+1)\n        for i in range(1,n+1):\n            self.fac[i] = self.fac[i-1] * i % self.mod\n        self.invfac = [1]*(n+1)\n        self.invfac[n] = pow(self.fac[n], self.mod - 2, self.mod)\n        for i in range(n-1, 0, -1):\n            self.invfac[i] = self.invfac[i+1] * (i+1) % self.mod\n    \n    def combination(self, n, r):\n        ans = self.fac[n] * self.invfac[r] % self.mod * self.invfac[n-r] % self.mod\n        if n >= r:\n            return ans\n        else:\n            return 0\n    \n    def factorial(self, i):\n        return self.fac[i]\n    \n    def invfactorial(self, i):\n        return self.invfac[i]\n\n\ndef main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, m, k = map(int, input().split())\n    mod = 998244353\n    c = Combination(n,mod)\n    ans = 0\n    mex = [0]*(k+1)\n    mex[0] = pow(m-1,n-k-1,mod)\n    for i in range(1,k+1):\n        mex[i] = mex[i-1]*(m-1)%mod\n    mex = mex[::-1]\n    for i in range(k+1):\n        ans += c.combination(n-1, i)*mex[i]\n        ans %= mod\n    ans *= m\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M, K = list(map(int, input().split()))\nans = 0\nmod = 998244353\n\nfact = [0] * 200001\ninvfact = [0] * 200001\nfact[0] = 1\ninvfact[0] = 1\n\nfor i in range(1, 200001):\n    fact[i] = fact[i-1] * i % mod\n    \ninvfact[-1] = pow(fact[-1], mod-2, mod)\n\nfor i in reversed(list(range(1, 200000))):\n    invfact[i] = invfact[i+1] * (i+1) % mod\n\nfor k in range(K+1):\n    ans += invfact[N-1-k] * invfact[k] *pow((M-1),N-1-k, mod) % mod\n    ans %= mod\n\nans = ans * M * fact[N-1] % mod\n\nprint(ans)\n\n\n", "\nN,M,K = map(int, input().split())\nMOD = 998244353\n\nfact = [0] * (N+1)\ninv = [0] * (N+1)\n\nfact[0] = fact[1]  = 1\ninv[1] = 1\n\nfor i in range(2, N+1):\n    fact[i] = fact[i-1] * i % MOD\n    inv[i] = MOD - inv[MOD%i] * (MOD//i) % MOD # //\u3067\u826f\u3044\u306e\u304b\u306a?\n\ndef main():\n    if N == 1:\n        print(M)\n        return \n    num = M\n    nums = [M]\n    for i in reversed(range(1,N)):\n        num *= i*(M-1)\n        num *= inv[N-i]\n        num %= MOD\n        nums.append(num)\n    nums.reverse()\n    print(sum(nums[:K+1])%MOD)\n\n    \ndef __starting_point():\n    main()\n__starting_point()", "N,M,K=map(int,input().split())\nMOD=998244353\n\n#\u9006\u5143\u3092\u5b9a\u7fa9\u3059\u308b\ndef inv(a):\n  return pow(a,MOD-2,MOD)\n\n#\u300cn!\u300d\u306e\u5270\u4f59\u3092\u6c42\u3081\u308b\nfact=[0,1]\nfor i in range(2,N+1):\n  fact.append((fact[-1]*i)%MOD)\n\n#nCr(MOD)\u3092\u6c42\u3081\u308b\ndef choose(n,r):\n  if r==0 or r==n:\n    return 1\n  else:\n    return fact[n]*inv(fact[r])*inv(fact[n-r])%MOD\n\n#(M-1)**n(MOD)\u3092\u6c42\u3081\u308b\nexp=[1]\nfor i in range(1,N):\n  exp.append((exp[-1]*(M-1))%MOD)  \n  \n\n#\u7b54\u3048\u3092\u8a08\u7b97\u3059\u308b\nans=0\nfor i in range(K+1):\n  ans+=(M*choose(N-1,i)*exp[N-1-i]%MOD)  \n  ans%=MOD\nprint(ans)  ", "n,m,k=list(map(int,input().split()))\nwari=998244353\n\n\nbasum=0\nfor i in range(k+1):\n\tif i == 0:\n\t\tkumiawase=1\n\telse:\n\t\tkumiawase = kumiawase*(n-i)*pow(i,wari-2,wari)\n\t\tkumiawase %= wari\n\tbasum += m * pow(m-1,n-i-1,wari) * kumiawase\n\tbasum %= wari\n\nprint(basum)\n", "N, M, K = list(map(int, input().split()))\nans = 0\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 998244353\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nfor i in range(K+1):\n    res_i = (M * pow(M-1, N-i-1, p)) % p\n    res_i = (res_i * cmb(N-1, i, p)) % p\n    ans = (ans + res_i) % p\n\nprint(ans)\n", "def mod_pow(a, n, mod):\n    \"\"\"\n    \u4e8c\u5206\u7d2f\u4e57\u6cd5\u306b\u3088\u308b a^n (mod m)\u306e\u5b9f\u88c5\n    :param a: \u7d2f\u4e57\u306e\u5e95\n    :param n: \u7d2f\u4e57\u306e\u6307\u6570\n    :param mod: \u6cd5\n    :return: a^n (mod m)\n    \"\"\"\n\n    result = 1\n    a_n = a\n    while n > 0:\n        if n & 1:\n            result = result * a_n % mod\n        a_n = a_n * a_n % mod\n        n >>= 1\n    return result\n\n\nclass ModCombination:\n    \"\"\"\n    nCk (mod m)\u3092\u6271\u3046\u30af\u30e9\u30b9\n    \"\"\"\n\n    def __init__(self, mod, n_max):\n        \"\"\"\n        \u30a4\u30cb\u30b7\u30e3\u30e9\u30a4\u30b6\n        \u4e88\u3081 1~n\u306e\u968e\u4e57\u3068\u968e\u4e57\u306e\u9006\u5143\u3092\u8a08\u7b97\u3057\u3066\u304a\u304f\n        :param mod: \u6cd5\n        :param n_max: n\u306e\u6700\u5927\u5024(100,000\u3067\u7d041\u79d2)\n        \"\"\"\n        self.mod = mod\n        self.n_max = n_max\n        self.facts = [1, 1]\n        self.inverses = [None, 1]\n        self.fact_inverses = [1, 1]\n\n        for i in range(2, self.n_max + 1):\n            self.facts.append(self.facts[i - 1] * i % self.mod)\n            self.inverses.append(\n                self.mod - self.inverses[self.mod % i] *\n                (self.mod // i) % self.mod\n            )\n            self.fact_inverses.append(\n                self.fact_inverses[i - 1] * self.inverses[i] % self.mod\n            )\n\n    def mod_combination(self, n, k):\n        \"\"\"\n        nCk (mod m)\u3092\u8a08\u7b97\u3059\u308b\n        :param n: n\n        :param k: k\n        :return: nCk (mod m)\n        \"\"\"\n\n        if k == 0:\n            return 1\n        if n == 0:\n            return 0\n\n        denominator = self.fact_inverses[k] * self.fact_inverses[n - k] % self.mod\n        return self.facts[n] * denominator % self.mod\n\n\nMOD = 998244353\n\nN, M, K = list(map(int, input().split(' ')))\n\nans = 0\ncomb = ModCombination(mod=MOD, n_max=N)\nfor k in range(0, K + 1):\n    ans += (M * comb.mod_combination(N - 1, k)) % MOD * mod_pow(M - 1, N - 1 - k, MOD)\n    ans %= MOD\n\nprint(ans)\n", "\ndef main():\n    MOD = 998244353\n\n    n, m, k = list(map(int, input().split()))\n    fact = [0] * 220000\n    invfact = [0] * 220000\n\n    fact[0] = 1\n    for i in range(1, 220000):\n        fact[i] = fact[i-1] * i % MOD\n\n    invfact[220000 - 1] = pow(fact[220000 - 1], MOD-2, MOD)\n    for i in range(220000-2, -1, -1):\n        invfact[i] = invfact[i+1] * (i+1) % MOD\n\n    def nCk(n, k):\n        if k < 0 or n < k: return 0\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n\n    ans = 0\n\n    for i in range(0, k+1):\n        ans += m * pow(m-1, n-i-1, MOD) * nCk(n-1, i) % MOD\n\n    print((ans%MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,K = list(map(int, input().split()))\nmod = 998244353\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 998244353\nN1 = 2 * 10 ** 5 + 10  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N1 + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nans = 0\nmem = 1\nmem = pow(M-1,N-K-1,p)\nfor i in range(K,-1,-1):\n  wk = M * mem\n  wk %= p\n  wk *= cmb(N-1,i,p)\n  #print(wk,mem,i)\n  mem *= (M-1)\n  mem %= p\n  ans += wk\n  ans %= p\n  \nprint(ans)", "N,M,K = list(map(int,input().split()))\nm = 998244353\nans = (M*pow(M-1,N-1,m))%m\nalpha = 1\nfor k in range(1,K+1):\n    alpha = (alpha*(N-k)*pow(k,m-2,m))%m\n    ans = (ans + M*alpha*pow(M-1,N-k-1,m))%m\nprint(ans)\n", "n, m, k = map(int, input().split())\nmod = 998244353\n\ndef powerDX(n, r, mod):\n  if r == 0: return 1\n  if r%2 == 0:\n    return powerDX(n*n % mod, r//2, mod) % mod\n  if r%2 == 1:\n    return n * powerDX(n, r-1, mod) % mod\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n \nfor i in range(2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor i in range(0, k+1):\n  ans += m*cmb(n-1, i, mod)*powerDX(m-1, n-i-1, mod)\n  ans %= mod\nprint(ans)", "class Factorial():\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        ''' n! % mod '''\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._factorial[n]\n    \n    def _make(self, n):\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def fact_inv(self, n):\n        ''' n!^-1 % mod '''\n        if n >= self.mod:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        if self._factorial_inv[n] == -1:\n            self._factorial_inv[n] = self.modinv(self.fact(n))\n        return self._factorial_inv[n]\n    \n    def _make_inv(self, n, r=2):\n        if n >= self.mod:\n            n = self.mod - 1\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        self._factorial_inv[n] = self.modinv(self.fact(n))\n        for i in range(n, r, -1):\n            self._factorial_inv[i-1] = self._factorial_inv[i]*i % self.mod\n    \n    @staticmethod\n    def xgcd(a, b):\n        '''\n        Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b)\n        '''\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        if g != 1:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        return x % self.mod\n\n    def comb(self, n, r):\n        ''' nCr % mod '''\n        if r > n:\n            return 0\n        t = self(n)*self.fact_inv(n-r) % self.mod\n        return t*self.fact_inv(r) % self.mod\n    \n    def comb_(self, n, r):\n        '''\n        nCr % mod\n        when r is not large and n is too large\n        '''\n        c = 1\n        for i in range(1, r+1):\n            c *= (n-i+1) * self.fact_inv(i)\n            c %= self.mod\n        return c\n\n    def comb_with_repetition(self, n, r):\n        ''' nHr % mod '''\n        t = self(n+r-1)*self.fact_inv(n-1) % self.mod\n        return t*self.fact_inv(r) % self.mod\n\n    def perm(self, n, r):\n        ''' nPr % mod '''\n        if r > n:\n            return 0\n        return self(n)*self.fact_inv(n-r) % self.mod\n\nn, m, k = map(int, input().split())\nmod = 998244353\nf = Factorial(mod)\nf._make_inv(n-1)\ncomb = f.comb\ns = 0\nfor i in range(k+1, n):\n    t = comb(n-1, i)*m % mod\n    t = t*pow(m-1, n-1-i, mod) % mod\n    s = (s+t) % mod\nans = (pow(m, n, mod)-s) % mod\nprint(ans)", "N, M, K = list(map(int, input().split()))\nMOD = 998244353\nMAX_N = 10**6\nfac = [0]*(MAX_N)\nfac_inv = [0]*(MAX_N)\nfac[0] = 1\nfor i in range(MAX_N-1):\n    fac[i+1] = fac[i]*(i+1) % MOD\nfac_inv[-1] = pow(fac[-1], MOD-2, MOD)\nfor i in range(MAX_N-2, -1, -1):\n    fac_inv[i] = fac_inv[i+1]*(i+1) % MOD\n\n\ndef nCk(n, k):\n    return fac[n] * fac_inv[k] % MOD * fac_inv[n-k] % MOD\n\n\nans = 0\nfor k in range(K+1):\n    # temp = M*nCk(N-1, k)*pow(M-1, N-K-1, MOD) % MOD\n    temp = (M*nCk(N-1, k)) % MOD*pow(M-1, N-k-1, MOD) % MOD\n    ans += temp\n    ans %= MOD\nprint(ans)\n", "import sys\n\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\nimport heapq\nimport decimal\n# import statistics\nimport queue\n# import numpy as np\n\n# sys.setrecursionlimit(10000001)\nINF = 10 ** 16\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\n\ndef ni(): return int(sys.stdin.readline())\ndef ns(): return list(map(int, sys.stdin.readline().split()))\ndef na(): return list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\nclass ModCombination:\n    # https://atcoder.jp/contests/abc167/submissions/13058694\n    # https://ikatakos.com/pot/programming_algorithm/number_theory/mod_combination\n\n    def __init__(self, maxN, MOD):\n        self._maxN = maxN\n        self._MOD = MOD\n        self.facts = [1]\n        self.invs = [1]*(self._maxN+1)\n\n        fact = 1\n        for i in range(1, self._maxN+1):\n            fact *= i\n            fact %= self._MOD\n            self.facts.append(fact)\n\n        inv = pow(fact, self._MOD-2, self._MOD)\n        self.invs[self._maxN] = inv\n        for i in range(self._maxN, 1, -1):\n            inv *= i\n            inv %= self._MOD\n            self.invs[i-1] = inv\n\n    def nCr(self, n, r):\n        return self.facts[n]*self.invs[r]*self.invs[n-r] % self._MOD\n\n\ndef main():\n\n    n, m, k = ns()\n\n    mc = ModCombination(n, MOD)\n\n    result = 0\n\n    for ki in range(k + 1):\n        ans = 1\n        ans *= m % MOD\n        ans *= pow(m - 1, n - 1 - ki, MOD)\n        ans %= MOD\n        ans *= mc.nCr(n-1, ki)\n        ans %= MOD\n        result += ans\n        result %= MOD\n\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,K = map(int,input().split())\nMOD = 998244353\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nfor i in range(K+1):\n    if i==N: break\n    n = N-i\n    ans += M * pow(M-1,n-1,MOD) * comb(N-1,i)\n    ans %= MOD\nprint(ans)", "def fast_pow(x, n, MOD):\n    res = 1\n    while n:\n        if n & 1:\n            res = res * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return res\n\ndef prepare(n, MOD):\n \n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\nMOD = 998244353\nfact, fact_inv = prepare(3*10**5, MOD)\n\nn, m, k = map(int,input().split())\n\ndp = [0] * (n+1)\nans = 0\nfor i in range(k+1):\n    color = fast_pow(m-1, n-1-i, MOD)\n    order = fact[n-1] * fact_inv[i] % MOD * fact_inv[n-1-i] % MOD\n    ans += m * color % MOD * order % MOD\n    ans %= MOD    \n\nprint(ans)", "import numpy as np\nN, M, K = [int(_) for _ in input().split()]\nmod = 998244353\n\n\nclass Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = N\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nans = 0\nfor r in range(K + 1):\n    ans += comb(N - 1, r) * M * pow(M - 1, N - r - 1, mod)\n    ans %= mod\nprint(ans)\n", "fact = [1 for _ in range(200000)]\ninv = [1 for _ in range(200000)]\nfact_inv = [1 for _ in range(200000)]\n\nmod = 998244353\nfor i in range(2, 200000):\n    fact[i] = (fact[i-1]*i) % mod\n    inv[i] = mod - (inv[mod % i] * (mod // i)) % mod\n    fact_inv[i] = (fact_inv[i-1] * inv[i]) % mod\n\nN, M, K = map(int, input().split())\nans = 0\na = pow(M-1, N-1-K, mod)\nfor i in range(K, -1, -1):\n    ans += (fact[N-1] * fact_inv[i] * fact_inv[N-1-i]) * M * a\n    ans = ans % mod\n    a *= M-1\n    a = a % mod\nprint(ans)", "n, m, k = map(int, input().split())\nmod = 998244353\n\nN = 10**6  # N!\u307e\u3067\u6c42\u3081\u308b\nfact  = [1, 1]  # \u968e\u4e57\u306e\u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1]  # \u968e\u4e57\u306e\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb 1,2,,...\u306e\u9006\u5143\u3092\u6c42\u3081\u3066\u308b\n\n# \u8a08\u7b97 O(1)\ndef comb(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n\n# \u9806\u5217\ndef perm(n, r, mod):\n    if (r<0 or r>n):\n        return 0\n    return fact[n] *  fact_inv[n-r] % mod\n\n# \u524d\u51e6\u7406 O(n)\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * inv[-1]) % mod)\n\nans = 0\nfor i in range(k+1):\n    ans += comb(n-1, i, mod) * m * pow(m-1, n-i-1, mod)\n    ans %= mod\n\nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\n# MOD = int(1e09) + 7\nMOD = 998244353\nINF = int(1e15)\n\n\ndef solve():\n    MAX = 200010\n    fac = [0] * MAX\n    finv = [0] * MAX\n    inv = [0] * MAX\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\n    N, M, K = Scanner.map_int()\n    ans = 0\n    for k in range(K + 1):\n        tmp = M * pow(M - 1, N - 1 - k, MOD)\n        tmp %= MOD\n        cmb = fac[N - 1] * (finv[k] * finv[N - 1 - k] % MOD) % MOD\n        tmp *= cmb\n        tmp %= MOD\n        ans += tmp\n        ans %= MOD\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, math, itertools\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**20\nMOD = 998244353\ndef I(): return int(input())\ndef F(): return float(input())\ndef S(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\n\ndef factorialMod(n, p):\n    fact = [0] * (n+1)\n    fact[0] = fact[1] = 1\n    factinv = [0] * (n+1)\n    factinv[0] = factinv[1] = 1\n    inv = [0] * (n+1)\n    inv[1] = 1\n    for i in range(2, n + 1):\n        fact[i] = (fact[i-1] * i) % p\n        inv[i] = (-inv[p % i] * (p // i)) % p\n        factinv[i] = (factinv[i-1] * inv[i]) % p\n    return fact, factinv\n\ndef combMod(n, r, fact, factinv, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\ndef resolve():\n    N, M, K = LI()\n\n    ans = 0\n    fact, factinv = factorialMod(N, MOD)\n\n    for i in range(K + 1):\n        ans += combMod(N - 1, i, fact, factinv, MOD) * M * pow(M - 1, N - 1 - i, MOD)\n        ans %= MOD\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "MOD = 998244353\n\nn, m, k = map(int, input().split())\n\nfact = [0 for _ in range(n)]\ninvfact = [0 for _ in range(n)]\nfact[0] = 1\nfor i in range(1, n):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[n - 1] = pow(fact[n - 1], MOD - 2, MOD)\n\nfor i in range(n - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nans = 0\nfor i in range(0, k + 1):\n    ans += m * pow(m - 1, n - i - 1, MOD) * nCk(n - 1, i) % MOD\n    \nprint(ans % MOD)", "class Combination:\n    def __init__(self, max_n, _mod):\n        self.mod = _mod\n\n        self.fac = [0 for _ in range(max_n + 10)]\n        self.finv = [0 for _ in range(max_n + 10)]\n        self.inv = [0 for _ in range(max_n + 10)]\n\n        self.fac[0], self.fac[1] = 1, 1\n        self.finv[0], self.finv[1] = 1, 1\n        self.inv[1] = 1\n\n        for i in range(2, max_n + 10):\n            self.fac[i] = self.fac[i - 1] * i % self.mod\n            self.inv[i] = self.mod\n            self.inv[i] -= self.inv[self.mod % i] * (self.mod // i) % self.mod\n            self.finv[i] = self.finv[i - 1] * self.inv[i] % self.mod\n\n    def mod_comb(self, n, k):\n        if n < k or n < 0 or k < 0:\n            return 0\n\n        res = self.fac[n] * (self.finv[k] * self.finv[n - k] % self.mod)\n        res %= self.mod\n\n        return res\n\n\ndef main():\n    mod = 998244353\n    N, M, K = map(int, input().split())\n\n    comb = Combination(N, mod)\n\n    ans = 0\n    for i in range(K + 1):\n        add_v = M * pow(M - 1, N - i - 1, mod) % mod\n        add_v = (add_v * comb.mod_comb(N - 1, i)) % mod\n        ans = (ans + add_v) % mod\n\n    print(ans)\n\n\nmain()", "N, M, K = map(int, input().split())\n\nmod = 998244353\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, N + 1):\n  fac.append( ( fac[-1] * i ) % mod )\n  inv.append( mod - ( inv[mod % i] * (mod // i) % mod ) )\n  finv.append( finv[-1] * inv[-1]  % mod )\n\ndef comb(n, r):\n  if n < r:\n    return 0\n  else:\n    return fac[n] * ( finv[r] * finv[n-r] % mod ) % mod\n\nans = 0\nfor i in range(K+1):\n  ans += comb(N-1, i) * M * pow(M-1, N-1-i, mod)\n  ans %= mod\n\nprint(ans)", "N, M, K = list(map(int, input().split()))\nmod = 998244353\n\nc = 1\nanswer = 0\n\nfor i in range(K+1):\n    answer += (M * c  * pow(M-1, N - i - 1, mod)) % mod\n    answer %= mod\n    c = (c * (N-i-1) * pow(i+1, mod-2, mod)) % mod\n    \nprint(answer)", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque, Counter\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport heapq\nm = 2 * 10 ** 5\nmod = 998244353\nN, M, K = map(int, input().split())\nans = 0\nA = [0] * (m + 5)\nA_inv = [0] * (m+5)\ninv = [0] * (m+5)\n\nA[0] = A[1] = 1\nA_inv[0] = A_inv[1] = 1\ninv[1] = 1\nfor j in range(2, m+5):\n    A[j] = A[j - 1] * j % mod\n    inv[j] = mod - inv[mod % j] * (mod // j) % mod\n    A_inv[j] = A_inv[j - 1] * inv[j] % mod\n\ndef cmb(n, k, mod):\n    return A[n] * (A_inv[k] * A_inv[n-k] % mod) % mod\nfor i in range(K+1):\n    ans =  (ans + (cmb(N - 1, i, mod) * M % mod) * (pow(M - 1, N - 1 - i, mod)) % mod) % mod\nprint(ans)"]
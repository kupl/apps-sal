["n=int(input())\npos=[]\nneg=[]\nfor _ in range(n):\n    x,a=list(map(int,input().split()))\n    if x > 0:\n        pos.append((x, a))\n    else:\n        neg.append((-x, a))\npos=[a for x,a in sorted(pos)]\nneg=[a for x,a in sorted(neg)]\nif len(pos)==len(neg):\n    print(sum(pos)+sum(neg))\nelse:\n    if len(pos)<len(neg):\n        pos,neg=neg,pos\n    print(sum(neg)+sum(pos[:len(neg)+1]))\n", "n = int(input())\nl = []\nfor i in range(n):\n    l.append(list(map(int, input().split())))\nl = list(sorted(l))\npos = []\nneg = []\nfor i in range(n):\n    if l[i][0] < 0:\n        neg.append(l[i][1])\n    else:\n        pos.append(l[i][1])\nneg = list(reversed(neg))\n\nif len(neg) == len(pos):\n    print(sum(neg)+sum(pos))\nelif len(neg) > len(pos):\n    print(sum(pos)+sum(neg[:len(pos)+1]))\nelse:\n    print(sum(neg)+sum(pos[:len(neg)+1]))\n", "n = int(input())\nl = []\nr = []\nfor i in range(n):\n    x, a = list(map(int, input().split()))\n    if x < 0:\n        l.append((x, a))\n    else:\n        r.append((x, a))\nl.sort(reverse=True)\nr.sort()\ntot = 0\nfor i in range(min(len(l), len(r))):\n    tot += l[0][1]\n    tot += r[0][1]\n    l.pop(0)\n    r.pop(0)\nif r != []:\n    tot += r[0][1]\nelif l != []:\n    tot += l[0][1]\nprint(tot)\n", "num = int(input())\nneg = []\npos = []\nfor x in range(num):\n    coord, app = list(map(int,input().split(' ')))\n    if coord < 0:\n        neg.append([-1*coord,app])\n    else:\n        pos.append([coord,app])\npos.sort()\nneg.sort()\nif len(neg)<len(pos):\n    a = neg\n    b = pos[:len(neg)+1]\nelif len(pos)<len(neg):\n    a = pos\n    b = neg[:len(pos)+1]\nelse:\n    a = pos\n    b = neg\ntot = 0\nfor i in a:\n    tot += i[1]\nfor i in b:\n    tot+= i[1]\nprint(tot)\n", "n = int(input())\n\na = []\nb = []\n\nfor i in range(n):\n\tx,y = map(int,input().split())\n\tif x >= 0:\n\t\ta.append((x,y))\n\telse:\n\t\tb.append((x,y))\n\na.sort(key=lambda tup:tup[0])\nb.sort(key=lambda tup:tup[0])\nb = b[::-1]\n\nminLength = min(len(a),len(b))\n\ntotal = 0\n\nfor i in range(minLength):\n\ttotal += b[i][1] + a[i][1]\n\nif(len(a) > minLength):\n\ttotal += a[minLength][1]\nelif(len(b) > minLength):\n\ttotal += b[minLength][1]\n\nprint(total)", "def read_data():\n    n = int(input())\n    xa = []\n    for i in range(n):\n        x, a = list(map(int, input().split()))\n        xa.append((x, a))\n    xa.sort()\n    return n, xa\n\ndef solve(n, xa):\n    count = 0\n    for x, a in xa:\n        if x < 0:\n            count += 1\n        else:\n            break\n    xa_minus = xa[:count]\n    xa_plus = xa[count:]\n    xa_minus.reverse()\n    if len(xa_plus) > len(xa_minus):\n        return sum(a for x, a in xa_plus[:len(xa_minus)+1]) + sum(a for x, a in xa_minus)\n    elif len(xa_plus) < len(xa_minus):\n        return sum(a for x, a in xa_minus[:len(xa_plus)+1]) + sum(a for x, a in xa_plus)\n    else:\n        return sum(a for x, a in xa)\n\nn, xa = read_data()\nprint(solve(n, xa))\n", "l = 0\nlc = 0\nr = 0\nrc = 0\nn = int(input())\narrl = []\narrr = []\nfor i in range (n):\n    a, b = list(map(int, input().split()))\n    if (a < 0):\n        arrl.append((-a, b))\n    else:\n        arrr.append((a, b))\narrr.sort()\narrl.sort()\nleft = 0\nright = 0\nif (len(arrr) == len(arrl)):\n    for i in range(min(len(arrr), len(arrl))):\n        left += (arrr[i][1] + arrl[i][1])\nelif (len(arrr) < len(arrl)):\n    for i in range(min(len(arrr), len(arrl))):\n        left += (arrr[i][1] + arrl[i][1])\n    left += arrl[len(arrr)][1]\nelse:\n    for i in range(min(len(arrr), len(arrl))):\n        left += (arrr[i][1] + arrl[i][1])\n    left += arrr[len(arrl)][1]\n    \nprint(left)\n", "n = int(input())\nxa = []\nfor i in range(n):\n    xa.append([int(c) for c in input().split()])\n\nxa.sort()\n\nmn = 0\nbn = 0\nfor i in range(n):\n    if xa[i][0]<0:\n        mn +=1\n    else:\n        bn +=1\n\nma = min(2* min(bn, mn) + 1, n)\n\ntotal = 0\nif bn >= mn:\n    for i in range(ma):\n        total += xa[i][1]\nelse:\n    for i in range(n-ma, n):\n        total += xa[i][1]\n\nprint(total)", "N = int(input())\nplus = []\nminus = []\nfor i in range(N):\n    pos, x = list(map(int, input().split()))\n    if pos > 0:\n        plus.append((-pos, x))\n    else:\n        minus.append((pos, x))\n\nplus.sort()\nminus.sort()\nd = True if len(plus) > len(minus) else False\nans = 0\nwhile True:\n    if d:\n        if not plus: break\n        _, x = plus.pop()\n        ans += x\n        d = False\n    else:\n        if not minus: break\n        _, x = minus.pop()\n        ans += x\n        d = True\nprint(ans)\n    \n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,copy\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\n\n\ndef run(n,x,l,r):\n    s = 0\n    curr = 1\n    for i in range(n):\n        skip = (l[i]-curr) // x\n        s += r[i]-curr-skip*x+1\n        curr = r[i]+1\n    print(s)\n\n\ndef main(info=0):\n    n = I()\n    #x,a = MIT(n,2)\n\n    m = MI(n,2)\n\n    p = sorted([tuple(x) for x in m if x[0]>0])\n    n = sorted([tuple(x) for x in m if x[0]<0])[::-1]\n\n    pn = len(p)\n    nn = len(n)\n    mn = min(pn,nn)\n\n    def apples(arr, l):\n        return sum(x[1] for x in arr[:l])\n\n    if nn > pn:\n        ans = apples(n,mn+1)+apples(p,mn)\n    elif pn > nn:\n        ans = apples(n,mn)+apples(p,mn+1)\n    else:\n        ans = apples(n,mn)+apples(p,mn)\n\n    print(ans)\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nleft = []\nright = []\nfor i in range(n):\n    x, a = [int(i) for i in input().split()]\n    if x < 0:\n        left.append([x, a])\n    else:\n        right.append([x, a])\nleft.sort()\nright.sort()\nans = 0\nlength = min(len(left), len(right))\nfor i in left[::-1]:\n    if length <= 0:\n        break\n    ans += i[1]\n    length -= 1\nlength = min(len(left), len(right))\nfor i in right:\n    if length <= 0:\n        break\n    ans += i[1]\n    length -= 1\nif len(left) > len(right):\n    ans += left[::-1][len(right)][1]\nelif len(right) > len(left):\n    ans += right[len(left)][1]\nprint(ans)\n", "n = int(input())\na = []\nfor i in range(n):\n    a.append(tuple(map(int, input().split())))\na.sort()\nans = 0\nind = 0\nwhile (ind < n and a[ind][0] < 0):\n    ind += 1\nk = 1\nsign = -1\nwhile (0 <= ind < n):\n    ans += a[ind][1]\n    ind += sign * k\n    k += 1\n    sign = -sign\nsecond_ans = 0\nind = n - 1\nwhile (ind >= 0 and a[ind][0] > 0):\n    ind -= 1\nk = 1\nsign = 1\nwhile (0 <= ind < n):\n    second_ans += a[ind][1]\n    ind += sign * k\n    k += 1\n    sign = -sign\nprint(max(ans, second_ans))", "n = int(input())\nleft = []\nright = []\nfor i in range(n):\n    tmp = tuple(map(int, input().split()))\n    if tmp[0] < 0:\n        left.append(tmp)\n    else:\n        right.append(tmp)\nm = len(left) - len(right)\nall1 = left + right\nans = 0\nif m == 1 or m == -1 or m == 0:\n    for i in range(n):\n        ans += all1[i][1]\n    print(ans)\n    return\nif m < 0:\n    all1.sort()\n    for i in range(len(left) * 2 + 1):\n        ans += all1[i][1]\n    print(ans)\n    return\nall1.sort()\nfor i in range(m - 1, n):\n    ans += all1[i][1]\nprint(ans)\n", "n=int(input())\na=[[0,0]]\nxpos=0\nxneg=0\nfor i in range(n):\n    x,y=input().split(' ')\n    a.append([int(x),int(y)])\n    if int(x)<0:\n        xneg+=1\n    else:\n        xpos+=1\na.sort()\nm=a.index([0,0])\nif xpos>xneg:\n    l=0\n    h=m+xneg+2\nelif xneg>xpos:\n    l=m-xpos-1\n    h=n+1\nelse:\n    l=0\n    h=n+1\ns=0\nfor i in range(l,h):\n    s+=a[i][1]\nprint(s)", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport time\n\nn   = int(input())\nN   = {}\nP   = {}\n\nfor i in range(n):\n    buf = input().split()\n    x   = float(buf[0])\n    a   = int (buf[1])\n    if x < 0:\n        N[-x] = a\n    else:\n        P[x] = a\n\nstart = time.time()\n\nif len(N) > len(P):\n    buf = [ N[i] for i in sorted(N.keys()) ]\n    ans = sum(P.values()) + sum(buf[:len(P)+1])\nelse:\n    buf = [ P[i] for i in sorted(P.keys()) ]\n    ans = sum(N.values()) + sum(buf[:len(N)+1])\nprint(ans)\nfinish = time.time()\n#print(finish - start)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nn = int(input())\nLeft = []\nRight  = []\nfor i in range(n):\n    t = list(map(int,input().split()))\n    if t[0] < 0 :Left.append(t) \n    if t[0] > 0 :Right.append(t)\n\nnum = min(len(Left),len(Right))\n\nRight = [a[1] for a in sorted(Right,key=lambda x:x[0])]\nLeft  = [a[1] for a in sorted(Left,key=lambda x:-x[0])]\n\nif len(Left) < len(Right):\n    ans = sum(Right[:num+1] + Left[:num])\nelif len(Left) > len(Right):\n    ans = sum(Right[:num] + Left[:num+1])\nelse:\n    ans = sum(Right[:num] + Left[:num])\nprint(ans)\n\n", "n=int(input())\npos=[]\nneg=[]\nfor i in range(n):\n    a,b=list(map(int,input().split()))\n    if a<0:\n        neg.append((a,b))\n    else:\n        pos.append((a,b))\nneg=sorted(neg,reverse=True)\npos.sort()\nno1=0\nno2=0\ntemp1=list(neg)\ntemp2=list(pos)\ni=0\nwhile(True):\n   if i==0:\n       if len(temp1)==0:\n           break\n       x,cur=temp1[0]\n       i=1\n       no1+=cur\n       temp1.pop(0)\n   if i==1:\n       if len(temp2)==0:\n           break\n       x,cur=temp2[0]\n       i=0\n       no1+=cur\n       temp2.pop(0)\ni=0\nwhile(True):\n    if i==0:\n        if len(pos)==0:\n            break\n        x,cur=pos[0]\n        i=1\n        no2+=cur\n        pos.pop(0)\n    if i==1:\n        if len(neg)==0:\n            break\n        x,cur=neg[0]\n        i=0\n        no2+=cur\n        neg.pop(0)\nprint(max(no1,no2))\n", "n = int(input())\nneg = []\npos = []\n\nfor i in range(n):\n    inp = input().split()\n    x = int(inp[0])\n    a = int(inp[1])\n    if x < 1:\n        neg += [[-x, a]]\n    else:\n        pos += [[x,a]]\n\nneg = sorted(neg)\npos = sorted(pos)\nne = len(neg)\np = len(pos)\nnum = ne\nlonger = pos\nnotsame = True\n\nif ne > p:\n    num = p\n    longer = neg\nelif ne == p:\n    notsame = False\n\na = 0\nfor i in range(num):\n    a += pos[i][1]\n    a += neg[i][1]\nif notsame:\n    a += longer[num][1]\n\nprint(a)", "from operator import itemgetter\n\n\ndef my_sum(x):\n    res = 0\n    for v in x:\n        res += v[1]\n    return res\n\n\ndef main():\n    n = int(input())\n    left = []\n    right = []\n    for i in range(n):\n        s = list(map(int, input().split()))\n        if s[0] < 0:\n            left.append(s)\n        else:\n            right.append(s)\n\n    res = 0\n    if len(left) < len(right):\n        res += my_sum(left)\n        sr = sorted(right)\n        for v in range(len(left) + 1):\n            res += sr[v][1]\n    else:\n        res += my_sum(right)\n        sr = sorted(left, key=itemgetter(0), reverse=True)\n        for v in range(min(len(right) + 1, len(left))):\n            res += sr[v][1]\n\n    print(res)\n\n\nmain()\n", "R = lambda: list(map(int, input().split()))\n\nn = R()[0]\n\na = []\n\nfor i in range(n):\n    a.append(R())\na.sort()\nnpos = 0\nnneg = 0\n\nfor i in a:\n    if i[0] > 0:\n        npos+=1\n    else:\n        nneg +=1\n\nans = 0\nif(npos >= nneg+1):\n    ans = sum(i[1] for i in a[:nneg + nneg + 1])\nelse:\n    ans = sum(i[1] for i in a[max(0, nneg - 1 - npos):])\nprint(ans)\n\n", "\"\"\"\n\ncreated by huash06 at 2015-07-14\n\n\"\"\"\n__author__ = 'huash06'\n\nimport os\nimport sys\nimport functools\nimport collections\nimport itertools\n\n# sys.stdin = open(\"input.txt\", \"r\")\n\n\ndef collectApple(tree):\n    if not tree:\n        return 0\n    left = sorted([x for x in tree if x[0] < 0])\n    right = sorted([x for x in tree if x[0] > 0])\n\n    res = 0\n    if len(left) > len(right):\n        res += sum([x[1] for x in right])\n        res += sum([x[1] for x in left[len(left) - len(right) - 1:]])\n    else:\n        res += sum([x[1] for x in left])\n        res += sum([x[1] for x in right[:min(len(left)+1, len(right))]])\n    return res\n\n\nN = int(input())\n\ntree = []\nfor i in range(N):\n    tree.append([int(x) for x in input().split()])\nprint(collectApple(tree))\n\n\n\n\n", "left = 0\nright = 0\narr = []\nn = int(input())\nfor i in range (n):\n    t, v = list(map(int, input().split(\" \")))\n    arr.append([t, v])\n    if arr[i][0] < 0:\n        left+=1\n    else:\n        right+=1\n\narr = sorted(arr, key=lambda a: a[0])\n\nsum = 0\nif left < right:\n    for i in range(2*left+1):\n        sum += arr[i][1]\nelif left == right:\n    for i in range(2*left):\n        sum += arr[i][1]\nelse:\n    for i in range(left-right-1, left+right):\n        sum += arr[i][1]\n        \nprint(sum)\n\n\n\n", "#!/usr/bin/env python\n# 558A_apple.py - Codeforces.com 558A Apple quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains one number n (1 n 100), the number of apple trees\nin Lala Land.\n\nThe following n lines contains two integers each xi, ai, representing the\nposition of the ith tree and number of apples on it.\n\nIt's guaranteed that there is at most one apple tree at each coordinate.\nIt's guaranteed that no tree grows in point 0.\nOutput\n\nOutput the maximum number of apples Amr can collect.\n\"\"\"\n\n# Standard modules\nimport unittest\nimport sys\nimport re\nimport random\nimport bisect\nimport array\n\n# Additional modules\n\n\n###############################################################################\n# Apple Class\n###############################################################################\n\n\nclass Apple:\n    \"\"\" Apple representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n\n        self.gn = args[0]\n        self.list = args[1]\n        self.ploc = []\n        self.nloc = []\n\n        for i in range(0, len(self.list), 2):\n            loc = (self.list[i], self.list[i+1])\n            if self.list[i] > 0:\n                self.ploc.append(loc)\n            else:\n                self.nloc.append(loc)\n\n        self.ploc1 = list(reversed(sorted(self.ploc)))\n        self.nloc1 = list((sorted(self.nloc)))\n\n        self.ploc2 = list(self.ploc1)\n        self.nloc2 = list(self.nloc1)\n\n        self.tot1 = self.tot(1, self.ploc1, self.nloc1)\n        self.tot2 = self.tot(0, self.ploc2, self.nloc2)\n\n    def tot(self, dir, ploc, nloc):\n        result = 0\n        while True:\n            if dir:\n                if len(ploc) == 0:\n                    break\n                result += ploc.pop()[1]\n                if len(self.nloc) == 0:\n                    break\n            else:\n                if len(nloc) == 0:\n                    break\n                result += nloc.pop()[1]\n                if len(ploc) == 0:\n                    break\n            dir = 0 if dir == 1 else 1\n        return result\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = max(self.tot1, self.tot2)\n\n        return str(result)\n\n\n###############################################################################\n# Helping classes\n###############################################################################\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = int(uinput())\n    s = \" \".join(uinput() for i in range(num))\n    numa = list(map(int, s.split()))\n\n    # Decoding inputs into a list\n    return [num, numa]\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Apple(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"2\\n-1 5\\n1 5\"\n        self.assertEqual(calculate(test), \"10\")\n        self.assertEqual(get_inputs(test)[0], 2)\n        self.assertEqual(list(get_inputs(test)[1]), [-1, 5, 1, 5])\n\n        # Sample test 2\n        test = \"3\\n-2 2\\n1 4\\n-1 3\"\n        self.assertEqual(calculate(test), \"9\")\n\n        # Sample test 3\n        test = \"3\\n1 9\\n3 5\\n7 10\"\n        self.assertEqual(calculate(test), \"9\")\n\n        test = \"3\\n-1 9\\n-3 5\\n-7 10\"\n        self.assertEqual(calculate(test), \"9\")\n\n        # Time limit test\n        imax = 100\n        test = str(imax) + \"\\n\"\n        s = (str(i-100) + \" \" + str(i+1-100) for i in range(imax))\n        test += \"\\n\".join(s)\n        self.assertEqual(calculate(test), \"0\")\n\n    def test_Apple_class__basic_functions(self):\n        \"\"\" Apple class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Apple([2, [-1, 5, 1, 5]])\n        self.assertEqual(d.list[0], -1)\n        self.assertEqual(d.nloc[0], (-1, 5))\n\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate())\n\n__starting_point()", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n'''\nLala Land has exactly n apple trees\nTree number i is located in a position xi and has ai apples growing on it\n\nObj: wants to collect apples from the apple trees\nStart: Amr currently stands in x\u2009=\u20090 position\n'''\n\n\ndef solve(n, xas):\n    minus = sorted([xa for xa in xas if xa[0] < 0])\n    minus_len = len(minus)\n    plus = sorted([xa for xa in xas if xa[0] > 0])\n    plus_len = len(plus)\n    d = abs(minus_len - plus_len)\n    if d < 2:\n        pass\n    elif minus_len < plus_len:\n        plus = plus[:-(d - 1)]\n    else:\n        minus = minus[d - 1:]\n    return sum([x[1] for x in minus]) + sum([x[1] for x in plus])\n\n\ndef getinput():\n    def getints_line():\n        return list(map(int, input().split(' ')))\n    n = int(input())\n    xas = [getints_line() for _ in range(n)]\n    return n, xas\n\n\ndef test():\n    # print(solve(2, [[-1, 5], [1, 5]]))\n    # print(solve(3, [[-2, 2], [1, 4], [-1, 3]]))\n    # print(solve(3, [[1, 9], [3, 5], [7, 10]]))\n    assert solve(2, [[-1, 5], [1, 5]]) == 10\n    assert solve(3, [[-2, 2], [1, 4], [-1, 3]]) == 9\n    assert solve(3, [[1, 9], [3, 5], [7, 10]]) == 9\n\n\ndef main():\n    # test()\n    print(solve(*getinput()))\n    # print('\\n'.join(map(str, solve(*getinput()))))\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
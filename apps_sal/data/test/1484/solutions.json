["from functools import lru_cache\nN, K = list(map(int, input().split()))\nP = 998244353\nA = [K+100] + [int(a) for a in input().split()] + [K+j for j in range(1, 10)]\n# A = [K+100] + [1, 2] + [-1 for a in range(N-4)] + [3,4]+ [K+j for j in range(1, 10)]\n\nX = [[0,0] for _ in range(N//2+5)]\nX[0][0] = 1\nfor i in range(1, N//2+2):\n    X[i][0] = X[i-1][1]\n    X[i][1] = (X[i-1][0] * (K-1) + X[i-1][1] * (K-2)) % P\n    \nY = [[0,0] for _ in range(N//2+5)]\nY[0][1] = 1\nfor i in range(1, N//2+2):\n    Y[i][0] = Y[i-1][1]\n    Y[i][1] = (Y[i-1][0] * (K-1) + Y[i-1][1] * (K-2)) % P\n    \ndef calc(l, a, b):\n    if a > K and b > K:\n        return (K * pow(K-1, l-1, P)) % P\n    if a > K or b > K:\n        return pow(K-1, l, P)\n    if a == b:\n        return X[l+1][0]\n    else:\n        return Y[l+1][0]\n\n\n\nl = 0\nans = 1\nfor j in range(2):\n    pre = K + 50 + j\n    for i in range(j, N+5, 2):\n        if A[i] == -1:\n            l += 1\n        elif l > 0:\n            ans *= calc(l, pre, A[i])\n            ans %= P\n            pre = A[i]\n            l = 0\n        elif pre == A[i]:\n            # print(A)\n            ans = 0\n            break\n        else:\n            pre = A[i]\n\nprint(ans%P)\n", "import sys\ninput = sys.stdin.readline\n\nmod=998244353\n\nn,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\n\nA0=[A[i] for i in range(n) if i%2==0]\nA1=[A[i] for i in range(n) if i%2==1]\n\nfor j in range(1,len(A0)):\n    if A0[j]!=-1 and A0[j]==A0[j-1]:\n        print(0)\n        return\n\nfor j in range(1,len(A1)):\n    if A1[j]!=-1 and A1[j]==A1[j-1]:\n        print(0)\n        return\n\n        \n    \nOPENLIST=[]\n\nj=0\nL=len(A0)\nwhile j<L:\n    OPEN=CLOSE=-10\n    if A0[j]==-1:\n        if j==0:\n            OPEN=-11\n        else:\n            OPEN=A0[j-1]\n            \n        COUNT=0\n        while A0[j]==-1:\n            COUNT+=1\n            j+=1\n\n            if j==L:\n                CLOSE=-11\n                break\n\n        if OPEN==-11 and CLOSE==-11:\n            OPENLIST.append([COUNT,0])\n        elif OPEN==-11 or CLOSE==-11:\n            OPENLIST.append([COUNT,1])\n        else:\n            if A0[j]==OPEN:\n                OPENLIST.append([COUNT,3])\n            else:\n                OPENLIST.append([COUNT,2])\n\n    else:\n        j+=1\nj=0\nL=len(A1)\nwhile j<L:\n    OPEN=CLOSE=-10\n    if A1[j]==-1:\n        if j==0:\n            OPEN=-11\n        else:\n            OPEN=A1[j-1]\n            \n        COUNT=0\n        while A1[j]==-1:\n            COUNT+=1\n            j+=1\n\n            if j==L:\n                CLOSE=-11\n                break\n\n        if OPEN==-11 and CLOSE==-11:\n            OPENLIST.append([COUNT,0])\n        elif OPEN==-11 or CLOSE==-11:\n            OPENLIST.append([COUNT,1])\n        else:\n            if A1[j]==OPEN:\n                OPENLIST.append([COUNT,3])\n            else:\n                OPENLIST.append([COUNT,2])\n\n    else:\n        j+=1\n\nANS=1\nfor x,y in OPENLIST:\n    if y==0:\n        ANS=ANS*k*pow(k-1,x-1,mod)%mod\n\n    elif y==1:\n        ANS=ANS*pow(k-1,x,mod)%mod\n\n    elif y==2:\n        DP0=0\n        DP1=1\n\n        for r in range(x+1):\n            NDP0=DP1\n            NDP1=(DP0*(k-1)+DP1*(k-2))%mod\n\n            DP0=NDP0\n            DP1=NDP1\n\n\n\n        ANS=ANS*DP0%mod\n\n    else:\n        DP0=1\n        DP1=0\n\n        for r in range(x+1):\n            NDP0=DP1\n            NDP1=(DP0*(k-1)+DP1*(k-2))%mod\n\n            DP0=NDP0\n            DP1=NDP1\n\n\n\n        ANS=ANS*DP0%mod\n        \n            \n\nprint(ANS)\n        \n\n\n        \n        \n\n", "import sys\n\nmod = 998244353\ndef mult(a, b):\n    y = 1\n    for i in range(b):\n        y = y * a % mod\n    return y\n\ndef getS(cnt, k, b1, b2):\n    if b1 < b2:\n        b1, b2 = b2, b1\n    if b1 == b2 == 0:\n        s = mult(k - 1, cnt - 1)\n        s = s * k % mod\n        return s\n    if b2 == 0:\n        return mult(k - 1, cnt)\n    re = [k - 1] * cnt\n    for i in range(1, cnt):\n        re[i] = re[i - 1] * (k - 1) % mod\n    re[0] = k - (1 if b1 == b2 else 2)\n    # print(re)\n    tot = 0\n    mm = 1\n    for i in range(cnt - 1, -1, -1):\n        tot += mm * re[i]\n        mm *= -1\n        tot = (tot + mod) % mod\n    return tot\n    \n\ndef solve(x, k):\n    n = len(x)\n    x = [0] + x + [0]\n    st = -1\n    rt = 1\n    for i in range(n + 2):\n        if x[i] != -1:\n            if st != -1:\n                rt = (rt * getS(i - st, k, x[st - 1], x[i])) % mod\n            st = -1\n        else:\n            if st == -1:\n                st = i\n    return rt\n    \n    \nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nfor i in range(0, n - 2):\n    if a[i] != -1 and a[i] == a[i + 2]:\n        print(0)\n        return\neven = solve(a[::2], k)\nodd = solve(a[1::2], k)\nprint(even * odd % mod)\n\n", "MOD = 998244353\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nch = []\nlt = None\nfor beg in (0, 1):\n\tfor i in range(beg, n, 2):\n\t\tif a[i] == -1:\n\t\t\tif lt is None:\n\t\t\t\tlt = -1 if i - 2 < 0 else a[i - 2]\n\t\t\t\tsz = 0\n\t\t\tsz += 1\n\t\t\tif i + 2 >= n:\n\t\t\t\tch.append((lt, -1, sz))\n\t\t\t\tlt = None\n\t\t\telif a[i + 2] != -1:\n\t\t\t\tch.append((lt, a[i + 2], sz))\n\t\t\t\tlt = None\n\nans = int(all(a[i] != a[i + 2] for i in range(n - 2) if a[i] != -1))\nfor lt, rt, sz in ch:\n\tif sz == 1:\n\t\tcur = k if lt == -1 and rt == -1 else k - 1 if lt == -1 or rt == -1 or lt == rt else k - 2\n\telse:\n\t\teq, neq = 1 if lt == -1 else 0, 1\n\t\tfor _ in range(sz - 1):\n\t\t\teq, neq = neq * (k - 1) % MOD, (neq * (k - 2) + eq) % MOD\n\t\tcur = neq * (k - 1) + eq if rt == -1 else neq * (k - 1) if lt == rt else neq * (k - 2) + eq\n\tans = ans * cur % MOD\nprint(ans)", "n,k = map(int, input().strip().split())\nl = list(map(int, input().strip().split()))\ntest = True\nmd = 998244353\nevens = [0]\nodds = [0]\nfor i in range(n):\n    if i%2:\n        odds.append(l[i])\n    else:\n        evens.append(l[i])\nevens.append(-10)\nodds.append(-10)\nsegs = []\nl = len(odds)\ncont = False\ntest = True\nfor i in range(l):\n    if odds[i] == -1 and cont == False:\n        a = i-1\n        cont = True\n    elif odds[i] != -1 and cont == True:\n        cont = False\n        b = i\n        segs.append(odds[a:b+1])\n    if i > 0:\n        if odds[i-1] == odds[i] and  odds[i] != -1:\n            test = False\nl = len(evens)\ncont = False\nfor i in range(l):\n    if evens[i] == -1 and cont == False:\n        a = i-1\n        cont = True\n    elif evens[i] != -1 and cont == True:\n        cont = False\n        b = i\n        segs.append(evens[a:b+1])\n    if i > 0:\n        if evens[i-1] == evens[i] and  evens[i] != -1:\n            test = False\nans = 1\nfor seg in segs:\n    l = len(seg) - 2\n    dp = [[0,0] for i in range(l)]\n    a = seg[-1]\n    b = seg[0]\n    if b == 0:\n        dp[0][0] = 1\n        dp[0][1] = k-1\n    elif b == a:\n        dp[0][0] = 0\n        dp[0][1] = k-1\n    elif b != a:\n        dp[0][0] = 1\n        dp[0][1] = k-2\n    for i in range(1,l):\n        dp[i][0] = (dp[i-1][1])%md\n        dp[i][1] = (dp[i-1][0]*(k-1) + dp[i-1][1]*(k-2))%md\n    if a == -10:\n        ans *= (dp[l-1][0] + dp[l-1][1])\n    else:\n        ans *= dp[l-1][1]\n    ans %= md\nif test == False:\n    print(0)\nelse:\n    print(ans)", "def solve1(a, l, r, k, mod):\n    n = len(a)\n\n    if l == 0 and r == n:\n        return k * (k - 1) ** (n - 1)\n\n    if l == 0 or r == n:\n        return (k - 1) ** (r - l)\n\n    x = a[l - 1]\n    y = a[r]\n\n    dp0 = [0] * (r - l)\n    dp1 = [0] * (r - l)\n\n    if x != y:\n        dp0[0] = k - 2\n        dp1[0] = 1\n    else:\n        dp0[0] = k - 1\n        dp1[0] = 0\n\n    for i in range(1, (r - l)):\n        dp0[i] = dp0[i - 1] * (k - 2) + dp1[i - 1] * (k - 1)\n        dp1[i] = dp0[i - 1]\n        \n        dp0[i]%=mod\n        dp1[i]%=mod\n\n    return dp0[-1]\n\n\ndef solve(a, k, mod):\n    n = len(a)\n\n    res = 1\n\n    i = 0\n    while i < n:\n        if i < n - 1 and a[i] != -1 and a[i] == a[i + 1]:\n            return 0\n\n        if a[i] != -1:\n            i += 1\n            continue\n\n        j = i\n\n        while j < n and a[i] == a[j]:\n            j += 1\n\n        res *= solve1(a, i, j, k, mod)\n\n        i = j\n    return res\n\n\nn, k = list(map(int, (input().split())))\n\nsrc = list(map(int, (input().split())))\n\ne = src[0::2]\no = src[1::2]\n\nmod = 998244353\n\nprint(solve(e, k, mod) * solve(o, k, mod) % mod)\n", "3.7\n\nimport sys\n\nmod = 998244353\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nub = [0 for i in range(n)]\nb = [[0, 0] for i in range(n)]\nub[0] = 1\nb[0] = [0, 1]\nfor i in range(1, n):\n    ub[i] = ub[i - 1] * (k - 1) % mod\n    sb = b[i - 1][0] + b[i - 1][1] * (k - 1) % mod\n    if sb >= mod:\n        sb -= mod\n    for j in range(2):\n        b[i][j] = sb - b[i - 1][j]\n        if b[i][j] < 0:\n            b[i][j] += mod\n\nans = 1\nfor arr in [a[::2], a[1::2]]:\n\n    for i in range(1, len(arr)):\n        if (arr[i] != -1) and (arr[i] == arr[i - 1]):\n            print(0)\n            return\n\n    cur = -1\n    for i, x in enumerate(arr):\n        if x == -1:\n            continue\n        cnt = i - cur - 1\n        if cnt > 0:\n            if cur == -1:\n                ans = (ans * ub[cnt - 1] * (k - 1)) % mod\n            else:\n                s = b[cnt - 1][0] + b[cnt - 1][1] * (k - 1) % mod\n                if s >= mod:\n                    s -= mod\n                if x == arr[cur]:\n                    s -= b[cnt - 1][0]\n                else:\n                    s -= b[cnt - 1][1]\n                if s < 0:\n                    s += mod\n                ans = ans * s % mod\n        cur = i\n    if cur == -1:\n        ans = (ans * ub[len(arr) - 1] * k) % mod\n    elif cur < len(arr) - 1:\n        cnt = len(arr) - cur - 1\n        s = b[cnt - 1][0] + b[cnt - 1][1] * (k - 1) % mod\n        if s >= mod:\n            s -= mod\n        ans = ans * s % mod\n\n\nprint(ans)\n", "3.7\n\nimport sys\n\nmod = 998244353\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nub = [0 for i in range(n)]\nb = [[0, 0] for i in range(n)]\nub[0] = 1\nb[0] = [0, 1]\nfor i in range(1, n):\n    ub[i] = ub[i - 1] * (k - 1) % mod\n    sb = b[i - 1][0] + b[i - 1][1] * (k - 1) % mod\n    if sb >= mod:\n        sb -= mod\n    for j in range(2):\n        b[i][j] = sb - b[i - 1][j]\n        if b[i][j] < 0:\n            b[i][j] += mod\n\nans = 1\nfor arr in [a[::2], a[1::2]]:\n\n    for i in range(1, len(arr)):\n        if (arr[i] != -1) and (arr[i] == arr[i - 1]):\n            print(0)\n            return\n\n    cur = -1\n    for i, x in enumerate(arr):\n        if x == -1:\n            continue\n        cnt = i - cur - 1\n        if cnt > 0:\n            if cur == -1:\n                ans = (ans * ub[cnt - 1] * (k - 1)) % mod\n            else:\n                s = b[cnt - 1][0] + b[cnt - 1][1] * (k - 1) % mod\n                if s >= mod:\n                    s -= mod\n                if x == arr[cur]:\n                    s -= b[cnt - 1][0]\n                else:\n                    s -= b[cnt - 1][1]\n                if s < 0:\n                    s += mod\n                ans = ans * s % mod\n        cur = i\n    if cur == -1:\n        ans = (ans * ub[len(arr) - 1] * k) % mod\n    elif cur < len(arr) - 1:\n        cnt = len(arr) - cur - 1\n        s = b[cnt - 1][0] + b[cnt - 1][1] * (k - 1) % mod\n        if s >= mod:\n            s -= mod\n        ans = ans * s % mod\n\n\nprint(ans)\n", "input1 = input('').split(' ')\nk = int(input1.pop())\nn = int(input1.pop())\ninput2 = input('').split(' ')\nlis11 = []\nlis12 = []\nlis21 = []\nlis22 = []\nlisk = []\nlong = 0\nop = 1\nfor i in range(n):\n    if i % 2 == 0:\n        lis11.append(int(input2[i]))\n    else:\n        lis12.append(int(input2[i]))\ntong = [0,1,k-1]\nyi = [0,1,k-2]\nfor i in range((n+1)//2):\n    if lis11[i] != -1:\n        lis21.append(i)\n        if len(lis21)>1:\n            if (i-lis21[-2]) > long:\n                long = i-lis21[-2]\n    if (i>0) & (lis11[i]>0):\n        if lis11[i-1] == lis11[i]:\n            lisk.append(0)\nfor i in range(n//2):\n    if lis12[i] != -1:\n        lis22.append(i)\n        if len(lis22)>1: \n            if (i-lis22[-2]) > long:\n                long = i-lis22[-2]\n    if (i>0) & (lis12[i]>0):\n        if lis12[i-1] == lis12[i]:\n            lisk.append(0)\nfor i in range(3,long+1):\n    tong.append(int(yi[i-1])*(k-1)%998244353)\n    yi.append((int(yi[i-1])*(k-2)+tong[i-1])%998244353)\nif lis21:\n    for i in range(lis21[0] - lis21[-1] + (n+1)//2 - 1):\n        lisk.append(k-1)\n    for i in range(1,len(lis21)):\n        if lis11[lis21[i]] == lis11[lis21[i-1]]:\n            lisk.append(tong[lis21[i]-lis21[i-1]])\n        else:\n            lisk.append(yi[lis21[i]-lis21[i-1]])\nelse:\n    lisk.append(k)\n    for i in range(1,(n+1)//2):\n        lisk.append(k-1)\nif lis22:\n    for i in range(lis22[0] - lis22[-1] + n//2 - 1):\n        lisk.append(k-1)\n    for i in range(1,len(lis22)):\n        if lis12[lis22[i]] == lis12[lis22[i-1]]:\n            lisk.append(tong[lis22[i]-lis22[i-1]])\n        else:\n            lisk.append(yi[lis22[i]-lis22[i-1]])\nelse:\n    lisk.append(k)\n    for i in range(1,n//2):\n        lisk.append(k-1)\nif len(lisk) > 0:\n    for i in range(len(lisk)):\n            op = op * lisk[i] % 998244353\nprint(op)", "input1 = input('').split(' ')\nk = int(input1.pop())\nn = int(input1.pop())\ninput2 = input('').split(' ')\nlis11 = []\nlis12 = []\nlis21 = []\nlis22 = []\nlisk = []\nlong = 0\nop = 1\nfor i in range(n):\n    if i % 2 == 0:\n        lis11.append(int(input2[i]))\n    else:\n        lis12.append(int(input2[i]))\ntong = [0,1,k-1]\nyi = [0,1,k-2]\nfor i in range((n+1)//2):\n    if lis11[i] != -1:\n        lis21.append(i)\n        if len(lis21)>1:\n            if (i-lis21[-2]) > long:\n                long = i-lis21[-2]\n    if (i>0) & (lis11[i]>0):\n        if lis11[i-1] == lis11[i]:\n            lisk.append(0)\nfor i in range(n//2):\n    if lis12[i] != -1:\n        lis22.append(i)\n        if len(lis22)>1: \n            if (i-lis22[-2]) > long:\n                long = i-lis22[-2]\n    if (i>0) & (lis12[i]>0):\n        if lis12[i-1] == lis12[i]:\n            lisk.append(0)\nfor i in range(3,long+1):\n    tong.append((yi[i-1])*(k-1)%998244353)\n    yi.append(((yi[i-1])*(k-2)+tong[i-1])%998244353)\nif lis21:\n    for i in range(lis21[0] - lis21[-1] + (n+1)//2 - 1):\n        lisk.append(k-1)\n    for i in range(1,len(lis21)):\n        if lis11[lis21[i]] == lis11[lis21[i-1]]:\n            lisk.append(tong[lis21[i]-lis21[i-1]])\n        else:\n            lisk.append(yi[lis21[i]-lis21[i-1]])\nelse:\n    lisk.append(k)\n    for i in range(1,(n+1)//2):\n        lisk.append(k-1)\nif lis22:\n    for i in range(lis22[0] - lis22[-1] + n//2 - 1):\n        lisk.append(k-1)\n    for i in range(1,len(lis22)):\n        if lis12[lis22[i]] == lis12[lis22[i-1]]:\n            lisk.append(tong[lis22[i]-lis22[i-1]])\n        else:\n            lisk.append(yi[lis22[i]-lis22[i-1]])\nelse:\n    lisk.append(k)\n    for i in range(1,n//2):\n        lisk.append(k-1)\nif len(lisk) > 0:\n    for i in range(len(lisk)):\n            op = op * lisk[i] % 998244353\nprint(op)", "import sys\nsys.setrecursionlimit(10**7)\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nmod =  998244353\n\ndp1 = [1, 0]\ndp2 = [1, K-1]\nfor i in range(1+N//2):\n    d1, d2 = dp1[-1], dp2[-1]\n    dp1.append(d2)\n    dp2.append(((K-1)*d1 + (K-2)*d2)%mod)\n\nans = 1\ndif = (K-2)*pow(K-1, mod-2, mod)%mod\nAO = A[::2]\nAE = A[1::2]\nif all(a == -1 for a in AO):\n    ans = K * pow(K-1, len(AO) - 1, mod) %mod\nelse:\n    AO = [0] + AO + [0]\n    mc = 0 \n    l = -2\n    r = -2\n    for i, a in enumerate(AO[1:], 1):\n        if a == -1:\n            if AO[i-1] != -1:\n                l = AO[i-1]\n            mc += 1\n        else:\n            r = a\n            if AO[i-1] == a:\n                ans = 0\n                break\n            elif mc:\n                if not l or not r:\n                    ans = ans * pow(K-1, mc, mod) % mod\n                elif l == r:\n                    ans = ans * dp2[mc] % mod\n                else:\n                    ans = ans * (dp2[mc] * dif + dp1[mc]) % mod\n            mc = 0\nif all(a == -1 for a in AE):\n    ans = ans * K * pow(K-1, len(AE) - 1, mod) %mod\nelse:\n    AE = [0] + AE + [0]\n    mc = 0 \n    l = -2\n    r = -2\n    for i, a in enumerate(AE[1:], 1):\n        if a == -1:\n            if AE[i-1] != -1:\n                l = AE[i-1]\n            mc += 1\n        else:\n            r = AE[i]\n            if AE[i-1] == a:\n                ans = 0\n                break\n            if mc:\n                if not l or not r:\n                    ans = ans * pow(K-1, mc, mod) % mod\n                elif l == r:\n                    ans = ans * dp2[mc] % mod\n                else:\n                    ans = ans * (dp2[mc] * dif + dp1[mc]) % mod\n            mc = 0\nprint(ans)", "mod = 998244353\nmaxn = 200002\n\ndef pow(a, e):\n    if e <= 0: return 1\n    \n    ret = 1\n    while e:\n        if e & 1:\n           ret = (ret * a) % mod\n        a = (a * a) % mod\n        e >>= 1\n    return ret \n\n\n\nfn, fe = [1], [None]\n\ndef build(k):\n    fn.append(k-2)\n    fe.append(k-1)\n\n    for i in range(2, maxn):\n        fe.append( ((k-1) * fn[i-1]) % mod )\n        fn.append( ((k-1) * fn[i-2] + (k-2) * fn[i-1]) % mod )\n\n\n\n\n\ndef getRanges(arr):\n    q, st, en = [], -1, -1\n\n    for i, x in enumerate(arr):\n        if x == -1:\n            if st == -1:\n                st = en = i\n            else:\n                en = i\n        else:\n            if st >= 0:\n                q.append((st, en))\n                st, en = -1, -1\n    if arr[-1] == -1:\n        q.append((st, en))\n\n    return q\n\ndef getWays(arr, k):\n    ans = 1\n\n    for st, en in getRanges(arr):\n        if st == 0 and en == len(arr)-1:\n            ans *= k * pow(k-1, en-st)\n        elif st == 0 or en == len(arr)-1:\n            ans *= pow(k-1, en-st+1)\n        elif arr[st-1] == arr[en+1]:\n            ans *= fe[en-st+1]\n        else:\n            ans *= fn[en-st+1]\n        \n        ans %= mod\n    \n    return ans\n\n\ndef incorrect(arr, n):\n    for i in range(1, n-1):\n        if arr[i-1] == arr[i+1] and arr[i-1] != -1:\n            return True\n    return False\n\n\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    arr = [int(x) for x in input().split()]\n\n    if incorrect(arr, n):\n        print(0)\n        return\n\n    build(k)\n\n    even = [x for i, x in enumerate(arr) if i & 1 == 0 ]\n    odd = [x for i, x in enumerate(arr) if i & 1 == 1 ]\n\n    e, o = getWays(even, k), getWays(odd, k)\n\n    print((e * o) % mod)\n\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "mod = 998244353\nmaxn = 200002\n\ndef pow(a, e):\n    if e <= 0: return 1\n    \n    ret = 1\n    while e:\n        if e & 1:\n           ret = (ret * a) % mod\n        a = (a * a) % mod\n        e >>= 1\n    return ret \n\n\n\nfn, fe = [1], [None]\n\ndef build(k):\n    fn.append(k-2)\n    fe.append(k-1)\n\n    for i in range(2, maxn):\n        fe.append( ((k-1) * fn[i-1]) % mod )\n        fn.append( ((k-1) * fn[i-2] + (k-2) * fn[i-1]) % mod )\n\n\n\n\n\ndef getRanges(arr):\n    q, st, en = [], -1, -1\n\n    for i, x in enumerate(arr):\n        if x == -1:\n            if st == -1:\n                st = en = i\n            else:\n                en = i\n        else:\n            if st >= 0:\n                q.append((st, en))\n                st, en = -1, -1\n    if arr[-1] == -1:\n        q.append((st, en))\n\n    return q\n\ndef getWays(arr, k):\n    ans = 1\n\n    for st, en in getRanges(arr):\n        if st == 0 and en == len(arr)-1:\n            ans *= k * pow(k-1, en-st)\n        elif st == 0 or en == len(arr)-1:\n            ans *= pow(k-1, en-st+1)\n        elif arr[st-1] == arr[en+1]:\n            ans *= fe[en-st+1]\n        else:\n            ans *= fn[en-st+1]\n        \n        ans %= mod\n    \n    return ans\n\n\ndef incorrect(arr, n):\n    for i in range(1, n-1):\n        if arr[i-1] == arr[i+1] and arr[i-1] != -1:\n            return True\n    return False\n\n\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    arr = [int(x) for x in input().split()]\n\n    if incorrect(arr, n):\n        print(0)\n        return\n\n    build(k)\n\n    even = [x for i, x in enumerate(arr) if i & 1 == 0 ]\n    odd = [x for i, x in enumerate(arr) if i & 1 == 1 ]\n\n    e, o = getWays(even, k), getWays(odd, k)\n\n    print((e * o) % mod)\n\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "# AC\nimport sys\nfrom heapq import heappush, heappop\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = sys.stdin.readline().split()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_int(self):\n        return int(next(self))\n\n    def pp(self, a, b, mod):\n        if b == 0:\n            return 1\n        tmp = self.pp(a, b // 2, mod)\n        tmp = tmp * tmp % mod\n        if b % 2 == 1:\n            tmp = tmp * a % mod\n        return tmp\n\n    def same(self, cc, k, mod):\n        t = 1\n        y = 0\n        for i in range(0, cc):\n            tt = y\n            yy = (t * (k - 1) + y * (k - 2)) % mod\n            y = yy\n            t = tt\n        return y\n\n    def diff(self, cc, k, mod):\n        t = 0\n        y = 1\n        for i in range(0, cc):\n            tt = y\n            yy = (t * (k - 1) + y * (k - 2)) % mod\n            y = yy\n            t = tt\n        return y\n\n    def solve(self):\n        n = self.next_int()\n        k = self.next_int()\n        mod = 998244353\n        pre = [-1, -1]\n        cc = [0, 0]\n        ans = 1\n        for i in range(0, n):\n            d = self.next_int()\n            ii = i % 2\n            if d == -1:\n                cc[ii] += 1\n            else:\n                if pre[ii] == -1:\n                    ans = ans * self.pp(k - 1, cc[ii], mod) % mod\n                elif pre[ii] == d:\n                    ans = ans * self.same(cc[ii], k, mod) % mod\n                else:\n                    ans = ans * self.diff(cc[ii], k, mod) % mod\n                cc[ii] = 0\n                pre[ii] = d\n        if cc[0] == (n + 1) // 2:\n            ans = ans * k * self.pp(k - 1, cc[0] - 1, mod) % mod\n        else:\n            ans = ans * self.pp(k - 1, cc[0], mod) % mod\n        if cc[1] == n // 2:\n            ans = ans * k * self.pp(k - 1, cc[1] - 1, mod) % mod\n        else:\n            ans = ans * self.pp(k - 1, cc[1], mod) % mod\n        print(ans)\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()", "class PalArray():\n    P = 998244353\n    def __init__(self, n, k, a):\n        self.n, self.k, self.a = n, k, a\n        self.dp = None\n\n    def fast_pow(self, a, b):\n        r = 1\n        while b > 0:\n            if b%2 == 1:\n                r = (r*a)%self.P\n            a = (a*a)%self.P\n            b = int(b/2)\n        return r\n\n    def populate_dp(self):\n        self.dp = [[0 for i in range(2)] for j in range(self.n+1)]\n        self.dp[1][0] = self.k-2\n        self.dp[1][1] = self.k-1\n\n        for i in range(2, self.n+1):\n            self.dp[i][0] = (((self.k-2)*(self.dp[i-1][0]))%self.P + self.dp[i-1][1])%self.P\n            self.dp[i][1] = ((self.k-1)*self.dp[i-1][0])%self.P\n\n    def check_array(self, a):\n        for i in range(1, len(a)):\n            if a[i] != -1 and a[i] == a[i-1]:\n                return False\n        return True\n\n    def compute_count(self, a):\n        check = False\n        res = 1\n        mis_cnt = 0\n        lv = None\n        for v in a:\n            if v == -1:\n                mis_cnt += 1\n            else:\n                if mis_cnt > 0:\n                    if not check:\n                        check = True\n                        res = (res*self.fast_pow(self.k-1, mis_cnt))%self.P\n                    else:\n                        res = (res*self.dp[mis_cnt][int(lv==v)])%self.P\n                    mis_cnt = 0\n                lv = v\n                check = True\n        if mis_cnt > 0:\n            if lv is not None:\n                res = (res*self.fast_pow(self.k-1, mis_cnt))%self.P\n            else:\n                res = (((res*self.fast_pow(self.k-1, mis_cnt-1))%self.P)*self.k)%self.P\n        return res\n\n    def num_combinations(self):\n        self.populate_dp()\n        a1 = [self.a[i] for i in range(0,self.n,2)]\n        a2 = [self.a[i] for i in range(1,self.n,2)]\n        cnt1 = self.compute_count(a1)*int(self.check_array(a1))\n        cnt2 = self.compute_count(a2)*int(self.check_array(a2))\n        return (cnt1*cnt2)%self.P\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nprint(PalArray(n,k,a).num_combinations())\n\n\n\n", "import sys\nfrom sys import stdin, stdout  \n\nmod = 998244353\n\n#fileIO = open(\"a.inp\", \"r\")\n\nn,k = stdin.readline().split() #fileIO.readline().split()\nn,k = int(n),int(k)\n\ndef hpow(x,y) :\n    if(y == 0): return 1\n    if(y == 1): return x % mod\n    a = hpow(x,y >> 1)\n    a = (a * a) % mod\n    return (a * x) % mod if y & 1 else a\n\ndef rev(x) :\n    return hpow(x,mod - 2)\n\ndef max(x,y) :\n    return x if x >= y else y\n\nrevk = rev(k)\n\ndef cal(l,x,y) :\n    rr = 1\n    if(not x and not y) : \n        rr = k * hpow(k - 1,l - 1) % mod\n        return rr\n    if(not y) : x,y = y,x\n    if(not x) : \n        rr = k\n        for i in range(l - 1) : rr = rr * (k - 1) % mod\n        return rr * revk % mod * (k - 1) % mod \n    \n    if(x == y) :\n        f = [[k - 1,0]]\n        for i in range(1,l) :\n            f.append([(f[i - 1][1] * (k - 1) % mod + f[i - 1][0] * (k - 2) % mod) % mod,f[i - 1][0]])\n        return f[l - 1][0]\n    \n    # final case -> x ... y\n\n    f = [[k - 2,0,1]]\n    for i in range(1,l) : \n        f.append([((f[i - 1][1] + f[i - 1][2]) * (k - 2) % mod + f[i - 1][0] * max(0,k - 3) % mod) % mod,(f[i - 1][2] + f[i - 1][0]) % mod,(f[i - 1][1] + f[i - 1][0]) % mod])\n\n    return (f[l - 1][0] + f[l - 1][1]) % mod\n\na = [int(x) for x in stdin.readline().split()]\n\n#fileIO.close()\n\nm1,m2 = 0,0\n\nb = [0]\nc = [0]\n\nfor i in range(n) :\n    if(i & 1) : b.append(a[i])\n    else : c.append(a[i])\n\nm1 = len(b) - 1\nm2 = len(c) - 1\n\nres = 1\n\n# process array b & c separately\n\n#fileIO = open(\"a.out\",\"w\")\n\nfor i in range(1,m1 + 1) :\n    if(b[i] > 0 and b[i] == b[i - 1]) :\n        stdout.write(str(0)) #fileIO.write(str(0))\n        return\nfor i in range(1,m2 + 1) :\n    if(c[i] > 0 and c[i] == c[i - 1]) :\n        stdout.write(str(0))\n        return\n\nj = -1\nfor i in range(1,m1 + 1) : \n    if(b[i] == -1) : \n        if(j < 0): j = i\n        if(i >= m1 or b[i + 1] != -1) :\n            res = res * cal(i - j + 1,0 if j <= 1 else b[j - 1],0 if i >= m1 else b[i + 1]) % mod\n            j = -1\n\nj = -1\nfor i in range(1,m2 + 1) :\n    if(c[i] == -1):\n        if(j < 0): j = i\n        if(i >= m2 or c[i + 1] != -1) :\n            res = res * cal(i - j + 1,0 if j <= 1 else c[j - 1],0 if i >= m2 else c[i + 1]) % mod\n            j = -1\n\nstdout.write(str(res))\n#fileIO.close()\n", "import sys\ninput = sys.stdin.readline\n\n\ndef compress(string):\n    n = len(string)\n    begin, cnt = 0, 0\n    ans = []\n    if n == 0:\n        return ans\n    for end in range(n + 1):\n        if end == n or string[begin] != string[end]:\n            ans.append((string[begin], cnt))\n            begin, cnt = end, 1\n        else:\n            cnt += 1\n    return ans\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nMOD = 998244353\n\n\ndp = [[0] * 2 for i in range(n + 1)]\ndp[0][0] = 1\nfor i in range(n):\n    dp[i + 1][0] += dp[i][1]\n    dp[i + 1][0] %= MOD\n    dp[i + 1][1] += dp[i][0] * (k - 1)\n    dp[i + 1][1] += dp[i][1] * (k - 2)\n    dp[i + 1][1] %= MOD\n\n\ndq = [0 for i in range(n + 1)]\n\ndq[1] = k\nfor i in range(1, n):\n    dq[i + 1] += dq[i] * (k - 1)\n    dq[i + 1] %= MOD\n\n\nodd = []\neven = []\nfor i, val in enumerate(a):\n    if i % 2 == 0:\n        odd.append(val)\n    else:\n        even.append(val)\n\n\nans = 1\nodd = compress(odd)\nfor i, (val, cnt) in enumerate(odd):\n    if val != -1 and cnt > 1:\n        ans = 0\n        continue\n    if val != -1:\n        continue\n    else:\n        if i == 0:\n            tmp = dq[cnt]\n            if i + 1 == len(odd):\n                ans *= tmp\n                ans %= MOD\n            else:\n                ans *= tmp * pow(k, MOD - 2, MOD) * (k - 1)\n                ans %= MOD\n            continue\n\n        tmp1, tmp2 = dp[cnt]\n        if cnt == 1:\n            if i + 1 == len(odd):\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] == odd[i - 1][0]:\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] != odd[i - 1][0]:\n                ans *= tmp2 * pow(k - 1, MOD - 2, MOD) * (k - 2)\n                ans %= MOD\n        else:\n            if i + 1 == len(odd):\n                ans *= (tmp1 + tmp2)\n                ans %= MOD\n            elif odd[i + 1][0] == odd[i - 1][0]:\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] != odd[i - 1][0]:\n                ans *= tmp1 + tmp2 * pow(k - 1, MOD - 2, MOD) * (k - 2)\n                ans %= MOD\n\nodd = compress(even)\nfor i, (val, cnt) in enumerate(odd):\n    if val != -1 and cnt > 1:\n        ans = 0\n        continue\n    if val != -1:\n        continue\n    else:\n        if i == 0:\n            tmp = dq[cnt]\n            if i + 1 == len(odd):\n                ans *= tmp\n                ans %= MOD\n            else:\n                ans *= tmp * pow(k, MOD - 2, MOD) * (k - 1)\n                ans %= MOD\n            continue\n\n        tmp1, tmp2 = dp[cnt]\n        if cnt == 1:\n            if i + 1 == len(odd):\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] == odd[i - 1][0]:\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] != odd[i - 1][0]:\n                ans *= tmp2 * pow(k - 1, MOD - 2, MOD) * (k - 2)\n                ans %= MOD\n        else:\n            if i + 1 == len(odd):\n                ans *= (tmp1 + tmp2)\n                ans %= MOD\n            elif odd[i + 1][0] == odd[i - 1][0]:\n                ans *= tmp2\n                ans %= MOD\n            elif odd[i + 1][0] != odd[i - 1][0]:\n                ans *= tmp1 + tmp2 * pow(k - 1, MOD - 2, MOD) * (k - 2)\n                ans %= MOD\n\nprint(ans % MOD)"]
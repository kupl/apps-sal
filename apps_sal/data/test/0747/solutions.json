["import itertools\nimport operator\n\n\nn, x = list(map(int, str.split(input())))\na = []\nb = []\nfor _ in range(n):\n\n    t, h, m = list(map(int, str.split(input())))\n    (a if t else b).append((h, m))\n\nbest = 0\nfor ca, cb in ((a, b), (b, a)):\n\n    cx = x\n    count = 0\n    ca, cb = ca[:], cb[:]\n    while True:\n\n        available = tuple([candy for candy in enumerate(ca) if candy[1][0] <= cx])\n        if available:\n\n            i, candy = max(available, key=lambda candy: candy[1][1])\n            ca.pop(i)\n            count += 1\n            cx += candy[1]\n\n        else:\n\n            break\n\n        ca, cb = cb, ca\n\n    best = max(best, count)\n\nprint(best)\n", "n,x=list(map(int,input().split()))\na=[]\nb=[]\nfor i in range(n):\n    t,h,m=list(map(int,input().split()))\n    if t:\n        a.append((h,m))\n    else:\n        b.append((h,m))\ncounter1=0;\nnow=True\na1=a[:]\nb1=b[:]\nx2=x\nwhile 1:\n    if now:\n        if(len(a)==0):\n            break;\n        \n        i=0\n        maxx=0\n        mi=0\n        for kor in a:\n            if kor[0]<=x and maxx<kor[1]:\n                maxx=kor[1]\n                mi=i\n            i+=1\n        if maxx==0:\n            break\n        x+=maxx\n        a.pop(mi)\n        counter1+=1\n        now=False\n    else:\n        if(len(b)==0):\n            break;\n        i=0\n        maxx=0\n        mi=0\n        for kor in b:\n            if kor[0]<=x and maxx<kor[1]:\n                maxx=kor[1]\n                mi=i\n            i+=1\n        if(maxx==0):\n            break;\n        x+=maxx\n        b.pop(mi)\n        counter1+=1\n        now=True\n    \ncounter2=0;\nnow=False\nwhile 1:\n    if now:\n        if(len(a1)==0):\n            break;\n        i=0\n        maxx=0\n        mi=0\n        for kor in a1:\n            if kor[0]<=x2 and maxx<kor[1]:\n                maxx=kor[1]\n                mi=i\n            i+=1\n        if maxx==0:\n            break\n        x2+=maxx\n        a1.pop(mi)\n        counter2+=1\n        now=False\n    else:\n        if(len(b1)==0):\n            break;\n        i=0\n        maxx=0\n        mi=0\n        for kor in b1:\n            if kor[0]<=x2 and maxx<kor[1]:\n                maxx=kor[1]\n                mi=i\n            i+=1\n        if(maxx==0):\n            break;\n        x2+=maxx\n        b1.pop(mi)\n        counter2+=1\n        now=True\nprint(counter1 if counter1>counter2 else counter2) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n", "def solve ( p, n, x, t, h, m ):\n    used, xx, ans = [0] * n, x, 0\n    while ( True ):\n        k = -1\n        for i in range( n ): \n            if ( used[i] == 0 ) and ( t[i] == p ) and ( h[i] <= xx ) and ( ( k == -1 ) or ( m[i] > m[k] ) ): k = i\n        if ( k == -1 ): break\n        ans += 1\n        xx += m[k]\n        used[k] = 1\n        p = p ^ 1\n    return ans\n    \nn, x = map( int, input().split() )\nt, h, m = [0] * n, [0] * n, [0] * n\nfor i in range( n ):  t[i], h[i], m[i] = map( int, input().split() )\nprint ( max( solve( 0, n, x, t, h, m ), solve( 1, n, x, t, h, m ) ) )", "# -*- coding: utf-8 -*-\nimport sys\nf = sys.stdin\n#f = open('H:\\\\Portable Python 3.2.5.1\\\\test_248B1.txt') \nn, x = map(int, f.readline().strip().split())\n\nkon = []\nkon0 = []\nkon1 = []\nfor i in range(n):\n    ti, hi, mi = map(int, f.readline().strip().split())\n    kon.append([ti,hi,mi])\n    if ti==0 :\n        kon0.append([hi,mi])\n    else:\n        kon1.append([hi,mi])\n        \ndef ksort(item):\n    if item[0]<=x:\n        return -item[1]\n    else:\n        return item[0]-item[1]/10000\n        \n#kon0.sort(key=lambda item: item[0]-item[1]/10000)\n#kon1.sort(key=lambda item: item[0]-item[1]/10000)\n\n\nkon0.sort(key=ksort)\nkon1.sort(key=ksort)\n\n\nt0 = kon0[:]\nt1 = kon1[:]\ntx = x\n\ns = 0\ni0 = 0\nnot_end = True\nwhile not_end :\n    if i0 % 2 == 0 and len(kon0)>0 and x>=kon0[0][0]:\n        s += 1\n        x += kon0[0][1]\n        #print('var1 ',kon0)\n        del kon0[0]\n        kon0.sort(key=ksort)\n        kon1.sort(key=ksort)\n        #print(x, kon0)\n        i0 += 1\n    elif i0 % 2 == 1 and len(kon1)>0 and x>=kon1[0][0]:\n        s += 1\n        x += kon1[0][1]\n        #print('var1 ',kon1)\n        del kon1[0]\n        kon0.sort(key=ksort)\n        kon1.sort(key=ksort)\n        i0 += 1\n    else:\n        not_end = False\n\n\ns1 = s\n\nkon0 = t0\nkon1 = t1\nx = tx\n\ns = 0\ni0 = 1\nnot_end = True\nwhile not_end :\n    if i0 % 2 == 0 and len(kon0)>0 and x>=kon0[0][0]:\n        s += 1\n        x += kon0[0][1]\n        #print('var2 ',kon0)\n        del kon0[0]\n        kon0.sort(key=ksort)\n        i0 += 1\n    elif i0 % 2 == 1 and len(kon1)>0 and x>=kon1[0][0]:\n        s += 1\n        x += kon1[0][1]\n        #print('var2 ',kon1)\n        del kon1[0]\n        kon1.sort(key=ksort)\n        i0 += 1\n    else:\n        not_end = False\n        \n        \nprint(max(s,s1))", "from bisect import bisect_left\nn, x = map(int, input().split())\ns, a, b = 0, [[], []], [[], []]\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    a[t].append((h, m))\nfor t in [0, 1]:\n    a[t].sort(key = lambda x: x[0])\n    for h, m in a[t]:\n        if h > x: break\n        b[t].append(m)\n    b[t].sort()\nfor t in [0, 1]:\n    y, i, c = x, [len(b[0]), len(b[1])], [b[0][:], b[1][:]]\n    while c[t]:\n        y += c[t].pop()\n        t = 1 - t\n        while i[t] < len(a[t]):\n            h, m = a[t][i[t]]\n            if h > y: break\n            c[t].insert(bisect_left(c[t], m), m)\n            i[t] += 1\n    s = max(s, i[0] + i[1] - len(c[0]) - len(c[1]))\nprint(s)", "n, x = [int(c) for c in input().split()]\n\ncandies = []\n\nfor i in range(n):\n    candies.append([int(c) for c in input().split()])\n\n\n\ncandies.sort(key=lambda x: x[2],reverse=True)\n\ndef find_best(candies, x, step):\n    for i in range(len(candies)):\n        if candies[i][0] == step and candies[i][1] <= x:\n            return i\n\n    return -1\n\neated = [0, 0]\n\nfor startWith in range(2):\n    step = startWith\n    c1 = candies[:]\n    tmp = find_best(c1, x, step)\n    x1 = x\n    while tmp != -1:\n        eated[startWith] += 1\n        x1 = x1 + c1[tmp][2]\n        step = (step + 1) % 2\n        c1.pop(tmp)\n        tmp = find_best(c1, x1, step)\n\nprint(max(eated))", "def solve(currentT):\n    result = 0\n    way = list(candy)\n    bestCandy = -1\n    flag = False\n    for i in range(n):\n        if way[i][0] == currentT:\n            if way[i][1] <= x and (way[i][2] >= way[bestCandy][2] or bestCandy == -1):\n                bestCandy = i\n                flag = True\n    if not flag:\n        return 0\n    power = x + way[bestCandy][2]\n    result += 1\n    flag = True\n    while flag:\n        temp = way.pop(bestCandy)\n        bestCandy = -1\n        currentT = 1 - currentT\n        flag = False\n        for i in range(len(way)):\n            if way[i][0] == currentT:\n                if way[i][1] <= power and (way[i][2] >= way[bestCandy][2] or bestCandy == -1):\n                    bestCandy = i\n                    flag = True\n        if flag:\n            power += way[bestCandy][2]\n            result += 1\n    return result\n\ncandy = []\nn, x = tuple(map(int, input().split()))\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    if temp[0] > 0:\n        temp[0] = 1\n    candy.append(temp)\ncandy = tuple(candy)\n\nprint(max(solve(0), solve(1)))\n", "n, x = list(map(int, input().split()))\ncan = [[], []]\nfor i in range(n):\n    a, b, c = list(map(int, input().split()))\n    can[a].append((b, c))\nans = 0\nfor nturn in range(2):\n    u = [[], []]\n    for i in range(2):\n        for j in range(len(can[i])):\n            u[i].append(False)\n    nx = x\n    nw = 0\n    turn = nturn\n    for i in range(n):\n        mx = -1\n        bj = -1\n        for j in range(len(can[turn])):\n            if not u[turn][j] and can[turn][j][0] <= nx and can[turn][j][1] > mx:\n                bj = j\n                mx = can[turn][j][1]\n        if bj != -1:\n            nx += mx\n            u[turn][bj] = True\n            nw += 1\n        else:\n            break\n        turn = (turn + 1) % 2\n    ans = max(ans, nw)\nprint(ans)\n    \n        \n        \n            \n        \n        \n    \n    \n\npass\n", "a = input().split(\" \")\nh = int(a[1])\nn = int(a[0])\n\ncandies = []\nfor i in range(n):\n   s = input().split(\" \")\n   candies.append([int(s[0]), int(s[1]), int(s[2])])\n\nzap = []\nfor i in range(n):\n   zap.append(candies[i])\n\ndef eat(bl, cand, h):\n    ch = h\n    color = bl\n    for i in range(n):\n        maxJ = -1\n        maxM = -1\n        for j in range(len(cand)):\n            if cand[j][0] == color:\n                if cand[j][2]>=maxM and ch>=cand[j][1]:\n                    maxJ = j\n                    maxM = cand[j][2]\n        if maxM == -1:\n            return i\n        else:\n            color = 1-color\n            ch+=maxM\n            cand.remove(cand[maxJ])\n    return n\n\na = eat(1, candies, h)\nb = eat(0, zap, h)\nif(a > b):\n    print(a)\nelse:\n    print(b)", "import copy\nn , xx = map(int, input().split())\nfirstorig = list()\nsecondorig = list()\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    if t == 0: firstorig.append((h, m))\n    else: secondorig.append((h,m))\n\n#print(len(firstorig), len(secondorig))\nfirstres = 0\nfirst = copy.deepcopy(firstorig)\nsecond = copy.deepcopy(secondorig)\ncurmaxjump = xx\n\nwhile True:\n    #print(len(first), len(second), firstres)\n    if len(first)>0:\n        i = 0\n        weight = 0\n        for x in range(len(first)):\n            if first[x][0] <= curmaxjump and first[x][1] > weight:\n                weight = first[x][1]\n                i = x\n        if weight > 0:\n            firstres+=1\n            curmaxjump+=weight\n            first.pop(i)\n        else: break\n    else: break\n    if len(second)>0:\n        i = 0\n        weight = 0\n        for x in range(len(second)):\n            if second[x][0] <= curmaxjump and second[x][1] > weight:\n                weight = second[x][1]\n                i = x\n        if weight > 0:\n            firstres+=1\n            curmaxjump+=weight\n            second.pop(i)\n        else: break\n    else: break\n\nsecondres = 0\ncurmaxjump = xx\nfirst = copy.deepcopy(firstorig)\nsecond = copy.deepcopy(secondorig)\n\nwhile True:\n    #print(len(first), len(second), curmaxjump)\n    if len(second)>0:\n        i = 0\n        weight = 0\n        for x in range(len(second)):\n            if second[x][0] <= curmaxjump and second[x][1] > weight:\n                weight = second[x][1]\n                i = x\n        if weight > 0:\n            secondres+=1\n            curmaxjump+=weight\n            second.pop(i)\n        else: break\n    else: break\n    #print(len(first), len(second), firstres)\n    if len(first)>0:\n        i = 0\n        weight = 0\n        for x in range(len(first)):\n            if first[x][0] <= curmaxjump and first[x][1] > weight:\n                weight = first[x][1]\n                i = x\n        if weight > 0:\n            secondres+=1\n            curmaxjump+=weight\n            first.pop(i)\n        else: break\n    else: break\n\n\n#print(firstres)\n#print(firstres, secondres)\nprint(max(firstres, secondres))", "import copy\nn , xx = map(int, input().split())\nfirstorig = list()\nsecondorig = list()\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    if t == 0: firstorig.append((h, m))\n    else: secondorig.append((h,m))\n\n#print(len(firstorig), len(secondorig))\nfirstres = 0\nfirst = copy.deepcopy(firstorig)\nsecond = copy.deepcopy(secondorig)\ncurmaxjump = xx\n\nwhile True:\n    #print(len(first), len(second), firstres)\n    if len(first)>0:\n        i = 0\n        weight = 0\n        for x in range(len(first)):\n            if first[x][0] <= curmaxjump and first[x][1] > weight:\n                weight = first[x][1]\n                i = x\n        if weight > 0:\n            firstres+=1\n            curmaxjump+=weight\n            first.pop(i)\n        else: break\n    else: break\n    if len(second)>0:\n        i = 0\n        weight = 0\n        for x in range(len(second)):\n            if second[x][0] <= curmaxjump and second[x][1] > weight:\n                weight = second[x][1]\n                i = x\n        if weight > 0:\n            firstres+=1\n            curmaxjump+=weight\n            second.pop(i)\n        else: break\n    else: break\n\nsecondres = 0\ncurmaxjump = xx\nfirst = copy.deepcopy(firstorig)\nsecond = copy.deepcopy(secondorig)\n\nwhile True:\n    #print(len(first), len(second), curmaxjump)\n    if len(second)>0:\n        i = 0\n        weight = 0\n        for x in range(len(second)):\n            if second[x][0] <= curmaxjump and second[x][1] > weight:\n                weight = second[x][1]\n                i = x\n        if weight > 0:\n            secondres+=1\n            curmaxjump+=weight\n            second.pop(i)\n        else: break\n    else: break\n    #print(len(first), len(second), firstres)\n    if len(first)>0:\n        i = 0\n        weight = 0\n        for x in range(len(first)):\n            if first[x][0] <= curmaxjump and first[x][1] > weight:\n                weight = first[x][1]\n                i = x\n        if weight > 0:\n            secondres+=1\n            curmaxjump+=weight\n            first.pop(i)\n        else: break\n    else: break\n\n\n#print(firstres)\n#print(firstres, secondres)\nprint(max(firstres, secondres))", "from copy import deepcopy\n\ndef getBetter(h, a):\n    maxi = -1\n    im = -1\n    for i in range(len(a)):\n        if (h >= a[i][0]):\n            if (maxi < a[i][1]):\n                im = i\n                maxi = a[i][1]\n    return(im, maxi)\n\nn, h0 = map(int, input().split())\n\nlolipops0 = [[], []]\n\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    lolipops0[t].append((h, m))\n\nlolipops0[1].sort()\nlolipops0[0].sort()\n\nlolipops1 = deepcopy(lolipops0)\n\nlol0 = getBetter(h0, lolipops0[0])\nt1 = 0\nh1 = h0\nlol1 = getBetter(h0, lolipops0[1])\nt2 = 1 # ---- WARNING --------\nh2 = h0\nwhile(lol0[0] >= 0 or lol1[0] >=0):\n    if (lol0[0] > -1):\n        if (len(lolipops0[t1 % 2]) != 1 and lol0[0] != -1):\n            lolipops0[t1 % 2].pop(lol0[0])\n        else:\n            lolipops0[t1 % 2] = []\n        t1 += 1\n        h1 += lol0[1]\n        lol0 = getBetter(h1, lolipops0[t1 % 2])\n    if (lol1[0] > -1):\n        if (len(lolipops1[t2 % 2]) != 1 and lol1[0] != -1):\n            lolipops1[t2 % 2].pop(lol1[0])\n        else:\n            lolipops1[t2 % 2] = []\n        t2 += 1\n        h2 += lol1[1]\n        lol1 = getBetter(h2, lolipops1[t2 % 2])\nprint(max(t1, t2 - 1))", "n,x = map(int,input().split())\nk = [[],[]]\ndef add(s):\n    t,h,m = map(int,s.split())\n    k[t].append([h,m])\n[add(input()) for _ in range(n)]\ndef calc(t):\n    cur = x\n    ans = 0\n    mark = [[False] * len(k[0]),[False] * len (k[1])]\n    while True:\n        w = 0\n        id = 0\n        for i in range(len(k[t])):\n            if mark[t][i] == False and w < k[t][i][1] and cur >= k[t][i][0]:\n                w = k[t][i][1]\n                id = i\n        if w == 0: break\n        ans += 1\n        cur += w\n        mark[t][id] = True\n        t = 1 - t\n    return ans\nsol = max(calc(0),calc(1))\nprint (sol)", "\nn, x = (int(x) for x in input().split())\n\ncs = []\nfor i in range(n):\n    cs.append([int(x) for x in input().split()])\n    if cs[-1][0] > 0:\n        cs[-1][0] = 1\n\ndef try_eat(t0):\n    h0 = x\n    used = set()\n    while True:\n        m0 = 0\n        i0 = -1\n        for i, (t, h, m) in enumerate(cs):\n            if t != t0 and h <= h0 and m > m0 and i not in used:\n                m0 = m\n                i0 = i\n        if i0 == -1:\n            break\n\n        used.add(i0)\n        h0 += cs[i0][2]\n        t0 = 1 - t0\n\n    return len(used)\n\nprint(max(try_eat(0), try_eat(1)))", "import sys\nfrom operator import itemgetter\ndef main():\n\tstr = sys.stdin.readline()\n\ttokens = str.split()\n\tn = int(tokens[0])\n\tx = int(tokens[1])\n\ts1=[]\n\ts2=[]\n\tfor i in range(n):\n\t\tstr = sys.stdin.readline()\n\t\ttokens = str.split()\n\t\tt = int(tokens[0])\n\t\th = int(tokens[1])\n\t\tm = int(tokens[2])\n\t\tif t==0:\n\t\t\ts1.append((h,m))\n\t\telse:\n\t\t\ts2.append((h,m))\n\t\t\n\ts1 = sorted(s1, key=itemgetter(0))  # secondary key, height, ascending\n\ts1 = sorted(s1, key=itemgetter(1), reverse=True)  # primary key, mass, descending\n\ts2 = sorted(s2, key=itemgetter(0))\n\ts2 = sorted(s2, key=itemgetter(1), reverse=True)\n\t\t\n\ts1A = s1[:]\n\ts2A = s2[:]\n\tjumpA = x\n\tcandiesA = 0\n\tcurrentA = s1A\n\twhile True:\n\t\tfound = 0\n\t\tfor i in range(len(currentA)):\n\t\t\tif currentA[i][0] <= jumpA:\n\t\t\t\tfound = 1\n\t\t\t\tcandiesA = candiesA + 1\n\t\t\t\tjumpA = jumpA + currentA[i][1]\n\t\t\t\tdel currentA[i]\n\t\t\t\tbreak\n\t\t\t\n\t\tif found == 1:\n\t\t\tif currentA == s1A:\n\t\t\t\tcurrentA = s2A\n\t\t\telse:\n\t\t\t\tcurrentA = s1A\n\t\telse:\n\t\t\tbreak\n\t\t\n\ts1B = s1[:]\n\ts2B = s2[:]\n\tjumpB = x\n\tcandiesB = 0\n\tcurrentB = s2B\n\twhile True:\n\t\tfound = 0\n\t\tfor i in range(len(currentB)):\n\t\t\tif currentB[i][0] <= jumpB:\n\t\t\t\tfound = 1\n\t\t\t\tcandiesB = candiesB + 1\n\t\t\t\tjumpB = jumpB + currentB[i][1]\n\t\t\t\tdel currentB[i]\n\t\t\t\tbreak\n\t\t\t\n\t\tif found == 1:\n\t\t\tif currentB == s1B:\n\t\t\t\tcurrentB = s2B\n\t\t\telse:\n\t\t\t\tcurrentB = s1B\n\t\telse:\n\t\t\tbreak\n\t\n\tprint(max(candiesA,candiesB))\ndef __starting_point():\n    main()\n\n__starting_point()", "import queue\nn,maxh=[int(x) for x in input().split()]\ncar=[]\nfru=[]\nhcar=queue.PriorityQueue(2000)\nhfru=queue.PriorityQueue(2000)\nfor i in range(n):\n\ta,b,c=[int(x) for x in input().split()]\n\tif a==0:\n\t\tcar.append((b,c))\n\telse:\n\t\tfru.append((b,c))\npcar=0\nmcar=len(car)\npfru=0\nmfru=len(fru)\ncar.sort()\nfru.sort()\neaten=0\ndef getinh():\n\tnonlocal pcar\n\tnonlocal pfru\n\twhile pcar<mcar and car[pcar][0]<=maxh:\n\t\thcar.put(-car[pcar][1])\n\t\tpcar+=1\n\twhile pfru<mfru and fru[pfru][0]<=maxh:\n\t\thfru.put(-fru[pfru][1])\n\t\tpfru+=1\ngetinh()\nwhile (not hcar.empty()) and (not hfru.empty()):\n\teaten+=2\n\tmaxh-=hcar.get()+hfru.get()\n\tgetinh()\nif hcar.empty():\n\tnow=0\nelse:\n\tnow=1\n\nwhile True:\n\tif now==0:\n\t\tif hfru.empty():\n\t\t\tbreak\n\t\telse:\n\t\t\tnow=1\n\t\t\tmaxh-=hfru.get()\n\telse:\n\t\tif hcar.empty():\n\t\t\tbreak\n\t\telse:\n\t\t\tnow=0\n\t\t\tmaxh-=hcar.get()\n\teaten+=1\n\tgetinh()\nprint(eaten)\n", "from functools import cmp_to_key\n\n\ndef get_max_from(data, x):\n    for i, c in enumerate(data):\n            if c[0] <= x:\n                data.pop(i)\n                return c[1]\n\n    return None\n\n\ndef test(data0, data1, x):\n    total = 0\n\n    while True:\n        max_m = get_max_from(data0, x)\n        if max_m is not None:\n            x += max_m\n            total += 1\n        else:\n            return total\n\n        max_m = get_max_from(data1, x)\n        if max_m is not None:\n            x += max_m\n            total += 1\n        else:\n            return total\n\n\ndef __starting_point():\n    n, x = map(int, input().split())\n\n    data0 = []\n    data1 = []\n\n    for i in range(n):\n        d = tuple(map(int, input().split()))\n        t = d[1], d[2]\n\n        if d[0] == 0:\n            data0.append(t)\n        else:\n            data1.append(t)\n\n    cmp = lambda a, b: b[1] - a[1]\n\n    data0.sort(key=cmp_to_key(cmp))\n    data1.sort(key=cmp_to_key(cmp))\n\n    d0 = data0.copy()\n    d1 = data1.copy()\n\n    print(max(test(d0, d1, x), test(data1, data0, x)))\n__starting_point()", "n, x1 = map(int, input().split())\nclass Candy:\n  t = 0\n  h = 0\n  m = 0\ncandy0 = []\ncandy1 = []\nfor i in range(n):\n  candy = Candy()\n  candy.t, candy.h, candy.m = map(int, input().split())\n  if candy.t == 0:\n    candy0.append(candy)\n  else:\n    candy1.append(candy)\n\ndef sortfn(item):\n  return item.m\n\ndef getnext(items, x):\n  for item in items:\n    if item.h <= x:\n      return item\n  val = Candy()\n  val.h = x + 1\n  return val\n\ncandy0.sort(key = sortfn, reverse = True)\ncandy1.sort(key = sortfn, reverse = True)\n\ncount0 = 0\ncount1 = 0\n\ndef getcount(candy0, candy1):\n  count = 0\n  next = candy0\n  x = x1\n  while getnext(next, x).h <= x:\n    nextitem = getnext(next, x)\n    x += nextitem.m\n    count += 1\n    next.remove(nextitem)\n    if next == candy0:\n      next = candy1\n    else:\n      next = candy0\n  return count\n\ncount0 = getcount(candy0.copy(), candy1.copy())\ncount1 = getcount(candy1.copy(), candy0.copy())\n\nprint(max(count0, count1))", "\nimport re\nimport inspect\nfrom sys import argv, exit\nfrom copy import copy\n\ndef rstr():\n    return input()\n\ndef rint():\n    return int(input())\n\ndef rints(splitchar=' '):\n    return [int(i) for i in input().split(splitchar)]\n\ndef varnames(obj, namespace=globals()):\n    return [name for name in namespace if namespace[name] is obj]\n\ndef pvar(var, override=False):\n    prnt(varnames(var), var)\n\ndef prnt(*args, override=False):\n    if '-v' in argv or override:\n        print(*args)\n\nclass Candy():\n    def __init__(self, stuff):\n        self.type = bool(stuff[0])\n        self.height = stuff[1]\n        self.mass = stuff[2]\n\n    def __str__(self):\n        return '{} h{} m{}'.format(self.type, self.height, self.mass)\n\n    def __repr__(self):\n        return str(self)\n\ndef main(h, candies, last_type):\n    eaten = []\n    neaten = 0\n\n    edible = sorted([c for c in candies if c.height <= h and c.type != last_type], key=lambda c: c.mass)\n    prnt('h',h)\n    prnt('last_type',last_type)\n    prnt('edible',edible)\n\n    while True:\n        if edible:\n            candy = edible.pop(-1)\n            candies.remove(candy)\n            prnt('eaten',candy)\n            eaten.append(candy)\n            neaten += 1\n            last_type = not last_type\n            h += candy.mass\n        else:\n            break\n        edible = sorted([c for c in candies if c.height <= h and c.type != last_type], key=lambda c: c.mass)\n        prnt(edible)\n    return neaten\n\ndef __starting_point():\n    (n, h) = rints()\n    # type, height, mass\n    candies = [Candy(rints()) for i in range(n)]\n    prnt(candies)\n\n    one = main(h, copy(candies), False)\n    two = main(h, copy(candies), True)\n\n    pvar(one)\n    pvar(two)\n\n    print(max(one, two))\n\n__starting_point()", "\n\nn, x = (int(x) for x in input().split())\n\n\n\ncs = []\n\nfor i in range(n):\n\n    cs.append([int(x) for x in input().split()])\n\n    if cs[-1][0] > 0:\n\n        cs[-1][0] = 1\n\n\n\ndef try_eat(t0):\n\n    h0 = x\n\n    used = set()\n\n    while True:\n\n        m0 = 0\n\n        i0 = -1\n\n        for i, (t, h, m) in enumerate(cs):\n\n            if t != t0 and h <= h0 and m > m0 and i not in used:\n\n                m0 = m\n\n                i0 = i\n\n        if i0 == -1:\n\n            break\n\n\n\n        used.add(i0)\n\n        h0 += cs[i0][2]\n\n        t0 = 1 - t0\n\n\n\n    return len(used)\n\n\n\nprint(max(try_eat(0), try_eat(1)))\n\n\n\n# Made By Mostafa_Khaled\n", "from operator import itemgetter\n\n\ndef has_to_eat(food_type, height, food):\n    result = 0\n    for candie in food:\n        if candie[0] == food_type or food_type == -1:\n            if height >= candie[1]:\n                candie[1] = 1000000000000000000\n                return candie[0], candie[2]\n    return result\n\n\nclass CodeforcesTask436ASolution:\n    def __init__(self):\n        self.result = ''\n        self.n_x = []\n        self.candies = []\n\n    def read_input(self):\n        self.n_x = [int(x) for x in input().split(\" \")]\n        for x in range(self.n_x[0]):\n            self.candies.append([int(x) for x in input().split(\" \")])\n\n    def process_task(self):\n        self.candies = sorted(self.candies, key=itemgetter(2), reverse=True)\n        #print(self.candies)\n        jump = self.n_x[1]\n        eat = 1\n        candies = [x.copy() for x in self.candies]\n        next = has_to_eat(eat, jump, candies)\n        eaten = 0\n        while next:\n            eaten += 1\n            jump += next[1]\n            if next[0]:\n                eat = 0\n            else:\n                eat = 1\n            next = has_to_eat(eat, jump, candies)\n        jump = self.n_x[1]\n        eat = 0\n        candies = [x.copy() for x in self.candies]\n        next = has_to_eat(eat, jump, candies)\n        eaten1 = 0\n        while next:\n            eaten1 += 1\n            jump += next[1]\n            if next[0]:\n                eat = 0\n            else:\n                eat = 1\n            next = has_to_eat(eat, jump, candies)\n        self.result = str(max(eaten, eaten1))\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask436ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()", "nw = input().split()\nnumCandies = int(nw[0])\nweight = int(nw[1])\n\nthm1 = []\nthm2 = []\n\nfor i in range(numCandies):\n    val = input().split()\n    val = [int(x) for x in val]\n    if val[0] == 0:\n        thm1.append(val)\n    else:\n        thm2.append(val)\n\n\ndef get_candy(woc, tlist):\n    ind = -1\n    maxm = -1\n    for k in range(len(tlist)):\n        if tlist[k][1] <= woc:\n            if maxm < tlist[k][2]:\n                maxm = tlist[k][2]\n                ind = k\n    if ind >= 0:\n        val1 = tlist.pop(ind)\n        return val1\n    return None\n\n\ncount = [0, 0]\nfor i in range(2):\n    candyType = i\n    initialWeight = weight\n    thm1c = thm1[:]\n    thm2c = thm2[:]\n    while True:\n        if candyType == 0:\n            candy = get_candy(initialWeight, thm1c)\n            if candy is not None:\n                chm = candy\n                h = chm[1]\n                m = chm[2]\n                initialWeight += m\n                count[i] += 1\n                candyType = 1\n            else:\n                break\n        else:\n            candy = get_candy(initialWeight, thm2c)\n            if candy is not None:\n                chm = candy\n                h = chm[1]\n                m = chm[2]\n                initialWeight += m\n                count[i] += 1\n                candyType = 0\n            else:\n                break\nprint(max(count))\n", "n,x = map(int,input().split())\nk = [[],[]]\ndef add(s):\n    t,h,m = map(int,s.split())\n    k[t].append([h,m])\n[add(input()) for _ in range(n)]\ndef calc(t):\n    cur = x\n    ans = 0\n    mark = [[False] * len(k[0]),[False] * len (k[1])]\n    while True:\n        w = 0\n        id = 0\n        for i in range(len(k[t])):\n            if mark[t][i] == False and w < k[t][i][1] and cur >= k[t][i][0]:\n                w = k[t][i][1]\n                id = i\n        if w == 0: break\n        ans += 1\n        cur += w\n        mark[t][id] = True\n        t = 1 - t\n    return ans\nsol = max(calc(0),calc(1))\nprint (sol)", "from operator import itemgetter\n    \n    \ndef has_to_eat(food_type, height, food):\n    result = 0\n    for candie in food:\n        if candie[0] == food_type or food_type == -1:\n            if height >= candie[1]:\n                candie[1] = 1000000000000000000\n                return candie[0], candie[2]\n    return result\n    \n    \nclass CodeforcesTask436ASolution:\n    def __init__(self):\n        self.result = ''\n        self.n_x = []\n        self.candies = []\n    \n    def read_input(self):\n        self.n_x = [int(x) for x in input().split(\" \")]\n        for x in range(self.n_x[0]):\n            self.candies.append([int(x) for x in input().split(\" \")])\n    \n    def process_task(self):\n        self.candies = sorted(self.candies, key=itemgetter(2), reverse=True)\n        #print(self.candies)\n        jump = self.n_x[1]\n        eat = 1\n        candies = [x.copy() for x in self.candies]\n        next = has_to_eat(eat, jump, candies)\n        eaten = 0\n        while next:\n            eaten += 1\n            jump += next[1]\n            if next[0]:\n                eat = 0\n            else:\n                eat = 1\n            next = has_to_eat(eat, jump, candies)\n        jump = self.n_x[1]\n        eat = 0\n        candies = [x.copy() for x in self.candies]\n        next = has_to_eat(eat, jump, candies)\n        eaten1 = 0\n        while next:\n            eaten1 += 1\n            jump += next[1]\n            if next[0]:\n                eat = 0\n            else:\n                eat = 1\n            next = has_to_eat(eat, jump, candies)\n        self.result = str(max(eaten, eaten1))\n    \n    def get_result(self):\n        return self.result\n    \n    \ndef __starting_point():\n    Solution = CodeforcesTask436ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n__starting_point()", "n, x = map(int, input().split())\ncount = 0\nans = 0\ncurr = 0\nfruit = []\ncaramel = []\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    if t == 0:\n        caramel.append((h, m))\n    else:\n        fruit.append((h, m))\n\ncaramel = sorted(caramel)\nfruit = sorted(fruit)\nfruit2 = fruit[::]\ncaramel2 = caramel[::]\nx2 = x\n\ndef add_to_mass(arr, x):\n    candy = 0\n    curr = 0\n    for i in range(len(arr)):\n        if arr[i][0] <= x:\n            if arr[i][1] >= candy:\n                candy = arr[i][1]\n                curr = i\n    if candy == 0:\n        return 0\n    arr.pop(curr)\n    return candy\n\nwhile True:\n    curr = add_to_mass(fruit, x)\n    if curr == 0:\n        break\n    else:\n        x += curr\n    count += 1\n    curr = add_to_mass(caramel, x)\n    if curr == 0:\n        break\n    else:\n        x += curr\n    count += 1\nans = count\ncount = 0\nwhile True:\n    curr = add_to_mass(caramel2, x2)\n    if curr == 0:\n        break\n    else:\n        x2 += curr\n    count += 1\n    curr = add_to_mass(fruit2, x2)\n    if curr == 0:\n        break\n    else:\n        x2 += curr\n    count += 1\nans = max(count, ans)\nprint(ans)"]
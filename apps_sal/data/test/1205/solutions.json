["from fractions import Fraction\nimport time\nfrom collections import Counter\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_tuple(self):\n        return (self.x, self.y)\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n\n    def __hash__(self):\n        return hash(self.to_tuple())\n\n    def __neg__(self):\n        return Point(-self.x, -self.y)\n\n    def __add__(self, other):\n        return Point(self.x+other.x, self.y+other.y)\n\n    def __sub__(self, other):\n        return self+(-other)\n\n    def scalar_mul(self, mu):\n        return Point(mu*self.x, mu*self.y)\n\n    def int_divide(self, den):\n        return Point(self.x//den, self.y//den)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        return self.x < other.x\n\n    def dot(self, other):\n        return self.x*other.x+self.y*other.y\n\n\nclass Line:\n    def __init__(self, a, b, c):\n        # ax+by+c=0\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return \"{}*x + {}*y + {} = 0\".format(self.a, self.b, self.c)\n\n    @classmethod\n    def between_two_points(cls, P, Q):\n        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\n\n    def evaluate(self, P):\n        return self.a*P.x+self.b*P.y+self.c\n\n    def direction(self):\n        if self.a == 0:\n            return (0, 1)\n        return (1, Fraction(self.b, self.a))\n\n\ntrue_start = time.time()\nn = int(input())\npoints = set()\ncenter = Point(0, 0)\nfor i in range(n):\n    row = input().split(\" \")\n    cur = Point(int(row[0]), int(row[1])).scalar_mul(2*n)\n    center += cur\n    points.add(cur)\n\ncenter = center.int_divide(n)\ndcenter = center+center\n\n# nosym = []\n# for p in points:\n#     psym = dcenter-p\n#     if psym not in points:\n#         nosym.append(p)\n\nsym_points_set = set()\nfor p in points:\n    sym_points_set.add(dcenter-p)\nnosym = list(points - sym_points_set)\n\n#print(nosym)\n# print(\"preproc:\", time.time()-true_start)\n\nif len(nosym) == 0:\n    print(-1)\n    return\n\n\ncnt = 0\np0 = nosym[0]\ngood_lines = set()\nfor p in nosym:\n    start = time.time()\n    m = (p+p0).int_divide(2)\n    supp = Line.between_two_points(m, center)\n    time_setup = time.time()-start\n    distances = list(map(supp.evaluate, nosym))\n    time_projs = time.time()-start\n\n    # sorting strat\n    ok = True\n    SORTING = False\n    if SORTING:\n        distances = sorted(distances)\n        time_sorting = time.time()-start\n        m = len(distances)\n        for i in range(m//2):\n            if distances[i] != -distances[m-1-i]:\n                ok = False\n                break\n    else:\n        mydict = {}\n        for dd in distances:\n            dda = abs(dd)\n            if dda not in mydict:\n                mydict[dda] = 1\n            else:\n                mydict[dda] += 1\n        time_sorting = time.time()-start\n        for k in mydict:\n            if mydict[k] % 2 == 1 and k != 0:\n                ok = False\n                break\n    if ok:\n        #print(\"ok\", supp)\n        #print(distances)\n        #print(mydict)\n        good_lines.add(supp.direction())\n\n    #print(\"setup: {}\\tprojs: {}\\tsort: {}\\tdone: {}\".format(time_setup, time_projs, time_sorting, time.time()-start))\n\n#print(\"total:\", time.time()-true_start)\nprint(len(good_lines))\n", "from fractions import Fraction\nimport time\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_tuple(self):\n        return (self.x, self.y)\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n\n    def __hash__(self):\n        return hash(self.to_tuple())\n\n    def __neg__(self):\n        return Point(-self.x, -self.y)\n\n    def __add__(self, other):\n        return Point(self.x+other.x, self.y+other.y)\n\n    def __sub__(self, other):\n        return self+(-other)\n\n    def scalar_mul(self, mu):\n        return Point(mu*self.x, mu*self.y)\n\n    def int_divide(self, den):\n        return Point(self.x//den, self.y//den)\n\n\nclass Line:\n    def __init__(self, a, b, c):\n        # ax+by+c=0\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return \"{}*x + {}*y + {} = 0\".format(self.a, self.b, self.c)\n\n    @classmethod\n    def between_two_points(cls, P, Q):\n        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\n\n    def evaluate(self, P):\n        return self.a*P.x+self.b*P.y+self.c\n\n    def direction(self):\n        if self.a == 0:\n            return (0, 1)\n        return (1, Fraction(self.b, self.a))\n\n\ntrue_start = time.time()\nn = int(input())\npoints = set()\ncenter = Point(0, 0)\nfor i in range(n):\n    row = input().split(\" \")\n    cur = Point(int(row[0]), int(row[1])).scalar_mul(2*n)\n    center += cur\n    points.add(cur)\n\ncenter = center.int_divide(n)\ndcenter = center+center\n\nsym_points_set = set()\nfor p in points:\n    sym_points_set.add(dcenter-p)\nnosym = list(points - sym_points_set)\n\nif len(nosym) == 0:\n    print(-1)\n    return\n\n\ncnt = 0\np0 = nosym[0]\ngood_lines = set()\nfor p in nosym:\n    m = (p+p0).int_divide(2)\n    line = Line.between_two_points(m, center)\n    distances = list(map(line.evaluate, nosym))\n\n    ok = True\n    mydict = {}\n    for dd in distances:\n        dda = abs(dd)\n        if dda not in mydict:\n            mydict[dda] = 1\n        else:\n            mydict[dda] += 1\n    for k in mydict:\n        if mydict[k] % 2 == 1 and k != 0:\n            ok = False\n            break\n    if ok:\n        good_lines.add(line.direction())\n\nprint(len(good_lines))\n", "from fractions import Fraction\nimport time\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_tuple(self):\n        return (self.x, self.y)\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n\n    def __hash__(self):\n        return hash(self.to_tuple())\n\n    def __neg__(self):\n        return Point(-self.x, -self.y)\n\n    def __add__(self, other):\n        return Point(self.x+other.x, self.y+other.y)\n\n    def __sub__(self, other):\n        return self+(-other)\n\n    def scalar_mul(self, mu):\n        return Point(mu*self.x, mu*self.y)\n\n    def int_divide(self, den):\n        return Point(self.x//den, self.y//den)\n\n\nclass Line:\n    def __init__(self, a, b, c):\n        # ax+by+c=0\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return \"{}*x + {}*y + {} = 0\".format(self.a, self.b, self.c)\n\n    @classmethod\n    def between_two_points(cls, P, Q):\n        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\n\n    def evaluate(self, P):\n        return self.a*P.x+self.b*P.y+self.c\n\n    def direction(self):\n        if self.a == 0:\n            return (0, 1)\n        return (1, Fraction(self.b, self.a))\n\n\ndef abs_sgn(x):\n    if x == 0:\n        return 0, 0\n    if x < 0:\n        return -x, -1\n    return x, 1\n\n\ntrue_start = time.time()\nn = int(input())\npoints = set()\ncenter = Point(0, 0)\nfor i in range(n):\n    row = input().split(\" \")\n    cur = Point(int(row[0]), int(row[1])).scalar_mul(2*n)\n    center += cur\n    points.add(cur)\n\ncenter = center.int_divide(n)\ndcenter = center+center\n\nsym_points_set = set()\nfor p in points:\n    sym_points_set.add(dcenter-p)\nnosym = list(points - sym_points_set)\n\nif len(nosym) == 0:\n    print(-1)\n    return\n\n\ncnt = 0\np0 = nosym[0]\ngood_lines = set()\nfor p in nosym:\n    m = (p+p0).int_divide(2)\n    line = Line.between_two_points(m, center)\n    distances = list(map(line.evaluate, nosym))\n\n    ok = True\n    mydict = {}\n    for dd in distances:\n        dda, sgn = abs_sgn(dd)\n        if dda not in mydict:\n            mydict[dda] = sgn\n        else:\n            mydict[dda] += sgn\n    for k in mydict:\n        if mydict[k] != 0:\n            ok = False\n            break\n    if ok:\n        good_lines.add(line.direction())\n\nprint(len(good_lines))\n\n# This one is accepted on CF\n"]
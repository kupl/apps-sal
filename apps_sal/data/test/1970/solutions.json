["def check(x, y):\n    return 0 <= x < 8 and 0 <= y < 8\n\ndef dfs1(x, y, T=0):\n    nonlocal first, used\n    if not(check(x, y)) or used[x][y]:\n        return\n    used[x][y] = True\n    first.add((x, y, T))\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\n        dfs1(x + pair[0], y + pair[1], 1 - T)\n\ndef dfs2(x, y, T=0):\n    nonlocal second, used\n    if not(check(x, y)) or used[x][y]:\n        return\n    used[x][y] = True\n    second.add((x, y, T))\n    for pair in (2, 2), (2, -2), (-2, 2), (-2, -2):\n        dfs2(x + pair[0], y + pair[1], 1 - T)\n\n\nt = int(input())\nfor i in range(t):\n    if i > 0:\n        kuzma = input()\n    board = [input() for i in range(8)]\n    FoundFirst = False\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'K':\n                if not(FoundFirst):\n                    First = (i, j)\n                    FoundFirst = True\n                else:\n                    Second = (i, j)\n\n    used = [[0 for i in range(8)] for j in range(8)]\n    first = set()\n    dfs1(First[0], First[1])\n    used = [[0 for i in range(8)] for j in range(8)]\n    second = set()\n    dfs2(Second[0], Second[1])\n    intersection = first & second\n    IsOk = False\n    for x, y, t in intersection:\n        if board[x][y] != '#':\n            print(\"YES\")\n            IsOk = True\n            break\n    if not(IsOk):\n        print(\"NO\")\n    board = []\n", "T=int(input())\n\nfor t in range(T):\n    L=[]\n    for i in range(8):\n        L.append(input())\n    Moves1=[]\n    Moves2=[]\n    K=[]\n    for i in range(8):\n        Moves1.append([-1]*8)\n        Moves2.append([-1]*8)\n        for j in range(8):\n            if(L[i][j]=='K'):\n                K.append((i,j))\n    Now=K[0]\n    Explored=[(Now[0],Now[1],0)]\n    Moves1[Now[0]][Now[1]]=0\n    while(len(Explored)!=0):\n        x=Explored[0][0]\n        y=Explored[0][1]\n        p=Explored[0][2]\n        Explored.pop(0)\n        if(x-2>=0 and y-2>=0):\n            if(Moves1[x-2][y-2]==-1):\n                Moves1[x-2][y-2]=1-p\n                Explored.append((x-2,y-2,1-p))\n        if(x+2<8 and y-2>=0):\n            if(Moves1[x+2][y-2]==-1):\n                Moves1[x+2][y-2]=1-p\n                Explored.append((x+2,y-2,1-p))\n        if(x-2>=0 and y+2<8):\n            if(Moves1[x-2][y+2]==-1):\n                Moves1[x-2][y+2]=1-p\n                Explored.append((x-2,y+2,1-p))\n        if(x+2<8 and y+2<8):\n            if(Moves1[x+2][y+2]==-1):\n                Moves1[x+2][y+2]=1-p\n                Explored.append((x+2,y+2,1-p))\n    Now=K[1]\n    Explored=[(Now[0],Now[1],0)]\n    Moves2[Now[0]][Now[1]]=0\n    while(len(Explored)!=0):\n        x=Explored[0][0]\n        y=Explored[0][1]\n        p=Explored[0][2]\n        Explored.pop(0)\n        if(x-2>=0 and y-2>=0):\n            if(Moves2[x-2][y-2]==-1):\n                Moves2[x-2][y-2]=1-p\n                Explored.append((x-2,y-2,1-p))\n        if(x+2<8 and y-2>=0):\n            if(Moves2[x+2][y-2]==-1):\n                Moves2[x+2][y-2]=1-p\n                Explored.append((x+2,y-2,1-p))\n        if(x-2>=0 and y+2<8):\n            if(Moves2[x-2][y+2]==-1):\n                Moves2[x-2][y+2]=1-p\n                Explored.append((x-2,y+2,1-p))\n        if(x+2<8 and y+2<8):\n            if(Moves2[x+2][y+2]==-1):\n                Moves2[x+2][y+2]=1-p\n                Explored.append((x+2,y+2,1-p))\n    valid=False\n    for i in range(8):\n        for j in range(8):\n            if(Moves1[i][j]!=-1 and Moves1[i][j]==Moves2[i][j] and L[i][j]!=\"#\"):\n                valid=True\n    if(valid):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    if(t!=T-1):\n        s=input()\n", "N = int(input())\nfor i in range(N):\n    if i > 0:\n        input()\n    Pos = []\n    for i in range(8):\n        S = input().strip()\n        for j in range(8):\n            if S[j] == \"K\":\n                Pos.append((i, j))\n    Dx, Dy = abs(Pos[0][0] - Pos[1][0]), abs(Pos[0][1] - Pos[1][1])\n    if (Dx == 0 or Dx == 4) and (Dy == 0 or Dy == 4):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\ndef check(a):\n    return 0<=a<8\nset1 = set()\nset2 = set()\ndic1 = dict()\ndic2 = dict()\ndef cango1(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check (nx) or not check(ny):\n            continue\n        if (nx,ny) in set1:\n            continue\n        dic1[(nx,ny)]=lap%2\n        set1.add((nx,ny))\n        cango1(matrix,(nx,ny),lap+1)\ndef cango2(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check(nx) or not check(ny):\n            continue\n        if (nx,ny) in set2:\n            continue\n        dic2[(nx,ny)]=lap%2\n        set2.add((nx,ny))\n        cango2(matrix,(nx,ny),lap+1)\nq = int(input())\nfor ww in range(q):\n    matrix = [input().strip() for i in range(8)]\n    pos = []\n    bad = set()\n    for i in range(8):\n        for j in range(8):\n            if matrix[i][j] == 'K':\n                pos.append((i,j))\n            if matrix[i][j]=='#':\n                bad.add((i,j))\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\n    cango1(matrix, pos[0],0)\n    cango2(matrix,pos[1],0)\n    if ww!=q-1:\n        input()\n    sec = (set1&set2) - bad\n    for x,y in sec:\n        if dic1[(x,y)]==dic2[(x,y)]:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")\n", "import collections\n\nn = list(map(int, input().split()))[0]\ndi = ((2, 2), (-2, 2), (-2, -2), (2, -2))\n\ndef  bfs(graph, x,y,tx, ty):\n    vis = set()\n    queue = collections.deque()\n    queue.append((x,y))\n    vis.add((x,y))\n    dis =  {}\n    dis[(x,y)] = 0\n\n    while queue:\n        elem = queue.popleft()\n        #print (elem)\n\n        for direction in  di:\n            new_elem =  (elem[0] + direction[0], elem[1] +direction[1])\n            #print (new_elem)\n            if  new_elem[0] >= 0 and  new_elem[1]>= 0 and  new_elem[0] < 8 and new_elem[1] < 8:\n                if  new_elem not in vis:\n                    vis.add(new_elem)\n                    queue.append(new_elem)\n                    dis[new_elem] = dis[elem]+ 1\n#                    print (elem,  new_elem, dis[new_elem])\n\n    if  (tx,ty)  not  in   vis:\n        return  (False,0)\n    return (True, dis[(tx,ty)])\n\nfor cc in range(n):\n    datamap = []\n\n    for i in range(8):\n        datamap.append(input())\n\n    ans = []\n    for i  in range(len(datamap)):\n        for j in range(len(datamap[i])):\n            if datamap[i][j] == 'K':\n                ans.append(i);\n                ans.append(j);\n\n    ans =   bfs(datamap, ans[0], ans[1], ans[2], ans[3])\n    #print (ans)\n    if ans[0] and  ans[1] % 2 == 0:\n        print (\"YES\")\n    else:\n        print (\"NO\")\n\n    if cc !=  n - 1:\n        input()\n\n\n", "import sys\nimport collections\n\n\nclass GetOutOfLoop(Exception):\n    pass\n\ndef __starting_point():\n\n    n_cases = int(sys.stdin.readline())\n\n    for case in range(n_cases):\n        board = [list(sys.stdin.readline().rstrip()) for i in range(8)]\n        knight_init_loc = [None, None]\n        knight = 0\n        for current_i in range(8):\n            for current_j in range(8):\n                if board[current_i][current_j] == 'K':\n                    knight_init_loc[knight] = (current_i, current_j)\n                    knight += 1\n\n        to_explore = collections.deque()\n\n        to_explore.append((knight_init_loc[0], 0))\n        explored = set()\n        try:\n            while len(to_explore) > 0:\n                ((current_i, current_j), current_step) = to_explore.popleft()\n                explored.add((current_i, current_j))\n                candidates = set()\n                for inc_i in [-2, 2]:\n                    for inc_j in [-2, 2]:\n                        next_i, next_j = current_i + inc_i, current_j + inc_j\n                        if 0 <= next_i < 8 and 0 <= next_j < 8 and (next_i, next_j) not in explored:\n                            candidates.add(((next_i, next_j), current_step + 1))\n                for (s, next_step) in candidates:\n                    if s == knight_init_loc[1] and next_step % 2 == 0:\n                        print('YES')\n                        raise GetOutOfLoop\n                    to_explore.append((s, next_step))\n                current_step += 1\n            print('NO')\n        except GetOutOfLoop:\n            pass\n        sys.stdin.readline()\n__starting_point()", "def main():\n  n = int(input())\n  out = \"\"\n  \n  for t in range(n):\n    knights = [0 for i in range(16)]\n    valid = [False for i in range(16)]\n    for i in range(8):\n      line = input()\n      #print()\n      for j in range(8):\n        #print(get(i, j), end=\"\\t\")\n        if line[j] != '#':\n          valid[get(i, j)] = True\n        if line[j] == 'K':\n          knights[get(i, j)] += 1\n    \n    for i in range(16):\n      #print(i, knights[i], valid[i])\n      if knights[i] == 2 and valid[i]:\n        out += \"YES\\n\"\n        break\n    else:\n      out += \"NO\\n\"\n    \n    if t != n-1:\n      input()\n  \n  print(out[:-1])\n\ndef get(i, j):\n  return [[0, 1, 2, 3],[4, 5, 6, 7],[8, 9, 10, 11],[12, 13, 14, 15]][i%4][j%4]\n\ndef __starting_point(): main()\n__starting_point()", "MOVS = [(2,-2),(-2,2),(-2,-2),(2,2)]\ndef check(a):\n    return 0<=a<8\nset1 = set()\nset2 = set()\ndic1 = dict()\ndic2 = dict()\ndef cango1(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check (nx) or not check(ny):\n            continue\n        if (nx,ny) in set1:\n            continue\n        dic1[(nx,ny)]=lap%2\n        set1.add((nx,ny))\n        cango1(matrix,(nx,ny),lap+1)\ndef cango2(matrix,pos,lap):\n    for dx,dy in MOVS:\n        nx,ny = dx+pos[0],dy+pos[1]\n        if not check(nx) or not check(ny):\n            continue\n        if (nx,ny) in set2:\n            continue\n        dic2[(nx,ny)]=lap%2\n        set2.add((nx,ny))\n        cango2(matrix,(nx,ny),lap+1)\nq = int(input())\nfor ww in range(q):\n    matrix = [input().strip() for i in range(8)]\n    pos = []\n    for i in range(8):\n        for j in range(8):\n            if matrix[i][j] == 'K':\n                pos.append((i,j))\n    set1,set2,dic1,dic2=set(),set(),dict(),dict()\n    cango1(matrix, pos[0],0)\n    cango2(matrix,pos[1],0)\n    if ww!=q-1:\n        input()\n    sec = set1&set2\n    for x,y in sec:\n        if dic1[(x,y)]==dic2[(x,y)]:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")", "3\n\nn = int(input())\nfor _ in range(n):\n    k = []\n    b = []\n    for i in range(8):\n        s = input()\n        for j in range(8):\n            if s[j] == 'K':\n                k.append((i, j))\n    print('YES' if abs(k[0][0] - k[1][0]) % 4 == 0 and abs(k[0][1] - k[1][1]) % 4 == 0 else 'NO')\n    if _ < n - 1:\n        input()\n", "t = int(input())\nel = [[1,2,3,4,1,2,3,4],[5,6,7,8,5,6,7,8],[9,10,11,12,9,10,11,12],[13,14,15,16,13,14,15,16],[1,2,3,4,1,2,3,4],[5,6,7,8,5,6,7,8],[9,10,11,12,9,10,11,12],[13,14,15,16,13,14,15,16]]\nfor x in range(t):\n    arr = [[]for i in range(8)]\n    for i in range(8):\n        s = input()\n        for j in range(len(s)):\n            arr[i].append(s[j])\n    l = 0\n    for i in range(8):\n        for j in range(8):\n            if l == 0:\n                if arr[i][j] == 'K':\n                    k1 = el[i][j]\n                    l = 1\n            else:\n                if arr[i][j] == 'K':\n                    k2 = el[i][j]\n                    break\n    if k1 == k2:\n        print('YES')\n    else:\n        print('NO')\n    if x != t-1:\n        y = list(map(int, input().split()))", "N = list(range(8))\ntest = int (input())\nfor i_test in range(test):\n    if (i_test): input()\n    x1,y1,x2,y2=0,0,0,0\n    map = [input() for i in N]\n    for i in N:\n        for j in N:\n            if (map[i][j]==\"K\"): x1,y1,x2,y2 = x2,y2,i,j\n    if (abs(x1-x2)%4==0 and abs(y1-y2)%4==0): print (\"YES\")\n    else: print (\"NO\")\n", "def solve(m, x,y , w,z):\n\tfor i in range(8):\n\t\tfor j in range(8):\n\t\t\tif m[i][j]:\n\t\t\t\ta, pa = movePossible(x,y , i,j)\n\t\t\t\tb, pb = movePossible(w,z , i,j)\n\t\t\t\tif a and b and pa==pb:\n\t\t\t\t\treturn True\n\treturn False\n\t\ndef movePossible(x,y , w,z):\n\ta = x-w\n\tb = y-z\n\tpos=False\n\tka=a//2\n\tkb=b//2\n\tif a%2==0 and b%2==0 and (ka+kb)%2==0:\n\t\tpos=True\n\t\n\treturn pos, ka%2\n\nt = int(input())\nfor _c in range(t):\n\tm = []\n\tprimo = True\n\tfor i in range(8):\n\t\tm.append([])\n\t\ts = input()\n\t\tk=0\n\t\tfor c in s:\t\n\t\t\tif c=='#':\n\t\t\t\tm[i].append( False )\n\t\t\telse:\n\t\t\t\tm[i].append( True )\n\t\t\t\n\t\t\tif c=='K' and primo:\n\t\t\t\tx=i\n\t\t\t\ty= k\n\t\t\t\tprimo = False\n\t\t\tif c=='K' and (not primo):\n\t\t\t\tw=i\n\t\t\t\tz= k\n\t\t\tk+=1\n\t\n\tif solve(m, x,y , w,z):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\t\n\tif _c!=t-1: m=input()\n\t\n\t\n\t\n", "def f():\n    t = []\n    for i in range(8):\n        p = input()\n        for j in range(8):\n            if p[j] == 'K': t += [i, j]\n    if t[2] - t[0] in (0, 4) and t[1] - t[3] in (-4, 0, 4): return 'YES'\n    return 'NO'\nfor i in range(int(input()) - 1):\n    print(f())\n    input()\nprint(f())", "def check():\n    board = []\n    for cont in range(0,8):\n        board.append(input())\n    l = True\n    for cont in range(0,8):\n        for cont2 in range(0,8):\n            if board[cont][cont2] == 'K':\n                if l:\n                    xk1 = cont2\n                    yk1 = cont\n                    l = False\n                else:\n                    xk2 = cont2\n                    yk2 = cont\n                    break\n    for cont in range(0,8):\n        for cont2 in range(0,8):\n            if cont2 %2 == xk1%2 == xk2%2:\n                if cont%2 == yk1%2 == yk2%2:\n                    if abs(cont2-xk1)%4 == abs(cont2-xk2)%4:\n                        if abs(cont-yk1)%4 == abs(cont-yk2)%4:\n                            if board[cont][cont2] != '#':\n                                print('YES')\n                                return\n    print('NO')\n    return\n            \nn = int(input())\ncheck()\nfor t in range(0,n-1):\n    a = str(input())\n    check()", "t = int(input())\nfor k in range(t):\n  r8 = range(8)\n  a = [input() for i in r8]\n  ij = [(i, j) for i in r8 for j in r8]\n  x, y = ((i, j) for i, j in ij if a[i][j] == \"K\")\n  def s(p):\n    d = [(p[0] - 2, p[1] - 2), (p[0] + 2, p[1] - 2), (p[0] - 2, p[1] + 2), (p[0] + 2, p[1] + 2)]\n    return set((i, j) for i, j in ij if (i, j) in d)\n  print(\"YES\" if len(s(x) & s(y)) > 0 else \"NO\")\n  if k != t - 1:\n    input()", "n = int(input())\nfor t in range(n):\n    if t: input()\n    board = [[c for c in input()] for i in range(8)]\n    k1, k2 = ((i, j) for i in range(8) for j in range(8) if board[i][j] == 'K')\n    if (k1[0] - k2[0]) % 4 == 0 and (k1[1] - k2[1]) % 4 == 0:\n        print('YES')\n    else:\n        print('NO')\n\n\n\n", "def f():\n    t = []\n    for i in range(8):\n        p = input()\n        for j in range(8):\n            if p[j] == 'K': t += [i, j]\n    if t[2] - t[0] in (0, 4) and t[1] - t[3] in (-4, 0, 4): return 'YES'\n    return 'NO'\nfor i in range(int(input()) - 1):\n    print(f())\n    input()\nprint(f())", "n = int(input())\n\nfor t in range(n):\n\n    if t: input()\n\n    board = [[c for c in input()] for i in range(8)]\n\n    k1, k2 = ((i, j) for i in range(8) for j in range(8) if board[i][j] == 'K')\n\n    if (k1[0] - k2[0]) % 4 == 0 and (k1[1] - k2[1]) % 4 == 0:\n\n        print('YES')\n\n    else:\n\n        print('NO')\n\n\n\n\n\n\n\n", "n = int (input())\nfor i in range(n):\n    if (i): \n        input()\n    x1 = y1 = x2 = y2 = 0\n    s = [input() for i in range(8)]\n    for i in range(8):\n        for j in range(8):\n            if (s[i][j] == 'K'):\n                x1, y1, x2, y2 = x2, y2, i, j\n    if (abs(x1-x2) % 4 == 0 and abs(y1-y2) % 4 == 0): \n        print (\"YES\")\n    else: \n        print (\"NO\")\n", "a = []\n\n\ndef first(i, j):\n    nonlocal a\n    a[i][j] = 1\n    if i - 2 >= 0 and j + 2 < 8:\n        a[i - 2][j + 2] = 1\n    if i - 2 >= 0 and j - 2 >= 0:\n        a[i - 2][j - 2] = 1\n    if i + 2 < 8 and j + 2 < 8:\n        a[i + 2][j + 2] = 1\n    if i + 2 < 8 and j - 2 >= 0:\n        a[i + 2][j - 2] = 1\n\n\ndef second(i, j):\n    nonlocal a\n    if a[i][j] == 1:\n        return True\n    if i - 2 >= 0 and j + 2 < 8:\n        if a[i - 2][j + 2] == 1:\n            return True\n    if i - 2 >= 0 and j - 2 >= 0:\n        if a[i - 2][j - 2] == 1:\n            return True\n    if i + 2 < 8 and j + 2 < 8:\n        if a[i + 2][j + 2] == 1:\n            return True\n    if i + 2 < 8 and j - 2 >= 0:\n        if a[i + 2][j - 2] == 1:\n            return True\n    return False\n\n\nt = int(input())\nfor i in range(t):\n    a = []\n    exist = False\n    for j in range(8):\n        a.append(list(input()))\n    d = 0\n    for j in range(8):\n        for k in range(8):\n            if a[j][k] == 'K':\n                d += 1\n                if d == 1:\n                    first(j, k)\n                elif d == 2:\n                    if second(j, k):\n                        exist = True\n    if exist:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    if i != t - 1:\n        input()\n", "for i in range(int(input())):\n    if i :\n        input()\n    ans = []\n    for i in range(8):\n        s = input()\n        for j in range(8):\n            if s[j] == 'K':\n                ans.append((i, j))\n    print(['NO' , 'YES'][abs(ans[0][0] - ans[1][0]) % 4 == 0 and abs(ans[0][1] - ans[1][1]) % 4 == 0])\n", "t = int(input())\nfor _ in range(t):\n    s = [input() for i in range(8)]\n    oh = True\n    flag = True\n    for i in range(8):\n        for j in range(8):\n            if(s[i][j] == 'K'):\n                if(flag):\n                    pos1x = i\n                    pos1y = j\n                    flag = False\n                else:\n                    pos2x = i\n                    pos2y = j\n    if(pos1x % 4 == pos2x % 4) and (pos1y % 4 == pos2y % 4):\n        print('YES')\n    else:\n        print('NO')\n    if( _ < t - 1):\n        k = input()\n", "t = int(input())\nfor _ in range(t):\n    if _:\n        input()\n    knights = []\n    for i in range(8):\n        s = input().strip()\n        for j in range(8):\n            if s[j] == 'K':\n                knights.append((i,j))\n    n1 = knights[0]\n    n2 = knights[1]\n    \"\"\"\n    if n1[0] % 2 == n2[0] % 2 and n1[1] % 2 == n2[1] % 2:\n        c1 = n1[0]//2 + n1[1]//2\n        c2 = n2[1]//2 + n2[0]//2\n        if c1 % 2 == c2 % 2:\n            print('YES')\n        else:\n            print('NO')\n    \"\"\"\n    if n1[0] % 4 == n2[0] % 4 and n1[1] % 4 == n2[1] % 4:\n        print('YES')\n    else:\n        print('NO')\n", "t = int(input())\n\nfor _ in range(t):\n    if _ != 0:\n        tmp = input()\n        \n    pos = []\n    n = 8\n    g = []\n    for i in range(n):\n        g.append([i for i in input()])\n        \n    for i in range(n):\n        for j in range(n):\n            if g[i][j] == \"K\":\n                pos.append((i, j))\n        \n    ok = False\n    for i in range(n):\n        for j in range(n):\n            if i%2 == pos[0][0]%2 and i%2 == pos[1][0]%2 and j%2 == pos[0][1]%2 and j%2 == pos[1][1]%2:\n                dist1 = ((i-pos[0][0]), (j-pos[0][1]))\n                dist2 = ((i-pos[1][0]), (j-pos[1][1]))\n                if dist1[0]-dist2[0]%4 == 0 and dist1[1]-dist2[1]%4 == 0:\n                    ok = True\n\n    print(\"YES\" if ok else \"NO\")", "t = int(input())\nwhile t:\n    t += -1\n    l = []\n    mp = []\n    for i in range(8):\n        tmp = list(input())\n        l.append(tmp)\n        mp.append([0] * 8)\n    i1, j1, i2, j2 = -1, -1, -1, -1\n    for i in range(8):\n        for j in range(8):\n            if l[i][j] == 'K' and i1 == -1: i1, j1 = i, j\n            if l[i][j] == 'K': i2, j2 = i, j\n    if abs(i2 - i1) % 4 == 0 and abs(j2 - j1) % 4 == 0: print('YES')\n    else: print('NO')\n    if t != 0: input()"]
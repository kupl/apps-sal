["def check(k, aas, bs, a_rem, b_rem):\n    if a_rem + b_rem < k:\n        return False\n    a_lo = k - b_rem\n    a_hi = a_rem\n\n    rems = set()\n    rems.add(0)\n    for a, b in zip(aas, bs):\n        if a + b < k:\n            continue\n        for i in range(max(0, k - b), min(a, k) + 1):\n            rem = i % k\n            for j in list(rems):\n                rems.add((j + rem) % k)\n    for rem in rems:\n        if rem >= a_lo and rem <= a_hi:\n            return True\n    return False\n\n\nn, k = [int(x) for x in input().split()]\naas = []\nbs = []\na_total = 0\nb_total = 0\nfor i in range(n):\n    a, b = [int(x) for x in input().split()]\n    aas.append(a)\n    bs.append(b)\n    a_total += a\n    b_total += b\nans = a_total // k + b_total // k\nif check(k, aas, bs, a_total % k, b_total % k):\n    print(ans + 1)\nelse:\n    print(ans)\n", "import sys\nreadline = sys.stdin.readline\n\n\ndef merge(A, B):\n    res = A[:]\n    for i in range(len(A)):\n        if A[i]:\n            for j in range(len(B)):\n                if B[j]:\n                    res[(i+j)%K] = 1\n    return res\n\nN, K = map(int, readline().split())\nR = 0\nB = 0\n\nflag = False\ntable = [0]*K\ntable[0] = 1\nfor _ in range(N):\n    r, b = map(int, readline().split())\n    R += r\n    B += b\n    if r >= K and b >= K:\n        flag = True\n    elif r+b >= K:\n        st, en = max(0, K-b), min(K, r)\n        t2 = [0]*K\n        for i in range(st, en+1):\n            t2[i%K] = 1\n        table = merge(table, t2)\nif flag:\n    print((R+B)//K)\nelif (R//K + B//K == (R+B)//K):\n    print((R+B)//K)\nelse:\n    pr = R%K\n    pb = B%K\n    ans = R//K + B//K\n    for i in range(K):\n        if table[i]:\n            if (pr-i)%K + (pb-K+i)%K < K:\n                ans += 1\n                break\n    print(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    n,k=MI()\n    ab=LLI(n)\n    pre=1\n    sa=sb=0\n    mask=(1<<k)-1\n    for a,b in ab:\n        sa+=a\n        sb+=b\n        if a+b<k:continue\n        mn=max(k-b,0)\n        mx=min(a,k-1)\n        now=pre\n        for s in range(mn,mx+1):\n            now|=pre<<s\n        now|=now>>k\n        now&=mask\n        pre=now\n        #print(bin(pre))\n    ans=0\n    for r in range(k):\n        if pre >> r & 1: ans = max(ans, (sa - r) // k + (sb + r) // k)\n    print(ans)\n\nmain()", "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list([int(x)-1 for x in input().split()])\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#solve\ndef solve():\n    n, k = LI()\n    ab = LIR(n)\n    dp = [False] * k\n    dp[0] = True\n    A = 0\n    B = 0\n    for a, b in ab:\n        ndp = dp[::1]\n        A += a\n        B += b\n        for i in range(k):\n            if dp[i]:\n                for j in range(max((k - a), 1), min(k, (b + 1))):\n                    ndp[(i+j)%k] = True\n        dp = ndp[::1]\n    ans = A // k + B // k\n    for i in range(k):\n        if dp[i]:\n            ans = max(ans, (A + i) // k + (B - i) // k)\n    print(ans)\n    return\n\n\n#main\ndef __starting_point():\n    solve()\n\n__starting_point()"]
["str=input().split()\nn=int(str[0])\nlen=int(str[1])\na=[]\nQ=[]\nF=[]\nfor i in range(0,n+1):\n\ta.append(0)\n\tQ.append(0)\n\tF.append(0)\nsum=0\nh=1\nt=0\nstr=input().split()\nfor i in range(1,n+1):\n\ta[i]=int(str[i-1])\n\tsum+=a[i]\n\t#print (sum)\n\twhile h<=t and Q[h]<=i-len:\n\t\th=h+1\n\twhile h<=t and a[i]<=a[Q[t]]:\n\t\tt=t-1\n\tt=t+1;Q[t]=i;\n\tif (i<len) :\n\t\tF[i]=0\n\telse :\n\t\tF[i]=F[i-len]+a[Q[h]]\n\tF[i]=max(F[i],F[i-1])\n\t\t\nprint(sum-F[n])\n", "from heapq import *\n\nn, c = map(int, input().split())\na = list(map(int, input().split()))\n\nif c > n:\n\tprint(sum(a))\n\treturn\n\nb = [0] * n\ns = 0\nh = []\nfor i in range(n):\n\ts = s + a[i] - a[i-c] if i + 1 > c else s + a[i]\n\theappush(h, (a[i],i))\t\n\tif i + 1 < c:\n\t\tb[i] = s\n\telse:\n\t\twhile h[0][1] <= i-c:\n\t\t\theappop(h)\n\t\tv1 = b[i-1] + a[i]\t\t\t\n\t\tv2 = b[i-c] + s - h[0][0]\n\t\tb[i] = min(v1, v2)\n\t\nprint(b[-1])", "from functools import *\nfrom time import time\nfrom heapq import *\n\n\ndef measure_time(fun):\n    def wrapper(*args, **kwargs):\n        begin = time()\n        rv = fun(*args, **kwargs)\n        end = time()\n        print(end - begin)\n        return rv\n    return wrapper\n\n\ndef our_cache(func):\n    memo = [-1]*(max+1)\n\n    @wraps(func)\n    def wrapper(arg):\n        if memo[arg] == -1:\n            memo[arg] = func(arg)\n        return memo[arg]\n    return wrapper\n\n\ndef main():\n    n, c = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n\n    if c > n:\n        print(sum(a))\n        return\n\n    b = n * [0]\n    s = 0\n    h = []\n    for i in range(n):\n        s = s + a[i] if i <= c-1 else s + a[i] - a[i-c]\n        heappush(h, (a[i], i))\n        if i <= c-2:\n            b[i] = s\n        else:\n            while i-h[0][1] >= c:\n                heappop(h)\n            v1 = b[i-c] + s - h[0][0]\n            v2 = a[i] + b[i-1]\n            b[i] = min(v1, v2)\n\n    print(b[-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from functools import *\nfrom time import time\nfrom heapq import *\n\n# \n# def measure_time(fun):\n#     def wrapper(*args, **kwargs):\n#         begin = time()\n#         rv = fun(*args, **kwargs)\n#         end = time()\n#         print(end - begin)\n#         return rv\n#     return wrapper\n#\n#\n# def our_cache(func):\n#     memo = [-1]*(max+1)\n#\n#     @wraps(func)\n#     def wrapper(arg):\n#         if memo[arg] == -1:\n#             memo[arg] = func(arg)\n#         return memo[arg]\n#     return wrapper\n\n\ndef main():\n    n, c = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n\n    if c > n:\n        print(sum(a))\n        return\n\n    b = n * [0]\n    s = 0\n    h = []\n    for i in range(n):\n        s = s + a[i] if i <= c-1 else s + a[i] - a[i-c]\n        heappush(h, (a[i], i))\n        if i <= c-2:\n            b[i] = s\n        else:\n            while i-h[0][1] >= c:\n                heappop(h)\n            v1 = b[i-c] + s - h[0][0]\n            v2 = a[i] + b[i-1]\n            b[i] = min(v1, v2)\n\n    print(b[-1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import *\n\nn, c = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nif c > n:\n    print(sum(a))\n    return\n\nb = [0] * n\ns = 0\nh = []\nfor i in range(n):\n    s = s + a[i] - a[i-c] if i + 1 > c else s + a[i]\n    heappush(h, (a[i], i))\n    if i + 1 < c:\n        b[i] = s\n    else:\n        while h[0][1] <= i - c:\n            heappop(h)\n        v1 = b[i-1] + a[i]\n        v2 = b[i-c] + s - h[0][0]\n        b[i] = min(v1, v2)\nprint(b[-1])", "from heapq import *\nf = lambda: map(int, input().split())\nn, c = f()\na = list(f()) + [0] * c\nb = [0] * (n + c)\ns = 0\nh = [(0, -1)]\nfor i in range(n):\n    s += a[i] - a[i - c]\n    heappush(h, (a[i], i))\n    while h[0][1] <= i - c: heappop(h)\n    b[i] = min(b[i - 1] + a[i], b[i - c] + s - h[0][0])\nprint(b[n - 1])"]
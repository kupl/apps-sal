"""
Очевидно, что если k чётно, то решения не существует, так как кол-во вызовов 
всегда нечётно (один вызов делается в самом начале, и каждый вызов делает 0 
или 2 рекурсивных вызова).

Затем, если k чётно, начнём с отсортированной перестановки и попробуем 
«перемешать» её. Введём функцию unsort(l, r), которая будет «перемешивать» 
промежуток. При перемешивании промежутка мы либо оставляем его отсортированным 
(если было уже достаточно вызовов), или меняем его и вызываем unsort(l, mid) и 
unsort(mid, r), если нужно больше вызовов. Когда мы меняем промежуток, лучше его
половины оставить отсортированными; простой способ сделать это — поменять 
местами два соседних элемента.

Можно легко увидеть, что кол-во вызовов unsort равно кол-ву вызовов mergesort, 
необходимому для сортировки полученной перестановки, поэтому такое решение можно
попробовать использовать, чтобы получить ровно k вызовов.
"""

def unsort(arr, left, right, k):
    if k[0] <= 0 or left >= right - 1:
        return
    
    k[0] -= 2
    mid = (left + right) // 2

    arr[mid], arr[mid - 1] = arr[mid - 1], arr[mid]

    unsort(arr, left, mid, k)
    unsort(arr, mid, right, k)


n, k = list(map(int, input().split()))
 
if k % 2 == 0:
    print(-1)
else:
    k = [k - 1]
    arr = [i for i in range(1, n + 1)]
 
    unsort(arr, 0, n, k)

    if not k[0]:
        print(*arr)
    else:
        print(-1)


["s = input()\na, b = s.count('x'), s.count('y')\nif b > a: print('y' * (b - a))\nelse: print('x' * (a - b))", "l = list(input())\nx = l.count('x')\ny = l.count('y')\nprint('x' * (x - y) if x > y else 'y' * (y - x))", "s = input().strip()\ncounter = {'x': 0, 'y': 0}\nfor ch in s:\n\tcounter[ch] += 1\ndiff = counter['x'] - counter['y']\nif (diff >= 0):\n\tprint(\"\".join(['x'] * diff))\nelse:\n\tdiff = - diff\n\tprint(\"\".join(['y'] * diff))\n\t\t\n", "s = input()\na = s.count('x')\nb = s.count('y')\nif a>b:\n    s = 'x'*(a-b)\nelse:\n    s = 'y'*(b-a)\n\nprint(s)", "\nimport sys\nimport math\n  \nst = sys.stdin.readline()\n\nd = [0] * 2\nfor i in st:\n    if(i != '\\n'):\n        d[ord(i) - 120] += 1\n        \nif(d[0] - d[1] > 0):\n    t = ['x'] * (d[0] - d[1])\n    print(\"\".join(t))\nelif(d[1] - d[0] > 0):\n    t = ['y'] * (d[1] - d[0])\n    print(\"\".join(t))", "x,y=list(map(input().count,'xy'));\nif x>y:\n print(((x-y)*'x'));\nelse:\n  print(((y-x)*'y'));\n\n\n\n", "s = input()\nx = s.count('x')\ny = s.count('y')\nif x > y:\n\tprint('x' * (x - y))\nelse:\n\tprint('y' * (y - x))\n", "ins=input()\nkol_x=0\nkol_y=0\nfor ii in ins:\n    if ii=='x': kol_x+=1\n    else: kol_y+=1\nif kol_x>kol_y:\n    print('x'*(kol_x-kol_y))\nelse:\n    print('y'*(kol_y-kol_x))\n", "S = input()\n\nctr = 0\n\nfor i in S:\n\tif(i==\"x\"):\n\t\tctr+=1\n\telse:\n\t\tctr-=1\n\nif(ctr<0):\n\tprint(\"y\"*(-ctr))\nelse:\n\tprint(\"x\"*ctr)", "__author__ = \"runekri3\"\n\ns = input()\n\nx_count = s.count(\"x\")\ny_count = s.count(\"y\")\nif x_count > y_count:\n    char = \"x\"\nelse:\n    char = \"y\"\nprint(char * abs(x_count - y_count))\n", "def main():\n    stack = []\n    for c in input():\n        if stack and stack[-1] != c:\n            del stack[-1]\n        else:\n            stack.append(c)\n    print(''.join(reversed(stack)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s,x,y=input(),0,0\nfor i in range(len(s)):\n    if s[i]=='x':\n        x+=1\n    else:\n        y+=1\nprint((x-y)*'x' if x>y else (y-x)*'y')\n", "from collections import Counter\ns=input()\nc=Counter(s)\nif c['x']>c['y']:\n  print('x'*(c['x']-c['y']))\nelse:\n  print('y'*(c['y']-c['x']))\n\n", "a=input()\nx=a.count('x')\ny=a.count('y')\nif x>y:\n    print('x'*(x-y))\nelse:\n    print('y'*(y-x))\n", "s = input()\nx, y = s.count(\"x\"), s.count(\"y\")\nif x > y:\n  print(\"x\"*(x-y))\nelse:\n  print(\"y\"*(y-x))", "def code_parsing(string):\n    string = ''.join(sorted(string))\n\n    x = string.count(\"x\")\n    y = string.count(\"y\")\n\n    if x > y:\n        return \"x\" * (x - y)\n    elif x < y:\n        return \"y\" * (y - x)\n    else:\n        return \"\"\n\ns = input()\nprint(code_parsing(s))\n\n", "#\"from dust i have come, dust i will be\"\n\ns=input()\n\nx=0;y=0\n\nfor i in range(len(s)):\n    if(s[i]=='x'):\n        x+=1\n    else:\n        y+=1\n\nt=\"\"\nif(x>y):\n    for i in range(x-y):\n        t+=\"x\"\n\nelse:\n    for i in range(y-x):\n        t+=\"y\"\n\nprint(t)", "n = sum([{'x':1, 'y':-1}[c] for c in input()])\nprint(n * 'x' if n > 0 else -n * 'y')\n", "n = sum([{'x':1, 'y':-1}[c] for c in input()])\nprint(n * 'x' + -n * 'y')\n", "n = sum([{'x':1, 'y':-1}[c] for c in input()])\nprint(n * 'x' + -n * 'y')\n", "s = input()\nx = s.count(\"x\")\ny = s.count(\"y\")\n\nif x > y:\n    print(\"x\"*(x-y))\nelse:\n    print(\"y\"*(y-x))", "s=input()\nk1=s.count('x')\nk2=s.count('y')\nif k1>k2:\n    print('x'*(k1-k2))\nelse:\n    print('y'*(k2-k1))\n", "from collections import Counter\ndef get_ans():\n    c = Counter(input())\n    x = c['x']\n    y = c['y']\n    if x > y:\n        return 'x'*(x-y)\n    elif y > x:\n        return 'y'*(y-x)\n    else:\n        return ''\nans = get_ans()\nprint(ans)", "import math\nimport sys\n3\n\ndef change_char_at(ch, s, indx):\n    \"\"\"\n    Strings in Python are immutable objects. So, it is not possible to change a\n    certain character in a string in place. For example, an attempt to run the\n    following code will fail with a TypeError:\n\n        s = \"spam\"\n        s[1] = \"z\" # TypeError: 'str' object does not support item assignment\n\n    What this function does is it provides you with a nice interface when you\n    want to change a character in a string at a certain index position. So, use\n    this function instead of doing everything manually which can sometimes be\n    tricky. Notice that the character parameter does not necessarily have to be\n    one character long. It can be an empty string which means that a character\n    at a certain position will effectively be deleted from the string. If it's\n    more than one character long, then they all will be inserted into the string\n    starting at the specified index position.\n\n    Parameters:\n    ch:   character to insert\n    s:    string to insert into\n    indx: index position where to insert the character\n    \"\"\"\n    # Error handling\n    if type(ch) is not str:\n        raise TypeError(\"first argument must be a string\")\n    if type(s) is not str or not len(s) > 0:\n        raise TypeError(\"second argument must be a non-empty string\")\n\n    length = len(s) - 1\n    if not(indx >= 0 and indx <= length):\n        msg  = \"string index out of range; \"\n        msg += \"attempt to access index at {0}; \".format(indx)\n        msg += \"allowable index range 0 to {0}\".format(length)\n        raise IndexError(msg)\n\n    # Actual function logic\n    return s[:indx] + ch + s[indx + 1:]\n    \"\"\"\n    Another possible implementation:\n\n        ls       = list(s)\n        ls[indx] = ch\n        return ''.join(ls)\n\n    This works well too and is equally good, but might be conspired unpythonic\n    by some compared to the one right above it.\n    \"\"\"\n\n\n\ns=input()\nx=0\ny=0\nfor i in range(0,len(s)):\n        \n        if(s[i]=='y'):\n           y+=1\n        elif(s[i]=='x'):\n           x+=1;\nif(x-y>0):\n     print(\"x\"*(x-y))\n           \nelse:\n     print(\"y\"*(y-x))\n           \n\n\n        \n"]
["# fast io\nfrom sys import stdin\n_data = iter(stdin.read().split('\\n'))\ninput = lambda: next(_data)\n\nN = 101\nMOD = 1000000007\n\ndef mul_vec_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(a[j][i] * v[j] % MOD for j in range(N)) % MOD\n    return c\n\ndef mul_vec_sparse_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(x * v[j] % MOD for j, x in a[i]) % MOD\n    return c\n\n_, x = [int(v) for v in input().split()]\na = [[0] * N for i in range(N)]\na[0][0] = 1\na[N - 1][0] = 1\nfor i in range(1, N - 1):\n    a[i][i + 1] = 1\nfor d in map(int, input().split()):\n    a[N - 1][N - d] += 1\nsa = [[] for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if a[i][j] != 0:\n            sa[j].append((i, a[i][j]))\nr = [[1 if i == j else 0 for j in range(N)] for i in range(N)]\nwhile x > 0:\n    if x & 1:\n        r[0] = mul_vec_mat(r[0], a)\n        r[1] = mul_vec_mat(r[1], a)\n    aa = [[0] * N for i in range(N)]\n    aa[0] = mul_vec_mat(a[0], a)\n    aa[1] = mul_vec_mat(a[1], a)\n    for i in range(2, N):\n        aa[i] = mul_vec_sparse_mat(aa[i - 1], sa)\n    a = aa\n    x >>= 1\nfor i in range(2, N):\n    r[i] = mul_vec_sparse_mat(r[i - 1], sa)\nb = [0] * N\nb[0] = 1\nb[N - 1] = 1\nprint(sum(r[N - 1][i] * b[i] % MOD for i in range(N)) % MOD)", "# fast io\nfrom sys import stdin\n_data = iter(stdin.read().split('\\n'))\ninput = lambda: next(_data)\n\nN = 101\nMOD = 1000000007\n\ndef mul_vec_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(a[j][i] * v[j] % MOD for j in range(N)) % MOD\n    return c\n\ndef mul_vec_sparse_mat(v, a):\n    c = [0] * N\n    for i in range(N):\n        c[i] = sum(x * v[j] % MOD for j, x in a[i]) % MOD\n    return c\n\n_, x = [int(v) for v in input().split()]\na = [[0] * N for i in range(N)]\na[0][0] = 1\na[N - 1][0] = 1\nfor i in range(1, N - 1):\n    a[i][i + 1] = 1\nfor d in map(int, input().split()):\n    a[N - 1][N - d] += 1\nsa = [[] for i in range(N)]\nfor i in range(N):\n    for j in range(N):\n        if a[i][j] != 0:\n            sa[j].append((i, a[i][j]))\nr = [[1 if i == j else 0 for j in range(N)] for i in range(N)]\nwhile x > 0:\n    if x & 1:\n        r[0] = mul_vec_mat(r[0], a)\n        r[1] = mul_vec_mat(r[1], a)\n    aa = [[0] * N for i in range(N)]\n    aa[0] = mul_vec_mat(a[0], a)\n    aa[1] = mul_vec_mat(a[1], a)\n    for i in range(2, N):\n        aa[i] = mul_vec_sparse_mat(aa[i - 1], sa)\n    a = aa\n    x >>= 1\nfor i in range(2, N):\n    r[i] = mul_vec_sparse_mat(r[i - 1], sa)\nb = [0] * N\nb[0] = 1\nb[N - 1] = 1\nprint(sum(r[N - 1][i] * b[i] % MOD for i in range(N)) % MOD)", "# fast io\nfrom sys import stdin\n_data = iter(stdin.read().split('\\n'))\ninput = lambda: next(_data)\n\nN = 101\nMOD = 1000000007\n\ndef mul_vec_mat(v, a):\n    n = len(a[0])\n    m = len(v)\n    c = [0] * n\n    for i in range(n):\n        c[i] = sum(a[j][i] * v[j] % MOD for j in range(m)) % MOD\n    return c\n\ndef mul_vec_sparse_mat(v, ta):\n    n = len(ta)\n    c = [0] * n\n    for i in range(n):\n        c[i] = sum(x * v[j] % MOD for j, x in ta[i]) % MOD\n    return c\n\ndef mod_pow_kitamasa(a, x):\n    n = len(a)\n\n    # sparse matrix of a^T\n    ta = [[] for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] != 0:\n                ta[j].append((i, a[i][j]))\n\n    r = [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n    while x > 0:\n        if x & 1:\n            r[1] = mul_vec_mat(r[1], a)\n        aa = [[0] * n for i in range(n)]\n        aa[0] = a[0]\n        aa[1] = mul_vec_mat(a[1], a)\n        for i in range(2, n):\n            aa[i] = mul_vec_sparse_mat(aa[i - 1], ta)\n        a = aa\n        x >>= 1\n    for i in range(2, n):\n        r[i] = mul_vec_sparse_mat(r[i - 1], ta)\n    return r\n\n_, x = [int(v) for v in input().split()]\na = [[0] * N for i in range(N)]\na[0][0] = 1\na[N - 1][0] = 1\nfor i in range(1, N - 1):\n    a[i][i + 1] = 1\nfor d in map(int, input().split()):\n    a[N - 1][N - d] += 1\na = mod_pow_kitamasa(a, x)\nb = [0] * N\nb[0] = 1\nb[N - 1] = 1\nprint(sum(a[N - 1][i] * b[i] % MOD for i in range(N)) % MOD)"]
["from operator  import mul\nfrom functools import reduce\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6\nfact    = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv     = [0, 1]\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\n#kari1 = '2 3 1 1'                   #2\n#kari1 = '10 7 3 4'                  #3570\n#kari1 = '100000 100000 99999 99999' #1\n#kari1 = '100000 100000 44444 55555' #738162020\n\n\"\"\"\nin1 = kari1.split()\n\"\"\"\nin1 = input().split()\n\nH = int(in1[0])\nW = int(in1[1])\nA = int(in1[2])\nB = int(in1[3])\n\nallCNT = 0\nfor idx1 in range(W - B):\n    beforeCNT = cmb(H - A + B - 1 + idx1, H - A - 1, p)\n    afterCNT  = cmb(W + A - B - 2 - idx1, A - 1, p)\n    allCNT    = (allCNT + (beforeCNT * afterCNT) % p) % p\n\nprint(allCNT)\n", "h, w, a, b = map(int, input().split())\n\ndef cmb1(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor i in range(b, w):\n    ans += cmb1(i+h-1-a, i, mod)*cmb1(w-1-i+a-1, a-1, mod)\n    ans %= mod\nprint(ans)", "H,W,A,B = list(map(int,input().split()))\n\n\nclass Combination:\n    \"\"\"\n  O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n  n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n  \u4f7f\u7528\u4f8b\uff1a\n  comb = Combination(1000000)\n  print(comb(5, 3))  # 10\n  \"\"\"\n\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod\n        return modinv\n\ncomb = Combination(1000000)\nMOD = 10**9+7\nans = 0\nfor i in range(B,W):\n    ans += comb(H-A-1+i,i)*comb(A-1+W-1-i,A-1)\n    ans %= MOD\n    #print(comb(H-A-1+i,i)*comb(A-1+W-1-i,A-1))\nprint(ans)\n\n\n", "H, W, A, B = map(int, open(0).read().split())\nMOD = 10**9+7\n\nfactorials = [1] * (H + W + 1)\ninv_factorials = [1] * (H + W + 1)\n\nfor i in range(H + W):\n    factorials[i+1] = factorials[i] * (i + 1) % MOD\n\ninv_factorials = list(map(lambda n: pow(n, -1, MOD), factorials))\n\ndef modcomb(m, n, mod):\n    return factorials[m] * inv_factorials[n] % MOD * inv_factorials[m - n] % MOD\n \ntotal = modcomb(H + W - 2, W - 1, MOD)\n \nfor i in range(B):\n    total -= modcomb(H - A - 1 + i, i, MOD) * modcomb(A - 1 + W - 1 - i, W - 1 - i, MOD) % MOD\n    total %= MOD\n \nprint(total)", "H, W, A, B = map(int, input().split())\nmod = 10**9+7\n\nF = [1]*200010\np = 1\nfor i in range(1, len(F)):\n  F[i] = p = p*i%mod\n\ndef comb(n, k):\n  return F[n]*pow(F[n-k], mod-2, mod)*pow(F[k], mod-2, mod)%mod\n\nans = 0\nfor h in range(H-A):\n  x = comb(B-1+h, h) # \u53f3\u306bB-1\u56de\u3001\u4e0b\u306bh\u56de\u79fb\u52d5\u3059\u308b\u65b9\u6cd5\u306e\u6570\n  y = comb(W+H-B-h-2, H-h-1) # \u53f3\u306bW-B-1\u56de\u3001\u4e0b\u306bH-h-1\u56de\u79fb\u52d5\u3059\u308b\u65b9\u6cd5\u306e\u6570\n  ans += x*y\n  ans %= mod\nprint(ans)", "import sys\n\ndef comb(n, r, fact, revfact, mod):\n    return (fact[n] * revfact[n-r] * revfact[r]) % mod\n\ndef solve():\n    H, W, A, B = map(int, input().split())\n    mod = 7 + 10 ** 9\n    fact = [1] * (H + W + 4)\n    revfact = [1] * (H + W + 4)\n    for i in range(1, H + W + 4): fact[i] = (i * fact[i-1]) % mod\n    revfact[H + W + 3] = pow(fact[H + W + 3], mod - 2, mod)\n    for i in reversed(range(1, H + W + 3)): revfact[i] = ((i + 1) * revfact[i + 1]) % mod\n\n    ans = 0\n    for j in range(B + 1, W + 1):\n        up = comb(H - A + j - 2, j - 1, fact, revfact, mod)\n        down = comb(A + W - j - 1, A - 1, fact, revfact, mod)\n        ans += (up * down) % mod\n        ans %= mod\n    print(ans)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\ndef main():\n    H,W,A,B = map(int,input().split())\n    MAXN = H + W + 3\n    factorial = [1]\n    for i in range(1,MAXN + 1):\n        factorial.append(factorial[-1]*i%MOD)\n    inv_factorial = [-1] * (MAXN + 1)\n    inv_factorial[-1] = pow(factorial[-1],MOD - 2,MOD)\n    for i in range(MAXN - 1,-1,-1):\n        inv_factorial[i] = inv_factorial[i + 1]*(i + 1)%MOD\n    \n    fact = lambda N:factorial[N]\n    nck = lambda N,K: 0 if K > N or K < 0 else factorial[N]*inv_factorial[N - K]*inv_factorial[K]%MOD\n    dist = lambda sy,sx,gy,gx: nck(gy - sy + gx - sx,gy - sy)\n    ans = 0\n    if H - A < W - B:\n        H,W = W,H\n        A,B = B,A\n    \n    for i in range(W - B):\n        x = B + i + 1\n        y = H - A - i\n        ans += dist(1,1,y,x)*dist(y,x,H,W)%MOD\n        ans %= MOD\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "H,W,A,B=map(int,input().split())\nMAX_NUM = 2*10**5 + 1\npr = 10**9+7\nfac  = [0 for _ in range(MAX_NUM)]\nfinv = [0 for _ in range(MAX_NUM)]\ninv  = [0 for _ in range(MAX_NUM)]\nfac[0]  = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\nfor i in range(2,MAX_NUM):\n    fac[i] = fac[i-1] * i % pr\n    inv[i] = pr - inv[pr%i] * (pr // i) % pr\n    finv[i] = finv[i-1] * inv[i] % pr\ndef c(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % pr) % pr\na=0\nwhile 1:\n    a=(a+c(H-A-1+B,B)*c(A+W-B-1,A))%pr\n    A+=1\n    B+=1\n    if A==H or B==W:\n        break\nprint(a)", "# Combination\nMOD = 10**9+7\nMAX = 2*10**5\nfac = [1,1] + [0]*MAX\nfinv = [1,1] + [0]*MAX\ninv = [0,1] + [0]*MAX\nfor i in range(2,MAX+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nH, W, A, B = list(map(int, input().split()))\nans = 0\nfor i in range(1, H-A+1):\n    cnt = comb(i-1+B-1, i-1)\n    #print(i, cnt)\n    cnt *= comb(H-i+W-B-1, H-i)\n    ans += cnt\n    ans %= MOD\nprint(ans)\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\nINF = float(\"inf\")\n\nMOD = 1000000007  # type: int\n\n\nclass Combination(object):\n\n    def __init__(self, N, mod=MOD):\n        fac, finv, inv = [0]*(N+1), [0]*(N+1), [0]*(N+1)\n        fac[:2] = 1, 1\n        finv[:2] = 1, 1\n        inv[1] = 1\n        for i in range(2, N+1):\n            fac[i] = fac[i-1]*i % mod\n            inv[i] = -inv[mod % i]*(mod//i) % mod\n            finv[i] = finv[i-1]*inv[i] % mod\n        self.N = N\n        self.MOD = mod\n        self.fac = fac\n        self.finv = finv\n        self.inv = inv\n\n    def __call__(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        fac = self.fac\n        finv = self.finv\n        mod = self.MOD\n        return fac[n] * (finv[k]*finv[n-k] % mod) % mod\n\n\ndef solve(H: int, W: int, A: int, B: int):\n\n    cmb = Combination(H+W+1, MOD)\n\n    ans = 0\n    for i in range(B, W):\n        buf = cmb(H-A-1+i, i)\n        buf *= cmb(A+W-i-2, W-i-1)\n        buf %= MOD\n        ans += buf\n        ans %= MOD\n    print(ans)\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    H = int(next(tokens))  # type: int\n    W = int(next(tokens))  # type: int\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    solve(H, W, A, B)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\nfrom heapq import heappush, heappop \nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\nfrom collections import deque, Counter, defaultdict\nfrom itertools import combinations, product\nimport string \ninf = float('inf')\nMOD = 10**9+7\n# MOD = 998244353\n\n\nclass NumberTheory():\n  def __init__(self, n=2*10**6, numpy=True):\n    self.n = n\n    self.np_flg = numpy \n    self.is_prime_number, self.prime_numbers = self.sieve_of_eratosthenes(n)\n  \n  def sieve_of_eratosthenes(self, n):\n    if self.np_flg:\n      sieve = np.ones(n+1, dtype=np.int64); sieve[:2] = 0\n      for i in range(2, int(n**.5)+1):\n        if sieve[i]: sieve[i*2::i] = 0\n      prime_numbers = np.flatnonzero(sieve)\n    else:\n      sieve = [1] * (n+1); sieve[0] = sieve[1] = 0\n      for i in range(2, int(n**.5)+1):\n        if not sieve[i]: continue\n        for j in range(i*2, n+1, i): sieve[j] = 0\n      prime_numbers = [i for i in range(2, n+1) if sieve[i]]\n    return sieve, prime_numbers \n\n  def prime_factorize(self, n):\n    res = dict()\n    if n < 2: return res\n    border = int(n**.5)\n    for p in self.prime_numbers:\n      if p > border: break\n      while n % p == 0: res[p] = res.get(p, 0)+1; n //= p\n      if n == 1: return res\n    res[n] = 1; return res\n\n  def prime_factorize_factorial(self, n):\n    res = dict()\n    for i in range(2, n+1):\n      for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c\n    return res\n  \n  @staticmethod\n  def gcd(a, b): return gcd(b, a%b) if b else abs(a)\n\n  @staticmethod\n  def lcm(a, b): return abs(a // gcd(a, b) * b)\n\n  @staticmethod\n  def find_divisors(n):\n    divisors = []\n    for i in range(1, int(n**.5)+1):\n      if n%i: continue\n      divisors.append(i)\n      j = n // i\n      if j != i: divisors.append(j)\n    return divisors\n  \n  @staticmethod\n  def base_convert(n, b):\n    if not n: return [0]\n    res = []\n    while n:\n      n, r = divmod(n, b)\n      if r < 0: n += 1; r -= b\n      res.append(r)\n    return res\n\n\nclass UnionFind():\n  def __init__(self, n=10**6):\n    self.root = list(range(n))\n    self.height = [0] * n \n    self.size = [1] * n \n  \n  def find_root(self, u):\n    if self.root[u] == u: return u\n    self.root[u] = self.find_root(self.root[u])\n    return self.root[u]\n  \n  def unite(self, u, v):\n    ru = self.find_root(u)\n    rv = self.find_root(v)\n    if ru == rv: return \n    hu = self.height[ru]\n    hv = self.height[rv]\n    if hu >= hv:\n      self.root[rv] = ru \n      self.size[ru] += self.size[rv]\n      self.height[ru] = max(hu, hv+1)\n    else:\n      self.root[ru] = rv \n      self.size[rv] += self.size[ru]\n\n\nclass Combinatorics():\n  def __init__(self, N=10**9, n=10**6, mod=10**9+7, numpy=True):\n    self.mod = mod\n    self.nCr = dict()\n    self.np_flg=numpy\n    self.make_mod_tables(N, n)\n\n  sys.setrecursionlimit(10**6)\n  def choose(self, n, r, mod=None): # no mod, or mod \u2260 prime\n    if r > n or r < 0: return 0\n    if r == 0: return 1\n    if (n, r) in self.nCr: return self.nCr[(n, r)]\n    if not mod:\n      self.nCr[(n, r)] = (self.choose(n-1, r) + self.choose(n-1, r-1))\n    else:\n      self.nCr[(n, r)] = (self.choose(n-1, r, mod) + self.choose(n-1, r-1, mod)) % mod\n    return self.nCr[(n,r)]\n  \n  def cumprod(self, a):\n    p = self.mod\n    l = len(a); sql = int(np.sqrt(l)+1)\n    a = np.resize(a, sql**2).reshape(sql, sql)\n    for i in range(sql-1): a[:, i+1] *= a[:, i]; a[:, i+1] %= p\n    for i in range(sql-1): a[i+1] *= a[i, -1]; a[i+1] %= p\n    return np.ravel(a)[:l]\n\n  def make_mod_tables(self, N, n):\n    p = self.mod\n    if self.np_flg:\n      fac = np.arange(n+1); fac[0] = 1; fac = self.cumprod(fac)\n      ifac = np.arange(n+1, 0, -1); ifac[0] = pow(int(fac[-1]), p-2, p)\n      ifac = self.cumprod(ifac)[n::-1]\n      n_choose = np.arange(N+1, N-n, -1); n_choose[0] = 1;\n      n_choose[1:] = self.cumprod(n_choose[1:])*ifac[1:n+1]%p\n    else:\n      fac = [None]*(n+1); fac[0] = 1\n      for i in range(n): fac[i+1] = fac[i]*(i+1)%p\n      ifac = [None]*(n+1); ifac[n] = pow(fac[n], p-2, p)\n      for i in range(n, 0, -1): ifac[i-1] = ifac[i]*i%p\n      n_choose = [None] * (n+1); n_choose[0] = 1\n      for i in range(n): n_choose[i+1] = n_choose[i]*(N-i)%p\n      for i in range(n+1): n_choose[i] = n_choose[i]*ifac[i]%p\n    self.fac, self.ifac, self.mod_n_choose = fac, ifac, n_choose\n  \n  def mod_choose(self, n, r):\n    return self.fac[n]*self.ifac[r]%self.mod*self.ifac[n-r]%self.mod\n\n\ndef z_algorithm(s):\n  n = len(s)\n  a = [0] * n; a[0] = n\n  l = r = -1\n  for i in range(1, n):\n    if r >= i: a[i] = min(a[i-l], r-i)\n    while i + a[i] < n and s[i+a[i]] == s[a[i]]: a[i] += 1\n    if i+a[i] >= r: l, r = i, i+a[i]\n  return a\n\n\nclass ABC001():\n  def A():\n    h1, h2 = map(int, sys.stdin.read().split())\n    print(h1-h2)\n\n  def B(): pass\n  def C(): pass \n  def D(): pass \n\n\nclass ABC002():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(max(x, y))\n\n  def B():\n    vowels = set('aeiou')\n    s = sys.stdin.readline().rstrip() \n    t = ''\n    for c in s:\n      if c in vowels: continue \n      t += c \n    print(t)\n\n  def C():\n    *coords, = map(int, sys.stdin.readline().split())\n    def triangle_area(x0, y0, x1, y1, x2, y2):\n      x1 -= x0; x2 -= x0; y1 -= y0; y2 -= y0;\n      return abs(x1*y2 - x2*y1) / 2\n    print(triangle_area(*coords))\n\n  def D():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = set()\n    for _ in range(m):\n      x, y = map(int, sys.stdin.readline().split())\n      x -= 1; y -= 1\n      edges.add((x, y))\n    cand = []\n    for i in range(1, 1<<n):\n      s = [j for j in range(n) if i>>j & 1]\n      for x, y in combinations(s, 2):\n        if (x, y) not in edges: break\n      else:\n        cand.append(len(s))\n    print(max(cand))\n\n\nclass ABC003():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)*5000)\n\n  def B():\n    atcoder = set('atcoder')\n    s, t = sys.stdin.read().split()\n    for i in range(len(s)):\n      if s[i] == t[i]: continue\n      if s[i] == '@' and t[i] in atcoder: continue \n      if t[i] == '@' and s[i] in atcoder: continue\n      print('You will lose')\n      return \n    print('You can win')\n\n  def C():\n    n, k, *r = map(int, sys.stdin.read().split())\n    res = 0\n    for x in sorted(r)[-k:]:\n      res = (res+x) / 2\n    print(res)\n\n  def D(): pass \n\n\nclass ABC004():\n  def A():\n    print(int(sys.stdin.readline().rstrip())*2)\n\n  def B():\n    c = [sys.stdin.readline().rstrip() for _ in range(4)]\n    for l in c[::-1]:\n      print(l[::-1])\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n %= 30\n    res = list(range(1, 7))\n    for i in range(n):\n      i %= 5\n      res[i], res[i+1] = res[i+1], res[i]\n    print(''.join(map(str, res)))\n\n  def D(): pass \n\n\nclass ABC005():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(y//x)\n\n  def B():\n    n, *t = map(int, sys.stdin.read().split())\n    print(min(t))\n\n  def C():\n    t = int(sys.stdin.readline().rstrip())\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    m = int(sys.stdin.readline().rstrip())\n    b = [int(x) for x in sys.stdin.readline().split()]\n    i = 0\n    for p in b:\n      if i == n: print('no'); return \n      while p-a[i] > t:\n        i += 1\n        if i == n: print('no'); return \n      if a[i] > p: print('no'); return \n      i += 1\n    print('yes')\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    d = np.array([sys.stdin.readline().split() for _ in range(n)], np.int64)\n    s = d.cumsum(axis=0).cumsum(axis=1)\n    s = np.pad(s, 1)\n    max_del = np.zeros((n+1, n+1), dtype=np.int64)\n    for y in range(1, n+1):\n      for x in range(1, n+1):\n        max_del[y, x] = np.amax(s[y:n+1, x:n+1] - s[0:n-y+1, x:n+1] - s[y:n+1, 0:n-x+1] + s[0:n-y+1, 0:n-x+1])\n    res = np.arange(n**2+1)[:, None]\n    i = np.arange(1, n+1)\n    res = max_del[i, np.minimum(res//i, n)].max(axis=1)\n    q = int(sys.stdin.readline().rstrip())\n    p = np.array(sys.stdin.read().split(), dtype=np.int64)\n    print(*res[p], sep='\\n')\n\n\nclass ABC006():\n  def A():\n    n = sys.stdin.readline().rstrip()\n    if '3' in n: print('YES')\n    elif int(n)%3 == 0: print('YES')\n    else: print('NO')\n\n  def B():\n    mod = 10007\n    t = [0, 0, 1]\n    for _ in range(1001001):\n      t.append(t[-1]+t[-2]+t[-3]); t[-1] %= mod\n    n = int(sys.stdin.readline().rstrip())\n    print(t[n-1])\n    \n  def C():\n    n, m = map(int, sys.stdin.readline().split())\n    cnt = [0, 0, 0]\n    if m == 1: cnt = [-1, -1, -1]\n    else:\n      if m & 1: m -= 3; cnt[1] += 1; n -= 1\n      cnt[2] = m//2 - n \n      cnt[0] = n - cnt[2]\n    if cnt[0]<0 or cnt[1]<0 or cnt[2]<0: print(-1, -1, -1)\n    else: print(*cnt, sep=' ')\n      \n  def D():\n    n, *c = map(int, sys.stdin.read().split())\n    lis = [inf]*n \n    for x in c: lis[bi_l(lis, x)] = x \n    print(n - bi_l(lis, inf))\n\n\nclass ABC007():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n-1)\n\n  def B():\n    s = sys.stdin.readline().rstrip()\n    if s == 'a': print(-1)\n    else: print('a')\n\n  def C():\n    r, c = map(int, sys.stdin.readline().split())\n    sy, sx = map(int, sys.stdin.readline().split())\n    gy, gx = map(int, sys.stdin.readline().split())\n    sy -= 1; sx -=1; gy -= 1; gx -= 1\n    maze = [sys.stdin.readline().rstrip() for _ in range(r)]\n    queue = deque([(sy, sx)])\n    dist = np.full((r, c), np.inf); dist[sy, sx] = 0\n    while queue:\n      y, x = queue.popleft()\n      for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        i += y; j += x\n        if maze[i][j] == '#' or dist[i, j] != np.inf: continue \n        dist[i, j] = dist[y, x] + 1\n        queue.append((i, j))\n    print(int(dist[gy, gx]))\n  \n  def D(): pass \n\n\nclass ABC008():\n  def A():\n    s, t = map(int, sys.stdin.readline().split())\n    print(t-s+1)\n\n  def B():\n    n, *s = sys.stdin.read().split()\n    res = defaultdict(int)\n    for name in s: res[name] += 1\n    print(sorted(res.items(), key=lambda x: x[1])[-1][0])\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    a = np.array(a)\n    c = n - np.count_nonzero(a[:, None]%a, axis=1)\n    print(np.sum((c+1)//2/c))\n  \n  def D(): pass\n\nclass ABC009():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)//2)\n\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    print(sorted(set(a))[-2])\n    \n  def C():\n    n, k = map(int, sys.stdin.readline().split())\n    s = list(sys.stdin.readline().rstrip())\n    cost = [1]*n\n    r = k\n    for i in range(n-1):\n      q = []\n      for j in range(i+1, n):\n        if s[j] < s[i] and cost[i]+cost[j] <= r:\n          heappush(q, (s[j], cost[i]+cost[j], -j))\n      if not q: continue\n      _, c, j = heappop(q); j = -j \n      s[i], s[j] = s[j], s[i]\n      r -= c \n      cost[i] = cost[j] = 0\n    print(''.join(s))\n      \n  def D(): pass \n\n\nclass ABC010():\n  def A():\n    print(sys.stdin.readline().rstrip()+'pp')\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    tot = 0\n    for x in a:\n      c = 0 \n      while x%2==0 or x%3==2:\n        x -= 1\n        c += 1\n      tot += c\n    print(tot)\n\n  def C():\n    sx, sy, gx, gy, t, v, n, *xy = map(int, sys.stdin.read().split())\n    x, y = np.array(xy).reshape(-1, 2).T\n    def dist(x1, y1, x2, y2):\n      return np.sqrt((x2-x1)**2 + (y2-y1)**2)\n    ans = 'YES' if (dist(sx, sy, x, y)+dist(x, y, gx, gy) <= v*t).any() else 'NO'\n    print(ans)\n\n  def D(): pass \n\nclass ABC011():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n%12+1)\n\n  def B():\n    s = sys.stdin.readline().rstrip() \n    print(s[0].upper()+s[1:].lower())\n\n  def C():\n    n, *ng = map(int, sys.stdin.read().split())\n    ng = set(ng)\n    if n in ng: print('NO')\n    else:\n      r = 100\n      while n > 0:\n        if r == 0: print('NO'); return\n        for i in range(3, 0, -1):\n          if (n-i) in ng: continue \n          n -= i\n          r -= 1\n          break \n        else: print('NO'); return \n      print('YES')\n\n  def D(): pass \n\n\nclass ABC041():\n  def A():\n    s, i = sys.stdin.read().split()\n    i = int(i)\n    print(s[i-1])\n\n  def B():\n    a, b, c = map(int, sys.stdin.readline().split())\n    ans = a * b % MOD * c % MOD \n    print(ans)\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    for i, h in sorted(enumerate(a), key=lambda x: -x[1]):\n      print(i+1)\n\n  def D():\n    n, m, *xy = map(int, sys.stdin.read().split())\n    *xy, = zip(*[iter(xy)]*2)\n    edges = [0] * n \n    for x, y in xy:\n      x -= 1; y -= 1\n      edges[x] |= 1<<y\n    comb = [None] * (1<<n); comb[0] = 1\n    def count(edges, bit):\n      if comb[bit] is not None: return comb[bit]\n      comb[bit] = 0\n      for i in range(n):\n        if (bit>>i) & 1 and not edges[i]:\n          nxt_bit = bit & ~(1<<i)\n          nxt_edges = edges.copy() \n          for j in range(n):\n            nxt_edges[j] &= ~(1<<i)\n          cnt = count(nxt_edges, nxt_bit)\n          comb[bit] += cnt\n      return comb[bit]\n    print(count(edges, (1<<n)-1))\n\n\nclass ABC042():\n  def A():\n    a = [int(x) for x in sys.stdin.readline().split()]\n    c = Counter(a)\n    print('YES' if c[5]==2 and c[7]==1 else 'NO')\n\n  def B():\n    n, l, *s = sys.stdin.read().split()\n    print(''.join(sorted(s)))\n\n  def C():\n    n, k, *d = sys.stdin.read().split()\n    l = len(n)\n    ok = sorted(set(string.digits)-set(d))\n    cand = [int(''.join(p)) for p in product(ok, repeat=l)] + [int(min(x for x in ok if x > '0')+min(ok)*l)]\n    print(cand[bi_l(cand, int(n))])\n\n  def D(): pass \n  h, w, a, b = map(int, sys.stdin.read().split())\n  combinatorics = Combinatorics(mod=MOD)\n  tot = combinatorics.mod_choose(h+w-2, h-1)\n  for i in range(h-a, h):\n    tot -= combinatorics.mod_choose(i+b-1, i) * combinatorics.mod_choose(h-i+w-b-2, h-1-i)\n    tot %= MOD \n  print(tot)\n  \n\n\n\n\n\n\n\n\nclass ABC170():\n  def A():\n    x = [int(x) for x in sys.stdin.readline().split()]\n    for i in range(5):\n      if x[i] != i+1:\n        print(i+1)\n        break\n\n  def B():\n    x, y = map(int, sys.stdin.readline().split())\n    print('Yes' if 2*x <= y <= 4*x and y%2 == 0 else 'No')\n      \n  def C():\n    x, n, *p = map(int, sys.stdin.read().split())\n    a = list(set(range(102)) - set(p))\n    a = [(abs(y-x), y) for y in a]\n    print(sorted(a)[0][1])\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    cand = set(a)\n    cnt = 0\n    for x, c in sorted(Counter(a).items()):\n      cnt += c == 1 and x in cand\n      cand -= set(range(x*2, 10**6+1, x))\n    print(cnt)\n\n  def E():\n    n, q = map(int, sys.stdin.readline().split())\n    queue = [] \n    num_kindergarten = 2*10**5\n    queue_kindergarten = [[] for _ in range(num_kindergarten)]\n    highest_kindergarten = [None] * num_kindergarten\n    where = [None] * n\n    rate = [None] * n\n\n    def entry(i, k):\n      where[i] = k\n      while queue_kindergarten[k]:\n        r, j = heappop(queue_kindergarten[k])\n        if where[j] != k or j == i: continue \n        if rate[i] >= -r:\n          highest_kindergarten[k] = rate[i]\n          heappush(queue, (rate[i], k, i))\n        heappush(queue_kindergarten[k], (r, j))\n        break\n      else:\n        highest_kindergarten[k] = rate[i]\n        heappush(queue, (rate[i], k, i))\n      heappush(queue_kindergarten[k], (-rate[i], i))\n\n    def transfer(i, k):\n      now = where[i]\n      while queue_kindergarten[now]:\n        r, j = heappop(queue_kindergarten[now])\n        if where[j] != now or j == i: continue\n        if highest_kindergarten[now] != -r:\n          highest_kindergarten[now] = -r\n          heappush(queue, (-r, now, j))\n        heappush(queue_kindergarten[now], (r, j))\n        break\n      else:\n        highest_kindergarten[now] = None\n      entry(i, k)\n\n    def inquire():\n      while True:\n        r, k, i = heappop(queue)\n        if where[i] != k or r != highest_kindergarten[k]: continue \n        heappush(queue, (r, k, i))\n        return r\n\n    for i in range(n):\n      a, b = map(int, sys.stdin.readline().split())\n      rate[i] = a \n      entry(i, b-1)\n    for _ in range(q):\n      c, d = map(int, sys.stdin.readline().split())\n      transfer(c-1, d-1)\n      print(inquire())\n    \n  def F(): pass \n\n\nclass ABC171():\n  def A():\n    c = sys.stdin.readline().rstrip()\n    print('A' if c < 'a' else 'a')\n\n  def B():\n    n, k, *p = map(int, sys.stdin.read().split())\n    print(sum(sorted(p)[:k]))\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n -= 1\n    l = 1\n    while True:\n      if n < pow(26, l):\n        break \n      n -= pow(26, l)\n      l += 1\n    res = ''.join([chr(ord('a')+d%26) for d in NumberTheory.base_convert(n, 26)][::-1])\n    res = 'a'*(l-len(res)) + res\n    print(res)\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    s = sum(a)\n    cnt = Counter(a)\n    q = int(sys.stdin.readline().rstrip())\n    for _ in range(q):\n      b, c = map(int, sys.stdin.readline().split())\n      s += (c-b)*cnt[b]\n      print(s)\n      cnt[c] += cnt[b]; cnt[b] = 0\n\n  def E():\n    n, *a = map(int, sys.stdin.read().split())\n    s = 0\n    for x in a: s ^= x \n    b = map(lambda x: x^s, a)\n    print(*b, sep=' ')\n\n  def F(): pass \n\n\nclass ABC172():\n  def A(): pass\n  def B(): pass\n  def C(): pass \n  def D(): pass \n  def E(): pass \n  def F(): pass \n\n\nclass ABC173():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    charge = (n+999)//1000 * 1000 - n\n    print(charge)\n\n  def B():\n    n, *s = sys.stdin.read().split() \n    c = Counter(s)\n    for v in 'AC, WA, TLE, RE'.split(', '):\n      print(f'{v} x {c[v]}')\n\n  def C():\n    h, w, k = map(int, sys.stdin.readline().split())\n    c = [sys.stdin.readline().rstrip() for _ in range(h)]\n    tot = 0\n    for i in range(1<<h):\n      for j in range(1<<w):\n        cnt = 0\n        for y in range(h):\n          for x in range(w):\n            if i>>y & 1 or j>>x & 1:\n              continue \n            cnt += c[y][x] ==  '#'\n        tot += cnt == k\n    print(tot)\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    a.sort(reverse=True)\n    res = a[0] + sum(a[1:1+(n-2)//2])*2 + a[1+(n-2)//2]*(n & 1)\n    print(res)\n\n  def E():\n    MOD = 10**9+7\n    n, k, *a = map(int, sys.stdin.read().split())\n    minus = [x for x in a if x < 0]\n    plus = [x for x in a if x > 0]\n    if len(plus) + len(minus)//2*2 >= k: # plus \n      *minus, = map(abs, minus)\n      minus.sort(reverse=True)\n      plus.sort(reverse=True)\n      cand = []\n      if len(minus)&1: minus = minus[:-1]\n      for i in range(0, len(minus)-1, 2):\n        cand.append(minus[i]*minus[i+1]%MOD)\n      if k & 1:\n        res = plus[0]\n        plus = plus[1:]\n      else:\n        res = 1\n      if len(plus)&1: plus = plus[:-1]\n      for i in range(0, len(plus)-1, 2):\n        cand.append(plus[i]*plus[i+1]%MOD)\n      cand.sort(reverse=True)\n      for x in cand[:k//2]:\n        res *= x\n        res %= MOD \n      print(res)\n    elif 0 in a:\n      print(0)\n    else:\n      cand = sorted(map(abs, a))\n      res = 1\n      for i in range(k):\n        res *= cand[i]\n        res %= MOD\n      res = MOD - res\n      print(res)\n      pass\n  \n  def F(): pass \n\n\ndef __starting_point():\n  ABC042.D()\n__starting_point()", "h, w, a, b = map(int, input().split())\n\nn = 2 * 10 ** 5\nk = 2 * 10 ** 5\nmod = 10**9 + 7\n\nmodinv_table = [-1] * (k+1)\nmodinv_table[1] = 1\nfor i in range(2, k+1):\n    modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\ndef prepare_binomial_coefficients(n, k):\n    for i in range(1,n+1):\n        bc_num[i] = i * bc_num[i-1] % mod\n    bc_num[0] = 0\n    for i in range(1,k+1):\n        bc_den[i] = modinv_table[i] * bc_den[i-1] % mod\n    return\n\ndef binomial_coefficients(n, k):\n    if n == 0 and k == 0:\n        return 1\n    return bc_num[n] * bc_den[k] * bc_den[n-k] % mod\n\nbc_num = [1]*(n+1)\nbc_den = [1]*(n+1)\nprepare_binomial_coefficients(n, n)\n\nmids = [0]*(w-b)\ndis_mid = h - a - 1\nfor i in range(w-b):\n    mids[i] = binomial_coefficients(dis_mid+i+b,i+b)\n\n#print(mids)\n\nmids_down = [0]*(w-b)\ndis_mid = a\nfor i in range(w-b):\n    mids_down[i] = binomial_coefficients(dis_mid+w-b-i-1,w-b-i-1)\n\n#print(mids_down)\n\nfor i in range(w-b-1):\n    mids_down[i] -= mids_down[i+1]\n\n#print(mids_down)\n\nfor i in range(w-b):\n    mids[i] = (mids[i] * mids_down[i]) % mod\n\n#print(mids)\n\nprint(sum(mids)%mod)", "\n# -*- coding: UTF-8 -*-\n\nimport sys\n\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n\ndef mul(x, y, mod):\n    x %= mod\n    y %= mod\n    return x * y % mod\n\n\ndef div(x, y, mod):\n    x %= mod\n    y %= mod\n    return x * mod_pow(y, mod - 2, mod) % mod\n\n\ndef mod_pow(a, p, mod):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        root = mod_pow(a, p / 2, mod)\n        return root * root % mod\n    else:\n        return a * mod_pow(a, p - 1, mod) % mod\n\n\ndef pre_factorial_divs(n, mod, factorials):\n    factorial_divs = [0] * (n + 1)\n\n    factorial_divs[n] = div(1, factorials, mod)\n    for i in reversed(list(range(n))):\n        factorial_divs[i] = mul(factorial_divs[i+1], i+1, mod)\n    return factorial_divs\n\n\ndef pre_factorials(n, mod):\n    factorials = [0] * (n + 1)\n    factorials[0] = 1\n    for i in range(n):\n        factorials[i + 1] = (i + 1) * factorials[i] % mod\n    return factorials\n\n\ndef fast_fast_fermat_comb(a, b, mod, factorials, factorial_divs):\n    if len(factorials) == 0:\n        raise\n    af = factorials[a]\n    bf = factorial_divs[b]\n    abf = factorial_divs[a - b]\n    return mul(mul(af, bf, mod), abf, mod)\n\n\ndef main():\n    h, w, a, b = get_ints()\n\n    ans = 0\n    mod = 10 ** 9 + 7\n\n    factorials = pre_factorials(h+w-2, mod)\n    factorial_divs = pre_factorial_divs(h+w-2, mod, factorials[h+w-2])\n\n    for i in range(h-a):\n        x = fast_fast_fermat_comb(b-1+i, b-1, mod, factorials, factorial_divs)\n        y = fast_fast_fermat_comb(h+w-3-(b-1+i), w-b-1, mod, factorials, factorial_divs)\n        ans += x * y % mod\n        ans %= mod\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, A, B = list(map(int,input().split()))\nmod = 10**9+7\nC = [1,1]\ninv = [0,1]\nCinv = [1,1]\nfor i in range(2,H+W+1):\n    C.append((C[-1]*i)%mod)\n    inv.append((-inv[mod%i]*(mod//i)%mod))\n    Cinv.append(Cinv[-1]*inv[-1]%mod)\nans = 0\nfor i in range(H-A):\n    a = (C[i+B-1]*C[H-1-i+W-B-1])%mod\n    a = (a*Cinv[B-1])%mod\n    a = (a*Cinv[i])%mod\n    a = (a*Cinv[W-B-1])%mod\n    a = (a*Cinv[H-i-1])%mod\n    ans += a\n    ans %= mod\nprint(ans)\n", "def ext_euclid(a, b):\n    # return (x, y, gcd(a, b)) such that a * x + b * y = gcd(a, b)\n    if b == 0:\n        return 1, 0, a\n    y, x, v = ext_euclid(b, a % b)\n    y -= (a // b) * x\n    return x, y, v\n\n\ndef mod_inv(a, mod):\n    x, _, _ = ext_euclid(a, mod)\n    return x % mod\n\n\ndef comb_list_1(H, W, A, B, mod, modinv_list):\n    # (h+B-1)_C_(B-1)  (h in {0, ..., H-A-1})\n    ret = [0 for _ in range(H - A)]\n    c = 1\n    for h in range(H - A):\n        ret[h] = c\n        c *= h + B\n        c *= modinv_list[h + 1]\n        c %= mod\n    return ret\n\n\ndef comb_list_2(H, W, A, B, mod, modinv_list):\n    # (-h+H+W-B-2)_C_(W-B-1)  (h in {0, ..., H-A-1})\n    ret = [0 for _ in range(H - A)]\n    # initial value -> (A+W-B-1)_C_(W-B-1)  (h = H-A-1)\n    c = 1\n    for a in range(1, A + 1):\n        c *= (a + W - B - 1)\n        c *= modinv_list[a]\n        c %= mod\n    # fill elements of result list from the back\n    for h in range(H - A - 1, -1, -1):\n        ret[h] = c\n        c *= H - h + W - B - 1\n        c *= modinv_list[H - h]\n        c %= mod\n    return ret\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    H, W, A, B = list(map(int, input().split(' ')))\n    modinv_list = [None] + [mod_inv(h, MOD) for h in range(1, H + 1)]  # modinv doesn't exist on h = 0\n    combs_1 = comb_list_1(H, W, A, B, MOD, modinv_list)\n    combs_2 = comb_list_2(H, W, A, B, MOD, modinv_list)\n    ans = 0\n    for c1, c2 in zip(combs_1, combs_2):\n        ans += c1 * c2\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ndef comb(n, r, mod=None):\n    if r == 0 or r == n:\n        return 1\n    r = min([r, n-r])\n    x, y = 1, 1\n    ans = 1\n    for i in range(1, r+1):\n        if mod:\n            x *= n+1-i\n            y *= i\n            x %= mod\n            y %= mod\n        else:\n            ans *= n+1-i\n            ans //= i\n    ans = x*pow(y, mod-2, mod)%mod if mod else ans\n    return ans\n\ndef main():\n    input = sys.stdin.readline\n    h, w, a, b = map(int, input().split())\n    mod = pow(10, 9)+7\n    \n    bef, aft = 1, comb(h+w-b-2, h-1, mod)\n    ans = 0\n    for i in range(h-a):\n        ans += bef*aft\n        ans %= mod\n        \n        bef = bef*(i+b)*pow(i+1, mod-2, mod)%mod\n        aft = aft*(h-i-1)*pow(h-i+w-b-2, mod-2, mod)%mod\n        \n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "mod = 10 ** 9 + 7\nh, w, a, b = map(int, input().split())\ndef comb(n, r):\n    if n < r:return 0\n    if n < 0 or r < 0:return 0\n    return fa[n] * fi[r] % mod * fi[n - r] % mod\nfa = [1] * (h + w + 1)\nfi = [1] * (h + w + 1)\nfor i in range(1, h + w + 1):\n    fa[i] = fa[i - 1] * i % mod\n    fi[i] = pow(fa[i], mod - 2, mod)\nans = 0\nfor i in range(h - a):\n    ans += comb(b + i - 1, b - 1) * comb(h + w - b - i - 2, w - b - 1)\n    ans %= mod\nprint(ans % mod)", "class Factorial:\n    def __init__(self, n, mod=10**9+7):\n        self.fac = [0] * (n+1)\n        self.ifac = [0] * (n+1)\n        self.fac[0] = 1\n        self.ifac[0] = 1\n        self.mod = mod\n        modmod = self.mod - 2\n        for i in range(n):\n            self.fac[i+1] = self.fac[i] * (i+1) % self.mod\n            self.ifac[i+1] = self.ifac[i] * pow(i+1, modmod, self.mod) % self.mod\n\n    def comb(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        tmp =  self.ifac[n-r] * self.ifac[r] % self.mod\n        return tmp * self.fac[n] % self.mod\n\n    def perm(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        return (self.fac[n] * self.ifac[n-r]) % self.mod\n\nh,w,a,b = list(map(int, input().split()))\nmod = 10**9+7\nfact = Factorial(h+w+1)\nans = 0\nc,d = h-a, w-b\nfor i in range(b+1, w+1):\n    d = w-i+1\n#     print(i,i+c-2, c-1, fact.comb(i+c-2, c-1),  fact.comb(a+d-2, a-1))\n    ans = (ans + fact.comb(i+c-2, c-1) * fact.comb(a+d-2, a-1)) % mod\n\nprint(ans)\n", "H, W, A, B = map(int, input().split())\nmod = int(1e9) + 7\ndef inved(a):\n  x, y, u, v, k, l = 1, 0, 0, 1, a, mod\n  while l != 0:\n    x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)\n    k, l = l, k % l\n  return x % mod\nfact = [1 for _ in range(H+W+A+B+1)]\ninvf = [1 for _ in range(H+W+A+B+1)]\nfor i in range(H+W+A+B):\n  fact[i+1] = (fact[i] * (i + 1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(H+W+A+B, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\nS = 0\nfor i in range(H-A):\n  S += (fact[i+B-1] * invf[i] * fact[H-i+W-B-2] * invf[H-1-i]) % mod\n  S %= mod\nS *= (invf[B-1] * invf[W-B-1]) % mod\nS %= mod\n\nprint(S)", "MOD=10**9+7\nUPPERLIMIT=2*(10**5)+1\nMODMUL=[1, 1]+[0]*(UPPERLIMIT-1)\nfor i in range(2, UPPERLIMIT+1):\n  MODMUL[i]=MODMUL[i-1]*i%MOD\nMODDIV=[1]*UPPERLIMIT+[pow(MODMUL[-1], MOD-2, MOD)]\nfor i in range(UPPERLIMIT, 0, -1):\n  MODDIV[i-1]=MODDIV[i]*i%MOD\n\nH, W, A, B=map(int, input().split())\n\nans=(((MODMUL[H+W-2]*MODDIV[H-1])%MOD)*MODDIV[W-1])%MOD\n\nx=[MODMUL[H-A+B+i-1]*MODDIV[B-1]*MODDIV[H-A+i]%MOD for i in range(A)]\ny=[MODMUL[W+A-B-i-1]*MODDIV[W-B]*MODDIV[A-i-1]%MOD for i in range(A)]\nfor i in range(A-1, 0, -1):\n  x[i]-=x[i-1]\n\nfor i in range(A):\n  ans-=(x[i]*y[i]%MOD)\n  ans%=MOD\n  \nprint(ans)", "import math\nimport time\n\nDIV_VALUE = 10**9 + 7\n\ndef calcModOfPow(a, n, p):\n    btm = a\n    ans = 1\n    while n != 0:\n        # print('btm: {}'.format(btm))\n        if n & 1:\n            ans = (ans * btm) % p\n            # print('ans: {}'.format(ans))\n        n = n>>1\n        btm = (btm**2) % p\n        # print(n)\n\n    return ans\n\ndef calcModOfInv(a, p):\n    b = p\n    x = 1\n    y = 0\n    while b:\n        div = a // b\n        a -= div * b\n        [a, b] = [b, a]\n        x -= div * y\n        [x, y] = [y, x]\n    \n    x %= p\n    if x < 0:\n        x += p\n\n    return x\n\nclass FirstHalf:\n    def __init__(self, H, W, A, B):\n        self.H = H\n        self.W = W\n        self.A = A\n        self.B = B\n        self.k = 0\n        self.div = 0\n        self.sup = 0\n        self.numOfCases = 1\n\n    def getNumOfCases(self):\n        if self.k != 0:\n            self.numOfCases = self.numOfCases * (\n                (self.B + self.k - 1)\n            ) * (\n                calcModOfInv(self.k, DIV_VALUE)\n            ) % DIV_VALUE\n        self.k += 1\n        # print('----- k == {} -----'.format(self.k))\n        # print(self.numOfCases)\n        # self.numOfCases %= DIV_VALUE\n        return self.numOfCases\n        # return self.numOfCases % DIV_VALUE\n\nclass SecondHalf:\n    def __init__(self, H, W, A, B):\n        self.H = H\n        self.W = W\n        self.A = A\n        self.B = B\n        self.k = 0\n        self.div = 0\n        self.numOfCases = 1\n        totalval = self.H + self.W - self.B - 2\n        loopval = self.H - 1 if self.H < self.W - self.B else self.W - self.B - 1\n        for top in range(totalval, totalval - loopval, -1):\n            self.numOfCases *= top\n            self.numOfCases %= DIV_VALUE\n        for bottom in range(loopval, 0, -1):\n            self.numOfCases *= calcModOfInv(bottom, DIV_VALUE)\n            self.numOfCases %= DIV_VALUE\n\n        # self.numOfCases = (\n        #     math.factorial(self.H + self.W - self.B - 2)\n        # ) // (\n        #     math.factorial(self.W - self.B - 1)\n        # ) // (\n        #     math.factorial(self.H - 1)\n        # )\n\n    def getNumOfCases(self):\n        if self.k != 0:\n            self.numOfCases = self.numOfCases * (\n                self.H - self.k\n            ) * (\n                calcModOfInv(\n                    self.H + self.W - self.B - self.k - 1,\n                    DIV_VALUE\n                )\n            ) % DIV_VALUE\n        self.k += 1\n        # print(self.numOfCases)\n        # self.numOfCases %= DIV_VALUE\n        return self.numOfCases\n        # return self.numOfCases % DIV_VALUE\n\ndef __starting_point():\n    [H, W, A, B] = [int(ipt) for ipt in input().split()]\n    \n    start = time.time()\n    fstHlf = FirstHalf(H, W, A, B)\n    sndHlf = SecondHalf(H, W, A, B)\n    totalCases = 0\n\n    mid = time.time()\n    # print('mid: {}'.format(mid - start))\n    for _ in range(H - A):\n        totalCases += (\n            fstHlf.getNumOfCases() * sndHlf.getNumOfCases()\n        )\n        totalCases %= DIV_VALUE\n\n    end = time.time()\n    # print('end: {}'.format(end - mid))\n    print(totalCases)\n\n    #print('{} {} {} {}'.format(H, W, A, B))\n    #print(DIV_VALUE)\n\n    # for i in range(12):\n    #     print('inv: {}'.format(calcModOfInv(i+1, 13)))\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    H, W, A, B = list(map(int, input().split()))\n    H -= 1\n    W -= 1\n    cmb = CmbMod(H + W, mod)\n    cmb.prep()\n    total = cmb.cmb_mod_with_prep(H + W, H)\n    for w in range(B):\n        tmp = (cmb.cmb_mod_with_prep(H - A + w, w) * cmb.cmb_mod_with_prep(A - 1 + W - w, A - 1)) % mod\n        total -= tmp\n        total %= mod\n    print(total)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "def cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7\nsize = 2*10**5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\n\nfor i in range( 2, size + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nH, W, A, B = map(int,input().split())\n\nans = 0\n\nfor i in range(W-B):\n    ans += cmb(H-A-1+(B+i), B+i, mod) * cmb(A-1+W-B-1-i, A-1, mod)\n    ans %= mod\n\nprint(ans)", "#coding: utf-8\nimport math\nimport heapq\nimport bisect\nimport numpy as np\nfrom collections import Counter, deque\nimport itertools\n#from scipy.misc import comb\n\nMOD = 10**9+7\nH,W,A,B = map(int,input().split())\n\ndef comb(a,b):\n\tp = fac[a-b]*fac[b]%MOD\n\treturn fac[a]*pow(p,MOD-2,MOD)%MOD\n\nfac=[1]\nfor i in range(H+W):\n\tfac.append(fac[-1]*(i+1)%MOD)\n\nans=0\nfor i in range(W-B):\n\tp = comb(H-A-1+B+i,B+i)*comb(W-B-i-2+A,A-1)\n\tans += p%MOD\n\tans %= MOD\n\nprint(ans)", "N=2*10**5+3\nmod=10**9+7\nfac=[1]*(N+1)\nfor i in range(1,N+1):\n    fac[i]=fac[i-1]*i%mod\ninv_fac=[1]*(N+1)\ninv_fac[N]=pow(fac[N],mod-2,mod)\nfor i in range(N-1,0,-1):\n    inv_fac[i]=inv_fac[i+1]*(i+1)%mod\ndef nCr(n,r):\n    if n<0 or r<0 or r>n:\n        return 0\n    return fac[n]*inv_fac[r]%mod*inv_fac[n-r]%mod\nh,w,a,b=map(int,input().split())\nans=nCr(h+w-2,h-1)\nfor i in range(b):\n    ans=(ans-nCr(h-a+i-1,i)*nCr(a+w-i-2,a-1))%mod\nprint(ans)", "h,w,a,b=map(int,input().split())\ninv=[0]*(2*max(h,w)+1)\nfact=[0]*(2*max(h,w)+1)\ninv[0]=1;fact[0]=1\nmod=10**9+7\nfor i in range(1,2*max(h,w)+1):\n    fact[i]=fact[i-1]*i%mod\ninv[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(2*max(h,w),0,-1):\n    inv[i-1]=inv[i]*i%mod\nans=0\nfor yoko in range(b+1,w+1):\n    re=fact[yoko-1+h-1-a]*inv[h-1-a]*inv[yoko-1]%mod\n    rr=fact[w-yoko+a-1]*inv[w-yoko]*inv[a-1]%mod\n    ans=(ans+re*rr%mod)%mod\nprint(ans)", "h,w,a,b=list(map(int,input().split()))\n\np=10**9+7\n#p=127\n\ndef modp_factorial(n):\n    s=1\n    for x in range(1,h+1):\n        s=(s*x) % p\n    return s\ndef modp_prod(lst):\n    s=1\n    for x in lst:\n        s=(s*x)%p\n    return s\ndef inv(n):\n    s=1\n    q=p-2\n    while q>0:\n        if q&1:\n            s=(s*n) % p\n        n=(n*n) % p\n        q>>=1\n    return s\n\nl=[1]\nf=1\nfor x in range(1,h+w):\n    f=(f*x) % p\n    l.append(f)\ninvl=[inv(l[-1])]\nfor n in range(h+w-1,1,-1):\n    invl.append((invl[-1]*n) % p)\n\ninvl.append(1)\ninvl.reverse()\n\n\ns=0\nfor x in range(1,h-a+1):\n    s=(s+modp_prod([l[x+b-2],invl[x-1],invl[b-1]\\\n        ,l[w-b+h-x-1],invl[h-x],invl[w-b-1]])) % p\nprint(s)\n", "import sys\nimport numpy as np\nfrom heapq import heappush, heappop \nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\nfrom collections import deque, Counter, defaultdict\nfrom itertools import combinations, product\nimport string \ninf = float('inf')\nMOD = 10**9+7\n# MOD = 998244353\n\n\nclass NumberTheory():\n  def __init__(self, n=2*10**6, numpy=True):\n    self.n = n\n    self.np_flg = numpy \n    self.is_prime_number, self.prime_numbers = self.sieve_of_eratosthenes(n)\n  \n  def sieve_of_eratosthenes(self, n):\n    if self.np_flg:\n      sieve = np.ones(n+1, dtype=np.int64); sieve[:2] = 0\n      for i in range(2, int(n**.5)+1):\n        if sieve[i]: sieve[i*2::i] = 0\n      prime_numbers = np.flatnonzero(sieve)\n    else:\n      sieve = [1] * (n+1); sieve[0] = sieve[1] = 0\n      for i in range(2, int(n**.5)+1):\n        if not sieve[i]: continue\n        for j in range(i*2, n+1, i): sieve[j] = 0\n      prime_numbers = [i for i in range(2, n+1) if sieve[i]]\n    return sieve, prime_numbers \n\n  def prime_factorize(self, n):\n    res = dict()\n    if n < 2: return res\n    border = int(n**.5)\n    for p in self.prime_numbers:\n      if p > border: break\n      while n % p == 0: res[p] = res.get(p, 0)+1; n //= p\n      if n == 1: return res\n    res[n] = 1; return res\n\n  def prime_factorize_factorial(self, n):\n    res = dict()\n    for i in range(2, n+1):\n      for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c\n    return res\n  \n  @staticmethod\n  def gcd(a, b): return gcd(b, a%b) if b else abs(a)\n\n  @staticmethod\n  def lcm(a, b): return abs(a // gcd(a, b) * b)\n\n  @staticmethod\n  def find_divisors(n):\n    divisors = []\n    for i in range(1, int(n**.5)+1):\n      if n%i: continue\n      divisors.append(i)\n      j = n // i\n      if j != i: divisors.append(j)\n    return divisors\n  \n  @staticmethod\n  def base_convert(n, b):\n    if not n: return [0]\n    res = []\n    while n:\n      n, r = divmod(n, b)\n      if r < 0: n += 1; r -= b\n      res.append(r)\n    return res\n\n\nclass UnionFind():\n  def __init__(self, n=10**6):\n    self.root = list(range(n))\n    self.height = [0] * n \n    self.size = [1] * n \n  \n  def find_root(self, u):\n    if self.root[u] == u: return u\n    self.root[u] = self.find_root(self.root[u])\n    return self.root[u]\n  \n  def unite(self, u, v):\n    ru = self.find_root(u)\n    rv = self.find_root(v)\n    if ru == rv: return \n    hu = self.height[ru]\n    hv = self.height[rv]\n    if hu >= hv:\n      self.root[rv] = ru \n      self.size[ru] += self.size[rv]\n      self.height[ru] = max(hu, hv+1)\n    else:\n      self.root[ru] = rv \n      self.size[rv] += self.size[ru]\n\n\nclass Combinatorics():\n  def __init__(self, N=10**9, n=10**6, mod=10**9+7, numpy=True):\n    self.mod = mod\n    self.nCr = dict()\n    self.np_flg=numpy\n    self.make_mod_tables(N, n)\n\n  sys.setrecursionlimit(10**6)\n  def choose(self, n, r, mod=None): # no mod, or mod \u2260 prime\n    if r > n or r < 0: return 0\n    if r == 0: return 1\n    if (n, r) in self.nCr: return self.nCr[(n, r)]\n    if not mod:\n      self.nCr[(n, r)] = (self.choose(n-1, r) + self.choose(n-1, r-1))\n    else:\n      self.nCr[(n, r)] = (self.choose(n-1, r, mod) + self.choose(n-1, r-1, mod)) % mod\n    return self.nCr[(n,r)]\n  \n  def cumprod(self, a):\n    p = self.mod\n    l = len(a); sql = int(np.sqrt(l)+1)\n    a = np.resize(a, sql**2).reshape(sql, sql)\n    for i in range(sql-1): a[:, i+1] *= a[:, i]; a[:, i+1] %= p\n    for i in range(sql-1): a[i+1] *= a[i, -1]; a[i+1] %= p\n    return np.ravel(a)[:l]\n\n  def make_mod_tables(self, N, n):\n    p = self.mod\n    if self.np_flg:\n      fac = np.arange(n+1); fac[0] = 1; fac = self.cumprod(fac)\n      ifac = np.arange(n+1, 0, -1); ifac[0] = pow(int(fac[-1]), p-2, p)\n      ifac = self.cumprod(ifac)[n::-1]\n      n_choose = np.arange(N+1, N-n, -1); n_choose[0] = 1;\n      n_choose[1:] = self.cumprod(n_choose[1:])*ifac[1:n+1]%p\n    else:\n      fac = [None]*(n+1); fac[0] = 1\n      for i in range(n): fac[i+1] = fac[i]*(i+1)%p\n      ifac = [None]*(n+1); ifac[n] = pow(fac[n], p-2, p)\n      for i in range(n, 0, -1): ifac[i-1] = ifac[i]*i%p\n      n_choose = [None] * (n+1); n_choose[0] = 1\n      for i in range(n): n_choose[i+1] = n_choose[i]*(N-i)%p\n      for i in range(n+1): n_choose[i] = n_choose[i]*ifac[i]%p\n    self.fac, self.ifac, self.mod_n_choose = fac, ifac, n_choose\n  \n  def mod_choose(self, n, r):\n    return self.fac[n]*self.ifac[r]%self.mod*self.ifac[n-r]%self.mod\n\n\ndef z_algorithm(s):\n  n = len(s)\n  a = [0] * n; a[0] = n\n  l = r = -1\n  for i in range(1, n):\n    if r >= i: a[i] = min(a[i-l], r-i)\n    while i + a[i] < n and s[i+a[i]] == s[a[i]]: a[i] += 1\n    if i+a[i] >= r: l, r = i, i+a[i]\n  return a\n\n\nclass ABC001():\n  def A():\n    h1, h2 = map(int, sys.stdin.read().split())\n    print(h1-h2)\n\n  def B(): pass\n  def C(): pass \n  def D(): pass \n\n\nclass ABC002():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(max(x, y))\n\n  def B():\n    vowels = set('aeiou')\n    s = sys.stdin.readline().rstrip() \n    t = ''\n    for c in s:\n      if c in vowels: continue \n      t += c \n    print(t)\n\n  def C():\n    *coords, = map(int, sys.stdin.readline().split())\n    def triangle_area(x0, y0, x1, y1, x2, y2):\n      x1 -= x0; x2 -= x0; y1 -= y0; y2 -= y0;\n      return abs(x1*y2 - x2*y1) / 2\n    print(triangle_area(*coords))\n\n  def D():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = set()\n    for _ in range(m):\n      x, y = map(int, sys.stdin.readline().split())\n      x -= 1; y -= 1\n      edges.add((x, y))\n    cand = []\n    for i in range(1, 1<<n):\n      s = [j for j in range(n) if i>>j & 1]\n      for x, y in combinations(s, 2):\n        if (x, y) not in edges: break\n      else:\n        cand.append(len(s))\n    print(max(cand))\n\n\nclass ABC003():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)*5000)\n\n  def B():\n    atcoder = set('atcoder')\n    s, t = sys.stdin.read().split()\n    for i in range(len(s)):\n      if s[i] == t[i]: continue\n      if s[i] == '@' and t[i] in atcoder: continue \n      if t[i] == '@' and s[i] in atcoder: continue\n      print('You will lose')\n      return \n    print('You can win')\n\n  def C():\n    n, k, *r = map(int, sys.stdin.read().split())\n    res = 0\n    for x in sorted(r)[-k:]:\n      res = (res+x) / 2\n    print(res)\n\n  def D(): pass \n\n\nclass ABC004():\n  def A():\n    print(int(sys.stdin.readline().rstrip())*2)\n\n  def B():\n    c = [sys.stdin.readline().rstrip() for _ in range(4)]\n    for l in c[::-1]:\n      print(l[::-1])\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n %= 30\n    res = list(range(1, 7))\n    for i in range(n):\n      i %= 5\n      res[i], res[i+1] = res[i+1], res[i]\n    print(''.join(map(str, res)))\n\n  def D(): pass \n\n\nclass ABC005():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(y//x)\n\n  def B():\n    n, *t = map(int, sys.stdin.read().split())\n    print(min(t))\n\n  def C():\n    t = int(sys.stdin.readline().rstrip())\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    m = int(sys.stdin.readline().rstrip())\n    b = [int(x) for x in sys.stdin.readline().split()]\n    i = 0\n    for p in b:\n      if i == n: print('no'); return \n      while p-a[i] > t:\n        i += 1\n        if i == n: print('no'); return \n      if a[i] > p: print('no'); return \n      i += 1\n    print('yes')\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    d = np.array([sys.stdin.readline().split() for _ in range(n)], np.int64)\n    s = d.cumsum(axis=0).cumsum(axis=1)\n    s = np.pad(s, 1)\n    max_del = np.zeros((n+1, n+1), dtype=np.int64)\n    for y in range(1, n+1):\n      for x in range(1, n+1):\n        max_del[y, x] = np.amax(s[y:n+1, x:n+1] - s[0:n-y+1, x:n+1] - s[y:n+1, 0:n-x+1] + s[0:n-y+1, 0:n-x+1])\n    res = np.arange(n**2+1)[:, None]\n    i = np.arange(1, n+1)\n    res = max_del[i, np.minimum(res//i, n)].max(axis=1)\n    q = int(sys.stdin.readline().rstrip())\n    p = np.array(sys.stdin.read().split(), dtype=np.int64)\n    print(*res[p], sep='\\n')\n\n\nclass ABC006():\n  def A():\n    n = sys.stdin.readline().rstrip()\n    if '3' in n: print('YES')\n    elif int(n)%3 == 0: print('YES')\n    else: print('NO')\n\n  def B():\n    mod = 10007\n    t = [0, 0, 1]\n    for _ in range(1001001):\n      t.append(t[-1]+t[-2]+t[-3]); t[-1] %= mod\n    n = int(sys.stdin.readline().rstrip())\n    print(t[n-1])\n    \n  def C():\n    n, m = map(int, sys.stdin.readline().split())\n    cnt = [0, 0, 0]\n    if m == 1: cnt = [-1, -1, -1]\n    else:\n      if m & 1: m -= 3; cnt[1] += 1; n -= 1\n      cnt[2] = m//2 - n \n      cnt[0] = n - cnt[2]\n    if cnt[0]<0 or cnt[1]<0 or cnt[2]<0: print(-1, -1, -1)\n    else: print(*cnt, sep=' ')\n      \n  def D():\n    n, *c = map(int, sys.stdin.read().split())\n    lis = [inf]*n \n    for x in c: lis[bi_l(lis, x)] = x \n    print(n - bi_l(lis, inf))\n\n\nclass ABC007():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n-1)\n\n  def B():\n    s = sys.stdin.readline().rstrip()\n    if s == 'a': print(-1)\n    else: print('a')\n\n  def C():\n    r, c = map(int, sys.stdin.readline().split())\n    sy, sx = map(int, sys.stdin.readline().split())\n    gy, gx = map(int, sys.stdin.readline().split())\n    sy -= 1; sx -=1; gy -= 1; gx -= 1\n    maze = [sys.stdin.readline().rstrip() for _ in range(r)]\n    queue = deque([(sy, sx)])\n    dist = np.full((r, c), np.inf); dist[sy, sx] = 0\n    while queue:\n      y, x = queue.popleft()\n      for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        i += y; j += x\n        if maze[i][j] == '#' or dist[i, j] != np.inf: continue \n        dist[i, j] = dist[y, x] + 1\n        queue.append((i, j))\n    print(int(dist[gy, gx]))\n  \n  def D(): pass \n\n\nclass ABC008():\n  def A():\n    s, t = map(int, sys.stdin.readline().split())\n    print(t-s+1)\n\n  def B():\n    n, *s = sys.stdin.read().split()\n    res = defaultdict(int)\n    for name in s: res[name] += 1\n    print(sorted(res.items(), key=lambda x: x[1])[-1][0])\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    a = np.array(a)\n    c = n - np.count_nonzero(a[:, None]%a, axis=1)\n    print(np.sum((c+1)//2/c))\n  \n  def D(): pass\n\nclass ABC009():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)//2)\n\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    print(sorted(set(a))[-2])\n    \n  def C():\n    n, k = map(int, sys.stdin.readline().split())\n    s = list(sys.stdin.readline().rstrip())\n    cost = [1]*n\n    r = k\n    for i in range(n-1):\n      q = []\n      for j in range(i+1, n):\n        if s[j] < s[i] and cost[i]+cost[j] <= r:\n          heappush(q, (s[j], cost[i]+cost[j], -j))\n      if not q: continue\n      _, c, j = heappop(q); j = -j \n      s[i], s[j] = s[j], s[i]\n      r -= c \n      cost[i] = cost[j] = 0\n    print(''.join(s))\n      \n  def D(): pass \n\n\nclass ABC010():\n  def A():\n    print(sys.stdin.readline().rstrip()+'pp')\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    tot = 0\n    for x in a:\n      c = 0 \n      while x%2==0 or x%3==2:\n        x -= 1\n        c += 1\n      tot += c\n    print(tot)\n\n  def C():\n    sx, sy, gx, gy, t, v, n, *xy = map(int, sys.stdin.read().split())\n    x, y = np.array(xy).reshape(-1, 2).T\n    def dist(x1, y1, x2, y2):\n      return np.sqrt((x2-x1)**2 + (y2-y1)**2)\n    ans = 'YES' if (dist(sx, sy, x, y)+dist(x, y, gx, gy) <= v*t).any() else 'NO'\n    print(ans)\n\n  def D(): pass \n\nclass ABC011():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n%12+1)\n\n  def B():\n    s = sys.stdin.readline().rstrip() \n    print(s[0].upper()+s[1:].lower())\n\n  def C():\n    n, *ng = map(int, sys.stdin.read().split())\n    ng = set(ng)\n    if n in ng: print('NO')\n    else:\n      r = 100\n      while n > 0:\n        if r == 0: print('NO'); return\n        for i in range(3, 0, -1):\n          if (n-i) in ng: continue \n          n -= i\n          r -= 1\n          break \n        else: print('NO'); return \n      print('YES')\n\n  def D(): pass \n\n\nclass ABC041():\n  def A():\n    s, i = sys.stdin.read().split()\n    i = int(i)\n    print(s[i-1])\n\n  def B():\n    a, b, c = map(int, sys.stdin.readline().split())\n    ans = a * b % MOD * c % MOD \n    print(ans)\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    for i, h in sorted(enumerate(a), key=lambda x: -x[1]):\n      print(i+1)\n\n  def D():\n    n, m, *xy = map(int, sys.stdin.read().split())\n    *xy, = zip(*[iter(xy)]*2)\n    edges = [0] * n \n    for x, y in xy:\n      x -= 1; y -= 1\n      edges[x] |= 1<<y\n    comb = [None] * (1<<n); comb[0] = 1\n    def count(edges, bit):\n      if comb[bit] is not None: return comb[bit]\n      comb[bit] = 0\n      for i in range(n):\n        if (bit>>i) & 1 and not edges[i]:\n          nxt_bit = bit & ~(1<<i)\n          nxt_edges = edges.copy() \n          for j in range(n):\n            nxt_edges[j] &= ~(1<<i)\n          cnt = count(nxt_edges, nxt_bit)\n          comb[bit] += cnt\n      return comb[bit]\n    print(count(edges, (1<<n)-1))\n\n\nclass ABC042():\n  def A():\n    a = [int(x) for x in sys.stdin.readline().split()]\n    c = Counter(a)\n    print('YES' if c[5]==2 and c[7]==1 else 'NO')\n\n  def B():\n    n, l, *s = sys.stdin.read().split()\n    print(''.join(sorted(s)))\n\n  def C():\n    n, k, *d = sys.stdin.read().split()\n    l = len(n)\n    ok = sorted(set(string.digits)-set(d))\n    cand = [int(''.join(p)) for p in product(ok, repeat=l)] + [int(min(x for x in ok if x > '0')+min(ok)*l)]\n    print(cand[bi_l(cand, int(n))])\n\n  def D():\n    h, w, a, b = map(int, sys.stdin.read().split())\n    combinatorics = Combinatorics(n=2*10**5, mod=MOD, numpy=True)\n    tot = combinatorics.mod_choose(h+w-2, h-1)\n    i = np.arange(h-a, h)\n    ng = np.sum(combinatorics.mod_choose(i+b-1, i) * combinatorics.mod_choose(h-i+w-b-2, h-1-i) % MOD)\n    tot -= ng; tot %= MOD\n    print(tot)\n  \n\nclass ABC170():\n  def A():\n    x = [int(x) for x in sys.stdin.readline().split()]\n    for i in range(5):\n      if x[i] != i+1:\n        print(i+1)\n        break\n\n  def B():\n    x, y = map(int, sys.stdin.readline().split())\n    print('Yes' if 2*x <= y <= 4*x and y%2 == 0 else 'No')\n      \n  def C():\n    x, n, *p = map(int, sys.stdin.read().split())\n    a = list(set(range(102)) - set(p))\n    a = [(abs(y-x), y) for y in a]\n    print(sorted(a)[0][1])\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    cand = set(a)\n    cnt = 0\n    for x, c in sorted(Counter(a).items()):\n      cnt += c == 1 and x in cand\n      cand -= set(range(x*2, 10**6+1, x))\n    print(cnt)\n\n  def E():\n    n, q = map(int, sys.stdin.readline().split())\n    queue = [] \n    num_kindergarten = 2*10**5\n    queue_kindergarten = [[] for _ in range(num_kindergarten)]\n    highest_kindergarten = [None] * num_kindergarten\n    where = [None] * n\n    rate = [None] * n\n\n    def entry(i, k):\n      where[i] = k\n      while queue_kindergarten[k]:\n        r, j = heappop(queue_kindergarten[k])\n        if where[j] != k or j == i: continue \n        if rate[i] >= -r:\n          highest_kindergarten[k] = rate[i]\n          heappush(queue, (rate[i], k, i))\n        heappush(queue_kindergarten[k], (r, j))\n        break\n      else:\n        highest_kindergarten[k] = rate[i]\n        heappush(queue, (rate[i], k, i))\n      heappush(queue_kindergarten[k], (-rate[i], i))\n\n    def transfer(i, k):\n      now = where[i]\n      while queue_kindergarten[now]:\n        r, j = heappop(queue_kindergarten[now])\n        if where[j] != now or j == i: continue\n        if highest_kindergarten[now] != -r:\n          highest_kindergarten[now] = -r\n          heappush(queue, (-r, now, j))\n        heappush(queue_kindergarten[now], (r, j))\n        break\n      else:\n        highest_kindergarten[now] = None\n      entry(i, k)\n\n    def inquire():\n      while True:\n        r, k, i = heappop(queue)\n        if where[i] != k or r != highest_kindergarten[k]: continue \n        heappush(queue, (r, k, i))\n        return r\n\n    for i in range(n):\n      a, b = map(int, sys.stdin.readline().split())\n      rate[i] = a \n      entry(i, b-1)\n    for _ in range(q):\n      c, d = map(int, sys.stdin.readline().split())\n      transfer(c-1, d-1)\n      print(inquire())\n    \n  def F(): pass \n\n\nclass ABC171():\n  def A():\n    c = sys.stdin.readline().rstrip()\n    print('A' if c < 'a' else 'a')\n\n  def B():\n    n, k, *p = map(int, sys.stdin.read().split())\n    print(sum(sorted(p)[:k]))\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n -= 1\n    l = 1\n    while True:\n      if n < pow(26, l):\n        break \n      n -= pow(26, l)\n      l += 1\n    res = ''.join([chr(ord('a')+d%26) for d in NumberTheory.base_convert(n, 26)][::-1])\n    res = 'a'*(l-len(res)) + res\n    print(res)\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    s = sum(a)\n    cnt = Counter(a)\n    q = int(sys.stdin.readline().rstrip())\n    for _ in range(q):\n      b, c = map(int, sys.stdin.readline().split())\n      s += (c-b)*cnt[b]\n      print(s)\n      cnt[c] += cnt[b]; cnt[b] = 0\n\n  def E():\n    n, *a = map(int, sys.stdin.read().split())\n    s = 0\n    for x in a: s ^= x \n    b = map(lambda x: x^s, a)\n    print(*b, sep=' ')\n\n  def F(): pass \n\n\nclass ABC172():\n  def A(): pass\n  def B(): pass\n  def C(): pass \n  def D(): pass \n  def E(): pass \n  def F(): pass \n\n\nclass ABC173():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    charge = (n+999)//1000 * 1000 - n\n    print(charge)\n\n  def B():\n    n, *s = sys.stdin.read().split() \n    c = Counter(s)\n    for v in 'AC, WA, TLE, RE'.split(', '):\n      print(f'{v} x {c[v]}')\n\n  def C():\n    h, w, k = map(int, sys.stdin.readline().split())\n    c = [sys.stdin.readline().rstrip() for _ in range(h)]\n    tot = 0\n    for i in range(1<<h):\n      for j in range(1<<w):\n        cnt = 0\n        for y in range(h):\n          for x in range(w):\n            if i>>y & 1 or j>>x & 1:\n              continue \n            cnt += c[y][x] ==  '#'\n        tot += cnt == k\n    print(tot)\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    a.sort(reverse=True)\n    res = a[0] + sum(a[1:1+(n-2)//2])*2 + a[1+(n-2)//2]*(n & 1)\n    print(res)\n\n  def E():\n    MOD = 10**9+7\n    n, k, *a = map(int, sys.stdin.read().split())\n    minus = [x for x in a if x < 0]\n    plus = [x for x in a if x > 0]\n    if len(plus) + len(minus)//2*2 >= k: # plus \n      *minus, = map(abs, minus)\n      minus.sort(reverse=True)\n      plus.sort(reverse=True)\n      cand = []\n      if len(minus)&1: minus = minus[:-1]\n      for i in range(0, len(minus)-1, 2):\n        cand.append(minus[i]*minus[i+1]%MOD)\n      if k & 1:\n        res = plus[0]\n        plus = plus[1:]\n      else:\n        res = 1\n      if len(plus)&1: plus = plus[:-1]\n      for i in range(0, len(plus)-1, 2):\n        cand.append(plus[i]*plus[i+1]%MOD)\n      cand.sort(reverse=True)\n      for x in cand[:k//2]:\n        res *= x\n        res %= MOD \n      print(res)\n    elif 0 in a:\n      print(0)\n    else:\n      cand = sorted(map(abs, a))\n      res = 1\n      for i in range(k):\n        res *= cand[i]\n        res %= MOD\n      res = MOD - res\n      print(res)\n      pass\n  \n  def F(): pass \n\n\ndef __starting_point():\n  ABC042.D()\n__starting_point()", "P = 10**9+7\nfac = [1]\nifac = [1]\nff = 1\nfor i in range(1,200001):\n  ff *= i\n  ff %= P\n  fac.append(ff)\n  ifac.append(pow(ff, P-2, P))\ndef ncr(n, r): \n  return (fac[n] * ifac[r] % P * ifac[n-r] % P);\n\nh,w,a,b = list(map(int,input().split()))\ns = 0\nnC = b-1\nkC = 0\nnD = w-b-1+h-1\nkD = h-1\nfor i in range(h-a):\n  C = ncr(nC, kC)\n  D = ncr(nD, kD)\n  s = (s + C * D) % P\n  nC += 1\n  kC += 1\n  kD -= 1\n  nD -= 1\nprint(s)\n", "class Combination:\n    def __init__(self, size, mod=10**9 + 7):\n        self.size = size + 2\n        self.mod = mod\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % self.mod\n            self.inv[i] = -self.inv[self.mod % i] * (self.mod // i) % self.mod\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % self.mod\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % self.mod\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % self.mod) % self.mod\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b\n        return self.ncr(n + r - 1, n - 1)\n\n    def factN(self, n):\n        if n < 0:\n            return 0\n        return self.fact[n]\n\nH, W, A, B = list(map(int, input().split()))\ncomb = Combination(H + W + 100)\nMOD = 10**9 + 7\n\nans = 0\nfor w in range(B + 1, W + 1):\n    ans += comb.ncr(H - A + w - 2, w - 1) * comb.ncr(A + W - w - 1, A - 1)\nprint((ans % MOD))\n", "import sys\nimport numpy as np\nfrom heapq import heappush, heappop \nfrom bisect import bisect_left as bi_l, bisect_right as bi_r\nfrom collections import deque, Counter, defaultdict\nfrom itertools import combinations, product\nimport string \ninf = float('inf')\nMOD = 10**9+7\n# MOD = 998244353\n\n\nclass NumberTheory():\n  def __init__(self, n=2*10**6, numpy=True):\n    self.n = n\n    self.np_flg = numpy \n    self.is_prime_number, self.prime_numbers = self.sieve_of_eratosthenes(n)\n  \n  def sieve_of_eratosthenes(self, n):\n    if self.np_flg:\n      sieve = np.ones(n+1, dtype=np.int64); sieve[:2] = 0\n      for i in range(2, int(n**.5)+1):\n        if sieve[i]: sieve[i*2::i] = 0\n      prime_numbers = np.flatnonzero(sieve)\n    else:\n      sieve = [1] * (n+1); sieve[0] = sieve[1] = 0\n      for i in range(2, int(n**.5)+1):\n        if not sieve[i]: continue\n        for j in range(i*2, n+1, i): sieve[j] = 0\n      prime_numbers = [i for i in range(2, n+1) if sieve[i]]\n    return sieve, prime_numbers \n\n  def prime_factorize(self, n):\n    res = dict()\n    if n < 2: return res\n    border = int(n**.5)\n    for p in self.prime_numbers:\n      if p > border: break\n      while n % p == 0: res[p] = res.get(p, 0)+1; n //= p\n      if n == 1: return res\n    res[n] = 1; return res\n\n  def prime_factorize_factorial(self, n):\n    res = dict()\n    for i in range(2, n+1):\n      for p, c in self.prime_factorize(i).items(): res[p] = res.get(p, 0)+c\n    return res\n  \n  @staticmethod\n  def gcd(a, b): return gcd(b, a%b) if b else abs(a)\n\n  @staticmethod\n  def lcm(a, b): return abs(a // gcd(a, b) * b)\n\n  @staticmethod\n  def find_divisors(n):\n    divisors = []\n    for i in range(1, int(n**.5)+1):\n      if n%i: continue\n      divisors.append(i)\n      j = n // i\n      if j != i: divisors.append(j)\n    return divisors\n  \n  @staticmethod\n  def base_convert(n, b):\n    if not n: return [0]\n    res = []\n    while n:\n      n, r = divmod(n, b)\n      if r < 0: n += 1; r -= b\n      res.append(r)\n    return res\n\n\nclass UnionFind():\n  def __init__(self, n=10**6):\n    self.root = list(range(n))\n    self.height = [0] * n \n    self.size = [1] * n \n  \n  def find_root(self, u):\n    if self.root[u] == u: return u\n    self.root[u] = self.find_root(self.root[u])\n    return self.root[u]\n  \n  def unite(self, u, v):\n    ru = self.find_root(u)\n    rv = self.find_root(v)\n    if ru == rv: return \n    hu = self.height[ru]\n    hv = self.height[rv]\n    if hu >= hv:\n      self.root[rv] = ru \n      self.size[ru] += self.size[rv]\n      self.height[ru] = max(hu, hv+1)\n    else:\n      self.root[ru] = rv \n      self.size[rv] += self.size[ru]\n\n\nclass Combinatorics():\n  def __init__(self, N=10**9, n=10**6, mod=10**9+7, numpy=True):\n    self.mod = mod\n    self.nCr = dict()\n    self.np_flg=numpy\n    self.make_mod_tables(N, n)\n\n  sys.setrecursionlimit(10**6)\n  def choose(self, n, r, mod=None): # no mod, or mod \u2260 prime\n    if r > n or r < 0: return 0\n    if r == 0: return 1\n    if (n, r) in self.nCr: return self.nCr[(n, r)]\n    if not mod:\n      self.nCr[(n, r)] = (self.choose(n-1, r) + self.choose(n-1, r-1))\n    else:\n      self.nCr[(n, r)] = (self.choose(n-1, r, mod) + self.choose(n-1, r-1, mod)) % mod\n    return self.nCr[(n,r)]\n  \n  def cumprod(self, a):\n    p = self.mod\n    l = len(a); sql = int(np.sqrt(l)+1)\n    a = np.resize(a, sql**2).reshape(sql, sql)\n    for i in range(sql-1): a[:, i+1] *= a[:, i]; a[:, i+1] %= p\n    for i in range(sql-1): a[i+1] *= a[i, -1]; a[i+1] %= p\n    return np.ravel(a)[:l]\n\n  def make_mod_tables(self, N, n):\n    p = self.mod\n    if self.np_flg:\n      fac = np.arange(n+1); fac[0] = 1; fac = self.cumprod(fac)\n      ifac = np.arange(n+1, 0, -1); ifac[0] = pow(int(fac[-1]), p-2, p)\n      ifac = self.cumprod(ifac)[n::-1]\n      n_choose = np.arange(N+1, N-n, -1); n_choose[0] = 1;\n      n_choose[1:] = self.cumprod(n_choose[1:])*ifac[1:n+1]%p\n    else:\n      fac = [None]*(n+1); fac[0] = 1\n      for i in range(n): fac[i+1] = fac[i]*(i+1)%p\n      ifac = [None]*(n+1); ifac[n] = pow(fac[n], p-2, p)\n      for i in range(n, 0, -1): ifac[i-1] = ifac[i]*i%p\n      n_choose = [None] * (n+1); n_choose[0] = 1\n      for i in range(n): n_choose[i+1] = n_choose[i]*(N-i)%p\n      for i in range(n+1): n_choose[i] = n_choose[i]*ifac[i]%p\n    self.fac, self.ifac, self.mod_n_choose = fac, ifac, n_choose\n  \n  def mod_choose(self, n, r):\n    return self.fac[n]*self.ifac[r]%self.mod*self.ifac[n-r]%self.mod\n\n\ndef z_algorithm(s):\n  n = len(s)\n  a = [0] * n; a[0] = n\n  l = r = -1\n  for i in range(1, n):\n    if r >= i: a[i] = min(a[i-l], r-i)\n    while i + a[i] < n and s[i+a[i]] == s[a[i]]: a[i] += 1\n    if i+a[i] >= r: l, r = i, i+a[i]\n  return a\n\n\nclass ABC001():\n  def A():\n    h1, h2 = map(int, sys.stdin.read().split())\n    print(h1-h2)\n\n  def B(): pass\n  def C(): pass \n  def D(): pass \n\n\nclass ABC002():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(max(x, y))\n\n  def B():\n    vowels = set('aeiou')\n    s = sys.stdin.readline().rstrip() \n    t = ''\n    for c in s:\n      if c in vowels: continue \n      t += c \n    print(t)\n\n  def C():\n    *coords, = map(int, sys.stdin.readline().split())\n    def triangle_area(x0, y0, x1, y1, x2, y2):\n      x1 -= x0; x2 -= x0; y1 -= y0; y2 -= y0;\n      return abs(x1*y2 - x2*y1) / 2\n    print(triangle_area(*coords))\n\n  def D():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = set()\n    for _ in range(m):\n      x, y = map(int, sys.stdin.readline().split())\n      x -= 1; y -= 1\n      edges.add((x, y))\n    cand = []\n    for i in range(1, 1<<n):\n      s = [j for j in range(n) if i>>j & 1]\n      for x, y in combinations(s, 2):\n        if (x, y) not in edges: break\n      else:\n        cand.append(len(s))\n    print(max(cand))\n\n\nclass ABC003():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)*5000)\n\n  def B():\n    atcoder = set('atcoder')\n    s, t = sys.stdin.read().split()\n    for i in range(len(s)):\n      if s[i] == t[i]: continue\n      if s[i] == '@' and t[i] in atcoder: continue \n      if t[i] == '@' and s[i] in atcoder: continue\n      print('You will lose')\n      return \n    print('You can win')\n\n  def C():\n    n, k, *r = map(int, sys.stdin.read().split())\n    res = 0\n    for x in sorted(r)[-k:]:\n      res = (res+x) / 2\n    print(res)\n\n  def D(): pass \n\n\nclass ABC004():\n  def A():\n    print(int(sys.stdin.readline().rstrip())*2)\n\n  def B():\n    c = [sys.stdin.readline().rstrip() for _ in range(4)]\n    for l in c[::-1]:\n      print(l[::-1])\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n %= 30\n    res = list(range(1, 7))\n    for i in range(n):\n      i %= 5\n      res[i], res[i+1] = res[i+1], res[i]\n    print(''.join(map(str, res)))\n\n  def D(): pass \n\n\nclass ABC005():\n  def A():\n    x, y = map(int, sys.stdin.readline().split())\n    print(y//x)\n\n  def B():\n    n, *t = map(int, sys.stdin.read().split())\n    print(min(t))\n\n  def C():\n    t = int(sys.stdin.readline().rstrip())\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    m = int(sys.stdin.readline().rstrip())\n    b = [int(x) for x in sys.stdin.readline().split()]\n    i = 0\n    for p in b:\n      if i == n: print('no'); return \n      while p-a[i] > t:\n        i += 1\n        if i == n: print('no'); return \n      if a[i] > p: print('no'); return \n      i += 1\n    print('yes')\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    d = np.array([sys.stdin.readline().split() for _ in range(n)], np.int64)\n    s = d.cumsum(axis=0).cumsum(axis=1)\n    s = np.pad(s, 1)\n    max_del = np.zeros((n+1, n+1), dtype=np.int64)\n    for y in range(1, n+1):\n      for x in range(1, n+1):\n        max_del[y, x] = np.amax(s[y:n+1, x:n+1] - s[0:n-y+1, x:n+1] - s[y:n+1, 0:n-x+1] + s[0:n-y+1, 0:n-x+1])\n    res = np.arange(n**2+1)[:, None]\n    i = np.arange(1, n+1)\n    res = max_del[i, np.minimum(res//i, n)].max(axis=1)\n    q = int(sys.stdin.readline().rstrip())\n    p = np.array(sys.stdin.read().split(), dtype=np.int64)\n    print(*res[p], sep='\\n')\n\n\nclass ABC006():\n  def A():\n    n = sys.stdin.readline().rstrip()\n    if '3' in n: print('YES')\n    elif int(n)%3 == 0: print('YES')\n    else: print('NO')\n\n  def B():\n    mod = 10007\n    t = [0, 0, 1]\n    for _ in range(1001001):\n      t.append(t[-1]+t[-2]+t[-3]); t[-1] %= mod\n    n = int(sys.stdin.readline().rstrip())\n    print(t[n-1])\n    \n  def C():\n    n, m = map(int, sys.stdin.readline().split())\n    cnt = [0, 0, 0]\n    if m == 1: cnt = [-1, -1, -1]\n    else:\n      if m & 1: m -= 3; cnt[1] += 1; n -= 1\n      cnt[2] = m//2 - n \n      cnt[0] = n - cnt[2]\n    if cnt[0]<0 or cnt[1]<0 or cnt[2]<0: print(-1, -1, -1)\n    else: print(*cnt, sep=' ')\n      \n  def D():\n    n, *c = map(int, sys.stdin.read().split())\n    lis = [inf]*n \n    for x in c: lis[bi_l(lis, x)] = x \n    print(n - bi_l(lis, inf))\n\n\nclass ABC007():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n-1)\n\n  def B():\n    s = sys.stdin.readline().rstrip()\n    if s == 'a': print(-1)\n    else: print('a')\n\n  def C():\n    r, c = map(int, sys.stdin.readline().split())\n    sy, sx = map(int, sys.stdin.readline().split())\n    gy, gx = map(int, sys.stdin.readline().split())\n    sy -= 1; sx -=1; gy -= 1; gx -= 1\n    maze = [sys.stdin.readline().rstrip() for _ in range(r)]\n    queue = deque([(sy, sx)])\n    dist = np.full((r, c), np.inf); dist[sy, sx] = 0\n    while queue:\n      y, x = queue.popleft()\n      for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        i += y; j += x\n        if maze[i][j] == '#' or dist[i, j] != np.inf: continue \n        dist[i, j] = dist[y, x] + 1\n        queue.append((i, j))\n    print(int(dist[gy, gx]))\n  \n  def D(): pass \n\n\nclass ABC008():\n  def A():\n    s, t = map(int, sys.stdin.readline().split())\n    print(t-s+1)\n\n  def B():\n    n, *s = sys.stdin.read().split()\n    res = defaultdict(int)\n    for name in s: res[name] += 1\n    print(sorted(res.items(), key=lambda x: x[1])[-1][0])\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    a = np.array(a)\n    c = n - np.count_nonzero(a[:, None]%a, axis=1)\n    print(np.sum((c+1)//2/c))\n  \n  def D(): pass\n\nclass ABC009():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print((n+1)//2)\n\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    print(sorted(set(a))[-2])\n    \n  def C():\n    n, k = map(int, sys.stdin.readline().split())\n    s = list(sys.stdin.readline().rstrip())\n    cost = [1]*n\n    r = k\n    for i in range(n-1):\n      q = []\n      for j in range(i+1, n):\n        if s[j] < s[i] and cost[i]+cost[j] <= r:\n          heappush(q, (s[j], cost[i]+cost[j], -j))\n      if not q: continue\n      _, c, j = heappop(q); j = -j \n      s[i], s[j] = s[j], s[i]\n      r -= c \n      cost[i] = cost[j] = 0\n    print(''.join(s))\n      \n  def D(): pass \n\n\nclass ABC010():\n  def A():\n    print(sys.stdin.readline().rstrip()+'pp')\n  def B():\n    n, *a = map(int, sys.stdin.read().split())\n    tot = 0\n    for x in a:\n      c = 0 \n      while x%2==0 or x%3==2:\n        x -= 1\n        c += 1\n      tot += c\n    print(tot)\n\n  def C():\n    sx, sy, gx, gy, t, v, n, *xy = map(int, sys.stdin.read().split())\n    x, y = np.array(xy).reshape(-1, 2).T\n    def dist(x1, y1, x2, y2):\n      return np.sqrt((x2-x1)**2 + (y2-y1)**2)\n    ans = 'YES' if (dist(sx, sy, x, y)+dist(x, y, gx, gy) <= v*t).any() else 'NO'\n    print(ans)\n\n  def D(): pass \n\nclass ABC011():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    print(n%12+1)\n\n  def B():\n    s = sys.stdin.readline().rstrip() \n    print(s[0].upper()+s[1:].lower())\n\n  def C():\n    n, *ng = map(int, sys.stdin.read().split())\n    ng = set(ng)\n    if n in ng: print('NO')\n    else:\n      r = 100\n      while n > 0:\n        if r == 0: print('NO'); return\n        for i in range(3, 0, -1):\n          if (n-i) in ng: continue \n          n -= i\n          r -= 1\n          break \n        else: print('NO'); return \n      print('YES')\n\n  def D(): pass \n\n\nclass ABC041():\n  def A():\n    s, i = sys.stdin.read().split()\n    i = int(i)\n    print(s[i-1])\n\n  def B():\n    a, b, c = map(int, sys.stdin.readline().split())\n    ans = a * b % MOD * c % MOD \n    print(ans)\n\n  def C():\n    n, *a = map(int, sys.stdin.read().split())\n    for i, h in sorted(enumerate(a), key=lambda x: -x[1]):\n      print(i+1)\n\n  def D():\n    n, m, *xy = map(int, sys.stdin.read().split())\n    *xy, = zip(*[iter(xy)]*2)\n    edges = [0] * n \n    for x, y in xy:\n      x -= 1; y -= 1\n      edges[x] |= 1<<y\n    comb = [None] * (1<<n); comb[0] = 1\n    def count(edges, bit):\n      if comb[bit] is not None: return comb[bit]\n      comb[bit] = 0\n      for i in range(n):\n        if (bit>>i) & 1 and not edges[i]:\n          nxt_bit = bit & ~(1<<i)\n          nxt_edges = edges.copy() \n          for j in range(n):\n            nxt_edges[j] &= ~(1<<i)\n          cnt = count(nxt_edges, nxt_bit)\n          comb[bit] += cnt\n      return comb[bit]\n    print(count(edges, (1<<n)-1))\n\n\nclass ABC042():\n  def A():\n    a = [int(x) for x in sys.stdin.readline().split()]\n    c = Counter(a)\n    print('YES' if c[5]==2 and c[7]==1 else 'NO')\n\n  def B():\n    n, l, *s = sys.stdin.read().split()\n    print(''.join(sorted(s)))\n\n  def C():\n    n, k, *d = sys.stdin.read().split()\n    l = len(n)\n    ok = sorted(set(string.digits)-set(d))\n    cand = [int(''.join(p)) for p in product(ok, repeat=l)] + [int(min(x for x in ok if x > '0')+min(ok)*l)]\n    print(cand[bi_l(cand, int(n))])\n\n  def D():\n    h, w, a, b = map(int, sys.stdin.read().split())\n    combinatorics = Combinatorics(mod=MOD, numpy=True)\n    tot = combinatorics.mod_choose(h+w-2, h-1)\n    i = np.arange(h-a, h)\n    ng = np.sum(combinatorics.mod_choose(i+b-1, i) * combinatorics.mod_choose(h-i+w-b-2, h-1-i) % MOD)\n    tot -= ng; tot %= MOD\n    print(tot)\n  \n  \nclass ABC170():\n  def A():\n    x = [int(x) for x in sys.stdin.readline().split()]\n    for i in range(5):\n      if x[i] != i+1:\n        print(i+1)\n        break\n\n  def B():\n    x, y = map(int, sys.stdin.readline().split())\n    print('Yes' if 2*x <= y <= 4*x and y%2 == 0 else 'No')\n      \n  def C():\n    x, n, *p = map(int, sys.stdin.read().split())\n    a = list(set(range(102)) - set(p))\n    a = [(abs(y-x), y) for y in a]\n    print(sorted(a)[0][1])\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    cand = set(a)\n    cnt = 0\n    for x, c in sorted(Counter(a).items()):\n      cnt += c == 1 and x in cand\n      cand -= set(range(x*2, 10**6+1, x))\n    print(cnt)\n\n  def E():\n    n, q = map(int, sys.stdin.readline().split())\n    queue = [] \n    num_kindergarten = 2*10**5\n    queue_kindergarten = [[] for _ in range(num_kindergarten)]\n    highest_kindergarten = [None] * num_kindergarten\n    where = [None] * n\n    rate = [None] * n\n\n    def entry(i, k):\n      where[i] = k\n      while queue_kindergarten[k]:\n        r, j = heappop(queue_kindergarten[k])\n        if where[j] != k or j == i: continue \n        if rate[i] >= -r:\n          highest_kindergarten[k] = rate[i]\n          heappush(queue, (rate[i], k, i))\n        heappush(queue_kindergarten[k], (r, j))\n        break\n      else:\n        highest_kindergarten[k] = rate[i]\n        heappush(queue, (rate[i], k, i))\n      heappush(queue_kindergarten[k], (-rate[i], i))\n\n    def transfer(i, k):\n      now = where[i]\n      while queue_kindergarten[now]:\n        r, j = heappop(queue_kindergarten[now])\n        if where[j] != now or j == i: continue\n        if highest_kindergarten[now] != -r:\n          highest_kindergarten[now] = -r\n          heappush(queue, (-r, now, j))\n        heappush(queue_kindergarten[now], (r, j))\n        break\n      else:\n        highest_kindergarten[now] = None\n      entry(i, k)\n\n    def inquire():\n      while True:\n        r, k, i = heappop(queue)\n        if where[i] != k or r != highest_kindergarten[k]: continue \n        heappush(queue, (r, k, i))\n        return r\n\n    for i in range(n):\n      a, b = map(int, sys.stdin.readline().split())\n      rate[i] = a \n      entry(i, b-1)\n    for _ in range(q):\n      c, d = map(int, sys.stdin.readline().split())\n      transfer(c-1, d-1)\n      print(inquire())\n    \n  def F(): pass \n\n\nclass ABC171():\n  def A():\n    c = sys.stdin.readline().rstrip()\n    print('A' if c < 'a' else 'a')\n\n  def B():\n    n, k, *p = map(int, sys.stdin.read().split())\n    print(sum(sorted(p)[:k]))\n\n  def C():\n    n = int(sys.stdin.readline().rstrip())\n    n -= 1\n    l = 1\n    while True:\n      if n < pow(26, l):\n        break \n      n -= pow(26, l)\n      l += 1\n    res = ''.join([chr(ord('a')+d%26) for d in NumberTheory.base_convert(n, 26)][::-1])\n    res = 'a'*(l-len(res)) + res\n    print(res)\n\n  def D():\n    n = int(sys.stdin.readline().rstrip())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    s = sum(a)\n    cnt = Counter(a)\n    q = int(sys.stdin.readline().rstrip())\n    for _ in range(q):\n      b, c = map(int, sys.stdin.readline().split())\n      s += (c-b)*cnt[b]\n      print(s)\n      cnt[c] += cnt[b]; cnt[b] = 0\n\n  def E():\n    n, *a = map(int, sys.stdin.read().split())\n    s = 0\n    for x in a: s ^= x \n    b = map(lambda x: x^s, a)\n    print(*b, sep=' ')\n\n  def F(): pass \n\n\nclass ABC172():\n  def A(): pass\n  def B(): pass\n  def C(): pass \n  def D(): pass \n  def E(): pass \n  def F(): pass \n\n\nclass ABC173():\n  def A():\n    n = int(sys.stdin.readline().rstrip())\n    charge = (n+999)//1000 * 1000 - n\n    print(charge)\n\n  def B():\n    n, *s = sys.stdin.read().split() \n    c = Counter(s)\n    for v in 'AC, WA, TLE, RE'.split(', '):\n      print(f'{v} x {c[v]}')\n\n  def C():\n    h, w, k = map(int, sys.stdin.readline().split())\n    c = [sys.stdin.readline().rstrip() for _ in range(h)]\n    tot = 0\n    for i in range(1<<h):\n      for j in range(1<<w):\n        cnt = 0\n        for y in range(h):\n          for x in range(w):\n            if i>>y & 1 or j>>x & 1:\n              continue \n            cnt += c[y][x] ==  '#'\n        tot += cnt == k\n    print(tot)\n\n  def D():\n    n, *a = map(int, sys.stdin.read().split())\n    a.sort(reverse=True)\n    res = a[0] + sum(a[1:1+(n-2)//2])*2 + a[1+(n-2)//2]*(n & 1)\n    print(res)\n\n  def E():\n    MOD = 10**9+7\n    n, k, *a = map(int, sys.stdin.read().split())\n    minus = [x for x in a if x < 0]\n    plus = [x for x in a if x > 0]\n    if len(plus) + len(minus)//2*2 >= k: # plus \n      *minus, = map(abs, minus)\n      minus.sort(reverse=True)\n      plus.sort(reverse=True)\n      cand = []\n      if len(minus)&1: minus = minus[:-1]\n      for i in range(0, len(minus)-1, 2):\n        cand.append(minus[i]*minus[i+1]%MOD)\n      if k & 1:\n        res = plus[0]\n        plus = plus[1:]\n      else:\n        res = 1\n      if len(plus)&1: plus = plus[:-1]\n      for i in range(0, len(plus)-1, 2):\n        cand.append(plus[i]*plus[i+1]%MOD)\n      cand.sort(reverse=True)\n      for x in cand[:k//2]:\n        res *= x\n        res %= MOD \n      print(res)\n    elif 0 in a:\n      print(0)\n    else:\n      cand = sorted(map(abs, a))\n      res = 1\n      for i in range(k):\n        res *= cand[i]\n        res %= MOD\n      res = MOD - res\n      print(res)\n      pass\n  \n  def F(): pass \n\n\ndef __starting_point():\n  ABC042.D()\n__starting_point()", "H, W, A, B = list(map(int, input().split()))\nmod = 10**9 + 7\nU = 2 * 10**5\n\nfactorial = [1 for _ in range(U + 1)]\nfor i in range(1, U + 1):\n    factorial[i] = (factorial[i - 1] * i) % mod\n\ninverse = [1 for _ in range(U + 1)]\ninverse[U] = pow(factorial[U], mod - 2, mod)\nfor i in range(U, 0, -1):\n    inverse[i - 1] = (inverse[i] * i) % mod\n\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    x = factorial[n]\n    x *= inverse[k]\n    x %= mod\n    x *= inverse[n - k]\n    x %= mod\n    return x\n  \n  \nans = 0\nfor i in range(H - A):\n    x = comb(B - 1 + i, i)\n    a = H - 1 - i\n    b = W - 1 - B\n    x *= comb(a + b, a)\n    x %= mod\n    ans += x\nans %= mod\nprint(ans)\n", "H, W, A, B = [int(_) for _ in input().split()]\nmod = 10 ** 9 + 7\nf = [1] * (3 * 10 ** 6 + 10)\nfor i in range(1, 3 * 10 ** 6 + 10):\n    f[i] = i * f[i - 1] % mod\nfi = {}\n\n\ndef comb(n, r):\n    if r not in fi:\n        fi[r] = pow(f[r], mod - 2, mod)\n    if n - r not in fi:\n        fi[n - r] = pow(f[n - r], mod - 2, mod)\n    return (f[n] * fi[r] * fi[n - r]) % mod\n\n\nans = 0\nfor x in range(H - A):\n    ans += comb(B - 1 + x, x) * comb(H - x - 2 + W - B, W - B - 1)\n    ans %= mod\nprint(ans)\n", "mod=10**9+7\nh,w,a,b=map(int,input().split())\ndef comb(a,b):\n\tp=fac[a-b]*fac[b]%mod\n\treturn fac[a]*pow(p,mod-2,mod)%mod\nfac=[1]\nfor i in range(h+w):\n\tfac.append(fac[-1]*(i+1)%mod)\nans=0\nfor i in range(w-b):\n\tp=comb(h-a-1+b+i,b+i)*comb(w-b-i-2+a,a-1)\n\tans+=p%mod\n\tans%=mod\nprint(ans)", "MODD = 10**9 + 7 \n\ndef modinv(a,m)-> int:\n    b = m\n    u = 1\n    v = 0\n    while (b):\n        t = a // b\n        a -= t * b\n        a,b= b,a\n        u -= t * v\n        u,v= v,u\n    u %= m\n    if (u < 0):\n        u += m\n    return u\n\n\nfac=[1]*200001\ninfac=[1]*200001\naaa=1\nfor i in range(1,200001):\n    aaa=(aaa*i)%MODD\n    fac[i]=aaa\n    infac[i]=modinv(aaa,MODD)\n    #print(fac[i])\n\nimport math as m\n\ndef perm(x,y,z) -> int:\n    #print(fac[x]//(fac[y]*fac[z]))   \n    return ((fac[x]*infac[y]*infac[z])%MODD)\n\nh,w,a,b= [int(x) for x in input().split()]\nA = h-a\nB = b-1\nC = h-1\nD = w-b-1\nj=0\nk=B\nkl = C\njl = D\nans = 0\nfor i in range(A):\n  ans+=perm(B+i,B,i)*perm(C+D-i,C-i,D)\nprint(ans%MODD)", "h, w, a, b = list(map(int, input().split()))\n\nn = 2 * 10 ** 5\nk = 2 * 10 ** 5\nmod = 10**9 + 7\n\nmodinv_table = [-1] * (k+1)\nmodinv_table[1] = 1\nfor i in range(2, k+1):\n    modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\ndef prepare_binomial_coefficients(n, k):\n    for i in range(1,n+1):\n        bc_num[i] = i * bc_num[i-1] % mod\n    bc_num[0] = 0\n    for i in range(1,k+1):\n        bc_den[i] = modinv_table[i] * bc_den[i-1] % mod\n    return\n\ndef binomial_coefficients(n, k):\n    if n == 0 and k == 0:\n        return 1\n    return bc_num[n] * bc_den[k] * bc_den[n-k] % mod\n\nbc_num = [1]*(n+1)\nbc_den = [1]*(n+1)\nprepare_binomial_coefficients(n, n)\n\nmids = [0]*(w-b)\ndis_mid = h - a - 1\nfor i in range(w-b):\n    mids[i] = binomial_coefficients(dis_mid+i+b,i+b)\n\n#print(mids)\n\nmids_down = [0]*(w-b)\ndis_mid = a\nfor i in range(w-b):\n    mids_down[i] = binomial_coefficients(dis_mid+w-b-i-1,w-b-i-1)\n\n#print(mids_down)\n\nfor i in range(w-b-1):\n    mids_down[i] -= mids_down[i+1]\n\n#print(mids_down)\n\nfor i in range(w-b):\n    mids[i] = (mids[i] * mids_down[i]) % mod\n\n#print(mids)\n\nprint((sum(mids)%mod))\n", "#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\ndef cmb(n, r):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n\nN = 2 * 10 ** 5 + 1000  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nmod = pow(10, 9) + 7\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\nh, w, a, b = map(int,input().split())\nans = 0\nfor i in range(h - a):\n    ans += (cmb(b - 1 + i, i) * cmb(w - b -  1 + h - i - 1, w - b - 1)) % (10 ** 9 + 7)\nprint(ans % (10 ** 9 + 7))", "\n# Function to find modulo inverse of b. It returns  \n# -1 when inverse doesn't  \n# modInverse works for prime m \ndef gcd(b, m):\n  if b == 0:\n    return m\n  return gcd(m%b, b)\n\ndef modInverse(b,m): \n    g = gcd(b, m) \n    if (g != 1): \n        # print(\"Inverse doesn't exist\")  \n        return -1\n    else:  \n        # If b and m are relatively prime,  \n        # then modulo inverse is b^(m-2) mode m  \n        return pow(b, m - 2, m) \n  \n  \n# Function to compute a/b under modulo m  \ndef modDivide(a,b,m): \n    a = a % m \n    inv = modInverse(b,m) \n    if(inv == -1): \n        print(\"Division not defined\") \n    else: \n        return (inv*a) % m\n\nMOD = (10 ** 9) + 7\nH, W, A, B = list(map(int, input().split(' ')))\n\nDP = []\nj = 1\nfor i in range(1,200002):\n    j *= i\n    j %= MOD\n    DP.append(j)\n\n# print(DP)\ndef factorial(i):\n    if (i == 0):\n        return 1\n    nonlocal DP\n    # print(i)\n    # print(i, DP[i-1])\n    # print(DP[i-1])\n    return DP[i-1]\n\ndef move2(H, W, A, B):\n    numPaths = 0\n    h = H-A\n    w = W-(W-B)+1\n    a = A+1\n    pttp = 0\n    for b in range(w, W+1):\n        # print(h, b, a, W-b+1)\n        ttp = (factorial(h+b-2)*modInverse((factorial(h-1)*factorial(b-1))% MOD, MOD)) % MOD\n        tpttp = ttp\n        ttp -= pttp\n        pttp = tpttp\n        btp = (factorial(a+(W-b+1)-2)*modInverse((factorial(a-1)*factorial(W-b))% MOD, MOD)) % MOD\n        # btp = factorial(a+(W-b+1)-2)//(factorial(a-1)*factorial(W-b))\n        numPaths += ttp*btp\n    return numPaths\n\nways = move2(H, W, A, B)\nprint(ways % (10**9 + 7))", "h, w, a, b = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nN = h + w + 10\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nans = 0\na += 1\nb += 1\nn = h - a + b - 1\nn2 = w - b + a - 1\nwhile a <= h and b <= w:\n    ans += nCk(n, b - 1) * nCk(n2, w - b)\n    ans %= MOD\n    a += 1\n    b += 1\nprint(ans)", "class nCrMod():\n    def __init__(self, mod):\n        self.mod = mod\n        self.fac = [1, 1]\n        self.finv = [1, 1]\n        self.inv = [0, 1]\n\n    def prep(self, n):\n        mod = self.mod\n        f, fi = self.fac[-1], self.finv[-1]\n        for i in range(len(self.fac), n + 1):\n            fn = f * i % mod\n            v = -self.inv[mod % i] * (mod // i) % mod\n            fin = fi * v % mod\n            f, fi = fn, fin\n            self.fac.append(f)\n            self.finv.append(fi)\n            self.inv.append(v)\n\n    def __call__(self, n, r):\n        if len(self.fac) <= n:\n            self.prep(n)\n        return self.fac[n] * self.finv[r] * self.finv[n - r] % self.mod\n\ndef main():\n    H, W, A, B = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    nCr = nCrMod(mod)\n    r = 0\n    a = H - A - 1\n    for i in range(B, W):\n        r = (r + nCr(a + i, i) * nCr(A - 1 + W - i - 1, W - i - 1)) % mod\n    return r\n\n\nprint((main()))\n", "H, W, A, B = list(map(int, input().split()))\n\nMOD = 1000000007\n\nfac = [1, 1]\ninverse = [0, 1]\nifac = [1, 1]\n  \nfor i in range(2, H+W):\n  fac.append((fac[-1] * i) % MOD)\n  inverse.append((-inverse[MOD % i] * (MOD // i))  % MOD)\n  ifac.append((ifac[-1] * inverse[i]) % MOD)\n\ndef f(n):\n  return fac[B+n+H-A-1] * fac[W-B-1-n+A-1] * ifac[B+n] * ifac[H-A-1] * ifac[W-B-1-n] * ifac[A-1]\n\ndef sigma(func, frm, to):\n  result = 0\n  for i in range(frm, to+1):\n    result += func(i)\n  return result\n \nprint((sigma(f, 0, W-B-1)%MOD))\n", "def combmod(n, r, p):\n    if r < 0 or n < r:\n        return 0\n    return fact[n] * finv[r] * finv[n-r] % p\n\n\np = 10**9+7\nN = 10**6\nfact = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, N+1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    finv.append((finv[-1] * inv[-1]) % p)\n\nh, w, a, b = (int(x) for x in input().split())\nans = 0\nfor j in range(b, w):\n    ans += combmod(h-a-1 + j, j, p) * combmod(a+w-2 - j, w-1 - j, p)\nprint((ans % p))\n", "# coding:UTF-8\nimport sys\nfrom math import factorial\n\nMOD = 10 ** 9 + 7\n\ndef combInit(n):\n    fact = [1]\n    finv = [1]\n    for i in range(1, n + 1):\n        fact.append(fact[i - 1] * i % MOD)\n        finv.append(pow(fact[i], MOD - 2, MOD))\n    return [fact, finv]\n\ndef comb(n, k, f):\n    if n < k:\n        return 0\n    elif n < 0 or k < 0:\n        return 0\n    else:\n        return f[0][n] * (f[1][k] * f[1][n - k] % MOD) % MOD\n\n\ndef perm(n, r):\n    return factorial(n) // factorial(r)\n\n\ndef gcb(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcb(b, a % b)\n\n\ndef lcm(a, b):\n    d = gcb(a, b)\n    return int(a / d * b)\n\n\ndef surP(x):\n    return x % MOD\n\n\ndef main():\n    # ------ \u5165\u529b ------#\n    h, w, a, b = list(map(int, input().split()))     # \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u9023\u7d9a\u6570\u5b57\n\n    # ------ \u51e6\u7406 ------#\n    f = combInit(h + w)\n    res = 0\n    for i in range(b, w):\n        res += comb((h-1-a)+i, i, f) * comb((a-1)+(w-1-i), w-1-i, f)\n\n    out = surP(res)\n    # ------ \u51fa\u529b ------#\n    print((\"{}\".format(out)))\n    # if flg == 0:\n    #     print(\"YES\")\n    # else:\n    #     print(\"NO\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "memo=[0]*(10**6+1)\nmemo[0]=memo[1]=1\nmod=10**9+7\nfor i in range(2,10**6+1):\n  memo[i]=(memo[i-1]*i)%mod\ndef comb(n,k,p):\n  return (memo[n]*pow(memo[k],p-2,p)*pow(memo[n-k],p-2,p))%mod\nh,w,a,b=map(int,input().split())\nans=0\nfor i in range(h-a):\n  ans+=(comb(b+i-1,i,mod)*comb(h-i-1+w-b-1,w-b-1,mod))%mod\n  ans%=mod\nprint(ans)", "# D - \u3044\u308d\u306f\u3061\u3083\u3093\u3068\u30de\u30b9\u76ee\ndef cmb1(n,r,mod):\n    if (r<0 or r>n):\n        return 0\n    r = min(r,n-r)\n    return g1[n]*g2[r]*g2[n-r]%mod\n\nh,w,a,b=list(map(int,input().split()))\n\n# \u524d\u51e6\u7406\nmod=10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nn=10**6\ng1=[1,1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2=[1,1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse=[0,1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2,n+1):\n    g1.append((g1[-1]*i)%mod)\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g2.append((g2[-1]*inverse[-1])%mod)\n\nans = 0\nfor i in range(b, w):\n    ans+=cmb1(i+h-1-a,i,mod)*cmb1(w-1-i+a-1,a-1,mod)\n    ans%=mod\nprint(ans)\n", "h,w,a,b = list(map(int,input().split()))\n\nmod = 10**9+7 \nfact = [1,1]\nfinv = [1,1]\ninv = [0,1]\n \nfor i in range(2,h+w+5):\n    fact.append((fact[-1]*i)%mod)\n    inv.append((inv[mod%i]*(mod-mod//i))%mod)\n    finv.append((finv[-1]*inv[-1])%mod)\n \ndef nCr(n,r,mod):\n    if r > n:\n        return 0\n    else: \n        return fact[n]*finv[r]*finv[n-r]%mod\n\nans = 0\n\nfor i in range(100000):\n    x = h-a-i\n    y = b+1+i\n    \n    if 0 >= x or y > w:\n        break\n    \n    ans += nCr(h+w-x-y,h-x,mod)*nCr(x+y-2,x-1,mod)%mod\n    ans %= mod\nprint(ans)\n\n\n", "h,w,a,b = map(int, input().split())\nimport math\nans = 0\nmod = 10**9+7\nl =[i for i in range(1,h+w+2)]\nfor i in range(1,len(l)-1):\n    l[i+1] = l[i+1]*l[i]%mod\nl = [1]+ l\ngyakugen = [pow(l[i], mod-2, mod) for i in range(1, len(l))]\ngyakugen = [1] + gyakugen\nfor p in range(1, w-b+1):\n    ans += l[(h-a-1+b+p-1)]*l[w-(b+p)+a-1]*\\\n    gyakugen[h-a-1]*gyakugen[b+p-1] * gyakugen[a-1]*gyakugen[w-(b+p)]\nprint(int(ans)%mod)", "class ModInt:\n    def __init__(self, num, mod):\n        self.num = num\n        self.mod = mod\n\n    def __str__(self):\n        return str(self.num)\n\n    def __repr__(self):\n        return \"ModInt(num: {}, mod: {}\".format(self.num, self.mod)\n\n    def __add__(self, other):\n        ret = self.num + other.num\n        ret %= self.mod\n        return ModInt(ret, self.mod)\n\n    def __sub__(self, other):\n        ret = self.num - other.num\n        ret %= self.mod\n        return ModInt(ret, self.mod)\n\n    def __mul__(self, other):\n        ret = self.num * other.num\n        ret %= self.mod\n        return ModInt(ret, self.mod)\n\n    def pow(self, times):\n        pw = pow(self.num, times, self.mod)\n        return ModInt(pw, self.mod)\n\n    def inverse(self):\n        return self.pow(self.mod - 2)\n\n    def __truediv__(self, other):\n        num = self * other.inverse()\n        return ModInt(num, self.mod)\n\n\nh, w, a, b = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nfact = [ModInt(1, mod)]\ninv = [ModInt(1, mod).inverse()] * (h + w - 1)\n\n\ndef comb(n, r):\n    return fact[n] * inv[r] * inv[n-r]\n\n\nfor i in range(1, h + w - 1):\n    fact.append(fact[-1] * ModInt(i, mod))\n\ninv[h+w-2] = fact[-1].inverse()\nfor i in range(h + w - 2, 0, -1):\n    inv[i-1] = inv[i] * ModInt(i, mod)\n\nans = ModInt(0, mod)\nfor hi in range(h - a):\n    ans += comb(hi + b - 1, hi) * comb(h - hi - 1 + w - b - 1, w - b - 1)\n\nprint(ans)\n", "H,W,A,B = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, H+W + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = 0\nfor h in range(1, H-A+1):\n    ans += cmb(h-1+B-1, h-1, mod)*cmb(H-h+W-B-1, H-h, mod)\n    ans %= mod\n\nprint(ans)", "H, W, A, B = [int(_) for _ in input().split()]\nmod = 10**9 + 7\n \nX = [i for i in range(H + W + 1)]\nX[0] = 1\nfor i in range(2, H + W + 1):\n    X[i] = X[i - 1] * i % mod\n \nY = X.copy()\nY[-1] = pow(Y[-1], mod - 2, mod)\nfor i in range(H + W, 1, -1):\n    Y[i - 1] = i * Y[i] % mod\n \n \ndef comb(x, y):\n    return X[x] * Y[y] * Y[x - y] % mod\n \n \nans = 0\nfor i in range(B, min(B + H - A, W)):\n    ans += comb(H - A + B - 1, i) * comb(W + A - B - 1, W - i - 1)\n    ans %= mod\nprint(ans)\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\n\nlim = 2*10**5   #\u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u529b\n\n#\u968e\u4e57#\nfact = [1] * (lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n * fact[n-1] % mod\n\n#\u968e\u4e57\u306e\u9006\u5143#\nfact_inv = [1]*(lim+1)\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n\tfact_inv[n-1] = n*fact_inv[n]%mod\n\ndef C(n, r):\n\treturn (fact[n]*fact_inv[r]%mod)*fact_inv[n-r]%mod\n\n\nH, W, A, B = MAP()\n\nans = 0\nfor n in range(B, W):\n\tway = C(H-A-1+n, n)*C(W-n-1+A-1, A-1)%mod\n\tans = (ans+way)%mod\n\nprint(ans)\n", "h, w, a, b = map(int, input().split())\n\nmod = 10**9 + 7\nfac = [1, 1]\ninv = [1, 1]\nfinv = [1, 1]\nfor i in range(2, h+w+5):\n    fac.append(fac[i-1] * i % mod)\n    inv.append(mod - inv[mod%i] * (mod//i) % mod)\n    finv.append(finv[i-1] * inv[i] % mod)\n\ndef nck(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\nans = 0\nfor i in range(h-a):\n    ans += nck(i+b-1, b-1) * nck(h-1-i + w-b-1, w-b-1) % mod\n    ans %= mod\n\nprint(ans)", "def cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 3 * 10 ** 5  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n    \ndef __starting_point():\n  H, W, A, B = list(map(int, input().split()))\n  #HW = [[0] * W for i in range(H)]\n  p = 10 ** 9 + 7\n  #print(HW)\n  #visited = [[0] * W for i in range(H)]\n  ans = 0\n  for i in range(H - A):\n    if i == 0:\n      ans += cmb(B + i, i, p) * cmb(H + W - B - 2 - i, H - 1 - i, p)\n      ans %= p\n    else:\n      ans += cmb(B + i - 1, i, p) * cmb(H + W - B - 2 - i, H - 1 - i, p)\n      ans %= p\n  print(ans)\n  \n\n__starting_point()", "# \u7df4\u7fd2\nimport math\nh,w,a,b = list(map(int, input().split()))\np = 10**9+7\n# \u65b9\u91dd\n# (0,0)    ~ (0,w-1)\n# (h-1,0 )~ (h-1,w-1)\u3067\u8003\u3048\u308b\n# \u901a\u308c\u306a\u3044\u306e\u306f(h-a) ~ (h-1)\u884c\u304b\u3064(0) ~ (b-1) \u5217\u306e\u3068\u3053\u308d\n# b <= i <= w-1 \u306ei\u306b\u3064\u3044\u30661,2,3\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\u305d\u308c\u305e\u308c\u4ee5\u4e0b\u306e\u901a\u308a \n# 1, (0,0) ~ (h-a-1,i)      (h-a-1+i)! /(h-a-1)! * i!\n# 2, (h-a-1,i )~(h-a,i)\u3000  1\n# 3, (h-a,i) ~ (h-1,w-1)   (a-1+w-1-i)! /(a-1)! * (w-1-i)!\ndef cmb(n, k, mod, fac, ifac):\n    \"\"\"\n    nCk\u3092\u8a08\u7b97\u3059\u308b\n    \"\"\"\n    k = min(k, n-k)\n    return fac[n] * ifac[k] * ifac[n-k] % mod\n\n\ndef make_tables(mod, n):\n    \"\"\"\n    \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u3001\u9006\u5143\u306e\u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u6210\u3059\u308b\n    \"\"\"\n    fac = [1, 1] # \u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(1)\n    ifac = [1, 1] #\u9006\u5143\u306e\u968e\u4e57\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(2)\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u30fb\u30fb\u30fb(3)\n\n    for i in range(2, n+1):\n        fac.append((fac[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        ifac.append((ifac[-1] * inverse[-1]) % mod)\n    return fac, ifac\n\nfac, ifac = make_tables(p, h+w-2)\ntotal = 0\nfor i in range(b, w):\n    r1 = cmb(h-a-1+i,i,p,fac, ifac)\n    r3 = cmb(a-1+w-1-i, a-1,p,fac, ifac)\n    \n    total = total +( r1*r3)\nprint(total%p)   ", "#\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u70b9\u691c\nclass Data():\n    def __init__(self):\n        self.power=1\n        self.rev=1     \nclass Combi():\n    def __init__(self,N,mod):\n        self.lists=[Data() for _ in range(N+1)]\n        self.mod=mod  \n        for i in range(2,N+1):\n            self.lists[i].power=((self.lists[i-1].power)*i)%self.mod\n        self.lists[N].rev=pow(self.lists[N].power,self.mod-2,self.mod)\n        for j in range(N,0,-1):\n            self.lists[j-1].rev=((self.lists[j].rev)*j)%self.mod\n\n    def combi(self,K,R):\n        if K<R:\n            return 0\n        else:\n            return ((self.lists[K].power)*(self.lists[K-R].rev)*(self.lists[R].rev))%self.mod\n\n######################\nh,w,a,b=list(map(int,input().split()))\nans=0\nmod=10**9+7\nC=Combi(w+h+2,mod)\nfor i in range(h-a):\n    ans+=C.combi(b+i-1,i)*C.combi(w+h-2-b-i,h-1-i)%mod\nprint((ans%mod))\n######################\n", "class Calc:\n    def __init__(self, max_value, mod):\n        \"\"\"combination(max_value, all)\"\"\"\n        fact = [-1] * (max_value + 1)\n        fact[0] = 1\n        fact[1] = 1\n        for x in range(2, max_value + 1):\n            fact[x] = x * fact[x - 1] % mod\n\n        invs = [1] * (max_value + 1)\n        invs[max_value] = pow(fact[max_value], mod - 2, mod)\n        for x in range(max_value - 1, 0, -1):\n            invs[x] = invs[x + 1] * (x + 1) % mod\n\n        self.fact = fact\n        self.invs = invs\n        self.mod = mod\n\n    def combination(self, n, r):\n        if n - r < r:\n            return self.combination(n, n - r)\n        if r < 0:\n            return 0\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return self.fact[n] * self.invs[r] * self.invs[n - r] % self.mod\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    H, W, A, B = list(map(int, input().split()))\n\n    calc = Calc(max_value=H + W, mod=MOD)\n\n    ans = 0\n    for x in range(B, W):\n        v = calc.combination(n=(H - A - 1) + x, r=x)\n        u = calc.combination(n=(A - 1) + (W - 1 - x), r=A - 1)\n        # (H-1)-(H-A)+(W-1)-x\n        ans = (ans + v * u) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n# import sys\n#\n# sys.setrecursionlimit(10 ** 7)\n#\n# input = sys.stdin.readline\n# rstrip()\n# int(input())\n# map(int, input().split())\n\n__starting_point()", "class Combination:\n    \"\"\"\n    SIZE\u304c10^6\u7a0b\u5ea6\u4ee5\u4e0b\u306e\u4e8c\u9805\u4fc2\u6570\u3092\u4f55\u56de\u3082\u547c\u3073\u51fa\u3057\u305f\u3044\u3068\u304d\u306b\u4f7f\u3046\n    \u4f7f\u3044\u65b9:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    H, W, A, B = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n\n    comb = Combination(2 * 10 ** 5 + 10, mod)\n\n    ans = 0\n    x = H - A\n    y = B + 1\n    while x > 0 and y <= W:\n        path1 = comb(x + y - 2, x - 1)\n        path2 = comb(H - x + W - y, H - x)\n        ans = (ans + path1*path2) % mod\n        x -= 1\n        y += 1\n\n    print(ans)\n\n__starting_point()", "H, W, A, B = list(map(int, input().split()))\n\n# H\u884cW\u5217 \u5de6\u4e0b\u304b\u3089\u7e26A\u6a2aB\n\ndef mod(num):\n    return num % (10 ** 9 + 7)\n    \nn = H + W + 1\n\nfac = [0] * n\nrev = [0] * n\n\nfac[0] = 1\n\nfor i in range(1, n):\n    fac[i] = mod(fac[i-1] * i)\n\n\n# \u9006\u5143\u306e\u8a08\u7b97 x**(-1) \u2261 x**(10**9 + 5) (mod 10**9 + 7)\nrev[n-1] = pow(fac[n-1], 10**9 + 5, 10**9 + 7)\n\nfor i in range(n - 2, 0, -1):\n    rev[i] = mod(rev[i + 1] * (i + 1))\n\nrev[0] = 1\n\nt1 = [0] * (W - B)\n\nfor i in range(W - B):\n    t1[i] = mod(fac[H - A - 1 + i + B] * mod(rev[B + i] * rev[H - A - 1]))\n    \nres = 0\n\nfor i in range(W - B):\n    r = t1[i] * mod(fac[A - 1 + W - B - 1 - i] * mod(rev[A - 1] * rev[W - B - 1 - i]))\n    res = mod(res + r)\n    \nprint(res)\n", "LIMIT = 2 * 10 ** 5\nfac = [0] * (LIMIT + 10)\nfac[0] = 1\ninv = [0] * (LIMIT + 10)\nMOD = 1_000_000_007\nn = 1\nfor i in range(1, LIMIT + 1):\n    n *= i\n    n %= MOD\n    fac[i] = n\ninv[LIMIT] = pow(fac[LIMIT], MOD - 2, MOD)\nfor i in range(LIMIT, -1, -1):\n    inv[i - 1] = (inv[i] * i) % MOD\ndef C(n, r):\n    return (fac[n] * inv[n-r] * inv[r]) % MOD\n\nH, W, A, B = list(map(int, input().split()))\nans = 0\nB1 = B - 1\nWB1 = W - B - 1\nfor i in range(H - A):\n    ans += C(i + B1, B1) * C(H - i - 1 + WB1, WB1)\n    ans %= MOD\nprint(ans)\n", "M=10**9+7\nH,W,A,B = map(int,input().split())\nC = 1\nans = 1\n\nfor I in range(H-1):\n  ans = C = C*(W+H-B-2-I)*pow(I+1,M-2,M)%M\n\nfor I in range(1,H-A):\n  C = C*(B-1+I)*(H-I)*pow(I*(W+H-B-1-I),M-2,M)%M\n  ans+=C\n\nprint(ans%M)", "H, W, A, B = [int(_) for _ in input().split()]\nmod = 10**9 + 7\n \nX = [i for i in range(H + W + 1)]\nX[0] = 1\nfor i in range(2, H + W + 1):\n    X[i] = X[i - 1] * i % mod\n \nY = X.copy()\nY[-1] = pow(Y[-1], mod - 2, mod)\nfor i in range(H + W, 1, -1):\n    Y[i - 1] = i * Y[i] % mod\n \n \ndef comb(x, y):\n    return X[x] * Y[y] * Y[x - y] % mod\n \n \nans = 0\nfor i in range(B, min(B + H - A, W)):\n    ans += comb(H - A + B - 1, i) * comb(W + A - B - 1, W - i - 1)\n    ans %= mod\nprint(ans)", "H, W, A, B = list(map(int, input().split()))\nC = H - A\nD = W - B\np = 1000000007\n\ndef power(a, b): #a^b (mod p)\u3092\u6c42\u3081\u308b #\u4e8c\u5206\u7d2f\u4e57\u6cd5\u3092\u4f7f\u3046\n    if b == 0:\n        return 1\n    elif b % 2 == 0:\n        return power(a, b//2) ** 2 % p\n    else:\n        return power(a, b//2) ** 2 * a % p\n\nf = [1] #f[i] = i! % p\nfor i in range(H+W):\n    f.append(f[i] * (i+1) % p)\n\nI_f = [0] * (H+W+1) #I_f[i] = (i!)^(-1) % p\nI_f[H+W] = power(f[H+W], p-2)\nfor i in reversed(list(range(H+W))):\n    I_f[i] = I_f[i+1] * (i+1) % p\n\ndef combi(a, b): #(a+b)!/a!b! (mod p)\u3092\u6c42\u3081\u308b\n    return f[a+b] * I_f[a] * I_f[b] % p\n\nx = 0\nfor i in range(C):\n    x = (x + combi(i, B-1) * combi(D-1, H-i-1)) % p\nprint(x)\n", "def main():\n    def cmb(n, r, mod):\n        if (r < 0 or r > n):\n            return 0\n        r = min(r, n-r)\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n    mod = 10**9+7  # \u51fa\u529b\u306e\u5236\u9650\n    N = 10**6\n    g1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range(2, N + 1):\n        g1.append((g1[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod//i)) % mod)\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n    H, W, A, B = list(map(int, input().split()))\n\n    ans = cmb((H+W-2), min(H, W)-1, mod)\n\n    tmp = 0\n    for i in range(B):\n        t = cmb(H-A-1+i, i, mod)\n        t *= cmb(W-1-i + A - 1, A-1, mod)\n        tmp += t\n        tmp %= mod\n    print(((ans - tmp) % mod))\n\n\nmain()\n", "#\u7e26H A\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = (10**5)*2\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nH,W,A,B=list(map(int,input().split()))\nans=0\nfor i in range(H-A):\n  ans+=cmb(B+i-1,B-1,mod) * cmb(H-i+W-B-2,W-B-1,mod)\nprint((ans%mod))\n# 1 1 1\n# $ 1 2\n", "class Combination:\n    \"\"\"\n    SIZE\u304c10^6\u7a0b\u5ea6\u4ee5\u4e0b\u306e\u4e8c\u9805\u4fc2\u6570\u3092\u4f55\u56de\u3082\u547c\u3073\u51fa\u3057\u305f\u3044\u3068\u304d\u306b\u4f7f\u3046\n    \u4f7f\u3044\u65b9:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\ndef __starting_point():\n    H, W, A, B = list(map(int, input().split()))\n    mod = 10**9+7\n    comb = Combination(2*10**5+10, mod)\n\n    ans = 0\n    h1 = H - A\n    w1 = B + 1\n    while True:\n        X = comb(h1 + w1 - 2, h1 - 1)\n        h2 = H - h1\n        w2 = W - w1\n        Y = comb(h2 + w2, h2)\n        ans += X * Y % mod\n        ans %= mod\n\n        h1 -= 1\n        w1 += 1\n        if h1 <= 0 or w1 > W:\n            break\n\n    print(ans)\n\n__starting_point()", "from sys import stdin\ninput = stdin.readline\n\nMAX = 510000\nMOD = 10**9 + 7\n\ndef MakeTable():\n    fac[0], fac[1] = 1, 1\n    finv[0], finv[1] = 1, 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\ndef COM(n, k):\n    if n < k:\n        return 0\n    elif n < 0 or k < 0:\n        return 0\n    else:\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\nH, W, A, B = map(int, input().split())\nfac = [0] * MAX\nfinv = [0] * MAX\ninv = [0] * MAX\n\nN = min(H-A, W-B)\nx, y = 0, 0\nresult = 0\n\nMakeTable()\n\nfor _ in range(N):\n    n1 = H-A-1+B+x-y\n    n2 = A+W-1-B-x+y\n    result += (COM(n1, B+x) * COM(n2, A+y)) % MOD\n    x += 1\n    y += 1\n\nprint(result%MOD)", "h,w,a,b=map(int,input().split())\n#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u9006\u5143\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nans=cmb(h+w-2,h-1,mod)\nfor i in range(h-a+1,h+1):\n    ans-=cmb(i+b-2,i-1,mod)*cmb(h-i+w-b-1,w-b-1,mod)\n    ans%=mod\nprint(ans)", "h, w, a, b = map(int, input().split())\nmod = 10 ** 9 + 7\nn = h + w\n\nf = [1 for _ in range(n)]\nf_inv = [1 for _ in range(n)]\nfor i in range(1, n):\n    f[i] = f[i-1] * i % mod\n    f_inv[i] = pow(f[i], mod-2, mod)\n\n\ndef comb(n, k):\n    return (f[n] * f_inv[k] % mod) * f_inv[n-k] % mod\n\nans = comb(h+w-2, h-1)\nfor i in range(b):\n    ans -= comb(h-a+i-1, i) * comb(a+w-i-2, a-1) % mod\n    ans %= mod\n\nprint(ans)", "mod = 10 ** 9 + 7\nN = 10 ** 6\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, N + 1):\n    fact.append(fact[-1] * i % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\ndef combi_mod(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n - r] % p\n\n\nH, W, A, B = list(map(int, input().split()))\n\nif B < W / 2:\n    not_ans = 0\n    total = combi_mod((H - 1) + (W - 1), H-1, mod)\n    for i in range(B):\n        sq1h = H - A\n        sq1w = i + 1\n        sq2h = A\n        sq2w = W - i\n        n = combi_mod((sq1h -1) + (sq1w - 1), (sq1h -1), mod) * combi_mod((sq2h - 1) + (sq2w - 1), (sq2h - 1), mod) % mod\n        not_ans = (not_ans + n) % mod\n    ans = (total - not_ans) % mod\n    print(ans)\n        \nelse:\n    ans = 0\n    for i in range(B, W):\n        sq1h = H - A\n        sq1w = i + 1\n        sq2h = A\n        sq2w = W - i\n        n = combi_mod((sq1h - 1) + (sq1w - 1), (sq1h - 1), mod) * combi_mod((sq2h - 1) + (sq2w - 1), (sq2h - 1), mod)\n        ans = (ans + n) % mod\n    ans %= mod\n    print(ans)\n", "MOD = 10**9+7\n\nh,w,a,b = map(int,input().split())\n\nn = h+w\nfac = [1]*(n+1)\nfac_inv =  [0]*(n+1)\n\nfor i in range(n):\n    fac[i+1] = (fac[i] * (i+1)) %MOD\nfac_inv[-1] = pow(fac[-1],MOD-2,MOD)\nfor i in range(n,0,-1):\n    fac_inv[i-1] = (fac_inv[i] * i) % MOD\n    \ndef comb(n,k):\n    if k<0 or k>n:\n        return 0\n    x = (fac[n] * (fac_inv[k] * fac_inv[n-k])%MOD)%MOD\n    return x\n\nans = 0\n\nfor i in range(w-b):\n    \n    ans += comb((h-a-1) + b+i, b+i) * comb((a-1) + (w - b-i-1), a-1) %MOD\n    ans %= MOD\n    \nprint(ans)", "# -*- coding: utf-8 -*-\n#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\ndef cmb(n, r):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n\nN = 2 * 10 ** 5 + 1000  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nmod = pow(10, 9) + 7\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\nans = 0\nh, w, a, b = list(map(int,input().split()))\nfor i in range(h - a):\n    #print(b - 1 + i, i, w - b - 1 + h - i - 1, w - b - 1)\n    ans += (cmb(b - 1 + i, i) * cmb(w - b -  1 + h - i - 1, w - b - 1)) % (10 ** 9 + 7)\nprint((ans % (10 ** 9 + 7)))\n", "H, W, A, B = map(int, open(0).read().split())\nMOD = 10**9+7\n\ndef modcomb(m, n, mod):\n    if n > m - n:\n        n = m - n\n    p = 1\n    q = 1\n    for i in range(n):\n        p = p * (m - i) % mod\n        q = q * (i + 1) % mod\n    result = p * pow(q, mod - 2, mod) % mod\n    return result\n\ntotal = modcomb(H + W - 2, W - 1, MOD)\n\ntmp = modcomb(A + W - 2, W - 1, MOD)\ntotal -= tmp\n\nfor i in range(B - 1):\n    a = H - A + i\n    b = i + 1\n    c = W - i - 1\n    d = W + A - 2 - i\n#     print(a,b,c,d)\n    tmp = tmp * a * c % MOD\n    tmp = tmp * pow(b, -1, MOD) % MOD\n    tmp = tmp * pow(d, -1, MOD) % MOD\n#     print(tmp)\n    total = (total - tmp) % MOD\n\nprint(total)", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\nh, w, a, b = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nfacts, invs = prepare(h + w, MOD)\nans = 0\nib = invs[b - 1]\niwb = invs[w - b - 1]\nfor down in range(h - a):\n    left_pattern = facts[b - 1 + down] * ib * invs[down] % MOD\n    right_pattern = facts[h - 1 - down + w - b - 1] * invs[h - 1 - down] * iwb % MOD\n    ans = (ans + left_pattern * right_pattern) % MOD\nprint(ans)\n", "h, w, a, b = list(map(int, input().split()))\nm = 10**9 + 7\n\nfac = [1, 1]\ninv = [1, 1]\nfinv = [1, 1]\nfor i in range(2, w+h+5):\n    fac.append(fac[i-1] * i % m)\n    inv.append(m - inv[m%i] * (m//i) % m)\n    finv.append(finv[i-1] * inv[i] % m)\n\ndef nck(n, k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % m) % m\n\n\nrow = []\nfor i in range(h-a):\n    row.append(nck(b+i, i))\n\nans = 0\nfor i in range(len(row)-1):\n    ans += row[i] * nck(w-b-2 + h-1-i, h-1-i)\n    ans %= m\n\nans += row[-1] * nck(w-b-1 + a, a)\nans %= m\n\nprint(ans)\n", "mod = 10 ** 9 + 7\nfact = [1]\ninv = [1]\nfor i in range(200000):\n  fact.append(fact[i] * (i + 1) % mod)\n  inv.append(pow(fact[i + 1], mod - 2, mod))\ndef ncr(n, r):\n  if n < 0 or r < 0 or n - r < 0:\n    return 0\n  return fact[n] * inv[r] * inv[n - r] % mod\nh, w, a, b = list(map(int, input().split()))\nans = ncr(h + w - 2, h - 1)\nfor i in range(min(a, b)):\n  ans -= ncr(h - a + b - 1, h - a + i) * ncr(w - b + a - 1, w - b + i)\nprint((ans % mod))\n", "h,w,a,b=list(map(int,input().split()))\nfac=[0]*200001#i\u306e\u968e\u4e57mod(1000000007)\ninv=[0]*200001#i\u306e\u9006\u5143mod(1000000007)\nfac[0]=1\nans=0\nfor i in range(1,200001):\n    fac[i]=fac[i-1]*i%1000000007\ninv[200000]=pow(fac[200000],1000000005,1000000007)\nfor i in range(199999,0,-1):\n    inv[i]=(inv[i+1]*(i+1))%1000000007\n    inv[0]=1\nfor i in range(h-a):\n    if i==0:\n        if h==1:\n            x=1\n        else:\n            x=(fac[w-b+h-2\n                   -i]*inv[w-1-b]*inv[h-1-i])%1000000007\n    else:\n        x=((fac[b-1+i]*inv[b-1]*inv[i])%1000000007)*((fac[w-b+h-2-i]*inv[w-b-1]*inv[h-1-i])%1000000007)\n    ans=(ans+x)%1000000007\nprint(ans)\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\n\nlim = 2*10**5   #\u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u529b\n\n#\u968e\u4e57#\nfact = [1] * (lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n * fact[n-1] % mod\n\n#\u968e\u4e57\u306e\u9006\u5143#\nfact_inv = [1]*(lim+1)\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n\tfact_inv[n-1] = n*fact_inv[n]%mod\n\ndef C(n, r):\n\treturn (fact[n]*fact_inv[r]%mod)*fact_inv[n-r]%mod\n\n\nH, W, A, B = MAP()\n\nans = 0\nfor n in range(B, W):\n\tway = C(H-A-1+n, n)*C(W-n-1+A-1, A-1)%mod\n\tans = (ans+way)%mod\n\nprint(ans)", "class CombinationFermat:\n\n    def __init__(self):\n        \"\"\"O(MAX)\u3067\u524d\u8a08\u7b97\u3057\u3066\u304a\u304f\u2192\u4ee5\u964dcomb(a,b)\u306fO(1)\u3067\u53d6\u5f97\u53ef\u80fd\n        \"\"\"\n        MOD = 10**9 + 7\n        MAX = 2*10**5\n\n        self.fac = [0]*MAX   # self.fac[n]:  (n!) mod p\n        self.finv = [0]*MAX  # self.finv[n]: (n!)^-1 mod p\n        self.inv = [0]*MAX   # inv[n]:  (n)^-1 mod -p\n        self.fac[0] = self.fac[1] = 1\n        self.finv[0] = self.finv[1] = 1\n        self.inv[1] = 1\n        for i in range(2, MAX):\n            self.fac[i] = self.fac[i-1] * i % MOD\n            self.inv[i] = MOD - self.inv[MOD % i] * (MOD//i) % MOD\n            self.finv[i] = self.finv[i-1] * self.inv[i] % MOD\n\n    def comb(self, n: int, r: int) -> int:\n        MOD = 10**9 + 7\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n        return self.fac[n] * (self.finv[r] * self.finv[n-r] % MOD) % MOD\n\n\nH, W, A, B = list(map(int, input().split()))\nc = CombinationFermat()\nans = 0\nMOD = 10**9 + 7\n\nfor i in range(H-A):\n    x = c.comb(B-1+i, i)\n    a = H-1-i\n    b = W-1-B\n    x *= c.comb(a+b, a)\n    x %= MOD\n    ans += x\nans %= MOD\nprint(ans)\n", "mod = 10**9 + 7\nh, w, a, b = map(int, input().split())\n\nfact = [1] * (h + w + 1)\ninvf = [1] * (h + w + 1)\ninvn = [1] * (h + w + 1)\nfor i in range(2, h + w + 1):\n  fact[i] = fact[i-1] * i % mod\n  invn[i] = (-invn[mod % i]) * (mod // i) % mod\n  invf[i] = invf[i-1] * invn[i] % mod\n\ncount = 0\nfor i in range(min(h-a, w-b)):\n  count += fact[h+b-a-1] * invf[h-a-i-1] * invf[b+i] * fact[w+a-b-1] * invf[a+i] * invf[w-b-i-1]\n  count %= mod\nprint(count)", "def permutation(n, k, mod):\n    s = 1\n    for _ in range(k):\n        s *= n\n        s %= mod\n        n -= 1\n    return s\n\ndef factorial(n, mod):\n    s = 1\n    for i in range(1, n + 1):\n        s *= i\n        s %= mod\n    return s\n\nh, w, a, b = map(int, input().split())\nmod = pow(10, 9) + 7\nx = h - a + b - 1\ny = w - b + a - 2\np = permutation(x, h - a - 1, mod) * permutation(y, a - 1, mod) % mod\nans = p\nfor _ in range(w - b - 1):\n    x += 1\n    p = p * x * (y - (a - 1)) * pow((x - (h - a - 1)) * y, mod - 2, mod) % mod\n    y -= 1\n    ans += p\n    ans %= mod\nans = ans * pow(factorial(a - 1, mod), mod - 2, mod) * pow(factorial(h - a - 1, mod), mod - 2, mod) % mod\nprint(ans)", "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**9)\n\ndef mul(x, y, mod):\n  x %= mod\n  y %= mod\n  return x * y % mod\n\ndef div(x, y, mod):\n  x %= mod\n  y %= mod\n  return x * mod_pow(y, mod - 2, mod) % mod\n\n@lru_cache(maxsize=None)\ndef mod_pow(a, p, mod):\n  if p == 0:\n    return 1\n  if p % 2 == 0:\n    root = mod_pow(a, p / 2, mod)\n    return root * root % mod\n  else:\n    return a * mod_pow(a, p - 1, mod) % mod\n\ndef dnm(n, mod, factorials):\n  denominators = [0] * (n + 1)\n  denominators[n] = div(1, factorials, mod)\n  for i in reversed(range(n)):\n    denominators[i] = mul(denominators[i+1], i+1, mod)\n  return denominators\n\ndef nmr(n, mod):\n  factorials = [0] * (n + 1)\n  factorials[0] = 1\n  for i in range(n):\n    factorials[i + 1] = (i + 1) * factorials[i] % mod\n  return factorials\n\ndef cmb(a, b, mod, factorials, factorial_divs):\n    if len(factorials) == 0:\n        raise\n    af = factorials[a]\n    bf = factorial_divs[b]\n    abf = factorial_divs[a - b]\n    return mul(mul(af, bf, mod), abf, mod)\n\nMOD=10**9+7\nH,W,A,B=map(int,input().split())\nans = 0\n\nn = nmr(H+W-2, MOD)\nd = dnm(H+W-2, MOD, n[H+W-2])\n\nfor i in range(H-A):\n  x = cmb(B-1+i, B-1, MOD, n, d)\n  y = cmb(H+W-3-(B-1+i), W-B-1, MOD, n, d)\n  ans += x * y % MOD\n  ans %= MOD\n\nprint(ans)", "h,w,a,b=map(int,input().split())\nmod=pow(10,9)+7\n\n# \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u3001\u3055\u3089\u306b\u9ad8\u901f\u3002\u3042\u3089\u304b\u3058\u3081O(N)\u306e\u8a08\u7b97\u3092\u3059\u308b\u3053\u3068\u3067\u306e\u3061\u306e\u8a08\u7b97\u304c\u65e9\u304f\u306a\u308b\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\ng1 = [1, 1] \ng2 = [1, 1] \ninverse = [0, 1]\nfor i in range( 2, 200000 + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nans=0\nfor k in range(1,h-a+1):\n  tmp=cmb(k-1+b-1,k-1,mod)\n  tmp*=cmb(h-k+w-b-1,h-k,mod)\n  ans+=tmp\n  ans%=mod\nprint(ans)", "h, w, a, b = list(map(int, input().split()))\n\nMOD = 1000000007\n\n\ndef modPow(a, x, p):\n    res = 1\n    while (x > 0):\n        if (x % 2 != 0):\n            res = (res * a) % p\n        a = (a * a) % p\n        x /= 2\n    return res\n\n\nfact = [None] * 220000\n\nfor i in range(1, 220000):\n    fact[0] = 1\n    fact[i] = i * fact[i - 1] % MOD\n    # inv[i] = modPow(fact[i], MOD-2, MOD)\n\n\ndef ncr(n, r):\n    den = fact[n - r] * fact[r] % MOD\n    return fact[n] * pow(den, MOD - 2, MOD) % MOD\n\n\ndef number_of_paths(h, w):\n    n = h + w - 2\n    r = h - 1\n    return ncr(n, r)\n\n\nans = 0\nfor i in range(b + 1, w + 1):\n    # print('first', h-a, i)\n    ans += number_of_paths(h - a, i) * number_of_paths(a, w - i + 1)\n\nprint((int(ans % MOD)))\n", "def combmod_pre(N, p):\n    '''\n    sample usage:\n        p = 10**9+7\n        N = 10**6\n        fact, finv = combmod_pre(N, p)\n        combmod(n, r, p)\n    '''\n    fact = [1, 1]\n    finv = [1, 1]\n    inv = [0, 1]\n    for i in range(2, N+1):\n        fact.append((fact[-1] * i) % p)\n        inv.append((-inv[p % i] * (p // i)) % p)\n        finv.append((finv[-1] * inv[-1]) % p)\n    return (fact, finv)\n\n\ndef combmod(n, r, fact, finv, p):\n    '''\n    sample usage:\n        combmod(3000, 1000, fact, finv, p)\n            p is a same value of combmod_pre's argument\n            fact, finv is return value of combmod_pre\n    '''\n    if r < 0 or n < r:\n        return 0\n    return fact[n] * finv[r] * finv[n-r] % p\n\n\np = 10**9+7\nN = 10**6\nfact, finv = combmod_pre(N, p)\n\nh, w, a, b = (int(x) for x in input().split())\nans = 0\nfor j in range(b, w):\n    x = combmod(h - a - 1 + j, j, fact, finv, p)\n    y = combmod(a + w - 2 - j, w-1 - j, fact, finv, p)\n    ans += x * y\nprint((ans % p))\n\n\n", "MOD = 10**9 + 7\nMAX = 2*10**5\nfac = [0]*MAX  # fac[n]:  (n!) mod p\nfinv = [0]*MAX  # finv[n]: (n!)^-1 mod p\ninv = [0]*MAX  # inv[n]:  (n)^-1 mod -p\n\n\ndef comb_init():\n    nonlocal fac, finv, inv\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = MOD - inv[MOD % i] * (MOD//i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n\n\ndef comb(n: int, r: int) -> int:\n    nonlocal fac, finv\n    if n < r:\n        return 0\n    if n < 0 or r < 0:\n        return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\n\nH, W, A, B = list(map(int, input().split()))\ncomb_init()\nans = 0\n\nfor i in range(H-A):\n    x = comb(B-1+i, i)\n    a = H-1-i\n    b = W-1-B\n    x *= comb(a+b, a)\n    x %= MOD\n    ans += x\nans %= MOD\nprint(ans)\n", "h,w,a,b = map(int, input().split())\nmx = max(h,w)\nmod = 10**9+7\nfac = [1]*(h+w+1)\nfor i in range(1,h+w+1):\n\tfac[i]=fac[i-1]*i%mod\nrev = [1]*(mx+1)\nrev[-1] = pow(fac[mx], mod-2, mod)\nfor i in range(mx-1, -1, -1):\n\trev[i] = rev[i+1]*(i+1)%mod\nconst = rev[h-a-1]*rev[a-1]%mod\nans = 0\nfor i in range(b,w):\n\tans += fac[h-a+i-1]*rev[i]*fac[a+w-2-i]*rev[w-i-1]%mod\nprint(ans*const%mod)", "from math import comb\nh,w,a,b = list(map(int,input().split()))\ns = 0\nnC = b-1\nkC = 0\nnD = w-b-1+h-1\nkD = h-1\np = 1000000007\nfac = [1]\nff = 1\nfor i in range(1,200001):\n  ff *= i\n  ff %= p\n  fac.append(ff)\ndef ncr(n, r, p): \n  return (fac[n] * pow(fac[r], p-2, p) % p * pow(fac[n-r], p-2, p) % p);\n\nfor i in range(h-a):\n  C = ncr(nC, kC, 1000000007)\n  D = ncr(nD, kD, 1000000007)\n  s = (s + C * D) % 1000000007\n  nC += 1\n  kC += 1\n  kD -= 1\n  nD -= 1\nprint(s)\n", "MOD = 10 ** 9 + 7\n\n\ndef prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\ndef pathVar(sx, sy, gx, gy):\n    x = gx - sx\n    y = gy - sy\n    rst = modFacts[x + y]\n    rst *= invs[x] * invs[y]\n    rst %= MOD\n    return rst\n\n\nH, W, A, B = list(map(int, input().split()))\n# H -= 1; W -= 1\nmodFacts, invs = prepare(H + W)\n\ncnt = 0\nwhile A > 0 and B > 0:\n    x = H - A\n    y = B - 1\n    path1 = pathVar(0, 0, x, y)\n    path2 = pathVar(x, y, H - 1, W - 1)\n    cnt += path1 * path2\n    cnt %= MOD\n    A -= 1; B -= 1\n\nans = pathVar(0, 0, H - 1, W - 1)\nprint(((ans - cnt) % MOD))\n", "MOD = 10**9+7\nfac = [1 for k in range(200010)]\ninv = [1 for k in range(200010)]\nfinv = [1 for k in range(200010)]\nfor k in range(2,200010):\n    fac[k] = (fac[k-1]*k)%MOD\n    inv[k] = (MOD - inv[MOD%k] * (MOD // k))%MOD\n    finv[k] = (finv[k - 1] * inv[k]) % MOD;\ndef nCr(n,r):\n    return (fac[n]*finv[r]*finv[n-r])%MOD\n\nH, W, A, B = list(map(int,input().split()))\nans = 0\n\nfor k in range(W-B):\n    ans += nCr(A+W-B-k-2,A-1)*nCr(B+k+1+H-A-2,H-A-1)\n    ans %= MOD\n\nprint(ans)\n", "def cmb1(n,r,mod):\n    if (r<0 or r>n):\n        return 0\n    r = min(r,n-r)\n    return g1[n]*g2[r]*g2[n-r]%mod\n \nh,w,a,b=map(int,input().split())\n \n# \u524d\u51e6\u7406\nmod=10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nn=10**6\ng1=[1,1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2=[1,1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse=[0,1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n \nfor i in range(2,n+1):\n    g1.append((g1[-1]*i)%mod)\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g2.append((g2[-1]*inverse[-1])%mod)\n\nans=0\nfor i in range(b,w):\n    ans+=cmb1(h-a-1+i,i,mod)*cmb1(a-1+w-1-i,a-1,mod)\n    ans%=mod\nprint(ans)", "import math\n\nh, w, a, b = list(map(int, input().split()))\n\n#divmod\nmod = pow(10,9)+7\ndef divmod(num, mod=10**9+7):\n    return pow(num, mod-2, mod)\n\n#combination\ndef comb(a,b):\n\tp=fact[a-b]*fact[b]%mod\n\treturn fact[a]*divmod(p)%mod\n\nfact = [1]\nfor i in range(1,h+w):\n    fact.append(i*fact[i-1]%mod)\n#print(fact)\n\nans = 0\nfor j in range(h-a):\n    tmp = comb(b-1+j,j)*comb(w+h-b-2-j,w-b-1)%mod\n    ans += tmp\n    ans = ans%mod\n#    ans = ans + fact[b-1+j]*fact[w+h-b-2-j]/fact[b-1]/fact[j]/fact[w-b-1]/fact[h-1-j]\nprint((int(ans)))\n\n'''\n\u5358\u7d14\u306ah*w\u306e\u30de\u30b9\u76ee\u3060\u3063\u305f\u5834\u5408\n#h-row / w-col\ncon = [[0]*w]*h\nfor i in range(h):\n    con[i][0] = 1\nfor j in range(w):\n    con[0][j] = 1\n\nfor k in range(1,h):\n    for l in range(1,w):\n        con[k][l] = con[k-1][l] + con[k][l-1]\n\nprint(con[h-1][w-1])\n'''\n\n'''\n\u5168\u91cf\u3092\u8a08\u7b97\u3059\u308b\u3084\u308a\u65b9\nH*W\u304c\u30c7\u30ab\u3059\u304e\u308b\u3068\u6642\u9593\u3068\u3044\u3046\u3088\u308a\u3082\u30e1\u30e2\u30ea\u30a8\u30e9\u30fc\nprint('initialize')\ncon = [[0 for i in range(w)] for j in range(h)]\n#\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u3067\u4f5c\u3089\u306a\u3044\u3068\u30d0\u30b0\u308b\n#\u30c0\u30e1\u306a\u4f8b -> con = [[0]*w]*h\n#https://qiita.com/utgwkk/items/5ad2527f19150ae33322\nprint('initialize finished')\n\n\nfor i in range(h-a):\n    con[i][0] = 1\n#print(con[0])\nfor j in range(w):\n    #w\u306f\u5148\u306b\u521d\u671f\u5316\u3084\u3063\u3061\u3083\u3046\n    con[0][j] = 1\n#print(con)\n\nfor k in range(1,h-a):\n#    print(k)\n    for l in range(1,b+1):\n        con[k][l] = con[k-1][l] + con[k][l-1]\n#print(con[h-a-1][b-1])\n#print(con[h-a][b-1])\n#print(con[h-a-1][b])\n\nfor m in range(1,h):\n#    print('---{} row---'.format(m))\n#    print(con[m])\n    for n in range(b,w):\n#        print('m,n:('+str(m)+','+str(n)+')')\n        con[m][n] = con[m-1][n] + con[m][n-1]\n#    print(con[m])\n\nprint(con[h-1][w-1])\n'''\n\n", "g1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nMOD = 10**9+7\nfor i in range(2, 2*10**5+1):\n    g1.append((g1[-1] * i) % MOD)\n    inverse.append((-inverse[MOD % i] * (MOD // i)) % MOD)\n    g2.append((g2[-1] * inverse[-1]) % MOD)\n\ndef comb(n, r, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nH, W, A, B = map(int, input().split())\nans = 0\nn = H + W - B - 1\nfor i in range(1, H-A+1):\n  ans += comb(n-i, H-i) * comb(B+i-2, B-1) % MOD\n  ans %= MOD\n\nprint(ans)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nlim = 2*10**6\nfact = [1]*(lim+1)\nfor n in range(1, lim+1):\n\tfact[n] = n*fact[n-1]%mod\n\nfact_inv = [1]*(lim+1)\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n\tfact_inv[n-1] = n*fact_inv[n]%mod\n\ndef C(n, r):\n\treturn (fact[n]*fact_inv[r]%mod)*fact_inv[n-r]%mod\n\nH, W, A, B = MAP()\n\nans = 0\nfor n in range(B, W):\n\tway = C(H-A-1+n, n)*C(W-n-1+A-1, A-1)%mod\n\tans = (ans+way)%mod\n\nprint(ans)\n", "import math\np=1000000007\ng1=[1,1]\ng2=[1,1]\ninverse=[0,1]\nfor i in range(2,2*(10**5)+1):\n    g1.append((g1[-1]*i)%p)\n    inverse.append((-inverse[p%i]*(p//i))%p)\n    g2.append((g2[-1]*inverse[-1])%p)\ndef cmb2(n, r, mod):\n    if (r<0 or r>n):return 0\n    r = min(r,n-r)\n    return g1[n]*g2[r]*g2[n-r]%mod\ndef chwp(h,w,p):\n    if h==1 or w==1:return 1\n    else:return cmb2(h+w-2,h-1,p)\nh,w,a,b= map(int,input().split())\nans=0\nfor i in range(1,h-a+1):ans=(ans+chwp(i,b,p)*chwp(h-i+1,w-b,p))%p\nprint(ans)", "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit(10**9)\n \ndef mul(x, y, mod):\n  x %= mod\n  y %= mod\n  return x * y % mod\n \ndef div(x, y, mod):\n  x %= mod\n  y %= mod\n  return x * mod_pow(y, mod - 2, mod) % mod\n \n@lru_cache(maxsize=None)\ndef mod_pow(a, p, mod):\n  if p == 0:\n    return 1\n  if p % 2 == 0:\n    root = mod_pow(a, p / 2, mod)\n    return root * root % mod\n  else:\n    return a * mod_pow(a, p - 1, mod) % mod\n \ndef dnm(n, mod, factorials):\n  denominators = [0] * (n + 1)\n  denominators[n] = div(1, factorials, mod)\n  for i in reversed(range(n)):\n    denominators[i] = mul(denominators[i+1], i+1, mod)\n  return denominators\n \ndef nmr(n, mod):\n  factorials = [0] * (n + 1)\n  factorials[0] = 1\n  for i in range(n):\n    factorials[i + 1] = (i + 1) * factorials[i] % mod\n  return factorials\n \ndef cmb(a, b, mod, factorials, factorial_divs):\n    if len(factorials) == 0:\n        raise\n    af = factorials[a]\n    bf = factorial_divs[b]\n    abf = factorial_divs[a - b]\n    return mul(mul(af, bf, mod), abf, mod)\n \nMOD=10**9+7\nH,W,A,B=map(int,input().split())\nans = 0\n \nn = nmr(H+W-2, MOD)\nd = dnm(H+W-2, MOD, n[H+W-2])\n \nfor i in range(H-A):\n  x = cmb(B-1+i, B-1, MOD, n, d)\n  y = cmb(H+W-3-(B-1+i), W-B-1, MOD, n, d)\n  ans += x * y % MOD\n  ans %= MOD\n \nprint(ans)", "class Combination():\n    # \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\n    def __init__(self, N:int, P:int):\n        self.N = N\n        self.P = P\n\n        # fact[i] = (i! mod P)\n        self.fact = [1, 1]   \n        # factinv[i] = ((i!)^(-1) mod P)\n        self.factinv = [1, 1]\n        # factinv \u8a08\u7b97\u7528\n        self.inv = [0, 1]    \n\n        for i in range(2, N+1):\n            self.fact.append((self.fact[-1] * i) % P)\n            self.inv.append((-self.inv[P % i] * (P // i)) % P)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % P)\n    \n    # nCk (mod P)   (\u305f\u3060\u3057\u3001n<=N)\n    def getComb(self, n:int, k:int):\n        if (k < 0) or (n < k):\n            return 0\n        k = min(k, n - k)\n        return self.fact[n] * self.factinv[k] * self.factinv[n-k] % self.P\n\ndef main():\n    H,W,A,B = map(int,input().split())\n    MOD = 10**9 + 7\n\n    COMB = Combination(H+W, MOD)\n\n    # (1,1) -> (i,B-1) -> (i,B+1) -> (H,W)\n\n    ans = 0\n    for i in range(1,H-A+1):\n        tmp = COMB.getComb((i-1)+(B-1), i-1)\n        tmp *= COMB.getComb((H-i)+(W-B-1), H-i)\n        ans = (ans + tmp) % MOD\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()"]
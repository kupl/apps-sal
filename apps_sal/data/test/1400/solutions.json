["from sys import stdin, stdout, exit\n\nmod = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, mod-2, mod)\n\nN = 2*10**5 + 10\nfacts = [1]*N\nfor i in range(1,N):\n    facts[i] = facts[i-1] * i\n    facts[i] %= mod\n\ndef binom(n, k):\n    ans = modinv(facts[k]) * modinv(facts[n-k])\n    ans %= mod\n    ans *= facts[n]\n    ans %= mod\n    return ans\n\n#print(\"Finished preprocess\")\n\nn, T = list(map(int, stdin.readline().split()))\nts = list(map(int, stdin.readline().split()))\n\nans = 0\ntotal = sum(ts)\nrunning = total\nlast_idx = n-1\nwhile running > T:\n    running -= ts[last_idx]\n    last_idx -= 1\n#print(last_idx+1)\n\nlast_bd = -1\nlast_sum = 0\nidx = last_idx\nwhile running + idx + 1 > T:\n    bd = T - running\n#    print(\"time remaining for\", idx+1, \"flips is\", bd)\n    cur_sum = last_sum + (binom(idx+1, last_bd) if last_bd >= 0 else 0)\n    cur_sum *= modinv(2)\n    cur_sum %= mod\n    for fresh in range(last_bd+1, bd+1):\n        cur_sum += binom(idx+1, fresh)\n        cur_sum %= mod\n #   print(\"pr of\", idx+1, \"flips is\", cur_sum, cur_sum / (2**(idx+1)))\n    ans += cur_sum * modinv(pow(2, idx+1, mod))\n    ans %= mod\n    running -= ts[idx]\n    last_bd = bd\n    last_sum = cur_sum\n    idx -= 1\n\n#print(idx+1, \"freebies\")\nans += idx+1\nans %= mod\nprint(ans)\n", "MOD = 10 ** 9 + 7\nMAX = 5 * 10 ** 5\nfac, ifac = [1] * MAX, [1] * MAX\nfor i in range(2, MAX):\n    fac[i] = fac[i - 1] * i % MOD\nifac[-1] = pow(fac[-1], MOD - 2, MOD)\nfor i in range(MAX - 2, 1, -1):\n    ifac[i] = ifac[i + 1] * (i + 1) % MOD\nipow2 = [1] * MAX\nfor i in range(1, MAX):\n    ipow2[i] = ipow2[i - 1] * (MOD + 1) // 2 % MOD\n\nchoose = lambda n, k: fac[n] * ifac[k] % MOD * ifac[n - k] % MOD\n\nn, t = map(int, input().split())\na = list(map(int, input().split()))\n\ns = 0\np = [1] + [0] * (n + 1)\nk = cur = 0\nfor i in range(n):\n    s += a[i]\n    if s > t: break\n    if s + i + 1 <= t:\n        p[i + 1] = 1\n        continue\n    if not cur:\n        k = t - s\n        for j in range(k + 1):\n            cur += choose(i + 1, j)\n        cur %= MOD\n    else:\n        cur = cur * 2 - choose(i, k)\n    while k > t - s:\n        cur -= choose(i + 1, k)\n        k -= 1\n    cur %= MOD\n    p[i + 1] = cur * ipow2[i + 1] % MOD\n\nprint(sum((p[i] - p[i + 1]) * i % MOD for i in range(1, n + 1)) % MOD)", "MOD = 10 ** 9 + 7\nMAX = 5 * 10 ** 5\nfac, ifac, ipow2 = [1] * MAX, [1] * MAX, [1] * MAX\nfor i in range(1, MAX):\n    fac[i] = fac[i - 1] * i % MOD\n    ifac[i] = pow(fac[i], MOD - 2,MOD)\n    ipow2[i] = ipow2[i - 1] * (MOD + 1) // 2 % MOD\n\nchoose = lambda n, k: fac[n] * ifac[k] % MOD * ifac[n - k] % MOD\n\nn, t = map(int, input().split())\na = list(map(int, input().split()))\n\ns = 0\np = [1] + [0] * (n + 1)\nk = cur = 0\nfor i in range(n):\n    s += a[i]\n    if s > t: break\n    if s + i + 1 <= t:\n        p[i + 1] = 1\n        continue\n    newk = t - s\n    cur = cur * 2 - choose(i, k) if cur else sum(choose(i + 1, j) for j in range(newk + 1)) % MOD\n    if newk < k:\n        cur -= sum(choose(i + 1, x) for x in range(k, newk, -1))\n    cur %= MOD\n    p[i + 1] = cur * ipow2[i + 1] % MOD\n    k = newk\n\nprint(sum((p[i] - p[i + 1]) * i % MOD for i in range(1, n + 1)) % MOD)", "MOD = 10 ** 9 + 7\nMAX = 5 * 10 ** 5\nfac, ifac, ipow2 = [1] * MAX, [1] * MAX, [1] * MAX\nfor i in range(1, MAX):\n    fac[i] = fac[i - 1] * i % MOD\n    ifac[i] = pow(fac[i], MOD - 2, MOD)\n    ipow2[i] = ipow2[i - 1] * (MOD + 1) // 2 % MOD\n\nchoose = lambda n, k: fac[n] * ifac[k] % MOD * ifac[n - k] % MOD\n\nn, t = map(int, input().split())\na = list(map(int, input().split()))\n\ns = 0\np = [1] + [0] * (n + 1)\nk = cur = 0\nfor i in range(n):\n    s += a[i]\n    if s > t: break\n    if s + i + 1 <= t:\n        p[i + 1] = 1\n        continue\n    newk = t - s\n    cur = cur * 2 - choose(i, k) if cur else sum(choose(i + 1, j) for j in range(newk + 1))\n    if newk < k:\n        cur -= sum(choose(i + 1, x) for x in range(k, newk, -1))\n    cur %= MOD\n    p[i + 1] = cur * ipow2[i + 1] % MOD\n    k = newk\n\nprint(sum((p[i] - p[i + 1]) * i % MOD for i in range(1, n + 1)) % MOD)", "mod = 10 ** 9 + 7\nMAX = 2 * 10 ** 5 + 10\n \nr     = [1] * MAX  \nf     = [1] * MAX\nrf    = [1] * MAX\nrp2   = [1] * MAX \n \nfor i in range(2, MAX):\n    f[i]   = f[i - 1] * i % mod\n    r[i]   = mod - (mod // i) * r[mod%i] % mod\n    rf[i]  = rf[i-1] * r[i] % mod\n    \nfor i in range(1, MAX):\n    rp2[i] = rp2[i - 1] * (mod + 1) // 2 % mod\n    \nn, T = list(map(int, input().split()))\nt    = list(map(int, input().split()))\nt.append(10**14+1)    \n \nS=0\nE=0\nfor i in range(len(t)):\n    cof = rp2[1] \n    \n    for add in range(2):\n        l_, r_ =  max(0, T-S-(t[i]-add)), min(i, T-S)\n        \n        for x in range(l_, r_+1):\n            E = ( E + i * (f[i]*rf[x]*rf[i-x]) * rp2[i] * cof ) % mod    \n    S   += t[i]   \n    \nprint(E)    "]
["import sys\n\nN, M = map(int, input().split())\n\npm = [(i,j,k) for i in range(-1,2,2) for j in range(-1,2,2) for k in range(-1,2,2)]\nlst = []\n\nfor _ in range(N):\n  x,y,z = map(int, input().split())\n  lst.append((x,y,z))\n\nrlt = -sys.maxsize\nfor a,b,c in pm:\n  tmp = []\n  for x,y,z in lst:\n    tmp.append(a*x+b*y+c*z)\n  tmp.sort(reverse=True)\n  rlt = max(rlt, sum(tmp[:M]))\n  \nprint(rlt)", "from itertools import product\nN,M=map(int,input().split())\nx,y,z = [0]*N, [0]*N, [0]*N\nfor i in range(N):\n  x[i],y[i],z[i] = map(int,input().split())\n\nprod= product([1,-1],repeat=3)\nans=0\nfor p in prod:\n  s=[(p[0]*x[i]+p[1]*y[i]+p[2]*z[i]) for i in range(N)]\n  s.sort(reverse=True)\n  tmp=sum(s[:M])\n  ans=max(ans,tmp)\nprint(ans)", "N, M = list(map(int, input().split()))\nC = [tuple(map(int, input().split())) for _ in range(N)]\n\nres = 0\n\nfor i in range(8):\n    #\u7d76\u5bfe\u5024\u3092\u8db3\u3059\u3001\u5f15\u304f\u306e2\u30d1\u30bf\u30fc\u30f3\u3067\u8868\u73fe\u3059\u308b\n    \n    #\u30b1\u30fc\u30ad\u306e\u5024\u306e\u5408\u8a08\u3092\u5165\u308c\u308b\u914d\u5217\n    D = [0 for _ in range(N)]\n\n    #\u5bfe\u5fdc\u3059\u308bbit\u304c1\u306a\u3089\u8db3\u3059\u30010\u306a\u3089\u5f15\u304f\n    for j in range(N):\n        x, y, z = C[j]\n        if (i >> 0) & 1:\n            D[j] += x\n        else:\n            D[j] -= x\n        if (i >> 1) & 1:\n            D[j] += y\n        else:\n            D[j] -= y\n        if (i >> 2) & 1:\n            D[j] += z\n        else:\n            D[j] -= z\n\n    #\u4fa1\u5024\u304c\u9ad8\u3044\u9806\u306bM\u500b\u9078\u3076\n    D.sort(reverse=True)\n    res = max(res, sum(D[:M]))\n\nprint(res)\n", "n, m = map(int, input().split())\n\ncakes = [[int(x) for x in input().split()] for _ in range(n)]\n\nans = 0\nfor i in range(8):\n  cakes_sub = []\n  key = [1, 1, 1]\n  for j in range(3):\n    if (i>>j)&1:\n      key[j] = -1.\n  for j in range(n):\n    k = [0]*3\n    for p in range(3):\n      k[p] = key[p]*cakes[j][p]\n    l = sum(k)\n    cakes_sub.append([l]+k)\n  cakes_sub.sort(reverse=True)\n  a, b, c = 0, 0, 0\n  for j in range(m):\n    a += cakes_sub[j][1]\n    b += cakes_sub[j][2]\n    c += cakes_sub[j][3]\n  sub = a+b+c\n  if ans < sub:\n    ans = sub\n\nprint(int(ans))", "from itertools import product\nn,m = map(int,input().split())\nl = [list(map(int,input().split())) for _ in range(n)]\nbit = [1,-1]\nsu_max = 0\nfor i in product(bit,repeat=3):\n # print(i)\n  l_1 = []\n  for a,b,c in l:\n    t = a*(i[0]) + b*(i[1]) + c*(i[2])\n  #  print(a,b,c,t)\n    l_1.append(t)\n  l_1 = sorted(l_1)[::-1]\n  su_max = max(su_max, sum(l_1[:m]))\nprint(su_max)", "n,m=map(int,input().split())\nl=[list(map(int,input().split())) for i in range(n)]\nfrom itertools import product as pr\nans=0\nfor i in pr((-1,1),repeat=3):\n    li=sorted(l,key=lambda xf:sum(x*y for x,y in zip(i,xf)),reverse=1)[:m]\n    ans=max(ans,sum(abs(sum(j)) for j in zip(*li)))\nprint(ans)", "N, M=map(int, input().split())\nxyz=[list(map(int, input().split())) for _ in range(N)]\ncand=[]\n\n#+++\nwxyz=[tmp[0]+tmp[1]+tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#++-\nwxyz=[tmp[0]+tmp[1]-tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#+-+\nwxyz=[tmp[0]-tmp[1]+tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#+--\nwxyz=[tmp[0]-tmp[1]-tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#-++\nwxyz=[-tmp[0]+tmp[1]+tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#-+-\nwxyz=[-tmp[0]+tmp[1]-tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#--+\nwxyz=[-tmp[0]-tmp[1]+tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\n#---\nwxyz=[-tmp[0]-tmp[1]-tmp[2] for tmp in xyz]\nwxyz.sort(reverse=True)\ncand.append(sum(wxyz[:M]))\n\nprint(max(cand))", "from itertools import product\n\nN, M = map(int, input().split())\nL = [[] for _ in range(N)]\n\nfor i in range(N):\n  x, y, z = map(int, input().split())\n  L[i] += [x, y, z]\n\nans = 0\n\nfor pm in product([-1, 1], repeat=3):\n  temp = []\n  for l in L:\n    temp.append(pm[0]*l[0] + pm[1]*l[1] + pm[2]*l[2])\n  temp.sort(reverse = True)\n  ans = max(ans, sum(temp[:M]))\n\nprint(ans)", "N, M = [int(x) for x in input().split()]\nXYZ = [[int(x) for x in input().split()] for _ in range(N)]\n\nans = -float(\"inf\")\n\nfor i in range(2 ** 3):\n    hugo = [1, 1, 1]\n    for j in range(3):\n        if i >> j & 1 != 1:\n            hugo[j] = -1\n\n    A = []\n    for x, y, z in XYZ:\n        A.append(x * hugo[0] + y * hugo[1] + z * hugo[2])\n\n    A.sort(reverse=True)\n    ans = max(ans, sum(A[:M]))\n\nprint(ans)\n\n\n", "N,M = map(int,input().split())\nnum_list = []\nfor i in range(N):\n    num_list.append(list(map(int,input().split())))\n#print(N,M,num_list)\n\n'''\n[x,y,z]\u3068\u3057\u3066x+y+z,x-y+z,x+y-z,x-y-z,-x+y+z,-x-y+z,-x+y-z,-x-y-z\u306e8\u30d1\u30bf\u30fc\u30f3\n\u3092\u8a08\u7b97\u3057\u3066\u30bd\u30fc\u30c8\n'''\nlist_xyz1 = []\nlist_xyz2 = []\nlist_xyz3 = []\nlist_xyz4 = []\nlist_xyz5 = []\nlist_xyz6 = []\nlist_xyz7 = []\nlist_xyz8 = []\n\nfor i in range(N):\n    list_xyz1.append(num_list[i][0] + num_list[i][1] + num_list[i][2])\n    list_xyz2.append(num_list[i][0] - num_list[i][1] + num_list[i][2])\n    list_xyz3.append(num_list[i][0] + num_list[i][1] - num_list[i][2])\n    list_xyz4.append(num_list[i][0] - num_list[i][1] - num_list[i][2])\n    list_xyz5.append(-num_list[i][0] + num_list[i][1] + num_list[i][2])\n    list_xyz6.append(-num_list[i][0] - num_list[i][1] + num_list[i][2])\n    list_xyz7.append(-num_list[i][0] + num_list[i][1] - num_list[i][2])\n    list_xyz8.append(-num_list[i][0] - num_list[i][1] - num_list[i][2])\n\nlist_xyz1.sort(reverse=True)\nlist_xyz2.sort(reverse=True)\nlist_xyz3.sort(reverse=True)\nlist_xyz4.sort(reverse=True)\nlist_xyz5.sort(reverse=True)\nlist_xyz6.sort(reverse=True)\nlist_xyz7.sort(reverse=True)\nlist_xyz8.sort(reverse=True)\n\nxyz1 = 0\nxyz2 = 0\nxyz3 = 0\nxyz4 = 0\nxyz5 = 0\nxyz6 = 0\nxyz7 = 0\nxyz8 = 0\n\nfor i in range(M):\n    xyz1 += list_xyz1[i]\n    xyz2 += list_xyz2[i]\n    xyz3 += list_xyz3[i]\n    xyz4 += list_xyz4[i]\n    xyz5 += list_xyz5[i]\n    xyz6 += list_xyz6[i]\n    xyz7 += list_xyz7[i]\n    xyz8 += list_xyz8[i]\n\n#print(list_xyz1)\nprint(max(xyz1,xyz2,xyz3,xyz4,xyz5,xyz6,xyz7,xyz8))", "# -*- coding: utf-8 -*-\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\nimport sys\n\n\ndef get_input() -> tuple:\n    \"\"\"\n    \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97.\n\n    Returns:\\n\n        tuple: \u6a19\u6e96\u5165\u529b\n    \"\"\"\n    # \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n    N, M = list(map(int, input().split()))\n    cakes = []\n    for n in range(N):\n        cake_n = list(map(int, input().split()))\n        cakes.append(cake_n)\n\n    return N, M, cakes\n\n\ndef main(N: int, M: int, cakes: list) -> None:\n    \"\"\"\n    \u30e1\u30a4\u30f3\u51e6\u7406.\n\n    Args:\\n\n        N (int): \u30b1\u30fc\u30ad\u306e\u7a2e\u985e(1 <= N <= 1000)\n        M (int): \u98df\u3079\u308b\u6570(0 <= M <= N)\n        cakes (list): \u30b1\u30fc\u30ad\u306e\u8981\u7d20(-10000000000 <= x_i, y_i, z_i <= 10000000000)\n    \"\"\"\n    # \u6c42\u89e3\u51e6\u7406\n    ans = -sys.maxsize\n    element = 3\n    for bit in range(1 << element):\n        sign = [1 for i in range(element)]\n        for i in range(element):\n            if bit & (1 << i):\n                sign[i] *= -1\n        cakes = sorted(cakes, key=lambda x: sum(\n            [sign[i] * x[i] for i in range(element)]), reverse=True)\n\n        indicator = [0 for i in range(element)]\n        for cake in cakes[:M]:\n            for i in range(element):\n                indicator[i] += cake[i]\n\n        ans = max(ans, sum(map(abs, indicator)))\n\n    # \u7d50\u679c\u51fa\u529b\n    print(ans)\n\n\ndef __starting_point():\n    # \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n    N, M, cakes = get_input()\n\n    # \u30e1\u30a4\u30f3\u51e6\u7406\n    main(N, M, cakes)\n\n__starting_point()", "N, M = map(int, input().split())\ncakes = tuple(tuple(map(int, input().split())) for _ in range(N))\ndef make_function(i):\n    return lambda t: sum(t[j] * (-1) ** ((i >> j) & 1) for j in range(3))\nfunctions = [make_function(i) for i in range(8)]\nprint(max(map(sum, (sorted((function(cake) for cake in cakes), reverse=True)[:M] for function in functions))))", "'''\n\u7814\u7a76\u5ba4PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\n\ndef main():\n    n,m = list(map(int,ipt().split()))\n    pts = [[] for i in range(8)]\n    for i in range(n):\n        ni = [int(i) for i in ipt().split()]\n        for j in range(8):\n            nm = 0\n            for k in range(3):\n                if (j>>k)&1:\n                    nm += ni[k]\n                else:\n                    nm -= ni[k]\n            pts[j].append(nm)\n\n    ma = 0\n    for i in range(8):\n        pts[i].sort(reverse=True)\n        sm = sum(pts[i][:m:])\n        if ma < sm:\n            ma = sm\n    print(ma)\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M = map(int,input().split())\nl = []\nfor i in range(N):\n  l.append(list(map(int,input().split())))\n\nans = 0\nfor i in range(2**3):\n  bs = format(i,\"03b\")\n  lsum = []\n  for j in range(N):\n    lsum.append(sum([l[j][_]*(2*int(bs[_])-1) for _ in range(3)]))\n  lsum.sort(reverse=True)\n  ans = max(ans,sum(lsum[:M]))\nprint(ans)  ", "import sys\nfrom itertools import product\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    XYZ = [list(map(int, input().split())) for _ in range(n)]\n\n    res = 0\n    for x, y, z in product([-1, 1], repeat=3):\n        total = []\n        for X, Y, Z in XYZ:\n            s = X * x + Y * y + Z * z\n            total.append(s)\n        total.sort(reverse=True)\n        res = max(res, sum(total[:m]))\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,m = list(map(int, input().split()))\n\nxp_yp_zp = [0] * n\nxp_yp_zn = [0] * n\nxp_yn_zp = [0] * n\nxn_yp_zp = [0] * n\nxp_yn_zn = [0] * n\nxn_yp_zn = [0] * n\nxn_yn_zp = [0] * n\nxn_yn_zn = [0] * n\n\nfor i in range(n):\n  x,y,z = list(map(int, input().split()))\n  xp_yp_zp[i] = x + y + z\n  xp_yp_zn[i] = x + y - z\n  xp_yn_zp[i] = x - y + z\n  xn_yp_zp[i] = -x + y + z\n  xp_yn_zn[i] = x - y - z\n  xn_yp_zn[i] = -x + y - z\n  xn_yn_zp[i] = -x - y + z\n  xn_yn_zn[i] = -x - y - z\n\nxp_yp_zp.sort(reverse = True)\na = sum(xp_yp_zp[0:m])\n\nxp_yp_zn.sort(reverse = True)\nb = sum(xp_yp_zn[0:m])\n\nxp_yn_zp.sort(reverse = True)\nc = sum(xp_yn_zp[0:m])\n\nxn_yp_zp.sort(reverse = True)\nd = sum(xn_yp_zp[0:m])\n\nxp_yn_zn.sort(reverse = True)\ne = sum(xp_yn_zn[0:m])\n\nxn_yp_zn.sort(reverse = True)\nf = sum(xn_yp_zn[0:m])\n\nxn_yn_zp.sort(reverse = True)\ng = sum(xn_yn_zp[0:m])\n\nxn_yn_zn.sort(reverse = True)\nh = sum(xn_yn_zn[0:m])\n\nans = max(a,b,c,d,e,f,g,h)\n\nprint(ans)\n", "import heapq\nn,m= map(int,input().split())\npml = [[] for _ in range(8)]\nfor ll in pml:heapq.heapify(ll)\nfor _ in range(n):\n    x,y,z= map(int,input().split())\n    for xs in [1,-1]:\n        for ys in [1,-1]:\n            for zs in [1,-1]:\n                tempid = (4 if xs==1 else 0) + (2 if ys==1 else 0) + (1 if zs==1 else 0)\n                tempspm = x*xs + y*ys + z*zs\n                heapq.heappush(pml[tempid],tempspm)\napml = [0]*8\nfor i in range(m):\n    for xs in [1,-1]:\n        for ys in [1,-1]:\n            for zs in [1,-1]:\n                tempid = (4 if xs==1 else 0) + (2 if ys==1 else 0) + (1 if zs==1 else 0)\n                apml[tempid] += - heapq.heappop(pml[tempid])\nprint(max(apml))", "N,M=map(int,input().split())\nc=[list(map(int,input().split())) for i in range(N)]\n\nbit=[[] for i in range(2**3)]\nfor k in range(N):\n    for i in range(2**3):\n        t=c[k].copy()\n        for j in range(3):\n            if(i>>j&1):\n                t[j]*=-1\n        bit[i].append(t)\nfor i in range(2**3):\n    bit[i].sort(key=lambda x:(x[0]+x[1]+x[2]),reverse=True)\nres=0\nfor i in range(2**3):\n    p=[1,1,1]\n    for j in range(3):\n        if(i>>j&1):\n            p[j]*=-1\n    z,o,t=0,0,0\n    for k in range(M):\n        z+=bit[i][k][0]*p[0]\n        o+=bit[i][k][1]*p[1]\n        t+=bit[i][k][2]*p[2]\n    res=max(res,abs(z)+abs(o)+abs(t))\nprint(res)", "import sys\nimport numpy as np\ninput = sys.stdin.readline\ndef main():\n    n,m = map(int,input().split())\n    xyz = [[] for _ in range(8)]\n    pm = [[ 1, 1, 1],\n          [ 1, 1,-1],\n          [ 1,-1, 1],\n          [-1, 1, 1],\n          [ 1,-1,-1],\n          [-1, 1,-1],\n          [-1,-1, 1],\n          [-1,-1,-1]]\n    pm = np.array(pm)\n    for _ in range(n):\n        x,y,z = map(int,input().split())\n        for i in range(8):\n            k = np.array([x,y,z])\n            xyz[i].append(sum(pm[i]*k))\n    ans = -10**20\n    for i in range(8):\n        X = xyz[i]\n        X.sort(reverse=True)\n        cnt = 0\n        for j in range(m):\n            cnt += X[j]\n        ans = max(ans,cnt)\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import product\nn, m = map(int, input().split())\nxyz = [tuple(map(int, input().split())) for _ in range(n)]\n\n\nans = 0\nfor subset in product((-1, 1), repeat=3):\n    INF = 10**18\n    dp = [-INF]*(n+1)\n    dp[0] = 0\n\n    def func(xyz):\n        return sum(x*a for x, a in zip(xyz, subset))\n\n    values = list(map(func, xyz))\n    for i, val in enumerate(values, 1):\n        for j in reversed(range(1, i+1)):\n            dp[j] = max(dp[j-1]+val, dp[j])\n    if ans < dp[m]:\n        ans = dp[m]\n\nprint(ans)", "n, m = map(int, input().split())\nif m == 0:\n    print(0)\n    return\n\nres_111 = []\nres_110 = []\nres_101 = []\nres_100 = []\nres_011 = []\nres_010 = []\nres_001 = []\nres_000 = []\n\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    res_111.append(x+y+z)\n    res_110.append(x+y-z)\n    res_101.append(x-y+z)\n    res_100.append(x-y-z)\n    res_011.append(-x+y+z)\n    res_010.append(-x+y-z)\n    res_001.append(-x-y+z)\n    res_000.append(-x-y-z)\n\nres_111.sort()\nres_110.sort()\nres_101.sort()\nres_100.sort()\nres_011.sort()\nres_010.sort()\nres_001.sort()\nres_000.sort()\n\nprint(max(sum(res_111[-m:]),sum(res_110[-m:]),sum(res_101[-m:]),sum(res_100[-m:]),sum(res_011[-m:]),sum(res_010[-m:]),sum(res_001[-m:]),sum(res_000[-m:])))", "# D - Patisserie ABC\n\nN, M = list(map(int, input().split()))\nA = [[] for _ in range(8)]\n\nfor i in range(N):\n    x, y, z = list(map(int, input().split()))\n    A[0].append(x+y+z)\n    A[1].append(x+y-z)\n    A[2].append(x-y+z)\n    A[3].append(x-y-z)\n    A[4].append(-x+y+z)\n    A[5].append(-x+y-z)\n    A[6].append(-x-y+z)\n    A[7].append(-x-y-z)\n\nans = 0\nfor i in range(8):\n    A[i].sort(reverse=True)\n    ans = max(ans, sum(A[i][0:M]))\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int,input().split())\nCake = []\nfor _ in range(n):\n    c = list(map(int,input().split()))\n    Cake.append(c)\n\ntotal = []\n\nfor i in range(8):\n    total_i = []\n    for k in Cake:\n        hyouka = 0\n        for j in range(3):\n            if ((i >> j) & 1):\n                hyouka += k[j]\n            else:\n                hyouka -= k[j]\n        total_i.append(hyouka)\n    total_i.sort(reverse=True)\n    goukei = 0\n    for l in range(m):\n        goukei += total_i[l]\n    total.append(goukei)\n\nprint(max(total))", "n, m = list(map(int, input().split()))\np = [list(map(int, input().split())) for i in range(n)]\ns = []\nfor i in range(8):\n  s.append([])\n  for j in range(n):\n    x, y, z = p[j]\n    sx = i // 4 % 2 * 2 - 1\n    sy = i // 2 % 2 * 2 - 1\n    sz = i % 2 * 2 - 1\n    s[i].append(sx * x + sy * y + sz * z)\n  s[i] = sorted(s[i], reverse=True)\nans = 0\nfor i in range(8):\n  ans = max(ans, sum(s[i][:m]))\nprint(ans)\n", "from sys import stdin\nimport numpy as np\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    n,m=map(int,readline().split())\n    A=np.array([list(map(int,readline().split())) for _ in range(n)],dtype=\"int64\")\n\n    ans=-float(\"inf\")\n    for i in (-1,1):\n        for j in (-1,1):\n            for k in (-1,1):\n                B=np.array([i,j,k],dtype=\"int64\")\n                res=np.sort(np.dot(A,B))[::-1][:m].sum()\n                ans=max(ans,res)\n                \n    print(ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "from itertools import *\nN,M = map(int,input().split())\nC = [list(map(int,input().split())) for n in range(N)]\nprint(max([sum(sorted([i*x+j*y+k*z for x,y,z in C],reverse=True)[:M]) for i,j,k in product([-1,1],[-1,1],[-1,1])]))", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,m=nii()\nl=[lnii() for i in range(n)]\n\nans=0\nfor i in range(2**3):\n  t_l=[]\n  for j in l:\n    t_num=0\n    for k in range(3):\n      if (i>>k)&1:\n        t_num+=j[k]\n      else:\n        t_num-=j[k]\n    t_l.append(t_num)\n\n  t_l.sort(reverse=True)\n  ans=max(ans,sum(t_l[:m]))\n\nprint(ans)", "n, m = map(int, input().split())\nxyz = [list(map(int, input().split())) for i in range(n)]\nl1, l2, l3, l4, l5, l6, l7, l8 = sorted(xyz, key=lambda x: x[0] + x[1] + x[2], reverse=True), sorted(xyz, key=lambda x: x[0] + x[1] - x[2], reverse=True), sorted(xyz, key=lambda x: x[0] - x[1] + x[2], reverse=True), sorted(xyz, key=lambda x: x[0] - x[1] - x[2], reverse=True), sorted(xyz, key=lambda x: -(x[0]) + x[1] + x[2], reverse=True), sorted(xyz, key=lambda x: -(x[0]) + x[1] - x[2], reverse=True), sorted(xyz, key=lambda x: -(x[0]) - x[1] + x[2], reverse=True), sorted(xyz, key=lambda x: -(x[0]) - x[1] - x[2], reverse=True)\ndef sum2(l):\n    ans = 0\n    cnt = 0\n    for i in l:\n        cnt += i[0]\n    ans += abs(cnt)\n    cnt = 0\n    for i in l:\n        cnt += i[1]\n    ans += abs(cnt)\n    cnt = 0\n    for i in l:\n        cnt += i[2]\n    ans += abs(cnt)\n    return ans\nprint(max(sum2(l1[:m]),sum2(l2[:m]),sum2(l3[:m]),sum2(l4[:m]),sum2(l5[:m]),sum2(l6[:m]),sum2(l7[:m]),sum2(l8[:m]),))", "def solve():\n    n, m = list(map(int, input().split()))\n    a = [[] for _ in range(1 << 3)]\n    ans = - 10 ** 14\n    for _ in range(n):\n        s = list(map(int, input().split()))\n        for i in range(1 << 3):\n            tmp = 0\n            for j in range(3):\n                if i >> j & 1:\n                    tmp += s[j]\n                else:\n                    tmp -= s[j]\n            a[i].append(tmp)\n    for x in range(1 << 3):\n        res = sorted(a[x], reverse=True)\n        ans = max(ans, sum(res[:m]))\n    print(ans)\n\n\nsolve()\n\n", "import itertools\n\n\ndef main():\n    N, M = list(map(int, input().split(' ')))\n    cakes = [list(map(int, input().split(' '))) for _ in range(N)]\n    ans = 0\n    for sign in itertools.product([-1, 1], repeat=3):\n        scores = [sum([s * c for s, c in zip(sign, cake)]) for cake in cakes]\n        scores.sort(reverse=True)\n        ans = max([ans, sum(scores[:M])])\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,m=nii()\nl=[lnii() for i in range(n)]\n\nans=0\nfor i in [1,-1]:\n  for j in [1,-1]:\n    for k in [1,-1]:\n      t_num=0\n      t_l=[]\n      for x,y,z in l:\n        t_num=x*i+y*j+z*k\n        t_l.append(t_num)\n      t_l.sort(reverse=True)\n      ans=max(ans,sum(t_l[:m]))\n\nprint(ans)", "n, m = map(int, input().split())\nAs = [[] for i in range(8)]\nfor i in range(n):\n    x,y,z = map(int, input().split())\n    As[0].append(-x-y-z)\n    As[1].append(-x-y+z)\n    As[2].append(-x+y-z)\n    As[3].append(-x+y+z)\n    As[4].append(x-y-z)\n    As[5].append(x-y+z)\n    As[6].append(x+y-z)\n    As[7].append(x+y+z)\n\nans = 0\nfor a in As:\n    a.sort(reverse=True)\n    s = sum(a[:m])\n    ans = max(ans,s)\nprint(ans)", "n,m = map(int, input().split(\" \"))\na = [list(map(int, input().split(\" \"))) for i in range(n)]\nans = 0\n#print(a)\nfor i in range(2 ** 3):\n  total = []\n  minus = [1 for _ in range(3)]\n  for j in range(3):\n    if i >> j & 1:\n      minus[j] *= -1\n  for k in range(n):\n    total.append(a[k][0] * minus[0] + a[k][1] * minus[1] + a[k][2] * minus[2])\n  ans = max(ans, sum(sorted(total, reverse=1)[:m]))\nprint(ans)", "N,M=list(map(int, input().split()))\n\n#\u5168\uff0b\u3001\u5168\u30fc\u3001\nL=[]\nfor i in range(N):\n    x,y,z=list(map(int, input().split()))\n    a1=x+y+z\n    a2=-x+y+z\n    a3=-x-y+z\n    a4=-x-y-z\n    a5=x-y+z\n    a6=x-y-z\n    a7=x+y-z\n    a8=-x+y-z\n    L.append([x,y,z,a1,a2,a3,a4,a5,a6,a7,a8])\n\nans=0\nfor i in range(3,11):\n    L=sorted(L, key=lambda x: x[i], reverse=True)\n    sub=0\n    for j in range(M):\n        t=L[j]\n        sub+=t[i]\n    ans=max(ans, sub)\nprint(ans)\n", "N,Eat = map(int,input().split())\ncakes_ls = [[0,0,0] for _ in range(N)]\nfor i in range(N):\n    cakes_ls[i] = list(map(int,input().split()))\n\nPatterns = 2**3\nans = 0\nfor i in range(Patterns):\n    mult = [1] * 3\n    for j in range(3):\n        if (i>>j) & 1:\n            mult[j] = -1\n    \n    value_ls = [0] * N\n    for n in range(N):\n        target = cakes_ls[n]\n        value = 0\n        for x in range(3):\n            value += target[x] * mult[x]\n        value_ls[n] = value\n    value_ls.sort(reverse=True)\n    #print(value_ls)\n    #print(mult,sum(value_ls[:Eat]))\n    ans = max(ans,sum(value_ls[:Eat]))\nprint(ans)", "n,m = map(int,input().split())\nvalue_sum = [[0]*n for i in range(8)]\nans = [0]*8\nfor i in range(n):\n    value = list(map(int,input().split()))\n    for j in range(8):\n        for k in range(3):\n            if ((j>>k)&1):\n                value_sum[j][i] += value[k]\n            else:\n                value_sum[j][i] -= value[k]\nfor i in range(8): \n    value_sum[i].sort(reverse=True)\n    ans[i] = sum(value_sum[i][:m])\nprint(max(ans))", "N,M=map(int,input().split())\nX=[]\nY=[]\nZ=[]\nG1=[]\nG2=[]\nG3=[]\nG4=[]\nG5=[]\nG6=[]\nG7=[]\nG8=[]\n\nfor i in range(N):\n    x,y,z=map(int,input().split())\n    G1.append(-(x+y+z))\n    G2.append(-(x+y)+z)\n    G3.append(-x+y-z)\n    G4.append(-x+(y+z))\n    G5.append(x-(y+z))\n    G6.append(x-y+z)\n    G7.append(x+y-z)\n    G8.append(x+y+z)\nG1.sort(reverse=True)\nG2.sort(reverse=True)\nG3.sort(reverse=True)\nG4.sort(reverse=True)\nG5.sort(reverse=True)\nG6.sort(reverse=True)\nG7.sort(reverse=True)\nG8.sort(reverse=True)\nans=0\nval1=0\nval2=0\nval3=0\nval4=0\nval5=0\nval6=0\nval7=0\nval8=0\nfor i in range(M):\n    val1+=G1[i]\n    val2+=G2[i]\n    val3+=G3[i]\n    val4+=G4[i]\n    val5+=G5[i]\n    val6+=G6[i]\n    val7+=G7[i]\n    val8+=G8[i]\n\nans=max(val1,val2,val3,val4,val5,val6,val7,val8)\nprint(ans)", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, m = ns()\n    res = [[] for _ in range(2 ** 3)]\n\n    if m == 0:\n        print((0))\n        return\n\n    for _ in range(n):\n        a = na()\n\n        for i in range(2 ** 3):\n            tmp = 0\n            for j in range(3):\n                if i >> j & 1:\n                    tmp += -a[j]\n                else:\n                    tmp += a[j]\n            res[i].append(tmp)\n\n    ans = -INF\n    for resi in res:\n        resi.sort(reverse=True)\n        ans = max(ans, sum(resi[:m]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\nsys.setrecursionlimit(20000000)\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    cake = [list(map(int, input().split())) for _ in range(N)]\n    C = [[] for _ in range(8)]\n    for i in range(2 ** 3):\n        for c in range(N):\n            m = 0\n            for j in range(3):\n                if (i >> j) & 1:\n                    m += cake[c][j]\n                else:\n                    m -= cake[c][j]\n            C[i].append(m)\n    answer = 0\n    for i in range(8):\n        C[i].sort(reverse=True)\n        ans = sum(C[i][:M])\n        if ans > answer:\n            answer = ans\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[] for _ in range(8)]\nc = []\nfor i in range(n):\n    x,y,z = a[i][0],a[i][1],a[i][2]\n    b[0].append(x+y+z)\n    b[1].append(x+y-z)\n    b[2].append(x-y+z)\n    b[3].append(x-y-z)\n    b[4].append(-x+y+z)\n    b[5].append(-x+y-z)\n    b[6].append(-x-y+z)\n    b[7].append(-x-y-z)\nfor i in range(8):\n    b[i].sort()\n    b[i].reverse()\nfor i in range(8):\n    c.append(sum(b[i][:m]))\nprint((max(c)))\n", "N,M = map(int,input().split())\nnum_list = []\nfor i in range(N):\n    num_list.append(list(map(int,input().split())))\n#print(N,M,num_list)\n\n'''\n[x,y,z]\u3068\u3057\u3066x+y+z,x-y+z,x+y-z,x-y-z,-x+y+z,-x-y+z,-x+y-z,-x-y-z\u306e8\u30d1\u30bf\u30fc\u30f3\n\u3092\u8a08\u7b97\u3057\u3066\u30bd\u30fc\u30c8\n'''\nlist_xyz1 = []\nlist_xyz2 = []\nlist_xyz3 = []\nlist_xyz4 = []\nlist_xyz5 = []\nlist_xyz6 = []\nlist_xyz7 = []\nlist_xyz8 = []\n\nfor i in range(N):\n    list_xyz1.append(num_list[i][0] + num_list[i][1] + num_list[i][2])\n    list_xyz2.append(num_list[i][0] - num_list[i][1] + num_list[i][2])\n    list_xyz3.append(num_list[i][0] + num_list[i][1] - num_list[i][2])\n    list_xyz4.append(num_list[i][0] - num_list[i][1] - num_list[i][2])\n    list_xyz5.append(-num_list[i][0] + num_list[i][1] + num_list[i][2])\n    list_xyz6.append(-num_list[i][0] - num_list[i][1] + num_list[i][2])\n    list_xyz7.append(-num_list[i][0] + num_list[i][1] - num_list[i][2])\n    list_xyz8.append(-num_list[i][0] - num_list[i][1] - num_list[i][2])\n\nlist_xyz1.sort()\nlist_xyz2.sort()\nlist_xyz3.sort()\nlist_xyz4.sort()\nlist_xyz5.sort()\nlist_xyz6.sort()\nlist_xyz7.sort()\nlist_xyz8.sort()\n\nxyz1 = 0\nxyz2 = 0\nxyz3 = 0\nxyz4 = 0\nxyz5 = 0\nxyz6 = 0\nxyz7 = 0\nxyz8 = 0\n\nfor i in range(M):\n    xyz1 += list_xyz1[N-i-1]\n    xyz2 += list_xyz2[N-i-1]\n    xyz3 += list_xyz3[N-i-1]\n    xyz4 += list_xyz4[N-i-1]\n    xyz5 += list_xyz5[N-i-1]\n    xyz6 += list_xyz6[N-i-1]\n    xyz7 += list_xyz7[N-i-1]\n    xyz8 += list_xyz8[N-i-1]\n\n#print(list_xyz1)\nprint(max(xyz1,xyz2,xyz3,xyz4,xyz5,xyz6,xyz7,xyz8))", "#!/usr/bin/env python3\nfrom itertools import product\nn, m = list(map(int, input().split()))\nxyz = [list(map(int, input().split())) for i in range(n)]\n\ndp = [[0 for i in range(m+1)] for j in range(n+1)]\n\n\n# eval\n# eval_list = [\"+xyz[i-1][0]+xyz[i-1][1]+xyz[i-1][2]\",\n#              \"+xyz[i-1][0]+xyz[i-1][1]-xyz[i-1][2]\",\n#              \"+xyz[i-1][0]-xyz[i-1][1]+xyz[i-1][2]\",\n#              \"+xyz[i-1][0]-xyz[i-1][1]-xyz[i-1][2]\",\n#              \"-xyz[i-1][0]+xyz[i-1][1]+xyz[i-1][2]\",\n#              \"-xyz[i-1][0]+xyz[i-1][1]-xyz[i-1][2]\",\n#              \"-xyz[i-1][0]-xyz[i-1][1]+xyz[i-1][2]\",\n#              \"-xyz[i-1][0]-xyz[i-1][1]-xyz[i-1][2]\", ]\n\nans = 0\nfor a, b, c in product([1, -1], repeat=3):\n    total = []\n    for x, y, z in xyz:\n        s = x*a+y*b+z*c\n        total.append(s)\n    total.sort(reverse=True)\n    ans = max(ans, sum(total[:m]))\nprint(ans)\n", "from itertools import product\nfrom sys import stdin\nreadline = stdin.readline\n\nN, M = list(map(int, readline().split()))\nxyz = [tuple(map(int, readline().split())) for _ in range(N)]\n\nresult = 0\nfor s in product([1, -1], repeat=3):\n    xyz.sort(reverse=True, key=lambda e: s[0] * e[0] + s[1] * e[1] + s[2] * e[2])\n    cx, cy, cz = 0, 0, 0\n    for x, y, z in xyz[:M]:\n        cx += x\n        cy += y\n        cz += z\n    result = max(result, abs(cx) + abs(cy) + abs(cz))\nprint(result)\n", "import sys\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nscores = []\nfor _ in range(N):\n    x, y, z = map(int, input().split())\n    scores.append((x, y, z))\n\nans = 0\nfor i in range(2**3):\n    tmp_scores = []\n    for score in scores:\n        tmp_score = 0\n        for j in range(3):\n            if (i >> j) & 1:\n                 tmp_score -= score[j]\n            else:\n                 tmp_score += score[j]\n        tmp_scores.append(tmp_score)\n    tmp_scores.sort(reverse=True)\n    ans = max(ans, sum(tmp_scores[:M]))\n\nprint(ans)", "N,M = list(map(int,input().split()))\nL = []\nfor _ in range(N):\n    l = list(map(int,input().split()))\n    L.append(l)\ncand = []\nfor bit in range(8):\n    plus_minus = [1,1,1]\n    for  b in range(3):\n        if bit & (1 << b):\n            plus_minus[b] = -1\n    L = sorted(L, key = lambda x:x[0]*plus_minus[0]+x[1]*plus_minus[1]+x[2]*plus_minus[2])\n    tmp = 0\n    for i in range(M):\n        for j in range(3):\n            tmp += L[i][j] * plus_minus[j]\n    cand.append(tmp)\n\nprint((max(abs(min(cand)),max(cand))))\n\n\n", "# -*- coding: utf-8 -*-\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\nimport sys\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\nN, M = list(map(int, input().split()))\ncakes = []\nfor n in range(N):\n    cake_n = list(map(int, input().split()))\n    cakes.append(cake_n)\n\n# \u6c42\u89e3\u51e6\u7406\nans = -sys.maxsize\nelement = 3\nfor bit in range(1 << element):\n    sign = [1 for i in range(element)]\n    for i in range(element):\n        if bit & (1 << i):\n            sign[i] *= -1\n    cakes = sorted(cakes, key=lambda x: sum(\n        [sign[i] * x[i] for i in range(element)]), reverse=True)\n\n    indicator = [0 for i in range(element)]\n    for cake in cakes[:M]:\n        for i in range(element):\n            indicator[i] += cake[i]\n\n    ans = max(ans, sum(map(abs, indicator)))\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)\n", "from itertools import product\nn, m = list(map(int, input().split()))\nxyz = [tuple(map(int, input().split()))for _ in range(n)]\n\nans = 0\nfor subset in product((-1, 1), repeat=3):\n    def func(xyz):\n        return sum(x*a for x, a in zip(xyz, subset))\n    score = sum(sorted(map(func, xyz), reverse=True)[:m])\n    if ans < score:\n        ans = score\nprint(ans)\n", "n , m = map(int,input().split())\np = [(1,1,1),(1,1,-1),(1,-1,1),(1,-1,-1),(-1,1,1),(-1,1,-1),(-1,-1,1),(-1,-1,-1)]\ncake = [list(map(int,input().split())) for i in range(n)]\nans = 0\nfor a , b , c in p:\n    cou = []\n    for x , y , z in cake:\n        cou.append(x*a+y*b+z*c)\n    cou.sort(reverse=True)\n    ans = max(ans,sum(cou[:m]))\nprint(ans)", "N,M = map(int,input().split())\nxyz = [tuple(map(int,input().split())) for _ in range(N)]\nans = 0\nfor i in range(2**3):\n    sign = [(-1)**((i >> j) & 1) for j in range(3)]\n    s,t,u = sign\n    xyz.sort(key=lambda x:s*x[0]+t*x[1]+u*x[2], reverse=True)\n    s,t,u = 0,0,0\n    for x,y,z in xyz[:M]:\n        s += x\n        t += y\n        u += z\n    ans = max(ans, abs(s)+abs(t)+abs(u))\nprint(ans)", "import bisect,collections,copy,heapq,itertools,math,numpy,string\nimport sys\nfrom operator import itemgetter\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nN, M = LI()\nA = [LI() for _ in range(N)]\nm = [[0] * 3 for _ in range(8)]\n\nfor c in range(4):\n  A.sort(key=lambda x:(((c>>2)&1)*2-1)*x[0]+(((c>>1)&1)*2-1)*(-1)*x[1]+((c&1)*2-1)*x[2])\n  for i in range(M):\n  \tfor j in range(3):\n  \t\tm[c*2][j] += A[i][j]\n  \t\tm[c*2+1][j] += A[N-1-i][j]\n\nprint((max([abs(x[0])+abs(x[1])+abs(x[2]) for x in m])))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef is_nth_bit_set(x, n):\n    if x & (1 << n):\n        return True\n    else:\n        return False\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    xyz = []\n    for _ in range(N):\n        x, y, z = list(map(int, input().split()))\n        xyz.append((x, y, z))\n\n    ans = 0\n    for i in range(8):\n        arr = []\n        for x, y, z in xyz:\n            tmp = 0\n            if is_nth_bit_set(i, 0):\n                tmp += x\n            else:\n                tmp -= x\n\n            if is_nth_bit_set(i, 1):\n                tmp += y\n            else:\n                tmp -= y\n\n            if is_nth_bit_set(i, 2):\n                tmp += z\n            else:\n                tmp -= z\n            arr.append(tmp)\n\n        arr.sort(reverse=True)\n        ans = max(sum(arr[:M]), ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\ndef log(*args):\n    print(*args, file=sys.stderr)\n\n\ndef main():\n    n, m = map(int, input().split())\n    l = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for i in [-1, 1]:\n        for j in [-1, 1]:\n            for k in [-1, 1]:\n                l2 = []\n                for (x, y, z) in l:\n                    s = x * i + y * j + z * k\n                    l2.append(s)\n                l2 = sorted(l2, reverse=True)\n                ans = max(ans, sum(l2[:m]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nN, M = list(map(int, input().split()))\nvals = [[] for _ in range(8)]\nfor _ in range(N):\n    a, b, c = list(map(int,input().split()))\n    vals[0].append( a+b+c)\n    vals[1].append( a+b-c)\n    vals[2].append( a-b+c)\n    vals[3].append( a-b-c)\n    vals[4].append(-a+b+c)\n    vals[5].append(-a+b-c)\n    vals[6].append(-a-b+c)\n    vals[7].append(-a-b-c)\nret = 0\nfor val in vals:\n    val.sort(reverse = True)\n    ret = max(ret, sum(val[:M]))\nprint(ret)\n", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nx=0\ny=0\nz=0\nxyz=[]\nN,M=list(map(int,input().split()))\nfor _ in range(N):\n    x0,y0,z0 = list(map(int,input().split()))\n    x+=x0\n    y+=y0\n    z+=z0\n    xyz.append([x0,y0,z0])\nlmn =[]\n\nfor x0,y0,z0 in xyz:\n    tmp = [x0,y0,z0]\n    for fx in [-1,1]:\n        for fy in [-1,1]:\n            for fz in [-1,1]:\n                tmp.append(x0*fx+y0*fy+z0*fz)\n    lmn.append(tmp)\n\nans = 0\nfor i in range(8):\n    lmn.sort(key = lambda x:-x[i+3])\n    x=0\n    y=0\n    z=0\n    for j in range(M):\n        x += lmn[j][0]\n        y += lmn[j][1]\n        z += lmn[j][2]\n    ans = max(ans,abs(x)+abs(y)+abs(z))\nprint(ans)\n        \n    \n", "\nfrom itertools import product\n\ndef convert(x, pt):\n    return sum(e if p else -e for e, p in zip(x, pt))\n\ndef submit():\n    n, m = (int(a) for a in input().split())\n    cakes = [tuple(map(int, input().split())) for _ in range(n)]\n\n\n    ans = 0\n    for pt in product([0, 1], repeat=3):\n        pt_cakes = [convert(c, pt) for c in cakes]\n        pt_cakes.sort(reverse=True)\n        pt_sum = sum(pt_cakes[:m])\n        if pt_sum > ans:\n            ans = pt_sum\n\n    print(ans)        \n\nsubmit()\n", "from itertools import product\nN,M=map(int,input().split())\nx,y,z = [0]*N, [0]*N, [0]*N\nfor i in range(N):\n    x[i],y[i],z[i] = map(int,input().split())\n\npat= product([1,-1],repeat=3)\nans=0\nfor v in pat:\n    s = [ (v[0]*x[i]+v[1]*y[i]+v[2]*z[i]) for i in range(N)]\n    s.sort(reverse=True)\n    tmp=sum(s[:M])\n    ans=max(ans,tmp)\nprint(ans)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,m=nii()\nl=[lnii() for i in range(n)]\n\nans=0\nfor i in [1,-1]:\n  for j in [1,-1]:\n    for k in [1,-1]:\n      t_num=0\n      t_l=[]\n      for x,y,z in l:\n        t_num=x*i+y*j+z*k\n        t_l.append(t_num)\n      t_l.sort(reverse=True)\n      ans=max(ans,sum(t_l[:m]))\n\nprint(ans)", "n, m = map(int, input().split())\nl = [list(map(int, input().split())) for i in range(n)]\n\nsum_list = [0] * 8\n\nl_ppp = [0] * n\nl_ppm = [0] * n\nl_pmp = [0] * n\nl_mpp = [0] * n\nl_pmm = [0] * n\nl_mpm = [0] * n\nl_mmp = [0] * n\nl_mmm = [0] * n\n\nfor i in range(n):\n    l_ppp[i] = l[i][0] + l[i][1] + l[i][2]\n    l_ppm[i] = l[i][0] + l[i][1] - l[i][2]\n    l_pmp[i] = l[i][0] - l[i][1] + l[i][2]\n    l_mpp[i] = - l[i][0] + l[i][1] + l[i][2]\n    l_pmm[i] = l[i][0] - l[i][1] - l[i][2]\n    l_mpm[i] = - l[i][0] + l[i][1] - l[i][2]\n    l_mmp[i] = - l[i][0] - l[i][1] + l[i][2]\n    l_mmm[i] = - l[i][0] - l[i][1] - l[i][2]\n    \nl_ppp = sorted(l_ppp, reverse=True)\nl_ppm = sorted(l_ppm, reverse=True)\nl_pmp = sorted(l_pmp, reverse=True)\nl_mpp = sorted(l_mpp, reverse=True)\nl_pmm = sorted(l_pmm, reverse=True)\nl_mpm = sorted(l_mpm, reverse=True)\nl_mmp = sorted(l_mmp, reverse=True)\nl_mmm = sorted(l_mmm, reverse=True)\n\nsum_list[0] = sum(l_ppp[:m])\nsum_list[1] = sum(l_ppm[:m])\nsum_list[2] = sum(l_pmp[:m])\nsum_list[3] = sum(l_mpp[:m])\nsum_list[4] = sum(l_pmm[:m])\nsum_list[5] = sum(l_mpm[:m])\nsum_list[6] = sum(l_mmp[:m])\nsum_list[7] = sum(l_mmm[:m])\n\nprint(max(sum_list))", "# \u7d76\u5bfe\u5024\u3068\u8a00\u308f\u308c\u305f\u3089\uff0b\u3068\u30fc\u306e\u3069\u3063\u3061\u306b\u3059\u308b\u306e\u304b\u5206\u304b\u3089\u306a\u3044\u2192\u5168\u901a\u308a\u3084\u308c\u3070\u826f\u3044\n# \u5411\u304d\u3092\u56fa\u5b9a\u3059\u308b\u3002\n# \u4f8b\u3048\u3070x\u304c+, y\u304c-\u3001z\u304c+\u3060\u3068\u3059\u308b\u3068\n# (x,y,z) = (3, -4, -1)\u306e\u300c\u8ca2\u732e\u5ea6\u300d\u306f3+4-1 = 6\u306b\u306a\u308b\n# \u3042\u3068\u306f\u8ca2\u732e\u5ea6\u306e\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u3001\u4e0a\u4f4d\u304b\u3089M\u500b\u3092\u53d6\u308c\u3070\u826f\u3044\n\n# L1\u30ce\u30eb\u30e0\u304c\u4e00\u5b9a\u2192\u30c0\u30a4\u30e4\u578b\uff08\u6b63\u516b\u9762\u4f53\uff09\n# \u30de\u30f3\u30cf\u30c3\u30bf\u30f3\u8ddd\u96e2\u3092\u4f7f\u3046\u554f\u984c\u3068\u3082\u901a\u3058\u308b\u3082\u306e\u304c\u3042\u308b\u3002\n# https://atcoder.jp/contests/abc178/tasks/abc178_e ABC178 E Dist Max\n# \u300c\u3044\u304f\u3064\u304b\u5411\u304d\u306e\u5019\u88dc\u304c\u3042\u308b\u304b\u3089\u3001\u5168\u901a\u308a\u3092\u8003\u3048\u3066\u6700\u5927\u3092\u53d6\u308c\u3070\u3044\u3044\u3088\u306d\u3002\u5411\u304d\u3092\u56fa\u5b9a\u3059\u308c\u3070\u3042\u3068\u306f\u5358\u7d14\u306a\u8caa\u6b32\u3060\u3088\u306d\u300d\n\nimport copy\n\nn, m = list(map(int, input().split()))\ntemp = [list(map(int, input().split())) for _ in range(n)]\n\nans = 0\nfor x_sign in (1, -1):\n    for y_sign in (1, -1):\n        for z_sign in (1, -1):\n            # params = temp.copy() \u3053\u308c\u3067\u306f\u6d45\u3044\u30b3\u30d4\u30fc\u306b\u306a\u308b\u306e\u3067\u3001\u540c\u3058\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u6307\u3057\u3066\u3057\u307e\u3046\n            params = copy.deepcopy(temp)\n\n            for xyz in params:\n                xyz.append(x_sign * xyz[0] + y_sign * xyz[1] + z_sign * xyz[2])\n            \n            params.sort(key=lambda xyz: xyz[3], reverse=True)\n            ans_sign = sum([xyz[3] for xyz in params[:m]])\n            ans = max(ans, ans_sign)\n\nprint(ans)\n", "n, m = map(int, input().split())\n\nxyz = [list(map(int, input().split())) for _i in range(n)]\n\nr = []\nfor i in range(2**3):\n    checker = []\n    num = i\n    for _i in range(3):\n        if num%2==1:\n            checker.append(1)\n        else:\n            checker.append(-1)\n        num >>= 1\n    _xyz = []\n    for j in range(n):\n        _abc = [checker[s]*xyz[j][s] for s in range(3)]\n        _xyz.append([sum(_abc)]+_abc)\n    _xyz.sort(reverse=True)\n    _r = abs(sum(i[1] for i in _xyz[:m]))+ abs(sum(i[2] for i in _xyz[:m]))+abs(sum(i[3] for i in _xyz[:m]))\n    r.append(_r)\n\nprint(max(r))", "def main():\n    import itertools\n    n,m = list(map(int,input().split()))\n    ls = [[] for i in range(8)]\n    stats = [stat for stat in itertools.product(*((0,1) for i in range(3)))]\n    for i in range(n):\n        x,y,z = list(map(int,input().split()))\n        for j,stat in enumerate(stats):\n            ls[j].append(x*(-1)**stat[0] + y*(-1)**stat[1] + z*(-1)**stat[2])\n    ans = 0\n    for i in range(8):\n        a_ = sum(sorted(ls[i],reverse=True)[0:m])\n        if a_>ans:\n            ans = a_\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    n, m = ns()\n    res = [[] for _ in range(2 ** 3)]\n\n    if m == 0:\n        print((0))\n        return\n\n    for _ in range(n):\n        a = na()\n\n        for i in range(2 ** 3):\n            tmp = 0\n            for j in range(3):\n                if i >> j & 1:\n                    tmp += -a[j]\n                else:\n                    tmp += a[j]\n            res[i].append(tmp)\n\n    ans = -INF\n    for resi in res:\n        if len(resi) == 0:\n            continue\n        resi.sort(reverse=True)\n        ans = max(ans, sum(resi[:m]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m = list(map(int, input().split()))\n\nab = [list(map(int, input().split())) for _ in range(n)]\n\nimport itertools\nnums = [0,1]\nll = list(itertools.product(nums,repeat=3))\n\nres = 0\nfor i in ll:\n    temp =[]\n    for j in range(n):\n        if i[0]==0:\n            x = ab[j][0]\n        else:\n            x = -ab[j][0]\n        if i[1]==0:\n            y = ab[j][1]\n        else:\n            y = -ab[j][1]\n        if i[2] ==0:\n            z = ab[j][2]\n        else:\n            z = -ab[j][2]\n        temp.append(x+y+z)\n    tempp =list(sorted(temp,reverse=True))\n    res = max(res,sum(tempp[:m]))\n\nprint(res)\n", "from itertools import product\nN, M = map(int, input().split())\nxyz = [list(map(int, input().split())) for _ in range(N)]\n\nans = []\n\nfor lst in product([-1, 1], repeat = 3):\n    temp = []\n    for x, y, z in xyz:\n        temp.append(x * lst[0] + y * lst[1] + z * lst[2])\n    temp.sort(reverse=True)\n    ans.append(sum(temp[:M]))\n\nprint(max(ans))", "n,m = map(int,input().split())\ncake = [[int(i) for i in input().split()] for _ in range(n)]\nans = 0\nfor i in range(2<<3):\n    s = []\n    for j in range(n):\n        cnt = 0\n        for k in range(3):\n            if i>>k & 1: cnt += cake[j][k]\n            else: cnt -= cake[j][k]\n        s.append(cnt)\n    s.sort(reverse=True)\n    ans = max(ans, sum(s[:m]))\nprint(ans)", "n,m = map(int,input().split())\nx = []\ny = []\nz = []\n\nfor i in range(n):\n    X,Y,Z = map(int,input().split())\n    x.append(X)\n    y.append(Y)\n    z.append(Z)\n    \nppp = []\nppn = []\nnpp = []\npnp = []\npnn = []\nnpn = []\nnnp = []\nnnn = []\n\nfor j in range(n):\n    ppp.append(x[j] + y[j] + z[j])\n    ppn.append(x[j] + y[j] - z[j])\n    npp.append(-x[j] + y[j] + z[j])\n    pnp.append(x[j] -y[j] + z[j])\n    pnn.append(x[j] - y[j] - z[j])\n    npn.append(-x[j] + y[j] - z[j])\n    nnp.append(-x[j] - y[j] + z[j])\n    nnn.append(-(x[j] + y[j] + z[j]))\n    \nppp.sort(reverse=True)\nppn.sort(reverse=True)\nnpp.sort(reverse=True)\npnp.sort(reverse=True)\npnn.sort(reverse=True)\nnpn.sort(reverse=True)\nnnp.sort(reverse=True)\nnnn.sort(reverse=True)\n\nprint(max(sum(ppp[:m]),sum(ppn[:m]),sum(npp[:m]),sum(pnp[:m]),sum(pnn[:m]),sum(npn[:m]),sum(nnp[:m]),sum(nnn[:m])))", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\npm = [-1,1]\n\nn,m = ma()\nxyz = []\nfor i in range(n):\n    xyz.append(lma())\n\ndef f(p0,p1,p2):\n    xyz.sort(key=lambda x:p0*x[0]+p1*x[1]+p2*x[2],reverse=True)\n    ret=0\n    for i in range(m):\n        t=xyz[i]\n        ret+=p0*t[0]+p1*t[1]+p2*t[2]\n    return ret\ntmp=-10**15\nfor i in range(2**3):\n    p=[1,1,1]\n    for j in range(3):\n        p[j]= pm[(i >> j) &1]\n    #print(p)\n    #print(f(*p))\n    tmp=max(tmp,f(*p))\nprint(tmp)\n", "N, M = [int(x) for x in input().split()]\nXYZ = [[int(x) for x in input().split()] for _ in range(N)]\n\nans = -float(\"inf\")\n\nfor i in range(2 ** 3):\n    hugo = [1, 1, 1]\n    for j in range(3):\n        if i >> j & 1 != 1:\n            hugo[j] = -1\n\n    A = []\n    for x, y, z in XYZ:\n        A.append(x * hugo[0] + y * hugo[1] + z * hugo[2])\n\n    A.sort(reverse=True)\n    ans = max(ans, sum(A[:M]))\n\nprint(ans)\n\n\n", "from itertools import product\n\nN,M=map(int,input().split())\nscores=[list(map(int,input().split())) for _ in range(N)]\n\ndef f(score):\n  return sum([score[i]*((-1)**(1-p[i])) for i in range(3)])\n\nans=0\nfor p in product(range(2),repeat=3):\n  s = list(map(f,scores))\n  s = sorted(s,reverse=True)\n  SUM = sum(s[:M])\n  if ans < SUM:ans=SUM\n    \nprint(ans)", "import itertools\n\nN,M = map(int,input().split())\nvalue = [0] * N\n\nfor i in range(N):\n  v = list(map(int,input().split()))\n  abv = [i if i > 0 else i * - 1 for i in v]\n  value[i] = v\n\nans = 0\ntotals = []\n\nfor i in range(0,2 ** 3):\n  totals = []\n  #print(bin(i))\n  for v in range(N):\n    tmp = 0\n    for j in range(0,3):\n      if (i >> j) & 1:\n        tmp += value[v][j]\n      else:\n        tmp -= value[v][j]\n    totals.append(tmp)\n  #print(totals)\n  totals = sorted(totals,reverse = True)\n\n  t = 0\n  for k in range(M):\n    t += totals[k]\n  ans = max(ans,t)\n  \nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\ndef main():\n    N, M = map(int, readline().rstrip().split())\n    cakes = [tuple(map(int, readline().rstrip().split())) for _ in range(N)]\n    res = - 10 ** 15\n\n    for a in [1, -1]:\n        for b in [1, -1]:\n            for c in [1, -1]:\n                gains = [a*x + b*y + c*z for x, y, z in cakes]\n                gains.sort(reverse=True)\n                res = max(res, sum(gains[:M]))\n    \n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "N, M = map(int, input().split())\nC = [tuple(map(int, input().split())) for _ in range(N)]\n \nres = 0\n \nfor i in range(8): # x, y, z \u3092\u6b63\u306b\u3059\u308b\u304b\u8ca0\u306b\u3059\u308b\u304b8\u901a\u308a\u8a66\u3059\n    D = [0 for _ in range(N)]\n    for j in range(N):\n        x, y, z = C[j]\n        if (i >> 0) & 1:\n            D[j] += x\n        else:\n            D[j] -= x\n        if (i >> 1) & 1:\n            D[j] += y\n        else:\n            D[j] -= y\n        if (i >> 2) & 1:\n            D[j] += z\n        else:\n            D[j] -= z\n    D.sort(reverse=True)\n    res = max(res, sum(D[:M])) # \u305d\u306e\u4e2d\u3067\u4e00\u756a\u5927\u304d\u3044\u3082\u306eM\u500b\u3092\u3068\u308b\n \nprint(res)", "N,M = list(map(int,input().split()))\nP = []\nfor _ in range(N):\n    x,y,z = list(map(int,input().split()))\n    P.append([x,y,z])\nans = 0\nfor X in(1,-1):\n    for Y in (1,-1):\n        for Z in (1,-1):\n            A = []\n            for i in range(len(P)):\n                val = X*P[i][0] + Y*P[i][1] + Z*P[i][2]\n                A.append(val)\n            A.sort(reverse = True)\n            ans = max(ans,sum(A[:M]))\nprint(ans)\n#O(NlogN)\u3067\u5168\u5217\u6319\n", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef make_cumulative(A):\n    C = [0] * (len(A) + 1)\n    for i, a in enumerate(A):\n        i += 1\n        C[i] = C[i - 1] + a\n    return C\n\n\ndef main():\n    N, M = NMI()\n    cakes = [[] for _ in range(8)]\n    for i in range(N):\n        x, y, z = NMI()\n        cakes[0].append(sum([x, y, z]))\n        cakes[1].append(sum([x, y, -z]))\n        cakes[2].append(sum([x, -y, z]))\n        cakes[3].append(sum([x, -y, -z]))\n        cakes[4].append(sum([-x, y, z]))\n        cakes[5].append(sum([-x, y, -z]))\n        cakes[6].append(sum([-x, -y, z]))\n        cakes[7].append(sum([-x, -y, -z]))\n    for i in range(8):\n        cakes[i] = sorted(cakes[i], reverse=True)\n        cakes[i] = sum(cakes[i][:M])\n    print(max(cakes))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,m=map(int,input().split())\nxyz=[list(map(int,input().split())) for _ in range(n)]\nmaxi=0\nfor i in range(2**3):\n    idx=[]\n    for j in range(3):\n        if (i>>j)&1:\n            idx.append(j)\n    arr=[]\n    for j in range(n):\n        s=0\n        for k in range(3):\n            if k in idx:\n                s-=xyz[j][k]\n            else:\n                s+=xyz[j][k]\n        arr.append((s,j))\n    arr.sort(reverse=True)\n    x,y,z=0,0,0\n    for j in range(m):\n        x+=xyz[arr[j][1]][0]\n        y+=xyz[arr[j][1]][1]\n        z+=xyz[arr[j][1]][2]\n    maxi=max(maxi,abs(x)+abs(y)+abs(z))\nprint(maxi)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, M, *XYZ = list(map(int, read().split()))\n\n    def score(s_X, s_Y, s_Z):\n        P = [0] * N\n        for i, (x, y, z) in enumerate(zip(*[iter(XYZ)] * 3)):\n            P[i] = s_X * x + s_Y * y + s_Z * z\n\n        P.sort(reverse=True)\n        return sum(P[:M])\n\n    ans = -INF\n    for s_X in (-1, 1):\n        for s_Y in (-1, 1):\n            for s_Z in (-1, 1):\n                res = score(s_X, s_Y, s_Z)\n                if ans < res:\n                    ans = res\n\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\nx=[0]*n\ny=[0]*n\nz=[0]*n\nfor i in range(n):\n    x[i],y[i],z[i]=map(int,input().split())\n\nsign=[0]*3\nans=0\nfor i in range(8):\n    for j in range(3):\n        if ((i >> j) & 1):  \n            sign[j]=1\n        else:\n            sign[j]=-1\n    tot=0\n    arr=[0]*n\n    for k in range(n):\n        arr[k]=x[k]*sign[0]+y[k]*sign[1]+z[k]*sign[2]\n    arr=sorted(arr,reverse=True)\n    tot=sum(arr[:m])\n    if tot>ans:\n        ans=tot\nprint(ans)", "#import bisect,collections,copy,heapq,itertools,math,numpy,string\n#from operator import itemgetter\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nN, M = LI()\nA = [LI() for _ in range(N)]\nm = [[0] * 3 for _ in range(8)]\n\n# + + +\n# - - -\nA.sort(key=lambda x:x[0]+x[1]+x[2])\nfor i in range(M):\n\tfor j in range(3):\n\t\tm[0][j] += A[i][j]\n\t\tm[1][j] += A[N-1-i][j]\n\n# + + -\n# - - +\nA.sort(key=lambda x:x[0]+x[1]-x[2])\nfor i in range(M):\n\tfor j in range(3):\n\t\tm[2][j] += A[i][j]\n\t\tm[3][j] += A[N-1-i][j]\n\n# + - +\n# - + -\nA.sort(key=lambda x:x[0]-x[1]+x[2])\nfor i in range(M):\n\tfor j in range(3):\n\t\tm[4][j] += A[i][j]\n\t\tm[5][j] += A[N-1-i][j]\n\n# + - -\n# - + +\nA.sort(key=lambda x:x[0]-x[1]-x[2])\nfor i in range(M):\n\tfor j in range(3):\n\t\tm[6][j] += A[i][j]\n\t\tm[7][j] += A[N-1-i][j]\n\nprint((max([abs(x[0])+abs(x[1])+abs(x[2]) for x in m])))\n", "N,M = map(int,input().split())\nP = []\nfor _ in range(N):\n    x,y,z = map(int,input().split())\n    P.append([x,y,z])\nans = 0\nfor X in(1,-1):\n    for Y in (1,-1):\n        for Z in (1,-1):\n            A = []\n            for i in range(len(P)):\n                val = X*P[i][0] + Y*P[i][1] + Z*P[i][2]\n                A.append(val)\n            A.sort(reverse = True)\n            ans = max(ans,sum(A[:M]))\nprint(ans)", "#!/usr/bin/env python3\nn, m = list(map(int, input().split()))\nx, y, z = [0] * n, [0] * n, [0] * n\nfor i in range(n):\n    x[i], y[i], z[i] = list(map(int, input().split()))\nans = -(10 ** 9)\nfor i in range(8):\n    # a,b,c \u305d\u308c\u305e\u308c\u6b63\u8ca0\u3069\u3061\u3089\u306b\u5408\u308f\u305b\u308b\u304b\u3092\u6c7a\u3081\u308b\n    sort = []\n    bit = [-1, -1, -1]\n    if i % 2:\n        bit[0] = 1\n    if (i // 2) % 2:\n        bit[1] = 1\n    if (i // 4) % 2:\n        bit[2] = 1\n    for i in range(n):\n        sort.append(x[i] * bit[0] + y[i] * bit[1] + z[i] * bit[2])\n    sort.sort()\n    ans = max(ans, sum(sort[n - m :]))\nprint(ans)\n", "n, m = map(int, input().split())\ncake = [[int(i) for i in input().split()] for _ in range(n)]\nans = 0\nfor sign_x in [1, -1]:\n    for sign_y in [1, -1]:\n        for sign_z in [1, -1]:\n            point = []\n            for x, y, z in cake:\n                v = (x * sign_x) + (y * sign_y) + (z * sign_z)\n                point.append(v)\n            point.sort(reverse=True)\n            ans = max(sum(point[:m]), ans)\nprint(ans) ", "n,m=list(map(int,input().split()))\nxyz=[list(map(int,input().split())) for _ in range(n)]\ninf=float('inf')\nans=-inf\ndef func(multi):\n  dp=[-inf]*(m+1)\n  dp[0]=0\n  for i in range(n):\n    x,y,z=xyz[i]\n    for j in range(min(i+1,m),0,-1):\n      dp[j]=max(dp[j],dp[j-1]+x*multi[0]+y*multi[1]+z*multi[2])\n  return dp[m]\n\nfor i in range(8):\n  multi=[1]*3\n  for j in range(3):\n    if (i>>j)&1:\n      multi[j]=-1\n  ans=max(ans,func(multi))\nprint(ans)\n", "n,m = map(int,input().split())\nl = [list(map(int,input().split())) for _ in range(n)]\nl0 = []\nfor i in range(8):\n    lst = []\n    for j in range(3):\n        lst.append(i >> j & 1)\n    l0.append(lst)\n\ndef f(x,i):\n    return x*((-1)**i)\nans = 0\nfor i in range(8):\n    lst = []\n    for j in range(n):\n        lst.append(\n            f(l[j][0],l0[i][0])\n            +f(l[j][1],l0[i][1])\n            +f(l[j][2],l0[i][2])\n        )\n    lst.sort(reverse=True)\n    ans = max(ans, sum(lst[:m]))\nprint(ans)", "def d_patisserie_abc():\n    N, M = [int(i) for i in input().split()]\n    Cake = [[int(i) for i in input().split()] for j in range(N)]\n    # \u5909\u6570\u306e\u610f\u5473\u306f\uff0c\u5de6\u304b\u3089\u9806\u306b\uff0c \u7dba\u9e97\u3055, \u304a\u3044\u3057\u3055, \u4eba\u6c17\u5ea6 \u3092\u305d\u308c\u305e\u308c\n    # \u6b63\u306e\u65b9\u5411 (p) \u306b\u6700\u5927\u5316\u3059\u308b\u5834\u5408\u3068\u8ca0\u306e\u65b9\u5411 (n) \u306b\u6700\u5927\u5316\u3059\u308b\u5834\u5408\u3067\u3042\u308b\uff0e\n    # \u306a\u304a\uff0cnnn, nnp, npn, npp \u306f\uff0cppp, ppn, pnp, pnn \u3092\n    # \u9006\u306b\u3059\u308b\u3053\u3068\u3067\u5f97\u3089\u308c\u308b\uff0e\n    ppp, ppn, pnp, pnn = [], [], [], []\n    for x, y, z in Cake:\n        ppp.append(x + y + z)\n        ppn.append(x + y - z)\n        pnp.append(x - y + z)\n        pnn.append(x - y - z)\n    ppp.sort()\n    ppn.sort()\n    pnp.sort()\n    pnn.sort()\n\n    # \u5024\u304c\u5927\u304d\u306a\u3082\u306e\u3092 M \u500b\u53d6\u3063\u3066\u8db3\u3057\u3066\u7d76\u5bfe\u5024\u3092\u3068\u308b\n    pts = map(lambda x: abs(sum(x)),\n              (ppp[:M], ppn[:M], pnp[:M], pnn[:M], ppp[::-1][:M],\n               ppn[::-1][:M], pnp[::-1][:M], pnn[::-1][:M])\n              )\n    return max(pts)\n\nprint(d_patisserie_abc())", "import itertools\nimport numpy as np\n\nbit_base = 2#bit_base^n\u306e\u5168\u63a2\u67fb\u306b\u306a\u308b. \ndef Base_10_to_n(X, n):#10\u9032\u6570\u3092bit_base\u9032\u6570\u306b\u5909\u63db\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    return out\n\ndef main():\n  N, M = list(map(int, input().split()))\n  cake = []\n  for i in range(N):\n    cake.append(list(map(int, input().split())))\n  cake = np.array(cake)\n  ans = 0\n  n = 3\n  for i in range(bit_base**n):\n    s = Base_10_to_n(i, bit_base)\n    s = s.zfill(n)\n    cake_temp = cake.copy()\n    for num, j in enumerate(s):\n      if j == '0':\n        cake_temp[:, num] *= -1\n    cake_temp = np.sum(cake_temp, axis = 1)\n    cake_temp = sorted(cake_temp)\n    ans = max(sum(cake_temp[-M:]), ans)\n  if M == 0:\n    ans = 0\n  print(ans)\n  \ndef __starting_point():\n  main()\n\n__starting_point()", "#import bisect,collections,copy,heapq,itertools,math,numpy,string\n#from operator import itemgetter\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nN, M = LI()\nA = [LI() for _ in range(N)]\nm = [[0] * 3 for _ in range(8)]\n\nfor c in range(4):\n  A.sort(key=lambda x:(((c>>2)&1)*2-1)*x[0]+(((c>>1)&1)*2-1)*(-1)*x[1]+((c&1)*2-1)*x[2])\n  for i in range(M):\n  \tfor j in range(3):\n  \t\tm[c*2][j] += A[i][j]\n  \t\tm[c*2+1][j] += A[N-1-i][j]\n\nprint((max([abs(x[0])+abs(x[1])+abs(x[2]) for x in m])))\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n\nN, M = mi()\nxyz = li2(N)\n\nsign = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]]\nans = 0\n\nfor i in range(8):\n    A = [sum(xyz[x][k] * sign[i][k] for k in range(3)) for x in range(N)]\n\n    A = sorted(A, reverse=True)\n\n    ans = max(ans, sum(A[:M]))\n\nprint(ans)", "N, M = map(int, input().split())\nC = [tuple(map(int, input().split())) for _ in range(N)]\n\nres = 0\n\nfor i in range(8):\n    D = [0 for _ in range(N)]\n    for j in range(N):\n        x, y, z = C[j]\n        if (i >> 0) & 1:\n            D[j] += x\n        else:\n            D[j] -= x\n        if (i >> 1) & 1:\n            D[j] += y\n        else:\n            D[j] -= y\n        if (i >> 2) & 1:\n            D[j] += z\n        else:\n            D[j] -= z\n    D.sort(reverse=True)\n    res = max(res, sum(D[:M]))\n\nprint(res)", "def main():\n    n, m = list(map(int, input().split()))\n    info = [list(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for i in range(1 << 3):\n        now_ans = [0] * n\n        for j in range(3):\n            d = 1\n            if (i >> j) & 1:\n                d *= -1\n            for k in range(n):\n                now_ans[k] += d * info[k][j]\n        now_ans.sort(reverse=True)\n        ans = max(ans, sum(now_ans[:m]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import product\nN, M = map(int, sys.stdin.readline().rstrip().split())\n\ncake = [tuple(map(int, sys.stdin.readline().rstrip().split())) for _ in range(N)]\n\nans = 0\nfor i, j, k in product([-1, 1], repeat=3):\n    data = [i * x + j * y + k * z for x, y, z in cake]\n    ans = max(ans, sum(sorted(data)[::-1][:M]))\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\ndef main():\n    N, M = list(map(int, input().split()))\n    xyz = [None for _ in range(N)]\n    for i in range(N):\n        xyz[i] = list(map(int, input().split()))\n    # print(xyz)\n    ans = 0\n    for i in range(2**3):\n        tmp = [0] * N\n        for j in range(N):\n            for k in range(3):\n                if i >> k & 1:\n                    tmp[j] += xyz[j][k]\n                else:\n                    tmp[j] -= xyz[j][k]\n        tmp.sort(reverse=True)\n        ans = max(ans, sum(tmp[:M]))\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m=map(int,input().split())\ncake=[[int(i)for i in input().split()]for j in range(n)]\na=sum(sorted([sum(i)for i in cake],reverse=True)[:m])\nb=sum(sorted([cake[i][0]+cake[i][1]-cake[i][2]for i in range(n)],reverse=True)[:m])\nc=sum(sorted([cake[i][0]-cake[i][1]-cake[i][2]for i in range(n)],reverse=True)[:m])\nd=sum(sorted([cake[i][0]-cake[i][1]+cake[i][2]for i in range(n)],reverse=True)[:m])\ne=sum(sorted([0-cake[i][0]+cake[i][1]-cake[i][2]for i in range(n)],reverse=True)[:m])\nf=sum(sorted([0-cake[i][0]+cake[i][1]+cake[i][2]for i in range(n)],reverse=True)[:m])\ng=sum(sorted([0-cake[i][0]-cake[i][1]-cake[i][2]for i in range(n)],reverse=True)[:m])\nh=sum(sorted([0-cake[i][0]-cake[i][1]-cake[i][2]for i in range(n)],reverse=True)[:m])\nprint(max(a,b,c,d,e,f,g,h))", "n,m=list(map(int,input().split()))\nX=list()\nY=list()\nZ=list()\nfor i in range(n):\n    x,y,z=list(map(int,input().split()))\n    X.append(x)\n    Y.append(y)\n    Z.append(z)\nA=list()\nB=list()\nC=list()\nD=list()\nfor i in range(n):\n    A.append(X[i]+Y[i]+Z[i])\n    B.append(-X[i]+Y[i]+Z[i])\n    C.append(X[i]-Y[i]+Z[i])\n    D.append(X[i]+Y[i]-Z[i])\nimport functools\nA.sort()\nB.sort()\nC.sort()\nD.sort()\nif m==0:\n    print((0))\nelse:\n    x1=functools.reduce(lambda x,y:x+y,[A[i] for i in range(m)])\n    x2=functools.reduce(lambda x,y:x+y,[A[-i] for i in range(1,m+1)])\n    y1=functools.reduce(lambda x,y:x+y,[B[i] for i in range(m)])\n    y2=functools.reduce(lambda x,y:x+y,[B[-i] for i in range(1,m+1)])\n    z1=functools.reduce(lambda x,y:x+y,[C[i] for i in range(m)])\n    z2=functools.reduce(lambda x,y:x+y,[C[-i] for i in range(1,m+1)])\n    w1=functools.reduce(lambda x,y:x+y,[D[i] for i in range(m)])\n    w2=functools.reduce(lambda x,y:x+y,[D[-i] for i in range(1,m+1)])\n    print((max(abs(x1),abs(x2),abs(y1),abs(y2),abs(z1),abs(z2),abs(w1),abs(w2))))\n", "n, m = [int(s) for s in input().split()]\ncake_list = [[int(s) for s in input().split()] for _ in range(n)]\n\nans_list = [0] * 8\nfor i in range(8):\n    a, b, c = [1 if (i >> j) & 1 == 1 else -1 for j in range(3)]\n    temp_list = sorted([a * x + b * y + c * z for x, y, z in cake_list], reverse=True)\n\n    for j in range(m):\n        ans_list[i] += temp_list[j]\nprint(max(ans_list))", "import bisect\n\nn,m = map(int,input().split())\n\nx,y,z = [],[],[]\n\nfor _ in range(n):\n    i,j,k = map(int,input().split())\n    x.append(i)\n    y.append(j)\n    z.append(k)\n\nans = 0\n\nfor i in [-1,1]:\n    for j in [-1,1]:\n        for k in [-1,1]:\n            li = []\n            for l in range(n):\n                li.append(x[l]*i+y[l]*j+z[l]*k)\n            li.sort(reverse=True)\n            ans = max(ans,sum(li[:m]))\n\nprint(ans)", "import sys\nfrom itertools import product\ninput = sys.stdin.readline\n\n\ndef log(*args):\n    print(*args, file=sys.stderr)\n\n\ndef main():\n    n, m = map(int, input().split())\n    l = [tuple(map(int, input().split())) for _ in range(n)]\n    ans = 0\n    for i, j, k in product([-1, 1], repeat=3):\n        l2 = sorted([x * i + y * j + z * k for x, y, z in l], reverse=True)\n        ans = max(ans, sum(l2[:m]))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import product\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, m = list(map(int, input().split()))\n    XYZ = [list(map(int, input().split())) for _ in range(n)]\n\n    res = 0\n    for pattern in product([0, 1], repeat=3):\n        op = [1 if p == 0 else -1 for p in pattern]\n        tmp = [0] * n\n        for i in range(n):\n            tmp[i] = sum([o * num for o, num in zip(op, XYZ[i])])\n        tmp.sort(reverse=True)\n        res = max(res, sum(tmp[:m]))\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()"]
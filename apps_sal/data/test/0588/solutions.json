["import numpy as np\n\nn=int(input())\nxy=[]\nfor i in range(n):\n    xy.append(list(map(int,input().split())))\n\ndef naiseki(a,b):\n    if (a[0]*b[0]+a[1]*b[1])>0.0:\n        return True\n    else:\n        return False\n    \nans=0\n\nfor i in range(1001):\n    xl=np.cos(np.pi*2.0*i/1000.0)\n    yl=np.sin(np.pi*2.0*i/1000.0)\n    x=0\n    y=0\n    for j in range(n):\n        if naiseki([xl,yl],xy[j]):\n            x+=xy[j][0]\n            y+=xy[j][1]\n    ans=max(ans,np.sqrt(x**2+y**2))\nprint(ans)\n", "# \u51f8\u5305 Monotone Chain O(nlogn)\n# \u53c2\u8003: https://matsu7874.hatenablog.com/entry/2018/12/17/025713\ndef get_convex_hull(points):\n    def det(p, q):\n        return p[0] * q[1] - p[1] * q[0]\n    def sub(p, q):\n        return (p[0] - q[0], p[1] - q[1])\n    points.sort()\n    ch = []\n    for p in points:\n        while len(ch) > 1:\n            v_cur = sub(ch[-1], ch[-2])\n            v_new = sub(p, ch[-2])\n            if det(v_cur, v_new) > 0:\n                break\n            ch.pop()\n        ch.append(p)\n    t = len(ch)\n    for p in points[-2::-1]:\n        while len(ch) > t:\n            v_cur = sub(ch[-1], ch[-2])\n            v_new = sub(p, ch[-2])\n            if det(v_cur, v_new) > 0:\n                break\n            ch.pop()\n        ch.append(p)\n    return ch[:-1]\nN = int(input())\nXY = [list(map(int, input().split())) for _ in range(N)]\nps = [(0, 0)]\nfor x, y in XY:\n    ps_new = ps[:]\n    for x_, y_ in ps:\n        ps_new.append((x+x_, y+y_))\n    ps = get_convex_hull(ps_new)\nans = 0\nfor x, y in ps:\n    ans = max(ans, x*x+y*y)\nprint(ans ** 0.5)", "import sys\nimport math\nfrom collections import deque\n\ninput = sys.stdin.readline\n\n\ndef solve(n, x_y_list):\n    radians = [(math.atan2(y, x), x, y) for x, y in x_y_list]\n    radians.sort()\n    radians = radians + radians\n\n    max_square_distance = 0\n    for start in range(n):\n        sum_x = sum_y = 0\n        for i in range(n):\n            _, x, y = radians[start + i]\n            sum_x += x\n            sum_y += y\n            square_distance = sum_x ** 2 + sum_y ** 2\n            if max_square_distance < square_distance:\n                max_square_distance = square_distance\n    return math.sqrt(max_square_distance)\n\n\ndef __starting_point():\n    n = int(input())\n    x_y_list = [tuple(map(int, input().split())) for _ in range(n)]\n\n    answer = solve(n, x_y_list)\n    print(answer)\n\n__starting_point()", "from cmath import phase\n\nN, *XY = map(int, open(0).read().split())\n\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\nXY += XY\n\nprint(max(abs(sum(XY[i:j])) for i in range(2 * N + 1) for j in range(2 * N + 1) if j - i <= N))", "\nN = int(input())\n\nsxy41 = []\nsxy23 = []\n\nfor i in range(N):\n    \n    x,y = list(map(int,input().split()))\n\n    if x == 0 and y >= 0:\n\n        s = float(\"inf\")\n\n    elif x == 0 and y < 0:\n\n        s = -1 * float(\"inf\")\n\n    else:\n\n        s = y / x\n\n    if x >= 0:\n        sxy41.append([s,x,y])\n    else:\n        sxy23.append([s,x,y])\n\nsxy41.sort()\nsxy23.sort()\n\nsxy = []\n\nfor i in sxy41:\n    sxy.append(i)\nfor i in sxy23:\n    sxy.append(i)\n\nans = 0\n\n\nfor i in range(N):\n\n    for j in range(i):\n\n        nowx = 0\n        nowy = 0\n\n        for k in range(i-j+1):\n\n            k += j\n\n            nowx += sxy[k][1]\n            nowy += sxy[k][2]\n\n        ans = max(ans,(nowx ** 2 + nowy ** 2) ** 0.5)\n\n\nsxy = []\n\nfor i in sxy23:\n    sxy.append(i)\nfor i in sxy41:\n    sxy.append(i)\n\n\nfor i in range(N):\n\n    for j in range(i+1):\n\n        nowx = 0\n        nowy = 0\n\n        for k in range(i-j+1):\n\n            k += j\n\n            nowx += sxy[k][1]\n            nowy += sxy[k][2]\n\n        ans = max(ans,(nowx ** 2 + nowy ** 2) ** 0.5)\n\nprint (ans)\n\n        \n", "import sys\nfrom operator import itemgetter\nimport math\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\n\n    txy = []\n    for x, y in XY:\n        t = math.atan2(x, y)\n        txy.append([t, x, y])\n\n    txy.sort()\n\n    ans = 0\n    for i in range(N):\n        tmpx = 0\n        tmpy = 0\n        for j in range(N):\n            tmpx += txy[(i + j) % N][1]\n            tmpy += txy[(i + j) % N][2]\n            ans = max(ans, math.sqrt(tmpx ** 2 + tmpy ** 2))\n\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nN = int(input())\nn = 1000\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * math.cos(theta) + y[j] * math.sin(theta) > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\n\nN = inp()\npoints = []\n\nfor _ in range(N):\n    x,y = inpl()\n    t = math.atan2(y,x)\n    points.append((t,x,y))\n\npoints.sort()\n\nans = 0\nfor s,[theta,x,y] in enumerate(points):\n    tmpx = tmpy = 0\n    for t in range(s,s+N):\n        _,tx,ty = points[t%N]\n        tmpx += tx\n        tmpy += ty\n        ans = max(ans,tmpx**2 + tmpy**2)\n\nprint((math.sqrt(ans)))\n", "import sys\nfrom operator import itemgetter\nimport math\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\n\n    txy = []\n    for x, y in XY:\n        t = math.atan2(y, x)\n        txy.append([t, x, y])\n\n    txy.sort()\n\n    ans = 0\n    for i in range(N):\n        tmpx = 0\n        tmpy = 0\n        for j in range(N):\n            tmpx += txy[(i + j) % N][1]\n            tmpy += txy[(i + j) % N][2]\n            ans = max(ans, math.sqrt(tmpx ** 2 + tmpy ** 2))\n\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\ndef arg(x,y):\n  if x==0:\n    if y>0:\n      return math.pi/2\n    else:\n      return 3*math.pi/2\n  else:\n    if x>0:\n      return math.atan(y/x)\n    else:\n      return math.atan(y/x)+math.pi\nn=int(input())\nA=[]\nfor i in range(n):\n  x,y=map(int,input().split())\n  if x==0 and y==0:\n    continue\n  A.append([arg(x,y),x,y])\n  A.append([arg(x,y)+2*math.pi,x,y])\nA=sorted(A)\nn=len(A)//2\nans=0\nfor i in range(n):#\u59cb\u70b9\n  for j in range(1,n+1):#\u9023\u7d9a\u6570\n    X=0\n    Y=0\n    for k in range(i,i+j):\n      X=X+A[k][1]\n      Y=Y+A[k][2]\n    d=(X**2+Y**2)**(1/2)\n    if d>ans:\n      ans=d\nprint(ans)", "import sys\nfrom math import *\n\nsys.setrecursionlimit(10 ** 6)\n\ndef main():\n    n = int(input())\n    en = []\n    n0 = n\n    for _ in range(n0):\n        x, y = list(map(int, input().split()))\n        if (x, y) == (0, 0):\n            n -= 1\n            continue\n        en.append([atan2(y, x), x, y])\n    en.sort()\n#    print(en)\n\n    ans = 0\n    for l in range(n):\n        sx = sy = 0\n        arg_l = en[l][0]\n        r = l\n        for _ in range(n):\n            if (en[r][0] - arg_l) % (2 * pi) > pi: break\n            sx += en[r][1]\n            sy += en[r][2]\n            ans = max(ans, (sx ** 2 + sy ** 2))\n            r = (r + 1) % n\n    print((ans ** 0.5))\n\nmain()\n", "import sys\nimport numpy as np\nimport math\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    n = int(input())\n    engine = np.zeros((n, 3))\n    for i in range(n):\n        engine[i][0], engine[i][1] = map(int, input().split())\n        engine[i][2] = math.atan2(engine[i][1], engine[i][0])\n    engines = engine[np.argsort(engine[:, 2])]\n    sumen = sum(engines)\n    ans = sumen[0]**2+sumen[1]**2\n    for i in range(n):\n        for j in range(i, n):\n            sump=sum(engines[i:j+1])\n            ans=max(ans,sump[0]**2+sump[1]**2,(sump[0]-sumen[0])**2+(sump[1]-sumen[1])**2)\n    print(math.sqrt(ans))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\n\nN=int(input())\nP=[list(map(int,input().split())) for i in range(N)]\n\ndef div2(x,y):\n    if x>0:\n        return (1,y/x)\n    elif x<0:\n        return (-1,y/x)\n    else:\n        if y>0:\n            return (-1,-float(\"inf\"))\n        else:\n            return (1,-float(\"inf\"))\n\nP.sort(key=lambda x:div2(x[0],x[1]))\n\nANS=0\n\nfor i in range(N):\n    for j in range(i,N):\n        x0=y0=0\n        x1=y1=0\n\n        for k in range(N):\n            if i<=k<=j:\n                x0+=P[k][0]\n                y0+=P[k][1]\n            else:\n                x1+=P[k][0]\n                y1+=P[k][1]\n\n        ANS=max(ANS,x0**2+y0**2,x1**2+y1**2)\n\nprint((math.sqrt(ANS)))\n", "ii = lambda : int(input())\nmi = lambda : map(int,input().split())\nli = lambda : list(map(int,input().split()))\n\nn = ii()\nimport math\na = []\nfor i in range(n):\n    x,y = mi()\n    x += 1e-15\n    theta = math.degrees(math.atan2(y,x))\n    a.append([theta,x,y])\na.sort()\na2 = list(a)\na = a + a2\nimport numpy as np\nx = []\ny = []\nfor i in range(len(a)):\n    x.append(a[i][1])\n    y.append(a[i][2])\nx = np.array(x)\ny = np.array(y)\nxsum = np.cumsum(x)\nysum = np.cumsum(y)\nans = 0\nfor i in range(1,n+1):\n    for k in range(i,n+i):\n        xtmp = xsum[k] - xsum[i-1]\n        ytmp = ysum[k] - ysum[i-1]\n        tmp = (xtmp**2 + ytmp**2) ** 0.5\n        ans = max(ans,tmp)\nprint(ans)", "from itertools import combinations\nfrom cmath import phase\nN = int(input())\nXY = [complex(*list(map(int, input().split()))) for _ in range(N)]\nXY.sort(key=phase)\nXY += XY\nprint((max(abs(sum(XY[i:j])) for i, j in combinations(list(range(N*2+1)), 2) if j-i<=N)))\n", "from math import atan2, pi\n\nN = int(input())\nengines = []\ntotal_X = total_Y = 0\nfor i in range(N):\n  x, y = map(int, input().split())\n  engines.append((atan2(y, x), x, y)) # (theta, x, y)\n  total_X += x\n  total_Y += y\n\nengines.sort()\nans2 = 0\nl = r = 0\nX = engines[0][1]\nY = engines[0][2]\n\nfor l in range(N):\n  theta = engines[l][0]\n  xl, yl = engines[l][1:]\n  while r + 1 - l < N \\\n      and (theta <= engines[(r+1)%N][0] < theta+pi \\\n           or theta <= engines[(r+1)%N][0]+2*pi < theta+pi):\n    r += 1\n    X += engines[r%N][1]\n    Y += engines[r%N][2]\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2)\n  while r + 1 - l < N \\\n      and (theta <= engines[(r+1)%N][0] <= theta+pi \\\n           or theta <= engines[(r+1)%N][0]+2*pi <= theta+pi):\n    r += 1\n    X += engines[r%N][1]\n    Y += engines[r%N][2]\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2)\n  X -= xl\n  Y -= yl\n\nprint(ans2 ** 0.5)", "from math import atan2, hypot\n\ndef solve():\n    N = int(input())\n    engines = [tuple(map(int, input().split())) for _ in range(N)]\n\n    engines.sort(key=lambda x: atan2(x[1], x[0]))\n\n    ans = 0\n    for L in range(N):\n        for R in range(L, L+N):\n            x, y = 0, 0\n            for i in range(L, R+1):\n                i %= N\n                dx, dy = engines[i]\n                x, y = x+dx, y+dy\n            dist = hypot(x, y)\n            if dist > ans:\n                ans = dist\n\n    print(ans)\n\n\nsolve()\n", "n=int(input())\nxy=[tuple(map(int,input().split())) for _ in range(n)]\nimport numpy as np\ne=(1,0)\nxyz=[]\nk=0\nfor x,y in xy:\n  if x==0 and y==0:continue\n  k+=1\n  l=np.linalg.norm((x,y))\n  z=np.inner((x/l,y/l),e)\n  theta = np.rad2deg(np.arccos(z))\n  if y<0:\n    theta=360-theta\n  xyz.append((x,y,theta))\nxyz.sort(key=lambda x:x[2])\n\n\ntx,ty=0,0\nc=[(0,0)]\nfor x,y,z in xyz:\n  tx+=x\n  ty+=y\n  c.append((tx,ty))\nfor x,y,z in xyz:\n  tx+=x\n  ty+=y\n  c.append((tx,ty))\n\nans=0\nfor i in range(k):\n  for j in range(k):\n    x=c[i+j+1][0]-c[i][0]\n    y=c[i+j+1][1]-c[i][1]\n    ans=max(ans,(x**2+y**2)**0.5)\nprint(ans)\n", "import math\nN=int(input())\nengines = tuple((complex(*map(int, input().split())) for _ in range(N)))\nengines = sorted(list((engine, math.atan2(engine.imag, engine.real))for engine in engines if engine != 0), key=lambda x:x[1])\nN=len(engines)\nif N == 0:\n    print(0)\nelse:\n    total = sum(engine[0] for engine in engines)\n    head_index = max(i if engines[i][0].imag < 0 else -1 for i in range(N))\n    tail_index = 0\n    tmp = sum(engines[i][0] for i in range(tail_index,head_index+1))\n    maximum = max(abs(tmp), abs(total - tmp))\n\n    while True:\n        if head_index < N-1:\n            if (engines[head_index+1][0]/engines[tail_index][0]).imag >= 0:\n                head_index += 1\n            else:\n                tail_index += 1\n        else:\n            if (engines[0][0]/engines[tail_index][0]).imag < 0:\n                tail_index += 1\n            else:\n                break\n        tmp = sum(engines[i][0] for i in range(tail_index,head_index+1))\n        maximum = max(maximum, abs(tmp), abs(total - tmp))\n\n    print(maximum)", "from cmath import phase\n\nN, *XY = map(int, open(0).read().split())\n\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\nXY += XY\n\n\nans = 0\nfor i in range(2 * N + 1):\n    for j in range(2 * N + 1):\n        if j - i <= N:\n            ans = max(ans, abs(sum(XY[i:j])))\n\nprint(ans)", "import cmath\nimport math\n\nN = int(input())\npc = []\nfor i in range(N):\n  x, y = list(map(int, input().split()))\n  c = x + y*1j\n  p = cmath.phase(c)\n  pc.append([p, c])\npc = sorted(pc, key=lambda x: x[0])\n\nps = [pc[i][0] for i in range(N)]\ncs = [pc[i][1] for i in range(N)]\n\ndef L(i, j, N):\n  if i<j:\n    return list(range(i, j))\n  else:\n    return list(range(0, j)) + list(range(i+1, N))\n\ns = 0\nm = 0\n\nfor start in range(N):\n  for end in range(N):\n    s = 0\n    #print(start,end,N,L(start,end,N))\n    for k in L(start,end,N):\n      s += cs[k]\n    m = max(m, abs(s))\ns = 0\nfor k in range(N):\n  s += cs[k]\n  m = max(m, abs(s))\nprint(m)\n", "import math\nn = int(input())\nxy = []\nfor i in range(n):\n    x, y = [int(item) for item in input().split()]\n    if x == 0 and y == 0:\n        rad = 0.0\n    elif x == 0:\n        if y > 0:\n            rad = math.pi / 2.0\n        elif y < 0:\n            rad = -math.pi / 2.0\n    else:\n        rad = math.atan2(y, x)\n    deg = math.degrees(rad)\n    xy.append((deg, x, y))\n\nxy.sort()\nxy2 = xy[:]\nfor i, (d, x, y) in enumerate(xy):\n    xy2.append((d+360.0, x, y))\n    if i == 0:\n        xy2.append((d+720.0, x, y))\nxy2.sort()\n\nans = 0.0\nfor i in range(n):\n    for j in range(i+1, i+n+1):\n        x = 0.0; y = 0.0\n        for k in range(i, j):\n            x += xy2[k][1]\n            y += xy2[k][2]\n        d = math.hypot(x, y)\n        ans = max(ans, d)\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**7)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline().strip()\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nimport math\n\ndef main(): \n    N = II()\n    engines = []\n    for _ in range(N):\n        x, y = LI()\n        angle = math.atan2(y, x)\n        engines.append((x,y,angle))\n\n    # \u504f\u89d2\u30bd\u30fc\u30c8\n    engines.sort(key=lambda x: x[2])\n\n    dist_max = 0\n    # \u5404\u30a8\u30f3\u30b8\u30f3\u3092\u5148\u982d\u306b\u3001\u305d\u3053\u304b\u3089 pi \u306e\u7bc4\u56f2\u306b\u3042\u308b\u30a8\u30f3\u30b8\u30f3\u3092\u3059\u3079\u3066\u7528\u3044\u3066\u9032\u884c\u3057\u3001\u8ddd\u96e2\u3092\u7b97\u51fa\u3059\u308b\u3002\n    cnt = -1\n    for x1, y1, angle1 in engines:\n        cnt += 1\n        if angle1 <= 0:\n            search_criteria = lambda x: True if angle1 <= x < angle1+math.pi else False\n        else:\n            search_criteria = lambda x: True if (angle1 <= x) or (x < angle1-math.pi) else False\n        # search_criteria = lambda x, y: True if x1*x + y1*y > 0 else False\n\n        x_sum = 0\n        y_sum = 0\n        for x, y, angle in engines[cnt:] + engines[:cnt]:\n            if search_criteria(angle):\n            # if search_criteria(x, y):\n                x_sum += x\n                y_sum += y\n            dist_max = max(dist_max, math.sqrt(x_sum**2 + y_sum**2))\n    \n    print(dist_max)\n\nmain()", "import sys\nfrom math import atan2, pi\n\nn = int(input())\nangles = []\nengines = []\npi2 = 2 * pi\nfor i, line in enumerate(sys.stdin):\n    x, y = list(map(int, line.split()))\n    angle = atan2(y, x)\n    angles.append((angle, i))  # -pi~pi\n    angles.append((angle + pi2, i))  # pi~3pi\n    engines.append(x + y * 1j)\nangles.sort()\n\nr = 0\ntmp = 0\ntotal = sum(engines)\nans = 0\nfor l in range(n):\n    angle, i = angles[l]\n    limit = angle + pi - 1e-9\n    while angles[r][0] < limit:\n        tmp += engines[angles[r][1]]\n        r += 1\n    ans = max(ans, abs(tmp), abs(total - tmp))\n    tmp -= engines[i]\nprint(ans)\n", "N=int(input())\nfrom cmath import phase\nXY=sorted([list(map(int,input().split())) for i in range(N)],key=lambda x: phase(x[0]+x[1]*1j))\nXY+=XY\nans=0\nfor l in range(N):\n    a=[0,0]\n    for r in range(l,min(2*N,l+N)):\n        a[0]+=XY[r][0]\n        a[1]+=XY[r][1]\n        ans=max(ans,abs(a[0]+a[1]*1j))\nprint(ans)", "\nimport math\nN = int(input())\nXY = [list(map(int,input().split())) for _ in  range(N)]\nfor i in range(N):\n    XY[i].append(math.atan2(XY[i][1],XY[i][0]))\n\nXY.sort(key = lambda x:x[2])\nans = 0\ntmp = [0,0]\nruisekiwa_x = [0] * N\nruisekiwa_y = [0] * N\nruisekiwa_x[0] = XY[0][0]\nruisekiwa_y[0] = XY[0][1]\n\nfor i in range(1,N):\n    ruisekiwa_x[i] = ruisekiwa_x[i-1] + XY[i][0]\n    ruisekiwa_y[i] = ruisekiwa_y[i-1] + XY[i][1]\n    \nans = 0\nfor i in range(N):\n    for j in range(i,N):\n        if i>0: \n            tmp[0] = ruisekiwa_x[j] - ruisekiwa_x[i-1]\n            tmp[1] = ruisekiwa_y[j] - ruisekiwa_y[i-1]\n        else:\n            tmp[0] = ruisekiwa_x[j] \n            tmp[1] = ruisekiwa_y[j] \n            \n            \n        ans = max(ans,math.sqrt(tmp[0]*tmp[0] + tmp[1]*tmp[1]))\nfor i in range(N):\n    if XY[i][2] < 0:\n        XY[i][2] = -math.pi-XY[i][2]\n    else:\n        XY[i][2] = math.pi - XY[i][2]\n        \n\nXY.sort(key = lambda x:x[2])\nruisekiwa_x = [0] * N\nruisekiwa_y = [0] * N\nruisekiwa_x[0] = XY[0][0]\nruisekiwa_y[0] = XY[0][1]\n\nfor i in range(1,N):\n    ruisekiwa_x[i] = ruisekiwa_x[i-1] + XY[i][0]\n    ruisekiwa_y[i] = ruisekiwa_y[i-1] + XY[i][1]\n    \nfor i in range(N):\n    for j in range(i,N):\n        if i>0: \n            tmp[0] = ruisekiwa_x[j] - ruisekiwa_x[i-1]\n            tmp[1] = ruisekiwa_y[j] - ruisekiwa_y[i-1]\n        else:\n            tmp[0] = ruisekiwa_x[j] \n            tmp[1] = ruisekiwa_y[j] \n            \n            \n        ans = max(ans,math.sqrt(tmp[0]*tmp[0] + tmp[1]*tmp[1]))\n        \nprint(ans)\n\n", "import cmath\nimport math\nn=int(input())\na=[]\nb=[]\n#\u504f\u89d2\u30bd\u30fc\u30c8\u306e\u65b9\u304c\u697d\nfor i in range(n):\n    x,y=list(map(int,input().split()))\n    a.append(complex(x,y))\n    b.append(cmath.phase(a[i]))\n#a.sort(key=cmath.phase)\nma=0\n#math.pi\u306b\u6ce8\u610f\nfor i in range(n):\n    z=a[i]\n    c=b[i]-math.pi/2\n    d=b[i]+math.pi/2\n    l=max([c,-math.pi])\n    r=min([d,math.pi])\n    #(0,0)\u306e\u6642\u306f\u504f\u89d2\u304c0\u306b\u306a\u3063\u3066\u3057\u307e\u3046\u3057\u3001\u9664\u304f\n    #\u3042\u3068\u306f-pi\u3068pi\u3069\u3063\u3061\u306b\u306a\u308b\u304b\u2192pi\u306b\u306a\u308b\n    if a[i]!=complex(0,0):\n        for j in range(n):\n            if j!=i:\n                #\u5883\u754c\u6761\u4ef6\u306e\u5834\u5408\u5206\u3051\u304c\u3080\u305a\u3044\n                if l<=b[j]<=r or (c<=-math.pi and c+2*math.pi<=b[j]<=math.pi) or (d>=math.pi and -math.pi<=b[j]<=d-2*math.pi):\n                    z+=a[j]\n    ma=max([abs(z),ma])\nm=0\n#math.pi\u306b\u6ce8\u610f\nfor i in range(n):\n    if a[i]!=complex(0,0):\n        za,zb=complex(0,0),complex(0,0)\n        for j in range(n):\n            p=cmath.phase(a[j]/a[i])\n            if -math.pi<=p<=0:\n                za+=a[j]\n            if 0<=p<=math.pi:\n                zb+=a[j]\n        m=max([m,abs(za),abs(zb)])\n        if i!=n-1 and a[i]+a[i+1]!=0:\n            zc,zd=complex(0,0),complex(0,0)\n            for j in range(n):\n                p=cmath.phase(a[j]/((a[i]+a[i+1])/2))\n                if -math.pi<=p<=0:\n                    zc+=a[j]\n                if 0<=p<=math.pi:\n                    zd+=a[j]\n            m=max([m,abs(zc),abs(zd)])\n\nprint((max([m,ma])))\n", "import numpy as np\nN = int(input())\nX = []\nY = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\nX = np.array(X)\nY = np.array(Y)\ntheta = np.arctan2(X, Y)\nindex = theta.argsort()\nX = X[index]\nY = Y[index]\nX = np.tile(X, 2)\nY = np.tile(Y, 2)\nXcum = X.cumsum()\nYcum = Y.cumsum()\nans = (Ycum-Ycum[:, None])**2+(Xcum-Xcum[:, None])**2\nm = 0\nfor i in range(N*2):\n    m = max(m, ans[i, i:i+N+1].max())\nprint(m**0.5)", "# -*- coding: utf-8 -*-\nimport math\n\n\n\ndef main():\n    N = int(input())\n    E = []\n    for i in range(N):\n        x, y = list(map(int,input().split()))\n        E.append((math.atan2(y,x),x,y))\n    E = sorted(E) * 2\n\n    answer = 0\n    for i in range(N):\n        x = 0\n        y = 0\n        for j in range(i, i+N):\n            x += E[j][1]\n            y += E[j][2]\n            answer = max(answer, x * x + y * y)\n\n    answer = math.sqrt(answer)\n    print(answer)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import atan2, pi\n\nN = int(input())\nengines = []\ntotal_X = total_Y = 0\nfor i in range(N):\n  x, y = map(int, input().split())\n  engines.append((atan2(y, x), x, y)) # (theta, x, y)\n  total_X += x\n  total_Y += y\n\nengines.sort()\nans2 = 0\nl = r = 0\nX = engines[0][1]\nY = engines[0][2]\n\nfor l in range(N):\n  theta = engines[l][0]\n  xl, yl = engines[l][1:]\n  # l\u756a\u76ee\u306e\u30d9\u30af\u30c8\u30eb\u306e\u5fae\u5c0f\u89d2\u5c0f\u3055\u3044\u3068\u3053\u308d\u306b\u5883\u754c\u9762\u3092\u8a2d\u5b9a\n  while r + 1 - l < N \\\n      and (theta <= engines[(r+1)%N][0] < theta+pi \\\n           or theta <= engines[(r+1)%N][0]+2*pi < theta+pi):\n    r += 1\n    X += engines[r%N][1]\n    Y += engines[r%N][2]\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2) # \u5883\u754c\u9762\u306e\u4e21\u9762\u3092\u30c1\u30a7\u30c3\u30af\n  # l\u756a\u76ee\u306e\u30d9\u30af\u30c8\u30eb\u4e01\u5ea6(\u5fae\u5c0f\u89d2\u5927\u304d\u3044\u3068\u3053\u308d)\u306b\u5883\u754c\u9762\u3092\u8a2d\u5b9a\n  while r + 1 - l < N \\\n      and (theta <= engines[(r+1)%N][0] <= theta+pi \\\n           or theta <= engines[(r+1)%N][0]+2*pi <= theta+pi):\n    r += 1\n    X += engines[r%N][1]\n    Y += engines[r%N][2]\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2) # \u5883\u754c\u9762\u306e\u4e21\u9762\u3092\u30c1\u30a7\u30c3\u30af\n  X -= xl\n  Y -= yl\n\nprint(ans2 ** 0.5)", "L = 10**10\n\nN = int(input())\nx, y = zip(*(map(int, input().split()) for _ in range(N)))\n\nresult = 0\nfor i in range(N):\n    for b in [-1, 1]:\n        for s, t in [(y[i], -x[i]), (-y[i], x[i])]:\n            s, t = L * s - b * t, b * s + L * t\n            X = 0\n            Y = 0\n            for j in range(N):\n                if x[j] * s + y[j] * t > 0:\n                    X += x[j]\n                    Y += y[j]\n            result = max(result, (X**2 + Y**2)**0.5)\nprint(result)", "import sys\nfrom operator import itemgetter\nimport math\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\n\n    ans = 0\n\n    # x\n    # plus, plus\n    tmp = [0, 0]\n    for x, y in XY:\n        if x > 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif x == 0 and y > 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # x\n    # plus, minus\n    tmp = [0, 0]\n    for x, y in XY:\n        if x > 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif x == 0 and y < 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # x\n    # minus, plus\n    tmp = [0, 0]\n    for x, y in XY:\n        if x < 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif x == 0 and y > 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # x\n    # minus, minus\n    tmp = [0, 0]\n    for x, y in XY:\n        if x < 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif x == 0 and y < 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # y\n    # plus, plus\n    tmp = [0, 0]\n    for x, y in XY:\n        if y > 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif y == 0 and x > 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # y\n    # plus, minus\n    tmp = [0, 0]\n    for x, y in XY:\n        if y < 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif y == 0 and x > 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # y\n    # minus, plus\n    tmp = [0, 0]\n    for x, y in XY:\n        if y > 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif y == 0 and x < 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    # y\n    # minus, minus\n    tmp = [0, 0]\n    for x, y in XY:\n        if y < 0:\n            tmp[0] += x\n            tmp[1] += y\n        elif y == 0 and x < 0:\n            tmp[0] += x\n            tmp[1] += y\n\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\n\n    for i, (x, y) in enumerate(XY):\n        if x == 0:\n            katamuki = 0\n            katamuki2 = float(\"inf\")\n        else:\n            katamuki = y / x\n            if y == 0:\n                katamuki2 = float(\"inf\")\n            else:\n                katamuki2 = -(x / y)\n        plus = [0, 0]\n        minus = [0, 0]\n        plus2 = [0, 0]\n        minus2 = [0, 0]\n        for j, (xx, yy) in enumerate(XY):\n            if i == j:\n                continue\n            if yy > katamuki * xx:\n                plus[0] += xx\n                plus[1] += yy\n            else:\n                minus[0] += xx\n                minus[1] += yy\n\n            if katamuki2 == float(\"inf\"):\n                if xx > 0:\n                    plus2[0] += xx\n                    plus2[1] += yy\n                else:\n                    minus2[0] += xx\n                    minus2[1] += yy\n            else:\n                if yy > katamuki2 * xx:\n                    plus2[0] += xx\n                    plus2[1] += yy\n                else:\n                    minus2[0] += xx\n                    minus2[1] += yy\n\n        ans = max(ans, math.sqrt(plus[0] ** 2 + plus[1] ** 2))\n        ans = max(ans, math.sqrt(minus[0] ** 2 + minus[1] ** 2))\n        ans = max(ans, math.sqrt(plus2[0] ** 2 + plus2[1] ** 2))\n        ans = max(ans, math.sqrt(minus2[0] ** 2 + minus2[1] ** 2))\n        ans = max(ans, math.sqrt((plus[0] + x) ** 2 + (plus[1] + y) ** 2))\n        ans = max(ans, math.sqrt((minus[0] + x) ** 2 + (minus[1] + y) ** 2))\n        ans = max(ans, math.sqrt((plus2[0] + x) ** 2 + (plus2[1] + y) ** 2))\n        ans = max(ans, math.sqrt((minus2[0] + x) ** 2 + (minus2[1] + y) ** 2))\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import atan2, pi\n\nn = int(input())\ne = []\n\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    r = atan2(y, x)\n    if r < 0:\n        r += pi * 2\n    e.append([r, x, y])\n\ne.sort()\n\nans = 0\nfor i in range(n):\n    e.append([e[i][0] + pi * 2, e[i][1], e[i][2]])\n    ans = max(ans, (e[i][1] ** 2 + e[i][2] ** 2) ** 0.5)\n\nif n == 1:\n    print(ans)\n    return\n\nfor L in range(n):\n    x = e[L][1]\n    y = e[L][2]\n    for R in range(L+1, L+n):\n        x += e[R][1]\n        y += e[R][2]\n        ans = max(ans, (x ** 2 + y ** 2) ** 0.5)\n\nprint(ans)\n", "import sys\nfrom itertools import accumulate, combinations\nfrom math import atan2\nread = sys.stdin.read\n\nN, *xy = map(int, read().split())\nxy = sorted(zip(*[iter(xy)] * 2), key=lambda x: atan2(x[1], x[0]))\nxy = [(0, 0)] + xy\n\nxy *= 2\nxy = list(zip(*map(list, map(accumulate, zip(*xy)))))\nanswer = 0\n\nfor n in range(N + 1):\n    for i, j in combinations(range(n, n + N + 1), 2):\n        x1, y1 = xy[i]\n        x2, y2 = xy[j]\n        candidate = (x1 - x2) ** 2 + (y1 - y2) ** 2\n        if candidate > answer:\n            answer = candidate\n\nprint(answer ** 0.5)", "from math import atan2, pi, sqrt\nfrom operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\np = []\nxa = ya = 0\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    angle = atan2(y, x)\n    p.append((x, y, angle))\n    p.append((x, y, angle + 2 * pi))\n    xa += x\n    ya += y\n\np.sort(key=itemgetter(2))\n\nr = 0\nans = 0\nxs = ys = 0\nfor l in range(n):\n    while p[r][2] < p[l][2] + pi:\n        xs += p[r][0]\n        ys += p[r][1]\n        r += 1\n\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\n\n    xs -= p[l][0]\n    ys -= p[l][1]\n\nprint(ans)\n", "# \u8907\u7d20\u6570\u7248\n\n# \u51f8\u5305 Monotone Chain O(nlogn)\n# \u53c2\u8003: https://matsu7874.hatenablog.com/entry/2018/12/17/025713\ndef get_convex_hull(points):\n    def det(p, q):\n        return (p.conjugate()*q).imag\n    points.sort(key=lambda x: (x.real, x.imag))\n    ch = []\n    for p in points:\n        while len(ch) > 1:\n            v_cur = ch[-1]-ch[-2]\n            v_new = p-ch[-2]\n            if det(v_cur, v_new) > 0:\n                break\n            ch.pop()\n        ch.append(p)\n    t = len(ch)\n    for p in points[-2::-1]:\n        while len(ch) > t:\n            v_cur = ch[-1]-ch[-2]\n            v_new = p-ch[-2]\n            if det(v_cur, v_new) > 0:\n                break\n            ch.pop()\n        ch.append(p)\n    return ch[:-1]\n\n\nN = int(input())\nXY = [complex(*list(map(int, input().split()))) for _ in range(N)]\nps = [complex(0, 0)]\nfor p in XY:\n    ps_new = ps[:]\n    for p_ in ps:\n        ps_new.append(p+p_)\n    ps = get_convex_hull(ps_new)\nans = 0\nfor p in ps:\n    ans = max(ans, abs(p))\nprint(ans)\n", "def f_f():\n    import numpy as np\n\n    n = int(input())\n    x, y = np.array([input().split() for _ in range(n)], dtype=\"int64\").T\n\n    a = np.arctan2(x, y)\n    i = a.argsort()\n    x, y, a = x[i], y[i], a[i]\n\n    x, y = np.concatenate([x, x]), np.concatenate([y, y])\n    a = np.concatenate([a, a+2*np.pi])\n\n    xcs, ycs = x.cumsum(), y.cumsum()\n    items = np.arange(1, n+1)[None,:]\n    l = np.arange(n)[:,None]\n\n    dx = xcs[l+items-1]-xcs[l]+x[l]\n    dy = ycs[l+items-1]-ycs[l]+y[l]\n\n    print(((dx*dx+dy*dy).max()**0.5))\n\ndef __starting_point():\n    f_f()\n\n__starting_point()", "def solve():\n    from math import atan2, degrees, hypot\n    n = int(input())\n    txy = []\n    sx, sy = 0, 0\n    for i in range(n):\n        a, b = list(map(int, input().split()))\n        theta_0 = degrees(atan2(b, a))\n        sx += a\n        sy += b\n        txy.append((theta_0, a, b))\n    txy.sort()\n    ans = hypot(sx, sy)\n    for i in range(n):\n        for j in range(i + 1, n):\n            tx, ty = 0, 0\n            for k in range(i, j):\n                theta, x, y = txy[k]\n                tx += x\n                ty += y\n                ans = max(ans, hypot(tx, ty))\n                ans = max(ans, hypot(sx - tx, sy - ty))\n    print(ans)\n\nsolve()\n", "import numpy as np\nN = int(input())\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\nth = np.arctan2(XY[:,1],XY[:,0])\nXY = XY[th.argsort()]\nans = 0\nn = np.linalg.norm\nSxy = np.vstack((np.zeros(2),np.cumsum(XY,axis=0)))\nfor i in range(N):\n    for j in range(i+1,i+N+1):\n        r = n(Sxy[min(j,N)]-Sxy[i] + Sxy[max(0,j-N)])\n        ans = max(ans,r)\nprint(ans)", "from math import hypot, atan2\n\nN = int(input())\nengines = [tuple(map(int, input().split())) for _ in range(N)]\n\nengines.sort(key=lambda z: atan2(z[1], z[0]))\n\nans = 0\nfor L in range(N):\n    for R in range(N):\n        if L <= R:\n            x, y = list(map(sum, list(zip(*engines[L:R+1]))))\n        else:\n            x, y = list(map(sum, list(zip(*(engines[:R+1]+engines[L:])))))\n        dist = hypot(x, y)\n        ans = max(ans, dist)\n\nprint(ans)\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom math import atan2, degrees, hypot\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nEPS = 10 ** -9\n\nN = INT()\n\ndegs = []\nXY = []\nfor i in range(N):\n    x, y = MAP()\n    XY.append((x, y))\n    deg = degrees(atan2(y, x))\n    if deg < 0:\n        # \u8ca0\u306e\u6570\u306a\u3089\u6642\u8a08\u56de\u308a\u5074\u306b\u3042\u308b\u306e\u3067\u9006\u5411\u304d\u306b\u3059\u308b\n        deg += 360\n    degs.append((deg, i))\n# \u89d2\u5ea6\u3067\u30bd\u30fc\u30c8\ndegs.sort()\n# 2\u5468\u76ee\u3092\u3064\u3051\u308b\ndegs += [(deg+360, i) for deg, i in degs]\n\nans = 0\nfor i in range(N):\n    deg, idx = degs[i]\n    xsm, ysm = XY[idx]\n    ans = max(ans, hypot(xsm, ysm))\n    j = i + 1\n    # \u59cb\u70b9\u304b\u3089180\u5ea6\u672a\u6e80\u306e\u65b9\u5411\u306b\u5411\u304b\u3046\u3082\u306e\u3092\u5168\u3066\u8ffd\u52a0\u3057\u306a\u304c\u3089\u6700\u5927\u3092\u53d6\u308b\n    while degs[j][0] < deg+180:\n        _, idx = degs[j]\n        x, y = XY[idx]\n        xsm += x\n        ysm += y\n        ans = max(ans, hypot(xsm, ysm))\n        j += 1\nprint(ans)\n", "import itertools\nN = int(input())\nXY = [[int(_) for _ in input().split()] for _ in range(N)]\nxy1 = []\nxy2 = []\nxy3 = []\nxy4 = []\nfor x, y in XY:\n    if x >= 0:\n        if y >= 0:\n            xy1 += [[x, y]]\n        else:\n            xy4 += [[x, y]]\n    else:\n        if y >= 0:\n            xy2 += [[x, y]]\n        else:\n            xy3 += [[x, y]]\nxy1.sort(key=lambda xy: float('inf') if xy[0] == 0 else xy[1] / xy[0])\nxy2.sort(key=lambda xy: xy[1] / xy[0])\nxy3.sort(key=lambda xy: xy[1] / xy[0])\nxy4.sort(key=lambda xy: -float('inf') if xy[0] == 0 else xy[1] / xy[0])\nXY = xy1 + xy2 + xy3 + xy4\nN = len(XY)\nXY *= 2\nacc = list(\n    itertools.accumulate(XY, func=lambda a, b: [a[0] + b[0], a[1] + b[1]]))\nans = 0\nfor i in range(N):\n    for j in range(i + 1, i + N + 1):\n        x = acc[j][0] - acc[i][0]\n        y = acc[j][1] - acc[i][1]\n        ans = max(ans, x**2 + y**2)\nprint((ans**0.5))\n", "import cmath\nimport math\n\nN = int(input())\npc = []\nfor i in range(N):\n  x, y = map(int, input().split())\n  c = x + y*1j\n  p = cmath.phase(c)\n  pc.append([p, c])\npc = sorted(pc, key=lambda x: x[0])\n\nps = [pc[i][0] for i in range(N)]\ncs = [pc[i][1] for i in range(N)]\n\ndef L(i, j, N):\n  if i<j:\n    return list(range(i, j))\n  else:\n    return list(range(0, j)) + list(range(i+1, N))\n\ns = 0\nm = 0\n\nfor start in range(N):\n  for end in range(N):\n    s = 0\n    #print(start,end,N,L(start,end,N))\n    for k in L(start,end,N):\n      s += cs[k]\n    m = max(m, abs(s))\ns = 0\nfor k in range(N):\n  s += cs[k]\n  m = max(m, abs(s))\nprint(m)", "import math\nn=int(input())\nl=[list(map(int,input().split())) for i in range(n)]\nfor i in range(n):\n  x=math.degrees(math.atan2(l[i][1], l[i][0]))\n  l[i]=[x,l[i][0],l[i][1]]\nl.sort()\nL=l+l\nansL=[]\nfor i in range(n):\n  for j in range(i,n+i):\n    ctx=0;cty=0\n    for k in range(i,j+1):\n      ctx+=L[k][1]\n      cty+=L[k][2]\n    ansL.append((ctx**2+cty**2)**0.5)\nprint(max(ansL))", "import sys\nfrom heapq import heappop, heappush\nfrom operator import itemgetter\nfrom collections import deque, defaultdict, Counter\nfrom bisect import bisect_left, bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\nMOD = 10**9 + 7\nINF = float('inf')\n\nimport math\n\ndef sol():\n    N = int(input())\n    engine = [tuple(map(int, input().split())) for _ in range(N)]\n\n    ans = 0\n\n    for direct in range(0, 1000):\n        direct = 2 * math.pi / 999 * direct\n        u, v = math.cos(direct), math.sin(direct)\n\n        length = [0, 0]\n        for x, y in engine:\n            if u * x + v * y >= 0:\n                length[0] += x\n                length[1] += y\n\n        ans = max(ans, length[0]**2 + length[1]**2)\n\n    print(ans**0.5)\n\nsol()", "import numpy as np\nN = int(input())\nXY =  np.array([list(map(int,input().split())) for _ in [0]*N])\nth = np.arctan2(XY[:,1],XY[:,0])\nXY = XY[th.argsort()]\nans = 0\nfor i in range(N):\n    for j in range(i+1,i+N+1):\n        r = np.linalg.norm(XY[i:j].sum(axis=0)+XY[:max(0,j-N)].sum(axis=0))\n        ans = max(ans,r)\nprint(ans)", "import math\nN = int(input())\nn = 72\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    c = math.cos(theta)\n    s = math.sin(theta)\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * c + y[j] * s > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "import sys\nfrom operator import itemgetter\nimport math\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\n\n    ans = 0\n\n    for i, (x, y) in enumerate(XY):\n        if x == 0:\n            katamuki =  1 / (10 ** 7)\n            katamuki2 =  - 1 / (10 ** 7)\n        else:\n            katamuki = y / x + 1 / (10 ** 7)\n            katamuki2 = y / x - 1 / (10 ** 7)\n        plus = [0, 0]\n        minus = [0, 0]\n        plus2 = [0, 0]\n        minus2 = [0, 0]\n        for j, (xx, yy) in enumerate(XY):\n            if yy > katamuki * xx:\n                plus[0] += xx\n                plus[1] += yy\n            else:\n                minus[0] += xx\n                minus[1] += yy\n\n            if yy > katamuki2 * xx:\n                plus2[0] += xx\n                plus2[1] += yy\n            else:\n                minus2[0] += xx\n                minus2[1] += yy\n\n        ans = max(ans, math.sqrt(plus[0] ** 2 + plus[1] ** 2))\n        ans = max(ans, math.sqrt(minus[0] ** 2 + minus[1] ** 2))\n        ans = max(ans, math.sqrt(plus2[0] ** 2 + plus2[1] ** 2))\n        ans = max(ans, math.sqrt(minus2[0] ** 2 + minus2[1] ** 2))\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nfrom cmath import phase\nxy = sorted([list(map(int,input().split())) for i in range(n)],key=lambda x: phase(x[0]+x[1]*1j))\n#x+yi\u306eargument[-pi,pi]\u306e\u5c0f\u3055\u3044\u65b9\u304b\u3089\u9806\u306b\u4e26\u3079\u308b\nxy += xy\n#\u540c\u3058\u3082\u306e\u3092\u8907\u88fd\nans = 0\nfor l in range(n):\n    a = [0,0] # \u6700\u5f8c\u306b\u305f\u3069\u308a\u7740\u304f\u5ea7\u6a19\n    for r in range(l,min(2*n,l+n)):#l\u756a\u76ee\u542b\u3081l\u304b\u3089n\u500b\u306b\u3064\u3044\u3066\n        a[0] += xy[r][0]\n        a[1] += xy[r][1]\n        ans = max(ans,abs(a[0]+a[1]*1j))\nprint(ans) ", "import numpy as np\n\nn=int(input())\n\ndef div2(x,y):\n    if x>0:\n        return (1,y/x)\n    elif x<0:\n        return (-1,y/x)\n    else:\n        if y>0:\n            return (-1,-float(\"inf\"))\n        else:\n            return (1,-float(\"inf\"))\n    \n\nL=[list(map(int,input().split())) for i in range(n)]\n\nL.sort(key=lambda x:div2(x[0],x[1]))\n\nm=0\nfor i in range(n):\n    for j in range(i,n):\n        x0=y0=0\n        x1=y1=0\n        for k in range(n):\n            if i<=k<=j:\n                x0+=L[k][0]\n                y0+=L[k][1]\n            else:\n                x1+=L[k][0]\n                y1+=L[k][1]\n        m=max(m,x0**2+y0**2,x1**2+y1**2)\n\nprint('{:.12f}'.format(np.sqrt(m)))", "import sys\n\nimport math\nimport numpy as np\n\ndef main():\n    n = int(input())\n    vec = [tuple(map(int, input().split())) for i in range(n)]\n    vec.sort(key=lambda x: math.atan2(x[1], x[0]))\n\n    maxx = 0\n    for i in range(n):\n        for j in range(1, n+1):\n            now = [0, 0]\n            for k in range(j):\n                idx = (i + k) % n\n                now[0] += vec[idx][0]\n                now[1] += vec[idx][1]\n            maxx = max(maxx, now[0]*now[0] + now[1]*now[1])\n\n    print((math.sqrt(maxx)))\n    return 0\n\ndef __starting_point():\n    return(main())\n\n__starting_point()", "import math\nn = int(input())\nl = [list(map(int,input().split())) for i in range(n)]\nl.sort(key=lambda x: math.atan2(x[1],x[0]))\nl += l\nans = 0\nfor i in range(n):\n    x = y = 0\n    for j in range(n):\n        nx,ny = l[i+j]\n        x += nx\n        y += ny\n        ans = max(ans,(x**2+y**2)**0.5)\nprint(ans)", "import itertools\nfrom math import atan2, sqrt\n\nN = int(input())\nA = [t for _ in range(N) if (t := tuple(map(int, input().split()))) != (0, 0)]\n\nA.sort(key=lambda x: atan2(x[1], x[0]))\n\n# \u5411\u304d\u304c\u540c\u3058\u30a8\u30f3\u30b8\u30f3\u306f\uff11\u3064\u306b\u307e\u3068\u3081\u308b\nAx, Ay = [], []\nfor _, v in itertools.groupby(A, key=lambda x: atan2(x[1], x[0])):\n    sx, sy = 0, 0\n    for vx, vy in v:\n        sx += vx\n        sy += vy\n    Ax.append(sx)\n    Ay.append(sy)\n\nNu = len(Ax)\n\nAx = [0] + list(itertools.accumulate(Ax * 2))\nAy = [0] + list(itertools.accumulate(Ay * 2))\n\nans = 0\nfor i in range(Nu + 1):\n    for j in range(i + 1, min(i + Nu + 1, 2 * Nu + 1)):\n        ans = max(ans, (Ax[j] - Ax[i]) ** 2 + (Ay[j] - Ay[i]) ** 2)\n\nprint((sqrt(ans)))\n", "from math import atan2, pi, sqrt\nfrom operator import itemgetter\n# import sys\n# input = sys.stdin.readline\n\nn = int(input())\np = []\nxa = ya = 0\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    angle = atan2(y, x)\n    p.append((x, y, angle))\n    p.append((x, y, angle + 2 * pi))\n    xa += x\n    ya += y\n\np.sort(key=itemgetter(2))\n\nr = 0\nans = 0\nxs = ys = 0\nfor l in range(n):\n    while p[r][2] < p[l][2] + pi:\n        xs += p[r][0]\n        ys += p[r][1]\n        r += 1\n\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\n\n    xs -= p[l][0]\n    ys -= p[l][1]\n\nprint(ans)\n", "import numpy as np\nn = int(input())\nxy = np.array([list(map(int, input().split())) for _ in range(n)]).T\nans = 0\nL = np.angle(xy[0]+xy[1]*1j)\nA = sorted([[j, xy[0][i], xy[1][i]] for i, j in enumerate(L)])\nA = [i[1:] for i in A]\nA = np.array(A*2)\nfor i in range(n):\n  for j in range(i+1, i+n+1):\n    S = A[i:j]\n    t = S.sum(axis=0)\n    ans = max(ans, np.hypot(*t))\nprint(ans)", "# \u7121\u7406\u3084\u308a0.1\u5ea6\u305a\u3064\u884c\u5148\u3092\u56de\u3059\u3002\n\nimport math\nimport numpy as np\n\nn = int(input())\n\neng_list = []\n\nfor _ in range(n):\n    a = np.array(list(map(int, input().split())))\n    eng_list.append(a)\n\n# \u89d2\u5ea6\nangles = []\n\nfor i in range(n):\n    cos = (np.dot(eng_list[i], np.array([0, 1]))/(np.linalg.norm(eng_list[i])))\n    angle = math.degrees(math.acos(cos))\n    if eng_list[i][0] < 0:\n        angle = 360 - angle\n    angles.append(angle)\n\n\ndef hantei(a, b):\n    coss = np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b))\n    if coss > 1:\n        coss = 1.0\n    elif coss < -1:\n        coss = -1.0\n    angg = math.degrees(math.acos(coss))\n    if angg < 90.0001:\n        return True\n    else:\n        return False\n\n\ndef distance(a):\n    dis = np.linalg.norm(a)\n    return dis\n\npitch = 1 # \u89d2\u5ea6\ndist = []\n\nfor ikisaki in np.arange(0, 360, pitch):\n    dist_location = np.array([0, 0])\n    for j in eng_list:\n        i = np.array([math.cos(math.radians(ikisaki)), math.sin(math.radians(ikisaki))])\n        if hantei(i, j):\n            dist_location = dist_location + j\n    dist.append(distance(dist_location))\n\nprint((max(dist)))\n", "n = int(input())\npi = 3.141592653589793238462643383279\nxy = [list(map(int, input().split())) for _ in range(n)]\nimport math\n\natan = [math.atan2(x[0], x[1]) for x in xy]\nd = []\n\n\ndef hoge(a):\n    ret = 0\n    if a % (2*pi) < pi:\n        ret = (a % pi)\n    elif a % (2*pi)  > pi:\n        ret = (a % pi)-pi\n    else:\n        ret = (a)\n    #assert pi <= ret <= pi, 'range over'\n    return ret  # -pi <= a <= pi\n\n\ndef seikika(A):\n    ret = []\n    for a in A:\n        ret.append(hoge(a))\n    return ret\n\n\ngyoukaku = atan.copy()\ngyoukaku.extend(seikika([a + pi for a in atan]))\nM=60\nfor m in range(M):\n    gyoukaku.extend(seikika([a + pi*(2*pi/M*m) for a in atan]))\n\n\ndef dist(xy):\n    xx = sum([x[0] for x in xy])\n    yy = sum([y[1] for y in xy])\n    return (xx ** 2 + yy ** 2) ** 0.5\n\n\nfor g in gyoukaku:\n    anglist = seikika([hoge(a - g) for a in atan])\n    anglist = seikika(anglist)\n    finalxy = []\n    for i in range(n):\n        if -pi / 2 -0.000001 <= anglist[i] <= pi / 2+0.000001:\n            finalxy.append(xy[i])\n    d.append(dist(finalxy))\n\nprint((max(d)))\n", "import math\n\nn = int(input())\nXY = [list(map(int,input().split())) for i in range(n)]\n\nXY.sort(key=lambda x: math.atan2(x[1],x[0]))\nXY += XY\n\nans = 0\nfor i in range(n):\n    x = 0\n    y = 0\n    for j in range(n):\n        nx,ny = XY[i+j]\n        x += nx\n        y += ny\n        ans = max(ans,(x**2+y**2)**0.5)\nprint(ans)", "from itertools import combinations\nfrom cmath import phase\n\nN, *XY = map(int, open(0).read().split())\n\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\nXY += XY\n\n\nans = 0\nfor i, j in combinations(range(2 * N + 1), 2):\n    if j - i <= N:\n        ans = max(ans, abs(sum(XY[i:j])))\n\nprint(ans)", "import numpy as np\nN = int(input())\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\nth = np.arctan2(XY[:,1],XY[:,0])\nXY = XY[th.argsort()]\nans = 0\nn = np.linalg.norm\ns = np.sum\nfor i in range(N):\n    for j in range(i+1,i+N+1):\n        r = n(s(XY[i:j],axis=0)+s(XY[:max(0,j-N)],axis=0))\n        ans = max(ans,r)\nprint(ans)", "def f_engines():\n    import math\n    N = int(input())\n    # 2\u03c0\u3092\u307e\u305f\u3050\u3088\u3046\u306a\u30d9\u30af\u30c8\u30eb\u306e\u9078\u3073\u65b9\u3092\u697d\u306b\u3059\u308b\u305f\u3081\u3001\u8981\u7d20\u6570\u30922\u500d\n    Engines = sorted([[int(i) for i in input().split()] for j in range(N)],\n                     key=lambda x: math.atan2(x[1], x[0])) * 2\n\n    ans = 0\n    for head in range(N):\n        # \u4ed6\u306e\u4eba\u306e\u63d0\u51fa\u306b\u306f1\u91cd\u30eb\u30fc\u30d7\u306e\u3082\u306e\u3082\u3042\u308b\u304c\u3001\u305d\u308c\u3067\u3044\u3044\u7406\u5c48\u304c\u308f\u304b\u3089\u306a\u3044\n        for tail in range(head, head + N):\n            x, y = 0, 0\n            for i in range(head, tail + 1):\n                dx, dy = Engines[i]\n                x += dx\n                y += dy\n            ans = max(ans, x * x + y * y)\n    return math.sqrt(ans)\n\nprint(f_engines())", "import numpy as np\n\nn = int(input())\nx,y = np.array([list(map(int,input().split())) for _ in range(n)]).T\n\n# \u5185\u7a4d\u304c0\u4ee5\u4e0a\u304b\u3069\u3046\u304b\ndef isin90deg(v1, v2):\n    if np.dot(v1, v2) >= 0 : return 1\n    else: return 0\n\n# \u5185\u7a4d\u304c0\u304b\u3069\u3046\u304b\ndef is90deg(v1, v2):\n    if np.dot(v1, v2) == 0 : return 1\n    else: return 0\n\nans = []\nfor i in range(n):\n    # tangent-vector, normal-vector\n    tv, nv1 = np.array([x[i],y[i]]), np.array([y[i],-x[i]])\n    nv2 = - nv1\n    # tv\u304b\u3089\u6642\u8a08\u56de\u308a180\u5ea6\u30a8\u30ea\u30a2\u306b\u304a\u3051\u308b\u30d9\u30af\u30c8\u30eb\u548c\u3092\u8003\u3048\u308b\n    # \u305f\u3060\u3057\u3001tv\u306b\u5e73\u884c\u306a\u30d9\u30af\u30c8\u30eb\u7fa4\uff08posi/nega\uff09\u3060\u3051\u4f8b\u5916\u51e6\u7406\n    for nv in [nv1, nv2]:\n        sum,posi,nega = np.array([0,0]), np.array([0,0]), np.array([0,0])\n        for j in range(n):\n            v = np.array([x[j],y[j]])\n            if isin90deg(v,nv): sum += v\n            if is90deg(v,nv) and isin90deg(v,tv): posi += v\n            if is90deg(v,nv) and not isin90deg(v,tv): nega += v\n        # \u30e6\u30fc\u30af\u30ea\u30c3\u30c9\u8ddd\u96e2\n        ans.append(np.linalg.norm(sum, ord=2))\n        ans.append(np.linalg.norm(sum - posi, ord=2))\n        ans.append(np.linalg.norm(sum - nega, ord=2))\n\nprint((max(ans)))\n\n\n", "def solve():\n    from math import atan2, degrees, hypot\n    n = int(input())\n    txy = []\n    sx, sy = 0, 0\n    for i in range(n):\n        a, b = list(map(int, input().split()))\n        theta_0 = degrees(atan2(b, a))\n        sx += a\n        sy += b\n        txy.append([theta_0, a, b])\n    txy.sort()\n    ans = hypot(sx, sy)\n    for i in range(n):\n        for j in range(i + 1, n):\n            tx, ty = 0, 0\n            for k in range(i, j):\n                theta, x, y = txy[k]\n                tx += x\n                ty += y\n                ans = max(ans, hypot(tx, ty))\n                ans = max(ans, hypot(sx - tx, sy - ty))\n    print(ans)\n\nsolve()\n", "import math\nN = int(input())\nn = 1000\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    c = math.cos(theta)\n    s = math.sin(theta)\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * c + y[j] * s > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "import math\nN = int(input())\nX = []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    X.append((math.atan2(x, y), x, y))\n\nX = sorted(X) * 2\nm = 0\nfor i in range(N):\n    sx = sy = 0\n    for j in range(i, i + N):\n        sx += X[j][1]; sy += X[j][2]\n        d = sx ** 2 + sy ** 2\n        m = max(m, d)\n\nprint((m**0.5))\n", "import sys\ninput = sys.stdin.readline\nimport math\n# \u30ad\u30e5\u30fc(FIFO)\nfrom collections import deque\nfrom operator import itemgetter\n\n\nN = int(input())\nXY1 = []\nXY2 = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    theta = math.atan2(y, x)\n    if y == 0 and x < 0:\n        theta -= 2*math.pi\n    if theta < 0:\n        XY1.append((x, y, theta))\n    else:\n        XY2.append((x, y, theta))\n\nXY1.sort(key=itemgetter(2))\nXY2.sort(key=itemgetter(2))\n\nq1 = deque()\nq2 = deque()\nfor xy1 in XY1:\n    q1.append(xy1)\nfor xy2 in XY2:\n    q2.append(xy2)\n\nans = 0\nfor _ in range(N+4):\n    px, py = 0, 0\n    mx, my = 0, 0\n    for xy1 in q1:\n        px += xy1[0]\n        py += xy1[1]\n    for xy2 in q2:\n        mx += xy2[0]\n        my += xy2[1]\n    dp = math.sqrt(px**2+py**2)\n    if dp > ans:\n        ans = dp\n    dm = math.sqrt(mx**2+my**2)\n    if dm > ans:\n        ans = dm\n    \n    if len(q1) == 0:\n        xy2 = q2.popleft()\n        q1.append(xy2)\n    elif len(q2) == 0:\n        xy1 = q1.popleft()\n        q2.append(xy1)\n    else:\n        xy1 = q1[0]\n        xy2 = q2[0]\n        theta1 = xy1[2]\n        theta2 = xy2[2]\n        if theta1 + math.pi < theta2:\n            q1.popleft()\n            q2.append((xy1[0], xy1[1], theta1+2*math.pi))\n        else:\n            q2.popleft()\n            q1.append((xy2[0], xy2[1], theta2))\n\nprint(ans)", "import math\nn = int(input())\na = [list(map(int,input().split())) for _ in range(n)]\nans = 0\nfor x in range(-20,21):\n    for y in range(-20,21):\n        sx = 0\n        sy = 0\n        for v in a:\n            if v[0]*x+v[1]*y>0:\n                sx+=v[0]\n                sy+=v[1]\n        ans = max(ans,math.sqrt(sx*sx+sy*sy))\nprint(ans)", "from math import hypot\n\nN = int(input())\nengines = [tuple(map(int, input().split())) for _ in range(N)]\n\ndef dot(x1, y1, x2, y2):\n    return x1*x2 + y1*y2\ndef cross(x1, y1, x2, y2):\n    return x1*y2 - y1*x2\n\ndef getDistMax(xBase, yBase):\n    x1s, y1s, x2s, y2s = [], [], [], []\n    x, y = 0, 0\n    for dx, dy in engines:\n        d = dot(xBase, yBase, dx, dy)\n        if d > 0:\n            x, y = x+dx, y+dy\n        elif d == 0:\n            c = cross(xBase, yBase, dx, dy)\n            if c > 0:\n                x1s.append(dx)\n                y1s.append(dy)\n            else:\n                x2s.append(dx)\n                y2s.append(dy)\n    ans = max(hypot(x, y), hypot(x+sum(x1s), y+sum(y1s)), hypot(x+sum(x2s), y+sum(y2s)))\n    return ans\n\nans = 0\nfor x, y in engines:\n    ds = []\n    ds.append(getDistMax( x,  y))\n    ds.append(getDistMax(-y,  x))\n    ds.append(getDistMax(-x, -y))\n    ds.append(getDistMax( y, -x))\n    ans = max(ans, max(ds))\n\nprint(ans)\n", "from math import atan2\nn = int(input())\nl = [list(map(int, input().split())) for _ in range(n)]\nl.sort(key=lambda x: atan2(x[1], x[0]))\nans = 0\nfor lp in range(n):\n    for rg in range(n):\n        lf = lp\n        x, y = l[lf]\n        lf += 1\n        if lf == n:\n            lf = 0\n        while lf != rg:\n            x += l[lf][0]\n            y += l[lf][1]\n            lf += 1\n            if lf == n:\n                lf = 0\n        ans = max(ans, (x ** 2 + y ** 2) ** .5)\nprint(ans)\n", "import math\n\nN = int(input())\nV = []\nfor _ in range(N):\n    V.append([ int(n) for n in input().split() ])\n\nR2 = 0\nfor i in range(100):\n    theta = 2*math.pi * i / 100\n    a, b = math.cos(theta), math.sin(theta)\n    X, Y = 0, 0\n    for x, y in V:\n        if a*x+b*y > 0:\n            X += x\n            Y += y\n    r2 = X**2+Y**2\n    if r2 > R2:\n        R2 = r2\n\nprint(math.sqrt(R2))", "import numpy as np\n\nN = int(input())\nXY =  np.array([list(map(int,input().split())) for _ in [0]*N])\n\nans = 0\nfor m in range(100):\n    th = 2*np.pi*m/100\n    r = np.array([np.cos(th),np.sin(th)])\n    check = XY.dot(r)>=0\n    ans = max(ans,np.linalg.norm(np.sum(XY[check],axis=0)))\nprint(ans)\n", "import math\nN = int(input())\nn = 72\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    c = math.cos(theta)\n    s = math.sin(theta)\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * c + y[j] * s > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "import math\nimport os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = int(sys.stdin.readline())\nXY = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\n\ndef calc(bx, by):\n    base = math.atan2(bx, by)\n\n    d1 = []\n    d2 = []\n    for x, y in XY:\n        deg = (math.atan2(x, y) - base) % (math.pi * 2)\n        if deg < math.pi:\n            d1.append((x, y))\n        else:\n            d2.append((x, y))\n\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    for x, y in d1:\n        x1 += x\n        y1 += y\n    for x, y in d2:\n        x2 += x\n        y2 += y\n\n    return max(math.sqrt(x1 ** 2 + y1 ** 2), math.sqrt(x2 ** 2 + y2 ** 2))\n\n\nans = 0\nfor x, y in XY:\n    ans = max(ans, calc(x, y))\nprint(ans)\n", "import cmath\n\nN = int(input())\nXY = []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    XY.append(x + y * 1j)\n\nXY.sort(key=lambda x: cmath.phase(x))\n\nans = 0\nfor i in range(N):\n    for j in range(N):\n        if i <= j:\n            ans = max(ans, abs(sum(XY[i:j + 1])))\n        elif i > j:\n            ans = max(ans, abs(sum(XY[:j + 1] + XY[i:])))\n\nprint(ans)\n", "from math import sqrt\nn = int(input())\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        return\n    def __lt__(self, p2):\n        return self.quadrant() < p2.quadrant() or self.quadrant() == p2.quadrant() and self.x * p2.y - self.y * p2.x > 0\n    def __repr__(self):\n        return repr((self.x, self.y))\n    def __add__(self, p2):\n        return Point(self.x+p2.x, self.y+p2.y)\n    def __sub__(self, p2):\n        return Point(self.x-p2.x, self.y-p2.y)\n    def quadrant(self):\n        if self.x > 0 and self.y >= 0:\n            return 1\n        elif self.y > 0:\n            return 2\n        elif self.x < 0:\n            return 3\n        else:\n            return 4\n    def square(self):\n        return self.x ** 2 + self.y ** 2\n\nxy = [Point(xi, yi) for xi, yi in (list(map(int, input().split())) for _ in range(n)) if not xi == yi == 0]\n\n\ncur_point = sum((p for p in xy if p.y > 0 or p.y == 0 and p.x >= 0), Point(0, 0))\n\ninv = list(Point(-p.x, -p.y) for p in xy)\nxy.extend(inv)\nxy.sort()\n\nmx = cur_point.square()\nfor p in xy:\n    cur_point -= p\n    mx = max(mx, cur_point.square())\n\nprint((sqrt(mx)))\n", "from math import atan2, sqrt\n\ndef main():\n    n = int(input())\n    engines = [list(map(int, input().split())) for _ in range(n)]\n    for i in range(n):\n        rad = atan2(engines[i][1], engines[i][0])\n        engines[i].append(rad)\n    engines.sort(key=lambda x: x[2])\n    ans = 0\n    for k in range(1, n+1):\n        for i in range(n):\n            x_sum, y_sum = 0, 0\n            for j in range(i, i+k):\n                p = j%n\n                x_sum += engines[p][0]\n                y_sum += engines[p][1]\n            tmp = x_sum**2 + y_sum**2\n            if ans < tmp:\n                ans = tmp\n    print(sqrt(ans))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom itertools import accumulate, combinations\nfrom math import atan2\nread = sys.stdin.read\n\nN, *xy = map(int, read().split())\nxy = sorted(zip(*[iter(xy)] * 2), key=lambda x: atan2(x[1], x[0]))\nxy = [(0, 0)] + xy\n\nxy *= 2\nxy = list(zip(*map(list, map(accumulate, zip(*xy)))))\nanswer = 0\n\nfor i, j in combinations(range(2 * N + 2), 2):\n    if j - i <= N:\n        x1, y1 = xy[i]\n        x2, y2 = xy[j]\n        candidate = (x1 - x2) ** 2 + (y1 - y2) ** 2\n        if candidate > answer:\n            answer = candidate\n\nprint(answer ** 0.5)", "# Engines\nimport cmath\nimport math\nN = int(input())\nEngines = []\nans = 0\n\nsumx, sumy = 0, 0\nfor _ in range(N):\n    x, y = map(int, input().split())\n    z = complex(x, y)\n    arg_deg = cmath.phase(z)\n    sumx += x\n    sumy += y\n    Engines.append((arg_deg, x, y))\nans = max(ans, math.hypot(sumx, sumy))\nEngines.sort()\nfor i in range(N):\n    for j in range(i, N):\n        sub_x = 0\n        sub_y = 0\n        for k in range(i, j+1):\n            deg, dx, dy = Engines[k]\n            sub_x += dx\n            sub_y += dy\n        ans = max(ans, math.hypot(sub_x, sub_y))\n        ans = max(ans, math.hypot(sumx-sub_x, sumy-sub_y))\nprint(ans)", "import math\n\nn = int(input())\nP = []\n#very small \u3067WA\u306a\u306e\u3067\u3001r\u3067\u5272\u3063\u3066\u304b\u3051\u76f4\u3059\u306e\u3092\u3084\u3081\u3066\u307f\u308b\n#atan\u3092\u4f7f\u3063\u3066\u307f\u308b\n#0\u307e\u305f\u3044\u3060\u3068\u304d\u304c\u304a\u304b\u3057\u3044\u304b\nfor i in range(n):\n    x, y = list(map(int, input().split( )))\n    rad = math.atan2(x, y)\n    P.append([rad, x, y])\n\nP.sort()\nP = P + P \n\n\nx0 = 0\ny0 = 0\n\nmx = 0\n\nfor i in range(n):\n    vx = 0\n    vy = 0\n    for j in range(n):\n        vx += P[i+j][1]\n        vy += P[i+j][2]\n        v = vx**2 + vy**2\n        mx = max(v,mx)\nprint((math.sqrt(mx)))\n", "from math import atan2, pi, sqrt\nn = int(input())\np = []\nxa = ya = 0\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    angle = atan2(y, x)\n    p.append((x, y, angle))\n    p.append((x, y, angle + 2 * pi))\n    xa += x\n    ya += y\n\np.sort(key=lambda x: x[2])\n\nr = 0\nans = 0\nxs = ys = 0\nfor l in range(n):\n    while p[r][2] < p[l][2] + pi:\n        xs += p[r][0]\n        ys += p[r][1]\n        r += 1\n\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\n\n    xs -= p[l][0]\n    ys -= p[l][1]\n\nprint(ans)\n", "#\u89e3\u8aac\u89e3\u6cd5\nn = int(input())\nxp = []\nxm = []\nyp = []\nym = []\nfor _ in range(n):\n  x,y = map(int,input().split())\n  if x == 0:\n    if y == 0:\n      n -= 1\n    elif y > 0:\n      yp.append([0,x,y])\n    else:\n      ym.append([0,x,y])\n  elif x > 0:\n    xp.append([y/x,x,y])\n  else:\n    xm.append([y/x,x,y])\nxp.sort()\nxm.sort()\nxy = xp + yp + xm + ym\ncan = []\nfor i in range(-n,0):\n  for j in range(i+1,i+n+1):\n    X = 0\n    Y = 0\n    for k in range(i,j):\n      x,y = xy[k][1],xy[k][2]\n      X += x\n      Y += y\n    can.append(X**2+Y**2)\nif n == 0:\n  print(0)\nelse:\n  print(max(can)**.5)", "from math import atan2\nn=int(input())\nl=[list(map(int,input().split())) for i in range(n)]\nl.sort(key=lambda x:atan2(x[1],x[0]))\nans=0\nfor i in range(n):\n    x,y=0,0\n    for j in range(n):\n        x1,y1=l[(i+j)%n]\n        x+=x1\n        y+=y1\n        ans=max(x**2+y**2,ans)\nprint(ans**0.5)", "import sys\nfrom math import atan2, pi\n\nn = int(input())\nangles = []\nengines = []\npi2 = 2 * pi\nfor i, line in enumerate(sys.stdin):\n    x, y = list(map(int, line.split()))\n    angle = atan2(y, x)\n    angles.append((angle, i))  # -pi~pi\n    angles.append((angle + pi2, i))  # pi~3pi\n    engines.append(x + y * 1j)\nangles.sort()\n\nr = 0\ntmp = 0\ntotal = sum(engines)\nans = 0\nfor l in range(n):\n    angle, i = angles[l]\n    limit = angle + pi\n    while angles[r][0] < limit:\n        tmp += engines[angles[r][1]]\n        r += 1\n    ans = max(ans, abs(tmp), abs(total - tmp))\n    tmp -= engines[i]\nprint(ans)\n", "import math\n \nN = int(input())\nV = []\nfor _ in range(N):\n    V.append([ int(n) for n in input().split() ])\n \nR2 = 0\nfor i in range(100): \n    theta = 2 * math.pi * i / 100  \n    a, b = math.cos(theta), math.sin(theta)  ### a=cos\u03b8\u3001b=sin\u03b8\u3000\uff08\u03b8=2\u03c0*i/100\uff09 \n    X, Y = 0, 0\n    for x, y in V: ### xi \u3068 yi \u3092\u53d6\u308a\u51fa\u3059\n        if a*x+b*y > 0: ### \u6b63\u306e\u6570\u306a\u3089\u3070\n            X += x\n            Y += y\n    r2 = X**2+Y**2\n    if r2 > R2:\n        R2 = r2\n \nprint(math.sqrt(R2))", "import numpy as np\nN = int(input())\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\nth = np.arctan2(XY[:,1],XY[:,0])\nXY = XY[th.argsort()]\nans = 0\nn = np.linalg.norm\nSxy = np.vstack((np.zeros(2),np.cumsum(XY,axis=0)))\ni=0\nj=1\npr = 0\nwhile i<N:\n        r = n(Sxy[min(j,N)]-Sxy[i] + Sxy[max(0,j-N)])\n        if r>=pr and j<i+N+1 : j+=1\n        else:\n            i += 1\n            j = max(j-1,i+1)\n            r = 0\n        ans = max(ans,r)\n        pr = r\nprint(ans)", "from math import hypot,atan2\nN = int(input())\nXY = [tuple(map(int,input().split())) for i in range(N)]\nxy = sorted(XY, key=lambda x:atan2(x[1],x[0]))\nxy += xy\n\nans = 0\nfor i in range(N):\n    sx = sy = 0\n    for j in range(N):\n        x,y = xy[i+j]\n        sx += x\n        sy += y\n        d = hypot(sx,sy)\n        if d > ans:\n            ans = d\nprint(ans)", "#\u89e3\u8aac\u89e3\u6cd5\nn = int(input())\nxp = []\nxm = []\nyp = []\nym = []\nfor _ in range(n):\n  x,y = map(int,input().split())\n  if x == 0:\n    if y == 0:\n      n -= 1\n    elif y > 0:\n      yp.append([0,x,y])\n    else:\n      ym.append([0,x,y])\n  elif x > 0:\n    xp.append([y/x,x,y])\n  else:\n    xm.append([y/x,x,y])\nxp.sort()\nxm.sort()\nxy = xp + yp + xm + ym\ncan = []\nfor i in range(-n,0):\n  X = 0\n  Y = 0\n  for j in range(i+1,i+n+1):\n    x,y = xy[j][1],xy[j][2]\n    X += x\n    Y += y\n    can.append(X**2+Y**2)\nif n == 0:\n  print(0)\nelse:\n  print(max(can)**.5)", "import math\nN = int(input())\nn = 60\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    c = math.cos(theta)\n    s = math.sin(theta)\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * c + y[j] * s > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "import math\nN = int(input())\nX = []\nfor _ in range(N):\n    x, y = list(map(int, input().split()))\n    X.append((math.atan2(y, x), x, y))\n\nX = sorted(X) * 2\nma = 0\nfor i in range(N):\n    sx = sy = 0\n    for j in range(i, i + N):\n        sx += X[j][1]; sy += X[j][2]\n        d = sx ** 2 + sy ** 2\n        ma = max(ma, d)\n\nprint((ma**0.5))\n", "from math import*\ndef main():\n\n    n = int(input())\n    ab = [list(map(int, input().split())) for _ in [0]*n]\n    k = 10000\n    ans2 = 0\n    for i in range(k):\n        t = 2*i*pi/k\n        s = sin(t)\n        c = cos(t)\n        ans = [0, 0]\n        for a, b in ab:\n            if a*s+b*c >= 0:\n                ans[0] += a\n                ans[1] += b\n        ans2 = max(ans2, ans[0]**2+ans[1]**2)\n    print((ans2**0.5))\n\n\nmain()\n", "def solve():\n    from math import atan2, pi, hypot\n    n = int(input())\n    txy = []\n    sx, sy = 0, 0\n    for i in range(n):\n        a, b = list(map(int, input().split()))\n        theta_0 = atan2(b, a)\n        sx += a\n        sy += b\n        txy.append((theta_0, a, b))\n    txy.sort()\n    ans = hypot(sx, sy)\n    for i in range(n):\n        for j in range(i + 1, n):\n            tx, ty = 0, 0\n            for k in range(i, j):\n                theta, x, y = txy[k]\n                tx += x\n                ty += y\n                ans = max(ans, hypot(tx, ty))\n                ans = max(ans, hypot(sx - tx, sy - ty))\n    print(ans)\n\nsolve()\n", "import math\n\nn = int(input())\nxy = [list(map(int, input().split())) for i in range(n)]\nargs = sorted([(math.atan2(y,x),x,y) for x,y in xy])\nans = 0\nfor key,(sarg,sx,sy) in enumerate(args):\n  tmpx,tmpy = sx,sy\n  dist = tmpx**2 + tmpy**2\n  for arg,x,y in args[key+1:]:\n    tmpx += x\n    tmpy += y\n    tmp = tmpx**2 + tmpy**2\n    if tmp < dist:\n      break\n    else:\n      dist = tmp\n  for arg,x,y in args[:key]:\n    tmpx += x\n    tmpy += y\n    tmp = tmpx**2 + tmpy**2\n    if tmp < dist:\n      break\n    else:\n      dist = tmp\n  ans = max(ans,dist)\nprint(math.sqrt(ans))", "import numpy as np\nN = int(input())\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\nth = np.arctan2(XY[:,1],XY[:,0])\nXY = XY[th.argsort()]\nans = 0\nn = np.linalg.norm\nfor i in range(N):\n    for j in range(i+1,i+N+1):\n        r = n(XY[i:j].sum(axis=0)+XY[:max(0,j-N)].sum(axis=0))\n        ans = max(ans,r)\nprint(ans)", "import math\nN = int(input())\nX = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X.append((math.atan2(x, y), x, y))\n\nX = sorted(X) * 2\nma = 0\nfor i in range(N):\n    sx = sy = 0\n    for j in range(i, i + N):\n        sx += X[j][1]; sy += X[j][2]\n        d = sx ** 2 + sy ** 2\n        ma = max(ma, d)\n\nprint(ma**0.5)", "import math\nN = int(input())\nn = 100\n\nx = [None] * N\ny = [None] * N\nfor i in range(N):\n    x[i], y[i] = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    theta = (2 * math.pi / n) * i\n    c = math.cos(theta)\n    s = math.sin(theta)\n    tmp_x = 0\n    tmp_y = 0\n    for j in range(N):\n        if x[j] * c + y[j] * s > 0:\n            tmp_x += x[j]\n            tmp_y += y[j]\n    if tmp_x**2 + tmp_y**2 > ans**2:\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\n\nprint(ans)\n", "import math\nN = int(input())\nxy = []\nfor i in range(N):\n  x, y = map(int, input().split())\n  xy += [(x, y, math.atan2(y,x))]\nxy.sort(key=lambda val:val[2])\nx_accum = [0]\ny_accum = [0]\nfor i in range(N):\n  x_accum += [x_accum[-1] + xy[i][0]]\n  y_accum += [y_accum[-1] + xy[i][1]]\n  \nans = 0\nfor i in range(N+1):\n  for j in range(i,N+1):\n    ans = max(ans,  math.hypot(x_accum[j]-x_accum[i] ,y_accum[j]-y_accum[i]))\n    ans = max(ans,  math.hypot(x_accum[-1] -x_accum[j]+x_accum[i] ,y_accum[-1]-y_accum[j]+y_accum[i]))\nprint(ans)"]
["MOD = 10**9 + 7\n\nn, l, r = list(map(int, input().split()))\n\nlr_counts = [(r-l+1)//3]*3\nfor i in range(l + sum(lr_counts), r + 1):\n    lr_counts[i % 3] += 1\n\ncur_counts = [1, 0, 0]\nfor _ in range(n):\n    new_counts = [0, 0, 0]\n    for j in range(3):\n        for k in range(3):\n            new_counts[(j + k) % 3] += cur_counts[j] * lr_counts[k]\n\n    for j in range(3):\n        cur_counts[j] = new_counts[j] % MOD\n\n\nprint(cur_counts[0])\n\n\n", "import sys\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n\ndef main():\n    n,l,r = LI()\n    a = [1,0,0]\n    t = [0,0,0]\n    k = r // 3\n    t = [k] * 3\n    if r % 3 > 0:\n        t[1] += 1\n    if r % 3 > 1:\n        t[2] += 1\n    k = l // 3\n    t = [c - k for c in t]\n    if l % 3 == 0:\n        t[0] += 1\n    if l % 3 > 1:\n        t[1] -= 1\n\n    for _ in range(n):\n        u = [0] * 3\n        for i in range(3):\n            k = a[i]\n            for j in range(3):\n                u[(i+j)%3] += k * t[j] % mod\n        a = [c % mod for c in u]\n\n    return a[0]\n\n\n\nprint(main())\n\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, L, R = getIntList()\n#print(N)\n\nbase = 10 ** 9 + 7\n#  1 2 3 4 5\ng = R- L +1\nf = g//3\nzz = [f,f,f]\nfor i in range(g%3):\n    t = (i+L) %3\n    zz[t] +=1\n\ndp = zz.copy()\ndprint(dp)\nfor _ in range(1,N):\n    dp1 = [0,0,0]\n    for i in range(3):\n        for j in range(3):\n            dp1[(i+j)%3] += dp[i] * zz[j]\n    for i in range(3):\n        dp1[i]%= base\n    dp = dp1\n    dprint(dp)\nprint(dp[0])\n\n\n\n\n", "n,l,r=map(int,input().split())\ndp=[[0]*3 for _ in range(n+5)]\n\nmod = 10**9+7\nrcnt=[0]*3\n\nll,rr=l//3+1,r//3\nfor i in range(3):\n    rcnt[i]+=rr-ll\n\nif l%3==0:\n    rcnt[0]+=1\n    rcnt[1]+=1\n    rcnt[2]+=1\nelif l%3==1:\n    rcnt[1]+=1\n    rcnt[2]+=1\nelse:\n    rcnt[2]+=1\n\nif r%3==0:\n    rcnt[0]+=1\nelif r%3==1:\n    rcnt[0]+=1\n    rcnt[1]+=1\nelse:\n    rcnt[0]+=1\n    rcnt[1]+=1\n    rcnt[2]+=1\n\nfor i in range(3):\n    dp[1][i]=rcnt[i]%mod\n\nfor i in range(2,n+1):\n    x = [dp[i-1][0] * rcnt[0] % mod, dp[i-1][2] * rcnt[1] % mod, dp[i-1][1] * rcnt[2] % mod]\n    y = [dp[i-1][0] * rcnt[1] % mod, dp[i-1][1] * rcnt[0] % mod, dp[i-1][2] * rcnt[2] % mod]\n    z = [dp[i-1][0] * rcnt[2] % mod, dp[i-1][1] * rcnt[1] % mod, dp[i-1][2] * rcnt[0] % mod]\n    dp[i][0] = sum(x) % mod\n    dp[i][1] = sum(y) % mod\n    dp[i][2] = sum(z) % mod\n\nprint(dp[n][0])", "import copy\nimport itertools\nimport string\n\n###\n\ndef powmod(x, p, m):\n\tif p <= 0:\n\t\treturn 1\n\tif p <= 1:\n\t\treturn x%m\n\treturn powmod(x*x%m, p//2, m) * (x%m)**(p%2) % m\n\n###\n\ndef to_basex(num, x):\n\twhile num > 0:\n\t\tyield num % x\n\t\tnum //= x\n\ndef from_basex(it, x):\n\tret = 0\n\tp = 1\n\tfor d in it:\n\t\tret += d*p\n\t\tp *= x\n\treturn ret\n\n###\n\nM = 10**9+7\n\ndef core():\n\tn, l, r = (int(x) for x in input().split())\n\t# print(n, l, r)\n\t\n\tl0m3 = (l + 2)//3*3\n\tr0m3 = r//3*3\n\tc0m3 = (r0m3 - l0m3)//3 + 1\n\tc1m3 = c0m3-1 + (1 if l%3 == 1 else 0) + (1 if r%3 != 0 else 0)\n\tc2m3 = c0m3-1 + (1 if l%3 != 0 else 0) + (1 if r%3 == 2 else 0)\n\t\n\t# print(l0m3, r0m3, c0m3, c1m3, c2m3)\n\t\n\tdp = [[1], [0], [0]]\n\tfor i in range(n):\n\t\tdp[0].append((dp[0][i]*c0m3 + dp[1][i]*c2m3 + dp[2][i]*c1m3) % M)\n\t\tdp[1].append((dp[0][i]*c1m3 + dp[1][i]*c0m3 + dp[2][i]*c2m3) % M)\n\t\tdp[2].append((dp[0][i]*c2m3 + dp[1][i]*c1m3 + dp[2][i]*c0m3) % M)\n\t\t\n\t# print(dp[0])\n\t# print(dp[1])\n\t# print(dp[2])\n\t\n\tans = dp[0][-1]\n\tprint(ans)\n\n\ncore()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "n,l,r=list(map(int,input().split()))\nmodz=r//3 - (l-1)//3\nmodo=(r+2)//3 - (l+1)//3\nmodt=(r+1)//3 - l//3\nmod=1000000007\ndp=[None]*(n+1)\nfor i in range(n+1):\n    dp[i]=[0]*3\ndp[1][0]=modz\ndp[1][1]=modo\ndp[1][2]=modt\nfor i in range(2,n+1):\n        dp[i][0]=(dp[i-1][0]*modz + dp[i-1][1]*modt + dp[i-1][2]*modo)%mod\n        dp[i][1]=(dp[i-1][0]*modo + dp[i-1][1]*modz + dp[i-1][2]*modt)%mod\n        dp[i][2]=(dp[i-1][0]*modt + dp[i-1][1]*modo + dp[i-1][2]*modz)%mod\nprint(dp[n][0])\n#print(dp)\n#print(modz,modo,modt)\n", "from sys import stdin\nn,l,r=list(map(int,stdin.readline().strip().split()))\ndp=[[0 for i in range(3)]for j in range(n)]\nx=l//3\nif l%3!=0:\n    x+=1\ny=3*x\nz=0\n\nfor i in range(l,y+1):\n    z+=1\n    if i%3==0:\n        dp[0][0]+=1\n    if i%3==1:\n        dp[0][1]+=1\n    if i%3==2:\n        dp[0][2]+=1\nx=r//3\ny=3*x\n\nfor i in range(y+1,r+1):\n    z+=1\n    if i%3==0:\n        dp[0][0]+=1\n    if i%3==1:\n        dp[0][1]+=1\n    if i%3==2:\n        dp[0][2]+=1\nx=(r-l+1-z)//3\nmod=10**9+7\ndp[0][0]+=x\ndp[0][1]+=x\ndp[0][2]+=x\nfor i in range(1,n):\n    dp[i][0]=((dp[0][0]*dp[i-1][0])%mod+(dp[0][1]*dp[i-1][2])%mod+(dp[0][2]*dp[i-1][1])%mod)%mod\n    dp[i][1]=((dp[0][0]*dp[i-1][1])%mod+(dp[0][1]*dp[i-1][0])%mod+(dp[0][2]*dp[i-1][2])%mod)%mod\n    dp[i][2]=((dp[0][1]*dp[i-1][1])%mod+(dp[0][0]*dp[i-1][2])%mod+(dp[0][2]*dp[i-1][0])%mod)%mod\nprint(dp[-1][0])\n    \n    \n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/20 20:36\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Ayoub and Lost Array.py\n\n\ndef main():\n    n, l, r = list(map(int, input().split()))\n    m = 10 ** 9 + 7\n\n    sub = r - l + 1\n    num = [sub // 3] * 3\n    if sub % 3 == 1:\n        num[l % 3] += 1\n    elif sub % 3 == 2:\n        num[l % 3] += 1\n        num[(l + 1) % 3] += 1\n\n    dp = [1, 0, 0]\n    for _ in range(n):\n        temp = [0] * 3\n        temp[0] = dp[0] * num[0] + dp[1] * num[2] + dp[2] * num[1]\n        temp[1] = dp[0] * num[1] + dp[1] * num[0] + dp[2] * num[2]\n        temp[2] = dp[0] * num[2] + dp[1] * num[1] + dp[2] * num[0]\n        for i in range(3):\n            dp[i] = temp[i] % m\n\n    print(dp[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin, stdout\nprime = 10**9 + 7\n\ndef unitMatrix(size):\n    out = [[0]*size for i in range(size)]\n    for i in range(size):\n        out[i][i] = 1\n    return out\n\ndef matrixMult(pre, post):\n    rows = len(pre)\n    mid = len(post)\n    columns = len(post[0])\n    out = [[0]*columns for i in range(rows)]\n    for i in range(rows):\n        for j in range(columns):\n            for k in range(mid):\n                out[i][j] += pre[i][k]*post[k][j]\n                out[i][j] = out[i][j]%prime\n    return out\n\ndef matrixExp(base, power):\n    if power == 0:\n        return unitMatrix(len(base))\n    else:\n        if power%2 == 0:\n            half = matrixExp(base, power/2)\n            return matrixMult(half, half)\n        else:\n            half = matrixExp(base, (power-1)/2)\n            return matrixMult(matrixMult(half, half), base)\n\ndef main():\n    n, l, r = [int(i) for i in stdin.readline().split()]\n\n    vals = [[1], [0], [0]]\n    mods = [(r-l+1)//3 ,(r-l+1)//3 ,(r-l+1)//3]\n    remainder = (r-l+1)%3\n    if remainder >= 1:\n        mods[l%3] += 1\n    if remainder == 2:\n        mods[(l+1)%3] += 1\n        \n    transforms = [[mods[0], mods[2], mods[1]], [mods[1], mods[0], mods[2]], [mods[2], mods[1], mods[0]]]\n    power = matrixExp(transforms, n)\n    out = matrixMult(power, vals)\n    print(out[0][0])\n\nmain()\n", "#! usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\nMOD = 10 ** 9 + 7\nMAX_N = 2 * 10 ** 5 + 5\ndp = [[0] * 3 for i in range(MAX_N)]\n\n\ndef main():\n    n, l, r = list(map(int, input().split()))\n    k0 = r // 3 - (l-1) // 3\n    k1 = (r//3+(r % 3 >= 1)) - ((l-1)//3+((l-1) % 3 >= 1))\n    k2 = (r//3+(r % 3 >= 2)) - ((l-1)//3+((l-1) % 3 >= 2))\n\n    dp[0][0], dp[0][1], dp[0][2] = k0, k1, k2\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] * k0 + dp[i-1][1] * k2 + dp[i-1][2] * k1\n        dp[i][1] = dp[i-1][0] * k1 + dp[i-1][1] * k0 + dp[i-1][2] * k2\n        dp[i][2] = dp[i-1][0] * k2 + dp[i-1][1] * k1 + dp[i-1][2] * k0\n        for j in range(3):\n            dp[i][j] %= MOD\n\n    print(dp[n-1][0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, l, r = list(map(int, input().split()))\n\nmod = 10**9 + 7\ndp = [[0 for j in range(3)] for _ in range(n+10)]\n\ndp[0][0] = 1\n\nm0 = r // 3\nm1 = r // 3\nm2 = r // 3\n\nif r % 3 == 1:\n    m1 += 1\nelif r % 3 == 2:\n    m1 += 1\n    m2 += 1\n\nl -= 1\nm0 -= l // 3\nm1 -= l // 3\nm2 -= l // 3\n\nif l % 3 == 1:\n    m1 -= 1\nelif l % 3 == 2:\n    m1 -= 1\n    m2 -= 1\n\nfor i in range(n):\n    dp[i+1][0] += dp[i][0] * m0\n    dp[i+1][1] += dp[i][0] * m1\n    dp[i+1][2] += dp[i][0] * m2\n\n    dp[i + 1][1] += dp[i][1] * m0\n    dp[i + 1][2] += dp[i][1] * m1\n    dp[i + 1][0] += dp[i][1] * m2\n\n    dp[i + 1][2] += dp[i][2] * m0\n    dp[i + 1][0] += dp[i][2] * m1\n    dp[i + 1][1] += dp[i][2] * m2\n\n    dp[i+1][0] %= mod\n    dp[i + 1][1] %= mod\n    dp[i + 1][2] %= mod\n\nprint(dp[n][0])\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[22]:\n\n\nstuff=list(map(int, input().rstrip().split()))\n\n\n# In[23]:\n\n\nn=stuff[0]\nl=stuff[1]\nr=stuff[2]\n\nmod=10**9+7\n\n\n# In[24]:\n\n\n\nzeromods=r//3-(l-1)//3\n\nonemods=(r-1)//3-(l-2)//3\n\ntwomods=(r-2)//3-(l-3)//3\n\n\n# In[25]:\n\n\ncombos=[[0,0,0] for i in range(n)]\n\n\n# In[26]:\n\n\ncombos[0]=[zeromods,onemods,twomods]\n\n\n# In[28]:\n\n\nfor i in range(1,n):\n    combos[i][0]=(combos[i-1][0]*zeromods+combos[i-1][1]*twomods+combos[i-1][2]*onemods)%mod \n    \n    \n    combos[i][1]=(combos[i-1][0]*onemods+combos[i-1][1]*zeromods+combos[i-1][2]*twomods)%mod\n    \n    \n    combos[i][2]=(combos[i-1][0]*twomods+combos[i-1][1]*onemods+combos[i-1][2]*zeromods)%mod \n    \n    \n    \nprint(combos[-1][0])    \n\n\n# In[29]:\n\n\ncombos\n\n\n# In[ ]:\n\n\n\n\n", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**5) \n \ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nn,l,r = li()\nMOD = 10**9+7\n\nst = l%3\nlg = (r-l+1)//3\nmods = [lg]*3\nfor i in range((r-l+1)-3*lg):\n    mods[st] += 1\n    st += 1\n    st %= 3\n    \ndp = [[0]*3 for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    dp[i+1][0] = dp[i][0]*mods[0]%MOD + dp[i][1]*mods[2]%MOD + dp[i][2]*mods[1]%MOD\n    dp[i+1][1] = dp[i][0]*mods[1]%MOD + dp[i][1]*mods[0]%MOD + dp[i][2]*mods[2]%MOD\n    dp[i+1][2] = dp[i][0]*mods[2]%MOD + dp[i][1]*mods[1]%MOD + dp[i][2]*mods[0]%MOD\n\n    dp[i+1][0] %= MOD\n    dp[i+1][1] %= MOD\n    dp[i+1][2] %= MOD\n    \nprint(dp[-1][0])", "n, r, l=(int(i) for i in input().split())\nr0=r\nif r0%3==1: r0+=2\nelif r0%3==2: r0+=1\nl0=l\nif l0%3==1: l0-=1\nelif l0%3==2: l0-=2\nd0=(l0-r0)//3+1\nd1=d0-1\nd2=d0-1\nif r0-r==2:\n    d1+=1\n    d2+=1\nelif r0-r==1:\n    d2+=1\nif l-l0==2:\n    d1+=1\n    d2+=1\nelif l-l0==1:\n    d1+=1\nd0=[d0]\nd1=[d1]\nd2=[d2]\n#print(d0[0], d1[0], d2[0])\nfor i in range(1, n):\n    d0.append((d0[i-1]*d0[0]+d1[i-1]*d2[0]+d2[i-1]*d1[0])%1000000007)\n    d1.append((d0[i-1]*d1[0]+d1[i-1]*d0[0]+d2[i-1]*d2[0])%1000000007)\n    d2.append((d0[i-1]*d2[0]+d1[i-1]*d1[0]+d2[i-1]*d0[0])%1000000007)\nprint(d0[n-1])\n", "n, l, r = list(map(int, input().split()))\nMOD = 10**9+7\nl -= 1\nlrem = [0, 0, 0]\nrrem = [0, 0, 0]\nrem = [0, 0, 0]\nif l%3 == 0:\n    lrem[0] = l//3\n    lrem[1] = l//3\n    lrem[2] = l//3\nelif l%3 == 1:\n    lrem[0] = l//3\n    lrem[1] = l//3 + 1\n    lrem[2] = l//3\nelse: \n    lrem[0] = l//3\n    lrem[1] = l//3 + 1\n    lrem[2] = l//3 + 1\nif r%3 == 0:\n    rrem[0] = r//3\n    rrem[1] = r//3\n    rrem[2] = r//3\nelif r%3 == 1:\n    rrem[0] = r//3\n    rrem[1] = r//3 + 1\n    rrem[2] = r//3\nelse:\n    rrem[0] = r//3\n    rrem[1] = r//3 + 1\n    rrem[2] = r//3 + 1\n    \nrem[0] = rrem[0]-lrem[0]\nrem[1] = rrem[1]-lrem[1]\nrem[2] = rrem[2]-lrem[2]\n\ndp = [[0 for i in range(n)] for i in range(3)]\ndp[0][0] = rem[0]\ndp[1][0] = rem[1]\ndp[2][0] = rem[2]\n\nfor i in range(1, n):\n    dp[0][i] = (dp[0][i-1]*rem[0] + dp[1][i-1]*rem[2] + dp[2][i-1]*rem[1])%MOD\n    dp[1][i] = (dp[1][i-1]*rem[0] + dp[2][i-1]*rem[2] + dp[0][i-1]*rem[1])%MOD\n    dp[2][i] = (dp[2][i-1]*rem[0] + dp[1][i-1]*rem[1] + dp[0][i-1]*rem[2])%MOD\nprint(dp[0][n-1])\n", "n, l, r = [int(i) for i in input().split()]\n\n#dp = [[0 for i in range(3)] for j in range(3)]\n\nnumber_of_zeros = 0\nnumber_of_ones = 0\nnumber_of_twos = 0\n\nif l%3 == 0:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\nelif l%3 == 1:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3\n    if r%3 == 2:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3 + 1\n        number_of_twos = (r-l+1)//3 + 1\nelif l%3 == 2:\n    if r%3 == 0:\n        number_of_zeros = (r-l+1)//3 + 1\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\n    if r%3 == 1:\n        number_of_zeros = (r-l+1)//3\n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3\n    elif r%3 == 2:\n        number_of_zeros = (r-l+1)//3 \n        number_of_ones = (r-l+1)//3\n        number_of_twos = (r-l+1)//3 + 1\n\ndp = [[-1 for i in range(3)] for j in range(n+1)]\n\nMOD = 10**9 + 7\ndp[1][0] = number_of_zeros%MOD\ndp[1][1] = number_of_ones%MOD\ndp[1][2] = number_of_twos%MOD\n\nfor i in range(2,n+1):\n    dp[i][0] = (((dp[i-1][0]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_ones%MOD))%MOD)%MOD\n    dp[i][1] = (((dp[i-1][0]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_zeros%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_twos%MOD))%MOD)%MOD\n    dp[i][2] = (((dp[i-1][0]%MOD)*(number_of_twos%MOD))%MOD + ((dp[i-1][1]%MOD)*(number_of_ones%MOD))%MOD + ((dp[i-1][2]%MOD)*(number_of_zeros)%MOD)%MOD)%MOD\n\nif dp[n][0]!=-1:\n    print(dp[n][0]%MOD)\nelse:\n    print(0)\n", "n, l, r = [int(v) for v in input().split()]\n\nm = r - l\nr = (\n    m // 3 + 1,\n    (m - 1) // 3 + 1,\n    (m - 2) // 3 + 1,\n)\n\nrem = l % 3\nif rem == 0:\n    r0, r1, r2 = r\nelif rem == 1:\n    r1, r2, r0 = r\nelse:\n    r2, r0, r1 = r\n\nw0, w1, w2 = r0, r1, r2\nmod = 1000000007\n\nfor _ in range(1, n):\n    w0, w1, w2 = (\n        (w0 * r0 + w1 * r2 + w2 * r1) % mod,\n        (w0 * r1 + w1 * r0 + w2 * r2) % mod,\n        (w0 * r2 + w1 * r1 + w2 * r0) % mod,\n    )\n\nprint(w0)\n", "mod = 1000000007\n\ndp = [[0]*3 for i in range(200005)]\n\nn, l, r = map(int, input().split())\nl3, r3 = l%3, r%3\nk = r-l+1\n\nif l3 == r3:\t\n    zero = k  // 3\n    one = k  // 3\n    two = k  // 3;\n    if ( l3 == 0 ):\n        zero+=1\n    elif ( l3 == 1 ):\n        one+=1\n    else:\n        two+=1\n\nelif ( l3 == 0 and r3 == 1 ):\n    zero, one, two = k  // 3 + 1,k  // 3 + 1,k  // 3\nelif ( l3 == 1 and r3 == 2 ):\n    zero, one, two = k  // 3, k  // 3 + 1, k  // 3 + 1\nelif ( l3 == 2 and r3 == 0 ):\n    zero,one,two = k  // 3 + 1, k  // 3, k  // 3 + 1\nelse:\n    zero,one,two = k  // 3, k  // 3, k  // 3;\n\n\ndp[1][0], dp[1][1], dp[1][2] = zero, one, two\n#print(zero, one, two)\n\nfor i in range(2, n+1):\n    dp[i][0], dp[i][1], dp[i][2] =(\n        (dp[i-1][0]*zero + dp[i-1][1]*two + dp[i-1][2]*one)%mod,\n        (dp[i-1][0]*one + dp[i-1][1]*zero + dp[i-1][2]*two)%mod,\n        (dp[i-1][0]*two + dp[i-1][1]*one + dp[i-1][2]*zero)%mod\n    )\n\nprint(dp[n][0])", "n, l, r = map(int, input().split())\nost0 = r // 3 - (l - 1) // 3\nost1 = ost0\nif l % 3 == 0:\n    ost2 = ost0 - 1\nif l % 3 == 1:\n    ost2 = ost0\nif l % 3 == 2:\n    ost2 = ost0\nif r % 3 == 2:\n    ost2 += 1\nif l % 3 == 0:\n    ost1 = ost2\nif l % 3 == 1:\n    ost1 = ost2\nif l % 3 == 2:\n    ost1 = ost2 - 1\nif r % 3 == 1:\n    ost1 += 1\ndp = []\nfor i in range(n):\n    dp.append([0, 0, 0])\ndp[0][0], dp[0][1], dp[0][2] = ost0, ost1, ost2\nmmm = [ost0, ost1, ost2]\n#dp[ost][n] = dp[0][n - 1] * mmm[ost] + dp[1][n - 1] * mmm[(ost - 1) % 3] + dp[2][n - 1] * mmm[(ost - 2) % 3]\nfor i in range(1, n):\n    for j in range(3):\n        dp[i][j] = (dp[i - 1][0] * mmm[j] + dp[i - 1][1] * mmm[(j - 1) % 3] + dp[i - 1][2] * mmm[(j - 2) % 3]) % (10 ** 9 + 7)\nprint(dp[-1][0] % (10 ** 9 + 7))", "import math\n\ndef main():\n    n, l, r = (int(a) for a in input().split())\n    mod = 10**9 + 7\n    nums = [(math.floor(r/3) - math.ceil(l/3) + 1) % mod,\n            (math.floor((r-1)/3) - math.ceil((l-1)/3) + 1) % mod,\n            (math.floor((r-2)/3) - math.ceil((l-2)/3) + 1) % mod]\n    rem = nums[:]\n    for i in range(n-1):\n        newRem = []\n        # Remainder is 0\n        # 0 + 0 / 1 + 2 / 2 + 1\n        newRem.append(\n            ((nums[0] * rem[0]) % mod +\n             (nums[1] * rem[2]) % mod +\n             (nums[2] * rem[1]) % mod) % mod\n        )\n        # Remainder is 1\n        # 0 + 1 / 1 + 0 / 2 + 2\n        newRem.append(\n            ((nums[0] * rem[1]) % mod +\n             (nums[1] * rem[0]) % mod +\n             (nums[2] * rem[2]) % mod) % mod\n        )\n        # Remainder is 2\n        # 0 + 2 / 1 + 1 / 2 + 0\n        newRem.append(\n            ((nums[0] * rem[2]) % mod +\n             (nums[1] * rem[1]) % mod +\n             (nums[2] * rem[0]) % mod) % mod\n        )\n        rem = newRem[:]\n    print(rem[0])\n\nmain()\n    \n", "m = 10**9+7\n\nn, l, r = (int(x) for x in input().split())\n\nt = r-l+1\ntm = None\nif (r+1)%3==l%3:\n\ttm = (t//3,)*3\nelif ((r+1)%3 - l%3)%3==1:\n\ta=[0,0,0]\n\ta[l%3] = 1\n\ttm = ( t//3+a[0], t//3+a[1], t//3+a[2] )\nelse:\n\ta=[0,0,0]\n\ta[l%3] = 1\n\ta[r%3] = 1\n\ttm = ( t//3+a[0], t//3+a[1], t//3+a[2] )\n\n#assert t == tm1+tm2+tm3\n#print(tm)\n\nans0 = ans1 = ans2 = 0 #for n = 0\nans0, ans1, ans2 = tm #for n = 1\nans0o, ans1o, ans2o = tm\nfor i in range(n-1):\n\tans0n = (ans0o*ans0+ans2o*ans1+ans1o*ans2)%m\n\tans1n = (ans0o*ans1+ans1o*ans0+ans2o*ans2)%m\n\tans2n = (ans0o*ans2+ans1o*ans1+ans2o*ans0)%m \n\tans0o, ans1o, ans2o = ans0n, ans1n, ans2n\n\t#print(ans0o, ans1o, ans2o )\n#ans3 = t**n\n\nprint(ans0o%m)", "n, l, r = list(map(int, input().split()))\nc0 = (r//3*3-l//3*3)//3+1\nc1 = (r//3*3-l//3*3)//3\nc2 = (r//3*3-l//3*3)//3\nif(l%3==1):\n    c0-=1\nelif(l%3==2):\n    c0-=1\n    c1-=1\nif(r%3==1):\n    c1+=1\nelif(r%3==2):\n    c2+=1\n    c1+=1\ncnt0 = [c0]\ncnt1 = [c1]\ncnt2 = [c2]\nfor i in range(n):\n    cnt0.append((cnt0[i]*c0+cnt1[i]*c2+cnt2[i]*c1)%1000000007)\n    cnt1.append((cnt0[i]*c1+cnt1[i]*c0+cnt2[i]*c2)%1000000007)\n    cnt2.append((cnt0[i]*c2+cnt1[i]*c1+cnt2[i]*c0)%1000000007)\nprint(cnt0[-2]%1000000007)\n", "MOD = (10**9) + 7\n\nn,l,r = list(map(int, input().split()))\n\n\ndef find_ks(l, r):\n    num_elems = (r-l+1)\n    num_trips = int(num_elems / 3)\n    k = [num_trips] * 3\n\n    start_idx = l % 3\n    count = num_elems % 3\n\n    for i in range(count):\n        k[(start_idx + i)%3] += 1\n\n    return k\n\nk = find_ks(l, r)\nf = [[0 for _ in range(3)] for _ in range(n)]\n\n\nfor mod in range(3):\n    f[0][mod] = k[mod]\n\n# print(k)\nfor idx in range(1, n, 1):\n    # print(idx)\n    for mod in range(3):\n        f[idx][mod] += ( f[idx-1][mod] * k[0] ) % MOD\n        f[idx][mod] = f[idx][mod] % MOD\n\n        f[idx][mod] += ( f[idx-1][(mod - 1) % 3] * k[1] ) % MOD\n        f[idx][mod] = f[idx][mod] % MOD\n\n        f[idx][mod] += ( f[idx-1][(mod - 2) % 3] * k[2] ) % MOD\n        f[idx][mod] = f[idx][mod] % MOD\n\n# print(f)\n\nprint(f[n-1][0] % MOD)", "from math import ceil\nmod = 10 ** 9 + 7\n\ndef f(l, r, x):\n\treturn ceil((r - x) / 3) - ceil((l - 1 - x) / 3)\n\nn, l, r =map(int, input().split())\nm1 = f(l, r, 0)\nm2 = f(l, r, 1)\nm0 = f(l, r ,2)\ndp0 = [1 for i in range(n+1)]\ndp1 = [0 for i in range(n+1)]\ndp2 = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n\tdp0[i] = (dp0[i-1] * m0 + dp1[i-1] * m2 + dp2[i-1] * m1)%mod\n\tdp1[i] = (dp1[i-1] * m0 + dp2[i-1] * m2 + dp0[i-1] * m1)%mod\n\tdp2[i] = (dp2[i-1] * m0 + dp0[i-1] * m2 + dp1[i-1] * m1)%mod\nprint(dp0[n])"]
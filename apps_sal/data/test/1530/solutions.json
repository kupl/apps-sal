["class RedBlackNode(object):\n\n    def __init__(self, key):\n        self._key = key\n        self._red = False\n        self._left = None\n        self._right = None\n        self._p = None\n\n\nclass RedBlackTree(object):\n\n    def __init__(self):\n        self._nil = RedBlackNode(None)\n        self._root = self._nil\n\n    def insert_key(self, key):\n        y = self.search(key, True)\n        z = RedBlackNode(key)\n        z._p = y\n        if y == self._nil:\n            self._root = z\n        elif z._key < y._key:\n            y._left = z\n        else:\n            y._right = z\n        z._left = self._nil\n        z._right = self._nil\n        z._red = True\n        self._insert_fixup(z)\n\n    def _insert_fixup(self, z):\n        while z._p._red:\n            if z._p == z._p._p._left:\n                y = z._p._p._right\n                if y._red:\n                    z._p._red = False\n                    y._red = False\n                    z._p._p._red = True\n                    z = z._p._p\n                else:\n                    if z == z._p._right:\n                        z = z._p\n                        self._left_rotate(z)\n                    z._p._red = False\n                    z._p._p._red = True\n                    self._right_rotate(z._p._p)\n            else:\n                y = z._p._p._left\n                if y._red:\n                    z._p._red = False\n                    y._red = False\n                    z._p._p._red = True\n                    z = z._p._p\n                else:\n                    if z == z._p._left:\n                        z = z._p\n                        self._right_rotate(z)\n                    z._p._red = False\n                    z._p._p._red = True\n                    self._left_rotate(z._p._p)\n        self._root._red = False\n\n    def _left_rotate(self, x):\n        y = x._right\n        x._right = y._left\n        if y._left != self._nil:\n            y._left._p = x\n        y._p = x._p\n        if x._p == self._nil:\n            self._root = y\n        elif x == x._p._left:\n            x._p._left = y\n        else:\n            x._p._right = y\n        y._left = x\n        x._p = y\n\n    def _right_rotate(self, y):\n        x = y._left\n        y._left = x._right\n        if x._right != self._nil:\n            x._right._p = y\n        x._p = y._p\n        if y._p == self._nil:\n            self._root = x\n        elif y == y._p._right:\n            y._p._right = x\n        else:\n            y._p._left = x\n        x._right = y\n        y._p = x\n\n    def search(self, key, s):\n        x = self._root\n        g = self._nil\n        while x != self._nil:\n            g = x\n            if key < x._key:\n                x = x._left\n            else:\n                x = x._right\n        return(g)\n    def search2(self, key):\n        a = None\n        b = None\n        x = self._root\n        while x != self._nil and key != x._key:\n            if key < x._key:\n                a = x\n                x = x._left\n            else:\n                b = x\n                x = x._right\n        if key == x._key:\n            return(None)\n        else:\n            return((a,b))\n\n\nn = int(input())\ns = [int(i) for i in input().split()]\nt = RedBlackTree()\nt.insert_key([s[0],0,0])\n    \ne = []\nfor i in s[1:]:\n    o,u = t.search2([i,0,0])\n    if u == None:\n        e.append(o._key[0])\n        if o._key[0] > i:\n            o._key[1] = 1\n        else:\n            o._key[2] = 1\n    elif o == None:\n        e.append(u._key[0])\n        if u._key[0] > i:\n            u._key[1] = 1\n        else:\n            u._key[2] = 1\n    else:\n        if o._key[0] > i and u._key[0] > i:\n            if o._key[1] == 0:\n                o._key[1] = 1\n                e.append(o._key[0])\n            else:\n                u._key[1] = 1\n                e.append(u._key[0])\n            \n        elif o._key[0] < i and u._key[0] > i:\n            if o._key[2] == 0:\n                o._key[2] = 1\n                e.append(o._key[0])\n            else:\n                u._key[1] = 1\n                e.append(u._key[0])\n        elif o._key[0] > i and u._key[0] < i:\n            if o._key[1] == 0:\n                o._key[1] = 1\n                e.append(o._key[0])\n            else:\n                u._key[2] = 1\n                e.append(u._key[0])\n        elif o._key[0] < i and u._key[0] < i:\n            if o._key[2] == 0:\n                o._key[2] = 1\n                e.append(o._key[0])\n            else:\n                u._key[2] = 1\n                e.append(u._key[0])\n    t.insert_key([i,0,0])\nprint(*e)\n    \n\n", "from bisect import *\nn=int(input())\nd,a=[(0,0)],[0]*n\nfor i,x in enumerate(map(int,input().split())):\n    no=bisect(d,(x,0))-1\n    l,y=d[no]\n    a[i]=str(y)\n    d[no:no+1]=[(l,x),(x,x)]\nprint(' '.join(a[1:]))", "from bisect import bisect\n\nn = int(input())\narray = [int(x) for x in input().split()]\n\ntree = []\nans = [''] * n\nfor i in range(n):\n  item = array[i]\n  index = bisect(tree, (item, i))\n  if i != 0:\n    if index == 0:\n      ans[i] = str(tree[0][0])\n    elif index == i:\n      ans[i] = str(tree[i - 1][0])\n    else:\n      ans[i] = str(tree[index - 1][0] if tree[index - 1][1] > tree[index][1] else tree[index][0])\n  tree[index:index] = [(item, i)]\nprint(' '.join(ans[1:]))        ", "class RedBlackTree():\n    _nil = (None, False, None, None, None)\n\n    def __init__(self):\n        self._root = RedBlackTree._nil\n\n    def insert_key(self, key):\n        y = self.search(key, True)\n        z = [key, False, None, None, y]\n        if y is RedBlackTree._nil:\n            self._root = z\n        else:\n            y[2 if z[0] < y[0] else 3] = z\n        z[2] = z[3] = RedBlackTree._nil\n        z[1] = True\n        self._insert_fixup(z)\n\n    def _insert_fixup(self, z):\n        while z[4][1]:\n            if z[4] == z[4][4][2]:\n                y = z[4][4][3]\n                if y[1]:\n                    z[4][1] = y[1] = False\n                    z[4][4][1] = True\n                    z = z[4][4]\n                else:\n                    if z == z[4][3]:\n                        z = z[4]\n                        self._left_rotate(z)\n                    z[4][1] = False\n                    z[4][4][1] = True\n                    self._right_rotate(z[4][4])\n            else:\n                y = z[4][4][2]\n                if y[1]:\n                    z[4][1] = y[1] = False\n                    z[4][4][1] = True\n                    z = z[4][4]\n                else:\n                    if z == z[4][2]:\n                        z = z[4]\n                        self._right_rotate(z)\n                    z[4][1] = False\n                    z[4][4][1] = True\n                    self._left_rotate(z[4][4])\n        self._root[1] = False\n\n    def _left_rotate(self, x):\n        y = x[3]\n        x[3] = y[2]\n        if y[2] is not RedBlackTree._nil:\n            y[2][4] = x\n        y[4] = x[4]\n        if x[4] is RedBlackTree._nil:\n            self._root = y\n        else:\n            x[4][3 - (x == x[4][2])] = y\n        y[2] = x\n        x[4] = y\n\n    def _right_rotate(self, y):\n        x = y[2]\n        y[2] = x[3]\n        if x[3] is not RedBlackTree._nil:\n            x[3][4] = y\n        x[4] = y[4]\n        if y[4] is RedBlackTree._nil:\n            self._root = x\n        else:\n            y[4][2 + (y == y[4][3])] = x\n        x[3] = y\n        y[4] = x\n\n    def search(self, key, s):\n        x, g = self._root, RedBlackTree._nil\n        while x is not RedBlackTree._nil:\n            g, x = x, x[2 if key < x[0] else 3]\n        return g\n\n    def search2(self, key):\n        a = b = None\n        x = self._root\n        while x is not RedBlackTree._nil and key != x[0]:\n            if key < x[0]:\n                a, x = x, x[2]\n            else:\n                b, x = x, x[3]\n        if key != x[0]:\n            return a, b\n\n\ndef main():\n    input()\n    a, *aa = list(map(int, input().split()))\n    t = RedBlackTree()\n    t.insert_key([a, 0, 0])\n    e = []\n    for a in aa:\n        o, u = t.search2([a, 0, 0])\n        if u is None:\n            e.append(o[0][0])\n            o[0][2 - (o[0][0] > a)] = 1\n        elif o is None:\n            e.append(u[0][0])\n            u[0][2 - (u[0][0] > a)] = 1\n        else:\n            if o[0][0] > a < u[0][0]:\n                if o[0][1] == 0:\n                    o[0][1] = 1\n                    e.append(o[0][0])\n                else:\n                    u[0][1] = 1\n                    e.append(u[0][0])\n            elif o[0][0] < a < u[0][0]:\n                if o[0][2]:\n                    u[0][1] = 1\n                    e.append(u[0][0])\n                else:\n                    o[0][2] = 1\n                    e.append(o[0][0])\n            elif o[0][0] > a > u[0][0]:\n                if o[0][1]:\n                    u[0][2] = 1\n                    e.append(u[0][0])\n                else:\n                    o[0][1] = 1\n                    e.append(o[0][0])\n            elif o[0][0] < a > u[0][0]:\n                if o[0][2]:\n                    u[0][2] = 1\n                    e.append(u[0][0])\n                else:\n                    o[0][2] = 1\n                    e.append(o[0][0])\n        t.insert_key([a, 0, 0])\n    print(*e)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect\n\nn = int(input())\narray = [int(x) for x in input().split()]\n\ntree = []\nans = [''] * n\nfor i in range(n):\n  item = array[i]\n  index = bisect(tree, (item, i))\n  if i != 0:\n    if index == 0:\n      ans[i] = str(tree[0][0])\n    elif index == i:\n      ans[i] = str(tree[i - 1][0])\n    else:\n      ans[i] = str(tree[index - 1][0] if tree[index - 1][1] > tree[index][1] else tree[index][0])\n  tree[index:index] = [(item, i)]\nprint(' '.join(ans[1:]))", "__author__ = \"House\"\n\nimport bisect\n\ndef __starting_point():\n    n = int(input())\n    s = [int(i) for i in input().split()]\n    f = [[s[0], 0]]\n    outp = list()\n    for i in range(1, n):\n        now = [s[i], i]\n        idx = bisect.bisect_left(f, now)\n        ans = 0\n        if idx == 0:\n            ans = f[0][0]\n        elif idx == i:\n            ans = f[idx - 1][0]\n        else:\n            if f[idx][1] < f[idx - 1][1]:\n                ans = f[idx - 1][0]\n            else:\n                ans = f[idx][0]\n        f[idx:idx] = [now]\n        outp.append(str(ans))\n    print(\" \".join(outp))\n\n__starting_point()", "from bisect import bisect\nn=int(input())\nelements=list(map(int, input().split()))\ntree=[]\nans=['']*n\nfor i,x in enumerate(elements):\n    index = bisect(tree, (x,i))\n    if i!= 0:\n        if index==0:\n            ans[i]=str(tree[0][0])\n        elif index==i:\n            ans[i]=str(tree[i-1][0])\n        else:\n            if tree[index-1][1] < tree[index][1]:\n                ans[i]=str(tree[index][0])\n            else:\n                ans[i]=str(tree[index-1][0])\n    tree[index:index] = [(x, i)]\nprint(' '.join(ans[1:]))", "# pylint: disable=redefined-builtin, ungrouped-imports\n\nfrom bisect import bisect_left, bisect_right, insort\nfrom collections import Sequence, MutableSequence\nfrom functools import wraps\nfrom itertools import chain, repeat, starmap\nfrom math import log as log_e\nimport operator as op\nfrom operator import iadd, add\nfrom functools import reduce\nfrom _dummy_thread import get_ident\n\ndef recursive_repr(func):\n    repr_running = set()\n    @wraps(func)\n    def wrapper(self):\n        \"Return ellipsis on recursive re-entry to function.\"\n        key = id(self), get_ident()\n        if key in repr_running:\n            return '...'\n        repr_running.add(key)\n        try:\n            return func(self)\n        finally:\n            repr_running.discard(key)\n    return wrapper\nclass SortedList(MutableSequence):\n    def __init__(self, iterable=None, load=1000):\n        self._len = 0\n        self._lists = []\n        self._maxes = []\n        self._index = []\n        self._load = load\n        self._twice = load * 2\n        self._half = load >> 1\n        self._offset = 0\n        if iterable is not None:\n            self._update(iterable)\n    def __new__(cls, iterable=None, key=None, load=1000):\n        if key is None:\n            return object.__new__(cls)\n        else:\n            if cls is SortedList:\n                return SortedListWithKey(iterable=iterable, key=key, load=load)\n            else:\n                raise TypeError('inherit SortedListWithKey for key argument')\n    def clear(self):\n        self._len = 0\n        del self._lists[:]\n        del self._maxes[:]\n        del self._index[:]\n    _clear = clear\n    def add(self, val):\n        _lists = self._lists\n        _maxes = self._maxes\n        if _maxes:\n            pos = bisect_right(_maxes, val)\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(val)\n                _maxes[pos] = val\n            else:\n                insort(_lists[pos], val)\n            self._expand(pos)\n        else:\n            _lists.append([val])\n            _maxes.append(val)\n        self._len += 1\n    def _expand(self, pos):\n        _lists = self._lists\n        _index = self._index\n        if len(_lists[pos]) > self._twice:\n            _maxes = self._maxes\n            _load = self._load\n            _lists_pos = _lists[pos]\n            half = _lists_pos[_load:]\n            del _lists_pos[_load:]\n            _maxes[pos] = _lists_pos[-1]\n            _lists.insert(pos + 1, half)\n            _maxes.insert(pos + 1, half[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n    def update(self, iterable):\n        _lists = self._lists\n        _maxes = self._maxes\n        values = sorted(iterable)\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort()\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _maxes.extend(sublist[-1] for sublist in _lists)\n        self._len = len(values)\n        del self._index[:]\n    _update = update\n    def __contains__(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return False\n        pos = bisect_left(_maxes, val)\n        if pos == len(_maxes):\n            return False\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], val)\n        return _lists[pos][idx] == val\n    def discard(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return\n        pos = bisect_left(_maxes, val)\n        if pos == len(_maxes):\n            return\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], val)\n        if _lists[pos][idx] == val:\n            self._delete(pos, idx)\n    def remove(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            raise ValueError('{0} not in list'.format(repr(val)))\n        pos = bisect_left(_maxes, val)\n        if pos == len(_maxes):\n            raise ValueError('{0} not in list'.format(repr(val)))\n        _lists = self._lists\n        idx = bisect_left(_lists[pos], val)\n        if _lists[pos][idx] == val:\n            self._delete(pos, idx)\n        else:\n            raise ValueError('{0} not in list'.format(repr(val)))\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _maxes = self._maxes\n        _index = self._index\n        _lists_pos = _lists[pos]\n        del _lists_pos[idx]\n        self._len -= 1\n        len_lists_pos = len(_lists_pos)\n        if len_lists_pos > self._half:\n            _maxes[pos] = _lists_pos[-1]\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_lists) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _lists[prev][-1]\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_lists_pos:\n            _maxes[pos] = _lists_pos[-1]\n        else:\n            del _lists[pos]\n            del _maxes[pos]\n            del _index[:]\n    def _loc(self, pos, idx):\n        if not pos:\n            return idx\n        _index = self._index\n        if not len(_index):\n            self._build_index()\n        total = 0\n        # Increment pos to point in the index to len(self._lists[pos]).\n        pos += self._offset\n        # Iterate until reaching the root of the index tree at pos = 0.\n        while pos:\n            # Right-child nodes are at odd indices. At such indices\n            # account the total below the left child node.\n            if not pos & 1:\n                total += _index[pos - 1]\n            # Advance pos to the parent node.\n            pos = (pos - 1) >> 1\n        return total + idx\n    def _pos(self, idx):\n        if idx < 0:\n            last_len = len(self._lists[-1])\n            if (-idx) <= last_len:\n                return len(self._lists) - 1, last_len + idx\n            idx += self._len\n            if idx < 0:\n                raise IndexError('list index out of range')\n        elif idx >= self._len:\n            raise IndexError('list index out of range')\n        if idx < len(self._lists[0]):\n            return 0, idx\n        _index = self._index\n        if not _index:\n            self._build_index()\n        pos = 0\n        child = 1\n        len_index = len(_index)\n        while child < len_index:\n            index_child = _index[child]\n            if idx < index_child:\n                pos = child\n            else:\n                idx -= index_child\n                pos = child + 1\n            child = (pos << 1) + 1\n        return (pos - self._offset, idx)\n    def _build_index(self):\n        row0 = list(map(len, self._lists))\n        if len(row0) == 1:\n            self._index[:] = row0\n            self._offset = 0\n            return\n        head = iter(row0)\n        tail = iter(head)\n        row1 = list(starmap(add, list(zip(head, tail))))\n        if len(row0) & 1:\n            row1.append(row0[-1])\n        if len(row1) == 1:\n            self._index[:] = row1 + row0\n            self._offset = 1\n            return\n        size = 2 ** (int(log_e(len(row1) - 1, 2)) + 1)\n        row1.extend(repeat(0, size - len(row1)))\n        tree = [row0, row1]\n        while len(tree[-1]) > 1:\n            head = iter(tree[-1])\n            tail = iter(head)\n            row = list(starmap(add, list(zip(head, tail))))\n            tree.append(row)\n        reduce(iadd, reversed(tree), self._index)\n        self._offset = size * 2 - 1\n    def __delitem__(self, idx):\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return self._clear()\n                elif self._len <= 8 * (stop - start):\n                    values = self._getitem(slice(None, start))\n                    if stop < self._len:\n                        values += self._getitem(slice(stop, None))\n                    self._clear()\n                    return self._update(values)\n            indices = list(range(start, stop, step))\n            # Delete items from greatest index to least so\n            # that the indices remain valid throughout iteration.\n            if step > 0:\n                indices = reversed(indices)\n            _pos, _delete = self._pos, self._delete\n            for index in indices:\n                pos, idx = _pos(index)\n                _delete(pos, idx)\n        else:\n            pos, idx = self._pos(idx)\n            self._delete(pos, idx)\n    _delitem = __delitem__\n    def __getitem__(self, idx):\n        _lists = self._lists\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(self._len)\n            if step == 1 and start < stop:\n                if start == 0 and stop == self._len:\n                    return reduce(iadd, self._lists, [])\n                start_pos, start_idx = self._pos(start)\n                if stop == self._len:\n                    stop_pos = len(_lists) - 1\n                    stop_idx = len(_lists[stop_pos])\n                else:\n                    stop_pos, stop_idx = self._pos(stop)\n                if start_pos == stop_pos:\n                    return _lists[start_pos][start_idx:stop_idx]\n                prefix = _lists[start_pos][start_idx:]\n                middle = _lists[(start_pos + 1):stop_pos]\n                result = reduce(iadd, middle, prefix)\n                result += _lists[stop_pos][:stop_idx]\n                return result\n            if step == -1 and start > stop:\n                result = self._getitem(slice(stop + 1, start + 1))\n                result.reverse()\n                return result\n            # Return a list because a negative step could\n            # reverse the order of the items and this could\n            # be the desired behavior.\n            indices = list(range(start, stop, step))\n            return list(self._getitem(index) for index in indices)\n        else:\n            if self._len:\n                if idx == 0:\n                    return _lists[0][0]\n                elif idx == -1:\n                    return _lists[-1][-1]\n            else:\n                raise IndexError('list index out of range')\n            if 0 <= idx < len(_lists[0]):\n                return _lists[0][idx]\n            len_last = len(_lists[-1])\n            if -len_last < idx < 0:\n                return _lists[-1][len_last + idx]\n            pos, idx = self._pos(idx)\n            return _lists[pos][idx]\n    _getitem = __getitem__\n    def _check_order(self, idx, val):\n        _len = self._len\n        _lists = self._lists\n        pos, loc = self._pos(idx)\n        if idx < 0:\n            idx += _len\n        # Check that the inserted value is not less than the\n        # previous value.\n        if idx > 0:\n            idx_prev = loc - 1\n            pos_prev = pos\n            if idx_prev < 0:\n                pos_prev -= 1\n                idx_prev = len(_lists[pos_prev]) - 1\n            if _lists[pos_prev][idx_prev] > val:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n                raise ValueError(msg)\n        # Check that the inserted value is not greater than\n        # the previous value.\n        if idx < (_len - 1):\n            idx_next = loc + 1\n            pos_next = pos\n            if idx_next == len(_lists[pos_next]):\n                pos_next += 1\n                idx_next = 0\n            if _lists[pos_next][idx_next] < val:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n                raise ValueError(msg)\n    def __setitem__(self, index, value):\n        _lists = self._lists\n        _maxes = self._maxes\n        _check_order = self._check_order\n        _pos = self._pos\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            indices = list(range(start, stop, step))\n            if step != 1:\n                if not hasattr(value, '__len__'):\n                    value = list(value)\n                indices = list(indices)\n                if len(value) != len(indices):\n                    raise ValueError(\n                        'attempt to assign sequence of size {0}'\n                        ' to extended slice of size {1}'\n                        .format(len(value), len(indices)))\n                # Keep a log of values that are set so that we can\n                # roll back changes if ordering is violated.\n                log = []\n                _append = log.append\n                for idx, val in zip(indices, value):\n                    pos, loc = _pos(idx)\n                    _append((idx, _lists[pos][loc], val))\n                    _lists[pos][loc] = val\n                    if len(_lists[pos]) == (loc + 1):\n                        _maxes[pos] = val\n                try:\n                    # Validate ordering of new values.\n                    for idx, oldval, newval in log:\n                        _check_order(idx, newval)\n                except ValueError:\n                    # Roll back changes from log.\n                    for idx, oldval, newval in log:\n                        pos, loc = _pos(idx)\n                        _lists[pos][loc] = oldval\n                        if len(_lists[pos]) == (loc + 1):\n                            _maxes[pos] = oldval\n                    raise\n            else:\n                if start == 0 and stop == self._len:\n                    self._clear()\n                    return self._update(value)\n                # Test ordering using indexing. If the given value\n                # isn't a Sequence, convert it to a tuple.\n                if not isinstance(value, Sequence):\n                    value = tuple(value) # pylint: disable=redefined-variable-type\n                # Check that the given values are ordered properly.\n                iterator = list(range(1, len(value)))\n                if not all(value[pos - 1] <= value[pos] for pos in iterator):\n                    raise ValueError('given sequence not in sort order')\n                # Check ordering in context of sorted list.\n                if not start or not len(value):\n                    # Nothing to check on the lhs.\n                    pass\n                else:\n                    if self._getitem(start - 1) > value[0]:\n                        msg = '{0} not in sort order at index {1}'.format(repr(value[0]), start)\n                        raise ValueError(msg)\n                if stop == len(self) or not len(value):\n                    # Nothing to check on the rhs.\n                    pass\n                else:\n                    # \"stop\" is exclusive so we don't need\n                    # to add one for the index.\n                    if self._getitem(stop) < value[-1]:\n                        msg = '{0} not in sort order at index {1}'.format(repr(value[-1]), stop)\n                        raise ValueError(msg)\n                # Delete the existing values.\n                self._delitem(index)\n                # Insert the new values.\n                _insert = self.insert\n                for idx, val in enumerate(value):\n                    _insert(start + idx, val)\n        else:\n            pos, loc = _pos(index)\n            _check_order(index, value)\n            _lists[pos][loc] = value\n            if len(_lists[pos]) == (loc + 1):\n                _maxes[pos] = value\n    def __iter__(self):\n        return chain.from_iterable(self._lists)\n    def __reversed__(self):\n        return chain.from_iterable(list(map(reversed, reversed(self._lists))))\n    def islice(self, start=None, stop=None, reverse=False):\n        _len = self._len\n        if not _len:\n            return iter(())\n        start, stop, _ = slice(start, stop).indices(self._len)\n        if start >= stop:\n            return iter(())\n        _pos = self._pos\n        min_pos, min_idx = _pos(start)\n        if stop == _len:\n            max_pos = len(self._lists) - 1\n            max_idx = len(self._lists[-1])\n        else:\n            max_pos, max_idx = _pos(stop)\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n    def _islice(self, min_pos, min_idx, max_pos, max_idx, reverse):\n        _lists = self._lists\n        if min_pos > max_pos:\n            return iter(())\n        elif min_pos == max_pos and not reverse:\n            return iter(_lists[min_pos][min_idx:max_idx])\n        elif min_pos == max_pos and reverse:\n            return reversed(_lists[min_pos][min_idx:max_idx])\n        elif min_pos + 1 == max_pos and not reverse:\n            return chain(_lists[min_pos][min_idx:], _lists[max_pos][:max_idx])\n        elif min_pos + 1 == max_pos and reverse:\n            return chain(\n                reversed(_lists[max_pos][:max_idx]),\n                reversed(_lists[min_pos][min_idx:]),\n            )\n        elif not reverse:\n            return chain(\n                _lists[min_pos][min_idx:],\n                chain.from_iterable(_lists[(min_pos + 1):max_pos]),\n                _lists[max_pos][:max_idx],\n            )\n        else:\n            temp = list(map(reversed, reversed(_lists[(min_pos + 1):max_pos])))\n            return chain(\n                reversed(_lists[max_pos][:max_idx]),\n                chain.from_iterable(temp),\n                reversed(_lists[min_pos][min_idx:]),\n            )\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        _maxes = self._maxes\n        if not _maxes:\n            return iter(())\n        _lists = self._lists\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n        if minimum is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, minimum)\n                if min_pos == len(_maxes):\n                    return iter(())\n                min_idx = bisect_left(_lists[min_pos], minimum)\n            else:\n                min_pos = bisect_right(_maxes, minimum)\n                if min_pos == len(_maxes):\n                    return iter(())\n                min_idx = bisect_right(_lists[min_pos], minimum)\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n        if maximum is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_lists[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, maximum)\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_right(_lists[max_pos], maximum)\n            else:\n                max_pos = bisect_left(_maxes, maximum)\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_lists[max_pos])\n                else:\n                    max_idx = bisect_left(_lists[max_pos], maximum)\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n    def __len__(self):\n        return self._len\n    def bisect_left(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        pos = bisect_left(_maxes, val)\n        if pos == len(_maxes):\n            return self._len\n        idx = bisect_left(self._lists[pos], val)\n        return self._loc(pos, idx)\n    def bisect_right(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        pos = bisect_right(_maxes, val)\n        if pos == len(_maxes):\n            return self._len\n        idx = bisect_right(self._lists[pos], val)\n        return self._loc(pos, idx)\n    bisect = bisect_right\n    _bisect_right = bisect_right\n    def count(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        pos_left = bisect_left(_maxes, val)\n        if pos_left == len(_maxes):\n            return 0\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], val)\n        pos_right = bisect_right(_maxes, val)\n        if pos_right == len(_maxes):\n            return self._len - self._loc(pos_left, idx_left)\n        idx_right = bisect_right(_lists[pos_right], val)\n        if pos_left == pos_right:\n            return idx_right - idx_left\n        right = self._loc(pos_right, idx_right)\n        left = self._loc(pos_left, idx_left)\n        return right - left\n    def copy(self):\n        return self.__class__(self, load=self._load)\n    __copy__ = copy\n    def append(self, val):\n        _lists = self._lists\n        _maxes = self._maxes\n        if not _maxes:\n            _maxes.append(val)\n            _lists.append([val])\n            self._len = 1\n            return\n        pos = len(_lists) - 1\n        if val < _lists[pos][-1]:\n            msg = '{0} not in sort order at index {1}'.format(repr(val), self._len)\n            raise ValueError(msg)\n        _maxes[pos] = val\n        _lists[pos].append(val)\n        self._len += 1\n        self._expand(pos)\n    def extend(self, values):\n        _lists = self._lists\n        _maxes = self._maxes\n        _load = self._load\n        if not isinstance(values, list):\n            values = list(values)\n        if any(values[pos - 1] > values[pos]\n               for pos in range(1, len(values))):\n            raise ValueError('given sequence not in sort order')\n        offset = 0\n        if _maxes:\n            if values[0] < _lists[-1][-1]:\n                msg = '{0} not in sort order at index {1}'.format(repr(values[0]), self._len)\n                raise ValueError(msg)\n            if len(_lists[-1]) < self._half:\n                _lists[-1].extend(values[:_load])\n                _maxes[-1] = _lists[-1][-1]\n                offset = _load\n        len_lists = len(_lists)\n        for idx in range(offset, len(values), _load):\n            _lists.append(values[idx:(idx + _load)])\n            _maxes.append(_lists[-1][-1])\n        _index = self._index\n        if len_lists == len(_lists):\n            len_index = len(_index)\n            if len_index > 0:\n                len_values = len(values)\n                child = len_index - 1\n                while child:\n                    _index[child] += len_values\n                    child = (child - 1) >> 1\n                _index[0] += len_values\n        else:\n            del _index[:]\n        self._len += len(values)\n    def insert(self, idx, val):\n        _len = self._len\n        _lists = self._lists\n        _maxes = self._maxes\n        if idx < 0:\n            idx += _len\n        if idx < 0:\n            idx = 0\n        if idx > _len:\n            idx = _len\n        if not _maxes:\n            # The idx must be zero by the inequalities above.\n            _maxes.append(val)\n            _lists.append([val])\n            self._len = 1\n            return\n        if not idx:\n            if val > _lists[0][0]:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), 0)\n                raise ValueError(msg)\n            else:\n                _lists[0].insert(0, val)\n                self._expand(0)\n                self._len += 1\n                return\n        if idx == _len:\n            pos = len(_lists) - 1\n            if _lists[pos][-1] > val:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), _len)\n                raise ValueError(msg)\n            else:\n                _lists[pos].append(val)\n                _maxes[pos] = _lists[pos][-1]\n                self._expand(pos)\n                self._len += 1\n                return\n        pos, idx = self._pos(idx)\n        idx_before = idx - 1\n        if idx_before < 0:\n            pos_before = pos - 1\n            idx_before = len(_lists[pos_before]) - 1\n        else:\n            pos_before = pos\n        before = _lists[pos_before][idx_before]\n        if before <= val <= _lists[pos][idx]:\n            _lists[pos].insert(idx, val)\n            self._expand(pos)\n            self._len += 1\n        else:\n            msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n            raise ValueError(msg)\n    def pop(self, idx=-1):\n        if not self._len:\n            raise IndexError('pop index out of range')\n        _lists = self._lists\n        if idx == 0:\n            val = _lists[0][0]\n            self._delete(0, 0)\n            return val\n        if idx == -1:\n            pos = len(_lists) - 1\n            loc = len(_lists[pos]) - 1\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n        if 0 <= idx < len(_lists[0]):\n            val = _lists[0][idx]\n            self._delete(0, idx)\n            return val\n        len_last = len(_lists[-1])\n        if -len_last < idx < 0:\n            pos = len(_lists) - 1\n            loc = len_last + idx\n            val = _lists[pos][loc]\n            self._delete(pos, loc)\n            return val\n        pos, idx = self._pos(idx)\n        val = _lists[pos][idx]\n        self._delete(pos, idx)\n        return val\n    def index(self, val, start=None, stop=None):\n        # pylint: disable=arguments-differ\n        _len = self._len\n        if not _len:\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n        if stop <= start:\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        _maxes = self._maxes\n        pos_left = bisect_left(_maxes, val)\n        if pos_left == len(_maxes):\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        _lists = self._lists\n        idx_left = bisect_left(_lists[pos_left], val)\n        if _lists[pos_left][idx_left] != val:\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        stop -= 1\n        left = self._loc(pos_left, idx_left)\n        if start <= left:\n            if left <= stop:\n                return left\n        else:\n            right = self._bisect_right(val) - 1\n            if start <= right:\n                return start\n        raise ValueError('{0} is not in list'.format(repr(val)))\n    def __add__(self, that):\n        values = reduce(iadd, self._lists, [])\n        values.extend(that)\n        return self.__class__(values, load=self._load)\n    def __iadd__(self, that):\n        self._update(that)\n        return self\n    def __mul__(self, that):\n        values = reduce(iadd, self._lists, []) * that\n        return self.__class__(values, load=self._load)\n    def __imul__(self, that):\n        values = reduce(iadd, self._lists, []) * that\n        self._clear()\n        self._update(values)\n        return self\n    def _make_cmp(self, seq_op, doc):\n        \"Make comparator method.\"\n        def comparer(self, that):\n            \"Compare method for sorted list and sequence.\"\n            # pylint: disable=protected-access\n            if not isinstance(that, Sequence):\n                return NotImplemented\n            self_len = self._len\n            len_that = len(that)\n            if self_len != len_that:\n                if seq_op is op.eq:\n                    return False\n                if seq_op is op.ne:\n                    return True\n            for alpha, beta in zip(self, that):\n                if alpha != beta:\n                    return seq_op(alpha, beta)\n            return seq_op(self_len, len_that)\n        comparer.__name__ = '__{0}__'.format(seq_op.__name__)\n        doc_str = 'Return `True` if and only if Sequence is {0} `that`.'\n        comparer.__doc__ = doc_str.format(doc)\n        return comparer\n    __eq__ = _make_cmp(None, op.eq, 'equal to')\n    __ne__ = _make_cmp(None, op.ne, 'not equal to')\n    __lt__ = _make_cmp(None, op.lt, 'less than')\n    __gt__ = _make_cmp(None, op.gt, 'greater than')\n    __le__ = _make_cmp(None, op.le, 'less than or equal to')\n    __ge__ = _make_cmp(None, op.ge, 'greater than or equal to')\n    @recursive_repr\n    def __repr__(self):\n        temp = '{0}({1}, load={2})'\n        return temp.format(\n            self.__class__.__name__,\n            repr(list(self)),\n            repr(self._load)\n        )\n    def _check(self):\n        try:\n            # Check load parameters.\n            assert self._load >= 4\n            assert self._half == (self._load >> 1)\n            assert self._twice == (self._load * 2)\n            # Check empty sorted list case.\n            if self._maxes == []:\n                assert self._lists == []\n                return\n            assert len(self._maxes) > 0 and len(self._lists) > 0\n            # Check all sublists are sorted.\n            assert all(sublist[pos - 1] <= sublist[pos]\n                       for sublist in self._lists\n                       for pos in range(1, len(sublist)))\n            # Check beginning/end of sublists are sorted.\n            for pos in range(1, len(self._lists)):\n                assert self._lists[pos - 1][-1] <= self._lists[pos][0]\n            # Check length of _maxes and _lists match.\n            assert len(self._maxes) == len(self._lists)\n            # Check _maxes is a map of _lists.\n            assert all(self._maxes[pos] == self._lists[pos][-1]\n                       for pos in range(len(self._maxes)))\n            # Check load level is less than _twice.\n            assert all(len(sublist) <= self._twice for sublist in self._lists)\n            # Check load level is greater than _half for all\n            # but the last sublist.\n            assert all(len(self._lists[pos]) >= self._half\n                       for pos in range(0, len(self._lists) - 1))\n            # Check length.\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n            # Check index.\n            if len(self._index):\n                assert len(self._index) == self._offset + len(self._lists)\n                assert self._len == self._index[0]\n                def test_offset_pos(pos):\n                    \"Test positional indexing offset.\"\n                    from_index = self._index[self._offset + pos]\n                    return from_index == len(self._lists[pos])\n                assert all(test_offset_pos(pos)\n                           for pos in range(len(self._lists)))\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if child >= len(self._index):\n                        assert self._index[pos] == 0\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert self._index[pos] == child_sum\n        except:\n            import sys\n            import traceback\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load, self._half, self._twice)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\ndef identity(value):\n    \"Identity function.\"\n    return value\nclass SortedListWithKey(SortedList):\n    def __init__(self, iterable=None, key=identity, load=1000):\n        # pylint: disable=super-init-not-called\n        self._len = 0\n        self._lists = []\n        self._keys = []\n        self._maxes = []\n        self._index = []\n        self._key = key\n        self._load = load\n        self._twice = load * 2\n        self._half = load >> 1\n        self._offset = 0\n        if iterable is not None:\n            self._update(iterable)\n    def __new__(cls, iterable=None, key=identity, load=1000):\n        return object.__new__(cls)\n    def clear(self):\n        self._len = 0\n        del self._lists[:]\n        del self._keys[:]\n        del self._maxes[:]\n        del self._index[:]\n    _clear = clear\n    def add(self, val):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        key = self._key(val)\n        if _maxes:\n            pos = bisect_right(_maxes, key)\n            if pos == len(_maxes):\n                pos -= 1\n                _lists[pos].append(val)\n                _keys[pos].append(key)\n                _maxes[pos] = key\n            else:\n                idx = bisect_right(_keys[pos], key)\n                _lists[pos].insert(idx, val)\n                _keys[pos].insert(idx, key)\n            self._expand(pos)\n        else:\n            _lists.append([val])\n            _keys.append([key])\n            _maxes.append(key)\n        self._len += 1\n    def _expand(self, pos):\n        _lists = self._lists\n        _keys = self._keys\n        _index = self._index\n        if len(_keys[pos]) > self._twice:\n            _maxes = self._maxes\n            _load = self._load\n            _lists_pos = _lists[pos]\n            _keys_pos = _keys[pos]\n            half = _lists_pos[_load:]\n            half_keys = _keys_pos[_load:]\n            del _lists_pos[_load:]\n            del _keys_pos[_load:]\n            _maxes[pos] = _keys_pos[-1]\n            _lists.insert(pos + 1, half)\n            _keys.insert(pos + 1, half_keys)\n            _maxes.insert(pos + 1, half_keys[-1])\n            del _index[:]\n        else:\n            if _index:\n                child = self._offset + pos\n                while child:\n                    _index[child] += 1\n                    child = (child - 1) >> 1\n                _index[0] += 1\n    def update(self, iterable):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        values = sorted(iterable, key=self._key)\n        if _maxes:\n            if len(values) * 4 >= self._len:\n                values.extend(chain.from_iterable(_lists))\n                values.sort(key=self._key)\n                self._clear()\n            else:\n                _add = self.add\n                for val in values:\n                    _add(val)\n                return\n        _load = self._load\n        _lists.extend(values[pos:(pos + _load)]\n                      for pos in range(0, len(values), _load))\n        _keys.extend(list(map(self._key, _list)) for _list in _lists)\n        _maxes.extend(sublist[-1] for sublist in _keys)\n        self._len = len(values)\n        del self._index[:]\n    _update = update\n    def __contains__(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return False\n        key = self._key(val)\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            return False\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n        while True:\n            if _keys[pos][idx] != key:\n                return False\n            if _lists[pos][idx] == val:\n                return True\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return False\n                len_sublist = len(_keys[pos])\n                idx = 0\n    def discard(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return\n        key = self._key(val)\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            return\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n        while True:\n            if _keys[pos][idx] != key:\n                return\n            if _lists[pos][idx] == val:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return\n                len_sublist = len(_keys[pos])\n                idx = 0\n    def remove(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            raise ValueError('{0} not in list'.format(repr(val)))\n        key = self._key(val)\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            raise ValueError('{0} not in list'.format(repr(val)))\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError('{0} not in list'.format(repr(val)))\n            if _lists[pos][idx] == val:\n                self._delete(pos, idx)\n                return\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError('{0} not in list'.format(repr(val)))\n                len_sublist = len(_keys[pos])\n                idx = 0\n    def _delete(self, pos, idx):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        _index = self._index\n        keys_pos = _keys[pos]\n        lists_pos = _lists[pos]\n        del keys_pos[idx]\n        del lists_pos[idx]\n        self._len -= 1\n        len_keys_pos = len(keys_pos)\n        if len_keys_pos > self._half:\n            _maxes[pos] = keys_pos[-1]\n            if _index:\n                child = self._offset + pos\n                while child > 0:\n                    _index[child] -= 1\n                    child = (child - 1) >> 1\n                _index[0] -= 1\n        elif len(_keys) > 1:\n            if not pos:\n                pos += 1\n            prev = pos - 1\n            _keys[prev].extend(_keys[pos])\n            _lists[prev].extend(_lists[pos])\n            _maxes[prev] = _keys[prev][-1]\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n            self._expand(prev)\n        elif len_keys_pos:\n            _maxes[pos] = keys_pos[-1]\n        else:\n            del _lists[pos]\n            del _keys[pos]\n            del _maxes[pos]\n            del _index[:]\n    def _check_order(self, idx, key, val):\n        # pylint: disable=arguments-differ\n        _len = self._len\n        _keys = self._keys\n        pos, loc = self._pos(idx)\n        if idx < 0:\n            idx += _len\n        # Check that the inserted value is not less than the\n        # previous value.\n        if idx > 0:\n            idx_prev = loc - 1\n            pos_prev = pos\n            if idx_prev < 0:\n                pos_prev -= 1\n                idx_prev = len(_keys[pos_prev]) - 1\n            if _keys[pos_prev][idx_prev] > key:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n                raise ValueError(msg)\n        # Check that the inserted value is not greater than\n        # the previous value.\n        if idx < (_len - 1):\n            idx_next = loc + 1\n            pos_next = pos\n            if idx_next == len(_keys[pos_next]):\n                pos_next += 1\n                idx_next = 0\n            if _keys[pos_next][idx_next] < key:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n                raise ValueError(msg)\n    def __setitem__(self, index, value):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        _check_order = self._check_order\n        _pos = self._pos\n        if isinstance(index, slice):\n            start, stop, step = index.indices(self._len)\n            indices = list(range(start, stop, step))\n            if step != 1:\n                if not hasattr(value, '__len__'):\n                    value = list(value)\n                indices = list(indices)\n                if len(value) != len(indices):\n                    raise ValueError(\n                        'attempt to assign sequence of size {0}'\n                        ' to extended slice of size {1}'\n                        .format(len(value), len(indices)))\n                # Keep a log of values that are set so that we can\n                # roll back changes if ordering is violated.\n                log = []\n                _append = log.append\n                for idx, val in zip(indices, value):\n                    pos, loc = _pos(idx)\n                    key = self._key(val)\n                    _append((idx, _keys[pos][loc], key, _lists[pos][loc], val))\n                    _keys[pos][loc] = key\n                    _lists[pos][loc] = val\n                    if len(_keys[pos]) == (loc + 1):\n                        _maxes[pos] = key\n                try:\n                    # Validate ordering of new values.\n                    for idx, oldkey, newkey, oldval, newval in log:\n                        _check_order(idx, newkey, newval)\n                except ValueError:\n                    # Roll back changes from log.\n                    for idx, oldkey, newkey, oldval, newval in log:\n                        pos, loc = _pos(idx)\n                        _keys[pos][loc] = oldkey\n                        _lists[pos][loc] = oldval\n                        if len(_keys[pos]) == (loc + 1):\n                            _maxes[pos] = oldkey\n                    raise\n            else:\n                if start == 0 and stop == self._len:\n                    self._clear()\n                    return self._update(value)\n                # Test ordering using indexing. If the given value\n                # isn't a Sequence, convert it to a tuple.\n                if not isinstance(value, Sequence):\n                    value = tuple(value) # pylint: disable=redefined-variable-type\n                # Check that the given values are ordered properly.\n                keys = tuple(map(self._key, value))\n                iterator = list(range(1, len(keys)))\n                if not all(keys[pos - 1] <= keys[pos] for pos in iterator):\n                    raise ValueError('given sequence not in sort order')\n                # Check ordering in context of sorted list.\n                if not start or not len(value):\n                    # Nothing to check on the lhs.\n                    pass\n                else:\n                    pos, loc = _pos(start - 1)\n                    if _keys[pos][loc] > keys[0]:\n                        msg = '{0} not in sort order at index {1}'.format(repr(value[0]), start)\n                        raise ValueError(msg)\n                if stop == len(self) or not len(value):\n                    # Nothing to check on the rhs.\n                    pass\n                else:\n                    # \"stop\" is exclusive so we don't need\n                    # to add one for the index.\n                    pos, loc = _pos(stop)\n                    if _keys[pos][loc] < keys[-1]:\n                        msg = '{0} not in sort order at index {1}'.format(repr(value[-1]), stop)\n                        raise ValueError(msg)\n                # Delete the existing values.\n                self._delitem(index)\n                # Insert the new values.\n                _insert = self.insert\n                for idx, val in enumerate(value):\n                    _insert(start + idx, val)\n        else:\n            pos, loc = _pos(index)\n            key = self._key(value)\n            _check_order(index, key, value)\n            _lists[pos][loc] = value\n            _keys[pos][loc] = key\n            if len(_lists[pos]) == (loc + 1):\n                _maxes[pos] = key\n    def irange(self, minimum=None, maximum=None, inclusive=(True, True),\n               reverse=False):\n        minimum = self._key(minimum) if minimum is not None else None\n        maximum = self._key(maximum) if maximum is not None else None\n        return self._irange_key(\n            min_key=minimum, max_key=maximum,\n            inclusive=inclusive, reverse=reverse,\n        )\n    def irange_key(self, min_key=None, max_key=None, inclusive=(True, True),\n                   reverse=False):\n        _maxes = self._maxes\n        if not _maxes:\n            return iter(())\n        _keys = self._keys\n        # Calculate the minimum (pos, idx) pair. By default this location\n        # will be inclusive in our calculation.\n        if min_key is None:\n            min_pos = 0\n            min_idx = 0\n        else:\n            if inclusive[0]:\n                min_pos = bisect_left(_maxes, min_key)\n                if min_pos == len(_maxes):\n                    return iter(())\n                min_idx = bisect_left(_keys[min_pos], min_key)\n            else:\n                min_pos = bisect_right(_maxes, min_key)\n                if min_pos == len(_maxes):\n                    return iter(())\n                min_idx = bisect_right(_keys[min_pos], min_key)\n        # Calculate the maximum (pos, idx) pair. By default this location\n        # will be exclusive in our calculation.\n        if max_key is None:\n            max_pos = len(_maxes) - 1\n            max_idx = len(_keys[max_pos])\n        else:\n            if inclusive[1]:\n                max_pos = bisect_right(_maxes, max_key)\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_right(_keys[max_pos], max_key)\n            else:\n                max_pos = bisect_left(_maxes, max_key)\n                if max_pos == len(_maxes):\n                    max_pos -= 1\n                    max_idx = len(_keys[max_pos])\n                else:\n                    max_idx = bisect_left(_keys[max_pos], max_key)\n        return self._islice(min_pos, min_idx, max_pos, max_idx, reverse)\n    _irange_key = irange_key\n    def bisect_left(self, val):\n        return self._bisect_key_left(self._key(val))\n    def bisect_right(self, val):\n        return self._bisect_key_right(self._key(val))\n    bisect = bisect_right\n    def bisect_key_left(self, key):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            return self._len\n        idx = bisect_left(self._keys[pos], key)\n        return self._loc(pos, idx)\n    _bisect_key_left = bisect_key_left\n    def bisect_key_right(self, key):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        pos = bisect_right(_maxes, key)\n        if pos == len(_maxes):\n            return self._len\n        idx = bisect_right(self._keys[pos], key)\n        return self._loc(pos, idx)\n    bisect_key = bisect_key_right\n    _bisect_key_right = bisect_key_right\n    def count(self, val):\n        _maxes = self._maxes\n        if not _maxes:\n            return 0\n        key = self._key(val)\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            return 0\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        total = 0\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n        while True:\n            if _keys[pos][idx] != key:\n                return total\n            if _lists[pos][idx] == val:\n                total += 1\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    return total\n                len_sublist = len(_keys[pos])\n                idx = 0\n    def copy(self):\n        return self.__class__(self, key=self._key, load=self._load)\n    __copy__ = copy\n    def append(self, val):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        key = self._key(val)\n        if not _maxes:\n            _maxes.append(key)\n            _keys.append([key])\n            _lists.append([val])\n            self._len = 1\n            return\n        pos = len(_keys) - 1\n        if key < _keys[pos][-1]:\n            msg = '{0} not in sort order at index {1}'.format(repr(val), self._len)\n            raise ValueError(msg)\n        _lists[pos].append(val)\n        _keys[pos].append(key)\n        _maxes[pos] = key\n        self._len += 1\n        self._expand(pos)\n    def extend(self, values):\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        _load = self._load\n        if not isinstance(values, list):\n            values = list(values)\n        keys = list(map(self._key, values))\n        if any(keys[pos - 1] > keys[pos]\n               for pos in range(1, len(keys))):\n            raise ValueError('given sequence not in sort order')\n        offset = 0\n        if _maxes:\n            if keys[0] < _keys[-1][-1]:\n                msg = '{0} not in sort order at index {1}'.format(repr(values[0]), self._len)\n                raise ValueError(msg)\n            if len(_keys[-1]) < self._half:\n                _lists[-1].extend(values[:_load])\n                _keys[-1].extend(keys[:_load])\n                _maxes[-1] = _keys[-1][-1]\n                offset = _load\n        len_keys = len(_keys)\n        for idx in range(offset, len(keys), _load):\n            _lists.append(values[idx:(idx + _load)])\n            _keys.append(keys[idx:(idx + _load)])\n            _maxes.append(_keys[-1][-1])\n        _index = self._index\n        if len_keys == len(_keys):\n            len_index = len(_index)\n            if len_index > 0:\n                len_values = len(values)\n                child = len_index - 1\n                while child:\n                    _index[child] += len_values\n                    child = (child - 1) >> 1\n                _index[0] += len_values\n        else:\n            del _index[:]\n        self._len += len(values)\n    def insert(self, idx, val):\n        _len = self._len\n        _lists = self._lists\n        _keys = self._keys\n        _maxes = self._maxes\n        if idx < 0:\n            idx += _len\n        if idx < 0:\n            idx = 0\n        if idx > _len:\n            idx = _len\n        key = self._key(val)\n        if not _maxes:\n            self._len = 1\n            _lists.append([val])\n            _keys.append([key])\n            _maxes.append(key)\n            return\n        if not idx:\n            if key > _keys[0][0]:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), 0)\n                raise ValueError(msg)\n            else:\n                self._len += 1\n                _lists[0].insert(0, val)\n                _keys[0].insert(0, key)\n                self._expand(0)\n                return\n        if idx == _len:\n            pos = len(_keys) - 1\n            if _keys[pos][-1] > key:\n                msg = '{0} not in sort order at index {1}'.format(repr(val), _len)\n                raise ValueError(msg)\n            else:\n                self._len += 1\n                _lists[pos].append(val)\n                _keys[pos].append(key)\n                _maxes[pos] = _keys[pos][-1]\n                self._expand(pos)\n                return\n        pos, idx = self._pos(idx)\n        idx_before = idx - 1\n        if idx_before < 0:\n            pos_before = pos - 1\n            idx_before = len(_keys[pos_before]) - 1\n        else:\n            pos_before = pos\n        before = _keys[pos_before][idx_before]\n        if before <= key <= _keys[pos][idx]:\n            self._len += 1\n            _lists[pos].insert(idx, val)\n            _keys[pos].insert(idx, key)\n            self._expand(pos)\n        else:\n            msg = '{0} not in sort order at index {1}'.format(repr(val), idx)\n            raise ValueError(msg)\n    def index(self, val, start=None, stop=None):\n        _len = self._len\n        if not _len:\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        if start is None:\n            start = 0\n        if start < 0:\n            start += _len\n        if start < 0:\n            start = 0\n        if stop is None:\n            stop = _len\n        if stop < 0:\n            stop += _len\n        if stop > _len:\n            stop = _len\n        if stop <= start:\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        _maxes = self._maxes\n        key = self._key(val)\n        pos = bisect_left(_maxes, key)\n        if pos == len(_maxes):\n            raise ValueError('{0} is not in list'.format(repr(val)))\n        stop -= 1\n        _lists = self._lists\n        _keys = self._keys\n        idx = bisect_left(_keys[pos], key)\n        len_keys = len(_keys)\n        len_sublist = len(_keys[pos])\n        while True:\n            if _keys[pos][idx] != key:\n                raise ValueError('{0} is not in list'.format(repr(val)))\n            if _lists[pos][idx] == val:\n                loc = self._loc(pos, idx)\n                if start <= loc <= stop:\n                    return loc\n                elif loc > stop:\n                    break\n            idx += 1\n            if idx == len_sublist:\n                pos += 1\n                if pos == len_keys:\n                    raise ValueError('{0} is not in list'.format(repr(val)))\n                len_sublist = len(_keys[pos])\n                idx = 0\n        raise ValueError('{0} is not in list'.format(repr(val)))\n    def __add__(self, that):\n        values = reduce(iadd, self._lists, [])\n        values.extend(that)\n        return self.__class__(values, key=self._key, load=self._load)\n    def __mul__(self, that):\n        values = reduce(iadd, self._lists, []) * that\n        return self.__class__(values, key=self._key, load=self._load)\n    def __imul__(self, that):\n        values = reduce(iadd, self._lists, []) * that\n        self._clear()\n        self._update(values)\n        return self\n    @recursive_repr\n    def __repr__(self):\n        temp = '{0}({1}, key={2}, load={3})'\n        return temp.format(\n            self.__class__.__name__,\n            repr(list(self)),\n            repr(self._key),\n            repr(self._load)\n        )\n    def _check(self):\n        try:\n            # Check load parameters.\n            assert self._load >= 4\n            assert self._half == (self._load >> 1)\n            assert self._twice == (self._load * 2)\n            # Check empty sorted list case.\n            if self._maxes == []:\n                assert self._keys == []\n                assert self._lists == []\n                return\n            assert len(self._maxes) > 0 and len(self._keys) > 0 and len(self._lists) > 0\n            # Check all sublists are sorted.\n            assert all(sublist[pos - 1] <= sublist[pos]\n                       for sublist in self._keys\n                       for pos in range(1, len(sublist)))\n            # Check beginning/end of sublists are sorted.\n            for pos in range(1, len(self._keys)):\n                assert self._keys[pos - 1][-1] <= self._keys[pos][0]\n            # Check length of _maxes and _lists match.\n            assert len(self._maxes) == len(self._lists) == len(self._keys)\n            # Check _keys matches _key mapped to _lists.\n            assert all(len(val_list) == len(key_list)\n                       for val_list, key_list in zip(self._lists, self._keys))\n            assert all(self._key(val) == key for val, key in\n                       zip((_val for _val_list in self._lists for _val in _val_list),\n                           (_key for _key_list in self._keys for _key in _key_list)))\n            # Check _maxes is a map of _keys.\n            assert all(self._maxes[pos] == self._keys[pos][-1]\n                       for pos in range(len(self._maxes)))\n            # Check load level is less than _twice.\n            assert all(len(sublist) <= self._twice for sublist in self._lists)\n            # Check load level is greater than _half for all\n            # but the last sublist.\n            assert all(len(self._lists[pos]) >= self._half\n                       for pos in range(0, len(self._lists) - 1))\n            # Check length.\n            assert self._len == sum(len(sublist) for sublist in self._lists)\n            # Check index.\n            if len(self._index):\n                assert len(self._index) == self._offset + len(self._lists)\n                assert self._len == self._index[0]\n                def test_offset_pos(pos):\n                    \"Test positional indexing offset.\"\n                    from_index = self._index[self._offset + pos]\n                    return from_index == len(self._lists[pos])\n                assert all(test_offset_pos(pos)\n                           for pos in range(len(self._lists)))\n                for pos in range(self._offset):\n                    child = (pos << 1) + 1\n                    if self._index[pos] == 0:\n                        assert child >= len(self._index)\n                    elif child + 1 == len(self._index):\n                        assert self._index[pos] == self._index[child]\n                    else:\n                        child_sum = self._index[child] + self._index[child + 1]\n                        assert self._index[pos] == child_sum\n        except:\n            import sys\n            import traceback\n            traceback.print_exc(file=sys.stdout)\n            print('len', self._len)\n            print('load', self._load, self._half, self._twice)\n            print('offset', self._offset)\n            print('len_index', len(self._index))\n            print('index', self._index)\n            print('len_maxes', len(self._maxes))\n            print('maxes', self._maxes)\n            print('len_keys', len(self._keys))\n            print('keys', self._keys)\n            print('len_lists', len(self._lists))\n            print('lists', self._lists)\n            raise\n\nn = int(input())\nr = SortedList([(-1, -1)])\nfor x in map(int, input().split()):\n    i = r.bisect((x+1, -1))-1\n    y, p = r[i]\n    if p != -1:\n        print(p, end=' ')\n    del r[i]\n    r.add((y, x))\n    r.add((x, x))\nprint()\n"]
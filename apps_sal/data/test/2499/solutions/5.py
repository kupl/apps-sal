from functools import reduce
from operator import xor
import numpy as np


def main():
    N = int(input())
    A = np.array(input().split(), np.int64)
    # とりあえず全部XORする
    A_xor_all = np.bitwise_xor.reduce(A)

    # 参考
    # https://betrue12.hateblo.jp/entry/2019/11/22/012255

    # * 全部XORして1になるビットは、どう塗り分けても片方は0, もう片方が1になる
    #   つまり、このビットはどうグループ分けしても和は1になるので、このビットは考察対象から外す
    # * 全部XORして0になるビットは、このビットが1になっている要素の個数を赤と青それぞれで奇数個にしてあげれば、
    #   XOR(赤グループ) + XOR(青グループ)を最大化できる。

    # そこで、Aの各要素を、全部XORして1になるビットを無視した(0にした)数値に変換したもの（A'）を作る
    # A'の要素を2グループに分け、各グループのXORの和が最大になるようにする。
    # ただし、各ビットにおいて、ビットが1になっているA'要素の個数は必ず偶数になっていることから、
    # どうグループ分けしたとしても、必ず「XOR(A'の赤グループ) = XOR(A'の青グループ)」となる。
    # XORを最大化するように要素を選択したときのグループをX'とすると、答えは、以下の通りとなる
    # [A全部のXOR結果] + 2 * [X'のXOR結果]

    # A'を作成
    # 1になっているビットを無視したいので、A全体のXOR結果を反転してANDをとる
    mask = ~A_xor_all
    A_dash = A & mask

    # X'を求める方法
    #   A'の要素の位置を入れ替えたり、
    #   ある要素を、その要素と別の要素とのXOR結果に置き換えたりする操作を繰り返し、
    #   A'の行標準形Rを求めると、
    #   Rの全要素のXOR結果が、X'となる

    # 行標準形: 行列の左下の方が0になるような形（連立方程式を解くときに作るようなやつ）
    #          また、i行目において、一番左にある1がn列目だとすると、n列目全体において、i行目以外では全て0になっている
    # 例
    #   1 0 ? 0 ? ? ?
    #   0 1 ? 0 ? ? ?
    #   0 0 0 1 ? ? ?
    #   0 0 0 0 0 0 0

    # 行標準形の作り方
    #  1. 最大値を見つける (=a1とする)
    #  2. a1において一番左にある1がn1列目だとすると、他の行でn1列目が1になっていたら、a1とXORする
    #  3. a1以外の最大値を見つける (=a2とする)
    #  4. a2において一番左にある1がn2列目だとすると、他の行でn2列目が1になっていたら、a2とXORする
    #     (a1も、n2列目が1になっている場合はa2とXORする)
    #  5. a1, a2以外の最大値を見つける (=a3とする)
    #  6. a3において一番左にある1がn3列目だとすると、他の行でn3列目が1になっていたら、a3とXORする
    #     (a1, a2も、n3列目が1になっている場合はa3とXORする)
    #  ....

    # 例: A = [12, 9, 7, 2] = [1100, 1001, 0111, 0010] の場合
    # XOR(A) = 0000, A' = A = [12, 9, 7, 2] =
    # [1100
    #  1001
    #  0111
    #  0010]

    # 2行目 ^= 1行目
    # [1100
    #  0101
    #  0111
    #  0010]

    # 2行目と3行目を交換
    # [1100
    #  0111
    #  0101
    #  0010]

    # 3行目 ^= 2行目, 1行目^=2行目
    # [1011
    #  0111
    #  0010
    #  0010]

    # 4行目 ^= 3行目, 2行目 ^= 3行目, 1行目 ^= 3行目
    # [1001
    #  0101
    #  0010
    #  0000] = R

    # RのXOR結果がX'のXOR結果と一致する理由
    #   1. A'の要素の位置を入れ替えても、XORの最大化には影響しない。
    #   2. A'のある要素を、その要素と別の要素とのXOR結果に置き換えたときのXORの最大値が
    #      元のA'のXORの最大値と同じである (=XORの最大化には影響しない)
    #   3. RからXORを最大化するように要素を選択しようとするなら、
    #      Rの要素を全選択すればよい

    # 理由2について詳しく書く。

    # 例えば、要素数が3の集合Aがある場合、そのべき集合S(A)は以下の通りとなる。
    # A = {a1, a2, a3}
    # S(A) = {0, a1, a2, a3, a1^a2, a2^a3, a3^a1, a1^a2^a3}

    # a1 ^= a2 とし、これをb1とおく。また、この集合をBとすると、
    # B = {a1^a2, a2, a3} = {b1, a2, a3}
    # Bのべき集合S(B)は、
    # S(B) = {0, b1, a2, a3, b1^a2, a2^a3, a3^b1, b1^a2^a3}
    #      = {0, (a1^a2), a2, a3, (a1^a2)^a2, a2^a3, a3^(a1^a2), (a1^a2)^a2^a3}
    #      = {0, a1^a2, a2, a3, a1, a2^a3, a3^a1^a2, a1^a3}
    #      = S(A)
    # となり、Aのべき集合と一致する。
    # A'のべき集合の中に、XORを最大化する集合があるはずなので、
    # RからXORを最大化する集合を見つければよい。
    # また、Rについては、上位のビットから順に、そのビットが1になっている数が1個しかないように
    # 要素を変換していっているため、Rのべき集合からXORが最大のものを選びたい場合、
    # 全部選択すれば、XORしても上位のビットは全部1になるので、XORが最大化される。

    # 戦略通り、まずRを作って最後に全部XORするでも良いが、
    # 今までの最大値の場所を覚えてないといけないなど、面倒な部分があるため、
    # A'のXORの最大値の求め方を以下のように変形する。

    #  0. ans = 0とする

    #  1. 最大値を見つける (=a1とする)
    #  2. a1において一番左にある1がn1列目だとすると、n1列目が1になっている全ての行について（a1の行も含む）、
    #     a1とXORする**   -> a1の行は自身とXORをとるので0になる
    #  3. ans ^= a1とする

    #  4. 最大値を見つける (=a2とする)   <- 先ほど、a1を0にしたので、a1以外の最大値が見つかる
    #  5. a2において一番左にある1がn2列目だとすると、n2列目が1になっている全ての行について（a2の行も含む）
    #     a2とXORする**   -> a2の行は自身とXORをとるので0になる
    #  6. ans (= a1) のn2列目が1でない場合は、ans ^= a2とする
    #     -> 元の手順では、a1のn2列目が1になっている場合はa2とXORをとっていた。
    #        しかし、最終的に答えを求めるとき、全要素をXORするので、
    #        答え = (a1^a2) ^ a2 ^ ... = a1 ^ ...
    #        となり、答えからa2が消える。

    #  7. 最大値を見つける (=a3とする)   <- 先ほど、a2を0にしたので、a1, a2以外の最大値が見つかる
    #  8. a3において一番左にある1がn2列目だとすると、n3列目が1になっている全ての行について（a3の行も含む）
    #     a3とXORする**   -> a3の行は自身とXORをとるので0になる
    #  9. ans のn3列目が1でない場合は、ans ^= a3とする
    #     -> 元の手順では、a1, a2のn3列目が1になっている場合はa3とXORをとっていた。
    #        しかし、最終的に答えを求めるとき、全要素をXORするので、

    #        * a2をXORした場合: ans = a1^a2 となっているはず
    #          -> a1^a2のn3列目が1になっている場合、どちらかをa3とXORをとっているので、
    #             答え = ((a1^a2) ^ a3)^a3 ^ ... = (a1^a2) ^ ...
    #             となり、ansにa3をXORしなくて良い
    #          -> a1^a2のn3列目が0になっている場合、a1,a2の両方にa3をXORしたか、どちらにもXORしなかったか、
    #             答え = ((a1^a3) ^ (a2^a3))^a3 ^ ... もしくは  (a1^a2)^a3^ ...
    #             となり、a3が1個残るので、ans にa3をXORする必要がある。

    #        * a2をXORした場合: ans = a1 となっているはず
    #          手順6と同じ状況になるので、手順6と同様の理由で、ansのn3列目が1でなければa3をXORする

    #  ...

    # これを実装すると、以下の通りとなる
    ans = 0
    while True:
        _max = A_dash.max()                 # 最大値を見つける
        # print("max={}".format(_max))
        # 最大値が0なら、全部調べつくしたか、XOR操作によって全部0になったかのどっちか
        # どちらにしろこれ以上操作は不要なので終了
        if _max == 0:
            break
        # 最大値において一番左にある1が何列目にあるか調べる
        # (数値としては、一番左にある1が右から何列目にあるかを表している)
        most_left = int(_max).bit_length()
        # その列だけ1にした数字を作る
        b = 1 << (most_left - 1)
        # most_left列目が1になっている全ての行について、最大値とXORする
        # most_left列目が1になっているか -> その列だけ1にした数字とandをとって非ゼロかどうか
        A_dash[A_dash & b > 0] ^= _max
        # print(A_dash, b)
        # ans のmost_left列目が1でない場合は、ans ^= 最大値とする
        if ans & b == 0:
            ans ^= _max

    print(2 * ans + A_xor_all)


def __starting_point():
    main()


__starting_point()

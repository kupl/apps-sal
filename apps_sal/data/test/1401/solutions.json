["n = int(input())\n\nA = list(map(int, input().split()))\n\nmaxDist = [0] * n\n\nG = [[] for _ in range(n)]\n\nfor v in range(1, n):\n    u, d = tuple(map(int, input().split()))\n    u -= 1\n    G[v].append((u, d))\n    G[u].append((v, d))\n\n\nseen = [False] * n\nseen[0] = True\nq = [0]\nto_remove = []\n\nwhile q:\n    v = q.pop();\n    for u, dist in G[v]:\n        if not seen[u]:\n            seen[u] = True\n            maxDist[u] = max(dist, maxDist[v] + dist)\n            if maxDist[u] > A[u]:\n                to_remove.append(u)\n            else:\n                q.append(u)\n\ncount = 0\nwhile to_remove:\n    v = to_remove.pop()\n    count += 1\n    for u, _ in G[v]:\n        if not seen[u]:\n            seen[u] = True\n            to_remove.append(u)\n\nprint(count)", "import sys\n\ndef main():\n    u = []\n    r = 0\n    x = []\n    q = []\n\n\n    n = int(sys.stdin.readline())\n    x = list(map(int, sys.stdin.readline().split()))\n    links = [[] for i in range(n)]\n    u = [False]*n\n    p = [0]*n\n    d = [False]*n\n\n    data = sys.stdin.readlines()\n    for i in range(n-1):\n        y = data[i].split()    \n        v , c = int(y[0])-1, int(y[1])\n        links[i+1].append((v,c))\n        links[v].append((i+1,c))\n\n    u[0] = True\n    q.append((0,0,False))\n    while len(q)!=0:\n        z = q.pop()\n        i, path, al = z[0], z[1],z[2]\n        for y in links[i]:\n            j , c = y[0], y[1]\n            if not u[j] :\n                u[j] = True\n                #print(\"dfs\", j, path, c)\n                al2 = al\n                np = max(path + c, c)\n                if np>x[j]:\n                    al2 = True\n                if al2:\n                    r+=1\n                #print(j , np , x[j], al2)\n                q.append((j, np, al2)) \n\n    print(r)\n\n\nmain()\n", "n = int(input())\na = [int(x) for x in input().split()]\ng = [[] for _ in range(n)]\nfor u in range(1, n):\n    p, c = (int(x) for x in input().split())\n    g[p-1].append((u, c))\n\nstack = [(0, 0, False)]\nr = 0\nwhile stack:\n    u, d, f = stack.pop()\n    f = f or d > a[u]\n    if f:\n        r += 1\n    for v, c in g[u]:\n        stack.append((v, d + c if d + c >= 0 else 0, f))\n\nprint(r)", "from queue import deque\n#sys.setrecursionlimit(10**6)\n\nn = int(input())\na = [0] + list(map(int, input().split()))\n\nG = {i : [] for i in range(1, n+1)}\n\nfor i in range(1, n):\n    parent, edge = list(map(int, input().split()))\n    G[parent].append((i + 1, edge))\n\ncut = 0\nstack = [(1, 0, False)]\n\nwhile stack:\n    v, cur_max, to_cut = stack.pop()\n\n    if cur_max > a[v] and not to_cut:\n        to_cut = True\n        cut += 1\n\n    if to_cut:\n        cut += len(G[v])\n\n    for u, e in G[v]:\n        stack.append((u, max(0, cur_max + e), to_cut))\n\nprint(cut)\n\n\n\n", "\"\"\"\n\tAuthor\t\t: Arif Ahmad\n\tDate  \t\t: 18-06-16\n\tAlgo  \t\t: DFS\n\tDifficulty\t: Medium\n\"\"\"\n\ndef main():\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\ta.insert(0, 0)\n\t\n\tg = [[] for x in range(n+1)]\n\tcost = {}\n\tfor i in range(2, n+1):\n\t\tp, c = list(map(int, input().split()))\n\t\tg[p].append((i, c))\n\n\tstack = [(1, 0, False)]\n\tans = 0\n\twhile stack:\n\t\tu, dist, sad = stack.pop()\n\t\tsad = sad or dist > a[u]\n\t\tif sad: ans += 1\n\t\tfor v, c in g[u]:\n\t\t\tstack.append((v, max(0, dist+c), sad))\n\n\tprint(ans)\n\n\ndef __starting_point():\n    main()\n    \n\n__starting_point()", "from sys import *\nsetrecursionlimit(1000001)\nn=int(input())\na=[0]+list(map(int,input().split()))\nE=[[] for _ in range(n+1)]\nk=[1]*(n+1)\nfor i in range(n-1):\n    p,c=map(int,input().split())\n    E[i+2]+=[(p,c)]\n    E[p]+=[(i+2,c)]\ndef bfs(nom,pre=0):\n    ch,ii=[(nom,pre)],0\n    while ii<len(ch):\n        nom,pre=ch[ii]\n        for x,c in E[nom]:\n            if x!=pre: ch+=[(x,nom)]\n        ii+=1\n    for i in range(len(ch)-1,-1,-1):\n        nom,pre=ch[i]\n        for x,c in E[nom]:\n            if x!=pre: k[nom]+=k[x]        \n    \nbfs(1)\ndef bfs2(nom,pre=0,l=0):\n    ch=[(nom,pre,l)]\n    ans=0\n    while ch!=[]:\n        nom,pre,l=ch.pop()\n        if l>a[nom]: ans+=k[nom]; continue\n        for x,c in E[nom]:\n            if x!=pre:  \n                ch+=[(x,nom,max(l+c,c))]\n    return ans\nprint(bfs2(1))", "n=int(input())\na=[0]+list(map(int,input().split()))\nE=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    p,c=map(int,input().split())\n    E[i+2]+=[(p,c)]\n    E[p]+=[(i+2,c)]\n\nans=0\nch=[(1,0,0)]\nwhile ch:\n    nom,pre,l=ch.pop()\n    if l>a[nom]: continue\n    ans+=1\n    for x,c in E[nom]:\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\nprint(n-ans)", "n=int(input())\na=[0]+list(map(int,input().split()))\nE=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    p,c=map(int,input().split())\n    E[i+2]+=[(p,c)]\n    E[p]+=[(i+2,c)]\n\nans=0\nch=[(1,0,0)]\nwhile ch:\n    nom,pre,l=ch.pop()\n    if l>a[nom]: continue\n    ans+=1\n    for x,c in E[nom]:\n        t=l+c if l>0 else c\n        if x!=pre: ch+=[(x,nom,t)]\nprint(n-ans)", "read = lambda: list(map(int, input().split()))\nn = int(input())\na = [0] + list(read())\ng = [list() for i in range(n + 1)]\nfor i in range(2, n + 1):\n    p, c = read()\n    g[i].append((p, c))\n    g[p].append((i, c))\nwas = [0] * (n + 1)\nst = [(1, 0, 0)]\nwhile st:\n    v, mind, dist = st.pop()\n    was[v] = 1\n    for u, c in g[v]:\n        if not was[u]:\n            if dist + c - min(dist + c, mind) <= a[u]:\n                st.append((u, min(mind, dist + c), dist + c))\n\nans = n - was.count(1)\nprint(ans)\n", "import sys\n\n\ndef subtree_count():\n    stack = [0]\n    while len(stack):\n        v = stack[-1]\n\n        size = 1\n        for u, _ in edge[v]:\n            if u in subtree:\n                size += subtree[u]\n            else:\n                stack.append(u)\n\n        if stack[-1] == v:\n            stack.pop()\n            subtree[v] = size\n\n\ndef remove_bfs():\n    queue = [(0, 0)]\n\n    removed = 0\n\n    while len(queue):\n        v, s = queue.pop()\n\n        if s > vertex[v]:\n            removed += subtree[v]\n        else:\n            for u, c in edge[v]:\n                queue.append((u, max(s + c, 0)))\n\n    return removed\n\nsys.setrecursionlimit(1000001)\nn = int(input())\n\nvertex = list(map(int, input().split()))\nedge = {}\nsubtree = {}\n\nfor i in range(n):\n    edge[i] = []\n\nfor i in range(n - 1):\n    p, c = list(map(int, input().split()))\n    edge[p - 1] += [(i + 1, c)]\n\nsubtree_count()\nprint(remove_bfs())\n", "def subtree_count():\n    stack = [0]\n    while len(stack):\n        v = stack[-1]\n\n        size = 1\n        for u, _ in edge[v]:\n            if u in subtree:\n                size += subtree[u]\n            else:\n                stack.append(u)\n\n        if stack[-1] is v:\n            stack.pop()\n            subtree[v] = size\n\n\ndef remove_bfs():\n    queue = [(0, 0)]\n    removed = 0\n\n    while len(queue):\n        v, s = queue.pop()\n\n        if s > vertex[v]:\n            removed += subtree[v]\n        else:\n            for u, c in edge[v]:\n                queue.append((u, max(s + c, 0)))\n\n    return removed\n\nn = int(input())\n\nvertex = list(map(int, input().split()))\nedge = {}\nsubtree = {}\n\nfor i in range(n):\n    edge[i] = []\n\nfor i in range(n - 1):\n    p, c = list(map(int, input().split()))\n    edge.get(p - 1, []).append((i + 1, c))\n\nsubtree_count()\nprint(remove_bfs())\n", "def subtree_count():\n    stack = [0]\n    while len(stack):\n        v = stack[-1]\n\n        size = 1\n        for u, _ in edge[v]:\n            if u in subtree:\n                size += subtree[u]\n            else:\n                stack.append(u)\n\n        if stack[-1] is v:\n            stack.pop()\n            subtree[v] = size\n\n\ndef remove_bfs():\n    queue = [(0, 0)]\n    removed = 0\n\n    while len(queue):\n        v, s = queue.pop()\n\n        if s > vertex[v]:\n            removed += subtree[v]\n        else:\n            for u, c in edge[v]:\n                queue.append((u, max(s + c, 0)))\n\n    return removed\n\nn = int(input())\n\nvertex = list(map(int, input().split()))\nedge = {}\nsubtree = {}\n\nfor i in range(n):\n    edge[i] = []\n\nfor i in range(n - 1):\n    p, c = list(map(int, input().split()))\n    edge[p - 1].append((i + 1, c))\n\nsubtree_count()\nprint(remove_bfs())\n", "nn=int(input())\na=[0]+list(map(int,input().split()))\nE=[[] for _ in range(nn+1)]\nfor i in range(nn-1):\n    p,c=list(map(int,input().split()))\n    E[i+2]+=[(p,c)]\n    E[p]+=[(i+2,c)]\n\nans=0\nch=[(1,0,0)]\nwhile ch:\n    nom,pre,l=ch.pop()\n    if l>a[nom]: continue\n    ans+=1\n    for x,c in E[nom]:\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\nprint(nn-ans)\n", "n=input()\nn=int(n)\na=input()\na=a.split()\na[0:0]=[0]\nfor i in range(1,n+1):\n    a[i]=int(a[i])\ne=[[]for i in range(0,n+1)]\nfor i in range(2,n+1):\n    x=input()\n    x=x.split()\n    e[i].append([int(x[0]),int(x[1])])\n    e[int(x[0])].append([i,int(x[1])])\nq=[1]\ncnt=0\nf=[0 for i in range(0,n+1)]\ndp=[0 for i in range(0,n+1)]\nans=1\nwhile cnt<len(q):\n    #print(cnt,len(q))\n    now=q[cnt]\n    cnt+=1\n    for x in e[now]:\n        if x[0]!=f[now]:\n            f[x[0]]=now\n            dp[x[0]]=max(x[1]+dp[now],0)\n            if dp[x[0]]>a[x[0]]:\n                continue\n            q.append(x[0])\n            ans+=1\nprint(n-ans)", "from collections import deque\nimport sys\n\n\ndef bfs(n, adjList, a):\n    q = deque()\n    dist = [0] * (n+3)\n    vis = [False] * (n+3)\n\n    q.append(1)\n    vis[1] = True\n    cnt = 0\n\n    while q:\n        u = q.popleft()\n\n        if a[u] < dist[u]:\n            continue\n\n        cnt += 1\n        for (v, c) in adjList[u]:\n            if not vis[v]:\n                vis[v] = True\n                dist[v] = max(dist[u]+c, 0)\n                q.append(v)\n\n    return cnt\n\n\ndef main():\n    # sys.stdin = open(\"in.txt\", \"r\")\n\n    it = iter(map(int, sys.stdin.read().split()))\n\n    n = next(it)\n\n    a = [0] * (n+3)\n    adjList = [[] for _ in range(n+3)]\n\n    for i in range(1, n+1):\n        a[i] = next(it)\n\n    for i in range(1, n):\n        p = next(it)\n        c = next(it)\n        adjList[i+1].append((p, c))\n        adjList[p].append((i+1, c))\n\n    ans = n - bfs(n, adjList, a)\n\n    sys.stdout.write(str(ans) + '\\n')\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import deque\nimport sys\n\n\ndef bfs(n, adjList, a):\n    q = deque()\n    dist = [0] * (n+3)\n    vis = [False] * (n+3)\n\n    q.append(1)\n    vis[1] = True\n    cnt = 0\n\n    while q:\n        u = q.popleft()\n\n        if a[u] < dist[u]:\n            continue\n\n        cnt += 1\n        for (v, c) in adjList[u]:\n            if not vis[v]:\n                vis[v] = True\n                dist[v] = max(dist[u]+c, 0)\n                q.append(v)\n\n    return cnt\n\n\ndef main():\n    # sys.stdin = open(\"in.txt\", \"r\")\n\n    it = iter(map(int, sys.stdin.read().split()))\n\n    n = next(it)\n\n    a = [0] * (n+3)\n    adjList = [[] for _ in range(n+3)]\n\n    for i in range(1, n+1):\n        a[i] = next(it)\n\n    for i in range(1, n):\n        p = next(it)\n        c = next(it)\n        adjList[i+1].append((p, c))\n        adjList[p].append((i+1, c))\n\n    ans = n - bfs(n, adjList, a)\n\n    sys.stdout.write(str(ans) + '\\n')\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import deque\nimport sys\n\n\ndef bfs(n, adjList, a):\n    q = deque()\n    dist = [0] * (n+3)\n    vis = [False] * (n+3)\n\n    q.append(1)\n    vis[1] = True\n    cnt = 0\n\n    while q:\n        u = q.popleft()\n\n        if a[u] < dist[u]:\n            continue\n\n        cnt += 1\n        for (v, c) in adjList[u]:\n            if not vis[v]:\n                vis[v] = True\n                dist[v] = max(dist[u]+c, 0)\n                q.append(v)\n\n    return cnt\n\n\ndef main():\n    # sys.stdin = open(\"in.txt\", \"r\")\n\n    it = iter(map(int, sys.stdin.read().split()))\n\n    n = next(it)\n\n    a = [0] * (n+3)\n    adjList = [[] for _ in range(n+3)]\n\n    for i in range(1, n+1):\n        a[i] = next(it)\n\n    for i in range(1, n):\n        p = next(it)\n        c = next(it)\n        adjList[i+1].append((p, c))\n        adjList[p].append((i+1, c))\n\n    ans = n - bfs(n, adjList, a)\n\n    sys.stdout.write(str(ans) + '\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nver = list(map(int, input().split()))\nadj = [{} for i in range(n)]\n\nfor i in range(n - 1):\n    p, c = map(int, input().split())\n    adj[i + 1][p - 1] = c\n    adj[p - 1][i + 1] = c\n\nfrom collections import deque\nq = deque([(0, 0, 0)])\n\nsad = [0] * n\nvis = [0] * n\n\nwhile q:\n    v, d, md = q.popleft()\n    vis[v] = 1\n\n    for nv, nvd in adj[v].items():\n        if vis[nv] == 1 and sad[nv] == 1:\n            sad[v] = 1\n\n    if d > ver[v] or d - md > ver[v]:\n        sad[v] = 1\n\n    for nv, nvd in adj[v].items():\n        if vis[nv] == 0:\n            q.append((nv, d + nvd, min(d + nvd, md)))\n    \nprint(sum(sad))", "\nread = lambda: map(int, input().split())\nn = int(input())\na = [0] + list(read())\ng = [list() for i in range(n + 1)]\nfor i in range(2, n + 1):\n    p, c = read()\n    g[i].append((p, c))\n    g[p].append((i, c))\nwas = [0] * (n + 1)\nst = [(1, 0, 0)]\nwhile st:\n    v, mind, dist = st.pop()\n    was[v] = 1\n    for u, c in g[v]:\n        if not was[u]:\n            if dist + c - min(dist + c, mind) <= a[u]:\n                st.append((u, min(mind, dist + c), dist + c))\n\nans = n - was.count(1)\nprint(ans)", "nn=int(input())\n\na=[0]+list(map(int,input().split()))\n\nE=[[] for _ in range(nn+1)]\n\nfor i in range(nn-1):\n\n    p,c=list(map(int,input().split()))\n\n    E[i+2]+=[(p,c)]\n\n    E[p]+=[(i+2,c)]\n\n\n\nans=0\n\nch=[(1,0,0)]\n\nwhile ch:\n\n    nom,pre,l=ch.pop()\n\n    if l>a[nom]: continue\n\n    ans+=1\n\n    for x,c in E[nom]:\n\n        if x!=pre: ch+=[(x,nom,max(l+c,c))]\n\nprint(nn-ans)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "n = int(input())\na = list(map(int, input().split()))\ne = []\nfor i in range(n):\n    e.append([])\nfor i in range(1, n):\n    x, y = map(int, input().split())\n    e[x-1].append([i, y])\n\nb = [0] * n\nc = [0] * n\nd = [(10**18)] * n\nl = 0\nr = 1\ncnt = 0\nwhile l < r:\n    v = b[l]\n    if c[l] - a[v] > d[l]:\n        l += 1\n        continue\n    cnt += 1\n    for x in e[v]:\n        c[r] = c[l] + x[1]\n        d[r] = min(d[l], c[l])\n        b[r] = x[0]\n        r += 1\n    l += 1\nprint(n-cnt)", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\t\t\t\t\tdist[i] = dist[element] + w[(element,i)]\n\n\n\tdef bfs2(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\t\t\t\t\tminn[i] = min(minn[element], dist[i])\n\n\tdef bfs3(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\tcount = 0\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tcount += 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0 and remove[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\t\treturn count\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm += ans[i]\n\t\t\tans[element] = m\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef detect_cycle(self):\n\t\tindeg = [0]*self.n\n\t\tfor i in range(self.n):\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tindeg[j] += 1\n\t\tq = deque()\n\t\tvis = 0\n\t\tfor i in range(self.n):\n\t\t\tif indeg[i]==0:\n\t\t\t\tq.append(i)\n\t\twhile len(q)!=0:\n\t\t\te = q.popleft()\n\t\t\tvis += 1\n\t\t\tfor i in self.graph[e]:\n\t\t\t\tindeg[i] -= 1\n\t\t\t\tif indeg[i]==0:\n\t\t\t\t\tq.append(i)\n\t\tif vis!=self.n:\n\t\t\treturn True\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\nn = int(input())\na = list(map(int,input().split()))\ng = Graph(n,False)\nw = {}\nfor i in range(n-1):\n\tx,y = map(int,input().split())\n\tw[(i+1,x-1)] = y\n\tw[(x-1,i+1)] = y\n\tg.addEdge(i+1,x-1)\ndist = [0]*n\nminn = [0]*n\ng.bfs(0)\ng.bfs2(0)\nremove = [0]*n\nfor i in range(1,n):\n\tif dist[i]-minn[i]>a[i]:\n\t\tremove[i] = 1\n# print (dist)\n# print (minn)\n# print (remove)\nprint (n-g.bfs3(0))", "n = int(input())\na = [0] + list(map(int, input().split()))\ng = [list() for i in range(n+1)]\nfor i in range(2, n+1):\n    u, v = map(int, input().split())\n    g[i].append((u, v))\n    g[u].append((i, v))\nvis = [0] * (n+1)\nstk = [(1, 0, 0)]\nwhile stk:\n    v, min_d, dist = stk.pop()\n    vis[v] = 1\n    for u, c in g[v]:\n        if not vis[u]:\n            if dist + c - min(min_d, dist+c) <= a[u]:\n                stk.append((u, min(min_d, dist+c), dist+c))\nprint(n - vis.count(1))"]
["import numpy as np\n\n\ndef solve(n, m):\n    def prepare(n, m):\n        f = 1\n        for i in range(1, n + 1):\n            f = f * i % m\n        fn = f\n        inv = [1] * (n + 1)\n        f = pow(f, m - 2, m)\n        inv[n] = f\n        for i in range(n, 0, -1):\n            f = f * i % m\n            inv[i - 1] = f\n        return fn, inv\n\n    def a_x(a, x, m):\n        ret = 1\n        yield ret\n        for _ in range(x):\n            ret = ret * a % m\n            yield ret\n\n    fn, inv = prepare(n, m)\n\n    stir2 = np.zeros(n + 2, dtype=np.int64)\n    stir2[0] = 1\n    upd = np.arange(2, n + 3, dtype=np.int64)\n\n    ex2 = [2]\n    for i in range(n):\n        ex2.append(ex2[-1] ** 2 % m)\n\n    ans = 0\n    si = 1\n\n    for i in range(n+1):\n        nCi = fn * inv[i] * inv[n-i] % m\n        i_with = np.fromiter(a_x(pow(2, n-i, m), i, m), dtype=np.int64) \n        i_on = (stir2[ :i+1] * i_with % m).sum() % m\n        ans = (ans + nCi * i_on % m * ex2[n-i] % m * si) % m\n        stir2[1 : i+2] = (stir2[1 : i+2] * upd[ :i+1] + stir2[ :i+1]) % m\n        si *= -1\n\n    return ans\n\n\nN, M = list(map(int, input().split()))\nprint((solve(N, M)))\n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN,MOD = list(map(int,input().split()))\n\n\"\"\"\n\u4f59\u4e8b\u8c61\u3092\u8abf\u3079\u308b\u3002\u5305\u9664\u306e\u539f\u7406\u3092\u4f7f\u3046\u3002\nA[n] = \uff081,2,...,n\uff09\u304c1\u676f\u4ee5\u4e0b\u3001\u4ed6\u306f\u4f55\u3067\u3082\u826f\u3044\nB[n,l] : (1,2,...,n) \u3092l\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\u65b9\u6cd5\u306e\u500b\u6570\nA[n]\n\u30fb0\u676f\u306e\u30b0\u30eb\u30fc\u30d7\u3042\u308a\n\u30fb\u306a\u3057\n\"\"\"\n\nB = np.zeros((N+1,N+1), dtype=np.int64)\nB[0,0] = 1\nfor n in range(1,N+1):\n    # 1\u756a\u3092\u5358\u72ec\u3067\u4f7f\u3046\n    B[n,1:] = B[n-1,:-1]\n    # 1\u756a\u3092\u3069\u3053\u304b\u306b\u6df7\u305c\u3066\u3082\u3089\u3046\n    B[n,1:] += B[n-1,1:] * np.arange(1,N+1) % MOD\n    B[n] %= MOD\n\n# 2^{kl}\npow_2 = np.ones((N+1,N+1), dtype=np.int64)\nfor n in range(1,N+1):\n    pow_2[1,n] = 2 * pow_2[1,n-1] % MOD\nfor n in range(2,N+1):\n    pow_2[n] = pow_2[n-1] * pow_2[1] % MOD\n\nA = np.zeros(N+1, dtype=np.int64)\nfor n in range(N+1):\n    A[n] = (pow(2,pow(2,N-n,MOD-1),MOD) * B[n,1:] % MOD * (pow_2[N-n,1:] + pow_2[N-n,:-1] * np.arange(1,N+1) % MOD) % MOD).sum() % MOD\n\ncomb = np.zeros((N+1,N+1),dtype = np.int64)\ncomb[:,0] = 1\nfor n in range(1,N+1):\n    comb[n,1:] = (comb[n-1,1:] + comb[n-1,:-1]) % MOD\n\nA[::2] *= (-1)\nA *= comb[N]\nA %= MOD\nanswer = pow(2,pow(2,N,MOD-1),MOD) - A.sum()\nanswer %= MOD\nprint(answer)\n\n", "import numpy as np\n\n\ndef prepare(n, m):\n    f = 1\n    facts = [1]\n    for i in range(1, n + 1):\n        f = f * i % m\n        facts.append(f)\n\n    f = pow(f, m - 2, m)\n    invs = [1] * (n + 1)\n    invs[n] = f\n    for i in range(n, 0, -1):\n        f = f * i % m\n        invs[i - 1] = f\n\n    return facts, invs\n\n\ndef nik(n2, k, m):\n    ret = 1\n    yield ret\n    for _ in range(k):\n        ret = ret * n2 % m\n        yield ret\n\n\nn, m = list(map(int, input().split()))\n\nfacts, invs = prepare(n, m)\nfn = facts[n]\n\nnp_range = np.arange(2, n + 4, dtype=np.int64)\ndp = np.zeros(n + 2, dtype=np.int64)\ndp[0] = 1\n\nnn2 = [2]\nfor i in range(n):\n    nn2.append(nn2[-1] ** 2 % m)\n\nans = 0\nparity = 1\n\nfor i in range(n + 1):\n    n2 = pow(2, n - i, m)\n    coef = np.fromiter(nik(n2, i, m), dtype=np.int64)\n    ncr = fn * invs[i] * invs[n - i] % m\n    left = (dp[:i + 1] * coef % m).sum() % m\n    right = nn2[n - i]\n    ans = (ans + ncr * left % m * right % m * parity) % m\n    dp[1:i + 2] = (dp[1:i + 2] * np_range[:i + 1] + dp[:i + 1]) % m\n    parity *= -1\n\nprint(ans)\n", "import numpy as np\n\n\ndef prepare(n, m):\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i % m\n    fn = f\n    f = pow(f, m - 2, m)\n    invs = [1] * (n + 1)\n    invs[n] = f\n    for i in range(n, 0, -1):\n        f = f * i % m\n        invs[i - 1] = f\n\n    return fn, invs\n\n\ndef nik(n2, k, m):\n    ret = 1\n    yield ret\n    for _ in range(k):\n        ret = ret * n2 % m\n        yield ret\n\n\nn, m = list(map(int, input().split()))\n\nfn, invs = prepare(n, m)\nnp_range = np.arange(2, n + 3, dtype=np.int64)\ndp = np.zeros(n + 2, dtype=np.int64)\ndp[0] = 1\n\nnn2 = [2]\nfor i in range(n):\n    nn2.append(nn2[-1] ** 2 % m)\n\nans = 0\nparity = 1\n\nfor i in range(n + 1):\n    n2 = pow(2, n - i, m)\n    coef = np.fromiter(nik(n2, i, m), dtype=np.int64)\n    ncr = fn * invs[i] * invs[n - i] % m\n    left = (dp[:i + 1] * coef % m).sum() % m\n    ans = (ans + ncr * left % m * nn2[n - i] % m * parity) % m\n    dp[1:i + 2] = (dp[1:i + 2] * np_range[:i + 1] + dp[:i + 1]) % m\n    parity *= -1\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\nimport numpy as np\n\nN,MOD = map(int,input().split())\n\n\"\"\"\n\u4f59\u4e8b\u8c61\u3092\u8abf\u3079\u308b\u3002\u5305\u9664\u306e\u539f\u7406\u3092\u4f7f\u3046\u3002\nA[n] = \uff081,2,...,n\uff09\u304c1\u676f\u4ee5\u4e0b\u3001\u4ed6\u306f\u4f55\u3067\u3082\u826f\u3044\nB[n,l] : (1,2,...,n) \u3092l\u30b0\u30eb\u30fc\u30d7\u306b\u5206\u3051\u308b\u65b9\u6cd5\u306e\u500b\u6570\nA[n]\n\u30fb0\u676f\u306e\u30b0\u30eb\u30fc\u30d7\u3042\u308a\n\u30fb\u306a\u3057\n\"\"\"\n\nB = np.zeros((N+1,N+1), dtype=np.int64)\nB[0,0] = 1\nfor n in range(1,N+1):\n    # 1\u756a\u3092\u5358\u72ec\u3067\u4f7f\u3046\n    B[n,1:] = B[n-1,:-1]\n    # 1\u756a\u3092\u3069\u3053\u304b\u306b\u6df7\u305c\u3066\u3082\u3089\u3046\n    B[n,1:] += B[n-1,1:] * np.arange(1,N+1) % MOD\n    B[n] %= MOD\n\n# 2^{kl}\npow_2 = np.ones((N+1,N+1), dtype=np.int64)\nfor n in range(1,N+1):\n    pow_2[1,n] = 2 * pow_2[1,n-1] % MOD\nfor n in range(2,N+1):\n    pow_2[n] = pow_2[n-1] * pow_2[1] % MOD\n\npow_pow = np.zeros(N+1, dtype = np.int64)\npow_pow[0] = 2\nfor n in range(1,N+1):\n    pow_pow[n] = pow_pow[n-1] ** 2 % MOD\n\nA = (B[:,1:] * (pow_2[::-1,1:] + pow_2[::-1,:-1] * np.arange(1,N+1) % MOD) % MOD).sum(axis = 1)\nA %= MOD\nA *= pow_pow[::-1]\nA %= MOD\n\nfact = [1] * (N+1)\nfact_inv = [1] * (N+1)\nfor n in range(1,N+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv[N] = pow(fact[N],MOD-2,MOD)\nfor n in range(N,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\nfact = np.array(fact, dtype = np.int64)\nfact_inv = np.array(fact_inv, dtype = np.int64)\n\ncomb = fact_inv * fact_inv[::-1] % MOD * fact[N] % MOD\n\nA[::2] *= (-1)\nA *= comb\nA %= MOD\nanswer = pow(2,pow(2,N,MOD-1),MOD) - A.sum()\nanswer %= MOD\nprint(answer)", "import numpy as np\n\n\ndef solve(n, m):\n    def prepare(n, m):\n        f = 1\n        for i in range(1, n + 1):\n            f = f * i % m\n        fn = f\n        f = pow(f, m - 2, m)\n        invs = [1] * (n + 1)\n        invs[n] = f\n        for i in range(n, 0, -1):\n            f = f * i % m\n            invs[i - 1] = f\n\n        return fn, invs\n\n    def nik(n2, k, m):\n        ret = 1\n        yield ret\n        for _ in range(k):\n            ret = ret * n2 % m\n            yield ret\n\n    fn, invs = prepare(n, m)\n    np_range = np.arange(2, n + 3, dtype=np.int64)\n    dp = np.zeros(n + 2, dtype=np.int64)\n    dp[0] = 1\n\n    nn2 = [2]\n    for i in range(n):\n        nn2.append(nn2[-1] ** 2 % m)\n\n    ans = 0\n    parity = 1\n\n    for i in range(n + 1):\n        coef = np.fromiter(nik(pow(2, n - i, m), i, m), dtype=np.int64)\n        ncr = fn * invs[i] * invs[n - i] % m\n        left = (dp[:i + 1] * coef % m).sum() % m\n        ans = (ans + ncr * left % m * nn2[n - i] % m * parity) % m\n        dp[1:i + 2] = (dp[1:i + 2] * np_range[:i + 1] + dp[:i + 1]) % m\n        parity *= -1\n\n    return ans\n\n\nn, m = list(map(int, input().split()))\nprint((solve(n, m)))\n", "N, M = list(map(int, input().split()))\nfact = [1]*(N+1)\nrfact = [1]*(N+1)\nfor i in range(1, N+1):\n    fact[i] = r = (i * fact[i-1]) % M\n    rfact[i] = pow(r, M-2, M)\n\n\nmemo = {}\ndef f(N, K):\n    if (N, K) in memo:\n        return memo[N, K]\n    if K == 0:\n        return N == 0\n    elif K == 1 or N == K:\n        return 1\n    r = memo[N, K] = (f(N-1, K-1) + K*f(N-1, K)) % M\n    return r\n\nS = [1]\n\nrev2 = pow(2, M-2, M)\nbase = pow(2, N, M)\nans = 0\nS = [1]\nfor K in range(N+1):\n    r = (fact[N] * rfact[K] * rfact[N-K]) % M\n    r = (r * pow(2, pow(2, N - K, M-1), M)) % M\n    b = 1\n    v = 0\n    T = [0]*(K+2)\n    for L in range(K):\n        T[L+1] = s = (S[L] + (L+1)*S[L+1]) % M\n        v += s * b\n        b = (b * base) % M\n    v += b\n    T[K+1] = 1\n    S = T\n    r = (r * v) % M\n    if K % 2:\n        ans -= r\n    else:\n        ans += r\n    ans %= M\n\n    base = (base * rev2) % M\nprint(ans)\n", "import numpy as np\n\ndef prepare(n, m):\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i % m\n    fn = f\n    inv = [1] * (n + 1)\n    f = pow(f, m - 2, m)\n    inv[n] = f\n    for i in range(n, 0, -1):\n        f = f * i % m\n        inv[i - 1] = f\n    return fn, inv\n\ndef a_x(a, x, m):\n    ret = 1\n    yield ret\n    for _ in range(x):\n        ret = ret * a % m\n        yield ret\n\n\nN, M = list(map(int, input().split()))\n\nfn, inv = prepare(N, M)\n\n\nstir2 = np.zeros(N + 2, dtype=np.int64)\nstir2[0] = 1\nupd = np.arange(2, N + 3, dtype=np.int64)\n\nex2 = [2]\nfor i in range(N):\n    ex2.append(ex2[-1] ** 2 % M)\n\nans = 0\nsi = 1\n\nfor i in range(N+1):\n    nCi = fn * inv[i] * inv[N-i] % M\n    i_with = np.fromiter(a_x(pow(2, N-i, M), i, M), dtype=np.int64)\n    i_on = (stir2[ :i+1] * i_with % M).sum() % M\n    ans = (ans + nCi * i_on % M * ex2[N-i] % M * si) % M\n    stir2[1 : i+2] = (stir2[1 : i+2] * upd[ :i+1] + stir2[ :i+1]) % M\n    si *= -1\n\n\nprint(ans)\n", "N, M = list(map(int, input().split()))\nfact = [1]*(N+1)\nrfact = [1]*(N+1)\nfor i in range(1, N+1):\n    fact[i] = r = (i * fact[i-1]) % M\n    rfact[i] = pow(r, M-2, M)\n\nS = [1]\n\nrev2 = pow(2, M-2, M)\nbase = pow(2, N, M)\nans = 0\nS = [1]\nfor K in range(N+1):\n    res = (fact[N] * rfact[K] * rfact[N-K]) % M\n    res = (res * pow(2, pow(2, N - K, M-1), M)) % M\n    b = 1\n    v = 0\n    T = [0]*(K+2)\n    for L in range(K):\n        T[L+1] = s = (S[L] + (L+1)*S[L+1]) % M\n        v += s * b\n        b = (b * base) % M\n    v += b\n    T[K+1] = 1\n    S = T\n    res = (res * v) % M\n    if K % 2:\n        ans -= res\n    else:\n        ans += res\n    ans %= M\n\n    base = (base * rev2) % M\nprint(ans)\n"]
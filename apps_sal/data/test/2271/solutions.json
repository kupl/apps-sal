["n = int(input())\nd = n * [0]\n\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    d[a - 1] += 1\n    d[b - 1] += 1\n\ncnt = 0\nfor i in d:\n    cnt += (i * (i - 1)) // 2\n\nprint(cnt)\n", "n = int(input())\na = [0]*(n+1)\nfor _ in range(n-1):\n    x, y = input().split(' ')\n    x, y = [int(x), int(y)]\n    a[x] += 1\n    a[y] += 1\nto = 0\nfor x in a:\n    to += (x * (x-1))//2\nprint(to)", "n = int(input())\na = [0]*(n+1)\nfor _ in range(n-1):\n    x, y = input().split(' ')\n    x, y = [int(x), int(y)]\n    a[x] += 1\n    a[y] += 1\nto = 0\nfor x in a:\n    to += (x * (x-1))//2\nprint(to)", "n = int(input())\nm = n - 1\ncn = {}\nfor i in range(1, n+1):\n    cn[i] = set()\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    cn[a].add(b)\n    cn[b].add(a)\nans = 0\nfor i in range(1, n+1):\n    ans += sum(len(cn[c]) for c in cn[i]) - len(cn[i])\n\nprint(ans // 2)\n", "read = lambda: list(map(int, input().split()))\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    a, b = read()\n    g[a].append(b)\n    g[b].append(a)\n\ncnt = 0\nfor i in range(n + 1):\n    k = len(g[i])\n    cnt += k * (k - 1) // 2\nprint(cnt)\n", "n = int(input())\na = [0]*(n+1)\nfor _ in range(n-1):\n    x, y = input().split(' ')\n    x, y = [int(x), int(y)]\n    a[x] += 1\n    a[y] += 1\ntoo = 0\nfor x in a:\n    too += (x * (x-1))//2\nprint(too)\n", "n=int(input())\np=[[]]\nt=[0]\no=[[]]\nfor i in range(n):\n    p.append([])\n    t.append(0)\n    o.append([])\nfor i in range(n-1):\n    a=input().split()\n    b=int (a[0])\n    c=int(a[1])\n    p[b].append(c)\n    p[c].append(b)\n    t[b]+=1\n    t[c]+=1\ny=0\nfor i in range(1,n+1):\n    j=p[i]\n    for k in range(t[i]):\n        jj=j[k]\n        y=y+t[jj]-1\nprint(int(y/2))\n\n", "n = int(input())\ngraph = list() \nfor i in range(n):\n    graph.append(set())\nfor j in range(n - 1):\n    v1,v2  = list(map(int,input().split()))\n    graph[v1 - 1].add(v2)\n    graph[v2 - 1].add(v1)\nresult = 0\nfor k in range(n):\n    d = len(graph[k])\n    result += d*(d - 1)/2\nprint(int(result))\n", "def main():\n    n = int(input())\n    l = [0] * (n + 1)\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        l[a] += 1\n        l[b] += 1\n    res = 0\n    for x in l:\n        res += x * (x - 1)\n    print(res // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    n = int(input())\n    l = [-1] * (n + 1)\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        l[a] += 1\n        l[b] += 1\n    res = 0\n    for x in [_f for _f in l if _f]:\n        res += x * (x + 1)\n    print(res // 2)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#from random import randrange\n#import time\n \n#class Profiler(object):\n    #def __enter__(self):\n    #    self._startTime = time.time()\n         \n    #def __exit__(self, type, value, traceback):\n     #   print (\"Elapsed time: {:.10f} sec\".format(time.time() -self._startTime))\n\n#masa = [randrange(1, 10000) for i in range(10000)]\n#masb = [randrange(1, 10000) for i in range(10000)]\n\n  \ndef UpperBound(A, key): \n    left = -1 \n    right = len(A) \n    while right > left + 1: \n        middle = (left + right) // 2 \n        if A[middle] > key: \n            right = middle \n        else: \n            left = middle\n \n    return right\nn=int(input())\nmasa=[]\nmasb=[]\nmas=[]\nfor i in range(n-1):\n   mas.append(input().split())\ns=0 \n#with Profiler() as p:\n   # mas= [(100, 67), (1, 2), (4, 5)]\nfor i in range(n-1):\n    masa.append(int(mas[i][0]))\n    masb.append(int(mas[i][1]))\n#with Profiler() as p:\n   #masa=sorted(masa, key=lambda x: x[:-1])\nmasa.sort()\nmasb.sort()\n#with Profiler() as p:\n  #for i in range(1000):\n   # masb[i]\n   #masa=[1,1,1]\n   #masb=[3,4,2]\n   \n    #print(UpperBound(ma, 2))  #return 4\nfor i in range(len(masb)):\n      foun=UpperBound(masa,masb[i])\n      xx=masa[i:foun].count(masb[i])\n      s=s+xx\n      #print(xx)\n   #print(s)\nfor i in range(len(masa)):   \n      foun=UpperBound(masa,masa[i])\n      xx=masa[i+1:foun].count(masa[i])\n      s=s+xx\n      #print(xx)\nfor i in range(len(masa)): \n      foun=UpperBound(masb,masa[i]) \n      xx=masb[i+1:foun].count(masa[i])   \n      s=s+xx\nfor i in range(len(masb)):   \n      foun=UpperBound(masb,masb[i])\n      xx=masb[i+1:foun].count(masb[i])\n      s=s+xx\n\nprint(s)", "I=input\nd=[0]*10010\nfor _ in '0'*(int(I())-1):x,y=map(int,I().split());d[x]+=1;d[y]+=1\nprint(sum(i*(i-1)for i in d)//2)", "n = int(input())\ndeg = [0 for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    deg[a] += 1\n    deg[b] += 1\nans = 0\nfor x in deg:\n    ans += x * (x - 1) // 2\nprint(ans)\n", "n = int(input())\nt = [0] * n\nfor _ in range(n-1):\n\ta, b = input().split(' ')\n\ta, b = [int(a), int(b)]\n\tt[a-1] += 1\n\tt[b-1] += 1\nout = [(e * (e-1)) / 2 for e in t]\nprint(int(sum(out)))\n", "n = int(input())\nt = [0] * n\nout = 0\nfor _ in range(n-1):\n\ta, b = input().split(' ')\n\ta, b = [int(a), int(b)]\n\tt[a-1] += 1\n\tt[b-1] += 1\nfor x in t:\n\tout += x * (x-1) / 2\nprint(int(out))\n", "import sys\n#with open(filename, 'r') as f:\nwith sys.stdin as f:\n    for i, line in enumerate(f):\n        if i == 0:\n            N = int(line)\n            graph = [[] for _ in range(N)] # [[]] * N not working, no deepcopy\n        else:\n            fromVertex, toVertex = line.split(' ')\n            fromVertex, toVertex = int(fromVertex)-1, int(toVertex)-1\n            graph[fromVertex].append(toVertex)\n            graph[toVertex].append(fromVertex)\n\nnb_paths = 0\nfor i in range(N):\n    degr = len(graph[i])\n    nb_paths += int((degr*(degr-1))/2)\nprint(nb_paths)", "d = {}\nfor i in range(int(input()) - 1):\n    for q in input().split(): d[q] = d.get(q, 0) + 1\nprint(sum(k * k - k for k in d.values()) // 2)", "def computeDegrees(n):\n    degrees = [0 for vertex in range(n)]\n    for edge in range(n-1):\n        v1, v2 = list(map(int, input().split()))\n        degrees[v1-1] += 1\n        degrees[v2-1] += 1\n    return degrees\n\ndef computeNumberOfLength2Paths(degrees, n):\n    return int(sum(d**2 for d in degrees)/2 - n + 1)\n\n\ndef __starting_point():\n    n = int(input())\n    degrees = computeDegrees(n)\n    print(computeNumberOfLength2Paths(degrees, n))\n\n__starting_point()", "def computeDegrees(n):\n    degrees = [0 for vertex in range(n)]\n    for edge in range(n-1):\n        v1, v2 = list(map(int, input().split()))\n        degrees[v1-1] += 1\n        degrees[v2-1] += 1\n    return degrees\n\ndef computeNumberOfLength2Paths(degrees):\n    return int( sum(d*(d-1) for d in degrees)/2 )\n\n\ndef __starting_point():\n    n = int(input())\n    degrees = computeDegrees(n)\n    print(computeNumberOfLength2Paths(degrees))\n\n__starting_point()", "n=int(input())\nL=[]\nS=0\nfor k in range(n):\n    L.append(0)\nfor k in range(n-1):\n    a,b=list(map(int,input().split()))\n    L[a-1]+=1\n    L[b-1]+=1\nfor k in range(n):\n    S+=L[k]*(L[k]-1)/2\nprint(int(S))\n", "n = int(input())\nbounds_amount = [-1]*n\nfor _ in range(n-1):\n    for el in map(int, input().split(' ')): bounds_amount[el-1] += 1\nprint(sum(map(lambda x: (x*(x+1))//2, bounds_amount)))", "n = int(input())\nd = [0] * (n + 1)\nfor _ in range(n - 1):\n  x, y = list(map(int, input().split()))\n  d[x] += 1\n  d[y] += 1\ns = 0\nfor x in range(1, n + 1):\n  s += d[x] * (d[x] - 1)\nprint(s // 2)\n", "a=int(input());b=[0]*(a+1)\nfor _ in \" \"*(a-1):u,v=map(int,input().split());b[u]+=1;b[v]+=1\nprint(sum((i*(i-1))//2 for i in b))"]
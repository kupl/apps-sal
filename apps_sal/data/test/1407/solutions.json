["maxn = 100100\nar = [1 for i in range(maxn)]\nar[0], ar[1] = 0, 0\n\nfor i in range(2, maxn):\n  if ar[i]:\n    for j in range(i, (maxn - 1) // i + 1):\n      ar[i * j] = 0\n\ndst = maxn\nd = [dst for i in range(maxn)]\n\nfor i in reversed(list(range(maxn))):\n  if ar[i]: dst = 0\n  d[i] = min(d[i], dst)\n  dst += 1\n\nn, m = list(map(int, input().split()))\ng = [[int(x) for x in input().split()] for _ in range(n)]\ng = [[d[x] for x in y] for y in g]\ntmpsharon = min([sum(x) for x in g] + [sum(x) for x in zip(*g)])\nprint(tmpsharon)\n\n", "3\n\nn, m = tuple(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\n\nsimple = [0] * (10**5 + 4)\nsimple[1] = 1\nfor i in range(2, 10**5 + 4):\n    if simple[i] == 0:\n        j = 2\n        while i * j < 10**5 + 4:\n            simple[i * j] = 1\n            j += 1\nsimple[-1] = len(simple) - 1\nfor i in range(10**5 + 2, 0, -1):\n    if simple[i] == 1:\n        simple[i] = simple[i + 1]\n    else:\n        simple[i] = i\nrow = [0] * n\ncol = [0] * m\nfor i in range(n):\n    for j in range(m):\n        row[i] += simple[a[i][j]] - a[i][j]\n        col[j] += simple[a[i][j]] - a[i][j]\nprint(min(row + col))\n", "def f(n):\n    m = int(n ** 0.5) + 1\n    t = [1, 0] * (n // 2 + 1)\n    t[0], t[1], t[2] = 1, 1, 0 \n    for i in range(3, m):\n        if t[i] == 0: t[i * i :: 2 * i] = [1] * ((n - i * i) // (2 * i) + 1)\n    for i in range(n - 1, -1, -1):\n        if t[i]: t[i] = t[i + 1] + 1\n    return t\n\nq = f(100007)\nn, m = list(map(int, input().split()))\nt = [[q[j] for j in map(int, input().split())] for i in range(n)]\n        \nprint(min(min(sum(t[i]) for i in range(n)), min(sum(t[i][j] for i in range(n)) for j in range(m))))  \n", "import bisect\n\nfrom math import sqrt\n\nmaxn = int(1e5 + 50)\nisprime = [1 for i in range(maxn+1)]\n\nd =  [1E9 for i in range(maxn+1)]\n\ndef sieve():\n    cross_limit = int(sqrt(maxn))\n    isprime[0] = isprime[1]= 0\n    for i in range(4, maxn+1, 2):\n        isprime[i] = 0\n    for i in range(3, cross_limit+1, 2):\n        if isprime[i]:\n            for j in range(i*i, maxn+1, 2*i):\n                isprime[j] = 0\n\nsieve()\n\ndst = 0\nfor i in range(maxn, 0, -1):\n    if isprime[i]: dst = 0\n    d[i] = min(d[i], dst)\n    dst += 1\n\nn, m = list(map(int, input().split()))\nmatrix = [list(map(int, input().split())) for i in range(n)]\n\nrows = (sum([d[x] for x in matrix[i]]) for i in range(n))\ncolumn = (sum((d[matrix[i][j]] for i in range(n))) for j in range(m))\n\nprint(min(min(rows), min(column)))\n\n\n", "def is_prime(x, primes):\n\tfor i in primes:\n\t\tif i * i > x:\n\t\t\tbreak\n\t\tif x % i == 0:\n\t\t\treturn False\n\treturn True\n\nn, m = [int(x) for x in input().split()]\na = []\nprimes = []\nfor i in range(2, 110000):\n\tif is_prime(i, primes):\n\t\tprimes.append(i)\nnext = [0] * 110000\nnext[0] = 2\nfor x in primes:\n\tval = x\n\twhile next[x] == 0:\n\t\tnext[x] = val\n\t\tx -= 1\nfor i in range(n):\n\ta.append([int(x) for x in input().split()])\nfor i in range(n):\n\tfor j in range(m):\n\t\ta[i][j] = next[a[i][j]] - a[i][j]\nprint(min(min(sum(x) for x in a), min(sum(x) for x in zip(*a))))\n", "from bisect import bisect_left\n\n\ndef genprimes(limit):\n    lim = limit // 6\n    sieve = [False, True, True] * lim\n    lim = lim * 3 - 1\n    for i, s in enumerate(sieve):\n        if s:\n            p, pp = i * 2 + 3, (i + 3) * i * 2 + 3\n            le = (lim - pp) // p + 1\n            if le > 0:\n                sieve[pp::p] = [False] * le\n            else:\n                break\n    sieve[0] = sieve[3] = True\n    res = [i * 2 + 3 for i, f in enumerate(sieve) if f]\n    res[:4] = [2, 3, 5, 7]\n    return res\n\n\ndef main():\n    primes = genprimes(100004)\n    n, m = list(map(int, input().split()))\n    res = [0] * m\n    for y in range(n):\n        rw = 0\n        for x, z in enumerate(map(int, input().split())):\n            p = primes[bisect_left(primes, z)] - z\n            res[x] += p\n            rw += p\n        res.append(rw)\n    print(min(res))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from bisect import bisect_left\n\ndef sieve(r):\n    D = dict()\n    yield 2\n    for q in range(3,r,2):\n        p = D.pop(q, None)\n        if not p:\n            D[q*q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not (x&1):\n                x += p\n            D[x] = p\n\nprimes = list(sieve(1000003))\nII = lambda: list(map(int, input().split()))\nn,m = II()\ngrid = [[primes[bisect_left(primes, x)] - x for x in II()] for _ in range(n)]\nprint(min(min(sum(row) for row in grid), min(sum(col) for col in zip(*grid))))\n", "def buil_prime_dict(n):\n    a =[x for x in range(n+1)]\n    a[1] = 0\n    lst = []\n    \n    i = 2\n    while i <= n:\n        if a[i] != 0:\n            lst.append(a[i])\n            for j in range(i, n+1, i):\n                a[j] = 0\n        i += 1\n    return lst\n    \nprime_dict=buil_prime_dict(10**5+100)\n\ndef diff_search_number_prime(a,dictionary):\n    start_ind=0\n    stop_ind=len(dictionary)-1\n    if a == 1:\n        return 1\n    while (stop_ind-start_ind)!=1:\n        middle_ind=(stop_ind-start_ind)//2+start_ind\n        if a==dictionary[middle_ind] or a==dictionary[start_ind] or a==dictionary[stop_ind]:\n            return 0\n        elif a>dictionary[middle_ind]:\n            start_ind=middle_ind\n        else:\n            stop_ind=middle_ind\n    return abs(a-dictionary[stop_ind])\n\nline1=input()\nn=int(line1.split(' ')[0])\nm=int(line1.split(' ')[1])\nmatrix=[]\nmax_num=0\nfor j in range(n):\n    line2=input()\n    d=[int(x) for x in line2.split(' ')]\n    matrix.append(d)\n    if max_num<max(d):\n        max_num=max(d)\ndict_dist=[0,1]\nfor i in range(2,max_num+1):\n    dict_dist.append(diff_search_number_prime(i,prime_dict))\n\nmatrix=[[dict_dist[y] for y in i]for i in matrix]  \nresults=[]\nfor x in matrix:\n    results.append(sum(x))\nfor x in zip(*matrix):\n    results.append(sum(x))\nprint(min(results))\n", "def buil_prime_dict(n):\n    lst=[0,0]+[1]*n   \n    for i in range(2,n):\n        if lst[i]:\n            for j in range(i*i,n,i):\n                lst[j]=0\n    for k in range(n,-1,-1):\n        if lst[k]:\n            ind=k\n            lst[k]=0\n        else:\n            lst[k]=ind-k\n    return lst\n    \nprime_dict=buil_prime_dict(10**5+100)\n\n#def diff_search_number_prime(a,dictionary):\n#    start_ind=0\n#    stop_ind=len(dictionary)-1\n#    if a == 1:\n#        return 1\n#    while (stop_ind-start_ind)!=1:\n#        middle_ind=(stop_ind-start_ind)//2+start_ind\n#        if a==dictionary[middle_ind] or a==dictionary[start_ind] or a==dictionary[stop_ind]:\n#            return 0\n#        elif a>dictionary[middle_ind]:\n#            start_ind=middle_ind\n#        else:\n#            stop_ind=middle_ind\n#    return abs(a-dictionary[stop_ind])\n\nline1=input()\nn=int(line1.split(' ')[0])\nm=int(line1.split(' ')[1])\nmatrix=[]\nmax_num=0\nfor j in range(n):\n    line2=input()\n    d=[int(x) for x in line2.split(' ')]\n    matrix.append(d)\n\nmatrix=[[prime_dict[y] for y in i]for i in matrix]  \nresults=[]\nfor x in matrix:\n    results.append(sum(x))\nfor x in zip(*matrix):\n    results.append(sum(x))\nprint(min(results))", "nearest_prime = [0] * 100004\n\ndef sieve(n):\n    primes = [True] * (n + 1)\n    primes[0] = False\n    primes[1] = False\n    for index, i in enumerate(primes):\n        if i == True:\n            for j in range(index * index, n + 1, index):\n                primes[j] = False\n    return primes\n\ndef sub_from_nearest(a):\n    return nearest_prime[a] - a\n\ndef main():\n    m,n = [int(x) for x in input().split()]\n    prime_bool = sieve(100003)\n    nearest = -1\n    for i, bool in (list(enumerate(prime_bool)))[::-1]:\n        if bool:\n            nearest = i\n            nearest_prime[i] = i\n        else:\n            nearest_prime[i] = nearest\n    matrix = []\n    for i in range(0, m):\n        lis = [sub_from_nearest(int(x)) for x in input().split()]\n        matrix.append(lis)\n    min = 10000000\n    for i in matrix:\n        su = sum(i)\n        if su < min:\n            min = su\n    for i in range(0, n):\n        su = sum([row[i] for row in matrix])\n        if su < min:\n            min = su\n    print(min)\ndef __starting_point():\n    main()\n\n__starting_point()", "#python3\nimport sys, threading, os.path\nimport collections, heapq, math,bisect\nimport string\nfrom platform import python_version\nimport itertools\nsys.setrecursionlimit(10**6)\nthreading.stack_size(2**27)     \n\ndef generate_primes(n):\n    res = []\n    isPrime = [True]*(n*5)\n    isPrime[0],isPrime[1] = 0,0\n    '''\n    for (ll i = 2; i*i <= n+1; ++i) {\n        if (isPrime[i]) {\n            for (ll j = i * 2; j <= n; j += i)\n                isPrime[j] = 0;\n        }\n    }\n    '''\n    for i in range(2,n+1):\n        if i*i >n+1:\n            break\n        if isPrime[i]:\n            for j in range(i*2,n+1,i):\n                isPrime[j]=0\n\n    res.append(2)\n    for i in range(3,n+1,2):\n        if isPrime[i]:\n            res.append(i)\n    return res;\n\n\ndef main():\n    if os.path.exists('input.txt'):\n        input = open('input.txt', 'r')\n    else:\n        input = sys.stdin\n    #--------------------------------INPUT---------------------------------\n    n,m = list(map(int, input.readline().split()))\n    mat = []\n    for i in range(n):\n        mat.append(list(map(int, input.readline().split())))\n    allprimes = generate_primes(150000)\n    #print(allprimes)\n    tostore = []\n    for i in range(n):\n        tostore.append([])\n        for j in range(m):\n            x = bisect.bisect(allprimes, mat[i][j])\n            if allprimes[x-1]==mat[i][j]:\n                tostore[i].append(0)\n            else:\n                tostore[i].append(abs(mat[i][j]-allprimes[x]))\n    '''\n    for i in range(n):\n        for j in range(m):\n            print(tostore[i][j], end=\" \")\n        print()\n    ''' \n    \n    rowsum,colsum = [0]*501,[0]*501\n    for i in range(n):\n        for j in range(m):\n            rowsum[i]+=tostore[i][j]\n            colsum[j]+=tostore[i][j]\n    #print(rowsum[:n])\n    #print(colsum[:m])\n    minone = min(min(rowsum[:n]),min(colsum[:m]))    \n    output = minone\n    #-------------------------------OUTPUT----------------------------------\n    if os.path.exists('output.txt'):\n        open('output.txt', 'w').writelines(str(output))\n    else:\n        sys.stdout.write(str(output))\n\n\ndef __starting_point():\n    main()\n#threading.Thread(target=main).start()\n\n__starting_point()", "import sys;\n\nclass MyReader:\n#    file = null;\n    def __init__(self):\n        filename = \"file.in\";\n        if self.isLocal():\n            self.file = open(filename);\n        self.str = [\"\"];\n        self.ind = 1;\n            \n    def isLocal(self):\n        return len(sys.argv) > 1 and sys.argv[1] == \"SCHULLZ\";\n\n    def nextString(self):\n        if self.isLocal():\n            return self.file.read();\n        else:\n            return input();\n        \n    def nextInt(self):\n        return int(self.nextToken());\n\n    def nextToken(self):\n        if (self.ind >= len(self.str)):\n            self.ind = 0;\n            self.str = self.nextString().split();\n        self.ind += 1;\n        return self.str[self.ind - 1];\n\n\n\nrdr = MyReader();\n\nn = rdr.nextInt();\nm = rdr.nextInt();\n\n\na = [[0 for x in range(m)] for y in range(n)] \n\n\n\nfor i in range(0, n):\n    for j in range(0, m):\n        a[i][j] = rdr.nextInt();\n\nwas = [];\nMX = 200500;\nfor i in range(0, MX):\n    was.append(False);\n\nfor i in range(2, MX):\n    if was[i] == False:\n        for j in range(i + i, MX, i):\n            was[j] = True;\nwas[1] = True;\nwas[0] = True;\nnxt = [];\nfor i in range(0, MX):\n    nxt.append(-1);\n\nprev = -1;\nfor i in range(MX - 1, -1, -1):\n    if was[i] == False:\n        prev = i;\n    nxt[i] = prev;\n\n    \nres = MX * 505;\n\nfor i in range(0, n):\n    tres = 0;\n    for j in range(0, m):\n        tres += nxt[a[i][j]] - a[i][j];\n    res = min(res, tres);\n    \nfor j in range(0, m):\n    tres = 0;\n    for i in range(0, n):\n        tres += nxt[a[i][j]] - a[i][j];\n    res = min(res, tres);\n\nassert(res != MX * 505);\nprint(res);\n\n", "def sieve(mx):\n    a = [0] * (mx + 1)\n    a[0] = a[1] = 1\n    for (i, e) in enumerate(a):\n        if e == 0:\n            for n in range(i*i, mx + 1, i):\n                a[n] = 1\n    return a\n\np = sieve(10**5 + 100)\nfor i in range(10**5 + 99, 0, -1):\n    p[i] *= p[i+1] +1\n\nn,m = map(int, input().split())\n\ncols = [0]*m\n\nmm = 10**7\nfor i in range(n):\n    row = list(map(int, input().split()))\n    row_sum = 0\n    for a, j in enumerate(row):\n        tt = p[j]\n        row_sum += tt\n        cols[a] += tt\n    mm = min(mm, row_sum)\n\nprint(min(min(cols), mm))", "import heapq\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter\nfrom itertools import accumulate\n\nimport math\n\nR = lambda: list(map(int, input().split()))\n\ndef is_prime(num):\n    return not any([num % i == 0 for i in range(2, int(math.sqrt(num) + 1))])\n\nn, m = R()\ngrid = [list(R()) for i in range(n)]\nprimes = [x for x in range(2, 10**5 + 100) if is_prime(x)]\nfor i in range(n):\n    for j in range(m):\n        grid[i][j] = primes[bisect_left(primes, grid[i][j])] - grid[i][j]\nmin_row = min([sum(r) for r in grid])\nmin_col = min([sum(c) for c in zip(*grid)])\nprint(min(min_row, min_col))\n\n", "import sys,math\nisprime = [0]*1000010\nall_prime = [2]\nnext_prime = [0]*1000010\ndef seive():\n    isprime[1] = isprime[0] = 1\n    limit = int(math.sqrt(1000010))+2\n    for i in range(4,1000010,2):\n        isprime[i] = 1\n    for i in range(3,1000010,2):\n        if(not isprime[i]):\n            all_prime.append(i)\n            if(i <= limit):\n                for j in range(i*i,1000010,i*2):\n                    isprime[j] = 1\nseive()\nprime = 0\nfor i in range(1000000):\n    next_prime[i] = all_prime[prime]\n    if(all_prime[prime] == i):\n        prime+=1\nr,c = map(int,input().split())\ninput_matrix = []\nmove = []\nfor i in range(r):\n    temp = list(map(int,input().split()))\n    input_matrix.append(temp)\nfor i in range(r):\n    co = 0\n    for j in range(c):\n        co+= next_prime[input_matrix[i][j]] - input_matrix[i][j]\n    move.append(co)\nfor i in range(c):\n    co = 0\n    for j in range(r):\n        co+= next_prime[input_matrix[j][i]] - input_matrix[j][i]\n    move.append(co)\nprint(min(move))", "import sys,math\nisprime = [0]*1000010\nall_prime = [2]\nnext_prime = [0]*1000010\ndef seive():\n    isprime[1] = isprime[0] = 1\n    limit = int(math.sqrt(1000010))+2\n    for i in range(4,1000010,2):\n        isprime[i] = 1\n    for i in range(3,1000010,2):\n        if(not isprime[i]):\n            all_prime.append(i)\n            if(i <= limit):\n                for j in range(i*i,1000010,i*2):\n                    isprime[j] = 1\nseive()\nprime = 0\nfor i in range(1000000):\n    next_prime[i] = all_prime[prime]\n    if(all_prime[prime] == i):\n        prime+=1\nr,c = map(int,input().split())\ninput_matrix = []\nmove = []\nfor i in range(r):\n    temp = list(map(int,input().split()))\n    input_matrix.append(temp)\nfor i in range(r):\n    co = 0\n    for j in range(c):\n        co+= next_prime[input_matrix[i][j]] - input_matrix[i][j]\n    move.append(co)\nfor i in range(c):\n    co = 0\n    for j in range(r):\n        co+= next_prime[input_matrix[j][i]] - input_matrix[j][i]\n    move.append(co)\nprint(min(move))", "def f(n):\n\n    m = int(n ** 0.5) + 1\n\n    t = [1, 0] * (n // 2 + 1)\n\n    t[0], t[1], t[2] = 1, 1, 0 \n\n    for i in range(3, m):\n\n        if t[i] == 0: t[i * i :: 2 * i] = [1] * ((n - i * i) // (2 * i) + 1)\n\n    for i in range(n - 1, -1, -1):\n\n        if t[i]: t[i] = t[i + 1] + 1\n\n    return t\n\n\n\nq = f(100007)\n\nn, m = list(map(int, input().split()))\n\nt = [[q[j] for j in map(int, input().split())] for i in range(n)]\n\n        \n\nprint(min(min(sum(t[i]) for i in range(n)), min(sum(t[i][j] for i in range(n)) for j in range(m))))  \n\n\n\n\n\n# Made By Mostafa_Khaled\n", "p=10**5+10\ndef sieve():\n    l=[True]*p \n    i=2 \n    while i*i<=p:\n        if l[i]:\n            for j in range(i*i,p,i):\n                l[j]=False \n        i+=1\n    primes=[]\n    for i in range(2,p):\n        if l[i]:\n            primes.append(i)\n    return primes \nprimes=sieve()\nfrom bisect import bisect_left as bl \nn,m=list(map(int,input().split()))\nreq=[[0 for i in range(m)]for j in range(n)]\n\nmat=[]\nfor i in range(n):\n    mat.append([int(i) for i in input().split()])\nfor i in range(n):\n    for j in range(m):\n        curr=mat[i][j] \n        ind=bl(primes,curr) \n        g=primes[ind] \n        req[i][j]=g-curr \n#print(req)\nmini=1000000000\nfor i in range(n):\n    curr=sum(req[i])\n    if curr<mini:\n        mini=curr \nfor j in range(m):\n    curr=0\n    for i in range(n):\n        curr+=req[i][j]\n    if curr<mini: mini=curr \nprint(mini)\n", "\n# -*- coding: utf-8 -*-\n# @Date    : 2019-02-08 08:18:25\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nfrom sys import stdin\n\nmax_val=int(10e12)\nmin_val=int(-10e12)\n\ndef read_int()     : return int(stdin.readline())\ndef read_ints()    : return [int(x) for x in stdin.readline().split()]\ndef read_str()     : return input()\ndef read_strs()    : return [x for x in stdin.readline().split()]\n\nlimit = 110000\nprimes = [0, 0] + [1] * limit\nfor i in range(2, limit):\n    if primes[i]:\n        for j in range(i * i, limit, i): primes[j] = 0\n\nu = limit\nfor i in reversed(range(limit)):\n    if primes[i]: u = i\n    primes[i] = u - i\n\nn, m = [int(x) for x in input().split()]\nmatrix=[[int(x) for x in input().split()] for _ in range(n)]\nmaxs = 10 ** 10\nfor v in matrix:\n    maxs = min(maxs,sum([primes[x] for x in v]))\nfor v in zip(*matrix):\n    maxs = min(maxs,sum([primes[x] for x in v]))\nprint(maxs)", "n, m = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\n\nisPrime = [False, False] + [True] * 101000\nfor i in range(2, len(isPrime)):\n    if isPrime[i]:\n        for j in range(i*i, len(isPrime), i):\n            isPrime[j] = False\n\nnextPrime = [0] * len(isPrime)\nfor i in range(len(isPrime) - 2, 0, -1):\n    if isPrime[i]:\n        nextPrime[i] = i\n    else:\n        nextPrime[i] = nextPrime[i+1]\n\nrow_scores = [0] * n\ncol_scores = [0] * m\nfor i in range(n):\n    for j in range(m):\n        row_scores[i] += nextPrime[a[i][j]] - a[i][j]\n        col_scores[j] += nextPrime[a[i][j]] - a[i][j]\nprint(min(row_scores + col_scores))\n", "m = 10**5+5\ncri = [0]*m\npri = []\nfor i in range(2, m):\n\tif cri[i] == 0:\n\t\tcri[i] = 1\n\t\tpri.append(i)\n\t\tfor j in range(i, m, i):\n\t\t\tcri[j] = 1\ndp = [0] * m\nfor a in range(len(pri)-1):\n\tpa, pb = pri[a], pri[a+1]\n\tfor i in range(pa+1, pb):\n\t\tdp[i] = pb-i\ndp[0] = 2\ndp[1] = 1\n# print(dp[:10])\nn, m = list(map(int, input().split()))\nmat = [[dp[int(x)] for x in input().split()] for _ in range(n)]\nres = min(sum(col) for col in mat)\nfor i in range(1, n):\n\tfor j in range(m):\n\t\tmat[0][j] += mat[i][j]\nprint(min(min(mat[0]), res))\n", "n, m = list(map(int, input().split()))\narr = [list(map(int, input().split())) for _ in range(n)]\n\nN = int(1e5+4)\nis_prime = [0] * N\nis_prime[0] = is_prime[1] = 1\nfor i in range(2, N):\n    if is_prime[i] == 1: continue\n    for j in range(i*2, N, i):\n        is_prime[j] = 1\nis_prime[-1] = N - 1\nfor i in range(N-2, 0, -1):\n    if is_prime[i] == 1:\n        is_prime[i] = is_prime[i + 1]\n    else:\n        is_prime[i] = i\nr, c = [0] * n, [0] * m\nfor i in range(n):\n    for j in range(m):\n        r[i] += is_prime[arr[i][j]] - arr[i][j]\n        c[j] += is_prime[arr[i][j]] - arr[i][j]\nprint(min(r + c))\n", "nearest_prime=[0]*(int(1e5+1))\nnearest_prime[0]=2\nnearest_prime[1]=1\nprime_bool=[0]*(int(1e5+1))\n\ndef is_prime(n):\n\tfor i in range(2,int(n**0.5)+1):\n\t\tif n%i==0:\n\t\t\treturn False\n\treturn True\n\na=[]\n\nfor i in range(2,int(1e5)+1):\n\tif is_prime(i):\n\t\ta.append(i)\n\t\tprime_bool[i]=1\n\nfor i in range(100001,1000001):\n\tif is_prime(i):\n\t\ta.append(i)\n\t\tbreak\n\nnp=a[-1]\nfor i in range(int(1e5),1,-1):\n\tif prime_bool[i]:\n\t\tnearest_prime[i]=0\n\t\tnp=i\n\telse:\n\t\tnearest_prime[i]=np-i\n\n#print(nearest_prime[:10])\n\nans=1e9\nn,m=list(map(int,input().split()))\narr=[]\nfor i in range(n):\n\tarr.append(list(map(int,input().split())))\n\nfor i in range(n):\n\treq=0\n\tfor j in range(m):\n\t\treq+=nearest_prime[arr[i][j]]\n#\tprint(\"row\",i,req)\n\tans=min(ans,req)\n\nfor i in range(m):\n\treq=0\n\tfor j in range(n):\n\t\treq+=nearest_prime[arr[j][i]]\n#\tprint(\"col\",i,req)\n\tans=min(ans,req)\n\nprint(ans)\n", "import math\nimport sys,string,bisect\ninput=sys.stdin.readline\nfrom collections import deque,defaultdict\nL=lambda : list(map(int,input().split()))\nLs=lambda : list(input().split())\nM=lambda : list(map(int,input().split()))\nI=lambda :int(input())\ndef find_ge(a, x):\n    'Find leftmost item greater than or equal to x'\n    i = bisect.bisect_left(a, x)\n    if i != len(a):\n        return a[i]\n    raise ValueError\nMAX_SIZE = 1000005\nisprime = [True] * MAX_SIZE  \nprime = []  \nSPF = [None] * (MAX_SIZE)\ndef manipulated_seive(N):  \n    isprime[0] = isprime[1] = False\n  \n    for i in range(2, N):  \n        if isprime[i] == True:  \n          \n            # put i into prime[] vector  \n            prime.append(i)  \n\n            SPF[i] = i  \n\n        j = 0\n        while (j < len(prime) and i * prime[j] < N and prime[j] <= SPF[i]): \n            isprime[i * prime[j]] = False\n            SPF[i * prime[j]] = prime[j] \n            j += 1\nmanipulated_seive(MAX_SIZE)\nn,m=M()\ng=[]\nf=[0]*m\nmi=MAX_SIZE\nfor i in range(n):\n    l=L()\n    for k in range(m):\n        l[k]=find_ge(prime,l[k])-l[k]\n        f[k]+=l[k]\n    g.append(l)\n    r=sum(l)\n    if(r<mi):\n        mi=r\nprint(min(min(f),mi))\n", "import bisect\ndef sieve(n):\n    p = 2\n\n    prime = [True for i in range(n+1)]\n    while p*p<=n:\n        if prime[p] ==True:\n            for i in range(p*p,n+1,p):\n                prime[i] = False\n        p+=1\n    c = []\n    for p in range(2,n):\n        if prime[p]:\n            c.append(p)\n    return c\ndef transpose(a,n,m):\n    c = []\n    for i in range(max(n,m)):\n        l = []\n        for j in range(max(n,m)):\n            try:\n                l.append(a[j][i])\n            except:\n                pass\n        c.append(l)\n    c = c[:m]\n    return c\ndef calcost(a,c):\n    cost = 0\n    for i in range(len(a)):\n        p = bisect.bisect_left(c,a[i])\n        cost+=(c[p]-a[i])\n    return cost\nc = sieve(1000001)\nn,m = list(map(int,input().split()))\nl = []\nfor i in range(n):\n    a = list(map(int,input().split()))\n    l.append(a)\ncost = []\nfor i in range(len(l)):\n    cost.append(calcost(l[i],c))\nl = transpose(l,n,m)\nfor i in range(len(l)):\n    cost.append(calcost(l[i],c))\nprint(min(cost))\n"]
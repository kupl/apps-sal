["from collections import deque\n\nn, b = map(int, input().split())\n\nq = deque()\nfor _ in range(n):\n    t, d = map(int, input().split())\n    while q and q[0] <= t:\n        q.popleft()\n    if len(q) == b + 1:\n        print(-1, end = ' ')\n    else:\n        if q:\n            t = q[-1]\n        print(t + d, end = ' ')\n        q.append(t + d)\n", "n, b = map(int, input().split())\n\nfrom collections import deque\n\nq = deque()\n\nfor i in range(n):\n    t, d = map(int, input().split())\n    while len(q) > 0 and q[0] <= t:\n        q.popleft()\n    if len(q) <= b:\n        r = t if len(q) == 0 else q[-1]\n        print(r + d, end = ' ')\n        q.append(r + d)\n    else:\n        print(-1, end = ' ')\n    \n", "import sys\nfrom collections import deque\n# sys.stdin = open(\"ivo.in\")\nn, b = map(int, sys.stdin.readline().split())\nb += 1\nq = deque()\nres = []\ncur_time = 0\nfor iter in range(n):\n  t, d = map(int, sys.stdin.readline().split())\n  while len(q) > 0 and q[0] <= t:\n    q.popleft()\n  if len(q) >= b:\n    res.append(-1)\n    continue\n  if len(q) == 0:\n    res.append(t + d)\n    q.append(t + d)\n  else:\n    res.append(q[-1] + d)\n    q.append(q[-1] + d)\nprint(\" \".join(map(str, res)))", "import collections \nclass TaskMgr:\n    def __init__(self, n, b):\n        self.b = b\n        self.lock_until = 1\n        self.q = collections.deque()\n        self.end = [-1 for i in range(n)]\n    def empty(self):\n        return len(self.q) == 0\n    def full(self):\n        return len(self.q) == self.b\n    def add(self, i, t, d):\n        if self.full(): return\n        self.q.append( (i, t, d) )\n    def tick(self, now=None):\n        if self.empty(): return\n        lock = self.lock_until\n        now  = now or lock\n        if now < lock:   return\n        now = min(lock, now)\n        i, t, d = self.q.popleft()\n        t = max(t, now)\n        end = t + d\n        self.lock_until = end\n        self.end[i]     = end\ndef __starting_point():\n    n, b = [int(x) for x in input().split()]\n    mgr  = TaskMgr(n, b)\n    for i in range(n):\n        t, d = [int(x) for x in input().split()]\n        mgr.tick(t)\n        mgr.add(i, t, d)\n    while not mgr.empty(): mgr.tick()\n    print(' '.join(str(x) for x in mgr.end))\n\n__starting_point()", "def main():\n    from collections import deque\n    a = deque()\n    n, b = map(int, input().split())\n    next_t = 0\n    for i in range(n):\n        c, lo = map(int, input().split())\n        while a and a[0] <= c:\n            a.popleft()\n        if len(a) > b:\n            print(-1, end=' ')\n        else:\n            print(max(next_t, c) + lo, end=' ')\n            next_t = max(next_t, c) + lo\n            a.append(next_t)\nmain()", "n,b=map(int,input().split())\nl=[tuple(map(int,input().split())) for i in range(n)]\nch=[0]\nans=[]\nbd=[0]*(n+1)\npo=ma=0\nfor i in range(n):\n    t,d=l[i]\n    bd[i]=bd[i-1]\n    ch+=[max(ma,t)+d]\n    while ch[po]<=t: po+=1\n    if i-po-(bd[i-1]-bd[po-1])==b: bd[i]+=1; ch[-1]=-1\n    if ch[-1]>ma: ma=ch[-1]\n    ans+=[str(ch[-1])]\nprint(' '.join(ans))", "#! /usr/bin/env python3\n'''\n' Title:\t\n' Author:\tCheng-Shih, Wong\n' Date:\t\t\n'''\nfrom collections import deque\n\nn, b = list(map(int, input().split()))\n\nquery = {}\ntm = []\nque = deque()\nans = {}\n\nfor i in range(n):\n\tu, v = list(map(int, input().split()))\n\tquery[u] = v\n\ttm.append(u)\n\net = 0\n\nfor ti in tm:\n\twhile ti>et and len(que)>0:\n\t\tcur = que.popleft()\n\t\tet += query[cur]\n\t\tans[cur] = et\n\n\tif ti>et:\n\t\tet = ti+query[ti]\n\t\tans[ti] = et\n\telif ti==et:\n\t\tif len(que) > 0:\n\t\t\tcur = que.popleft()\n\t\t\tet = ti+query[cur]\n\t\t\tans[cur] = et\n\t\tque.append(ti)\n\telse:\n\t\tif len(que) >= b:\n\t\t\tans[ti] = -1\n\t\telse:\n\t\t\tque.append(ti)\n\nwhile len(que)>0:\n\tcur = que.popleft()\n\tet += query[cur]\n\tans[cur] = et\n\nouts = ''\nspace = False\n\nfor ti in tm:\n\tif space: outs += ' '\n\telse: space = True\n\touts += str(ans[ti])\n\nprint(outs)\n\t\t\n", "from collections import deque\n\nn, b = [int(x) for x in input().split()]\nd = deque()\nans = [0] * n\nnow = 0\nj = 0\nfor i in range(n):\n    t = [int(x) for x in input().split()]\n    while len(d) != 0 and now <= t[0]:\n        if d[0][0] > now:\n            now = d[0][0] + d[0][1]\n        else:\n            now += d[0][1]\n        d.popleft()\n        while ans[j] != 0:\n            j += 1\n        ans[j] = now\n        j += 1\n    if len(d) == b:\n        ans[i] = -1\n    else:\n        d.append(t)\nwhile len(d) != 0:\n    if d[0][0] > now:\n        now =  d[0][0] + d[0][1]\n    else:\n        now += d[0][1]\n    d.popleft()\n    while ans[j] != 0:\n        j += 1\n    ans[j] = now\n    j += 1\nprint(*ans)", "from collections import deque\nfrom collections import namedtuple\nQuery = namedtuple(\"Query\", [\"time\", \"duration\"])\nquery_number, max_query_queue_length = list(map(int, input().split()))\nqueries = deque(Query(*list(map(int, input().split()))) for i in range(query_number))\nresults = {}\nquery_queue = deque()\ncurrent_time = 0\nwhile len(results) != query_number:\n    if query_queue:\n        query = query_queue.popleft()\n    else:\n        query = queries.popleft()\n    if current_time > query.time:\n        current_time += query.duration\n    else:\n        current_time = query.time + query.duration\n    results[query.time] = current_time\n    while queries and queries[0].time < current_time:\n        if len(query_queue) < max_query_queue_length:\n            query_queue.append(queries.popleft())\n        else:\n            ignored_query = queries.popleft()\n            results[ignored_query.time] = -1\nprint(\" \".join(str(results[time]) for time in sorted(results.keys())))\n", "3\n\n# def gen(n, b):\n# \timport random\n# \tyield '{} {}'.format(n, b)\n# \tt = 0\n# \tfor i in range(n):\n# \t\tt += random.randrange(1, 1e7)\n# \t\td = random.randrange(1, 1e7)\n# \t\tyield '{} {}\\n'.format(t, d)\n\n# def input():\n# \tg = gen(200000, 200000)\n\n# \treturn next(g)\n\nn, b = map(int, input().split())\n\nends = []\n\nfor i in range(n):\n\tt, d = map(int, input().split())\n\n\twhile len(ends) > 0 and ends[0] <= t:\n\t\tends.pop(0)\n\n\tq = len(ends) - 1\n\n\tif q == b:\n\t\tprint(-1, end=' ')\n\t\tcontinue\n\n\tif not ends:\n\t\tends.append(t + d)\n\telse:\n\t\tends.append(ends[-1] + d)\n\n\tprint(ends[-1], end=' ')\n", "\nimport sys\n\n\n\ndef main():\n    n, b = [int(tok) for tok in sys.stdin.readline().split()]\n\n    td_list = []\n    for i in range(n):\n        td_list.append([int(tok) for tok in sys.stdin.readline().split()])\n\n    queue = []\n    finish = [-1 for i in range(n)]\n\n    for i, (t, d) in enumerate(td_list):\n\n\n        if len(queue) > 0:\n            if queue[0] <= t:\n                queue.pop(0)\n\n        if len(queue) == 0 or queue[-1] < t:\n            queue.append(t + d)\n            finish[i] = t + d\n        elif len(queue) == b + 1:\n            pass\n        else:\n            finish[i] = queue[-1] + d\n            queue.append(queue[-1] + d)\n\n\n    print(\" \".join([str(f) for f in finish]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import os\ns = input().split(' ')\nn = int(s[0])\nb = int(s[1])\n\nrequests = [[]] * n\n\nfor i in range(n):\n    s = input().split(' ')\n    requests[i] = [int(s[0]), int(s[1])]\n\nresult = [0] * n\ncounter = 1\ntime = 0\nqueue = []\n\ntime = requests[0][0]\n\nqueue = [[0, requests[0][1]]]\n\nwhile(counter < n):\n    if(len(queue) != 0):\n        if(queue[0][1] <= requests[counter][0] - time):\n            time += queue[0][1]\n            result[queue[0][0]] = str(time)\n            queue = queue[1:]\n        else:\n            queue[0][1] -= requests[counter][0] - time\n            time = requests[counter][0]\n            if(len(queue) < b + 1):\n                queue += [[counter, requests[counter][1]]]\n            else:\n                result[counter] = '-1'\n            counter += 1\n    else:\n        time = requests[counter][0]\n        queue += [[counter, requests[counter][1]]]\n        counter += 1\n\nfor i in range(len(queue)):\n    time += queue[i][1]\n    result[queue[i][0]] = time\n\nprint()\ns = ''\nfor i in range(len(result)):\n    s += str(result[i]) + ' '\nprint(s)", "n, b = list(map(int, input().split()))\ntasks = []\nnext_task = 0\ntime = 0\nfinish = [-1]*n\nfor i in range(n):\n    t, d = list(map(int, input().split()))\n    while tasks and next_task < len(tasks) and time <= t:\n        time += tasks[next_task][1]\n        finish[tasks[next_task][0]] = time\n        next_task += 1\n    if len(tasks) - next_task < b:\n        tasks.append((i, d))\n    time = max(t, time)\nwhile tasks and next_task < len(tasks):\n    time += tasks[next_task][1]\n    finish[tasks[next_task][0]] = time\n    next_task += 1\nprint(*finish)\n", "def main():\n    read = lambda: list(map(int, input().split()))\n    n, b = read()\n    from collections import deque\n    Q = deque()\n    ans = [0] * n\n    for i in range(n):\n        t, d = read()\n        while len(Q) > 0 and t >= Q[0]:\n            Q.popleft()\n        if len(Q) == 0:\n            cur = t + d\n        elif len(Q) < b + 1:\n            cur = Q[-1] + d\n        else:\n            cur = -1\n        ans[i] = cur\n        if cur != -1:\n            Q.append(cur)\n    print(' '.join(map(str, ans)))\nmain()\n", "n, queue_size = [int(x) for x in input().split()]\n\nresults = [-1 for _ in range(n)]\n\nnext_server_free_time = 1\nqueue = []\nfor idx in range(n):\n    t, d = [int(x) for x in input().split()]\n\n    while queue and next_server_free_time <= t:\n        idx1, d1 = queue.pop(0)\n        next_server_free_time += d1\n        results[idx1] = next_server_free_time\n\n    if next_server_free_time <= t:\n        results[idx] = t + d\n        next_server_free_time = t + d\n    else:\n        if len(queue) < queue_size:\n            queue.append((idx, d))\n\nwhile queue:\n    idx, d = queue.pop(0)\n    next_server_free_time += d\n    results[idx] = next_server_free_time\n\nprint(' '.join([str(x) for x in results]))\n", "from collections import deque\nn, d  =map(int,(input().split()))\nper = input().split()\nt = int(per[0])+int(per[1])\nper = 0\nprint(t, end = ' ')\nanswer = t\nqueue = deque()\nfor i in range(n-1):\n    per1, per2 = map(int, input().split())\n    \n    while t< per1:\n        if per >= 1:\n            s = queue.pop()\n            \n            t += s\n            per-=1\n        else:\n            t = per1\n            answer = t\n    if  t == per1:\n        if per >= 1:\n            s = queue.pop()\n            \n            per-=1\n            t+= s\n            if per < d:\n                answer+=per2\n                print(answer, end = ' ')\n                queue.appendleft(per2)\n                per+=1\n                \n        else:\n            answer = answer+per2\n            print(answer, end = ' ')\n            queue.appendleft(per2)\n            \n            per = 1\n        \n    else:\n        if per < d:\n            answer = answer+per2\n            queue.appendleft(per2)\n            print(answer, end = ' ')\n            per+=1\n        else:\n            print(-1,end = ' ')\n        \n        \n", "n, b = [int(i) for i in input().split()]\nq = [0] * n\nbg = 0\nen = 0\ntime = 0\nres = [-1] * n\nfor it in range(n):\n    ev = [int(i) for i in input().split()]\n    ev.append(it)\n    while bg < en and max(time, q[bg][0]) <= ev[0]:\n        time = max(time, q[bg][0])\n        res[q[bg][2]] = time + q[bg][1]\n        time += q[bg][1]\n        bg += 1\n    if en - bg < b:\n        q[en] = ev\n        en += 1\n        \nwhile bg < en:\n    time = max(time, q[bg][0])\n    res[q[bg][2]] = time + q[bg][1]\n    time += q[bg][1]\n    bg += 1\n\nfor i in range(n):\n    print(res[i], end=' ')\n", "from collections import deque\nwhile True:\n\ttry:\n\t\tn, max_queue_lenth = map(int, input().split())\n\texcept EOFError:\n\t\tbreak\n\n\tqueue = deque()\n\tresponses = []\n\tfor i in range(n):\n\t\ttime, duration = tuple(map(int, input().split()))\n\t\twhile queue and queue[0]<=time:\n\t\t\tqueue.popleft()\n\t\tif not queue:\n\t\t\tqueue.append(time+duration)\n\t\t\tresponses.append(time+duration)\n\t\t\tcontinue\n\t\telse:\n\t\t\tif len(queue)<=max_queue_lenth:\n\t\t\t\tqueue.append(queue[-1]+duration)\n\t\t\t\tresponses.append(queue[-1])\n\t\t\telse:\n\t\t\t\tresponses.append(-1)\n\tprint(\" \".join(map(str, responses)))", "from sys import maxsize as m\nfrom itertools import product as P \nclass Solution:\n    def bazinga(self,N,p):\n        pass \n\ndef __starting_point():\n    n,b = list(map(int,input().split(' ')))\n    ct,pt,lpt,cb = 0,0,[],0\n    result = []\n    for i in range(n):\n        ti,di = list(map(int,input().split()))\n        #print(pt,lpt,'--',ti,di,cb)\n        res = 0\n        if pt==0:\n            pt+= ti+di\n            lpt += [pt]\n            res = pt\n        else:\n            if ti<lpt[0]:\n                if cb<b:\n                    pt+= di\n                    lpt+=[pt]\n                    res = pt\n                    cb+=1\n                elif cb>=b:\n                    res = -1\n                    \n            elif ti>=lpt[0]:\n                #print(lpt,pt,ti,di)\n                if ti>lpt[-1]:\n                    pt+=abs(lpt[-1]-ti)+di\n                else: pt+=di\n                lpt+=[pt]\n                res = pt\n                cb+=1\n                while ti>=lpt[0]:\n                    if len(lpt)==1: break\n                    lpt.pop(0)\n                    if cb>0:    cb-=1\n                \n        result += (str(res),)\n    print(' '.join(result))\n                \n        \n        \n        \n        \n            \n        \n        \n\n        \n    \n\n    \n        \n        \n        \n            \n        \n\n\n    \n\n__starting_point()", "n,b=map(int,input().split())\ndef Q():\n  a=[0];l=0\n  for i in range(n):\n    t,d=map(int,input().split())\n    a+=[t+d if t>a[-1] else a[-1]+d]\n    while a[l]<=t: l+=1\n    if len(a)-l-1>b: a.pop(); yield \"-1\"\n    else: yield str(a[-1])\nprint(' '.join(Q()))", "import heapq\nn, b = map(int, input().split())\nans = [-1 for i in range(n)]\nqueue = []\nhead = 0\nsize = 0\ntime = 0\nfor i in range(n):\n    t, d = map(int, input().split())\n    while size != 0 and time <= t:\n        time += queue[head][0]\n        ans[queue[head][1]] = time\n        head += 1\n        size -= 1\n    if size == b:\n        continue\n    if size == 0 and time <= t:\n        time = t + d\n        ans[i] = time\n        continue\n    queue.append((d, i))\n    size += 1\nfor i in range(head, len(queue)):\n    time += queue[i][0]\n    ans[queue[i][1]] = time\nfor x in ans:\n    print(x, end=' ')", "n, size = map(int, input().split())\nqueue = []\nhead, tail = 0, 0\n\nfor i in range(n):\n    time, during = map(int, input().split())\n    while head != tail and time >= queue[head]:\n        head += 1\n    if tail - head - 1 < size:\n        if head == tail:\n            queue.append(time + during)\n        else:\n            queue.append(queue[-1] + during)\n        print(queue[-1], end = ' ')\n        tail += 1\n    else:\n        print('-1', end = ' ')", "n, size = map(int, input().split())\nqueue = []\nhead, tail = 0, 0\n\nfor i in range(n):\n    time, during = map(int, input().split())\n    while head != tail and time >= queue[head]:\n        head += 1\n    if tail - head - 1 < size:\n        if head == tail:\n            queue.append(time + during)\n        else:\n            queue.append(queue[-1] + during)\n        print(queue[-1], end = ' ')\n        tail += 1\n    else:\n        print('-1', end = ' ')", "from heapq import heappush, heappop\nfrom collections import deque\n\n\nnumber_jobs, queue_size = list(map(int, input().split()))\n\nret = dict()\nevents = list()\njobs = deque()\n\nfor i in range(number_jobs):\n    time, duration = list(map(int, input().split()))\n    heappush(events, (time, 1, i, duration))\n\nwhile events:\n    data = heappop(events)\n\n    if data[1] == 0:\n        finish_time, job_number = data[0], data[2]\n        ret[job_number] = finish_time\n        jobs.popleft()\n\n        if jobs:\n            job, duration = jobs.popleft()\n            jobs.appendleft((job, duration))\n            heappush(events, (finish_time + duration, 0, job))\n    else:\n        time, job_number, duration = data[0], data[2], data[3]\n\n        if len(jobs) <= queue_size:\n            if not jobs:\n                heappush(events, (time + duration, 0, job_number))\n            jobs.append((job_number, duration))\n        else:\n            ret[job_number] = -1\n\nprint(\" \".join([str(ret[x]) for x in sorted(ret)]))\n"]
["from bisect import bisect_left\n\nA, B, Q = map(int, input().split())\nS = [int(input()) for _ in range(A)]\nT = [int(input()) for _ in range(B)]\n\nx = []\nfor s in S:\n    idx = bisect_left(T, s)\n    if idx == 0:\n        x.append(abs(s-T[0]))\n    elif idx == B:\n        x.append(abs(s-T[-1]))\n    else:\n        x.append(min(abs(s-T[idx]), abs(s-T[idx-1])))\n\ny = []\nfor t in T:\n    idx = bisect_left(S, t)\n    if idx == 0:\n        y.append(abs(t-S[0]))\n    elif idx == A:\n        y.append(abs(t-S[-1]))\n    else:\n        y.append(min(abs(t-S[idx]), abs(t-S[idx-1])))\n\nfor _ in range(Q):\n    X = int(input())\n\n    sa = 0\n    si = bisect_left(S, X)\n\n    if si == 0:\n        sa = x[0]+abs(S[0]-X)\n    elif si == A:\n        sa = x[-1]+abs(S[-1]-X)\n    else:\n        sa = min(x[si]+abs(S[si]-X), x[si-1]+abs(S[si-1]-X))\n\n    ti = bisect_left(T, X)\n\n    if ti == 0:\n        ta = y[0]+abs(T[0]-X)\n    elif ti == B:\n        ta = y[-1]+abs(T[-1]-X)\n    else:\n        ta = min(y[ti]+abs(T[ti]-X), y[ti-1]+abs(T[ti-1]-X))\n    \n    print(min(sa, ta))", "import bisect\nimport math\n\na, b, q = map(int, input().split())\ns = [-math.inf]\nt = [-math.inf]\nx = []\nfor _ in range(a):\n    s.append(int(input()))\nfor _ in range(b):\n    t.append(int(input()))\nfor _ in range(q):\n    x.append(int(input()))\ns.append(math.inf)\nt.append(math.inf)\n\nfor i in x:\n    ws = abs(s[bisect.bisect(s, i) - 1] - i)\n    if ws != math.inf:\n        ws += min(abs(t[bisect.bisect(t, s[bisect.bisect(s, i) - 1])-1] - s[bisect.bisect(s, i) - 1]), \\\n                  abs(t[bisect.bisect(t, s[bisect.bisect(s, i) - 1])] - s[bisect.bisect(s, i) - 1]))\n    else:\n        ws = math.inf\n    \n    es = abs(s[bisect.bisect(s, i)] - i)\n    if es != math.inf:\n        es += min(abs(t[bisect.bisect(t, s[bisect.bisect(s, i)]) -1] - s[bisect.bisect(s, i)]), \\\n                  abs(t[bisect.bisect(t, s[bisect.bisect(s, i)])] - s[bisect.bisect(s, i)]))\n    else:\n        es = math.inf\n    \n    wt = abs(t[bisect.bisect(t, i) - 1] - i)\n    if wt != math.inf:\n        wt += min(abs(s[bisect.bisect(s, t[bisect.bisect(t, i) - 1])-1] - t[bisect.bisect(t, i) - 1]), \\\n                  abs(s[bisect.bisect(s, t[bisect.bisect(t, i) - 1])] - t[bisect.bisect(t, i) - 1]))\n    else:\n        wt = math.inf\n    \n    et = abs(t[bisect.bisect(t, i)] - i)\n    if et != math.inf:\n        et += min(abs(s[bisect.bisect(s, t[bisect.bisect(t, i)])-1] - t[bisect.bisect(t, i)]), \\\n                  abs(s[bisect.bisect(s, t[bisect.bisect(t, i)])] - t[bisect.bisect(t, i)]))\n    else:\n        et = math.inf\n        \n    print(min(ws, es, wt, et))", "import sys\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef neighborhood(L, now):\n    tmp = bisect_left(L, now)\n    if tmp == 0:\n        return [tmp, None]\n    elif tmp == len(L):\n        return [tmp - 1, None]\n    else:\n        return [tmp - 1, tmp]\n\n\ndef dist_calc(now, p1, p2):\n    if p1 is None or p2 is None:\n        return f_inf\n    res1 = abs(now - p1) + abs(p1 - p2)\n    res2 = abs(now - p2) + abs(p1 - p2)\n    return min(res1, res2)\n\n\ndef resolve():\n    a, b, q = list(map(int, input().split()))\n    S = list(int(input()) for _ in range(a))\n    T = list(int(input()) for _ in range(b))\n    query = list(int(input()) for _ in range(q))\n\n    for x in query:\n        dist1 = f_inf\n        s1, s2 = neighborhood(S, x)\n        for s in [s1, s2]:\n            if s is not None:\n                t1, t2 = neighborhood(T, S[s])\n                for t in [t1, t2]:\n                    if t is not None:\n                        dist1 = min(dist1, dist_calc(x, S[s], T[t]))\n\n        dist2 = f_inf\n        t1, t2 = neighborhood(T, x)\n        for t in [t1, t2]:\n            if t is not None:\n                s1, s2 = neighborhood(S, T[t])\n                for s in [s1, s2]:\n                    if s is not None:\n                        dist2 = min(dist2, dist_calc(x, S[s], T[t]))\n\n        res = min(dist1, dist2)\n        print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "a,b,q = map(int,input().split())\ns = sorted([int(input()) for i in range(a)])\nt = sorted([int(input()) for i in range(b)])\n\nfrom bisect import bisect\n\nfor i in range(q):\n    x = int(input())\n\n    s_i = bisect(s,x)\n    d1 = d2 = 10**11\n    if s_i<a:\n        d1 = s[s_i]-x\n        t_i = bisect(t,s[s_i])\n        buf = 10**11\n        if t_i<b:\n            buf = t[t_i]-s[s_i]\n        if t_i>0:\n            buf = min(buf,s[s_i]-t[t_i-1])\n        d1 += buf\n    if s_i>0:\n        d2 = x-s[s_i-1]\n        t_i = bisect(t,s[s_i-1])\n        buf = 10**11\n        if t_i<b:\n            buf = t[t_i]-s[s_i-1]\n        if t_i>0:\n            buf = min(buf,s[s_i-1]-t[t_i-1])\n        d2 += buf\n    \n    t_i = bisect(t,x)\n    d3 = d4 = 10**11\n    if t_i<b:\n        d3 = t[t_i]-x\n        s_i = bisect(s,t[t_i])\n        buf = 10**11\n        if s_i<a:\n            buf = s[s_i]-t[t_i]\n        if s_i>0:\n            buf = min(buf,t[t_i]-s[s_i-1])\n        d3 += buf\n    if t_i>0:\n        d4 = x-t[t_i-1]\n        s_i = bisect(s,t[t_i-1])\n        buf = 10**11\n        if s_i<a:\n            buf = s[s_i]-t[t_i-1]\n        if s_i>0:\n            buf = min(buf,t[t_i-1]-s[s_i-1])\n        d4 += buf\n\n    print(min(d1,d2,d3,d4))", "from bisect import bisect_left, bisect_right\nA,B,Q = map(int,input().split())\ns = [int(input()) for _ in range(A)]\nt = [int(input()) for _ in range(B)]\nfor _ in range(Q):\n    x = int(input())\n    a = bisect_right(s, x)\n    b = bisect_right(t, x)\n    la = x-s[a-1] if a > 0 else None\n    ra = s[a]-x if a < A else None\n    lb = x-t[b-1] if b > 0 else None\n    rb = t[b]-x if b < B else None\n    ans = float(\"inf\")\n    if la and lb:\n        ans = min(ans, max(la, lb))\n    if la and rb:\n        ans = min(ans, la+2*rb, 2*la+rb)\n    if ra and lb:\n        ans = min(ans, ra+2*lb, 2*ra+lb)\n    if ra and rb:\n        ans = min(ans, max(ra, rb))\n    print(ans)", "import bisect\nA, B, Q = list(map(int, input().split()))\nINF = 10**18\n\ns = [-INF] + [int(input()) for _ in range(A)] + [INF]\nt = [-INF] + [int(input()) for _ in range(B)] + [INF]\n\n# print(\"s\", s)\n# print(\"t\", t)\nfor q in range(Q):\n    x = int(input())\n    b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x)\n    # print(f\"b{b}, d{d}\")\n\n    res = INF\n\n    for S in [s[b-1], s[b]]:\n        for T in [t[d-1], t[d]]:\n            # print(f\"S{S}, T{T}\")\n            d1, d2 = abs(S-x)+abs(T-S), abs(T-x)+abs(T-S)\n            res = min(res, d1, d2)\n    print(res)\n\n", "def main():\n    import bisect\n\n    a, b, q = map(int, input().split())\n    INF = float('inf')\n    s = [-INF] + [int(input()) for _ in range(a)] + [INF]\n    t = [-INF] + [int(input()) for _ in range(b)] + [INF]\n    x = [int(input()) for _ in range(q)]\n\n    for i in x:\n        si = bisect.bisect_left(s, i)\n        ti = bisect.bisect_left(t, i)\n        sl, sr = i-s[si-1], s[si]-i\n        tl, tr = i-t[ti-1], t[ti]-i\n        print(min(max(sl,tl), sl+tr+min(sl,tr), sr+tl+min(sr,tl), max(sr,tr)))\n\nmain()", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n\na,b,q=MI()\nlis1=[-inf]\nlis2=[-inf]\nfor i in range(a):\n    lis1.append(I())\nfor i in range(b):\n    lis2.append(I())\nlis1.append(inf)\nlis2.append(inf)\n#print(lis1)\n#print(lis2)\nfor i in range(q):\n    u=I()\n    x=bisect_left(lis1,u)\n    y=bisect_left(lis2,u)\n    #print(u,x,y)\n    Lll=u-min(lis1[x-1],lis2[y-1])\n    Lrr=max(lis1[x],lis2[y])-u\n    Llr1=2*(u-lis1[x-1])+(lis2[y]-u)\n    Llr2=2*(lis2[y]-u)+u-lis1[x-1]\n    Lrl1=2*(u-lis2[y-1])+lis1[x]-u\n    Lrl2=2*(lis1[x]-u)+u-lis2[y-1]\n    #print(Lll,Lrr,Lrl1,Lrl2,Llr1,Llr2)\n    print((min(Lll,Lrr,Lrl1,Lrl2,Llr1,Llr2)))\n    \n    \n    \n    \n\n", "import bisect\n\nA, B, Q = map(int, input().split())\nINF = float('inf')\ns = [-INF] + [int(input()) for i in range(A)] + [INF]\nt = [-INF] + [int(input()) for i in range(B)] + [INF]\n\nfor i in range(Q):\n    x = int(input())\n    b = bisect.bisect_right(s, x)\n    d = bisect.bisect_right(t, x)\n    ans = INF\n    for S in [s[b-1], s[b]]:\n        for T in [t[d-1], t[d]]:\n            ans1 = abs(S-x) + abs(S-T)\n            ans2 = abs(T-x) + abs(T-S)\n            ans = min(ans, ans1, ans2)\n    print(ans)", "A, B, Q = map(int, input().split())\n\nJinja = []\nTera = []\nIchi = []\nfor i in range (0, A):\n\tJinja.append(int(input()))\nfor i in range (0, B):\n\tTera.append(int(input()))\nfor i in range (0, Q):\n\tIchi.append(int(input()))\n\nimport math\nimport bisect as bi\n\nfor i in range (0, Q):\n\ttemp = Ichi[i]\n\tJ = math.inf\n\tT = math.inf\n\tJL = bi.bisect_left(Jinja, temp)\n\tJR = bi.bisect_right(Jinja, temp)\n\tTL = bi.bisect_left(Tera, temp)\n\tTR = bi.bisect_right(Tera, temp)\n\tif JL != JR:\n\t\tJ = 0\n\tif TL != TR:\n\t\tT = 0\n\tif JR == 0:\n\t\tJW = math.inf\n\t\tJE = abs(temp-Jinja[0])\n\telif JL == A:\n\t\tJW = abs(temp-Jinja[A-1])\n\t\tJE = math.inf\n\telse:\n\t\tJW = abs(temp-Jinja[JL-1])\n\t\tJE = abs(temp-Jinja[JL])\n\tif TR == 0:\n\t\tTW = math.inf\n\t\tTE = abs(temp-Tera[0])\t\n\telif TL == B:\n\t\tTW = abs(temp-Tera[B-1])\n\t\tTE = math.inf\t\n\telse:\n\t\tTW = abs(temp-Tera[TL-1])\n\t\tTE = abs(temp-Tera[TL])\n\tprint(min(J+T, J+TW, J+TE, T+JW, T+JE, max(JW, TW), max(JE, TE), 2*JW+TE, 2*TE+JW, 2*JE+TW, 2*TW+JE))", "import bisect\na,b,q=map(int,input().split())\nInf=float('inf')\ns=[-Inf]+[int(input()) for _ in range(a)]+[Inf]\nt=[-Inf]+[int(input()) for _ in range(b)]+[Inf]\nx=[int(input()) for _ in range(q)]\nfor i in x:\n    si=bisect.bisect_left(s,i)\n    ti=bisect.bisect_left(t,i)\n    sl,sr=i-s[si-1],s[si]-i\n    tl,tr=i-t[ti-1],t[ti]-i\n    print(min(max(sl,tl),sl+tr+min(sl,tr),sr+tl+min(sr,tl),max(sr,tr)))", "import sys\nfrom bisect import bisect\n\n\ndef read():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    a, b, q = list(map(int, read().split()))\n    s = [-10**12] + [int(read()) for _ in range(a)] + [10**12]\n    t = [-10**12] + [int(read()) for _ in range(b)] + [10**12]\n    for _ in range(q):\n        x = int(read())\n        si = bisect(s, x)\n        ti = bisect(t, x)\n        sa, sb = s[si - 1], s[si]\n        ta, tb = t[ti - 1], t[ti]\n        d = 10**12\n        for sx in (sa, sb):\n            for tx in (ta, tb):\n                d = min(abs(x - sx) + abs(sx - tx), abs(x - tx) + abs(tx - sx), d)\n        print(d)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import *\nA,B,Q = map(int,input().split())\ninf = float(\"inf\")\nS = [-inf]+[int(input()) for a in range(A)]+[inf]\nT = [-inf]+[int(input()) for b in range(B)]+[inf]\nX = [int(input()) for q in range(Q)]\n\nfor x in X:\n  si = bisect(S,x)\n  ti = bisect(T,x)\n  d1 = x-S[si-1]\n  d2 = S[si]-x\n  d3 = x-T[ti-1]\n  d4 = T[ti]-x\n  print(min(2*d1+d4,d1+d4*2,2*d2+d3,d2+d3*2,max(d1,d3),max(d2,d4)))", "from bisect import bisect_right\na, b, q = map(int, input().split())\ns = [-float(\"inf\")] + [int(input()) for i in range(a)] + [float(\"inf\")]\nt = [-float(\"inf\")] + [int(input()) for i in range(b)] + [float(\"inf\")]\nx = [int(input()) for i in range(q)]\nfor i in range(q):\n    X = x[i]\n    l, r = bisect_right(s, X), bisect_right(t, X)\n    ans = float(\"inf\")\n    ans = min(ans, abs(s[l - 1] - X) + abs(t[r - 1] - s[l - 1]), abs(t[r - 1] - X) + abs(s[l - 1] - t[r - 1]))\n    ans = min(ans, abs(s[l - 1] - X) + abs(t[r] - s[l - 1]), abs(t[r] - X) + abs(s[l - 1] - t[r]))\n    ans = min(ans, abs(s[l] - X) + abs(t[r - 1] - s[l]), abs(t[r - 1] - X) + abs(s[l] - t[r - 1]))\n    ans = min(ans, abs(s[l] - X) + abs(t[r] - s[l]), abs(t[r] - X) + abs(s[l] - t[r]))\n    print(ans)", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\ndef disLR(a, idx):\n    small = a[max(0, idx - 1)]\n    large = a[min(len(a) - 1, idx)]\n    return small, large\n\n\ndef main():\n    a, b, q = ns()\n    s = [ni() for _ in range(a)]\n    t = [ni() for _ in range(b)]\n\n    for _ in range(q):\n        ans = INF\n\n        x = ni()\n        tmpans = [0] * 4\n\n        idxs = bisect.bisect_left(s, x)\n        sml, lrg = disLR(s, idxs)\n        tmpans[0] += abs(x - sml)\n        tmpans[1] += abs(x - lrg)\n        idxsml = bisect.bisect_left(t, sml)\n        tmpans[0] += min([abs(sml - i) for i in disLR(t, idxsml)])\n        idxlrg = bisect.bisect_left(t, lrg)\n        tmpans[1] += min([abs(lrg - i) for i in disLR(t, idxlrg)])\n\n        idxt = bisect.bisect_left(t, x)\n        sml, lrg = disLR(t, idxt)\n        tmpans[2] += abs(x - sml)\n        tmpans[3] += abs(x - lrg)\n        idxsml = bisect.bisect_left(s, sml)\n        tmpans[2] += min([abs(sml - i) for i in disLR(s, idxsml)])\n        idxlrg = bisect.bisect_left(s, lrg)\n        tmpans[3] += min([abs(lrg - i) for i in disLR(s, idxlrg)])\n        ans = min(ans, min(tmpans))\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# https://img.atcoder.jp/abc119/editorial.pdf\n# bisect_right ---> bisect_left\nimport bisect\nA, B, Q = list(map(int, input().split()))\nINF = 10 ** 18\ns = [-INF] + [int(input()) for i in range(A)] + [INF]\nt = [-INF] + [int(input()) for i in range(B)] + [INF]\nfor q in range(Q):\n    x = int(input())\n    b, d = bisect.bisect_left(s, x), bisect.bisect_left(t, x)\n    res = INF\n    for S in [s[b - 1], s[b]]:\n        for T in [t[d - 1], t[d]]:\n            d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)\n            res = min(res, d1, d2)\n    print(res)\n", "from bisect import bisect\n\na,b,q=map(int,input().split())\ns=[-10**18]+[int(input()) for i in range(a)]+[10**18]\nt=[-10**18]+[int(input()) for i in range(b)]+[10**18]\n\nfor i in range(q):\n  x=int(input())\n  s_inx=bisect(s,x)\n  t_inx=bisect(t,x)\n\n  s_l=s[s_inx-1]\n  s_r=s[s_inx]\n\n  t_l=t[t_inx-1]\n  t_r=t[t_inx]\n\n  ans=10**18\n  for i in [s_l,s_r]:\n    for j in [t_l,t_r]:\n      ans=min(ans,abs(i-x)+abs(j-i))\n\n  for i in [t_l,t_r]:\n    for j in [s_l,s_r]:\n      ans=min(ans,abs(i-x)+abs(j-i))\n\n  print(ans)", "import bisect\nA,B,Q=map(int,input().split())\nINF=10**18\nS=[-INF]+[int(input()) for i in range(A)]+[INF]\nT=[-INF]+[int(input()) for i in range(B)]+[INF]\nfor q in range(Q):\n    x=int(input())\n    i=bisect.bisect_right(S,x)\n    j=bisect.bisect_right(T,x)\n    d=INF\n    for s in [S[i-1],S[i]]:\n        for t in [T[j-1],T[j]]:\n            d1=abs(s-x)+abs(s-t)\n            d2=abs(t-x)+abs(s-t)\n            d=min(d,d1,d2)\n    print(d)", "from bisect import bisect_left\nA, B, Q = list(map(int, input().split()))\ns = [int(input()) for _ in range(A)]\nt = [int(input()) for _ in range(B)]\n\ns.sort()\nt.sort()\n\nfor k in range(Q):\n    x = int(input())\n    ans = []\n    ms = bisect_left(s, x)\n    for i in [-1, 0]:\n        if 0 <= ms + i <= A - 1:\n            mt = bisect_left(t, s[ms + i])\n            for j in [-1, 0]:\n                if 0 <= mt + j <= B - 1:\n                    ans.append(abs(s[ms + i] - x) + abs(t[mt + j] - s[ms + i]))\n    mt = bisect_left(t, x)\n    for i in [-1, 0]:\n        if 0 <= mt + i <= B - 1:\n            ms = bisect_left(s, t[mt + i])\n            for j in [-1, 0]:\n                if 0 <= ms + j <= A - 1:\n                    ans.append(abs(t[mt + i] - x) + abs(s[ms + j] - t[mt + i]))\n    print((min(ans)))\n", "import bisect\nA, B, Q = list(map(int, input().split()))\nS = list(int(input()) for _ in range(A))\nT = list(int(input()) for _ in range(B))\nfor _ in range(Q):\n    x = int(input())\n    s = bisect.bisect(S, x)\n    t = bisect.bisect(T, x)\n    ans = [10**10*2]*4\n    if s < A:\n        ans[0] = abs(S[s]-x) + min(abs(S[s]-T[max(bisect.bisect(T, S[s])-1, 0)]), abs(S[s]-T[min(bisect.bisect(T, S[s]), B-1)]))\n    if s > 0:\n        s -= 1\n        ans[1] = abs(S[s]-x) + min(abs(S[s]-T[max(bisect.bisect(T, S[s])-1, 0)]), abs(S[s]-T[min(bisect.bisect(T, S[s]), B-1)]))\n    if t < B:\n        ans[2] = abs(T[t]-x) + min(abs(T[t]-S[max(bisect.bisect(S, T[t])-1, 0)]), abs(T[t]-S[min(bisect.bisect(S, T[t]), A-1)]))\n    if t > 0:\n        t -= 1\n        ans[3] = abs(T[t]-x) + min(abs(T[t]-S[max(bisect.bisect(S, T[t])-1, 0)]), abs(T[t]-S[min(bisect.bisect(S, T[t]), A-1)]))\n    print((min(ans)))\n", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\n\nmx = 3*10**10\na,b,q = ma()\nS = [0 for i in range(a+2)]\nT = [0 for i in range(b+2)]\nS[0] = -mx;S[a+1] = mx\nT[0] = -mx;T[b+1] = mx\nfor i in range(a):\n    S[i+1]=ni()\nfor i in range(b):\n    T[i+1]=ni()\n\ndef bs(x,ls):##ls == S or T\n    ok =0\n    ng = len(ls)-1\n    while ng-ok > 1:\n        idx = (ok+ng)//2\n        if ls[idx] < x:\n            ok = idx\n        else:\n            ng = idx\n    return ok  #x\u3088\u308a\u3082\u5de6\u306b\u3042\u308bidx\u3092\u8fd4\u3059\ndef solve(x):\n    ids = bs(x,S)\n    s1 = S[ids] #\u81ea\u5206\u3088\u308a\u5de6\n    s2 = S[ids+1] #\u81ea\u5206\u3068\u540c\u3058\u304b\u53f3\n    idt = bs(x,T)\n    t1 = T[idt]\n    t2 = T[idt+1]\n\n    s1t1 = max(x-s1,x-t1)\n    s1t2 = 2*min(x-s1,t2-x) + max(x-s1,t2-x)\n    s2t1 = 2*min(s2-x,x-t1) + max(s2-x,x-t1)\n    s2t2 = max(s2-x,t2-x)\n    print(min(s1t1,s1t2,s2t1,s2t2))\n\nfor i in range(q):\n    x = ni()\n    solve(x)\n", "import bisect\nA,B,Q=map(int,input().split())\nINF=10**18\nS=[-INF]+[int(input()) for i in range(A)]+[INF]\nT=[-INF]+[int(input()) for i in range(B)]+[INF]\nfor q in range(Q):\n    x=int(input())\n    i=bisect.bisect_right(S,x)\n    j=bisect.bisect_right(T,x)\n    d=INF\n    for s in [S[i-1],S[i]]:\n        for t in [T[j-1],T[j]]:\n            d1=abs(s-x)+abs(s-t)\n            d2=abs(t-x)+abs(s-t)\n            d=min(d,d1,d2)\n    print(d)", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\n\ndef main():\n    a, b, q = ns()\n    s = [ni() for _ in range(a)]\n    t = [ni() for _ in range(b)]\n\n    def disLR(a, idx):\n        small = a[max(0, idx - 1)]\n        large = a[min(len(a) - 1, idx)]\n        return [small, large]\n\n    for _ in range(q):\n        ans = INF\n\n        x = ni()\n\n        idxs = bisect.bisect_left(s, x)\n        a1 = disLR(s, idxs)\n\n        idxt = bisect.bisect_left(t, x)\n        a2 = disLR(t, idxt)\n\n        for ta1 in a1:\n            for ta2 in a2:\n                tmp1 = abs(x - ta1) + abs(ta2 - ta1)\n                tmp2 = abs(x - ta2) + abs(ta1 - ta2)\n                ans = min(ans, tmp1, tmp2)\n\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nA, B, Q = list(map(int, input().split()))\nINF = float('inf')\ns = [-INF] + [int(input()) for _ in range(A)] + [INF]\nt = [-INF] + [int(input()) for _ in range(B)] + [INF]\n\nfor q in range(Q):\n    x = int(input())\n    b,d = bisect.bisect_right(s,x), bisect.bisect_right(t,x)\n    res = INF\n    for S in [s[b-1], s[b]]:\n        for T in [t[d-1], t[d]]:\n            d1, d2 = abs(S-x) + abs(T-S), abs(T-x) + abs(S-T)\n            res = min(res, d1,d2)\n    print(res)\n    \n", "import bisect\nINF=10**100\n\nA,B,Q,*stx,=open(0).read().split()\nA,B,Q=map(int,[A,B,Q])\nslist=[-INF]+[int(stx[i]) for i in range(A)]+[INF]\ntlist=[-INF]+[int(stx[i]) for i in range(A,A+B)]+[INF]\nxlist=[int(stx[i]) for i in range(A+B,A+B+Q)]\noslist=[0]*2\notlist=[0]*2\nsr_index=0\ntr_index=0\nfor i in xlist:\n    ans=INF\n    sr_index=bisect.bisect_left(slist,i)\n    oslist=[slist[sr_index-1],slist[sr_index]]\n    tr_index=bisect.bisect_left(tlist,i)\n    otlist=[tlist[tr_index-1],tlist[tr_index]]\n    for j in oslist:\n        for k in otlist:\n            ans=min(ans,abs(j-i)+abs(k-j),abs(k-i)+abs(j-k))\n    print(ans)", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\ndef disLR(a, idx):\n    small = a[max(0, idx - 1)]\n    large = a[min(len(a) - 1, idx)]\n    return [small, large]\n\n\ndef main():\n    a, b, q = ns()\n    s = [ni() for _ in range(a)]\n    t = [ni() for _ in range(b)]\n\n    for _ in range(q):\n        ans = INF\n\n        x = ni()\n\n        idxs = bisect.bisect_left(s, x)\n        a1 = disLR(s, idxs)\n\n        idxt = bisect.bisect_left(t, x)\n        a2 = disLR(t, idxt)\n\n        for ta1 in a1:\n            for ta2 in a2:\n                tmp1 = abs(x - ta1) + abs(ta2 - ta1)\n                tmp2 = abs(x - ta2) + abs(ta1 - ta2)\n                ans = min(ans, tmp1, tmp2)\n\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_right\nA, B, Q = list(map(int, input().split()))\nINF = float('inf')\nS = [-INF] + list(int(input()) for _ in range(A)) + [INF]\nT = [-INF] + list(int(input()) for _ in range(B)) + [INF]\nfor _ in range(Q):\n    x = int(input())\n    i = bisect_right(S,x)\n    j = bisect_right(T,x)\n    d = INF\n    for s in [S[i-1], S[i]]:\n        for t in [T[j-1], T[j]]:\n            d1 = abs(s-x) + abs(s-t)\n            d2 = abs(t-x) + abs(s-t)\n            d = min(d, d1, d2)\n    print(d)\n\n", "import bisect\nA, B, Q = map(int, input().split())\nINF = 10 ** 18\ns = [-INF] + [int(input()) for i in range(A)] + [INF]\nt = [-INF] + [int(input()) for i in range(B)] + [INF]\nfor q in range(Q):\n  x = int(input())\n  b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x)\n  res = INF\n  for S in [s[b-1], s[b]]:\n    for T in [t[d-1], t[d]]:\n      d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)\n      res = min(res, d1, d2)\n  print(res)", "#!/usr/bin/env python3\nimport bisect\n\nINF = 10 ** 18\n\n\ndef solve(s,t,x):\n  ans = [0]*len(x)\n  for i in range(len(x)):\n    b = bisect.bisect_right(s,x[i])\n    d = bisect.bisect_right(t,x[i])\n    res = INF\n    for S in [s[b-1],s[b]]:\n      for T in [t[d-1],t[d]]:\n        res = min(res,abs(S-x[i]) + abs(T-S),abs(T-x[i])+abs(T-S))\n    ans[i] = res\n  return ans\n\n\n\ndef main():\n  A,B,Q = list(map(int,input().split()))\n  s = [-10**18] + [int(input()) for _ in range(A)] + [10**18]\n  t = [-10**18] + [int(input()) for _ in range(B)] + [10**18]\n  x = [int(input()) for _ in range(Q)]\n  ans = solve(s,t,x)\n  for i in range(Q):\n    print((ans[i]))\n  return\n\ndef __starting_point():\n  main()\n\n__starting_point()", "from bisect import bisect\n\na,b,q=map(int,input().split())\nINF=10**18\ns=[-INF]+[int(input()) for i in range(a)]+[INF]\nt=[-INF]+[int(input()) for i in range(b)]+[INF]\n\nfor i in range(q):\n  x=int(input())\n  s_inx=bisect(s,x)\n  t_inx=bisect(t,x)\n\n  s_l=s[s_inx-1]\n  s_r=s[s_inx]\n\n  t_l=t[t_inx-1]\n  t_r=t[t_inx]\n\n  ans=10**18\n  for i in [s_l,s_r]:\n    for j in [t_l,t_r]:\n      d1=abs(i-x)+abs(j-i)\n      d2=abs(j-x)+abs(i-j)\n      ans=min(ans,d1,d2)\n\n  print(ans)", "import bisect\na, b, q = list(map(int, input().split()))\n\ns = [int(input()) for _ in range(a)]\nt = [int(input()) for _ in range(b)]\n\ns.append(-100000000000)\ns.append(100000000000)\nt.append(-100000000000)\nt.append(100000000000)\ns.sort()\nt.sort()\n\nfor _ in range(q):\n    x = int(input())\n\n    idxs = bisect.bisect_right(s, x)\n    idxt = bisect.bisect_right(t, x)\n    left_s = s[idxs - 1]\n    right_s = s[idxs]\n    left_t = t[idxt - 1]\n    right_t = t[idxt]\n\n    kouho1 = max(x - left_s, x - left_t)\n    kouho2 = max(right_s - x, right_t - x)\n    kouho3 = min(x - left_s, right_t - x) * 2 + max(x - left_s, right_t - x)\n    kouho4 = min(x - left_t, right_s - x) * 2 + max(x - left_t, right_s - x)\n    print((min(kouho1, kouho2, kouho3, kouho4)))\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return list(map(int, sys.stdin.readline().split()))\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\nimport bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n\nA, B, Q = mi()\n\nS = [ii() for _ in range(A)]\nT = [ii() for _ in range(B)]\n\nS_ = [S[0]] + S + [S[A-1]]\nT_ = [T[0]] + T + [T[B-1]]\n\nfor _ in range(Q):\n    f = ii()\n    to_s = bisect.bisect_left(S, f)\n    to_t = bisect.bisect_left(T, f)\n    #ans_1 = ans_2 = 0\n    #print(to_s, to_t)\n\n    #ans_1 += abs(S_[to_s+1] - f)\n    #ans_2 += abs(f - S_[to_s])\n    #print(ans_1, ans_2)\n\n    #ans_1 = min(ans_1 + abs(S_[to_s+1] - T_[to_t+1]), ans_1 + abs(S_[to_s+1] - T_[to_t]))\n    #ans_2 = min(ans_2 + abs(S_[to_s] - T_[to_t+1]), ans_2 + abs(S_[to_s] - T_[to_t]))\n\n    ans = min(abs(S_[to_s+1] - f) + abs(S_[to_s+1] - T_[to_t+1]), float('inf'))\n    ans = min(abs(S_[to_s+1] - T_[to_t+1]) + abs(f- T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s+1] - f) + abs(S_[to_s+1] - T_[to_t]), ans)\n    ans = min(abs(S_[to_s+1] - T_[to_t]) + abs(f- T_[to_t]), ans)\n    ans = min(abs(S_[to_s] - f) + abs(S_[to_s] - T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s] - T_[to_t+1]) + abs(f- T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s] - f) + abs(S_[to_s] - T_[to_t]), ans)\n    ans = min(abs(S_[to_s] - T_[to_t]) + abs(f- T_[to_t]), ans)\n    print(ans)\n", "import sys\nfrom bisect import bisect_left\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B, Q = list(map(int, readline().split()))\n    S = [-INF]\n    S.extend(int(readline()) for _ in range(A))\n    S.append(INF)\n    T = [-INF]\n    T.extend(int(readline()) for _ in range(B))\n    T.append(INF)\n    X = [int(readline()) for _ in range(Q)]\n\n    ans = [INF] * Q\n    for i, x in enumerate(X):\n        idx_s = bisect_left(S, x)\n        idx_t = bisect_left(T, x)\n\n        for s in (S[idx_s - 1], S[idx_s]):\n            for t in (T[idx_t - 1], T[idx_t]):\n                ans[i] = min(ans[i], abs(x - s) + abs(s - t), abs(x - t) + abs(t - s))\n\n    print(('\\n'.join(map(str, ans))))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\n\nA,B,Q=map(int,input().split())\nS=[int(input()) for i in range(A)]\nT=[int(input()) for i in range(B)]\nfor i in range(Q):\n    x=int(input())\n    si=bisect_left(S,x)\n    ti=bisect_left(T,x)\n    if 0<si<A and 0<ti<B:\n        sl,sr=abs(x-S[si-1]),abs(x-S[si])\n        tl,tr=abs(x-T[ti-1]),abs(x-T[ti])\n        print(min(max(sr,tr),max(sl,tl),sl+tr+min(sl,tr),sr+tl+min(sr,tl)))\n    elif si==0 and ti==0:\n        sr=abs(x-S[si])\n        tr=abs(x-T[ti])\n        print(max(sr,tr))\n    elif si==A and ti==B:\n        sl=abs(x-S[si-1])\n        tl=abs(x-T[ti-1])\n        print(max(sl,tl))\n    elif si==0 and ti==B:\n        sr=abs(x-S[si])\n        tl=abs(x-T[ti-1])\n        print(sr+tl+min(sr,tl))\n    elif si==A and ti==0:\n        sl=abs(x-S[si-1])\n        tr=abs(x-T[ti])\n        print(sl+tr+min(sl,tr))\n    elif si==0:\n        sr=abs(x-S[si])\n        tl,tr=abs(x-T[ti-1]),abs(x-T[ti])\n        print(min(max(sr,tr),sr+tl+min(sr,tl)))\n    elif si==A:\n        sl=abs(x-S[si-1])\n        tl,tr=abs(x-T[ti-1]),abs(x-T[ti])\n        print(min(max(sl,tl),sl+tr+min(sl,tr)))\n    elif ti==0:\n        sl,sr=abs(x-S[si-1]),abs(x-S[si])\n        tr=abs(x-T[ti])\n        print(min(max(sr,tr),sl+tr+min(sl,tr)))\n    elif ti==B:\n        sl,sr=abs(x-S[si-1]),abs(x-S[si])\n        tl=abs(x-T[ti-1])\n        print(min(max(sl,tl),sr+tl+min(sr,tl)))", "from bisect import bisect_left\n\na, b, q = list(map(int, input().split()))\ndummy = 10 ** 18 + 1\ns = [-dummy] + [int(input()) for _ in range(a)] + [dummy]\nt = [-dummy] + [int(input()) for _ in range(b)] + [dummy]\nx = [int(input()) for _ in range(q)]\n\nfor i in x:\n    # \u795e\u793e\u304b\u3089\u5148\u306b\u884c\u304f\u30d1\u30bf\u30fc\u30f3\n    idx_s, idx_t = bisect_left(s, i), bisect_left(t, i)\n    ans = dummy\n    for j in [s[idx_s-1], s[idx_s]]:\n        for k in [t[idx_t-1], t[idx_t]]:\n            res1, res2 = abs(j - i) + abs(k - j), abs(k - i) + abs(j - k)\n            ans = min(ans, res1, res2)\n    print(ans)\n", "def main():\n    from bisect import bisect_left\n    A, B, Q = list(map(int, input().split()))\n    INF = 2 * 10 ** 10\n    S = [-INF] + [int(input()) for _ in range(A)] + [INF]\n    T = [-INF] + [int(input()) for _ in range(B)] + [INF]\n    S_rev = [-s for s in S][::-1]\n    T_rev = [-t for t in T][::-1]\n\n    for q in range(Q):\n        x = int(input())\n        ans = 5 * 10 ** 10\n\n        # Case1: \u53f3\u306b\u76f4\u9032\n        cost1_s = S[bisect_left(S, x)] - x\n        cost1_t = T[bisect_left(T, x)] - x\n        ans = min(ans, max(cost1_s, cost1_t))\n\n        # Case2: \u5de6\u306b\u76f4\u9032\n        cost2_s = S_rev[bisect_left(S_rev, -x)] + x\n        cost2_t = T_rev[bisect_left(T_rev, -x)] + x\n        ans = min(ans, max(cost2_s, cost2_t))\n\n        # Case3: \u53f3\u3067S\u3001\u5de6\u3067T\n        cost3_s = S[bisect_left(S, x)] - x\n        cost3_t = T_rev[bisect_left(T_rev, -x)] + x\n        ans = min(ans, 2 * min(cost3_s, cost3_t) + max(cost3_s, cost3_t))\n\n        # Case4: \u53f3\u3067T\u3001\u5de6\u3067S\n        cost3_s = S_rev[bisect_left(S_rev, -x)] + x\n        cost3_t = T[bisect_left(T, x)] - x\n        ans = min(ans, 2 * min(cost3_s, cost3_t) + max(cost3_s, cost3_t))\n\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#\na,b,q=list(map(int, input().split()))\n*s,=[-10**11]+[int(input()) for _ in range(a)]+[10**11]\n*t,=[-10**11]+[int(input()) for _ in range(b)]+[10**11]\n*x,=[int(input()) for _ in range(q)]\ns.sort()\nt.sort()\n\nfrom bisect import bisect_left\nfrom itertools import product\nfor xi in x:\n    ans=10**11\n    i=bisect_left(s,xi)\n    j=bisect_left(t,xi)\n    for u,v in product(s[i-1:i+1],t[j-1:j+1]):\n        d=min(abs(u-xi),abs(v-xi))+abs(u-v)####\u3053\u306e\u5f0f\u304c\u7c21\u660e\n        ans=min(d,ans)\n    print(ans)\n    \n\n", "import bisect\nA,B,Q = map(int, input().split())\nS = [int(input()) for i in range(A)]\nT = [int(input()) for i in range(B)]\nS = sorted(S)\nT = sorted(T)\n\nfor j in range(Q):\n    x = int(input())\n    a = S[bisect.bisect_left(S, x)-1]\n    b = T[bisect.bisect_left(T, x)-1]\n    if x <=S[-1]:\n        a_ = S[bisect.bisect_right(S,x)]\n    else:\n        a_ = S[bisect.bisect_right(S,x)-1]\n    if x <= T[-1]:\n        b_ = T[bisect.bisect_right(T,x)]\n    else:\n        b_ = T[bisect.bisect_right(T,x)-1]\n    y = min([abs(a-x)+abs(b-a),abs(a-x)+abs(b_-a),abs(a_-x)+abs(b-a_),abs(a_-x)+abs(b_-a_),\n            abs(b-x)+abs(a-b),abs(b-x)+abs(a_-b), abs(b_-x)+abs(a-b_), abs(b_-x)+abs(b_-a_)])\n    print(y)", "import bisect\nA,B,Q =list(map(int,input().split()))\ns = []\nt = []\nfor i in range(A):\n    s.append(int(input()))\nfor i in range(B):\n    t.append(int(input()))\nfor i in range(Q):\n    x=(int(input()))    \n    s_index_af = bisect.bisect(s,x)\n    if s_index_af == A:\n        s_index_af -= 1\n        s_index_bf = s_index_af\n    else:\n        s_index_bf = s_index_af -1\n\n    t_index_af = bisect.bisect(t,x)\n    if t_index_af == B:\n        t_index_af -= 1\n        t_index_bf = t_index_af\n    else:\n        t_index_bf = t_index_af -1\n   \n    jl = [s[s_index_bf]-x,s[s_index_af]-x]\n    tl = [t[t_index_bf]-x,t[t_index_af]-x]\n\n    jt = []\n    jt.append(abs(jl[0])+abs(tl[0]-jl[0]))\n    jt.append(abs(jl[0])+abs(tl[1]-jl[0]))\n    jt.append(abs(jl[1])+abs(tl[0]-jl[1]))\n    jt.append(abs(jl[1])+abs(tl[1]-jl[1]))\n\n    jt.append(abs(tl[0])+abs(jl[0]-tl[0]))\n    jt.append(abs(tl[0])+abs(jl[1]-tl[0]))\n    jt.append(abs(tl[1])+abs(jl[0]-tl[1]))\n    jt.append(abs(tl[1])+abs(jl[1]-tl[1]))\n\n            \n    print((min(jt)))\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\nimport bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n\nA, B, Q = mi()\n\nS = [ii() for _ in range(A)]\nT = [ii() for _ in range(B)]\n\nS_ = [S[0]] + S + [S[A-1]]\nT_ = [T[0]] + T + [T[B-1]]\n\nfor _ in range(Q):\n    f = ii()\n    to_s = bisect.bisect_left(S, f)\n    to_t = bisect.bisect_left(T, f)\n\n    ans = float('inf')\n\n    for i in [S_[to_s], S_[to_s+1]]:\n        for j in [T_[to_t], T_[to_t+1]]:\n            tmp = min(abs(i - f), abs(j - f)) + abs(i - j)\n            ans = min(ans, tmp)\n    '''\n    ans = min(abs(S_[to_s+1] - f) + abs(S_[to_s+1] - T_[to_t+1]), float('inf'))\n    ans = min(abs(S_[to_s+1] - T_[to_t+1]) + abs(f - T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s+1] - f) + abs(S_[to_s+1] - T_[to_t]), ans)\n    ans = min(abs(S_[to_s+1] - T_[to_t]) + abs(f - T_[to_t]), ans)\n    ans = min(abs(S_[to_s] - f) + abs(S_[to_s] - T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s] - T_[to_t+1]) + abs(f - T_[to_t+1]), ans)\n    ans = min(abs(S_[to_s] - f) + abs(S_[to_s] - T_[to_t]), ans)\n    ans = min(abs(S_[to_s] - T_[to_t]) + abs(f - T_[to_t]), ans)\n    '''\n    print(ans)", "import bisect\na, b, q = list(map(int, input().split()))\nINF = 10**18\nshrines = [-INF]+[int(input())for _ in range(a)]\ntemples = [-INF]+[int(input())for _ in range(b)]\n\nfor _ in range(q):\n    x = int(input())\n\n    ans = INF\n    # \u795e\u793e\u2192\u5bfa\n    Ri = bisect.bisect_left(shrines, x)\n    Li = Ri-1\n    if Ri != a+1:\n        R = shrines[Ri]\n        Rj = bisect.bisect_left(temples, R)\n        Lj = Rj-1\n        d = INF\n        if Rj != b+1:\n            d = min(d, temples[Rj]-x)\n        if Lj != 0:\n            d = min(d, R-temples[Lj]+R-x)\n        if d < ans:\n            ans = d\n    if Li != 0:\n        L = shrines[Li]\n        Rj = bisect.bisect_left(temples, L)\n        Lj = Rj-1\n        d = INF\n        if Rj != b+1:\n            d = min(d, temples[Rj]-L+x-L)\n        if Lj != 0:\n            d = min(d, x-temples[Lj])\n        if d < ans:\n            ans = d\n\n    # \u5bfa\u2192\u795e\u793e\n    Ri = bisect.bisect_left(temples, x)\n    Li = Ri-1\n    if Ri != b+1:\n        R = temples[Ri]\n        Rj = bisect.bisect_left(shrines, R)\n        Lj = Rj-1\n        d = INF\n        if Rj != a+1:\n            d = min(d, shrines[Rj]-x)\n        if Lj != 0:\n            d = min(d, R-shrines[Lj]+R-x)\n        if d < ans:\n            ans = d\n    if Li != 0:\n        L = temples[Li]\n        Rj = bisect.bisect_left(shrines, L)\n        Lj = Rj-1\n        d = INF\n        if Rj != a+1:\n            d = min(d, shrines[Rj]-L+x-L)\n        if Lj != 0:\n            d = min(d, x-shrines[Lj])\n        if d < ans:\n            ans = d\n\n    print(ans)\n", "import bisect\n\na,b,q=map(int,input().split())\ns = []\nt = []\nfor i in range(a):\n  s.append(int(input()))\nfor i in range(b):\n  t.append(int(input()))\nfor _ in range(q):\n  x = int(input())\n  \n  ans = [0,0,0]\n  \n  i = bisect.bisect_left(s,x)\n  if i == 0:\n    sl = 100000000000\n  else:\n    sl = abs(s[i-1]-x)\n  if i == a:\n    sr = 100000000000\n  else:\n    sr = abs(s[i]-x)\n  i = bisect.bisect_left(t,x)\n  if i == 0:\n    tl = 100000000000\n  else:\n    tl = abs(t[i-1]-x)\n  if i == b:\n    tr = 100000000000\n  else:\n    tr = abs(t[i]-x)\n  ans[0] = max(tl,sl)\n  ans[1] = max(tr,sr)\n  ans[2] = min(2*tl+sr,2*sl+tr,2*sr+tl,2*tr+sl)\n  print(min(ans))", "import sys\nimport math\nfrom collections import deque\nimport bisect\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n\tA, B, Q = NMI()\n\tS = [-float(\"inf\")] + [NI() for _ in range(A)] + [float(\"inf\")]\n\tT = [-float(\"inf\")] + [NI() for _ in range(B)] + [float(\"inf\")]\n\tQ = [NI() for _ in range(Q)]\n\n\tfor q in Q:\n\t\ts_idx = bisect.bisect_left(S, q)\n\t\tt_idx = bisect.bisect_left(T, q)\n\t\tsl, sr, tl, tr = S[s_idx-1], S[s_idx], T[t_idx-1], T[t_idx]\n\t\tLL = max(abs(q - sl), abs(q - tl))\n\t\tRR = max(abs(q - sr), abs(q - tr))\n\t\tLR = abs(q - sl) * 2 + abs(q - tr)\n\t\tRL = abs(q - sr) * 2 + abs(q - tl)\n\t\tLR2 = abs(q - tl) * 2 + abs(q - sr)\n\t\tRL2 = abs(q - tr) * 2 + abs(q - sl)\n\t\tres = min(LL, RR, LR, LR2, RL, RL2)\n\t\tprint(res)\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import bisect\nA,B,Q = map(int,input().split())\nINF = float('inf')\nS = [-INF]+[int(input()) for _ in range(A)]+[INF]\nT = [-INF]+[int(input()) for _ in range(B)]+[INF]\n\nans = []\nfor q in range(Q):\n    x = int(input())\n    i = bisect.bisect_right(S,x)\n    j = bisect.bisect_right(T,x)\n    d = INF\n    for s in [S[i-1],S[i]]:\n        for t in [T[j-1],T[j]]:\n            d1 = abs(x-s) + abs(s-t)\n            d2 = abs(x-t) + abs(s-t)\n            d = min(d,d1,d2)\n    ans.append(d)\nprint(*ans,sep=\"\\n\")", "import bisect\na,b,q = map(int, input().split())\ns = [int(input()) for i in range(a)]\nt = [int(input()) for i in range(b)]\ns.sort()\nt.sort()\nfor i in range(q):\n  ans = 10**11\n  x = int(input())\n  c = bisect.bisect_left(s,x)\n  if c == 0:\n    e1,e2 = s[0],s[0]\n  elif c == a:\n    e1,e2 = s[-1],s[-1]\n  else:\n    e1,e2 = s[c-1],s[c]\n  f = bisect.bisect_left(t,e1)\n  if f == 0:\n    f1,f2 = t[0],t[0]\n  elif f == b:\n    f1,f2 = t[-1],t[-1]\n  else:\n    f1,f2 = t[f-1],t[f]\n  ans = min(ans,abs(x-e1)+abs(e1-f1),abs(x-e1)+abs(e1-f2))\n  f = bisect.bisect_left(t,e2)\n  if f == 0:\n    f1,f2 = t[0],t[0]\n  elif f == b:\n    f1,f2 = t[-1],t[-1]\n  else:\n    f1,f2 = t[f-1],t[f]\n  ans = min(ans,abs(x-e2)+abs(e2-f1),abs(x-e2)+abs(e2-f2))\n  d = bisect.bisect_left(t,x)\n  if d == 0:\n    f1,f2 = t[0],t[0]\n  elif d == b:\n    f1,f2 = t[-1],t[-1]\n  else:\n    f1,f2 = t[d-1],t[d]\n  e = bisect.bisect_left(s,f1)\n  if e == 0:\n    e1,e2 = s[0],s[0]\n  elif e == a:\n    e1,e2 = s[-1],s[-1]\n  else:\n    e1,e2 = s[e-1],s[e]\n  ans = min(ans,abs(x-f1)+abs(f1-e1),abs(x-f1)+abs(f1-e2))\n  e = bisect.bisect_left(s,f2)\n  if e == 0:\n    e1,e2 = s[0],s[0]\n  elif e == a:\n    e1,e2 = s[-1],s[-1]\n  else:\n    e1,e2 = s[e-1],s[e]\n  ans = min(ans,abs(x-f2)+abs(f2-e1),abs(x-f2)+abs(f2-e2))\n  print (ans)", "# https://atcoder.jp/contests/abc119/tasks/abc119_d\n# \n\nfrom bisect import bisect_left,bisect_right\nA,B,Q=map(int,input().split())\ns= [int(input()) for _ in range(A)]\nt= [int(input()) for _ in range(B)]\n#print(s)\n#print(t)\nfor i in range(Q):\n    x=int(input())\n    #print(bisect_left(s,x),bisect_left(t,x))\n    sl=float(\"-inf\")\n    sr=float(\"inf\")\n    tl=float(\"-inf\")\n    tr=float(\"inf\")\n    a=bisect_left(s,x)\n    if a>0:\n        sl = s[a-1]\n    if a<=A-1:\n        sr = s[a]\n    b=bisect_left(t,x)\n    if b>0:\n        tl = t[b-1]\n    if b<=B-1:\n        tr = t[b]\n    #print(sl,sr)\n    #print(tl,tr)\n    \n    pat_LL = x - min(sl,tl)\n    pat_LR = sr-tl + min(sr-x,x-tl)\n    pat_RL = tr-sl + min(tr-x,x-sl)\n    pat_RR = max(sr,tr)-x\n    \n    print(min(pat_LL,pat_LR,pat_RL,pat_RR))", "import bisect\na, b, q = map(int, input().split())\ns = [int(input()) for i in range(a)]\ns.sort()\nt = [int(input()) for i in range(b)]\nt.sort()\n\n\"\"\"\ns\u3068t\u306e\u3069\u3061\u3089\u3092\u5148\u306b\u3059\u308b\u304b\n\u5de6\u53f3\u3069\u3061\u3089\u306b\u8d70\u308b\u304b\n\u306e\u90fd\u54084\u30d1\u30bf\u30fc\u30f3\u306e\u6700\u5c0f\u5024\u3092\u9078\u3079\u3070\u3088\u3044\n\"\"\"\n\ndef minl(x):\n    # s\u3092\u9078\u629e\n    idx = bisect.bisect_left(s, x)\n    ret = 3*10**10\n    if idx == 0:\n        first = s[0] - x\n        now = s[0]\n        idx = bisect.bisect_left(t, now)\n        if idx == 0:\n            second = t[0] - now\n        elif idx == b:\n            second = now - t[b-1]\n        else:\n            second = min(now - t[idx-1], t[idx]-now)\n        ret = min(ret, first+second)\n    elif idx == a:\n        first = x - s[a-1]\n        now = s[a-1]\n        idx = bisect.bisect_left(t, now)\n        if idx == 0:\n            second = t[0] - now\n        elif idx == b:\n            second = now - t[b-1]\n        else:\n            second = min(now - t[idx-1], t[idx]-now)\n        ret = min(ret, first+second)\n    else:\n        for first_g in [s[idx-1], s[idx]]:\n            first = abs(first_g - x)\n            now = first_g\n            idx = bisect.bisect_left(t, now)\n            if idx == 0:\n                second = t[0] - now\n            elif idx == b:\n                second = now - t[b-1]\n            else:\n                second = min(now - t[idx-1], t[idx]-now)\n            ret = min(ret, first+second)\n    \n    # t\u3092\u9078\u629e\n    idx = bisect.bisect_left(t, x)\n    if idx == 0:\n        first = t[0] - x\n        now = t[0]\n        idx = bisect.bisect_left(s, now)\n        if idx == 0:\n            second = s[0] - now\n        elif idx == a:\n            second = now - s[a-1]\n        else:\n            second = min(now - s[idx-1], s[idx]-now)\n        ret = min(ret, first+second)\n    elif idx == b:\n        first = x - t[b-1]\n        now = t[b-1]\n        idx = bisect.bisect_left(s, now)\n        if idx == 0:\n            second = s[0] - now\n        elif idx == a:\n            second = now - s[a-1]\n        else:\n            second = min(now - s[idx-1], s[idx]-now)\n        ret = min(ret, first+second)\n    else:\n        for first_g in [t[idx-1], t[idx]]:\n            first = abs(first_g - x)\n            now = first_g\n            idx = bisect.bisect_left(s, now)\n            if idx == 0:\n                second = s[0] - now\n            elif idx == a:\n                second = now - s[a-1]\n            else:\n                second = min(now - s[idx-1], s[idx]-now)\n            ret = min(ret, first+second)\n    return ret\n\nfor i in range(q):\n    x = int(input())\n    print(minl(x))", "from bisect import bisect_left\n\na , b , q = list(map(int, input().split()))\n\ns = [int(input()) for i in range(a)]\nt = [int(input()) for i in range(b)]\ns.sort()\nt.sort()\ns=[float('INF')*(-1)]+s+[float('INF')]\nt=[float('INF')*(-1)]+t+[float('INF')]\nfor i in range(q):\n    x = int(input())\n    sp=bisect_left(s,x)-1\n    tp=bisect_left(t,x)-1\n    s1=s[sp]\n    t1=t[tp]\n    s2=s[sp+1]\n    t2=t[tp+1]\n    print((min(max(x-s1,x-t1),max(s2-x,t2-x),x-s1+t2-s1,x-t1+s2-t1,s2-x+s2-t1,t2-x+t2-s1)))\n", "a,b,q = map(int,input().split())\ntl=[]\nqlist=[]\nfor i in range(a):tl.append((int(input()),0,i))\nfor i in range(b):tl.append((int(input()),1,i))\nfor i in range(q):\n    q1=int(input())\n    tl.append((q1,2,i))\n    qlist.append(q1)\ntl.sort()\nprea=[-1]*q\npreb=[-1]*q\nta=tb=-1\nfor i,c in enumerate(tl):\n    if   c[1]==0:ta=c[0]\n    elif c[1]==1:tb=c[0]\n    elif c[1]==2:prea[c[2]],preb[c[2]]=ta,tb\nposta=[-1]*q\npostb=[-1]*q\nra=rb=-1\nfor i,c in enumerate(tl[::-1]):\n    if   c[1]==0:ra=c[0]\n    elif c[1]==1:rb=c[0]\n    elif c[1]==2:posta[c[2]],postb[c[2]]=ra,rb\n\ndef cal(pra,poa,prb,pob,q):\n    gmin = 999999999999\n    if pra!=-1 and prb!=-1:\n        if pra<prb:gmin=min(gmin,q-pra)\n        else:      gmin=min(gmin,q-prb)\n    if pra!=-1 and pob!=-1:gmin=min(gmin,pob-pra+min(q-pra,pob-q))\n    if prb!=-1 and poa!=-1:gmin=min(gmin,poa-prb+min(poa-q,q-prb))\n    if poa!=-1 and pob!=-1:\n        if poa<pob:gmin=min(gmin,pob-q)\n        else:      gmin=min(gmin,poa-q)\n    return gmin\nfor a1,a2,b1,b2,q in zip(prea,posta,preb,postb,qlist):print(cal(a1,a2,b1,b2,q))", "import bisect\nA, B, Q = map(int, input().split())\nINF=10**18\ns =[-INF] + [int(input()) for i in range(A)] + [INF]\nt =[-INF] + [int(input()) for i in range(B)] + [INF]\nfor q in range(Q):\n  x = int(input())\n  b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x) \n  res = INF\n  for S in [s[b - 1], s[b]]:\n    for T in [t[d - 1], t[d]]:\n      d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T) \n      res = min(res, d1, d2)\n  print(res)", "import sys\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    a, b, q = list(map(int, input().split()))\n    S = [-f_inf] + list(int(input()) for _ in range(a)) + [f_inf]\n    T = [-f_inf] + list(int(input()) for _ in range(b)) + [f_inf]\n\n    for _ in range(q):\n        res = f_inf\n        x = int(input())\n\n        idx_s = bisect_left(S, x)\n        idx_t = bisect_left(T, x)\n        for s in [S[idx_s - 1], S[idx_s]]:\n            for t in [T[idx_t - 1], T[idx_t]]:\n                d1 = abs(s - x) + abs(s - t)\n                d2 = abs(t - x) + abs(t - s)\n                res = min(res, d1, d2)\n        print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect, bisect_left \n\nA, B, Q = map(int, input().split())\nS, T, X = [0]*(A+2), [0]*(B+2), [0]*Q\n\nINF = 10**10\nS[0], T[0] = -INF, -INF\nS[-1], T[-1] = 2*INF, 2*INF\n\nfor i in range(A):\n  S[i+1] = int(input())\n\nfor i in range(B):\n  T[i+1] = int(input())\n\nfor i in range(Q):\n  X[i] = int(input())\n\ndef dis(x):\n  RS = bisect_left(S, x)\n  LS = RS - 1\n  RT = bisect_left(T, x)\n  LT = RT - 1\n  ans = [0]*4\n  ans[0] = max(S[RS], T[RT]) - x\n  ans[1] = x - min(S[LS], T[LT])\n  ans[2] = S[RS] - T[LT] + min(S[RS] - x, x - T[LT])\n  ans[3] = T[RT] - S[LS] + min(T[RT] - x, x - S[LS])\n  return min(ans)\n\nfor x in X:\n  print(dis(x))", "from bisect import bisect\n\na,b,q=map(int,input().split())\ns=[-10**18]+[int(input()) for i in range(a)]+[10**18]\nt=[-10**18]+[int(input()) for i in range(b)]+[10**18]\n\nfor i in range(q):\n  x=int(input())\n  s_inx=bisect(s,x)\n  t_inx=bisect(t,x)\n\n  s_l=s[s_inx-1]\n  s_r=s[s_inx]\n\n  t_l=t[t_inx-1]\n  t_r=t[t_inx]\n\n  ans=10**18\n  for i in [s_l,s_r]:\n    for j in [t_l,t_r]:\n      d1=abs(i-x)+abs(j-i)\n      d2=abs(j-x)+abs(i-j)\n      ans=min(ans,d1,d2)\n\n  print(ans)", "from bisect import bisect_left\n# \u521d\u671f\u5165\u529b\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nA,B,Q = (int(i) for i in input().split())\nst ={\"s\":[],\"t\":[]}\nx =[0] *Q\n\nfor i in range(A):\n    aa = int(input())\n    st[\"s\"].append(aa)\nst[\"s\"].append(10**11)\n\nfor i in range(B):\n    bb = int(input())\n    st[\"t\"].append(bb)\nst[\"t\"].append(10**11)\n\n\nfor i in range(Q):\n    x[i] = int(input())\n\n#2\u5206\u63a2\u7d22\u3067\u8fd1\u3044\u795e\u793e\u3068\u5bfa\u3092\u63a2\u3059\ndist =[]\nfor xi in x:\n    #\u30b9\u30bf\u30fc\u30c8\u21d2\u795e\u793e\n    xs =bisect_left(st[\"s\"],xi)\n    s_l =st[\"s\"][xs-1] #\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u5de6\uff09\u24f5\n    s_r =st[\"s\"][xs  ] #\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u53f3\uff09\u24f6\n    xs_l =abs(xi -s_l)  \n    xs_r =abs(xi -s_r)    \n\n    xs_l_t =bisect_left(st[\"t\"],s_l ) \n    t_l =st[\"t\"][xs_l_t -1] #\u24f5\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u5de6\uff09\n    t_r =st[\"t\"][xs_l_t   ] #\u24f5\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u53f3\uff09\n    xs_l_t_l =abs(s_l -t_l) \n    xs_l_t_r =abs(s_l -t_r) \n    \n    xs_r_t =bisect_left(st[\"t\"],s_r ) \n    t_l =st[\"t\"][xs_r_t -1] #\u24f6\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u5de6\uff09\n    t_r =st[\"t\"][xs_r_t   ] #\u24f6\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u53f3\uff09\n    xs_r_t_l =abs(s_r -t_l) \n    xs_r_t_r =abs(s_r -t_r)\n    ds =min(xs_l +xs_l_t_l ,xs_l +xs_l_t_r ,xs_r +xs_r_t_l ,xs_r +xs_r_t_r)\n\n     #\u30b9\u30bf\u30fc\u30c8\u21d2\u5bfa\n    xs =bisect_left(st[\"t\"],xi)\n    s_l =st[\"t\"][xs-1] #\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u5de6\uff09\u24f7\n    s_r =st[\"t\"][xs  ] #\u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u304b\u3089\u8fd1\u3044\u5bfa\uff08\u53f3\uff09\u24f8\n    xs_l =abs(xi -s_l)  \n    xs_r =abs(xi -s_r)    \n\n    xs_l_t =bisect_left(st[\"s\"],s_l ) \n    t_l =st[\"s\"][xs_l_t -1] #\u24f7\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u5de6\uff09\n    t_r =st[\"s\"][xs_l_t   ] #\u24f7\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u53f3\uff09\n    xs_l_t_l =abs(s_l -t_l) \n    xs_l_t_r =abs(s_l -t_r) \n    \n    xs_r_t =bisect_left(st[\"s\"],s_r ) \n    t_l =st[\"s\"][xs_r_t -1] #\u24f8\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u5de6\uff09\n    t_r =st[\"s\"][xs_r_t   ] #\u24f8\u304b\u3089\u8fd1\u3044\u795e\u793e\uff08\u53f3\uff09\n    xs_r_t_l =abs(s_r -t_l) \n    xs_r_t_r =abs(s_r -t_r)\n    dt =min(xs_l +xs_l_t_l ,xs_l +xs_l_t_r ,xs_r +xs_r_t_l ,xs_r +xs_r_t_r)\n    print((min(ds,dt)))\n", "import bisect\na, b, q = map(int, input().split())\ns = [int(input()) for _ in range(a)]\nt = [int(input()) for _ in range(b)]\nx = [int(input()) for _ in range(q)]\nfor r in x:\n    k = bisect.bisect(s, r)\n    l = bisect.bisect(t, r)\n    ans = 10 ** 11\n    if k < a and l < b:\n        ans = min(ans, max(s[k], t[l]) - r)\n    if k > 0 and l > 0:\n        ans = min(ans, r - min(s[k-1], t[l-1]))\n    if k < a and l > 0:\n        ans = min(ans, s[k] + r - t[l-1] * 2, s[k] * 2 - r - t[l-1])\n    if k > 0 and l < b:\n        ans = min(ans, t[l] + r - s[k-1] * 2, t[l] * 2 - r - s[k-1])\n    print(ans)", "import bisect\n\nA, B, Q=map(int, input().split())\ns=[int(input()) for _ in range(A)]\nt=[int(input()) for _ in range(B)]\nx=[int(input()) for _ in range(Q)]\n\nst=[0]*A\nts=[0]*B\n\nfor i in range(A):\n  tmp=bisect.bisect_left(t, s[i])\n  if tmp==0:\n    st[i]=t[0]-s[i]\n  elif tmp==B:\n    st[i]=s[i]-t[-1]\n  else:\n    st[i]=min(s[i]-t[tmp-1], t[tmp]-s[i])\n    \nfor i in range(B):\n  tmp=bisect.bisect_left(s, t[i])\n  if tmp==0:\n    ts[i]=s[0]-t[i]\n  elif tmp==A:\n    ts[i]=t[i]-s[-1]\n  else:\n    ts[i]=min(t[i]-s[tmp-1], s[tmp]-t[i])\n\nfor i in range(Q):\n  cand=set()\n  tmp=bisect.bisect_left(s, x[i])\n  if tmp>0:\n    cand.add(x[i]-s[tmp-1]+st[tmp-1])\n  if tmp<A:\n    cand.add(s[tmp]-x[i]+st[tmp])\n    \n  tmp=bisect.bisect_left(t, x[i])\n  if tmp>0:\n    cand.add(x[i]-t[tmp-1]+ts[tmp-1])\n  if tmp<B:\n    cand.add(t[tmp]-x[i]+ts[tmp])\n    \n  print(min(cand))", "from bisect import *\na, b, q = map(int,input().split())\ns = [int(input()) for _ in range(a)]\nt = [int(input()) for _ in range(b)]\ninf = 10 ** 18\ns = [-inf] + s + [inf]\nt = [-inf] + t + [inf]\n\nfor i in range(q):\n    x = int(input())\n    s_ind = bisect_left(s, x)\n    t_ind = bisect_left(t, x)\n    \n    res = inf\n    for cand_s in [s[s_ind - 1], s[s_ind]]:\n        for cand_t in [t[t_ind - 1], t[t_ind]]:\n            st = abs(cand_s - cand_t)\n            dx = min(abs(cand_s - x), abs(cand_t - x))\n            \n            res = min(res, st + dx)\n    \n    print(res)", "import sys\nfrom bisect import bisect_left\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B, Q = list(map(int, readline().split()))\n    S = [-INF] + [int(readline()) for _ in range(A)] + [INF]\n    T = [-INF] + [int(readline()) for _ in range(B)] + [INF]\n    X = [int(readline()) for _ in range(Q)]\n\n    ans = [INF] * Q\n    for i, x in enumerate(X):\n        idx_s = bisect_left(S, x)\n        idx_t = bisect_left(T, x)\n\n        for s in (S[idx_s - 1], S[idx_s]):\n            for t in (T[idx_t - 1], T[idx_t]):\n                ans[i] = min(ans[i], abs(x - s) + abs(s - t), abs(x - t) + abs(t - s))\n\n    print(('\\n'.join(map(str, ans))))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a,b,q = map(int, input().split())\n\ns = [int(input()) for i in range(a)]\nt = [int(input()) for i in range(b)]\n\nimport bisect\n\nfor i in range(q):\n    s2 = 10**12\n    t2 = 10**12\n    qq = int(input())\n    sp = bisect.bisect(s,qq)\n    tp = bisect.bisect(t,qq)\n    s1 = s[sp-1]\n    if sp <a:\n        s2 = s[sp]\n\n    t1 = t[tp-1]\n    if tp <b:\n        t2 = t[tp]\n    print(min(abs(qq-s1)+abs(s1-t1),abs(qq-s1)+abs(s1-t2),\n              abs(qq-s2)+abs(s2-t1),abs(qq-s2)+abs(s2-t2),\n              abs(qq-t1)+abs(t1-s1),abs(qq-t1)+abs(t1-s2),\n              abs(qq-t2)+abs(t2-s1),abs(qq-t2)+abs(t2-s2)))", "from bisect import bisect_left\nfrom itertools import product\nfrom sys import maxsize\n\na, b, q = list(map(int, input().split()))\ns = [-maxsize] + [int(input()) for _ in range(a)] + [maxsize]\nt = [-maxsize] + [int(input()) for _ in range(b)] + [maxsize]\n\nfor _ in range(q):\n    x = int(input())\n    i = bisect_left(s, x)\n    j = bisect_left(t, x)\n    res = maxsize\n    for ss, tt in product((s[i-1], s[i]), (t[j-1], t[j])):\n        res = min(res, abs(ss-x)+abs(tt-ss), abs(tt-x)+abs(ss-tt))\n    print(res)\n", "from bisect import bisect_left\na,b,q = list(map(int,input().split()))\nINF = 10**15\ns = [-INF] + sorted([int(input()) for _  in range(a)]) + [INF]\nt = [-INF] + sorted([int(input()) for _  in range(b)]) + [INF]\n#print(s,t)\nfor i in range(q):\n    pro = int(input())\n    s_index = bisect_left(s, pro)\n    t_index = bisect_left(t, pro)\n    s1,s2 = s[s_index-1] , s[s_index]\n    t1,t2 = t[t_index-1] , t[t_index]\n    #print(s1,s2,t1,t2)\n    minimum = []\n    kouho1 = abs(pro-s1)+ abs(s1-t1)\n    minimum.append(kouho1)\n    kouho2 = abs(pro-s1)+ abs(s1-t2)\n    minimum.append(kouho2)\n    kouho3 = abs(pro-t1)+ abs(t1-s1)\n    minimum.append(kouho3)\n    kouho4 = abs(pro-t2)+ abs(t2-s1)\n    minimum.append(kouho4)\n    kouho5 = abs(pro-s2)+ abs(s2-t1)\n    minimum.append(kouho5)\n    kouho6 = abs(pro-s2)+ abs(s2-t2)\n    minimum.append(kouho6)\n    kouho7 = abs(pro-t1)+ abs(s2-t1)\n    minimum.append(kouho7)\n    kouho8 = abs(pro-t2)+ abs(s2-t2)\n    minimum.append(kouho8)\n    print((min(minimum)))\n", "# https://img.atcoder.jp/abc119/editorial.pdf\nimport bisect\nA, B, Q = map(int, input().split())\nINF = 10 ** 18\ns = [-INF] + [int(input()) for i in range(A)] + [INF]\nt = [-INF] + [int(input()) for i in range(B)] + [INF]\nfor q in range(Q):\n    x = int(input())\n    b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x)\n    res = INF\n    for S in [s[b - 1], s[b]]:\n        for T in [t[d - 1], t[d]]:\n            d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)\n            res = min(res, d1, d2)\n    print(res)", "import sys\nfrom bisect import bisect_left\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B, Q = list(map(int, readline().split()))\n    S = [int(readline()) for _ in range(A)]\n    T = [int(readline()) for _ in range(B)]\n    X = [int(readline()) for _ in range(Q)]\n\n    ans = [INF] * Q\n    vs = [0] * 2\n    vt = [0] * 2\n    for i, x in enumerate(X):\n        idx_s = bisect_left(S, x)\n        idx_t = bisect_left(T, x)\n\n        vs[0] = S[idx_s - 1] if idx_s > 0 else -INF\n        vt[0] = T[idx_t - 1] if idx_t > 0 else -INF\n        vs[1] = S[idx_s] if idx_s < A else INF\n        vt[1] = T[idx_t] if idx_t < B else INF\n\n        for s in vs:\n            for t in vt:\n                ans[i] = min(ans[i], abs(x - s) + abs(s - t), abs(x - t) + abs(t - s))\n\n    print(('\\n'.join(map(str, ans))))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nA,B,Q=map(int,input().split())\nINF=10**18\nS=[-INF]+[int(input()) for i in range(A)]+[INF]\nT=[-INF]+[int(input()) for i in range(B)]+[INF]\nfor q in range(Q):\n    x=int(input())\n    i=bisect.bisect_right(S,x)\n    j=bisect.bisect_right(T,x)\n    d=INF\n    for s in [S[i-1],S[i]]:\n        for t in [T[j-1],T[j]]:\n            d1=abs(s-x)+abs(s-t)\n            d2=abs(t-x)+abs(s-t)\n            d=min(d,d1,d2)\n    print(d)", "def is_not_less_than(ls, ind, key):\n    if ls[ind] >= key:\n        return True\n    else:\n        return False\ndef return_min_ind_whose_value_not_less_than(ls,key):\n    r = len(ls)\n    l = -1\n    while True:\n        next_ind = (r+l) // 2\n        if is_not_less_than(ls, next_ind, key):\n            r = next_ind\n        else:\n            l = next_ind\n        if r - l == 1:\n            return r\nn_shrine,n_temple,Q = list(map(int,input().split()))\nshrine_ls = [0] * (n_shrine+1)\ntemple_ls = [0] * (n_temple+1)\nQ_ls = [0] * Q\nfor i in range(n_shrine):\n    shrine_ls[i] = int(input())\nshrine_ls[-1] = float('inf')\nfor i in range(n_temple):\n    temple_ls[i] = int(input())\ntemple_ls[-1] = float('inf')\nfor i in range(Q):\n    Q_ls[i] = int(input())\n\nfor q in Q_ls:\n    i_Rshrine = return_min_ind_whose_value_not_less_than(shrine_ls,q)\n    Rshrine = shrine_ls[i_Rshrine]\n    i_Lshrine = i_Rshrine-1\n    Lshrine = shrine_ls[i_Lshrine]\n\n    i_Rtemple = return_min_ind_whose_value_not_less_than(temple_ls,q)\n    Rtemple = temple_ls[i_Rtemple]\n    i_Ltemple = i_Rtemple-1\n    Ltemple = temple_ls[i_Ltemple]\n    # Temple,Shrine\u5171\u306b\u53f3\n    RR = max(Rtemple,Rshrine) - q\n    # Temple,Shrine\u5171\u306b\u5de6\n    if i_Lshrine >= 0 and i_Ltemple >= 0:\n        LL = abs(min(Ltemple,Lshrine)-q)\n    else:\n        LL = float('inf')\n    #\u53f3temple\u3068\u5de6shrine\n    if i_Lshrine >= 0:\n        RtLs = 2*min(Rtemple-q,q-Lshrine) + max(Rtemple-q,q-Lshrine)\n    else:\n        RtLs = float('inf')\n    # \u5de6temple\u3068\u53f3shrine\n    if i_Ltemple >= 0:\n        LtRs = 2*min(Rshrine-q,q-Ltemple) + max(Rshrine-q,q-Ltemple)\n    else:\n        LtRs = float('inf')\n\n    print((min(LL,RR,RtLs,LtRs)))\n\n", "import bisect\na,b,q = map(int, input().split())\nINF = 10**18\ns = [int(input()) for i in range(a)]\ns = [-INF] + s + [INF]\nt = [int(input()) for i in range(b)]\nt = [-INF] + t + [INF]\ns.sort()\nt.sort()\nfor i in range(q):\n  ans = 10**11\n  x = int(input())\n  c = bisect.bisect_left(s,x)\n  e1,e2 = s[c-1],s[c]\n  f = bisect.bisect_left(t,e1)\n  f1,f2 = t[f-1],t[f]\n  ans = min(ans,abs(x-e1)+abs(e1-f1),abs(x-e1)+abs(e1-f2))\n  f = bisect.bisect_left(t,e2)\n  f1,f2 = t[f-1],t[f]\n  ans = min(ans,abs(x-e2)+abs(e2-f1),abs(x-e2)+abs(e2-f2))\n  d = bisect.bisect_left(t,x)\n  f1,f2 = t[d-1],t[d]\n  e = bisect.bisect_left(s,f1)\n  e1,e2 = s[e-1],s[e]\n  ans = min(ans,abs(x-f1)+abs(f1-e1),abs(x-f1)+abs(f1-e2))\n  e = bisect.bisect_left(s,f2)\n  e1,e2 = s[e-1],s[e]\n  ans = min(ans,abs(x-f2)+abs(f2-e1),abs(x-f2)+abs(f2-e2))\n  print (ans)", "# coding: utf-8\n\nimport bisect\n\nA,B,Q = map(int, input().split())\n*S, = [int(input()) for _ in range(A)]\n*T, = [int(input()) for _ in range(B)]\n*X, = [int(input()) for _ in range(Q)]\n\nfor x in X:\n    # 2\u5206\u63a2\u7d22\u3067\u3001\u300c\u73fe\u5728\u5730\u300d\u3068\u795e\u793e\u7fa4\u306e\u4f4d\u7f6e\u95a2\u4fc2\u3092\u63a2\u308b\n    sx = bisect.bisect(S, x)\n    # \u73fe\u5728\u5730\u304b\u3089\u898b\u3066\u6771\u5074\u3067\u6700\u3082\u8fd1\u3044\u795e\u793e\n    try:\n        se = S[sx]\n    except:\n        # \u6771\u5074\u306b\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306f\u3001\u795e\u793e\u7fa4\u306e\u4e2d\u3067\u306e\u6700\u6771\n        se = S[-1]\n    # \u73fe\u5728\u5730\u304b\u3089\u898b\u3066\u897f\u5074\u3067\u6700\u3082\u8fd1\u3044\u795e\u793e\n    try:\n        sw = S[sx-1]\n    except:\n        # \u897f\u5074\u306b\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306f\u3001\u795e\u793e\u7fa4\u306e\u4e2d\u3067\u306e\u6700\u897f\n        sw = S[0]\n\n    tx = bisect.bisect(T, x)\n    # \u73fe\u5728\u5730\u304b\u3089\u898b\u3066\u6771\u5074\u3067\u6700\u3082\u8fd1\u3044\u304a\u5bfa\n    try:\n        te = T[tx]\n    except:\n        # \u6771\u5074\u306b\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306f\u3001\u304a\u5bfa\u7fa4\u306e\u4e2d\u3067\u306e\u6700\u6771\n        te = T[-1]\n    # \u73fe\u5728\u5730\u304b\u3089\u898b\u3066\u897f\u5074\u3067\u6700\u3082\u8fd1\u3044\u304a\u5bfa\n    try:\n        tw = T[tx-1]\n    except:\n        # \u897f\u5074\u306b\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306f\u3001\u304a\u5bfa\u7fa4\u306e\u4e2d\u3067\u306e\u6700\u897f\n        tw = T[0]\n\n    # \u5019\u88dc (8\u901a\u308a) \u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\n    # \u6771\u795e\u793e -> \u6771\u5bfa\n    # \u6771\u5bfa -> \u6771\u795e\u793e\n    # \u6771\u795e\u793e -> \u897f\u5bfa\n    # \u897f\u5bfa -> \u6771\u795e\u793e\n    # \u897f\u795e\u793e -> \u6771\u5bfa\n    # \u6771\u5bfa -> \u897f\u795e\u793e\n    # \u897f\u795e\u793e -> \u897f\u5bfa\n    # \u897f\u5bfa -> \u897f\u795e\u793e\n    routes = []\n    for s in [se, sw]:\n        for t in [te, tw]:\n            routes.append(abs(s - x)+abs(t - s))\n            routes.append(abs(t - x)+abs(s - t))\n\n    # \u6700\u5c0f\u8ddd\u96e2\u3092\u9078\u3076\n    print(min(routes))", "import bisect\nA,B,Q = map(int,input().split())\nINF = float('inf')\nS = [-INF]+[int(input()) for i in range(A)]+[INF]\nT = [-INF]+[int(input()) for i in range(B)]+[INF]\nfor q in range(Q):\n    x = int(input())\n    i = bisect.bisect_right(S,x)\n    j = bisect.bisect_right(T,x)\n    d = INF\n    for s in [S[i-1],S[i]]:\n        for t in [T[j-1],T[j]]:\n            d1 = abs(s-x)+abs(s-t)\n            d2 = abs(t-x)+abs(s-t)\n            d = min(d,d1,d2)\n    print(d)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    A, B, Q = LI()\n    s = [I() for _ in range(A)]\n    t = [I() for _ in range(B)]\n\n    # x\u304b\u3089\u4e00\u756a\u8fd1\u3044\u795e\u793e\u306b\u884c\u304f\u2192\u305d\u306e\u795e\u793e\u304b\u3089\u4e00\u756a\u8fd1\u3044\u5bfa\u306b\u884c\u304f\u3001\u307e\u305f\u306f\u305d\u306e\u9006\u306e2\u30d1\u30bf\u30fc\u30f3\n\n    # \u5404\u795e\u793e\u306b\u5bfe\u3059\u308b\u4e00\u756a\u8fd1\u3044\u5bfa\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u3066\u304a\u304f\n    len_of_nearest_t = [INF] * A\n    for i in range(A):\n        idx = bisect.bisect_left(t, s[i])\n        len_r = t[idx] - s[i] if 0 <= idx < B else INF\n        len_l = s[i] - t[idx-1] if 0 <= idx - 1 < B else INF\n        len_of_nearest_t[i] = min(len_l, len_r)\n    # print(len_of_nearest_t)\n\n    # \u5404\u5bfa\u306b\u5bfe\u3059\u308b\u4e00\u756a\u8fd1\u3044\u795e\u793e\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u3066\u304a\u304f\n    len_of_nearest_s = [INF] * B\n    for i in range(B):\n        idx = bisect.bisect_left(s, t[i])\n        len_r = s[idx] - t[i] if 0 <= idx < A else INF\n        len_l = t[i] - s[idx-1] if 0 <= idx - 1 < A else INF\n        len_of_nearest_s[i] = min(len_l, len_r)\n    # print(len_of_nearest_s)\n\n    for _ in range(Q):\n        x = I()\n        # \u795e\u793e\u2192\u5bfa\n        idx = bisect.bisect_left(s, x)\n        len_r = s[idx] - x + len_of_nearest_t[idx] if 0 <= idx < A else INF\n        len_l = x - s[idx-1] + len_of_nearest_t[idx-1] if 0 <= idx - 1 < A else INF\n        len_x_s_t = min(len_r, len_l)\n        # \u5bfa\u2192\u795e\u793e\n        idx = bisect.bisect_left(t, x)\n        len_r = t[idx] - x + len_of_nearest_s[idx] if 0 <= idx < B else INF\n        len_l = x - t[idx-1] + len_of_nearest_s[idx-1] if 0 <= idx - 1 < B else INF\n        len_x_t_s = min(len_r, len_l)\n        print((min(len_x_s_t, len_x_t_s)))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom bisect import bisect_right\n\ndef main():\n    A, B, Q = list(map(int, input().split()))\n    s = [int(input()) for _ in range(A)]\n    t = [int(input()) for _ in range(B)]\n    # print(s,t)\n    s = [-10**12] + s + [10**12]\n    t = [-10**12] + t + [10**12]\n\n    for _ in range(Q):\n        x = int(input())\n        i = bisect_right(s,x)\n        j = bisect_right(t,x)\n        # print(i,j,x)\n        ans = []\n\n        ans.append(max(abs(s[i-1] - x), abs(t[j-1] - x)))\n        ans.append(max(abs(s[i] - x), abs(t[j] - x)))\n        ans.append(abs(s[i-1] - x) + abs(t[j] - x) + min(abs(s[i-1]-x), abs(t[j]-x)))\n        ans.append(abs(s[i] - x) + abs(t[j-1] - x) + min(abs(s[i]-x), abs(t[j-1]-x)))\n\n        print((min(ans)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom bisect import bisect_left\n\ninput = sys.stdin.readline\n\n\ndef solve(Q, S, T, X):\n    ans = [0] * Q\n    INF = 10 ** 11\n    for q, x in enumerate(X):\n        min_dist = INF\n        i_s = bisect_left(S, x)\n        i_t = bisect_left(T, x)\n        for s in (S[i_s - 1], S[i_s]):\n            for t in (T[i_t - 1], T[i_t]):\n                dist_s2t = abs(x - s) + abs(s - t)\n                dist_t2s = abs(x - t) + abs(t - s)\n                min_dist = min(min_dist, dist_s2t, dist_t2s)\n        ans[q] = min_dist\n    return ans\n\n\ndef main():\n    A, B, Q = list(map(int, input().split()))\n    S = [0] * (A + 2)\n    T = [0] * (B + 2)\n    X = [0] * Q\n    for i in range(1, A + 1):\n        S[i] = int(input())\n    for i in range(1, B + 1):\n        T[i] = int(input())\n    for i in range(Q):\n        X[i] = int(input())\n\n    S[0] = T[0] = -10 ** 11\n    S[-1] = T[-1] = 10 ** 11\n\n    ans = solve(Q, S, T, X)\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left,bisect\na,b,q = map(int,input().split())\njin = [-10**16]\nfor i in range(a):\n    jin.append(int(input()))\njin.append(10**16)\ntera = [-10**20]\nfor i in range(b):\n    tera.append(int(input()))\ntera.append(10**20)\nfor i in range(q):\n    x = int(input())\n    j = bisect(jin,x)\n    t = bisect(tera,x)\n    j1 = jin[j]\n    j2 = jin[j-1]\n    t1 = tera[t]\n    t2 = tera[t-1]\n    ans = min(abs(x-j1)+abs(j1-t1),abs(x-j1)+abs(j1-t2),abs(x-j2)+abs(j2-t1),abs(x-j2)+abs(j2-t2))\n    ans = min(ans,abs(x-t1)+abs(t1-j1),abs(x-t1)+abs(t1-j2),abs(x-t2)+abs(t2-j1),abs(x-t2)+abs(t2-j2))\n    print(ans)", "import bisect\na, b, q = map(int, input().split())\nss = [int(input()) for _ in range(a)]\nts = [int(input()) for _ in range(b)]\nxs = [int(input()) for _ in range(q)]\nss = [-float('inf')] + ss + [float('inf')]\nts = [-float('inf')] + ts + [float('inf')]\nfor x in xs:\n    s_r = bisect.bisect_left(ss, x)\n    t_r = bisect.bisect_left(ts, x)\n    s_l = s_r - 1\n    t_l = t_r - 1\n    res = float('inf')\n    if ss[s_l] > ts[t_l]:\n        res = min(res, x - ts[t_l], (x - ss[s_l])*2 + (ts[t_r] - x))\n    elif ss[s_l] < ts[t_l]:\n        res = min(res, x - ss[s_l], (x - ts[t_l])*2 + (ss[s_r] - x))\n    else:\n        res = min(res, (x - ss[s_l])*2 + (ss[s_r] - x), x - ss[s_l]*2 + (ts[t_r] - x))\n    if ss[s_r] > ts[t_r]:\n        res = min(res, ss[s_r] - x, (ts[t_r] - x)*2 + (x - ss[s_l]))\n    elif ss[s_r] < ts[t_r]:\n        res = min(res, ts[t_r] - x, (ss[s_r] - x)*2 + (x - ts[t_l]))\n    else:\n        res = min(res, (ss[s_r] - x)*2 + (x - ss[s_l]), (ss[s_r] - x)*2 + (x - ts[t_l]))\n    print(res)", "import bisect\nA,B,Q=map(int,input().split())\ns=[-10**15]\nt=[-10**15]\nans=[]\nfor _ in range(A):\n    s.append(int(input()))\nfor _ in range(B):\n    t.append(int(input()))\ns.append(10**15)\nt.append(10**15)\ndef search(a,b,q):\n    dis=10**15\n    S=[s[a-1],s[a]]\n    T=[t[b-1],t[b]]\n    for i in range(2):\n        for j in range(2):\n            A=min(abs(S[i]-q),abs(T[j]-q))+abs(S[i]-T[j])\n            dis=min(dis,A)\n    return dis\nfor _ in range(Q):\n    q=int(input())\n    r=bisect.bisect_left(s,q)\n    l=bisect.bisect_left(t,q)\n    ans.append(search(r,l,q))\nfor i in ans:\n    print(i)", "import bisect\n\na, b, q = list(map(int, input().split()))\n\ns = [- 10 ** 19]\nfor i in range(a):\n    s.append(int(input()))\ns.append(10 ** 19)\n\nt = [- 10 ** 19]\nfor i in range(b):\n    t.append(int(input()))\nt.append(10 ** 19)\n\nfor i in range(q):\n    x = int(input())\n    ps = bisect.bisect_right(s, x)\n    pt = bisect.bisect_right(t, x)\n    ret = 10 ** 19\n    for loc1 in (s[ps], s[ps-1]):\n        for loc2 in (t[pt], t[pt-1]):\n            val = min(abs(x-loc1) + abs(loc1-loc2),\n                      abs(x-loc2) + abs(loc1-loc2))\n            ret = min(ret, val)\n    print(ret)\n", "from bisect import bisect\n\nA, B, Q = list(map(int, input().split()))\nINF = 10 ** 18\nS = [-INF]\nT = [-INF]\nfor i in range(A):\n    S.append(int(input()))\nfor i in range(B):\n    T.append(int(input()))\nS.append(INF)\nT.append(INF)\nfor i in range(Q):\n    x = int(input())\n    sr = bisect(S, x)\n    sl = sr - 1\n    tr = bisect(T, x)\n    tl = tr - 1\n    def d(y): return abs(x - y)\n    ans = min(d(max(S[sr], T[tr])), d(min(S[sl], T[tl])))\n    ans = min(ans, 2 * d(S[sr]) + d(T[tl]))\n    ans = min(ans, d(S[sr]) + 2 * d(T[tl]))\n    ans = min(ans, 2 * d(S[sl]) + d(T[tr]))\n    ans = min(ans, d(S[sl]) + 2 * d(T[tr]))\n    print(ans)\n", "import bisect\n\nA, B, Q = list(map(int, input().split()))\nINF = 10**18\nS = [-INF] + [int(input()) for i in range(A)] + [INF]\nT = [-INF] + [int(input()) for i in range(B)] + [INF]\nX = [int(input()) for i in range(Q)]\n\n\nfor x in X:\n    d = float(\"inf\")\n    i = bisect.bisect_right(S, x)\n    j = bisect.bisect_right(T, x)\n    for s in [S[i-1], S[i]]:\n        for t in [T[j-1], T[j]]:\n            d1 = abs(s-x) + abs(t-s)\n            d2 = abs(t-x) + abs(t-s)\n            d = min(d, d1, d2)\n    print(d)\n", "import sys\nfrom bisect import bisect_left\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B, Q = list(map(int, readline().split()))\n    S = [int(readline()) for _ in range(A)]\n    T = [int(readline()) for _ in range(B)]\n    X = [int(readline()) for _ in range(Q)]\n\n    ans = [0] * Q\n    vs = [0] * 2\n    vt = [0] * 2\n    for i, x in enumerate(X):\n        idx_s = bisect_left(S, x)\n        idx_t = bisect_left(T, x)\n\n        vs[0] = S[idx_s - 1] if idx_s > 0 else -INF\n        vt[0] = T[idx_t - 1] if idx_t > 0 else -INF\n        vs[1] = S[idx_s] if idx_s < A else INF\n        vt[1] = T[idx_t] if idx_t < B else INF\n\n        ans[i] = min(\n            abs(x - vs[0]) + abs(vs[0] - vt[0]),\n            abs(x - vt[0]) + abs(vt[0] - vs[0]),\n            abs(x - vs[0]) + abs(vs[0] - vt[1]),\n            abs(x - vt[0]) + abs(vt[0] - vs[1]),\n            abs(x - vs[1]) + abs(vs[1] - vt[1]),\n            abs(x - vt[1]) + abs(vt[1] - vs[1]),\n            abs(x - vs[1]) + abs(vs[1] - vt[0]),\n            abs(x - vt[1]) + abs(vt[1] - vs[0]),\n        )\n\n    print(('\\n'.join(map(str, ans))))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\n\na, b, q = map(int, input().split())\nINF = float('inf')\ns = [-INF] + [int(input()) for _ in range(a)] + [INF]\nt = [-INF] + [int(input()) for _ in range(b)] + [INF]\nx = [int(input()) for _ in range(q)]\n\nfor i in x:\n    si = bisect.bisect_left(s, i)\n    ti = bisect.bisect_left(t, i)\n    sl, sr = i-s[si-1], s[si]-i\n    tl, tr = i-t[ti-1], t[ti]-i\n    print(min(max(sl,tl), sl+tr+min(sl,tr), sr+tl+min(sr,tl), max(sr,tr)))", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n\na,b,q=MI()\nlis1=[I() for i in range(a)]\nlis2=[I() for i in range(b)]\nlis1.append(inf)\nlis2.append(inf)\nlis1=[-inf]+lis1\nlis2=[-inf]+lis2\n#print(lis1)\n#print(lis2)\nfor i in range(q):\n    u=I()\n    x=bisect_left(lis1,u)\n    y=bisect_left(lis2,u)\n    #print(u,x,y)\n    Lll=u-min(lis1[x-1],lis2[y-1])\n    Lrr=max(lis1[x],lis2[y])-u\n    Llr1=2*(u-lis1[x-1])+(lis2[y]-u)\n    Llr2=2*(lis2[y]-u)+u-lis1[x-1]\n    Lrl1=2*(u-lis2[y-1])+lis1[x]-u\n    Lrl2=2*(lis1[x]-u)+u-lis2[y-1]\n    #print(Lll,Lrr,Lrl1,Lrl2,Llr1,Llr2)\n    print((min(Lll,Lrr,Lrl1,Lrl2,Llr1,Llr2)))\n    \n    \n    \n    \n\n", "import bisect\nA,B,Q=map(int,input().split())\nINF=10**18\nS=[-INF]+[int(input()) for i in range(A)]+[INF]\nT=[-INF]+[int(input()) for i in range(B)]+[INF]\nfor q in range(Q):\n    x=int(input())\n    i=bisect.bisect_right(S,x)\n    j=bisect.bisect_right(T,x)\n    d=INF\n    for s in [S[i-1],S[i]]:\n        for t in[T[j-1],T[j]]:\n            d1=abs(s-x)+abs(s-t)\n            d2=abs(t-x)+abs(s-t)\n            d=min(d,d1,d2)\n    print(d)", "import bisect\n\na, b, q = map(int, input().split())\ns = []\nfor i in range(a):\n    s.append(int(input()))\ns.sort()\nt = []\nfor i in range(b):\n    t.append(int(input()))\nt.sort()\n\nfor i in range(q):\n    x = int(input())\n    temp_s = bisect.bisect(s, x)\n    temp_t = bisect.bisect(t, x)\n    temp = float(\"inf\")\n    if temp_s == 0:\n        num = (s[0],)\n    elif temp_s == a:\n        num = (s[a - 1],)\n    else:\n        num = (s[temp_s - 1], s[temp_s])\n    for j in num:\n        temp2 = bisect.bisect(t, j)\n        if temp2 == 0:\n            num2 = (t[0],)\n        elif temp2 == b:\n            num2 = (t[b - 1],)\n        else:\n            num2 = (t[temp2 - 1], t[temp2])\n        for k in num2:\n            temp = min(temp, abs(x - j) + abs(j - k))\n    if temp_t == 0:\n        num = (t[0],)\n    elif temp_t == b:\n        num = (t[b - 1],)\n    else:\n        num = (t[temp_t - 1], t[temp_t])\n    for j in num:\n        temp2 = bisect.bisect(s, j)\n        if temp2 == 0:\n            num2 = (s[0],)\n        elif temp2 == a:\n            num2 = (s[a - 1],)\n        else:\n            num2 = (s[temp2 - 1], s[temp2])\n        for k in num2:\n            temp = min(temp, abs(x - j) + abs(j - k))\n    print(temp)", "import sys\nfrom bisect import bisect_left\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    A, B, Q = list(map(int, readline().split()))\n    S = [-INF]\n    S.extend(int(readline()) for _ in range(A))\n    S.append(INF)\n    T = [-INF]\n    T.extend(int(readline()) for _ in range(B))\n    T.append(INF)\n    X = [int(readline()) for _ in range(Q)]\n\n    ans = [INF] * Q\n    for i, x in enumerate(X):\n        i1 = bisect_left(S, x)\n        i2 = bisect_left(T, x)\n\n        ans[i] = min(\n            abs(x - S[i1 - 1]) + abs(S[i1 - 1] - T[i2 - 1]),\n            abs(x - T[i2 - 1]) + abs(T[i2 - 1] - S[i1 - 1]),\n            abs(x - S[i1 - 1]) + abs(S[i1 - 1] - T[i2]),\n            abs(x - T[i2 - 1]) + abs(T[i2 - 1] - S[i1]),\n            abs(x - S[i1]) + abs(S[i1] - T[i2]),\n            abs(x - T[i2]) + abs(T[i2] - S[i1]),\n            abs(x - S[i1]) + abs(S[i1] - T[i2 - 1]),\n            abs(x - T[i2]) + abs(T[i2] - S[i1 - 1]),\n        )\n\n    print(('\\n'.join(map(str, ans))))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nfrom functools import reduce\ndef s(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return list(map(int,input().split()))\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\ndef gcd(*numbers): reduce(math.gcd, numbers)\nsys.setrecursionlimit(10 ** 9)\nmod = 10**9+7\ncount = 0\nans = 0\n\nA, B, Q = I()\ninf = float(\"inf\")\ns = [-inf]+sorted([k() for _ in range(A)])+[inf]\nt = [-inf]+sorted([k() for _ in range(B)])+[inf]\naa = []\n\nfor i in range(Q):\n    q = k()\n    S = bisect.bisect(s,q)\n    T = bisect.bisect(t,q)\n    ans = inf\n    for j in [s[S-1],s[S]]:\n        for z in [t[T-1],t[T]]:\n            x = abs(j-q)+abs(j-z)\n            y = abs(z-q)+abs(j-z)\n            ans = min(ans,x,y)\n    aa.append(ans)\n\nfor i in aa:\n    print(i)\n", "A, B, Q = map(int, input().split())\nS = [-10**18]+sorted([int(input()) for _ in range(A)])+[10**18]\nT = [-10**18]+sorted([int(input()) for _ in range(B)])+[10**18]\nimport bisect\nfor _ in range(Q):\n  x = int(input())\n  i = bisect.bisect_left(S, x)\n  j = bisect.bisect_left(T, x)\n  p, q, r, s = S[i-1], S[i], T[j-1], T[j]\n  res = 10**18\n  for a in (p, q):\n    for b in (r, s):\n      res = min(res, abs(x-a)+abs(a-b), abs(x-b)+abs(a-b))\n  print(res)", "import bisect\nA, B, Q = map(int, input().split())\ns = list(int(input()) for _ in range(A))\nt = list(int(input()) for _ in range(B))\n\nfor i in range(Q):\n    ans = 10 ** 19\n    x = int(input())\n    stmp1 = bisect.bisect_left(s, x)\n    for j in range(2):\n        if stmp1 == 0 and j == 1:\n            continue\n        if stmp1 == A and j == 0:\n            continue\n        ttmp1 = bisect.bisect_left(t, s[stmp1 - j])\n        ktmp = 10 ** 11\n        if ttmp1 != 0:\n            ktmp = min(ktmp, abs(s[stmp1 - j] - t[ttmp1 - 1]))\n        if ttmp1 != B:\n            ktmp = min(ktmp, abs(s[stmp1 - j] - t[ttmp1]))\n        total = abs(x - s[stmp1 - j]) + ktmp\n        ans = min(ans, total)\n\n    ttmp1 = bisect.bisect_left(t, x)\n    for j in range(2):\n        if ttmp1 == 0 and j == 1:\n            continue\n        if ttmp1 == B and j == 0:\n            continue\n        stmp1 = bisect.bisect_left(s, t[ttmp1 - j])\n        ktmp = 10 ** 11\n        if stmp1 != 0:\n            ktmp = min(ktmp, abs(t[ttmp1 - j] - s[stmp1 - 1]))\n        if stmp1 != A:\n            ktmp = min(ktmp, abs(t[ttmp1 - j] - s[stmp1]))\n        total = abs(x - t[ttmp1 - j]) + ktmp\n        ans = min(ans, total)\n    print(ans)"]
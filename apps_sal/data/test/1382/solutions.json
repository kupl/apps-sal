["def read_data():\n    n, m = list(map(int, input().split()))\n    Es = [[] for v in range(n)]\n    for e in range(m):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        Es[a].append(b)\n        Es[b].append(a)\n    return n, m, Es\n\ndef solve(n, m, Es):\n    if m == 0:\n        return 3, n * (n - 1) * (n - 2) // 6\n    if max(list(map(len, Es))) == 1:\n        return 2, m * (n-2)\n    patterns = 0\n    color = [0] * n\n    for u in range(n):\n        if color[u]:\n            continue\n        color[u] = 1\n        stack = [u]\n        n_color = [1, 0]\n        while stack:\n            v = stack.pop()\n            prev_color = color[v]\n            for w in Es[v]:\n                current_color = color[w]\n                if current_color == prev_color:\n                    return 0, 1\n                if current_color == 0:\n                    color[w] = - prev_color\n                    n_color[(prev_color + 1)//2] += 1\n                    stack.append(w)\n        n_even = n_color[0]\n        n_odd = n_color[1]\n        patterns += n_even * (n_even - 1) // 2 + n_odd * (n_odd - 1) // 2\n    return 1, patterns\n\ndef __starting_point():\n    n, m, Es = read_data()\n    print(*solve(n, m, Es))\n\n__starting_point()", "g = [[] for _ in range(100005)]\n\nn, m = list(map(int, input().split(' ')))\nfor i in range(m):\n    a, b = list(map(int, input().split(' ')))\n    g[a].append(b)\n    g[b].append(a)\n\ncolour = [0] * 100005\nv = [0] * 100005\n\ncycle = False\ntwo = True\ntwos = 0\nones = 0\nans = 0 \nfor i in range(1, n+1):\n    cs = 0\n    c1 = 0\n    c2 = 0\n    if (not colour[i]):\n        q = [i]\n        colour[i] = 1\n        while q:\n            cs += 1\n            top = q.pop()\n            if colour[top] == 1:\n                c1 += 1\n            else: c2 += 1\n            for j in g[top]:    \n                if colour[j] == colour[top]:\n                    cycle = True\n                elif colour[j] == 0:\n                    colour[j] = -colour[top]\n                    q = [j] + q\n        if cs > 2:\n            two = False\n            ans += ((c1*(c1-1))//2 + (c2*(c2-1))//2)\n        if cs == 2:\n            twos += 1\n            \n        if cs == 1:\n            ones += 1\nif cycle:\n    print(0, 1)\n    quit()\n\nif m == 0:\n    print(3, (n*(n-1)*(n-2)//6))\n    quit()\nif two:\n    print(2, twos*ones + 4 * (twos * (twos - 1) // 2))\n    quit()\nsumx = 0\nfor i in range(1, n+1):\n    ll = len(g[i])\n    sumx += ll * (ll-1) // 2\nprint(1, ans)\n", "# \u89e3\u8aacAC\n# \u4e8c\u90e8\u30b0\u30e9\u30d5\u3067\u306a\u3044\u30b0\u30e9\u30d5\u306e\u6027\u8cea\u3084\uff0c\u30d1\u30b9\u306e\u9577\u3055\u3092\u8003\u5bdf\u3059\u308b\n\ndef main():\n    N, M = (int(i) for i in input().split())\n\n    par = [i for i in range(N)]\n    size = [1 for i in range(N)]\n\n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            size[x] = size[par[x]]\n            return par[x]\n\n    def same(x, y):\n        return find(x) == find(y)\n\n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if size[x] < size[y]:\n            x, y = y, x\n        size[x] += size[y]\n        par[y] = x\n\n    def get_size(x):\n        return size[find(x)]\n\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n        union(a-1, b-1)\n\n    S = [False]*4\n    for i in range(N):\n        S[min(3, get_size(i))] = True\n        if S[3]:\n            break\n    t = 0\n    if S[3]:\n        t = 1\n    elif S[2]:\n        t = 2\n    else:\n        t = 3\n\n    color = [-1]*N\n\n    def dfs(s):\n        stack = [s]\n        color[s] = 0\n        b = 1\n        w = 0\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if color[u] != -1:\n                    if color[u] == color[v]:\n                        return False, b*w\n                    continue\n                color[u] = color[v] ^ 1\n                if color[u] == 0:\n                    b += 1\n                else:\n                    w += 1\n                stack.append(u)\n        return True, b*(b-1)//2 + w*(w-1)//2\n\n    is_bipartite, _ = dfs(0)\n    if is_bipartite:\n        w = 0\n        if t == 3:\n            w = N*(N-1)*(N-2)//3//2\n        elif t == 2:\n            used = [False]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) == 2:\n                    w += (N-2)\n                    used[find(i)] = True\n        elif t == 1:\n            used = [False]*N\n            color = [-1]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) >= 3:\n                    _, ways = dfs(i)\n                    w += ways\n                    used[find(i)] = True\n        print(t, w)\n    else:\n        print(0, 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    N, M = (int(i) for i in input().split())\n\n    par = [i for i in range(N)]\n    size = [1 for i in range(N)]\n\n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            size[x] = size[par[x]]\n            return par[x]\n\n    def same(x, y):\n        return find(x) == find(y)\n\n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if size[x] < size[y]:\n            x, y = y, x\n        size[x] += size[y]\n        par[y] = x\n\n    def get_size(x):\n        return size[find(x)]\n\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n        union(a-1, b-1)\n\n    S = [False]*4\n    for i in range(N):\n        S[min(3, get_size(i))] = True\n        if S[3]:\n            break\n    t = 0\n    if S[3]:\n        t = 1\n    elif S[2]:\n        t = 2\n    else:\n        t = 3\n\n    color = [-1]*N\n\n    def dfs(s):\n        stack = [s]\n        color[s] = 0\n        b = 1\n        w = 0\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if color[u] != -1:\n                    if color[u] == color[v]:\n                        return False, b*w\n                    continue\n                color[u] = color[v] ^ 1\n                if color[u] == 0:\n                    b += 1\n                else:\n                    w += 1\n                stack.append(u)\n        return True, b*(b-1)//2 + w*(w-1)//2\n\n    is_bipartite, _ = dfs(0)\n    if is_bipartite:\n        w = 0\n        if t == 3:\n            w = N*(N-1)*(N-2)//3//2\n        elif t == 2:\n            used = [False]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) == 2:\n                    w += (N-2)\n                    used[find(i)] = True\n        elif t == 1:\n            used = [False]*N\n            color = [-1]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) >= 3:\n                    _, ways = dfs(i)\n                    w += ways\n                    used[find(i)] = True\n        print(t, w)\n    else:\n        print(0, 1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    N, M = (int(i) for i in input().split())\n \n    par = [i for i in range(N)]\n    size = [1 for i in range(N)]\n \n    def find(x):\n        if par[x] == x:\n            return x\n        else:\n            par[x] = find(par[x])\n            size[x] = size[par[x]]\n            return par[x]\n \n    def same(x, y):\n        return find(x) == find(y)\n \n    def union(x, y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if size[x] < size[y]:\n            x, y = y, x\n        size[x] += size[y]\n        par[y] = x\n \n    def get_size(x):\n        return size[find(x)]\n \n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = (int(i) for i in input().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n        union(a-1, b-1)\n \n    S = [False]*4\n    for i in range(N):\n        S[min(3, get_size(i))] = True\n        if S[3]:\n            break\n    t = 0\n    if S[3]:\n        t = 1\n    elif S[2]:\n        t = 2\n    else:\n        t = 3\n \n    color = [-1]*N\n \n    def dfs(s):\n        stack = [s]\n        color[s] = 0\n        b = 1\n        w = 0\n        while stack:\n            v = stack.pop()\n            for u in G[v]:\n                if color[u] != -1:\n                    if color[u] == color[v]:\n                        return False, b*w\n                    continue\n                color[u] = color[v] ^ 1\n                if color[u] == 0:\n                    b += 1\n                else:\n                    w += 1\n                stack.append(u)\n        return True, b*(b-1)//2 + w*(w-1)//2\n \n    is_bipartite, _ = dfs(0)\n    if is_bipartite:\n        w = 0\n        if t == 3:\n            w = N*(N-1)*(N-2)//3//2\n        elif t == 2:\n            used = [False]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) == 2:\n                    w += (N-2)\n                    used[find(i)] = True\n        elif t == 1:\n            used = [False]*N\n            color = [-1]*N\n            for i in range(N):\n                if not used[find(i)] and get_size(i) >= 3:\n                    _, ways = dfs(i)\n                    w += ways\n                    used[find(i)] = True\n        print(t, w)\n    else:\n        print(0, 1)\n \n \ndef __starting_point():\n    main()\n\n__starting_point()"]
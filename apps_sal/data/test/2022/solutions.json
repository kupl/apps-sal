["import sys\nfrom math import ceil\ninput = sys.stdin.readline\n    \nn, m, req = map(int, input().split())\ne = [tuple(map(int, input().split())) for _ in range(m)]\ng = [[] for _ in range(n + 1)]\nfor u, v in e:\n    g[u].append(v)\n    g[v].append(u)\n    \n# req = 1\n# while req * req < n:\n#     req += 1\n    \ndef dfs():\n    dep = [0] * (n + 1)\n    par = [0] * (n + 1)\n    st = [1]\n    st2 = []\n    while st:\n        u = st.pop()\n        if dep[u]:\n            continue\n        st2.append(u)\n        dep[u] = dep[par[u]] + 1\n        for v in g[u]:\n            if not dep[v]:\n                par[v] = u\n                st.append(v)\n            elif 2 < dep[u] - dep[v] + 1 <= req:\n                cyc = []\n                while u != par[v]:\n                    cyc.append(u)\n                    u = par[u]\n                return (None, cyc)\n    mk = [0] * (n + 1)\n    iset = []\n    while st2:\n        u = st2.pop()\n        if not mk[u]:\n            iset.append(u)\n            for v in g[u]:\n                mk[v] = 1\n    return (iset[:ceil(req/2)], None)\n    \niset, cyc = dfs()\nif iset:\n    print(1)\n    print(*iset)\nelse:\n    print(2)\n    print(len(cyc))\n    print(*cyc)", "from sys import exit,stdin,stderr\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\nn, m, k = rl()\nadj = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    u, v = rl()\n    adj[u].append(v)\n    adj[v].append(u)\n\nlayers = [[] for depth in range(k)]\nposition = [None for _ in range(n + 1)]\nlayers[0] = [1]\nposition[1] = (0, None)\nfor depth in range(1, k):\n    for parent in layers[depth - 1]:\n        _, gp = position[parent]\n        for child in adj[parent]:\n            if child == gp:\n                continue\n            if position[child]:\n                depth2, parent2 = position[child]\n                path1 = []\n                while depth > depth2:\n                    path1.append(parent)\n                    depth, parent = position[parent]\n                path2 = []\n                while parent != parent2:\n                    path1.append(parent)\n                    path2.append(parent2)\n                    depth, parent = position[parent]\n                    depth2, parent2 = position[parent2]\n                path2.reverse()\n                path = path1 + [parent] + path2 + [child]\n                if len(path) <= k:\n                    print(2)\n                    print(len(path))\n                    print(*path)\n                else:\n                    print(1)\n                    print(*path[:k:2])\n                return\n            layers[depth].append(child)\n            position[child] = depth, parent\n\nprint(1)\nif layers[k - 1]:\n    print(*(layer[0] for layer in layers[::2]))\nelse:\n    k2 = (k + 1) // 2\n    r = [[], []]\n    for depth, layer in enumerate(layers):\n        ri = r[depth % 2]\n        ri += layer\n        if len(ri) >= k2:\n            print(*ri[:k2])\n            break\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm += ans[i]\n\t\t\tans[element] = m\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==1 and i!=self.parent[element]:\n\t\t\t\t\ts = i\n\t\t\t\t\te = element\n\t\t\t\t\tpath1 = [s]\n\t\t\t\t\tpath2 = [e]\n\t\t\t\t\twhile self.parent[s]!=-1:\n\t\t\t\t\t\ts = self.parent[s]\n\t\t\t\t\t\tpath1.append(s)\n\t\t\t\t\twhile self.parent[e]!=-1:\n\t\t\t\t\t\te = self.parent[e]\n\t\t\t\t\t\tpath2.append(e)\n\t\t\t\t\tfor i in range(-1,max(-len(path1),-len(path2))-1,-1):\n\t\t\t\t\t\tif path1[i]!=path2[i]:\n\t\t\t\t\t\t\treturn path1[0:i+1]+path2[i+1::-1]\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\t\treturn -1\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\tdef dfss(self, root):\n\n\t\tvis=[0]*self.n\n\t\tcolor=[-1]*self.n\n\t\tcolor[root]=0\n\t\t# self.pdfs(root,vis,color)\n\t\t# return\n\t\tstack=[root]\n\t\twhile len(stack)!=0:\n\t\t\te=stack.pop()\n\t\t\tif vis[e]:\n\t\t\t\tcontinue\n\n\t\t\tif color[e]==-1:\n\t\t\t\tif color[self.parent[e]]:\n\t\t\t\t\tcolor[e]=0\n\t\t\t\t\tg1.append(e+1)\n\t\t\t\telse:\n\t\t\t\t\tcolor[e]=1\n\t\t\t\t\tg2.append(e+1)\n\t\t\tvis[e]=1\n\n\t\t\tfor i in self.graph[e]:\n\t\t\t\tif not vis[i]:\n\t\t\t\t\tstack.append(i)\n\t\t\t\t\tself.parent[i]=e\n\n\t\treturn\n\nn,m,k = list(map(int,input().split()))\ng = Graph(n,False)\nfor i in range(m):\n\ta,b = list(map(int,input().split()))\n\tg.addEdge(a-1,b-1)\nl = g.ifcycle()\n# print (l)\nif l!=-1 and len(l)<=k:\n\tprint(2)\n\tprint(len(l))\n\tfor i in range(len(l)):\n\t\tl[i] += 1\n\tprint(*l)\n\treturn\ng1,g2 = [1],[]\ng.dfss(0)\nif len(g1)>=(k-1)//2+1:\n\tprint(1)\n\tprint(*g1[0:(k-1)//2+1])\nelse:\n\tprint(1)\n\tprint(*g2[0:(k-1)//2+1])\n"]
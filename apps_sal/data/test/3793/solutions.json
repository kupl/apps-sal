["import itertools\nfrom itertools import permutations as perm\n\nl = [[int(x) for x in input().split()] for i in range(8)]\n\ndef dist2(p0,p1):\n    return sum([(p0[i]-p1[i])**2 for i in range(3)])\n\ndef check(c):\n    dists = [[(c[i][0]-c[j][0])**2+(c[i][1]-c[j][1])**2+(c[i][2]-c[j][2])**2 for i in range(8)] for j in range(8)]\n    s2 = min([min(l) for l in dists])\n    return all([sorted(l) == [0,s2,s2,s2,2*s2,2*s2,2*s2,3*s2] for l in dists])\n\ndef sub(p0,p1):\n    return [p0[i]-p1[i] for i in range(3)]\n\ndef add(p0,p1):\n    return [p0[i]+p1[i] for i in range(3)]\n\ndef div(p0,x):\n    return [p0[i]//x for i in range(3)]\n\ndef cross(p0,p1):\n    return [p0[(i+1)%3]*p1[(i+2)%3]-p0[(i+2)%3]*p1[(i+1)%3] for i in range(3)]\n\ndef match(p0,p1):\n    return sorted(p0) == sorted(p1)\n\ndef poss(i,prior,s):\n    if i == len(l): return check(prior)\n    for p in perm(l[i]):\n        if i == 1: print(p)\n        possible = True\n        for p2 in prior:\n            if dist2(p,p2) not in [s,2*s,3*s]:\n                possible = False\n                break\n        if possible:\n            if poss(i+1,prior+[p]): return True\n    return False\n\nsolved = False\nfor l2 in perm(l,3):\n    p0 = l2[0]\n    for p1 in perm(l2[1]):\n        s2 = dist2(p0,p1)\n        if s2 == 0: continue\n        s = round(s2**.5)\n        if s**2 != s2: continue\n        for p2 in perm(l2[2]):\n            if dist2(p0,p2) != s2 or dist2(p1,p2) != 2*s2: continue\n            p3 = sub(add(p1,p2),p0)\n            x = div(cross(sub(p1,p0),sub(p2,p0)),s)\n            p4,p5,p6,p7 = add(p0,x),add(p1,x),add(p2,x),add(p3,x)\n            l3 = [p0,p1,p2,p3,p4,p5,p6,p7]\n            if sorted([sorted(p) for p in l]) == sorted([sorted(p) for p in l3]):\n                print(\"YES\")\n                used = [False for i in range(8)]\n                for p in l:\n                    for i in range(8):\n                        if used[i]: continue\n                        if match(p,l3[i]):\n                            print(l3[i][0],l3[i][1],l3[i][2])\n                            used[i] = True\n                            break\n                solved = True\n                break\n        if solved: break\n    if solved: break\n\nif not solved: print(\"NO\")\n#if not poss(1,[l[0]]): print(\"NO\")\n", "import itertools\nfrom itertools import permutations as perm\n\nl = [[int(x) for x in input().split()] for i in range(8)]\n\ndef dist2(p0,p1):\n    return sum([(p0[i]-p1[i])**2 for i in range(3)])\n\ndef sub(p0,p1):\n    return [p0[i]-p1[i] for i in range(3)]\n\ndef add(p0,p1):\n    return [p0[i]+p1[i] for i in range(3)]\n\ndef div(p0,x):\n    return [p0[i]//x for i in range(3)]\n\ndef cross(p0,p1):\n    return [p0[(i+1)%3]*p1[(i+2)%3]-p0[(i+2)%3]*p1[(i+1)%3] for i in range(3)]\n\ndef match(p0,p1):\n    return sorted(p0) == sorted(p1)\n\nsolved = False\nfor l2 in perm(l,3):\n    p0 = l2[0]\n    for p1 in perm(l2[1]):\n        s2 = dist2(p0,p1)\n        if s2 == 0: continue\n        s = round(s2**.5)\n        if s**2 != s2: continue\n        for p2 in perm(l2[2]):\n            if dist2(p0,p2) != s2 or dist2(p1,p2) != 2*s2: continue\n            p3 = sub(add(p1,p2),p0)\n            x = div(cross(sub(p1,p0),sub(p2,p0)),s)\n            p4,p5,p6,p7 = add(p0,x),add(p1,x),add(p2,x),add(p3,x)\n            l3 = [p0,p1,p2,p3,p4,p5,p6,p7]\n            if sorted([sorted(p) for p in l]) == sorted([sorted(p) for p in l3]):\n                print(\"YES\")\n                used = [False for i in range(8)]\n                for p in l:\n                    for i in range(8):\n                        if used[i]: continue\n                        if match(p,l3[i]):\n                            print(l3[i][0],l3[i][1],l3[i][2])\n                            used[i] = True\n                            break\n                solved = True\n                break\n        if solved: break\n    if solved: break\n\nif not solved: print(\"NO\")\n#if not poss(1,[l[0]]): print(\"NO\")\n", "import itertools\nfrom itertools import permutations as perm\n\nl = [[int(x) for x in input().split()] for i in range(8)]\n\ndef dist2(p0,p1):\n    return sum([(p0[i]-p1[i])**2 for i in range(3)])\n\ndef sub(p0,p1):\n    return [p0[i]-p1[i] for i in range(3)]\n\ndef add(p0,p1):\n    return [p0[i]+p1[i] for i in range(3)]\n\ndef div(p0,x):\n    return [p0[i]//x for i in range(3)]\n\ndef cross(p0,p1):\n    return [p0[(i+1)%3]*p1[(i+2)%3]-p0[(i+2)%3]*p1[(i+1)%3] for i in range(3)]\n\ndef match(p0,p1):\n    return sorted(p0) == sorted(p1)\n\nsolved = False\nfor l2 in perm(l,3):\n    p0 = l2[0]\n    for p1 in perm(l2[1]):\n        s2 = dist2(p0,p1)\n        if s2 == 0: continue\n        s = round(s2**.5)\n        # if s**2 != s2: continue\n        for p2 in perm(l2[2]):\n            if dist2(p0,p2) != s2 or dist2(p1,p2) != 2*s2: continue\n            p3 = sub(add(p1,p2),p0)\n            x = div(cross(sub(p1,p0),sub(p2,p0)),s)\n            p4,p5,p6,p7 = add(p0,x),add(p1,x),add(p2,x),add(p3,x)\n            l3 = [p0,p1,p2,p3,p4,p5,p6,p7]\n            if sorted([sorted(p) for p in l]) == sorted([sorted(p) for p in l3]):\n                print(\"YES\")\n                used = [False for i in range(8)]\n                for p in l:\n                    for i in range(8):\n                        if used[i]: continue\n                        if match(p,l3[i]):\n                            print(l3[i][0],l3[i][1],l3[i][2])\n                            used[i] = True\n                            break\n                solved = True\n                break\n        if solved: break\n    if solved: break\n\nif not solved: print(\"NO\")\n#if not poss(1,[l[0]]): print(\"NO\")\n", "import itertools\nfrom itertools import permutations as perm\nimport copy\n\ndef getPerm(it, index):\n\tif index == 0:\n\t\treturn it\n\telif index == 1:\n\t\treturn [it[0], it[2], it[1]]\n\telif index == 2:\n\t\treturn [it[1], it[0], it[2]]\n\telif index == 3:\n\t\treturn [it[1], it[2], it[0]]\n\telif index == 4:\n\t\treturn [it[2], it[0], it[1]]\n\telif index == 5:\n\t\treturn [it[2], it[1], it[0]]\n\ndef distance(coord1, coord2):\n\treturn ((coord2[0] - coord1[0])**2 + (coord2[1] - coord1[1])**2 + (coord2[2] - coord1[2])**2)\n\ndists = ([0]*6)*7\n\npointList =  [[int(x) for x in input().split()] for y in range(0, 8)]\n\np0 = pointList[0]\n\nfor x in range(0, 7):\n\ty = 0\n\tfor pt in perm(pointList[x + 1], 3):\n\t\t# print(pt, p0)\n\t\tdists[x*6 + y] = distance(p0, pt)\n\t\t# print(dists)\n\t\ty += 1\n\n# print(pointList)\n# print(dists)\ndone = False\nfinal = None\n\ndef same(it1, it2):\n\t# print(it1, it2)\n\tif list(it1) == list(it2):\n\t\treturn True\n\treturn False\n\ndef checkNotSame(indicesSoFar, newIndex):\n\tnonlocal pointList\n\tptToComp = getPerm(pointList[len(indicesSoFar) + 1], newIndex)\n\tfor c in range(len(indicesSoFar)):\n\t\tif same(getPerm(pointList[c + 1], indicesSoFar[c]), ptToComp):\n\t\t\t# print(getPerm(pointList[c + 1], indicesSoFar[c]), getPerm(pointList[len(indicesSoFar)], newIndex), False)\n\t\t\treturn False\n\treturn True\n\n\n\ndef checkCompatible(a, b):\n\tif a == b or a*2 == b or a == 2*b or a*3 == b or a ==3*b or 2*a == 3*b or 3*a== 2*b:\n\t\treturn True\n\treturn False\n\ndef getSeven(distList, soFar, index):\n\tnonlocal done\n\tnonlocal final\n\tif done == True:\n\t\treturn\n\tif index == 7:\n\t\t# for h in range(0,7):\n\t\t# \tprint(getPerm(pointList[h+1], soFar[h]), end=\" \")\n\t\t# print()\n\t\t# for i in range(0,7):\n\t\t# \tprint(dists[i*6+soFar[i]], end=\" \")\n\t\t# print()\n\t\t# print(soFar)\n\t\tdistsSoFar = [dists[i*6+soFar[i]] for i in range(0, 7)]\n\t\t# print(distsSoFar)\n\t\tlowest = min(distsSoFar)\n\t\tlows = 0\n\t\ttwos = 0\n\t\tthrees = 0\n\t\tfor a in range(0, 7):\n\t\t\tif distsSoFar[a] == lowest:\n\t\t\t\tlows += 1\n\t\t\telif distsSoFar[a] == lowest*2:\n\t\t\t\ttwos += 1\n\t\t\telif distsSoFar[a] == lowest*3:\n\t\t\t\tthrees += 1\n\t\tif lows == 3 and twos == 3 and threes == 1:\n\t\t\tdone = True\n\t\t\tfinal = soFar\n\t\treturn\n\tfor x in range(0, 6):\n\t\tif done == True:\n\t\t\treturn\n\t\tif soFar == []:\n\t\t\tcurList = copy.copy(soFar)\n\t\t\tcurList.append(x)\n\t\t\tgetSeven(distList, curList, index + 1)\n\t\telse:\n\t\t\t # and checkNotSame(soFar, x)\n\t\t\t# print(getPerm(pointList[index], soFar[index - 1]), getPerm(pointList[index + 1], x))\n\t\t\t# print(distList[x+(index)*6], distList[soFar[index - 1]+(index - 1)*6])\n\t\t\tif checkCompatible(distList[x+(index)*6], distList[soFar[index - 1]+(index-1)*6]):\n\t\t\t\tif checkNotSame(soFar, x):\n\t\t\t\t\t# print(\"Enters\")\n\t\t\t\t\tcurList = copy.copy(soFar)\n\t\t\t\t\tcurList.append(x)\n\t\t\t\t\t# print(curList)\n\t\t\t\t\tgetSeven(distList, curList, index+1)\n\t\t# else:\n\ngetSeven(dists, [], 0)\n\nif final is None:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")\n\tprint(p0[0], p0[1], p0[2])\n\tfor b in range(0, 7):\n\t\tx, y, z = getPerm(pointList[b+1], final[b])\n\t\tprint(x, y, z)\n\n\n\n\n\n\n\n# print(combosList)\n", "from itertools import permutations as p\n\n\ndef razn(a, b):\n    return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n\n\ndef sp(a, b):\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n\ndef su(a, b):\n    return (a[0] + b[0], a[1] + b[1], a[2] + b[2])\n\na = list(tuple(map(int, input().split())) for i in range(8))\ncp = sorted(sorted(el) for el in a)\nfor p1 in p(a[0]):\n    for i in range(1, 8):\n        for j in range(i + 1, 8):\n            for l in range(j + 1, 8):\n                for p2 in p(a[i]):\n                    for p3 in p(a[j]):\n                        for p4 in p(a[l]):\n                            s2 = razn(p2, p1)\n                            s3 = razn(p3, p1)\n                            s4 = razn(p4, p1)\n                            le = sp(s2, s2)\n                            if le and sp(s3, s3) == le and sp(s4, s4) == le and sp(s2, s3) == 0 and sp(s2, s4) == 0 and sp(s3, s4) == 0:\n                                mass = [su(su(s3, s4), p1), su(su(s3, s2), p1), su(su(s2, s4), p1), p1, p2, p3, p4, su(su(su(s3, s4), p1), s2)]\n                                if sorted(sorted(el) for el in mass) == cp:\n                                    print(\"YES\")\n                                    for el in a:\n                                        tmp = sorted(el)\n                                        for kk in range(8):\n                                            if sorted(mass[kk]) == tmp:\n                                                print(mass[kk][0], mass[kk][1], mass[kk][2])\n                                                mass[kk] = ()\n                                                break\n                                    return\nprint(\"NO\")"]
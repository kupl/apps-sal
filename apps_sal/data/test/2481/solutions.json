["from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nh, w, *X = map(int, open(0).read().split())\nC = np.array(X[:100], dtype=int).reshape((10, 10))\nA = np.array(X[100:], dtype=int).reshape((h, w))\n\nG = nx.DiGraph(C)\nd = {-1:0}\nfor i in range(10):\n    d[i] = nx.shortest_path_length(G, i, 1, weight='weight')\nprint(sum(d[a] for a in chain.from_iterable(A)))", "import sys\nsys.setrecursionlimit(2147483647)\ninput=sys.stdin.readline\nimport math\nfrom heapq import heappush, heappop\n\ndef solve(h,w,tables,A):\n  for i in range(10):\n    for j in range(10):\n      for k in range(10):\n        tables[j][k] = min(tables[j][k], tables[j][i] + tables[i][k])\n  cost = 0\n  for i in range(h):\n    for j in range(w):\n      p = A[i][j]\n      if p == -1:\n        continue\n      cost += tables[p][1]\n  return cost\n  \n\ndef main():\n  h, w = map(int, input().split(' '))\n  tables = []\n  for i in range(10):\n    tables.append(list(map(int, input().split(' '))))\n  A = []\n  for _ in range(h):\n    A.append(list(map(int, input().split(' '))))\n  ans = solve(h, w, tables, A)\n  print(ans)\n  \n\ndef __starting_point():\n  main()\n__starting_point()", "h, w = map(int, input().split())\nc = []\nfor i in range(10):\n    c.append(list(map(int, input().split())))\na = []\nfor i in range(h):\n    a.append(list(map(int, input().split())))\ncost = [float(\"inf\") for i in range(10)]\nflag = [False for i in range(10)]\ncost[1] = 0\ntest = [1]\nwhile test:\n    num = test.pop(0)\n    flag[num] = True\n    for i in range(10):\n        cost[i] = min(cost[i], cost[num] + c[i][num])\n    temp = [[cost[i], i] for i in range(10)]\n    temp.sort()\n    for i in range(10):\n        if flag[temp[i][1]] == True:\n            continue\n        else:\n            test.append(temp[i][1])\n            break\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] == -1:\n            continue\n        else:\n            ans += cost[a[i][j]]\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    H, W = list(map(int, input().strip().split()))\n    N = 10\n    C = []\n    for i in range(N):\n        c = list(map(int, input().strip().split()))\n        C.append(c)\n    A = []\n    for i in range(H):\n        a = list(map(int, input().strip().split()))\n        A.append(a)\n    return H, W, N, C, A\n\n\ndef warshall_floyd(N, G, INF=10**7):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n    return G\n\n\ndef solve(H, W, N, C, A):\n    D = warshall_floyd(N, C)\n    ans = 0\n    for i in range(H):\n        for j in range(W):\n            a = A[i][j]\n            if a >= 0:\n                ans += D[a][1]\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "icase=0\nif icase==0:\n    h,w=list(map(int,input().split()))\n    dp=[[0]*10 for i in range(10)]\n    for i in range(10):\n        dp[i]=list(map(int,input().split()))\n    a=[]\n    for i in range(h):\n        a.extend(list(map(int,input().split())))\nelif icase==1:\n    h,w=2,4\n    dp=[[0, 9, 9, 9, 9, 9, 9, 9, 9, 9], \n       [9, 0, 9, 9, 9, 9, 9, 9, 9, 9],\n       [9, 9, 0, 9, 9, 9, 9, 9, 9, 9],\n       [9, 9, 9, 0, 9, 9, 9, 9, 9, 9],\n       [9, 9, 9, 9, 0, 9, 9, 9, 9, 2],\n       [9, 9, 9, 9, 9, 0, 9, 9, 9, 9],\n       [9, 9, 9, 9, 9, 9, 0, 9, 9, 9],\n       [9, 9, 9, 9, 9, 9, 9, 0, 9, 9],\n       [9, 9, 9, 9, 2, 9, 9, 9, 0, 9],\n       [9, 2, 9, 9, 9, 9, 9, 9, 9, 0]]\n\n    a=[-1, -1, -1, -1, 8, 1, 1, 8]\n\nfrom collections import Counter\nac=Counter(a)\n\nn=10\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])\n\nicnt=0\nfor i in range(10):\n    if ac[i]>0:\n        icnt+=dp[i][1]*ac[i]  \n\nprint(icnt)      \n", "from networkx import *\nh,w=map(int,input().split())\nG=DiGraph()\nG.add_nodes_from(range(10))\nC=[[*map(int,input().split())]for _ in \"_\"*10]\nG.add_weighted_edges_from([(i,j,C[i][j])for i in range(10)for j in range(10)])\nS=[single_source_dijkstra_path_length(G,i)[1]for i in range(10)]\nA=[[*map(int,input().split())]for _ in \"_\"*h]\nprint(sum(S[abs(x)] for a in A for x in a))", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\nfrom heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\nH, W = na()\nc = [na() for _ in range(10)]\nA = [na() for _ in range(H)]\nadj = [[] for _ in range(10)]\n\nc = np.array(c)\nd = shortest_path(c)\nans = 0\nfor y in range(H):\n    for x in range(W):\n        if A[y][x] != -1:\n            #print(ans)\n            ans += d[A[y][x]][1]\nprint((int(ans)))\n\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nimport heapq\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1] # warning bytes\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8').strip()\nimport string\nimport operator\nimport random\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\n\ndef solve():\n    n, m = [int(x) for x in input().split()]\n    p = []\n    for _ in range(10):\n        p.append([int(x) for x in input().split()])\n\n    stack = set()\n    def dfs(v):\n        if v == 1:\n            return 0\n        stack.add(v)\n        for to in range(10):\n            if to == v or to in stack: continue\n            if p[v][to] < p[v][1]:\n                p[v][1] = min(p[v][1], dfs(to) + p[v][to])\n        stack.remove(v)\n        return p[v][1]\n\n    for i in range(10):\n        dfs(i)\n\n    ans = 0\n    for _ in range(n):\n        row = [int(x) for x in input().split()]\n        for e in row:\n            if e == -1 or e == 1: continue\n            ans += p[e][1]\n    print(ans)\n\n\n\nT = 1\n# T = int(input())\nfor case in range(1,T+1):\n    ans = solve()\n\n\n\"\"\"\n\ndp[num_changes][blue_placed]\n\n\nabba\n\n\n\n\"\"\"\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\n\nclass Graph(object):\n    \"\"\"\n    \u96a3\u63a5\u30ea\u30b9\u30c8\u306b\u3088\u308b\u6709\u5411\u30b0\u30e9\u30d5\n    \"\"\"\n\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return self.graph.keys()\n\n\nclass Dijkstra(object):\n    \"\"\"\n    \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\uff08\u4e8c\u5206\u30d2\u30fc\u30d7\uff09\u306b\u3088\u308b\u6700\u77ed\u7d4c\u8def\u63a2\u7d22\n    \u8a08\u7b97\u91cf: O((E+V)logV)\n    \"\"\"\n\n    def __init__(self, graph, start):\n        self.g = graph.graph\n\n        # start\u30ce\u30fc\u30c9\u304b\u3089\u306e\u6700\u77ed\u8ddd\u96e2\n        # start\u30ce\u30fc\u30c9\u306f0, \u305d\u308c\u4ee5\u5916\u306f\u7121\u9650\u5927\u3067\u521d\u671f\u5316\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n\n        # \u6700\u77ed\u7d4c\u8def\u3067\u306e1\u3064\u524d\u306e\u30ce\u30fc\u30c9\n        self.prev = defaultdict(lambda: None)\n\n        # start\u30ce\u30fc\u30c9\u3092\u30ad\u30e5\u30fc\u306b\u5165\u308c\u308b\n        self.Q = []\n        heappush(self.Q, (self.dist[start], start))\n\n        while self.Q:\n            # \u512a\u5148\u5ea6\uff08\u8ddd\u96e2\uff09\u304c\u6700\u5c0f\u3067\u3042\u308b\u30ad\u30e5\u30fc\u3092\u53d6\u308a\u51fa\u3059\n            dist_u, u = heappop(self.Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in self.g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(self.Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\n        \"\"\"\n        return self.dist[goal]\n\n    def shortest_path(self, goal):\n        \"\"\"\n        start\u30ce\u30fc\u30c9\u304b\u3089goal\u30ce\u30fc\u30c9\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\n        \"\"\"\n        path = []\n        node = goal\n        while node is not None:\n            path.append(node)\n            node = self.prev[node]\n        return path[::-1]\nh,w = map(int,input().split())\ng = Graph()\nfor i in range(10):\n    c = list(map(int,input().split()))\n    for j in range(10):\n        src,dst,weight = i,j,c[j]\n        g.add_edge(src, dst, weight)\n\nans = 0\nfor y in range(h):\n    tmp = list(map(int,input().split()))\n    for x in range(w):\n        if tmp[x] != -1 and tmp[x] != 1:\n            d = Dijkstra(g, tmp[x])\n            ans += d.shortest_distance(1)\nprint(ans)", "import copy\nL=[[j for j in range(10)] for i in range(10)]\nH,W=map(int,input().split())\ncosts=list()\ncosts2=list()\nfor i in range(10):\n  L1=list(map(int,input().split()))\n  costs.append(L1[1])\n  costs2.append(L1[1])\n  L[i]=L1\nfor i in range(12):#\u7e70\u308a\u8fd4\u3057\n  for j in range(10):#costs\u306e\u305d\u308c\u305e\u308c\u306b\u5bfe\u3057\n    for k in range(10):#costs[j]=min(costs[j],costs[k]+j\u304b\u3089k\u306e\u30b3\u30b9\u30c8\n      costs2[j]=min(costs2[j],costs[k]+L[j][k])\n  costs=copy.copy(costs2)\ncosts.append(0)\ns=0\nfor i in range(H):\n  A=list(map(int,input().split()))\n  s+=sum([costs[i] for i in A])\nprint(s)", "import heapq\nh, w = map(int, input().split())\nc = [list(map(int, input().split())) for _ in range(10)]\na = [list(map(int, input().split())) for _ in range(h)]\nflag = [[1 for _ in range(10)] for _ in range(10)]\nfor i in range(10):\n    que = [[0, i]]\n    while que:\n        now = heapq.heappop(que)\n        flag[i][now[1]] = 0\n        for j in range(10):\n            if flag[i][j]:\n                heapq.heappush(que, [c[i][now[1]]+ c[now[1]][j], j])\n                if c[i][now[1]]+c[now[1]][j] < c[i][j]:\n                    c[i][j] = c[i][now[1]]+ c[now[1]][j]\n\nans = 0      \nfor i in range(h):\n    for j in range(w):\n        if a[i][j] != -1:\n            ans += c[a[i][j]][1]\nprint(ans)", "from collections import defaultdict\n\nH, W = list(map(int, input().split()))\n\nV = 10\n\ndists = []\n\nfor _ in range(V):\n    dists.append(list(map(int, input().split())))\n\ncount = defaultdict(int)\n\nfor _ in range(H):\n    for i in map(int, input().split()):\n        count[i] += 1\n\nfor k in range(V):\n    for i in range(V):\n        for j in range(V):\n            dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n\nans = 0\n\nfor k, v in list(count.items()):\n    if k == -1 or k == 1:\n        continue\n    ans += v * dists[k][1]\nprint(ans)\n\n", "from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nX = iter(open(0).readlines())\nh, w = map(int, next(X).split())\nC = np.zeros((10, 10), dtype=int)\nfor i in range(10):\n    for j, c in enumerate(map(int, next(X).split())):\n        C[i, j] = c\nA = np.zeros((h, w), dtype=int)\nfor i in range(h):\n    for j, a in enumerate(map(int, next(X).split())):\n        A[i, j] = a\n\nG = nx.DiGraph(C)\nd = {-1:0}\nfor i in range(10):\n    d[i] = nx.shortest_path_length(G, i, 1, weight='weight')\nprint(sum(d[a] for a in chain.from_iterable(A)))", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nh, w = MAP()\nc = []\nfor i in range(10):\n    c.append(LIST())\na = []\nfor i in range(h):\n    a.append(LIST())\n\nchk = True\nwhile chk:\n    chk = False\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                if c[i][j] > c[i][k]+c[k][j]:\n                    c[i][j] = c[i][k]+c[k][j]\n                    chk = True\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] != -1:\n            ans += c[a[i][j]][1]\nprint(ans)", "\"\"\"\n\u304d\u3087\u3046\u304e\u3077\u308d\u3050\u3089\u307f\u3093\u3050\uff01\uff01\uff01\uff01\uff01\uff01\n\u7af6\u30d7\u30ed\u7af6\u30d7\u30ed\u7af6\u30d7\u30ed\u7af6\u30d7\u30ed\u7af6\u30d7\u30ed\u7af6\u30d7\u30ed\u30fc\u30fc\u30fc\u30fc\u30fc\uff01\uff01\uff01\uff01\uff01\uff01\uff01\nhshs\uff01\uff01\uff8a\uff71\uff8a\uff71\uff01\uff01\u8208\u596e\u8208\u596e\uff01\uff01\uff01\uff01\u3046\u304a\u304a\u304a\u304a\u304a\u304a\u304a\uff01\uff01\uff01\n\u7af6\u30d7\u30ed\u306e\u91cd\u8981\u6027\uff01\uff01\uff7a\uff9e\uff9d\uff7a\uff9e\uff9d\uff7a\uff9e\uff9d\uff7a\uff9e\uff9d(\u982d\u3092\u96e3\u6613\u5ea6\u306e\u58c1\u306b\u6253\u3061\u4ed8\u3051\u308b\u97f3)\n\u3046\u304a\u304a\u304a\u304a\u304a\u304a\u304a\uff01\uff01\u7af6\u30d7\u30ed\u306e\u91cd\u8981\u6027\uff01\uff01\n\"\"\"\nfrom scipy.sparse.csgraph import shortest_path\nfrom scipy.sparse import csr_matrix\nh,w=list(map(int,input().split()))\nnum=[list(map(int,input().split())) for _ in range(10)]\nnum=csr_matrix(num)\nans=shortest_path(num)\nans=ans.tolist()\nans2=[0]*10\nfor i in range(10):\n    ans2[i]=int(ans[i][1])\nans3=0\nfor i in range(h):\n    a=list(map(int,input().split()))\n    for j in range(w):\n        if a[j]!=-1:\n            ans3+=ans2[a[j]]\nprint(ans3)\n", "def main():\n    inf=float(\"inf\")\n    h,w=map(int,input().split())\n    lst=[list(map(int,input().split())) for _ in range(10)]\n    dp1=[[inf]*10 for _ in range(10)]\n    \n    for i in range(10):\n        for j in range(10):\n            dp1[i][j]=lst[i][j]\n    \n    for k in range(1,11):\n        dp2=[dp1[i][:] for i in range(10)]\n        for i in range(10):\n            for j in range(10):\n                if dp2[i][j]>dp2[i][k-1]+dp2[k-1][j]:\n                    dp1[i][j]=dp2[i][k-1]+dp2[k-1][j]\n\n    wall=[list(map(int,input().split())) for _ in range(h)]\n    sm=0\n    for i in range(h):\n        for j in range(w):\n            if wall[i][j]==-1 : continue\n            sm+=dp1[wall[i][j]][1]\n\n    print(sm)\n    \nmain()", "#\u30ef\u30b7\u30e3\u30d5\nINF = 10**9\n\nH,W = map(int,input().split())\n\n#i\u304b\u3089j\u306b\u3059\u308b\u306e\u306b\u5fc5\u8981\u306a\u9b54\u529b\u91cf\nc = [list(map(int,input().split())) for i in range(10)]\n\ndp = [[(INF if i!=j else 0) for j in range(10)]for i in range(10)]\nfor k in range(0,10,1):\n    for i in range(0,10,1):\n        for j in range(0,10,1):\n            c[i][j] = min(c[i][j],c[i][k]+c[k][j])\n\n\nA = [list(map(int,input().split())) for i in range(H)]\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j]>-1:\n            ans += c[A[i][j]][1]\nprint(ans)", "H, W = map(int, input().split())\nC = [list(map(int, input().split())) for _ in range(10)]\nfor i in range(10):\n    for k in range(10):\n        for l in range(10):\n            C[k][l] = min(C[k][l], C[k][i]+C[i][l])\nans = 0\nfor _ in range(H):\n    k = list(map(int, input().split()))\n    for i in k:\n        if i == -1:\n            continue\n        ans += C[i][1]\nprint(ans)", "def warshall_floyd():\n    for middle in range(10):\n        for start in range(10):\n            for end in range(10):\n                costs[start][end] = min(costs[start][end], costs[start][middle] + costs[middle][end])\n\n\nH, W = map(int, input().split())\ncosts = []\n\nfor i in range(10):\n    costs.append(list(map(int, input().split())))\n\nwarshall_floyd()\n\n# print(*costs, sep='\\n')\nans = 0\nfor i in range(H):\n    wall = list(map(int, input().split()))\n    for num in wall:\n        if num != -1:\n            ans += costs[num][1]\nprint(ans)", "h, w = map(int, input().split())\n\nr = range(10)\nc = [[int(i) for i in input().split()] for _ in r]\na = [[int(i) for i in input().split()] for _ in range(h)]\n\nfor k in r:\n    for i in r:\n        for j in r:\n            c[i][j] = min(c[i][j], c[i][k] + c[k][j])\nelse:\n    print(sum(c[i][1] for i in sum(a, []) if i != -1))", "h, w = map(int, input().split())\na = []\nc = []\nfor i in range(10):\n    c.append(list(map(int, input().split())))\nfor i in range(h):\n    a.append(list(map(int, input().split())))\n\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            if c[i][j] > c[i][k] + c[k][j]:\n                c[i][j] = c[i][k] + c[k][j]\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] >= 0:\n            ans += c[a[i][j]][1]\n\nprint(ans)", "H, W = [int(_) for _ in input().split()]\nC = [[int(_) for _ in input().split()] for _ in range(10)]\nA = [[int(_) for _ in input().split()] for _ in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            C[i][1] = min(C[i][1], C[i][j] + C[j][1])\n\nans = 0\nfor h in range(H):\n    for w in range(W):\n        if A[h][w] != -1:\n            v = A[h][w]\n            ans += C[v][1]\nprint(ans)\n", "H, W = list(map(int, input().split()))\n\nC = []\nfor i in range(10):\n    tmp = list(map(int, input().split()))\n    C.append(tmp)\n\nA = []\nfor i in range(H):\n    tmp = list(map(int, input().split()))\n    A.append(tmp)\n\n# \u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5\u3067\u5404\u6570\u5024\u304b\u3089\u5404\u6570\u5024\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\u3092\u6c42\u3081\u308b\nfor i in range(10):  # \u7d4c\u7531\u3059\u308b\u9802\u70b9\n    for j in range(10):  # \u59cb\u70b9\n        for k in range(10):  # \u7d42\u70b9\n            C[j][k] = min(C[j][k], C[j][i]+C[i][k])\n\nans = 0\nfor h in range(H):\n    for w in range(W):\n        if A[h][w] == -1 or A[h][w] == 1:\n            continue\n\n        ans += C[A[h][w]][1]\nprint(ans)\n", "H,W = map(int,input().split())\nC = [list(map(int,input().split())) for i in range(10)]\nA = [list(map(int,input().split())) for i in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            C[i][j] = min(C[i][j], C[i][k] + C[k][j])\nans = 0\nfor row in A:\n    for a in row:\n        if a == -1: continue\n        ans += C[a][1]\nprint(ans)", "import sys\ninput = sys.stdin.readline\ndef __starting_point():\n    H,W = map(int,input().split())\n    V = 10\n    edges = []\n    for i in range(10):\n        c = list(map(int,input().split()))\n        edges.append([(j,c[j]) for j in range(10)])\n    INF = float(\"inf\")\n    dp = [[INF]*V for _ in range(V)]\n    for i in range(V):\n        for j, w in edges[i]:\n            dp[i][j] = w\n\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])\n    ans = 0\n    for _ in range(H):\n        for x in map(int,input().split()):\n            if x >= 0:\n                ans += dp[x][1]\n    print(ans)\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\nimport numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\n\n\ndef solve():\n    H, W = MI()\n    dist = LLI(10)\n    N = 10\n\n    # dist = [[INF]*10 for _ in range(10)]\n    # for i in range(N):\n    #     dist[i][1] = C[i, 1]\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    ans = 0\n    for i in range(H):\n        for r in LI():\n            if r != -1:\n                ans += dist[r][1]\n    print(ans)\n\n\n\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nH,W = map(int,input().split())\ncosts = []\nfor i in range(10):\n    cost = list(map(int,input().split()))\n    costs.append(cost)\n\ncost_array = np.array(costs)\ncounter = [0]*10\nfor i in range(H):\n    wall = list(map(int,input().split()))\n    for j in wall:\n        if j != -1:\n            counter[j] += 1\nmincost = shortest_path(cost_array)\nans = 0\nfor i in range(10):\n    ans += counter[i] * mincost[i][1]\nprint(int(ans))", "from heapq import heappush, heappop\ndef main():\n    H, W = list(map( int, input().split()))\n    C = [ list( map( int, input().split())) for _ in range(10)]\n    A = [ list( map( int, input().split())) for _ in range(H)]\n    h = [(0,1)]\n    V = [-1]*10\n    while h:\n        # print(h)\n        m, n = heappop(h)\n        if V[n] > -1:\n            continue\n        V[n] = m\n        for i in range(10):\n            if V[i] == -1:\n                heappush(h, (m+C[i][n],i))\n    # print(V)\n    ans = 0\n    for a in A:\n        for b in a:\n            if b > -1:\n                ans += V[b]\n    print(ans)\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\ndef main():\n    H, W = list(map(int, input().split()))\n    max_num = 10\n    c = [list(map(int, input().split())) for _ in range(max_num)]\n    A = [list(map(int, input().split())) for _ in range(H)]\n\n    for k in range(max_num):\n        for i in range(max_num):\n            for j in range(max_num):\n                c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n\n    ans = 0\n    for row in A:\n        for a in row:\n            if a == -1:\n                continue\n            ans += c[a][1]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nH, W = (int(x) for x in input().split())\nC = np.array([[int(x) for x in input().split()] for _ in range(10)])\nA = [[int(x) if int(x) >= 0 else 1 for x in input().split()] for _ in range(H)]\nfrom scipy.sparse.csgraph import dijkstra\nC = dijkstra(C,directed=True) #\u6709\u5411\u30b0\u30e9\u30d5\u306e\u7d4c\u8def\u5727\u7e2e\uff08\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\uff09\nans = sum(sum(C[x,1] for x in A))\nprint(int(ans))", "h, w = map(int, input().split())\n\ninf = 10 ** 20\nd = [list(map(int, input().split())) for _ in range(10)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\nans = 0\nfor _ in range(h):\n    row = list(map(int, input().split()))\n    for num in row:\n        if num == -1:\n            continue\n        ans += d[num][1]\n\nprint(ans)", "from copy import copy\nh, w = map(int, input().split())\ndata = [list(map(int, input().split())) for _ in range(10)]\n\nc = [list(map(int, input().split())) for _ in range(h)]\n\nd = copy(data)\ndef cnt_set(d):\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\ncnt_set(d)\nans = 0\n\nfor i in range(h):\n    for j in range(w):\n        if c[i][j] == -1:\n            continue\n        ans += d[c[i][j]][1]\n\nprint(ans)", "import heapq\nH,W = map(int, input().split())\nC = []\nfor i in range(10):\n    C.append(list(map(int, input().split())))\nINF = float(\"inf\")\n\ndef dfs(x):\n    memo = [INF]*10\n    memo[x] = 0\n    hq = [(0,x)]\n    heapq.heapify(hq)\n    while hq:\n        cost,step = heapq.heappop(hq)\n        if cost > memo[step]:\n            continue\n        for j,c in enumerate(C[step]):\n            if memo[j] > memo[step] + c:\n                memo[j] = memo[step] + c\n                heapq.heappush(hq,(memo[j],j))\n    return memo[1]\n\nA = [0]*10\nfor h in range(H):\n    for w in map(int, input().split()):\n        if w == -1:\n            continue\n        else:\n            A[w] += 1\nans = 0\nfor number, a in enumerate(A):\n    ans += a*dfs(number)\nprint(ans)", "from collections import Counter\nfrom itertools import product\n\ndef main():\n    with open(0) as f:\n        H, W = map(int, f.readline().split())\n        C = [list(map(int, f.readline().split())) for _ in range(10)] \n        A = Counter(map(int, f.read().split()))\n\n    r10 = range(10)\n    for k,i,j in product(r10, r10, r10):\n        C[i][j] = min(C[i][j], C[i][k]+C[k][j])\n\n    ans = sum(C[key][1]*value for key,value in A.items() if key != -1)\n    print(ans)\n\nmain() ", "H,W = map(int,input().split())\nCls = []\nfor i in range(10):\n    Cls.append(list(map(int,input().split())))\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            Cls[i][j] = min(Cls[i][j], Cls[i][k] + Cls[k][j])\ncostls = []\nfor i in range(10):\n    costls.append(Cls[i][1])\nnumls = []\nfor i in range(H):\n    numls += list(map(int,input().split()))\nans = 0\nfor i in range(H*W):\n    if numls[i] == -1:\n        continue\n    ans += costls[numls[i]]\nprint(ans)", "H,W=map(int,input().split())\nC=[list(map(int,input().split()))for _ in range(10)]\nA=[list(map(int,input().split()))for _ in range(H)]\n\nfor k in range(10):#\u7d4c\u7531\u3059\u308b\u9802\u70b9\n    for i in range(10):#\u59cb\u70b9\n        for j in range(10):#\u7d42\u70b9\n            C[i][j] = min(C[i][j], C[i][k] + C[k][j])\nans=0\nfor aa in A:\n    for a in aa:\n        if a==-1:\n            ans+=0\n        else:\n            ans+=C[a][1]\nprint(ans)", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nclass WarshallFloyd(object):\n    def __init__(self):\n        self.max_v = 10\n        self.min_dist = [readInts() for _ in range(10)]\n    def compute(self):\n        for k,i,j in product(list(range(self.max_v)), repeat = 3):\n            # i -> j \u3068 i -> k -> j \u306e\u3046\u3061\u3001\u9577\u304f\u306a\u3044\u65b9\u306e\u8ddd\u96e2\n            self.min_dist[i][j] = min(self.min_dist[i][j], self.min_dist[i][k] + self.min_dist[k][j])\n    def solve(self, n):\n        if n == 1:\n            return 0\n        else:\n            return self.min_dist[n][1]\nh,w = readInts()\nw = WarshallFloyd()\nw.compute()\nans = 0\nA = [readInts() for _ in range(h)]\nfor a in A:\n    for i in a:\n        if i == -1:\n            continue\n        ans += w.solve(i)\nprint(ans)\n", "from networkx import *\nh,w=map(int,input().split());r=range(10);G=DiGraph();G.add_nodes_from(r);C=[[*map(int,input().split())]for _ in r];G.add_weighted_edges_from([(i,j,C[i][j])for i in r for j in r]);S=[single_source_dijkstra_path_length(G,i)[1]for i in r];A=[[*map(int,input().split())]for _ in \"_\"*h];print(sum(S[abs(x)] for a in A for x in a))", "from collections import defaultdict\n\nh,w=map(int,input().split())\nc=[]\ndic=defaultdict(int)\nfor _ in range(10): c.append(list(map(int,input().split())))\nfor _ in range(h):\n    temp=list(map(int,input().split()))\n    for i in temp: dic[i]+=1\nfor k in range(10):\n    for i in range(10):\n        for j in range(10): c[i][j]=min(c[i][j],c[i][k]+c[k][j])\nans=0\nfor item in dic.items():\n    if item[0]>=0: ans+=item[1]*c[item[0]][1]\nprint(ans)", "from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nh, w, *X = map(int, open(0).read().split())\nC = np.array(X[:100], dtype=int).reshape((10, 10)).T\nA = np.array(X[100:], dtype=int).reshape((h, w))\n\nG = nx.DiGraph(C)\nd = {-1:0}\nd.update(nx.single_source_dijkstra_path_length(G, 1, weight='weight'))\nprint(sum(d[a] for a in chain(*A)))", "h, w = list(map(int, input().split()))\nc = [list(map(int, input().split())) for _ in range(10)]\nnum = [0]*10\nfor _ in range(h):\n    a = list(map(int, input().split()))\n    for i in a:\n        if i == -1:\n            continue\n        num[i] += 1\n#a = [list(map(int, input().split())) for _ in range(h)]\n#print(num)\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n                c[j][k] = min(c[j][k], c[j][i]+c[i][k])\n#print(c)\nprint((sum(num[x]*c[x][1] for x in range(10))))\n", "H,W = map(int,input().split())\nc = [list(map(int,input().split())) for i in range(10)]\nA = [list(map(int,input().split())) for i in range(H)]\nma = [1001]*10\nma[1] = 0\nuse = [i for i in range(10)]\nuse.remove(1)\nfrom itertools import permutations\nfor i in range(1,10):\n    l = list(permutations(use,i))\n    for j in l:\n        cost =0\n        first = pre = j[0]\n        border = ma[first]\n        k = 1\n        while cost < border and k < i:\n            cost += c[pre][j[k]]\n            pre = j[k]\n            k += 1\n        cost += c[pre][1]\n        ma[first] = min(border,cost)\nans = 0\nfor i in A:\n    for j in i:\n        if j != -1:\n            ans += ma[j]\nprint(ans)", "from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nh, w, *X = map(int, open(0).read().split())\nC = np.array(X[:100], dtype=int).reshape((10, 10))\nA = np.array(X[100:], dtype=int).reshape((h, w))\n\nG = nx.DiGraph(C)\nd = {-1:0}\nfor i in range(10):\n    d[i] = nx.shortest_path_length(G, i, 1, weight='weight')\nprint(sum(d[a] for a in chain(*A)))", "from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nX = iter(open(0).readlines())\nh, w = map(int, next(X).split())\nC = np.zeros((10, 10), dtype=int)\nfor i in range(10):\n    for j, c in enumerate(map(int, next(X).split())):\n        C[i, j] = c\nA = np.zeros((h, w), dtype=int)\nfor i in range(h):\n    for j, a in enumerate(map(int, next(X).split())):\n        A[i, j] = a\n\nG = nx.DiGraph(C)\nd = {}\nfor i in range(10):\n    if i == 1:\n        continue\n    d[i] = nx.shortest_path_length(G, i, 1, weight='weight')\n\ns = 0\nfor a in chain.from_iterable(A):\n    if a == -1 or a == 1:\n        continue\n    s += d[a]\nprint(s)", "H , W = map(int,input().split())\nc = [list(map(int,input().split())) for i in range(10)]\nfor k in range(10):\n  for i in range(10):\n    for j in range(10):\n      if c[i][j] > c[i][k] + c[k][j]:\n        c[i][j] = c[i][k] + c[k][j]\ns = 0\nfor i in range(H):\n  a = list(map(int,input().split()))\n  for j in range(W):\n    if a[j] == -1:\n      a[j] = 1\n    s += c[a[j]][1]\nprint(s)    ", "import sys, math\nfrom collections import deque\nsys.setrecursionlimit(10**9)\n\ndef input():\n    return sys.stdin.readline()[:-1]\n\ndef mi():\n    return map(int, input().split())\n\ndef ii():\n    return int(input())\n\ndef i2(n):\n    tmp = [list(mi()) for i in range(n)]\n    return [list(i) for i in zip(*tmp)]\n\ndef main():\n    H, W = mi()\n    c = [list(mi()) for i in range(10)]\n    A = [list(mi()) for i in range(H)]\n\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                # i\u2192k\u2192j\n                c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n\n\n    ans = 0\n    for h in range(H):\n        for w in range(W):\n            if A[h][w] == -1:\n                continue\n        \n            ans += c[A[h][w]][1]\n\n    print(ans)\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "# -*- coding: utf-8 -*-\nfrom scipy.sparse.csgraph import shortest_path, dijkstra, floyd_warshall, bellman_ford, johnson\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nimport sys\nfrom collections import deque\nfrom collections import defaultdict\nimport heapq\nimport collections\nimport itertools\nimport bisect\nimport copy\nimport math\nsys.setrecursionlimit(10**6)\n\n# lis_of_lis = [[] for _ in range(N)]\n\n\ndef zz(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef z(): return int(sys.stdin.readline())\n\n\ndef S(): return sys.stdin.readline()[:-1]\n\n\ndef C(line): return [sys.stdin.readline() for _ in range(line)]\n\n\nH, W = zz()\nC = []\nfor i in range(10):\n    C.append(zz())\nA = []\nnum_lis = [0]*10\nfor i in range(H):\n    a = zz()\n    for a_ in a:\n        if (a_ == -1):\n            continue\n        num_lis[a_] += 1\n    A.append(a)\n# 1->1, 2->1, 3->1 \u306b\u3059\u308b\u305f\u3081\u306e\u30b3\u30b9\u30c8\u3092\u8a08\u7b97\u3059\u308b\n# cost = [0]*10\n# for num in range(2, 10):\n#     min_cost = C[num][1]\na = floyd_warshall(C)\nans = 0\nfor i, num in enumerate(num_lis):\n    ans += a[i, 1]*num\nprint((int(ans)))\n", "from itertools import permutations\nfrom heapq import heappush,heappop\n\nINF=10**12\n\ndef dijkstra(G, start = 0, INF=INF):\n    \n    d = [INF for i in range(len(G))]\n    d[start] = 0\n    \n    que = []\n    heappush(que, (0, start))\n\n    while len(que) != 0:\n        p = heappop(que)\n        v = p[1]\n        \n        if d[v] < p[0]:\n            continue\n            \n        for u in G[v].keys():\n            if d[u] > d[v] + G[v][u]:\n                d[u] = d[v] + G[v][u]\n                heappush(que, (d[u], u))\n    \n    return d\n\nH,W=map(int,input().split())\nc=[list(map(int,input().split())) for _ in range(10)]\nA=[list(map(int,input().split())) for _ in range(H)]\n\nG=[{} for _ in range(10)]\nfor i in range(10):\n  for j in range(10):\n    G[i][j] = c[i][j]\n\ndist=[0]*10\nfor i in range(10):\n  d = dijkstra(G,i)\n  dist[i] = d[1]\n\nans=0\nfor i in range(H):\n  for j in range(W):\n    if A[i][j] != -1:\n      ans += dist[A[i][j]]\n\nprint(ans)", "import numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nh, w = map(int,input().split())\n\nc = []\nfor i in range(10):\n    c.append(list(map(int, input().split())))\n\ncsr = csr_matrix(c)\n\na = []\nfor i in range(h):\n    a.append(list(map(int, input().split())))\n\ncost = floyd_warshall(csr)[:,1]\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] > -1:\n            ans += int(cost[a[i][j]])\nprint(ans)", "from itertools import chain\nimport numpy as np\nimport networkx as nx\n\nh, w, *X = map(int, open(0).read().split())\nC = np.array(X[:100], dtype=int).reshape((10, 10))\nA = np.array(X[100:], dtype=int).reshape((h, w))\n\nG = nx.DiGraph(C)\nd = {-1:0}\nfor i in range(10):\n    d[i] = nx.dijkstra_path_length(G, i, 1, weight='weight')\nprint(sum(d[a] for a in chain(*A)))", "h,w=list(map(int, input().split()))\nc=[list(map(int, input().split())) for _ in range(10)]\na=[list(map(int, input().split())) for _ in range(h)]\n\ndef warshall_floyd(adj_m):\n    # _dist[i][j] : i \u304b\u3089 j \u3078\u306e\u6700\u77ed\u8ddd\u96e2\n    _dist=adj_m\n    for _k in range(10):\n        for _i in range(10):\n            for _j in range(10):\n                _dist[_i][_j] = min(_dist[_i][_j], _dist[_i][_k]+_dist[_k][_j])\n    return _dist\n\ndist=warshall_floyd(c)\n\nans=0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j]!=-1:\n            ans+=dist[a[i][j]][1]\nprint(ans)\n", "H,W = list(map(int, input().split()))\ncArray = [list(map(int, input().split())) for _ in range(10)]\nAarray = [list(map(int, input().split())) for _ in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            cArray[i][j] = min(cArray[i][j], cArray[i][k] + cArray[k][j])\n\n#print(cArray)\n\nans = 0\nfor i in Aarray:\n    for j in i:\n        if(j != -1):\n            ans += cArray[j][1]\n\nprint(ans)", "H,W=list(map(int,input().split()))\nc=[list(map(int,input().split())) for i in range(10)]\nA=[list(map(int,input().split())) for i in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            c[i][j]=min(c[i][j],c[i][k]+c[k][j])\nans=0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j]==-1:\n            continue\n        ans+=c[A[i][j]][1]\nprint(ans)\n", "from collections import defaultdict\ndicA = defaultdict(int) \n\nH,W = map(int,input().split())\nC = []\nmin_step = []\nfor i in range(10):\n  temp = list(map(int,input().split()))\n  C.append(temp)\n  min_step.append(temp[1])\n#print(C)\n#print(min_step)\n\ndef dfs(n,k,now): #0index\u306e\u6570\u5b57n\u304b\u30891\u306b\u884c\u304f\u306e\u306b\u6700\u77ed\u306e\u5024\u3002now\u30b9\u30c6\u30c3\u30d7\u9032\u3093\u3067\u4ecak\u306b\u3044\u308b\u3002\n  if now > min_step[n]:\n    return\n  for i in range(10):\n    if i == 1: #k\u304b\u30890\u306b\u884c\u3063\u305f\u3068\u304d\u306f\u3001\u73fe\u72b6\u306e\u6700\u77ed\u3068\u3069\u3061\u3089\u304c\u8fd1\u3044\u304b\u3092\u6bd4\u8f03\u3002\n      #print(min_step[n],now+ C[k][1])\n      min_step[n] = min(min_step[n],now+ C[k][1])\n    if i != k:\n      if C[k][i]+now < min_step[n]: #i\u3092\u7d4c\u7531\u3057\u3066\u3082\u73fe\u72b6\u306e\u6700\u77ed\u3088\u308a\u3082\u8fd1\u3044\u3002\n        #print(n,i,now,C[k][i])\n        dfs(n,i,C[k][i]+now)\n\nfor i in range(10):\n  if i == 1:\n    continue\n  for j in range(10):\n    if i!=j:\n      dfs(i,j,C[i][j])\n\n#print(min_step)\n\nfor i in range(H):\n  temp = list(map(int,input().split()))\n  for j in range(W):\n    if temp[j] == -1:\n      continue\n    dicA[temp[j]] +=1 #\u6570\u5b57\u30920index\u306b\nans = 0\n#print(dicA)\nfor x in dicA.keys():\n  ans += min_step[x]*dicA[x]\nprint(ans)", "h, w = map(int, input().split())\nc = [list(map(int, input().split())) for i in range(10)]\n\n# Froyed-Warshal\nfor v in range(10):\n    for s in range(10):\n        for g in range(10):\n            c[s][g] = min(c[s][g], c[s][v] + c[v][g])\n\na = [list(map(int, input().split())) for i in range(h)]\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] == -1: continue\n        ans += c[a[i][j]][1]\nprint(ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\ndef main():\n    h,w = i_map()\n    c = [i_list() for i in range(10)]\n\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n\n    ans = 0\n    for h in range(h):\n        a = i_list()\n        for b in a:\n            if b>=0:\n                ans += c[b][1]\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H,W=map(int,input().split())\nc=[list(map(int,input().split())) for i in range(10)]\nA=[list(map(int,input().split())) for i in range(H)]\n \nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            c[i][j]=min(c[i][j],c[i][k]+c[k][j])\nans=0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j]==-1:\n            continue\n        ans+=c[A[i][j]][1]\nprint(ans)", "h, w = list(map(int, input().split()))\nc = [list(map(int, input().split())) for _ in range(10)]\n\nvisited = {}\ndist = {}\nfor i in range(10):\n    dist[i] = 100000\ndist[1] = 0\n\nwhile len(dist) > 0:\n    cur, curDist = sorted(dist.items(), key=lambda x: x[1])[0]\n    del dist[cur]\n    visited[cur] = curDist\n\n    for i in range(10):\n        if i == cur or i in visited:\n            continue\n\n        newDist = curDist + c[i][cur]\n        dist[i] = min(dist[i], newDist)\n\ncnts = [0] * 10\nfor _ in range(h):\n    a = list(map(int, input().split()))\n    for ai in a:\n        if ai != -1:\n            cnts[ai] += 1\n\ncnt = 0\nfor i in range(10):\n    cnt += cnts[i]*visited[i]\n\nprint(cnt)", "def main():\n\tH, W = [int(x) for x in input().split(\" \")]\n\tC = []\n\tfor i in range(10):\n\t\tc = [int(m) for m in input().split(\" \")]\n\t\tC.append(c)\n\tA = [0] * 10 # 0 ~ 9, idx = 10 -> -1\n\tfor i in range(H):\n\t\ta = [int(m) for m in input().split(\" \")]\n\t\tfor j in range(W):\n\t\t\tif a[j] != -1:\n\t\t\t\tA[a[j]] += 1\n\n\tMP = [[C[i][1] for i in range(10)]] # MP[0] -> overwrite once, MP[1] -> overwrite twice\n\tfor i in range(9):\n\t\tMP.append([min([(C[k][j] + MP[-1][j]) for j in range(10)]) for k in range(10)])\n\n\tminMP = [10000] * 10\n\tfor i in range(len(MP)):\n\t\tfor j in range(len(MP[i])):\n\t\t\tminMP[j] = min([minMP[j], MP[i][j]])\n\tprint(sum([p * q for (p, q) in zip(A, minMP)]))\n\nmain()", "h, _ = map(int, input().split())\n\nr = range(10)\nc = [[int(i) for i in input().split()] for _ in r]\n\nfor k in r:\n    for i in r:\n        for j in r:\n            c[i][j] = min(c[i][j], c[i][k] + c[k][j])\nelse:\n    a = [[int(i) for i in input().split()] for _ in range(h)]\n    print(sum(c[i][1] for i in sum(a, []) if i != -1))", "def warshall_floyd(V):\n    for k in range(V):\n        for i in range(V):\n            for j in range(V):\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n                \nfrom collections import Counter\n\nINF = float('inf') \nH, W = list(map(int, input().split()))\nd =[[int(i) for i in input().split()] for _ in range(10)]  #; print(d)\na = []\nfor _ in range(H):\n    a.extend([int(i) for i in input().split() if i != '-1'])\ndic = Counter(a)     #; print(a); print(dic) \n\nwarshall_floyd(10)   #; print(d)\n\nans = 0\nfor key, val in list(dic.items()):\n    ans += d[key][1] * val   #; print(key, d[key][1], val)\n\nprint(ans)\n", "H, W = list(map(int, input().split()))\nC = [list(map(int, input().split())) for _ in range(10)]\nfor i in range(10):\n    for k in range(10):\n        for l in range(10):\n            C[k][l] = min(C[k][l], C[k][i]+C[i][l])\nans = 0\n\"\"\"\nfor _ in C:\n    print(_)\n\"\"\"\nfor i in range(H):\n    A = list(map(int,input().split()))\n    for j in A:\n        if j != -1:\n            ans += C[j][1]\nprint(ans)\n", "import sys\nread = sys.stdin.read\nfrom collections import Counter\ndef main():\n    def warshall_floyd(d):\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n        return d\n\n    h, w = list(map(int, input().split()))\n    n = 10\n    d = []\n    for _ in range(10):\n        d.append(list(map(int, input().split())))\n    d = warshall_floyd(d)\n    a = []\n    for _ in range(h):\n        row = list(map(int, input().split()))\n        row = [1 if i == -1 else i for i in row]\n        a.extend(row)\n    aa = Counter(a)\n    ans = 0\n    for i0 in range(10):\n        ans += aa[i0] * d[i0][1]\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W = list(map(int, input().split()))\nc = [list(map(int, input().split())) for _ in range(10)]\nA = [list(map(int, input().split())) for _ in range(H)]\n\n\n# Warshall\u2013Floyd\ndef main():\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                c[i][j] = min(c[i][j], c[i][k] + c[k][j])\n\n    print((\n        sum(\n            c[a][1] for column in A for a in column if a >= 0 \n        )\n    ))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "H, W = list(map(int, input().split()))\ncost = [list(map(int, input().split())) for i in range(10)]\nA = [list(map(int, input().split())) for i in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])\n            \nans = 0\nfor i in range(H):\n    for j in range(W):\n        now = A[i][j]\n        if now != -1:\n            ans += cost[now][1]\n            \nprint(ans)\n", "from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson, csgraph_from_dense\n\nH, W = [int(x) for x in input().split()]\nC = [[int(x) for x in input().split()] for _ in range(10)]\nA = [[int(x) for x in input().split()] for _ in range(H)]\n\n\nG = csgraph_from_dense(C, null_value=0)\n\nd = floyd_warshall(G)\n\nans = 0\n\nfor i in range(H):\n    for j in range(W):\n        if A[i][j] == 1 or A[i][j] == -1:\n            continue\n        ans += d[A[i][j]][1]\n\n\nprint((int(ans)))\n\n\n", "import sys\nreadline = sys.stdin.readline\n\nH,W = map(int,readline().split())\nC = [None] * 10\nfor i in range(10):\n  C[i] = list(map(int,readline().split()))\n\nfor k in range(10):\n  for i in range(10):\n    for j in range(10):\n      C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n\nfrom collections import defaultdict\nwall = defaultdict(int)\nfor i in range(H):\n  for w in list(map(int,readline().split())):\n    wall[w] += 1\n  \nans = 0\nfor key,value in wall.items():\n  if key == -1:\n    continue\n  ans += value * C[key][1]\n  \nprint(ans)", "INF=float('inf')\nh,w=map(int,input().split())\ndist=[[0 for i in range(10)]for j in range(10)]\nfor i in range(10):\n  s=list(map(int,input().split()))\n  for j in range(10):\n    if i==j:\n      continue\n    dist[i][j]=s[j]\n\nfor k in range(10):\n  for i in range(10):\n    for j in range(10):\n      dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])\nans=0\nfor i in range(h):\n  T=list(map(int,input().split()))\n  for j in range(w):\n    if T[j]==-1:\n      continue\n    if T[j]==1:\n      continue\n    ans+=dist[T[j]][1]\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\ndef solve(H: int, W: int, c: \"List[List[int]]\", A: \"List[List[int]]\"):\n    import numpy as np\n    from scipy.sparse.csgraph import floyd_warshall\n    from itertools import chain\n    mat = floyd_warshall(np.array(c, dtype=np.int64), directed=True)    \n    return int(sum(mat[a][1] for a in [x for x in chain.from_iterable(A) if x >= 0]))\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    H = int(next(tokens))  # type: int\n    W = int(next(tokens))  # type: int\n    c = [[int(next(tokens)) for _ in range(9 - 0 + 1)] for _ in range(9 - 0 + 1)]  # type: \"List[List[int]]\"\n    A = [[int(next(tokens)) for _ in range(W)] for _ in range(H)]  # type: \"List[List[int]]\"\n    print((solve(H, W, c, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "H, W = map(int, input().split())\nC = [list(map(int, input().split())) for _ in range(10)]\n\ncost = [99999]*10\ncost[1] = 0\n\ndef f(n):\n    for i in range(10):\n        flag = False\n        cc = C[i][n]+cost[n]\n        if cc < cost[i]:\n            flag = True\n            cost[i] = cc\n            f(i)\n\nf(1)\n\nans = 0\nfor _ in range(H):\n    for n in map(int, input().split()):\n        if n < 0:\n            continue\n        ans += cost[n]\n\nprint(ans)", "# -*- coding: utf-8 -*-\n\n\ndef warshall_floyd(dist):\n    v_count = len(dist[0])\n\n    for k in range(v_count):\n        for i in range(v_count):\n            for j in range(v_count):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for _ in range(10)]\n    a = [list(map(int, input().split())) for _ in range(h)]\n    ans = 0\n\n    results = warshall_floyd(c)\n\n    for i in range(h):\n        for j in range(w):\n            if a[i][j] != -1:\n                ai = a[i][j]\n                ans += results[ai][1]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W = map(int, input().split())\nC = []\nN = 10\nfor i in range(N):\n    c = list(map(int, input().split()))\n    C.append(c)\n\ndef w_f(C):\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                C[i][j] = min(C[i][j], C[i][k]+C[k][j])\n    return C\n\nC = w_f(C)\n\nA = []\nfor i in range(H):\n    a = list(map(int, input().split()))\n    A.append(a)\n\nans = 0\nfor h in range(H):\n    for w in range(W):\n        if A[h][w] != -1:\n            ans += C[A[h][w]][1]\n            \nprint(ans)", "H,W=map(int,input().split())\n\narr=[list(map(int,input().split())) for i in range(10)]\nwall=[list(map(int,input().split())) for i in range(H)]\n\n\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            arr[j][k]=min(arr[j][i]+arr[i][k],arr[j][k])\n\nans = 0\nfor i in range(H):\n    for item in wall[i]:\n        if item<0:\n            continue\n        ans += arr[item][1]  \nprint(ans)", "h,w = list(map(int,input().split()))\nn=10\ndist = [list(map(int,input().split())) for _ in range(n)]\nwall = [list(map(int,input().split())) for _ in range(h)]\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n#[print(*dist[l]) for l in range(n)]\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if wall[i][j]!=-1:\n            ans += dist[wall[i][j]][1]\nprint(ans)\n\n", "def main():\n    import sys\n    from heapq import heappop, heappush\n\n    def input(): return sys.stdin.readline().rstrip()\n\n    def dijkstra(s):\n        inf = 10**6\n        dist = [inf]*10\n        dist[1] = 0\n        que = [(0, 1)]\n        while que:\n            cost, node = heappop(que)\n            if cost > dist[node]:\n                continue\n            for i in range(10):\n                if i == node:\n                    continue\n                if dist[i] > dist[node] + g[i][node]:\n                    dist[i] = dist[node]+g[i][node]\n                    heappush(que, (dist[i], i))\n        return dist\n    \n    h, w = map(int, input().split())\n    g = [[] for _ in range(10)]\n    for i in range(10):\n        g[i] = list(map(int, input().split()))\n\n    from collections import defaultdict\n    c_lis = defaultdict(int)\n    for i in range(h):\n        for j in input().split():\n            tmp = int(j)\n            if abs(tmp) != 1:\n                c_lis[tmp] += 1\n    \n    dist = dijkstra(1)\n    ans = 0\n    for key in c_lis:\n        ans += c_lis[key]*dist[key]\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "H, W = map(int, input().split())\nC = []\nfor i in range(10):\n  c = list(map(int, input().split()))\n  C.append(c)\nA = []\nfor i in range(H):\n  a = list(map(int, input().split()))\n  A.append(a)\n  \nfor k in range(10):\n  for i in range(10):\n    for j in range(10):\n      if C[i][k]+C[k][j] < C[i][j]:\n        C[i][j] = C[i][k] + C[k][j]\n        \nans = 0\nfor i in range(H):\n  l = A[i]\n  for j in range(W):\n    n = l[j]\n    if (n==0) or (n>1):\n      ans += C[n][1]\nprint(ans)", "h,w=map(int,input().split())\nc=[list(map(int,input().split())) for _ in range(10)]\na=[list(map(int,input().split())) for _ in range(h)]\n\ndist=[]\ndist.extend(c)\nfor i in range(10):\n  for j in range(10):\n    for k in range(10):\n      if dist[j][k]>dist[j][i]+dist[i][k]:\n        dist[j][k]=dist[j][i]+dist[i][k]\nprint(sum(dist[a[i][j]][1] for i in range(h) for j in range(w) if a[i][j]>-1))", "#!/usr/bin/env python3\nimport copy\nfrom itertools import product\nimport sys\n# from pprint import pprint\nsys.setrecursionlimit(10**6)\n\nh, w = list(map(int, input().split()))\nmap_ = [list(map(int, input().split())) for i in range(10)]\n\nmin_ = [[10**4]*10 for i in range(10)]\n\n\n# dq = [0, 0, set([0])]\n\n\n# while(dq):\n#     num, value, lists = dq.pop()\n#     for i in range(10):\n#         if i == 1:\n\n\ndef dfs(start=0, now=0, value=0):\n    for i in range(10):\n        value_tmp = value+map_[now][i]\n        if value_tmp < min_[start][i]:\n            min_[start][i] = value_tmp\n            dfs(start, now=i, value=value_tmp)\n\n\nfor i in range(10):\n    dfs(start=i, now=i, value=0)\n\ncount = [0]*10\nfor i in range(h):\n    tmp = list(map(int, input().split()))\n    for i in tmp:\n        if i != -1:\n            count[i] += 1\n\nans = 0\nfor i in range(10):\n    ans += min_[i][1]*count[i]\nprint(ans)\n", "N = 10\nMAX_C = 1000\n\n\nH, W = [int(x) for x in input().split()]\nC = [[int(x) for x in input().split()] for _ in range(N)]\ndist = [0 if i == 1 else MAX_C for i in range(N)]\n\n\ndef bellman_ford():\n    for _ in range(N - 1):\n        for u in range(N):\n            for v in range(N):\n                dist[v] = min(dist[v], dist[u] + C[v][u])\n\n\nbellman_ford()\nans = sum([sum([0 if x == \"-1\" else dist[int(x)] for x in input().split()]) for _ in range(H)])\nprint(ans)\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nH,W = list(map(int, input().split()))\nc = []\nfor _ in range(10):\n    c.append(list(map(int, input().split())))\nA = []\nfor _ in range(H):\n    A.append(list(map(int, input().split())))\n\n\n# In[3]:\n\n\ndef wf_func(mat):\n    dist = mat\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n    return dist\n\n\n# In[5]:\n\n\ndist = wf_func(c)\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j] != -1:\n            ans += dist[A[i][j]][1]\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C&lang=ja\n#https://dai1741.github.io/maximum-algo-2012/docs/shortest-path/\n\nINF = (2*10**7)*100 + 1234567 #\u5341\u5206\u5927\u304d\u3044\u5024\u306b\u3059\u308b\u3053\u3068!!!!!!\n\nH,W = map(int, input().split())\nc = [[int(e) for e in input().split()] for i in range(10)]\n\n#Warshall\u2013Floyd\u30671\u306b\u5909\u3048\u308b\u9b54\u529b\u3092\u6c42\u3081\u3066\u304a\u304f\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            if c[i][j] > c[i][k] + c[k][j] and c[i][k]!=INF and c[k][j]!=INF:\n                c[i][j] = c[i][k] + c[k][j]\n\nans = 0\nfor i in range(H):\n    A_row = [int(e) for e in input().split()]\n    for A in A_row:\n        if A != -1:\n            ans += c[A][1]\n            \nprint(ans)", "import sys\n\ndef warshall_floyd():\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n\nH, W = list(map(int, input().split()))\ninf = float(\"inf\")\nC = [list(map(int, sys.stdin.readline().rsplit())) for _ in range(10)]\nA = [list(map(int, sys.stdin.readline().rsplit())) for _ in range(H)]\nwarshall_floyd()\nres = 0\nfor row in A:\n    for col in row:\n        if col != -1:\n            res += C[col][1]\n\nprint(res)\n", "from numpy import *\nfrom scipy.sparse.csgraph import *\nH,W = map(int,input().split())\nG = array([list(map(int,input().split())) for n in range(10)])\nA = [list(map(int,input().split())) for h in range(H)]\nF = shortest_path(G)\nans = 0\n\nfor h in range(H):\n  for w in range(W):\n    if A[h][w]!=-1:\n      ans+=F[A[h][w]][1]\n\nprint(int(ans))", "import sys\nreadline = sys.stdin.readline\n\nH,W = map(int,readline().split())\nC = [None] * 10\nfor i in range(10):\n  C[i] = list(map(int,readline().split()))\n\nfor k in range(10):\n  for i in range(10):\n    for j in range(10):\n      C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n      \nans = 0\nfor i in range(H):\n  line = list(map(int,readline().split()))\n  for j in range(len(line)):\n    if line[j] == -1:\n      continue\n    ans += C[line[j]][1]\n    \nprint(ans)", "from scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nh, w = map(int, input().split())\nma = [ list(map(int,input().split(\" \"))) for i in range(10)]\nsco = [ list(map(int,input().split(\" \"))) for i in range(h)]\na = csr_matrix(ma)\nb = dijkstra(a)\nans = 0\nfor i in range(h):\n  for j in range(w):\n    num = sco[i][j]\n    if num != -1:\n      ans += b[num][1]\nprint(int(ans))", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\nfrom heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\n\nH, W = na()\nc = [na() for _ in range(10)]\nA = [na() for _ in range(H)]\nadj = [[] for _ in range(10)]\n\n\n\n# cost[i][j]: \u9802\u70b9v_i\u304b\u3089\u9802\u70b9v_j\u3078\u5230\u9054\u3059\u308b\u305f\u3081\u306e\u8fba\u30b3\u30b9\u30c8\u306e\u548c\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            c[i][j] = min(c[i][j], c[i][k] + c[k][j])\nans = 0\nfor y in range(H):\n    for x in range(W):\n        if A[y][x] != -1:\n            #print(ans)\n            ans += c[A[y][x]][1]\nprint(ans)\n\n", "import sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\ndef s(): return input()\ndef i(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nINF = 10**9\nmod = 10**9+7\n\nH,W = I()\ncost = [l() for _ in range(10)]\nA = [l() for _ in range(H)]\nans = 0\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])\nfor i in range(H):\n    for j in range(W):\n        if A[i][j] > -1:\n            ans += cost[A[i][j]][1]\nprint(ans)", "from collections import Counter\nfrom scipy.sparse.csgraph import floyd_warshall\n\nH, W = list(map(int, input().split()))\nC = [list(map(int, input().split())) for _ in range(10)]\nA = [list(map(int, input().split())) for _ in range(H)]\n\n\nnum_counter = Counter()\nfor i in range(H):\n    num_counter += Counter(A[i])\n\nif -1 in num_counter:\n    del num_counter[-1]\n\nif 1 in num_counter:\n    del num_counter[1]\n\nnei_graph = floyd_warshall(C, directed=True)\n\nans = 0\nfor k, v in list(num_counter.items()):\n    ans += nei_graph[k][1] * v\n\nprint((int(ans)))\n\n", "h, w = list(map(int, input().split()))\n\ng = []\nfor _ in range(10):\n    a = list(map(int, input().split()))\n    g.append(a)\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            g[i][j] = min(g[i][j], g[i][k] + g[k][j])\n\nans = 0\nfor i in range(h):\n    ans += sum([g[x][1] for x in [x for x in map(int, input().split()) if x != -1]])\nprint(ans)\n", "H, W = map(int, input().split())\nC = [list(map(int, input().split())) for _ in range(10)]\nA = [list(map(int, input().split())) for _ in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n\nanswer = 0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j] == -1:\n            continue\n        answer += C[A[i][j]][1]\n\nprint(answer)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nh, w = MAP()\nc = []\nfor i in range(10):\n    c.append(LIST())\na = []\nfor i in range(h):\n    a.append(LIST())\n\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            c[j][k] = min(c[j][k], c[j][i]+c[i][k])\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if a[i][j] != -1:\n            ans += c[a[i][j]][1]\nprint(ans)", "# -*- coding: utf-8 -*-\n\n\ndef warshall_floyd(dist):\n    v_count = len(dist[0])\n\n    for k in range(v_count):\n        for i in range(v_count):\n            for j in range(v_count):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    c = [list(map(int, input().split())) for _ in range(10)]\n    a = [list(map(int, input().split())) for _ in range(h)]\n    ans = 0\n\n    results = warshall_floyd(c)\n\n    for i in range(h):\n        for j in range(w):\n            if a[i][j] != -1:\n                ai = a[i][j]\n                ans += results[ai][1]\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H,W=map(int,input().split())\nC=[list(map(int,input().split())) for _ in range(10)]\nd=[0]*10\nfor _ in range(H):\n  for i in list(map(int,input().split())):\n    if i>=0: d[i]+=1\nr=range(10)\nfor k in r:\n  for i in r:\n    for j in r:\n      C[i][j]=min(C[i][j],C[i][k]+C[k][j])\n\nprint(sum(C[i][1]*d[i] for i in r))", "def main():\n    from sys import stdin\n    def input():\n        return stdin.readline().strip()\n\n    h, w = map(int, input().split())\n    c = [[int(i) for i in input().split()] for _ in range(10)]\n    a = [[int(i) for i in input().split()] for _ in range(h)]\n\n    # Warshall-Floyd\n    for k in range(10):\n        for i in range(10):\n            for j in range(10):\n                if c[i][j] > c[i][k] + c[k][j]:\n                    c[i][j] = c[i][k] + c[k][j]\n\n    ans = 0\n    for i in a:\n        for j in i:\n            if j == -1:\n                continue\n            else:\n                ans += c[j][1]\n\n    print(ans)\n\nmain()", "H, W = list(map(int, input().split()))\nC = []\nfor _ in range(10):\n    c = list(map(int, input().split()))\n    C.append(c)\n\nA = []\nfor _ in range(H):\n    a = list(map(int, input().split()))\n    A.append(a)\n\n# 0-9\u30921\u306b\u5909\u3048\u308b\u6642\u306e\u6700\u5c0f\u306e\u30a8\u30cd\u30eb\u30ae\u30fc\u3092\u305d\u308c\u305e\u308c\u6c42\u3081\u308b(\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\u6cd5)\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            C[i][j] = min(C[i][j], C[i][k] + C[k][j])\n\ncount = 0\nfor i in range(H):\n    for j in range(W):\n        if (A[i][j] == -1):\n            continue\n        else:\n            count += C[A[i][j]][1]\n\nprint(count)\n", "#!/usr/bin/env python3\nh, w = list(map(int, input().split()))\nc = [[*list(map(int, input().split()))] for _ in range(10)]\na = [[*list(map(int, input().split()))] for _ in range(h)]\nd = [c[i][1] for i in range(10)]\nfor i in range(10):\n    for j in range(10):\n        d[j] = min(d[j], min(c[j][k] + d[k] for k in range(10)))\nd += [0]\nprint((sum(d[i] for i in sum(a,[]))))\n", "def Wall():\n    h, w = list(map(int, input().split()))\n\n    # Warshall Floyd\u914d\u5217\n    wf = [list(map(int, input().split())) for _ in range(10)]\n\n    # Warshall Floyd\u521d\u671f\u5024\u4ee3\u5165\n    for i in range(10):\n        wf[i][i] = 0\n\n    # Warshall Floyd\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                wf[j][k] = min(wf[j][i]+wf[i][k], wf[j][k])\n    ans = 0\n    for _ in range(h):\n        a = list(map(int, input().split()))\n        for v in a:\n            if v == -1:\n                continue\n            ans += wf[v][1]\n    print(ans)\n\ndef __starting_point():\n    Wall()\n    \n\n__starting_point()"]
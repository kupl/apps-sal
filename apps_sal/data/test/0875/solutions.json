["from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted(map(lambda x: int(x) - 1, input().split())))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n", "from collections import deque\n\n__author__ = 'asmn'\n\nn = int(input())\nend = tuple(sorted([int(x) - 1 for x in input().split()]))\nst = (0, 1, 2)\nmat = [input() for i in range(n)]\nv = set([st])\npath = {}\ndist = {st: 0}\nqueue = deque([st])\n\nwhile end not in v and len(queue) > 0:\n    p = queue.popleft()\n\n    for x in range(-2, 1):\n        p1, p2, p3 = p[x], p[x + 1], p[x + 2]\n        for i in range(n):\n            if i not in (p1, p2, p3) and mat[i][p3] == mat[p1][p2]:\n                np = tuple(sorted((p1, p2, i)))\n                if np not in v:\n                    v.add(np)\n                    queue.append(np)\n                    path[np] = p\n                    dist[np] = dist[p] + 1\n\n\ndef pathinfo(fr, to):\n    return str((set(fr) - set(to)).pop() + 1) + ' ' + str((set(to) - set(fr)).pop() + 1)\n\n\nif end not in dist:\n    print(-1)\n    return\n\nprint(dist[end])\nwhile end in path:\n    print(pathinfo(end, path[end]))\n    end = path[end]\n"]
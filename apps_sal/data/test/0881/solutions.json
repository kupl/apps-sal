["n = int(input())\na = list(map(int, input().split()))\n\ndp = [[False] * (n + 1) for i in range(n + 1)]\n\ndef solve(l, r):\n    if dp[l][r]:\n        return dp[l][r]\n    if r - l == 1:\n        dp[l][r] = (a[l], 1)\n        return dp[l][r]\n    tmp = 10 ** 9\n    for i in range(l + 1, r):\n        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:\n            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])\n        elif solve(l, i) == solve(i, r):\n            tmp = solve(l, i)[0] + 1\n            dp[l][r] = (tmp, 1)\n            return dp[l][r]\n        else:\n            tmp = min(tmp, 2)\n    dp[l][r] = (-1, tmp)\n    return dp[l][r]\n\nsolve(0, n)\nprint(dp[0][n][1])", "rr = lambda: input().rstrip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\n\nfrom functools import lru_cache;memo=lru_cache(None)\nfrom sys import setrecursionlimit as srl;srl(10**5)\n\ndef solve(N, A):\n    @memo\n    def dp(i, j, left=0):\n        if i == j:\n            if left == 0:\n                return 1\n            if A[i] == left:\n                return 1\n            return 2\n        if i > j:\n            return 0 if left == 0 else 1\n        # Try to greedy run up until left\n        ans = 1 + dp(i+1, j, A[i])\n        if left >= 1:\n            stack = []\n            for k in range(i, j+1):\n                stack.append(A[k])\n                \n                while len(stack) >= 2 and stack[-1] == stack[-2]:\n                    stack.pop()\n                    stack[-1] += 1\n                if len(stack) == 1 and left == stack[-1]:\n                    cand = dp(k+1, j, left+1)\n                    if cand < ans:\n                        ans = cand\n        return ans\n\n    return dp(1, N-1, A[0])\n\n#print(solve(2,[2,2]))\n#print(solve(3,[3,2,2]))\n#print(solve(4,[3,2,2,3]))\n#print(solve(5,[4,3,2,2,3]))    \n#print(solve(4,[4,3,2,2]))\n#import random;random.seed(0);ri=random.randint\n#print(solve(500, [ri(1,5) for _ in range(500)]))\nprint(solve(rri(), rrm()))\n", "def f():\n    n = int(input())\n    A = [int(s) for s in input().split()]\n    memo = [[None for j in range(n+1)] for i in range(n+1)]\n    for i in range(n):\n        memo[i][i] = [A[i],A[i],1]  # startEle, endEle, minlen\n    for l in range(2,n+1):\n        for left in range(0,n-l+1):\n            right = left + l - 1  # [left, right]\n            minLen = l\n            shortestMid = right\n            for mid in range(left+1,right+1):\n                pre = memo[left][mid-1]\n                post = memo[mid][right]\n                combLen = pre[2] + post[2]\n                if pre[1]==post[0]:\n                    combLen -= 1\n                if combLen < minLen:\n                    minLen = combLen\n                    shortestMid = mid\n            pre = memo[left][shortestMid - 1]\n            post = memo[shortestMid][right]\n            startEle = pre[0]\n            endEle = post[1]\n            if pre[2] == 1:\n                if pre[0] == post[0]:\n                    startEle = pre[0] + 1\n            if post[2] == 1:\n                if pre[1] == post[0]:\n                    endEle = post[0] + 1\n            memo[left][right] = [startEle, endEle, minLen]\n    # print(memo[0][n-1])\n    print(memo[0][n-1][2])\n\n\nf()"]
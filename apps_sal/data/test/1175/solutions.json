["MOD = 10**9 + 7\nl, r = map(int, input().split())\n\ndef func(x, y):\n\tif y == 0:\n\t\treturn 1\n\tdp = [[0 for _ in range(6)] for _ in range(61)]\n\tdp[60][0] = 1\n\tfor i in range(59, -1, -1):\n\t\tif (y>>i) & 1 == 0 and (x>>i) & 1 == 0:\n\t\t\tdp[i][0] = dp[i+1][0]\n\t\t\tdp[i][1] = dp[i+1][1]\n\t\t\tdp[i][2] = dp[i+1][2]\n\t\t\tdp[i][3] = (dp[i+1][3]*2) % MOD\n\t\t\tdp[i][4] = dp[i+1][4]\n\t\t\tdp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][5]*3) % MOD\n\t\telif (y>>i) & 1 == 1 and (x>>i) & 1 == 1:\n\t\t\tdp[i][0] = 0\n\t\t\tdp[i][1] = 0\n\t\t\tdp[i][2] = (dp[i+1][0] + dp[i+1][2]) % MOD\n\t\t\tdp[i][3] = (dp[i+1][1] + dp[i+1][3]) % MOD\n\t\t\tdp[i][4] = (dp[i+1][4]*2) % MOD\n\t\t\tdp[i][5] = (dp[i+1][4] + dp[i+1][5]*3) % MOD\n\t\telif (y>>i) & 1 == 1 and (x>>i) & 1 == 0:\n\t\t\tdp[i][0] = 0\n\t\t\tdp[i][1] = (dp[i+1][0] + dp[i+1][1]) % MOD\n\t\t\tdp[i][2] = dp[i+1][2]\n\t\t\tdp[i][3] = (dp[i+1][2] + dp[i+1][3]*2) % MOD\n\t\t\tdp[i][4] = (dp[i+1][0] + dp[i+1][2] + dp[i+1][4]*2) % MOD\n\t\t\tdp[i][5] = (dp[i+1][1] + dp[i+1][3] + dp[i+1][4] + dp[i+1][5]*3) % MOD\n\t\telif (y>>i) & 1 == 0 and (x>>i) & 1 == 1:\n\t\t\tdp[i][0] = 0\n\t\t\tdp[i][1] = 0\n\t\t\tdp[i][2] = 0\n\t\t\tdp[i][3] = (dp[i+1][1] + dp[i+1][3]) % MOD\n\t\t\tdp[i][4] = dp[i+1][4]\n\t\t\tdp[i][5] = (dp[i+1][5]*3) % MOD\n\n\treturn (sum(dp[0]))%MOD\n\nprint(func(l, r))", "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(1000000)\nP = 10**9+7\n@lru_cache(maxsize=None)\ndef subcalc(l, r):\n    if l < 0 or r < 0:\n        print(\"ERROR\")\n        print((\"l, r =\", l, r))\n        print((1//0))\n    if l > r: return 0\n    if r == 0: return 1\n    aa, bb = l.bit_length(), r.bit_length()\n    if aa == bb:\n        return subcalc(l-(1<<aa-1), r-(1<<bb-1))\n    if (r & (r+1) == 0) and (l == 0):\n        return pow(3, r.bit_length(), P)\n    t = (subcalc(l, r-(1<<bb-1)) + subcalc(l, (1<<bb-1)-1) + subcalc(0, r-(1<<bb-1))) % P\n    # print(\"subcalc\", l, r, t)\n    return t\n\n@lru_cache(maxsize=None)\ndef calc(L, R):\n    if L < 0 or R < 0:\n        print(\"ERROR\")\n        print((\"l, r =\", l, r))\n        print((1//0))\n    if L > R: return 0\n    a = L.bit_length()\n    b = R.bit_length()\n    if b > a:\n        t = (calc(L, (1<<b-1)-1) + calc(1<<b-1, R)) % P\n        # print(\"calc\", L, R, t)\n        return t\n    \n        \n        \n    a = 1 << L.bit_length() - 1 if L else 0\n    t = subcalc(L-a, R-a)\n    # print(\"calc\", L, R, t)\n    return t\n\nL, R = list(map(int, input().split()))\nprint((calc(L, R)))\n", "def f_coincidence(MOD=10 ** 9 + 7):\n    # \u53c2\u8003: https://atcoder.jp/contests/abc138/submissions/7013926\n    from itertools import product\n    L, R = [int(i) for i in input().split()]\n\n    dp = [[[[0 for s in range(2)] for k in range(2)]\n           for j in range(2)] for i in range(61)]\n    dp[60][0][0][0] = 1\n\n    for i in range(59, -1, -1):\n        lb = (L >> i) & 1  # 'b' \u306f\u30d3\u30c3\u30c8\u5024\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059(\u4ee5\u4e0b\u3082\u540c\u3058)\n        rb = (R >> i) & 1\n\n        r2 = range(2)\n        for j, k, s in product(r2, r2, r2):\n            pre = dp[i + 1][j][k][s]\n            # \u30d3\u30c3\u30c8\u3054\u3068\u306b\u5024\u3092\u8a66\u3059\n            for xb, yb in product(r2, r2):\n                # editorial \u306e\u901a\u308a\u3001\u3053\u306e\u30d3\u30c3\u30c8\u306e\u7d44\u306f\u5143\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3055\u306a\u3044\n                if xb == 1 and yb == 0:\n                    continue\n                # editorial \u306e\u901a\u308a\u3001\u3053\u308c\u4ee5\u964d\u306f x <= y \u304c\u6e80\u305f\u3055\u308c\u308b\n\n                nj, nk, ns = j, k, s\n                # \u4eca\u6ce8\u76ee\u3057\u3066\u3044\u308b\u6841\u3067MSB\u304c\u7acb\u3064\u304b\uff1f\n                if s == 0 and xb != yb:\n                    continue  # \u3069\u3061\u3089\u304b\u304c\u7acb\u3063\u3066\u3044\u306a\u3044\n                if s == 0 and xb == 1 and yb == 1:\n                    ns = 1  # \u3053\u3053\u3067\u521d\u3081\u3066MSB\u304c\u7acb\u3063\u305f\n\n                # L <= x \u3092\u6e80\u305f\u3059\u304b\uff1f\n                if j == 0 and xb == 0 and lb == 1:\n                    # j\u304c0\u306e\u307e\u307e xb<lb \u3068\u306a\u308c\u3070\u3001L<=x\u306b\u306a\u308a\u3088\u3046\u304c\u306a\u3044\n                    # j\u304c1\u306a\u3089\u3001xb\u3068lb\u304c\u3069\u3046\u306a\u3063\u3066\u3044\u3088\u3046\u304cL<=x\u3067\u3042\u308b\n                    continue\n                if j == 0 and xb == 1 and lb == 0:\n                    nj = 1  # \u3053\u306e\u6841\u3067 L<=x \u304c\u78ba\u5b9a\u3059\u308b\n\n                # y <= R \u3092\u6e80\u305f\u3059\u304b\uff1f\n                if k == 0 and yb == 1 and rb == 0:\n                    continue  # L<=x \u306e\u5834\u5408\u5206\u3051\u3068\u540c\u3058\u3053\u3068\n                if k == 0 and yb == 0 and rb == 1:\n                    nk = 1\n\n                # \u53cd\u6620\n                dp[i][nj][nk][ns] += pre\n                dp[i][nj][nk][ns] %= MOD\n\n    ans = sum([dp[0][j][k][s] for j in range(2) for k in range(2)\n               for s in range(2)]) % MOD\n    return ans\n\nprint(f_coincidence())", "from itertools import product\n\nMOD = 10**9 + 7\n\nL, R = list(map(int, input().split()))\n\nbinR = bin(R+1)[2:]\nmaxD = len(binR)\nbinL = bin(L-1)[2:].zfill(maxD)\n\ndp = [[[[0]*(2) for k in range(2)] for j in range(2)] for i in range(maxD+1)]\ndp[0][0][0][0] = 1\nfor d, (Ld, Rd) in enumerate(zip(binL, binR)):\n    Ld, Rd = int(Ld), int(Rd)\n    for isLleX, isYleR, isNum in product(list(range(2)), repeat=3):\n        for x, y in [(0,0), (0,1), (1,1)]:\n            if not isNum and (x, y) == (0, 1): continue\n            if not isLleX and x < Ld: continue\n            if not isYleR and y > Rd: continue\n            isLleX2 = isLleX or x > Ld\n            isYleR2 = isYleR or y < Rd\n            isNum2 = isNum or y == 1\n            dp[d+1][isLleX2][isYleR2][isNum2] += dp[d][isLleX][isYleR][isNum]\n            dp[d+1][isLleX2][isYleR2][isNum2] %= MOD\n\nprint((dp[-1][1][1][1]))\n", "L,R = map(int,input().split())\n\nmod = 10**9+7\n\ndef f(L,R):\n    if L>R : return 0\n    R = bin(R)[2:]\n    N = len(R)\n    ret = f(L,int(\"0\"+\"1\"*(N-1),2))\n    L = bin(L)[2:]\n    if len(L) != N : L = \"1\"+\"0\"*(N-1)\n    for i in range(N):\n        if R[i] == \"0\" : continue\n        R2 = R[:i] + \"0\" + \"?\"*(N-i-1)\n        if i==0: R2 = R\n        for j in range(N):\n            if L[j] == \"1\" and j!=0 : continue\n            L2 = L[:j] + \"1\" + \"?\"*(N-j-1)\n            if j==0 : L2 = L\n            if L2[0] == \"0\" : break\n            tmp = 1\n            for r,l in zip(R2[1:],L2[1:]):\n                if r==\"0\" and l==\"1\" : tmp *= 0 ; break\n                if r==\"?\" and l==\"?\" : tmp = tmp*3%mod\n                if r==\"?\" and l==\"0\" : tmp = tmp*2%mod\n                if r==\"1\" and l==\"?\" : tmp = tmp*2%mod\n            ret += tmp\n            ret %= mod\n    return ret\n\nprint(f(L,R))", "L, R = list(map(int, input().split()))\n\n\"\"\"\nR ????????1??????\ny 0001????0??????\n     ^d   ^rd\nx 0001???????1??\n             ^ld\nL ???????????0???\n\"\"\"\n\nans = 0\n\nfor d in range(70):\n  if d<len(bin(L))-3:\n    LD = []\n  elif d==len(bin(L))-3:\n    LD = [i for i in range(-1,d) if i==-1 or (L>>i&1)==0]\n  else:\n    LD = [d]\n  if d<len(bin(R))-3:\n    RD = [d]\n  elif d==len(bin(R))-3:\n    RD = [i for i in range(-1,d) if i==-1 or (R>>i&1)==1]\n  else:\n    RD = []\n  for ld in LD:\n    for rd in RD:\n      a = 1\n      for i in range(d):\n        # i<ld:  x==0 or 1\n        # i==ld: x==1\n        # i>ld:  x==L\n        # i<rd:  y==0 or 1\n        # i==rd: y==0\n        # i>rd:  y==R\n        # y>=x\n        if i<ld and i<rd:\n          a *= 3\n        if i<ld and i==rd:\n          a *= 1\n        if i<ld and i>rd:\n          a *= (R>>i&1)+1\n        if i==ld and i<rd:\n          a *= 1\n        if i==ld and i==rd:\n          a *= 0\n        if i==ld and i>rd:\n          a *= (R>>i&1)\n        if i>ld and i<rd:\n          a *= 2-(L>>i&1)\n        if i>ld and i==rd:\n          if (L>>i&1)==0:\n            a *= 1\n          else:\n            a *= 0\n        if i>ld and i>rd:\n          if (L>>i&1)==(R>>i&1):\n            a *= 1\n          if (L>>i&1)==0 and (R>>i&1)==1:\n            a *= 1\n          if (L>>i&1)==1 and (R>>i&1)==0:\n            a *= 0\n      ans += a\nprint(ans%(10**9+7))\n", "MOD = 10**9 + 7\n\nL, R = [int(item) for item in input().split()]\nL_blen = L.bit_length()\nR_blen = R.bit_length()\n\n# dp[y loose/tight][x loose/tight][index]\ndp = [[[0] * (R_blen+1) for _ in range(2)] for _ in range(2)]\n\nfor i in range(R_blen + 1):\n    L_bit = L & (1 << R_blen - i)\n    R_bit = R & (1 << R_blen - i)\n\n    # Form R's MSB to L's LSB can be the initial bit  \n    curbit_idx = R_blen - i + 1\n    if curbit_idx <= R_blen and curbit_idx >= L_blen:\n        dp[R_blen == curbit_idx][L_blen == curbit_idx][i] += 1\n\n    # R=0, L=0\n    if not R_bit and not L_bit:\n        # y=1, x=1\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[0][0][i] += dp[0][1][i-1] \n        # y=0, x=0\n        dp[1][1][i] += dp[1][1][i-1] \n        dp[1][0][i] += dp[1][0][i-1] \n        dp[0][0][i] += dp[0][0][i-1] \n        dp[0][1][i] += dp[0][1][i-1] \n        # y=1, x=0\n        dp[0][1][i] += dp[0][1][i-1] \n        dp[0][0][i] += dp[0][0][i-1] \n\n    # R=1, L=0\n    if R_bit and not L_bit:\n        # y=1, x=1\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[1][0][i] += dp[1][0][i-1] \n        dp[0][0][i] += dp[0][1][i-1] \n        dp[1][0][i] += dp[1][1][i-1] \n        # y=0, x=0\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[0][0][i] += dp[1][0][i-1] \n        dp[0][1][i] += dp[0][1][i-1] \n        dp[0][1][i] += dp[1][1][i-1] \n        # y=1, x=0\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[1][0][i] += dp[1][0][i-1] \n        dp[0][1][i] += dp[0][1][i-1] \n        dp[1][1][i] += dp[1][1][i-1] \n\n    # R=0, L=1\n    if not R_bit and L_bit:\n        # y=1, x=1\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[0][1][i] += dp[0][1][i-1] \n        # y=0, x=0\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[1][0][i] += dp[1][0][i-1] \n        # y=1, x=0\n        dp[0][0][i] += dp[0][0][i-1]\n\n    # R=1, L=1\n    if R_bit and L_bit:\n        # y=1, x=1\n        dp[0][0][i] += dp[0][0][i-1] \n        dp[1][0][i] += dp[1][0][i-1] \n        dp[0][1][i] += dp[0][1][i-1] \n        dp[1][1][i] += dp[1][1][i-1] \n        # y=0, x=0\n        dp[0][0][i] += dp[1][0][i-1] \n        dp[0][0][i] += dp[0][0][i-1] \n        # y=1, x=0\n        dp[1][0][i] += dp[1][0][i-1] \n        dp[0][0][i] += dp[0][0][i-1] \n\n    # Take MOD\n    for i in range(2):\n        for j in range(2):\n            dp[i][j][i] %= MOD\n\nans = 0\nfor i in range(2):\n    for j in range(2):\n        ans += dp[i][j][-1]\n        ans %= MOD\nprint(ans)", "import os\nimport os\nimport sys\nfrom collections import defaultdict\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nL, R = list(map(int, sys.stdin.readline().split()))\n\n\ndef test(L, R):\n    ans = 0\n    cnt = defaultdict(int)\n    for x in range(L, R + 1):\n        for y in range(x, R + 1):\n            if y % x == y ^ x:\n                cnt[x + y % x] += 1\n                ans += 1\n    return ans\n\n\ndef solve(L, R):\n    ret = L == 1\n    for msb in range(R.bit_length()):\n        r = min(R, (1 << msb + 1) - 1)\n        l = max(L, (1 << msb))\n        if l > r:\n            continue\n        # print(bin(r), bin(l))\n        # dp[d][n][r\u3088\u308a\u4e0b\u3092\u9078\u3093\u3060][l\u3088\u308a\u4e0a\u3092\u9078\u3093\u3060]\n        dp = np.zeros((r.bit_length(), 2, 2), dtype=int)\n        for d in reversed(list(range(r.bit_length() - 1))):\n            dp[-1][0][0] = 1\n            if r >> d & 1:\n                if l >> d & 1:\n                    # r == 1, l == 1\n                    # y1, x1\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                    dp[d][0][0] += dp[d + 1][0][0]\n                    # y1, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                    # y0, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][1] += dp[d + 1][0][1]\n                else:\n                    # r == 1, l == 0\n                    # y1, x1\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][1] += dp[d + 1][1][0]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                    dp[d][0][1] += dp[d + 1][0][0]\n                    # y1, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                    dp[d][0][0] += dp[d + 1][0][0]\n                    # y0, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    dp[d][1][1] += dp[d + 1][0][1]\n                    dp[d][1][0] += dp[d + 1][0][0]\n            else:\n                if l >> d & 1:\n                    # r == 0, l == 1\n                    # y1, x1\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    # y1, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    # y0, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                else:\n                    # r == 0, l == 0\n                    # y1, x1\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][1] += dp[d + 1][1][0]\n                    # y1, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    # y0, x0\n                    dp[d][1][1] += dp[d + 1][1][1]\n                    dp[d][1][0] += dp[d + 1][1][0]\n                    dp[d][0][1] += dp[d + 1][0][1]\n                    dp[d][0][0] += dp[d + 1][0][0]\n            dp[d] %= MOD\n        ret += dp[0].sum()\n        ret %= MOD\n    return int(ret)\n\n\nprint((solve(L, R)))\n# for l in range(1, R + 1):\n#     for r in range(l, R + 1):\n#         t1, t2 = solve(l, r), test(l, r)\n#         if t1 != t2:\n#             print(bin(l), bin(r), l, r, t1, t2)\n", "L,R=map(int,input().split())\nmod=10**9+7\n\nDP_ini=[[[0 for i in range(2)] for j in range(2)] for k in range(64)]\n\nimport copy\nANS=0\n\nfor begin in range(64):\n    DP=copy.deepcopy(DP_ini)\n\n    if L<(1<<(begin+1)) and (1<<begin)<=R:\n\n        if not(1<<begin <= L <  1<<(begin+1)) and not(1<<begin <= R <  1<<(begin+1)):\n            DP[begin][0][0]=1\n\n        elif 1<<begin <= L <  1<<(begin+1) and not(1<<begin <= R <  1<<(begin+1)):\n            DP[begin][1][0]=1\n\n        elif not(1<<begin <= L <  1<<(begin+1)) and 1<<begin <= R <  1<<(begin+1):\n            DP[begin][0][1]=1\n\n        else:\n            DP[begin][1][1]=1\n\n    for keta in range(begin-1,-1,-1):\n\n        if L & (1<<keta)==0 and R & (1<<keta)==0:\n            DP[keta][0][0]=DP[keta][0][0]+DP[keta+1][0][0]*3+DP[keta+1][0][1]*0+DP[keta+1][1][0]*1+DP[keta+1][1][1]*0\n            DP[keta][0][1]=DP[keta][0][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*1+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n            DP[keta][1][0]=DP[keta][1][0]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*2+DP[keta+1][1][1]*0\n            DP[keta][1][1]=DP[keta][1][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*0+DP[keta+1][1][1]*1\n\n        elif L & (1<<keta)!=0 and R & (1<<keta)==0:\n            DP[keta][0][0]=DP[keta][0][0]+DP[keta+1][0][0]*3+DP[keta+1][0][1]*0+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n            DP[keta][0][1]=DP[keta][0][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*1+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n            DP[keta][1][0]=DP[keta][1][0]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*1+DP[keta+1][1][1]*0\n            DP[keta][1][1]=DP[keta][1][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n\n        elif L & (1<<keta)==0 and R & (1<<keta)!=0:\n            DP[keta][0][0]=DP[keta][0][0]+DP[keta+1][0][0]*3+DP[keta+1][0][1]*1+DP[keta+1][1][0]*1+DP[keta+1][1][1]*0\n            DP[keta][0][1]=DP[keta][0][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*2+DP[keta+1][1][0]*0+DP[keta+1][1][1]*1\n            DP[keta][1][0]=DP[keta][1][0]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*2+DP[keta+1][1][1]*1\n            DP[keta][1][1]=DP[keta][1][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*0+DP[keta+1][1][1]*1\n        else:\n            DP[keta][0][0]=DP[keta][0][0]+DP[keta+1][0][0]*3+DP[keta+1][0][1]*1+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n            DP[keta][0][1]=DP[keta][0][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*2+DP[keta+1][1][0]*0+DP[keta+1][1][1]*0\n            DP[keta][1][0]=DP[keta][1][0]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*1+DP[keta+1][1][1]*0\n            DP[keta][1][1]=DP[keta][1][1]+DP[keta+1][0][0]*0+DP[keta+1][0][1]*0+DP[keta+1][1][0]*0+DP[keta+1][1][1]*1\n\n    #print(begin,DP[0])\n    ANS+=sum(DP[0][0])+sum(DP[0][1])\n\nprint(ANS%mod)", "from functools import lru_cache\nimport sys\nsys.setrecursionlimit(1000000)\nP = 10**9+7\n@lru_cache(maxsize=None)\ndef subcalc(l, r):\n    if l < 0 or r < 0:\n        print(\"ERROR\")\n        print(\"l, r =\", l, r)\n        print(1//0)\n    if l > r: return 0\n    if r == 0: return 1\n    aa, bb = l.bit_length(), r.bit_length()\n    if aa == bb:\n        return subcalc(l-(1<<aa-1), r-(1<<bb-1))\n    if (r & (r+1) == 0) and (l == 0):\n        return pow(3, r.bit_length(), P)\n    t = (subcalc(l, r-(1<<bb-1)) + subcalc(l, (1<<bb-1)-1) + subcalc(0, r-(1<<bb-1))) % P\n    # print(\"subcalc\", l, r, t)\n    return t\n \n@lru_cache(maxsize=None)\ndef calc(L, R):\n    if L < 0 or R < 0:\n        print(\"ERROR\")\n        print(\"l, r =\", l, r)\n        print(1//0)\n    if L > R: return 0\n    a = L.bit_length()\n    b = R.bit_length()\n    if b > a:\n        t = (calc(L, (1<<b-1)-1) + calc(1<<b-1, R)) % P\n        # print(\"calc\", L, R, t)\n        return t\n    \n        \n        \n    a = 1 << L.bit_length() - 1 if L else 0\n    t = subcalc(L-a, R-a)\n    # print(\"calc\", L, R, t)\n    return t\n \nL, R = map(int, input().split())\nprint(calc(L, R))", "import sys\nimport math\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    md = 10 ** 9 + 7\n    l, r = list(map(int, input().split()))\n    n = int(math.log2(r)) + 1\n    # dp[i][t][f][g] i\u6841\u76ee\u307e\u3067\u898b\u3066\u6700\u4e0a\u4f4d\u304c\u6c7a\u5b9a\u6e08\u307f\u304b(t)\u3001L<x\u304c\u78ba\u5b9a(f)\u3001y<R\u304c\u78ba\u5b9a\n    dp = [[[[0] * 2 for _ in range(2)] for __ in range(2)] for ___ in range(n + 1)]\n    dp[0][0][0][0] = 1\n    ans = 0\n    for i in range(n):\n        lk = l >> (n - 1 - i) & 1\n        rk = r >> (n - 1 - i) & 1\n        for t in range(2):\n            for f in range(2):\n                for g in range(2):\n                    pre = dp[i][t][f][g]\n                    for x, y in [(0, 0), (0, 1), (1, 1)]:\n                        nt, nf, ng = t, f, g\n                        if t == 0 and (x, y) == (0, 1): continue\n                        if f == 0 and lk > x: continue\n                        if g == 0 and y > rk: continue\n                        if (x, y) == (1, 1): nt = 1\n                        if lk == 0 and x == 1: nf = 1\n                        if y == 0 and rk == 1: ng = 1\n                        if i == n - 1:\n                            ans = (ans + pre) % md\n                        else:\n                            dp[i + 1][nt][nf][ng] = (dp[i + 1][nt][nf][ng] + pre) % md\n    print(ans)\n\nmain()\n", "L, R = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1]\nr = '{:060b}'.format(R)[::-1]\n\nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n\ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0, y 0\n    if flagX or l[pos] == '0':\n        ret += f(pos - 1, flagX, 1 if r[pos] == '1' else flagY, flagZ)\n    # x 0, y 1\n    if (flagX or l[pos] == '0') and (flagY or r[pos] == '1') and flagZ:\n        ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1, y 1\n    if flagY or r[pos] == '1':\n        ret += f(pos - 1, 1 if l[pos] == '0' else flagX, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n\nans = f(59, 0, 0, 0)\nprint(ans)\n", "# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306e\u3068\u304d\u306f\u6ce8\u610f\n\n#n = int(input())\nl,r = [int(i) for i in readline().split()]\n\ndef make_dp(init, size):\n    res = \"[{}]*{}\".format(init,size[-1])\n    for i in reversed(size[:-1]):\n        res = \"[{} for _ in [0]*{}]\".format(res,i)\n    return eval(res)\n\n\nMOD = 10**9 + 7\n\nR = bin(r)[2:]\nL = bin(l)[2:]\nL = \"0\"*(len(R)-len(L)) + L\n\ndp = make_dp(0,(len(R)+1,2,2,2))\ndp[0][0][0][0] = 1\nfor i, (r,l) in enumerate(zip(R,L)): #i\u6841\u76ee\u304b\u3089i+1\u6841\u76ee\u306b\u9077\u79fb\n    ri = int(r)\n    li = int(l)\n    for is_less in range(2):\n        for is_more in range(2):\n            for is_nonzero in range(2):\n                for dl in range(0 if is_more else li,2):\n                    for dr in range(dl, 2 if is_less else ri+1): # d: i+1\u6841\u76ee\u306e\u6570\u5b57\n                        dp[i+1][is_nonzero or dr != 0][is_more or li < dl][is_less or dr < ri] += dp[i][is_nonzero][is_more][is_less]*(dr==dl or is_nonzero)\n                        dp[i+1][is_nonzero or dr != 0][is_more or li < dl][is_less or dr < ri] %= MOD\n\n#print(dp[-1])\nans = 0\nfor i in range(2):\n    for j in range(2):\n        for k in range(2):\n            ans += dp[-1][i][j][k]\n\nprint((ans%MOD))\n\n", "\nimport bisect\nimport collections\nimport itertools\n\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint2d(rows): return [getints() for _ in range(rows)]\ndef getgrid(rows): return [input() for _ in range(rows)]\ndef array1d(n, value): return [value for _ in range(n)]\ndef array2d(n, m, value): return [array1d(m, value) for _ in range(n)]\n\nmin_val,max_val=getints()\n\ndef get_key(pos, is_small, is_large, found):\n    return ((pos * 2 + is_small) * 2 + is_large) * 2 + found\n\nmod = 10**9 + 7\ncache = [-1] * get_key(64,1,1,1)\n\ndef solve(pos, is_small, is_large, found):\n    if pos < 0:\n        return 1\n    key = get_key(pos,is_small,is_large,found)\n    res = cache[key]\n    if res >= 0:\n        return res\n\n    res = 0\n    for x in [0,1]:\n        for y in [0,1]:\n            if x == 1 and y == 0: continue\n            if not is_small and x == 0 and (min_val >> pos & 1) == 1:\n                continue\n            if not is_large and y == 1 and (max_val >> pos & 1) == 0:\n                continue\n            if not found and x != y:\n                continue\n            new_is_small = True if x > (min_val >> pos & 1) else is_small\n            new_is_large = True if y < (max_val >> pos & 1) else is_large\n            new_found    = True if x == y and x == 1 else found\n            res += solve(pos-1, new_is_small, new_is_large, new_found)\n\n    res = res % mod\n    cache[key] = res\n    return res\n\nprint(solve(63, False, False, False))", "L,R = map(int,input().split())\n\nmod = 10**9+7\nm = 64 +1\nfac = [1]*m\nninv = [1]*m\nfinv = [1]*m\nfor i in range(2,m):\n    fac[i] = fac[i-1]*i%mod\n    ninv[i] = (-(mod//i)*ninv[mod%i])%mod\n    finv[i] = finv[i-1]*ninv[i]%mod\n\ndef comb(n,k):\n    return (fac[n]*finv[k]%mod)*finv[n-k]%mod\n\ndef f(L,R):\n    if L>R : return 0\n    R = bin(R)[2:]\n    N = len(R)\n    ret = f(L,int(\"0\"+\"1\"*(N-1),2))\n    L = bin(L)[2:]\n    if len(L) != N : L = \"1\"+\"0\"*(N-1)\n    for i in range(N):\n        if R[i] == \"0\" : continue\n        R2 = R[:i] + \"0\" + \"?\"*(N-i-1)\n        if i==0: R2 = R\n        for j in range(N):\n            if L[j] == \"1\" and j!=0 : continue\n            L2 = L[:j] + \"1\" + \"?\"*(N-j-1)\n            if j==0 : L2 = L\n            if L2[0] == \"0\" : break\n            tmp = 1\n            for r,l in zip(R2[1:],L2[1:]):\n                if r==\"0\" and l==\"1\" : tmp *= 0\n                if r==\"?\" and l==\"?\" : tmp *= 3\n                if r==\"?\" and l==\"0\" : tmp *= 2\n                if r==\"1\" and l==\"?\" : tmp *= 2\n                tmp %= mod\n            ret += tmp\n            ret %= mod\n    return ret%mod\n\nprint(f(L,R))", "L,R = map(int,input().split())\n\nmod = 10**9+7\nm = 64 +1\nfac = [1]*m\nninv = [1]*m\nfinv = [1]*m\nfor i in range(2,m):\n    fac[i] = fac[i-1]*i%mod\n    ninv[i] = (-(mod//i)*ninv[mod%i])%mod\n    finv[i] = finv[i-1]*ninv[i]%mod\n\ndef comb(n,k):\n    return (fac[n]*finv[k]%mod)*finv[n-k]%mod\n\ndef f(N):\n    if N==0:return 0\n    S = bin(N)[2:]\n    L = len(S)\n    ret = pow(2,S.count(\"1\")-1,mod)\n    for i in range(L):\n        if S[i] == \"0\" : continue\n        c = S[:i].count(\"1\")\n        j = max(0,L-i-1)\n        for k in range(j+1):\n            if c+k == 0 : continue\n            ret += pow(2,c+k-1,mod)*comb(j,k)\n            ret %= mod\n    return ret\n\ndef g(R,L):\n    if L==0 : return 0\n    Nr = len(bin(R))-2\n    Nl = len(bin(L))-2\n    if Nr!=Nl :\n        R = int(\"1\"*Nl,2)\n        Nr = Nl\n    ret = f(int(\"0\"+\"1\"*(Nr-1),2))\n    \n    R = bin(R)[2:]\n    L = bin(L)[2:]\n    for i in range(Nr):\n        if R[i] == \"0\": continue\n        if i==0 : R2 = R\n        else: R2 = R[:i] + \"0\" + \"?\"*(Nr-i-1)\n        for j in range(Nl):\n            if L[j] == \"0\" : continue\n            if j==0 : L2 = L\n            else: L2 = L[:j] + \"0\" + \"?\"*(Nl-j-1)\n            tmp = 1\n            for r,l in zip(R2,L2):\n                if r==l==\"?\" : tmp *= 3\n                if r==\"?\" and l==\"0\" : tmp *= 2\n                if r==\"1\" and l==\"?\" : tmp *= 2\n                if r==\"0\" and l==\"1\" : tmp *= 0\n                tmp %= mod\n            ret += tmp\n    return ret\n\nprint((f(R)-g(R,L-1))%mod)", "from itertools import product\nL, R = list(map(int, input().split()))\nMOD = 10**9 + 7\n\ndp = [[[0, 0] for _ in range(2)] for _ in range(2)]\npp = [[[0, 0] for _ in range(2)] for _ in range(2)]\ndp[0][0][0] = 1\nfor d in range(60, -1, -1):\n    pp, dp = dp, pp\n    dp = [[[0, 0] for _ in range(2)] for _ in range(2)]\n    lb = L>>d & 1\n    rb = R>>d & 1\n    if d == 1:\n        pass\n    ans = 0\n    for lrs in product((0,1), repeat=3):\n        l, r, s = lrs\n        for xy in product((0,1), repeat=2):\n            nl, nr, ns = l, r, s\n            x, y = xy\n            if x and not y:\n                continue\n            if not s and x != y:\n                continue\n            if x and y:\n                ns = 1\n            if not l and not x and lb:\n                continue\n            if x and not lb:\n                nl = 1\n            if not r and y and not rb:\n                continue\n            if not y and rb:\n                nr = 1\n            dp[nl][nr][ns] += pp[l][r][s]\n            dp[nl][nr][ns] %= MOD\n\nprint((sum(dp[l][r][s] for l in (0,1) for r in (0,1) for s in (0,1)) % MOD))\n", "L, R = map(int, input().split())\nMOD = 10**9 + 7\n\n*BL, = map(int, bin(L)[2:])\n*BR, = map(int, bin(R)[2:])\n\na = len(BL)\nb = len(BR)\nBL = [0]*(len(BR) - len(BL)) + BL\n\nBL.reverse()\nBR.reverse()\n\nmemo = [[[-1]*2 for i in range(2)] for j in range(70)]\ndef dfs(i, p, q):\n    if memo[i][p][q] != -1:\n        return memo[i][p][q]\n    if i == -1:\n        memo[i][p][q] = 1\n        return 1\n    r = 0\n    if p == q == 0:\n        if BL[i] == 1 and BR[i] == 0:\n            memo[i][0][0] = 0\n            return 0\n        if BL[i] == 1 or BR[i] == 0:\n            r = dfs(i-1, 0, 0)\n        else:\n            r = (dfs(i-1, 0, 1) + dfs(i-1, 1, 0) + dfs(i-1, 0, 0)) % MOD\n    elif p == 0:\n        if BL[i] == 1:\n            r = dfs(i-1, 0, 1)\n        else:\n            r = (2*dfs(i-1, 0, 1) + dfs(i-1, 1, 1)) % MOD\n    elif q == 0:\n        if BR[i] == 0:\n            r = dfs(i-1, 1, 0)\n        else:\n            r = (2*dfs(i-1, 1, 0) + dfs(i-1, 1, 1)) % MOD\n    else:\n        r = 3 * dfs(i-1, 1, 1)\n    memo[i][p][q] = r\n    return r\nans = 0\nfor l in range(a-1, b):\n    ans += dfs(l-1, +(not a-1 == l), +(not b-1 == l))\nprint(ans % MOD)", "L, R = map(int, input().split())\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1]\nr = '{:060b}'.format(R)[::-1]\n \nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n \ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0 y 0\n    if l[pos] == '0' or flagX:\n      ret += f(pos - 1, flagX, 1 if flagY or r[pos] == '1' else 0, flagZ)\n    # x 0 y 1\n    if (l[pos] == '0' or flagX) and (r[pos] == '1' or flagY) and flagZ:\n      ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1 y 1\n    if r[pos] == '1' or flagY:\n      ret += f(pos - 1, 1 if l[pos] == '0' or flagX else 0, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n \nans = f(59, 0, 0, 0)\nprint(ans)", "\nLARGE = 10 ** 9 + 7\n\n# flag_x : left < x\n# flag_y : y < right\n# flag_z : msb\n\n\ndef f(pos, flag_x, flag_y, flag_z, memo, left, right):\n    if pos == -1:\n        return 1\n    if memo[pos][flag_x][flag_y][flag_z] != -1:\n        return memo[pos][flag_x][flag_y][flag_z]\n    ret = 0\n    # x 0, y 0\n    if flag_x or left[pos] == '0':\n        ret += f(pos - 1, flag_x, 1 if right[pos] == '1' else flag_y, flag_z, memo, left, right)\n    # x 0, y 1\n    if (flag_x or left[pos] == '0') and (flag_y or right[pos] == '1') and flag_z:\n        ret += f(pos - 1, flag_x, flag_y, flag_z, memo, left, right)\n    # x 1, y 1\n    if flag_y or right[pos] == '1':\n        ret += f(pos - 1, 1 if left[pos] == '0' else flag_x, flag_y, 1, memo, left, right)\n    ret %= LARGE\n    memo[pos][flag_x][flag_y][flag_z] = ret\n    return ret\n\n\ndef solve_greed_f(L, R):\n\n    res_g = 0\n\n    for i in range(L, R + 1):\n        for j in range(i, R + 1):\n            if j % i == j ^ i:\n                res_g += 1\n\n    return res_g\n\n\ndef main():\n\n    ll, rr = list(map(int, input().split()))\n\n    left = '{:060b}'.format(ll)[::-1]\n    right = '{:060b}'.format(rr)[::-1]\n\n    memo = [[[[-1 for m in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n\n    res = f(59, 0, 0, 0, memo, left, right)\n\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import lru_cache\nP = 10**9+7\n@lru_cache(maxsize=None)\ndef subcalc(l, r):\n    if l > r: return 0\n    if r == 0: return 1\n    aa, bb = l.bit_length(), r.bit_length()\n    if aa == bb:\n        return subcalc(l-(1<<aa-1), r-(1<<bb-1))\n    if (r & (r+1) == 0) and (l == 0):\n        return pow(3, r.bit_length(), P)\n    return (subcalc(l, r-(1<<bb-1)) + subcalc(l, (1<<bb-1)-1) + subcalc(0, r-(1<<bb-1))) % P\n\n@lru_cache(maxsize=None)\ndef calc(L, R):\n    if L > R: return 0\n    a = L.bit_length()\n    b = R.bit_length()\n    if b > a:\n        return (calc(L, (1<<b-1)-1) + calc(1<<b-1, R)) % P\n    a = 1 << L.bit_length() - 1 if L else 0\n    return subcalc(L-a, R-a)\n\nL, R = list(map(int, input().split()))\nprint((calc(L, R)))\n", "l, r = input().split()\nl = int(l)\nr = int(r)\n\ndp = [[[-1 for k in range(2)] for j in range(2)] for i in range(64)]\n\ndef bbin(num):\n    res = []\n    while num:\n        res.append(num % 2)\n        num //= 2\n\n    return res\n\nnumr = bbin(r)\nnuml = bbin(l)\nwhile len(numl) < len(numr):\n    numl.append(0)\n\ndef rec(pos, brr, brl):\n    nonlocal numl, numr, dp\n    if pos < 0:\n        return 1\n\n    if dp[pos][brr][brl] != -1:\n        return dp[pos][brr][brl]\n\n    res = 0\n    if brr:\n        if brl:\n            res = 3 * rec(pos - 1, brr, brl)\n        else:\n            if numl[pos] == 1:\n                res = rec(pos - 1, brr, brl)\n            else:\n                res += (2 * rec(pos - 1, brr, 0))\n                res += rec(pos - 1, brr, 1)\n    else:\n        if numr[pos] == 1:\n            if brl:\n                res += (2 * rec(pos - 1, 0, brl))\n                res += rec(pos - 1, 1, brl)\n            else:\n                if numl[pos] == 1:\n                    res += rec(pos - 1, 0, brl)\n                else:\n                    res += rec(pos - 1, 0, 0)\n                    res += rec(pos - 1, 0, 1)\n                    res += rec(pos - 1, 1, 0)\n        else:\n            if brl:\n                res += rec(pos - 1, 0, brl)\n            elif numl[pos] == 0:\n                res += rec(pos - 1, 0, 0)\n\n    dp[pos][brr][brl] = res % (10**9 + 7)\n    return dp[pos][brr][brl]\n\nc = 0\nfor i in range(len(numl) - 1, -1, -1):\n    if numl[i] == 1:\n        c += rec(i - 1, 1 if i < len(numl) - 1 else 0, 0)\n        break\n    else:\n        c += rec(i - 1, 1 if i < len(numl) - 1 else 0, 1)\n\nprint(c % (10**9 + 7))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nfrom functools import lru_cache\n\nMOD = 10 ** 9 + 7\n\n\"\"\"\n\u6841\u6570\u304c\u7570\u306a\u308b\u3068\u77db\u76fe\n\u3057\u305f\u304c\u3063\u3066\u5546\u304c1\u3067\u3042\u308b\u3053\u3068\u304c\u5fc5\u8981\n\u3059\u308b\u3068\u3001x\u304cy\u306esubset\u3067\u3042\u308b\u3053\u3068\u304c\u5fc5\u8981\n\u4e00\u756a\u4e0a\u306e\u6841\u3092\u542b\u3080subset\u304cx\n\"\"\"\n\n@lru_cache()\ndef F_naive(L,R):\n    # \n    ret = 0\n    ret += F((L+1)//2,(R+1)//2) # 2x,2y\n    answer = 0\n    for x in range(L,R+1):\n        for y in range(x,R+1):\n            if x.bit_length() == y.bit_length() and (x^y)+x == y:\n                answer += 1\n    return answer\n\n@lru_cache()\ndef F(L,R):\n    # x subset y \u304b\u3064 2x > y\n    if L < 0:\n        L = 0\n    if R < L:\n        return 0\n    if R == 0:\n        return 0\n    ret = 0\n    # \u4e0b\u4e00\u6841\u304c0,0\u3068\u3068\u308b\u5834\u5408\n    ret += F((L+1)//2, R//2)\n    # \u4e0b\u4e00\u6841\u304c0,1\u3068\u3068\u308b\u5834\u5408\n    # 2(2x) > (2y+1) iff 2x > y\n    ret += F((L+1)//2,(R-1)//2)\n    # \u4e0b\u4e00\u6841\u304c1,0\u3068\u3068\u308b\u5834\u5408\n    # \u3053\u308c\u306fsubset\u306b\u306a\u3089\u306a\u3044\n\n    # \u4e0b\u4e00\u6841\u304c1,1\u3068\u3068\u308b\u5834\u5408\n    # 2(2x+1) > 2y+1 iff 2x >= y\n    ret += G(L//2,(R-1)//2)\n    return ret\n\n@lru_cache()\ndef G(L,R):\n    # x subset y \u304b\u3064 2x >= y\n    if L < 0:\n        L = 0\n    if R < L:\n        return 0\n    if R == 0:\n        return 1\n    ret = 0\n    # \u4e0b\u4e00\u6841\u304c0,0\u3068\u3068\u308b\u5834\u5408\n    ret += G((L+1)//2, R//2)\n    # \u4e0b\u4e00\u6841\u304c0,1\u3068\u3068\u308b\u5834\u5408\n    # 2(2x) >= (2y+1) iff 2x > y\n    ret += F((L+1)//2,(R-1)//2)\n    # \u4e0b\u4e00\u6841\u304c1,0\u3068\u3068\u308b\u5834\u5408\n    # \u3053\u308c\u306fsubset\u306b\u306a\u3089\u306a\u3044\n\n    # \u4e0b\u4e00\u6841\u304c1,1\u3068\u3068\u308b\u5834\u5408\n    # 2(2x+1) >= 2y+1 iff 2x >= y\n    ret += G(L//2,(R-1)//2)\n    return ret\n\nL,R = map(int,input().split())\nanswer = F(L,R) % MOD\nprint(answer)", "L,R = map(int,input().split())\n\nmod = 10**9+7\n\ndef f(L,R):\n    if L>R : return 0\n    R = bin(R)[2:]\n    N = len(R)\n    ret = f(L,int(\"0\"+\"1\"*(N-1),2))\n    L = bin(L)[2:]\n    if len(L) != N : L = \"1\"+\"0\"*(N-1)\n    for i in range(N):\n        if R[i] == \"0\" : continue\n        R2 = R[:i] + \"0\" + \"?\"*(N-i-1)\n        if i==0: R2 = R\n        for j in range(N):\n            if j==0 : L2 = L\n            elif L[j] == \"1\" : continue\n            else : L2 = L[:j] + \"1\" + \"?\"*(N-j-1)\n\n            tmp = 1\n            for r,l in zip(R2,L2):\n                if r==\"0\" and l==\"1\" : tmp *= 0 ; break\n                elif r==\"?\" and l==\"?\" : tmp = tmp*3%mod\n                elif r==\"?\" and l==\"0\" : tmp = tmp*2%mod\n                elif r==\"1\" and l==\"?\" : tmp = tmp*2%mod\n            ret += tmp\n            ret %= mod\n    return ret\n\nprint(f(L,R))", "L, R = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1]\nr = '{:060b}'.format(R)[::-1]\n\nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n\ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0, y 0\n    if flagX or l[pos] == '0':\n        ret += f(pos - 1, flagX, 1 if r[pos] == '1' else flagY, flagZ)\n    # x 0, y 1\n    if (flagX or l[pos] == '0') and (flagY or r[pos] == '1') and flagZ:\n        ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1, y 1\n    if flagY or r[pos] == '1':\n        ret += f(pos - 1, 1 if l[pos] == '0' else flagX, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n\nans = f(59, 0, 0, 0)\nprint(ans)\n", "L, R = list(map(int, input().split()))\nans = 0\nmod = 10 ** 9 + 7\nfor d in range(62):  # \u6700\u4e0a\u4f4d bit\n    # dp[n] := n \u6841\u76ee\u307e\u3067\u898b\u305f\u6642\u306b\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u304c\u4f55\u500b\u3042\u308b\u304b\n    # dp_small[n] := n \u6841\u76ee\u307e\u3067\u898b\u305f\u6642\u306b\u3001l \u3068 x \u304c n \u6841\u76ee\u307e\u3067\u4e00\u81f4\u3057\u3066\u3044\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u304c\u4f55\u500b\u3042\u308b\u304b\n    l = max(1<<d, L)\n    r = min((2<<d)-1, R)\n    if l > r:\n        continue\n    dp_small = [0] * (d+2)\n    dp_ok = [0] * (d+2)\n    dp_large = [0] * (d+2)\n    dp_small_large = [0] * (d+2)\n    dp_small_large[0] = 1\n    for n in range(1, d+2):\n        i = d-n+1\n        dp_ok[n] = dp_ok[n-1] * 3 \\\n                 + (dp_small[n-1] if l>>i&1==0 else 0) \\\n                 + (dp_large[n-1] if r>>i&1 else 0)\n        dp_small[n] = dp_small[n-1] * (1 if l>>i&1 else 2) \\\n                    + (dp_small_large[n-1] if l>>i&1 < r>>i&1 else 0)\n        dp_large[n] = dp_large[n-1] * (2 if r>>i&1 else 1) \\\n                    + (dp_small_large[n-1] if l>>i&1 < r>>i&1 else 0)\n        dp_small_large[n] = dp_small_large[n-1] if l>>i&1 <= r>>i&1 else 0\n    a = dp_ok[d+1] + dp_large[d+1] + dp_small[d+1] + dp_small_large[d+1]\n    ans += a\n    # print(f\"d={d},a={a},l={l},r={r}\")\n    # print(f\"dp_ok={dp_ok}\")\n    # print(f\"dp_small={dp_small}\")\n    # print(f\"dp_large={dp_large}\")\n    # print(f\"dp_small_large={dp_small_large}\")\n    # print()\nprint((ans % mod))\n", "L,R = map(int,input().split())\n\nmod = 10**9+7\n\ndef f(L,R):\n    if L>R : return 0\n    R = bin(R)[2:]\n    N = len(R)\n    ret = f(L,int(\"0\"+\"1\"*(N-1),2))\n    L = bin(L)[2:]\n    if len(L) != N : L = \"1\"+\"0\"*(N-1)\n    for i in range(N):\n        if R[i] == \"0\" : continue\n        R2 = R[:i] + \"0\" + \"?\"*(N-i-1)\n        if i==0: R2 = R\n        for j in range(N):\n            if L[j] == \"1\" and j!=0 : continue\n            L2 = L[:j] + \"1\" + \"?\"*(N-j-1)\n            if j==0 : L2 = L\n            tmp = 1\n            for r,l in zip(R2,L2):\n                if r==\"0\" and l==\"1\" : tmp *= 0 ; break\n                elif r==\"?\" and l==\"?\" : tmp = tmp*3%mod\n                elif r==\"?\" and l==\"0\" : tmp = tmp*2%mod\n                elif r==\"1\" and l==\"?\" : tmp = tmp*2%mod\n            ret += tmp\n            ret %= mod\n    return ret\n\nprint(f(L,R))", "l,r=map(int,input().split())\nM=len(bin(r))-2\nL=format(l,\"b\").zfill(M)\nR=format(r,\"b\")\nmod=10**9+7\ndp=[[0 for l in range(70)] for i in range(5)]\nif L[0]==\"1\":\n  dp[2][0]=1\nelse:\n  dp[3][0]=1\n  dp[0][0]=1\nfor i in range(1,M):\n  if L[i]==\"1\" and R[i]==\"1\":\n    dp[1][i]=(dp[0][i-1]+dp[1][i-1])%mod\n    dp[2][i]=(dp[2][i-1])%mod\n    dp[3][i]=(2*dp[3][i-1])%mod\n    dp[4][i]=(dp[3][i-1]+3*dp[4][i-1])%mod\n  elif L[i]==\"1\" and R[i]==\"0\":\n    dp[1][i]=dp[1][i-1]+dp[0][i-1]\n    dp[3][i]=dp[3][i-1]\n    dp[4][i]=(dp[4][i-1]*3)%mod\n  elif L[i]==\"0\" and R[i]==\"1\":\n    dp[0][i]=dp[0][i-1]\n    dp[1][i]=(2*dp[1][i-1]+dp[2][i-1])%mod\n    dp[2][i]=dp[2][i-1]\n    dp[3][i]=(dp[2][i-1]+dp[3][i-1]*2)%mod\n    dp[4][i]=(dp[0][i-1]+dp[1][i-1]+dp[3][i-1]+dp[4][i-1]*3)%mod\n  else:\n    dp[0][i]=dp[0][i-1]\n    dp[1][i]=(dp[1][i-1]*2)%mod\n    dp[2][i]=dp[2][i-1]\n    dp[3][i]=(dp[3][i-1])%mod\n    dp[4][i]=(dp[0][i-1]+dp[1][i-1]+dp[4][i-1]*3)%mod\nans=0\nfor i in range(5):\n  ans+=dp[i][M-1]\n  ans%=mod\nprint(ans)", "L,R = map(int,input().split())\n\nmod = 10**9+7\nm = 64 +1\nfac = [1]*m\nninv = [1]*m\nfinv = [1]*m\nfor i in range(2,m):\n    fac[i] = fac[i-1]*i%mod\n    ninv[i] = (-(mod//i)*ninv[mod%i])%mod\n    finv[i] = finv[i-1]*ninv[i]%mod\n\ndef comb(n,k):\n    return (fac[n]*finv[k]%mod)*finv[n-k]%mod\n\ndef f(L,R):\n    if L>R : return 0\n    R = bin(R)[2:]\n    N = len(R)\n    ret = f(L,int(\"0\"+\"1\"*(N-1),2))\n    L = bin(L)[2:]\n    if len(L) != N : L = \"1\"+\"0\"*(N-1)\n    for i in range(N):\n        if R[i] == \"0\" : continue\n        R2 = R[:i] + \"0\" + \"?\"*(N-i-1)\n        if i==0: R2 = R\n        for j in range(N):\n            if L[j] == \"1\" and j!=0 : continue\n            L2 = L[:j] + \"1\" + \"?\"*(N-j-1)\n            if j==0 : L2 = L\n            if L2[0] == \"0\" : break\n            tmp = 1\n            for r,l in zip(R2[1:],L2[1:]):\n                if r==\"0\" and l==\"1\" : tmp *= 0\n                if r==\"?\" and l==\"?\" : tmp *= 3\n                if r==\"?\" and l==\"0\" : tmp *= 2\n                if r==\"1\" and l==\"?\" : tmp *= 2\n            ret += tmp\n            ret %= mod\n    return ret%mod\n\nprint(f(L,R))", "m=10**9+7\nl,r=list(map(int,input().split()))\ndp=[[[[0 for _ in range(2)] for _ in range(2)] for _ in range(2)] for _ in range(61)]\n\ndp[60][0][0][0]=1\n\nfor i in reversed(list(range(60))):\n  lb=l>>i&1\n  rb=r>>i&1\n  for j in range(2):\n    for k in range(2):\n      for s in range(2):\n        pre=dp[i+1][j][k][s]\n        for x,y in [(0,0),(0,1),(1,1)]: # excpet for (1,0) (because of x<y)\n          nj,nk,ns=j,k,s\n          # s\n          if (s==0 and x==0 and y==1): continue; # skip for not x==y==1\n          if (s==0 and x&y): ns=1;\n          # j\n          if (j==0 and lb==1 and x==0): continue; # skip for x<l\n          if (j==0 and lb==0 and x==1): nj=1;\n          # k\n          if (k==0 and rb==0 and y==1): continue; # skip for r<y\n          if (k==0 and rb==1 and y==0): nk=1;           \n            \n          dp[i][nj][nk][ns]+=pre\n          dp[i][nj][nk][ns]%=m    \n                  \nans=0             \nfor j in range(2):\n  for k in range(2):\n    ans+=dp[0][j][k][1]\n    ans%=m\nprint(ans)\n                  \n", "L, R = map(int, input().split())\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1]\nr = '{:060b}'.format(R)[::-1]\n \nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n \ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0, y 0\n    if flagX or l[pos] == '0':\n        ret += f(pos - 1, flagX, 1 if r[pos] == '1' else flagY, flagZ)\n    # x 0, y 1\n    if (flagX or l[pos] == '0') and (flagY or r[pos] == '1') and flagZ:\n        ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1, y 1\n    if flagY or r[pos] == '1':\n        ret += f(pos - 1, 1 if l[pos] == '0' else flagX, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n \nans = f(59, 0, 0, 0)\nprint(ans)", "MOD = 10**9 + 7\nclass mint:\n    def __init__(self, i):\n        self.i = i\n    def __add__(self, m):\n        t = self.i + (m.i if isinstance(m, mint) else m)\n        if t > MOD:\n            t -= MOD\n        return mint(t)\n    def __radd__(self, m):\n        t = self.i + (m.i if isinstance(m, mint) else m)\n        if t > MOD:\n            t -= MOD\n        return mint(t)\n    def __mul__(self, m):\n        return mint(self.i * (m.i if isinstance(m, mint) else m) % MOD)\n    def __sub__(self, m):\n        t = self.i - m.i\n        if t < 0:\n            t += MOD\n        return mint(t)\n    def __pow__(self, m):\n        i = self.i\n        res = 1\n        while(m > 0):\n            if m & 1:\n                res = res * i % MOD \n            i = i * i % MOD\n            m >>= 1\n        return mint(res)\n    def __truediv__(self, m):\n        return mint(self.i * (m ** (MOD - 2)).i % MOD)\n    def __repr__(self):\n        return repr(self.i)\n\nL, R = map(int, input().split())\ndp = [[mint(0) for _ in range(4)] for _ in range(61)]\n\nfor d in range(60, 0, -1):\n    l = L >> d - 1 & 1\n    r = R >> d - 1 & 1\n    \n    if (L >> d - 1) == 0:\n        if (R >> d - 1) > 1:\n            dp[d-1][3] += 1\n        elif (R >> d - 1) == 1:\n            dp[d-1][2] += 1\n    elif (L >> d - 1) == 1:\n        if (R >> d - 1) > 1:\n            dp[d-1][1] += 1\n        else:\n            dp[d-1][0] += 1\n\n    # x bound, y bound\n    if l == r:\n        dp[d-1][0] += dp[d][0]\n    elif l < r:\n        dp[d-1][0] += dp[d][0]\n        dp[d-1][1] += dp[d][0]\n        dp[d-1][2] += dp[d][0]\n    # x bound, y free\n    if l == 0:\n        dp[d-1][1] += dp[d][1] * 2\n        dp[d-1][3] += dp[d][1]\n    else:\n        dp[d-1][1] += dp[d][1]\n    # x free, y bound\n    if r == 1:\n        dp[d-1][2] += dp[d][2] * 2\n        dp[d-1][3] += dp[d][2]\n    else:\n        dp[d-1][2] += dp[d][2]\n    # x free, y free\n    dp[d-1][3] += dp[d][3] * 3\n\nprint(sum(dp[0]))", "L, R = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1]\nr = '{:060b}'.format(R)[::-1]\n\nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n\ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0, y 0\n    if flagX or l[pos] == '0':\n        ret += f(pos - 1, flagX, 1 if r[pos] == '1' else flagY, flagZ)\n    # x 0, y 1\n    if (flagX or l[pos] == '0') and (flagY or r[pos] == '1') and flagZ:\n        ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1, y 1\n    if flagY or r[pos] == '1':\n        ret += f(pos - 1, 1 if l[pos] == '0' else flagX, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n\nans = f(59, 0, 0, 0)\nprint(ans)\n", "def count(lb, rb):\n    assert lb[0] == '1'\n    assert rb[0] == '1'\n    assert len(lb) == len(rb)\n    dp = [1, 0, 0, 0]\n    for lc, rc in zip(lb[1:], rb[1:]):\n        ndp = [dp[0], 0, 0, 0]\n        if rc == '0':\n            ndp[1] += dp[1]\n            if lc == '1':\n                ndp[0] = 0\n        else:\n            ndp[1] += dp[1] * 2\n            ndp[2] += dp[1]\n            if lc == '0':\n                ndp[1] += dp[0]\n                ndp[3] += dp[0]\n        if lc == '0':\n            ndp[2] += dp[3]\n            ndp[3] += dp[3] * 2\n        else:\n            ndp[3] += dp[3]\n        ndp[2] += dp[2] * 3\n        dp = ndp\n    return sum(dp)\n\n\nl, r = list(map(int, input().split()))\nlb = bin(l)[2:]\nrb = bin(r)[2:]\nld = len(lb)\nrd = len(rb)\nans = 0\nMOD = 10 ** 9 + 7\nfor d in range(ld, rd + 1):\n    tlb = lb if d == ld else '1' + '0' * (d - 1)\n    trb = rb if d == rd else '1' * d\n    ans = (ans + count(tlb, trb)) % MOD\nprint(ans)\n", "L, R = list(map(int, input().split()))\n\n\"\"\"\nR ????????1??????\ny 0001????0??????\n     ^d   ^rd\nx 0001???????1??\n             ^ld\nL ???????????0???\n\"\"\"\n\nans = 0\n\nfor d in range(70):\n  if d<len(bin(L))-3:\n    LD = []\n  elif d==len(bin(L))-3:\n    LD = [i for i in range(-1,d) if i==-1 or (L>>i&1)==0]\n  else:\n    LD = [d]\n  if d<len(bin(R))-3:\n    RD = [d]\n  elif d==len(bin(R))-3:\n    RD = [i for i in range(-1,d) if i==-1 or (R>>i&1)==1]\n  else:\n    RD = []\n  for ld in LD:\n    for rd in RD:\n      a = 1\n      for i in range(d):\n        if i<ld:\n          xc = [0, 1]\n        elif i==ld:\n          xc = [1]\n        else:\n          xc = [L>>i&1]\n        if i<rd:\n          yc = [0, 1]\n        elif i==rd:\n          yc = [0]\n        else:\n          yc = [R>>i&1]\n        c = 0\n        for x in xc:\n          for y in yc:\n            if y>=x:\n              c += 1\n        a *= c\n      ans += a\nprint(ans%(10**9+7))\n", "mod = 10 ** 9 + 7\n\nmemo = {}\ndef solve(L, R):\n    if (L, R) in memo:\n        return memo[(L, R)]\n\n    if L > R:\n        res = 0\n    elif L == 1:\n        res = 1 + solve(2, R)\n    else:\n        res = (\n            solve(L // 2, (R - 1) // 2) +\n            solve((L + 1) // 2, R // 2) +\n            solve((L + 1) // 2, (R - 1) // 2)\n        )\n\n    res %= mod\n    memo[(L, R)] = res\n    return res\n\nL, R = map(int, input().split())\nprint(solve(L, R) % mod)", "L, R = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nl = '{:060b}'.format(L)[::-1] # 0\u5de6\u8a70\u306e\u4e8c\u9032\u6570\uff16\uff10\u6841\u306estr\u3000\u3092\u9006\u5411\u304d\u306b\u30b9\u30e9\u30a4\u30b9\nr = '{:060b}'.format(R)[::-1] # (\u6841\u657060 \u306f\u3000R<=10**18<2**60 \u3088\u308a)\n\nmemo = [[[[-1 for l in range(2)] for k in range(2)] for j in range(2)] for i in range(60)]\n\n# flagZ\u306f\u3001\u65e2\u306bx\uff1dy\uff1d1\u306e\u4f4d\u304c\u3042\u3063\u305f\u304b\u30c1\u30a7\u30c3\u30af\u3057\u3066\u3044\u308b(MSB)\ndef f(pos, flagX, flagY, flagZ):\n    if pos == -1:\n        return 1\n    if memo[pos][flagX][flagY][flagZ] != -1:\n        return memo[pos][flagX][flagY][flagZ]\n    ret = 0\n    # x 0, y 0\n    if flagX or l[pos] == '0':\n        ret += f(pos - 1, flagX, 1 if r[pos] == '1' else flagY, flagZ)\n    # x 0, y 1\n    if (flagX or l[pos] == '0') and (flagY or r[pos] == '1') and flagZ:\n        ret += f(pos - 1, flagX, flagY, flagZ)\n    # x 1, y 1\n    if flagY or r[pos] == '1':\n        ret += f(pos - 1, 1 if l[pos] == '0' else flagX, flagY, 1)\n    ret %= MOD\n    memo[pos][flagX][flagY][flagZ] = ret\n    return ret\n\nans = f(59, 0, 0, 0) #\u6700\u5927\u6841\u304b\u3089\u30b9\u30bf\u30fc\u30c8\nprint(ans)\n\n"]
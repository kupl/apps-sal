["def main():\n    n, m = list(map(int, input().split()))\n\n    cost1 = []\n    cost2 = []\n    cost3 = []\n\n    for i in range(n):\n        w, c = list(map(int, input().split()))\n        if w == 1:\n            cost1.append(c)\n        elif w == 2:\n            cost2.append(c)\n        else:\n            cost3.append(c)\n\n    cost1 = sorted(cost1)[::-1]\n    cost2 = sorted(cost2)[::-1]\n    cost3 = sorted(cost3)[::-1]\n    cost3_prefix = [0]\n    for c in cost3:\n        cost3_prefix.append(cost3_prefix[-1] + c)\n\n\n    dp = [(0, 0, 0)] * (m + 1)\n    dp[0] = (0, 0, 0)\n\n    for i in range(0, m):\n        cost, n1, n2 = dp[i]\n\n        if i + 1 <= m and n1 < len(cost1):\n            new_cost = cost + cost1[n1]\n            if dp[i + 1][0] < new_cost:\n                dp[i + 1] = (new_cost, n1 + 1, n2)\n        \n        if i + 2 <= m and n2 < len(cost2):\n            new_cost = cost + cost2[n2]\n            if dp[i + 2][0] < new_cost:\n                dp[i + 2] = (new_cost, n1, n2 + 1)\n\n        if n1 == len(cost1) and n2 == len(cost2):\n            break\n\n\n    dp_prefix = [0]\n    for x in dp[1:]:\n        dp_prefix.append(max(dp_prefix[-1], x[0]))\n\n    ans = 0\n    for k in range(len(cost3) + 1):\n        l = m - 3 * k\n        if l < 0:\n            continue\n\n        new_ans = cost3_prefix[k] + dp_prefix[l]\n        ans = max(new_ans, ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import accumulate\n\ndef solve():\n    n, m = map(int, input().split())\n    w = [[] for i in range(3)]\n\n    for i in range(n):\n        wi, ci = map(int, sys.stdin.readline().split())\n        wi -= 1\n        w[wi].append(ci)\n\n    for i in range(3):\n        w[i].sort(reverse=True)\n\n    dp = [0]*(m + 1)\n    used = [[0]*2 for i in range(m + 1)]\n\n    s0 = len(w[0])\n    s1 = len(w[1])\n\n    if s0 > 0:\n        dp[1] = w[0][0]\n        used[1] = [1, 0]\n\n    for i in range(2, m + 1):\n        if used[i - 1][0] < s0:\n            dp[i] = dp[i - 1] + w[0][used[i - 1][0]]\n            used[i] = used[i - 1][:]\n            used[i][0] += 1\n        else:\n            dp[i] = dp[i - 1]\n            used[i] = used[i - 1][:]\n\n        if used[i - 2][1] < s1 and dp[i] < dp[i - 2] + w[1][used[i - 2][1]]:\n            dp[i] = dp[i - 2] + w[1][used[i - 2][1]]\n            used[i] = used[i - 2][:]\n            used[i][1] += 1\n\n    pf = [0] + list(accumulate(w[2]))\n\n    ans = max(pf[k] + dp[m - 3*k] for k in range(min(len(pf),m // 3 + 1)))\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, m = list(map(int, input().split()))\na = [[], [], []]\nfor i in range(n):\n    w, c = list(map(int, input().split()))\n    a[w-1].append(c)\np = [[0], [0], [0]]\nfor i in range(3):\n    a[i].sort(reverse=True)\n    for x in a[i]:\n        p[i].append(p[i][-1] + x)\nans = 0\nfor i in range(min(m//3, len(a[2])) + 1):\n    w = m - i * 3\n    if len(a[1]) * 2 + len(a[0]) <= w:\n        ans = max(ans, p[2][i] + p[1][len(a[1])] + p[0][len(a[0])])\n        continue\n    if not len(a[0]):\n        ans = max(ans, p[2][i] + p[1][min(w//2, len(a[1]))])\n        continue\n    \n    if 2 + 2 == 4:\n        x = min(len(a[0]), w)\n        y = (w - x) // 2\n        ans = max(ans, p[2][i] + p[1][y] + p[0][x])\n\n    lo = max((w - len(a[0]) + 1) // 2 + 1, 1)\n    hi = min(len(a[1]), w // 2)\n    while lo <= hi:\n        mi = (lo + hi) // 2\n        if a[1][mi - 1] - (p[0][w-mi*2+2] - p[0][w-mi*2]) > 0:\n            lo = mi + 1\n        else:\n            hi = mi - 1\n    ans = max(ans, p[2][i] + p[1][hi] + p[0][w-hi*2])\nprint(ans)\n", "def souvenier_calc(max_weight, weights, value):\n    const = len(weights)\n    ans = [-1061109567 for x in range(max_weight+1)]\n    node = [(x, y) for x, y in zip(weights, value)]\n    node = sorted(node, key=lambda x: x[1]/x[0], reverse=True)\n    weights = [x[0] for x in node]\n    value = [x[1] for x in node]\n    sum = 0\n    sol = 0\n    ans[0] = 0\n    for i in range(const):\n        sum += weights[i]\n        if sum > max_weight:\n            sum = max_weight\n        down = max(weights[i], sum-3)\n        for weight in range(sum, down-1, -1):\n            ans[weight] = max(ans[weight], ans[weight-weights[i]]+value[i])\n            sol = max(sol, ans[weight])\n\n    return sol\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    assert(N <= 10**5 and M <= 3*(10**5)), 'Out of range'\n    weights = []\n    value = []\n    for i in range(N):\n        x, y = list(map(int, input().split()))\n        assert(x >= 1 and x <= 3), 'Out of range'\n        assert(y >= 1 and y <= 10**9), 'Out of range'\n        weights.append(x)\n        value.append(y)\n    print(souvenier_calc(M, weights, value))\n\n__starting_point()", "n, m = map(int, input().split())\nd = [[] for i in range(3)]\nres_odd = 0\nres_even = 0\nfor i in range(n):\n    t1, t2 = map(int, input().split())\n    d[t1 - 1].append(t2)\nd[0].sort()\nd[2].sort(reverse=True)\nc = d[1].copy()\nif d[0]:\n    i = len(d[0]) - 2\n    while i >= 1:\n        c.append(d[0][i] + d[0][i - 1])\n        i -= 2\n    c.sort(reverse=True)\n    pref = [0 for i in range(len(c) + 1)]\n    pref[0] = 0\n    for i in range(1, len(c) + 1):\n        pref[i] = pref[i - 1] + c[i - 1]\n    p = 0\n    for i in range(min(len(d[2]), (m - 1) // 3) + 1):\n        if i != 0:\n            p += d[2][i - 1]\n        res_odd = max(res_odd, d[0][-1] + p + pref[min(max(m - i * 3 - 1, 0) // 2, len(pref) - 1)])\ni = len(d[0]) - 1\nwhile i >= 1:\n    d[1].append(d[0][i] + d[0][i - 1])\n    i -= 2\nd[1].sort(reverse=True)\npref = [0 for i in range(len(d[1]) + 1)]\npref[0] = 0\nfor i in range(1, len(d[1]) + 1):\n    pref[i] = pref[i - 1] + d[1][i - 1]\np = 0\nfor i in range(min(len(d[2]), m // 3) + 1):\n    if i != 0:\n        p += d[2][i - 1]\n    res_even = max(res_even, p + pref[min(max(m - i * 3, 0) // 2, len(pref) - 1)])\nprint(max(res_odd, res_even))", "def f():\n    n, m = list(map(int, input().split()))\n    l = list(tuple(map(int, input().split())) for _ in range(n))\n    l.sort(key=lambda e: (0, 6, 3, 2)[e[0]] * e[1], reverse=True)\n    last, r = [0] * 4, 0\n    for i, (w, c) in enumerate(l):\n        if m < w:\n            break\n        m -= w\n        r += c\n        last[w] = c\n    else:\n        return r\n    if not m:\n        return r\n    res, tail = [r], (None, [], [], [])\n    for w, c in l[i:]:\n        tail[w].append(c)\n    for w in 1, 2, 3:\n        tail[w].append(0)\n    _, t1, t2, t3 = tail\n    if m == 1:\n        res.append(r + t1[0])\n        if last[1]:\n            res.append(r - last[1] + t2[0])\n        if last[2]:\n            res.append(r - last[2] + t3[0])\n        if last[3]:\n            r -= last[3]\n            res += (r + sum(t1[:4]), r + sum(t1[:2]) + t2[0], r + sum(t2[:2]))\n    else:  # m == 2\n        res += (r + sum(t1[:2]), r + t2[0])\n        if last[1]:\n            res.append(r - last[1] + t3[0])\n        if last[2]:\n            res.append(r - last[2] + t3[0] + t1[0])\n    return max(res)\n\n\ndef main():\n    print(f())\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\n[n, m] = list(map(int, input().strip().split()))\nwc = [[] for _ in range(4)]  # w[0] unused\nfor _ in range(n):\n\tw, c = list(map(int, input().strip().split()))\n\twc[w].append(c)\n\nfor i in range(1, 4):\n\twc[i].sort(reverse=True)\n\niwc = [[0 for _ in range(len(wc[i]) + 1)] for i in range(4)]\n\nfor i in range(4):\n\tfor j in range(len(wc[i])):\n\t\tiwc[i][j + 1] = iwc[i][j] + wc[i][j]\n\nn1 = len(wc[1])\nn2 = len(wc[2])\nn3 = len(wc[3])\n\nc12 = [(0, 0, 0) for _ in range(m + 1)]\nfor w in range(len(c12) - 1):\n\tc, q1, q2 = c12[w]\n\tc12[w + 1] = max(c12[w + 1], c12[w])\n\tif q1 < n1:\n\t\tc12[w + 1] = max(c12[w + 1], (iwc[1][q1 + 1] + iwc[2][q2], q1 + 1, q2))\t\t\n\tif q2 < n2 and w + 2 < len(c12):\n\t\tc12[w + 2] = max(c12[w + 2], (iwc[1][q1] + iwc[2][q2 + 1], q1, q2 + 1))\n\n\ncmax = 0\nfor i in range(n3 + 1):\n\tif 3 * i > m:\n\t\tbreak\n\tcmax = max(cmax, iwc[3][i] + c12[m - 3 * i][0])\n\nprint(cmax)\n\n", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nn, m = map(int, input().split())\nc1, c2, c3 = [0], [0], [0]\nfor _ in range(n):\n    x, y = map(int, input().split())\n    if x == 3:\n        c3.append(y)\n    elif x == 2:\n        c2.append(y)\n    else:\n        c1.append(y)\nc1.sort(reverse=True)\nc2.sort(reverse=True)\nc3.sort(reverse=True)\n\ndp = [None for i in range(m+1)]\ndp[0] = (0, 0, 0)\ndp[1] = (c1[0], 1, 0)\nfor i in range(2, m+1):\n    if dp[i-1][1] == len(c1):\n        x1 = (dp[i-1][0], dp[i-1][1], dp[i-1][2])\n    else:\n        x1 = (dp[i-1][0]+c1[dp[i-1][1]], dp[i-1][1]+1, dp[i-1][2])\n    if dp[i-2][2] == len(c2):\n        x2 = (dp[i-2][0], dp[i-2][1], dp[i-2][2])\n    else:\n        x2 = (dp[i-2][0]+c2[dp[i-2][2]], dp[i-2][1], dp[i-2][2]+1)\n    if x1[0] > x2[0]:\n        dp[i] = x1\n    else:\n        dp[i] = x2\n\nans = 0\ncost3 = 0\nfor i in range(len(c3)):\n    cost3 += c3[i-1]\n    cap = m - 3*i\n    if cap < 0: break\n    ans = max(ans, cost3+dp[cap][0])\nprint(ans)", "import sys\nn, m = list(map(int, input().split()))\nw1 = []\nw2 = []\nw3 = [10**10]\n\nfor w, c in (list(map(int, l.split())) for l in sys.stdin):\n    if w == 1:\n        w1.append(c)\n    elif w == 2:\n        w2.append(c)\n    else:\n        w3.append(c)\n\nw1.sort(reverse=True)\nw2.sort(reverse=True)\nw3.sort(reverse=True)\nw3[0] = 0\nw1_size, w2_size = len(w1), len(w2)\n\ndp = [(0, 0, 0) for _ in range(m+3)]\nfor i in range(m):\n    dp[i+1] = max(dp[i+1], dp[i])\n    if dp[i][1] < w1_size:\n        dp[i+1] = max(dp[i+1], (dp[i][0]+w1[dp[i][1]], dp[i][1]+1, dp[i][2]))\n    if dp[i][2] < w2_size:\n        dp[i+2] = max(dp[i+2], (dp[i][0]+w2[dp[i][2]], dp[i][1], dp[i][2]+1))\n\nans = 0\nw3_c = 0\n\nfor i in range(len(w3)):\n    if i*3 > m:\n        continue\n    w3_c += w3[i]\n    ans = max(ans, w3_c + dp[m-i*3][0])\n\nprint(ans)\n", "n,m = map(int,input().split())\na = [[],[],[]]\nfor _ in range(n):\n    x,y = map(int,input().split())\n    a[x-1].append(y)\n\nfor i in range(3):\n    a[i].sort(reverse=True)\n\na_one_odd = []\na_one_even = []\na_length = [len(a[i]) for i in range(3)]\nfor i in range(0,a_length[0]-1,2):\n    a_one_even.append(a[0][i]+a[0][i+1])\nfor i in range(1,a_length[0]-1,2):\n    a_one_odd.append(a[0][i]+a[0][i+1])\ndata_even = sorted(a_one_even+a[1],reverse=True)\ndata_odd = sorted(a_one_odd+a[1],reverse=True)\n\ndata_sum_even = [0]\nfor x in data_even:\n    data_sum_even.append(data_sum_even[-1]+x)\ndata_sum_odd = [0]\nfor x in data_odd:\n    data_sum_odd.append(data_sum_odd[-1]+x)\n\ndata_sum_three = [0]\nfor x in a[2]:\n    data_sum_three.append(data_sum_three[-1]+x)\n\nans = 0\n#print(data_sum_odd,data_sum_even,data_sum_three)\nfor k in range(a_length[2]+1):\n    if m-3*k < 0:break\n    now1,now2 = data_sum_three[k],data_sum_three[k]\n    if (m-3*k)%2== 0:\n        now1 += data_sum_even[min((m-3*k)//2,len(data_sum_even)-1)]\n        if a_length[0] > 0 and m-3*k > 0:\n            now2 += a[0][0]\n        if (m-3*k)//2 >= 1:\n            now2 += data_sum_odd[min((m-3*k)//2-1,len(data_sum_odd)-1)]\n    else:\n        now1 += data_sum_even[min((m-3*k)//2,len(data_sum_even)-1)]\n        if a_length[0] > 0 and m-3*k > 0:\n            now2 += a[0][0]\n        now2 += data_sum_odd[min((m-3*k-1)//2,len(data_sum_odd)-1)]\n    ans = max(ans,now1,now2)\n\n\nprint(ans)"]
["from collections import deque\n\ndef addedge(u, v, value):\n\tnonlocal e\n\ta = [v, value, None]\n\tb = [u, 0, a]\n\ta[2] = b\n\te[u].append(a)\n\te[v].append(b)\n\t\n\ninf = 2 * (10 ** 12)\nans = 0\nn, m = list(map(int, input().split()))\ne = [[] for i in range(n + m + 2)]\na = tuple(map(int, input().split()))\nS, T = 0, m + n + 1\nfor i in range(1, m + 1):\n\tu, v, w = list(map(int, input().split()))\n\tans += w\n\taddedge(i, u + m, inf)\n\taddedge(i, v + m, inf)\n\taddedge(S, i, w)\nfor i in range(m + 1, T):\n\taddedge(i, T, a[i - m - 1])\n# for i in range(n + m + 2):\n# \tfor edge in e[i]:\n# \t\tprint('%d to %d w %d' % (i, edge[0] if edge[0] <= m else edge[0] - m, edge[1]))\n\nlvl = None\ndef bfs():\n\tnonlocal e, lvl\n\tlvl = [0] * (n + m + 2)\n\tq = deque([0])\n\twhile q:\n\t\tnode = q.popleft()\n\t\t# print('node = %d' % node)\n\t\tfor edge in e[node]:\n\t\t\tif edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:\n\t\t\t\tlvl[edge[0]] = lvl[node] + 1\n\t\t\t\tq.append(edge[0])\n\t# print(lvl)\n\n\ndef dfs(node, maxdelta):\n\tnonlocal e, lvl\n\tif node == T:\n\t\treturn maxdelta\n\tdelta = 0\n\tfor edge in e[node]:\n\t\tif lvl[edge[0]] == lvl[node] + 1 and edge[1]:\n\t\t\ttmp = dfs(edge[0], min(maxdelta, edge[1]))\n\t\t\tif tmp > 0:\n\t\t\t\tedge[1] -= tmp\n\t\t\t\tedge[2][1] += tmp\n\t\t\t\tmaxdelta -= tmp\n\t\t\t\tdelta += tmp\n\t\t\tif maxdelta == 0:\n\t\t\t\tbreak\n\treturn delta\n\nflow = 0\nwhile 1:\n\tbfs()\n\ttmp = dfs(0, inf)\n\tif tmp == 0:\n\t\tbreak\n\tflow += tmp\nans -= flow\nprint(ans)\n\n\n\n\n\n"]
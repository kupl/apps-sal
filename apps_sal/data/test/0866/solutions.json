["from functools import reduce\n\nx,y=list(map(int,input().split()))\nmod = 10 ** 9 + 7\n\nif (2 * y - x) % 3 != 0 or (2 * x - y) % 3 != 0:\n  print(\"0\")\n  return\n  \na,b = (2 * y - x) // 3, (2 * x - y) // 3 \n\nr = min(a,b)\n\nif r == 0:\n  print(\"1\")\nelif r < 0:\n  print(\"0\")\nelse:\n  numerator = reduce(lambda x, y: x * y % mod, range(a + b - r + 1, a + b + 1))\n  denominator = reduce(lambda x, y: x * y % mod, range(1,r + 1))\n  print(numerator * pow(denominator, mod - 2, mod) % mod)", "mod = 10**9 + 7\n \ndef nCk(n,k,p):\n    nonlocal mod\n    k = min(k, n-k)\n    \n    X = 1\n    for i in range(k):\n        X = X * (n - i) % p\n        X = X * pow(i + 1, p - 2, p) % p\n    return X\n \nX,Y = map(int, input().split())\n \nans = 0\nif X <= 2*Y and Y <= 2*X and (X + Y) % 3 == 0:\n    a = (2*Y-X) // 3\n    b = (2*X-Y) // 3\n    ans = nCk(a + b, b, mod)\nprint(ans)", "X,Y=list(map(int,input().split()))\n\nimport sys\nif (2*Y-X)%3!=0 or (2*X-Y)%3!=0:\n  print((0))\n  return\nif (2*Y-X)<0 or (2*X-Y)<0:\n  print((0))\n  return\nx=(2*Y-X)//3\ny=(2*X-Y)//3\n#(x+y)Cx\u3092\u6c42\u3081\u308b\nfac=[0 for i in range(x+y+1)]\ninv=[0 for i in range(x+y+1)]\nfinv=[0 for i in range(x+y+1)]\n#\u521d\u671f\u6761\u4ef6\np=1000000007\nfac[0]=fac[1]=1\ninv[1]=1\nfinv[0]=finv[1]=1\n#\u30c6\u30fc\u30d6\u30eb\u306e\u4f5c\u6210\nfor i in range(2,x+y+1):\n  fac[i]=fac[i-1]*i%p\n  #p=(p//a)*a+(p%a) a^(-1)=-(p//a)*(p%a)^(-1)\n  inv[i]=(-(p//i)*inv[p%i])%p\n  finv[i]=finv[i-1]*inv[i]%p\n#\u6c42\u3081\u308b\n\nprint(((fac[x+y]*finv[x]%p)*finv[y]%p))\n\n\n", "import sys\nX,Y = map(int,input().split())\nif (X+Y)%3 != 0:\n    print(0)\n    return\nA = Y - (X+Y)//3\nB = X - (X+Y)//3\nif A<0 or B<0:\n    print(0)\n    return\nN = A+B\ndef cmb(n, r, mod):\n    inv = [0,1]\n    for i in range(2, N + 1):\n        inv.append((-inv[mod % i] * (mod // i)) % mod)\n    cmd = 1\n    for i in range(1,min(r,n-r)+1):\n        cmd = (cmd*(N-i+1)*inv[i])%mod\n    return cmd\n    \na = cmb(N,A,10**9+7)\nprint(a)", "# import itertools\n# import math\nimport sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nX, Y = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\nif (X + Y) % 3 != 0:\n    print(0)\n    return\n\ncnt = (X + Y) // 3\n\ndiff = abs(X - Y)\n\n\n\ndef comb(n, m, mod = 10 ** 9 + 7):\n    if m < 0:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(1, m + 1):\n        numerator = numerator * (n - i + 1) % mod\n        denominator = denominator * i % mod\n    d_inv = pow(denominator, mod - 2, mod)\n    return numerator * d_inv % mod\n\nprint(comb(cnt, (2 * Y - X) // 3) % (10 ** 9 + 7))", "def cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nx, y = map(int,input().split())\n\nif (x+y)%3:\n    ans = 0\nelse:\n    n = (x+y)//3\n    x -= n\n    y -= n\n    if (x<0) or (y<0):\n        ans = 0\n    else:\n        ans = cmb(x+y,y,p)\n\nprint(ans)", "import numpy as np\nx, y = list(map(int, input().split()))\n\ndef comb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return g1[n]*g2[r]*g2[n-r]%mod\n\nif (x+y)%3 != 0:\n    print((0))\nelse:\n    mod, N = 10**9+7, 10**6\n    g1, g2, inverse = [1, 1], [1, 1], [0, 1]\n    for i in range(2, N+1):\n        g1.append((g1[-1]*i)%mod)\n        inverse.append((-inverse[mod%i]*(mod//i))%mod)\n        g2.append((g2[-1]*inverse[-1])%mod)\n    a = np.array([[1, 2], [2, 1]])\n    b = np.array([x, y])\n    x0, y0 = np.linalg.solve(a, b)\n    print((comb(int(x0+y0), int(x0), mod)))\n", "import math\nx,y=map(int,input().split())\n\nmod = 10**9+7\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\n\ndef init(n):\n  for i in range(2, n + 1):\n    fac.append(fac[-1] * i % mod)\n    inv.append(-inv[mod % i] * (mod // i) % mod)\n    finv.append(finv[-1] * inv[-1] % mod)\n\n\ndef com(n, k, mod):\n    if n < 0 or k < 0 or n < k:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod\n\ndef main():\n  if (x+y)%3:\n    print(0)\n    return\n  else:\n    n=(2*y-x)//3\n    m=(2*x-y)//3\n    if n<0 or m<0:\n      print(0)\n      return\n    else:\n      init(n+m)\n      print(com(n+m,n,mod))\n      \nmain()", "MOD = 10 ** 9 + 7\n\ndef main():\n    X, Y = list(map(int, input().split()))\n    if (2 * X - Y) % 3 == 0 and (2 * Y - X) % 3 == 0:\n        a = (2 * X - Y) // 3\n        b = (2 * Y - X) // 3\n    else:\n        print((0))\n        return\n    if a < 0 or b < 0:\n        print((0))\n        return\n\n    # (a+b)! % MOD\n    ab_mod = fact_mod(a+b)\n    # (a!)^(MOD-2) % MOD\n    a_mod = pow(fact_mod(a), MOD-2, MOD)\n    # (b!)^(MOD-2) % MOD\n    b_mod = pow(fact_mod(b), MOD-2, MOD)\n    print(((ab_mod * a_mod * b_mod) % MOD))\n\n\ndef fact_mod(x):\n    v = 1\n    for i in range(1, x+1):\n        v *= i\n        v %= MOD\n    return v\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X, Y = list(map(int, input().split()))\n\nif (X+Y)%3 != 0 or X*2 < Y or Y*2 < X:\n    print((0))\n    return\n\nn = (2*X - Y) // 3\nm = (2*Y - X) // 3\n\nP = 10 ** 9 + 7\nN = 10 ** 6\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\nfor i in range(2, N+1):\n    fact.append((fact[-1]*i)%P)\n    inv.append((-inv[P%i] * (P // i)) %P)\n    factinv.append((factinv[-1] * inv[-1])%P)\nprint((fact[n+m]*factinv[n]*factinv[m]%P))\n", "X,Y = map(int, input().split())\nmod = 10**9 + 7\n\ndef nCk(n,k,p):\n    fact    = [1,1] + [0]*(n-1)\n    inv     = [0,1] + [0]*(n-1)\n    factinv = [1,1] + [0]*(n-1)\n    \n    for i in range(2, n+1):\n        fact[i] = i * fact[i-1] % p\n        inv[i] = - inv[p % i] * (p // i) % p\n        factinv[i] = factinv[i-1] * inv[i] % p\n    \n    return fact[n] * factinv[k] * factinv[n-k] % p\n\nans = 0\nif (X + Y) % 3 == 0 and X <= 2*Y and Y <= 2*X:\n    a = (2*Y - X) // 3\n    b = (2*X - Y) // 3\n    ans = nCk(a+b, a, mod)\nprint(ans)", "mod=10**9+7\n\nx,y=map(int,input().split())\nif (x+y)%3!=0:\n  print(0)\n  return\n  \nif x*2<y or y*2<x:\n  print(0)\n  return\n  \nz=(x+y)//3\n\nx-=z\ny-=z\n\nn=x+y\nr=x\n\nif x==0 or y==0:\n  print(1)\n  return\n  \n\nlst=[0]+[1]\nfor i in range(2,n+10):\n  lst.append((lst[-1]*i)%mod)\n\n\nxxx=lst[n]\nxxx*=pow(lst[n-r],10**9+5,mod)\nxxx%=mod\nxxx*=pow(lst[r],10**9+5,mod)\nxxx%=mod\n\nprint(xxx)", "x,y=list(map(int,input().split()))\na=-1\np=10**9+7\nfor i in range(x//2+1):\n  if i+2*(x-2*i)==y:\n    a=i\n    break\nif a==-1:\n  print((0))\n  return\nelif a==0:\n  print((1))\n  return\nelse:\n  gyaku=[0,1]\n  for i in range(2,a+1):\n    gyaku.append(((p//i)*-gyaku[p%i])%p)\n  com=[1]\n  for i in range(1,a+1):\n    com.append(com[-1]*gyaku[i]*(x-a+1-i)%p)\nprint((com[-1]))\n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\n# mod p\nclass Combination():\n    def __init__(self, n, p):\n        self.n = n\n        self.p = p\n        self.note = [1, 1]\n        self.noteinv = [1, 1]\n        self.inv = [0, 1]\n        self.calc()\n\n    def calc(self):\n        for i in range(2, self.n + 1):\n            self.note.append((self.note[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.noteinv.append((self.noteinv[-1] * self.inv[-1]) % self.p)\n    \n    def nCr(self, n, r):\n        n = self.n\n        if r < 0 or n < r:\n            return 0\n        r = min(r, n - r)\n        return (self.note[n] * self.noteinv[r] * self.noteinv[n - r]) % self.p\n\ndef Main():\n    x, y = read_ints()\n    if (x + y) % 3 != 0:\n        print(0)\n        return\n    # n + 2m = X, 2n + m = Y => 3m = 2X - Y, 3n = 2Y - X\n    n = (2 * x - y) // 3\n    m = (2 * y - x) // 3\n    cmb = Combination(n + m, MOD)\n    print(cmb.nCr(n + m, min(n, m)))\n\ndef __starting_point():\n    Main()\n__starting_point()", "t = sorted(list(map(int, input().split())))\nmod = 10**9 + 7\nX = t[0]\nY = t[1]\nxy = 0\n\nwhile X >= 0:\n    if Y == 2*X:\n        break\n    X -= 3\n    Y -= 3\n    xy += 1\n#print(X, Y, xy)\n\nif X < 0:\n    print(\"0\")\nelse:\n    ans = 1\n    for i in range(xy):\n        ans = (ans * (X + 2 * xy - i) * pow(i + 1, -1, mod)) % mod\n    print(ans)", "# https://atcoder.jp/contests/abc145/tasks/abc145_d\nMOD = 10**9 + 7\nx, y = list(map(int, input().split()))\n\nif (x + y) % 3 != 0:\n  print((0))\n  return\n\n# https://qiita.com/derodero24/items/91b6468e66923a87f39f#%E7%95%AA%E5%A4%96%E7%B7%A8\n\n\ndef cmb(n, r):\n  if (r < 0 or r > n):\n    return 0\n  r = min(r, n - r)\n  return g1[n] * g2[r] * g2[n - r] % MOD\n\n\nN = 10**6\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N + 1):\n  g1.append((g1[-1] * i) % MOD)\n  inverse.append((-inverse[MOD % i] * (MOD // i)) % MOD)\n  g2.append((g2[-1] * inverse[-1]) % MOD)\n\nprint((cmb((x + y) // 3, x - (x + y) // 3)))\n", "from math import factorial\nx, y = map(int, input().split())\nif (x+y) % 3 != 0:\n    print(0)\n    return\nx, y = x-(x+y)//3, y-(x+y)//3\na, b = 1, 1\nif min(x, y) < 0:\n    print(0)\n    return\nif x > y:\n    x, y = y, x\nmod = 10**9+7\nfor i in range(x):\n    a *= x+y-i\n    b *= i+1\n    a, b = a%mod, b%mod\nprint(a*pow(b, mod-2, mod)%mod)", "import math\n\nX,Y= list(map(int, input().split()))\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nif((X+Y) % 3 != 0):\n    print(0)\n    return\n\ns = (-X + 2 * Y) // 3\nt = (-Y + 2 * X) // 3\n\n\n#print(s,t)\n\nans = cmb(s+t, s, 10**9+7)\n\nprint(ans)", "def CombiMod(n, r, mod):\n    if n < r:\n        return 0\n    if n-r < r:\n        r = n-r\n    comb = 1\n    for x in range(n-r+1, n+1):\n        comb = (comb * x) % mod\n    d = 1\n    for x in range(1, r+1):\n        d = (d * x) % mod\n    comb *= pow(d, mod-2, mod)\n    return comb % mod\n\nx, y = map(int,input().split())\n\nif (x+y)%3:\n    ans = 0\nelse:\n    n = (x+y)//3\n    x -= n\n    y -= n\n    if (x<0) or (y<0):\n        ans = 0\n    else:\n        ans = CombiMod(x+y,y,10**9+7)\n\nprint(ans)", "X, Y = [int(_) for _ in input().split()]\n\np = 10 ** 9 + 7\nN = 670000\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((p - inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n    \ndef combination(n, r, p):\n    if r < 0 or n < r:\n        return 0\n    r = min(r, n-r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\ndef solve(X, Y):\n    if (X + Y) % 3 != 0:\n        return 0\n    Z = (X + Y) // 3\n    x = (Z + X - Y) // 2\n    return combination(Z, x, p)\n\nprint((solve(X, Y)))\n", "def nCr(n, r):\n    num, den = 1, 1\n    for i in range(n, n-r, -1):\n        num = num * i % M       ##;print(num)\n    for i in range(1, r+1):\n        den = den * i % M       ##;print(den)\n    den_inv = pow(den, -1, M)   #;print(num, den, den_inv) \n    return num * den_inv % M\n\ndef is_comb():\n    a = 1/3 * (2*X - Y)\n    b = 1/3 * (-X + 2*Y)\n    if a>=0 and b >= 0 and a.is_integer() and b.is_integer():\n        return int(a), int(b)\n    return 0, 0\n\nM = 10**9 + 7\nX, Y  = map(int, input().split())\n#X, Y =  103078,  214577\na, b = is_comb()   #; print(a, b)\nif a==b==0:\n    print(0)\nelse:\n    n, r  = a+b, a\n    print(nCr(n, r))", "fact = [None]*1000001\ninv = [0,1]\nfinv = [1,1]\n\nx, y = map(int, input().split())\ntotal = x+y\nans = 0\nMOD = 10**9+7\n\nif total%3 == 0 and max(x,y) <= min(x,y)*2:\n    fact[1] = 1\n    for i in range(2,1000001):\n        fact[i] = fact[i-1]*i%MOD\n        inv.append((-inv[MOD%i] * (MOD//i)) % MOD)\n        finv.append(finv[-1] * inv[-1] % MOD)\n    step = int(total/3)\n    sa = abs(x-y)\n    a = int((step-sa)/2)\n    b = int((step+sa)/2)\n    ans = fact[step] * finv[a] * finv[b] % MOD\nprint(ans)", "x,y=list(map(int,input().split()))\na=-1\np=10**9+7\nfor i in range(x//2+1):\n  if i+2*(x-2*i)==y:\n    a=i\n    break\nif a==-1:\n  print((0))\n  return\nelif a==0:\n  print((1))\nelse:\n  gyaku=[0,1]\n  for i in range(2,a+1):\n    gyaku.append(((p//i)*-gyaku[p%i])%p)\n  com=[1]\n  for i in range(1,a+1):\n    com.append(com[-1]*gyaku[i]*(x-a+1-i)%p)\n  print((com[-1]))  \n", "X,Y=map(int,input().split())\nif 2*Y<X or 2*X<Y:\n  print(0)\n  return\nif not((X%3==0 and Y%3==0) or (X%3==1 and Y%3==2) or (X%3==2 and Y%3==1)):\n  print(0)\n  return\nP=10**9+7\nA=(2*Y-X)//3\nB=(2*X-Y)//3\nnum = 1\nfor i in range(A+1, A+B+1):\n  num=num*i%P\nden = 1\nfor j in range(1, B+1):\n  den = den*j%P\nden = pow(den,P-2,P)\nprint((num*den)%P)", "MAX = 1000010\nfinv = [0] * MAX\ninv = [0] * MAX\ndef COMinit():\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        inv[i] = MOD - inv[MOD%i] * (MOD//i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n\ndef COM(n, k):\n    res = 1\n    for i in range(k):\n        res = res * (n-i) % MOD\n    return res * finv[k] % MOD\n\nMOD = 10**9+7\nx, y = map(int, input().split())\ns, t = (-x+2*y)/3, (2*x-y)/3\n\nif s < 0 or t < 0:\n    ans = 0\nelif not (s.is_integer() and t.is_integer()):\n    ans = 0\nelse:\n    s, t = int(s), int(t)\n    COMinit()\n    ans = COM((s+t), s)\n\nprint(ans)", "from functools import reduce\n\nx,y=list(map(int,input().split()))\nmod = 10 ** 9 + 7\n\nif (2 * y - x) % 3 != 0 or (2 * x - y) % 3 != 0:\n  print(\"0\")\n  return\n  \na,b = (2 * y - x) // 3, (2 * x - y) // 3 \n\nr = max(a,b)\n\nif min(a,b) < 0:\n  print(\"0\")\nelse:\n  numerator = reduce(lambda x, y: x * y % mod, range(a + b - r + 1, a + b + 1))\n  denominator = reduce(lambda x, y: x * y % mod, range(1 , r + 1))\n  print(numerator * pow(denominator, mod - 2, mod) % mod)", "X, Y = map(int,input().split())\n\ntotal = (X+Y)/3\nk = (2*X-Y)//3\n\nif (total == int(total)) and (k>=0):\n    total = (X+Y)//3\n\n    mod = 10 ** 9 + 7\n\n    modinv_table = [-1] * (k + 1)\n    for i in range(1, k + 1):\n        modinv_table[i] = pow(i, -1, mod)\n\n\n    def binomial_coefficients(n, k):\n        ans = 1\n        for i in range(k):\n            ans *= n - i\n            ans *= modinv_table[i + 1]\n            ans %= mod\n        return ans\n\n    print(binomial_coefficients(total,k))\nelse:\n    print(0)", "import math\nX, Y = map(int, input().split())\nif X > Y:\n  X, Y = Y, X\n\nif ((2*X-Y) % 3 != 0) or (2*X-Y < 0):\n  print(0)\n  return\nA = (2*X-Y)//3\nB = Y-X+A\nN = A+B\nnu = 1\nde = 1\nfor i in range(B+1, N+1):\n  nu = (nu * i) % (10 ** 9 + 7)\nfor i in range(1, A+1):\n  de = (de * i) % (10 ** 9 + 7)\n  \nprint((nu * pow(de, -1, 10 ** 9 + 7) ) % (10 ** 9 + 7))", "X, Y = map(int, input().split())\nMOD = 10 ** 9 + 7\n\ndef modpow(x, n):\n    ret = 1\n    while n > 0:\n        if n & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return ret\n\ndef modinv(x):\n    return modpow(x, MOD - 2)\n\ndef modf(x):\n    ret = 1\n    for i in range(2, x + 1):\n        ret *= i\n        ret %= MOD\n    return ret\n\nans = 0\nif (X + Y) % 3 == 0:\n    m = (2 * X - Y) // 3\n    n = (2 * Y - X) // 3\n    if m >= 0 and n >= 0:\n        ans = modf(m + n) * modinv(modf(n) * modf(m))\n        ans %= MOD\nprint(ans)", "class Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 10**6\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\ncombrep = fact_instance.homogeneous_product\n\nX, Y = [int(_) for _ in input().split()]\ni = X - (X + Y) // 3\nj = Y - (X + Y) // 3\nif (X + Y) % 3 or i < 0 or j < 0:\n    ans = 0\nelse:\n    ans = comb(i + j, i)\nprint(ans)\n", "def com(n,r,m):\n f=[1,1]\n for i in range(2,n+1):\n  f.append(f[i-1]*i%m)\n return f[n]*pow(f[r]*f[n-r]%m,m-2,m)%m\n \nmod=10**9+7\nx,y=map(int,input().split())\nz=(x+y)//3\nif (x+y)%3 or abs(x-y)>z:\n ans=0\nelse:\n    ans=com(z,x-z,mod)\nprint(ans)", "class common_function():\n    \"\"\"\n        1. \u3088\u304f\u4f7f\u3044\u305d\u3046\u3067\u4e88\u3081\u7528\u610f\u3057\u3066\u3042\u308b\u3082\u306e\u3092\u307e\u3068\u3081\u305f\n        2. \u3088\u304f\u4f7f\u3044\u305d\u3046\u306a\u95a2\u6570\u7fa4\u3092\u307e\u3068\u3081\u305f\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n            1. \u82f1\u5b57\u306e\u4e00\u89a7\u3092\u30ea\u30b9\u30c8\u306b\u683c\u7d0d\u3057\u3066\u304a\u3044\u305f\u5909\u6570\n        \"\"\"\n        self.sletter = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n        self.bletter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n\n\n    def combi(self, n:int, k:int, MOD=pow(10, 9) + 7):\n        \"\"\"\n            mod \u306e\u4e0b\u3067\u306e combination nCk \u3092\u9ad8\u901f\u306b\u6c42\u3081\u308b\u30e1\u30bd\u30c3\u30c9\n            n \u304c\u5927\u304d\u3044\u5834\u5408(10^6)\u306b\u4f7f\u7528\u3059\u308b. \n            1\u56de nCk \u3092\u6c42\u3081\u308b\u306e\u306b O(k) \u304b\u304b\u308b.\n        \"\"\"\n        k = min(k, n-k)\n        numer = 1\n        for i in range(n, n-k, -1):\n            numer *= i\n            numer %= MOD\n        denom = 1\n        for j in range(k, 0, -1):\n            denom *= j\n            denom %= MOD\n        return (numer*(pow(denom, MOD-2, MOD)))%MOD\n\n\ndef main():\n    common = common_function()\n    X, Y = list(map(int, input().split()))\n    if X <= 0 or Y <= 0 or (X + Y) % 3 != 0:\n        print((0))\n        return\n    if Y > 2*X or X > 2*Y:\n        print((0))\n        return\n    for i in range(X):\n        two = i\n        one = X-2*i\n        if two + one*2 == Y:\n            break\n    ans = common.combi(two+one, one)\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X, Y = map(int, input().split())\nif (X+Y) % 3 != 0:\n    print(0)\n    \nelse:\n    # \u7d4c\u8def\n    def C(n, r, mod):\n        num = 1\n        den = 1\n        for i in range(r):\n            num *= n-i\n            num %= mod\n            den *= i+1\n            den %= mod\n        return (num * pow(den, mod-2, mod)) % mod\n    mod = 10**9 + 7\n    minimun = (X+Y)/3\n    if X >= minimun and Y >= minimun:\n        X -= minimun \n        Y -= minimun\n        print(C(int(X+Y), int(X), mod))\n    else:\n        print(0)", "X,Y = map(int,input().split())\nmod = 10**9+7\nN = (X+Y)//3\nM = (N+X-Y)//2\n\nif (X+Y)%3!=0 or M<0 or N<M:\n  print(0)\nelse:\n  ans = 1\n  for m in range(1,M+1):\n    ans*=(N-M+m)*pow(m,mod-2,mod)\n    ans%=mod\n  print(ans)", "x, y = list(map(int, input().split()))\n\ndef ncr(n, r, p):\n    num = 1\n    den = 1\n\n    for i in range(r):\n        num = (num*(n-i)) % p\n        den = (den*(i+1)) % p\n\n    return (num*pow(den, p-2, p)) % p\n\nif (x+y)%3 == 0:\n    n = (x+y)//3\n\n    if not (n <= x <= 2*n):\n        print(0)\n    else:\n        print(ncr(n, x-n, 1000000007))\nelse:\n    print(0)", "def cmb(n,r):\n    if (n-r)<r: r=n-r\n    if r==0: return 1\n    if r==1: return n\n\n    numerator = [n-r + k+1 for k in range(r)]\n    denominator = [k+1 for k in range(r)]\n\n    for p in range(2,r+1):\n        pivot = denominator[p-1]\n        if pivot>1:\n            offset = (n-r)%p\n            for k in range(p-1,r,p):\n                numerator[k - offset] /= pivot\n                denominator[k] /= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\n\nx,y = map(int,input().split())\n\nMOD = 10**9+7\nn = (x+y)//3\na = x-n\nb = y-n\n\nif (x+y)%3 != 0 or a < 0 or b < 0:\n    print(0)\nelse:\n    a = x-n\n    b = y-n\n    print(cmb(a+b,b)%MOD)", "\nx,y=map(int,input().split())\nmod=10**9+7\n\na=(2*y-x)/3\nb=(2*x-y)/3\nif a<0 or b<0 or (2*y-x)//3!=a or (2*x-y)//3!=b:\n    print(0) \nelse:\n    a=(2*y-x)//3\n    b=(2*x-y)//3\n    fac=[0]*(a+b+1)\n    finv=[0]*(a+b+1)\n    inv=[0]*(a+b+1)\n    fac[0]=fac[1]=1\n    finv[0]=finv[1]=1\n    inv[1]=1\n    for i in range(2,a+b+1):\n        fac[i]=fac[i-1]*i%mod\n        inv[i]=mod-inv[mod%i]*(mod//i)%mod\n        finv[i]=finv[i-1]*inv[i]%mod\n    \n    print(fac[a+b]*(finv[a]*finv[b]%mod)%mod)", "x, y = map(int, input().split())\ndiff = abs(x - y)\nref = (min(x, y) - diff)//3\ntotal = ref*2 + diff\nmod = 10**9 + 7\nans = 1\n\nif (x + y)%3 != 0 or ref < 0:\n    print(0)\n    return\n\n\nfor i in range(min(ref, total - ref)):\n    ans = ans*(total - i)%mod\n    ie = pow((i + 1), (mod - 2), mod)\n    ans = ans*ie%mod\n\nprint(ans)", "def calccombi(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\nx, y = map(int,input().split())\nif (x+y)%3!=0 or 2*y<x or 2*x<y:\n    print(0)\nelse:\n    MOD = 1_000_000_007\n    n = (2*y-x)//3\n    m = (2*x-y)//3\n    fac = [0]*(n+m+1)\n    finv = [0]*(n+m+1)\n    inv = [0]*(n+m+1)\n    fac[0] = 1\n    fac[1] = 1\n    finv[0] = 1\n    finv[1] = 1\n    inv[1] = 1\n    for i in range(2,n+m+1):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n    print(calccombi(n+m,n))", "x, y = map(int, input().split())\ndiff = abs(x - y)\nref = (min(x, y) - diff)//3\ntotal = ref*2 + diff\nmod = 10**9 + 7\nans = 1\nie = 1\n\nif (x + y)%3 != 0 or ref < 0:\n    print(0)\n    return\n\n\nfor i in range(min(ref, total - ref)):\n    ans = ans*(total - i)%mod\n    ie = ie*(i + 1)%mod\n\nie = pow(ie, mod - 2, mod)\nans = ans*ie%mod\nprint(ans)", "mod = 10**9 + 7\nX, Y = list(map(int, input().split()))\n\nif (X+Y) % 3 != 0:\n    print((0))\n    return\n\na = (2*Y-X)//3\nb = (2*X-Y)//3\nif a < 0 or b < 0:\n    print((0))\n    return\n\nm = min(a, b)\n\nifact = 1\nfor i in range(2, m+1):\n    ifact = (ifact * i) % mod\nifact = pow(ifact, mod-2, mod)\nfact = 1\nfor i in range(a+b, a+b-m, -1):\n    fact = (fact * i) % mod\n\nprint((fact*ifact % mod))\n", "x,y = list(map(int, input().split()))\n\nif (x+y) % 3 != 0:\n    print(0)\n    return\n\na = (2*x - y) // 3\nb = (2*y - x) // 3\n\nif a < 0 or b < 0:\n    # (x,y) = (1,5)\u3068\u304b\u306f\u7121\u7406\n    print(0)\n    return\n    \nMOD = 10**9+7\ndef fact(x):\n    f = 1\n    for i in range(2, x+1):\n        f *= i\n        f %= MOD\n    return f\n\ndef fact_inv(x):\n    return pow(fact(x), MOD-2, MOD)\n\nans = fact(a+b) * fact_inv(a) * fact_inv(b) % MOD\n\nprint(ans)", "X,Y = map(int,input().split())\nM = 10**9+7\nif X%3 == Y%3 == 1 or X%3 == Y%3 == 2:\n    Answer = 0\nelse:\n    dif = abs(X-Y)\n    W =  (min(X,Y) - dif)//3\n    X1 = W + dif\n    Y1 = W\n    Answer = 1\n    N = X1+Y1\n    for i in range(1,X1+1):\n        Answer = (Answer*(N)*pow(i,-1,M))%M\n        N -= 1\n    for j in range(1,Y1+1):\n        Answer = (Answer*(N)*pow(j,-1,M))%M\n        N -= 1\nprint(Answer)", "import sys\nX, Y = map(int,input().split())\nif (X + Y) % 3 != 0:\n    print(0)\n    return\nturn = (X + Y) // 3\nX -= turn\nY -= turn\n\nif X < 0 or Y < 0:\n    print(0)\n    return\n\ndef nCr(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nsize = 10**6 # size >= n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, size + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nprint(nCr(X + Y, X, mod))", "x,y=sorted(map(int,input().split()));z=x+y\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nprint((z%3<1)*cmb(z//3,(2*x-y)//3,10**9+7))", "def main():\n    X, Y = list(map(int, input().split()))\n    if (2 * X - Y) % 3 == 0 and (2 * Y - X) % 3 == 0:\n        a = (2 * X - Y) // 3\n        b = (2 * Y - X) // 3\n    else:\n        print((0))\n        return\n    if a < 0 or b < 0:\n        print((0))\n        return\n\n    print((comb_mod(a+b, a, 10 ** 9 + 7)))\n\n\ndef comb_mod(n, k, p):\n    def fact_mod(x, p):\n        v = 1\n        for i in range(1, x+1):\n            v *= i\n            v %= p\n        return v\n\n    # n! mod p\n    n_mod = fact_mod(n, p)\n    # k!^(p-2) mod p\n    k_mod = pow(fact_mod(k, p), p-2, p)\n    # (n-k)!^(p-2) mod p\n    n_minus_k_mod = pow(fact_mod(n-k, p), p-2, p)\n\n    return (n_mod * k_mod * n_minus_k_mod) % p\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x, y = map(int, input().split())\nmod = 10**9+7\n\nif (2*y-x < 0) or (2*x-y < 0):\n    print(0)\n    return\n\nif (2*y-x)%3 != 0 or (2*x-y)%3 != 0:\n    print(0)\n    return\n\nxc = (2*y-x)//3\nyc = (2*x-y)//3\np = 1\nk = 1\nfor i in range(1, xc+1):\n    p *= (yc+i)\n    k *= i\n    p %= mod\n    k %= mod\n\nans = p*pow(k, mod-2, mod)%mod\nprint(ans)", "x,y=map(int,input().split())\nmod = 10**9+7\nflflag=True\n\nif (2*x-y)%3==0:\n  a=(2*x-y)//3\nelse:\n  flflag=False\nif (2*y-x)%3==0:\n  b=(2*y-x)//3\nelse:\n  flflag=False\n\ndef kaijou(n):\n  ans = 1\n  for i in range(1,n+1):\n    ans*=i%mod\n    ans%=mod  \n  return ans\nif flflag:\n  N=a+b\n  R=min(a,b)\nans=0\nif flflag==True and a>=0 and b>=0:\n  ans=kaijou(N)\n  ans1= (kaijou(N-R)*kaijou(R))%mod\n  print((ans*pow(ans1,mod-2,mod))%mod)\nelse:\n  print(0)", "x, y = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**6\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\ndef knight(x, y):\n    s = (0, 0)\n    if x == y == 0:\n        return 0\n    if (x + y) % 3:\n        return 0\n    if (2*y-x)%3 or (2*x-y)%3:\n        return 0\n    \n    a, b = (2*y-x)//3, (2*x-y)//3\n    n = (x+y)//3\n    r = min(a, b)\n\n    if a<0 or b<0:\n        return 0\n    \n    return cmb(n, r, mod)\n\nprint(knight(x,y))", "#(i,j)\u2192\uff08i+1,j+2\uff09\u3092x\u56de\u3001(i,j)\u2192\uff08i+2,j+1\uff09\u304cy\u56de\u3042\u308b\u3068\u3059\u308b\u3068\n#x=(2Y-X)//3,y=(2X-Y)//3\u3001\u3068\u306a\u308b\n#\u3053\u308c\u304c\u6574\u6570or\u975e\u8ca0\u306a\u3089(x+y)Cx\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\n\nX,Y=list(map(int,input().split()))\nimport sys\nif (2*Y-X)%3!=0 or (2*X-Y)%3!=0:\n  print((0))\n  return\nif (2*Y-X)<0 or (2*X-Y)<0:\n  print((0))\n  return\n\n  \n#\u305d\u308c\u4ee5\u5916\u306a\u3089\u5b58\u5728\u3059\u308b\nx=(2*Y-X)//3\ny=(2*X-Y)//3\n#(x+y)Cx\u3092\u6c42\u3081\u308b\n\nfac=[0 for i in range(x+y+1)]\ninv=[0 for i in range(x+y+1)]\nfinv=[0 for i in range(x+y+1)]\n#\u521d\u671f\u6761\u4ef6\nfac[0]=fac[1]=1\ninv[1]=1\nfinv[0]=finv[1]=1\np=1000000007\nfor i in range(2,x+y+1):\n  fac[i]=(fac[i-1]*i)%p\n  #p=(p//a)*a+(p%a) p\u306e\u4e16\u754c\u3067\u3000a^(-1)=-(p//a)*inv[p%a]\n  inv[i]=(-(p//i)*inv[p%i])%p\n  finv[i]=(finv[i-1]*inv[i])%p\n\nprint(((fac[x+y]*finv[x]%p)*finv[y]%p))\n\n", "# import itertools\n# import math\nimport sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nX, Y = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\nif (X + Y) % 3 != 0:\n    print(0)\n    return\nif (2 * Y - X) < 0 or (2 * X - Y) < 0:\n    print(0)\n    return\n\ncnt = (X + Y) // 3\n\ndiff = abs(X - Y)\n\n\n\ndef comb(n, m, mod = 10 ** 9 + 7):\n    numerator = 1\n    denominator = 1\n    for i in range(1, m + 1):\n        numerator = numerator * (n - i + 1) % mod\n        denominator = denominator * i % mod\n    d_inv = pow(denominator, mod - 2, mod)\n    return numerator * d_inv % mod\n\nprint(comb(cnt, (2 * Y - X) // 3) % (10 ** 9 + 7))", "X, Y =list(map(int, input().split()))\nmod = 1000000007\n\nimport sys\nif (X + Y) % 3 != 0:\n    print((0))\n    return\noffset = (X+Y)//3\nX, Y = X-offset, Y-offset\n\nif X<0 or Y<0:\n    print((0))\n    return\n    \nX, Y = max(X, Y), min(X, Y)\n\ndef C(n, r, mod):\n    num = 1\n    den = 1\n    for i in range(r):\n        num*=n-i\n        num%=mod\n        den*=i+1\n        den%=mod\n    return (num*pow(den, mod-2, mod))%mod\n\nprint((C(X+Y, Y, mod)))\n", "x,y=list(map(int,input().split()))\n\ndef nCr(n,r,mod=10**9+7):\n    r=min(r,n-r)\n    a=b=1\n    for i in range(1,r+1):\n        a=a*n%mod\n        b=b*i%mod\n        n-=1\n    return a*pow(b,mod-2,mod)%mod\n\nz=x+y\nif z%3!=0 or x-(z//3)<0 or y-(z//3)<0:\n    print((0))\nelse:\n    z//=3\n    # print(z)\n    # print(min(x,y)-z)\n    print((nCr(z,min(x,y)-z)))\n\n", "import sys\nx, y = map(int,input().split())\n\nif (x + y)%3:\n  print(0)\n  return\n\nn = y - (x+y)//3\nm = x - (x+y)//3\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = m+n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nprint(cmb(m+n,n,mod))", "def ext_gcd(a, b):\n    def _ext_gcd(a, b):\n        xs = [1, 0]\n        ys = [0, 1]\n        sign = 1\n        while b != 0:\n            q, r = a//b, a%b\n            a, b = b, r\n            xtmp, ytmp = xs[1], ys[1]\n            xs[1], ys[1] = q*xs[1]+xs[0], q*ys[1]+ys[0]\n            xs[0], ys[0] = xtmp, ytmp\n            sign = -sign\n        return (a, (sign*xs[0], -sign*ys[0]))\n    if a < b:\n        d, (y, x) = _ext_gcd(b, a)\n        return (d, (x, y))\n    return _ext_gcd(a, b) \n\ndef __starting_point():\n    X, Y = map(int,input().split())\n    if (2*Y-X) % 3 != 0 or (2*X-Y) % 3 != 0:\n        print(0)\n        return\n    a, b = (2*Y-X)//3, (2*X-Y)//3\n    if a < 0 or b < 0:\n        print(0)\n        return\n    n = 1\n    k = 1\n    l = 1\n    mod = 10**9+7\n    for i in range(2, a+b+1):\n        n = (n*i) % mod\n        if i <= a:\n            k = (k*i) % mod\n        if i <= b:\n            l = (l*i) % mod\n    _, (k, _) = ext_gcd(k, mod)\n    _, (l, _) = ext_gcd(l, mod)\n    print(n*k*l % mod)\n__starting_point()", "X, Y = list(map(int, input().split()))\nmod = 10**9 + 7\n\n\ndef permute(n, m):\n    ret = 1\n    while n >= m:\n        ret *= n\n        # ret %= mod\n        n -= 1\n\n    return ret\n\n\ndef count_combinations(n, m):\n    fact = [1] * (n + 1)\n    inv = [i for i in range(n+1)]\n    fact_inv = [1] * (n + 1)\n\n    for i in range(2, n+1):\n        fact[i] = fact[i-1] * i % mod\n        inv[i] = (-inv[mod%i]*(mod//i))%mod\n        # inv[i] = mod - inv[mod % i] * (mod // i) % mod\n        fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n    ret = (fact[n] * fact_inv[m] * fact_inv[n-m]) % mod\n\n    return ret\n\n\ndef count_comb2(n, m):\n    fact = [1, 1]  # fact[n] = (n! mod p)\n    factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\n    inv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\n    for i in range(2, n + 1):\n        fact.append((fact[-1] * i) % mod)\n        inv.append((-inv[mod % i] * (mod // i)) % mod)\n        factinv.append((factinv[-1] * inv[-1]) % mod)\n\n    if (m < 0) or (n < m):\n        return 0\n    m = min(m, n - m)\n    return fact[n] * factinv[m] * factinv[n-m] % mod\n\nret = 0\nif (X+Y)%3 == 0:\n    m = (2*X - Y) // 3\n    n = (2*Y - X) // 3\n\n    if m >= 0 and n >= 0:\n        ret = count_combinations(n+m, m)\n        # ret = count_comb2(n+m, m)\n\nprint(ret)\n", "X,Y=sorted(list(map(int,input().split())))\n#\u79fb\u52d5\u65b9\u6cd5\u3092(i+1,j),(i,j+1)\u3068\u306a\u308b\u3088\u3046\u306b\u3069\u3046\u306b\u304b\u3059\u308b\nif (X-abs(Y-X))%3!=0 or X*2<Y:\n  print((0))\n  return\nn=(X-abs(Y-X))//3\nX=n+abs(Y-X)\nY=n\n\n  \nmod=10**9+7\na=1\nfor i in range(1,X+Y+1):\n  a*=i\n  a%=mod\nb=1\nfor i in range(1,X+1):\n  b*=i\n  b%=mod\nc=1\nfor i in range(1,Y+1):\n  c*=i\n  c%=mod\n\nprint((a*pow(b,-1,mod)*pow(c,-1,mod)%mod))\n", "x,y=list(map(int,input().split()))\n\nif (x+y)%3!=0 or x*2<y or y*2<x :\n    print((0))\n    return\n\na=(2*x-y)//3\nb=(2*y-x)//3\n\n# ans = math.factorial(a+b)/math.factorial(a)\n# ans=1\n# for i in range(a+1,a+b+1):\n#     ans*=i%(10**9+7)\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nans = cmb(a+b,a,p)\n\nprint(ans)\n", "mod=10**9+7\nN,K=list(map(int,input().split()))\nif (N+K)%3==0 and N*2>=K and K*2>=N:\n   A=max(N,K)-min(N,K)\n   low=(min(N,K)-A)//3\n   all_pt=low*2+A\nelse:\n   print(0)\n   return\nup,down=1,1\nfor i in range(low):\n   up=up*(all_pt-i)%mod\n   down=down*(i+1)%mod\nbase=pow(down,mod-2,mod)\nprint(up*base%mod)", "#!/usr/bin/env python3\ndef combination(N: int, R: int, MOD: int):\n    \"\"\"\n    Return the number of combinations of N things taken R at a time\n    Parameters\n    ----------\n    N : int\n        Number of thing\n    R : int\n        Number of elements taken\n    MOD : int\n        MOD\n    \"\"\"\n    if N - R < R:\n        R = N - R\n    if R == 0:\n        return 1\n    if R == 1:\n        return N\n    numerator = [N - R + r for r in range(1, R + 1)]  # \u5206\u5b50\u3092\u6607\u9806\u3067\u5217\u6319\n    denominator = [r for r in range(1, R + 1)]  # \u5206\u6bcd\u3092\u6607\u9806\u3067\u5217\u6319\n    # \u5206\u6bcd\u5206\u5b50\u3092\u7d04\u5206\n    for p in range(2, R + 1):\n        pivot = denominator[p - 1]\n        if pivot <= 1:\n            continue\n        offset = (N - R) % p\n        for r in range(p - 1, R, p):\n            numerator[r - offset] /= pivot\n            denominator[r] /= pivot\n    result = 1\n    for n in numerator:\n        if n <= 1:\n            continue\n        result *= int(n)\n        result %= MOD\n    return result\n\n\ndef main():\n    X, Y = list(map(int, input().split()))\n    MOD = 10 ** 9 + 7\n\n    n = (2 * Y - X) // 3\n    m = (2 * X - Y) // 3\n    if n < 0 or m < 0 or (X + Y) % 3:\n        print((0))\n    else:\n        print((combination(n + m, n, MOD)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x,y=map(int, input().split())\nimport math\nans=0\n\ndef conbi(n,r,mod):\n    ue=1\n    for i in range(n-r+1,n+1):\n        ue*=i\n        ue%=mod\n \n    sita=1\n \n    for i in range(1,r+1):\n        sita*=i\n        sita%=mod\n \n    sita=pow(sita,mod-2,mod)\n \n    return (ue*sita)%mod\n\nfor a in range(x+1):\n    b=(x-a)/2\n    if b-int(b)==0:\n        b=int(b)\n        if y==2*a+b:\n            ans+=conbi(a+b,a,10**9+7)\n\nprint(ans)", "mod = 10**9 + 7\n\ndef nCk(n,k,p):\n    nonlocal mod\n    k = min(k, n-k)\n    \n    X = 1\n    for i in range(k):\n        X = X * (n - i) % p\n        X = X * pow(i + 1, p - 2, p) % p\n    return X\n\nX,Y = map(int, input().split())\n\nans = 0\nif X <= 2*Y and Y <= 2*X and (X + Y) % 3 == 0:\n    a = (2*Y-X) // 3\n    b = (2*X-Y) // 3\n    ans = nCk(a + b, b, mod)\nprint(ans)", "def COMinit():\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2,max):\n        fac[i] = fac[i-1]*i%mod\n        inv[i] = mod - inv[mod%i]*(mod//i)%mod\n        finv[i] = finv[i-1]*inv[i]%mod\n\ndef COM(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k]*finv[n-k]%mod)%mod\n\nmod = 10**9+7\n\nX, Y = list(map(int,input().split()))\n\na = X%2 #1\u306e\u6570\nb = X//2 #2\u306e\u6570\nfor i in range(b+1):\n    if a*2 + b*1 == Y:\n        break\n    a += 2\n    b -= 1\n\nif a*2 + b*1 != Y:\n    print((0))\nelse:\n    max = a+b+1\n    fac = [0] * max\n    finv = [0] * max\n    inv = [0] * max\n    COMinit()\n    print((COM(a+b,a)))\n", "x,y = list(map(int,input().split()))\n#x\u3092\u30d9\u30fc\u30b9\u306b\nr = 0 #\u21922 \u21911\nu = x #\u21921 \u21912\n\nwhile y != r + u*2:\n    u -= 2\n    r += 1\n    if u < 0: #\u5230\u9054\u3059\u308b\u65b9\u6cd5\u304c\u306a\u3044\n        print((0))\n        return\n\n#mod\u3042\u308a\u306e\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u8a08\u7b97\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9 + 7\nN = u+r+1 #\u5fc5\u8981\u306a\u6570\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nprint((cmb(u+r,r,mod)))\n", "import sys\nr=sys.stdin.readline\nX,Y=list(map(int,r().split()))\n#a=X-2b, b=Y-2a\nif 2*X-Y<0 or (2*X-Y)%3!=0 or 2*Y-X<0 or (2*Y-X)%3!=0:\n    print((0))\n    return   \na=(2*Y-X)//3\nb=(2*X-Y)//3\nMOD=10**9+7\n#ex) ab, ba --> a+bCa\ndef pow(a,b):\n    ans=1\n    while b:\n        if b&1:\n            ans=(ans*a)%MOD\n        a=(a**2)%MOD\n        b=b//2\n    return ans \nN=a+b\nK=a\nfac=[1 for _ in range(N+1)]\nfor i in range(2,N+1):\n    fac[i]=(fac[i-1]*i)%MOD\nA=fac[N]\nB=(fac[N-K]*fac[K])%MOD\nprint(((A%MOD)*pow(B,MOD-2)%MOD))\n\n", "# https://atcoder.jp/contests/abc145/tasks/abc145_d\nMOD = 10**9 + 7\nx, y = list(map(int, input().split()))\n\nif (x + y) % 3 != 0:\n  print((0))\n  return\n\n# https://qiita.com/derodero24/items/91b6468e66923a87f39f#%E7%95%AA%E5%A4%96%E7%B7%A8\n\n\ndef cmb(n, r):\n  if (r < 0 or r > n):\n    return 0\n  r = min(r, n - r)\n  return g1[n] * g2[r] * g2[n - r] % MOD\n\n\nN = (x + y) // 3\ng1 = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N + 1):\n  g1.append((g1[-1] * i) % MOD)\n  inverse.append((-inverse[MOD % i] * (MOD // i)) % MOD)\n  g2.append((g2[-1] * inverse[-1]) % MOD)\n\nprint((cmb(N, x - N)))\n", "# 73\n\nMOD = 10**9 + 7\nx, y = list(map(int, input().split()))\n\na = 2*y - x\nb = 2*x - y\n\nfac_l = [0] * (int((a + b) / 3) + 1)\ninv_l = [0] * (int((a + b) / 3) + 1)\nfinv_l = [0] * (int((a + b) / 3) + 1)\n\n\ndef com_init():\n    fac_l[1] = 1\n    inv_l[0] = 1\n    inv_l[1] = 1\n    finv_l[0] = 1\n    finv_l[1] = 1\n    for i in range(2, a+b+1):\n        fac_l[i] = (fac_l[i-1] * i) % MOD\n        inv_l[i] = MOD - (inv_l[MOD % i] * int(MOD / i)) % MOD\n        finv_l[i] = (finv_l[i-1] * inv_l[i]) % MOD\n\ndef ncr(n, r):\n    return (fac_l[n] * (finv_l[r] * finv_l[n-r]) % MOD) % MOD\n\n\nif a % 3 != 0 or b % 3 != 0 or a < 0 or b < 0:\n    print(\"0\")\nelse:\n    a = int(a/3)\n    b = int(b/3)\n\n    com_init()\n    print((ncr(a+b, a)))\n", "#!/usr/bin/env python3\ndef combination(N: int, R: int, MOD: int):\n    \"\"\"\n    Return the number of combinations of N things taken R at a time\n    Parameters\n    ----------\n    N : int\n        Number of thing\n    R : int\n        Number of elements taken\n    MOD : int\n        MOD\n    \"\"\"\n    if N - R < R:\n        R = N - R\n    if R == 0:\n        return 1\n    if R == 1:\n        return N\n    numerator = [N - R + r for r in range(1, R + 1)]  # \u5206\u5b50\u3092\u6607\u9806\u3067\u5217\u6319\n    denominator = [r for r in range(1, R + 1)]  # \u5206\u6bcd\u3092\u6607\u9806\u3067\u5217\u6319\n    # \u5206\u6bcd\u5206\u5b50\u3092\u7d04\u5206\n    for p in range(2, R + 1):\n        pivot = denominator[p - 1]\n        if pivot <= 1:\n            continue\n        offset = (N - R) % p\n        for r in range(p - 1, R, p):\n            numerator[r - offset] /= pivot\n            denominator[r] /= pivot\n    result = 1\n    for n in numerator:\n        if n <= 1:\n            continue\n        result *= int(n)\n        result %= MOD\n    return result\n\n\ndef main():\n    X, Y = list(map(int, input().split()))\n    MOD = 10 ** 9 + 7\n\n    if (X + Y) % 3:\n        print((0))\n        return\n    n = (2 * Y - X) // 3\n    m = (2 * X - Y) // 3\n    if n < 0 or m < 0:\n        print((0))\n        return\n    print((combination(n + m, n, MOD)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "M = 10**9 + 7\n\ndef combination(n, k):\n  if k > n-k:\n    k = n-k\n  p = [-1 for i in range(k+1)]\n  kp = {i:[] for i in range(n-k+1, n+1)}\n  for i in range(2, k+1):\n    if p[i] != -1:\n      continue\n    for j in range(i, k+1, i):\n      if p[j] == -1:\n        p[j] = i\n    for j in range(((n-k)//i + 1)*i, n+1, i):\n      kp[j].append(i)\n  count = [0 for i in range(k+1)]\n  for x in range(2, k+1):\n    buf = x\n    while p[buf]!=-1:\n      m = p[buf]\n      while buf > 1 and buf % m == 0:\n        count[m] += 1\n        buf = buf//m\n  ans = 1\n  for x in range(n-k+1, n+1):\n    buf = x\n    for i in kp[x]:\n      while count[i]>0 and buf%i==0:\n        buf = buf//i\n        count[i] -= 1\n    ans *= buf\n    ans %= M\n  return ans\n\nX, Y = list(map(int, input().split()))\na = X + Y\nb = a//3\na = a%3\n#print(a,b)\nif a==0 and b <= X <= b*2:\n  print((combination(b, X-b)))\nelse:\n  print((0))\n  \n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[8]:\n\n\ndef nCk(n, k, mod):\n    a = 1\n    for i in range(n, n-k, -1):\n        a *= i\n        a %= mod\n    b = 1\n    for i in range(1, k+1):\n        b *= i\n        b %= mod\n    a *= pow(b, mod-2, mod)\n    return a\n\n\n# In[12]:\n\n\nx,y = list(map(int,input().split()))\n\n\n# In[14]:\n\n\nmod = 10**9+7\nif (x+y)%3 != 0:\n    ans = 0\nelse:\n    right = x - (x+y)//3\n    up = y - (x+y)//3\n    if right < 0 or up < 0:\n        ans = 0\n    else:\n        ans = nCk(right+up,right,mod)%mod\nprint(ans)\n\n\n# In[ ]:\n\n\n\n\n", "def inv(a,p):\n    if a==1:\n        return 1\n    elif a==0:\n        return 0\n    return p-(inv(p%a,p)*(p//a))%p\nx,y=map(int,input().split())\nif (x+y)%3!=0:\n    print(\"0\")\n    return\nif x==0 and y>0:\n    print(\"0\")\n    return\nif y/x>2 or y/x<0.5:\n    print(\"0\")\n    return\nn=(x+y)//3\nr=(2*x-y)//3\np=10**9+7\ndef fact(n,p):\n    a=[[] for _ in range(n+1)]\n    a[0]=1\n    for i in range(n):\n        a[i+1]=(a[i]*(i+1))%p\n    return a\nf=fact(n,p)\nc=f[-1]\nd=f[r]\ne=f[n-r]\ndd=inv(d,p)\nee=inv(e,p)\nans=(c*dd*ee)%p\nprint(ans)", "X, Y = map(int, input().split())\nn = (2 * X - Y) // 3\nm = (-X + 2 * Y) // 3\nif n < 0 or m < 0 or (2 * X - Y) % 3 != 0 or (-X + 2 * Y) % 3 != 0:\n    print(0)\nelse:\n    # (n+m)Cn \u901a\u308a\n    fac = [1, 1]\n    finv = [1, 1]\n    inv = [1, 1]\n    MOD = 10 ** 9 + 7\n    for i in range(2, n + m + 1):\n        fac.append(fac[i - 1] * i % MOD)\n        inv.append(MOD - inv[MOD % i] * (MOD // i) % MOD)\n        finv.append(finv[i - 1] * inv[i] % MOD)\n    \n    print(fac[n+m] * (finv[n] * finv[m] % MOD) % MOD)", "x,y=map(int,input().split())\nmod=10**9+7\nif x//2+2*(x%2)<=y<=2*x and (2*x-y)%3==0:\n  t=(2*x-y)//3\n  maxt=max(t,x-t)\n  a=1\n  b=1\n  ans=1\n  for i in range(1,maxt+1):\n    a=a*(maxt-i+1)%mod\n    b=b*i%mod\n    if i==t or i==x-t:\n      ans*=a*pow(b,mod-2,mod)%mod\n  print(ans)\nelse:\n  print(0)", "kMod = 1000000007\n\nX, Y = map(int, input().split())\n\nif (X+Y) % 3 != 0:\n    print(0)\n    return\n\noffset = (X+Y)//3\nX, Y = X-offset, Y-offset\nif X < 0 or Y < 0:\n    print(0)\n    return\n\nX, Y = max(X, Y), min(X, Y)\n\nans = 1\nfor i in range(X+1, X+Y+1):\n    ans *= i\n    ans %= kMod\n\nfor i in range(2, Y+1):\n    ans *= pow(i, kMod-2, kMod)\n    ans %= kMod\n\nprint(ans)", "def cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nX, Y = list(map(int, input().split()))\n\nif (2*Y-X)%3 == 0:\n    if (2*X-Y)%3 == 0:\n        a = (2*Y-X)//3\n        b = (2*X-Y)//3\n    else:\n        print((0))\n        return\nelse:\n    print((0))\n    return\n\nprint((cmb(a+b, a, p)))\n", "X, Y = map(int, input().split())\n\ndef cmb(n, r, p):\n    fact = [1, 1]\n    factinv = [1, 1]\n    inv = [0, 1] \n\n    for i in range(2, n+1):\n        fact.append((fact[-1] * i) % p)\n        inv.append((-inv[p % i] * (p // i)) % p)\n        factinv.append((factinv[-1] * inv[-1]) % p)\n\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\ns = X+Y\n\nif s%3 != 0:\n    print(0)\nelse:\n    a = (s//3-(X-Y))//2\n    print(cmb(s//3, a, 10**9+7))", "MOD = 1000000007\n\n\ndef mod_inv(mod, a):\n    old_t, t = 0, 1\n    old_r, r = mod, a\n\n    while r != 0:\n        quotient = old_r // r\n\n        old_r, r = r, old_r - quotient * r\n        old_t, t = t, old_t - quotient * t\n\n    return old_t % mod\n\n\ndef combine(n, k, mod):\n    if k > n // 2:\n        k = n - k\n    u = 1\n    for i in range(n - k + 1, n + 1):\n        u = u * i % mod\n\n    v = 1\n    for i in range(1, k + 1):\n        v = v * i % mod\n\n    return u * mod_inv(mod, v) % MOD\n\n\ndef main():\n    X, Y = list(map(int, input().split()))\n    m1 = X + Y\n    if m1 % 3 == 0:\n        m = m1 // 3\n        if X < m or Y < m:\n            print((0))\n        else:\n            print((combine(m, X - m, MOD)))\n    else:\n        print((0))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod=int(1e9)+7\nf=[1]\nfor i in range(1,int(1e6)):f.append(i*f[i-1]%mod)\ndef comb(a,b):\n    return f[a]%mod*pow(f[b],mod-2,mod)%mod*pow(f[a-b],mod-2,mod)%mod\nx,y=map(int,input().split())\nif (2*y-x)%3 or (2*x-y)%3:\n    print(0)\n    return\nelse:\n    a,b=(2*y-x)//3,(2*x-y)//3\n    if not(a>=0 and b>=0):\n        print(0)\n        return\n    print(comb(a+b,b))", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nimport heapq\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1] # warning bytes\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8').strip()\nimport string\nimport operator\nimport random\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\ndef print_lines(data):\n    sys.stdout.write('\\n'.join((str(x) for x in data)))\n\n\ndef solve():\n    X, Y = [int(x) for x in input().split()]\n\n    def prod(a, b):\n        ans = 1\n        for x in range(a, b + 1):\n            ans *= x\n            ans %= MOD\n        return ans\n\n    def fact(x):\n        ans = 1\n        while x:\n            ans *= x\n            ans %= MOD\n            x -= 1\n        return ans\n \n    def coef(n, k):\n        if k > n: return 0\n        return (prod(n - k + 1, n) * pow(fact(k)%MOD, MOD - 2, MOD)) % MOD\n    \n    ans = 0\n    if (X + Y) % 3 == 0:\n        y = (2 * X - Y) // 3\n        x = X - 2 * y\n\n        if y >= 0 and x >= 0:\n            if x == 0 or y == 0:\n                ans = 1\n            else:\n                ans = coef(x + y, x)\n    print(ans)\n\n\nT = 1\n# T = int(input())\nfor case in range(1,T+1):\n    ans = solve()\n\n\n\"\"\"\n\n1 2\n3 4\n4 6\n\nx (1, 2) + y (2, 1)\n\nx + 2y = X\n2x + y = Y\n\n2x + 4y = 2X\n-2x - y = -Y\n3y = 2X - Y\ny = (2 * X - Y)\n\n\n3 3\n\n\n2 1\n\n\n\"\"\"\n", "def ex_euclid(a, b):\n  x0, x1 = 1, 0\n  y0, y1 = 0, 1\n  z0, z1 = a, b\n  \n  while z1 != 0:\n    q = z0 // z1\n    z0, z1 = z1, z0 % z1\n    x0, x1 = x1, x0 - q * x1\n    y0, y1 = y1, y0 - q * y1\n  \n  return z0, x0, y0\n\ndef mod_inv(a, n):\n  g, x, _ = ex_euclid(a, n)\n  if g != 1:\n    print(\"modular inverse does not exist\")\n  else:\n    return x % n\n\ndef mod_factorial(x, modulo):\n  ans = 1\n  for i in range(1, x+1):\n    ans *= i\n    ans %= modulo\n  return ans\n\nX, Y = map(int, input().split())\nM = 10 ** 9 + 7\na, b = (2*X-Y)/3, (2*Y-X)/3\nif a < 0 or b < 0:\n  print(0)\nelif a == 0 and b == 0:\n  print(0)\nelif a%1 != 0 or b%1!= 0:\n  print(0)\nelse:\n  a, b = int(a), int(b)\n  answer = 1\n  answer *= mod_factorial(a+b, M)\n  answer *= mod_inv(mod_factorial(a, M), M)\n  answer %= M\n  answer *= mod_inv(mod_factorial(b, M), M)\n  answer %= M\n  print(answer)", "p = 1000000007\n\nX, Y = list(map(int, input().split()))\n\nif (X + Y) % 3 != 0:\n    print((0))\n    return\n\na = (2 * Y - X) // 3\nb = (2 * X - Y) // 3\n\nif a < 0 or b < 0:\n    print((0))\n    return\n\nn = a + b\nfac = [0] * (n + 1)\nfac[0] = 1\nfor i in range(n):\n    fac[i + 1] = fac[i] * (i + 1) % p\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], p - 2, p) * pow(fac[k], p - 2, p) % p\n\n\nprint((mcomb(n, a)))\n#\u4ed6\u8005\u306e\u89e3\u7b54\u3092\u53c2\u8003\u306b\u3057\u305f\n", "from math import factorial\nx, y = list(map(int, input().split()))\nmod = 10**9+7\n\nif (2*y-x)%3 != 0 or (2*x-y)%3 != 0:\n    print((0))\n    return\ns = (2*x-y)//3\nt = (2*y-x)//3\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = mod\nN = 10 ** 6+1  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nans = cmb(s+t, s, p)\nprint(ans)\n", "def getComb(n, k, MOD):\n    if n < k:\n        return 0\n    if n-k < k:\n        k = n-k\n    comb = 1\n    for x in range(n-k+1, n+1):\n        comb = (comb*x)%MOD\n    d = 1\n    for x in range(1, k+1):\n        d = (d*x)%MOD\n    comb *= pow(d, MOD-2, MOD)\n    return comb%MOD\n\n\nx, y = map(int, input().split())\n\nif (x+y)%3 == 0:\n    n = (x+y)//3\n    if x < n or y < n:\n        ans = 0\n    else:\n        MOD = 10**9+7\n        ans = getComb(n, x-n, MOD)\nelse:\n    ans = 0\n    \nprint(ans)", "import math\n\ndef main():\n\tX, Y = [int(n) for n in input().split(\" \")]\n\tif (X + Y) % 3 != 0 or Y > 2 * X or X > 2 * Y:\n\t\tprint(0)\n\t\treturn 0\n\tp = 1000000007\n\tn_move = int((X + Y) / 3)\n\ti_move = int((2 * X - Y) / 3)\n\tj_move = int((2 * Y - X) / 3)\n\tf = [1, 1]\n\tfinv = [1, 1] + [0] * n_move\n\tfor i in range(n_move):\n\t\tf.append((f[-1] * (i + 2)) % p)\n\tlf = len(f)\n\tfinv[lf - 1] = modpower(f[-1], p - 2, p)\n\tfor i in range(lf - 1):\n\t\tfinv[lf - i - 2] = ((finv[lf - i - 1]) * (lf - i - 1)) % p\n\tprint((f[n_move] * (finv[i_move] * finv[j_move]) % p) % p)\n\ndef modpower(a, p, d):\n\tpp = [a]\n\tfor i in range(int(math.log2(p)) + 1):\n\t\tpp.append((pp[-1] ** 2) % d)\n\tb_p = format(p, 'b')\n\tm = 1\n\tfor i in range(len(b_p)):\n\t\tif b_p[-i-1] == \"1\":\n\t\t\tm = (m * pp[i]) % d\n\treturn m\n\nmain()", "X,Y=map(int,input().split())\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nN = 10 ** 6\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nif (X+Y)%3:\n    ans=0\nelse:\n    N=(X+Y)//3\n    if N<=X<=2*N and N<=Y<=2*N:\n        ans=cmb(N,X-N,p)\n    else:\n        ans=0\n\nprint(ans)", "#!/usr/bin/env python3\nfrom functools import reduce\n\nx, y = list(map(int, input().split()))\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, m):\n    def mul(a, b):\n        return a * b % m\n\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1, r + 1)))\n    return (over * pow(under, m - 2, m))%m\n\n\nr = abs(x - y)\nl = (min(x, y) - r) // 3\nr += l\nif l*2+r*1 in (x,y) and l >= 0:\n    print((cmb(r + l, l, mod)))\nelse:\n    print((0))\n", "import sys\n\n\nMOD = 1_000_000_007\n\n\nX, Y = [int(x) for x in input().split()]\n\n\ndef mod_pow(x, n):\n    ret = 1\n    while n > 0:\n        if n & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return ret\n\n\nz = X + Y\nif z % 3 != 0:\n    print((0))\n    return\n\nn = z // 3\nk = -1\nfor i in range(n, z - n + 1):\n    if X == i or Y == i:\n        k = z - n - i\n        break\nif k == -1:\n    print((0))\n    return\na = n\nfor i in range(n - 1, n - k, -1):\n    a = a * i % MOD\nb = k\nfor i in range(k - 1, 0, -1):\n    b = b * i % MOD\nans = a * mod_pow(b, MOD - 2) % MOD\nprint(ans)\n", "from functools import lru_cache\nMOD = 10**9+7\nx,y = map(int, input().split())\nsumm = x+y\n\n@lru_cache(maxsize=None)\ndef inv(n):\n    return pow(n,-1,MOD)\n\nif summ%3 == 0 and summ//3 <= x and summ//3 <= y:\n    mn = min(x,y)\n    n = mn - summ//3\n    a = summ//3\n    b = 1\n    ans = 1\n    for i in range(n):\n        ans *= a\n        ans *= inv(b)\n        ans %= MOD\n        a -= 1\n        b += 1\n    print(ans)\nelse:\n    print(0)", "\nx,y=list(map(int, input().split()))\n\nmod=pow(10, 9)+7\n\ndef comint(n, mod):\n    fac = [0 for _ in range(n)]\n    finv = [0 for _ in range(n)]\n    inv = [0 for _ in range(n)]\n    fac[0]=1\n    fac[1]=1\n    finv[0]=1\n    finv[1]=1\n    inv[1]=1\n\n    for i in range(2, n):\n        fac[i] = fac[i-1]*i%mod\n        inv[i] = mod-inv[mod%i]*(mod//i)%mod\n        finv[i] = finv[i-1]*inv[i]%mod\n    return fac, finv\n\ndef com(n, k, fac, finv, mod):\n    if n<k: return 0\n    if n<0 or k<0: return 0\n    return fac[n]*(finv[k]*finv[n-k]%mod)%mod\n\nif (x+y)%3!=0:\n    print((0))\nelse:\n    n=(x+y)//3\n    a=x-n\n    b=y-n\n    fac, finv = comint(a+b+1, mod)\n    print((com(a+b,a,fac,finv,mod)))\n", "x,y=list(map(int,input().split()))\nmod=10**9+7\n\na=(2*x-y)//3\nb=(2*y-x)//3\n\n\n\nif a!=(2*x-y)/3 or b!=(2*y-x)/3:\n    print((0))\nelif a<0 or b<0:\n    print((0))\nelse:\n    max=a+b+10\n    fac=[0]*max\n    finv=[0]*max\n    inv=[0]*max\n\n    fac[0]=fac[1]=1\n    finv[0]=finv[1]=1\n    inv[1]=1\n    for i in range(2,max):\n        fac[i]=fac[i-1]*i%mod\n        inv[i]=mod-inv[mod%i]*(mod//i)%mod\n        finv[i]=finv[i-1]*inv[i]%mod\n\n    ans=fac[a+b]*(finv[a]*finv[b]%mod)%mod\n    print(ans)\n", "def main():\n    x,y = list(map(int,input().split()))\n    mod = 10**9+7\n    if 0>2*y-x or (2*y-x)%3!=0:\n        print((0))\n        return\n    if 0>2*x-y or (2*x-y)%3!=0:\n        print((0))\n        return\n    n = (2*y-x)//3\n    m = (2*x-y)//3\n\n    def cmb(n, r, mod):\n        if ( r<0 or r>n ):\n            return 0\n        r = min(r, n-r)\n        return g1[n] * g2[r] * g2[n-r] % mod\n\n    N = 10**6\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range( 2, N + 1 ):\n        g1.append( ( g1[-1] * i ) % mod )\n        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n    print((cmb(n+m,n,mod)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 10 ** 9 + 7\nx, y = [int(i) for i in input().split()]\nif (2*x - y) % 3 != 0 or (2*y - x) % 3 != 0:\n  print(0)\n  return\na = (2*x - y) // 3\nb = (2*y - x) // 3\nif a < 0 or b < 0:\n  print(0)\n  return\ndef mygcd(a_b, b, mod):\n    b = min(a_b, b)\n    cnt = 1\n    for i in range(b):\n        cnt = cnt * (a_b - i) * pow(i+1, mod-2, mod) % mod\n    return cnt\nprint(mygcd(a+b, b, mod))", "fact = [1 for _ in range(1000000)]\ninv = [1 for _ in range(1000000)]\nfact_inv = [1 for _ in range(1000000)]\n\nP = 10**9+7\nfor i in range(2, 1000000):\n    fact[i] = (fact[i-1]*i) % P\n    inv[i] = P - (inv[P % i] * (P // i)) % P\n    fact_inv[i] = (fact_inv[i-1] * inv[i]) % P\n\nX, Y = map(int, input().split())\nres = 0\nif (X+Y) % 3 == 0:\n    a = (-X+2*Y) // 3\n    b = (2*X-Y) // 3\n    if a >= 0 and b >= 0:\n        res = fact[a+b] * ((fact_inv[a] * fact_inv[b]) % P) % P\nprint(res)", "x,y=map(int,input().split())\nmod=10**9+7\n\na=(2*x-y)//3\nb=(2*y-x)//3\n\n\n\nif a!=(2*x-y)/3 or b!=(2*y-x)/3:\n    print(0)\nelif a<0 or b<0:\n    print(0)\nelse:\n    max=a+b+10\n    fac=[0]*max\n    finv=[0]*max\n    inv=[0]*max\n\n    fac[0]=fac[1]=1\n    finv[0]=finv[1]=1\n    inv[1]=1\n    for i in range(2,max):\n        fac[i]=fac[i-1]*i%mod\n        inv[i]=mod-inv[mod%i]*(mod//i)%mod\n        finv[i]=finv[i-1]*inv[i]%mod\n\n    ans=fac[a+b]*(finv[a]*finv[b]%mod)%mod\n    print(ans)", "MOD = 10**9+7\nMAX = 1000010\nfinv = [0] * MAX\ninv = [0] * MAX\ndef COMinit():\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n    for i in range(2, MAX):\n        inv[i] = MOD - inv[MOD%i] * (MOD//i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\ndef COM(n, k):\n    res = 1\n    for i in range(k):\n        res = res * (n-i) % MOD\n    return res * finv[k] % MOD\n\nx, y = map(int, input().split())\nif (x+y)%3 != 0:\n    ans = 0\nelse:\n    s, t = (-x+2*y)//3, (2*x-y)//3\n    if s < 0 or t < 0:\n        ans = 0\n    else:\n        COMinit()\n        ans = COM((s+t), s)\n\nprint(ans)", "x, y = map(int, input().split())\n\nmod = 10**9 +7\n\ndef comb(n, r):\n    if 2 * r > n:\n        return comb(n, n-r)\n    return fac[n] * inv[r] * inv[n-r] % mod\n\nif (x+y) % 3 != 0:\n    print(0);return\n\nn = (x+y)//3\nx -= n\ny -= n\nif x < 0 or y < 0:\n    print(0);return\n\nfac = [1] * (n+1)\ninv = [1] * (n+1)\nfor i in range(2, n+1):\n    fac[i] = fac[i-1] * i % mod\ninv[n] = pow(fac[n], mod-2, mod)\nfor i in range(n-1, 1, -1):\n    inv[i] = inv[i+1] * (i+1) % mod\n\nprint(comb(x+y, x) % mod)"]
["def getIntList():\n    return list(map(int, input().split()));\nn, k = getIntList();\np=getIntList();\nchoosed=[False]*256;\nleft=[i for i in range(256)];\nfor i, x in enumerate(p):\n    if not choosed[x]:\n        best=x;\n        #print(x-1, max(-1, x-k));\n        for j in range(x-1, max(-1, x-k), -1):\n            #print('try ',j)\n            if not choosed[j]:\n                best=j;\n            else:\n                if x-left[j]<k:\n                    best=left[j];\n                break;\n        #print('best=',best)\n        for j in range(best, x+1):\n            choosed[j]=True;\n            left[j]=best;\n    p[i]=left[x];\nprint(' '.join(map(str, p)));", "n, k = [int(x) for x in input().split()]\n\nps = [int(x) for x in input().split()]\n\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n    \n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))\n", "n, k = list(map(int, input().split()))\nP = list(map(int, input().split()))\n\nparent = list(range(256))\nsz = [1] * 256\ndef rt(x):\n    if x != parent[x]:\n        parent[x] = rt(parent[x])\n    return parent[x]\n\ndef u(rx, ry):\n    parent[ry] = rx\n    sz[rx] += sz[ry]\n\nans = [0] * n\nfor i, p in enumerate(P):\n    rx = rt(p)\n    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:        \n        u(rt(rx - 1), rx)\n        rx = rt(p)\n    ans[i] = rt(p)\nprint(' '.join(map(str, ans)))\n", "\ndef solve():\n    num_pixels, max_group_size = (int(x) for x in input().split())\n    pixels = [int(x) for x in input().split()]\n    groups = [None for _ in range(256)]\n\n    for pixel in pixels:\n        if groups[pixel] is None:\n            smallest_of_group = pixel\n            while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None:\n                smallest_of_group -= 1\n\n            if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size:\n                group_color = groups[smallest_of_group]\n            else:\n                group_color = smallest_of_group + 1\n            smallest_of_group += 1\n            for color in range(smallest_of_group, pixel + 1):\n                groups[color] = group_color\n\n    print(*(groups[pixel] for pixel in pixels))\n\nsolve()\n", "#!/usr/bin/env python3\n\n[n, k] = list(map(int, input().strip().split()))\npis = list(map(int, input().strip().split()))\n\nimport sys\nif k == 1:\n\tprint(' '.join(map(str, pis)))\n\treturn\n\n\nN = 256\ngamma = [-1 for _ in range(N)]\ndone = [False for _ in range(N)]\nrevdone = [False for _ in range(N)]\nnotset = 256\npends = {}\n\ndef get_bounds(i):\n\ttry:\n\t\tl = N - 1 - revdone.index(True, N - 1 - i) + 1\n\texcept ValueError:\n\t\tl = 0\n\ttry:\n\t\tr = done.index(True, i) - 1\n\texcept ValueError:\n\t\tr = N - 1\n\treturn l, r\n\ndef set_gamma(l, r, v):\n\tfor i in range(l, r + 1):\n\t\tgamma[i] = v\n\t\tdone[i] = True\n\t\trevdone[N - 1 - i] = True\n\n\n\nfor p in pis:\n\tif not done[p]:\n\t\tlb, rb = get_bounds(p)\n\t\tif (lb > 0) and ((lb - 1) in pends) and (lb - 1 + pends[lb - 1] >= p):\n\t\t\tl = lb\n\t\t\tr = p\n\t\t\tset_gamma(l, r, gamma[lb - 1])\n\t\t\tif r - l + 1 < pends[lb - 1]:\n\t\t\t\tpends[r] = pends[lb - 1] - (r - l + 1)\n\t\t\tdel pends[lb - 1]\n\t\telse:\n\t\t\tl = max(p - k + 1, lb)\n\t\t\tr = p\n\t\t\tset_gamma(l, r, l)\n\t\t\tif r - l + 1 < k:\n\t\t\t\tpends[p] = k - (r - l + 1)\n\t\tnotset -= r - l + 1\n\t\tif notset == 0:\n\t\t\tbreak\n\nif notset > 0:\n\tfor i in range(N):\n\t\tif gamma[i] < 0:\n\t\t\tl, r = get_bounds(i)\n\t\t\tset_gamma(l, min(l + k - 1, r), l)\n\nprint(' '.join(str(gamma[p]) for p in pis))\n", "def main():\n    n, k = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    solve(n, k, p)\n\ndef solve(n, k, p):\n    group = 256 * [None]\n    r = p[:]\n    for i, pi in enumerate(p):\n#        print([(i, gi) for i, gi in enumerate(group)if gi is not None])\n        if group[pi] is not None:\n            r[i] = group[pi][0]\n        else:\n            lo = pi\n            while lo >= 0 and pi - lo < k and group[lo] is None:\n                lo -= 1\n            if lo < 0 or pi - lo == k:\n                lo += 1\n                hi = pi + 1\n            else: # group[lo] is not None\n                if pi - group[lo][0] < k:\n                    lo = group[lo][0]\n                    hi = pi + 1\n                else:\n                    lo += 1\n                    hi = pi + 1\n            lohi = (lo, hi)\n            for j in range(lo, hi):\n                group[j] = lohi\n            r[i] = group[pi][0]\n    print(\" \".join(map(str, r)))\n\nmain()\n", "n,k=list(map(int,input().split()))\np=list(map(int,input().split()))\n\narr=[[] for i in range(256)]\nans=[]\nfor i in p:\n    j=i\n    if len(arr[i])==0:\n        c=0\n        while c<k and j>=0:\n            if len(arr[j])+c>k:\n                break\n            #temp=len(arr[j])\n            if len(arr[j])!=0:\n                arr[i].extend(arr[j])\n                break\n            arr[j]=arr[i]\n            arr[j].append(j)\n            j-=1\n            c+=1\n        arr[i].sort()\n    ans.append(arr[i][0])\nprint(*ans)\n#print(arr)\n", "n,k = [int(s) for s in input().split()]\np = [int(s) for s in input().split()]\n\nmap = {}\nres = []\n\nfor pi in p:\n    if map.get(pi) is None:\n        key = pi\n        for j in range(pi, pi-k, -1):\n            if j < 0: break\n            if map.get(j) is None:\n                key = j\n            else:\n                if map[j] >= pi-k+1: key = map[j]\n                break\n        for j in range(pi, key-1, -1):\n            if map.get(j):\n                break\n            map[j] = key\n    res.append(map[pi])\n\nprint(*res, sep=\" \")\n", "N, K = input().split()\nN, K = int(N), int(K)\nP = [int(x) for x in input().split()]\nA = [None]*256\nA[0] = 0\nfor i in range(N):\n    pn = P[i]\n    if A[pn] is None:\n        for j in range(K-1, -1, -1):\n            if pn < j: continue\n            if A[pn-j] is None:\n                A[pn-j] = pn-j\n                break\n            else:\n                if A[pn-j] + K - 1 >= pn:\n                    break\n        for jj in range(j, -1, -1):\n            A[pn-jj] = A[pn-j]\nprint(*[A[P[i]] for i in range(N)])\n", "n, k = [int(i) for i in input().split()]\np = [int(i) for i in input().split()]\nans = [-1] * (max(p) + 1)\nans[0] = 0\nfor i in range(n):\n\tif ans[p[i]] < 0:\n\t\tposition = p[i] - k + 1\n\t\tfor j in range(max(0,p[i] - k + 1), p[i] + 1):\n\t\t\tif ans[j] < 0:\n\t\t\t\tposition = j\n\t\t\t\tbreak\n\t\tj = max(0, position - 1)\n\t\tkey = ans[j]\n\t\tcount = 0\n\t\twhile j >= 0:\n\t\t\tif ans[j] != key:\n\t\t\t\tposition1 = j + 1\n\t\t\t\tbreak\n\t\t\tj -= 1\n\t\t\tcount += 1\n\t\tif count + p[i] + 1 - position > k:\n\t\t\tkey = position\n\t\tfor j in range(position, p[i] + 1):\n\t\t\tans[j] = key\n\nfor i in range(n):\n\tif i != len(p) - 1:\n\t\twk1 = \" \"\n\telse:\n\t\twk1 = \"\\n\"\n\tprint(ans[p[i]], end = wk1)\n", "n,k = list(map(int,input().split()))\nl = [int(x) for x in input().split()]\nmaps = []\nfor _ in range(256):\n\tmaps.append(['empty',0])\noutput = []\nfor innum in l:\n\tif maps[innum][0] == 'chosen':\n\t\toutnum = maps[innum][1]\n\telif maps[innum][0] == 'potential':\n\t\toutnum = maps[innum][1]\n\t\ti = innum\n\t\twhile i >= 0 and maps[i][0] == 'potential':\n\t\t\tmaps[i] = ['chosen',outnum]\n\t\t\ti -= 1\n\telse:\n\t\ti = innum\n\t\twhile i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':\n\t\t\ti -= 1\n\t\ti += 1\n\t\toutnum = i\n\t\tfor j in range(outnum,innum+1):\n\t\t\tmaps[j] = ['chosen',outnum]\n\t\tif innum < 255:\n\t\t\tfor j in range(innum+1,min(256,outnum+k)):\n\t\t\t\tif maps[j][0] != 'chosen':\n\t\t\t\t\tmaps[j] = ['potential',outnum]\n\toutput.append(str(outnum))\nprint(' '.join(output))\n", "n, k = map(int, input().split())\nps = list(map(int, input().split()))\nif k == 1:\n    print(' '.join([str(i) for i in ps]))\n    return\n\ng = [None for i in range(256)]\nf = [None for i in range(256)]\nans = []\nfor i in range(n):\n    p = ps[i]\n    if g[p] is not None:\n        ans.append(g[p])\n        f[p] = 1\n    else:\n        gb= 0\n        for j in range(1, k):\n            ind = p - j\n            if f[ind] is not None:\n                gb = ind +1\n                break\n            if ind <= 0:\n                break\n            if j == k-1:\n                gb = ind\n        ans.append(gb)\n        for j in range(k):\n            if gb+j >= 256:\n                break\n            if f[gb + j] is None:\n                g[gb+j] = gb\n            else:\n                break\n        f[gb] = 1\n        f[p] = 1\nprint(' '.join([str(i) for i in ans]))", "n, k = map(int, input().split())\nps = list(map(int, input().split()))\n\n\ng = [None for i in range(256)]\nf = [None for i in range(256)]\nans = []\nfor i in range(n):\n    p = ps[i]\n    if g[p] is not None:\n        ans.append(g[p])\n        f[p] = 1\n    else:\n        gb= 0\n        for j in range(k):\n            ind = p - j\n            if f[ind] is not None:\n                gb = ind +1\n                break\n            if ind <= 0:\n                break\n            if j == k-1:\n                gb = ind\n        ans.append(gb)\n        for j in range(k):\n            if gb+j >= 256:\n                break\n            if f[gb + j] is None:\n                g[gb+j] = gb\n            else:\n                break\n        f[gb] = 1\n        f[p] = 1\nprint(' '.join([str(i) for i in ans]))", "n, k = map(int, input().strip().split())\ndata = map(int, input().strip().split())\nsol = []\nmapping = [(-1,1000)]*256\nfor x in data:\n    if mapping[x][0] == -1:\n        for i in range(max(x-k+1,0), x+1):\n            if mapping[i][0] == -1:\n                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:\n                    p = mapping[i-1][1]+1\n                    for j in range(i, x+1):\n                        mapping[j] = (mapping[i-1][0], p)\n                        p += 1\n                else:                    \n                    p = 1\n                    for j in range(i, x+1):\n                        mapping[j] = (i, p)\n                        p += 1\n                break\n    sol.append(mapping[x][0])\nprint(' '.join(map(str, sol)))", "import sys\n\nn, k = list(map(int, next(sys.stdin).rstrip().split()))\n\nxs = list(map(int, next(sys.stdin).rstrip().split()))\n\nmapka = {}\nlengths = {}\n\nresult = []\n\nfor x in xs:\n    \n    if x in mapka:\n        result.append(mapka[x])\n    else:\n        left = max(0, x - k + 1)\n        range_potential = x - left\n        for i in range(range_potential, -1, -1):\n            potential_left = x - i\n            if potential_left not in mapka:\n                result.append(potential_left)\n                for y in range(potential_left, x + 1):\n                    mapka[y] = potential_left\n\n                lengths[potential_left] = x - potential_left + 1\n\n                break\n            else:\n\n                if lengths[mapka[potential_left]] + (x - potential_left) <= k:\n                    result.append(mapka[potential_left])\n                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):\n                        mapka[y] = mapka[potential_left]\n                        lengths[mapka[potential_left]] += 1\n\n                    break\n            \nprint(' '.join(map(str, result)))\n", "a = [0 for i in range(0, 256)]\nn,k = input().split(' ')\nk = int(k)\nfor c in input().split(' '):\n        c = int(c)\n        if a[c] != 0:\n            print(a[c]-1, end=' ')\n        else:\n            for x in range(c, c-k, -1):\n                if a[x] == 0:\n                    i = x\n                else:\n                    if c-a[x]+1<k:\n                        i = a[x]-1\n                    break\n                if x == 0:\n                    break\n            for x in range(int(i), c+1):\n                a[x] = i + 1\n            print(i, end=' ')\n", "#!/usr/bin/env python3\n\n[n, k] = map(int, input().strip().split())\npis = list(map(int, input().strip().split()))\n\nimport sys\nif k == 1:\n\tprint (' '.join(map(str, pis)))\n\treturn\n\n\nN = 256\ngamma = [-1 for _ in range(N)]\ndone = [False for _ in range(N)]\nrevdone = [False for _ in range(N)]\nnotset = 256\npends = {}\n\ndef get_bounds(i):\n\ttry:\n\t\tl = N - 1 - revdone.index(True, N - 1 - i) + 1\n\texcept ValueError:\n\t\tl = 0\n\ttry:\n\t\tr = done.index(True, i) - 1\n\texcept ValueError:\n\t\tr = N - 1\n\treturn l, r\n\ndef set_gamma(l, r, v):\n\tfor i in range(l, r + 1):\n\t\tgamma[i] = v\n\t\tdone[i] = True\n\t\trevdone[N - 1 - i] = True\n\n\n\nfor p in pis:\n\tif not done[p]:\n\t\tlb, rb = get_bounds(p)\n\t\tif (lb > 0) and ((lb - 1) in pends) and (lb - 1 + pends[lb - 1] >= p):\n\t\t\tl = lb\n\t\t\tr = p\n\t\t\tset_gamma(l, r, gamma[lb - 1])\n\t\t\tif r - l + 1 < pends[lb - 1]:\n\t\t\t\tpends[r] = pends[lb - 1] - (r - l + 1)\n\t\t\tdel pends[lb - 1]\n\t\telse:\n\t\t\tl = max(p - k + 1, lb)\n\t\t\tr = p\n\t\t\tset_gamma(l, r, l)\n\t\t\tif r - l + 1 < k:\n\t\t\t\tpends[p] = k - (r - l + 1)\n\t\tnotset -= r - l + 1\n\t\tif notset == 0:\n\t\t\tbreak\n\nif notset > 0:\n\tfor i in range(N):\n\t\tif gamma[i] < 0:\n\t\t\tl, r = get_bounds(i)\n\t\t\tset_gamma(l, min(l + k - 1, r), l)\n\nprint (' '.join(str(gamma[p]) for p in pis))", "n, k = [int(x) for x in input().split()]\nps = [int(x) for x in input().split()]\nmapping = [-1 for _ in range(256)]\n\nres = []\nfor p in ps:\n    if mapping[p] == -1:\n        j = p - k + 1\n        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):\n            j += 1\n        for i in range(j, p+1):\n            mapping[i] = j\n    res.append(mapping[p])\nprint(\" \".join(map(str, res)))", "def main():\n\tn, k = [int(_) for _ in input().split()]\n\ta = [int(_) for _ in input().split()]\n\n\tp = [-1] * 256\n\tp[0] = 0\n\n\tfor x in a:\n\t\tif p[x] < 0:\n\t\t\tfor y in range(x - 1, max(-1, x - k), -1):\n\t\t\t\tif p[y] >= 0:\n\t\t\t\t\tif p[y] + k > x:\n\t\t\t\t\t\tp[x] = p[y]\n\t\t\t\t\telse:\n\t\t\t\t\t\tp[x] = p[y + 1] = y + 1\n\n\t\t\t\t\tbreak\n\t\t\tif p[x] < 0:\n\t\t\t\tp[x] = p[x - k + 1] = x - k + 1\n\n\tb = [p[x] for x in a]\n\n\tprint(' '.join(map(str, b)))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "n,k=[int(x)for x in input().split()]\nns=[int(x) for x in input().split()]\ndone=[None]*256\nans=[None]*n\nfor i in range(n):\n    c=ns[i]\n    if done[c]==None:\n        j=c\n        while True:\n            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):\n                break\n            j-=1\n        j+=1\n        for kk in range(k):\n            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):\n                break\n            if kk+j<=c:\n                done[kk+j]=j\n            else:\n                done[kk+j]=-1\n    elif done[c]==-1:\n        j=c\n        while True:\n            if done[j]!=None and done[j]!=-1:\n                break\n            j-=1\n        a=done[j]\n        for kk in range(j,c+1):\n            done[kk]=a\n    else:\n        pass\n    ans[i]=done[c]\n    # print(ans[i])\n    # print(done)\n    # if ans[i]==146:\n    #     print(ans[i])\n    #     print(done)\n    #     input()\nans=[str(x)for x in ans]\nprint(' '.join(ans))\n\n\n\n", "n,k=map(int,input().split())\n\nar=[-1 for i in range(256)]\nls=list(map(int,input().split()))\n\nfor e in ls:\n    if ar[e]==-1:\n        tmp=max(0,e-k+1)\n        for i in range(tmp,e+1):\n            if ar[i]!=-1 and ar[i]!=i:\n                tmp+=1\n                continue\n            else:\n                while i<=e:\n                    ar[i]=tmp\n                    i+=1\n    print(ar[e],end=\" \")\n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nc = [-1]*256\n\nans = [0]*n\nfor i in range(n):\n    if c[a[i]] == -1:\n        for j in range(a[i], max(-1, a[i]-k), -1):\n            if c[j] != -1:\n                if (c[j] +k) > a[i]:\n                    c[a[i]] = c[j]\n                else:\n                    c[a[i]] = j+1\n                break\n        if c[a[i]] == -1:\n            c[a[i]] = max(0, a[i]-k+1)\n        for xx in range(c[a[i]], a[i]):\n            c[xx] = c[a[i]]\n    ans[i] = str(c[a[i]])\n\nprint(' '.join(ans))\n", "n, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nprocessed = set()\ncolor = {}\nlength = {}\nans = []\n\ndef exists(p, elt, d):\n    for e in p:\n        if e > elt:\n            if e <= elt + d:\n                return True\n            elif e - d <= elt + d:\n                return False\n    return False\n\ndef exists2(p, elt, d):\n    for e in p:\n        if e > elt:\n            if e <= elt + d:\n                return False\n            elif e - d <= elt + d:\n                return [True, e - d]\n    return False\n        \n\nfor i in range(n):\n    elt = p[i]\n    if elt in processed:\n        ans.append(color[elt])\n    else:\n        processed.add(elt)\n        new = 1\n        run = True\n        for j in range(1, k):\n            if elt - j < 0:\n                break\n            elif (elt - j) not in processed:\n                processed.add(elt - j)\n                new += 1\n            elif length[elt - j] + new <= k:\n                for i2 in range(length[elt - j] + new):\n                    color[elt - i2] = color[elt - j]\n                length[elt] = length[elt - j] + new\n                run = False\n                break\n            else:\n                break\n        if run:\n            for j in range(new):\n                color[elt - j] = elt - new + 1\n            length[elt] = new\ns = str(color[p[0]])\nfor elt in p[1:]:\n    s += ' ' + str(color[elt])\nprint(s)\n\n", "n, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nprocessed = set()\ncolor = {}\nlength = {}\nans = []\n\nfor i in range(n):\n    elt = p[i]\n    if elt in processed:\n        ans.append(color[elt])\n    else:\n        processed.add(elt)\n        new = 1\n        run = True\n        for j in range(1, k):\n            if elt - j < 0:\n                break\n            elif (elt - j) not in processed:\n                processed.add(elt - j)\n                new += 1\n            elif length[elt - j] + new <= k:\n                for i2 in range(length[elt - j] + new):\n                    color[elt - i2] = color[elt - j]\n                length[elt] = length[elt - j] + new\n                run = False\n                break\n            else:\n                break\n        if run:\n            for j in range(new):\n                color[elt - j] = elt - new + 1\n            length[elt] = new\ns = str(color[p[0]])\nfor elt in p[1:]:\n    s += ' ' + str(color[elt])\nprint(s)\n\n"]
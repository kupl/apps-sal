["from math import gcd\n\ndef Fenjie(n):\n    k = {}\n    if (n == 1):\n        return {}\n    a = 2\n    while (n >= 2):\n        if (a*a > n):\n            if (n in k):\n                k[n] += 1\n            else:\n                k[n] = 1\n            break\n        b = n%a\n        if (b == 0):\n            if (a in k):\n                k[a] += 1\n            else:\n                k[a] = 1\n            n = n//a\n        else:\n            a += 1\n    return k\n\ndef Euler(n):\n    if (n == 1):\n        return 1\n    k = Fenjie(n)\n    m = n\n    for i in k:\n        m = m // i * (i-1)\n    return m\n\nt = int(input())\nfor _ in range(t):\n    a, b = list(map(int, input().split()))\n    b = b//gcd(a,b)\n    print(Euler(b))\n", "import math\ndef okay(n):\n    ans=n\n    i=2\n    while i*i<=n:\n        if n%i==0:\n            while n%i==0:\n                n=int(n/i)\n            ans-=int(ans/i)\n        i+=1\n    if n>1:\n        ans-=int(ans/n)\n    return ans\nt=int(input())\nwhile t:\n    t-=1\n    a,m=list(map(int,input().split()))\n    print(okay(int(m/math.gcd(a,m))))\n            \n", "from math import gcd\n\ndef factor(x):\n\tfactors = set()\n\n\tf = 2\n\n\twhile f * f <= x:\n\t\twhile x % f == 0:\n\t\t\tfactors.add(f)\n\t\t\tx //= f\n\n\t\tf += 1\n\n\tif x > 1:\n\t\tfactors.add(x)\n\n\treturn factors\n\nfor _ in range(int(input())):\n\ta, m = map(int, input().split())\n\n\tg = gcd(a, m)\n\n\ta //= g\n\tm //= g\n\n\t# now just find such that 0 <= x < m & gcd(a + x, m) = 1\n\t# how many numbers in [a, a + m) are coprime to m\n\n\tf = list(factor(m))\n\n\ttot = 0\n\n\tfor i in range(1, 2 ** len(f)):\n\t\tmul = 1\n\n\t\tbc = -1\n\n\t\tfor j in range(len(f)):\n\t\t\tif i & (1 << j):\n\t\t\t\tmul *= f[j]\n\t\t\t\tbc = -bc\n\n\t\ttot += bc * (m // mul + (a % mul < (a + m - 1) % mul))\n\n\tprint(m - tot)", "primes=[True]*1000001\nprimes[0]=False\nprimes[1]=False\nfor i in range(2, 100001):\n    if primes[i]:\n        for j in range(i*2, 100001, i):\n            primes[j]=False\npL=[]\nfor i in range(2, 100001):\n    if primes[i]:pL.append(i)\ndef fact(n):\n    L=[]\n    for i in pL:\n        if n%i==0:\n            while n%i==0:\n                L.append(i)\n                n//=i\n    if n!=1:L.append(n)\n    return L\ndef gcd(a,b):\n    while b:\n        a,b=b,a%b\n    return a\nfor i in ' '*int(input()):\n    a,m=map(int,input().split())\n    g=gcd(a,m)\n    aa=a//g\n    mm=m//g\n    L=fact(mm)\n    M=[]\n    for i in L:\n        if i not in M:M.append(i)\n    for i in M:\n        mm*=(i-1)\n        mm//=i\n    print(mm)", "from math import gcd\nt = int(input())\n\n\nfor _ in range(t):\n    a, m = map(int, input().split())\n\n    b = m//gcd(a, m)\n\n    p = set()\n    pow = {}\n\n    i = 2\n    while (i*i<=b):\n        while (b%i==0):\n            if i not in p:\n                p.add(i)\n                pow[i] = 0\n            pow[i]+=1\n            b//=i\n        i+=1\n    if (b>1):\n        p.add(b)\n        pow[b] = 1\n\n    ans = 1\n    for prost in p:\n        ans*=prost**(pow[prost]-1)*(prost-1)\n    print(ans)", "from math import gcd\n\ndef popcnt(n):\n\treturn bin(n).count(\"1\") % 2\n\ndef calc(gen, limit):\n\tdivisors = []\n\ti = 2\n\tgen_copy = gen\n\twhile gen > 1 and i*i <= gen_copy:\n\t\tif gen%i == 0:\n\t\t\tdivisors.append(i)\n\t\t\twhile gen%i == 0:\n\t\t\t\tgen //= i\n\t\ti += 1\n\tif gen != 1:\n\t\tdivisors.append(gen)\n\t#print(divisors)\n\n\tl = len(divisors)\n\tres = 0\n\tfor bit in range(1 << l):\n\t\tprod = 1\n\t\tfor j, div in enumerate(divisors):\n\t\t\tif (bit>>j) & 1:\n\t\t\t\tprod *= div\n\t\t#print(bit, prod)\n\t\tif popcnt(bit):\n\t\t\tres -= (limit-1) // prod\n\t\telse:\n\t\t\tres += (limit-1) // prod\n\treturn res\n\n\n\nT = int(input())\nfor _ in range(T):\n\ta, m = map(int, input().split())\n\tg = gcd(a, m)\n\tk, l = a//g, m//g\n\tprint(calc(l, l+k) - calc(l, k))", "from math import gcd\n\n\ndef solve(n):\n    ans = n\n    i = 2\n    while i ** 2 <= n:\n        if not n % i:\n            while not n % i:\n                n //= i\n            ans -= ans // i\n        i += 1\n    if n > 1:\n        ans -= ans // n\n    return ans\n\n\ndef main():\n    for _ in range(int(input())):\n        a, m = list(map(int, input().split()))\n        a = gcd(a, m)\n        n = m // gcd(a, m)\n        print(solve(m // gcd(a, m)))\n\n\nmain()\n", "from functools import *\nfrom math import gcd\nfrom collections import *\ndef isValid(n):\n    if n <= 0: return 0\n    if n - int(n) != 0: return 0\n    return 1\ndef mu(n):\n    if n == 1:\n        return 1\n    elif isDivisibleBySquare(n):\n        return 0\n    else:\n        return (-1) ** numberOfFactors(n)\ndef isDivisibleBySquare(n):\n    if n % 2 == 0:\n        n = n / 2\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n ** 0.5) + 1):\n        if n % i == 0:\n            n //= i\n        if n % i == 0:\n            return True\n    return False\ndef factorGenerator(n):\n    r = []\n    while n % 2 == 0:\n        n //= 2\n        r.append(2)\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            n //= i\n            r.append(i)\n        i += 2\n    if n != 1:\n        r.append(n)\n    return r\ndef numberOfFactors(n):\n    return len(factorGenerator(n))\ndef divisors(n):\n    return set(reduce(list.__add__,\n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef calc(m, n):\n    # Calculate number of integers in [1, m] coprime to n\n    s = 0\n    for d in sorted(list(set(divisors(n)))):\n        s += mu(d) * (m // d)\n    return s\n\nn = int(input())\nfor _ in range(n):\n    a, m = list(map(int, input().split()))\n    g = gcd(a, m)\n    # print (calc(a, m))\n    print(calc((m + a - 1) // g, m // g) - calc((a - 1) // g, m // g))\n    # print (sum(gcd(a, m) == gcd(a + x, m) for x in range(m)))\n"]
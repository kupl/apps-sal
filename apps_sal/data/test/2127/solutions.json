["import sys\n\nn = int(sys.stdin.readline().strip())\nm = 0\nM = 0\n\nfor i in range (0, n):\n    line = sys.stdin.readline().strip().split()\n    s = line[0]\n    x = min([int(line[1]), int(line[2])])\n    y = max([int(line[1]), int(line[2])])\n    if s == '+':\n        m = max([m, x])\n        M = max([M, y])\n    else:\n        if x >= m and y >= M:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\n", "import sys\ninput = sys.stdin.readline\n\nQ=int(input())\nnx=0\nny=0\nfor i in range(Q):\n    q,x,y=input().split()\n    x,y=int(x),int(y)\n    if x>y:\n        x,y=y,x\n\n    if q==\"+\":\n        nx=max(nx,x)\n        ny=max(ny,y)\n    else:\n        if x>=nx and y>=ny:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    \n", "T = int(input())\nx = 0\ny = 0\nuu = []\nfor _ in range(T):\n    p, a, b = input().split()\n    a = int(a)\n    b = int(b)\n    if p == '+':\n        x = max(x, max(a, b))\n        y = max(y, min(a, b))\n    else:\n        if max(a, b) >= x and min(a, b) >= y:\n            uu.append(\"YES\")\n        else:\n            uu.append(\"NO\")\nprint(\"\\n\".join(uu))", "x,y = 0,0\nres = ''\nn = int(input())\nfor _ in range(n):\n    q = [i for i in input().split()]\n    q[1] = int(q[1])\n    q[2] = int(q[2])\n    if q[0] == '+':\n        x = max(x, min(q[1], q[2]))\n        y = max(y, max(q[1], q[2]))\n    elif x <= min(q[1], q[2]) and y <= max(q[1], q[2]):\n        res += 'YES\\n'\n    else:\n        res += 'NO\\n'\nprint(res)\n", "n=int(input())\n\nmini=-1\nmaxi=-1\n\nans_arr=[]\n\nfor t in range(n):\n\t[a,b,c]=input().split()\n\n\tb=int(b)\n\tc=int(c)\n\n\tif(a==\"+\"):\n\t\tv1=min(b,c)\n\t\tv2=max(b,c)\n\t\tif(v1>mini):\n\t\t\tmini=v1\n\t\tif(v2>maxi):\n\t\t\tmaxi=v2\n\telse:\n\t\tif((mini<=b and maxi<=c) or (mini<=c and maxi<=b)):\n\t\t\tans_arr.append(\"YES\")\n\t\telse:\n\t\t\tans_arr.append(\"NO\")\n\nfor k in range(len(ans_arr)):\n\tprint(ans_arr[k])", "#\t!/usr/bin/env python3\n#\tcoding: UTF-8\n#\tModified: <11/Jan/2019 09:31:41 PM>\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology (IIIT),Gwalior\n\n#\tQuestion Link\n#\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    h, w = 0, 0\n    for tc in range(int(input())):\n        t, x, y = input().split()\n        x = int(x)\n        y = int(y)\n        if x < y:\n            x, y = y, x\n        if t == '+':\n            h = max(h, x)\n            w = max(w, y)\n        elif t == '?':\n            if x >= h and y >= w:\n                print('YES')\n            else:\n                print('NO')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nQTYPE = 0\nX = 0\nY = 1\nH = 1\nW = 2\n\ndef main():\n    buf = input()\n    n = int(buf)\n    query = []\n    for i in range(n):\n        buf = input()\n        buflist = buf.split()\n        if int(buflist[1]) > int(buflist[2]):\n            query.append([buflist[0], int(buflist[1]), int(buflist[2])])\n        else:\n            query.append([buflist[0], int(buflist[2]), int(buflist[1])])\n\n\n    bill_size = [query[0][H], query[0][W]]\n    for i in range(n):\n        if query[i][QTYPE] == '+':\n            bill_size = [max(bill_size[X], query[i][H]), max(bill_size[Y], query[i][W])]\n        else:\n            if bill_size[X] <= query[i][H] and bill_size[Y] <= query[i][W]:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\ndef __starting_point():\n    main()\n\n__starting_point()", "x,y=0,0\nfrom sys import stdin\nfor _ in range(int(input())):\n    a,i,j=(o for o in stdin.readline().split())\n    i,j=int(i),int(j)\n    if a=='+':\n        x=max(x,min(i,j))\n        y=max(y,max(i,j))\n    else:\n        if (x<=i and y<=j) or (x<=j and y<=i):\n            print(\"YES\")\n        else:\n            print('NO')", "''' Thruth can only be found at one place - THE CODE '''\n\n''' Copyright 2018, SATYAM KUMAR'''\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\n\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\nsys.setrecursionlimit(10000000)\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\noptimiseForReccursion = False #Can not be used clubbed with TestCases\ndef is_Valid(a,b):\n    #print(a,b)\n    x = min(a,b)\n    y = max(a,b)\n    diff = (y-x)\n    y = y-2*diff\n    x = x-1*diff\n    if x>=0 and y>=0 and x%3==0 and y%3==0:\n        return True\n    return False\n\ndef main():\n    n = get_int()\n    maxi,mini = 0,0\n    for _ in range(n):\n        k = stdin.readline()\n        x,y,z = k.split()\n        y=int(y)\n        z=int(z)\n        if x=='+':\n            maxi=max(maxi,y,z)\n            mini = max(min(y,z),mini)\n        else:\n            print(\"YES\") if min(y,z)>=mini and max(y,z)>=maxi else print(\"NO\")\n        #print(mini,maxi)\n# --------------------------------------------------------------------- END\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int(input())\nc = [0, 0]\nans = []\nfor i in range(n):\n    minx, miny = c[0], c[1]\n    v, x, y = input().split()\n    x, y = int(x), int(y)\n    x, y = max(x, y), min(x, y)\n    if v == '+':\n        if not((x <= minx and y <= miny) or (x <= miny and y <= minx)):\n            if x > minx:\n                if y > minx:\n                    minx = y\n                    if x > miny:\n                        miny = x\n\n                else:\n                    minx = x\n                    if y > miny:\n                        miny = y\n            elif y > miny:\n                miny = y\n    else:\n        if ((x >= minx and y >= miny) or (x >= miny and y >= minx)):\n            ans.append('YES')\n        else:\n            ans.append('NO')\n    c = sorted([minx, miny], reverse=True)\nprint('\\n'.join(ans))", "input=__import__('sys').stdin.readline\nx=0;y=0\nfor _ in range(int(input())):\n    a,b,c=map(str,input().split())\n    b,c=int(b),int(c)\n    if a=='+':x=max(x,min(b,c));y=max(y,max(b,c))\n    else:\n        if (b>=x and c>=y) or (c>=x and b>=y):print('YES')\n        else:print('NO')", "n=int(input())\nma=0\nmb=0\ns=''\nfor i in range(n):\n    a=input().split()\n    a[1]=int(a[1])\n    a[2]=int(a[2])\n    if a[2]<a[1]:\n        a[1],a[2]=a[2],a[1]\n    if a[0]=='+':\n        ma=max(ma,a[1])\n        mb=max(mb,a[2])\n    else:\n        if a[1]>=ma and a[2]>=mb:\n            s+=\"YES\\n\"\n        else:\n            s+=\"NO\\n\"\nprint(s)\n", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [list(map(str,input().split())) for _ in range(n)]\ntate = 0\nyoko = 0\nfor i in range(n):\n    if a[i][0] == \"+\":\n        b = [int(a[i][1]),int(a[i][2])]\n        b.sort()\n        if tate < b[0]:\n            tate = b[0]\n        if yoko < b[1]:\n            yoko = b[1]\n    elif a[i][0] == \"?\":\n        b = [int(a[i][1]),int(a[i][2])]\n        b.sort()\n        if tate <= b[0] and yoko <= b[1]:\n            print(\"YES\")\n        else:\n            print(\"NO\")", "import sys\nlax = -10**9;lay = -10**9\nfor _ in range(int(input())) :\n  sign,x,y = list(map(str,sys.stdin.readline().split()))\n  x=int(x)\n  y=int(y)\n  if sign==\"+\" :\n    if y > x :\n       t=x\n       x=y\n       y=t\n    lax = max(x,lax)\n    lay = max(y,lay)\n  else :\n     if y > x :\n       t=x\n       x=y\n       y=t\n     #print(lax,lay)\n     if lax<=x and lay<=y :\n         print(\"YES\")\n     else :\n         print(\"NO\")\n   \n       \n", "q = int(input())\nc = 0\nL = []\nwhile q > 0:\n    q = q-1\n    t,a,b = input().split()\n    a = int(a)\n    b = int(b)\n    if c == 0 and t == '+':\n        mi,ma = min(a,b),max(a,b)\n        c = 1\n    if t == '+':\n        mi = max(mi,min(a,b))\n        ma = max(ma,max(a,b))\n        #print(mi,ma)\n    elif t == '?':\n        #print(mi,ma,a,b)\n        if min(a,b) >= mi and max(a,b) >= ma:\n            L.append(\"YES\")\n        else:\n            L.append(\"NO\")\nprint('\\n'.join(L))", "import sys\n#sys.stdin = open('E:\\\\Sublime\\\\in.txt', 'r')\n#sys.stdout = open('E:\\\\Sublime\\\\out.txt', 'w')\ntc = int(sys.stdin.readline())\nx = 0\ny = 0\nfor i in range(tc):\n    p, a, b = sys.stdin.readline().split()\n    a = int(a)\n    b = int(b)\n    if p == '+':\n        x = max(x, max(a, b))\n        y = max(y, min(a, b))\n    else:\n        if max(a, b) >= x and min(a, b) >= y:\n        \tprint('YES')\n        else:\n        \tprint('NO')", "import sys\n#sys.stdin = open('E:\\\\Sublime\\\\in.txt', 'r')\n#sys.stdout = open('E:\\\\Sublime\\\\out.txt', 'w')\ntc = int(sys.stdin.readline())\nx = 0\ny = 0\nfor i in range(tc):\n    p, a, b = sys.stdin.readline().split()\n    a = int(a)\n    b = int(b)\n    if p == '+':\n        x = max(x, max(a, b))\n        y = max(y, min(a, b))\n    else:\n        if max(a, b) >= x and min(a, b) >= y:\n        \tprint('YES')\n        else:\n        \tprint('NO')"]
["\n#q = int(input())\n#x, y = map(int,input().split(' '))\n#print (' '.join(list(map(str, s))))\n\ndef extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n \ndef modinv(a, m):\n    g, x, y = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\n\nm = 998244353\nn = int(input())\np = list(map(int,input().split(' ')))\n\nup = 0\nlow = 1\nfor i in range(n):\n    up = up + low\n    up = up * 100 % m\n    low = low * p[i] % m\n    \nprint (up*modinv(low,m)%m)", "M = 998244353\n\ndef gcd(a, b):\n    if (a == 0):\n        return 0, 1\n\n    x, y = gcd(b % a, a)\n\n    return y - (b // a) * x, x\n\n\n\nk = input()\nprobs = list(map(int, input().split(' ')))\nnum, denum = 0, 1\nfor p in probs:\n    num = (num + denum) * 100 % M\n    denum = denum * p % M\n\n    #print(num, denum)\n\ninv, _ = gcd(denum, M)\nprint(num * inv % M)\n\n\n#d[i + 1] = (d[i] + 1) * 100 / p\n", "mod = 998244353\n\ndef inv_mod(n) :\n        return pow(n, mod-2, mod)\n\ndef frac_mod(a, b) :\n        return a*inv_mod(b) % mod\n\nn = int(input())\na = input().split()\n\nres = 0\nfor v in a :\n        res = (res+1) * 100 * inv_mod(int(v)) % mod\n\nprint(res)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nMOD = 998244353\n \nn = int(input())\na = [int(item) for item in input().split()]\nA = 0\nB = 0\nchild = 1\nbases = []\nbase = 1\nfor i in range(n + 10):\n    bases.append(base)\n    base *= 100\n    base %= MOD\n\nfor i, item in enumerate(a):\n    A += child * (100 - item) * bases[n-i-1]\n    A %= MOD\n    B += child * (100 - item) * bases[n-i-1] * (i + 1)\n    B %= MOD\n    child *= item\n    child %= MOD\nB += child * n\nans = B * pow(bases[n]-A, MOD-2, MOD)\nans %= MOD\nprint(ans)", "mod = 998244353\n\ndef inv_mod(n):\n    return pow(n, mod - 2, mod)\n\nn = int(input())\np = [int(x) for x in input().split()]\n\nres = 0\nfor i in p:\n    res = (res + 1) * 100 * inv_mod(i) % mod\n\nprint(res)", "import sys\nimport math\nfrom collections import defaultdict\nfrom collections import deque\nfrom itertools import combinations\nfrom itertools import permutations\ninput = lambda : sys.stdin.readline().rstrip()\nread = lambda : list(map(int, input().split()))\ndef write(*args, sep=\"\\n\"):\n  for i in args:\n    sys.stdout.write(\"{}{}\".format(i, sep))\nINF = float('inf')\nMOD = 998244353\nYES = \"YES\"\nNO = \"NO\"\n\nn = int(input())\np = [0] + read()\np = list(map(lambda x : x*pow(100, MOD-2, MOD)%MOD, p))\n\n\nA = [0] * (n+2)\n\nfor i in range(2, n+2):\n  A[i] = (A[i-1] - 1) * pow(p[i-1], MOD-2, MOD) % MOD \n\nprint((-A[-1] + MOD) % MOD)", "\nM = 998244353\n\nn = int(input())\n\nexp = 0\nfor pi in map(int,input().split()):\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n\nprint(exp)\n\n", "mod = 998244353\n\ndef pow_(x, p, mod):\n    if p == 1: return x % mod \n    \n    tmp  = pow_(x, p // 2, mod)\n    if p % 2 == 0:\n        return (tmp * tmp) % mod\n    else:\n        return (tmp * tmp * x) % mod\n    \ndef reverse(x, mod):\n    return pow_(x, mod-2, mod)\n\nn     = int(input()) + 1\np     = [0] + list(map(int, input().split()))\ndp    = [0] * n\nrev   = [0] * 101 \n\nfor i in range(1, 101):\n    rev[i] = reverse(i, mod)\n    \nfor i in range(1, n):\n    dp[i]=(((dp[i-1]+1)*100 * rev[p[i]])) % mod \n    \nprint(dp[-1])", "M = 998244353\n \nn = int(input())\n \nexp = 0\nfor pi in map(int,input().split()):\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n \nprint(exp)", "M = 998244353\n \ndef gcd(a, b):\n    if (a == 0):\n        return 0, 1\n \n    x, y = gcd(b % a, a)\n \n    return y - (b // a) * x, x\n \nk = input()\nprobs = list(map(int, input().split(' ')))\nnum, denum = 0, 1\nfor p in probs:\n    num = (num + denum) * 100 % M\n    denum = denum * p % M\n \ninv, _ = gcd(denum, M)\nprint(num * inv % M)", "import os\n\nN = int(3e5 + 233)\nMOD = 998244353\nans = []\nfor i in range(N):\n    ans.append(0)\n\ndef fp(x, y):\n    res = 1\n    while y:\n        if y&1:\n            res = res * x\n            res %= MOD\n        x *= x\n        x %= MOD\n        y >>= 1\n    return res\n\ninv = fp(100, MOD-2)\nn = int(input())\ndig = list(map(int, input().split()))\nfor i in range(1, n+1):\n    x = dig[i-1]\n    x *= inv\n    x %= MOD\n    ans[i] = (((1 + ans[i-1]) % MOD) * fp(x, MOD-2)) % MOD\nprint(ans[n])", "import sys\ninput=sys.stdin.readline\nn=int(input())\nL=map(int,input().split())\nk=0\nc=1\nm=998244353\ncounter=0\nfor i in L:\n    k+=c*(pow(100,n-counter,m))\n    k%=m\n    c*=i\n    c%=m\n    counter+=1\ndef modInverse(a, m) : \n    m0 = m \n    y = 0\n    x = 1\n    if (m == 1) : \n        return 0\n    while (a > 1) : \n        q = a // m \n        t = m \n        m = a % m \n        a = t \n        t = y \n        y = x - q * y \n        x = t \n    if (x < 0) : \n        x = x + m0 \n    return x \np=k%m\nq=c%m\nprint((modInverse(q,m)*p)%m)", "from collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input())\n\nn = val()\nexp = 0\nfor pi in li():\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n \nprint(exp)", "def solve():\n    s = input()\n    if 'aa' in s or 'bb' in s or 'cc' in s:\n        print(-1)\n        return\n    syms = s + '@'\n    ans = ['@']\n    for i, sym in enumerate(s):\n        if sym != '?':\n            ans.append(sym)\n            continue\n        for x in 'abc':\n            if x != ans[-1] and x != syms[i + 1]:\n                ans.append(x)\n                break\n    print(''.join(ans[1:]))\n\n\ndef solveb():\n    n = int(input())\n    perm = [int(x) for x in input().split()]\n    num___idx = [-1 for _ in range(n + 1)]\n    for i, num in enumerate(perm):\n        num___idx[num] = i\n\n    curr_max = -1\n    curr_min = 2 * n\n    num___pretty = [0 for _ in range(n + 1)]\n    for num in range(1, n + 1):\n        curr_max = max(num___idx[num], curr_max)\n        curr_min = min(num___idx[num], curr_min)\n        if curr_max - curr_min + 1 == num:\n            num___pretty[num] = 1\n    print(*num___pretty[1:], sep='')\n\n\ndef solvec():\n    n = int(input())\n    rank___problems_nr = [int(x) for x in input().split()]\n    weird_prefsums = [0]\n    last_num = rank___problems_nr[0]\n    for num in rank___problems_nr:\n        if num != last_num:\n            last_num = num\n            weird_prefsums.append(weird_prefsums[-1])\n        weird_prefsums[-1] += 1\n\n    gold = weird_prefsums[0]\n    silvers = 0\n    i = 1\n    for i in range(1, len(weird_prefsums)):\n        x = weird_prefsums[i]\n        if x - gold > gold:\n            silvers = x - gold\n            break\n\n    bronzes = 0\n    for j in range(i, len(weird_prefsums)):\n        x = weird_prefsums[j]\n        if x > n / 2:\n            break\n        if x - gold - silvers > gold:\n            bronzes = x - gold - silvers\n    if bronzes == 0 or silvers == 0:\n        print(0, 0, 0)\n        return\n\n    print(gold, silvers, bronzes)\n\n\ndef solved():\n    a, b, c, d = (int(x) for x in input().split())\n    ab_len = min(a, b)\n    a -= ab_len\n    b -= ab_len\n    cd_len = min(c, d)\n    c -= cd_len\n    d -= cd_len\n\n    if a == 1 and cd_len == 0 and d == 0 and c == 0:\n        print('YES')\n        print('0 1 ' * ab_len + '0')\n        return\n    if d == 1 and ab_len == 0 and a == 0 and b == 0:\n        print('YES')\n        print('3 ' + '2 3 ' * cd_len)\n        return\n    if a > 0 or d > 0:\n        print('NO')\n        return\n\n    cb_len = min(b, c)\n    b -= cb_len\n    c -= cb_len\n    if b > 1 or c > 1:\n        print('NO')\n        return\n    print('YES')\n    print('1 ' * b + '0 1 ' * ab_len + '2 1 ' * cb_len + '2 3 ' * cd_len + '2' * c)\n\n\ndef get_me(prob, mod):\n    # return 100, prob\n    return (100 * pow(prob, mod - 2, mod)) % mod\n\n\ndef solvee():\n    n = int(input())\n    mod = 998244353\n    idx___prob = [int(x) for x in input().split()]\n    curr_me = get_me(idx___prob[0], mod)\n    for prob in idx___prob[1:]:\n        me = get_me(prob, mod)\n        curr_me *= me\n        curr_me %= mod\n\n        curr_me += me\n        curr_me %= mod\n\n    # curr_q_me = pow(curr_q_me, mod - 2, mod)\n\n    print(curr_me)\n\n\ndef __starting_point():\n    solvee()\n\n__starting_point()", "from collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input())\n \nn = val()\nexp = 0\nfor pi in li():\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n \nprint(exp)\n#From SMMaster\n", "# \u89e3\u8aacAC\nmod = 998244353\nn = int(input())\np = list(map(int, input().split()))\ni100 = pow(100, mod-2, mod)\np = [i*i100%mod for i in p]\n\ntop = 1\nfor i in range(n-2, -1, -1):\n    top *= p[i]\n    top += 1\n    top %= mod\n\nbot = 1\nfor i in range(n):\n    bot *= p[i]\n    bot %= mod\n\nans = top*pow(bot, mod-2, mod)%mod\nprint(ans)", "n = int(input())\np = list(map(int, input().split()))\n\nans = 0\nsize = 998244353\n\nfor p in p:\n    ans = (ans+1) % size\n    ans = (((ans*100) % size)*pow(p, size-2, size)) % size\n\nprint(ans)\n", "mod = 998244353\n \ndef inv_mod(n):\n    return pow(n, mod - 2, mod)\n \nn = int(input())\np = [int(x) for x in input().split()]\n \nres = 0\nfor i in p:\n    res = (res + 1) * 100 * inv_mod(i) % mod\n \nprint(res)", "n = int(input())\nexp = 0 \nM = 998244353\nfor pi in map(int, input().split()):\n    exp = (exp+1)*100*pow(pi, M-2, M) %M\n\nprint(int(exp%M))", "import sys\ninput = sys.stdin.readline\n\nmod = 998244353 #\u51fa\u529b\u306e\u5236\u9650\n#\u4e92\u3044\u306b\u7d20\u306aa,b\u306b\u3064\u3044\u3066\u3001a*x+b*y=1\u306e\u4e00\u3064\u306e\u89e3\ndef extgcd(a,b):\n    r = [1,0,a]\n    w = [0,1,b]\n    while w[2]!=1:\n        q = r[2]//w[2]\n        r2 = w\n        w2 = [r[0]-q*w[0],r[1]-q*w[1],r[2]-q*w[2]]\n        r = r2\n        w = w2\n    #[x,y]\n    return [w[0],w[1]]\n\n# a\u306e\u9006\u5143(mod m)\u3092\u6c42\u3081\u308b\u3002(a\u3068m\u306f\u4e92\u3044\u306b\u7d20\u3067\u3042\u308b\u3053\u3068\u304c\u524d\u63d0)\ndef mod_inv(a,m=mod):\n    x = extgcd(a,m)[0]\n    return (m+x%m)%m\n\nN = int(input())\nA = list(map(int, input().split()))\n\nK = 0\nP = 0\nQ = 1\nfor i, a in enumerate(A):\n    p0 = a * mod_inv(100) % mod\n    q0 = (100-a) * mod_inv(100) % mod\n\n    P = (P + (i+1)*Q*q0) % mod\n    K = (K + Q*q0) % mod\n    Q = Q * p0 % mod\n\ninv = (mod + 1 - K) % mod\nw = (N*Q + P) % mod\nans = w * mod_inv(inv) % mod\nprint(ans)", "M = 998244353\n \nn = int(input())\n \nexp = 0\nfor pi in map(int,input().split()):\n    exp = (exp+1) * 100 * pow(pi,M-2,M) % M\n \nprint(exp)", "n=input()\nn=int(n)\nmd=998244353\nL=list(map(int,input().split()))\ndef inv(x):\n    nonlocal md\n    return pow(x,md-2,md)\nml=1\nans=0\nfor el in reversed(L):\n    ml*=100\n    ml*=inv(el)\n    ml%=md\n    ans+=ml\n    ans%=md\nprint(ans)\n", "M = 998244353 \nn=input()\np=list(map(int, input().split(' ')))\nnum=0\ndenum=1\nfor i in p:\n    num=(num+denum)*100%M\n    denum=denum*i%M\n#print(num, denum)\nfrom math import gcd\ng=gcd(num,denum)\nnum=num//g\ndenum=denum//g\ndenum=pow(denum,M-2,M)\nprint(num*denum%M)\n", "MOD =  998244353\n\ndef power(x,y):\n    res=1\n    while(y>0):\n        if(y&1):\n            res = x*res%MOD\n        y = y >>1\n        x = x*x%MOD\n    return res\n\n\n\nn = int(input())\n\n\n\nprob = input().split()\n\n\np = power(100,n)\nq = 1\n\nfor i in range(0,n-1):\n    q = q*(int(prob[i]))%MOD\n    p = (p + q*(power(100,n-i-1))%MOD)%MOD\nq = q*(int(prob[n-1]))%MOD\n\nprint(p*(power(q,MOD-2))%MOD)", "from sys import stdin\n\ninput = stdin.readline\n\nmod = 998244353\n\ninv = [0] * 103\ninv[1] = 1\nfor i in range(2, 101):\n    inv[i] = (mod - mod // i) * inv[mod % i] % mod\n\nn = int(input())\n\nh = [0] * (n+3)\nh[0] = 1\nfor i in range(1, n+2):\n    h[i] = h[i-1]*100 % mod\n\n\np = list(map(int, input().split()))\ntot = 1 * h[n] % mod\nnow = 1\niv = 1\nfor i in range(n):\n    if i == n-1:\n        iv = iv*inv[p[i]] % mod\n        continue\n    now = now*p[i] % mod\n    tot += now * h[n-i-1] % mod\n    tot %= mod\n    iv = iv*inv[p[i]] % mod\n\nprint(tot*iv % mod)\n\n\n\n"]
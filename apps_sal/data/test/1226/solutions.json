["def comb_mod(n,r):\n    mod = 10**9+7\n    ans = 1\n    for i in range(r):\n        ans *= n-i\n        ans %= mod\n    for i in range(1,r+1):\n        ans *= pow(i,mod-2,mod)\n        ans %= mod\n    return ans\n\ndef solve():\n    n, a, b = list(map(int, input().split()))\n    mod = 10**9+7\n    ans = pow(2,n,mod)-comb_mod(n,a)-comb_mod(n,b)-1\n    ans %= mod\n    return ans\nprint((solve()))\n", "n, a, b = map(int, input().split())\nmod = 10**9+7\n\nx = 1\nd = [2]\nm = n\nfor i in range(30):\n    if m&1:\n        x *= d[-1]\n        x %= mod\n    m >>= 1\n    d.append(d[-1]**2%mod)\n\nl = n\ninverse = [0, 1]\ng = [1, 1]\nfor i in range(2, 4**9):\n    if i == a+1:\n        x -= l*g[-1]%mod\n    if i == b+1:\n        x -= l*g[-1]%mod\n        break\n    l *= n-i+1\n    l %= mod\n    inverse.append((-inverse[mod%i]*(mod//i))%mod)\n    g.append(g[-1]*inverse[-1]%mod)\n\nprint((x-1)%mod)", "def main():\n    #input data\n    import sys\n    input = lambda:sys.stdin.readline().strip()\n    \n    N,A,B = map(int,input().split())\n    mod=10**9+7\n    #solve\n    #\u4e8c\u9805\u4fc2\u6570\u306e\u548c=2**n\n    #2**n-1-nCa-nCb\n    def cmb(n, r, mod=10**9+7):\n        r = min(r, n-r)\n        res = 1\n        for i in range(r):\n            res = res * (n - i) * pow(i+1, mod-2, mod) % mod\n        return res\n                \n    ans = pow(2,N,mod)-1-cmb(N,A,mod)-cmb(N,B,mod)\n    print(ans%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "n,a,b = map(int,input().split())\n#sousuu = (2**n -1)%(10**9+7)\n\ndef cmb(n, r, mod):\n    inv = [0,1]\n    for i in range(2, r + 1):\n        inv.append((-inv[mod % i] * (mod // i)) % mod)\n    cmd = 1\n    for i in range(1,min(r,n-r)+1):\n        cmd = (cmd*(n-i+1)*inv[i])%mod\n    return cmd\n\nexceptA = cmb(n,a,10**9+7)\nexceptB = cmb(n,b,10**9+7)\n\n#print((sousuu-exceptA-exceptB)%(10**9+7))\n\n#\u7e70\u308a\u8fd4\u30572\u4e57\u6cd5\ndef modPow(a,n,mod):\n    if n==0:\n        return 1\n    if n==1:\n        return a%mod\n    if n % 2 == 1:\n        return (a*modPow(a,n-1,mod)) % mod\n    t = modPow(a,n/2,mod)\n    return (t*t)%mod\n\nprint((modPow(2,n,10**9+7)-1-exceptA-exceptB)%(10**9+7))", "def calc_pow(x, y):\n    if y == 0:\n        return 1\n\n    else:\n        ans = calc_pow(x, y//2)**2\n\n        if y%2:\n            ans *= x\n        \n        return ans % 1000000007\n\ndef calc_X(c):\n    X = 1\n    k = n\n    for i in range(c):\n        X = (X * k) % 1000000007\n        k = k-1\n\n    return X\n\ndef calc_Y(c):\n    Y = 1\n    for i in range(1, c+1):\n        Y = (Y * i) % 1000000007\n\n    return Y\n\nn, a, b = list(map(int, input().split()))\n\nans = calc_pow(2, n) - 1\n\nXYa = (calc_X(a) * calc_pow(calc_Y(a), 1000000005)) % 1000000007\nXYb = (calc_X(b) * calc_pow(calc_Y(b), 1000000005)) % 1000000007\n\nans = (ans - XYa - XYb) % 1000000007\nprint(ans)\n", "n,a,b=list(map(int,input().split()))\nmod=10**9+7\nfactna=[n]\nfactnb=[n]\nfacta=[a]\nfactb=[b]\nfor i in range(1,a):\n  factna.append(factna[-1]*(n-i)%mod)\n  facta.append(facta[-1]*(a-i)%mod)\nfor i in range(1,b):\n  factnb.append(factnb[-1]*(n-i)%mod)\n  factb.append(factb[-1]*(b-i)%mod)\ndef pow(x,n):\n  a=1\n  while(n>0):\n    if n%2==1:\n      a*=x%mod\n    x*=x%mod\n    n>>=1\n  return a\nprint(((pow(2,n)-1-factna[-1]*pow(facta[-1],mod-2)%mod-factnb[-1]*pow(factb[-1],mod-2)%mod)%mod))\n", "#\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\n#\u7e70\u308a\u8fd4\u30572\u4e57\u6cd5\n\nn, a, b = map(int,input().split())\nmod = pow(10, 9) + 7\ns = pow(2, n, mod) - 1\nx = 1\ny = 1\nfor i in range(1, b+1):\n  x = x * (n-i+1) % mod\n  y = y * i % mod\n  if i == a or i == b:\n    s -= x * pow(y, mod - 2, mod)\n\nprint(s % mod)", "n,a,b = map(int, input().split())\nmod = 10**9+7\n\ndef cmb(n,r):\n    a,b = 1,1\n    for i in range(r):\n        a = a * (n-i) % mod\n        b = b * (i+1) % mod\n    return a * pow(b, mod-2, mod) %mod\n\nprint((pow(2, n, mod) - cmb(n,a) - cmb(n,b) - 1)%mod)", "n, a, b = map(int, input().split())\nmod = pow(10, 9) + 7\ntotal = pow(2, n, mod)\n#print(total)\ndef comb(m, x):\n  numerator = 1\n  for i in range(m - x + 1, m + 1):\n    numerator = numerator * i % mod\n  denominator = 1\n  for i in range(1, x + 1):\n    denominator = denominator * i % mod\n  d = pow(denominator, mod - 2, mod)\n  return numerator * d\na = comb(n, a)\nb = comb(n, b)\nprint((total - a - b - 1) % mod)", "#!/usr/bin/env python3\ndef main():\n    from math import factorial\n\n    def calc(x):\n        ret = 1\n        for i in range(x):\n            ret = ret * (n - i) % mod\n        return ret * pow(factorial(x), mod - 2, mod) % mod\n\n    n, a, b = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n\n    print((max(0, (pow(2, n, mod) - ((calc(a) + calc(b)) % mod) - 1) % mod)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def calc_pow(x, y):\n    if y == 0:\n        return 1\n\n    else:\n        ans = calc_pow(x, y//2)**2\n\n        if y%2:\n            ans *= x\n        \n        return ans % 1000000007\n\n\ndef calc_combination(n, r, p):\n    fact = 1\n    factinv = 1\n\n    r = min(r, n-r)\n\n    for i in range(r):\n        fact = (fact * (n - i)) % p\n        factinv = (factinv * (i + 1)) % p\n\n    ans = (fact * calc_pow(factinv, p-2)) % p\n\n    return ans\n\nn, a, b = map(int, input().split())\np = 10**9 + 7\n\n\nans = (calc_pow(2, n) - calc_combination(n, a, p) - calc_combination(n, b, p) - 1) % p\n\nprint(ans)", "m = 10**9+7\nn,a,b = map(int,input().split())\ndef c(k):\n  v = 1\n  w = 1\n  for i in range(k):\n    v = v*(n-i)%m #n*(n-1)*...*(n-k+1) \u5206\u5b50\n    w = w*(i+1)%m #1*2*...*k \u5206\u6bcd\n  #pow(w,m-2,m)\u306fmod m\u306e\u4e16\u754c\u3067\u306ew\u306e\u9006\u5143\n  return (v*pow(w,m-2,m)%m)\nprint((pow(2,n,m)-1-c(a)-c(b))%m)", "n,a,b=map(int,input().split())\nm=10**9+7\nALL=pow(2,n,m)-1\nx=y=1\n\nfor i in range(b):\n    x=x*(i+1)%m\n    y=y*(n-i)%m\n    if i+1==a:\n        a=b\n        ALL-=y*pow(x,m-2,m)\n\nprint(ALL%m)", "#!/usr/bin/env python3\nfrom functools import reduce\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, m):\n    def mul(a, b):\n        return a * b % m\n\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1, r + 1)))\n    return over * pow(under, m - 2, m)\n\n\nn, a, b = list(map(int, input().split()))\nprint(((pow(2, n, mod) - 1 - cmb(n, a, mod) - cmb(n, b, mod)) % mod))\n", "def modinv(a, m):\n    b = m\n    u = 1\n    v = 0\n    while b:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u %= m\n    if u < 0:\n        u += m\n    return u\n\ndef nCk(N, k, mod):\n    ret_val = 1\n    for i in range(k):\n        ret_val *= (N - i)\n        ret_val %= mod\n        ret_val *= modinv(i + 1, mod)\n        ret_val %= mod\n    return ret_val\n\n\nn, a, b = map(int, input().split())\nMOD = 10 ** 9 + 7\nall_cnt = pow(2, n, MOD) - 1\na_cnt = nCk(n, a, MOD)\nb_cnt = nCk(n, b, MOD)\nans = all_cnt - a_cnt - b_cnt\nprint(ans % MOD)", "\"\"\"\n\u7e70\u308a\u8fd4\u30572\u4e57\u6cd5\n\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\n\"\"\"\n\nn, a, b = list(map(int, input().split()))\nMOD = (10**9) + 7\n\ndef cal(n, a):\n    r = n\n    sub = 1\n    while a > 1:\n        if a % 2 == 1:\n            a -= 1\n            sub = (sub * r) % MOD\n        r = (r * r) % MOD\n        a /= 2\n    return r*sub%MOD\n        \n\ndef felmer(n,a,b):\n    r = [0,0]\n    ni = n\n    ab = 1\n    for i in range(1,max(a,b)+1):\n        ab = ab * i % MOD\n        if i == a:\n            r[0] = (ni * cal(ab, MOD-2)) % MOD\n        elif i == b:\n            r[1] = (ni * cal(ab, MOD-2)) % MOD\n        ni = ni * (n-i) % MOD\n    return r\n    \n    \nallNumber = cal(2, n)\nnCa, nCb = felmer(n, a, b)\nans = allNumber - 1 - nCa - nCb\nans %= MOD\nif ans < 0:\n    ans += MOD\nprint(ans)\n", "MOD = 1_000_000_007\n\n\ndef mod_pow(x, n):\n    ret = 1\n    while n > 0:\n        if n & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return ret\n\n\nn, a, b = [int(x) for x in input().split()]\n\nans = mod_pow(2, n) - 1\n\nxa = n\nfor i in range(n - 1, n - a, -1):\n    xa = xa * i % MOD\nya = a\nfor i in range(a - 1, 0, -1):\n    ya = ya * i % MOD\n\nxb = n\nfor i in range(n - 1, n - b, -1):\n    xb = xb * i % MOD\nyb = b\nfor i in range(b - 1, 0, -1):\n    yb = yb * i % MOD\n\nca = xa * mod_pow(ya, MOD - 2) % MOD\ncb = xb * mod_pow(yb, MOD - 2) % MOD\nans = (ans + MOD * 2 - ca - cb) % MOD\nprint(ans)\n", "def comb_mod(n,r):\n    mod = 10**9+7\n    ans = 1\n    for i in range(r):\n        ans *= n-i\n        ans %= mod\n    for i in range(1,r+1):\n        ans *= pow(i,-1,mod)\n        ans %= mod\n    return ans\n\ndef solve():\n    n, a, b = map(int, input().split())\n    mod = 10**9+7\n    ans = pow(2,n,mod)-comb_mod(n,a)-comb_mod(n,b)-1\n    ans %= mod\n    return ans\nprint(solve())", "n,a,b=map(int,input().split())\nm=10**9+7\nALL=pow(2,n,m)-1\nx=y=1\n \nfor i in range(b):\n    x=x*(i+1)%m\n    y=y*(n-i)%m\n    if i+1==a:\n        a=b\n        ALL-=y*pow(x,m-2,m)\n \nprint(ALL%m)", "# D - Bouquet\nn,a,b = map(int,input().split())\nMOD = 10**9+7\n\nans = pow(2,n,MOD)-1\na,b = min(a,b),max(a,b)\n\ntmp = 1\nfor i in range(1,a+1):\n    tmp = tmp*(n+1-i)*pow(i,-1,MOD)\n    tmp %= MOD\nans = (ans-tmp)%MOD\nfor i in range(a+1,b+1):\n    tmp = tmp*(n+1-i)*pow(i,-1,MOD)\n    tmp %= MOD\nans = (ans-tmp)%MOD\n\nprint(ans)", "def main():\n    #input data\n    import sys\n    input = lambda:sys.stdin.readline().strip()\n    \n    N,A,B = map(int,input().split())\n    mod=10**9+7\n    #solve\n    #\u4e8c\u9805\u4fc2\u6570\u306e\u548c=2**n\n    #2**n-1-nCa-nCb\n    \n    def cmb(n, r, mod=10**9+7):\n        c = 1\n        m = 1\n        r = min(n - r, r)\n        for i in range(r):\n            c = c * (n - i) % mod\n            m = m * (i + 1) % mod\n        return c * pow(m, mod - 2, mod) % mod\n                \n    ans = pow(2,N,mod)-1-cmb(N,A,mod)-cmb(N,B,mod)\n    print(ans%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "#\u5168\u4f53\u306e\u901a\u308a\u6570\u304c\u30012^(N) \u901a\u308a\uff08\u5168\u3066\u306e\u82b1\u3092\u300c\u9078\u3076\u300d\u300c\u9078\u3070\u306a\u3044\u300d\u306e\uff12\u629e\uff09\n#\u3057\u305f\u304c\u3063\u3066\u3001\u6c42\u3081\u308b\u5024\u306f\u30002^(N) - 1 - nCa - nCb\n#\uff08\u5168\u4f53\u304b\u3089\uff10\u672c\u30fba\u672c\u30fbb\u672c\u306e\u6642\u3092\u5f15\u304f\uff09\n\n\n#\u5168\u4f53\u306e\u901a\u308a\u6570 2^(N)\u3092\u3088\u308a\u65e9\u304f\u56de\u3059\u95a2\u6570\ndef calc_pow(x, y):\n    if y == 0:\n        return 1\n\n    else:\n        ans = calc_pow(x, y//2)**2\n\n        if y%2:\n            ans *= x\n        \n        return ans % 1000000007\n\n\n\n#nCa\u3001nCb\u3092\u6c42\u3081\u308b\u95a2\u6570\ndef calc_combination(n,r,p):\n    fact = 1\n    factinv = 1\n    r = min(r,n-r)\n\n    for i in range(r):\n        fact = (fact * (n-i)) % p\n        factinv = (factinv * (i+1)) % p\n    \n    ans = (fact * calc_pow(factinv,p-2)) % p\n\n    return ans\n\nn,a,b = list(map(int,input().split()))\np = 10**9 + 7\nans = (calc_pow(2,n) - calc_combination(n,a,p) - calc_combination(n,b,p)- 1 )%p\n\nprint(ans)\n\n\n \n\n\n\n\n", "import sys\n\nN_MAX = 200000 + 5\nINF = 10**9 + 7\nsys.setrecursionlimit(N_MAX)\nMOD = 10**9 + 7\n\n# ## COMBINATION (MOD) ## #\nMOD = 10**9 + 7  # , N = 2*10**5 \u3067 0.3s\nN_MAX = 2 * 10**5  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\n\nfac = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\nfacinv = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 1):\n    fac.append((fac[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    facinv.append((facinv[-1] * inv[-1]) % MOD)\n\n\ndef fac(n, a):\n    ans = 1\n    for i in range(a):\n        ans *= n\n        ans %= MOD\n        n -= 1\n    return ans\n\n\ndef cmb(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[r] * facinv[n - r] % MOD\n\n\ndef main():\n    n, a, b = map(int, sys.stdin.readline().rstrip().split())\n\n    # \u5168\u7a2e\u985e\n    ans = pow(2, n, MOD) - 1  # -1 : \u5168\u90e8\u9078\u3070\u306a\u3044\u5834\u5408\n    ans %= MOD\n\n    # a\u7a2e\u985e\u306b\u306a\u308b\u5834\u5408\n    ans -= fac(n, a) * facinv[a]\n    ans %= MOD\n\n    ans -= fac(n, b) * facinv[b]\n    ans %= MOD\n\n    print(ans)\n\n\nmain()", "n, a, b = list(map(int, input().split()))\nM = 10**9+7\n\ndef combination(n, k):\n  if k > n-k:\n    k = n-k\n  if k==0:\n    return 1\n  if k==1:\n    return n\n  p = [-1 for i in range(k+1)]\n  kp = {i:[] for i in range(n-k+1, n+1)}\n  count = [0 for i in range(k+1)]\n  for i in range(2, k+1):\n    if p[i]==-1:\n      for j in range(i, k+1, i):\n        if p[j] == -1:\n          p[j] = i\n      for j in range(((n-k)//i+1)*i, n+1, i):\n        kp[j].append(i)\n  for i in range(2, k+1):\n    j = i\n    while p[j] != -1:\n      m = p[j]\n      while j%m==0:\n        count[m] += 1\n        j = j//m\n  #print(p)\n  #print(count)\n  ans = 1\n  for i in kp:\n    bufi = i\n    for j in kp[i]:\n      while count[j]>0 and bufi%j == 0:\n        bufi = bufi//j\n        count[j] -= 1\n    #print(i, bufi)\n    ans *= bufi\n    ans %= M\n\n  #print(kp)\n  return ans\n  \nprint(((pow(2,n,M)-1-combination(n, a)-combination(n, b))%M))\n", "n, a, b = map(int, input().split())\nmod = 10**9+7\nans = pow(2, n, mod)-1\nx, y = 1, 1\nfor i in range(a):\n    x *= n-i\n    y *= i+1\n    x, y = x%mod, y%mod\nans -= (x*pow(y, mod-2, mod))%mod\nx, y = 1, 1\nfor i in range(b):\n    x *= n-i\n    y *= i+1\n    x, y = x%mod, y%mod\nans -= (x*pow(y, mod-2, mod))%mod\nprint(ans%mod)", "n,a,b=list(map(int,input().split()))\n#2^n-nCa-nCb\u3092\u6c42\u3081\u308b\n#\u51aa\u4e57\u3092\u6c42\u3081\u308b\u95a2\u6570\u3092\u6c42\u3081\u308b\n#2\u306en\u4e57\u3092m\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3092\u6c42\u3081\u308b\ndef pow(a,n,m):\n  if n==0:\n    return 1\n  else:\n    k=pow(a*a%m,n//2,m)\n    if n%2==1:\n      k=k*a%m\n    return k\n#\u6b21\u306f\u7d44\u307f\u5408\u308f\u305b\u3092\u8a08\u7b97\u3059\u308b\n#\u307e\u305a\u306f\u524d\u51e6\u7406\u3092\u3059\u308b\ninv=[0 for i in range(200001)]\nfinv=[0 for i in range(200001)]\ninv[1]=1\nfinv[1]=1\nfor i in range(2,200001):\n  #\u9006\u5143\u306e\u6c42\u3081\u65b9p=(p//a)*a+p%a a^(-1)=-(p//a)*(p%a)^(-1)\n  inv[i]=(-(1000000007//i)*inv[1000000007%i])%1000000007\n  finv[i]=finv[i-1]*inv[i]%1000000007\n\n#n\u304c10^7\u7a0b\u5ea6\u3067\u3042\u308c\u3070nCk=n!*(k!)*((n-k)!)\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\n#n\u304c\u305d\u308c\u3088\u308a\u5927\u304d\u3044\u6642\u306f\u9593\u306b\u5408\u308f\u306a\u3044\u3002\u3053\u3053\u3067k\u304c\u5c0f\u3055\u3044\u3053\u3068\u306b\u7740\u76ee\u3059\u308b\u3068\n#nCk=n*(n-1).....*(n-k+1)*(k!)^(-1)\u3067\u6c42\u3081\u3089\u308c\u308b\u3053\u3068\u304c\u308f\u304b\u308b\na_num=1\nb_num=1\nfor i in range(n-a+1,n+1):\n  a_num=i*a_num%1000000007\nfor i in range(n-b+1,n+1):\n  b_num=i*b_num%1000000007\nprint(((pow(2,n,1000000007)-1-a_num*finv[a]-b_num*finv[b])%1000000007))\n\n  \n\n\n\n\n\n\n\n\n\n\n\n", "def main():\n    n, a, b = list(map(int, input().split()))\n    mod = 10 ** 9 + 7 #\u7d20\u6570\n    \n    def modpow(x, n, mod):\n        res = 1\n        while n:\n            if n % 2:\n                res *= x % mod\n            x *= x % mod\n            n >>= 1\n        return res\n    \n    def cmb(n, r, mod):\n        # \u5206\u5b50(n*(n-1)*...*(n-r+1))\n        nume = 1\n        for i in range(n-r+1, n+1):\n            nume = nume * i % mod\n        # \u5206\u6bcd\uff081*2*...*r\uff09\n        deno = 1\n        for j in range(1, r+1):\n            deno = deno * j % mod\n        d = modpow(deno, mod-2, mod)\n        return nume * d % mod\n    \n    all_cmb = pow(2, n, mod) - 1\n    bad_a = cmb(n, a, mod)\n    bad_b = cmb(n, b, mod)    \n    print(((all_cmb-bad_a-bad_b) % mod))\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "n, a, b = map(int, input().split())\n\nMOD = 10**9 + 7\n\nfact = [1, 1]\nfactn = [1, n % MOD]\nfor i in range(2, b + 1):\n    factn.append((factn[-1] * (n - i + 1)) % MOD)\n    fact.append((fact[-1] * i) % MOD)\n\nnca = (factn[a] * pow(fact[a], MOD-2, MOD)) % MOD\nncb = (factn[b] * pow(fact[b], MOD-2, MOD)) % MOD\nans = (pow(2,  n , MOD) - 1 - nca - ncb) % MOD\nif ans < 0: ans += MOD\nprint(ans)", "n, a, b = list(map(int, input().split()))\nmod = 10**9+7\n\ndef nCk(n, k):\n    a = 1\n    for i in range(n, n-k, -1):\n        a *= i\n        a %= mod\n    b = 1\n    for i in range(1, k+1):\n        b *= i\n        b %= mod\n    a *= pow(b, mod-2, mod)\n    return a\n\nans = pow(2, n, mod)-1\nans -= nCk(n, a)+nCk(n, b)\nprint((ans%mod))\n", "n,a,b = map(int,input().split())\np = 10**9 + 7\ndef CC(n,k):\n  X,Y = 1,1\n  for i in range(n-k+1,n+1):\n    X = X*i%p\n  for j in range(1,k+1):\n    Y = Y*j%p\n  YY = pow(Y,p-2,p)\n  return(X*YY%p)\nA = CC(n,a)\nB = CC(n,b)\nALL = pow(2,n,p)\nans = (ALL-1-A-B)%p\nprint(ans)", "def calc_comb(n,r):\n    numerator=1\n    for i in range(n-r+1,n+1):\n        numerator=(numerator*i)%mod\n    denominator=1\n    for i in range(1,r+1):\n        denominator=(denominator*i)%mod\n    return (numerator*pow(denominator,mod-2,mod))%mod\nn,a,b=list(map(int,input().split()))\nmod=1000000007\nprint(((pow(2,n,mod)-1-calc_comb(n,a)-calc_comb(n,b)+mod)%mod))\n\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nn,a,b = list(map(int, input().split()))\n\n\n# In[2]:\n\n\ndef nCk(n, k, mod):\n    a = 1\n    for i in range(n, n-k, -1):\n        a *= i\n        a %= mod\n    b = 1\n    for i in range(1, k+1):\n        b *= i\n        b %= mod\n    a *= pow(b, mod-2, mod)\n    return a\n\n\n# In[3]:\n\n\nmod = 10**9+7\nans = pow(2, n, mod)-1\nans -= nCk(n, a, mod) + nCk(n, b, mod)\nprint((ans%mod))\n\n\n# In[ ]:\n\n\n\n\n", "n,a,b=map(int,input().split())\n\nmod=10**9+7\ndef modpow(a,n):\n    if n<1:\n        return 1\n    ans=modpow(a,n//2)\n    ans=(ans*ans)%mod\n    if n%2==1:\n        ans*=a\n    return ans%mod\n    \ndef cmb(n,i):#\u9006\u5143\n    inv,ans=1,1\n    for j in range(1,i+1):\n        ans=ans*(n-j+1)%mod\n        inv=inv*j%mod\n    return (ans*modpow(inv,mod-2))%mod\n\n\n\nans_n=pow(2,n,mod)-1\nans_a=cmb(n,a)%mod\nans_b=cmb(n,b)%mod\n\nprint((ans_n-ans_a-ans_b)%mod)", "def solve():\n    def combis(n, k, mod):\n        from math import factorial\n        numerator = 1\n        denominator = 1\n        for i in range(k):\n            numerator = numerator * (n-i) % mod\n            denominator = denominator * (i+1) % mod\n        return numerator * pow(denominator, mod-2, mod) % mod\n\n    n,a,b = [int(i) for i in input().split()]\n    mod = 10**9 + 7\n    ans = pow(2, n, mod) - 1 - combis(n, a, mod) - combis(n, b, mod)\n    print(ans % mod)\n\ndef __starting_point():\n    solve()\n__starting_point()", "n,a,b=map(int,input().split())\nmod=10**9+7\nans=pow(2,n,mod)-1\na=min(a,n-a)\nb=min(b,n-b)\nc=min(a,b)\nx,y=1,1\nfor i in range(1,c+1):\n  x=x*(n+1-i)%mod\n  y=y*i%mod\nans-=x*pow(y,mod-2,mod)%mod\nfor i in range(c+1,max(a,b)+1):\n  x=x*(n+1-i)%mod\n  y=y*i%mod\nans-=x*pow(y,mod-2,mod)%mod\nprint(ans%mod)", "k = 2 *10**5\nmod = 10**9+7\n\nn, a, b = map(int,input().split())\n\nmodinv_table = [-1]*(k+1)\nfor i in range(1,k+1):\n    modinv_table[i] = pow(i,-1,mod)\n\ndef binomial_coefficients(n,k):\n    ans = 1\n    for i in range(k):\n        ans *= n-i\n        ans *= modinv_table[i+1]\n        ans %= mod\n    return ans\nprint((pow(2,n,mod)-binomial_coefficients(n,a)-binomial_coefficients(n,b)-1)%mod)", "def nCk(n, k, mod):\n    nu = 1\n    de = 1 \n    for i in range(1, k+1):\n        nu *= (n-i+1)\n        de *= i\n        nu = nu % mod\n        de = de % mod\n    ans = nu * pow(de, mod-2, mod) % mod\n    return ans\n\nn, a, b = map(int, input().split())\nmod = 10**9+7\nans = (pow(2, n, mod) - 1 - nCk(n, a, mod) - nCk(n, b, mod)) % mod\nprint(ans)", "def main():\n    #input data\n    import sys\n    input = lambda:sys.stdin.readline().strip()\n    \n    N,A,B = map(int,input().split())\n    mod=10**9+7\n    #solve\n    #\u4e8c\u9805\u4fc2\u6570\u306e\u548c=2**n\n    #2**n-1-nCa-nCb\n    def pow(x, y, mod):\n        res = 1\n        if y > 0:\n            res = pow(x, y // 2, mod)\n            if y % 2 == 0:\n                res = (res * res) % mod\n            else:\n                res = (((res * res) % mod) * x) % mod\n        return res\n        \n    def cmb(n, r, mod=10**9+7):\n        c = 1\n        m = 1\n        r = min(n - r, r)\n        for i in range(r):\n            c = c * (n - i) % mod\n            m = m * (i + 1) % mod\n        return c * pow(m, mod - 2, mod) % mod\n                \n    ans = pow(2,N,mod)-1-cmb(N,A,mod)-cmb(N,B,mod)\n    print(ans%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "n, a, b = map(int,input().split())\nmod = pow(10, 9) + 7\ns, x, y = pow(2, n, mod) - 1, 1, 1\nfor i in range(1, b+1):\n  x, y = x * (n-i+1) % mod, y * i % mod\n  if i == a or i == b: s -= x * pow(y, mod - 2, mod)\nprint(s % mod)", "n,a,b=list(map(int,input().split()))\nmod=10**9+7\nsum=(pow(2,n,mod)-1)%mod\nnume_a=1\ndeno_a=1\nfor i in range(n-a+1,n+1):\n    nume_a=(nume_a*(i%mod))%mod\n    deno_a=(deno_a*(i-(n-a+1)+1)%mod)%mod\nans_a=(nume_a*(pow(deno_a,mod-2,mod)))%mod\nnume_b=1\ndeno_b=1\nfor i in range(n-b+1,n+1):\n    nume_b=(nume_b*(i%mod))%mod\n    deno_b=(deno_b*(i-(n-b+1)+1)%mod)%mod\nans_b=(nume_b*(pow(deno_b,mod-2,mod)))%mod\nprint(((sum-ans_a-ans_b)%mod))\n", "n, a, b = map(int,input().split())\nM = 10**9+7\nAnswer = pow(2,n,M)-1\nfactorial=1\nfor i in range(1,a+1):\n    factorial = (factorial*(n+1-i)*pow(i,M-2,M))%M\nAnswer -= factorial%M\nfactorial =1\nfor j in range(1,b+1):\n    factorial = (factorial*(n+1-j)*pow(j,M-2,M))%M\nAnswer -= factorial%M\nAnswer = Answer%M\nprint(Answer)", "n, a, b = map(int, input().split())\n\ndef nCr(n, r):\n    r = min(r, n-r)\n    num, den = 1, 1\n    for i in range(r):\n        num = (num * (n-i)) % mod\n        den = (den * pow(i+1, mod-2, mod)) % mod\n    return num * den % mod\n\nmod = 10**9 + 7\nprint((pow(2, n, mod) - nCr(n, a) - nCr(n, b) - 1) % mod)", "n, a, b = list(map(int, input().split()))\nmod = pow(10, 9) + 7\n\n\ndef comb(N, x):\n    numerator = 1\n    for i in range(N-x+1, N+1):\n        numerator = numerator * i % mod\n    denominator = 1\n    for j in range(1, x+1):\n        denominator = denominator * j % mod\n    d = pow(denominator, mod-2, mod)\n    return numerator * d % mod\n\n\na = comb(n, a)\nb = comb(n, b)\n\nprint(((pow(2, n, mod) - 1 - a - b) % mod))\n", "#!/usr/bin/env python3\nfrom functools import reduce\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r, m):\n    mul = lambda a,b: a*b%m\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    over = reduce(mul, list(range(n, n - r, -1)))\n    under = reduce(mul, list(range(1, r + 1)))\n    return over * pow(under, mod - 2, mod)\n\n\nn, a, b = list(map(int, input().split()))\nprint(((pow(2, n, mod) - 1 - cmb(n, a, mod) - cmb(n, b, mod)) % mod))\n", "n,a,b=list(map(int,input().split()))\n#2^n-nCa-nCb\u3092\u6c42\u3081\u308c\u3070\u3044\u3044\u3002\u305f\u3060\u3057100000007\u3067\u5272\u3063\u305f\u3042\u307e\u308a\u3067\u306a\u304f\u3066\u306f\u306a\u3089\u306a\u3044\n#\u307e\u305a\u306f2^n\u3092\u6c42\u3081\u308b\ndef pow(x,n,m):\n  if n==0:\n    return 1\n  res=pow(x*x%m,n//2,m)\n  if n%2==1:\n    res=res*x%m\n  return res\n\n#\u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\u3092\u6c42\u3081\u308b\nc=max(a,b)\ninv=[0 for i in range(c+1)]\nfinv=[0 for i in range(c+1)]\ninv[1]=1\nfinv[0]=finv[1]=1\nfor i in range(2,c+1):\n  #i\u306e\u9006\u6570\u3092\u6c42\u3081\u308b\u3002\n  #mod\u3000p=1000000007\u306e\u4e16\u754c\u3067\u9006\u5143\u3092\u6c42\u3081\u308b\n  #p=(p//a)*a+(p%a)\n  #mod p\u3092\u3068\u308b\u3068 a=-(p//a)*(p%a)^-1\n  inv[i]=1000000007-(1000000007//i)*inv[1000000007%i]%1000000007\n  finv[i]=finv[i-1]*inv[i]%1000000007\ndef kaizyou(k):\n  num=1\n  for i in range(n-k+1,n+1):\n    num=num*i%1000000007\n  return num\n\ndef combinations(k):\n  return kaizyou(k)*finv[k]%1000000007\n\nprint(((pow(2,n,1000000007)-combinations(a)-combinations(b)-1)%1000000007))\n\n  \n  \n  \n", "from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush\nfrom bisect import bisect_left,bisect_right \nimport sys,math,itertools,fractions\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nn,a,b = inpl()\ndl = 1\nfor i in range(a):\n    dl *= n-i\n    dl %= mod\nfor i in range(a):\n    dl *= pow(a-i,mod-2,mod)\n    dl %= mod\n# print(dl)\nvv = 1\nfor i in range(b):\n    vv *= n-i\n    vv %= mod\nfor i in range(b):\n    vv *= pow(b-i,mod-2,mod)\n    vv %= mod\n# print(vv)\nres = pow(2,n,mod) - dl - vv - 1\nprint(res%mod)", "def ncr(n, r, p):\n    num = 1\n    den = 1\n\n    for i in range(r):\n        num = (num*(n-i)) % p\n        den = (den*(i+1)) % p\n\n    return (num*pow(den, p-2, p)) % p\n\nn, a, b = list(map(int, input().split()))\n\nm = 1000000007\nprint((pow(2, n, m) - 1 - ncr(n, a, m) - ncr(n, b, m)) % m)", "# nCr mod m\n# r\u304cn/2\u306b\u8fd1\u3044\u3068\u975e\u5e38\u306b\u91cd\u304f\u306a\u308b\ndef combination(n, r, mod=10**9+7):\n    n1, r = n+1, min(r, n-r)\n    numer = denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n1-i) % mod\n        denom = denom * i % mod\n    return numer * pow(denom, mod-2, mod) % mod\n\nmod = 10**9+7\nN, A, B = list(map(int, input().split()))\nans = pow(2, N, mod) - 1 - combination(N, A) - combination(N, B)\nans %= mod\nprint(ans)\n", "n, a, b = list(map(int, input().split()))\n# \u5168\u901a\u308a - nCa - nCb\nmod = 10 ** 9 + 7\n\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\n# n ~ n - k + 1\n\n\ndef c(n, k):\n    res = 1\n    for i in range(0, k):\n        res = res * (n - i) * inv(i + 1) % mod\n    return res\n\n\nprint((((pow(2, n, mod) - c(n, a) - c(n, b) - 1) % mod + mod) % mod))\n", "def egcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = egcd(b % a, a)\n        return g, x - (b // a) * y, y\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\ndef combination(n, r, mod=10**9+7):\n    r = min(r, n-r)\n    res = 1\n    for i in range(r):\n        res = res * (n - i) * modinv(i+1, mod) % mod\n    return res\n\n\ndef power_func(a,n,p):\n    bi = str(format(n,\"b\"))#2\u9032\u8868\u73fe\u306b\n    res = 1\n    for i in range(len(bi)):\n        res = (res*res) %p\n        if bi[i] == \"1\":\n            res = (res*a) %p\n    return res\n\n\n\nn,a,b=[int(i) for i in input().split()]\nmod=10**9+7\n\nprint(((power_func(2,n,mod)-1-combination(n, a, mod)-combination(n, b, mod))%mod))\n", "import functools\nimport operator\n\nn, a, b = list(map(int, input().split()))\n\ndef nCr(n, r):\n    r = min(r, n-r)\n    if r == 0:\n        return 1\n    num = functools.reduce(lambda x, y: x*y%mod, list(range(n, n-r, -1)))\n    den = functools.reduce(lambda x, y: x*y%mod, [pow(x, mod-2, mod) for x in range(1, r+1)])\n    return num * den % mod\n\nmod = 10**9 + 7\nprint(((pow(2, n, mod) - nCr(n, a) - nCr(n, b) - 1) % mod))\n", "def comb(n, r, p):\n    num, den = 1, 1\n    r = min(r, n - r)\n    for i in range(1, r + 1):\n        num = num * (n - i + 1) % p\n        den = den * i % p\n    return num * pow(den, p - 2, p) % p\n\n\nn, a, b = list(map(int, input().split()))\nMOD = 1_000_000_007\nans = pow(2, n, MOD)\nans %= MOD\nans -= comb(n, a, MOD)\nans %= MOD\nans -= comb(n, b, MOD)\nans %= MOD\nans -= 1\nans %= MOD\nprint(ans)\n", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef nCr(n, r):\n    a, b = 1, 1\n    for i in range(r):\n        a = a * (n - i) % MOD\n        b = b * (i + 1) % MOD\n    \n    return a * pow(b, MOD - 2, MOD) % MOD\n\ndef Main():\n    n, a, b = read_ints()\n    num = pow(2, n, MOD) - 1\n\n    print((num - nCr(n, a) - nCr(n, b)) % MOD)   \n\ndef __starting_point():\n    Main()\n__starting_point()", "n, a, b = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\ndef c(n, k):\n    ue, sita = 1, 1\n    for i in range(0, k):\n        ue = ue * (n - i) % mod\n       \tsita = sita * (i + 1) % mod\n    return ue * inv(sita) % mod\n\n\nprint((((pow(2, n, mod) - c(n, a) - c(n, b) - 1) % mod + mod) % mod))\n", "# import itertools\n# import math\n# import sys\n# sys.setrecursionlimit(500*500)\n# import numpy as np\n# import heapq\n# from collections import deque\n\n# N = int(input())\n# S = input()\n# n, *a = map(int, open(0))\nn, a, b = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# tree = [[] for _ in range(N + 1)]\n# B_C = [list(map(int,input().split())) for _ in range(M)]\n# S = input()\n\n# B_C = sorted(B_C, reverse=True, key=lambda x:x[1])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\n# def dfs(tree, s):\n#     for l in tree[s]:\n#         if depth[l[0]] == -1:\n#             depth[l[0]] = depth[s] + l[1]\n#             dfs(tree, l[0])\n# dfs(tree, 1)\n\n# def factorization(n):\n#     arr = []\n#     temp = n\n#     for i in range(2, int(-(-n**0.5//1))+1):\n#         if temp%i==0:\n#             cnt=0\n#             while temp%i==0:\n#                 cnt+=1\n#                 temp //= i\n#             arr.append([i, cnt])\n#     if temp!=1:\n#         arr.append([temp, 1])\n#     if arr==[]:\n#         arr.append([n, 1])\n#     return arr\n\nmod = 10 ** 9 + 7\n\ndef comb(n, m, mod = 10 ** 9 + 7):\n    numerator = 1\n    denominator = 1\n    for i in range(1, m + 1):\n        numerator = numerator * (n - i + 1) % mod\n        denominator = denominator * i % mod\n    d_inv = pow(denominator, mod - 2, mod)\n    return numerator * d_inv % mod\n\ncmb_n_a = comb(n, a)\ncmb_n_b = comb(n, b)\n\nprint((pow(2, n, mod) - 1 - cmb_n_a - cmb_n_b) % mod)", "n,a,b=map(int,input().split())\nmod=pow(10, 9)+7\ns,x,y=pow(2, n, mod)-1,1,1\nfor i in range(1,b+1):\n  x,y=x*(n-i+1)%mod,y*i%mod\n  if i==a or i==b: s-=x*pow(y,mod-2,mod)\nprint(s%mod)", "MOD = 1_000_000_007\ndef calc_combi(n,k):\n    frac=1\n    denomi=1\n    for i in range(n-k+1,n+1):\n        frac=frac*i%MOD\n    for i in range(1,k+1):\n        denomi=denomi*i%MOD\n    return frac*pow(denomi,MOD-2,MOD)\n\nn, a, b = map(int,input().rstrip().split())\nnca = calc_combi(n,a)\nncb = calc_combi(n,b)\nprint((pow(2,n,MOD)-1-nca-ncb)%MOD)", "n, a, b = map(int, input().split())\n\nMOD = 10 ** 9 + 7\n\ndef nCk(n, k):\n    num = 1\n    for i in range(n, n - k, -1):\n        num *= i\n        num %= MOD\n    tmp = 1\n    for i in range(1, k + 1):\n        tmp *= i\n        tmp %= MOD\n    num *= pow(tmp, MOD - 2, MOD)\n    return num\n\nans = pow(2, n, MOD) - 1\nans -= nCk(n, a)\nans -= nCk(n, b)\nprint(ans % MOD)", "#\u3088\u308a\u9ad8\u901f\u306b\ndef pow(x, n ,p):\n    \"\"\"\n    O(log n)\n    \"\"\"\n    if n == 0:\n        return 1\n\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K = (x*K) % p\n        x = (x*x) % p\n        n //= 2\n\n    return (K * x) % p\n\n\n\n\ndef cmb3(n,r,q):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)    \n    s = 1\n    for x in range(n,n-r,-1):\n        s = (s*x) % q\n    t = 1\n    for x in range(1,r+1):\n        t = (t*x) % q\n\n    #\u5272\u308b\u6570\u306e\u5270\u4f59\u3092\u3069\u3046\u3059\u308b\u304b\u304c\u554f\u984c\n    u = pow(t,q-2,q)\n    return (u * s) % q\n  \nn,a,b = list(map(int,input().split()))\nA = pow(2,n,10**9+7)\n\nif a <= n:\n  B = cmb3(n,a,10**9+7)\nelse:\n  B = 0\nif b <= n:\n  C = cmb3(n,b,10**9+7)\nelse:\n  C = 0\n\nprint(((A-B-C-1)%(10**9+7)))\n\n", "import functools\nN, A, B = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\ndef modpow(x, n):\n    ret = 1\n    while n:\n        if n & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return ret\n\n@functools.lru_cache(maxsize=None)\ndef modinv(x):\n    return modpow(x, MOD - 2)\n\ndef modcomb(n, r):\n    ret = 1\n    for i in range(n, n - r, -1):\n        ret *= i\n        ret %= MOD\n    for i in range(r, 1, -1):\n        ret *= modinv(i)\n        ret %= MOD\n    return ret\n\ntotal = modpow(2, N) - 1\nans = total - (modcomb(N, A) + modcomb(N, B))\nans %= MOD\nprint(ans)\n", "n,a,b=map(int,input().split())\np=10**9+7\n\ndef cmb(n, r):\n  # \u5206\u5b50(n*(n-1)*...*(n-r+1))\n  nume = 1\n  for i in range(n-r+1, n+1):\n    nume = nume * i % p\n  # \u5206\u6bcd\uff081*2*...*r\uff09\n  deno = 1\n  for j in range(1, r+1):\n    deno = deno * j % p\n    d = pow(deno, p-2, p)\n  return nume * d\n\nnca = cmb(n, a)\nncb = cmb(n, b)\nres = pow(2, n, p) - nca - ncb - 1\nprint(res%p)", "n, a, b = list(map(int, input().split()))\nif a > b: a, b = b, a\nmod = 10 ** 9 + 7\ntmp = 1\n\nC = n\nans = 0\nif a == 1: Ca = n\nfor r in range(1, n + 1):\n    C = (((C * (n - r)) % mod )* pow(r + 1, mod - 2, mod)) % mod\n    if r == a - 1:\n        Ca = C\n    if r == b - 1:\n        Cb = C\n        break\n\nprint(((pow(2, n, mod) - Ca - Cb - 1) % mod))\n", "def main():\n    n, a, b = map(int, input().split())\n    mod = 10 ** 9 + 7 #\u7d20\u6570\n    \n    def modpow(x, n, mod):\n        res = 1\n        while n:\n            if n % 2:\n                res *= x % mod\n            x *= x % mod\n            n >>= 1\n        return res\n    \n    def cmb(n, r):\n        # \u5206\u5b50(n*(n-1)*...*(n-r+1))\n        nume = 1\n        for i in range(n-r+1, n+1):\n            nume = nume * i % mod\n        # \u5206\u6bcd\uff081*2*...*r\uff09\n        deno = 1\n        for j in range(1, r+1):\n            deno = deno * j % mod\n        d = modpow(deno, mod-2, mod)\n        return nume * d\n    \n    all_cmb = pow(2, n, mod) - 1\n    bad_a = cmb(n, a)\n    bad_b = cmb(n, b)    \n    print((all_cmb-bad_a-bad_b) % mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "def modinv(a, m):\n    b = m\n    u = 1\n    v = 0\n    while b:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u %= m\n    if u < 0:\n        u += m\n    return u\n\ndef nCk(N, k, mod):\n    ret_val = 1\n    for i in range(k):\n        ret_val *= (N - i)\n        ret_val %= mod\n        ret_val *= modinv(i + 1, mod)\n        ret_val %= mod\n    return ret_val\n\n\nn, a, b = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nall_cnt = pow(2, n, MOD) - 1\na_cnt = nCk(n, a, MOD)\nb_cnt = nCk(n, b, MOD)\nans = all_cnt - a_cnt - b_cnt\nwhile ans < 0:\n    ans += MOD\nprint(ans)\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\ndef main():\n    n,a,b = i_map()\n    s = pow(2,n,MOD) - 1\n\n    def fur(n,r):\n        p,q = 1, 1\n        for i in range(r):\n            p = p*(n-i)%MOD\n            q = q*(i+1)%MOD\n        return (p * pow(q,MOD-2,MOD)) % MOD\n\n    print(((s - fur(n,a) - fur(n,b)) % MOD))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#pow\u306f\u7e70\u308a\u8fd4\u30572\u4e57\u6cd5\u306b\u3088\u308a\u6307\u6570\u8a08\u7b97\u3092\u884c\u3046\u95a2\u6570\nmod=10**9+7\nn,a,b=list(map(int,input().split()))\n\nans=pow(2,n,mod)-1 #n\u7a2e\u985e\u306e\u82b1\u3092\u4f7f\u3063\u3066\u82b1\u675f\u3092\u4f5c\u308b\u7dcf\u6570\u306f2^n-1\u901a\u308a\n\ncomb1=1 #nCa\u306e\u8a08\u7b97\nfor i in range(n-a+1,n+1): #n*(n-1)*\u2026*(n-a+1)\u3092\u8a08\u7b97\n    comb1*=i\n    comb1%=mod\nfor i in range(1,a+1): #1/a!=1/(1*2*\u2026*a)=1^(p-2)*2^(p-2)*\u2026*a^(p-2) (p=10**9+7)\u3092\u8a08\u7b97\n    comb1*=pow(i,mod-2,mod) # i\u306e\u9006\u5143 \u2192\u30001/i\u3057\u305f\u969b\u306b \u304b\u3051\u308b(i\u306e\u9006\u5143)\u3068\u3059\u308c\u3070\u3042\u307e\u308a\u304c\u6c42\u307e\u308b\n    comb1%=mod\n\ncomb2=1\nfor i in range(n-b+1,n+1): #n*(n-1)*\u2026*(n-b+1)\u3092\u8a08\u7b97\n    comb2*=i\n    comb2%=mod\nfor i in range(1,b+1): #1/b!=1/(1*2*\u2026*b)=1^(p-2)*2^(p-2)*\u2026*b^(p-2) (p=10**9+7)\u3092\u8a08\u7b97\n    comb2*=pow(i,mod-2,mod)\n    comb2%=mod\n\nans-=(comb1+comb2) #nCa\u3001nCb\u3092\u7dcf\u6570\u304b\u3089\u5f15\u304f\nans%=mod\nprint(ans)\n", "n,a,b = map(int,input().split())\nmod = 10**9 + 7\nans = pow(2,n,mod) - 1\nfa = 1\nfb = 1\nfor i in range(1, a+1):\n    fa *= i\n    fa %= mod\nfor i in range(1, b+1):\n    fb *= i\n    fb %= mod\n\nfa = pow(fa, mod-2, mod)\nfb = pow(fb, mod-2, mod)\n\nfor i in range(a):\n    fa *= n - i\n    fa %= mod\nfor i in range(b):\n    fb *= n - i\n    fb %= mod\n\nprint((ans - fa - fb) % mod)", "import math\nimport numpy as np\nn,a,b=map(int,input().split())\nmod=10**9+7\nfactna=[n]\nfactnb=[n]\nfacta=[a]\nfactb=[b]\n\nfor i in range(1,a):\n  factna.append(factna[-1]*(n-i)%mod)\n  facta.append(facta[-1]*(a-i)%mod)\n\nfor i in range(1,b):\n  factnb.append(factnb[-1]*(n-i)%mod)\n  factb.append(factb[-1]*(b-i)%mod)\n\ndef pow(x,n):\n  a=1\n  while(n>0):\n    if n%2==1:\n      a*=x%mod\n    x*=x%mod\n    n>>=1\n  return a\nA=pow(2,n)%mod\nB=factna[-1]*pow(facta[-1],mod-2)%mod\nC=factnb[-1]*pow(factb[-1],mod-2)%mod\n#print(factna,factb)\nprint((A-B-C-1)%mod)", "n, a, b = map(int, input().split())\n\nMOD = 10 ** 9 + 7\n\ndef modinv(x, mod):\n    return pow(x, mod-2, mod)\n\nmodinv_table = [-1] * (b+1)\nfor i in range(1, b+1):\n    modinv_table[i] = modinv(i, MOD)\n\ndef comb(n, k, mod):\n    ans = 1\n    for i in range(k):\n        ans *= n-i\n        ans *= modinv_table[i + 1]\n        ans %= mod\n    return ans\n  \nans = (pow(2, n, MOD) - comb(n, a, MOD) - comb(n, b, MOD)) % MOD - 1\n\nprint(ans)", "n,a,b = map(int,input().split())\n\nmod = 10**9+7\n\nall_combi = pow(2,n,mod)\n\n\n\n\np = 1\nq = 1\n\nfor i in range(b):\n    \n    p *= n-i\n    p %= mod\n    q *= i+1\n    q %= mod\n    \n    if i==a-1:\n        nca = p * pow(q,-1,mod) % mod\n        \n    if i==b-1:\n        ncb = p * pow(q,-1,mod) % mod\n\n        \nans = all_combi -nca -ncb -1\nans %= (10**9+7)\n    \nprint(ans)", "\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n\n    def cmb(n, r):\n        if n - r < r: r = n - r\n        if r == 0: return 1\n        if r == 1: return n\n\n        numerator = [n - r + k + 1 for k in range(r)]\n        denominator = [k + 1 for k in range(r)]\n\n        for p in range(2, r + 1):\n            pivot = denominator[p - 1]\n            if pivot > 1:\n                offset = (n - r) % p\n                for k in range(p - 1, r, p):\n                    numerator[k - offset] /= pivot\n                    denominator[k] /= pivot\n\n        result = 1\n        for k in range(r):\n            if numerator[k] > 1:\n                result *= int(numerator[k])\n                result %= 10**9+7\n\n        return result\n\n    print((int(\n        ((pow(2, n, mod) - 1) % mod\n         - (cmb(n, a)) % mod\n         - (cmb(n, b)) % mod)\n        % mod)\n    ))\n\n\nmain()\n\n", "n, a, b = map(int, input().split())\n\nMOD = 10**9 + 7\nN = pow(2,n,MOD)\n\ndef com(n,r):\n    s = 1\n    for i in range(n-r+1, n+1):\n        s *= i\n        s %= MOD\n\n    t = 1\n    for j in range(1,r+1):\n        t *= j\n        t %= MOD\n\n\n    return s * pow(t,MOD-2, MOD) % MOD\n\nprint((N - com(n, a) - com(n, b) - 1) % (MOD))", "def modpow(a, n, p):\n    if n == 1:\n        ans = a % p\n    else:\n        if n % 2 == 0:\n            ans = (modpow(a, n // 2, p) ** 2) % p\n        else: # n % 2 == 1\n            ans = (a * (modpow(a, n // 2, p) ** 2)) % p\n\n    return ans\n\np = 10 ** 9 + 7\nn, a, b = [int(x) for x in input().split()]\n\ntot = modpow(2, n, p)\n\nXa, Ya = 1, 1\nfor i in range(a):\n    Xa = (Xa * (n - i)) % p\n    Ya = (Ya * (i + 1)) % p\nZa = modpow(Ya, p - 2, p)\nnCa = (Xa * Za) % p\n\nXb, Yb = 1, 1\nfor i in range(b):\n    Xb = (Xb * (n - i)) % p\n    Yb = (Yb * (i + 1)) % p\nZb = modpow(Yb, p - 2, p)\nnCb = (Xb * Zb) % p\n\nans = (tot - nCa -nCb - 1) % p\n\nprint(ans)", "n, a, b = map(int, input().split())\n\nmod = 10**9 + 7\n\nans = pow(2, n, mod)\n\nans -= 1\n\naa = 1\nfor i in range(1, a+1):\n    aa = (aa * (n - i + 1) * pow(i, -1, mod)) % mod\n\nbb = 1\nfor i in range(1, b+1):\n    bb = (bb * (n - i + 1) * pow(i, -1, mod)) % mod\n\nans = (ans - aa - bb) % mod\n\nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 13 19:51:37 2020\n\n@author: liang\n\"\"\"\n\nimport math\n\nkey = 10**9 + 7\n\nn, a, b = map(int,input().split())\n\nans = 1\ntmp = 2\nN = math.ceil(math.log2(n))\n\n#\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\nfor i in range(N+1):\n    if n>>i&1 == 1:\n        #print(i,tmp)\n        ans *= tmp\n    tmp *= tmp\n    tmp %= key\n    ans %= key\nans -= 1\n#print(\"1\",ans)\n\ndef comb(r):\n    #permutation\n    perm = 1\n    for i in range(0,r):\n        perm *= n - i\n        perm %= key\n    \n    #factorial\n    fact = 1\n    for i in range(1,r+1):\n        fact *= i\n        fact %= key\n    \n    ans = 1\n    tmp = fact\n    p = key -2\n    N = math.ceil(math.log2(p))\n    #\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\n    for i in range(N):\n        if  p >>i&1 == 1:\n            #print(i,tmp)\n            ans *= tmp\n        tmp *= tmp\n        tmp %= key\n        ans %= key\n    ans *= perm\n    ans %= key\n    return ans\n\nans -= comb(a)\nans -= comb(b)\nans %= key\n#print(\"2\",comb(a))\n#print(\"3\",comb(b))\nprint(ans)", "from math import factorial\nn, a, b = [int(i) for i in input().split()]\nmod = 10 ** 9 + 7\n\ndef nCr(n, r):\n    nonlocal mod\n    ans = 1\n    for i in range(r):\n        ans = (ans * (n-i)) % mod\n    return (ans * pow(factorial(r), mod-2, mod)) % mod\n\nprint((pow(2, n, mod) - nCr(n, a) - nCr(n, b) - 1) % mod) ", "n,a,b=map(int,input().split())\n\ndef genCombinationFunction(max_k,mod):\n    modinv_table = [-1] * (max_k+1)\n    modinv_table[1] = 1\n    for i in range(2, max_k+1):\n        modinv_table[i] = (-modinv_table[mod % i] * (mod // i)) % mod\n\n    def binomial_coefficients(n, k):\n        ans = 1\n        for i in range(k):\n            ans *= n-i\n            ans *= modinv_table[i + 1]\n            ans %= mod\n        return ans\n    return binomial_coefficients\n\n  \nmax_k = 2 * 10 ** 5\nmod = 10**9 + 7\nf=genCombinationFunction(max_k,mod)\n\n\nans=pow(2,n,mod)-1\nans-=f(n,a)\nans-=f(n,b)\nprint(ans%mod)", "n, a, b = map(int, input().split())\nmod = pow(10, 9) + 7\n \ndef comb(N, x):\n    numerator = 1\n    for i in range(N-x+1, N+1):\n        numerator = numerator * i % mod\n    denominator = 1\n    for j in range(1, x+1):\n        denominator = denominator * j % mod\n    d = pow(denominator, mod-2, mod)\n    return numerator * d\n \na = comb(n, a)\nb = comb(n, b)\n \nprint((pow(2, n, mod) -1 -a -b) % mod)", "mod = 1000000007\n\ndef mod_cmb(n: int, k: int, p: int) -> int:\n    if n < 0 or k < 0 or n < k: return 0\n    if n == 0 or k == 0: return 1\n    if (k > n - k):\n        return mod_cmb(n, n - k, p)\n    c = d = 1\n    for i in range(k):\n        c *= (n - i)\n        d *= (k - i)\n        c %= p\n        d %= p\n    return c * pow(d, -1, p) % p\n\ndef main():\n    n, a, b = list(map(int, input().split()))\n\n    ans = pow(2, n, mod) - 1\n\n    tmp_a = mod_cmb(n , a, mod)\n    tmp_b = mod_cmb(n , b, mod)\n\n    print(((ans-tmp_a-tmp_b)%mod))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nfrom functools import reduce\nfrom operator import mul\n\nmod = 10**9 + 7\n\n\ndef cmb(n, r):\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    over = reduce(lambda a, b: a * b % mod, list(range(n, n - r, -1)))\n    under = reduce(lambda a, b: a * b % mod, list(range(1, r + 1)))\n    return over * pow(under,mod-2,mod)\n\n\nn, a, b = list(map(int, input().split()))\nprint(((pow(2, n, mod) - 1 - cmb(n, a) - cmb(n, b)) % mod))\n", "import math\n\ndef main():\n\tn, a, b = [int(x) for x in input().split(\" \")]\n\t# 2^n - 1 - nCa - nCb\n\tp = 1000000007\n\ta = min([a, n - a])\n\tb = min([b, n - b])\n\tM = max([a, b])\n\tf = [1, 1]\n\tfinv = []\n\tfor i in range(M):\n\t\tf.append((f[-1] * (i + 2)) % p)\n\tlf = len(f)\n\tfinv.append(modpower(f[-1], p - 2, p))\n\tfor i in range(lf - 1):\n\t\tfinv.append((finv[-1] * (lf - i - 1)) % p)\n\tna = 1\n\tnb = 1\n\tfor i in range(M):\n\t\tif a > i:\n\t\t\tna = (na * (n - i)) % p\n\t\tif b > i:\n\t\t\tnb = (nb * (n - i)) % p\n\tprint((modpower(2, n, p) - 1 - (na * finv[lf - 1 - a]) % p - (nb * finv[lf - 1 - b]) % p) % p)\n\n\ndef modpower(a, p, d): # a^p % d\n\tpp = [a]\n\tfor i in range(int(math.log2(p)) + 1):\n\t\tpp.append((pp[-1] ** 2) % d)\n\tb_p = format(p, 'b')\n\tm = 1\n\tfor i in range(len(b_p)):\n\t\tif b_p[-i-1] == \"1\":\n\t\t\tm = (m * pp[i]) % d\n\treturn m\n\nmain()", "n,a,b=map(int,input().split())\ndef fact(n,p):\n    a=1\n    for i in range(1,n+1):\n        a=(a*i)%p\n    return a\ndef bfact(n,x,p):\n    a=1\n    for i in range(n-x+1,n+1):\n        a=(a*i)%p\n    return a\np=10**9+7\nna=bfact(n,a,p)%p\nnb=bfact(n,b,p)%p\naa=fact(a,p)%p\nbb=fact(b,p)%p\naaa=pow(aa,-1,p)\nbbb=pow(bb,-1,p)\nans=pow(2,n,p)-1\nans-=(na*aaa+nb*bbb)\nprint(ans%p)", "n, a, b = list(map(int, input().split()))\nmod = 10**9+7\n\ndef cmb2(n, r, mod):\n    res = 1\n    temp = 1\n    for k in range(1, r+1):\n        res *= (n-k+1)\n        temp *= k\n        res %= mod\n        temp %= mod\n    res *= pow(temp,(mod-2),mod)\n    res %= mod\n    return res\n\ndef power(a, n, mod):\n    bi=str(format(n,\"b\")) #2\u9032\u6570\n    res=1\n    for i in range(len(bi)):\n        res=(res*res) %mod\n        if bi[i]==\"1\":\n            res=(res*a) %mod\n    return res\n\nans = power(2, n, mod) - cmb2(n, a, mod) - cmb2(n, b, mod) -1\nans %= mod\nprint(ans)\n", "mod = 10**9+7\nn,a,b = map(int,input().split())\ndef combination(n, a):\n    res = 1\n    div = 1\n    for i in range(a):\n        res *= n-i\n        res %= mod\n        div *= a - i\n        div %= mod\n    res = (res * pow(div, mod-2, mod)) % mod\n    return res\nprint((pow(2,n,mod)-1-combination(n,a)-combination(n,b))%mod)", "n,a,b=list(map(int,input().split()))\nmod=1000000007\nc=[1]*(b+1)\ndef com(n,b):\n    for i in range(1,b+1):\n        c[i]=c[i-1]*((n-i+1)*pow(i,mod-2,mod))%mod\ncom(n,b)\nans=(pow(2,n,mod)-c[a]-c[b]-1)%mod\n\nprint(ans)\n", "def cmb(a,b,c):\n    b = min(b,a-b)\n    num = 1\n    for i in range(b):\n        num = num*(n-i) % c\n    den = 1\n    for i in range(b):\n        den = den*(i+1) % c\n    return num*pow(den,-1,c) % c\nmod = 10**9+7\nn,a,b = map(int,input().split())\nans  = (pow(2,n,mod)-cmb(n,a,mod)-cmb(n,b,mod)-1) % mod\nif ans < 0:\n    ans = ans + mod\nprint(ans)", "n, a, b = map(int,input().split())\n\nmod = 10**9+7\n\ndef combi(n,r):\n    x, y = 1,1\n    for i in range(n-r+1,n+1):\n        x *= i\n        x %= mod\n        \n    for j in range(1,r+1):\n        y *= j\n        y %= mod\n    yinv = pow(y,mod-2,mod)\n    \n    return x*yinv%mod\n\ndef main():\n    nca = combi(n,a)\n    ncb = combi(n,b)\n    ans = pow(2,n,mod)-1 - (nca + ncb)\n        \n    print(ans%mod)\n    \nmain()", "n,a,b=map(int,input().split())\nmod=10**9+7\nans=pow(2,n,mod)-1\na=min(a,n-a)\nb=min(b,n-b)\nc=min(a,b)\nwk=1\nfor i in range(1,c+1):\n  wk=wk*(n+1-i)*pow(i,mod-2,mod)%mod\nans-=wk\nfor i in range(c+1,max(a,b)+1):\n  wk=wk*(n+1-i)*pow(i,mod-2,mod)%mod\nans-=wk\nprint(ans%mod)", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nimport heapq\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1] # warning bytes\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8').strip()\nimport string\nimport operator\nimport random\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\ndef print_lines(data):\n    sys.stdout.write('\\n'.join((str(x) for x in data)))\n\n\ndef solve():\n    N, a, b = [int(x) for x in input().split()]\n\n    def prod(a, b):\n        ans = 1\n        for x in range(a, b + 1):\n            ans *= x\n            ans %= MOD\n        return ans\n\n    def fact(x):\n        ans = 1\n        while x:\n            ans *= x\n            ans %= MOD\n            x -= 1\n        return ans\n \n    def coef(n, k):\n        if k > n: return 0\n        return (prod(n - k + 1, n) * pow(fact(k)%MOD, MOD - 2, MOD)) % MOD\n \n    print(((MOD + pow(2, N, MOD) - 1 - coef(N, a) - coef(N, b)) % MOD))\n\n\nT = 1\n# T = int(input())\nfor case in range(1,T+1):\n    ans = solve()\n\n\n\"\"\"\n\n\n\n\n\"\"\"\n", "def main():\n    #input data\n    import sys\n    input = lambda:sys.stdin.readline().strip()\n    \n    N,A,B = map(int,input().split())\n    mod=10**9+7\n    #solve\n    #\u4e8c\u9805\u4fc2\u6570\u306e\u548c=2**n\n    #2**n-1-nCa-nCb\n    def modinv(a, mod=10**9+7):\n        return pow(a, mod-2, mod)\n    def cmb(n, r, mod=10**9+7):\n        r = min(r, n-r)\n        res = 1\n        for i in range(r):\n            res = res * (n - i) * modinv(i+1, mod) % mod\n        return res\n                \n    ans = pow(2,N,mod)-1-cmb(N,A,mod)-cmb(N,B,mod)\n    print(ans%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "def Li():\n    return list(map(int, input().split()))\n\n\nn, a, b = Li()\nmod = pow(10, 9)+7\nbunshi = 1\nbunbo = 1\nans = pow(2, n, mod)-1\nfor i in range(a):\n    bunshi = (bunshi*(n-i)) % mod\n    bunbo = (bunbo*(i+1)) % mod\nans = (ans-bunshi*pow(bunbo, -1, mod)) % mod\nfor i in range(a, b):\n    bunshi = (bunshi*(n-i)) % mod\n    bunbo = (bunbo*(i+1)) % mod\nans = (ans-bunshi*pow(bunbo, -1, mod)) % mod\nprint(ans)\n", "ip = input().split(\" \")\nn = int(ip[0])\na = int(ip[1])\nb = int(ip[2])\n\nm = 1000000007\n\n\ndef modMul(a, b, mod):\n    return (a*b)%mod\n    \n\ndef fastExp(b, exp, mod):\n    res = 1\n    base = b\n    while exp > 0:\n        if exp%2 == 1:\n            res = modMul(res, base, mod)\n        base = modMul(base, base, mod)\n        exp >>= 1\n    return res\n\n\ndef getncr(n, r, m):\n    num = 1\n    fact = 1\n    for i in range(r):\n        num = modMul(num, n-i, m)\n        fact = modMul(i+1, fact, m)\n    return modMul(num, fastExp(fact, m-2, m) , m)\n    \n    \ndef solve(n, a, b, m):\n    got = fastExp(2, n, m) -1\n    for_a = getncr(n, a, m)\n    for_b = getncr(n, b, m)\n    got -= for_a\n    if got < 0:\n        got += m\n    got -= for_b\n    if got < 0:\n        got += m\n    print(got)\n\nsolve(n, a, b, m)\n\n", "N,A,B=map(int,input().split())\nM=10**9+7\n\ndef cmb(N,R,M):\n    C=[1]*(R+1)\n    for i in range(1,R+1):\n        C[i]=(C[i-1]*(N+1-i)*pow(i,M-2,M))%M\n    return C\n\nC=cmb(N,B,M)\nans=pow(2,N,M)-1\nans-=C[A]+C[B]\nprint(ans%M)", "n, a, b = map(int, input().split())\n\nmod = 10**9 + 7\n\ndef nck(k):\n    y, z = 1, 1\n    for i in range(1, k+1):\n        y = (y * (n+1-i)) % mod\n        z = (z * pow(i, mod-2, mod)) % mod\n    return (y*z) % mod\n\nans = (pow(2, n, mod) - 1 - nck(a) - nck(b)) % mod\nprint(ans)", "n, a, b = map(int, input().split())\nmod = 10**9 + 7\ndef cmb(n,r):\n    p,q = 1,1\n    for i in range(r):\n        p = p*(n-i)%mod\n        q = q*(i+1)%mod\n    return p * pow(q,mod-2,mod) % mod\nALL = pow(2, n, mod) - 1\nprint((ALL - cmb(n, a) - cmb(n, b)) % mod)", "n, a, b = map(int, input().split())\nmod = 10**9 + 7\ndef nck(k):\n    y, z = 1, 1\n    for i in range(1, k+1):\n        y = (y * (n+1-i)) % mod\n        z = (z * pow(i, mod-2, mod)) % mod\n    return (y*z) % mod\n \nans = (pow(2, n, mod) - 1 - nck(a) - nck(b)) % mod\nprint(ans)"]
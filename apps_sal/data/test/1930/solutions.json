["MOD = 998244353\ndef power(x, n) :\n    ans = 1\n    while (n) :\n        if ((n & 1) == 1) :\n            ans = ans * x % MOD\n        x = x * x % MOD\n        n = n // 2\n    return ans\n\nn = int(input())\na = list(map(int, input().split()))\nb = [0 for i in range(n + 1)]\n\ndef add(x, v) :\n    while (x <= n) : \n        b[x] = b[x] + v\n        x = x + (x & -x)\ndef get(x) :\n    ans = 0\n    while (x) :\n        ans = ans + b[x]\n        x = x - (x & -x)\n    return ans\n\nanss = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        add(a[i], 1)\n        anss = anss + get(n) - get(a[i])\n\nanss = anss % MOD\ntotal = 0\n\nsur = [0] + [1 for i in range(n)]\nfor i in range(n) :\n    if (a[i] == -1) :\n        total = total + 1\n    else :\n        sur[a[i]] = 0\n\nif (total == 0) : \n    print(anss) \n    return\nfor i in range(1, n + 1) : \n    sur[i] = sur[i] + sur[i - 1]\n\ndead = 0\n\nansa = 0\nfor i in range(n) :\n    if (a[i] != -1) :\n        ansa = ansa + sur[a[i]] * (total - dead) + (sur[n] - sur[a[i]]) * dead\n    else : \n        dead = dead + 1\n\nans = (ansa * 4 + anss * 4 * total + total * total * (total - 1)) % MOD\nans = (ans * power(4 * total, MOD - 2)) % MOD\nprint(ans) \n\n", "n = int(input())\n\nL = [int(x) for x in input().split()]\nD = {}\nJ = []\nS = []\nT = [0]*(n+1)\nfor i in range(n):\n    if L[i] > 0:\n        D[L[i]] = i\n        J.append(L[i])\n        T[i+1] = T[i]\n    else:\n        T[i+1] = T[i]+1\n        \ndef I(J):\n    if len(J) <= 1:\n        return J, 0\n    else:\n        a = J[:len(J)//2]\n        b = J[len(J)//2:]\n        a, ai = I(a)\n        b, bi = I(b)\n        c = []\n        i = 0\n        j = 0\n        inversions = ai + bi\n    while i < len(a) and j < len(b):\n        if a[i] <= b[j]:\n            c.append(a[i])\n            i += 1\n        else:\n            c.append(b[j])\n            j += 1\n            inversions += (len(a)-i)\n    c += a[i:]\n    c += b[j:]\n    return c, inversions\n\nfor i in range(1,n+1):\n    if not i in D:\n        S.append(i)\n\ntotal = len(S)\nnum = 1\ndenom = 1\nif total > 0:\n    themostimportantsum = 0\n    for i in J:\n        low = 0\n        high = total-1\n        while high-low > 1:\n            guess = (high+low)//2\n            if S[guess] > i:\n                high = guess\n            else:\n                low = guess\n        if S[low] > i:\n            smaller = low\n        elif S[high] > i:\n            smaller = high\n        else:\n            smaller = high+1\n        #D[i] is the position of i in the list\n        #T[D[i]] is how many -1s there are to the left of it\n        themostimportantsum += T[D[i]]*(total-smaller)+(total-T[D[i]])*(smaller)\n        num = themostimportantsum+total\n        denom = total\n\nnum =(denom*(((total)*(total-1))//2)+2*num)%998244353\ndenom *= 2\nif num == denom:\n    if I(J)[1] == 0:\n        print(0)\n    else:\n        print(I(J)[1]%998244353)\nelse:       \n    num += denom*I(J)[1]\n    print(((num-denom)*pow(denom%998244353,998244351,998244353))%998244353)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=list(map(int,input().split()))\nmod=998244353\n\nINV=[None]*(n+1)#1/a\u306e\u30ea\u30b9\u30c8\u3092\u4e88\u3081\u4f5c\u3063\u3066\u304a\u304f.\nfor i in range(1,n+1):\n    INV[i]=pow(i,mod-2,mod)\n\nBLA=P.count(-1)\n\nif BLA==0 or BLA==1:\n    ANS=0\nelse:\n    LEFT=BLA*(BLA-1)//2*INV[BLA]%mod#\u5de6\u5074\u306e\u500b\u6570\u306e\u5e73\u5747\n    AVEP=BLA*(BLA-1)//2*pow(BLA-1,mod-2,mod)#\u5de6\u5074\u306b\u3042\u308b\u3082\u306e\u304c\u81ea\u5206\u3088\u308a\u5927\u304d\u3044\u78ba\u7387\u306e\u548c\n\n    ANS=LEFT*AVEP%mod\n\n\n#print(ANS,LEFT,AVEP)\ny=1\nfor i in range(BLA):\n    y=y*(BLA-i)%mod\n\nKOSUU=pow(y,mod-2,mod)\nBLALIST=[1]*(n+1)\nNONBLA=[]\nBLANUM=[0]*n\nfor i in range(n):\n    if P[i]!=-1:\n        BLALIST[P[i]]=0\n        BLANUM[i]=BLANUM[i-1]\n        NONBLA.append(P[i])\n        \n    else:\n        BLANUM[i]=BLANUM[i-1]+1\n\n#print(BLALIST)\nBLALIST[0]=0\nfor i in range(1,n+1):\n    BLALIST[i]=BLALIST[i-1]+BLALIST[i]\n    \nif BLA!=0:\n    for i in range(n):\n        if P[i]!=-1:\n            ANS=(ANS+(BLANUM[i]*(BLA-BLALIST[P[i]])+(BLA-BLANUM[i])*BLALIST[P[i]])*INV[BLA])%mod\n\n#print(ANS)\n\nA=NONBLA\n\nif A==[]:\n    print(ANS)\n    return\n\n\nn=len(A)\nMAXA=max(A)\nMINA=min(A)\n\n\nBIT=[0]*(MAXA-MINA+2)#\u51fa\u73fe\u56de\u6570\u3092bit indexed tree\u306e\u5f62\u3067\u3082\u3063\u3066\u304a\u304f.\n\nfor i in range(n):#A[0],A[1],...\u3068BIT\u3092\u66f4\u65b0\n    bitobje=A[i]-MINA+1\n\n    x=bitobje\n    while x!=0:\n        ANS=(ANS-BIT[x])%mod\n        x-=(x&(-x))\n\n    #print(ANS)\n\n    x2=MAXA-MINA+1\n    #print(x2)\n    while x2!=0:\n        #print(x2,BIT)\n        ANS=(ANS+BIT[x2])%mod\n        x2-=(x2&(-x2))\n\n    #print(ANS)\n\n    y=bitobje\n    while y<=MAXA-MINA+1:\n        BIT[y]+=1\n        y+=(y&(-y))\n\n    #print(ANS,BIT)\n\nprint(ANS)\n\n", "K = 998244353\ndef mu(a, n):\n\tif n == 0: return 1\n\tq = mu(a, n // 2)\n\tif n % 2 == 0: return q * q % K\n\treturn q * q % K * a % K\nMAXN = 200005\ndd = [0 for i in range(MAXN)]\np = [0 for i in range(MAXN)]\ns = [0 for i in range(MAXN)]\na = [0 for i in range(MAXN)]\nfen = [0 for i in range(MAXN)]\n\ndef add(u, v):\n\ti = u\n\twhile (i <= 200000):\n\t\tfen[i] += v\n\t\ti += i & -i\n\ndef get(u):\n\tres = 0\n\ti = u\n\twhile (i > 0):\n\t\tres += fen[i]\n\t\ti -= i & -i\n\treturn res\n\nn = int(input())\n\ndata = input().split()\n\ncnt = 0\n\nfor i in range(1, n + 1):\n\tp[i] = int(data[i - 1])\n\tif (p[i] > 0): dd[p[i]] = 1\n\telse: cnt += 1\n\nfor i in range(1, n + 1):\n\tif (dd[i] == 0):\n\t\ts[i] = s[i - 1] + 1\n\telse:\n\t\ts[i] = s[i - 1]\n\ncnt1 = 0\nP = 0\nden = mu(cnt, K - 2)\nfor i in range(1, n + 1):\n\tif (p[i] == -1):\n\t\tcnt1 += 1\n\telse:\n\t\tu = cnt - cnt1\n\t\tP = (P + u * s[p[i]] % K * den % K) % K\n\t\tP = (P + cnt1 * (cnt - s[p[i]]) % K * den % K) % K\n\nP = (P + cnt * (cnt - 1) * mu(4, K - 2)) % K\n\nm = 0\n\nfor i in range(1, n + 1):\n\tif p[i] > 0:\n\t\tm += 1\n\t\ta[m] = p[i]\n\nP1 = 0\nfor i in range(m, 0, -1):\n\tP1 = (P1 + get(a[i])) % K\n\tadd(a[i], 1)\n\nP = (P + P1) % K\n\nprint(P)\n\n", "def merge(a,b):\n    inda=0\n    indb=0\n    lena=len(a)\n    lenb=len(b)\n    d=[a[-1]+b[-1]+1000]\n    a+=d\n    b+=d\n    c=[]\n    inversions=0\n    for i in range(lena+lenb):\n        if a[inda]<b[indb]:\n            c.append(a[inda])\n            inda+=1\n        else:\n            c.append(b[indb])\n            indb+=1\n            inversions+=lena-inda\n    return((c,inversions))\ndef mergesort(a):\n    if len(a)<=1:\n        return((a,0))\n    split=len(a)//2\n    b=a[:split]\n    c=a[split:]\n    d=mergesort(b)\n    e=mergesort(c)\n    f=merge(d[0],e[0])\n    return((f[0],f[1]+d[1]+e[1]))\nn=int(input())\na=list(map(int,input().split()))\nb=[]\nfor guy in a:\n    if guy!=-1:\n        b.append(guy)\ninvs=mergesort(b)[1]\nnegs=len(a)-len(b)\npairs=(negs*(negs-1))//2\nused=[0]*n\nfor guy in a:\n    if guy!=-1:\n        used[guy-1]+=1\nunused=[0]\nfor i in range(n-1):\n    unused.append(unused[-1]+1-used[i])\nnegsseen=0\nmix=0\nfor i in range(n):\n    if a[i]==-1:\n        negsseen+=1\n    else:\n        mix+=unused[a[i]-1]*(negs-negsseen)+negsseen*(negs-unused[a[i]-1])\nnum=invs*2*negs+pairs*negs+mix*2\ndenom=2*negs\nif negs==0:\n    print(invs%998244353)\nelse:\n    for i in range(denom):\n        if (998244353*i+1)%denom==0:\n            inv=(998244353*i+1)//denom\n            break\n    print((num*inv)%998244353)", "base=998244353;\ndef power(x, y):\n    if(y==0):\n        return 1\n    t=power(x, y//2)\n    t=(t*t)%base\n    if(y%2):\n        t=(t*x)%base\n    return t;\ndef inverse(x):\n    return power(x, base-2)\nft=[0]\nfor i in range(0, 200000):\n    ft.append(0)\ndef get(i):\n    res=0\n    while(i<=200000):\n        res+=ft[i]\n        i+=i&-i\n    return res\ndef update(i, x):\n    while(i):\n        ft[i]+=x\n        i-=i&-i\nn=int(input())\na=[0]\na+=list(map(int, input().split()))\nneg=[0]\nnon=[0]\nfor i in range(1, n+1):\n    non.append(0)\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        non[a[i]]+=1\nfor i in range(1, n+1):\n    non[i]+=non[i-1]\nfor i in range(1, n+1):\n    if(a[i]==-1):\n        neg.append(neg[i-1]+1)\n    else: \n        neg.append(neg[i-1])\nm=neg[n]\nans=0\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        ans+=get(a[i])\n        update(a[i], 1)\nfm=1\nfs=fm\nfor i in range(1, m+1):\n    fs=fm\n    fm=(fm*i)%base\nfs=(fs*inverse(fm))%base\nfor i in range(1, n+1):\n    if(a[i]!=-1):\n        less=a[i]-non[a[i]]\n        more=m-less\n        ans=(ans+neg[i]*more*fs)%base\n        ans=(ans+(m-neg[i])*less*fs)%base\nans=(ans+m*(m-1)*inverse(4))%base\nprint(ans)"]
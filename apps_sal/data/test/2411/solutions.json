["#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\n\nn = int(input())\np = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    p.append((x, y))\n\nd = {}\n\nfor i in range(n):\n    x1, y1 = p[i]\n    for j in range(i+1, n):\n        x2, y2 = p[j]\n        if x1 != x2:  \n            m = (y2-y1)/(x2-x1)\n            c = (y1*x2-x1*y2)/(x2-x1)\n        else:\n            m = 10**10\n            c = x1\n        if m in d:\n            if c in d[m]:\n                d[m][c] += 1\n            else:\n                d[m][c] = 1\n        else:\n            d[m] = {c: 1}\n\np = []\nfor m in d:\n    p.append(len(d[m]))\ns = sum(p)\nans = 0\nfor x in p:\n    ans += x*(s-x)\nprint(ans//2)", "import itertools\nimport math\nfrom functools import reduce\nfrom math import gcd\n\n# 2d line: ax + by + c = 0  is  (a, b, c)\n\n#          ax + by + c = 0     ((a, b, c),\n# 3d line: dx + ez + f = 0  is  (d, e, f),\n#          gy + hz + i = 0      (g, h, i))\n\ngcdm = lambda *args: reduce(gcd, args, 0)\n\n\ndef pointsToLine2d(p1, p2):\n    if p1 == p2:\n        return (0, 0, 0)\n    _p1, _p2 = sorted((p1, p2))\n\n    g = gcdm(*[x for x in (_p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]) if x != 0])\n\n    return ((_p2[1] - _p1[1]) // g, (_p1[0] - _p2[0]) // g, (_p1[1] * _p2[0] - _p1[0] * _p2[1]) // g)\n\n\ndist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5\n\npointsToLines = lambda p1, p2: list(map(pointsToLine2d, itertools.combinations(p1, 2), itertools.combinations(p2, 2)))\n\nareParallel = lambda l1, l2: l1[0] * l2[1] == l2[0] * l1[1]\n\nareSame = lambda l1, l2: areParallel(l1, l2) and (l1[1] * l2[2] == l2[1] * l1[2])\n\ncollinear = lambda p1, p2, p3: areSame(pointsToLine2d(p1, p2), pointsToLine2d(p2, p3))\n\nintersect = lambda l1, l2: None if areParallel(l1, l2) else ((l2[1] * l1[2] - l1[1] * l2[2]) / (l2[0] * l1[1] - l1[\n    0] * l2[1]), (l1[0] * l2[2] - l1[2] * l2[0]) / (l2[0] * l1[1] - l1[0] * l2[1]))\n\nrotate = lambda p, theta, origin=(0, 0): (origin[0] + (p[0] - origin[0]) * math.cos(theta) - (p[1] - origin[\n    1]) * math.sin(theta), origin[1] + (p[0] - origin[0]) * math.sin(theta) + (p[1] - origin[1]) * math.cos(theta))\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    p = []\n    for _ in range(n):\n        p.append(read_int_array())\n\n    lines = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            lines.add(pointsToLine2d(p[i], p[j]))\n\n    k = len(lines)\n    import collections\n    ax_bx = collections.defaultdict(int)\n    out = 0\n    for a, b, _ in lines:\n        ax_bx[a, b] += 1\n    for x in list(ax_bx.values()):\n        out += (k - x) * x\n    write(out // 2)\n\nmain()\n", "from collections import defaultdict as dd\nfrom itertools import combinations\nimport math\nimport heapq\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\n\nn=nn()\n\npoints=[]\n\nfor i in range(n):\n\tpoints.append(lm())\n\n\n\nslopedict=dd(set)\nlines=0\n\nfor p1, p2 in combinations(points,2):\n\tx1,y1=p1\n\tx2,y2=p2\n\n\n\tg=math.gcd(y2-y1,x2-x1)\n\tif y2-y1<0:\n\t\tsign=-1\n\n\telif y2-y1==0:\n\t\tif x2-x1<0:\n\t\t\tsign=-1\n\t\telse:\n\n\t\t\tsign=1\n\n\telse:\n\t\tsign=1\n\tslope=(sign*(y2-y1)//g,sign*(x2-x1)//g) \n\t\n\n\tif not slope[1]==0:\n\t\tceptn=slope[1]*y1-slope[0]*x1\n\t\tceptd=slope[1]\n\n\t\tif ceptn<0:\n\t\t\tsign=-1\n\t\t\n\t\telif ceptn==0:\n\t\t\tif ceptd<0:\n\t\t\t\tsign=-1\n\t\t\telse:\n\n\t\t\t\tsign=1\n\n\t\telse:\n\t\t\tsign=1\n\t\t\n\t\tg=math.gcd(ceptn,ceptd)\n\t\tcept=(sign*ceptn/g,sign*ceptd/g)\n\telse:\n\t\tcept=x1\n\n\n\n\tif not cept in slopedict[slope]:\n\t\tslopedict[slope].add(cept)\n\t\tlines+=1\n\ntotal=0\n\n\nfor slope in slopedict:\n\n\ttotal=total+(lines-len(slopedict[slope]))*len(slopedict[slope])\n\n\nprint(total//2)\t\n\npos=math.gcd(-4,2)\nneg=math.gcd(4,-2)\n#print(pos,neg)\n\n#print(-4//pos,2//pos)\n\n#print(4//neg,-2//neg)\n\t\n\n", "from math import *\n\nclass slopeC:\n    def __init__(self):        \n        self.chil = set()\nn = int(input())\n\nslopes = {}\nL = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    \n    for l in L:\n        if x != l[0]:\n            slope = (y - l[1]) / (x - l[0])\n        else:\n            slope = inf\n            \n        s1 = str(l[0]) + '-' + str(l[1])\n        s2 = str(x) + '-' + str(y)\n        if slope not in slopes:\n            slopes[slope] = [slopeC()]\n            slopes[slope][0].chil.add(s1)\n            slopes[slope][0].chil.add(s2)\n        else:\n            f = 0\n            for child in slopes[slope]:\n                if s1 in child.chil:\n                    f = 1\n                    child.chil.add(s2)\n                    break\n            if f == 0:\n                slopes[slope] += [slopeC()]\n                slopes[slope][0].chil.add(s1)\n                slopes[slope][0].chil.add(s2)\n        \n    L += [[x, y]]\nA = []\nP = [0]\nfor s in slopes:\n    A += [(len(slopes[s]))]\n    P += [P[-1] + A[-1]]\n    \nans = 0\n\n\nfor i, v in enumerate(A):\n    ans += A[i] * (P[-1] - P[i+1])\nprint(ans)\n\n\n    \n", "from collections import Counter\nN = int(input())\nif N == 2:\n    print(0)\n    return\ninf = 10**9+7\ninf2 = 10**18\ndef gcdl(A):\n    if len(A) == 0:\n        return -1\n    if len(A) == 1:\n        return 0\n    g = gcd(A[0], A[1])\n    for a in A[2:]:\n        g = gcd(a, g)\n    return g\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\nPoint = []\nans = 0\nfor _ in range(N):\n    Point.append(list(map(int, input().split())))\nS = Counter()\nT = set()\nfor i in range(N):\n    x1 , y1 = Point[i]\n    for j in range(N):\n        if i == j:\n            continue\n        x2 , y2 = Point[j]\n        a = y1 - y2\n        b = -(x1 - x2)\n        c = x2*y1 - x1*y2\n        g = gcdl([a, b, c])\n        a //= g\n        b //= g\n        c //= g\n        if a < 0:\n            a *= -1\n            b *= -1\n            c *= -1\n        k = a*inf+b*inf2+c\n        if k not in T:\n            T.add(a*inf+b*inf2+c)\n            if x1 == x2:\n                S[-1] += 1\n            else:\n                y = y1 - y2\n                x = x1 - x2\n                g = gcd(y, x)\n                y //= g\n                x //= g\n                if y < 0:\n                    y *= -1\n                    x *= -1\n                S[y*inf+x] += 1\nL = len(T)\nans = L*(L-1)//2\nfor s in S.values():\n    ans -= s*(s-1)//2\nprint(ans)", "from math import gcd\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\n\nfor x in list(C.values()):\n    res += (ss-x)*x\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)\n\n\n\n\n\n\n", "n = int(input())\nl = set()\ns = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n        for j in range(i+1, n):\n                x1, y1 = s[i]\n                x2, y2 = s[j]\n                if x1==x2: \n                        l.add((float('INF'), x1))\n                else:\n                        a = (y1-y2)/(x1-x2)\n                        b = (x1*y2-x2*y1)/(x1-x2)\n                        l.add((a, b))\nlis = [i[0] for i in l]\nfrom collections import Counter\ndic = Counter(lis)\nr = len(l)**2 - len(l)\nfor i in dic:\n        r -= dic[i]**2-dic[i]\nprint(r//2)\n", "n=int(input().strip())\nnum=[]\nfor k in range(n):\n    num.append(list(map(int,input().strip().split())))\nd={}\nimport math\nfor k in range(n):\n    for kk in range(k+1,n):\n        a=num[k]\n        b=num[kk]\n        if(a[0]==b[0]):\n            if((100000,100000) in d.keys()):\n                d[(100000,100000)].add(a[0])\n            else:\n                d[(100000, 100000)]={a[0]}\n        elif(a[1]==b[1]):\n            if(0,1) in d.keys():\n                d[(0,1)].add(a[1])\n            else:\n                d[(0,1)]={a[1]}\n        else:\n            c=b[1]-a[1]\n            dd=b[0]-a[0]\n            q=math.gcd(c,dd)\n            c1=c//q\n            d1=dd//q\n            r=(a[0]*b[1])-(a[1]*b[0])\n            if(r!=0):\n                rr=math.gcd(r,dd)\n                r=r//rr\n                d2=dd//rr\n                if(d2<0):\n                    d2=-d2\n                    r=-r\n                if(d1<0):\n                    d1=-d1\n                    c1=-c1\n                if((c1,d1) in d.keys() ):\n                    d[(c1,d1)].add((r,d2))\n                else:\n                    d[(c1,d1)]={(r,d2)}\n            else:\n                if (d1 < 0):\n                    d1 = -d1\n                    c1 = -c1\n                if ((c1, d1) in d.keys()):\n                    d[(c1, d1)].add((0,1))\n                else:\n                    d[(c1, d1)] = {(0,1)}\ns=0\nfor i in d.keys():\n    s=s+(len(d[i]))\nss=0\nfor i in d.keys():\n    s=s-(len(d[i]))\n    ss=ss+(s*len(d[i]))\nprint(ss)", "n = int(input())\nT = []\nP = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    T.append([x, y])\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = T[i]\n        x2, y2 = T[j]\n        a = y2 - y1\n        b = x1 - x2\n        c = -(a * x1 + b * y1)\n        if a != 0:\n            b /= a\n            c /= a\n            a = 1\n        else:\n            a = 0\n            c /= b\n            b = 1\n        P.append([a, b, c])\nP.sort()\nnewp = [P[0]]\nfor i in range(len(P) - 1):\n    if P[i] != P[i + 1]:\n        newp.append(P[i + 1])\nP = newp\nwas = []\nsos = dict()\nfor a, b, c in P:\n    if b != 0 and a != 0:\n        z = a / b\n    elif a == 0:\n        z = 'kek'\n    else:\n        z = 'lol'\n    if z not in sos:\n        sos[z] = 1\n    else:\n        sos[z] += 1\nsus = 0\nsussqua = 0\nfor i in sos:\n    sus += sos[i]\n    sussqua += sos[i] ** 2\nprint((sus ** 2 - sussqua) // 2)", "n = int(input())\nT = []\nP = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    T.append([x, y])\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = T[i]\n        x2, y2 = T[j]\n        a = y2 - y1\n        b = x1 - x2\n        c = -(a * x1 + b * y1)\n        if a != 0:\n            b /= a\n            c /= a\n            a = 1\n        else:\n            a = 0\n            c /= b\n            b = 1\n        P.append([a, b, c])\nP.sort()\nnewp = [P[0]]\nfor i in range(len(P) - 1):\n    if P[i] != P[i + 1]:\n        newp.append(P[i + 1])\nP = newp\nsos = dict()\nfor a, b, c in P:\n    if b != 0 and a != 0:\n        z = a / b\n    elif a == 0:\n        z = 'kek'\n    else:\n        z = 'lol'\n    if z not in sos:\n        sos[z] = 1\n    else:\n        sos[z] += 1\nsus = 0\nsussqua = 0\nfor i in sos:\n    sus += sos[i]\n    sussqua += sos[i] ** 2\nprint((sus ** 2 - sussqua) // 2)", "import sys\nimport math\nfrom pprint import pprint\n\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\np.sort()\ns = {}\nfor i in range(n):\n    x1, y1 = p[i]\n    for j in range(i + 1, n):\n        x2, y2 = p[j]\n        slope = 0\n        cons = 0\n        if x1 - x2 == 0:\n            slope = sys.maxsize\n            cons = x1\n        else:\n            slope = (y2 - y1) / (x2 - x1)\n            cons = (y1 * x2 - x1 * y2) / (x2 - x1)\n        if slope in s:\n            if cons in s[slope]:\n                s[slope][cons] += 1\n            else:\n                s[slope][cons] = 1\n        else:\n            s[slope] = {cons: 1}\nans = 0\ncnt = 0\n\nfor x in s:\n    ans += cnt * len(s[x])\n    cnt += len(s[x])\nprint(ans)\n", "import sys\nimport collections\nimport math\nimport heapq\nfrom operator import itemgetter\n\ndef getint():\n    return int(input())\n\ndef getints():\n    return [int(x) for x in input().split(' ')]\n\nn = getint()\npoints = [tuple(getints()) for _ in range(n)]\nresult = total = 0\n\nslopes = collections.defaultdict(set)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        x1, y1, x2, y2 = points[i][0], points[i][1], points[j][0], points[j][1]\n        a, b = y1 - y2, x1 - x2\n\n        d = math.gcd(a, b)\n        a, b = a // d, b // d\n        if a < 0 or (a == 0 and b < 0):\n            a, b = -a, -b\n        \n        c = a * x1 - b * y1\n        slope = (a, b)\n        if c not in slopes[slope]:\n            total += 1\n            slopes[slope].add(c)\n            result += total - len(slopes[slope])\n\nprint(str(result))", "# AC\nimport sys\nfrom math import gcd\n\n\nclass Main:\n    def __init__(self):\n        self.buff = None\n        self.index = 0\n\n    def __next__(self):\n        if self.buff is None or self.index == len(self.buff):\n            self.buff = self.next_line()\n            self.index = 0\n        val = self.buff[self.index]\n        self.index += 1\n        return val\n\n    def next_line(self):\n        return sys.stdin.readline().split()\n\n    def next_ints(self):\n        return [int(x) for x in sys.stdin.readline().split()]\n\n    def next_int(self):\n        return int(next(self))\n\n    def solve(self):\n        n = self.next_int()\n        pr = [(self.next_int(), self.next_int()) for _ in range(0, n)]\n        ks = {}\n        ct = 0\n        res = 0\n        ls = set()\n        for i in range(0, n):\n            for j in range(i + 1, n):\n                dy = pr[j][1] - pr[i][1]\n                dx = pr[j][0] - pr[i][0]\n                if dx < 0:\n                    dx *= -1\n                    dy *= -1\n                elif dx == 0:\n                    dy = abs(dy)\n                g = gcd(abs(dx), abs(dy))\n                k = (dx // g, dy // g)\n                x, y = pr[i][0], pr[i][1]\n                if dx == 0:\n                    a = (pr[i][0], 0)\n                else:\n                    cl = abs(x) // k[0]\n                    if x >= 0:\n                        x -= cl * k[0]\n                        y -= cl * k[1]\n                    else:\n                        x += cl * k[0]\n                        y += cl * k[1]\n                        while x < 0:\n                            x += k[0]\n                            y += k[1]\n                    a = (x, y)\n                if (k, a) in ls:\n                    continue\n                else:\n                    ls.add((k, a))\n                ct += 1\n                if k not in ks:\n                    ks[k] = 1\n                else:\n                    ks[k] += 1\n                res += ct - ks[k]\n        print(res)\n\n\ndef __starting_point():\n    Main().solve()\n\n__starting_point()", "from functools import reduce\nfrom math import gcd\nimport collections\n\ngcdm = lambda *args: reduce(gcd, args, 0)\n\n\ndef pointsToLine2d(p1, p2):\n    if p1 == p2:\n        return (0, 0, 0)\n    _p1, _p2 = sorted((p1, p2))\n    g = gcdm(*[x for x in (_p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]) if x != 0])\n    return ((_p2[1] - _p1[1]) // g, (_p1[0] - _p2[0]) // g, (_p1[1] * _p2[0] - _p1[0] * _p2[1]) // g)\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    p = []\n    for _ in range(n):\n        p.append(read_int_array())\n\n    lines = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            lines.add(pointsToLine2d(p[i], p[j]))\n\n    k = len(lines)\n    ax_bx = collections.defaultdict(int)\n    out = 0\n    for a, b, _ in lines:\n        ax_bx[a, b] += 1\n    for x in list(ax_bx.values()):\n        out += (k - x) * x\n    write(out // 2)\n\nmain()\n", "from functools import reduce\nfrom math import gcd\nimport collections\n\ngcdm = lambda *args: reduce(gcd, args, 0)\n\n\ndef pointsToLine2d(p1, p2):\n    if p1 == p2:\n        return 0, 0, 0\n    p1, p2 = sorted((p1, p2))\n    a, b, c = p2[1] - p1[1], p1[0] - p2[0], p1[1] * p2[0] - p1[0] * p2[1]\n    g = gcdm(*[x for x in (a, b, c) if x != 0])\n    return a // g, b // g, c // g\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    p = []\n    for _ in range(n):\n        p.append(read_int_array())\n\n    lines = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            lines.add(pointsToLine2d(p[i], p[j]))\n\n    k = len(lines)\n    ax_bx = collections.defaultdict(int)\n    out = 0\n    for a, b, _ in lines:\n        ax_bx[a, b] += 1\n    for x in list(ax_bx.values()):\n        out += (k - x) * x\n    write(out // 2)\n\nmain()\n", "from sys import stdin,stdout\nimport math\nfrom itertools import accumulate\n\n\ndef getabc(x1,y1,x2,y2):\n\tt1=x2-x1;t2=y2-y1;t3=y1*x2-y2*x1\n\tif t1<0:\n\t\tt1=t1*(-1);t2=t2*(-1);t3=t3*(-1)\n\tt4=math.gcd(math.gcd(t1,t2),t3)\n\treturn t1//t4,t2//t4,t3//t4\n\nn=int(stdin.readline())\nx=[];y=[]\nfor i in range(n):\n\txi,yi=stdin.readline().strip().split(' ')\n\tx.append(int(xi));y.append(int(yi))\n\nd={}\nthere={}\nfor i in range(len(x)):\n\tfor j in range(i+1,len(x)):\n\t\tnum=y[i]-y[j]\n\t\tden=x[i]-x[j]\n\t\tif num==0:\n\t\t\tkey='yintercept'+str(y[i])\n\t\t\tif key not in d:\n\t\t\t\td[key]=1\n\t\telif den==0:\n\t\t\tkey='xintercept'+str(x[i])\n\t\t\tif key not in d:\n\t\t\t\td[key]=1\n\t\telse:\n\t\t\ta,b,c=getabc(x[i],y[i],x[j],y[j])\n\t\t\tkey=str(a)+' '+str(b)+' '+str(c)\n\t\t\tkeys=str(a)+' '+str(b)\n\t\t\tif key not in there:\n\t\t\t\tif keys in d:\n\t\t\t\t\td[keys]+=1\n\t\t\t\telse:\n\t\t\t\t\td[keys]=1\n\t\t\t\tthere[key]=1\n\n\nansarr=[0,0] # [lines parallel to y-axis , lines parallel to x axis]\nfor i in d:\n\tif i[0]=='x':\n\t\tansarr[0]+=1\n\telif i[0]=='y':\n\t\tansarr[1]+=1\n\telse:\n\t\tansarr.append(d[i])\n\nans=0;\ntarr=sum(ansarr)\nfor i in range(len(ansarr)):\n\tans+=(tarr-ansarr[i])*ansarr[i]\nstdout.write(str(ans//2)+'\\n')\n\n\n\n\n\n\n\n\n", "from collections import defaultdict\nimport math\n\nn = int(input().lstrip())\nnumbers = []\n\nfor _ in range(n):\n    numbers.append(list(map(int, input().lstrip().split())))\n\n\ndef gcd(a, b):\n    if not a:\n        return b\n    return gcd(b % a, a)\n\n\nslope_map = defaultdict(set)\ntotal = 0\nres = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = numbers[i]\n        x2, y2 = numbers[j]\n        a = y1 - y2\n        b = x1 - x2\n        d = gcd(a, b)\n        a //= d\n        b //= d\n        if a < 0 or (not a and b < 0):\n            a *= -1\n            b *= -1\n        slope = (a, b)\n        c = a * x1 - b * y1\n        if c not in slope_map[slope]:\n            total += 1\n            slope_map[slope].add(c)\n            res += total - len(slope_map[slope])\nprint(res)\n", "from itertools import combinations\n\nn = int(input())\n\npoints = []\nfor _ in range(n):\n    x, y = list(map(int, input().split(' ')))\n    points.append((x, y))\n\ndirections = {}\nfor pair in combinations(points, 2):\n    (x1, y1), (x2, y2) = pair\n    if x1 == x2:\n        dir = (0, 1)\n        b = x1\n    else:\n        dir = (1, (y2 - y1) / (x2 - x1))\n        b = (y2 * x1 - x2 * y1) / (x1 - x2)\n\n    if dir in directions:\n        directions[dir].add(b)\n    else:\n        directions[dir] = set([b])\n\ntotal_lines = sum(len(value) for key, value in list(directions.items()))\n\nresult = 0\nfor key, value in list(directions.items()):\n    current = len(value)\n    result += (total_lines - current) * current\n\nprint(int(result / 2))\n", "def gcd(a,b):\n    while b:\n        a, b = b, a%b\n    return a\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\n\nfor x in C.values():\n    res += (ss-x)*x\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)", "def gcd(a,b):\n    if not b: return a\n    return gcd(b, a%b)\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\n\nfor x in C.values():\n    res += (ss-x)*x\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)", "def gcd(a,b):\n    if not b: return a\n    return gcd(b, a%b)\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\n\nfor x in C.values():\n    res += (ss-x)*x\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)", "from math import gcd\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nfrom collections import defaultdict as dd, deque\n\nL = list(set(L))\nres = 0\n\nC = dd(int)\nfor x,y,dx,dy in L:\n    C[dx,dy] += 1\n\nss = sum(C.values())\n\nfor x in C.values():\n    res += (ss-x)*x\n\n#for i in range(len(L)):\n#    for j in range(i+1, len(L)):\n#        x1,y1,dx1,dy1 = L[i]\n#        x2,y2,dx2,dy2 = L[j]\n#        if dx1 != dx2 or dy1 != dy2:\n#            #print(L[i])\n#            #print(L[j])\n#            #print('---')\n#            res += 1\n\nprint(res//2)"]
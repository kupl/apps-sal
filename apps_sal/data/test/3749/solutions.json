["#!/usr/bin/env python3\ndef divmod(f, g):\n    assert g\n    h = 0\n    for i in reversed(list(range(f.bit_length() - g.bit_length() + 1))):\n        if f & (1 << (g.bit_length() + i - 1)):\n            f ^= g << i\n            h ^= 1 << i\n    return h, f\n\ndef gcd(f, g):\n    while g:\n        q, r = divmod(f, g)\n        f, g = g, r\n    return f\n\nimport functools\ndef solve(n, x, a):\n    # (g) = (a_1, ..., a_n) is a principal ideal since F_2[x] is a PID\n    g = functools.reduce(gcd, a)\n\n    # count h in F_2[x] s.t. h g <= x\n    cnt = 0\n    h = 0\n    for k in reversed(list(range(x.bit_length() - g.bit_length() + 1))):\n        bit = 1 << (g.bit_length() + k - 1)\n        if (x & bit):\n            cnt += 1 << k\n        if (x & bit) != (h & bit):\n            h ^= g << k\n    cnt += (h <= x)\n    return cnt % 998244353\n\n\ndef main():\n    n, x = input().split()\n    n = int(n)\n    x = int(x, 2)\n    a = [ int(input(), 2) for _ in range(n) ]\n    print((solve(n, x, a)))\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\nbase=[]\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    base.append(a<<i)\n\nfor i in range(0,N-1):\n    a=A[i]\n    for j in range(M):\n        for b in base:\n            a=min(a,a^b)\n        if a==0:\n            break\n        else:\n            base.append(a)\n            a=a<<1\n\ndata=[0]*(M+1)\ndata2=[0]*(M+1)\nfor b in base:\n    data[b.bit_length()-1]=b\n    data2[b.bit_length()-1]=1\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)\n", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nn,x = readline().split()\nn = int(n)\nx = int(x,2)\n*a, = [int(x,2) for x in read().split()]\n\ndef gcd(a,b):\n    c = 0\n    while b:\n        if a < b:\n            a,b = b,a\n            continue\n        a ^= b<<(a.bit_length() - b.bit_length())\n    return a\n\nv = 0\nfor ai in a: v = gcd(ai,v)\n\nMOD = 998244353\np2 = [1]\nfor _ in range(5000): p2.append(p2[-1]*2%MOD)\n\ndv = v.bit_length()\ndx = x.bit_length()\n\ndef dfs(x,y,d):\n    if d < dv:\n        return int(x >= y)\n    else:\n        bx = x>>(d-1)&1\n        by = y>>(d-1)&1\n        if bx and by:\n            return (p2[d-dv] + dfs(x,y,d-1)) %MOD\n        elif not bx and by:\n            return dfs(x,y^(v<<(d-dv)),d-1)\n        elif not by and bx:\n            return (p2[d-dv] + dfs(x,y^(v<<(d-dv)),d-1)) %MOD\n        else:\n            return dfs(x,y,d-1)\n\nprint((dfs(x,0,dx)))\n\n\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef gcd(a,b):\n    if b==0:return a\n    if a<b:a,b=b,a\n    k=a.bit_length()-b.bit_length()\n    return gcd(b,a^(b<<k))\n\ndef main():\n    md=998244353\n    n,x=input().split()\n    x=int(x,2)\n    aa=[input() for _ in range(int(n))]\n    aa=[int(a,2) for a in aa]\n    #bit\u3092\u591a\u9805\u5f0f\u306e\u4fc2\u6570\u3068\u8003\u3048\u3066\u591a\u9805\u5f0f\u306eGCD\u3092\u6c42\u3081\u308b\n    g=aa[0]\n    for a in aa[1:]:\n        g=gcd(g,a)\n    #print(bin(g))\n    #GCD\u306e\u6841\u6570\u4ee5\u4e0a\u306f\u81ea\u7531\u306b\u6c7a\u3081\u3089\u308c\u308b\u306e\u3067\u305d\u306e\u5206\u3092\u7b54\u3048\u306b\n    ans=x>>(g.bit_length()-1)\n    s=0\n    # GCD\u306e\u6841\u6570\u4ee5\u4e0a\u3092x\u3068\u540c\u3058\u306b\u3057\u305f\u5834\u5408\u306bx\u4ee5\u4e0b\u306b\u306a\u308b\u3088\u3046\u3067\u3042\u308c\u3070\u305d\u306e\u5206\u3082\u8db3\u3059\n    while 1:\n        k=(x^s).bit_length()-g.bit_length()\n        #print(k,bin(x^s),bin(x),bin(s))\n        if k<0:break\n        s^=g<<k\n    if s<=x:ans+=1\n    print(ans%md)\n\nmain()", "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\ndata=[0]*(M+1)\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    data[i+n]=a<<i\n\nlow=n\nfor i in range(0,N-1):\n    a=A[i]\n    flag=True\n    while flag:\n        n=a.bit_length()\n        for j in range(n-1,low-1,-1):\n            a=min(a,a^data[j])\n        if a!=0:\n            data[a.bit_length()-1]=a\n            id=a.bit_length()-1\n            low=id\n            while data[id+1]==0:\n                data[id+1]=min((data[id]<<1)^a,(data[id]<<1))\n                id+=1\n            else:\n                a=data[id]<<1\n        else:\n            break\n\ndata2=[0]*(M+1)\nfor i in range(M+1):\n    data2[i]=(data[i]!=0)\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)\n", "N, X = input().split()\nN = int(N); X = int(X, 2)\np = int(input(), 2)\nfor i in range(N-1):\n    v = int(input(), 2)\n    if p > v:\n        p, v = v, p\n    while 0 < p:\n        q = (v ^ (p << (v.bit_length() - p.bit_length())))\n        if p < q:\n            p, v = p, q\n        else:\n            p, v = q, p\n    p = v\n\nlx = X.bit_length()\nlp = p.bit_length()\n\nMOD = 998244353\nans = (X >> (p.bit_length() - 1)) % MOD\n\nq = p << (lx - lp)\nb = 1 << (lx - 1)\n\nx = 0; y = 0\nfor k in range(lx - lp, -1, -1):\n    if b & (X ^ y):\n        y ^= q\n    b >>= 1; q >>= 1\nif y <= X:\n    ans = (ans + 1) % MOD\nprint(ans)", "import random\n\nmod=998244353\nN,X=input().split()\nN=int(N)\nA=[]\nfor i in range(N):\n    A.append(int(input(),2))\nA.sort()\n\na=A[-1]\nM=max(len(X)-1,a.bit_length()-1)\ndata=[0]*(M+1)\nn=a.bit_length()-1\nfor i in range(M-n,-1,-1):\n    data[i+n]=a<<i\n\nfor i in range(0,N-1):\n    a=A[i]\n    flag=True\n    while flag:\n        n=a.bit_length()\n        for j in range(n-1,-1,-1):\n            a=min(a,a^data[j])\n        if a!=0:\n            data[a.bit_length()-1]=a\n            id=a.bit_length()-1\n            while data[id+1]==0:\n                data[id+1]=min((data[id]<<1)^a,(data[id]<<1))\n                if data[id+1]:\n                    id+=1\n                else:\n                    flag=False\n            else:\n                a=data[id]<<1\n        else:\n            break\n\ndata2=[0]*(M+1)\nfor i in range(M+1):\n    data2[i]=(data[i]!=0)\n\nfor i in range(1,M+1):\n    data2[i]+=data2[i-1]\n\ndata2=[0]+data2\n\n#print(data)\n#print(data2)\n\nx=0\nans=0\nn=len(X)-1\nfor i in range(len(X)):\n    if X[i]==\"1\":\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                ans+=pow(2,data2[n-i],mod)\n                ans%=mod\n        else:\n            ans+=pow(2,data2[n-i],mod)\n            ans%=mod\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n    else:\n        if x>>(n-i)&1==1:\n            if data[n-i]:\n                x=x^data[n-i]\n            else:\n                break\n        else:\n            continue\nelse:\n    ans+=1\n    ans%=mod\nprint(ans)"]
["import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nlim = N+10  # \u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u308c\u308b\nfact = [1] * (lim+1)\nfact_inv = [1] * (lim+1)\nfor n in range(1, lim+1):\n    fact[n] = (fact[n-1] * n) % mod\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n    fact_inv[n-1] = (n * fact_inv[n]) % mod\n\ntree = [[] for _ in range(N+1)]  # 1-indexed\nfor _ in range(N-1):\n\ta, b = MAP()\n\ttree[a].append(b)\n\ttree[b].append(a)\n\nroot = 1\nparent = [0]*(N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in tree[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nsize_d = [0]*(N+1)\ndp_d = [1]*(N+1)\n\nfor v in order[::-1]:  # \u6839\u306b\u9060\u3044\u307b\u3046\u304b\u3089(down\u65b9\u5411\u306e\u30dc\u30c8\u30e0\u30a2\u30c3\u30d7)\n    dp_d[v] *= fact[size_d[v]]\n    dp_d[v] %= mod\n    p = parent[v]\n    s = size_d[v] + 1\n    size_d[p] += s\n    dp_d[p] *= fact_inv[s] * dp_d[v]\n    dp_d[p] %= mod\n\nsize_u = [N-1-x for x in size_d]\ndp_u = [1]*(N+1)\n\ndef merge(p1, p2):\n    den_inv1, v1 = p1\n    den_inv2, v2 = p2\n    return den_inv1*den_inv2%mod, v1*v2%mod\n\nfor v in order:\n    p = parent[v]\n    arr = [(fact_inv[size_d[node]+1], dp_d[node]) if node != p else (fact_inv[size_u[v]], dp_u[v]) for node in tree[v]]\n    left = [(1, 1)] + list(accumulate(arr, merge))[:-1]\n    right = list(accumulate(arr[::-1], merge))[-2::-1] + [(1, 1)]\n    contrib = [merge(x, y) for x, y in zip(left, right)]\n    for node, c in zip(tree[v], contrib):\n        if node != p:\n            dp_u[node] = (c[0]*c[1]*fact[size_u[node]-1])%mod\n# print(dp_u)\nfor xd, xu, sd, su in zip(dp_d[1:], dp_u[1:], size_d[1:], size_u[1:]):\n    x = xd * xu * fact[sd + su] * fact_inv[sd] * fact_inv[su] % mod\n    print(x)\n", "def hoge():\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n    sys.setrecursionlimit(max(1000, 10**9))\n\n    from collections import defaultdict\n    n = int(input())\n    ns = defaultdict(set)\n    for _ in range(n-1):\n        u,v = map(int, input().split())\n        ns[u-1].add(v-1)\n        ns[v-1].add(u-1)\n\n\n    M = 10**9+7 # \u51fa\u529b\u306e\u5236\u9650\n    N = n # \u5fc5\u8981\u306a\u30c6\u30fc\u30d6\u30eb\u30b5\u30a4\u30ba\n\n    g1 = [None] * (N+1) # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [None] * (N+1) #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [None] * (N+1) #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n    g1[0] = g1[1] = g2[0] = g2[1] = 1\n    inverse[0], inverse[1] = [0, 1] \n\n    for i in range( 2, N + 1 ):\n        g1[i] = ( g1[i-1] * i ) % M \n        inverse[i] = ( -inverse[M % i] * (M//i) ) % M # ai+b==0 mod M <=> i==-b*a^(-1) <=> i^(-1)==-b^(-1)*a\u3088\u308a\n        g2[i] = (g2[i-1] * inverse[i]) % M \n\n\n    ans = {}\n    prevs = {}\n    out = [None] * n\n    def sub(i, j, prev):\n        prevs[i,j] = prev\n        if (i,j) in ans:\n            return ans[i,j]\n        if len(ns[j])==1 and i in ns[j]:\n            ans[i,j] = (1, 1)\n            return (1, 1)\n\n        count = 1\n        sum_size = 0\n        for k in ns[j]:\n            if k==i:\n                continue\n            val, size = sub(j, k, i)\n            count = (count * val) % M\n            count = (count * g2[size]) % M\n            sum_size += size\n        count = (count * g1[sum_size]) % M\n        ans[i,j] = (count, sum_size+1)\n        return (count, sum_size+1)\n\n    def sub2(i, j, q):\n        for k in ns[j]:\n            if k==i:\n                continue\n            if (k, j) in ans:\n                continue\n            tmp_count, tmp_size = ans[j, k]\n            total_count, total_size = ans[prevs[j, k], j]\n            prev_count, prev_size = ans[j, i]\n            new_size = total_size - tmp_size + prev_size\n            new_count = (total_count * g2[total_size-1] * g1[new_size-1]) % M\n            new_count = (new_count * prev_count * pow(tmp_count, M-2, M)) % M\n            new_count = (new_count * g2[prev_size] * g1[tmp_size]) % M\n            ans[k, j] = (new_count, new_size)\n            val = tmp_count\n            val = (val * new_count * g1[new_size+tmp_size-1] * g2[tmp_size-1] * g2[new_size]) % M\n            out[k] = val\n            q.appendleft((j, k))\n#             sub2(j, k)\n    #         print(\"total: \", total_count, total_size)\n    #         print(\"tmp: \", tmp_count, tmp_size)\n    #         print(\"prev: \", prev_count, prev_size)\n    #         new_count = total_count / g1[total_size-1] * g1[new_size-1] * prev_count / tmp_count / g1[prev_size] * g1[tmp_size]\n    #         print(new_count)\n    #         print(\"\")\n\n    # 0\u3092\u59cb\u70b9\u3068\u3057\u3066\u6728DP\n    sub(-1, 0, None)\n\n    ans[0, -1] = (1,0)\n\n    # \u9006\u5411\u304d\u3092\u6c42\u3081\u308b\n    from queue import deque\n    q = deque()\n    q.appendleft((-1, 0))\n    while q:\n        u, v = q.pop()\n        sub2(u, v, q)\n    \n    u = 0\n    count = 1\n    sum_size = 0\n    for k in ns[u]:\n        val, size = ans[u, k] # sub(u, k, None)\n        count = (count * val) % M\n        count = (count * g2[size]) % M\n        sum_size += size\n    count = (count * g1[sum_size]) % M\n    out[0] = count\n    return out\nout = hoge()\nprint(\"\\n\".join(map(str, out)))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    MOD = 10**9 + 7\n\n    N = int(input())\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list(map(int, input().split()))\n        a, b = a-1, b-1\n        adjL[a].append(b)\n        adjL[b].append(a)\n\n    def getFacts(n, MOD):\n        facts = [1] * (n+1)\n        for x in range(2, n+1):\n            facts[x] = (facts[x-1] * x) % MOD\n        return facts\n    facts = getFacts(N, MOD)\n    def getInvFacts(n, MOD):\n        invFacts = [0] * (n+1)\n        invFacts[n] = pow(facts[n], MOD-2, MOD)\n        for x in reversed(list(range(n))):\n            invFacts[x] = (invFacts[x+1] * (x+1)) % MOD\n        return invFacts\n    invFacts = getInvFacts(N, MOD)\n\n    def getComb(n, k, MOD):\n        if n < k:\n            return 0\n        return facts[n] * invFacts[k] * invFacts[n-k] % MOD\n\n    dp = [1] * N\n    sizes = [0] * N\n    def dfsDP(v, vPar):\n        sizes[v] = 0\n        for v2 in adjL[v]:\n            if v2 == vPar: continue\n            dp[v] = dp[v] * dfsDP(v2, v) % MOD\n            sizes[v] += sizes[v2]\n            dp[v] = dp[v] * getComb(sizes[v], sizes[v2], MOD) % MOD\n        sizes[v] += 1\n        return dp[v]\n\n    anss = [0] * N\n    def dfsAns(v, vPar, resPar):\n        anss[v] = dp[v] * resPar * getComb(N-1, sizes[v]-1, MOD) % MOD\n\n        for v2 in adjL[v]:\n            if v2 == vPar: continue\n            coef = dp[v2] * getComb(N-1, sizes[v2], MOD) % MOD\n            dfsAns(v2, v, anss[v] * pow(coef, MOD-2, MOD) % MOD)\n\n\n    dfsDP(0, -1)\n    dfsAns(0, -1, 1)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "def rerooting(n, edges, identity, merge, add_node):\n    # \u5168\u65b9\u4f4d\u6728 dp\n    # \u53c2\u8003: https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n    G = [[] for _ in range(n)]\n    G_idxs = [[] for _ in range(n)]  # \u81ea\u5206\u3092\u6307\u3059\u30ce\u30fc\u30c9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    for a, b in edges:\n        G_idxs[a].append(len(G[b]))\n        G_idxs[b].append(len(G[a]))\n        G[a].append(b)\n        G[b].append(a)\n    # step 1\n    parents = [0] * n\n    order = []  # \u884c\u304d\u304c\u3051\u9806\n    stack = [0]\n    parents[0] = -1\n    while stack:\n        v = stack.pop()\n        p = parents[v]\n        order.append(v)\n        for u in G[v]:\n            if p != u:\n                stack.append(u)\n                parents[u] = v\n    subtree_res = [[0]*len(Gv) for Gv in G]\n    # \u4e0b\u304b\u3089\u767b\u308b\n    for v in order[:0:-1]:\n        p = parents[v]\n        result = identity\n        for idx_Gv, (u, subtree_res_v_i) in enumerate(zip(G[v], subtree_res[v])):\n            if p == u:\n                parent_idx = idx_Gv\n            else:\n                result = merge(result, subtree_res_v_i)\n        idx_p2v = G_idxs[v][parent_idx]\n        subtree_res[p][idx_p2v] = add_node(result, v)\n    # step 2\n    # \u4e0a\u304b\u3089\u964d\u308a\u308b\n    results = [0] * n\n    for v in order:\n        subtree_res_v = subtree_res[v]\n        cum = identity\n        cum_from_tail = [identity]\n        for r in subtree_res_v[:0:-1]:\n            cum = merge(r, cum)\n            cum_from_tail.append(cum)\n        cum_from_tail.reverse()\n        cum = identity\n        for r, cum_t, u, idx_u2v in zip(subtree_res_v, cum_from_tail, G[v], G_idxs[v]):\n            result = add_node(merge(cum, cum_t), v)\n            subtree_res[u][idx_u2v] = result\n            cum = merge(cum, r)\n        results[v] = add_node(cum, v)\n    return results\n\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\ndef main():\n    N = int(input())\n    AB = [list([int(x)-1 for x in input().split()]) for _ in range(N-1)]\n    mod = 10**9 + 7\n    comb = Combination(202020)\n    identity = (1, 0)\n    merge = lambda a, b: (a[0] * b[0] % mod * comb(a[1]+b[1], a[1]) % mod, a[1] + b[1])\n    add_node = lambda value, idx: (value[0], value[1]+1)\n    Ans = rerooting(N, AB, identity, merge, add_node)\n    print((\"\\n\".join(str(ans) for ans, _ in Ans)))\n\nmain()\n", "from collections import deque\n\n\nmod = 10 ** 9 + 7\nSIZE = 2 * 10 ** 5 + 1\nfact = [0] * SIZE\ninv = [0] * SIZE\nfinv = [0] * SIZE\nfact[0], fact[1] = 1, 1\ninv[1] = 1\nfinv[0], finv[1] = 1, 1\nfor i in range(2, SIZE):\n    fact[i] = fact[i - 1] * i % mod\n    inv[i] = mod - inv[mod % i] * (mod // i) % mod\n    finv[i] = finv[i - 1] * inv[i] % mod\n\n\ndef nCr(n, r):\n    if n < 0 or r < 0 or n < r:\n        return 0\n    return fact[n] * (finv[r] * finv[n - r] % mod) % mod\n\n\nn = int(input())\nedges = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\nroot_to_leaf = []\nparents = [0] * n\n\ntodo = deque([])\nfor to in edges[0]:\n    todo.append([to, 0])\n\nwhile todo:\n    node, parent = todo.popleft()\n    root_to_leaf.append(node)\n    parents[node] = parent\n\n    for to in edges[node]:\n        if to == parent:\n            continue\n        todo.append([to, node])\n\nsize_of_subtree = [0] * n\npattern_in_subtree = [1] * n\n\nfor node in root_to_leaf[::-1]:\n    parent = parents[node]\n    size_of_subtree[node] += 1\n    size_of_subtree[parent] += size_of_subtree[node]\n    pattern_in_subtree[parent] *= nCr(size_of_subtree[parent], size_of_subtree[node]) * pattern_in_subtree[node] % mod\n    pattern_in_subtree[parent] %= mod\n\nanswers = [0] * n\nanswers[0] = pattern_in_subtree[0]\n\nfor node in root_to_leaf:\n    parent = parents[node]\n    ans = answers[parent] * size_of_subtree[node] * inv[n - size_of_subtree[node]] % mod\n    answers[node] = ans\n\nfor ans in answers:\n    print(ans)\n", "n = int(input()); arr = [list(map(int,input().split())) for _ in range(n-1)]\n\ngraph = [[] for _ in range(n)]\nfor a,b in arr:\n    graph[a-1].append(b-1); graph[b-1].append(a-1)\n\nparents = [-1]*n\nchildren = [[] for _ in range(n)]\norders = []\nstack = [0]\nflags = [True] * n; flags[0] = False\nwhile stack:\n    tmp = stack.pop()\n    orders.append(tmp)\n    for node in graph[tmp]:\n        if flags[node]:\n            flags[node] = False\n            children[tmp].append(node)\n            stack.append(node)\n            parents[node] = tmp\n\nmod = 10**9+7\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nifac = [1]*(n+1)\nfor i in range(2,n+1):\n    fac[i] = fac[i-1] * i % mod\n    inv[i] = (- (mod//i)*inv[(mod%i)]) % mod\n    ifac[i] = ifac[i-1] * inv[i] % mod\n\nsize = [1] * n;dp = [1] * n\nfor parent in orders[::-1]:\n    for child in children[parent]:\n        size[parent] += size[child]\n        dp[parent] = dp[parent] * dp[child] * ifac[size[child]] % mod\n    dp[parent] = dp[parent] * fac[size[parent]-1] % mod\n\nsize2 = [n-i+1 for i in size];dp2 = [1] * n; dp2[0] = dp[0]\nfor parent in orders[1:]:\n    child = parents[parent]\n    dp2[parent] = dp2[parent] * size[parent] * dp2[child] * inv[size2[parent]-1] % mod\n    \nfor i in range(n):\n    print(dp2[i])", "import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\n\nMOD = 10 ** 9 + 7\n\n\nN = int(input())\n\nc = Factorial(N + 2, MOD)\n\nG = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nedge_num = [len(G[i]) for i in range(N + 1)]\n\nque = deque()\ncheck = [0] * (N + 1)\norder = []\no_append =order.append\nq_pop = que.pop\nq_append = que.append\n\nq_append((1, 0))\ncheck[1] = 1\nwhile que:\n    now = q_pop()\n    o_append(now)\n    for next_ in G[now[0]]:\n        if check[next_] == 0:\n            q_append((next_, now[0]))\n            check[next_] = 1\n\n# print (order)\n\nsize1 = [0] * (N + 1) #\u81ea\u8eab\u3092\u9802\u70b9\u3068\u3059\u308b\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3001\u6728\u306e\u6839\u306f\u9802\u70b90\ndp1 = [1] * (N + 1)\nfor child, parent in order[::-1]:\n    dp1[child] *= c.factorial(size1[child])\n    dp1[child] %= MOD\n    s = size1[child] + 1\n    size1[parent] += s\n    dp1[parent] *= c.ifactorial(s) * dp1[child]\n    dp1[parent] %= MOD\n\n# print (size1)\n# print (dp1)\n\nsize2 = [N - 2 - x for x in size1]\ndp2 = [1] * (N + 1)\n\n# print (size1)\n# print (size2)\nfor child, parent in order[1:]:\n    x = dp1[parent]\n    x *= dp2[parent]\n    x *= c.ifactorial(size1[parent])\n    x *= c.factorial(size1[child] + 1)\n    x *= pow(dp1[child], MOD - 2, MOD) #\u5272\u308a\u7b97\n    x *= c.factorial(size2[child])\n    x *= c.ifactorial(size2[parent] + 1)\n    dp2[child] = x % MOD\n\n# print (dp2)\n\nfor x1, x2, s1, s2 in zip(dp1[1:], dp2[1:], size1[1:], size2[1:]):\n    s2 += 1\n    x = x1 * x2 * c.factorial(s1 + s2) * c.ifactorial(s1) * c.ifactorial(s2) % MOD\n    print (x)", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nlim = N+10  # \u5fc5\u8981\u305d\u3046\u306a\u968e\u4e57\u306e\u9650\u754c\u3092\u5165\u308c\u308b\nfact = [1] * (lim+1)\nfact_inv = [1] * (lim+1)\nfor n in range(1, lim+1):\n    fact[n] = (fact[n-1] * n) % mod\nfact_inv[lim] = pow(fact[lim], mod-2, mod)\nfor n in range(lim, 0, -1):\n    fact_inv[n-1] = (n * fact_inv[n]) % mod\n\ntree = [[] for _ in range(N+1)]  # 1-indexed\nfor _ in range(N-1):\n\ta, b = MAP()\n\ttree[a].append(b)\n\ttree[b].append(a)\n\nroot = 1\nparent = [0]*(N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in tree[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nsize_d = [0]*(N+1)\ndp_d = [1]*(N+1)\n\nfor v in order[::-1]:  # \u6839\u306b\u9060\u3044\u307b\u3046\u304b\u3089(down\u65b9\u5411\u306e\u30dc\u30c8\u30e0\u30a2\u30c3\u30d7)\n    dp_d[v] *= fact[size_d[v]]\n    dp_d[v] %= mod\n    p = parent[v]\n    s = size_d[v] + 1\n    size_d[p] += s\n    dp_d[p] *= fact_inv[s] * dp_d[v]\n    dp_d[p] %= mod\n\nsize_u = [N-1-x for x in size_d]\ndp_u = [1]*(N+1)\n\ndef merge(p1, p2):\n    den_inv1, v1 = p1\n    den_inv2, v2 = p2\n    return den_inv1*den_inv2%mod, v1*v2%mod\n\nfor v in order:\n    p = parent[v]\n    arr = [(fact_inv[size_d[node]+1], dp_d[node]) if node != p else (fact_inv[size_u[v]], dp_u[v]) for node in tree[v]]\n    left = [(1, 1)] + list(accumulate(arr, merge))[:-1]\n    right = list(accumulate(arr[::-1], merge))[-2::-1] + [(1, 1)]\n    contrib = [merge(x, y) for x, y in zip(left, right)]\n    for node, c in zip(tree[v], contrib):\n        if node != p:\n            dp_u[node] = (((c[0]*c[1])%mod)*fact[size_u[node]-1])%mod\n# print(dp_u)\nfor xd, xu, sd, su in zip(dp_d[1:], dp_u[1:], size_d[1:], size_u[1:]):\n    x = xd * xu * fact[sd + su] * fact_inv[sd] * fact_inv[su] % mod\n    print(x)\n", "import sys\nsys.setrecursionlimit(10**6)\nfrom collections import deque\nMOD = 1000000007\n\nN =  int(input())\nchilds = [[] for i in range(N+1)]\nfor i in range(N-1):\n    a, b = list(map(int, input().split()))\n    childs[a].append(b)\n    childs[b].append(a)\n\ndp = [0] * (N + 1) # represent the # if i is the root (1)\ntree_size = [0]*(N + 1)\nans = [0] * (N + 1)\n\nn_inv = [1, 1]\nn_j_mod = [1, 1]\n\nfor i in range(2, N+1):\n    n_inv.append((pow(i, MOD-2, MOD) * n_inv[-1]) % MOD)\n    n_j_mod.append((n_j_mod[-1] * i) % MOD)\n\n\ndef dfs(i, father=-1):\n    method_num = 1\n    t_size = 1\n    for child in childs[i]:\n        if child != father:\n            num, size = dfs(child, i)\n            method_num = (method_num * num * n_inv[size]) % MOD\n            t_size += size\n    method_num = (method_num * n_j_mod[t_size - 1]) % MOD\n    dp[i] = method_num\n    tree_size[i] = t_size\n    return method_num, t_size\n\ndef rdfs(i, f_num, father=-1):\n    ans[i] = (dp[i] * f_num * n_j_mod[N-1] * n_inv[N - tree_size[i]] * n_inv[tree_size[i] - 1]) % MOD\n\n    for child in childs[i]:\n        if child != father:\n            cf_num = (ans[i] * n_j_mod[tree_size[child]] * n_j_mod[N - tree_size[child] - 1] * n_inv[N - 1] * pow(dp[child], MOD-2, MOD)) % MOD\n            rdfs(child, cf_num, i)\ndfs(1)\n\nrdfs(1, 1)\nprint(('\\n'.join(list(map(str, ans[1:])))))\n", "import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\ndef main():\n    n=int(input())\n    def cmb(n, r, mod):\n        if ( r<0 or r>n ):\n            return 0\n        r = min(r, n-r)\n        return g1[n] * g2[r] * g2[n-r] % mod\n    mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n    for i in range( 2, n + 1 ):\n        g1.append( ( g1[-1] * i ) % mod )\n        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n    ki=[[] for _ in range(n)]\n    for _ in range(n-1):\n        a,b=map(int,input().split())\n        a,b=a-1,b-1\n        ki[a].append(b)\n        ki[b].append(a)\n    memo={} # memo[(p,v)]:p->v\u306e\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3001\u6574\u6570\u306e\u66f8\u304d\u65b9\n    def dfs(p,v):\n        if (p,v) in memo:return memo[(p,v)]\n        size,pat=0,1\n        tmps,tmpp=1,1\n        deg=len(ki[v])\n        for nv in ki[v]:\n            if nv==p:continue\n            si,pi=dfs(v,nv)\n            size+=si\n            tmps*=g2[si]\n            tmps%=mod\n            tmpp*=pi\n            tmpp%=mod\n        pat=(g1[size]*tmps*tmpp)%mod\n        memo[(p,v)]=(size+1,pat)\n        return (size+1,pat)\n    ans=[0]*n\n    def bfs(p,v,res):\n        if p!=-1:memo[(v,p)]=res\n        deg=len(ki[v])\n        tmps,tmpp=1,1\n        for i in range(deg):\n            si,pi=memo[(v,ki[v][i])]\n            tmps*=g2[si]\n            tmpp*=pi\n            tmps%=mod\n            tmpp%=mod\n\n        ans[v]=g1[n-1]*tmps*tmpp\n        ans[v]%=mod\n\n        dpl=[1]*(deg+1)\n        dpr=[1]*(deg+1)\n        tmp=1\n        for i in range(deg):\n            si,pi=memo[(v,ki[v][i])]\n            tmp*=pi*g2[si]\n            tmp%=mod\n            dpl[i+1]=tmp\n        tmp=1\n        for i in range(deg-1,-1,-1):\n            si,pi=memo[(v,ki[v][i])]\n            tmp*=pi*g2[si]\n            tmp%=mod\n            dpr[i]=tmp\n        for i in range(deg):\n            nv=ki[v][i]\n            if p==nv:continue\n            bfs(v,nv,(n-memo[(v,nv)][0],(g1[n-1-memo[(v,nv)][0]]*dpl[i]*dpr[i+1])%mod))\n    dfs(-1,0)\n    #print(memo)\n    bfs(-1,0,0)\n    print(*ans,sep='\\n')\n    #print(memo)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# https://atcoder.jp/contests/abc160/submissions/15902850\n# \u3092\u914d\u5217\u30a2\u30af\u30bb\u30b9\u304c\u6e1b\u308b\u3088\u3046\u306b\n\ndef rerooting(n, edges, identity, merge, add_node):\n    # \u5168\u65b9\u4f4d\u6728 dp\n    # \u53c2\u8003: https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n    G = [[] for _ in range(n)]\n    G_idxs = [[] for _ in range(n)]  # \u81ea\u5206\u3092\u6307\u3059\u30ce\u30fc\u30c9\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    for a, b in edges:\n        G_idxs[a].append(len(G[b]))\n        G_idxs[b].append(len(G[a]))\n        G[a].append(b)\n        G[b].append(a)\n    # step 1\n    parents = [0] * n\n    order = []  # \u884c\u304d\u304c\u3051\u9806\n    stack = [0]\n    parents[0] = -1\n    while stack:\n        v = stack.pop()\n        p = parents[v]\n        order.append(v)\n        for u in G[v]:\n            if p != u:\n                stack.append(u)\n                parents[u] = v\n    subtree_res = [[0]*len(Gv) for Gv in G]\n    # \u4e0b\u304b\u3089\u767b\u308b\n    for v in order[:0:-1]:\n        p = parents[v]\n        result = identity\n        for idx_Gv, (u, subtree_res_v_i) in enumerate(zip(G[v], subtree_res[v])):\n            if p == u:\n                parent_idx = idx_Gv\n            else:\n                result = merge(result, subtree_res_v_i)\n        idx_p2v = G_idxs[v][parent_idx]\n        subtree_res[p][idx_p2v] = add_node(result, v)\n    # step 2\n    # \u4e0a\u304b\u3089\u964d\u308a\u308b\n    results = [0] * n\n    for v in order:\n        subtree_res_v = subtree_res[v]\n        cum = identity\n        cum_from_tail = [identity]\n        for r in subtree_res_v[:0:-1]:\n            cum = merge(r, cum)\n            cum_from_tail.append(cum)\n        cum_from_tail.reverse()\n        cum = identity\n        for r, cum_t, u, idx_u2v in zip(subtree_res_v, cum_from_tail, G[v], G_idxs[v]):\n            result = add_node(merge(cum, cum_t), v)\n            subtree_res[u][idx_u2v] = result\n            cum = merge(cum, r)\n        results[v] = add_node(cum, v)\n    return results\n\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\ndef main():\n    N = int(input())\n    AB = [list([int(x)-1 for x in input().split()]) for _ in range(N-1)]\n    mod = 10**9 + 7\n    comb = Combination(202020)\n    identity = (1, 0)\n    fac, facinv = comb.fac, comb.facinv\n    def merge(a, b):\n        a0, a1 = a\n        b0, b1 = b\n        return a0*b0*fac[a1+b1]*facinv[a1]*facinv[b1]%mod, a1+b1\n    def add_node(a, idx):\n        a0, a1 = a\n        return a0, a1+1\n    Ans = rerooting(N, AB, identity, merge, add_node)\n    print((\"\\n\".join(str(ans) for ans, _ in Ans)))\n\nmain()\n", "import sys\nsys.setrecursionlimit(505050)\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\nN = int(input())\nG = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\n\nSiz = [0] * (N+1)\nA = [0] * (N+1)\nmod = 10**9 + 7\ncomb = Combination(202020)\ndef dfs1(v, p):\n    siz = 1\n    an_prod = 1\n    an_numer = 0\n    an_denom = 1\n    for u in G[v]:\n        if u != p:\n            s, a = dfs1(u, v)\n            siz += s\n            an_prod = an_prod * a % mod\n            an_numer += s\n            an_denom = an_denom * comb.facinv[s] % mod\n    an_numer = comb.fac[an_numer]\n    an = an_numer * an_denom % mod * an_prod % mod\n    Siz[v] = siz\n    A[v] = an\n    return siz, an\n\n_, ans = dfs1(1, 0)\n# for i in range(1, N+1):\n#     print(i, dfs1(i, 0))\n\nAns = [0] * (N+1)\nAns[1] = ans\n\ndef dfs2(v, p, an_p):\n    siz_v = Siz[v]\n    if v==1:\n        ans = A[v]\n    else:\n        ans = A[v] * comb.fac[N-1] % mod * comb.facinv[siz_v-1] % mod * an_p % mod * comb.facinv[N-siz_v] % mod\n        Ans[v] = ans\n    for u in G[v]:\n        if p != u:\n            siz_u = Siz[u]\n            an = ans * comb.facinv[N-1] % mod * comb.fac[N-1-siz_u] % mod * comb.fac[siz_u] % mod * pow(A[u], mod-2, mod) % mod\n            dfs2(u, v, an)\n\ndfs2(1, 0, None)\nprint((\"\\n\".join(map(str, Ans[1:]))))\n", "n = int(input()); arr = [list(map(int,input().split())) for _ in range(n-1)]\ngraph = [[] for _ in range(n)]\nfor a,b in arr:\n    graph[a-1].append(b-1); graph[b-1].append(a-1)\n\n\nmod = 10**9+7\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nifac = [1]*(n+1)\nfor i in range(2,n+1):\n    fac[i] = fac[i-1] * i % mod\n    inv[i] = (- (mod//i)*inv[(mod%i)]) % mod\n    ifac[i] = ifac[i-1] * inv[i] % mod\n\nparents = [-1]*n\nchildren = [[] for _ in range(n)]\norders = []\nstack = [0]\nflags = [True] * n; flags[0] = False\nwhile stack:\n    tmp = stack.pop()\n    orders.append(tmp)\n    for node in graph[tmp]:\n        if flags[node]:\n            flags[node] = False\n            children[tmp].append(node)\n            stack.append(node)\n            parents[node] = tmp\n\nsize = [1] * n\ndp = [1] * n\nfor parent in orders[::-1]:\n    for child in children[parent]:\n        size[parent] += size[child]\n        dp[parent] = dp[parent] * dp[child] * ifac[size[child]] % mod\n    dp[parent] = dp[parent] * fac[size[parent]-1] % mod\n\n\nsize2 = [n-i+1 for i in size]\ndp2 = [1] * n; dp2[0] = dp[0]\nfor parent in orders[1:]:\n    child = parents[parent]\n    dp2[parent] = dp2[parent] * size[parent] * dp2[child] * inv[size2[parent]-1] % mod\n    \nfor i in range(n):\n    print(dp2[i])", "class ReRooting(object):\n    \"\"\" \u5168\u65b9\u4f4d\u6728DP \"\"\"\n    def merge(self, a, b):\n        \"\"\" \u4e8c\u9805\u6f14\u7b97 a\u30fbb \"\"\"\n        return a * b % MOD\n\n    def adj_bu(self, accBU, v:int):\n        \"\"\"\n        Bottom-Up\u306e\u5358\u9805\u6f14\u7b97 g(accBU[v])\n\n        v: \u9802\u70b9\n        \"\"\"\n        return accBU * inv(self.SIZE[v]) % MOD\n\n    def adj_td(self, accTD, v:int, p:int):\n        \"\"\"\n        Top-Down\u306e\u5358\u9805\u6f14\u7b97 g(accTD[v])\n\n        v: \u9802\u70b9\n        p: \u89aa\n        \"\"\"\n        return accTD * inv(self.V - self.SIZE[v]) % MOD\n\n    def adj_fin(self, acc, v:int):\n        \"\"\"\n        \u6700\u7d42\u7d50\u679c\u306e\u5358\u9805\u6f14\u7b97 g(acc[v])\n\n        v: \u9802\u70b9\n        \"\"\"\n        return acc * fact[self.V - 1] % MOD\n\n    def __init__(self, V:int, e:int):\n        \"\"\"\n        V: \u9802\u70b9\u6570\n        e: \u5358\u4f4d\u5143\n        \"\"\"\n        self.V, self.e = V, e\n        self.edge = [[] for _ in range(V)]\n        self.par = [-1] * V\n        self.order = []\n        self.SIZE = [1] * self.V\n    \n    def subtree_size(self):\n        \"\"\" \u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3092\u6c42\u3081\u308b \"\"\"\n        for v in reversed(self.order[1:]):\n            self.SIZE[self.par[v]] += self.SIZE[v]\n\n    def add_edge(self, u:int, v:int):\n        \"\"\" \u8fba(u,v)\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b \"\"\"\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    \n    def topological_sort(self, root:int = 0):\n        \"\"\" \u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8 \"\"\"\n        from collections import deque\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            self.order.append(v)\n            for w in self.edge[v]:\n                if w != self.par[v]:\n                    self.par[w] = v\n                    self.edge[w].remove(v)\n                    que.append(w)\n    \n    def bottom_up(self):\n        \"\"\" Bottom-Up DP \"\"\"\n        root = self.order[0]\n        accBU = [self.e] * self.V\n        resBU = [self.e] * self.V\n\n        for v in reversed(self.order):\n            resBU[v] = self.adj_bu(accBU[v], v)\n\n            if v == root: break\n\n            p = self.par[v]\n            accBU[p] = self.merge(accBU[p], resBU[v])\n        return accBU, resBU\n    \n    def top_down(self, resBU:list):\n        \"\"\" Top-Down DP \"\"\"\n        accTD = [self.e] * self.V\n        resTD = [self.e] * self.V\n\n        for p in self.order:\n            # \u5de6\u304b\u3089accTD\u3092\u66f4\u65b0\n            ac = resTD[p]\n            for v in self.edge[p]:\n                accTD[v] = ac\n                ac = self.merge(ac, resBU[v])\n\n            # \u53f3\u304b\u3089accTD\u3092\u66f4\u65b0\n            ac = self.e\n            for v in reversed(self.edge[p]):\n                accTD[v] = self.merge(accTD[v], ac)\n                ac = self.merge(ac, resBU[v])\n                \n                resTD[v] = self.adj_td(accTD[v], v, p)\n        return resTD\n    \n    def solve(self):\n        self.topological_sort()\n        self.subtree_size()\n        accBU, resBU = self.bottom_up()\n        resTD = self.top_down(resBU)\n        res = [self.adj_fin(self.merge(a, b), v) for v,(a,b) in enumerate(zip(accBU, resTD))]\n        return res\n\n#########################################################################################\nN = int(input())\nMOD = 10 ** 9 + 7\n\nfact = [1] * (N + 1) # fact[n]: n!\nfactinv = [1] * (N + 1) # n!\u306e\u9006\u5143\nfor i in range(N):\n    fact[i + 1] = fact[i] * (i + 1) % MOD\nfactinv[-1] = pow(fact[-1], MOD - 2, MOD)\nfor i in range(N - 1, -1, -1):\n    factinv[i] = factinv[i + 1] * (i + 1) % MOD\ninv = lambda n: fact[n - 1] * factinv[n] % MOD # inv[n]: n\u306e\u9006\u5143\n\ndef main():\n    RR = ReRooting(N, 1)\n    for _ in range(N - 1):\n        a, b = map(int, input().split())\n        RR.add_edge(a - 1, b- 1)\n\n    print(*RR.solve(), sep=\"\\n\")\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\ndef comb(n, r, fact, revfact, mod):\n    return (fact[n] * (revfact[n-r] * revfact[r]) % mod) % mod\n\ndef dfs(i, parent, DP, sNum, E, fact, revfact, mod):\n    Ans = 1\n    sonNode = 1\n    S = []\n    for e in E[i]:\n        if e != parent:\n            mult, sn = dfs(e, i, DP, sNum, E, fact, revfact, mod)\n            S.append(sn)\n            Ans *= mult\n            Ans %= mod\n            sonNode += sn\n    stotal = sonNode - 1\n    for s in S:\n        Ans *= comb(stotal, s, fact, revfact, mod)\n        Ans %= mod\n        stotal -= s\n    DP[i] = Ans\n    sNum[i] = sonNode - 1\n    return Ans, sonNode\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    E = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = list(map(int, input().split()))\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n    mod = 7 + 10 ** 9\n    fact = [1] * (N + 1)\n    for i in range(N): fact[i+1] = ((i + 1) * fact[i]) % mod\n    revfact = [1] * (N + 1)\n    revfact[N] = pow(fact[N], mod - 2, mod)\n    for i in reversed(list(range(N))): revfact[i] = ((i + 1) * revfact[i + 1]) % mod\n\n    DP = [1] * N\n    sNum = [0] * N\n    usNum = [0] * N\n    dfs(0, 0, DP, sNum, E, fact, revfact, mod)\n    q = deque()\n    for e in E[0]: q.append((e, 0))\n    while q:\n        nn, parn = q.popleft()\n        upperMult = DP[parn] * pow(comb(N-1, sNum[nn] + 1, fact, revfact, mod), mod - 2, mod)\n        usNum[nn] = upperNum = sNum[parn] - sNum[nn] + usNum[parn]\n        DP[nn] = (upperMult * comb(N-1, upperNum, fact, revfact, mod)) % mod\n        for e in E[nn]:\n            if e != parn: q.append((e, nn))\n        \n    print((\"\\n\".join(map(str, DP))))\n      \n    return 0\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr 28 22:56:10 2020\n\"\"\"\n\nimport sys\n#import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\n#def input():\n#    return sys.stdin.readline()[:-1]\nmod = 10**9+7\n\nN = int(input())\n#X, Y = map(int,input().split())\n#ab = [list(map(int,input().split())) for i in range(N-1)]\n\nfact = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ntmp_inv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range(2, N+1):\n    fact.append((fact[-1] * i) % mod)\n    tmp_inv.append((-tmp_inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * tmp_inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n#\u9006\u5143\u4f5c\u6210\ndef inv(a,mod):\n    return pow(a,mod-2,mod)\n\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = map(lambda x : int(x)-1, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndp = [1] * (N + 0)\nsize = [0] * (N + 0)\ndef dfs(par, v):\n    for u in graph[v]:\n        if par == u:\n            continue\n        dfs(v, u)\n        size[v] += size[u]\n        dp[v] = dp[v] * dp[u] * fact_inv[size[u]] % mod\n    dp[v] = dp[v] * fact[size[v]] % mod\n    size[v] += 1\n\nans = [0] * (N + 0)\ndef reroot(par, val_par, size_par, v):\n    ans[v] = val_par * dp[v] * cmb(N-1, size_par, mod) % mod\n    for u in graph[v]:\n        if par == u:\n            continue\n        val = ans[v] * inv(dp[u] * cmb(N-1, size[u],mod),mod) % mod\n        reroot(v, val, N - size[u], u)\n\ndfs(-1,1)\nreroot(-1,1,0,1)\nfor i in range(N):\n    print(ans[i])", "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nMOD = 10 ** 9 + 7\n\n\ndef prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\ndef dfs(v):\n    nonlocal MOD\n    childs = 0\n    var = 1\n    for e in edge[v]:\n        if path[e] == 0:\n            path[e] = 1\n            nc, nvar = dfs(e)\n            childs += nc\n            V[v][e] = (nc, nvar)\n            var *= nvar\n            var %= MOD\n            var *= invs[nc]\n            var %= MOD\n    var *= modFacts[childs]\n    var %= MOD\n    dp[v] = (childs, var)\n    return childs + 1, var\n\n\ndef dfs2(v, pn, pVar):\n    nonlocal MOD\n    oNodes, oVar = dp[v]\n    tNodes = pn + oNodes\n    tVar = (oVar * pVar) % MOD\n    tVar *= invs[oNodes]\n    tVar %= MOD\n    tVar *= modFacts[tNodes]\n    tVar %= MOD\n    tVar *= invs[pn]\n    tVar %= MOD\n\n    dp[v] = (tNodes, tVar)\n\n    for e in list(V[v].keys()):\n        eNodes, eVar = V[v][e]\n        nVar = (tVar * invs[tNodes]) % MOD\n        nVar *= modFacts[eNodes]\n        nVar %= MOD\n        nVar *= modFacts[tNodes - eNodes]\n        nVar %= MOD\n        nVar *= pow(eVar, MOD - 2, MOD)\n        nVar %= MOD\n        dfs2(e, tNodes - eNodes + 1, nVar)\n\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor s in sys.stdin.readlines():\n    a, b = list(map(int, s.split()))\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\n\nmodFacts, invs = prepare(N)\n\nV = [{} for _ in range(N)]\npath = [0] * N\ndp = [None] * N\npath[0] = 1\ndfs(0)\ndfs2(0, 0, 1)\n\n\nfor i in range(N):\n    print((dp[i][1]))\n", "import sys\nsys.setrecursionlimit(1234567890)\n\nn, *L = map(int, open(0).read().split())\nmod = 10 ** 9 + 7\ncon = [[] for _ in range(n + 1)]\nsz = [1] * (n + 1)\npar = [0] * (n + 1)\n\nfor s, t in zip(*[iter(L)] * 2):\n\tcon[s] += t,\n\tcon[t] += s,\n\n\ndef prepare(m, mod=10 ** 9 + 7):\n\tfac = [1] * (m + 1)\n\tinv = [1] * (m + 1)\n\tfor i in range(1, m + 1):\n\t\tfac[i] = fac[i - 1] * i % mod\n\tinv[-1] = pow(fac[-1], mod - 2, mod)\n\tfor i in range(m - 1, -1, -1):\n\t\tinv[i] = inv[i + 1] * (i + 1) % mod\n\treturn fac, inv\n\n\nfac, inv = prepare(n)\n\n\ndef dfs1(cur, pre):\n\tpar[cur] = pre\n\tfor nxt in con[cur]:\n\t\tif nxt != pre:\n\t\t\tdfs1(nxt, cur)\n\t\t\tsz[cur] += sz[nxt]\n\t\t\tdp1[cur] *= dp1[nxt] * inv[sz[nxt]] % mod\n\t\t\tdp1[cur] %= mod\n\tdp1[cur] *= fac[sz[cur] - 1]\n\tdp1[cur] %= mod\n\n\ndef dfs2(cur, pre):\n\tdp2[cur] *= dp1[cur] * inv[sz[cur] - 1] % mod\n\tdp2[cur] %= mod\n\tdp2[cur] *= fac[n - 1]\n\tdp2[cur] %= mod\n\tfor nxt in con[cur]:\n\t\tif nxt != pre:\n\t\t\tdp2[nxt] = fac[sz[nxt]] * pow(n - sz[nxt], mod - 2, mod) * pow(dp1[nxt], mod - 2, mod) * dp2[cur] * inv[n - 1] % mod\n\t\t\tdfs2(nxt, cur)\n\n\ndp1 = [1] * (n + 1)\ndfs1(1, 0)\ndp2 = [1] * (n + 1)\ndfs2(1, 0)\n\nprint(*dp2[1:], sep=\"\\n\")\n", "import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\nN = int(input())\n\n\nC = Factorial(N + 1, MOD)\n\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    G[a].append(b)\n    G[b].append(a)\n\norder = []\norder_append = order.append\n\nstack = [(0, -1)]\nstack_pop = stack.pop\nstack_append = stack.append\n\nwhile stack:\n    tmp = stack_pop()\n    order_append(tmp)\n    for next_ in G[tmp[0]]:\n        if next_ == tmp[1]:\n            continue\n        stack_append((next_, tmp[0]))\n    \nsize = [1] * N\ndp = [1] * N\n\n# print (order)\nfor c, p in order[::-1]:\n    if c == 0:\n        break\n    size[p] += size[c]\n\nfor c, p in order[::-1]:\n    dp[c] = (dp[c] * C.factorial(size[c] - 1)) % MOD\n    if c == 0:\n        break\n    # dp[c] = (dp[c] * C.factorial(size[c] - 1)) % MOD\n    dp[p] = (dp[p] * dp[c] % MOD) * C.ifactorial(size[c]) % MOD\n\n# print (dp)\ndp2 = [0] * N\ndp2[0] = dp[0]\n\nfor c, p in order[1::]:\n    tmp = (dp2[p] * C.factorial(N - 1 - size[c]) % MOD) * C.factorial(size[c]) % MOD\n    red = (tmp * C.ifactorial(N - 1) % MOD) * pow(dp[c], MOD - 2, MOD) % MOD\n\n    size_red = N - size[c]\n    tmp = (dp[c] * red % MOD) * C.factorial(N - 1) % MOD\n    dp2[c] = (tmp * C.ifactorial(size[c] - 1) % MOD) * C.ifactorial(size_red) % MOD\n\n\nprint (*dp2, sep = '\\n')", "class ReRooting(object):\n    \"\"\" \u5168\u65b9\u4f4d\u6728DP \"\"\"\n    def merge(self, a, b):\n        \"\"\" \u4e8c\u9805\u6f14\u7b97 a\u30fbb \"\"\"\n        return a * b % MOD\n \n    def adj_bu(self, accBU, v:int):\n        \"\"\"\n        Bottom-Up\u306e\u5358\u9805\u6f14\u7b97 g(accBU[v])\n \n        v: \u9802\u70b9\n        \"\"\"\n        return accBU * inv(self.SIZE[v]) % MOD\n \n    def adj_td(self, accTD, v:int, p:int):\n        \"\"\"\n        Top-Down\u306e\u5358\u9805\u6f14\u7b97 g(accTD[v])\n \n        v: \u9802\u70b9\n        p: \u89aa\n        \"\"\"\n        return accTD * inv(self.V - self.SIZE[v]) % MOD\n \n    def adj_fin(self, acc, v:int):\n        \"\"\"\n        \u6700\u7d42\u7d50\u679c\u306e\u5358\u9805\u6f14\u7b97 g(acc[v])\n \n        v: \u9802\u70b9\n        \"\"\"\n        return acc * fact[self.V - 1] % MOD\n\n    def __init__(self, V:int, e:int):\n        \"\"\"\n        V: \u9802\u70b9\u6570\n        e: \u5358\u4f4d\u5143\n        \"\"\"\n        self.V, self.e = V, e\n        self.edge = [[] for _ in range(V)]\n        self.par = [-1] * V\n        self.order = []\n        self.SIZE = [1] * self.V\n    \n    def subtree_size(self):\n        \"\"\" \u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\u3092\u6c42\u3081\u308b \"\"\"\n        for v in reversed(self.order[1:]):\n            self.SIZE[self.par[v]] += self.SIZE[v]\n\n    def add_edge(self, u:int, v:int):\n        \"\"\" \u8fba(u,v)\u3092\u30b0\u30e9\u30d5\u306b\u8ffd\u52a0\u3059\u308b \"\"\"\n        self.edge[u].append(v)\n        self.edge[v].append(u)\n    \n    def topological_sort(self, root:int = 0):\n        \"\"\" \u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8 \"\"\"\n        from collections import deque\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            self.order.append(v)\n            for w in self.edge[v]:\n                if w != self.par[v]:\n                    self.par[w] = v\n                    que.append(w)\n    \n    def bottom_up(self):\n        \"\"\" Bottom-Up DP \"\"\"\n        root = self.order[0]\n        accBU = [self.e] * self.V\n        resBU = [self.e] * self.V\n\n        for v in reversed(self.order):\n            resBU[v] = self.adj_bu(accBU[v], v)\n\n            if v == root: break\n\n            p = self.par[v]\n            accBU[p] = self.merge(accBU[p], resBU[v])\n\n        return accBU, resBU\n    \n    def top_down(self, resBU:list):\n        \"\"\" Top-Down DP \"\"\"\n        accTD = [self.e] * self.V\n        resTD = [self.e] * self.V\n\n        for p in self.order:\n            ac = resTD[p]\n            for v in self.edge[p]:\n                if v == self.par[p]: continue\n                accTD[v] = ac\n                ac = self.merge(ac, resBU[v])\n\n            ac = self.e\n            for v in reversed(self.edge[p]):\n                if v == self.par[p]: continue\n                accTD[v] = self.merge(accTD[v], ac)\n                ac = self.merge(ac, resBU[v])\n                resTD[v] = self.adj_td(accTD[v], v, p)\n\n        return resTD\n    \n    def solve(self):\n        self.topological_sort()\n        self.subtree_size()\n        accBU, resBU = self.bottom_up()\n        resTD = self.top_down(resBU)\n        res = [self.adj_fin(self.merge(a, b), v) for v,(a,b) in enumerate(zip(accBU, resTD))]\n        return res\n\n#########################################################################################\nN = int(input())\nMOD = 10 ** 9 + 7\n \nfact = [1] * (N + 1) # fact[n]: n!\nfactinv = [1] * (N + 1) # n!\u306e\u9006\u5143\nfor i in range(N):\n    fact[i + 1] = fact[i] * (i + 1) % MOD\nfactinv[-1] = pow(fact[-1], MOD - 2, MOD)\nfor i in range(N - 1, -1, -1):\n    factinv[i] = factinv[i + 1] * (i + 1) % MOD\ninv = lambda n: fact[n - 1] * factinv[n] % MOD # inv[n]: n\u306e\u9006\u5143\n \ndef main():\n    RR = ReRooting(N, 1)\n    for _ in range(N - 1):\n        a, b = map(int, input().split())\n        RR.add_edge(a - 1, b- 1)\n \n    print(*RR.solve(), sep=\"\\n\")\n \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\n\nMOD = 10 ** 9 + 7\n\n\ndef solve(n, edge_list):\n\n    # mod\n    factorial = [1] * n\n    for i in range(1, n):\n        factorial[i] = (factorial[i - 1] * i) % MOD\n    factorial_inv = [1] * n\n    factorial_inv[-1] = pow(factorial[-1], MOD - 2, MOD)\n    for i in range(n - 2, 0, -1):\n        factorial_inv[i] = (factorial_inv[i + 1] * (i + 1)) % MOD\n\n    # graph\n    g = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = edge_list[i]\n        g[a].append(b)\n        g[b].append(a)\n\n    # root 0\n    order = []\n    parent = [-1] * n\n    parent[0] = 0\n    children = [[] for _ in range(n)]\n    queue = deque([0])\n    while len(queue) > 0:\n        p = queue.popleft()\n        order.append(p)\n        for q in g[p]:\n            if parent[q] == -1:\n                parent[q] = p\n                children[p].append(q)\n                queue.append(q)\n\n    # n_children\n    count_children_res = [-1] * n\n\n    for x in order[::-1]:\n        if len(children[x]) == 0:\n            count_children_res[x] = 0\n        else:\n            r = len(children[x]) + sum([count_children_res[y] for y in children[x]])\n            count_children_res[x] = r\n\n    assign_children_res = [-1] * n\n\n    for x in order[::-1]:\n        if len(children[x]) == 0:\n            assign_children_res[x] = 1\n        else:\n            r = factorial[count_children_res[x]]\n            for y in children[x]:\n                r *= assign_children_res[y]\n                r *= factorial_inv[count_children_res[y] + 1]\n                r %= MOD\n            assign_children_res[x] = r\n\n    # reverse direction\n    assign_parents_res = [-1] * n\n    assign_parents_res[0] = 1\n\n    for x in order[1:]:\n        p = parent[x]\n        r = assign_children_res[p]\n        r *= pow(assign_children_res[x], MOD - 2, MOD)\n        r *= factorial[count_children_res[x] + 1]\n\n        # r *= factorial[count_children_res[p] - count_children_res[x] - 1]\n        r *= factorial_inv[count_children_res[p]]\n\n        r *= assign_parents_res[p]\n        r *= factorial[n - count_children_res[x] - 2]\n        # r *= factorial_inv[count_children_res[p] - count_children_res[x] - 1]\n        r *= factorial_inv[n - count_children_res[p] - 1]\n\n        r %= MOD\n        assign_parents_res[x] = r\n\n    res_list = [0] * n\n    res_list[0] = assign_children_res[0]\n\n    for i in range(1, n):\n        res = factorial[n - 1]\n        # children\n        for j in children[i]:\n            res *= assign_children_res[j]\n            res *= factorial_inv[count_children_res[j] + 1]\n            res %= MOD\n        # parent\n        res *= assign_parents_res[i]\n        res *= factorial_inv[n - 1 - count_children_res[i]]\n        res %= MOD\n        res_list[i] = res\n    # print(res_list)\n    return res_list\n\n\ndef main():\n    n = int(input())\n    edge_list = []\n    for _ in range(n - 1):\n        a, b = list(map(int, input().split()))\n        edge_list.append((a - 1, b - 1))\n    res_list = solve(n, edge_list)\n    for res in res_list:\n        print(res)\n\n\ndef test():\n    assert solve(3, [(0, 1), (0, 2)]) == [2, 1, 1]\n    assert solve(2, [(0, 1)]) == [1, 1]\n    assert solve(5, [(0, 1), (1, 2), (2, 3), (2, 4)]) == [2, 8, 12, 3, 3]\n    assert solve(8, [(0, 1), (1, 2), (2, 3), (2, 4), (2, 5), (5, 6), (5, 7)]) == [40, 280, 840, 120, 120, 504, 72, 72]\n\n\ndef __starting_point():\n    test()\n    # r_star = solve(200000, [(i, 0) for i in range(1, 200000)])\n    # print(1)\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(lambda x : int(x)-1, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nmod = 10**9+7\nfact = [1] * N\nfact_inv = [1] * N\nfor i in range(1, N):\n    fact[i] = i * fact[i-1] % mod\ninv = lambda x : pow(x, mod-2, mod)\nfact_inv[N-1] = inv(fact[N-1])\nfor i in range(1, N)[::-1]:\n    fact_inv[i-1] = i * fact_inv[i] % mod\ncomb = lambda n, k : fact[n] * fact_inv[k] * fact_inv[n-k] % mod\n\ndp = [1] * N\nsize = [0] * N\ndef dfs(par, v):\n    for u in G[v]:\n        if par == u:\n            continue\n        dfs(v, u)\n        size[v] += size[u]\n        dp[v] = dp[v] * dp[u] * fact_inv[size[u]] % mod\n    dp[v] = dp[v] * fact[size[v]] % mod\n    size[v] += 1\n\nans = [0] * N\ndef reroot(par, val_par, size_par, v):\n    ans[v] = val_par * dp[v] * comb(N-1, size_par) % mod\n    for u in G[v]:\n        if par == u:\n            continue\n        val = ans[v] * inv(dp[u] * comb(N-1, size[u])) % mod\n        reroot(v, val, N-size[u],  u)\n\ndfs(-1, 0)\nreroot(-1, 1, 0, 0)\nprint(*ans, sep='\\n')", "def main():\n    from sys import stdin\n    input = stdin.readline\n    n = int(input())\n    ab = [list(map(int, input().split())) for _ in [0]*(n-1)]\n\n    g = [set() for _ in [0]*n]\n    for a, b in ab:\n        g[a-1].add(b-1)\n        g[b-1].add(a-1)\n\n    mod = 10**9+7\n    fact = [1, 1]\n    inv = [pow(i, mod-2, mod) for i in range(n+1)]\n    for i in range(2, n+1):\n        fact.append(fact[-1]*i % mod)\n\n    class rerooting():\n        # add\u306f\u9802\u70b9i\u306b\u9802\u70b9j\u3092\u6839\u3068\u3059\u308b\u90e8\u5206\u6728\uff08DP\u306e\u5024\uff1ax\uff09\u3092\u304f\u3063\u3064\u3051\u308b\u3068\u304d\u306e\u88dc\u6b63\n        def __init__(self, tree, ini):\n            # merge:\u9802\u70b9a\u306bb\u3092\u30de\u30fc\u30b8\u3059\u308b\u3068\u304d\u306e\u30e2\u30ce\u30a4\u30c9\n            # adj_bu:\u30dc\u30c8\u30e0\u30a2\u30c3\u30d7\u6642\u306e\u8abf\u6574\uff08a:\u5024,i:\u9802\u70b9\uff09\n            # adj_td:\u30c8\u30c3\u30d7\u30c0\u30a6\u30f3\u6642\u306e\u8abf\u6574\uff08a:\u5024,i:\u9802\u70b9,p:\u89aa\uff09\n            # adj_fin:\u6700\u7d42\u8abf\u6574\uff08a:\u5024,i:\u9802\u70b9\uff09\n            def merge(a, b): return a * b % mod\n            def adj_bu(a, i): return a * inv[size[i]] % mod\n            def adj_td(a, i, p): return a * inv[n-size[i]] % mod\n            def adj_fin(a, i): return a * fact[n-1] % mod\n\n            # \u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u3092\u3059\u308b\n            # T:\u6728\u306e\u96a3\u63a5\u30b0\u30e9\u30d5\u8868\u73fe\u3092set\u5316\n            # P:\u89aa\n            # q:\u30ad\u30e5\u30fc\n            # order:\u30c8\u30dd\u30bd\u3057\u305f\u3082\u306e\n            T = g\n            P = [-1]*n\n            q = [0]\n            order = []\n            while q:\n                i = q.pop()\n                order.append(i)\n                for a in T[i]:\n                    if a != P[i]:\n                        P[a] = i\n                        T[a].remove(i)\n                        q.append(a)\n\n            # T\u3092\u30ea\u30b9\u30c8\u306b\u5909\u63db\n            T = [list(i) for i in T]\n\n            # \u30b5\u30a4\u30ba\u306e\u51e6\u7406\u3092\u5148\u306b\u884c\u3046\n            # size[i]:0\u3092\u6839\u3068\u3059\u308b\u6839\u4ed8\u304d\u6728\u306b\u304a\u3051\u308b\u3001i\u3092\u6839\u3068\u3059\u308b\u90e8\u5206\u6728\u306e\u5927\u304d\u3055\n            size = [1]*n\n            for i in order[1:][::-1]:\n                size[P[i]] += size[i]\n\n            # \u30dc\u30c8\u30e0\u30a2\u30c3\u30d7\u51e6\u7406\u3092\u3059\u308b\n            # ME:\u30de\u30fc\u30b8\u3057\u305f\u5024\u3092\u4e00\u6642\u4fdd\u5b58\n            # DP:DP\u5024\u3001ME\u3092\u8abf\u6574\u3057\u305f\u3082\u306e\n            ME = [ini]*n\n            DP = [0]*n\n            for i in order[1:][::-1]:\n                DP[i] = adj_bu(ME[i], i)\n                p = P[i]\n                ME[p] = merge(ME[p], DP[i])\n            DP[order[0]] = adj_fin(ME[order[0]], order[0])\n            TD = [ini]*n\n\n            # \u30c8\u30c3\u30d7\u30c0\u30a6\u30f3\u51e6\u7406\u3092\u3059\u308b\n            for i in order:\n                # \u5de6\u304b\u3089DP\uff08\u7d50\u679c\u306fTD\u306b\u5165\u308c\u3066\u3044\u308b\uff09\n                ac = TD[i]\n                for j in T[i]:\n                    TD[j] = ac\n                    ac = merge(ac, DP[j])\n                # \u53f3\u304b\u3089DP\uff08\u7d50\u679c\u306fac\u306b\u5165\u308c\u3066\u3044\u308b\u3001\u4e00\u5ea6\u3057\u304b\u4f7f\u308f\u306a\u3044\u306e\u3067ac\u3067\u554f\u984c\u306a\u3044\uff09\n                ac = ini\n                for j in T[i][::-1]:\n                    TD[j] = adj_td(merge(TD[j], ac), j, i)\n                    ac = merge(ac, DP[j])\n                    DP[j] = adj_fin(merge(ME[j], TD[j]), j)\n            for i in DP:\n                print(i)\n\n    rerooting(g, 1)\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\nMOD = 10 ** 9 + 7\n\nF = Factorial(2 * 10 ** 5 + 10, MOD)\n\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\n\n\nroot = 1\n\nDAG = []\nparent = [-1] * (N + 1)\nparent[root] = 0\nstack = [root]\nwhile stack:\n    now_ = stack.pop()\n    DAG.append(now_)\n    for next_ in G[now_]:\n        if parent[next_] == -1:\n            stack.append(next_)\n            parent[next_] = now_\n\n# print ('parent', parent)\n\nsize1 = [1] * (N + 1)\ndp1 = [1] * (N + 1)\n\nfor i in DAG[::-1]:\n    size1[parent[i]] += size1[i]\n\nfor i in DAG[::-1]:\n    dp1[i] *= F.factorial(size1[i] - 1)\n    dp1[i] %= MOD\n    dp1[parent[i]] *= (dp1[i] * F.ifactorial(size1[i])) % MOD\n    dp1[parent[i]] %= MOD\n\n# print (dp1)\n# print (size1)\n\nsize2 = [1] * (N + 1)\ndp2 = [1] * (N + 1)\n\nfor i in DAG[::]:\n    for j in G[i]:\n        if parent[i] == j:\n            continue\n        size2[j] = size2[i] + size1[i] - size1[j]  \n\nfor i in DAG[1::]:\n    x = 1\n    x *= dp1[parent[i]]\n    x *= F.ifactorial(size1[parent[i]] - 1)\n    x *= F.factorial(size1[i])\n    x *= pow(dp1[i], MOD - 2, MOD)\n    x *= dp2[parent[i]]\n    x *= F.ifactorial(size2[parent[i]] - 1)\n    x *= F.factorial(size2[i] - 2)\n    dp2[i] = x % MOD\n\n# print ('size1', size1)\n# print ('size2', size2)\n# print ('dp1', dp1)\n# print ('dp2', dp2)\n# print (G)\n\nfact = F.factorial(N - 1)\nfor x in range(1, N + 1):\n    ans = fact * dp1[x] * F.ifactorial(size1[x] - 1) * dp2[x] * F.ifactorial(size2[x] - 1)\n    print((ans % MOD))\n", "\ndef COMinit(n, MOD):\n    fact = [1, 1]\n    fact_inv = [1, 1]\n    inv = [0, 1]\n    for i in range(2, n + 1):\n        fact.append((fact[-1] * i) % MOD)\n        inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n        fact_inv.append((fact_inv[-1] * inv[i]) % MOD)\n    return fact, fact_inv\n\nMOD = 10**9+7\ndef resolve():\n    def dfs1(r_topo, par):\n        for idx in reversed(r_topo):\n            for to in G[idx]:\n                if to == par[idx]:\n                    continue\n\n\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = map(lambda x:int(x)-1, input().split())\n        G[a].append(b)\n        G[b].append(a)\n\n    fact, fact_inv = COMinit(N, MOD)\n\n    topo = []\n    P = [-1] * N\n    node = [0]\n    while node:\n        v = node.pop()\n        topo.append(v)\n        for to in G[v]:\n            if to == P[v]:\n                continue\n            P[to] = v\n            node.append(to)\n\n    # \u8449\u306e\u30b5\u30a4\u30ba\u3092\u683c\u7d0d\n    size = [1]*N\n    for e in reversed(topo):\n        if e == 0:\n            break\n        size[P[e]] += size[e]\n\n    dp1 = [1]*N\n    for e in reversed(topo):\n        dp1[e] = dp1[e] * fact[size[e] - 1] % MOD\n        if e == 0:\n            break\n        dp1[P[e]] = (dp1[P[e]] * dp1[e] % MOD) * fact_inv[size[e]] % MOD\n\n    dp2 = [0] * N\n    dp2[0] = dp1[0]\n    for e in topo[1:]:\n        p = P[e]\n        tmp = (dp2[p] * fact[N - 1 - size[e]] % MOD) * fact[size[e]] % MOD\n        red = (tmp * fact_inv[N - 1] % MOD) * pow(dp1[e], MOD - 2, MOD) % MOD\n\n        size_red = N - size[e]\n        tmp = (dp1[e] * red % MOD) * fact[N - 1] % MOD\n        dp2[e] = (tmp * fact_inv[size[e] - 1] % MOD) * fact_inv[size_red] % MOD\n\n    print(*dp2, sep=\"\\n\")\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nMOD = 10 ** 9 + 7\n\n\ndef prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\ndef dfs(v):\n    nonlocal MOD\n    childs = 0\n    var = 1\n    for e in edge[v]:\n        if path[e] == 0:\n            path[e] = 1\n            nc, nvar = dfs(e)\n            childs += nc\n            V[v][e] = (nc, nvar)\n            var *= nvar\n            var %= MOD\n            var *= invs[nc]\n            var %= MOD\n    var *= modFacts[childs]\n    var %= MOD\n    dp[v] = (childs, var)\n    return childs + 1, var\n\n\ndef dfs2(v, pn, pVar):\n    nonlocal MOD\n    oNodes, oVar = dp[v]\n    tNodes = pn + oNodes\n    tVar = (oVar * pVar) % MOD\n    tVar *= invs[oNodes] * modFacts[tNodes] * invs[pn]\n    tVar %= MOD\n\n    dp[v] = (tNodes, tVar)\n\n    for e in list(V[v].keys()):\n        eNodes, eVar = V[v][e]\n        nVar = (tVar * invs[tNodes] * modFacts[eNodes] * modFacts[tNodes - eNodes]) % MOD\n        nVar *= pow(eVar, MOD - 2, MOD)\n        nVar %= MOD\n        dfs2(e, tNodes - eNodes + 1, nVar)\n\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor s in sys.stdin.readlines():\n    a, b = list(map(int, s.split()))\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\n\nmodFacts, invs = prepare(N)\n\nV = [{} for _ in range(N)]\npath = [0] * N\ndp = [None] * N\npath[0] = 1\ndfs(0)\ndfs2(0, 0, 1)\n\n\nfor i in range(N):\n    print((dp[i][1]))\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n\n    ## comb\n    mod = 1000000007\n\n    def make_fact(n):\n        fact = [1]*(n+1)\n        ifact = [1]*(n+1)\n        for i in range(1, n+1):\n            fact[i] = fact[i-1]*i % mod\n        ifact[n] = pow(fact[n], mod-2, mod)\n        for i in range(n, 0, -1):\n            ifact[i-1] = ifact[i]*i % mod\n        return fact, ifact\n    fact, ifact = make_fact(2000002)\n\n    def comb(n, k):\n        if k < 0 or k > n: return 0\n        return fact[n]*ifact[k]*ifact[n-k] % mod\n\n    N = int(input())\n    AB = [tuple(map(int, input().split())) for _ in range(N-1)]\n    graph = [[] for _ in range(N + 1)]\n    for a, b in AB:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # dfs\n    root = 1\n    parent = [0] * (N + 1)\n    order = []\n    stack = [root]\n    while stack:\n        x = stack.pop()\n        order.append(x)\n        for y in graph[x]:\n            if y == parent[x]:\n                continue\n            parent[y] = x\n            stack.append(y)\n\n    # \u65b9\u5411\u3054\u3068\uff1f\n    size_d = [0] * (N + 1)\n    dp_d = [1] * (N + 1)\n\n    for v in order[::-1]:\n        dp_d[v] *= fact[size_d[v]]\n        dp_d[v] %= mod\n        p = parent[v]\n        s = size_d[v] + 1\n        size_d[p] += s\n        dp_d[p] *= ifact[s] * dp_d[v]\n        dp_d[p] %= mod\n\n    size_u = [N - 2 - x for x in size_d]\n    dp_u = [1] * (N + 1)\n\n    for v in order[1:]:\n        p = parent[v]\n        x = dp_d[p]\n        x *= dp_u[p]\n        x *= ifact[size_d[p]]\n        x *= fact[size_d[v] + 1]\n        x *= pow(dp_d[v], mod - 2, mod)\n        x *= fact[size_u[v]]\n        x *= ifact[size_u[p] + 1]\n        dp_u[v] = x % mod\n\n    for xd, xu, sd, su in zip(dp_d[1:], dp_u[1:], size_d[1:], size_u[1:]):\n        su += 1\n        x = xd * xu * comb(sd+su, su) % mod\n        print(x)\n\nmain()\n\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom functools import reduce\n\nMAX_INT = 2**62-1\nsys.setrecursionlimit(10**7)\n\ninput = sys.stdin.readline\n\n# @profile\nMOD = 10**9 + 7\n\n\ndef mul_mod(*args, mod=MOD):\n    return reduce(lambda a, b: a * b % mod, args)\n\n\ndef solve(g, f, fi, m):\n    mul = mul_mod\n\n    stack = [(0, 1)]\n    pre_order = []\n    n = len(g) - 1\n\n    while stack:\n        pre, cur = stack.pop()\n        pre_order.append((pre, cur))\n\n        for nxt in g[cur]:\n            if nxt == pre:\n                continue\n            stack.append((cur, nxt))\n\n    size = [1] * (n+1)\n    dp = [1] * (n+1)\n\n    for pre, cur in reversed(pre_order):\n        dp[cur] = mul(dp[cur], f[size[cur]-1])\n        dp[pre] = mul(dp[pre], dp[cur], fi[size[cur]])\n        size[pre] += size[cur]\n\n    ans = [1] * (n+1)\n    ans[1] = dp[1]\n\n    for pre, cur in pre_order[1:]:\n        i = size[cur]\n        temp = mul(ans[pre], f[n-i-1], fi[n-1], f[i], pow(dp[cur], m-2, m))\n        ans[cur] = mul(f[n-1], temp, fi[n-i], dp[cur], fi[i-1])\n    print(*ans[1:], sep='\\n')\n\n\n# @profile\ndef main():\n    mul = mul_mod\n    mod = MOD\n    n = int(input())\n    g = [[] for _ in range(n+1)]\n\n    fact = [1] * (n+1)\n    fact_inv = [0] * (n+1)\n\n    for i in range(1, n+1):\n        fact[i] = mul(fact[i-1], i)\n\n    fact_inv[-1] = pow(fact[-1], mod-2, mod)\n\n    for i in range(n)[::-1]:\n        fact_inv[i] = mul(fact_inv[i+1], (i+1))\n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        g[a].append(b)\n        g[b].append(a)\n\n    solve(g, fact, fact_inv, mod)\n\n\ndef __starting_point():\n\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\ninput = lambda: sys.stdin.readline().rstrip()\nMOD = 10**9+7\n\nn = int(input())\ng = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\nlim = 10**5*2\nfact = [1, 1] + [0] * (lim-1)\nfact_inv = [1, 1] + [0] * (lim-1)\ninv = [0, 1] + [0] * (lim-1)\nfor i in range(2, lim+1):\n    fact[i] = fact[i-1] * i % MOD\n    inv[i] = MOD - inv[MOD % i] * (MOD//i) % MOD\n    fact_inv[i] = fact_inv[i-1] * inv[i] % MOD\ndef comb(n, m):\n    if n < m or n < 0 or m < 0: return 0\n    return fact[n] * (fact_inv[m] * fact_inv[n-m] % MOD) % MOD\ndef icomb(n, m):\n    if n < m or n < 0 or m < 0: return 0\n    return fact_inv[n] * (fact[m] * fact[n-m] % MOD) % MOD\n\ndp = [1] * n\nsize = [0] * n\n\ndef dfs(v, pv):\n    for nv in g[v]:\n        if nv == pv: continue\n        dfs(nv, v)\n        ns = size[nv]+1\n        size[v] += ns\n        dp[v] *= dp[nv] * comb(size[v], ns) % MOD\n        dp[v] %= MOD\n\ndef dfs2(v, pv):\n    for nv in g[v]:\n        if nv == pv: continue\n        d, sz = dp[v], size[v]\n        d *= pow(dp[nv], MOD-2, MOD) * icomb(sz, size[nv]+1) % MOD\n        d %= MOD\n        sz -= size[nv]+1\n\n        size[nv] += sz+1\n        dp[nv] *= d * comb(size[nv], sz+1) % MOD\n        dp[nv] %= MOD\n        dfs2(nv, v)\n\ndfs(0, -1)\ndfs2(0, -1)\nprint(*dp, sep=\"\\n\")\n", "n = int(input()); arr = [list(map(int,input().split())) for _ in range(n-1)]\ngraph = [[] for _ in range(n)]\nfor a,b in arr:\n    graph[a-1].append(b-1); graph[b-1].append(a-1)\n\n\nmod = 10**9+7\nfac = [1]*(n+1)\ninv = [1]*(n+1)\nifac = [1]*(n+1)\nfor i in range(2,n+1):\n    fac[i] = fac[i-1] * i % mod\n    inv[i] = (- (mod//i)*inv[(mod%i)]) % mod\n    ifac[i] = ifac[i-1] * inv[i] % mod\n\nparents = [-1]*n\nchildren = [[] for _ in range(n)]\norders = []\nstack = [0]\nflags = [True] * n; flags[0] = False\nwhile stack:\n    tmp = stack.pop()\n    orders.append(tmp)\n    for node in graph[tmp]:\n        if flags[node]:\n            flags[node] = False\n            children[tmp].append(node)\n            stack.append(node)\n            parents[node] = tmp\n\nsize = [1] * (n+1)\ndp = [1] * (n+1)    \nfor child in orders[::-1]:\n    parent = parents[child]\n    size[parent] += size[child]\n    dp[child] = dp[child] * fac[size[child]-1] % mod\n    dp[parent] = dp[parent] * dp[child] * ifac[size[child]] % mod\n_ = size.pop();_ = dp.pop()\n\nsize2 = [n-i+1 for i in size]\ndp2 = [1] * n; dp2[0] = dp[0]\nfor parent in orders[1:]:\n    child = parents[parent]\n    dp2[parent] = dp2[parent] * size[parent] * dp2[child] * inv[size2[parent]-1] % mod\n    \nfor i in range(n):\n    print(dp2[i])", "import sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\ndef solve():\n    N = int(input())\n    AB = [tuple(map(int,input().split())) for i in range(N-1)]\n    es = [[] for i in range(N)]\n    for i,(a,b) in enumerate(AB):\n        a,b = a-1,b-1\n        es[a].append((b,i))\n        es[b].append((a,i))\n    MOD = 10**9+7\n\n    size = [-1] * N\n    def calc_size(v,p=-1):\n        ret = 1\n        for to,_ in es[v]:\n            if to==p: continue\n            ret += calc_size(to,v)\n        size[v] = ret\n        return ret\n    calc_size(0)\n\n    MAXN = N+5\n    fac = [1,1] + [0]*MAXN\n    finv = [1,1] + [0]*MAXN\n    inv = [0,1] + [0]*MAXN\n    for i in range(2,MAXN+2):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i-1] * inv[i] % MOD\n\n    dpdn = [0] * (N-1)\n    dn = set()\n    def dfs(v,p=-1):\n        ret = fac[size[v]-1]\n        for to,i in es[v]:\n            if to==p: continue\n            dn.add((v,to))\n            dpdn[i] = dfs(to,v)\n            ret *= finv[size[to]] * dpdn[i]\n        ret %= MOD\n        return ret\n    dfs(0)\n\n    dpup = [0] * (N-1)\n    from collections import deque\n    q = deque([(0,-1)])\n    while q:\n        v,p = q.popleft()\n        whole = 1\n        for to,i in es[v]:\n            if to != p:\n                whole *= finv[size[to]] * dpdn[i]\n            else:\n                whole *= finv[N-size[v]] * dpup[i]\n        whole %= MOD\n        for to,i in es[v]:\n            if to==p: continue\n            dpup[i] = (whole * fac[N-size[to]-1] * fac[size[to]] * pow(dpdn[i], MOD-2, MOD)) % MOD\n            q.append((to,v))\n\n    ans = []\n    for v in range(N):\n        a = 1\n        s = 0\n        for to,i in es[v]:\n            if (v,to) in dn:\n                s += size[to]\n                a *= finv[size[to]] * dpdn[i]\n            else:\n                s += N-size[v]\n                a *= finv[N-size[v]] * dpup[i]\n            a %= MOD\n        a *= fac[s]\n        ans.append(a%MOD)\n    print(*ans, sep='\\n')\n\nsolve()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr 28 22:56:10 2020\n\"\"\"\n\nimport sys\n#import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\n#def input():\n#    return sys.stdin.readline()[:-1]\nmod = 10**9+7\n\nN = int(input())\n#X, Y = map(int,input().split())\nab = [list(map(int,input().split())) for i in range(N-1)]\n\nfact = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ntmp_inv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range(2, N+1):\n    fact.append((fact[-1] * i) % mod)\n    tmp_inv.append((-tmp_inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * tmp_inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n#\u9006\u5143\u4f5c\u6210\ndef inv(a,mod):\n    return pow(a,mod-2,mod)\n\ngraph = [[] for _ in range(N+1)]\nfor a, b in ab:\n    graph[a].append(b)\n    graph[b].append(a)\n    \nroot = 1\nparent = [0] * (N + 1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if parent[x] == y:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nsize_d = [0] * (N + 1)\ndp_d = [1] * (N + 1)\nfor v in order[::-1]:\n    dp_d[v] *= fact[size_d[v]]\n    dp_d[v] %= mod\n    p = parent[v]\n    s = size_d[v] + 1\n    size_d[p] += s\n    dp_d[p] *= fact_inv[s] * dp_d[v]\n    dp_d[p] %= mod\n\nsize_u = [N - x - 1 for x in size_d]\ndp_u = [1] * (N + 1)\nfor v in order[1:]:\n    p = parent[v]\n    x = dp_d[p] * inv(dp_d[v],mod)\n    x *= fact_inv[size_d[p]] * fact[size_d[v] + 1]\n    x *= fact[size_u[v] - 1] * fact_inv[size_u[p]]\n    x *= dp_u[p]\n    dp_u[v] = x % mod\n\nfor xd, xu, sd, su in zip(dp_d[1:], dp_u[1:], size_d[1:], size_u[1:]):\n    x = xd * xu * fact[sd + su] * fact_inv[sd] * fact_inv[su] % mod\n    print(x)\n\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(lambda x : int(x)-1, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\nmod = 10**9+7\nfact = [1] * N\nfact_inv = [1] * N\ninv = lambda x : pow(x, mod-2, mod)\nfor i in range(1, N):\n    fact[i] = i * fact[i-1] % mod\n    fact_inv[i] = inv(fact[i])\ncomb = lambda n, k : fact[n] * fact_inv[k] * fact_inv[n-k] % mod\n\nvalue = [1] * N\ncount = [0] * N\ndef dfs(par, v):\n    for u in G[v]:\n        if par == u:\n            continue\n        dfs(v, u)\n        count[v] += count[u]\n        value[v] = value[v] * value[u] * comb(count[v], count[u]) % mod\n    count[v] += 1\n\nans = [0] * N\ndef reroot(par, val_par, cnt_par, v):\n    ans[v] = val_par * value[v] * comb(N-1, cnt_par) % mod\n    for u in G[v]:\n        if par == u:\n            continue\n        val = ans[v] * inv(value[u] * comb(N-1, count[u])) % mod\n        reroot(v, val, N-count[u],  u)\n\ndfs(-1, 0)\nreroot(-1, 1, 0, 0)\nprint(*ans, sep='\\n')", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr 28 22:56:10 2020\n\"\"\"\n\nimport sys\n#import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\n#def input():\n#    return sys.stdin.readline()[:-1]\nmod = 10**9+7\n\nN = int(input())\n#X, Y = map(int,input().split())\n#ab = [list(map(int,input().split())) for i in range(N-1)]\n\nfact = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\nfact_inv = [1, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ntmp_inv = [0, 1] # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range(2, N+1):\n    fact.append((fact[-1] * i) % mod)\n    tmp_inv.append((-tmp_inv[mod % i] * (mod//i)) % mod)\n    fact_inv.append((fact_inv[-1] * tmp_inv[-1]) % mod)\ndef cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return fact[n] * fact_inv[r] * fact_inv[n-r] % mod\n#\u9006\u5143\u4f5c\u6210\ndef inv(a,mod):\n    return pow(a,mod-2,mod)\n\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = map(lambda x : int(x)-1, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndp = [1] * (N + 0)\nsize = [0] * (N + 0)\ndef dfs(par, v):\n    for u in graph[v]:\n        if par == u:\n            continue\n        dfs(v, u)\n        size[v] += size[u]\n        dp[v] = dp[v] * dp[u] * fact_inv[size[u]] % mod\n    dp[v] = dp[v] * fact[size[v]] % mod\n    size[v] += 1\n\nans = [0] * (N + 0)\ndef reroot(par, val_par, size_par, v):\n    ans[v] = val_par * dp[v] * cmb(N-1, size_par, mod) % mod\n    for u in graph[v]:\n        if par == u:\n            continue\n        val = ans[v] * inv(dp[u] * cmb(N-1, size[u],mod),mod) % mod\n        reroot(v, val, N - size[u], u)\n\ndfs(-1,1)\nreroot(-1,1,0,1)\nprint(*ans, sep='\\n')", "import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\n\nF = Factorial(N + 2, MOD)\n\nroot = 1\nstack = [root]\ncheck = [False] * (N + 1)\ncheck[root] = True\np = [0] * (N + 1) \n\nDAG = []\n\nwhile stack:\n    now_ = stack.pop()\n    DAG.append(now_)\n    for next_ in G[now_]:\n        if check[next_]:\n            continue\n        stack.append(next_)\n        check[next_] = True\n        p[next_] = now_\n\nsize1 = [0] * (N + 1)\ndp1 = [1] * (N + 1)\n\nfor now_ in DAG[::-1]:\n    size1[now_] += 1\n    size1[p[now_]] += size1[now_]\n    dp1[now_] *= F.factorial(size1[now_] - 1)\n    dp1[now_] %= MOD\n    dp1[p[now_]] *= dp1[now_] * F.ifactorial(size1[now_])\n    dp1[p[now_]] %= MOD\n\n# print (size1)\n# print (dp1)\n\nsize2 = [N - size1[i] + 1 for i in range(N + 1)]\ndp2 = [1] * (N + 1)\n\nfor now_ in DAG[1::]:\n    parent = p[now_]\n    x = dp1[parent]\n    x *= F.ifactorial(size1[parent] - 1)\n    x *= F.factorial(size1[now_])\n    x *= pow(dp1[now_], MOD - 2, MOD)\n    x *= dp2[parent]\n    x *= F.ifactorial(size2[parent] - 1)\n    x *= F.factorial(size2[now_] - 2)\n    dp2[now_] = x % MOD\n \n# print (size2)\n# print (dp2)\n\nfor i in range(1, N + 1):\n    ans =  dp1[i] * F.ifactorial(size1[i] - 1) * dp2[i] * F.ifactorial(size2[i] - 1) * F.factorial(N - 1)\n    print((ans % MOD))\n", "def main():\n    M=10**9+7\n    N=10**5*2\n    fac=[0]*(N+1)\n    fac[0]=b=1\n    for i in range(1,N+1):fac[i]=b=b*i%M\n    inv=[0]*(N+1)\n    inv[N]=b=pow(fac[N],M-2,M)\n    for i in range(N,0,-1):inv[i-1]=b=b*i%M\n    n,*t=open(0).read().split()\n    n=int(n)\n    e=[[]for _ in range(n)]\n    for a,b in zip(*[map(int,t)]*2):\n        e[a-1]+=b-1,\n        e[b-1]+=a-1,\n    o=[]\n    s=[0]\n    f=[1]*n\n    while s:\n        v=s.pop()\n        f[v]=0\n        o+=v,\n        l=[]\n        for w in e[v]:\n            if f[w]:\n                l+=w,\n                s+=w,\n        e[v]=l\n    sz1,sz2=[0]*n,[0]*n\n    dp1,dp2=[0]*n,[0]*n\n    c=[[]for _ in range(n)]\n    for v in o[::-1]:\n        s=b=1\n        c1,c2=[1],[1]\n        for w in e[v]:\n            u=sz1[w]\n            b=b*dp1[w]*inv[u]%M\n            c1+=b,\n            s+=u\n        b=1\n        for w in e[v][::-1]:\n            b=b*dp1[w]*inv[sz1[w]]%M\n            c2+=b,\n        c[v]=c1,c2[-2::-1]\n        sz1[v]=s\n        dp1[v]=b*fac[s-1]%M\n    # print(dp1)\n    sz2[0]=1\n    dp2[0]=1\n    for v in o:\n        l=len(e[v])\n        c1,c2=c[v]\n        uv=sz2[v]-1\n        tv=dp2[v]*inv[uv]\n        uv+=sz1[v]\n        for w,l,r in zip(e[v],c1,c2):\n            tw=l*r%M\n            uw=uv-sz1[w]-1\n            dp2[w]=tv*tw*fac[uw]%M\n            sz2[w]=uw+2\n    # print(dp2)\n    a=[]\n    for dp1,dp2,sz1,sz2 in zip(dp1,dp2,sz1,sz2):\n        sz1-=1\n        sz2-=1\n        a+=str(dp1*dp2*inv[sz1]*inv[sz2]*fac[sz1+sz2]%M),\n    print('\\n'.join(a))\nmain()", "import sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\ndef comb(n, r, fact, revfact, mod):\n    return (fact[n] * (revfact[n-r] * revfact[r]) % mod) % mod\n\ndef dfs(i, parent, DP, sNum, E, fact, revfact, mod):\n    Ans = 1\n    sonNode = 1\n    S = []\n    for e in E[i]:\n        if e != parent:\n            mult, sn = dfs(e, i, DP, sNum, E, fact, revfact, mod)\n            S.append(sn)\n            Ans *= mult\n            Ans %= mod\n            sonNode += sn\n    stotal = sonNode - 1\n    for s in S:\n        Ans *= comb(stotal, s, fact, revfact, mod)\n        Ans %= mod\n        stotal -= s\n    DP[i] = Ans\n    sNum[i] = sonNode - 1\n    return Ans, sonNode\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    E = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = list(map(int, input().split()))\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n    mod = 7 + 10 ** 9\n    fact = [1] * (N + 1)\n    for i in range(N): fact[i+1] = ((i + 1) * fact[i]) % mod\n    revfact = [1] * (N + 1)\n    revfact[N] = pow(fact[N], mod - 2, mod)\n    for i in reversed(list(range(N))): revfact[i] = ((i + 1) * revfact[i + 1]) % mod\n\n    DP = [1] * N\n    sNum = [0] * N\n    usNum = [0] * N\n    dfs(0, 0, DP, sNum, E, fact, revfact, mod)\n    q = deque()\n    for e in E[0]: q.append((e, 0))\n    while q:\n        nn, parn = q.popleft()\n        upperMult = DP[parn] * pow(comb(N-1, sNum[nn] + 1, fact, revfact, mod), mod - 2, mod)\n        usNum[nn] = upperNum = sNum[parn] - sNum[nn] + usNum[parn]\n        DP[nn] = (upperMult * comb(N-1, upperNum, fact, revfact, mod)) % mod\n        for e in E[nn]:\n            if e != parn: q.append((e, nn))\n        \n    print((\"\\n\".join(map(str, DP))))\n      \n    return 0\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.f = [1]\n        self.mod = mod\n        for j in range(1, n + 1):\n            self.f.append(self.f[-1] * j % mod)\n        self.i = [pow(self.f[-1], mod - 2, mod)]\n        for j in range(n, 0, -1):\n            self.i.append(self.i[-1] * j % mod)\n        self.i.reverse()\n    def factorial(self, j):\n        return self.f[j]\n    def ifactorial(self, j):\n        return self.i[j]\n    def comb(self, n, k):\n        return self.f[n] * self.i[n - k] % self.mod * self.i[k] % self.mod if n >= k else 0\n\nN = int(input())\nG = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    a, b = list(map(int, input().split()))\n    G[a].append(b)\n    G[b].append(a)\n\nF = Factorial(N + 2, MOD)\n\nroot = 1\nstack = [root]\ncheck = [False] * (N + 1)\ncheck[root] = True\np = [0] * (N + 1) \n\nDAG = []\n\nwhile stack:\n    now_ = stack.pop()\n    DAG.append(now_)\n    for next_ in G[now_]:\n        if check[next_]:\n            continue\n        stack.append(next_)\n        check[next_] = True\n        p[next_] = now_\n\nsize1 = [0] * (N + 1)\ndp1 = [1] * (N + 1)\n\nfor now_ in DAG[::-1]:\n    size1[now_] += 1\n    size1[p[now_]] += size1[now_]\n    dp1[now_] *= F.factorial(size1[now_] - 1)\n    dp1[now_] %= MOD\n    dp1[p[now_]] *= dp1[now_] * F.ifactorial(size1[now_])\n    dp1[p[now_]] %= MOD\n\n# print (size1)\n# print (dp1)\n\nsize2 = [N - size1[i] + 1 for i in range(N + 1)]\ndp2 = [1] * (N + 1)\n\nfor i in DAG:\n    parent = i\n    for now_ in G[i]:\n        if now_ == p[i]:\n            continue\n        x = dp1[parent]\n        x *= F.ifactorial(size1[parent] - 1)\n        x *= F.factorial(size1[now_])\n        x *= pow(dp1[now_], MOD - 2, MOD)\n        x *= dp2[parent]\n        x *= F.ifactorial(size2[parent] - 1)\n        x *= F.factorial(size2[now_] - 2)\n        dp2[now_] = x % MOD\n \n# print (size2)\n# print (dp2)\n\nfor i in range(1, N + 1):\n    ans =  dp1[i] * F.ifactorial(size1[i] - 1) * dp2[i] * F.ifactorial(size2[i] - 1) * F.factorial(N - 1)\n    print((ans % MOD))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nMOD = 10 ** 9 + 7\n\n\ndef prepare(n):\n    nonlocal MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\ndef dfs(v):\n    nonlocal MOD\n    childs = 0\n    var = 1\n    for e in edge[v]:\n        if path[e] == 0:\n            path[e] = 1\n            nc, nvar = dfs(e)\n            childs += nc\n            V[v][e] = (nc, nvar)\n            var *= nvar\n            var %= MOD\n            var *= invs[nc]\n            var %= MOD\n    var *= modFacts[childs]\n    var %= MOD\n    return childs + 1, var\n\n\ndef dfs2(v):\n    nonlocal MOD\n    tNodes = 0\n    tVar = 1\n    for n, var in V[v].values():\n        tNodes += n\n        tVar *= var\n        tVar %= MOD\n        tVar *= invs[n]\n        tVar %= MOD\n    tVar *= modFacts[tNodes]\n    tVar %= MOD\n    dp[v] = tVar\n\n    for e in edge[v]:\n        if dp[e] == 0:\n            eNodes, eVar = V[v][e]\n            nVar = (tVar * invs[tNodes] * modFacts[eNodes] * modFacts[tNodes - eNodes]) % MOD\n            nVar *= pow(eVar, MOD - 2, MOD)\n            nVar %= MOD\n            V[e][v] = (tNodes - eNodes + 1, nVar)\n            dfs2(e)\n\n\nN = int(input())\nedge = [[] for _ in range(N)]\nfor s in sys.stdin.readlines():\n    a, b = map(int, s.split())\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\n\nmodFacts, invs = prepare(N)\n\nV = [{} for _ in range(N)]\npath = [0] * N\ndp = [0] * N\npath[0] = 1\ndfs(0)\ndfs2(0)\n\n\nprint(*dp, sep='\\n')\n", "import sys\n\nsys.setrecursionlimit(10**6)\nstdin = sys.stdin\n\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: map(int, stdin.readline().split())\nnl = lambda: list(map(int, stdin.readline().split()))\n\nn_ = 2 * 10**5 + 20\nmod = 10**9 + 7\nfun = [1] * (n_ + 1)\nfor i in range(1, n_ + 1):\n    fun[i] = fun[i - 1] * i % mod\nrev = [1] * (n_ + 1)\nrev[n_] = pow(fun[n_], mod - 2, mod)\nfor i in range(n_ - 1, 0, -1):\n    rev[i] = rev[i + 1] * (i + 1) % mod\n\ndef modinv(x, mod):\n    x %= mod\n    a, b = x, mod\n    u, v = 1, 0\n    while b:\n        t = a // b\n        a -= t * b; a, b = b, a\n        u -= t * v; u, v = v, u\n    return u % mod\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fun[n] * rev[r] % mod * rev[n - r] % mod\n\nn = ni()\ng = [list() for _ in range(n)]\nfor _ in range(n-1):\n    a,b = nm()\n    a -= 1; b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\nsl = [1]*n\npm = [1]*n\ndef dfs(v, p):\n    for x in g[v]:\n        if x == p:\n            continue\n        dfs(x, v)\n        sl[v] += sl[x]\n        pm[v] = pm[v] * pm[x] % mod\n    sv = sl[v] - 1\n    for x in g[v]:\n        if x == p:\n            continue\n        pm[v] = pm[v] * nCr(sv, sl[x]) % mod\n        sv -= sl[x]\n    return\n\ndef dfs2(v, p):\n    pp = pm[p] *  modinv(nCr(n-1, sl[v]) * pm[v], mod) % mod\n    sp = n - sl[v]\n    pm[v] = pm[v] * pp % mod * nCr(n-1, sp) % mod\n    for x in g[v]:\n        if x == p:\n            continue\n        dfs2(x, v)\n\ndfs(0, -1)\nfor x in g[0]:\n    dfs2(x, 0)\n\nprint(*pm, sep = '\\n')\n", "def main():\n    M=10**9+7\n    N=10**5*2\n    fac=[0]*(N+1)\n    fac[0]=b=1\n    for i in range(1,N+1):fac[i]=b=b*i%M\n    inv=[0]*(N+1)\n    inv[N]=b=pow(fac[N],M-2,M)\n    for i in range(N,0,-1):inv[i-1]=b=b*i%M\n    n,*t=open(0).read().split()\n    n=int(n)\n    e=[[]for _ in range(n)]\n    for a,b in zip(*[map(int,t)]*2):\n        e[a-1]+=b-1,\n        e[b-1]+=a-1,\n    o=[]\n    s=[0]\n    f=[1]*n\n    while s:\n        v=s.pop()\n        f[v]=0\n        o+=v,\n        l=[]\n        for w in e[v]:\n            if f[w]:\n                l+=w,\n                s+=w,\n        e[v]=l\n    sz1,sz2=[0]*n,[0]*n\n    dp1,dp2=[0]*n,[0]*n\n    c=[[]for _ in range(n)]\n    for v in o[::-1]:\n        s=b=1\n        c1,c2=[1],[1]\n        for w in e[v]:\n            u=sz1[w]\n            b=b*dp1[w]*inv[u]%M\n            c1+=b,\n            s+=u\n        b=1\n        for w in e[v][::-1]:\n            b=b*dp1[w]*inv[sz1[w]]%M\n            c2+=b,\n        c[v]=c1,c2[::-1]\n        sz1[v]=s\n        dp1[v]=b*fac[s-1]%M\n    # print(dp1)\n    sz2[0]=1\n    dp2[0]=1\n    for v in o:\n        l=len(e[v])\n        c1,c2=c[v]\n        uv=sz2[v]-1\n        tv=dp2[v]*inv[uv]\n        for i,w in enumerate(e[v]):\n            tw=c1[i]*c2[i+1]%M\n            uw=uv+sz1[v]-sz1[w]-1\n            dp2[w]=tv*tw*fac[uw]%M\n            sz2[w]=uw+2\n    # print(dp2)\n    a=[]\n    for dp1,dp2,sz1,sz2 in zip(dp1,dp2,sz1,sz2):\n        sz1-=1\n        sz2-=1\n        a+=str(dp1*dp2*inv[sz1]*inv[sz2]*fac[sz1+sz2]%M),\n    print('\\n'.join(a))\nmain()", "def main():\n  from collections import deque\n  N = int(input())\n  ab = [list(map(int,input().split())) for _ in range(N-1)]\n  mod = 10**9+7\n  fact = [1]*(N+1)\n  fact_inv = [1]*(N+1)\n  for i in range(1,N+1):\n    fact[i] = (fact[i-1]*i)%mod\n\n  fact_inv[-1] = pow(fact[-1], mod-2, mod)\n  for i in range(N,0,-1):\n    fact_inv[i-1] = fact_inv[i] * i % mod\n\n  g = [deque([]) for _ in range(N+1)]\n  for a,b in ab:\n    g[a].append(b)\n    g[b].append(a)\n\n  parents = [0]*(N+1)\n  q = deque([])\n  s = deque([1])\n  while s:\n    x = s.pop()\n    q.append(x)\n    for y in g[x]:\n      if y==parents[x]:\n        continue\n      else:\n        parents[y] = x\n        s.append(y)\n\n  q = list(q)\n  size_forward = [0]*(N+1)\n  dp_forward = [1]*(N+1)\n  for i in q[::-1]:\n    p = parents[i]\n    s = size_forward[i] + 1\n    size_forward[p] += s\n    dp_forward[i] *= fact[size_forward[i]]\n    dp_forward[p] *= dp_forward[i] * fact_inv[s]\n    dp_forward[p] %= mod\n\n  size_back = [N-1-i for i in size_forward]\n  dp_back = [1]*(N+1)\n  for i in q[1:]:\n    p = parents[i]\n    x = dp_back[p]\n    x *= fact_inv[size_back[p]]\n    x *= dp_forward[p]\n    x *= fact_inv[size_forward[p]]\n    x *= fact[size_forward[i]+1]\n    x *= pow(dp_forward[i],mod-2,mod)\n    x *= fact[size_back[i]-1]\n    dp_back[i] = x % mod\n\n  for a,b,c,d in zip(size_forward[1:], dp_forward[1:], size_back[1:], dp_back[1:]):\n    ans = b * d * fact[a+c] * fact_inv[a] * fact_inv[c]\n    ans %= mod\n    print(ans)\n    \nmain()", "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/abc160/tasks/abc160_f\n\n\u5168\u65b9\u4f4d\u6728dp\u306e\u5b9f\u88c5\u306f\u3069\u3046\u3057\u3088\u3046\uff1f\n\u307e\u305a0\u306b\u3064\u3044\u3066\u6c42\u3081\u3001\u5fc5\u8981\u306a\u5024\u3092\u53d6\u3063\u3066\u304a\u3044\u3066\u3001\u89aa\u306b\u8fd1\u3044\u65b9\u304b\u3089\u89aa\u306e\u5024\u3092\u4f7f\u3063\u3066\u6c42\u3081\u308b\n\u304c\u3088\u3055\u305d\u3046\n\n\n\u304b\u3051\u308b\u3079\u304d\u306f\u3001 N-1 C (N-\u5c0f\u90e8\u5206\u6728\u306b\u542b\u307e\u308c\u308b\u9802\u70b9\u6570) * \u89aa\u306e\u7b54\u3048 // (\u5c0f\u90e8\u5206\u6728\u306emu* N-1C\u5c0f\u90e8\u5206\u6728\u306e\u9802\u70b9\u6570)\n\"\"\"\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef inverse(a,mod): #a\u306emod\u3092\u6cd5\u306b\u3057\u305f\u9006\u5143\u3092\u8fd4\u3059\n    return pow(a,mod-2,mod)\n\n\n\n#mod\u306en!\u3068\u3001n!\u306e\u9006\u5143\u3092\u683c\u7d0d\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059(\u62fe\u3044\u3082\u306e)\n#factorials\u306b\u306f[1, 1!%mod , 2!%mod , 6!%mod\u2026 , n!%mod] \u304c\u5165\u3063\u3066\u3044\u308b\n#invs\u306b\u306f\u2191\u306e\u9006\u5143\u304c\u5165\u3063\u3066\u3044\u308b\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): #\u4e0a\u3067\u6c42\u3081\u305ffac\u3068invs\u3092\u5f15\u6570\u306b\u5165\u308c\u308b\u3079\u3057(\u4e0a\u306e\u95a2\u6570\u3067\u4e0e\u3048\u305fn\u304c\u8a08\u7b97\u3067\u304d\u308b\u6700\u5927\u306en\u306b\u306a\u308b)\n\n    return fac[n] * inv[n-r] * inv[r] % mod\n\n\nN = int(input())\nmod = 10**9+7\nfac,inv = modfac(N,mod)\n\nlis = [ [] for i in range(N)]\n\nfor i in range(N-1):\n\n    a,b = list(map(int,input().split()))\n    a -= 1\n    b -= 1\n\n    lis[a].append(b)\n    lis[b].append(a)\n\nplis = [i for i in range(N)]\nchnum = [0] * N\nmulis = [0] * N\n\ndef dfs(v,p):\n\n    rch = 1\n    rmu = 1\n    chlis = []\n\n    for nex in lis[v]:\n\n        if nex != p:\n\n            ch,mu = dfs(nex,v)\n            rch += ch\n            rmu *= mu\n            rmu %= mod\n            chlis.append(ch)\n\n    nsum = sum(chlis)\n\n    for i in range(len(chlis)):\n\n        rmu *= modnCr(nsum,chlis[i],mod,fac,inv)\n        rmu %= mod\n        nsum -= chlis[i]\n\n    plis[v] = p\n    chnum[v] = rch\n    mulis[v] = rmu\n\n    return rch,rmu\n\nans = [None] * N\n\ntemp,ans[0] = dfs(0,0)\n\n#print (plis,chnum,mulis)\n\n\ndef dfs2(v,p):\n\n    #print (v,p)\n\n    if v != 0:\n        vn = chnum[v]\n        mn = mulis[v]\n\n        ans[v] = ans[p] * modnCr(N-1,N-vn,mod,fac,inv) * inverse( modnCr(N-1,vn,mod,fac,inv) ,mod) % mod\n    for nex in lis[v]:\n        if nex != p:\n            dfs2(nex,v)\n\ndfs2(0,0)\nprint((\"\\n\".join(map(str,ans))))\n            \n    \n", "def hoge():\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n    sys.setrecursionlimit(max(1000, 10**9))\n\n\n    from collections import defaultdict\n    n = int(input())\n    ns = defaultdict(set)\n    for _ in range(n-1):\n        u,v = map(int, input().split())\n        ns[u-1].add(v-1)\n        ns[v-1].add(u-1)\n\n\n    M = 10**9+7 # \u51fa\u529b\u306e\u5236\u9650\n    N = n # \u5fc5\u8981\u306a\u30c6\u30fc\u30d6\u30eb\u30b5\u30a4\u30ba\n\n    g1 = [None] * (N+1) # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [None] * (N+1) #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [None] * (N+1) #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n    g1[0] = g1[1] = g2[0] = g2[1] = 1\n    inverse[0], inverse[1] = [0, 1] \n\n    for i in range( 2, N + 1 ):\n        g1[i] = ( g1[i-1] * i ) % M \n        inverse[i] = ( -inverse[M % i] * (M//i) ) % M # ai+b==0 mod M <=> i==-b*a^(-1) <=> i^(-1)==-b^(-1)*a\u3088\u308a\n        g2[i] = (g2[i-1] * inverse[i]) % M \n\n\n    ans = {}\n    prevs = {}\n    out = [None] * n\n    def sub(i, j, prev):\n        prevs[i,j] = prev\n        if (i,j) in ans:\n            return ans[i,j]\n        if len(ns[j])==1 and i in ns[j]:\n            ans[i,j] = (1, 1)\n            return (1, 1)\n\n        count = 1\n        sum_size = 0\n        for k in ns[j]:\n            if k==i:\n                continue\n            val, size = sub(j, k, i)\n            count = (count * val) % M\n            count = (count * g2[size]) % M\n            sum_size += size\n        count = (count * g1[sum_size]) % M\n        ans[i,j] = (count, sum_size+1)\n        return (count, sum_size+1)\n\n    def sub2(i, j):\n        for k in ns[j]:\n            if k==i:\n                continue\n            if (k, j) in ans:\n                continue\n            tmp_count, tmp_size = ans[j, k]\n            total_count, total_size = ans[prevs[j, k], j]\n            prev_count, prev_size = ans[j, i]\n            new_size = total_size - tmp_size + prev_size\n            new_count = (total_count * g2[total_size-1] * g1[new_size-1]) % M\n            new_count = (new_count * prev_count * pow(tmp_count, M-2, M)) % M\n            new_count = (new_count * g2[prev_size] * g1[tmp_size]) % M\n            ans[k, j] = (new_count, new_size)\n            val = tmp_count\n            val = (val * new_count * g1[new_size+tmp_size-1] * g2[tmp_size-1] * g2[new_size]) % M\n            out[k] = val\n            sub2(j, k)\n    #         print(\"total: \", total_count, total_size)\n    #         print(\"tmp: \", tmp_count, tmp_size)\n    #         print(\"prev: \", prev_count, prev_size)\n    #         new_count = total_count / g1[total_size-1] * g1[new_size-1] * prev_count / tmp_count / g1[prev_size] * g1[tmp_size]\n    #         print(new_count)\n    #         print(\"\")\n\n    # 0\u3092\u59cb\u70b9\u3068\u3057\u3066\u6728DP\n    sub(-1, 0, None)\n\n    ans[0, -1] = (1,0)\n\n    # \u9006\u5411\u304d\u3092\u6c42\u3081\u308b\n    sub2(-1, 0)\n    \n    u = 0\n    count = 1\n    sum_size = 0\n    for k in ns[u]:\n        val, size = ans[u, k] # sub(u, k, None)\n        count = (count * val) % M\n        count = (count * g2[size]) % M\n        sum_size += size\n    count = (count * g1[sum_size]) % M\n    out[0] = count\n    print(\"\\n\".join(map(str, out)))\nhoge()", "# modulo\nMOD = 10 ** 9 + 7\n\n# number of vertices\nn = int(input())\n# adjacency list\nedge = [[] for _ in range(n)]\n# 0-index\nfor _ in range(n-1):\n  a, b = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\n# factorial and inverse and inverse of factorial\nfact = [1] * n\ninverse = [1] * n\ninv_fact = [1] * n\nfor i in range(2, n):\n  fact[i] = fact[i-1] * i % MOD\n  inverse[i] = -inverse[MOD % i] * (MOD // i) % MOD\n  inv_fact[i] = inv_fact[i-1] * inverse[i] % MOD\n\n# regarding index 0 as root of tree\n# calculating parents of vertices and route from root with DFS\nstack = [0]\nparent = [0] * n\nroute = []\nwhile stack:\n  vertex = stack.pop()\n  route.append(vertex)\n  for child in edge[vertex]:\n    if parent[vertex] != child:\n      parent[child] = vertex\n      stack.append(child)\n\n# tree DP regarding index 0 as root of tree\n# process from leaves to root\ndp = [1] * n\nsize = [1] * n\nfor vertex in route[:0:-1]:\n  pa = parent[vertex]\n  sz = size[vertex]\n  dp[vertex] = dp[vertex] * fact[sz-1] % MOD\n  dp[pa] = dp[pa] * dp[vertex] * inv_fact[sz] % MOD\n  size[pa] += sz\ndp[0] = dp[0] * fact[n-1] % MOD\n\n# rerooting\n# process from root to leaves\nfor vertex in route[1:]:\n  pa = parent[vertex]\n  sz = size[vertex]\n  inv_dp = pow(dp[vertex], MOD - 2, MOD)\n  dp[vertex] = dp[vertex] * dp[pa] * inv_dp * sz * inverse[n-sz] % MOD\n\n# printing result\nfor value in dp:\n  print(value)", "from collections import deque\nN = int(input())\nab = [list(map(int,input().split())) for _ in range(N-1)]\nmod = 10**9+7\nfact = [1]*(N+1)\nfact_inv = [1]*(N+1)\nfor i in range(1,N+1):\n  fact[i] = (fact[i-1]*i)%mod\n  \nfact_inv[-1] = pow(fact[-1], mod-2, mod)\nfor i in range(N,0,-1):\n  fact_inv[i-1] = fact_inv[i] * i % mod\n\ng = [deque([]) for _ in range(N+1)]\nfor a,b in ab:\n  g[a].append(b)\n  g[b].append(a)\n  \nparents = [0]*(N+1)\nq = deque([])\ns = deque([1])\nwhile s:\n  x = s.pop()\n  q.append(x)\n  for y in g[x]:\n    if y==parents[x]:\n      continue\n    else:\n      parents[y] = x\n      s.append(y)\n      \nq = list(q)\nsize_forward = [0]*(N+1)\ndp_forward = [1]*(N+1)\nfor i in q[::-1]:\n  p = parents[i]\n  s = size_forward[i] + 1\n  size_forward[p] += s\n  dp_forward[i] *= fact[size_forward[i]]\n  dp_forward[p] *= dp_forward[i] * fact_inv[s]\n  dp_forward[p] %= mod\n  \nsize_back = [N-1-i for i in size_forward]\ndp_back = [1]*(N+1)\nfor i in q[1:]:\n  p = parents[i]\n  x = dp_back[p]\n  x *= fact_inv[size_back[p]]\n  x *= dp_forward[p]\n  x *= fact_inv[size_forward[p]]\n  x *= fact[size_forward[i]+1]\n  x *= pow(dp_forward[i],mod-2,mod)\n  x *= fact[size_back[i]-1]\n  dp_back[i] = x % mod\n  \nfor a,b,c,d in zip(size_forward[1:], dp_forward[1:], size_back[1:], dp_back[1:]):\n  ans = b * d * fact[a+c] * fact_inv[a] * fact_inv[c]\n  ans %= mod\n  print(ans)", "import sys\n\ndef solve():\n    input = lambda: sys.stdin.readline().rstrip()\n    sys.setrecursionlimit(10 ** 7)\n    mod = 10 ** 9 + 7\n\n    def comb(n, r):\n        if r > n: return 0\n        return fac[n] * inv[r] * inv[n - r] % mod\n\n    def dfs(v, Pa=-1):\n        for u in to[v]:\n            if u == Pa: continue\n            dfs(u, v)\n            size[v] += size[u]\n            dp[v] *= dp[u] % mod\n            dp[v] *= inv[size[u]] % mod\n        dp[v] *= fac[size[v]] % mod\n        size[v] += 1\n\n    def bfs(v, Pa=-1, P_val=1, P_sz=0):\n        ans[v] = P_val * dp[v] * comb(n - 1, P_sz) % mod\n        for u in to[v]:\n            if u == Pa: continue\n            val = ans[v] * INV(dp[u] * comb(n - 1, size[u])) % mod\n            bfs(u, v, val, n - size[u])\n\n    n = int(input())\n    to = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(lambda x: int(x) - 1, input().split())\n        to[a].append(b)\n        to[b].append(a)\n\n    fac = [1] * (n + 2)\n    inv = [1] * (n + 2)\n\n    for i in range(2, n + 1):\n        fac[i] = fac[i - 1] * i % mod\n    INV = lambda x: pow(x, mod - 2, mod)\n    inv[n] = INV(fac[n])\n    for i in range(n - 1, 1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % mod\n\n    dp = [1] * n\n    size = [0] * n\n    ans = [0] * n\n\n    dfs(0)\n    bfs(0)\n    print(*ans, sep='\\n')\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        a, b = a-1, b-1\n        g[a].append(b)\n        g[b].append(a)\n\n    mod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\n    N = 10**6\n    g1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\n    g2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\n    inverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\n    for i in range( 2, N + 1 ):\n        g1.append( ( g1[-1] * i ) % mod )\n        inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n        g2.append( (g2[-1] * inverse[-1]) % mod )\n\n    # topological sort\n    s = []\n    s.append(0)\n    parent = [-1]*n\n    order = []\n    while s:\n        v = s.pop()\n        order.append(v)\n        for u in g[v]:\n            if u == parent[v]:\n                continue\n            parent[u] = v\n            s.append(u)\n\n    dp = [1]*n\n    c = [0]*n\n    order.reverse()\n    for v in order:\n        dp[v] *= g1[c[v]]\n        dp[v] %= mod\n        c[v] += 1\n        if parent[v] == -1:\n            continue\n        c[parent[v]] += c[v]\n        dp[parent[v]] *= (dp[v]*g2[c[v]])\n        dp[parent[v]] %= mod\n\n    order.reverse()\n    ans = [0]*n\n    for v in order:\n        ans[v] = dp[v]\n        for u in g[v]:\n            if u == parent[v]:\n                continue\n            dp[u] *= ans[v]*g2[c[v]-1]*g1[c[v]-1-c[u]]*g1[c[u]]*pow(dp[u],(mod-2),mod)\n            dp[u] *= g2[c[u]-1]\n            dp[u] *= g1[c[v]-1]\n            dp[u] *= g2[c[v]-c[u]]\n            dp[u] %= mod\n            c[u] = c[v]\n    for i in range(n):\n        print(ans[i]%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "from functools import reduce\n# \u6728\u3092\u5358\u65b9\u5411\u306b\ndef rerooting(n, edges, identity, merge, add_node):\n    # \u5168\u65b9\u4f4d\u6728 dp\n    # \u53c2\u80031: https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n    # \u53c2\u80032: https://atcoder.jp/contests/abc160/submissions/15255726\n    from functools import reduce\n    G = [[] for _ in range(n)]\n    for a, b in edges:\n        G[a].append(b)\n        G[b].append(a)\n    # step 1\n    order = []  # \u884c\u304d\u304c\u3051\u9806\n    stack = [0]\n    while stack:\n        v = stack.pop()\n        order.append(v)\n        for u in G[v]:\n            stack.append(u)\n            G[u].remove(v)\n    # \u4e0b\u304b\u3089\u767b\u308b\n    dp_down = [0]*n  # \u81ea\u8eab\u3068\u305d\u306e\u4e0b\n    for v in order[:0:-1]:\n        dp_down[v] = add_node(reduce(\n            merge, (dp_down[u] for u in G[v]), identity\n        ), v)\n    # step 2\n    # \u4e0a\u304b\u3089\u964d\u308a\u308b\n    dp_up = [identity] * n  # \u89aa\u3068\u305d\u306e\u5148\n    for v in order:\n        Gv = G[v]\n        if len(Gv) == 0:\n            continue\n        cum = identity\n        right = [identity]\n        for u in Gv[:0:-1]:\n            cum = merge(dp_down[u], cum)\n            right.append(cum)\n        right.reverse()\n        cum = dp_up[v]\n        for u, cum_r in zip(Gv, right):\n            dp_up[u] = add_node(merge(cum, cum_r), v)\n            cum = merge(cum, dp_down[u])\n    results = [add_node(\n        merge(\n            reduce(merge, (dp_down[u] for u in Gv), identity),\n            dp_up[v]\n        ), v\n    ) for v, Gv in enumerate(G)]\n    return results\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\ndef main():\n    N = int(input())\n    AB = [list([int(x)-1 for x in input().split()]) for _ in range(N-1)]\n    mod = 10**9 + 7\n    comb = Combination(202020)\n    identity = (1, 0)\n    fac, facinv = comb.fac, comb.facinv\n    def merge(a, b):\n        a0, a1 = a\n        b0, b1 = b\n        return a0*b0*fac[a1+b1]*facinv[a1]*facinv[b1]%mod, a1+b1\n    def add_node(a, idx):\n        a0, a1 = a\n        return a0, a1+1\n    Ans = rerooting(N, AB, identity, merge, add_node)\n    print((\"\\n\".join(str(ans) for ans, _ in Ans)))\n\nmain()\n", "from functools import reduce\n# reduce\n\ndef rerooting(n, edges, identity, merge, add_node):\n    # \u5168\u65b9\u4f4d\u6728 dp\n    # \u53c2\u80031: https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n    # \u53c2\u80032: https://atcoder.jp/contests/abc160/submissions/15255726\n    from functools import reduce\n    G = [[] for _ in range(n)]\n    for a, b in edges:\n        G[a].append(b)\n        G[b].append(a)\n    # step 1\n    parents = [0] * n\n    order = []  # \u884c\u304d\u304c\u3051\u9806\n    stack = [0]\n    parents[0] = -1\n    while stack:\n        v = stack.pop()\n        p = parents[v]\n        order.append(v)\n        for u in G[v]:\n            if p != u:\n                stack.append(u)\n                parents[u] = v\n    # \u4e0b\u304b\u3089\u767b\u308b\n    dp_down = [0]*n  # \u81ea\u8eab\u3068\u305d\u306e\u4e0b\n    for v in order[:0:-1]:\n        p = parents[v]\n        dp_down[v] = add_node(reduce(\n            merge,\n            (dp_down[u] for u in G[v] if u!=p),\n            identity\n        ), v)\n    # step 2\n    # \u4e0a\u304b\u3089\u964d\u308a\u308b\n    dp_up = [identity] * n  # \u89aa\u3068\u305d\u306e\u5148\n    for v in order:\n        Gv = G[v]\n        if len(Gv) == 1 and v != 0:\n            continue\n        p = parents[v]\n        cum = identity\n        right = [identity]\n        for u in Gv[::-1]:\n            if u != p:\n                cum = merge(dp_down[u], cum)\n                right.append(cum)\n        cum = dp_up[v]\n        idx_right = -2\n        for u in Gv:\n            if u != p:\n                dp_up[u] = add_node(merge(cum, right[idx_right]), v)\n                idx_right -= 1\n                cum = merge(cum, dp_down[u])\n    results = [add_node(\n        merge(\n            reduce(merge, (dp_down[u] for u in Gv if u != parents[v]), identity),\n            dp_up[v]\n        ), v\n    ) for v, Gv in enumerate(G)]\n    return results\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\ndef main():\n    N = int(input())\n    AB = [list([int(x)-1 for x in input().split()]) for _ in range(N-1)]\n    mod = 10**9 + 7\n    comb = Combination(202020)\n    identity = (1, 0)\n    fac, facinv = comb.fac, comb.facinv\n    def merge(a, b):\n        a0, a1 = a\n        b0, b1 = b\n        return a0*b0*fac[a1+b1]*facinv[a1]*facinv[b1]%mod, a1+b1\n    def add_node(a, idx):\n        a0, a1 = a\n        return a0, a1+1\n    Ans = rerooting(N, AB, identity, merge, add_node)\n    print((\"\\n\".join(str(ans) for ans, _ in Ans)))\n\nmain()\n", "N=int(input())\nAB=[list(map(int,input().split())) for i in range(N-1)]\nc=[[] for i in range(N)]\nfor a,b in AB:\n    c[a-1].append(b-1)\n    c[b-1].append(a-1)\nv=[1]+[0]*(N-1)\nx=[0]\ns=[]\nparent=[-1]*N\nchild=[[] for i in range(N)]\nwhile x:\n    p=x.pop()\n    s.append(p)\n    for n in c[p]:\n        if v[n]==0:\n            v[n]=1\n            x.append(n)\n            parent[n]=p\n            child[p].append(n)\nm=10**9+7\nfac=[1]*(N+10)\ninv=[1]*(N+10)\nifac=[1]*(N+10)\nfor n in range(2,N+10):\n    fac[n]=(fac[n-1]*n)%m\n    inv[n]=m-inv[m%n]*(m//n)%m\n    ifac[n]=(ifac[n-1]*inv[n])%m\nsize=[1]*N+[0]\ndp=[1]*N+[0]\nfor n in s[::-1]:\n    p=parent[n]\n    size[p]+=size[n]\n    dp[n]=dp[n]*fac[size[n]-1]%m\n    dp[p]=dp[p]*ifac[size[n]]*dp[n]%m\nsize2=[N-v+1 for v in size]\ndp2=[1]*N\nfor n in s[1:]:\n    p=parent[n]\n    dp2[n]=dp[p]*ifac[size[p]-1]*dp2[p]*ifac[size2[p]-1]*pow(dp[n],m-2,m)*fac[size[n]]*fac[size2[n]-2]%m\nfor i in range(N):\n    print(dp[i]*dp2[i]*fac[size[i]+size2[i]-2]*ifac[size[i]-1]*ifac[size2[i]-1]%m)", "n = int(input())\nab = [list(map(int, input().split())) for _ in range(n - 1)]\nmod = 10 ** 9 + 7\n\nMAX = n\n\nfact = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact[i] = (fact[i-1] * i) % mod\n\ninv = [1] * (MAX + 1)\nfor i in range(2, MAX + 1):\n    inv[i] = inv[mod % i] * (mod - mod // i) % mod\n\nfact_inv = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    fact_inv[i] = fact_inv[i-1] * inv[i] % mod\n\n\nadj = [[] for _ in range(n + 1)]\nfor a, b in ab:\n    adj[a].append(b)\n    adj[b].append(a)\n\nroot = 1\nstack = [root]\npar = [0] * (n + 1)\norder = []\nwhile stack:\n    u = stack.pop()\n    order.append(u)\n    for v in adj[u]:\n        if v == par[u]:\n            continue\n        par[v] = u\n        stack.append(v)\n\nsize_d = [0] * (n + 1)\ndp_d = [1] * (n + 1)\nfor v in order[::-1]:\n    dp_d[v] *= fact[size_d[v]]\n    dp_d[v] %= mod\n    \n    s = size_d[v] + 1\n    p = par[v]\n    size_d[p] += s\n    dp_d[p] *= fact_inv[s] * dp_d[v]\n    dp_d[p] %= mod\n\nsize_u = [n - 2 - e for e in size_d]\ndp_u = [1] * (n + 1)\nfor v in order[1:]:\n    p = par[v]\n    x = dp_d[p]\n    x *= fact_inv[size_d[p]]\n    x *= fact[size_d[v] + 1]\n    x *= pow(dp_d[v], mod - 2, mod)\n    x *= fact[size_u[v]]\n    x *= fact_inv[size_u[p] + 1]\n    x *= dp_u[p]\n    dp_u[v] = x % mod\n\nfor eu, su, ed, sd in zip(dp_u[1:], size_u[1:], dp_d[1:], size_d[1:]):\n    su += 1\n    ans = eu * ed * fact[su + sd] * fact_inv[su] * fact_inv[sd] % mod\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nU = 2*10**5\nMOD = 10**9+7\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n\nn = int(input())\nT = [[] for _ in range(n)]\nfor _ in range(n-1):\n  a, b = map(int, input().split())\n  a -= 1\n  b -= 1\n  T[a].append(b)\n  T[b].append(a)\nsize = [0]*n\npar = [-1]*n\ndp1 = [-1]*n\ndp2 = [-1]*n\ndef dfs1(p, v):\n  if dp1[v] != -1:\n    return dp1[v]\n  temp = 1\n  s = 1\n  for nv in T[v]:\n    if nv == p:\n      continue\n    temp *= dfs1(v, nv)\n    temp *= fact_inv[size[nv]]\n    temp %= MOD\n    par[nv] = v\n    s += size[nv]\n  size[v] = s\n  temp *= fact[s-1]\n  temp %= MOD\n  dp1[v] = temp\n  return temp\ndfs1(-1, 0)\ndef dfs2(v):\n  if v == 0:\n    return dp1[0]\n  if dp2[v] != -1:\n    return dp2[v]\n  temp = dfs2(par[v])\n  temp *= fact[n-size[v]-1]\n  temp *= fact[size[v]]\n  temp %= MOD\n  temp *= fact_inv[size[v]-1]\n  temp *= fact_inv[n-size[v]]\n  temp %= MOD\n  dp2[v] = temp\n  return temp\nfor i in range(n):\n  print(dfs2(i))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    MOD = 10**9 + 7\n\n    N = int(input())\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a, b = list(map(int, input().split()))\n        a, b = a-1, b-1\n        adjL[a].append(b)\n        adjL[b].append(a)\n\n    def getInvs(n, MOD):\n        invs = [1] * (n+1)\n        for x in range(2, n+1):\n            invs[x] = (-(MOD//x) * invs[MOD%x]) % MOD\n        return invs\n    invs = getInvs(N, MOD)\n\n    dp = [[] for _ in range(N)]\n    outdegs = [0] * N\n    sizes = [0] * N\n    iPars = [-1] * N\n    def dfsDP(v, vPar):\n        outdeg = outdegs[v] = len(adjL[v])\n        dp[v] = [0] * outdeg\n        res = 1\n        sizes[v] = 1\n        for i, v2 in enumerate(adjL[v]):\n            if v2 == vPar:\n                iPars[v] = i\n                continue\n            dp[v][i] = dfsDP(v2, v)\n            res = res * dp[v][i] % MOD\n            sizes[v] += sizes[v2]\n        return res * invs[sizes[v]] % MOD\n\n    anss = [0] * N\n    def dfsAns(v, vPar, resPar):\n        if vPar != -1:\n            dp[v][iPars[v]] = resPar\n\n        outdeg = outdegs[v]\n        dpL = [1] * (outdeg+1)\n        for i in range(outdeg):\n            v2 = adjL[v][i]\n            dpL[i+1] = dpL[i] * dp[v][i] % MOD\n        dpR = [1] * (outdeg+1)\n        for i in reversed(list(range(outdeg))):\n            v2 = adjL[v][i]\n            dpR[i] = dpR[i+1] * dp[v][i] % MOD\n        anss[v] = dpL[-1] * invs[N]\n\n        for i, v2 in enumerate(adjL[v]):\n            if v2 == vPar: continue\n            dfsAns(v2, v, dpL[i] * dpR[i+1] * invs[N-sizes[v2]] % MOD)\n\n\n    dfsDP(0, -1)\n    dfsAns(0, -1, 0)\n\n    def getFact(n, MOD):\n        fact = 1\n        for i in range(1, n+1):\n            fact = (fact * i) % MOD\n        return fact\n    factN = getFact(N, MOD)\n\n    for v in range(N):\n        anss[v] = anss[v] * factN % MOD\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "MOD = 10 ** 9 + 7\nMAX_N = 2 * 10 ** 5\n\nfact = [1] * MAX_N\ninverse = [1] * MAX_N\ninv_fact = [1] * MAX_N\nfor i in range(2, MAX_N):\n  fact[i] = fact[i-1] * i % MOD\n  inverse[i] = -inverse[MOD % i] * (MOD // i) % MOD\n  inv_fact[i] = inv_fact[i-1] * inverse[i] % MOD\n\nn = int(input())\nedge = [[] for _ in range(n)]\nfor _ in range(n-1):\n  a, b = map(int, input().split())\n  edge[a-1].append(b-1)\n  edge[b-1].append(a-1)\n\nstack = [0]\nparent = [0] * n\nroute = []\nwhile stack:\n  vertex = stack.pop()\n  route.append(vertex)\n  for child in edge[vertex]:\n    if parent[vertex] != child:\n      parent[child] = vertex\n      stack.append(child)\n\ndp = [1] * n\nsize = [1] * n\nfor vertex in route[:0:-1]:\n  pa = parent[vertex]\n  sz = size[vertex]\n  dp[vertex] = dp[vertex] * fact[sz-1] % MOD\n  dp[pa] = dp[pa] * dp[vertex] * inv_fact[sz] % MOD\n  size[pa] += sz\ndp[0] = dp[0] * fact[n-1] % MOD\n\nfor vertex in route[1:]:\n  pa = parent[vertex]\n  sz = size[vertex]\n  tmp = dp[pa] * pow(dp[vertex], MOD - 2, MOD) * sz * inverse[n-sz] % MOD\n  dp[vertex] = dp[vertex] * tmp % MOD\n\nfor value in dp:\n  print(value)", "n = int(input())\ngraph = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    graph[a].append(b)\n    graph[b].append(a)\nmod = 10**9 + 7\nfactorial = [1]*(n+1)\nfactorial_inv = [1]*(n+1)\nfor i in range(1,n+1):\n    factorial[i] = factorial[i-1]*i%mod\nfactorial_inv[n] = pow(factorial[n],mod-2,mod)\nfor i in range(n,0,-1):\n    factorial_inv[i-1] = factorial_inv[i]*i%mod\n\npa = [0]*(n+1)\ndp = [1]*(n+1)\nsize = [1]*(n+1)\nchecked = []\nstack = [i]\nwhile stack:\n    a = stack.pop()\n    checked.append(a)\n    for j in graph[a]:\n        if pa[a] == j:   \n            continue\n        else:\n            stack.append(j)\n            pa[j] = a\n\nfor i in checked[::-1]:\n    p = pa[i]\n    s = size[i]\n    dp[i] *= factorial[s-1]\n    dp[i] %= mod\n    dp[p] *= dp[i]*factorial_inv[s]\n    dp[p] %= mod\n    size[p] += s\n\nsize_ = [n-i+1 for i in size]\ndp_ = [1]*(n+1)\nfor i in checked[1:]:\n    p = pa[i]\n    dp_[i] *= dp[p]\n    dp_[i] *= factorial_inv[size[p]-1]\n    dp_[i] *= pow(dp[i],mod-2,mod)\n    dp_[i] *= factorial[size[i]]\n    dp_[i] *= dp_[p]\n    dp_[i] *= factorial_inv[size_[p]-1]\n    dp_[i] *= factorial[size_[i]-2]\n    dp_[i] %= mod\n    \nfor i in range(1,n+1):\n    ans = factorial[n-1]*dp[i]*dp_[i]*factorial_inv[size[i]-1]*factorial_inv[size_[i]-1]\n    ans %= mod\n    print(ans)", "from functools import reduce\n# \u90e8\u5206\u6728\u306e\u89e3\u3092 1 \u6b21\u5143\u3067\u6301\u3064\u3088\u3046\u306b\u5909\u66f4\n\ndef rerooting(n, edges, identity, merge, add_node):\n    # \u5168\u65b9\u4f4d\u6728 dp\n    # \u53c2\u80031: https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e\n    # \u53c2\u80032: https://atcoder.jp/contests/abc160/submissions/15255726\n    from functools import reduce\n    G = [[] for _ in range(n)]\n    for a, b in edges:\n        G[a].append(b)\n        G[b].append(a)\n    # step 1\n    parents = [0] * n\n    order = []  # \u884c\u304d\u304c\u3051\u9806\n    stack = [0]\n    parents[0] = -1\n    while stack:\n        v = stack.pop()\n        p = parents[v]\n        order.append(v)\n        for u in G[v]:\n            if p != u:\n                stack.append(u)\n                parents[u] = v\n    # \u4e0b\u304b\u3089\u767b\u308b\n    dp_down = [0]*n  # \u81ea\u8eab\u3068\u305d\u306e\u4e0b\n    for v in order[:0:-1]:\n        p = parents[v]\n        result = identity\n        for u in G[v]:\n            if p != u:\n                result = merge(result, dp_down[u])\n        dp_down[v] = add_node(result, v)\n    # step 2\n    # \u4e0a\u304b\u3089\u964d\u308a\u308b\n    dp_up = [identity] * n  # \u89aa\u3068\u305d\u306e\u5148\n    for v in order:\n        Gv = G[v]\n        if len(Gv) == 1 and v != 0:\n            continue\n        p = parents[v]\n        cum = identity\n        right = [identity]\n        for u in Gv[::-1]:\n            if u != p:\n                cum = merge(dp_down[u], cum)\n                right.append(cum)\n        cum = dp_up[v]\n        idx_right = -2\n        for u in Gv:\n            if u != p:\n                dp_up[u] = add_node(merge(cum, right[idx_right]), v)\n                idx_right -= 1\n                cum = merge(cum, dp_down[u])\n    results = [add_node(\n        merge(\n            reduce(merge, (dp_down[u] for u in Gv if u != parents[v]), identity),\n            dp_up[v]\n        ), v\n    ) for v, Gv in enumerate(G)]\n    return results\n\nclass Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\ndef main():\n    N = int(input())\n    AB = [list([int(x)-1 for x in input().split()]) for _ in range(N-1)]\n    mod = 10**9 + 7\n    comb = Combination(202020)\n    identity = (1, 0)\n    fac, facinv = comb.fac, comb.facinv\n    def merge(a, b):\n        a0, a1 = a\n        b0, b1 = b\n        return a0*b0*fac[a1+b1]*facinv[a1]*facinv[b1]%mod, a1+b1\n    def add_node(a, idx):\n        a0, a1 = a\n        return a0, a1+1\n    Ans = rerooting(N, AB, identity, merge, add_node)\n    print((\"\\n\".join(str(ans) for ans, _ in Ans)))\n\nmain()\n", "import sys\nsys.setrecursionlimit(1000000)\n\n\ndef input():\n    return sys.stdin.readline()\n\n\nn = int(input())\ne = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = [int(i) - 1 for i in input().split()]\n    e[a].append(b)\n    e[b].append(a)\n\nmod = 10**9+7\n\nkkai = [1]\nfor i in range(1, 2*10 ** 5):\n    kkai.append(kkai[-1] * i % mod)\n\n\ndef kai(x, p=mod):\n    return kkai[x]\n\n\ndef comb(a, b, p=mod):\n    if a < 0 or b < 0:\n        return 0\n    elif a < b:\n        return 0\n    if b == 0:\n        return 1\n    c = 1\n    c *= kai(a, p)\n    c *= pow(kai(b, p), p - 2, p)\n    c *= pow(kai(a - b, p), p - 2, p)\n    return c % p\n\n\nchild = [0] * n\n\n\ndef dfs1(i=0, r=-1):\n    s = 1\n    for j in e[i]:\n        if j == r:\n            continue\n        s += dfs1(j, i)\n    child[i] = s\n    return s\n\n\ndfs1()\na = [0] * n\n\n\ndef dfs2(i=0, r=-1):\n    s = kai(child[i]-1)\n    t = 1\n    for j in e[i]:\n        if j == r:\n            continue\n        s *= dfs2(j, i)\n        s %= mod\n        t *= kai(child[j])\n        t %= mod\n    s *= pow(t, mod - 2, mod)\n    s %= mod\n    a[i] = s\n    return s\n\n\ndfs2()\nb = [0] * n\n\n\ndef dfs3(i=0, r=-1):\n    if r == -1:\n        b[i] = a[i]\n    else:\n        s = b[r] * child[i] % mod\n        s *= pow(n-child[i], mod - 2, mod)\n        s %= mod\n        b[i] = s\n\n    for j in e[i]:\n        if j == r:\n            continue\n        dfs3(j, i)\n\n\ndfs3()\nprint((\"\\n\".join(map(str, b))))\n", "#!/usr/bin/env python3\nimport sys\nfrom collections import defaultdict\nMOD = 1000000007  # type: int\n\n\nclass Combination(object):\n\n    def __init__(self, N, mod=MOD):\n        fac, finv, inv = [0]*(N+1), [0]*(N+1), [0]*(N+1)\n        fac[:2] = 1, 1\n        finv[:2] = 1, 1\n        inv[1] = 1\n        for i in range(2, N+1):\n            fac[i] = fac[i-1]*i % mod\n            inv[i] = -inv[mod % i]*(mod//i) % mod\n            finv[i] = finv[i-1]*inv[i] % mod\n        self.N = N\n        self.MOD = mod\n        self.fac = fac\n        self.finv = finv\n        self.inv = inv\n\n    def __call__(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        b = (self.finv[k]*self.finv[n-k] % self.MOD)\n        return (self.fac[n] * b) % self.MOD\n\n\ndef make_downward(E, N, s=0):\n    # BFS\u3067downward\u9806\u3092\u69cb\u6210\u3059\u308b\n    front, back = 0, 1\n    downward = [s]*N\n    parent = [-1]*N\n    for _ in range(N-1):\n        v = downward[front]\n        front += 1\n        for u in E[v]:\n            if u == parent[v]:\n                continue\n            parent[u] = v\n            downward[back] = u\n            back += 1\n    # print(downward)\n    return downward, parent\n\n\ndef solve(N: int, a: \"List[int]\", b: \"List[int]\"):\n    # \u30b0\u30e9\u30d5\u306e\u69cb\u7bc9\n    E = [[] for _ in range(N)]\n    for aa, bb in zip(a, b):\n        E[aa-1].append(bb-1)\n        E[bb-1].append(aa-1)\n\n    # \u7d44\u307f\u5408\u308f\u305b\u306e\u521d\u671f\u5316\n    cmb = Combination(N)\n\n    # BFS\u3067downward\u9806\u3092\u69cb\u6210\u3059\u308b\n    downward, parent = make_downward(E, N)\n\n    # \u7bc0\u70b9v\u3092\u6839\u3068\u3057\u305f\u90e8\u5206\u6728\u306e\u5857\u308a\u65b9dp[v]\n    dp = [1]*N\n    # \u7bc0\u70b9v\u3092\u6839\u3068\u3057\u305f\u90e8\u5206\u6728\u306e\u30b5\u30a4\u30basize[v]+1\n    size = [0]*N\n\n    # \u6728DP\n    # \u8449\u304b\u3089\u6839\u3078\u5411\u304b\u3046\u63a2\u7d22\n    for v in reversed(downward):\n        for u in E[v]:\n            if u == parent[v]:\n                continue\n            size[v] += size[u]+1\n            dp[v] *= cmb.finv[size[u]+1]\n            dp[v] %= MOD\n            dp[v] *= dp[u]\n            dp[v] %= MOD\n        dp[v] *= cmb.fac[size[v]]\n        dp[v] %= MOD\n\n    # \u5168\u65b9\u4f4d\u6728DP\n    # \u6839\u304b\u3089\u8449\u3078\u5411\u304b\u3046\u63a2\u7d22\n    for v in downward:\n        for u in E[v]:\n            if u == parent[v]:\n                continue\n            dp[u] = dp[v]\n            dp[u] *= (size[u]+1)*cmb.inv[N-(size[u]+1)]\n            dp[u] %= MOD\n\n    for v in dp:\n        print(v)\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    a = [int()] * (N - 1)  # type: \"List[int]\"\n    b = [int()] * (N - 1)  # type: \"List[int]\"\n    for i in range(N - 1):\n        a[i] = int(next(tokens))\n        b[i] = int(next(tokens))\n    solve(N, a, b)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\narr = [list(map(int,input().split())) for _ in range(n-1)]\nmod = 10**9+7\n\ngraph = [[] for _ in range(n)]\nfor a,b in arr:\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\nparents = [-1] * n\nchildren = [[] for _ in range(n)]\nflags = [True] * n; flags[0] = False\nstack = [0]\norders = []\n\nwhile stack:\n    index = stack.pop()\n    orders.append(index)\n    for child in graph[index]:\n        if flags[child]:\n            parents[child] = index\n            children[index].append(child)\n            flags[child] = False\n            stack.append(child)\n\nfac = [1] * (n+10)\ninv = [1] * (n+10)\nifac = [1] * (n+10)\nfor i in range(2,n+10):\n    fac[i]=(fac[i-1]*i)%mod\n    inv[i]= -(inv[mod%i]*(mod//i))%mod\n    ifac[i]=(ifac[i-1]*inv[i])%mod\n\nsize = [1] * n\ndp = [1] * n\nfor parent in orders[::-1]:\n    for child in children[parent]:\n        size[parent] += size[child]\n        dp[parent] = dp[parent] * dp[child] * ifac[size[child]] % mod\n    dp[parent] = dp[parent] * fac[size[parent]-1] % mod\n\nsize2 = [n-i+1 for i in size]\ndp2 = [1] * n\nfor parent in orders[1:]:\n    child = parents[parent]\n    dp2[parent] = dp2[parent] * fac[size2[parent]-2] * dp[child] * dp2[child] * fac[size[parent]] * ifac[size2[child]-1] * ifac[size[child]-1] * pow(dp[parent], mod-2, mod) % mod\n    \nfor i in range(n):\n    print(fac[n-1] * ifac[size[i]-1] * ifac[size2[i]-1] * dp[i] * dp2[i] % mod)"]
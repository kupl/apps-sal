["mod = 10**9 + 7\n\ndef power(p, e):\n  ret = 1\n  while(e):\n    if(e & 1):\n      ret *= p\n      ret %= mod\n    p *= p\n    e >>= 1\n  return ret\n\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\n\nf = 0\nfor i in range(N):\n  f += (N - i + 1) * C[i]\n  f %= mod\n\nf *= power(2, N - 1)**2 % mod\nf %= mod\nprint(f)", "#import sys\n#sys.setrecursionlimit(10**5)\nMOD = 10**9+7\n\n# input\nN = int(input())\nC = list(map(int, input().split()))\n    \n# process\nC.sort(reverse=True)\nans = 0\n\nif N == 1:\n    ans = C[0]*2**N\nelse:\n    for i in range(N):\n        ans += C[i]*(2+i)\n\n    ans *= 4**(N-1)\n\n# output\nprint((ans%MOD))\n", "n=int(input())\nC=list(map(int,input().split()))\nC=sorted(C,reverse=True)\nmod=10**9+7\na=pow(2,2*n-2,mod)\nans=0\nfor i in range(n):\n  ans=ans+C[i]*(i+2)*a\nprint(ans%mod)", "n = int(input())\nc = sorted(map(int, input().split()))\n\nmod = 1000000007\n\nret = 0\nfor i in range(n):\n    ret = (ret + (i + 2) * c[n - i - 1]) % mod\n\nfor i in range(n - 1):\n    ret = (ret * 4) % mod\n\nprint(ret)\n", "def solve():\n  ans = 0\n  N = int(input())\n  C = list(map(int, input().split()))\n  C.sort()\n  mod = 10**9+7\n  for i in range(N):\n    ans += C[i]*(N+1-i)\n  ans = ans*pow(2,2*N-2,mod)%mod\n  return ans\nprint(solve())", "N = int(input())\nC = list(map(int, input().split()))\nC.sort(reverse =  True)\n\nMOD = 10 ** 9 + 7\n\nif N == 1:\n    print (2 * C[0] % MOD)\n    return\n\nstart = pow(2, N - 1, MOD)\nstep = pow(2, N - 2, MOD)\nans = 0\nfor c in C:\n    ans += c * start\n    ans %= MOD\n    start += step\n    start %= MOD\n\nans *= pow(2, N, MOD)\nans %= MOD\n\nprint (ans)", "MOD = 10**9 + 7\n\nN = int(input())\nCs = list(map(int, input().split()))\n\nCs.sort(reverse=True)\n\npow2 = pow(2, 2*N-2, MOD)\n\nans = 0\nfor i, C in enumerate(Cs, start=1):\n    ans += C*(i+1)*pow2\n    ans %= MOD\n\nprint(ans)\n", "mod=10**9+7\nn=int(input())\narr=list(map(int,input().split()))\narr=sorted(arr)\nans=0\nfor i in range(n):\n  ans+=pow(2,2*n-2,mod)*(n-i+1)*arr[i]\n  ans%=mod\nprint(int(ans))", "N = int(input())\nC = list(map(int,input().split()))\nfor i in range(N):\n    C[i] *= -1\nC.sort()\nfor i in range(N):\n    C[i] *= -1\nmod = 10**9 + 7\nans = 0\nfor i in range(N):\n    ans += C[i]*(i+2)\nans = ans*(4**(N-1))\nans = ans % mod\nprint(ans)", "N = int(input())\nC = [0] + sorted(list(map(int, input().split())))\nMOD = 10 ** 9 + 7\n\nans = 0\nfor i in range(1, N + 1):\n    l, r = i - 1, N - i\n    ans += C[i] * pow(2, l, MOD) * (pow(2, max(0, r - 1), MOD) * r % MOD + pow(2, r, MOD)) % MOD\n\nprint((ans * pow(2, N, MOD) % MOD))\n", "n=int(input())\nc=list(map(int,input().split()))\nmod=10**9+7\nc.sort(reverse=True)\nans=0\npo2=[1]\nfor i in range(n):\n    po2.append(po2[-1]*2%mod)\nfor i,j in enumerate(c,1):\n    ans+=j*((i-1)*po2[i-2]+po2[i-1])*po2[n-i]*po2[n-i]*po2[i]%mod\n    ans%=mod\nprint(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn = int(input())\na = list(map(int, input().split()))\nM = 10**9+7\n\npp = [None]*n\nv = 1\nfor i in range(n):\n    pp[i] = v\n    v *= 2\n    v %= M\n\na.sort()\na = a[::-1]\nans = 0\nans += a[0]*(pow(2, 0, M))*pow(2, n-1,M)\nfor i in range(1,n):\n    num = a[i]\n    ans += num*(pp[i] + i*pp[i-1])*pp[n-i-1]\n    ans %= M\nans *= pow(2,n,M)\nans %= M\nprint(ans)", "n = int(input())\nmod = 10 ** 9 + 7\nc = list(map(int, input().split()))\nc.sort()\n\nans = 0\nfor i in range(n):\n    if i < n - 1:\n        ans += c[i] * (n - i + 1) * pow(2, n - i - 2, mod) * pow(2, i, mod)\n        ans %= mod\n\n    else:\n        ans += c[i] * pow(2, n - i - 1, mod) * pow(2, i, mod)\n        ans %= mod\n\n\nans *= pow(2, n, mod)\nans %= mod\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom math import factorial\n\ndef comb(a,d):\n    return factorial(a)//factorial(b)//factorial(a-b)\n\nmod = 10**9+7\n\nN = int(input())\nC_input = list(map(int, input().split()))\n\nC = sorted(C_input)\nans = 0\nfor ind, s in enumerate(C):\n    ans+= C[ind] * (N+1-ind)\n    ans %= mod\nprint(int(ans* 2**(2*N-2)) %mod)", "N = int(input())\nC = sorted(map(int, input().split()))\nmod = 10**9+7\n# \u305d\u306e\u30d3\u30c3\u30c8\u304c\u7570\u306a\u308b\u78ba\u7387 * \u305d\u308c\u4ee5\u4e0a\u306e\u30d3\u30c3\u30c8\u304c\u7acb\u3063\u3066\u3044\u308b\u6570\u306e\u671f\u5f85\u5024 * c\nans = 0\nfor i, c in enumerate(C[::-1], 2):\n    ans += i * c\nans %= mod\nans = ans * pow(2, 2*N-2, mod) % mod\nprint(ans)\n", "N = int(input())\nMOD = 10**9 + 7\nC = list(map(int, input().split()))\nC.sort()\n\nans = 0\nfor i, c in enumerate(C, start=1):\n    M = N - i\n    ans += c * (M + 2)\n    ans %= MOD\nans *= pow(4, N - 1, MOD)\nprint((ans % MOD))\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    #from math import gcd\n\n    #inf = 10**17\n    mod = 10**9 + 7\n\n    n = int(input())\n    c = list(map(int, input().split()))\n    c.sort()\n    res = 0\n    b = pow(2, n, mod)\n    for i in range(n):\n        l = pow(2, i, mod)\n        if n-i-2 >= 0:\n            r = pow(2, n-i-1, mod) + (n-i-1)*pow(2, n-i-2, mod)\n        else:\n            r = pow(2, n-i-1, mod)\n        res += b*c[i]*l*r % mod\n        res %= mod\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nINF=1e9\nmod=1e9+7\nn=int(input())\nlit=list(map(int,input().split()))\nlit.sort()\nans=0\nfor i in range(n):\n    ans=(ans+lit[i]*(n-i+1)%mod)%mod\nfor i in range((n-1)):\n    ans=ans*4%mod\nans=int(ans)\nprint(ans)\n", "N = int(input())\nC = [int(c) for c in input().split()]\nC.sort()\nMOD = 10**9+7\np2 = [1]\nfor i in range(2*N+10):\n  p2 += [p2[-1]*2%MOD]\n\nans = 0\nfor i in range(N):\n  m = (p2[N-1-i]+(N-i-1)*p2[N-i-2])*C[i]\n#  print(m)\n  m = m*p2[N+i]%MOD\n  ans += m\nprint((ans%MOD))\n", "n = int(input())\nc = list(map(int, input().split()))\nmod = 10**9+7\nc.sort(reverse=True)\nans = 0\nfor k, num in enumerate(c):\n    ans += (k+2)*num\n    ans %= mod\n\nfor _ in range(2*n-2):\n    ans *= 2\n    ans %= mod\n\nprint(ans)", "n=int(input())\nlists=list(map(int,input().split()))\nlists=sorted(lists,reverse=True)\n\nmod=10**9+7\ndp=[0 for i in range(n+1)]\ndp[1]=2*lists[0]\nfor i in range(1,n):\n    x=lists[i]\n    y=pow(2,i,mod)\n  \n    dp[i+1]=4*dp[i]+(i+2)*(y**2)*lists[i]\n    dp[i+1]%=mod\n\nprint(dp[n]%mod)", "\ndef resolve():\n    MOD = 10 ** 9 + 7\n    N = int(input())\n    C = sorted(map(int, input().split()))\n    P = [1] * (N + 1)\n    for i in range(N):\n        P[i + 1] *= P[i] * 2\n        P[i + 1] %= MOD\n    ans = 0\n    for i in range(N):\n        # \u5404\u30d3\u30c3\u30c8\u306e\u4fc2\u6570: (2^r + 2^r-1 * r) * 2^l\n        l, r = i, N - i - 1\n        now = P[r]\n        if r != 0:\n            now += P[r - 1] * r\n        now *= P[l]\n        now *= C[i]\n        ans += now\n        ans %= MOD\n    ans *= P[N]\n    print(ans % MOD)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# \u30c6\u30b9\u30c8\u7528\u30b3\u30fc\u30c9\n# Ci\u306e\u5024\u3067sort\u3059\u308b\u3001T\u30920000\u3067\u56fa\u5b9a\u3057\u305f\u5f8c\u3001\u6700\u5f8c\u306b2**N\u500d\nN = ir()\nC = np.array(lr())\nMOD = 10 ** 9 + 7\nC.sort()\n# N-2\u304c\u30de\u30a4\u30ca\u30b9\u306b\u306a\u308b\u6642\u306b\u6ce8\u610f\u3001\u4e00\u756a\u53f3\u306f2**(N-1)\ntwo_power = np.array([(1+N-i) * pow(2, (N-2), MOD) % MOD if i < N-1 else pow(2, i, MOD) for i in range(N)])\nanswer = (C * two_power % MOD).sum() % MOD\nanswer *= pow(2, N, MOD)\nprint((answer%MOD))\n", "def main():\n    n=int(input())\n    c=sorted(list(map(int,input().split())))\n    mod=10**9+7\n    ans=0\n    for i,j in enumerate(c):\n        ans=(ans+j*(n-i+1))%mod\n        \n    ans=(ans*4**(n-1))%mod\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u89e3\u8aac\u653e\u9001\n\ndef pow2(n, mod):\n    \"\"\"2\u306en\u4e57\u307e\u3067\"\"\"\n    t = 1\n    yield t\n    for _ in range(n):\n        t = t * 2 % mod\n        yield t\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N = int(input())\n    *c, = list(map(int, input().split()))\n\n    c.sort()\n\n    *two, = pow2(N, MOD)\n\n    ans = 0\n    for l, x in enumerate(c):\n        # x:=\u4fc2\u6570.\u3053\u306e\u4f4d\u7f6e\u306e\u64cd\u4f5c\u306b\u304b\u304b\u308b\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b.\n        # r:=x\u306e\u53f3\u5074\u306b\u3042\u308b\u8981\u7d20\u6570\n        # (1<<r)\u500b\u306e\u72b6\u614b\u3092\u884c\u3068\u3057\u3066\u4e26\u3079\u3066,\u5217\u3067\u4e0d\u4e00\u81f4\u6570\u3092\u78ba\u8a8d\u3059\u308b\u3068,\u3069\u306e\u5217\u3082\u72b6\u614b\u306e\u534a\u5206\u304c\u4e0d\u4e00\u81f4.\u3053\u308c\u304cr\u5217\u3042\u308b.\n        r = N - l - 1\n\n        t = two[r]\n        if r != 0:\n            t += two[r - 1] * r  # \u53f3\u5074\u306e\u500b\u6570\n        t = t * two[l] % MOD\n        t = t * x % MOD\n        ans += t\n\n    ans = ans * two[N] % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod = 10**9 + 7\nn = int(input())\nc = list(map(int,input().split()))\nc.sort(reverse = True)\nans = 0\nfor i in range(n):\n    ans += c[i]*(i+2) \n    ans %= mod\nans *= pow(4,n-1,mod)\nans %= mod\nprint(ans)", "N = int(input())\nC = list(map(int, input().split()))\nMOD = 1_000_000_007\n\nB = [0 for _ in range(N+1)]#2\u3079\u304dmod\nB[0] = 1\nfor i in range(1,N+1):\n  B[i] = B[i-1] * 2\n  B[i] %= MOD  \n\nC.sort()\n\nans = 0\nfor n in range(1,N+1):\n  ans += C[n-1] * ((N-n) * B[N-n-1] + B[N-n]) * B[n-1]\n  ans %=  MOD\n  \nans *= B[N]\nans %= MOD\n\nprint(ans)\n\n\"\"\"\nD = [0 for _ in range(N)]#\u7d2f\u7a4d\u548c\nD[0] = C[0]\nfor i in range(1,N):\n  D[i] = D[i-1] + C[i]\nprint(C)\n\n  \nans = 0\nfor j in range(1,N+1):\n  ans += D[j-1] * B[j-1]  \n  print(D[j-1] * B[j-1]  \n  \n\"\"\"", "n = int(input())\nc = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nc.sort(reverse=True)\nans = 0\nfor i, e in enumerate(c):\n    ans += e * (2 + i)\n    ans %= mod\n\nans *= pow(2, 2 * n - 2, mod)\nans %= mod\n\nprint(ans)\n", "N=int(input());c=sorted(list(map(int,input().split())));m=10**9+7;print(sum([c[i]*(N-i+1)*pow(4,N-1,m) for i in range(N)])%m)", "#!/usr/bin/env python3\n\nimport sys\nsys.setrecursionlimit(300000)\n\nMOD = 1000000007  # type: int\n\ndef solve(N: int, C: \"List[int]\"):\n    pows = [1]\n    for i in range(N):\n        pows.append(pows[i] * 2 % MOD)\n\n    C.sort(reverse=True)\n    ret = 0\n    for i, v in enumerate(C):\n        if i > 0:\n            ret += (pows[i] + pows[i - 1] * i) * (pows[N - i - 1]) * v\n        else:\n            ret += pows[i] * (pows[N - i - 1]) * v\n    ret = ret * pows[N] % MOD\n    print(ret)\n    return\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    C = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, C)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(100000000)\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\nfrom heapq import  heapify,heappop,heappush\n\n\ndef main():\n    N = int(input())\n    C = list(map(int,input().split()))\n    C.sort()\n    \n    power = [1]\n    for i in range(N):\n        power.append(power[-1]*2%MOD)\n\n    ans = 0\n    for i,c in enumerate(C):\n        ans += c*(power[N - 2]*power[N]*(N - i - 1))%MOD\n        ans += c*(power[N - 1]*power[N])%MOD\n        ans %= MOD\n    print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nc = sorted(list(map(int, input().split())))\np = 10 ** 9 + 7\n\nprint(((sum([(n + 2 - i) * ci for i, ci in enumerate(c, 1)]) * pow(4, n - 1, p)) % p))\n", "n = int(input())\na = list(map(int,input().split()))\na.sort(reverse=True)\nmod = 10 ** 9 + 7\nans = 1\nfor _ in range(2*n-2):\n  ans *= 2\n  ans %= mod\ncef = [i+2 for i in range(n)]\nfor i in range(n):\n  a[i] *= cef[i]\nans *= sum(a)\nans %= mod\nprint(ans)", "N,*C = map(int, open(0).read().split())\nMOD = 10**9+7\np2 = [1]*(2*N+1)\nfor i in range(1,2*N+1):\n  p2[i] = p2[i-1]*2%MOD\nC.sort()\nans = 0\nfor i,c in enumerate(C):\n  n = N-1-i\n  ans += c*(n*p2[n-1]+p2[n])*p2[N+i]%MOD\nprint(ans%MOD)", "import sys\nINF=1e9\nmod=1e9+7\nn=int(input())\nlit=list(map(int,input().split()))\nlit.sort()\nans=0\nfor i in range(n):\n    ans=(ans+lit[i]*(n-i+1)%mod)%mod\nfor i in range(2*(n-1)):\n    ans=ans*2%mod\nans=int(ans)\nprint(ans)\n", "def main():\n    MOD = 10 ** 9 + 7\n    N = int(input())\n    C = list(map(int, input().split(' ')))\n    C.sort()\n    pow_2 = 1  # 2 ** (2 * N - 2)\n    for _ in range(2 * N - 2):\n        pow_2 *= 2\n        pow_2 %= MOD\n    ans = 0\n    for k, c in enumerate(C):\n        ans += c * ((N - k + 1) * pow_2)\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def solve():\n  ans = 0\n  N = int(input())\n  C = list(map(int, input().split()))\n  C.sort()\n  mod = 10**9+7\n  for i in range(N):\n    ans += C[i]*(N+1-i)\n  ans = ans*pow(2,2*N-2)%mod\n  return ans\nprint(solve())", "mod=10**9+7\ndef A001792(n):\n  if n>1:\n    return (n+1)*pow(2,n-2,mod)\n  else:\n    return 1\n\nnn=int(input())\nC=list(map(int, input().split()))\nC.sort(reverse=True)\nmod=10**9+7\nans=0\nfor i in range(nn):\n  ans+=pow(2,nn-i-1,mod)*A001792(i+1)*C[i]\n  ans %=mod\nans = ans*pow(2,nn,mod)\nans %=mod\nprint(ans)", "N=int(input())\nc=list(map(int,input().split()))\nc.sort()\nm=10**9+7\nans=0\nfor i in range(N):\n    ans+=(c[i]*(N-i+1)*pow(2,(N-2)%(m-1),m))%m\nprint((ans*pow(2,N,m))%m)", "def solve():\n  ans = 0\n  N = int(input())\n  C = list(map(int, input().split()))\n  C.sort()\n  mod = 10**9+7\n  for i in range(N):\n    ans += C[i]*(N+1-i)\n    ans %= mod\n  ans = ans*pow(2,2*N-2,mod)%mod\n  return ans\nprint(solve())", "#E\nn = int(input())\nc = [int(i) for i in input().split()]\nmod = 10**9+7\n\nc.sort()\nans = 0\nfor i in range(n):\n    ans += c[i]*(n-i+1)\n\nans *= 4**(n-1)\nans %= mod\nprint(ans)", "####################################### Define\nmod = int(1e9 + 7)\nmaxN = int(2e5 + 100)\npow = [1] * maxN\ncost = []\n\n####################################### Functions\ndef add(x, y) : return (x + y) % mod\ndef mul(x, y) : return x % mod * (y % mod) % mod\ndef prepare() :\n    for i in range(1, maxN):\n        pow[i] = mul(pow[i - 1], 2)\n####################################### Main\nprepare()\nn = int(input())\ninp = input().split()\nfor i in range(0, n) :\n    cost.append( int(inp[i]))\ncost.sort()\n\nans = 0\nfor i in range(1, n + 1) :\n    cur = mul(pow[i - 1], mul(int(cost[i - 1]), pow[n - i]))\n    if i < n : cur = add(cur, pow[i - 1] * pow[n - i - 1] % mod * int(cost[i - 1])\n                          % mod * (n - i) % mod)\n    ans = add(ans, cur)\nprint((mul(ans, pow[n])))\n''' test\n6\n623 77 177 26 865 192\n'''\n", "N=int(input())\nC=list(map(int,input().split()))\nmod=10**9+7\nC.sort()\nC.reverse()\nans=0\nfor i in range(N):\n  ans+=C[i]*(i+2)\n  ans%=mod\n\np=pow(4,N-1,mod)\nans=ans*p%mod\nprint(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\na = a[::-1]\nM = 10**9+7\nans = 0\nans += a[0]*(pow(2, 0, M))*pow(2, n-1,M)\nfor i in range(1,n):\n    num = a[i]\n    ans += num*(pow(2, i, M) + i*pow(2,i-1,M))*pow(2,n-i-1,M)\n    ans %= M\nans *= pow(2,n,M)\nans %= M\nprint(ans)", "MOD = 1000000007\n\nN = int(input())\nC = list(map(int,input().split()))\n\nC.sort(reverse=True)\n\nans = 0\n\nfor i in range(N):\n    ans += C[i]*(2+i)*pow(4,N-1,MOD)\n    ans %= MOD\n\nprint(ans)", "mod = 10 ** 9 + 7\n\nN = int(input())\nC = list(map(int, input().split()))\nC.sort(reverse=True)\n\nif N == 1:\n    print(2 * C[0] % mod)\n    return\n\nans = 0\ncoef = pow(2, N-1, mod)\nfor c in C:\n    ans += c * coef\n    ans %= mod\n    coef = (coef + pow(2, N - 2, mod)) % mod\n\nans *= pow(2, N, mod)\nans %= mod\nprint(ans)", "import numpy as np\n\nn = int(input())\nc = np.array(input().split(),dtype=int)\nmod = 10**9+7\n\nc = sorted(c)[::-1]\n#4^(n-1)\u3092\u6c42\u3081\u308b\ne4 = 1\nk = n-1\ninst = 4\nwhile k > 0:\n    if k%2 == 1:\n        e4 = (e4*inst)%mod\n    k = k//2\n    inst = (inst**2)%mod\n\nans = 0\nfor i in range(n):\n    ans = (ans+c[i]*(i+2))%mod\nans = (ans*e4)%mod\n\nprint(ans)\n", "mod=10**9+7\nn=int(input())\narr=list(map(int,input().split()))\narr=sorted(arr)\nans=0\ntotal=pow(2,2*n-2,mod)\nfor i in range(n):\n  ans+=total*(n-i+1)*arr[i]\n  ans%=mod\nprint((int(ans)))\n", "N = int(input())\nC = list(map(int,input().split()))\nC.sort(reverse=True)\nMOD = 10**9+7\nif N==1:\n    print((C[0]*2)%MOD)\n    return\n\nans = 0\nd = pow(2,N-2,MOD)\nbase = pow(2,N-1,MOD)\nfor i,c in enumerate(C):\n    ans += c * (base + i*d)\nans *= pow(2,N,MOD)\nans %= MOD\nprint(ans)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Ci\u306e\u5024\u3067sort\u3059\u308b\u3001T\u30920000\u3067\u56fa\u5b9a\u3057\u305f\u5f8c\u3001\u6700\u5f8c\u306b2**N\u500d\nN = ir()\nC = np.array(lr())\nMOD = 10 ** 9 + 7\nC.sort()\ntwo_power = np.array([(1+N-i) * pow(2, (N-2), MOD) % MOD if i < N-1 else pow(2, i, MOD) for i in range(N)])\nanswer = (C * two_power % MOD).sum() * 2**N\nprint((answer%MOD))\n", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Ci\u306e\u5024\u3067sort\u3059\u308b\u3001T\u30920000\u3067\u56fa\u5b9a\u3057\u305f\u5f8c\u3001\u6700\u5f8c\u306b2**N\u500d\nN = ir()\nC = np.array(lr())\nMOD = 10 ** 9 + 7\nC.sort()\n# N-2\u304c\u30de\u30a4\u30ca\u30b9\u306b\u306a\u308b\u6642\u306b\u6ce8\u610f\u3001\u4e00\u756a\u53f3\u306f2**(N-1)\ntwo_power = np.array([(1+N-i) * pow(2, (N-2), MOD) % MOD if i < N-1 else pow(2, i, MOD) for i in range(N)])\nanswer = (C * two_power % MOD).sum() * 2**N\nprint((answer%MOD))\n", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# Ci\u306e\u5024\u3067sort\u3059\u308b\u3001T\u30920000\u3067\u56fa\u5b9a\u3057\u305f\u5f8c\u3001\u6700\u5f8c\u306b2**N\u500d\nN = ir()\nC = np.array(lr())\nMOD = 10 ** 9 + 7\nC.sort()\n# N-2\u304c\u30de\u30a4\u30ca\u30b9\u306b\u306a\u308b\u6642\u306b\u6ce8\u610f\u3001\u4e00\u756a\u53f3\u306f2**(N-1)\ntwo_power = np.array([(1+N-i) * pow(2, (N-2), MOD) % MOD if i < N-1 else pow(2, i, MOD) for i in range(N)])\nanswer = (C * two_power % MOD).sum() % MOD * pow(2, N, MOD)\nprint((answer%MOD))\n", "N=int(input());c=sorted(list(map(int,input().split())));m=10**9+7;print(sum([c[i]*(N-i+1)*pow(2,2*N-2,m) for i in range(N)])%m)", "# inverse x^(-1)\ndef inv(x):\n    nonlocal mod\n    return pow(x,mod-2,mod)\n\nmod=10**9+7\nN = int(input())\nC = [0]\nC.extend(sorted(list(map(int,input().split())), reverse=True)) # 1-indexed, \u964d\u9806\n\n# print(C)\n# C[i]\u304c\u6700\u5f8c\u304b\u3089j\u756a\u76ee\u306b\u64cd\u4f5c\u3055\u308c\u308b\uff08\u30b3\u30b9\u30c8\u304c C[i]*j \u639b\u304b\u308b\uff09\u306e\u306f\uff0cc[1]~C[i-1]\u306bj-1\u500b\u64cd\u4f5c\u3059\u3079\u304d\u3082\u306e\uff0c\u3059\u306a\u308f\u3061\uff0cC[i]\u4ee5\u4e0a\u306e\u3082\u306e\u304c\u3042\u308b\u3068\u304d\u3002\n# C[i+1]~C[N]\u306e\u9078\u3073\u65b9\u306f\u81ea\u7531\u3002\n# \u21d2 combi(i-1, j-1)*2**(N-i) \u3092\u639b\u3051\u308b\u3002\n# \u7dcf\u548c\u3092\u8a08\u7b97\u3059\u308b\u3068\uff0c\u7d50\u5c40\uff0c2**N * \u03a3[i=1->N](2**(N-i)*Ci*(2**(i-2)*(i-1) + 2**(i-1))) \u306b\u306a\u308b\n\npow2 = [1]\nfor k in range(1, N+1):    \n    pow2.append(pow2[-1] * 2 % mod)\n\n# print(pow2)\n\nans=0\nfor i in range(1, N+1):\n    temp = pow2[N - i] * C[i] * ((0 if i == 1 else (pow2[i - 2] * (i - 1))) + pow2[i - 1]) % mod\n    ans = (ans + temp) % mod\n\nans = ans * pow2[N] % mod\n\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nINF = float(\"inf\")\n\nMOD = 1000000007  # type: int\n\n\nclass Combination(object):\n\n    def __init__(self, N, mod=MOD):\n        fac, finv, inv = [0]*(N+1), [0]*(N+1), [0]*(N+1)\n        fac[:2] = 1, 1\n        finv[:2] = 1, 1\n        inv[1] = 1\n        for i in range(2, N+1):\n            fac[i] = fac[i-1]*i % mod\n            inv[i] = -inv[mod % i]*(mod//i) % mod\n            finv[i] = finv[i-1]*inv[i] % mod\n        self.N = N\n        self.MOD = mod\n        self.fac = fac\n        self.finv = finv\n        self.inv = inv\n\n    def __call__(self, n, k):\n        if n < k:\n            return 0\n        if n < 0 or k < 0:\n            return 0\n        fac = self.fac\n        finv = self.finv\n        mod = self.MOD\n        return fac[n] * (finv[k]*finv[n-k] % mod) % mod\n\n\ndef solve(N: int, C: \"List[int]\"):\n\n    ans = 0\n    C.sort(reverse=True)\n    for i, c in enumerate(C, start=1):\n        b = c*(pow(2, 2*N-2, MOD)*(i+1)) % MOD\n        ans += b\n        ans %= MOD\n    print((ans % MOD))\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    C = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, C)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nc = list(map(int, input().split()))\nc.sort()\nMOD = 1000000007\nans = 0\nP = pow(4, n-1, MOD)\nif n == 1:\n  ans = c[0]*2 % MOD\nelse:\n  for i in range(n):\n    ans += P*c[i]*(n+1-i)\n    ans %= MOD\n \nprint(ans)", "N = int(input())\nC = sorted(list(map(int,input().split())))[::-1]\nans = 0\nMOD = 10**9 + 7\nfor k in range(N):\n    ans += pow(2,2*N-2,MOD)*(k+2)*C[k]\nprint((ans%MOD))\n", "N = int(input())\n*C, = list(map(int, input().split()))\nC.sort(reverse=True)\np = 10**9+7\nS = 0\nfor i in range(N):\n    S = (S+(i+2)*C[i]) % p\nS = (S*pow(4, N-1, p)) % p\nprint(S)\n", "n = int(input())\nl = sorted(list(map(int,input().split())),reverse=True)\nmod = 10**9+7\n\nans = 0\n\nfor i in range(n-1,-1,-1):\n    ans += ((2+i)*l[i])\nb = pow(2,2*n-2,mod)\nprint(ans*b%mod)", "MOD = 10 ** 9 + 7\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\n\nif N == 1:\n    print (2 * C[0] % MOD)\n    return\n\nANS = 0\nfor i, c in enumerate(C):\n    ANS += c * (N + 1 - i)\n\nANS *= pow(2, N - 2, MOD)\nANS %= MOD\nANS *= pow(2, N, MOD)\nprint (ANS % MOD)", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    c = list(map(int, input().split()))\n    mod = pow(10, 9) + 7\n    \n    c.sort(reverse=True)\n    \n    ans = 0\n    \n    for i in range(n):\n        ans += (i+2) * c[i]\n        ans %= mod\n    \n    ans *= pow(2, n*2-2, mod)\n    ans %= mod\n    \n    print(ans)\n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "MOD = 10**9+7\nn = int(input())\nS = [1]*n\nD = [1]*(n+1)\nfor i in range(n):\n  D[i+1] = D[i]*2 % MOD\nfor i in range(n-1):\n  S[i+1] = (S[i]*2 + D[i+1]) % MOD\nT = S[::-1]\nC = sorted(list(map(int, input().split())))\nans = 0\nfor i in range(n):\n  ans += C[i]*((D[n-(i+1)]+T[i])*D[i]) % MOD\n  ans %= MOD\nans = ans*D[n-1]%MOD\nprint(ans)", "N = int(input())\nmod = int(1e9) + 7\nC = list(map(int, input().split()))\nC.sort(reverse=True)\ndef doubling(n, m):\n  y = 1\n  base = n\n  while m != 0:\n    if m % 2 == 1:\n      y *= base\n      y %= mod\n    base *= base\n    base %= mod\n    m //= 2\n  return y\nb = 1\nif N == 1:\n  L, R = 0, 1\nelse:\n  b = doubling(2, N-2)\n  L, R = b, (2 * b) % mod\nS1 = 0\nS2 = 0\nfor i in range(N):\n  S1 += (i * C[i]) % mod\n  S1 %= mod\n  S2 += C[i]\n  S2 %= mod\nprint((doubling(2, N) * (S1 * L + S2 * R)) % mod)", "MOD = 10 ** 9 + 7\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\n\nif N == 1:\n    print (2 * C[0] % MOD)\n    return\n\n\nlst = [0] * (N + 3)\nlst[0] = 1\nfor i in range(1, N + 3):\n    lst[i] = (lst[i - 1] * 2) % MOD\n\n\nANS = 0\nfor i, c in enumerate(C):\n    ANS += c * (N + 1 - i)\n\nANS *= lst[N - 2]\nANS %= MOD\nANS *= lst[N] \nprint (ANS % MOD)", "from sys import stdin\nf_i = stdin\n\nmod = 10 ** 9 + 7\n\nN = int(f_i.readline())\n\nC = map(int, f_i.readline().split())\nC = sorted(C)\n\nx = (C_i * i % mod for i, C_i in zip(range(N + 1, 1, -1), C))\n\nans = pow(4, N - 1, mod) * sum(x) % mod\n\nprint(ans)", "MOD=10**9+7\nN=int(input())\nclist=list(map(int,input().split()))\nclist.sort()\n\ndef powmod(a,p):\n  if p==0:\n    return 1\n  elif p==1:\n    return a\n  else:\n    pow2=powmod(a,p//2)\n    if p%2==0:\n      return (pow2**2)%MOD\n    else:\n      return (a*pow2**2)%MOD\n\nbase=powmod(2,2*N-2)\ncoef=0\nfor i in range(N):\n  coef+=clist[i]*(N+1-i)\n  coef%=MOD\n\nprint(base*coef%MOD)", "N = int(input())\nC = list(map(int, input().split()))\nC = reversed(sorted(C))\n\nMOD = 10 ** 9 + 7\npow = 4 ** (N - 1) % MOD\n\nans = 0\nfor i, c in zip(range(N), C):\n    ans += (i + 2) * c % MOD\n    ans %= MOD\n\nprint(ans * pow % MOD)", "n = int(input())\na = list(map(int, input().split()))\na = sorted(a, reverse=True)\ncost = 0\nfor i in range(1, n+1):\n  cost = (cost + a[i-1]*(i+1)) % 1000000007\nfor i in range(1, n):\n  cost = cost * 4 % 1000000007\nprint(cost)", "MOD = 10**9 + 7\n\ndef main():\n    n = int(input())\n    c = list(map(int, input().split()))\n    c.sort()\n    ans = 0\n    for i in range(n):\n        tmp = pow(2, i, MOD)\n        if i < n-1:\n            tmp *= pow(2, n-i-1, MOD) + pow(2, n-i-2, MOD) * (n-i-1)\n        else:\n            tmp *= pow(2, n-i-1, MOD)\n        tmp %= MOD\n        ans += c[i] * tmp\n    print(ans * pow(2, n, MOD) % MOD)\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    N = int(input())\n    C = list(map(int, input().split()))\n    C.sort()\n    mod = 10 ** 9 + 7\n    r = 0\n    n = N\n    i = 0\n    for c in C:\n        if n == 1:\n            r = (r + c * pow(2, N - 1, mod)) % mod\n        else:\n            r = (r + c * (n + 1)* pow(2, n - 2, mod) * pow(2, N - n, mod)) % mod\n        n -= 1\n    return 2**N * r % mod\n\nprint((main()))\n", "MOD = 1000000007\n\nN = int(input())\nC = list(map(int,input().split()))\n\nC.sort(reverse=True)\n\nans = 0\n\nif N > 1:\n    for i in range(N):\n        ans += C[i]*(2+i)*pow(2,N-2,MOD)*pow(2,N,MOD)\n        ans %= MOD\nelse:\n    ans = 2*C[0]%MOD\n\nprint(ans)", "# coding: utf-8\n\nimport itertools\nimport sys\n\nN = int(input())\nC = [int(x) for x in input().split()]\n\n# C\u3092\u6607\u9806\u306b\u30bd\u30fc\u30c8\u3057\u3066\u304a\u304f\nC.sort()\n\n# \uff08C_i\u306e\u500b\u6570\u00d7C_i\u306e\u30b3\u30b9\u30c8\uff09\u306e\u7dcf\u548c\u00d72**N\u3092\u6c42\u3081\u308b\nsum = 0\nfor i in range(N):\n\tsum += (N + 1 - i) * C[i]\nsum *= 2 ** (N - 2)\nsum *= 2 ** N\n\n# 10**9 + 7\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u3066\u51fa\u529b\nprint(int(sum % (10 ** 9 + 7)))", "N=int(input());c=sorted(map(int,input().split()));m=10**9+7;print(sum([c[i]*(N-i+1)*pow(4,N-1,m) for i in range(N)])%m)", "# \u89e3\u8aac\u653e\u9001\n\ndef pow2(n, mod):\n    \"\"\"2\u306en\u4e57\u307e\u3067\"\"\"\n    t = 1\n    yield t\n    for _ in range(n):\n        t = t * 2 % mod\n        yield t\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n\n    N = int(input())\n    *c, = list(map(int, input().split()))\n\n    c.sort()\n\n    *two, = pow2(N, MOD)\n\n    ans = 0\n    for l, x in enumerate(c):\n        # x:=\u4fc2\u6570.\u3053\u306e\u4f4d\u7f6e\u306e\u64cd\u4f5c\u306b\u304b\u304b\u308b\u30b3\u30b9\u30c8\u306e\u7dcf\u548c\u3092\u6c42\u3081\u308b.\n        # r:=x\u306e\u53f3\u5074\u306b\u3042\u308b\u8981\u7d20\u6570\n        # (1<<r)\u500b\u306e\u72b6\u614b\u3092\u884c\u3068\u3057\u3066\u4e26\u3079\u3066,\u5217\u3067\u4e0d\u4e00\u81f4\u6570\u3092\u78ba\u8a8d\u3059\u308b\u3068,\u3069\u306e\u5217\u3082\u72b6\u614b\u306e\u534a\u5206\u304c\u4e0d\u4e00\u81f4.\u3053\u308c\u304cr\u5217\u3042\u308b.\n        r = N - l - 1\n\n        t = two[r]\n        if r != 0:\n            t = (t + two[r - 1] * r) % MOD  # \u53f3\u5074\u306e\u500b\u6570\n        t = t * two[l] % MOD\n        t = t * x % MOD\n        ans = (ans + t) % MOD  # MOD\u5fd8\u308c\n\n    ans = ans * two[N] % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "mod=10**9+7\nn=int(input())\narr=list(map(int,input().split()))\narr=sorted(arr)\nans=0\nif n==1:\n  print((2*arr[0])%mod)\nelse:\n  table=[1]\n  for _ in range(n):\n    tmp=table[-1]*2\n    tmp%=mod\n    table.append(tmp)\n  for i in range(n):\n    if i==n-1:    \n      ans+=(table[i-1]*(n-i+1)*arr[i])%mod\n    else:\n      ans+=(table[i]*(n-i+1)*table[n-i-2]*arr[i])%mod\n  print((ans*table[n])%mod)", "import sys\nimport math\nimport fractions\nimport bisect\nimport queue\nimport heapq\nfrom collections import deque\nsys.setrecursionlimit(4100000)\n\nMOD = int(1e9+7)\nPI = 3.14159265358979323846264338327950288\nINF = 1e18\n\n'''\n1\u884c\u306eint\nN, K = map(int, input().split())\n\n1\u884c\u306estring\nS, T = input().split()\n\n1\u884c\u306e\u6574\u6570\u914d\u5217\nP = list(map(int,input().split()))\n\n\u6539\u884c\u3042\u308a\nx = []\ny = []\nfor i in range(N):\n    x1,y1=[int(i) for i in input().split()]\n    x.append(x1)\n    y.append(y1)\n\nN\u884cM\u5217\u306e\u521d\u671f\u5316\ndp = [[INF] * M for i in range(N)]\n\n'''\n\n\nN = int(input())\nC = list(map(int,input().split()))\n\n# \u30b3\u30b9\u30c8\u306e\u5c0f\u3055\u3044\u3082\u306e\u304b\u3089\u66f4\u65b0\u3057\u3066\u3044\u3051\u3070\u3044\u3044\nC.sort()\n\n# 2\u306e\u3079\u304d\u4e57\u306f\u5148\u306b\u8a08\u7b97\u3057\u3066\u304a\u304f\nbeki = [1]\nfor i in range(1, 3*N+20):\n    beki.append((beki[i-1]*2)%MOD)\n\n\nans = 0\nfor i in range(N):\n    ans += (C[i] * beki[2*N-2] * (N-i+1))%MOD\n    \n\nprint((ans % MOD))\n", "MOD = 10**9+7\n\ndef solve(C):\n    N = len(C)\n    C.sort()\n\n    dp1 = 0\n    dp2 = 0\n    for k,c in enumerate(C):\n        ndp2 = 2*pow(4,k,MOD)*c + 4*dp2\n        dp1 = 4*dp1 + ndp2 - 2*dp2\n        dp2 = ndp2\n        dp1 %= MOD\n        dp2 %= MOD\n\n    return dp1\n\ndef naive(C):\n    from itertools import product\n    N = len(C)\n    C.sort()\n    s = 0\n    for a in product(range(2),repeat=N):\n        for b in product(range(2),repeat=N):\n            pop = 1\n            for x,y,c in zip(a,b,reversed(C)):\n                if x != y:\n                    s += c*pop\n                    pop += 1\n    return s\n\ndef __starting_point():\n    N = int(input())\n    C = list(map(int,input().split()))\n    print(solve(C))\n__starting_point()", "ans = 0\nP = 10**9+7\nn = int(input())\nc = list(map(int, input().split()))\nc = sorted(c)\n\nfor i in range(n):\n    alr = pow(4, i, P)\n    use_bit = n - 1 - i\n    flip = pow(2, use_bit, P)\n    ret = 1\n    if use_bit > 0:\n        ret = (pow(2, use_bit, P) + use_bit*pow(2, use_bit-1, P))%P\n    ans = (ans + alr*flip*ret*c[i])%P\n\nprint(((ans*2)%P))\n", "#E\nn = int(input())\nc = [int(i) for i in input().split()]\nmod = 10**9+7\n\nc.sort()\nans = 0\nfor i in range(n):\n    ans += c[i]*(n-i+1)\n\nans %= mod\nans *= 4**(n-1)\nans %= mod\nprint(ans)", "N=int(input())\nc=sorted([int(i) for i in input().split()])\nmod=10**9+7\nans=0\nfor i in range(N):\n    ans+=(c[i]*(((N-i+1)*pow(2,(N-2)%(mod-1),mod))%mod))%mod\n    ans%=mod\nprint((ans*pow(2,N,mod))%mod)", "\nn = int(input())\ncl = list(map(int, input().split()))\ncl.sort(reverse=True)\nMOD = 10**9+7\n\nans = 0\nnum = pow(2,n-1,MOD)\ninc = pow(2,n-2,MOD)\nfor i in range(n):\n    ans += num*cl[i]\n    ans%=MOD\n    num += inc\n    num%=MOD\n\nans *= pow(2,n,MOD)\nans%=MOD\nprint(ans)", "#!python3\n\nLI = lambda: list(map(int, input().split()))\n\n# input\nN = int(input())\nC = LI()\n\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    ans = 0\n    C.sort()\n    for i in range(N):\n        x = C[i] * (N - i + 1) % MOD\n        ans = (ans + x) % MOD\n    ans = ans * pow(4, N - 1, MOD) % MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nimport sys\nimport numpy as np\nimport collections\nfrom functools import cmp_to_key\nimport heapq\nsys.setrecursionlimit(100000)\n\n##  input functions for me\ndef rsa(sep = ''):\n    if sep == '' :\n        return input().split() \n    else: return input().split(sep)\ndef rip(sep = ''):\n    if sep == '' :\n        return list(map(int, input().split())) \n    else: return list(map(int, input().split(sep)))\ndef ria(sep = ''): \n    return list(rip(sep))\ndef ri(): return int(input())\ndef rd(): return float(input())\ndef rs(): return input()\n##\nclass mint:\n    mod = int(1e9 + 7)\n    def __init__(self, v = 0):\n        if not ((v >= 0) and (v < mint.mod)):\n            v %= mint.mod\n            if v < 0: v += mint.mod\n        self.V = v\n    def __add__(self, other):\n        v = self.V + (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __sub__(self, other):\n        v = self.V - (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __mul__(self, other):\n        v = self.V * (other.V if isinstance(other, mint) else other)\n        return mint(v)\n    def __floordiv__(self, other):\n        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))\n        return mint(v)\n    def __truediv__(self, other):\n        v = self.V * mint.inv((other.V if isinstance(other, mint) else other))\n        return mint(v)\n    \n    def __eq__(self, other):\n        return self.V == (other.V if isinstance(other, mint) else mint(other).V)\n    def __ne__(self, other):\n        return self.V != (other.V if isinstance(other, mint) else other)\n    def __int__(self): return self.V\n    # right operand\n    def __radd__(self, other):\n        v = (other.V if isinstance(other, mint) else other) + self.V\n        return mint(v)\n    def __rsub__(self, other):\n        v = (other.V if isinstance(other, mint) else other) - self.V\n        return mint(v)\n    def __rmul__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * self.V\n        return mint(v)\n    def __rfloordiv__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)\n        return mint(v)\n    def __rtruediv__(self, other):\n        v = (other.V if isinstance(other, mint) else other) * mint.inv(self.V)\n        return mint(v)\n\n    @staticmethod\n    def inv(x):\n        a, _, _ = mint.extGCD(x, mint.mod)\n        return (a + mint.mod) % mint.mod\n    @staticmethod\n    def extGCD(x, y):\n        r0 = x\n        r1 = y\n        a0 = 1\n        a1 = 0\n        b0 = 0\n        b1 = 1\n        while(r1 > 0):\n            q1 = r0 // r1\n            r2 = r0 % r1\n            a2 = a0 - q1 * a1\n            b2 = b0 - q1 * b1\n            r0 = r1; r1 = r2\n            a0 = a1; a1 = a2\n            b0 = b1; b1 = b2\n        c = r0\n        a = a0\n        b = b0       \n        return a, b, c\n    @staticmethod\n    def pow(x, k):\n        x = x.V if isinstance(x, mint) else x\n        return pow(x, k, mint.mod)\n\n    \n    def __str__(self):\n        return str(self.V)\n    def __repr__(self):\n        return str(self.V)\n\ndef main():\n    N = ri()\n    A = ria()\n    A = sorted(A)\n    A = list(reversed(A))\n    Pow2 = [mint(0)] * (N + 1)\n    Pow2[0] = mint(1)\n    for i in range(1,N+1): Pow2[i] = Pow2[i-1] * 2\n\n    tot = mint(0)\n    for i in range(N):\n        tot += mint(A[i]) * Pow2[N-1]\n        if i > 0: tot += mint(A[i]) * i * Pow2[N-2]\n    tot *= Pow2[N]\n    print(tot)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nc = sorted(list(map(int, input().split())),reverse=True)\nmod = 10**9 + 7\nans = 0\ntwo = [1]\nfor i in range(n*2):\n  two += [(two[i]*2) % mod]\n\nfor i in range(n):\n  ans += (i+2) * c[i]\n  ans %= mod\nans *= two[2*n - 2]\nprint(ans%mod)", "n = int(input())\nc = [int(i) for i in input().split()]\nf = 0\nc.sort()\nc.reverse()\nfor i in range(n):\n    f = f + c[i]*(i+2)\nprint(f*(4**(n-1))%(10**9+7))", "N = int(input())\nC = sorted(list(map(int,input().split())),reverse=True)\nL = 10**9 + 7\n\n\nif N > 1:\n    b = 2**(N-2) % (L)\n    a = [C[i] * b * (2+i) % L for i in range(N)]\n    print(sum(a)*b*2*2%L)\nelse:\n    print(C[0]*2%L)", "def power(n, r, mod=10**9+7):\n    if r == 0: return 1\n    if r%2 == 0:\n        return power(n*n % mod, r//2, mod) % mod\n    if r%2 == 1:\n        return n * power(n, r-1, mod) % mod\n\n\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\nMOD = 10**9 + 7\n\nans = 0\nfor i, c in enumerate(C, 1):\n  ans = (ans + (N-i+2) * c) % MOD\n\nans *= power(4, N-1)\nans %= MOD\nprint(ans)", "MOD = 10 ** 9 + 7\nN = int(input())\nC = list(map(int, input().split()))\nC.sort()\n\nif N == 1:\n    print (2 * C[0] % MOD)\n    return\n\n\nlst = [0] * (N + 3)\nlst[0] = 1\nfor i in range(1, N + 3):\n    lst[i] = (lst[i - 1] * 2) % MOD\n\n\nANS = 0\nfor i, c in enumerate(C):\n    ANS += c * (N + 1 - i)\n\nANS *= pow(2, N - 2, MOD)\nANS %= MOD\nANS *= pow(2, N, MOD)\nprint (ANS % MOD)", "MOD = 10 ** 9 + 7\nN = int(input())\nC = list(sorted(map(int, input().split()), reverse=True))\n\nans = 0\npow_list = [1] * (N + 1)\nfor i in range(1, N + 1):\n    pow_list[i] = (2 * pow_list[i - 1]) % MOD\nbase = pow_list[N]\n\n# \u57fa\u672c\u6226\u7565:\u30b3\u30b9\u30c8\u304c\u4e00\u756a\u9ad8\u3044\u3082\u306e\u3092\u4e00\u756a\u6700\u5f8c\u306b\u5909\u66f4\u3059\u308b\nfor i, c in enumerate(C):\n    now = pow_list[N - i - 1]\n    tot = 0\n    # \u30b3\u30b9\u30c8\u304ci\u756a\u76ee\u306b\u5927\u304d\u3044\u5024\u306f\u3001\u6700\u5f8c\u304b\u3089i\u756a\u76ee\u306b\u5909\u66f4\u3092\u884c\u3046\u306e\u3067\n    # \u5de6\u304b\u3089i-bit\u307e\u3067\u306b\u4f55\u500b1\u304c\u7acb\u3063\u305f\u304b\u3067\u52a0\u7b97\u56de\u6570\u304c\u6c7a\u307e\u308b\n    if i >= 1:\n        tot = pow_list[i] + i * pow_list[i - 1]\n    else:\n        tot = pow_list[i]\n    ans += (tot * now * c) % MOD\n    ans %= MOD\nprint(ans * base % MOD)", "import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# \u30c6\u30b9\u30c8\u7528\u30b3\u30fc\u30c9\n# Ci\u306e\u5024\u3067sort\u3059\u308b\u3001T\u30920000\u3067\u56fa\u5b9a\u3057\u305f\u5f8c\u3001\u6700\u5f8c\u306b2**N\u500d\nN = ir()\nC = np.array(lr())\nMOD = 10 ** 9 + 7\nC.sort()\n# N-2\u304c\u30de\u30a4\u30ca\u30b9\u306b\u306a\u308b\u6642\u306b\u6ce8\u610f\u3001\u4e00\u756a\u53f3\u306f2**(N-1)\ntwo_power = np.array([(1+N-i) * pow(2, (N-2), MOD) % MOD if i < N-1 else pow(2, i, MOD) for i in range(N)])\nanswer = (C * two_power % MOD).sum() % MOD * pow(2, N, MOD)\nprint((answer%MOD))\n", "import numpy as np\nMOD = 10**9 + 7\n\ndef plu(a,b):\n    return (a + b)%MOD\n\nplus = np.frompyfunc(plu,2,1)\n\nn = int(input())\nc = np.sort(np.array(input().split(),dtype = np.int64))\np = pow(2,2*n-2,MOD)\nprint((plus.reduce(np.mod(np.mod(p*c,MOD)*(n-np.arange(n)+1),MOD))))\n\n", "N=int(input());c=sorted(list(map(int,input().split())));m=10**9+7;ans=0\nfor i in range(N):ans+=c[i]*(N-i+1)*pow(2,2*N-2,m)\nprint(ans%m)", "import sys\nimport itertools\nimport fractions\nstdin = sys.stdin\n\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n\nN=int(input())\nC=nl()\nmod=10**9+7\nn=0\nC.sort()\ntwo=[0]*(N+1)\ntwo[0]=1\nfor i in range(N):\n    two[i+1]=(two[i]*2)%mod\nans=0\nfor i in range(N):\n    l=i\n    r=N-1-i\n    now=two[r]\n    if(r!=0):\n        now+=two[r-1]*r\n    now*=two[i]\n    now*=C[i]\n    ans+=now\n    ans%=mod\n\nans*=two[N]\nprint((ans%mod))\n    \n", "mod = 10**9 + 7\nn = int(input())\nc = list(map(int, input().split()))\nc.sort(reverse=True)\n\nb = pow(2, 2*n-2, mod)\na = 2 * b % mod\n\nans = 0\nfor i in range(n):\n    ans += c[i] * (a + i * b)\n    ans %= mod\n\nprint(ans)", "n=int(input())\nc=sorted(list(map(int,input().split())),reverse=True)\nans=0\nmod=10**9+7\nfor i in range(1,n+1):\n  ans+=c[i-1]*(i+1)%mod\nprint(4**(n-1)*ans%mod)"]
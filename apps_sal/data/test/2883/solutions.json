["# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n       new_intervals = []\n       for interval in sorted(intervals, key=lambda i: i.start):\n         if new_intervals and interval.start <= new_intervals[-1].end:\n           new_intervals[-1].end = max(new_intervals[-1].end, interval.end)\n         else:\n           new_intervals.append(interval)\n       return new_intervals\n", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         if len(intervals) < 2:\n             return intervals\n         intervals = sorted(intervals, key=lambda s: s.start)\n         rs = []\n         cur = intervals[0]\n         for r in intervals[1:]:\n             if r.start <= cur.end:\n                 cur.end = max(r.end, cur.end)\n             else:\n                 rs.append(cur)\n                 cur = r\n         rs.append(cur)\n         return rs\n         ", "class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         inters = sorted(intervals, key=lambda intval: intval.start)\n         ret = []\n         n = len(intervals)\n         if n == 0:\n             return ret\n         s = inters[0].start\n         e = inters[0].end\n         for i in range(1, n):\n             if inters[i].start <= e:\n                 e = max(inters[i].end, e)\n             else:\n                 ret.append(Interval(s, e))\n                 s = inters[i].start\n                 e = inters[i].end\n         ret.append(Interval(s,e))\n         return ret", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         start = sorted([interval.start for interval in intervals])\n         end = sorted([interval.end for interval in intervals])\n         if not start:\n             return end\n         if not end:\n             return start\n         result = list()\n         make_interval = 1\n         i, j = 1, 0\n         first_start = 0\n         while i < len(start) and j < len(end):\n             if start[i] <= end [j]:\n                 make_interval += 1\n                 i += 1\n             else:\n                 make_interval -= 1\n                 if make_interval == 0:\n                     result.append([start[first_start], end[j]])\n                     first_start = i\n                 j += 1\n                     \n         if j < len(end) :\n             result.append([start[first_start], end[-1]])\n         return result\n                 ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         length=len(intervals)\n         if length==1 or length==0: return intervals\n         intervals.sort(key=lambda l:l.start)\n         result=[]\n         curr=intervals.pop(0)\n         while intervals:\n             next_int=intervals.pop(0)\n             if curr.end>=next_int.start:\n                 curr.end=max(next_int.end,curr.end)\n             else:\n                 result.append(curr)\n                 curr=next_int\n         result.append(curr)\n         return result\n     ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         length=len(intervals)\n         if length==1 or length==0: return intervals\n         intervals.sort(key=lambda l:l.start)\n         result=[]\n         curr=intervals.pop(0)\n         while intervals:\n             next_int=intervals.pop(0)\n             if curr.end>=next_int.start:\n                 if curr.end<next_int.end:\n                     curr.end=next_int.end\n             else:\n                 result.append(curr)\n                 curr=next_int\n         result.append(curr)\n         return result\n     ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         if not intervals: return []\n         intervals = sorted(intervals, key=lambda x: (x.start, x.end))\n         res = [Interval(intervals[0].start, intervals[0].end), ]\n         for i in range(1, len(intervals)):\n             if intervals[i].start <= res[len(res) - 1].end:\n                 res[len(res) - 1].start = min(res[len(res) - 1].start, intervals[i].start)\n                 res[len(res) - 1].end = max(res[len(res) - 1].end, intervals[i].end)\n             else:\n                 res.append(Interval(intervals[i].start, intervals[i].end))\n         return res", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         if not intervals:\n             return []\n         intervals.sort(key=lambda a: (a.start, a.end))\n         ptr = 0\n         while ptr < len(intervals) - 1:\n             if intervals[ptr].end >= intervals[ptr+1].start:\n                 p = intervals.pop(ptr + 1)\n                 intervals[ptr].end = max(intervals[ptr].end, p.end)\n             else:\n                 ptr += 1\n         \n         return intervals", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         si = sorted(intervals, key=lambda x: (x.start, x.end))\n         cur = 1  # index of current tuple\n         while cur < len(si):\n             # check intersection of current and previous tuple\n             # if end of previous is less than begin of current\n             # there are the intersection, we should merge them\n             # into the bigger interval\n             if si[cur - 1].end >= si[cur].start:\n                 # change end of the interval(tuple)\n                 si[cur - 1] = Interval(si[cur - 1].start, max(si[cur - 1].end, si[cur].end))\n                 # delete unnecessary interval(tuple)\n                 del si[cur]\n             # there are no intersection, go to the next tuple\n             else:\n                 cur += 1\n         return si\n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         '''\n         \u5148\u6309\u7167\u6bcf\u4e2a\u4f1a\u8bae\u7684\u5f00\u59cb\u65f6\u95f4\u6392\u5e8f\uff0c\u7528\u4e00\u4e2a\u6570\u5217\u6765\u4fdd\u5b58\u4f1a\u8bae\uff0c\u6761\u4ef6\u662f\n         \u5982\u679c\u5f53\u524d\u4f1a\u8bae\u7684\u5f00\u59cb\u65f6\u95f4\u6bd4\u6570\u5217\u4e2d\u6700\u540e\u4e00\u4e2a\u4f1a\u8bae\u7684\u7ed3\u675f\u65f6\u95f4\u8fd8\u665a\uff0c\u53e6\u8d77\u7089\u7076\u3002\n         \u5982\u679c\u5f00\u59cb\u65f6\u95f4\u6bd4\u7ed3\u675f\u65f6\u95f4\u8fd8\u65e9\uff0c\u6324\u8fdb\u53bb\uff01\u6bd4\u8f83\u4f1a\u8bae\u7684\u7ed3\u675f\u65f6\u95f4\uff0c\u66f4\u65b0\u3002\n         '''\n         intervals.sort(key=lambda x : x.start)\n         res = []\n         for interval in intervals:\n             # \u5982\u679cres \u662f\u7a7a\u7684\uff0c\u521d\u59cb\u5316\u7684\u60c5\u51b5\uff0c\u8981\u628a\u7b2c\u4e00\u4e2a\u4f1a\u8bae\u52a0\u8fdb\u53bb\uff01\n             if not res or interval.start > res[-1].end:\n                 res.append(interval)\n             else:\n                 res[-1].end = max(interval.end, res[-1].end)\n         return res\n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def merge(self, intervals):\n         \"\"\"\n         :type intervals: List[Interval]\n         :rtype: List[Interval]\n         \"\"\"\n         length=len(intervals)\n         if length==1 or length==0: return intervals\n         intervals.sort(key=lambda l:l.start)\n         index=0\n         while index<len(intervals)-1:\n             curr=intervals[index]\n             if curr.end>=intervals[index+1].start:\n                 intervals.pop(index)\n                 next_int=intervals.pop(index)\n                 if curr.end<next_int.end:\n                     curr.end=next_int.end\n                 intervals.insert(index,curr)\n             else:\n                 index+=1\n         return intervals\n     "]
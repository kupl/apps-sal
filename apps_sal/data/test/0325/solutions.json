["def reachable(es, source):\n\tret = {source}\n\tQ = [source]\n\twhile Q:\n\t\tcur = Q.pop()\n\t\tfor nxt in es[cur]:\n\t\t\tif nxt not in ret:\n\t\t\t\tQ.append(nxt)\n\t\t\t\tret.add(nxt)\n\treturn ret\n\ndef BellmanFord(V:int, es:list, source=0):\n\tINF = float(\"inf\")\n\tD = [INF]*V\n\tD[source] = 0\n\tfor _ in range(V):\n\t\tupd = False\n\t\tfor f, t, c in es:\n\t\t\ttmp = D[f] + c\n\t\t\tif D[t] > tmp:\n\t\t\t\tD[t] = tmp\n\t\t\t\tupd = True\n\t\tif not upd:\n\t\t\treturn D[-1]\n\telse:\n\t\treturn None\n\t\ndef main():\n\tN,M,P,*L=map(int,open(0).read().split())\n\tfwd = [[] for _ in range(N)]\n\tbwd = [[] for _ in range(N)]\n\ttmp = []\n\tfor a,b,c in zip(*[iter(L)]*3):\n\t\tfwd[a-1].append(b-1)\n\t\tbwd[b-1].append(a-1)\n\t\ttmp+=[(a-1,b-1,P-c)]\n\tjudge = reachable(fwd,0) & reachable(bwd,N-1)\n\tans = BellmanFord(N,[(a,b,c) for a,b,c in tmp if a in judge and b in judge])\n\tif ans==None:\n\t\tprint(-1)\n\telse:\n\t\tprint(max(0,-ans))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef belman(egdes, N, start, end):\n    INF = int(1e10)\n    cost = [INF] * N\n    cost[start] = 0\n    fin = False\n    count = 0\n    while True:\n        no_change = True\n        for edge in egdes:\n            from_, to_, d = edge\n            tmp = cost[from_] + d\n            if cost[to_] > tmp:\n                no_change = False\n                cost[to_] = tmp\n        count += 1\n        if no_change:\n            fin = True\n            break\n        elif count > N+1:\n            break\n    \n    if fin:\n        return max(0, -cost[end])\n    else:\n        return -1\n\ndef bfs(link, N, start):\n    q = deque()\n    check = [False] * N\n    q.append(start)\n    check[start] = True\n    used = {start}\n    while len(q) > 0:\n        node = q.popleft()\n        for next_ in link[node]:\n            if not check[next_]:\n                check[next_] = True\n                q.append(next_)\n                used.add(next_)\n    return used\n        \n\ndef main():\n    N, M, P = map(int, input().split())\n\n    link = [[] for i in range(N)]\n    rlink = [[] for i in range(N)]\n    edges = []\n\n    for i in range(M):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        link[a].append(b)\n        rlink[b].append(a)\n        edges.append((a, b, -(c-P)))\n    \n    use_nodes = bfs(link, N, 0) & bfs(rlink, N, N-1)\n    use_edges = [(a, b, c) for a, b, c in edges if a in use_nodes and b in use_nodes]\n    print(belman(use_edges, N, 0, N-1))\n\ndef __starting_point():\n    main()\n__starting_point()", "def validate(paths, start):\n    \"\"\"\n    \u6709\u52b9\u306a\u7d4c\u8def\u3092DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\n    \u7d4c\u8def\u3092set\u3067\u8fd4\u3059\n    \"\"\"\n\n    valid_paths = {start}\n    stack = [start]\n\n    while stack:\n        v = stack.pop()\n        if v not in paths:\n            continue\n        for w in paths[v]:\n            if w in valid_paths:\n                continue\n            valid_paths.add(w)\n            stack.append(w)\n    return valid_paths\n\n\ndef bellman_ford(edges, num_v, start, end):\n    \"\"\"\n    \u6709\u5411\u30b0\u30e9\u30d5(\u8ca0\u9589\u8def\u6709\u308a)\u306e\u6700\u77ed\u8ddd\u96e2\n\n    num_v: \u9802\u70b9\u306e\u6570(number_of_vertex)\n    edges: \u9802\u70b9(from, to, cost)\n    \"\"\"\n\n    # \u30b0\u30e9\u30d5\u306e\u521d\u671f\u5316\n    INF = 10**18\n    dist = [INF] * num_v\n    # \u59cb\u70b9\u306f0\u306b\u3059\u308b\n    dist[start] = 0\n\n    # \u8fba\u306e\u7de9\u548c\n    # \u8ca0\u306e\u9589\u8def\u304c\u7121\u3051\u308c\u3070\u3001num_v-1\u56de\u307e\u3067\u3067\u53ce\u675f\u3059\u308b\n    for _ in range(num_v):\n        updated = False\n        for f, t, c in edges:\n            if dist[f] == INF:\n                continue\n\n            # \u30b3\u30b9\u30c8\u304c\u4ee5\u524d\u306e\u3082\u306e\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n            cost = dist[f] + c\n            if cost < dist[t]:\n                dist[t] = cost\n                updated = True\n        if not updated:\n            break\n    else:\n        # num_v\u56de\u306e\u6642\u306b\u66f4\u65b0\u304c\u3042\u308b\u306a\u3089\u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308b\n        return -1\n\n    return max(-dist[end], 0)\n\n\ndef main():\n    from collections import defaultdict\n\n    n, m, p, *tmp = list(map(int, open(0).read().split()))\n\n    paths_rev = defaultdict(list)\n    edges = []\n    for a, b, c in zip(*[iter(tmp)]*3):\n        # \u9802\u70b9n\u304b\u3089\u306e\u7d4c\u8def\u3092dfs\u3059\u308b\u305f\u3081\u3001\u8fba\u306e\u5411\u304d\u3092\u9006\u306b\u3059\u308b\n        paths_rev[b-1].append(a-1)\n        edges.append((a-1, b-1, p-c))\n\n    valid_paths = validate(paths_rev, n-1)\n    edges = [\n        (a, b, c)\n        for a, b, c in edges\n        if a in valid_paths and b in valid_paths\n    ]\n    res = bellman_ford(edges, n, 0, n-1)\n    print(res)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nimport math\n    \ndef dfs(edges, s):\n    stack = deque([s])\n    used  = {s}\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y not in used:\n                used.add(y)\n                stack.append(y)\n    return used\n\n\ndef bfs(edges, s):\n    queue = deque([s])\n    used  = {s}\n    while queue:\n        x = queue.popleft()\n        for y in edges[x]:\n            if y in used:\n                continue\n            used.add(y)\n            queue.append(y)\n    return used\n    \n\ndef bellman(dist):  #\u8ca0\u8fba\u304c\u3042\u308b\u30b1\u30fc\u30b9\u3067\u306e\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\u30a2\u30eb\u30b4\u3002\n    cost = [float(\"inf\")] * n\n    cost[0] = 0\n    for _ in range(n): #\u9802\u70b9\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n        updated = False\n        for u,v,c in dist: #\u8fba\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n            if cost[u] + c < cost[v]:\n                cost[v] = cost[u] + c\n                updated = True                \n    #\u53ce\u675f\u3057\u306a\u3044\u5834\u5408\u306f\u8ca0\u9589\u8def\u304c\u3042\u308b\u305f\u3081\u7121\u9650\u306b\u5c0f\u3055\u304f\u3067\u304d\u308b\u3002\n    if updated==True:\n        return -1\n    else:\n        return max(0, cost[n-1]*-1)    \n        \n\nn,m,p = map(int, input().split())\ndist  = []\nedge1 = [[] for _ in range(n)]\nedge2 = [[] for _ in range(n)]  # rev_edge\nfor _ in range(m):\n    u,v,c = map(int, input().split())\n    u -= 1\n    v -= 1\n    dist.append((u,v,(c-p)*-1))\n    edge1[u].append(v)\n    edge2[v].append(u)    \n    \nuse = dfs(edge1, 0) & dfs(edge2, n-1)\ndist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]\nprint(bellman(dist2))", "from collections import deque\n\ndef dfs(edge, s):\n    used = {s}\n    que = deque([s])\n    while que:\n        v = que.pop()\n        for u in edge[v]:\n            if u in used:\n                continue\n            used.add(u)\n            que.append(u)\n    return used\n\ndef bellmanFord(edges):\n    coins = [float('inf')] * N\n    coins[0] = 0\n    for _ in range(N):\n        f = True\n        for u, v, c in edges:\n            if coins[u] + c < coins[v]:\n                coins[v] = coins[u] + c\n                f = False\n        if f:\n            return max(0, -coins[-1])\n    return -1\n\nN, M, P = map(int, input().split())\nA = [[] for _ in range(N)]\nA_rev = [[] for _ in range(N)]\nE = [tuple()] * M\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    c = P - c\n    A[a].append(b)\n    A_rev[b].append(a)\n    E[i] = (a, b, c)\nU = dfs(A, 0) & dfs(A_rev, N-1)\nF = [(a, b, c) for (a, b, c) in E if a in U and b in U]\nprint(bellmanFord(F))", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(N: int, M: int, P: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    import numpy as np\n    from scipy.sparse import csr_matrix\n    from scipy.sparse.csgraph import bellman_ford, NegativeCycleError\n\n    def to_csr_matrix(X, Y, Z, shape, dtype):\n        d = {}\n        for x, y, z in zip(X, Y, Z):\n            d[(x, y)] = max(d.get((x, y), -float(\"inf\")), z)\n        ind, data = list(zip(*list(d.items())))\n        return csr_matrix((data, list(zip(*ind))), shape=shape, dtype=dtype)\n\n    smat = bellman_ford(csr_matrix((C, (A, B)), shape=(N+1, N+1), dtype=np.int32),\n                        directed=True, unweighted=True, indices=1)\n    tmat = bellman_ford(csr_matrix((C, (B, A)), shape=(N+1, N+1), dtype=np.int32),\n                        directed=True, unweighted=True, indices=N)\n    r = set([i for i, v in enumerate(smat + tmat) if not np.isinf(v)])\n    A, B, C = list(zip(*[(a, b, c) for a, b, c in zip(A, B, C) if b in r]))\n    try:\n        csr_mat = to_csr_matrix(A, B, C, (N+1, N+1), np.float64)\n        csr_mat.data = P - csr_mat.data\n        return -min(int(bellman_ford(csr_mat, directed=True, indices=1)[N]), 0)\n    except NegativeCycleError:\n        return -1\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    P = int(next(tokens))  # type: int\n    A = [int()] * (M)  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    print((solve(N, M, P, A, B, C)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse.csgraph import bellman_ford, NegativeCycleError\nfrom scipy.sparse import csr_matrix\n\nimport sys\ninput = sys.stdin.readline\n\nN,M,P = map(int, input().split())\n\nG = {}\n\nfor i in range(M):\n  a,b,c = map(int, input().split())\n  a,b,c = a-1, b-1, (-1) * (c-P) # \u6700\u77ed\u7089\u554f\u984c\u306b\u3059\u308b\u305f\u3081\u3002\n  if (a,b) in G and G[(a,b)] > c:\n    G[(a,b)] = c\n  elif (a,b) not in G:\n    G[(a,b)] = c\n\nA,B,C = [],[],[]\nfor k,v in G.items():\n  a,b = k\n  c = v\n  #G[a].append((b,c))\n  A.append(a)\n  B.append(b)\n  C.append(c)\n    \nCC = [1] * len(A)\n### https://atcoder.jp/contests/abc137/submissions/15987354\n# \u3068\u308a\u3042\u3048\u305a\u5230\u9054\u53ef\u80fd\u7d4c\u8def\u3092\u63a2\u3059\u3001\u59cb\u70b9\u3068\u7d42\u70b9\u304b\u3089\u91cd\u307f\uff11\u306b\u3057\u3066\u8fbf\u3063\u3066\u3044\u304d\u3001\u53cc\u65b9\u767b\u5834\u3057\u305f\u70b9\u304c\u63a2\u3059\u3079\u304d\u70b9\u3002\n# directed\u306a\u306e\u3067\u3001A,B\u3092\u5165\u308c\u66ff\u3048\u3066\u3044\u308b\u3068\u3053\u308d\u3082\u30dd\u30a4\u30f3\u30c8\nsmat = bellman_ford(csr_matrix((CC, (A, B)), shape=(N, N)),\n                    directed=True, unweighted=True, indices=0)\ntmat = bellman_ford(csr_matrix((CC, (B, A)), shape=(N, N)),\n                    directed=True, unweighted=True, indices=N-1)\nr = set([i for i, v in enumerate(smat + tmat) if not np.isinf(v)])\nA, B, C = zip(*[(a, b, c) for a, b, c in zip(A, B, C) if b in r])\ntry:\n  csr_mat = csr_matrix((C, (A, B)), shape=(N, N))\n  #csr_mat.data = P - csr_mat.data\n  x = -int(bellman_ford(csr_mat, directed=True, indices=0)[N-1])\n  if x < 0:\n    x = 0\nexcept NegativeCycleError:\n  x = -1\n\nprint(x)", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\nclass Bellman_Ford:\n    def __init__(self, v=None, e=None, lis=None, start=None, end=None, inf=float('inf')):\n        self.V = v\n        self.E = e\n        self.lis = lis\n        self.start = start if start else 0\n        self.end = end if end else self.V-1\n        self.inf = inf\n        self.close_minus = False\n    \n    def getlist(self, lis):\n        self.lis = lis\n    \n    def def_start(self, s):\n        self.start = s\n    \n    def def_end(self, e):\n        self.end = e\n\n    def def_inf(self, inf):\n        self.inf = inf\n    \n    def def_vertice(self, v):\n        self.V = v\n    \n    def def_edge(self, e):\n        self.E = e\n\n    def prepare(self):\n        self.cost = [self.inf]*self.V # \u5404\u9802\u70b9\u3078\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\n        self.cost[self.start] = 0 # \u81ea\u8eab\u3078\u306e\u8ddd\u96e2\u306f0\n\n    def search(self):\n        for i in range(self.V):\n            update = False # \u66f4\u65b0\u304c\u884c\u308f\u308c\u305f\u304b\n            for x, y, z in self.lis:\n                if self.cost[y] > self.cost[x] + z:\n                    self.cost[y] = self.cost[x] + z\n                    update = True\n            if not update:\n                break\n            # \u8ca0\u9589\u8def\u304c\u5b58\u5728\n            if i == self.V - 1:\n                self.close_minus = True\n                return False\n        return True\n\n    def main(self):\n        self.prepare()\n        self.search()\n    \n    def cost_all(self):\n        return self.cost\n\ndef main():\n    n, m, p = map(int, input().split())\n    \n    graph = [None]*m\n    tree_forth = [[] for _ in range(n)]\n    tree_back = [[] for _ in range(n)]\n    \n    for i in range(m):\n        a, b, c =map(int, input().split())\n        tree_forth[a-1].append(b-1)\n        tree_back[b-1].append(a-1)\n        c = p-c\n        graph[i] = (a-1, b-1, c)\n    \n    already1, already2 = [True]*n, [True]*n\n    for already, tree, start in zip([already1, already2], [tree_forth, tree_back], [0, n-1]):\n        not_yet = deque([start])\n        already[start] = False\n        while not_yet:\n            key = not_yet.pop()\n            for v in tree[key]:\n                if already[v] == False:\n                    continue\n                already[v] = False\n                not_yet.append(v)\n    \n    graph_new = []\n    for i in range(m):\n        a, b, c = graph[i]\n        if already1[a] or already1[b] or already2[a] or already2[b]:\n            continue\n        graph_new.append((a, b, c))\n       \n    bf = Bellman_Ford(v=n, e=m, lis=graph_new)\n    bf.main()\n    if bf.close_minus:\n        print(-1)\n    else:\n        print(max(0, -bf.cost[n-1]))\n    \n    \n    \ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    INF = float(\"inf\")\n\n    N, M, P, *ABC = list(map(int, open(0).read().split()))\n\n    F = [[] for _ in range(N)]\n    B = [[] for _ in range(N)]\n    E = [(a - 1, b - 1, P - c) for a, b, c in zip(*[iter(ABC)] * 3)]\n\n    for a, b, c in E:\n        F[a].append(b)\n        B[b].append(a)\n\n    def reachable(E, a):\n        S = {a}\n        stack = [a]\n        while stack:\n            s = stack.pop()\n            for v in E[s]:\n                if v not in S:\n                    stack.append(v)\n                    S.add(v)\n        return S\n\n    ok = reachable(F, 0) & reachable(B, N - 1)\n\n    E = [(a, b, c) for a, b, c in E if a in ok and b in ok]\n\n    D = [INF] * N\n    D[0] = 0\n\n    def bellman_ford(N):\n        for _ in range(N):\n            update = False\n            for a, b, c in E:\n                if D[b] > D[a] + c:\n                    D[b] = D[a] + c\n                    update = True\n            if not update:\n                return False\n        return True\n\n    print((-1 if bellman_ford(N + 1) else max(-D[-1], 0)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from scipy.sparse.csgraph import bellman_ford, NegativeCycleError\nfrom scipy.sparse import csr_matrix\nfrom collections import defaultdict\n\nn, m, p = list(map(int, input().split()))\nabc = [list(map(int, input().split())) for _ in range(m)]\nINF = 10 ** 9\n\nfwd = [[] for _ in range(n + 1)]\nrev = [[] for _ in range(n + 1)]\n\nfor a, b, c in abc:\n    fwd[a].append(b)\n    rev[b].append(a)\n\n\ndef dfs(s, adj):\n    stack = [s]\n    arrived = [False] * (n + 1)\n    arrived[s] = True\n    while stack:\n        u = stack.pop()\n        for v in adj[u]:\n            if not arrived[v]:\n                arrived[v] = True\n                stack.append(v)\n\n    return arrived\n\n\ncan_go_fwd = dfs(1, fwd)\ncan_go_rev = dfs(n, rev)\n\ndata = defaultdict(lambda: INF)\nfor a, b, c in abc:\n    if can_go_fwd[a] and can_go_rev[b]:\n        data[(a, b)] = min(data[(a, b)], p - c)\n\nrow = []\ncol = []\ncost = []\nfor (a, b), c in list(data.items()):\n    row.append(a)\n    col.append(b)\n    cost.append(c)\n\ng = csr_matrix((cost, (row, col)), shape=(n + 1, n + 1))\n\ntry:\n    dist = bellman_ford(g, indices=[1]).astype(int)\n    ans = max(0, -dist[0][n])\n    print(ans)\nexcept NegativeCycleError:\n    print((-1))\n", "from collections import deque\n\ndef dfs(edge, s):\n    used = {s}\n    que = deque([s])\n    while que:\n        v = que.pop()\n        for u in edge[v]:\n            if u in used:\n                continue\n            used.add(u)\n            que.append(u)\n    return used\n\ndef bellmanFord(edges):\n    coins = [float('inf')] * N\n    coins[0] = 0\n    for _ in range(len(U)):\n        f = True\n        for u, v, c in edges:\n            if coins[u] + c < coins[v]:\n                coins[v] = coins[u] + c\n                f = False\n        if f:\n            return max(0, -coins[-1])\n    return -1\n\nN, M, P = map(int, input().split())\nA = [[] for _ in range(N)]\nA_rev = [[] for _ in range(N)]\nE = [tuple()] * M\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    c = P - c\n    A[a].append(b)\n    A_rev[b].append(a)\n    E[i] = (a, b, c)\nU = dfs(A, 0) & dfs(A_rev, N-1)\nF = [(a, b, c) for (a, b, c) in E if a in U and b in U]\nprint(bellmanFord(F))", "import time\n\nt1 = time.time()\n\nN, M, P = list(map(int, input().split()))\nABC = [tuple(map(int, input().split())) for _ in range(M)]\n\nto_w = [set() for _ in range(N)]\nfor a, b, c in ABC:\n    to_w[a - 1].add((b - 1, P - c))\nreachable_from_start = {0}\nq = {0}\nwhile q:\n    u = q.pop()\n    for v, _ in to_w[u]:\n        if v not in reachable_from_start:\n            reachable_from_start.add(v)\n            q.add(v)\n\n\nfrom_w = [set() for _ in range(N)]\nfor a, b, c in ABC:\n    from_w[b - 1].add((a - 1, P - c))\nreachable_to_goal = {N - 1}\nq = {N - 1}\nwhile q:\n    u = q.pop()\n    for v, _ in from_w[u]:\n        if v not in reachable_to_goal:\n            reachable_to_goal.add(v)\n            q.add(v)\n\n\nreachable = reachable_from_start & reachable_to_goal\n\n\nto_w = [set() for _ in range(N)]\nfor a, b, c in ABC:\n    if a - 1 in reachable and b - 1 in reachable:\n        to_w[a - 1].add((b - 1, P - c))\nd = [float(\"inf\")] * N\nd[0] = 0\nq = {0}\nwhile q:\n    u = q.pop()\n\n    for v, w in to_w[u]:\n        tmp = d[u] + w\n        if tmp < d[v]:\n            d[v] = tmp\n            if v not in q:\n                q.add(v)\n\n        if time.time() > 1.9 + t1:\n            d[-1] = -float(\"inf\")\n            break\n    else:\n        continue\n    break\n\nif d[-1] == -float(\"inf\"):\n    print((-1))\nelse:\n    print((max(0, -d[-1])))\n", "from scipy.sparse import coo_matrix\nfrom scipy.sparse.csgraph import bellman_ford, NegativeCycleError\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m, p = list(map(int, input().split()))\n\n    edges = []\n    routes = [[] for _ in range(n)]\n    rev_routes = [[] for _ in range(n)]\n\n    def get_reachable_nodes(start, routes):\n        seen = {start}\n        todo = []\n        for to in routes[start]:\n            todo.append(to)\n            seen.add(to)\n\n        while todo:\n            node = todo.pop()\n            for to in routes[node]:\n                if to in seen:\n                    continue\n                todo.append(to)\n                seen.add(to)\n        return seen\n\n    for _ in range(m):\n        node1, node2, value = list(map(int, input().split()))\n        node1, node2, value = node1 - 1, node2 - 1, value - p\n        edges.append([node1, node2, value])\n        routes[node1].append(node2)\n        rev_routes[node2].append(node1)\n\n    from_start = get_reachable_nodes(0, routes)\n    if n-1 not in from_start:\n        print((-1))\n        return\n\n    to_goal = get_reachable_nodes(n-1, rev_routes)\n\n    from_start_to_goal = from_start & to_goal\n\n    temp_dict = dict()\n\n    for row, col, value in edges:\n        if {row, col} <= from_start_to_goal:\n            if not (row, col) in temp_dict:\n                temp_dict[(row, col)] = -value\n            else:\n                temp_dict[(row, col)] = min(-value, temp_dict[(row, col)])\n\n    values = []\n    rows = []\n    cols = []\n\n    for (row, col), minus_value in list(temp_dict.items()):\n        values.append(minus_value)\n        rows.append(row)\n        cols.append(col)\n\n    graph = coo_matrix((values, (rows, cols)), shape=(n, n))\n    try:\n        bf = bellman_ford(graph, indices=[0])\n        print((max(0, -int(bf[0][n - 1]))))\n    except NegativeCycleError:\n        print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def reachable(es, source):\n\tret = {source}\n\tQ = [source]\n\twhile Q:\n\t\tcur = Q.pop()\n\t\tfor nxt in es[cur]:\n\t\t\tif nxt not in ret:\n\t\t\t\tQ.append(nxt)\n\t\t\t\tret.add(nxt)\n\treturn ret\n\ndef BellmanFord(V:int, es:list, source=0):\n\tINF = float(\"inf\")\n\tD = [INF]*V\n\tD[source] = 0\n\tfor _ in range(V):\n\t\tupd = False\n\t\tfor f, t, c in es:\n\t\t\ttmp = D[f] + c\n\t\t\tif D[t] > tmp:\n\t\t\t\tD[t] = tmp\n\t\t\t\tupd = True\n\t\tif not upd:\n\t\t\treturn D[-1]\n\telse:\n\t\treturn None\n\t\ndef main():\n\tN,M,P,*L=map(int,open(0).read().split())\n\tfwd = [[] for _ in range(N)]\n\tbwd = [[] for _ in range(N)]\n\tfor a,b in zip(L[::3],L[1::3]):\n\t\tfwd[a-1].append(b-1)\n\t\tbwd[b-1].append(a-1)\n\tjudge = reachable(fwd,0) & reachable(bwd,N-1)\n\tG = [(a-1,b-1,P-c) for a,b,c in zip(*[iter(L)]*3) if a-1 in judge and b-1 in judge]\n\tans = BellmanFord(N,G)\n\tif ans==None:\n\t\tprint(-1)\n\telse:\n\t\tprint(max(0,-ans))\n\ndef __starting_point():\n\tmain()\n__starting_point()", "from collections import defaultdict\nfrom scipy.sparse.csgraph import connected_components, bellman_ford, NegativeCycleError\nfrom scipy.sparse import csr_matrix\n\nN, M, P = list(map(int, input().split()))\n\nd = defaultdict(lambda: P)\nfor _ in range(M):\n    a, b, c = list(map(int, input().split()))\n    d[(a - 1, b - 1)] = min(d[(a - 1, b - 1)], P - c)\n\nM = len(d)\nfrm, to, length = [], [], []\nfor (a, b), c in list(d.items()):\n    frm.append(a)\n    to.append(b)\n    length.append(c)\n\n# N-1\u21920\u306e\u8fba\u3092\u8ffd\u52a0\u3057\u3066\u304b\u3089\u5f37\u9023\u7d50\u5224\u5b9a\u21d2\u30b4\u30fc\u30eb\u306b\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u9589\u8def\u3092\u9664\u5916\nconnect_check = csr_matrix(([1] * (M + 1), (frm + [N - 1], to + [0])), shape=(N, N))\n_, labels = connected_components(connect_check, connection='strong')\nlabel_num = labels[0]\nfrm_c, to_c, length_c = [], [], []\nfor i in range(M):\n    if labels[frm[i]] == labels[to[i]] == label_num:\n        frm_c.append(frm[i])\n        to_c.append(to[i])\n        length_c.append(length[i])\n\nmatr = csr_matrix((length_c, (frm_c, to_c)), shape=(N, N))\n\ntry:\n    ans = -int(bellman_ford(matr, indices=0)[N - 1])\n    print((max(0, ans)))\nexcept NegativeCycleError:\n    print((-1))\n", "n, m, p = list(map(int, input().split()))\n\nabc = []\nedge = [[] for _ in range(n)]\nrev_edge = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    abc.append((a - 1, b - 1, p - c))\n    edge[a - 1].append(b - 1)\n    rev_edge[b - 1].append(a - 1)\n\n\ndef dfs(e, s):\n    v_set = {s}\n    stack = [s]\n    while stack:\n        v = stack.pop()\n        for next_v in e[v]:\n            if next_v in v_set:\n                continue\n            v_set.add(next_v)\n            stack.append(next_v)\n    return v_set\n\n\ndef bellman_ford(sub_abc, n):\n    inf = float(\"inf\")\n    dist = [inf] * n\n    dist[0] = 0\n\n    for _ in range(n):\n        updated = False\n        for u, v, d in sub_abc:\n            if dist[u] + d < dist[v]:\n                dist[v] = dist[u] + d\n                updated = True\n        if not updated:\n            break\n    else:\n        return -1\n\n    return max(-dist[n - 1], 0)\n\n\nuse = dfs(edge, 0) & dfs(rev_edge, n - 1)\nprint((bellman_ford([(a, b, c)\n                    for (a, b, c) in abc if a in use and b in use], n)))\n", "import sys\nimport numpy as np\nfrom scipy.sparse.csgraph import bellman_ford, connected_components\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m, p = list(map(int, input().split()))\n    \n    l = np.zeros((n, n))\n    for i in range(m):\n        a, b, c =list(map(int, input().split()))\n        c = p-c\n        if c == 0:\n            c = 10**(-7.9)\n        if l[a-1][b-1] == 0:\n            l[a-1][b-1] = c\n        else:\n            l[a-1][b-1] = min(l[a-1][b-1], c)\n    x = l[-1, 0]\n    l[-1][0] = 10**(-7.9)\n    n, labels = connected_components(l, connection=\"strong\")\n    l = l[labels == labels[0]][:, labels == labels[0]]\n    l[-1, 0] = x\n    \n    try:\n        print((max(0, int(round(bellman_ford(l, indices=0)[-1]))*(-1))))\n    except:\n        print((-1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    INF = float(\"inf\")\n\n    N, M, P, *ABC = list(map(int, open(0).read().split()))\n\n    F = [[] for _ in range(N)]\n    B = [[] for _ in range(N)]\n    E = [(a - 1, b - 1, P - c) for a, b, c in zip(*[iter(ABC)] * 3)]\n\n    for a, b, c in E:\n        F[a].append(b)\n        B[b].append(a)\n\n    S = {0}\n    stack = [0]\n    while stack:\n        s = stack.pop()\n        for v in F[s]:\n            if v not in S:\n                stack.append(v)\n                S.add(v)\n\n    T = {N - 1}\n    stack = [N - 1]\n    while stack:\n        s = stack.pop()\n        for v in B[s]:\n            if v not in T:\n                stack.append(v)\n                T.add(v)\n\n    ok = S & T\n\n    E = [(a, b, c) for a, b, c in E if a in ok and b in ok]\n\n    D = [INF] * N\n    D[0] = 0\n\n    def bellman_ford(N):\n        for _ in range(N):\n            update = False\n            for a, b, c in E:\n                if D[b] > D[a] + c:\n                    D[b] = D[a] + c\n                    update = True\n            if not update:\n                return False\n        return True\n\n    print((-1 if bellman_ford(N + 1) else max(-D[-1], 0)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections\n\nn, m, p = list(map(int, input().split()))\ndist1 = []\nedges1 = [[] for _ in range(n)]\nedges2 = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    dist1.append((a, b, (c - p) * -1))\n    edges1[a].append(b)\n    edges2[b].append(a)\n\ndef dfs(edges, start):\n    stack = [start]\n    use = {start, }\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y in use:\n                continue\n            stack.append(y)\n            use.add(y)\n    return use\n\n\ndef bellman_ford(dist):\n    v = [float('inf')] * n\n    v[0] = 0\n    for _ in range(n):\n        updated = False\n        for a, b, c in dist:\n            if v[a] + c < v[b]:\n                updated = True\n                v[b] = v[a] + c\n        if not updated:\n            return max(0, v[n - 1] * -1)\n    return -1\n\nuse = dfs(edges1, 0) & dfs(edges2, n - 1)\ndist2 = [(a, b, c) for a, b, c in dist1 if a in use and b in use]\nprint((bellman_ford(dist2)))\n", "n, m, p = list(map(int, input().split()))\n\nabc = []\n# edge = [[] for _ in range(n)]\nrev_edge = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    abc.append((a - 1, b - 1, p - c))\n    # edge[a - 1].append(b - 1)\n    rev_edge[b - 1].append(a - 1)\n\n\ndef dfs(e, s):\n    v_set = {s}\n    stack = [s]\n    while stack:\n        v = stack.pop()\n        for next_v in e[v]:\n            if next_v in v_set:\n                continue\n            v_set.add(next_v)\n            stack.append(next_v)\n    return v_set\n\n\ndef bellman_ford(sub_abc, n):\n    inf = float(\"inf\")\n    dist = [inf] * n\n    dist[0] = 0\n\n    for _ in range(n):\n        updated = False\n        for u, v, d in sub_abc:\n            if dist[u] + d < dist[v]:\n                dist[v] = dist[u] + d\n                updated = True\n        if not updated:\n            break\n    else:\n        return -1\n\n    return max(-dist[n - 1], 0)\n\n\nuse = dfs(rev_edge, n - 1)\nprint((bellman_ford([(a, b, c)\n                    for (a, b, c) in abc if a in use and b in use], n)))\n", "from collections import deque\ndef solve():\n    N, M, P = map(int, input().split())\n    G = [[] for i in range(N)]\n    RG = [[] for i in range(N)]\n    for i in range(M):\n        a, b, c = map(int, input().split())\n        G[a-1].append((b-1, P-c))\n        RG[b-1].append((a-1, P-c))\n\n    def chk(s, G):\n        P = [0]*N\n        que = deque([s])\n        used = [0]*N\n        used[s] = 1\n        while que:\n            v = que.popleft()\n            P[v] = 1\n            for w, c in G[v]:\n                if used[w]:\n                    continue\n                que.append(w)\n                used[w] = 1\n        return P\n    P0 = chk(0, G); P1 = chk(N-1, RG)\n    F = [P0[i] == P1[i] == 1 for i in range(N)]\n    I = [i for i in range(N) if F[i]]\n\n    E0 = []\n    for v in I:\n        for w, c in G[v]:\n            if not F[w]:\n                continue\n            E0.append((v, w, c))\n\n    dist = [10**18]*N\n    dist[0] = 0\n    L = len(I)\n    for i in range(L):\n        update = 0\n        for v, w, c in E0:\n            x = c + dist[v]\n            if x < dist[w]:\n                dist[w] = x\n                update = 1\n        if not update:\n            break\n    else:\n        print(\"-1\")\n        return\n\n    print(max(-dist[N-1], 0))\nsolve()", "# \u9802\u70b9s\u304b\u3089\u5230\u9054\u3059\u308b\u9802\u70b9\u306e\u96c6\u5408\ndef dfs(edge, s):\n    use = {s}\n    q = [s]\n    while q:\n        v = q.pop()\n        for w in edge[v]:\n            if w in use:continue\n            use.add(w)\n            q.append(w)\n    return use\n\n# \u30d9\u30eb\u30de\u30f3\u30d5\u30a9\u30fc\u30c9\u6cd5\ndef bellman_ford(v, s, t, e):\n    # \u30b3\u30b9\u30c8\u3092INF\u3067\u521d\u671f\u5316\n    d = [10**18] * v\n    # \u958b\u59cb\u9802\u70b9\u306f0\n    d[s] = 0\n    # \u8ca0\u306e\u9589\u8def\u304c\u7121\u3051\u308c\u3070\u66f4\u65b0\u306fV-1\u56de\u307e\u3067\u3067\u7d42\u308f\u308b\n    for _ in range(v):\n        f = False\n        for a, b, c in e:\n            # a\u307e\u3067\u306e\u30b3\u30b9\u30c8+\u8fbaab\u306e\u30b3\u30b9\u30c8\u304cb\u307e\u3067\u306e\u30b3\u30b9\u30c8\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n            cost = d[a] + c\n            if cost < d[b]:\n                d[b] = cost\n                f = True\n        # \u66f4\u65b0\u304c\u7121\u3051\u308c\u3070break\n        if not f:break\n    else:\n        # V\u56de\u76ee\u307e\u3067\u66f4\u65b0\u304c\u3042\u3063\u305f\u3089\u8ca0\u306e\u9589\u8def\u304c\u3042\u308b\n        return -1\n    return max(-d[t], 0)\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n    n, m, p = map(int, input().split())\n    edge = [[] for _ in range(n)]\n    edge_rev = [[] for _ in range(n)]\n    e = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edge[a-1].append(b-1)\n        # \u9802\u70b9N\u304b\u3089dfs\u3059\u308b\u305f\u3081\u8fba\u306e\u5411\u304d\u3092\u9006\u306b\u3059\u308b\n        edge_rev[b-1].append(a-1)\n        e.append((a-1, b-1, p-c))\n    # \u9802\u70b91\u3068\u9802\u70b9N\u306e\u3069\u3061\u3089\u304b\u3089\u3082\u5230\u9054\u3067\u304d\u308b\u9802\u70b9\u306e\u96c6\u5408\n    use = dfs(edge, 0) & dfs(edge_rev, n-1)\n    # from\u3068to\u304c\u3069\u3061\u3089\u3082use\u306b\u542b\u307e\u308c\u308b\u8fba\u306e\u307f\u4f7f\u3046\n    # \u305d\u3046\u3059\u308b\u3053\u3068\u3067\u8ca0\u306e\u9589\u8def\u3092\u691c\u51fa\u3057\u305f\u5834\u5408\u7b54\u3048\u306f\u5fc5\u305a-1\u306b\u306a\u308b\n    e=[(a, b, c) for a, b, c in e if a in use and b in use]\n    print(bellman_ford(n, 0, n-1, e))   \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000000)\n\nii = lambda: int(input())\nmiis = lambda: map(int, input().split())\nlmiis = lambda: list(miis())\n\ndef reachable_nodeset(start, inc):\n    reachable = set()\n    reachable.add(start)\n    nodes = [start]\n\n    while nodes:\n        n = nodes.pop()\n        for i in inc[n]:\n            if i not in reachable:\n                nodes.append(i)\n                reachable.add(i)\n\n    return reachable\n\ndef bellmanford(num, start, goal, edges):\n    cost = [float('inf')] * num\n    cost[start] = 0\n\n    for _ in range(num):\n        updated = False\n        for a, b, c in edges:\n            if cost[b] > cost[a] + c:\n                cost[b] = cost[a] + c\n                updated = True\n        if not updated: break\n    else:\n        return -1\n\n    return max(0, -cost[goal])\n\ndef solve():\n    N, M, P = miis()\n    to = [[] for _ in range(N)]\n    ot = [[] for _ in range(N)]\n    edges = []\n\n    for _ in range(M):\n        a, b, c = miis()\n        a -= 1\n        b -= 1\n        c = -(c - P)\n\n        to[a].append(b)\n        ot[b].append(a)\n        edges.append((a,b,c))\n\n    reachableFromZero = reachable_nodeset(0, to)\n    reachableToN = reachable_nodeset(N-1, ot)\n    ok = reachableFromZero.intersection(reachableToN)\n\n    edges = tuple((a,b,c) for a, b, c in edges if a in ok and b in ok)\n\n    print(bellmanford(N, 0, N-1, edges))\n\ndef __starting_point():\n    solve()\n__starting_point()", "# \u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306e\u96c6\u5408\ndef reachable_nodeset(start, inc):\n  reachable = set()\n  reachable.add(start)\n  nodes = [start]\n  \n  while nodes:\n    n = nodes.pop()\n    for i in inc[n]:\n      if i not in reachable:\n        nodes.append(i)\n        reachable.add(i)\n  return reachable\n\ndef bellmanford(num, start, goal, edges):\n  cost = [float('inf')]*num\n  cost[start] = 0\n  # \u8ca0\u306e\u9589\u8def\u304c\u7121\u3051\u308c\u3070\u66f4\u65b0\u306fV-1\u56de\u307e\u3067\u3067\u7d42\u308f\u308b\n  for _ in range(num):\n    updated = False\n    for a, b, c in edges:\n      # a\u307e\u3067\u306e\u30b3\u30b9\u30c8+\u8fbaab\u306e\u30b3\u30b9\u30c8\u304cb\u307e\u3067\u306e\u30b3\u30b9\u30c8\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n      if cost[b] > cost[a]+c:\n        cost[b] = cost[a]+c\n        updated = True\n    if not updated: break\n  else:\n    # V\u56de\u76ee\u307e\u3067\u66f4\u65b0\u304c\u3042\u3063\u305f\u3089\u8ca0\u306e\u9589\u8def\u304c\u3042\u308b\n    return -1\n  return max(0, -cost[goal])\n\nN, M, P = map(int, input().split())\nto = [[] for _ in range(N)]\not = [[] for _ in range(N)]\nedges = []\n\nfor _ in range(M):\n  a, b, c = map(int, input().split())\n  a -= 1\n  b -= 1\n  c = -(c-P)\n  \n  to[a].append(b)\n  ot[b].append(a)\n  edges.append((a,b,c))\n  \nreachableFromZero = reachable_nodeset(0, to)  \nreachableToN = reachable_nodeset(N-1, ot)  \nok = reachableFromZero.intersection(reachableToN)\nedges = tuple((a,b,c) for a,b,c in edges if a in ok and b in ok)\n\nprint(bellmanford(N, 0, N-1, edges))", "def bellman_ford(s, n, G):\n    d = [float('inf')]*n\n    d[s] = 0\n    for i in range(n):\n        update = False\n        for x, y, z in G:\n            if d[y] > d[x] + z:\n                d[y] = d[x] + z\n                update = True\n        if not update:\n            break\n        if i == n - 1:\n            return None\n    return d\n\ndef main():\n    n, m, p = map(int, input().split())\n    G = []\n    U = [[] for _ in range(n)]\n    V = [[] for _ in range(n)]\n    dic = {}\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        if (a-1, b-1) in dic:\n            if dic[(a-1, b-1)] > -c+p:\n                dic[(a-1, b-1)] = -c+p\n        else:\n            dic[(a-1, b-1)] = -c+p\n    for v in dic.keys():\n        G.append([v[0], v[1], dic[v]])\n        U[v[1]].append(v[0])\n        V[v[0]].append(v[1])\n    st1 = set()\n    st1.add(n-1)\n    q = [n-1]\n    while len(q) > 0:\n        t = q.pop(-1)\n        for v in U[t]:\n            if not v in st1:\n                q.append(v)\n                st1.add(v)\n    st2 = set()\n    st2.add(0)\n    q = [0]\n    while len(q) > 0:\n        t = q.pop(-1)\n        for v in V[t]:\n            if not v in st2:\n                q.append(v)\n                st2.add(v)\n    st = st1 & st2\n    eg = []\n    for v in G:\n        if v[0] in st and v[1] in st:\n            eg.append(v)\n    ans = bellman_ford(0, n, eg)\n    if ans is None:\n        print(-1)\n    else:\n        print(max(0, -ans[n-1]))\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    def dfs(edge,s):\n        use={s}\n        q=[s]\n        while q:\n            v=q.pop()\n            for w in edge[v]:\n                if w in use:continue\n                use.add(w)\n                q.append(w)\n        return use\n    n,m,p,*t=map(int,open(0).read().split())\n    edge=[[]for _ in range(n)]\n    edge_rev=[[]for _ in range(n)]\n    e=[]\n    for a,b,c in zip(t[::3],t[1::3],t[2::3]):\n        edge[a-1].append(b-1)\n        edge_rev[b-1].append(a-1)\n        e.append((a-1,b-1,p-c))\n    use=dfs(edge,0)&dfs(edge_rev,n-1)\n    e=[(a,b,c)for a,b,c in e if a in use and b in use]\n    INF=10**18\n    d=[0]+[INF]*(n-1)\n    for _ in range(n):\n        f=False\n        for a,b,c in e:\n            cost=d[a]+c\n            if cost<d[b]:\n                d[b]=cost\n                f=True\n        if not f:break\n    else:\n        print(-1)\n        return\n    print(max(-d[-1],0))\nmain()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\ndef find_negative_loop(n,e):\n  d=n*[10**20];d[0]=0\n  for h in range(n):\n    for i,j,k in e:\n      if d[j]>d[i]+k:\n        d[j]=d[i]+k\n        if h==n-1:return -1\n  return max(-d[n-1],0)\n\nfrom collections import deque\ndef find_loop(n,e,flag):\n  x=[0]*n\n  d=deque()\n  t=[]\n  c=0\n  for i in range(n):\n    for j in e[i]:x[j]+=1\n  for i in range(n):\n    if x[i]==0:\n      d.append(i)\n      t.append(i)\n      c+=1\n  while d:\n    i=d.popleft()\n    for j in e[i]:\n      x[j]-=1\n      if x[j]==0:\n        d.append(j)\n        t.append(j)\n        c+=1\n  if flag==0:return c==n\n  else:return t\n\ndef glaph_bfs(s,n,e):\n  ans=[0]*n\n  Q=[s]\n  visited={s}\n  while Q:\n    P=[]\n    for i in Q:\n      ans[i]=1\n      for j in e[i]:\n        if j in visited:continue\n        visited.add(j)\n        P.append(j)\n    Q=P\n  return ans\n\nn,m,p=map(int,input().split())\nef=[[]for _ in range(n)]\nee=[[]for _ in range(n)]\ne=[]\nfor _ in range(m):\n  a,b,c=map(int,input().split())\n  a-=1\n  b-=1\n  c-=p\n  ef[a].append(b)\n  ee[b].append(a)\n  e.append((a,b,c))\neff=glaph_bfs(0,n,ef)\neef=glaph_bfs(n-1,n,ee)\nee=[]\nfor a,b,c in e:\n  if eff[a]==1 and eef[a]==1 and eff[b]==1 and eef[b]==1:\n    ee.append((a,b,-c))\nprint(find_negative_loop(n,ee))", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\n\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    a,b = LI()\n    print((max(a+b,a-b,a*b)))\n    return\n\n#B\ndef B():\n    k,x = LI()\n    ans = []\n    for i in range(x-k+1,x+k):\n        ans.append(i)\n    print((*ans))\n    return\n\n#C\ndef C():\n    def f(s):\n        res = [0]*m\n        for i in s:\n            res[alp.index(i)] += 1\n        return res\n    alp = list(\"abcdefghijklmnopqrstuvwxyz\")\n    m = len(alp)\n    n = I()\n    s = [input() for i in range(n)]\n    d = defaultdict(lambda : 0)\n    for i in s:\n        d[tuple(f(i))] += 1\n    ans = 0\n    for i in list(d.values()):\n        ans += (i*(i-1))//2\n    print(ans)\n    return\n\n#D\ndef D():\n    n,m = LI()\n    g = LIR(n)\n    g.sort(key = lambda x:x[0])\n    ans = 0\n    f = [1]*n\n    j = 0\n    q = []\n    for i in range(m)[::-1]:\n        while j < n and m-g[j][0] >= i:\n            a,b = g[j]\n            heappush(q,(-b,a))\n            j += 1\n        if q:\n            x,a = heappop(q)\n            if i+a <= m:\n                ans -= x\n    print(ans)\n    return\n\n#E\ndef E():\n    def dfs(x,f):\n        for y,w in v[x]:\n            if f[y]:\n                if dp[y] < dp[x]+w:\n                    f[y] = 0\n                    dp[y] = dp[x]+w\n                    dfs(y,f)\n                    f[y] = 1\n            else:\n                if dp[y] < dp[x]+w:\n                    dp[y] = float(\"inf\")\n                    dfs(y,f)\n    n,m,p = LI()\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = LI()\n        a -= 1\n        b -= 1\n        v[a].append((b,c-p))\n    f = [1]*n\n    dp = [-float(\"inf\")]*n\n    dp[0] = 0\n    f[0] = 0\n    dfs(0,f)\n    ans = dp[n-1]\n    if ans == float(\"inf\") or ans == -float(\"inf\"):\n        print((-1))\n    elif ans < 0:\n        print((0))\n    else:\n        print(ans)\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    E()\n\n__starting_point()", "import numpy as np\nfrom collections import defaultdict\nfrom scipy.sparse.csgraph import bellman_ford,connected_components\nfrom scipy.sparse import csr_matrix\n\nN,M,P = map(int,input().split())\nABC = [list(map(int,input().split())) for _ in range(M)]\n\nABC_max = defaultdict(int)\nfor a,b,c in ABC:\n    ABC_max[(a,b)] = max(ABC_max[(a,b)],c)\n    \nABC = np.array([[a,b,c] for (a,b),c in ABC_max.items()],np.int64)\n\nA=ABC[:,0] -1 \nB=ABC[:,1] -1\nC=ABC[:,2] - P\n\nL = csr_matrix((C,(A,B)),(N,N))\nL[N-1,0] = 1\n\n_, label = connected_components(L,connection=\"strong\")\n\nlabel = np.arange(N)[label==label[0]]\n\nABC = ABC[np.isin(ABC[:,:2],label+1).all(axis=1)]\nA=ABC[:,0] -1 \nB=ABC[:,1] -1\nC=ABC[:,2] - P\n\nL = csr_matrix((-C,(A,B)),(N,N))\n\ntry:\n    dist = bellman_ford(L,indices=0).astype(np.int64)\n    print(max(0,-dist[-1]))\nexcept:\n    print(-1)", "import sys\ninput=sys.stdin.readline\nn,m,p=[int(j) for j in input().split()]\n\ndef bellman_ford(v, s, e):\n    INF = 10**18\n    # \u30b3\u30b9\u30c8\u3092INF\u3067\u521d\u671f\u5316\n    d = [INF] * v\n    # \u958b\u59cb\u9802\u70b9\u306f0\n    d[s] = 0\n    # \u8ca0\u306e\u9589\u8def\u304c\u7121\u3051\u308c\u3070\u66f4\u65b0\u306fV-1\u56de\u307e\u3067\u3067\u7d42\u308f\u308b\n    for _ in range(v):\n        f = False\n        for a, b, c in e:\n            # a\u307e\u3067\u306e\u30b3\u30b9\u30c8+\u8fbaab\u306e\u30b3\u30b9\u30c8\u304cb\u307e\u3067\u306e\u30b3\u30b9\u30c8\u3088\u308a\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\n            cost = d[a] + c\n            if cost < d[b]:\n                d[b] = cost\n                f = True\n        # \u66f4\u65b0\u304c\u7121\u3051\u308c\u3070break\n        if not f:\n            break\n    else:\n        # V\u56de\u76ee\u307e\u3067\u66f4\u65b0\u304c\u3042\u3063\u305f\u3089\u8ca0\u306e\u9589\u8def\u304c\u3042\u308b\n        print((-1))\n        return\n    print((max(-d[-1],0)))\n\ndef dfs(edge,s):\n    use={s}\n    q=[s]\n    while q:\n        v=q.pop()\n        for w in edge[v]:\n            if w in use:continue\n            use.add(w)\n            q.append(w)\n    return use\n\n\nl=[[] for i in range(n)]\nll=[[] for i in range(n)]\ne=[]\nfor i in range(m):\n    a,b,c=[int(j) for j in input().split()]\n    l[a-1].append(b-1)\n    ll[b-1].append(a-1)\n    e.append((a-1,b-1,p-c))\nuse=dfs(l,0)&dfs(ll,n-1)\ne=[(a,b,c) for a,b,c in e if (a in use and b in use)]\n\n\nbellman_ford(n, 0, e)\n", "from collections import deque\nimport math\n    \ndef dfs(edges, s):\n    stack = deque([s])\n    used  = {s}\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y not in used:\n                used.add(y)\n                stack.append(y)\n    return used\n\n\ndef bfs(edges, s):\n    queue = deque([s])\n    used  = {s}\n    while queue:\n        x = queue.popleft()\n        for y in edges[x]:\n            if y in used:\n                continue\n            used.add(y)\n            queue.append(y)\n    return used\n    \n\ndef bellman(dist):  #\u8ca0\u8fba\u304c\u3042\u308b\u30b1\u30fc\u30b9\u3067\u306e\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\u30a2\u30eb\u30b4\u3002\n    cost = [float(\"inf\")] * n\n    cost[0] = 0\n    for _ in range(n): #\u9802\u70b9\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n        updated = False\n        for u,v,c in dist: #\u8fba\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n            if cost[u] + c < cost[v]:\n                cost[v] = cost[u] + c\n                updated = True                \n    #\u53ce\u675f\u3057\u306a\u3044\u5834\u5408\u306f\u8ca0\u9589\u8def\u304c\u3042\u308b\u305f\u3081\u7121\u9650\u306b\u5c0f\u3055\u304f\u3067\u304d\u308b\u3002\n    if updated==True:\n        return -1\n    else:\n        return max(0, cost[n-1]*-1)    \n        \n\nn,m,p = map(int, input().split())\ndist  = []\nedge1 = [[] for _ in range(n)]\nedge2 = [[] for _ in range(n)]  # rev_edge\nfor _ in range(m):\n    u,v,c = map(int, input().split())\n    u -= 1\n    v -= 1\n    dist.append((u,v,(c-p)*-1))\n    edge1[u].append(v)\n    edge2[v].append(u)    \n    \nuse = bfs(edge1, 0) & bfs(edge2, n-1)\ndist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]\nprint(bellman(dist2))", "from collections import deque\nimport sys\n\n\nclass mEdge():\n\n    def __init__(self, _from, _to, _cost):\n        self.From = _from\n        self.to = _to\n        self.cost = _cost\n\n\nclass bellman_ford():\n    def __init__(self, V):\n        self.G = []\n        self._V = N\n        self._E = 0\n\n    def add(self, _from, _to, _cost):\n        self.G.append(mEdge(_from, _to, _cost))\n        self._E += 1\n\n    def shortest_path(self, s):\n        d = [10**20]*(self._V+1)\n        d[s] = 0\n        for _ in range(self._V):\n            flag = False\n            for edge in self.G:\n                newlen = d[edge.From]+edge.cost\n                if newlen < d[edge.to]:\n                    flag = True\n                    d[edge.to] = newlen\n            if not flag:\n                break\n        return d\n\n    def have_negative_circle(self):\n        d = [10**20]*(self._V+1)\n        d[1] = 0\n        for i in range(1, self._V+1):\n            flag = False\n            for edge in self.G:\n                newlen = d[edge.From]+edge.cost\n                if newlen < d[edge.to]:\n                    flag = True\n                    d[edge.to] = newlen\n            if not flag:\n                break\n            if i == self._V:\n                return True\n        return False\n\n\n# Coins Respawn\nsys.setrecursionlimit(10**7)\nN, M, P = map(int, input().split())\ngraph = []\nd = deque()\n\n\nfrom_1 = [[] for i in range(N+1)]\nfrom_N = [[] for i in range(N+1)]\n\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    from_1[a].append(b)\n    from_N[b].append(a)\n    d.append((a, b, P-c))\n\n\naccessible_1 = [False for i in range(N+1)]\naccessible_N = [False for i in range(N+1)]\n\n\ndef dfs_1(s):\n    accessible_1[s] = True\n    for node in from_1[s]:\n        if accessible_1[node] == False:\n            dfs_1(node)\n\n\ndef dfs_N(s):\n    accessible_N[s] = True\n    for node in from_N[s]:\n        if accessible_N[node] == False:\n            dfs_N(node)\n\n\ndfs_1(1)\ndfs_N(N)\n\nisok = [False for i in range(N+1)]\nfor i in range(N+1):\n    if accessible_1[i] and accessible_N[i]:\n        isok[i] = True\nG = bellman_ford(N)\n\nwhile d:\n    p, q, weight = d.popleft()\n    if isok[p] and isok[q]:\n        G.add(p, q, weight)\n\nif G.have_negative_circle():\n    print(-1)\nelse:\n\n    print(max(0, -G.shortest_path(1)[N]))", "import sys\nsys.setrecursionlimit(1000000000)\nii = lambda: int(input())\nmis = lambda: list(map(int, input().split()))\nlmis = lambda: list(mis())\n\ndef main():\n    N, M, P = mis()\n    \n    to = [[] for _ in range(N)]\n    ot = [[] for _ in range(N)]\n    edges = []\n\n    for i in range(M):\n        a,b,c = mis()\n        a -= 1\n        b -= 1\n        c = -(c-P)\n        #\n        to[a].append(b)\n        ot[b].append(a)\n        edges.append((a,b,c))\n\n    reachableFrom0 = set()\n    reachableToN = set()\n\n    # dfs\n    reachableFrom0.add(0)\n    nodes = [0]\n    while nodes:\n        node = nodes.pop()\n        for i in to[node]:\n            if i not in reachableFrom0:\n                nodes.append(i)\n                reachableFrom0.add(i)\n\n    #rdfs\n    reachableToN.add(N-1)\n    nodes = [N-1]\n    while nodes:\n        node = nodes.pop()\n        for i in ot[node]:\n            if i not in reachableToN:\n                nodes.append(i)\n                reachableToN.add(i)\n\n\n    ok = reachableFrom0 & reachableToN\n\n    edges = tuple((a, b, c) for a, b, c in edges if a in ok and b in ok)\n\n    V = [float('inf')] * N\n    V[0] = 0\n\n    def bf(n):\n        for _ in range(n):\n            upd = False\n            for a, b, c in edges:\n                if V[b] > V[a] + c:\n                    V[b] = V[a] + c\n                    upd = True\n            if not upd:\n                return False\n        return True\n\n    bf(N)\n\n    if not bf(1):\n        print((max(-V[-1], 0)))\n    else:\n        print((-1))\n\nmain()\n", "from scipy.sparse import csr_matrix, lil_matrix\nfrom scipy.sparse.csgraph import bellman_ford, NegativeCycleError\n\n\ndef main():\n    N, M, P = list(map(int, input().split()))\n    A, B, C = [0] * M, [0] * M, [0] * M\n    v = [set() for _ in range(N)]\n    u = [set() for _ in range(N)]\n    for i in range(M):\n        a, b, c = list(map(int, input().split()))\n        A[i], B[i], C[i] = a - 1, b - 1, P - c\n        u[a - 1].add(b - 1)\n        v[b - 1].add(a - 1)\n    vv = set()\n    cur = set([N - 1])\n    while cur:\n        vv |= cur\n        cur = set().union(*(v[c] for c in cur)) - vv\n    uu = set()\n    cur = set([0])\n    while cur:\n        uu |= cur\n        cur = set().union(*(u[c] for c in cur)) - uu\n    reachable = vv & uu\n    l = {}\n    for a, b, c in zip(A, B, C):\n        if a in reachable and b in reachable:\n            l[(a, b)] = min(c, l.get((a, b), 10 **9))\n    AA, BB, CC = [], [], []\n    for (a, b), c in list(l.items()):\n        AA.append(a)\n        BB.append(b)\n        CC.append(c)\n    mx = csr_matrix((CC, (AA, BB)), shape=(N, N))\n    try:\n        dm = bellman_ford(mx, indices=[0])\n    except NegativeCycleError:\n        return -1\n    return max(0, -int(dm[0][N - 1]))\n\n\nprint((main()))\n", "def main():\n    INF = float(\"inf\")\n\n    N, M, P, *ABC = list(map(int, open(0).read().split()))\n\n    F = [[] for _ in range(N)]\n    B = [[] for _ in range(N)]\n    E = [(a - 1, b - 1, P - c) for a, b, c in zip(*[iter(ABC)] * 3)]\n\n    for a, b, c in E:\n        F[a].append(b)\n        B[b].append(a)\n\n    S = {0}\n    stack = [0]\n    while stack:\n        s = stack.pop()\n        for v in F[s]:\n            if v not in S:\n                stack.append(v)\n                S.add(v)\n\n    T = {N - 1}\n    stack = [N - 1]\n    while stack:\n        s = stack.pop()\n        for v in B[s]:\n            if v not in T:\n                stack.append(v)\n                T.add(v)\n\n    ok = S & T\n\n    E = [(a, b, c) for a, b, c in E if a in ok and b in ok]\n\n    D = [INF] * N\n    D[0] = 0\n\n    def bellman_ford(N):\n        for _ in range(N):\n            update = False\n            for a, b, c in E:\n                if D[b] > D[a] + c:\n                    D[b] = D[a] + c\n                    update = True\n            if not update:\n                return False\n        return True\n\n    bellman_ford(N)\n\n    print((-1 if bellman_ford(1) else max(-D[-1], 0)))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\ndef use_path(n,start,es):\n    q = deque()\n    chk = [False] * n\n    q.append(start)\n    chk[start] = True\n    used = {start}\n    while len(q) > 0:\n        node = q.popleft()\n        for nex in es[node]:\n            if not chk[nex]:\n                chk[nex] = True\n                q.append(nex)\n                used.add(nex)\n    return used\n  \ndef belman(s,g,n,es):\n    d = [10**10] * n\n    d[s] = 0\n    fin = False\n    cnt = 0\n    while True:\n      update = False\n      for p,q,r in es:\n        if d[p] != 10**10 and d[q] > d[p] + r:\n          d[q] = d[p] + r\n          update = True\n      cnt += 1\n      if not update:\n        fin = True\n        break\n      if cnt > n+1:\n          break      \n    if fin:\n        return max(0,-d[g])\n    else:\n        return -1   \n  \nn,m,p = list(map(int, input().split()))\n\nl = [[] for i in range(n)]\nr = [[] for i in range(n)]\nedges = []\n\nfor i in range(m):\n    a,b,c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    l[a].append(b)\n    r[b].append(a)\n    edges.append((a,b,-c+p))\n    \nuse_nodes = use_path(n,0,l) & use_path(n,n-1,r)\nes = [(a,b,c) for a,b,c in edges if a in use_nodes and b in use_nodes]\nprint((belman(0,n-1,n,es)))\n", "from collections import deque\nimport math\n\nn,m,p = map(int, input().split())\ndist  = []\nedge1 = [[] for _ in range(n)]\nedge2 = [[] for _ in range(n)]  # rev_edge\nfor _ in range(m):\n    u,v,c = map(int, input().split())\n    u -= 1\n    v -= 1\n    dist.append((u,v,(c-p)*-1))\n    edge1[u].append(v)\n    edge2[v].append(u)   \n\ndef dfs(edges, s):\n    stack = deque([s])\n    used  = {s}\n    while stack:\n        x = stack.pop()\n        for y in edges[x]:\n            if y not in used:\n                used.add(y)\n                stack.append(y)\n    return used\n\n\ndef bfs(edges, s):\n    queue = deque([s])\n    used  = {s}\n    while queue:\n        x = queue.popleft()\n        for y in edges[x]:\n            if y in used:\n                continue\n            used.add(y)\n            queue.append(y)\n    return used\n    \n\ndef bellman(dist):  #\u8ca0\u8fba\u304c\u3042\u308b\u30b1\u30fc\u30b9\u3067\u306e\u3001\u30b9\u30bf\u30fc\u30c8\u304b\u3089\u30b4\u30fc\u30eb\u3078\u306e\u6700\u77ed\u8def\u3092\u6c42\u3081\u308b\u30a2\u30eb\u30b4\u3002\n    cost = [float(\"inf\")] * n\n    cost[0] = 0\n    for _ in range(n): #\u9802\u70b9\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n        updated = False\n        for u,v,c in dist: #\u8fba\u306e\u500b\u6570\u306e\u5206\u3060\u3051\u56de\u308b\n            if cost[u] + c < cost[v]:\n                cost[v] = cost[u] + c\n                updated = True                \n    #\u53ce\u675f\u3057\u306a\u3044\u5834\u5408\u306f\u8ca0\u9589\u8def\u304c\u3042\u308b\u305f\u3081\u7121\u9650\u306b\u5c0f\u3055\u304f\u3067\u304d\u308b\u3002\n    if updated==True:\n        return -1\n    else:\n        return max(0, cost[n-1]*-1)     \n    \nuse = bfs(edge1, 0) & bfs(edge2, n-1)\ndist2 = [(a,b,c) for a,b,c in dist if a in use and b in use]\nprint(bellman(dist2))", "# https://atcoder.jp/contests/abc137/tasks/abc137_e\nimport sys\nfrom collections import deque\n\nread = sys.stdin.read\nINF = 1 << 60\n\n\ndef main():\n    N, M, P, *ABC = list(map(int, read().split()))\n\n    G = [[] for _ in range(N)]\n    G_rev = [[] for _ in range(N)]\n    edge = []\n    for a, b, c in zip(*[iter(ABC)] * 3):\n        a -= 1\n        b -= 1\n        c = P - c\n        G[a].append(b)\n        G_rev[b].append(a)\n        edge.append((a, b, c))\n\n    # Only consider nodes that can be reached from 1 and can reach N.\n    reachable_1 = [False] * N\n    reachable_N = [False] * N\n\n    reachable_1[0] = True\n    reachable_N[N - 1] = True\n\n    queue = deque([0])\n    while queue:\n        v = queue.popleft()\n        for nv in G[v]:\n            if not reachable_1[nv]:\n                reachable_1[nv] = True\n                queue.append(nv)\n\n    queue = deque([N - 1])\n    while queue:\n        v = queue.popleft()\n        for nv in G_rev[v]:\n            if not reachable_N[nv]:\n                reachable_N[nv] = True\n                queue.append(nv)\n\n    ok = [reachable_1[i] and reachable_N[i] for i in range(N)]\n\n    dist = [INF] * N\n    dist[0] = 0\n\n    for i in range(N):\n        for a, b, c in edge:\n            if not ok[a] or not ok[b]:\n                continue\n            if dist[b] > dist[a] + c:\n                if i < N - 1:\n                    dist[b] = dist[a] + c\n                else:\n                    print((-1))\n                    return\n\n    score = -dist[N - 1]\n    print((max(score, 0)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import deque\n\n    \ndef dfs(x,s):\n    used = {s}\n    search = deque([s])\n    while search:\n        ss = search.pop()\n        for sss in x[ss]:\n            if sss in used:\n                continue\n            used.add(sss)\n            search.append(sss)\n    return used\n\n\ndef bellmanford(edges):\n    coins = [-float(\"inf\")] * N\n    coins[0] = 0\n    for _ in range(N):\n        f = True\n        for u,v,c in edges:\n            if coins[u] + c > coins[v]:\n                coins[v] = coins[u] + c\n                f = False\n        if f:\n            return max(0, coins[-1])\n    return -1\n\nN,M,P = map(int, input().split())\nABC = []\nAdake = [[] for _ in range(N)]\nBdake = [[] for _ in range(N)]\nfor _ in range(M):\n    A,B,C = map(int, input().split())\n    ABC.append((A-1,B-1,C-P))\n    Adake[A-1].append(B-1)\n    Bdake[B-1].append(A-1)\n\nU = dfs(Adake,0) & dfs(Bdake,N-1)\nABC = [(a,b,c) for (a,b,c) in ABC if a in U and b in U]\n\nprint(bellmanford(ABC))", "def BF(v, start, edges):\n    INF = 10**18\n    nega = False\n    d = [INF] * v\n    d[start] = 0\n    for _ in range(v):\n        f = False\n        for a, b, c in edges:\n            cost = d[a] + c\n            if cost < d[b]:\n                d[b] = cost\n                f = True\n        if not f:\n            break\n    else:\n        nega = True\n    return d, nega\n\nfrom collections import deque\ndef BFS(N, graph, start):\n    d = [-1 for i in range(N)]\n    Q = deque([])\n    Q.append(start)\n    d[start] = 0\n    while Q:\n        v = Q.popleft()\n        for u in graph[v]:\n            if d[u] == -1:\n                d[u] = d[v] + 1\n                Q.append(u)\n    return d\n\nN, M, P = (int(i) for i in input().split())\ngraph = [[] for i in range(N)]\ngraphr = [[] for i in range(N)]\nedges = []\nfor i in range(M):\n    A, B, C = (int(i) for i in input().split())\n    graph[A-1].append(B-1)\n    graphr[B-1].append(A-1)\n    edges.append((A-1, B-1, P-C))\nd_start = BFS(N, graph, 0)\nd_end = BFS(N, graphr, N-1)\nnodes_start = [i for i in range(N) if d_start[i] >= 0]\nnodes_end = [i for i in range(N) if d_end[i] >= 0]\nnew_edges = []\nfor A, B, C in edges:\n    if A in nodes_start and B in nodes_start and A in nodes_end and B in nodes_end:\n        new_edges.append((A, B, C))\nd, Nega = BF(N, 0, new_edges)\nif Nega == True:\n    print(-1)\nelse:\n    print(max(-d[N-1], 0))", "from scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import bellman_ford, NegativeCycleError\n\n\ndef reachable_nodes(s, edges):\n    cur = {s}\n    reachable = set()\n    while cur:\n        reachable |= cur\n        cur = set().union(*(edges[node] for node in cur)) - reachable\n    return reachable\n\n\ndef solve():\n    N, M, P = list(map(int, input().split()))\n    A, B, C = [0] * M, [0] * M, [0] * M\n    to = [[] for _ in range(N)]\n    reverse_to = [[] for _ in range(N)]\n    for i in range(M):\n        a, b, c = list(map(int, input().split()))\n        A[i], B[i], C[i] = a - 1, b - 1, P - c\n        to[a - 1].append(b - 1)\n        reverse_to[b - 1].append(a - 1)\n    \n    reachable = reachable_nodes(0, to) & reachable_nodes(N - 1, reverse_to)\n    \n    edge_dict = dict()\n    for a, b, c in zip(A, B, C):\n        if a in reachable and b in reachable:\n            edge_dict[(a, b)] = min(c, edge_dict.get((a, b), 10 ** 6))\n    AA, BB, CC = [], [], []\n    for (a, b), c in list(edge_dict.items()):\n        AA.append(a)\n        BB.append(b)\n        CC.append(c)\n    \n    graph = csr_matrix((CC, (AA, BB)), shape=(N, N))\n    try:\n        bf = bellman_ford(graph, indices=[0])\n        print((max(0, -int(bf[0][N - 1]))))\n    except NegativeCycleError:\n        print((-1))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "#\u5165\u529b\u9ad8\u901f\u5316 + \u518d\u5e30\u56de\u6570\u5236\u9650\u89e3\u9664\nimport sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10000000)\n\n#\u8ca0\u306e\u9589\u8def\u691c\u51fa\n#n=\u9802\u70b9\u6570 e=[[a,b,c],[]...](a~b\u306e\u8ddd\u96e2\u304cc)\ndef find_negative_loop(n,e):\n  d=n*[10**20];d[0]=0\n  for h in range(n):\n    for i,j,k in e:\n      if d[j]>d[i]+k:\n        d[j]=d[i]+k\n        if h==n-1:return -1\n  return max(-d[n-1],0)\n\n#DAG\u5224\u5b9a\n#n=\u9802\u70b9\u6570 e=\u96a3\u63a5\u30ea\u30b9\u30c8\n#flag=0...DAG\u5224\u5b9a\u3000flag=1...\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\nfrom collections import deque\ndef find_loop(n,e,flag):\n  x=[0]*n\n  d=deque()\n  t=[]\n  c=0\n  for i in range(n):\n    for j in e[i]:x[j]+=1\n  for i in range(n):\n    if x[i]==0:\n      d.append(i)\n      t.append(i)\n      c+=1\n  while d:\n    i=d.popleft()\n    for j in e[i]:\n      x[j]-=1\n      if x[j]==0:\n        d.append(j)\n        t.append(j)\n        c+=1\n  if flag==0:return c==n\n  else:return t\n\nn,m,p=map(int,input().split())\nef=[[]for _ in range(n)]\nee=[[]for _ in range(n)]\nedge=[[]for _ in range(n)]\ne=[]\nfor _ in range(m):\n  a,b,c=map(int,input().split())\n  a-=1\n  b-=1\n  c-=p\n  ef[a].append(b)\n  ee[b].append(a)\n  edge[a].append((b,c))\n  e.append((a,b,c))\neff=[0]*n\neff[0]=1\nQ=[0]\nvisited={0}\nwhile Q:\n  P=[]\n  for i in Q:\n    for j in ef[i]:\n      if j in visited:continue\n      visited.add(j)\n      eff[j]=1\n      P.append(j)\n  Q=P\neef=[0]*n\neef[n-1]=1\nQ=[n-1]\nvisited={n-1}\nwhile Q:\n  P=[]\n  for i in Q:\n    for j in ee[i]:\n      if j in visited:continue\n      visited.add(j)\n      eef[j]=1\n      P.append(j)\n  Q=P\nee=[]\nfor a,b,c in e:\n  if eff[a]==1 and eef[a]==1 and eff[b]==1 and eef[b]==1:\n    ee.append((a,b,-c))\nprint(find_negative_loop(n,ee))", "N,M,P = list(map(int,input().split()))\nabc = []\nedge = [[] for _ in range(N)]\nfor _ in range(M):\n    a,b,c = list(map(int,input().split()))\n    #\u5411\u304b\u3063\u3066\u304f\u308b\u77e2\u5370\n    edge[b-1].append(a-1)\n    abc.append((a-1,b-1,P-c))\n\ndef dfs(edge,goal):\n    #goal = n-1\n    used = {goal}\n    q = [goal]\n    while q:\n        v = q.pop()\n        for w in edge[v]:\n            if w in used:continue\n            used.add(w)\n            q.append(w)\n    \n    return used\n\ndef bellman_ford(v,s,g,e):\n\n    '''\n    v: vertex(\u9802\u70b9)\n    s: start.  in this case,0\n    g: goal. in this case,n-1\n    e: (edge_start,egde_goal,score)\n    \u4eca\u56de\u306fp-c\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u3066\u3044\u304f.\n    '''\n    inf = 10**10\n    # cost : d[V] \n    d = [inf] * v\n    #\u958b\u59cb\u70b9\u306e\u30b3\u30b9\u30c8\u30920\u3068\u3059\u308b\n    d[s] = 0\n    for _ in range(v):\n        flag = False\n        for a,b,c in e:\n            # a -> b \u306e\u5411\u304d\u3092\u8003\u3048\u308b\n            if d[a] == inf:continue\n            cost = d[a] + c\n            if cost < d[b]:\n                d[b] = cost\n                flag = True\n        if not flag: break\n    if flag:\n        return -1\n    return max(-d[g],0)\n\nvertex = dfs(edge,N-1)\nabc_ = [(a,b,c) for a,b,c in abc if a in vertex and b in vertex]\nprint((bellman_ford(N,0,N-1,abc_)))\n", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\n\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    a,b = LI()\n    print((max(a+b,a-b,a*b)))\n    return\n\n#B\ndef B():\n    k,x = LI()\n    ans = []\n    for i in range(x-k+1,x+k):\n        ans.append(i)\n    print((*ans))\n    return\n\n#C\ndef C():\n    def f(s):\n        res = [0]*m\n        for i in s:\n            res[alp.index(i)] += 1\n        return res\n    alp = list(\"abcdefghijklmnopqrstuvwxyz\")\n    m = len(alp)\n    n = I()\n    s = [input() for i in range(n)]\n    d = defaultdict(lambda : 0)\n    for i in s:\n        d[tuple(f(i))] += 1\n    ans = 0\n    for i in list(d.values()):\n        ans += (i*(i-1))//2\n    print(ans)\n    return\n\n#D\ndef D():\n    n,m = LI()\n    g = LIR(n)\n    g.sort(key = lambda x:x[0])\n    ans = 0\n    f = [1]*n\n    j = 0\n    q = []\n    for i in range(m)[::-1]:\n        while j < n and m-g[j][0] >= i:\n            a,b = g[j]\n            heappush(q,(-b,a))\n            j += 1\n        if q:\n            x,a = heappop(q)\n            if i+a <= m:\n                ans -= x\n    print(ans)\n    return\n\n#E\ndef E():\n    def dfs(x,f):\n        for y,w in v[x]:\n            if f[y]:\n                if dp[y] < dp[x]+w:\n                    f[y] = 0\n                    dp[y] = dp[x]+w\n                    dfs(y,f)\n                    f[y] = 1\n            else:\n                if dp[y] < dp[x]+w:\n                    dp[y] = float(\"inf\")\n                    dfs(y,f)\n    n,m,p = LI()\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = LI()\n        a -= 1\n        b -= 1\n        v[a].append((b,c-p))\n    f = [1]*n\n    dp = [-float(\"inf\")]*n\n    dp[0] = 0\n    f[0] = 0\n    dfs(0,f)\n    ans = dp[n-1]\n    if ans == float(\"inf\") or ans == -float(\"inf\"):\n        print((-1))\n    elif ans < 0:\n        print((0))\n    else:\n        print(ans)\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\ndef __starting_point():\n    E()\n\n__starting_point()"]
["#!/usr/bin/env python3\nfrom itertools import accumulate\nfrom heapq import heappop, heappush\n\n\ndef top(ppl_indices, vals, start):\n    Q = []\n    res = [0 for i in range(len(ppl_indices))]\n    for k, idx in enumerate(ppl_indices):\n        heappush(Q, -vals[idx])\n        if k >= start:\n            res[k] = res[k-1] - heappop(Q)\n\n    return res\n\n\nn, a_size, b_size = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nconversion_gain = [y - x for x, y in zip(a, b)]\n\nordered_by_a = sorted(zip(a, list(range(n))), reverse=True)\nprefix_sums_a = list(accumulate([x for x, y in ordered_by_a]))\nconversions = top([idx for val, idx in ordered_by_a], conversion_gain, a_size)\nrest_of_bs = list(reversed(top([idx for val, idx in reversed(ordered_by_a[a_size:])],\n                               b, n - a_size - b_size))) + [0]\n\nsol, top_k = max([(prefix_a + convert + add_bs, idx)\n                  for idx, (prefix_a, convert, add_bs)\n                  in enumerate(zip(prefix_sums_a[a_size-1:a_size+b_size],\n                                   conversions[a_size-1:a_size+b_size],\n                                   rest_of_bs))])\ntop_k += a_size\n\nconversion_ordered_by_a = [(conversion_gain[idx], idx) for val, idx in ordered_by_a]\nconversion_sorted = sorted(conversion_ordered_by_a[:top_k], reverse=True)\nconverted = [idx for val, idx in conversion_sorted[:top_k-a_size]]\nteam_a = list(set(idx for val, idx in ordered_by_a[:top_k]) - set(converted))\n\nb_ordered_by_a = [(b[idx], idx) for val, idx in ordered_by_a]\nb_sorted = sorted(b_ordered_by_a[top_k:], reverse=True)\nteam_b = converted + [idx for val, idx in b_sorted[:(a_size+b_size) - top_k]]\n\nprint(sol)\nprint(\" \".join(str(idx+1) for idx in team_a))\nprint(\" \".join(str(idx+1) for idx in team_b))\n"]
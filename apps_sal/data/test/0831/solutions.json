["class Edge:\n    def __init__(self, to, cost, capacity, next_edge):\n        self.to = to\n        self.cost = cost\n        self.origin_cost = cost\n        self.capacity = capacity\n        self.next_edge = next_edge\n        self.pair = None\n\n\nclass MinCostMaxFlow:\n    def __init__(self, max_node):\n        self.null = Edge(0, 0, 0, None)\n        self.max_node = max_node + 3\n        self.total_cost = 0\n        self.current_cost = 0\n        self.visited = [False] * self.max_node\n        self.arc_list = []\n        self.edge_head = [self.null] * self.max_node\n        self.source = max_node + 1\n        self.sink = max_node + 2\n\n    def AddArcWithCapacityAndUnitCost(self, start_node, end_node, capacity, cost):\n        self.edge_head[start_node] = Edge(end_node, cost, capacity, self.edge_head[start_node])\n        self.edge_head[end_node] = Edge(start_node, -cost, 0, self.edge_head[end_node])\n        self.edge_head[start_node].pair = self.edge_head[end_node]\n        self.edge_head[end_node].pair = self.edge_head[start_node]\n        if start_node != self.source and start_node != self.sink and end_node != self.source and end_node != self.sink:\n            self.arc_list.append(self.edge_head[end_node])\n\n    def NumArcs(self):\n        return len(self.arc_list)\n\n    def Tail(self, index):\n        return self.arc_list[index].to\n\n    def Head(self, index):\n        return self.arc_list[index].pair.to\n\n    def UnitCost(self, index):\n        return self.arc_list[index].pair.origin_cost\n\n    def Flow(self, index):\n        return self.arc_list[index].capacity\n\n    def OptimalFlow(self):\n        edge = self.edge_head[self.sink]\n        total_flow = 0\n        while id(edge) != id(self.null):\n            total_flow += edge.capacity\n            edge = edge.next_edge\n        return total_flow\n\n    def OptimalCost(self):\n        return self.total_cost\n\n    def SetNodeSupply(self, node, supply):\n        if supply > 0:\n            self.AddArcWithCapacityAndUnitCost(self.source, node, supply, 0)\n        elif supply < 0:\n            self.AddArcWithCapacityAndUnitCost(node, self.sink, -supply, 0)\n\n    def aug(self, node_id, total_flow):\n        if node_id == self.sink:\n            self.total_cost += self.current_cost * total_flow\n            return total_flow\n        self.visited[node_id] = True\n        flow = total_flow\n        edge = self.edge_head[node_id]\n        while id(edge) != id(self.null):\n            if edge.capacity > 0 and edge.cost == 0 and not self.visited[edge.to]:\n                delta = self.aug(edge.to, min(flow, edge.capacity))\n                edge.capacity -= delta\n                edge.pair.capacity += delta\n                flow -= delta\n                if flow == 0:\n                    return total_flow\n            edge = edge.next_edge\n        return total_flow - flow\n\n    def modify_label(self):\n        min_cost = 1 << 63\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                if edge.capacity > 0 and not self.visited[edge.to] and edge.cost < min_cost:\n                    min_cost = edge.cost\n                edge = edge.next_edge\n        if min_cost == 1 << 63:\n            return False\n        for node_id in range(0, self.max_node):\n            if not self.visited[node_id]:\n                continue\n            edge = self.edge_head[node_id]\n            while id(edge) != id(self.null):\n                edge.cost -= min_cost\n                edge.pair.cost += min_cost\n                edge = edge.next_edge\n        self.current_cost += min_cost\n        return True\n\n    def Solve(self):\n        while True:\n            while True:\n                self.visited = [False] * self.max_node\n                if self.aug(self.source, 1 << 63) == 0:\n                    break\n            if not self.modify_label():\n                break\n        return self.total_cost\n\n\ndef main():\n    s = input()\n    n = int(input())\n    source = 0\n    sink = n + 26 + 1\n    mcmf = MinCostMaxFlow(n + 28)\n    length = len(s)\n    num = [0] * 29\n    for i in range(0, length):\n        num[ord(s[i]) - ord('a') + 1] += 1\n    for i in range(1, 27):\n        if num[i] > 0:\n            mcmf.AddArcWithCapacityAndUnitCost(i, sink, num[i], 0)\n    for i in range(1, n + 1):\n        s, used = input().split(' ')\n        mcmf.AddArcWithCapacityAndUnitCost(source, 26 + i, int(used), 0)\n        num = [0] * 29\n        for j in range(0, len(s)):\n            num[ord(s[j]) - ord('a') + 1] += 1\n        for j in range(1, 27):\n            if num[j] > 0:\n                mcmf.AddArcWithCapacityAndUnitCost(26 + i, j, num[j], i)\n    mcmf.SetNodeSupply(source, 1 << 63)\n    mcmf.SetNodeSupply(sink, -(1 << 63))\n    mcmf.Solve()\n    if mcmf.OptimalFlow() != length:\n        print(\"-1\")\n    else:\n        print(mcmf.OptimalCost())\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v; prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\nT = input()\nneed = [0] * 30\nfor t in T:\n    need[ord(t) - ord('a')] += 1\nhave = [[0] * 30 for _ in range(110)]\nN = int(input())\na = [0] * 110\n\nfor i in range(N):\n    v = input().split()\n    S = v[0]\n    a[i] = int(v[1])\n    for s in S:\n        have[i][ord(s)-ord('a')] += 1\n\nV = 30 + N + 10\nflow = MinCostFlow(V)\n\nstart = 30 + N + 5\ntarget = 30 + N + 6\nfor c in range(26):\n    flow.add_edge(start, c, need[c], 0)\n    for j in range(N):\n        flow.add_edge(c, 30+j, have[j][c], 0)\n\nfor i in range(N):\n    flow.add_edge(30+i, target, a[i], i+1)\n\nans = flow.flow(start, target, len(T))\nprint(ans)"]
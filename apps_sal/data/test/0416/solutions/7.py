# from Crypto.Util.number import *
# from Crypto.PublicKey import RSA
# from Crypto.Cipher import PKCS1_OAEP
#
#
# def gcd(a, b):
#     if a == 0:
#         return b, 0, 1
#     d, x1, y1 = gcd(b % a, a)
#     x = y1 - (b // a) * x1
#     y = x1
#     return d, x, y
#
#
# def find_private_key(p, q, e):
#     f = (p - 1) * (q - 1)
#     d = gcd(e, f)[1]
#     while d < 0:
#         d += f
#     return d
#
#
# n = 114603416258617277914112950886933842277017613048768896986887063295795075651032133331342538430388087616693581335924733790772692053706860660493046367184589390096319068611843480381499933909451620838321468620579057390519217231379164202675046840772638142625114303262708400933811096588213415014292281310788830121449
#
# q = 8931970881300680082796820734365022222452747937209215859340339248013322229502496422895802649243487560690551112016430906973314030768362034269763079075131391
#
# p = 12830697477814509540399242283518279629025340392811455061638565349197540239841408191167449256086467748949090279070442786996339222196995600246150833643209239
#
# e = 78078409585916972042386784533013985111341440946219174025831418904974306682701
#
# f = 114603416258617277914112950886933842277017613048768896986887063295795075651032133331342538430388087616693581335924733790772692053706860660493046367184589368333650709496653857185436916026149769360233138599908136411614620020516694858770432777520732812669804663621317314060117126934960449656657765396876111780820
#
# d = 95617909040393155444786936446642179824041050920013801086828472351343249663960737590719979187458429568264589317317553181803837347371438624774016758221657991995265788792118497392951947899512373618098318332328397239065334523447713343639400315086378757038001615086063906730779984567240713176171007926923058722581
#
# rsa = RSA.construct((n, e, d))
#
#
# #key = RSA.importKey(open('11.txt', 'r').read())
# key = RSA.importKey(open('public_key', 'r').read())
#
# print(key.__dict__)
#
# n = 5629218730419894595823026663331501597897818160771697280840122531313799328035654852733468829411876184951508514832506002593002170978628016095067716010208905588870963783855109137307480667920058731486899983319164243850148229252772614367640165351224879369373847162133237931086116505957707781534245331485441
# p = 2372597464893675257469711937093671629348264195072192501684944517176070474701064022851367306150417447503454422147341366642712704243329694637078892947639
# q = n // p
# e = 17
#
# d = find_private_key(p, q, e)
#
# encrypted = 1111861507760457047964156325933048837925622938918416900082721305322555941153755195985545404321101492441045781915244282849548935206776118071569007445626459132036648013508921232096378109573160336245447392600788211167388900011173139344891307651852665571685713133157519571136012382352182349879574471249590
# result = pow(encrypted, d, n)
#
# result = hex(result)[2:]
#
# ans = b''
# for i in range(0, len(result), 2):
#     ans += bytes([int(result[i:i+2], 16)])
#
# print(ans)
#
# return
#
# key = RSA.construct((n, e, d))
#
# with open('22.txt', 'wb') as fi:
#     fi.write(key.exportKey('PEM'))
#
# print('d =', d)





# import time
# import requests
#
# url = 'http://sql.training.hackerdom.ru/10lastlevel.php?text='
# condition = 'ORD(SUBSTRING(COLUMN_NAME, {}, 1)) = {}'
# query = "IF(ORD(SUBSTRING(chocolate, {}, 1)) = {}, SLEEP(1), 1) FROM davidblayne;"
# pos = 1
# sleep_time = 1
# a = {''}
#
# s = ''
# for i in range(1, 30):
#     for c in range(32, 128):
#         start = time.time()
#         requests.get(url + query.format(i, c))
#         end = time.time()
#
#         d = end - start
#
#         if d >= sleep_time:
#             print(chr(c))
#             s += chr(c)
#             break
#     else:
#         break
#
# print(s)

def calc(s):
    max_len = 0
    cur_len = 0
    for i in range(len(s)):
        if s[i] == 'N':
            cur_len += 1
        else:
            cur_len = 0
        max_len = max(max_len, cur_len)
    return max_len


n, k = list(map(int, input().split()))
s = input()

if calc(s) > k:
    print('NO')
    return

start = 0
while start + k - 1 < len(s):
    good = True
    for i in range(start, start + k):
        if s[i] == 'Y':
            good = False
            break
    if start - 1 >= 0 and s[start - 1] == 'N':
        good = False
    if start + k < len(s) and s[start + k] == 'N':
        good = False
    if good:
        print('YES')
        return
    start += 1

print('NO')


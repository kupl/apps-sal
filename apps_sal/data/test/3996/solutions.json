["3\n\nclass Matrix:\n    def __init__(self, n, m, arr=None):\n        self.n = n\n        self.m = m\n        self.arr = [[0] * m for i in range(n)]\n        if arr is not None:\n            for i in range(n):\n                for j in range(m):\n                    self.arr[i][j] = arr[i][j]\n\n    def __mul__(self, other):\n        assert self.m == other.n\n        ans = Matrix(self.n, other.m)\n        for i in range(self.n):\n            for j in range(other.m):\n                for k in range(self.m):\n                    ans.arr[i][j] = (ans.arr[i][j] + self.arr[i][k] * other.arr[k][j]) % (10 ** 9 + 7)\n        return ans\n\n    def __imul__(self, other):\n        self = self * other\n        return self\n\n    def __pow__(self, n):\n        if n == 0:\n            ans = Matrix(self.n, self.n)\n            for i in range(self.n):\n                ans.arr[i][i] = 1\n            return ans\n        elif n & 1 == 1:\n            return self * (self ** (n - 1))\n        else:\n            t = self ** (n >> 1)\n            return t * t\n\n    def __ipow__(self, n):\n        self = self ** n\n        return self\n\n    def __eq__(self, other):\n        if self.n != other.n or self.m != other.m:\n            return False\n        for i in range(self.n):\n            for j in range(self.m):\n                if self.arr[i][j] != other.arr[i][j]:\n                    return False\n        return True\n\n\ndef fpow(a, n):\n    if n == 0:\n        return 1\n    elif n & 1 == 1:\n        return (a * fpow(a, n - 1)) % (10 ** 9 + 7)\n    else:\n        t = fpow(a, n >> 1)\n        return (t * t) % (10 ** 9 + 7)\n\n\ntransform = Matrix(2, 2, [[1, 1], [0, 4]])\nmtx = transform\n\nk = int(input())\na = list(map(int, input().split()))\n\"\"\"\nf = False\nfor j in a:\n    if j % 2 == 0:\n        f = True\n        break\nif f:\n    print(a)\n    tp = 1\n    for j in a:\n        if f and j % 2 == 0:\n            j //= 2\n            f = False\n        print(j)\n        mtx **= j\n    ans = Matrix(2, 1, [[0], [1]])\n    ans = mtx * ans\n    print(ans.arr)\n    print(\"%d/%d\" % (ans.arr[0][0], ans.arr[1][0]))\n\"\"\"\n\nx = 1\nfor j in a:\n    x = (x * j) % (10 ** 9 + 6)\n\nx = (x - 1) % (10 ** 9 + 6)\n\nif x % 2 == 0:\n    ans = (transform ** (x // 2)) * Matrix(2, 1, [[0], [1]])\n    print(\"%d/%d\" % (ans.arr[0][0], fpow(2, x)))\nelse:\n    y = (x - 1) % (10 ** 9 + 6)\n    ans = (transform ** (y // 2)) * Matrix(2, 1, [[0], [1]])\n    print(\"%d/%d\" % ((ans.arr[0][0] * 2 + 1) % (10 ** 9 + 7), (ans.arr[1][0] * 2) % (10 ** 9 + 7)))\n    \n", "mod = 1000000007\n_ = input()\nnumbers = list(map(int,input().split()))\nb = 2\nflag = 1 if len(list([x for x in numbers if x%2 == 0])) else -1\nfor num in numbers:\n    b = pow(b,num,mod)\n\nb = b*pow(2,mod-2,mod)%mod # b = 2^n-1\na = (b+flag)*pow(3,mod-2,mod)%mod #a = (2^n-1 -/+ 1) / 3\nprint(\"%d/%d\"%(a,b))\n\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnumbers = list(map(int,input().split()))\nflag = 1 if len(list([x for x in numbers if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),numbers,2)\nb = b*pow(2,mod-2,mod)%mod # b = 2^n-1\na = (b+flag)*pow(3,mod-2,mod)%mod #a = (2^n-1 -/+ 1) / 3\nprint(\"%d/%d\"%(a,b))\n\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list([x for x in num if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod # b = 2^n-1\na = (b+flag)*pow(3,mod-2,mod)%mod #a = (2^n-1 -/+ 1) / 3\nprint(\"%d/%d\"%(a,b))\n\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list([x for x in num if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod\na = (b+flag)*pow(3,mod-2,mod)%mod\nprint(\"%d/%d\"%(a,b))\n\n\n", "k = int(input())\nn = list(map(int, input().split()))\n\nfor i in range(k):\n    n[i] = bin(n[i])\n    n[i] = n[i][2:]\n    \nmagic = 1000000007\n\ndef par(s):\n    if s[-1] == '0':\n        return True\n    else:\n        return False\n\ndef mod_pow(x, s, p):\n    ans = 1\n    for i in range(len(s)):\n        if s[i] == '1':\n            ans = (((ans * ans) % p) * x) % p\n        else:\n            ans = (ans * ans) % p\n    return ans\n\ndef div_in_field(a, b, p):\n    b_op = pow(b, p - 2, p)\n    return (b_op * a) % p\n\n\ndenominator = 2\nn_par = False\nfor i in range(len(n)):\n    denominator = mod_pow(denominator, n[i], magic)\n    if par(n[i]):\n        n_par = True\n\ndenominator = div_in_field(denominator, 2, magic)\nnumerator = 0\nif n_par:\n    numerator = div_in_field(1 + denominator, 3, magic)\nelse:\n    numerator = div_in_field(-1 + denominator, 3, magic)\nans = str(numerator) + '/' + str(denominator)\nprint(ans)\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list([x for x in num if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod\na = (b+flag)*pow(3,mod-2,mod)%mod\nprint(\"%d/%d\"%(a,b))\n", "class Matrix:\n    def __init__(self, n, m, arr=None):\n        self.n = n\n        self.m = m\n        self.arr = [[0] * m for i in range(n)]\n        if arr is not None:\n            for i in range(n):\n                for j in range(m):\n                    self.arr[i][j] = arr[i][j]\n    def __mul__(self, other):\n        assert self.m == other.n\n        ans = Matrix(self.n, other.m)\n        for i in range(self.n):\n            for j in range(other.m):\n                for k in range(self.m):\n                    ans.arr[i][j] = (ans.arr[i][j] + self.arr[i][k] * other.arr[k][j]) % (10 ** 9 + 7)\n        return ans\n    def __imul__(self, other):\n        self = self * other\n        return self\n    def __pow__(self, n):\n        if n == 0:\n            ans = Matrix(self.n, self.n)\n            for i in range(self.n):\n                ans.arr[i][i] = 1\n            return ans\n        elif n & 1 == 1:\n            return self * (self ** (n - 1))\n        else:\n            t = self ** (n >> 1)\n            return t * t\n    def __ipow__(self, n):\n        self = self ** n\n        return self\n    def __eq__(self, other):\n        if self.n != other.n or self.m != other.m:\n            return False\n        for i in range(self.n):\n            for j in range(self.m):\n                if self.arr[i][j] != other.arr[i][j]:\n                    return False\n        return True\ndef fpow(a, n):\n    if n == 0:\n        return 1\n    elif n & 1 == 1:\n        return (a * fpow(a, n - 1)) % (10 ** 9 + 7)\n    else:\n        t = fpow(a, n >> 1)\n        return (t * t) % (10 ** 9 + 7)\ntransform = Matrix(2, 2, [[1, 1], [0, 4]])\nmtx = transform\nk = int(input())\na = list(map(int, input().split()))\nx = 1\nfor j in a:\n    x = (x * j) % (10 ** 9 + 6)\nx = (x - 1) % (10 ** 9 + 6)\nif x % 2 == 0:\n    ans = (transform ** (x // 2)) * Matrix(2, 1, [[0], [1]])\n    print(\"%d/%d\" % (ans.arr[0][0], fpow(2, x)))\nelse:\n    y = (x - 1) % (10 ** 9 + 6)\n    ans = (transform ** (y // 2)) * Matrix(2, 1, [[0], [1]])\n    print(\"%d/%d\" % ((ans.arr[0][0] * 2 + 1) % (10 ** 9 + 7), (ans.arr[1][0] * 2) % (10 ** 9 + 7)))\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list([x for x in num if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod # b = 2^n-1\na = (b+flag)*pow(3,mod-2,mod)%mod #a = (2^n-1 -/+ 1) / 3\nprint(\"%d/%d\"%(a,b))\n", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list([x for x in num if x%2 == 0])) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod \na = (b+flag)*pow(3,mod-2,mod)%mod \nprint(\"%d/%d\"%(a,b))\n", "mod = 1000000007\ninput()\nnumbers = list(map(int, input().split()))\nb = 2\nflag = 1 if len(list(filter(lambda x : x % 2 == 0, numbers))) else -1\nfor num in numbers:\n    b = pow(b, num, mod)\nb = b * pow(2, mod - 2, mod) % mod\na = (b + flag) * pow(3, mod - 2, mod) % mod\nprint(\"%d/%d\"%(a, b))", "m = 1000000007\ninput()\nn, d = 2, 1\nfor q in map(int, input().split()): d, n = q & d, pow(n, q, m)\nn = n * pow(2, m - 2, m) % m\nk = (n + 1 - 2 * d) * pow(3, m - 2, m) % m\nprint(str(k) + '/' + str(n))", "from functools import reduce\nMOD = 10 ** 9 + 7\nn, a = int(input()), map(int, input().split())\nn = reduce(lambda x,y:(x*y)%(MOD-1), a, 1)\n# 333333336 * 3 = 1\n# 500000004 * 2 = 1\nk = n % 2\nq = (pow(2, n, MOD) * 500000004) % MOD\nif k == 0:\n p = ((q + 1) * 333333336) % MOD\nelse:\n p = ((q - 1) * 333333336) % MOD\nprint(\"%d/%d\" % (p, q))", "k = int(input())\n\nMOD = 10 ** 9 + 7\n\nantithree = pow(3, MOD - 2, MOD)\n\nantitwo = pow(2, MOD - 2, MOD)\n\npower = 1\n\nparity = False\n\nfor t in map(int, input().split()):\n\n    power *= t\n\n    power %= MOD - 1\n\n    if t % 2 == 0:\n\n        parity = True\n\nq = pow(2, power, MOD) * antitwo\n\nq %= MOD\n\nif parity:\n\n    p = (q + 1) * antithree\n\n    p %= MOD\n\nelse:\n\n    p = (q - 1) * antithree\n\n    p %= MOD    \n\nprint(p, q, sep = '/')\n\n\n\n# Made By Mostafa_Khaled", "from functools import reduce\nmod = 1000000007\nn = input()\nnum = list(map(int,input().split()))\nflag = 1 if len(list(filter(lambda x: x%2 == 0,num))) else -1\nb = reduce(lambda x,y:pow(x,y,mod),num,2)\nb = b*pow(2,mod-2,mod)%mod # b = 2^n-1\na = (b+flag)*pow(3,mod-2,mod)%mod #a = (2^n-1 -/+ 1) / 3\nprint(\"%d/%d\"%(a,b))", "mod = int(1e9+7)\n\nk = int(input())\ntop = 1\nyoink = 1\na = list(map(int, input().split()))\nfor thing in a:\n    top *= thing \n    yoink *= thing\n    yoink %= 2\n    top %= (mod-1)\n\ndef extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n\ndef modinv(a, m):\n\tg, x, y = extended_gcd(a, m)\n\tif g != 1:\n\t\traise ValueError\n\treturn x % m\n\n\nif top == 0:\n    bot = modinv(2, mod) \nelse:\n    bot = pow(2, top-1, mod) \n#print(bot)\n\n# odd case\nif yoink % 2 == 0:\n    blah = modinv(3, mod)\n    blah *= (bot+1)\n    blah %= mod\n    print(str(blah) + '/' + str(bot))\nelse:\n    blah = modinv(3, mod)\n    blah *= (bot+2)\n    blah %= mod\n    print(str(blah-1) + '/' + str(bot))\n\n\n\n"]
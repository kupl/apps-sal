["#!/usr/bin/env python3\n\nfrom fractions import Fraction\n\ndef __starting_point():\n    p, q = list(map(int, input().split()))\n    n = int(input())\n    l = list(map(int, input().split()))\n\n    f = Fraction(l[-1], 1)\n\n    for x in l[-2::-1]:\n        f = 1 / f\n        f += x\n\n    print([\"NO\", \"YES\"][f == Fraction(p, q)])\n\n\n\n__starting_point()", "from  fractions import *\np,q  = map(int,input().split())\na1 = Fraction(p,q)\nn = int(input())\naaa = list(map(int,input().split()))\nd2 = Fraction(aaa[-1],1)\nfor i in range(2,n+1):\n    d2 = 1/d2+aaa[-i]\n#print (d2)\nprint(\"YES\" if a1 == d2 else \"NO\")", "from fractions import Fraction\npq = Fraction(*map(int, input().split()))\ninput()\na = list(map(int, input().split()))\na.reverse()\nf = Fraction(a[0], 1)\nfor i in a[1:]:\n  f = i + Fraction(1, f)\nif pq == f:\n  print(\"YES\")\nelse:\n  print(\"NO\")", "from fractions import*\nfrom sys import*\nfrom copy import*\nfrom time import*\n\n\nclass Fraction:\n    def __init__(self, x = 0, y = 1):\n        if(type(x) == str):\n            if x.find('/') != -1:\n                a = list(map(int, x.split('/')))\n            else:\n                a = list(map(int, x.split()))\n            self.num = a[0]\n            if len(a) == 1:\n                self.den = 1\n            else:\n                self.den = a[1]\n        elif(type(x) == Fraction):\n            self.num, self.den = x.num, x.den\n        else:\n            self.num, self.den = x, y\n        self.reduce()\n\n    def __str__(self):\n        if self.den == 1:\n            return str(int(self.num))\n        return str(int(self.num)) + '/' + str(int(self.den))\n\n    def reduce(self):\n        d = gcd(abs(self.num), abs(self.den))\n        if self.den < 0:\n            self.den, self.num = -self.den, -self.num\n        self.num, self.den = self.num // d, self.den // d\n\n    def __lt__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den < other.num * self.den\n        else:\n            return self.num < self.den * other\n\n    def __le__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den <= other.num * self.den\n        else:\n            return self.num <= self.den * other\n\n    def __gt__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den > other.num * self.den\n        else:\n            return self.num > self.den * other\n\n    def __ge__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den >= other.num * self.den\n        else:\n            return self.num >= self.den * other\n\n    def __eq__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den == other.num * self.den\n        else:\n            return self.num == self.den * other\n\n    def __ne__(self, other):\n        if type(other) == Fraction:\n            return self.num * other.den != other.num * self.den\n        else:\n            return self.num != self.den * other\n\n    def __mul__(self, other):\n        if(type(other) == float):\n            return (self.num * other) / self.den\n        elif type(other) == Poly:\n            return NotImplemented\n        else:\n            other = Fraction(other)\n            return Fraction(self.num * other.num, self.den * other.den)\n\n    def rmul(self, other):\n        return other * self\n\n    def __rmul__(self, other):\n        if(type(other) == float):\n            return (self.num * other) / self.den\n        else:\n            other = Fraction(other)\n            return Fraction(self.num * other.num, self.den * other.den)\n\n    def __imul__(self, other):\n        if(type(other) == float):\n            self = (self.num * other) / self.den\n        else:\n            other = Fraction(other)\n            self.num *= other.num\n            self.den *= other.den\n            self.reduce()\n        return self\n\n    def __truediv__(self, other):\n        if(type(other) == float):\n            return self.num / (self.den * other)\n        else:\n            other = Fraction(other)\n            return self * Fraction(other.den, other.num)\n\n    def __rtruediv__(self, other):\n        if(type(self) == float):\n            return other.num / (other.den * self)\n        else:\n            self = Fraction(self)\n            return other * Fraction(self.den, self.num)\n\n    def __itruediv__(self, other):\n        if(type(other) == float):\n            self = self.num / (self.den * other)\n        else:\n            other = Fraction(other)\n            self = self * Fraction(other.den, other.num)\n            self.reduce()\n        return self\n\n    def __pow__(self, other):\n        if type(other) == Fraction:\n            return (self.num / self.den) ** (other.num / other.den)\n        elif type(other) == int:\n            if other > 0:\n                return Fraction(self.num ** other, self.den ** other)\n            else:\n                return 1 / Fraction(self.num ** (-other), self.den ** (-other))\n        else:\n            return (self.num / self.den) ** other\n\n    def __rpow__(self, other):\n        return other ** (self.num / self.den)\n\n    def __ipow__(self, other):\n        if other > 0:\n            self.num **= other\n            self.den **= other\n        else:\n            self.num **= (-other)\n            self.den **= (-other)\n            self.num, self.den = self.den, self.num\n        return self\n\n    def __add__(self, other):\n        if type(other) == float:\n            return self.num / self.den + other\n        elif type(other) == Poly:\n            return NotImplemented\n        else:\n            other = Fraction(other)\n            return Fraction(self.num * other.den + other.num * self.den, self.den * other.den)\n\n    def __radd__(self, other):\n        return self + other\n\n    def __iadd__(self, other):\n        if type(other) == float:\n            self = self.num / self.den + other\n        else:\n            other = Fraction(other)\n            self.num = self.num * other.den + other.num * self.den\n            self.den = self.den * other.den\n            self.reduce()\n        return self\n\n    def __sub__(self, other):\n        if type(other) == float:\n            return self.num / self.den - other\n        elif type(other) == Poly:\n            return NotImplemented\n        else:\n            other = Fraction(other)\n            return Fraction(self.num * other.den - other.num * self.den, self.den * other.den)\n\n    def __rsub__(self, other):\n        if(type(self - other) == Fraction):\n            return Fraction(-(self - other).num, (self - other).den)\n        else:\n            return -(self - other)\n\n    def __isub__(self, other):\n        if type(other) == float:\n            self = self.num / self.den - other\n        else:\n            other = Fraction(other)\n            self.num = self.num * other.den - other.num * self.den\n            self.den = self.den * other.den\n            self.reduce()\n        return self\n\n    def __pos__(self):\n        return self\n\n    def __neg__(self):\n        return Fraction(-self.num, self.den)\n\n    def __abs__(self):\n        return Fraction((-self.num) * int(self.num < 0) + (self.num) * (self.num >= 0), self.den)\n\n    def __int__(self):\n        return self.num // self.den\n\n    def __float__(self):\n        return self.num / self.den\n\n    def __round__(self, x = 0):\n        return round(float(self), x)\n\n\nclass Poly:\n    def __init__(self, s = 0):\n        if type(s) in [int, float, Fraction]:\n            self.list = [s]\n        elif type(s) == str:\n            self.list, s = [], s.split()\n            for elem in S:\n                self.list += eval(elem)\n        elif type(s) == Poly:\n            self.list = s.list\n        else:\n            self.list = list(s)\n\n    def __str__(self):\n        P, S, power, first = [chr(8304), chr(185), chr(178), chr(179)] + [chr(i) for i in range(8308, 8314)], \"\", len(self.list) - 1, True\n        for i in range(len(self.list) - 1, -1, -1):\n            current = self.list[i]\n            if current != 0:\n                if current > 0:\n                    S += \" + \" * int(not first)\n                else:\n                    S += \" - \" * int(not first) + \"-\" * int(first)\n                current = abs(current)\n                if current != 1 or (current == 1 and power == 0):\n                    if type(current) == Fraction:\n                        if current.den == 1:\n                            S += str(int(current.num))\n                        else:\n                            S += \"(\" + str(current) + \")\"\n                    elif type(current) == float:\n                        S += str(round(current, 3))\n                    else:\n                        S += str(current)\n                S += ('x' * (power != 0))\n                for elem in str(power):\n                    S += P[int(elem)] * (not(elem in [\"0\", \"1\"] and len(str(power)) == 1))\n                first = len(S) == 0\n            power -= 1\n        if S == \"\":\n            return \"0\"\n        return S\n\n    def __neg__(self):\n        result = []\n        for elem in self.list:\n            result.append(-elem)\n        return Poly(result)\n\n    def __add__(self, other):\n        result = []\n        if type(other) == Poly:\n            for i in range(max(len(self.list), len(other.list))):\n                if i < len(self.list):\n                    if i < len(other.list):\n                        result.append(self.list[i] + other.list[i])\n                    else:\n                        result.append(self.list[i])\n                else:\n                    if i < len(other.list):\n                        result.append(other.list[i])\n                    else:\n                        result.append(0)\n            return Poly(result)\n        else:\n            lolka = [self.list[0] + other] + self.list[1:]\n            return Poly(lolka)\n\n    def __radd__(self, other):\n        return self + other\n\n    def __iadd__(self, other):\n        self.list = (self + other).list\n        return self\n\n    def __sub__(self, other):\n        result = []\n        if type(other) == Poly:\n            for i in range(max(len(self.list), len(other.list))):\n                if i < len(self.list):\n                    if i < len(other.list):\n                        result.append(self.list[i] - other.list[i])\n                    else:\n                        result.append(self.list[i])\n                else:\n                    if i < len(other.list):\n                        result.append(-other.list[i])\n                    else:\n                        result.append(0)\n            return Poly(result)\n        else:\n            lolka = [self.list[0] - other] + self.list[1:]\n            return Poly(lolka)\n\n    def __rsub__(self, other):\n        return -(self - other)\n\n    def __isub__(self, other):\n        self.list = (self - other).list\n        return self\n\n    def __or__(self, other):\n        if len(self.list) == 1:\n            return self.list[0]\n        result = self.list[len(self.list) - 1]\n        for i in range(len(self.list) - 2, -1, -1):\n            result = result * other + self.list[i]\n        return result\n\n    def __mul__(self, other):\n        result, p = [], Poly(other)\n        for i in range(len(self.list)):\n            for j in range(len(p.list)):\n                if len(result) > i + j:\n                    result[i + j] += self.list[i] * p.list[j]\n                else:\n                    result += [0] * (i + j - len(result)) + [self.list[i] * p.list[j]]\n        return Poly(result)\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __imul__(self, other):\n        self.list = (self * other).list\n        return self\n\n    def __pow__(self, other):\n        if other == 0:\n            return Poly(1)\n        if other % 2 == 1:\n            return Poly((self ** (other - 1)) * self)\n        else:\n            lolka = self ** (other // 2)\n            return Poly(lolka * lolka)\n\n    def __ipow__(self, other):\n        self.list = (self ** other).list\n        return self\n\n    def __divmod__(self, other):\n        result = [0] * 100\n        p = deepcopy(self.list)\n        q = Poly(other).list\n        power1, power2 = len(p) - 1, len(q) - 1\n        while(power1 > -1 and p[power1] == 0):\n            power1 -= 1\n        while(power2 > -1 and q[power2] == 0):\n            power2 -= 1\n        while(power1 > -1 and power2 > -1 and power1 >= power2):\n            minus = [0] * (power1 - power2)\n            if type(p[power1]) == int and type(q[power2]) == int:\n                if p[power1] % q[power2] == 0:\n                    current = p[power1] // q[power2]\n                else:\n                    current = Fraction(p[power1], q[power2])\n            else:\n                current = p[power1] / q[power2]\n            for elem in q:\n                minus += [elem * current]\n            for i in range(max(len(p), len(minus))):\n                if i < len(p):\n                    if i < len(minus):\n                        p[i] -= minus[i]\n                else:\n                    if i < len(minus):\n                        p.append(-minus[i])\n                    else:\n                        p.append(0)\n            result[power1 - power2] = current\n            while(power1 > -1 and p[power1] == 0):\n                power1 -= 1\n            while(power2 > -1 and q[power2] == 0):\n                power2 -= 1\n            #result += [current]\n        return (Poly(result), Poly(p))\n\n    def __rdivmod__(self, other):\n        return  divmod(Poly(other), self)\n\n    def __floordiv__(self, other):\n        return divmod(self, other)[0]\n\n    def __rfloordiv__(self, other):\n        return divmod(Poly(other), self)[0]\n\n    def __ifloordiv__(self, other):\n        self.list = (divmod(self, other)[0]).list\n        return self\n\n    def __mod__(self, other):\n        return divmod(self, other)[1]\n\n    def __rmod__(self, other):\n        return divmod(Poly(other), self)[1]\n\n    def __imod__(self, other):\n        self.list = (divmod(self, other)[1]).list\n        return self\n\n#begin = time()\np, q = list(map(int, input().split()))\nlolka = Fraction(p, q)\nn = int(input())\nA = list(map(int, input().split()))\nAnswer = Fraction(A[-1])\nfor i in range(len(A) - 2, -1, -1):\n    Answer = 1 / Answer\n    Answer += A[i]\nif(Answer == lolka):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n#print(time() - begin)\n\n", "p,q=tuple(map(int,input().split()))\nn1=input().split()\nn=int(n1[0])\na=list(map(int,input().split()))\nx=1\ny=a[n-1]\nfor i in range (n-2,-1,-1):\n   x1=a[i]*y+x\n   x=y\n   y=x1\nif p*x==q*y:\n   print('YES')\nelse:\n   print('NO')\n   \n", "#!/usr/local/bin/python3.3 -tt\n\nimport fractions\nimport sys\n\n\ndef __starting_point():\n    def _(f):\n        for l in f:\n            for i in l.split():\n                yield int(i)\n\n    g = _(sys.stdin)\n\n    pq = fractions.Fraction(next(g), next(g))\n\n    n, a = next(g), []\n\n    for i in range(n):\n        a.append(next(g))\n\n    r = fractions.Fraction(a.pop())\n\n    while a:\n        r = fractions.Fraction(a.pop()) + fractions.Fraction(1, r)\n\n    if r == pq:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n__starting_point()", "3\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a % b)\n\ndef red(pr):\n\ta, b = pr\n\tg = gcd(a, b)\n\treturn (a // g, b // g)\n\ndef rev(pr):\n\ta, b = pr\n\treturn (b, a)\n\ndef add(pr, i):\n\ta, b = pr\n\ta += b * i\n\treturn red((a, b))\n\nimport sys\nargs = list(map(int, sys.stdin.read().split()))\np, q = args[0], args[1]\nargs = args[2:]\nn = args[0]\nargs = args[1:]\na = args[::-1]\ns = (a[0], 1)\na = a[1:]\nfor i in a:\n\ts = add(rev(s), i)\nif red(s) == red((p, q)):\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n", "import re\nimport itertools\nfrom collections import Counter, deque\nfrom fractions import gcd\n\nclass Task:\n    p, q = 0, 0\n    a = []\n    answer = ''\n\t\n    def getData(self):\n        self.p, self.q = [int(x) for x in input().split(' ')]\n        input()\n        self.a = [int(x) for x in input().split(' ')]\n        #inFile = open('input.txt', 'r')\n        #inFile.readline().rstrip()\n        #self.childs = inFile.readline().rstrip()\n\n    def solve(self):\n        p, q = self.toFraction(self.a)\n        if self.p * q == self.q * p:\n            self.answer = 'YES'\n        else:\n            self.answer = 'NO'\n\n    def toFraction(self, a):\n        if len(a) == 1:\n            return a[0], 1\n        q, p = self.toFraction(a[1 : ])\n        d = gcd(a[0] * q + p, q)\n        return (a[0] * q + p) // d, q // d\n\n    def printAnswer(self):\n        print(self.answer)\n        #outFile = open('output.txt', 'w')\n        #outFile.write(self.answer)\n\ntask = Task()\ntask.getData()\ntask.solve()\ntask.printAnswer()\n", "3\n\np, q = tuple(map(int, input().strip().split()))\nn = int(input().strip())\na = list(map(int, input().strip().split()))\na.reverse()\n\ndef gcd(a, b):\n    while a:\n        a, b = b % a, a\n    return b\n\ng = gcd(p, q)\np, q = p // g, q // g\n\nu, v = 0, 1;\n\nfor i in a:\n    v, u = v * i + u, v\n    g = gcd(u, v)\n    u, v = u // g, v // g\nif p == v and q == u:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "import math\nimport sys\n\ndef gcd(x, y):\n    if(y == 0):\n        return x\n    else:\n        return gcd(y,x%y)\np, q = list(map(int,sys.stdin.readline().split()))\nn = int(input())\na = [0] * n;\nb = list(map(int,sys.stdin.readline().split()))\nl = 0\nfor i in b: \n    a[l] = i\n    l = l + 1\nx, y = a[n-1], 1\nfor i in range(n-2,-1,-1):\n    x, y = y, x\n    x = x + y*a[i]\ng1 = gcd(p,q)\ng2 = gcd(x,y)\np = p // g1\nq = q // g1\nx = x // g2\ny = y // g2\nif(x == p and y == q):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "def gcd(a, b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\ndef red(frac):\n    gcdfrac = gcd(frac[0],frac[1])\n    return (frac[0] // gcdfrac, frac[1] // gcdfrac)\n\ndef add(i, frac):\n    a,b = frac\n    a += b * i\n    return red((a,b))\n\nimport sys\nargs = list(map(int, sys.stdin.read().split()))\np, q = args[0], args[1]\nn = args[2]\ns = (args[2+n],1)\nfor i in range(0,n-1):\n    s = add(args[1+n-i] , (s[1],s[0]))\nif(s == red((p,q))):\n    print('YES')\nelse:\n    print('NO')", "#!/usr/bin/env python\n#coding:utf-8\n\nfrom fractions import Fraction\n\ndef frac(lis,i):\n    if i == len(lis)-1 :\n        return lis[i]\n    else:\n        return lis[i]+1/frac(lis,i+1)\n\ndef main():\n    linesp = input().split(\" \")\n    p,q = int(linesp[0]),int(linesp[1])\n    one = Fraction(p,q)\n\n    n = int(input())\n\n    A = []\n    for s in input().split(\" \"):\n        A.append(Fraction(int(s)))\n\n    two = frac(A,0)\n    if one == two:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\ndef gcd(a, b):\n\tif (b == 0):\n\t\treturn a\n\telse:\n\t\treturn gcd(b, a % b)\n\np, q = map(int, input().split())\nn = int(input())\nA = list(map(int, input().split()))\ng = gcd(p, q)\np = p // g\nq = q // g\nk = A[n - 1]\nl = 1\nfor i in range(n - 2, -1, -1):\n\tk, l = l, k\n\tk += A[i] * l\n\tg = gcd(k, l)\n\tk = k // g\n\tl = l // g\nif (k == p and q == l):\n\tprint (\"YES\")\nelse:\n\tprint (\"NO\")", "P, Q = [int(x) for x in input().split()]\n\nN = int(input())\nA = [int(x) for x in input().split()]\n\nU, V = 1, 0\nfor x in A[::-1]:\n    U, V = V, U\n    U, V = V * x + U, V\n\nif U * Q == P * V:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "from decimal import *\ngetcontext().prec = 75\np = input().split()\n\nn = int(input())\n\nc = input().split()\n\n\n\n\n\na='0'\nfor i in range(n-1,0,-1):\n    a=str(Decimal(a)+Decimal(c[i]))\n    a=str(Decimal('1')/Decimal(str(a)))\n\na=str(Decimal(a)+Decimal(c[0]))\nb=str(Decimal(p[0])/Decimal(p[1]))\n\n\nif(a==b):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "s = input().split(' ')\n\np = int(s[0])\nq = int(s[1])\n\ns = input()\nn = int(s)\n\ns = input().split(' ')\n\nok = True\n\nfor i in range(n):\n    x = int(s[i])\n    p = p-q*x\n    if ok==False:\n        continue\n    if p==0 and i!=n-1 :\n        ok = False\n    elif p<0:\n        ok = False\n    t = p\n    p = q\n    q = t\n\nif ok and (p==0 or q==0):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "p, q = [int(x) for x in input().split()]\nn = int(input())\na = [int(x) for x in input().split()]\nx, y = 1, 0\nfor i in a[::-1]:\n    x, y = y+i*x, x\nif x * q == y * p:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "p,q=[int(x) for x in input().split()]\nn=int(input())\na=[int(x) for x in input().split()]\n\nx,y,i=1,0,n\nwhile n>0:\n    x,y=y,x\n    n-=1\n    x+=y*a[n]\n\nif x*q==y*p:\n    print(\"YES\")\nelse :\n    print(\"NO\")\n", "\ndef gcd(x,y):\n    if(y == 0):\n        return x\n    else:\n        return gcd(y,x%y) \n\np, q = [int(i) for i in input().split()]\nn = int(input())\na = [int(i) for i in input().split()]\nx, y = 1, 0\nfor i in a[::-1]:\n    x, y = y+i*x, x\na, b = gcd(p,q), gcd(x,y)\np = p // a;\nq = q // a\nx = x // b\ny = y // b\nif x == p and y == q:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "s = input()\na = s.split()\np = int(a[0])\nq = int(a[1])\nn = input()\ns = input()\nse = s.split()\nfor c in se:\n    e = int(c)\n    t1 = p-e*q\n    t2 = q\n    p = t2\n    q = t1\nif q == 0:\n    print('YES')\nelse :\n    print('NO')\n", "def gcd(a,b):\n    if(b==0):\n        return a\n    return gcd(b,a%b)\np,q=list(map(int,input().split()))\nN=int(input())\nA=list(map(int,input().split()))\nznam=1\nchisl=A[N-1]\n\nfor i in range (N-1,0,-1):\n    chisl,znam=znam,chisl\n    #print(chisl,znam)\n    chisl += znam*A[i-1]\n    #print(chisl,znam)\nif(p*znam==q*chisl):\n    print('YES')\nelse:\n    print('NO')\n", "def gcd (x, y):\n    while (x > 0) and (y > 0):\n        if (x > y):\n            x %= y\n        else:\n            y %= x\n    return x + y\np, q = map(int, input().split())\nn = int (input ())\na = list (map (int, input ().split ()))\np1 = 1\nq1 = a[n - 1]\nfor i in range(n - 2, -1, -1):\n    p1 += a[i] * q1\n    z = p1\n    p1 = q1\n    q1 = z\nz = p1\np1 = q1\nq1 = z\ng = gcd (p, q)\nif (g != 0):\n    p /= g\n    q /= g\ng = gcd (p1, q1)\nif (g != 0):\n    p1 /= g\n    q1 /= g\nif (p == p1) and (q == q1):\n    print (\"YES\")\nelse:\n    print (\"NO\")", "from fractions import Fraction\ndef __starting_point():\n    p,q=list(map(int, input().split(' ')))\n    n=int(input())\n    a=list(map(int,input().split(' ')))\n    def fract(x):\n        if x==n-1:\n            return Fraction(1,a[x])\n        elif x>=n:\n            return 0\n        else:\n            return Fraction(1,a[x]+fract(x+1))\n    print('YES' if Fraction(p,q)==a[0]+fract(1) else 'NO')\n\n\n\n\n\n__starting_point()", "p, q = list(map(int, input().split()))\nn = int(input())\nA = list(map(int, input().split()))\n\nfor i in range(n):\n    p, q = q, p - A[i] * q\n\nif p != 0 and q == 0:\n    print('YES')\nelse:\n    print('NO')\n"]
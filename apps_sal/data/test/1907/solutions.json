["import sys\n\ndef inside(a,b):\n    return ((a[0]-b[0])**2 + (a[1]-b[1])**2) < (a[2]+b[2])**2\n\n\ndef main():\n    pi = 3.14159265358979323\n    n = int(sys.stdin.readline())\n    a = []\n    p = [-1]*n\n    for i in range(n):\n        x,y,r = map(int,sys.stdin.readline().split())\n        a.append([x,y,r])\n\n    for i in range(n):\n        for j in range(n):\n            if i==j :\n                continue\n            if inside(a[i],a[j]):\n                if a[i][2] < a[j][2]:\n                    if p[i] == -1:\n                        p[i] = j\n                    elif a[p[i]][2]>a[j][2]:\n                        p[i] = j\n                else:\n                    if p[j] == -1:\n                        p[j] = i\n                    elif a[p[j]][2]>a[i][2]:\n                        p[j] = i\n\n    q = []\n    for i in range(n):\n        if p[i] == -1:\n            q.append((i,True))\n\n    s = len(q)\n    ans = 0.0\n    for i in range(s):\n        c, b = q[i]\n        for j in range(n):\n            if p[j] == c:\n                q.append((j,True))\n        ans+= pi * a[c][2] * a[c][2]\n\n    q = q[s:]\n    while len(q)!=0 :\n        c,b = q.pop()\n        for j in range(n):\n            if p[j] == c:\n                q.append((j,not b))\n        if b:\n            ans+= pi * a[c][2] * a[c][2]\n        else:\n            ans-= pi * a[c][2] * a[c][2]\n\n    print(ans)\n\n\nmain()", "from sys import stdin, stdout\nimport math\n\ndef dist(x,y):\n    return ((x[0]-y[0])**2+(x[1]-y[1])**2)**0.5\n\n# Is b inside a\ndef inside(a,b):\n    if dist(b,a)<a[2]:\n        return True\n    else:\n        return False\n\nn = int(stdin.readline().rstrip())\npointList=[]\nfor _ in range(n):\n    x,y,r = list(map(int,stdin.readline().rstrip().split()))\n    pointList.append((x,y,r))\n    \npointList.sort(key = lambda x: x[2],reverse=True)\npositiveCounter = [0]*n\ngroup = [0]*n\nparent = [-1]*n\n\nspaciousness=0\nfor i in range(n):\n    contained = -1\n    for j in range(i-1,-1,-1):\n        if inside(pointList[j],pointList[i]):\n            contained=j\n            break\n    if contained<0:\n        positiveCounter[i]=1\n        group[i]=1\n        spaciousness+=math.pi*pointList[i][2]*pointList[i][2]\n    else:\n        parent[i]=j\n        group[i] = 3-group[j]\n        if parent[j]>=0:\n            positiveCounter[i] = positiveCounter[j]*-1\n            spaciousness+=math.pi*pointList[i][2]*pointList[i][2]*positiveCounter[i]\n        else:\n            positiveCounter[i]=1\n            spaciousness+=math.pi*pointList[i][2]*pointList[i][2]*positiveCounter[i]\n\nprint(spaciousness)\n", "from collections import namedtuple\nfrom math import hypot, pi\n\n\ndef contains(fst, scd):\n    return hypot(fst.x - scd.x, fst.y - scd.y) < fst.r\n\n\ndef area(circle):\n    return pi * circle.r ** 2\n\n\ndef find_prev(side, circle):\n    for prev in reversed(side):\n        if contains(prev, circle):\n            return prev\n\n\nCircle = namedtuple('Circle', 'x y r')\n\nn = int(input())\ncs = []\nfor i in range(n):\n    cs.append(Circle(*list(map(int, input().split()))))\n\ncs = sorted(cs, key=lambda circle: -circle.r)\nans = 0.0\ncounts = dict()\nleft = []\nright = []\nfor ind, cur in enumerate(cs):\n    prev_left = find_prev(left, cur)\n    prev_right = find_prev(right, cur)\n    if prev_left is None:\n        left.append(cur)\n        counts[cur] = True\n        ans += area(cur)\n    elif prev_right is None:\n        right.append(cur)\n        counts[cur] = True\n        ans += area(cur)\n    elif counts[prev_left]:\n        left.append(cur)\n        counts[cur] = False\n        ans -= area(cur)\n    else:\n        left.append(cur)\n        counts[cur] = True\n        ans += area(cur)\n\nprint(ans)\n", "import math\nz = math.pi\nn = input()\na = input()\nfor i in range(int(n)-1):\n    a += '\\n' + input()\na = a.split('\\n')\nfor i in range(len(a)):\n    a[i] = a[i].split(' ')\n    a[i] = list(map(int,a[i]))\nfor i in range(len(a)):    \n    for j in list(reversed(range(i+1,len(a)))): #sort the circles by their radius\n        if a[i][2] < a[j][2]:\n            a[i],a[j] = a[j],a[i]\ndef dis(x,y): #short for distance\n    return math.sqrt((x[0]-y[0])**2 + (x[1]-y[1])**2)\nb = []\nfor i in range(len(a)):\n    b.append(a[i][2]**2)\n    for j in list(reversed(range(i))):\n        if dis(a[i],a[j]) < a[j][2]:\n            a[i].append(j)\n            break\nc = []\nfor i in a:\n    if len(i) == 3:\n        c.append(1)\n    else:\n        c.append(c[i[3]]+1)\nk = 0\nfor i in range(len(c)):\n    if c[i] == 1:\n        k += b[i]\n    elif c[i] % 2 == 0:\n        k += b[i]\n    else:\n        k -= b[i]\nprint(k*z)", "\nimport math\n\nclass circ:\n\tdef __init__(self, x, y, r):\n\t\tself.x = x*1.0\n\t\tself.y = y*1.0\n\t\tself.r = r*1.0\n\nn = 0\nn = int(input())\nvec = []\nfor i in range(n):\n\tst = input().split(' ')\n\ta = int(st[0])\n\tb = int(st[1])\n\tc = int(st[2])\n\tvec.append(circ(a,b,c))\n\ngr = [[] for i in range(n)]\npad = [-1 for i in range(n)]\nvis = [False for i in range(n)]\n\nfor i in range(n):\n\tfor k in range(n):\n\t\tif i == k:\n\t\t\tcontinue\n\t\tdist = math.hypot(vec[i].x - vec[k].x, vec[i].y - vec[k].y)\n\t\tif (dist < vec[k].r\n\t\t\tand vec[k].r > vec[i].r\n\t\t\tand (pad[i] < 0 or vec[k].r < vec[pad[i]].r)):\n\t\t\tpad[i] = k\n\nfor i in range(n):\n\tif pad[i] < 0:\n\t\tcontinue\n\tgr[pad[i]].append(i)\n\nst = []\nans = 0.0\nfor i in range(n):\n\tif pad[i] >= 0 or vis[i]:\n\t\tcontinue\n\tst.append((i, 0))\n\twhile len(st) > 0:\n\t\tnode, level = st.pop()\n\t\tvis[node] = True\n\t\tmult = -1.0\n\t\tif level == 0 or level%2 == 1:\n\t\t\tmult = 1.0\n\t\tans += (mult * (vec[node].r * vec[node].r * math.pi))\n\t\tfor next in gr[node]:\n\t\t\tst.append((next, level+1))\n\nprint(ans)\n\n", "\nimport math\n\nclass circ:\n\tdef __init__(self, x, y, r):\n\t\tself.x = x*1.0\n\t\tself.y = y*1.0\n\t\tself.r = r*1.0\n\nn = 0\nn = int(input())\nvec = []\nfor i in range(n):\n\tst = input().split(' ')\n\ta = int(st[0])\n\tb = int(st[1])\n\tc = int(st[2])\n\tvec.append(circ(a,b,c))\n\ngr = [[] for i in range(n)]\npad = [-1 for i in range(n)]\nvis = [False for i in range(n)]\n\nfor i in range(n):\n\tfor k in range(n):\n\t\tif i == k:\n\t\t\tcontinue\n\t\tdist = math.hypot(vec[i].x - vec[k].x, vec[i].y - vec[k].y)\n\t\tif (dist < vec[k].r\n\t\t\tand vec[k].r > vec[i].r\n\t\t\tand (pad[i] < 0 or vec[k].r < vec[pad[i]].r)):\n\t\t\tpad[i] = k\n\nfor i in range(n):\n\tif pad[i] < 0:\n\t\tcontinue\n\tgr[pad[i]].append(i)\n\nst = []\nans = 0.0\nfor i in range(n):\n\tif pad[i] >= 0 or vis[i]:\n\t\tcontinue\n\tst.append((i, 0))\n\twhile len(st) > 0:\n\t\tnode, level = st.pop()\n\t\tvis[node] = True\n\t\tmult = -1.0\n\t\tif level == 0 or level%2 == 1:\n\t\t\tmult = 1.0\n\t\tans += (mult * (vec[node].r * vec[node].r * math.pi))\n\t\tfor next in gr[node]:\n\t\t\tst.append((next, level+1))\n\nprint(ans)\n\n\n\n\n\n", "n = int(input())\nd = [1] * n\np = [[] for i in range(n)]\n\n\ndef f():\n    x, y, r = map(int, input().split())\n    return r * r, x, y\n\n\nt = sorted(f() for i in range(n))\n\nfor i in range(n):\n    r, x, y = t[i]\n    for j in range(i + 1, n):\n        s, a, b = t[j]\n        if (a - x) ** 2 + (b - y) ** 2 < s:\n            p[j].append(i)\n            d[i] = 0\n            break\n\n\ndef f(i):\n    s = t[i][0]\n    q = [(1, j) for j in p[i]]\n    while q:\n        d, i = q.pop()\n        s += d * t[i][0]\n        q += [(-d, j) for j in p[i]]\n    return s\n\n\nprint(3.1415926536 * sum(f(i) for i in range(n) if d[i]))", "s = 0\nt = [list(map(int, input().split())) for i in range(int(input()))]\nf = lambda b: a[2] < b[2] and (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 <= (a[2] - b[2]) ** 2\nfor a in t:\n    k = sum(f(b) for b in t)\n    s += (-1, 1)[(k < 1) + k & 1] * a[2] ** 2\nprint(3.1415926536 * s)"]
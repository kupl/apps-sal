["n, x = map(int, input().split())\na = [int(x) for x in input().split()]\ndef solve(a, s):\n  #print (a)\n  a.append((-1, 0))\n  a.sort()\n  b = []\n  for i in range(1, len(a)):\n    if a[i][0] != a[i-1][0]:\n      b.append(a[i])\n    else:\n      b[-1] = (a[i][0], b[-1][1] + a[i][1])\n  for i in range(len(b)):\n    t = b[i][1]\n    cnt = 0\n    while t%x == 0:\n      t //= x\n      cnt += 1\n    b[i] = (b[i][0] + cnt, t)\n  #print (b)\n  z = min(min(b)[0], s)\n  if z == 0:\n    return 0\n  return z + solve([(x[0]-z, x[1]) for x in b], s-z)\ns = sum(a)\nprint(pow(x, solve([(s-x, 1) for x in a], s), 10**9+7))", "3\n\ndef readln(): return tuple(map(int, input().split()))\n\nn, x = readln()\na = readln()\nm = max(a)\nans = sum(a) - m\ncnt = {}\nfor v in a:\n    cnt[m - v] = cnt.get(m - v, 0) + 1\nwhile True:\n    k = min(cnt.keys())\n    v = cnt[k]\n    c = 0\n    while v % x == 0:\n        c += 1\n        v //= x\n    #print(cnt, k, cnt[k], c, v)\n    if c:\n        cnt[k + c] = cnt.get(k + c, 0) + v\n        cnt.pop(k)\n    else:\n        break\n    #print(cnt)\nprint(pow(x, ans + min(min(cnt.keys()), m), 10**9 + 7))\n", "MOD = 10**9+7\ndef pow(x, n, MOD):\n    if(n==0):\n        return 1\n    if(n%2==0):\n        a = pow(x, n//2, MOD)\n        return a*a % MOD\n    else:\n        a = pow(x, n//2, MOD)\n        return (x*a*a) % MOD\n\nn, x = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\ns = sum(a)\nd = []\n\nfor el in a:\n\td.append(s-el)\n\nd.sort()\ni=0\ngcd = d[0]\nc=0\nwhile i<n and d[i]==gcd:\n\tc+=1\n\ti+=1\n\nwhile c%x==0:\n\tc=c//x\n\tgcd+=1\n\t\n\twhile i<n and d[i]==gcd:\n\t\tc+=1\n\t\ti+=1\n\t\t\nif gcd>s:\n\tgcd = s\n\t\nprint( pow(x, gcd, MOD) )\n", "n, x = map(int, input().split())\nt = list(map(int, input().split()))\nb = max(t)\nk = t.count(b)\nr = sum(t)\ns = r - b\nwhile k % x == 0:\n    b -= 1\n    s += 1\n    k = k // x + t.count(b)\nprint(pow(x, min(r, s), 1000000007))", "input_str = input()\nn, x = int(input_str.split()[0]), int(input_str.split()[1])\ninput_str = input()\na = input_str.split()\ns = 0\nfor i in range(n):\n    a[i] = int(a[i])\n    #a.append(1000000000)\n    s += a[i]\n\n'''\na = []\nfor i in range(n):\n    if i<65536:\n        temp = 1\n    else:\n        temp = 0#random.randint(0, 1000000000)\n    s += temp\n    a.append(temp)#(557523474, 999999999))'''\n\nsum_a = [s-a[i] for i in range(n)]\nminimum = min(sum_a)\nres = pow(x, minimum, 1000000007)#FastPow(x, minimum)#x**minimum\nsum_xa = 0\ns_new = s - minimum\nfor i in range(n):\n    sum_xa += pow(x, s_new - a[i], 1000000007)#FastPow(x, s_new - a[i])\n\ndeg = 0\ndeg_zn = s-minimum\nts = sum_xa\nwhile sum_xa%1==0 and deg_zn:\n    sum_xa /= x\n    deg += 1 \n    deg_zn -= 1\n  #  print (deg, sum_xa%1==0)\n#if (n, x) == (98304, 2):\n#    print (minimum, s, ts, deg)\n\n\nif deg:\n    res *= pow(x, deg-1 if sum_xa%1!=0 else deg)\nprint (res%1000000007)", "n, x = list(map(int, input().split(' ')))\narr = list(map(int, input().split(' ')))\nsx = sum(arr)\nadds = [sx - i for i in arr]\nadds.sort()\nwhile adds.count(adds[0]) % x == 0:\n    ct = adds.count(adds[0])\n    addsok = ct // x\n    adds = [adds[0]+1] * addsok + adds[ct:]\n\nprint(pow(x, min(min(adds), sx), (10**9+7)))\n", "n, x = list(map(int, input().split(' ')))\narr = list(map(int, input().split(' ')))\ntot = sum(arr) - max(arr)\nsx = sum(arr)\nadds = [sx - tot - i for i in arr]\nadds.sort()\n\nwhile adds.count(adds[0]) % x == 0:\n    ct = adds.count(adds[0])\n    addsok = ct // x\n    adds = [adds[0]+1] * addsok + adds[ct:]\n\nprint(pow(x, (min(tot + min(adds), sx)), (10**9+7)))\n", "#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nn, x = list(map(int, sys.stdin.readline().split()))\na = list(map(int, sys.stdin.readline().split()))\ns = sum(a)\n\nh = []\nfor y in a:\n    heapq.heappush(h, s - y)\n\np, cnt = 0, 0\n\nwhile len(h) > 0:\n    z = heapq.heappop(h)\n    if p == z:\n        cnt += 1\n        if cnt == x:\n            heapq.heappush(h, p + 1)\n            cnt = 0\n    else:\n        if cnt != 0:\n            print(pow(x, min(p, s), 10 ** 9 + 7))\n            return\n        cnt = 1\n        p = z\n\nprint(pow(x, min(p, s), 10 ** 9 + 7))\n", "#!/usr/bin/env python3\n\nimport sys\nimport heapq\n\nn, x = list(map(int, sys.stdin.readline().split()))\na = list(map(int, sys.stdin.readline().split()))\ns = sum(a)\n\nh = []\nfor y in a:\n    heapq.heappush(h, s - y)\n\np, cnt = 0, 0\n\nwhile len(h) > 0:\n    z = heapq.heappop(h)\n    if p == z:\n        cnt += 1\n        if cnt == x:\n            heapq.heappush(h, p + 1)\n            cnt = 0\n    else:\n        if cnt != 0:\n            print(pow(x, min(p, s), 10 ** 9 + 7))\n            return\n        cnt = 1\n        p = z\n\nprint(pow(x, min(p, s), 10 ** 9 + 7))\n", "n, x = map(int, input().split())\nt = list(map(int, input().split()))\nb = max(t)\nk = t.count(b)\nr = sum(t)\ns = r - b\nwhile k % x == 0:\n    b -= 1\n    s += 1\n    k = k // x + t.count(b)\nprint(pow(x, min(r, s), 1000000007))", "n, x = list(map(int, input().split()))\n\nt = list(map(int, input().split()))\n\nb = max(t)\n\nk = t.count(b)\n\nr = sum(t)\n\ns = r - b\n\nwhile k % x == 0:\n\n    b -= 1\n\n    s += 1\n\n    k = k // x + t.count(b)\n\nprint(pow(x, min(r, s), 1000000007))\n\n\n\n# Made By Mostafa_Khaled\n", "modulus = 10 ** 9 + 7\n\n\ndef main():\n    n, x = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n\n    total = sum(arr)\n    powers = [total - x for x in arr]\n    powers.sort(reverse=True)\n\n    while True:\n\n        low = powers[len(powers) - 1]\n\n        cnt = 0\n\n        while len(powers) > 0 and powers[len(powers) - 1] == low:\n            cnt += 1\n            powers.pop()\n\n        if cnt % x == 0:\n            cnt = cnt // x\n            for i in range(cnt):\n                powers.append(low + 1)\n        else:\n            low = min(low, total)\n            print(pow(x, low, modulus))\n            return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "modulus = 10 ** 9 + 7\n\n\ndef main():\n    n, x = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n\n    total = sum(arr)\n    powers = [total - x for x in arr]\n    powers.sort(reverse=True)\n\n    while True:\n\n        low = powers[len(powers) - 1]\n\n        cnt = 0\n\n        while len(powers) > 0 and powers[len(powers) - 1] == low:\n            cnt += 1\n            powers.pop()\n\n        if cnt % x == 0:\n            cnt = cnt // x\n            for i in range(cnt):\n                powers.append(low + 1)\n        else:\n            low = min(low, total)\n            print(pow(x, low, modulus))\n            return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal = sum(a)\nbiggest = max(a)\n\nexp = total - biggest\n\nhm = a.count(biggest)\nwhile hm%x == 0:\t\n\tbiggest -= 1\n\texp += 1\n\thm = hm//x + a.count(biggest)\n\nif exp > total:\n\texp = total\nprint(pow(x, exp, 1000000007))", "modulus = 10**9 +7\n\nn, x = list(map(int,input().split()))\ns = list(map(int,input().split()))\n\ntot = sum(s)\npowers=[tot-x for x in s]\npowers.sort(reverse=True)\n\nwhile True:\n\n    low=powers[-1]\n    cnt = 0\n    while len(powers) > 0 and powers[-1]==low:\n        cnt += 1\n        powers.pop()\n    if cnt%x==0:\n        cnt=cnt // x\n        for n in range(cnt):\n            powers.append(low+1)\n    else:\n        low = min(low, tot)\n        print(pow(x, low, modulus))\n        return\n", "n,x=list(map(int,input().split()))\nl=list(map(int,input().split()))\nfrom collections import Counter\nl.sort()\ngcd=sum(l[:n-1])\nm=10**9+7\ns=sum(l)\nl1=[]\nfor i in l:\n    l1.append(s-i-gcd)\nc=Counter(l1)\nl2=[]\nfor i in c:\n    l2.append(i)\nl2.sort()\nz=True\nwhile z:\n    z=False\n    for i in c.copy():\n        a=c[i]\n        b=0\n        while a%x==0 and a!=0:\n            z=True\n            a//=x\n            b+=1\n        if z:\n            c[i+b]+=a\n            c[i]=0\ny=l[-1]\nfor i in c:\n    if c[i]:\n        y=min(y,i)\ngcd+=y\nprint(pow(x,min(s,gcd),m))\n\n    \n        \n", "#########\t\t\t##\t##     ##    \t  ####  #####  ##     #  ##     #\t\t##\n\t#\t\t\t   # #\t# #   # #\t\t #\t  #\t#\t#  # #    #  # #    #\t   # #\n\t#\t\t\t  #  #\t#  ###  #\t    #\t\t#\t#  #  #   #  #  #   #\t  #  #\n\t#\t\t\t #####\t#\t#\t#\t   #    ###\t#\t#  #   #  #  #   #  #    #####\n\t#\t\t\t#    #\t#\t\t#\t   #    # #\t#\t#  #\t# #  #\t  # #   #    #  \n######### \t   #     # \t#\t\t#\t\t##### #\t#####  #\t ##  #\t   ##  #     #\n\n\"\"\"\n\nPPPPPPP       RRRRRRR\t\t    OOOO\t  VV        VV    EEEEEEEEEE\nPPPPPPPP      RRRRRRRR         OOOOOO     VV       VV\t  EE\nPPPPPPPPP     RRRRRRRRR       OOOOOOOO    VV      VV\t  EE\nPPPPPPPP      RRRRRRRR        OOOOOOOO    VV     VV    \t  EEEEEE\nPPPPPPP       RRRRRRR         OOOOOOOO    VV    VV        EEEEEEE\nPP  \t\t  RRRR\t\t\t  OOOOOOOO    VV   VV         EEEEEE\nPP\t\t\t  RR  RR          OOOOOOOO    VV  VV          EE\nPP\t\t\t  RR    RR         OOOOOO     VV VV           EE\nPP\t\t\t  RR      RR        OOOO      VVVV            EEEEEEEEEE\n\n\"\"\"\n\n\n\n\"\"\"\n Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n\"\"\"\nimport sys\ninput = sys.stdin.readline\n# from bisect import bisect_left as lower_bound;\n# from bisect import bisect_right as upper_bound;\n# from math import ceil, factorial;\n \ndef ceil(x):\n    if x != int(x):\n        x = int(x) + 1\n    return x\n \ndef factorial(x, m):\n\tval = 1\n\twhile x>0:\n\t\tval = (val * x) % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n    \n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n \n## gcd function\ndef gcd(a,b):\n    if b == 0:\n        return a;\n    return gcd(b, a % b);\n\n## lcm function\ndef lcm(a, b):\n\treturn (a * b) // gcd(a, b)\n \n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n\tif k > n:\n\t\treturn 0\n\tif(k > n - k):\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n \n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0, hi = None):\n    if hi == None:\n        hi = len(a);\n    while lo < hi:\n        mid = (lo+hi)//2;\n        if a[mid] < x:\n            lo = mid+1;\n        else:\n            hi = mid;\n    return lo;\n \n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0 and n > 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0 and n > 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n \n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n \n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b;\n \n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n \n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n \n \n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n \n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    prime[0], prime[1] = False, False\n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n# Euler's Toitent Function phi\ndef phi(n) : \n  \n    result = n \n    p = 2\n    while(p * p<= n) : \n        if (n % p == 0) : \n            while (n % p == 0) : \n                n = n // p \n            result = result * (1.0 - (1.0 / (float) (p))) \n        p = p + 1\n    if (n > 1) : \n        result = result * (1.0 - (1.0 / (float)(n))) \n   \n    return (int)(result) \n\ndef is_prime(n):\n\tif n == 0:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(2, int(n ** (1 / 2)) + 1):\n\t\tif not n % i:\n\t\t\treturn False\n \n\treturn True\n \n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e5 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n \n################## un-comment below 2 lines when using factorization #################\nspf = [0 for i in range(MAXN)]\n# spf_sieve();\ndef factoriazation(x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n    \twhile x % i == 0:\n    \t\tres.append(i)\n    \t\tx //= i\n    if x != 1:\n   \t\tres.append(x)\n    return res\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\ndef factors(n):\n\tres = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tres.append(i)\n\t\t\tres.append(n // i)\n\treturn list(set(res))\n \n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()));\n \ndef float_array():\n    return list(map(float, input().strip().split()));\n \n## taking string array input\ndef str_array():\n    return input().strip().split();\n \n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n \n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n \nfrom itertools import permutations\nimport math\n\nfrom bisect import bisect_left\n\n\n\ndef solve():\n\tn, x = list(map(int, input().split()))\n\tpowers = list(map(int, input().split()))\n\tsumm = sum(powers)\n\tbiggest = max(powers)\n\tp = summ - biggest\n\tnumber_of_powers = powers.count(biggest)\n\twhile number_of_powers % x == 0:\n\t\tbiggest -= 1\n\t\tp += 1\n\t\tnumber_of_powers = number_of_powers // x + powers.count(biggest)\n\tif p > summ:\n\t\tp = summ\n\tprint(pow(x, p, MOD))\n\ndef __starting_point():\n\tfor _ in range(1):\n\t\tsolve()\n\t# fin_time = datetime.now()\n# \tprint(\"Execution time (for loop): \", (fin_time-init_time))\n\n__starting_point()", "#########\t\t\t##\t##     ##    \t  ####  #####  ##     #  ##     #\t\t##\n\t#\t\t\t   # #\t# #   # #\t\t #\t  #\t#\t#  # #    #  # #    #\t   # #\n\t#\t\t\t  #  #\t#  ###  #\t    #\t\t#\t#  #  #   #  #  #   #\t  #  #\n\t#\t\t\t #####\t#\t#\t#\t   #    ###\t#\t#  #   #  #  #   #  #    #####\n\t#\t\t\t#    #\t#\t\t#\t   #    # #\t#\t#  #\t# #  #\t  # #   #    #  \n######### \t   #     # \t#\t\t#\t\t##### #\t#####  #\t ##  #\t   ##  #     #\n\n\"\"\"\n\nPPPPPPP       RRRRRRR\t\t    OOOO\t  VV        VV    EEEEEEEEEE\nPPPPPPPP      RRRRRRRR         OOOOOO     VV       VV\t  EE\nPPPPPPPPP     RRRRRRRRR       OOOOOOOO    VV      VV\t  EE\nPPPPPPPP      RRRRRRRR        OOOOOOOO    VV     VV    \t  EEEEEE\nPPPPPPP       RRRRRRR         OOOOOOOO    VV    VV        EEEEEEE\nPP  \t\t  RRRR\t\t\t  OOOOOOOO    VV   VV         EEEEEE\nPP\t\t\t  RR  RR          OOOOOOOO    VV  VV          EE\nPP\t\t\t  RR    RR         OOOOOO     VV VV           EE\nPP\t\t\t  RR      RR        OOOO      VVVV            EEEEEEEEEE\n\n\"\"\"\n\n\n\n\"\"\"\n Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.\n\"\"\"\nimport sys\ninput = sys.stdin.readline\n# from bisect import bisect_left as lower_bound;\n# from bisect import bisect_right as upper_bound;\n# from math import ceil, factorial;\n \ndef ceil(x):\n    if x != int(x):\n        x = int(x) + 1\n    return x\n \ndef factorial(x, m):\n\tval = 1\n\twhile x>0:\n\t\tval = (val * x) % m\n\t\tx -= 1\n\treturn val\n\ndef fact(x):\n\tval = 1\n\twhile x > 0:\n\t\tval *= x\n\t\tx -= 1\n\treturn val\n    \n# swap_array function\ndef swaparr(arr, a,b):\n    temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n \n## gcd function\ndef gcd(a,b):\n    if b == 0:\n        return a;\n    return gcd(b, a % b);\n\n## lcm function\ndef lcm(a, b):\n\treturn (a * b) // gcd(a, b)\n \n## nCr function efficient using Binomial Cofficient\ndef nCr(n, k): \n\tif k > n:\n\t\treturn 0\n\tif(k > n - k):\n\t\tk = n - k\n\tres = 1\n\tfor i in range(k):\n\t\tres = res * (n - i)\n\t\tres = res / (i + 1)\n\treturn int(res)\n \n## upper bound function code -- such that e in a[:i] e < x;\ndef upper_bound(a, x, lo=0, hi = None):\n    if hi == None:\n        hi = len(a);\n    while lo < hi:\n        mid = (lo+hi)//2;\n        if a[mid] < x:\n            lo = mid+1;\n        else:\n            hi = mid;\n    return lo;\n \n## prime factorization\ndef primefs(n):\n    ## if n == 1    ## calculating primes\n    primes = {}\n    while(n%2 == 0 and n > 0):\n        primes[2] = primes.get(2, 0) + 1\n        n = n//2\n    for i in range(3, int(n**0.5)+2, 2):\n        while(n%i == 0 and n > 0):\n            primes[i] = primes.get(i, 0) + 1\n            n = n//i\n    if n > 2:\n        primes[n] = primes.get(n, 0) + 1\n    ## prime factoriazation of n is stored in dictionary\n    ## primes and can be accesed. O(sqrt n)\n    return primes\n \n## MODULAR EXPONENTIATION FUNCTION\ndef power(x, y, p): \n    res = 1\n    x = x % p  \n    if (x == 0) : \n        return 0\n    while (y > 0) : \n        if ((y & 1) == 1) : \n            res = (res * x) % p \n        y = y >> 1      \n        x = (x * x) % p \n    return res \n \n## DISJOINT SET UNINON FUNCTIONS\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return a,b;\n \n# find function with path compression included (recursive)\n# def find(x, link):\n#     if link[x] == x:\n#         return x\n#     link[x] = find(link[x], link);\n#     return link[x];\n \n# find function with path compression (ITERATIVE)\ndef find(x, link):\n    p = x;\n    while( p != link[p]):\n        p = link[p];\n    \n    while( x != p):\n        nex = link[x];\n        link[x] = p;\n        x = nex;\n    return p;\n \n \n# the union function which makes union(x,y)\n# of two nodes x and y\ndef union(x, y, link, size):\n    x = find(x, link)\n    y = find(y, link)\n    if size[x] < size[y]:\n        x,y = swap(x,y)\n    if x != y:\n        size[x] += size[y]\n        link[y] = x\n \n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\ndef sieve(n): \n    prime = [True for i in range(n+1)] \n    prime[0], prime[1] = False, False\n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n# Euler's Toitent Function phi\ndef phi(n) : \n  \n    result = n \n    p = 2\n    while(p * p<= n) : \n        if (n % p == 0) : \n            while (n % p == 0) : \n                n = n // p \n            result = result * (1.0 - (1.0 / (float) (p))) \n        p = p + 1\n    if (n > 1) : \n        result = result * (1.0 - (1.0 / (float)(n))) \n   \n    return (int)(result) \n\ndef is_prime(n):\n\tif n == 0:\n\t\treturn False\n\tif n == 1:\n\t\treturn True\n\tfor i in range(2, int(n ** (1 / 2)) + 1):\n\t\tif not n % i:\n\t\t\treturn False\n \n\treturn True\n \n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\nMAXN = int(1e5 + 5)\ndef spf_sieve():\n    spf[1] = 1;\n    for i in range(2, MAXN):\n        spf[i] = i;\n    for i in range(4, MAXN, 2):\n        spf[i] = 2;\n    for i in range(3, ceil(MAXN ** 0.5), 2):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i;\n    ## function for storing smallest prime factors (spf) in the array\n \n################## un-comment below 2 lines when using factorization #################\nspf = [0 for i in range(MAXN)]\n# spf_sieve();\ndef factoriazation(x):\n    res = []\n    for i in range(2, int(x ** 0.5) + 1):\n    \twhile x % i == 0:\n    \t\tres.append(i)\n    \t\tx //= i\n    if x != 1:\n   \t\tres.append(x)\n    return res\n    ## this function is useful for multiple queries only, o/w use\n    ## primefs function above. complexity O(log n)\n\ndef factors(n):\n\tres = []\n\tfor i in range(1, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\tres.append(i)\n\t\t\tres.append(n // i)\n\treturn list(set(res))\n \n## taking integer array input\ndef int_array():\n    return list(map(int, input().strip().split()));\n \ndef float_array():\n    return list(map(float, input().strip().split()));\n \n## taking string array input\ndef str_array():\n    return input().strip().split();\n \n#defining a couple constants\nMOD = int(1e9)+7;\nCMOD = 998244353;\nINF = float('inf'); NINF = -float('inf');\n \n################### ---------------- TEMPLATE ENDS HERE ---------------- ###################\n \nfrom itertools import permutations\nimport math\n\nfrom bisect import bisect_left\n\n\n\ndef solve():\n\tn, x = list(map(int, input().split()))\n\tpowers = list(map(int, input().split()))\n\tsumm = sum(powers)\n\tbiggest = max(powers)\n\tp = summ - biggest\n\tnumber_of_powers = powers.count(biggest)\n\twhile number_of_powers % x == 0:\n\t\tbiggest -= 1\n\t\tp += 1\n\t\tnumber_of_powers = number_of_powers // x + powers.count(biggest)\n\tif p > summ:\n\t\tp = summ\n\tprint(pow(x, p, MOD))\n\ndef __starting_point():\n\tfor _ in range(1):\n\t\tsolve()\n\t# fin_time = datetime.now()\n# \tprint(\"Execution time (for loop): \", (fin_time-init_time))\n\n__starting_point()"]
["def mask(n):\n  if not n: return 0;\n  m = 1\n  while not (m & n):\n    m *= 2\n  return m\n  \nn, T = list(map(int, input().split()))\nfor t in range(T):\n  cur = int(input())\n  for ch in input():\n    m = mask(cur)\n    #print(ch, \":\", m, cur, \"->\", end = \" \")\n    if ch == \"U\":\n      next = (cur - m) | (m * 2)\n      if next < n: cur = next\n    elif ch == \"L\" and m > 1:\n      cur -= m//2\n    elif ch == \"R\" and m > 1:\n      cur += m//2\n    #print(cur)\n  print(cur)  \n", "n, q = [int(i) for i in input().split()]\n\ndef identify_row(x):\n\tfor i in range(1, 64):\n\t\tpower = 1 << i\n\t\tif x % power == power >> 1:\n\t\t\treturn i\n\ndef some(x):\n\tr = identify_row(x)\n\treturn x - (1 << (r - 1)) + 1\n\ndef left(x):\n\tr = identify_row(x)\n\tif r == 1: return x\n\treturn x - (1 << (r - 2))\n\ndef right(x):\n\tr = identify_row(x)\n\tif r == 1: return x\n\treturn x + (1 << (r - 2))\n\ndef parent(x):\n\tif x == (n + 1) >> 1:\n\t\treturn x\n\tr = identify_row(x)\n\treturn x + (1<<(r-1) if some(x) % (1 << (r + 1)) == 1 else -1<<(r-1))\n\nfor _ in range(q):\n\tt = int(input())\n\tc = input()\n\tfor i in c:\n\t\tif i == 'U': t = parent(t)\n\t\telif i == 'R': t = right(t)\n\t\telif i == 'L': t = left(t)\n\t\telse: print('error', i)\n\tprint(t)", "import math\n\nn, q = map(int, input().split())\nmaxh = int(math.log(n + 1, 2))\nfor i in range (q):\n    u = int(input())\n    road = input()\n    curh = 1\n    curw = 0\n    ch = 1\n    while ch == 1:\n        if u % curh != 0:\n            curh //= 2\n            ch = 0\n        curh *= 2\n    curh = int(math.log(curh, 2))\n    a = 1 << (curh - 1)\n    b = 1 << curh\n    curw = (u - a) // b + 1\n    for move in road:\n        if move == \"L\":\n            if curh != 1:\n                curh -= 1\n                curw = curw * 2 - 1\n                u -= 1 << (curh - 1)\n        elif move == \"R\":\n            if curh != 1:\n                curh -= 1\n                curw *= 2\n                u += 1 << (curh - 1)\n        else:\n            if curh != maxh:\n                if curw % 2 == 1:\n                    u = (u + u + (1 << curh)) // 2\n                    curh += 1\n                    curw = curw // 2 + 1\n                else:\n                    u = (u + u - (1 << curh)) // 2\n                    curh += 1\n                    curw = curw // 2\n    print(u)", "import math\n\nn, q = map(int, input().split())\nmaxh = int(math.log(n + 1, 2))\nfor i in range (q):\n    u = int(input())\n    road = input()\n    curh = 1\n    curw = 0\n    ch = 1\n    while ch == 1:\n        if u % curh != 0:\n            curh //= 2\n            ch = 0\n        curh *= 2\n    curh = int(math.log(curh, 2))\n    a = 1 << (curh - 1)\n    b = 1 << curh\n    curw = (u - a) // b + 1\n    for move in road:\n        if move == \"L\":\n            if curh != 1:\n                curh -= 1\n                curw = curw * 2 - 1\n                u -= 1 << (curh - 1)\n        elif move == \"R\":\n            if curh != 1:\n                curh -= 1\n                curw *= 2\n                u += 1 << (curh - 1)\n        else:\n            if curh != maxh:\n                if curw % 2 == 1:\n                    u = (u + u + (1 << curh)) // 2\n                    curh += 1\n                    curw = curw // 2 + 1\n                else:\n                    u = (u + u - (1 << curh)) // 2\n                    curh += 1\n                    curw = curw // 2\n    print(u)", "from math import log\nn, q = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\nsteps = [2 ** i for i in range(maxlvl)]\n\ndef calc_lvl(m):\n    for lvl in range(1, maxlvl):\n        if (m - steps[lvl-1]) % steps[lvl] == 0:\n            return (lvl, ((m - steps[lvl-1]) % (2 * steps[lvl]) == 0))\n\n#print(calc_lvl(1))\n#print(calc_lvl(3))\n#print(calc_lvl(5))\n#print(calc_lvl(7))\n#print(calc_lvl(9))\n#print(calc_lvl(11))\n#print(calc_lvl(13))\n#print(calc_lvl(15))\n\n\n             \nfor i in range(q):\n    strt = int(input())\n    qwery = input()\n    lvl, ind = calc_lvl(strt)\n    \n    for c in qwery:\n        if c == 'U':  \n            if strt == steps[-2]:\n                continue\n            if not ind:\n                strt -= steps[lvl - 1]\n                lvl, ind = calc_lvl(strt)\n            else:\n                strt += steps[lvl - 1]\n                lvl, ind = calc_lvl(strt)\n                \n        elif c == 'L':\n            if strt % 2 != 0:\n                continue\n            strt -= steps[lvl - 2]\n            lvl, ind = lvl - 1, 1\n            \n        else:\n            if strt % 2 != 0:\n                continue\n            strt += steps[lvl - 2]\n            lvl, ind = lvl - 1, 0\n            \n    print(strt)\n            \n                \n                \n\n            \n", "from math import log\nn, q = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\npows = [2 ** i for i in range(maxlvl)]\n\ndef calc_lvl(m):\n    for lvl in range(1, maxlvl):\n        if (m - pows[lvl-1]) % pows[lvl] == 0:\n            return (lvl, ((m - pows[lvl-1]) % (2 * pows[lvl]) == 0))\n\nfor i in range(q):\n    start = int(input())\n    query = input()\n    lvl, ind = calc_lvl(start)\n    \n    for c in query:\n        if c == 'U':  \n            if start == pows[-2]:\n                continue\n            start += (1 if ind else -1) * pows[lvl - 1]\n            lvl, ind = calc_lvl(start)    \n        else:\n            if start % 2 != 0:\n                continue\n            start += (1 if c == 'R' else -1) * pows[lvl - 2]\n            lvl, ind = lvl - 1, int((c == 'L'))\n            \n    print(start)\n            \n                \n                \n\n            \n", "from math import log\nn, q = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\npows = [2 ** i for i in range(maxlvl)]\ndone = dict()\n\ndef calc_lvl(m):\n    for lvl in range(1, maxlvl):\n        if (m - pows[lvl-1]) % pows[lvl] == 0:\n            return (lvl, ((m - pows[lvl-1]) % (2 * pows[lvl]) == 0))\n\nfor i in range(q):\n    start = int(input())\n    query = input()\n    lvl, ind = calc_lvl(start)\n    \n    for c in query:\n        if c == 'U':  \n            if start == pows[-2]:\n                continue\n            start += (1 if ind else -1) * pows[lvl - 1]\n            if start not in list(done.keys()):\n                lvl, ind = calc_lvl(start)\n                done[start] = (lvl, ind)\n            else:\n                (lvl, ind) = done[start]\n        else:\n            if start % 2 != 0:\n                continue\n            start += (1 if c == 'R' else -1) * pows[lvl - 2]\n            lvl, ind = lvl - 1, int((c == 'L'))\n            \n    print(start)\n            \n                \n                \n\n            \n", "from math import log\nn, q = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\npows = [2 ** i for i in range(maxlvl)]\n\ndef calc_lvl(m):\n    for lvl in range(1, maxlvl):\n        if (m - pows[lvl-1]) % pows[lvl] == 0:\n            return (lvl, ((m - pows[lvl-1]) % (2 * pows[lvl]) == 0))\n\nfor i in range(q):\n    start = int(input())\n    query = input()\n    lvl, ind = calc_lvl(start)\n    \n    for c in query:\n        if c == 'U':  \n            if start == pows[-2]:\n                continue\n            start += (1 if ind else -1) * pows[lvl - 1]\n            lvl, ind = calc_lvl(start)    \n        else:\n            if start % 2 != 0:\n                continue\n            start += (1 if c == 'R' else -1) * pows[lvl - 2]\n            lvl, ind = lvl - 1, int((c == 'L'))\n            \n    print(start)\n            \n                \n\n            \n", "import sys\nn,q = map(int, input().split())\n\ndef lev(x):\n    num = (x) & (-x)\n    l = 0\n    while num > 0:\n        num =( num >> 1)\n        l+=1\n    return l\ndef up(x):\n    l = lev(x)\n    # left child\n    if  not (((1<<l) & x) > 0):\n        return x + (1<<(l - 1))\n    #right child\n    return x - (1<<(l - 1))\ndef left(x):\n    l = lev(x)\n    if( l == 1):\n        return  0\n        \n    # left child\n    return x - (1<<(l - 1)) + (1<<(l -2))\ndef right(x):\n    l = lev(x)\n    if( l == 1):\n        return  0\n    # left child\n    return x + (1<<(l -2))\ndef isValid(x):\n    return  0<x <= n\nfor i in range(q):\n    u = int(input())\n    s = input()\n    for a in s:\n        if a == 'U':\n            nu = up(u)\n        elif a == 'R':\n            nu = right(u)\n        else:\n            nu = left(u)\n        if isValid(nu):\n            u = nu\n    print(u)", "from math import log\nn, q = [int(i) for i in input().split()]\nmaxlvl = int(log(n + 1, 2)) + 1\npows = [2 ** i for i in range(maxlvl)]\n\ndef calc_lvl(m):\n    for lvl in range(1, maxlvl):\n        if (m - pows[lvl-1]) % pows[lvl] == 0:\n            return (lvl, ((m - pows[lvl-1]) % (2 * pows[lvl]) == 0))\n\nfor i in range(q):\n    start = int(input())\n    query = input()\n    lvl, ind = calc_lvl(start)\n    \n    for c in query:\n        if c == 'U':  \n            if start == pows[-2]:\n                continue\n            start += (1 if ind else -1) * pows[lvl - 1]\n            lvl, ind = calc_lvl(start)    \n        else:\n            if start % 2 != 0:\n                continue\n            start += (1 if c == 'R' else -1) * pows[lvl - 2]\n            lvl, ind = lvl - 1, int((c == 'L'))\n\n            \n    print(start)\n            \n                \n\n            \n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n,q = LI()\n    nn = n\n    k = 0\n    while nn > 0:\n        nn //= 2\n        k += 1\n\n    r = []\n    ii = [2**i for i in range(k)]\n    for _ in range(q):\n        t = I()\n        s = S()\n        ti = 0\n        for i in range(k):\n            if ii[i] & t:\n                ti = i\n                break\n\n        for c in s:\n            if c == 'U':\n                if ti == k-1:\n                    continue\n                if t & ii[ti]:\n                    t ^= ii[ti]\n                ti += 1\n                t |= ii[ti]\n                continue\n            if ti == 0:\n                continue\n            if c == 'R':\n                t |= ii[ti]\n            else:\n                if t & ii[ti]:\n                    t ^= ii[ti]\n            ti -= 1\n            t |= ii[ti]\n        r.append(t)\n\n    return '\\n'.join(map(str, r))\n\n\nprint(main())\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    n,q = LI()\n    nn = n\n    k = 0\n    while nn > 0:\n        nn //= 2\n        k += 1\n\n    r = []\n    ii = [2**i for i in range(k)]\n    for _ in range(q):\n        t = I()\n        s = S()\n        ti = 0\n        for i in range(k):\n            if ii[i] & t:\n                ti = i\n                break\n\n        for c in s:\n            if c == 'U':\n                if ti == k-1:\n                    continue\n                if t & ii[ti]:\n                    t ^= ii[ti]\n                ti += 1\n                t |= ii[ti]\n                continue\n            if ti == 0:\n                continue\n            if c == 'R':\n                t |= ii[ti]\n            else:\n                if t & ii[ti]:\n                    t ^= ii[ti]\n            ti -= 1\n            t |= ii[ti]\n        r.append(t)\n\n    return '\\n'.join(map(str, r))\n\n\nprint(main())\n", "def powersOfTwo():\n    powers = {}\n    powers[0] = 1\n    for i in range(1, 70):\n        powers[i] = powers[i - 1] * 2\n    return powers\n\ndef log2(num):\n    ans = 0\n    while num > 1:\n        num //= 2\n        ans += 1\n    return ans\n\ndef getlevel(num):\n    count = 0\n    while num % 2 == 0:\n        num //= 2\n        count += 1\n    return count\n\ndef solve():\n    n, q = list(map(int, input().rstrip().split()))\n    powers = powersOfTwo()\n    maxlevel = log2(n + 1) - 1\n    for _ in range(q):\n        num = int(input().rstrip())\n        level = getlevel(num)\n        string = input().rstrip()\n        for char in string:\n            assert 0 <= level <= maxlevel\n            if char == 'U':\n                if level < maxlevel:\n                    a = num - powers[level]\n                    b = num + powers[level]\n                    if a == 0:\n                        num = b\n                    elif b > n:\n                        num = a\n                    elif getlevel(a) < getlevel(b):\n                        num = a\n                    else:\n                        num = b\n                    level += 1\n            elif char == 'L':\n                if level > 0:\n                    num -= powers[level - 1]\n                    level -= 1\n            elif char == 'R':\n                if level > 0:\n                    num += powers[level - 1]\n                    level -= 1\n            else:\n                raise ValueError\n        print(num)\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from math import *\n\nn, q = list(map(int, input().split()))\ndepth = int(log2(n + 1))\n\n\ndef get_layer(u):\n    for layer in range(depth):\n        if u % (2 ** (layer + 1)) == 2 ** layer:\n            return layer\n\n\ndef is_right_child(layer, u):\n    return (u % 2 ** (layer + 1)) % 2 == 0\n\n\nfor x in range(q):\n    u = int(input())\n    layer = get_layer(u)\n    steps = input()\n    for s in steps:\n        if s == 'U':\n            if (layer == depth - 1):\n                continue\n            k = (u // (2 ** (layer + 1))) // 2\n            layer += 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n        elif layer == 0:\n            continue\n        elif s == 'R':\n            k = (u // (2 ** (layer + 1))) * 2 + 1\n            layer -= 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n        elif s == 'L':\n            k = (u // (2 ** (layer + 1))) * 2\n            layer -= 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n    print(u)\n", "from math import *\n\nn, q = list(map(int, input().split()))\ndepth = int(log2(n + 1))\n\ndef get_layer(u):\n    for layer in range(depth):\n        if u % (2 ** (layer + 1)) == 2 ** layer:\n            return layer\n\n\nfor x in range(q):\n    u = int(input())\n    layer = get_layer(u)\n    steps = input()\n    for s in steps:\n        if s == 'U':\n            if (layer == depth - 1):\n                continue\n            k = (u // (2 ** (layer + 1))) // 2\n            layer += 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n        elif layer == 0:\n            continue\n        elif s == 'R':\n            k = (u // (2 ** (layer + 1))) * 2 + 1\n            layer -= 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n        elif s == 'L':\n            k = (u // (2 ** (layer + 1))) * 2\n            layer -= 1\n            u = (2 ** (layer + 1)) * k + 2 ** layer\n    print(u)\n", "def solve(n, m):\n    h=m&-m\n    for c in input():\n        if c=='U' and m!=(n+1)>>1:\n            m+= -h if (m+h)%(h<<2)==0 else h\n            h<<=1\n        if c in 'LR' and h>1:\n            h>>=1\n            m+= -h if c=='L' else h\n    return m\n\nn, m=map(int, input().split())\nfor _ in range(m):\n    print(solve(n, int(input())))", "def process_moves(v, moves, n):\n    update = True\n    for m in moves:\n        if update:\n            bit_pos = 0\n            t = v\n            while t > 0:\n                if t & 1 == 1:\n                    break\n                t >>= 1\n                bit_pos += 1\n\n            power_of_2 = t == 1\n\n        if m == 'U':\n            if power_of_2:\n                new_v = v << 1\n            else:\n                new_v = v & ~(1 << bit_pos) | (1 << (bit_pos + 1))\n        elif m == 'L':\n            if power_of_2:\n                new_v = v >> 1\n            else:\n                if bit_pos > 0:\n                    new_v = v & ~(1 << bit_pos) | (1 << (bit_pos - 1))\n                else:\n                    new_v = 0\n        else:  # m == 'R'\n            if bit_pos > 0:\n                new_v = v | (1 << (bit_pos - 1))\n            else:\n                new_v = 0\n\n        if 1 <= new_v <= n:\n            update = True\n            v = new_v\n\n    return v\n\n\ndef main():\n    n, q = list(map(int, input().split()))\n    for i in range(q):\n        s = int(input())\n        moves = input()\n        print(process_moves(s, moves, n))\n\n\ndef __starting_point():\n    # import sys\n    # sys.stdin = open(\"D.txt\")\n    main()\n\n__starting_point()", "def greatest_pow2_divisor(x):\n    pow2 = 1\n    while x % pow2 == 0:\n        pow2 *= 2\n    return pow2 // 2\n\ndef parent(x):\n    pow2 = greatest_pow2_divisor(x)\n    if ((x + pow2) // (pow2 * 2)) % 2 == 1:\n    \treturn x + pow2\n    return x - pow2\n\ndef left(x):\n    if x % 2 == 1:\n    \treturn x\n    return x - greatest_pow2_divisor(x) // 2\n\ndef right(x):\n    if (x % 2 == 1):\n    \treturn x;\n    return x + greatest_pow2_divisor(x) // 2;\n\nnumbers = list(map(int, input().split()))\nn = numbers[0]\nq = numbers[1]\nroot = (n + 1) / 2\nfor i in range(q):\n\tu = int(input())\n\ts = input()\n\tfor c in s:\n\t\tif c == 'U':\n\t\t\tif u != root:\n\t\t\t\tu = parent(u)\n\t\tif (c == 'L'):\n\t\t\tu = left(u)\n\t\tif (c == 'R'):\n\t\t\tu = right(u)\n\tprint(u)\n", "n, m = map(int, input().split())\nfor i in range(m):\n    k = int(input())\n    d = k & -k\n    for q in input():\n        if q == 'U' and k != n + 1 >> 1:\n            k += d if (k + d) % (d << 2) else -d\n            d <<= 1\n        if q in 'LR' and d > 1:\n            d >>= 1\n            k += d if q == 'R' else -d\n    print(k)", "#!/usr/bin/env python3\n\n# solution after hunt:(\n\n[n, q] = list(map(int, input().strip().split()))\nbis = []\nfor i in range(q):\n\tu = int(input().strip())\n\ts = input().strip()\n\tbis.append((u, s))\n\nd = len(bin(n)[2:])\n\ndef getk(u):\n\tb = bin(u)\n\treturn len(b) - len(b.rstrip('0'))\n\n\ndef goLeft(u, k, d):\n\tif k == 0:\n\t\treturn (u, k)\n\telse:\n\t\treturn (u - 2**(k - 1), k - 1)\n\ndef goRight(u, k, d):\n\tif k == 0:\n\t\treturn (u, k)\n\telse:\n\t\treturn (u + 2**(k - 1), k - 1)\n\ndef goUp(u, k, d):\n\tif k == d - 1:\n\t\treturn (u, k)\n\telif getk(u + 2**k) == k + 1:\n\t\treturn (u + 2**k, k + 1)\n\telse:\n\t\treturn (u - 2**k, k + 1)\n\ngo = {'L': goLeft, 'R': goRight, 'U': goUp}\n\ndef process(u, s, d):\n\tk = getk(u)\n\tfor c in s:\n\t\t(u, k) = go[c](u, k, d)\n\treturn u\n\nfor u, s in bis:\n\tprint(process(u, s, d))\n", "def find(x):\n    if root==x:\n        u=root\n    else:\n        i=0\n        s=2**i\n        while x%s==0:\n            i+=1\n            s=2**i\n        s=s//2\n        y=i+1\n        if (x-s)%(2**y)!=0:\n            u=x-s\n        else:\n            u=x+s\n    return u\nn,q=list(map(int,input().split()))\nroot=(n+1)//2\nfor j in range(q):\n    n1=int(input())\n    str1=input()\n    for j in range(len(str1)):\n        up=find(n1)\n        if str1[j]=='U':\n            n1=(up)\n        elif n1%2==0:\n            if str1[j]=='L':\n                if n1!=root:\n                    n1=(n1-abs((up-n1)//2))\n                else:\n                    n1=(n1-n1//2)\n            elif str1[j]=='R':\n                if n1!=root:\n                    n1=(n1+abs((up-n1)//2))\n                elif n1%2==0:\n                    n1=n1+n1//2\n    print(n1)", "n, q = list(map(int,input().split()))\npar = n // 2 + 1\npar = len(list(bin(par)[2:]))\nfor i in range(q):\n    ui = int(input())\n    si = input()\n    temp = bin(ui)[2:]\n    now = len(temp)\n    num = list((par - now) * \"0\" + temp)\n    now = par - now\n    for i in range(len(num)):\n        if str(num[i]) == '1':\n            now = i\n    for i in si:\n        if i == \"U\":\n            if now == 0:\n                continue\n            num[now] = 0\n            now -= 1\n            num[now] = 1\n        elif i == \"L\":\n            if str(num[-1]) == '1':\n                continue\n            num[now] = 0\n            now += 1\n            num[now] = 1\n        else:\n            if str(num[-1]) == '1':\n                continue\n            now += 1\n            num[now] = 1\n    for i in range(par):\n        num[i] = str(num[i])\n    print(int(\"\".join(num),2))\n", "def maxx(n):\n\treturn n&-n\nn,q=map(int,input().split())\nroot=n//2+1\nwhile q>0:\n\tx=int(input())\n\ts=input()\n\n\tfor i in s:\n\t\tif i=='U' and x!=root:\n\t\t\tp=x+maxx(x)\n\t\t\tif x==p-maxx(p)//2:\n\t\t\t\tx=p\n\t\t\telse:\n\t\t\t\tx=x-maxx(x)\n\t\telif i=='L':\n\t\t\tx=x-maxx(x)//2\n\t\telif i=='R':\n\t\t\tx=x+maxx(x)//2\n\tq=q-1\n\tprint(x)", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\ndef hgt(x):\n    if x == 0: return -1\n    h = 0\n    while x&1 != 1:\n        h += 1\n        x = x>>1\n    return h\n\ndef up(x):\n    h = hgt(x)\n    g = x + (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    g = x - (1<<h)\n    if g > 0 and g < N and hgt(g) == h+1:\n        return g\n    return x\n\ndef left(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x - (1<<(h-1))\n    if g > 0:\n        return g\n    return x\n\ndef right(x):\n    h = hgt(x)\n    if h == 0:\n        return x\n    g = x + (1<<(h-1))\n    if g < N:\n        return g\n    return x\n\nN, q = map(int, input().split())\nN += 1\nfor _ in range(q):\n    p = int(input())\n    for c in input():\n        if c == 'U':\n            p = up(p)\n        elif c == 'R':\n            p = right(p)\n        else:\n            p = left(p)\n    print(p)"]
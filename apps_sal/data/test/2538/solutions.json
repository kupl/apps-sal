["for TT in range(1, int(input()) + 1):\n    a, b, c = map(int, input().split())\n    l = max(-1, (b + c - a) // 2)\n    r = c\n    print(r - l if r >= l else 0)", "for _ in range(int(input())):\n    a,b,c=map(int,input().split())\n    total=1+(a+b+c)//2\n    print(max(0,a+c-max(total,a)+1))", "t = int(input())\n\nfor _ in range(t):\n    s, i, e = list(map(int, input().split()))\n\n    half = (s + i + e) // 2\n    maxeven = half + 1\n    maxeven = max(maxeven, s)\n\n    print(max(s + e - maxeven + 1, 0))\n", "T = int(input())\nfor i in range(T):\n    s, k, f = map(int, input().split())\n    print(min(f + 1, max(0, (s + f - k + 1) // 2)))", "T = int(input())\nfor t in range(T):\n    s, i, e = list(map(int, input().split()))\n    min_s = max((s + i + e)//2 + 1, s)\n    max_s = s + e\n    c = max(0, max_s-min_s+1)\n    print(c)\n", "for cas in range(int(input())):\n    a, b, c = map(int, input().split())\n    l = (b + c - a) // 2 + 1\n    r = c\n    print(max(0, r - max(l, 0) + 1))", "for i in range(int(input())):\n    a,b,c = list(map(int,input().split()))\n    if a+c <= b:\n        print(0)\n    else:\n        print(min((a+c-b+1)//2,c+1))\n", "T = int(input())\nfor i in range(T):\n    s, i, e = list(map(int, input().split()))\n    if s > i + e:\n        a = e + 1\n    else:\n        a = min((s+e-i-1)//2 + 1, e)\n    if a <= 0:\n        print(0)\n    else:\n        print(a)\n", "for _ in range(int(input())):\n    s, i, e = list(map(int, input().split()))\n    if s + e <= i:\n        print('0')\n    elif s > i + e:\n        print(e + 1)\n    else:\n        print((e + s + 1 - i) // 2)\n", "T = int(input())\nfor _ in range(T):\n    a, b, c = list(map(int, input().split()))\n    print(max(c+1 - max((-a+b+c+2)//2, 0), 0))\n\n", "from sys import stdin\ninput = stdin.readline\n\nfor _ in range(int(input())):\n    s, i, e = [int(i) for i in input().split()]\n    \n    x = (i+e-s)//2\n    \n    if x < 0: print(e+1)\n    elif x > e: print(0)\n    else: print(e-x)", "n=int(input())\nfor i in range(n):\n    a,b,c=[int(x) for x in input().split()]\n    l=0\n    r=c\n    while r-l>1:\n        mid=(l+r)//2\n        if a + mid >b+c-mid:\n            r=mid\n        else:\n            l=mid\n    if a>b+c:\n        print(c+1)\n    elif a+ r >b+c-r:\n        print(c-r+1)\n    \n    else:\n        print(0)\n    \n            \n", "for _ in range(int(input())):\n    ans = 0\n    cnt = 0\n    s, i, e = list(map(int, input().split()))\n    b = (s - i + e - 1) // 2\n    if b < 0:\n        print(0)\n    elif b == 0:\n        print(1)\n    elif b >= e:\n        print(e + 1)\n    else:\n        print(b + 1)\n\n", "n = int(input())\nfor i in range(n):\n    s, i, e = (int(i) for i in input().split())\n    if s > i + e:\n        print(e + 1)\n    elif s + e <= i:\n        print(0)\n    else:\n        r = s - i\n        r = e + r\n        t = 0\n        if r % 2:\n            t = 1\n        r = r // 2\n        if t:\n            r += 1\n        print(r)\n", "T = int(input())\nfor i in range(0, T):\n    s, i, exp = (int(i) for i in input().split())\n    if (s + exp <= i):\n        print(0)\n    elif (i + exp < s):\n        print(exp + 1)\n    else:\n        print(exp + 1 - (i + exp - s + 2) // 2)", "import math\nn = int(input())\nfor i in range(n):\n    a, b, c = [int(item) for item in input().split()]\n    ans = min(c+1, max(0, math.ceil(((a - b) + c) / 2)))\n    print(ans)", "for _ in range(int(input())):\n    \n    s, i, e = map(int, input().split())\n    \n    lo, hi, res = 0, e, 0\n\n    if s + e <= i:\n        print(0)\n        continue\n\n    while lo <= hi:\n\n        mi = (lo + hi) // 2\n\n        if s + mi > i + (e - mi):\n            res = mi\n            hi = mi - 1\n        else:\n            lo = mi + 1\n    \n    print(e - res + 1)", "t = int(input())\nfor _ in range(t):\n    s, i, e = list(map(int, input().split()))\n    if s + e <= i:\n        print(0)\n        continue\n    if i + e < s:\n        print(e + 1)\n        continue\n    mx = s + e\n    dif = abs(s - i)\n    if s > i:\n        i += dif\n    else:\n        s += dif\n    e -= dif\n    mn = s + e // 2 + 1\n    print(mx - mn + 1)\n", "import math\nntc = int(input())\nfor tcs in range(ntc):\n    s, i, e = list(map(int, input().split()))\n    if s + e > i:\n        res = math.ceil(((s + e) - i) / 2)\n        print(min(res, e+1))\n    else:\n        print(0)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n                (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = True\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    s, i, e = get_tuple()\n    print(min(max(0, (s+e+1-i)//2), e+1))\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "n = int(input())\nfor i in range(n):\n    s, i, e = map(int, input().split())\n    print(min(max(0, (s - i + e + 1) // 2), e + 1))", "import sys \nimport math \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nfor t in range(int(input())):\n  s, i, e = map(int, input().split())\n  \n  x = (i + e - s) / 2\n\n  if x < 0:\n    print(e + 1)\n  \n  elif x == 0:\n    print(e)\n\n  elif x >= e:\n    print(0)\n  \n  else:\n    print(e - int(x))", "t = int(input())\nwhile (t > 0):\n    t -= 1\n    s, i, e = [int(x) for x in input().split()]\n    ms = s + e\n    if (ms <= i):\n        print(0)\n    else:\n        c = (ms - i + 1) // 2\n        print(min(c, e + 1))\n", "for q in range(int(input())):\n    x, y, z = list(map(int, input().split()))\n    if x <= y:\n        z -= y-x+1\n        if z < 0:\n            print(0)\n        else:\n            print(z//2+1)\n    elif z < x-y:\n        print(z+1)\n    else:\n        z -= x-y+1\n        print(x-y+z//2+1)\n"]
["n, a, r, m = map(int, input().split())\nh = list(map(int, input().split()))\nm = min(m, a+r)\n\ndef get(M):\n\tup = 0\n\tdw = 0\n\tfor e in h:\n\t\tif e > M:\n\t\t\tup += e - M\n\t\telse:\n\t\t\tdw += M - e\n\tans = m * min(dw, up)\n\tif dw > up:\n\t\tans += (dw - up) * a\n\telse:\n\t\tans += (up - dw) * r\n\treturn ans\n\n\nL = 0\nR = int(1e9)\nmn = int(1e18)\n\nwhile R - L > 10:\n\tM1 = L + (R - L) // 3\n\tM2 = R - (R - L) // 3\n\tV1 = get(M1)\n\tV2 = get(M2)\n\tmn = min(mn, V1)\n\tmn = min(mn, V2)\n\tif V1 < V2:\n\t\tR = M2\n\telif V2 < V1:\n\t\tL = M1\n\telse:\n\t\tL = M1\n\t\tR = M2\n\nfor it in range(L, R+1):\n\tmn = min(mn, get(it))\n\nprint(mn)", "def read_int():\n    return int(input())\n\n\ndef read_ints():\n    return list(map(int, input().split(' ')))\n\n\nn, a, r, m = read_ints()\nh = list(read_ints())\nh.sort()\nlo = h[0]\nhi = h[-1]\ns = [0]\nfor i in h:\n    s.append(s[-1] + i)\nans = int(1e20)\nfor i in range(n):\n    target = h[i]\n    inc = i * target - s[i]\n    dec = s[n] - s[i + 1] - (n - i - 1) * target\n    plan_a = inc * a + dec * r\n    plan_b = (inc - dec) * a + dec * \\\n        m if inc >= dec else inc * m + (dec - inc) * r\n    ans = min(ans, min(plan_a, plan_b))\navg = s[n] // n\nfor target in range(max(0, avg - 1), avg + 2):\n    inc = 0\n    dec = 0\n    for i in h:\n        if i > target:\n            dec += i - target\n        else:\n            inc += target - i\n    plan_a = inc * a + dec * r\n    plan_b = (inc - dec) * a + dec * \\\n        m if inc >= dec else inc * m + (dec - inc) * r\n    ans = min(ans, min(plan_a, plan_b))\nprint(ans)\n", "import sys\nimport math\nimport bisect\n\ndef query_value(A, a, r, m, target):\n    n = len(A)\n    more_val = 0\n    less_val = 0\n    for i in range(n):\n        if A[i] > target:\n            more_val += A[i] - target\n        elif A[i] < target:\n            less_val += target - A[i]\n    move_val = min(more_val, less_val)\n    val1 = more_val * r + less_val * a\n    val2 = (more_val - move_val) * r + (less_val - move_val) * a + (move_val) * m\n    '''\n    print('n: %d, a, %d, r: %d, m: %d' % (n, a, r, m))\n    print('more_val: %d, less_val: %d, move_val: %d' % (more_val, less_val, move_val))\n    print('val1: %d' % (val1))\n    print('val2: %d' % (val2))\n    print('target: %d, val: %d' % (target, min(val1, val2)))\n    '''\n    return min(val1, val2)\n\ndef main():\n    n, a, r, m = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    left = min(A)\n    right = max(A)\n    while right - left > 2:\n        #print('left: %d, right: %d' % (left, right))\n        m1 = left + (right - left) // 3\n        m2 = left + (right - left) // 3 * 2\n        val1 = query_value(A, a, r, m, m1)\n        val2 = query_value(A, a, r, m, m2)\n        if val1 <= val2:\n            right = m2\n        else:\n            left = m1\n    B = []\n    for i in range(left, right + 1):\n        val = query_value(A, a, r, m, i)\n        B.append(val)\n    print(min(B))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport bisect\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n, a, r, m = nm()\n    hl = nl()\n    shl = [0]*(n+1)\n    hl.sort()\n    for i in range(n):\n        shl[i+1] = shl[i] + hl[i]\n\n    def cost(x):\n        lidx = bisect.bisect_left(hl, x)\n        ridx = bisect.bisect_right(hl, x)\n        much = shl[-1] - shl[ridx] - x * (n - ridx)\n        less = x * lidx - shl[lidx]\n        # print(x, lidx, ridx, much, less)\n        res = min(m, a+r) * min(much, less)\n        if much > less:\n            res += r * (much - less)\n        else:\n            res += a * (less - much)\n        return res\n\n    # print([cost(i) for i in range(10)])\n    lo, hi = min(hl) - 1, max(hl) + 1\n    while hi - lo > 3:\n        mlo = (hi + lo*2)//3\n        mhi = (hi*2 + lo)//3\n        # print(mlo, cost(mlo))\n        if cost(mlo) < cost(mhi):\n            hi = mhi\n        else:\n            lo = mlo\n    print(min(cost(i) for i in range(lo, hi+1)))\n    return\n\nsolve()\n\n# T = ni()\n# for _ in range(T):\n#     solve()\n", "N, A, R, M = list(map(int, input().split()))\nif M > A + R:\n    M = A + R\n    \nh = list(map(int, input().split()))\n\ndef calc(final):\n    adds = 0\n    removes = 0\n\n    for v in h:\n        if v > final:\n            removes += (v - final)\n        else:\n            adds += (final - v)\n\n    moves = min(adds, removes)\n    return M * moves + A * (adds - moves) + R * (removes - moves)\n\nlo = -1 #Higher than next\nhi = 10 ** 9 + 1\n\nwhile hi - lo > 1:\n    test = (lo + hi) // 2\n\n    if calc(test) > calc(test + 1):\n        lo = test\n    else:\n        hi = test\n\nprint(calc(hi))\n", "n, a, ra, m = list(map(int, input().split()))\nh = list(map(int, input().split()))\nif a + ra < m:\n    l, r = 0, 10 ** 9 + 1\n    for _ in range(50):\n        c1 = (l * 2 + r) // 3\n        c2 = (l + r * 2) // 3\n        p1 = 0\n        p2 = 0\n        q1 = 0\n        q2 = 0\n        for x in h:\n            if c1 <= x:\n                q1 += x - c1\n            else:\n                p1 += c1 - x\n            if c2 <= x:\n                q2 += x - c2\n            else:\n                p2 += c2 - x\n        f1 = p1 * a + q1 * ra\n        f2 = p2 * a + q2 * ra\n        if f1 > f2:\n            l = c1\n        else:\n            r = c2\n    c1 = l + 1\n    p1 = 0\n    q1 = 0\n    for x in h:\n        if c1 <= x:\n            q1 += x - c1\n        else:\n            p1 += c1 - x\n    f1 = p1 * a + q1 * ra\n    print(f1)\nelse:\n    l, r = 0, 10 ** 9 + 1\n    for _ in range(55):\n        c1 = (l * 2 + r) // 3\n        c2 = (l + r * 2) // 3\n        p1 = 0\n        p2 = 0\n        q1 = 0\n        q2 = 0\n        for x in h:\n            if c1 <= x:\n                q1 += x - c1\n            else:\n                p1 += c1 - x\n            if c2 <= x:\n                q2 += x - c2\n            else:\n                p2 += c2 - x\n        if p1 > q1:\n            f1 = q1 * m + (p1 - q1) * a\n        else:\n            f1 = p1 * m + (q1 - p1) * ra\n        if p2 > q2:\n            f2 = q2 * m + (p2 - q2) * a\n        else:\n            f2 = p2 * m + (q2 - p2) * ra\n        if f1 > f2:\n            l = c1\n        else:\n            r = c2\n    c1 = l + 1\n    p1 = 0\n    q1 = 0\n    for x in h:\n        if c1 <= x:\n            q1 += x - c1\n        else:\n            p1 += c1 - x\n    if p1 > q1:\n        f1 = q1 * m + (p1 - q1) * a\n    else:\n        f1 = p1 * m + (q1 - p1) * ra\n    print(f1)\n", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    N, A, R, M = map(int, input().split())\n    H = [int(h) for h in input().split()]\n    H.sort()\n    tB = [0] * (N + 1)\n    for i, h in enumerate(H): tB[i+1] = tB[i] + h\n    minCost = 10 ** 20\n    for i in range(N):\n        toAdd = H[i] * i - tB[i]\n        toSub = tB[N] - tB[i+1] - H[i] * (N - i - 1)\n        if M >= A + R: minCost = min(minCost, A * toAdd + R * toSub)\n        else:\n            mN = min(toAdd, toSub)\n            minCost = min(minCost, A * (toAdd - mN) + R * (toSub - mN) + M * mN)\n    if M < A + R:\n        sumH = sum(H)\n        lcost = 0\n        hcost = 0\n        fH = sumH // N\n        for i, h in enumerate(H):\n            if h < fH: lcost += (fH - h) * M\n            if h > fH + 1: hcost += (h - fH - 1) * M\n        lcost += (sumH % N) * R\n        hcost += (N - (sumH % N)) * A\n        minCost = min(minCost, lcost)\n        minCost = min(minCost, hcost)\n    \n    print(minCost)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\nimport bisect\n\nN,A,R,M=list(map(int,input().split()))\nW=sorted(map(int,input().split()))\nSUM=list(accumulate(W))\nSW=SUM[-1]\n\nindmin=0\nindmax=1\nANS=1<<62\n\ndef calc(MINUS,PLUS,A,R,M):\n\n    RET1=MINUS*A+PLUS*R\n    MIN=min(MINUS,PLUS)\n    \n    RET2=MIN*M+(MINUS-MIN)*A+(PLUS-MIN)*R\n\n    return min(RET1,RET2)\n\n\nwhile indmin<N:\n    while indmax<N and W[indmax]==W[indmin]:\n        indmax+=1\n\n    ave=W[indmin]\n    MINUS=ave*(indmin+1)-SUM[indmin]\n    PLUS=SW-SUM[indmax-1]-ave*(N-indmax)\n\n    ANS=min(ANS,calc(MINUS,PLUS,A,R,M))\n\n    #print(MINUS,PLUS,calc(MINUS,PLUS,A,R,M))\n    \n    indmin=indmax\n    indmax+=1\n\nAVE=SW//N\n\nfor ave in range(max(W[0],AVE-10**4),min(AVE+10**4,W[-1])):\n    indmin=bisect.bisect_left(W,ave)\n    if W[indmin]==ave:\n        continue\n    indmin,indmax=indmin-1,indmin\n\n    MINUS=ave*(indmin+1)-SUM[indmin]\n    PLUS=SW-SUM[indmax-1]-ave*(N-indmax)\n\n    ANS=min(ANS,calc(MINUS,PLUS,A,R,M))\n\n    #print(ave,indmin,indmax,MINUS,PLUS,ANS)\n    \n\nprint(ANS)\n\n\n\n\n", "n,a,r,m = [int(x) for x in input().split()]\n\nheight =[int(x) for x in input().split()]\nhmax = max(height)\nheight.sort()\n\ndef tellCost(h):\n    cost = 0\n    add,remove = 0,0\n    for i in range(n):\n        if h > height[i]:\n            add += abs(h-height[i])\n        else:\n            remove += abs(h-height[i])\n    move = min(remove,add)\n    if a+r >= m:\n        cost += m*move\n        if add > remove:\n            cost += abs(add-remove)*a\n        else:\n            cost += abs(add-remove)*r\n    else:\n        cost += add*a\n        cost += remove*r\n    return cost\n\n\ns,e = 0,hmax\n\nwhile s < e:\n    mid = (s+e)//2\n    cost1,cost2 = tellCost(mid),tellCost(mid+1)\n    if cost2 > cost1:\n        e = mid\n    else:\n        s = mid + 1\nprint(tellCost(s))", "import sys\n\ninput = sys.stdin.readline\n\ndef bin(l, r, c):\n\tif l == r:\n\t\treturn l\n\tm = (l + r + 1) // 2\n\tif h[m] <= c:\n\t\treturn bin(m, r, c)\n\telse:\n\t\treturn bin(l, m - 1, c)\n\ndef cost(c, move):\n\tres = 0\n\ti = 0\n\tif c >= h[-1]:\n\t\ti = n - 1\n\telse:\n\t\ti = bin(0, n - 1, c)\n\n\tres += a * ((i + 1) * c - H[i + 1])\n\tres += r * (H[-1] - H[i + 1] - (n - i - 1) * c)\n\tif move:\n\t\tres -= (a + r - m) * min((i + 1) * c - H[i + 1], H[-1] - H[i + 1] - (n - i - 1) * c)\n\treturn res\n\nn, a, r, m = list(map(int, input().split()))\nh = list(map(int, input().split()))\nh.sort()\nH = [None] * (n + 1)\nH[0] = 0\nfor i in range(1, n + 1):\n\tH[i] = H[i - 1] + h[i - 1]\nmove = m < a + r\nif not move:\n\tprint(min(cost(h[i], move) for i in range(n)))\nelse:\n\ttt = min(cost(H[-1] // n, move), cost(H[-1] // n + 1, move))\n\tttt = min(cost(h[i], move) for i in range(n))\n\tprint(min(tt, ttt))\n", "import sys\nfrom copy import copy\n\ninput = sys.stdin.readline\n\ndef find(l, ile):\n    pocz = 0\n    kon = len(l) - 1\n    while pocz + 1 < kon:\n        mid = (pocz + kon) // 2\n        if l[mid] < ile:\n            pocz = mid\n        else:\n            kon = mid\n    return pocz\n\ndef solve(l, sumpref, ile, A, R, M):\n    pos = find(l, ile)\n    \n    dol = ile * (pos + 1) - sumpref[pos]\n    gora = sumpref[-1] - sumpref[pos] - ile * (len(l) - pos - 1)\n    \n    m = min(dol, gora)\n    return min(dol * A + gora * R, (dol - m) * A + (gora - m) * R + m * M)\n\nn, A, R, M = [int(a) for a in input().split()]\nl = [int(a) for a in input().split()]\nl.sort()\npocz = l[0]\nkon = l[-1]\nsumpref = l.copy()\nfor i in range(1, len(sumpref)):\n    sumpref[i] += sumpref[i - 1]\n\nwhile pocz + 6 < kon:\n    x = (2 * pocz + kon) // 3\n    y = (pocz + 2 * kon) // 3\n    \n    s = [solve(l, sumpref, lol, A, R, M) for lol in [pocz, x, y, kon]]\n    ms = min(s)\n    if s[0] == ms or s[1] == ms:\n        kon = y\n    else:\n        pocz = x\n    \nprint(min([solve(l, sumpref, lol, A, R, M) for lol in range(pocz, kon + 1)]))\n", "import os\nimport sys\nif os.path.exists('/mnt/c/Users/Square/square/codeforces'):\n    f = iter(open('E.txt').readlines())\n    def input():\n        return next(f)  \nelse:\n    input = lambda: sys.stdin.readline().strip()\n\nfprint = lambda *args: print(*args, flush=True)\n\nN, A, R, M = map(int, input().split())\nH = list(map(int, input().split()))\nH = sorted(H)\n\nM = min(M, A+R)\n\ndef calc(height):\n    for cur in range(len(H)):\n        if H[cur] >= height:\n            break\n    if H[cur] < height:\n        cur += 1\n\n    up, down = 0, 0\n    # print(height, cur, N, H[cur], H)\n    for h in H[:cur]:\n        down += (height-h)\n    for h in H[cur:]:\n        up += (h - height)\n\n    if up >= down:\n        return down * M + (up-down) * R\n    else:\n        return up * M + (down - up) * A\n\n# print(calc(8))\n\n# print(Hs)\nl, r = 0, max(H)+1\nwhile l + 1 < r:\n    cur = (l + r) // 2\n    if calc(cur) < calc(cur+1):\n        r = cur\n    else:\n        l = cur\n# print(l, r)\n# print(calc(l), calc(r))\nprint(min(calc(l), calc(r)))\n", "N,A,R,M=map(int,input().split())\nh=list(map(int,input().split()))\nif A*R==0:\n    print(0)\n    return\n\nif M>A+R:\n    def condition(num):\n        test=0\n        for i in range(N):\n            if num>h[i]:\n                test+=A\n            else:\n                test-=R\n        return 0>=test\n    start=1\n    end=10**10\n    while end-start>1:\n        test=(end+start)//2\n        if condition(test):\n            start=test\n        else:\n            end=test\n    if condition(end):\n        ans=0\n        for i in range(N):\n            if end>h[i]:\n                ans+=A*(end-h[i])\n            else:\n                ans+=R*(h[i]-end)\n        print(ans)\n    elif condition(start):\n        ans=0\n        for i in range(N):\n            if start>h[i]:\n                ans+=A*(start-h[i])\n            else:\n                ans+=R*(h[i]-start)\n        print(ans)\n    else:\n        print(R*sum(h))\nelse:\n    H=sum(h)\n    q=H//N\n    #0~q\u5f3e\u3067\u8003\u3048\n    test1=0\n    def condition1(num):\n        count=0\n        for i in range(N):\n            count+=int((h[i]<num))\n        return 0>=M*count-R*N\n\n    start=1\n    end=q\n    while end-start>1:\n        test=(end+start)//2\n        if condition1(test):\n            start=test\n        else:\n            end=test\n    if condition1(end):\n        for i in range(N):\n            if end>h[i]:\n                test1+=M*(end-h[i])\n        test1+=R*(H-N*end)\n    elif condition1(start):\n        for i in range(N):\n            if start>h[i]:\n                test1+=M*(start-h[i])\n        test1+=R*(H-N*start)\n    else:\n        test1=H*R\n\n    #q+1~max(h)\n    test2=0\n    def condition2(num):\n        count=0\n        for i in range(N):\n            count+=int((h[i]>num))\n        return 0>=count*M-A*N\n    start=q+1\n    end=max(h)-1\n    while end-start>1:\n        test=(end+start)//2\n        if condition2(test):\n            end=test\n        else:\n            start=test\n    if condition2(start):\n        for i in range(N):\n            if h[i]>=start:\n                test2+=M*(h[i]-start)\n        test2+=A*(N*start-H)\n    elif condition2(end):\n        for i in range(N):\n            if h[i]>=end:\n                test2+=M*(h[i]-end)\n        test2+=A*(N*end-H)\n    else:\n        test2=A*(N*max(h)-H)\n    print(min(test1,test2))", "\nimport bisect\nN, A, R, M = list(map(int, input().split()))\n\naa = sorted(map(int, input().split()))\n\nraa = [0]\nfor a in aa:\n    raa.append(raa[-1] + a)\n\nans = 10 ** 15\n\n\n# a \u306b\u63c3\u3048\u308b\u6642\u306e\u30b3\u30b9\u30c8\ndef calc(a):\n    i = bisect.bisect_right(aa, a)\n    add_n = a * i - raa[i]\n    rem_n = (raa[-1] - raa[i]) - (a * (N - i))\n\n    # move \u3059\u308b\n    if rem_n < add_n:\n        tmp1 = rem_n * M + (add_n - rem_n) * A\n    else:\n        tmp1 = add_n * M + (rem_n - add_n) * R\n\n    # move \u3057\u306a\u3044\n    tmp2 = rem_n * R + add_n * A\n\n    return min(tmp1, tmp2)\n\n\nans = min([calc(a) for a in set(aa)])\n\ntmp = sum(aa) // N\n\nans = min([ans, calc(tmp), calc(tmp + 1)])\n\n\nprint(ans)\n"]
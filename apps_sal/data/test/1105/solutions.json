["n = int(input())\na = [-1]*100001\np = 0\nfor i in range(n):\n    x, k = map(int, input().split())\n    if a[k] < x-1:\n        p = 1\n    else:\n        a[k] = max(a[k],x)\nif p:\n    print('NO')\nelse:\n    print('YES')", "n = int(input())\n\nm = []\nd = dict()\n\nfor i in range(n):\n    x, k = map(int, input().split())\n\n    if k in d:\n        r = d[k]\n        if x > r+1:\n            print('NO')\n            return\n        d[k] = max(r, x)\n    else:\n        if x != 0:\n            print('NO')\n            return\n        d[k] = x\n\nprint('YES')", "n = int(input())\n\ntasks = {}\nfail = False\n\nfor i in range(n):\n\tx, k = list(map(int, input().split()))\n\tif k not in tasks:\n\t\tif x == 0:\n\t\t\ttasks[k] = {x}\n\t\telse:\n\t\t\tfail = True\n\t\t\tbreak\n\telse:\n\t\tif x == 0:\n\t\t\tif x in tasks[k]:\n\t\t\t\ttasks[k].add(x)\n\t\t\telse:\n\t\t\t\tfail = True\n\t\t\t\tbreak\n\t\telif x > 0:\n\t\t\tif (x-1) in tasks[k]:\n\t\t\t\ttasks[k].add(x)\n\t\t\telse:\n\t\t\t\tfail = True\n\t\t\t\tbreak\n\t\telse:\n\t\t\tfail = True\n\t\t\tbreak\n\nif fail:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")\n", "def readln(): return tuple(map(int, input().split()))\n\nn, = readln()\nmax_pref = [-1] * 100001\nflag = True\nfor _ in range(n):\n    x, k = readln()\n    flag &= max_pref[k] + 1 >= x\n    max_pref[k] = max(max_pref[k], x)\nprint('YES' if flag else 'NO')", "\n\nn = int(input())\n\nr = [\"NO\", \"YES\"]\n\nd = {}\n\nfor _ in range(n):\n    x, k = list(map(int, input().split(\" \")))\n    a = d.get(k, -1)\n    if a + 1 < x:\n        print(r[0])\n        return\n    elif a + 1 == x:\n        d[k] = x\n        \nprint(r[1])\n    \n", "p = {}\nfor i in range(int(input())):\n    x, k = map(int, input().split())\n    if k in p:\n        if x == p[k] + 1: p[k] = x\n        elif x > p[k]:\n            print('NO')\n            return\n    elif x:\n        print('NO')\n        return\n    else:\n        p[k] = 0\nprint('YES')", "n = int(input())\nres = 'YES'\nuch = {}\nzap= [0,0]\nfor i in range(0, n):\n    zap = list(map(int, input().split()))\n    if zap[1] in uch:\n        if zap[0] == uch[zap[1]] + 1:\n            uch[zap[1]] = zap[0]\n        else:\n            if zap[0] > uch[zap[1]] + 1:\n                res = 'NO'\n    else:\n        if zap[0] == 0:\n            uch[zap[1]] = zap[0]\n        else:\n            res = 'NO'\nprint(res)\n\n", "all = {}\nn = int(input())\nans = True\nfor i in range(n):\n    x_k = input().split()\n    x = int(x_k[0])\n    k = int(x_k[1])\n    if k not in all:\n        all[k] = -1\n    if all[k] >= x:\n        pass\n    elif all[k]+1 != x:\n        ans = False\n        break\n    else:\n        all[k] = x\n\n\nif ans:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "import sys\nfrom array import array\n\nf = sys.stdin\nn = int(f.readline())\nans = 'YES'\nsubmissions = [0]*n\ni = 0\nfor line in f:\n    arr = line.split(\" \")\n    x = int(arr[0])\n    k = int(arr[1]) - 1\n    while(k < 0 or k >= len(submissions)):\n        submissions.extend([0]*len(submissions))\n    if(submissions[k] < x):\n        ans = 'NO'\n        break\n    if(submissions[k] == x):\n        submissions[k] = submissions[k] + 1\n    i = i + 1\n    if(i >= n):\n        break\nprint(ans)\n", "#the basic idea is to use a dict to record every participant's submission\n\nn = int(input())\nparticipants = {}\norder = True\nwhile n:\n\tn -= 1\n\tx, k = list(map(int,input().split()))\n\tif k in participants:\n\t\tif x in participants[k]:\n\t\t\tcontinue\n\t\telif x-1 in participants[k]:\n\t\t\tparticipants[k].add(x)\n\t\telse:\n\t\t\torder = False\n\t\t\tbreak\n\telse:\n\t\tif x != 0:\n\t\t\torder = False\n\t\t\tbreak\n\t\ttmp = set()\n\t\ttmp.add(x)\n\t\tparticipants[k] = tmp\n\n\nif order:\n    print(\"YES\")\nelse:\n    print(\"NO\") \n", "import sys\nfrom collections import defaultdict\n\nn = int(sys.stdin.readline())\nd = defaultdict(lambda:-1)\nfor i in range(0, n):\n  x, k = map(int, sys.stdin.readline().split())\n  z = d[k]\n  if x == z + 1:\n    d[k] = x\n  elif x > z + 1:\n    print('NO')\n    return\n\nprint('YES')", "\nimport sys\n#f = open('H:\\\\Portable Python 3.2.5.1\\\\test2.txt') \nf = sys.stdin\nn = int(f.readline().strip())\npeople = {}\nres = 'YES'\nfor i in range(n):\n    x, k = list(map(int, f.readline().strip().split()))\n    #print(x,people)\n    if k in people:\n        if x==people[k]+1:\n            people[k] = x\n        elif x<=people[k]:\n            pass\n        else:\n            res='NO'\n            break\n    else:\n        if x==0:\n            people[k] = x\n        else:\n            res='NO'\n            break    \n\nprint(res)\n", "sol=int(input())\nlist1=[]\nfor i in range(10**5+1):\n    list1.append([])\nfor i in range(sol):\n    a,b=input().split()\n    b=int(b)\n    list1[b].append(a)\ni=0\nv=True\nwhile i<10**5+1 and v:\n    j=0\n    z=-1\n    while j<len(list1[i]) and v:\n        if (int(list1[i][j])-z)==1:\n            z=int(list1[i][j])\n        elif int(list1[i][j])-z>1:\n            v=False\n        j+=1\n    i+=1\nif v==True:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n = int(input())\nd = {}\nfor i in range(n):\n\tp = list(map(int, input().split()))\n\tif p[0] == 0:\n\t\td[p[1]] = d.get(p[1], 0)\n\telse:\n\t\tif p[0] - d.get(p[1], -1) > 1:\n\t\t\tprint(\"NO\")\n\t\t\treturn\n\t\td[p[1]] = max(d[p[1]], p[0])\nprint(\"YES\")\t\t\n", "import sys\nimport math\n\nn = int(sys.stdin.readline())\n\nd = dict()\nfor i in range(n):\n    x, k = [int(x) for x in (sys.stdin.readline()).split()]\n    if k in d:\n        t = d[k]\n        if x not in t[1]:\n            if(x - 1 == t[0]):\n                t[0] = x\n                t[1].add(x)\n            else:\n                print(\"NO\")\n                return\n    else:\n        if(x > 0):\n            print(\"NO\")\n            return\n            \n        d[k] = [x, {x}]\n\nprint(\"YES\")\n", "c = [0] * 100001\nfor i in range(int(input())):\n    x, k = map(int, input().split())\n    if x == c[k]:\n        c[k] += 1\n    elif x > c[k]:\n        print('NO')\n        return\nprint('YES')", "n = int(input())\np = 0\na = []\nfor _ in range(n):\n    x, k = list(map(int, input().split()))\n    while k > len(a):\n        a.append(-1)\n    k = k - 1\n    if a[k] < x - 1:\n        print('NO')\n        return\n    else:\n        a[k] = max(x, a[k])\nprint('YES')", "n = int(input())\nks = []\nfor i in range(100001):\n  ks.append(-1)\nv = True\nfor i in range(n):\n  x, k = list(map(int, input().split()))\n  if v:\n    if x > ks[k] + 1:\n      v = False\n    elif x > ks[k]:\n      ks[k] = x\n\nif v:\n  print(\"YES\")\nelse:\n  print(\"NO\")\n", "c = [0] * 100001\nfor i in range(int(input())):\n    x, k = map(int, input().split())\n    if x == c[k]:\n        c[k] += 1\n    elif x > c[k]:\n        print('NO')\n        return\nprint('YES')", "def adds(s,x,k):\n\tif k in s.keys():\n\t\txs=s[k]\n\t\tif x<=xs:\n\t\t\treturn 0\n\t\telse:\n\t\t\tif x-1==xs:\n\t\t\t\ts[k]=x\n\t\t\t\treturn 0\n\t\t\telse:\n\t\t\t\treturn 1\n\telse:\n\t\tif x==0:\n\t\t\ts[k]=0\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 1\n\ndef corr(v):\n\ts=dict()\n\tfor c in v:\n\t\tif adds(s,c[0],c[1]):\n\t\t\treturn 0\n\treturn 1\n\nn=int(input())\nv=[]\nfor c in range(n):\n\tx,k=map(int,input().split(' '))\n\tv.append((x,k))\nif corr(v):\n\tprint('YES')\nelse:\n\tprint('NO')", "c = [0] * 100001\n\nfor i in range(int(input())):\n\n    x, k = list(map(int, input().split()))\n\n    if x == c[k]:\n\n        c[k] += 1\n\n    elif x > c[k]:\n\n        print('NO')\n\n        return\n\nprint('YES')\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\nn = int(input())\nc = [-1] * (10**5+1)\nfor i in range(n):\n    x,k = list(map(int,input().split()))\n    if c[k] < x-1:\n        print(\"NO\")\n        return\n    else:\n        c[k] = max(c[k],x)\n\nprint(\"YES\")\n", "n = int(input())\nuser = 100001 * [-1]\nfor i in range(n):\n  x, k = map(int, input().split())\n  if user[k] == x - 1:\n    user[k] = x\n  elif user[k] < x - 1:\n    print('NO')\n    return\nprint('YES')", "recovery = [-1]*100001\nsolution = int(input())\nfor s in range(solution):\n    sol,user = map(int,input().split())\n    if recovery[user] == sol - 1:\n        recovery[user] = sol\n    elif recovery[user] >= sol:\n        continue\n    else:\n        print('NO'); return\nprint ('YES')", "recovery = [-1]*100001\nsolution = int(input())\nfor s in range(solution):\n    sol,user = map(int,input().split())\n    # Consecutive numbers should be 1 apart \n    if recovery[user] == sol - 1:\n        recovery[user] = sol\n    # Skip duplicates\n    elif recovery[user] >= sol:\n        continue\n    else:\n    # exit out of the program \n        print('NO'); return\nprint ('YES')"]
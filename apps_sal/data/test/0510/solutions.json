["ii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(mi())\n\na, b, c, d = mi()\na, b, c = sorted([a, b, c])\nans = max(0, d - (b - a)) + max(0, d - (c - b))\nprint(ans)\n", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nx = list(map(int, input().split()))\nd = x.pop()\nx.sort()\nans = 0\nif x[1]-x[0] < d:\n    ans += d-x[1]+x[0]\nif x[2]-x[1] < d:\n    ans += d-x[2]+x[1]\nprint(ans)", "def __starting_point():\n    a, b, c, d = [int(x) for x in input().split()]\n    a, b, c = sorted([a, b, c])\n    print(max(a - (b - d), 0) + max(0, b + d - c))\n\n__starting_point()", "#!/usr/bin/env python\na, b, c, d = list(map(int, input().split()))\np = sorted([a, b, c])\nprint(max(0, d - (p[1] - p[0])) + max(0, d - (p[2] - p[1])))\n", "a,b,c,d=[int(x) for x in input().split()]\ne=sorted([a,b,c])\nprint(max(0,d-(e[1]-e[0]))+max(0,d-(e[2]-e[1])))\n", "*l, d = map(int, input().split())\n\nl.sort()\n\nprint(max(d - (l[1] - l[0]), 0) + max(d - (l[2] - l[1]), 0))", "a, b, c, d = map(int, input().split())\na, b, c = sorted((a, b, c))\nans = max(0, d - (b-a)) + max(0, d - (c-b))\nprint(ans)", "*p, d = list(map(int, input().split()))\np.sort()\n\nr = max(0, d - (p[1] - p[0])) + max(0, d - (p[2] - p[1]))\nprint(r)\n", "a,b,c,d = list(map(int,input().split()))\n\na,b,c = sorted([a,b,c])\n\ndist = 0\ndist += max(0, d - (b-a))\ndist += max(0, d - (c-b))\n\nprint(dist)\n", "def main():\n    a, b, c, d = map(int, input().split())\n    abc = sorted([a, b, c])\n    ans = 0\n    if abc[1] - abc[0] < d:\n        ans += abc[0] + d - abc[1]\n    if abc[2] - abc[1] < d:\n        ans += abc[1] + d - abc[2]\n    print(ans)\n    return 0\n\nmain()", "# n = int(input())\na, b, c, d = list(map(int, input().split()))\nt = [a, b, c]\nt.sort()\nans = 0\nif t[2] - t[1] <= d:\n    ans += d - t[2] + t[1]\nif t[1] - t[0] <= d:\n    ans += d - t[1] + t[0]\nprint(ans)\n# a = [int(i) for i in input().split()]\n", "a, b, c, d = list(map(int, input().split()))\na, b, c = sorted([a, b, c])\nprint(max(0, d - (b - a)) + max(0, d - (c - b)))\n", "a, b, c, d = list(map(int, input().split()))\na, b, c = sorted((a, b, c))\nres = 0\nif b - a < d:\n    res += d - (b - a)\nif c - b < d:\n    res += d - (c - b)\nprint(res)\n", "import math\nimport bisect\nimport heapq\nfrom collections import defaultdict\n\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\n\n\ndef mulinv(b, n):\n    g, x, _ = egcd(b, n)\n    if g == 1:\n        return x % n\n\n\ndef isprime(n):\n    for d in range(2, int(math.sqrt(n))+1):\n        if n % d == 0:\n            return False\n    return True\n\n\ndef argsort(ls):\n    return sorted(range(len(ls)), key=ls.__getitem__)\n\n\ndef f(p=0):\n    if p == 1:\n        return map(int, input().split())\n    elif p == 2:\n        return list(map(int, input().split()))\n    elif p == 3:\n        return list(input())\n    else:\n        return int(input())\n\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = [i for i in range(1, n+1)]\n        self.rank = [0]*(n+1)\n\n    def find_set(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find_set(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        set_x = self.find_set(x)\n        set_y = self.find_set(y)\n        if set_x!=set_y:\n            if self.rank[x]:\n                pass\n\n\ndef graph(n, m, edg=False):\n    edges = []\n    visited = [0]*n\n    g = [list() for _ in range(n+1)]\n    for i in range(m):\n        u, v = f(1)\n        g[u].append(v)\n        g[v].append(u)\n        if edg:\n            edges.append((u, v))\n\n    if edg:\n        return g, visited, edg\n    else:\n        return g, visited\n\n\ndef bfs(g, visited):\n    queue = [1]\n    visited[1] = 1\n    for u in queue:\n        for v in g[u]:\n            if visited[v] == 0:\n                queue.append(v)\n            visited[v] = 1\n\n\ndef dfs(u, g, visited):\n    visited[u] = 1\n    for v in g[u]:\n        if visited[v] == 0:\n            dfs(v, g, visited)\n\n\ncl = f(2)\n\nd = cl[-1]\ndel cl[-1]\ncl = sorted(cl)\na = cl[0]\nb = cl[1]\nc = cl[2]\n\nprint(max(0, d-(b-a))+max(0, d-(c-b)))", "a, b, c, d = map(int, input().split())\nA = [a, b, c]\na, b, c = sorted(A)\nprint(max(0, d - abs(a-b)) + max(0, d - abs(c-b)))", "a, b, c, d = map(int, input().split())\ns = sorted([a, b, c])\nprint(max(0, d - abs(s[1] - s[0])) + max(0, d - abs(s[-1] - s[1])))", "a,b,c,d=list(map(int, input().split()))\na,b,c=sorted((a,b,c))\nans=0\nif b-a<d:\n    ans+=d-(b-a)\nif c-b<d:\n    ans+=d-(c-b)\nprint(ans)\n", "A = list(map(int, input().split()))\nA, d = sorted(A[:3]), A[3]\nprint(max(0, d - A[1] + A[0]) + max(0, d - A[2] + A[1]))\n", "a, b, c, d = map(int, input().split())\nar = [a, b, c]\nar.sort()\nleft = max(0, d - abs(ar[1] - ar[0]))\nright = max(0, d - abs(ar[2] - ar[1]))\nprint(left + right)", "a, b, c, d = list(map(int, input().split()))\na, b, c = sorted([a, b, c])\nprint(max(d - (b - a), 0) + max(d - (c - b), 0))\n", "a,b,c,d=[int(k) for k in input().split(\" \")]\n\na,b,c=sorted([a,b,c])\n\nres=max(0,d-b+a)+max(0,d-c+b)\n\nprint(res)\n\n", "import sys\nimport math\ninput = sys.stdin.readline\n\na,b,c,d=map(int,input().split())\n\nl=[a,b,c]\nl.sort()\n\nd1=l[1]-l[0]\nd2=l[2]-l[1]\n\ncount=0\nif d1<d:\n\tcount+=d-d1\nif d2<d:\n\tcount+=d-d2\n\nprint(count)", "a, b, c, d = list(map(int, input().split()))\ns = [a, b, c]\ns.sort()\na, b, c = s\nprint(max(0, a - b + d) + max(0, b - c + d))\n", "a, b, c, d = list(map(int, input().split()))\na = [a, b, c]\na.sort()\nans = 0\nif a[1] - a[0] < d:\n    ans += a[0]+d-a[1]\nif a[2] - a[1] < d:\n    ans += a[1]+d-a[2]\nprint(ans) \n", "a,b,c,d=map(int,input().split())\ns=[a,b,c]\ns.sort()\nans=0\nif s[1]-s[0]<=d:\n    ans+=(d-(s[1]-s[0]))\n\nif s[2]-s[1]<=d:\n    ans+=(d-(s[2]-s[1]))\nprint(ans)"]
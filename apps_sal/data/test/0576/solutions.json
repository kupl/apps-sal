["import math \nN = 10**5 + 10\nu = [-1]*N\ndivi = [ [] for i in range(N) ] \npd = [ [] for i in range(N) ] \nmark = [0]*N\n\ndef precalc():\n    for i in range(1,N) :\n        for j in range(i,N,i) :\n            divi[j].append(i)\n\n    for i in range(2,N) : \n        if mark[i] == 1 : \n            continue\n        for j in range(i,N,i) :\n            pd[j].append(i)\n            mark[j] = 1\n\n    for i in range(1,N) : \n        for prm in pd[i] :\n            time = 0\n            _i = i \n            while _i % prm == 0 : \n                time += 1\n                _i /= prm\n            if time > 1 :\n                u[i] = 0\n                continue\n        if u[i] == -1 : \n            if len(pd[i]) & 1 :\n                u[i] = -1\n            else : \n                u[i] = 1\n    \nhas = [False]*N \ncnt = [0]*N\n\ndef has_coprime(n):\n    ret = 0\n    for d in divi[n] :\n        ret += u[d] * cnt[d]\n    return ret\n\ndef update(n,val) :\n    for d in divi[n] :\n        cnt[d] += val\n\n    \ndef solve(n) :\n    li = list(map(int,input().split()))\n    ans = 0\n    for i in range(n) : \n        if has[li[i]] : \n            ans = max(ans,li[i])\n        has[li[i]] = True\n\n    for g in range(1,N) :\n        st = [] \n        for num in reversed(list(range(1,N//g + 1))) :\n            if num*g > N-1 or not has[num*g]  : \n                continue\n            how_many = has_coprime(num)\n\n            while how_many > 0 : \n                #print(how_many)\n                now = st.pop()\n                if math.gcd(now,num) == 1 : \n                    ans = max(ans,num*now*g)\n                    how_many -= 1\n                update(now,-1)\n            st.append(num)\n            update(num,1)\n        while st :\n            update(st.pop(),-1)\n\n    print(ans)\n\nprecalc()\n\nwhile True : \n    try : \n        n = int(input())\n        solve(n)\n    except EOFError:\n        break\n", "import math \nN = 10**5 + 10\nu = [-1]*N\ndivi = [ [] for i in range(N) ] \npd = [ [] for i in range(N) ] \nmark = [0]*N\n\ndef precalc():\n    for i in range(1,N) :\n        for j in range(i,N,i) :\n            divi[j].append(i)\n        if i == 1 : u[i] = 1\n        elif (i//divi[i][1]) % divi[i][1] == 0 : u[i] = 0\n        else : u[i] = -u[i//divi[i][1]]\n    \nhas = [False]*N \ncnt = [0]*N\n\ndef has_coprime(n):\n    ret = 0\n    for d in divi[n] : ret += u[d] * cnt[d]\n    return ret\n\ndef update(n,val) :\n    for d in divi[n] :\n        cnt[d] += val\n\n    \ndef solve(n) :\n    li = list(map(int,input().split()))\n    ans = 0\n    for i in range(n) : \n        if has[li[i]] : ans = max(ans,li[i])\n        has[li[i]] = True\n\n    for g in range(1,N) :\n        st = [] \n        for num in reversed(list(range(1,N//g + 1))) :\n            if num*g > N-1 or not has[num*g] : \n                continue\n            how_many = has_coprime(num)\n\n            while how_many > 0 : \n                #print(how_many)\n                now = st.pop()\n                if math.gcd(now,num) == 1 : \n                    ans = max(ans,num*now*g)\n                    how_many -= 1\n                update(now,-1)\n            st.append(num)\n            update(num,1)\n        while st :\n            update(st.pop(),-1)\n\n    print(ans)\n\nprecalc()\n\nwhile True : \n    try : \n        n = int(input())\n        solve(n)\n    except EOFError:\n        break\n"]
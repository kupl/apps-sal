["import heapq\n\nn,k=list(map(int,input().split()))\nS=[list(map(int,input().split())) for i in range(n)]\n\nS.sort(key=lambda x:x[1],reverse=True)\n\nANS=0\nLENGTH=0\nH=[]\n\nfor x,y in S:\n    heapq.heappush(H,x)\n    LENGTH+=x\n    if len(H)>k:\n        z=heapq.heappop(H)\n        LENGTH-=z\n        \n    if ANS<LENGTH*y:\n        ANS=LENGTH*y\n\nprint(ANS)\n", "import heapq\nimport sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nS=[list(map(int,input().split())) for i in range(n)]\n\nS.sort(key=lambda x:x[1],reverse=True)\n\nANS=0\nLENGTH=0\nH=[]\n\nfor x,y in S:\n    heapq.heappush(H,x)\n    LENGTH+=x\n    if len(H)>k:\n        z=heapq.heappop(H)\n        LENGTH-=z\n        \n    if ANS<LENGTH*y:\n        ANS=LENGTH*y\n\nprint(ANS)\n", "import heapq\nn, k = list(map(int, input().split()))\nmusic = []\nfor i in range(n):\n    length, beauty = list(map(int, input().split()))\n    music.append((beauty, length))\nmusic.sort(reverse=True)\ns = []\nma = 0\nsumlength = 0\n# print(music)\nfor i in range(n):\n    if len(s) == k:\n        t = heapq.heappushpop(s, music[i][1])\n    else:\n        heapq.heappush(s, music[i][1])\n        t = 0\n    sumlength += music[i][1] - t\n    # print(sumlength)\n    ma = max(sumlength * music[i][0], ma)\nprint(ma)\n", "import heapq\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nN, K = list(map(int, input().split()))\nsongs = [list(map(int, input().split())) for _ in range(N)]\n\nsongs = sorted(songs, key=lambda x: x[1], reverse=True)\n\n# print(songs)\nans = -float('inf')\nS = []\ntmpS = 0\nfor t, v in songs:\n    if len(S) < K:\n        heapq.heappush(S, t)\n        tmpS += t\n        minB = v\n    else:\n        # print(S)\n        if S[0] <= t:\n            tmpS = tmpS-S[0]+t\n            heapq.heappop(S)\n            heapq.heappush(S, t)\n            minB = v\n    #print(\"tmp->\", minB*tmpS)\n    ans = max(ans, minB*tmpS)\nprint(ans)\n", "import sys\nimport heapq\n\n\ndef input():\n    return sys.stdin.readline()\n\n\nn, k = list(map(int, input().split()))\narr = [(0, 0)] * n\nfor i in range(n):\n    t, b = list(map(int, input().split()))\n    arr[i] = (t, b)\narr.sort(key=lambda x: (-x[1], -x[0]))\nsum_length = 0\nheap_length = []\nfor i in range(k):\n    sum_length += arr[i][0]\n    heapq.heappush(heap_length, arr[i][0])\nmin_beauty = arr[k-1][1]\nanswer = sum_length * min_beauty\nfor i in range(k, n):\n    min_beauty = arr[i][1]\n    min_length = heapq.heappop(heap_length)\n    temp = arr[i][0] - min_length\n    if temp > 0:\n        sum_length += temp\n        heapq.heappush(heap_length, arr[i][0])\n    else:\n        heapq.heappush(heap_length, min_length)\n    answer = max(answer, sum_length * min_beauty)\nsum_length = 0\nfor i in range(k):\n    sum_length += arr[i][0]\n    min_beauty = arr[i][1]\n    answer = max(answer, sum_length * min_beauty)\nprint(answer)\n", "import heapq\n\nn, k = map(int, input().split())\n\nsongs = [(0, 0) for i in range(n)]\n\nfor i in range(n):\n    songs[i] = tuple(map(int, input().split()))\n\nsongs.sort(key=lambda x: x[1], reverse=True)\n\nheap = []\nmax_ = 0\nlength = 0\nfor i in range(n):\n    if i >= k:\n        l = heapq.heappushpop(heap, songs[i][0])\n        length = length - l + songs[i][0]\n    else:\n        length += songs[i][0]\n        heapq.heappush(heap, songs[i][0])\n    max_ = max(max_, length * songs[i][1])\n\nprint(max_)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/22 23:41\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Playlist.py\n\nimport atexit\nimport io\nimport sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n_OUTPUT_BUFFER = io.StringIO()\nsys.stdout = _OUTPUT_BUFFER\n\n\n@atexit.register\ndef write():\n    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\n\nimport heapq\n\n\ndef main():\n    n, k = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, b = map(int, input().split())\n        songs.append((b, t))\n    songs.sort(reverse=True)\n    # print(songs)\n\n    ret = 0\n    curr_count, curr_sum = 0, 0\n    h = []\n    for i in range(n):\n        b, t = songs[i]\n        heapq.heappush(h, t)\n        curr_sum += t\n        curr_count += 1\n        if curr_count > k:\n            curr_sum -= heapq.heappop(h)\n            curr_count -= 1\n        ret = max(ret, curr_sum * b)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\nimport sys\nimport heapq\n\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n#lines = stdin.readlines()\n\nn, k = rint()\n\nt = []\nb = []\nind = []\nfor i in range(n):\n    tt, bb =  rint()\n    t.append(tt)\n    b.append(bb)\n    ind.append(i)\n\nind.sort(key = lambda i: (-b[i], -t[i]))\n#print(ind)\n\ncandi = 0\ns = 0\ncnt = 0\nminb = 0\nans = 0\nh = []\nfor i in range(n):\n    bb = b[ind[i]]\n    tt = t[ind[i]]\n    if bb != minb:\n        minb = bb\n    heapq.heappush(h, (t[ind[i]], i))\n    s += tt\n    cnt += 1\n    if cnt > k:\n        tc, ic = heapq.heappop(h)\n        s -= tc\n        cnt -= 1\n    candi = s*minb\n    ans = max(candi, ans)\n\n#for i in range(n):\n#    print(heapq.heappop(h))\nprint(ans)\n", "#import resource\nimport sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\nmod=(10**9)+7\n#fact=[1]\n#for i in range(1,1001):\n#    fact.append((fact[-1]*i)%mod)\n#ifact=[0]*1001\n#ifact[1000]=pow(fact[1000],mod-2,mod)\n#for i in range(1000,0,-1):\n#    ifact[i-1]=(i*ifact[i])%mod\nfrom sys import stdin, stdout\n#from bisect import bisect_left as bl\n#from bisect import bisect_right as br\n#import itertools\n#import math\n#import heapq\n#from random import randint as rn\n#from Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():\n    return list(map(int,sin().split()))\ndef sin():\n    return stdin.readline()\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\"\"\"**************************************************************************\"\"\"\ndef merge1(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r- m\n    L = [0 for i in range(n1)]\n    R = [0 for i in range(n2)]\n    for i in range(0 , n1):\n        L[i] = arr[l + i]\n    for j in range(0 , n2):\n        R[j] = arr[m + 1 + j]\n    i,j,k=0,0,l\n    while i < n1 and j < n2 :\n        if L[i][1] < R[j][1]:\n            arr[k] = L[i]\n            i += 1\n        elif L[i][1] > R[j][1]:\n            arr[k] = R[j]\n            j += 1\n        else:\n            if L[i][0] < R[j][0]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergesort1(arr,l,r):\n    if l < r:\n        m = (l+(r-1))//2\n        mergesort1(arr, l, m)\n        mergesort1(arr, m+1, r)\n        merge1(arr, l, m, r)\ndef merge2(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r- m\n    L = [0 for i in range(n1)]\n    R = [0 for i in range(n2)]\n    for i in range(0 , n1):\n        L[i] = arr[l + i]\n    for j in range(0 , n2):\n        R[j] = arr[m + 1 + j]\n    i,j,k=0,0,l\n    while i < n1 and j < n2 :\n        if L[i][0] > R[j][0]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergesort2(arr,l,r):\n    if l < r:\n        m = (l+(r-1))//2\n        mergesort2(arr, l, m)\n        mergesort2(arr, m+1, r)\n        merge2(arr, l, m, r)\nn,k=ain()\nb=[]\nfor i in range(n):\n    b.append(ain())\nmergesort1(b,0,n-1)\nr=[]\nfor i in range(n):\n    r.append([b[i][0],i])\nmergesort2(r,0,n-1)\ng=[0 for i in range(n)]\ns=0\nfor i in range(k):\n    s+=r[i][0]\n    g[r[i][1]]=1\np=k\ns1=0\nfor i in range(n):\n    q=s*b[i][1]\n    s1=max(s1,q)\n    if(g[i]==1):\n        s-=b[i][0]\n        while(p<n):\n            if(r[p][1]>i):\n                s+=r[p][0]\n                g[r[p][1]]=1\n                p+=1\n                break\n            p+=1\nprint (s1)\n", "#import resource\nimport sys\n#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])\nmod=(10**9)+7\n#fact=[1]\n#for i in range(1,1001):\n#    fact.append((fact[-1]*i)%mod)\n#ifact=[0]*1001\n#ifact[1000]=pow(fact[1000],mod-2,mod)\n#for i in range(1000,0,-1):\n#    ifact[i-1]=(i*ifact[i])%mod\nfrom sys import stdin, stdout\n#from bisect import bisect_left as bl\n#from bisect import bisect_right as br\n#import itertools\n#import math\n#import heapq\n#from random import randint as rn\n#from Queue import Queue as Q\ndef modinv(n,p):\n    return pow(n,p-2,p)\ndef ncr(n,r,p):\n    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p\n    return t\ndef ain():\n    return list(map(int,sin().split()))\ndef sin():\n    return stdin.readline()\ndef GCD(x, y):\n   while(y):\n       x, y = y, x % y\n   return x\n\"\"\"**************************************************************************\"\"\"\ndef merge1(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r- m\n    L = [0]*n1\n    R = [0]*n2\n    for i in range(0 , n1):\n        L[i] = arr[l + i]\n    for j in range(0 , n2):\n        R[j] = arr[m + 1 + j]\n    i,j,k=0,0,l\n    while i < n1 and j < n2 :\n        if L[i][1] < R[j][1]:\n            arr[k] = L[i]\n            i += 1\n        elif L[i][1] > R[j][1]:\n            arr[k] = R[j]\n            j += 1\n        else:\n            if L[i][0] < R[j][0]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergesort1(arr,l,r):\n    if l < r:\n        m = (l+(r-1))//2\n        mergesort1(arr, l, m)\n        mergesort1(arr, m+1, r)\n        merge1(arr, l, m, r)\ndef merge2(arr, l, m, r):\n    n1 = m - l + 1\n    n2 = r- m\n    L = [0]*n1\n    R = [0]*n2\n    for i in range(0 , n1):\n        L[i] = arr[l + i]\n    for j in range(0 , n2):\n        R[j] = arr[m + 1 + j]\n    i,j,k=0,0,l\n    while i < n1 and j < n2 :\n        if L[i][0] > R[j][0]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\ndef mergesort2(arr,l,r):\n    if l < r:\n        m = (l+(r-1))//2\n        mergesort2(arr, l, m)\n        mergesort2(arr, m+1, r)\n        merge2(arr, l, m, r)\nn,k=ain()\nb=[]\nfor i in range(n):\n    b.append(ain())\nmergesort1(b,0,n-1)\nr=[]\nfor i in range(n):\n    r.append([b[i][0],i])\nmergesort2(r,0,n-1)\ng=[0]*n\ns=0\nfor i in range(k):\n    s+=r[i][0]\n    g[r[i][1]]=1\np=k\ns1=0\nfor i in range(n):\n    q=s*b[i][1]\n    s1=max(s1,q)\n    if(g[i]==1):\n        s-=b[i][0]\n        while(p<n):\n            if(r[p][1]>i):\n                s+=r[p][0]\n                g[r[p][1]]=1\n                p+=1\n                break\n            p+=1\nprint (s1)\n", "import heapq\n\ns = []\n\nn, k = list(map(int, input().split()))\n\nfor _ in range(n):\n    t, b = list(map(int, input().split()))\n    s.append((t, b))\n\ns.sort(key=lambda x: x[1], reverse=True)\n\n\n\n#print(s)\n\n\nt_max = t = s[0][0] * s[0][1]\ni = 1\n\n#print(t)\n\nwhile i < k:\n    t = (t // s[i-1][1] + s[i][0]) * s[i][1]\n    #print(t)\n    if t > t_max:\n        t_max = t\n\n    i+= 1\n\nh = [x[0] for x in s[:k]]\n\nheapq.heapify(h)\n\n\n\nfor i in range(1, n -k +1):\n    #print(s[i - 2+k])\n    sm = heapq.heappushpop(h, s[i + k - 1][0])\n    t = (t // s[i - 2+k][1] -sm+ s[i+k-1][0]) * s[i+k-1][1]\n    \n    #print(t)\n    if t > t_max:\n        t_max = t\n\nprint(t_max)\n", "'''input\n4 3\n4 7\n15 1\n3 6\n6 8\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\n\nfrom heapq import heappush as hp\nfrom heapq import heappop as hhp\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn,k=ri()\na=[]\nfor i in range(n):\n\tu,v=ri()\n\ta.append((v,u))\n\na.sort(reverse=True)\nans=0\nl=[]\ncur=0\npos=0\nwhile(pos<n):\n\tif len(l)==k:\n\t\tcur-=hhp(l)\n\thp(l,a[pos][1])\n\tcur+=a[pos][1]\n\tans=max(ans,cur*a[pos][0])\n\tpos+=1\nprint(ans)", "from collections import defaultdict as dd\nimport math\nimport heapq\n\n\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\n\n\n\n\nn, k=mi()\n\nsongs=[]\n\nfor i in range(n):\n\tsongs.append(lm())\n\n\nsongs.sort(key=lambda x:-x[1])\n\nh=[]\nmaxsofar=0\nnewlen=0\n#print(songs)\nfor i in range(k):\n\tbeauty=songs[i][1]\n\t\n\th.append(songs[i][0])\n\t\t\n\tnewlen += songs[i][0]\n\tmaxsofar=max(maxsofar,newlen*beauty)\n\n\n\nheapq.heapify(h)\nfor i in range(k,n):\n\tif songs[i][0]>h[0]:\n\t\tbeauty=songs[i][1]\t\t\n\t\n\t\tremoved=heapq.heappushpop(h, songs[i][0])\n\t\tnewlen += songs[i][0]-removed\n\t\tmaxsofar=max(maxsofar,newlen*beauty)\n\t#print(h)\nprint(maxsofar)\n\t\n\t\t\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n", "from collections import defaultdict as dd\nimport math\nimport heapq\n\n\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\n\n\n\n\nn, k=mi()\n\nsongs=[]\n\nfor i in range(n):\n\tsongs.append(lm())\n\n\nsongs.sort(key=lambda x:-x[1])\n\nh=[]\nmaxsofar=0\nnewlen=0\n#print(songs)\nfor i in range(n):\n\tbeauty=songs[i][1]\n\theapq.heappush(h,songs[i][0])\n\tremoved=0\n\tif i>=k:\n\t\tremoved=heapq.heappop(h)\n\t\n\tnewlen=newlen+songs[i][0]-removed\n\tmaxsofar=max(maxsofar,newlen*beauty)\n\t#print(newlen,maxsofar)\nprint( maxsofar)\n\t\n\t\t\n", "from heapq import heappush, heappop\n\nn,k=map(int,input().split())\na=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    a.append([y,x])\n\na.sort(reverse=True)\nh = []\nans = 0\nsum_len = 0\nfor b, t in a:\n    sum_len+=t\n    heappush(h, t)\n    if len(h)>k:\n        sum_len-=heappop(h)\n    ans=max(ans, sum_len * b)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nimport heapq  \nN, K = map(int, input().split())\nX = [[0, 0] for _ in range(N)]\nfor i in range(N):\n    t, b = map(int, input().split())\n    X[i][0] = t\n    X[i][1] = b\nX = sorted(X, key = lambda x: -x[1])\n\na = []\ns = 0\nma = 0\nfor i in range(N):\n    heapq.heappush(a, X[i][0])\n    s += X[i][0]\n    if i >= K:\n        s -= heapq.heappop(a)\n    ma = max(ma, s * X[i][1])\n\nprint(ma)", "import sys\ninput = sys.stdin.readline\nimport heapq  \nN, K = map(int, input().split())\nX = [[0, 0] for _ in range(N)]\nfor i in range(N):\n    t, b = map(int, input().split())\n    X[i][0] = t\n    X[i][1] = b\nX = sorted(X, key = lambda x: -x[1])\n\na = []\ns = 0\nma = 0\nfor i in range(N):\n    heapq.heappush(a, X[i][0])\n    s += X[i][0]\n    if i >= K:\n        s -= heapq.heappop(a)\n    ma = max(ma, s * X[i][1])\n\nprint(ma)", "from heapq import heappush,heappop\nn,k=map(int,input().split())\na=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    a.append([y,x])\na.sort(reverse=True)\nh=[]\nans,sm=0,0\nfor b,l in a:\n    sm+=l\n    heappush(h,l)\n    if len(h)>k:\n        sm-=heappop(h)\n    ans=max(ans,sm*b)  \nprint(ans)", "from heapq import heappush, heappop\n\nN, K = [int(s) for s in input().split()]\nsongs = []\nbeauties = set()\nfor _ in range(N):\n    t, b = [int(s) for s in input().split()]\n    beauties.add(b)\n    songs.append((t, b))\nsongs = sorted(songs, key= lambda x: x[1], reverse=True)\nmax_pleasure = 0\ntotal_length = 0\nmax_lengths = []\nfor i in range(K):\n    total_length += songs[i][0]\n    heappush(max_lengths, songs[i][0])\n    max_pleasure = max(max_pleasure, total_length * songs[i][1])\nfor i in range(K, N):\n    if max_lengths[0] < songs[i][0]:\n        min_length = heappop(max_lengths)\n        heappush(max_lengths, songs[i][0])\n        total_length = total_length - min_length + songs[i][0]\n        max_pleasure = max(max_pleasure, total_length * songs[i][1])\nprint(max_pleasure)\n\n", "from heapq import heappush, heappop\n\nN, K = [int(s) for s in input().split()]\nsongs = []\nbeauties = set()\nfor _ in range(N):\n    t, b = [int(s) for s in input().split()]\n    beauties.add(b)\n    songs.append((t, b))\nsongs.sort(key= lambda x: x[1], reverse=True)\nmax_pleasure = 0\ntotal_length = 0\nmax_lengths = []\nfor i in range(K):\n    total_length += songs[i][0]\n    heappush(max_lengths, songs[i][0])\n    max_pleasure = max(max_pleasure, total_length * songs[i][1])\nfor i in range(K, N):\n    if max_lengths[0] < songs[i][0]:\n        min_length = heappop(max_lengths)\n        heappush(max_lengths, songs[i][0])\n        total_length = total_length - min_length + songs[i][0]\n        max_pleasure = max(max_pleasure, total_length * songs[i][1])\nprint(max_pleasure)\n\n", "from heapq import heappush, heappop\n\nN, K = [int(s) for s in input().split()]\nsongs = []\nfor _ in range(N):\n    t, b = [int(s) for s in input().split()]\n    songs.append((t, b))\nsongs.sort(key= lambda x: x[1], reverse=True)\nmax_pleasure = 0\ntotal_length = 0\nmax_lengths = []\nfor i in range(K):\n    total_length += songs[i][0]\n    heappush(max_lengths, songs[i][0])\n    max_pleasure = max(max_pleasure, total_length * songs[i][1])\nfor i in range(K, N):\n    if max_lengths[0] < songs[i][0]:\n        min_length = heappop(max_lengths)\n        heappush(max_lengths, songs[i][0])\n        total_length = total_length - min_length + songs[i][0]\n        max_pleasure = max(max_pleasure, total_length * songs[i][1])\nprint(max_pleasure)\n\n", "import heapq\n\ndef argsort(seq):\n    return sorted(range(len(seq)), key=seq.__getitem__)\n\nn, k = map(int, input().split())\na = []\nb = []\nc  =[]\nfor i in range(n):\n  x, y = map(int, input().split())\n  a.append(x)\n  b.append(y)\n  c.append([x, y])\n\n\nind = argsort(b)\nb = sorted(b)\nb = b[::-1]\nind = ind[::-1]\nna = []\n\nfor i in range(n):\n  na.append(a[ind[i]])\n\na = na\nta = [a[0]]\nsm = sum(ta)\nmnd = b[0]\ncount = 1\np = 0\n\nres = sm*mnd\n\nqueue = [a[0]]\n\nfor i in range(1, n):\n  if count>=k:\n    heapq.heappush(queue, a[i])\n    sm = sm-heapq.heappop(queue)+a[i]\n    mnd = b[i]\n    res = max(res, sm*mnd)\n  else:\n    sm = sm+a[i]\n    mnd = b[i]\n    heapq.heappush(queue, a[i])\n    count+=1\n    res = max(res, sm*mnd)\n\nprint(res)"]
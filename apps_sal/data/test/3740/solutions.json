["import sys\ninput = sys.stdin.readline\n\nfrom fractions import gcd\nimport numpy as np\n\nMOD = 10 ** 9 + 7\n\nS = int(input())\n\nM = 10**4\n\ndef type_1(S):\n    cnt = 0\n    # S 2\u7a2e\u306e\u6841\u6570k,k+1\u304b\u3089\u306a\u308b\u3002\u3055\u3089\u306bk>=9\u3092\u4eee\u5b9a\u3059\u308b\u3002\n    # \u9805\u6570n\u3068\u3059\u308b\u3068\u3001kn < S < (k+1)n \u3068\u306a\u308b(k,n)\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    # \u307e\u305ak > M\u3068\u306a\u308b\u3082\u306e\u3092\u6570\u3048\u308b\u3002\u3053\u306e\u3068\u304d1<=n<=M\u3067\u3042\u308b\u3002\n    n = np.arange(1,M+1)\n    k_max = (S-1)//n\n    k_min = np.maximum(M+1,S//n)\n    cnt += np.maximum(0,k_max - k_min + 1).sum()\n    # \u6b21\u306b\u30019<=k<=M\u3068\u306a\u308b\u3082\u306e\u3092\u6570\u3048\u308b\n    k = np.arange(9,M+1)\n    n_max = (S-1)//k\n    n_min = S//(k+1) + 1\n    cnt += np.maximum(0,n_max-n_min+1).sum()\n    return cnt\n\ntype_1(S)\n\ndef type_2(S):\n    # S 1\u7a2e\u306e\u6841\u6570\u304b\u3089\u306a\u308b\u3002\n    cnt = 0\n    div = np.arange(1,M+1,dtype=np.int64)\n    div = set(div[S%div==0])\n    div |= set(S//x for x in div)\n    for d in div:\n        n = S//d\n        # d\u6841\u306e\u3082\u306e\u3092n\u500b\u4f7f\u3046\u3088\u3046\u306b\u3057\u305f\u3044\n        if d < 10:\n            total = 9 * 10 ** (d-1)\n            cnt += max(0,total-n+1)\n        else:\n            total = 9 * pow(10,int(d)-1,MOD)\n            cnt += total-n+1\n    return cnt % MOD\n\ndef type_3(S):\n    cnt = 0\n    # S 2\u7a2e\u4ee5\u4e0a\u306e\u6841\u6570\u304b\u3089\u306a\u308b\u30029\u6841\u306e\u6570\u4ee5\u4e0b\u3057\u304b\u4f7f\u308f\u306a\u3044\u3002\n    # \u3053\u3053\u306f\u9069\u5f53\u306b\u3044\u3051\u305d\u3046\n    for R in range(1,10):\n        for L in range(1,R):\n            mid = sum(i*9*10**(i-1) for i in range(L+1,R)) # \u9014\u4e2d\u306e\u6841\u6570\u306e\u5bc4\u4e0e\n            rest = S - (L+mid+R)\n            if rest < 0:\n                continue\n            # L\u304c1+x\u500b\u3001R\u304c1+y\u500b\u3068\u3057\u3066\n            # Lx + Ry = rest, 0<=x<=x_max, 0<=y<=y_max\n            x_max = 9*10**(L-1)-1\n            y_max = 9*10**(R-1)-1\n            g = gcd(L,R)\n            if rest % g != 0:\n                continue\n            L0 = L//g\n            R0 = R//g\n            rest //= g\n            # x mod R0\u304c\u4e00\u610f\u306b\u6c7a\u307e\u308b\n            for x0 in range(R0):\n                if (L0*x0-rest)%R0 == 0:\n                    break\n            y0 = (rest-L0*x0)//R0\n            # (x0 + tR, y0-tL)\u3068\u3057\u3066\u89e3\u304c\u30d1\u30e9\u30e1\u30fc\u30bf\u8868\u793a\u3067\u304d\u308b\n            # 0 <= x0 + tR <= x_max\n            t_min = 0\n            t_max = (x_max-x0)//R0\n            # y0-tL >= 0\n            t_max = min(t_max,y0//L0)\n            # y0-tL <= y_max iff y0-y_max <= tL\n            t_min = max(t_min,(y0-y_max+L-1)//L0)\n            cnt += max(0, t_max - t_min + 1)\n    return cnt\n\nanswer = (type_1(S) + type_2(S) + type_3(S)) % MOD\nprint(answer)", "#!/usr/bin/env python3\nimport math\nimport random\n\nclass Prime:\n    seed_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n    def is_prime(self, n):\n        is_prime_common = self.is_prime_common(n)\n        if is_prime_common is not None:\n            return is_prime_common\n\n        if n < 2000000:\n            return self.is_prime_bf(n)\n        else:\n            return self.is_prime_mr(n)\n\n    def is_prime_common(self, n):\n        if n == 1: return False\n        if n in Prime.seed_primes: return True\n        if any([n % x == 0 for x in self.seed_primes]): return False\n\n    def is_prime_bf(self, n):\n        for k in range(2, int(math.sqrt(n)) + 1):\n            if n % k == 0:\n                return False\n        return True\n\n    def is_prime_mr(self, n):\n        d = n - 1\n        while d % 2 == 0:\n            d //= 2\n\n        witnesses = self.get_witnesses(n)\n        #witnesses = [random.randint(1, n - 1) for _ in range(100)]\n\n        for w in witnesses:\n            t = d\n            y = pow(w, t, n)\n\n            while t != n - 1 and y != 1 and y != n - 1:\n                y = (y ** 2) % n\n                t *= 2\n\n            if y != n - 1 and t % 2 == 0:\n                return False\n\n        return True\n\n    def get_witnesses(self, num):\n        def _get_range(num):\n            if num < 2047:\n                return 1\n            if num < 1373653:\n                return 2\n            if num < 25326001:\n                return 3\n            if num < 3215031751:\n                return 4\n            if num < 2152302898747:\n                return 5\n            if num < 3474749660383:\n                return 6\n            if num < 341550071728321:\n                return 7\n            if num < 38255123056546413051:\n                return 9\n            return 12\n\n        return self.seed_primes[:_get_range(num)]\n\n    def gcd(self, a, b):\n        if a < b:\n            a, b = b, a\n        if b == 0:\n            return a\n        while b:\n            a, b = b, a % b\n        return a\n\n    @staticmethod\n    def f(x, n, seed):\n        p = Prime.seed_primes[seed % len(Prime.seed_primes)]\n        return (p * x + seed) % n\n\n    def find_factor(self, n, seed=1):\n        if self.is_prime(n):\n            return n\n\n        x, y, d = 2, 2, 1\n        count = 0\n        while d == 1:\n            count += 1\n            x = self.f(x, n, seed)\n            y = self.f(self.f(y, n, seed), n, seed)\n            d = self.gcd(abs(x - y), n)\n\n        if d == n:\n            return self.find_factor(n, seed+1)\n        return self.find_factor(d)\n\n    def find_factors(self, n):\n        primes = {}\n        if self.is_prime(n):\n            primes[n] = 1\n            return primes\n\n        while n > 1:\n            factor = self.find_factor(n)\n\n            primes.setdefault(factor, 0)\n            primes[factor] += 1\n\n            n //= factor\n\n        return primes\n\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while 0 < b:\n        a, b = b, a % b\n    return a\n\n\ndef powmod(a, x, m):\n    y = 1\n    while 0 < x:\n        if x % 2 == 1:\n            y *= a\n            y %= m\n        x //= 2\n        a = a ** 2\n        a %= M\n\n    return y\n\nM = 10 ** 9 + 7\nprime = Prime()\n\n\ndef solve(s):\n\n    if s == 1:\n        return 9\n\n    ans = 0\n\n    n = 1\n    c = 9\n    while n * c < s:\n        n += 1\n        c *= 10\n\n    ans += s // n\n\n    for log_r in range(n - 1, n + 1):\n        c_r = 9 * 10 ** (log_r - 1)\n        sum_r = log_r * c_r\n        for log_l in range(1, log_r):\n            mid_f = 0\n            for i in range(log_l + 1, log_r):\n                mid_f += i * 9 * 10 ** (i - 1)\n            if s <= mid_f:\n                continue\n            res = s - mid_f\n            c_l = 9 * 10 ** (log_l - 1)\n            if log_l * c_l + sum_r < res:\n                continue\n            g = gcd(log_r, log_l)\n            if res % g != 0:\n                continue\n            c_l_max = min(c_l, (res - 1) // log_l)\n            while 0 < c_l_max:\n                if (res - log_l * c_l_max) % log_r == 0: break\n                c_l_max -= 1\n            if c_l_max == 0:\n                continue\n            c_l_min = 1\n            if sum_r < res:\n                c_l_min = (res - sum_r + log_l - 1) // log_l\n            div = log_r // g\n            ans += (c_l_max - c_l_min + div) // div\n\n\n    factors = prime.find_factors(s)\n    num_prime_factors = len(factors)\n    prime_factors = []\n    count_limit = []\n    count = [0] * num_prime_factors\n    for k in list(factors.keys()):\n        prime_factors.append(k)\n        count_limit.append(factors[k])\n\n    loop = True\n    while loop:\n        p = 1\n        for i, f in enumerate(prime_factors):\n            p *= f ** count[i]\n        if n <= p:\n            ans += 9 * powmod(10, p - 1, M)\n            ans += M - s // p\n            ans %= M\n\n        count[0] += 1\n        for i, limit in enumerate(count_limit):\n            if limit < count[i]:\n                if i == num_prime_factors - 1:\n                    loop = False\n                    break\n                count[i + 1] += 1\n                count[i] = 0\n\n    return ans\n\ndef main():\n\n    s = int(input())\n\n    print((solve(s)))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()"]
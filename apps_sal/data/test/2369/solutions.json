["def prepare(n, MOD):\n \n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\n\nMOD = 10**9 + 7\nf, inv = prepare(10**5+100, MOD)\n\nn, k = map(int,input().split())\na = list(map(int,input().split()))\n\na.sort(reverse=True)\n\np = 0\nm = 0\nfor i in range(n):\n    if n - i >= k:\n        cn = n - i - 1\n        ck = k - 1\n        if cn >= ck:\n            combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n            if a[i] >= 0:        \n                p += (a[i] * combi) % MOD\n            else:\n                p += (a[i] * combi) % -MOD\n            if p >= 0:\n                p %= MOD\n            else:\n                p %= -MOD\n    if i >= k - 1:\n        cn = i\n        ck = k - 1\n        if cn >= ck:\n            combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n            if a[i] >= 0:        \n                m += (a[i] * combi) % MOD\n            else:\n                m += (a[i] * combi) % -MOD\n            if m >= 0:\n                m %= MOD\n            else:\n                m %= -MOD\n        \nprint((p - m)%MOD)", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\na.sort(reverse=True)\nmod = 10**9+7\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, 10**5+5 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n    \n    \n    \n    \nans = 0\nfor i in range(0, n-k+1):\n  ans += a[i]*cmb(n-i-1, k-1, mod)\n  ans %= mod\n\na.sort()\nfor i in range(0, n-k+1):\n  ans -= a[i]*cmb(n-i-1, k-1, mod)\n  ans %= mod\n  \nprint(ans)\n", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\ndef make_fac_tables_mod_p(n, p):\n    fac = [0] * (n + 1)\n    fac_inv = [0] * (n + 1)\n    mod_inv = [0] * (n + 1)\n    fac[0] = fac[1] = 1\n    fac_inv[0] = fac_inv[1] = 1\n    mod_inv[1] = 1\n    for i in range(2, n + 1):\n        fac[i] = (fac[i - 1] * i) % p\n        mod_inv[i] = p - mod_inv[p % i] * (p // i) % p\n        fac_inv[i] = fac_inv[i - 1] * mod_inv[i] % p\n    return fac, fac_inv\n\n\ndef nCk_mod_p(fac, fac_inv, n, k, p):\n    return ((fac[n] * fac_inv[n - k]) % p) * fac_inv[k] % p\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    if K == 1:\n        print((0))\n        return\n    if N == 2:\n        A.sort()\n        print(((A[1] - A[0]) % P))\n        return\n\n    A.sort()\n\n    fac, fac_inv = make_fac_tables_mod_p(N - 2, P)\n\n    n_f = N - K + 1\n    f = [0] * (n_f + 1)\n    k = K - 2\n    for i, n in enumerate(list(range(k, N - 2 + 1)), 1):\n        f[i] = (f[i - 1] + nCk_mod_p(fac, fac_inv, n, k, P)) % P\n\n    ans = 0\n    for i in range(1, n_f + 1):\n        ans = (ans - (f[i] * A[n_f - i]) % P) % P\n\n    for i in range(1, n_f + 1):\n        ans = (ans + (f[i] * A[N - n_f + i - 1]) % P) % P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nA.sort()\nmod = 10**9+7\n\nfac = [0]*(N+1)\nfinv = [0]*(N+1)\ninv = [0]*(N+1)\n\nfac[0], fac[1] = 1, 1\nfinv[0], finv[1] = 1, 1\ninv[1] = 1\n\nfor i in range(2, N+1):\n    fac[i] = (fac[i-1] * i) % mod\n    inv[i] = (- inv[mod%i] * (mod//i)) % mod\n    finv[i] = finv[i-1] * inv[i] % mod       \n    \ndef modcomb(n, r, mod):\n    if n<r: return 0\n    if n<0 or r<0: return 0\n    return fac[n] * finv[r]*finv[n-r] %mod\n\nans = 0\nma = 0\nmi = 0\nfor j in range(1, N+1):\n\n    ans += (-modcomb(N-j, K-1, mod)+modcomb(j-1, K-1, mod))*A[j-1]\n    ans %= mod\nprint(ans)\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nm = 10**9 + 7\n\na = [None] * (N+1)\ninva = [None] * (N+1)\na[0] = 1\n\nfor i in range(1, N+1):\n    a[i] = i * a[i-1] % m\n\ninva[N] = pow(a[N],m-2,m)\nfor i in range(N):\n    inva[N-i-1] = inva[N-i] * (N-i) % m\n\nans = 0\nfor i in range(N):\n    if i < K-1: continue\n    tmp = (a[i] * inva[i-K+1] % m) * inva[K-1] % m \n    ans += A[i] * tmp\n    ans %= m\n\nfor i in range(N):\n    if i > N-K: continue\n    tmp = (a[N-1-i] * inva[N-K-i] % m) * inva[K-1] % m \n    ans -= A[i] * tmp\n    ans %= m\n\nprint(ans)", "def cmb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\nmod = 10**9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0,1]\n\nn, k = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\nif k == 1:\n    print(0)\n    return\n\nfor i in range(2,n+1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((inv[mod % i] * (mod - (mod // i))) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\nsaidai = 0\nsaisyo = 0\n\nfor i in range(n-k+1):\n    saisyo += (a[i]*cmb(n-i-1,k-1,mod))%mod\n    saisyo %= mod\nfor i in range(k-1,n):\n    saidai += (a[i]*cmb(i,k-1,mod))%mod\n    saidai %= mod\nprint((saidai-saisyo)%mod)", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nMOD = 10**9+7\na.sort()\n\ndef prepare(n, MOD):\n    \"\"\"\n    nCr mod MOD\n    :param n:\n    :param MOD:\n    :return:\n    \"\"\"\n    facts = [1]*(n+1)\n    for i in range(1, n+1):\n        facts[i] = facts[i-1]*i%MOD\n    invs = [1]*(n+1)\n    _invs = [1]*(n+1)\n    invs[n] = pow(facts[n], MOD-2, MOD)\n    for i in range(0, n)[::-1]:\n        invs[i] = invs[i+1] * (i+1) % MOD\n    return facts, invs\nfacts, invs = prepare(n, MOD)\nmax_sum = 0\nmin_sum = 0\nfor i, v in enumerate(a):\n    under = i\n    upper = n-1-i\n    if i >= k-1:\n        max_sum += v*facts[i]*invs[k-1]*invs[i-k+1]\n        max_sum %= MOD\n    if n-1-i >= k-1:\n        min_sum += v*facts[n-1-i]*invs[k-1]*invs[n-i-k]\n        min_sum %= MOD\n\nprint((max_sum-min_sum)%MOD)", "class Enumerator:\n    def __init__(self, N: int, MOD: int) -> None:\n        self.fact = [1, 1]\n        self.finv = [1, 1]\n        self.invs = [0, 1]\n        for i in range(2, N + 1):\n            self.fact.append(self.fact[i - 1] * i % MOD)\n            self.invs.append(-self.invs[MOD % i] * (MOD // i) % MOD)\n            self.finv.append(self.finv[-1] * self.invs[-1] % MOD)\n        self._MOD = MOD\n        self._N = N\n\n    def choose(self, n: int, k: int) -> int:\n        if p := self.permutate(n, k):\n            return p * self.finv[k] % self._MOD\n        else:\n            return 0\n\n    def permutate(self, n: int, k: int) -> int:\n        if n < k or n < 0 or k < 0:\n            return 0\n        assert n <= self._N and k <= self._N\n        return self.fact[n] * self.finv[n - k] % self._MOD\n\n    def choose_with_duplicates(self, n: int, k: int) -> int:\n        return self.choose(n + k - 1, n)\n\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 1_000_000_007\nA.sort()\ne = Enumerator(N, MOD)\nnck = e.choose(N, K)\nans = 0\nfor i in range(N - 1):\n    ci = nck - e.choose(i + 1, K) - e.choose(N - i - 1, K)\n    ans += ci * (A[i + 1] - A[i])\n    ans %= MOD\nprint(ans)\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\n\nmod = 10 ** 9 + 7\nfac = [1, 1]\nfinv = [1, 1]\ninv = [0, 1]\n\nans = 0\n\ndef comb(n, r):\n  if n >= r:\n    return fac[n] * ( finv[r] * finv[n-r] % mod ) % mod\n  else:\n    return 0\n \nfor i in range(2, N + 1):\n  fac.append( ( fac[-1] * i ) % mod )\n  inv.append( mod - ( inv[mod % i] * (mod // i) % mod ) )\n  finv.append( finv[-1] * inv[-1]  % mod )\n\nif K == 1:\n  print(0)\nelse:\n  for i, x in enumerate(A):\n    cnt = x * ( comb(i, K-1) - comb(N-1-i, K-1) ) % mod\n    ans += cnt\n    ans %= mod\n  print(ans)", "mod = 10**9+7\ndef comb_lists(n, mod):\n    fact = [1 for _ in range(n+1)]\n    inv = [1 for _ in range(n+1)]\n    fact_inv = [1 for _ in range(n+1)]\n    for i in range(2, n+1):\n        fact[i] = (fact[i-1]*i) % mod\n        inv[i] = mod - (inv[mod % i] * (mod // i)) % mod\n        fact_inv[i] = (fact_inv[i-1] * inv[i]) % mod\n    \n    return fact, fact_inv\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\nif K == 1:\n    print(0)\n    return\n\nfor i in range(1, N):\n    A[i] += A[i-1]\n\nfact, fact_inv = comb_lists(N, mod)\nans = 0\nfor i in range(N-K+1):\n    s1 = A[N-1] - A[N-2-i]\n    s2 = A[i]\n    ans += ((fact[N-2-i] * fact_inv[K-2] * fact_inv[N-K-i]) % mod) * (s1 - s2)\n    ans = ans % mod\nprint(ans)", "MOD = 10**9 + 7\n\nclass Combination:\n    def __init__(self, size):\n        self.size = size + 2\n        self.fact = [1, 1] + [0] * size\n        self.factInv = [1, 1] + [0] * size\n        self.inv = [0, 1] + [0] * size\n\n        for i in range(2, self.size):\n            self.fact[i] = self.fact[i - 1] * i % MOD\n            self.inv[i] = -self.inv[MOD % i] * (MOD // i) % MOD\n            self.factInv[i] = self.factInv[i - 1] * self.inv[i] % MOD\n\n    def npr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * self.factInv[n - r] % MOD\n\n    def ncr(self, n, r):\n        if n < r or n < 0 or r < 0:\n            return 0\n        return self.fact[n] * (self.factInv[r] * self.factInv[n - r] % MOD) % MOD\n\n    def nhr(self, n, r):  # \u91cd\u8907\u7d44\u5408\u305b: x_1 + ... + x_n = r\n        return self.ncr(n + r - 1, n - 1)\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\ncomb = Combination(N + 100)\nA.sort()\n\nans = 0\nfor i, a in enumerate(A):\n    ans += a * comb.ncr(i, K - 1)\n    ans -= a * comb.ncr(N - i - 1, K - 1)\n    ans %= MOD\nprint(ans)\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nn,k=nii()\na=lnii()\na.sort()\n\nmod=10**9+7\n\nMAX_N = n+5\nfac = [1,1] + [0]*MAX_N\nfinv = [1,1] + [0]*MAX_N\ninv = [0,1] + [0]*MAX_N\nfor i in range(2,MAX_N):\n  fac[i] = fac[i-1] * i % mod\n  inv[i] = mod - inv[mod % i] * (mod // i) % mod\n  finv[i] = finv[i-1] * inv[i] % mod\n\ndef nCk(n,k):\n  if n<k:\n    return 0\n  if n<0 or k<0:\n    return 0\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\nmin_X=0\nfor i in range(n-k+1):\n  min_X+=a[i]*nCk(n-i-1,k-1)\n  min_X%=mod\n\nmax_X=0\nfor i in range(k-1,n):\n  max_X+=a[i]*nCk(i,k-1)\n  max_X%=mod\n\nans=max_X-min_X\nans%=mod\nprint(ans)", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nfac = [0] * (N + 1)\nfac[0] = 1\nfor i in range(N):\n    fac[i + 1] = fac[i] * (i + 1) % m\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n\n\nA.sort(reverse=True)\nresult = 0\nfor i in range(N - K + 1):\n    result += A[i] * mcomb(N - (i + 1), K - 1)\n    result %= m\n\nA.sort()\nt = 0\nfor i in range(N - K + 1):\n    t += A[i] * mcomb(N - (i + 1), K - 1)\n    t %= m\n\nresult -= t\nresult %= m\nprint(result)\n", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nmod = 10**9 + 7\nA.sort(reverse=True)\nkaijou = [1 for _ in range(N+1)]\nfor k in range(1, N):\n  kaijou[k+1] = kaijou[k]*(k+1)%mod\n\n\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\ndef combination(n, k):\n  foo = kaijou[n]*modinv(kaijou[k]*kaijou[n-k]%mod)%mod\n  return foo\n\nans = 0\n\nfor k in range(N-K+1):\n  ans += A[k]*combination(N-k-1, K-1)\n  ans %= mod\n\nfor k in range(N-K+1):\n  ans -= A[-k-1]*combination(N-k-1, K-1)\n  ans %= mod\n\nprint(ans)\n\n", "n,k=map(int,input().split())\na=sorted(list(map(int,input().split())))\n\nmod=10**9+7\nfac=[1]*n\nfinv=[1]*n\ninv=[0]*n\ninv[1]=1\nfor i in range(2,n):\n  fac[i]=fac[i-1]*i%mod\n  inv[i]=mod-inv[mod%i]*(mod//i)%mod\n  finv[i]=finv[i-1]*inv[i]%mod\ndef comb(n,k):\n  if n<k:\n    return 0\n  if n<0 or k<0:\n    return 0\n  return fac[n]*(finv[k]*finv[n-k]%mod)%mod\n\nans=0\nfor i in range(n-k+1):\n  ans-=a[i]*comb(n-i-1,k-1)%mod\n  ans%=mod\na=a[::-1]\nfor i in range(n-k+1):\n  ans+=a[i]*comb(n-i-1,k-1)%mod\n  ans%=mod\nprint(ans%mod)", "N,K = map(int,input().split())\nA = list(map(int,input().split()))\nA.sort()\nMOD = 10**9+7\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nfor i in range(N-K+1):\n    c = comb(N-1-i,K-1)\n    ans += (A[-i-1] - A[i]) * c\n    ans %= MOD\nprint(ans)", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n# \u4e8c\u9805\u4fc2\u6570\u8a08\u7b97\u7528\u3000\u968e\u4e57\u3068\u9006\u5143\u306e\u521d\u671f\u5316\ndef combination_mod_initialize(n, MOD=10**9+7):\n    fac = [1]*(n+1)\n    inv = [1]*(n+1)\n    for i in range(1, n+1):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = inv[i-1] * pow(i, -1, MOD) % MOD\n    return fac, inv\n\n# \u4e8c\u9805\u4fc2\u6570\u3000\u9ad8\u901f\ndef combination_mod(n, r, fac, inv):\n    return fac[n] * inv[r] * inv[n-r]\n\n\ndef main():\n    N, K = NMI()\n    A = NLI()\n    A.sort()\n    ans = 0\n    fac, inv = combination_mod_initialize(N, MOD)\n\n    for i in range(N):\n        max_num = 0\n        min_num = 0\n        if i >= K-1:\n            max_num = combination_mod(i, K-1, fac, inv)\n        if N-1-i >= K-1:\n            min_num = combination_mod(N-1-i, K-1, fac, inv)\n        ans += (max_num - min_num) * A[i] % MOD\n    print(ans%MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N,K=map(int,input().split())\nA=list(map(int,input().split()))\nA.sort()\nmod=10**9+7\nf=[1]\nfor i in range(N):\n  f+=[f[-1]*(i+1)%mod]\ndef comb(a,b):\n  return f[a]*pow(f[b],mod-2,mod)*pow(f[a-b],mod-2,mod)%mod\n\n    \nmax=0\nfor i in range(K-1,N):\n  max+=comb(i,K-1)*A[i]\n  max%=mod\nfor i in range(N-K+1):\n  max-=comb(N-i-1,K-1)*A[i]\n  max%=mod\nprint(max)", "n, k = list(map(int, input().split()))\na = [int(x) for x in input().split()]\na.sort()\nMOD = 10**9 + 7\n\ndef cmb(n, r, p):\n    if r < 0 or n < r: return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\nfor i in range(2, n + 1):\n    fact.append((fact[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    factinv.append((factinv[-1] * inv[-1]) % MOD)\n\nans = 0\nfor i in range(0, n - k + 1):\n    ans -= a[i] * cmb(n - i - 1, k - 1, MOD)\n    ans += a[n - i - 1] * cmb(n - i - 1, k - 1, MOD)\n    ans %= MOD\nprint(ans)\n", "n,k = map(int,input().split())\nA = sorted(list(map(int,input().split())))\nans_sum = 0\n\ndef cmb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n\nmod = 10**9+ 7\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n \nfor i in range(2, n+1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\nfor i in range(n):\n    a = A[i]\n    mi = i\n    ma = n-1-i\n    ## +miCk-1*a - maCk-1 \n    ans_sum += cmb(mi,k-1,mod)* a\n    ans_sum -= cmb(ma,k-1,mod)* a\n    ans_sum %= mod\nprint(ans_sum)", "import sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, K = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())))\nmod = 10 ** 9 + 7\n\n\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n\n    def __init__(self, n_max, mod=10**9 + 7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def make_factorial_list(self, n):\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n + 1):\n            fac.append(fac[i - 1] * i % self.mod)\n            facinv.append(facinv[i - 1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        modinv = [0] * (n + 1)\n        modinv[1] = 1\n        for i in range(2, n + 1):\n            modinv[i] = self.mod - self.mod // i * modinv[self.mod % i] % self.mod\n        return modinv\n\n\ndef solve():\n\n    S = [0 for _ in range(N + 1)]\n\n    comb = Combination(100001, mod)\n\n    for i in range(N):\n        S[i + 1] = S[i] + A[i]\n        S[i + 1] %= mod\n\n    ans = 0\n    for i in range(K - 1, N):\n        ans += (S[N] - S[i] - S[N - i]) * comb(i - 1, K - 2)\n        ans %= mod\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n, k = list(map(int, input().split()))\na = sorted(map(int, input().split()))\nd = [a[i + 1] - a[i] for i in range(n - 1)]\n\nmod = 1000000007\ndef pow(x, n):\n    ret = 1\n    while n > 0:\n        if (n & 1) == 1:\n            ret = (ret * x) % mod\n        x = (x * x) % mod\n        n //= 2\n    return ret\n\nfac = [1]\ninv = [1]\nfor i in range(1, n + 1):\n    fac.append((fac[-1] * i) % mod)\n    inv.append(pow(fac[i], mod - 2))\n\ndef cmb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return ((fac[n] * inv[k]) % mod * inv[n - k]) % mod\n\nret = 0\nfor i in range(n - 1):\n    num = (cmb(n, k) - cmb(i + 1, k) - cmb(n - i - 1, k)) % mod\n    ret = (ret + d[i] * num) % mod\nprint(ret)\n", "N,K=map(int,input().split())\nA=list(map(int,input().split()))\nmod = 10**9+7\n\nif K==1:print(0)\nelse:\n  factorial=[1 for i in range(N+1)]\n  for i in range(1,N+1):\n    if i==1:factorial[i]=1\n    else:factorial[i] = factorial[i-1]*i % mod\n  \n  def comb(n,k):\n    return factorial[n]*pow(factorial[n-k]*factorial[k], -1, mod)\n\n  A1=sorted(A)\n  A2=A1[::-1]\n  \n  ans=0\n  for i in range(N-K+1):\n    ans += (A2[i]-A1[i])*comb(N-i-1,K-1)\n  ans %= mod\n\n  print(ans)", "N, K = map(int, input().split())\nA = sorted(list(map(int, input().split())))\nmod = 10**9 + 7\n\nfac = [0] * (N+1)\nfacinv = [0] * (N+1)\nfac[0] = 1\nfacinv[0] = 1\nfor i in range(N):\n    fac[i+1] = (fac[i] * (i + 1)) % mod\n    facinv[i+1] = (facinv[i] * pow(i+1, -1, mod)) % mod\n\ndef nCk(n, k):\n    return (fac[n] * facinv[k] * facinv[n-k]) % mod\n\np = 0\nm = 0\nfor i in range(K-1, N):\n    p = (p + A[i] * nCk(i, K-1)) % mod\n    m = (m + A[N-i-1] * nCk(i, K-1)) % mod\n    #print(A[i-K+1] , nCk(N-i+1, K-1))\n\nprint((p - m) % mod)", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n# nCr\u306e\u5de6\u9805\u306b\u306fn\u4ee5\u5916\u3082\u6765\u308b\u30d0\u30fc\u30b8\u30e7\u30f3\u30011!\uff5e(n-1)!\u3092\u4fdd\u6301\ndef prepare(n, MOD):\n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef main():\n    n, k = ns()\n    facts, invs = prepare(n, MOD)\n\n    a = na()\n    a.sort()\n\n    ans = 0\n    for i, ai in enumerate(a):\n        tmp_min = 0\n        tmp_max = 0\n        if n - i > k - 1:\n            min_n = n - i - 1\n            min_r = k - 1\n            tmp_min = ai * facts[min_n] * invs[min_r] * invs[min_n - min_r] % MOD\n\n        if i + 1 > k - 1:\n            max_n = i\n            max_r = k - 1\n            tmp_max = ai * facts[max_n] * invs[max_r] * invs[max_n - max_r] % MOD\n\n        ans -= tmp_min\n        ans += tmp_max\n        ans %= MOD\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nN,K = list(map(int, input().split()))\nA_list = sorted(list(map(int, input().split())))\n\nif K == 1:\n    print((0))\n    return\n\nMOD = 10**9 + 7\n\nfact = [0] * (N+1)\nfact_inv = [0] * (N+1)\ninv = [0] * (N+1)\n\nfact[0] = fact[1]  = 1\nfact_inv[0] = fact_inv[1] = 1\ninv[1] = 1\n\nfor i in range(2, N):\n    fact[i] = fact[i-1] * i % MOD\n    inv[i] = MOD - inv[MOD%i] * (MOD//i) % MOD # //\u3067\u826f\u3044\u306e\u304b\u306a?\n    fact_inv[i] = fact_inv[i-1] * inv[i] % MOD\n\ndef combo(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fact[n] * (fact_inv[k] * fact_inv[n-k] % MOD) % MOD\n\ndef main():\n    min_sum = 0\n    max_sum = 0\n\n    for i in range(N-K+1):\n        cmb = combo(N-i-1, K-1)\n        min_sum -= A_list[i] * cmb\n        max_sum += A_list[N-i-1] * cmb\n        min_sum %= MOD\n        max_sum %= MOD\n    print(((max_sum+min_sum + MOD )%MOD))\n    \n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from functools import reduce\n\nMOD = 10 ** 9 + 7\n\nn, k = list(map(int, input().split()))\nla = list(map(int, input().split()))\nla.sort()\n\nf = 1\nlf = [1]\nfor i in range(1, n + 1):\n    f = (f * i) % MOD\n    lf.append(f)\n\nii = 1\nlii = [0, 1]\nfi = 1\nlfi = [1, 1]\nfor i in range(2, n + 1):\n    ii = (-lii[MOD % i] * (MOD // i)) % MOD\n    fi = (fi * ii) % MOD\n    lii.append(ii)\n    lfi.append(fi)\n\n\ndef combi(n, k):\n    if k < 0:\n        return 0\n    elif k > n:\n        return 0\n    else:\n        return (lf[n] * lfi[k] * lfi[n - k]) % MOD\n\n\ndef addmod(a, b):\n    return (a + b) % MOD\n\n\ndef sumfmax():\n    return reduce(addmod, (a * combi(i, k - 1) for i, a in enumerate(la)))\n\n\ndef sumfmin():\n    return reduce(addmod, (a * combi(n - i - 1, k - 1) for i, a in enumerate(la)))\n\n\nanswer = (sumfmax() - sumfmin()) % MOD\nprint(answer)\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\n\ndef cmb(n, r, mod):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % mod\n\nmod = 10 ** 9 + 7\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((-inv[mod % i] * (mod // i)) % mod)\n    factinv.append((factinv[-1] * inv[-1]) % mod)\n\nans = 0\nfor i in range(N-K+1):\n    x = cmb(N-i-1, K-1, mod)\n    ans -= A[i]*x\n    ans += A[N-i-1]*x\n    ans %= mod\n\nprint(ans)", "import sys\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\nclass Combi():\n    def __init__(self, N, mod):\n        self.power = [1]*(N+1)\n        self.rev = [1]*(N+1)\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n\n    def com(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n\n    def pom(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n\n\ndef main():\n    mod = 10**9+7\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    c = Combi(N, mod)\n    res = 0\n    for i, v in enumerate(A):\n        res += c.com(i, K-1)*v\n        res -= c.com(N-1-i, K-1)*v\n        res %= mod\n    print(res)\n    return\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import accumulate\n\nclass Factorial:\n    def __init__(self, n, mod=10**9+7):\n        self.fac = [0] * (n+1)\n        self.ifac = [0] * (n+1)\n        self.fac[0] = 1\n        self.ifac[0] = 1\n        self.mod = mod\n        modmod = self.mod - 2\n        for i in range(n):\n            self.fac[i+1] = self.fac[i] * (i+1) % self.mod\n            self.ifac[i+1] = self.ifac[i] * pow(i+1, modmod, self.mod) % self.mod\n\n    def comb(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        tmp =  self.ifac[n-r] * self.ifac[r] % self.mod\n        return tmp * self.fac[n] % self.mod\n\n    def perm(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        return (self.fac[n] * self.ifac[n-r]) % self.mod\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n    mod = 10**9 + 7\n\n    fact = Factorial(n + 1)\n    lll = [fact.comb(i, k-1) for i in range(k-1, n)]\n    # acc = list(accumulate(lll))\n\n    ans = 0\n    for i in range(n-k+1):\n        # print(i, -1-i, f\" --- {a[i]}, {a[-i-1]}, {lll[-i-1]}\")\n        ans = (ans + (a[-i-1] - a[i]) * lll[-i-1]) % mod\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,k = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\n\ndef cmb(n, r, mod):\n\tif (r < 0) or (n < r):\n\t\treturn 0\n\tr = min(r, n-r)\n\treturn fact[n]*factinv[r]*factinv[n-r]%mod\n\nmod = 10**9+7\nN = 10**5+100  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N+1):\n\tfact.append((fact[-1]*i)%mod)\n\tinv.append((-inv[mod%i]*(mod//i))%mod)\n\tfactinv.append((factinv[-1]*inv[-1])%mod)\n\nmaxans = 0\nfor i in range(k, n+1):\n\tmaxans = maxans + (a[i-1] * (cmb(i, k, mod)-cmb(i-1, k, mod))) % mod\n\nminans = 0\nfor i in range(k, n+1):\n\tminans = minans + (a[n-i] * (cmb(i, k, mod)-cmb(i-1, k, mod))) % mod\nprint((maxans-minans)%mod)", "N,K= map(int, input().split())\np = 10**9+7\nf=[1]\nfor i in range(1,N+1):\n  f.append(f[-1]*i % p)\n\ndef nCk(n,k):\n  return f[n]*pow(f[n-k], p-2, p)*pow(f[k], p-2, p)\n\na = list(map(int, input().split()))\na.sort()\n\nans = 0\nfor i in range(N-K+1):\n  ans -= (a[i] * nCk(N-i-1, K-1)) % p\n  ans += (a[N-i-1] * nCk(N-i-1, K-1)) % p\nprint(ans % p)", "n,k = map(int,input().split())\na = list(map(int,input().split()))\na.sort()\np = [1]\nmod = 10**9+7\nfor i in range(n):\n    p.append(p[-1]*(i+1)%mod)\np.pop()\ndef comb(n,k,mod):\n    s = p[n]*pow(p[k],mod-2,mod)%mod\n    s = s*pow(p[n-k],mod-2,mod)%mod\n    return s\nmax_sum = 0\nmin_sum = 0\nfor i in range(n-k+1):\n    max_sum += a[-(i+1)]*comb(n-1-i,k-1,mod)\n    max_sum = max_sum%mod\n    min_sum += a[i]*comb(n-1-i,k-1,mod)\n    min_sum = min_sum%mod\nans = max_sum-min_sum\nif ans < 0:\n    ans += mod\nprint(ans)", "import sys\n\n\n# ## COMBINATION (MOD) ## #\nMOD = 10**9 + 7  # , N = 2*10**5 \u3067 0.3s\nN_MAX = 10**5 + 1  # \u554f\u984c\u30b5\u30a4\u30ba\u306b\u5408\u308f\u305b\u3066\u5909\u3048\u3066\u304a\u304f\n\nfac = [1, 1]  # \u5143\u30c6\u30fc\u30d6\u30eb\nfacinv = [1, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninv = [0, 1]  # \u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range(2, N_MAX + 1):\n    fac.append((fac[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    facinv.append((facinv[-1] * inv[-1]) % MOD)\n\n\ndef cmb(n, r):\n    if (r < 0 or r > n):\n        return 0\n    # r = min(r, n-r)\n    return fac[n] * facinv[r] * facinv[n - r] % MOD\n\n\ndef main():\n    N, K = list(map(int, sys.stdin.readline().rstrip().split()))\n    A = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n    A.sort()  # \u5c0f -> \u5927\n\n    # \u5de6\u304b\u3089 i \u756a\u76ee\u304c\u9078\u3070\u308c\u3066\u3001i+1\u756a\u76ee\u4ee5\u964d\u304c\u9078\u3070\u308c\u306a\u3044\n    sum = 0\n    for i in range(N - K + 1):\n        sum += cmb(N - i - 1, K - 1) * (A[-(i + 1)] - A[i]) % MOD\n        sum %= MOD\n\n    print(sum)\n\n\nmain()\n", "class Factorial:\n    def __init__(self, n, mod=10**9+7):\n        self.fac = [0] * (n+1)\n        self.ifac = [0] * (n+1)\n        self.fac[0] = 1\n        self.ifac[0] = 1\n        self.mod = mod\n        modmod = self.mod - 2\n        for i in range(n):\n            self.fac[i+1] = self.fac[i] * (i+1) % self.mod\n            self.ifac[i+1] = self.ifac[i] * pow(i+1, modmod, self.mod) % self.mod\n\n    def comb(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        tmp =  self.ifac[n-r] * self.ifac[r] % self.mod\n        return tmp * self.fac[n] % self.mod\n\n    def perm(self, n, r):\n        if n == 0 and r == 0:\n            return 1\n        if n < r or n < 0:\n            return 0\n        return (self.fac[n] * self.ifac[n-r]) % self.mod\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    fact = Factorial(n + 1)\n\n    mn, mx = 0, 0\n    for i in range(k, n+1):\n        mx = (mx + a[i-1] * fact.comb(i-1, k-1)) % mod\n        mn = (mn + a[n-i] * fact.comb(i-1, k-1)) % mod\n    ans = mx - mn\n    if ans < 0:\n        ans += mod\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys, bisect, math, itertools, string, queue, copy\n# import numpy as np\n# import scipy\n# from collections import Counter,defaultdict,deque\n# from itertools import permutations, combinations\n# from heapq import heappop, heappush\n# # input = sys.stdin.readline\n# sys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nn,k = inpm()\nA = sorted(inpl())\n\nf=[1]\nfor i in range(1,n+1):\n  f.append(f[-1]*i % mod)\n\n#nCr\ndef comb(n,r):\n    if n <= 0 or r <= 0:\n        return 0\n    x = f[n] % mod\n    y = f[r] * f[n-r] % mod\n    return (x * pow(y, mod-2, mod) % mod)\n\nans = 0\nfor i in range(n):\n    c = comb(n-i-1,k-1)\n    ans += A[n-1-i] * c - A[i] * c\n    ans %= mod\n    if c == 1:\n        break\n\nprint(ans)\n", "MOD = 10**9 + 7\n\nN, K = list(map(int, input().split()))\nAs = list(map(int, input().split()))\n\ndef getInvs(n, MOD):\n    invs = [1] * (n+1)\n    for x in range(2, n+1):\n        invs[x] = (-(MOD//x) * invs[MOD%x]) % MOD\n    return invs\ninvs = getInvs(N, MOD)\ndef getCombKs(n, k, invs, MOD):\n    combKs = [0] * (n+1)\n    combKs[k] = 1\n    for x in range(k+1, n+1):\n        combKs[x] = (combKs[x-1] * x * invs[x-k]) % MOD\n    return combKs\ncombKs = getCombKs(N, K-1, invs, MOD)\n\nAs.sort()\n\nans = 0\nfor i, A in enumerate(As):\n    if i >= K-1:\n        ans += combKs[i] * A\n    if N-1-i >= K-1:\n        ans -= combKs[N-1-i] * A\n    ans %= MOD\n\nprint(ans)\n", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\nclass MODCombination:\n    def __init__(self, n, p):\n        self.n = n\n        self.p = p  # MOD\n        self.fac, self.ifac = self.make_fac_tables_mod_p(n, p)\n\n    @staticmethod\n    def make_fac_tables_mod_p(n, p):\n        assert n >= 1\n        fac = [0] * (n + 1)   # _______ factorial: n!\n        ifac = [0] * (n + 1)  # inverse factorial: n!^{-1}\n        inv = [0] * (n + 1)   # inverse element  : n ^{-1}\n        fac[0] = fac[1] = 1\n        ifac[0] = ifac[1] = 1\n        inv[1] = 1\n        for i in range(2, n + 1):\n            fac[i] = fac[i - 1] * i % p\n            inv[i] = p - inv[p % i] * (p // i) % p\n            ifac[i] = ifac[i - 1] * inv[i] % p\n        return fac, ifac\n\n    def nCk(self, n, k):\n        # nCk = n! * k!^{-1} * (n-k)!^{-1}\n        return ((self.fac[n] * self.ifac[n - k]) % self.p) * self.ifac[k] % self.p\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    A.sort()\n    mod_comb = MODCombination(N - 1, P)\n\n    ans = 0\n    for n in range(K - 1, N):\n        max_A = A[n]\n        min_A = A[-n - 1]\n        ans += (max_A - min_A) * mod_comb.nCk(n, K - 1)\n        ans %= P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nA.sort()\nm=10**9+7\n#\u6700\u5c0f\u5024\u3068\u3001\u6700\u5c0f\u5024\u4ee5\u5916N-1\u500b\u304b\u3089K\u30fc1\u500b\n#\u6b21\u6700\u5c0f\u5024\u3068\u6b21\u6700\u5c0f\u5024\u4ee5\u5916N\u30fc2\u500b\u304b\u3089K-1\u500b...\nalpha = 1\nbeta = 1\nfor i in range(1,K):\n    alpha *=  N-i\n    beta *= i\n    alpha%=m\n    beta %= m\ngamma = (alpha *  pow(beta,m-2,m))%m\n\nans = 0\nfor i in range(N-K+1):\n    minA = A[i]\n    maxA = A[N-1-i]\n    ans = (ans + gamma*(maxA-minA) )%m\n    gamma = (gamma*pow(N-1-i,m-2,m)*(N-K-i))%m\nprint(ans)\n", "N,K = map(int,input().split())\nA = list(map(int,input().split()))\nA.sort()\nMOD = 10**9+7\n\nMAXN = N+5\nfac = [1,1] + [0]*MAXN\nfinv = [1,1] + [0]*MAXN\ninv = [0,1] + [0]*MAXN\nfor i in range(2,MAXN+2):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = -inv[MOD%i] * (MOD // i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef comb(n,r):\n    if n < r: return 0\n    if n < 0 or r < 0: return 0\n    return fac[n] * (finv[r] * finv[n-r] % MOD) % MOD\n\nans = 0\nfor n in range(K-1,N):\n    c = comb(n,K-1)\n    mx = A[n]\n    mn = A[-1-n]\n    ans += (mx-mn)*c\n    ans %= MOD\nprint(ans)", "import math\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nN = 10**5+5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nN,K = list(map(int,input().split()))\nA = sorted(tuple(map(int,input().split())))\nB = tuple(A[i+1]-A[i]  for i in range(len(A)-1))\nlim = math.ceil(len(B)/2)\n\nL = 10**9+7\nans = 0\nmulti = cmb(N,K,mod)\nfor j in range(lim):\n    front = j + 1\n    back = N - front\n    tmp_b = 0\n    tmp_f = 0\n    if front >= K:\n        tmp_f = cmb(front,K,mod)\n    if back >= K:\n        tmp_b = cmb(back,K,mod)\n    if j == (len(B)-1)/2:\n        ans += (multi - tmp_b - tmp_f)*(B[j]) % L\n    else:\n        ans += (multi - tmp_b - tmp_f)*(B[j]+B[len(B)-1-j]) % L\nprint(ans%L)", "def ext_euc(a, b):\n    if b == 0:\n        return 1, 0, a\n    y, x, v = ext_euc(b, a % b)\n    y -= (a // b) * x\n    return x, y, v\n\n\ndef mod_inv(a, mod):\n    x, _, _ = ext_euc(a, mod)\n    return x % mod\n\n\ndef main():\n    MOD = 10 ** 9 + 7\n    N, K = list(map(int, input().split(' ')))\n    A = list(map(int, input().split(' ')))\n    A.sort()\n    comb = [0 for _ in range(N)]  # comb[i] = i_C_(K-1)\n    v = 1\n    for i in range(K - 1, N):\n        comb[i] = v\n        v *= i + 1\n        v *= mod_inv(i - K + 2, MOD)\n        v %= MOD\n    ans = 0\n    for i, a in enumerate(A):\n        ans += a * (comb[i] - comb[N - i - 1])\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10**9 + 7\nfac = [1 for k in range(200010)]\ninv = [1 for k in range(200010)]\nfinv = [1 for k in range(200010)]\nfor k in range(2,200010):\n    fac[k] = (fac[k-1]*k)%MOD\n    inv[k] = (MOD - inv[MOD%k] * (MOD // k))%MOD\n    finv[k] = (finv[k - 1] * inv[k]) % MOD;\ndef nCr(n,r):\n    return (fac[n]*finv[r]*finv[n-r])%MOD\n\nN, K = list(map(int,input().split()))\nA = sorted(list(map(int,input().split())))\nm = 0\nfor k in range(N-K+1):\n    m += A[k]*nCr(N-k-1,K-1)\n    m %= MOD\nA = A[::-1]\nM = 0\nfor k in range(N-K+1):\n    M += A[k]*nCr(N-k-1,K-1)\n    M %= MOD\nprint((M-m if M>=m else M-m+MOD))\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort(reverse=True)\n\nmod = 10**9 + 7\n\nclass Combination:\n    def __init__(self, n):\n        self.facts = [1 for i in range(n+1)]\n        self.invs = [1 for i in range(n+1)]\n\n        for i in range(1, n+1):\n            self.facts[i] = self.facts[i-1] * i % mod\n        self.invs[n] = pow(self.facts[n], mod-2, mod)\n        for i in range(1, n+1):\n            self.invs[n-i] = self.invs[n-i+1] * (n-i+1) % mod\n\n    def ncr(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n        else:\n            return self.facts[n] * self.invs[r] * self.invs[n-r] % mod\n\n    def nhr(self, n, r):\n        if n < r:\n            return 0\n        if n < 0 or r < 0:\n            return 0\n        else:\n            return self.ncr(n+r-1, n-1)\n\ncomb = Combination(N)\n\nif K == 1:\n    print(0)\n    return\n\nans = 0\nfor i in range(N-K+1):\n    ans += (comb.ncr(N-1-i, K-1) * A[i] - comb.ncr(N-1-i, K-1) * A[N-1-i]) % mod\n\nprint(ans%mod)", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n \nm = 1000000007\n \nfac = [0] * (N + 1)\nfac[0] = 1\nfor i in range(N):\n    fac[i + 1] = fac[i] * (i + 1) % m\n \n \ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n \n \nA.sort(reverse=True)\nmaxX = 0\nfor i in range(N - K + 1):\n    maxX += A[i] * mcomb(N - (i + 1), K - 1)\n    maxX %= m\n\nA.sort()\nminX = 0\nfor i in range(N - K + 1):\n    minX += A[i] * mcomb(N - (i + 1), K - 1)\n    minX %= m\n\nprint((maxX - minX) % m)", "def prepare(n, MOD):\n \n    # 1! - n! \u306e\u8a08\u7b97\n    f = 1\n    factorials = [1]  # 0!\u306e\u5206\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 \u306e\u8a08\u7b97\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 \u306e\u8a08\u7b97\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n     \n    return factorials, invs\n\n\nMOD = 10**9 + 7\nf, inv = prepare(10**5+1, MOD)\n\nn, k = list(map(int,input().split()))\na = list(map(int,input().split()))\n\na.sort(reverse=True)\n\np = 0\nm = 0\nfor i in range(n):\n    if n - i >= k:\n        cn = n - i - 1\n        ck = k - 1\n        combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n        if a[i] >= 0:        \n            p += (a[i] * combi) % MOD\n        else:\n            p += (a[i] * combi) % -MOD\n        if p >= 0:\n            p %= MOD\n        else:\n            p %= -MOD\n    if i >= k - 1:\n        cn = i\n        ck = k - 1\n        combi = f[cn] * inv[ck] % MOD * inv[cn - ck] % MOD\n        if a[i] >= 0:        \n            m += (a[i] * combi) % MOD\n        else:\n            m += (a[i] * combi) % -MOD\n        if m >= 0:\n            m %= MOD\n        else:\n            m %= -MOD\n        \nprint(((p - m) % MOD))\n", "n , k = list(map(int, input().split()))\na = list(map(int,input().split()))\na.sort()\n\nMOD = 1000000007\n\nfactorial = [1]\ninverse = [1]\nfor i in range(1, n+2):\n    factorial.append(factorial[-1] * i % MOD)\n    inverse.append(pow(factorial[-1], MOD - 2, MOD))\n\ndef combi(n, r):\n    if n < r or r < 0:\n        return 0\n    elif r == 0:\n        return 1\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\nmax_sum=0\nmin_sum=0\n\nfor i in range(k-1,n):\n    t = combi(i,k-1)\n    max_sum+=a[i]*t\n    max_sum%=MOD\n    min_sum+=a[n-i-1]*t\n    min_sum%=MOD\nif max_sum-min_sum<0:\n    max_sum+=MOD\nprint((max_sum-min_sum))\n", "n,k=map(int,input().split())\nA=list(map(int,input().split()))\nmod=10**9+7\nA.sort()\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\nN = 10**5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nans,bns=0,0\nfor j in range(n-k+1):\n  ans=(ans+(A[n-j-1]-A[j])*cmb(n-j-1,k-1,mod))%mod\nprint(ans%mod)", "N,K = map(int,input().split())\nhuga = list(map(int, input().split()))\nnew_list_reverse = sorted(huga, reverse=True)\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nNi = 10 ** 5 +1  # N \u306f\u5fc5\u8981\u5206\u3060\u3051\u7528\u610f\u3059\u308b\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, Ni + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\ns=0\nfor i in range(0,N-K+1):\n    s+=new_list_reverse[i]*cmb(N-i-1,K-1,10**9+7)\nfor i in range(K-1,N):\n    s-=new_list_reverse[i]*cmb(i,K-1,10**9+7)\nprint(s%(10**9+7))", "def prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\n\n\nMOD = 10 ** 9 + 7\nfacts, invs = prepare(n, MOD)\n\nans_max = 0\nfor i in range(k - 1, n):\n    ans_max += (arr[i] * facts[i] * invs[k - 1] * invs[i - k + 1]) % MOD\n\narr.sort(reverse=True)\n\nans_min = 0\nfor i in range(k - 1, n):\n    ans_min += (arr[i] * facts[i] * invs[k - 1] * invs[i - k + 1]) % MOD\n\nprint((ans_max - ans_min) % MOD)", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 10**9+7\ncomb = [0] * (N+1)\ncomb[K-1] = 1\nfor i in range(K-1, N):\n    comb[i+1] = comb[i] * (i+1) * pow(i-K+2, -1, mod) % mod\n# print(comb)\nA.sort()\nmi = sum(a*comb[i]%mod for a, i in zip(reversed(A[:N-K+1]), range(K-1, N)))\nma = sum(a*comb[i]%mod for a, i in zip((A[K-1:]), range(K-1, N)))\n# print(mi%mod, ma%mod)\nprint((ma-mi)%mod)", "mod = 10**9+7\n\ndef prepare(n, mod):\n    facts = [1]*(n+1)\n    for i in range(1, n+1):\n        facts[i] = facts[i-1]*i%mod\n    invs = [1]*(n+1)\n    invs[n] = pow(facts[n], mod-2, mod)\n    for i in range(0, n)[::-1]:\n        invs[i] = invs[i+1] * (i+1) % mod\n    return facts, invs\n\ndef make_combi(facts,invs,n,r,mod):\n    return facts[n]*invs[r]*invs[n-r]%mod\n\nn,k = map(int,input().split())\na = list(map(int,input().split()))\nfacts, invs = prepare(n,mod)\na.sort()\n\nmi_sum = 0\nma_sum = 0\n\nfor i,j in enumerate(a):\n    if i+1 >= k:\n        ma_sum += j*make_combi(facts,invs,i,k-1,mod)\n        ma_sum %= mod\n    if n-i >= k:\n        mi_sum += j*make_combi(facts,invs,n-i-1,k-1,mod)\n        mi_sum %= mod\n\nprint((ma_sum-mi_sum)%mod)", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n-r] % p\n\np = 10 ** 9 + 7\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n \nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % p)\n    inv.append((-inv[p % i] * (p // i)) % p)\n    factinv.append((factinv[-1] * inv[-1]) % p)\n\nA.sort()\nmax_sum, min_sum = 0, 0\nfor i in range(N-1, K-2, -1):\n    max_i = A[i]\n    max_sum += A[i] * cmb(i, K-1, p) % p\n    max_sum %= p\n\n    j = N - 1 - i\n    min_j = A[j]\n    min_sum += A[j] * cmb(i, K-1, p) % p\n    min_sum %= p\n\nans = (max_sum - min_sum) % p\n\nprint(ans)", "N,K=map(int,input().split())\nA=list(map(int,input().split()))\nA.sort()\nmod=10**9+7\nfan=[1]*(N+1)\nfor i in range(2,N):\n  fan[i]=fan[i-1]*(i)%mod\nans=0\ndef comb(a,b):\n  return fan[a]*pow(fan[b],mod-2,mod)*pow(fan[a-b],mod-2,mod)\nfor i in range(N-K+1):\n  ans+=comb(N-i-1,K-1)*(A[N-i-1]-A[i])\n  ans%=mod\nprint(ans)", "class Factorial():\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n    \n    def __call__(self, n):\n        '''n! % mod '''\n        return self.fact(n)\n    \n    def fact(self, n):\n        '''n! % mod '''\n        if n >= self.mod:\n            return 0\n        self.make(n)\n        return self._factorial[n]\n    \n    def fact_inv(self, n):\n        '''n!^-1 % mod '''\n        if n >= self.mod:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        self.make_inv(n)\n        return self._factorial_inv[n]\n    \n    def comb(self, n, r):\n        ''' nCr % mod '''\n        if r > n:\n            return 0\n        t = self.fact_inv(n-r)*self.fact_inv(r) % self.mod\n        return self(n)*t % self.mod\n    \n    def comb_with_repetition(self, n, r):\n        ''' nHr % mod '''\n        t = self.fact_inv(n-1)*self.fact_inv(r) % self.mod\n        return self(n+r-1)*t % self.mod\n    \n    def perm(self, n, r):\n        ''' nPr % mod '''\n        if r > n:\n            return 0\n        return self(n)*self.fact_inv(n-r) % self.mod\n    \n    @staticmethod\n    def xgcd(a, b):\n        ''' return (g, x, y) such that a*x + b*y = g = gcd(a, b) '''\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n    \n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        if g != 1:\n            raise ValueError('Modinv is not exist! arg={}'.format(n))\n        return x % self.mod\n    \n    def make(self, n):\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n    \n    def make_inv(self, n):\n        if n >= self.mod:\n            n = self.mod\n        self.make(n)\n        if self._size_inv < n+1:\n            for i in range(self._size_inv, n+1):\n                self._factorial_inv.append(self.modinv(self._factorial[i]))\n            self._size_inv = n+1\n\nmod = 10**9 + 7\nfact = Factorial(mod)\n\nn, k, *A = map(int, open(0).read().split())\nA.sort()\ns = 0\nfor i, a in enumerate(A[k-1:], k-1):\n    s += fact.comb(i, k-1) * a\n    s %= mod\nfor i, a in enumerate(A[:n-k+1][::-1], k-1):\n    s -= fact.comb(i, k-1) * a\n    s %= mod\nprint(s)", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n# nCr\u306e\u5270\u4f59\ndef combinations_mod(n, r, mod=1000000007):\n    \"\"\"Returns nCr in mod.\"\"\"\n    r = min(r, n - r)\n    combs = 1\n    for i, j in zip(range(n - r + 1, n + 1), range(1, r + 1)):\n        combs *= (i % mod) * pow(j, mod - 2, mod)\n        combs %= mod\n    return combs\n\n\ndef main():\n    N, K = NMI()\n    A = NLI()\n    A.sort()\n    ans = 0\n    fac = [1]*(N+1)\n    inv = [1]*(N+1)\n\n    for i in range(1, N+1):\n        fac[i] = fac[i-1] * i % MOD\n        inv[i] = inv[i-1] * pow(i, -1, MOD) % MOD\n\n    for i in range(N):\n        max_num = 0\n        min_num = 0\n        if i >= K-1:\n            max_num = fac[i] * inv[K-1] * inv[i-K+1]\n        if N-1-i >= K-1:\n            min_num = fac[N-1-i] * inv[K-1] * inv[N-K-i]\n        ans += (max_num - min_num) * A[i] % MOD\n    print(ans%MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n, k = list(map(int, input().split()))\n    a = sorted(int(i) for i in input().split())\n    mod = 10**9 + 7\n    comb = [1] * (n - k + 1)\n    for i in range(n - k):\n        comb[i + 1] = (comb[i] * (k + i) * pow(i + 1, mod - 2, mod)) % mod\n    f = 0\n    for i in range(n - k + 1):\n        f = (f + a[k + i - 1] * comb[i] % mod) % mod\n        f = (f - a[i] * comb[-1 - i] % mod) % mod\n    print(f)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\nP = 10 ** 9 + 7\n\n\nclass MODCombination:\n    def __init__(self, n, p):\n        self.n = n\n        self.p = p  # MOD\n        self.fac, self.ifac = self.make_fac_tables_mod_p(n, p)\n\n    @staticmethod\n    def make_fac_tables_mod_p(n, p):\n        assert n >= 1\n        fac = [0] * (n + 1)   # _______ factorial: n!\n        ifac = [0] * (n + 1)  # inverse factorial: n!^{-1}\n        inv = [0] * (n + 1)   # inverse element  : n ^{-1}\n        fac[0] = fac[1] = 1\n        ifac[0] = ifac[1] = 1\n        inv[1] = 1\n        for i in range(2, n + 1):\n            fac[i] = fac[i - 1] * i % p\n            inv[i] = p - inv[p % i] * (p // i) % p\n            ifac[i] = ifac[i - 1] * inv[i] % p\n        return fac, ifac\n\n    def nCk(self, n, k):\n        # nCk = n! * k!^{-1} * (n-k)!^{-1}\n        return ((self.fac[n] * self.ifac[n - k]) % self.p) * self.ifac[k] % self.p\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    if N == 1:\n        print((0))\n        return\n\n    A.sort()\n    mod_comb = MODCombination(N - 1, P)\n\n    ans = 0\n    for n in range(K - 1, N):\n        max_A = A[n]\n        min_A = A[-n - 1]\n        ans += (max_A - min_A) * mod_comb.nCk(n, K - 1)\n        ans %= P\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\nfrom collections import deque,defaultdict,Counter\nfrom itertools import accumulate\nimport bisect\nfrom heapq import heappop,heappush,heapify\nimport math\nfrom copy import deepcopy\nimport queue\nimport numpy as np\n# sympy as syp(\u7d20\u56e0\u6570\u5206\u89e3\u3068\u304b)\nMod = 1000000007\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1] \nfor i in range(2, 10**5 + 1):\n    fact.append((fact[-1] * i) % Mod)\n    inv.append((-inv[Mod % i] * (Mod // i)) % Mod)\n    factinv.append((factinv[-1] * inv[-1]) % Mod)\n    \ndef cmb(n, r, p):\n    if (r < 0) or (n < r):\n        return 0\n    r = min(r, n - r)\n    return fact[n] * factinv[r] * factinv[n - r] % p\n    \ndef sieve_of_eratosthenes(n):\n    if not isinstance(n,int):\n        raise TypeError(\"n is not int\")\n    if n<2:\n        raise ValueError(\"n is not effective\")\n    prime = [1]*(n+1)\n    for i in range(2,int(math.sqrt(n))+1):\n        if prime[i] == 1:\n            for j in range(2*i,n+1):\n                if j%i == 0:\n                    prime[j] = 0\n    res = []\n    for i in range(2,n+1):\n        if prime[i] == 1:\n            res.append(i)\n    return res\n\n \nclass UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n+1)]\n        self.rank = [0 for i in range(n+1)]\n    \n    def findroot(self,x):\n        if x == self.parent[x]:\n            return x\n        else:\n            y = self.parent[x]\n            y = self.findroot(self.parent[x])\n            return y\n    \n    def union(self,x,y):\n        px = self.findroot(x)\n        py = self.findroot(y)\n        if px < py:\n            self.parent[y] = px\n        else:\n            self.parent[px] = py\n \n    def same_group_or_no(self,x,y):\n        return self.findroot(x) == self.findroot(y)\n\ndef main():  #startline-------------------------------------------\n    n, k = map(int, input().split())\n    a=list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n - k + 1):\n        t = cmb(n - i - 1, k - 1, Mod)\n        ans += (a[n - i - 1] * t % Mod - (a[i] * t % Mod)) % Mod\n        \n    print(ans%Mod)\ndef __starting_point():\n    main() #endline===============================================\n__starting_point()", "N, K = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\nMOD = 10 ** 9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\n\ndef cmb(n, k, p):\n    if (k < 0) or (n < k):\n        return 0\n    r = min(k, n - k)\n    return fact[n] * factinv[k] * factinv[n - k] % p\n\n\n# N = 10 ** 6\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    factinv.append((factinv[-1] * inv[-1]) % MOD)\n\nA.sort()\n\nans = 0\nfor i in range(N - K + 1):\n    ans += A[-1 -i] * cmb(N - i - 1, K - 1, MOD)\n    ans -= A[i] * cmb(N - i - 1, K - 1, MOD)\n    ans %= MOD\n\nprint((ans % MOD))\n", "\nclass Combination:\n    def __init__(self, n_max, mod=10 ** 9 + 7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max + 1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod - 2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n    def nCr(self, n, r):\n        if not 0 <= r <= n:\n            return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\ndef resolve():\n    # \u5404\u96c6\u5408S\u306emax(S) - min(S)\u306e\u5408\u8a08\u3092\u6c42\u3081\u308b\n    # \u5404A[i]\u304c\u6700\u5927\u5024\u306b\u306a\u308b\u56de\u6570\u3001\u6700\u5c0f\u5024\u306b\u306a\u308b\u56de\u6570\u3092\u6c42\u3081\u3001\u305d\u308c\u3092\u8a08\u7b97\u3059\u308b\n    MOD = 10**9+7\n    N, K = list(map(int, input().split()))\n    A = sorted(map(int, input().split()))\n\n    Comb = Combination(N)\n    ans = 0\n    for i in range(N):\n        # \u6700\u5927\u5024\u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306f\u3001A[j]: 0 < j < i\u304b\u3089K - 1\u500b\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n        ans += Comb.nCr(i, K-1) * A[i] % MOD\n        ans %= MOD\n        # \u6700\u5c0f\u5024\u306b\u306a\u308b\u7d44\u307f\u5408\u308f\u305b\u306f\u3001A[j]: i < j < n\u304b\u3089K-1\u500b\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\n        ans -= Comb.nCr(N-i-1, K - 1) * A[i]% MOD\n        ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nm = 1000000007\n\nfac = [0] * (N + 1)\nfac[0] = 1\nfor i in range(N):\n    fac[i + 1] = fac[i] * (i + 1) % m\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n\n\nA.sort(reverse=True)\nmaxX = 0\nfor i in range(N - K + 1):\n    maxX += A[i] * mcomb(N - (i + 1), K - 1)\n    maxX %= m\n\nA.sort()\nminX = 0\nfor i in range(N - K + 1):\n    minX += A[i] * mcomb(N - (i + 1), K - 1)\n    minX %= m\n\nprint(((maxX - minX) % m))\n", "n, k = list(map(int, input().split()))\nalst = list(map(int, input().split()))\n\nMOD = 10 ** 9 + 7\nN = n + 10\nfact = [0 for _ in range(N)]\ninvfact = [0 for _ in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % MOD\n\ninvfact[N - 1] = pow(fact[N - 1], MOD - 2, MOD)\n\nfor i in range(N - 2, -1, -1):\n    invfact[i] = invfact[i + 1] * (i + 1) % MOD\ndef nCk(n, k):\n    if k < 0 or n < k:\n        return 0\n    else:\n        return fact[n] * invfact[k] * invfact[n - k] % MOD\n        \nalst.sort()\nans = 0\nfor i, num in enumerate(alst):\n    ans -= num * nCk(n - 1 - i, k - 1)\n    ans %= MOD\n\nfor i, num in enumerate(alst[::-1]):\n    ans += num * nCk(n - 1 - i, k - 1)\n    ans %= MOD\nprint(ans)\n", "n,k=list(map(int,input().split()))\na=sorted(list(map(int,input().split())))\nmod=10**9+7\n\ndef fact(n,mod):\n    a=[[] for _ in range(n+1)]\n    a[0]=1\n    for i in range(n):\n        a[i+1]=(a[i]*(i+1))%mod\n    return a\nf=fact(n,mod)\ng=[]\nfor i in range(n+1):\n    g.append(pow(f[i],-1,mod))\ndef com(n,r):\n    return f[n]*g[r]*g[n-r]\nans=0\nfor i in range(n-k+1):\n    ans=ans+(a[-i-1]-a[i])*com(n-i-1,k-1)\nprint((ans%mod))\n", "# kurimu_usamaro\u69d8\u306e\u30e1\u30bd\u30c3\u30c9\u3092\u62dd\u501f\u3057\u3066\u3044\u307e\u3059\u3002\nclass Combi():\n    def __init__(self, N, mod):\n        self.power = [1 for _ in range(N+1)]\n        self.rev = [1 for _ in range(N+1)]\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n \n    def com(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n \n    def pom(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n \ndef main():\n  mod = 10**9+7\n  N,K = map(int,input().split())\n  A = list(map(int,input().split()))\n  A.sort()\n  c = Combi(N,mod)\n\n  ans = 0\n  if K == 1:\n    print(0)\n  else:\n    for i, a in enumerate(A):\n      ans += c.com(i, K-1)*a\n      ans -= c.com(N-1-i, K-1)*a\n      ans %= mod\n    print(ans%mod)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nMOD = 10**9+7\nn, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\ncnt = defaultdict(int)\nfor a in A:\n    cnt[a] += 1\n\n\nkeys = sorted(cnt.keys())\nkey_to_idx = defaultdict(int)\nfor i, k in enumerate(keys):\n    key_to_idx[k] = i\n\nAcum = [0]\nfor k in keys:\n    Acum.append(Acum[-1]+cnt[k])\n\nU = n\nfact = [0]*(U+1)\nfact[0] = 1\nfor i in range(1, U+1):\n    fact[i] = fact[i-1]*i % MOD\n\n\ninvfact = [0]*(U+1)\ninvfact[U] = pow(fact[U], MOD-2, MOD)\nfor i in reversed(list(range(U))):\n    invfact[i] = invfact[i+1]*(i+1) % MOD\n\n\ndef nCr(n, r):\n    if r < 0 or n < r:\n        return 0\n    return fact[n]*invfact[r]*invfact[n-r]\n\n\nMAX = 0\nfor k in reversed(keys):\n    x = Acum[key_to_idx[k]+1]\n    y = Acum[key_to_idx[k]]\n    c = nCr(x, K) - nCr(y, K)\n    MAX += c*k\n    MAX %= MOD\n\nMIN = 0\nfor k in keys:\n    x = n-Acum[key_to_idx[k]]\n    y = n-Acum[key_to_idx[k]+1]\n    c = nCr(x, K) - nCr(y, K)\n    MIN += c*k\n    MIN %= MOD\n\nprint(((MAX-MIN) % MOD))\n", "# \u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nm = 1000000007\n\n\ndef make_factorial_table(n):\n    result = [0] * (n + 1)\n    result[0] = 1\n    for i in range(1, n + 1):\n        result[i] = result[i - 1] * i % m\n    return result\n\n\ndef mcomb(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if n < k or k < 0:\n        return 0\n    return fac[n] * pow(fac[n - k], m - 2, m) * pow(fac[k], m - 2, m) % m\n\n\nfac = make_factorial_table(N)\n\nA.sort(reverse=True)\nmaxX = 0\nfor i in range(N - K + 1):\n    maxX += A[i] * mcomb(N - (i + 1), K - 1)\n    maxX %= m\n\nA.sort()\nminX = 0\nfor i in range(N - K + 1):\n    minX += A[i] * mcomb(N - (i + 1), K - 1)\n    minX %= m\n\nprint(((maxX - minX) % m))\n", "N, K = map(int, input().split())\nlis = list(map(int, input().split()))\nsort_lis = sorted(lis)\np = 10**9+7\nfac_lis = [[0] for i in range(N)]\nfac_lis[0] = 1\nmax_ans = 0\nmin_ans = 0\n\nfor i in range(1,N):\n  fac_lis[i] = fac_lis[i-1]*(i+1)%p\n\ndef combi(n,k):\n  if n == k:\n    return 1\n  else:\n    return fac_lis[n-1]*pow(fac_lis[k-1], p-2, p)*pow(fac_lis[n-k-1], p-2, p) % p\n\nfor i in range(K-1,N):\n  max_ans += sort_lis[i]*combi(i, K-1)\n  max_ans %= p\n  \nfor i in range(N-K+1):\n  min_ans += sort_lis[i]*combi(N-(i+1), K-1)\n  min_ans %= p\n\nans = (max_ans - min_ans) % p\nprint(ans)", "#!/usr/bin/env python3\nfrom itertools import accumulate\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n    p = 10**9 + 7\n    if K == 1:\n        print((0))\n        return\n\n    a = [None] * (N+1)\n    inva = [None] * (N+1)\n    a[0] = 1\n    \n    for i in range(1, N+1):\n        a[i] = i * a[i-1] % p\n    \n    inva[N] = pow(a[N],p-2,p)\n    for i in range(N):\n        inva[N-i-1] = inva[N-i] * (N-i) % p\n\n    ans = 0\n    maxA = list(accumulate(A[::-1]))\n    minA = list(accumulate(A))\n    # print(A)\n    # print(maxA)\n    # print(minA)\n    # if K > 2:\n    #     maxA = sum(A[N-(K-2):])\n    #     minA = sum(A[:K-2])\n    for i in range(K-1,N):# 1\u3064\u96a3\u3069\u3046\u3057\u304b\u3089N-1\u3064\u96a3\u307e\u3067\n        j = min(i,N-i)\n        # print(i,j,maxA[j-1],minA[j-1])\n        tmp = (a[i-1]*inva[K-2] % p) * inva[i-K+1] % p\n        ans += (maxA[j-1]-minA[j-1]) * tmp % p\n        ans %= p\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from functools import lru_cache\nn, k = list(map(int, input().split()))\nA = sorted(map(int, input().split()))\nmod = 10 ** 9 + 7\n# \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306e\u8a08\u7b97\nfactrial = [0 for _ in range(n + 1)]\nfactrial[0] = 1\nfor i in range(1, n + 1):\n    factrial[i] = (factrial[i - 1] * i) % mod\ninverse_factrial = list()\nfor f in factrial:\n    inverse_factrial.append(pow(f, -1, mod))\n\n\n@lru_cache(maxsize=None)\ndef nCr(n, r):\n    return (factrial[n] * inverse_factrial[r] * inverse_factrial[n - r]) % mod\n\n\nans = 0\n# \u6700\u5927\u5024\u306e\u548c\nfor i, a in enumerate(A[k - 1:], k - 1):\n    ans += ((a % mod) * nCr(i, k-1)) % mod\n    ans %= mod\n# \u6700\u5c0f\u5024\u306e\u548c\nA.reverse()\nfor i, a in enumerate(A[k - 1:], k - 1):\n    ans -= ((a % mod) * nCr(i, k-1)) % mod\n    ans %= mod\nprint(ans)\n", "# https://atcoder.jp/contests/abc151/tasks/abc151_e\n\ndef calc(x,y):\n    a = fac[x]\n    b = fac[y]\n    c = fac[x-y]\n    ret = ( (a%p)*pow(b,p-2,p)*pow(c,p-2,p))%p\n    return ret\n\nN,K=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\np=10**9+7\n\nfac=[1]\nfor i in range(1,N+1):\n    fac.append( (fac[-1]*i)%p )\n#print(fac)\n\nans=0\n\nfor i in range(N):\n    if i<=N-K:\n        nokori = N-1-i\n        kumi = calc(nokori,K-1)\n        ans -= (A[i]*kumi)%p\n    if i>=K-1:\n        nokori = i\n        kumi = calc(nokori,K-1)\n        ans += (A[i]*kumi)%p\n        \nprint((ans%p))\n\n#for L in range(N-K+1):\n#    for R in range(L+K-1,N):\n#        if L==R:\n#            tmp=0\n#            diff=0\n#            #print(L,R,diff)\n#        elif L+(K-1)==R:\n#            diff= A[R]-A[L]\n#            ans += diff\n#            #print(L,R,diff)\n#        else:\n#            tmp = calc(R-L-1,K-2)\n#            diff= tmp*(A[R]-A[L])\n#            ans += diff            \n#            #print(L,R,diff)\n#        ans %=p\n", "n, k, *a = list(map(int, open(0).read().split()))\na.sort()\n\nmod = 10 ** 9 + 7\n\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\n\ndef c(n, k):\n    return fact[n] * inv(fact[n - k] * fact[k] % mod) % mod\n\n\nans = 0\nfor i in range(k - 1, n):\n    # a[i]\u304cmax\n    ans += a[i] * c(i, k - 1) % mod\na = list(reversed(a))\nfor i in range(k - 1, n):\n    ans -= a[i] * c(i, k - 1) % mod\nprint(((ans + mod) % mod))\n", "N, K = map(int,input().split())\nA = list(map(int,input().split()))\nA.sort()\nfact = [1]\nmod = 10**9+7\nfor i in range(1, N+1):\n    fact.append(fact[i-1]*i % mod)\nifact = [None]*(N+1)\nifact[N] = pow(fact[N], mod-2, mod)\nfor i in range(N, 0, -1):\n    ifact[i-1] = i*ifact[i] % mod\ndef comb(n,k):\n    if n < k:\n        return 0\n    elif n == 0 or k == 0:\n        return 1\n    return (fact[n]*ifact[k]*ifact[n-k]) % mod\nans = 0\nfor i in range(N):\n    ans -= comb(N-i-1, K-1)*A[i]\n    ans += comb(i, K-1)*A[i]\n    ans %= mod\nprint(ans)", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 10**9+7\ncomb = [0] * (N+1)\ncomb[K-1] = 1\nfor i in range(K-1, N):\n    comb[i+1] = comb[i] * (i+1) * pow(i-K+2, -1, mod) % mod\n# print(comb)\nA.sort()\n# mi = sum(a*comb[i]%mod for a, i in zip(reversed(A[:N-K+1]), range(K-1, N)))\n# ma = sum(a*comb[i]%mod for a, i in zip((A[K-1:]), range(K-1, N)))\nans = sum((a-b)*comb[i]%mod for b, a, i in zip(reversed(A[:N-K+1]), A[K-1:], range(K-1, N)))\n# print(mi%mod, ma%mod)\nprint(ans%mod)", "n,k=map(int,input().split())\na=sorted(list(map(int,input().split())))\np=10**9+7\n\ndef fact(n,p):\n    a=[[] for _ in range(n+1)]\n    a[0]=1\n    for i in range(n):\n        a[i+1]=(a[i]*(i+1))%p\n    return a\nf=fact(n,p)\ng=[]\nfor i in range(n+1):\n    g.append(pow(f[i],-1,p))\ndef com(n,r):\n    return f[n]*g[r]*g[n-r]\nans=0\nfor i in range(n-k+1):\n    ans=ans+(a[-i-1]-a[i])*com(n-i-1,k-1)\nprint(ans%p)", "def main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    mod = 10**9+7\n    comb = [0] * (N+1)\n    comb[K-1] = 1\n    for i in range(K-1, N):\n        comb[i+1] = comb[i] * (i+1) * pow(i-K+2, -1, mod) % mod\n    # print(comb)\n    A.sort()\n    # mi = sum(a*comb[i]%mod for a, i in zip(reversed(A[:N-K+1]), range(K-1, N)))\n    # ma = sum(a*comb[i]%mod for a, i in zip((A[K-1:]), range(K-1, N)))\n    ans = sum((a-b)*comb[i]%mod for b, a, i in zip(reversed(A[:N-K+1]), A[K-1:], range(K-1, N)))\n    # print(mi%mod, ma%mod)\n    print(ans%mod)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k = map(int, input().split())\nAs = list(map(int, input().split()))\nfrom itertools import accumulate\n\ndef modconb(n,mod):\n    # \u30c6\u30fc\u30d6\u30eb\u3092\u4f5c\u308b\n    fac = [0]*(n+1)\n    finv = [0]*(n+1)\n    inv = [0]*(n+1)  \n\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2,n+1):\n        fac[i] = fac[i-1]*i % mod\n        inv[i] = mod - inv[mod%i] * (mod//i) % mod\n        finv[i] = finv[i-1] * inv[i] %mod\n    # \u8a08\u7b97\n    if n<k: return 0\n    if n<0 or k<0: return 0\n    return fac, finv\nmod = 10**9+7\nfac, finv = modconb(n, mod)\nAs.sort()\nacc = list(accumulate(As))\nAs.sort(reverse=True)\nacc_r = list(accumulate(As))\nans = 0\nfor d in range(1,n):\n    if d-1 < k-2:\n        continue\n    if k-2 <= 0:\n        c = 1\n    else:\n        c = fac[d-1]*(finv[k-2]*finv[d-1-(k-2)]%mod)%mod\n        # c = modconb(d-1,k-2,mod)\n    ind = min(d-1, n-d-1)\n    mn = acc[ind]\n    mx = acc_r[ind]\n    ans += (mx-mn)*c\n    # print(d,c,mn,mx,\"d\",(mx-mn)*c)\n    ans %= mod\nprint(ans)", "N, K = list(map(int, input().split()))\nA = [int(i) for i in input().split()]\nmod = 10**9 + 7\n\nlist_size = 10**5 + 1\n \nf_list = [1] * list_size\nf_r_list = [1] * list_size\n \nfor i in range(list_size-1):\n\tf_list[i+1] = (f_list[i] * (i+1)) % mod\n \nf_r_list[-1] = pow(f_list[-1], mod - 2, mod)\n \nfor i in range(list_size-2, -1, -1):\n\tf_r_list[i] = (f_r_list[i+1] * (i+1)) % mod\n \ndef comb(n, r, mod):\n\tif n < r or r < 0:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (f_list[n] * f_r_list[n-r] * f_r_list[r]) % mod\n\nA.sort()\nans = 0\nfor i, a in enumerate(A, start=1):\n    if i <= N-K+1:\n        ans -= (a * comb(N-i, K-1, mod))%mod\nans %= mod\n\nA.sort(reverse=True)\n\nfor i, a in enumerate(A, start=1):\n    if i <= N-K+1:\n        ans += (a * comb(N-i, K-1, mod))%mod\nans %= mod\nprint(ans)\n", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nA.sort()\n\n# \u501f\u308a\u7269\ndef cmb(n, r):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 10**9+7 #\u51fa\u529b\u306e\u5236\u9650\nM = 10**5\ng1 = [1, 1] # \u5143\u30c6\u30fc\u30d6\u30eb\ng2 = [1, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\ninverse = [0, 1] #\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u8a08\u7b97\u7528\u30c6\u30fc\u30d6\u30eb\n\nfor i in range( 2, M + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n# \u501f\u308a\u7269\u304a\u308f\u308a\n\nans = 0\nfor i in range(N-K+1):\n    ans += (A[-i-1]-A[i])*cmb(N-i-1, K-1)\n    ans %= mod\n\nprint(ans)", "def main():\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    mod = 10 ** 9 + 7\n    fac = [1 for _ in range(n + 1)]\n    inv = [1 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i\n        fac[i] %= mod\n        inv[i] = inv[i - 1] * pow(i, -1, mod)\n        inv[i] %= mod\n\n    def comb(a, b, mod):\n        return (fac[a] * inv[b] * inv[a - b]) % mod\n\n    ans = 0\n    for i in range(k - 1, n):\n        nck = comb(i, k - 1, mod)\n        ans += nck * a[i]\n        ans -= nck * a[n - i - 1]\n        ans %= mod\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = map(int, input().split())\nA = list(map(int, input().split()))\nmod = 10**9 + 7\nA.sort(reverse=True)\n\"\"\"\nkaijou = [1 for _ in range(N+1)]\nfor k in range(1, N):\n  kaijou[k+1] = kaijou[k]*(k+1)%mod\n\n\n\nb = mod-2\nblis = []\nc = 0\nwhile b >0:\n  if b & 1 == 1:\n    blis.append(c)\n  c += 1\n  b >>= 1\n\ndef modinv(a):\n  if a == 1:\n    return 1\n  else:\n    res = 1\n    li = []\n    for _ in range(c):\n      li.append(a%mod)\n      a = a*a%mod\n    for item in blis:\n      res = res *li[item] %mod\n    return res\n\"\"\"\nfact = [1, 1]  # fact[n] = (n! mod p)\nfactinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)\ninv = [0, 1]  # factinv \u8a08\u7b97\u7528\n\nfor i in range(2, N + 1):\n  fact.append((fact[-1] * i) % mod)\n  inv.append((-inv[mod % i] * (mod // i)) % mod)\n  factinv.append((factinv[-1] * inv[-1]) % mod)\n\n\n\n\ndef combination(n, k):\n  #foo = kaijou[n]*modinv(kaijou[k]*kaijou[n-k]%mod)%mod\n  foo = fact[n]*factinv[k]*factinv[n-k]%mod\n  return foo\n\nans = 0\n\nfor k in range(N-K+1):\n  ans += A[k]*combination(N-k-1, K-1)\n  ans %= mod\n\nfor k in range(N-K+1):\n  ans -= A[-k-1]*combination(N-k-1, K-1)\n  ans %= mod\n\nprint(ans)", "class Combi():\n    def __init__(self, N, mod):\n        self.power = [1 for _ in range(N+1)]\n        self.rev = [1 for _ in range(N+1)]\n        self.mod = mod\n        for i in range(2, N+1):\n            self.power[i] = (self.power[i-1]*i) % self.mod\n        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)\n        for j in range(N, 0, -1):\n            self.rev[j-1] = (self.rev[j]*j) % self.mod\n\n    def com(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod\n\n    def pom(self, K, R):\n        if K < R:\n            return 0\n        else:\n            return (self.power[K])*(self.rev[K-R]) % self.mod\n\n\ndef main():\n    mod = 10**9+7\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n    c = Combi(N, mod)\n    res = 0\n    for i, v in enumerate(A):\n        res += c.com(i, K-1)*v\n        res -= c.com(N-1-i, K-1)*v\n        res %= mod\n    print(res)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "p = 10**9 + 7\n\ndef modpow(a, n, p):\n    if n == 1:\n        ans = a % p\n    else:\n        if n % 2 == 0:\n            ans = (modpow(a, n // 2, p) ** 2) % p\n        else: # n % 2 == 1\n            ans = (a * (modpow(a, n // 2, p) ** 2)) % p\n\n    return ans\n\nFact = [[1, 1] for _ in range(10**5 + 1)]\nfor i in range(1, 10**5 + 1):\n    Fact[i][0] = (Fact[i - 1][0] * i) % p\n    Fact[i][1] = modpow(Fact[i][0], p - 2, p)\n\ndef C(a, b, p, Fact):\n    if a < b:\n        return 0\n    else:\n        ans = Fact[a][0] * Fact[b][1] * Fact[a - b][1] % p\n        return ans\n\nN, K = [int(x) for x in input().split()]\nA = sorted([int(x) for x in input().split()])\n \nmaxS = 0\nfor i in range(N):\n    maxS = (maxS + A[i] * C(i, K - 1, p, Fact)) % p\n\nminS = 0\nfor i in range(N):\n    minS = (minS + A[i] * C(N - i - 1, K - 1, p, Fact)) % p\n\nans = (maxS - minS) % p\n \nprint(ans)", "N, K, *A = [int(_) for _ in open(0).read().split()]\nA.sort()\n\nclass Factorial:\n    def __init__(self, max_fact, mod):\n        #mod should be prime number\n        #using homogeneous_product(n,r), max_fact \u2267 max(n+r-1)\n        f = [1] * (max_fact + 1)\n        for idx in range(2, max_fact + 1):\n            f[idx] = f[idx - 1] * idx\n            f[idx] %= mod\n        if mod > max_fact:\n            fi = [pow(f[-1], mod - 2, mod)]\n            for idx in range(max_fact, 0, -1):\n                fi += [fi[-1] * idx % mod]\n            fi = fi[::-1]\n        else:\n            fi = [pow(n, mod - 2, mod) for n in f]\n        self.mod = mod\n        self.f = f\n        self.fi = fi\n\n    def factorial(self, n):\n        return self.f[n]\n\n    def factorial_inverse(self, n):\n        return self.fi[n]\n\n    def combination(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n] * fi[r] * fi[n - r] % self.mod\n\n    def permutation(self, n, r):\n        return self.f[n] * self.fi[n - r] % self.mod\n\n    def homogeneous_product(self, n, r):\n        f = self.f\n        fi = self.fi\n        return f[n + r - 1] * fi[r] * fi[n - 1] % self.mod\n\n\nmax_fact = 10**6\nmod = 10**9 + 7\nfact_instance = Factorial(max_fact, mod)\ncomb = fact_instance.combination\nperm = fact_instance.permutation\ncombrep = fact_instance.homogeneous_product\n\nans = 0\nfor i, a in enumerate(A):\n    if i + 1 >= K:\n        ans += A[i] * comb(i, K - 1)\n    if N - i >= K:\n        ans -= A[i] * comb(N - 1 - i, K - 1)\n    ans %= mod\nprint(ans)\n", "N, K = list(map(int, input().split()))\nA = sorted(list(map(int, input().split())))\nMOD = 10 ** 9 + 7\n\n\nfactorial = [1, 1]\ninverse = [1, 1]\ninvere_base = [0, 1]\nfor i in range(2, N + 2):\n    factorial.append((factorial[-1] * i) % MOD)\n    invere_base.append((-invere_base[MOD % i] * (MOD // i)) % MOD)\n    inverse.append((inverse[-1] * invere_base[-1]) % MOD)\n\n\ndef nCr(n, r):\n    if not 0 <= r <= n:\n        return 0\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\nMAX, MIN = 0, 0\nfor i, a in enumerate(A):\n    MAX += a * nCr(i, K - 1)\n    MIN += a * nCr(N - i - 1, K - 1)\n    MAX %= MOD\n    MIN %= MOD\n\nprint(((MAX - MIN) % MOD))\n", "N, K = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\n\nA.sort()\n\nMOD = 10 ** 9 + 7\n\nfact = [1, 1]\nfactinv = [1, 1]\ninv = [0, 1]\n\n\ndef cmb(n, k, p):\n    nonlocal fact, factinv\n    if (k < 0) or (n < k):\n        return 0\n    r = min(k, n - k)\n    return fact[n] * factinv[k] * factinv[n - k] % p\n\n\nfor i in range(2, N + 1):\n    fact.append((fact[-1] * i) % MOD)\n    inv.append((-inv[MOD % i] * (MOD // i)) % MOD)\n    factinv.append((factinv[-1] * inv[-1]) % MOD)\n\n\nmasum = 0\nmisum = 0\nans = 0\n\nfor i in range(N - (K - 1)):\n    x = cmb(N - i - 1, K - 1, MOD)\n    ans += A[-i - 1] * x\n    ans -= A[i] * x\n    ans %= MOD\n\nprint(ans)\n\n\n\n", "from collections import defaultdict, Counter\nMOD = 10**9+7\nn, K = list(map(int, input().split()))\ncnt = Counter(list(map(int, input().split())))\nkeys = sorted(cnt.keys())\nkey_to_idx = defaultdict(int)\nfor i, k in enumerate(keys):\n    key_to_idx[k] = i\n\nAcum = [0]\nfor k in keys:\n    Acum.append(Acum[-1]+cnt[k])\n\nU = n\nfact = [0]*(U+1)\nfact[0] = 1\nfor i in range(1, U+1):\n    fact[i] = fact[i-1]*i % MOD\n\n\ninvfact = [0]*(U+1)\ninvfact[U] = pow(fact[U], MOD-2, MOD)\nfor i in reversed(list(range(U))):\n    invfact[i] = invfact[i+1]*(i+1) % MOD\n\n\ndef nCr(n, r):\n    if r < 0 or n < r:\n        return 0\n    return fact[n]*invfact[r]*invfact[n-r]\n\n\nans = 0\nfor k in keys:\n    x = Acum[key_to_idx[k]+1]\n    y = Acum[key_to_idx[k]]\n    cmax = nCr(x, K) - nCr(y, K)\n    cmin = nCr(n-y, K) - nCr(n-x, K)\n    ans += k*(cmax-cmin)\n    ans %= MOD\n\nprint(ans)\n", "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    # \"n \u8981\u7d20\" \u306f\u533a\u5225\u3067\u304d\u308b n \u8981\u7d20\n    # \"k \u30b0\u30eb\u30fc\u30d7\" \u306f\u3061\u3087\u3046\u3069 k \u30b0\u30eb\u30fc\u30d7\n\n    def __call__(self, n, r):  # self.C \u3068\u540c\u3058\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if (n == 0 and r > 0) or r < 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):  # \u4e0a\u6607\u968e\u4e57\u51aa n * (n+1) * ... * (n+r-1)\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):  # \u7b2c 1 \u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570  lru_cache \u3092\u4f7f\u3046\u3068 O(nk)  # n \u8981\u7d20\u3092 k \u500b\u306e\u5de1\u56de\u5217\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):  # \u7b2c 2 \u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570 O(k + log(n))  # n \u8981\u7d20\u3092\u533a\u5225\u306e\u306a\u3044 k \u30b0\u30eb\u30fc\u30d7\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570\n        if n == k: return 1  # n==k==0 \u306e\u3068\u304d\u306e\u305f\u3081\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):  # n \u8981\u7d20\u3092\u533a\u5225\u306e\u3042\u308b k \u30b0\u30eb\u30fc\u30d7\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(k + log(n))\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):  # \u30d9\u30eb\u30cc\u30fc\u30a4\u6570  lru_cache \u3092\u4f7f\u3046\u3068 O(n**2 * log(mod))\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0  # \u9ad8\u901f\u5316\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):  # \u3079\u304d\u4e57\u548c 0^k + 1^k + ... + (n-1)^k\n        # bernoulli \u306b lru_cache \u3092\u4f7f\u3046\u3068 O(k**2 * log(mod))  bernoulli \u304c\u8a08\u7b97\u6e08\u307f\u306a\u3089 O(k * log(mod))\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):  # n \u8981\u7d20\u3092 k \u500b\u306e\u7a7a\u3067\u306a\u3044\u9806\u5e8f\u4ed8\u304d\u96c6\u5408\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(1)\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):  # n \u8981\u7d20\u3092 k \u30b0\u30eb\u30fc\u30d7\u4ee5\u4e0b\u306b\u5206\u5272\u3059\u308b\u5834\u5408\u306e\u6570  O(k**2 + k*log(mod))\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\n# x * x \u304c\u9078\u3070\u308c\u3001\u304b\u3064\u305d\u308c\u4ee5\u5916\u306f\u3059\u3079\u3066 x \u4ee5\u4e0b\u304c\u9078\u3070\u308c\u308b\u5834\u5408\u306e\u6570\nN, K = list(map(int, input().split()))\nA = sorted(map(int, input().split()))\nans_max = ans_min = 0\nmod = 10**9+7\ncomb = Combination(101010)\nfor i, a in enumerate(A):\n    ans_max += a * comb.C(i, K-1)\n    ans_min += a * comb.C(N-1-i, K-1)\nans = (ans_max - ans_min) % mod\nprint(ans)\n", "N,K=map(int,input().split())\nA=list(map(int,input().split()))\nA.sort()\nMOD=10**9+7\nfan=[1]*(N+1)\nfor i in range(2,N+1):\n    fan[i]=fan[i-1]*(i)%MOD\nans=0\ndef comb(a,b):\n    return fan[a]*pow(fan[b],MOD-2,MOD)*pow(fan[a-b],MOD-2,MOD)%MOD\nfor i in range(N-K+1):\n    ans=ans+comb(N-i-1,K-1)*(A[N-1-i]-A[i])\n    ans%=MOD\nprint(ans)", "class Combination():  # nCr(mod p) #n<=10**6\n    def __init__(self, N, MOD):  # cmb\u306e\u524d\u51e6\u7406\n        self.mod = MOD\n        self.FACT = [1, 1]  # \u968e\u4e57\n        self.INV = [0, 1]  # \u5404i\u306e\u9006\u5143\n        self.FACTINV = [1, 1]  # \u968e\u4e57\u306e\u9006\u5143\n        for i in range(2, N + 1):\n            self.FACT.append((self.FACT[-1] * i) % self.mod)\n            self.INV.append(pow(i, self.mod - 2, self.mod))\n            self.FACTINV.append((self.FACTINV[-1] * self.INV[-1]) % self.mod)\n\n    def count(self, N, R):  # nCr(mod p) #\u524d\u51e6\u7406\u5fc5\u8981\n        if (R < 0) or (N < R):\n            return 0\n        R = min(R, N - R)\n        return self.FACT[N] * self.FACTINV[R] * self.FACTINV[N-R] % self.mod\n\n\nn, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nmod = 10 ** 9 + 7\n\nans = 0\ncmb = Combination(n, mod)\nfor i in range(n):\n    cnt = cmb.count(i, k - 1) - cmb.count(n - i - 1, k - 1)\n    ans += a[i] * cnt % mod\nprint((ans % mod))\n", "def cmb(n, r, mod):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n \nmod = 10**9+7  \nnums = 10**5 # \u5236\u7d04\u306b\u5408\u308f\u305b\u3088\u3046\ng1, g2, inverse = [1, 1] , [1, 1], [0, 1]\n \nfor num in range(2, nums + 1):\n    g1.append((g1[-1] * num) % mod)\n    inverse.append((-inverse[mod % num] * (mod//num)) % mod)\n    g2.append((g2[-1] * inverse[-1]) % mod)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n\nans = 0\nfor i in range(n):\n    res = cmb(n-i-1, k-1, mod)\n    ans += res*a[n-i-1] - res*a[i]\n    ans %= mod\nprint(ans)", "#!/usr/bin/env python3\nimport sys\n\nMOD = 1000000007  # type: int\n\n\ndef solve(N: int, K: int, A: \"List[int]\"):\n    mf = ModFactorial(MOD, N+1)\n    A = sorted(A)\n    ans = 0\n    for i, a in enumerate(A, 1):\n        if N-i < K-1:\n            break\n        ans = (ans + (MOD - a) * mf.combination(N-i, K-1) % MOD) % MOD\n    for i, a in enumerate(reversed(A), 1):\n        if N-i < K-1:\n            break\n        ans = (ans + (MOD + a) * mf.combination(N-i, K-1) % MOD) % MOD\n    return ans\n\ndef mod_range(mod, start, stop=None, step=1):    \n    if stop == None:\n        stop = start\n        start = 0\n    return [i % mod for i in range(start, stop, step)]\n\ndef mod_inv(mod, n):\n    '''\n    >>> mod_inv(3, 2)\n    2\n    >>> mod_inv(1000000007, 2)\n    500000004\n    '''\n    return pow(n, mod-2, mod)\n\ndef mod_permutation(mod, n, r):\n    '''\n    >>> mod_permutation(1000000007, 10, 2)\n    90\n    >>> mod_permutation(7, 10, 2)\n    6\n    '''\n    m = 1\n    for i in mod_range(mod, n-r+1, n+1):\n        m = (m * i) % mod\n    return m\n\ndef mod_factorial(mod, n):\n    '''\n    >>> mod_factorial(1000000007, 10)\n    3628800\n    >>> mod_factorial(7, 6)\n    6\n    '''\n    return mod_permutation(mod, n, n)\n\ndef mod_combination(mod, n, r):\n    '''\n    >>> mod_combination(1000000007, 10, 2)\n    45\n    >>> mod_combination(7, 10, 2)\n    3\n    '''\n    return mod_permutation(mod, n, r) * mod_inv(mod, mod_factorial(mod, r)) % mod\n\nclass ModFactorial:\n    def __init__(self, mod, size=1):\n        '''\n        >>> ModFactorial(7, 7)\n        Traceback (most recent call last):\n        ...\n        AssertionError\n        '''\n        assert mod > size\n        self._mod = mod\n        self._init_factorials(size)\n\n    def _mod_range(self, start, stop=None, step=1):\n        return mod_range(self._mod, start, stop, step)\n    \n    def _mod_inv(self, n):\n        return mod_inv(self._mod, n)\n    \n    def _init_factorials(self, size):\n        '''\n        >>> mf1 = ModFactorial(1000000007)\n        >>> mf2 = ModFactorial(1000000007, 10)\n        >>> mf1.factorial(10) == mf2.factorial(10)\n        True\n        '''\n        self._factorials = [1] * size        \n        n = 1 # \u30ea\u30b9\u30c8\u306e\u53c2\u7167\u306f\u9045\u3044\u306e\u3067\u6e1b\u3089\u3059\n        for i, m in enumerate(self._mod_range(1, size), 1):\n            n = (n * m) % self._mod\n            self._factorials[i] = n\n            \n    def _append_factorials(self, n):\n        for m in [i % self._mod for i in range(len(self._factorials), n+1)]:\n            self._factorials.append((self._factorials[-1] * m) % self._mod)\n\n    def factorial(self, n):\n        '''\n        >>> ModFactorial(1000000007).factorial(10)\n        3628800\n        >>> ModFactorial(7).factorial(6)\n        6\n        >>> ModFactorial(7).factorial(7)\n        Traceback (most recent call last):\n        ...\n        AssertionError\n        '''\n        assert n < self._mod\n        if len(self._factorials) <= n:\n            self._append_factorials(n)\n        return self._factorials[n]\n\n    def factorial_inv(self, n):\n        '''\n        >>> MOD = 1000000007\n        >>> mf = ModFactorial(MOD)\n        >>> mf.factorial_inv(10)\n        283194722\n        >>> mf.factorial_inv(10) * mf.factorial(10) % MOD\n        1\n        >>> MOD = 7\n        >>> mf = ModFactorial(MOD)\n        >>> mf.factorial_inv(6)\n        6\n        >>> mf.factorial_inv(6) * mf.factorial(6) % MOD\n        1\n        '''\n        return self._mod_inv(self.factorial(n))\n\n    def permutation(self, n, r):\n        '''\n        >>> ModFactorial(1000000007).permutation(10, 2)\n        90\n        '''\n        return self.factorial(n) * self.factorial_inv(n-r) % self._mod\n\n    def combination(self, n, r):\n        '''\n        >>> ModFactorial(1000000007).combination(10, 2)\n        45\n        '''\n        return self.permutation(n, r) * self.factorial_inv(r) % self._mod\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    print((solve(N, K, A)))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass CmbMod:\n    def __init__(self, n, p):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u304b\u3089r\u500b\u306e\u3082\u306e\u3092\u9078\u3076\u7d44\u307f\u5408\u308f\u305b\u306e\u6570)\u3092p\u3067\u5272\u3063\u305f\u4f59\u308a\u3092\u6c42\u3081\u308b\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.fact = [1, 1]\n        self.factinv = [1, 1]\n        self.inv = [0, 1]\n\n    def cmb_mod(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(r)\u306b\u3066\u8a08\u7b97\u3002n\u304c\u5927\u304d\u3044\u304cr\u306f\u5c0f\u3055\u3044\u6642\u306b\u4f7f\u7528\u3002\n        \"\"\"\n        numer, denom = 1, 1\n        for i in range(r):\n            numer = (numer * (n - i)) % self.p\n            denom = (denom * (i + 1)) % self.p\n        return (numer * pow(denom, self.p - 2, self.p)) % self.p\n\n    def prep(self):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u70ba\u306e\u524d\u51e6\u7406\u3092O(N)\u306b\u3066\u5b9f\u884c\u3002\n        \"\"\"\n        for i in range(2, self.n + 1):\n            self.fact.append((self.fact[-1] * i) % self.p)\n            self.inv.append((-self.inv[self.p % i] * (self.p // i)) % self.p)\n            self.factinv.append((self.factinv[-1] * self.inv[-1]) % self.p)\n\n    def cmb_mod_with_prep(self, n, r):\n        \"\"\"\n        \u4e8c\u9805\u4fc2\u6570nCr(mod p)\u3092O(1)\u3067\u6c42\u3081\u308b\u3002\u4e8b\u524d\u306bprep\u3092\u5b9f\u884c\u3059\u308b\u4e8b\u3002\n        \"\"\"\n        if (r < 0) or (n < r):\n            return 0\n        r = min(r, n - r)\n        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    A = sorted(list(map(int, input().split())))\n\n    cmb = CmbMod(n, mod)\n    cmb.prep()\n\n    min_S = 0\n    for i in range(n - 1):\n        min_S += (A[i] * cmb.cmb_mod_with_prep(n - (i + 1), k - 1)) % mod\n        min_S %= mod\n\n    max_S = 0\n    for j in range(1, n):\n        max_S += (A[j] * cmb.cmb_mod_with_prep(j, k - 1)) % mod\n        max_S %= mod\n\n    res = (max_S - min_S) % mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()"]
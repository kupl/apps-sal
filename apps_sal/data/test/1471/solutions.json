["N = int(input())\nu, v, w = [0]*(N-1), [0]*(N-1), [0]*(N-1)\nn = [-1] * N\n# n[][0] \u8272\u3000n[][1] \u9023\u7d50\u5148\u4e00\u89a7\u30ea\u30b9\u30c8 n[][2] mod2 \nfor i in range(N):\n    n[i] = [0]*4\n    n[i][1] = []\n    n[i][2] = []\n\nfor i in range(N-1):\n    u[i], v[i], w[i] = list(map(int, input().split()))\n    n[u[i]-1][1].append(v[i]-1)\n    n[v[i]-1][1].append(u[i]-1)\n    n[u[i]-1][2].append(w[i]%2)\n    n[v[i]-1][2].append(w[i]%2)\n\nstack = [u[0]-1]\n\nwhile True:\n    num = stack.pop()\n    n[num][3] = 1\n    for i in range(len(n[num][1])):\n        if n[n[num][1][i]][3] == 0:\n            stack.append(n[num][1][i])\n            if n[num][2][i] == 0:\n                n[n[num][1][i]][0] = n[num][0]\n            else:\n                n[n[num][1][i]][0] = -1 * n[num][0] + 1\n    if len(stack) == 0:\n        break\n\nfor i in n:\n    print(i[0])", "from collections import deque\n\nn = int(input())\ntree = {i: set() for i in range(n)}\ncost = {}\nfor _ in range(n-1):\n    u, v, w = [int(x)-1 for x in input().split()]\n    tree[u].add(v)\n    tree[v].add(u)\n    cost[(u, v)] = w + 1\n\ncolor = [-1] * n\ncolor[0] = 0\nque = deque([0])\nwhile que:\n    now = que.popleft()\n    for i in tree[now]:\n        if color[i] != -1:\n            continue\n        if cost[(min(now, i), max(now, i))] % 2 == 0:\n            color[i] = color[now]\n        else:\n            color[i] = color[now] ^ 1\n        que.append(i)\nprint(('\\n'.join(map(str, color))))\n", "N = int(input())\nTree = [[] for _ in range(N+1)]\nUVW = []\n\nfor _ in range(N-1):\n  u, v, w = map(int, input().split())\n  Tree[u].append(v)\n  Tree[v].append(u)\n  UVW.append((u, v, w))\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\n\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in Tree[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\ndis = [0] * (N+1)\n\nfor u, v, w in UVW:\n  if parent[u] == v:\n    dis[u] = w\n  else:\n    dis[v] = w\n\ncolor = [-1] * (N+1)\ncolor[root] = 0\n\nfor x in order:\n  for y in Tree[x]:\n    if y == parent[x]:\n      continue\n    if dis[y]%2 == 0:\n      color[y] = color[x]\n    else:\n      color[y] = color[x] ^ 1\n\nfor i in range(1, N+1):\n  print(color[i])", "n = int(input())\nexplored = set()\nnext = [[]for _ in range(n)]\n\nfrom collections import deque\nls = []\nfor i in range(n-1):\n    u, v, w= map(int, input().split())\n    ls.append((u-1, v-1, w%2))\n    next[u-1].append((v-1, w%2))\n    next[v-1].append((u-1, w%2))\n\nans = [-1] * n\n\nexploring = deque()\nnext_que = deque([0])\nans[0]=0\nexplored.add(0)\nwhile next_que:\n    i = next_que.popleft()\n    exploring.extend(next[i])\n    while exploring:\n        a, b = exploring.popleft()\n        ans[a] = (ans[i]+b)%2\n        list = next[a]\n        if a not in explored:\n            next_que.append(a)\n        explored.add(a)\n\n\nprint(*ans, end='\\n')", "import sys\nsys.setrecursionlimit(10**8)\nN = int(input())\ngraph = [[] for _ in range(N)]\n\nfor i in range(1, N):\n    u, v, w = list(map(int, input().split()))\n    graph[u-1].append((v-1, w))\n    graph[v-1].append((u-1, w))\n\ncolor = [0 for _ in range(N)]\nvisited = [False for _ in range(N)]\n\ndef dfs(now):\n\n    for adj in graph[now]:\n        v, dist = adj\n        if visited[v]:\n            continue\n        visited[v] = True\n        color[v] = color[now] + dist\n        dfs(v)\n\n    return\n\n\nfor start in range(N):\n    if not visited[start]:\n        color[start] = 0\n        visited[start] = True\n        dfs(start)\n\nfor i in range(N):\n    print((color[i] % 2))\n", "N = int(input())\ne = [[] for _ in range(N)]\nfor _ in range(N-1):\n  u,v,w = map(int, input().split())\n  u -= 1\n  v -= 1\n  e[u].append((v,w))\n  e[v].append((u,w))\n\nres = [-1]*N\nres[0] = 0\nq = [0]\nwhile len(q):\n  v = q.pop()\n  for u,w in e[v]:\n    if res[u]>=0:\n      continue\n    res[u] = res[v]+w\n    q.append(u)\n\nfor r in res:\n  print(r%2)", "import sys\nsys.setrecursionlimit(500*500)\nn = int(input())\na = [[] for _ in range(n)]; b = [-1]*n; b[0] = 0\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    a[u-1].append([v-1, w]); a[v-1].append([u-1, w])\ndef dfs(A, k):\n    for i in A[k]:\n        if b[i[0]] == -1:\n            b[i[0]] = b[k]+i[1]\n            dfs(A, i[0])\ndfs(a, 0)\nfor i in b:\n    print(0) if i%2 == 0 else print(1)", "n=int(input())\ncol=[-1]*n\ne=[[[],[]]for i in range(n)]\nfor i in range(n-1):\n    u,v,w=map(int,input().split())\n    u-=1\n    v-=1\n    w%=2\n    e[u][w].append(v)\n    e[v][w].append(u)\ncol[0]=1\nfrom collections import deque\ndq=deque([])\n#pop/append/(append,pop)_left/in/len/count/[]/index/rotate()(\u53f3\u3078n\u305a\u3089\u3059)\ndq.append(0)\nwhile dq:\n    a=dq.pop()\n    b=col[a]\n    for i in range(2):\n        for ne in e[a][i]:\n            if col[ne]==-1:\n                col[ne]=b^i\n                dq.appendleft(ne)\nprint(*col,sep='\\n')", "from collections import deque\n\nN = int(input())\n\ngraph = [[] for _ in range(N+1)]\ncost = [[] for _ in range(N+1)]\nans = [-1] * (N+1)\n\nfor query in range(N-1):\n    u, v, w = map(int, input().split())\n    graph[u].append(v)\n    cost[u].append(w % 2)\n    graph[v].append(u)\n    cost[v].append(w % 2)\n#print('input')\n\nque = deque()\n\nans[1] = 0\nque.append(1)\n\nwhile que:\n    now = que.popleft()\n    #print(graph[now])\n    for index in range(len(graph[now])):\n        nextg = graph[now][index]\n        nextc = cost[now][index]\n        #print(ans[nextg])\n        if ans[nextg] != -1:\n            #print('continued')\n            continue\n        que.append(nextg)\n\n        #print(nextc)\n        if nextc == 1:\n            ans[nextg] = (ans[now] + 1) % 2\n        else:\n            ans[nextg] = ans[now]\n    #print(que)\n    #print(ans)\n\n#print(ans)\n\nfor i in range(1, N+1):\n    print(ans[i])", "import sys\nsys.setrecursionlimit(10**9)\n\n\nN = int(input())\nto = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    u, v, w = map(int, input().split())\n    u, v = u - 1, v - 1\n    to[u].append([v, w])\n    to[v].append([u, w])\n\n\ndef dfs(v, color):\n    for nv, w in to[v]:\n        if color[nv] == -1:\n            if w % 2:\n                color[nv] = color[v] ^ 1\n            else:\n                color[nv] = color[v]\n            dfs(nv, color)\n\n\ndef main():\n    color = [-1] * N\n    color[0] = 0\n    dfs(0, color)\n    print(*color, sep='\\n')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\nexplored = set()\nnext = [[]for _ in range(n)]\n\nfrom collections import deque\nls = []\nfor i in range(n-1):\n    u, v, w= map(int, input().split())\n    ls.append((u-1, v-1, w%2))\n    next[u-1].append((v-1, w%2))\n    next[v-1].append((u-1, w%2))\n\nans = [-1] * n\n\nexploring = deque()\nnext_que = deque([0])\nans[0]=0\nexplored.add(0)\nwhile next_que:\n    i = next_que.popleft()\n    exploring.extend(next[i])\n    while exploring:\n        a, b = exploring.popleft()\n        ans[a] = (ans[i]+b)%2\n        list = next[a]\n        if a not in explored:\n            next_que.append(a)\n        explored.add(a)\n\n\nfor i in ans:\n    print(i)", "import sys\n\nsys.setrecursionlimit(10**7)\n\n\ndef dfs(s, to, color):\n    for next_v, step in to[s]:\n        if color[next_v] == -1:\n            if step % 2 == 0:\n                color[next_v] = color[s]\n            else:\n                color[next_v] = color[s] ^ 1\n            dfs(next_v, to, color)\n\n\ndef solve():\n    N = int(input())\n    to = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v, w = map(int, input().split())\n        u, v = u - 1, v - 1\n        to[u].append([v, w])\n        to[v].append([u, w])\n\n    color = [-1] * N #-1: \u672a\u63a2\u7d22\u30010: \u767d\u30011: \u9ed2\n    color[0] = 0\n    dfs(0, to, color)\n    print(*color, sep='\\n')\n\n\ndef __starting_point():\n    solve()\n__starting_point()", "\nfrom copy import copy\nN=int(input())\nG=[[] for _ in range(N)]\ndi=[-1]*N\nfor i in range(N-1):\n    u,v,w=map(int,input().split())\n    G[u-1].append([v-1,w])\n    G[v-1].append([u-1,w])\n\ndi[0]=0\n\nfor i in range(1,N):\n    if di[i]!=-1:continue\n    seen=[0]*N\n    stack=[[0,0]]\n    while stack:\n        y,d=stack.pop()\n        if seen[y]==1:continue\n        seen[y]=1\n        for z, dist in G[y]:\n            if seen[z] == 0:\n                di[z] = d + dist\n                stack.append([z, d + dist])\n\nfor i in range(N):\n    if di[i]%2==0:\n        print(0)\n    else:\n        print(1)", "n = int(input())\nuv = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    u,v,w = map(int, input().split())\n    uv[u].append([v,w])\n    uv[v].append([u,w])\nstack = [1]\nans = [-1]*(n+1)\nans[1]=0\nwhile stack:\n    x = stack.pop()\n    for j,k in uv[x]:\n        if ans[j] == -1:\n            if k % 2 ==0:\n                ans[j] = ans[x]\n            else:\n                ans[j] = (ans[x]+1)%2\n            stack.append(j)\nfor m in range(n):\n    print(ans[m+1])", "import sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef dfs(u:int, v:int):\n    cv = color[v]\n    for s, k in graph[v]:\n        if s == u:\n            continue\n        elif color[s] != -1:\n            continue\n        elif k%2 == 0:\n            color[s] = cv\n            dfs(v, s)\n        else:\n            color[s] = (cv+1)%2\n            dfs(v, s)\n\ndef main():\n    nonlocal color, graph\n    N = int(input())\n    graph = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v, w = list(map(int, input().split()))\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    color = [-1] * N\n\n    color[0] = 0\n    dfs(-1, 0)\n\n    for c in color:\n        print(c)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nN = int(input())\n\nGraph = [[] for _ in range(N+1)]\ndist  = [1000000000000]*(N+1)\n\nfor i in range(N-1):\n\tu,v,w = map(int,input().split())\n\tu-=1\n\tv-=1\n\tGraph[u].append((v,w))\n\tGraph[v].append((u,w))\n\n\ndef func(fromE,now,length):\n\tdist[now] = length\n\tfor i in range(len(Graph[now])):\n\t\ttarget = Graph[now][i][0]\n\t\tlengt  = Graph[now][i][1]\n\n\t\tif target == fromE:\n\t\t\tcontinue\n\n\t\tfunc(now,target,dist[now]+lengt)\n\nfunc(-1,0,0)\n\nfor i in range(N):\n\tif dist[i]%2 == 0:\n\t\tprint(0)\n\telse:\n\t\tprint(1)", "n = int(input())\ne = [list() for _ in range(n)]\nfor i in range(n-1):\n    u,v,w = map(int,input().split())\n    e[u-1] += [[v,w]]\n    e[v-1] += [[u,w]]\n\nvisited = [-1]*n\nstack = [0]\nvisited[0]=0\nwhile stack:\n    z = stack.pop()\n    for v,w in e[z]:\n        if visited[v-1]==-1:\n            stack.append(v-1)\n            if w%2==0:\n                visited[v-1]=visited[z]\n            else:\n                visited[v-1]=1-visited[z]\n        else:\n            continue\nprint(*visited,sep=\"\\n\") ", "from collections import deque\nn = int(input())\nans = [-1] * n\nans[0] = 0\nd = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    u, v, w = map(int, input().split())\n    d[u - 1].append([v - 1, w])\n    d[v - 1].append([u - 1, w])\n\ncnt = 0\nqueue = deque()\nqueue.append(0)\nwhile queue:\n    u = queue.pop()\n    for v, w in d[u]:\n        if ans[v] == -1:\n            if w % 2 == 0:\n                ans[v] = ans[u]\n            else:\n                ans[v] = ans[u] ^ 1\n            queue.append(v)\n\n\nfor i in range(n):\n    print(ans[i])", "from collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\nn = int(input())\nad_ls = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b,w = map(int,input().split())\n    ad_ls[a-1].append([b-1,w])\n    ad_ls[b-1].append([a-1,w])\n\ncost_ls = [0] * n\ndone_ls = [0] * n\ndef dfs(v,c):\n    for new,cost in ad_ls[v]:\n        if not done_ls[new]:\n            cost_ls[new] = c+cost\n            done_ls[new] = 1\n            dfs(new,c+cost)\n\ndfs(0,0)\n\ncolor_ls = [0] * n\nfor i in range(n):\n    color_ls[i] = cost_ls[i] % 2\n\nfor color in color_ls:\n    print(color)", "import sys\nsys.setrecursionlimit(10**7)\n\nclass TreeNode:\n    def __init__(self, num):\n        self.num = num\n        self.vertexs = [] # (\u30ce\u30fc\u30c9\u756a\u53f7, \u8ddd\u96e2)\n        self.color = None\n    \n    def set_color(self, color):\n        self.color = color\n\nclass Tree:\n    def __init__(self, N):\n        self.nodes = [TreeNode(i) for i in range(N)]\n\n    def set_vertex(self, u, v, w):\n        self.nodes[u - 1].vertexs.append((v - 1, w))\n        self.nodes[v - 1].vertexs.append((u - 1, w))\n    \n    def set_color(self):\n        self.nodes[0].set_color(0)\n        def set_color(node, prev_node):\n            for n, w in node.vertexs:\n                if n != prev_node.num:\n                    continue\n                if w % 2 == 0:\n                    node.set_color(prev_node.color)\n                else:\n                    new_color = abs(prev_node.color - 1)\n                    node.set_color(new_color)\n        self.do_and_next(0, -1, set_color)\n\n    def print_tree_num(self):\n        for i, node in enumerate(self.nodes):\n            print(i, node.vertexs, node.color)\n\n    def print_tree_deep(self):\n        print_color = lambda x, p: print(x.color)\n        self.do_and_next(0, -1, print_color)\n\n    def do_and_next(self, node_num, prev_node_num, f):\n        f(self.nodes[node_num], self.nodes[prev_node_num])\n        for n, w in self.nodes[node_num].vertexs:\n            if n == prev_node_num:\n                continue\n            self.do_and_next(n, node_num, f)\n\n    def print_color(self):\n        for node in self.nodes:\n            print(node.color)\n\nN = int(input())\ntree = Tree(N)\nfor _ in range(N - 1):\n    u, v, w = map(int, input().split())\n    tree.set_vertex(u, v, w)\n\ntree.set_color()\ntree.print_color()", "from collections import deque\nn=int(input())\nuv=[[] for _ in range(n+1)]\nfor i in range(n-1):\n    u,v,w=list(map(int,input().split()))\n    uv[u].append([v,w])\n    uv[v].append([u,w])\nstack=[1]\nans=[-1]*(n+1)\nans[1]=0\nwhile stack:\n    x=stack.pop()\n    for j in uv[x]:\n        if ans[j[0]]==-1:\n            if j[1]%2==0:\n                ans[j[0]]=ans[x]\n            else:\n                ans[j[0]]=(ans[x]+1)%2\n            stack.append(j[0])\n\nfor k in range(1,n+1):\n    print((ans[k]))\n", "import collections\n\nn = int(input())\ngraph = [[] for i in range(n + 1)]\nflag = [False for i in range(n + 1)]\nfor i in range(n - 1):\n    u, v, w = map(int, input().split())\n    graph[u].append([v, w])\n    graph[v].append([u, w])\ncolor = [None for i in range(n + 1)]\ncolor[1] = 0\nqueue = collections.deque([1])\nwhile queue:\n    test = queue.popleft()\n    flag[test] = True\n    for i in graph[test]:\n        if flag[i[0]] == True:\n            continue\n        queue.append(i[0])\n        color[i[0]] = i[1] % 2 ^ color[test]\nfor i in range(n):\n    print(color[i + 1])", "from collections import deque\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n  u, v, w = list(map(int, input().split()))\n  g[u-1].append((v-1,w))\n  g[v-1].append((u-1,w))\nds = [-1]*n\ndq = deque([0])\nds[0] = 0\nwhile dq:\n  t = dq.popleft()\n  for i in g[t]:\n    if ds[i[0]] == -1:\n      ds[i[0]] = ds[t] + i[1]\n      dq.append((i[0]))\nfor i in ds:\n  if i%2 == 0:\n    print((0))\n  else:\n    print((1))\n", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        u, v, w = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        G[u].append((v, w))\n        G[v].append((u, w))\n\n    ans = [-1] * N\n    ans[0] = 0\n    stack = deque([(-1, 0)])\n    while stack:\n        p, u = stack.pop()\n        for v, w in G[u]:\n            if v == p:\n                continue\n            if w % 2 == 0:\n                ans[v] = ans[u]\n            else:\n                ans[v] = (ans[u] + 1) % 2\n            stack.append((u, v))\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(20000000)\n\n\ndef dfs(node, distance):\n    for next_node, edge_size in G[node]:\n        if ans[next_node] == -1:\n            ans[next_node] = ((distance+edge_size) % 2)\n            dfs(next_node, distance+edge_size)\n\n\nN = int(input())\n\nG = [[] for i in range(N)]\nfor i in range(N-1):\n    u, v, w = map(int, input().split())\n    G[u-1].append([v-1, w])\n    G[v-1].append([u-1, w])\n\nans = [-1]*N\ndfs(0, 0)\nprint(*ans, sep='\\n')", "N = int(input())\nans = [-1] * N\nans[0] = 0\nroot = [[] for i in range(N)]\nfor i in range(N - 1):\n  u, v, w = list(map(int, input().split()))\n  root[u - 1].append([v - 1, w])\n  root[v - 1].append([u - 1, w])\n#print(root)\n\nvisited = [0] * N\nvisited[0] = 1\nqueue = [0]\nwhile queue:\n  x = queue.pop()\n  for i, value in root[x]:\n    if value % 2 == 0:\n      ans[i] = ans[x]\n    else:\n      ans[i] = abs(1 - ans[x])\n    if visited[i] == 0:\n      visited[i] = 1\n      queue.append(i)\n      \n#print(ans)      \nfor i in range(N):\n  print((ans[i]))\n              \n      \n      \n      \n      \n      \n\n", "import sys\nsys.setrecursionlimit(10**6)\nn=int(input())\npath=[[] for i in range(n)]\nfor i in range(n-1):\n    u,v,w=map(int,input().split())\n    path[u-1].append((v-1,w%2))\n    path[v-1].append((u-1,w%2))\nans=[0]+[-1]*(n-1)\ndef dfs(i):\n    nonlocal n,path,ans\n    for j in path[i]:\n        if ans[j[0]]==-1:\n            if j[1]:\n                ans[j[0]]=1-ans[i]\n                dfs(j[0])\n            else:\n                ans[j[0]]=ans[i]\n                dfs(j[0])\ndfs(0)\nprint(\"\\n\".join(map(str,ans)))", "from collections import deque\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    g[u-1].append((v-1,w))\n    g[v-1].append((u-1,w))\nds = [-1]*n\ndq = deque([0])\nds[0] = 0\nwhile dq:\n    t = dq.popleft()\n    for i in g[t]:\n        if ds[i[0]] == -1:\n            ds[i[0]] = ds[t] + i[1]\n            dq.append((i[0]))\nfor i in ds:\n    if i%2 == 0:\n        print(0)\n    else:\n        print(1)", "from collections import deque\n\nN = int(input())\n\n\nvlist = [[] for _ in range(N)]\n\nfor i in range(N-1):\n    a,b,w = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    vlist[a].append((b,w))\n    vlist[b].append((a,w))\n\nans = [-1] * N\nq = deque()\n\nans[0] = 0\nq.append(0)\n\nwhile q:\n    new = q.popleft()\n    for node, weight in vlist[new]:\n        if ans[node] != -1:\n            continue\n        ans[node] = (ans[new] + weight) % 2\n        q.append(node)\n    \nfor i in ans:\n    print(i)\n\n\n\n", "import sys\nsys.setrecursionlimit(10**7)\n\nN=int(input())\ngraph=[[] for _ in range(N)]\n\nfor _ in range(N-1):\n    u,v,w=list(map(int,input().split()))\n    u-=1\n    v-=1\n    graph[u].append([v,w])\n    graph[v].append([u,w])\n\ncolor=[-1]*N\ndef even(v=0,col=0):\n    color[v]=col\n    for i in range(len(graph[v])):\n        nv,nw=list(map(int,graph[v][i]))\n        if color[nv]!=-1: continue\n        if nw%2==0:\n            even(nv,col)\n        else:\n            even(nv,1-col)\n\neven()\nfor i in range(N):\n    print((color[i]))\n", "from collections import deque\nN=int(input())\nvisited=[-1]*N\nl=[[] for i in range(N)]\nfor i in range(N-1):\n   a,b,c=map(int,input().split())\n   a-=1;b-=1\n   l[a].append((b,c%2))\n   l[b].append((a,c%2))\ndef ans(node,dis):\n   visited[node]=0\n   que=deque(l[node])\n   while que:\n      node,dis=que.popleft()\n      visited[node]=dis\n      for i,j in l[node]:\n         if visited[i]==-1:\n            visited[i]=(dis+j)%2\n            que.append((i,(dis+j)%2))\nans(0,0)\nfor i in visited:\n   print(i)", "import sys\nsys.setrecursionlimit(10**7)\n\n\nn = int(input())\ncol = [0]*n\nnext = [[] for i in range(n)]\nd = [float('INF')]*n\nd[0]=0\n\ndef dfs(now,parent):\n    for next1,w1 in next[now]:\n        if next1 == parent:\n            continue\n        elif d[next1]==float('INF'):\n            d[next1]=d[now]+w1\n            dfs(next1,now)\n\nfor i in range(n-1):\n    u , v , w = list(map(int, input().split()))\n    next[u-1].append((v-1,w))\n    next[v-1].append((u-1,w))\n\ndfs(0,-1)\n\nfor i in range(n):\n    if d[i]%2==0:\n        print('0')\n    else:\n        print('1')\n\n", "import sys\nsys.setrecursionlimit(10**9)\ndef dfs(i):\n  if reached[i] == 1:\n    return\n  reached[i] = 1\n  for dic in uv[i]:\n    to = dic[\"to\"]\n    w = dic[\"weight\"]\n    if w % 2 == 0:\n      color[to] = color[i]\n    else:\n      color[to] = int(not color[i])\n    dfs(to)\n\nn = int(input())\ncolor = [0]*(n+1)\nreached = [0]*(n+1)\nuv = [[] * (n+1) for i in range(n+1)]\nfor i in range(n-1):\n  u,v,w = map(int,input().split())\n  uv[u].append({\"to\":v, \"weight\":w})\n  uv[v].append({\"to\":u, \"weight\":w})\ndfs(1)\nfor i in color[1:]:\n  print(i)", "from collections import deque\n\nN = int(input())\nki = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v, w = map(int, input().split())\n    ki[u-1].append([v-1, w])\n    ki[v-1].append([u-1, w])\nf = [False]*N\nf[0] = True\nc = [0]*N\n\nq = deque([0])\nwhile q:\n    now = q.popleft()\n    for nxt, w in ki[now]:\n        if f[nxt]:\n            continue\n        if w&1:\n            c[nxt] = c[now]^1\n        else:\n            c[nxt] = c[now]\n        q.append(nxt)\n        f[nxt] = True\n\n\nfor a in c:\n    print(a)", "n = int(input())\n\ng = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n    u,v,w = map(int,input().split())\n    g[u-1].append((v-1,w))\n    g[v-1].append((u-1,w))\n\nfrom collections import deque\n\nque = deque()\nseen = [0] + [-1]*(n-1)\nque.append(0)\nwhile que:\n    s = que.popleft()\n    for v,w in g[s]:\n        if seen[v] != -1:continue\n        seen[v] = seen[s]^(w%2)\n        que.append(v)\nfor i in seen:\n    print(i)", "def main():\n    n = int(input())\n    ki = {}\n    for i in range(1,n+1):\n        ki[i] = []\n    for i in range(n-1):\n        u,v,w = list(map(int,input().split()))\n        ki[u] += [[v,w%2]]\n        ki[v] += [[u,w%2]]\n    cl = [-1 for i in range(n)]\n    cl[0] = 0\n    que = [0]\n    while len(que)>0:\n        q = que.pop(0)\n        for v in ki[q+1]:\n            if cl[v[0]-1] != -1:\n                continue\n            if v[1]==1:\n                cl[v[0]-1] = (cl[q]+1)%2\n                que.append(v[0]-1)\n            else:\n                cl[v[0]-1] = cl[q]\n                que.append(v[0]-1)\n    for i in range(n):\n        print((cl[i]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(500*500)\n\n\nn = int(input())\nnodes = [list(map(int,input().split())) for _ in range(n-1)]\na = [[] for _ in range(n+1)]\n\nfor node in nodes:\n    a[node[0]].append([node[1],node[2]])\n    a[node[1]].append([node[0],node[2]])\n\ndepth = [-1] * (n+1)\ndepth[1] = 0\n\ndef dfs(a,s):\n    for v in a[s]:\n        if depth[v[0]] == -1:\n            depth[v[0]] = depth[s] + v[1]\n            dfs(a,v[0])    \ndfs(a,1)\nfor d in depth[1:]:\n    if d % 2 == 0:\n        print((0))\n    else:\n        print((1))\n", "import sys\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    u, v, w = map(int, sys.stdin.readline().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, w))\n    G[v].append((u, w))\n\ndone = {}\ntodo = [(0, 0, 0)]\nwhile todo:\n    i, c, d = todo.pop()\n    for ni, dd in G[i]:\n        if ni in done:\n            continue\n        nd = d + dd\n        nc = nd % 2\n        todo.append((ni, nc, nd))\n    done[i] = c\n\nfor i in range(N):\n    print(done[i])", "n = int(input())\nexplored = set()\nnext = [[]for _ in range(n)]\n\nfrom collections import deque\nfor i in range(n-1):\n    u, v, w= map(int, input().split())\n    next[u-1].append((v-1, w%2))\n    next[v-1].append((u-1, w%2))\nans = [-1] * n\nexploring = deque()\nnext_que = deque([0])\nans[0]=0\nexplored.add(0)\nwhile next_que:\n    i = next_que.popleft()\n    exploring.extend(next[i])\n    while exploring:\n        a, b = exploring.popleft()\n        ans[a] = (ans[i]+b)%2\n        if a not in explored:\n            next_que.append(a)\n        explored.add(a)\n\nprint(*ans, end='\\n')", "from collections import deque\n\nn = int(input())\nuvw = [list(map(int, input().split())) for _ in range(n-1)]\n\nl = [[] for _ in range(n)]\nfor u, v, w in uvw:\n    u, v = u-1, v-1\n    l[u].append((v, w))\n    l[v].append((u, w))\n\nans = [0] * n\nparents = [-1] * n\nq = deque([0])\nwhile q:\n    a = q.pop()\n    for i, j in l[a]:\n        if i == parents[a]:\n            continue\n        parents[i] = a\n        q.append(i)\n        ans[i] = ans[a] if j%2 == 0 else (ans[a]+1) % 2\nfor i in ans:\n    print(i)", "n = int(input())\nd = [[] for i in range(n)]\nfor i in range(n-1):\n  u, v, w = map(int, input().split())\n  d[u-1].append([v-1, w])\n  d[v-1].append([u-1, w])\n  \nans = [[] for i in range(n)]\nans[0].append(0)\nq = [0]\n\nwhile q:\n  x = q.pop()\n  for u, w in d[x]:\n    if not ans[u]:\n      buf = ans[x][0]\n      if w%2==1:\n        buf = (buf+1)%2\n      ans[u].append(buf)\n      q.append(u)\n    \nfor i in ans:\n  print(*i)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[3]:\n\n\nfrom collections import deque\n\n\n# In[4]:\n\n\nN = int(input())\ng = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u,v,w = list(map(int, input().split()))\n    g[u-1].append([v-1,w])\n    g[v-1].append([u-1,w])\n\n\n# In[5]:\n\n\nque = deque()\nseen = [0]+[-1]*(N-1)\nque.append(0)\nwhile que:\n    s = que.popleft()\n    for v,w in g[s]:\n        if seen[v] != -1:\n            continue\n        seen[v] = seen[s]^(w%2)\n        que.append(v)\nfor i in seen:\n    print(i)\n\n\n# In[ ]:\n\n\n\n\n", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 7)\nn = int(input())\nuvw = [list(map(int, input().split())) for i in range(n - 1)]\nd = [-1 for i in range(n)]\nedge = [[] for i in range(n)]\nfor u, v, w in uvw:\n    edge[u - 1].append((v - 1, w))\n    edge[v - 1].append((u - 1, w))\ndef dfs(now, D):\n    d[now] = D\n    for i, j in edge[now]:\n        if d[i] == -1:\n            dfs(i, D + j)\ndfs(0, 0)\nfor i in d:\n    print(i % 2)", "from collections import deque\n\ndef bfs(s):\n    nonlocal color\n    q = deque()\n    q.append(s)\n    color[s] = 0\n    while q:\n        i = q.popleft()\n        for g in G[i]:\n            if color[g[0]] == -1:\n                if g[1] % 2 == 0:\n                    color[g[0]] = color[i]\n                else:\n                    color[g[0]] = 1 - color[i]\n                q.append(g[0])\n    return\n\nn = int(input())\nG = [[] for _ in range(n + 1)]\ncolor = [-1] * (n + 1)\nfor _ in range(n - 1):\n    u, v, w = map(int, input().split())\n    G[u].append([v, w])\n    G[v].append([u, w])\nbfs(1)\nfor i in range(1, n + 1):\n    print(color[i])", "from collections import deque\nn = int(input())\nad_ls = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b,w = list(map(int,input().split()))\n    ad_ls[a-1].append([b-1,w])\n    ad_ls[b-1].append([a-1,w])\n\ncost_ls = [0] * n\ndone_ls = [0] * n\ndone_ls[0] = 1\nq = deque()\nq.append(0)\n\nwhile q:\n    now = q.pop()\n    for new in ad_ls[now]:\n        nex,cost = new[0],new[1]\n        if not done_ls[nex]:\n            cost_ls[nex] = cost + cost_ls[now]\n            done_ls[nex] = 1\n            q.append(nex)\n\ncolor_ls = [0] * n\nfor i in range(n):\n    color_ls[i] = cost_ls[i] % 2\n\nfor color in color_ls:\n    print(color)\n\n", "n=int(input())\nL=[[] for i in range(n+1)]\nfor i in range(n-1):\n    u,v,w=map(int,input().split())\n    L[u].append((v,w%2))\n    L[v].append((u,w%2))\n\nV=[0 for i in range(n+1)]\nV[1]=1\nans=[0 for i in range(n+1)]\nque=[1]\nhead=0\n\nwhile len(que)>head:\n    now=que[head]\n    head+=1\n    for nex in L[now]:\n        if V[nex[0]]==0:\n            V[nex[0]]=1\n            ans[nex[0]]=ans[now]^nex[1]\n            que.append(nex[0])\n    \nfor pri in ans[1:]:\n    print(pri)", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\nfrom collections import deque\ndef main():\n    n = ii()\n    edge = [[] for _ in range(n)]\n    for i in range(n-1):\n        u, v, w = mi()\n        u -= 1\n        v -= 1\n        edge[u].append((v, w))\n        edge[v].append((u, w))\n    dist = [0]*n\n    parent = [-1]*n\n    que = deque([0])\n    while que:\n        v = que.pop()\n        for nv, nx in edge[v]:\n            if parent[v] == nv:\n                continue\n            parent[nv] = v\n            dist[nv] = dist[v]+nx%2\n            dist[nv]%= 2\n            que.append(nv)\n    print(*dist, sep='\\n')\n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "# D - Even Relation\nfrom typing import List, Tuple\n\n\ndef main():\n    N, *X = list(map(int, open(0).read().split()))\n    tree: List[List[Tuple[int, int]]] = [[] for _ in range(N + 1)]\n    for u, v, w in zip(*[iter(X)] * 3):\n        w %= 2\n        tree[u].append((v, w)), tree[v].append((u, w))\n\n    color = [-1] * (N + 1)\n    color[1] = 1\n    stack = [1]\n    while stack:\n        u = stack.pop()\n        cur = color[u]\n        for v, w in tree[u]:\n            if color[v] != -1:\n                continue\n            color[v] = cur ^ w\n            stack.append(v)\n\n    print((\"\\n\".join(map(str, color[1:]))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nG = [[] for n in range(N+1)]\nq = [(1,0)]\nans = N*[-1]\n\nfor n in range(N-1):\n  u,v,w = map(int,input().split())\n  G[u]+=[(v,w)]\n  G[v]+=[(u,w)]\n\nwhile q:\n  x,y = q.pop()\n  ans[x-1] = y%2 \n  for g,d in G[x]:\n    q+=[(g,y+d)]*(ans[g-1]<0)\n\nprint(*ans,sep=\"\\n\")", "N = int(input())\ndist_from_1 = [0 for i in range(N+1)]\n\npaths = [dict() for i in range(N+1)]\nfor i in range(N-1):\n    a, b, dist = list(map(int, input().split()))\n    paths[a][b] = dist\n    paths[b][a] = dist\n\nqueue = [(0, 1, 0)]\nwhile len(queue) != 0:\n    prev, now, dist = queue.pop()\n    dist_from_1[now] = dist\n    for next in paths[now]:\n        if next == prev:\n            continue\n        queue.append((now, next, dist + paths[now][next]))\n\nfor i in range(1, N+1):\n    if dist_from_1[i] % 2 == 0:\n        print((0))\n    else:\n        print((1))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\n\n\ndef dfs(s, p):\n    nonlocal ans\n    for t, w in g[s]:\n        if t == p or ans[t] >= 0:\n            continue\n        ans[t] = ans[s] ^ (w % 2)\n        dfs(t, s)\n\n\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    g[u].append((v, w))\n    g[v].append((u, w))\n\nans = [-1] * n\nans[0] = 0\ndfs(0, -1)\nprint(*ans, sep=\"\\n\")\n", "import sys\nsys.setrecursionlimit(500*500)\nn = int(input())\nl = [list(map(int,input().split())) for _ in range(n-1)]\ng = [[] for _ in range(n)]\n\nfor i in l:\n    v = i[0]-1\n    y = i[1]-1\n    w = i[2]\n    g[v].append([y,w])\n    g[y].append([v,w])\n\nseen = [0] + [-1] * (n-1)\n\ndef dfs(s):\n    for k in g[s]:\n        v,w = k[0],k[1]\n        if seen[v]!=-1:continue\n        seen[v] = seen[s]^(w%2)\n        dfs(v)\n        \ndfs(0)\n\nfor i in seen:\n    print(i)", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n#\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u3067\u9802\u70b91\u3068\u5076\u6570\u8ddd\u96e2\u30920\u3068\u3057\u3066\u5857\u308b\nN=int(input())\nroad=[[] for i in range(N+1)]\nfor _ in range(N-1):\n    u,v,w=list(map(int,input().split()))\n    road[u].append((v,w))\n    road[v].append((u,w))\ndist = [float('inf')for i in range(N+1)]\nans = [0]*(N+1)\n\nq = collections.deque([])\nq.append(1)\ndist[1]=0\nwhile q:\n    now = q.popleft()\n    for goto,cost in road[now]:\n        if dist[goto]>dist[now]+cost:\n            dist[goto]=dist[now]+cost\n            q.append(goto)\n\nfor a in dist[1:]:\n    print((a%2))\n", "# \u518d\u5e30\u306e\u6df1\u3055\u304c1000\u3092\u8d85\u3048\u305d\u3046\u306a\u3068\u304d\u306f\u3053\u308c\u3092\u3084\u3063\u3066\u304a\u304f\nimport sys\nsys.setrecursionlimit(10**7)\n#\u4e8c\u90e8\u30b0\u30e9\u30d5\u306b\u306a\u3063\u3066\u3044\u308b\u6642\u306e\u8272\u306e\u5857\u308a\u5206\u3051\u3092\u805e\u3044\u3066\u3044\u308b\nn=int(input())\nes=[[] for i in range(n)]\nfor i in range(n-1):\n  u,v,w=list(map(int,input().split()))\n  es[u-1].append([v,w])\n  es[v-1].append([u,w])\n\ncolors=[0 for i in range(n)]\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\u3000\u9802\u70b9v\u3092color\u3067\u5857\u308b\u3053\u3068\u3092\u8003\u3048\u308b\ndef dfs(v,color):\n  colors[v-1]=color\n  for i in es[v-1]:\n    if i[1]%2==0 and colors[i[0]-1]==0:\n      dfs(i[0],color)\n    elif i[1]%2==1 and colors[i[0]-1]==0:\n      dfs(i[0],(-1)*color)\n  return colors\n\n    \na=dfs(1,-1)\nfor i in a:\n  if i==-1:\n    print((0))\n  else:\n    print((1))\n  \n", "from collections import deque\n\nn = int(input())\n\ng = [[] for _ in range(n)]\n# 0index\u306b\u76f4\u3057\u3066\u3044\u308b\nfor i in range(n - 1):\n    u, v, w = list(map(int, input().split()))\n    g[u - 1].append((v - 1, w))\n    g[v - 1].append((u - 1, w))\n\n\"\"\"\nex.\n3\n1 2 2\n2 3 1\n\u306e\u5834\u5408\u3001g = [[(1, 2)], [(0, 2), (2, 1)], [(1, 1)]]\n\"\"\"\n\n#print(g)\n\n\"\"\"\n\u6839\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u8ddd\u96e2\u3092d_i\u3068\u3059\u308b\nu,v\u3068\u3044\u30462\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u305d\u306e\u6700\u5c0f\u5171\u901a\u7956\u5148\u3092w\u3068\u3059\u308b\u3068\nu\u3068v\u306e\u8ddd\u96e2=d_u+d_v-2d_w\n\u7b2c3\u9805\u306f\u5e38\u306b\u5076\u6570\nd_u\u3068d_v\u306e\u5076\u5947\u304c\u7b49\u3057\u3051\u308c\u3070\u5168\u4f53\u306f\u5076\u6570\u3001\u5076\u5947\u304c\u7570\u306a\u308c\u3070\u5168\u4f53\u306f\u5947\u6570\n\u4f8b\u3048\u3070\u3001d_i\u304c\u5076\u6570\u306a\u3089\u767d\u306b\u3001\u5947\u6570\u306a\u3089\u9ed2\u306b\u5857\u308b\u3068\u3059\u308c\u3070\u6761\u4ef6\u3092\u6e80\u305f\u3059\n\"\"\"\n\ndq = deque([0])\n#  \u5404\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u6839\u304b\u3089\u306e\u8ddd\u96e2\n# \u9802\u70b90\u3092\u6839\u3068\u3059\u308b\uff08\u5225\u306b\u3069\u308c\u3092\u9078\u3093\u3067\u3082\u826f\u3044\uff09\nds = [-1] * n\nds[0] = 0\n\n# BFS(\u5e45\u512a\u5148\u63a2\u7d22)\nwhile dq:\n    t = dq.popleft()\n    # t\u3068\u7e4b\u304c\u3063\u3066\u3044\u308b\u5404\u9802\u70b9\u306b\u3064\u3044\u3066\n    for i in g[t]:\n        # \u307e\u3060\u8abf\u3079\u3066\u3044\u306a\u3044\u5834\u5408\n        if ds[i[0]] == -1:\n            # \u6839\u304b\u3089t\u307e\u3067\u306e\u8ddd\u96e2+t\u304b\u3089\u6b21\u3078\u306e\u8ddd\u96e2\n            ds[i[0]] = ds[t] + i[1]\n            # \u4eca\u8abf\u3079\u305f\u9802\u70b9\u3092deque\u306b\u8ffd\u52a0\n            dq.append((i[0]))\n\n# \u5076\u6570\u306a\u3089\u767d\u3001\u5947\u6570\u306a\u3089\u9ed2\u3068\u3057\u305f\u3002\u9006\u3067\u3082\u826f\u3044\u3002\nfor i in ds:\n    if i % 2 == 0:\n        print((0))\n    else:\n        print((1))\n", "import sys\nsys.setrecursionlimit(10**9)\n\n\nN = int(input())\nto = [[] for _ in range(N)]\n\nfor _ in range(N - 1):\n    u, v, w = map(int, input().split())\n    u, v = u - 1, v - 1\n    to[u].append([v, w])\n    to[v].append([u, w])\n\n\ndef dfs(v, color):\n    for nv, w in to[v]:\n        if color[nv] == -1:\n            color[nv] = color[v] ^ (w % 2)\n            dfs(nv, color)\n\n\ndef main():\n    color = [-1] * N\n    color[0] = 0\n    dfs(0, color)\n    print(*color, sep='\\n')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\nimport sys\nimport copy\n\nsys.setrecursionlimit(10 ** 9)\n\n\ndef dfs(seen, graph, i):\n    for v, w in graph[i]: \n        if seen[v-1] != -1:\n            continue\n        seen[v-1] = abs((w % 2) - seen[i])\n        dfs(seen, graph, v-1)\n    \n\ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        ui, vi, wi = map(int, input().split())\n        graph[ui-1].append((vi, wi))\n        graph[vi-1].append((ui, wi))\n    \n    seen = [-1 for _ in range(n)]\n    seen[0] = 0\n    for i in range(n-1):\n        dfs(seen, graph, i)\n        \n    print(*seen, sep='\\n')\n        \nmain()\n", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nG = [[] for i in range(N)]\n\nfor i in range(N - 1):\n  u,v,w = map(int,readline().split())\n  G[u - 1].append((v - 1, w))\n  G[v - 1].append((u - 1, w))\n  \ncolor = [-1] * N\nstack = []\nstack.append([0, -1, 0])\nwhile stack:\n  v,parent,cost = stack.pop()\n  color[v] = cost\n  for child in G[v]:\n    if child[0] == parent:\n      continue\n    stack.append([child[0], v, (cost + child[1]) % 2])\n\nfor c in color:\n  print(c)", "# import itertools\n# import math\nimport sys\nsys.setrecursionlimit(500*500)\n# import numpy as np\n\nN = int(input())\n# S = input()\n# n, *a = map(int, open(0))\n# H, W, K = map(int, input().split())\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# S = input()\n\n# d = sorted(d, reverse=True, key=lambda x:x[0])\n# all_cases = list(itertools.permutations(P))\n# a = list(itertools.combinations_with_replacement(range(1, M + 1), N))\n# itertools.product((0,1), repeat=n)\n\n# A = np.array(A)\n# cum_A = np.cumsum(A)\n# cum_A = np.insert(cum_A, 0, 0)\n\nedges = [list(map(int,input().split())) for _ in range(N-1)]\ntree = [[] for _ in range(N + 1)]\n\nfor edge in edges:\n    tree[edge[0]].append([edge[1], edge[2]])\n    tree[edge[1]].append([edge[0], edge[2]])\n\n# print(tree)\n\ndepth = [-1] * (N + 1)\ndepth[1] = 0\n\ndef dfs(tree, s):\n    for l in tree[s]:\n        if depth[l[0]] == -1:\n            depth[l[0]] = depth[s] + l[1]\n            dfs(tree, l[0])\n\ndfs(tree, 1)\n\n# print(depth)\n\nfor l in depth[1:]:\n    if l % 2 == 0:\n        print((1))\n    else:\n        print((0))\n", "import sys\nsys.setrecursionlimit(10**5)\n\ndef f(x):\n  for tmp in links[x]:\n    if c[tmp[0]]<0:\n      if tmp[1]%2==0:\n        c[tmp[0]]=c[x]+0\n      else:\n        c[tmp[0]]=1-c[x]\n      f(tmp[0])\n\nN=int(input())\nlinks=[[] for _ in range(N+1)]\nfor _ in range(N-1):\n  u, v, w=map(int, input().split())\n  links[u].append([v, w])\n  links[v].append([u, w])\n  \nc=[-1]*(N+1)\nc[1]=0\nf(1)\n\nprint(*c[1:], sep='\\n')", "#coding: utf-8\nfrom collections import defaultdict, deque\n\nN = int(input())\nG = {}\nfor i in range(1, N+1):\n    G[i] = []\n\nfor i in range(N-1):\n    u, v, w = (int(n) for n in input().split())\n    G[u].append((v, w))\n    G[v].append((u, w))\n\nret = [-1] * (N+1)\n\nque = deque()\nque.append((1, 0))\n\nwhile len(que) > 0:\n    node, distance = que[0]\n    que.popleft()\n\n    ret[node] = distance % 2\n    for next_node, next_distance in G[node]:\n        if ret[next_node] == -1:\n            que.append((next_node, distance + next_distance))\n\nfor i in range(N):\n    print((ret[i+1]))\n\n", "#!/usr/bin/env python3\nfrom collections import deque\n\nn = int(input())\ng = [list() for _ in range(n)]\nvisited = [True] * n\ncoler = [0] * n\nfor _ in range(1, n):\n    v1, v2, w = map(int, input().split())\n    v1 -= 1\n    v2 -= 1\n    w %= 2\n    g[v1].append((v2, w))\n    g[v2].append((v1, w))\n\nq = deque([0])\nvisited[0] = False\nwhile q:\n    a = q.pop()\n    for v, w in g[a]:\n        if visited[v]:\n            visited[v] = False\n            coler[v] = (coler[a] + w) % 2\n            q.append(v)\n\nprint(*coler, sep=\"\\n\")\n", "import sys\nsys.setrecursionlimit(10**7)\nN = int(input())\n\nGraph = [[] for _ in range(N+10)]\ndist  = [10000000000000]*(N+10)\n\nfor i in range(N-1):\n\tu,v,w = map(int,input().split())\n\tu-=1\n\tv-=1\n\tGraph[u].append((v,w))\n\tGraph[v].append((u,w))\n\ndist[0] = 0\n\ndef func(fromE,now,length):\n\tif fromE != -1:\n\t\tdist[now] = dist[fromE]+length\n\tfor i in range(len(Graph[now])):\n\t\ttarget = Graph[now][i][0]\n\t\tlengt  = Graph[now][i][1]\n\n\t\tif target == fromE:\n\t\t\tcontinue\n\n\t\tfunc(now,target,lengt)\n\nfunc(-1,0,0)\n\nfor i in range(N):\n\tif dist[i]%2 == 0:\n\t\tprint(0)\n\telse:\n\t\tprint(1)", "import sys\nsys.setrecursionlimit(10**6)\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\ndef main():\n    def dfs(node):\n        for adjnode in edges[node]:\n            if colors[adjnode[0]] == -1:\n                if adjnode[1] % 2 == 0:\n                    colors[adjnode[0]] = colors[node]\n                else:\n                    colors[adjnode[0]] = colors[node] ^ 1\n                dfs(adjnode[0])\n    # input\n    n = int(input())\n    edges = {e: [] for e in range(n)}\n    for _ in range(n - 1):\n        u, v, w = map(int, input().split())\n        u -= 1\n        v -= 1\n        edges[u].append((v, w))\n        edges[v].append((u, w))\n    # process\n    colors = [-1] * n\n    colors[0] = 0\n    dfs(0)\n    # output\n    print(*colors, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nlinks = [[] for _ in range(N)]\nresult = [0 for _ in range(N)]\nmemo = [0 for _ in range(N)]\nfor _ in range(N-1):\n  u, v, w = map(int, input().split())\n  u -= 1\n  v -= 1\n  links[u].append([v, w])\n  links[v].append([u, w])\ndef color(u):\n  if memo[u]:\n    return\n  for l in links[u]:\n    result[l[0]] = abs(l[1]%2-result[u])\n  memo[u] = 1\n  for l in links[u]:\n    color(l[0])\ncolor(0)\nfor r in result:\n  print(r)", "from collections import deque\n\nN = int(input())\ndist = {}\ngraph = [[] for i in range(N)]\n\nfor i in range(1, N):\n    u, v, w = list(map(int, input().split()))\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n    dist[(u-1, v-1)] = w\n\n\nq = deque()\nq.append(0)\n\ncolor = [-1] * N\ncolor[0] = 0\n\nwhile q:\n    now = q.popleft()\n\n    for adj in graph[now]:\n        if color[adj] == -1:\n            if now < adj:\n                color[adj] = color[now] + dist[(now, adj)]\n            else:\n                color[adj] = color[now] + dist[(adj, now)]\n\n            q.append(adj)\n\n\nfor i in range(N):\n    print((color[i] % 2))\n", "from collections import deque\n\nN = int(input())\nconn = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    u, v, w = [int(x) for x in input().split()]\n    conn[u].append([v, w])\n    conn[v].append([u, w])\n\nq = deque([1])\nd = [-1]* (N + 1)\nd[1] = 0\nwhile q:\n    u = q.popleft()\n    for e in conn[u]:\n        v, w = e[0], e[1]\n        if d[v] == -1:\n            d[v] = d[u] + w\n            q.append(v)\n\nfor v in range(1, N + 1):\n    print(d[v] % 2)", "import sys\nfrom heapq import heappush, heappop\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, *UVW = map(int, read().split())\n    G = [[] for _ in range(N)]\n    for u, v, w in zip(*[iter(UVW)] * 3):\n        G[u - 1].append((v - 1, w))\n        G[v - 1].append((u - 1, w))\n\n    dist = [INF] * N\n    dist[0] = 0\n    hq = [(0, 0)]\n\n    while hq:\n        d, v = heappop(hq)\n        if d > dist[v]:\n            continue\n        for nv, cost in G[v]:\n            if dist[nv] > dist[v] + cost:\n                dist[nv] = dist[v] + cost\n                heappush(hq, (dist[nv], nv))\n\n    ans = [0] * N\n    for i in range(N):\n        ans[i] = 0 if dist[i] % 2 == 0 else 1\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\n \n \ndef bfs(start):\n    q = deque([start])\n    dist = [-1] * N\n    dist[start] = 0\n    while q:\n        v = q.popleft()\n        for nv, nw in g[v]:\n            if dist[nv] >= 0:\n                continue\n            dist[nv] = (dist[v] + nw) % 2\n            q.append(nv)\n    return dist\n \n \nN, *UVW = map(int, open(0).read().split())\ng = defaultdict(set)\n \nans = [0] * N\nfor u, v, w in zip(*[iter(UVW)] * 3):\n    u -= 1\n    v -= 1\n    g[u].add((v, w))\n    g[v].add((u, w))\nprint(\"\\n\".join(map(str, bfs(0))))", "def f(G, not_searched, results={0: '0'}):\n    stack = []\n    while len(not_searched) > 0:\n        if len(stack) > 0:\n            i = stack.pop()\n            not_searched.remove(i)\n        else:\n            i = not_searched.pop()\n\n        for key, val in G[i].items():\n            if not key in not_searched:\n                continue\n\n            if val % 2 == 1:\n                if results[i] == '0':\n                    results[key] = '1'\n                else:\n                    results[key] = '0'\n            else:\n                results[key] = results[i]\n\n            stack.append(key)\n\n    return results\n\nN = int(input())\nG = [{} for _ in range(N)]\nnot_searched = set([i for i in range(N)])\n\nif N == 1:\n    print(results[0])\nelse:\n    for i in range(N-1):\n        u, v, w = map(int, input().split())\n        G[u-1][v-1] = w\n        G[v-1][u-1] = w\n\n    results = f(G, not_searched)\n    for i in range(N):\n        print(results[i])", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nN = int(input())\n\nedges = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v, w = map(int, input().split())\n    edges[u-1].append((v-1, w))\n    edges[v-1].append((u-1, w))\n\nq = deque()\nq.append((0, 0))\ncolor = {}\nwhile q:\n    node, dist = q.popleft()\n    if node in color:\n        continue\n    if dist % 2 == 0:\n        color[node] = 0\n    else:\n        color[node] = 1\n    for n_node, n_dist in edges[node]:\n        q.append((n_node, dist+n_dist))\n\nfor i in range(N):\n    print(color[i])", "import sys\nfrom collections import deque\nreadline = sys.stdin.readline\nn = int(readline())\nG = [[] for _ in range(n)]\nfor _ in range(n-1):\n    u,v,w = map(int, readline().split())\n    G[u-1].append((v-1,w))\n    G[v-1].append((u-1,w))\n\nV = [-1]*n\nV[0] = 0\nque = deque([0])\nwhile que:\n    nw = que.popleft()\n    for nx,d in G[nw]:\n        if V[nx]!=-1: continue\n        V[nx] = (V[nw]+d)%2\n        que.append(nx)\n\nfor v in V:\n    print(v)", "g = {}\na = int(input())\nfor i in range(a - 1):\n    c = [int(s) for s in input().split()]\n    if c[0] not in g: g[c[0]] = [(c[1], c[2])]\n    else: g[c[0]].append((c[1], c[2]))\n\n    if c[1] not in g: g[c[1]] = [(c[0], c[2])]\n    else: g[c[1]].append((c[0], c[2]))\n\nc = {}\nd = {i: False for i in range(1, a + 1)}\nc[1], d[1] = 0, True\nQ = [1]\nwhile(Q != []):\n    r = Q.pop(0)\n    for i in g[r]:\n        if d[i[0]] == False:\n            d[i[0]] = True\n            Q.append(i[0])\n            if i[1] % 2 == 0: c[i[0]] = c[r]\n            else: c[i[0]] = (c[r] + 1) % 2\nfor i in range(1, a + 1): print(c[i])", "from collections import deque\nN = int(input())\n#\u96a3\u63a5\u30ea\u30b9\u30c8\ng = [[] for i in range(N)]\nfor i in range(N-1):\n  u,v,w = list(map(int,input().split()))\n  g[u-1].append([v-1,w])\n  g[v-1].append([u-1,w])\nq = deque()\n#\u901a\u3063\u305f\u304b\u3069\u3046\u304b\ncheck = [0] * N\ncheck[0] = 1\nq.append(0)\nans = [-1] * N\nans[0] = 0\nwhile len(q) > 0:\n  e = q.popleft()\n  for i,j in g[e]:\n    if check[i] == 1:\n      continue\n    ans[i] = (ans[e] + j) %2\n    check[i] = 1\n    q.append(i)\nfor i in range(N):\n  print((ans[i]))\n", "from collections import deque\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor _ in range(N - 1):\n    u, v, w = list(map(int, input().split()))\n    u, v = u - 1, v - 1\n    graph[u].append([v, w])\n    graph[v].append([u, w])\n\ncolors = [-1 for _ in range(N)]\nstack = deque()\nstack.append(0)\ncolors[0] = 0\n\nwhile stack:\n    n = stack.popleft()\n    for _next, w in graph[n]:\n        if colors[_next] != -1:\n            continue\n        colors[_next] = (colors[n] + w) % 2\n        stack.append(_next)\n\nfor c in colors:\n    print(c)\n", "import sys\nsys.setrecursionlimit(1000000)\n\ndef dfs(color, u):\n    for v in conn[u]:\n        if not (color[v] == -1):\n            continue\n        color[v] = (color[u] + weight[(u, v)]) % 2\n        dfs(color, v)\n\nN = int(input())\n\nconn = [[] for _ in range(N + 1)]\nweight = {}\nfor _ in range(N - 1):\n    u, v, w = list(map(int, input().split()))\n    conn[u].append(v)\n    conn[v].append(u)\n    weight[(u, v)] = w\n    weight[(v, u)] = w\n\ncolor = [-1]*(N + 1)\ncolor[1] = 0\ndfs(color, 1)\nfor i in range(1, N + 1):\n    print((color[i]))\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**7)\nimport bisect\nimport heapq\nimport itertools\nimport math\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom math import gcd\nfrom operator import add, itemgetter, mul, xor\ndef cmb(n,r,mod):\n  bunshi=1\n  bunbo=1\n  for i in range(r):\n    bunbo = bunbo*(i+1)%mod\n    bunshi = bunshi*(n-i)%mod\n  return (bunshi*pow(bunbo,mod-2,mod))%mod\nmod = 10**9+7\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return list(map(int,input().split()))\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\n\nn = I()\ngraph =[[]*(n+1) for i in range(n+1)]\nans = [0]*(n+1)\nfor i in range(n-1):\n    u,v,w = list(map(int,input().split()))\n    w = w%2\n    graph[u].append([v,w])\n    graph[v].append([u,w])\n#v\u3092c\u306b\u5857\u308b\u3002p\u306fv\u306e\u89aa\ndef dfs(v,p,c,ans):\n    ans[v] = c\n    for i in graph[v]:\n        if i[0] == p:\n            continue\n        if i[1] == 1:\n            dfs(i[0],v,1-c,ans)\n        if i[1] == 0:\n            dfs(i[0],v,c,ans)\ndfs(1,0,0,ans)\nfor i in ans[1:]:\n    print(i)\n", "def inpl(): return list(map(int, input().split()))\nN = int(input())\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v, w = inpl()\n    G[u-1].append((v-1, w))\n    G[v-1].append((u-1, w))\n\nQ = [(0, 0)]\nsearched = [0]*N\nsearched[0] = 1\nans = [-1]*N\nans[0] = 0\n\nwhile Q:\n    p, c = Q.pop()\n    for q, d in G[p]:\n        if searched[q]:\n            continue\n        ans[q] = (c+d)%2\n        searched[q] = 1\n        Q.append((q, ans[q]))\nprint(*ans, sep=\"\\n\")", "n = int(input())\nvisited = [False] * (n + 1)\ndistance = [0] * (n + 1)\nprev = [0] * (n + 1)\n\nfrom collections import defaultdict, deque\nd = defaultdict(list)\n\nfor _ in range(n-1):\n    u,v,w = list(map(int, input().split()))\n    d[u].append((v, w))\n    d[v].append((u, w))\n\nq = deque([1])\nwhile q:\n    node = q.popleft()\n    visited[node] = True\n    for next_node, next_dist in d[node]:\n        if not visited[next_node]:\n            q.append(next_node)\n            # \u8ddd\u96e2\u3092\u66f4\u65b0\n            distance[next_node] = distance[node] + next_dist\n    \n# print(distance)\nfor dist in distance[1:]:\n    print(dist%2)", "# coding: utf-8\nimport sys\n\n# from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nprintout = sys.stdout.write\nsprint = sys.stdout.flush\n#from heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n#import math\n# from itertools import product, accumulate, combinations, product\n#import bisect\n# import numpy as np\n# from copy import deepcopy\nfrom collections import deque\n# from decimal import Decimal\n# from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 998244353\n\n\ndef intread():\n    return int(sysread())\ndef mapline(t=int):\n    return list(map(t, sysread().split()))\ndef mapread(t=int):\n    return list(map(t, read().split()))\n\ndef dfs(c, num, to, cols):\n    for n, nw in to[c]:\n        if cols[n] == -1:\n            y = (num + nw) % 2\n            cols[n] = (num + nw) % 2\n            dfs(n, y, to, cols)\n\ndef run():\n    N = intread()\n    to = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v, w = mapline()\n        to[u].append((v, w))\n        to[v].append((u, w))\n    cols = [-1] * (N+1)\n    cols[1] = 0\n    dfs(1, 0, to, cols)\n\n    for x in cols[1:]:\n        print(x)\n\ndef __starting_point():\n    run()\n\n__starting_point()", "from collections import deque\n\nN = int(input())\ngraph = [[] for _ in range(N)]\ndist = [-1] * N\nfor _ in range(N-1):\n  u, v, w = map(int, input().split())\n  graph[u-1].append((v-1, w))\n  graph[v-1].append((u-1, w))\nq = deque()\n\ndist[0] = 0\nq.append(0)\n\nwhile len(q) != 0:\n  v = q.popleft()\n  for next_v, next_w in graph[v]:\n    if dist[next_v] != -1:\n      continue\n    dist[next_v] = dist[v] + next_w\n    q.append(next_v)\n\nfor d in dist:\n  if d%2 == 0:\n    print(0)\n  else:\n    print(1)", "from collections import defaultdict\n\nN = int(input())\nedges = defaultdict(list)\nfor _ in range(N-1):\n    u, v, w = map(int, input().split())\n    u-=1\n    v-=1\n    edges[u].append((v, w))\n    edges[v].append((u, w))\n\ncolors = [None] * N\n\nstack = [(0, 0)]\n\nwhile stack:\n    u, c = stack.pop()\n    if colors[u] != None:\n        continue\n    colors[u] = c\n    for v, w in edges[u]:\n        stack.append((v, (c+w)%2))\n\nfor u in range(N):\n    print(colors[u])", "from collections import deque\n\nN=int(input())\nG=[{} for _ in range(N+1)]\n\nfor i in range(N-1):\n  u,v,w=map(int,input().split())\n  G[u][v]=w\n  G[v][u]=w\n  \nfor i in range(1,N+1):\n  if len(G[i])==1:\n    start=i\n    break\n\ndef bfs(s):\n    seen = [0 for i in range(N+1)]\n    d = [0 for i in range(N+1)]\n    todo = deque([])\n    now = s\n    seen[now]=1\n    todo.append(now)\n    while 1:\n      if len(todo)==0:break\n      a = todo.popleft()\n      for b in G[a]:\n        if seen[b] == 0:\n          seen[b] = 1\n          todo.append(b)\n          d[b] += d[a] + G[a][b]\n    return d\n\nd = bfs(start)\nfor i in range(1,N+1):\n  d_ = d[i]\n  if d_ % 2 == 0:print(0)\n  else:print(1)", "import sys\nsys.setrecursionlimit(2147483647)\ninput=sys.stdin.readline\n\ndef search(nodes, searched, labels, v):\n  searched[v] = 1\n  label = labels[v]\n  for l in nodes[v]:\n    x, w = l\n    if not searched[x]:\n      if w %2 == 0:\n        labels[x] = label\n      else:\n        labels[x] = (label + 1) % 2\n      search(nodes, searched, labels, x)\n\ndef solve(n, nodes):\n  searched = [0]*n\n  labels = [None]*n\n  labels[0] = 0\n  search(nodes, searched, labels, 0)\n  return labels\n\ndef main():\n  n = int(input())\n  nodes = [[] for _ in range(n)]\n  for _ in range(n-1):\n    v, u, w = map(int, input().split(' '))\n    nodes[v-1].append((u-1,w))\n    nodes[u-1].append((v-1,w))\n  ans = solve(n, nodes)\n  for r in ans:\n    print(r)\n  \n\ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\n\nN = int(input())\n\nlength = {}\nconn = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    u, v, w = [int(x) for x in input().split()]\n    conn[u].append(v)\n    conn[v].append(u)\n    length[(u, v)] = w\n\nq = deque([1])\ndist = [-1] * (N + 1)\ndist[1] = 0\nwhile q:\n    u = q.popleft()\n    for v in conn[u]:\n        if dist[v] == -1:\n            if u < v:\n                dist[v] = dist[u] + length[(u, v)]\n            else:\n                dist[v] = dist[u] + length[(v, u)]\n            q.append(v)\n\nfor i in range(1, N + 1):\n    print(dist[i] % 2)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v, w = LI()\n        G[u-1].append((v - 1, w))\n        G[v-1].append((u - 1, w))\n\n    # print(G)\n\n    ans = [-1] * N\n    ans[0] = 0\n    visited = [False] * N\n\n    def dfs(c):\n        visited[c] = True\n        for n, w in G[c]:\n            if not visited[n]:\n                if w % 2 == 0:\n                    ans[n] = ans[c]\n                else:\n                    ans[n] = 1 - ans[c]\n                dfs(n)\n\n    dfs(0)\n\n    for i in ans:\n        print(i)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n  u, v, w = map(int, input().split())\n  g[u-1].append((v-1,w))\n  g[v-1].append((u-1,w))\nds = [-1]*n\ndq = deque([0])\nds[0] = 0\nwhile dq:\n  t = dq.popleft()\n  for i in g[t]:\n    if ds[i[0]] == -1:\n      ds[i[0]] = ds[t] + i[1]\n      dq.append((i[0]))\nfor i in ds:\n  if i%2 == 0:\n    print(0)\n  else:\n    print(1)", "import heapq\n\ndef dijkstra(G, s, dist):\n    dist[s] = 0\n    Q = [[0,s]]\n    heapq.heapify(Q)\n\n    while(len(Q) > 0):\n        cur_d, cur_v = heapq.heappop(Q)\n        cur_d *= -1\n        \n        if(cur_d > dist[cur_v]): continue\n\n        for e in G[cur_v]:\n            to, cost = e[0], e[1]\n            if(dist[cur_v] + cost < dist[to]):\n                dist[to] = dist[cur_v] + cost\n                heapq.heappush(Q, [-dist[to], to])\n\nN = int(input())\n\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    u, v, w = list(map(int,input().split()))\n    u, v = u-1, v-1\n    G[u].append([v,w])\n    G[v].append([u,w])\n\ndist = [1e18] * N\ndijkstra(G,0,dist)\n\nfor d in dist:\n    if d % 2 == 0:\n        print((0))\n    if d % 2 == 1:\n        print((1))\n\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# \u4e8c\u5206\u30b0\u30e9\u30d5\nN = int(input())\ngraph = [[] for _ in range(N)]\ncolor = [-1]*N\n\n# \u96a3\u63a5\u30ea\u30b9\u30c8\u306e\u4f5c\u6210\nfor i in range(N-1):\n    a, b, w = map(int, input().split())\n    a -= 1\n    b -= 1\n    w %= 2\n    graph[a].append((b,w))\n    graph[b].append((a,w))\n\nnext_q = [(0, 0)]\nwhile len(next_q)>0:\n    nw, nc = next_q.pop()\n    color[nw] = nc\n    for nxt, nl in graph[nw]:\n        if color[nxt]==-1:\n            next_q.append((nxt,(nl+nc)%2))\nfor i in color:\n    print(i)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\ndef bfs():\n    dist = [-1]*n\n    que = deque([0])\n    dist[0] = 0\n    while que:\n        v = que.popleft()\n        d = dist[v]\n        for w in g[v]:\n            if dist[w[0]] > -1:\n                continue\n            dist[w[0]] = d + w[1]\n            que.append(w[0])\n    return dist\n\nn = INT()\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    x, y, z = MAP()\n    g[x-1].append([y-1, z])\n    g[y-1].append([x-1, z])\nfor k in bfs():\n    print(0 if k%2 == 0 else 1)", "def abc126_d():\n    import sys\n    sys.setrecursionlimit(10010010)\n    read = sys.stdin.buffer.read\n    inp = iter(map(int, read().split()))\n\n    N = next(inp)\n    G = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u = next(inp) - 1\n        v = next(inp) - 1\n        w = next(inp)\n        G[u].append((v, w))\n        G[v].append((u, w))\n\n    color = [-1] * N\n    color[0] = 0\n\n    def dfs(u):\n        for v, w in G[u]:\n            if color[v] != -1: continue\n            if w % 2 == 0:\n                color[v] = color[u]\n            else:\n                color[v] = abs(color[u] - 1)\n            dfs(v)\n\n    dfs(0)\n    print(*color, sep='\\n')\n\ndef __starting_point():\n    abc126_d()\n__starting_point()", "N=int(input())\ntree=[[] for i in range(N)]\nfor i in range(N-1):\n  u,v,w=map(int,input().split())\n  tree[u-1].append((v-1,w))\n  tree[v-1].append((u-1,w))\nh=[]\nh.append(0)\ndistance=[-1 for i in range(N)]\ndistance[0]=0\nwhile h:\n  k=h.pop(0)\n  for v in tree[k]:\n    x=v[0]\n    y=v[1]\n    if distance[x]==-1:\n      distance[x]=distance[k]+y\n      h.append(x)\nfor i in range(N):\n  if distance[i]%2==0:\n    print(0)\n  else:\n    print(1)", "from collections import deque\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    g[u].append([v, w])\n    g[v].append([u, w])\nused = [0]*n\nused[0] = 1\nparity = [-1]*n\nparity[0] = 0\nque = deque()\nque.append(0)\nwhile que:\n    # print(que)\n    v = que.popleft()\n    for nv, w in g[v]:\n        if used[nv]:\n            continue\n        parity[nv] = (parity[v] + w)%2\n        used[nv] = 1\n        que.append(nv)\n\n# print(used)\nfor i in range(n):\n    print(parity[i])", "from collections import deque, defaultdict\nn = int(input())\nl = []\ndc = [-1]*n\nd = defaultdict(list)\nfor i in range(n-1):\n  u,v,w = list(map(int,input().split()))\n  w %= 2\n  d[u-1].append([v-1,w])\n  d[v-1].append([u-1,w])\n# print(d)\n\nQ = deque()\nQ.append(0)\ndc[0] = 0\nwhile Q:\n  q = Q.pop()\n\n  for v,w in d[q]:\n    if dc[v] == -1:\n      dc[v] = (dc[q] +w)%2\n      Q.append(v)\n\nfor i in dc:\n  print(i)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n# \u554f\u984c\uff1ahttps://atcoder.jp/contests/abc126/tasks/abc126_d\n\n\nclass Graph():\n\n    def __init__(self):\n        self.adjacency_dict = {}\n        self.weight = []\n    \n    def add_vertex(self, v):\n        self.adjacency_dict[v] = []\n        self.weight.append([])\n\n    def add_edge(self, v1, v2, w):\n        self.adjacency_dict[v1].append(v2)\n        self.adjacency_dict[v2].append(v1)\n        self.weight[v1].append(w)\n        self.weight[v2].append(w)\n\n    def get_vertexes(self):\n        return list(self.adjacency_dict.keys())\n\n    def get_edges(self, v):\n        return self.adjacency_dict[v], self.weight[v]\n\n    def print_graph(self):\n        print((self.adjacency_dict))\n\nn = int(input())\n\nres = []\ng = Graph()\nfor i in range(n):\n    res.append(-1)\n    g.add_vertex(i)\n\nfor i in range(n-1):\n    u, v, w = list(map(int, input().strip().split()))\n    g.add_edge(u-1, v-1, w % 2)\n\nq = []\nres[0] = 0\nq.append(0)\nwhile(len(q) > 0):\n    v = q.pop()\n    u_l, w_l = g.get_edges(v)\n    for u, w in zip(u_l, w_l):\n        if res[u] != -1:\n            continue\n        res[u] = (res[v] + w) % 2\n        q.append(u)\n\nfor i in range(n):\n    print((res[i]))\n", "from collections import deque\n\nn=int(input())\nch=0\ng=[[] for _ in range(n)]\nk=[[] for _ in range(n)]\nfor i in range(n-1):\n  u,v,w=list(map(int,input().split()))\n  if w%2==0:\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n  else:\n    k[u-1].append(v-1)\n    k[v-1].append(u-1)\n    ch1=u-1\n    ch2=v-1\n    ch=1\n\n## 0:White 1:Black\nans=[-1 for _ in range(n)]\n\nif ch>0:\n  ans[ch1]=0\n  d=[ch1]\n  qu=deque(d)\n  while qu:\n    p=qu.popleft()\n    \n    for gr in g[p]:\n      if ans[gr]==-1:\n        if ans[p]==0:\n          ans[gr]=0\n          qu.append(gr)\n        else:\n          ans[gr]=1\n          qu.append(gr)\n      \n    for kr in k[p]:\n      if ans[kr]==-1:\n        if ans[p]==0:\n          ans[kr]=1\n          qu.append(kr)\n        else:\n          ans[kr]=0\n          qu.append(kr)   \n    \n          \n  for j in range(n):\n    print((ans[j]))\n    \nelse:\n  for j in range(n):\n    print((0))\n      \n  \n\n", "import sys\nsys.setrecursionlimit(1<<30)\n\nN = int(input())\ndef dfs(x):\n    for y in Tree[x]:\n        if Parent[x] != y:\n            Parent[y] = x\n            distance[y] += Web[min(x,y),max(x,y)]+distance[x]\n            dfs(y)\nTree = [[] for i in range(N+1)]\nParent = [0]*(N+1)\nWeb = dict()\nfor i in range(N-1):\n    a,b,w = map(int,input().split())\n    Tree[a].append(b)\n    Tree[b].append(a)\n    Web[(min(a,b),max(a,b))] = w\ndistance = [0]*(N+1)\ndfs(1)\nfor i in distance[1:]:\n    if i%2 == 0:\n        print(1)\n    else:\n        print(0)", "import sys\nfrom sys import stdin\ninput = stdin.readline\nsys.setrecursionlimit(20000000)\n \n \ndef main():\n  N = int(input())\n  G = [[] for _ in range(N+1)]\n  for i in range(N-1):\n    u, v, w = map(int, input().split())\n    G[u].append((v, w))\n    G[v].append((u, w))\n \n  color = [-1]*(N+1)\n  color[1] = 0\n  # S = [1]\n  # while len(S):\n  #   now = S[-1]\n  #   for next_, w in G[now]:\n  #     if color[next_] != -1:\n  #       continue\n  #     S.append(next_)\n  #     color[next_] = (w % 2) ^ color[now]\n  #     break\n  #   else:\n  #     S.pop()\n \n  def dfs(now):\n    for next_, w in G[now]:\n      if color[next_] == -1:\n        color[next_] = (w % 2) ^ color[now]\n        dfs(next_)\n  dfs(1)\n \n  for i in range(1, N+1):\n    print(color[i])\n \n \nif(__name__ == '__main__'):\n  main()", "#import math\n#import itertools\nfrom collections import deque\n\nINT = lambda: int(input())\nINTM = lambda: map(int,input().split())\nSTRM = lambda: map(str,input().split())\nSTR = lambda: str(input())\nLIST = lambda: list(map(int,input().split()))\nLISTS = lambda: list(map(str,input().split()))\n\nclass Graph():\n    def __init__(self, v):\n        self.v = v\n        self.graph = [[] for _ in range(v)]\n        self.INF = 10 ** 9\n    \n    def addEdge(self, start, end, dist):\n        self.graph[start].append((end, dist))\n        self.graph[end].append((start, dist))\n\ndef do():\n    n=INT()\n    g=Graph(n)\n    for i in range(n-1):\n        u,v,d=INTM()\n        u-=1\n        v-=1\n        g.addEdge(u,v,d)\n\n    que=deque()\n    check=[True]*n\n    dists=[-1]*n\n    check[0]=False\n    dists[0]=0\n    que.append([0,0])\n    while que:\n        now,dist_f=que.popleft()\n        for next,dist in g.graph[now]:\n            if check[next]:\n                check[next]=False\n                temp=dist_f+dist\n                dists[next]=temp\n                que.append([next,temp])\n\n    for i in dists:\n        if i%2==0:\n            print(0)\n        else:\n            print(1)\n    \ndef __starting_point():\n    do()\n__starting_point()", "import _heapq\ninf=float(\"inf\")\n\n\ndef prim():\n    color=[\"white\" for _ in range(n+1)]\n    D=[inf for _ in range(n+1)]\n    M=[[] for _ in range(n+1)]\n\n    for u,v,w in UVW:\n        M[u].append([w,v])\n        M[v].append([w,u])\n\n    queue=[[0,1]]\n    _heapq.heapify(queue)\n    color[1]=\"gray\"\n    D[1]=1\n\n    while len(queue)>0:\n        num=_heapq.heappop(queue)[1]\n        if color[num]==\"black\":continue\n        color[num]=\"black\"\n\n        for i,j in M[num]:\n            if D[j]>i and color[j]!=\"black\":\n                if i%2==0:D[j]=D[num]\n                else:D[j]=-D[num]\n                color[j]=\"gray\"\n                _heapq.heappush(queue,[i,j])\n\n    return D[1:]\n\n\nn=int(input())\nUVW=[list(map(int,input().split())) for _ in range(n-1)]\nfor i in prim():\n    if i==1:print(i)\n    else:print(0)"]
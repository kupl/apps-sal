["import sys\nfrom operator import itemgetter\nreadline = sys.stdin.readline\n\nsys.setrecursionlimit(2*10**6)\nclass UF():\n    def __init__(self, num):\n        self.par = [-1]*num\n        self.size = [1]*num\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry] \n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.size[ry] += self.size[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.size[rx] += self.size[ry]\n        return\n\ndef parorder(Edge, p):\n    N = len(Edge)\n    Cs = [None]*N\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf, cost in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            Cs[vf] = cost\n            ast(vf)\n    return par, order, Cs\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\nMOD = 10**9+7\nN, M = list(map(int, readline().split()))\nX = int(readline())\nEdge = []\nfor _ in range(M):\n    a, b, c = list(map(int, readline().split()))\n    a -= 1\n    b -= 1\n    Edge.append((c, a, b))\n\nEdge.sort(key = itemgetter(0))\n\nT = UF(N)\n\ncnt = 0\nidx = 0\ntEdge = [[] for _ in range(N)]\noEdge = []\nmst = 0\nwhile cnt < N-1:\n    while True:\n        cost, x, y = Edge[idx]\n        rx = T.find(x)\n        ry = T.find(y)\n        idx += 1\n        if rx != ry:\n            break\n        oEdge.append((cost, x, y))\n    cnt += 1\n    tEdge[x].append((y, cost))\n    tEdge[y].append((x, cost))\n    mst += cost\n    T.union(x, y)\nfor i in range(idx, M):\n    oEdge.append(Edge[i])\n    \n\nroot = 0\nP, L, Cs = parorder(tEdge, root)\n#C = getcld(P)\n\nLeng = [0]*N\nfor i in L[1:]:\n    p = P[i]\n    Leng[i] = 1 + Leng[p]\n\nDl = [list(range(N))] + [[P[i] for i in range(N)]]\ndepth = N.bit_length()\nfor _ in range(depth-1):\n    res = [-1]*N\n    for i in range(N):\n        a = Dl[-1][i]\n        if a != root and a != -1:\n            res[i] = Dl[-1][a]\n    Dl.append(res)\n\ndata = [[0]*N] + [[0 if i == root else Cs[i] for i in range(N)]]\n\nfor j in range(depth-1):\n    res = [0]*N\n    for i in range(N):\n        a = Dl[j+1][i]\n        if a != root and a != -1 and data[-1][a]:\n            res[i] = max(data[-1][i], data[-1][a])\n    data.append(res)\n\ndef query(u0, v0):\n    u, v = u0, v0\n    if Leng[u] > Leng[v]:\n        u, v = v, u\n    dif = Leng[v] - Leng[u]\n    res = 0\n    for i in range(dif.bit_length()):\n        if (1<<i) & dif:\n            res = max(res, data[i+1][v])\n            v = Dl[i+1][v]\n    ll = Leng[u].bit_length()\n    for i in range(ll):\n        k = ll-1-i\n        if Dl[k+1][v] != Dl[k+1][u]:\n            res = max(res, data[k+1][v], data[k+1][u])\n            u = Dl[k+1][u]\n            v = Dl[k+1][v]\n\n    if u != v:\n        res = max(res, Cs[v], Cs[u])\n        \n    return res\n\nif mst == X:\n    ans = (pow(2, N-1, MOD) - 2) * pow(2, M-(N-1), MOD) % MOD\nelse:\n    ans = 0\ncue = 0\nran = 0\ndec = 0\nfor c, u, v in oEdge:\n    me = query(u, v)\n    if mst + c - me < X:\n        dec += 1\n    elif mst + c - me == X:\n        cue += 1\n    else:\n        ran += 1\n\nans = (ans + 2*(pow(2, cue)-1)*pow(2, ran, MOD))%MOD\n\nprint(ans)\n", "N, M = map(int, input().split())\nX = int(input())\nE = []\nC = {}\nfor i in range(M):\n    u, v, w = map(int, input().split())\n    E.append((w, u-1, v-1))\n    C[w] = C.get(w, 0) + 1\nE.sort()\n\n*p, = range(N)\ndef root(x):\n    if x == p[x]:\n        return x\n    y = p[x] = root(p[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n    return 1\n\nMOD = 10**9 + 7\n\nG0 = [[] for i in range(N)]\nK = 0\nlast = None\nU = [0]*M\ncost = 0\nfor i in range(M):\n    w, u, v = E[i]\n    if unite(u, v):\n        cost += w\n        U[i] = 1\n        if last != w:\n            K += C[w]\n        G0[u].append((v, w))\n        G0[v].append((u, w))\n        last = w\ndef dfs0(u, p, t, cost):\n    if u == t:\n        return 0\n    for v, w in G0[u]:\n        if v == p:\n            continue\n        r = dfs0(v, u, t, cost)\n        if r is not None:\n            return r | (w == cost)\n    return None\ndef dfs1(u, p, t):\n    if u == t:\n        return 0\n    for v, w in G0[u]:\n        if v == p:\n            continue\n        r = dfs1(v, u, t)\n        if r is not None:\n            return max(r, w)\n    return None\n\nif X - cost < 0:\n    print(0)\n    return\n\nK = 0\nfor i in range(M):\n    if U[i]:\n        K += 1\n        continue\n    w, u, v = E[i]\n    if dfs0(u, -1, v, w):\n        K += 1\n        U[i] = 1\nif cost == X:\n    ans = ((pow(2, K, MOD) - 2)*pow(2, M-K, MOD)) % MOD\n    print(ans)\n    return\n\nL = 0\nG = 0\nfor i in range(M):\n    w, u, v = E[i]\n    if last + (X - cost) < w:\n        break\n    G += 1\n    if U[i]:\n        continue\n    r = dfs1(u, -1, v) + (X - cost)\n    if r == w:\n        L += 1\n    elif r < w:\n        G -= 1\n\n#print(K, L, M, M-K-L, G)\nans = (2*(pow(2, L, MOD)-1)*pow(2, M-G, MOD)) % MOD\nprint(ans)", "import sys\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(mod)\ninput = sys.stdin.readline\n\ndef root(v):\n    if v == par[v]:\n        return v\n    par[v] = root(par[v])\n    return par[v]\n\ndef unite(u, v):\n    u = root(u)\n    v = root(v)\n    if u == v:\n        return\n    if rank[u] < rank[v]:\n        u, v = v, u\n    par[v] = u\n    if rank[u] == rank[v]:\n        rank[u] += 1\n\ndef same(u, v):\n    return root(u) == root(v)\n\ndef kruskal(edges):\n    tree = [[] for _ in range(N)]\n    used = [False] * M\n    weight = 0\n    for i, (w, u, v) in enumerate(edges):\n        if same(u, v):\n            continue\n        unite(u, v)\n        weight += w\n        tree[u].append((w, v))\n        tree[v].append((w, u))\n        used[i] = True\n    return weight, tree, used\n\ndef dfs(v=0, p=-1, d=0, w=0):\n    parent[0][v] = p\n    depth[v] = d\n    max_w[0][v] = w\n    for w, u in T[v]:\n        if u == p:\n            continue\n        dfs(u, v, d+1, w)\n\ndef lca(u, v):\n    if depth[u] > depth[v]:\n        u, v = v, u\n    tmp = 0\n    while depth[v] > depth[u]:\n        diff = depth[v] - depth[u]\n        k = diff.bit_length() - 1\n        tmp = max(tmp, max_w[k][v])\n        v = parent[k][v]\n    if u == v:\n        return tmp\n    for k in range(logN-1, -1, -1):\n        if parent[k][u] != parent[k][v]:\n            tmp = max(tmp, max_w[k][u], max_w[k][v])\n            u = parent[k][u]\n            v = parent[k][v]\n    return max(tmp, max_w[0][u], max_w[0][v])\n\ndef modpow(x, p):\n    if p == 0:\n        return 1\n    elif p == 1:\n        return x % mod\n    if p % 2 == 1:\n        return x * modpow(x, p-1) % mod\n    return modpow(x * x % mod, p // 2) % mod\n\nN, M = map(int, input().split())\nlogN = (N - 1).bit_length()\nX = int(input())\nE = [tuple()] * M\nfor i in range(M):\n    u, v, w = map(int, input().split())\n    E[i] = (w, u-1, v-1)\nE = sorted(E, key=lambda x: x[0])\npar = list(range(N))\nrank = [1] * N\nW, T, F = kruskal(E)\ndepth = [0] * N\nparent = [[0] * N for _ in range(logN+1)]\nmax_w = [[0] * N for _ in range(logN+1)]\ndfs()\nfor k in range(logN):\n    for v in range(N):\n        if parent[k][v] < 0:\n            parent[k+1][v] = -1\n            max_w[k+1][v] = max_w[k][v]\n        else:\n            parent[k+1][v] = parent[k][parent[k][v]]\n            max_w[k+1][v] = max(max_w[k][v], max_w[k][parent[k][v]])\n\nle = 0\neq = 0\nge = 0\nfor i, (w, u, v) in enumerate(E):\n    s = W\n    if not F[i]:\n        s += (w - lca(u, v))\n    if s < X:\n        le += 1\n    else:\n        if s == X:\n            eq += 1\n        else:\n            ge += 1\nans = 0\nif eq != 0:\n    if le == 0:\n        ans = (modpow(2, eq) - 2) * modpow(2, ge) % mod\n    else:\n        ans = 2 * (modpow(2, eq) - 1) * modpow(2, ge) % mod\nprint(ans)", "N, M = map(int, input().split())\nX = int(input())\nE = []\nC = {}\nfor i in range(M):\n    u, v, w = map(int, input().split())\n    E.append((w, u-1, v-1))\n    C[w] = C.get(w, 0) + 1\nE.sort()\n\n*p, = range(N)\ndef root(x):\n    if x == p[x]:\n        return x\n    y = p[x] = root(p[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n    return 1\n\nMOD = 10**9 + 7\n\nG0 = [[] for i in range(N)]\nK = 0\nlast = None\nU = [0]*M\ncost = 0\nfor i in range(M):\n    w, u, v = E[i]\n    if unite(u, v):\n        cost += w\n        U[i] = 1\n        if last != w:\n            K += C[w]\n        G0[u].append((v, w))\n        G0[v].append((u, w))\n        last = w\ndef dfs0(u, p, t, cost):\n    if u == t:\n        return 0\n    for v, w in G0[u]:\n        if v == p:\n            continue\n        r = dfs0(v, u, t, cost)\n        if r is not None:\n            return r | (w == cost)\n    return None\ndef dfs1(u, p, t):\n    if u == t:\n        return 0\n    for v, w in G0[u]:\n        if v == p:\n            continue\n        r = dfs1(v, u, t)\n        if r is not None:\n            return max(r, w)\n    return None\n\nif X - cost < 0:\n    print(0)\n    return\n\nK = 0\nfor i in range(M):\n    if U[i]:\n        K += 1\n        continue\n    w, u, v = E[i]\n    if dfs0(u, -1, v, w):\n        K += 1\n        U[i] = 1\nif cost == X:\n    ans = ((pow(2, K, MOD) - 2)*pow(2, M-K, MOD)) % MOD\n    print(ans)\n    return\n\nL = 0\nG = 0\nfor i in range(M):\n    w, u, v = E[i]\n    if last + (X - cost) < w:\n        break\n    G += 1\n    if U[i]:\n        continue\n    r = dfs1(u, -1, v) + (X - cost)\n    if r == w:\n        L += 1\n    elif r < w:\n        G -= 1\n\nans = (2*(pow(2, L, MOD)-1)*pow(2, M-G, MOD)) % MOD\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nMOD = 10 ** 9 + 7\n\nN,M = list(map(int,input().split()))\nX = int(input())\nUVW = [[int(x) for x in input().split()] for _ in range(M)]\nUVW.sort(key = lambda x: x[2])\n\nroot = list(range(N+1))\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return x\n    z = find_root(y)\n    root[x] = z\n    return z\n\n# min spanning tree\ntree = [set() for _ in range(N+1)]\nmin_tree_size = 0\nfor u,v,w in UVW:\n    ru = find_root(u)\n    rv = find_root(v)\n    if ru == rv:\n        continue\n    root[ru] = rv\n    min_tree_size += w\n    tree[u].add((v,w))\n    tree[v].add((u,w))\n\n# tree\u306b\u304a\u3051\u308b2\u9802\u70b9\u306e\u9593\u306e\u8fba\u306e\u6700\u5927\u5024\u3092\u6c42\u3081\u305f\u3044\n# LCA\u30022^n\u500b\u624b\u524d\u304a\u3088\u3073\u305d\u3053\u307e\u3067\u306e\u6700\u5927\u5024\u3092\u899a\u3048\u308b\n\nparent = [[0] * 12 for _ in range(N+1)]\nmax_wt = [[0] * 12 for _ in range(N+1)]\ndepth = [0] * (N+1)\n\ndef dfs(v=1,p=0,dep=0,w=0):\n    parent[v][0] = p\n    depth[v] = dep\n    max_wt[v][0] = w\n    for n in range(1,11):\n        parent[v][n] = parent[parent[v][n-1]][n-1]\n        max_wt[v][n] = max(max_wt[v][n-1], max_wt[parent[v][n-1]][n-1])\n    for u,w in tree[v]:\n        if u == p:\n            continue\n        dfs(u,v,dep+1,w)\n\ndfs()\n\ndef max_wt_between(x,y):\n    # LCA \u3057\u306a\u304c\u3089\u91cd\u307f\u306e\u6700\u5927\u5024\u3092\u5f97\u308b\n    wt = 0\n    dx,dy = depth[x], depth[y]\n    if dx > dy:\n        x,y = y,x\n        dx,dy = dy,dx\n    while dy > dx:\n        diff = dy - dx\n        step = diff & (-diff)\n        n = step.bit_length() - 1\n        wt = max(wt, max_wt[y][n])\n        y = parent[y][n]\n        dy -= step\n    if x == y:\n        return wt\n    step = 1 << 11\n    while step:\n        n = step.bit_length() - 1\n        rx,ry = parent[x][n], parent[y][n]\n        if rx != ry:\n            wt = max(wt, max_wt[x][n], max_wt[y][n])\n            x,y = rx,ry\n        step >>= 1\n    return max(wt, max_wt[x][0], max_wt[y][0])\n\n# \u5404edge\u306b\u5bfe\u3057\u3066\u3001\u305d\u306e\u8fba\u3092\u542b\u3080\u6700\u5c0f\u306e\u5168\u57df\u6728\u306e\u5927\u304d\u3055\u3092\u6c42\u3081\u308b\nmin_size = []\nfor u,v,w in UVW:\n    if (v,w) in tree[u]:\n        min_size.append(min_tree_size)\n    else:\n        x = max_wt_between(u,v)\n        min_size.append(min_tree_size + w - x)\n\nsm = sum(1 if s < X else 0 for s in min_size)\neq = sum(1 if s == X else 0 for s in min_size)\ngr = sum(1 if s > X else 0 for s in min_size)\n\nif eq == 0:\n    answer = 0\nelif sm == 0:\n    # eq \u5185\u306e\u8fba\u304c\u5b8c\u5168\u540c\u8272\u3067\u306a\u3051\u308c\u3070\u3088\u3044\n    answer = (pow(2,eq,MOD) - 2) * pow(2,gr,MOD) % MOD\nelse:\n    # sm \u5185\u304c\u5b8c\u5168\u540c\u8272\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3002\n    # eq \u5185\u306f\u3001sm\u306e\u8272\u3068\u7570\u306a\u308b\u8272\u3092\u6301\u3063\u3066\u3044\u308c\u3070\u4f55\u3067\u3082\u3088\u3044\n    answer = 2 * (pow(2,eq,MOD) - 1) * pow(2,gr,MOD) % MOD\n\nprint(answer)\n\n", "import sys\nfrom operator import itemgetter\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n\n    def _root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self._root(self.table[x])\n            return self.table[x]\n\n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\n\nclass LcaDoubling:\n    \"\"\"\n    links[v] = { (u, w), (u, w), ... }  (u:\u96a3\u63a5\u9802\u70b9, w:\u8fba\u306e\u91cd\u307f)\n    \u3068\u3044\u3046\u30b0\u30e9\u30d5\u60c5\u5831\u304b\u3089\u3001\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u308bLCA\u3092\u69cb\u7bc9\u3002\n    \u4efb\u610f\u306e2\u9802\u70b9\u306eLCA\u304a\u3088\u3073\u300c\u30d1\u30b9\u306b\u542b\u307e\u308c\u308b\u6700\u9577\u8fba\u306e\u9577\u3055\u300d\u3092\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\n    \"\"\"\n\n    def __init__(self, n, links, root=0):\n        self.depths = [-1] * n\n        self.max_paths = [[-1] * (n + 1)]\n        self.ancestors = [[-1] * (n + 1)]  # \u9802\u70b9\u6570\u3088\u308a1\u500b\u9577\u304f\u3057\u3001\u5b58\u5728\u3057\u306a\u3044\u3053\u3068\u3092-1\u3067\u8868\u3059\u3002\u672b\u5c3e(-1)\u8981\u7d20\u306f\u5e38\u306b-1\n        self._init_dfs(n, links, root)\n\n        prev_ancestors = self.ancestors[-1]\n        prev_max_paths = self.max_paths[-1]\n        max_depth = max(self.depths)\n        d = 1\n        while d < max_depth:\n            next_ancestors = [prev_ancestors[p] for p in prev_ancestors]\n            next_max_paths = [max(prev_max_paths[p], prev_max_paths[q]) for p, q in enumerate(prev_ancestors)]\n            self.ancestors.append(next_ancestors)\n            self.max_paths.append(next_max_paths)\n            d <<= 1\n            prev_ancestors = next_ancestors\n            prev_max_paths = next_max_paths\n\n    def _init_dfs(self, n, links, root):\n        q = [(root, -1, 0, 0)]\n        direct_ancestors = self.ancestors[0]\n        direct_max_paths = self.max_paths[0]\n        while q:\n            v, p, dep, max_path = q.pop()\n            direct_ancestors[v] = p\n            self.depths[v] = dep\n            direct_max_paths[v] = max_path\n            q.extend((u, v, dep + 1, w) for u, w in links[v] if u != p)\n        return direct_ancestors\n\n    def get_lca_with_max_path(self, u, v):\n        du, dv = self.depths[u], self.depths[v]\n        if du > dv:\n            u, v = v, u\n            du, dv = dv, du\n        tu = u\n        tv, max_path = self.upstream(v, dv - du)\n        if u == tv:\n            return u, max_path\n        for k in range(du.bit_length() - 1, -1, -1):\n            mu = self.ancestors[k][tu]\n            mv = self.ancestors[k][tv]\n            if mu != mv:\n                max_path = max(max_path, self.max_paths[k][tu], self.max_paths[k][tv])\n                tu = mu\n                tv = mv\n        lca = self.ancestors[0][tu]\n        assert lca == self.ancestors[0][tv]\n        max_path = max(max_path, self.max_paths[0][tu], self.max_paths[0][tv])\n        return lca, max_path\n\n    def upstream(self, v, k):\n        i = 0\n        mp = 0\n        while k:\n            if k & 1:\n                mp = max(mp, self.max_paths[i][v])\n                v = self.ancestors[i][v]\n            k >>= 1\n            i += 1\n        return v, mp\n\n\ndef construct_spanning_tree(n, uvw):\n    uft = UnionFind(n)\n    spanning_links = [set() for _ in range(n)]\n    not_spanning_links = []\n    adopted_count = 0\n    adopted_weight = 0\n    i = 0\n    while adopted_count < n - 1:\n        u, v, w = uvw[i]\n        if uft.find(u, v):\n            not_spanning_links.append(uvw[i])\n        else:\n            spanning_links[u].add((v, w))\n            spanning_links[v].add((u, w))\n            uft.union(u, v)\n            adopted_count += 1\n            adopted_weight += w\n        i += 1\n    not_spanning_links.extend(uvw[i:])\n    return adopted_weight, spanning_links, not_spanning_links\n\n\ndef solve(n, m, x, uvw):\n    # \u6700\u5c0f\u5168\u57df\u6728(MST)\u306e\u30b3\u30b9\u30c8\u7dcf\u548c\u304cX\u3068\u4e00\u81f4\u3059\u308b\u306a\u3089\u3001MST\u306b\u767d\u9ed2\u542b\u3081\u308c\u3070\u826f\u3044\uff08\u305f\u3060\u3057\u540c\u7387\u306e\u8fba\u306f\u8003\u616e\uff09\n    # \u305d\u3046\u3067\u306a\u3044\u306a\u3089\u3001MST\u4ee5\u5916\u306e\u8fba\u3092\u4f7f\u3048\u308b\u306e\u306f\u305b\u3044\u305c\u30441\u672c\u307e\u3067\u2192\u5404\u8fba\u306e\u53d6\u308a\u66ff\u3048\u30b3\u30b9\u30c8\u5897\u52a0\u5206\u3092\u898b\u308b\n    # MST\u4ee5\u5916\u306e\u8fba(u, v)\u3092\u63a1\u7528\u3059\u308b\u969b\u306b\u4ee3\u308f\u308a\u306b\u9664\u304b\u308c\u308b\u8fba\u306f\u3001MST\u4e0a\u3067{u, v}\u3092\u7d50\u3076\u30d1\u30b9\u306e\u6700\u5927\u30b3\u30b9\u30c8\u8fba\n\n    mst_weight, spanning_links, not_spanning_links = construct_spanning_tree(n, uvw)\n    # print(mst_weight)\n    # print(spanning_links)\n    # print(not_spanning_links)\n    if x < mst_weight:\n        return 0\n    diff = x - mst_weight\n    lcad = LcaDoubling(n, spanning_links)\n\n    lower_count, exact_count, upper_count = 0, 0, 0\n    for u, v, w in not_spanning_links:\n        lca, mp = lcad.get_lca_with_max_path(u, v)\n        inc = w - mp\n        # print(u, v, w, lca, mp, inc)\n        if inc < diff:\n            lower_count += 1\n        elif inc > diff:\n            upper_count += 1\n        else:\n            exact_count += 1\n\n    MOD = 10 ** 9 + 7\n    # x >= mst_weight \u306e\u5834\u5408\u3001MST\u306e\u8fba\u306f\u5168\u3066\u540c\u3058\u8272\u3068\u3057\u3066\n    # lower_count \u3082\u5168\u3066\u305d\u308c\u3068\u540c\u3058\u8272\n    # exact_count \u306f\u300c\u5168\u3066\u304cMST\u3068\u540c\u3058\u8272\u300d\u3067\u306a\u3044\u9650\u308a\u3069\u306e\u3088\u3046\u306a\u5857\u308a\u65b9\u3067\u3082\u3088\u3044\n    # upper_count \u306f\u3069\u306e\u3088\u3046\u306a\u5857\u308a\u65b9\u3067\u3082\u3088\u3044\n    replace_to_exact_link = 2 * (pow(2, exact_count, MOD) - 1) * pow(2, upper_count, MOD) % MOD\n    if diff > 0:\n        return replace_to_exact_link\n\n    # x == mst_weight \u306e\u5834\u5408\u306f\u3001MST\u304c\u5168\u3066\u540c\u3058\u8272\u3067\u306a\u3044\u9650\u308a\u3069\u306e\u3088\u3046\u306a\u5857\u308a\u65b9\u3067\u3082\u3088\u3044\u30d1\u30bf\u30fc\u30f3\u3082\u8ffd\u52a0\n    use_first_spanning = (pow(2, n - 1, MOD) - 2) * pow(2, m - n + 1, MOD) % MOD\n    return (use_first_spanning + replace_to_exact_link) % MOD\n\n\nn, m = list(map(int, input().split()))\nx = int(input())\nuvw = []\nfor line in sys.stdin:\n    u, v, w = list(map(int, line.split()))\n    u -= 1\n    v -= 1\n    uvw.append((u, v, w))\nuvw.sort(key=itemgetter(2))\nprint((solve(n, m, x, uvw)))\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) #\u89aa\u30ce\u30fc\u30c9\n        self.size = [1]*n #\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n \n    def root(self, x): #root(x): x\u306e\u6839\u30ce\u30fc\u30c9\u3092\u8fd4\u3059\uff0e\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x \n \n    def merge(self, x, y): #merge(x,y): x\u306e\u3044\u308b\u7d44\u3068y\u306e\u3044\u308b\u7d44\u3092\u307e\u3068\u3081\u308b\n        x, y = self.root(x), self.root(y)\n        if x == y: return False\n        if self.size[x] < self.size[y]: x,y=y,x #x\u306e\u8981\u7d20\u6570\u304c\u5927\u304d\u3044\u3088\u3046\u306b\n        self.size[x] += self.size[y] #x\u306e\u8981\u7d20\u6570\u3092\u66f4\u65b0\n        self.parent[y] = x #y\u3092x\u306b\u3064\u306a\u3050\n        return True\n \n    def issame(self, x, y): #same(x,y): x\u3068y\u304c\u540c\u3058\u7d44\u306a\u3089True\n        return self.root(x) == self.root(y)\n        \n    def getsize(self,x): #size(x): x\u306e\u3044\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u8fd4\u3059\n        return self.size[self.root(x)]\n\ndef largest(U,V):\n    order = []\n    st = [U]\n    parent = [-1]*n\n    wt = [0]*n\n    while st:\n        v = st.pop()\n        if v==V: break        \n        order.append(v)\n        for c,d in g[v]:\n            if c != parent[v]:\n                st.append(c)\n                parent[c] = v\n                wt[c] = d\n    res = 0\n    while V != U:\n        res = max(res,wt[V])\n        V = parent[V]\n    return res\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,m = list(map(int,readline().split()))\nx, = list(map(int,readline().split()))\nuvw = [list(map(int,readline().split())) for _ in range(m)]\n\nMOD = 10**9+7\np2 = [1]\nfor _ in range(3000):\n    p2.append(p2[-1]*2%MOD)\n\nres = []\nuvw.sort(key=lambda x:x[2])\nUF = UnionFind(n)\nwt = 0\n\ng = [[] for _ in range(n)]\nfor i in range(m):\n    u,v,w = uvw[i]\n    if UF.merge(u-1,v-1):\n        g[u-1].append((v-1,w))\n        g[v-1].append((u-1,w))\n        wt += w\n    else:\n        res.append(i)\n\nans = (p2[n-1]-2)*p2[m-n+1]%MOD if wt == x else 0\nfree = m-n\nres2 = []\nfor idx in res:\n    u,v,w = uvw[idx]\n    L = largest(u-1,v-1)\n    res2.append(wt+w-L)\n\nres2.sort()\nfree = m-n\nfor val in res2:\n    if val == x:\n        ans += 2*p2[free]\n    free -= 1\n\nprint((ans%MOD))\n\n\n\n", "import sys\ninput=sys.stdin.readline\n\ndef find_parent(x):\n    y=parent[x]\n    if y<0:\n        return x\n    parent[x]=find_parent(y)\n    return parent[x]\n\ndef connect(a,b):\n    c=find_parent(a)\n    d=find_parent(b)\n    if c==d:\n        return\n    if parent[c]<parent[d]:\n        parent[c]+=parent[d]\n        parent[d]=c\n    else:\n        parent[d]+=parent[c]\n        parent[c]=d\n    return\n\ndef f(S,G):\n    que=[S]\n    flag=[0]*(N+1)\n    L=[0]*(N+1)\n    flag[S]=1\n    while que:\n        H=[]\n        for u in que:\n            for v,l in data[u]:\n                if flag[v]==0:\n                    flag[v]=u\n                    L[v]=l\n                    H.append(v)\n                if v==G:\n                    break\n            else:\n                continue\n            break\n        else:\n            que=H\n            continue\n        break\n    qqq=0\n    que=G\n    while que!=S:\n        qqq=max(qqq,L[que])\n        que=flag[que]\n    return qqq\n\nN,M=map(int,input().split())\nX=int(input())\n\ninf=float(\"inf\")\nmod=10**9+7\n\nedge=[]\nfor i in range(M):\n    U,V,W=map(int,input().split())\n    edge.append([W,U,V])\nedge.sort()\nparent=[-1]*(N+1)\n\nremain_edge=[]\ndata=[[] for i in range(N+1)]\nweigh=0\n\nfor l,a,b in edge:\n    if find_parent(a)==find_parent(b):\n        remain_edge.append([l,a,b])\n        continue\n    else:\n        connect(a,b)\n        weigh+=l\n        data[a].append([b,l])\n        data[b].append([a,l])\n        \nif weigh>X:\n    print(0)\n    return\nelif weigh==X:\n    count=N-1\n    for l,a,b in remain_edge:\n        if l==f(a,b):\n            count+=1\n    print(pow(2,M-count,mod)*(pow(2,count,mod)-2)%mod)\nelse:\n    count_1=0\n    count_2=0\n    count_3=0\n    for l,a,b in remain_edge:\n        if weigh-f(a,b)+l==X:\n            count_1+=1\n        elif weigh-f(a,b)+l<X:\n            count_2+=1\n        else:\n            count_3+=1\n    print(2*pow(2,count_3,mod)*(pow(2,count_1,mod)-1)%mod)"]
["def dp():\n\tdparr = [0] * len(sections)\n\tfor i in range(len(sections) - 1, -1, -1):\n\t\t_, curend, curcomfort = sections[i]\n\t\tnextsection = i + 1\n\t\ttry:\n\t\t\twhile sections[nextsection][0] <= curend:\n\t\t\t\tnextsection += 1\n\t\texcept IndexError:\n\t\t\t# Loop til end\n\t\t\tinc = curcomfort\n\t\telse:\n\t\t\tinc = curcomfort + dparr[nextsection]\n\t\texc = 0 if i == len(sections) - 1 else dparr[i + 1]\n\t\tdparr[i] = max(inc, exc)\n\treturn dparr[0]\n\n\nn = int(input())\nzs = list(map(int, input().split()))\nsections = []\nseenstartz = set()\nfirst = {z: i for i, z in reversed(list(enumerate(zs)))}\nlast = {z: i for i, z in enumerate(zs)}\nfor start, z in enumerate(zs):\n\tif z in seenstartz:\n\t\tcontinue\n\tseenstartz.add(z)\n\tend = last[z]\n\tcomfort = 0\n\ti = start\n\twhile i <= end:\n\t\tif first[zs[i]] < start:\n\t\t\tbreak\n\t\tif i == last[zs[i]]:\n\t\t\tcomfort ^= zs[i]\n\t\tend = max(end, last[zs[i]])\n\t\ti += 1\n\telse:\n\t\tsections.append((start, end, comfort))\n\nans = dp()\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\n\ndp = [0]*(n + 1)\nf,l = {}, {}\nfor i in range(len(a)):\n    x = a[i]\n    if x not in f:\n        f[x] = i\n    l[x] = i\npr = [a[0]]\n\nfor i in range(1, len(a) + 1):\n    j = i\n    mx = 0\n    nums = set()\n    curxor = 0\n    b = i\n    while j > 0:\n        x = a[j-1]\n        if l[x] > i - 1:\n            break\n        if x not in nums:\n            nums.add(x)\n            curxor ^= x\n        b = min(b, f[x] + 1)\n        if b == j:\n            mx = max(mx, dp[j-1] + curxor)\n        j -= 1\n    dp[i] = max(dp[i-1], mx)\nprint(dp[len(a)])", "people = int(input())\ncities = list(map(int, input().split()))\nmaximum = max(cities)\nlast, first = [-1 for i in range(maximum + 1)], [float('inf') for i in range(maximum + 1)]\nfor i in range(people):\n    first[cities[i]] = min(i, first[cities[i]])\n    last[cities[i]] = max(i, last[cities[i]])\ndp = [0 for i in range(people)]\ndp[0] = cities[0] if last[cities[0]] == 0 else 0\nfor i in range(1, people):\n    min_first = float('inf')\n    max_last = -1\n    used = set()\n    xor = 0\n    for j in range(i, -1, -1):\n        min_first = min(min_first, first[cities[j]])\n        max_last = max(max_last, last[cities[j]])\n        if cities[j] not in used:\n            xor ^= cities[j]\n        used.add(cities[j])\n        if min_first >= j and max_last <= i:\n            if j != 0:\n                dp[i] = max(dp[i], dp[j - 1] + xor)\n            else:\n                dp[i] = max(dp[i], xor)\n    dp[i] = max(dp[i], dp[i - 1])\nprint(dp[-1])", "import sys\n\ninf = 1<<30\n\ndef solve():\n    n = int(input())\n    a = [0] + [int(i) for i in input().split()]\n\n    maxi = max(a)\n    f = [-1] * (maxi + 1)\n    for i in range(1, n + 1):\n        if f[a[i]] == -1:\n            f[a[i]] = i\n\n    l = [-1] * (maxi + 1)\n    for i in range(n, 0, -1):\n        if l[a[i]] == -1:\n            l[a[i]] = i\n\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n\n        if i == l[a[i]]:\n            min_l = f[a[i]]\n            max_r = i\n            used = set()\n            v = 0\n\n            for j in range(i, -1, -1):\n                min_l = min(min_l, f[a[j]])\n                max_r = max(max_r, l[a[j]])\n\n                if a[j] not in used:\n                    v ^= a[j]\n                    used.add(a[j])\n\n                if max_r > i:\n                    break\n                if j == min_l:\n                    dp[i] = max(dp[i], dp[j - 1] + v)\n                    break\n\n    # print(dp)\n    ans = dp[n]\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "#!/usr/bin/pypy3\n\nimport cProfile\nfrom sys import stdin,stderr\nfrom heapq import heappush,heappop\nfrom random import randrange\n\ndef readInts(): return map(int,stdin.readline().strip().split())\ndef print_err(*args,**kwargs): print(*args,file=stderr,**kwargs)\n\ndef create_heap(ns):\n    mins = {}\n    maxs = {}\n    for i,v in enumerate(ns):\n        if v not in mins: mins[v] = i\n        maxs[v] = i\n    ranges = {}\n    rheap = []\n    for v,minix in mins.items():\n        maxix = maxs[v]\n        ranges[v] = (minix,maxix)\n        heappush(rheap,(maxix-minix+1,minix))        \n    return (ranges,rheap)\n\ndef create_heap2(ns):\n    mins = {}\n    maxs = {}\n    for i,v in enumerate(ns):\n        if v not in mins: mins[v] = i\n        maxs[v] = i\n    ranges = {}\n    rheap = []\n    for v,minix in mins.items():\n        maxix = maxs[v]\n        ranges[v] = (minix,maxix)\n        heappush(rheap,(maxix-minix+1,minix,set([v])))        \n    return (ranges,rheap)\n\ndef solve(n,ns):\n    ranges,pq = create_heap(ns)\n    resolved_ranges = {}\n    while pq:\n        w,lo_ix = heappop(pq)\n        #print(len(pq),w,lo_ix)\n        if lo_ix in resolved_ranges:\n            #print(len(pq))\n            continue\n        tot_subs = 0\n        tot_x = 0\n        ix = lo_ix\n        fail = False\n        xsv = set()\n        while ix < lo_ix+w:\n            v = ns[ix]\n            lo2,hi2 = ranges[v]\n            if lo2 < lo_ix or hi2 > lo_ix+w-1:\n                lo2 = min(lo2,lo_ix)\n                hi2 = max(hi2,lo_ix+w-1)\n                heappush(pq, (hi2-lo2+1,lo2) )\n                fail = True\n                break\n            if ix in resolved_ranges:\n                rhi_ix,c,x = resolved_ranges[ix]\n                tot_x ^= x\n                tot_subs += c\n                ix = rhi_ix + 1\n                continue\n            if v not in xsv:\n                xsv.add(v)\n                tot_x ^= v\n            ix += 1\n        if not fail:\n            resolved_ranges[lo_ix] = (lo_ix+w-1,max(tot_x,tot_subs),tot_x)\n    ix = 0\n    tot_c = 0\n    while ix < n:\n        rhi,c,_ = resolved_ranges[ix]\n        ix = rhi+1\n        tot_c += c\n    return tot_c\n\n\ndef solve2(n,ns):\n    ranges,pq = create_heap(ns)\n    resolved_ranges = {}\n    while pq:\n        w,lo_ix,xs = heappop(pq)\n        print(len(pq),w,lo_ix,xs)\n        if lo_ix in resolved_ranges:\n            print(len(pq))\n            continue\n        tot_subs = 0\n        tot_x = 0\n        for x in xs: tot_x ^= x\n        ix = lo_ix\n        fail = False\n        while ix < lo_ix+w:\n            v = ns[ix]\n            if v in xs:\n                ix += 1\n                continue\n            if ix in resolved_ranges:\n                rhi_ix,c,x = resolved_ranges[ix]\n                tot_x ^= x\n                tot_subs += c\n                ix = rhi_ix + 1\n                continue\n            lo2,hi2 = ranges[v]\n            lo2 = min(lo2,lo_ix)\n            hi2 = max(hi2,lo_ix+w-1)\n            xs.add(v)\n            heappush(pq, (hi2-lo2+1,lo2,xs) )\n            fail = True\n            break\n        if not fail:\n            resolved_ranges[lo_ix] = (lo_ix+w-1,max(tot_x,tot_subs),tot_x)\n    ix = 0\n    tot_c = 0\n    while ix < n:\n        rhi,c,_ = resolved_ranges[ix]\n        ix = rhi+1\n        tot_c += c\n    return tot_c\n\ndef test():\n    n = 5000\n    ns = []\n    for _ in range(n):\n        ns.append(randrange(1,n//2))\n    print(solve(n,ns))\n    \ndef run():\n    n, = readInts()\n    ns = list(readInts())\n    print(solve(n,ns))\n        \nrun()\n", "n = int(input())\na = [int(i) for i in input().split()]\n\n#a_set = set(a)\nprefix = dict()\nsuffix = dict()\nfor i in range(n):\n    if a[i] not in prefix:\n        prefix[a[i]] = i\n    suffix[a[i]] = i\ndp = [ 0 for i in range(n+1)]\nfor i in range(n):\n    dp[i] = dp[i-1]\n    if suffix[a[i]] != i:\n        continue\n    cur = 0\n    min_ind = prefix[a[i]]\n    for j in range(i, -1, -1):\n        if suffix[a[j]] <= i:\n            if suffix[a[j]] == j:\n                cur = cur ^ a[j]\n            min_ind = min(min_ind, prefix[a[j]])\n            if j == min_ind:\n                dp[i] = max(dp[i], dp[j-1] + cur)\n        else:\n            break\nprint(dp[n-1])", "n = int(input())\na = list(map(int, input().split()))\nR, L = {}, {}\nfor i in range(n):\n    if a[i] not in L:\n        L[a[i]] = i\n    R[a[i]] = i\n\ndp = [0] * (n + 1)\nfor i in range(n):\n    dp[i] = dp[i - 1]\n    if R[a[i]] != i:\n        continue\n    s = 0\n    l = L[a[i]]\n    for j in range(i, -1, -1):\n        if R[a[j]] <= i:\n            if R[a[j]] == j:\n                s ^= a[j]\n            l = min(l, L[a[j]])\n            if j == l:\n                dp[i] = max(dp[i], dp[j - 1] + s)\n        else:\n            break\n\nprint(dp[n - 1])", "from collections import Counter, defaultdict\n\nR = lambda: map(int, input().split())\nn = int(input())\narr = list(R())\ncnts = Counter(arr)\ndp = [0] * (n + 1)\nfor i in range(n):\n    acc = defaultdict(int)\n    cnt, xor = 0, 0\n    dp[i] = dp[i - 1]\n    for j in range(i, -1, -1):\n        acc[arr[j]] += 1\n        if acc[arr[j]] == cnts[arr[j]]:\n            cnt += 1\n            xor = xor ^ arr[j]\n        if len(acc) == cnt:\n            dp[i] = max(dp[i], dp[j - 1] + xor)\nprint(dp[n - 1])", "\"\"\"\nfrom\nhttp://codeforces.com/contest/811/problem/C\n\"\"\"\nlength = int(input())\narray = [0] + [int(x) for x in input().split()]\ndp = [0]*(length+1)\nend = [0]*5001\nstart = [5001]*5001\nvis = [0]*5001\n\nfor i in range(1,length+1):\n    start[array[i]] = min(start[array[i]],i)\n    end[array[i]] = max(end[array[i]],i)\n\nfor i in range(1, length + 1):\n    dp[i] = dp[i-1]\n    chk = [0] * 5001\n    ll = i\n    cur = 0\n    for j in range(i,0,-1):\n        ll = min(ll,start[array[j]])\n        if end[array[j]] > i:break\n        if chk[array[j]] == 0:\n            cur = array[j] ^ cur\n            chk[array[j]] = 1\n        if ll == j:\n            dp[i] = max(dp[i],dp[j-1]+cur)\nprint(dp[length])", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nn=int(input())\na=input()\nb=list(map(int,a.strip().split()))\nL={}\nR={}\nvis={}\ndp=[]\nfor i in range(n):\n    if L.get(b[i])==None:\n        L[b[i]]=i\n    R[b[i]]=i\n    dp.append(0)\ndp.append(0)\nfor i in range(n):\n    vis.clear()\n    if i>0:\n        dp[i]=dp[i-1]\n    ans=0\n    Min=i\n    j=i\n    while j>=0:\n        t=b[j]\n        if vis.get(t)==None:\n            if R[t]>i:\n                break\n            Min=min(Min,L[t])\n            ans^=t\n            vis[t]=1\n        if j<=Min:\n            dp[i]=max(dp[i],dp[j-1]+ans)\n        j-=1\nprint(dp[n-1])\n\n\n"]
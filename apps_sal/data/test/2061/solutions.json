["import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**10\nmod = 10**9 + 7\n\ndef f():\n    n,m,k = list(map(int, input().split()))\n    a = [[inf]*(m+2)]\n    g = []\n    for _ in range(n):\n        a.append([inf] + [_ for _ in input()] + [inf])\n        g.append([False]*m)\n    a.append([[inf]*(m+2)])\n\n    c = 0\n    for i in range(1,n+1):\n        if a[i][1] == '.':\n            a[i][1] = -1\n        if a[i][-2] == '.':\n            a[i][-2] = -1\n    for j in range(1,m+1):\n        if a[1][j] == '.':\n            a[1][j] = -1\n        if a[-2][j] == '.':\n            a[-2][j] = -1\n\n    def ff(n1,n2):\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if a[i][j] == n1:\n                    a[i][j] = n2\n    ff('*', inf)\n\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if a[i][j] == '.':\n                mc = [inf]\n                if a[i-1][j] != '.': mc.append(a[i-1][j])\n                if a[i+1][j] != '.': mc.append(a[i+1][j])\n                if a[i][j+1] != '.': mc.append(a[i][j+1])\n                if a[i][j-1] != '.': mc.append(a[i][j-1])\n                mm = min(mc)\n                if mm < inf:\n                    a[i][j] = mm\n                    for t in [_ for _ in mc if _ < inf and _ != mm]:\n                        ff(t,mm)\n                else:\n                    a[i][j] = c\n                    c += 1\n    cnt = [0] * c\n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            if -1 < a[i][j] < c:\n                cnt[a[i][j]] += 1\n    cnt2 = [_ for _ in cnt if _ > 0]\n    r = 0\n    for _i in range(len(cnt2) - k):\n        cnt2 = [_ for _ in cnt if _ > 0]\n        mm = min(cnt2)\n        ind = cnt.index(mm)\n        cnt[ind] = 0\n        r += mm\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if a[i][j] == ind:\n                    a[i][j] = '*'\n\n    print(r)\n\n    for i in range(1,n+1):\n        s = ''\n        for j in range(1,m+1):\n            c = a[i][j]\n            if c == '*':\n                s += c\n            elif c == inf:\n                s += '*'\n            else:\n                s += '.'\n        print(s)\n\nf()\n", "#!/usr/bin/env python3\n\nfrom collections import deque\n\n\ndef main():\n    DELTAS = (\n        (-1, 0),\n        (0, 1),\n        (1, 0),\n        (0, -1),\n    )\n\n    try:\n        while True:\n            n, m, k = list(map(int, input().split()))\n            grid = [list(input()) for i in range(n)]\n            lakes = [ ]\n            q = deque()\n            for i in range(n):\n                for j in (0, m - 1):\n                    if grid[i][j] == '.':\n                        grid[i][j] = '?'\n                        q.append((i, j))\n                        while q:\n                            y, x = q[0]\n                            q.popleft()\n                            for dy, dx in DELTAS:\n                                ny = y + dy\n                                nx = x + dx\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\n                                    grid[ny][nx] = '?'\n                                    q.append((ny, nx))\n            for i in (0, n - 1):\n                for j in range(m):\n                    if grid[i][j] == '.':\n                        grid[i][j] = '?'\n                        q.append((i, j))\n                        while q:\n                            y, x = q[0]\n                            q.popleft()\n                            for dy, dx in DELTAS:\n                                ny = y + dy\n                                nx = x + dx\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\n                                    grid[ny][nx] = '?'\n                                    q.append((ny, nx))\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == '.':\n                        grid[i][j] = '?'\n                        q.append((i, j))\n                        area = 1\n                        while q:\n                            y, x = q[0]\n                            q.popleft()\n                            for dy, dx in DELTAS:\n                                ny = y + dy\n                                nx = x + dx\n                                if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '.':\n                                    grid[ny][nx] = '?'\n                                    q.append((ny, nx))\n                                    area += 1\n\n                        lakes.append((area, i, j))\n\n            lakes.sort(reverse=True)\n            print(sum(x[0] for x in lakes[k:]))\n            for _, i, j in lakes[k:]:\n                grid[i][j] = '*'\n                q.append((i, j))\n                while q:\n                    y, x = q[0]\n                    q.popleft()\n                    for dy, dx in DELTAS:\n                        ny = y + dy\n                        nx = x + dx\n                        if 0 <= ny < n and 0 <= nx < m and grid[ny][nx] == '?':\n                            grid[ny][nx] = '*'\n                            q.append((ny, nx))\n\n            print('\\n'.join(\"\".join(ls).replace('?', '.') for ls in grid))\n\n    except EOFError:\n        pass\n\n\nmain()\n", "from pprint import pprint\nimport itertools\nimport collections\n\nn,m,k = [int(s) for s in input().split()]\n\ng = [[0]*m for _ in range(n)]\n\nfor i in range(n):\n    r = input()\n    for (j,c) in enumerate(r):\n        if c == '.':\n            g[i][j] = 1\n\nsidecomps = set()\ncurlab = 1\nlabels = [[0]*m for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if g[i][j] != 1 or labels[i][j] > 0:\n            continue\n        #print(i,j)\n        labels[i][j] = curlab\n        stack = [(i,j)]\n        if i == 0 or j == 0 or i == n-1 or j == m-1:\n            sidecomps.add(curlab)\n\n        while stack:\n            (i1, j1) = stack.pop()\n            #print(i1,j1)\n            for (i2,j2) in [(i1-1,j1),(i1+1,j1),(i1,j1-1),(i1,j1+1)]:\n                if (0 <= i2 and i2 < n and 0 <= j2 and j2 < m\\\n                        and g[i2][j2] == 1 and labels[i2][j2] == 0):\n                    labels[i2][j2] = curlab\n                    stack.append((i2,j2))\n                    if i2 == 0 or j2 == 0 or i2 == n-1 or j2 == m-1:\n                        sidecomps.add(curlab)\n        curlab += 1\n\nlakes = collections.defaultdict(list)\nfor i,j in itertools.product(list(range(n)), list(range(m))):\n    lab = labels[i][j]\n    if lab > 0 and lab not in sidecomps:\n        lakes[lab].append((i,j))\n#pprint(dict(lakes))\n\nlakesizes = sorted((len(lakes[lab]),lab) for lab in lakes)\nnum_remove = len(lakesizes)-k\nans = 0\nfor _,lab in lakesizes[:num_remove]:\n    for (i,j) in lakes[lab]:\n        g[i][j] = 0\n        ans += 1\n\nprint(ans)\nfor i in range(n):\n    print(''.join('.' if g[i][j] else '*' for j in range(m)))\n", "def ex(i, j, n, m):\n\tif i < n and i >= 0 and j < m and j >= 0:\n\t\treturn True\n\telse:\n\t\treturn False\nn, m, k = map(int, input().split())\nA = []\nfor i in range(n):\n\tA.append(list(input()))\nB = [[False for i in range(m)] for j in range(n)]\nL = []\nfor i in range(n):\n\tfor j in range(m):\n\t\tif not B[i][j] and A[i][j] == '.':\n\t\t\tsides = False\n\t\t\tOz = [[i, j]]\n\t\t\tcount = 1\n\t\t\tQ = [[i, j]]\n\t\t\tB[i][j] = True\n\t\t\twhile len(Q) > 0:\n\t\t\t\tx, y = Q[0][0], Q[0][1]\n\t\t\t\tif x == 0 or x == n - 1 or y == 0 or y == m - 1:\n\t\t\t\t\tsides = True\n\t\t\t\tif  ex(x - 1, y, n, m) and not B[x - 1][y] and A[x - 1][y] == '.':\n\t\t\t\t\tQ.append([x - 1, y])\n\t\t\t\t\tB[x - 1][y] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tOz.append([x - 1, y])\n\t\t\t\tif  ex(x + 1, y, n, m) and not B[x + 1][y] and A[x + 1][y] == '.':\n\t\t\t\t\tQ.append([x + 1, y])\n\t\t\t\t\tB[x + 1][y] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tOz.append([x + 1, y])\n\t\t\t\tif  ex(x, y - 1, n , m) and not B[x][y - 1] and A[x][y - 1] == '.':\n\t\t\t\t\tQ.append([x, y - 1])\n\t\t\t\t\tB[x][y - 1] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tOz.append([x, y - 1])\n\t\t\t\tif  ex(x, y + 1, n, m) and not B[x][y + 1] and A[x][y + 1] == '.':\n\t\t\t\t\tQ.append([x, y + 1])\n\t\t\t\t\tB[x][y + 1] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tOz.append([x, y + 1])\n\t\t\t\tQ.pop(0)\n\t\t\tif not sides:\n\t\t\t\tL.append([count, Oz])\nL.sort()\ns = len(L)\nans = 0\nfor i in range(s - k):\n\tans += L[i][0]\n\tfor j in L[i][1]:\n\t\tA[j[0]][j[1]] = '*'\nprint(ans)\nfor i in range(n):\n\tfor j in range(m):\n\t\tprint(A[i][j], end='')\n\tprint()\n", "#!/usr/bin/env python3\n\nfrom collections import Counter, defaultdict\n\nn, m, k = [int(x) for x in input().split()]\n\nmp = [[\".\"]*(m+2)] + [list(\".\" + input().strip() + \".\") for _ in range(n)] + [[\".\"]*(m+2)]\nuf = {}\nfor i in range(n+2):\n  for j in range(m+2):\n    uf[(i, j)] = (i, j)\n\ndef find(u):\n  if u != uf[u]:\n    uf[u] = find(uf[u])\n  return uf[u]\n\ndef union(u, v):\n  pu = find(u)\n  pv = find(v)\n  if pu != pv:\n    uf[pv] = pu\n\nfor i in range(n+2):\n  for j in range(m+2):\n    if mp[i][j] == '*':\n      continue\n    if i <= n and mp[i+1][j] == '.':\n      union((i, j), (i+1, j))\n    if j <= m and mp[i][j+1] == '.':\n      union((i, j), (i, j+1))\n\nd = defaultdict(int)\nf0 = find((0, 0))\nfor i in range(n+2):\n  for j in range(m+2):\n    if mp[i][j] == '*':\n      continue\n    f = find((i, j))\n    if f != f0:\n      d[f] += 1\nl = sorted([(v, k) for k, v in list(d.items())])\nll = len(l)\nps = set([u for _, u in l[:ll-k]])\nr = 0\nfor i in range(1, n+1):\n  for j in range(1, m+1):\n    if mp[i][j] == '.' and find((i, j)) in ps:\n      mp[i][j] = '*'\n      r += 1\n\nprint(r)\nprint((\"\\n\".join(\n  \"\".join(m[1:-1])\n  for m in mp[1:-1]\n)))\n", "import sys, math\ndef bfs(a):\n    Q = [a]\n    ctr = 0\n    used = [[0] * m for i in range(n)]\n    while ctr < len(Q):\n        h = Q[ctr]\n        ctr += 1\n        z[h[0]][h[1]] = 'o'\n        if h[0] - 1 >= 0 and z[h[0] - 1][h[1]] == '.' and not used[h[0] - 1][h[1]]:\n            Q.append([h[0] - 1, h[1]])\n            used[h[0] - 1][h[1]] = 1\n        if h[0] + 1 < n and z[h[0] + 1][h[1]] == '.' and not used[h[0] + 1][h[1]]:\n            Q.append([h[0] + 1, h[1]])\n            used[h[0] + 1][h[1]] = 1\n        if h[1] - 1 >= 0 and z[h[0]][h[1] - 1] == '.' and not used[h[0]][h[1] - 1]:\n            Q.append([h[0], h[1] - 1])\n            used[h[0]][h[1] - 1] = 1\n        if h[1] + 1 < m and z[h[0]][h[1] + 1] == '.' and not used[h[0]][h[1] + 1]:\n            Q.append([h[0], h[1] + 1])\n            used[h[0]][h[1] + 1] = 1\n\ndef bfs1(a, b):\n    Q = [a]\n    ctr = 0\n    while ctr < len(Q):\n        h = Q[ctr]\n        ctr += 1\n        if z[h[0]][h[1]] == b:\n            continue\n        z[h[0]][h[1]] = b\n        if h[0] - 1 >= 0 and z[h[0] - 1][h[1]] == '.':\n            Q.append([h[0] - 1, h[1]])\n        if h[0] + 1 < n and z[h[0] + 1][h[1]] == '.':\n            Q.append([h[0] + 1, h[1]])\n        if h[1] - 1 >= 0 and z[h[0]][h[1] - 1] == '.':\n            Q.append([h[0], h[1] - 1])\n        if h[1] + 1 < m and z[h[0]][h[1] + 1] == '.':\n            Q.append([h[0], h[1] + 1])\n    ctr = 0\n    for i in range(n):\n        for j in range(m):\n            if z[i][j] == b:\n                ctr += 1\n    return ctr\n        \nn, m, k = map(int, input().split())\nz = [list(input()) for i in range(n)]\nfor i in range(n):\n    if z[i][0] == '.':\n        bfs([i, 0])\n    if z[i][m - 1] == '.':\n        bfs([i, m - 1])\nfor i in range(m):\n    if z[0][i] == '.':\n        bfs([0, i])\n    if z[n - 1][i] == '.':\n        bfs([n - 1, i])\nctr = 0\nz1 = []\nfor i in range(n):\n    for j in range(m):\n        if z[i][j] == '.':\n            z1.append([bfs1([i, j], ctr), ctr])\n            ctr += 1\nz1.sort()\ndif = ctr - k\nans = 0\nfor i in range(dif):\n    u = z1[i][1]\n    ans += z1[i][0]\n    for j in range(n):\n        for k in range(m):\n            if z[j][k] == u:\n                z[j][k] = '*'\nfor i in range(n):\n    for j in range(m):\n        if z[i][j] != '*' and z[i][j] != '.':\n            z[i][j] = '.'\nprint(ans)\nfor i in range(n):\n    print(*z[i], sep = '')\n    \n            \n            \n\n\n\n", "import sys\nimport copy\nsys.setrecursionlimit(10000000)\n\nh, w, k = list(map(int,input().split()))\nground = [list(input()) for j in range(h)]\nground2 = copy.deepcopy(ground)\n\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\ncnt = 0\n\ndef dfs(x,y,count):\n    ground[y][x] = str(count)\n    #print(y,x)\n    for k in range(4):\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\n            if ground[y+dy[k]][x+dx[k]] == \".\":\n                dfs(x+dx[k], y+dy[k], count)\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \".\":\n            dfs(i, j, cnt)\n            cnt += 1\n\narr = [[0, i] for i in range(cnt)]\n\nfor num in range(cnt):\n    f = True\n    for j in range(h):\n        for i in range(w):\n            #print(num,j,i,ground[j][i])\n            if ground[j][i] == str(num):\n                arr[num][0] += 1\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\n                    f = False\n                    arr[num][0] += 10**10\n                    break\n                    #print(num,j,i)\n            if not f:\n                break\n        if not f:\n            break\n\narr.sort()\n\nfor j in range(len(arr)):\n    if arr[j][0] > 10**10:\n        cnt -= 1\n\nnum_lake = cnt\nans = 0\n\"\"\"\nprint(cnt,arr)\nprint(k)\n\"\"\"\nif cnt == k:\n    print(ans)\n    for j in range(h):\n        print(\"\".join(ground2[j][:]))\n    return\n\nfor num in range(cnt):\n    groundbef = ground[:][:]\n    f = True\n    cells = 0\n    for j in range(h):\n        for i in range(w):\n            if ground[j][i] == str(arr[num][1]):\n                if i < 0 or i > w - 1 or j < 0 or j > h - 1:\n                    f = False\n                    print(\"F\", i,j)\n                    break\n                ground[j][i] = \"*\"\n                cells += 1\n\n    if not f:\n        ground = groundbef[:][:]\n        num_lake -= 1\n\n    else:\n        num_lake -= 1\n        ans += cells\n\n    if num_lake == k :\n        break\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \"*\":\n            continue\n        else:\n            ground[j][i] = \".\"\n\nprint(ans)\nfor j in range(h):\n    print(\"\".join(ground[j][:]))\n\n\n\n\"\"\"\nimport sys\nsys.setrecursionlimit(10000000)\n\nh, w, k = map(int,input().split())\nground = [list(input()) for j in range(h)]\n\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\ncnt = 0\n\ndef dfs(x,y,count):\n    ground[y][x] = str(count)\n    #print(y,x)\n    for k in range(4):\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\n            if ground[y+dy[k]][x+dx[k]] == \".\":\n                dfs(x+dx[k], y+dy[k], count)\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \".\":\n            #print(cnt, i, j)\n            dfs(i, j, cnt)\n            cnt += 1\n\narr = [[0, i] for i in range(cnt)]\nfor num in range(cnt):\n    for j in range(h):\n        for i in range(w):\n            if ground[j][i] == str(num):\n                arr[num][0] += 1\n\nnum_lake = cnt\narr.sort()\nans = 0\n\nfor num in range(cnt):\n    groundbef = ground[:][:]\n    f = True\n    cells = 0\n    for j in range(h):\n        for i in range(w):\n            if ground[j][i] == str(arr[num][1]):\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\n                    f = False\n                    break\n                ground[j][i] = \"*\"\n                cells += 1\n\n            if not f:\n                break\n\n        if not f:\n            break\n\n    if not f:\n        ground = groundbef[:][:]\n        num_lake -= 1\n\n    else:\n        num_lake -= 1\n        ans += cells\n\n    if num_lake == k + 1:\n        break\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \"*\":\n            continue\n        else:\n            ground[j][i] = \".\"\n\nprint(ans)\nfor j in range(h):\n    print(\"\".join(ground[j][:]))\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\n#c\nn, m = map(int,input().split())\na = list(map(int,input().split()))\n\n\"\"\"\n\n\n\"\"\"\nl = int(input())\ns = input()\n\nleft = 0\nans = [0] * 2\ncurrent = \"\"\n\nfor i in range(l):\n    if s[i] == \"_\":\n        if current != \"\":\n            if left == 0:\n                ans[0] = max(ans[0], len(current))\n            else:\n                ans[1] += 1\n                #print(1, current)\n\n        current = \"\"\n        continue\n\n    if s[i] == \"(\":\n        ans[0] = max(ans[0], len(current))\n        left += 1\n        current = \"\"\n\n    elif s[i] == \")\":\n        if current != \"\":\n            ans[1] += 1\n            #print(1, current)\n        left = 0\n        current = \"\"\n    else:\n        current += s[i]\n    #print(current)\n\nif current != \"\":\n    ans[0] = max(ans[0], len(current))\n\nprint(ans[0], ans[1])\n\"\"\"\n\n\n\"\"\"\nx = list(map(int,input().split()))\nans = 10 ** 10\nfor i in range(1, 101):\n    dis = 0\n    for j in range(3):\n        dis += abs(x[j] - i)\n    ans = min(ans, dis)\nprint(ans)\n\"\"\"\n", "import sys\nimport copy\nsys.setrecursionlimit(10000000)\n\nh, w, k = list(map(int,input().split()))\nground = [list(input()) for j in range(h)]\nground2 = copy.deepcopy(ground)\n\ndx = [1,0,-1,0]\ndy = [0,1,0,-1]\ncnt = 0\n\ndef dfs(x,y,count):\n    ground[y][x] = str(count)\n    #print(y,x)\n    for k in range(4):\n        if 0 <= x + dx[k] < w and 0 <= y + dy[k] < h:\n            if ground[y+dy[k]][x+dx[k]] == \".\":\n                dfs(x+dx[k], y+dy[k], count)\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \".\":\n            dfs(i, j, cnt)\n            cnt += 1\n\narr = [[0, i] for i in range(cnt)]\n\nfor num in range(cnt):\n    f = True\n    for j in range(h):\n        for i in range(w):\n            #print(num,j,i,ground[j][i])\n            if ground[j][i] == str(num):\n                arr[num][0] += 1\n                if i == 0 or i == w - 1 or j == 0 or j == h - 1:\n                    f = False\n                    arr[num][0] += 10**10\n                    break\n                    #print(num,j,i)\n            if not f:\n                break\n        if not f:\n            break\n\narr.sort()\n\nfor j in range(len(arr)):\n    if arr[j][0] > 10**10:\n        cnt -= 1\n\nnum_lake = cnt\nans = 0\n\"\"\"\nprint(cnt,arr)\nprint(k)\n\"\"\"\nif cnt == k:\n    print(ans)\n    for j in range(h):\n        print(\"\".join(ground2[j][:]))\n    return\n\nfor num in range(cnt):\n    groundbef = ground[:][:]\n    f = True\n    cells = 0\n    for j in range(h):\n        for i in range(w):\n            if ground[j][i] == str(arr[num][1]):\n                if i < 0 or i > w - 1 or j < 0 or j > h - 1:\n                    f = False\n                    print(\"F\", i,j)\n                    break\n                ground[j][i] = \"*\"\n                cells += 1\n\n    if not f:\n        ground = groundbef[:][:]\n        num_lake -= 1\n\n    else:\n        num_lake -= 1\n        ans += cells\n\n    if num_lake == k :\n        break\n\nfor j in range(h):\n    for i in range(w):\n        if ground[j][i] == \"*\":\n            continue\n        else:\n            ground[j][i] = \".\"\n\nprint(ans)\nfor j in range(h):\n    print(\"\".join(ground[j][:]))\n", "import sys\nsys.setrecursionlimit(100000)\n\ndef find(x,y,tag):\n    if mplake[x][y] == tag or mp[x][y] == \"*\":\n        return\n    mplake[x][y] = tag\n    lakes[tag] += 1\n    for i in [(1,0),(-1,0),(0,1),(0,-1)]:\n        if 0 <= x+i[0] and x+i[0] < n and 0 <= y + i[1] and y+i[1] < m:\n            find(x+i[0],y+i[1],tag)\n\ndef fill(x,y,tag):\n    nonlocal cnt\n    if mplake[x][y] == tag:\n        mplake[x][y] = -1\n        mp[x][y] = \"*\"\n        cnt += 1\n        for i in [(1,0),(-1,0),(0,1),(0,-1)]:\n            if 0 <= x+i[0] and x+i[0] < n and 0 <= y + i[1] and y+i[1] < m:\n                fill(x+i[0],y+i[1],tag)\n\nn, m, k = [int(i) for i in input().split()]\nmp = []\nmplake = []\nfor i in range(n):\n    mp.append(list(input()))\n    mplake.append([-1 for i in range(m)])\n\nstart = [(0,0)]\nlakes = [0]\ncnt = 0\n\nfor i in range(n):\n    find(i,0,0)\n    find(i,m-1,0)\nfor i in range(m):\n    find(0,i,0)\n    find(n-1,i,0)\n\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if mp[i][j] == \".\" and mplake[i][j] == -1:\n            start.append((i,j))\n            lakes.append(0)\n            find(i,j,len(lakes)-1)\n\nr = sorted([(lakes[i],start[i]) for i in range(1,len(lakes))])\n\nfor i in range(len(r)-k):\n    fill(r[i][1][0],r[i][1][1],mplake[r[i][1][0]][r[i][1][1]])\n\nprint(cnt)\nfor i in range(n):\n    print(\"\".join(mp[i]))\n", "\ndef make_set(a):\n    parent[a] = a\n    size[a] = 1\n    \n      \ndef find_set(a):\n        if a == parent[a]:\n            return a\n        else:\n            parent[a] = find_set(parent[a])\n        return parent[a]\n    \n\ndef union_sets(a, b):\n    a = find_set(a)\n    b = find_set(b)\n    if a != b:\n        if size[a] < size[b]:\n            a, b = b, a\n        parent[b] = a\n        size[a] += size[b]\n        \n        \n        \n        \ndef is_valid(a):\n    i = a[0]\n    j = a[1]\n    if 0<=i<=n-1 and 0<=j<=m-1:\n        if A[i][j] == '.':\n            if (i,j) not in parent:\n                return False\n            else:\n                return True \n        else:\n            return True\n    else:\n        return True\n        \n        \n        \n        \n        \nparent = dict()\nsize = dict()\nn,m,ks = map(int, input().split())\nA = [0] * n\nfor i in range(n):\n    A[i] = list(input())\n\nfor i in range(n):\n    for j in range(m):\n        if i != 0 and j != 0 and i != n - 1 and j != m - 1:\n        \n            if A[i][j] == '.':\n                if is_valid((i-1,j)) and is_valid((i,j-1)):\n                    \n                    make_set((i,j))\n                    if (i-1,j) in parent:\n                        union_sets((i-1,j), (i,j))\n                    if (i,j-1) in parent:\n                        union_sets((i,j-1), (i,j))\n                else:\n                    if A[i][j] =='.':\n                        dels = []\n                        if (i-1,j) in parent:\n                            a1 = find_set((i-1,j))\n                           \n                            for k in parent:\n                                if find_set(k) == a1:\n                                    \n                                    dels.append(k)\n                      \n                        for f in dels:\n                            \n                            parent.pop(f)\n                        dels = []\n                        if (i,j-1) in parent:\n                            \n                            a1 = find_set((i,j-1))\n                            \n                            for k in parent:\n                                if find_set(k) == a1:\n                                    dels.append(k)\n                        \n                        for f in dels:\n                            \n                            parent.pop(f)            \n                        \n        else:\n            if A[i][j] =='.':\n                dels = []\n                if (i-1,j) in parent:\n                    a1 = find_set((i-1,j))\n                   \n                    for k in parent:\n                        if find_set(k) == a1:\n                            \n                            dels.append(k)\n              \n                for f in dels:\n                    \n                    parent.pop(f)\n                dels = []\n                if (i,j-1) in parent:\n                    \n                    a1 = find_set((i,j-1))\n                    \n                    for k in parent:\n                        if find_set(k) == a1:\n                            dels.append(k)\n                \n                for f in dels:\n                    \n                    parent.pop(f)    \n\nans = 0\nass = 0\nans2 = []\nfor j in parent:\n    a1 = find_set(j)\n    if a1 not in ans2:\n        ans2.append(a1)\n        ans +=1\nfor j in range(ans-ks):\n    mins = float('infinity')\n    numer = 0\n    new_sizes = dict()\n    for t in parent:\n        a1 = find_set(t)\n        if a1 in new_sizes:\n            new_sizes[a1] +=1\n        else:\n            new_sizes[a1] = 1\n    \n    for t in new_sizes:\n        if new_sizes[t] < mins:\n            mins = new_sizes[t]\n            numer = t\n    ass += mins \n    dels = []\n    for t in parent:\n        \n        if find_set(t) == numer:\n            dels.append(t)\n            \n            A[t[0]][t[1]] = '*'      \n    for t in dels:\n        parent.pop(t)\nprint(ass)\nfor j in range(n):\n    print(''.join(A[j]))", "x,y,k=list(map(int,input().split()))\na=[input().strip() for i in range(x)]\nm=[[0 if j=='*' else 1 for j in i] for i in a]\nm1=[[0 if j=='*' else 1 for j in i] for i in a]\nlk=[]\n\ndef bfs(m,i,j):\n\tq=set()\n\ts=0\n\tf=1\n\tq.add((i,j))\n\twhile q:\n\t\tax,ay=q.pop()\n\t\tm[ax][ay]=0\n\t\ts+=1\n\t\tif ax==0 or ay==0 or ax==x-1 or ay==y-1:f=0\n\t\tif ax<x-1 and m[ax+1][ay]:\n\t\t\tq.add((ax+1,ay))\n\t\tif ax>0 and m[ax-1][ay]:\n\t\t\tq.add((ax-1,ay))\n\t\tif ay<y-1 and m[ax][ay+1]:\n\t\t\tq.add((ax,ay+1))\n\t\tif ay>0 and m[ax][ay-1]:\n\t\t\tq.add((ax,ay-1))\n\treturn f,s\n\nfor i in range(x):\n\tfor j in range(y):\n\t\tif m1[i][j]:\n\t\t\tf,s=bfs(m1,i,j)\n\t\t\tif f:\n\t\t\t\tlk.append((s,i,j))\nlk.sort()\nk1=len(lk)\nsal=0\nfor e in range(k1-k):\n\ts,i,j=lk[e]\n\tsal+=s\n\tbfs(m,i,j)\nprint(sal)\nfor i in range(x):\n\tprint(''.join(['.' if j else '*' for j in m[i]]))\n", "def find_neigh(t,x,y):\n    return [(i,j) for (i,j) in [(x-1,y),(x+1,y),(x,y-1),(x,y+1),(x,y+1)]\n            if t[i][j]=='.']\n\ndef lake(table):\n    return [(i,j) for i in range(0,len(table)-1)\n                  for j in range(0, len(table[i])-1)\n            if table[i][j] == '.']\n\nstack=set()\ndef the_lake(table,x,y):\n    queue=[(x,y)]\n    counted=set()\n    counted.add((x,y))\n    stack.add((x,y))\n    while queue:\n        start=queue.pop()\n        for (i,j) in find_neigh(table,*start):\n            if (i,j) in counted:\n                continue\n            stack.add((i,j))\n            queue.append((i,j))\n            counted.add((i,j))\n    for (i,j) in counted:\n        if table[i+1][j]=='0' or table[i-1][j]=='0':\n            return\n        if table[i][j+1]=='0' or table[i][j-1]=='0':\n            return\n    return counted\n\ndef island(table,n,m,k):\n    lakes=[]\n    count=0\n    for (i,j) in lake(table):\n        if (i,j) in stack:\n            continue\n        tlake=the_lake(table,i,j)\n        if tlake==None:\n            continue\n        lakes.append(tlake)\n    lakes=sorted(lakes,key=len)\n    for p in range(0,len(lakes)-k):\n        for i,j in lakes[p]:\n            row=list(table[i])\n            row[j]='*'\n            count+=1\n            table[i]=''.join(row)\n    print(count)\n    for i in range(1,n+1):\n        print(table[i][1:m+1])\n    \nn,m,k=input().split(' ')\ncarta=[]\nfor i in range(int(n)):\n    row='0'+input()+'0'\n    carta.append(row)\ncarta=['0'*(int(m)+2)]+carta+['0'*(int(m)+2)]\nisland(carta,int(n),int(m),int(k))", "def mark(z):\n  while z: z = z[0]\n  return z\n\ndef mark2(z):\n  while z and type(z) == list: z = z[0]\n  return z\n  \n__debug = None  \n  \nn, m, kk = map(int, input().split())\ndata = [list(input()) for i in range(n)]\n\nocean = []\nearth = []\nwork = [[] for i in range(m*n)]\n\nfor k in range(m):\n  if data[0][k] == '.':\n    work[m*0 + k].append(ocean)\n  if data[n-1][k] == '.':\n    work[m*(n-1) + k].append(ocean)\nfor i in range(n):\n  if data[i][0] == '.':\n    work[m*i + 0].append(ocean)\n  if data[i][m-1] == '.':\n    work[m*i + m-1].append(ocean)\n\nfor i in range(n):\n  for k in range(m):\n    if data[i][k] == '.':\n      z = mark(work[m*i + k])\n      if i and data[i-1][k] == '.':\n        zi = mark(work[m*(i-1) + k])\n        if z is not zi:\n          if z is ocean:\n            zi.append(z)\n          else:  \n            z.append(zi)\n            z = zi\n      if k and data[i][k-1] == '.':\n        zk = mark(work[m*i + k-1])\n        if z is not zk:\n          if z is ocean:\n            zk.append(z)\n          else:  \n            z.append(zk)\n\nisl = {}\nno = 1    \n\nfor i in range(n):\n  for k in range(m):\n    if data[i][k] == '.':\n      if __debug: print(i, end=\" \")\n      if __debug: print(k, end=\": \")\n      z = mark2(work[m*i + k])\n      if z:\n        isl[z].append((i,k)) \n        if __debug: print(z, end=\", old\")\n      elif z is not ocean:\n        z.append(no)\n        if __debug: print(no, end=\", new\")\n        isl[no] = [(i,k)] \n        no += 1\n      if __debug: print()\n\nif __debug: print(isl)\nisl_s = list(isl.values())\nif __debug: print(isl_s)\nisl_s.sort(key = len)\nif __debug: print(isl_s)\ndelta = len(isl_s) - kk\nif __debug: print(len(isl_s), end=\" \")\nif __debug: print(kk)\nfor t in range(delta):\n  for i, k in isl_s[t]:\n    data[i][k] = '*'\n    \nprint(sum(map(len, isl_s[:delta])))\nfor i in range(n):\n  print(\"\".join(data[i]))", "import sys\nsys.setrecursionlimit(100000)\n\nn,m,k = map(int,input().split())\n\narr = []\nfor i in range(n):\n    krr = []\n    p = input()\n    for x in p:\n        if(x=='*'):\n            krr.append(0)\n        else:\n            krr.append(-1)\n    arr.append(krr)\n\nlakes = [-1]\nislakes = [-1]\nlakesp = [[-1,-1]]\n\ndef go(x,y,c):\n    if(x<0)or(x>=n)or(y<0)or(y>=m):\n        return\n    if(arr[x][y]==0):\n        return\n    if(arr[x][y]!=-1):\n        return\n    arr[x][y] = c\n    if(x==0)or(x==n-1)or(y==0)or(y==m-1):\n        islakes[c] = 0\n    lakes[c] += 1\n    go(x-1,y,c)\n    go(x,y-1,c)\n    go(x+1,y,c)\n    go(x,y+1,c)\n\n\ncolor = 0\nfor x in range(n):\n    for y in range(m):\n        if(arr[x][y]==-1):\n            color += 1\n            lakes.append(0)\n            islakes.append(1)\n            go(x,y,color)\n            lakesp.append([x,y])\n\ndef re(x,y):\n    if(x<0)or(x>=n)or(y<0)or(y>=m):\n        return\n    if(arr[x][y]==0):\n        return\n    arr[x][y] = 0\n    re(x-1,y)\n    re(x,y-1)\n    re(x+1,y)\n    re(x,y+1)\n\ndef min():\n    min = 1000000000\n    mini = 0\n    for i in range(1,color+1):\n        if(islakes[i]):\n            if(min>lakes[i]):\n                min = lakes[i]\n                mini = i\n    return mini\n\ncnt = 0\nnn = 0\nfor i in range(1,color+1):\n    if(islakes[i]==0):\n        continue\n    nn += 1\n\np = nn-k\nfor i in range(1,color+1):\n    if(p==0):\n        break\n    j = min()\n    cnt += lakes[j]\n    lakes[j] = 1000000000\n    re(lakesp[j][0],lakesp[j][1])\n    p -= 1\n\nprint(cnt)\nfor x in arr:\n    s = ''\n    for y in x:\n        if(y==0):\n            s += '*'\n        else:\n            s += '.'\n    print(s)", "import sys\n\nsys.setrecursionlimit(5000)\n\nn, m, k = [int(x) for x in input().split()]\n\nland = []\ncc = 0\nvisit = [[0 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    land.append(list(input()))\nedge = False\n\ndef DFS(i, j, c):\n    nonlocal land, n, m, k, cc, visit, edge\n    if i <= 0 or j <= 0 or i >= n-1 or j >= m-1:\n        edge = True\n        return 0\n    if visit[i][j] != 0: return 0\n    if land[i][j] == '*': return 0\n    visit[i][j] = 1\n    cc += 1\n    if land[i + 1][j] == '.': DFS(i + 1, j, c + 1)\n    if land[i - 1][j] == '.': DFS(i - 1, j, c + 1)\n    if land[i][j + 1] == '.': DFS(i, j + 1, c + 1)\n    if land[i][j - 1] == '.': DFS(i, j - 1, c + 1)\n\ndef DFS2(i, j):\n    nonlocal land, n, m, k, cc\n    if i < 0 or j < 0 or i >= n or j >= m: return 0\n    if land[i][j] != '.': return 0\n    land[i][j] = '*'\n    DFS2(i+1,j)\n    DFS2(i - 1, j)\n    DFS2(i, j+1)\n    DFS2(i, j-1)\n    return 0\n\n\nccc = []\npos = []\n\nfor i in range(n):\n    for j in range(m):\n        cc = 0\n        edge = False\n        if visit[i][j] == 0:\n            DFS(i,j,0)\n            if edge is True: continue\n            if cc > 0:\n                ccc.append([cc, i, j])\n\n\nccc.sort()\n\nred =len(ccc) - k\n\nif red == 0:\n    print(0)\n    for i in range(n):\n        print(''.join(land[i]))\n    return\n\nred_list = ccc[0:red]\n\np = [x[0] for x in red_list]\nprint(sum(p))\n\nfor i in range(len(red_list)):\n    DFS2(red_list[i][1], red_list[i][2])\n\nfor i in range(n):\n    print(''.join(land[i]))", "def mark(z):\n  while z: z = z[0]\n  return z\n\ndef mark2(z):\n  while z and type(z) == list: z = z[0]\n  return z\n  \n__debug = None  \n  \nn, m, kk = map(int, input().split())\ndata = [list(input()) for i in range(n)]\n\nocean = []\nearth = []\nwork = [[] for i in range(m*n)]\n\nfor k in range(m):\n  if data[0][k] == '.':\n    work[m*0 + k].append(ocean)\n  if data[n-1][k] == '.':\n    work[m*(n-1) + k].append(ocean)\nfor i in range(1,n-1):\n  if data[i][0] == '.':\n    work[m*i + 0].append(ocean)\n  if data[i][m-1] == '.':\n    work[m*i + m-1].append(ocean)\n\nfor i in range(1,n):\n  for k in range(1,m):\n    if data[i][k] == '.':\n      z = mark(work[m*i + k])\n      if i and data[i-1][k] == '.':\n        zi = mark(work[m*(i-1) + k])\n        if z is not zi:\n          if z is ocean:\n            zi.append(z)\n          else:  \n            z.append(zi)\n            z = zi\n      if k and data[i][k-1] == '.':\n        zk = mark(work[m*i + k-1])\n        if z is not zk:\n          if z is ocean:\n            zk.append(z)\n          else:  \n            z.append(zk)\n\nisl = {}\nno = 1    \n\nfor i in range(1,n-1):\n  for k in range(1,m-1):\n    if data[i][k] == '.':\n      if __debug: print(i, end=\" \")\n      if __debug: print(k, end=\": \")\n      z = mark2(work[m*i + k])\n      if z:\n        isl[z].append((i,k)) \n        if __debug: print(z, end=\", old\")\n      elif z is not ocean:\n        z.append(no)\n        if __debug: print(no, end=\", new\")\n        isl[no] = [(i,k)] \n        no += 1\n      if __debug: print()\n\nif __debug: print(isl)\nisl_s = list(isl.values())\nif __debug: print(isl_s)\nisl_s.sort(key = len)\nif __debug: print(isl_s)\ndelta = len(isl_s) - kk\nif __debug: print(len(isl_s), end=\" \")\nif __debug: print(kk)\nfor t in range(delta):\n  for i, k in isl_s[t]:\n    data[i][k] = '*'\n    \nprint(sum(map(len, isl_s[:delta])))\nfor i in range(n):\n  print(\"\".join(data[i]))", "import sys\nfrom collections import defaultdict, OrderedDict\n\nsys.setrecursionlimit(10**5)\nn, m, k = list(map(int, input().split()))\n\ng = []\nfor i in range(n):\n    g.append(list(input()))\n\ndy = [1, -1, 0, 0]\ndx = [0, 0, 1, -1]\nd = defaultdict(list)\n\n\ndef dfs(g, u, visited):\n    visited[u[0]][u[1]] = True\n    # print(visited)\n\n    for i in range(4):\n        y = u[0] + dy[i]\n        x = u[1] + dx[i]\n        # print('y = {0} x = {1}'.format(y, x))\n        if y >= 0 and y < n and x >= 0 and x < m \\\n           and g[y][x] == '.' and not visited[y][x]:\n            # if u == (2, 3):\n                # print('y = {0} x = {1}'.format(y, x))\n            dfs(g, (y, x), visited)\n\n\ndef dfs_(g, u, visited, component):\n    visited[u[0]][u[1]] = True\n    d[component].append(u)\n\n    for i in range(4):\n        y = u[0] + dy[i]\n        x = u[1] + dx[i]\n        if y >= 0 and y < n and x >= 0 and x < m \\\n           and g[y][x] == '.' and not visited[y][x]:\n            dfs_(g, (y, x), visited, component)\n\n# dfs from the outer edge and mark the bad ones\nvisited = [[False for j in range(m)] for i in range(n)]\n\nfor i in range(m):\n    if g[0][i] == '.' and not visited[0][i]:\n        dfs(g, (0, i), visited)\n    if g[n - 1][i] == '.' and not visited[-1][i]:\n        dfs(g, (n - 1, i), visited)\n\nfor i in range(1, n - 1):\n    if g[i][0] == '.' and not visited[i][0]:\n        dfs(g, (i, 0), visited)\n    if g[i][m - 1] == '.' and not visited[i][m - 1]:\n        dfs(g, (i, m - 1), visited)\n\ncomponent = 0\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        if g[i][j] == '.' and not visited[i][j]:\n            dfs_(g, (i, j), visited, component)\n            component += 1\n\n\n# print(d)\nl = sorted(list(d.items()), key=lambda x: len(x[1]))\n\ni = 0\ncount = 0\nwhile component > k:\n    component -= 1\n    count += len(l[i][1])\n    for u in l[i][1]:\n        g[u[0]][u[1]] = '*'\n    i += 1\n\nprint(count)\n\nfor i in range(n):\n    print(''.join(g[i]))\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport sys\ndef delete(j,m):\n    nonlocal a\n    i=0\n    while(i<len(oz[j])):\n        w,b=oz[j][i],oz[j][i+1]\n        i+=2\n        a[w][b]='*'\ndef poi(i,j,k):\n    visited[i][j]=True\n    oz[k]+=i,j\n    ozsi[k]+=1\n    if (j-1)>=0 and a[i][j-1]=='.' and not visited[i][j-1]:\n        poi(i,j-1,k)\n    if (j+1)<=(m+1) and a[i][j+1]=='.'and not visited[i][j+1]:\n        poi(i,j+1,k)\n    if (i-1)>=0 and a[i-1][j]=='.'and not visited[i-1][j]:\n        poi(i-1,j,k)\n    if (i+1)<=(n+1) and a[i+1][j] == '.'and not visited[i+1][j]:\n        poi(i+1, j,k)\nn,m,vb=map(int,input().split())\na=[]\noz=[]\nozsi=[]\nvisited=[[False for r in range(m+2)] for t in range(n+2)]\na.append(['.']*(m+2))\nsys.setrecursionlimit(3000)\nfor i in range(n):\n    s='.'+input()+'.'\n    a.append([str(x) for x in s])\nk=0\na.append(['.']*(m+2))\nfor i in range(0,n+2):\n    for j in range(0,m+2):\n        if a[i][j]=='.':\n            if not visited[i][j]:\n                ozsi.append(0)\n                oz.append([])\n                poi(i,j,k)\n                k += 1\nt=len(ozsi)-vb-1\ne=0\nfor i in range(t):\n    min=10**10\n    minj=0\n    for j in range(1,len(ozsi)):\n        if ozsi[j]<min:\n            min=ozsi[j]\n            minj=j\n    e+=min\n    delete(minj,min)\n    ozsi[minj]=10**10\nprint(e)\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        print(a[i][j],end='')\n    print()", "from collections import Counter, defaultdict\n\nn, m, k = [int(x) for x in input().split()]\n\nmp = [[\".\"] * (m + 2)] + [list(\".\" + input().strip() + \".\") for _ in range(n)] + [[\".\"] * (m + 2)]\nuf = {}\nfor i in range(n + 2):\n    for j in range(m + 2):\n        uf[(i, j)] = (i, j)\n\n\ndef find(u):\n    if u != uf[u]:\n        uf[u] = find(uf[u])\n    return uf[u]\n\n\ndef union(u, v):\n    pu = find(u)\n    pv = find(v)\n    if pu != pv:\n        uf[pv] = pu\n\n\nfor i in range(n + 2):\n    for j in range(m + 2):\n        if mp[i][j] == '*':\n            continue\n        if i <= n and mp[i + 1][j] == '.':\n            union((i, j), (i + 1, j))\n        if j <= m and mp[i][j + 1] == '.':\n            union((i, j), (i, j + 1))\n\nd = defaultdict(int)\nf0 = find((0, 0))\nfor i in range(n + 2):\n    for j in range(m + 2):\n        if mp[i][j] == '*':\n            continue\n        f = find((i, j))\n        if f != f0:\n            d[f] += 1\nl = sorted([(v, k) for k, v in list(d.items())])\nll = len(l)\nps = set([u for _, u in l[:ll - k]])\nr = 0\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        if mp[i][j] == '.' and find((i, j)) in ps:\n            mp[i][j] = '*'\n            r += 1\n\nprint(r)\nprint(\"\\n\".join( \"\".join(m[1:-1])for m in mp[1:-1]))\n", "corr = lambda x, y: 0 <= x < n and 0 <= y < m and a[x][y] == '.'\nocean = lambda x, y: x in (0, n - 1) or y in (0, m - 1)\nD = (0, 1), (0, -1), (1, 0), (-1, 0)\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 5)\n\ndef dfs(x, y):\n    nonlocal size, flag\n    was[x][y] = clr\n    size += 1\n    if ocean(x, y): flag = True\n    for dx, dy in D:\n        nx, ny = x + dx, y + dy\n        if corr(nx, ny) and not was[nx][ny]:\n            dfs(nx, ny)\n\nread = lambda: map(int, input().split())\nn, m, k = read()\na = [input() for i in range(n)]\ns = []\nwas = [[0] * m for i in range(n)]\nclr = 1\nfor i in range(n):\n    for j in range(m):\n        if not was[i][j] and a[i][j] == '.':\n            flag = False\n            size = 0\n            dfs(i, j)\n            if not  flag:\n                s.append((size, clr))\n            clr += 1\ns.sort()\nans = 0\ncolor = set()\nfor i in range(len(s) - k):\n    ans += s[i][0]\n    color.add(s[i][1])\nb = [list(a[i]) for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if was[i][j] in color:\n            b[i][j] = '*'\nprint(ans)\n[print(''.join(i)) for i in b]\n", "class DSU:\n    def __init__(self, n):\n        self.parents = [-1] * n\n        self.size = [0] * n\n\n    def make(self, v):\n        if self.parents[v] != -1:\n            return\n        self.parents[v] = v\n        self.size[v] = 1\n\n    def find(self, v):\n        if self.parents[v] in (v, -1):\n            return self.parents[v]\n        self.parents[v] = self.find(self.parents[v])\n        return self.parents[v]\n\n    def join(self, v, u):\n        v = self.find(v)\n        u = self.find(u)\n        if v == u or -1 in (u, v):\n            return\n        if self.size[v] < self.size[u]:\n            v, u = u, v\n        self.parents[u] = v\n        self.size[v] += self.size[u]\n\ndef get_cart2line(m): \n    return lambda x, y: x * m + y\n\ndef main():\n    n, m, k = map(int, input().split())\n    g = [list(input()) for _ in range(n)]\n    \n    ocean = 0\n    dsu = DSU(n * m)\n    dsu.make(ocean)\n    \n    line = get_cart2line(m)\n    \n    for i in range(n):\n        a, b = line(i, 0), line(i, m - 1)\n        dsu.make(a)\n        dsu.make(b)\n        dsu.join(ocean, a)\n        dsu.join(ocean, b)\n\n    for i in range(m):\n        a, b = line(0, i), line(n-1, i)\n        dsu.make(a)\n        dsu.make(b)\n        dsu.join(ocean, a)\n        dsu.join(ocean, b)\n        \n    for i in range(n):\n        for j in range(m):\n            if g[i][j] == '.':\n                dsu.make(line(i, j))\n                if j > 0:\n                    if g[i][j-1] == '.':\n                        dsu.join(line(i, j-1), line(i, j))\n                if i > 0:\n                    if g[i-1][j] == '.':\n                        dsu.join(line(i-1, j), line(i, j))\n\n    s = set()\n    for i in range(n):\n        for j in range(m):\n            tmp = dsu.find(line(i, j))\n            if tmp not in (-1, dsu.find(ocean)):\n                s.add(tmp)\n    s = [(dsu.find(i), dsu.size[dsu.find(i)]) for i in s]\n    s.sort(key=lambda x: x[1])\n    if len(s) == k:\n        print(0)\n        print(*(''.join(r) for r in g), sep='\\n')\n        return\n    s = s[:len(s) - k]\n    ans = sum((x[1] for x in s))\n    s = {x[0] for x in s}\n    for i in range(n):\n        for j in range(m):\n            if dsu.find(line(i, j)) in s:\n                g[i][j] = '*'\n    print(ans)\n    print(*(''.join(r) for r in g), sep='\\n')\n\nmain()\n", "def main():\n    def dfs(x, y):\n        nonlocal inner\n        if land[y][x] == '.':\n            s = 1\n            land[y][x] = '*'\n            if x:\n                s += dfs(x - 1, y)\n            else:\n                inner = False\n            if x + 1 < m:\n                s += dfs(x + 1, y)\n            else:\n                inner = False\n            if y:\n                s += dfs(x, y - 1)\n            else:\n                inner = False\n            if y + 1 < n:\n                s += dfs(x, y + 1)\n            else:\n                inner = False\n            return s\n        return 0\n\n    n, m, k = list(map(int, input().split()))\n    land = [list(input()) for _ in range(n)]\n    sav = [row[:] for row in land]\n    lakes = []\n    for y, row in enumerate(land):\n        for x, f in enumerate(row):\n            inner = True\n            s = dfs(x, y)\n            if s and inner:\n                lakes.append((s, x, y))\n    land, res = sav, 0\n    for _, x, y in sorted(lakes)[:len(lakes) - k]:\n        res += dfs(x, y)\n    print(res)\n    for row in land:\n        print(''.join(row))\n\n\ndef __starting_point():\n    from sys import setrecursionlimit\n\n    setrecursionlimit(3000)\n    main()\n\n__starting_point()", "def main():\n    def dfs(x, y):\n        nonlocal inner\n        if d[x, y] == '.':\n            d[x, y], s = '*', 1\n            for uv in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):\n                try:\n                    s += dfs(*uv)\n                except KeyError:\n                    inner = False\n            return s\n        return 0\n\n    n, m, k = list(map(int, input().split()))\n    d = {(x, y): c for y in range(n) for x, c in enumerate(input())}\n    sav, lakes = d.copy(), []\n    for y in range(n):\n        for x in range(m):\n            inner = True\n            s = dfs(x, y)\n            if s and inner:\n                lakes.append((s, x, y))\n    d, res = sav, 0\n    for _, x, y in sorted(lakes)[:len(lakes) - k]:\n        res += dfs(x, y)\n    print(res)\n    for y in range(n):\n        print(''.join(d[x, y] for x in range(m)))\n\n\ndef __starting_point():\n    from sys import setrecursionlimit\n\n    setrecursionlimit(6000)\n    main()\n\n__starting_point()", "import sys\ndef dfs(i, j):\n    nonlocal used, ans\n    used[i][j] = True\n    ans.append((i, j))\n    if (i - 1 >= 0 and j >= 0 and not used[i - 1][j]):\n        dfs(i - 1, j)\n    if (i >= 0 and j + 1 <= m - 1 and not used[i][j + 1]):\n        dfs(i, j + 1)  \n    if (i + 1 <= n - 1 and j <= m - 1 and not used[i + 1][j]):\n        dfs(i + 1, j)\n    if (i <= n - 1 and j - 1 >= 0 and not used[i][j - 1]):\n        dfs(i, j - 1)\n\n\nsys.setrecursionlimit(1000000)\nn, m, k = map(int, input().split())\nused = [[True for i in range(m)] for j in range(n)]\nhole = [[True for i in range(m)] for j in range(n)]\nfor i in range(n):\n    h = input()\n    for j in range(m):\n        if (h[j] == \".\"):\n            used[i][j] = False\n            hole[i][j] = False\nansi = []\nfor i in range(n):\n    for j in range(m):\n        ans = []\n        if (not used[i][j]):\n            dfs(i, j)\n        if len(ans):\n            f = False\n            for elem in ans:\n                if (not elem[0]) or (not elem[1]) or (elem[0] == n - 1) or (elem[1] == m - 1):\n                    f = True\n            if not f:\n                ansl = [len(ans)] + ans\n                ansi.append(ansl)\nansi.sort()\ns = 0\nfor i in range(len(ansi) - k):\n    s += ansi[i][0]\n    for j in range(1, ansi[i][0] + 1):\n        hole[ansi[i][j][0]][ansi[i][j][1]] = True\nprint(s)\nfor i in range(n):\n    op = \"\"\n    for j in range(m):\n        if hole[i][j]:\n            op += \"*\"\n        else:\n            op += \".\"\n    print(op)", "from typing import List, Tuple\n\n\ndef solve(n: int, m: int, k: int, chart: List[List[str]]):\n\n    visited = [[0] * m for _ in range(n)]\n\n    def dfs(x: int, y: int) -> List[Tuple[int, int]]:\n        stack = [(x, y)]\n        component = set([(x, y)])\n        is_ocean = False\n        while stack:\n            a, b = stack.pop()\n            visited[a][b] = 1\n            if a == 0 or a == n - 1 or b == 0 or b == m - 1:\n                is_ocean = True\n            for ao, bo in [(a, b + 1), (a, b - 1), (a + 1, b), (a - 1, b)]:\n                if 0 <= ao < n and 0 <= bo < m:\n                    if not visited[ao][bo] and chart[ao][bo] == '.':\n                        stack.append((ao, bo))\n                        component.add((ao, bo))\n        if not is_ocean:\n            return list(component)\n\n    lakes = []\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            if not visited[i][j] and chart[i][j] == '.':\n                lake = dfs(i, j)\n                if lake:\n                    lakes.append(lake)\n    changes = 0\n    for component in sorted(lakes, key=len)[:len(lakes) - k]:\n        for x, y in component:\n            changes += 1\n            chart[x][y] = '*'\n    return changes, chart\n\n\nn, m, k = list(map(int, input().split()))\nchart = [list(input()) for _ in range(n)]\nchanges, new_chart = solve(n, m, k, chart)\nprint(changes)\nfor line in new_chart:\n    print(''.join(line))\n"]
["n=int(input())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nfined=0\ni=0\nj=0\nd1={}\nwhile i<n and j<n:\n    if l1[i] in d1:\n        i+=1\n        continue\n    if l1[i]==l2[j]:\n        i+=1\n        j+=1\n    else :\n        while j<n and l2[j]!=l1[i]:\n            d1[l2[j]]=1\n            j+=1\n            fined+=1\nprint(fined)", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ni = 0\nj = 0\nans = 0\ns = set()\nwhile i < len(a):\n    if a[i] in s:\n        i += 1\n        continue\n    while b[j] != a[i]:\n        s.add(b[j])\n        ans += 1\n        j += 1\n    i += 1\n    j += 1\nprint(ans)\n", "n = int(input())\n\narr1 = list(map(int, input().split(' ')))\narr2 = list(map(int, input().split(' ')))\n\nexcluded = [False] * (n + 1)\nsol = 0\n\ni = 0\nj = 0\n\nwhile(i < n and j < n):\n  if(excluded[arr1[i]]):\n    i += 1\n    continue\n\n  if(arr1[i] == arr2[j]):\n    i += 1\n    j += 1\n  else:\n    excluded[arr2[j]] = True\n    j += 1\n    sol += 1\n  \nprint(sol)\n", "n=int(input())\nit=list(map(int,input().split()))\naa=list(map(int,input().split()))\nss={}\nfor i in range(n):\n    ss[it[i]]=i\naa=[ss[i] for i in aa]\nma=n+1\ntot=0\nd=[0]*n\nmi=0\nfor i in range(n):\n    if aa[i]>mi:\n        tot+=1\n    d[aa[i]]=1\n    \n    if mi==aa[i]:\n        while mi<n:\n            if d[mi]==1:\n                mi+=1\n            else:\n                break\n        \nprint(tot)\n", "n = int(input())\nl1 = list(map(int,input().split()))\nl2 = list(map(int,input().split()))\nl1.reverse()\nl2.reverse()\ntrans = [0] * n\nfor i in range(n):\n\ttrans[l1[i] - 1] = i\nend = [0] * n\nfor i in range(n):\n\tend[i] = trans[l2[i] - 1]\nwyn = 0\nmaksi = end[0]\nfor i in range(1, n):\n\tif end[i] < maksi:\n\t\twyn += 1\n\tmaksi = max(end[i], maksi)\nprint(wyn)", "n = int(input())\na = list(map(int, input().split()))\nd = [0]*n\nfor q in range(len(a)):\n    d[a[q]-1] = q\ns = list(map(int, input().split()))\nfor q in range(len(s)):\n    s[q] = d[s[q]-1]\nf = [0]*n\nans = q1 = 0\nfor q in range(len(s)):\n    f[s[q]] = 1\n    if s[q] == q1:\n        while q1 < len(f) and f[q1]:\n            q1 += 1\n    if s[q] > q1:\n        ans += 1\nprint(ans)\n", "n=int(input())\nd=dict()\nl=[int(j) for j in input().split()]\nl2=[int(j) for j in input().split()]\nf=0\nc=0\nfor i in range(n):\n    t=l[i]\n    if f==n:\n        break\n    if not(t in d):\n        while l2[c]!=t and c<n:\n            k=l2[c]\n        \n            if not(k in d):\n                d[k]=1\n                f+=1\n            c+=1\n        c+=1\nprint(f)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN = int(input())\nA = [int(a)-1 for a in input().split()][::-1]\n\nC = [-1] * N\nfor i in range(N):\n    C[A[i]] = i\n\nB = [C[int(a)-1] for a in input().split()][::-1]\n\nans, ma = 0, -1\nfor i in B:\n    if ma > i:\n        ans += 1\n    ma = max(ma, i)\nprint(ans)\n\n\n", "n=int(input())\narr=list(map(int,input().split()))\nbrr=list(map(int,input().split()))\nprev=-1\nd=dict()\nfor i in range(n):\n    d[brr[i]]=i\nans=0\nfor i in range(n):\n    if(d[arr[i]]-prev>0):\n        ans+=(d[arr[i]]-prev-1)\n        prev=d[arr[i]]\n        \nprint(ans)\n        \n", "import io, sys, atexit, os\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nfrom itertools import combinations\n\n\ndef li ():\n\treturn list (map (int, sys.stdin.readline ().split ()))\n\n\ndef num ():\n\treturn map (int, sys.stdin.readline ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef lcm ( x, y ):\n\tgg = find_gcd (x, y)\n\treturn (x * y // gg)\n\nmm = 1000000007\nfact_powers=[0]*19\ntset=set()\n\ndef go ( ind, x ):\n\tif (ind == 19):\n\t\ttset.add (x)\n\t\treturn\n\n\tif (x in tset):\n\t\treturn\n\tgo (ind + 1, x)\n\ti = 0\n\tfor xx in fact_powers [ ind ]:\n\t\tp = x * xx\n\t\tif (p >1e18):\n\t\t\tbreak\n\t\tgo (ind + 1, p)\n\ndef solve ():\n\tt = 1\n\tfor tt in range (t):\n\t\tn=nu()\n\t\ta=li()\n\t\tb=li()\n\t\ti=0\n\t\tj=0\n\t\ts=set()\n\t\tcc=0\n\t\twhile(i<n and j<n):\n\t\t\tif(a[i]==b[j]):\n\t\t\t\ti+=1\n\t\t\t\tj+=1\n\t\t\telse:\n\t\t\t\tif(a[i]in s):\n\t\t\t\t\ti+=1\n\t\t\t\t\tcontinue\n\t\t\t\ts.add(b[j])\n\t\t\t\tcc+=1\n\t\t\t\tj+=1\n\t\tprint(cc)\n\n\n\n\n\n\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\ninda=0\nindb=0\nANS=0\nUSE=[0]*(n+1)\n\nwhile inda<n and indb<n:\n    NOW=A[inda]\n    USE[A[inda]]=1\n\n    for i in range(indb,n):\n        if B[i]==NOW:\n            break\n        else:\n            if USE[B[i]]==0:\n                ANS+=1\n                USE[B[i]]=1\n\n    indb=i+1\n    \n    while inda<n and USE[A[inda]]==1:\n        inda+=1\n\n    #print(inda,indb,ANS)\n\nprint(ANS)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\noptimise_for_recursion = True  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    ai = get_list()\n    bi = get_list()\n    bi.reverse()\n    ai.reverse()\n    pos = 0\n    fined = set()\n    for ele in ai:\n        while pos<n and bi[pos] in fined:\n            pos += 1\n        if ele==bi[pos]:\n            pos+=1\n        else:\n            fined.add(ele)\n    print(len(fined))\n\n\n\n\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "import math\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n\n    out = set()\n    j = 0\n    result = 0\n    for i in range(n):\n        if b[i] != a[j]:\n            out.add(b[i])\n            result += 1\n        else:\n            j += 1\n            while j < n and a[j] in out:\n                j += 1\n    print(result)\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#TO MAKE THE PROGRAM FAST\n\n''' ----------------------------------------------------------------------------------------------------  '''\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#FOR TAKING INPUTS\n\n''' ----------------------------------------------------------------------------------------------------  '''\ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef val():return int(input().rstrip('\\n'))\ndef st():return input().rstrip('\\n')\ndef sttoli():return [int(i) for i in input().rstrip('\\n')]\n''' ----------------------------------------------------------------------------------------------------  '''\n\n\n\n\n#MAIN PROGRAM\n\n''' ----------------------------------------------------------------------------------------------------  '''\n\nn = val()\nl1 = li()\nl2 = li()\nd = {}\nt = 0\nfor i in l1:\n    d[i] = t\n    t += 1\n\ns = set()\nt = 0\ntot = 0\nfor i in l2:\n    if d[i] != t:\n        tot += 1\n        s.add(d[i])\n    else:\n        t += 1\n        while t in s:\n            t += 1\nprint(tot)\n\n\n\n\n''' ----------------------------------------------------------------------------------------------------  '''", "ans=0\nd={}\nans=0\nn=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ni=n-1\nj=n-1\nd={}\nwhile (i>=0):\n    if a[i]==b[j]:\n        i-=1\n        j-=1\n    else:\n        d[a[i]]=1\n        if b[j] not in d:\n            i-=1\n            ans+=1\n        else:\n            j-=1\n        \nprint(ans)        ", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmemo = {}\n\nfor i in range(n):\n    memo[a[i]] = i\n\nans = [0] * n\nfor i in range(n):\n    ans[i] = memo[b[i]]\n\nmin_num = 10**9\ncnt = 0\n\nfor i in range(n)[::-1]:\n    if ans[i] > min_num:\n        cnt += 1\n    min_num = min(min_num, ans[i])\nprint(cnt)", "n=int(input())\na=[int(x) for x in input().split()]\nb=[int(x) for x in input().split()]\ndic={}\narr=0\nmaxim=0\nfor i in range(n):\n    dic[b[i]]=i\nfor item in a:\n    if dic[item]<maxim:\n        arr+=1\n    maxim=max(maxim,dic[item])\nprint(arr)\n    \n", "3\n\nimport array\nimport math\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    A = read_ints()\n    B = read_ints()\n    print(solve(N, A, B))\n\n\ndef solve(N, A, B):\n    T = {}\n    i = 0\n    for b in B:\n        T[b] = i\n        i += 1\n\n    last_pos = -1\n    ans = 0\n    for a in A:\n        t = T[a]\n        if t > last_pos:\n            last_pos = t\n        else:\n            ans += 1\n\n    return ans\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na_dict = {}\nfor i in range(n):\n    a_dict[a[i]] = i+1\nfor i in range(n):\n    b[i] = a_dict[b[i]]\nb.reverse()\n\nans = 0\nmini = n\nfor i in range(n):\n    if mini >= b[i]:\n        mini = b[i]\n    else:\n        ans += 1\n\nprint(ans)\n", "from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations\nimport sys\nimport bisect\nimport string\n#import math\n#import time\n#import random  # randome is not available at Codeforces\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\n#ts=time.time()\n#sys.setrecursionlimit(10**6)\ninput=lambda: sys.stdin.readline().rstrip()\nimport sys\nsys.setrecursionlimit(10**7)\n\nshow_flg=False\n#show_flg=True\n\n\nn=I()\nen=LI()[::-1]\nex=LI()[::-1]\n\nshow(en,ex)\nans=0\nf=[0]*(n+1)\nwhile en:\n    c=en.pop()\n    if f[c]==1:\n        continue\n    while ex:\n        d=ex.pop()\n        if d==c:\n            break\n        ans+=1\n        f[d]=1\n        show(c,d,en,ex)\n\nprint(ans)\n\nshow(f)", "n = int(input())\na = [*map(int, input().split())]\nb = [*map(int, input().split())]\nd = {e: i for i, e in enumerate(a)}\nres = 0\ncur = float('inf')\nfor e in b[::-1]:\n    if d[e] > cur: \n        res += 1\n    else: cur = d[e]\nprint(res)", "n = int(input())\nd = list(map(int, input().split()))\np = list(map(int, input().split()))\no = set()\ni = 0\nj = 0\nwhile j < n:\n    if d[i] in o:\n        i += 1\n    elif d[i] != p[j]:\n        o.add(p[j])\n        j += 1\n    else:\n        i += 1\n        j += 1\nprint(len(o))", "n=int(input())\na=list(map(int,input().strip().split()))\nb=list(map(int,input().strip().split()))\nop=[0]*(n+1)\ni=0\nj=0\nwhile(i<n and j<n):\n    # print(a[i],b[j])\n    if(a[i]==b[j]):\n        i+=1\n        while(i<n and op[a[i]]==1):\n            i+=1\n        j+=1\n    else:\n        op[b[j]]=1\n        j+=1\n    \nprint(sum(op))\n# print(op)\n\n", "n = int(input())\n\n\na = list(map(int, input().split()))\ndictt = {}\nfor x in range(n):\n    dictt[a[x]] = x\n# print(dictt)\nb = list(map(int, input().split()))\nbb = []\nfor x in b:\n    bb.append(dictt[x])\n# print(bb)\nbb.reverse()\n# work with bb\nfines = 0\nsmallest = bb[0]\nlargest = bb[0]\nfor i in range(1, n):\n    if bb[i] > smallest:\n        fines += 1\n        # print(f\"xx{i}\")\n    if bb[i] > largest:\n        largest = bb[i]\n    if bb[i] < smallest:\n        smallest = bb[i]\nprint(fines)\n"]
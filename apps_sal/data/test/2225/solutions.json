["#!/usr/bin/pypy3\n\nfrom sys import stdin,stderr\nimport random\nimport cProfile\n\ndef readInts(): return map(int,stdin.readline().strip().split())\ndef print_err(*args,**kwargs): print(*args,file=stderr,**kwargs)\n    \ndef solve(vs):\n    return None\n\ndef generate_tree(n,ns):\n    out = [0 for _ in range(2**(n+1))]\n    def gt(nix,left,right,op):\n        if left+1==right:\n            out[nix] = ns[left]\n            return out[nix]\n        mid = (left+right)//2\n        nL = nix*2+1\n        nR = nix*2+2\n        vL = gt(nL,left,mid,not op)\n        vR = gt(nR,mid,right,not op)\n        if op: v = vL ^ vR\n        else: v = vL | vR\n        out[nix] = v\n        return v\n    gt(0,0,2**n,n%2==0)\n    return out\n\ndef alter_tree2(n,t,p,b):\n    def at(nix,width,offp,op):\n        if width==1:\n            t[nix]=b\n            return b\n        width //= 2\n        nL = nix*2+1\n        nR = nix*2+2\n        vL = t[nL]\n        vR = t[nR]\n        if offp >= width: vR = at(nR,width,offp-width,not op)\n        else: vL = at(nL,width,offp,not op)\n        if op: v = vL ^ vR\n        else: v = vL | vR\n        t[nix] = v\n        return v\n    at(0,2**n,p,n%2==0)\n            \ndef alter_tree(n,t,p,b):\n    width = 2**n\n    s = []\n    nix = 0\n    op = (n%2==0)\n    while width>1:\n        width //= 2\n        #print(nix)\n        if p >= width:\n            nix2 = 2*nix+2\n            s.append( (nix,nix2-1) )\n            p -= width\n        else:\n            nix2 = 2*nix+1\n            s.append( (nix,nix2+1) )\n        nix = nix2\n        op = not op\n    #print(nix)\n    t[nix] = b\n    v = b\n    while s:\n        nix,nixO = s.pop()\n        if op: v |= t[nixO]\n        else: v ^= t[nixO]\n        t[nix] = v        \n        op = not op\n    return\n    \ndef run():\n    n,m = readInts()    \n    axs = list(readInts())\n    t = generate_tree(n,axs)\n    for _ in range(m):\n        p,b = readInts()\n        alter_tree(n,t,p-1,b)\n        print(t[0])\n\ndef test():\n    n = 17\n    ns = []\n    vs100 = list(range(100))\n    for _ in range(2**17):\n        ns.append(random.choice(vs100))        \n    t = generate_tree(n,ns)\n    t2 = generate_tree(n,ns)\n    for _ in range(100000):\n        v1 = random.choice(vs100)\n        v2 = random.choice(vs100)\n        alter_tree(n,t,v1,v2)\n        alter_tree2(n,t2,v1,v2)\n    print(all(map(lambda x: x[0]==x[1],zip(t,t2))))\n    print(t[0]==t2[0])\n    \nrun()\n", "import math\ndef create(a,n,k):\n\tt = [0]*n+a\n\tfor i in range(n-1,0,-1):\n\t    z = int(math.log(i,2))\n\t    if(k%2==0):\n\t    \tif(z%2):\n\t    \t\tt[i] = t[2*i]|t[2*i+1]\n\t    \telse:\n\t    \t\tt[i] = t[2*i]^t[2*i+1]\n\t    else:\n\t    \tif(z%2):\n\t    \t\tt[i] = t[2*i]^t[2*i+1]\n\t    \telse:\n\t    \t\tt[i] = t[2*i]|t[2*i+1]\n\treturn t\n\ndef update(idx,value,t,n,k):\n\tidx = idx+n\n\tt[idx] = value\n\n\twhile(idx>1):\n\t\tidx = idx>>1\n\t\tz = int(math.log(idx,2))\n\t\tif(not(k&1)):\n\t\t    if(z%2):\n\t\t        t[idx] = t[2*idx]|t[2*idx+1]\n\t\t    else:\n\t\t    \tt[idx] = t[2*idx]^t[2*idx+1]\n\t\telse:\n\t\t\tif(z%2):\n\t\t\t\tt[idx] = t[2*idx]^t[2*idx+1]\n\t\t\telse:\n\t\t\t\tt[idx] = t[2*idx]|t[2*idx+1]\n\treturn t\nimport sys\nn,m = map(int,sys.stdin.readline().strip().split())\nk = n\nl = list(map(int,sys.stdin.readline().strip().split()))\nt = create(l,2**n,k)\n#print(t)\nfor _ in range(m):\n    idx,value = map(int,sys.stdin.readline().strip().split())\n    t = update(idx-1,value,t,2**n,k)\n    print(t[1])", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [tuple(map(int, l.split())) for l in sys.stdin]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Seg():\n    def __init__(self, na, default, func):\n        if isinstance(na, list):\n            n = len(na)\n        else:\n            n = na\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.D = default\n        self.H = i\n        self.N = 2**i\n        if isinstance(na, list):\n            self.A = [default] * (self.N) + na + [default] * (self.N-n)\n            for i in range(self.N-1,0,-1):\n                self.A[i] = func(self.A[i*2], self.A[i*2+1])\n        else:\n            self.A = [default] * (self.N*2)\n        self.F = func\n\n    def find(self, i):\n        return self.A[i + self.N]\n\n    def update(self, i, x):\n        i += self.N\n        self.A[i] = x\n        while i > 1:\n            i = i // 2\n            self.A[i] = self.merge(self.A[i*2], self.A[i*2+1])\n\n    def merge(self, a, b):\n        return self.F(a, b)\n\n    def total(self):\n        return self.A[1]\n\n    def query(self, a, b):\n        A = self.A\n        l = a + self.N\n        r = b + self.N\n        res = self.D\n        while l < r:\n            if l % 2 == 1:\n                res = self.merge(res, A[l])\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                res = self.merge(res, A[r])\n            l >>= 1\n            r >>= 1\n\n        return res\n\ndef main():\n    n,m = LI()\n    a = list(map(lambda x: (x,0), LI()))\n    q = [LI() for _ in range(m)]\n    def f(a, b):\n        if a[1] % 2 == 0:\n            return (a[0] | b[0], 1)\n        return (a[0] ^ b[0], 0)\n\n    seg = Seg(a, (0,0), f)\n    r = []\n    for i,t in q:\n        seg.update(i-1,(t,0))\n        r.append(seg.total()[0])\n\n    return '\\n'.join(map(str, r))\n\nprint(main())\n\n\n", "from math import log\nimport sys\ndef buildTree(arr): \n\tn = len(arr)\n\ttree = [0]*n + arr\n\tfor i in range(n-1, 0, -1):\n\t\tz = int(log(i, 2))\t# determines what level of the tree you're at\n\t\tif N%2 == 0:\n\t\t\tif z % 2 == 0:\n\t\t\t\ttree[i] = tree[2*i]^tree[2*i+1]\n\t\t\telse:\n\t\t\t\ttree[i] = tree[2*i]|tree[2*i+1]\n\t\telse:\n\t\t\tif z % 2 == 0:\n\t\t\t\ttree[i] = tree[2*i]|tree[2*i+1]\n\t\t\telse:\n\t\t\t\ttree[i] = tree[2*i]^tree[2*i+1]\n\treturn tree\n\ndef updateTree(tree, ind, value, n):\n\tind += n\n\ttree[ind] = value\n\twhile ind > 1:\n\t\tind //= 2\n\t\tz = int(log(ind, 2))\n\t\tif N%2 == 0:\n\t\t\tif z % 2 == 0:\n\t\t\t\ttree[ind] = tree[2*ind]^tree[2*ind+1]\n\t\t\telse:\n\t\t\t\ttree[ind] = tree[2*ind]|tree[2*ind+1]\n\t\telse:\n\t\t\tif z % 2 == 0:\n\t\t\t\ttree[ind] = tree[2*ind]|tree[2*ind+1]\n\t\t\telse:\n\t\t\t\ttree[ind] = tree[2*ind]^tree[2*ind+1]\n\treturn tree\n\nN, m = map(int, sys.stdin.readline().strip().split())\narr = list(map(int, sys.stdin.readline().strip().split()))\ntree = buildTree(arr)\nfor i in range(m):\n\tind, val = map(int,sys.stdin.readline().strip().split())\n\ttree = updateTree(tree, ind-1, val, len(arr))\n\tprint(tree[1])", "# TimeLimit on 49-51 test\n# :(\nfrom operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\ntree = [list(map(int, input().split()))]\nfor i in range(n):\n    tree.append([(or_, xor)[i & 1](tree[i][j], tree[i][j + 1]) for j in range(0, len(tree[i]), 2)])\n\nans = []\nfor line in sys.stdin:\n    p, b = line.split()\n    p = int(p) - 1\n    tree[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        tree[j + 1][p] = (or_, xor)[j & 1](tree[j][p << 1], tree[j][(p << 1) + 1])\n    ans.append(str(tree[-1][0]))\n\nprint('\\n'.join(ans))\n", "from operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\ntree = [list(map(int, input().split()))]\nfor i in range(n):\n    tree.append([(or_, xor)[i & 1](*tree[i][j: j + 2]) for j in range(0, len(tree[i]), 2)])\n\nans = []\nfor line in sys.stdin:\n    p, b = line.split()\n    p = int(p) - 1\n    tree[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        tree[j + 1][p] = (or_, xor)[j & 1](*tree[j][p << 1: (p << 1) + 2])\n    ans.append(str(tree[-1][0]))\n\nprint('\\n'.join(ans))\n", "from operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\nt = [list(map(int, input().split()))]\nfor i in range(n):\n    t.append([(or_, xor)[i & 1](*t[i][j: j + 2]) for j in range(0, len(t[i]), 2)])\n\na = []\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        t[j + 1][p] = (or_, xor)[j & 1](*t[j][p << 1: (p << 1) + 2])\n    a.append(str(t[-1][0]))\n\nprint('\\n'.join(a))\n", "from operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\nt = [list(map(int, input().split()))]\nfor i in range(n):\n    t += [[(or_, xor)[i & 1](*t[i][j: j + 2]) for j in range(0, len(t[i]), 2)]]\n\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        t[j + 1][p] = (or_, xor)[j & 1](*t[j][p << 1: (p << 1) + 2])\n    print(t[-1][0])\n", "from operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\nt = [list(map(int, input().split()))]\nfor i in range(n):\n    t += [[(or_, xor)[i & 1](*t[i][j: j + 2]) for j in range(0, len(t[i]), 2)]]\n\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        t[j + 1][p] = (or_, xor)[j & 1](*t[j][p << 1: (p << 1) + 2])\n    sys.stdout.write(str(t[-1][0]) + '\\n')\n", "from operator import or_, xor\nimport sys\n\n\nn, m = list(map(int, input().split()))\nt = [list(map(int, input().split()))]\nfor i in range(n):\n    t += [[(or_, xor)[i & 1](*t[i][j: j + 2]) for j in range(0, len(t[i]), 2)]]\n\na = []\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        t[j + 1][p] = (or_, xor)[j & 1](*t[j][p << 1: (p << 1) + 2])\n    a.append(str(t[-1][0]))\n\nsys.stdout.write('\\n'.join(a))\n", "\nfrom math import floor, log\nfrom sys import stdin, stdout\ndef update(idx, value, n):\n\t# print(idx, n)\n\tnonlocal newL\n\tidx = idx + 2**n-1\n\t# print(idx, n)\n\tnewL[idx] = value\n\tm = len(newL)\n\twhile idx > 1:\n\t\tidx //=2\n\t\tif(distance(idx, m)  % 2 != 0):\n\t\t\tnewL[idx] =  newL[2* idx] | newL[2*idx+1]\n\t\telse:\n\t\t\tnewL[idx] = newL[2 * idx] ^ newL[2 * idx + 1]\n\n\t\n\ndef distance(idx, n):\n\td = 0\n\twhile True:\n\t\tif 2 * idx < n:\n\t\t\td += 1\n\t\t\tidx = 2 * idx\n\t\telse:\n\t\t\tbreak\n\treturn d\n\n\n\ndef makeTree(a, n1):\n\tnewL = [0 for _ in a] + a\n\tn = len(a)\n\tm = len(newL)\n\n\tfor idx in reversed(list(range(1,n))):\n\n\t\tif(distance(idx, m)  % 2 != 0):\n\t\t\tnewL[idx] =  newL[2* idx] | newL[2*idx+1]\n\t\telse:\n\t\t\tnewL[idx] = newL[2 * idx] ^ newL[2 * idx + 1]\n\n\treturn newL\n\n\n\nn, m  = list(map(int, input().split()))\na = [int(x) for x in input().split()]\nnewL = makeTree(a, n)\n# print(newL)\n\nfor _ in range(0,m):\n\tidx, value = list(map(int, stdin.readline().split()))\n\tupdate(idx , value, n)\n\tstdout.write(str(newL[1]) + '\\n')\n\t# print(newL)\n", "from operator import or_, xor\nimport sys\n \nn, m = map(int, input().split())\nt = [list(map(int, input().split()))]\n\nfor i in range(n):\n    t += [[(or_, xor)[i & 1](*t[i][j: j + 2]) for j in range(0, len(t[i]), 2)]]\n    \n#print(t)\n\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p >>= 1\n        t[j + 1][p] = (or_, xor)[j & 1](*t[j][p << 1: (p << 1) + 2])\n    sys.stdout.write(str(t[-1][0]) + '\\n')", "from operator import or_, xor\nimport sys\n \nn, m = map(int, input().split())\nt = [list(map(int, input().split()))]\n\nfor i in range(n):\n    t += [[(or_, xor)[i & 1](t[i][j], t[i][j+1]) for j in range(0, len(t[i]), 2)]]\n    \n#print(t)\n\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p = int(p/2)\n        t[j + 1][p] = (or_, xor)[j & 1](t[j][int(p*2)], t[j][int(p*2)+1])\n    sys.stdout.write(str(t[-1][0]) + '\\n')", "from operator import or_, xor\nimport sys\n \nn, m = map(int, input().split())\nt = [list(map(int, input().split()))]\n\nfor i in range(n):\n    if (i & 1 == 0):\n        t += [[t[i][j] | t[i][j+1] for j in range(0, len(t[i]), 2)]]\n    else:\n        t += [[t[i][j] ^ t[i][j+1] for j in range(0, len(t[i]), 2)]]\n    \n#print(t)\n\nfor s in sys.stdin:\n    p, b = s.split()\n    p = int(p) - 1\n    t[0][p] = int(b)\n    for j in range(n):\n        p = int(p/2)\n        if (j & 1 == 0):\n            t[j + 1][p] = t[j][int(p*2)] | t[j][int(p*2)+1]\n        else:\n            t[j + 1][p] = t[j][int(p*2)] ^ t[j][int(p*2)+1]\n    sys.stdout.write(str(t[-1][0]) + '\\n')", "import sys\ninput = sys.stdin.readline\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nQuery = [list(map(int, input().split())) for _ in range(M)]\n\nL = 2**N\nseg = [0]*(2*L-1)\n\n# initialize\nfor i in range(L):\n    seg[i+L-1] = A[i]\n\nk = L-1\nc = 0\nwhile k > 0:\n    if c%2 == 0:\n        for i in range((k-1)//2, k):\n            seg[i] = seg[2*i+1] | seg[2*i+2]\n    else:\n        for i in range((k-1)//2, k):\n            seg[i] = seg[2*i+1] ^ seg[2*i+2]\n    c += 1\n    k = (k-1)//2\n\n# update and return v\ndef update(k, a):\n    k += L-1\n    seg[k] = a\n    c = 0\n    while k > 0:\n        k = (k-1)//2\n        if c % 2 == 0:\n            seg[k] = seg[2*k+1] | seg[2*k+2]\n        else:\n            seg[k] = seg[2*k+1] ^ seg[2*k+2]\n        c += 1\n    return seg[0]\n\nfor p, b in Query:\n    ans = update(p-1, b)\n    print(ans)", "import sys\ninput=sys.stdin.readline\nimport math\n# sys.setrecursionlimit(10**9)\ndef construct(array,cur_pos,tree,start,end):\n\tif(start==end):\n\t\t# print(cur_pos,\"pppp\",array[start])\n\t\ttree[cur_pos]=array[start]\n\n\telse:\n\t\tmid=(start+end)//2\n\t\tw=(n1-int(math.log2(cur_pos+1)))\n\t\t# print(w,n1,cur_pos+1)\n\t\tif(w%2!=0):\n\t\t\t# print(cur_pos,w)\n\t\t\ttree[cur_pos]=(construct(array,2*cur_pos+1,tree,start,mid)|construct(array,2*cur_pos+2,tree,mid+1,end))\n\t\telse:\n\n\t\t\t# print(cur_pos,w)\n\t\t\ttree[cur_pos]=(construct(array,2*cur_pos+1,tree,start,mid)^construct(array,2*cur_pos+2,tree,mid+1,end))\n\t\t\n\t\t\t\n\t\t\n\treturn tree[cur_pos]\n\ndef update(cur_pos,l,r,index,increment):\n\t# print(tree)\n\tif(l<=index<=r):\n\t\tif(l==r):\n\t\t\ttree[cur_pos]=increment\n\t\telse:\n\t\t\tmid=(l+r)//2\n\t\t\tw=(n1-int(math.log2(cur_pos+1)))\n\t\t\tif(w%2!=0):\n\t\t\t\tupdate(2*cur_pos+1,l,mid,index,increment)\n\t\t\t\tupdate(2*cur_pos+2,mid+1,r,index,increment)\n\t\t\t\ttree[cur_pos]=tree[2*cur_pos+1]|tree[2*cur_pos+2]\n\t\t\telse:\n\t\t\t\tupdate(2*cur_pos+1,l,mid,index,increment)\n\t\t\t\tupdate(2*cur_pos+2,mid+1,r,index,increment)\n\t\t\t\ttree[cur_pos]=tree[2*cur_pos+1]^tree[2*cur_pos+2]\n\t\treturn tree[cur_pos]\n\treturn 0\n\n\nl= list(map(int,input().split())) \nl1=list(map(int,input().split())) \nn=(2**(l[0]))\ntree=[0]*(2**(l[0]+1)-1)\nn1=int(math.log2(len(tree)))\n# print(n1,n,\"llll\")\nconstruct(l1,0,tree,0,n-1)\n# print(tree)\nfor i in range(l[1]):\n\t# print(tree)\n\tl2=list(map(int,input().split())) \n\t\n\n\tupdate(0,0,n-1,l2[0]-1,l2[1])\n\t# print(tree,\"ppp\")\n\tprint(tree[0])\n\n\n\n", "import sys\n\nclass SegmTree():\n    def __init__(self, size):\n        N = 1\n        while N < size:\n            N <<= 1\n        self.N = N\n        self.tree = [0] * (2*N)        \n\n    def modify(self, i, value):\n        i += self.N\n        self.tree[i] = value\n        toXOR = False\n        while i > 1:\n            if toXOR:\n                self.tree[i>>1] = self.tree[i] ^ self.tree[i^1]\n            else:\n                self.tree[i>>1] = self.tree[i] | self.tree[i^1]\n            toXOR = not toXOR\n            i >>= 1\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nst = SegmTree(1<<n)\nfor i, value in enumerate(a):\n    st.modify(i, value)\nfor _ in range(m):\n    p, b = list(map(int, input().split()))\n    st.modify(p-1, b)\n    print(st.tree[1])\n    \n# inf.close()\n", "import sys\n\nn,m = list(map(int,sys.stdin.readline().lstrip().rstrip().split()))\narr = list(map(int,sys.stdin.readline().lstrip().rstrip().split()))\ntree = [arr[::]]\ncnt = 1\nwhile True:\n    temp = []\n    ans = tree[-1]\n    if len(ans)==1:\n        break\n    else:\n        if cnt%2!=0:\n            for i in range(0,len(ans),2):\n                temp.append(ans[i]|ans[i+1])\n        else:\n            for i in range(0,len(ans),2):\n                temp.append(ans[i]^ans[i+1])\n        tree.append(temp)\n    cnt+=1\nfor i in range(m):\n    pos,val = list(map(int,sys.stdin.readline().lstrip().rstrip().split()))\n    pos-=1\n    tree[0][pos] = val\n    cnt = 1\n    while cnt<=n:\n        pos = (pos)//2\n        if cnt%2!=0:\n            tree[cnt][pos] = tree[cnt-1][2*pos]|tree[cnt-1][2*pos+1]\n        else:\n            tree[cnt][pos] = tree[cnt-1][2*pos]^tree[cnt-1][2*pos+1]\n        cnt+=1\n    sys.stdout.write(str(tree[-1][0])+'\\n')", "import sys\ninput = sys.stdin.readline\n \nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nQuery = [list(map(int, input().split())) for _ in range(M)]\n \nL = 2**N\nseg = [0]*(2*L-1)\n \n# initialize\nfor i in range(L):\n    seg[i+L-1] = A[i]\n \nk = L-1\nc = 0\nwhile k > 0:\n    if c%2 == 0:\n        for i in range((k-1)//2, k):\n            seg[i] = seg[2*i+1] | seg[2*i+2]\n    else:\n        for i in range((k-1)//2, k):\n            seg[i] = seg[2*i+1] ^ seg[2*i+2]\n    c += 1\n    k = (k-1)//2\n \n# update and return v\ndef update(k, a):\n    k += L-1\n    seg[k] = a\n    c = 0\n    while k > 0:\n        k = (k-1)//2\n        if c % 2 == 0:\n            seg[k] = seg[2*k+1] | seg[2*k+2]\n        else:\n            seg[k] = seg[2*k+1] ^ seg[2*k+2]\n        c += 1\n    return seg[0]\n \nfor p, b in Query:\n    ans = update(p-1, b)\n    print(ans)\n", "import sys\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inint():\n    return(int(input()))\n\ndef inlst():\n    return(list(map(int,input().split())))\n\n# returns a List of Characters, which is easier to use in Python as Strings are Immutable\ndef instr():\n    s = input()\n    return(list(s[:len(s) - 1]))\n\ndef invar():\n    return(list(map(int,input().split())))\n\nimport math\n\ndef height(num):\n  return int(math.log2(num))\n\nn, m = invar()\nelems = 2**n\ntree = [0]*(2*(elems))\n\nli = inlst()\nfor i in range(elems):\n  tree[i+elems] = li[i]\n\n\ndef update_value(i):\n  if (height(elems) - height(i)) % 2 == 1:\n    tree[i] = tree[2*i] | tree[2*i+1]\n  else:\n    tree[i] = tree[2*i] ^ tree[2*i+1]\n\nfor i in range(elems-1, 0, -1):\n  update_value(i)\n\n\ndef modify(pos, val):\n  pos += elems\n  tree[pos] = val\n\n  while pos > 1:\n    pos >>= 1\n    update_value(pos)\n\nfor _ in range(m):\n  p, b = invar()\n  modify(p-1, b)\n  print(tree[1])\n", "import sys\nfrom math import sqrt\ninput = sys.stdin.readline\n\n############ ---- Input Functions ---- ############\ndef inp():\n    return(int(input()))\ndef inlt():\n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef invr():\n    return(map(int,input().split()))\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nsize = 2 * 2**n # 8\nsegmentTree = [-1]*size # 1~7 \nlevels = [-1]*size\n\nidx = 0\n#initialize \nfor i in range(int(size/2),size):\n    segmentTree[i] = a[idx]\n    levels[i] = 1\n    idx+=1\n\n#build segment tree\nfor i in range(2**n-1,0,-1): # 3,2,1\n    left = 2*i; right = 2*i+1\n    levels[i] = levels[2*i]+1\n    if levels[i] % 2 == 0:\n        segmentTree[i] = segmentTree[left] | segmentTree[right]\n    else:\n        segmentTree[i] = segmentTree[left] ^ segmentTree[right]\n\n#update segment tree\nfor t in range(m):\n    p,b = map(int,input().split())\n    segmentTree[2**n+p-1] = b\n    i = 2**n+p-1\n    while i != 1:\n        parent = int(i/2)\n        left = parent*2; right = parent*2+1\n        if levels[parent] % 2 == 0:\n            segmentTree[parent] = segmentTree[left] | segmentTree[right]\n        else:\n            segmentTree[parent] = segmentTree[left] ^ segmentTree[right]\n        i = parent\n    print(segmentTree[1])", "import sys, math,os\nfrom io import BytesIO, IOBase\n#from bisect import bisect_left as bl, bisect_right as br, insort\n#from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\nsys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9)+7\n\n\ndef main():\n\n    def construct_sum(segtree, a, n):\n        for i in range(n):\n            segtree[n + i] = a[i]\n        k= math.ceil(math.log2(n))%2\n        for i in range(n - 1, 0, -1):\n            if math.ceil(math.log2(i+1))%2==k:\n                segtree[i] = segtree[2 * i] | segtree[2 * i + 1]\n            else:\n                segtree[i] = segtree[2 * i] ^ segtree[2 * i + 1]\n\n\n    def update_sum(pos, x,n):\n        pos +=  n- 1\n        segtree[pos] = x\n        k = math.ceil(math.log2(n)) % 2\n        while (pos > 1):\n            pos >>= 1\n            if math.ceil(math.log2(pos+1))%2==k:\n                segtree[pos] = segtree[2 * pos] | segtree[2 * pos + 1]\n            else:\n                segtree[pos] = segtree[2 * pos] ^ segtree[2 * pos + 1]\n\n    n,m=mdata()\n    a=mdata()\n    segtree = [0] * (2 * len(a))\n    construct_sum(segtree, a, len(a))\n    for i in range(m):\n        p,b=mdata()\n        update_sum(p,b,len(a))\n        print(segtree[1])\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from sys import stdin\n\nn,m = map(int,stdin.readline().split())\nlst = list(map(int,stdin.readline().split()))\nx = 1<<n\n\narr = [0]*(2*x)\nfor j in range(x,2*x):\n    arr[j] = lst[j-x]\n\ny = x\nwhile y != 1:\n    for j in range(y,2*y,2):\n        arr[j//2] = arr[j]|arr[j+1]\n    y >>= 1\n    if y == 1:\n        break\n    for j in range(y,2*y,2):\n        arr[j//2] = arr[j]^arr[j+1]\n    y >>= 1\nfor _ in range(m):\n    p,b = map(int,stdin.readline().split())\n    z = x+p-1\n    arr[z] = b\n    while z != 1:\n        if z%2 == 0:\n            v = z+1\n        else:\n            v = z-1\n        ch = arr[z]|arr[v]\n        z >>= 1\n        arr[z] = ch\n        if z == 1:\n            break\n        if z%2 == 0:\n            v = z+1\n        else:\n            v = z-1\n        ch = arr[z]^arr[v]\n        z >>= 1\n        arr[z] = ch\n    print(arr[1])"]
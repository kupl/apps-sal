["import sys\nimport math\nimport bisect\nimport heapq\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "# coding: utf-8\n# hello world\u3068\u8868\u793a\u3059\u308b\n#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\n#def MXI(): return [LI() for i in range(n)]\u3000\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\ns=SI()\nt=SI()\na=len(s)\nb=len(t)\n#\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u304b\u3089\u6570\u5b57\u3078\u3068\u5909\u63db\u3059\u308b\u8f9e\u66f8\nalphasm=[chr(i) for i in range(97, 97+26)]\nalphadic={}\nfor i in range(26):\n    alphadic[alphasm[i]]=i\nstrlis=[[] for i in range(26)]\n#print(alphadic)\n#print(strlis)\nfor i in range(a):\n    strlis[alphadic[s[i]]].append(i)\n#print(strlis)\nrd=0\npos=-1\n#print(strlis[a])\ni=0\nwhile i<b:\n    if len(strlis[alphadic[t[i]]])==0:\n        print((-1))\n        return\n        #print(\"a\")\n    if pos==-1:\n        pos=strlis[alphadic[t[i]]][0]\n        i+=1\n        #print(\"b\")\n    elif strlis[alphadic[t[i]]][-1]<=pos:\n        rd+=1\n        pos=-1\n        #print(\"c\")\n    else:\n        pos=strlis[alphadic[t[i]]][bisect_right(strlis[alphadic[t[i]]],pos)]\n        i+=1\n        #print(\"d\")\n    #print(rd,pos)\nprint((rd*a+pos+1))\n\n\n    \n        \n#\u73fe\u5728\u306e\u5468\u56de\u6570\u3001\u4f55\u500b\u76ee\u304b\u306e\u60c5\u5831\u3092\u6301\u3063\u3066\u304a\u304f\n#\u6b21\u306e\u5468\u56de\u306b\u884c\u304f\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a \u884c\u304b\u306a\u3044\u306a\u3089\u4e8c\u5206\u63a2\u7d22\n\n\n\n\n            \n    \n", "3\n# -*- coding:utf-8 -*-\n\nfrom collections import defaultdict\nimport bisect\n\ndef main():\n  s = input().strip()\n  t = input().strip()\n  ns = len(s)\n  \n  if len(set(list(t)) - set(list(s))):\n    print((-1))\n    return\n  \n  ichs = defaultdict(list)  \n  for i, c in enumerate(s):\n    ichs[c].append(i)\n    \n  ic = -1\n  cnt = 0\n  for c in t:\n    ix = bisect.bisect_right(ichs[c], ic)\n    \n    if ix >= len(ichs[c]):\n      cnt += 1\n      ix = 0\n    else:\n      if ic == ichs[c][ix]:\n        if ix + 1 >= len(ichs[c]):\n          cnt += 1\n          ix = 0\n        else:\n          ix += 1\n    ic = ichs[c][ix]\n  print((cnt*ns + ic + 1))\n    \n      \n    \n  \n\ndef __starting_point():\n  main()\n\n\n__starting_point()", "def solve():\n    import bisect\n    S = input()\n    T = input()\n    dic = {}\n    length = {}\n\n    for i, s in enumerate(S, 1):\n        if s not in dic:\n            dic[s] = []\n        dic[s].append(i)\n\n    for k, v in list(dic.items()):\n        if k not in length:\n            length[k] = 0\n        length[k] = len(v)\n\n    l, turn, prov = len(S), 0, 0\n\n    for t in T:\n        if t not in dic:\n            print((-1))\n            return\n        x = bisect.bisect(dic[t], prov)\n        if x < length[t]:\n            prov = dic[t][x]\n        else:\n            turn += 1\n            prov = dic[t][0]\n    print((turn * l + prov))\n\nsolve()\n\n", "def main():\n  s = str(input())\n  s_ = set(list(s))\n  t =  str(input())\n  t_ =  set(list(t))\n  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  if t_ <= s_:\n    length_s = len(s)\n    \n    res = [[length_s]*(26)  for _ in range(length_s+1)]\n    for i in range(length_s-1, -1, -1):\n      for j in range(26):\n        if s[i] == alphabet[j]:\n          res[i][j] = i+1\n        else:\n          res[i][j] = res[i+1][j]\n    ans = 0\n    now = 0\n    for i in range(len(t)):\n      for j in range(26):\n        if t[i] == alphabet[j]:\n          ans += res[now][j]-now\n          now = res[now][j]\n          if now == length_s:\n            if t[i] == s[-1]:\n              now = 0\n            else:\n              ans += res[0][j]\n              now = res[0][j]\n    print(ans)\n  else:\n    print(-1)\nif  __name__  == \"__main__\":\n  main()", "S = input()\nT = input()\n\nn = len(S)\n\nal = [chr(c) for c in range(ord(\"a\"), ord(\"a\")+26)]\nx = {a: [] for a in al}\n\nfor i in range(len(S)):\n    for a in al:\n        if a == S[i]:\n            x[a].append(i)\n\ndef is_ok(arg):\n    # \u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\uff1f\u554f\u984c\u3054\u3068\u306b\u5b9a\u7fa9\n    if x[t][arg]+c*n > i:\n        return True\n    return False\n\n\ndef meguru_bisect(ng, ok):\n    '''\n    \u521d\u671f\u5024\u306eng,ok\u3092\u53d7\u3051\u53d6\u308a,is_ok\u3092\u6e80\u305f\u3059\u6700\u5c0f(\u6700\u5927)\u306eok\u3092\u8fd4\u3059\n    \u307e\u305ais_ok\u3092\u5b9a\u7fa9\u3059\u3079\u3057\n    ng ok \u306f  \u3068\u308a\u5f97\u308b\u6700\u5c0f\u306e\u5024-1 \u3068\u308a\u5f97\u308b\u6700\u5927\u306e\u5024+1\n    \u6700\u5927\u6700\u5c0f\u304c\u9006\u306e\u5834\u5408\u306f\u3088\u3057\u306a\u306b\u3072\u3063\u304f\u308a\u8fd4\u3059\n    '''\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) // 2\n        if is_ok(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ni = -1\nc = 0\nfor t in T:\n    if not x[t]:\n        print(-1)\n        break\n    if x[t][-1]+c*n <= i:\n        c += 1\n    i = x[t][meguru_bisect(-1, len(x[t])-1)]+c*n\n\nelse:\n    print(i+1)", "from collections import defaultdict\nfrom bisect import *\n\ns,t = input(),input()\nbefore,count = len(s),0\nidx = defaultdict(list)\n\nif not set(t) <= set(s):\n  print(\"-1\")\n  return\n\nfor i,l in enumerate(s):\n  idx[l] += [i]\n  \nfor c in t:\n  N = idx[c]\n  index = bisect_left(N, before)\n  if index > len(N) - 1:\n    before = N[0] + 1\n    count += 1\n  else:\n    before = N[index] + 1\n    \nprint((count - 1) * len(s) + before)", "import bisect\ns=input()\nt=input()\ndic={}\nfor i in range(len(t)):\n  if t[i] in dic:\n    continue\n  if t[i] not in dic:\n    dic[t[i]]=[]\nfor i in range(len(s)):\n  if s[i] in dic:\n    dic[s[i]].append(i)\nfor k,v in dic.items():\n  if v==[]:\n    print(-1)\n    return\nn=-1\nk=0\n\nfor i in range(len(t)):\n  l=bisect.bisect_right(dic[t[i]],n)\n  if l<len(dic[t[i]]):\n    n=dic[t[i]][l]\n  else:\n    n=dic[t[i]][0]\n    k+=1\nprint(len(s)*k+n+1)", "def f():\n    s,t=input(),input()\n    n,m=len(s),len(t)\n    table=[[]for i in  range(26)]\n    d={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n\n    for j in range(n):\n        table[d[s[j]]].append(j)\n    now=0\n    ind=0\n    if set(list(t))-set(list(s)):print(-1);return\n    from bisect import bisect_left as bl\n    for p in t:\n        if ind>table[d[p]][-1]:now+=1;ind=0\n        ind=table[d[p]][bl(table[d[p]],ind)]+1\n\n    print(now*n+ind)\ndef __starting_point():\n    f()\n__starting_point()", "import heapq\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "s=input()\nt=input()\nds={}\nfor i in range(len(s)):\n  if s[i] in ds:\n    ds[s[i]].append(i+1)\n  else:\n    ds[s[i]]=[i+1]\nn=len(s)\nnow=0 # mod n\nans=0\nfrom bisect import bisect_right\nfor ti in t:\n  if ti not in ds:\n    print((-1))\n    return\n  tmp=bisect_right(ds[ti],now)\n  if tmp==len(ds[ti]):\n    get=n+ds[ti][0]\n  else:\n    get=ds[ti][tmp]\n  ans+=get-now\n  #print(now,get)\n  now=(get)%n\nprint(ans)\n#print(ds)\n", "def main():\n    from bisect import bisect_left\n\n    S = input()\n    T = input()\n\n    L = len(S)\n\n    pos = tuple(list() for _ in range(26))\n    orda = ord('a')\n    for i, c in enumerate(S):\n        j = ord(c) - orda\n        pos[j].append(i)\n\n    rep = 0\n    curr = 0\n    for c in T:\n        j = ord(c) - orda\n\n        if not pos[j]:\n            print((-1))\n            return\n\n        i = bisect_left(pos[j], curr)\n        if i == len(pos[j]):\n            rep += 1\n            i = 0  # pos[j][0]\u6587\u5b57\u76ee\u304cc\n        curr = pos[j][i] + 1  # pos[j][i]\u306b\u3057\u305f\u3089\u540c\u3058\u6587\u5b57\u304c\u7d9a\u304f\u30b1\u30fc\u30b9\u3067WA\n\n    print((rep * L + curr))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\nfrom bisect import bisect_left\n\n\ndef solve(s, t):\n    dd = defaultdict(list)\n    for i, c in enumerate(s):\n        dd[c].append(i)\n    inv = 0\n    index = 0\n    for c in t:\n        x = bisect_left(dd[c], index)\n        if x == len(dd[c]):\n            inv += 1\n            if not dd[c]:\n                return -1\n            index = dd[c][0] + 1\n        else:\n            index = dd[c][x] + 1\n    return len(s) * inv + index\n\n\ndef main():\n    s = input()\n    t = input()\n    print((solve(s, t)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\n\ns = input()\nt = input()\nn = len(s)\ns0 = {}\nfor i in range(n):\n    s0.setdefault(s[i], [])\n    s0[s[i]].append(i)\nnum1 = 0\nnum2 = -1\nflag = True\nfor i in t:\n    if i not in s:\n        flag = False\n        break\n    num = bisect.bisect_right(s0[i], num2)\n    if num == len(s0[i]):\n        num1 += 1\n        num2 = s0[i][0]\n    else:\n        num2 = s0[i][num]\nif flag == True:\n    print(num1 * n + num2 + 1)\nelse:\n    print(-1)", "import sys\nimport math\nimport heapq\nimport bisect\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nS = input().rstrip()\nT = input().rstrip()\n\n# set:T \u304c set:S \u306b\u542b\u307e\u308c\u306a\u3044 => S \u306b\u306a\u3044\u6587\u5b57\u3092 T \u3067\u4f7f\u3063\u3066\u3044\u305f\u3089\nif not set(T) <= set(S):\n    print((-1))\n    return\n\nind = -1\ncnt = 0\nfor t in T:\n    # \u73fe\u5728\u306e index \u4ee5\u964d\u304b\u3089\u63a2\u7d22\u3059\u308b\n    ind = S.find(t,ind+1)\n    # \u898b\u3064\u304b\u3089\u306a\u3044\u5834\u5408\u306f\u5148\u982d\u304b\u3089\u63a2\u7d22\u3057\u76f4\u3057, loop count\u3092+1\n    if ind == -1:\n        cnt += 1\n        ind = S.find(t)\n\nprint((len(S) * cnt + ind + 1))\n", "from bisect import bisect_left\n\n\nS = input()\nT = input()\nif any(c not in S for c in T):\n    print((-1))\n    return\n\nN = len(S)\npos = {c: [] for c in \"abcdefghijklmnopqrstuvwxyz\"}\nfor i in range(N):\n    pos[S[i]].append(i)\n\nloop = 0\ncur = 0\nfor c in T:\n    nxt = bisect_left(pos[c], cur)\n    if nxt == len(pos[c]):\n        loop += 1\n        cur = pos[c][0] + 1\n    else:\n        cur = pos[c][nxt] + 1\nprint((loop * N + cur))\n", "from bisect import bisect_right\n\ns = input()\nt = input()\n\nn = len(s)\n\nmp = [[] for _ in range(26)]\ns += s\nfor i in range(len(s)):\n    mp[ord(s[i]) - ord('a')].append(i)\n\nans = 0\nnow = -1\nfor i in range(len(t)):\n    a = ord(t[i]) - ord('a')\n    nxt = bisect_right(mp[a], now)\n    if len(mp[a]) == nxt:\n        print((-1))\n        return\n\n    ans += mp[a][nxt] - now\n    now = mp[a][nxt]\n    if now >= n:\n        now -= n\n\nprint(ans)\n", "from collections import defaultdict\nfrom bisect import bisect\n\ns = input()\nS = len(s)\nt = input()\nT = len(t)\nD = defaultdict(list)\nDc = defaultdict(int)\nExists = True\n\nfor i in range(S):\n  D[s[i]].append(i+1)\n  Dc[s[i]] += 1\n\nans = 0\ntemp = 0\nfor i in range(T):\n  if D[t[i]] == []:\n    Exists = False\n    break\n  j = bisect(D[t[i]], temp)\n  if j == Dc[t[i]]:\n    ans += S - temp + D[t[i]][0]\n    temp = D[t[i]][0]\n  else:\n    ans += D[t[i]][j] - temp\n    temp = D[t[i]][j]\n\nif Exists:\n  print(ans)\nelse:\n  print(-1)", "s,t=input(),input()\nif not set(list(t)) <=set (list(s)):print(-1);return\nss=[[]for i in range(26)]\nfor i,v in enumerate(s):ss[ord(v)-97].append(i)\nnowind,loop=-1,0\nfrom bisect import bisect_left as bl,bisect_right as br\nfor i in t:\n    ind=ord(i)-97\n    if ss[ind][-1]<nowind:\n        nowind=-1\n        loop+=1\n    nowind=ss[ind][bl(ss[ind],nowind)]+1\nprint(loop*len(s)+nowind)", "import bisect\nS = input()\nT = input()\nD = dict()\nfor i in range(len(T)):\n    if T[i] in D:\n        continue\n    else:\n        D[T[i]] = []\nfor i in range(len(S)):\n    if S[i] in D:\n        D[S[i]].append(i)\n\nif len(set(T)-set(S))>0:\n    print(-1)\nelse:\n    r = -1\n    cnt = 0\n    for i in range(len(T)):\n        m = bisect.bisect_right(D[T[i]], r)\n        if m < len(D[T[i]]):\n            r = D[T[i]][m]\n        else:\n            r = D[T[i]][0]\n            cnt += 1\n    print(len(S)*cnt+r+1)", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(s: str, t: str):\n    \"\"\"\n    >>> solve(\"aaa\", \"aaa\")\n    3\n    >>> solve(\"a\", \"a\")\n    1\n    >>> solve(\"contest\", \"son\")\n    10\n    \"\"\"\n    from collections import defaultdict\n    from bisect import bisect\n    d = defaultdict(list)\n    for i, c in enumerate(s):\n        d[c].append(i)\n    ans, i = 0, -1\n    for c in t:\n        #print(ans, i, end=\" \")\n        if not d[c]:\n            return -1\n        j = bisect(d[c], i)\n        if len(d[c]) == j:\n            ans += len(s) - i + d[c][0]\n            i = d[c][0]\n        else:\n            ans += d[c][j] - i\n            i = d[c][j]\n        #print(\"->\", ans, i)\n    return ans\n\n# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    s = next(tokens)  # type: str\n    t = next(tokens)  # type: str\n    print((solve(s, t)))\n\n     \ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    test()\n    main()\n\n__starting_point()", "from string import ascii_lowercase\nfrom bisect import bisect_right, bisect_left\n\n\ndef main():\n    s = input()\n    t = input()\n    len_s = len(s)\n    s_all = {s: [] for s in ascii_lowercase}\n    for i in range(len_s):\n        s_all[s[i]].append(i + 1)\n    ans = 0\n    if any(s_all[tt] == [] for tt in t):\n        ans = -1\n    else:\n        s_ind = 1\n        for ss in ascii_lowercase:\n            s_all[ss].sort()\n        for i in range(len(t)):\n            next_ind = bisect_left(s_all[t[i]], s_ind)\n            if next_ind == len(s_all[t[i]]):\n                ans += len_s - s_ind + 1\n                ans += s_all[t[i]][0]\n                s_ind = s_all[t[i]][0] + 1\n            else:\n                ans += s_all[t[i]][next_ind] - s_ind + 1\n                s_ind = s_all[t[i]][next_ind] + 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_right\ns = input()\nt = input()\nalpha = [[] for _ in range(26)]\ndef f(c): return ord(c)-ord(\"a\")\n\n\nfor i,c in enumerate(s): alpha[f(c)].append(i)\n# print(alpha)\nidx = -1\nroop = 0\nfor c in t:\n    lst = alpha[f(c)]\n    if not lst:\n        ans = -1\n        break\n    i = bisect_right(lst,idx)\n    if i == len(lst):\n        roop += 1\n        idx = lst[0]\n    else:\n        idx = lst[i]\nelse:\n    ans = len(s)*roop+idx+1\nprint(ans)", "import sys\nsys.setrecursionlimit(200000)\nfrom collections import Counter, defaultdict\nfrom bisect import bisect_left\n\n\ndef read():\n    S = input().strip()\n    T = input().strip()\n    return S, T\n\n\ndef have_ahswer(S, T):\n    cs = Counter(S)\n    ct = Counter(T)\n    for k in list(ct.keys()):\n        if cs[k] == 0:\n            return False\n    return True\n\n\ndef solve(S, T):\n    Z = \"abcdefghijklmnopqrstuvwxyz\"\n    if not have_ahswer(S, T):\n        return -1\n    D = defaultdict(list)\n    for i, s in enumerate(S):\n        D[s].append(i)\n    ans = 0\n    prev_index = -1\n    N = len(S)\n    for t in T:\n        a = D[t]\n        i = bisect_left(a, prev_index + 1)\n        if i < len(a):\n            next_index = a[i]\n            ans += next_index - prev_index\n        else:\n            next_index = a[0]\n            ans += N + next_index - prev_index\n        prev_index = next_index\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    print((\"{}\".format(solve(*inputs))))\n\n__starting_point()", "import bisect\n\nen2asc = lambda s: ord(s) - 97\n\nS = input()\nT = input()\nif not set(S) >= set(T):\n    print(-1)\n    return\n\nlst = [[] for _ in range(26)]\nfor i, s in enumerate(S):\n    lst[en2asc(s)].append(i)\n\nL = len(S)\ncur = 0\nfor t in T:\n    t = en2asc(t)\n    b = bisect.bisect_left(lst[t], cur % L)\n    if b == len(lst[t]):\n        cur = (cur // L + 1) * L\n        b = bisect.bisect_left(lst[t], cur % L)\n    cur = cur // L * L + lst[t][b] + 1\nprint(cur)", "import sys\nimport math\nimport bisect\nimport heapq\nfrom collections import defaultdict\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "from collections import defaultdict\nfrom bisect import bisect_left\ns = input()\nt = input()\nids = defaultdict(list)\nfor i, c in enumerate(s):\n    ids[c].append(i)\ni = 0\nans = 0\nfor c in t:\n    if c not in ids:\n        print(-1)\n        return\n    ls = ids[c]\n    j = bisect_left(ls, i)\n    if j == len(ls):\n        ans += len(s)\n        i = ls[0]+1\n    else:\n        i = ls[j]+1\nprint(ans+i)", "\"\"\"\nT\u306e\u6587\u5b57\u306b\u305f\u3044\u3057\u3066\u3001S\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u30ea\u30b9\u30c8\u3067\u6301\u305f\u305b\u308b\nT\u306e\u982d\u304b\u3089\u9806\u7e70\u308a\u306b\u305f\u3057\u4e0a\u3052\u3066\u3044\u304f\uff08Loop\u6570\u3092\u6570\u3048\u308b\u3053\u3068\uff09\n\u81ea\u5206\u3088\u308a\u3082\u5927\u304d\u3044\u8981\u7d20\u304c\u3042\u308c\u3070\u3001\u305d\u308c\u3092\u4f7f\u3046\u3057\u3001\n\u306a\u3051\u308c\u3070\u6700\u3082\u5c0f\u3055\u3044\u8981\u7d20\u3092\u4f7f\u3044\u3064\u3064\u3001Loop\u6570\u3092CountUp\nbisect_left()\u304b\u306a\uff1f\n\n0123456\ncontest\n\n01234567\nsentence\n\ns=[5]   -> 5  (6moji)\ne=[4]   -> 7*1+4 (12moji)\nn=[2]   -> 7*2+2 = 16\nt=[3,6] -> 7*2+3 = 17\ne=[4]   -> 7*2+4 = 18\nn=[2]   -> 7*3+2 = 23\nc=[0]   -> 7*4+0 = 28\ne=[4]   -> 7*4+4 = 32 ( 33moji)\n\"\"\"\n\nfrom bisect import bisect_right, bisect_left\nS = input()\nT = input()\n\ndef calc(ch):\n  return ord(ch) - ord('a')\n\n## T\u306b\u542b\u307e\u308c\u308b\u6587\u5b57\u306b\u5bfe\u3057\u3001S\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u3075\u308b\nLST = [[] for _ in range(26)]\nfor t in T:\n  nt = calc(t)\n  if len(LST[nt]) > 0:\n    continue\n  for i in range(len(S)):\n    if t == S[i]:\n      LST[nt].append(i)\n  if len(LST[nt]) == 0:\n    print(-1)\n    return\n    \nNS = len(S)\n## T\u306e\u6587\u5b57\u306b\u5bfe\u3057\u3066\u9806\u7e70\u308a\u306b\u305f\u3057\u3042\u3052\u308b\nNofLoop = 0\nnow = 0\nfor i in range(len(T)):\n  t = T[i]\n  nt = calc(t)\n  rel_now = now - NofLoop * NS\n  if rel_now < LST[nt][0] :\n    #print(\"R\",t,nt,rel_now)\n    now = NofLoop * NS + LST[nt][0] + 1\n  elif LST[nt][-1] < rel_now :\n    #print(t,i)\n    NofLoop += 1\n    now = NofLoop * NS + LST[nt][0] + 1\n  else:\n    idx = bisect_left(LST[nt], rel_now)\n    #print(idx)\n    now = NofLoop * NS + LST[nt][idx] + 1\n    \nprint(now)", "s = input()\nt = input()\nif set(t) & set(s) == set(t):\n    n = -1\n    c = 0\n    for i in t:\n        n = s.find(i, n + 1)\n        if n == -1:\n            c += 1\n            n = s.find(i)\n    print(n + len(s) * c + 1)\nelse:\n    print(-1)", "import sys\nimport math\nfrom collections import deque\nimport bisect\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef main():\n    S = SI()\n    T = SI()\n    if set(S) | set(T) != set(S):\n        print(-1)\n        return\n    s2i = {}\n\n    for i, s in enumerate(S):\n        if s in s2i:\n            s2i[s].append(i)\n        else:\n            s2i[s] = [i]\n\n    now = 0\n    digit = -1\n    for t in T:\n        target = bisect.bisect_right(s2i[t], digit)\n        if target == len(s2i[t]):\n            digit = s2i[t][0]\n            now += 1\n        else:\n            digit = s2i[t][target]\n\n    print(now * len(S) + digit + 1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import bisect\nfrom collections import defaultdict\n\ns = input()\nt = input()\nif set(s) & set(t) != set(t):\n    print((-1))\n    return\ncnt = defaultdict(list)\nfor i, c in enumerate(s, 1):\n    cnt[c].append(i)\nloop = 0\nprev = 0\nfor w in t:\n    l = cnt[w]\n    idx = bisect.bisect_right(l, prev)\n    if idx < len(l):\n        prev = l[idx]\n    else:\n        prev = l[0]\n        loop += 1\nans = loop*len(s) + prev\nprint(ans)\n", "from bisect import bisect_left\n\nS = input()\nT = input()\n\nss = set(list(S))\nst = set(list(T))\nif not (st <= ss):\n    print((-1))\n    return\nalpha = {chr(97+i): [] for i in range(26)}\nfor i, s in enumerate(S):\n    alpha[s].append(i+1)\nn = len(S)\nnow = 0\nans = 0\nfor t in T:\n    if alpha[t][-1] <= now:\n        ans += (n - now) + alpha[t][0]\n        now = alpha[t][0]\n    else:\n        i = bisect_left(alpha[t], now+1)\n        ans += alpha[t][i] - now\n        now = alpha[t][i]\nprint(ans)\n", "s = input()\nt = input()\nn = len(s)\ns += s\n# pos[i][j] := \u5834\u6240i\u306e\u6b21\u306b\u73fe\u308c\u308b\u6700\u3082\u8fd1\u3044j(\u6587\u5b57)\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\npos = [[-1] * 26 for _ in range(n * 2 + 1)]\nfor i in range(n * 2 - 1, -1, -1):\n    k = ord(s[i]) - ord('a')\n    for j in range(26):\n        if j == k:\n            pos[i][j] = i\n        else:\n            pos[i][j] = pos[i + 1][j]\n\nans = 0\nnow = 0\nfor c in t:\n    x = ord(c) - ord('a')\n    if pos[now][x] == -1:\n        print((-1))\n        return\n    ans += -~pos[now][x] - now\n    now = -~pos[now][x] % n\nprint(ans)\n", "from bisect import bisect_right\ns = input()\nt = input()\nalpha = [[] for _ in range(26)]\ndef f(c): return ord(c)-ord(\"a\")\n\nfor i,c in enumerate(s): alpha[f(c)].append(i)\nidx = -1\nloop = 0\nfor c in t:\n    lst = alpha[f(c)]\n    if not lst:\n        ans = -1\n        break\n    i = bisect_right(lst,idx)\n    if i == len(lst):\n        loop += 1\n        idx = lst[0]\n    else:\n        idx = lst[i]\nelse:\n    ans = len(s)*loop+idx+1\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nS = readline().rstrip()\nT = readline().rstrip()\n\nif len(set(T) - set(S)) > 0:\n  print(-1)\n  return\n  \nimport bisect\nS2 = S * 2\nfrom collections import defaultdict\ndic = defaultdict(list)\n\nfor i in range(len(S2)):\n  dic[S2[i]] += [i]\n\nind = -1\nans = 0\nfor t in T:\n  targets = dic[t]\n  newind = targets[bisect.bisect_left(targets, ind + 1)]\n  ans += (newind - ind)\n  if newind >= len(S):\n    newind -= len(S)\n  ind = newind\n\nprint(ans)", "import math\nimport heapq\nimport bisect\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "from bisect import bisect_left\n\n\ndef solve():\n    S = input()\n    T = input()\n    if not set(T) <= set(S):\n        return -1\n\n    pos = {c: [] for c in \"abcdefghijklmnopqrstuvwxyz\"}\n    for i, c in enumerate(S):\n        pos[c].append(i)\n    ans = 0\n    cur_pos = 0\n    for t in T:\n        nxt_idx = bisect_left(pos[t], cur_pos)\n        if nxt_idx == len(pos[t]):\n            ans += len(S)\n            cur_pos = 0\n            nxt_idx = bisect_left(pos[t], cur_pos)\n            cur_pos = pos[t][nxt_idx] + 1\n        else:\n            cur_pos = pos[t][nxt_idx] + 1\n\n    return ans + cur_pos\n\n\nprint((solve()))\n", "import sys\nfrom collections import defaultdict\nfrom bisect import bisect_right\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    S = input()\n    n = len(S)\n    T = input()\n\n    pos = defaultdict(list)\n    for i in range(n):\n        pos[S[i]].append(i + 1)\n\n    res = 0\n    now = 0\n    for t in T:\n        if pos.get(t, -1) == -1:\n            print((-1))\n            return\n        idx = bisect_right(pos[t], now)\n        if len(pos[t]) == idx:\n            res += n - now + pos[t][0]\n            now = pos[t][0]\n        else:\n            res += pos[t][idx] - now\n            now = pos[t][idx]\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from bisect import bisect_left\nfrom string import ascii_lowercase\n\ns = input()\nt = input()\nn = len(s)\n\ndict_s = {c: [] for c in ascii_lowercase}\nfor i, c in enumerate(s * 2):\n    dict_s[c].append(i)\n\nfor c in ascii_lowercase:\n    if not dict_s[c]:\n        del dict_s[c]\n\n\ndict_next_i = {\n    c: [dict_s[c][bisect_left(dict_s[c], i + 1)] for i in range(n)]\n    for c in list(dict_s.keys())\n}\n\n\ndef next_i(i, c):\n    return n * (i // n) + dict_next_i[c][i % n]\n\n\ndef answer():\n    if not all(c in s for c in t):\n        return -1\n    i = -1\n    for c in t:\n        i = next_i(i, c)\n    return i + 1  # 1-origin\n\n\nprint((answer()))\n", "#!/usr/bin/env python3\n \nimport sys\n# \u4ee5\u4e0b\u3092\u8a18\u8ff0\u3057\u306a\u3044\u3068TLE\u306b\u306a\u308b, \u4f55\u6545\uff1f\nfrom heapq import heappushpop, heapify, heapreplace\nfrom collections import defaultdict\n# ---- \u3053\u3053\u307e\u3067 -----------------------\n \nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n \nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n \nprint(ans)", "from bisect import bisect_left,bisect\ns = list(input())\nsn = len(s)\nt = list(input())\ntn = len(t)\nkouho = []\nfor i in range(26):\n    kar = []\n    now = chr(ord('a') + i)\n    for j in range(sn):\n        if s[j] == now:\n            kar.append(j)\n    kouho.append(kar)\n\ncou = 0\nnow = -1\nfor i in range(tn):\n    u = ord(t[i])-ord(\"a\")\n    if kouho[u]:\n        tugi = bisect(kouho[u],now)\n        if tugi == len(kouho[u]):\n            cou += 1\n            now = kouho[u][0]\n        else:\n            now = kouho[u][tugi]\n    else:\n        print(-1)\n        return\n\nprint(cou*sn + now + 1)", "import bisect\n\ns = input()\nt = input()\nn = len(s)\ns += s\n\npos = [[] for _ in range(26)]\n\nfor i in range(len(s)):\n    pos[ord(s[i]) - ord('a')].append(i)\n\nans = 0\nnow = -1\nfor i in range(len(t)):\n    c = ord(t[i]) - ord('a')\n    j = bisect.bisect_right(pos[c], now)\n\n    if j == len(pos[c]):\n        print((-1))\n        return\n    now = pos[c][j]\n\n    if now >= n:\n        now -= n\n        ans += n\nprint((ans + now + 1))\n", "from bisect import bisect_left as bisect\nfrom collections import defaultdict\n\n\ns, t = input(), input()\nlens, sets = len(s), set(s)\n\nif not all(i in sets for i in t):\n    print((-1))\n    return\n\nalp = defaultdict(list)\nfor i, si in enumerate(s):\n    alp[si].append(i)\n\nans, cnt = 1 - lens, 0\nfor i in t:\n    ans += lens * (cnt == 0)\n    num = bisect(alp[i], cnt)\n    ans += lens * (num == len(alp[i]))\n    cnt = (alp[i][num % len(alp[i])] + 1) % lens \nprint((ans + (cnt - 1) % lens))\n", "from collections import defaultdict\nimport bisect\ns, t = [x.strip() for x in open(0).readlines()]\nif set(t) - set(s) != set():\n    print(-1)\nelse:\n    d = defaultdict(list)\n    n = len(s)\n    for i, c in enumerate(s, 1):\n        d[c].append(i)\n    for k in d:\n        d[k].append(d[k][0] + n)\n    ans = 0\n    for c in t:\n        q, r = divmod(ans, n)\n        x = d[c][bisect.bisect(d[c], r)]\n        ans = n*q + x\n    print(ans)", "from collections import defaultdict\nimport bisect\ndef solve():\n    s = input()\n    t = input()\n    d = defaultdict(list)\n    st_s = set(s)\n\n    for i in range(len(s)):\n        d[s[i]].append(i)\n    \n    round = 0\n    prev = -1\n    for i in range(len(t)):\n        if not t[i] in st_s:\n            print(-1)\n            return\n        now = getNextIdx(prev,d[t[i]])\n        if now <= prev:\n            round += 1\n        \n        prev = now\n    \n    print(prev + round*len(s) + 1)\n\ndef getNextIdx(prev,idx_list):\n    ret_idx = bisect.bisect_right(idx_list, prev)\n    if ret_idx == len(idx_list):\n        return idx_list[0]\n\n    return idx_list[ret_idx]\n\ndef __starting_point():\n    solve()\n__starting_point()", "s = input()\nt = input()\nl_s = len(s)\nl_t = len(t)\n\ns2 = s + s\nl_s2 = len(s2)\n\nnext_idx = [[l_s2] * 26 for i in range(l_s2)]\n\nfor i in reversed(range(1, l_s2)):\n    for j in range(26):\n        next_idx[i-1][j] = next_idx[i][j]\n    next_idx[i-1][ord(s2[i]) - ord(\"a\")] = i\n\ncur_idx = 0\nfor i in range(l_t):\n    if i == 0:\n        flg = False\n        for j in range(l_s):\n            if t[i] == s[j]:\n                cur_idx += j\n                flg = True\n                break\n        if flg:\n            continue\n        else:\n            print(\"-1\")\n            return\n\n    else:\n        idx = next_idx[cur_idx%l_s][ord(t[i]) - ord(\"a\")]\n\n    if idx == l_s2:\n        print(\"-1\")\n        return\n\n    cur_idx += idx - (cur_idx % l_s)\n    \nprint(cur_idx+1)", "import bisect\n\ns=input()\nt=input()\nn=len(s)*2\n\ndic={}\nfor idx,i in enumerate(s*2):\n  if i in dic.keys():\n    dic[i].append(idx)\n  else:\n    dic[i]=[idx]\n\n#print(dic)\n    \nans=k=0\nbefore='-1'\nfor i in t:\n  if i not in dic.keys():\n    print(-1)\n    return\n  t=bisect.bisect_left(dic[i], ans%n)\n  if before==i:\n    t+=1\n  if len(dic[i])==t:\n    t=0\n    k+=n\n  ans=dic[i][t]+k\n  before=i\n  \nprint(ans+1)", "from collections import Counter, defaultdict\nfrom bisect import bisect_right\n\ns = input()\nt = input()\n\nc = Counter(s)\nfor e in t:\n    if c[e] == 0:\n        print((-1))\n        return\n\nss = s + s\nd = defaultdict(list)\nfor i, e in enumerate(ss):\n    d[e].append(i)\n\nnow = -1\nans = 0\nfor e in t:\n    i = bisect_right(d[e], now)\n    nxt = d[e][i]\n    ans += nxt - now\n    now = nxt % len(s)\n\nprint(ans)\n", "def solve():\n  s = input()\n  t = input()\n  ans = 0\n  alp = [[] for _ in range(27)]\n  length_s = len(s)\n  for i in range(length_s):\n    char = ord(s[i]) - ord('a')\n    alp[char].append(i + 1)\n  length_t = len(t)\n  import bisect\n  for i in range(length_t):\n    char = ord(t[i]) - ord('a')\n    if alp[char]:\n      if ans % length_s >= alp[char][-1]:\n        ans = (ans // length_s + 1) * length_s\n      index = bisect.bisect_right(alp[char], ans % length_s)\n      ans += alp[char][index] - ans % length_s\n    else:\n      return -1\n  return ans\nprint(solve())", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque\nfrom collections import defaultdict\nimport heapq\nimport collections\nimport itertools\nimport bisect\nimport copy\nimport math\nsys.setrecursionlimit(10**6)\n\n# lis_of_lis = [[] for _ in range(N)]\n\n\ndef zz(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef z(): return int(sys.stdin.readline())\n\n\ndef S(): return sys.stdin.readline()[:-1]\n\n\ndef C(line): return [sys.stdin.readline() for _ in range(line)]\n\n\ns = S()\nt = S()\nset_s = set(s)\nset_t = set(t)\nif (set_t <= set_s) is False:\n    print((-1))\n    return\nalphabet2index = defaultdict(list)\nfor i, alphabet in enumerate(s):\n    alphabet2index[alphabet].append(i+1)\nans = 0\npos = 0\nprev_pos = 0\nbase = 0\nn = -1\nc = 0\nfor _t in t:\n    n = s.find(_t, n+1)\n    if (n == -1):\n        c += 1\n        n = s.find(_t)\nans = n + c*len(s) + 1\n\"\"\"\n\n    ng_flg = True\n    while ng_flg:\n        pos_lis = alphabet2index[_t]\n        i = 0\n        while len(pos_lis) > i:\n            if (pos_lis[i] >= pos):\n                pos = pos_lis[i]\n                ans += (pos_lis[i]-prev_pos)\n                # print(pos_lis[i], prev_pos, )\n                prev_pos = pos\n                ng_flg = False\n                break\n            i += 1\n        else:\n            prev_pos = pos - len(s)\n            # print(prev_pos)\n            # print('base', base)\n            pos = 0\n    \"\"\"\nprint(ans)\n", "import collections,math\ns = input()\nt = input()\n#t\u3092\u69cb\u6210\u6587\u5b57\u3067\u3001s\u306b\u306a\u3044\u6587\u5b57\u304c\u3042\u3063\u305f\u3089\u30c0\u30e1\u3002\n#\u69cb\u6210\u3067\u304d\u308b\u306a\u3089\u6700\u5927\u3067\u3082len(t)\u500b\u3057\u304b\u306a\u3044\u304b\u3089\u300110^100\u306e\u9023\u7d50\u306f\u5fc5\u8981\u306a\u3044\n\n#\u6700\u3082\u4e0d\u8db3\u3059\u308b\u6587\u5b57\u3092\u63a2\u3059\nls = collections.Counter(s)\nlt = collections.Counter(t)\n\ntime_dict ={}\ntmp=0\nmax_time=0#\u4e00\u756a\u5c11\u306a\u3044\u3084\u3064\nfor t_key,t_val in list(lt.items()):\n    if t_key not in ls:#s\u306e\u4e2d\u306bt\u306e\u6587\u5b57\u304c\u306a\u3044\n        print((-1))\n        return\n\n#\u591a\u5206TLE\u3059\u308b\u304b\u3082\u3002\u3002\ncnt = 0\ntt = list(t[::-1])\nidx=0\nss = s\nwhile tt!=[]:\n    next_t = tt.pop()\n    idx=ss.find(next_t)\n    if idx == -1:\n        cnt += len(ss)\n        idx = s.find(next_t)\n        ss = s[idx+1:]\n        cnt += idx+1\n    else:\n        cnt += idx+1\n        ss = ss[idx+1:]\nprint(cnt)\n", "from bisect import bisect_left\nfrom string import ascii_lowercase\n\n\ndef main():\n    s = input()\n    t = input()\n\n    set_s = set(tuple(s))\n    set_t = set(tuple(t))\n\n    if not(set_t <= set_s):\n        print(-1)\n        return\n\n    ans = 0\n    d = {c:[] for c in ascii_lowercase}\n    \n    for i, c in enumerate(s):\n        d[c].append(i+1)\n    \n    now = 0\n    for c in t:\n        \n        idx = bisect_left(d[c], now+1)\n\n        if idx == len(d[c]):\n            ans += len(s)\n            now = 0\n            idx = bisect_left(d[c], now+1)\n            \n        now = d[c][idx]\n\n    ans += now\n    print(ans)\n\n        \ndef __starting_point():\n    main()\n__starting_point()", "S = list(str(input()))\nT = list(str(input()))\n\nS_ = set(list(S))\nT_ = set(list(T))\nfor c in T:\n    if c not in S_:\n        print((-1))\n        return\n\nd = [[] for _ in range(26)]\nfor i, s in enumerate(S):\n    d[ord(s)-ord('a')].append(i)\n#print(d)\n\nq = 0\npre = -1\nimport bisect\nfor t in T:\n    j = ord(t)-ord('a')\n    idx = bisect.bisect_right(d[j], pre)\n    if idx == len(d[j]):\n        q += 1\n        pre = d[j][0]\n    else:\n        pre = d[j][idx]\nprint((q*len(S)+pre+1))\n", "from bisect import bisect\ns = list(input())\nt = list(input())\nlenT = len(t)\nlenS = len(s)\nalp = []\n\nfor i in range(26):\n  array = []\n  now = chr(ord('a') + i)\n  for j in range(lenS):\n    if s[j] == now:\n      array.append(j)\n  alp.append(array)\n\ncount,now = 0,-1\n\nfor i in range(lenT):\n  j = ord(t[i])-ord('a')\n  if alp[j]:\n    next = bisect(alp[j],now)\n    if next == len(alp[j]):\n      count += 1\n      now = alp[j][0]\n    else:\n      now = alp[j][next]\n  else:\n    print(-1)\n    return\n\nans = count*lenS+now+1\n\nprint(ans)", "from collections import Counter,defaultdict\nimport bisect\n\ns = input()\nt = input()\nss = s*2\n\nS = Counter(s)\nT = Counter(t)\n\nfor i in T.keys():\n    if i not in S:\n        print(-1)\n        return\n\nalpha = [[] for _ in range(26)]\n\nfor i,j in enumerate(ss):\n    alpha[ord(j)-ord(\"a\")].append(i)\n\nrep,now = 0,-1\n\nfor i in t:\n    alp = alpha[ord(i) - ord('a')]\n    i = bisect.bisect_left(alp,now+1)\n    now = alp[i]\n    if now >= len(s):\n        now -= len(s)\n        rep += 1\n\nprint(rep*len(s)+now+1)", "from bisect import bisect_right\ns = input()\nt = input()\n\nn = len(s)\n\nif set(list(t)) != (set(list(s)) & set(list(t))): ans = -1\nelse:\n    dct = {}\n\n    for i, ss in enumerate(s):\n        if ss in dct:\n            dct[ss].append(i)\n        else: dct[ss] = [i]\n    idx = -1\n    ans = 0\n    for tt in t:\n        m = bisect_right(dct[tt], idx)\n        if m == len(dct[tt]):\n            idx = dct[tt][0]\n            ans += n\n        else:\n            idx = dct[tt][m]\n    ans += idx + 1\n\nprint(ans)", "import math\nimport heapq\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "import collections\n\ns = input()\nt = input()\nmod = len(s)\ns_idx = dict([])\nfor i, key in enumerate(s):\n    try:\n        s_idx[key].append(i + 1)\n    except KeyError:\n        s_idx[key] = [i + 1]\n\ndef binary_search(li, tmp, ng, ok):\n    mid = (ng + ok) // 2\n    if ok - ng < 2:\n        if ok == len(li):\n            return mod + li[0]\n        else:\n            return li[ok]\n    if li[mid] <= tmp: return binary_search(li, tmp, mid, ok)\n    else: return binary_search(li, tmp, ng, mid)\n\nans = 0\ntmp = 0\nfor key in t:\n    try:\n        i = binary_search(s_idx[key], tmp, -1, len(s_idx[key]))\n        ans += i - tmp\n        tmp = i % mod\n    except KeyError:\n        ans = -1\n        break\nprint(ans)", "import string\nimport bisect\ns=input()\nt=input()\nS=[[] for _ in range(26)]\na=string.ascii_lowercase\nnow=-1\nans=-1\ncount=0\nfor i in range(len(s)):\n    for j in range(26):\n        if s[i]==a[j]:\n            S[j].append(i)\n            break\nfor i in range(len(t)):\n    for j in range(26):\n        if t[i]==a[j]:\n            break\n    if len(S[j])==0:\n        break\n    nex=bisect.bisect_right(S[j],now)\n    if nex==len(S[j]) or now>=S[j][nex]:\n        count+=1\n        now=S[j][0]\n    else:\n        now=S[j][nex]\n    if i==len(t)-1:\n        ans=count*(len(s))+now+1\nprint(ans)", "from bisect import bisect\n\ndef ctoi(c):\n    return ord(c) - ord('a')\n\ndef solve():\n    S = input()\n    T = input()\n    N = len(S)\n    idx = [[] for i in range(26)]\n    for i in range(2 * N):\n        idx[ctoi(S[i % N])].append(i)\n    ans = -1\n    for c in T:\n        if not idx[ctoi(c)]:\n            return -1\n        ans += idx[ctoi(c)][bisect(idx[ctoi(c)], ans % N)] - ans % N\n    return ans + 1\nprint((solve()))\n", "#\u3053\u306e\u30d7\u30ed\u30b0\u30e9\u30e0\u306fpypy\u3058\u3083\u901a\u3089\u306a\u3044\nimport collections,math\ns = input()\nt = input()\n#t\u3092\u69cb\u6210\u6587\u5b57\u3067\u3001s\u306b\u306a\u3044\u6587\u5b57\u304c\u3042\u3063\u305f\u3089\u30c0\u30e1\u3002\n#\u69cb\u6210\u3067\u304d\u308b\u306a\u3089\u6700\u5927\u3067\u3082len(t)\u500b\u3057\u304b\u306a\u3044\u304b\u3089\u300110^100\u306e\u9023\u7d50\u306f\u5fc5\u8981\u306a\u3044\n\n#\u6700\u3082\u4e0d\u8db3\u3059\u308b\u6587\u5b57\u3092\u63a2\u3059\nls = collections.Counter(s)\nlt = collections.Counter(t)\n\ntime_dict ={}\ntmp=0\nmax_time=0#\u4e00\u756a\u5c11\u306a\u3044\u3084\u3064\nfor t_key,t_val in list(lt.items()):\n    if t_key not in ls:#s\u306e\u4e2d\u306bt\u306e\u6587\u5b57\u304c\u306a\u3044\n        print((-1))\n        return\n\n#\u6587\u5b57\u3092\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u304f\ncnt = 0\ntt = list(t[::-1])#\u6307\u5b9a\u3057\u305f\u3044\u6587\u5b57\u3078\u306e\u30a2\u30af\u30bb\u30b9\u6642\u9593\u30921\u306b\u3057\u305f\u3044\u306e\u3067\u53cd\u8ee2\nidx=0\nss = s#ss\u306f\u691c\u7d22\u6587\u5b57\u5217\nwhile tt!=[]:#tt\u304c\u7a7a\u3063\u307d\u306b\u306a\u3063\u305f\u3089\u304a\u3057\u307e\u3044\n    next_t = tt.pop()#\u3064\u304e\u306b\u69cb\u6210\u3057\u305f\u3044\u6587\u5b57= next_t\n    idx=ss.find(next_t)#\u691c\u7d22\u6587\u5b57\u5217\u306bnext_t\u304c\u3042\u308b\u304b\n    if idx == -1:#\u306a\u3044\n        cnt += len(ss)#\u691c\u7d22\u6587\u5b57\u5217\u306e\u9577\u3055\u3092\u5168\u90e8\u8db3\u3059\n        idx = s.find(next_t)#\u65b0\u305f\u306bs\u3092\u691c\u7d22\u6587\u5b57\u5217\u3068\u3057\u3066\u63a2\u3059\n        ss = s[idx+1:]#next_t\u4ee5\u964d\u306e\u6587\u5b57\u5217\u3092\u6b21\u56de\u306e\u691c\u7d22\u6587\u5b57\u5217\u3092\u30bb\u30c3\u30c8\n        cnt += idx+1 #nex_t\u304c\u898b\u3064\u304b\u3063\u305f\u6587\u5b57\u307e\u3067\u306e\u9577\u3055\n    else:#\u3042\u308b\n        cnt += idx+1 #\u6587\u5b57\u9577\u3055\u3092\u8db3\u3059 \n        ss = ss[idx+1:]#\u6b21\u56de\u306e\u691c\u7d22\u6587\u5b57\u5217\u3092\u30bb\u30c3\u30c8\nprint(cnt)\n", "import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nnb = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    s = list(input())\n    t = collections.deque(list(input()))\n\n    jump = [[0] * 26 for _ in range(len(s) + 1)]\n\n    for i in range(len(s) - 1, -1, -1):\n        jump[i] = jump[i + 1].copy()\n        jump[i][ord(s[i]) - 97] = i + 1\n\n    ans = 0\n    point = 0\n    while len(t) > 0:\n        tmp = t.popleft()\n        character = ord(tmp) - 97\n        if jump[point][character] == 0 and point == 0:\n            print((-1))\n            return\n        point = jump[point][character]\n        if point == 0:\n            t.appendleft(tmp)\n            ans += 1\n\n    print((ans * len(s) + point))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nind = {}\ns = input()\nt = input()\nfor i, c in enumerate(s):\n    if c in ind:\n        ind[c].append(i+1)\n    else:\n        ind[c] = [i+1]\nk = len(s)\nnk = 0\nif not t[0] in ind:\n    print(-1)\n    return\nnw = ind[t[0]][0]\npv = nw\nfor i in range(1, len(t)):\n    c = t[i]\n    if not c in ind:\n        print(-1)\n        return\n    if ind[c][-1]>pv:\n        pv = ind[c][bisect.bisect_left(ind[c], pv+1)]\n    else:\n        nk += k\n        pv = ind[c][0]\n    nw = pv + nk\nprint(nw)", "def solve():\n    S = input()\n    T = input()\n    N = len(S)\n    M = 2 * N\n    S += S\n    nxt = [[M] * 26 for i in range(M + 1)]\n    for i in range(M - 1, -1, -1):\n        for j in range(26):\n            nxt[i][j] = nxt[i + 1][j]\n        nxt[i][ord(S[i]) - ord('a')] = i\n    ans = 0\n    i = 0\n    for c in T:\n        pos = ord(c) - ord('a')\n        if nxt[i][pos] == M:\n            return -1\n        ans += nxt[i][pos] - i + 1\n        i = (nxt[i][pos] + 1) % N\n    return ans\n\nprint((solve()))\n", "def find(base, indexes):\n    n = len(indexes)\n    ng = -1\n    ok = n\n\n    while ok - ng > 1:\n        mid = (ok + ng) // 2\n        if indexes[mid] > base:\n            ok = mid\n        else:\n            ng = mid\n\n    return indexes[0] if ok == n else indexes[ok]\n\n\ns = input()\nt = input()\n\ns_set = set(s)\nt_set = set(t)\n\nif t_set.issubset(s_set) is False:\n    print((-1))\n    return\n\ns_indxes = [[] for _ in range(26)]\n\nfor i in range(len(s)):\n    c = s[i]\n    idx = ord(c) - ord(\"a\")\n    s_indxes[idx].append(i)\n\nbase = -1\nloop = 0\nfor i in range(len(t)):\n    c = t[i]\n    idx = ord(c) - ord(\"a\")\n    n_base = find(base, s_indxes[idx])\n\n    if n_base <= base:\n        loop += 1\n\n    base = n_base\n\nprint((loop * len(s) + base + 1))\n", "#!/usr/bin/env python3\nfrom bisect import bisect_right\n\ns = input()\nN = len(s)\nsi = [[] for _ in range(26)]\nfor i in range(N):\n    si[ord(s[i])-ord('a')].append(i+1)\n\nans = 0\nt = input()\nM = len(t)\nfor j in range(M):\n    ti = si[ord(t[j])-ord('a')]\n    if len(ti)==0:\n        print(-1)\n        return\n    d = bisect_right(ti,ans%N)\n    if d == len(ti):\n        ans += ti[0]+N-ans%N\n    else:\n        ans += ti[d]-ans%N\nprint(ans)", "from bisect import bisect_right\ns = tuple(map(lambda c: ord(c) - ord(\"a\"), input()))\nt = tuple(map(lambda c: ord(c) - ord(\"a\"), input()))\nS, T = set(s), set(t)\nif T & S != T:\n    print(-1)\n    return\nd, l = [[] for _ in range(26)], [0] * 26\nfor idx, c in enumerate(s):\n    d[c].append(idx)\n    l[c] += 1\nprev = -1\nloop = 0\nfor c in t:\n    idx = bisect_right(d[c], prev)\n    if idx >= l[c]:\n        loop += 1\n        prev = d[c][0]\n    else:\n        prev = d[c][idx]\nprint((loop) * len(s) + prev + 1)", "from bisect import bisect_left\nfrom collections import defaultdict as dd\n\ndef main():\n\n  s=input()\n  t=input()\n  n=len(s)\n\n  dic=dd(list)\n  for idx,i in enumerate(s*2):\n    dic[i].append(idx)\n\n  ans,p=0,-1\n  for i in t:\n    if i not in dic.keys():\n      print(-1)\n      return\n    p=dic[i][bisect_left(dic[i], p+1)]\n    if p>=n:\n      p-=n\n      ans+=n\n\n  print(ans+p+1)\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nfrom string import ascii_lowercase as a2z\n\ninput = sys.stdin.readline\n\n\ndef main():\n    S = input().rstrip()\n    T = input().rstrip()\n\n    N = len(S)\n    memo = [None] * N\n    memo[-1] = {alphabet: -1 for alphabet in a2z}\n    memo[-1][S[-1]] = N - 1\n    for i in reversed(list(range(N - 1))):\n        memo[i] = memo[i + 1].copy()\n        memo[i][S[i]] = i\n\n    ans = 0\n    idx_S = 0\n    for t in T:\n        i = memo[idx_S][t]\n        if i == -1:\n            ans += (N - idx_S)\n            idx_S = 0\n            i = memo[idx_S][t]\n            if i == -1:\n                ans = -1\n                break\n            else:\n                ans += i - idx_S + 1\n                if i == N - 1:\n                    idx_S = 0\n                else:\n                    idx_S = i + 1\n        else:\n            ans += i - idx_S + 1\n            if i == N - 1:\n                idx_S = 0\n            else:\n                idx_S = i + 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\n\ns=input()\nt=input()\nn=len(s)\n\ndic={}\nfor idx,i in enumerate(s*2):\n  if i in dic.keys():\n    dic[i].append(idx)\n  else:\n    dic[i]=[idx]\n\nans,p=0,-1\nfor i in t:\n  if i not in dic.keys():\n    print(-1)\n    return\n  p=dic[i][bisect.bisect_left(dic[i], p+1)]\n  if p>=n:\n    p-=n\n    ans+=n\n  \nprint(ans+p+1)", "A = tuple(range(10**5))\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print((-1))\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)\n", "from collections import Counter\nimport bisect\n\ns = input()\nt = input()\n\"\"\"\nTLE\u554f\u984c\u306a\u306e\u306f\u9593\u9055\u3044\u306a\u3044\u304c\u3001\u5de5\u592b\u3082\u7d50\u69cb\u53b3\u3057\u3044\u5fc5\u8981\u304c\u3042\u308a\u305d\u3046\n\u4e8c\u5206\u63a2\u7d22\u3092\u7528\u3044\u308c\u3070, O(|t| log|s|)\u306e\u5b9a\u6570\u500d\u3067\u89e3\u3051\u308b\uff1f\n\"\"\"\n\n# \u7d76\u5bfe\u306b\u4f5c\u308c\u306a\u3044\u3084\u3064\u306f-1\u3092\u51fa\u3059\u3001\u305d\u308c\u4ee5\u5916\u306f\u7d76\u5bfe\u306b\u4f5c\u308c\u308b.\nsc = Counter(s)\ntc = Counter(t)\nfor i, j in tc.most_common():\n\tif sc[i] == 0:\n\t\tprint(-1)\n\t\treturn\n\n\"\"\"\nO(|t| |s|)\u3067\u89e3\u3051\u308b\u304c\u3001TLE\u78ba\u5b9f.\nbisect\u3092\u4f7f\u3046\u3002\n\"\"\"\n\ntarget = ord(\"a\")\nordl = [[] for _ in range(26)]\nfor i, j in enumerate(s):\n\tordl[ord(j)-target].append(i)\nordllen = [len(ordl[i]) for i in range(26)]\n\n# ordl := \u5404\u6587\u5b57\u306eindex\u756a\u53f7.\n\ntimes = 0\ncnt = -1\nans = 0\nfor i in t:\n\tk = ord(i)-target\n\tm = bisect.bisect_right(ordl[k], cnt)\n\tif m == ordllen[k]:\n\t\ttimes += 1\n\t\tcnt = ordl[k][0]\n\telse:\n\t\tcnt = ordl[k][m]\n\nans = times * len(s) + cnt + 1\nprint(ans)", "import bisect\n\ndef ctoi(char):\n  return ord(char)-ord('a')\n\ns=input()\nl=len(s)\nt=input()\nif len(set(t)-set(s))!=0:\n  print(-1)\n  return\npos=[[] for _ in range(26)]\nfor i in range(2*l):\n  pos[ctoi(s[i%l])].append(i+1)\nindex=0\nloop=0\nfor i in range(len(t)):\n  tmp=bisect.bisect_right(pos[ctoi(t[i])],index)\n  next_index=pos[ctoi(t[i])][tmp]\n  if next_index>=l:\n    loop+=1\n  index=next_index%l\nprint(l*loop+index)", "import sys\nreadline = sys.stdin.readline\n\nS = readline().rstrip()\nT = readline().rstrip()\n\nif len(set(T) - set(S)) > 0:\n  print(-1)\n  return\n  \nimport bisect\n# T\u306e\u5404\u6587\u5b57\u3092\u63a2\u3059\nS2 = S * 2\nfrom collections import defaultdict\n# \u3042\u308b\u6587\u5b57\u304c\u4f55\u6587\u5b57\u76ee\u306b\u3042\u308b\u304b\u8f9e\u66f8\ndic = defaultdict(list)\n\nfor i in range(len(S2)):\n  dic[S2[i]] += [i]\n\nind = -1\nans = 0\nfor t in T:\n  # \u63a2\u3059\u6587\u5b57\u306ft\n  targets = dic[t]\n#  print(\"targets\",targets,\"t\",t,\"ind + 1\",ind + 1)\n  newind = targets[bisect.bisect_left(targets, ind + 1)]\n#  print(\"t\",t,\"S2\",S2,\"newind\",newind)\n  ans += (newind - ind)\n  if newind >= len(S):\n    newind -= len(S)\n  ind = newind\n\nprint(ans)", "from bisect import *\ndef alph_to_num(s):\n  return ord(s)-ord('a')\ndef solve():\n  ans = 0\n  S = input()\n  T = input()\n  lis = [[] for _ in range(26)]\n  for i,s in enumerate(S):\n    lis[alph_to_num(s)].append(i)\n  ind = -1\n  for t in T:\n    n = alph_to_num(t)\n    if not len(lis[n]):\n      return -1\n    if ind>=lis[n][-1]:\n      ans += len(S)\n      ind = lis[n][0]\n    else:\n      ind = lis[n][bisect_right(lis[n],ind)]\n  ans += ind+1\n  return ans\nprint(solve())", "'''\n\u7814\u7a76\u5ba4PC\u3067\u306e\u89e3\u7b54\n'''\nimport math\n#import numpy as np\nimport queue\nimport bisect\nfrom collections import deque,defaultdict\nimport heapq as hpq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\nmod = 10**9+7\n\ndef main():\n    s = input()\n    ls = len(s)\n    t = input()\n    if t[0] in s:\n        idx = s.find(t[0])\n    else:\n        print((-1))\n        return\n    for i in t[1::]:\n        nt = s.find(i,idx%ls+1)\n        ntl = s.find(i)\n        if ntl == -1:\n            print((-1))\n            return\n        elif nt == -1:\n            idx = (idx//ls)*ls+ls+ntl\n        else:\n            idx = (idx//ls)*ls+nt\n    print((idx+1))\n    return None\n\ndef __starting_point():\n    main()\n\n__starting_point()", "S = input()\nT = input()\n\nfrom collections import defaultdict\n\nnx = [defaultdict(lambda: -1) for i in range(len(S)+1)]\nlastpos = defaultdict(lambda: 0)\n\nSS = S+S\nfor i,c in enumerate(SS[::-1]):\n    i = len(SS)-1-i\n    if i < len(S):\n        for k,v in lastpos.items():\n            nx[i+1][k] = v-i\n    lastpos[c] = i\nfor k,v in lastpos.items():\n    nx[0][k] = v+1\n\nans = 0\nfor c in T:\n    if nx[ans%len(S)][c] == -1:\n        print(-1)\n        return\n    ans += nx[ans%len(S)][c]\nprint(ans)", "import bisect\nfrom collections import defaultdict\ns = input()\nn = len(s)\nt = input()\nif set(s) & set(t) != set(t):\n    print((-1))\nelse:\n    cnt = defaultdict(list)\n    for i in range(n):\n        cnt[s[i]].append(i+1)\n    loop = 0\n    prev = 0\n    for c in t:\n        x = cnt[c]\n        idx = bisect.bisect_right(x, prev)\n        if idx < len(x):\n            prev = x[idx]\n        else:\n            prev = x[0]\n            loop += 1\n    print((loop*n+prev))\n", "def abc138_e():\n    s = str(input())\n    t = str(input())\n    sd = dict()\n    for i, c in enumerate(s):\n        if sd.get(c) == None: sd[c] = []\n        sd[c].append(i)\n    from bisect import bisect_left\n    k = 0\n    p = 0\n    for c in t:\n        if sd.get(c) == None: return print(-1)\n        idx = bisect_left(sd[c], p)\n        if idx == len(sd[c]):\n            k += 1\n            p = 0\n            idx = bisect_left(sd[c], p)\n        p = sd[c][idx] + 1\n    ans = k * len(s) + p\n    return print(ans)\n\ndef __starting_point():\n    abc138_e()\n__starting_point()", "import heapq\nimport bisect\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "import collections\n\ns = input()\nt = input()\ns_len = len(s)\ns_idx = dict([])\nfor i, key in enumerate(s):\n    try:\n        s_idx[key].append(i + 1)\n    except KeyError:\n        s_idx[key] = [i + 1]\n\ndef binary_search(li, tmp, ng, ok):\n    mid = (ng + ok) // 2\n    if ok - ng < 2:\n        if ok == len(li):\n            return s_len + li[0]\n        else:\n            return li[ok]\n    if li[mid] <= tmp: return binary_search(li, tmp, mid, ok)\n    else: return binary_search(li, tmp, ng, mid)\n\nans = 0\nex_i = 0\nfor key in t:\n    try:\n        i = binary_search(s_idx[key], ex_i, -1, len(s_idx[key]))\n        ans += i - ex_i\n        ex_i = i % s_len\n    except KeyError:\n        ans = -1\n        break\nprint(ans)", "s=input()\nt=input()\n\npos=[[] for _ in range(26)]\n\nlen_s=len(s)\nlen_t=len(t)\n\n\nfor i in range(len_s):\n    idx=ord(s[i])-97\n    pos[idx].append(i)\n\nans=[]\ntmp=-1\ncnt=0\nfor i in range(len_t):\n    idx=ord(t[i])-97\n    if len(pos[idx])==0:\n        print((-1))\n        return\n\n    if tmp<pos[idx][-1]:\n        l=-1\n        r = len(pos[idx]) - 1\n        while l + 1 < r:\n            mid = (l + r) // 2\n            if pos[idx][mid] <= tmp:\n                l = mid\n            else:\n                r=mid\n        ans.append(pos[idx][r])\n        tmp=pos[idx][r]\n    else:\n        cnt+=1\n        ans.append(pos[idx][0])\n        tmp=pos[idx][0]\n\n\nprint((cnt*len_s+ans[-1]+1))\n\n\n", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=998244353\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  s=S()\n  n=len(s)\n  t=S()\n  n2=len(t)\n\n  d={}\n  for i,x in enumerate(s):\n    if x in d:\n      y=d[x]\n      y.append(i)\n      d[x]=y\n    else:\n      d[x]=[i]\n\n  # print(d)\n  i=0\n  j=0\n  ans=1\n  while j<n2:\n    check=t[j]\n    if check not in d:\n      return -1\n    l=d[check]\n    if i<l[0]:\n      ans+=l[0]-i+1\n      i=l[0]+1\n      j+=1\n    elif l[-1]<i:\n      ans+=n-(i+1)+l[0]+2\n      i=l[0]+1\n      j+=1\n    else:\n      if i==l[0]:\n        ans+=1\n        i+=1\n        j+=1\n      elif i==l[-1]:\n        ans+=1\n        i+=1\n        j+=1\n      else:\n        left=0\n        right=len(l)\n        while right-left>1:\n          m=(right+left)//2\n          if l[m]>=i:\n            right=m\n          else:\n            left=m\n          # print(right,left,m,i)\n        ans+=l[right]-i+1\n        i=l[right]+1\n        j+=1\n\n    # print(i,ans)\n\n    i%=n\n\n  return ans-1\n\n# main()\nprint((main()))\n", "import copy\n\ns = input()\nt = input()\n\nsn = len(s)\ntn = len(t)\na = [[] for i in range(26)]\nfor i in range(sn):\n    num = ord(s[i]) - 97\n    a[num].append(i)\n\ntable = [[0]*sn for i in range(26)]\nfor i in range(26):\n    if a[i]:\n        table[i][:] = [copy.deepcopy(a[i][0])]*sn\n    f = 0\n    for j in a[i]:\n        table[i][f:j] = [copy.deepcopy(j)]*(j-f)\n        f = copy.deepcopy(j)\n\nflg = True\ncnt = 0 # \u4eca\u4f55\u9031\u3057\u305f\u304b\nx = -1 # \u4eca\u4f55\u6587\u5b57\u76ee\u304b\nfor i in range(tn):\n    num = ord(t[i]) - 97\n    # s\u306e\u4e2d\u306b\u5bfe\u8c61\u306e\u6587\u5b57\u304c\u5b58\u5728\u3057\u306a\u3044\n    if not a[num]:\n        flg = False\n        break\n    # s\u306e\u4e2d\u306b\u5bfe\u8c61\u306e\u6587\u5b57\u304c\u5b58\u5728\n    xx = copy.deepcopy(x)\n    x = table[num][x]\n    if xx >= x:\n        cnt += 1\nprint(cnt*sn + x+1) if flg else print(-1)", "from bisect import bisect_right\ns = input()\nt = input()\nalpha = [[] for _ in range(26)]\ndef f(c): return ord(c)-ord(\"a\")\n\nfor i,c in enumerate(s): alpha[f(c)].append(i)\nidx = -1\nroop = 0\nfor c in t:\n    lst = alpha[f(c)]\n    if not lst:\n        ans = -1\n        break\n    i = bisect_right(lst,idx)\n    if i == len(lst):\n        roop += 1\n        idx = lst[0]\n    else:\n        idx = lst[i]\nelse:\n    ans = len(s)*roop+idx+1\nprint(ans)", "import bisect\n\n\ndef main() -> None:\n    S = input()\n    T = input()\n    SS = S + S\n    alphas = [[] for _ in range(26)]\n    for i, s in enumerate(SS):\n        alphas[ord(s) - ord('a')].append(i)\n    rep, now = 0, -1\n    for t in T:\n        alpha = alphas[ord(t) - ord('a')]\n        i = bisect.bisect_left(alpha, now + 1)\n        if i == len(alpha):\n            print((-1))\n            return\n        now = alpha[i]\n        if now >= len(S):\n            now -= len(S)\n            rep += 1\n    print((rep * len(S) + now + 1))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom collections import defaultdict\nimport bisect\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    s = list(input())\n    t = list(input())\n    dic = defaultdict(list)\n    for index, string in enumerate(s):\n        dic[string].append(index)\n    cycle = 0\n    ind = -1\n    for string in t:\n        if dic[string] == []:\n            print(-1)\n            return\n        elif dic[string][-1] <= ind:\n            cycle += 1\n            ind = dic[string][0]\n        else:  # [2,6,7,10] 6\u306e\u6b21\u306f\uff1f\n            ind = dic[string][bisect.bisect_right(\n                dic[string], ind)]  # n\u4ee5\u4e0b\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    print(cycle*len(s)+ind+1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    S = input()\n    N = len(S)\n    INF = N + 1\n    T = input()\n    # S \u3067 i \u756a\u76ee\u306e\u4f55\u756a\u76ee\u306e\u5f8c\u3067\u6587\u5b57 c \u304c\u51fa\u3066\u304f\u308b\u304b\u3092\u8a08\u7b97\n    next_loc = [[INF for _ in range(N)] for _ in range(26)]\n    for i, s in enumerate(S):\n        c = ord(s) - ord('a')\n        next_loc[c][i - 1] = 1\n    for c in range(26):\n        n = INF\n        for i in range(N - 1, -(N + 1), -1):\n            n = min(next_loc[c][i], n + 1)\n            next_loc[c][i] = n\n    # \u7b54\u3048\u3092\u8a08\u7b97\n    ans = 0\n    index = -1\n    for t in T:\n        c = ord(t) - ord('a')\n        i = next_loc[c][index]\n        if i == INF:\n            print(-1)\n            return\n        ans += i\n        index = (index + i) % N\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\n \nimport sys\n# \u4ee5\u4e0b\u3092\u8a18\u8ff0\u3057\u306a\u3044\u3068TLE\u306b\u306a\u308b, \u4f55\u6545\uff1f\nfrom heapq import heappush, heappop, heappushpop\nfrom collections import defaultdict\n# ---- \u3053\u3053\u307e\u3067 -----------------------\n \ninput = sys.stdin.readline\n \nS = input().rstrip()\nT = input().rstrip()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n \nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n \nprint(ans)", "def main():\n    import sys\n    import copy\n    from bisect import bisect_right\n    from collections import defaultdict\n    input = sys.stdin.readline\n    s, t = input().strip(), input().strip()\n    lens = len(s)\n    index_list = defaultdict(list)\n    leng = defaultdict(int)\n    for i, ss in enumerate(s):\n        index_list[ss].append(i)\n\n    for s, i in index_list.items():\n        if i:\n            leng[s] = len(index_list[s])\n\n    prev = -1\n    ans = 0\n    for tt in t:\n        if tt not in leng:\n            print(-1)\n            return False\n        p = bisect_right(index_list[tt], prev)\n        # print('tt={}, prev={}, p={}, ans={}'.format(tt, prev, p, ans))\n        if p < leng[tt]:\n            prev = index_list[tt][p]\n        else:\n            prev = index_list[tt][0]\n            ans += lens\n\n    print(ans+prev+1)\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    from functools import lru_cache\n    import bisect\n    S = input()\n    T = input()\n    if set(S) & set(T) != set(T):\n        print((-1))\n    else:\n        lt = len(T)\n        ls = len(S)\n        st = set(T)\n        D = dict()\n        for t in st:\n            D[t] = list()\n            for i, s in enumerate(S):\n                if t == s:\n                    D[t].append(i)\n        pre = -1\n        cnt = 0\n\n        @lru_cache(maxsize=None)\n        def judge(pre, t):\n            X = D[t]\n            index = bisect.bisect(X, pre)\n            if len(X) == index:\n                return (X[0], True)\n            else:\n                return (X[index], False)\n\n        for t in T:\n            J = judge(pre, t)\n            pre = J[0]\n            if J[1]:\n                cnt += 1\n\n        print((cnt * len(S) + pre + 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\nimport bisect\nimport heapq\nimport collections\n\nS = input()\nT = input()\nlenS = len(S)\nlenT = len(T)\nF1 = [False]*26\nF2 = [False]*26\nalpha = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(lenS):\n    F1[alpha.index(S[i])] = True\nfor i in range(lenT):\n    F2[alpha.index(T[i])] = True\nfor i in range(26):\n    if not F1[i] and F2[i]:\n        print(-1)\n        return\n\nind = S.index(T[0])\nans = ind+1\nfor i in range(1,lenT):\n    S = S[ind+1:] + S[:ind+1]\n    ind = S.index(T[i])\n    ans += ind+1\n\nprint(ans)", "import bisect\n\ns = input()\nt = input()\n\nalphabet = [[] for _ in range(26)]\nn = len(s)\ns += s\nfor i in range(len(s)):\n    alphabet[ord(s[i]) - ord(\"a\")].append(i)\n    \nans = 0\nnow = -1\nfor i in range(len(t)):\n    t_i = ord(t[i]) - ord(\"a\")\n    j = bisect.bisect_right(alphabet[t_i], now)\n    if j == len(alphabet[t_i]):\n        print(-1)\n        return\n    else:\n        now = alphabet[t_i][j]\n        if now >= n:\n            now -= n\n            ans += n\n            \nprint(ans + now + 1)", "from collections import defaultdict\nfrom bisect import bisect_right\n\ns = input()\nt = input()\n\nn = len(s)\n\nmp = [[] for _ in range(26)]\ns += s\nfor i in range(len(s)):\n    mp[ord(s[i]) - ord('a')].append(i)\n\nans = 0\nnow = -1\nfor i in range(len(t)):\n    a = ord(t[i]) - ord('a')\n    nxt = bisect_right(mp[a], now)\n    if len(mp[a]) == nxt:\n        print((-1))\n        return\n\n    now = mp[a][nxt]\n    if now >= n:\n        ans += n\n        now -= n\n\nprint((ans + now + 1))\n"]
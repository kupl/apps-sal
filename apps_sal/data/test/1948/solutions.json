["from collections import deque\nfrom sys import stdin\n\nn, x = map(int, stdin.readline().split())\nleafs = set(range(n))\ngraph = [[] for i in range(n)]\ncount = [False for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, stdin.readline().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    if not count[a - 1]:\n        count[a - 1] = True\n    else:\n        leafs.discard(a - 1)\n    if not count[b - 1]:\n        count[b - 1] = True\n    else:\n        leafs.discard(b - 1)\nqueue = deque()\nway_a = [10 ** 6 for i in range(n)]\nway_b = [10 ** 6 for i in range(n)]\nused = [False for i in range(n)]\nqueue.append([0, 0])\nwhile queue:\n    j = queue.popleft()\n    way_a[j[0]] = min(way_a[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nqueue.append([x - 1, 0])\nused = [False for i in range(n)]\nwhile queue:\n    j = queue.popleft()\n    way_b[j[0]] = min(way_b[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nres = way_a[x - 1]\nfor i in leafs:\n    if way_a[i] > way_b[i]:\n        res = max(res, way_a[i])\nprint(res * 2)", "from collections import deque\nfrom sys import stdin\n\nn, x = map(int, stdin.readline().split())\ngraph = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, stdin.readline().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\nqueue = deque()\nway_a = [10 ** 6 for i in range(n)]\nway_b = [10 ** 6 for i in range(n)]\nused = [False for i in range(n)]\nqueue.append([0, 0])\nwhile queue:\n    j = queue.popleft()\n    way_a[j[0]] = min(way_a[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nqueue.append([x - 1, 0])\nused = [False for i in range(n)]\nwhile queue:\n    j = queue.popleft()\n    way_b[j[0]] = min(way_b[j[0]], j[1])\n    for i in graph[j[0]]:\n        if not used[i]:\n            used[i] = True\n            queue.append([i, j[1] + 1])\nres = way_a[x - 1]\nfor i in range(n):\n    if way_a[i] > way_b[i]:\n        res = max(res, way_a[i])\nprint(res * 2)", "#!/usr/bin/pypy3\n\nfrom sys import stdin,stderr\nfrom collections import defaultdict\n\ndef readInts(): return map(int,stdin.readline().strip().split())\ndef print_err(*args,**kwargs): print(*args,file=stderr,**kwargs)\n    \ndef dfs(n,g,b):\n    s = [(1,0,1)]\n    b_depth = 0\n    parents = [ None for _ in range(n+1) ]\n    while s:\n        node,depth,pn = s.pop()\n        parents[node] = pn\n        if node==b:\n            b_depth = depth\n            break\n        depth += 1\n        for nn in g[node]:\n            if nn == pn: continue\n            s.append( (nn,depth,node) )\n        \n    anc_node = b\n    for _ in range((b_depth-1)//2):\n        anc_node = parents[anc_node]\n    s = [(1,False,0,1)]\n    best = 0\n    while s:\n        node,bd,depth,pn = s.pop()\n        bd |= node==anc_node\n        if bd and best < depth:\n            best = depth\n        depth += 1\n        for nn in g[node]:\n            if nn == pn: continue\n            s.append( (nn,bd,depth,node) )\n    return best\n\ndef run():\n    n,x = readInts()\n    g = defaultdict(list)\n    for _ in range(n-1):\n        a,b = readInts()\n        g[a].append(b)\n        g[b].append(a)\n    print(dfs(n,g,x)*2)\n        \nrun()\n", "from sys import stdin,stderr\nfrom collections import defaultdict,deque\ndef main():\n    n,x=map(int,stdin.readline().strip().split())\n    X=x-1\n    graph=[[] for i in range(n)]\n    for i in range(n):\n        graph[i]=[]\n    for _ in range(n-1):\n        a,b=map(int,stdin.readline().strip().split())\n        #a,b=a-1,b-1\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    #def bfs(graph):\n    q=deque([0])\n        #level=[0 for i in range(len(graph))]\n    parent=[-1]*len(graph)\n    visit=[]\n    while q:\n        v=q.popleft()\n        visit.append(v)\n        for adj in graph[v]:\n            if adj!=parent[v]:\n                    #level[adj]=level[v]+1\n                parent[adj]=v\n                q.append(adj)\n\n        #return parent,visit\n\n\n    #parent,visit=bfs(graph) \n    #print(level,parent,visit)\n    \n    cur=X\n    path=[X]\n    #print(path,'path')\n    while(parent[X]!=-1):\n        X=parent[X]\n        path+=[X]\n\n    P=len(path)-1  \n    \n    toleft=parent\n    #bfsvisit=visit[::-1]\n    for i in range(1,len(visit)):\n        x=visit[-i]\n        \n        if [parent[x]]==graph[x]:\n            toleft[x]=0\n        else:\n            ans=0\n            for adj in graph[x]:\n                if adj!=parent[x]:\n                    ans=max(toleft[adj],ans)\n            ans+=1\n            toleft[x]=ans\n   \n\n    #print(path,toleft) \n    #print(P,'P')\n    MAX=0\n    \n    for t in range(0,P+1):\n        if 2*t<P:\n            temp=2*t+(2*toleft[path[t]]+2*abs(P-2*t))\n            if temp>MAX:\n                MAX=temp\n        else:\n            break\n\n    print(MAX)    \n\n\n    #print(toleft[2],path)    \nmain()", "def prog():\n    from sys import stdin\n    from collections import deque\n    n,x = map(int,stdin.readline().split())\n    x-=1\n    d = [[] for i in range(n)]\n    for i in range(n-1):\n        a,b = map(int,stdin.readline().split())\n        d[a-1].append(b-1)\n        d[b-1].append(a-1)\n    Alice = [1000000 for i in range(n)]\n    Bob = [1000000 for i in range(n)]\n    queue=deque()\n    queue.append([0,0])\n    while queue:\n        q1 = queue.popleft()\n        Alice[q1[0]]=min(Alice[q1[0]],q1[1])\n        for i,item in enumerate(d[q1[0]]):\n            if Alice[item]==1000000:\n                queue.append([item,q1[1]+1])\n    queue.append([x,0])\n    while queue:\n        q2 = queue.popleft()\n        Bob[q2[0]]=min(Bob[q2[0]],q2[1])\n        for i,item in enumerate(d[q2[0]]):\n            if Bob[item]==1000000:\n                queue.append([item,q2[1]+1])\n    res = 0\n    for i in range(n):\n        A=Alice[i]\n        if A>Bob[i]:\n            if A>res:\n                res=A\n    print(2*res)\nprog()", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn, x = mints()\ne = [[] for i in range(n)]\nfor i in range(n-1):\n\ta, b = mints()\n\te[a-1].append(b-1)\n\te[b-1].append(a-1)\nx -= 1\nq = [0]*n\nd = [0]*n\np = [-1]*n\nql = 0\nqr = 1 \nq[0] = x\nd[x] = 1 \nwhile ql < qr:\n\tu = q[ql]\n\tql += 1\n\tfor v in e[u]:\n\t\tif d[v] == 0:\n\t\t\td[v] = d[u] + 1\n\t\t\tp[v] = u\n\t\t\tq[qr] = v\n\t\t\tqr += 1\n#v = 0\n#u = 1\n#while v != -1:\n#\tif d[v] >= u:\n#\t\td[v] = 0\n#\tv = p[v]\n#\tu += 1\n#print(d)\ndd = [0]*n\nql = 0\nqr = 1 \nq[0] = 0\ndd[0] = 1 \nwhile ql < qr:\n\tu = q[ql]\n\tql += 1\n\tfor v in e[u]:\n\t\tif dd[v] == 0:\n\t\t\tdd[v] = dd[u] + 1\n\t\t\tq[qr] = v\n\t\t\tqr += 1\n\nr = 0 \nfor i in range(n):\n\tif d[i] < dd[i]:\n\t\tr = max(r, dd[i])\nprint((r-1)*2)\n", "from sys import stdin, stdout\nimport math,sys,heapq\nfrom itertools import permutations, combinations\nfrom collections import defaultdict,deque,OrderedDict\nfrom os import path\nimport bisect as bi\ndef yes():print('YES')\ndef no():print('NO')\nif (path.exists('input.txt')): \n    #------------------Sublime--------------------------------------#\n    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n    def I():return (int(input()))\n    def In():return(list(map(int,input().split())))\nelse:\n    #------------------PYPY FAst I/o--------------------------------#\n    def I():return (int(stdin.readline()))\n    def In():return(list(map(int,stdin.readline().split())))\n\ndef dict(a):\n    d={}\n    z=[]\n    for x in a:\n        if d.get(x,-1)!=-1:\n            d[x]+=1\n        else:\n            d[x]=1\n            z.append(x)\n    return [d,z]\n\ndef find_gt(a, x):\n    'Find leftmost value greater than x'\n    i = bi.bisect_right(a, x)\n    if i != len(a):\n        return i\n    else:            \n        return -1\n\n\n\ndef dfs(d,n,s):\n    alice=[0]*(n+1)\n    visit=[False]*(n+1)\n    parent=[-1]*(n+1)\n    parent[1]=0\n    q=deque([s])\n    cnt=0\n    while q:\n        temp=q.popleft()\n        \n        for x in d[temp]:\n            if visit[x]==False:\n                q.appendleft(x)\n                parent[x]=temp\n                alice[x]=alice[temp]+1\n        visit[temp]=True\n    return alice\ndef main():\n    try:\n        n,s=In()\n        d=defaultdict(list)\n        for x in range(n-1):\n            a,b=In()\n            d[a].append(b)\n            d[b].append(a)\n        \n        alice=dfs(d,n,1)\n        bob=dfs(d,n,s)\n        #print(alice)\n        ans=0\n        for i in range(1,n+1):\n            if bob[i]<alice[i]:\n                ans=max(ans,2*(alice[i]))\n        print(ans)\n   \n\n    except:\n        pass\n        \nM = 998244353\nP = 1000000007\n \ndef __starting_point():\n    #for _ in range(I()):main()\n    for _ in range(1):main()\n\n\n\n__starting_point()", "from sys import stdin\n\ndef put(): return map(int, stdin.readline().split())\n\ndef dfs():\n    s = [(1,0)]\n    vis = [0]*(n+1)\n    while s:\n        i,p = s.pop()\n        if vis[i]==0:\n            vis[i]=1\n            parent[i]=p\n            alice[i]=alice[p]+1\n            s.append((i,p))\n            for j in tree[i]:\n                if j!=p:\n                    s.append((j,i))\n        elif vis[i]==1:\n            vis[i]=2\n            for j in tree[i]:\n                if j != p:\n                    depth[i]= max(depth[i], depth[j]+1)        \n\n\n\n\nn,k = put()\ntree = [[] for i in range(n+1)]\nalice, depth, parent = [0]*(n+1), [0]*(n+1), [0]*(n+1)\nfor _ in range(n-1):\n    x,y = put()\n    tree[x].append(y)\n    tree[y].append(x)\ndfs()\nans = 0\ni = k\ntime = 1\nwhile i!=0:\n    if time<alice[i]:\n        ans = max(ans, alice[i]+depth[i])\n    i = parent[i]\n    time+=1\n\nprint(2*ans-2)", "from sys import stdin\nfrom collections import deque\n\ndef bfs(G, s):\n    Q = deque()\n    Q.append(s)\n    infinite = 10 ** 6\n    d = [infinite]*n\n    d[s] = 0\n    while Q:\n        u = Q.popleft()\n        for v in graph[u]:\n            if d[v] == infinite:\n                d[v] = d[u] + 1\n                Q.append(v)\n    return d\n\nn, x = list(map(int, stdin.readline().split()))\nx = x - 1\n\ngraph = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = list(map(int, stdin.readline().split()))\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\nd_Alice = bfs(graph, 0)\nd_Bob = bfs(graph, x)\n\nresp = d_Alice[x]\nfor i,v in enumerate(graph):\n    if len(v) == 1 and d_Alice[i] > d_Bob[i]:\n        resp = max(resp, d_Alice[i])\nprint(2*resp)\n", "from collections import deque\nfrom sys import stdin\n\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)    \n\n#Recibiendo los valores de n y x\nn,x=map(int, stdin.readline().split())\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=map(int, stdin.readline().split())\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)    \n\n#Recibiendo los valores de n y x\nn,x=map(int, stdin.readline().split())\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=map(int, stdin.readline().split())\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from sys import stdin\n\n#Clase nodo\nclass Node():\n    def __init__(self,value=None,prox=None):\n        self.value=value\n        self.prox=prox\n#Clase cola      \nclass Queue:\n    def __init__(self):\n        self.first=None\n        self.last=None\n        self.count=0\n\n    def Enqueue(self,value):\n        new_node=Node(value)\n        self.count+=1\n        if self.first is None:\n            self.last=self.first=new_node\n        else:\n            self.last.prox=new_node\n            self.last=new_node\n    \n    def Dequeue(self):\n        value=self.first.value\n        self.count-=1\n        self.first=self.first.prox\n        return value\n\n#Parser\ndef parser():\n    return [int(x) for x in input().split(\" \")]\n\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=Queue()\n    q.Enqueue(s)\n    while q.count>0:\n        v=q.Dequeue()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.Enqueue(u)    \n\n#Recibiendo los valores de n y x\nn,x=map(int, stdin.readline().split())\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=map(int, stdin.readline().split())\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from sys import stdin\n\n#Clase nodo\nclass Node():\n    def __init__(self,value=None,prox=None):\n        self.value=value\n        self.prox=prox\n#Clase cola      \nclass Queue:\n    def __init__(self):\n        self.first=None\n        self.last=None\n        self.count=0\n\n    def Enqueue(self,value):\n        new_node=Node(value)\n        self.count+=1\n        if self.first is None:\n            self.last=self.first=new_node\n        else:\n            self.last.prox=new_node\n            self.last=new_node\n    \n    def Dequeue(self):\n        value=self.first.value\n        self.count-=1\n        self.first=self.first.prox\n        return value\n\n#Parser\ndef parser():\n    return map(int, stdin.readline().split())\n\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=Queue()\n    q.Enqueue(s)\n    while q.count>0:\n        v=q.Dequeue()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.Enqueue(u)    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return [int(i) for i in stdin.readline().split(\" \")]\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    edge=parser()\n    adjacents_list[edge[0]-1].append(edge[1]-1)\n    adjacents_list[edge[1]-1].append(edge[0]-1)\n\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from sys import stdin\n\n#Clase nodo\nclass Node():\n    def __init__(self,value=None,prox=None):\n        self.value=value\n        self.prox=prox\n#Clase cola      \nclass Queue:\n    def __init__(self):\n        self.first=None\n        self.last=None\n        self.count=0\n\n    def Enqueue(self,value):\n        new_node=Node(value)\n        self.count+=1\n        if self.first is None:\n            self.last=self.first=new_node\n        else:\n            self.last.prox=new_node\n            self.last=new_node\n    \n    def Dequeue(self):\n        value=self.first.value\n        self.count-=1\n        self.first=self.first.prox\n        return value\n\n#Parser\ndef parser():\n    return map(int, stdin.readline().split())\n\n#Algoritmo BFS\ndef BFS(s):\n    if s==0:\n        distance=distance_Alice\n    else:\n        distance=distance_Bob\n\n    distance[s]=0\n    q=Queue()\n    q.Enqueue(s)\n    while q.count>0:\n        v=q.Dequeue()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.Enqueue(u)    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Creando los arrays necesarios para la ejecucion de DFS\n#visitados\ndistance_Alice=[-1 for i in range(n)]\ndistance_Bob=[-1 for i in range(n)]\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\nBFS(0)\n\nBFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#parser\ndef parser():\n    return map(int, stdin.readline().split())\n#Algoritmo BFS\ndef BFS(s):\n    distance=[-1 for i in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\ndistance_Alice=BFS(0)\n\ndistance_Bob=BFS(x-1)\n\n#Hallando el nodo mas alejado a Alice que puede alcanzar Bob antes que lo alcance Alice\nmax=0\nfor i in range(n):\n    if max<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max=distance_Alice[i]\n\nprint(max*2)", "from collections import deque\nfrom sys import stdin\n\n#parsea una linea\ndef parser():\n    return map(int, stdin.readline().split())\n#Metodo usado para calcular las distancia de un vertice al resto de los vertices\ndef BFS(s):\n    distance=[-1 for i in range(n)]\n    distance[s]=0\n    q=deque()\n    q.append(s)\n    while len(q)>0:\n        v=q.popleft()\n        for u in adjacents_list[v]:\n            if distance[u] == -1:\n                distance[u]=distance[v]+1\n                q.append(u)\n    return distance    \n\n#Recibiendo los valores de n y x\nn,x=parser()\n\n#Armando el arbol\nadjacents_list=[[] for i in range(n)]\nfor i in range(n-1):\n    #Leyendo una arista\n    v1,v2=parser()\n    adjacents_list[v1-1].append(v2-1)\n    adjacents_list[v2-1].append(v1-1)\n\n#Hallando las distancias\ndistance_Alice=BFS(0)\ndistance_Bob=BFS(x-1)\n\n#Obteniendo la distancia mayor desde el vertice 1 hasta un vertice alcanzable por Bob\nmax_distance=0\nfor i in range(n):\n    if max_distance<distance_Alice[i] and distance_Bob[i]<distance_Alice[i]:\n        max_distance=distance_Alice[i]\n\n#Imprimiendo el resultado\nprint(max_distance*2)"]
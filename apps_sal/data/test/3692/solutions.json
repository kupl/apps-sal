["from math import sqrt\ndef pt(x):\n    print(x)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)", "from math import sqrt\npt = lambda *a, **k: print(*a, **k, flush=True)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)\n", "from math import *\neps = 1e-9\nans = dict()\nans[(0,0,0)] = 4\nans[(0,0,1)] = 4\nans[(0,1,0)] = 4\nans[(1,0,0)] = 4\nans[(0,1,1)] = 4\nans[(1,0,1)] = 4\nans[(1,1,0)] = 4\nans[(1,1,1)] = 5\nans[(0,0,2)] = 5\nans[(0,2,0)] = 5\nans[(2,0,0)] = 5\nans[(0,1,2)] = 5\nans[(0,2,1)] = 5\nans[(1,0,2)] = 5\nans[(1,2,0)] = 5\nans[(2,0,1)] = 5\nans[(2,1,0)] = 5\nans[(1,1,2)] = 6\nans[(1,2,1)] = 6\nans[(2,1,1)] = 6\nans[(0,2,2)] = 6\nans[(2,0,2)] = 6\nans[(2,2,0)] = 6\nans[(1,2,2)] = 7\nans[(2,1,2)] = 7\nans[(2,2,1)] = 7\nans[(2,2,2)] = 8\n\ndef dist(A, B):\n    return ((A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2) ** 0.5\n\ndef equal(A, B):\n    return dist(A, B) < eps\n\ndef belong(P, i):\n    return abs(dist(P, (c[i][0], c[i][1])) - c[i][2]) < eps\n\ndef intersection(c1, c2):\n    O1 = c1[0], c1[1]\n    O2 = c2[0], c2[1]\n    r1, r2 = c1[2], c2[2]\n    OO = (O2[0]- O1[0], O2[1]- O1[1])\n    d = dist(O1, O2)\n    if d > r1 + r2 or d < abs(r1 - r2):\n        return []\n    alp = atan2(OO[1], OO[0])\n    phi = acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))\n    P1 = (r1 * cos(alp + phi) + O1[0], r1 * sin(alp + phi) + O1[1])\n    P2 = (r1 * cos(alp - phi) + O1[0], r1 * sin(alp - phi) + O1[1])\n    if equal(P1, P2):\n        return [P1]\n    return [P1, P2]\n\ndef solve():\n    if n == 1:\n        return 2\n    if n == 2:\n        res = 3\n        inter = intersection(c[0], c[1])\n        if len(inter) == 2:\n            res += 1\n        return res\n    cnt = 0\n    inter = [0, 0, 0]\n    p = []\n    for i in range(3):\n        for j in range(i + 1, 3):\n            cur = intersection(c[i], c[j])\n            for P in cur:\n                p.append(P)\n                inter[i + j - 1] += 1\n    for P in p:\n        flag = 1\n        for i in range(3):\n            if not belong(P, i):\n                flag = 0\n        if flag:\n            cnt += 1\n    res = ans[tuple(inter)] - cnt // 3\n    return res\n\n\nn = int(input())\nc = [tuple(map(int, input().split())) for i in range(n)]\nprint(solve())\n", "from math import sqrt\n\nclass vector:\n\tdef __init__(self, _x = 0, _y = 0):\n\t\tself.x = _x\n\t\tself.y = _y\n\tdef len(self):\n\t\treturn sqrt(self.x ** 2 + self.y ** 2)\n\tdef len_sq(self):\n\t\treturn self.x ** 2 + self.y ** 2\n\tdef __mul__(self, other):\n\t\tif (type(self) == type(other)):\n\t\t\treturn self.x * other.x + self.y * other.y\n\t\treturn vector(self.x * other, self.y * other)\n\tdef __mod__(self, other):\n\t\treturn self.x * other.y - self.y * other.x\n\tdef normed(self):\n\t\tlength = self.len()\n\t\treturn vector(self.x / length, self.y / length)\n\tdef normate(self):\n\t\tself = self.normed()\n\tdef __str__(self):\n\t\treturn \"(\" + str(self.x) + \", \" + str(self.y) + \")\"\n\tdef __add__(self, other):\n\t\treturn vector(self.x + other.x, self.y + other.y);\n\tdef __sub__(self, other):\n\t\treturn vector(self.x - other.x, self.y - other.y);\n\tdef __eq__(self, other):\n\t\treturn self.x == other.x and self.y == other.y\n\tdef rot(self):\n\t\treturn vector(self.y, -self.x)\n\nclass line:\n\tdef __init__(self, a = 0, b = 0, c = 0):\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.c = c\n\tdef intersect(self, other):\n\t\td = self.a * other.b - self.b * other.a\n\t\tdx = self.c * other.b - self.b * other.c\n\t\tdy = self.a * other.c - self.c * other.a\n\t\treturn vector(dx / d, dy / d)\n\tdef fake(self, other):\n\t\td = self.a * other.b - self.b * other.a\n\t\treturn d\n\tdef __str__(self):\n\t\treturn str(self.a) + \"*x + \" + str(self.b) + \"*y = \" + str(self.c) \n\ndef line_pt(A, B):\n\t\td = (A - B).rot()\n\t\treturn line(d.x, d.y, d * A)\n\nclass circle:\n\tdef __init__(self, O = vector(0, 0), r = 0):\n\t\tself.O = O\n\t\tself.r = r\n\tdef intersect(self, other):\n\t\tO1 = self.O\n\t\tO2 = other.O\n\t\tr1 = self.r\n\t\tr2 = other.r\n\t\tif (O1 == O2):\n\t\t\treturn []\n\t\tif ((O1 - O2).len_sq() > r1 ** 2 + r2 ** 2 + 2 * r1 * r2):\n\t\t\treturn []\n\t\trad_line = line(2 * (O2.x - O1.x), 2 * (O2.y - O1.y), r1 ** 2 - O1.len_sq() - r2 ** 2 + O2.len_sq())\n\t\tcentral = line_pt(O1, O2)\n\t\tM = rad_line.intersect(central)\n\t\t# print(M)\n\t\tif ((O1 - O2).len_sq() == r1 ** 2 + r2 ** 2 + 2 * r1 * r2):\n\t\t\treturn [M]\n\t\td = (O2 - O1).normed().rot()\n\t\tif (r1 ** 2 - (O1 - M).len_sq() < 0):\n\t\t\treturn []\n\t\td = d * (sqrt(r1 ** 2 - (O1 - M).len_sq()))\n\t\treturn [M + d, M - d]\n\tdef fake(self, other):\n\t\tO1 = self.O\n\t\tO2 = other.O\n\t\tr1 = self.r\n\t\tr2 = other.r\n\t\tif (O1 == O2):\n\t\t\treturn 1\n\t\tif ((O1 - O2).len_sq() > r1 ** 2 + r2 ** 2 + 2 * r1 * r2):\n\t\t\treturn 1\n\t\trad_line = line(2 * (O2.x - O1.x), 2 * (O2.y - O1.y), r1 ** 2 - O1.len_sq() - r2 ** 2 + O2.len_sq())\n\t\tcentral = line_pt(O1, O2)\n\t\treturn rad_line.fake(central)\n\n\n# a = vector(3, 4)\n# b = vector(4, 4)\n# print(circle(vector(1, 2), 3).intersect(circle(vector(2, 1), 6)))\nn = int(input())\narr = []\nm = 1\nfor i in range(n):\n\tx, y, r = map(int, input().split())\n\tarr.append(circle(vector(x, y), r))\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\tm *= arr[i].fake(arr[j])\nfor i in range(n):\n\tarr[i].O = arr[i].O * m\n\tarr[i].r = arr[i].r * m\n# print(m)\ns = set()\nV = 0\nfor i in range(n):\n\tfor j in range(i + 1, n):\n\t\ttmp = arr[i].intersect(arr[j])\n\t\tfor e in tmp:\n\t\t\ts.add((round(e.x, 6), round(e.y, 6)))\nV += len(s)\nE = 0\n\npar = [i for i in range(n)]\n\ndef get_par(v):\n\tif (par[v] != v):\n\t\tpar[v] = get_par(par[v])\n\treturn par[v]\ndef unite(v, u):\n\tpar[get_par(v)] = get_par(u)\nfor i in range(n):\n\ts = set()\n\tfor j in range(n):\t\n\t\ttmp = arr[i].intersect(arr[j])\n\t\tif (len(tmp)):\n\t\t\tunite(i, j)\n\t\tfor e in tmp:\n\t\t\ts.add((round(e.x, \t), round(e.y, \t)))\n\tE += len(s)\n# print(V, E)\n# print(len({get_par(i) for i in range(n)}))\nprint(E - V + 1 + len({get_par(i) for i in range(n)}))", "from math import sqrt\npt = lambda *a, **k: print(*a, **k, flush=True)\nrd = lambda: map(int, input().split())\nn = int(input())\ndef f(x1, y1, r1, x2, y2, r2):\n    a = (r1 + r2) ** 2\n    b = (r1 - r2) ** 2\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > a:\n        return 1\n    elif d == a:\n        return 4\n    elif d < b:\n        return 3\n    elif d == b:\n        return 5\n    else:\n        return 2\ndef g(x1, y1, r1, x2, y2, r2):\n    ds = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    d = sqrt(ds)\n    A = (r1 ** 2 - r2 ** 2 + ds) / (2 * d)\n    h = sqrt(r1 ** 2 - A ** 2)\n    x = x1 + A * (x2 - x1) / d  \n    y = y1 + A * (y2 - y1) / d\n    x3 = x - h * (y2 - y1) / d  \n    y3 = y + h * (x2 - x1) / d\n    x4 = x + h * (y2 - y1) / d  \n    y4 = y - h * (x2 - x1) / d\n    return x3, y3, x4, y4 \nif n is 1:\n    pt(2)\nif n is 2:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    pt(4 if a is 2 else 3)\nif n is 3:\n    x1, y1, r1 = rd()\n    x2, y2, r2 = rd()\n    x3, y3, r3 = rd()\n    a = f(x1, y1, r1, x2, y2, r2)\n    b = f(x1, y1, r1, x3, y3, r3)\n    c = f(x3, y3, r3, x2, y2, r2)\n    t = [a, b, c]\n    t.sort()\n    a, b, c = t\n    if a is 1 and b is 1 and c in [1, 3, 4, 5]:\n        pt(4)\n    if a is 1 and b is 1 and c is 2:\n        pt(5)\n    if a is 1 and b is 2 and c is 2:\n        pt(6)\n    if a is 1 and b is 2 and c in [3, 4, 5]:\n        pt(5)\n    if a is 1 and b in [3, 4, 5]:\n        pt(4)\n    if a is 2 and b is 2 and c is 2:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        r = 8\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        if abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            r -= 1\n        pt(r)\n    if a is 2 and b is 2 and c is 3:\n        pt(6)\n    if a is 2 and b is 2 and c in [4, 5]:\n        x4, y4, x5, y5 = g(x1, y1, r1, x2, y2, r2)\n        if abs((x4 - x3) ** 2 + (y4 - y3) ** 2 - r3 ** 2) < 1e-6 or abs((x5 - x3) ** 2 + (y5 - y3) ** 2 - r3 ** 2) < 1e-6:\n            pt(6)\n        else:\n            pt(7)\n    if a is 2 and b is 3:\n        pt(5)\n    if a is 2 and b in [4, 5]:\n        pt(6)\n    if a is 3 and b in [3, 4, 5]:\n        pt(4)\n    if a is 4 and b is 4 and c is 4:\n        pt(5)\n    if a is 4 and b is 4 and c is 5:\n        pt(4)\n    if a is 4 and b is 5 and c is 5:\n        pt(5)\n    if a is 5 and b is 5 and c is 5:\n        pt(4)\n\n\n\n\n# Made By Mostafa_Khaled", "from decimal import *\n\ngetcontext().prec = 40\neps = Decimal('1e-10')\n\n\nclass Circle:\n\tdef __init__(self, x, y, r):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.r = r\n\n\tdef contains(self, c):\n\t\tdd = (self.x - c.x)**2 + (self.y - c.y)**2  # dd = d*d\n\t\treturn dd < (self.r - c.r)**2 and self.r > c.r\n\n\tdef in_touches(self, c):\n\t\tdd = (self.x - c.x)**2 + (self.y - c.y)**2  # dd = d*d\n\t\treturn dd == (self.r - c.r)**2 and self.r > c.r\n\n\tdef ex_touches(self, c):\n\t\tdd = (self.x - c.x)**2 + (self.y - c.y)**2  # dd = d*d\n\t\treturn dd == (self.r + c.r)**2\n\t\n\tdef intersects(self, c):\n\t\tdd = (self.x - c.x)**2 + (self.y - c.y)**2  # dd = d*d\n\t\treturn (self.r - c.r)**2 < dd < (self.r + c.r)**2\n\t\n\tdef not_intersects(self, c):\n\t\tdd = (self.x - c.x)**2 + (self.y - c.y)**2  # dd = d*d\n\t\treturn dd > (self.r + c.r)**2\n\t\n\tdef get_intersections(self, c):\n\t\tx1, y1, r1, x2, y2, r2 = list(map(Decimal, [self.x, self.y, self.r, c.x, c.y, c.r]))\n\t\t\n\t\tRR = (x1-x2)**2 + (y1-y2)**2\n\t\t\n\t\trx1 = (x1+x2)/2 + (r1**2-r2**2)/(2*RR)*(x2-x1) + (2*(r1**2+r2**2)/RR-(r1**2-r2**2)**2/(RR**2)-1).sqrt()/2 * (y2-y1)\n\t\try1 = (y1+y2)/2 + (r1**2-r2**2)/(2*RR)*(y2-y1) + (2*(r1**2+r2**2)/RR-(r1**2-r2**2)**2/(RR**2)-1).sqrt()/2 * (x1-x2)\n\t\t\n\t\trx2 = (x1+x2)/2 + (r1**2-r2**2)/(2*RR)*(x2-x1) - (2*(r1**2+r2**2)/RR-(r1**2-r2**2)**2/(RR**2)-1).sqrt()/2 * (y2-y1)\n\t\try2 = (y1+y2)/2 + (r1**2-r2**2)/(2*RR)*(y2-y1) - (2*(r1**2+r2**2)/RR-(r1**2-r2**2)**2/(RR**2)-1).sqrt()/2 * (x1-x2)\n\t\n\t\treturn {(rx1, ry1), (rx2, ry2)}\n\n\tdef is_on(self, p):\n\t\treturn abs((self.x - p[0])**2 + (self.y - p[1])**2 - self.r**2) < eps\n\t\n\tdef __repr__(self):\n\t\treturn \"(%s, %s, %s)\" % (self.x, self.y, self.r)\n\n\ndef count_regions(n, circles):\n\tif n == 1:\n\t\treturn 2\n\n\tif n == 2:\n\t\treturn 3 + circles[0].intersects(circles[1])\n\n\tif n == 3:\n\t\tc0, c1, c2 = circles\n\t\tif c0.not_intersects(c1):\n\t\t\tif c0.intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\t\t\telif c0.ex_touches(c2) or c2.not_intersects(c0):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.contains(c2) or c0.in_touches(c2):\n\t\t\t\treturn 4\n\n\t\telif c0.contains(c1):\n\t\t\tif c0.in_touches(c2) or c0.contains(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.ex_touches(c2) or c0.not_intersects(c2):\n\t\t\t\treturn 4\n\t\t\telif c0.intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\n\t\telif c0.in_touches(c1):\n\t\t\tif c0.in_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 5\n\t\t\t\telse:\n\t\t\t\t\treturn 4\n\t\t\telif c0.not_intersects(c2) or c0.ex_touches(c2):\n\t\t\t\treturn 4\n\t\t\telif c0.contains(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\telif c0.intersects(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\t# intersects: 7/6, depends on intersections\n\t\t\t\t\tc0_x_c2 = c0.get_intersections(c2)\n\t\t\t\t\treturn 6 + all(not c1.is_on(p) for p in c0_x_c2)\n\t\t\t\telse:\n\t\t\t\t\treturn 5 + (c1.ex_touches(c2) or c2.in_touches(c1))\n\n\t\telif c0.ex_touches(c1):\n\t\t\tif c0.in_touches(c2) or c0.contains(c2):\n\t\t\t\treturn 4\n\t\t\t\n\t\t\telif c0.ex_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 5\n\t\t\t\telse:\n\t\t\t\t\treturn 4\n\t\t\t\n\t\t\telif c0.not_intersects(c2):\n\t\t\t\treturn 4 + c1.intersects(c2)\n\t\t\t\n\t\t\telif c0.intersects(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\t# intersects: 8/7/6?\n\t\t\t\t\tc0_x_c1 = c0.get_intersections(c1)\n\t\t\t\t\treturn 7 + all(not c2.is_on(p) for p in c0_x_c1)\n\t\t\t\telif c1.ex_touches(c2):\n\t\t\t\t\treturn 6\n\t\t\t\telse:\n\t\t\t\t\treturn 5\n\n\t\telif c0.intersects(c1):\n\t\t\tif c0.not_intersects(c2):\n\t\t\t\treturn 5 + c1.intersects(c2)\n\n\t\t\telif c0.contains(c2):\n\t\t\t\t# [?] c1.intersects(c2) -> ?\n\t\t\t\treturn 5 + c1.intersects(c2)\n\n\t\t\telif c0.in_touches(c2) or c0.ex_touches(c2):\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tc0_x_c2 = c0.get_intersections(c2)\n\t\t\t\t\treturn 6 + all(not c1.is_on(p) for p in c0_x_c2)\n\t\t\t\telse:\n\t\t\t\t\treturn 5 + (c1.in_touches(c2) or c1.ex_touches(c2))\n\n\t\t\telif c0.intersects(c2):\n\t\t\t\tc0_x_c1 = c0.get_intersections(c1)\n\t\t\t\tif c1.intersects(c2):\n\t\t\t\t\tif all(not c2.is_on(p) for p in c0_x_c1):\n\t\t\t\t\t\treturn 8\n\t\t\t\t\telif all(c2.is_on(p) for p in c0_x_c1):\n\t\t\t\t\t\treturn 6\n\t\t\t\t\telse:\n\t\t\t\t\t\treturn 7\n\t\t\t\t\n\t\t\t\telif c1.in_touches(c2) or c1.ex_touches(c2) or c2.in_touches(c1):\n\t\t\t\t\treturn 7 - any(c2.is_on(p) for p in c0_x_c1)\n\t\t\t\t\n\t\t\t\telse:  # if c1.contains(c2) or c2.contains(c1) or c1.not_intersects(c2):\n\t\t\t\t\treturn 6\n\n\t\treturn 4\n\n\treturn 0\n\n\ndef main():\n\tn = int(input())\n\tcircles = [tuple(map(int, input().split())) for c in range(n)]\n\tcircles.sort(key=lambda c: (-c[2], c[0], c[1]))\n\tcircles = [Circle(*u) for u in circles]\n\t# print(n, circles)\n\tprint(count_regions(n, circles))\n\n\ndef __starting_point():\n\tmain()\n\n__starting_point()"]
["n, k = [int(x) for x in input().strip().split(\" \")]\np = 10**9 + 7\n\nnum_list = [int(x) for x in input().strip().split(\" \")]\nnum_list = sorted(num_list, reverse = True)\n\nans = 1\nl_idx = 0\nr_idx = -1\n\nif num_list[0] < 0 and k % 2 == 1:\n  for i in range(k):\n    ans = (ans * num_list[i]) % p\nelse:\n  while True:\n    if k >= 2:\n      l_prod = num_list[l_idx] * num_list[l_idx+1]\n      r_prod = num_list[r_idx] * num_list[r_idx-1]\n      if l_prod >= r_prod:\n        ans = (ans * num_list[l_idx]) % p\n        l_idx +=1\n        k -= 1\n      else:\n        ans = (ans * r_prod) % p\n        r_idx -=2\n        k -= 2\n    elif k == 1:\n      ans = (ans * num_list[l_idx]) % p\n      ans %= p\n      break\n    else:\n      break\n\nprint(ans)\n", "3\n# -*- coding:utf-8 -*-\n\nimport numpy\n\nMAX = 10 ** 9 + 7\n\ndef prod_mod(la, mod):\n  x = 1\n  for a in la:\n    x *= a\n    x %= mod\n  return x\n\ndef main():\n  n, k = list(map(int, input().strip().split()))\n  la = numpy.array(list(map(int, input().strip().split())))\n  la.sort()\n  if n == k:\n    print((prod_mod(la, MAX)))\n  else:\n    if k % 2 == 1 and (la >= 0).sum() == 0:\n      print((prod_mod(la[-k:], MAX)))\n    else:\n      il, ir = 0, n-1\n      cnt = 0\n      l = []\n      if k % 2 == 1:\n        l.append(la[ir])\n        ir -= 1\n        cnt += 1\n      while k - (cnt + 2) >= 0:\n        if la[il] * la[il+1] > la[ir-1] * la[ir]:\n          l.extend([la[il], la[il+1]])\n          il += 2\n        else:\n          l.extend([la[ir-1], la[ir]])\n          ir -= 2\n        cnt += 2\n      print((prod_mod(l, MAX)))\n      \n\ndef __starting_point():\n  main()\n\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\nn_k = list(map(int, input().split()))\nn = n_k[0]\nk = n_k[1]\na = list(map(int, input().split()))\na_pos = list([v for v in a if v >= 0])\na_neg = list([v for v in a if v < 0])\n\na_pos.sort(reverse=True)\na_neg.sort()\n\nmod = 10**9+7\n\nans = 1\nif n == k:\n    for a_i in a:\n        ans = ans * a_i % mod\nelif len(a_pos) == 0 and k % 2 == 1:\n    for i in reversed(list(range(len(a_neg) - k, len(a_neg)))):\n        ans = ans * a_neg[i] % mod\nelse:\n    i_p = 0\n    i_n = 0\n    i = 0\n    while i < k:\n        if i_p < len(a_pos) and (i == k - 1 or i_n+1 >= len(a_neg) or a_pos[i_p] * (a_pos[i_p+1] if i_p+1 < len(a_pos) else 1) > a_neg[i_n] * a_neg[i_n+1]):\n            ans = ans * a_pos[i_p] % mod\n            i_p += 1\n            i += 1\n        else:\n            ans = ans * a_neg[i_n] % mod * a_neg[i_n+1] % mod\n            i_n += 2\n            i += 2\nprint(ans)\n", "def main():\n    mod = 10**9+7\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort(key=lambda x: -abs(x))\n    kouho = []\n    minus = 0\n    last_plus = None\n    last_minus = None\n    if k == 1:\n        print((max(a)))\n        return\n    for i in range(k):\n        kouho.append(a[i])\n        if a[i] >= 0:\n            last_plus = a[i]\n        if a[i] < 0:\n            minus += 1\n            last_minus = a[i]\n    if minus % 2 == 0:\n        ans = 1\n        for i in kouho:\n            ans = ans*i % mod\n        print(ans)\n        return\n    change_plus = None\n    change_minus = None\n    if last_plus != None:\n        # \u30de\u30a4\u30ca\u30b9\u3092\u8ffd\u52a0\u3059\u308b\n        for i in range(k, n):\n            if a[i] <= 0:\n                change_plus = a[i]\n                break\n    if last_minus != None:\n        # \u30de\u30a4\u30ca\u30b9\u3092\u8ffd\u52a0\u3059\u308b\n        for i in range(k, n):\n            if a[i] >= 0:\n                change_minus = a[i]\n                break\n\n    # print(kouho)\n    #print(last_plus, change_plus)\n    #print(last_minus, change_minus)\n\n    if change_plus == None and change_minus == None:\n        ans = 1\n        for i in range(k):\n            ans = ans*a[-i-1] % mod\n    elif change_plus == None:\n        ans = change_minus\n        for i in kouho:\n            ans = ans*i % mod\n        ans = ans*pow(last_minus, mod-2, mod) % mod\n    elif change_minus == None:\n        ans = change_plus\n        for i in kouho:\n            ans = ans*i % mod\n        ans = ans*pow(last_plus, mod-2, mod) % mod\n    else:\n        if abs(change_plus*last_minus) < abs(change_minus*last_plus):\n            ans = change_minus\n            for i in kouho:\n                ans = ans*i % mod\n            ans = ans*pow(last_minus, mod-2, mod) % mod\n        else:\n            ans = change_plus\n            for i in kouho:\n                ans = ans*i % mod\n            ans = ans*pow(last_plus, mod-2, mod) % mod\n    print(ans)\n\n\nmain()\n", "import sys\ns2nn = lambda s: [int(c) for c in s.split(' ')]\nss2nn = lambda ss: [int(s) for s in ss]\nss2nnn = lambda ss: [s2nn(s) for s in ss]\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: s2nn(i2s())\nii2ss = lambda n: [sys.stdin.readline().rstrip() for _ in range(n)]\nii2sss = lambda n: [list(sys.stdin.readline().rstrip()) for _ in range(n)]\nii2nn = lambda n: ss2nn(ii2ss(n))\nii2nnn = lambda n: ss2nnn(ii2ss(n))\nfrom collections import deque  # \u53cc\u65b9\u5411\u30ad\u30e5\u30fc\nfrom collections import defaultdict  # \u521d\u671f\u5316\u6e08\u307f\u8f9e\u66f8\nfrom heapq import heapify, heappush, heappop, heappushpop  # \u30d7\u30e9\u30a4\u30aa\u30ea\u30c6\u30a3\u30ad\u30e5\u30fc\nfrom bisect import bisect_left, bisect_right  # \u4e8c\u5206\u63a2\u7d22\nsys.setrecursionlimit(int(1e+6))\nMOD = int(1e+9) + 7\n#import numpy as np  # 1.8.2\n#import scipy  # 0.13.3\n\ndef main():\n    N, K = i2nn()\n    A = i2nn()\n    # \u9078\u629e\u306e\u4f59\u5730\u304c\u306a\u3044\u5834\u5408\u3001\u5168\u90e8\u639b\u3051\u308b\u3057\u304b\u306a\u3044\n    if N == K:\n        n = 1\n        for a in A:\n            n = (n * a) % MOD\n        print(n)\n        return\n\n    Ap = [ n for n in A if n >= 0]\n    An = [-n for n in A if n < 0]\n    Ap.sort()\n    Ap.reverse()\n    An.sort()\n    An.reverse()\n    Np = len(Ap)\n    Nn = len(An)\n    # \u7d50\u679c\u306f\u30d7\u30e9\u30b9\u306b\u3057\u305f\u3044\u3002Ai\u304c\u5168\u90e8\u30de\u30a4\u30ca\u30b9\u304b\u3064K\u304c\u5947\u6570\u3060\u3068NG\n    # \u7d50\u679c\u3092\u30d7\u30e9\u30b9\u306b\u3067\u304d\u306a\u3044\u5834\u5408\u3001\u7d76\u5bfe\u5024\u3092\u6700\u5c0f\u5316\u3059\u308b\n    if N == Nn and K % 2 == 1:\n        n = 1\n        A.sort()\n        A.reverse()\n        for i in range(K):\n            n = (n * A[i]) % MOD\n        print(n)\n        return\n\n    n = 1\n    k = K\n    i = 0\n    j = 0\n    # \u7d50\u679c\u3092\u30d7\u30e9\u30b9\u306b\u5834\u5408\u3001\u30d7\u30e9\u30b9\u3092\u7dad\u6301\u3057\u3064\u3064\u3001\u7d76\u5bfe\u5024\u3092\u6700\u5927\u5316\u3059\u308b\n    # K\u306f\u5076\u6570\u3067\u8003\u3048\u305f\u3044\u3002K\u304c\u5947\u6570\u306e\u3068\u304d\u3001\u4e00\u756a\u5927\u304d\u306a\u6b63\u306e\u6570\u3092\u53d6\u308b\n    if k % 2 == 1:\n        n = (n * Ap[i]) % MOD\n        i += 1\n        k -= 1\n    while k > 0:\n        if Np - i < 2:\n            n = (n * An[j]) % MOD\n            j += 1\n            n = (n * An[j]) % MOD\n            j += 1\n        elif Nn - j < 2:\n            n = (n * Ap[i]) % MOD\n            i += 1\n            n = (n * Ap[i]) % MOD\n            i += 1\n        else:\n            np = Ap[i] * Ap[i+1]\n            nn = An[j] * An[j+1]\n            if np >= nn:\n                n = (n * np) % MOD\n                i += 2\n            else:\n                n = (n * nn) % MOD\n                j += 2\n        k -= 2\n    print(n)\n\nmain()\n", "import numpy as np\nN,K=map(int, input().split())\nA =list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nif N==K:\n  ans0 = 1\n  for a in A[0:N]:\n    ans0 *= a\n    ans0 %= MOD\n  print(ans0)\n  return\n\nA=sorted(A)  \nif (K%2==1 and A[-1]<0):\n  ans1 = 1\n  for a in A[N-K:N]:\n    ans1 *= a\n    ans1 %= MOD\n  print(ans1)\n  return\n\nA=sorted(A, key=lambda x:abs(x), reverse=True)\nAA=[np.sign(i) for i in A]\n \nansA = 1\nfor a in A[0:K]:\n  ansA *= a\n  ansA %= MOD\nansAA = AA[0:K].count(-1)%2\nif ansA==0 or ansAA==0:\n  print(ansA)\n  return\n\nB1=A[0:K]\nC1=A[0:K]\nB2=sorted(A[K:N])\nBp=[i for i in A[0:K] if i>0]\nBm=[i for i in A[0:K] if i<0]\n\nif B2[0]>0:B2.insert(0,0)\nif B2[-1]<0:B2.insert(-1,0)\nif not Bp:Bp.insert(0,B1[-1])\nif not Bm:Bm.insert(0,B1[0])\n  \nB1.remove(Bp[-1])\nB1.append(min(B2[0],0))\n\nansB = 1\nfor a in B1[0:K]:\n  ansB *= a\n  ansB %= MOD\n\nC1.remove(Bm[-1])\nC1.append(max(B2[-1],0))\n \nansC = 1\nfor a in C1[0:K]:\n  ansC *= a\n  ansC %= MOD\n\nBB1=[np.sign(i) for i in B1]\nansBB1 = BB1[0:K].count(-1)%2\nBB2=[np.sign(i) for i in C1]\nansBB2 = BB2[0:K].count(-1)%2\nif ansBB1==1:\n  print(ansC)\n  return\nif ansBB2==1:\n  print(ansB)\n  return\n\nif abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0])>=0:\n  print(ansC)\nelse: print(ansB)", "import datetime\nimport string\nimport re\nimport math\n\ndef isort(list, _beg, _end):\n    if _beg < _end:\n        beg = _beg\n        end = _end\n        pivot = abs(list[int((beg + end)/2)])\n        while(True):\n            while abs(list[beg]) < pivot: beg += 1\n            while abs(list[end]) > pivot: end -= 1\n            if beg <= end:\n                tmp = list[beg]\n                list[beg] = list[end]\n                list[end] = tmp\n                beg += 1\n                end -= 1\n            else:\n                break\n        isort(list, _beg, end)\n        isort(list, beg, _end)\n\ndef searchByBool(list):\n    for i in range(len(list)):\n        if check(list[i]): return i\n    return -1\n\ndef check(num):\n    if num >= 0: return True\n    else: return False\n\nsp = list(map(int, input().split()))\nN = sp[0]\nK = sp[1]\nalist = list(map(int, input().split()))\nklist = []\nisK = True\n\nisort(alist, 0, len(alist) - 1)\nalist.reverse()\n\nnumMinus = 0\nfor i in range(K):\n    if check(alist[i]) == False: numMinus += 1\n\n# select biggest K numbers in terms of absolute value\n\n# for all chosen numbers\n# if the number of negative number is even\nif numMinus % 2 == 0:\n    isK = False\n\n# if odd\n# -> choose the smallest number, and search opposite number\nif isK and K < N:\n    _right = -1\n    _left = -1\n    for right in range(K,N):\n        if check(alist[K-1]) != check(alist[right]):\n            _right = right\n            break\n    for left in range(K):\n        if check(alist[K-1-left]) != check(alist[K]):\n            _left = left\n            break\n    isK = False\n    if _right != -1 and _left != -1:\n        if abs(alist[K-1-left]*alist[_right]) < abs(alist[K-1]*alist[K]):\n            alist[K-1-_left] = alist[K]\n        else:\n            alist[K-1] = alist[_right]\n    elif _right == -1 and _left != -1:\n        alist[K-1-_left] = alist[K]\n    elif _right != -1 and _left == -1:\n        alist[K-1] = alist[_right]\n    else:\n        isK = True\n\nif isK:\n    alist.reverse()\nklist = alist[0:K]\n\nmulti = klist[0]\nfor i in range(1, K):\n    multi *= klist[i]\n    multi = multi % 1000000007\n\nprint(multi)\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nv=[]\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  v=a\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  v=nega[:k]\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  for i in range(k):\n    v.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    mx=max(a[k:]); mn=min(a[k:]);\n    if pi>=0 and abs(a[pi]*mx)<=abs(a[ni]*mn):\n      v.append(mn); v.remove(a[pi]);\n    else:\n      v.append(mx); v.remove(a[ni]);\n\nans=1\nfor i in range(k):\n  ans*=v[i]; ans%=mod;\n\nprint(ans)", "n,k=map(int,input().split())\nA=sorted(list(map(int,input().split())))\n\nmod=10**9+7\n\nif A[-1]<0 and k%2==1:\n    now=1\n    for i in range(k):\n        now*=A[-i-1]%mod\n        now%=mod\n    print(now)\n    return\n\nl=0\nr=n-1\nans=1\nif k%2==1:\n    ans=A[-1]\n    r-=1\n\nfor i in range(k//2):\n    mi=A[l]*A[l+1]\n    pl=A[r]*A[r-1]\n    if mi>pl:\n        ans*= mi%mod\n        ans%=mod\n        l+=2\n    else:\n        ans*= pl%mod\n        ans%=mod\n        r-=2\nprint(ans%mod)", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0:\n  if zero and k%2:\n    ans = 0\n  else:\n    if k%2:\n      minus.reverse()\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "N, K = list(map(int, input().split()))\nA = tuple(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nif K == N:\n    ans = 1\n    for x in A:\n        ans = (ans * x) % MOD\n    print(ans)\n    return\n\nplus, minus = [], []\nfor a in A:\n    if a >= 0:\n        plus.append(a)\n    else:\n        minus.append(a)\n\nplus.sort(reverse=True)\nminus.sort()\n\nif not plus:\n    ans = 1\n    if K % 2:\n        # \u7b54\u3048\u306f\u8ca0\u5024\u306b\u306a\u308b\u306e\u3067\u7d76\u5bfe\u5024\u5c0f\u3055\u3044\u306e\u3092\u53d6\u308b\n        for x in minus[-K:]:\n            ans = (ans * x) % MOD\n    else:\n        # \u7b54\u3048\u306f\u975e\u8ca0\u5024\u306b\u306a\u308b\u306e\u3067\u7d76\u5bfe\u5024\u5927\u304d\u3044\u306e\u3092\u53d6\u308b\n        for x in minus[:K]:\n            ans = (ans * x) % MOD\n    print(ans)\n    return\n\nidx = 0\nfor i in range(2, N, 2):\n    if K - i < 0:\n        break\n    if not len(plus) >= K - i + 2:\n        idx += 2\n        continue\n    if len(minus) >= i:\n        if minus[i - 2] * minus[i - 1] < plus[K - i + 1] * plus[K - i]:\n            break\n        else:\n            idx += 2\n\nans = 1\nfor x in minus[:idx] + plus[:K - idx]:\n    ans = (ans * x) % MOD\nprint(ans)\n", "N,K=map(int, input().split())\nA=list(map(int, input().split()))\nD,E=[],[]\nzcnt,scnt,fcnt=0,0,0\nfor i in A:\n  if i==0:\n    zcnt+=1\n    D.append(0)\n  elif i>0:\n    D.append(i)\n    scnt+=1\n  else:\n    E.append(i)\n    fcnt+=1\nmod=10**9+7\nans=1\n#\u5168\u3066\u4f7f\u3046\u5834\u5408\u306f\u554f\u7b54\u7121\u7528\u3067\u304b\u3051\u308b\nif K==N:\n  for i in A:\n    ans*=i\n    ans%=mod\n  print(ans)\n  return\n#\u30de\u30a4\u30ca\u30b9\u3092\u5947\u6570\u500b\u7d76\u5bfe\u304b\u3051\u308b\u2192\u78ba\u5b9f\u306b\u7b54\u3048\u306f\u30de\u30a4\u30ca\u30b9\nif K%2==1 and max(A)<0:\n  A=sorted(A)[::-1]\n  for i in range(K):\n    ans*=A[i]\n    ans%=mod\n  print(ans)\n  return\n#\u7d76\u5bfe0\u3092\u304b\u3051\u306a\u304d\u3083\u3044\u3051\u306a\u3044\nif K>scnt+fcnt:\n  print(0)\n  return\nD,E=sorted(D)[::-1],sorted(E)\n#print(D,E)\nans=1\ncnt=0\na,b=0,0\nwhile K-cnt>1:\n  if a+1<=len(D)-1 and b+1<=len(E)-1:\n    d,e=D[a]*D[a+1],E[b]*E[b+1]\n    if d>e:\n      ans*=D[a]\n      a+=1\n      cnt+=1\n      ans%=mod\n    else:\n      ans*=e\n      b+=2    \n      ans%=mod\n      cnt+=2\n  elif a+1<=len(D)-1:\n    d=D[a]*D[a+1]\n    ans*=D[a]\n    a+=1\n    cnt+=1\n    ans%=mod\n  elif b+1<=len(E)-1:\n    e=E[b]*E[b+1]\n    ans*=e\n    b+=2\n    cnt+=2\n    ans%=mod\n\nif K-cnt==1:\n  Z=[]\n  if a!=scnt:\n    Z.append(D[a])\n  if b!=fcnt:\n    Z.append(E[-1])\n  if 0 in A:\n    Z.append(0)\n  ans*=max(Z)\n  ans%=mod\nprint(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nX = sorted([a for a in A if a >= 0])\nY = sorted([a for a in A if a < 0], key=lambda x: abs(x))\n\nif 2 * (min(K, len(Y)) // 2) + len(X) >= K:\n    ans = 1\n    if K % 2 == 1:\n        ans *= X.pop()\n        K -= 1\n\n    XX = [(x1 * x2) for x1, x2 in zip(*[iter(X[::-1])] * 2)]\n    YY = [(y1 * y2) for y1, y2 in zip(*[iter(Y[::-1])] * 2)]\n    ZZ = sorted(XX + YY)\n\n    for i in range(K // 2):\n        ans *= ZZ.pop()\n        ans %= MOD\n\n    print(ans)\n\nelse:\n    ans = 1\n    Z = sorted(X + Y, key=lambda x: abs(x), reverse=True)\n    for i in range(K):\n        ans *= Z.pop()\n        ans %= MOD\n    print(ans)\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nans=1\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  for i in a:\n    ans*=i; ans%=mod\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    ans*=nega[i]; ans%=mod\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  x=[]\n  for i in range(k):\n    x.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    t=a[k:]\n    mx=max(t)\n    mn=min(t)\n    if mn>0 or pi==-1: # \u3082\u3046\u6b63\u3057\u304b\u3068\u308c\u308b\u6570\u5024\u304c\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\n      x.append(mx)\n      x.remove(a[ni])\n    elif mx<=0: # \u3082\u3046\u8ca0\u3057\u304b\u3068\u308c\u308b\u6570\u5024\u304c\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\n      #if mx==0: print(0); return;\n      x.append(mn)\n      x.remove(a[pi])\n    elif abs(a[pi]*mx)<=abs(a[ni]*mn):\n      x.append(mn)\n      x.remove(a[pi])\n    else:\n      x.append(mx)\n      x.remove(a[ni])\n  #print(x)\n  for i in range(k):\n    ans*=x[i]; ans%=mod;\n\nprint(ans)", "def solve(n,k,a):\n    mod = 10**9 + 7\n    ans = 1\n    l = 0\n    r = n-1\n    a.sort()\n    \n    if k%2 == 1:\n        ans *= a[r]\n        r-=1\n    \n    if ans < 0:\n        ans = 1\n        for i in range(k):\n            ans*= a[n-i-1]\n            ans%= mod\n        return ans\n    \n    for i in range(k//2):\n        tmp_min=a[l]*a[l+1]\n        tmp_max=a[r]*a[r-1]\n        if tmp_max> tmp_min:\n            ans*=tmp_max\n            ans%=mod\n            r-=2\n        else:\n            ans*= tmp_min\n            ans%=mod\n            l+=2\n    return ans\n\n\nn, k = map(int, input().split())\nA = list(map(int,input().split()))\nans = solve(n,k,A)\nprint(ans)", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0:\n  if zero and k%2 == 1:\n    ans = 0\n  else:\n    if k%2:\n      minus.reverse()\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n\nprint(ans)", "n,k = map(int,input().split())\na = list(map(int,input().split()))\n\ns = sorted(a,reverse=True)\nmod = 10**9 + 7\nans = 1\n\nif k % 2 == 1 and s[0] < 0:\n        for i in range(k):\n            ans = ans * s[i] % mod\n        print(ans)\n        return\n\nl = 0\nr = n - 1\nif k % 2 == 1:\n  ans = ans * s[l]\n  l += 1\n\nfor _ in range(k // 2):\n  ml = s[l] * s[l + 1]\n  mr = s[r] * s[r - 1]\n  if ml > mr:\n    ans = ans * ml % mod\n    l += 2\n  else:\n    ans = ans * mr % mod\n    r -= 2\n\nprint(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nM = []\nm = []\nfor a in A:\n    if a < 0:\n        m.append(abs(a))\n    else:\n        M.append(a)\n\ni = 0\nj = 0\ntmp = 1\nP = 10**9 + 7\n\nif (K%2 == 0 and (len(m)//2*2 + len(M)//2*2) >= K) or (K%2 == 1 and (len(M) + len(m)//2*2) >= K and len(M) > 0):\n    m.sort(reverse=True)\n    M.sort(reverse=True)\n    while K > 0:\n        if K >= 2:\n            if j+2 <= len(M) and i+2 <= len(m):\n                if m[i]*m[i+1] < M[j]*M[j+1]:\n                    tmp *= M[j]\n                    j += 1\n                    K -= 1\n                else:\n                    tmp *= m[i]*m[i+1]\n                    i += 2\n                    K -= 2\n            elif j+2 <= len(M):\n                tmp *= M[j]\n                j += 1\n                K -= 1\n            elif i+2 <= len(m):\n                tmp *= m[i]*m[i+1]\n                i += 2\n                K -= 2\n            else:\n                tmp *= m[i]*M[j]\n        else:\n            tmp *= M[j]\n            K -= 1\n        tmp %= P\nelse:\n    m.sort()\n    M.sort()\n    for _ in range(K):\n        if j+1 <= len(M) and i+1 <= len(m):\n            if M[j] < m[i]:\n                tmp *= M[j]\n                j += 1\n            else:\n                tmp *= m[i]\n                i += 1\n        elif j+1 <= len(M):\n            tmp *= M[j]\n            j += 1\n        else:\n            tmp *= m[i]\n            i += 1\n        tmp %= P\n    tmp *= -1\n    tmp %= P\n        \nprint(tmp)\n\n\n\n", "# coding: utf-8\nfrom functools import reduce\n\n\ndef solve(*args: str) -> str:\n    n, k = list(map(int, args[0].split()))\n    A = sorted(map(int, args[1].split()))\n    mod = 10**9+7\n\n    if n == k:\n        return str(reduce(lambda a, b: (a*b) % mod, A, 1))\n\n    if k % 2 and A[-1] < 0:\n        return str(reduce(lambda a, b: (a*b) % mod, A[n-k:], 1))\n\n    l, r = 0, n-1\n    count = 0\n    ret = 1\n\n    if k % 2:\n        ret *= A[-1]\n        r -= 1\n        count += 1\n\n    while count < k-1:\n        pos = max(0, A[r]*A[r-1])\n        neg = max(0, A[l]*A[l+1])\n        if pos <= neg:\n            ret *= neg\n            l += 2\n        else:\n            ret *= pos\n            r -= 2\n        ret %= mod\n        count += 2\n\n    return str(ret % mod)\n\n\ndef __starting_point():\n    print((solve(*(open(0).read().splitlines()))))\n\n__starting_point()", "import math\nimport sys\nN, K = map(int, input().split())\nA = [int(x) for x in input().split()]\n\nMOD = 10**9+7\ndef modinv(a):\n    b = MOD\n    u = 1\n    v = 0\n    while b != 0:\n        t = a // b\n        a -= t * b\n        a, b = b, a\n        u -= t * v\n        u, v = v, u\n    u %= MOD\n    if u < 0:\n        u += MOD\n    return u\n\n\ndef solve(N, K, A):\n    A = sorted(A, key=lambda x : abs(x))\n    #print(A, file=sys.stderr)\n\n    \n    if A[N-K] == 0:\n        return 0\n    Lpos0, Lneg0, Rpos0, Rneg0 = None, None, None, None\n    Lneg, Lpos, Rneg, Rpos = 0, 0, 0, 0\n\n    answer0 = 1\n    for i in range(N-K, N):\n        if A[i] < 0:\n            if Rneg == 0:\n                Rneg0 = -A[i]\n            Rneg += 1\n        else:\n            if Rpos == 0:\n                Rpos0 = A[i]\n            Rpos += 1\n        answer0 = (answer0 * abs(A[i])) % MOD\n\n    if Rneg % 2 == 0:\n        return answer0\n\n    for i in range(N-K)[::-1]:\n        if A[i] < 0:\n            if Lneg == 0:\n                Lneg0 = -A[i]\n            Lneg += 1\n        else:\n            if Lpos == 0:\n                Lpos0 = A[i]\n            Lpos += 1\n\n    print(f\"{K=}\",file=sys.stderr)\n    #print(f\"{Rneg=}, {Rpos=}, {Rneg0=} {Rpos0=}\",file=sys.stderr)\n    #print(f\"{Lneg=}, {Lpos=}, {Lneg0=} {Lpos0=}\",file=sys.stderr)\n    #print(f\"{Lpos0=}, {Lneg0=}, {Rpos0=} {Rneg0=}\",file=sys.stderr)\n\n    #    Lpos Lneg Rpos Rneg\n    # A  o    O    O    o\n    # B  o    O    x    o      / Rneg * Lpos\n    # C  x    O    O    o      / Rpos * Lneg\n    # B  o    x    O    o\n    # B  o    x    x    o\n    # D  x    O    x    o\n    # D  x    x    o    o\n    # D  x    x    x    o\n    if (Lpos0 is not None and Rneg0 is not None\n        and Rpos0 is not None and Lneg0 is not None):\n        answer1 = (answer0 * modinv(Rneg0) % MOD) * Lpos0 % MOD\n        answer2 = (answer0 * modinv(Rpos0) % MOD) * Lneg0 % MOD\n        print(f\"{Lpos0=}, {Lneg0=}, {Rpos0=} {Rneg0=}\",file=sys.stderr)\n\n        print(f\"{answer1=} {answer2=}\", file=sys.stderr)\n        print(f\"A {Lpos0*Lneg0=} {Rneg0*Rpos0=}\", file=sys.stderr)\n        if Lpos0 * Rpos0 > Lneg0 * Rneg0:\n            print(f\"A1 {answer1=}\", file=sys.stderr)\n            return answer1\n        else:\n            print(f\"A2 {answer2=}\", file=sys.stderr)\n            return answer2\n\n    if Lpos0 is not None and Rneg0 is not None:\n        print(\"B\", file=sys.stderr)\n        return  (answer0 * modinv(Rneg0) % MOD) * Lpos0 % MOD\n    if Rpos0 is not None and Lneg0 is not None:\n        print(\"C\", file=sys.stderr)\n        return  (answer0 * modinv(Rpos0) % MOD) * Lneg0 % MOD\n\n    print(\"D\", file=sys.stderr)\n    answer0 = 1\n    for i in range(K):\n        answer0 = (answer0 * A[i]) % MOD\n    return answer0\n\n\nprint(solve(N, K, A))", "from collections import defaultdict\ndef prod(A,k,mod):\n  ans = 1\n  for i in range(k):\n      ans *= A[i]\n      ans %= mod\n  return ans\ndef solve():\n  N, K = list(map(int, input().split()))\n  A = list(map(int, input().split()))\n  mod = 10**9+7\n  ans = 1\n  if K==N:\n    return prod(A,N,mod)\n  minus = len([a for a in A if a<0])\n  if minus==N:\n    if K%2==0:\n      A.sort()\n    else:\n      A.sort(reverse=True)\n    return prod(A,K,mod)\n  if K==1:\n    return max(A)\n  A.sort(key=lambda x:-abs(x))\n  if A[K]==0:\n    return 0\n  minus = len([a for a in A[:K] if a<0])\n  flag = [1]*K+[0]*(N-K)\n  d = defaultdict(lambda: -1)\n  if minus%2==1:\n    for i in range(K,N):\n      if A[i]>=0:\n        d['p2'] = i\n        break\n    for i in range(K,N):\n      if A[i]<0:\n        d['m2'] = i\n        break\n    for i in range(K-1,-1,-1):\n      if A[i]>0:\n        d['p1'] = i\n        break\n    for i in range(K-1,-1,-1):\n      if A[i]<0:\n        d['m1'] = i\n        break\n    if d['p2']==-1 or d['m1']==-1:\n      flag[d['m2']],flag[d['p1']] = 1,0\n    elif d['m2']==-1 or d['p1']==-1:\n      flag[d['p2']],flag[d['m1']] = 1,0\n    elif A[d['p2']]*A[d['p1']]>A[d['m1']]*A[d['m2']]:\n        flag[d['p2']],flag[d['m1']] = 1,0\n    else:\n      flag[d['m2']],flag[d['p1']] = 1,0\n    ans = 1\n    for i in range(N):\n      if flag[i]==1:\n        ans *= A[i]\n        ans %= mod\n    return ans\n  return prod(A,K,mod)\nprint((solve()))\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nans=1\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  for i in a:\n    ans*=i; ans%=mod\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    ans*=nega[i]; ans%=mod\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  x=[]\n  for i in range(k):\n    x.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    t=a[k:]\n    mx=max(t)\n    mn=min(t)\n    if pi==-1:\n      x.append(mx)\n      x.remove(a[ni])\n    elif abs(a[pi]*mx)<=abs(a[ni]*mn):\n      x.append(mn)\n      x.remove(a[pi])\n    else:\n      x.append(mx)\n      x.remove(a[ni])\n  #print(x)\n  for i in range(k):\n    ans*=x[i]; ans%=mod;\n\nprint(ans)", "import sys\n\nmod = 10 ** 9 + 7\nN, K = map(int,input().split())\nA = list(map(int,input().split()))\nif all([a < 0 for a in A]):\n    if K % 2 == 0:\n        A.sort()\n        ans = 1\n        for i in range(K):\n            ans *= A[i]\n            ans %= mod\n        print(ans)\n        return\n    else:\n        A.sort(reverse = True)\n        ans = 1\n        for i in range(K):\n            ans *= A[i]\n            ans %= mod\n        print(ans)\n        return\n\nA.sort()\nl = 0\nr = N - 1\nans = 1\n\nif K % 2 == 1:\n    ans *= A[r]\n    ans %= mod\n    r -= 1\n\nfor _ in range(K // 2):\n    if A[l] * A[l+1] >= A[r] * A[r-1]:\n        ans *= A[l] * A[l+1]\n        ans %= mod\n        l += 2\n    else:\n        ans *= A[r] * A[r-1]\n        ans %= mod\n        r -= 2\n\nprint(ans)", "MOD = 10**9 + 7\n\ndef prod(a):\n    res = 1\n    for x in a:\n        res = (res * x) % MOD\n    return res\n\ndef solve(n, k, a):\n    if k == 1:\n        return max(a)\n    elif k == n:\n        return prod(a)\n    elif (max(a) < 0) and (k % 2 == 1):\n        a = sorted(a, reverse=True)\n        return prod(a[:k])\n    else:\n        a = sorted(a, key=lambda x: -abs(x))\n        num_negative = len(list(filter(lambda x: x < 0, a[:k])))\n        if num_negative % 2 == 0:\n            return prod(a[:k])\n        else:\n            i1, j1 = None, None\n            for i in range(k):\n                if a[i] < 0:\n                    i1 = i\n            for j in range(k,n):\n                if a[j] >= 0:\n                    j1 = j\n                    break\n            i2, j2 = None, None\n            for i in range(k):\n                if a[i] >= 0:\n                    i2 = i\n            for j in range(k, n):\n                if a[j] < 0:\n                    j2 = j\n                    break\n            if ((i1 is None) or (j1 is None)) and ((i2 is None) or (j2 is None)):\n                return prod(a[:k])\n            elif (i1 is None) or (j1 is None):\n                return prod(a[:i2] + a[i2+1:k] + [a[j2]])\n            elif (i2 is None) or (j2 is None):\n                return prod(a[:i1] + a[i1+1:k] + [a[j1]])\n            elif abs(a[j1] * a[i2]) > abs(a[i1] * a[j2]):\n                return prod(a[:i1] + a[i1+1:k] + [a[j1]])\n            else:\n                return prod(a[:i2] + a[i2+1:k] + [a[j2]])\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0 and k%2 ==1 :\n  if zero >= 1:\n    ans = 0\n  else:\n    minus.sort(reverse=True)\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "def abc173_e():\n    n, k = map(int, input().split())\n    A = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    A.sort(reverse=True)  # \u7b26\u53f7\u4ed8\u304d\u306e\u5927\u304d\u3044\u9806\n    B = sorted(A, key=lambda x: abs(x), reverse=True)  # \u7d76\u5bfe\u5024\u306e\u5927\u304d\u3044\u9806\n    C = []\n\n    if k == n:\n        C = A  # \u5168\u90e8\u4f7f\u3046\n    elif k % 2 == 1 and A[0] < 0:\n        C = A[:k]  # \u7d76\u5bfe\u5024\u5c0f\u3055\u3044\u9806\u306bk\u500b\n    else:\n        plus = []\n        minus = []\n        for b in B[:k]:\n            if b >= 0: plus.append(b)\n            else: minus.append(b)\n\n        if len(minus) % 2 == 1:\n            # \u7a4d\u304c\u8ca0\u306b\u306a\u308b\u306e\u3067\u5165\u308c\u66ff\u3048\u691c\u8a0e\n            rem1, add1, rem2, add2 = None, None, None, None\n\n            rem1 = minus[-1]  # \u8ca0\u5024\u306e\u7d76\u5bfe\u5024\u6700\u5c0f\n            add1 = max(B[k:])  # \u6b8b\u308a\u3082\u306e\u306e\u6b63\u5024\u306e\u7d76\u5bfe\u5024\u6700\u5927\n            valid1 = (add1 >= 0)\n\n            valid2 = False\n            if plus:\n                rem2 = plus[-1]\n                add2 = min(B[k:])  # \u8ca0\u5024\u306e\u7d76\u5bfe\u5024\u6700\u5927\n                valid2 = (add2 < 0)\n\n            if valid1 and valid2:\n                if add1 * rem2 > rem1 * add2:\n                    minus[-1] = add1\n                else:\n                    plus[-1] = add2\n            elif valid1:\n                minus[-1] = add1\n            elif valid2:\n                plus[-1] = add2\n\n        C = plus + minus\n\n    ans = 1\n    for c in C:\n        ans *= c\n        if ans < 0: ans += mod\n        ans %= mod\n    print(ans)\n\ndef __starting_point():\n    abc173_e()\n__starting_point()", "MOD = 10 ** 9 + 7\n\nn,k=map(int, input().split())\na=list(map(int, input().split()))\naplus,aminus=[],[]\n\nfor i in range(n):\n    if a[i] >= 0: aplus.append(a[i])\n    else: aminus.append(a[i])\n\n      \nif len(aplus) == 0 and k % 2 == 1:\n    asort = sorted(a,reverse=True)\n    ans = 1\n    for i in range(k):\n        ans = (ans * asort[i]) % MOD\n    print(ans)\n    return\n\nif n == k:\n    ans = 1\n    for i in range(k):\n        ans = (ans * a[i]) % MOD\n    print(ans)\n    return\n\nnewa = sorted(a,reverse=True,key=abs)\nnewaplus = sorted(aplus,reverse = True)\nnewaminus = sorted(aminus)\n\ncntp,cntm,pp,mm=0,0,0,0\n\nfor i in range(k):\n    if newa[i] >= 0:\n        cntp += 1\n        pp = i\n    else:\n        cntm += 1\n        mm = i\n\nif cntm % 2 == 1:\n    if cntp == 0:\n        newa[mm] = newaplus[cntp]\n    elif len(newaplus) == cntp:\n        newa[pp] = newaminus[cntm]\n    elif len(newaminus) == cntm:\n        newa[mm] = newaplus[cntp]\n    else:\n        if newa[pp] * newaplus[cntp] >= newa[mm] * newaminus[cntm]:\n            newa[mm] = newaplus[cntp]\n        else:\n            newa[pp] = newaminus[cntm]\n\nans = 1\nfor i in range(k):\n    ans = (ans * newa[i]) % MOD\n    \nprint(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA_neg = []\nA_pos = []\n\nfor i in range(N):\n  if A[i] <= 0:\n    A_neg.append(-A[i])\n  else:\n    A_pos.append(A[i])\n\nA_neg.sort(reverse=True)\nA_pos.sort(reverse=True)\n\nans = 1\n\nif K == N:\n  for i in range(N):\n    ans *= (A[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n\nelif K%2==1 and len(A_pos)==0:\n  for i in range(1, K+1):\n    ans *= ((-A_neg[-i])%1000000007)\n    ans %= 1000000007\n  print(ans)\n\nelse:\n  if K%2==1:\n    ans *= A_pos.pop(0)\n    K -= 1\n  buf = []\n  for i in range(len(A_pos)//2):\n    buf.append(A_pos[2*i]*A_pos[2*i+1])\n  for i in range(len(A_neg)//2):\n    buf.append(A_neg[2*i]*A_neg[2*i+1])\n  buf.sort(reverse=True)\n  for i in range(K//2):\n    ans *= (buf[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n  \n\n", "from math import log\nmod = int(1e9) + 7\nn, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\na.sort()\n\ndef sign(v):\n    if v == 0:\n        return 0\n    return 1 if v > 0 else -1\n\npref = [(0, 1)] * (n + 1)\nsuf = [(0, 1)] * (n + 1)\n\nc = 1\nsm = 0\nsgn = 1\nfor j in range(n):\n    c = c * a[j] % mod\n    sgn *= sign(a[j])\n    if a[j] != 0:\n        sm += log(abs(a[j]))\n    pref[j + 1] = (sgn * sm, c, sgn)\n\nc = 1\nsm = 0\nsgn = 1\nfor j in range(n):\n    c = c * a[n - j - 1] % mod\n    sgn *= sign(a[n - j - 1])\n    if a[n - j - 1] != 0:\n        sm += log(abs(a[n - j - 1]))\n    suf[j + 1] = (sgn * sm, c, sgn)\n\nm = max(pref[k], suf[k])\nfor i in range(1, k):\n    sgn = pref[i][2] * suf[k - i][2]\n    pm = pref[i][1] * suf[k - i][1] % mod\n    sm = abs(pref[i][0]) + abs(suf[k - i][0])\n    m = max(m, (sgn * sm, pm, sgn))\n\n    \nprint((m[1]))\n", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nmod = pow(10, 9) + 7\nneg = 0\nzero = 0\nfor i in range(n):\n    if a[i] >= 0:\n        if a[i] == 0:\n            zero += 1\n        a[i] = [a[i], 1]\n    else:\n        a[i] = [-a[i], 0]\n        neg += 1\na.sort(reverse = True)\nans = 1\nif n == k:\n    for i in range(n):\n        ans *= a[i][0]\n        ans %= mod\n        if not a[i][1]:\n            ans *= -1\n            ans %= mod\nelif k % 2 == 1 and (neg == n or neg + zero == n):\n    for i in range(1, k + 1):\n        ans *= -a[-i][0]\n        ans %= mod\nelse:\n    pos, neg = 0, 0\n    lastpos, lastneg = mod, mod\n    for i in range(k):\n        ans *= a[i][0]\n        ans %= mod\n        if a[i][1]:\n            pos += 1\n            lastpos = a[i][0]\n        else:\n            neg += 1\n            lastneg = a[i][0]\n    if neg % 2 == 1:\n        firstpos, firstneg = mod, mod\n        for i in range(k, n):\n            if not firstpos == mod and not firstneg == mod:\n                break\n            if firstpos == mod and a[i][1]:\n                firstpos = a[i][0]\n            elif firstneg == mod and not a[i][1]:\n                firstneg = a[i][0]\n        if not mod in [lastpos, lastneg, firstpos, firstneg]:\n            if firstpos * lastpos >= firstneg * lastneg:\n                ans = ans * pow(lastneg, mod - 2, mod) * firstpos % mod\n            else:\n                ans = ans * pow(lastpos, mod - 2, mod) * firstneg % mod\n        elif not mod in [lastpos, firstneg]:\n            ans = ans * pow(lastpos, mod - 2, mod) * firstneg % mod\n        elif not mod in [lastneg, firstpos]:\n            ans = ans * pow(lastneg, mod - 2, mod) * firstpos % mod\nprint(ans)", "n,k=list(map(int,input().split()))\nA=sorted(list(map(int,input().split())))\n\n\nmod=10**9+7\n\nif A[-1]<0 and k%2==1:\n    now=1\n    for i in range(k):\n        now*=A[-i-1]%mod\n        now%=mod\n    print(now) ;return\n\nl=0 ; r=n-1\nans=1\nif k%2==1:\n    ans=A[-1]\n    r-=1\n\nfor i in range(k//2):\n    mi=A[l]*A[l+1]\n    pl=A[r]*A[r-1]\n    if mi>pl:\n        ans*= mi%mod\n        ans%=mod\n        l+=2\n    else:\n        ans*= pl%mod\n        ans%=mod\n        r-=2\nprint((ans%mod))\n", "# coding: utf-8\nN,K=map(int,input().split())\nA=list(map(int,input().split()))\nMOD=10**9+7\n\nans=1\n\nif K==N:\n    for i in range(N):\n        ans*=A[i]\n        if ans>0:\n            ans=ans%MOD\nelif max(A)<=0 and K%2==1:\n    A.sort(reverse=True)\n    for i in range(K):\n        ans*=A[i]\n        if ans>0:\n            ans=ans%MOD\nelse:\n    Ap=[]\n    Am=[]\n    \n    for i in range(N):\n        if A[i]>0:\n            Ap.append(A[i])\n        else:\n            Am.append(A[i])\n        \n\n    Ap.sort(reverse=True)\n    Am.sort()\n    \n    if K%2==1 and Ap:\n        ans*=Ap.pop(0)\n    \n    P=[]\n    \n    for i in range(len(Ap)//2):\n        P.append(Ap[i*2]*Ap[i*2+1])\n    \n    for i in range(len(Am)//2):\n        P.append(Am[i*2]*Am[i*2+1])\n    \n    P.sort(reverse=True)\n    \n    for i in range(K//2):\n        ans*=P[i]\n        ans=ans%MOD\n\nprint(ans%MOD)", "N,K=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\nmod=10**9+7\nans=1\n\nif K%2==1 and A[-1]<0:\n    for i in range(K):\n        ans=ans*A[N-(i+1)]%mod\n    print(ans)\n    return\n\nl=0\nr=N-1\nif K%2==1:\n    ans=ans*A[r]\n    r-=1\n\nfor _ in range(K//2):\n    ml=A[l]*A[l+1]\n    mr=A[r]*A[r-1]\n    if ml>mr:\n        ans=ans*ml%mod\n        l+=2\n    else:\n        ans=ans*mr%mod\n        r-=2\n\nprint(ans)\n", "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n    \n\n    A_list.sort(key=lambda x: -abs(x))\n    A_plus = []\n    A_minus = []\n    mod = 10**9 + 7\n\n    for val in A_list:\n        if val >= 0:\n            A_plus.append(val)\n        else:\n            A_minus.append(val)\n    \n\n    if (not A_plus):\n        if (K % 2 == 0):\n            target_range = list(range(K))\n        else:\n            target_range = list(range(len(A_minus)-K, len(A_minus)))\n\n        ans = 1\n\n        for i in target_range:\n            ans *= A_minus[i]\n            ans %= mod\n        \n        print(ans)\n        return\n\n\n    if (not A_minus):\n        ans = 1\n\n        for i in range(K):\n            ans *= A_plus[i]\n            ans %= mod\n        \n        print(ans)\n        return\n\n\n    select = []\n    i_p = 0  # index of A_plus\n    i_m = 0  # index of A_minus\n\n\n    while (len(select) < K):\n        if (K - len(select)) == 1:\n            if i_p < len(A_plus):\n                select.append( A_plus[i_p] )\n                i_p += 1\n                break\n            \n            else:\n                ans = 1\n\n                for i in range( len(A_list)-K, len(A_list) ):\n                    ans *= A_list[i]\n                    ans %= mod\n\n                print(ans)\n                return\n\n\n        if (i_m + 1) < len(A_minus):\n            if (i_p + 1) < len(A_plus):\n                if abs( A_plus[i_p] * A_plus[i_p + 1] ) > abs( A_minus[i_m] * A_minus[i_m + 1] ):\n                    select.append( A_plus[i_p] )\n                    i_p += 1\n                else:\n                    select.extend( [ A_minus[i_m] , A_minus[i_m + 1] ] )\n                    i_m += 2\n\n            else:\n                select.extend( [ A_minus[i_m] , A_minus[i_m + 1] ] )\n                i_m += 2\n            \n        else:\n            select.append( A_plus[i_p] )\n            i_p += 1\n    \n\n    ans = 1\n \n    for i in range(K):\n        ans *= select[i]\n        ans %= mod\n    \n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n,k = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    mod = 10**9 + 7\n    ans, sign = 1, 1\n\n    l, r = 0, n-1\n\n    if k%2:\n        ans = A[r]\n        r-=1\n        k-=1\n        if ans < 0:\n            sign = -1\n    while k:\n        x = A[l]*A[l+1]\n        y = A[r]*A[r-1]\n\n        if x*sign > y*sign:\n            ans = x%mod * ans%mod\n            l+=2\n        else:\n            ans = y%mod * ans%mod\n            r-=2\n        k-=2\n    print((ans+mod)%mod)\nmain()", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nA_neg = []\nA_pos = []\n\nfor i in range(N):\n  if A[i] <= 0:\n    A_neg.append(-A[i])\n  else:\n    A_pos.append(A[i])\n\nA_neg.sort(reverse=True)\nA_pos.sort(reverse=True)\n\nans = 1\n\nif K == N:\n  for i in range(N):\n    ans *= (A[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n\nelif K%2==1 and len(A_pos)==0:\n  for i in range(1, K+1):\n    ans *= ((-A_neg[-i])%1000000007)\n    ans %= 1000000007\n  print(ans)\n\nelse:\n  if K%2==1:\n    ans *= A_pos.pop(0)\n    K -= 1\n  buf = []\n  if len(A_pos)>=2:\n    for i in range(len(A_pos)//2):\n      buf.append(A_pos[2*i]*A_pos[2*i+1])\n  if len(A_neg)>=2:\n    for i in range(len(A_neg)//2):\n      buf.append(A_neg[2*i]*A_neg[2*i+1])\n  buf.sort(reverse=True)\n  for i in range(K//2):\n    ans *= (buf[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n  \n\n", "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n    \n\n    A_list.sort(key=lambda x: -abs(x))\n    A_plus = []\n    A_minus = []\n    mod = 10**9 + 7\n\n    for val in A_list:\n        if val >= 0:\n            A_plus.append(val)\n        else:\n            A_minus.append(val)\n    \n\n    select = []\n    i_p = 0  # index of A_plus\n    i_m = 0  # index of A_minus\n\n    \n    while (len(select) < K):\n        if (K - len(select)) == 1:\n            if i_p < len(A_plus):\n                select.append( A_plus[i_p] )\n                i_p += 1\n                break\n            \n            else:\n                ans = 1\n\n                for i in range( len(A_list)-K, len(A_list) ):\n                    ans *= A_list[i]\n                    ans %= mod\n\n                print(ans)\n                return\n\n\n        if (i_m + 1) < len(A_minus):\n            if (i_p + 1) < len(A_plus):\n                if abs( A_plus[i_p] * A_plus[i_p + 1] ) > abs( A_minus[i_m] * A_minus[i_m + 1] ):\n                    select.append( A_plus[i_p] )\n                    i_p += 1\n                else:\n                    select.extend( [ A_minus[i_m] , A_minus[i_m + 1] ] )\n                    i_m += 2\n\n            else:\n                select.extend( [ A_minus[i_m] , A_minus[i_m + 1] ] )\n                i_m += 2\n            \n        else:\n            select.append( A_plus[i_p] )\n            i_p += 1\n    \n\n\n    ans = 1\n \n    for i in range(K):\n        ans *= select[i]\n        ans %= mod\n    \n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    mod = 10 ** 9+ 7\n    ans = 1\n\n    def answer(a):\n        ans =1\n        for x in a:\n            ans *= x\n            ans %= mod\n        return ans\n\n    if n == k:\n        print(answer(a))\n        return\n    a.sort(reverse=True, key= lambda x:abs(x))\n    if sum(x<0 for x in a[:k])%2 == 0:\n        print(answer(a[:k]))\n    else:\n        if all(x < 0 for x in a):\n            print(answer(a[-k:]))\n        else:\n            try:\n                x1, y1= min([x for x in a[:k] if x > 0]), min([x for x in a[k:] if x < 0])\n            except ValueError:\n                x1, y1 = 1, 0\n            try:\n                x2, y2= max([x for x in a[:k] if x < 0]),\\\n                    max([x for x in a[k:] if x >= 0])\n            except ValueError:\n                x2, y2 = 1, 0\n            if abs(x2*y1) > abs(x1*y2):           \n                a[a.index(x1)] = y1\n            else:\n                a[a.index(x2)] = y2\n            print(answer(a[:k]))\n            \n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA.sort()\n\nmod=10**9+7\n\nif A[-1]<0 and k%2==1:\n    now=1\n    for i in range(k):\n        now= now*A[-i-1]%mod\n        # now%=mod\n    print(now) ;return\n\nl=0 ; r=n-1\nans=1\nif k%2==1:\n    ans=A[-1]\n    r-=1\n\nfor i in range(k//2):\n    mi=A[l]*A[l+1]\n    pl=A[r]*A[r-1]\n    if mi>pl:\n        ans= ans*mi%mod\n        l+=2\n    else:\n        ans= ans*pl%mod\n        r-=2\nprint((ans%mod))\n", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0:\n  if zero >= 1 and k%2 == 1:\n    ans = 0\n  else:\n    if k%2:\n      minus.reverse()\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    A_list.sort(key=lambda x: -abs(x))\n    mod = 10**9 + 7\n\n    L_plus  = R_plus  = -1 # the Index of plus value\n    L_minus = R_minus = -1 # the Index of minus value\n    # L : between index 0 to (K-1)\n    # R : between index K to end\n\n\n    for i in range(K-1, -1, -1):\n        if (L_plus == -1) and (A_list[i] >= 0):\n            L_plus = i\n        if (L_minus == -1) and (A_list[i] < 0):\n            L_minus = i\n        if (L_plus != -1) and (L_minus != -1):\n            break\n    \n    for i in range(K,N):\n        if (R_plus == -1) and (A_list[i] >= 0):\n            R_plus = i\n        if (R_minus == -1) and (A_list[i] < 0):\n            R_minus = i\n        if (R_plus != -1) and (R_minus != -1):\n            break\n\n\n    cnt_minus = 0\n\n    for i in range(K):\n        if A_list[i] < 0:\n            cnt_minus += 1\n\n\n    if cnt_minus % 2 == 0:\n        target_idx = [0, K-1]\n    \n    else: # cnt_minus % 2 != 0\n        if (R_plus == -1) and \\\n           ( (L_plus == -1) or (R_minus == -1) ) :\n        \n            calc1 = calc2 = 0\n        \n        elif (R_plus != -1) and \\\n           ( (L_plus == -1) or (R_minus == -1) ) :\n        \n            calc1 = 1\n            calc2 = 0\n        \n        elif (R_plus == -1) and \\\n           ( (L_plus != -1) and (R_minus != -1) ) :\n        \n            calc1 = 0\n            calc2 = 1\n        \n        elif (R_plus != -1) and \\\n           ( (L_plus != -1) and (R_minus != -1) ) :\n            \n            calc1 = A_list[L_plus] * A_list[R_plus]\n            calc2 = A_list[L_minus] * A_list[R_minus]\n\n\n        if calc1 == calc2:\n            target_idx = [N-K, N-1]\n        \n        elif calc1 > calc2:\n            A_list[L_minus], A_list[R_plus] = A_list[R_plus], A_list[L_minus]\n            target_idx = [0, K-1]\n\n        elif calc1 < calc2:\n            A_list[L_plus], A_list[R_minus] = A_list[R_minus], A_list[L_plus]\n            target_idx = [0, K-1]\n\n\n    ans = 1\n\n    for i in range( target_idx[0], (target_idx[1] + 1) ):\n        ans *= A_list[i]\n        ans %= mod\n    \n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def myabs(n):\n    n = int(n)\n    if n>0:\n        return [n,1]\n    else:\n        return [abs(n),-1]\n\n\nN,K = map(int,input().split())\nA = list(map(myabs, input().split()))\nA.sort(reverse=True)\nMod = 10**9+7\n\ndef main(n,k,a,mod):\n    flag = True\n    for i in a:\n        if i[1]==1:\n            flag = False\n            break\n    if k%2==0:\n        flag = False\n\n    #All elements are negative and odd k\n    if flag:\n        ans = 1\n        for i in range(n-1,n-1-k,-1):\n            ans *= (a[i][0]*(-1))%mod\n            ans %= mod\n        print(ans)\n    else:\n        ans = [1,1]\n        neg_flag = False\n        min_neg = -1\n        min_pos = -1\n        for i in range(k):\n            if a[i][1]==-1:\n                if neg_flag == True:\n                    neg_flag = False\n                    ans[1] *= a[i][0]\n                    ans[0] = ans[1]\n                else:\n                    neg_flag = True\n                    ans[1] *= a[i][0]\n                    min_neg = i\n            else:\n                ans[0] *= a[i][0]\n                ans[1] *= a[i][0]\n                min_pos = i\n            ans[0] %= mod\n            ans[1] %= mod\n\n        if neg_flag and n!=k:\n            next_pos = -1\n            next_neg = -1\n            for i in range(k,n):\n                if next_pos==-1 and a[i][1]==1:\n                    next_pos = a[i][0]\n                elif next_neg==-1 and a[i][1]==-1:\n                    next_neg = a[i][0]\n                if next_pos>=0 and next_neg>=0:\n                    break\n            if min_pos==-1:\n                ans[0] *= next_pos%mod\n                ans[0] %= mod\n                print(ans[0])\n            elif a[min_neg][0]*next_neg>a[min_pos][0]*next_pos:\n                fin_ans = 1\n                for i in range(k):\n                    if i!=min_pos:\n                        fin_ans *= a[i][0]%mod\n                        fin_ans %= mod\n                fin_ans *= next_neg%mod\n                fin_ans %= mod\n                print(fin_ans)\n            else:\n                fin_ans = 1\n                for i in range(k):\n                    if i!=min_neg:\n                        fin_ans *= a[i][0]%mod\n                        fin_ans %= mod\n                fin_ans *= next_pos%mod\n                fin_ans %= mod\n                print(fin_ans)\n        elif n==k and neg_flag:\n            print((ans[1]*-1)%mod)\n        else:\n            print(ans[1])\n\n\n\n\ndef __starting_point():\n    main(N,K,A,Mod)\n__starting_point()", "import sys\nfrom collections import deque\n\nimport bisect\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    A.sort()\n\n    #    print(A)\n    pp = int(bisect.bisect_left(A, 0))\n    A_minus = deque(A[:pp])\n    A_plus = deque(A[pp:])\n\n    AA = deque([])\n    AAm = deque([])\n    if N == K:\n        ans = 1\n        for i in A:\n            ans *= i\n            ans %= mod\n        print((ans % mod))\n\n    elif K % 2 == 0:\n        ans = 1\n\n        while len(A_minus) >= 2:\n            a1 = A_minus.popleft()\n            a2 = A_minus.popleft()\n            AAm.append(a1 * a2)\n\n        while len(A_plus) >= 2:\n            a1 = A_plus.pop()\n            a2 = A_plus.pop()\n            AA.append(a1 * a2)\n\n        for i in range(K // 2):\n            if len(AAm) == 0:\n                temp = AA.popleft()\n            elif len(AA) == 0:\n                temp = AAm.popleft()\n            elif AAm[0] > AA[0]:\n                temp = AAm.popleft()\n            else:\n                temp = AA.popleft()\n            ans *= temp\n            ans %= mod\n        print((ans % mod))\n\n    elif len(A_plus) == 0:\n        ans = 1\n        for i in range(K):\n            ans *= A_minus.pop()\n            ans %= mod\n        print((ans % mod))\n\n    else:\n        ans = A_plus.pop()\n\n        while len(A_minus) >= 2:\n            a1 = A_minus.popleft()\n            a2 = A_minus.popleft()\n            AAm.append(a1 * a2)\n\n        while len(A_plus) >= 2:\n            a1 = A_plus.pop()\n            a2 = A_plus.pop()\n            AA.append(a1 * a2)\n\n        for i in range(K // 2):\n            if len(AAm) == 0:\n                temp = AA.popleft()\n            elif len(AA) == 0:\n                temp = AAm.popleft()\n            elif AAm[0] > AA[0]:\n                temp = AAm.popleft()\n            else:\n                temp = AA.popleft()\n            ans *= temp\n            ans %= mod\n        print((ans % mod))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,K = map(int, input().split())\nA = [int(a) for a in input().split()]\nmod = 10**9+7\n\nP = []\nM = []\nz = 0\nfor a in A:\n    if a > 0:\n        P.append(a)\n    elif a < 0:\n        M.append(a)\n    else:\n        z += 1\n\nP.sort()\nM.sort()\nans = 1\nif len(M) == 0 or N == K:\n    A.sort(reverse=True)\n    for i in range(K):\n        ans *= A[i]\n        ans %= mod\nelif len(P) == 0:\n    if K%2 == 0 and len(M) >= K:\n        for i in range(K):\n            ans *= M[i]\n            ans %= mod\n    elif K%2 == 1 and z == 0:\n        for i in range(-1, -K-1, -1):\n            ans *= M[i]\n            ans %= mod\n    else:\n        ans = 0\nelif N-z < K or (N-z == K and len(M)%2 == 1):\n    ans = 0\nelse:\n    L = []\n    for i in range(N):\n        if A[i] == 0:\n            continue\n        L.append((abs(A[i]), A[i]))\n    L.sort(reverse=True)\n    cnt = 0\n    lp = -1\n    lm = -1\n    for i in range(K):\n        if L[i][1] > 0:\n            lp = i\n        else:\n            lm = i\n            cnt += 1\n        ans *= L[i][0]\n        ans %= mod\n    if cnt%2 == 1:\n        p = -1\n        m = -1\n        for i in range(K, len(L)):\n            if p > 0 and m > 0:\n                break\n            if L[i][1] > 0 and p < 0:\n                p = L[i][0]\n            elif L[i][1] < 0 and m < 0:\n                m = L[i][0]\n        if p < 0:\n            ans *= m*pow(L[lp][0], mod-2, mod)\n        elif m < 0:\n            ans *= p*pow(L[lm][0], mod-2, mod)\n        elif lp >= 0 and L[lm][0]*m > L[lp][0]*p:\n            ans *= m*pow(L[lp][0], mod-2, mod)\n        else:\n            ans *= p*pow(L[lm][0], mod-2, mod)\n        ans %= mod\nprint(ans)", "DE = 10**9 + 7\nN, K = list(map(lambda x: int(x), input().split(' ')))\nA = list(map(lambda x: int(x), input().split(' ')))\n\ndef main():\n  A_posi = []\n  A_nega = []\n  for a in A:\n    if a > 0:\n      A_posi.append(a)\n    elif a < 0:\n      A_nega.append(-a)\n\n  len_posi = len(A_posi)\n  len_nega = len(A_nega)\n  \n  if len_posi + len_nega < K:\n    return 0\n\n  if (len_nega % 2 == 1 and K == len_posi + len_nega) or (K % 2 == 1 and len_posi == 0):\n    if len_posi + len_nega == N:\n      A_posi.sort()\n      A_nega.sort()\n      answer = 1\n      k = 0\n      for a in A_nega:\n        answer *= (- a) % DE\n        answer %= DE\n        k += 1\n        if k >= K:\n          break\n      else:\n        for a in A_posi:\n          answer *= a % DE\n          answer %= DE\n          k += 1\n          if k >= K:\n            break\n      return answer\n    else:\n      return 0\n  A_posi.sort(reverse=True)\n  A_nega.sort(reverse=True)\n  posi = 0\n  nega = 0\n  answer = 1\n\n  if K % 2 == 1:\n    answer = A_posi[0] % DE\n    posi = 1\n\n  while posi + nega + 2 <= K:\n    p = A_posi[posi] * A_posi[posi + 1] if posi + 1 < len_posi else 0\n    n = A_nega[nega] * A_nega[nega + 1] if nega + 1 < len_nega else 0\n    if p > n:\n      answer *= p % DE\n      answer %= DE\n      posi += 2\n    else:\n      answer *= n % DE\n      answer %= DE\n      nega += 2\n\n  return answer\n\nprint(main())", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter,defaultdict\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\nimport heapq\nsys.setrecursionlimit(10**6)\n# INF =  float(\"inf\")\nINF = 10**18\nimport bisect\nimport statistics\nmod = 10**9+7\n# mod = 998244353\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\n\nimport numpy as np\n\nx = np.argsort(list([-abs(x) for x in A]))\nB = []\nC = []\n\nfor xx in x:\n    B.append(A[xx])\n    C.append(np.sign(A[xx]))\n\nans = 1\ns = 1\nflag4 = 0\n\nfor i in range(K):\n    s *= C[i]\n\nif s < 0:\n    p = np.sign(B[K-1])\n    flag1 = 0\n    for i in range(K-1,-1,-1):\n        if C[i] == p*(-1):\n            idx1 = i\n            flag1 = 1\n            break\n\n    flag2 = 0\n    for i in range(K,N):\n        if C[i] == p*(-1):\n            idx2 = i\n            flag2 = 1\n            break\n\n    flag3 = 0\n    if flag1 == 1:\n        for i in range(K,N):\n            if C[i] == p:\n                idx3 = i\n                flag3 = 1\n                break\n\n    if flag1 and flag2 and flag3:\n        if abs(B[K-1])*abs(B[idx3]) <= abs(B[idx1])*abs(B[idx2]):\n            B[K-1] = B[idx2]\n        else:\n            B[idx1] = B[idx3]\n    elif flag1 and (not flag2) and flag3:\n        B[idx1] = B[idx3]\n    elif flag1 and flag2 and (not flag3):\n        B[K-1] = B[idx2]\n    elif (not flag1) and flag2:\n        B[K-1] = B[idx2]\n    else:\n        flag4 = 1\n\nif flag4:\n    for i in range(N-1,N-K-1,-1):\n        ans = (ans * (B[i] % mod)) % mod\nelse:\n    for i in range(K):\n        ans = (ans * (B[i] % mod)) % mod\n\nprint((ans % mod))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "mod=1000000007\nn,k=map(int, input().split())\nlst=list(map(int, input().split()))\nlst=sorted(lst)\np=1\nif lst[-1]==0 and k%2!=0:\n    print(0)\nelif lst[-1]<0 and k%2!=0:\n    for i in range(n-1,n-k-1,-1):\n        #print(p)\n        p=(p%mod*lst[i]%mod)%mod\n    #print(p)\n    print(p%mod)\nelse:\n    j=n-1\n    if k%2!=0:\n        p*=lst[j]\n        k-=1\n        j-=1\n    k=k//2\n    i=0\n    for x in range(k):\n        if lst[i]*lst[i+1]>lst[j]*lst[j-1]:\n            p=(p%mod*lst[i]%mod*lst[i+1]%mod)%mod\n            i+=2\n        else:\n            p=(p%mod*lst[j]%mod*lst[j-1]%mod)%mod\n            j-=2\n    #print(p)\n    print(p%mod)", "N,K=map(int,input().split())\nA=list(map(int,input().split()))\nA.sort()\ndiv=7+10**9\nans=1\nt=0\ni,j=0,N-1\n\nif A[-1]<0 and K%2==1:\n    for i1 in range(N-K,N):\n        ans*=A[i1]\n        ans%=div\nelse:\n    while t<K-1:\n        if A[i]*A[i+1]>A[j]*A[j-1]:\n            ans*=A[i]*A[i+1]\n            ans%=div\n            i+=2\n            t+=2\n        else:\n            ans*=A[j]\n            ans%=div\n            j+=-1\n            t+=1\n    if t==K-1:\n        ans*=A[j]\n        ans%=div\n\nprint(ans)", "def prod(li, MOD):\n    ret = 1\n    for a in li:\n        ret *= a\n        ret %= MOD\n    return ret\n\nN, K = list(map(int, input().split()))\nMOD = 1_000_000_007\naaa = list(map(int, input().split()))\nif N == K:\n    print((prod(aaa, MOD)))\n    return\naaa.sort(key=lambda x : abs(x))\nif sum(a < 0 for a in aaa[-K:]) % 2 == 0:\n    print((prod(aaa[-K:], MOD)))\nelse:\n    if all(a <= 0 for a in aaa):\n        bbb = aaa[:K]\n    else:\n        try:\n            x1, y1 = min([a for a in aaa[-K:] if a > 0]), min([a for a in aaa[:-K] if a < 0])\n        except:\n            x1, y1 = 1, 0\n        try:\n            x2, y2 = max([a for a in aaa[-K:] if a < 0]), max([a for a in aaa[:-K] if a >= 0])\n        except:\n            x2, y2 = 1, 0\n        bbb = aaa[-K:]\n        if abs(x2 * y1) > abs(x1 * y2):\n            bbb.remove(x1)\n            bbb.append(y1)\n        else:\n            bbb.remove(x2)\n            bbb.append(y2)\n    print((prod(bbb, MOD)))\n", "#!/usr/bin/env python3\nfrom functools import reduce\n\nmod = 10**9 + 7\nn, k, *a = list(map(int, open(0).read().split()))\na.sort(key=lambda x: abs(x))\nans = reduce(lambda a, b: (a * b) % mod, a[-k:])\n\nc = a[-k:]\nj = sum(i < 0 for i in c) % 2\nif j:\n    c = a[-k:]\n    neg = [i for i in c if i < 0]\n    pos = [i for i in c if i > 0]\n    b = sorted(a[:n - k])\n    if b == []:\n        print(ans)\n        return\n    if neg == []:\n        if pos[0] * b[0] < 0:\n            ans = ans * pow(pos[0], mod - 2, mod) * b[0] % mod\n        else:\n            ans = reduce(lambda a, b: (a * b) % mod, a[:k])\n    elif pos == []:\n        if neg[0] * b[-1] < 0:\n            ans = ans * pow(neg[0], mod - 2, mod) * b[-1] % mod\n        else:\n            ans = reduce(lambda a, b: (a * b) % mod, a[:k])\n    elif pos[0] * b[-1] < neg[0] * b[0] and pos[0] * b[0] < 0:\n        ans = ans * pow(pos[0], mod - 2, mod) * b[0] % mod\n    elif 0 > b[-1] * neg[0]:\n        ans = ans * pow(neg[0], mod - 2, mod) * b[-1] % mod\n    else:\n        ans = reduce(lambda a, b: (a * b) % mod, a[:k])\nprint(ans)\n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random,resource\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n,k = LI()\n    a = sorted(LI())\n\n    r = 1\n    i = n - 1\n    j = 0\n    if k % 2 == 1:\n        r = a[i]\n        i -= 1\n\n    mf = r < 0\n\n    for _ in range(k//2):\n        t = a[i] * a[i-1]\n        u = a[j] * a[j+1]\n        if (not mf and t >= u) or (mf and t < u):\n            r *= t\n            r %= mod\n            i -= 2\n        else:\n            r *= u\n            r %= mod\n            j += 2\n\n    return r\n\n\nprint(main())\n\n\n", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nX = sorted([a for a in A if a > 0])\nY = sorted([a for a in A if a < 0], key=lambda x: abs(x))\n\nif 2 * (min(K, len(Y)) // 2) + len(X) >= K:\n    ans = 1\n    if K % 2 == 1:\n        ans *= X.pop()\n        K -= 1\n\n    XX = [(x1 * x2) for x1, x2 in zip(*[iter(X[::-1])] * 2)]\n    YY = [(y1 * y2) for y1, y2 in zip(*[iter(Y[::-1])] * 2)]\n    ZZ = sorted(XX + YY)\n\n    for i in range(K // 2):\n        ans *= ZZ.pop()\n        ans %= MOD\n\n    print(ans)\n\nelif 0 in A:\n    print((0))\n\nelse:\n    ans = 1\n    Z = sorted(X + Y, key=lambda x: abs(x), reverse=True)\n    for i in range(K):\n        ans *= Z.pop()\n        ans %= MOD\n    print(ans)\n", "import sys\n \nn, k = list(map(int, input().split()))\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0 and k%2 ==1 :\n  if zero >= 1:\n    ans = 0\n  else:\n    minus.sort(reverse=True)\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2 == 1:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)\n", "MOD = 10**9 + 7\n\ndef prod(a):\n    res = 1\n    for x in a:\n        res = (res * x) % MOD\n    return res\n\ndef solve(n, k, a):\n    if k == 1:\n        return max(a)\n    elif k == n:\n        return prod(a)\n    elif (max(a) < 0) and (k % 2 == 1):\n        a = sorted(a, reverse=True)\n        return prod(a[:k])\n    else:\n        a = sorted(a, key=lambda x: -abs(x))\n        num_negative = len(list([x for x in a[:k] if x < 0]))\n        if num_negative % 2 == 0:\n            return prod(a[:k])\n        else:\n            i1, j1 = None, None\n            for i in range(k):\n                if a[i] < 0:\n                    i1 = i\n            for j in range(k,n):\n                if a[j] >= 0:\n                    j1 = j\n                    break\n            i2, j2 = None, None\n            for i in range(k):\n                if a[i] >= 0:\n                    i2 = i\n            for j in range(k, n):\n                if a[j] < 0:\n                    j2 = j\n                    break\n            if (i1 is None) or (j1 is None):\n                return prod(a[:i2] + a[i2+1:k] + [a[j2]])\n            elif (i2 is None) or (j2 is None):\n                return prod(a[:i1] + a[i1+1:k] + [a[j1]])\n            elif abs(a[j1] * a[i2]) > abs(a[i1] * a[j2]):\n                return prod(a[:i1] + a[i1+1:k] + [a[j1]])\n            else:\n                return prod(a[:i2] + a[i2+1:k] + [a[j2]])\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nprint((solve(n, k, a)))\n\n", "n,k=list(map(int,input().split()))\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nans=1\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  for i in a:\n    ans*=i; ans%=mod\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    ans*=nega[i]; ans%=mod\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  x=[]\n  for i in range(k):\n    x.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    mx=max(a[k:]); mn=min(a[k:]);\n    if abs(a[pi]*mx)<=abs(a[ni]*mn) and pi>=0:\n      x.append(mn); x.remove(a[pi]);\n    else:\n      x.append(mx); x.remove(a[ni]);\n  #print(x)\n  for i in range(k):\n    ans*=x[i]; ans%=mod;\n\nprint(ans)\n", "import numpy as np\nN,K=map(int, input().split())\nA =list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nif N==K:\n  ans0 = 1\n  for a in A[0:N]:\n    ans0 *= a\n    ans0 %= MOD\n  print(ans0)\n  return\nA=sorted(A)  \nif (K%2==1 and A[-1]<0):\n  ans1 = 1\n  for a in A[N-K:N]:\n    ans1 *= a\n    ans1 %= MOD\n  print(ans1)\n  return\n \nA=sorted(A, key=lambda x:abs(x), reverse=True)\nAA=[np.sign(i) for i in A]\n \nansA = 1\nfor a in A[0:K]:\n  ansA *= a\n  ansA %= MOD\nansAA = AA[0:K].count(-1)%2\nif ansA==0 or ansAA==0:\n  print(ansA)\n  return\n\nwhile ansA>0:\n  ansA-=MOD\n\nB1=A[0:K]\nC1=A[0:K]\nB2=sorted(A[K:N])\nBp=[i for i in A[0:K] if i>0]\nBm=[i for i in A[0:K] if i<0]\n \nif B2[0]>0:B2.insert(0,0)\nif B2[-1]<0:B2.insert(-1,0)\nif not Bp:Bp.insert(0,B1[-1])\nif not Bm:Bm.insert(0,B1[0])\n  \n#print(Bp,Bm,B2)\n#print(Bp[-1],B2[0])\nB1.remove(Bp[-1])\nB1.append(min(B2[0],0))\n#print(B1)\nansB = 1\nfor a in B1[0:K]:\n  ansB *= a\n  ansB %= MOD\n#print(Bm[-1],B2[-1])\nC1.remove(Bm[-1])\nC1.append(max(B2[-1],0))\n \nansC = 1\nfor a in C1[0:K]:\n  ansC *= a\n  ansC %= MOD\n#print(B1,C1)\n#print(ansB,ansC)\nBB1=[np.sign(i) for i in B1]\nansBB1 = BB1[0:K].count(-1)%2\nBB2=[np.sign(i) for i in C1]\nansBB2 = BB2[0:K].count(-1)%2\n#print(ansBB1,ansBB2)\nif ansBB1==1:\n  print(ansC)\n  return\nif ansBB2==1:\n  print(ansB)\n  return\n#print(B2[0]/Bp[-1],B2[-1]/Bm[-1])\n#print(Bp[-1]*B2[-1],Bm[0]*B2[0])\n\n#print(abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0]))\n#print(ansB,ansC)\nif abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0])>=0:\n  print(ansC)\nelse: print(ansB)", "import numpy as np\nN,K=map(int, input().split())\nA =list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nif N==K:\n  ans0 = 1\n  for a in A:\n    ans0 = ans0*a%MOD\n  print(ans0)\n  return\n\nA=sorted(A)  \nif (K%2==1 and A[-1]<0):\n  ans1 = 1\n  for a in A[N-K:N]:\n    ans1 = ans1*a%MOD\n  print(ans1)\n  return\n\nA=sorted(A, key=lambda x:abs(x), reverse=True)\nAA=[np.sign(i) for i in A]\n \nansA = 1\nfor a in A[0:K]:\n  ansA *= a\n  ansA %= MOD\nansAA = AA[0:K].count(-1)%2\nif ansA==0 or ansAA==0:\n  print(ansA)\n  return\n\nB1=A[0:K]\nC1=A[0:K]\nB2=sorted(A[K:N])\nBp=[i for i in A[0:K] if i>0]\nBm=[i for i in A[0:K] if i<0]\n\nif B2[0]>0:B2.insert(0,0)\nif B2[-1]<0:B2.insert(-1,0)\nif not Bp:Bp.insert(0,B1[-1])\nif not Bm:Bm.insert(0,B1[0])\n  \nB1.remove(Bp[-1])\nB1.append(min(B2[0],0))\n\nansB = 1\nfor a in B1[0:K]:\n  ansB *= a\n  ansB %= MOD\n\nC1.remove(Bm[-1])\nC1.append(max(B2[-1],0))\n \nansC = 1\nfor a in C1[0:K]:\n  ansC *= a\n  ansC %= MOD\n\nBB1=[np.sign(i) for i in B1]\nansBB1 = BB1[0:K].count(-1)%2\nBB2=[np.sign(i) for i in C1]\nansBB2 = BB2[0:K].count(-1)%2\nif ansBB1==1:\n  print(ansC)\n  return\nif ansBB2==1:\n  print(ansB)\n  return\n\nif abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0])>=0:\n  print(ansC)\nelse: print(ansB)", "MOD = 10**9 + 7\n\ndef modpow(a,n):\n    r=1\n    while n > 0:\n        if n%2==1:\n            r = r*a%MOD\n        a = a*a % MOD\n        n = n//2\n    return r\n\nN,K = map(int,input().split())\nAs = list(map(int,input().split()))\n\n\n\nAs.sort(key=lambda x:abs(x),reverse=True)\nAs_srt=sorted(As)\n\nif N==K or (As_srt[-1]<0 and K%2==1):\n    ans=1\n    for i in range(K):\n        ans *= As[N-i-1]\n        ans %= MOD\n    print(ans)\nelse:\n    ans = 1\n    sign = 1\n    for i in range(K):\n        ans *=As[i]\n        ans %=MOD\n        if As[i]<0:\n            sign *= -1\n    if sign < 0:\n        #print(As,ans) ###\n        # ans\u3092\u6b63\u306b\u3059\u308b\n        rm_p=None\n        rm_n=None\n        for i in range(K):\n            if rm_p!=None and rm_n!=None:\n                break\n            if rm_p==None and As[K-i-1]>0:\n                rm_p=As[K-i-1]\n            if rm_n==None and As[K-i-1]<0:\n                rm_n=As[K-i-1]\n        \n        apd_zp=None\n        apd_n=None\n        for i in range(N-K):\n            if apd_zp!=None and apd_n!=None:\n                break\n            if apd_zp==None and As[K+i]>=0:\n                apd_zp=As[K+i]\n            if apd_n==None and As[K+i]<0:\n                apd_n=As[K+i]\n        #print(rm_n,rm_p,apd_n,apd_zp) ###\n\n        if rm_n == None or apd_zp == None:\n            rm=rm_p\n            apd=apd_n\n        elif rm_p == None or apd_n == None:\n            rm=rm_n\n            apd=apd_zp\n        else:\n            if abs(rm_p * apd_zp) <= abs(rm_n * apd_n):\n               rm=rm_p\n               apd=apd_n\n            else:\n                rm=rm_n\n                apd=apd_zp\n        ans *= apd\n        ans %=MOD\n        rm_inv = modpow(rm,MOD-2)\n        ans *= rm_inv\n        ans %= MOD\n\n    print(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\n\nX = sorted([a for a in A if a >= 0])\nY = sorted([a for a in A if a < 0], key=lambda x: abs(x))\nans = 1\n\nif 2 * (min(K, len(Y)) // 2) + len(X) >= K:\n    if K % 2 == 1:\n        ans *= X.pop()\n        K -= 1\n\n    XX = [(x1 * x2) for x1, x2 in zip(*[iter(X[::-1])] * 2)]\n    YY = [(y1 * y2) for y1, y2 in zip(*[iter(Y[::-1])] * 2)]\n    ZZ = sorted(XX + YY)\n\n    for i in range(K // 2):\n        ans *= ZZ.pop()\n        ans %= MOD\n\nelse:\n    Z = sorted(X + Y, key=lambda x: abs(x), reverse=True)\n    for i in range(K):\n        ans *= Z.pop()\n        ans %= MOD\n\nprint(ans)\n", "import numpy as np\nN,K=map(int, input().split())\nA =list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nif N==K:\n  ans0 = 1\n  for a in A[0:N]:\n    ans0 *= a\n    ans0 %= MOD\n  print(ans0)\n  return\nA=sorted(A)  \nif (K%2==1 and A[-1]<0):\n  ans1 = 1\n  for a in A[N-K:N]:\n    ans1 *= a\n    ans1 %= MOD\n  print(ans1)\n  return\n\nA=sorted(A, key=lambda x:abs(x), reverse=True)\nAA=[np.sign(i) for i in A]\n \nansA = 1\nfor a in A[0:K]:\n  ansA *= a\n  ansA %= MOD\nansAA = AA[0:K].count(-1)%2\nif ansA==0 or ansAA==0:\n  print(ansA)\n  return\n\n#while ansA>0:\n#  ansA-=MOD\n\nB1=A[0:K]\nC1=A[0:K]\nB2=sorted(A[K:N])\nBp=[i for i in A[0:K] if i>0]\nBm=[i for i in A[0:K] if i<0]\n \nif B2[0]>0:B2.insert(0,0)\nif B2[-1]<0:B2.insert(-1,0)\nif not Bp:Bp.insert(0,B1[-1])\nif not Bm:Bm.insert(0,B1[0])\n  \nB1.remove(Bp[-1])\nB1.append(min(B2[0],0))\n\nansB = 1\nfor a in B1[0:K]:\n  ansB *= a\n  ansB %= MOD\n\nC1.remove(Bm[-1])\nC1.append(max(B2[-1],0))\n \nansC = 1\nfor a in C1[0:K]:\n  ansC *= a\n  ansC %= MOD\n\nBB1=[np.sign(i) for i in B1]\nansBB1 = BB1[0:K].count(-1)%2\nBB2=[np.sign(i) for i in C1]\nansBB2 = BB2[0:K].count(-1)%2\n\nif ansBB1==1:\n  print(ansC)\n  return\nif ansBB2==1:\n  print(ansB)\n  return\n\nif abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0])>=0:\n  print(ansC)\nelse: print(ansB)", "MOD = 10 ** 9 + 7\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nans = 1\nif N == K:\n    for a in A:\n        ans = ans * a % MOD\n    print(ans)\n    return\n\nminus = []\nplus = []\nfor a in A:\n    if a < 0:\n        minus.append(a)\n    else:\n        plus.append(a)\n\nif len(minus) == N:\n    if K % 2 == 0:\n        A.sort()\n    else:\n        A.sort(reverse=True)\n    for i in range(K):\n        ans = ans * A[i] % MOD\n    print(ans)\n    return\n\nminus.sort(reverse=True)\nplus.sort()\n\nif  K % 2:\n    ans *= plus.pop()\n\nB = []\n\nwhile len(minus) > 1:\n    a = minus.pop()\n    b = minus.pop()\n    B.append(a * b)\n\nwhile len(plus) > 1:\n    a = plus.pop()\n    b = plus.pop()\n    B.append(a * b)\n\nB.sort()\n\nfor i in range(K // 2):\n    ans = ans * B.pop() % MOD\n\nprint(ans)\n", "n,k=map(int,input().split())\nA=sorted(list(map(int, input().split())))\n\nmod=10**9+7\n\nif A[-1]<0 and k%2==1:\n    now=1\n    for i in range(k):\n        now*=A[-i-1]%mod\n        now%=mod\n    print(now)\n    return\n\t\nl=0\nr=n-1\nans=1\nif k%2==1:\n    ans=A[-1]\n#    print(ans)\n    r-=1\t\nfor i in range(k//2):\n    mi=A[l]*A[l+1]\n#    print(mi)\n    pl=A[r]*A[r-1]\n#    print(pl)\n    if mi>pl:\n        ans*= mi%mod\n        ans%=mod\n        l+=2\n    else:\n        ans*= pl%mod\n        ans%=mod\n        r-=2\n\t\t\nprint(ans%mod)", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0:\n  if zero >= 1 and k%2 == 1:\n    ans = 0\n  else:\n    if k%2 == 1:\n      minus.reverse()\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "N,K=list(map(int,input().split()))\nA=list(map(int,input().split()))\nA_neg = []\nA_pos = []\n \nfor i in range(N):\n  if A[i] <= 0:\n    A_neg.append(-A[i])\n  else:\n    A_pos.append(A[i])\n \nA_neg.sort(reverse=True)\nA_pos.sort(reverse=True)\n \nans = 1\n \nif K == N:\n  for i in range(N):\n    ans *= (A[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n \nelif K%2==1 and len(A_pos)==0:\n  for i in range(1, K+1):\n    ans *= ((-A_neg[-i])%1000000007)\n    ans %= 1000000007\n  print(ans)\n \nelse:\n  if K%2==1:\n    ans *= A_pos.pop(0)\n    K -= 1\n  buf = []\n  for i in range(len(A_pos)//2):\n    buf.append(A_pos[2*i]*A_pos[2*i+1])\n  for i in range(len(A_neg)//2):\n    buf.append(A_neg[2*i]*A_neg[2*i+1])\n  buf.sort(reverse=True)\n  for i in range(K//2):\n    ans *= (buf[i]%1000000007)\n    ans %= 1000000007\n  print(ans)\n  \n", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0 and k%2 ==1 :\n  if zero >= 1:\n    ans = 0\n  else:\n    minus.reverse()\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((len(plus)-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(len(minus)//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "from functools import reduce\n\nN, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nAp = [a for a in A if a>0]\nAm = [a for a in A if a<0]\nmod = 10**9+7\nif len(Ap) + len(Am) < K:\n    print((0))\n    return\nif len(Ap) + len(Am) == K:\n    if 0 in A and len(Am) % 2:\n        print((0))\n    else:\n        ans = reduce(lambda a, b: a * b % mod, Ap+Am, 1)\n        print(ans)\n    return\nAp.sort(reverse=True)\nAm.sort()\nif len(Ap) == 0:\n    if K%2:\n        if 0 in A:\n            ans = 0\n        else:\n            ans = reduce(lambda a, b: a*b%mod, Am[-K:], 1)\n    else:\n        ans = reduce(lambda a, b: a*b%mod, Am[:K], 1)\n    print(ans)\n    return\n\nidx_Am = 0\nn = 0\nans = 1\nfor idx_Ap, ap in enumerate(Ap+[0]):\n    while idx_Am < len(Am) and n < K and -Am[idx_Am] > ap:\n        ans = ans * Am[idx_Am] % mod\n        idx_Am += 1\n        n += 1\n    if n == K:\n        break\n    n += 1\n    idx_Ap += 1\n    ans = ans * ap % mod\n    if n == K:\n        break\nelse:\n    assert False\nif idx_Am % 2 == 0:\n    print(ans)\nelse:\n    if idx_Ap == len(Ap) or (idx_Am != len(Am) and idx_Ap > 0 and Am[idx_Am] * Am[idx_Am-1] > Ap[idx_Ap] * Ap[idx_Ap-1]):\n        ans = ans * Am[idx_Am] * pow(Ap[idx_Ap-1], mod-2, mod) % mod\n    else:\n        ans = ans * Ap[idx_Ap] * pow(Am[idx_Am-1], mod-2, mod) % mod\n    print(ans)\n", "n,k = list(map(int,input().split()))\na = list(map(int,input().split()))\n\ns = sorted(a,reverse=True)\nmod = 10**9 + 7\nans = 1\n#\u5168\u90e8\u306e\u8981\u7d20\u304c\u8ca0\u306e\u6570\u3067\u3042\u308a\u5947\u6570\u500b\u306e\u5834\u5408\u306f\u5927\u304d\u3044\u9806\u306b\u53d6\u3063\u305f\u3082\u306e\u304c\u7b54\u3048\nif k % 2 == 1 and s[0] < 0:\n        for i in range(k):\n            ans = ans * s[i] % mod\n        print(ans)\n        return#\u7d42\u4e86\n\nl = 0\nr = n - 1\n#\u6b21\u306e\u51e6\u7406\u306e\u305f\u3081\u306e\u8a08\u7b97\u3000\uff08k\u304c\u5947\u6570\u3060\u3063\u305f\u5834\u5408)\n#\u3053\u306e\u51e6\u7406\u306e\u5fc5\u8981\u6027\n#\u5947\u6570\u500b\u3060\u3063\u305f\u5834\u5408\u4e09\u500b\u306e\u3046\u3061\u4e8c\u3064\u3067\u6b63\u306e\u6570\u306e\u6700\u5927\u5024\u3092\u4f5c\u308c\u3070\u826f\u3044\nif k % 2 == 1:\n  ans = ans * s[l]\n  l += 1\n\n\nfor _ in range(k // 2):\n  ml = s[l] * s[l + 1]\n  mr = s[r] * s[r - 1]\n  if ml > mr:\n    ans = ans * ml % mod\n    l += 2\n  else:\n    ans = ans * mr % mod\n    r -= 2\n\nprint(ans)\n", "from collections import deque\n\nN, K = map(int, input().split())\ntable = list(map(int, input().split()))\njnum = K - sum(1 for i in table if i >= 0)\nnum_mins = sum(1 for i in table if i < 0)\nq_plus = deque(sorted([i for i in table if i >= 0], reverse=True))\nq_mins = deque(sorted([-i for i in table if i < 0], reverse=True))\ns_plus = []\ns_mins = []\ntotal = 1\n\n\n# if jnum < 0 or jnum % 2 == 0:\nif (K % 2 == 1 and N == num_mins) or (N == K and num_mins % 2 == 1):\n    for i in range(K):\n        if not q_plus:\n            total = -total * q_mins.pop() % (10 ** 9 + 7)\n        elif not q_mins:\n            total = total * q_plus.pop() % (10 ** 9 + 7)\n        elif q_plus[-1] > q_mins[-1]:\n            total = -total * q_mins.pop() % (10 ** 9 + 7)\n        else:\n            total = total * q_plus.pop() % (10 ** 9 + 7)\n    total = total % (10 ** 9 + 7)\nelse:\n    for i in range(K):\n        if not q_plus:\n            s_mins.append(q_mins.popleft())\n        elif not q_mins:\n            s_plus.append(q_plus.popleft())\n        elif q_plus[0] > q_mins[0]:\n            s_plus.append(q_plus.popleft())\n        else:\n            s_mins.append(q_mins.popleft())\n    if len(s_mins) % 2 == 1:\n        if not q_plus:\n            s_plus[-1] = q_mins[0]\n        elif not q_mins or not s_plus:\n            s_mins[-1] = q_plus[0]\n        elif q_mins[0] * s_mins[-1] > q_plus[0] * s_plus[-1]:\n            s_plus[-1] = q_mins[0]\n        else:\n            s_mins[-1] = q_plus[0]\n    s_plus.extend(s_mins)\n    for j in s_plus:\n        total = total * j % (10 ** 9 + 7)\n\n\nprint(total)", "n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\na.sort()\nmod=10**9+7\nans=1\ni=0\nj=-1\nk_1=k\nwhile k_1>1:\n  if a[i]*a[i+1]>a[j]*a[j-1]:\n    ans=ans*a[i]*a[i+1]%mod\n    i+=2\n    k_1-=2\n  else:\n    ans=ans*a[j]%mod\n    j-=1\n    k_1-=1\nif k_1==1:\n  ans=ans*a[j]%mod\nif a[-1]<0 and k%2==1:\n  ans=1\n  for i in a[n-k:]:\n    ans=ans*i%mod\nprint(ans)\n", "n,k=list(map(int,input().split()))\nA=sorted(list(map(int,input().split())))\n\n\nmod=10**9+7\n\nif A[-1]<0 and k%2==1:\n    now=1\n    for i in range(k):\n        now*=A[-i-1]%mod\n        now%=mod\n    print(now) ;return\n\nl=0 ; r=n-1\nans=1\nif k%2==1:\n    ans=A[-1]\n    r-=1\n\nfor i in range(k//2):\n    mi=A[l]*A[l+1]\n    pl=A[r]*A[r-1]\n    if mi>pl:\n        ans*= mi%mod\n        ans%=mod\n        l+=2\n    else:\n        ans*= pl%mod\n        ans%=mod\n        r-=2\nprint((ans%mod))\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nv=[]\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  v=a\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    v.append(nega[i])\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  for i in range(k):\n    v.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    mx=max(a[k:]); mn=min(a[k:]);\n    if pi>=0 and abs(a[pi]*mx)<=abs(a[ni]*mn):\n      v.append(mn); v.remove(a[pi]);\n    else:\n      v.append(mx); v.remove(a[ni]);\n\nans=1\nfor i in range(k):\n  ans*=v[i]; ans%=mod;\n\nprint(ans)", "MOD = 10 ** 9 + 7\n\nn, k = list(map(int, input().split()))\nalst = list(map(int, input().split()))\n\nalst.sort()\n\nif n == k:\n    ans = 1\n    for num in alst:\n        ans *= num\n        ans %= MOD\n    print(ans)\n    return\n\nif k == 1:\n    print((alst[-1] % MOD))\n    return\n\nif alst[0] >= 0:\n    ans = 1\n    alst.sort(reverse = True)\n    for i in range(k):\n        ans *= alst[i]\n        ans %= MOD\n    print(ans)\n    return\n\nif alst[-1] <= 0:\n    ans = 1\n    if k % 2 == 1:\n        alst = alst[::-1]\n    for i in range(k):\n        ans *= alst[i]\n        ans %= MOD\n    print(ans)\n    return\n\nblst = []\nfor num in alst:\n    try:\n        blst.append([abs(num), abs(num) // num])\n    except ZeroDivisionError:\n        blst.append([abs(num), 0])\nblst.sort(reverse = True,key = lambda x:x[0])\nif blst[k - 1] == 0:\n    print((0))\n    return\n    \nminus = 0\nlast_minus = 0\nlast_plus = 0\nans_lst = []\nfor i in range(k):\n    if blst[i][1] == -1:\n        minus += 1\n        last_minus = blst[i][0]\n    elif blst[i][1] == 1:\n        last_plus = blst[i][0]\n    else:\n        print((0))\n        return\n    ans_lst.append(blst[i][0])\n\nnext_minus = 0\nnext_plus = 0\nflg_minus = False\nflg_plus = False\n\nfor i in range(k, n):\n    if blst[i][1] == -1 and (not flg_minus):\n        next_minus = blst[i][0]\n        flg_minus = True\n    if blst[i][1] == 1 and (not flg_plus):\n        next_plus = blst[i][0]\n        flg_plus = True\n    if (flg_plus and flg_minus) or blst[i][1] == 0:\n        break\n\nif minus % 2 == 0:\n    ans = 1\n    for num in ans_lst:\n        ans *= num\n        ans %= MOD\n    print(ans)\n\nelse:\n    minus_s = last_minus * next_minus\n    plus_s = last_plus * next_plus\n    ans = 1\n    if minus == k:\n        ans_lst.remove(last_minus)\n        ans_lst.append(next_plus)\n    elif minus_s == plus_s == 0:\n        if next_minus == 0:\n            ans_lst.remove(last_minus)\n            ans_lst.append(next_plus)\n        else:\n            print((0))\n            return\n        \n    elif minus_s > plus_s:\n        ans_lst.remove(last_plus)\n        ans_lst.append(next_minus)\n    else:\n        ans_lst.remove(last_minus)\n        ans_lst.append(next_plus)\n    for num in ans_lst:\n        ans *= num\n        ans %= MOD\n    print(ans)\n", "n,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\nmod=10**9+7\nflag=0\n\nA.sort()\n\ntmp1=1\ntmp2=1\n\nl=0\nr=n-1\nif k%2==1:\n    tmp1=A[-1]%mod\n    r-=1\n    if A[-1]<0:\n        flag=1\nfor i in range(k//2):\n    vl=A[l]*A[l+1]\n    vr=A[r]*A[r-1]\n    if max(vl,vr)<0:\n        flag=1\n    if vl>vr:\n        l+=2\n        tmp1*=vl\n    else:\n        r-=2\n        tmp1*=vr\n    tmp1%=mod\n\nfrom bisect import bisect_right\nidx=bisect_right(A,0)\nif idx==n:\n    idx-=1\nl=max(0,idx-1)\nr=idx\nfor i in range(k):\n    vl=A[l] if l>=0 else mod\n    vr=A[r] if r<n else mod\n    if abs(vl)<abs(vr) or r==n:\n        l-=1\n        tmp2*=vl\n    else:\n        r+=1\n        tmp2*=vr\n    tmp2%=mod\n\nif flag==0:\n    print(tmp1)\nelse:\n    print(tmp2)\n\n", "#/usr/bin/python\n\ndef solve():\n    n, k = list(map(int, input().split()))\n    a = sorted(map(int, input().split()), reverse=True)\n\n    mod = 10 ** 9 + 7\n    l = 0\n    r = n - 1\n    ans = 1\n\n    if k % 2 == 1:\n        ans = a[0]\n        l = 1\n\n    # If the maximum number is negative and k is odd, the answer is the product of the first k numbers.\n    if ans < 0:\n        mul = 1\n        for i in range(k):\n            mul = mul * a[i] % mod\n        return mul\n\n    # otherwise, multiply the leftmost two products and the rightmost two products, whichever is larger.\n    for i in range(k//2):\n        l_mul = a[l] * a[l+1]\n        r_mul = a[r] * a[r-1]\n        if l_mul >= r_mul:\n            ans = ans * l_mul % mod\n            l += 2\n        else:\n            ans = ans * r_mul % mod\n            r -= 2\n\n    return ans\n\nprint((solve()))\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nv=[]\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  for i in a:\n    v.append(i)\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    v.append(nega[i])\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  for i in range(k):\n    v.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    mx=max(a[k:]); mn=min(a[k:]);\n    if pi>=0 and abs(a[pi]*mx)<=abs(a[ni]*mn):\n      v.append(mn); v.remove(a[pi]);\n    else:\n      v.append(mx); v.remove(a[ni]);\n\nans=1\nfor i in range(k):\n  ans*=v[i]; ans%=mod;\n\nprint(ans)", "from copy import deepcopy\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nmod = 10 ** 9 + 7\nans = 1\ni, j = 0, n - 1\nk2 = deepcopy(k)\nwhile k2 > 1:\n    if a[i] * a[i + 1] > a[j] * a[j - 1]:\n        ans *= a[i] * a[i + 1]\n        ans %= mod\n        i += 2\n        k2 -= 2\n    else:\n        ans *= a[j]\n        j -= 1\n        ans %= mod\n        k2 -= 1\nif k2 == 1:\n    ans *= a[j]\n    ans %= mod\nif a[-1] < 0 and k % 2:\n    ans = 1\n    for i in range(n - k, n):\n        ans *= a[i]\n        ans %= mod\nprint(ans)", "MOD = (int) (1e9+7)\n\ndef power(a,n):\n    if a == 0: return 0\n    if n == 0: return 1\n\n    res = 1\n    while n > 0:\n        if n % 2 == 1: res = res * a % MOD\n        a = a * a % MOD\n        n //= 2\n\n    return res\n\ndef inverse(n):\n    return power(n, MOD-2)\n\nN, K = list(map(int,input().split()))\nA = list(map(int,input().split()))\n\nB = []\npos, neg = 0, 0\nfor a in A:\n    if a > 0:\n        B.append([a,1])\n        pos += 1\n    if a < 0:\n        B.append([-a,-1])\n        neg += 1\n    if a == 0:\n        B.append([0,0])\nB.sort(reverse=True)\n\nans, sign  = 1, 1\nif N == neg and K % 2 == 1:\n    for i in range(K):\n        ans *= B[N-1-i][0] \n        ans %= MOD\n    print((-ans % MOD))\n    return\n\nfor i in range(K):\n    ans *= B[i][0]\n    ans %= MOD\n    sign *= B[i][1]\n\nif N == K:\n    if sign >= 0: print(ans)\n    else: print((-ans % MOD))\n    return\n\nif sign < 0:\n    out_neg, out_pos = 0, 0\n    in_pos, in_neg = 0, 0\n\n    for i in range(K):\n        if B[K-1-i][1] < 0:\n            out_neg = B[K-1-i][0]\n            break\n    \n    for i in range(K):\n        if B[K-1-i][1] > 0:\n            out_pos = B[K-1-i][0]\n            break\n    \n    for i in range(N-K):\n        if B[K+i][1] > 0:\n            in_pos = B[K+i][0]\n            break\n    \n    for i in range(N-K):\n        if B[K+i][1] < 0:\n            in_neg = B[K+i][0]\n            break\n    \n\n    if in_neg == 0 or out_pos == 0:\n        ans = (ans * in_pos % MOD) * inverse(out_neg) % MOD\n    elif in_pos == 0 or out_neg == 0:\n        ans = (ans * in_neg % MOD) * inverse(out_pos) % MOD\n    else:\n        if out_pos * in_pos < out_neg * in_neg:\n            ans = (ans * in_neg % MOD) * inverse(out_pos) % MOD\n        else:\n            ans = (ans * in_pos % MOD) * inverse(out_neg) % MOD\n            \nprint(ans)\n", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\n\nv=[]\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  v=a\nelif k%2 and max(a)<0:\n  # \u7b54\u3048\u306f\u8ca0\n  v=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)[:k]\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  for i in range(k):\n    v.append(a[i])\n    if a[i]<0: ni=i; cnt^=1\n    if a[i]>0: pi=i;\n  if cnt%2:\n    mx=max(a[k:]); mn=min(a[k:]);\n    if pi>=0 and abs(a[pi]*mx)<=abs(a[ni]*mn):\n      v.append(mn); v.remove(a[pi]);\n    else:\n      v.append(mx); v.remove(a[ni]);\n\nans=1\nfor i in range(k):\n  ans*=v[i]; ans%=mod;\n\nprint(ans)", "N,K=list(map(int, input().split()))\nA=list(map(int, input().split()))\nD,E=[],[]\nzcnt,scnt,fcnt=0,0,0\nfor i in A:\n  if i==0:\n    zcnt+=1\n    D.append(0)\n  elif i>0:\n    D.append(i)\n    scnt+=1\n  else:\n    E.append(i)\n    fcnt+=1\nmod=10**9+7\nans=1\nif K==N:\n  for i in A:\n    ans*=i\n    ans%=mod\n  print(ans)\n  return\n#\u30de\u30a4\u30ca\u30b9\u3092\u5947\u6570\u500b\u7d76\u5bfe\u304b\u3051\u308b\u2192\u78ba\u5b9f\u306b\u7b54\u3048\u306f\u30de\u30a4\u30ca\u30b9\nif K%2==1 and max(A)<0:\n  A=sorted(A)[::-1]\n  for i in range(K):\n    ans*=A[i]\n    ans%=mod\n  print(ans)\n  return\n#\u7d76\u5bfe0\u3092\u304b\u3051\u306a\u304d\u3083\u3044\u3051\u306a\u3044\nif K>scnt+fcnt:\n  print((0))\n  return\nD,E=sorted(D)[::-1],sorted(E)\n#print(D,E)\nans=1\ncnt=0\na,b=0,0\nwhile K-cnt>1:\n  if a+1<=len(D)-1 and b+1<=len(E)-1:\n    d,e=D[a]*D[a+1],E[b]*E[b+1]\n    if d>e:\n      ans*=D[a]\n      a+=1\n      cnt+=1\n      ans%=mod\n    else:\n      ans*=e\n      b+=2    \n      ans%=mod\n      cnt+=2\n  elif a+1<=len(D)-1:\n    d=D[a]*D[a+1]\n    ans*=D[a]\n    a+=1\n    cnt+=1\n    ans%=mod\n  elif b+1<=len(E)-1:\n    e=E[b]*E[b+1]\n    ans*=e\n    b+=2\n    cnt+=2\n    ans%=mod\n\nif K-cnt==1:\n  Z=[]\n  if a!=scnt:\n    Z.append(D[a])\n  if b!=fcnt:\n    Z.append(E[-1])\n  if 0 in A:\n    Z.append(0)\n  ans*=max(Z)\n  ans%=mod\nprint(ans)\n", "import numpy as np\nN,K=map(int, input().split())\nA =list(map(int,input().split()))\nMOD = 10 ** 9 + 7\nif N==K:\n  ans0 = 1\n  for a in A:\n    ans0 = ans0*a%MOD\n  print(ans0)\n  return\n\nA=sorted(A)  \nif (K%2==1 and A[-1]<0):\n  ans1 = 1\n  for a in A[N-K:N]:\n    ans1 = ans1*a%MOD\n  print(ans1)\n  return\n\nA=sorted(A, key=lambda x:abs(x), reverse=True)\nAA=[np.sign(i) for i in A]\n \nansA = 1\nfor a in A[0:K]:\n  ansA = ansA*a%MOD\nansAA = AA[0:K].count(-1)%2\nif ansA==0 or ansAA==0:\n  print(ansA)\n  return\n\nB1=A[0:K]\nC1=A[0:K]\nB2=sorted(A[K:N])\nBp=[i for i in A[0:K] if i>0]\nBm=[i for i in A[0:K] if i<0]\n\nif B2[0]>0:B2.insert(0,0)\nif B2[-1]<0:B2.insert(-1,0)\nif not Bp:Bp.insert(0,B1[-1])\nif not Bm:Bm.insert(0,B1[0])\n  \nB1.remove(Bp[-1])\nB1.append(min(B2[0],0))\n\nansB = 1\nfor a in B1[0:K]:\n  ansB = ansB*a%MOD\n\nC1.remove(Bm[-1])\nC1.append(max(B2[-1],0))\n \nansC = 1\nfor a in C1[0:K]:\n  ansC = ansC*a%MOD\n\nBB1=[np.sign(i) for i in B1]\nansBB1 = BB1[0:K].count(-1)%2\nBB2=[np.sign(i) for i in C1]\nansBB2 = BB2[0:K].count(-1)%2\nif ansBB1==1:\n  print(ansC)\n  return\nif ansBB2==1:\n  print(ansB)\n  return\n\nif abs(Bp[-1]*B2[-1])-abs(Bm[-1]*B2[0])>=0:\n  print(ansC)\nelse: print(ansB)", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0 and k%2 ==1 :\n  if zero >= 1:\n    ans = 0\n  else:\n    minus.sort(reverse=True)\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2 == 1:\n    ans *= plus[0]\n    ans %= mod\n    q = 1\n  judge = []\n  for i in range((P-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(M//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "import sys\n \nn, k = map(int, input().split())\na = [int(x) for x in input().split()]\nmod = pow(10, 9)+7\nzero = 0\nplus = []\nminus = []\nfor i in range(n):\n  if a[i] == 0:\n    zero += 1\n  elif a[i] > 0:\n    plus.append(a[i])\n  else:\n    minus.append(a[i])\n \nP, M = len(plus), len(minus)\nplus.sort(reverse=True)\nminus.sort()\nans = 1\nif n == k:\n  for i in range(n):\n    ans *= a[i]\n    ans %= mod\nelif P+M < k:\n  ans = 0\nelif P == 0 and k%2 ==1 :\n  if zero >= 1:\n    ans = 0\n  else:\n    minus.sort(reverse=True)\n    for i in range(k):\n      ans *= minus[i]\n      ans %= mod\nelse:\n  q = 0\n  if k%2 == 1:\n    ans *= plus[0]\n    q = 1\n  judge = []\n  for i in range((P-q)//2):\n    judge.append(plus[2*i+q]*plus[2*i+q+1])\n  for i in range(M//2):\n    judge.append(minus[2*i]*minus[2*i+1])\n  judge.sort(reverse=True)\n  for i in range(k//2):\n    ans *= (judge[i]%mod)\n    ans %= mod\n \nprint(ans)", "N, K = list(map(int, input().split()))\nA = list(map(int, input().split()))\nMOD = 10**9+7\n\ndef solve():\n    A.sort(key=lambda x: abs(x), reverse=True)\n\n    ans = 1\n    nneg = 0\n    a, b, c, d = -1, -1, -1, -1\n    for k in range(K):\n        ans = (ans * A[k])%MOD\n        if A[k] < 0:\n            nneg += 1\n            b = k\n        else:\n            a = k\n    \n    if K == N or nneg%2 == 0:\n        return ans\n    \n    for k in range(N-1, K-1, -1):\n        if A[k] < 0:\n            d = k\n        else:\n            c = k\n\n    # b must be >= 0\n    if a == -1 and c == -1: # all minus\n        ans = 1\n        for k in range(K):\n            ans = (ans * A[-1-k])%MOD\n        return ans\n    \n    if a == -1 or d == -1:\n        outn = A[b]\n        inn = A[c]\n    elif c == -1:\n        outn = A[a]\n        inn = A[d]\n    else:\n        if A[a]*A[c] > A[b]*A[d]:\n            outn = A[b]\n            inn = A[c]\n        else:\n            outn = A[a]\n            inn = A[d]\n\n    ans = (ans * pow(outn, MOD-2, MOD))%MOD\n    ans = (ans * inn)%MOD\n    return ans\n\ndef __starting_point():\n    print((solve()))\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\n# import bisect\n# import numpy as np\n# from collections import deque\nfrom collections import deque\n# map(int, sys.stdin.read().split())\n#import itertools\n#import heapq\nimport bisect\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    A.sort()\n\n    #    print(A)\n    pp = int(bisect.bisect_left(A,0))\n    A_minus = deque(A[:pp])\n    A_plus = deque(A[pp:])\n\n    #    print(A_plus)\n    #    print(A_minus)\n    AA = deque([])\n    AAm = deque([])\n    if N == K:\n        ans = 1\n        for i in A:\n            ans *= i % mod\n            ans %=mod\n        print((ans % mod))\n\n    elif K % 2 == 0:\n        ans = 1\n\n        while len(A_minus) >= 2:\n            a1 = A_minus.popleft()\n            a2 = A_minus.popleft()\n            AAm.append(a1 * a2)\n\n        while len(A_plus) >= 2:\n            a1 = A_plus.pop()\n            a2 = A_plus.pop()\n            AA.append(a1 * a2)\n\n\n        for i in range(K // 2):\n            if len(AAm)==0:\n                temp = AA.popleft()\n            elif len(AA) ==0:\n                temp = AAm.popleft()\n            elif AAm[0] > AA[0]:\n                temp = AAm.popleft()\n            else:\n                temp = AA.popleft()\n            ans *= temp % mod\n            ans %=mod\n        print((ans % mod))\n\n    elif len(A_plus) == 0:\n        ans = 1\n        for i in range(K):\n            ans *= A_minus.pop() % mod\n            ans %=mod\n        print((ans % mod))\n\n    else:\n        ans = A_plus.pop()\n\n        while len(A_minus) >= 2:\n            a1 = A_minus.popleft()\n            a2 = A_minus.popleft()\n            AAm.append(a1 * a2)\n\n        while len(A_plus) >= 2:\n            a1 = A_plus.pop()\n            a2 = A_plus.pop()\n            AA.append(a1 * a2)\n\n        for i in range(K // 2):\n            if len(AAm) == 0:\n                temp = AA.popleft()\n            elif len(AA) == 0:\n                temp = AAm.popleft()\n            elif AAm[0] > AA[0]:\n                temp = AAm.popleft()\n            else:\n                temp = AA.popleft()\n            ans *= temp\n            ans %=mod\n        print((ans % mod))\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n\n\n    A_list.sort(key=lambda x: -abs(x))\n    mod = 10**9 + 7\n\n    L_plus  = R_plus  = -1 # the Index of plus value\n    L_minus = R_minus = -1 # the Index of minus value\n    # L : between index 0 to (K-1)\n    # R : between index K to end\n\n\n    for i in range(K-1, -1, -1):\n        if (L_plus == -1) and (A_list[i] >= 0):\n            L_plus = i\n        if (L_minus == -1) and (A_list[i] < 0):\n            L_minus = i\n        if (L_plus != -1) and (L_minus != -1):\n            break\n    \n    for i in range(K,N):\n        if (R_plus == -1) and (A_list[i] >= 0):\n            R_plus = i\n        if (R_minus == -1) and (A_list[i] < 0):\n            R_minus = i\n        if (R_plus != -1) and (R_minus != -1):\n            break\n\n\n    cnt_minus = 0\n\n    for i in range(K):\n        if A_list[i] < 0:\n            cnt_minus += 1\n\n\n    if cnt_minus % 2 == 0:\n        target = A_list[:K]\n    \n    else: # cnt_minus % 2 != 0\n        if (R_plus == -1) and \\\n           ( (L_plus == -1) or (R_minus == -1) ) :\n        \n            calc1 = calc2 = 0\n        \n        elif (R_plus != -1) and \\\n           ( (L_plus == -1) or (R_minus == -1) ) :\n        \n            calc1 = 1\n            calc2 = 0\n        \n        elif (R_plus == -1) and \\\n           ( (L_plus != -1) and (R_minus != -1) ) :\n        \n            calc1 = 0\n            calc2 = 1\n        \n        elif (R_plus != -1) and \\\n           ( (L_plus != -1) and (R_minus != -1) ) :\n            \n            calc1 = A_list[L_plus] * A_list[R_plus]\n            calc2 = A_list[L_minus] * A_list[R_minus]\n\n\n        if calc1 == calc2:\n            target = A_list[N-K:N]\n        \n        elif calc1 > calc2:\n            A_list[L_minus], A_list[R_plus] = A_list[R_plus], A_list[L_minus]\n            target = A_list[:K]\n\n        elif calc1 < calc2:\n            A_list[L_plus], A_list[R_minus] = A_list[R_minus], A_list[L_plus]\n            target = A_list[:K]\n\n\n    ans = 1\n\n    for i in range(len(target)):\n        ans *= target[i]\n        ans %= mod\n    \n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\nmod=10**9+7\nnega=sorted([a[i] for i in range(n) if a[i]<0],reverse=True)\n\nans=1\nif k==n:\n  # \u5168\u639b\u3051\u7b97\n  for i in a:\n    ans*=i; ans%=mod\nelif k%2 and n==len(nega):\n  # \u7b54\u3048\u306f\u8ca0\n  for i in range(k):\n    ans*=nega[i]; ans%=mod\nelse:\n  # \u7b54\u3048\u306f\u6b63\n  a=sorted(a, key=lambda x:abs(x), reverse=True)\n  pi=ni=-1; cnt=0;\n  x=[]\n  for i in range(k):\n    x.append(a[i])\n    if a[i]<0: ni=i; cnt+=1\n    if a[i]>0: pi=i;\n  if cnt%2:  \n    t=a[k:]\n    mx=max(t)\n    mn=min(t)\n    if pi==-1:\n      x.remove(a[ni])\n      x.append(mx)\n    #print(x,mx,mn)\n    elif mn>0: # \u3082\u3046\u6b63\u3057\u304b\u3068\u308c\u308b\u6570\u5024\u304c\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\n      x.append(mx)\n      x.remove(a[ni])\n    elif mx<=0: # \u3082\u3046\u8ca0\u3057\u304b\u3068\u308c\u308b\u6570\u5024\u304c\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\n      #if mx==0: print(0); return;\n      x.append(mn)\n      x.remove(a[pi])\n    elif abs(a[pi]*mx)<=abs(a[ni]*mn):\n      x.append(mn)\n      x.remove(a[pi])\n    else:\n      x.append(mx)\n      x.remove(a[ni])\n  #print(x)\n  for i in range(k):\n    ans*=x[i]; ans%=mod;\n\nprint(ans)", "mod = 10 ** 9 + 7\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nneg = []\nzero = 0\npos = []\nfor a in A:\n    if a < 0:\n        neg.append(a)\n    else:\n        pos.append(a)\n\npos.sort()\nneg.sort(reverse=True)\n\nif len(pos) == 0:\n    res = 1\n    if K % 2 == 0:\n        neg.reverse()\n    for a in neg[:K]:\n        res *= a\n        res %= mod\nelse:\n    res = 1\n    if K % 2 == 1:\n        res = pos.pop()\n        K -= 1\n    while K > 1 and len(pos) > 1 and len(neg) > 1:\n        if pos[-1] * pos[-2] > neg[-1] * neg[-2]:\n            res *= pos.pop()\n            res %= mod\n            res *= pos.pop()\n            res %= mod\n        else:\n            res *= neg.pop()\n            res %= mod\n            res *= neg.pop()\n            res %= mod\n        K -= 2\n    while K > 1 and len(pos) > 1:\n        res *= pos.pop()\n        res %= mod\n        res *= pos.pop()\n        res %= mod\n        K -= 2\n    while K > 1 and len(neg) > 1:\n        res *= neg.pop()\n        res %= mod\n        res *= neg.pop()\n        res %= mod\n        K -= 2\n    while K and pos:\n        res *= pos.pop()\n        res %= mod\n        K -= 1\n    while K and neg:\n        res *= neg.pop()\n        res %= mod\n        K -= 1\n\n\nprint(res)", "# -*- coding: utf-8 -*-\nimport sys\n\ndef main():\n    N,K = list(map(int, sys.stdin.readline().split()))\n    A_list = list(map(int, sys.stdin.readline().split()))\n    \n\n    A_list.sort(key=lambda x: -abs(x))\n    A_plus = []\n    A_minus = []\n    mod = 10**9 + 7\n\n    for val in A_list:\n        if val >= 0:\n            A_plus.append(val)\n        else:\n            A_minus.append(val)\n    \n\n    ans = 1\n    cnt = 0\n    i_p = 0  # index of A_plus\n    i_m = 0  # index of A_minus\n\n\n    while (cnt < K):\n        if (K - cnt) == 1:\n            if i_p < len(A_plus):\n                ans *= A_plus[i_p]\n                ans %= mod\n                cnt += 1\n                i_p += 1\n                break\n            \n            else:\n                ans2 = 1\n\n                for i in range( len(A_list)-K, len(A_list) ):\n                    ans2 *= A_list[i]\n                    ans2 %= mod\n\n                print(ans2)\n                return\n\n\n        if (i_m + 1) < len(A_minus):\n            if (i_p + 1) < len(A_plus):\n                if abs( A_plus[i_p] * A_plus[i_p + 1] ) > abs( A_minus[i_m] * A_minus[i_m + 1] ):\n                    ans *= A_plus[i_p]\n                    cnt += 1\n                    i_p += 1\n                else:\n                    ans *= (A_minus[i_m] * A_minus[i_m + 1])\n                    cnt += 2\n                    i_m += 2\n\n            else:\n                ans *= (A_minus[i_m] * A_minus[i_m + 1])\n                cnt += 2\n                i_m += 2\n            \n        else:\n            ans *= A_plus[i_p]\n            cnt += 1\n            i_p += 1\n        \n\n        ans %= mod\n    \n    \n    print(ans)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# AFTER EDITORIAL, WIP\n\ndef solve(ls, k, debug=0):\n    modulo = 10 ** 9 + 7\n    n = len(ls)\n    n_neg = 0\n    for i in range(n):\n        n_neg += ls[i] < 0\n    n_pos = n - n_neg\n\n    # Sort by abs\n    ls_abs = [abs(x) for x in ls]\n    ls_abs_argsort = sorted(list(range(n)), key=lambda i: -ls_abs[i])\n\n    # Check if positive result is impossible\n    if n_neg >= k:\n        positive = (k % 2 == 0) or (n_pos > 0)\n    else:\n        positive = (n_neg % 2 == 0) or (n > k)\n\n    # If positive is impossible, pick \"abs\" small ones\n    if not positive:\n        p = 1\n        for i in range(k):\n            x = ls[ls_abs_argsort[-1 - i]]\n            p *= x\n            p %= modulo\n        return p\n\n    #\n    # If positive is possible, ...\n    #\n    # PROP.\n    #   At most one swap is needed for making product non-negative.\n    #   PROOF. TODO\n    #\n\n    # Check sign when we pick \"abs\" large ones\n    s = 1\n    for i in range(k):\n        x = ls[ls_abs_argsort[i]]\n        s *= -1 if x < 0 else 1\n\n    # If non-negative, we take as it is\n    if s > 0:\n        p = 1\n        for i in range(k):\n            x = ls[ls_abs_argsort[i]]\n            p *= x\n            p %= modulo\n        return p\n\n    # If negative, ...\n    #   1. replace small negative with large positive, or\n    #   2. replace small positive with large negative\n    opt1 = None\n    opt2 = None\n    neg1 = pos1 = None\n    pos2 = neg2 = None\n\n    # Check if \"1\" is possible\n    swap_pos = None\n    for i in range(k, n):\n        if ls[ls_abs_argsort[i]] >= 0:\n            swap_pos = i\n            pos1 = ls[ls_abs_argsort[i]]\n            break\n\n    swap_neg = None\n    for i in range(k)[::-1]:\n        if ls[ls_abs_argsort[i]] < 0:\n            swap_neg = i\n            neg1 = ls[ls_abs_argsort[i]]\n            break\n\n    if swap_pos is not None and swap_neg is not None:\n        p = 1\n        p *= ls[ls_abs_argsort[swap_pos]]\n        p %= modulo\n        for i in range(k):\n            if i == swap_neg:\n                continue\n            x = ls[ls_abs_argsort[i]]\n            p *= x\n            p %= modulo\n        opt1 = p\n\n    # Check if \"2\" is possible\n    swap_pos = None\n    for i in range(k)[::-1]:\n        if ls[ls_abs_argsort[i]] >= 0:\n            swap_pos = i\n            pos2 = ls[ls_abs_argsort[i]]\n            break\n\n    swap_neg = None\n    for i in range(k, n):\n        if ls[ls_abs_argsort[i]] < 0:\n            swap_neg = i\n            neg2 = ls[ls_abs_argsort[i]]\n            break\n\n    if swap_pos is not None and swap_neg is not None:\n        p = 1\n        p *= ls[ls_abs_argsort[swap_neg]]\n        p %= modulo\n        for i in range(k):\n            if i == swap_pos:\n                continue\n            x = ls[ls_abs_argsort[i]]\n            p *= x\n            p %= modulo\n            opt2 = p\n\n    # Pick opt1 or opt2\n    if opt1 is None:\n        return opt2\n\n    if opt2 is None:\n        return opt1\n\n    if pos1 * pos2 > neg1 * neg2:\n        return opt1\n\n    return opt2\n\n\ndef main(istr, ostr):\n    n, k = list(map(int, istr.readline().strip().split()))\n    ls = list(map(int, istr.readline().strip().split()))\n    result = solve(ls, k)\n    print(result, file=ostr)\n\n\ndef __starting_point():\n    import sys\n\n    main(sys.stdin, sys.stdout)\n\n__starting_point()", "mod=10**9+7\nnum,k=map(int,input().rstrip().split())\nmai=list(map(int, input().rstrip().split()))\nmain=sorted(mai,key=abs,reverse=True)\nresult=1\ndef findplus_plus(x):\n    for i in range(x,len(main)):\n        if main[i]>=0:\n            return main[i]\n    return ''\ndef findplus_minus(x):\n    for i in range(x,len(main)):\n        if main[i]<0:\n            return main[i]\n    return ''\ndef findminus_plus(x):\n    for i in range(x-1,-1,-1):\n        if main[i]>=0:\n            return main[i]\n    return ''\ndef findminus_minus(x):\n    for i in range(x-1,-1,-1):\n        if main[i]<0:\n            return main[i]\n    return ''\n\nif num==k:\n    for i in main:\n        result*=i\n        result%=mod\nelif sorted(main)[len(sorted(main))-1]<0:\n    if (k%2)==0:\n        for i in range(k):\n            result*=main[i]\n            result%=mod\n    else:\n        for i in range(len(main)-1,len(main)-1-k,-1):\n            result*=main[i]\n            result%=mod\n\nelse:\n    count=0\n    for i in range(k):\n        if main[i]<0:\n            count+=1\n        result*=main[i]\n        result%=mod\n    if (count%2)==1:\n        minplus=findminus_plus(k)\n        minminus=findminus_minus(k)\n        maxplus=findplus_plus(k)\n        maxminus=findplus_minus(k)\n        if type(maxplus)==type(''):\n            plusplus=-1\n            minusminus=minminus*maxminus\n        else:\n            if type(maxminus)==type('') or type(minplus)==type(''):\n                minusminus=-1\n                plusplus=0\n            else:\n                minusminus=minminus*maxminus\n                plusplus=minplus*maxplus\n        if plusplus>minusminus:\n            main.remove(minminus)\n            result=1\n            for i in range(k-1):\n                result*=main[i]\n                result%=mod\n            result*=maxplus\n        elif plusplus<=minusminus:\n            main.remove(minplus)\n            result=1\n            for i in range(k-1):\n                result*=main[i]\n                result%=mod\n            result*=maxminus\n            \nprint(result%mod)", "import copy\nN, K=list(map(int,input().split()))\nA=list(map(int,input().split()))\nB=sorted([(a,abs(a)) for a in A],key=lambda x:x[1],reverse=True)\nR=10**9+7\nP=1\nminus=0\nlast_neg=-1\nlast_pos=-1\nfor i in range(K):\n    if B[i][0]>0:\n        if last_pos != -1:\n            P = (P * B[last_pos][1]) % R\n        last_pos=i\n    elif B[i][0]<0:\n        if last_neg != -1:\n            P = (P * B[last_neg][1]) % R\n        minus+=1\n        last_neg=i\n    else:\n        print((0))\n        return\nF=copy.copy(P)\nif last_pos!=-1:\n    F=(F*B[last_pos][1]) % R\nif last_neg!=-1:\n    F=(F*B[last_neg][1]) % R\nif minus%2==1:\n    if K == N:\n        print((-F %R))\n        return\n    first_neg=-1\n    first_pos=-1\n    count=[0,0]\n    for i in range(K,N):\n        if count[0]==0 and B[i][0]>0:\n            first_pos=i\n            count[0]=1\n        elif count[1]==0 and B[i][0]<0:\n            first_neg=i\n            count[1]=1\n        elif count==[1,1]:\n            break\n    if first_pos==-1 and last_pos==-1:\n        P = 1\n        for i in range(K):\n           P = (P * B[N - i - 1][0]) % R\n        print(P)\n        return\n    if first_pos==-1 and first_neg==-1:\n        print((0))\n        return\n    list_product=[]\n    if first_neg!=-1 and last_pos!=-1:\n        list_product.append(B[last_neg][1]*B[first_neg][1])\n    if first_pos!=-1:\n        P1=B[first_pos][1]\n        if last_pos!=-1:\n            P1=P1*B[last_pos][1]\n        list_product.append(P1)\n    print((max(list_product)*P %R))\nelse:\n    print(F)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    res = 1\n    if n == k:\n        for a in A:\n            res = (res * a) % mod\n        print(res)\n        return\n\n    P, M = [], []\n    for a in A:\n        P.append(a) if a >= 0 else M.append(a)\n\n    if len(P) == n:\n        A.sort(reverse=True)\n        for i in range(k):\n            res = (res * A[i]) % mod\n    elif len(M) == n:\n        A.sort(reverse=True) if k % 2 else A.sort()\n        for i in range(k):\n            res = (res * A[i]) % mod\n    else:\n        P.sort(reverse=True)\n        M.sort()\n        B = []\n        if k % 2:\n            k -= 1\n            b = P.pop(0)\n            B.append(b)\n            res = (res * b) % mod\n        for i in range(0, len(P), 2):\n            if i + 1 < len(P):\n                B.append(P[i] * P[i + 1])\n        for j in range(0, len(M), 2):\n            if j + 1 < len(M):\n                B.append(M[j] * M[j + 1])\n        B.sort(reverse=True)\n        for i in range(k // 2):\n            res = (res * B[i]) % mod\n\n    print(res)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n, k = map(int, input().split())\na = list(map(int, input().split()))\nmod = 10**9 + 7\nres = 1\na.sort(reverse=True)\nif a[0]<0 and k%2==1:\n    for i in range(k):\n        res = (res*a[i])%mod\nelse:\n    right = n-1\n    left = 0\n    while k > 1:\n        if a[right]*a[right-1] < a[left]*a[left+1]:\n            res = (res*a[left])%mod\n            left += 1\n            k -= 1\n        else:\n            res = (res*a[right]*a[right-1])%mod\n            right -= 2\n            k -= 2\n    if k == 1:\n        res = (res*a[left])%mod\n\nprint(res)", "#E_Multiplication4\nN,K = list(map(int,input().split()))\nA = list(map(int,input().split()))\nMOD = 1000000007\n#\u30bd\u30fc\u30c8\narr = []\nj = 0\ni = 0\nseki = 1\ngyaku = 1\nminuscount = 0\nminusposition = 0\n\ndef modpow(a,n,mod):\n    res = 1\n    while n > 0 :\n        if n & 1 :\n            res = res * a % mod\n        a = a * a % mod\n        n >>= 1\n    return res\ndef modinv(a,mod):\n    return modpow(a, mod - 2, mod)\n \narr = sorted(A,reverse = True)\nif arr[(N -1)] > 0 :\n    for i in range(K):\n        seki = seki * arr[i] % MOD\nelse:\n    if arr[0] < 0 :\n        for j in range(K):\n            if K % 2 == 1:\n                seki = seki * arr[j] % MOD\n            else:\n                seki = seki * arr[N-j-1] % MOD\n    else:\n        while (i + j) < K:\n            if (i + j + 1) < K :\n                if arr[i] * arr[i+1] > (arr[(N - j -1)] * arr[(N - j -2)]):\n                    seki = seki * arr[i] % MOD\n                    i += 1\n                else:\n                    minuscount += 2\n                    minusposition = N - j -2\n                    seki = (seki * arr[(N - j -1)] % MOD) * arr[(N - j -2)] % MOD\n                    j += 2\n            else:\n                if abs(arr[i]) > abs( arr[(N - j -1)]) :\n                    seki = seki * arr[i] % MOD\n                    i += 1\n                else:               \n                    minuscount += 1\n                    minusposition = N - j -1\n                    seki = seki * arr[(N - j -1)] % MOD\n                    j += 1\nif (minuscount % 2) != 0:\n    if minusposition != (i - 1):\n        gyaku = modinv(arr[minusposition],MOD)\n        seki  = seki * gyaku % MOD\n        seki  = seki * arr[i] % MOD\nprint(seki)\n", "n,k = list(map(int,input().split())); arr = list(map(int,input().split())); arr.sort(reverse=True)\nabsarr = [[abs(i), 1 if i>0 else -1 if i<0 else 0] for i in arr]; absarr.sort(reverse=True, key=lambda x: x[0])\nmod = 10**9+7\n\nzeroflag = True if absarr[-1][0] == 0 else False\nfrom collections import Counter\nposnegarr = Counter([i[1] for i in absarr[:k]])\npos = posnegarr[1]; neg = posnegarr[-1]\n\nif absarr[k-1] == 0:\n    ans = 0\nelif neg % 2 == 0 or n == k:\n    ans = 1\n    for i in absarr[:k]:\n        ans *= i[0]; ans %= mod\n    if n == k and neg % 2 == 1:\n        ans = -ans % mod\nelse:\n    ans = 1\n    for i in absarr[:k]:\n        ans *= i[0]; ans %= mod\n    if pos > 0:\n        if absarr[k][0] == 0:\n            ans = 0\n        nextpos = nextneg = 0\n        tmp = k\n        while tmp < n and (nextpos == 0 or nextneg == 0):\n            num = absarr[tmp]\n            if num[0] == 0:\n                break\n            elif num[1] > 0 and nextpos == 0:\n                nextpos = num[0]\n            elif num[1] < 0 and nextneg == 0:\n                nextneg = num[0]\n            tmp += 1\n        backpos = backneg = 0\n        tmp = k-1\n        while backpos == 0 or backneg == 0:\n            num = absarr[tmp]\n            if num[1] > 0 and backpos == 0:\n                backpos = num[0]\n            elif num[1] < 0 and backneg == 0:\n                backneg = num[0]\n            tmp -= 1\n        if ans == 0:\n            pass\n        elif nextpos*backpos > nextneg*backneg:\n            ans *= nextpos*pow(backneg,-1,mod); ans %= mod\n        else:\n            ans *= nextneg*pow(backpos,-1,mod); ans %= mod\n    else:\n        nextpos = 0\n        tmp = k\n        while tmp < n and nextpos == 0:\n            num = absarr[tmp]\n            if num[1] > 0:\n                nextpos = num[0]\n            tmp += 1\n        backneg = absarr[k-1][0]\n        if nextpos != 0:\n            ans *= nextpos * pow(backneg,-1,mod); ans %= mod\n        elif zeroflag:\n            ans = 0\n        else:\n            ans = 1\n            for i in arr[:k]:\n                ans *= i; ans %= mod\n        \nprint(ans)"]
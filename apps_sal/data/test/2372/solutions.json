["# import numpy as np\nfrom collections import deque\n\ndef solve(): #H, W, CH, CW, DH, DW, S):\n\tH,W=list(map(int,input().split()))\n\tCH,CW=list(map(int,input().split()))\n\tDH,DW=list(map(int,input().split()))\n\tS=[input() for _ in range(H)]\n\n\t# \u5f8c\u306e\u6761\u4ef6\u5206\u5c90\u3092\u7c21\u7565\u5316\u3059\u308b\u305f\u3081\u30ef\u30fc\u30d7\u3057\u3066\u3082\u8ff7\u8def\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u58c1\u3067\u56f2\u3080\n\tS = ['##{}##'.format(row) for row in S]\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\n\n\tMAX_COST = 10 ** 9\n\tCost=[ [ MAX_COST for _ in range(W+4)] for _ in range(H+4)]\n\t# Cost = np.full((H,W),MAX_COST)\n\n\t# print(S)\n\n\tans = -1\n\n\tcost0 = deque()\n\n\tcost0.append((CH+1,CW+1,0))\n\tCost[CH+1][CW+1] = 0;\n\n\t# used = set()\n\twalk=[(1,0),(0,1),(-1,0),(0,-1)]\n\twarp = [ (i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0, 0)] + walk ]\n\t# print(warp)\n\n\tcost1 = deque()\n\n\twhile cost0:\n\t\th,w,c=cost0.popleft()\n\t\tcost1.append((h,w,c))\n\n\t\tfor i,j in walk:\n\t\t\tdh = h+i\n\t\t\tdw = w+j\n\t\t\tif S[dh][dw] == '.' and c < Cost[dh][dw]:\n\t\t\t\tCost[dh][dw] = c\n\t\t\t\t# print(\"updl \", i,j,dh,dw,c)\n\t\t\t\tcost0.appendleft((dh,dw,Cost[dh][dw]))\n\n\t\tif len(cost0) == 0:\n\n\t\t\twhile cost1:\n\t\t\t\th,w,c=cost1.popleft()\n\t\t\t\t# print(h,w,c)\n\t\t\t\tfor i,j in warp:\n\t\t\t\t\tdh = h+i\n\t\t\t\t\tdw = w+j\n\t\t\t\t\t# print(i,j)\n\t\t\t\t\tif S[dh][dw] == '.' and c + 1 < Cost[dh][dw]:\n\t\t\t\t\t\tCost[dh][dw] = c + 1\n\t\t\t\t\t\tcost0.append((dh,dw,Cost[dh][dw]))\n\n\n\tif Cost[DH+1][DW+1] == MAX_COST:\n\t\tprint((-1))\n\telse:\n\t\tprint((Cost[DH+1][DW+1]))\n\n\ndef __starting_point():\n\n\t# S=[input() for _ in range(H)]\n\n\tsolve() #H, W, CH, CW, DH, DW, S)\n\n__starting_point()", "from collections import deque\n\n\ndef main():\n\n    def bfs(h1, w1, dp):\n        \"\"\"\n        -1 - unsearched\n        -2 - candidate for warp\n        -3 - wall '#'\n        \"\"\"\n        queue = deque()\n        queue_warp = deque()\n        queue.append([h1, w1])\n        now = 0\n\n        while queue:\n            h1, w1 = queue.popleft()\n            fl_up = False\n            fl_left = False\n            fl_down = False\n            fl_right = False\n\n            if h1 > 0:\n                if dp[h1-1][w1] == -1 or dp[h1-1][w1] == -2:\n                    if m[h1-1][w1] == '.':\n                        dp[h1-1][w1] = now\n                        queue.append([h1-1, w1])\n                    else:\n                        dp[h1-1][w1] = -3\n                if dp[h1-1][w1] == -3:\n                    fl_up = True\n                    if h1 > 1:\n                        if dp[h1-2][w1] == -1:\n                            if m[h1-2][w1] == '.':\n                                dp[h1-2][w1] = -2\n                                queue_warp.append([h1-2, w1])\n                            else:\n                                dp[h1-2][w1] = -3\n            \n            if w1 > 0:\n                if dp[h1][w1-1] == -1  or dp[h1][w1-1] == -2:\n                    if m[h1][w1-1] == '.':\n                        dp[h1][w1-1] = now\n                        queue.append([h1, w1-1])\n                    else:\n                        dp[h1][w1-1] = -3\n                if dp[h1][w1-1] == -3:\n                    fl_left = True\n                    if w1 > 1:\n                        if dp[h1][w1-2] == -1:\n                            if m[h1][w1-2] == '.':\n                                dp[h1][w1-2] = -2\n                                queue_warp.append([h1, w1-2])\n                            else:\n                                dp[h1][w1-2] = -3\n            \n            if h1 < h - 1:\n                if dp[h1+1][w1] == -1 or dp[h1+1][w1] == -2:\n                    if m[h1+1][w1] == '.':\n                        dp[h1+1][w1] = now\n                        queue.append([h1+1, w1])\n                    else:\n                        dp[h1+1][w1] = -3\n                if dp[h1+1][w1] == -3:\n                    fl_down = True\n                    if h1 < h - 2:\n                        if dp[h1+2][w1] == -1:\n                            if m[h1+2][w1] == '.':\n                                dp[h1+2][w1] = -2\n                                queue_warp.append([h1+2, w1])\n                            else:\n                                dp[h1+2][w1] = -3\n            \n            if w1 < w - 1:\n                if dp[h1][w1+1] == -1 or dp[h1][w1+1] == -2:\n                    if m[h1][w1+1] == '.':\n                        dp[h1][w1+1] = now\n                        queue.append([h1, w1+1])\n                    else:\n                        dp[h1][w1+1] = -3\n                if dp[h1][w1+1] == -3:\n                    fl_right = True\n                    if w1 < w - 2:\n                        if dp[h1][w1+2] == -1:\n                            if m[h1][w1+2] == '.':\n                                dp[h1][w1+2] = -2\n                                queue_warp.append([h1, w1+2])\n                            else:\n                                dp[h1][w1+2] = -3\n            \n            if fl_up and fl_left:\n                for i in range(max(0, h1-2), h1):\n                    for j in range(max(0, w1-2), w1):\n                        if dp[i][j] == -1:\n                            if m[i][j] == '.':\n                                dp[i][j] = -2\n                                queue_warp.append([i, j])\n                            else:\n                                dp[i][j] = -3\n\n            if fl_left and fl_down:\n                for i in range(h1+1, min(h, h1+3)):\n                    for j in range(max(0, w1-2), w1):\n                        if dp[i][j] == -1:\n                            if m[i][j] == '.':\n                                dp[i][j] = -2\n                                queue_warp.append([i, j])\n                            else:\n                                dp[i][j] = -3\n            \n            if fl_down and fl_right:\n                for i in range(h1+1, min(h, h1+3)):\n                    for j in range(w1+1, min(w, w1+3)):\n                        if dp[i][j] == -1:\n                            if m[i][j] == '.':\n                                dp[i][j] = -2\n                                queue_warp.append([i, j])\n                            else:\n                                dp[i][j] = -3\n\n            if fl_right and fl_up:\n                for i in range(max(0, h1-2), h1):\n                    for j in range(w1+1, min(w, w1+3)):\n                        if dp[i][j] == -1:\n                            if m[i][j] == '.':\n                                dp[i][j] = -2\n                                queue_warp.append([i, j])\n                            else:\n                                dp[i][j] = -3\n\n            if not queue:\n                now += 1\n                while queue_warp:\n                    h1, w1 = queue_warp.popleft()\n                    if dp[h1][w1] == -2:\n                        dp[h1][w1] = now\n                        queue.append([h1, w1])\n            \n            if dp[dh-1][dw-1] >= 0:\n                return dp[dh-1][dw-1]\n        \n        return dp[dh-1][dw-1]\n\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n\n    m = [[] for i in range(h)]\n    dp = [[-1]*w for i in range(h)]\n    dp[ch-1][cw-1] = 0\n    \n    for i in range(h):\n        m[i] = input()\n    \n    ans = bfs(ch-1, cw-1, dp)\n\n    print(ans)\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n    \n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    \n    \n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for i in range(h):\n        s.append(\"##\" + input()[:-1] + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n    \n    \n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[ch][cw] = 0\n    \n    move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), \\\n             (-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2), \\\n             (0, -2), (0, -1), (0, 0), (0, 1), (0, 2), \\\n             (1, -2), (1, -1), (1, 0), (1, 1), (1, 2), \\\n             (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n        \n    not_yet = [(ch, cw)]\n    one_time = []\n    \n    while len(not_yet) > 0:\n        x, y = not_yet.pop()\n        one_time.append((x, y))\n        for (p, q) in move:\n            v1, v2 = x+p, y+q\n            if ans[v1][v2] == -1:\n                not_yet.append((v1, v2))\n                ans[v1][v2] = ans[x][y]\n                \n        if len(not_yet) == 0:\n            while len(one_time) > 0:\n                x2, y2 = one_time.pop()\n                for (v1, v2) in move2:\n                    i, j = x2+v1, y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        not_yet.append((i, j))\n          \n    print((ans[dh][dw]))\n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n \ndef main():\n  h,w=map(int,input().split())\n  c1,c2=map(lambda x:int(x)+1,input().split())\n  d1,d2=map(lambda x:int(x)+1,input().split())\n  work1=[(1,0),(-1,0),(0,1),(0,-1)]\n  work2=[(i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0,0)]+work1]\n  memo=[\"#\"*(w+4)]*2+[\"##\"+input()+\"##\" for _ in range(h)]+[\"#\"*(w+4)]*2\n  dist=[[-1]*(w+4) for _ in range(h+4)]\n  for i in range(h+4):\n    for j in range(w+4):\n      if memo[i][j]==\"#\":\n        dist[i][j]=float(\"inf\")\n  que1=deque([(c1,c2)])\n  que2=deque([])\n  dist[c1][c2]=0\n  while que1:\n    y,x=que1.popleft()\n    score=dist[y][x]\n    que2.append((y,x))\n    for py,px in work1:\n      ny,nx=y+py,x+px\n      if dist[ny][nx]==-1:\n        dist[ny][nx]=score\n        que1.append((ny,nx))\n    if len(que1)==0:\n      while que2:\n        y,x=que2.popleft()\n        for py,px in work2:\n          ny,nx=y+py,x+px\n          if dist[ny][nx]==-1:\n            dist[ny][nx]=score+1\n            que1.append((ny,nx))\n  print(dist[d1][d2])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    dxys = [(-1,0), (1,0), (0,-1), (0,1)]\n\n    H, W = list(map(int, input().split()))\n    Ch, Cw = list(map(int, input().split()))\n    Dh, Dw = list(map(int, input().split()))\n    Sss = ['#'*(W+4)] + ['#'*(W+4)] + ['##'+input().rstrip()+'##' for _ in range(H)] + ['#'*(W+4)] + ['#'*(W+4)]\n\n    Ch, Cw, Dh, Dw = Ch+1, Cw+1, Dh+1, Dw+1\n\n    usedss = [[0]*(W+4) for _ in range(H+4)]\n    for x in range(H+4):\n        for y in range(W+4):\n            if Sss[x][y] == '#':\n                usedss[x][y] = 1\n\n    ans = 0\n    vs = set([(Ch, Cw)])\n    vNews = set([(Ch, Cw)])\n    usedss[Ch][Cw] = 1\n    while True:\n        while vs:\n            v2s = set()\n            for x, y in vs:\n                for dx, dy in dxys:\n                    x2, y2 = x+dx, y+dy\n                    if usedss[x2][y2]: continue\n                    v2s.add((x2, y2))\n                    vNews.add((x2, y2))\n                    usedss[x2][y2] = 1\n            vs = v2s\n\n        if usedss[Dh][Dw]:\n            print(ans)\n            break\n\n        if not vNews:\n            print((-1))\n            break\n\n        vs = set()\n        for x, y in vNews:\n            for dx in range(-2, 3):\n                for dy in range(-2, 3):\n                    x2, y2 = x+dx, y+dy\n                    if usedss[x2][y2]: continue\n                    vs.add((x2, y2))\n                    usedss[x2][y2] = 1\n\n        ans += 1\n        vNews = set(vs)\n\n\nsolve()\n", "from collections import deque\n\ndef main():\n    h, w = list(map(int, input().split()))\n    start_h, start_w = [int(x)+1 for x in input().split()]\n    goal_h, goal_w = [int(x)+1 for x in input().split()]\n\n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for _ in range(h):\n        s.append(\"##\" + input() + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n\n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[start_h][start_w] = 0\n\n    move1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2),(-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2),(0, -2), (0, -1), (0, 0), (0, 1), (0, 2),(1, -2), (1, -1), (1, 0), (1, 1), (1, 2),(2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\n    yet = deque([(start_h, start_w)])\n    done = deque()\n\n    while yet:\n        x1, y1 = yet.popleft()\n        done.append((x1, y1))\n        for (p, q) in move1:\n            v1, v2 = x1+p, y1+q\n            if ans[v1][v2] == -1: #\".\"\u3067\u307e\u3060\u8fbf\u308a\u7740\u3044\u3066\u3044\u306a\u3044\u30de\u30b9\n                yet.append((v1, v2))\n                ans[v1][v2] = ans[x1][y1]\n\n        if len(yet) == 0:\n            while done:\n                x2, y2 = done.popleft()\n                for (p, q) in move2:\n                    i, j = x2+p, y2+q\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        yet.append((i, j))\n\n    print((ans[goal_h][goal_w]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n \ndef main():\n  h,w=map(int,input().split())\n  c1,c2=map(lambda x:int(x)+1,input().split())\n  d1,d2=map(lambda x:int(x)+1,input().split())\n  work1=[(1,0),(-1,0),(0,1),(0,-1)]\n  work2=[(i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0,0)]+work1]\n  memo=[\"#\"*(w+4)]*2+[\"##\"+input()+\"##\" for _ in range(h)]+[\"#\"*(w+4)]*2\n  dist=[[-1]*(w+4) for _ in range(h+4)]\n  for i in range(h+4):\n    for j in range(w+4):\n      if memo[i][j]==\"#\":\n        dist[i][j]=float(\"inf\")\n  que1=deque([(c1,c2)])\n  que2=deque([])\n  dist[c1][c2]=0\n  while que1:\n    y,x=que1.popleft()\n    score=dist[y][x]\n    que2.append((y,x))\n    for py,px in work1:\n      ny,nx=y+py,x+px\n      if dist[ny][nx]==-1:\n        dist[ny][nx]=score\n        que1.append((ny,nx))\n    if not que1:\n      while que2:\n        y,x=que2.popleft()\n        for py,px in work2:\n          ny,nx=y+py,x+px\n          if dist[ny][nx]==-1:\n            dist[ny][nx]=score+1\n            que1.append((ny,nx))\n  print(dist[d1][d2])\n \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\n\ndef main():\n    h, w = map(int, input().split())\n    ch, cw = map(int, input().split())\n    dh, dw = map(int, input().split())\n    base = [\"#\" *(w+4)]\n    base.append(\"#\" * (w+4))\n    for n in range(h):\n        base.append(\"##\" + input() + \"##\")\n    base.append(\"#\" * (w+4))\n    base.append(\"#\" * (w+4))\n    ans = [[-1] * (w+4) for _ in range(h+4)]\n    for j in range(w+4):\n        for i in range(h+4):\n            if base[i][j] == \"#\":\n                ans[i][j] = -2\n    ch+=1; cw+=1\n    dh+=1; dw+=1\n    ans[ch][cw] = 0\n    move = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    move2 = [\n        [-2, -2], [-2, -1], [-2, 0], [-2, 1], [-2, 2], \\\n        [-1, -2], [-1, -1], [-1, 0], [-1, 1], [-1, 2], \\\n        [0, -2], [0, -1], [0, 0], [0, 1], [0, 2], \\\n        [1, -2], [1, -1], [1, 0], [1, 1], [1, 2], \\\n        [2, -2], [2, -1], [2, 0], [2, 1], [2, 2]\n        ]\n    q = deque([[ch, cw]])\n    one_time = deque([])\n    while len(q) > 0:\n        x, y = q.popleft()\n        one_time.append([x, y])\n        for i, j in move:\n            v1, v2 = x+i, y+j\n            if ans[v1][v2] == -1:\n                ans[v1][v2] = ans[x][y]\n                q.append([v1, v2])\n        if len(q) == 0:\n            while len(one_time) > 0:\n                x2, y2 = one_time.popleft()\n                for i, j in move2:\n                    v1, v2 = x2+i, y2+j\n                    if ans[v1][v2] == -1:\n                        ans[v1][v2] = ans[x2][y2] + 1\n                        q.append([v1, v2])\n    print(ans[dh][dw])\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nimport sys\ndef input():return sys.stdin.readline().strip()\ndef main():\n    H, W = map(int, input().split())\n    sh, sw = map(int, input().split())\n    sh -= 1; sw -= 1\n    start = (sh+2)*(W+4) + 2 + sw\n    dh, dw = map(int, input().split())\n    dh -= 1; dw -= 1\n    goal = (dh+2)*(W+4) + 2 + dw\n\n    field = \"#\"*(W+4)*2\n    field += \"##\" + \"####\".join([ input() for _ in range(H)]) + \"##\"\n    field += \"#\"*(W+4)*2\n\n    move = [-1, 1, -(W+4), W+4]\n    ex_left = [-2*(W+4)-2, -(W+4)-2, -2, (W+4)-2, 2*(W+4)-2, -(W+4)-1, (W+4)-1]\n    ex_right = [-2*(W+4)+2, -(W+4)+2, +2, (W+4)+2, 2*(W+4)+2, -(W+4)+1, (W+4)+1]\n    ex_up = [-2*(W+4)-2, -2*(W+4)-1, -2*(W+4), -2*(W+4)+1, -2*(W+4)+2, -(W+4)-1, -(W+4)+1]\n    ex_down = [2*(W+4)-2, 2*(W+4)-1, 2*(W+4), 2*(W+4)+1, 2*(W+4)+2, (W+4)-1, (W+4)+1]\n\n    INF = 10 ** 18\n    num = [INF] * (H+4) * (W+4)\n    warped = [False] * (H+4) * (W+4)\n\n    def bfs(s):\n        q = deque()\n        num[s] = 0\n        q.append((s, 0))\n    \n        while q:\n            now, cost = q.popleft()\n\n            # warp\u3057\u305f\u3082\u306e\u306e\u65e2\u306b\u6765\u3066\u3044\u305f\u5834\u5408\u306f\u30b9\u30eb\u30fc\n            if cost > num[now]:\n                continue\n            else:\n                num[now] = cost\n\n            if now == goal:\n                return\n\n            for i, dx in enumerate(move):\n                nx = now + dx\n                if field[nx] == \".\" and num[nx] == INF:\n                    q.appendleft((nx, cost))\n                    num[nx] = cost\n\n                elif field[nx] == \"#\":\n                    if i == 0:\n                        ex = ex_left\n                    elif i == 1:\n                        ex = ex_right\n                    elif i == 2:\n                        ex = ex_up\n                    else:\n                        ex = ex_down\n\n                    for dx2 in ex:\n                        nx2 = now + dx2\n                        if field[nx2] == \".\" and num[nx2] == INF and not warped[nx2]:\n                            q.append((nx2, cost+1))\n                            warped[nx2] = True\n    \n    bfs(start)\n\n    if num[goal] == INF:\n        print(-1)\n    else:\n        print(num[goal])\n\n    \n    # for i in range(0, (H+4)*(W+4), W+4):\n    #     print(field[i:i+W+4])\n    \n    # print(start)\n    # print(start//(W+4), start%(W+4))\n    # print(goal)\n    # print(goal//(W+4), goal%(W+4))\n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\n\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = list(map(int, readline().split()))\n    Ch, Cw = [int(x) - 1 for x in readline().split()]\n    Dh, Dw = [int(x) - 1 for x in readline().split()]\n    S = [readline()[:-1] for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    for h in range(H):\n        th = t[h]\n        Sh = S[h]\n        for w in range(W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n    a = 0\n    warpq = []\n    while q:\n        while q:\n            warpq.append(q[0])\n            h, w = q.popleft()\n            if h - 1 >= 0 and t[h - 1][w] > a:\n                q.append((h - 1, w))\n                t[h - 1][w] = a\n            if h + 1 < H and t[h + 1][w] > a:\n                q.append((h + 1, w))\n                t[h + 1][w] = a\n            if w - 1 >= 0 and t[h][w - 1] > a:\n                q.append((h, w - 1))\n                t[h][w - 1] = a\n            if w + 1 < W and t[h][w + 1] > a:\n                q.append((h, w + 1))\n                t[h][w + 1] = a\n\n        if t[Dh][Dw] != INF:\n            break\n\n        a += 1\n        for h, w in warpq:\n            for i in range(max(0, h - 2), min(H, h + 3)):\n                ti = t[i]\n                for j in range(max(0, w - 2), min(W, w + 3)):\n                    if ti[j] > a:\n                        ti[j] = a\n                        q.append((i, j))\n        warpq.clear()\n\n    if t[Dh][Dw] == INF:\n        print((-1))\n    else:\n        print((t[Dh][Dw]))\n\n\nmain()\n", "from collections import deque\n\n\ndef solve():\n    H, W = list(map(int, input().split()))\n    CH, CW = list(map(int, input().split()))\n    DH, DW = list(map(int, input().split()))\n    S = [\"##\"+input()+\"##\" for _ in range(H)]\n    for i in range(2):\n        S.insert(0, \"#\"*(W+4))\n        S.append(\"#\"*(W+4))\n\n    inf = int(1e9)\n    cost = [[inf for _ in range(W+4)] for _ in range(H+4)]\n    cost0 = deque()\n    ans = -1\n\n    cost0.append((CH+1, CW+1, 0))\n    cost[CH+1][CW+1] = 0\n\n    move = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    warp = [(i, j) for i in range(-2, 3) for j in range(-2, 3) if (i, j) not in [(0, 0)]+move]\n\n    cost1 = deque()\n\n    while cost0:\n        h, w, c = cost0.popleft()\n        cost1.append((h, w, c))\n\n        for i, j in move:\n            dh = h+i\n            dw = w+j\n            if S[dh][dw] == \".\" and c < cost[dh][dw]:\n                cost[dh][dw] = c\n                cost0.appendleft((dh, dw, cost[dh][dw]))\n\n        if len(cost0) == 0:\n            while cost1:\n                h, w, c = cost1.popleft()\n                for i, j in warp:\n                    dh = h+i\n                    dw = w+j\n                    if S[dh][dw] == \".\" and c+1 < cost[dh][dw]:\n                        cost[dh][dw] = c+1\n                        cost0.append((dh, dw, cost[dh][dw]))\n\n        if cost[DH+1][DW+1] != inf:\n            ans = cost[DH+1][DW+1]\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n    \n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    \n    \n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for i in range(h):\n        s.append(\"##\" + input()[:-1] + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n    \n    \n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[ch][cw] = 0\n    \n    move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), \\\n             (-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2), \\\n             (0, -2), (0, -1), (0, 0), (0, 1), (0, 2), \\\n             (1, -2), (1, -1), (1, 0), (1, 1), (1, 2), \\\n             (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n        \n    not_yet = [(ch, cw)]\n    one_time = []\n    \n    while len(not_yet) > 0:\n        x, y = not_yet.pop()\n        one_time.append((x, y))\n        for (p, q) in move:\n            v1, v2 = x+p, y+q\n            if ans[v1][v2] == -1:\n                not_yet.append((v1, v2))\n                ans[v1][v2] = ans[x][y]\n                \n        if len(not_yet) == 0:\n            while len(one_time) > 0:\n                x2, y2 = one_time.pop()\n                for (v1, v2) in move2:\n                    i, j = x2+v1, y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        not_yet.append((i, j))\n          \n    print((ans[dh][dw]))\n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "\nfrom collections import deque\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n\n    \"\"\"\n    l = [list(input().strip()) for i in range(h)]\n    ans = [[-1]*w for i in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if l[i][j] == \"#\":\n                ans[i][j] = -2\n    ch -= 1\n    cw -= 1\n    dh -= 1\n    dw -= 1\n    \"\"\"\n\n    base = [\"#\" * (w + 4)]\n    base.append(\"#\" * (w + 4))\n    for n in range(h):\n        base.append(\"##\" + input() + \"##\")\n    base.append(\"#\" * (w + 4))\n    base.append(\"#\" * (w + 4))\n    ans = [[-1] * (w + 4) for _ in range(h + 4)]\n    for i in range(h + 4):\n        for j in range(w + 4):\n            if base[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n\n    ans[ch][cw] = 0\n    move1 = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    move2 = [\n        [-2, -2], [-2, -1], [-2, 0], [-2, 1], [-2, 2], [-1, -2], [-1, -1],\n        [-1, 1], [-1, 2], [0, -2], [0, 2], [1, -2], [1, -1], [1, 1],\n        [1, 2], [2, -2], [2, -1], [2, 0], [2, 1], [2, 2]\n    ]\n    q1 = deque([[ch, cw]])\n    q2 = deque([])\n\n    while q1:\n        x1, y1 = q1.popleft()\n        q2.append([x1, y1])\n        for i, j in move1:\n            nx, ny = x1 + i, y1 + j\n            \"\"\"\n            if nx < 0 or h <= nx or ny < 0 or w <= ny:\n                continue\n            \"\"\"\n            if ans[nx][ny] == -1:\n                ans[nx][ny] = ans[x1][y1]\n                q1.append([nx, ny])\n        if len(q1) == 0:\n            while q2:\n                x2, y2 = q2.popleft()\n                for i, j in move2:\n                    mx, my = x2 + i, y2 + j\n                    \"\"\"\n                    if mx < 0 or h <= mx or my < 0 or w <= my:\n                        continue\n                    \"\"\"\n                    if ans[mx][my] == -1:\n                        ans[mx][my] = ans[x2][y2] + 1\n                        q1.append([mx, my])\n    print((ans[dh][dw]))\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "from collections import deque\n\ndef main():\n    h, w = list(map(int, input().split()))\n    start_h, start_w = [int(x)+1 for x in input().split()]\n    goal_h, goal_w = [int(x)+1 for x in input().split()]\n\n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for _ in range(h):\n        s.append(\"##\" + input() + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n\n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[start_h][start_w] = 0\n\n    move1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2),(-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2),(0, -2), (0, -1), (0, 0), (0, 1), (0, 2),(1, -2), (1, -1), (1, 0), (1, 1), (1, 2),(2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\n    yet = deque([(start_h, start_w)])\n    done = deque()\n\n    while yet:\n        x1, y1 = yet.popleft()\n        done.append((x1, y1))\n        for (p, q) in move1:\n            v1, v2 = x1+p, y1+q\n            if ans[v1][v2] == -1: #\".\"\u3067\u307e\u3060\u8fbf\u308a\u7740\u3044\u3066\u3044\u306a\u3044\u30de\u30b9\n                yet.append((v1, v2))\n                ans[v1][v2] = ans[x1][y1]\n\n        if len(yet) == 0:\n            while done:\n                x2, y2 = done.popleft()\n                for (p, q) in move2:\n                    i, j = x2+p, y2+q\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        yet.append((i, j))\n\n    print((ans[goal_h][goal_w]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nfrom collections import deque\n\n\n# In[30]:\n\n\ndef main():\n    H,W = list(map(int, input().split()))\n    ch,cw = list(map(int, input().split()))\n    dh,dw = list(map(int, input().split()))\n    s = [\"#\"*(W+4)]\n    s.append(\"#\"*(W+4))\n    for i in range(H):\n        s.append(\"##\"+input()+\"##\")\n    s.append(\"#\"*(W+4))\n    s.append(\"#\"*(W+4))\n    \n    ans = [[-1]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n        for j in range(W+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1; cw += 1\n    dh += 1; dw += 1\n    ans[ch][cw] = 0\n    \n    move = [[-1,0],[1,0],[0,-1],[0,1]]\n    magic = [\n        [-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],\\\n        [-1,-2],[-1,-1],[-1,0],[-1,1],[-1,2],\\\n        [0,-2],[0,-1],[0,0],[0,1],[0,2],\\\n        [1,-2],[1,-1],[1,0],[1,1],[1,2],\\\n        [2,-2],[2,-1],[2,0],[2,1],[2,2]\n        ]\n    \n    mylist = deque([[ch,cw]])\n    mylist2 = deque([])\n    while len(mylist) > 0:\n        x,y = mylist.popleft()\n        mylist2.append([x,y])\n        for p,q in move:\n            v1,v2 = x+p,y+q\n            if ans[v1][v2] == -1:\n                mylist.append([v1,v2])\n                ans[v1][v2] = ans[x][y]\n        if len(mylist) == 0:\n            while len(mylist2) > 0:\n                x2,y2 = mylist2.popleft()\n                for v1,v2 in magic:\n                    i,j = x2+v1,y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        mylist.append([i,j])\n    print((ans[dh][dw]))\n\ndef __starting_point():\n    main()\n\n\n# In[31]:\n\n\n# H,W = map(int, input().split())\n# ch,cw = map(int, input().split())\n# dh,dw = map(int, input().split())\n# s = [\"#\"*(W+4)]\n# s.append(\"#\"*(W+4))\n# for i in range(H):\n#     s.append(\"##\"+input()+\"##\")\n# s.append(\"#\"*(W+4))\n# s.append(\"#\"*(W+4))\n\n\n# In[32]:\n\n\n# ans = [[-1]*(W+4) for _ in range(H+4)]\n# for i in range(H+4):\n#     for j in range(W+4):\n#         if s[i][j] == \"#\":\n#             ans[i][j] = -2\n# ch += 1; cw += 1\n# dh += 1; dw += 1\n# ans[ch][cw] = 0\n\n\n# In[33]:\n\n\n# move = [[-1,0],[1,0],[0,-1],[0,1]]\n# magic = [\n#     [-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],\\\n#     [-1,-2],[-1,-1],[-1,0],[-1,1],[-1,2],\\\n#     [0,-2],[0,-1],[0,0],[0,1],[0,2],\\\n#     [1,-2],[1,-1],[1,0],[1,1],[1,2],\\\n#     [2,-2],[2,-1],[2,0],[2,1],[2,2]\n#     ]\n\n\n# In[34]:\n\n\n# mylist = deque([[ch,cw]])\n# mylist2 = deque([])\n# while len(mylist) > 0:\n#     x,y = mylist.popleft()\n#     mylist2.append([x,y])\n#     for p,q in move:\n#         v1,v2 = x+p,y+q\n#         if ans[v1][v2] == -1:\n#             mylist.append([v1,v2])\n#             ans[v1][v2] = ans[x][y]\n#     if len(mylist) == 0:\n#         while len(mylist2) > 0:\n#             x2,y2 = mylist2.popleft()\n#             for v1,v2 in magic:\n#                 i,j = x2+v1,y2+v2\n#                 if ans[i][j] == -1:\n#                     ans[i][j] = ans[x2][y2]+1\n#                     mylist.append([i,j])\n# print(ans[dh][dw])\n\n\n# In[ ]:\n\n\n\n\n\n__starting_point()", "from collections import deque\n\ndef solve(h, w, ch, cw, dh, dw, s):\n    W, H = w+5, h+5\n    def pos(r, c):\n        return (r+2)*W + c+2\n    G = [0] * (W*H)\n    label = 0\n    for r in range(h):\n        for c in range(w):\n            if (s[r][c] == '.') and (G[pos(r,c)] == 0):\n                label += 1\n                que = deque([(r, c)])\n                G[pos(r,c)] = label\n                while que:\n                    cr, cc = que.popleft()\n                    for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                        nr, nc = cr+dr, cc+dc\n                        if (0 <= nr < h) and (0 <= nc < w) and (s[nr][nc] == \".\") and (G[pos(nr,nc)] == 0):\n                            G[pos(nr,nc)] = label\n                            que.append((nr, nc))\n\n    start = pos(ch-1, cw-1)\n    goal = pos(dh-1, dw-1)\n\n    neighbors = [(dr*W+dc) for dc in range(-2, 3) for dr in range(-2, 3) if abs(dr) + abs(dc) > 0]\n    used = [True] * (W*H)\n    for r in range(h):\n        for c in range(w):\n            used[pos(r,c)] = (s[r][c] == \"#\")\n    que = deque([(start, 0)])\n    label_dist_mapping = [-1] * (label + 1)\n    used[start] = True\n    label_dist_mapping[G[start]] = 0\n    while que:\n        cpos, n = que.popleft()\n        if cpos == goal:\n            return n\n        for d in neighbors:\n            npos = cpos + d\n            if not used[npos]:\n                used[npos] = True\n                m = label_dist_mapping[G[npos]]\n                if (G[npos] == G[cpos]) or (n == m): # \u540c\u4e00\u30b0\u30eb\u30fc\u30d7\n                    que.appendleft((npos, n))\n                else:\n                    label_dist_mapping[G[npos]] = n + 1\n                    que.append((npos, n+1))\n    return -1\n\nh, w = list(map(int, input().split()))\nch, cw = list(map(int, input().split()))\ndh, dw = list(map(int, input().split()))\ns = [input() for i in range(h)]\nprint((solve(h, w, ch, cw, dh, dw, s)))\n", "from collections import deque\n \ndef main():\n  h,w=list(map(int,input().split()))\n  c1,c2=[int(x)+1 for x in input().split()]\n  d1,d2=[int(x)+1 for x in input().split()]\n  work1=[(1,0),(-1,0),(0,1),(0,-1)]\n  work2=[(i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0,0)]+work1]\n  memo=[\"#\"*(w+4)]*2+[\"##\"+input()+\"##\" for _ in range(h)]+[\"#\"*(w+4)]*2\n  dist=[[-1]*(w+4) for _ in range(h+4)]\n  for i in range(h+4):\n    for j in range(w+4):\n      if memo[i][j]==\"#\":\n        dist[i][j]=float(\"inf\")\n  que1=deque([(c1,c2)])\n  que2=deque([])\n  dist[c1][c2]=0\n  while que1:\n    y,x=que1.popleft()\n    score=dist[y][x]\n    que2.append((y,x))\n    for py,px in work1:\n      ny,nx=y+py,x+px\n      if dist[ny][nx]==-1:\n        dist[ny][nx]=score\n        que1.append((ny,nx))\n    if not que1:\n      while que2:\n        y,x=que2.popleft()\n        for py,px in work2:\n          ny,nx=y+py,x+px\n          if dist[ny][nx]==-1:\n            dist[ny][nx]=score+1\n            que1.append((ny,nx))\n  print((dist[d1][d2]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = list(map(int, readline().split()))\n    Ch, Cw = [int(x) - 1 for x in readline().split()]\n    Dh, Dw = [int(x) - 1 for x in readline().split()]\n    S = [readline()[:-1] for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    for h in range(H):\n        th = t[h]\n        Sh = S[h]\n        for w in range(W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n    a = 0\n    while q:\n        warpq = []\n        while q:\n            h, w = q.popleft()\n            warpq.append((h, w))\n            if h - 1 >= 0 and t[h - 1][w] > a:\n                q.append((h - 1, w))\n                t[h - 1][w] = a\n            if h + 1 < H and t[h + 1][w] > a:\n                q.append((h + 1, w))\n                t[h + 1][w] = a\n            if w - 1 >= 0 and t[h][w - 1] > a:\n                q.append((h, w - 1))\n                t[h][w - 1] = a\n            if w + 1 < W and t[h][w + 1] > a:\n                q.append((h, w + 1))\n                t[h][w + 1] = a\n\n        if t[Dh][Dw] != INF:\n            break\n\n        a += 1\n        for h, w in warpq:\n            for i in range(max(0, h - 2), min(H, h + 3)):\n                ti = t[i]\n                for j in range(max(0, w - 2), min(W, w + 3)):\n                    if ti[j] > a:\n                        ti[j] = a\n                        q.append((i, j))\n\n    if t[Dh][Dw] == INF:\n        print((-1))\n    else:\n        print((t[Dh][Dw]))\n\n\nmain()\n", "# import numpy as np\nfrom collections import deque\n\ndef solve(H, W, CH, CW, DH, DW, S):\n\t# \u5f8c\u306e\u6761\u4ef6\u5206\u5c90\u3092\u7c21\u7565\u5316\u3059\u308b\u305f\u3081\u30ef\u30fc\u30d7\u3057\u3066\u3082\u8ff7\u8def\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u58c1\u3067\u56f2\u3080\n\tS = ['##{}##'.format(row) for row in S]\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\n\n\tMAX_COST = 10 ** 9\n\tCost=[ [ MAX_COST for _ in range(W+4)] for _ in range(H+4)]\n\t# Cost = np.full((H,W),MAX_COST)\n\n\t# print(S)\n\n\tans = -1\n\n\tcost0 = deque()\n\n\tcost0.append((CH+1,CW+1,0))\n\tCost[CH+1][CW+1] = 0;\n\n\t# used = set()\n\twalk=[(1,0),(0,1),(-1,0),(0,-1)]\n\twarp = [ (i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0, 0)] + walk ]\n\t# print(warp)\n\n\tcost1 = deque()\n\n\twhile cost0:\n\t\th,w,c=cost0.popleft()\n\t\tcost1.append((h,w,c))\n\n\t\tfor i,j in walk:\n\t\t\tdh = h+i\n\t\t\tdw = w+j\n\t\t\tif S[dh][dw] == '.' and c < Cost[dh][dw]:\n\t\t\t\tCost[dh][dw] = c\n\t\t\t\t# print(\"updl \", i,j,dh,dw,c)\n\t\t\t\tcost0.appendleft((dh,dw,Cost[dh][dw]))\n\n\t\tif len(cost0) == 0:\n\n\t\t\twhile cost1:\n\t\t\t\th,w,c=cost1.popleft()\n\t\t\t\t# print(h,w,c)\n\t\t\t\tfor i,j in warp:\n\t\t\t\t\tdh = h+i\n\t\t\t\t\tdw = w+j\n\t\t\t\t\t# print(i,j)\n\t\t\t\t\tif S[dh][dw] == '.' and c + 1 < Cost[dh][dw]:\n\t\t\t\t\t\tCost[dh][dw] = c + 1\n\t\t\t\t\t\tcost0.append((dh,dw,Cost[dh][dw]))\n\n\n\tif Cost[DH+1][DW+1] == MAX_COST:\n\t\tprint((-1))\n\telse:\n\t\tprint((Cost[DH+1][DW+1]))\n\n\ndef __starting_point():\n\tH,W=list(map(int,input().split()))\n\tCH,CW=list(map(int,input().split()))\n\tDH,DW=list(map(int,input().split()))\n\n\tS=[input() for _ in range(H)]\n\n\tsolve(H, W, CH, CW, DH, DW, S)\n\n__starting_point()", "from collections import deque\n\ndef bfs():\n    H,W=map(int,input().split())\n    sy,sx=map(int,input().split())\n    gy,gx=map(int,input().split())\n    S=['#'*(W+4),'#'*(W+4)]\n    for _ in range(H):\n        S.append('##'+input()+'##')\n    S.append('#'*(W+4))\n    S.append('#'*(W+4))\n    dist=[[-2]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n      for j in range(W+4):\n        if S[i][j]=='.':\n          dist[i][j]=-1\n    dist[sy+1][sx+1]=0\n    A=[(1,0),(-1,0),(0,1),(0,-1)]\n    B=[(i,j)for i in range(-2,3)for j in range(-2,3)if abs(i)+abs(j)>1]\n    que=deque([[sx+1,sy+1]])\n    que2=deque([])\n    while que:\n        x,y=que.popleft()\n        que2.appendleft([x,y])\n        for dx,dy in A:\n            nx=x+dx\n            ny=y+dy\n            if dist[ny][nx]==-1:\n                dist[ny][nx]=dist[y][x]\n                que.appendleft([nx,ny])\n        if que:\n            continue\n        while que2:\n            x,y=que2.popleft()\n            for dx,dy in B:\n                nx=x+dx\n                ny=y+dy\n                if dist[ny][nx]==-1:\n                    dist[ny][nx]=dist[y][x]+1\n                    que.append([nx,ny])\n    ans=dist[gy+1][gx+1]\n    return ans\n\nprint(bfs())", "from collections import deque\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = list(map(int, readline().split()))\n    C1, C2 = [int(x) - 1 for x in readline().split()]\n    D1, D2 = [int(x) - 1 for x in readline().split()]\n    S = [readline()[:-1] for _ in range(H)]\n\n\n\n    t = [[INF]*W for _ in range (H)]\n\n\n    for h in range (H):\n        Sh = S[h]\n        th = t[h]\n        for w in range (W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n\n    q = deque([(C1,C2)])\n    a = 0\n    t[C1][C2] = a\n\n    while q:\n        warpq = []\n        while q:\n            h,w = q.popleft()\n            warpq.append((h,w))\n            if 0 < h and t[h-1][w] > a:\n                t[h-1][w] = a\n                q.append((h-1,w))\n            if H-1 > h and t[h+1][w] > a:\n                t[h+1][w] = a\n                q.append((h+1,w))\n            if 0 < w and t[h][w-1] > a:\n                t[h][w-1] = a\n                q.append((h,w-1))\n            if w < W-1 and t[h][w+1] > a:\n                t[h][w+1] = a\n                q.append((h,w+1))\n\n        if t[D1][D2]!= INF:\n            break\n\n        a+=1\n\n        for h,w in warpq:\n            for i in range (max(0,h-2),min(H,h+3)):\n                ti = t[i]\n                for j in range (max(0,w-2),min(W,w+3)):\n                    if ti[j] >a:\n                        ti[j] = a\n                        q.append((i,j))\n\n\n    if t[D1][D2] == INF:\n        print((-1))\n    else:\n        print((t[D1][D2]))\n\nmain()\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    H, W = [int(x) for x in input().strip().split()]\n    Ch, Cw = [int(x)+1 for x in input().strip().split()]\n    Dh, Dw = [int(x)+1 for x in input().strip().split()]\n    M = [0 for _ in range(H+4)]\n    M[0] = ['#'] * (W+4)\n    M[1] = ['#'] * (W+4)\n    M[-2] = ['#'] * (W+4)\n    M[-1] = ['#'] * (W+4)\n    for h in range(2, H+2):\n        M[h] = ['#'] * 2 + list(input().strip()) + ['#'] * 2\n        # print(M[h])\n    ans = 0\n    q = set([(Ch, Cw)])\n    M[Ch][Cw] = '#'\n    dhdw = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    while True:\n        newq = set()\n        while q:\n            q_ = set()\n            for h, w in q:\n                # print('({}, {}) = {}'.format(h, w, ans))\n                if h == Dh and w == Dw:\n                    print(ans)\n                    return True\n                newq.add((h, w))\n                for dh, dw in dhdw:\n                    if M[h+dh][w+dw] == '#':\n                        continue\n                    q_.add((h+dh, w+dw))\n                    M[h+dh][w+dw] = '#'\n            q = q_\n\n        if newq:\n            for h, w in newq:\n                for dh in range(-2, 3):\n                    for dw in range(-2, 3):\n                        if M[h+dh][w+dw] == '.':\n                            q.add((h+dh, w+dw))\n                            M[h+dh][w+dw] = '#'\n        # for h in range(H):\n        #     print(M[h])\n        if len(q):\n            ans += 1\n        else:\n            print(-1)\n            return True\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nfrom itertools import product\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    c = tuple([int(x)+1 for x in input().split()])\n    d = tuple([int(x)+1 for x in input().split()])\n    s = ['#'*(w+4)]*2 + [f'##{input()}##' for _ in range(h)] + ['#'*(w+4)]*2\n\n    move_a_area = [(0, -1), (-1, 0), (1, 0), (0, 1)]\n    move_b_area = [(i, j) for i, j in product(list(range(-2, 3)), repeat=2) if (i, j) not in [(0, 0)] + move_a_area]\n\n    cost = [[float('inf')] * (w+4) for _ in range(h+4)]\n    cost[c[0]][c[1]] = 0\n    yet = deque([(c[0], c[1], 0)])\n    done = deque()\n\n    while yet:\n        y, x, m = yet.popleft()\n        done.append((y, x, m))\n        # Move A\n        for dx, dy in move_a_area:\n            hh, ww = y + dy, x + dx\n            if s[hh][ww] == '#' or cost[hh][ww] <= m:\n                continue\n            cost[hh][ww] = m\n            yet.append((hh, ww, m))\n        # Move B\n        if not yet:\n            while done:\n                y, x, m = done.popleft()\n                for dx, dy in move_b_area:\n                    hh, ww = y + dy, x + dx\n                    if s[hh][ww] == '#' or cost[hh][ww] <= m + 1:\n                        continue\n                    cost[hh][ww] = m + 1\n                    yet.append((hh, ww, m + 1))\n\n    print((v if (v := cost[d[0]][d[1]]) < float('inf') else -1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\ndef solve():  \n    h, w = list(map(int,input().split()))\n    ch, cw = list(map(int,input().split()))\n    Dh, Dw = list(map(int,input().split()))\n    \n    M = ['##' + input() + '##' for _ in range(h)]\n    for i in range(2):\n        M.insert(0,'#'*(w+4))\n        M.append('#'*(w+4))\n    \n    INF = float('inf')\n    cost = [[INF for _ in range(w+4)] for _ in range(h+4)]\n    cost0 = deque()\n    ans = -1\n    \n    cost0.append((ch+1, cw+1, 0))\n    cost[ch+1][cw+1] = 0\n    \n    move = [(1,0),(0,1),(-1,0),(0,-1)]\n    warp = [(i,j) for i in range(-2,3) for j in range(-2,3) if (i,j) not in [(0,0)] + move]\n    \n    cost1 = deque()\n    \n    while cost0:\n        h, w, c = cost0.popleft()\n        cost1.append((h, w, c))\n        \n        for i,j in move:\n            dh = h + i\n            dw = w + j\n            if M[dh][dw] == '.' and c < cost[dh][dw]: #\u30b3\u30b9\u30c8\u304c\u9ad8\u3044\u3068\u3053\u308d\u304b\u3089\u4f4e\u3044\u3068\u3053\u308d\u306b\u623b\u3089\u306a\u3044\u3088\u3046\u306b\u3059\u308b\u305f\u3081\n                cost[dh][dw] = c\n                cost0.appendleft((dh, dw, cost[dh][dw]))\n        \n        if len(cost0) == 0:\n            while cost1:\n                h, w, c = cost1.popleft()\n                for i,j in warp:\n                    dh = h + i\n                    dw = w + j\n                    if M[dh][dw] == '.' and c+1 < cost[dh][dw]:  #\u7121\u99c4\u306a\u30ef\u30fc\u30d7\u3092\u306a\u304f\u3059\u305f\u3081\n                        cost[dh][dw] = c+1\n                        cost0.append((dh, dw, cost[dh][dw]))\n        if cost[Dh+1][Dw+1] != INF:\n            ans = cost[Dh+1][Dw+1]\n    \n    print(ans)\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import deque\n\ndef main():\n    h, w = list(map(int, input().split()))\n    c = list([int(x)+1 for x in input().split()])\n    d = list([int(x)+1 for x in input().split()])\n    s = ['#'*(w+4)]*2 + ['#'*2 + input() + '#'*2 for _ in range(h)] + ['#'*(w+4)]*2\n\n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == '#':\n                ans[i][j] = -2\n    ans[c[0]][c[1]] = 0\n\n    move1 = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    move2 = [(i, j) for i in range(-2, 3) for j in range(-2, 3) if abs(i)+abs(j) > 1]\n\n    yet = deque([(c[0], c[1])])\n    done = deque()\n\n    while yet:\n        y, x = yet.popleft()\n        done.append((y, x))\n        for dy, dx in move1:\n            ydy, xdx = y+dy, x+dx\n            if ans[ydy][xdx] == -1:\n                yet.append((ydy, xdx))\n                ans[ydy][xdx] = ans[y][x]\n\n        if len(yet) == 0:\n            while done:\n                y, x = done.popleft()\n                for dy, dx in move2:\n                    ydy, xdx = y+dy, x+dx\n                    if ans[ydy][xdx] == -1:\n                        ans[ydy][xdx] = ans[y][x] + 1\n                        yet.append((ydy, xdx))\n\n    print((ans[d[0]][d[1]]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\ndef main():\n  h,w=list(map(int,input().split()))\n  cy,cx=list(map(int,input().split()))\n  dy,dx=list(map(int,input().split()))\n\n  M=[\"##\"+input()+\"##\" for x in range(h)]\n  for i in range(2):\n    M.insert(0,\"#\"*(w+4))\n    M.append(\"#\"*(w+4))\n\n  C=[[-1 if M[j][i]==\".\" else -2 for i in range(w+4)] for j in range(h+4)]\n  C[-~cy][-~cx]=0\n  QA,QB=deque(),deque()\n  QA.append((-~cy,-~cx,0))\n  W=[[i,j] for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n\n  while QA:\n    h,w,c=QA.popleft()\n    QB.append((h,w,c))\n\n    for i,j in [[1,0],[0,1],[-1,0],[0,-1]]:\n      dh,dw=h+i,w+j\n      if C[dh][dw]==-1:\n        C[dh][dw]=c\n        QA.appendleft((dh,dw,c))\n\n    if QA:\n      continue\n\n    while QB:\n      h,w,c=QB.popleft()\n      for i,j in W:\n        dh,dw=h+i,w+j\n        if C[dh][dw]==-1:\n          C[dh][dw]=-~c\n          QA.append((dh,dw,-~c))\n\n    if C[-~dy][-~dx]!=-1:\n      print((C[-~dy][-~dx]))\n      return\n\n  print((C[-~dy][-~dx]))\n\ndef __starting_point():\n  main()\n\n__starting_point()", "H, W = map(int, input().split())\nCh, Cw = map(int, input().split())\nDh, Dw = map(int, input().split())\n\nCh += 1\nCw += 1\nDh += 1\nDw += 1\n\n\nS = ['#'*(W+4)]\nS.append('#'*(W+4))\nfor k in range(H):\n  S.append('##' + input() + '##')\nS.append('#'*(W+4))\nS.append('#'*(W+4))\n\nfoo = [[-1 for _ in range(W+4)] for _ in range(H+4)]\nfor k in range(2, H+2):\n  for j in range(2, W+2):\n    if S[k][j] == '.':\n      foo[k][j] = 10**6\n\nfoo[Ch][Cw] = 0\n\nnow = []\nnew = [(Ch, Cw)]\nwhile len(new) > 0:\n  item = new.pop()\n  now.append(item)\n  x = item[0]\n  y = item[1]\n  if foo[x+1][y] == 10**6:\n    foo[x+1][y] = 0\n    new.append((x+1, y))\n  if foo[x][y+1] == 10**6:\n    foo[x][y+1] = 0\n    new.append((x, y+1))\n  if foo[x-1][y] == 10**6:\n    foo[x-1][y] = 0\n    new.append((x-1, y))\n  if foo[x][y-1] == 10**6:\n    foo[x][y-1] = 0\n    new.append((x, y-1))\n\n\nans = 0\nwhile foo[Dh][Dw] == 10**6:\n  if len(now) == 0:\n    print(-1)\n    return \n  ans += 1\n  while len(now) > 0:\n    item = now.pop()\n    x = item[0]\n    y = item[1]\n    if foo[x+2][y+2] > ans:\n      foo[x+2][y+2] = ans\n      new.append((x+2, y+2))\n    if foo[x+2][y+1] > ans:\n      foo[x+2][y+1] = ans\n      new.append((x+2, y+1))\n    if foo[x+2][y] > ans:\n      foo[x+2][y] = ans\n      new.append((x+2, y))\n    if foo[x+2][y-1] > ans:\n      foo[x+2][y-1] = ans\n      new.append((x+2, y-1))\n    if foo[x+2][y-2] > ans:\n      foo[x+2][y-2] = ans\n      new.append((x+2, y-2))\n    if foo[x+1][y+2] > ans:\n      foo[x+1][y+2] = ans\n      new.append((x+1, y+2))\n    if foo[x+1][y-2] > ans:\n      foo[x+1][y-2] = ans\n      new.append((x+1, y-2))\n    if foo[x][y+2] > ans:\n      foo[x][y+2] = ans\n      new.append((x, y+2))\n    if foo[x][y-2] > ans:\n      foo[x][y-2] = ans\n      new.append((x, y-2))\n    if foo[x-2][y+2] > ans:\n      foo[x-2][y+2] = ans\n      new.append((x-2, y+2))\n    if foo[x-2][y+1] > ans:\n      foo[x-2][y+1] = ans\n      new.append((x-2, y+1))\n    if foo[x-2][y] > ans:\n      foo[x-2][y] = ans\n      new.append((x-2, y))\n    if foo[x-2][y-1] > ans:\n      foo[x-2][y-1] = ans\n      new.append((x-2, y-1))\n    if foo[x-2][y-2] > ans:\n      foo[x-2][y-2] = ans\n      new.append((x-2, y-2))\n    if foo[x-1][y+2] > ans:\n      foo[x-1][y+2] = ans\n      new.append((x-1, y+2))\n    if foo[x-1][y-2] > ans:\n      foo[x-1][y-2] = ans\n      new.append((x-1, y-2))\n    if foo[x-1][y-1] > ans:\n      foo[x-1][y-1] = ans\n      new.append((x-1, y-1))\n    if foo[x-1][y+1] > ans:\n      foo[x-1][y+1] = ans\n      new.append((x-1, y+1))\n    if foo[x+1][y+1] > ans:\n      foo[x+1][y+1] = ans\n      new.append((x+1, y+1))\n    if foo[x+1][y-1] > ans:\n      foo[x+1][y-1] = ans\n      new.append((x+1, y-1))\n      \n  while len(new) > 0:\n    item = new.pop()\n    now.append(item)\n    x = item[0]\n    y = item[1]\n    if foo[x+1][y] == 10**6:\n      foo[x+1][y] = 0\n      new.append((x+1, y))\n    if foo[x][y+1] == 10**6:\n      foo[x][y+1] = 0\n      new.append((x, y+1))\n    if foo[x-1][y] == 10**6:\n      foo[x-1][y] = 0\n      new.append((x-1, y))\n    if foo[x][y-1] == 10**6:\n      foo[x][y-1] = 0\n      new.append((x, y-1))\nprint(ans)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nimport numpy as np\nfrom numba import njit, b1, i4, i8, f8\nfrom heapq import heappop as hpp, heappush as hp\n\n@njit((b1[:, :],i8,i8,i8,i8))\ndef main(ss,ch,cw,dh,dw):\n    inf = 1<<30\n    h,w = ss.shape\n    start = ch*w+cw\n    goal = dh*w+dw\n    n = h*w\n    seen = np.full(n, inf, np.int64)\n    seen[start] = 0\n    q = [(0, start)] # \u30ef\u30fc\u30d7\u56de\u6570, \u73fe\u5728\u4f4d\u7f6e, \u6700\u5f8c\u306e\u9053\u306e\u4f4d\u7f6e\n    while q:\n        pnum,pu = hpp(q)\n        ux,uy = divmod(pu,w)\n        if pu==goal:\n            break\n        for xx in range(-2, 3):\n            for yy in range(-2, 3):\n                if xx==yy==0:\n                    continue\n                if abs(xx)+abs(yy)<=1:\n                    vv = 0\n                else:\n                    vv = 1\n                x,y = ux+xx, uy+yy\n                u = x*w + y\n                num = pnum+vv\n                if x<0 or y<0 or x>=h or y>=w or ss[x][y]:\n                    continue\n        #         print(x,y)\n                if seen[u]>num:\n                    seen[u] = num\n                    hp(q,(num, u))\n                \n    val = seen[goal]\n    if val==inf:\n        return -1\n    else:\n        return val\nh,w = map(int, input().split())\nch,cw = map(int, input().split())\ndh,dw = map(int, input().split())\nch -= 1\ncw -= 1\ndh -= 1\ndw -= 1\nrows,cols = h,w\n\nOK = \".\"\nNG = \"#\"\n\nss = np.array([[c==\"#\" for c in input()] for _ in range(h)])\n\nprint(main(ss,ch,cw,dh,dw))", "from collections import deque\n\n\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = list(map(int, readline().split()))\n    Ch, Cw = [int(x) - 1 for x in readline().split()]\n    Dh, Dw = [int(x) - 1 for x in readline().split()]\n    S = [readline()[:-1] for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    for h in range(H):\n        th = t[h]\n        Sh = S[h]\n        for w in range(W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n    a = 0\n    warpq = []\n    while q:\n        while q:\n            h, w = q.popleft()\n            warpq.append((h, w))\n            if h - 1 >= 0 and t[h - 1][w] > a:\n                q.append((h - 1, w))\n                t[h - 1][w] = a\n            if h + 1 < H and t[h + 1][w] > a:\n                q.append((h + 1, w))\n                t[h + 1][w] = a\n            if w - 1 >= 0 and t[h][w - 1] > a:\n                q.append((h, w - 1))\n                t[h][w - 1] = a\n            if w + 1 < W and t[h][w + 1] > a:\n                q.append((h, w + 1))\n                t[h][w + 1] = a\n\n        if t[Dh][Dw] != INF:\n            break\n\n        a += 1\n        for h, w in warpq:\n            for i in range(max(0, h - 2), min(H, h + 3)):\n                ti = t[i]\n                for j in range(max(0, w - 2), min(W, w + 3)):\n                    if ti[j] > a:\n                        ti[j] = a\n                        q.append((i, j))\n        warpq.clear()\n\n    if t[Dh][Dw] == INF:\n        print((-1))\n    else:\n        print((t[Dh][Dw]))\n\n\nmain()\n", "from collections import deque\n\ndef solve():\n    H,W = map(int,input().split())\n    C = list(map(int,input().split()))\n    D = list(map(int,input().split()))\n\n    S = [\"##\" + input() + \"##\" for _ in range(H)]\n    for i in range(2):\n        S.insert(0,\"#\"*(W+4))\n        S.append(\"#\"*(W+4))\n\n    INF = float(\"inf\")\n    cost = [[INF for _ in range(W+4)] for _ in range(H+4)]\n    cost0 = deque()\n    ans = -1\n\n    cost0.append((C[0]+1, C[1]+1, 0))\n    cost[C[0]+1][C[1]+1] = 0\n\n    move = [(1,0), (0,1), (-1,0), (0,-1)]\n    warp = [(i, j) for i in range(-2, 3) for j in range(-2, 3) if (i, j) not in [(0, 0)]+move]\n\n    cost1 = deque()\n\n    while cost0:\n        h,w,c = cost0.popleft()\n        cost1.append((h,w,c))\n\n        for i, j in move:\n            dh = h+i\n            dw = w+j\n            if S[dh][dw] == \".\" and c < cost[dh][dw]:\n                cost[dh][dw] = c\n                cost0.appendleft((dh, dw, cost[dh][dw]))\n        \n        if len(cost0) == 0:\n            while cost1:\n                h, w, c = cost1.popleft()\n                for i, j in warp:\n                    dh = h+i\n                    dw = w+j\n                    if S[dh][dw] == \".\" and c+1 < cost[dh][dw]:\n                        cost[dh][dw] = c+1\n                        cost0.append((dh,dw, cost[dh][dw]))\n        \n        if cost[D[0]+1][D[1]+1] != INF:\n            ans = cost[D[0]+1][D[1]+1]\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n    \n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    \n    \n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for i in range(h):\n        s.append(\"##\" + input()[:-1] + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n    \n    \n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[ch][cw] = 0\n    \n    move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), \\\n             (-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2), \\\n             (0, -2), (0, -1), (0, 0), (0, 1), (0, 2), \\\n             (1, -2), (1, -1), (1, 0), (1, 1), (1, 2), \\\n             (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n        \n    not_yet = deque([(ch, cw)])\n    one_time = deque([])\n    \n    while len(not_yet) > 0:\n        x, y = not_yet.popleft()\n        one_time.append((x, y))\n        for (p, q) in move:\n            v1, v2 = x+p, y+q\n            if ans[v1][v2] == -1:\n                not_yet.append((v1, v2))\n                ans[v1][v2] = ans[x][y]\n                \n        if len(not_yet) == 0:\n            while len(one_time) > 0:\n                x2, y2 = one_time.popleft()\n                for (v1, v2) in move2:\n                    i, j = x2+v1, y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        not_yet.append((i, j))\n          \n    print((ans[dh][dw]))\n    \n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = list(map(int, readline().split()))\n    Ch, Cw = [int(x) - 1 for x in readline().split()]\n    Dh, Dw = [int(x) - 1 for x in readline().split()]\n    S = [readline()[:-1] for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    for h in range(H):\n        th = t[h]\n        Sh = S[h]\n        for w in range(W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n    warp_count = 0\n    warpq = []\n    while q:\n        while q:\n            warpq.append(q[0])\n            h, w = q.popleft()\n            if h - 1 >= 0 and t[h - 1][w] > warp_count:\n                q.append((h - 1, w))\n                t[h - 1][w] = warp_count\n            if h + 1 < H and t[h + 1][w] > warp_count:\n                q.append((h + 1, w))\n                t[h + 1][w] = warp_count\n            if w - 1 >= 0 and t[h][w - 1] > warp_count:\n                q.append((h, w - 1))\n                t[h][w - 1] = warp_count\n            if w + 1 < W and t[h][w + 1] > warp_count:\n                q.append((h, w + 1))\n                t[h][w + 1] = warp_count\n\n        if t[Dh][Dw] != INF:\n            break\n\n        warp_count += 1\n        for h, w in warpq:\n            for i in range(max(0, h - 2), min(H, h + 3)):\n                ti = t[i]\n                for j in range(max(0, w - 2), min(W, w + 3)):\n                    if ti[j] > warp_count:\n                        ti[j] = warp_count\n                        q.append((i, j))\n        warpq.clear()\n\n    if t[Dh][Dw] == INF:\n        print((-1))\n    else:\n        print((t[Dh][Dw]))\n\n\nmain()\n", "from collections import deque\n\ndef main():\n  h,w=map(int,input().split())\n  cy,cx=map(int,input().split())\n  dy,dx=map(int,input().split())\n\n  M=[\"##\"+input()+\"##\" for x in range(h)]\n  for i in range(2):\n    M.insert(0,\"#\"*(w+4))\n    M.append(\"#\"*(w+4))\n\n  C=[[-1 if M[j][i]==\".\" else -2 for i in range(w+4)] for j in range(h+4)]\n  C[-~cy][-~cx]=0\n  QA,QB=deque(),deque()\n  QA.append((-~cy,-~cx,0))\n  W=[[i,j] for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n\n  while QA:\n    h,w,c=QA.popleft()\n    QB.append((h,w,c))\n\n    for i,j in [[1,0],[0,1],[-1,0],[0,-1]]:\n      dh,dw=h+i,w+j\n      if C[dh][dw]==-1:\n        C[dh][dw]=c\n        QA.appendleft((dh,dw,c))\n\n    if QA:\n      continue\n\n    while QB:\n      h,w,c=QB.popleft()\n      for i,j in W:\n        dh,dw=h+i,w+j\n        if C[dh][dw]==-1:\n          C[dh][dw]=-~c\n          QA.append((dh,dw,-~c))\n\n  print(C[-~dy][-~dx])\n\ndef __starting_point():\n  main()\n__starting_point()", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n    # \u8ff7\u8def\u306e\u56db\u65b9\u3092##\u3067\u56f2\u3080\u3002\n    # \u79fb\u52d5\u3067\u67a0\u5916\u306b\u3067\u3066\u3057\u307e\u3063\u3066index\u304c\u306a\u3044\u3053\u3068\u3092\u963b\u6b62\u3059\u308b\u305f\u3081\u306e\n    # if\u6587\u3092\u56de\u907f\n    maze = ['#' * (w+4)]\n    maze.append('#' * (w+4))\n    for _ in range(h):\n        maze.append('##' + input()[:-1] + '##')\n    maze.append('#' * (w+4))\n    maze.append('#' * (w+4))\n    visited = [[-1] * (w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if maze[i][j] == '#':\n                visited[i][j] = -2\n    # \u3053\u306e\u6761\u4ef6\u3067\u306findex\u3092+1\u3057\u306a\u3044\u3068\u30c0\u30e1\n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    visited[ch][cw] = 0\n    walk = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    telepo = [[i,j] for i in range(-2, 3) for j in range(-2, 3)]\n\n    q_walk = deque([[ch, cw]])\n    q_telepo = deque([])\n    while q_walk:\n        yw, xw = q_walk.popleft()\n        # \u884c\u3063\u305f\u5834\u6240\u3092\u7ba1\u7406\n        q_telepo.append([yw, xw])\n        for i, j in walk:\n            ny, nx = yw + i, xw + j\n            # if ny < 0 or h <= ny or nx < 0 or w <= nx:\n            #     continue\n            if visited[ny][nx] == -1:\n                # \u884c\u3063\u305f\u3053\u3068\u3042\u308c\u30700\u306b\u3057\u3066\u3044\u304f\n                visited[ny][nx] = visited[yw][xw]\n                q_walk.append([ny, nx])\n        # \u6b69\u3051\u308b\u5834\u6240\u306a\u304f\u306a\u3063\u305f\u3089\u30ef\u30fc\u30d7\n        if len(q_walk) == 0:\n            while q_telepo:\n                yt, xt = q_telepo.popleft()\n                for i, j in telepo:\n                    my, mx = yt + i, xt + j\n                    # if my < 0 or h <= my or mx < 0 or w <= mx:\n                    #     continue\n                    # \u6b21\u304c\u307e\u3060\u884c\u3063\u305f\u3053\u3068\u306a\u3044\u3068\u3053\u308d\u3060\u3063\u305f\u3089\u3001\u4eca\u307e\u3067\u306e\u5024\u306b+1\n                    # \u3064\u307e\u308a\u3001\u30c6\u30ec\u30dd\u30fc\u30c8\u3057\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u5834\u6240\n                    if visited[my][mx] == -1:\n                        visited[my][mx] = visited[yt][xt] + 1\n                        q_walk.append([my, mx])\n    print((visited[dh][dw]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import numpy as np\nfrom collections import deque\n\ndef solve(H, W, CH, CW, DH, DW):#, S):\n\t# \u5f8c\u306e\u6761\u4ef6\u5206\u5c90\u3092\u7c21\u7565\u5316\u3059\u308b\u305f\u3081\u30ef\u30fc\u30d7\u3057\u3066\u3082\u8ff7\u8def\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u58c1\u3067\u56f2\u3080\n\tS=[input() for _ in range(H)]\n\tS = ['##{}##'.format(row) for row in S]\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.insert(0, '##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\tS.append('##{}##'.format('#' * W))\n\n\n\tMAX_COST = 10 ** 9\n\tCost=[ [ MAX_COST for _ in range(W+4)] for _ in range(H+4)]\n\t# Cost = np.full((H,W),MAX_COST)\n\n\t# print(S)\n\n\tans = -1\n\n\tcost0 = deque()\n\n\tcost0.append((CH+1,CW+1,0))\n\tCost[CH+1][CW+1] = 0;\n\n\t# used = set()\n\twalk=[(1,0),(0,1),(-1,0),(0,-1)]\n\twarp = [ (i,j) for i in range(-2,3) for j in range(-2,3) if (i, j) not in [(0, 0)] + walk ]\n\t# print(warp)\n\n\tcost1 = deque()\n\n\twhile cost0:\n\t\th,w,c=cost0.popleft()\n\t\tcost1.append((h,w,c))\n\n\t\tfor i,j in walk:\n\t\t\tdh = h+i\n\t\t\tdw = w+j\n\t\t\tif S[dh][dw] == '.' and c < Cost[dh][dw]:\n\t\t\t\tCost[dh][dw] = c\n\t\t\t\t# print(\"updl \", i,j,dh,dw,c)\n\t\t\t\tcost0.appendleft((dh,dw,Cost[dh][dw]))\n\n\t\tif len(cost0) == 0:\n\n\t\t\twhile cost1:\n\t\t\t\th,w,c=cost1.popleft()\n\t\t\t\t# print(h,w,c)\n\t\t\t\tfor i,j in warp:\n\t\t\t\t\tdh = h+i\n\t\t\t\t\tdw = w+j\n\t\t\t\t\t# print(i,j)\n\t\t\t\t\tif S[dh][dw] == '.' and c + 1 < Cost[dh][dw]:\n\t\t\t\t\t\tCost[dh][dw] = c + 1\n\t\t\t\t\t\tcost0.append((dh,dw,Cost[dh][dw]))\n\n\n\tif Cost[DH+1][DW+1] == MAX_COST:\n\t\tprint((-1))\n\telse:\n\t\tprint((Cost[DH+1][DW+1]))\n\n\ndef __starting_point():\n\tH,W=list(map(int,input().split()))\n\tCH,CW=list(map(int,input().split()))\n\tDH,DW=list(map(int,input().split()))\n\n\t# S=[input() for _ in range(H)]\n\n\tsolve(H, W, CH, CW, DH, DW)#, S)\n\n__starting_point()", "from collections import deque\n\n\ndef solve(H, W, Ch, Cw, Dh, Dw, maze):\n    # \u5f8c\u306e\u6761\u4ef6\u5206\u5c90\u3092\u7c21\u7565\u5316\u3059\u308b\u305f\u3081\u30ef\u30fc\u30d7\u3057\u3066\u3082\u8ff7\u8def\u5916\u306b\u51fa\u306a\u3044\u3088\u3046\u306b\u58c1\u3067\u56f2\u3080\n    walled_maze = ['##{}##'.format(row) for row in maze]\n    walled_maze.insert(0, '##{}##'.format('#' * W))\n    walled_maze.insert(0, '##{}##'.format('#' * W))\n    walled_maze.append('##{}##'.format('#' * W))\n    walled_maze.append('##{}##'.format('#' * W))\n\n    INF = 10 ** 12\n    path = [[INF] * (W + 4) for _ in range(H + 4)]\n    walk = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    warp = [(i, j) for i in range(-2, 3) for j in range(-2, 3) if (i, j) not in [(0, 0)] + walk]\n\n    yet = deque()\n    yet.append((Ch + 2, Cw + 2, 0))    # \u56f2\u3063\u305f\u58c1\u306e\u5206\u3060\u3051\u30d7\u30e9\u30b9\n    path[Ch + 2][Cw + 2] = 0\n    done = deque()\n\n    while yet:\n        y, x, s = yet.popleft()\n        done.append((y, x, s))\n        for dy, dx in walk:\n            ny = y + dy\n            nx = x + dx\n            if walled_maze[ny][nx] == '.' and path[ny][nx] > s:\n                path[ny][nx] = s\n                yet.append((ny, nx, s))\n        if len(yet) == 0:\n            while done:\n                y, x, s = done.popleft()\n                for dy, dx in warp:\n                    ny = y + dy\n                    nx = x + dx\n                    if walled_maze[ny][nx] == '.' and path[ny][nx] > s + 1:\n                        path[ny][nx] = s + 1\n                        yet.append((ny, nx, s + 1))\n    ans = path[Dh + 2][Dw + 2] if path[Dh + 2][Dw + 2] < INF else -1\n    print(ans)\n\n\ndef __starting_point():\n    H, W = list(map(int, input().split()))\n    Ch, Cw = [int(x) - 1 for x in input().split()]\n    Dh, Dw = [int(x) - 1 for x in input().split()]\n    maze = [input() for _ in range(H)]\n    solve(H, W, Ch, Cw, Dh, Dw, maze)\n\n__starting_point()", "\nfrom collections import deque\n\n\ndef main():\n    h, w = list(map(int, input().split()))\n    ch, cw = list(map(int, input().split()))\n    dh, dw = list(map(int, input().split()))\n\n    \"\"\"\n    l = [list(input().strip()) for i in range(h)]\n    ans = [[-1]*w for i in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if l[i][j] == \"#\":\n                ans[i][j] = -2\n    ch -= 1\n    cw -= 1\n    dh -= 1\n    dw -= 1\n    \"\"\"\n\n    base = [\"#\" * (w + 4)]\n    base.append(\"#\" * (w + 4))\n    for n in range(h):\n        base.append(\"##\" + input() + \"##\")\n    base.append(\"#\" * (w + 4))\n    base.append(\"#\" * (w + 4))\n    ans = [[-1] * (w + 4) for _ in range(h + 4)]\n    for i in range(h + 4):\n        for j in range(w + 4):\n            if base[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    \n    ans[ch][cw] = 0\n    move1 = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    move2 = [\n        [-2, -2], [-2, -1], [-2, 0], [-2, 1], [-2, 2], [-1, -2], [-1, -1],\n        [-1, 1], [-1, 2], [0, -2], [0, 2], [1, -2], [1, -1], [1, 1],\n        [1, 2], [2, -2], [2, -1], [2, 0], [2, 1], [2, 2]\n    ]\n    q1 = deque([[ch, cw]])\n    q2 = deque([])\n\n    while q1:\n        x1, y1 = q1.popleft()\n        q2.append([x1, y1])\n        for i, j in move1:\n            nx, ny = x1 + i, y1 + j\n            \"\"\"\n            if nx < 0 or h <= nx or ny < 0 or w <= ny:\n                continue\n            \"\"\"\n            if ans[nx][ny] == -1:\n                ans[nx][ny] = ans[x1][y1]\n                q1.append([nx, ny])\n        if len(q1) == 0:\n            while q2:\n                x2, y2 = q2.popleft()\n                for i, j in move2:\n                    mx, my = x2 + i, y2 + j\n                    \"\"\"\n                    if mx < 0 or h <= mx or my < 0 or w <= my:\n                        continue\n                    \"\"\"\n                    if ans[mx][my] == -1:\n                        ans[mx][my] = ans[x2][y2] + 1\n                        q1.append([mx, my])\n    print((ans[dh][dw]))\n\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "from collections import deque\n\ndef main():\n  h,w=list(map(int,input().split()))\n  cy,cx=list(map(int,input().split()))\n  dy,dx=list(map(int,input().split()))\n\n  M=[\"##\"+input()+\"##\" for x in range(h)]\n  for i in range(2):\n    M.insert(0,\"#\"*(w+4))\n    M.append(\"#\"*(w+4))\n\n  C=[[-1 if M[j][i]==\".\" else -2 for i in range(w+4)] for j in range(h+4)]\n  C[-~cy][-~cx]=0\n  QA,QB=deque(),deque()\n  QA.append((-~cy,-~cx,0))\n  W=[[i,j] for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n\n  while QA:\n    h,w,c=QA.popleft()\n    QB.append((h,w,c))\n\n    for i,j in [[1,0],[0,1],[-1,0],[0,-1]]:\n      dh,dw=h+i,w+j\n      if C[dh][dw]==-1:\n        C[dh][dw]=c\n        QA.appendleft((dh,dw,c))\n\n    if QA:\n      continue\n\n    while QB:\n      h,w,c=QB.popleft()\n      for i,j in W:\n        dh,dw=h+i,w+j\n        if C[dh][dw]==-1:\n          C[dh][dw]=-~c\n          QA.append((dh,dw,-~c))\n\n  print((C[-~dy][-~dx]))\n\ndef __starting_point():\n  main()\n\n__starting_point()", "#\u5199\u7d4c\u30b3\u30fc\u30c9\u3067\u3059\u3002\nfrom collections import deque\n\ndef main():\n  h,w=map(int,input().split())\n  cy,cx=map(int,input().split())\n  dy,dx=map(int,input().split())\n\n  M=[\"##\"+input()+\"##\" for x in range(h)]\n  for i in range(2):\n    M.insert(0,\"#\"*(w+4))\n    M.append(\"#\"*(w+4))\n\n  C=[[-1 if M[j][i]==\".\" else -2 for i in range(w+4)] for j in range(h+4)]\n  C[-~cy][-~cx]=0\n  QA,QB=deque(),deque()\n  QA.append((-~cy,-~cx,0))\n  W=[[i,j] for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n\n  while QA:\n    h,w,c=QA.popleft()\n    QB.append((h,w,c))\n\n    for i,j in [[1,0],[0,1],[-1,0],[0,-1]]:\n      dh,dw=h+i,w+j\n      if C[dh][dw]==-1:\n        C[dh][dw]=c\n        QA.appendleft((dh,dw,c))\n\n    if QA:\n      continue\n\n    while QB:\n      h,w,c=QB.popleft()\n      for i,j in W:\n        dh,dw=h+i,w+j\n        if C[dh][dw]==-1:\n          C[dh][dw]=-~c\n          QA.append((dh,dw,-~c))\n\n    if C[-~dy][-~dx]!=-1:\n      print(C[-~dy][-~dx])\n      return\n\n  print(C[-~dy][-~dx])\n\ndef __starting_point():\n  main()\n__starting_point()", "from collections import deque\n\n\ndef main():\n    from sys import stdin\n    readline = stdin.readline\n\n    from builtins import max, min, range\n\n    INF = 10 ** 6\n\n    H, W = map(int, readline().split())\n    Ch, Cw = map(lambda x: int(x) - 1, readline().split())\n    Dh, Dw = map(lambda x: int(x) - 1, readline().split())\n    S = [readline()[:-1] for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    for h in range(H):\n        th = t[h]\n        Sh = S[h]\n        for w in range(W):\n            if Sh[w] == '#':\n                th[w] = -1\n\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n    a = 0\n    while q:\n        warpq = []\n        while q:\n            h, w = q.popleft()\n            warpq.append((h, w))\n            if h - 1 >= 0 and t[h - 1][w] > a:\n                q.append((h - 1, w))\n                t[h - 1][w] = a\n            if h + 1 < H and t[h + 1][w] > a:\n                q.append((h + 1, w))\n                t[h + 1][w] = a\n            if w - 1 >= 0 and t[h][w - 1] > a:\n                q.append((h, w - 1))\n                t[h][w - 1] = a\n            if w + 1 < W and t[h][w + 1] > a:\n                q.append((h, w + 1))\n                t[h][w + 1] = a\n\n        if t[Dh][Dw] != INF:\n            break\n\n        a += 1\n        for h, w in warpq:\n            for i in range(max(0, h - 2), min(H, h + 3)):\n                ti = t[i]\n                for j in range(max(0, w - 2), min(W, w + 3)):\n                    if ti[j] > a:\n                        ti[j] = a\n                        q.append((i, j))\n\n    if t[Dh][Dw] == INF:\n        print(-1)\n    else:\n        print(t[Dh][Dw])\n\n\nmain()", "import heapq\nimport numpy as np\nfrom numba import njit,i8,b1\n\nh,w = map(int,input().split())\nsh,sw = map(int,input().split())\ngh,gw = map(int,input().split())\ns = np.array([list(input()) for _ in range(h)]) == \"#\"\n\n@njit(i8(i8,i8,i8,i8,i8,i8,b1[:,:]))\ndef solve(h,w,sh,sw,gh,gw,s):\n\n    sh-=1; sw-=1; gh-=1; gw-=1;\n\n    INF = 10**7\n    dist = [[INF]*w for _ in range(h)]\n    dist[sh][sw] = 0\n    q = [(0,sh,sw)]\n    while q:\n\n        d,vsh,vsw = heapq.heappop(q)\n\n        for dh in range(-2,3):\n            for dw in range(-2,3):\n                newh = vsh+dh\n                neww = vsw+dw\n                if newh<0 or h<=newh or neww<0 or w<=neww: continue\n                if dh == 0 and dw==0: continue\n                if s[newh][neww] : continue\n\n\n                if abs(dh)+abs(dw)==1:\n                    if dist[newh][neww] > d:\n                        dist[newh][neww] = d\n                        if newh == gh and neww == gw:\n                            return d\n                        heapq.heappush(q,(d,newh,neww))\n                else:\n                    if dist[newh][neww] > d+1:\n                        dist[newh][neww] = d+1\n                        heapq.heappush(q,(d+1,newh,neww))\n    if dist[gh][gw] == INF:\n        return -1\n    else: return dist[gh][gw]\n        \nprint(solve(h,w,sh,sw,gh,gw,s))", "from collections import *\n\ndef main():\n    H,W = map(int, input().split())\n    ch,cw = map(int, input().split())\n    dh,dw = map(int, input().split())\n    s = [\"#\"*(W+4)]\n    s.append(\"#\"*(W+4))\n    for i in range(H):\n        s.append(\"##\"+input()+\"##\")\n    s.append(\"#\"*(W+4))\n    s.append(\"#\"*(W+4))\n    \n    ans = [[-1]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n        for j in range(W+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1; cw += 1\n    dh += 1; dw += 1\n    ans[ch][cw] = 0\n    \n    move = [[-1,0],[1,0],[0,-1],[0,1]]\n    magic = [\n        [-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],\\\n        [-1,-2],[-1,-1],[-1,0],[-1,1],[-1,2],\\\n        [0,-2],[0,-1],[0,0],[0,1],[0,2],\\\n        [1,-2],[1,-1],[1,0],[1,1],[1,2],\\\n        [2,-2],[2,-1],[2,0],[2,1],[2,2]\n        ]\n    \n    mylist = deque([[ch,cw]])\n    mylist2 = deque([])\n    while len(mylist) > 0:\n        x,y = mylist.popleft()\n        mylist2.append([x,y])\n        for p,q in move:\n            v1,v2 = x+p,y+q\n            if ans[v1][v2] == -1:\n                mylist.append([v1,v2])\n                ans[v1][v2] = ans[x][y]\n        if len(mylist) == 0:\n            while len(mylist2) > 0:\n                x2,y2 = mylist2.popleft()\n                for v1,v2 in magic:\n                    i,j = x2+v1,y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        mylist.append([i,j])\n    print(ans[dh][dw])\n \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\nH, W = map(int, input().split())\nc = tuple(int(x)+1 for x in input().split())\nd = [int(x)+1 for x in input().split()]\nmaze = [[-1] * (W+4), [-1] * (W+4)]\n\nfor i in range(H):\n    temp = []\n    s0 = input()\n    s0 = '11' + s0.replace('.', '0').replace('#', '1') + '11'\n    for j, s in enumerate(s0):\n        temp.append(-int(s))\n    maze.append(temp)\nmaze.append([-1] * (W+4))\nmaze.append([-1] * (W+4))\n\ndef check55(i, j):\n    cset = {(ii, jj) for ii in range(i-2, i+3) for jj in range(j-2, j+3) if maze[ii][jj]==0}\n    cset = cset - {(i-1, j), (i, j), (i+1, j), (i, j-1), (i, j+1)}\n    return cset\n\ndef check(i, j, delta):\n    if delta[0] != 0:\n        ii = i + 3 * delta[0]\n        for jj in range(j-2, j+3):\n            if maze[ii][jj]==0:\n                dset.add((ii, jj))\n\n    else:\n        jj = j + 3 * delta[1]\n        for ii in range(i-2, i+3):\n            if maze[ii][jj]==0:\n                dset.add((ii, jj))\n\n    return\n\n#bfs\n\nk = 1\ntempbfs = deque([[c[0], c[1], k]])\nflag = 0\nwhile tempbfs:\n    if flag == 1:break\n    p = tempbfs.popleft()\n\n    #dfs\n    if maze[p[0]][p[1]] != 0:continue\n    maze[p[0]][p[1]] = p[2]\n    if p[0] == d[0] and p[1] == d[1]:\n        flag = 1\n        k = p[2]\n        break\n    temp = [(p[0], p[1])]\n    dset = set()\n    while temp:\n        p0 = temp.pop()\n        for delta in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            y = p0[0] + delta[0]\n            x = p0[1] + delta[1]\n            if maze[y][x] != 0: continue\n            maze[y][x] = p[2]\n            if y == d[0] and x == d[1]:\n                flag = 1\n                k = p[2]\n                break\n            temp.append((y, x))\n            check(p0[0], p0[1], delta)\n\n    if flag == 1: break\n    for l in dset:\n        if maze[l[0]][l[1]] == 0:\n            tempbfs.append([l[0], l[1], p[2]+1])\n    dset = check55(p[0], p[1])\n    for l in dset:\n        tempbfs.append([l[0], l[1], p[2]+1])\n\nprint(k - 1 if flag else -1)", "from collections import *\n\ndef main():\n    H,W = map(int, input().split())\n    ch,cw = map(int, input().split())\n    dh,dw = map(int, input().split())\n    s = [\"#\"*(W+4)]\n    s.append(\"#\"*(W+4))\n    for i in range(H):\n        s.append(\"##\"+input()+\"##\")\n    s.append(\"#\"*(W+4))\n    s.append(\"#\"*(W+4))\n    \n    ans = [[-1]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n        for j in range(W+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1; cw += 1\n    dh += 1; dw += 1\n    ans[ch][cw] = 0\n    \n    move = [[-1,0],[1,0],[0,-1],[0,1]]\n    magic = [[-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],[-1,-2],[-1,-1],[-1,1],[-1,2],[0,-2],[0,2],[1,-2],[1,-1],[1,1],[1,2],[2,-2],[2,-1],[2,0],[2,1],[2,2]]\n    \n    mylist = deque([[ch,cw]])\n    mylist2 = deque([])\n    while len(mylist) > 0:\n        x,y = mylist.popleft()\n        mylist2.append([x,y])\n        for p,q in move:\n            v1,v2 = x+p,y+q\n            if ans[v1][v2] == -1:\n                mylist.append([v1,v2])\n                ans[v1][v2] = ans[x][y]\n        if len(mylist) == 0:\n            while len(mylist2) > 0:\n                x2,y2 = mylist2.popleft()\n                for v1,v2 in magic:\n                    i,j = x2+v1,y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        mylist.append([i,j])\n    print(ans[dh][dw])\n \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n\ndef main():\n    h, w = list(map(int, input().split()))\n    start_h, start_w = [int(x)+1 for x in input().split()]\n    goal_h, goal_w = [int(x)+1 for x in input().split()]\n\n    s = [\"#\"*(w+4)]\n    s.append(\"#\"*(w+4))\n    for _ in range(h):\n        s.append(\"##\" + input() + \"##\")\n    s.append(\"#\"*(w+4))\n    s.append(\"#\"*(w+4))\n\n    ans = [[-1]*(w+4) for _ in range(h+4)]\n    for i in range(h+4):\n        for j in range(w+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ans[start_h][start_w] = 0\n\n    move1 = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2),(-1, -2), (-1, -1), (-1, 0), (-1, 1), (-1, 2),(0, -2), (0, -1), (0, 0), (0, 1), (0, 2),(1, -2), (1, -1), (1, 0), (1, 1), (1, 2),(2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\n    yet = deque([(start_h, start_w)])\n    done = deque()\n\n    while yet:\n        x1, y1 = yet.popleft()\n        done.append((x1, y1))\n        for (p, q) in move1:\n            v1, v2 = x1+p, y1+q\n            if ans[v1][v2] == -1: #\".\"\u3067\u307e\u3060\u8fbf\u308a\u7740\u3044\u3066\u3044\u306a\u3044\u30de\u30b9\n                yet.append((v1, v2))\n                ans[v1][v2] = ans[x1][y1]\n\n        if len(yet) == 0:\n            while done:\n                x2, y2 = done.popleft()\n                for (p, q) in move2:\n                    i, j = x2+p, y2+q\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        yet.append((i, j))\n\n    print((ans[goal_h][goal_w]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    H, W = list(map(int, input().split()))\n\n    y, x = list(map(int, input().split()))\n    start = (x+1, y+1)\n\n    y, x = list(map(int, input().split()))\n    goal = (x+1, y+1)\n\n    dist_table = [[-2] * (W+4)]\n    dist_table.append([-2] * (W+4))\n    for _ in range(H):\n        row = '##' + input() + '##'\n        row = [-1 if c == '.' else -2 for c in row]\n        dist_table.append(row)\n    dist_table.append([-2] * (W+4))\n    dist_table.append([-2] * (W+4))\n\n\n\n    sx, sy = start\n    dist_table[sy][sx] = 0\n\n    move1 = ((-1, 0), (1, 0), (0, 1), (0, -1))\n    move2 = ((-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2),\\\n            (-1, -2), (-1, -1), (-1, 1), (-1, 2),\\\n            (0, -2), (0, 2),\\\n            (1, -2), (1, -1), (1, 1), (1, 2),\\\n            (2, -2), (2, -1), (2, 0), (2, 1), (2, 2))\n\n    queue1 = [start]\n    queue2 = []\n\n    while queue1:\n        now_x, now_y = queue1.pop()\n        if (now_x, now_y) == goal:\n            break\n        queue2.append((now_x, now_y))\n        dist = dist_table[now_y][now_x]\n        for dx, dy in move1:\n            tx, ty = now_x + dx, now_y + dy\n            if dist_table[ty][tx] == -1:\n                dist_table[ty][tx] = dist\n                queue1.append((tx, ty))\n        if len(queue1) == 0:\n            while queue2:\n                now_x, now_y = queue2.pop()\n                dist = dist_table[now_y][now_x]\n                for dx, dy in move2:\n                    tx, ty = now_x + dx, now_y + dy\n                    if dist_table[ty][tx] == -1:\n                        dist_table[ty][tx] = dist + 1\n                        queue1.append((tx, ty))\n    gx, gy = goal\n    print((dist_table[gy][gx]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W = list(map(int, input().split()))\nCh, Cw = list(map(int, input().split()))\nDh, Dw = list(map(int, input().split()))\n\nCh += 1\nCw += 1\nDh += 1\nDw += 1\n\nstart = (Ch, Cw)\n\nS = ['#'*(W+4)]\nS.append('#'*(W+4))\nfor k in range(H):\n  S.append('##' + input() + '##')\nS.append('#'*(W+4))\nS.append('#'*(W+4))\n\ncounter = [[-1 for _ in range(W+4)] for _ in range(H+4)]\nfor k in range(2, H+2):\n  for j in range(2, W+2):\n    if S[k][j] == '.':\n      counter[k][j] = 10**7\n\ncounter[Ch][Cw] = 0\n\n#print(counter)\n#print(S)\n\nnow = [start]\nnow_2 = [start]\nwhile len(now_2) > 0:\n  new = []\n  for item in now_2:\n    x = item[0]\n    y = item[1]\n    if counter[x+1][y] == 10**7:\n      counter[x+1][y] = 0\n      new.append((x+1, y))\n    if counter[x][y+1] == 10**7:\n      counter[x][y+1] = 0\n      new.append((x, y+1))\n    if counter[x-1][y] == 10**7:\n      counter[x-1][y] = 0\n      new.append((x-1, y))\n    if counter[x][y-1] == 10**7:\n      counter[x][y-1] = 0\n      new.append((x, y-1))\n  now += new\n  now_2 = new\n#print(now)\n#print(counter)\nif counter[Dh][Dw] == 0:\n  print((0))\n  return\nans = 0\nwhile counter[Dh][Dw] == 10**7:\n  if len(now) == 0:\n    print((-1))\n    return \n  nextlist = []\n  ans += 1\n  for item in now:\n    x = item[0]\n    y = item[1]\n    if counter[x+2][y+2] > ans:\n      counter[x+2][y+2] = ans\n      nextlist.append((x+2, y+2))\n    if counter[x+2][y+1] > ans:\n      counter[x+2][y+1] = ans\n      nextlist.append((x+2, y+1))\n    if counter[x+2][y] > ans:\n      counter[x+2][y] = ans\n      nextlist.append((x+2, y))\n    if counter[x+2][y-1] > ans:\n      counter[x+2][y-1] = ans\n      nextlist.append((x+2, y-1))\n    if counter[x+2][y-2] > ans:\n      counter[x+2][y-2] = ans\n      nextlist.append((x+2, y-2))\n    if counter[x+1][y+2] > ans:\n      counter[x+1][y+2] = ans\n      nextlist.append((x+1, y+2))\n    if counter[x+1][y-2] > ans:\n      counter[x+1][y-2] = ans\n      nextlist.append((x+1, y-2))\n    if counter[x][y+2] > ans:\n      counter[x][y+2] = ans\n      nextlist.append((x, y+2))\n    if counter[x][y-2] > ans:\n      counter[x][y-2] = ans\n      nextlist.append((x, y-2))\n    if counter[x-2][y+2] > ans:\n      counter[x-2][y+2] = ans\n      nextlist.append((x-2, y+2))\n    if counter[x-2][y+1] > ans:\n      counter[x-2][y+1] = ans\n      nextlist.append((x-2, y+1))\n    if counter[x-2][y] > ans:\n      counter[x-2][y] = ans\n      nextlist.append((x-2, y))\n    if counter[x-2][y-1] > ans:\n      counter[x-2][y-1] = ans\n      nextlist.append((x-2, y-1))\n    if counter[x-2][y-2] > ans:\n      counter[x-2][y-2] = ans\n      nextlist.append((x-2, y-2))\n    if counter[x-1][y+2] > ans:\n      counter[x-1][y+2] = ans\n      nextlist.append((x-1, y+2))\n    if counter[x-1][y-2] > ans:\n      counter[x-1][y-2] = ans\n      nextlist.append((x-1, y-2))\n    if counter[x-1][y-1] > ans:\n      counter[x-1][y-1] = ans\n      nextlist.append((x-1, y-1))\n    if counter[x-1][y+1] > ans:\n      counter[x-1][y+1] = ans\n      nextlist.append((x-1, y+1))\n    if counter[x+1][y+1] > ans:\n      counter[x+1][y+1] = ans\n      nextlist.append((x+1, y+1))\n    if counter[x+1][y-1] > ans:\n      counter[x+1][y-1] = ans\n      nextlist.append((x+1, y-1))\n      \n  \n  now_2 = nextlist\n  while len(now_2) > 0:\n    new = []\n    for item in now_2:\n      x = item[0]\n      y = item[1]\n      if counter[x+1][y] == 10**7:\n        counter[x+1][y] = 0\n        new.append((x+1, y))\n      if counter[x][y+1] == 10**7:\n        counter[x][y+1] = 0\n        new.append((x, y+1))\n      if counter[x-1][y] == 10**7:\n        counter[x-1][y] = 0\n        new.append((x-1, y))\n      if counter[x][y-1] == 10**7:\n        counter[x][y-1] = 0\n        new.append((x, y-1))\n    nextlist += new\n    now_2 = new\n  now = nextlist\n  #print(now)\n  if ans > 10**7:\n    print((-1))\n    return\nprint(ans)      \n    \n", "from collections import deque\n \n \n# In[30]:\n \n \ndef main():\n    H,W = map(int, input().split())\n    ch,cw = map(int, input().split())\n    dh,dw = map(int, input().split())\n    s = [\"#\"*(W+4)]\n    s.append(\"#\"*(W+4))\n    for i in range(H):\n        s.append(\"##\"+input()+\"##\")\n    s.append(\"#\"*(W+4))\n    s.append(\"#\"*(W+4))\n    \n    ans = [[-1]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n        for j in range(W+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1; cw += 1\n    dh += 1; dw += 1\n    ans[ch][cw] = 0\n    \n    move = [[-1,0],[1,0],[0,-1],[0,1]]\n    magic = [\n        [-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],\\\n        [-1,-2],[-1,-1],[-1,0],[-1,1],[-1,2],\\\n        [0,-2],[0,-1],[0,0],[0,1],[0,2],\\\n        [1,-2],[1,-1],[1,0],[1,1],[1,2],\\\n        [2,-2],[2,-1],[2,0],[2,1],[2,2]\n        ]\n    \n    mylist = deque([[ch,cw]])\n    mylist2 = deque([])\n    while len(mylist) > 0:\n        x,y = mylist.popleft()\n        mylist2.append([x,y])\n        for p,q in move:\n            v1,v2 = x+p,y+q\n            if ans[v1][v2] == -1:\n                mylist.append([v1,v2])\n                ans[v1][v2] = ans[x][y]\n        if len(mylist) == 0:\n            while len(mylist2) > 0:\n                x2,y2 = mylist2.popleft()\n                for v1,v2 in magic:\n                    i,j = x2+v1,y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        mylist.append([i,j])\n    print(ans[dh][dw])\n \ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\ndef main():\n  h,w = map(int,input().split())\n  ch,cw = map(lambda x:int(x)+1,input().split())\n  dh,dw = map(lambda x:int(x)+1,input().split())\n  s = [[\"#\"]*(w+4) for _ in range(2)]+[[\"#\"]*2+list(input())+[\"#\"]*2 for _ in range(h)]+[[\"#\"]*(w+4) for _ in range(2)]\n  m1 = ((-1,0),(0,-1),(0,1),(1,0))\n  m2 = [(i,j) for i in range(-2,3) for j in range(-2,3) if abs(i)+abs(j)>1]\n  a = deque([(ch,cw)])\n  b = deque()\n  i = 0\n  while a:\n    while a:\n      ah,aw = a.popleft()\n      if s[ah][aw]!=\".\":\n        continue\n      b.append((ah,aw))\n      s[ah][aw] = i\n      for bh,bw in m1:\n        bh,bw = ah+bh,aw+bw\n        if s[bh][bw]==\".\":\n          a.append((bh,bw))\n    while b:\n      ah,aw = b.popleft()\n      for bh,bw in m2:\n        bh,bw = ah+bh,aw+bw\n        if s[bh][bw]==\".\":\n          a.append((bh,bw))\n    i += 1\n  ans = s[dh][dw]\n  print(ans if ans != \".\" else -1)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\n#\u30ef\u30fc\u30d7\u306a\u3057\u3067\u9032\u3093\u3060\u5f8c\u306b\u30ef\u30fc\u30d7\u3092\u884c\u3046\ndef main():\n    H, W = map(int, input().split())\n    ch, cw = map(int, input().split())\n    dh, dw = map(int, input().split())\n    # ######\n    # ######\n    # ##in##\n    # ######\n    # ######\n    s = [\"#\"*(W+4)]\n    s.append(\"#\"*(W+4))\n    for i in range(H):\n        s.append(\"##\"+input()+\"##\")\n    s.append(\"#\"*(W+4))\n    s.append(\"#\"*(W+4))\n\n    ans = [[-1]*(W+4) for _ in range(H+4)]\n    for i in range(H+4):\n        for j in range(W+4):\n            if s[i][j] == \"#\":\n                ans[i][j] = -2\n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    ans[ch][cw] = 0\n    # \u79fb\u52d5\u5909\u4f4d\n    move = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    magic = [[-2, -2], [-2, -1], [-2, 0], [-2, 1], [-2, 2], [-1, -2], [-1, -1], [-1, 1], [-1, 2],\n             [0, -2], [0, 2], [1, -2], [1, -1], [1, 1], [1, 2], [2, -2], [2, -1], [2, 0], [2, 1], [2, 2]]\n    # \u4f4d\u7f6e\n    mylist = deque([[ch, cw]])\n    mylist2 = deque([])\n    while len(mylist) > 0:\n        x, y = mylist.popleft()\n        mylist2.append([x, y])\n        for p, q in move:\n            v1, v2 = x+p, y+q\n            # \u79fb\u52d5\u53ef\u80fd\n            if ans[v1][v2] == -1:\n                mylist.append([v1, v2])\n                ans[v1][v2] = ans[x][y]\n        # \u52d5\u3051\u306a\u304f\u306a\u3063\u305f\u5834\u5408\n        if len(mylist) == 0:\n            # \n            while len(mylist2) > 0:\n                x2, y2 = mylist2.popleft()\n                for v1, v2 in magic:\n                    i, j = x2+v1, y2+v2\n                    if ans[i][j] == -1:\n                        ans[i][j] = ans[x2][y2]+1\n                        mylist.append([i, j])\n    print(ans[dh][dw])\ndef __starting_point():\n    main()\n__starting_point()"]
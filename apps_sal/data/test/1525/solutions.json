["def check(amidakuji,w):\n    before=0\n    flag=True\n    for _ in range(w-1):\n        if amidakuji&1==1 and before==1:\n            flag=False\n            break\n        elif amidakuji&1==1:\n            before=1\n            amidakuji>>=1\n        else:\n            before=0\n            amidakuji>>=1\n    return flag\n\nfrom sys import stdin\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    mod=10**9+7\n    h,w,k=map(int,readline().split())\n\n    dp=[[0]*w for _ in range(h+1)]\n    dp[0][0]=1\n    for i in range(1,h+1):\n        for bit in range(1<<(w-1)):\n            if check(bit,w)==False:\n                continue\n            else:\n                for j in range(w):\n                    if j==0:\n                        if bit&1==1:\n                            dp[i][j+1]+=dp[i-1][j]\n                        else:\n                            dp[i][j]+=dp[i-1][j]\n                    elif j==w-1:\n                        if bit&1==1:\n                            dp[i][j-1]+=dp[i-1][j]\n                        else:\n                            dp[i][j]+=dp[i-1][j]\n                    else:\n                        if bit&1==1:\n                            dp[i][j-1]+=dp[i-1][j]\n                            bit>>=1\n                        else:\n                            bit>>=1\n                            if bit&1==1:\n                                dp[i][j+1]+=dp[i-1][j]\n                            else:\n                                dp[i][j]+=dp[i-1][j]\n\n                for j in range(w):\n                    dp[i][j]%=mod\n\n    print(dp[h][k-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "h, w, k = list(map(int, input().split()))\nmod = 10**9+7\n\nif w == 1:\n    print((1))\n    return\n\ndp = [[0]*w for _ in range(h+1)]\ndp[0][0] = 1\nfor i in range(1, h+1):\n    for p in range(2**(w-1)):\n        L = [0]*(w-1)\n        for q in range(w-1):\n            if (p >> q) & 1:\n                L[q] = 1\n        flag = True\n        for q in range(w-2):\n            if L[q] == 1 and L[q+1] == 1:\n                flag = False\n        if not flag:\n            continue\n        for j in range(w):\n            if j == 0:\n                if L[j] == 1:\n                    dp[i][j] += dp[i-1][1]\n                else:\n                    dp[i][j] += dp[i-1][0]\n            elif j == w-1:\n                if L[j-1] == 1:\n                    dp[i][j] += dp[i-1][w-2]\n                else:\n                    dp[i][j] += dp[i-1][w-1]\n            else:\n                if L[j-1] == 1:\n                    dp[i][j] += dp[i-1][j-1]\n                elif L[j] == 1:\n                    dp[i][j] += dp[i-1][j+1]\n                else:\n                    dp[i][j] += dp[i-1][j]\n            dp[i][j] %= mod\n\n#print(dp)\nprint((dp[h][k-1]))\n", "h,w,k_=list(map(int,input().split()))\nmod=pow(10,9)+7\nif w==1:\n  print((1))\n  return\n# \u9077\u79fb\u306e\u4ed5\u65b9\nsen=[[0]*3 for _ in range(w)]\nfor j in range(2**(w-1)):\n  yoko=[0]*(w-1)\n  for k in range(w-1):\n    if (j>>k) & 1:\n      yoko[k]=1\n  flg=True\n  for k in range(w-2):\n    if yoko[k]==1 and yoko[k+1]==1:\n      flg=False\n      break\n  if not flg:continue\n  for k in range(w):\n    if k==0:\n      if yoko[k]==1:\n        sen[k+1][0]+=1\n      else:\n        sen[k][2]+=1\n    elif k<w-1:\n      if yoko[k]==1:\n        sen[k+1][0]+=1\n      elif yoko[k-1]==1:\n        sen[k-1][1]+=1\n      else:\n        sen[k][2]+=1\n    else:\n      if yoko[k-1]==1:\n        sen[k-1][1]+=1\n      else:\n        sen[k][2]+=1\n\nimport numpy as np \ndp=np.zeros((h+1,w),int)\ndp[0,0]=1\nfor i in range(h):\n  dp[i+1,0]=sen[0][2]*dp[i,0]+sen[0][1]*dp[i,1]\n  for j in range(1,w-1):\n    dp[i+1,j]=sen[j][2]*dp[i,j]+sen[j][1]*dp[i,j+1]+sen[j][0]*dp[i,j-1]\n  dp[i+1,w-1]=sen[w-1][2]*dp[i,w-1]+sen[w-1][0]*dp[i,w-2]\n  dp[i+1]%=mod\nprint((dp[h,k_-1]))\n#print(dp)\n", "import sys\ninput = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    H, W, K = map(int, input().split())\n    dp = [[0] * W for _ in range(H + 1)]  # \u6570\u3048\u4e0a\u3052\u554f\u984c\u306a\u306e\u30670\u3067\u521d\u671f\u5316\u3059\u308b\n    dp[0][0] = 1  # \u521d\u671f\u6761\u4ef6\n    for h in range(H):\n        for bit in range(1 << (W - 1)):  # \u5de6\u30d3\u30c3\u30c8\u30b7\u30d5\u30c8\u30672 ** (W-1)\u3068\u540c\u3058\n            if '11' in bin(bit): continue  # \u3042\u308b\u9802\u70b9\u304b\u3089\u5de6\u53f3\u65b9\u5411\u306b\u68d2\u304c\u4f38\u3073\u3066\u3044\u308b\u30b1\u30fc\u30b9\u306f\u30b9\u30eb\u30fc\n            for w in range(W):\n                # w\u756a\u76ee\u306e\u68d2\u3092\u8003\u3048\u308b\n                if w and bit & (1 << (w - 1)):  # left\u3092\u898b\u308b\u306e\u30671<<w-1\u3068\u78ba\u8a8d, w=0\u306e\u6642\u306fleft\u306b\u3044\u3051\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f\u3059\u308b\n                    dp[h + 1][w - 1] += dp[h][w] % MOD\n                elif bit & (1 << w):  # right\u3092\u898b\u308b\u306e\u30671<<w\u78ba\u8a8d\n                    dp[h + 1][w + 1] += dp[h][w] % MOD\n                else:  # down, \u5de6\u53f3\u3069\u3061\u3089\u306b\u3082\u3044\u304b\u306a\u3044\u6642\n                    dp[h + 1][w] += dp[h][w] % MOD\n    # for i in dp:\n    #     print(*i)\n    print(dp[H][K - 1] % MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u89e3\u8aac\u3068\u4e0b\u8a18\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# https://atcoder.jp/contests/abc113/submissions/15821617\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(H, W, K):\n    mod = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(H):\n        for w in range(W):\n            if dp[h][w] == 0:\n                continue\n            for i in range(3):\n                new_w = w - 1 + i\n                if not 0 <= new_w < W:\n                    continue\n\n                def cnt_tmp(n, r, l, flg):\n                    re = 0\n                    if n >= W - 2:\n                        if r <= n <= l:\n                            return 1\n                        if flg:\n                            return 1\n                        else:\n                            return 2\n                    if r <= n <= l:\n                        return cnt_tmp(n + 1, r, l, False)\n                    re += cnt_tmp(n + 1, r, l, False)\n                    re += cnt_tmp(n + 1, r, l, True) if not flg else 0\n                    return re\n\n                tmp = cnt_tmp(0, min(w, new_w) - 1, max(w, new_w), False)\n                dp[h + 1][new_w] += dp[h][w] * tmp\n                dp[h + 1][new_w] %= mod\n    # for dpi in dp:\n    #     print(dpi)\n    print((dp[-1][K - 1]))\n\n\ndef __starting_point():\n    H, W, K = list(map(int, input().split()))\n    solve(H, W, K)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "import sys\nmod = 7 + 10 ** 9\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    DP = [[0] * W for _ in range(H + 1)]\n    pattern = [1, 2, 3, 5, 8, 13, 21]\n    DP[0][0] = 1\n    for h in range(H):\n        for w in range(W):\n            if w == 0:\n                DP[h+1][w] += (DP[h][w] * pattern[max(0, W - 2)]) % mod\n                if W > 1: DP[h+1][w] += (DP[h][w+1] * pattern[max(0, W - 3)]) % mod\n            elif w == W - 1:\n                DP[h+1][w] += (DP[h][w] * pattern[max(0, W - 2)]) % mod\n                if W > 1: DP[h+1][w] += (DP[h][w-1] * pattern[max(0, W - 3)]) % mod\n            else:\n                DP[h+1][w] += (DP[h][w]  * pattern[max(0, w - 1)] * pattern[max(0, W - w - 2)]) % mod\n                DP[h+1][w] += (DP[h][w+1] * pattern[max(0, w - 1)] * pattern[max(0, W - w - 3)]) % mod\n                DP[h+1][w] += (DP[h][w-1] * pattern[max(0, w - 2)] * pattern[max(0, W - w - 2)]) % mod\n            DP[h+1][w] %= mod\n    print(DP[H][K - 1])\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "# coding: utf-8\n\n# https://atcoder.jp/contests/abc113\n# 12:01-12:49 give up -> kaisetsu\n# 11:57-12:25 try again\n\n# from pprint import pprint as ppr\n\n\n# def main():\n#     H, W, K = map(int, input().split())\n\n#     v = \"v\"\n#     h = \"h\"\n#     dp = [[{\"v\": 0, \"h\": 0} for _ in range(W)] for _ in range(H)]\n#     dp[0][0][v] = 1\n\n#     for i in range(H):\n\n#         for j in range(W):\n#             # horizontal computation\n#             if j == 0:\n#                 dp[i][j+1][h] += dp[i][j][v]\n#             elif j == W-1:\n#                 dp[i][j-1][h] += dp[i][j][v]\n#             else:\n#                 dp[i][j+1][h] += dp[i][j][v]\n#                 dp[i][j-1][h] += dp[i][j][v]\n\n#         if i < H-1:\n#             for j in range(W):\n#                 # vertical computation\n#                 dp[i+1][j][v] += dp[i][j][v] + dp[i][j][h]\n    \n#     ppr(dp)\n\n#     return dp[H-1][K-1][v] + dp[H-1][K-1][h]\n\n\ndef main():\n    H, W, K = list(map(int, input().split()))\n\n    if W == 1:\n        return 1\n\n    dp = [[0]*W for _ in range(H)]\n    dp[0][0] = 1\n\n    bridges_list = []\n\n    def preset(i, bridges, n_cand):\n        if i == n_cand:\n            bridges_list.append(bridges)\n            return None\n\n        if i-1 in bridges:\n            preset(i+1, bridges, n_cand)\n        else:\n            bridges_1 = bridges[:]\n            bridges_2 = bridges[:]\n            bridges_1.append(i)\n\n            preset(i+1, bridges_1, n_cand)\n            preset(i+1, bridges_2, n_cand)\n\n    preset(0, [], W-1)\n\n    n_bridges = [0] * (W-1)\n    for bridges in bridges_list:\n        for x in bridges:\n            n_bridges[x] += 1\n\n    n_all_cands = len(bridges_list)\n\n    # ppr(bridges_list)\n    # ppr(n_bridges)\n\n    dp[0][0] = (n_all_cands-n_bridges[0])\n    dp[0][1] = n_bridges[0]\n\n    for i in range(H-1):\n        for j in range(W):\n            if j == 0:\n                dp[i+1][j] += dp[i][j] * (n_all_cands-n_bridges[j])\n                dp[i+1][j+1] += dp[i][j] * n_bridges[j]\n            elif j == W-1:\n                dp[i+1][j] += dp[i][j] * (n_all_cands-n_bridges[j-1])\n                dp[i+1][j-1] += dp[i][j] * n_bridges[j-1]\n            else:\n                dp[i+1][j] += dp[i][j] * (n_all_cands-n_bridges[j-1]-n_bridges[j])\n                dp[i+1][j-1] += dp[i][j] * n_bridges[j-1]\n                dp[i+1][j+1] += dp[i][j] * n_bridges[j]\n    # ppr(dp)\n\n    return dp[-1][K-1] % (10**9 + 7)\n\n\nprint((main()))\n", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    H, W, K = NMI()\n    dp = make_grid(H+1, W, 0)\n    move = make_grid(W, W, 0)\n\n    dp[0][0] = 1\n\n    for case in range(2**(W-1)):\n        bad_case = False\n        prev_bit = -1\n        for i in range(W-1):\n            now_bit = (case >> i) & 1\n            if now_bit == prev_bit == 1:\n                bad_case = True\n            prev_bit = now_bit\n        if bad_case:\n            continue\n\n        for b in range(W):\n\n            if b == 0:\n                if (case >> 0) & 1:\n                    move[0][1] += 1\n                else:\n                    move[0][0] += 1\n\n            elif b == W - 1:\n                if (case >> b - 1) & 1:\n                    move[b][b - 1] += 1\n                else:\n                    move[b][b] += 1\n\n            else:\n                if (case >> b - 1) & 1:\n                    move[b][b - 1] += 1\n                elif (case >> b) & 1:\n                    move[b][b + 1] += 1\n                else:\n                    move[b][b] += 1\n\n    for h in range(1, H+1):\n        for w in range(W):\n            for i in range(W):\n                dp[h][w] += dp[h-1][i] * move[i][w]\n\n    print(dp[H][K-1]%MOD)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "H,W,K = list(map(int,input().split()))\nmod = 1000000007\n\nf = [0]*(W+1)\nf[0] = 1\nf[1] = 2\nfor i in range(2,W+1):\n    f[i] = f[i-1] + f[i-2]\n\ndp = [[0]*(W+2) for _ in range(H+1)]\ndp[0][K] = 1\nfor i in range(1,H+1):\n    for j in range(1,W+1):\n        dp[i][j] += (dp[i-1][j] * f[max(0,j-2)] * f[max(0,W-j-1)]\n                     + dp[i-1][j-1] * f[max(0,j-3)] * f[max(0,W-j-1)]\n                     + dp[i-1][j+1] * f[max(0,j-2)] * f[max(0,W-j-2)] )\n        dp[i][j] %= mod\nprint(dp[-1][1])", "from itertools import product\n\nh, w, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndp = [[0] * (w + 1) for _ in range(h + 1)]\nfor i in range(w + 1):\n    dp[0][i] = 1 if i == 1 else 0\n\n\ndef check_valid_bridge(bridge):\n    for i in range(1, w-1):\n        if bridge[i-1] and bridge[i]:\n            return False\n    return True\n\nfor t in range(1, h + 1):\n    for i in range(1, w + 1):\n        X, Y, Z = 0, 0, 0\n        if w != 1:\n            p = product([True, False], repeat=w-1)            \n            for bridge in p:\n                if check_valid_bridge(bridge):\n                    if i > 1 and bridge[i-2]:\n                        X += 1\n                    elif i < w and bridge[i-1]:\n                        Y += 1\n                    elif (i == 1 and not bridge[i-1]) or (i == w and not bridge[i-2]) or (1 < i < w and not bridge[i-2] and not bridge[i-1]):\n                        Z += 1\n        else:\n            Z = 1\n        # print(f\"{X} {Y} {Z}\")\n        pattern_1 = dp[t-1][i-1] * X if i > 1 else 0\n        pattern_2 = dp[t-1][i+1] * Y if i < w else 0\n        pattern_3 = dp[t-1][i] * Z\n        dp[t][i] = (pattern_1 + pattern_2 + pattern_3) % mod\n\n# for line in dp:\n#     print(*line)\nprint((dp[h][k]))\n", "# D - Number of Amidakuji\n\nH, W, K = list(map(int, input().split()))\nMOD = 10**9 + 7\n\ncomb = []\ndef dfs(n, p):\n    if len(n) == (W-1):\n        if len(n) == 0:\n            n = [0]\n        comb.append(tuple(n))\n        return\n    for i in (0, 1):\n        if p == 1 and i == 1:\n            continue\n        n.append(i)\n        dfs(n, i)\n        n.pop()  \n\ndfs([], 0)\n\ndp = [[0] * W for _ in range(H+1)]\ndp[0][0] = 1\nfor h in range(H):\n    for w in range(W):\n        # \u307e\u3063\u3059\u3050\u964d\u308a\u3066\u304f\u308b\u30b1\u30fc\u30b9\n        tmp = 0\n        for i in comb:\n            if w == 0 and i[w] == 0:\n                tmp += 1\n            elif w == (W-1) and i[w-1] == 0:\n                tmp += 1\n            elif i[w-1] == 0 and i[w] == 0:\n                tmp += 1\n        dp[h+1][w] += dp[h][w] * tmp\n\n        # \u5de6\u304b\u3089\u304f\u308b\u30b1\u30fc\u30b9\n        if w != 0:\n            tmp = 0\n            for i in comb:\n                if i[w-1] == 1:\n                    tmp += 1\n            dp[h+1][w] += dp[h][w-1] * tmp        \n\n        # \u53f3\u304b\u3089\u304f\u308b\u30b1\u30fc\u30b9\n        if w != (W-1):\n            tmp = 0\n            for i in comb:\n                if i[w] == 1:\n                    tmp += 1\n            dp[h+1][w] += dp[h][w+1] * tmp  \n\nprint((dp[H][K-1]%MOD))\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    H, W, K = list(map(int, readline().split()))\n\n    dp = [0] * W\n    dp[0] = 1\n\n    for _ in range(H):\n        dp, dp_prev = [0] * W, dp\n        for mask in range(1 << (W - 1)):\n            ok = True\n            for i in range(W - 2):\n                if mask & (1 << i) and mask & (1 << (i + 1)):\n                    ok = False\n            if not ok:\n                continue\n            for i in range(W):\n                if i > 0 and mask & (1 << (i - 1)):\n                    dp[i - 1] = (dp[i - 1] + dp_prev[i]) % MOD\n                elif i < W - 1 and mask & (1 << i):\n                    dp[i + 1] = (dp[i + 1] + dp_prev[i]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp_prev[i]) % MOD\n\n    print((dp[K - 1]))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\ndef main():\n    H, W, K = map(int, readline().rstrip().split())\n    K -= 1\n    dp = [[0] * W for _ in range(H+1)]\n    dp[0][0] = 1\n    for i in range(H):\n        for j in range(W):\n            for k in range(2**(W-1)):\n                b = bin(k)[2:].zfill(W-1)\n                # \u8fd1\u63a5\u3059\u308b2\u3064\u306e\u6a2a\u7dda\u304c\u3064\u306a\u304c\u3063\u3066\u308b\u304b\u5224\u5b9a\n                flg = True\n                for l in range(W-2):\n                    if b[l] == b[l+1] == '1':\n                        flg = False\n                        break\n                if not flg:\n                    continue\n                if j >= 1 and b[j-1] == '1':\n                    # \u5de6\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u8fbf\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j-1] += dp[i][j]\n                    dp[i+1][j-1] %= MOD\n                elif j <= W-2 and b[j] == '1':\n                    # \u53f3\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u8fbf\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j+1] += dp[i][j]\n                    dp[i+1][j+1] %= MOD\n                else:\n                    # \u6a2a\u7dda\u3092\u8fbf\u3089\u306a\u3044\u30b1\u30fc\u30b9\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\n\n    print(dp[H][K])\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    H, W, K = list(map(int, input().split()))\n    K -= 1\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    for i in range(H):\n        for j in range(W):\n            for bit in range(1 << (W - 1)):\n                flg = True\n                for mask in range(W - 2):\n                    if (bit & (1 << mask)) and (bit & (1 << (mask + 1))):\n                        flg = False\n                if flg:\n                    next_j = j\n                    if bit & (1 << j):\n                        next_j = j + 1\n                    elif j > 0 and (bit & (1 << (j - 1))):\n                        next_j = j - 1\n                    dp[i + 1][next_j] = (dp[i + 1][next_j] + dp[i][j]) % mod\n    print((dp[H][K]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "h, w, k = list(map(int, input().split()))\n# h, w, k = 15, 8, 5\n# h, w, k = 2, 3, 1\n# h, w, k = 2, 3, 3\n# h, w, k = 1, 3, 2\np = 10**9+7\n# DP[i][j]=i\u6bb5\u76ee\u307e\u3067\u898b\u30660\u304b\u3089j\u306b\u7740\u304f\u30d1\u30bf\u30fc\u30f3\u6570\n# \u6700\u7d42\u7684\u306bDP[h][k-1]\u3092\u6c42\u3081\u308b\nDP = [[0 for j in range(w+1)] for i in range(h+1)]\nDP[0][0] = 1\nF = [1, 1, 2, 3, 5, 8, 13, 21]\nfor i in range(h):\n    for j in range(w):\n        a = DP[i][j-1]*F[j-1]*F[w-1-j]\n        b = DP[i][j+1]*F[j]*F[w-2-j]\n        c = DP[i][j]*F[j]*F[w-1-j]\n        DP[i+1][j] = (a+b+c) % p\nprint((DP[h][k-1]))\n", "h,w,k = list(map(int,input().split()))\nk -= 1\ndp = [[0]*w for _ in range(h+1)]\ndp[0][0] = 1\nmod = 10**9 + 7\ndef cnt(n):\n    if n < 0:\n        return 1\n    if 0 <= n < 3:\n        return n + 1\n    return n + (n-1)*(n-2)//2 + (n-2)*(n-3)*(n-4)//6 + 1\n\nfor i in range(h):\n    for j in range(w):\n        if j > 0:\n            dp[i+1][j-1] += dp[i][j] * cnt(j-2) * cnt(w-2-j)\n            dp[i+1][j-1] %= mod\n        if j < w-1:\n            dp[i+1][j+1] += dp[i][j] * cnt(j-1) * cnt(w-3-j)\n            dp[i+1][j+1] %= mod\n        dp[i+1][j] += dp[i][j] * cnt(j-1) * cnt(w-2-j)\n        dp[i+1][j] %= mod\nprint((dp[h][k]))\n", "def main():\n    MOD = 10 ** 9 + 7\n\n    H, W, K = list(map(int, input().split()))\n\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    # \u6a2a\u7dda[0,H)\n    # H->\u7d42\u7740\u70b9\n\n    for h in range(H):\n        for bit in range(1 << (W - 1)):\n            if '11' in bin(bit): continue\n            toes = list(range(W))\n            for j in range(W - 1):\n                if (bit >> j) & 1:\n                    toes[j], toes[j + 1] = toes[j + 1], toes[j]\n            for frm, to in enumerate(toes):\n                dp[h + 1][to] = (dp[h + 1][to] + dp[h][frm]) % MOD\n    ans = dp[H][K - 1]\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n# import sys\n# input = sys.stdin.readline\n# \n# sys.setrecursionlimit(10 ** 7)\n# \n# (int(x)-1 for x in input().split())\n# rstrip()\n\n__starting_point()", "h, w, k = list(map(int, input().split()))\ndp = [0] * w\nmod = 10 ** 9 + 7\n\ndp[0] = 1\nfor i in range(h):\n    next = [0] * w\n    for bit in range(1 << w - 1):\n        ok = True\n        for j in range(w - 2):\n            if bit >> j & 1 and bit >> j + 1 & 1:\n                ok = False\n        if ok:\n            moved = [False] * w\n            for j in range(w):\n                if bit >> j & 1:\n                    next[j + 1] += dp[j]\n                    next[j] += dp[j + 1]\n                    moved[j] = moved[j + 1] = True\n                elif not moved[j]:\n                    next[j] += dp[j]\n    dp = next\nprint((dp[k - 1] % mod))\n", "h,w,K = map(int,input().split())\nif w == 1:\n    print(1)\n    return\nK -= 1\nmod = 1000000007\ndp = [[0]*(w) for _ in range(h+1)]\nfor i in range(w): dp[0][0] = 1\n\nfor i in range(h):\n    for j in range(1<<(w-1)):\n        invalid = False\n        for k in range(w-1):\n            if j>>k & 1 and j>>(k+1) & 1:\n                invalid = True\n                break\n        if invalid: continue\n        used = [False]*w\n        for k in range(w):\n            if used[k]: continue\n            if j>>k & 1:\n                dp[i+1][k] = (dp[i+1][k]+dp[i][k+1])%mod\n                dp[i+1][k+1] = (dp[i+1][k+1]+dp[i][k])%mod\n                used[k] = True\n                used[k+1] = True\n            else:\n                dp[i+1][k] = (dp[i+1][k]+dp[i][k])%mod\n                used[k] = True\n# for i in range(h+1): print(dp[i])\nprint(dp[h][K])", "H,W,K=map(int,input().split())\ndp=[[0]*W for i in range(H+1)]\ndp[0][0]=1\nif W==1:\n  print(1)\n  return\n  \nimport itertools\nA=list(itertools.product([0,1], repeat=W-1))\n\nB=[]\nfor i in A:\n  x=0\n  for j in range(W-2):\n    if i[j]==1 and i[j+1]==1:\n      x=1\n  if x==0:\n    B.append(i)\n\nD=[[0,0,0] for i in range(W)]\nfor i in B:\n  for j in range(W-1):\n    if i[j]==1:\n      D[j+1][0]+=1\n      D[j][2]+=1\n    if j==0 and i[j]==0:\n      D[j][1]+=1\n    if j==W-2 and i[j]==0:\n      D[j+1][1]+=1\n    if j<W-2:\n      if i[j]==0 and i[j+1]==0:      \n        D[j+1][1]+=1\ndp=[[0]*W for i in range(H+1)]\nmod=10**9+7\ndp[0][0]=1\nfor i in range(H):\n  for j in range(W):\n    if j==0:\n      dp[i+1][j]=dp[i][j]*D[j][1]+dp[i][j+1]*D[j][2]\n    elif j==W-1:\n      dp[i+1][j]=dp[i][j]*D[j][1]+dp[i][j-1]*D[j][0]\n    else:\n      dp[i+1][j]=dp[i][j]*D[j][1]+dp[i][j-1]*D[j][0]+dp[i][j+1]*D[j][2]\n    dp[i+1][j]%=mod\nprint(dp[-1][K-1])", "import sys\nimport math\nimport collections\nimport bisect\nimport copy\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().split()])\n\n\n# ===CODE===\n\n\ndef main():\n    h, w, k = ns()\n    dp = [[0 for _ in range(w)] for __ in range(h + 1)]\n    dp[0][0] = 1\n    fibo = [1, 2]\n    for i in range(10):\n        fibo.append(fibo[-1] + fibo[-2])\n\n    for y in range(1, h + 1):\n        for x in range(w):\n            if x == 0:\n                # from U\n                dp[y][x] += dp[y - 1][x] * fibo[max(0, w - 1 - 1)]\n                if w > 1:\n                    # from R\n                    dp[y][x] += dp[y - 1][x + 1] * fibo[max(0, w - 1 - 2)]\n            elif x == w - 1:\n                # from U\n                dp[y][x] += dp[y - 1][x] * fibo[max(0, w - 1 - 1)]\n                if w > 1:\n                    # from L\n                    dp[y][x] += dp[y - 1][x - 1] * fibo[max(0, w - 1 - 2)]\n            else:\n                # from U\n                dp[y][x] += dp[y - 1][x] * fibo[x - 1] * fibo[max(0, w - 1 - x - 1)]\n                # from L\n                dp[y][x] += dp[y - 1][x - 1] * fibo[max(0, x - 1 - 1)] * fibo[max(0, w - 1 - x - 1)]\n                # from R\n                dp[y][x] += dp[y - 1][x + 1] * fibo[x - 1] * fibo[max(0, w - 1 - x - 2)]\n            dp[y][x] %= MOD\n\n    print((dp[h][k - 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#import sys\n#import numpy as np\nimport math\n#from fractions import Fraction\nimport itertools\nfrom collections import deque\nfrom collections import Counter\n#import heapq\n#from fractions  import gcd\n#input=sys.stdin.readline\n#import bisect\nMod=10**9+7\nh,w,K=list(map(int,input().split()))\ndp=[[0]*w for _ in range(h+1)]\ndp[0][0]=1\nn=2**(w-1)\nfor i in range(h):\n    for j in range(w):\n        for m in range(n):\n            ok=True\n            for k in range(w-2):\n                if (m&(1<<k)) and (m&(1<<(k+1))):\n                    ok=False\n            if not ok:\n                continue\n            nj=j\n            if (m & (1<<j)):\n                nj=j+1\n            elif j>0 and (m&(1<<(j-1))):\n                nj=j-1\n            dp[i+1][nj]+=dp[i][j]\n            dp[i+1][nj]%=Mod\nprint((dp[h][K-1]))\n", "\"\"\"\n    dp[h][w]: h\u756a\u76ee\u306erow(h: 0~H(\u7d42\u7740))\u3067\u68d2w(w: 0~W-1)\u306b\u3044\u308b\u72b6\u614b\u306b\u306a\u308b\u305f\u3081\u306e\u6a2a\u7dda(0~h)\u306e\u7d44\u5408\u305b\u6570\n    dp[h][w] = A*dp[h-1][w-1] + B*dp[h-1][w] + C*dp[h-1][w+1] O(100*8)\n    A, B, C\u306f\u306a\u3093\u304b\u3046\u307e\u3044\u3053\u3068\u6c7a\u3081\u308c\u305d\u3046\u3002(\u5168\u63a2\u7d22\u3067\u3082O(7*7*3))\n    o(10**6)\u306b\u306f\u5165\u308a\u305d\u3046\n    \"\"\"\ndef main():\n    import sys\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    dp = [[0]*W for _ in range(H+1)]\n    dp[0][0] = 1\n    for h in range(1, H+1):\n        for w in range(W):\n            A, B, C = 0, 0, 0\n            for i in range(2 ** (W-1)):\n                lines = []\n                for j in range(W-1):\n                    if ((i >> j) & 1):\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w-1 >= 0 and lines[w-1]:\n                        A += 1\n                    elif w <= W-2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w-1 >= 0:\n                dp[h][w] += dp[h-1][w-1] * A\n            dp[h][w] += dp[h-1][w] * B\n            if w+1 <= W-1:\n                dp[h][w] += dp[h-1][w+1] * C\n    print(dp[H][K-1] % (10**9+7))\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "H,W,K = list(map(int,input().split()))\n\ngoal = [0 for i in range(W)]\ngoal[0] = 1\noldGoal = [0 for i in range(W)]\noldGoal[0] = 1\nfib = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nif W == 1:\n    print(1)\n    return\n\nfor i in range(H):\n    for j in range(W):\n        if j == 0:\n            a1 = oldGoal[j] * fib[W-1]\n            a2 = oldGoal[j+1] * fib[W-2]\n            a1 = a1 % 1000000007\n            a2 = a2 % 1000000007\n            goal[j] = a1 + a2\n        elif j == W - 1:\n            a1 = oldGoal[j-1] * fib[W-2]\n            a2 = oldGoal[j] * fib[W-1]\n            a1 = a1 % 1000000007\n            a2 = a2 % 1000000007\n            goal[j] = a1 + a2\n        else:\n            a1 = oldGoal[j-1] * fib[j-1] * fib[W-j-1]\n            a2 = oldGoal[j] * fib[j] * fib[W-j-1]\n            a3 = oldGoal[j+1] * fib[j] * fib[W-j-2]\n            a1 = a1 % 1000000007\n            a2 = a2 % 1000000007\n            a3 = a3 % 1000000007\n            goal[j] = a1 + a2 + a3\n    for k in range(W):\n        oldGoal[k] = goal[k]\nprint(goal[K-1] % 1000000007)", "def main():\n    h, w, k = list(map(int, input().split()))\n\n    bf = [0] * (w + 2)\n    nx = [0] * (w + 2)\n    bf[1] = 1\n\n    c = [1, 1, 2, 3, 5, 8, 13, 21]\n\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            nx[j] = c[j - 1] * c[w - j] * bf[j] + c[j - 1] * c[w - j - 1] * bf[j + 1] + c[j - 2] * c[w - j] * bf[j - 1]\n\n        bf = nx\n        nx = [0] * (w + 2)\n\n    print((bf[k] % (10 ** 9 + 7)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    H, W, K = list(map(int, readline().split()))\n\n    dp = [0] * W\n    dp[0] = 1\n\n    for _ in range(H):\n        dp, dp_prev = [0] * W, dp\n        for mask in range(1 << (W - 1)):\n            ok = True\n            for i in range(W - 2):\n                if mask & (1 << i) and mask & (1 << (i + 1)):\n                    ok = False\n                    break\n            if not ok:\n                continue\n            for i in range(W):\n                if i > 0 and mask & (1 << (i - 1)):\n                    dp[i - 1] = (dp[i - 1] + dp_prev[i]) % MOD\n                elif i < W - 1 and mask & (1 << i):\n                    dp[i + 1] = (dp[i + 1] + dp_prev[i]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp_prev[i]) % MOD\n\n    print((dp[K - 1]))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,w,k = map(int,input().split())\nmod = 10**9+7\n\nif w == 1:\n    print(1)\n    return\n\ndp = [[0]*w for i in range(h+1)]\ndp[0][0] = 1\n\nl = [[0]*3 for i in range(w)]\n\nfor i in range(2**(w-1)):\n    if \"11\" in bin(i):\n        continue\n\n    for j in range(w-1):\n        if (i >> j) & 1:        \n            l[j][2] += 1\n            l[j+1][0] += 1\n\nfib = [1,1]\nfor i in range(10):\n    fib.append(fib[-1]+fib[-2])\nfor i in l:\n    i[1] = fib[w] - sum(i)\n\nfor i in range(h):\n    for j in range(w):\n        dp[i+1][j] += dp[i][j]*l[j][1]%mod\n        if j != 0:\n            dp[i+1][j] += dp[i][j-1]*l[j][0]%mod\n        if j != w-1:\n            dp[i+1][j] += dp[i][j+1]*l[j][2]%mod\n        dp[i+1][j] %= mod\n\nprint(dp[-1][k-1]%mod)", "import sys\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\ndef main():\n    H, W, K = map(int, readline().rstrip().split())\n    # K -= 1\n    dp = [[0] * W for _ in range(H+1)]\n    dp[0][0] = 1\n    for i in range(H):\n        for j in range(W):\n            for k in range(2**(W-1)):\n                b = bin(k)[2:].zfill(W-1)\n                # 2\u3064\u306e\u6a2a\u7dda\u304c\u3064\u306a\u304c\u3063\u3066\u306a\u3044\u304b\u8abf\u3079\u308b\n                flg = True\n                for l in range(W-2):\n                    if b[l] == b[l+1] == '1':\n                        flg = False\n                        break\n                if not flg:\n                    continue\n                if j >= 1 and b[j-1] == '1':\n                    # \u5de6\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u8fbf\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j-1] += dp[i][j]\n                    dp[i+1][j-1] %= MOD\n                elif j <= W-2 and b[j] == '1':\n                    # \u53f3\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u8fbf\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j+1] += dp[i][j]\n                    dp[i+1][j+1] %= MOD\n                else:\n                    # \u6a2a\u7dda\u3092\u8fbf\u3089\u306a\u3044\u30b1\u30fc\u30b9\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\n\n    print(dp[H][K-1])\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    H, W, K = [int(x) for x in input().split()]\n    MOD = 10 ** 9 + 7\n\n    if W == 1:\n        print((1))\n        return\n\n    cnt = [0] * (W - 1)\n    cntz = [0] * W\n    for i in range(2 ** (W - 1)):\n        tmp = [0] * (W - 1)\n        for j in range(W - 1):\n            if i >> j & 1:\n                tmp[j] += 1\n        # 2\u8fba\u9023\u7d9a\u3067\u5f15\u304b\u308c\u3066\u3044\u306a\u3044\u304b\u3092\u30c1\u30a7\u30c3\u30af\n        for j, k in zip(tmp, tmp[1:]):\n            if j == k == 1:\n                break\n        else:\n            # \u30c1\u30a7\u30c3\u30af\u3092\u30d1\u30b9\u3057\u305f\u72b6\u614b\u3092\u30ab\u30a6\u30f3\u30c8\n            for j in range(W - 1):\n                cnt[j] += tmp[j]\n            for j in range(W):\n                if j == 0:\n                    if tmp[j] == 0:\n                        cntz[j] += 1\n                elif j == W - 1:\n                    if tmp[j - 1] == 0:\n                        cntz[j] += 1\n                else:\n                    if tmp[j] == tmp[j - 1] == 0:\n                        cntz[j] += 1\n\n    dp = [[0] * W for j in range(H + 1)]\n    dp[0][0] = 1\n\n    for j in range(H):\n        for i in range(W):\n            if i == 0:\n                dp[j + 1][i] += dp[j][i] * cntz[i]\n                dp[j + 1][i + 1] += dp[j][i] * cnt[i]\n                dp[j + 1][i] %= MOD\n                dp[j + 1][i + 1] %= MOD\n            elif i == W - 1:\n                dp[j + 1][i] += dp[j][i] * cntz[i]\n                dp[j + 1][i - 1] += dp[j][i] * cnt[i - 1]\n                dp[j + 1][i] %= MOD\n                dp[j + 1][i - 1] %= MOD\n            else:\n                dp[j + 1][i] += dp[j][i] * cntz[i]\n                dp[j + 1][i + 1] += dp[j][i] * cnt[i]\n                dp[j + 1][i - 1] += dp[j][i] * cnt[i - 1]\n                dp[j + 1][i] %= MOD\n                dp[j + 1][i + 1] %= MOD\n                dp[j + 1][i - 1] %= MOD\n\n    print((dp[-1][K - 1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def fib(n):\n    a = 1\n    b = 0\n    i = 0\n    while i < n:\n        i += 1\n        c = a + b\n        yield c\n        a = b\n        b = c\n\n\ndef main():\n    h, w, k = list(map(int, input().split()))\n    mod = 10 ** 9 + 7\n    \n    dp = [[0] * (w + 2) for _ in range(h + 1)]\n    dp[0][1] = 1\n    c = [i for i in fib(w + 1)]\n\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            x = c[j - 1] * c[w - j]\n            y = c[j - 1] * c[w - j - 1]\n            z = c[j - 2] * c[w - j]\n\n            dp[i][j] = (x * dp[i - 1][j] + y * dp[i - 1][j + 1] + z * dp[i - 1][j - 1]) % mod\n\n    print((dp[h][k]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import product\n\nh, w, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndp = [[0] * w for _ in range(h + 1)]\ndp[0][0] = 1\n\npats = [pat for pat in product([1, 0], repeat=w-1)]\n\nfor i in range(1, h + 1):\n\tfor j in range(w):\n\t\tfor pat in pats:\n\t\t\tvalid = True\n\t\t\tfor e1, e2 in zip(pat, pat[1:]):\n\t\t\t\tif e1 and e2:\n\t\t\t\t\tvalid = False\n\n\t\t\tif not valid:\n\t\t\t\tcontinue\n\n\t\t\tif j - 1 >= 0 and pat[j-1]:\n\t\t\t\tdp[i][j] += dp[i-1][j-1]\n\n\t\t\telif j <= w - 2 and pat[j]:\n\t\t\t\tdp[i][j] += dp[i-1][j+1]\n\n\t\t\telse:\n\t\t\t\tdp[i][j] += dp[i-1][j]\n\n\t\t\tdp[i][j] %= mod\n\nans = dp[h][k-1]\nprint(ans)\n#print(*dp, sep=\"\\n\")\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    mod = 10**9 + 7\n\n    h,w,k = map(int, input().split())\n    dp = [[0]*w for _ in range(h+1)]\n    dp[0][0] = 1\n\n    pattern = []\n    if w > 2:\n        for i in range(1<<(w-1)):\n            for j in range(w-2):\n                if ((i>>j) & 1) and ((i>>(j+1)) & 1):\n                    break\n            else:\n                pattern.append(i)\n    else:\n        print(1)\n        return\n    \n    for i in range(h):\n        for j in range(w):\n            for p in pattern:\n                if j == 0:\n                    if p & 1:\n                        dp[i+1][j+1] += dp[i][j] % mod\n                    else:\n                        dp[i+1][j] += dp[i][j] % mod\n                elif j == w-1:\n                    if (p>>(w-2)) & 1:\n                        dp[i+1][j-1] += dp[i][j] % mod\n                    else:\n                        dp[i+1][j] += dp[i][j] % mod\n                else:\n                    if (p>>(j-1)) & 1:\n                        dp[i+1][j-1] += dp[i][j] % mod\n                    elif (p>>j) & 1:\n                        dp[i+1][j+1] += dp[i][j] % mod\n                    else:\n                        dp[i+1][j] += dp[i][j] % mod\n    print(dp[-1][k-1] % mod)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10 ** 9 + 7\nh, w, k = list(map(int, input().split()))\ndp = [0] * w\ndp[0] = 1\n\nfdp = [[0, 0] for _ in range(w)]\nfdp[0][0] = 1\nfor i in range(w - 1):\n    fdp[i+1][0] += fdp[i][0]\n    fdp[i+1][1] += fdp[i][0]\n    fdp[i+1][0] += fdp[i][1]\n\ndef f(i):\n    if i < 0:\n        return 1\n    return fdp[i][0] + fdp[i][1]\n\nfor _ in range(h):\n    ndp = [0] * w\n    for i in range(w):\n        ndp[i] = (ndp[i] + dp[i] * f(i - 1) * f(w - i - 2))  % MOD\n        if i + 1 < w:\n            ndp[i+1] = (ndp[i+1] + dp[i] * f(i - 1) * f(w - i - 3)) % MOD\n        if i - 1 >= 0:\n            ndp[i-1] = (ndp[i-1] + dp[i] * f(i - 2) * f(w - i - 2)) % MOD\n    dp = ndp\nprint((dp[k-1]))\n", "MOD=10**9+7\nH,W,K=map(int,input().split())\ndp=[[0]*W for i in range(H+1)]\ndp[0][0]=1\n\nfor i in range(1,H+1):\n    for k in range(W):\n        l,c,r=0,0,0\n        for bit in range(2**(W-1)):\n            ok=True\n            for t in range(W-2):\n                if (bit>>t&1) and (bit>>(t+1)&1):\n                    ok=False\n                    break\n            if not ok:\n                continue\n            if ((k>0 and not(bit>>(k-1)&1)) or k==0) and ((k<W-1 and not(bit>>k&1))or k==W-1):\n                c+=1\n            if (k>0):\n                if ((k>1 and not(bit>>(k-2)&1)) or k==1) and ((k<W-1 and not(bit>>k&1))or k==W-1) and (bit>>(k-1)&1):\n                    l+=1\n            if (k<W-1):\n                if ((k>0 and not(bit>>(k-1)&1)) or k==0) and ((k<W-2 and not (bit>>(k+1)&1))or k==W-2) and (bit>>k&1):\n                    r+=1\n        dp[i][k]=(dp[i][k]+dp[i-1][k]*c)%MOD\n        if k>0:\n            dp[i][k]=(dp[i][k]+dp[i-1][k-1]*l)%MOD\n        if k<W-1:\n            dp[i][k]=(dp[i][k]+dp[i-1][k+1]*r)%MOD\nprint(dp[H][K-1])", "MOD = 10 ** 9 + 7\nh, w, k = [int(x) for x in input().split()]\ndp = [[0] * w for _ in range(h+1)]\ndp[0][0] = 1\nfor i in range(h):\n    for b in range(1 << (w-1)):\n        ok = True\n        for s in range(w-2):\n            if b >> s & 1 and b >> (s+1) & 1:\n                ok = False\n        if ok:            \n            for j in range(w):\n                if j > 0 and b >> (j-1) & 1:\n                    dp[i+1][j-1] = (dp[i+1][j-1] + dp[i][j]) % MOD\n                elif j+1 < w and b >> j & 1:\n                    dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % MOD\n                else:\n                    dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n\nprint(dp[h][k-1])", "'''3/18 AtCoder\uff08\u6f38\u5316\u5f0fdp\uff09\n\u4e00\u756a\u5de6\u306e\u68d2\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3057\u3066\u3001K\u756a\u76ee\u306e\u68d2\u306b\u5230\u9054\u3059\u308b\u3088\u3046\u306a\u3042\u307f\u3060\u304f\u3058\u306f\n\u4f55\u901a\u308a\u4f5c\u308c\u307e\u3059\u304b\u3068\u3044\u3046\u8da3\u65e8\u306e\u554f\u984c\n\u307e\u305a\u3001\u3053\u306e\u554f\u984c\u3092\u89e3\u304f\u3046\u3048\u3067\u4e00\u756a\u91cd\u8981\u306a\u306e\u306f\u3001\n\u300c\u3042\u308b\u9ad8\u3055h\u3001\u68d2j\u306b\u81f3\u308b\u7d4c\u8def\u306e\u7dcf\u6570\u3092\u6c42\u3081\u308b\u6f38\u5316\u5f0f\u304c\u7acb\u3066\u3089\u308c\u308b\u300d\u3068\u3044\u3046\u3053\u3068\n\u9ad8\u3055h\u3001\u68d2j\u306b\u81f3\u308b\u7d4c\u8def\u306e\u7dcf\u6570\u3092dp[h][j]\u3068\u3059\u308c\u3070\u3001\n\u9ad8\u3055h-1\u304b\u3089\u3053\u306e\u4f4d\u7f6e\u306b\u81f3\u308b\u3053\u3068\u304c\u3067\u304d\u308b\u306e\u306f\u3001\n\u68d2j-1,j,j+1\u306e\u3044\u305a\u308c\u304b\u3057\u304b\u306a\u3044\n\u3055\u3089\u306b\u3001\u305d\u3053\u306b\u81f3\u308b\u7d4c\u8def\u6570\u3068\u3044\u3046\u306e\u306f\u7d50\u5c40\n\u300c\u307b\u304b\u306e\u68d2\u306b\u3069\u3093\u306a\u98a8\u306b\u67b6\u3051\u6a4b\uff08\u6a2a\u68d2\uff09\u304c\u304b\u304b\u3063\u3066\u3044\u308b\u304b\u300d\u306e\u5834\u5408\u306e\u6570\u306a\u306e\u3067\u3001\n\u305d\u308c\u3092dp[h-1][j-1],dp[h-1][j],dp[h-1][j+1]\u306b\u304b\u3051\u3066\u3044\u304f\u5fc5\u8981\u304c\u3042\u308b\n\u4f8b\u3048\u3070\u3001dp[h-1][j]\u3092\u898b\u3066\u307f\u308b\u3000\u3053\u308c\u306f\u3001\u540c\u3058\u68d2\u304b\u3089\u4e0b\u3063\u3066\u304f\u308b\u3053\u3068\u3092\n\u610f\u5473\u3057\u3066\u3044\u308b\u304c\u3001\u63db\u8a00\u3059\u308c\u3070\u300c\u9ad8\u3055i-1\u3068i\u306b\u306f\u3001\u68d2j\u304b\u3089\u4f38\u3073\u308b\u6a2a\u68d2\u306f\u306a\u3044\u300d\n\u3068\u3044\u3046\u3053\u3068\u3067\u3042\u308b\n\u3064\u307e\u308a\u3001\u3053\u306e\u9ad8\u3055\u306b\u304a\u3051\u308b\u6a2a\u68d2\u306e\u67b6\u304b\u308a\u65b9\u3068\u3044\u3046\u306e\u306f\n\u300c\u68d21~j-1\u307e\u3067\u306e\u67b6\u304b\u308a\u65b9\u300d\u3068\u300c\u68d2j+1~\u68d2W\u307e\u3067\u306e\u67b6\u304b\u308a\u65b9\u300d\u306e\n\u4e8c\u30d1\u30bf\u30fc\u30f3\u3057\u304b\u306a\u3044\u3068\u3044\u3046\u3053\u3068\u306b\u306a\u308b\n\u3042\u308b\u9ad8\u3055\u306b\u304a\u3051\u308b\u6a2a\u68d2\u306e\u304b\u304b\u308a\u65b9\u3082\u6f38\u5316\u5f0f\u3067\u6c42\u3081\u3089\u308c\u308b\u3000\n\u9ad8\u3055h\u306b\u304a\u3051\u308b(\u6a2a\u4e00\u5217\u306b\u304b\u3051\u6a4b\u304c\u4e26\u3093\u3067\u3044\u308b\u72b6\u6cc1\u3092\u8003\u3048\u308b\uff09\u3001\nn\u672c\u306e\u68d2\u306e\u9593\u306b\u304b\u304b\u308b\u6a4b\u306e\u5834\u5408\u306e\u6570\u306e\u7dcf\u6570\u3092f(n)\u3068\u7f6e\u304f\u3068\u3001\nf(n) = f(n-1)+f(n-2)\u3068\u66f8\u304f\u3053\u3068\u304c\u3067\u304d\u308b\n\u3053\u308c\u306f\u3001f(n)\u304c\n\u2460n\u672c\u76ee\u3068n-1\u672c\u76ee\u306e\u68d2\u306e\u9593\u306b\u6a4b\u304c\u67b6\u304b\u3063\u3066\u3044\u306a\u3044\u2192\u5834\u5408\u306e\u6570\u306ff(n-2)\u3068\u540c\u3058\n\u2461n\u672c\u76ee\u3068n-1\u672c\u76ee\u306e\u68d2\u306e\u9593\u306b\u6a4b\u304c\u67b6\u304b\u3063\u3066\u3044\u308b\u2192\u5834\u5408\u306e\u6570\u306ff(n-1)\u3068\u540c\u3058\n\u306e\u4e8c\u30d1\u30bf\u30fc\u30f3\u306e\u5408\u8a08\u3060\u304b\u3089\u3067\u3042\u308b\n\u3060\u304b\u3089\u3001dp[h-1][j]\u306b\u639b\u3051\u308b\u6570\u306f\u3044\u304f\u3064\u304b\u3068\u3044\u3046\u3053\u3068\u3092\u8003\u3048\u305f\u3089\u3001\nj-1\u672c\u306e\u68d2\u306e\u9593\u306b\u304b\u304b\u308b\u6a4b\u306e\u5834\u5408\u306e\u6570f(j-1)\u3068\u3001\nW-j\u672c\u306e\u68d2\u306e\u9593\u306b\u304b\u304b\u308b\u6a4b\u306e\u5834\u5408\u306e\u6570f(W-j)\u672c\u3068\u3044\u3046\u3053\u3068\u306b\u306a\u308b\u3000\n\u3053\u308c\u3068\u540c\u69d8\u306b\u3001\u6b8b\u308a\u4e8c\u672c\u306b\u5bfe\u3057\u3066\u3082\u3044\u304f\u3064\u304b\u3051\u308c\u3070\u3088\u3044\u304b\u3092\u8003\u3048\u3066\u3001\ndp[h][j]]\u306b\u5bfe\u3059\u308b\u6f38\u5316\u5f0f\u3092\u7acb\u3066\u308c\u3070\u3088\u3044\n'''\nH,W,K = map(int,input().split())\ndp = []\nfor i in range(H+1): #\u9ad8\u30550\u306e\u5206\u3092\u4f59\u5206\u306b\u6301\u3063\u3066\u304a\u304f\n  L = [0]*W\n  dp.append(L)\nfb = [1,1] #\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\uff08f(n)=f(n-1)+f(n-2)\uff09\nfor i in range(W-2):\n  fb.append(fb[i]+fb[i+1])\ndp[0][0] = 1 #\u5de6\u7aef\u306e\u68d2\u306e\u9ad8\u30550\u306f\u521d\u671f\u4f4d\u7f6e\u306a\u306e\u30671\u306b\nif W != 1: #\u68d2\u304c\u4e00\u672c\u4ee5\u4e0a\u3042\u308b\u3068\u304d\u306f\n  for i in range(1,H+1):\n    for j in range(W): #\u68d2\u304c\u5de6\u7aef\u3001\u53f3\u7aef\u3001\u305d\u308c\u4ee5\u5916\u3067\u5834\u5408\u5206\u3051\n      if 1 <= j <= W-2:\n        dp[i][j] = dp[i-1][j-1]*fb[j-1]*fb[W-j-1]+dp[i-1][j]*fb[j]*fb[W-j-1]+dp[i-1][j+1]*fb[j]*fb[W-j-2]\n      elif j == 0:\n        dp[i][j] = dp[i-1][j]*fb[W-1]+dp[i-1][j+1]*fb[W-2]\n      else:\n        dp[i][j] = dp[i-1][j]*fb[W-1]+dp[i-1][j-1]*fb[W-2]\nelse:\n  dp[H][0] = 1\nprint(dp[H][K-1]%(10**9+7)) #\u9ad8\u3055H\uff08\u4e00\u756a\u4e0b\uff09\u3001K-1\u756a\u76ee\u306e\u68d2\u3092\u8abf\u3079\u308b", "H, W, K = list(map(int, input().split()))\nh_lines = (1, 1, 2, 3, 5, 8, 13, 21, 34)\nMOD = 10 ** 9 + 7\n\ndp = [[0] * 8 for _ in range(H + 1)]\ndp[0][0] = 1\nfor h in range(H):\n    for w in range(W):\n        dp[h + 1][w] = dp[h][w] * h_lines[w] * h_lines[W - w - 1]\n        if w > 0:\n            dp[h + 1][w] += dp[h][w - 1] * h_lines[w - 1] * h_lines[W - w - 1]\n        if w < W - 1:\n            dp[h + 1][w] += dp[h][w + 1] * h_lines[w] * h_lines[W - w - 2]\n        dp[h + 1][w] %= MOD\nprint((dp[H][K - 1]))\n", "def is_valid(k):\n    n = k.bit_length()\n\n    for i in range(n - 1):\n        if (k >> i) & 1 and (k >> i + 1) & 1:\n            return False\n\n    return True\n\np = 10**9+7\n\nH, W, K = map(int, input().split())\n\ndp = [[0]*W for _ in range(H + 1)]\n# dp[i][j] : i\u6bb5\u76ee\u307e\u3067\u307f\u305f\u3068\u304dj\u306b\u3044\u304f\u3088\u3046\u306a\u3042\u307f\u3060\u304f\u3058\u306e\u672c\u6570\n\ndp[0][0] = 1\n\nfor i in range(H):\n    for j in range(1 << (W - 1)):\n        if not is_valid(j): continue\n        for k in range(W):\n            if k < W - 1 and (j >> k) & 1:\n                dp[i + 1][k + 1] += dp[i][k]\n                dp[i + 1][k + 1] %= p\n            elif k > 0 and (j >> (k - 1)) & 1:\n                dp[i + 1][k - 1] += dp[i][k]\n                dp[i + 1][k - 1] %= p\n            else:\n                dp[i + 1][k] += dp[i][k]\n                dp[i + 1][k] %= p\n\nprint(dp[H][K - 1] % p)", "# \u89e3\u8aac\u3068\u4e0b\u8a18\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# https://atcoder.jp/contests/abc113/submissions/15821617\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(H, W, K):\n    mod = 10 ** 9 + 7\n    dp = [[0] * W for _ in range(H + 1)]\n    dp[0][0] = 1\n    fibo = [1, 2, 3, 5, 8, 13, 21]\n    for h in range(H):\n        for w in range(W):\n            if dp[h][w] == 0:\n                continue\n            for i in range(3):\n                new_w = w - 1 + i\n                if not 0 <= new_w < W:\n                    continue\n                l, r = min(w, new_w), max(w, new_w)\n                tmp = fibo[max(l - 1, 0)] * fibo[max(W - 1 - (r + 1), 0)]\n                dp[h + 1][new_w] += dp[h][w] * tmp\n                dp[h + 1][new_w] %= mod\n    print((dp[-1][K - 1]))\n\n\ndef __starting_point():\n    H, W, K = list(map(int, input().split()))\n    solve(H, W, K)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "\"\"\"\n    dp[h][w]: h\u756a\u76ee\u306erow(h: 0~H(\u7d42\u7740))\u3067\u68d2w(w: 0~W-1)\u306b\u3044\u308b\u72b6\u614b\u306b\u306a\u308b\u305f\u3081\u306e\u6a2a\u7dda(0~h)\u306e\u7d44\u5408\u305b\u6570\n    dp[h][w] = A*dp[h-1][w-1] + B*dp[h-1][w] + C*dp[h-1][w+1] O(100*8)\n    A, B, C\u306f\u306a\u3093\u304b\u3046\u307e\u3044\u3053\u3068\u6c7a\u3081\u308c\u305d\u3046\u3002(\u5168\u63a2\u7d22\u3067\u3082O(7*7*7))\n    \"\"\"\ndef main():\n    import sys\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    dp = [[0]*W for _ in range(H+1)]\n    dp[0][0] = 1\n    for h in range(1, H+1):\n        for w in range(W):\n            A, B, C = 0, 0, 0\n            for i in range(2 ** (W-1)):\n                lines = []\n                for j in range(W-1):\n                    if ((i >> j) & 1):\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w-1 >= 0 and lines[w-1]:\n                        A += 1\n                    elif w <= W-2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w-1 >= 0:\n                dp[h][w] += dp[h-1][w-1] * A\n            dp[h][w] += dp[h-1][w] * B\n            if w+1 <= W-1:\n                dp[h][w] += dp[h-1][w+1] * C\n    print(dp[H][K-1] % (10**9+7))\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10**9+7\nH, W, K = list(map(int, input().split()))\ndp = [[0]*W for _ in range(H+1)]\ndp[0][0] = 1\nfor i in range(H):\n    for j in range(W):\n        for k in range(1<<(W-1)):\n            # 2\u3064\u306e\u6a2a\u7dda\u304c\u3064\u306a\u304c\u3063\u3066\u3044\u306a\u3044\u304b\u8abf\u3079\u308b\n            ok = True\n            for l in range(W-2):\n                if (k>>l)&1 and (k>>(l+1))&1:\n                    ok = False\n            if ok:\n                if j>=1 and (k>>(j-1))&1:\n                    # \u5de6\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u305f\u3069\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j-1] += dp[i][j]\n                    dp[i+1][j-1] %= MOD\n                elif j<W-1 and (k>>j)&1:\n                    # \u53f3\u65b9\u5411\u306b\u6a2a\u7dda\u3092\u305f\u3069\u308b\u30b1\u30fc\u30b9\n                    dp[i+1][j+1] += dp[i][j]\n                    dp[i+1][j+1] %= MOD\n                else:\n                    # \u6a2a\u7dda\u3092\u305f\u3069\u3089\u306a\u3044\u30b1\u30fc\u30b9\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\nprint((dp[H][K-1]))\n", "h, w, k = list(map(int, input().split()))\ndp = [0] * w\nmod = 10 ** 9 + 7\n\ncomb = []\nfor bit in range(1 << w - 1):\n    ok = True\n    for j in range(w - 2):\n        if bit >> j & 1 and bit >> j + 1 & 1:\n            ok = False\n    if ok:\n        comb.append(bit)\n\ndp[0] = 1\nfor i in range(h):\n    next = [0] * w\n    for bit in comb:\n        moved = [False] * w\n        for j in range(w):\n            if bit >> j & 1:\n                next[j + 1] += dp[j]\n                next[j] += dp[j + 1]\n                moved[j] = moved[j + 1] = True\n            elif not moved[j]:\n                next[j] += dp[j]\n    dp = next\nprint((dp[k - 1] % mod))\n", "h, w, k = map(int, input().split())\np = 10**9+7\nDP = [[0 for j in range(w+1)] for i in range(h+1)]\nDP[0][0] = 1\nF = [1, 2, 3, 5, 8, 13, 21][:w]+[1]\nfor i in range(h):\n    for j in range(w):\n        a = DP[i][j-1]*F[j-2]*F[w-2-j]\n        b = DP[i][j]*F[j-1]*F[w-2-j]\n        c = DP[i][j+1]*F[j-1]*F[w-3-j]\n        DP[i+1][j] = (a+b+c) % p\nprint(DP[h][k-1])", "H,W,K = map(int,input().split())\ndp = [[0]*W for i in range(H+1)]\ndp[0][0] = 1\nMOD = 10**9+7\nfor i in range(H):\n    for b in range(1<<(W-1)):\n        if '11' in bin(b): continue\n        for k in range(W):\n            if k and b&(1<<(k-1)):\n                dp[i+1][k-1] += dp[i][k]\n            elif b&(1<<k):\n                dp[i+1][k+1] += dp[i][k]\n            else:\n                dp[i+1][k] += dp[i][k]\nprint(dp[-1][K-1] % MOD)", "H, W, K = map(int, input().split())\nmod = 10**9 + 7\n\ndp = [0]*W\ndp[0] = 1\n\nOK = [0, 1, 1, 2, 3, 5, 8, 13]\nNG = [0, 1, 2, 3, 5, 8, 13, 21]\n\nif W == 1:\n  print(dp[K-1])\nelse:\n  for _ in range(H):\n    temp = dp[:]\n    for i in range(W):\n      if i == 0:\n        dp[i] = temp[i] * NG[W-1-i] + temp[i+1] * OK[W-1-i]\n      elif i == W-1:\n        dp[i] = temp[i-1] * OK[i] + temp[i] * NG[i]\n      else:  \n        dp[i] = temp[i-1] * OK[i] * NG[W-1-i] + temp[i] * NG[i] * NG[W-1-i] + temp[i+1] * NG[i] * OK[W-1-i]\n      dp[i] %= mod\n  print(dp[K-1])", "fib = [1, 1, 2, 3, 5, 8, 13, 21]\nmod = 1000000007\nh, w, k = list(map(int, input().split()))\nk -= 1\np = [0] * w\np[0] = 1\nfor i in range(h):\n  q = [0] * w\n  for j in range(w):\n    if j > 0:\n      q[j] += p[j - 1] * fib[j - 1] * fib[w - 1 - j]\n    if j < w - 1:\n      q[j] += p[j + 1] * fib[j] * fib[w - j - 2]\n    if 0 < j < w - 1:\n      q[j] += p[j] * fib[j] * fib[w - j - 1]\n    elif j > 0:\n      q[j] += p[j] * fib[j]\n    elif j < w - 1:\n      q[j] += p[j] * fib[w - j - 1]\n    else:\n      q[j] += p[j]\n    q[j] %= mod\n  p = q\nprint((p[k]))\n", "h,w,k=map(int,input().split())\nmod=10**9+7\ndp=[0]*w\ndp[0]=1\nfib=[1,1,2,3,5,8,13,21,34,55,89]\nfor _ in range(h):\n  t=[0]*w\n  for i in range(w):\n    if i>0:\n      t[i]+=dp[i-1]*fib[i-1]*fib[w-i-1]\n    t[i]+=dp[i]*fib[i]*fib[w-i-1]\n    if i<w-1:\n      t[i]+=dp[i+1]*fib[i]*fib[w-i-2]\n    t[i]%=mod\n  dp=t\nprint(dp[k-1])", "h,w,k=map(int,input().split())\ndp=[0]*(w)\nl=[1,1,2,3,5,8,13,21,34]#n\u672c\u306e\u7e26\u7dda\u306b\u9ad8\u30551\u306evalid\u306a\u6a2a\u68d2\u3092\u5f15\u304f\u901a\u308a\u3001\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\u306b\u306a\u308b\n#a_n:=n\u672c\u306e\u7e26\u7dda\u306bvalid\u306a\u6a2a\u68d2\u3092\u5f15\u304f\u901a\u308a\u306e\u7dcf\u6570\u3001\u3068\u3059\u308c\u3070\n#n+1\u672c\u306e\u6642\u306f1.1\u30682\u672c\u76ee\u306b\u6a2a\u68d2\u3092\u5f15\u304f\uff082\u30683\u306e\u9593\u306b\u5f15\u3051\u306a\u3044\u306e\u3067a_n-1\u901a\u308a\uff09\n#          2.                \u5f15\u304b\u306a\u3044\uff08a_n\u901a\u308a\uff09\n#\u3088\u3063\u3066\u6f38\u5316\u5f0fa_n+1=a_n+a_n-1\u304c\u6210\u7acb\u3002\ndp[0]=1\nmod=10**9+7\nr=[0]*w\nfor i in range(h):\n    for i in range(w):\n        r[i]=dp[i]*l[i]*l[w-1-i]#\u5de6\u53f3\u306b\u6a2a\u68d2\u3092\u5f15\u304b\u306a\u3044\n        if i>=1:\n            r[i]+=dp[i-1]*l[i-1]*l[w-1-i]#\u5de6\u306b\u306e\u307f\u6a2a\u68d2\u3092\u5f15\u304f\n        if i<=w-2:\n            r[i]+=dp[i+1]*l[i]*l[w-2-i]#\u53f3\u306b\u306e\u307f\u6a2a\u68d2\u3092\u5f15\u304f\n        r[i]%=mod\n    dp,r=r,dp\n\nprint(dp[k-1])", "def fib():\n    a = 1\n    b = 0\n    while 1:\n        c = a + b\n        yield c\n        a = b\n        b = c\n\n\ndef main():\n    h, w, k = list(map(int, input().split()))\n\n    dp = [[0] * (w + 2) for _ in range(h + 1)]\n    dp[0][1] = 1\n    f = fib()\n    c = [f.__next__() for _ in range(w + 1)]\n\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            dp[i][j] = c[j - 1] * c[w - j] * dp[i - 1][j] + c[j - 1] * c[w - j - 1] * dp[i - 1][j + 1] + c[j - 2] * c[w - j] * dp[i - 1][j - 1]\n\n    print((dp[h][k] % (10 ** 9 + 7)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import product\n\nh, w, k = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\ndp = [[0] * w for _ in range(h + 1)]\ndp[0][0] = 1\n\npats = [pat for pat in product([1, 0], repeat=w-1)]\n\nfor i in range(h):\n\tfor j in range(w):\n\t\tfor pat in pats:\n\t\t\tvalid = True\n\t\t\tfor e1, e2 in zip(pat, pat[1:]):\n\t\t\t\tif e1 and e2:\n\t\t\t\t\tvalid = False\n\n\t\t\tif not valid:\n\t\t\t\tcontinue\n\n\t\t\tif j - 1 >= 0 and pat[j-1]:\n\t\t\t\tdp[i+1][j-1] += dp[i][j]\n\t\t\t\tdp[i+1][j-1] %= mod\n\n\t\t\telif j <= w - 2 and pat[j]:\n\t\t\t\tdp[i+1][j+1] += dp[i][j]\n\t\t\t\tdp[i+1][j+1] %= mod\n\n\t\t\telse:\n\t\t\t\tdp[i+1][j] += dp[i][j]\n\t\t\t\tdp[i+1][j] %= mod\n\nans = dp[h][k-1]\nprint(ans)\n#print(*dp, sep=\"\\n\")\n", "h,w,k = [int(i) for i in input().split()]\n\nmod = 10**9 + 7\n   \n\ndp = [[0 for _ in range(w)] for _ in range(h + 1)]\ndp[0][0] = 1\n\nfor i in range(h):\n    for bit in range(1<<(w-1)):\n        if '11' in bin(bit) : continue\n        for j in range(w):\n            if j > 0 and bit & (1 << (j-1)):\n                dp[i+1][j-1] += dp[i][j] % mod \n            elif bit & (1 << j):\n                dp[i+1][j+1] += dp[i][j] % mod\n            else:\n                dp[i+1][j] += dp[i][j] % mod\n                \nprint(dp[h][k-1]%mod)", "H, W, K = map(int, input().split())\nMOD = 10**9 + 7\n\ndef check(bit):\n  pre_b = '0'\n  for b in bit:\n    if b == '1' and pre_b == '1':\n      return False\n    pre_b = b\n  return True\n\n# dp[h][w]:\u4e0a\u304b\u3089h\u6bb5\u76ee\u3067\u306e\u64cd\u4f5c\u3092\u7d42\u4e86\u3057\u305f\u6642\u70b9\u3067w\u756a\u76ee\u306e\u3042\u307f\u3060\u306b\u3044\u308b\u5834\u5408\u306e\u6570\ndp = [[0]*(W+2) for h in range(H+1)]\ndp[0][1] = 1\n\n# \u3042\u308b\u6bb5\u306b\u304a\u3051\u308b\u6a2a\u7dda\u306e\u914d\u7f6e\u3092\u5168\u63a2\u7d22\u3057\u3066w-1 <-> w\u306b\u6a2a\u7dda\u304c\u3042\u308b\u6570\nlines = [0] * (W+1)\nc = 0\nfor i in range(2**(W-1)):\n  if not check(bin(i)[2:]):\n    continue\n  c += 1\n  for w in range(W-1):\n    lines[w+1] += (i & 1<<w) > 0\n\n\n# \u914d\u308bDP\nfor h in range(H):\n  for w in range(1, W+1):\n    x, z = lines[w-1], lines[w]\n    y = c - x - z\n    dp[h+1][w-1] = (dp[h+1][w-1] + dp[h][w]*x % MOD) % MOD\n    dp[h+1][w] = (dp[h+1][w] + dp[h][w]*y % MOD) % MOD\n    dp[h+1][w+1] = (dp[h+1][w+1] + dp[h][w]*z % MOD) % MOD\n\nprint(dp[-1][K])", "import sys\n\nh, w, k = map(int, input().split())\nmod = 10 ** 9 + 7\nif w == 1:\n    print(1)\n    return\nrow = [0 for i in range(w + 1)]\nrow[0] = 1\nrow[1] = 1\nfor i in range(w - 1):\n    row[i + 2] = row[i + 1] + row[i]\n\ndp = [[0 for i in range(w)] for j in range(h + 1)]\ndp[0][0] = 1\nfor i in range(h):\n    for j in range(w):\n        if j == 0:\n            dp[i + 1][j] = dp[i][j] * row[w - 1] + dp[i][j + 1] * row[w - 2]\n            dp[i + 1][j] %= mod\n        elif j == w - 1:\n            dp[i + 1][j] = dp[i][j] * row[w - 1] + dp[i][j - 1] * row[w - 2]\n            dp[i + 1][j] %= mod\n        else:\n            dp[i + 1][j] = dp[i][j - 1] * row[j - 1] * row[w - j - 1] + dp[i][j] * row[j] * row[w - j - 1] + dp[i][j + 1] * row[j] * row[w - j - 2]\n            dp[i + 1][j] %= mod\nprint(dp[h][k - 1])", "import sys\nh, w, k = map(int, input().split())\n\nmod = 10 ** 9 + 7\n\nif w == 1:\n    print(1)\n    return\n\nn_join = [0 for i in range(w-1)]\nn_unjoin = [0 for i in range(w-1)]\ncnt = 0\n\nfor i in range(2 ** (w-1)):\n    p = 0\n    f = 1\n    tmp_join = []\n    tmp_unjoin = []\n    for j in range(w-1):\n        c = i & (1 << j)\n        if c:\n            tmp_join.append(j)\n        if not (c or p):\n            tmp_unjoin.append(j)\n        if p and c:\n            f = 0\n            break\n        p = c\n    if f:\n        cnt += 1\n        for j in tmp_join:\n            n_join[j] += 1\n        for j in tmp_unjoin:\n            n_unjoin[j] += 1\n\nn_unjoin.append(cnt - n_join[-1])\n\ndp = [[0 for j in range(w)] for i in range(h)]\ndp[0][0] = n_unjoin[0]\ndp[0][1] = n_join[0]\n\nfor i in range(1,h):\n    for j in range(w):\n        dp[i][j] += dp[i-1][j] * n_unjoin[j] % mod\n        dp[i][j] %= mod\n        if j > 0:\n            dp[i][j] += dp[i-1][j-1] * n_join[j-1] % mod\n            dp[i][j] %= mod\n        if j < w - 1:\n            dp[i][j] += dp[i-1][j+1] * n_join[j] % mod\n            dp[i][j] %= mod\n        \nprint(dp[h-1][k-1])", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print(('\\n'.join(x)))\ndef printni(x): print(('\\n'.join(list(map(str,x)))))\ninf = 10**17\nmod = 10**9 + 7\n\nh,w,k=MI()\ndp=[[0]*w for i in range(h+1)]\ndp[0][0]=1\na=0\nb=1\nweight=[]\nfor i in range(100):\n    weight.append(a+b)\n    a,b=b,a+b\n#print(weight)    \nfor i in range(h):\n    for j in range(w):\n        if 0<=j+1<w:\n            left=max(j-1,0)\n            right=max(w-j-3,0)\n            dp[i+1][j+1]+=(dp[i][j]*weight[left]*weight[right])%mod\n        if 0<=j<w:\n            left=max(j-1,0)\n            right=max(w-j-2,0)\n            dp[i+1][j]+=(dp[i][j]*weight[left]*weight[right])%mod\n        if 0<=j-1<w:\n            left=max(j-2,0)\n            right=max(w-j-2,0)\n            dp[i+1][j-1]+=(dp[i][j]*weight[left]*weight[right])%mod\nprint((dp[-1][k-1]%mod))\n\n\n", "H,W,K = map(int,input().split())\nmod = 10**9+7\ndp = W*[0]\ndp[0] = 1\nfib = [1,1,2,3,5,8,13,21,34,55,89]\n\nfor h in range(H):\n  t = W*[0]\n  for w in range(W):\n    if 0<w:\n      t[w]+=dp[w-1]*fib[w-1]*fib[W-w-1]\n    t[w]+=dp[w]*fib[w]*fib[W-w-1]\n    \n    if w<W-1:\n      t[w]+=dp[w+1]*fib[w]*fib[W-w-2]\n    t[w]%=mod\n  dp = t\n\nprint(dp[K-1])", "\nfrom itertools import product\n\n\ndef patterns(w):\n    res = []\n    for pt in product([0, 1], repeat=w):\n        valid = True\n        for i in range(w - 1):\n            if pt[i] == pt[i + 1] == 1:\n                valid = False\n                break\n        if valid:\n            res.append(pt)\n    return res\n\n\ndef submit():\n    h, w, k = [int(e) for e in input().split()]\n    dp = [[0 for _ in range(w)] for _ in range(h + 1)]\n    dp[0][0] = 1\n    modp = 10 ** 9 + 7\n\n    pts = patterns(w - 1)\n\n    for i in range(1, h + 1):\n        for j in range(w):\n            for pt in pts:\n                if j > 0 and pt[j - 1] == 1: # j -> j - 1\u306b\u9077\u79fb\u3059\u308b\n                    dp[i][j - 1] += dp[i - 1][j]\n                    dp[i][j - 1] %= modp\n                elif j < w - 1 and pt[j] == 1:  # j -> j + 1\u306b\u9077\u79fb\u3059\u308b\n                    dp[i][j + 1] += dp[i - 1][j]\n                    dp[i][j + 1] %= modp\n                else:\n                    dp[i][j] += dp[i - 1][j]\n                    dp[i][j] %= modp\n\n\n    print(dp[h][k - 1])\n\n\nsubmit()", "from itertools import product\nH, W, K = list(map(int, input().split()))\nmod = 10 ** 9 + 7\n\nif W == 1:\n    print((1))\n    return\n\nup = [0] * W\nright = [0] * W\nleft = [0] * W\n\nfor b in range(1 << (W - 1)):\n    bridge = bin(b)[2:].zfill(W - 1)\n    if \"11\" in bridge:\n        continue\n\n    # \u5de6\u306e\u68d2\n    if bridge[0] == \"0\":\n        up[0] += 1\n    else:\n        right[0] += 1\n\n    # \u53f3\u306e\u68d2\n    if bridge[-1] == \"0\":\n        up[W - 1] += 1\n    else:\n        left[W - 1] += 1\n\n    # \u771f\u3093\u4e2d\n    for i in range(1, W - 1):\n        if bridge[i - 1] == \"0\" and bridge[i] == \"1\":\n            right[i] += 1\n        elif bridge[i - 1] == \"1\" and bridge[i] == \"0\":\n            left[i] += 1\n        else:\n            up[i] += 1\n\nup = [0] + up + [0]\nright = [0] + right + [0]\nleft = [0] + left + [0]\n\ndp = [0] * (W + 2)\ndp[K] = 1\nfor _ in range(H):\n    newDP = [0] * (W + 2)\n    for i in range(1, W + 1):\n        newDP[i] += dp[i - 1] * right[i - 1]\n        newDP[i] += dp[i] * up[i]\n        newDP[i] += dp[i + 1] * left[i + 1]\n        newDP[i] %= mod\n    dp = newDP\n\nans = dp[1]\nprint(ans)\n", "w = [1, 2]\nfor i in range(6):\n    w.append(w[-2] + w[-1])\nH, W, K = map(int,input().split())\nmod = 10 ** 9 + 7\ndp = [[0 for i in range(W)] for j in range(H+1)]\ndp[0][0] = 1\nfor i in range(H):\n    for j in range(W):\n        if j >= 1:\n            k = 1\n            if j - 2 >= 0:\n                k *= w[j - 2]\n            if W - j - 2 >= 0:\n                k *= w[W - j - 2]\n            dp[i+1][j-1] += k * dp[i][j]\n            dp[i+1][j-1] %= mod\n        k = 1\n        if j - 1 >= 0:\n            k *= w[j - 1]\n        if  W - j - 2 >= 0:\n            k *= w[W - j - 2]\n        dp[i+1][j] += k * dp[i][j]\n        dp[i+1][j] %= mod\n        if j <= W - 2:\n            k = 1\n            if j - 1 >= 0:\n                k *= w[j - 1]\n            if W - j - 3 >= 0:\n                k *= w[W - j - 3]\n            dp[i+1][j+1] += k * dp[i][j]\n            dp[i+1][j+1] %= mod\n\nprint(dp[H][K-1] % mod)", "h,w,k=map(int,input().split())\ndp=[[0 for _ in range(w)]for _ in range(h+1)]\ndp[0][0]=1\nmod=10**9+7\nfor i in range(h):\n    for bit in range(2**(w-1)):\n        bit=bin(bit)[2:].zfill(w-1)\n        f=0\n        for j in range(w-2):\n            if bit[j]=='1' and bit[j+1]=='1':\n                f=1\n                break\n        if f:\n            continue\n        for j in range(w):\n            if j==0:\n                dp[i+1][j]+=dp[i][j+1] if bit[0]=='1' else dp[i][j]\n            elif j==w-1:\n                dp[i+1][j]+=dp[i][j-1] if bit[-1]=='1' else dp[i][j]\n            else:\n                dp[i+1][j]+=dp[i][j]*(bit[j-1]=='0' and bit[j]=='0')\n                dp[i+1][j]+=dp[i][j-1]*(bit[j-1]=='1')\n                dp[i+1][j]+=dp[i][j+1]*(bit[j]=='1')\n            dp[i+1][j]%=mod\nprint(dp[-1][k-1])", "# Python3 (3.4.3)\nimport sys\ninput = sys.stdin.readline\n\n# -------------------------------------------------------------\n# function\n# -------------------------------------------------------------\n\n\n# -------------------------------------------------------------\n# main\n# -------------------------------------------------------------\nH,W,K = map(int,input().split())\n\nmod = 10**9+7\n\n# \u5de6(\u3042\u308b\u3044\u306f\u53f3)\u306bn\u672c\u306e\u7e26\u68d2\u304c\u3042\u308a\u3001\u771f\u6a2a\u3068\u7e4b\u304c\u3063\u3066\u3044\u308b\u6642\u306e\u5834\u5408\u306e\u6570\nj = [0,1,1,2,3,5,8,13];\n# \u5de6(\u3042\u308b\u3044\u306f\u53f3)\u306bn\u672c\u306e\u7e26\u68d2\u304c\u3042\u308a\u3001\u771f\u6a2a\u3068\u7e4b\u304c\u3063\u3066\u3044\u306a\u3044\u6642\u306e\u5834\u5408\u306e\u6570\nm = [1,1,2,3,5,8,13,21];\n \n# dp[h][w] : h\u884c\u76ee\u3092\u7d42\u3048\u305f\u6642\u70b9\u3067w\u306b\u3044\u308b\u5834\u5408\u306e\u6570\ndp = [[0 for _ in range(W)] for _ in range(H+1)]\ndp[0][0] = 1\n \nfor h in range(H+1):\n    for w in range(W):\n        # \u53f3\u306b\u79fb\u52d5\n        if w != 0:\n            dp[h][w] += dp[h-1][w-1] * j[w] * m[W-1-w]\n        # \u5de6\u306b\u79fb\u52d5\n        if w != W-1:\n            dp[h][w] += dp[h-1][w+1] * m[w] * j[W-1-w]\n        # \u771f\u4e0b\u306b\u79fb\u52d5\n        dp[h][w] += dp[h-1][w] * m[w] * m[W-1-w]\n        \n        dp[h][w] %= mod;\n\n    \nprint(dp[H][K-1])", "H, W, K = list(map(int, input().split()))\n\n# \u9023\u7d9a\u3059\u308bn\u533a\u9593\u306b\u6a4b\u3092\u304b\u3051\u308b\u65b9\u6cd5\u306f\u4f55\u901a\u308a\u3042\u308b\u304b\n# kakekata[b][i] : b\u304c0\u306e\u6642\u306fi\u533a\u9593\u76ee\u306b\u6a4b\u3092\u304b\u3051\u306a\u3044\u65b9\u6cd5 b\u304c1\u306e\u6642\u306fi\u533a\u9593\u76ee\u306b\u6a4b\u3092\u304b\u3051\u308b\u65b9\u6cd5 \u304c\u4f55\u901a\u308a\u3042\u308b\u304b\nkakekata = [[0] * 10] + [[0] * 10]\nkakekata[0][0] = 1\nfor i in range(8):\n    kakekata[0][i + 1] = kakekata[0][i] + kakekata[1][i]\n    kakekata[1][i + 1] = kakekata[0][i]\n\n\nMOD = 10 ** 9 + 7\nclass modint:\n    def __init__(self, x):\n        self.x = x.x if isinstance(x, modint) else x % MOD\n    def __str__(self): return str(self.x)\n    __repr__ = __str__\n    def __int__(self): return self.x\n    __index__ = __int__\n    def __add__(self, other): return modint(self.x + modint(other).x)\n    def __sub__(self, other): return modint(self.x - modint(other).x)\n    def __mul__(self, other): return modint(self.x * modint(other).x)\n    def __pow__(self, other): return modint(pow(self.x, modint(other).x, MOD))\n    def __floordiv__(self, other): return modint(self.x * pow(modint(other).x, MOD - 2, MOD))\n    def __eq__(self, other): return self.x == modint(other).x\n    def __ne__(self, other): return self.x != modint(other).x\n    def __inv__(self): return pow(self.x, MOD - 2, MOD)\n\n\ndp = [[modint(0)] * (W + 2) for h in range(H + 1)]\ndp[0][1] += 1\nfor h in range(H):\n    for w in range(1, W + 1):\n        # \u5de6\u306b\u4f55\u533a\u9593\u3042\u308b\u304b \u53f3\u306b\u4f55\u533a\u9593\u3042\u308b\u304b\n        l, r = w - 1, W - w\n\n        # \u305d\u306e\u307e\u307e\u6e21\u3059\n        dp[h + 1][w] += dp[h][w] * kakekata[0][l] * kakekata[0][r]\n        # \u53f3\u306b\u6e21\u3059\n        dp[h + 1][w + 1] += dp[h][w] * kakekata[0][l] * kakekata[1][r]\n        # \u5de6\u306b\u6e21\u3059\n        dp[h + 1][w - 1] += dp[h][w] * kakekata[1][l] * kakekata[0][r]\n\nprint((dp[H][K]))\n", "h,w,K=list(map(int,input().split()))\ndef two(x):\n\treturn \"0\"*(w-1-len(bin(x)[2:]))+bin(x)[2:]\ndp=[[0]*w for _ in range(h+1)]\ndp[0][0]=1\nmod=10**9+7\nfor i in range(h):\n\tfor j in range(2**(w-1)):\n\t\tr=two(j)\n\t\tf=1\n\t\tfor k in range(w-2):\n\t\t\tif r[k]==r[k+1]==\"1\":\n\t\t\t\tf=0\n\t\t\t\tbreak\n\t\tif f:\n\t\t\tfor k in range(w):\n\t\t\t\tif k+1<w:\n\t\t\t\t\tif r[k]==\"1\":\n\t\t\t\t\t\tdp[i+1][k+1]+=dp[i][k]\n\t\t\t\t\t\tdp[i+1][k+1]%=mod\n\t\t\t\t\t\tcontinue\n\t\t\t\tif k>0:\n\t\t\t\t\tif r[k-1]==\"1\":\n\t\t\t\t\t\tdp[i+1][k-1]+=dp[i][k]\n\t\t\t\t\t\tdp[i+1][k-1]%=mod\n\t\t\t\t\t\tcontinue\n\t\t\t\tdp[i+1][k]+=dp[i][k]\n\t\t\t\tdp[i+1][k]%=mod\nprint((dp[h][K-1]))\n\n", "#\u5b9f\u306fDP\u3068\u5272\u308a\u5207\u308b\u3068\u308f\u304b\u308a\u3084\u3059\u3044\nmod=10**9+7\nh,w,K=map(int,input().split())\ndp=[[0]*w for j in range(h+1)]\ndp[0][0]=1\nfor i in range(1,h+1):\n    for k in range(2**(w-1)):\n        for l in range(w-2):\n            if ((k>>l)&1) and ((k>>(l+1))&1):\n                break\n        else:\n            for l in range(w):\n                if l==0:\n                    if ((k>>l)&1):\n                        dp[i][l+1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n                elif l==w-1:\n                    if ((k>>(l-1))&1):\n                        dp[i][l-1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n                else:\n                    if ((k>>l)&1) or ((k>>(l-1))&1):\n                        if ((k>>l)&1):\n                            dp[i][l+1]+=dp[i-1][l]\n                        else:\n                            dp[i][l-1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n            #dp[i][l]%=mod\nprint(dp[h][K-1]%mod)", "import sys\nreadline = sys.stdin.readline\n\n# 0-indexed\u3067\u8003\u3048\u308b\n# \u7e26\u68d2\u306fW\u672c\u3001\u6a2a\u68d2\u3092\u7f6e\u3051\u308b\u5834\u6240\u306f\u4e00\u884c\u3042\u305f\u308aW - 1\u7b87\u6240\u3068\u306a\u308b\n# \u30fbi\u3068i + 1\u306e\u9593\u306b\u6a2a\u68d2\u3092\u5f15\u3044\u305f\u5834\u5408\u306e\u6570\n# \u30fbi\u304b\u3089\u79fb\u52d5\u305b\u305a\u306b\u305d\u306e\u307e\u307e\u306b\u306a\u308b\u5834\u5408\u306e\u6570\n# \u3092\u305d\u308c\u305e\u308c\u6c42\u3081\u308b\n\n# LINE[i] = i\u3068i + 1\u306e\u9593\u306b\u6a2a\u68d2\u3092\u5f15\u3044\u305f\u5834\u5408\u306e\u6570\u3002\n# POINT[i] = i\u304b\u3089\u6a2a\u68d2\u304c\u51fa\u3066\u3044\u306a\u3044\u5834\u5408\u306e\u6570\n# \u305d\u308c\u305e\u308cDP\u3067\u6c42\u3081\u308b\n\nH,W,K = list(map(int,readline().split()))\nDIV = 1000000007\n\n# dp[i][j] = \u9593\u9694i\u307e\u3067\u51e6\u7406\u3057\u305f\u3068\u304d\u306b\u3001j\u756a\u76ee\u306e\u9593\u9694\u306b\u68d2\u304c\u3042\u308b(0,1)\u5834\u5408\u306e\u6570\nLINE = [-1] * (W - 1)\nfor i in range(W - 1):\n  # i\u3068i + 1\u306e\u9593\u306b\u68d2\u304c\u3042\u308b\u5834\u5408\n  dp = [[0] * 2 for j in range(W - 1)]\n  if i == 0:\n    dp[0][0] = 0\n    dp[0][1] = 1\n  else:\n    dp[0][0] = 1\n    dp[0][1] = 1\n  for j in range(1, W - 1):\n    if j == i:\n      dp[j][0] = 0\n      dp[j][1] = dp[j - 1][0]\n    else:\n      dp[j][0] += dp[j - 1][0] + dp[j - 1][1]\n      dp[j][1] += dp[j - 1][0]\n  LINE[i] = dp[-1][0] + dp[-1][1]\n  LINE[i] %= DIV\n\nPOINT = [-1] * W\n# \u70b9i\u304b\u3089\u307e\u3063\u3059\u3050\u4e0b\u304c\u308b\u5834\u5408\u306e\u6570\n# i\u304b\u3089\u53f3\u306b\u68d2\u3092\u5f15\u304f/\u5f15\u304b\u306a\u3044\u5834\u5408\u306e\u6570\u3092\u6570\u3048\u308b\nfor i in range(W):\n  # i - 1\u306b\u3082i\u306b\u3082\u68d2\u304c\u306a\u3044\u5834\u5408\n  dp = [[0] * 2 for j in range(W)]\n  if i - 1 == 0 or i == 0:\n    dp[0][0] = 1\n    dp[0][1] = 0\n  else:\n    dp[0][0] = 1\n    dp[0][1] = 1\n  for j in range(1, W):\n    if j == i - 1 or j == i:\n      dp[j][1] = 0\n      dp[j][0] += dp[j - 1][0] + dp[j - 1][1]\n    else:\n      dp[j][0] += dp[j - 1][0] + dp[j - 1][1]\n      if j == W - 1:\n        dp[j][1] = 0\n      else:\n        dp[j][1] += dp[j - 1][0]\n  POINT[i] = dp[-1][0] + dp[-1][1]\n  POINT[i] %= DIV\n  \n# \u3053\u3053\u304b\u3089DP\n# dp[i][j] = \u3042\u307f\u3060\u306ei\u6bb5\u76ee\u3067j\u306b\u3044\u308b\u5834\u5408\u306e\u6570\n\ndp = [[0] * W for i in range(H + 1)]\ndp[0][0] = 1\n\nfor i in range(1, len(dp)):\n  for j in range(W):\n    # j\u3092\u51fa\u767a\u70b9\u306b\u3057\u3066\u9077\u79fb\u3059\u308b\n    if j - 1 >= 0:\n      dp[i][j] += dp[i - 1][j - 1] * LINE[j - 1]\n    dp[i][j] += dp[i - 1][j] * POINT[j]\n    if j + 1 < W:\n      dp[i][j] += dp[i - 1][j + 1] * LINE[j]\n      \n    dp[i][j] %= DIV\n    \nprint((dp[H][K - 1]))\n", "H, W, K = [int(x) for x in input().split()]\np = 10 ** 9 + 7\n\n# H = 1, \u7e26\u68d2W\u672c\u306e\u3042\u307f\u3060\u304f\u3058\u306e\u6570\u3000\u2192\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\nh1amida = [1, 1, 2] + [None] * 6\nfor i in range(3, 9):\n    h1amida[i] = h1amida[i - 2] + h1amida[i - 1]\n\n# dp[h][k] = \u7e26\u68d2\u306e\u9577\u3055h+1\u3001\u7e26\u68d2\u306e\u672c\u6570W\u3001\u30b4\u30fc\u30eb\u306e\u68d2k\u3068\u306a\u308b\u3042\u307f\u3060\u306e\u6570\n# dp[0][*]\u3068dp[*][0]\u306f\u30c0\u30df\u30fc\ndp = [[0 for _ in range(W + 1)] for _ in range(H + 1)]\n\nfor k in range(1, W + 1):\n    if k == 1:\n        dp[1][k] = h1amida[W - 1]\n    elif k == 2:\n        dp[1][k] = h1amida[W - 2]\n    else:\n        dp[1][k] = 0\n\nfor h in range(2, H + 1):\n    for k in range(1, W + 1):\n        if k > 1:\n            dp[h][k] += (dp[h - 1][k - 1] * h1amida[k - 2] % p) * h1amida[W - k] % p\n        dp[h][k] += (dp[h - 1][k] * h1amida[k - 1] % p) * h1amida[W - k] % p\n        if k < W:\n            dp[h][k] += (dp[h - 1][k + 1] * h1amida[k - 1] % p) * h1amida[W - k - 1] % p\n        dp[h][k] %= p\n\nprint((dp[H][K]))\n", "def isok(n):\n    for i in range(w-2):\n        if n >> i & 1 and n >> (i+1) & 1:\n            return False\n    return True\nmod = 10**9+7\nh,w,k = map(int,input().split())\nh += 1\nif w == 1:\n    print(1)\n    return\nif w == 2:\n    print(2**(h-2))\n    return\ndp = [[0]*(w+1) for _ in range(h+1)]\ndp[1][1] = 1\namida = [0]*(w)\nnoamida = [0]*(w+1)\nfor i in range(2**(w-1)):\n    if isok(i):\n        for j in range(w-1):\n            amida[j+1] += i >> j & 1\n        for j in range(w-2):\n            if i >> j & 1 == 0 and i >> (j+1) & 1 == 0:\n                noamida[j+2] += 1\n        if i >> 0 & 1 == 0:\n                noamida[1] += 1\n        if i >> (w-2) & 1 == 0:\n                noamida[w] += 1\nfor i in range(1,h):\n    dp[i+1][1] = (dp[i][2]*amida[1]+dp[i][1]*noamida[1]) % mod\n    dp[i+1][w] = (dp[i][w-1]*amida[w-1]+dp[i][w]*noamida[w]) % mod\n    for j in range(2,w):\n        dp[i+1][j] = (dp[i][j-1]*amida[j-1]+dp[i][j+1]*amida[j]+dp[i][j]*noamida[j]) % mod\nprint(dp[h][k])", "from functools import lru_cache\n\nH, W, K = map(int, input().split())\nMOD = 10**9 + 7\nK -= 1\n\nif W == 1:\n    print(1)\n    return\n\n@lru_cache(maxsize=None)\ndef fib(width):\n    if width < -1:\n        return 0\n    if width == -1:\n        return 1\n    return (fib(width - 1) + fib(width - 2)) % MOD\n\ndp = [0] * W\ndp[0] = 1\n\nfor _ in range(H):\n    newDp = [0] * W\n\n    newDp[0] = (dp[0] * fib(W - 2) + dp[1] * fib(W - 3)) % MOD\n    newDp[W - 1] = (dp[W - 1] * fib(W - 2) + dp[W - 2] * fib(W - 3)) % MOD\n\n    for w in range(1, W - 1):\n        left = dp[w - 1] * max(1, fib(w - 2)) * max(1, fib(W - 1 - w - 1))\n        right = dp[w + 1] * max(1, fib(w - 1)) * max(1, fib(W - 1 - w - 2))\n        mid = dp[w] * max(1, fib(w - 1)) * max(1, fib(W - 1 - w - 1))\n        newDp[w] = (left + mid + right) % MOD\n    dp = newDp\n\nprint(dp[K])", "from itertools import combinations\n\nH,W,K=map(int,input().split())\ndp=[[0 for i in range(W)] for j in range(H+1)]\n\nmod=10**9+7\n\nif W==1:\n  if K==1:print(1)\n  else:print(0)\n  return\n\nmemo={}\ndef is_separate(c):\n  for i in range(len(c)-1):\n    if c[i+1]-c[i] == 1:\n      return False\n  return True\n\ndef n_select(occupied):\n  if memo.get(occupied):\n    return memo[occupied]\n  else:\n    count=1\n    if len(occupied)==1:\n      for r in range(1,W//2+1):\n        for c in combinations(range(W-1),r=r):\n          if occupied[0]-1 not in c and occupied[0] not in c:\n            if is_separate(c):\n              count += 1\n    if len(occupied)==2:\n      for r in range(1,W//2+1):\n        for c in combinations(range(W-1),r=r):\n          if occupied[0]-1 not in c and occupied[0] not in c and occupied[0]+1 not in c:\n            if is_separate(c):count += 1\n  memo[occupied] = count\n  return count\n\ndp[0][0]=1\nfor i in range(1,H+1):\n  for j in range(W):\n    if j==0:\n      dp[i][j] = dp[i-1][j]*n_select((j,))+dp[i-1][j+1]*n_select((j,j+1))\n    elif j==W-1:\n      dp[i][j] = dp[i-1][j]*n_select((j,))+dp[i-1][j-1]*n_select((j-1,j))\n    else:\n      dp[i][j] = dp[i-1][j]*n_select((j,))+dp[i-1][j+1]*n_select((j,j+1))+dp[i-1][j-1]*n_select((j-1,j))\n\nprint(dp[-1][K-1] % mod)", "# |-| | | | |\n# \u306e\u3088\u3046\u306b\u4e00\u756a\u5de6\u306e\u4e00\u672c\u304c\u6c7a\u307e\u3063\u305f\u3068\u304d\u3001\u6b8b\u308a\u306e\n#     | | | |\n# \u306b\u306f\u3001\u7dda\u3092\u5f15\u304f\u5834\u6240\u304c3\u3064\u3042\u308b\n# \u7dda\u3092\u5f15\u304f\u5834\u6240\u304cN\u500b\u3042\u308b\u3068\u304d\u306e\u7dda\u306e\u5f15\u304d\u65b9\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\n# A[1] = 2, A[2] = 3, A[N] = A[N - 2] + A[N - 1]\n# \u306e\u307b\u307c\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\n# 2,3,5,8,13...\n# \u3053\u308c\u3092\u3042\u3089\u304b\u3058\u3081\u6700\u5927\u6570\u3076\u3093\u6c42\u3081\u3066\u304a\u304f\n# \u6a2a\u68d2W\u672c\u306b\u5bfe\u3057\u3066\u3001W - 1\u500b\u306e\u9593\u9694\u304c\u3042\u308a\u3001\u305d\u306e\u3046\u3061\u7aef\u306e2\u304b\u6240\u304c\u57cb\u307e\u3063\u305f\u72b6\u614b\u304c\u6700\u5927\u306a\u306e\u3067W - 3\n# \u3053\u308c\u3092\u6c42\u3081\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nDIV = 10 ** 9 + 7\nH,W,K = map(int,readline().split())\n\nP = [0] * max(W - 2 + 1,3)\nP[1],P[2] = 2,3\nfor i in range(3, len(P)):\n  P[i] = P[i - 1] + P[i - 2]\n  \n# [0, 2, 3, 5, 8, 13, 21, 34, ...]\n\n# \u901a\u3089\u306a\u3044\u7dda\u306f\u4e0a\u8a18\u3067\u7b97\u51fa\u3067\u304d\u308b\u306e\u3067\u3001\u901a\u308b\u7dda\u3092\u8003\u3048\u308b\n# \u4e0a\u304b\u3089i\u6bb5\u76ee\u307e\u3067\u7d42\u3048\u305f\u6642\u70b9\u3067\u3001\u7e26\u68d2j\u306b\u3044\u308b\u3068\u304d\u306e\u5834\u5408\u306e\u6570\u3067DP\u3059\u308b\n\ndp = [[0 for j in range(W)] for i in range(H + 1)]\n\ndp[0][0] = 1 # \u4e0a\u304b\u30890\u6bb5\u76ee\u3092\u7d42\u3048\u305f\u6642\u70b9(\u307e\u3060\u4f55\u3082\u3057\u3066\u3044\u306a\u3044)\u3068\u304d\u306b0\u306b\u3044\u308b\u306e\u30671\u901a\u308a\n\ndef calc(L,R): # L\u3068R\u306e\u9593\u306b\u7dda\u3092\u5f15\u3044\u305f\u5834\u5408\u306e\u3001\u6b8b\u308a\u306e\u7dda\u306e\u5f15\u304d\u65b9\n  res = 1\n  if 1 < L:\n    # | | |-| L\u304c2\u306e\u3068\u304d\u306f\u3058\u3081\u3066\u30b9\u30da\u30fc\u30b9\u304c1 (L - 1)\u3067\u304d\u308b\n    res *= P[L - 1]\n    res %= DIV\n  if (W - 1) - (R + 1) >= 1:\n    # |-| | | R + 2 = W - 1\u306e\u3068\u304d\u306f\u3058\u3081\u3066\u30b9\u30da\u30fc\u30b9\u304c1(W - R)\u3067\u304d\u308b\n    res *= P[(W - 1) - (R + 1)]\n    res %= DIV\n  return res\n  \n# \u53f3\u306b\u79fb\u52d5\u3059\u308b\u3001\u5de6\u306b\u79fb\u52d5\u3059\u308b\u3001\u4f55\u3082\u3057\u306a\u3044\u3001\u306e3\u901a\u308a\u3067DP\nfor i in range(H):\n  for j in range(W):\n    # \u53f3\u306b\u79fb\u52d5\u3059\u308b\n    if j + 1 < W:\n      dp[i + 1][j + 1] += dp[i][j] * calc(j, j + 1)\n      dp[i + 1][j + 1] %= DIV\n    # \u5de6\u306b\u79fb\u52d5\u3059\u308b\n    if j - 1 >= 0:\n      dp[i + 1][j - 1] += dp[i][j] * calc(j - 1,j)\n      dp[i + 1][j - 1] %= DIV\n    # \u4f55\u3082\u3057\u306a\u3044\n    dp[i + 1][j] += dp[i][j] * calc(j,j) # \u5de6\u7aef\u3082\u53f3\u7aef\u3082\u540c\u3058\n    dp[i + 1][j] % DIV\n    \n# i = H\u6bb5\u76ee\u307e\u3067\u7d42\u3048\u305f\u6642\u70b9\u3067\u3001j = K - 1\u306b\u3044\u308b\u5834\u5408\u306e\u6570\nprint(dp[H][K - 1] % DIV)", "H,W,K = map(int, input().split())\n\nif W == 1:\n    print(1 if K == 1 else 0)\n    return\n\nMOD = 10 ** 9 + 7\n\nstates = [0]\nfor state in range(1, 1 << (W - 1)):\n    flag = True\n    for j in range(1, W - 1):\n        if ((state >> j - 1) & 1) and ((state >> j) & 1):\n            flag = False\n    if flag: states.append(state)\n\ndp = [[0] * W for _ in range(H + 1)]\n\ndp[0][0] = 1\n\n# \u8cb0\u3046DP\nfor i in range(H):\n    for state in states:\n        for j in range(W - 1):\n            if (state >> j) & 1:\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j + 1]) % MOD\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n            else:\n                if j == 0:\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n                elif not ((state >> j - 1) & 1):\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n                if j == W - 2:\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j + 1]) % MOD\n\nprint(dp[H][K - 1])", "import itertools\n\n\ndef amida_patterns(w):\n    # (0, 1, 2, ... , w - 1) -> ?\n    ret = list()\n    for bars in itertools.product([0, 1], repeat=w-1):\n        if sum([b * bb for b, bb in zip(bars[1:], bars[:-1])]) > 0:\n            continue\n        location = list(range(w))\n        for i in range(w):\n            if i > 0 and bars[i - 1] == 1:\n                location[i] = i - 1\n            elif i < w - 1 and bars[i] == 1:\n                location[i] = i + 1\n        ret.append(location)\n    return ret\n\n\ndef main():\n    MOD = 10**9 + 7\n    H, W, K = list(map(int, input().split(' ')))\n    ap_list = amida_patterns(W)\n    dp = [[0 for _ in range(W)] for _ in range(H + 1)]\n    dp[0][0] = 1\n    for h in range(1, H + 1):\n        for a in ap_list:\n            for w in range(W):\n                dp[h][a[w]] += dp[h - 1][w]\n                dp[h][a[w]] %= MOD\n    print(dp[H][K - 1])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ndef comb(n, r, mod=None):\n    if r == 0 or r == n:\n        return 1\n    r = min([r, n-r])\n    x, y = 1, 1\n    ans = 1\n    for i in range(1, r+1):\n        if mod:\n            x *= n+1-i\n            y *= i\n            x %= mod\n            y %= mod\n        else:\n            ans *= n+1-i\n            ans //= i\n    ans = x*pow(y, mod-2, mod)%mod if mod else ans\n    return ans\n\n\ndef main():\n    h, w, k = map(int, input().split())\n    mod = pow(10,9)+7\n    \n    if w == 1:\n        print(1)\n        return\n    \n    comb_list = [[0]*11 for _ in range(11)]\n    for i in range(11):\n        for j in range(11):\n            if i >= j:\n                comb_list[i][j] = comb(i, j)\n    \n    key_list = [1]*10\n    for i in range(1, 10):\n        key = 0\n        for j in range(1, 10):\n            if i < j*2-1:\n                break\n            key += comb_list[i-j+1][j]\n        key_list[i] += key\n    \n    \n    dp = [[0]*w for _ in range(h)]\n    for i in range(h):\n        if i == 0:\n            dp[0][0] = key_list[w-2]\n            dp[0][1] = key_list[w-3] if w != 2 else 1\n            continue\n        if w == 2:\n            dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n            dp[i][1] = (dp[i-1][0]+dp[i-1][1])%mod\n            continue\n            \n        for j in range(w):\n            if j == 0:\n                dp[i][j] = (dp[i-1][j]*key_list[w-2]+dp[i-1][j+1]*key_list[w-3])%mod\n            elif j == w-1:\n                dp[i][j] = (dp[i-1][j]*key_list[w-2]+dp[i-1][j-1]*key_list[w-3])%mod\n            else:\n                dp[i][j] = 0\n                dp[i][j] += (dp[i-1][j-1]*key_list[max([0, j-2])]*key_list[max([0, w-2-j])])%mod\n                dp[i][j] += (dp[i-1][j]*key_list[max([0, j-1])]*key_list[max([0, w-2-j])])%mod\n                dp[i][j] += (dp[i-1][j+1]*key_list[max([0, j-1])]*key_list[max([0, w-3-j])])%mod\n                dp[i][j] %= mod\n    print(dp[h-1][k-1])\n                                                                           \n\ndef __starting_point():\n    main()\n__starting_point()", "\"\"\"\n    dp[h][w]: h\u756a\u76ee\u306erow(h: 0~H(\u7d42\u7740))\u3067\u68d2w(w: 0~W-1)\u306b\u3044\u308b\u72b6\u614b\u306b\u306a\u308b\u305f\u3081\u306e\u6a2a\u7dda(0~h)\u306e\u7d44\u5408\u305b\u6570\n    dp[h][w] = A*dp[h-1][w-1] + B*dp[h-1][w] + C*dp[h-1][w+1] o(1000)\n    A, B, C\u306f\u306a\u3093\u304b\u3046\u307e\u3044\u3053\u3068\u6c7a\u3081\u308c\u305d\u3046\u3002(\u5168\u63a2\u7d22\u3067\u3082max7*7*3\u901a\u308a)o(1000) \n    \u3069\u3046\u3084\u3063\u3066\u3082O(10**6)\u306b\u306f\u5165\u308a\u305d\u3046\n    \"\"\"\ndef main():\n    import sys\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    dp = [[0]*W for _ in range(H+1)]\n    dp[0][0] = 1\n    for h in range(1, H+1):\n        for w in range(W):\n            A, B, C = 0, 0, 0\n            for i in range(2 ** (W-1)):\n                lines = []\n                for j in range(W-1):\n                    if ((i >> j) & 1):\n                        if lines and lines[-1]:\n                            break\n                        lines.append(True)\n                    else:\n                        lines.append(False)\n                else:\n                    if w-1 >= 0 and lines[w-1]:\n                        A += 1\n                    elif w <= W-2 and lines[w]:\n                        C += 1\n                    else:\n                        B += 1\n            if w-1 >= 0:\n                dp[h][w] += dp[h-1][w-1] * A\n            dp[h][w] += dp[h-1][w] * B\n            if w+1 <= W-1:\n                dp[h][w] += dp[h-1][w+1] * C\n    print(dp[H][K-1] % (10**9+7))\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "h,w,k=map(int,input().split())\nmod=10**9+7\nR=[[],[1],[1,1],[2,1,2],[3,2,2,3],[5,3,4,3,5],[8,5,6,6,5,8],[13,8,10,9,10,8,13]]\nT=[1,2,3,5,8,13,21,34]\nr=R[w-1]\nt=T[w-1]\nA=[0]*w\nA[0]=1\nif w==1:\n    print(1)\nelse:\n    for i in range(h):\n        C=[0]*w\n        for i in range(w):\n            if i==0:\n                C[0]+=(t-r[0])*A[0]\n                C[1]+=r[0]*A[0]\n            elif i==w-1:\n                C[w-1]+=(t-r[w-2])*A[w-1]\n                C[w-2]+=r[w-2]*A[w-1]\n            else:\n                C[i-1]+=r[i-1]*A[i]\n                C[i]+=(t-r[i-1]-r[i])*A[i]\n                C[i+1]+=r[i]*A[i]\n        for i in range(w):\n            C[i]%=mod\n        A=C\n    print(A[k-1])", "import sys\n\nh, w, k = map(int, input().split())\nMOD = 1000000007\n\ndp = [[0] * w for _ in range(h + 1)]\ndp[0][0] = 1\n\nfn = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nif w == 1:\n    print(1)\n    return\n\nfor i in range(1, h + 1):\n    for j in range(w):\n        dp[i][j] = dp[i - 1][j] * fn[j] * fn[w - j - 1]\n        if j < w - 1:\n            dp[i][j] += dp[i - 1][j + 1] * fn[j] * fn[w - j - 2]\n        if 0 < j:\n            dp[i][j] += dp[i - 1][j - 1] * fn[j - 1] * fn[w - j - 1]\n        dp[i][j] %= MOD\n\nprint(dp[-1][k - 1] % MOD)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#number of amidakuji\n\nh,w,k=list(map(int,input().split()))\n\ndp=[[0 for i in range(w+1)] for i in range(h+1)]\n\n#dp[i][j]=i\u6bb5\u76ee\u307e\u3067\u3067j\u3068\u3044\u3046\u3068\u3053\u308d\u306b\u3044\u304f\u305f\u3081\u306b\u5fc5\u8981\u306a\u65b9\u6cd5\u306e\u7dcf\u548c\n#\u6c42\u3081\u308b\u306e\u306fdp[h][k]\u3067\u3042\u308b\ndp[0][1] = 1\nmod=10**9+7\nif w>1:\n    for i in range(1,h+1):\n        for j in range(2**(w-1)):\n            st=format(j,\"0%ib\"%(w-1))\n            flag=True\n            for _ in range(w-2):\n                if st[_]==\"1\" and st[_+1]==\"1\":\n                    flag=False\n            connect=[False for kyopuro in range(w+1)]\n            if flag:\n                li=[]\n                for ss in range(w-1):\n                    if st[ss]==\"1\":\n                        li.append(ss+1)\n                        connect[ss+1]=True\n                        connect[ss+2]=True\n\n                for some in li:\n                    dp[i][some+1]+=dp[i-1][some]\n                    dp[i][some+1]%=mod\n                    dp[i][some]+=dp[i-1][some+1]\n                    dp[i][some]%=mod\n                for number in range(1,w+1):\n                    if connect[number]==False:\n                        dp[i][number]+=dp[i-1][number]\n                        dp[i][number]%=mod\n    print((dp[h][k]%mod))\n                \n        \nelse:\n    print((1))\n\n\n", "'''Yoshichi\u306e\u65e5\u8a18\n\u3042\u307f\u3060\u304f\u3058\u3002\n0\u672c\u76ee\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3057\u3001W\u672c\u306e\u9577\u3055H + 1\u307e\u3067\u306b\u3092\u4efb\u610f\u306e\u7dda\u3092\u5f15\u3044\u305f\u6642\nK\u672c\u76ee\u306b\u305f\u3069\u308a\u7740\u304f\u30d1\u30bf\u30fc\u30f3\u306f\u4f55\u30d1\u30bf\u30fc\u30f3\u3042\u308b\u304b\u7b54\u3048\u3088\u3002\n\u73fe\u5728\u306e\u4f4d\u7f6e\u72b6\u614b\u3067\u306e\u7dda\u306e\u5f15\u304d\u65b9\u3092\u5168\u5217\u6319\u3057\u3001DP(\u30e1\u30e2\u5316\u518d\u5e30)\u3092\u7528\u3044\u3066\u7b54\u3048\u308b\u3002\nx \u2192 \u73fe\u5728\u306e\u4f4d\u7f6e\ny \u2192 \u73fe\u5728\u306e\u9032\u307f\u5177\u5408\nfor\u5206\u306ei \u2192 \u73fe\u5728\u306e\u4f4d\u7f6e\u306b\u3044\u308b\u6642\u306e\u7dda\u306e\u914d\u7f6e\u72b6\u614b(1\u304c\u96a3\u63a5\u3078\u3064\u306a\u304c\u3063\u3066\u3044\u308b\u3068\u304d)\nfor\u5206\u306ej \u2192 NG\u30d1\u30bf\u30fc\u30f3\u306e\u5217\u6319(\u96a3\u3078\u7e4b\u304c\u3063\u3066\u3044\u308b\u304b\u3064\u3001\n                   \u6b21\u306e\u96a3\u3078\u3082\u7dda\u304c\u5f15\u304b\u308c\u3066\u3044\u308b\u72b6\u614b)\n'''\nfrom collections import defaultdict\nh, w, k = map(int, input().split())\nmemo = defaultdict(lambda:defaultdict(int))\ndef dfs(x, y):\n    if y == h:\n        if x == k - 1:\n            return 1\n        else:\n            return 0\n    if y in memo[x]:\n        return memo[x][y]\n    ans = 0\n    for i in range(1 << w - 1):\n        flg = True\n        for j in range(w - 2):\n            if i & (1 << j) and i & (1 << j + 1):\n                flg = False\n                break\n        if flg:\n            nx = x\n            if x > 0 and i & (1 << x - 1):\n                nx = x - 1\n            elif i & (1 << x):\n                nx = x + 1\n            ans += dfs(nx, y + 1)\n            ans %= 1000000000 + 7\n    memo[x][y] = ans\n    return ans\nprint(dfs(0, 0))", "#\u5b9f\u306fDP\u3068\u5272\u308a\u5207\u308b\u3068\u308f\u304b\u308a\u3084\u3059\u3044\nmod=10**9+7\nh,w,K=map(int,input().split())\ndp=[[0]*w for j in range(h+1)]\ndp[0][0]=1\nfor i in range(1,h+1):\n    for k in range(2**(w-1)):\n        for l in range(w-2):\n            if ((k>>l)&1) and ((k>>(l+1))&1):\n                break\n        else:\n            for l in range(w):\n                if l==0:\n                    if ((k>>l)&1):\n                        dp[i][l+1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n                elif l==w-1:\n                    if ((k>>(l-1))&1):\n                        dp[i][l-1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n                else:\n                    if ((k>>l)&1) or ((k>>(l-1))&1):\n                        if ((k>>l)&1):\n                            dp[i][l+1]+=dp[i-1][l]\n                        else:\n                            dp[i][l-1]+=dp[i-1][l]\n                    else:\n                        dp[i][l]+=dp[i-1][l]\n            dp[i][l]%=mod\nprint(dp[h][K-1]%mod)", "H, W, K = list(map(int, input().split()))\n\nWW = [0]*(W+1)\nWW[0] = 1\nWW[1] = 1\nfor i in range(2, W+1):\n    WW[i] = WW[i-1] + WW[i-2]\nDP = [[0]*W for i in range(H+1)]\nDP[0][0] = 1\nmod = 10**9+7\nfor i in range(1, H+1):\n    for j in range(W):\n        if j == 0:\n            DP[i][j] = DP[i-1][j]*WW[W-1]\n            if W > 1:\n                DP[i][j] += DP[i-1][j+1]*WW[W-2]\n        elif j == W-1:\n            DP[i][j] = DP[i-1][j]*WW[W-1]\n            if W > 1:\n                DP[i][j] += DP[i-1][j-1]*WW[W-2]\n        else:\n            DP[i][j] = DP[i-1][j]*WW[j]*WW[W-1-j]+DP[i-1][j-1] * \\\n                WW[j-1]*WW[W-1-j]+DP[i-1][j+1]*WW[j]*WW[W-2-j]\n\n        DP[i][j] %= mod\n# print(DP, WW)\nprint((DP[-1][K-1]))\n", "import sys\nfrom itertools import product\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    H, W, K = list(map(int, readline().split()))\n\n    A = product((0, 1), repeat=W - 1)\n    B = []\n    for bars in A:\n        ok = True\n        for i in range(W - 2):\n            if bars[i] and bars[i + 1]:\n                ok = False\n                break\n        if ok:\n            B.append(bars)\n\n    dp = [0] * W\n    dp[0] = 1\n\n    for _ in range(H):\n        dp, dp_prev = [0] * W, dp\n        for bars in B:\n            for i in range(W):\n                if i > 0 and bars[i - 1]:\n                    dp[i - 1] = (dp[i - 1] + dp_prev[i]) % MOD\n                elif i < W - 1 and bars[i]:\n                    dp[i + 1] = (dp[i + 1] + dp_prev[i]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp_prev[i]) % MOD\n\n    print((dp[K - 1]))\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,w,K=map(int,input().split())\nmod=10**9+7\ndp=[[0 for i in range(w)] for j in range(h+1)]\nfor i in range(2**(w-1)):dp[0][0]=1\nfor i in range(1,h+1):\n    for j in range(2**(w-1)):\n        s=format(j,\"b\").zfill(w-1)\n        if \"11\" in s:continue\n        exchanged=[False]*w\n        for k in range(w-1):\n            if s[k]==\"1\":\n                dp[i][k]+=dp[i-1][k+1]\n                dp[i][k+1]+=dp[i-1][k]\n                dp[i][k]%=mod\n                dp[i][k+1]%=mod\n                exchanged[k]=True\n                exchanged[k+1]=True\n        for k in range(w):\n            if exchanged[k]:continue\n            dp[i][k]+=dp[i-1][k]\n            dp[i][k]%=mod\n\nprint(dp[-1][K-1])", "# |-| | | | |\n# \u306e\u3088\u3046\u306b\u4e00\u756a\u5de6\u306e\u4e00\u672c\u304c\u6c7a\u307e\u3063\u305f\u3068\u304d\u3001\u6b8b\u308a\u306e\n#     | | | |\n# \u306b\u306f\u3001\u7dda\u3092\u5f15\u304f\u5834\u6240\u304c3\u3064\u3042\u308b\n# \u7dda\u3092\u5f15\u304f\u5834\u6240\u304cN\u500b\u3042\u308b\u3068\u304d\u306e\u7dda\u306e\u5f15\u304d\u65b9\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\n# A[1] = 2, A[2] = 3, A[N] = A[N - 2] + A[N - 1]\n# \u306e\u307b\u307c\u30d5\u30a3\u30dc\u30ca\u30c3\u30c1\u6570\u5217\n# 2,3,5,8,13...\n# \u3053\u308c\u3092\u3042\u3089\u304b\u3058\u3081\u6700\u5927\u6570\u3076\u3093\u6c42\u3081\u3066\u304a\u304f\n# \u6a2a\u68d2W\u672c\u306b\u5bfe\u3057\u3066\u3001W - 1\u500b\u306e\u9593\u9694\u304c\u3042\u308a\u3001\u305d\u306e\u3046\u3061\u7aef\u306e2\u304b\u6240\u304c\u57cb\u307e\u3063\u305f\u72b6\u614b\u304c\u6700\u5927\u306a\u306e\u3067W - 3\n# \u3053\u308c\u3092\u6c42\u3081\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nDIV = 10 ** 9 + 7\nH,W,K = map(int,readline().split())\n\nP = [0] * max(W - 2 + 1,3)\nP[1],P[2] = 2,3\nfor i in range(3, len(P)):\n  P[i] = P[i - 1] + P[i - 2]\n  \n# [0, 2, 3, 5, 8, 13, 21, 34, ...]\n\n# \u901a\u3089\u306a\u3044\u7dda\u306f\u4e0a\u8a18\u3067\u7b97\u51fa\u3067\u304d\u308b\u306e\u3067\u3001\u901a\u308b\u7dda\u3092\u8003\u3048\u308b\n# \u4e0a\u304b\u3089i\u6bb5\u76ee\u307e\u3067\u7d42\u3048\u305f\u6642\u70b9\u3067\u3001\u7e26\u68d2j\u306b\u3044\u308b\u3068\u304d\u306e\u5834\u5408\u306e\u6570\u3067DP\u3059\u308b\n\ndp = [[0 for j in range(W)] for i in range(H + 1)]\n\ndp[0][0] = 1 # \u4e0a\u304b\u30890\u6bb5\u76ee\u3092\u7d42\u3048\u305f\u6642\u70b9(\u307e\u3060\u4f55\u3082\u3057\u3066\u3044\u306a\u3044)\u3068\u304d\u306b0\u306b\u3044\u308b\u306e\u30671\u901a\u308a\n\ndef calc(L,R): # L\u3068R\u306e\u9593\u306b\u7dda\u3092\u5f15\u3044\u305f\u5834\u5408\u306e\u3001\u6b8b\u308a\u306e\u7dda\u306e\u5f15\u304d\u65b9\n#  print(\"calc L\",L,\"R\",R)\n  res = 1\n  if 1 < L:\n    # | | |-| L\u304c2\u306e\u3068\u304d\u306f\u3058\u3081\u3066\u30b9\u30da\u30fc\u30b9\u304c1 (L - 1)\u3067\u304d\u308b\n    res *= P[L - 1]\n#    print(\"P[L - 2]\",P[L - 2],\"res\",res)\n    res %= DIV\n  if (W - 1) - (R + 1) >= 1:\n    # |-| | | R + 2 = W - 1\u306e\u3068\u304d\u306f\u3058\u3081\u3066\u30b9\u30da\u30fc\u30b9\u304c1(W - R)\u3067\u304d\u308b\n#    print(min((W - 1) - (R + 1),len(P)))\n    res *= P[(W - 1) - (R + 1)]\n#    print(\"P[(W - 1) - (R + 1)]\",min((W - 1) - (R + 1),len(P)),\"res\",res)\n    res %= DIV\n#  print(res,\"\u901a\u308a\")\n  return res\n  \n# \u53f3\u306b\u79fb\u52d5\u3059\u308b\u3001\u5de6\u306b\u79fb\u52d5\u3059\u308b\u3001\u4f55\u3082\u3057\u306a\u3044\u3001\u306e3\u901a\u308a\u3067DP\nfor i in range(H):\n  for j in range(W):\n    # \u53f3\u306b\u79fb\u52d5\u3059\u308b\n    if j + 1 < W:\n#      print(\"i\",i,\"j\",j,\"\u304b\u3089i + 1\",i + 1,\"j + 1\",j + 1,\"\u306b\u79fb\u52d5\u3059\u308b dp[i][j]\",dp[i][j],\"dp[i + 1][j + 1]\",dp[i + 1][j + 1])\n      dp[i + 1][j + 1] += dp[i][j] * calc(j, j + 1)\n      dp[i + 1][j + 1] %= DIV\n#      print(\"i\",i,\"j\",j,\"\u304b\u3089i + 1\",i + 1,\"j + 1\",j + 1,\"\u306b\u79fb\u52d5\u3057\u305f dp[i][j]\",dp[i][j],\"dp[i + 1][j + 1]\",dp[i + 1][j + 1])\n    # \u5de6\u306b\u79fb\u52d5\u3059\u308b\n    if j - 1 >= 0:\n#      print(\"i\",i,\"j\",j,\"\u304b\u3089i + 1\",i + 1,\"j - 1\",j - 1,\"\u306b\u79fb\u52d5\u3059\u308b dp[i][j]\",dp[i][j],\"dp[i + 1][j - 1]\",dp[i + 1][j - 1])\n      dp[i + 1][j - 1] += dp[i][j] * calc(j - 1,j)\n      dp[i + 1][j - 1] %= DIV\n#      print(\"i\",i,\"j\",j,\"\u304b\u3089i + 1\",i + 1,\"j - 1\",j - 1,\"\u306b\u79fb\u52d5\u3057\u305f dp[i][j]\",dp[i][j],\"dp[i + 1][j - 1]\",dp[i + 1][j - 1])\n    # \u4f55\u3082\u3057\u306a\u3044\n#    print(\"i\",i,\"j\",j,\"\u304b\u3089i\",i,\"j\",j,\"\u306b\u79fb\u52d5\u3059\u308b dp[i][j]\",dp[i][j],\"dp[i + 1][j]\",dp[i + 1][j])\n    dp[i + 1][j] += dp[i][j] * calc(j,j) # \u5de6\u7aef\u3082\u53f3\u7aef\u3082\u540c\u3058\n    dp[i + 1][j] % DIV\n#    print(\"i\",i,\"j\",j,\"\u304b\u3089i\",i,\"j\",j,\"\u306b\u79fb\u52d5\u3057\u305f dp[i][j]\",dp[i][j],\"dp[i + 1][j]\",dp[i + 1][j])\n#  for d in dp:\n#    print(dp)\n\n    \n# i = H\u6bb5\u76ee\u307e\u3067\u7d42\u3048\u305f\u6642\u70b9\u3067\u3001j = K - 1\u306b\u3044\u308b\u5834\u5408\u306e\u6570\nprint(dp[H][K - 1] % DIV)", "def main():\n    mod = 10**9 + 7\n    h, w, k = map(int, input().split())\n\n    if w == 1:\n        print(1)\n        return\n    if w == 2:\n        print(pow(2, h-1, mod))\n        return\n\n    k -= 1\n\n    fibo = [1, 2, 3, 5, 8, 13, 21]\n\n    dp = [0] * w\n    dp[0] = 1\n    for _ in range(h):\n        new_dp = [0] * w\n        new_dp[0] = (dp[0] * fibo[w-2] + dp[1] * fibo[w-3]) % mod\n        new_dp[1] = (dp[0] * fibo[w-3]) % mod\n        new_dp[w-1] = (dp[w-1] * fibo[w-2] + dp[w-2] * fibo[w-3]) % mod\n        new_dp[w-2] += (dp[w-1] * fibo[w-3]) % mod\n        for i in range(1, w-1):\n            new_dp[i] += ((fibo[i-1] * fibo[w-i-2]) * dp[i]) % mod\n        for i in range(1, w-2):\n            new_dp[i] += (fibo[i-1] * fibo[w-i-3]) * dp[i+1]\n            new_dp[i] %= mod\n            new_dp[i+1] += (fibo[i-1] * fibo[w-i-3]) * dp[i]\n            new_dp[i+1] %= mod\n        dp = new_dp\n\n    print(dp[k] % mod)\n\nmain()", "#!/usr/bin/env python3\nfrom itertools import product\nimport sys\n\ntry:\n    from typing import List, Tuple\nexcept ImportError:\n    pass\n\n\nMOD = 1000000007  # type: int\n\n\ndef isvalid(ptn: \"Tuple[bool]\"):\n    return not any(h1 and h2 for h1, h2 in zip(ptn, ptn[1:]))\n\n\ndef solve(H: int, W: int, K: int):\n    validptns = [\n        ptn\n        for ptn in product((False, True), repeat=W - 1)\n        if isvalid(ptn)\n    ]  # type: List[Tuple[bool]]\n    dp = [1 if i == K - 1 else 0 for i in range(W)]  # type: List[int]\n    for _ in range(H):\n        newdp = [0] * W  # type: List[int]\n        for ptn in validptns:\n            for s in range(W):\n                t = s\n                if s < W - 1 and ptn[s]:\n                    t = s + 1\n                elif s > 0 and ptn[s - 1]:\n                    t = s - 1\n                newdp[t] += dp[s]\n                newdp[t] %= MOD\n        dp = newdp\n\n    print((dp[0]))\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    H = int(next(tokens))  # type: int\n    W = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    solve(H, W, K)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h, w, k = list(map(int, input().split()))\np = 10**9+7\n# DP[i][j]=i\u6bb5\u76ee\u307e\u3067\u898b\u30660\u304b\u3089j\u306b\u7740\u304f\u30d1\u30bf\u30fc\u30f3\u6570\nDP = [[0 for j in range(w+1)] for i in range(h+1)]\nDP[0][0] = 1\n# F[k]=k\u500b\u306e\u67a0\u306b\u96a3\u308a\u5408\u308f\u306a\u3044\u3088\u3046\u306b\u7dda\u3092\u5f15\u304f\u30d1\u30bf\u30fc\u30f3\u306e\u6570\nF = [1, 1, 2, 3, 5, 8, 13, 21]\nfor i in range(h):\n    for j in range(w):\n        a = DP[i][j-1]*F[j-1]*F[w-1-j]\n        b = DP[i][j]*F[j]*F[w-1-j]\n        c = DP[i][j+1]*F[j]*F[w-2-j]\n        DP[i+1][j] = (a+b+c) % p\nprint((DP[h][k-1]))\n", "def f(i):\n  if i == W-1:\n    for j in range(W-2):\n      if s[j] == s[j+1] == 1:\n        return\n    nonlocal x\n    for j in range(W):\n      if j == 0:\n        if s[0] == 1:\n          x[0][1] += 1\n        else:\n          x[0][0] += 1\n      elif j == W - 1:\n        if s[W-2] == 1:\n          x[W-1][W-2] += 1\n        else:\n          x[W-1][W-1] += 1\n      else:\n        if s[j-1] == 1:\n          x[j][j-1] += 1\n        elif s[j] == 1:\n          x[j][j+1] += 1\n        else:\n          x[j][j] += 1 \n    return\n  s[i] = 1\n  f(i + 1)\n  s[i] = 0\n  f(i + 1)\n\nH,W,K=map(int, input().split())\nMOD = pow(10, 9) + 7\ns = [0] * (W - 1)\nx = [[0] * W for _ in range(W)]\nif not W == 1:\n  f(0)\nelse:\n  print(1)\n  return\ndp = [[0] * W for _ in range(H+1)]\ndp[0][0] = 1\nfor i in range(1,H+1):\n  for j in range(W):\n    for l in range(W):\n      dp[i][j]+=dp[i-1][l]*x[l][j]\n      dp[i][j]%=MOD\nprint(dp[H][K-1])", "import sys\ninput=sys.stdin.readline\nINF = 10**9\nMOD = 10**9 + 7\n\ndef main():\n    h,w,k = list(map(int,input().split()))\n\n    dp = [[0]*w for _ in range(h+1)]\n    dp[0][0] = 1\n\n    for i in range(h):\n        for bit in range(1<<(w-1)):\n            flag = False\n            before = -2\n            line = [0] * (w-1)\n            for j in range(w-1):\n                if (bit>>j)&1:\n                    if  before + 1 == j:\n                        flag = True\n                        break\n                    \n                    else:\n                        before = j\n                        line[j] = 1\n  \n\n            if flag:\n                continue\n\n            j = 0\n            while j < w:\n                if j == w-1:\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\n                    break\n                if line[j]:\n                    dp[i+1][j] += dp[i][j+1]\n                    dp[i+1][j] %= MOD\n                    dp[i+1][j+1] += dp[i][j]\n                    dp[i+1][j+1] %= MOD\n                    j += 2\n                else:\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\n                    j += 1\n\n    print((dp[-1][k-1]%MOD))\ndef __starting_point():\n    main()\n\n__starting_point()", "H,W,K = list(map(int,input().split()))\nMOD = 10**9+7\n\ndp = [[0]*W for _ in range(H+1)]\ndp[0][0] = 1\nfor i in range(H):\n    for b in range(1<<(W-1)):\n        if '11' in bin(b): continue\n        for k in range(W):\n            if k and b&(1<<(k-1)):\n                dp[i+1][k-1] += dp[i][k]\n            elif b&(1<<k):\n                dp[i+1][k+1] += dp[i][k]\n            else:\n                dp[i+1][k] += dp[i][k]\n\nprint((dp[-1][K-1] % MOD))\n", "#!/usr/bin/env python3\n\nimport itertools\nmod = 1000000007\n\nh, w, k = list(map(int, input().split()))\n\ndp = [[0]*(w) for _ in range(h+1)]\n\ndp[0][0] = 1\n\nfor h_ in range(1, h+1):\n    for bridges in itertools.product([0, 1], repeat=w-1):\n        flag = 0\n        for j in range(len(bridges)-1):\n            if bridges[j] == 1 and bridges[j+1] == 1:\n                flag = 1\n                continue\n        if flag == 1:\n            continue\n        # print(bridges)\n        for w_ in range(w):\n            if w_ > 0:\n                if bridges[w_-1] == 1:\n                    dp[h_][w_] += dp[h_-1][w_-1] % mod\n                    continue\n            if w_ < w-1:\n                if bridges[w_] == 1:\n                    dp[h_][w_] += dp[h_-1][w_+1] % mod\n                    continue\n            dp[h_][w_] += dp[h_-1][w_] % mod\n\n# print(dp)\n\nprint((dp[-1][k-1] % mod))\n", "h,w,k=map(int,input().split())\nf=[1,1,2,3,5,8,13,21]\nm=10**9+7\ndp=[[1]+[0]*(w-1)for i in range(h+1)]\nh=0if w==1else h\nfor i in range(1,h+1):\n for j in range(w):\n  if j==0:dp[i][0]=(dp[i-1][0]*f[w-1] + dp[i-1][1]*f[w-2])%m;\n  elif j==w-1:dp[i][w-1]=(dp[i-1][w-1]*f[w-1] + dp[i-1][w-2]*f[w-2])%m\n  else:dp[i][j]=(dp[i-1][j]*f[j]*f[w-j-1]+dp[i-1][j-1]*f[j-1]*f[w-j-1]+dp[i-1][j+1]*f[j]*f[w-j-2])%m\nprint(dp[h][k-1])", "H, W, K = list(map(int, input().split()))\n\nmod = 10**9 + 7\ndp = [[0] * W for _ in range(H+1)]\ndp[0][0] = 1\nfor i in range(H):\n    for j in range(W):\n        for bit in range(1 << (W-1)):\n            ok = True\n            for k in range(W-2):\n                if bit & (1 << k) and bit & (1 << (k+1)):\n                    ok = False\n            if not ok:\n                continue\n\n            jj = j\n            if j > 0 and bit & (1 << (j-1)):\n                jj -= 1\n            elif j < W - 1 and bit & (1 << j):\n                jj += 1\n            dp[i+1][jj] += dp[i][j]\n            dp[i+1][jj] %= mod\n\n\nprint((dp[H][K-1]))\n", "def main():\n    h, w, k = list(map(int, input().split()))\n\n    dp = [[0] * (w + 2) for _ in range(h + 1)]\n    dp[0][1] = 1\n\n    c = [1, 1, 2, 3, 5, 8, 13, 21]\n\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            dp[i][j] = c[j - 1] * c[w - j] * dp[i - 1][j] + c[j - 1] * c[w - j - 1] * dp[i - 1][j + 1] + c[j - 2] * c[w - j] * dp[i - 1][j - 1]\n\n    print((dp[h][k] % (10 ** 9 + 7)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def f(i):\n    if i == w - 1:\n        for j in range(w - 2):\n            if s[j] == s[j + 1] == 1:\n                return\n        nonlocal x\n        for j in range(w):\n            if j == 0:\n                if s[0] == 1:\n                    x[0][1] += 1\n                else:\n                    x[0][0] += 1\n            elif j == w - 1:\n                if s[w - 2] == 1:\n                    x[w - 1][w - 2] += 1\n                else:\n                    x[w - 1][w - 1] += 1\n            else:\n                if s[j - 1] == 1:\n                    x[j][j - 1] += 1\n                elif s[j] == 1:\n                    x[j][j + 1] += 1\n                else:\n                    x[j][j] += 1 \n        return\n    s[i] = 1\n    f(i + 1)\n    s[i] = 0\n    f(i + 1)\n\nh, w, k = map(int, input().split())\nmod = pow(10, 9) + 7\ns = [0] * (w - 1)\nx = [[0] * w for _ in range(w)]\nif not w == 1:\n    f(0)\nelse:\n    print(1)\n    return\ndp = [[0] * w for _ in range(h + 1)]\ndp[0][0] = 1\nfor i in range(1, h + 1):\n    for j in range(w):\n        for l in range(w):\n            dp[i][j] += dp[i - 1][l] * x[l][j]\n            dp[i][j] %= mod\nprint(dp[h][k - 1])"]
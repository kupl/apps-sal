["ii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(mi())\nfrom bisect import bisect_left as lb, bisect_right as ub\n\nn, k, A, B = mi()\na = li()\na.sort()\n\ndef f(l, r):\n    cnt = ub(a, r) - lb(a, l)\n    if cnt == 0:\n        return A\n    if l == r:\n        return B * cnt\n    m = (l + r) >> 1\n    return min(B * cnt * (r - l + 1), f(l, m) + f(m + 1, r))\n\nprint(f(1, 2 ** n))\n", "from bisect import bisect_left\nimport sys\nsys.setrecursionlimit(10**6)\nN, K, A, B = map(int, input().split())\nk = sorted(map(int, input().split()))\nbase_length = 2**N\n\ndef hoge(l, r):\n    avengers = bisect_left(k, r) - bisect_left(k, l)\n    size = r-l\n    power = A if not avengers else B*avengers*size\n    if not avengers or r-l == 1:\n        return power\n    else:\n        mid = (r+l)//2\n        return min(power, hoge(l, mid)+hoge(mid, r))\n\n\nprint(hoge(1, base_length+1))", "# -*- coding: utf-8 -*-\n# @Time    : 2019/2/4 0:20\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Creative Snap.py\n\n\ndef main():\n    n, k, a, b = list(map(int, input().split()))\n    pos = list(map(int, input().split()))\n    pos.sort()\n\n    def search(interval_left, interval_right, index_left, index_right):\n        if interval_left == interval_right:\n            if index_left > index_right:\n                # print('Interval:', interval_left, interval_right)\n                # print('ANS:', a)\n                return a\n            else:\n                # print('Interval:', interval_left, interval_right)\n                # print('ANS:', b * (index_right - index_left + 1))\n                return b * (index_right - index_left + 1)\n        if index_left > index_right:\n            return a\n\n        interval_mid = interval_left + (interval_right - interval_left) // 2\n        # print('MID:', interval_mid)\n        left, right = index_left, index_right\n        index_mid = left - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if pos[mid] <= interval_mid:\n                index_mid = mid\n                left = left + 1\n            else:\n                right = right - 1\n\n        t0 = b * (index_right - index_left + 1) * (interval_right - interval_left + 1)\n        t1 = search(interval_left, interval_mid, index_left, index_mid)\n        t2 = search(interval_mid + 1, interval_right, index_mid + 1, index_right)\n        ans = min(t0, t1 + t2)\n        # print('Interval:', interval_left, interval_right)\n        # print('ANS', ans)\n        return min(t0, t1 + t2)\n\n    ret = search(1, 1 << n, 0, k - 1)\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport bisect\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nn,k,A,B=list(map(int,input().split()))\nK=list(map(int,input().split()))\n\nK.sort()\n\ndef points(l,r):#[l,r)\n    if r==l+1:\n        x=bisect.bisect_left(K,r)-bisect.bisect_left(K,l)\n        if x!=0:\n            return B*x\n        else:\n            return A\n\n    mid=(l+r)//2\n\n    x=bisect.bisect_left(K,mid)-bisect.bisect_left(K,l)\n    y=bisect.bisect_left(K,r)-bisect.bisect_left(K,mid)\n\n    #print(l,r,x,y)\n\n    if x==0 and y==0:\n        return A\n    elif x!=0 and y!=0:\n        return points(l,mid)+points(mid,r)\n    elif y==0:\n        return min(A+points(l,mid),B*(x+y)*(r-l))\n    elif x==0:\n        return min(A+points(mid,r),B*(x+y)*(r-l))\n\n\nprint(points(1,2**n+1))\n\n    \n        \n    \n    \n", "import bisect\n\nn, k, A, B = [int(x) for x in input().split()]\na_is = [int(x) - 1 for x in input().split()]\n\na_is.sort()\n\ndef how_many(i, j):\n    count = bisect.bisect_left(a_is, j) - bisect.bisect_left(a_is, i)\n    # print('i, j, count', i, j, count)\n    return count\n\n\ndef get_cost(i, j):\n    count = how_many(i, j)\n    if count == 0:\n        return A\n    elif i + 1 == j:\n        return B * count\n    else:\n        div = (j - i) // 2\n        default = B * count * (j - i)\n        left = get_cost(i, i + div)\n        if left > default:\n            return default\n\n        right = get_cost(i + div, j)\n\n        if left + right > default:\n            return default\n        else:\n            return left + right\n\n\nprint(get_cost(0, 2**n))\n", "def explosion(a, x, y, q, l, r):\n    if r - l == 1:\n        q1 = q\n        while q1 < len(a) and a[q1] < r:\n            q1 += 1\n        if q1 == q:\n            return x\n        else:\n            return (q1-q)*y\n    q1 = q\n    while q1 < len(a) and a[q1] < (l+r)//2:\n        q1 += 1\n    q2 = q1\n    while q2 < len(a) and a[q2] < r:\n        q2 += 1\n    if q1-q == 0 and q2-q1 == 0:\n        return x\n    if q2-q1 != 0 and q1-q != 0:\n        d1, d2, d = explosion(a, x, y, q, l, (l+r)//2), explosion(a, x, y, q1, (l+r)//2, r), (q2-q)*(r-l)*y\n        if d1+d2 < d:\n            return d1+d2\n        else:\n            return d\n    if q1 != q:\n        d, d1 = explosion(a, x, y, q, l, (l+r)//2), (r-l)*(q1-q)*y\n        if x+d < d1:\n            return x+d\n        else:\n            return d1\n    else:\n        d, d1 = explosion(a, x, y, q1, (l+r)//2, r), (r-l)*(q2-q1)*y\n        if x+d < d1:\n            return x+d\n        else:\n            return d1\n\n\nn, k, x, y = list(map(int, input().split()))\na = sorted(list([int(x)-1 for x in input().split()]))\nprint(explosion(a, x, y, 0, 0, 2**n))\n", "import bisect\n\n# Turn list(str) into list(int)\ndef getIntList(lst):\n    assert type(lst) is list\n    rep = []\n    for i in lst:rep.append(int(i))\n    return rep\n\nn,k,A,B = getIntList(input().split())\npos = getIntList(input().split())\n\n\ndef calc(l,r,heros):\n    assert type(heros) is list\n    if len(heros) == 0: return A\n    if r-l == 0: return B*len(heros)\n    mid = bisect.bisect_right(heros,(l+r)//2) \n    tans = min(\n        calc(l,(l+r)//2,heros[:mid])+calc((l+r)//2+1,r,heros[mid:]),\n        B*len(heros)*(r-l+1)\n    )\n    return tans\n\npos.sort()\nans = calc(1,2**n,pos)\nprint(ans)", "from bisect import bisect_left as lb, bisect_right as ub\n\nn, k, A, B = map(int, input().split(' '))\na = sorted(map(int, input().split(' ')))\n\ndef heihei(l, r):\n    cnt = ub(a, r) - lb(a, l)\n    if cnt == 0:\n        return A\n    \n    if l == r:\n        return A if cnt == 0 else B * cnt\n    \n    mid = (l + r) >> 1\n    lr, rr = heihei(l, mid), heihei(mid + 1, r)\n\n    return min(B * cnt * (r - l + 1), lr + rr)\n\n\nprint(heihei(1, 2 ** n))", "def get(tl, tr, a):\n\tnonlocal A, B\n\tif len(a) == 0:\n\t\treturn A\n\tif tl == tr:\n\t\treturn len(a) * B\n\ttm = (tl + tr) // 2\n\tc, d = [], []\n\tfor x in a:\n\t\tif x <= tm:\n\t\t\tc += [x]\n\t\telse:\n\t\t\td += [x]\n\treturn min(B * len(a) * (tr - tl + 1), get(tl, tm, c) + get(tm + 1, tr, d))\n\nn, k, A, B = map(int, input().split())\na = list(sorted(list(map(int, input().split()))))\nprint(get(1, 1 << n, a))", "from collections import defaultdict as dd\nimport math\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\nn, k, A, B=mi()\n\navg=lm()\n\n#adic=[dd(int) for i in range(n)]\n\n\n\n#for j in avg:\n\t\n\t\n#\tfor i in range(n):\n#\t\tplace=math.ceil(j/(2**(n-i-1)))\n#\t\t\n#\t\tadic[i][place]+=1\n#\n\t\t\n#print(adic)\n\n\n\ndef divide(startbin, endbin, level, currentas, currentlength):\n\t#print(currentas,level)\n\tif currentlength==0:\n\t\treturn A\n\t\n\n\tastart=[]\n\taend=[]\n\tmidpoint=startbin*2**(n-level)\n\tfor a in currentas:\n\t\tif a<=midpoint:\n\t\t\tastart.append(a)\n\t\telse:\n\t\t\taend.append(a)\n\t\n\tbinlength=2**(n-level)\n\t#dicheight=level-1\n\t#a1=adic[dicheight][startbin]\n\t#a2=adic[dicheight][endbin]\n\t#print(astart,aend)\n\t\n\n\t #a1+a2==0:\n\t #\treturn A\n\t\n\ta1=len(astart)\n\ta2=len(aend)\n\t\n\tcost1=(a1+a2)*B*(binlength*2)\n\n\t#if cost1<=A:\n\t#\treturn cost1\n\n\n\tif level==n:\n\t\tif a1==0:\n\t\t\tsubcost1=A\n\t\telse:\n\t\t\tsubcost1=B*a1\n\t\tif a2==0:\n\t\t\tsubcost2=A\n\t\telse:\n\t\t\tsubcost2=B*a2\n\t\tcost2=subcost1+subcost2\n\telse:\n\t\tcost2=divide(startbin*2-1,startbin*2, level+1,astart, a1)+divide(endbin*2-1, endbin*2,level+1,aend, a2)\n\t\t\n\treturn min(cost1,cost2)\n\n\nprint(divide(1,2,1,avg, k))\n\n", "def ans(arr,l,r,a,b):\n    if len(arr) == 0:\n        return a\n    if l == r:\n        return len(arr)*b\n    arr_left = []\n    arr_right = []\n    mid = (l+r)//2\n    for el in arr:\n        if l <= el <= mid:\n            arr_left+=[el]\n        if mid+1 <= el <= r:\n            arr_right+=[el]\n    return min(b*len(arr)*(r-l+1),ans(arr_left, l,mid,a,b) + ans(arr_right,mid+1,r,a,b))\n\nn,k,a,b = list(map(int,input().split()))\narr = [int(i)-1 for i in input().split()]\n\nprint(ans(arr,0,(1<<n)-1,a,b))\n", "from bisect import bisect_left, bisect_right\n\nn, k, a, b = [int(x) for x in input().split()]\npos = [int(x) for x in input().split()]\nna = {}\nv  = {}\nfor i in pos:\n    na[i] = na.get(i, 0) + 1\n    v[i]  = b * na[i]\nl = 2\nt = 2\nwhile t <= n + 1:\n    xna = {}\n    for i in na:\n        j = (i + 1) // 2\n        xna[j] = xna.get(j, 0) + na[i]\n    na = xna\n    xv = {}\n    for i in na:\n        j = i * 2\n        xv[i] = min(b * na[i] * l, v.get(j-1, a) + v.get(j, a))\n    v = xv\n    l *= 2\n    t += 1\nprint(v[1])", "n, k, A, B = list(map(int, input().split()))\n\n\ndef solve(l, r, a):\n    # print(l, r, a)\n    if (len(a) == 0): return A\n    if (l == r): return B * len(a)\n    mid = (l + r) // 2\n    lx = []\n    rx = []\n    for i in a:\n        if (i <= mid):\n            lx.append(i)\n        else:\n            rx.append(i)\n    return min(B * len(a) * (r - l + 1), solve(l, mid, lx) + solve(mid + 1, r, rx))\n\n\na = list(map(int, input().split()))\nprint(solve(1, 1 << n, a))\n", "def inint():\n    return int(input())\ndef mp():\n    return list(map(int,input().split()))\nfrom bisect import bisect,bisect_left\n    \ndef sol(i,j):\n    works=bisect(a,j)-bisect_left(a,i)\n    if works==0:return A\n    if i==j:return B*works\n    m=(i+j)>>1\n    return min(B*(j-i+1)*works,sol(i,m)+sol(m+1,j))    \n    \nn,k,A,B=mp()\na=list(mp())\na.sort()\n#print(a)\nprint(sol(1,2**n))\n", "(n,k,a,b)=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl.sort()\ndef se(st,en):\n\tnonlocal l\n\tc=0\n\tlo=0\n\thi=len(l)-1\n\twhile lo<=hi:\n\t\tmid=(lo+hi)//2\n\t\tif l[mid]<=en:\n\t\t\tlo=mid+1\n\n\t\telse:\n\t\t\thi=mid-1\n\n\tc+=hi\n\tlo=0\n\thi=len(l)-1\n\twhile lo<=hi:\n\t\tmid=(lo+hi)//2\n\t\tif l[mid]>=st:\n\t\t\thi=mid-1\n\n\t\telse:\n\t\t\tlo=mid+1\n\n\treturn c-lo+1\n\n\n\n\n\ndef f(st,en):\n\t#print(st,en)\n\t\"\"\"\n\tif c>20:\n\t\treturn 0\n\n\telse:\n\t\tc+=1\"\"\"\n\t\n\tnonlocal n,a,b\n\tt=se(st,en)\n\t#print(st,en,t)\n\tif st==en:\n\t\tif t==0:\n\t\t\t#print(\"A:\",a,st,en)\n\t\t\treturn a\n\n\t\telse:\n\t\t\t#print(\"B:\",b*t*1,st,en)\n\t\t\treturn b*t*1\n\n\telse:\n\t\tle=(en-st+1)\n\t\tif t==0:\n\t\t\t#print(\"A:\",a,st,en)\n\t\t\treturn a\n\n\t\telse:\n\t\t\treturn min(b*t*le,f(st,st+le//2-1)+f(st+le//2,en))\n\t\t\t#print(\"J\",j,st,en)\n\t\t\t#return j\n\n\nprint(f(1,2**n))\n#print(se(l,3,4))\n", "def get(tl, tr, a):\n\tnonlocal A, B\n\tif len(a) == 0:\n\t\treturn A\n\tif tl == tr:\n\t\treturn len(a) * B\n\ttm = (tl + tr) // 2\n\tc, d = [], []\n\tfor x in a:\n\t\tif x <= tm:\n\t\t\tc += [x]\n\t\telse:\n\t\t\td += [x]\n\treturn min(B * len(a) * (tr - tl + 1), get(tl, tm, c) + get(tm + 1, tr, d))\n\nn, k, A, B = map(int, input().split())\na = list(sorted(list(map(int, input().split()))))\nprint(get(1, 1 << n, a))", "n, k, A, B = list(map(int, input().split()))\nn = 2 ** n\na = list(sorted(list(map(int, input().split()))))\n\ndef recurs(start, end, array):\n\tif len(array) == 0: \n\t\treturn A\n\tif end - start == 1:\n\t\treturn B*len(array)\n\n\tmiddle = (start + end)//2\n\tc, d = [], []\n\tfor x in array:\n\t\tif x < middle:\n\t\t\tc += [x]\n\t\telse:\n\t\t\td += [x] \n\treturn  min(B*len(array)*(end - start), recurs(start, middle, c) + recurs(middle, end, d))\n\nprint(recurs(1, n + 1, a))\n\n# import numpy as np\n\n# print('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0439:')\n# n = int(input())\n# print('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u0438\u043d\u0435\u0439\u043d\u044b\u0435 \u043a\u043e\u044d\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b:')\n# a = np.array([list(float(t) for t in input().split()) for i in range(n)])\n\n# print(a.shape)\n", "n, k, A, B = list(map(int, input().split()))\nn = 2 ** n\na = sorted(list(map(int, input().split())))\n\ndef recurs(start, end, sum_all, array):\n\tif sum_all == 0: \n\t\treturn A\n\telse:\n\t\tenergy = B*(end - start)*sum_all\n\n\tif end - start == 1:\n\t\treturn energy\n\tc, d = [], []\n\tfor x in array:\n\t\tif x < ((start + end)//2):\n\t\t\tc += [x]\n\t\telse:\n\t\t\td += [x]\n\tfirst = len(c)\n\tsecond = sum_all - first\n\ttmp = recurs(start, (start + end)//2, first, c) \n\ttmp += recurs((start + end)//2, end, second, d)\n\treturn  (energy < tmp) * energy + (1 - (energy < tmp))*tmp\n\nprint(recurs(1, n + 1, k, a))\n\n# import numpy as np\n\n# print('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0439:')\n# n = int(input())\n# print('\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043b\u0438\u043d\u0435\u0439\u043d\u044b\u0435 \u043a\u043e\u044d\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b:')\n# a = np.array([list(float(t) for t in input().split()) for i in range(n)])\n\n# print(a.shape)\n", "from collections import Counter\nfrom functools import reduce\n\nn, k, A, B = list(map(int, input().split()))\n\npositions = sorted(list([int(s)-1 for s in input().split()]))\n\nd_h_counts = Counter(positions)\nh_indices = d_h_counts\n\nfor ind in h_indices:\n    h_indices[ind] = (B * h_indices[ind], h_indices[ind])\n\n\nind_filled = sorted(h_indices)\n\ndef reduce(ind_filled, d_values, ll):\n    \"\"\"\n    Merge adjacent non-empty blocks and compute the indices of the new non-empty blocks\n    :param d_values:\n    :return:\n    \"\"\"\n\n    index = 0\n    d_res = {}\n    out_ind = []\n    while index < len(ind_filled):\n\n        ai = ind_filled[index]\n\n        if index == len(ind_filled)-1 or ind_filled[index] // 2 != ind_filled[index+1] // 2:\n            d_res[ai//2] = (min(A + d_values[ai][0], d_values[ai][1] * B * 2 * ll), d_values[ai][1])\n            out_ind.append(ai//2)\n            index += 1\n\n\n        elif ind_filled[index] // 2 == ind_filled[index+1] // 2:\n            # merge\n            anext = ind_filled[index+1]\n            d_res[ai//2] = (min(d_values[ai][0] + d_values[anext][0],\n                                   (d_values[ai][1] + d_values[anext][1]) * B * 2 * ll),\n                               d_values[ai][1] + d_values[anext][1])\n            out_ind.append(ai//2)\n\n            index += 2\n\n    return out_ind, d_res\n\nll = 1\n\narr_ind = ind_filled\n\nnpow = 0\n\nwhile npow < n:\n\n    arr_ind, d_h_counts = reduce(arr_ind, d_h_counts, ll)\n\n    ll *= 2\n    npow += 1\n\n\nk = list(d_h_counts.keys())[0]\nprint(d_h_counts[k][0])\n"]
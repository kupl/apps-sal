["import sys\nfrom collections import deque\nsys.setrecursionlimit(20000000)\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ng = [[] for i in range(n)]\nfor i in range(n-1):\n    g[b[i]-1].append(i+1)\nha = 0\nfor i in range(n):\n    if len(g[i]) == 0:\n        ha += 1\nkyo = [1<<30] * n\ndef dfs(x,y):\n  kyo[x] = y\n  for i in g[x]:\n    que.append([i,y+1])\nque = deque()\nque.append([0,0])\nwhile que:\n    aa,bb = que.popleft()\n    dfs(aa,bb)\nhukai = []\nfor i in range(n):\n  hukai.append([kyo[i],i])\nhukai.sort(key = lambda x:-x[0])\ndp = [1<<30]*n\nfor j,i in hukai:\n    if len(g[i]) == 0:\n        dp[i] = 0\n        continue\n    sita = []\n    for k in g[i]:\n        sita.append(dp[k])\n    if a[i] == 1:\n        dp[i] = min(sita)\n    else:\n        dp[i] = sum(sita)+len(g[i])-1\nans = ha-dp[0]\nprint(ans)", "from collections import defaultdict\nfrom collections import deque\n# import sys\n# sys.setrecursionlimit(400000)\nn = int(input())\ntree = defaultdict(set)\nnode_type = list(map(int,input().split()))\n#leaf = [True for x in range(n)]\nvalues = [0 for x in range(n)]\nfor i,x in enumerate(map(int,input().split())):\n    tree[x-1].add(i+1)\n    #leaf[x-1] = False\n\nqueue = deque([(0,False)])\nwhile queue:\n    node, tag = queue.popleft()\n    if not node in tree:\n        values[node] = 1\n        continue\n    elif tag:\n        if node_type[node]:\n            values[node] = min(values[c] for c in tree[node])\n        else:\n            values[node] = sum(values[c] for c in tree[node])\n    else:\n        queue.appendleft((node,True))\n        queue.extendleft((c,False) for c in tree[node])\n#print(values)\nk = n-len(tree)\nprint (k-values[0]+1)", "n = int(input())\n\nf = tuple(map(int, input().split()))\n\ntree = [[] for _ in range(n)]\nfor i, parent in zip(list(range(1, n + 1)), [int(x) - 1 for x in input().split()]):\n    tree[parent].append(i)\n\nd = [0] * n\n\nleaves = 0\nfor i in reversed(list(range(n))):\n    if not tree[i]:\n        d[i] = 1\n        leaves += 1\n        continue\n    if f[i] == 0:\n        d[i] = sum(d[j] for j in tree[i])\n    else:\n        d[i] = min(d[j] for j in tree[i])\n\n# print(f)\n# print(d)\nprint(leaves - d[0] + 1)\n", "from collections import deque\nN = int(input())\nmima = [-1] + list(map(int, input().split()))\npar = [-1, -1] + list(map(int, input().split()))\nleaf = set(range(1, N+1))\ncld = [0]*(N+1) \nfor p in par:\n    cld[p] += 1\n    if p in leaf:\n        leaf.remove(p)\ndp = [0]*(N+1)\nfor i in leaf:\n    dp[i] = 1\n\nQ = deque(list(leaf))\nvisited = leaf.copy()\nwhile Q:\n    vn = Q.pop()\n    if vn == 1:\n        break\n    pv = par[vn]\n    if mima[pv] == 1:\n        if not dp[pv]:\n            dp[pv] = dp[vn]\n        else:\n            dp[pv] = min(dp[pv], dp[vn])\n        cld[pv] -= 1\n        if not cld[pv]:\n            Q.appendleft(pv)\n    else:\n        if not dp[pv]:\n            dp[pv] = dp[vn]\n        else:\n            dp[pv] += dp[vn]\n        cld[pv] -= 1\n        if not cld[pv]:\n            Q.appendleft(pv)\nprint(len(leaf) - dp[1] + 1)", "n = int(input())\na = [None] + list(map(int, input().split()))\np = [None, None] + list(map(int, input().split()))\n\ng = [[] for i in range(n + 1)]\nfor i in range(n, 0, -1):\n    if g[i]:\n        c = 0\n        x, y = 0, 10 ** 9\n        for cv, wv in g[i]:\n            c += cv\n            x += wv\n            y = min(y, wv)\n        w = y if a[i] else x\n    else:\n        c, w = 1, 1\n    if i == 1:\n        print(c - w + 1)\n    else:\n        g[p[i]].append((c, w))", "n = int(input())\na = [None] + list(map(int, input().split()))\np = [None, None] + list(map(int, input().split()))\n\nf = [[0, 0, 10 ** 9] for i in range(n + 1)]\nfor i in range(n, 1, -1):\n    if f[i][0] == 0:\n        c = x = y = 1\n    else:\n        c, x, y = f[i]\n    w = y if a[i] else x\n    f[p[i]][0] += c\n    f[p[i]][1] += w\n    f[p[i]][2] = min(f[p[i]][2], w)\nw = f[1][2] if a[1] else f[1][1]\nprint(f[1][0] - w + 1)", "n = int(input())\nis_max = list(map(int,input().split()))\nparent = list(map(int,input().split()))\nadjList = [[] for _ in range(n)]\nused = [0]*n\nfor v, u in enumerate(parent):\n    adjList[u-1].append(v+1)\nfor i in range(n-1, 0, -1):\n    pi = parent[i-1] - 1\n    if is_max[pi]:\n        if used[pi] == 0:\n            used[pi] = max(1, used[i])\n        else:\n            used[pi] = max(1, min(used[pi], used[i]))\n    else:\n        used[pi] += max(1, used[i])\nk = sum([len(adjList[u]) == 0 for u in range(n)])\nprint(k-used[0]+1)\n", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nn=int(input())\nOP=[0]+list(map(int,input().split()))\nf=list(map(int,input().split()))\n\nCHLIST=[[] for i in range(n+1)]\n\nfor i in range(n-1):\n    CHLIST[f[i]].append(i+2)\n\nLEAFLIST=[]\nfor i in range(1,n+1):\n    if len(CHLIST[i])==0:\n        LEAFLIST.append(i)\n\nLEAF=len(LEAFLIST)\n\nHEIGHT=[0]*(n+1)\nQUE=deque([1])\nH=1\nwhile QUE:\n    NQUE=deque()\n    while QUE:\n        x=QUE.pop()\n        HEIGHT[x]=H\n        for ch in CHLIST[x]:\n            NQUE.append(ch)\n\n    H+=1\n    QUE=NQUE\n\nLIST=list(range(1,n+1))\nLIST.sort(key=lambda x:HEIGHT[x],reverse=True)\n        \n\nNMINUS=[10]*(n+1)\ndef node_minus(n):\n    if NMINUS[n]!=10:\n        return NMINUS[n]\n    \n    if len(CHLIST[n])==0:\n        return 0\n\n    if OP[n]==1:\n        ANS=-10**7\n\n        for ch in CHLIST[n]:\n            ANS=max(ANS,node_minus(ch))\n\n        NMINUS[n]=ANS\n        return ANS\n\n    else:\n        ANS=1\n\n        for ch in CHLIST[n]:\n            ANS-=1\n            ANS+=node_minus(ch)\n\n        NMINUS[n]=ANS\n        return ANS\n    \n\nfor l in LIST:\n    node_minus(l)\n\nprint(LEAF+NMINUS[1])\n", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\nn=int(input())\nOP=[0]+list(map(int,input().split()))\nf=list(map(int,input().split()))\n\nCHLIST=[[] for i in range(n+1)]\n\nfor i in range(n-1):\n    CHLIST[f[i]].append(i+2)\n\nLEAFLIST=[]\nfor i in range(1,n+1):\n    if len(CHLIST[i])==0:\n        LEAFLIST.append(i)\n\nLEAF=len(LEAFLIST)\n\nHEIGHT=[0]*(n+1)\nQUE=deque([1])\nH=1\nwhile QUE:\n    NQUE=deque()\n    while QUE:\n        x=QUE.pop()\n        HEIGHT[x]=H\n        for ch in CHLIST[x]:\n            NQUE.append(ch)\n\n    H+=1\n    QUE=NQUE\n\nLIST=list(range(1,n+1))\nLIST.sort(key=lambda x:HEIGHT[x],reverse=True)\n        \n\nNMINUS=[10]*(n+1)\ndef node_minus(n):\n    if NMINUS[n]!=10:\n        return NMINUS[n]\n    \n    if len(CHLIST[n])==0:\n        return 0\n\n    if OP[n]==1:\n        ANS=-10**7\n\n        for ch in CHLIST[n]:\n            ANS=max(ANS,node_minus(ch))\n\n        NMINUS[n]=ANS\n        return ANS\n\n    else:\n        ANS=1\n\n        for ch in CHLIST[n]:\n            ANS-=1\n            ANS+=node_minus(ch)\n\n        NMINUS[n]=ANS\n        return ANS\n    \n\nfor l in LIST:\n    node_minus(l)\n\nprint(LEAF+NMINUS[1])", "N = int(input())\na = list(map(int, input().split()))\nf = list(map(int, input().split()))\nG = [[] for i in range(N)]\nINF = float('inf')\nfor i in range(1, N):\n    G[f[i - 1] - 1].append(i)\n\nd = [0] * N\nk = 0\nfor i in range(N - 1, -1, -1):\n    if len(G[i]) == 0:\n        d[i] = 1\n        k += 1\n        continue\n\n    if a[i] == 0:\n        d[i] = 0\n        for j in G[i]:\n            d[i] += d[j]\n    else:\n        d[i] = INF\n        for j in G[i]:\n            d[i] = min(d[i], d[j])\n\nprint(k - d[0] + 1)\n", "N = int(input())\nT = [int(a) for a in input().split()]\nP = [int(a)-1 for a in input().split()]\nC = [[] for i in range(N)]\nfor i in range(N-1):\n    C[P[i]].append(i+1)\nL = [i for i in range(N) if len(C[i]) == 0]\nDP = [-1] * N\ndef calc(i):\n    if len(C[i]) == 0:\n        DP[i] = 1\n    elif T[i]:\n        mi = 10**10\n        for j in C[i]:\n            mi = min(mi, DP[j])\n        DP[i] = mi\n    else:\n        s = 0\n        for j in C[i]:\n            s += DP[j]\n        DP[i] = s\n\nfor i in range(N)[::-1]:\n    calc(i)\n\nprint(len(L)-DP[0]+1)\n", "N = int(input())\nT = [int(a) for a in input().split()]\nP = [int(a)-1 for a in input().split()]\nC = [[] for i in range(N)]\nfor i in range(N-1):\n    C[P[i]].append(i+1)\nL = sum([1 for i in range(N) if len(C[i]) == 0])\nDP = [-1] * N\ndef calc(i):\n    if len(C[i]) == 0:\n        DP[i] = 1\n    else:\n        X = [DP[j] for j in C[i]]\n        DP[i] = min(X) if T[i] else sum(X)\n\nfor i in range(N)[::-1]:\n    calc(i)\n\nprint(L-DP[0]+1)\n", "N = int(input())\nT = [int(a) for a in input().split()]\nP = [-1] + [int(a)-1 for a in input().split()]\nC = [[] for i in range(N)]\nfor i in range(1, N):\n    C[P[i]].append(i)\nL = sum([1 for i in range(N) if len(C[i]) == 0])\nCT = [0] * N\nDP = [-1] * N\n\ni = 0\nwhile i >= 0:\n    # print(\"Try\", i, C[i], CT[i])\n    if CT[i] >= len(C[i]):\n        if len(C[i]) == 0:\n            DP[i] = 1\n        elif T[i]:\n            mi = 10**10\n            for j in C[i]:\n                mi = min(mi, DP[j])\n            DP[i] = mi\n        else:\n            s = 0\n            for j in C[i]:\n                s += DP[j]\n            DP[i] = s\n        i = P[i]\n    else:\n        CT[i], i = CT[i] + 1, C[i][CT[i]]\n\nprint(L-DP[0]+1)\n", "import sys,threading\nsys.setrecursionlimit(10**6)\nthreading.stack_size(10**8)\n\ndef main():\n    n = int(input().strip())\n    son_tree = dict()\n    min_max = [0] + [int(i) for i in input().strip().split()]\n    for child, parent in enumerate(map(int,input().strip().split()),2):\n        if parent not in son_tree:\n            son_tree[parent] = [child]\n        else:\n            son_tree[parent].append(child)\n    leaf_ctr = 0\n    dp = [0 for i in range(n+1)]\n    for i in range(1,n+1):\n        if i not in son_tree:\n            leaf_ctr += 1\n            dp[i] = 1\n\n    visited = set()\n    def dfs(node):\n        if node not in visited:\n            visited.add(node)\n            if node not in son_tree:\n                return 1\n            if min_max[node]:\n                for i in son_tree[node]:\n                    dfs(i)\n                dp[node] = min(dp[k] for k in son_tree[node])\n                return 0\n            else:\n                for i in son_tree[node]:\n                    dfs(i)\n                dp[node] = sum(dp[k] for k in son_tree[node])\n                return 0\n    dfs(1)\n    print(leaf_ctr - dp[1]+1)\ndef __starting_point():\n    t = threading.Thread(target=main)\n    t.start()\n    t.join()\n\n__starting_point()", "n=int(input())\noper=list(map(int,input().split()))\nrod=list(map(int,input().split()))\ns={i:[] for i in range(n)}\nfor i in range(len(rod)):\n    s[rod[i]-1].append(i+1)\nt=[-1]*n\nt[0]=1\nblack=[]\ngrey=[0]\nwhile grey!=[]:\n    black.append(grey.pop())\n    for i in s[black[-1]]:\n        grey.append(i)\n        t[i]=t[black[-1]]+1\nl=[[] for i in range(n+1)]\nfor i in range(len(t)):\n    l[t[i]].append(i)\nl.reverse()\nt=[i for i in s if s[i]==[]]\nans=[1 for i in range(n)]\nfor i in t:\n    ans[i]=-1\nfor x in l:\n    for y in x:\n        if oper[y]==0:\n            if ans[y]!=1:\n                continue\n            ans[y]=sum([ans[i] for i in s[y]])\n        elif oper[y]==1:\n            if ans[y]!=1:\n                continue\n            ans[y]=max([ans[i] for i in s[y]])\nt=len([i for i in s if s[i]==[]])\nprint(t+1+ans[0])\n\n    \n\n", "import math\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n\n    n = int(input())\n    min_max = list(map(int, input().split()))\n    tree_input = list(map(int, input().split()))\n\n    tree = [[] for _ in range(n)]\n    for v in range(n-1):\n        parent = tree_input[v]-1\n        tree[parent].append(v+1)\n\n    leaves = [0 for _ in range(n)]\n\n    stack = [0]\n    pos = 0\n    while pos < len(stack):\n        for child in tree[stack[pos]]:\n            stack.append(child)\n        pos += 1\n\n    for pos in range(len(stack)-1, -1, -1):\n        node = stack[pos]\n        if len(tree[node]) == 0:\n            leaves[node] = 1\n        else:\n            for child in tree[node]:\n                leaves[node] += leaves[child]\n\n    node_max = [0] * n\n    for pos in range(len(stack)-1, -1, -1):\n        node = stack[pos]\n        if len(tree[node]) == 0:\n            node_max[node] = 1\n        else:\n            if min_max[node] == 1:\n                best = math.inf\n                for child in tree[node]:\n                    if leaves[child] - node_max[child] < best:\n                        best = leaves[child] - node_max[child]\n                node_max[node] = leaves[node] - best\n            else:\n                optimal = 1\n                for child in tree[node]:\n                    optimal += node_max[child]-1\n                node_max[node] = optimal\n\n    print(node_max[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nop=[int(g) for g in input().split()]\nparent=[int(g)-1 for g in input().split()]\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n    tree[parent[i]].append(i+1)\nl=sum([1 for i in range(n) if len(tree[i])==0])\n\nl1=[-1]*n\nfor i in range(n-1,-1,-1):\n    if len(tree[i])==0:\n        l1[i]=1\n    else:\n        x=[l1[j] for j in tree[i]]\n        if op[i]==1:\n            l1[i]=min(x)\n        else:\n            l1[i]=sum(x)\nprint(l-l1[0]+1)\n\n        \n    \n    \n\n    \n                \n    \n\n\n", "n = int(input())\noper = list(map(int, input().split())) # 0 - min, 1 - max\nprev = [int(i) - 1 for i in input().split()]\n\ngraph = [[] for i in range(n)]\nfor i in range(n - 1):\n    graph[prev[i]].append(i + 1) \n\nleafs = sum([len(graph[i]) == 0 for i in range(n)])\n\nres = [0] * n\nfor u in range(n - 1, -1, -1):\n    if len(graph[u]) == 0:\n        res[u] = 1\n    else:\n        sons = [res[v] for v in graph[u]]\n        res[u] = (min(sons) if oper[u] == 1 else sum(sons))\nprint(leafs - res[0] + 1)", "import sys\n\nn = int(input())\nminmax = list(map(int, input().split()))\nchilds = [[] for i in range(n)]\n\nfor idx, father in enumerate(list(map(int,input().split()))):\n    childs[father-1].append(idx+1)\n\nstack = []\nstack.append(0)\n\nans = [None for ele in range(n)]\nvis = [False for ele in range(n)]\n\nwhile len(stack):\n    index = stack[-1]\n    if not vis[index]:\n        vis[index] = True\n        if len(childs[index]) == 0:\n            ans[index] = (0,1)\n            stack.pop()\n        else:\n            for child in childs[index]:\n                stack.append(child)\n    else:\n        stack.pop()\n        res = [ans[child] for child in childs[index]]\n        total = sum([ele[1] for ele in res])\n        if minmax[index] == 1:\n            ans[index] = min([ele[0] for ele in res]), total\n        else:\n            bigger_than = sum([ele[1] - ele[0] - 1 for ele in res])    \n            ans[index] = total - bigger_than - 1, total\n\nprint(ans[0][1] - ans[0][0])\n", "n = int(input())\nop = list(int(v) for v in input().split())\nf = list(int(v) for v in input().split())\n\nch = [list() for p in op]\n\nfor i, p in enumerate(f): ch[p-1].append(i+1) # children\n\nq = [0]\nnl = 0 # number of leaves\n\nfor i in range(n): q += ch[i] # parents first\n\nx = [0]*n\n\nwhile q:\n    p = q.pop()\n    if not ch[p]:\n        #print('node', p, 'is a leaf (0)')\n        nl += 1\n    elif op[p]:\n        x[p] = min(x[c] for c in ch[p])\n        #print('node', p, 'is a MAX (%d)' % x[p], ch[p], list(x[c] for c in ch[p]))\n    else:\n        x[p] = sum(x[c]+1 for c in ch[p])-1\n        #print('node', p, 'is a MIN', x[p])\n\nprint(nl - x[0])\n#print(n, op, f)\n#print(ch)\n#print(q)\n", "n = int(input())\nop = list(int(v) for v in input().split())\nf = list(int(v) for v in input().split())\n\nch = [list() for p in op]\nfor i, p in enumerate(f): ch[p-1].append(i+1) # children\n\nq = [0]\nfor i in range(n): q += ch[q[i]] # queue parents first\n\nx = [0]*n # how many largest numbers the node consumes\nnl = 0 # number of leaves\n\nfor p in reversed(q):\n    if not ch[p]: nl += 1\n    elif op[p]: x[p] = min(x[c] for c in ch[p])\n    else: x[p] = sum(x[c]+1 for c in ch[p])-1\n\nprint(nl - x[0])\n", "n = int(input())\nop = [int(v) for v in input().split()]\nf = [int(v) for v in input().split()]\n\nch = [[] for p in op]\nfor i, p in enumerate(f): ch[p-1].append(i+1) # children\n\nq = [0]\nfor i in range(n): q += ch[q[i]] # queue parents first\n\nx = [0]*n # how many largest numbers the node consumes\nnl = 0 # number of leaves\n\nfor p in q[::-1]: # Leaves first\n    if not ch[p]: nl += 1\n    elif op[p]: x[p] = min(x[c] for c in ch[p])\n    else: x[p] = sum(x[c]+1 for c in ch[p])-1\n\nprint(nl - x[0])\n"]
["import functools, operator\nm = int(input())\np = [int(x) for x in input().split()]\nP = {}\nn = 1\nfor i in p:\n    P[i] = P.get(i, 0) + 1\n    n = n * i % 1000000007\ndv = functools.reduce(operator.mul, (l + 1 for l in list(P.values())))\nprod = 0;\n#n = functools.reduce(operator.mul, (pow(p,i,1000000007) for p,i in P.items()))\nif dv & 1:\n    #prod = pow(int(n**0.5), dv, 1000000007)\n    prod = pow(int(functools.reduce(operator.mul, (pow(p,i//2,1000000007) for p,i in list(P.items())))), dv, 1000000007)\n    #prod = pow(int(n**0.5), dv, 1000000007);\nelse:\n    #prod = pow(n, dv//2, 1000000007)\n    #prod = pow(functools.reduce(operator.mul, p), dv//2, 1000000007)\n    prod = pow(n, dv//2, 1000000007)\nprint(prod % 1000000007)\n\n", "MOD = 1000000007\ntop = 0\nt = [0] * 200005\nx = int(input())\ny = list(map(int, input().split(' ')))\n\nif 10**9+7 in y:\n    print(0)\n    quit()\n\nbase = 1\n\nsq = True\n\nfor i in y:\n    t[i] += 1\n    base *= i\n    base %= MOD\n\nfor i in range(200005):\n    if (t[i] % 2 == 1):\n        sq = False\n\nans = 1\npowf = 1\nif sq:\n    for i in range(200005):\n        ans *= pow(i, t[i]//2, MOD)\n        ans %= MOD\n        powf *= (t[i] + 1)\n        powf %= (MOD - 1)\n    print(pow(ans, powf, MOD))\n    quit()\n\ntwo = False\nfor i in range(200005):\n    if (not two and t[i] % 2 == 1):\n        two = True\n        powf *= (t[i]+1)//2\n    else:\n        powf *= (t[i]+1)\n    powf %= (MOD - 1)\n\nprint(pow(base, powf, 10**9+7))\n", "from functools import reduce\nimport sys\n\n#f = open('test', 'r')\n#sys.stdin = f\nm = int(input())\np = 10**9 + 7\ndividors = [int(x) for x in input().split()]\nD = {}\nfor d in dividors:\n    if d in D:\n        D[d] += 1\n    else:\n        D[d] = 1\nprod = reduce(lambda x,y : x*y%p, dividors)\ndeg = reduce(lambda x,y : x*y, (d+1 for d in list(D.values())))\nif deg % 2:\n    prod = reduce(lambda x,y : x*y%p, (pow(d, i//2, p) for d,i in list(D.items())))\n    ans = pow(prod, deg%(p-1), p)\nelse:\n    ans = pow(prod, (deg//2)%(p-1), p)\n\nprint(ans)\n", "import collections\n\ndef logpow(a, b, mod):\n    if b == 0:\n        return 1\n\n    v = logpow(a, b // 2, mod)\n    ret = v * v % mod\n    if b % 2 == 1:\n        ret = ret * a % mod\n    return ret\n\nmod = 1000000007\nn = int(input())\n\nd = collections.defaultdict(int)\nfor x in input().split():\n    d[int(x)] += 1\n\nb = [(x, y) for x, y in list(d.items())]\n\npl = [1 for i in range(len(b) + 2)]\npr = [1 for i in range(len(b) + 2)]\nfor i in range(1, len(b) + 1):\n    pl[i] = pl[i - 1] * (1 + b[i - 1][1]) % (mod - 1)\n    j = len(b) - i + 1\n    pr[j] = pr[j + 1] * (1 + b[j - 1][1]) % (mod - 1)\n\n\nret = 1\nfor i in range(1, len(b) + 1):\n    pp = pl[i - 1] * pr[i + 1] % (mod - 1)\n    pp = pp * ( b[i - 1][1] * (b[i - 1][1] + 1) // 2) % (mod - 1)\n    ret = ret * logpow(b[i - 1][0], pp, mod) % mod\n\nprint (ret)\n", "#!/usr/bin/env python3\nimport math\nlca = lambda a, b: a * b // math.gcd(a,b)\nmod = 1000000007\nm = int(input())\nps = list(map(int,input().split()))\ncnt = {}\nfor p in ps:\n    if p not in cnt:\n        cnt[p] = 0\n    cnt[p] += 1\nlca_i = 1\nk = 1\nfor i in list(cnt.values()):\n    k *= i + 1\n    lca_i = lca(lca_i, i+1)\nans = 1\nfor p, i in list(cnt.items()):\n    ans = ans * pow(p, i*(i+1)//2 * lca_i//(i+1), mod) % mod\nans = pow(ans, k//lca_i, mod)\nprint(ans)\n", "from collections import Counter\n\nMOD = 1000000007\n\ndef pow_m(base, pw):\n    if pw == 0:\n        return 1\n    elif pw % 2 == 1:\n        return (((pow_m(base, pw // 2) ** 2) % MOD) * base) % MOD\n    else:\n        return (pow_m(base, pw // 2) ** 2) % MOD\n\nm = int(input())\np = [int(x) for x in input().split()]\nc = Counter(p)\n\nis_square = all(c[x] % 2 == 0 for x in c)\n\nbase, root, pw = 1, 1, 1\nfor elem in c:\n    if is_square:\n        ppw = pow_m(elem, c[elem] // 2)\n        base = (base * ((ppw ** 2) % MOD)) % MOD\n        root = (root * ppw) % MOD\n    else:\n        base = (base * pow_m(elem, c[elem])) % MOD\n    pw *= c[elem] + 1\npw = (pw // 2) % (MOD - 1)\n\nprod = pow_m(base, pw)\nif is_square:\n    prod = (prod * root) % MOD\nprint(prod)\n", "n = int(input())\nl = list(map(int, input().split()))\nM = int(1e9+7)\ncounter = {}\nnum = 1\nfor elem in l:\n    num = (num * elem) % M\n    try:\n        counter[elem]+=1\n    except:\n        counter[elem] = 2\n        \nd = 1\nfor elem in counter:\n    d *= counter[elem]\n    \nres = pow(num, d//2, M)\ncheckodd = 1\nfor elem in counter:\n    if counter[elem] % 2 == 0: \n        checkodd = 0\n        break\nif checkodd:\n    for elem in counter:\n        for i in range(counter[elem] // 2):\n            res = (res * elem) % M\n            \nprint(res)", "from collections import Counter as C\nfrom operator import __mul__\nmod = 10 ** 9 + 7\n\nn = int(input())\nm = C(map(int, input().split()))\n\nans = mul = 1\nfor elem in m.values():\n    mul *= elem + 1\nfor a, b in m.items():\n    curr = mul * b // 2\n    curr %= mod - 1\n    ans *= pow(a, curr, mod)\n    ans %= mod\nprint(ans)", "from collections import Counter\nmd = 10**9+7\nm = int(input())\ncnt = Counter(list(map(int,input().split())))\n\nans = x = 1\nfor k in list(cnt.values()) : x*=k+1\nfor (a,b) in list(cnt.items()) :\n    p = (x*b//2)%(md-1)\n    ans = (ans*pow(a,p,md))%md\nprint(ans)\n", "mod_number = 10 ** 9 + 7\n\n\ndef power_mod(n, p):\n    if p < 2:\n        return (n ** p) % mod_number\n    sub_result = power_mod(n, p // 2)\n    if p % 2 == 0:\n        return (sub_result ** 2) % mod_number\n    else:\n        return (sub_result ** 2 * n) % mod_number\n\n\ndef get_frequency_map(items):\n    frequency_map = {}\n    for item in items:\n        if item in frequency_map:\n            frequency_map[item] += 1\n        else:\n            frequency_map[item] = 1\n\n    return frequency_map\n\n\ndef get_product_of_others(items):\n    length = len(items)\n\n    prefix_product_of_others = [1] * length\n    suffix_product_of_others = [1] * length\n    for i in range(1, length):\n        prefix_product_of_others[i] = (prefix_product_of_others[i - 1] * items[i - 1]) % (mod_number - 1)\n\n    for i in reversed(list(range(length - 1))):\n        suffix_product_of_others[i] = (suffix_product_of_others[i + 1] * items[i + 1]) % (mod_number - 1)\n\n    return [prefix_product_of_others[i] * suffix_product_of_others[i]\n            for i in range(length)]\n\n\ndef main():\n    m = int(input())\n    prime_factors = [int(t) for t in input().split()]\n\n    prime_factors_count_map = get_frequency_map(prime_factors)\n    ordered_prime_factors = list(prime_factors_count_map.keys())\n\n    # if prime factor 2 occurs three times\n    # it can be choose four way to form other factors\n    # taking three times, taking two times, taking one times and not taking 2 to form a factor\n    each_prime_factor_choices = [prime_factors_count_map[prime_factor] + 1 for prime_factor in ordered_prime_factors]\n\n    other_prime_factors_choices = get_product_of_others(each_prime_factor_choices)\n\n    total_factors = 1\n    for i, prime_factor in enumerate(ordered_prime_factors):\n        prime_factor_count = prime_factors_count_map[prime_factor]\n        # if prime factor 2 occurs four time then possible factors by 2, 4, 8\n        # means product of the factors will be 2^(1+2+3)\n        total_power_of_factor = ((prime_factor_count * (prime_factor_count + 1)) // 2)\n        product_of_factor_by_prime_factor = power_mod(prime_factor, total_power_of_factor % (mod_number - 1))\n        total_factors *= power_mod(product_of_factor_by_prime_factor, other_prime_factors_choices[i] % (mod_number - 1))\n\n    print(total_factors % mod_number)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "MD = 1000000007\nm = int(input())\np = list(map(int, input().split()))\nq = {}\nfor el in p:\n    if el in q:\n        q[el] += 1\n    else:\n        q[el] = 2\nsum1 = 1\nsum2 = 1\nfor el in q:\n    sum1=sum1*q[el]\n    sum2=sum2*pow(el,(q[el]-1),MD)\nsum=pow(sum2,sum1//2,MD)\nif sum1 % 2 == 1:\n    for el in q:\n        sum = (sum * pow(el,q[el]//2,MD)) % MD\nprint(sum)", "MD = 1000000007\nm = int(input())\np = list(map(int, input().split()))\nq = {}\nfor el in p:\n    if el in q:\n        q[el] += 1\n    else:\n        q[el] = 2\nsum1 = 1\nsum2 = 1\nfor el in q:\n    sum1=sum1*q[el]\n    sum2=sum2*pow(el,(q[el]-1),MD)\nsum=pow(sum2,sum1//2,MD)\nif sum1 % 2 == 1:\n    for el in q:\n        for i in range(q[el]//2):\n            sum = (sum * el) % MD\nprint(sum)", "MD = 1000000007\nm = int(input())\np = list(map(int, input().split()))\nq = {}\nfor el in p:\n    if el in q:\n        q[el] += 1\n    else:\n        q[el] = 2\nsum1 = 1\nsum2 = 1\nfor el in q:\n    sum1=sum1*q[el]\n    sum2=(sum2*pow(el,(q[el]-1),MD)) % MD\nsum=pow(sum2,sum1//2,MD)\nif sum1 % 2 == 1:\n    for el in q:\n        sum = (sum * pow(el,q[el]//2,MD)) % MD\nprint(sum)", "mbase = 10**9+7\nnof = int(input())\nfacts = [int(x) for x in input().split()]\n\npmap = {}\nfor p in facts:\n\tpmap[p] = pmap.get(p, 0) + 1\n\nonepprod = 1\nfor (p, q) in list(pmap.items()):\n\tonepprod*= q+1\n\tonepprod%= 2*(mbase-1)\n\nres = 1\nfor (p, q) in list(pmap.items()):\n\tres*= pow(p, (q*onepprod)//2, mbase)\n\tres%= mbase\n\nprint(res)\n", "m = int(input())\nprimes = list(map(int, input().split()))\ndict = {}\nresult = 1\n\nfor p in primes:\n    dict[p] = dict.get(p, 0) + 1\n\nmult = 1\nfor x in dict.values():\n    mult *= x + 1\n    mult %= 2*(10**9+6)\n\nfor x, y in dict.items():\n    result *= pow(x, (y*mult)//2, 10**9 + 7)\n    result %= 10**9 + 7\n\nprint(result)", "import operator\nfrom collections import Counter\n\nfrom functools import reduce\n\n\ndef solve(primes):\n    products = 1\n    for x in primes.values():\n        products *= x+1\n        products %= 2 * (10 ** 9 + 6)\n\n    n = 1\n    for x, y in primes.items():\n        n *= pow(x, y * (y + 1) // 2 * products // (y + 1), 10 ** 9 + 7)\n        n %= (10 ** 9 + 7)\n\n    return n\n\n\ndef main():\n    m = int(input())\n    primes = Counter(map(int, input().split()))\n    print(solve(primes))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10001)\n\ndef main():\n\tm = int(input())\n\ttemp = input().split()\n\tprimes = [int(x) for x in temp]\n\tprint(solver2(primes))\n\ndef solver2(primes):\n\tmodulus = 10**9 + 7\n\t# create mapping of primes to their count\n\tprimesDict = dict()\n\tfor p in primes:\n\t\tif p not in primesDict:\n\t\t\tprimesDict[p] = 1\n\t\telse:\n\t\t\tprimesDict[p] += 1\n\t# total number of factors\n\tfactors = 1\n\tfor p in primesDict:\n\t\tfactors *= (primesDict[p] + 1)\n\t\tfactors %= 2 * (modulus - 1)\n\tif factors % 2 == 0:\n\t\t# calculate n\n\t\tn = 1\n\t\tfor p in primesDict:\n\t\t\tn = (n * expMod(p, primesDict[p], modulus)) % modulus\n\t\t#if primes[0] == 31481:\n\t\t\t#print(digitCount(factors))\n\t\t#\treturn 86721852\n\t\treturn expMod(n, factors // 2, modulus)\n\telse:\n\t\t# all powers are even, so \n\t\t#n must be a perfect square\n\t\t#try:\n\t\t#\tsqrtN = int(round(n**0.5))\n\t\t#except:\n\t\tsqrtN = 1\n\t\tfor p in primesDict:\n\t\t\tsqrtN = (sqrtN * expMod(p, primesDict[p] // 2, modulus)) % modulus\n\t\treturn expMod(sqrtN, factors, modulus)\n\ndef expMod(n, e, modulus, recLimit = 0):\n\tif e == 1:\n\t\treturn n % modulus\n\t#elif recLimit == 10000:\n\t#\treturn (n**e) % modulus\n\telif e % 2 == 0:\n\t\treturn (expMod(n, e // 2, modulus)**2) % modulus\n\t# e % 2 != 0\n\telse:\n\t\treturn (n * expMod(n, e // 2, modulus)**2) % modulus\n\ndef digitCount(n):\n\tn = abs(n)\n\tcount = 0\n\twhile n > 0:\n\t\tcount += 1\n\t\tn //= 10\n\treturn count\n\nmain()\n#print(digitCount(2**200000))\n#975988510\n#factors = 10**5234\n#print(expMod(975988510, factors, 10**9 + 7))\n\n#print(expMod(3, 9, 2))\n#print(solver2([135391] * 200000))\n#print(solver2([2, 3, 2]))\n#print(solver2([63997, 63997]))\n\n#print(63997 **3 % (10**9 + 7))\n#print(63997**2)\n#print(expMod(135391, 100000, 10**9 + 7))\n#a = 135391**100000 % (10**9 + 7)\n#print(a)\n\n# a = \"31481 140797 186479 4861 79613 178439 137909 106291 31069 22271 22643 50549 31981 24631 129443 83449 11969 102299 199499 40627 56701 188017 138727 63473 22643 6763 24631 118463 93239 22643 166399 129401 106291 142469 4153 199499 53129 127 41863 24551 106291 50671 81773 132421 86467 49171 41491 133769 13147 53453 83449 51659 157279 33679 138727 118463 18593 24631 16693 26437 139871 135701 58741 133723 111149 41491 137909 93239 78511 199499 41863 166399 103087 24029 3001 182297 17981 53453 53327\"\n# a = a.split()\n# a = [int(x) for x in a]\n# print(solver2(a))\n# print(200000 // 79)\n\n", "MD = 1000000007\nm = int(input())\np = list(map(int, input().split()))\nq = {}\nfor el in p:\n    if el in q:\n        q[el] += 1\n    else:\n        q[el] = 2\nsum1 = 1\nsum2 = 1\nfor el in q:\n    sum1=sum1*q[el]\n    sum2=sum2*pow(el,(q[el]-1),MD)\nsum=pow(sum2,sum1//2,MD)\nif sum1 % 2 == 1:\n    for el in q:\n        sum = (sum * pow(el,q[el]//2,MD)) % MD\nprint(sum)", "import sys\nsys.setrecursionlimit(10001)\n\ndef main():\n\tm = int(input())\n\ttemp = input().split()\n\tprimes = [int(x) for x in temp]\n\tprint(solver2(primes))\n\ndef solver2(primes):\n\tmodulus = 10**9 + 7\n\t# create mapping of primes to their count\n\tprimesDict = dict()\n\tfor p in primes:\n\t\tif p not in primesDict:\n\t\t\tprimesDict[p] = 1\n\t\telse:\n\t\t\tprimesDict[p] += 1\n\t# total number of factors\n\tfactors = 1\n\tfor p in primesDict:\n\t\tfactors *= (primesDict[p] + 1)\n\t\t#factors %= 2 * (modulus - 1)\n\tif factors % 2 == 0:\n\t\t# calculate n\n\t\tn = 1\n\t\tfor p in primesDict:\n\t\t\tn = (n * pow(p, primesDict[p], modulus)) % modulus\n\t\t#if primes[0] == 31481:\n\t\t\t#print(digitCount(factors))\n\t\t#\treturn 86721852\n\t\treturn pow(n, factors // 2, modulus)\n\telse:\n\t\t# all powers are even, so \n\t\t#n must be a perfect square\n\t\t#try:\n\t\t#\tsqrtN = int(round(n**0.5))\n\t\t#except:\n\t\tsqrtN = 1\n\t\tfor p in primesDict:\n\t\t\tsqrtN = (sqrtN * pow(p, primesDict[p] // 2, modulus)) % modulus\n\t\treturn pow(sqrtN, factors, modulus)\n\ndef expMod(n, e, modulus, recLimit = 0):\n\tif e == 1:\n\t\treturn n % modulus\n\t#elif recLimit == 10000:\n\t#\treturn (n**e) % modulus\n\telif e % 2 == 0:\n\t\treturn (expMod(n, e // 2, modulus)**2) % modulus\n\t# e % 2 != 0\n\telse:\n\t\treturn (n * expMod(n, e // 2, modulus)**2) % modulus\n\ndef digitCount(n):\n\tn = abs(n)\n\tcount = 0\n\twhile n > 0:\n\t\tcount += 1\n\t\tn //= 10\n\treturn count\n\nmain()\n#print(digitCount(2**200000))\n#975988510\n#factors = 10**5234\n#print(expMod(975988510, factors, 10**9 + 7))\n\n#print(expMod(3, 9, 2))\n#print(solver2([135391] * 200000))\n#print(solver2([2, 3, 2]))\n#print(solver2([63997, 63997]))\n\n#print(63997 **3 % (10**9 + 7))\n#print(63997**2)\n#print(expMod(135391, 100000, 10**9 + 7))\n#a = 135391**100000 % (10**9 + 7)\n#print(a)\n\n# a = \"31481 140797 186479 4861 79613 178439 137909 106291 31069 22271 22643 50549 31981 24631 129443 83449 11969 102299 199499 40627 56701 188017 138727 63473 22643 6763 24631 118463 93239 22643 166399 129401 106291 142469 4153 199499 53129 127 41863 24551 106291 50671 81773 132421 86467 49171 41491 133769 13147 53453 83449 51659 157279 33679 138727 118463 18593 24631 16693 26437 139871 135701 58741 133723 111149 41491 137909 93239 78511 199499 41863 166399 103087 24029 3001 182297 17981 53453 53327\"\n# a = a.split()\n# a = [int(x) for x in a]\n# print(solver2(a))\n# print(200000 // 79)\n\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2016 missingdays <missingdays@missingdays>\n#\n# Distributed under terms of the MIT license.\n\n\"\"\"\n\n\"\"\"\n\n#Constant\ndef read_list():\n    return [int(i) for i in input().split()]\ndef new_list(n):\n    return [0 for i in range(n)]\ndef new_matrix(n, m=0):\n    return [[0 for i in range(m)] for i in range(n)]\nmod=1000000007\n\n\ndef binPow(a, q, mod):\n    a %= mod\n    if q == 0:\n        return 1\n    return ((q%2 == 1 and a or 1) * binPow(a*a, q//2, mod)) % mod\n\nn = int(input())\n\na = {}\n\nb = read_list()\n\nfor c in b:\n    if c in a:\n        a[c] += 1\n    else:\n        a[c] = 1\n\nd, answ = 1, 1\n\nfor p in a:\n    c = a[p]\n\n    fp = binPow(p, (c + 1)*c//2, mod)\n    answ = binPow(answ, (c+1), mod) * binPow(fp, d, mod) % mod\n    d = d * (c+1) % (mod-1) \n\nprint(answ)\n", "readInts=lambda: list(map(int, input().split()))\n\nn=int(input())\na=readInts()\np={}\nfor b in a:\n    p[b]=p.get(b,0)+1\n\nMOD=10**9+7\nret=1;cnt=1;\nfor x in list(p.items()):\n    t=x[1]\n    now=pow(x[0],(1+t)*t//2,MOD)\n    ret*=pow(ret,t,MOD)\n    ret%=MOD\n    ret*=pow(now,cnt,MOD)\n    ret%=MOD\n    cnt=cnt*(t+1)\n    cnt%=MOD-1\n    \nprint(ret)\n\n\n", "m = int(input())\nprimes = list(map(int, input().split()))\ndict = {}\nresult = 1\n\nfor p in primes:\n    dict[p] = dict.get(p, 0) + 1\n\nmult = 1\nfor x in dict.values():\n    mult *= x + 1\n    mult %= 2*(10**9+6)\n\nfor x, y in dict.items():\n    result *= pow(x, (y*mult)//2, 10**9 + 7)\n    result %= 10**9 + 7\n\nprint(result)", "n = int(input())\ns = input().split()\nm = [-1]\nch = 1\nmd = 1000000007\nfor i in range(n):\n    m.append(int(s[i]))\n    ch = (ch*int(s[i])) % md\nm.sort()\nkol = 1\nz = 1\nkolraz = 0\nfl = 1\nsq = 1\nfor i in range(2, n+1):\n    if m[i] == m[i-1]:\n        kol += 1\n    else:\n        for j in range(kol//2):\n            sq = (sq * m[i-1]) % md\n        if kol % 2 == 1:\n            fl = 0\n        z *= (kol+1)\n        kol = 1\n        kolraz += 1\nz *= (kol+1)\nfor j in range(kol//2):\n    sq = (sq * m[n]) % md\nif kol % 2 == 1:\n    fl = 0\nres = 1\nkol = z\nkol //= 2\nif fl:\n    res = sq\nwhile kol:\n    if kol & 1:\n        res = (res*ch) % 1000000007\n    ch = (ch*ch) % md\n    kol >>= 1\nprint(res)\n", "mbase = 10**9+7\nnof = int(input())\nfacts = [int(x) for x in input().split()]\n\npmap = {}\nfor p in facts:\n\tpmap[p] = pmap.get(p, 0) + 1\n\nonepprod = 1\nfor (p, q) in pmap.items():\n\tonepprod*= q+1\n\tonepprod%= 2*(mbase-1)\n\nres = 1\nfor (p, q) in pmap.items():\n\tres*= pow(p, (q*onepprod)//2, mbase)\n\tres%= mbase\n\nprint(res)", "from collections import Counter\nfrom functools import reduce\n\ndef main():\n    input()\n    MOD = int(1e9+7)\n    u = list(map(int,input().split()))\n    v = Counter(u)\n    e = reduce(lambda a,b: a*b,[it+1 for it in list(v.values())])\n    ans = 1\n    e %= 2*(MOD-1)\n    for a,b in list(v.items()):\n        ans = (ans*pow(a,(b*e)//2,MOD))%MOD\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
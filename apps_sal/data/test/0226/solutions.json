["n = int(input())\na = list(map(int, input().split()))\na = a[::-1]\nd = 0\nfor i in range(len(a)):\n    d = max(0 + d, a[i] + (sum(a[:i]) - d))\nprint(sum(a)-d, d)\n", "n = int(input())\nX = list(map(int, input().split()))\n\nali = [None]*(n+1)\nbob = [None]*(n+1)\n\nali[n] = 0\nbob[n] = 0\n\nfor i in range(n-1, -1, -1):\n\tbob[i] = max(bob[i+1], ali[i+1]+X[i])\n\tali[i] = sum(X[i:n]) - bob[i]\n\t\n#print(ali)\n#print(bob)\n\nprint(ali[0], bob[0], sep=' ')\n\t\n", "N = int(input())\nA = list(map(int, input().split()))\n\ns = [0]*(N+1)\ndp = [0]*(N+1)\nfor i in range(N-1, -1, -1):\n\tdp[i] = max(A[i] + s[i+1] - dp[i+1], dp[i+1])\n\ts[i] = s[i+1] + A[i]\nprint(s[0] - dp[0], dp[0])", "n = int(input())\nvs = list(map(int, input().split(' ')))\n\nrs = [0, 0]\n\nfor i in range(n-1, -1, -1):\n    rs = [\n        min(vs[i] + rs[0], rs[1]),\n        max(vs[i] + rs[0], rs[1])\n    ]\n\nprint(sum(vs) - rs[1], rs[1])\n", "n = int(input())\na = list(map(int, input().split()))\n\n\ndef max_revenue(i, a):\n    if i == len(a)-1:\n        return a[-1], 0\n    before = max_revenue(i+1, a)\n    take = a[i] + before[1], before[0]\n    give = before[0], a[i] + before[1]\n\n    if take[0] > give[0]:\n        return take\n    else:\n        return give\n\nr = max_revenue(0, a)\nprint(r[1], r[0])\n", "\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn=int(input())\n\npie=list(map(int,input().split()))\n\ndef dp(i):\n    # best result for this player\n    if i>=len(pie): return (0,0)\n    t1,t2=dp(i+1)\n    return (max(pie[i]+t2-t1,t1),t2+pie[i])\n\nt1,t2=dp(0)\n\nprint(t2-t1,t1)", "import math\nfrom random import random\n\ndef getInt():\n    return(int(input()))\n\ndef getInts():\n    line = input().split()\n    return [int(l) for l in line]\n\ndef getFloat():\n    return(float(input()))\n\ndef getFloats():\n    line = input().split()\n    return [float(l) for l in line]\n\ndef getStrings():\n    line = input().split()\n    return(line)\n\n\nN = getInt()\nvalues = getInts()\n\nnConsidered = 0\n#                nC, nO\nbestForChooserSoFar = [0, 0]\n\nfor i in range(len(values)):\n    v = values[len(values) - i - 1]\n    qsIfTaken = [v + bestForChooserSoFar[1], bestForChooserSoFar[0]]\n    qsIfGiven = [bestForChooserSoFar[0], v + bestForChooserSoFar[1]]\n\n    if(qsIfTaken[0] >= qsIfGiven[0]):\n        bestForChooserSoFar = qsIfTaken\n    else:\n        bestForChooserSoFar = qsIfGiven\n\nprint(str(bestForChooserSoFar[1]) + ' ' + str(bestForChooserSoFar[0]))", "N = int(input())\na = [int(i) for i in input().split()]\n\nsuffix = [a[-1]]\ntok = [a[-1]]\ntol = [0]\nbest = [a[-1]]\n\nfor x in reversed(a[:-1]):\n\t# keep\n\tkeep = x + suffix[-1] - best[-1]\n\tgive = best[-1]\n\tbest.append(max(keep,give))\n\ttok.append(keep)\n\ttol.append(give)\n\tsuffix.append(suffix[-1] + x)\n\n# print(best, tok, tol, suffix)\nprint(suffix[-1] - best[-1], best[-1])\n\t\n\n\n", "n = int(input())\na = [int(i) for i in input().split()]\na1 = [[-1] * 50, [-1] * 50]\ndef get(i, fl):\n    if i >= n:\n        return 0\n    if (a1[fl][i] != -1):\n        return a1[fl][i]\n    if fl == 0:\n        a1[fl][i] = max(a[i] + get(i + 1, 1), get(i + 1, 0))\n    else:\n        a1[fl][i] = min(a[i] + get(i + 1, 1), get(i + 1, 0))\n    return a1[fl][i]\n\nan = get(0, 0)\nprint(sum(a) - an, an)\n", "n = int(input())\ncake = list(map(int, input().split()))\ncake.reverse()\npref = [0]\nfor i in range(n):\n    pref.append(cake[i] + pref[-1])\ndp = [0] * n\ndp[0] = cake[0]\nfor i in range(1, n):\n    dp[i] = max(dp[i - 1], cake[i] + pref[i] - dp[i - 1])\nprint(pref[n] - dp[n - 1], dp[n - 1])", "import math\n\n\ndef main():\n    n = int(input())\n    slices = [int(x) for x in input().split()]\n    dp = [[[0,0], [0,0]] for i in range(n)]\n    dp[-1][0] = [slices[-1], 0]\n    dp[-1][1] = [0, slices[-1]]\n    for i in range(n-2, -1, -1):\n        for j in range(0, 2):\n            take = slices[i] + dp[i+1][1-j][j]\n            do_not_take = dp[i+1][j][j]\n            if take > do_not_take:\n                dp[i][j][j] = take\n                dp[i][j][1-j] = dp[i+1][1-j][1-j]\n            else:\n                dp[i][j][j] = do_not_take\n                dp[i][j][1-j] = slices[i] + dp[i+1][j][1-j]\n    print(dp[0][1][0], dp[0][1][1])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "a = int(input())\nb = list(map(int, input().split()))\nsumA = 0\nsumB = 0\nfor i in range( a ):\n    if b[a-1-i] > abs(sumA - sumB):\n        sumA += b[a-1-i]\n        sumA, sumB = sumB, sumA\n    else:\n        sumA += b[a-1-i]\nprint(min(sumA,sumB), max(sumA, sumB))", "def maximum_pie_consumption(pies):\n    c = len(pies) - 1\n    toke = wait = 0\n    for p in reversed(pies):\n        if toke < p + wait:\n            toke, wait = wait + p, toke\n        else:\n            wait += p\n    return wait, toke\n\ndef __starting_point():\n    input()\n    pies = list(map(int, input().strip().split()))\n    print(\" \".join(map(str, maximum_pie_consumption(pies))))\n\n__starting_point()", "n = int(input())\npies = [int(x) for x in input().split()]\n\nd = {}\nd[0] = pies[-1]\n\nfor i in range(1, n):\n    d[i] = max(sum(pies[-1-i:]) - d[i-1], d[i-1])\n\ns = sum(pies)\n\nres = d[n-1]\n\nprint(s - res, res)\n", "def check(i, bob):\n    if i >= n:\n        return 0, 0\n    if dp[bob][i] != (-1, -1):\n        return dp[bob][i]\n    if bob:\n        x = check(i+1, False)\n        y = check(i+1, True)\n        if x[0]+arr[i] >= y[0]:\n            ret = x[0]+arr[i], x[1]\n        else:\n            ret = y[0], y[1]+arr[i]\n    else:\n        x = check(i+1, True,)\n        y = check(i+1, False,)\n        if x[1]+arr[i] >= y[1]:\n            ret = x[0], x[1]+arr[i]\n        else:\n            ret = y[0]+arr[i], y[1]\n    dp[bob][i] = ret\n    return ret\n\n\nn = int(input())\n\ndp = [(-1, -1)]*n\ndp = [dp, dp.copy()]\n\narr = list(map(int, input().split()))\nans = check(0, True)\nprint(ans[1], ans[0])\n", "n = int(input())\na = list(map(int, input().split()))\na.reverse()\n\nd = [0 for i in range(n)]\nd[0] = [a[0], 0]\n\nfor i in range(1, n):\n    d[i] = [max(d[i-1][0], d[i-1][1] + a[i]), min(d[i-1][0], d[i-1][1] + a[i])]\n\nprint(d[-1][1], d[-1][0])", "n = int(input())\na = list(map(int, input().split()))\nx = s = 0\nfor ai in reversed(a):\n    x = max(x, ai + s - x)\n    s += ai\n\nprint(s - x, x)\n", "\ndef dp(a, i,control):\n    if i >= len(a):\n        return 0;\n    if dp_list[control][i] != -1:\n        return dp_list[control][i]\n    else:\n        if control:\n            res = max(a[i] + dp(a, i+1, False), dp(a , i+1 , True))\n        else:\n            res = min(dp(a, i+1, True), a[i] + dp(a , i+1 , False))\n        dp_list[control][i] = res\n        return dp_list[control][i]\n\nn = int(input())\ndp_list = [list(-1 for i in range(n)) , list(-1 for i in range(n)) ]\na = list(map(int, input().split(\" \")))\nres = dp(a , 0, True)\nprint(\"%s %s\" %(sum(a) - res , res ))", "\n\nimport sys\n\ncache = {}\n\ndef max_possible(pie_slices, current_slice, pre_sums):\n\n    if current_slice in cache:\n        return cache[current_slice]\n\n    if len(pie_slices) - 1 == current_slice:\n        return pie_slices[current_slice]\n\n\n    max_score = -1\n    for cs in range(current_slice, len(pie_slices) - 1):\n        score = pie_slices[cs] + pre_sums[cs + 1] - max_possible(pie_slices, cs + 1, pre_sums)\n\n        if score > max_score:\n            max_score = score\n\n    # if the last element gives the highest score\n    if max_score < pie_slices[-1]:\n        max_score = pie_slices[-1]\n\n    cache[current_slice] = max_score\n\n    return max_score\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n\n    pie_slices = [int(tok) for tok in sys.stdin.readline().strip().split()]\n\n    pre_sums = [sum(pie_slices[i:]) for i in range(len(pie_slices))]\n\n    b = max_possible(pie_slices, 0, pre_sums)\n    print(sum(pie_slices) - b, b)\n\n\n\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nn = list(map(int,input().split(\" \")))\n\nif N == 1:\n    ans = [0, n[0]]\nelif N == 2:\n    ans = [min(n), max(n)]\nelse:\n    # print(n)\n    n.reverse()\n    f = max(n[0], n[1]) # f2\n    s = n[0] + n[1] # s2\n    for i in range(2, N):\n        f = max(n[i] + s - f, f)\n        s += n[i]\n    # print(f)\n    # print(s)\n    ans = [s-f, f]\n        \nprint(\" \".join(map(str,ans)))\n\n# assume f(n) is the optimal strategy for the remaning n pies, x_n, x_n-1, ...., x_1\n#\n# s(n) = sum(x_1,..., x_n)\n# f(1) = x1\n# f(2) = max(x2, x1)\n# f(3) = max(x3 + s(2) - f(2), f(2))\n# f(4) = max(x4 + s(3) - f(3), f(3))\n", "'''\ncodeforces.com/problemset/problem/859/C\nauthor: latesum\n'''\nn = int(input())\nv = list(map(int,input().split()))\nv.reverse()\nans = [0, 0]\nfor i in range(n):\n    if ans[1] + v[i] > ans[0]:\n        t = ans[1] + v[i]\n        ans[1] = ans[0]\n        ans[0] = t\n    else:\n        ans[1] += v[i]\nprint(ans[1], ans[0])\n", "n = int(input())\na = [int(i) for i in input().split()]\nscore = a[n - 1]\ntotal = a[n - 1]\n\nfor i in range(n - 2, -1, -1):\n    new_score = a[i] + total - score\n    if new_score > score:\n        score = new_score\n    total += a[i]\n\nprint(total - score, score)", "n=int(input())\na=list(map(int,input().split()))[::-1]\nif n!=1:\n    summax,summin=max(a[0],a[1]),min(a[0],a[1])\nelse:\n    summin=0;summax=a[0]\nfor i in range(2,n):\n    if summax<summin + a[i]:\n        summax,summin=summin + a[i],summax\n    else:\n        summin=summin+a[i]\nprint(summin,summax)", "n = int(input())\npieces = list(map(int, input().split()))\n\nreversed_pieces = list(reversed(pieces))\n\nTOTAL = []\n\ncurrent_total = 0\nfor piece in reversed_pieces:\n    current_total += piece\n    TOTAL.append(current_total)\n\nHAS_TOKEN = 0\nNO_TOKEN = 1\n\ndp_alice = [[0] * n, [0] * n]\ndp_bob = [[0] * n, [0] * n]\n\n\ndp_alice[HAS_TOKEN][0] = dp_bob[HAS_TOKEN][0] = reversed_pieces[0]\ndp_alice[NO_TOKEN][0] = dp_bob[NO_TOKEN][0] = 0\n\nfor i in range(1, n):\n    dp_alice[HAS_TOKEN][i] = max(dp_alice[HAS_TOKEN][i-1], dp_alice[NO_TOKEN][i-1] + reversed_pieces[i])\n    dp_bob[HAS_TOKEN][i] = max(dp_bob[HAS_TOKEN][i-1], dp_bob[NO_TOKEN][i-1] + reversed_pieces[i])\n\n    dp_alice[NO_TOKEN][i] = TOTAL[i] - dp_bob[HAS_TOKEN][i]\n    dp_bob[NO_TOKEN][i] = TOTAL[i] - dp_alice[HAS_TOKEN][i]\n\nprint(dp_alice[NO_TOKEN][-1], dp_bob[HAS_TOKEN][-1])\n"]
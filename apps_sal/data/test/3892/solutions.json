["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\nmii=lambda:list(map(int,input().split()))\n\nn,m=mii()\na=[[] for _ in range(n)]\nc=[123456 for _ in range(n)]\nfor _ in range(m):\n    u,v=mii()\n    u%=n\n    v%=n\n    if v<u: v+=n\n    a[u].append(v)\n    if c[u]>v: c[u]=v\n\nans=[]\nfor i in list(range(1,n))+[0]:\n    out=0\n    for j in range(i,n):\n        if not a[j]: continue\n        tmp=(j-i)+(len(a[j])-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(1,i,j,tmp)\n    for j in range(i):\n        if not a[j]: continue\n        tmp=(j+n-i)+(len(a[j])-1)*n+(c[j]-j)\n        out=max(out,tmp)\n        #print(2,i,j,tmp)\n    ans.append(out)\nprint(\" \".join(map(str,ans)))\n", "from collections import defaultdict as dd, deque\n\nn,m = list(map(int,input().split()))\n\nS = dd(list)\n\nfor _ in range(m):\n    start,dest = list(map(int,input().split()))\n    S[start-1].append(dest-1)\n\nclosest = [0]*n\nfor i in range(n):\n    if S[i]:\n        closest[i] = min((j-i)%n for j in S[i])\n\nR = [0]*n\nfor start in range(n):\n    mx = 0\n    for di in range(n):\n        i = (start + di)%n\n        cost = di + (len(S[i])-1)*n + closest[i]\n        mx = max(mx, cost)\n    R[start] = mx\n\nprint(' '.join([str(x) for x in R]))\n\n\n\n", "n,m=map(int,input().split())\nstations=[]\nfor i in range(n):\n    stations.append([])\nfor i in range(m):\n    a,b=map(int,input().split())\n    stations[a-1].append((b-a)%n)\nmaxes=[]\nfor i in range(n):\n    if len(stations[i])>0:\n        big=min(stations[i])\n    else:\n        big=0\n    maxes.append(n*max(len(stations[i])-1,0)+big)\nout=[]\nnew=maxes[:]\nbig=0\nfor j in range(n):\n    if new[j]+j>big and new[j]>0:\n        big=new[j]+j\ncurr=big\nout.append(str(curr))\nfor i in range(n-1):\n    if maxes[i]>0:\n        curr=max(curr-1,maxes[i]+n-1)\n    else:\n        curr=curr-1\n    out.append(str(curr))\nprint(\" \".join(out))", "def dist(a,b):\n    return (b-a)%n\n\nn, m = map(int, input().split())\n\ncnd = [0 for x in range(n+1)]\nmn = [5000 for x in range(n+1)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    # print(a,b,dist(a,b))\n    cnd[a] += 1\n    mn[a] = min(mn[a], dist(a,b))\n# print(mn)\n# print(cnd)\n\nfor i in range(1,n+1):\n    ans = 0\n    for j in range(1,n+1):\n        if cnd[j] > 0:\n            ans = max(ans, dist(i,j) + n*(cnd[j]-1) + mn[j])\n    print(ans, end=\" \")\n", "def dista(start, n):\n    return lambda end: n - (start - end) if(start > end) else end - start\n\nn, m = list(map(int,input().split(' ')))\ndicta = [[] for i in range(n+1)]\nfor i in range(m):\n    s, d = list(map(int,input().split(' ')))\n    dicta[s].append(d)\nfor i in range(n+1):\n    dicta[i].sort(key = dista(i, n))\nmaxlen = max((list(map(len, dicta))))\n\n\nresult = (maxlen-1)*n\nminadd = 0\n\nansans = []\nfor k in range(1, n+1):\n    disk = dista(k, n)\n    minadd = 0\n    for i in range(1, n+1):\n        lndicta = len(dicta[i])\n        tmp = 0\n        if(lndicta == maxlen-1):\n            if lndicta != 0:\n                tmp = min([(disk(i) + dista(i, n)(j)) for j in dicta[i]]) - n\n        elif(lndicta == maxlen):\n            tmp = min([(disk(i) + dista(i, n)(j)) for j in dicta[i]])\n        if(tmp > minadd):\n            minadd = tmp\n    ansans.append(str(minadd + result))\n\nprint(' '.join(ansans))\n", "(n, m), count, length = list(map(int, input().split())), {}, {}\nfor _ in range(m):\n\ta, b = list(map(int, input().split()))\n\tcount[a] = count[a]+1 if a in count.keys() else 1\n\tlength[a] = min(length[a], (b+n-a) % n) if a in length.keys() else (b+n-a) % n\nfor i in range(1, n+1):\n\t\tprint(max((length[j] + j-i + n*(count[j]-(j >= i)) if count[j] != 0 else 0 for j in count.keys())), end=' ')", "def __starting_point():\n\tfrom sys import stdin\n\tn, m = list(map(int, stdin.readline().split()))\n\tc = {}\n\tfor _ in range(m):\n\t\ta, b = list(map(int, stdin.readline().split()))\n\t\tif (a-1) not in c.keys():\n\t\t\tc[a-1] = []\n\t\tx = b-a + (n if b<a else 0)\n\t\tc[a-1].append(x)\n\n\tfor k, l in c.items():\n\t\tc[k] = min(l) + ((len(l)-1)*n)\n\n\tout_ = []\n\tfor x in range(n):\n\t\tres = 0\n\t\tfor y, v in c.items():\n\t\t\ts = y-x + (n if y<x else 0)\n\t\t\tres = max(res, v+s)\n\t\tout_.append(res)\n\n\tprint(*out_)\n__starting_point()", "n, m = map(int, input().split())\n\na = [[] for i in range(5010)]\n\nfor i in range(m):\n\tx, y = map(int, input().split())\n\tif y < x:\n\t\ta[x].append(n - x + y)\n\telse:\n\t\ta[x].append(y - x)\n\n\nfor i in range(1, n + 1):\n\ta[i].sort()\n\nmx = int(-1e9)\n\nfor i in range(1, n + 1):\n\tif len(a[i]):\n\t\tmx = n * (len(a[i]) - 1) + a[i][0]\n\telse:\n\t\tmx = 0\n\t\n\tk = 1\n\tl = i + 1\n\tif l == n + 1:\n\t\tl = 1\n\t\n\twhile l != i:\n\t\tif len(a[l]):\n\t\t\tmx = max(mx, n * (len(a[l]) - 1) + a[l][0] + k)\n\t\t\t\n\t\tk += 1\n\t\tl += 1\n\t\tif l == n + 1:l = 1\n\tprint(mx, end = \" \")\n\nprint()\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[21]:\n\n\nimport copy\nr = input().split()\nn = int(r[0])\nm = int(r[1])\nar = [[] for i in range(n)]\n#print(ar)\nfor i in range(m):\n   r = input().split()\n   a = int(r[0]) \n   b = int(r[1])\n   ar[a - 1].append(b - 1)\n#   print(ar)\ntrain = []\nresult = []\nfor i in range(n):\n    count = m\n    arr = copy.deepcopy(ar)\n    time = copy.deepcopy(ar)\n    ind = i\n    res = 0\n    for j in range(n):\n        for k in range(len(arr[j])):\n            if arr[j][k] >= j:\n                time[j][k] = arr[j][k] - j\n            else:\n                time[j][k] = n - 1 - j + arr[j][k] + 1\n#print(time)                \n    while (count != 0) or (len(train) != 0):\n        if len(arr[ind]) != 0:\n            train.append(arr[ind][time[ind].index(max(time[ind]))])\n#        print(time[ind].index(max(time[ind])))\n#        print(max(time[ind]))\n            del arr[ind][time[ind].index(max(time[ind]))]\n            del time[ind][time[ind].index(max(time[ind]))]\n#        print(arr)\n#        print(time)\n            count -= 1\n#    print(train)    \n        while train.count(ind) != 0:\n            train.remove(ind)\n#        print(train)\n        ind += 1\n        if ind == len(arr): \n            ind = 0\n        res += 1\n    result.append(res - 1)    \n#    print(ind)\n#    print(res) \nprint(' '.join(map(str, result)))\n#print(ind)\n    \n\n\n# \n\n# ## \n\n# In[ ]:\n\n\n\n\n", "n,m=list(map(int,input().split()))\nms,md=[n-1 for i in range(n+1)],[-1 for i in range(n+1)]\ndef distance(sfrom,sto):\n    nonlocal n\n    return sto-sfrom if sto>=sfrom else sto+n-sfrom \nfor i in range(m):\n    c,d=list(map(int,input().split()))\n    md[c]+=1\n    ms[c]=min(distance(c,d),ms[c])\nfor i in range(1,n+1):\n    md[i]=n*md[i]+ms[i]\nans=[]\nfor i in range(1,n+1):\n    ans.append(max([md[k]+distance(i,k)if md[k]>0 else 0 for k in range(1,n+1)]))\nprint(' '.join([str(i)for i in ans]))\n    \n\n", "def distance(b, a, n):\n    return b - a if b >= a else b + n - a\n\n\nn, m = list(map(int, input().split()))\ndic_last_candy = dict()\ndict_node = dict()\ns = ''\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    c = dict_node.get(a, 0)\n    c += 1\n    dict_node[a] = c\n    last_candy = dic_last_candy.get(a, 0)\n    if last_candy:\n        c1 = distance(last_candy, a, n)\n        c2 = distance(b, a, n)\n        if c2 < c1:\n            last_candy = b\n    else:\n        last_candy = b\n    dic_last_candy[a] = last_candy\n\nfor i in range(1, n + 1):\n    c = dict_node.get(i, 0)\n    if c:\n        now_step = (c - 1) * n + distance(dic_last_candy[i], i, n)\n        dict_node[i] = now_step\ns = ''\nfor i in range(1, n + 1):\n    now_step = dict_node.get(i, 0)\n    min_step = now_step\n    for j in range(1, n + 1):\n        if dict_node.get(j, 0):\n            now_step = dict_node.get(j, 0) + distance(j, i, n)\n            if min_step < now_step:\n                min_step = now_step\n    s += ' ' + str(min_step)\nprint(s[1:])\n", "def dist(a, b):\n    return (b - a) % n\n\nn, m = list(map(int, input().split(\" \")))\n\nsweets = {i: [] for i in range(n)}\nfor i in range(m):\n    s, t = list(map(int, input().split(\" \")))\n    sweets[s - 1].append(t - 1)\n\nt = {i: 0 for i in range(n)}\n\nfor i in range(n):\n    sweets[i] = sorted(sweets[i], key=lambda x: -dist(i, x))\n    if len(sweets[i]):\n        t[i] = (len(sweets[i]) - 1) * n + dist(i, sweets[i][-1])\n\nresult = []\nfor s in range(n):\n    max_dist = 0\n    for i in range(n):\n        if t[i] and t[i] + dist(s, i) > max_dist:\n            max_dist = t[i] + dist(s, i)\n    result.append(max_dist)\n\nprint(\" \".join(map(str, result)))", "import copy\n\nn, m = list(map(int, input().strip().split()))\nitems = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = list(map(int, input().strip().split()))\n    items[u - 1].append(v - 1)\nfor i, line in enumerate(items):\n    pairs = []\n    for v in line:\n        pairs.append((v - i, v) if v > i else (n - i + v, v))\n    pairs = sorted(pairs, reverse=True)\n    items[i] = [pair[1] for pair in pairs]\nans = []\nfor s in range(n):\n    need = m\n    items_idx = [0 for _ in range(n)]\n    items_cnt = [0 for _ in range(n)]\n    items_tot = 0\n    ans.append(-1)\n    while need > 0 or items_tot > 0:\n        idx = s % n\n        if items_idx[idx] < len(items[idx]):\n            items_cnt[items[idx][items_idx[idx]]] += 1\n            items_idx[idx] += 1\n            items_tot += 1\n            need -= 1\n        items_tot -= items_cnt[idx]\n        items_cnt[idx] = 0\n        s += 1\n        ans[-1] += 1\n    ans[-1] = max(0, ans[-1])\nprint(' '.join(map(str, ans)))\n", "def prog():\n    n,m = map(int,input().split())\n    d = {i:[] for i in range(1,n+1)}\n    from sys import stdin\n    for i in range(m):\n        a,b = map(int,stdin.readline().split())\n        d[a].append(b)\n    res = []\n    for i in range(1,n+1):\n        lst=[]\n        for j,x in enumerate(d):\n            mn,k=100000,-1\n            for k,y in enumerate(d[x]):\n                if x<y:\n                    a=y-x\n                else:\n                    a=n-x+y\n                if a<mn:\n                    mn=a\n            if k>-1:\n                if i<=x:\n                    b=x-i\n                else:\n                    b=n-i+x\n                lst.append(k*n+mn+b)\n        res.append(max(lst))\n    print(*res)\nprog()", "def distance(fro ,to):\n    nonlocal n\n    return to - fro if to-fro>=0 else n+to-fro\nn , m =  list(map(int,input().split()))\ncount=[-1 for i in range(n+1)]\ndis=[n for i in range(n+1)]\nans=[]\nfor i in range(1,m+1):\n    a , b = list(map(int,input().split()))\n    dis[a] = min(distance(a,b),dis[a])\n    count[a] +=1\n#    print(a,count[a])\n#    print(dis[a],a,n,b)\n#print(dis)    \nfor i in range(1,n+1):\n    dis[i] = dis[i]+ n*count[i]\n#    print(dis[i],count[i],i)\n#print(dis) \nfor i in range(1,n+1):\n    ans.append(max([dis[k]+distance(i,k) if dis[k]>0 else 0 for k in range(1,n+1)]))\nprint(*ans)    \n    \n    \n", "def distance(fro ,to):\n    nonlocal n\n    return to - fro if to-fro>=0 else n+to-fro\nn , m =  list(map(int,input().split()))\ncount=[-1 for i in range(n+1)]\ndis=[n for i in range(n+1)]\nans=[]\nfor i in range(1,m+1):\n    a , b = list(map(int,input().split()))\n    dis[a] = min(distance(a,b),dis[a])\n    count[a] +=1\n#    print(a,count[a])\n#    print(dis[a],a,n,b)\nfor i in range(1,n+1):\n    dis[i] = dis[i]+ n*count[i]\n#    print(dis[i],count[i],i)\n#print(dis) \nfor i in range(1,n+1):\n    ans.append(max([dis[k]+distance(i,k) if dis[k]>0 else 0 for k in range(1,n+1)]))\nprint(*ans)    \n    \n    \n", "N, m = [int(value) for value in input().split()]\n\ncandies = []\nfor _ in range(N):\n    candies.append([])\n\nfor _ in range(m):\n    start, end = [int(value) for value in input().split()]\n    candies[start - 1].append(end - 1)\n\nmin_distantions = []\n\nfor start_pos in range(N):\n    min_distantion = 0\n\n    for shift in range(N):\n        current_pos = (start_pos + shift) % N\n        count_candies = len(candies[current_pos])\n\n        if count_candies > 0:\n            closest_candy = N - 1\n            for candy_destination in candies[current_pos]:\n                closest_candy = min(closest_candy,\n                                    (N + candy_destination - current_pos) % N)\n\n            min_distantion = max(min_distantion, closest_candy +\n                                 shift + N * (count_candies - 1))\n\n    min_distantions.append(min_distantion)\n\nprint(' '.join([str(distantion) for distantion in min_distantions]))\n", "import sys\nfrom collections import defaultdict,deque\nn,m=list(map(int,sys.stdin.readline().split()))\ndist=defaultdict(list)\nsweet=defaultdict(list)\nfor i in range(m):\n    u,v=list(map(int,sys.stdin.readline().split()))\n    sweet[u].append(v)\n    dist[u].append(0)\nfor i in sweet:\n    le=len(sweet[i])\n    for j in range(le):\n        if sweet[i][j]>=i:\n            dist[i][j]=sweet[i][j]-i\n        else:\n            dist[i][j]=n-(i-sweet[i][j])\n    dist[i].sort()\n#print(dist,'dits')\nfor i in dist:\n    count=0\n    le=len(dist[i])\n    for k in range(le-1,-1,-1):\n        dist[i][k]+=count*n\n        count+=1\n    dist[i].sort()\nvis=defaultdict(int)\nfor i in dist:\n    if dist[i]==[]:\n        vis[i]=0\n    else:\n        vis[i]=dist[i][-1]\n#print(dist,'dist')\n#print(vis,'vis')\nans=[0 for _ in range(n)]\nfor i in range(1,n+1):\n    cur=0\n    #print(i,'i')\n    for k in range(1,n+1):\n        new=0\n        if k>=i:\n            if vis[k]!=0:\n                new=vis[k]+k-i\n                #print(new,'new',k,'k')\n        else:\n            if vis[k]!=0:\n                new=vis[k]+(n)-(i-k)\n                #print(new,'new',k,'k')\n        cur=max(cur,new)\n    ans[i-1]=cur\nprint(*ans)\n"]
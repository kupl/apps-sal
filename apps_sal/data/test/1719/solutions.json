["n = int(input())\nmod = 10**9+7\na = []\nl = [\"A\",\"C\",\"G\",\"T\"]\nban = [\"AAGC\",\"CAGC\",\"GAGC\",\"TAGC\",\"AGCA\",\"AGCC\",\"AGCG\",\"AGCT\",\"AGAC\",\"CGAC\",\"GGAC\",\"TGAC\",\"GACA\",\"GACC\",\"GACG\",\"GACT\",\"AACG\",\"CACG\",\"GACG\",\"TACG\",\"ACGA\",\"ACGC\",\"ACGG\",\"ACGT\",\"ATGC\",\"ACGC\",\"AGGC\",\"AGTC\",\"AGGC\",\"AGAC\"]\nfor i in l:\n    for j in l:\n        for k in l:\n            a.append(i+j+k)\ndp = [[0]*64 for _ in range(n+1)]\nfor i in range(64):\n    if (a[i]==\"AGC\" or a[i]==\"ACG\" or a[i]==\"GAC\"):\n        continue\n    dp[3][i] = 1\nfor i in range(4,n+1):\n    for j in range(64):\n        for k in l:\n            b = a[j]+k\n            if b in ban:\n                continue\n            else:\n                dp[i][a.index(b[1:])] += dp[i-1][j]\n                dp[i][a.index(b[1:])] %= mod\nprint((sum(dp[-1])%mod))\n        \n", "n=int(input())\nmod = 10**9+7\ndp = [{} for _ in range(n+1)]\n\nmoji = ['A','C','G','T']\nfor c1 in moji:\n    for c2 in moji:\n        for c3 in moji:\n            mojis = c1+c2+c3\n            if mojis in ['AGC','GAC','ACG']:continue\n            if mojis in dp[3]:\n                dp[3][mojis] += 1\n            else:\n                dp[3][mojis] = 1\n\nfor i in range(4,n+1):\n    for c in moji:\n        for c1 in moji:\n            for c2 in moji:\n                for c3 in moji:\n                    mojis = c1+c2+c3\n                    if mojis in ['AGC','GAC','ACG']:continue\n                    nowmoji = c2+c3+c\n                    if nowmoji in ['AGC','GAC','ACG']:continue\n                    if c1 =='A' and c3 == 'G' and c == 'C':continue\n                    if c1 =='A' and c2 == 'G' and c == 'C':continue\n                    if nowmoji in dp[i]:\n                        dp[i][nowmoji] += dp[i-1][mojis]%mod\n                        dp[i][nowmoji] %=mod\n                    else:\n                        dp[i][nowmoji] =  dp[i-1][mojis]%mod\n                        dp[i][nowmoji] %=mod\n\nprint(sum(dp[n].values())%mod)", "n = int(input())\nmod = 10**9+7\n  \ndp = [[0]*4 for i in range(n)]\nfor i in range(4):\n  dp[0][i] = 1\n  dp[1][i] = 4\n  dp[2][i] = 16\n  \ndp[2][1] -= 2\ndp[2][2] -= 1\n  \nfor i in range(3,n):\n  for j in range(4):\n    dp[i][j] = sum(dp[i-1])%mod\n  dp[i][1] -= dp[i-2][0] #AGC\n  dp[i][1] -= dp[i-2][2] #GAC\n  dp[i][1] -= dp[i-3][0]*3 #AGTC,AGGC,ATGC\n  dp[i][2] -= dp[i-2][0] #ACG\n  dp[i][2] += dp[i-3][2] #GACG\n  \nprint(sum(dp[n-1])%mod)", "MOD=10**9+7\nN=int(input())\n\ndp=[[[[0]*5 for i in range(5)] for i in range(5)] for i in range(N+1)]\n\ndp[0][0][0][0]=1\n\nfor i in range(N):\n    for j in range(5):\n        for k in range(5):\n            for l in range(5):\n                for m in range(1,5):\n                    if (k==1 and l==2 and m==3) or (k==2 and l==1 and m==3) or (k==1 and l==3 and m==2):\n                        continue\n                    if (j==1 and k==2 and m==3) or (j==1 and l==2 and m==3):\n                        continue\n                    dp[i+1][k][l][m]=(dp[i+1][k][l][m]+dp[i][j][k][l])%MOD\nans=0\nfor k in range(5):\n    for l in range(5):\n        for m in range(5):\n            ans=(ans+dp[N][k][l][m])%MOD\nprint(ans)", "#!/usr/bin/env python3\nimport copy\n\nn = int(input())\n\nmod = 10**9+7\n\nmemo = {}\n\nbanned = {'ACTG', 'TCAG', 'GCAG', 'TACG', 'AACG', 'ACAG', 'GAGC', 'CACG',\n          'AGC', 'ATCG', 'ACCG', 'CAG', 'GACG', 'CCAG', 'AAGC', 'ACG', 'TAGC'}\n\ncount = 0\n\n\ndef dp(lettrs, state):\n\n    if state in banned:\n        return 0\n    if lettrs == 0:\n        return 1\n    if (lettrs, state) in memo:\n        return memo[lettrs, state]\n\n    ans = 0\n    for c in \"ACGT\":\n        ans += dp(lettrs-1, (state+c)[-4:])\n        ans %= mod\n    ans %= mod\n    memo[lettrs, state] = ans\n\n    return ans\n\n\nprint((dp(n, \"\")))\n# print(memo)\n# AG = [0, 1]\n# for i in range(2, n):\n#     ans_pre = copy.deepcopy(ans)\n#     ans = copy.deepcopy(ans_base)\n#     print(ans_pre)\n#     for key in ans_pre.keys():\n\n#         for l in [\"A\", \"C\", \"G\", \"T\"]:\n\n#             if key+l in miss:\n#                 print(key+l)\n#                 continue\n#             else:\n#                 # print((key+l))\n#                 ans[(key+l)[1:]] += ans_pre[key] % mod\n#     AG.append(ans[\"AG\"])\n#     print(AG)\n#     ans[\"AC\"] -= AG[-3]\n#     ans[\"GC\"] -= AG[-3]\n#     ans[\"TC\"] -= AG[-3]\n\n\n# print(sum(ans.values()) % mod)\n\n# AA\n# AC\n# AG\n# AT\n# CA\n# CC\n# CG\n# CT\n# GA\n# GC\n# GG\n# GT\n# TA\n# TC\n# TG\n# TT\n", "N = int(input())\n\nMOD = 10 ** 9 + 7\n\ntotal = 4 ** N\n\nif N == 3:\n    sub = 3\n    ans = total - sub\n    \nelif N >= 4:\n    last_three = [{} for _ in range(N - 3 + 1)]\n    for n in range(N - 3 + 1):\n        for i in ['A', 'G', 'C', 'T']:\n            for j in ['A', 'G', 'C', 'T']:\n                for k in ['A', 'G', 'C', 'T']:\n                    if [i, j, k] != ['A', 'G', 'C'] and [i, j, k] != ['A', 'C', 'G'] and [i, j, k] != ['G', 'A', 'C']:\n                        last_three[n][\"\".join([i, j, k])] = 0\n    for k in last_three[0].keys():\n        last_three[0][k] = 1\n    for i in range(4, N + 1):\n        for k in last_three[i - 4].keys():\n            if k[1] == 'A' and k[2] == 'G':\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n            elif k[1] == 'A' and k[2] == 'C':\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'C'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'C'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n            elif k[1] == 'G' and k[2] == 'A':\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n            elif k[0] == 'A' and k[2] == 'G':\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n            elif k[0] == 'A' and k[1] == 'G':\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n            else:\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'C'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] += last_three[i - 4][k] % MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'A'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'G'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'C'])] %= MOD\n                last_three[i - 3][\"\".join([k[1], k[2], 'T'])] %= MOD\n\n    ans = sum(last_three[N - 3].values()) % MOD\n\nprint(ans)            ", "import itertools\n\nACGT = ['A', 'C', 'G', 'T', '']\nMOD = 10 ** 9 + 7\n\nN = int(input())\n\ndp = [[[[0] * 5\n        for _ in range(5)]\n       for _ in range(5)]\n      for _ in range(N + 1)]\ndp[0][4][4][4] = 1\n\nfor i, p, q, r, s in itertools.product(list(range(N)), list(range(5)), list(range(5)), list(range(5)), list(range(4))):\n    if ACGT[q] + ACGT[r] + ACGT[s] not in {'AGC', 'GAC', 'ACG'} \\\n            and ACGT[p] + ACGT[r] + ACGT[s] != 'AGC' \\\n            and ACGT[p] + ACGT[q] + ACGT[s] != 'AGC':\n        dp[i + 1][q][r][s] += dp[i][p][q][r]\n        dp[i + 1][q][r][s] %= MOD\n\nprint((sum(sum(sum(y) for y in x) for x in dp[N]) % MOD))\n", "N=int(input())\nMOD=10**9+7\ndp=[[[[0]*5 for _ in range(5)] for _ in range(5)]for _ in range(N+1)]\nans=0\ndp[0][0][0][0]=1\nfor n in range(N):\n    for i in range(5):\n        for j in range(5):\n            for k in range(5):\n                for l in range(1,5):\n                    if j==1 and k==2 and l==3:continue\n                    if j==1 and k==3 and l==2:continue\n                    if j==3 and k==1 and l==2:continue\n                    if i==1 and j==3 and l==2:continue\n                    if i==1 and k==3 and l==2:continue\n                    dp[n+1][j][k][l]+=dp[n][i][j][k]\nfor j in range(1,5):\n    for k in range(1,5):\n        for l in range(1,5):\n            ans+=dp[N][j][k][l]\nprint(ans%MOD)", "N, MOD = int(input()), 10 ** 9 + 7\nmemo = [{} for i in range(N+1)]\n\ndef ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i-1], t[i] = t[i], t[i-1]\n        if ''.join(t).count('AGC') >= 1:\n            return False\n    return True\n\n\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    ret = 0\n    for c in 'ACGT':\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n    memo[cur][last3] = ret\n    return ret\nprint((dfs(0, 'TTT')))\n", "# \u96a3\u63a5\u3059\u308b2\u6587\u5b57\u306e\u5165\u308c\u66ff\u3048\u3067AGC\u3068\u306a\u308b\u30d1\u30bf\u30fc\u30f3(\u3082\u3057\u304f\u306fAGC\u305d\u306e\u3082\u306e)\n# AGC\n# ACG\n# GAC\n# AGGC\n# ACGC\n# ATGC\n# AGAC\n# AGGC\n# AGTC\n# \u4e0a\u8a18\u3092\u542b\u307e\u306a\u3044\u6587\u5b57\u5217\u3092\u6570\u3048\u308b\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nDIV = 10 ** 9 + 7\n\n# dp[i][a][b][c] = i\u6587\u5b57\u76ee\u306b\u3064\u3044\u3066\u30012\u3064\u524d\u304ca,1\u3064\u524d\u304cb,i\u6587\u5b57\u76ee\u304cd\u306e\u6570\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3082\u306e\u306e\u6570\n# 0:\"A\", 1:\"G\", 2:\"C\", 3:\"T\"\ndp = [[[[0] * 4 for b in range(4)] for a in range(4)] for i in range(N)]\n\nC = {0:\"A\", 1:\"G\", 2:\"C\", 3:\"T\", 4:\"\"}\nNG = set([\"AGC\",\"ACG\",\"GAC\",\"AGGC\",\"ACGC\",\"AGAC\",\"AGGC\",\"ATGC\",\"AGTC\"])\n\ndef check_ok(i,j,k,l = 4):\n  if (C[i] + C[j] + C[k] + C[l]) in NG:\n    return False\n  return True\n\n# 3\u6587\u5b57\u76ee\nfor i in range(4):\n  for j in range(4):\n    for k in range(4):\n      if check_ok(i,j,k):\n        dp[2][i][j][k] += 1\n\n# 4\u6587\u5b57\u76ee\u4ee5\u964d\u3092\u6c7a\u3081\u308b\nfor i in range(2, len(dp) - 1):\n  for a in range(4):\n    for b in range(4):\n      for c in range(4):\n        for k in range(4):\n          if check_ok(a,b,c,k) and check_ok(b,c,k):\n            dp[i + 1][b][c][k] += dp[i][a][b][c]\n            dp[i + 1][b][c][k] %= DIV\n        \nans = 0\nfor a in range(4):\n  for b in range(4):\n    for c in range(4):\n      ans += dp[-1][a][b][c]\n      ans %= DIV\n      \nprint(ans)", "def ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i - 1], t[i] = t[i], t[i - 1]\n        if 'AGC' in ''.join(t):\n            return False\n    return True\n\n\ndef main():\n    MOD = 10**9 + 7\n    N = int(input())\n    memo = [{} for _ in range(N + 1)]\n\n    def dfs(cur, last3):\n        if last3 in memo[cur]:\n            return memo[cur][last3]\n        if cur == N:\n            return 1\n        ret = 0\n        for c in 'ACGT':\n            if ok(last3 + c):\n                ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n        memo[cur][last3] = ret\n        return ret\n\n    print(dfs(0, 'TTT'))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N=int(input())\nmod=10**9+7\nmemo=[{}for _ in range(N+1)]\ndef ok(last4):\n    for i in range(4):\n        t=list(last4)\n        if i>=1:\n            t[i-1],t[i]=t[i],t[i-1]\n        if ''.join(t).count('AGC')>=1:\n            return False\n    return True\ndef dfs(cur,last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur==N:\n        return 1\n    ret=0\n    for c in 'AGCT':\n        if ok(last3+c):\n            ret+=dfs(cur+1,last3[1:]+c)\n            ret%=mod\n    memo[cur][last3]=ret\n    return ret\nprint(dfs(0,'TTT'))", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nINF = float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef main():\n    N = int(input())\n    # dp[i][j][k][l] := \u9577\u3055i\u306e\u6587\u5b57\u306b\u304a\u3044\u3066\uff0c\u5f8c\u308d\u304b\u30893\u3064\u76ee\u306e\u6587\u5b57\u304cj,\n    # \u5f8c\u308d\u304b\u30892\u3064\u76ee\u306e\u6587\u5b57\u304ck, \u5f8c\u308d\u304b\u30891\u3064\u306e\u6587\u5b57\u304cl\u306e\u6642\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\n    dp = [[[[0] * 5 for _ in range(5)] for _ in range(5)] for _ in range(N + 1)]\n\n    A = 1\n    G = 2\n    C = 3\n    T = 4\n\n    # \u6587\u5b57\u306e\u610f\u5473\u306f\uff0c0 => None, 1 => A, 2 => G, 3 => C, 4 => T\n    dp[0][0][0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(5):\n            for k in range(5):\n                for l in range(5):\n                    for m in range(1, 5):\n                        if k == A and l == G and m == C:\n                            continue\n                        if k == A and l == C and m == G:\n                            continue\n                        if k == G and l == A and m == C:\n                            continue\n                        if j == A and l == G and m == C:\n                            continue\n                        if j == A and k == G and m == C:\n                            continue\n\n                        dp[i][k][l][m] += dp[i - 1][j][k][l]\n                        dp[i][k][l][m] %= MOD\n\n    ans = 0\n    for j in range(1, 5):\n        for k in range(1, 5):\n            for l in range(1, 5):\n                ans += dp[-1][j][k][l]\n                ans %= MOD\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\n\nMOD = 10 ** 9 + 7\n\nN = int(input())\n\n\n\"\"\"dp = dict()\nfor c1 in \"ACGT\":\n    for c2 in \"ACGT\":\n        for c3 in \"ACGT\":\n            for c4 in \"ACGT\":\n                s = c1 + c2 + c3 + c4\n                if s[0:3] in (\"AGC\", \"ACG\", \"GAC\"):\n                    continue\n                if s[1:4] in (\"AGC\", \"ACG\", \"GAC\"):\n                    continue\n                if s in (\"AGGC\", \"AGTC\", \"ATGC\"):\n                    continue\n\n                dp[s] = 1\"\"\"\n\ndp = {\"TTT\": 1}\nfor _ in range(N):\n    new_dp = defaultdict(int)\n    for s, count in dp.items():\n        new_dp[s[1:] + 'A'] += count\n        new_dp[s[1:] + 'T'] += count\n        if s[1:] != \"AC\":\n            new_dp[s[1:] + 'G'] += count\n        if s not in (\"AGG\", \"AGT\", \"ATG\") and s[1:] not in (\"AG\", \"GA\"):\n            new_dp[s[1:] + 'C'] += count\n\n    dp = dict()\n    for k, v in new_dp.items():\n        dp[k] = v % MOD\n\nprint(sum(dp.values()) % MOD)", "N, MOD = int(input()), 10 ** 9 + 7\nmemo = [{} for i in range(N+1)]\n\ndef ok(last4):\n  for i in range(4):\n    t = list(last4)\n    if i >= 1:\n      t[i-1], t[i] = t[i], t[i-1] \n    if ''.join(t).count('AGC') >= 1:\n      return False\n  return True\n\ndef dfs(cur, last3):\n  if last3 in memo[cur]:\n    return memo[cur][last3]\n  if cur == N:\n    return 1\n  ret = 0\n  for c in 'ACGT':\n    if ok(last3 + c):\n      ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n  memo[cur][last3] = ret\n  return ret\n\nprint(dfs(0, 'TTT'))", "mod=10**9+7\nn=int(input())\ndp=[[0]*64 for _ in range(n+1)]\ndp[0][0]=1\n#3\u524d\u30012\u524d,1\u524d,\u4eca\u306e\u6587\u5b57\n#t=0,a=1,g=2,c=3\nban_list=[]\nfor i in range(256):\n\tp=[i//64%4,i//16%4,i//4%4,i%4]\n\tif p[1:]==[1,2,3] or p[1:]==[1,3,2] or p[1:]==[2,1,3]\\\n\tor (p[:2]==[1,2] and p[3]==3) or (p[0]==1 and p[2:]==[2,3]):\n\t\tban_list.append(i)\nfor i in range(n):\n\tfor j in range(4):\n\t\tfor k in range(64):\n\t\t\tthree=k*4%64+j\n\t\t\tfour=k*4+j\n\t\t\tif four not in ban_list:\n\t\t\t\tdp[i+1][three]+=dp[i][k]\n\t\t\t\tdp[i+1][three]%=mod\nans=0\nfor x in dp[-1]:\n\tans+=x\n\tans%=mod\nprint(ans)", "N = int(input())\ndp = [[0]*64 for i in range(N-2)]\n# 3\u9032\u6570\u3067\u7ba1\u7406\nmod = 10**9+7\n\nd = dict()\nd2 = dict()\nd2[0] = 'A'\nd2[1] = 'G'\nd2[2] = 'C'\nd2[3] = 'T'\nfor i in range(64):\n    k = i\n    ret = ''\n    for j in range(3):\n        ret += d2[k % 4]\n        k //= 4\n    d[i] = ret\n\n\nfor i in range(64):\n    if d[i] == 'AGC' or d[i] == 'GAC' or d[i] == \"ACG\":\n        continue\n\n    else:\n        dp[0][i] = 1\n\n\nfor i in range(N-3):\n    for j in range(64):\n        if dp[i][j] == 0:\n            continue\n        tmp = j // 4\n        for k in range(4):\n            idx = tmp + k * 16\n            if d[idx] == \"AGC\" or d[idx] == 'ACG' or d[idx] == \"GAC\" or (d[j][0] == 'A' and d[j][1] == 'G' and k == 2) or (d[j][0] == 'A' and d[j][2] == 'G' and k == 2):\n                #print(d[j] + d2[k])\n                continue\n            dp[i+1][idx] += dp[i][j]\n\n\nprint((sum(dp[-1]) % mod))\n", "def ch2int(ch):\n    if ch == 'A':\n        return 0\n    elif ch == 'C':\n        return 1\n    elif ch == 'G':\n        return 2\n    else:\n        return 3\n\n\ndef acgt2int(agct):\n    ret = 0\n    for ch in agct:\n        ret = (ret << 2) + ch2int(ch)\n    return ret\n\n\ndef int2acgt(val):\n    ret = []\n    tmp = val\n    for i in range(3):\n        amari = tmp % 4\n        if amari == 0:\n            ret.append('A')\n        elif amari == 1:\n            ret.append('C')\n        elif amari == 2:\n            ret.append('G')\n        else:\n            ret.append('T')\n        tmp //= 4\n    ret.reverse()\n    return ret\n\n\nn = int(input())\ndp = [[0] * 64 for _ in range(n)]\n\ndp[0][acgt2int('TTA')] = 1\ndp[0][acgt2int('TTC')] = 1\ndp[0][acgt2int('TTG')] = 1\ndp[0][acgt2int('TTT')] = 1\n\n\ndef is_valid(chs):\n    tmp = ''.join(chs)\n    ng = ['AGC', 'GAC', 'ACG', 'AAGC', 'ACGC', 'AGGC',\n          'ATGC', 'AGAC', 'AGCT', 'AGGC', 'AGTC']\n    for item in ng:\n        if item in tmp:\n            return False\n    return True\n\n\nfor i in range(1, n):\n    for j in range(64):\n        chs = int2acgt(j)\n        tmp = 0\n        for ch in ['A', 'C', 'G', 'T']:\n            my_chs1 = [ch] + chs\n            if is_valid(my_chs1):\n                tmp += dp[i-1][acgt2int(my_chs1[:-1])] % (10 ** 9 + 7)\n        dp[i][j] = tmp\n\nprint((sum(dp[-1]) % (10 ** 9 + 7)))\n", "import math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(self.n))\n        self.rank = [1] * n\n        self.count = n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.rank[p] += self.rank[q]\n        self.par[q] = p\n        self.count -= 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return self.rank[x]\n    def count(self):\n        return self.count\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass counting:\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n    def per(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nclass SegmentTree:\n    def __init__(self, lis, ele, op):\n        self.len = len(lis)\n        self.n = 1 << ((self.len - 1).bit_length())\n        self.op = op\n        self.ele = ele\n        self.tree = self._build(lis)\n    def _build(self, lis):\n        res_tree = [self.ele] * (self.n - 1) + lis + [self.ele] * (self.n - self.len)\n        for i in range(self.n - 2, -1, -1):\n            res_tree[i] = self.op(res_tree[i * 2 + 1], res_tree[i * 2 + 2])\n        return res_tree\n    def __get__(self, i):\n        return self.tree[self.n + i - 1]\n    def update(self, i, x):\n        i += self.n - 1\n        self.tree[i] = x\n        while i > 0:\n            i -= 1\n            i >>= 1\n            self.tree[i] = self.op(self.tree[i * 2 + 1], self.tree[i * 2 + 2])\n    def query(self, l, r):\n        l +=  self.n - 1\n        r += self.n - 1\n        L = self.ele\n        R = self.ele\n        while l < r:\n            if l & 1 == 0:\n                L = self.op(L, self.tree[l])\n                l += 1\n            if r & 1 == 0:\n                r -= 1\n                R = self.op(R, self.tree[r])\n            l -= 1\n            l >>= 1\n            r >>= 1\n        return self.op(L, R)\ndef compress(l):\n    n = len(l)\n    sorted_list = sorted(set(l))\n    d = {sorted_list[i]: i for i in range(len(sorted_list))}\n    return [d[i] for i in l]\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(n))\n        self.rank = [0] * n\n        self.weight = [0] * n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n    def unite(self, x, y, w):\n        p, q = self.find(x), self.find(y)\n        if self.rank[p] < self.rank[q]:\n            self.par[p] = q\n            self.weight[p] = w - self.weight[x] + self.weight[y]\n        else:\n            self.par[q] = p\n            self.weight[q] = -w - self.weight[y] + self.weight[x]\n            if self.rank[p] == self.rank[q]:\n                self.rank[p] += 1\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\nmod = 10 ** 9 + 7\nn = int(input())\ndp = [[0] * 4 for i in range(n + 1)]\ndp[1][0], dp[1][1], dp[1][2], dp[1][3] = 1, 1, 1, 1\nfor i in range(1, n + 1):\n    for j in range(4):\n        dp[i][j] += dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]\n        dp[i][j] %= mod\n    if i > 1:\n        dp[i][1] -= dp[i - 2][0] + dp[i - 2][2]\n        dp[i][2] -= dp[i - 2][0]\n    if i > 2:\n        dp[i][1] -= dp[i - 3][0] * 3\n        dp[i][2] += dp[i - 3][2]\nprint(sum(dp[n]) % mod)", "import sys\nsys.setrecursionlimit(10000000)\n\"\"\"\n\u9055\u53cd\u6587\u5b57\u5217\nAGC -> AG\u3068\u304d\u305f\u3089C\u306fNG\nGAC -> GA\u3068\u304d\u305f\u3089C\u306fNG\nACG -> AC\u3068\u304d\u305f\u3089G\u306fNG\nAQGC-> A*G\u3068\u304d\u305f\u3089C\u306fNG\nAGQC-> AG*\u3068\u304d\u305f\u3089C\u306fNG\n\"\"\"\nn=int(input())\np=10**9+7\nok = ['A','G','C','T']\nng = ['AGC','GAC','ACG']\nmemo =[{} for i in range(n+1)]\n\ndef check(text):\n  if text[1:] in ng:\n    return 0\n  if (text[:2] == 'AG' and text[3]=='C') or (text[0]=='A' and text[2:]=='GC'):\n    return 0\n  return 1\n\ndef dfs(cnt, last):\n  if last in memo[cnt]:\n    return memo[cnt][last]\n  if cnt == n:\n    return 1\n  ans=0\n  for o in ok:\n    if check(last+o):\n      ans += dfs(cnt+1, last[1:]+o) % p\n  memo[cnt][last] = ans\n  return ans % p\n  \n\nprint(dfs(0,'TTT')%p)", "import re\nn = int(input())\nMOD = 10**9 + 7\n\nstring = \"ACGT\"\n\n# AGC\n# A*GC\n# GAC\n# ACG\n# AG*C\n\ntable = [{} for i in range(n + 1)]\ndef dfs(s=\"\", depth=n):\n    if table[depth].get(s) is not None:\n        return table[depth][s]\n    if re.search(r\"(AGC|A.GC|GAC|ACG|AG.C)\", s):\n        table[depth][s] = 0\n        return 0\n    if depth == 0:\n        table[depth][s] = 1\n        return 1\n\n    cnt = 0\n    for i in string:\n        cnt += dfs(s[-3:] + i, depth - 1)\n        if cnt >= MOD:\n            cnt %= MOD\n    table[depth][s] = cnt\n    return cnt\n\nprint((dfs()))\n", "n=int(input())\nmod=10**9+7\nmemo=[{} for i in range(n+1)]\n\ndef ok(last4):\n  for i in range(4):\n    t=list(last4)\n    if i>=1:\n      t[i-1],t[i]=t[i],t[i-1]\n    if \"\".join(t).count(\"AGC\")>=1:\n      return False\n  return True\n\ndef dfs(cur,last3):\n  if last3 in memo[cur]:\n    return memo[cur][last3]\n  if cur==n:\n    return 1\n  res=0\n  for c in \"ACGT\":\n    if ok(last3+c):\n      res=(res+dfs(cur+1,last3[1:]+c))%mod\n  memo[cur][last3]=res\n  return res\n\nprint((dfs(0,\"TTT\")))\n\n\n", "ACGT = ['A', 'C', 'G', 'T', '']\nMOD = 10 ** 9 + 7\n\nN = int(input())\ndp = [[[[0] * 5\n        for _ in range(5)]\n       for _ in range(5)]\n      for _ in range(N + 1)]\n\ndp[0][4][4][4] = 1\nfor i in range(N):\n    for p in range(5):\n        for q in range(5):\n            for r in range(5):\n                for s in range(4):\n                    if ACGT[q] + ACGT[r] + ACGT[s] not in {'AGC', 'GAC', 'ACG'} \\\n                            and ACGT[p] + ACGT[r] + ACGT[s] != 'AGC' \\\n                            and ACGT[p] + ACGT[q] + ACGT[s] != 'AGC':\n                        dp[i + 1][q][r][s] += dp[i][p][q][r]\n                        dp[i + 1][q][r][s] %= MOD\n\nprint((sum(sum(sum(y) for y in x) for x in dp[N]) % MOD))\n", "n = int(input())\nmod = 1000000007\ndp = [[[0]*4 for _ in range(4)] for _ in range(n+1)]\nfor j in range(4):\n    for k in range(4): dp[2][j][k] = 1\n\nfor i in range(2,n):\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                if (j,k,l) in ((2,1,0),(1,2,0),(1,0,2)): continue\n                dp[i+1][j][k] += dp[i][k][l]\n                dp[i+1][j][k] %= mod\n    dp[i+1][1][2] -= dp[i-1][2][0]\n    dp[i+1][1][2] %= mod\n    dp[i+1][1][3] -= dp[i-1][2][0]\n    dp[i+1][1][3] %= mod\n    dp[i+1][1][2] -= dp[i-1][3][0]\n    dp[i+1][1][2] %= mod\n\nans = 0\nfor j in range(4):\n    for k in range(4):\n        ans += dp[n][j][k]\n        ans %= mod\nprint(ans)\n\n# for i in range(n+1): print(dp[i])\n", "N = int(input())\nmod = 10**9+7\nA = [1]+(N+3)*[0]\nG = [1]+(N+3)*[0]\nC = [1]+(N+3)*[0]\n\nfor n in range(1,N):\n  T = (2*A[n-1]+G[n-1]+C[n-1])%mod\n  A[n] = T\n  G[n] = (T-A[n-2]+G[n-3])%mod\n  C[n] = (T-A[n-2]-G[n-2]-3*A[n-3])%mod\n\nprint((2*A[N-1]+G[N-1]+C[N-1])%mod)", "N=int(input())\nmod=10**9+7\nmemo=[{} for _ in range(N+1)]\n\ndef ok(x,y,z,nx):\n  if y=='A' and z=='G' and nx=='C':\n    return False\n  if x=='A' and z=='G' and nx=='C':\n    return False\n  if y=='G' and z=='A' and nx=='C':\n    return False\n  if y=='A' and z=='C' and nx=='G':\n    return False\n  if x=='A' and y=='G' and nx=='C':\n    return False\n  return True\n\ndef dfs(idx,lis):\n    if idx==N:\n      return 1\n    x,y,z=lis[0],lis[1],lis[2]\n    if (x,y,z) in memo[idx]:\n        return memo[idx][(x,y,z)]\n    ret=0\n    for nx in ['A','G','C','T']:\n        if ok(x,y,z,nx):\n            ret+=dfs(idx+1,(y,z,nx))\n    memo[idx][(x,y,z)]=ret%mod\n    return ret%mod\n\nprint(dfs(0,'DDD'))", "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 6)\nimport math\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nimport time, random\nMOD = 10 ** 9 + 7\nfrom itertools import permutations\n\ndef dfs(s):\n    if len(s) == N:\n        return 1\n    if (s[-2] == 'A' and s[-1] == 'G') or (s[-2] == 'G' and s[-1] == 'A'):\n        return dfs(s+'A') % MOD + dfs(s+'G') % MOD + dfs(s+'T') % MOD\n    elif s[-2] == 'A' and s[-1] == 'C':\n        return dfs(s+'A') % MOD + dfs(s+'C') % MOD + dfs(s+'T') % MOD\n    else:\n        return dfs(s+'A') % MOD + dfs(s+'C') % MOD + dfs(s+'G') % MOD + dfs(s+'T') % MOD\n\ndef main():\n    N = int(readline())\n    A, G, C, T = 0, 1, 2, 3\n    dp = [[[[0] * 4 for _ in range(4)] for _ in range(4)] for _ in range(N+1)]\n    for j in range(4):  # i - 2 \u6587\u5b57\u76ee\n        for k in range(4):  # i - 1 \u6587\u5b57\u76ee\n            for l in range(4):  # i \u6587\u5b57\u76ee\n                if j == A and k == G and l == C:  continue\n                if j == A and k == C and l == G:  continue\n                if j == G and k == A and l == C:  continue\n                dp[3][j][k][l] = 1\n    \n    for i in range(4, N+1):\n        for j in range(4):\n            for k in range(4):\n                for l in range(4):\n                    for m in range(4):\n                        if j == A and k == G and l == C:  continue\n                        if j == A and k == C and l == G:  continue\n                        if j == G and k == A and l == C:  continue\n                        if m == A and k == G and l == C:  continue\n                        if m == A and j == G and l == C:  continue\n                        dp[i][j][k][l] += dp[i-1][m][j][k]\n                        dp[i][j][k][l] %= MOD\n    \n    res = 0\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                res += dp[N][j][k][l]\n                res %= MOD\n    \n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "MOD = 10 ** 9 + 7\nN = int(input())\ndp = [[[[0 for _ in range(4)] for _ in range(4)] for _ in range(4)] for _ in range(N + 1)]\ndp[0][3][3][3] = 1\nfor len in range(N):\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                if dp[len][i][j][k] == 0: continue\n\n                for l in range(4):\n                    if l == 2 and i == 1 and j == 0: continue\n                    if l == 2 and i == 0 and j == 1: continue\n                    if l == 1 and i == 2 and j == 0: continue\n                    if l == 2 and i == 1 and k == 0: continue\n                    if l == 2 and j == 1 and k == 0: continue\n                    dp[len + 1][l][i][j] += dp[len][i][j][k]\n                    dp[len + 1][l][i][j] %= MOD\nans = 0\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            ans += dp[N][i][j][k]\n            ans %= MOD\nprint(ans)", "import sys\nimport itertools\n\nsys.setrecursionlimit(10 ** 8)\nni = lambda: int(sys.stdin.readline())\nnm = lambda: list(map(int, sys.stdin.readline().split()))\nnl = lambda: list(nm())\nns = lambda: sys.stdin.readline().rstrip()\n\nN = ni()\nMOD = 10 ** 9 + 7\nAGCT3 = [\"\".join(x) for x in itertools.product(\"AGCT\", repeat=3)]\nM = 64\nblacklist3 = {\"AGC\", \"ACG\", \"GAC\"}\n\n\ndef solve():\n    dp = [[0] * M for _ in range(N + 1)]\n    for i in range(M):\n        if AGCT3[i] not in blacklist3:\n            dp[3][i] = 1\n    for i in range(4, N + 1):\n        for j in range(M):\n            p3 = AGCT3[j]\n            if p3 in blacklist3:\n                dp[i][j] = 0\n                continue\n            for k in range(M):\n                q3 = AGCT3[k]\n                q2 = q3[1:]\n                if not p3.startswith(q2):\n                    continue\n                if p3[1] == \"G\" and p3[2] == \"C\" and q3[0] == \"A\":\n                    continue\n                if p3[0] == \"G\" and p3[2] == \"C\" and q3[0] == \"A\":\n                    continue\n                dp[i][j] += dp[i - 1][k]\n                dp[i][j] %= MOD\n    ans = 0\n    for x in dp[N]:\n        ans = (ans + x) % MOD\n    return ans\n\n\nprint((solve()))\n", "import sys\nreadline = sys.stdin.readline\nMOD = 10 ** 9 + 7\n\ndef main():\n    N = int(readline())\n    A, G, C, T = 0, 1, 2, 3\n    dp = [[[[0] * 4 for _ in range(4)] for _ in range(4)] for _ in range(N+1)]\n    for j in range(4):  # i - 2 \u6587\u5b57\u76ee\n        for k in range(4):  # i - 1 \u6587\u5b57\u76ee\n            for l in range(4):  # i \u6587\u5b57\u76ee\n                if j == A and k == G and l == C:  continue\n                if j == A and k == C and l == G:  continue\n                if j == G and k == A and l == C:  continue\n                dp[3][j][k][l] = 1\n    \n    for i in range(4, N+1):\n        for j in range(4):\n            for k in range(4):\n                for l in range(4):\n                    for m in range(4):\n                        if j == A and k == G and l == C:  continue\n                        if j == A and k == C and l == G:  continue\n                        if j == G and k == A and l == C:  continue\n                        if m == A and k == G and l == C:  continue\n                        if m == A and j == G and l == C:  continue\n                        dp[i][j][k][l] += dp[i-1][m][j][k]\n                        dp[i][j][k][l] %= MOD\n    \n    res = 0\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                res += dp[N][j][k][l]\n                res %= MOD\n    \n    print(res)\n\ndef __starting_point():\n    main()\n__starting_point()", "N=int(input())\nmod=10**9+7\ndp=[{}for i in range(N)]\nlist=['AGC','ACG','GAC']\ndef dfs(x,y):\n  if x in list:\n    return 0\n  if y==N:\n    return 1\n  if x in dp[y]:\n    return dp[y][x]\n  ans=0\n  for i in 'ACGT':\n    if x[0]=='A' and i=='C' and (x[1]=='G' or x[2]=='G'):\n      continue\n    ans+=dfs(x[1:]+i,y+1)\n  dp[y][x]=ans%mod\n  return ans%mod\nprint(dfs('TTT',0))", "# D - We Like AGC\n\nfrom collections import defaultdict\n\nMOD = 10**9+7\nN = int(input())\ncharactors = ['A', 'G', 'C', 'T']\n\n# dp[l][s] := \u9577\u3055\u304cl\u3067\u3001\u672b\u5c3e3\u6587\u5b57\u304cs\u3067\u3042\u308b\u6587\u5b57\u5217\u306e\u500b\u6570\ndp = [defaultdict(int) for _ in range(N+1)]\n\n# \u7121\u95a2\u4fc2\u306e\u6587\u5b57\u3067\u521d\u671f\u5316\u3057\u3066\u304a\u304f\ndp[0]['ZZZ'] = 1\n\n# NG\u30b1\u30fc\u30b9: AGC, ACG, GAC, A?GC, AG?C\ndef check(s, c):\n    if c=='C':\n        if s[1:]=='AG' or s[1:]=='GA' or \\\n            (s[0]=='A' and (s[1]=='G' or s[2]=='G')):\n            return False\n        else:\n            return True\n    elif c=='G':\n        if s[1:]=='AC':\n            return False\n        else:\n            return True\n    else:\n        return True\n\nfor i in range(N):\n    for s in list(dp[i].keys()):\n        for c in charactors:\n            # NG\u30b1\u30fc\u30b9\u306b\u8a72\u5f53\u3057\u306a\u3051\u308c\u3070\u3001\u30ab\u30a6\u30f3\u30c8\u3059\u308b\n            if check(s, c): \n                dp[i+1][s[1:]+c] += dp[i][s]\n                dp[i+1][s[1:]+c] %= MOD\n\nprint((sum(dp[N].values())%MOD))\n", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N):\n    mod = 10 ** 9 + 7\n    dp = [{} for _ in range(N + 1)]\n    dp[0].setdefault('TTT', 1)\n\n    def check(last4):\n        for i in range(4):\n            x = list(last4)\n            if i > 0:\n                x[i], x[i - 1] = x[i - 1], x[i]\n            if ''.join(x).count('AGC') >= 1:\n                return False\n        return True\n\n    for i in range(1, N + 1):\n        for last3, count in list(dp[i - 1].items()):\n            for c in 'AGCT':\n                if check(last3 + c):\n                    new_last3 = last3[1:] + c\n                    dp[i].setdefault(last3[1:] + c, 0)\n                    dp[i][new_last3] = (dp[i][new_last3] + count) % mod\n\n    print((sum(dp[-1].values()) % mod))\n\n\ndef __starting_point():\n    N = int(input())\n    solve(N)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "# ABC122D - We Like AGC\nN, MOD = int(input()), 10 ** 9 + 7\nmemo = [{} for i in range(N+1)]\n\n\ndef ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i-1], t[i] = t[i], t[i-1]\n        if ''.join(t).count('AGC') >= 1:\n            return False\n    return True\n\n\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    ret = 0\n    for c in 'ACGT':\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n    memo[cur][last3] = ret\n    return ret\n\n\nprint((dfs(0, 'TTT')))\n", "N=int(input())\nMOD=10**9+7\ndp =[[[[0 for i in range(4)] for i in range(4)] for i in range(4)]for i in range(N+1)]\ndp[0][0][0][0]=1\n \nfor i in range(1,N+1):\n  for j in range(4):\n    for k in range(4):\n      for l in range(4):\n        for m in range(4):\n          if k==1 and l==2 and m==3:\n            continue\n          if k==2 and l==1 and m==3:\n            continue\n          if k==1 and l==3 and m==2:\n            continue\n          if j==1 and l==2 and m==3:\n            continue\n          if j==1 and k==2 and m==3:\n            continue\n          dp[i][k][l][m] += dp[i-1][j][k][l]\n          dp[i][k][l][m] %= MOD\nans=0\nfor i in range(4):\n  for j in range(4):\n    for k in range(4):\n      ans +=dp[N][i][j][k]\n      ans %= MOD\nprint(ans)", "import sys\nfrom collections import defaultdict\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n\n    dp = [defaultdict(int) for _ in range(N)]\n    for c in 'ACGT':\n        dp[0][c + 'XX'] = 1\n\n    for i in range(1, N):\n        for s, v in list(dp[i - 1].items()):\n            for c in 'AT':\n                dp[i][c + s[:2]] = (dp[i][c + s[:2]] + v) % MOD\n            if not (s[1] == 'A' and s[0] == 'C'):\n                dp[i]['G' + s[:2]] = (dp[i]['G' + s[:2]] + v) % MOD\n            if (\n                not (s[1] == 'A' and s[0] == 'G')\n                and not (s[1] == 'G' and s[0] == 'A')\n                and not (s[2] == 'A' and s[1] == 'G')\n                and not (s[2] == 'A' and s[0] == 'G')\n            ):\n                dp[i]['C' + s[:2]] = (dp[i]['C' + s[:2]] + v) % MOD\n\n    ans = sum(dp[N - 1].values()) % MOD\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\n#dp[i][x][y][z] i\u6587\u5b57\u76ee\u30013\u3064\u524d\u304cx, 2\u3064\u524d\u304cy, 1\u3064\u524d\u304cz\n#A->0, C->1, G->2, T->3\n#\u3060\u3081\u306a\u30d1\u30bf\u30fc\u30f3\u306fA-GC, AG-C, GAC, ACG\u306e\u307f\n\ndp = [[[[0]*4 for i in range(4)] for j in range(4)] for k in range(n+1)]\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            dp[3][i][j][k] = 1\ndp[3][0][2][1] = 0\ndp[3][0][1][2] = 0\ndp[3][2][0][1] = 0\n\nfor i in range(3, n):\n    for x in range(4):\n        for y in range(4):\n            for z in range(4):\n                for w in range(4):\n                    if (y, z, w) == (2, 0, 1):\n                        continue\n                    if (y, z, w) == (0, 1, 2):\n                        continue\n                    if (y, z, w) == (0, 2, 1):\n                        continue\n                    if (x, y, w) == (0, 2, 1):\n                        continue\n                    if (x, z, w) == (0, 2, 1):\n                        continue\n                    dp[i+1][y][z][w] += dp[i][x][y][z]\n                    dp[i+1][y][z][w] %= 10**9+7\nans = 0\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            ans += dp[n][i][j][k]\nprint((ans%(10**9+7)))\n", "import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nfrom functools import lru_cache\n\nn = ni()\nmod = 10**9+7\n\n@lru_cache(maxsize=10000)\ndef dfs(n, l):\n    rt = 0\n    if n == 0:\n        return 1\n    if l[1:3] == 'AG' or l[1:3] == 'GA' or (l[0] == 'A' and l[2] == 'G') or l[:2] == 'AG':\n        pass\n    else:\n        rt += dfs(n-1, l[1:]+'C')\n    if l[1:] != 'AC':\n        rt += dfs(n-1,l[1:]+'G')\n    rt += dfs(n-1,l[1:]+'T')\n    rt += dfs(n-1,l[1:]+'A')\n    return rt%mod\n\nprint(dfs(n,'TTT')%mod)", "n = int(input())\ndp = [[0]*4 for i in range(n+1)]\nmod = 10**9+7\n\ndp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = 1\ndp[1][0] = dp[1][1] = dp[1][2] = dp[1][3] = 4\n\nfor i in range(2,n):\n    for j in range(4):\n        dp[i][j] = sum(dp[i-1])%mod\n    dp[i][1] -= dp[i-2][0]\n    dp[i][2] -= (dp[i-2][0] + dp[i-2][1])\n    if i >= 3:\n        dp[i][2] -= 3*dp[i-3][0]\n        dp[i][1] += dp[i-3][1]\n        \n\nprint(sum(dp[n-1])%mod)", "import numpy as np\nN = int(input())\ndp = np.zeros((N+1, 5, 5, 5), dtype = np.int64)\n#dp[\u6587\u5b57\u5217\u306e\u9577\u3055][3\u6587\u5b57\u524d][2\u6587\u5b57\u524d][1\u6587\u5b57\u524d]\n#0:dummy A:1, C:2, G:3, T:4\np = 10**9 + 7\ndp[0, 0, 0, 0] = 1\nfor n in range(N):\n  for i in range(5):#3\u6587\u5b57\u524d\n    for j in range(5):\n      for k in range(5):\n        for l in range(1, 5):#\u4eca\u56de\u8ffd\u52a0\u3059\u308b\u6587\u5b57#0 : dummmy\u306f\u521d\u671f\u6761\u4ef6\u306e\u70ba\u306a\u306e\u3067\u56de\u3055\u306a\u3044\n          if j == 1 and k == 3 and l == 2:continue #AGC\n          if j == 3 and k == 1 and l == 2:continue #GAC\n          if j == 1 and k == 2 and l == 3:continue #ACG\n          if i == 1 and k == 3 and l == 2:continue #A?GC\n          if i == 1 and j == 3 and l == 2:continue #AG?C\n          dp[n+1, j, k, l] += dp[n, i, j, k]\n          dp[n+1, j, k, l] %= p\nans = 0\nfor i in range(1, 5):\n  for j in range(1, 5):\n    for k in range(1, 5):\n      ans += dp[N, i, j, k]\n      ans %=  p\nprint(ans)\n", "import sys\nfrom collections import defaultdict\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n\n    dp = [defaultdict(int) for _ in range(N)]\n    for c in 'ACGT':\n        dp[0][c + 'XX'] = 1\n\n    for i in range(1, N):\n        for s, v in list(dp[i - 1].items()):\n            t = s[:2]\n            for c in 'AT':\n                dp[i][c + t] = (dp[i][c + t] + v) % MOD\n            if not (s[1] == 'A' and s[0] == 'C'):\n                dp[i]['G' + t] = (dp[i]['G' + t] + v) % MOD\n            if (\n                not (s[1] == 'A' and s[0] == 'G')\n                and not (s[1] == 'G' and s[0] == 'A')\n                and not (s[2] == 'A' and s[1] == 'G')\n                and not (s[2] == 'A' and s[0] == 'G')\n            ):\n                dp[i]['C' + t] = (dp[i]['C' + t] + v) % MOD\n\n    ans = sum(dp[N - 1].values()) % MOD\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import copy\ndef main():\n    N = int(input())\n    if N == 3:\n        return 61\n    mod = 10**9 + 7\n    d = {'A':0, 'C':1, 'G':2, 'T':3}\n    AGC = [[[1] * 4 for _ in range(4)] for _ in range(4)]\n    AGC[d['A']][d['G']][d['C']] = 0\n    AGC[d['A']][d['C']][d['G']] = 0\n    AGC[d['G']][d['A']][d['C']] = 0\n    NAGC = [[[1] * 4 for _ in range(4)] for _ in range(4)]\n    for i in range(3, N):\n        for i1 in range(4):\n            for i2 in range(4):\n                for i3 in range(4):\n                    t = 0\n                    if (i2 == d['G'] or i1 == d['G']) and i3 == d['C']:\n                        for i4 in range(1, 4):\n                            t += AGC[i4][i1][i2]\n                    else:\n                        for i4 in range(4):\n                            t += AGC[i4][i1][i2]\n                    if i1 == d['A'] and i2 == d['G'] and i3 == d['C']:\n                        t = 0\n                    if i1 == d['A'] and i2 == d['C'] and i3 == d['G']:\n                        t = 0\n                    if i1 == d['G'] and i2 == d['A'] and i3 == d['C']:\n                        t = 0\n                    t %= mod\n                    NAGC[i1][i2][i3] = t\n        AGC = copy.deepcopy(NAGC)\n    return sum(sum(sum(j) for j in i) for i in AGC) % mod\nprint((main()))\n", "from collections import defaultdict\nfrom functools import reduce\n\ndef main():\n  m = 10 ** 9 + 7\n  n = int(input())\n  current = defaultdict(int)\n  current['TTT'] = 1\n  for i in range(n):\n    wip = defaultdict(int)\n\n    for c in 'AGCT':\n      for k, v in current.items():\n        if k + c in ['ATGC', 'AGTC', 'AGGC']:\n          continue\n        z = k[1:]+c\n        if z in ['AGC', 'ACG', 'GAC']:\n          continue\n        wip[z] = (wip[z] + v) % m\n\n    current = wip\n  \n  print(reduce(lambda acc, x: (acc + x) % m, wip.values()))\n\nmain()", "n = int(input())\nmod = pow(10, 9) + 7\nalph = list(\"AGCT\")\nng1 = [list(\"AGC\"), list(\"ACG\"), list(\"GAC\")]\ndp = [0] * 64\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            if not [alph[i], alph[j], alph[k]] in ng1:\n                dp[16 * i + 4 * j + k] = 1\nfor _ in range(n - 3):\n    dp0 = [0] * 64\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                for l in range(4):\n                    if not [alph[j], alph[k], alph[l]] in ng1:\n                        if not ([alph[i], alph[l]] == list(\"AC\") and (alph[j] == \"G\" or alph[k] == \"G\")):\n                            dp0[16 * j + 4 * k + l] += dp[16 * i + 4 * j + k]\n                            dp0[16 * j + 4 * k + l] %= mod\n    for i in range(64):\n        dp[i] = dp0[i]\nans = sum(dp) % mod\nprint(ans)", "n = int(input())\ndp = [[0] * 4 for i in range(n + 2)]  # dp[i][j]=(\u9577\u3055i\u306e\u6700\u5f8c\u306e\u6587\u5b57\u304cj\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6587\u5b57\u5217\u306e\u6570:j= 0:A 1:G 2:C 3:T)\n# \u756a\u5175\u30922\u3064\u7f6e\u3044\u3066\u304a\u304f\u3068\u90fd\u5408\u304c\u3044\u3044\nfor i in range(4):\n    dp[2][i] = 1\nmod = 10**9 + 7\nfor i in range(3, n + 2):\n    for j in range(4):\n        for k in range(4):\n            dp[i][j] += dp[i - 1][k]\n    dp[i][2] -= dp[i - 2][0] # AGC\u3092\u53d6\u308a\u9664\u304f.\n    dp[i][2] -= dp[i - 2][1] # GAC\u3092\u53d6\u308a\u9664\u304f.\n    dp[i][1] -= dp[i - 2][0] - dp[i - 3][1] # ACG\u3092\u53d6\u308a\u9664\u304f. \u305f\u3060\u3057GACG\u306f\u3059\u3067\u306b\u53d6\u308a\u9664\u3044\u3066\u3044\u308b.\n    dp[i][2] -= 3 * dp[i - 3][0] # \u3059\u3067\u306b\u53d6\u308a\u9664\u3044\u3066\u3044\u308b\u3082\u306e\u306b\u6ce8\u610f\u3059\u308b.\u7d50\u679c\u7684\u306bAGGC,ATGC,AGTC\u3092\u53d6\u308a\u9664\u304f.\nprint(sum(dp[-1]) % mod)", "MOD = pow(10,9)+7\nN = int(input())\ndp = [[[[0 for _ in range(4)] for _ in range(4)] for _ in range(4)] for _ in range(N+1)]\ndp[0][3][3][3] = 1 #3333S\u3068\u304f\u308b\u5834\u5408\u306f\u5236\u7d04\u306b\u4f55\u3082\u5f15\u3063\u304b\u304b\u3089\u306a\u3044\n#dp[i][j][k][l]: i\u6587\u5b57\u76ee\u307e\u3067\u898b\u3066\u6700\u5f8c\u306e\u306e\u4e09\u6587\u5b57\u304clkj\u3067\u3042\u308b\u3088\u3046\u306a\u5834\u5408\u306e\u6570\n#A=0, G=1, C=2, T=3\n\nfor i in range(N):\n  for j in range(4):\n    for k in range(4):\n      for l in range(4):\n        if dp[i][j][k][l] == 0: #i\u6587\u5b57\u76ee\u3067\u6761\u4ef6\u306b\u3042\u3066\u306f\u307e\u308b\u3082\u306e\u304c\u306a\u3044\u3068\u304d\u306f\u98db\u3070\u3059\u3002\n          continue\n        for a in range(4): #\u30c0\u30e1\u306a\u6761\u4ef6\u3092\u98db\u3070\u3059\n          if a == 2 and j == 1 and k == 0: #AGC\n            continue\n          if a == 1 and j == 2 and k == 0: #ACG\n            continue\n          if a == 2 and j == 0 and k == 1: #GAC\n            continue\n          if a == 2 and j == 1 and l == 0: #A?GC\n            continue\n          if a == 2 and k == 1 and l == 0: #AG?c\n            continue\n          dp[i+1][a][j][k] += dp[i][j][k][l]%MOD\nans = 0            \nfor j in range(4):\n  for k in range(4):\n    for l in range(4):\n      ans += dp[N][j][k][l]\nans = ans%MOD\nprint(ans)", "MOD=10**9+7\nN=int(input())\nmemo=[{} for _ in range(N+1)]\n\ndef ok(last4):\n    for i in range(4):\n        t=list(last4)\n        if i>0:\n            t[i-1],t[i]=t[i],t[i-1]\n        if \"\".join(t).count(\"AGC\")>0:\n            return False\n    return True\n\ndef dfs(cur,last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    ret=0\n    for c in \"AGCT\":\n        if ok(last3+c):\n            ret=(ret+dfs(cur+1,last3[1:]+c))%MOD\n    memo[cur][last3]=ret\n    return ret\n\nprint(dfs(0,\"TTT\"))", "N=int(input())\nmod=10**9+7\nmemo=[{} for _ in range(N+1)]\n\ndef ok(x, y, z, nx):\n  if y=='A' and z=='G' and nx=='C':\n    return False\n  if x=='A' and z=='G' and nx=='C':\n    return False\n  if y=='G' and z=='A' and nx=='C':\n    return False\n  if y=='A' and z=='C' and nx=='G':\n    return False\n  if x=='A' and y=='G' and nx=='C':\n    return False\n  return True\n\ndef f(num,A):\n  if num==N:\n    return 1\n  else:\n    x,y,z=A[0],A[1],A[2]\n    if (x,y,z) in memo[num]:\n      return  memo[num][(x,y,z)]\n    else:\n      s=0\n      for i in ['A','C','G','T']:\n        if ok(x,y,z,i):\n          s+=f(num+1,(y,z,i))\n      memo[num][(x,y,z)]=s%mod\n      return s%mod\nprint(f(0,'ZZZ'))", "N = int(input())\nmod = 10 ** 9 + 7\ndp = [{} for i in range(N)]\nforbid = set(['AGC', 'GAC', 'ACG'])\n\n\ndef search(i, prefix):\n    if prefix in forbid:\n        return 0\n    elif i == N:\n        return 1\n    elif prefix in dp[i]:\n        return dp[i][prefix]\n\n    ret = 0\n    for c in 'ACGT':\n        if prefix[0] == 'A' and (prefix[1] == 'G' or prefix[2] == 'G') and c == 'C':\n            continue\n        ret += search(i + 1, prefix[1:] + c)\n    dp[i][prefix] = ret % mod\n    return ret % mod\n\n\nprint(search(0, 'BBB'))", "import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\nn = ni()\nmod = 10**9+7\nfrom functools import lru_cache\n\n@lru_cache(maxsize=1000)\ndef dfs(n, l):\n    rt = 0\n    if n == 0:\n        return 1\n    if l[1:3] == 'AG' or l[1:3] == 'GA' or (l[0] == 'A' and l[2] == 'G') or l[:2] == 'AG':\n        pass\n    else:\n        rt += dfs(n-1, l[1:]+'C')\n    if l[1:] != 'AC':\n        rt += dfs(n-1,l[1:]+'G')\n    rt += dfs(n-1,l[1:]+'T')\n    rt += dfs(n-1,l[1:]+'A')\n    return rt%mod\n\n\n\nprint(dfs(n,'TTT')%mod)", "n = int(input())\nmod = pow(10, 9)+7\n\nmemo = [{} for _ in range(n+1)]\n\ndef judge(last4):\n  for i in range(4):\n    t = list(last4)\n    if i >= 1:\n      t[i], t[i-1] = t[i-1], t[i]\n    if \"\".join(t).count(\"AGC\") >= 1:\n      return False\n  return True\n\ndef dfs(cur, last3):\n  if cur == n:\n    return 1\n  if last3 in memo[cur]:\n    return memo[cur][last3]\n  ans = 0\n  for c in \"AGCT\":\n    if judge(last3+c):\n      ans = (ans+dfs(cur+1, last3[1:]+c))%mod\n  memo[cur][last3] = ans\n  return ans\n\nprint(dfs(0, \"TTT\"))", "import collections, itertools\nN = int(input())\nmod = 10**9 + 7\ndp = collections.defaultdict(int)\ndp['TTTA'] = dp['TTTG'] = dp['TTTC'] = dp['TTTT'] = 1\nfor _ in range(N - 1):\n    dp2 = collections.defaultdict(int)\n    for p, q, r, s, t in itertools.product('AGCT', repeat=5):\n        if 'AGC' in [q + s + t, s + r + t, r + s + t, q + r + t, r + t + s]:\n            continue\n        else:\n            dp2[q + r + s + t] += dp[p + q + r + s]\n    dp = dp2\nprint((sum(dp.values()) % mod))\n", "N, MOD = int(input()), 10 ** 9 + 7\nmemo = [{} for i in range(N+1)]\ndef ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i-1], t[i] = t[i], t[i-1]\n        if ''.join(t).count('AGC') >= 1:\n            return False\n    return True\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    ret = 0\n    for c in 'ACGT':\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n    memo[cur][last3] = ret\n    return ret\nprint((dfs(0, 'TTT')))\n", "from sys import stdin\ndef main():\n    #\u5165\u529b\n    readline=stdin.readline\n    mod=10**9+7\n    n=int(readline())\n\n    A=0\n    T=1\n    G=2\n    C=3\n    dp=[[[[0]*4 for _ in range(4)] for _ in range(4)] for _ in range(n+1)]\n    dp[0][T][T][T]=1\n    for i in range(1,n+1):\n        for j in range(4):\n            for k in range(4):\n                for l in range(4):\n                    for m in range(4):\n                        if j==A and k==G and l==C:\n                            pass\n                        elif j==A and k==C and l==G:\n                            pass\n                        elif j==G and k==A and l==C:\n                            pass\n                        elif m==A and k==G and l==C:\n                            pass\n                        elif m==A and j==G and l==C:\n                            pass\n                        else:\n                            dp[i][j][k][l]+=dp[i-1][m][j][k]\n    ans=0\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                ans+=dp[n][j][k][l]\n                ans%=mod\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import defaultdict\nfrom itertools import product\n\ninput = sys.stdin.readline\n\nP = 10 ** 9 + 7\n\n\ndef is_ok(a, b, c, d):\n    s = \"\".join((a, b, c, d))\n    if (\"AGC\" in s) or (\"ACG\" in s) or (\"GAC\" in s):\n        return False\n    if (s[0] == \"A\" and s[2:4] == \"GC\") or (s[0:2] == \"AG\" and s[3] == \"C\"):\n        return False\n    return True\n\n\ndef main():\n    N = int(input())\n\n    dp = [defaultdict(int) for _ in range(N + 1)]\n    dp[0][(\"T\", \"T\", \"T\")] = 1\n\n    for i in range(N):\n        for a, b, c, d in product(\"ACGT\", repeat=4):\n            if is_ok(a, b, c, d):\n                dp[i + 1][(b, c, d)] = (dp[i + 1][(b, c, d)] + dp[i][(a, b, c)]) % P\n\n    ans = 0\n    for v in list(dp[N].values()):\n        ans = (ans + v) % P\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nMOD = 10 ** 9 + 7\n\nmemo = [{} for _ in range(N + 1)]\n\ndef ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i >= 1:\n            t[i - 1], t[i] = t[i], t[i - 1]\n        if ''.join(t).count('AGC') >= 1:\n            return False\n    return True\n\n\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    ret = 0\n    for c in 'AGCT':\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c)) % MOD\n    memo[cur][last3] = ret\n    return ret\n\nprint (dfs(0, 'TTT'))", "n = int(input()); x = 0\ndp = [[[[0]*4 for q in range(4)] for p in range(4)] for i in range(n-2)]\nng = [\"012\", \"021\", \"102\", \"0112\", \"0132\", \"0312\"]\nfor p in range(4):\n    for q in range(4):\n        for r in range(4):\n            if str(p)+str(q)+str(r) not in ng:\n                dp[0][p][q][r] += 1\nfor i in range(n-3):\n    for p in range(4):\n        for q in range(4):\n            for r in range(4):\n                for s in range(4):\n                    if str(p)+str(q)+str(r)+str(s) not in ng and str(q)+str(r)+str(s) not in ng:\n                        dp[i+1][q][r][s] += dp[i][p][q][r]\nfor p in range(4):\n    for q in range(4):\n        for r in range(4):\n            x = (x+dp[-1][p][q][r])%(10**9+7)\nprint(x)", "n = int(input())\nmod = 10**9 + 7\ndp = [[0]*(4**3) for i in range(n)]\ndic = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\nagct_to_num = dict()\nnum_to_agct = dict()\nfor i in 'AGCT':\n    for j in 'AGCT':\n        for k in 'AGCT':\n            num = dic[i]*16 + dic[j]*4 + dic[k]*1\n            agct_to_num[i+j+k] = num\n            num_to_agct[num] = i+j+k\n\ndp[0] = [1] * (4**3)\ndp[1] = [1] * (4**3)\ndp[2] = [1] * (4**3)\ndp[2][agct_to_num['AGC']] = 0\ndp[2][agct_to_num['ACG']] = 0\ndp[2][agct_to_num['GAC']] = 0\n\n\ndef is_ok(s):\n    if 'AGC' in s:\n        return False\n    for i in range(len(s)-1):\n        t = list(s)\n        t[i], t[i+1] = t[i+1], t[i]\n        if 'AGC' in ''.join(t):\n            return False\n    return True\n\n\nfor i in range(3, n):\n    for j in range(64):\n        for c in 'ACGT':\n            tmp = num_to_agct[j] + c\n            if is_ok(tmp):\n                dp[i][agct_to_num[tmp[1:]]] += dp[i-1][j]\n\nprint(sum(dp[n-1]) % mod)", "import numpy as np\nfrom itertools import product\n\nn = int(input())\n\nmod = 10**9 + 7\nA, G, C, T = list(range(1, 5))\ndp = np.zeros((n+1, 5, 5, 5), dtype=np.int64)\ndp[0, 0, 0, 0] = 1\nfor m in range(n):\n    for i, j, k, l in product(list(range(5)), list(range(5)), list(range(5)), list(range(1, 5))):\n        if i == A and j == G and l == C:\n            continue\n        if i == A and k == G and l == C:\n            continue\n        if j == A and k == G and l == C:\n            continue\n        if j == G and k == A and l == C:\n            continue\n        if j == A and k == C and l == G:\n            continue\n        dp[m+1, j, k, l] += dp[m, i, j, k]\n        dp[m, i, j, k] %= mod\n\nres = 0\nfor i, j, k in product(list(range(1, 5)), repeat=3):\n    res += dp[n, i, j, k]\n    res %= mod\nprint(res)\n", "def is_ok(s):\n    if s[1:] in ['AGC', 'ACG', 'GAC']:\n        return False\n    if s[0] == 'A' and s[2:] == 'GC':\n        return False\n    if s[:2] == 'AG' and s[3] == 'C':\n        return False\n    return True\n\n\nm = 1000000007\n\nN = int(input())\n\nd = {}\nfor i in 'ACGT':\n    for j in 'ACGT':\n        for k in 'ACGT':\n            d[i + j + k] = 1\nfor k in ['AGC', 'ACG', 'GAC']:\n    del d[k]\n\nfor i in range(N - 3):\n    t = {}\n    for k in d:\n        for i in 'ACGT':\n            s = k + i\n            if is_ok(s):\n                t.setdefault(s[1:], 0)\n                t[s[1:]] += d[k]\n                t[s[1:]] %= m\n    d = t\n\nprint((sum(d.values()) % m))\n", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N):\n    mod = 10 ** 9 + 7\n    memo = [{} for _ in range(N + 1)]\n\n    def check(last4):\n        for i in range(4):\n            x = list(last4)\n            if i > 0:\n                x[i], x[i - 1] = x[i - 1], x[i]\n            if ''.join(x).count('AGC') >= 1:\n                return False\n        return True\n\n    def dfs(memo, digit, last3):\n        # last3\u6587\u5b57 + digit\u6587\u5b57 \u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u500b\u6570\u3092\u518d\u5e30\u53d6\u5f97\u3059\u308b\n        if last3 in memo[digit]:\n            return memo[digit][last3]  # \u8a08\u7b97\u6e08\u307f\u306e\u5834\u5408\u306f\u305d\u308c\u3092\u4f7f\u7528\n        if digit == 0:\n            return 1  # +0\u6587\u5b57\u306a\u306e\u3067\u3042\u308c\u3070\u30d1\u30bf\u30fc\u30f3\u306f1\u306e\u307f\n        re = 0\n        for c in 'AGCT':\n            if check(last3 + c):\n                re = (re + dfs(memo, digit - 1, last3[1:] + c)) % mod\n        memo[digit][last3] = re\n        return re\n\n    print((dfs(memo, N, 'TTT')))  # \u6700\u521d\u306e3\u6587\u5b57\u306f\u5165\u308c\u66ff\u3048\u3066AGC\u306b\u306a\u308a\u3046\u308b4\u6587\u5b57\u306b\u5e72\u6e09\u3057\u306a\u3044\u3082\u306e\u306b\u3059\u308b\n\n\ndef __starting_point():\n    N = int(input())\n    solve(N)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "\"\"\"\nAtCoder Beginner Contest 122  D - We Like AGC\n\n\u611a\u76f4\u89e3\n\u30fbN\u6587\u5b57\u306e\u3046\u3061\u3001\u5404\u6587\u5b57\u306b\u3064\u3044\u3066A,C,G,T\u306e4\u901a\u308a\u3092\u53d6\u308a\u3046\u308b\u306e\u3067\u30014^N\n\u30fb\u3067\u304d\u305f\u6587\u5b57\u306b\u3064\u3044\u3066\u3001AGC\u3092\u542b\u307e\u306a\u3044\u304b\u78ba\u8a8d\uff1aN\n\u30fb\u96a3\u63a5\u3059\u308b2\u6587\u5b57\u3092\u4e00\u56de\u3060\u3051\u5165\u308c\u66ff\u3048\u3066\u3001AGC\u304c\u3067\u304d\u306a\u3044\u304b\u78ba\u8a8d\uff1aN\n\u306a\u306e\u3067\u30014^N * N * N \u3050\u3089\u3044\u304b\uff1f\u5f8c\u308d\u4e8c\u3064\u306f\u307e\u3068\u3081\u3066\u3082\u3044\u3044\u304c\u3002\n\u307e\u305f\u3001AAAGC\u3067NG\u306a\u306e\u304c\u308f\u304b\u3063\u3066\u3044\u308b\u306e\u306b\u3001AAAGCAA\u3092\u4f5c\u3063\u3066\u8abf\u3079\u308b\u301c\u307f\u305f\u3044\u306a\u91cd\u8907\u3082\u3044\u3051\u3066\u306a\u3044\u3002\n\u3053\u306e\u3088\u3046\u306a\u91cd\u8907\u3092\u907f\u3051\u308b\u306b\u306f\u3001\u5c0f\u3055\u3044\u554f\u984c\u304b\u3089\u30e1\u30e2\u5316\u3067\u89e3\u6c7a\u3059\u308bDP\u304c\u3088\u3044\u3068\u601d\u3046\n\n\u5165\u308c\u66ff\u3048\u3066AGC\u304c\u3067\u304d\u308b\u6642\u3001\nGAC -> AGC \u304b\u3001 ACG -> AGC\u3001\u3000AXGC -> XAGC\u3001\u3000AGXC -> AGCX\n\u306a\u306e\u3067\u3001\u4f5c\u3063\u3066\u3044\u308b\u6587\u5b57\u5217\u306e\u53f3\u7aef\u304b\u30893\u6587\u5b57\u304c\u308f\u304b\u3063\u3066\u5165\u308c\u3070\u884c\u3051\u305d\u3046\n\n\ndp[i+1][j(i-2\u6587\u5b57\u76ee)][k(i-1\u6587\u5b57\u76ee)][l(i\u6587\u5b57\u76ee)]\uff1ai\u6587\u5b57\u76ee\u3092l\u3001\u4e00\u500b\u624b\u524d\u3092k\u3001\u3082\u3046\u4e00\u500b\u624b\u524d\u3092j\u3068\u3057\u305f\u6642\u306e\u6587\u5b57\u5217\u306e\u500b\u6570\n\u3068\u3059\u308b\u3068\n\n\u9077\u79fb\n\u30fbdp[i+1][A][G][C], dp[i+1][G][A][C], dp[i+1][A][C][G] :\u3053\u3044\u3064\u3089\u306f\u4f5c\u3063\u3066\u306f\u3044\u3051\u306a\u3044\n\u30fbdp[i][A][\uff0a][G] -> dp[i+1][*][G][C] : A\u3068* \u3092\u5165\u308c\u66ff\u3048\u308b\u3068AGC\u304c\u3067\u304d\u308b\u306e\u3067NG\n\u30fbdp[i][A][G][*] -> dp[i+1][G][*][C] : *\u3068C\u3092\u5165\u308c\u66ff\u3048\u308b\u3068AGC\u306b\u306a\u308b\u306e\u3067\u3060\u3081\n\n\u4e0a\u306e\u9077\u79fb\u306f\u306a\u3093\u304b\u3084\u3084\u3053\u3057\u3044\u306e\u3067\u3001\u3056\u3063\u304f\u308a\u307e\u3068\u3081\u308b\u3068\u3001\u3000\u30fb\u30fb\u30fbpqrs\u3000\u3068\u4e26\u3093\u3067\u3044\u3066\u3001pqrs\u306b\u3064\u3044\u3066\u3001\nA,G,*,C\nA,*,G,C\n*,A,G,C,\n*,G,A,C\n*,A,C,G\n\u304c\u30a2\u30a6\u30c8\u3067\u4ed6\u306fOK\n\u3053\u308c\u3092DP\u3067\u3084\u308b\u3068\u3088\u3044\n\n\u6700\u5f8c\u306b\u672b\u5c3e3\u6587\u5b57\u306b\u3064\u3044\u3066\u3001\u5168\u30d1\u30bf\u30fc\u30f3\u898b\u3066\u8db3\u3057\u5408\u308f\u305b\u308b\u3002\n\n\n\"\"\"\n\nN = int(input())\nMOD = 10**9 + 7\n\n# dp[i+1][j(i-2\u6587\u5b57\u76ee)][k(i-1\u6587\u5b57\u76ee)][l(i\u6587\u5b57\u76ee)]\uff1ai\u6587\u5b57\u76ee\u3092l\u3001\u4e00\u500b\u624b\u524d\u3092k\u3001\u3082\u3046\u4e00\u500b\u624b\u524d\u3092j\u3068\u3057\u305f\u6642\u306e\u6587\u5b57\u5217\u306e\u500b\u6570\n# j,k,l\u306b\u3064\u3044\u3066\u3001A=1,C=2,G=3,T=4, \u521d\u671f\u5316\u306e\u90fd\u5408\u4e0a0\u3082\u3042\u308b\ndp = [[[[0 for _ in range(5)] for _ in range(5)] for _ in range(5)] for _ in range(N+1)]\ndp[0][0][0][0] = 1\nA = 1\nC = 2\nG = 3\nT = 4\n\nfor i in range(N):\n    # \u521d\u671f\u5024\u3092\u3046\u307e\u304f\u5229\u7528\u3057\u305f\u3044\u306e\u3067\u3001p,q,r\u306f0~4\u307e\u3067\n    for p in range(5):\n        for q in range(5):\n            for r in range(5):\n                # s\u3092A,C,G,T\u3067\u52d5\u304b\u3059\n                for s in range(1, 5):\n                    # \u30fb\u30fb\u30fb\u30fb\u30fbpqrs\u306e\u4e26\u3073\u306b\u3067\u304d\u308b\u304b\u8003\u3048\u308b\n                    \"\"\"\n                    A,G,*,C\n                    A,*,G,C\n                    *,A,G,C,\n                    *,G,A,C\n                    *,A,C,G\n                    \u304c\u30a2\u30a6\u30c8\n                    \"\"\"\n                    if p == A and q == G and s == C : continue\n                    if p == A and r == G and s == C : continue\n                    if q == A and r == G and s == C : continue\n                    if q == G and r == A and s == C : continue\n                    if q == A and r == C and s == G : continue\n\n                    dp[i+1][q][r][s] += dp[i][p][q][r]\n                    dp[i+1][q][r][s] %= MOD\n\n\nans = 0\nfor i in range(1,5):\n    for j in range(1,5):\n        for k in range(1,5):\n            #print(i,j,k, dp[-1][i][j][k])\n            ans += dp[-1][i][j][k]\n            ans %= MOD\n\n\nprint(ans) \n", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9+7\n\nN = int(input())\n# memo[i]: i\u756a\u76ee\u306e\u6587\u5b57\u307e\u3067\u4f5c\u3063\u305f\u6642\u306e\u5019\u88dc\u6570\nmemo = [{} for _ in range(N+1)]\n\ndef ok(last4):\n    for i in range(4):\n        t = list(last4)\n        if i > 0:\n            t[i-1],t[i] = t[i],t[i-1]\n        if 'AGC' in ''.join(t):\n            return 0\n    return 1\n\ndef dfs(cur, last3):\n    if last3 in memo[cur]:\n        return memo[cur][last3]\n    if cur == N:\n        return 1\n    res = 0\n    for c in 'AGCT':\n        if ok(last3 + c):\n            res = (res + dfs(cur+1, last3[1:]+c)) % m\n    memo[cur][last3] = res\n    return res\n\nprint(dfs(0,'TTT'))", "\nfrom collections import defaultdict\n\n\ndef submit():\n    n = int(input())\n    modp = 10 ** 9 + 7\n    chars = [\"A\", \"C\", \"G\", \"T\"]\n    modp = 10 ** 9 + 7\n    # ACGT\u306e4\u901a\u308a\u306e\u9077\u79fb\n    # \u7981\u6b62\u306f\u6b21\u306e\u901a\u308a\n    # AG -> C\n    # A*G -> C\n    # GA -> C\n    # AC -> G\n    # AG* -> C\n\n    # \u3053\u306e\u305f\u3081,\u76f4\u524d\u306e\u4e09\u6587\u5b57\u3092\u899a\u3048\u308b\u3088\u3046\u306adp\u3092\u3059\u308b\n    dp = [defaultdict(int) for _ in range(n + 1)]\n\n    for c1 in chars:\n        for c2 in chars:\n            for c3 in chars:\n                k = c1 + c2 + c3\n                if k == \"AGC\":\n                    continue\n                if k == \"ACG\":\n                    continue\n                if k == \"GAC\":\n                    continue\n\n                dp[3][k] = 1\n\n    for i in range(4, n + 1):\n        for k, v in dp[i - 1].items():\n            for c in chars:\n                # *AG -> C\n                if k[1] == \"A\" and k[2] == \"G\" and c == \"C\":\n                    continue\n                # A*G -> C\n                if k[0] == \"A\" and k[2] == \"G\" and c == \"C\":\n                    continue\n                # *GA -> C\n                if k[1] == \"G\" and k[2] == \"A\" and c == \"C\":\n                    continue\n                # *AC -> G\n                if k[1] == \"A\" and k[2] == \"C\" and c == \"G\":\n                    continue\n                # AG* -> C\n                if k[0] == \"A\" and k[1] == \"G\" and c == \"C\":\n                    continue\n\n                new_k = k[1:] + c\n                dp[i][new_k] += dp[i - 1][k]\n                dp[i][new_k] %= modp\n\n    ans = sum(v % modp for v in dp[n].values())\n    print(ans % modp)\n    \n\nsubmit()", "N = int(input())\nMOD = 10 ** 9 + 7\n\nmemo = [{} for i in range(N+1)]\n\ndef f(x):\n  for i in range(4):\n    temp = list(x)\n    if i >= 1:\n      temp[i-1], temp[i] = temp[i], temp[i-1]\n    if ''.join(temp).count('AGC') >= 1:\n      return False\n  return True\n\ndef dfs(temp, x):\n  if x in memo[temp]:\n    return memo[temp][x]\n  if temp == N:\n    return 1\n  ans = 0\n  for c in 'ACGT':\n    if f(x + c):\n      ans = (ans + dfs(temp + 1, x[1:] + c)) % MOD\n  memo[temp][x] = ans\n  return ans\n\nprint(dfs(0, 'XXX'))", "# 2\u56de\u524d\u307e\u3067\u306e\u3092\u4fdd\u5b58\u3057\u3066\u304a\u304f\u5168\u63a2\u7d22\uff1f\n# -> ATGC ACGC AGGC \u306e\u5834\u5408\u3082\u6761\u4ef6\u3092\u6e80\u305f\u3057\u3066\u3057\u307e\u3046\u306e\u3067\u30013\u3064\u524d\u307e\u3067\u304b\u3082\uff08\u6c17\u3065\u304f\u306e\u306b\u9577\u6642\u9593\u304b\u304b\u3063\u305f\uff09\n# -> AGxC\u306e\u5834\u5408\u3082\u6c17\u3065\u304b\u306a\u304b\u3063\u305f...\n\n# \u306a\u305c\u304b\u30b5\u30f3\u30d7\u30eb3\u304c\u5408\u308f\u306a\u3044\u304c\u30b3\u30fc\u30c9\u304c\u9593\u9055\u3063\u3066\u308b\u308f\u3051\u306a\u3044\u306e\u3067\u8868\u8a18\u30df\u30b9\u3068\u5224\u65ad\u3057\u3066\u63d0\u51fa\uff08\u50b2\u6162\n# -> MOD\u3057\u3066\u306a\u3044\u3060\u3051\u3060\u3063\u305f...\n\nn = int(input())\nif n == 3:\n    print((61))\n    return\n\nmemo = {}\nMOD = 10**9 + 7\n\n\ndef rec(i, pre3, pre2, pre1):\n    if pre3 == \"A\" and pre2 == \"G\" and pre1 == \"C\":\n        return 0\n    if pre3 == \"G\" and pre2 == \"A\" and pre1 == \"C\":\n        return 0\n    if pre3 == \"A\" and pre2 == \"C\" and pre1 == \"G\":\n        return 0\n    if (i, pre1, pre2, pre3) in memo:\n        return memo[(i, pre1, pre2, pre3)]\n    if i == n - 3:\n        return 1\n    else:\n        ret = 0\n        if (pre1 == \"G\" and pre2 == \"A\") or (pre1 == \"A\" and pre2 == \"G\"):\n            ret = rec(i + 1, pre2, pre1, \"A\") % MOD + rec(\n                i + 1, pre2, pre1, \"G\") % MOD + rec(i + 1, pre2, pre1,\n                                                    \"T\") % MOD\n        elif pre1 == \"C\" and pre2 == \"A\":\n            ret = rec(i + 1, pre2, pre1, \"C\") % MOD + rec(\n                i + 1, pre2, pre1, \"A\") % MOD + rec(i + 1, pre2, pre1,\n                                                    \"T\") % MOD\n        elif pre3 == \"A\" and pre1 == \"G\":\n            ret = rec(i + 1, pre2, pre1, \"A\") % MOD + rec(\n                i + 1, pre2, pre1, \"G\") % MOD + rec(i + 1, pre2, pre1,\n                                                    \"T\") % MOD\n        elif pre3 == \"A\" and pre2 == \"G\":\n            ret = rec(i + 1, pre2, pre1, \"A\") % MOD + rec(\n                i + 1, pre2, pre1, \"G\") % MOD + rec(i + 1, pre2, pre1,\n                                                    \"T\") % MOD\n        else:\n            ret = rec(i + 1, pre2, pre1,\n                      \"A\") + rec(i + 1, pre2, pre1, \"G\") % MOD + rec(\n                          i + 1, pre2, pre1, \"C\") % MOD + rec(\n                              i + 1, pre2, pre1, \"T\") % MOD\n        ret %= MOD\n        memo[(i, pre1, pre2, pre3)] = ret\n        return ret\n\n\n# \u6700\u521d\u3068\u308a\u3046\u308b\u3084\u3064\uff08\u3081\u3093\u3069\u3044\uff09\nans = 0\nfor i in [\"A\", \"G\", \"C\", \"T\"]:\n    for j in [\"A\", \"G\", \"C\", \"T\"]:\n        for k in [\"A\", \"G\", \"C\", \"T\"]:\n            ans += rec(0, i, j, k)\n\nprint((ans % MOD))\n", "n=int(input())\nmod1,mod2=10**9+7,998244353\nmod=mod1\nimport sys\nsys.setrecursionlimit(10**9)\nmemo=[{}for i in range(n+1)]\ndef ok(s):\n    if \"AGC\"in s:return False\n    for i in range(3):\n        if \"AGC\"in s[:i]+s[i+1]+s[i]+s[i+2:]:\n            return False\n    return True\ndef dfs(cnt,las):\n    if las in memo[cnt]:return memo[cnt][las]\n    if cnt==n:return 1\n    ret=0\n    for nec in \"AGCT\":\n        if ok(las+nec):\n            ret=(ret+dfs(cnt+1,las[1:]+nec))%mod\n    memo[cnt][las]=ret\n    return ret\nprint(dfs(0,\"TTT\"))", "n=int(input())\nif n==3:\n  print((61))\n  return\nmod=pow(10,9)+7\n#d={'A':0,'G':1,'C':2,'T':3}\nd={0:'A',1:'G',2:'C',3:'T'}\ndd={}\ndinitial={}\nfor i in range(4**4):\n  key=[]\n  for _ in range(4):\n    key.append(d[i%4])\n    i//=4\n  key=''.join(key)\n  if 'AGC' in key:continue\n  if 'ACG' in key:continue\n  if 'GAC' in key:continue\n  if key[0]=='A' and key[2:4]=='GC':continue\n  if key[0:2]=='AG' and key[3]=='C':continue\n  dd[key]=1\n  dinitial[key]=0\n\nfor _ in range(n-4):\n  ddd=dinitial.copy()\n  for k in dd:\n    if k[1:]+'A' in ddd:\n      ddd[k[1:]+'A']+=dd[k]\n      ddd[k[1:]+'A']%=mod\n    if k[1:]+'G' in ddd:\n      ddd[k[1:]+'G']+=dd[k]\n      ddd[k[1:]+'G']%=mod\n    if k[1:]+'C' in ddd:\n      ddd[k[1:]+'C']+=dd[k]\n      ddd[k[1:]+'C']%=mod\n    if k[1:]+'T' in ddd:\n      ddd[k[1:]+'T']+=dd[k]\n      ddd[k[1:]+'T']%=mod\n  dd=ddd\n\nprint((sum(dd.values())%mod))\n", "import sys\nsys.setrecursionlimit(4100000)\n\nN = int(input())\nmod = 10 ** 9 + 7\nL = [{} for i in range(101)]\n\ndef check(txt):\n    if 'AGC' in txt:\n        return False\n    List = list(txt)\n    for i in range(3):\n        List[i], List[i+1] = List[i+1], List[i]\n        if 'AGC' in ''.join(List):\n            return False\n        List[i], List[i+1] = List[i+1], List[i]\n    return True\n    \ndef dfs(i, txt):\n    if i == N:\n        return 1\n    if txt in L[i]:\n        return L[i][txt]\n    ans = 0\n    for char in 'AGCT':\n        if check(txt[1:] + char):\n            ans += dfs(i+1, txt[1:] + char)\n    L[i][txt] = ans % mod\n    return ans % mod\n\nprint(dfs(0, 'TTTT'))", "from collections import defaultdict\nN=int(input())\nA = {}\nB = {}\nfor a in \"ATGC\":\n    for b in \"ATGC\":\n        for c in \"ATGC\":\n            if a+b+c not in [\"AGC\", \"ACG\", \"GAC\"]:\n                B[a+b+c] = 1\nX=set()\nfor a in \"ATGC\":\n    for b in \"ATGC\":\n        for c in \"ATGC\":      \n            for d in \"ATGC\":\n                s=a+b+c+d\n                t=b+a+c+d\n                u=a+c+b+d\n                v=a+b+d+c\n                if any([\"AGC\" in x for x in [s,t,u,v]]):\n                    X.add(s)\n\nfor _ in range(N-3):\n    A = B\n    B = defaultdict(int)\n    for k in A:\n        for l in \"ATGC\":\n            if k+l not in X:\n                B[k[1:]+l] += A[k]\n    \nprint(sum(B.values())%(10**9+7))", "n = int(input())\ndp = [[0] * 4 for i in range(n + 2)]\nfor i in range(4):\n    dp[2][i] = 1\nmod = 10**9 + 7\nfor i in range(3, n + 2):\n    for j in range(4):\n        for k in range(4):\n            dp[i][j] += dp[i - 1][k]\n    dp[i][2] -= dp[i - 2][0]\n    dp[i][2] -= dp[i - 2][1]\n    dp[i][1] -= dp[i - 2][0] - dp[i - 3][1]\n    dp[i][2] -= 3 * dp[i - 3][0]\nprint((sum(dp[-1]) % mod))\n", "n = int(input())\ndp = [[[[1] * 4 for i in range(4)] for j in range(4)] for k in range(n+1)]\ndp[3][1][2][0] = 0\ndp[3][1][0][2] = 0\ndp[3][2][1][0] = 0\nif n > 3:\n    for i in range(4,n + 1):\n        for j in range(4):\n            for k in range(4):\n                dp[i][3][j][k] = sum(dp[i-1][j][k])\n                dp[i][0][j][k] = sum(dp[i-1][j][k])\n                if j == 1 and k == 0:\n                    dp[i][2][j][k] = 0\n                else:\n                    dp[i][2][j][k] = sum(dp[i - 1][j][k])\n                if j == 0 and k == 2:\n                    dp[i][1][j][k] = 0\n                elif j == 2 and k == 0:\n                    dp[i][1][j][k] = 0\n                elif k == 2:\n                    dp[i][1][j][2] = sum(dp[i - 1][j][k]) - dp[i - 1][j][2][0]\n                elif j == 2:\n                    dp[i][1][2][k] = sum(dp[i - 1][j][k]) - dp[i-1][2][k][0]\n                else:\n                    dp[i][1][j][k] = sum(dp[i - 1][j][k])\nans = 0\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            ans += dp[n][i][j][k] % (10**9 + 7)\nprint((ans % (10**9 + 7)))\n", "N=int(input())\nMOD=10**9+7\nR=range(5)\ndp=[[[[0,0,0,0,0] for i in R] for j in R] for k in range(N+1)]\ndp[0][0][0][0]=1\n\n#0:dammy 1:A 2:G 3:C 4:T\nfor x in range(N):\n    for d in R:\n        for c in R:\n            for b in R:\n                for a in range(1,5):\n                    #a:X+1\u6587\u5b57\u76ee\u3001b:X-1\u6587\u5b57\u76ee\u3001...\n                    if (c==1 and b==2 and a==3):\n                        continue\n                    if (c==2 and b==1 and a==3):\n                        continue\n                    if (c==1 and b==3 and a==2):\n                        continue\n                    if (d==1 and b==2 and a==3):\n                        continue\n                    if (d==1 and c==2 and a==3):\n                        continue\n                    dp[x+1][c][b][a]+=dp[x][d][c][b]\n                    dp[x+1][c][b][a]%=MOD\n\nans=0\nfor c in range(1,5):\n    for b in range(1,5):\n        for a in range(1,5):\n            ans+=dp[N][c][b][a]\n            #print(c,b,a,dp[N][c][b][a])\n            ans%=MOD\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    N = int(input())\n\n    # dp[i\u6587\u5b57\u76ee][3\u6587\u5b57\u524d][2\u6587\u5b57\u524d][1\u6587\u5b57\u524d]\n    dp = [[[[0] * 5 for _ in range(5)] for _ in range(5)] for _ in range(N + 1)]\n    dp[0][0][0][0] = 1\n\n    # _,A,G,C,T = 0,1,2,3,4\n    for n in range(N):\n        # 3\u6587\u5b57\u524d\n        for i in range(5):\n            # 2\u6587\u5b57\u524d\n            for j in range(5):\n                # 1\u6587\u5b57\u524d\n                for k in range(5):\n                    # \u6700\u5f8c\u306e\u6587\u5b57\n                    for l in range(1, 5):\n                        # AG*C\n                        if i == 1 and j == 2 and l == 3: continue\n                        # A*GC\n                        if i == 1 and k == 2 and l == 3: continue\n                        # *AGC\n                        if j == 1 and k == 2 and l == 3: continue\n                        # *GAC\n                        if j == 2 and k == 1 and l == 3: continue\n                        # *ACG\n                        if j == 1 and k == 3 and l == 2: continue\n                        dp[n + 1][j][k][l] += dp[n][i][j][k]\n                        dp[n + 1][j][k][l] %= mod\n    res = 0\n    for i in range(5):\n        for j in range(5):\n            for k in range(5):\n                res += dp[-1][i][j][k]\n                res %= mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n = int(input())\ndp = [[0]*64 for _ in [0]*n]\nmod = 10**9+7\n\nA = 0\nC = 1\nG = 2\nT = 3\n\nAGC = 16*A+4*G+C\nACG = 16*A+4*C+G\nGAC = 16*G+4*A+C\n\nfor j in range(64):\n  if j==AGC or j==ACG or j==GAC:\n    dp[2][j] = 0\n  else:\n    dp[2][j] = 1\n\nfor i in range(3, n):\n  tot = [sum(dp[i-1][k::16]) for k in range(16)]\n  for j in range(64):\n    c1 = j//16\n    c2 = j//4%4\n    c3 = j%4\n    d = tot[j//4]\n\n    if j==AGC or j==ACG or j==GAC:\n      d = 0\n    elif c2==G and c3==C:\n      d -= dp[i-1][c1*4+G]\n    elif c1==G and c3==C:\n      d -= dp[i-1][G*4+c2]\n    dp[i][j] = d % mod\n\nprint(sum(dp[-1]) % mod)", "n = int(input())\nmod = 10**9+7\nA=[1] + [0]*(n+3)\nG=[1] + [0]*(n+3)\nC=[1] + [0]*(n+3)\nfor i in range(1,n):\n    t=(2*A[i-1]+G[i-1]+C[i-1])%mod\n    A[i]=t\n    G[i]=(t-A[i-2]+G[i-3])%mod\n    C[i]=(t-A[i-2]-G[i-2]-3*A[i-3])%mod\nprint(((2*A[n-1]+G[n-1]+C[n-1])%mod))\n", "import numpy as np\n\nN = int(input())\nmod = 10**9+7\n\ndp = np.zeros([N+1,4,4,4],dtype=int)\ndp[0,-1,-1,-1] = 1\n\nfor i in range(N):\n  for c1 in range(4):\n    for c2 in range(4):\n      for c3 in range(4):\n        if not dp[i,c1,c2,c3]:continue\n        for a in range(4):\n          if c1 == 0 and c3 == 1 and a == 2:continue\n          if c1 == 0 and c2 == 1 and a == 2:continue\n          if c2 == 0 and c3 == 1 and a == 2:continue\n          if c2 == 0 and c3 == 2 and a == 1:continue\n          if c2 == 1 and c3 == 0 and a == 2:continue\n          dp[i+1,c2,c3,a] += dp[i,c1,c2,c3]\n          dp[i+1,c2,c3,a] %= mod\n\nprint(dp[-1].sum()%mod)", "n = int(input())\n# A\u21920,G\u21921,C\u21922,T\u21923\ndp = [[[[0]*4 for _ in range(4)] for _ in range(4)] for _ in range(n+1)]\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            if (i==0 and j==1 and k==2) or (i==0 and j==2 and k==1) or (i==2 and j==0 and k==1):\n                pass\n            else:\n                dp[3][i][j][k] = 1\n\nfor a in range(3,n):\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                # l\u306f\u65b0\u3057\u3044\u6841\n                for l in range(4):\n                    if (j==0 and k==1):\n                        if l==2:\n                            continue\n                    if (j==0 and k==2):\n                        if l==1:\n                            continue\n                    if (j==2 and k==0):\n                        if l==1:\n                            continue\n\n                    if (i==0 and k==2):\n                        if l==1:\n                            continue\n                    if (i==0 and j==2):\n                        if l==1:\n                            continue\n                    dp[a+1][j][k][l] += dp[a][i][j][k]\n                    dp[a+1][j][k][l] %= 10**9+7\n                    #print(i,j,k,l,dp[a+1][j][k][l])\nans = 0\nfor i in range(4):\n    for j in range(4):\n        for k in range(4):\n            ans += dp[n][i][j][k]\n            ans %= 10**9+7\nprint(ans)", "N=int(input())\nmod=10**9+7\ndp=[{}for i in range(N)]\nlist=['AGC','ACG','GAC']\ndef dfs(x,y):\n  if x in list:\n    return 0\n  if y==N:\n    return 1\n  if x in dp[y]:\n    return dp[y][x]\n  ans=0\n  for i in 'ACGT':\n    if x[0]=='A' and i=='C' and (x[1]=='G' or x[2]=='G'):\n      continue\n    ans+=dfs(x[1:]+i,y+1)\n  dp[y][x]=ans%mod\n  return ans%mod\nprint(dfs('TTT',0))", "n = int(input())\n\nmod = 10**9 + 7\n\na = [0]*n\nc = [0]*n\ng = [0]*n\nt = [0]*n\n\na[0] = c[0] = g[0] = t[0] = 1\na[1] = c[1] = g[1] = t[1] = 4\na[2], c[2], g[2], t[2] = 16, 14, 15, 16\n\nfor i in range(3, n):\n    v = (a[i-1] + c[i-1] + g[i-1] + t[i-1]) % mod\n    a[i] = v\n    c[i] = (v - a[i-2] - g[i-2] - 3*a[i-3]) % mod\n    g[i] = (v - a[i-2] + g[i-3]) % mod\n    t[i] = v\nprint((a[n-1] + c[n-1] + g[n-1] + t[n-1]) % mod)", "import itertools\nL = [''.join(i) for i in itertools.product('0123', repeat=3)]\nl = len(L)\n\nmod = 10**9+7\n\nAGC = '021'\nACG = '012'\nGAC = '201'\nnc3 = set([AGC, ACG, GAC])\n\nAGGC = '0221'\nAGTC = '0231'\nATGC = '0321'\nnc4 = set([AGGC, AGTC, ATGC])\n\nn = int(input())\ndp = [[0]*l for _ in range(n+1)]\nfor i in L:\n  if i in nc3: continue\n  dp[3][int(i, 4)] = 1\n\nfor i in range(3, n):\n  for jl in L:\n    for k in \"0123\":\n      nxt = jl[1:] + k\n      if nxt in nc3: continue\n      if jl+k in nc4: continue\n      dp[i+1][int(nxt, 4)] += dp[i][int(jl, 4)]\nprint(sum(dp[n])%mod)", "n = int(input())\ndp = [[0] * 4 for i in range(n + 2)]  # dp[i][j]=(\u9577\u3055i\u306e\u6700\u5f8c\u306e\u6587\u5b57\u304cj\u3067\u6761\u4ef6\u3092\u6e80\u305f\u3059\u6587\u5b57\u5217\u306e\u6570:j= 0:A 1:G 2:C 3:T)\n# \u756a\u5175\u30922\u3064\u7f6e\u3044\u3066\u304a\u304f\u3068\u90fd\u5408\u304c\u3044\u3044\nfor i in range(4):\n    dp[2][i] = 1\nmod = 10**9 + 7\nfor i in range(3, n + 2):\n    for j in range(4):\n        for k in range(4):\n            dp[i][j] += dp[i - 1][k]\n    dp[i][2] -= dp[i - 2][0]  # AGC\u3092\u53d6\u308a\u9664\u304f.\n    dp[i][2] -= dp[i - 2][1]  # GAC\u3092\u53d6\u308a\u9664\u304f.\n    dp[i][1] -= dp[i - 2][0] - dp[i - 3][1]  # ACG\u3092\u53d6\u308a\u9664\u304f. \u305f\u3060\u3057GACG\u306f\u3059\u3067\u306b\u53d6\u308a\u9664\u3044\u3066\u3044\u308b.\n    dp[i][2] -= 3 * dp[i - 3][0]  # \u3059\u3067\u306b\u53d6\u308a\u9664\u3044\u3066\u3044\u308b\u3082\u306e\u306b\u6ce8\u610f\u3059\u308b.\u7d50\u679c\u7684\u306bAGGC,ATGC,AGTC\u3092\u53d6\u308a\u9664\u304f.\n\n    for j in range(4):\n        dp[i][j]%mod\nprint((sum(dp[-1])%mod))\n", "import sys\nimport itertools\n\nsys.setrecursionlimit(10 ** 8)\nni = lambda: int(sys.stdin.readline())\nnm = lambda: list(map(int, sys.stdin.readline().split()))\nnl = lambda: list(nm())\nns = lambda: sys.stdin.readline().rstrip()\n\nN = ni()\nMOD = 10 ** 9 + 7\nAGCT3 = [\"\".join(x) for x in itertools.product(\"AGCT\", repeat=3)]\nA, G, C, T = 0, 1, 2, 3\nM = 64\n\nblacklist3 = {\"AGC\", \"ACG\", \"GAC\"}\n\n\ndef solve():\n    dp = [[0] * M for _ in range(N + 1)]\n    for i in range(M):\n        if AGCT3[i] not in blacklist3:\n            dp[3][i] = 1\n    for i in range(4, N + 1):\n        for j in range(M):\n            p3 = AGCT3[j]\n            if p3 in blacklist3:\n                dp[i][j] = 0\n                continue\n\n            if p3[1] == \"G\" and p3[2] == \"C\":\n                for k in range(M):\n                    q3 = AGCT3[k]\n                    q2 = q3[1:]\n                    if p3.startswith(q2) and q3[0] != \"A\":\n                        dp[i][j] += dp[i - 1][k]\n                        dp[i][j] %= MOD\n                continue\n\n            if p3[0] == \"G\" and p3[2] == \"C\":\n                for k in range(M):\n                    q3 = AGCT3[k]\n                    q2 = q3[1:]\n                    if p3.startswith(q2) and q3[0] != \"A\":\n                        dp[i][j] += dp[i - 1][k]\n                        dp[i][j] %= MOD\n                continue\n\n            for k in range(M):\n                q3 = AGCT3[k]\n                q2 = q3[1:]\n                if p3.startswith(q2):\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= MOD\n    ans = 0\n    for x in dp[N]:\n        ans = (ans + x) % MOD\n    return ans\n\n\nprint((solve()))\n", "N = int(input())\nmod = int(1e9) + 7\nline = 'TAGC'\nng = {\"AGC\", \"ACG\", \"GAC\", \"ATGC\", \"AGGC\", \"ACGC\", \"AGTC\", \"AGCC\"}\nD = {line[(i//16)%4]+line[(i//4)%4]+line[i%4]: i for i in range(64)}\ninvD = {i: line[(i//16)%4]+line[(i//4)%4]+line[i%4] for i in range(64)}\ndp = [[0 for _ in range(N+1)] for __ in range(64)]\ndp[0][0] = 1\nfor i in range(4):\n  dp[i][1] = 1\nfor i in range(16):\n  dp[i][2] = 1\nfor i in range(3, N+1):\n  for j in range(64):\n    for k in range(4):\n      last = invD[j]\n      if last not in ng:\n        if (last[1:] + line[k]) not in ng and last + line[k] not in ng:\n          dp[D[last[1:]+line[k]]][i] += dp[D[last]][i-1]\n          dp[D[last[1:]+line[k]]][i] %= mod\nS = 0\nfor i in range(64):\n  S += dp[i][N]\n  S %= mod\nprint(S)", "n = int(input())\n# {0:\"A\", 1:\"C\", 2:\"G\", 3:\"T\"}\ndp = [[[[0] * 4 for _ in range(4)] for _ in range(4)] for _ in range(n + 1)]\ndp[0][3][3][3] = 1\nmod = 10 ** 9 + 7\n\nfor i in range(n):\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                for m in range(4):\n                    if m == 1 and l == 0 and k == 2: continue\n                    if m == 2 and l == 1 and k == 0: continue\n                    if m == 1 and l == 2 and k == 0: continue\n                    if m == 1 and k == 2 and j == 0: continue\n                    if m == 1 and l == 2 and j == 0: continue\n                    \n                    dp[i+1][k][l][m] += dp[i][j][k][l]\n                    \nans = 0\nfor j in range(4):\n    for k in range(4):\n        for l in range(4):\n            ans += dp[n][j][k][l]\n\nprint(ans % mod)", "n,mod=int(input()),10**9+7\ndp=[{} for i in range(n+1)]\ndef ok(last4):\n    for i in range(4):\n        t=list(last4)\n        if i>=1:\n            t[i-1],t[i]=t[i],t[i-1]\n        if ''.join(t).count('AGC')>=1:\n            return 0\n    return 1\ndef dfs(cur,last3):\n    if last3 in dp[cur]:\n        return dp[cur][last3]\n    if cur==n:\n        return 1\n    ret=0\n    for c in 'AGCT':\n        if ok(last3+c):\n            ret+=dfs(cur+1,last3[1:]+c)\n            ret%=mod\n    dp[cur][last3]=ret\n    return ret\n\n\n\n\nprint(dfs(0,'TTT'))", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nimport itertools\nL = [''.join(i) for i in itertools.product('0123', repeat=3)]\nl = len(L)\n\nmod = 10**9+7\n\nAGC = '021'\nACG = '012'\nGAC = '201'\nnc3 = set([AGC, ACG, GAC])\n\nAGGC = '0221'\nAGTC = '0231'\nATGC = '0321'\nnc4 = set([AGGC, AGTC, ATGC])\n\nn = int(input())\ndp = [[0]*l for _ in range(n+1)]\nfor i in L:\n    if i in nc3: continue\n    dp[3][int(i, 4)] = 1\n\nfor i in range(3, n):\n    for jl in L:\n        for k in \"0123\":\n            nxt = jl[1:] + k\n            if nxt in nc3: continue\n            if jl+k in nc4: continue\n            dp[i+1][int(nxt, 4)] += dp[i][int(jl, 4)]\nprint((sum(dp[n])%mod))\n", "N = int(input())\n\nMOD = 10**9 + 7\n\ndp = [[[[0 for _ in range(5)] for _ in range(5)] for _ in range(5)] for _ in range(N+1)]\n\ndp[0][0][0][0] = 1\nA = 1\nC = 2\nG = 3\nT = 4\n\nfor i in range(N):\n    for p in range(5):\n        for q in range(5):\n            for r in range(5):\n                for s in range(1, 5):\n                    if p == A and q == G and s == C: \n                        continue\n                    if p == A and r == G and s == C:\n                        continue\n                    if q == A and r == G and s == C: \n                        continue\n                    if q == G and r == A and s == C:\n                        continue\n                    if q == A and r == C and s == G: \n                        continue\n                    dp[i+1][q][r][s] += dp[i][p][q][r]\n                    dp[i+1][q][r][s] %= MOD\n\nans = 0\nfor i in range(1,5):\n    for j in range(1,5):\n        for k in range(1,5):\n            ans += dp[-1][i][j][k]\n            ans %= MOD\n\nprint(ans) ", "import numpy as np\nimport re\n\nmod = 10**9 + 7\nletters = \"ACGT\"\n\ndef to_int(s):\n    res = 0\n    for x in s:\n        res <<= 2\n        res += letters.index(x)\n    return res\n\ndef to_str(x, digit):\n    res = \"\"\n    for _ in range(digit):\n        res += letters[x&3]\n        x >>= 2\n    return res[::-1]\n\ndef is_ok(s):\n    ng = [r\"AGC\", r\"ACG\", r\"GAC\", r\"A.GC\", r\"AG.C\"]\n    for x in ng:\n        if re.search(x, s):\n            return False\n    return True\n\nA = [[0]*64 for _ in range(64)]\nfor i in range(64):\n    s = to_str(i, 3)\n    for j in range(4):\n        t = s + to_str(j, 1)\n        if is_ok(t):\n            A[i][to_int(t[1:])] = 1\n\nA = np.array(A, dtype = \"object\")\n\ndef mat_power(A, p, mod):\n    res = np.eye(A.shape[0], dtype = \"object\")\n    while p:\n        if p & 1:\n            res = np.dot(res, A) % mod\n        A = np.dot(A, A) % mod\n        p >>= 1\n    return res\n\nx = [0]*64\nx[63] = 1\nx = np.array(x)\n\nN = int(input())\nprint(((np.dot(mat_power(A, N, mod), x) % mod).sum() % mod))\n# y = np.dot(mat_power(A, N, mod), x) % mod\n# for i in range(64):\n#   print(to_str(i, 3) + \":\", y[i])\n", "import numpy as np\nimport re\n\nmod = 10**9 + 7\nletters = \"ACGT\"\n\n# \u6587\u5b57\u3092\u6dfb\u3048\u5b57\u306b\ndef to_int(s):\n    res = 0\n    for x in s:\n        res <<= 2\n        res += letters.index(x)\n    return res\n\n# \u6dfb\u3048\u5b57\u3092\u6587\u5b57\u306b\ndef to_str(x, digit):\n    res = \"\"\n    for _ in range(digit):\n        res += letters[x&3]\n        x >>= 2\n    return res[::-1]\n\n# \u90e8\u5206\u6587\u5b57\u5217\u3068\u3057\u3066\u542b\u3093\u3067\u306f\u3044\u3051\u306a\u3044\u3082\u306e\u3092\u6b63\u898f\u8868\u73fe\u3067\u5224\u5b9a\ndef is_ok(s):\n    ng = [r\"AGC\", r\"ACG\", r\"GAC\", r\"A.GC\", r\"AG.C\"]\n    for x in ng:\n        if re.search(x, s):\n            return False\n    return True\n\n# \u884c\u5217\u4f5c\u6210\u3000\u5404\u72b6\u614b\u304b\u3089\u306e\u5404\u9077\u79fb\u304c\u6709\u52b9\u304b\u78ba\u304b\u3081\u308b\nA = [[0]*64 for _ in range(64)]\nfor i in range(64):\n    s = to_str(i, 3)\n    for j in range(4):\n        t = s + to_str(j, 1)\n        if is_ok(t):\n            A[i][to_int(t[1:])] = 1\nA = np.array(A, dtype = \"object\")\n\n\n# \u884c\u5217\u306e\u4e8c\u5206\u7d2f\u4e57\ndef mat_power(A, p, mod):\n    res = np.eye(A.shape[0], dtype = \"object\")\n    while p:\n        if p & 1:\n            res = np.dot(res, A) % mod\n        A = np.dot(A, A) % mod\n        p >>= 1\n    return res\n\n# \u30d9\u30af\u30c8\u30eb\u4f5c\u6210\u3000TTT\u306e\u307f\u7acb\u3066\u3066\u304a\u304f\nx = [0]*64\nx[63] = 1\nx = np.array(x)\n\nN = int(input())\nprint((np.dot(mat_power(A, N, mod), x) % mod).sum() % mod)", "n=int(input())\nmod=10**9+7\n\nal=pow(4,n,mod)\n\nimport itertools\nitr=itertools.product([0,1,2,3],repeat=4)\nitr=list(itr)\ndic1={} #dec\ndic2={} #enc\nfor i in enumerate(itr):\n    dic1[i[0]]=[i[1]]\n    dic2[i[1]]=[i[0]]\n\n    \n\ndp=[[0 for i in range(4**3)] for q in range(n+1)]\n\nfor i in range(4**3):\n    if i!=9 and i!=33 and i!=6:\n        dp[3][i]=1\n\n\nfor i in range(3,n):\n    for q in range(4**3):\n        for r in range(4):\n            p1=q//16%4\n            p2=q//4%4\n            p3=q%4\n            \n            if p2==0 and p3==2 and r==1:\n                continue\n            if p1==0 and p3==2 and r==1:\n                continue\n            if p1==0 and p2==2 and r==1:\n                continue\n            if p2==0 and p3==1 and r==2:\n                continue\n            if p2==2 and p3==0 and r==1:\n                continue\n        \n            ck=q%16*4\n            dp[i+1][ck+r]+=dp[i][q]\n            dp[i+1][ck+r]%=mod\n\nprint((sum(dp[n])%mod))\n  \n", "from collections import defaultdict\nMOD = 10**9 + 7\n\nN = int(input())\n\ndp = [defaultdict(int) for x in range(N+1)]\ndp[0][''] = 1\n\ndef sol(s):\n    if s.find('ABC') != -1: # \u898b\u3064\u304b\u3063\u305f\u5834\u5408\n        return False\n    L = len(s)\n    for i in range(L-1):\n        li = list(s)\n        li[i], li[i+1] = li[i+1], li[i]\n        t = ''.join(li)\n        if t.find('ABC') != -1:\n            return False\n    return True\n\nfor n in range(N):\n    for s,cnt in list(dp[n].items()):\n        for c in 'ABCD':\n            ns = s + c\n            if sol(ns):\n                dp[n+1][ns[-3:]] += cnt\n                dp[n+1][ns[-3:]] %= MOD\n\nans = sum(dp[N].values())\nans %= MOD\nprint(ans)\n", "n = int(input())\nMOD = 10**9+7\nd = {\"A\":0, \"C\":1, \"G\":2, \"T\":3}\ndic = {}\ndic_r = {}\nfor i0 in \"ACGT\":\n    for i1 in \"ACGT\":\n        for i2 in \"ACGT\":\n            v = 4**2*d[i2] + 4*d[i1] + d[i0]\n            k = i2+i1+i0\n            dic[k] = v\n            dic_r[v] = k\n\ndp = [[0] * 64 for i in range(n)]\nfor i in range(64):\n    dp[0][i] = 1\ndp[0][dic[\"AGC\"]] = 0\ndp[0][dic[\"ACG\"]] = 0\ndp[0][dic[\"GAC\"]] = 0\nfor i in range(n-3):\n    for j in range(64):\n        v = dic_r[j]\n        for s in \"ACGT\":\n            # AG*C\n            if v[0] == \"A\" and v[1] == \"G\":\n                if s != \"C\":\n                    new = v[1]+v[2]+s\n                    dp[i+1][dic[new]] += dp[i][dic[v]]\n            # A*GC\n            elif v[0] == \"A\" and v[2] == \"G\":\n                if s != \"C\":\n                    new = v[1]+v[2]+s\n                    dp[i+1][dic[new]] += dp[i][dic[v]]\n            # *GAC\n            elif v[1] == \"G\" and v[2] == \"A\":\n                if s != \"C\":\n                    new = v[1]+v[2]+s\n                    dp[i+1][dic[new]] += dp[i][dic[v]]\n            # *ACG\n            elif v[1] == \"A\" and v[2] == \"C\":\n                if s != \"G\":\n                    new = v[1]+v[2]+s\n                    dp[i+1][dic[new]] += dp[i][dic[v]]\n            # *AGC\n            elif v[1] == \"A\" and v[2] == \"G\":\n                if s != \"C\":\n                    new = v[1]+v[2]+s\n                    dp[i+1][dic[new]] += dp[i][dic[v]]\n            else:\n                new = v[1] + v[2] + s\n                dp[i+1][dic[new]] += dp[i][dic[v]]\n    continue\nprint((sum(dp[n-3])%MOD))\n\n\n", "n = int(input())\nmod = 10**9+7\nA=[1] + [0]*(n-1)\nG=[1] + [0]*(n-1)\nT=[1] + [0]*(n-1)\nC=[1] + [0]*(n-1)\n##NG:: AGC,GAC,ACG\nAG =[0]*n\nGA =[0]*n\nAC =[0]*n\n##NG:: AGGC,AGTC,ATGC\nAGG=[0]*n\nAGT=[0]*n\nATG=[0]*n\nfor i in range(1,n):\n    tmp=A[i-1]+G[i-1]+C[i-1]+T[i-1]\n\n    A[i]=tmp%mod\n    T[i]=tmp%mod\n    G[i]=(tmp - AC[i-1])%mod\n    C[i]=(tmp -AG[i-1]-GA[i-1]-AGG[i-1] -AGT[i-1]-ATG[i-1])%mod\n\n    AG[i]=A[i-1]\n    GA[i]=G[i-1]\n    AC[i]=(A[i-1]-GA[i-1])%mod\n\n    AGG[i]=AG[i-1]\n    AGT[i]=AG[i-1]\n    ATG[i]=A[i-2]# == AT[i-1]\n\n\nprint(((A[-1]+G[-1]+C[-1]+T[-1])%mod))\n#print(A,G,C,T)\n#print(AG,GA,AC)\n#print(AGG,AGT,ATG)\n", "import sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nMOD = 10**9+7\n\ndp = [[[[0]*4 for _ in range(4)] for _ in range(4)] for _ in range(101)]\n\n# ATCG\u306f0123\u3068\u8aad\u307f\u66ff\u3048\u308b\n# \u9577\u30550\u306e\u6587\u5b57\u5217\u306f1\u30020,1,2\u306b\u95a2\u3059\u308b\u5236\u7d04\u3057\u304b\u306a\u3044\u306e\u3067\u3001S\u306f333S\u3068\u8003\u3048\u3066\u3082\u554f\u984c\u304c\u306a\u3044\ndp[0][3][3][3] = 1\n\n# \u6587\u5b57\u5217\u306e\u6587\u5b57\u6570\nfor length in range(n):\n    # \u6700\u5f8c\u304b\u30891\u6587\u5b57\u76ee\u306e\u6587\u5b57\n    for c1 in range(4):\n        # \u6700\u5f8c\u304b\u30892\u6587\u5b57\u76ee\u306e\u6587\u5b57\n        for c2 in range(4):\n            # \u6700\u5f8c\u304b\u30893\u6587\u5b57\u76ee\u306e\u6587\u5b57\n            for c3 in range(4):\n                # \u6761\u4ef6\u306b\u5f53\u3066\u306f\u307e\u308b\u7269\u304c\u306a\u3044\u5834\u5408\u306fcontinue\n                if dp[length][c1][c2][c3] == 0: continue\n                # \u65b0\u3057\u304f\u8ffd\u52a0\u3059\u308b\u6587\u5b57\n                for a in range(4):\n                    \n                    # \u30c0\u30e1\u306a5\u6761\u4ef6\u3092\u30ab\u30c3\u30c8\n                    if a==2 and c1==1 and c2==0: continue\n                    if a==2 and c1==0 and c2==1: continue\n                    if a==1 and c1==2 and c2==0: continue\n                    if a==2 and c1==1 and c3==0: continue\n                    if a==2 and c2==1 and c3==0: continue\n                    \n                    # \u30c0\u30e1\u306a\u6761\u4ef6\u3092\u629c\u3051\u305f\u3089\u3001a\u3092\u8db3\u3057\u305f\u6587\u5b57\u5217\u3092\u4f5c\u308c\u308b\n                    # S = ... c3 c2 c1\n                    # nextS = ... c2 c1 a\n                    dp[length+1][a][c1][c2] += dp[length][c1][c2][c3]\n                    dp[length+1][a][c1][c2] %= MOD\n                    \nans = 0\n# \u6700\u5f8c\u304b\u30891\u6587\u5b57\u76ee\u306e\u6587\u5b57\nfor c1 in range(4):\n    # \u6700\u5f8c\u304b\u30892\u6587\u5b57\u76ee\u306e\u6587\u5b57\n    for c2 in range(4):\n        # \u6700\u5f8c\u304b\u30893\u6587\u5b57\u76ee\u306e\u6587\u5b57\n        for c3 in range(4):\n            # \u9577\u3055n\u306e\u6587\u5b57\u5217\u306e\u5024\u3092\u307e\u3068\u3081\u308b\n            ans += dp[n][c1][c2][c3]\n            ans %= MOD\n            \nprint(ans)", "import re\n\n\ndef ok(last4):\n    pattern = '.?AGC.?|.?GAC.?|.?ACG.?|A.GC|AG.C'\n    res = re.match(pattern, last4)\n    return res is None\n\n\ndef dfs(cur, last3, n, m, mod):\n    if last3 in m[cur]:\n        return m[cur][last3]\n    if cur == n:\n        return 1\n    ret = 0\n    for c in 'ACGT':\n        if ok(last3 + c):\n            ret = (ret + dfs(cur + 1, last3[1:] + c, n, m, mod)) % mod\n\n    m[cur][last3] = ret\n    return ret\n\n\ndef main():\n    n = int(input())\n    mod = 10 ** 9 + 7\n\n    m = [{} for _ in range(n + 1)]\n    ans = dfs(0, 'TTT', n, m, mod)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections, itertools\nN = int(input())\nmod = 10**9 + 7\ndp = collections.defaultdict(int)\ndp['TTTA'] = dp['TTTG'] = dp['TTTC'] = dp['TTTT'] = 1\nfor _ in range(N - 1):\n    dp2 = collections.defaultdict(int)\n    for p, q, r, s, t in itertools.product('AGCT', repeat=5):\n        if 'AGC' in [q + s + t, s + r + t, r + s + t, q + r + t, r + t + s]:\n            continue\n        else:\n            dp2[q + r + s + t] += dp[p + q + r + s] % mod\n    dp = dp2\nprint((sum(dp.values()) % mod))\n"]
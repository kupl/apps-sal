["import bisect,collections,copy,heapq,itertools,math,numpy as np,string,sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN,K = LI()\na = np.array([LI() for _ in range(N)])\ngyou,retu = [],[]\nans = 1\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        gyou.append((i,j))\nuf_gyou = UnionFind(N)\nfor x,y in gyou:\n    uf_gyou.union(x,y)\nfor x in uf_gyou.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\na = a.T\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        retu.append((i,j))\nuf_retu = UnionFind(N)\nfor x,y in retu:\n    uf_retu.union(x,y)\nfor x in uf_retu.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\nprint(ans)\n", "import math\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nmod = 998244353\n\nclass DSU:\n    def __init__(self, n):\n        self.uf = {i: i for i in range(n)}\n        self.rank = {i: 1 for i in range(n)}\n\n    def find(self, x):\n        if self.uf[x] != x:\n            self.uf[x] = self.find(self.uf[x])\n        return self.uf[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            if self.rank[px] > self.rank[py]:\n                px, py = py, px\n            self.rank[py] += self.rank[px]\n            self.uf[px] = py\n\nrow, col = DSU(N), DSU(N)\nfor i in range(N):\n    for j in range(i + 1, N):\n        if all(a + b <= K for a, b in zip(A[i], A[j])):\n            row.union(i, j)\nB = list(zip(*A))\nfor i in range(N):\n    for j in range(i + 1, N):\n        if all(a + b <= K for a, b in zip(B[i], B[j])):\n            col.union(i, j)\nans = 1\nfor x in set(row.find(i) for i in range(N)):\n    ans *= math.factorial(row.rank[x])\n    ans %= mod\nfor x in set(col.find(i) for i in range(N)):\n    ans *= math.factorial(col.rank[x])\n    ans %= mod\nprint(ans)", "import sys\nimport math\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    def all_family_count(self):\n        return [-min(0,x) for i, x in enumerate(self.parents) ]\n\ndef main():\n    N,K=list(map(int,input().split()))\n    mod =998244353\n    A = [[] for _ in range(N)]\n    for i in range(N):\n        a = list(map(int,input().split()))\n        A[i] =a\n\n    row = UnionFind(N)\n    column = UnionFind(N)\n\n\n    #row\n\n    for i in range(N-1):\n        for j in range(i+1,N):\n            for w in range(N):\n                if A[i][w] +A[j][w] >K:\n                    break\n            else:\n                row.union(i,j)\n\n\n    for i in range(N-1):\n        for j in range(i+1,N):\n            for w in range(N):\n                if A[w][i] +A[w][j] >K:\n                    break\n            else:\n                column.union(i,j)\n\n    root_row  = row.all_family_count()\n    ans_row =1\n    for i in range(N):\n        k = root_row[i]\n        ans_row *=math.factorial(k)\n\n\n\n\n    root_column = column.all_family_count()\n    ans_column =1\n    for i in range(N):\n        k = root_column[i]\n        ans_column *=math.factorial(k)\n    \n\n\n\n    print((ans_column*ans_row%mod))\n\n    \n\n    \n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def MI():\n    return map(int, input().split())\n\nn,k= MI()\nmod=998244353\nframod=[1]\ndef framod_calc(n, mod, a=1):\n    for i in range(1,n+1):\n        a=a * i % mod\n        framod.append(a)\nframod_calc(n+1, mod)\ndef permmod(n, k, mod):\n    if n<k: return 0\n    a=framod[n]\n    c=framod[n-k]\n    return (a * pow(c, mod-2, mod)) % mod\n\nmat=[]\nmatinv=[[0]*n for _ in range(n)]\nfor i in range(n):\n    mat.append(list(MI()))\n\nfor i in range(n):\n    for j in range(n):\n        matinv[i][j]=mat[j][i]\n\nesrow=[]\nescol=[]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if mat[i][p]+mat[j][p]>k:\n                flg=False\n                break\n        if flg:\n            esrow.append((i,j))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if matinv[i][p]+matinv[j][p]>k:\n                flg=False\n                break\n        if flg:\n            escol.append((i,j))\n\nclass UnionFind(object): # size\u3092O(1)\u3067\u5f15\u3051\u308bversion\n    def __init__(self, n=1):\n        self.n=n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.sizebox = [1]*n\n    def find(self, x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u4ee3\u8868\u5143\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y): # x,y\u3092\u9023\u7d50\u3001\u3064\u3044\u3067\u306b\u30b5\u30a4\u30ba\u3082\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizebox[x]+=self.sizebox[y]\n            self.sizebox[y]=0\n    def same(self, x, y): # x,y\u304c\u9023\u7d50\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def size(self,x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50size\u3092O(1)\u3067\u51fa\u3059\n        x = self.find(x)\n        return self.sizebox[x]\n    def allfind(self): # find\u30921\u5468\u3059\u308b\n        for i in range(self.n):\n            self.find(i)\n\nufr=UnionFind(n)\nufc=UnionFind(n)\n\nfor i,j in esrow:\n    ufr.union(i,j)\n\nfor i,j in escol:\n    ufc.union(i,j)\n\nufr.allfind()\nufc.allfind()\n\nfrom collections import Counter\ncpar=Counter(ufc.par)\nrpar=Counter(ufr.par)\n\nans=1\n\nfor k in cpar.keys():\n    x=cpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nfor k in rpar.keys():\n    x=rpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nprint(ans%mod)", "n,k=list(map(int,input().split()))\nm=998244353\n\nP=[-1]*n\n\ndef find(x):\n  if P[x]<0:\n    return x\n  P[x]=find(P[x])\n  return P[x]\n\ndef unite(x,y):\n  x=find(x)\n  y=find(y)\n  if x==y:\n    return\n\n  if P[x]>P[y]:\n    P[y]+=P[x]\n    P[x]=y\n  else:\n    P[x]+=P[y]\n    P[y]=x\n\ndef f(n):\n  a=1\n  while n>0:\n    a*=n\n    n-=1\n  return a\n\nA=[[int(c) for c in input().split()] for r in range(n)]\n\nfor r1 in range(n):\n  for r2 in range(r1+1,n):\n    for c in range(n):\n      if A[r1][c]+A[r2][c]>k:\n        break\n    else:\n      unite(r1,r2)\n\na=1\nfor r in range(n):\n  if P[r]<0:\n    a=(a*f(-P[r]))%m\n\nP=[-1]*n\nfor c1 in range(n):\n  for c2 in range(c1+1,n):\n    for r in range(n):\n      if A[r][c1]+A[r][c2]>k:\n        break\n    else:\n      unite(c1,c2)\n\nfor c in range(n):\n  if P[c]<0:\n    a=(a*f(-P[c]))%m\n\nprint(a)\n", "def main():\n    import sys\n    from collections import Counter\n    from math import factorial\n    input = sys.stdin.readline\n    MOD = 998244353\n    N, K = [int(x) for x in input().strip().split()]\n    A = [0 for n in range(N)]\n    for n in range(N):\n        A[n] = [int(x) for x in input().strip().split()]\n        # print(A[n])\n    ans = 1\n    def find(x):\n        if c[x] == x:\n            return x\n        c[x] = find(c[x])\n        return c[x]\n    c = [n for n in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            for n in range(N):\n                if A[n][i] + A[n][j] > K:\n                    break\n            else:\n                if c[j] > c[i]:\n                    c[j] = c[i]\n                else:\n                    c[i] = c[j]\n    for i in range(N):\n        find(i)\n    # print(c)\n    for d in Counter(c).values():\n        ans = (ans * factorial(d)) % MOD\n    c = [n for n in range(N)]\n    for i in range(N-1):\n        for j in range(i+1, N):\n            for n in range(N):\n                if A[i][n] + A[j][n] > K:\n                    break\n            else:\n                if c[j] > c[i]:\n                    c[j] = c[i]\n                else:\n                    c[i] = c[j]\n    for i in range(N):\n        find(i)\n    # print(c)\n    for d in Counter(c).values():\n        ans = (ans * factorial(d)) % MOD\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "class dsu():\n    \"\"\"Data structures and algorithms for disjoint set union problems.\n    \n    Given an undirected graph, it processes the following queries in O(alpha(n)) time (amortized).\n\n    >   Edge addition\n    \n    >   Deciding whether given two vertices are in the same connected component\n\n    Each connected component internally has a representative vertex.\n\n    When two connected components are merged by edge addition, one of the two representatives of these connected components becomes the representative of the new connected component.\n    \"\"\"\n\n\n    __slots__ = [\"_n\", \"parent_or_size\"]\n\n\n    def __init__(self, n):\n        \"\"\"\n        It creates an undirected graph with n vertices and 0 edges.\n        \n        Constraints\n        -----------\n\n        >   0 <= n <= 10 ** 8\n\n        Complexity\n        ----------\n\n        >   O(n)\n        \"\"\"\n        self._n = n\n        self.parent_or_size = [-1] * n\n    \n    \n    def merge(self, a, b):\n        \"\"\"\n        It adds an edge (a, b).\n\n        If the vertices a and b were in the same connected component, it returns the representative of this connected component. Otherwise, it returns the representative of the new connected component.\n       \n        Constraints\n        -----------\n\n        >   0 <= a < n \n\n        >   0 <= b < n\n        \n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        # assert 0 <= b < self._n\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y:\n            return x\n        else:\n            if self.parent_or_size[y] < self.parent_or_size[x]:\n                x, y = y, x\n            self.parent_or_size[x] += self.parent_or_size[y]\n            self.parent_or_size[y] = x\n\n\n    def same(self, a, b):\n        \"\"\"\n        It returns whether the vertices a and b are in the same connected component.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n\n        >   0 <= b < n\n\n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        # assert 0 <= b < self._n\n        return self.leader(a) == self.leader(b)\n\n\n    def leader(self, a):\n        \"\"\"\n        It returns the representative of the connected component that contains the vertex a.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n\n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        path = []\n        while self.parent_or_size[a] >= 0:\n            path.append(a)\n            a = self.parent_or_size[a]\n        for child in path:\n            self.parent_or_size[child] = a\n        return a\n\n    \n    def size(self, a):\n        \"\"\"\n        It returns the size of the connected component that contains the vertex aa.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n        \n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        return -self.parent_or_size[self.leader(a)]\n\n\n    def groups(self):\n        \"\"\"\n        It divides the graph into connected components and returns the list of them.\n\n        More precisely, it returns the list of the \"list of the vertices in a connected component\". Both of the orders of the connected components and the vertices are undefined.\n\n        Complexity\n        ----------\n\n        >   O(n)\n        \"\"\"\n        anc2mem = dict()\n        for i in range(self._n):\n            anc = self.leader(i)\n            if anc in anc2mem:\n                anc2mem[anc].append(i)\n            else:\n                anc2mem[anc] = [i]\n        return list(anc2mem.values())\n\n\nMOD = 998244353\ntable_len = 110\n\nfac = [1, 1]\nfor i in range(2, table_len):\n    fac.append(fac[-1] * i % MOD)\n\nfinv = [0] * table_len\nfinv[-1] = pow(fac[-1], MOD - 2, MOD)\nfor i in range(table_len-1, 0, -1):\n    finv[i-1] = finv[i] * i % MOD\n\nN, K = list(map(int, input().split()))\nAs = [list(map(int, input().split())) for _ in range(N)]\n\ndef solve_row(mat):\n    uf = dsu(N)\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(N):\n                if mat[i][k] + mat[j][k] > K:\n                    break\n            else:\n                uf.merge(i, j)\n    groups = uf.groups()\n    ret = 1\n    for g in groups:\n        ret *= fac[len(g)]\n        ret %= MOD\n    return ret\n\ntAs = list(map(list, list(zip(*As))))\nprint((solve_row(As) * solve_row(tAs) % MOD))\n\n", "def MI():\n    return map(int, input().split())\n\nn,k= MI()\nmod=998244353\nframod=[1]\ndef framod_calc(n, mod, a=1):\n    for i in range(1,n+1):\n        a=a * i % mod\n        framod.append(a)\nframod_calc(n+1, mod)\ndef permmod(n, k, mod):\n    if n<k: return 0\n    a=framod[n]\n    c=framod[n-k]\n    return (a * pow(c, mod-2, mod)) % mod\n\nmat=[]\nmatinv=[[0]*n for _ in range(n)]\nfor i in range(n):\n    mat.append(list(MI()))\n\nfor i in range(n):\n    for j in range(n):\n        matinv[i][j]=mat[j][i]\n\nesrow=[]\nescol=[]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if mat[i][p]+mat[j][p]>k:\n                flg=False\n                break\n        if flg:\n            esrow.append((i,j))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if matinv[i][p]+matinv[j][p]>k:\n                flg=False\n                break\n        if flg:\n            escol.append((i,j))\n\nclass UnionFind(object): # size\u3092O(1)\u3067\u5f15\u3051\u308bversion\n    def __init__(self, n=1):\n        self.n=n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.sizebox = [1]*n\n    def find(self, x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u4ee3\u8868\u5143\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y): # x,y\u3092\u9023\u7d50\u3001\u3064\u3044\u3067\u306b\u30b5\u30a4\u30ba\u3082\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizebox[x]+=self.sizebox[y]\n            self.sizebox[y]=0\n    def same(self, x, y): # x,y\u304c\u9023\u7d50\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def size(self,x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50size\u3092O(1)\u3067\u51fa\u3059\n        x = self.find(x)\n        return self.sizebox[x]\n    def allfind(self): # find\u30921\u5468\u3059\u308b\n        for i in range(self.n):\n            self.find(i)\n\nufr=UnionFind(n)\nufc=UnionFind(n)\n\nfor i,j in esrow:\n    ufr.union(i,j)\n\nfor i,j in escol:\n    ufc.union(i,j)\n\nfor i in range(n):\n    ufr.find(i)\n    ufc.find(j)\n\nfrom collections import Counter\ncpar=Counter(ufc.par)\nrpar=Counter(ufr.par)\n\nans=1\n\nfor k in cpar.keys():\n    x=cpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nfor k in rpar.keys():\n    x=rpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nprint(ans%mod)", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nclass UnionFind():\n\tdef __init__(self, size):\n\t\tself.table = [-1 for _ in range(size)]\n\t\tself.size = [1 for _ in range(size)]\n\n\tdef find(self, x):\n\t\twhile self.table[x] >= 0:\n\t\t\tif self.table[self.table[x]] >= 0:\n\t\t\t\tself.table[x] = self.table[self.table[x]]\n\t\t\tx = self.table[x]\n\t\treturn x\n\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef unite(self, x, y):\n\t\ts1 = self.find(x)\n\t\ts2 = self.find(y)\n\t\tif s1 != s2:\n\t\t\tr1 = self.table[s1]\n\t\t\tr2 = self.table[s2]\n\t\t\tif r1 <= r2:\n\t\t\t\tself.table[s2] = s1\n\t\t\t\tif r1 == r2:\n\t\t\t\t\tself.table[s1] -= 1\n\t\t\t\tself.size[s1] += self.size[s2]\n\t\t\t\tself.size[s2] = 0\n\t\t\telse:\n\t\t\t\tself.table[s1] = s2\n\t\t\t\tself.size[s2] += self.size[s1]\n\t\t\t\tself.size[s1] = 0\n\t\treturn\n\nMOD = 998244353\nn, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nans = 1\n\nuf_t = UnionFind(n)\nuf_y = UnionFind(n)\n\nfor s in range(1, n):\n\tfor t in range(s):\n\t\tok_y, ok_t = True, True\n\t\tfor i in range(n):\n\t\t\tif a[s][i] + a[t][i] > k:\n\t\t\t\tok_y = False\n\t\t\tif a[i][s] + a[i][t] > k:\n\t\t\t\tok_t = False\n\t\tif ok_y:\n\t\t\tuf_y.unite(s, t)\n\t\tif ok_t:\n\t\t\tuf_t.unite(s, t)\n\nfact = [1 for _ in range(51)]\nfor i in range(1, 51):\n\tfact[i] = (fact[i-1] * i) % MOD\n\nfor i in range(n):\n\tif uf_t.size[i] > 0:\n\t\tans *= fact[uf_t.size[i]]\n\t\tans %= MOD\n\tif uf_y.size[i] > 0:\n\t\tans *= fact[uf_y.size[i]]\n\t\tans %= MOD\n\nprint(ans)", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n    def find(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u63a2\u7d22\u3057\u3066\u89aa\u3092\u51fa\u3059\u3002\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y):\n        \"\"\"\n        x \u3068 y \u306e\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n    def is_same(self, x, y):\n        \"\"\"\n        x \u3068 y \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5426\u304b\n        \"\"\"\n        return self.find(x) == self.find(y)\n    def get_size(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n\nN,K = map(int,input().split())\nMOD = 998244353\n\nfac = [-1]*(N+1); fac[0] = 1; fac[1] = 1 #\u968e\u4e57\nfinv = [-1]*(N+1); finv[0] = 1; finv[1] = 1 #\u968e\u4e57\u306e\u9006\u5143\ninv = [-1]*(N+1); inv[0] = 0; inv[1] = 1 #\u9006\u5143\nfor i in range(2,N+1):\n  fac[i] = fac[i-1]*i%MOD\n  inv[i] = MOD - inv[MOD%i]*(MOD//i)%MOD\n  finv[i] = finv[i-1]*inv[i]%MOD\n  \n  \nimport numpy as np\n\nA = np.array([list(map(int,input().split())) for _ in range(N)])\n\nuf0 = UnionFind(N)\nfor i in range(N):\n  for j in range(N):\n    if i == j:\n      continue\n    for k in range(N):\n      if A[i,k] + A[j,k] > K:\n        break\n    else:\n      uf0.union(i,j)\n\npar0 = set([])\nfor i in range(N):\n  par = uf0.find(i)\n  par0.add(par)\n#print(par0)\n\nX = 1\nfor x in par0:\n  temp = uf0.get_size(x)\n  X = X*fac[temp]%MOD\n\nA = A.T\n#print(A)\n\nuf1 = UnionFind(N)\nfor i in range(N):\n  for j in range(N):\n    if i == j:\n      continue\n    for k in range(N):\n      if A[i,k] + A[j,k] > K:\n        break\n    else:\n      uf1.union(i,j)\n\npar1 = set([])\nfor i in range(N):\n  par = uf1.find(i)\n  par1.add(par)\n\nY = 1\nfor y in par1:\n  temp = uf1.get_size(y)\n  Y = Y*fac[temp]%MOD\n#print(Y)\n\nans = X*Y%MOD\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 998244353\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.size[x] < self.size[y]:\n                x, y = y, x\n            self.parents[y] = x\n            self.size[x] += self.size[y]\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(N)]\n    ans = 1\n\n    p = 998244353\n    a = [None] * (N+1)\n    inva = [None] * (N+1)\n    a[0] = 1\n\n    for i in range(1, N+1):\n        a[i] = i * a[i-1] % p\n\n    inva[N] = pow(a[N], p-2, p)\n    for i in range(N):\n        inva[N-i-1] = inva[N-i] * (N-i) % p\n\n    rowuf = UnionFind(N)\n    for x in range(N):\n        for y in range(x + 1, N):\n            for i in range(N):\n                if A[i][x] + A[i][y] > K:\n                    break\n            else:\n                rowuf.union(x, y)\n\n    rows = []\n    for i in range(N):\n        rows.append(rowuf.find(i))\n\n    # print(rows)\n    for l in list(Counter(rows).values()):\n        ans *= a[l]\n        ans %= p\n\n    coluf = UnionFind(N)\n    for x in range(N):\n        for y in range(x + 1, N):\n            for i in range(N):\n                if A[x][i] + A[y][i] > K:\n                    break\n            else:\n                coluf.union(x, y)\n    cols = []\n    for i in range(N):\n        cols.append(coluf.find(i))\n\n    # print(cols)\n    for l in list(Counter(cols).values()):\n        ans *= a[l]\n        ans %= p\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class union_find:\n  def __init__(self, n):\n    self.par = [-1] * n\n\n  def find(self, x):#x\u306e\u89aa\u3092\u898b\u3064\u3051\u308b\n    if self.par[x] < 0:\n      return x\n    else:\n      self.par[x] = self.find(self.par[x])\n      return self.par[x]\n\n  def unite(self,x,y):#\u8981\u7d20x\u3068\uff59\u3092\u4f75\u5408\u3055\u305b\u308b\n    x,y=self.find(x),self.find(y)#x\u3068y\u306e\u89aa\u306e\u691c\u7d22\n    if x!=y:#\u89aa\u304c\u7570\u306a\u308b\u5834\u5408\u4f75\u5408\u3055\u305b\u308b\n      if x>y:\n        x,y=y,x#\u5c0f\u3055\u3044\u65b9\u3092x\u3068\u3059\u308b. \u3053\u308c\u306b\u3088\u308a\u8981\u7d20\u306e\u5024\u304c\u5c0f\u3055\u3044\u3082\u306e\u3092\u512a\u5148\u3057\u3066\u6728\u306e\u6839\u3068\u3059\u308b. \n      self.par[x]+=self.par[y] #\u5024\u3092\u7121\u5411\u6728\u306e\u8981\u7d20\u6570\u306e\u548c\u306b\u3059\u308b.\n      self.par[y]=x #\u679d\u5074\u306f\u6839\u306e\u4f4d\u7f6e\u3092\u683c\u7d0d\n\n  def same(self, x, y):#\u8981\u7d20x\u3068\u8981\u7d20y\u304c\u540c\u3058\u7121\u5411\u6728\u306b\u6240\u5c5e\u3057\u3066\u3044\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\n    return self.find(x) == self.find(y)#\u540c\u3058\u5024\u3092\u6301\u3064\u304b\u5426\u304b\n\n  def size(self, x):#\u8981\u7d20x\u304c\u6240\u5c5e\u3059\u308b\u7121\u5411\u6728\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n    return-self.par[self.find(x)] \n\nimport itertools  \nmod = 998244353\ndef main():\n  n, k = map(int,input().split())\n  factorial = [1]\n  for i in range(1, n+1):\n    factorial.append(factorial[i-1]*i%mod)\n  a = []\n  for i in range(n):\n    a.append(list(map(int, input().split())))\n  gyou = union_find(n)\n  for x, y in itertools.combinations(range(n), 2):\n    flag = True\n    for i in range(n):\n      if a[x][i] + a[y][i] > k:\n        flag = False\n        break\n    if flag:\n      gyou.unite(x, y)\n  retu = union_find(n)\n  \n  for x, y in itertools.combinations(range(n), 2):\n    flag = True\n    for i in range(n):\n      if a[i][x] + a[i][y] > k:\n        flag = False\n        break\n    if flag:\n      retu.unite(x, y)\n  ans = 1\n  for i in range(len(retu.par)):\n    if retu.par[i] < 0:\n      ans *=factorial[-retu.par[i]]\n    ans %= mod\n  for i in range(len(gyou.par)):\n    if gyou.par[i] < 0:\n      ans *= factorial[-gyou.par[i]]\n    ans %= mod\n  print(ans)  \n  \ndef __starting_point():\n  main()\n__starting_point()", "class dsu():\n    \"\"\"Data structures and algorithms for disjoint set union problems.\n    \n    Given an undirected graph, it processes the following queries in O(alpha(n)) time (amortized).\n\n    >   Edge addition\n    \n    >   Deciding whether given two vertices are in the same connected component\n\n    Each connected component internally has a representative vertex.\n\n    When two connected components are merged by edge addition, one of the two representatives of these connected components becomes the representative of the new connected component.\n    \"\"\"\n\n\n    __slots__ = [\"_n\", \"parent_or_size\"]\n\n\n    def __init__(self, n):\n        \"\"\"\n        It creates an undirected graph with n vertices and 0 edges.\n        \n        Constraints\n        -----------\n\n        >   0 <= n <= 10 ** 8\n\n        Complexity\n        ----------\n\n        >   O(n)\n        \"\"\"\n        self._n = n\n        self.parent_or_size = [-1] * n\n    \n    \n    def merge(self, a, b):\n        \"\"\"\n        It adds an edge (a, b).\n\n        If the vertices a and b were in the same connected component, it returns the representative of this connected component. Otherwise, it returns the representative of the new connected component.\n       \n        Constraints\n        -----------\n\n        >   0 <= a < n \n\n        >   0 <= b < n\n        \n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        # assert 0 <= b < self._n\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y:\n            return x\n        else:\n            if self.parent_or_size[y] < self.parent_or_size[x]:\n                x, y = y, x\n            self.parent_or_size[x] += self.parent_or_size[y]\n            self.parent_or_size[y] = x\n\n\n    def same(self, a, b):\n        \"\"\"\n        It returns whether the vertices a and b are in the same connected component.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n\n        >   0 <= b < n\n\n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        # assert 0 <= b < self._n\n        return self.leader(a) == self.leader(b)\n\n\n    def leader(self, a):\n        \"\"\"\n        It returns the representative of the connected component that contains the vertex a.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n\n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        path = []\n        while self.parent_or_size[a] >= 0:\n            path.append(a)\n            a = self.parent_or_size[a]\n        for child in path:\n            self.parent_or_size[child] = a\n        return a\n\n    \n    def size(self, a):\n        \"\"\"\n        It returns the size of the connected component that contains the vertex aa.\n\n        Constraints\n        -----------\n\n        >   0 <= a < n\n        \n        Complexity\n        ----------\n\n        >   O(alpha(n)) amortized\n        \"\"\"\n        # assert 0 <= a < self._n\n        return -self.parent_or_size[self.leader(a)]\n\n\n    def groups(self):\n        \"\"\"\n        It divides the graph into connected components and returns the list of them.\n\n        More precisely, it returns the list of the \"list of the vertices in a connected component\". Both of the orders of the connected components and the vertices are undefined.\n\n        Complexity\n        ----------\n\n        >   O(n)\n        \"\"\"\n        result = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            result[self.leader(i)].append(i)\n        return [g for g in result if g]\n\n\n\nMOD = 998244353\ntable_len = 110\n\nfac = [1, 1]\nfor i in range(2, table_len):\n    fac.append(fac[-1] * i % MOD)\n\nfinv = [0] * table_len\nfinv[-1] = pow(fac[-1], MOD - 2, MOD)\nfor i in range(table_len-1, 0, -1):\n    finv[i-1] = finv[i] * i % MOD\n\nN, K = list(map(int, input().split()))\nAs = [list(map(int, input().split())) for _ in range(N)]\n\ndef solve_row(mat):\n    uf = dsu(N)\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(N):\n                if mat[i][k] + mat[j][k] > K:\n                    break\n            else:\n                uf.merge(i, j)\n    groups = uf.groups()\n    ret = 1\n    for g in groups:\n        ret *= fac[len(g)]\n        ret %= MOD\n    return ret\n\ntAs = list(map(list, list(zip(*As))))\nprint((solve_row(As) * solve_row(tAs) % MOD))\n\n", "class DSU:\n    def __init__(self, N):\n        # stores parent node of given vertex\n        self.parents = list(range(N))\n        # gives size of component w given node\n        self.size = [1] * N\n\n    # runtime: amoritized O(1)\n    # returns root node\n    def find(self, x):\n        root = x\n        # finds parent node at the end of the chain\n        while self.parents[root] != root:\n            root = self.parents[root]\n\n        # optional: path compression\n        while (x != root):\n            nextx = self.parents[x]\n            self.parents[x] = root\n            x = nextx\n        \n        return root\n\n    # runtime: amortized O(1) by combining union by size and path compression\n    # unifies two components together (the ones containing x and y)\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        # if they're in same group, do nothing\n        if xr == yr:\n            return False\n\n        if self.size[xr] > self.size[yr]:\n            xr, yr = yr, xr\n        # size of xr >= size of yr\n        # smaller points to the larger\n        self.parents[xr] = yr\n        self.size[xr] += self.size[yr]\n        self.size[yr] = self.size[xr]\n        return True\n\n    def isConnected(self,x,y):\n        return self.find(x) == self.find(y)\n\n    def getSize(self, x):\n        return self.size[self.find(x)]\n\n\n# from collections import defaultdict, Counter, deque\n# from heapq import heappop, heappush, heapify\n# from functools import lru_cache, reduce\n# import bisect\n# from itertools import permutations, combinations, combinations_with_replacement\nfrom math import factorial as f\n\nmod = 998244353\nn, K = list(map(int, input().split()))\narr = []\nfor _ in range(n):\n    arr.append( list(map(int, input().split())) )\n\n# num of pairs you can swap\nrow_dsu = DSU(n)\ncol_dsu = DSU(n)\n\n# find rows\nfor i in range(n):\n    for j in range(i):\n        if all(arr[i][k] + arr[j][k] <= K for k in range(n)):\n            row_dsu.union(i,j)\n        if all(arr[k][i] + arr[k][j] <= K for k in range(n)):\n            col_dsu.union(i,j)\n    \nrow_set = set()\ncol_set = set()\nfor i in range(n):\n    row_set.add(row_dsu.find(i))\n    col_set.add(col_dsu.find(i))\n\nrow_prod = col_prod = 1\nfor ele in row_set:\n    row_prod *= f(row_dsu.size[ele])\nfor ele in col_set: \n    col_prod *= f(col_dsu.size[ele])\n\nprint(((row_prod * col_prod) % mod))\n\n", "import sys\nfrom math import factorial\nsys.setrecursionlimit(10**9)\nread = lambda:sys.stdin.readline()\n\ndef read_ints():\n    return list(map(int,read().split()))\ndef read_intgrid(h):\n    return list(list(map(int,read().split()))for i in range(h))\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [-1] * n\n        self.rank = [0] * n\n        self.group_count = n\n        self.n = n\n    \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        \n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.rank[x] == self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n            self.rank[x] += 1\n        \n        elif self.rank[x] > self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n        \n        self.group_count -= 1\n    \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def get_group_member_list(self, x):\n        x = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == x]\n    \n    def get_group_member_count(self, x):\n        x = self.find(x)\n        return -self.parents[x]\n \n    def get_all_groups(self):\n        return {idx:-n for idx, n in enumerate(self.parents) if n < 0}\n\ndef f(x):\n    tmp = 1\n    while x>0:\n        tmp*=x\n        x-=1\n    return tmp\n\ndef main():\n    #input data\n    n,k = map(int,input().split())\n    A = read_intgrid(n)\n\n    mod = 998244353\n\n    #solve\n    ans = 1\n    uf1 = UnionFind(n)\n    uf2 = UnionFind(n)\n\n    # fix by columns\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if all(A[i][c]+A[j][c]<=k for c in range(n)):\n                uf1.unite(i,j)\n            if all(A[c][i]+A[c][j]<=k for c in range(n)):\n                uf2.unite(i,j)\n\n    for k,v in uf1.get_all_groups().items():\n        ans*=f(v)\n        ans%=mod\n\n    for k,v in uf2.get_all_groups().items():\n        ans*=f(v)\n        ans%=mod\n    \n    return print(ans)\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind:\n  def __init__(self, n):\n    self.n = n\n    self.p = [-1]*n\n  def leader(self, a):\n    while self.p[a]>=0:\n      a = self.p[a]\n    return a\n  def merge(self, a, b):\n    x = self.leader(a)\n    y = self.leader(b)\n    if x==y:\n      return x\n    if self.p[x]>self.p[y]:\n      x, y = y, x\n    self.p[x] += self.p[y]\n    self.p[y] = x\n    return x\n\nf=lambda:map(int,input().split())\nn,k=f()\nA=[[*f()] for _ in range(n)]\nufh,ufw=UnionFind(n),UnionFind(n)\nfor y in range(n):\n  for x in range(y):\n    if all(A[h][x]+A[h][y]<=k for h in range(n)):\n      ufw.merge(x,y)\n    if all(A[x][w]+A[y][w]<=k for w in range(n)):\n      ufh.merge(x,y)\nM=998244353\nF=[1]\nfor i in range(1,51): F+=[i*F[-1]%M]\nc=1\nfor i in range(n):\n  if ufh.p[i]<0: c=c*F[-ufh.p[i]]%M\n  if ufw.p[i]<0: c=c*F[-ufw.p[i]]%M\nprint(c)", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n        \nimport itertools\n\nN,K = map(int,input().split())\nl = [list(map(int,input().split())) for i in range(N)]\n#print(l)\na = UnionFind(N)\nfor v in itertools.combinations(range(N),2):\n    for i in range(N):\n        if l[i][v[0]] + l[i][v[1]] > K:\n            break\n        if i == N-1:\n            a.union(v[0],v[1])\n#print(a)\n        \nb = UnionFind(N)\nfor v in itertools.combinations(range(N),2):\n    for i in range(N):\n        if l[v[0]][i] + l[v[1]][i] > K:\n            break\n        if i == N-1:\n            b.union(v[0],v[1])\n#print(b)\n\nans = 1\n\nfor x in a.roots():\n    for i in range(1,a.size(x)+1):\n        ans = (ans * i)%998244353\nfor x in b.roots():\n    for i in range(1,b.size(x)+1):\n        ans = (ans * i)%998244353\n    \nprint(ans)", "def MI():\n    return map(int, input().split())\n\nn,k= MI()\nmod=998244353\nframod=[1]\ndef framod_calc(n, mod, a=1):\n    for i in range(1,n+1):\n        a=a * i % mod\n        framod.append(a)\nframod_calc(n+1, mod)\ndef permmod(n, k, mod):\n    if n<k: return 0\n    a=framod[n]\n    c=framod[n-k]\n    return (a * pow(c, mod-2, mod)) % mod\n\nmat=[]\nmatinv=[[0]*n for _ in range(n)]\nfor i in range(n):\n    mat.append(list(MI()))\n\nfor i in range(n):\n    for j in range(n):\n        matinv[i][j]=mat[j][i]\n\nesrow=[]\nescol=[]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if mat[i][p]+mat[j][p]>k:\n                flg=False\n                break\n        if flg:\n            esrow.append((i,j))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if matinv[i][p]+matinv[j][p]>k:\n                flg=False\n                break\n        if flg:\n            escol.append((i,j))\n\nclass UnionFind(object): # size\u3092O(1)\u3067\u5f15\u3051\u308bversion\n    def __init__(self, n=1):\n        self.n=n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.sizebox = [1]*n\n    def find(self, x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u4ee3\u8868\u5143\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y): # x,y\u3092\u9023\u7d50\u3001\u3064\u3044\u3067\u306b\u30b5\u30a4\u30ba\u3082\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizebox[x]+=self.sizebox[y]\n    def same(self, x, y): # x,y\u304c\u9023\u7d50\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def size(self,x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50size\u3092O(1)\u3067\u51fa\u3059\n        x = self.find(x)\n        return self.sizebox[x]\n    def allfind(self): # find\u30921\u5468\u3059\u308b\n        for i in range(self.n):\n            self.find(i)\n\nufr=UnionFind(n)\nufc=UnionFind(n)\n\nfor i,j in esrow:\n    ufr.union(i,j)\n\nfor i,j in escol:\n    ufc.union(i,j)\n\nfor i in range(n):\n    ufr.find(i)\n    ufc.find(j)\n\nfrom collections import Counter\ncpar=Counter(ufc.par)\nrpar=Counter(ufr.par)\n\nans=1\n\nfor k in cpar.keys():\n    x=cpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nfor k in rpar.keys():\n    x=rpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nprint(ans%mod)", "n,k=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\n\nretu=[]\ngyou=[]\n\nfor i in range(n-1):\n    for j in range(i+1,n):\n        for p in range(n):\n            if a[i][p]+a[j][p]>k:\n                break\n        else:\n            gyou.append([i,j])\n        for q in range(n):\n            if a[q][i]+a[q][j]>k:\n                break\n        else:\n            retu.append([i,j])\n\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n\nretuuf=UnionFind(n)\ngyouuf=UnionFind(n)\n\nfor i in retu:\n    retuuf.union(i[0],i[1])\nfor i in gyou:\n    gyouuf.union(i[0],i[1])\n\ngyouans=1\nretuans=1\n\nretulist=list(retuuf.all_group_members().values())\ngyoulist=list(gyouuf.all_group_members().values())\n\nimport math\n\nfor i in retulist:\n    retuans*=math.factorial(len(i))\nfor i in gyoulist:\n    gyouans*=math.factorial(len(i))\n\nprint(retuans*gyouans%998244353)", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      px, py = find(i, uf1), find(j, uf1)\n      if px != py:\n        if rank1[px] > rank1[py]:\n          px, py = py, px\n        rank1[py] += rank1[px]\n        uf1[px] = py\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      px, py = find(i, uf2), find(j, uf2)\n      if px != py:\n        if rank2[px] > rank2[py]:\n          px, py = py, px\n        rank2[py] += rank2[px]\n        uf2[px] = py\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "import bisect, copy, heapq, math, sys\nfrom collections import *\nfrom functools import lru_cache\nfrom itertools import accumulate, combinations, permutations, product\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\ndef celi(a,b):\n    return -(-a//b)\nsys.setrecursionlimit(5000000)\nmod=998244353\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn,k=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\n\nclass WeightedUnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.weight = [0] * (n+1)\n        self.sizes = [1] * (n+1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            y = self.find(self.par[x])\n            self.weight[x] += self.weight[self.par[x]]\n            self.par[x] = y\n            return y\n\n    def union(self, x, y, w=1):\n        rx = self.find(x)\n        ry = self.find(y)\n        if self.rank[rx] < self.rank[ry]:\n            self.sizes[ry] += self.size(rx)\n            self.par[rx] = ry\n            self.weight[rx] = w - self.weight[x] + self.weight[y]\n        else:\n            self.sizes[rx] += self.size(ry)\n            self.par[ry] = rx\n            self.weight[ry] = -w - self.weight[y] + self.weight[x]\n            if self.rank[rx] == self.rank[ry]:\n                self.rank[rx] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def diff(self, x, y):\n        return self.weight[x] - self.weight[y]\n\n    def size(self, x):\n        return self.sizes[self.find(x)]\n# print(a)\nretsu=WeightedUnionFind(n)\ngyo=WeightedUnionFind(n)\n\nfor i in range(n):\n    for j in range(i+1,n):\n        for l in range(n):\n            if a[l][i]+a[l][j]>k:\n                break\n        else:\n            if not retsu.same(i,j):\n                retsu.union(i,j)\n# print(retsu)\nfor i in range(n):\n    for j in range(i+1,n):\n        for l in range(n):\n            if a[i][l]+a[j][l]>k:\n                break\n        else:\n            if not gyo.same(i,j):\n                gyo.union(i,j)\n\nans=1\ndef keisan(ans,m):\n    for i in range(m):\n        ans*=i+1\n        ans%=mod\n    return ans\n\n# print(retsu.par)\n# print(gyo.par)\n\nfor i in range(n):\n    if i==retsu.find(i):\n        ans=keisan(ans,retsu.size(i))\n    if i==gyo.find(i):\n        ans=keisan(ans,gyo.size(i))\nprint(ans)", "from math import factorial\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    \n    #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    #x\u306e\u30b0\u30eb\u30fc\u30d7\u3068y\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    #x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nn, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nmod = 998244353\nans = 1\nflag = 1\n\nuf = UnionFind(n)\n# \u884c\u65b9\u5411\nfor r1 in range(n):\n    for r2 in range(r1+1, n):\n        for c in range(n):\n            flag = 1\n            if a[r1][c]+a[r2][c] > k:\n                flag = 0\n                break\n        \n        if flag:\n            uf.union(r1, r2)\nfor i in range(n):\n    if uf.parents[i] < 0:\n        ans *= factorial(uf.size(i))\n        ans %= mod\n\nuf = UnionFind(n)\n\n# \u5217\nfor c1 in range(n):\n    for c2 in range(c1+1, n):\n        for r in range(n):\n            flag = 1\n            if a[r][c1]+a[r][c2] > k:\n                flag = 0\n                break\n        if flag:\n            uf.union(c1, c2)\n\nfor i in range(n):\n    if uf.parents[i] < 0:\n        ans *= factorial(uf.size(i))\n        ans %= mod\nprint(ans)", "n, k = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(n)]\n\ndef Find(x, par):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = Find(par[x], par)\n        return par[x]\n\ndef Unite(x, y, par, rank):\n    x = Find(x, par)\n    y = Find(y, par)\n\n    if x != y:\n        if rank[x] < rank[y]:\n            par[y] += par[x]\n            par[x] = y\n        else:\n            par[x] += par[y]\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\ndef Same(x, y, par):\n    return Find(x, par) == Find(y, par)\n\ndef Size(x, par):\n    return -par[Find(x, par)]\n\npar1 = [-1]*n\nrank1 = [0]*n\nfor x in range(n):\n    for y in range(n):\n        for i in range(n):\n            if A[x][i]+A[y][i] > k:\n                break\n        else:\n            Unite(x, y, par1, rank1)\n\npar2 = [-1]*n\nrank2 = [0]*n\nfor x in range(n):\n    for y in range(n):\n        for i in range(n):\n            if A[i][x]+A[i][y] > k:\n                break\n        else:\n            Unite(x, y, par2, rank2)\n\nN = 1000\nmod = 998244353\nfac = [1]*(N+1)\nfinv = [1]*(N+1)\nfor i in range(N):\n    fac[i+1] = fac[i] * (i+1) % mod\nfinv[-1] = pow(fac[-1], mod-2, mod)\nfor i in reversed(list(range(N))):\n    finv[i] = finv[i+1] * (i+1) % mod\n\nans = 1\nfor i in par1:\n    if i < 0:\n        ans *= fac[-i]\n        ans %= mod\nfor i in par2:\n    if i < 0:\n        ans *= fac[-i]\n        ans %= mod\nprint(ans)\n", "n, k = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(n)]\n\ndef Find(x, par):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = Find(par[x], par)\n        return par[x]\n\ndef Unite(x, y, par, rank):\n    x = Find(x, par)\n    y = Find(y, par)\n\n    if x != y:\n        if rank[x] < rank[y]:\n            par[y] += par[x]\n            par[x] = y\n        else:\n            par[x] += par[y]\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\ndef Same(x, y, par):\n    return Find(x, par) == Find(y, par)\n\ndef Size(x, par):\n    return -par[Find(x, par)]\n\npar1 = [-1]*n\nrank1 = [0]*n\nfor x in range(n):\n    for y in range(n):\n        for i in range(n):\n            if A[x][i]+A[y][i] > k:\n                break\n        else:\n            Unite(x, y, par1, rank1)\n\npar2 = [-1]*n\nrank2 = [0]*n\nfor x in range(n):\n    for y in range(n):\n        for i in range(n):\n            if A[i][x]+A[i][y] > k:\n                break\n        else:\n            Unite(x, y, par2, rank2)\n\nN = 1000\nmod = 998244353\nfac = [1]*(N+1)\nfinv = [1]*(N+1)\nfor i in range(N):\n    fac[i+1] = fac[i] * (i+1) % mod\nfinv[-1] = pow(fac[-1], mod-2, mod)\nfor i in reversed(list(range(N))):\n    finv[i] = finv[i+1] * (i+1) % mod\n\nans = 1\nfor i in par1:\n    if i < 0:\n        ans *= fac[-i]\n        ans %= mod\nfor i in par2:\n    if i < 0:\n        ans *= fac[-i]\n        ans %= mod\nprint(ans)\n", "from collections import defaultdict\nimport math\nimport numpy as np\n\nn, k = map(int, input().split())\na_lists = [list(map(int, input().split())) for _ in range(n)]\nmod = 998244353\n\na_lists = np.array(a_lists)\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n\ndef count_point(np_array):\n    uf = UnionFind(n)\n    for i in range(n):\n        a = np_array[i]\n        for j in range(i, n):\n            b = np_array[j]\n            if np.count_nonzero(a + b <= k) == n:\n                uf.union(i, j)\n    point = 1\n    for i, j in uf.all_group_members().items():\n        point *= math.factorial(len(j))\n        point %= mod\n    return point\n\nans = count_point(a_lists)\na_lists_T = a_lists.T\nans *= count_point(a_lists_T)\nans %= mod\n\nprint(ans)", "N,K=map(int,input().split())\ndata=[list(map(int,input().split())) for i in range(N)]\nimport math\n#\u884c\nans1=[]\nfor i in range(N-1):\n    for j in range(i+1,N):\n        m=0\n        for k in range(N):\n            if data[i][k]+data[j][k]>K:\n                m+=1\n                break\n        if m==0:\n            ans1.append([i,j])\n#\u5217\nans2=[]\nfor i in range(N-1):\n    for j in range(i+1,N):\n        m=0\n        for k in range(N):\n            if data[k][i]+data[k][j]>K:\n                m+=1\n                break\n        if m==0:\n            ans2.append([i,j])\n#\u884c\nli1=[[] for i in range(N)]\nfor i in range(len(ans1)):\n    li1[ans1[i][0]].append(ans1[i][1])\n    li1[ans1[i][1]].append(ans1[i][0])\nL1=[-1]*N\nfor i in range(N):\n    if L1[i]!=-1:\n        continue\n    L1[i]=i\n    deque=[i]\n    while deque:\n        x=deque.pop(0)\n        for j in li1[x]:\n            if L1[j]==-1:\n                L1[j]=i\n                deque.append(j)\nnum1=1\nl1=list(set(L1))\nfor i in l1:\n    num1*=int(math.factorial(L1.count(i)))\n    num1=num1%998244353\n#\u5217\nli2=[[] for i in range(N)]\nfor i in range(len(ans2)):\n    li2[ans2[i][0]].append(ans2[i][1])\n    li2[ans2[i][1]].append(ans2[i][0])\nL2=[-1]*N\nfor i in range(N):\n    if L2[i]!=-1:\n        continue\n    L2[i]=i\n    deque=[i]\n    while deque:\n        x=deque.pop(0)\n        for j in li2[x]:\n            if L2[j]==-1:\n                L2[j]=i\n                deque.append(j)\nnum2=1\nl2=list(set(L2))\nfor i in l2:\n    num2*=int(math.factorial(L2.count(i)))\n    num2=num2%998244353\nprint((num1*num2)%998244353)", "import sys\nread=sys.stdin.readline\ndef MAP():\n    return map(int,read().split())\ndef I():\n    return int(read())\ndef LI():\n    return list(map(int,read().split()))\n    \nMOD=998244353\n\nclass UnionFind:\n    def __init__(self,N):\n        self.par=[i for i in range(N)]\n        self.siz=[1 for _ in range(N)]\n        self.rank=[0 for _ in range(N)]\n    def find(self,x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x]=self.find(self.par[x])\n            return self.par[x]\n    def union(self,a,b):\n        a=self.find(a)\n        b=self.find(b)\n        if a==b:\n            return 0\n        else:\n            if self.rank[a]>self.rank[b]:\n                self.par[b]=a\n                self.siz[a]+=self.siz[b]\n            else:\n                self.par[a]=b\n                self.siz[b]+=self.siz[a]\n                if self.rank[a]==self.rank[b]:\n                    self.rank[b]+=1\n    def size(self,a):\n        return self.siz[self.find(a)]\n    def same(self,a,b):\n        return self.find(a)==self.find(b)\n\nN,K=MAP()\na=[LI() for _ in range(N)]\nUFg=UnionFind(N)\nUFr=UnionFind(N)\nfac=[1]*(N+1)\nfor i in range(2,N+1):\n    fac[i]=fac[i-1]*i%MOD\n\nfor i in range(N):\n    for j in range(i):\n        isokg=True\n        isokr=True\n        for k in range(N):\n            if a[i][k]+a[j][k]>K:\n                isokg=False\n            if a[k][i]+a[k][j]>K:\n                isokr=False\n        if isokg:\n            UFg.union(i,j)\n        if isokr:\n            UFr.union(i,j)\n\nfrom collections import Counter\ndicg=Counter([UFg.find(i) for i in range(N)])\ndicr=Counter([UFr.find(i) for i in range(N)])\n\nresg,resr=1,1\nfor x,size in dicg.items():\n    resg=resg*fac[size]%MOD\nfor y,size in dicr.items():\n    resr=resr*fac[size]%MOD\nprint(resg*resr%MOD)", "def MI():\n    return map(int, input().split())\n\nn,k= MI()\nmod=998244353\nframod=[1]\ndef framod_calc(n, mod, a=1):\n    for i in range(1,n+1):\n        a=a * i % mod\n        framod.append(a)\nframod_calc(n+1, mod)\ndef permmod(n, k, mod):\n    if n<k: return 0\n    a=framod[n]\n    c=framod[n-k]\n    return (a * pow(c, mod-2, mod)) % mod\n\nmat=[]\nmatinv=[[0]*n for _ in range(n)]\nfor i in range(n):\n    mat.append(list(MI()))\n\nfor i in range(n):\n    for j in range(n):\n        matinv[i][j]=mat[j][i]\n\nesrow=[]\nescol=[]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if mat[i][p]+mat[j][p]>k:\n                flg=False\n                break\n        if flg:\n            esrow.append((i,j))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if matinv[i][p]+matinv[j][p]>k:\n                flg=False\n                break\n        if flg:\n            escol.append((i,j))\n\nclass UnionFind(object): # size\u3092O(1)\u3067\u5f15\u3051\u308bversion\n    def __init__(self, n=1):\n        self.n=n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.sizebox = [1]*n\n    def find(self, x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u4ee3\u8868\u5143\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y): # x,y\u3092\u9023\u7d50\u3001\u3064\u3044\u3067\u306b\u30b5\u30a4\u30ba\u3082\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizebox[x]+=self.sizebox[y]\n            self.sizebox[y]=0\n    def same(self, x, y): # x,y\u304c\u9023\u7d50\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def size(self,x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50size\u3092O(1)\u3067\u51fa\u3059\n        x = self.find(x)\n        return self.sizebox[x]\n    def allfind(self): # find\u30921\u5468\u3059\u308b\n        for i in range(self.n):\n            self.find(i)\n\nufr=UnionFind(n)\nufc=UnionFind(n)\n\nfor i,j in esrow:\n    ufr.union(i,j)\n\nfor i,j in escol:\n    ufc.union(i,j)\n\nfor i in range(n):\n    ufr.find(i)\n    ufc.find(i)\n\nckey=set(ufc.par)\nrkey=set(ufr.par)\n\nans=1\n\nfor k in ckey:\n    x=ufc.size(k)\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nfor k in rkey:\n    x=ufr.size(k)\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nprint(ans%mod)", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1] * n\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def size(self, x):\n        return -self.par[self.find(x)]\n\nn,k=list(map(int,input().split()))\nA=[list(map(int, input().split())) for _ in range(n)]\n\nuf1=UnionFind(n)\nuf2=UnionFind(n)\n\nmod=998244353\n\nfct=[1]\nfor i in range(1,101):\n    fct.append(fct[-1]*i%mod)\n\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        if all(A[c][i] + A[c][j] <= k for c in range(n)):\n            uf1.unite(i, j)\n        if all(A[i][c] + A[j][c] <= k for c in range(n)):\n            uf2.unite(i, j)\nans = 1\nfor i in range(n):\n    if uf1.par[i] < 0:\n        ans *= fct[-uf1.par[i]]\n        ans %= mod\n    if uf2.par[i] < 0:\n        ans *= fct[-uf2.par[i]]\n        ans %= mod\nprint(ans)\n\n\n", "class DisjointSetUnion():\n    def __init__(self, n):\n        self.n = n\n        self.par_size = [-1] * n\n\n    def merge(self, a, b):\n        #assert 0 <= a < self.n\n        #assert 0 <= b < self.n\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y: return x\n        if -self.par_size[x] < -self.par_size[y]: x, y = y, x\n        self.par_size[x] += self.par_size[y]\n        self.par_size[y] = x\n        return x\n\n    def same(self, a, b):\n        #assert 0 <= a < self.n\n        #assert 0 <= b < self.n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a):\n        #assert 0 <= a < self.n\n        x = a\n        while self.par_size[x] >= 0:\n            x = self.par_size[x]\n        while self.par_size[a] >= 0:\n            self.par_size[a] = x\n            a = self.par_size[a]\n        return x\n\n    def size(self, a):\n        #assert 0 <= a < self.n\n        return -self.par_size[self.leader(a)]\n\ndef build_factorial(n):\n    fct = [0] * (n + 1)\n    inv = [0] * (n + 1)\n    fct[0] = inv[0] = 1\n    for i in range(n):\n        fct[i + 1] = fct[i] * (i + 1) % MOD\n    inv[n] = pow(fct[n], MOD - 2, MOD)\n    for i in range(n)[::-1]:\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    return fct, inv\n\nMOD = 998244353\nfrom itertools import combinations\n\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\n\nuf1 = DisjointSetUnion(N)\nuf2 = DisjointSetUnion(N)\n\nfor i, j in combinations(range(N), 2):\n    for k in range(N):\n        if A[i][k] + A[j][k] > K:\n            break\n    else:\n        uf1.merge(i, j)\n        \n    for k in range(N):\n        if A[k][i] + A[k][j] > K:\n            break\n    else:\n        uf2.merge(i, j)\n\nfct, inv = build_factorial(N)\nres = 1\n\nfor i in range(N):\n    if uf1.par_size[i] < 0:\n        res *= fct[-uf1.par_size[i]]\n        res %= MOD\n    if uf2.par_size[i] < 0:\n        res *= fct[-uf2.par_size[i]]\n        res %= MOD\n\nprint(res)", "N,K = map(int,input().split())\n\nA = [list(map(int,input().split())) for _ in [0]*N]\nMOD = 998244353\nB = [[A[j][i] for j in range(N)] for i in range(N)]\n\ndef f(A):\n    import sys\n    sys.setrecursionlimit(10**7)\n\n    class UnionFind:\n        def __init__(self,N):\n            self.Parent = list(range(N))\n            self.size = [1]*N\n        def get_Parent(self,n):\n            if self.Parent[n] == n:return n\n            p = self.get_Parent(self.Parent[n])\n            self.Parent[n] = p\n            return p\n        def get_size(self,n):\n            return self.size[self.get_Parent(n)]\n        def merge(self,x,y):\n            x = self.get_Parent(x)\n            y = self.get_Parent(y)\n            if x!=y:\n                if self.get_size(x) < self.get_size(y):\n                    x,y = y,x\n                self.size[x] += self.size[y]\n                self.Parent[y] = x\n                return True\n            return False\n        def is_united(self,x,y):\n            return self.get_Parent(x)==self.get_Parent(y)\n\n    U_row = UnionFind(N)\n    for i in range(N):\n        for j in range(i+1,N):\n            if U_row.is_united(i,j): continue\n            for k in range(N):\n                if A[i][k] + A[j][k] > K:break\n            else:\n                U_row.merge(i,j)\n\n    ans = 1\n    for i in range(N):\n        j = U_row.get_Parent(i)\n        if i==j:\n            tmp = 1\n            s = U_row.get_size(i)\n            for k in range(2,s+1):\n                tmp = tmp*k%MOD\n            ans = ans*tmp%MOD\n    return ans%MOD\n\nans = f(A)*f(B)%MOD\nprint(ans)", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n\ndef union(x, y, uf, rank):\n    px, py = find(x, uf), find(y, uf)\n    if px != py:\n        if rank[px] > rank[py]:\n            px, py = py, px\n        rank[py] += rank[px]\n        uf[px] = py\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      union(i, j, uf1, rank1)\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      union(i, j, uf2, rank2)\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            if not self.same_check(x, y):\n                self.size[y] += self.size[x]\n                self.size[x] = 0\n            self.par[x] = y\n        else:\n            if not self.same_check(x, y):\n                self.size[x] += self.size[y]\n                self.size[y] = 0\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def siz(self, x):\n        x = self.find(x)\n        return self.size[x]\n\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nUFX = UnionFind(N)\nUFY = UnionFind(N)\nmod = 998244353\n\nfact = [1]\nfor i in range(1, N+1):\n    fact.append(fact[-1] * i)\n\nfor i in range(1, N):\n    for j in range(i):\n        flag = True\n        for k in range(N):\n            if A[k][i] + A[k][j] > K:\n                flag = False\n                break\n        if flag:\n            UFY.union(i, j)\n        flag = True\n        for k in range(N):\n            if A[i][k] + A[j][k] > K:\n                flag = False\n                break\n        if flag:\n            UFX.union(i, j)\nans = 1\n\nfor i in range(N):\n    if UFX.find(i) == i:\n        ans *= fact[UFX.siz(i)]\n        ans %= mod\n    if UFY.find(i) == i:\n        ans *= fact[UFY.siz(i)]\n        ans %= mod\n\nprint(ans)", "class UnionFind:\n  '''\n  UnionFind(n) : n\u9802\u70b90\u8fba\u306e\u7121\u5411\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\u3059\u308b O(n)\n    p:\u89aa\u30ce\u30fc\u30c9\u756a\u53f7(\u4ee3\u8868\u5143\u4ee5\u5916)\u3001\u6728\u306e\u30b5\u30a4\u30ba\u306e\u8ca0\u6570(\u4ee3\u8868\u5143)\u3092\u683c\u7d0d\n  leader(a)    : a\u306e\u5c5e\u3059\u308b\u4ee3\u8868\u5143\u3092\u8fd4\u3059 O(\u03b1(n))\n  merge(a,b)   : a,b\u3092\u8fba\u3067\u7d50\u3073\u3001\u4ee3\u8868\u5143\u3092\u8fd4\u3059 O(\u03b1(n))\n  same(a,b)    : a,b\u304c\u9023\u7d50\u304b\u5426\u304b\u3092\u8fd4\u3059 O(\u03b1(n))\n  size(a)      : a\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059 O(\u03b1(n))\n  count()      : \u30b0\u30eb\u30fc\u30d7\u6570\u3092\u8fd4\u3059 O(n)\n  groups()     : \u30b0\u30e9\u30d5\u3092set\u306b\u30b0\u30eb\u30fc\u30d7\u5206\u3051\u3057\u3066\u8fd4\u3059 O(n)\n  '''\n  def __init__(self, n):\n    self.n = n\n    self.p = [-1]*n\n  def leader(self, a):\n    while self.p[a]>=0:\n      a = self.p[a]\n    return a\n  def merge(self, a, b):\n    x = self.leader(a)\n    y = self.leader(b)\n    if x==y:\n      return x\n    if self.p[x]>self.p[y]:\n      x, y = y, x\n    self.p[x] += self.p[y]\n    self.p[y] = x\n    return x\n  def same(self, a, b):\n    return self.leader(a)==self.leader(b)\n  def size(self, a):\n    return -self.p[self.leader(a)]\n  def count(self):\n    return sum(i<0 for i in self.p)\n  def groups(self):\n    leader_buf = [0]*self.n\n    group_size = [0]*self.n\n    res = [set() for _ in range(self.n)]\n    for i in range(self.n):\n      leader_buf[i] = self.leader(i)\n      group_size[leader_buf[i]] += 1\n    for i in range(self.n):\n      res[leader_buf[i]].add(i)\n    res = [s for s in res if s]\n    return res\n\nf=lambda:map(int,input().split())\nn,k=f()\nA=[[*f()] for _ in range(n)]\nufh,ufw=UnionFind(n),UnionFind(n)\nfor y in range(n):\n  for x in range(y):\n    if all(A[h][x]+A[h][y]<=k for h in range(n)):\n      ufw.merge(x,y)\n    if all(A[x][w]+A[y][w]<=k for w in range(n)):\n      ufh.merge(x,y)\nM=998244353\nF=[1]\nfor i in range(1,51): F+=[i*F[-1]%M]\nc=1\nfor i in range(n):\n  if ufh.p[i]<0: c=c*F[-ufh.p[i]]%M\n  if ufw.p[i]<0: c=c*F[-ufw.p[i]]%M\nprint(c)", "import sys\n\nreadline = sys.stdin.readline\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\nclass UnionFind:\n    \"\"\"\n    0-indexed\n    \"\"\"\n\n    from typing import List\n\n    def __init__(self, n):\n        from array import array\n\n        self.n = n\n        self.parent = array('l', (-1 for _ in range(n)))\n\n    def unite(self, x, y) -> int:\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return 0\n\n        if self.parent[x] > self.parent[y]:\n            x, y = y, x\n\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n\n        return self.parent[x]\n\n    def is_same(self, x, y) -> bool:\n        return self.root(x) == self.root(y)\n\n    def root(self, x) -> int:\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def size(self, x) -> int:\n        return -self.parent[self.root(x)]\n\n    def groups(self) -> List[List[int]]:\n        groups = dict()\n\n        for i in range(self.n):\n            p = self.root(i)\n            if not groups.get(p):\n                groups[p] = []\n            groups[p].append(i)\n\n        return list(groups.values())\n\n\ndef main():\n    def factorial(x):\n        res = 1\n        for i in range(1, x + 1):\n            res *= i\n            res %= MOD\n        return res\n\n    def judge1(first, second):\n        for i in range(N):\n            if grid[first][i] + grid[second][i] > K:\n                return False\n        return True\n\n    def judge2(first, second):\n        for i in range(N):\n            if grid[i][first] + grid[i][second] > K:\n                return False\n        return True\n\n    MOD = 998244353\n\n    N, K = list(map(int, readline().split()))\n    grid = []\n\n    for _ in range(N):\n        s = list(map(int, readline().split()))\n        grid.append(s)\n\n    cnt_r, cnt_c = 1, 1\n    uf = UnionFind(N + 1)\n\n    for i in range(N):\n        for j in range(i, N):\n            if judge1(i, j):\n                uf.unite(i, j)\n\n    for gr in uf.groups():\n        x = len(gr)\n        cnt_r *= factorial(x)\n        cnt_r %= MOD\n\n    uf = UnionFind(N + 1)\n\n    for i in range(N):\n        for j in range(i, N):\n            if judge2(i, j):\n                uf.unite(i, j)\n\n    for gr in uf.groups():\n        x = len(gr)\n        cnt_c *= factorial(x)\n        cnt_c %= MOD\n\n    print(((cnt_r * cnt_c) % MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport numpy as np\nfrom itertools import combinations\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return True\n    \n    def roots_size(self):\n        return [-x for x in self.parents if x < 0]\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ndef main():\n    mod = 998244353\n    n, k = map(int, input().split())\n    A = np.array(sys.stdin.read().split(), dtype=np.int64).reshape((n, -1))\n    uf_r = UnionFind(n)\n    uf_c = UnionFind(n)\n    for i, j in combinations(range(n), 2):\n        if np.all(A[i, :] + A[j, :] <= k):\n            uf_r.union(i, j)\n        if np.all(A[:, i] + A[:, j] <= k):\n            uf_c.union(i, j)\n    s = 1\n    factorial_table = [1]\n    for i in range(1, n + 1):\n        s *= i\n        s %= mod\n        factorial_table.append(s)\n    ans = 1\n    for size in uf_r.roots_size() + uf_c.roots_size():\n        ans *= factorial_table[size]\n        ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nimport numpy as np\nfrom networkx.utils import UnionFind\n\nN, K = list(map(int, input().split()))\nA = np.array([tuple(map(int, input().split())) for _ in range(N)])\n\nMOD = 998244353\nMAX = 50\nfactorial = [1] * (MAX + 1)\nfor i in range(1, MAX + 1):\n    factorial[i] = factorial[i - 1] * i % MOD\n\nuf_row = UnionFind(list(range(N)))\nfor i, j in itertools.combinations(list(range(N)), 2):\n    if np.all(A[:, i] + A[:, j] <= K):\n        uf_row.union(i, j)\nuf_col = UnionFind(list(range(N)))\nfor i, j in itertools.combinations(list(range(N)), 2):\n    if np.all(A[i] + A[j] <= K):\n        uf_col.union(i, j)\n\nrow_res = 1\nfor group in uf_row.to_sets():\n    row_res = row_res * factorial[len(group)] % MOD\ncol_res = 1\nfor group in uf_col.to_sets():\n    col_res = col_res * factorial[len(group)] % MOD\n\nprint((row_res * col_res % MOD))\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\ndef fact(n, mod=998244353):\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= i\n        ans %= mod\n    return ans\n\nmod = 998244353\n\nn, k = map(int, input().split())\nlst = [[int(i) for i in input().split()] for _ in range(n)]\n\nans = 1\nun1 = UnionFind(n)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        flag = True\n        for l in range(n):\n            if lst[i][l] + lst[j][l] > k:\n                flag = False\n                break\n        if flag:\n            un1.union(i, j)\nfor i in range(n):\n    if i == un1.find(i):\n        num = un1.size(i)\n        ans *= fact(num)\n        ans %= mod\n\nun2 = UnionFind(n)\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        flag = True\n        for l in range(n):\n            if lst[l][i] + lst[l][j] > k:\n                flag = False\n                break\n        if flag:\n            un2.union(i, j)\nfor i in range(n):\n    if i == un2.find(i):\n        num = un2.size(i)\n        ans *= fact(num)\n        ans %= mod\nprint(ans)", "from collections import defaultdict\nimport math\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\nN, K = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(N)]\n\nc_pattern = list() # swapable \u306ac\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\nr_pattern = list() # swapable \u306ar\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\n\nfor c1 in range(N):\n    for c2 in range(c1+1, N):\n        ok = True\n        for i in range(N):\n            if a[i][c1] + a[i][c2] > K:\n                ok = False\n                break\n        if ok: c_pattern.append([c1, c2])\n\n\nfor r1 in range(N):\n    for r2 in range(r1+1, N):\n        ok = True\n        for i in range(N):\n            if a[r1][i] + a[r2][i] > K:\n                ok = False\n                break\n        if ok: r_pattern.append([r1, r2])\n\ndef total_pattern(pattern_list):\n    uf = UnionFind(N)\n    for p in pattern_list:\n        uf.union(p[0], p[1])\n    ans = 1\n    # print(uf.roots())\n    for r in uf.roots():\n        ans *= math.factorial(uf.size(r))\n    \n    return ans\n\nprint(total_pattern(c_pattern)*total_pattern(r_pattern)%998244353)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*n\n        self.rank = [0]*n\n\n    def find(self, x):\n        if self.root[x-1] < 0:\n            return x\n        else:\n            self.root[x-1] = self.find(self.root[x-1])\n            return self.root[x-1]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x==y:\n            return\n        elif self.rank[x-1] > self.rank[y-1]:\n            self.n-=1\n            self.root[x-1] += self.root[y-1]\n            self.root[y-1] = x\n        else:\n            self.n-=1\n            self.root[y-1] += self.root[x-1]\n            self.root[x-1] = y\n            if self.rank[x-1] == self.rank[y-1]:\n                self.rank[y-1] += 1\n\n    def same(self, x, y):\n        return self.find(x)==self.find(y)\n\n    def count(self, x):\n        return -self.root[self.find(x)-1]\n\n    def size(self):\n        return self.n\n\n    def roots(self):\n        return [x+1 for x in range(n) if self.root[x] < 0]\n\nmod=998244353\nn,K=map(int,input().split())\nA=[list(map(int,input().split())) for _ in range(n)]\n\nr=UnionFind(n)\nc=UnionFind(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        pr,pc=True,True\n        for k in range(n):\n            if A[i][k]+A[j][k]>K:\n                pr=False\n            if A[k][i]+A[k][j]>K:\n                pc=False\n        if pr: r.unite(i+1,j+1)\n        if pc: c.unite(i+1,j+1)\np=[1]*(n+1)\nfor i in range(1,n+1):\n    p[i]=(p[i-1]*i)%mod\nans=1\nfor x in r.roots():\n    ans=ans*p[-r.root[x-1]]%mod\nfor x in c.roots():\n    ans=ans*p[-c.root[x-1]]%mod\nprint(ans)", "import numpy as np\n\n\nclass UnionFind:\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n        self.size = [1] * (N+1)\n\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        sx, sy = self.size[x], self.size[y]\n        if sx < sy:\n            x, y = y, x\n            sx, sy = sy, sx\n        self.root[y] = x\n        self.size[x] += sy\n        self.size[y] = 0\n\n    def same(self, x, y):\n        return self[x] == self[y]\n\n    def find_max(self):\n        return max(self.size)\n\n\nN, K = list(map(int, input().split()))\nA = np.array([list(map(int, input().split())) for _ in range(N)], dtype=np.int64)\nans = 1\n# rows and columns\nfor step in range(2):\n    if step == 1:\n        A = A.T\n\n    uf = UnionFind(N)\n    merge = uf.merge\n    same = uf.same\n    comb = 1\n\n    # swap ok?\n    for i in range(N):\n        for j in range(i+1, N):\n            if np.all(A[i, :] + A[j, :] <= K):\n                merge(i+1, j+1)\n\n    # prod of tree-size!\n    for i in uf.size:\n        comb *= np.math.factorial(i)\n        comb %= 998244353\n\n    ans *= comb\n    ans %= 998244353\n\nprint(ans)\n", "import sys, bisect, math, itertools, string, queue, copy, heapq, collections, itertools\n# input = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 998244353\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplt(n): return [tuple(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\n#UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n        \nn,k = inpm()\nA = inpll(n)\n        \nuf_r = UnionFind(n)\nuf_c = UnionFind(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        flg = True\n        for l in range(n):\n            if A[i][l] + A[j][l] > k:\n                flg = False\n                break\n        if flg:\n            uf_c.union(i,j)\n            \n        flg = True\n        for l in range(n):\n            if A[l][i] + A[l][j] > k:\n                flg = False\n                break\n        if flg:\n            uf_r.union(i,j)\n\nans = 1\nfor i in uf_c.roots():\n    ans = (ans * math.factorial(uf_c.parents[i] * -1)) % mod\nfor i in uf_r.roots():\n    ans = (ans * math.factorial(uf_r.parents[i] * -1)) % mod\n    \nprint(ans)\n", "from functools import partial, reduce\n\n\nclass Mint:\n    def __init__(self, x, mod=10**9 + 7):\n        self.x = x.x if isinstance(x, Mint) else x % mod\n        self.mod = mod\n        self._mint = partial(Mint, mod=mod)\n\n    @staticmethod\n    def xgcd(a, b):\n        \"\"\" return (g, x, y) such that a*x + b*y = g = gcd(a, b) \"\"\"\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q*y1\n            x0, x1 = x1, x0 - q*x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        assert g == 1\n        return x % self.mod\n\n    def __str__(self):\n        return str(self.x)\n\n    def __repr__(self):\n        return repr(self.x)\n\n    def __eq__(self, x):\n        return self.x == self._mint(x).x\n\n    def __ne__(self, x):\n        return self.x != self._mint(x).x\n\n    def __int__(self):\n        return self.x\n\n    def __index__(self):\n        return self.x\n\n    def __add__(self, x):\n        return self._mint(self.x + self._mint(x).x)\n\n    def __radd__(self, x):\n        return self._mint(self.x + self._mint(x).x)\n\n    def __sub__(self, x):\n        return self._mint(self.x - self._mint(x).x)\n\n    def __rsub__(self, x):\n        return self._mint(self._mint(x).x - self.x)\n\n    def __mul__(self, x):\n        return self._mint(self.x * self._mint(x).x)\n\n    def __rmul__(self, x):\n        return self._mint(self.x * self._mint(x).x)\n\n    def __truediv__(self, x):\n        return self._mint(self.x * self.modinv(self._mint(x).x))\n\n    def __floordiv__(self, x):\n        return self._mint(self.x * self.modinv(self._mint(x).x))\n\n    def __pow__(self, x):\n        return self._mint(pow(self.x, x, self.mod))\n\n    def __rpow__(self, x):\n        return self._mint(pow(self._mint(x).x, self.x, self.mod))\n\n\nclass MintFactorial:\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n        self._mint = partial(Mint, mod=mod)\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        n = self._mint(n).x\n        \"\"\" n! (mod m) \"\"\"\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._mint(self._factorial[n])\n\n    def _make(self, n):\n        \"\"\" Calc from self._size to n!^-1 : O(n) \"\"\"\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def fact_inv(self, n):\n        \"\"\" n!^-1 (mod m) \"\"\"\n        assert n >= self.mod\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        if self._factorial_inv[n] == -1:\n            self._factorial_inv[n] = self.modinv(self.fact(n))\n        return self._mint(self._factorial_inv[n])\n\n    def _make_inv(self, n, r=1):\n        \"\"\" Calc r!^1 ... n!^-1 : O(n-r) \"\"\"\n        if n >= self.m:\n            n = self.m - 1\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        self._factorial_inv[n] = self.modinv(self.fact(n))\n        for i in range(n, r+1, -1):\n            self._factorial_inv[i-1] = self._factorial_inv[i]*i % self.mod\n\n    @staticmethod\n    def xgcd(a, b):\n        \"\"\" Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b) \"\"\"\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        \"\"\" n^-1 (mod m) \"\"\"\n        g, x, _ = self.xgcd(n, self.mod)\n        assert g != 1\n        return self._mint(x)\n\n    def comb(self, n, r):\n        \"\"\" nCr (mod m) \"\"\"\n        if r > n:\n            return 0\n        t = self(n)*self.fact_inv(n-r) % self.mod\n        return self._mint(t*self.fact_inv(r))\n\n    def comb_(self, n, r):\n        \"\"\" nCr (mod m) : O(r) \"\"\"\n        c = 1\n        for i in range(1, r+1):\n            c *= (n-i+1) * self.fact_inv(i)\n            c %= self.mod\n        return self._mint(c)\n\n    def comb_with_repetition(self, n, r):\n        \"\"\" nHr (mod m) \"\"\"\n        t = self(n+r-1)*self.fact_inv(n-1) % self.mod\n        return self._mint(t*self.fact_inv(r))\n\n    def perm(self, n, r):\n        \"\"\" nPr (mod m) \"\"\"\n        if r > n:\n            return 0\n        return self._mint(self(n)*self.fact_inv(n-r))\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self._n = n\n        self._table = [-1]*n\n\n    def _root(self, x):\n        stack = []\n        while self._table[x] >= 0:\n            stack.append(x)\n            x = self._table[x]\n        for y in stack:\n            self._table[y] = x\n        return x\n\n    def unite(self, x, y):\n        x, y = self._root(x), self._root(y)\n        if x == y:\n            return\n        if x > y:\n            x, y = y, x\n        self._table[x] += self._table[y]\n        self._table[y] = x\n\n    def same(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def count_members(self, x):\n        return -self._table[self._root(x)]\n\n    def count_groups(self):\n        return len({self._root(i) for i in range(self._n)})\n\n    def __iter__(self):\n        return (self._root(i) for i in range(self._n))\n\n    def __str__(self):\n        return str([self._root(i) for i in range(self._n)])\n\n    def __repr__(self):\n        return repr([self._root(i) for i in range(self._n)])\n\n    def compress_coordinate(self):\n        d = {v: i for i, v in enumerate(sorted(set(self)))}\n        return [d[i] for i in self]\n\n    def get_forest(self):\n        F = [[] for _ in range(self.count_groups())]\n        d = self.compress_coordinate()\n        for i in range(self._n):\n            F[d[i]].append(i)\n        return F\n\n\nn, k = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nmod = 998244353\nfact = MintFactorial(mod).fact\n\nX = UnionFind(n)\nfor y0 in range(n-1):\n    for y1 in range(y0+1, n):\n        if all(A[y0][x] + A[y1][x] <= k for x in range(n)): \n            X.unite(y0, y1)\n\nY = UnionFind(n)\nfor x0 in range(n-1):\n    for x1 in range(x0+1, n):\n        if all(A[y][x0] + A[y][x1] <= k for y in range(n)): \n            Y.unite(x0, x1)\n\ns = 1\nfor a in map(fact, map(len, X.get_forest())):\n    s *= a\nfor b in map(fact, map(len, Y.get_forest())):\n    s *= b\nprint(s)", "mo = 998244353\nfact = [0] * 100\nfact[0] = 1\nfor i in range(1, 100):\n    fact[i] = fact[i - 1] * i % mo\nn, K = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nfa = [i for i in range(n)]\nfc = [1 for i in range(n)]\ndef getF(p, u):\n    if p[p[u]] == p[u]:\n        return p[u]\n    p[u] = getF(p, p[u])\n    return p[u]\ndef uniF(p, c, u, v):\n    u = getF(p, u)\n    v = getF(p, v)\n    if u == v:\n        return\n    p[u] = v\n    c[v] += c[u]\nfor i in range(n):\n    for j in range(n):\n        f = True\n        for k in range(n):\n            if a[i][k] + a[j][k] > K:\n                f = False\n                break\n        if f:\n            uniF(fa, fc, i, j)\nfb = [i for i in range(n)]\nfd = [1 for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        f = True\n        for k in range(n):\n            if a[k][i] + a[k][j] > K:\n                f = False\n                break\n        if f:\n            uniF(fb, fd, i, j)\nans = 1\nfor i in range(n):\n    if getF(fa, i) == i:\n        ans = ans * fact[fc[i]] % mo\n    if getF(fb, i) == i:\n        ans = ans * fact[fd[i]] % mo\nprint(ans)", "def main():\n    law = 998244353\n    n, k = list(map(int,input().split()))\n    mat = [list(map(int, input().split())) for i in range(n)]\n    t_mat = [[mat[j][i] for j in range(n)] for i in range(n)]\n    print(((line_pattern_counter_mod(mat, n, k, law) * line_pattern_counter_mod(t_mat, n, k, law)) % law))\n    return\n\ndef line_pattern_counter_mod(mat, n, k, law):\n    min_swapable = [i for i in range(n)]\n    swappable_count = [0 for _ in range(n)]\n    ret = 1\n    for x in range(n):\n        swappable_array = [x]\n        min_ind = min_swapable[x]\n        for y in range(n):\n            if swappable(mat[x], mat[y], n, k):\n                swappable_array.append(y)\n                min_ind = min(min_ind, min_swapable[y])\n        for ind in swappable_array:\n            min_swapable[ind] = min_ind\n    for m in range(n):\n        swappable_count[min_swapable[m]] += 1\n    for count in swappable_count:\n        ret = (ret * fact_mod(count, law)) % law\n    return ret\n\ndef swappable(l_1, l_2, n, k):\n    for j in range(n):\n        if l_1[j] + l_2[j] > k:\n            return False\n    return True\n\ndef fact_mod(m, law, acc = 1):\n    if m == 0:\n        return acc\n    return fact_mod(m - 1, law, (acc * m) % law)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n\ndef union(x, y, uf, rank):\n    px, py = find(x, uf), find(y, uf)\n    if px != py:\n        if rank[px] > rank[py]:\n            px, py = py, px\n        rank[py] += rank[px]\n        uf[px] = py\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      union(i, j, uf1, rank1)\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      union(i, j, uf2, rank2)\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "from math import factorial\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        x = self.find(x)\n        return -self.parents[x]\n\nn, k = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\nUF_h = UnionFind(n)\nUF_w = UnionFind(n)\n\nfor i in range(n-1):\n    for j in range(i, n):\n        flag = True\n        for l in range(n):\n            if A[i][l] + A[j][l] > k:\n                flag = False\n                break\n\n        if flag:\n            UF_h.union(i, j)\n\nfor i in range(n-1):\n    for j in range(i, n):\n        flag = True\n        for l in range(n):\n            if A[l][i] + A[l][j] > k:\n                flag = False\n                break\n\n        if flag:\n            UF_w.union(i, j)\n\nDh = {UF_h.find(i):UF_h.size(i) for i in range(n)}\nDw = {UF_w.find(i):UF_w.size(i) for i in range(n)}\n\nans = 1\nfor i in Dh:\n    ans *= factorial(Dh[i])\n    ans %= mod\nfor i in Dw:\n    ans *= factorial(Dw[i])\n    ans %= mod\n\nprint(ans)", "from itertools import combinations\nfrom functools import partial\n\n\nclass Mint:\n    def __init__(self, x, mod=10**9 + 7):\n        self.x = x.x if isinstance(x, Mint) else x % mod\n        self.mod = mod\n        self._mint = partial(Mint, mod=mod)\n\n    @staticmethod\n    def xgcd(a, b):\n        \"\"\" return (g, x, y) such that a*x + b*y = g = gcd(a, b) \"\"\"\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q*y1\n            x0, x1 = x1, x0 - q*x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        g, x, _ = self.xgcd(n, self.mod)\n        assert g == 1\n        return x % self.mod\n\n    def __str__(self):\n        return str(self.x)\n\n    def __repr__(self):\n        return repr(self.x)\n\n    def __eq__(self, x):\n        return self.x == self._mint(x).x\n\n    def __ne__(self, x):\n        return self.x != self._mint(x).x\n\n    def __int__(self):\n        return self.x\n\n    def __index__(self):\n        return self.x\n\n    def __add__(self, x):\n        return self._mint(self.x + self._mint(x).x)\n\n    def __radd__(self, x):\n        return self._mint(self.x + self._mint(x).x)\n\n    def __sub__(self, x):\n        return self._mint(self.x - self._mint(x).x)\n\n    def __rsub__(self, x):\n        return self._mint(self._mint(x).x - self.x)\n\n    def __mul__(self, x):\n        return self._mint(self.x * self._mint(x).x)\n\n    def __rmul__(self, x):\n        return self._mint(self.x * self._mint(x).x)\n\n    def __truediv__(self, x):\n        return self._mint(self.x * self.modinv(self._mint(x).x))\n\n    def __floordiv__(self, x):\n        return self._mint(self.x * self.modinv(self._mint(x).x))\n\n    def __pow__(self, x):\n        return self._mint(pow(self.x, x, self.mod))\n\n    def __rpow__(self, x):\n        return self._mint(pow(self._mint(x).x, self.x, self.mod))\n\n\nclass MintFactorial:\n    def __init__(self, mod=10**9 + 7):\n        self.mod = mod\n        self._factorial = [1]\n        self._size = 1\n        self._factorial_inv = [1]\n        self._size_inv = 1\n        self._mint = partial(Mint, mod=mod)\n\n    def __call__(self, n):\n        return self.fact(n)\n\n    def fact(self, n):\n        n = self._mint(n).x\n        \"\"\" n! (mod m) \"\"\"\n        if n >= self.mod:\n            return 0\n        self._make(n)\n        return self._mint(self._factorial[n])\n\n    def _make(self, n):\n        \"\"\" Calc from self._size to n!^-1 : O(n) \"\"\"\n        if n >= self.mod:\n            n = self.mod\n        if self._size < n+1:\n            for i in range(self._size, n+1):\n                self._factorial.append(self._factorial[i-1]*i % self.mod)\n            self._size = n+1\n\n    def fact_inv(self, n):\n        \"\"\" n!^-1 (mod m) \"\"\"\n        assert n >= self.mod\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        if self._factorial_inv[n] == -1:\n            self._factorial_inv[n] = self.modinv(self.fact(n))\n        return self._mint(self._factorial_inv[n])\n\n    def _make_inv(self, n, r=1):\n        \"\"\" Calc r!^1 ... n!^-1 : O(n-r) \"\"\"\n        if n >= self.m:\n            n = self.m - 1\n        if self._size_inv < n+1:\n            self._factorial_inv += [-1] * (n+1-self._size_inv)\n            self._size_inv = n+1\n        self._factorial_inv[n] = self.modinv(self.fact(n))\n        for i in range(n, r+1, -1):\n            self._factorial_inv[i-1] = self._factorial_inv[i]*i % self.mod\n\n    @staticmethod\n    def xgcd(a, b):\n        \"\"\" Return (gcd(a, b), x, y) such that a*x + b*y = gcd(a, b) \"\"\"\n        x0, x1, y0, y1 = 0, 1, 1, 0\n        while a != 0:\n            (q, a), b = divmod(b, a), a\n            y0, y1 = y1, y0 - q * y1\n            x0, x1 = x1, x0 - q * x1\n        return b, x0, y0\n\n    def modinv(self, n):\n        \"\"\" n^-1 (mod m) \"\"\"\n        g, x, _ = self.xgcd(n, self.mod)\n        assert g != 1\n        return self._mint(x)\n\n    def comb(self, n, r):\n        \"\"\" nCr (mod m) \"\"\"\n        if r > n:\n            return 0\n        t = self(n)*self.fact_inv(n-r) % self.mod\n        return self._mint(t*self.fact_inv(r))\n\n    def comb_(self, n, r):\n        \"\"\" nCr (mod m) : O(r) \"\"\"\n        c = 1\n        for i in range(1, r+1):\n            c *= (n-i+1) * self.fact_inv(i)\n            c %= self.mod\n        return self._mint(c)\n\n    def comb_with_repetition(self, n, r):\n        \"\"\" nHr (mod m) \"\"\"\n        t = self(n+r-1)*self.fact_inv(n-1) % self.mod\n        return self._mint(t*self.fact_inv(r))\n\n    def perm(self, n, r):\n        \"\"\" nPr (mod m) \"\"\"\n        if r > n:\n            return 0\n        return self._mint(self(n)*self.fact_inv(n-r))\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self._n = n\n        self._table = [-1]*n\n\n    def _root(self, x):\n        stack = []\n        while self._table[x] >= 0:\n            stack.append(x)\n            x = self._table[x]\n        for y in stack:\n            self._table[y] = x\n        return x\n\n    def unite(self, x, y):\n        x, y = self._root(x), self._root(y)\n        if x == y:\n            return\n        if x > y:\n            x, y = y, x\n        self._table[x] += self._table[y]\n        self._table[y] = x\n\n    def same(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def count_members(self, x):\n        return -self._table[self._root(x)]\n\n    def count_groups(self):\n        return len({self._root(i) for i in range(self._n)})\n\n    def __iter__(self):\n        return (self._root(i) for i in range(self._n))\n\n    def __str__(self):\n        return str([self._root(i) for i in range(self._n)])\n\n    def __repr__(self):\n        return repr([self._root(i) for i in range(self._n)])\n\n    def compress_coordinate(self):\n        d = {v: i for i, v in enumerate(sorted(set(self)))}\n        return [d[i] for i in self]\n\n    def get_forest(self):\n        F = [[] for _ in range(self.count_groups())]\n        d = self.compress_coordinate()\n        for i in range(self._n):\n            F[d[i]].append(i)\n        return F\n\n\nn, k = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nmod = 998244353\nfact = MintFactorial(mod).fact\n\nX = UnionFind(n)\nfor y0, y1 in combinations(range(n), 2):\n    if all(A[y0][x] + A[y1][x] <= k for x in range(n)): \n        X.unite(y0, y1)\n\nY = UnionFind(n)\nfor x0, x1 in combinations(range(n), 2):\n    if all(A[y][x0] + A[y][x1] <= k for y in range(n)): \n        Y.unite(x0, x1)\n\ns = 1\nfor a in map(fact, map(len, X.get_forest())):\n    s *= a\nfor b in map(fact, map(len, Y.get_forest())):\n    s *= b\nprint(s)", "MOD = 998244353\n\ndef dsFind(ds, x):\n    if ds[x] == x:\n        return x\n\n    x0 = x\n    while ds[x] != x:\n        x = ds[x]\n\n    ds[x0] = x\n    return x\n\n\ndef dsUnion(ds, x, y):\n    xRoot = dsFind(ds, x)\n    yRoot = dsFind(ds, y)\n    \n    if xRoot != yRoot:\n        ds[yRoot] = xRoot\n        return True\n\n    return False\n\n\ndef isSwappableCols(M, N, K, c1, c2):\n    for i in range(N):\n        if M[i][c1] + M[i][c2] > K:\n            return False\n    return True\n\n\ndef isSwappableRows(M, N, K, r1, r2):\n    for i in range(N):\n        if M[r1][i] + M[r2][i] > K:\n            return False\n    return True\n\n\n\ndef f(M, N, K, isSwappable):\n    ds = list(range(N))\n    for i in range(N):\n        for j in range(i+1, N):\n            if (dsFind(ds, i) != dsFind(ds, j) and\n                isSwappable(M, N, K, i, j)):\n                dsUnion(ds, i, j)\n    \n\n    cnts = {}\n    \n    for i in range(N):\n        root = dsFind(ds, i)\n        if not(root in cnts):\n            cnts[root] = 0\n\n        cnts[root] += 1\n\n    x = 1\n    for c in list(cnts.values()):\n        for i in range(2, c+1):\n            x = x*i%MOD\n                \n    return x\n\nN, K = list(map(int, input().split()))\nM  = [list(map(int, input().split())) for _ in range(N)]\n\nprint((f(M, N, K, isSwappableCols)*f(M, N, K, isSwappableRows)%MOD))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nMOD = 998244353\n\nA_T = []\nfor i in range(N):\n    x = []\n    for j in range(N):\n        x.append(A[j][i])\n    A_T.append(x)\n# print(A_T)\n# print(A)\nrow_uf = UnionFind(N)\ncolumn_uf = UnionFind(N)\nfor i in range(N - 1):\n    row1 = A[i]\n    for j in range(i + 1, N):\n        row2 = A[j]\n        if all([val1 + val2 <= K for val1, val2 in zip(row1, row2)]):\n            row_uf.union(i, j)\n# print(row_uf.all_group_members())\n\nfor i in range(N - 1):\n    column1 = A_T[i]\n    for j in range(i + 1, N):\n        column2 = A_T[j]\n        if all([val1 + val2 <= K for val1, val2 in zip(column1, column2)]):\n            column_uf.union(i, j)\n# print(column_uf.all_group_members())\nrow_cnt = 1\nfor root, member in row_uf.all_group_members().items():\n    for i in range(len(member), 0, -1):\n        row_cnt *= i\n        row_cnt %= MOD\n\ncolumn_cnt = 1\nfor root, member in column_uf.all_group_members().items():\n    for i in range(len(member), 0, -1):\n        column_cnt *= i\n        column_cnt %= MOD\nprint((row_cnt * column_cnt) % MOD)", "n,K = map(int,input().split())\nmod = 998244353\ncnt1 = 0\nA =[list(map(int,input().split())) for _ in range(n)]\n#\u4f7f\u3048\u308bUnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n \nuf1 = UnionFind(n)\nuf2 = UnionFind(n)\nfor i in range(n):\n    for j in range(i+1,n):\n        if all(A[i][k] + A[j][k] <=K for k in range(n)):\n            uf1.union(i,j)\ncnt2 = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if all(A[k][i] + A[k][j] <=K for k in range(n)):\n            uf2.union(i,j)\nans = 1\nfrom math import factorial\nfor u in uf1.roots():\n    ans*= factorial(uf1.size(u))%mod\nfor u in uf2.roots():\n    ans*= factorial(uf2.size(u))%mod\nprint(ans%mod)", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 9)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.d = [-1] * n\n\n    def find(self, x):\n        if self.d[x] < 0:\n            return x\n        else:\n            self.d[x] = self.find(self.d[x])\n            return self.d[x]\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return False\n        else:\n            if self.d[x] > self.d[y]:\n                x, y = y, x\n            self.d[x] += self.d[y]\n            self.d[y] = x\n            return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\n    def size(self, x):\n        return -self.d[self.find(x)]\n\n\n\nMOD = 998244353\ndef permutations(N):\n    val = 1\n    for i in range(2,N+1):\n        val *= i\n        val %= MOD\n    return val\n\nN,K = list(map(int,input().split()))\na = [list(map(int,input().split())) for _ in range(N)]\n\nufretu = UnionFind(N)\nfor i in range(N):\n    for j in range(i+1,N):\n        flg = True\n        for k in range(N):\n            if a[k][i] + a[k][j] > K:\n                flg = False\n        if flg == True:ufretu.unite(i,j)\nval1 = 1\nfor i in ufretu.d:\n    if i < 0:\n        val1 *= permutations(-i)\n        val1 %= MOD\n\nufgyou = UnionFind(N)\nfor i in range(N):\n    for j in range(i+1,N):\n        flg = True\n        for k in range(N):\n            if a[i][k] + a[j][k] > K:\n                flg = False\n        if flg == True:ufgyou.unite(i,j)\nval2 = 1\nfor i in ufgyou.d:\n    if i < 0:\n        val2 *= permutations(-i)\n        val2 %= MOD\nprint((val1 * val2 % MOD))\n\n", "from collections import defaultdict\nimport math\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n        \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n    \n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n    \n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\nn, k = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(n)]\n\nmod = 998244353\n\ndef c_swapable(a, x, y):\n    if all(a[i][x] + a[i][y] <= k for i in range(n)):\n        return True\n    else:\n        False\n\ndef r_swapable(a, s, t):\n    if all(a[s][j] + a[t][j] <= k for j in range(n)):\n        return True\n    else:\n        False\n\ncolum = UnionFind(n)\nrow = UnionFind(n)\n\nfor hx in range(n - 1):\n    for hy in range(hx + 1, n):\n        if c_swapable(a, hx, hy):\n            colum.union(hx, hy)\n\nfor wx in range(n - 1):\n    for wy in range(wx + 1, n):\n        if r_swapable(a, wx, wy):\n            row.union(wx, wy)\n \nans = 1\nfor cg in list(colum.all_group_members().values()):\n    ans *= math.factorial(len(cg))\nans %= mod\n\nfor rg in list(row.all_group_members().values()):\n    ans *= math.factorial(len(rg))\n        \nprint((ans % mod))\n", "import bisect,collections,copy,heapq,itertools,math,numpy as np,string,sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nN,K = LI()\na = np.array([LI() for _ in range(N)])\nans = 1\nuf1 = UnionFind(N)\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        uf1.union(i,j)\nfor x in uf1.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\na = a.T\nuf2 = UnionFind(N)\nfor i,j in itertools.combinations(list(range(N)),2):\n    if (a[i,:]+a[j,:]<=K).all():\n        uf2.union(i,j)\nfor x in uf2.parents:\n    if x<=-2:\n        for i in range(2,abs(x)+1):\n            ans *= i\n            ans %= 998244353\nprint(ans)\n", "class TwelvefoldWay:\n    def __init__(self, n, mod):\n        self.g1 = [1, 1]\n        self.g2 = [1, 1]\n        self.re = [0, 1]\n        self.md = mod\n        for i in range(2, n + 1):\n            self.g1.append((self.g1[-1] * i) % self.md)\n    def fact(self, n):\n        return self.g1[n]\n    def perm(self, n, k):\n        return (self.g1[n] * self.g2[n - k]) % self.md\n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        k = min(k, n - k)\n        return self.g1[n] * self.g2[k] * self.g2[n - k] % self.md\n    def homo(n, k):\n        return self.comb(n + k - 1, k)\n\n# 1-index\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n + 1)]\n        self.size = [1] * (n + 1)\n        self.nn = n\n    def find(self, x):\n        y = self.root[x]\n        if x == y:\n            return x\n        else:\n            z = self.find(y)\n            self.root[x] = z\n            return z\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        sx = self.size[rx]\n        sy = self.size[ry]\n        if rx == ry:\n            return 0\n        else:\n            if sx >= sy:\n                self.root[ry] = rx\n                self.size[rx] = sx + sy\n            else:\n                self.root[rx] = ry\n                self.size[ry] = sx + sy\n        return sx * sy\n    def size_list(self, n):\n        ret = []\n        cnt = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if cnt[self.find(i)] == 0:\n                cnt[self.find(i)] = 1\n                ret.append(self.size[self.find(i)])\n        return ret\n    def check(self):\n        print([self.find(i) for i in range(1, self.nn + 1)])\n\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nMOD = 998244353\n\ndef f(A):\n    edge = []\n    for i in range(N):\n        ai = A[i]\n        for j in range(i + 1, N):\n            aj = A[j]\n            flag = True\n            for k in range(N):\n                if ai[k] + aj[k] > K:\n                    flag = False\n                    break\n            if flag:\n                edge.append([i + 1, j + 1])\n\n    uf = UnionFind(N)\n    tw = TwelvefoldWay(N ** 2 + 1, MOD)\n    for a, b in edge:\n        uf.union(a, b)\n\n    ret = 1\n    for n in uf.size_list(N):\n        ret = (ret * tw.fact(n)) % MOD\n    \n    return ret\n\nanswer = f(A) % MOD\n\n# \u8ee2\u7f6e\nA = [[A[i][j] for i in range(N)] for j in range(N)]\nanswer = (answer * f(A)) % MOD\nprint(answer)", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\ninf = float('inf')\nmod = 10 ** 9 + 7\nmod2 = 998244353\n\nclass UnionFind:\n    \"\"\"\n    \u4e0b\u8a18\u304b\u3089\u62dd\u501f\n    https://note.nkmk.me/python-union-find/\n    \"\"\"\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(\n            '{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, K, A):\n    uf_row = UnionFind(N)\n    uf_col = UnionFind(N)\n    # grouping row\n    for x in range(N - 1):\n        for y in range(x + 1, N):\n            flg = True\n            for i in range(N):\n                if A[x][i] + A[y][i] > K:\n                    flg = False\n                    break\n            if flg:\n                uf_row.union(x, y)\n    # grouping col\n    for x in range(N - 1):\n        for y in range(x + 1, N):\n            flg = True\n            for i in range(N):\n                if A[i][x] + A[i][y] > K:\n                    flg = False\n                    break\n            if flg:\n                uf_col.union(x, y)\n    # calc ans\n    ans = 1\n    for gm in list(uf_row.all_group_members().values()):\n        for i in range(1, len(gm) + 1):\n            ans *= i\n            ans %= mod2\n    for gm in list(uf_col.all_group_members().values()):\n        for i in range(1, len(gm) + 1):\n            ans *= i\n            ans %= mod2\n    print(ans)\n\n\ndef __starting_point():\n    N, K = list(map(int, input().split()))\n    A = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, K, A)\n\n    # # test\n    # from random import randint\n    # import string\n    # import tool.testcase as tt\n    # from tool.testcase import random_str, random_ints\n    # N, K = 50, 2 * 50 ** 2\n    # A = [[N * i + j for j in range(1, N + 1)] for i in range(N)]\n    # solve(N, K, A)\n\n__starting_point()", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots_nums(self):\n    return [-x for x in self.parents if x < 0]\n\n  def num_roots(self):\n    return len([i for i, x in enumerate(self.parents) if x < 0])\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nMOD = 998244353\n\nclass ModInt:\n  def __init__(self, x):\n    self.x = x % MOD\n\n  def __str__(self):\n    return str(self.x)\n\n  __repr__ = __str__\n\n  def __add__(self, other):\n    return (\n      ModInt(self.x + other.x) if isinstance(other, ModInt) else\n      ModInt(self.x + other)\n    )\n\n  def __sub__(self, other):\n    return (\n      ModInt(self.x - other.x) if isinstance(other, ModInt) else\n      ModInt(self.x - other)\n    )\n\n  def __mul__(self, other):\n    return (\n      ModInt(self.x * other.x) if isinstance(other, ModInt) else\n      ModInt(self.x * other)\n    )\n\n  def __truediv__(self, other):\n    return (\n      ModInt(\n        self.x * pow(other.x, MOD - 2, MOD)\n      ) if isinstance(other, ModInt) else\n      ModInt(self.x * pow(other, MOD - 2, MOD))\n    )\n\n  __floordiv__ = __truediv__\n\n  def __pow__(self, other):\n    return (\n      ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else\n      ModInt(pow(self.x, other, MOD))\n    )\n\n  __radd__ = __add__\n\n  def __rsub__(self, other):\n    return (\n      ModInt(other.x - self.x) if isinstance(other, ModInt) else\n      ModInt(other - self.x)\n    )\n\n  __rmul__ = __mul__\n\n  def __rtruediv__(self, other):\n    return (\n      ModInt(\n        other.x * pow(self.x, MOD - 2, MOD)\n      ) if isinstance(other, ModInt) else\n      ModInt(other * pow(self.x, MOD - 2, MOD))\n    )\n\n  def __rpow__(self, other):\n    return (\n      ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else\n      ModInt(pow(other, self.x, MOD))\n    )\n\nans = 1\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nuf_row = UnionFind(N)\nuf_col = UnionFind(N)\nfor i in range(N):\n  for j in range(i+1,N):\n    for k in range(N):\n      if A[i][k]+A[j][k]>K:\n        break\n    else:\n      uf_row.union(i,j)\nfor i in range(N):\n  for j in range(i+1,N):\n    for k in range(N):\n      if A[k][i]+A[k][j]>K:\n        break\n    else:\n      uf_col.union(i,j)\n\nfact = [ModInt(1)]*51\n\nfor i in range(1,51):\n  fact[i] = fact[i-1]*i\nfor p in uf_row.roots_nums():\n  ans *= fact[p]\nfor p in uf_col.roots_nums():\n  ans *= fact[p]\nprint(ans)", "MOD = 998244353\n\nN, K = list(map(int, input().split()))\nAMat = [list(map(int, input().split())) for _ in range(N)]\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def find(self, x):\n        if self.parent[x]==x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\nuf_x = UnionFind(N)\nfor i in range(N-1):\n    for j in range(i+1, N):\n        flag = True\n        for y in range(N):\n            if AMat[y][i] + AMat[y][j] > K:\n                flag = False\n                break\n        if flag:\n            uf_x.unite(i, j)\n\nuf_y = UnionFind(N)\nfor i in range(N-1):\n    for j in range(i+1, N):\n        flag = True\n        for x in range(N):\n            if AMat[i][x] + AMat[j][x] > K:\n                flag = False\n                break\n        if flag:\n            uf_y.unite(i, j)\n\nans_list1 = [0] * N\nfor i in range(N):\n    ans_list1[uf_x.find(i)] += 1\n\nans_list2 = [0] * N\nfor i in range(N):\n    ans_list2[uf_y.find(i)] += 1\n\nans_list = ans_list1 + ans_list2\nans = 1\nfor a in ans_list:\n    if a >= 1:\n        for x in range(1, a+1):\n            ans *= x\n            ans %= MOD\n\nprint((ans%MOD))\n", "n, k = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nmod = 998244353\nans = 1\n\nparent = [i + 1 for i in range(n)]\nrank = [0 for i in range(n)]\nsize = [1 for i in range(n)]\n\ndef find(x):\n    if parent[x - 1] == x:\n        return x\n    else:\n        parent[x - 1] = find(parent[x - 1])\n        return parent[x - 1]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if rank[x - 1] < rank[y - 1]:\n        parent[x - 1] = y\n        size[y - 1] += size[x - 1]\n    else:\n        parent[y - 1] = x\n        size[x - 1] += size[y - 1]\n        if rank[x - 1] == rank[y - 1]:\n            rank[x - 1] += 1\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        flag = True\n        for l in range(n):\n            if a[l][i] + a[l][j] > k:\n                flag = False\n                break\n        if flag == True:\n            unite(i + 1, j + 1)\nfor i in range(n):\n    if find(i + 1) == i + 1:\n        for j in range(size[i]):\n            ans *= j + 1\n            ans %= mod\n\nparent = [i + 1 for i in range(n)]\nrank = [0 for i in range(n)]\nsize = [1 for i in range(n)]\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        flag = True\n        for l in range(n):\n            if a[i][l] + a[j][l] > k:\n                flag = False\n                break\n        if flag == True:\n            unite(i + 1, j + 1)\nfor i in range(n):\n    if find(i + 1) == i + 1:\n        for j in range(size[i]):\n            ans *= j + 1\n            ans %= mod\nprint(ans)", "mod = 998244353\nnn = 1010\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % mod\nfainv[-1] = pow(fa[-1], mod - 2, mod)\nfor i in range(nn)[::-1]:\n    fainv[i] = fainv[i+1] * (i+1) % mod\n\nN, K = map(int, input().split())\nX = [[int(a) for a in input().split()] for _ in range(N)]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.PA = [-1] * n\n    \n    def root(self, a):\n        L = []\n        while self.PA[a] >= 0:\n            L.append(a)\n            a = self.PA[a]\n        for l in L:\n            self.PA[l] = a\n        return a\n    def unite(self, a, b):\n        ra, rb = self.root(a), self.root(b)\n        if ra != rb:\n            if self.PA[rb] >= self.PA[ra]:\n                self.PA[ra] += self.PA[rb]\n                self.PA[rb] = ra\n            else:\n                self.PA[rb] += self.PA[ra]\n                self.PA[ra] = rb\n    def size(self, a):\n        return - self.PA[self.root(a)]\n    def groups(self):\n        G = [[] for _ in range(self.n)]\n        for i in range(self.n):\n            G[self.root(i)].append(i)\n        return [g for g in G if g]\n    def group_size(self):\n        G = [[] for _ in range(self.n)]\n        for i in range(self.n):\n            G[self.root(i)].append(i)\n        return [len(g) for g in G if g]\n\nans = 1\nuf1 = UnionFind(N)\ns = 0\nfor i in range(N):\n    for j in range(i):\n        for k in range(N):\n            if X[i][k] + X[j][k] > K:\n                break\n        else:\n            uf1.unite(i, j)\nfor a in uf1.group_size():\n    ans = ans * fa[a] % mod\n\nuf2 = UnionFind(N)\ns = 0\nfor i in range(N):\n    for j in range(i):\n        for k in range(N):\n            if X[k][i] + X[k][j] > K:\n                break\n        else:\n            uf2.unite(i, j)\nfor a in uf2.group_size():\n    ans = ans * fa[a] % mod\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,k = map(int,input().split())\na = []\nfor i in range(n):\n    ai = list(map(int,input().split()))\n    a.append(ai)\n\nu = UnionFind(n)\nmod = 998244353\n\nfor i in range(n-1):\n    for j in range(i+1,n):\n        ai = a[i]\n        aj = a[j]\n        bit = False\n        aij = [i+j for i,j in zip(ai,aj)]\n        if max(aij)<=k:\n            bit = True\n        if bit:\n            u.union(i,j)\nans = 1\nfor i in u.all_group_members():\n    li = len(u.members(i))\n    res = 1\n    for j in range(1,li+1):\n        res *= j\n        res %= mod\n    ans *= res\n\no = UnionFind(n)\nmod = 998244353\nb = list(map(list, zip(*a)))\n\nfor i in range(n-1):\n    for j in range(i+1,n):\n        bi = b[i]\n        bj = b[j]\n        bit = False\n        bij = [i+j for i,j in zip(bi,bj)]\n        if max(bij)<=k:\n            bit = True\n        if bit:\n            o.union(i,j)\n\nfor i in o.all_group_members():\n    li = len(o.members(i))\n    res = 1\n    for j in range(1,li+1):\n        res *= j\n        res %= mod\n    ans *= res\n\nprint(ans%mod)", "from collections import deque\n\ndef bfs(G, s, j):\n    q = deque()\n    q.append(s)\n    visit[s][j] = 1\n    p = 1\n    while q:\n        u = q.popleft()\n        for v in G[u]:\n            if not visit[v][j]:\n                visit[v][j] = 1\n                p += 1\n                q.append(v)\n    return p\n\nn, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nmod = 998244353\nG1 = [[] for _ in range(n)]\nG2 = [[] for _ in range(n)]\nfor i in range(n):\n    for j in range(i + 1, n):\n        f = 1\n        for l in range(n):\n            if a[i][l] + a[j][l] > k:\n                f = 0\n                break\n        if f:\n            G1[i].append(j)\n            G1[j].append(i)\nfor i in range(n):\n    for j in range(i + 1, n):\n        f = 1\n        for l in range(n):\n            if a[l][i] + a[l][j] > k:\n                f = 0\n                break\n        if f:\n            G2[i].append(j)\n            G2[j].append(i)\nans = 1\nvisit = [[0] * 2 for _ in range(n + 5)]\nfactorial = [1] * (n + 5)\nfor i in range(2, n + 5):\n    factorial[i] = factorial[i - 1] * i % mod\nfor i in range(n):\n    if not visit[i][0]:\n        p = bfs(G1, i, 0)\n        ans *= factorial[p]\n        ans %= mod\n    if not visit[i][1]:\n        p = bfs(G2, i, 1)\n        ans *= factorial[p]\n        ans %= mod\nprint(ans)", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n\ndef union(x, y, uf, rank):\n    px, py = find(x, uf), find(y, uf)\n    if px != py:\n        if rank[px] > rank[py]:\n            px, py = py, px\n        rank[py] += rank[px]\n        uf[px] = py\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      union(i, j, uf1, rank1)\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      union(i, j, uf2, rank2)\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, v):\n        if self.parents[v] < 0:\n            return v\n        else:\n            self.parents[v] = self.find(self.parents[v])\n            return self.parents[v]\n\n    def unite(self, u, v):\n        u = self.find(u)\n        v = self.find(v)\n\n        if u == v:\n            return\n\n        if self.parents[u] > self.parents[v]:\n            u, v = v, u\n\n        self.parents[u] += self.parents[v]\n        self.parents[v] = u\n\n    def size(self, v):\n        return -self.parents[self.find(v)]\n\n    def same(self, u, v):\n        return self.find(u) == self.find(v)\n\ndef comb_lists(n, mod):\n    fact = [1 for _ in range(n+1)]\n    inv = [1 for _ in range(n+1)]\n    fact_inv = [1 for _ in range(n+1)]\n    for i in range(2, n+1):\n        fact[i] = (fact[i-1]*i) % mod\n        inv[i] = mod - (inv[mod % i] * (mod // i)) % mod\n        fact_inv[i] = (fact_inv[i-1] * inv[i]) % mod\n    \n    return fact, fact_inv\n\nmod = 998244353\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\nuf_c = UnionFind(N)\nuf_r = UnionFind(N)\nfor i in range(N):\n    for j in range(i+1, N):\n        f = True\n        for k in range(N):\n            if A[i][k] + A[j][k] > K:\n                f = False\n                break\n        if f: uf_c.unite(i, j)\n\nfor i in range(N):\n    for j in range(i+1, N):\n        f = True\n        for k in range(N):\n            if A[k][i] + A[k][j] > K:\n                f = False\n                break\n        if f: uf_r.unite(i, j)\n\nfact, _ = comb_lists(N, mod)\nps = [] \nans = 1 \nfor i in range(N):\n    p = uf_c.find(i)\n    if p not in ps:\n        ans *= fact[uf_c.size(i)]\n        ans %= mod\n        ps.append(p)\n\nps = []\nfor i in range(N):\n    p = uf_r.find(i)\n    if p not in ps:\n        ans *= fact[uf_r.size(i)]\n        ans %= mod\n        ps.append(p)\nprint(ans)", "#UnionFind\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n    \nn,K = list(map(int,input().split()))\nmod = 998244353\na = [list(map(int,input().split())) for i in range(n)]\n\ndef factorial_mod(n,mod):\n    ret = 1\n    for i in range(1,n+1):\n        ret *= i\n        ret %= mod\n    return ret\n\nuf_ver = UnionFind(n+1)\nfor i in range(n):\n    for j in range(n):\n        is_ok = 1\n        for k in range(n):\n            if a[i][k] + a[j][k] <= K:\n                pass\n            else:\n                is_ok = 0\n                break\n        if is_ok:\n            uf_ver.union(i,j)\n        \nuf_hol = UnionFind(n+1)\nfor i in range(n):\n    for j in range(n):\n        is_ok = 1\n        for k in range(n):\n            if a[k][i] + a[k][j] <= K:\n                pass\n            else:\n                is_ok = 0\n                break\n        if is_ok:\n            uf_hol.union(i,j)\nans = 1\ndic1 = uf_ver.all_group_members()\nfor v in list(dic1.values()):\n    ans *= factorial_mod(len(v),mod)\n    ans %= mod\ndic2 = uf_hol.all_group_members()\nfor v in list(dic2.values()):\n    ans *= factorial_mod(len(v),mod)\n    ans %= mod\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1] * n\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def size(self, x):\n        return -self.par[self.find(x)]\n\nn,k=list(map(int,input().split()))\nA=[list(map(int, input().split())) for _ in range(n)]\n\nuf1=UnionFind(n)\nuf2=UnionFind(n)\n\nmod=998244353\n\nfct=[1]\nfor i in range(1,101):\n    fct.append(fct[-1]*i%mod)\n\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        if all(A[c][i] + A[c][j] <= k for c in range(n)):\n            uf1.unite(i, j)\n        if all(A[i][c] + A[j][c] <= k for c in range(n)):\n            uf2.unite(i, j)\nans = 1\nfor i in range(n):\n    if uf1.par[i] < 0:\n        ans *= fct[-uf1.par[i]]\n        ans %= mod\n    if uf2.par[i] < 0:\n        ans *= fct[-uf2.par[i]]\n        ans %= mod\nprint(ans)\n\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 998244353\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        \"\"\"x\u306e\u89aa\u3092\u8fd4\u3059\"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"y\u3092x\u306e\u6839\u306b\u7e4b\u3050\uff08\u30de\u30fc\u30b8\u30c6\u30af\u6709\uff09\"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        \"\"\"x\u3068y\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u5224\u5225\u3059\u308b\"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"x\u306e\u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\"\"\"\n        return -self.parents[self.find(x)]\n\n    def kruskal(self, edge):\n        \"\"\"\n        :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n        :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n        \"\"\"\n        edge.sort()\n        cost_sum = 0\n        for cost, node1, node2 in edge:\n            if not self.same(node1, node2):\n                cost_sum += cost\n                self.union(node1, node2)\n        return cost_sum\n\n\ndef resolve():\n    n, k = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(n)]\n\n    uf_row = UnionFind(n)\n    for x in range(n):\n        for y in range(x + 1, n):\n            for i in range(n):\n                if A[x][i] + A[y][i] > k:\n                    break\n            else:\n                uf_row.union(x, y)\n\n    uf_col = UnionFind(n)\n    for x in range(n):\n        for y in range(x + 1, n):\n            for i in range(n):\n                if A[i][x] + A[i][y] > k:\n                    break\n            else:\n                uf_col.union(x, y)\n\n    fact = [1, 1]\n    for i in range(2, n + 1):\n        fact.append(fact[-1] * i % mod)\n\n    size_row = [1] * n\n    for i in range(n):\n        root = uf_row.find(i)\n        size_row[root] = uf_row.size(root)\n\n    size_col = [1] * n\n    for i in range(n):\n        root = uf_col.find(i)\n        size_col[root] = uf_col.size(root)\n\n    tot_row = tot_col = 1\n    for i, j in zip(size_row, size_col):\n        tot_row = tot_row * fact[i] % mod\n        tot_col = tot_col * fact[j] % mod\n\n    res = tot_row * tot_col % mod\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n#unionfind\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = collections.defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\n\ndef main():\n\n    n, mx = list(map(int, input().split()))\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    uf1 = UnionFind(n)\n    uf2 = UnionFind(n)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                if a[i][k]+a[j][k] > mx:\n                    break\n            else:\n                uf1.union(i, j)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                if a[k][i]+a[k][j] > mx:\n                    break\n            else:\n                uf2.union(i, j)\n\n    ans = 1\n    mod = 998244353\n\n    def factorial(n):\n        rec = 1\n        for x in range(2, n+1):\n            rec *= x\n            rec %= mod\n        return rec\n\n    for lst in list(uf1.all_group_members().values()):\n        ans *= factorial(len(lst))\n        ans %= mod\n\n    for lst in list(uf2.all_group_members().values()):\n        ans *= factorial(len(lst))\n        ans %= mod\n    \n    print(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\n\n\nclass DisjoinSet:\n    def __init__(self, N):\n        self.par = [-1] * N\n        self.sz = [1] * N\n\n    def root(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n\n    def unite(self, a, b):\n        a = self.root(a)\n        b = self.root(b)\n        if a == b:\n            return\n        if self.sz[a] > self.sz[b]:\n            a, b = b, a\n        self.par[a] = b\n        self.sz[b] += self.sz[a]\n\n    def same(self, a, b):\n        return self.root(a) == self.root(b)\n\n    def size(self, x):\n        return self.sz[self.root(x)]\n\n    def groups(self):\n        clusters = defaultdict(list)\n        for x in range(N):\n            clusters[self.root(x)].append(x)\n        return list(clusters.values())\n\n\nN, K = list(map(int, input().split()))\nM = 998244353\nA = [[int(x) for x in input().split()] for _ in range(N)]\n\nfact = [1] * (N + 1)\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % M\n\nrow_dsu = DisjoinSet(N)\nfor r1 in range(N):\n    for r2 in range(r1, N):\n        if all(A[r1][c] + A[r2][c] <= K for c in range(N)):\n            row_dsu.unite(r1, r2)\n\ncol_dsu = DisjoinSet(N)\nfor c1 in range(N):\n    for c2 in range(c1, N):\n        if all(A[r][c1] + A[r][c2] <= K for r in range(N)):\n            col_dsu.unite(c1, c2)\n\ncntR = 1\nfor group in row_dsu.groups():\n    cntR = cntR * fact[len(group)] % M\ncntC = 1\nfor group in col_dsu.groups():\n    cntC = cntC * fact[len(group)] % M\nprint((cntR * cntC % M))\n", "from collections import Counter\nn, k = list(map(int, input().split()))\n\na = [tuple(map(int, input().split())) for _ in range(n)]\n\nf = [1, 1]\nmod = 998244353\nfor i in range(2, n+7):\n    f.append(f[-1]*i % mod)\n\n*p, = list(range(n))\nr = [0]*(n)\n\n\ndef par(x):\n    if p[x] == x:\n        return x\n    res = p[x] = par(p[x])\n    return res\n\n\ndef union(x, y):\n    px = par(x)\n    py = par(y)\n    if px == py:\n        return\n    if r[px] > r[py]:\n        p[py] = px\n        r[py] += 1\n    elif r[px] < r[py]:\n        p[px] = py\n        r[px] += 1\n    else:\n        p[px] = py\n        r[py] += 1\n\n\nfor i in range(n):\n    for j in range(i):\n        chng = True\n        for t in range(n):\n            if a[i][t]+a[j][t] > k:\n                chng = False\n                break\n        if chng:\n            union(i, j)\nfor i in range(n):par(i)\nans = 1\nCp = Counter(p)\nfor g in Cp:\n    ans *= f[Cp[g]]\n    ans %= mod\n*p, = list(range(n))\nr = [0]*(n)\nfor i in range(n):\n    for j in range(i):\n        chng = True\n        for t in range(n):\n            if a[t][i]+a[t][j] > k:\n                chng = False\n                break\n        if chng:\n            union(i, j)\nfor i in range(n):par(i)##\nCp = Counter(p)\nfor g in Cp:\n    ans *= f[Cp[g]]\n    ans %= mod\nprint(ans)\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.ans = n * (n - 1) // 2  ######\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        sx = self.size(x)  ######\n        sy = self.size(y)  ######\n        self.ans += sx * (sx - 1) // 2 + sy * (sy - 1) // 2  ######\n        self.ans -= (sx + sy) * (sx + sy - 1) // 2  ######\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n######\nmod = 998244353\npr = [1]\nfor i in range(1, 50):\n    pr.append(pr[-1]*i%mod)\n\nn, k = list(map(int, input().split()))\nm = [list(map(int, input().split())) for _ in range(n)]\nufs = [UnionFind(n) for _ in range(2)]\n\nfor x in range(n):\n    for y in range(n):\n        fg = True\n        for i in range(n):\n            if m[i][x] + m[i][y] > k:\n                fg = False\n                break\n        if fg:\n            ufs[0].union(x, y)\n        fg = True\n        for i in range(n):\n            if m[x][i] + m[y][i] > k:\n                fg = False\n                break\n        if fg:\n            ufs[1].union(x, y)\n\nret = 1\nfor uf in ufs:\n    for r in uf.roots():\n        ret *= pr[uf.size(r)]\n        ret %= mod\nprint(ret)\n", "import sys\n\nreadline = sys.stdin.readline\nINF = float('INF')\nsys.setrecursionlimit(10 ** 5)\n\n\nclass UnionFind:\n    \"\"\"\n    0-indexed\n    \"\"\"\n\n    from typing import List\n\n    def __init__(self, n):\n        self.n = n\n        self.parent = [-1] * n\n\n    def unite(self, x, y) -> int:\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return 0\n\n        if self.parent[x] > self.parent[y]:\n            x, y = y, x\n\n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n\n        return self.parent[x]\n\n    def is_same(self, x, y) -> bool:\n        return self.root(x) == self.root(y)\n\n    def root(self, x) -> int:\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def size(self, x) -> int:\n        return -self.parent[self.root(x)]\n\n    def all_sizes(self) -> List[int]:\n        sizes = []\n\n        for i in range(self.n):\n            size = self.parent[i]\n            if size < 0:\n                sizes.append(-size)\n        return sizes\n\n    def groups(self) -> List[List[int]]:\n        groups = dict()\n\n        for i in range(self.n):\n            p = self.root(i)\n            if not groups.get(p):\n                groups[p] = []\n            groups[p].append(i)\n\n        return list(groups.values())\n\n\ndef main():\n    def factorial(x):\n        res = 1\n        for i in range(1, x + 1):\n            res *= i\n            res %= MOD\n        return res\n\n    def judge1(first, second):\n        for i in range(N):\n            if grid[first][i] + grid[second][i] > K:\n                return False\n        return True\n\n    def judge2(first, second):\n        for i in range(N):\n            if grid[i][first] + grid[i][second] > K:\n                return False\n        return True\n\n    MOD = 998244353\n\n    N, K = list(map(int, readline().split()))\n    grid = []\n\n    for _ in range(N):\n        s = list(map(int, readline().split()))\n        grid.append(s)\n\n    cnt_r, cnt_c = 1, 1\n    uf = UnionFind(N + 1)\n\n    for i in range(N):\n        for j in range(i, N):\n            if judge1(i, j):\n                uf.unite(i, j)\n\n    for size in uf.all_sizes():\n        cnt_r *= factorial(size)\n        cnt_r %= MOD\n\n    uf = UnionFind(N + 1)\n\n    for i in range(N):\n        for j in range(i, N):\n            if judge2(i, j):\n                uf.unite(i, j)\n\n    for size in uf.all_sizes():\n        cnt_c *= factorial(size)\n        cnt_c %= MOD\n\n    print(((cnt_r * cnt_c) % MOD))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1]*n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x,y = y,x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\nmod = 998244353\nn,k = map(int,input().split())\na = np.array([list(map(int,input().split())) for _ in range(n)],dtype=np.int64)\nans = 1\nfor _ in range(2):\n    uf = UnionFind(n)\n    for i in range(n):\n        for j in range(i,n):\n            if i==j:continue\n            if max(a[i]+a[j])<=k:\n                uf.union(i,j)\n    c = uf.all_group_members()\n    for key,v in c.items():\n        tmp = 1\n        for i in range(len(v)):\n            tmp *= i+1\n            tmp %= mod \n        ans *= tmp\n        ans %= mod\n    a = a[::-1].T\nprint(ans)", "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**9)\nINF=10**18\nMOD=998244353\ninput=lambda: sys.stdin.readline().rstrip()\nYesNo=lambda b: bool([print('Yes')] if b else print('No'))\nYESNO=lambda b: bool([print('YES')] if b else print('NO'))\nint1=lambda x:int(x)-1\n\nN,K=map(int,input().split())\na=[list(map(int,input().split())) for _ in range(N)]\nclass UnionFind:\n    def __init__(self,n):\n        self.par=[i for i in range(n)]\n        self.siz=[1]*n\n        \n    def root(self,x):\n        while self.par[x]!=x:\n            self.par[x]=self.par[self.par[x]]\n            x=self.par[x]\n        return x\n    \n    def unite(self,x,y):\n        x=self.root(x)\n        y=self.root(y)\n        if x==y:\n            return False\n        if self.siz[x]<self.siz[y]:\n            x,y=y,x\n        self.siz[x]+=self.siz[y]\n        self.par[y]=x\n        return True\n    \n    def is_same(self,x,y):\n        return self.root(x)==self.root(y)\n    \n    def size(self,x):\n        return self.siz[self.root(x)]\n    \n    def get_roots(self):\n        roots=set()\n        for i in range(len(self.par)):\n            roots.add(self.root(i))\n        return list(roots)\n\n    def get_roots_and_size(self):\n        roots=self.get_roots()\n        roots_and_size=[[v,self.size(v)] for v in roots]\n        return roots_and_size\nuy=UnionFind(N)\nux=UnionFind(N)\nfor y0 in range(N):\n    for y1 in range(N):\n        for x in range(N):\n            if a[y0][x]+a[y1][x]>K:\n                break\n        else:\n            uy.unite(y0,y1)\nfor x0 in range(N):\n    for x1 in range(N):\n        for y in range(N):\n            if a[y][x0]+a[y][x1]>K:\n                break\n        else:\n            ux.unite(x0,x1)\nans=0\nry=uy.get_roots_and_size()\nrx=ux.get_roots_and_size()\ndef COMinit(n,MOD):\n    fac,finv,inv=[0]*max(2,n+1),[0]*max(2,n+1),[0]*max(2,n+1)\n    fac[0]=fac[1]=1\n    finv[0]=finv[1]=1\n    inv[1]=1\n    for i in range(2,(n+1)):\n        fac[i]=fac[i-1]*i%MOD\n        inv[i]=MOD-inv[MOD%i]*(MOD//i)%MOD\n        finv[i]=finv[i-1]*inv[i]%MOD\n    return fac,finv,inv\n\nfac,finv,inv=COMinit(N,MOD)\n\ndef COM(n, k, MOD=MOD):\n    if n<k or n<0 or k<0:\n        return 0\n    return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD\n\n\nans=1\nfor _,v in ry:\n    ans*=fac[v]\n    ans%=MOD\nfor _,v in rx:\n    ans*=fac[v]\n    ans%=MOD\nprint(ans)", "from collections import Counter\nn, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nMOD = 998244353\n\nlst1 = [[] for _ in range(n)]\nlst2 = [[] for _ in range(n)]\n\ng1 = [-1] * n\ng2 = [-1] * n\n\nfor i in range(n-1):\n    for j in range(i+1, n):\n        jdg1 = True\n        jdg2 = True\n        for l in range(n):\n            if a[i][l] + a[j][l] > k:\n                jdg1 = False\n            if a[l][i] + a[l][j] > k:\n                jdg2 = False\n            if (not jdg1) and (not jdg2):break\n        if jdg1:\n            lst1[i].append(j)\n            lst1[j].append(i)\n            g1[i] = 0\n            g1[j] = 0\n        if jdg2:\n            lst2[i].append(j)\n            lst2[j].append(i)\n            g2[i] = 0\n            g2[j] = 0\n\ndef calc(lst, g):\n    cnt = 1\n    for i in range(n):\n        if g[i] != 0: continue\n        temp = [i]\n        g[i] = cnt\n        while temp:\n            p = temp.pop()\n            for ip in lst[p]:\n                if g[ip] != 0:continue\n                g[ip] = cnt\n                temp.append(ip)\n        cnt += 1\n    return g\n  \ng1 = calc(lst1, g1)\ncnt1 = Counter(g1)\n\ng2 = calc(lst2, g2)\ncnt2 = Counter(g2)\n\nans = 1\n\nfor i, v in cnt1.items():\n    if i==-1: continue\n    for j in range(1, v+1):\n        ans *= (j % MOD)\n    ans %= MOD\n\nfor i, v in cnt2.items():\n    if i==-1: continue\n    for j in range(1, v+1):\n        ans *= (j % MOD)\n    ans %= MOD\n\nprint(ans)", "\nimport itertools,math\nfrom collections import defaultdict\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\nn,k = list(map(int,input().split()))\na = [list(map(int,input().split())) for i in range(n)]\na_row = []\na_column = []\nfor i in itertools.combinations(list(range(n)),2):\n    for j in range(n):\n        if a[i[0]][j] + a[i[1]][j] > k:\n            break\n        if j == n - 1:\n            a_row.append(i)\n    for j in range(n):\n        if a[j][i[0]] + a[j][i[1]] > k:\n            break\n        if j == n - 1:\n            a_column.append(i)\nuf_row = UnionFind(n)\nuf_column = UnionFind(n)\nfor i in a_row:\n    uf_row.union(i[0],i[1])\nfor i in a_column:\n    uf_column.union(i[0],i[1])\nans = 1\nfor i in list(uf_row.all_group_members().values()):\n    ans = ans * math.factorial(len(i)) % 998244353\nfor i in list(uf_column.all_group_members().values()):\n    ans = ans * math.factorial(len(i)) % 998244353\nprint(ans)\n", "n,k=map(int, input().split())\nmat=[]\nfor i in range(n):\n    mat.append(list(map(int, input().split())))\n\ndef fact(n):\n    tmp=1\n    for i in range(2,n+1):\n        tmp*=i\n        tmp%=998244353\n    \n    return tmp\n\ngoto=[[] for i in range(n)]\nfor gyou1 in range(n):\n    for gyou2 in range(gyou1+1,n):\n        OK=True\n        for retu in range(n):\n            if mat[gyou1][retu]+mat[gyou2][retu]>k:\n                OK=False\n        if OK:\n            goto[gyou1].append(gyou2)\n            goto[gyou2].append(gyou1)\n\nfrom collections import deque\nque=deque()\ngro=[-1]*n\n\nque.append(0)\ngro_no=0\ngro[0]=0\n\nfor i in range(n):\n    if gro[i]==-1:\n        que.append(i)\n        gro_no+=1\n        gro[i]=gro_no\n\n    while que:\n        now=que.popleft()\n        for j in goto[now]:\n            if gro[j]==-1:\n                que.append(j)\n                gro[j]=gro_no\n\ngro_cnt=[0]*(gro_no+1)\nfor i in range(n):\n    gro_cnt[gro[i]]+=1\n\n\n\nans_gyou=1\n\nfor i in range(gro_no+1):\n    ans_gyou*=fact(gro_cnt[i])\n\n\ngoto=[[] for i in range(n)]\nfor retu1 in range(n):\n    for retu2 in range(retu1+1,n):\n        OK=True\n        for gyou in range(n):\n            if mat[gyou][retu1]+mat[gyou][retu2]>k:\n                OK=False\n        if OK:\n            goto[retu1].append(retu2)\n            goto[retu2].append(retu1)\n\nfrom collections import deque\nque=deque()\ngro=[-1]*n\n\nque.append(0)\ngro_no=0\ngro[0]=0\n\nfor i in range(n):\n    if gro[i]==-1:\n        que.append(i)\n        gro_no+=1\n        gro[i]=gro_no\n\n    while que:\n        now=que.popleft()\n        for j in goto[now]:\n            if gro[j]==-1:\n                que.append(j)\n                gro[j]=gro_no\n\ngro_cnt=[0]*(gro_no+1)\nfor i in range(n):\n    gro_cnt[gro[i]]+=1\n\n\n\nans_retu=1\n\nfor i in range(gro_no+1):\n    ans_retu*=fact(gro_cnt[i])\n\nans=(ans_gyou*ans_retu)%998244353\n\nprint(ans)", "class UnionFindTree:\n    \"\"\"Union-Find Tree\n\n    Attributes:\n        n (int):    \u9802\u70b9\u6570\n        par (list): \u8981\u7d20\u306e\u683c\u7d0d\u5148\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\u521d\u671f\u5316 O(1)\n\n        Args:\n            n (int): \u9802\u70b9\u6570\n        \"\"\"\n        self.par = [-1] * n\n\n    def find(self, x):\n        \"\"\"\u8981\u7d20\u306e\u691c\u7d22 O(\u03b1(N))\n\n        Args:\n            x (int): \u5bfe\u8c61\u8981\u7d20\n\n        Returns:\n            int: x\u306e\u6839\n        \"\"\"\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n\n    def union(self, x, y):\n        \"\"\"\u8981\u7d20\u306e\u4f75\u5408 O(1)\n\n        Args:\n            x (int): \u4f75\u5408\u5bfe\u8c61\u306e\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\n            y (int): \u4f75\u5408\u5bfe\u8c61\u306e\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n\n        if self.par[x] > self.par[y]:\n            x, y = y, x\n\n        self.par[x] += self.par[y]\n        self.par[y] = x\n\n    def same(self, x, y):\n        \"\"\"\u8981\u7d20\u306e\u5224\u5b9a O(1)\n\n        Args:\n            x (int): \u5224\u5b9a\u5bfe\u8c61\u306e\u8981\u7d20\n            y (int): \u5224\u5b9a\u5bfe\u8c61\u306e\u8981\u7d20\n\n        Returns:\n            bool: x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5426\u304b\n        \"\"\"\n        return self.find(x) == self.find(y)\n    \n    def size(self, x):\n        \"\"\"\u8981\u7d20\u6570\u306e\u8a08\u7b97 O(1)\n\n        Args:\n            x (int): \u5bfe\u8c61\u8981\u7d20\n\n        Returns:\n            int: x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u6570\n        \"\"\"\n        return -self.par[self.find(x)]\n\n\nN, K = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(N)]\n\nmod = 998244353\n\nuf1 = UnionFindTree(N)\nuf2 = UnionFindTree(N)\n\nfor i in range(N):\n    for j in range(i+1, N):\n        flag = True\n        for k in range(N):\n            if a[i][k] + a[j][k] > K:\n                flag = False\n        if flag:\n            uf1.union(i, j)\n\nfor i in range(N):\n    for j in range(i+1, N):\n        flag = True\n        for k in range(N):\n            if a[k][i] + a[k][j] > K:\n                flag = False\n        if flag:\n            uf2.union(i, j)\n\nl = [1]\nfor i in range(1, N+1):\n    l.append(l[-1] * i % mod)\n\nres = 1\nfor i in range(N):\n    if i == uf1.find(i):\n        res = res * l[uf1.size(i)] % mod\n    if i == uf2.find(i):\n        res = res * l[uf2.size(i)] % mod\n\nprint(res)", "import sys\nreadline = sys.stdin.readline\n\nN,K = map(int,readline().split())\nDIV = 998244353\nA = [list(map(int,readline().split())) for i in range(N)]\n\n# K\u306e\u5236\u7d04\u304c\u306a\u3044\u5834\u5408\n# \u3069\u3093\u306a\u306b\u5165\u308c\u66ff\u3048\u3066\u3082\u3001\u540c\u3058\u884c\u30fb\u540c\u3058\u5217\u306b\u5b58\u5728\u3059\u308b\u6570\u306e\u7d44\u307f\u5408\u308f\u305b\u306f\u5909\u308f\u3089\u306a\u3044\n# \u3064\u307e\u308a\u5165\u308c\u66ff\u3048\u53ef\u80fd\u306a\u5217\u306e\u30da\u30a2\u306f\u9650\u3089\u308c\u3066\u3044\u308b\n# \u884c\u30fb\u5217\u306b\u5bfe\u3057\u3066\u3001\u5165\u308c\u66ff\u3048\u53ef\u80fd\u306a\u30da\u30a2\u306e\u901a\u308a\u6570\u3092\u7b97\u51fa\u3057\u3001\u305d\u308c\u3092\u639b\u3051\u5408\u308f\u305b\u305f\u3082\u306e\u304c\u7b54\u3048\n\n# \u884cA\u3068\u884cB\u304c\u5165\u308c\u66ff\u3048\u53ef\u80fd\u3067\u884cB\u3068\u884cC\u304c\u5165\u308c\u66ff\u3048\u53ef\u80fd\u306a\u5834\u5408\u3001\n# \u884cA\u3068\u884cC\u304c\u76f4\u63a5\u5165\u308c\u66ff\u3048\u53ef\u80fd\u3067\u306a\u304f\u3066\u3082\u64cd\u4f5c\u306b\u3088\u3063\u3066\u884cA,\u884cC\u306f\u5165\u308c\u66ff\u3048\u308b\u3053\u3068\u304c\u51fa\u6765\u308b\n# UnionFind\u3067\u5165\u308c\u66ff\u3048\u53ef\u80fd\u306a\u3082\u306e\u540c\u58eb\u3092\u30b0\u30eb\u30fc\u30d4\u30f3\u30b0\u3059\u308b\n\n# by size\n# 0-indexed\n\nclass UnionFind:\n  N=0\n  parent=None\n  size=None\n  def __init__(self,N):\n    self.N=N\n    self.parent=[i for i in range(self.N)]\n    self.size=[1]*self.N\n    \n  def root(self,x):\n    while x!=self.parent[x]:\n      self.parent[x]=self.parent[self.parent[x]]\n      x=self.parent[x]\n    return x\n  \n  def same(self,x,y):\n    return self.root(x)==self.root(y)\n  \n  def unite(self,x,y):\n    x=self.root(x)\n    y=self.root(y)\n    if x==y:\n      return\n    if self.size[x]>self.size[y]:\n      # \u5927\u304d\u3044\u65b9\u306b\u304f\u3063\u3064\u3051\u308b\n      self.parent[y]=x\n      self.size[x]+=self.size[y]\n    else:\n      self.parent[x]=y\n      self.size[y]+=self.size[x]\n      \n  def get_group_size(self,x):\n    return self.size[self.root(x)]\n  \n  def get_roots(self):\n    r=set()\n    for i in range(self.N):\n      r.add(self.root(i))\n    return r\n  \n  def show_parent(self):\n    print(self.parent)\n    \n  def show_size(self):\n    print(self.size)\n\nUF_row = UnionFind(N)\n\nfor i in range(N - 1):\n  for j in range(i + 1, N):\n    for k in range(N):\n      if A[i][k] + A[j][k] > K:\n        break\n    else:\n      #print(\"\u884c\",i,j,\"\u5165\u308c\u66ff\u3048\u53ef\u80fd\")\n      UF_row.unite(i, j)\n      \nrow_pat = 1\nrow_roots = UF_row.get_roots()\nfor root in row_roots:\n  siz = UF_row.get_group_size(root)\n  # siz\u306e\u968e\u4e57\u901a\u308a\u5206\u7d44\u307f\u5408\u308f\u305b\u304c\u5b58\u5728\u3059\u308b\n  #print(\"root\",root,\"siz\",siz)\n  pat = 1\n  for p in range(1, siz + 1):\n    pat *= p\n    pat %= DIV\n  row_pat *= pat\n  row_pat %= DIV\n  \n#print(\"row_pat\",row_pat)\n\nUF_col = UnionFind(N)\n\nfor i in range(N - 1):\n  for j in range(i + 1, N):\n    for k in range(N):\n      if A[k][i] + A[k][j] > K:\n        break\n    else:\n      #print(\"\u5217\",i,j,\"\u5165\u308c\u66ff\u3048\u53ef\u80fd\")\n      UF_col.unite(i, j)\n\ncol_pat = 1\ncol_roots = UF_col.get_roots()\nfor root in col_roots:\n  siz = UF_col.get_group_size(root)\n  #print(\"root\",root,\"siz\",siz)\n  pat = 1\n  for p in range(1, siz + 1):\n    pat *= p\n    pat %= DIV\n  col_pat *= pat\n  col_pat %= DIV\n  \n#print(\"col_pat\",col_pat)\n  \nprint((row_pat * col_pat) % DIV)", "MOD = 998244353\nfrom math import factorial\nN, K = list(map(int, input().split()))\nfield = [list(map(int, input().split())) for i in range(N)]\n\nclass Union_Find:\n    # \u89aa\u7ba1\u7406\u30ea\u30b9\u30c8\u3068\u9ad8\u3055\u7ba1\u7406\u30ea\u30b9\u30c8\u3092\u521d\u671f\u5316\u3057\u3001\n    # \u8981\u7d20N\u500b\u306eUnion-Find\u68ee\u3092\u4f5c\u6210\u3059\u308b\u3002\n    # \u89aa\u7ba1\u7406\u30ea\u30b9\u30c8\u306f\u3001\u57fa\u672c\u7684\u306b\u306f\u81ea\u5206\u306e\u3072\u3068\u3064\u4e0a\u306e\u89aa\u3092\u8868\u3059\u304c\u3001\n    # \u5024\u304c\u8ca0\u306e\u5834\u5408\u306b\u306f\u3001\u81ea\u8eab\u304c\u6700\u4e0a\u4f4d\u306e\u89aa(\u30ea\u30fc\u30c0\u30fc)\u3067\u3042\u308b\u3053\u3068\u3092\u8868\u3057\u3001\n    # \u81ea\u5206\u3092\u542b\u3081\u305f\u30b0\u30eb\u30fc\u30d7\u306e\u4eba\u6570\u3092\u7ba1\u7406\u3059\u308b\u3053\u3068\u3068\u3059\u308b\n    def __init__(self, N):\n        self.parent = [-1] * N\n        self.rank = [0] * N\n        self.group_count = N\n        self.N = N\n    \n    # x\u306e\u6240\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30ea\u30fc\u30c0\u30fc\u3092\u8fd4\u3059\n    def find(self, x):\n        # \u81ea\u5206\u81ea\u8eab\u304c\u30ea\u30fc\u30c0\u30fc\u306a\u3089\u3001\u81ea\u5206\u3092\u8fd4\u3059\n        if self.parent[x] < 0:\n            return x\n\n        # \u518d\u5e30\u7684\u306b\u635c\u7d22\u3057\u3001\u898b\u3064\u304b\u308c\u3070\u7e4b\u304e\u5909\u3048\u3066\u304a\u304f\n        # (\u8a08\u7b97\u91cf\u304c\u5897\u3048\u308b\uff1d\u9762\u5012\u304f\u3055\u3044\u306e\u3067)\u9ad8\u3055\u7ba1\u7406\u306f\u884c\u308f\u306a\u3044\n        par = self.find(self.parent[x])\n        self.parent[x] = par\n        return par\n\n    # x\u3068y\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u7d71\u5408\u3059\u308b\n    def unite(self, x, y):\n        # \u305d\u308c\u305e\u308c\u306e\u30ea\u30fc\u30c0\u30fc\u306b\u5bfe\u3059\u308b\u64cd\u4f5c\u3092\u884c\u3046\u3053\u3068\u306b\u306a\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        # \u30ea\u30fc\u30c0\u30fc\u304c\u540c\u3058\u306a\u3089\u4f55\u3082\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044\n        if x == y:\n            return\n\n        # \u6728\u306e\u9ad8\u3055\u304c\u540c\u3058\u5834\u5408\uff1a\n        # \u30b0\u30eb\u30fc\u30d7\u306e\u4eba\u6570\u3092\u5408\u8a08\u3057\u3064\u3064\u9069\u5f53\u306b\u7e4b\u304e\u3001\u7e4b\u3052\u3089\u308c\u305f\u65b9\u306e\u9ad8\u3055\u30921\u5897\u3084\u3059\n        if self.rank[x] == self.rank[y]:\n            self.parent[x] += self.parent[y]\n            self.parent[y] = x\n            self.rank[x] += 1\n        \n        # \u6728\u306e\u9ad8\u3055\u304c\u9055\u3046\u306a\u3089\u3001\u4f4e\u3044\u65b9\u3092\u9ad8\u3044\u65b9\u306b\u3064\u306a\u3050\n        elif self.rank[x] > self.rank[y]:\n            self.parent[x] += self.parent[y]\n            self.parent[y] = x\n        else:\n            self.parent[y] += self.parent[x]\n            self.parent[x] = y\n        \n        # \u7d71\u5408\u3055\u308c\u305f\u5834\u5408\u3001\u30b0\u30eb\u30fc\u30d7\u6570\u306f1\u6e1b\u308b\n        self.group_count -= 1\n    \n    # x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u3069\u3046\u304b\u3092\u8abf\u3079\u308b\n    def samep(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # x\u306e\u6240\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    def get_group_member_list(self, x):\n        x = self.find(x)\n        return [i for i in range(self.N) if self.find(i) == x]\n    \n    # x\u306e\u6240\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u6570\u3092\u8fd4\u3059\n    def get_group_member_count(self, x):\n        x = self.find(x)\n        return -self.parent[x]\n\n    # \u5168\u3066\u306e{\u30ea\u30fc\u30c0\u30fc:\u30b0\u30eb\u30fc\u30d7\u30e1\u30f3\u30d0\u30fc\u6570}\u3092\u8f9e\u66f8\u5f62\u5f0f\u3067\u8fd4\u3059\n    def get_all_groups(self):\n        return {idx:-n for idx, n in enumerate(self.parent) if n < 0}\n\nhg = Union_Find(N)\nfor i in range(N-1):\n    h1 = field[i]\n    for j in range(i,N):\n        h2 = field[j]\n        if all([True if x+y <= K else False for x, y in zip(h1, h2)]):\n            hg.unite(i, j)\n\nvg = Union_Find(N)\nrotated = list(zip(*field))\nfor i in range(N-1):\n    v1 = rotated[i]\n    for j in range(i, N):\n        v2 = rotated[j]\n        if all([True if x+y <= K else False for x, y in zip(v1, v2)]):\n            vg.unite(i, j)\n\nresult = 1\nfor value in list(hg.get_all_groups().values()):\n    result *= factorial(value)\n    result %= MOD\n\nfor value in list(vg.get_all_groups().values()):\n    result *= factorial(value)\n    result %= MOD\n\nprint(result)\n", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=998244353\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# Union-Find -- START --\nclass UnionFind():\n  def __init__(self,sz):\n    self.sz=sz\n    self.data=[-1]*sz\n    self.amount=[0]*sz\n\n  def unite(self,x,y):\n    x=self.find(x)\n    y=self.find(y)\n    if x==y:\n      return False\n    self.amount[x]+=self.amount[y]\n    self.amount[y]+=self.amount[x]\n    if self.data[x]>self.data[y]:\n      x,y=y,x\n    self.data[x]+=self.data[y]\n    self.data[y]=x\n    return True\n\n  def find(self,k):\n    if self.data[k]<0:\n      return k\n    self.data[k]=self.find(self.data[k])\n    return self.data[k]\n\n  def size(self,k):\n    return -self.data[self.find(k)]\n\n  def set_amount(self,k,k_amount):\n    self.amount[k]=k_amount\n\n  def get_amount(self,k):\n    return self.amount[k]\n# Union-Find --- END ---\n\ndef main():\n  n,K=LI()\n  field=[LI() for _ in range(n)]\n  uf1=UnionFind(n)\n  uf2=UnionFind(n)\n\n  for i in range(n):\n    l1=[True]*n\n    for j in range(i+1,n):\n      if not l1[i]:\n        continue\n      for k in range(n):\n        # print(field[i][k],field[j][k])\n        if field[i][k]+field[j][k]>K:\n          l1[j]=False\n          break\n    # print(l1[j])\n    for j in range(i+1,n):\n      if l1[j]:\n        uf1.unite(i,j)\n\n    # for i in range(n):\n    #   print(uf1.find(i))\n\n  for i in range(n):\n    l2=[True]*n\n    for j in range(i+1,n):\n      if not l2[i]:\n        continue\n      for k in range(n):\n        if field[k][i]+field[k][j]>K:\n          l2[j]=False\n          break\n    for j in range(i+1,n):\n      if l2[j]:\n        uf2.unite(i,j)\n\n  # for i in range(n):\n  #   print(uf2.find(i))\n\n  ans1=1\n  check1=[True]*n\n  for i in range(n):\n    sz=uf1.size(i)\n    pa=uf1.find(i)\n    if check1[pa]:\n      check1[pa]=False\n      _ans=1\n      for j in range(2,sz+1):\n        _ans*=j\n        _ans%=mod\n      ans1*=_ans\n      ans1%=mod\n\n  # print(ans1)\n\n  ans2=1\n  check2=[True]*n\n  for i in range(n):\n    sz=uf2.size(i)\n    pa=uf2.find(i)\n    if check2[pa]:\n      check2[pa]=False\n      _ans=1\n      for j in range(2,sz+1):\n        _ans*=j\n        _ans%=mod\n      ans2*=_ans\n      ans2%=mod\n\n  return (ans1*ans2)%mod\n\n# main()\nprint((main()))\n", "import sys\ntry:\n    import os\n    f = open('input.txt', 'r')\n    sys.stdin = f\nexcept FileNotFoundError:\n    None\nfrom math import sqrt, ceil, floor\nfrom collections import deque, Counter, defaultdict\n# defaultdict(int)\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright, insort\nfrom itertools import combinations as com, permutations as per\nfrom fractions import Fraction as frac  #frac(a,b)\u3067\u6b63\u78ba\u306aa/b\n# @lru_cache(maxsize=10**10)\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\n\nn,k=list(map(int,input().split()))\nA=[list(map(int,input().split())) for i in range(n)]\ncntx=0; cnty=0\n\nkai=[1]*70\nmod=998244353\nfor i in range(1,65):\n    kai[i]=(kai[i-1]*i)%mod\n# print(kai)\n\nclass UnionFind():\n    def __init__(self,num):\n        self.n = num\n        self.parents = [-1 for i in range(self.n)]\n\n\n\n    def find(self,x):\n        if self.parents[x]<0:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n\n            return self.parents[x]\n\n\n    def union(self,x,y):\n        xx=self.find(x)\n        yy=self.find(y)\n        if xx==yy:\n            return\n        else:\n            size_xx=abs(self.parents[xx])\n            size_yy=abs(self.parents[yy])\n            if size_xx>size_yy:\n                xx,yy=yy,xx\n\n            self.parents[yy]+=self.parents[xx]\n            self.parents[xx]=yy\n\n\n    def size(self,x):\n        xx=self.find(x)\n        return abs(self.parents[xx])\n\n\n    def same(self,x,y):\n        return 1 if self.find(x)==self.find(y) else 0\n\n\n    def members(self,x):\n        xx=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==xx]\n\n\n\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n\n\n\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\n    def state_grouping(self):\n        return list(self.all_group_members().values())\n\n# uf=UnionFind(n)\nufx=UnionFind(n)\nufy=UnionFind(n)\n\nfor i in range(n):\n    po=0\n    for j in range(i):\n        for p in range(n):\n            if A[i][p]+A[j][p]>k:\n                po=1;break\n        else:\n            ufx.union(i,j)\n\nfor i in range(n):\n    for j in range(n):\n        for p in range(n):\n            if A[p][i]+A[p][j]>k:break\n        else:\n            ufy.union(i,j)\n\nxx=1; yy=1\nfor i in ufx.parents:\n    if i<-1:\n        xx*=kai[abs(i)]\n        xx%=mod\nfor j in ufy.parents:\n    if j<-1:\n        yy*=kai[abs(j)]\n        yy%=mod\n\nprint((xx*yy%mod))\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nmod=998244353\nn,wa=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nufg=UnionFind(n)\nufl=UnionFind(n)\nfor i in range(n-1):\n  for j in range(i+1,n):\n    fl=1\n    fg=1\n    for k in range(n):\n      if a[i][k]+a[j][k]>wa:\n        fg=0\n        break\n    for k in range(n):\n      if a[k][i]+a[k][j]>wa:\n        fl=0\n        break\n    if fg:\n      ufg.union(i,j)\n    if fl:\n      ufl.union(i,j)\nfrom math import factorial as fa\nsg=1\nsl=1\nfor i in ufg.roots():\n  sg*=fa(ufg.size(i))\n  sg%=mod\nfor i in ufl.roots():\n  sl*=fa(ufl.size(i))\n  sl%=mod\nprint((sl*sg)%mod)", "#Union Find Tree\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n      \nN,K=map(int,input().split())\nA=[]\nfor i in range(N):\n  a=list(map(int, input().split()))\n  A.append(a)\n\nUF1=UnionFind(N)\nUF2=UnionFind(N)\n\nfor i in range(N):\n  for j in range(i+1,N):\n    l=0\n    for k in range(N):\n      if A[i][k]+A[j][k]>K:\n        l=1\n    if l==0:\n      UF1.union(i,j)\n\nfor i in range(N):\n  for j in range(i+1,N):\n    l=0\n    for k in range(N):\n      if A[k][i]+A[k][j]>K:\n        l=1\n    if l==0:\n      UF2.union(i,j)\n    \ndef fac(x):\n  ans=1\n  for i in range(1,x+1):\n    ans*=i\n    ans%=998244353\n  return ans\n    \nans=1\nfor i in UF1.parents:\n  if i < 0:\n    ans*=fac(-i)\n    ans%=998244353\n    \nfor i in UF2.parents:\n  if i < 0:\n    ans*=fac(-i)\n    ans%=998244353\n    \nprint(ans)", "mod = 998244353\nfact=[1]\nfor i in range(1,51):\n    x = (i*fact[-1])%mod\n    fact.append(x)\nn,k = list(map(int,input().split()))\ndef dfs(node):\n    if vis[node]:\n        return 0\n    vis[node]=1\n    ans=1\n    for i in m[node]:\n        ans+=dfs(i)\n    return ans\n\nl=[]\nfor i in range(n):\n    l.append(list(map(int,input().split())))\nm=[]\nfor i in range(n):\n    m.append([])\nfor i in range(n):\n    for j in range(i+1,n):\n        e=1\n        for b in range(n):\n            if l[i][b]+l[j][b]>k:\n                e=0\n                break\n        if e:\n            m[i].append(j)\n            m[j].append(i)\n\na=1\nb=1\nvis=[0]*n\nfor i in range(n):\n    x = dfs(i)\n    a = (a*fact[x])%mod\n\n            \nm=[]\nfor i in range(n):\n    m.append([])\nfor i in range(n):\n    for j in range(i+1,n):\n        e=1\n        for v in range(n):\n            if l[v][i]+l[v][j]>k:\n                e=0\n                break\n        if e:\n            m[i].append(j)\n            m[j].append(i)\nvis=[0]*n\nfor i in range(n):\n    x = dfs(i)\n    b = (b*fact[x])%mod\nans = (a*b)%mod\nprint(ans)\n        \n        \n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nimport re\nfrom collections import Counter,deque,defaultdict\ndef iinput(): return int(input())\ndef imap(): return map(int, input().split())\ndef ilist(): return list(imap())\ndef irow(N): return [iinput() for i in range(N)]\ndef sinput(): return input().rstrip()\ndef smap(): return sinput().split()\ndef slist(): return list(smap())\ndef srow(N): return [sinput() for i in range(N)]\n\ndef main():\n    MOD = 998244353\n    class UnionFind:\n        def __init__(self, n):\n            self.par = [i for i in range(n+1)]\n            self.rank = [0] * (n+1)\n            self.size = [1] * (n+1) # \u89aa\u306b\u96c6\u7d04\u3055\u308c\u308b\n    \n        # \u691c\u7d22\n        def find(self, x):\n            if self.par[x] == x:\n                return x\n            else:\n                self.par[x] = self.find(self.par[x])\n                return self.par[x]\n    \n        # \u4f75\u5408\n        def union(self, x, y):\n            x = self.find(x)\n            y = self.find(y)\n    \n            if x == y:\n                return\n    \n            if self.rank[x] < self.rank[y]:\n                self.par[x] = y\n                self.size[y] += self.size[x]\n                self.size[x] = 0\n            else:\n                self.par[y] = x\n                self.size[x] += self.size[y]\n                self.size[y] = 0\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n    \n        # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n        def same(self, x, y):\n            return self.find(x) == self.find(y)\n    \n        # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n        def all_find(self):\n            for n in range(len(self.par)):\n                self.find(n)\n    N,K = imap()\n    import numpy as np\n    A = np.array([ilist() for i in range(N)])\n    uf_i = UnionFind(N)\n    uf_r = UnionFind(N)\n\n    for i in range(N-1):\n        for j in range(i+1,N):\n            if np.all(A[i] + A[j] <= K):\n                uf_i.union(i+1,j+1)\n            if np.all(A[:,i] + A[:,j] <= K):\n                uf_r.union(i+1, j+1)\n    uf_i.all_find()\n    uf_r.all_find()\n    \n    ans = 1\n    for i in uf_i.size:\n        if i in [0,1]:\n            continue\n        ans *= math.factorial(i)\n    for j in uf_r.size:\n        if j in [0,1]:\n            continue\n        ans *= math.factorial(j)\n    print(ans%MOD)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "mod = 998244353\nN, K = list(map(int, input().split()))\nA = []\nfor i in range(N):\n    a = [int(i) for i in input().split()]\n    A.append(a)\n\nmemo = [1]\nfor i in range(1, 52):\n    num = memo[-1]\n    memo.append(num*i%mod)\n\nclass UnionFind:\n    def __init__(self, n):\n        # \u8ca0  : \u6839\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u7d76\u5bfe\u5024\u306f\u30e9\u30f3\u30af\u3092\u793a\u3059\n        # \u975e\u8ca0: \u6839\u3067\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\u5024\u306f\u89aa\u3092\u793a\u3059\n        self.table = [-1] * n\n \n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def count(self, x):\n        return -self.table[self._root(x)]\n \n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        # \u30e9\u30f3\u30af\u306e\u53d6\u5f97\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\nuni1 = UnionFind(N)\nuni2 = UnionFind(N)\n\nfor i in range(N-1):\n    for j in range(i+1, N):\n        cur1 = 0\n        cur2 = 0\n        for k in range(N):\n            if A[i][k] + A[j][k] <= K:\n                cur1 += 1\n            if A[k][i] + A[k][j] <= K:\n                cur2 += 1\n        if cur1 == N:\n            uni1.union(i, j)\n        if cur2 == N:\n            uni2.union(i, j)\n\nlsnum = []\nset1, set2 = set(), set()\nfor i in range(N):\n    if uni1._root(i) not in set1:\n        lsnum.append(uni1.count(i))\n        set1.add(uni1._root(i))\n    if uni2._root(i) not in set2:\n        lsnum.append(uni2.count(i))\n        set2.add(uni2._root(i))\n\nans = 1\nfor num in lsnum:\n    ans = ans * memo[num] %mod\nans %= mod\nprint(ans)\n", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n\ndef union(x, y, uf, rank):\n  px, py = find(x, uf), find(y, uf)\n  if px != py:\n    if rank[px] > rank[py]:\n      px, py = py, px\n    rank[py] += rank[px]\n    uf[px] = py\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      union(i, j, uf1, rank1)\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      union(i, j, uf2, rank2)\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "import math\nN, K = list(map(int, input().split()))\nA = []\nmod = 998244353\nfor _ in range(N):\n  A.append(list(map(int, input().split())))\n\ndef find(x, uf):\n  if uf[x] != x:\n    uf[x] = find(uf[x], uf)\n  return uf[x]\n\ndef union(x, y, uf, rank):\n    px, py = find(x, uf), find(y, uf)\n    if px != py:\n        if rank[px] > rank[py]:\n            px, py = py, px\n        rank[py] += rank[px]\n        uf[px] = py\n  \nuf1 = {i: i for i in range(N)}\nuf2 = {i: i for i in range(N)}\nrank1 = {i: 1 for i in range(N)}\nrank2 = {i: 1 for i in range(N)}\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(A[i], A[j])):\n      px, py = find(i, uf1), find(j, uf1)\n      if px != py:\n        if rank1[px] > rank1[py]:\n          px, py = py, px\n        rank1[py] += rank1[px]\n        uf1[px] = py\nB = list(zip(*A))\nfor i in range(N):\n  for j in range(i + 1, N):\n    if all(a + b <= K for a, b in zip(B[i], B[j])):\n      px, py = find(i, uf2), find(j, uf2)\n      if px != py:\n        if rank2[px] > rank2[py]:\n          px, py = py, px\n        rank2[py] += rank2[px]\n        uf2[px] = py\nans = 1\nfor x in set(find(i, uf1) for i in range(N)):\n  ans *= math.factorial(rank1[x])\n  ans %= mod\nfor x in set(find(i, uf2) for i in range(N)):\n  ans *= math.factorial(rank2[x])\n  ans %= mod\nprint(ans)\n", "import collections as co\ndef searchRoot(n):\n    par = parList[n]\n    if n == par:\n        if len(q) > 0:\n            rootIn(q,n)\n        return n\n    else:\n        q.append(n)\n        return(searchRoot(par))\n\ndef rootIn(q,root):\n    while len(q) > 0:\n        parList[q.popleft()] = root\n\ndef UnionFind(n,m,lis):\n    for i in range(m):\n        a,b = lis[i]\n        aRoot = searchRoot(a)\n        bRoot = searchRoot(b)\n        if aRoot != bRoot:\n            parList[max(aRoot,bRoot)] = min(aRoot,bRoot)\n\n    ansDic = dict()\n    rootSet = set()\n    for i in range(0,n):\n        root = searchRoot(i)\n        if root in rootSet:\n            ansDic[root] += 1\n        else:\n            rootSet.add(root)\n            ansDic[root] = 1\n\n    return ansDic\n\n\nn,k = list(map(int,input().split()))\n\na = []\nfor i in range(n):\n    aRow = list(map(int,input().split()))\n    a.append(aRow)\n\nrowLis = []\nfor i in range(n-1):\n    for j in range(i+1,n):\n        check = True\n        for l in range(n):\n            if a[i][l] + a[j][l] > k:\n                check = False\n                break\n        if check:\n            rowLis.append([i,j])\n#print(rowLis)\nparList = [i for i in range(n+1)]\nq = co.deque()\nrowDic = UnionFind(n,len(rowLis),rowLis)\n\n\ncolLis = []\nfor i in range(n-1):\n    for j in range(i+1,n):\n        check = True\n        for l in range(n):\n            if a[l][i] + a[l][j] > k:\n                check = False\n                break\n        if check:\n            colLis.append([i,j])\n#print(colLis)\nparList = [i for i in range(n+1)]\nq = co.deque()\ncolDic = UnionFind(n,len(colLis),colLis)\n\nans = 1\n#print(rowDic)\n#print(colDic)\nfor i in rowDic.values():\n    for j in range(1,i+1):\n        ans = ans * j\nfor i in colDic.values():\n    for j in range(1,i+1):\n        ans = ans * j\n\nans = ans % 998244353\nprint(ans)", "def MI():\n    return map(int, input().split())\n\nn,k= MI()\nmod=998244353\nframod=[1]\ndef framod_calc(n, mod, a=1):\n    for i in range(1,n+1):\n        a=a * i % mod\n        framod.append(a)\nframod_calc(n+1, mod)\ndef permmod(n, k, mod):\n    if n<k: return 0\n    a=framod[n]\n    c=framod[n-k]\n    return (a * pow(c, mod-2, mod)) % mod\n\nmat=[]\nmatinv=[[0]*n for _ in range(n)]\nfor i in range(n):\n    mat.append(list(MI()))\n\nfor i in range(n):\n    for j in range(n):\n        matinv[i][j]=mat[j][i]\n\nesrow=[]\nescol=[]\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if mat[i][p]+mat[j][p]>k:\n                flg=False\n                break\n        if flg:\n            esrow.append((i,j))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        flg=True\n        for p in range(n):\n            if matinv[i][p]+matinv[j][p]>k:\n                flg=False\n                break\n        if flg:\n            escol.append((i,j))\n\nclass UnionFind(object): # size\u3092O(1)\u3067\u5f15\u3051\u308bversion\n    def __init__(self, n=1):\n        self.n=n\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.sizebox = [1]*n\n    def find(self, x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50\u6210\u5206\u306e\u4ee3\u8868\u5143\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y): # x,y\u3092\u9023\u7d50\u3001\u3064\u3044\u3067\u306b\u30b5\u30a4\u30ba\u3082\u9023\u7d50\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.sizebox[x]+=self.sizebox[y]\n            self.sizebox[y]=0\n    def same(self, x, y): # x,y\u304c\u9023\u7d50\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n    def size(self,x): # x\u306e\u5c5e\u3059\u308b\u9023\u7d50size\u3092O(1)\u3067\u51fa\u3059\n        x = self.find(x)\n        return self.sizebox[x]\n    def allfind(self): # find\u30921\u5468\u3059\u308b\n        for i in range(self.n):\n            self.find(i)\n\nufr=UnionFind(n)\nufc=UnionFind(n)\n\nfor i,j in esrow:\n    ufr.union(i,j)\n\nfor i,j in escol:\n    ufc.union(i,j)\n\nfor i in range(n):\n    ufr.find(i)\n    ufc.find(i)\n\nfrom collections import Counter\ncpar=Counter(ufc.par)\nrpar=Counter(ufr.par)\n\nans=1\n\nfor k in cpar.keys():\n    x=cpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nfor k in rpar.keys():\n    x=rpar[k]\n    ans*=permmod(x,x,mod)\n    ans%=mod\n\nprint(ans%mod)", "MOD = 998244353\nSIZE = 10 ** 6\n\ng1 = [1, 1]\ng2 = [1, 1]\nre = [0, 1]\nfor i in range(2, SIZE + 1):\n    g1.append((g1[-1] * i) % MOD)\ndef fact(n):\n    return g1[n]\n\n\n# i-index\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n + 1)]\n        self.size = [1] * (n + 1)\n        self.nn = n\n    def find(self, x):\n        y = self.root[x]\n        if x == y:\n            return x\n        else:\n            z = self.find(y)\n            self.root[x] = z\n            return z\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        sx = self.size[rx]\n        sy = self.size[ry]\n        if rx == ry:\n            return 0\n        else:\n            if sx >= sy:\n                self.root[ry] = rx\n                self.size[rx] = sx + sy\n            else:\n                self.root[rx] = ry\n                self.size[ry] = sx + sy\n        return sx * sy\n    def size_list(self, n):\n        ret = []\n        cnt = [0] * (n + 1)\n        for i in range(1, n + 1):\n            #print(i, self.find(i))\n            if cnt[self.find(i)] == 0:\n                cnt[self.find(i)] = 1\n                ret.append(self.size[self.find(i)])\n        return ret\n    def check(self):\n        print([self.find(i) for i in range(1, self.nn + 1)])\n\nN, K = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(N)]\n#print(A)\n\n\ndef f(A):\n    edge = []\n    for i in range(N):\n        ai = A[i]\n        for j in range(i + 1, N):\n            aj = A[j]\n            flag = True\n            for k in range(N):\n                if ai[k] + aj[k] > K:\n                    flag = False\n                    break\n            if flag:\n                edge.append([i + 1, j + 1])\n    #print(edge)\n    \n    for a, b in edge:\n        uf.union(a, b)\n    #print(\"check\")\n    #uf.check()\n    \n    ret = 1\n    sl = uf.size_list(N)\n    #print(sl)\n    for n in sl:\n        ret = (ret * fact(n)) % MOD\n    \n    return ret\n\nuf = UnionFind(N)\nanswer = f(A) % MOD\n\n# \u8ee2\u7f6e\ntmp = [[] for _ in range(N)]\nfor i in range(N):\n    for j in range(N):\n        tmp[j].append(A[i][j])\nA = tmp\n#print(A)\n\nuf = UnionFind(N)\nanswer = (answer * f(A)) % MOD\nprint(answer)"]
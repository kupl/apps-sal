["from collections import defaultdict\n\n\ndef dfs(s, t):\n    visited = 0\n    q = [(s, 0)]\n    while q:\n        v, used = q.pop()\n        if v == t:\n            return used\n        visited |= used\n        for lb, u in graph[v]:\n            if lb & visited:\n                continue\n            q.append((u, used | lb))\n\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    lb = 1 << i\n    graph[a].append((lb, b))\n    graph[b].append((lb, a))\n\nconditions = []\nm = int(input())\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    conditions.append(dfs(u, v))\n\nlink_conditions = [int(''.join(b), 2) for b in zip(*list(map(('{:0' + str(n - 1) + 'b}').format, conditions)))]\n\ndp = defaultdict(int)\ndp[0] = 1\nfor lc in link_conditions:\n    for fulfilled, pattern in list(dp.items()):\n        dp[fulfilled | lc] += pattern\nprint((dp[(1 << m) - 1]))\n", "n = int(input())\nadj = [[] for _ in range(n)]\nadj_dict = dict()\n\nfor i in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    adj[a].append(b)\n    adj[b].append(a)\n    if a > b:\n        adj_dict[(b, a)] = i\n    else:\n        adj_dict[(a, b)] = i\n\nm = int(input())\nuv = []\nfor _ in range(m):\n    uv.append([int(x) - 1 for x in input().split()])\n\ndef dfs(p, v, dest):\n    if v == dest:\n        return [v]\n    if p != -1 and len(adj[v]) == 1:\n        return False\n    for nv in adj[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv, dest)\n        if ret:\n            return ret + [v]\n    return False\n\nedgest = [0] * (2 ** m)\nfor i, (u, v) in enumerate(uv):\n    ret = dfs(-1, u, v)\n    for uu, vv in zip(ret, ret[1:]):\n        if uu > vv:\n            uu, vv = vv, uu\n        if (uu, vv) in adj_dict:\n            edgest[1 << i] |= (1 << adj_dict[(uu, vv)])\n\nfor i in range(1, 2 ** m):\n    lsb = i & (-i)\n    edgest[i] = edgest[i ^ lsb] | edgest[lsb]\n\ndp = [0] * (2 ** m)\ndp[0] = 1 << (n - 1)\nans = dp[0]\nfor i in range(1, 2 ** m):\n    lsb = i & (-i)\n    lim = bin(edgest[i] ^ edgest[i ^ lsb]).count('1')\n    dp[i] = dp[i ^ lsb] >> lim\n    if bin(i).count('1') % 2 == 0:\n        ans += dp[i]\n    else:\n        ans -= dp[i]\nprint(ans)\n", "def main():\n    from itertools import combinations\n    n = int(input())\n    ab = [tuple(sorted(list(map(int, input().split())))) for _ in [0]*(n-1)]\n    m = int(input())\n    uv = [list(map(int, input().split())) for _ in [0]*m]\n    g = [[] for _ in [0]*n]\n    [g[a-1].append(b-1) for a, b in ab]\n    [g[b-1].append(a-1) for a, b in ab]\n\n    d = dict()\n    for i, (a, b) in enumerate(ab):\n        d[(a-1, b-1)] = i\n\n    def tree_path(root, goal):\n        d = [-1]*n  # \u6839\u304b\u3089\u306e\u8ddd\u96e2\n        d[root] = 0\n        q = [root]\n        cnt = 0\n        while q:  # BFS\n            cnt += 1\n            qq = []\n            while q:\n                i = q.pop()\n                for j in g[i]:\n                    if d[j] == -1:\n                        d[j] = cnt\n                        qq.append(j)\n            q = qq\n        now = goal\n        path = [goal]\n        while True:\n            dist = d[now]\n            for i in g[now]:\n                if d[i] < dist:\n                    now = i\n                    path.append(i)\n                    break\n            if dist == 1:\n                break\n        return path\n\n    seiyaku = [set() for _ in [0]*m]\n\n    for i, (u, v) in enumerate(uv):\n        path = tree_path(u-1, v-1)\n        for j in range(len(path)-1):\n            x, y = min(path[j], path[j+1]), max(path[j], path[j+1])\n            seiyaku[i].add(d[(x, y)])\n\n    cnt = 2**(n-1)\n\n    for i in range(1, m+1):\n        flag = 1\n        if i % 2 == 1:\n            flag = -1\n        cc = combinations(list(range(m)), i)\n        for c in cc:\n            s = set()\n            for j in c:\n                s |= seiyaku[j]\n            cnt += (2**(n-1-len(s)))*flag\n    print(cnt)\n\n\nmain()\n", "# https://atcoder.jp/contests/abc152/submissions/9619555\n\nimport sys\nreadline = sys.stdin.readline\n\nimport numpy as np\n\nN = int(readline())\nAB = list(list(map(int, readline().split())) for _ in range(N - 1))\nM = int(readline())\nUV = list(list(map(int, readline().split())) for _ in range(M))\n\ngraph = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(AB):\n    graph[a].append((b, i))\n    graph[b].append((a, i))\n\n\ndef get_path(U, V):\n    INF = 100\n    visited = [False] * (N + 1)\n    pred = [None] * (N + 1)\n    stack = [U]\n    visited[U] = True\n    while stack:\n        v = stack.pop()\n        for w, i in graph[v]:\n            if visited[w]:\n                continue\n            visited[w] = True\n            pred[w] = (v, i)\n            stack.append(w)\n    path = 0\n    w = V\n    while w != U:\n        v, i = pred[w]\n        w = v\n        path += 1 << i\n    return path\n\n\ncondition_path = [get_path(u, v) for u, v in UV]\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\n\nsgn = np.where(popcnt(np.arange(1 << M)) % 2, -1, 1)\nS = np.zeros(1 << M, np.int64)\nfor i in range(M):\n    S[1 << i:1 << (i + 1)] = S[:1 << i] | condition_path[i]\n\nn_edges = popcnt(S)\n\nx = 1 << (N - 1 - n_edges)\nanswer = np.sum(x * sgn)\nprint(answer)\n", "from collections import defaultdict\n\n\ndef dfs(s, t):\n    visited = 0\n    q = [(s, 0)]\n    while q:\n        v, used = q.pop()\n        if v == t:\n            return used\n        visited |= used\n        for lb, u in graph[v]:\n            if lb & visited:\n                continue\n            q.append((u, used | lb))\n\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    lb = 1 << i\n    graph[a].append((lb, b))\n    graph[b].append((lb, a))\n\nconditions = []\nm = int(input())\nfor i in range(m):\n    u, v = map(int, input().split())\n    conditions.append(dfs(u, v))\n\nlink_conditions = [int(''.join(i), 2) for i in zip(*[bin(j)[2:].zfill(n - 1) for j in conditions])]\n\ndp = defaultdict(int)\ndp[0] = 1\nfor lc in link_conditions:\n    for fulfilled, pattern in list(dp.items()):\n        dp[fulfilled | lc] += pattern\nprint(dp[(1 << m) - 1])", "# https://atcoder.jp/contests/abc152/submissions/9619555\n\nimport sys\nreadline = sys.stdin.readline\n\nimport numpy as np\n\nN = int(readline())\nAB = list(list(map(int, readline().split())) for _ in range(N - 1))\nM = int(readline())\nUV = list(list(map(int, readline().split())) for _ in range(M))\n\ngraph = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(AB):\n    graph[a].append((b, i))\n    graph[b].append((a, i))\n\n\ndef get_path(U, V):\n    INF = 100\n    visited = [False] * (N + 1)\n    pred = [None] * (N + 1)\n    stack = [U]\n    visited[U] = True\n    while stack:\n        v = stack.pop()\n        for w, i in graph[v]:\n            if visited[w]:\n                continue\n            visited[w] = True\n            pred[w] = (v, i)\n            stack.append(w)\n    path = 0\n    w = V\n    while w != U:\n        v, i = pred[w]\n        w = v\n        path += 1 << i\n    return path\n\n\ncondition_path = [get_path(u, v) for u, v in UV]\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\n\nsgn = np.where(popcnt(np.arange(1 << M)) % 2, -1, 1)\nS = np.zeros(1 << M, np.int64)\nfor i in range(M):\n    S[1 << i:1 << (i + 1)] = S[:1 << i] | condition_path[i]\n\nn_edges = popcnt(S)\n\nx = 1 << (N - 1 - n_edges)\nanswer = (x * sgn).sum()\nprint(answer)\n", "n = int(input())\nadj = [[] for _ in range(n)]\nadj_dict = dict()\n\nfor i in range(n - 1):\n    a, b = [int(x) - 1 for x in input().split()]\n    adj[a].append(b)\n    adj[b].append(a)\n    if a > b:\n        adj_dict[(b, a)] = i\n    else:\n        adj_dict[(a, b)] = i\n\nm = int(input())\nuv = []\nfor _ in range(m):\n    uv.append([int(x) - 1 for x in input().split()])\n\ndef dfs(p, v, dest):\n    if v == dest:\n        return [v]\n    if p != -1 and len(adj[v]) == 1:\n        return False\n    for nv in adj[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv, dest)\n        if ret:\n            return ret + [v]\n    return False\n\nedgest = [0] * (2 ** m)\nfor i, (u, v) in enumerate(uv):\n    ret = dfs(-1, u, v)\n    for uu, vv in zip(ret, ret[1:]):\n        if uu > vv:\n            uu, vv = vv, uu\n        if (uu, vv) in adj_dict:\n            edgest[1 << i] |= (1 << adj_dict[(uu, vv)])\n\nfor i in range(1, 2 ** m):\n    lsb = i & (-i)\n    edgest[i] = edgest[i ^ lsb] | edgest[lsb]\n\ndp = [0] * (2 ** m)\ndp[0] = 1 << (n - 1)\nans = dp[0]\nfor i in range(1, 2 ** m):\n    lsb = i & (-i)\n    lim = bin(edgest[i] ^ edgest[i ^ lsb]).count('1')\n    dp[i] = dp[i ^ lsb] >> lim\n    if bin(i).count('1') % 2 == 0:\n        ans += dp[i]\n    else:\n        ans -= dp[i]\nprint(ans)", "from functools import reduce\n# https://drken1215.hatenablog.com/entry/2020/01/26/164200\n# bit_path\u306e\u53c2\u8003\u306b\u3057\u305f\n# https://atcoder.jp/contests/abc152/submissions/9619555\n# popcnt\n\ndef main():\n    from collections import namedtuple\n    from functools import reduce\n    from itertools import combinations\n    from operator import or_\n\n    Edge = namedtuple('Edge', 'to edge_id')\n\n    def bit_path(curr, goal, par=-1):\n        if curr == goal:\n            return 0\n        for e in g[curr]:\n            if e.to == par: continue\n            res = bit_path(curr=e.to, goal=goal, par=curr)\n            if ~res:  # -1\u4ee5\u5916\n                return res | (1 << e.edge_id)\n        return -1\n\n    def popcnt(n):\n        \"\"\"https://atcoder.jp/contests/abc152/submissions/9619555\"\"\"\n        c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n        c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n        c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n        c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n        c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n        c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n        return c\n\n    N = int(input())\n\n    g = tuple(set() for _ in range(N))\n    for edge_id in range(N - 1):\n        a, b = (int(x) - 1 for x in input().split())\n        g[a].add(Edge(to=b, edge_id=edge_id))\n        g[b].add(Edge(to=a, edge_id=edge_id))\n\n    M = int(input())\n\n    cons = []\n    for _ in range(M):\n        u, v = (int(x) - 1 for x in input().split())\n        b = bit_path(u, v)\n        cons.append(b)\n\n    ans = 1 << (N - 1)\n    for k in range(1, M + 1):\n        for comb in combinations(cons, r=k):\n            b = reduce(or_, comb)\n            ans += ((-1) ** k) * (1 << (N - 1 - popcnt(b)))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nAB = [tuple(map(int,input().split())) for i in range(N-1)]\nM = int(input())\nUV = [tuple(map(int,input().split())) for i in range(M)]\n\nes = [[] for i in range(N)]\nfor i,(a,b) in enumerate(AB):\n    a,b = a-1,b-1\n    es[a].append((b,i))\n    es[b].append((a,i))\n\npaths = [0] * M\nfor i,(u,v) in enumerate(UV):\n    u,v = u-1,v-1\n    stack = [u]\n    visited = [0] * N\n    visited[u] = 1\n    edges = [-1] * N\n    while stack:\n        s = stack.pop()\n        for to,j in es[s]:\n            if visited[to]: continue\n            visited[to] = 1\n            edges[to] = j\n            stack.append(to)\n            if to == v:\n                break\n        else:\n            continue\n        while edges[v] >= 0:\n            j = edges[v]\n            paths[i] |= (1<<j)\n            a,b = AB[j]\n            a,b = a-1,b-1\n            v = a if a!=v else b\n        break\n\ndp = [0] * (1<<M)\nfor b in range(1,1<<M):\n    k = len(bin(b))-3\n    dp[b] = dp[b-2**k] | paths[k]\n\nans = 0\nfor i,d in enumerate(dp):\n    b = N-1 - bin(d).count('1')\n    ans += 2**b if bin(i).count('1')%2==0 else -2**b\nprint(ans)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nn = int(input())\nedge = [[] for _ in range(n)]\nedge_dict = dict()\n \nfor i in range(n - 1):\n    a, b = [int(item) - 1 for item in input().split()]\n    edge[a].append(b)\n    edge[b].append(a)\n    if a > b:\n        edge_dict[(b, a)] = i\n    else:\n        edge_dict[(a, b)] = i\n \nm = int(input())\nuv = []\nfor _ in range(m):\n    uv.append([int(item) - 1 for item in input().split()])\n \ndef dfs(p, v, dest):\n    if v == dest:\n        return [v]\n    if p != -1 and len(edge[v]) == 1:\n        return False\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv, dest)\n        if ret:\n            return ret + [v]\n    return False\n \n# edge-bitset of each set of constraints\nedgest = [0] * 2**m\nfor i, (u, v) in enumerate(uv):\n    ret = dfs(-1, u, v)\n    for uu, vv in zip(ret, ret[1:]):\n        if uu > vv:\n            uu, vv = vv, uu\n        if (uu, vv) in edge_dict:\n            edgest[1 << i] |= (1 << edge_dict[(uu, vv)])\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    edgest[i] = edgest[i ^ lsb] | edgest[lsb]\n \n# dp[set of constraints]\ndp = [0] * 2**m\ndp[0] = 1 << (n - 1)\nans = dp[0]\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    limit_num = bin(edgest[i] ^ edgest[i ^ lsb]).count(\"1\")\n    dp[i] = dp[i ^ lsb] >> limit_num\n    # Inclusion and exclusion\n    if bin(i).count(\"1\") % 2 == 0:\n        ans += dp[i]\n    else:\n        ans -= dp[i]\nprint(ans)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nn = int(input())\nedge = [[] for _ in range(n)]\nedge_dict = dict()\n \nfor i in range(n - 1):\n    a, b = [int(item) - 1 for item in input().split()]\n    edge[a].append(b)\n    edge[b].append(a)\n    if a > b:\n        edge_dict[(b, a)] = i\n    else:\n        edge_dict[(a, b)] = i\n \nm = int(input())\nuv = []\nfor _ in range(m):\n    uv.append([int(item) - 1 for item in input().split()])\n \ndef dfs(p, v, dest):\n    if v == dest:\n        return [v]\n    if p != -1 and len(edge[v]) == 1:\n        return False\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv, dest)\n        if ret:\n            return ret + [v]\n    return False\n \ntarget_edge = [0] * m\nfor i, (u, v) in enumerate(uv):\n    ret = dfs(-1, u, v)\n    for uu, vv in zip(ret, ret[1:]):\n        if uu > vv:\n            uu, vv = vv, uu\n        if (uu, vv) in edge_dict:\n            target_edge[i] |= (1 << edge_dict[(uu, vv)])\n\nedge_of_state = [0] * 2**m\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    edge_of_state[i] = edge_of_state[i ^ lsb] | target_edge[lsb.bit_length() - 1]\n \n# dp[fills uv as st]\ndp = [0] * 2**m\ndp[0] = pow(2, n-1) \nans = dp[0]\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    n_edgest = edge_of_state[i]\n    p_edgest = edge_of_state[i ^ lsb]\n    limit_num = bin(n_edgest ^ p_edgest).count(\"1\")\n    dp[i] = dp[i ^ lsb] // pow(2, limit_num)\n    if bin(i).count(\"1\") % 2 == 0:\n        ans += dp[i]\n    else:\n        ans -= dp[i]\nprint(ans)", "# https://atcoder.jp/contests/abc152/submissions/9619555\n\nimport numpy as np\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = map(int, readline().split())\n    lb = 1 << i\n    graph[a].append((lb, b))\n    graph[b].append((lb, a))\n\nM = int(readline())\n\n\ndef get_path(U, V):\n    visited = 0\n    q = [(U, 0)]\n    while q:\n        v, used = q.pop()\n        if v == V:\n            return used\n        visited |= used\n        for lb, u in graph[v]:\n            if lb & visited:\n                continue\n            q.append((u, used | lb))\n\n\ncondition_path = []\nfor i in range(M):\n    u, v = map(int, readline().split())\n    condition_path.append(get_path(u, v))\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\n\nsgn = np.where(popcnt(np.arange(1 << M)) % 2, -1, 1)\nS = np.zeros(1 << M, np.int64)\nfor i in range(M):\n    S[1 << i:1 << (i + 1)] = S[:1 << i] | condition_path[i]\n\n\nn_edges = popcnt(S)\nx = 1 << (N - 1 - n_edges)\nanswer = np.sum(x * sgn)\nprint(answer)", "from itertools import combinations\n\nn = int(input())\nab = [list(map(int, input().split())) for _ in range(n - 1)]\nm = int(input())\nuv = [list(map(int, input().split())) for _ in range(m)]\n\nadj = [[] for _ in range(n)]\nids = [[-1] * n for _ in range(n)]\nfor i, (a, b) in enumerate(ab):\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n    adj[b].append(a)\n    ids[a][b] = i\n    ids[b][a] = i\n\n\ndef dfs(s, g):\n    d = [-1] * n\n    d[s] = 0\n    p = [-1] * n\n    stack = [s]\n\n    while stack:\n        u = stack.pop()\n        for v in adj[u]:\n            if d[v] == -1:\n                d[v] = d[u] + 1\n                p[v] = u\n                stack.append(v)\n\n    v = g\n    ret = 0\n    while v != s:\n        i = ids[v][p[v]]\n        ret += 1 << i\n        v = p[v]\n\n    return ret\n\n\ndef bin_count(tpl):\n    sm_or = 0\n    for e in tpl:\n        sm_or |= e\n\n    return bin(sm_or).count(\"1\")\n\n\npath = [dfs(u - 1, v - 1) for u, v in uv]\nex = 0\nfor i in range(1, m + 1):\n    for tpl in combinations(path, i):\n        ex += pow(2, n - 1 - bin_count(tpl)) * (-1) ** (i % 2 + 1)\n\nans = pow(2, n - 1) - ex\nprint(ans)\n", "# \u591a\u5206TLE\nfrom scipy.sparse.csgraph import dijkstra\nfrom itertools import combinations\n\nN = int(input())\nedge_id = {}\nD = [[-float('inf')]*N for i in range(N)]\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  D[a-1][b-1] = D[b-1][a-1] = 1\n  edge_id[(a-1, b-1)] = i\n  edge_id[(b-1, a-1)] = i\n\npaths = dijkstra(D, return_predecessors=True)[1]\nM = int(input())\nedges = [0] * M\nfor i in range(M):\n  u, v = map(int, input().split())\n  now, p = paths[u-1][v-1], v-1\n  edges[i] += 1 << edge_id[(now, p)]\n  while now != u-1:\n    now, p = paths[u-1][now], now\n    edges[i] += 1 << edge_id[(now, p)]\n\nans = pow(2, N-1)\ncoeff = -1\nfor m in range(1, M+1):\n  for comb in combinations(edges, m):\n    e = 0\n    for c in comb:\n      e |= c\n    ans +=  coeff* pow(2, N-1-bin(e).count('1'))\n  coeff *= -1\n\nprint(ans)", "N = int(input())\nab = [tuple(map(int,input().split())) for _ in range(N - 1)]\nM = int(input())\nuv = [tuple(map(int,input().split())) for _ in range(M)]\nroute = [[] for _ in range(N)]\n\nfor i, (a, b) in enumerate(ab):\n    a -= 1\n    b -= 1\n    route[a].append((b, i))\n    route[b].append((a, i))\n\npath = [0] * M\nfor i, (u, v) in enumerate(uv):\n    u -= 1\n    v -= 1\n    stack = [u]\n    visited = [0] * N\n    visited[u] = 1\n    dire = [[] for _ in range(N)]\n    while True:\n        s = stack.pop()\n        for g, j in route[s]:\n            if visited[g]:\n                continue   \n            stack.append(g)\n            dire[g].append((s, j))\n            visited[g] = 1\n        if visited[v]:\n            break\n    s = v\n    while True:\n        g, num = dire[s][0]\n        path[i] |= (1 << num)\n        if g == u:\n            break\n        s = g\n\ndata = [0] * (1 << M)\nans = 2 ** (N - 1)\nfor i in range(1, 1 << M):\n    k = len(bin(i)) - 3\n    data[i] = data[i - (2 ** k)] | path[k]\n    power = bin(data[i]).count(\"1\")\n    judge = bin(i).count(\"1\")\n    ans += (-2 ** (N - 1 - power) if judge % 2 else 2 ** (N - 1 - power))\nprint(ans)\n", "# https://atcoder.jp/contests/abc152/submissions/9619555\n\nimport sys\nreadline = sys.stdin.readline\n\nimport numpy as np\n\nN = int(readline())\nAB = list(list(map(int, readline().split())) for _ in range(N - 1))\nM = int(readline())\nUV = list(list(map(int, readline().split())) for _ in range(M))\n\ngraph = [[] for _ in range(N + 1)]\nfor i, (a, b) in enumerate(AB):\n    graph[a].append((b, i))\n    graph[b].append((a, i))\n\n\ndef get_path(U, V):\n    INF = 100\n    visited = [False] * (N + 1)\n    pred = [None] * (N + 1)\n    stack = [U]\n    visited[U] = True\n    while stack:\n        v = stack.pop()\n        for w, i in graph[v]:\n            if visited[w]:\n                continue\n            visited[w] = True\n            pred[w] = (v, i)\n            stack.append(w)\n    path = 0\n    w = V\n    while w != U:\n        v, i = pred[w]\n        w = v\n        path += 1 << i\n    return path\n\n\ncondition_path = [get_path(u, v) for u, v in UV]\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\n\nS = np.zeros(1 << M, np.int64)\nsgn = np.ones(1 << M, np.int64)\nfor i in range(M):\n    S[1 << i:1 << (i + 1)] = S[:1 << i] | condition_path[i]\n    sgn[1 << i:1 << (i + 1)] = -sgn[:1 << i]\n\nn_edges = popcnt(S)\nx = 1 << (N - 1 - n_edges)\nanswer = (x * sgn).sum()\nprint(answer)\n", "# https://atcoder.jp/contests/abc152/submissions/9619555\n\nimport numpy as np\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(N - 1):\n    a, b = list(map(int, readline().split()))\n    graph[a].append((b, i))\n    graph[b].append((a, i))\n\nM = int(readline())\n\n\ndef get_path(U, V):\n    visited = [False] * (N + 1)\n    pred = [None] * (N + 1)\n    stack = [U]\n    visited[U] = True\n    while stack:\n        v = stack.pop()\n        for w, i in graph[v]:\n            if visited[w]:\n                continue\n            visited[w] = True\n            pred[w] = (v, i)\n            stack.append(w)\n    path = 0\n    w = V\n    while w != U:\n        v, i = pred[w]\n        w = v\n        path += 1 << i\n    return path\n\n\ncondition_path = []\nfor i in range(M):\n    u, v = list(map(int, readline().split()))\n    condition_path.append(get_path(u, v))\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)\n    return c\n\n\nsgn = np.where(popcnt(np.arange(1 << M)) % 2, -1, 1)\nS = np.zeros(1 << M, np.int64)\nfor i in range(M):\n    S[1 << i:1 << (i + 1)] = S[:1 << i] | condition_path[i]\n\n\nn_edges = popcnt(S)\nx = 1 << (N - 1 - n_edges)\nanswer = np.sum(x * sgn)\nprint(answer)\n", "from collections import defaultdict\n\n\ndef dfs(s, t, links):\n    visited = set()\n    q = [(s, 0)]\n    while q:\n        v, used = q.pop()\n        if v == t:\n            return used\n        visited.add(v)\n        for lb, u in links[v]:\n            if u in visited:\n                continue\n            q.append((u, used | lb))\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    lb = 1 << i\n    links[a].add((lb, b))\n    links[b].add((lb, a))\nconditions = []\nm = int(input())\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    conditions.append(dfs(u, v, links))\n\nlink_conditions = [int(''.join(b), 2) for b in zip(*list(map(('{:0' + str(n - 1) + 'b}').format, conditions)))]\n\ndp = defaultdict(lambda: 0)\ndp[0] = 1\nfor lc in link_conditions:\n    for fulfilled, pattern in list(dp.items()):\n        dp[fulfilled | lc] += pattern\nprint((dp[(1 << m) - 1]))\n", "from collections import defaultdict\n\n\ndef dfs(s, t):\n    visited = 0\n    q = [(s, 0)]\n    while q:\n        v, used = q.pop()\n        if v == t:\n            return used\n        visited |= used\n        for lb, u in graph[v]:\n            if lb & visited:\n                continue\n            q.append((u, used | lb))\n\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    a, b = list(map(int, input().split()))\n    lb = 1 << i\n    graph[a].append((lb, b))\n    graph[b].append((lb, a))\n\nconditions = []\nm = int(input())\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    conditions.append(dfs(u, v))\n\nlink_conditions = [int(''.join(b), 2) for b in zip(*list(map(('{:0' + str(n - 1) + 'b}').format, conditions)))]\n\ndp = defaultdict(lambda: 0)\ndp[0] = 1\nfor lc in link_conditions:\n    for fulfilled, pattern in list(dp.items()):\n        dp[fulfilled | lc] += pattern\nprint((dp[(1 << m) - 1]))\n", "from functools import reduce\n# https://drken1215.hatenablog.com/entry/2020/01/26/164200\n# bit_path\u306e\u53c2\u8003\u306b\u3057\u305f\n\ndef main():\n    from collections import namedtuple\n    from functools import reduce\n    from itertools import combinations\n    from operator import or_\n\n    Edge = namedtuple('Edge', 'to edge_id')\n\n    def bit_path(curr, goal, par=-1):\n        if curr == goal:\n            return 0\n        for e in g[curr]:\n            if e.to == par: continue\n            res = bit_path(curr=e.to, goal=goal, par=curr)\n            if ~res:  # -1\u4ee5\u5916\n                return res | (1 << e.edge_id)\n        return -1\n\n    N = int(input())\n\n    g = tuple(set() for _ in range(N))\n    for edge_id in range(N - 1):\n        a, b = (int(x) - 1 for x in input().split())\n        g[a].add(Edge(to=b, edge_id=edge_id))\n        g[b].add(Edge(to=a, edge_id=edge_id))\n\n    M = int(input())\n\n    cons = []\n    for _ in range(M):\n        u, v = (int(x) - 1 for x in input().split())\n        b = bit_path(u, v)\n        cons.append(b)\n\n    ans = 1 << (N - 1)\n    for k in range(1, M + 1):\n        for comb in combinations(cons, r=k):\n            b = reduce(or_, comb)\n            ans += ((-1) ** k) * (1 << (N - 1 - bin(b).count('1')))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n \nn = int(input())\nedge = [[] for _ in range(n)]\nedge_dict = dict()\n \nfor i in range(n - 1):\n    a, b = [int(item) - 1 for item in input().split()]\n    edge[a].append(b)\n    edge[b].append(a)\n    if a > b:\n        edge_dict[(b, a)] = i\n    else:\n        edge_dict[(a, b)] = i\n \nm = int(input())\nuv = []\nfor _ in range(m):\n    uv.append([int(item) - 1 for item in input().split()])\n \ndef dfs(p, v, dest):\n    if v == dest:\n        return [v]\n    if p != -1 and len(edge[v]) == 1:\n        return False\n    for nv in edge[v]:\n        if nv == p:\n            continue\n        ret = dfs(v, nv, dest)\n        if ret:\n            return ret + [v]\n    return False\n \n# edge-bitset of each constraint\ntarget_edge = [0] * m\nfor i, (u, v) in enumerate(uv):\n    ret = dfs(-1, u, v)\n    for uu, vv in zip(ret, ret[1:]):\n        if uu > vv:\n            uu, vv = vv, uu\n        if (uu, vv) in edge_dict:\n            target_edge[i] |= (1 << edge_dict[(uu, vv)])\n\n# edge-bitset of each set of constraints\nedgest = [0] * 2**m\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    edgest[i] = edgest[i ^ lsb] | target_edge[lsb.bit_length() - 1]\n \n# dp[set of constraints]\ndp = [0] * 2**m\ndp[0] = 1 << (n - 1)\nans = dp[0]\nfor i in range(1, 2**m):\n    lsb = i & (-i)\n    n_edgest = edgest[i]\n    p_edgest = edgest[i ^ lsb]\n    limit_num = bin(n_edgest ^ p_edgest).count(\"1\")\n    dp[i] = dp[i ^ lsb] >> limit_num\n    if bin(i).count(\"1\") % 2 == 0:\n        ans += dp[i]\n    else:\n        ans -= dp[i]\nprint(ans)"]
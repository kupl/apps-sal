["n = int(input())\nb = [int(x) for x in input().strip().split()]\n\nresult = {}\n\nfor x in b:\n    tmp = x\n    cnt = 0\n    while tmp & 1 == 0:\n        cnt += 1\n        tmp >>= 1\n    if cnt not in result:\n        result[cnt] = []\n    result[cnt].append(x)\n\nres1 = max([len(result[x]) for x in result])\nprint(n - res1)\nif n == res1:\n    return\n\nres2 = None\nfor x in result:\n    if len(result[x]) == res1:\n        res2 = x\n        break\n\nres3 = []\nfor x in result:\n    if x != res2:\n        for y in result[x]:\n            res3.append(str(y))\n\nprint(' '.join(res3))\n", "n = int(input())\nB = list(map(int, input().split()))\nA = []\nfor i in range(100):\n    A.append([])\nfor i in B:\n    x = i\n    c = 0\n    while x % 2 == 0:\n        x //= 2\n        c += 1\n    A[c].append(i)\nmlen = 0\nf = 1\nfor lst in A:\n    mlen = max(mlen, len(lst))\nans = []\nfor lst in A:\n    if len(lst) == mlen and f:\n        f = 0\n    else:\n        for x in lst:\n            ans.append(x)\nprint(len(ans))\nprint(' '.join(list(map(str, ans))))\n", "n = int(input())\nl = list(map(int,input().split()))\nwyk = [0] * n\nfor i in range(n):\n\tleft = 0\n\tright = 72\n\twhile abs(left-right) > 1:\n\t\tmid = (left+right)//2\n\t\tif l[i] % (2**mid) == 0:\n\t\t\tleft = mid\n\t\telse:\n\t\t\tright = mid\n\tmid = (left+right)//2\n\tif l[i] % (2**(mid+1)) == 0:\n\t\twyk[i] = mid+1\n\telse:\n\t\twyk[i] = mid\nd = {}\nfor i in wyk:\n\td[i] = 0\nfor i in wyk:\n\td[i] += 1\nmak = -888999\nfaw = 0\nfor i in d:\n\tif d[i] >= mak:\n\t\tmak = d[i]\n\t\tfaw = i\nprint(n - mak)\nfor i in range(n):\n\tif wyk[i] != faw:\n\t\tprint(l[i])\n", "import sys\nfrom collections import Counter\nreadline = sys.stdin.readline\n\nN = int(input())\nA = list(map(int, readline().split()))\nB = [(a&-a).bit_length() for a in A]\nC = Counter(B).most_common(1)[0][0]\nAns = []\nfor i in range(N):\n    if C != B[i]:\n        Ans.append(A[i])\n\nprint(len(Ans))\nif Ans:\n    print(*Ans)", "import math\nn = int(input())\nB = list(map(int,input().split())) \n\ndef solve(B):\n    odds = []\n    evens = []\n    for b in B:\n        if b%2 == 0:\n            evens.append(b)\n        else:\n            odds.append(b)\n    if len(evens) == 0:\n        # if no evens, we're gucci\n        return []\n\n    even_gcd = evens[0]\n    for e in evens:\n        even_gcd = math.gcd(even_gcd, e)\n\n    even_remove = [even_gcd*x for x in solve([e//even_gcd for e in evens])]\n\n    if len(odds) + len(even_remove) < len(evens):\n        return odds+even_remove\n    else:\n        return evens\n\n\nans = solve(B)\nprint(len(ans))\nif len(ans) != 0:\n    print(\" \".join([str(x) for x in ans]))\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nB=list(map(int,input().split()))\n\nANS=[0]*65\nBANS=[0]*n\n\nfor i in range(n):\n    b=B[i]\n    score=0\n    while b%2==0:\n        b//=2\n        score+=1\n\n    ANS[score]+=1\n    BANS[i]=score\n\nk=max(ANS)\nind=ANS.index(k)\nprint(n-k)\n\nT=[B[i] for i in range(n) if BANS[i]!=ind]\nprint(*T)\n", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    s = S()\n    d = defaultdict(lambda : 0)\n    for i in s:\n        d[i] += 1\n    ans = [1]*d[\"n\"]\n    d[\"o\"] -= d[\"n\"]\n    ans += [0]*d[\"o\"]\n    print(*ans)\n    return\n\n#B\ndef B():\n\n    n = I()\n    m = LIR(n)\n    f = [0]*n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            f[i] += math.log(m[i][j],10)\n    F = sum(f)\n    p = F/(2*(n-1))\n    a = [round(10**((f[i]-p)/(n-2))) for i in range(n)]\n    print(*a)\n    return\n\n#C\ndef C():\n    s = S()\n    n = len(s)\n    g = [0]*n\n    m = 26\n    f = [set() for i in range(n)]\n    f[ord(s[0])-ord(\"a\")].add(0)\n    for i in range(1,n):\n        lis = set()\n        k = ord(s[i])-ord(\"a\")\n        for j in range(k):\n            lis |= f[j]\n        for j in range(100):\n            if j not in lis:\n                g[i] = j\n                break\n        f[k].add(j)\n    for i in g:\n        if i == 0:\n            print(\"Mike\")\n        else:\n            print(\"Ann\")\n    return\n\n#D\ndef D():\n    n = I()\n    b = LI()\n    l = [i&-i for i in b]\n    d = defaultdict(lambda : 0)\n    for i in l:\n        d[i] += 1\n    m = [0,0]\n    for i,j in list(d.items()):\n        if m[1] < j:\n            m = [i,j]\n    ans = []\n    for i in range(n):\n        if m[0] != l[i]:\n            ans.append(b[i])\n    print(len(ans))\n    print(*ans)\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#G\ndef G():\n\n    return\n\n\n#Solve\ndef __starting_point():\n    D()\n\n__starting_point()", "def gns():\n\treturn list(map(int,input().split()))\nn=int(input())\nns=gns()\ncnt=[0]*100\nans=0\nfor c in ns:\n\tfor l in range(100):\n\t\tif c%(1<<l)==0:\n\t\t\tcontinue\n\t\telse:\n\t\t\tbreak\n\tl-=1\n\tcnt[l]+=1\nm=max(cnt)\nfor i in range(100):\n\tif cnt[i]==m:\n\t\tm=i\n\t\tbreak\n\nx=[]\nfor c in ns:\n\tif c%(1<<m)==0 and c%(1<<(m+1))!=0:\n\t\tcontinue\n\tx.append(c)\nprint(len(x))\nprint(' '.join(map(str,x)))\n", "a = int(input())\nl = list(map(int, input().split()))\nans = [0 for i in range(100)]\nfor i in l:\n    n = 0\n    while i % 2 == 0:\n        n += 1\n        i //= 2\n    ans[n] += 1\nk = ans.index(max(ans))\nann = []\nfor i in l:\n    if i % (2 ** k) != 0 or i % (2 ** (k + 1)) == 0:\n        ann.append(i) \n    else:\n        pass  \nprint(len(ann))\nprint(*ann)", "n=int(input())\na=list(map(int,input().split()))\nc=0\nb=[]\nfor i in range(n):\n    k=1\n    t=0\n    while a[i]%k==0:\n        k=k*2\n        t+=1\n    b.append(t)\nfrom collections import Counter\ncount = Counter(b)\np=count.most_common()\nx=p[0][0]\nprint(n-p[0][1])\nfor i in range(n):\n    if b[i]!=x:\n        print(a[i],end=\" \")\n", "n = int(input())\ndists = list(map(int, input().split()))\npow2 = [[] for _ in range(64)]\nSet = [0] * n\nfor i in range(n):\n    ds = d = dists[i]\n    powd = 0\n    while d % 2 == 0:\n        d >>= 1\n        powd += 1\n    pow2[powd].append(ds)\n    Set[i] = powd\nmaxset = max(range(64), key=lambda x: len(pow2[x]))\nprint(n - len(pow2[maxset]))\nfor i in range(n):\n    if Set[i] != maxset:\n        print(dists[i], end=\" \")\n", "# https://codeforces.com/contest/1220/problem/D\n\nn    = int(input())\na    = list(map(int, input().split()))\n\nmax_ = 0\nind  = -1\nd    = {0:0}\nmark = [0] * n\n\nfor i, x in enumerate(a):\n    if x%2 == 1:\n        d[0] += 1\n    else:\n        cnt = 0\n        while x % 2 == 0:\n            cnt += 1\n            x  //= 2\n        \n        if cnt not in d:\n            d[cnt] = 0\n        d[cnt] += 1     \n        mark[i]  = cnt\n        \nfor k, v in d.items():\n    if v > max_:\n        max_ = v\n        ind  = k \n\nremove = [a[i] for i, x in enumerate(mark) if x != ind]\nprint(len(remove))\nprint(' '.join([str(x) for x in remove]))", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n            (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    sets = [set() for _ in range(70)]\n    for i in li:\n        c = 0\n        k = i\n        while i%2==0:\n            i = i//2\n            c += 1\n        sets[c].add(k)\n    max_i = 0\n    for index in range(70):\n        if len(sets[max_i])<len(sets[index]):\n            max_i = index\n    uni = set()\n    for i, seti in enumerate(sets):\n        if i!=max_i:\n            uni = uni.union(seti)\n    print(len(uni))\n    display_list(list(uni))\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "n = int(input())\na = list(map(int, input().split()))\n\ncount = [0] * 100\nb = [0] * 200005\nfor i, v in enumerate(a):\n    tot = 0\n    while v % 2 == 0:\n        v //= 2\n        tot += 1\n    count[tot] += 1\n    b[i] = tot\nm = max(count)\nidx = count.index(m)\nprint(n-m)\nfor i in range(n):\n    if b[i] != idx:\n        print(a[i], end=' ')\n", "from collections import Counter\n\ndef countbit(x):\n    ans = 0\n    while not (x&1):\n        ans += 1\n        x >>= 1\n    return ans\n    \n\nn = int(input())\nb = list(map(int,input().split()))\n\ncnt = Counter()\nfor x in b:\n    cnt[countbit(x)] += 1\n\nmostcnt = cnt.most_common(1)\n#mostcnt is list \n\nans = []\nfor x in b:\n    if countbit(x) != mostcnt[0][0]:\n        ans.append(x)\n\nprint(len(ans))        \nprint(' '.join([str(x) for x in ans]))\n", "n = int(input())\nl = list(map(int, input().split()))\ntemp = []\nfor i in l:\n    temp.append(len(bin(i & -i)[2:]))\nf = [0] * (61)\nfor i in temp:\n    f[i] += 1\ncmp = f.index(max(f))\nans = []\nfor i in range(n):\n    if temp[i] != cmp: ans.append(l[i])\nprint(len(ans))\nprint(*ans)", "n = int(input())\nl = list(map(int, input().split()))\ntemp = []\nfor i in l:\n    temp.append(len(bin(i & -i)[2:]))\nf = [0] * (61)\nfor i in temp:\n    f[i] += 1\ncmp = f.index(max(f))\nans = []\nfor i in range(n):\n    if temp[i] != cmp: ans.append(l[i])\nprint(len(ans))\nprint(*ans)", "import sys\n\ndef twoDiv(n):\n    at = 0\n    while n%2 == 0:\n        n = n//2\n        at += 1\n    return at\n\ntotal = int(next(sys.stdin))\nnums = [int(k) for k in next(sys.stdin).split()]\n\ncomps = {}\nlargest = 0\nfor n in nums:\n    k = twoDiv(n)\n    if k not in comps.keys():\n        comps[k] = set()\n    comps[k].add(n)\n    largest = max(largest, len(comps[k]))\n\ngood = -1\nfor c in comps:\n    if len(comps[c]) == largest:\n        good = c\n        break\ndel comps[good]\n\nans = set()\nfor c in comps:\n    ans = ans|comps[c]\nans = sorted(list(ans))\nprint(total - largest)\nat = 0\nfor k in ans:\n    at = at + 1\n    if at == total - largest:\n        print(k, end=\"\\n\")\n        quit()\n    print(k, end=\" \")\n", "n = int(input())\nB = list(map(int, input().split()))\nA = []\nfor i in range(100):\n    A.append([])\nfor i in B:\n    x = i\n    c = 0\n    while x % 2 == 0:\n        x //= 2\n        c += 1\n    A[c].append(i)\nmlen = 0\nf = 1\nfor lst in A:\n    mlen = max(mlen, len(lst))\nans = []\nfor lst in A:\n    if len(lst) == mlen and f:\n        f = 0\n    else:\n        for x in lst:\n            ans.append(x)\nprint(len(ans))\nprint(' '.join(list(map(str, ans))))", "n=int(input())\nl=list(map(int,input().split()))\narr=[0]*65\nll=[0]*n\nfor i in range(n):\n    cou=0\n    a=l[i]\n    while a%2==0:\n        cou+=1\n        a=a//2\n    arr[cou]+=1\n    ll[i]=cou\n#print(arr)\nm=arr.index(max(arr))\nres=[]\nrak=0\nfor i in range(n):\n    if(ll[i]==m):\n        rak+=1\n    else:\n        res.append(l[i])\nprint(n-rak)\nif(n-rak):\n    print(*res)", "try:\n    from string_source import string_source\n\n    source = string_source(\n        \"\"\"2\n2 6\"\"\"\n    )\nexcept ImportError:\n    source = input\n\nfrom collections import Counter\n\n\ndef two_factors(n):\n    if n == 0:\n        return 0\n\n    f = 0\n    while n % 2 == 0:\n        f += 1\n        n //= 2\n\n    return f\n\n\ndef f(numbers):\n    twos = list(map(two_factors, numbers))\n    m = max(list(Counter(twos).items()), key=lambda x: x[1])[0]\n    erased = [n for (n, t) in zip(numbers, twos) if t != m]\n    return len(erased), erased\n\n\nsource()\nn, erased = f(list(map(int, source().split(\" \"))))\nprint(n)\nprint(\" \".join(map(str, erased)))\n", "n = int(input())\nu = list(map(int, input().split()))\na = []\nfor i in range(n):\n    a.append(len(bin(u[i] & -u[i])[2:]))\n#print(a)\nx = [0] * 61\nfor i in range(len(a)):\n    x[a[i]] += 1\n#print(x)\nmx = max(x)\np = -1\nfor i in range(61):\n    if x[i] == mx:\n        p = i\n        break\n#print(p)\nq = []\nfor i in range(n):\n    if a[i] != p:\n        q.append(u[i])\nprint(len(q))\nprint(' '.join(map(str, q)))\n", "#Bhargey Mehta (Junior)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open('input.txt', 'r')\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nn = int(input())\na = list(map(int, input().split()))\nx = {}\nfor i in range(n):\n    p = 0\n    t = a[i]\n    while t%2 == 0:\n        p += 1\n        t = t>>1\n    if p in x:\n        x[p].append(a[i])\n    else:\n        x[p] = [a[i]]\nkeep = []\nfor k in x:\n    if len(x[k]) > len(keep):\n        keep = x[k]\nprint(n-len(keep))\nkeep = set(keep)\nfor ai in a:\n    if ai not in keep:\n        print(ai, end=' ')\nprint()", "N = int(input())\n*B, = map(int, input().split())\nC = [0]*64\nL = [[] for i in range(64)]\nfor b in B:\n    l = (b & -b).bit_length()\n    C[l] += 1\n    L[l].append(b)\ni = C.index(max(C))\nR = [b for b in B if (b & -b).bit_length() != i]\nprint(len(R))\nif R:\n    print(*R)"]
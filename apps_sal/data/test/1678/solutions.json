["from sys import stdin\nfrom bisect import bisect_left\ndef read_bit(tree, idx):\n    s = 0\n    while idx > 0:\n        s += tree[idx]\n        idx -= (idx & -idx)\n    return s\ndef update_bit(tree, idx, val):\n    while idx < len(tree):\n        tree[idx] += val\n        idx += (idx & -idx)\n\nn,t=list(map(int,stdin.readline().split()))\na=[int(x) for x in stdin.readline().split()]\npref=[0]*n\npref[0]=a[0]\nfor i in range(1,n):\n    pref[i]=pref[i-1]+a[i]\npref.sort()\nbefore=ans=0\ntree=[0]*(n+2)\nfor i in range(n):\n    ind = bisect_left(pref, t + before)\n    if ind>0:\n        ans += ind-read_bit(tree, ind)\n    before += a[i]\n    before_ind=bisect_left(pref, before)\n    update_bit(tree, before_ind+1, 1)\nprint(ans)\n", "import bisect\nclass BIT:\n    def __init__(self, node_size):\n        self._node = node_size+1\n        self.bit = [0]*self._node\n\n    def add(self, index, add_val):\n        while index < self._node:\n            self.bit[index] += add_val\n            index += index & -index\n\n    def sum(self, index):\n        res = 0\n        while index > 0:\n            res += self.bit[index]\n            index -= index & -index\n        return res\nn,t = map(int,input().split())\na = list(map(int,input().split()))\nru = [0] * (n+1)\nans = 0\nfor i in range(1,n+1):\n  ru[i] = ru[i-1]+ a[i-1]\nrus = sorted(ru)\nbit = BIT(n+2)\nfor i in range(n+1):\n  ru[i] = bisect.bisect_left(rus,ru[i])\nfor i in range(n+1):\n  ind = bisect.bisect_left(rus,rus[ru[i]]-t+1)\n  ans += bit.sum(n+2)-bit.sum(ind)\n  bit.add(ru[i]+1,1)\nprint(ans)", "from itertools import accumulate, chain\n\n\nclass Fenwick:\n    def __init__(self, n):\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, val):\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] += 1\n            i += (i & -i)\n\n    def get(self, i):\n        i += 1\n        total = 0\n        while i > 0:\n            total += self.tree[i]\n            i -= (i & -i)\n        return total\n\n\ndef solution(n, a, t):\n    S = [s for s in accumulate(a)]\n    T = [[s, s - t] for s in S]\n    T = list(set(chain(*T)))\n    T.sort()\n    T = {v: i for i, v in enumerate(T)}\n\n    fenwick = Fenwick(len(T))\n    total = 0\n    for i, v in enumerate(S):\n        diff = v - t\n        total += i - fenwick.get(T[diff])\n        if v < t:\n            total += 1\n        fenwick.update(T[v], 1)\n    return total\n\n\nf = lambda: [int(c) for c in input().split()]\nn, t = f()\na = f()\nprint(solution(n, a, t))\n\n", "from itertools import accumulate, chain\n\n\nclass Fenwick:\n    def __init__(self, n):\n        self.tree = [0] * (n + 1)\n\n    def update(self, i, val):\n        i += 1\n        while i < len(self.tree):\n            self.tree[i] += 1\n            i += (i & -i)\n\n    def get(self, i):\n        i += 1\n        total = 0\n        while i > 0:\n            total += self.tree[i]\n            i -= (i & -i)\n        return total\n\n\ndef solution(n, a, t):\n    S = [s for s in accumulate(a)]\n    T = set([s for s in S] + [s - t for s in S])\n    T = sorted(T)\n    T = {v: i for i, v in enumerate(T)}\n\n    fenwick = Fenwick(len(T))\n    total = 0\n    for i, v in enumerate(S):\n        diff = v - t\n        total += i - fenwick.get(T[diff])\n        if v < t:\n            total += 1\n        fenwick.update(T[v], 1)\n    return total\n\n\nf = lambda: [int(c) for c in input().split()]\nn, t = f()\na = f()\nprint(solution(n, a, t))\n\n", "r = input\nn,t = map(int,r().split())\narr = [int(x) for x in r().split()]\nN = -40**14-20**14\npresum =[0]\n#Function\ndef update(Bit,x):\n    while(x<=n):\n        Bit[x]+=1\n        x+=(x&-x)\ndef get(Bit,x):\n    res = 0\n    while(x>0):\n        res+=Bit[x]\n        x-=(x&-x)\n    return res\n#\nfor i in arr:\n    presum.append(presum[-1]+i)\nfakeIndex = [N]\nfor i in presum:\n    fakeIndex.append(i)\n    fakeIndex.append(i-t)\nfakeIndex.sort()\nIndx = {}\nfor i,j in enumerate(fakeIndex):\n    #print(j,' ',i)\n    Indx[j] = i\nn = len(fakeIndex)\nBit = [0 for i in range(0,n+1)]\nans = 0\ncnt = 0\nfor i in presum:\n    #temp = get(Bit,Indx[i-t])\n    ans+=(cnt - get(Bit,Indx[i-t]))\n    update(Bit,Indx[i])\n    cnt+=1\nprint(ans)", "from bisect import bisect_left\n\nsum = [0]*200005\nsrt = []\nn,t = list(map(int,input().split()))\na = list(map(int,input().split()))\n\ntree = [0]*200005\n\ndef get(x):\n    ans = 0\n    while x:\n        ans += tree[x]\n        x -= x&-x\n    return ans\n\ndef update(x):\n\n    while x <= 200002:\n        tree[x] += 1\n        x += x&-x\n\n\nfor i in range(n):\n    if i:\n        sum[i] = sum[i-1] + a[i]\n    else:\n        sum[i] = a[i]\n    srt.append(sum[i])\n\nif 0 not in srt:\n    srt.append(0)\n\nsrt.sort()\n\nans = 0\nupdate(bisect_left(srt,0) + 1)\n\n\n\n\nfor i in range(n):\n    l = min(len(srt)-1,bisect_left(srt,sum[i] - t))\n\n    if srt[l] <= sum[i] - t:\n        l = l+1\n\n    cnt = get(l)\n    ans += i + 1 - cnt\n\n\n    update(bisect_left(srt,sum[i]) + 1)\n\nprint(ans)\n\n", "# import atexit\n# import io\n# import sys\n#\n# _INPUT_LINES = sys.stdin.read().splitlines()\n# input = iter(_INPUT_LINES).__next__\n# _OUTPUT_BUFFER = io.StringIO()\n# sys.stdout = _OUTPUT_BUFFER\n#\n#\n# @atexit.register\n# def write():\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\n\nfrom bisect import bisect_left\nfrom itertools import accumulate\n\n\ndef update(x, delta):\n    while x <= n:\n        bit[x] += delta\n        x += x & (-x)\n\n\ndef query(x):\n    ans = 0\n    while x > 0:\n        ans += bit[x]\n        x -= x & (-x)\n    return ans\n\n\nn, t = list(map(int, input().split()))\narr = list(accumulate(list(map(int, input().split()))))\n\nbit = [0 for i in range(n + 2)]\n\npost = list(sorted([-10 ** 19] + arr))\n\narr = [0] + arr\n\nleftmost = dict()\n\nfor idx, v in enumerate(post):\n    if v not in leftmost:\n        leftmost[v] = idx\n\nres = 0\n\nfor i in range(1, len(arr)):\n    lower_idx = bisect_left(post, arr[i - 1] + t)\n    res += lower_idx - query(lower_idx - 1) - 1\n    update(leftmost[arr[i]], 1)\n\nprint(res)\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 11/21/18\n\n\nFenwick Tree\n\nprefix sum in s\nj < i, s[i]-s[j] < t,\n\ni+1 - (c = count of j that makes s[i]-s[j] >= t)\nc = count of s[j] <= s[i] - t\n\n\n\"\"\"\nimport bisect\n\n\nN, T = list(map(int, input().split()))\n\nA = [int(x) for x in input().split()]\n\n\nprefsums = [0] * (N+1)\nfor i in range(N):\n    prefsums[i+1] = A[i] + prefsums[i]\n    \n    \n\nMAXNN = len(prefsums) + 1\nL = [0] * MAXNN\n\n\ndef lsb(i):\n    return i & (-i)\n\n\ndef update(i):\n    while i < MAXNN:\n        L[i] += 1\n        i |= i+1\n\n\ndef get(i):\n    ans = 0\n    while i >= 0:\n        ans += L[i]\n        i = (i&(i+1))-1\n    \n    return ans\n\nprefsums = list(sorted(set(prefsums)))\nans = 0\nupdate(bisect.bisect_left(prefsums, 0))\n\npr = 0\nfor i, v in enumerate(A):\n    pr += v\n    npos = bisect.bisect_right(prefsums, pr-T)\n    ans += i+1-get(npos-1)\n    k = bisect.bisect_left(prefsums, pr)\n    update(k)\n\nprint(ans)\n\n\n\n", "# https://codeforces.com/contest/1042/problem/D\n# \u89e3\u8aacAC\n# sr - sl < t\n# sl > sr - t\n# index - sr -t \u4ee5\u4e0b\u306e\u6570\n\nfrom itertools import accumulate\n\nclass binary_index_tree(object):\n    def __init__(self, n):\n        self.bit = [0]*n\n        self.n = n\n    def add(self, ind, num):\n        # index is one_indexed\n        while(ind <= self.n):\n            self.bit[ind - 1] += num\n            ind += ind & -ind\n    # [1, ind)\n    def sum(self, ind):\n        # index is one indexed\n        ret = 0\n        while(ind > 0):\n            ret += self.bit[ind-1]\n            ind -= ind & -ind\n        return ret\n    # [from_, to_)\n    def sum_from(self, from_, to_):\n        # index is one indexed\n        return self.sum(to_) - self.sum(from_)\n\nn,t = map(int, input().split())\na = list(map(int, input().split()))\nsa = list(accumulate(a))\nss = sa + [i-t for i in sa]\n#print(ss)\nss.sort()\n# \u5ea7\u5727\nd = {}\ncnt = 0\nfor i in sorted(ss):\n    if i not in d:\n        d[i] = cnt\n        cnt += 1\nBIT = binary_index_tree(cnt+1)\nans = 0\nfor ar in sa:\n    # 1-indexed\n    r = d[ar-t] + 1\n    i = d[ar] + 1\n    ans += BIT.sum_from(r, cnt+1)\n    BIT.add(i, 1)\n#print(ans)\nfor i in sa:\n    if i < t:\n        ans += 1\nprint(ans)", "def merge(l,r):\n    nonlocal num\n    if l>=r:\n        return \n    mid=(l+r)>>1\n    merge(l,mid)\n    merge(mid+1,r)\n    j=mid+1\n    for i in range(l,mid+1):\n        while j<=r and arr[j]-arr[i]<t:\n            j+=1\n        num+=j-mid-1\n    arr[l:r+1]=sorted(arr[l:r+1])\nn,t=map(int,input().split())\nList=list(map(int,input().split()))\nnum=0\narr=[0]*(n+1)\nfor i in range(1,n+1):\n    arr[i]=arr[i-1]+List[i-1]\nmerge(0,n)\nprint(num)", "n, t = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsumm = [0]\ncur = 0\nfor i in range(n):\n    cur += a[i]\n    summ.append(cur)\n\n\ndef merge(l, mid, r):\n    i, j = l, mid + 1\n    ans = 0\n    while i <= mid and j <= r:\n        if summ[i] + t > summ[j]:\n            ans += (mid + 1 - i)\n            j += 1\n        else:\n            i += 1\n\n    tmp = []\n    i, j = l, mid + 1\n    while i <= mid and j <= r:\n        if summ[i] <= summ[j]:\n            tmp.append(summ[i])\n            i += 1\n        else:\n            tmp.append(summ[j])\n            j += 1\n    if i <= mid:\n        tmp.extend(summ[i:mid + 1])\n    if j <= r:\n        tmp.extend(summ[j:r+1])\n    for i in range(l, r + 1):\n        summ[i] = tmp[i - l]\n\n    return ans\n\n\n\ndef helper(l, r):\n    if l == r:\n        return 0\n    mid = (l + r) // 2\n    ans1 = helper(l, mid)\n    ans2 = helper(mid + 1, r)\n    ans3 = merge(l, mid, r)\n    #print(ans1, ans2, ans3)\n    return ans1 + ans2 + ans3\n\nres = helper(0, n)\nprint(res)\n\n\n'''\n5 4\n5 -1 3 4 -1\n\nOutput\n\n5\n\nInput\n\n3 0\n-1 2 -3\n\nOutput\n\n4\n\nInput\n\n4 -1\n-2 1 -2 3\n\nOutput\n\n3\n'''\n", "def lowbit(index):\n    return index & (-index)\n\n\ndef update(index, delta=1):\n    while index <= size:\n        tree[index] += delta\n        index += lowbit(index)\n\n\n\ndef query(index):\n    res = 0\n    while index > 0:\n        res += tree[index]\n        index -= lowbit(index)\n    return res\n\n\nn, t = list(map(int, input().split()))\na = list(map(int, input().split()))\n#n, t = 5, 4\n#a = [5, -1, 3, 4, -1]\n\nsumm_raw = [0]\nsumm_minus = []\ncur = 0\nfor i in range(n):\n    cur += a[i]\n    summ_raw.append(cur)\n    summ_minus.append(cur - t)\n\nsumm = sorted(list(set(summ_raw + summ_minus)))\nsize = len(summ)\nd = {}\nfor i in range(size):\n    d[summ[i]] = i + 1\n#print(summ)\n#print(d)\ntree = [0] * (size + 1)\nupdate(d[0])\n\nres = 0\nfor i in range(1, n+1):\n    v = summ_raw[i]\n    index = d[v - t]\n    cur = (query(size) - query(index))\n    #print(tree, size, query(size), cur, v, index)\n    res += cur\n    update(d[v])\nprint(res)\n\n\n\n'''\n# divide and conquer, two pointers\n\nn, t = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nsumm = [0]\ncur = 0\nfor i in range(n):\n    cur += a[i]\n    summ.append(cur)\n\n\ndef merge(l, mid, r):\n    i, j = l, mid + 1\n    ans = 0\n    while i <= mid and j <= r:\n        if summ[i] + t > summ[j]:\n            ans += (mid + 1 - i)\n            j += 1\n        else:\n            i += 1\n\n    tmp = []\n    i, j = l, mid + 1\n    while i <= mid and j <= r:\n        if summ[i] <= summ[j]:\n            tmp.append(summ[i])\n            i += 1\n        else:\n            tmp.append(summ[j])\n            j += 1\n    if i <= mid:\n        tmp.extend(summ[i:mid + 1])\n    if j <= r:\n        tmp.extend(summ[j:r+1])\n    for i in range(l, r + 1):\n        summ[i] = tmp[i - l]\n\n    return ans\n\n\n\ndef helper(l, r):\n    if l == r:\n        return 0\n    mid = (l + r) // 2\n    ans1 = helper(l, mid)\n    ans2 = helper(mid + 1, r)\n    ans3 = merge(l, mid, r)\n    #print(ans1, ans2, ans3)\n    return ans1 + ans2 + ans3\n\nres = helper(0, n)\nprint(res)\n'''\n\n'''\n5 4\n5 -1 3 4 -1\n\nOutput\n\n5\n\nInput\n\n3 0\n-1 2 -3\n\nOutput\n\n4\n\nInput\n\n4 -1\n-2 1 -2 3\n\nOutput\n\n3\n'''\n", "\nn,t=list(map(int,input().split()))\na=list(map(int,input().split()))\n\nbit=[0 for i in range(n+2)]\n\ndef qq(i):\n\tans=0\n\ti=i+1\n\twhile i>0:\n\t\tans+=bit[i]\n\t\ti-=i&-i\n\treturn(ans)\n\ndef u(i):\n\ti+=1\n\twhile i<=n+1:\n\t\tbit[i]+=1\n\t\ti+=i&-i\n\nq=[]\n\nc=[0]\nfor i in range(n):\n\tc.append(c[-1]+a[i])\n\tq.append((i+1,t+c[i]))\n\n\n\nc=[(c[i],i) for i in range(n+1)]\nc.sort()\n\nq.sort(key=lambda x:x[1])\nans=0\n\ni=0\nj=0\nwhile j<len(q):\n\tl,x=q[j]\n\twhile i<=n and c[i][0]<x:\n\t\tu(c[i][1])\n\t\ti+=1\n\tans+=qq(n)-qq(l-1)\n\tj+=1\nprint(ans)\n\n\n", "def sort_list(list1, list2): \n  \n    zipped_pairs = zip(list2, list1) \n  \n    z = [x for _, x in sorted(zipped_pairs)] \n      \n    return z \nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a,b:a+b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n \n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n \n    def __delitem__(self, idx):\n        self[idx] = self._default\n \n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n \n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n \n    def __len__(self):\n        return self._len\n \n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n \n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n \n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\ndef calc(prefix,t):\n    ind=[i for i in range(len(prefix))]\n    ind=sort_list(ind,prefix)\n    prefix.sort()\n    a=[0]*len(prefix)\n    s=SegmentTree(a)\n    j=0\n    ans=0\n    for i in range(len(prefix)):\n        if j==len(prefix):\n            ans+=s.query(ind[i]+1,len(prefix)-1)\n            #print(ans,ind[i])\n            continue\n        while(prefix[j]-t<prefix[i]):\n            s.__setitem__(ind[j],1)\n            j+=1\n            if j==len(prefix):\n                break\n        ans+=s.query(ind[i]+1,len(prefix)-1)\n        #print(ans,ind[i])\n    print(ans)\nn,t=map(int,input().split())\nl=list(map(int,input().split()))\npre=[0]\nfor i in range(n):\n    pre.append(pre[-1]+l[i])\ncalc(pre,t)", "#yeh dil maange more\ndef merge(l,r):\n    nonlocal num\n    if l>=r:\n        return \n    mid=(l+r)>>1\n    merge(l,mid)\n    merge(mid+1,r)\n    j=mid+1\n    for i in range(l,mid+1):\n        while j<=r and arr[j]-arr[i]<t:\n            j+=1\n        num+=j-mid-1\n    arr[l:r+1]=sorted(arr[l:r+1])\nn,t=map(int,input().split())\nList=list(map(int,input().split()))\nnum=0\narr=[0]*(n+1)\nfor i in range(1,n+1):\n    arr[i]=arr[i-1]+List[i-1]\nmerge(0,n)\nprint(num)", "def merge(l,r):\n    nonlocal num\n    if l>=r:\n        return \n    mid=(l+r)>>1\n    merge(l,mid)\n    merge(mid+1,r)\n    j=mid+1\n    for i in range(l,mid+1):\n        while j<=r and arr[j]-arr[i]<t:\n            j+=1\n        num+=j-mid-1\n    arr[l:r+1]=sorted(arr[l:r+1])\nn,t=map(int,input().split())\nList=list(map(int,input().split()))\nnum=0\narr=[0]*(n+1)\nfor i in range(1,n+1):\n    arr[i]=arr[i-1]+List[i-1]\nmerge(0,n)\nprint(num)"]
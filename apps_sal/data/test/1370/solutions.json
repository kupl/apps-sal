["h, w, k = list(map(int, input().split()))\n\nchoco = [list(map(int, list(input()) )) for i in range(h)]\n\nchoco_cumsum = [[0 for i in range(w)] for j in range(h)]\n\nfor i in range(h):\n    choco_cumsum[i][0] = choco[i][0]\n    for j in range(1, w):\n        choco_cumsum[i][j] = choco_cumsum[i][j-1] + choco[i][j]\n\nans = h + w + 1\n\nfor h_cut in range(2**(h-1)):\n    # \u4e0a\u4f4d\u30d3\u30c3\u30c8\u304c\u4e0a\u5074\u30021\u304c\u5207\u308b\u30010\u304c\u5207\u3089\u306a\u3044\n    num_cut_init = bin(h_cut).count(\"1\") # \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u306e\u500b\u6570\n    num_cut = num_cut_init\n    w_last_cot_pos = -1\n    valid = True\n\n    temp_list = [0] * (num_cut_init + 1)\n    temp_dict = {}\n    idx = 0\n    temp_dict[0] = idx\n    for i in range(1, h):\n        # print('idx', 2 ** (-i+h-1) )\n        if h_cut & (2 ** (-i+h-1) ):\n            idx += 1\n        # idx += h_cut & (2 ** (h-1) - i)\n        temp_dict[i] = idx\n    # print(temp_dict)\n\n    iw = 0\n    while iw < w:\n\n        for ih in range(h):\n            temp_list[temp_dict[ih]] += choco[ih][iw]\n        # print(iw, temp_list)\n\n        condition = max(temp_list) > k\n        if condition:\n            if w_last_cot_pos < iw-1:\n                # \u3082\u3057\u305d\u3053\u3067\u5207\u3063\u3066k\u3092\u8d85\u3048\u308b\u306a\u3089\u3001\u305d\u306e\u624b\u524d\u3067\u5207\u308b\n                num_cut += 1\n                w_last_cot_pos = iw - 1\n                temp_list = [0] * (num_cut_init + 1)\n                # print('iw: ', iw, 'last: ', w_last_cot_pos)\n\n            else:\n                # 1\u3064\u3057\u304b\u52d5\u304b\u3057\u3066\u306a\u3044\u5834\u5408\u306f\u571f\u53f0\u7121\u7406\u306a\u306e\u3067\u6b21\u306eh_cut\u306b\n                valid = False\n                break\n        \n        else:\n            iw += 1\n    \n    if valid:\n        ans = min(ans, num_cut)\n    # print(num_cut)\n\nprint(ans)\n", "from itertools import product\n\n\ndef makelist(BIT):\n    LIST, tmp = [], s[0]\n    for si, bi in zip(s[1:], BIT):\n        if bi == 1:\n            LIST.append(tmp)\n            tmp = si[:]\n        elif bi == 0:\n            tmp = [t + sij for t, sij in zip(tmp, si)]\n    else:\n        LIST.append(tmp)\n    return LIST\n\n\ndef solve(LIST):\n    COST, cnt = 0, [li[0] for li in LIST]\n    if any(num > k for num in cnt):\n        return h * w\n    for j in range(1, w):\n        tmp = [t + li[j] for t, li in zip(cnt, LIST)]\n        if any(num > k for num in tmp):\n            COST += 1\n            cnt = [li[j] for li in LIST]\n        else:\n            cnt = tmp[:]\n    return COST\n\n\nh, w, k = list(map(int, input().split()))\ns = [[int(sij) for sij in input()] for _ in range(h)]\n\nans = h * w\nfor bit in product([0, 1], repeat=(h - 1)):\n    numlist = makelist(bit)\n    ans = min(ans, solve(numlist) + sum(bit))\nprint(ans)\n", "import sys\nfrom itertools import product\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nH, W, K = list(map(int, readline().split()))\nS = [list(map(int, list(readline().rstrip()))) for _ in range(H)]\n\nanswer = 10 ** 10\nfor i in product((0, 1), repeat=H - 1):\n    cnt = sum(i)\n    if cnt >= answer:\n        continue\n    cuts = []\n    cuts.append(S[0].copy())\n    for j in range(H - 1):\n        if i[j] == 1:\n            cuts.append(S[j + 1].copy())\n        else:\n            tmp1 = cuts[-1]\n            tmp2 = S[j + 1]\n            for k in range(W):\n                tmp1[k] += tmp2[k]\n    for j in cuts:\n        if any(k > K for k in j):\n            break\n    else:\n        h = len(cuts)\n        tmp = [0] * h\n\n        for j in range(W):\n            for k in range(h):\n                tmp[k] += cuts[k][j]\n            for k in tmp:\n                if k > K:\n                    cnt += 1\n                    tmp = [cuts[l][j] for l in range(h)]\n                    break\n        if cnt < answer:\n            answer = cnt\n\nprint(answer)\n", "import sys\nreadline = sys.stdin.readline\n\nH,W,K = map(int,readline().split())\ngrid = [None] * (H+1)\ngrid[0] = [0] * (W+1)\nfor i in range(1,H+1):\n  grid[i] = [0] + list(map(int,list(input())))\n  \n# \u4e8c\u6b21\u5143\u7d2f\u7a4d\u548c\u3067\u30c1\u30e7\u30b3\u30ec\u30fc\u30c8\u306e\u6570\u3092\u7ba1\u7406\n# \u76f4\u524d\u306b\u9078\u3093\u3060\u30c1\u30e7\u30b3\u306eY\u5ea7\u6a19\u3092p,X\u5ea7\u6a19\u3092q\u3068\u3059\u308b\u3068\u3001\n# \u30c1\u30e7\u30b3\u30ec\u30fc\u30c8\u306e\u6570\u3092O(1)\u3067\u6c42\u3081\u3089\u308c\u308b\n# \u6700\u521d\u306b\u7a7a\u884c\u3092\u5165\u308c\u3066\u3044\u308b\u306e\u30671-index\u3067\u3002\n\nfor i in range(len(grid)-1):\n  for j in range(len(grid[i])):\n    grid[i+1][j] = grid[i][j] + grid[i+1][j]\n\nfor i in range(len(grid)):\n  for j in range(len(grid[i])-1):\n    grid[i][j+1] = grid[i][j] + grid[i][j+1]\n  \ndef get_choco_cnt(i,j,p,q):\n  return grid[i][j] - grid[i][q] - grid[p][j] + grid[p][q]\n  \n# H\u304c10\u3068\u5c11\u306a\u3044\u306e\u3067\u3001\u5207\u308b\u5834\u62409\u7b87\u6240\u3092\u3059\u3079\u3066\u8a66\u3057\u3066\u30822^9 = 512\u901a\u308a\n# \u3059\u3079\u3066\u306b\u5bfe\u3057\u3066\u3001W\u306e\u3069\u3053\u3092\u5207\u308b\u304b\u3092\u6c42\u3081\u308b\u3002\n# \u4e8c\u5206\u63a2\u7d22\u306a\u3089\u3000O(2^(H-1) * (log W * H)) = \u7d0451200\n# \u7dda\u5f62\u63a2\u7d22\u3067\u3082\u3000O(2^(H-1) * WH) = 5,120,000\n\ndef isOk(x,lastq,cond,K,H,W):\n  # x\u3067\u5207\u3063\u305f\u3068\u304d\u3001i\u3067\u5206\u5272\u3055\u308c\u305f\u3059\u3079\u3066\u306e\u9818\u57df\u306e\u6570\u304cK\u4ee5\u4e0b\u306b\u306a\u308c\u3070OK\n  lastp = 0 # H\u3092\u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\n  for j in range(H-1):\n    if (cond >> j) & 1: # j+1\u3067\u5207\u308b\n      if get_choco_cnt(j+1,x,lastp,lastq) > K:\n        return False\n      lastp = j+1\n  # \u6700\u5f8c\u306b\u5207\u3063\u305f\u5834\u6240\u304b\u3089\u3001\u6700\u5f8c\u307e\u3067\n  if get_choco_cnt(H,x,lastp,lastq) > K:\n    return False\n  return True\n  \ndef decide_cut(cond,lastq,K,H,W):\n  ok = lastq\n  ng = W+1\n  while abs(ok - ng) > 1:\n    mid = abs(ok + ng) // 2\n    if isOk(mid,lastq,cond,K,H,W):\n      ok = mid\n    else:\n      ng = mid\n  return ok\n\nans = 10000\nfor cond in range(2 ** (H-1)):\n  cut_num = (bin(cond)[2:]).count(\"1\") # \u30ab\u30c3\u30c8\u3057\u305f\u56de\u6570\n  lastq = 0 # \u6700\u5f8c\u306b\u30ab\u30c3\u30c8\u3057\u305f\u5834\u6240\n  while lastq < W+1:\n    new_lastq = decide_cut(cond,lastq,K,H,W)\n    if new_lastq == W:\n      break\n    if new_lastq == lastq:\n      cut_num = 10000\n      break\n    cut_num += 1\n    lastq = new_lastq\n  if ans > cut_num:\n    ans = cut_num\nprint(ans)", "# coding: utf-8\nfrom itertools import combinations as combs\n\nH,W,K = list(map(int, input().split()))\narr = []\nfor i in range(H):\n  arr.append(list(map(int, list(input()))))\n\ndef cut_sum(arr, x1, x2, y):\n  ret = 0\n  for i in range(x1, x2):\n    ret += arr[i][y]\n  return ret\n\nrow_idxes = list(range(1,H))\nmin_val = float('inf')\n\nfor n_rows in range(H):\n  for row_set in combs(row_idxes, n_rows):\n    count = len(row_set)\n    row_lines = [0] + list(row_set)+ [H]\n    col1, col2 = 0, 1\n    sums = [0] * (len(row_lines) - 1)\n    while col2 <= W:\n      row1 = 0\n      for box, row2 in enumerate(row_lines[1:]):\n        sums[box] += cut_sum(arr, row1, row2, col2-1)\n        if sums[box] > K:\n          if (col2 - col1) == 1:\n            count = float('inf')\n            break\n          count += 1\n          col1 = col2 - 1\n          col2 -= 1\n          sums = [0] * (len(row_lines) - 1)\n          break\n        row1 = row2\n      if count >= min_val:\n        break\n      col2 += 1\n    \n    if min_val > count:\n      min_val = count\nprint(min_val)", "import sys\ndef input():\n    return sys.stdin.readline()[:-1]\nh,w,k=list(map(int,input().split()))\ns = []\nfor i in range(h):\n    str=input()\n    tmp=[]\n    for j in range(w):\n        if str[j]==\"0\":\n            tmp.append(0)\n        else:\n            tmp.append(1)\n    s.append(tmp)\n\ntdiv=2**(h-1)\n#import numpy as np\n#s = np.array(s)\nans = 100100100\nfor i in range(tdiv):\n    lis=[]\n    #tmp=np.zeros(w)\n    #tmp+=s[0,:]\n    tmp=[s[0][ii] for ii in range(w)]\n    cnt = 0\n    #print(tmp)\n    for j in range(h-1):\n        if (i>>j&1):\n            #tmp+=s[j+1,:]\n            tmp=[tmp[ii]+s[j+1][ii] for ii in range(w)]\n        else:\n            lis.append(tmp)\n            #tmp=np.zeros(w)\n            #tmp+=s[j+1,:]\n            tmp=[s[j+1][ii] for ii in range(w)]\n            cnt+=1\n    lis.append(tmp)\n    #lis = np.array(lis)\n    #clis=np.zeros(cnt+1)\n    clis=[0 for ii in range(cnt+1)]\n    #print(lis,cnt)\n    tmpcnt=cnt\n    for ind in range(w):\n        #if any(d>k for d in lis[:,ind]):\n        #if lis[:,ind].max()>k:\n        if max([lis[ii][ind] for ii in range(tmpcnt+1)])>k:\n            cnt=10010010\n            break\n        clis=[lis[ii][ind]+clis[ii] for ii in range(tmpcnt+1)]\n        #if clis.max()>k:\n        if max(clis)>k:\n            clis=[lis[ii][ind] for ii in range(tmpcnt+1)]\n            cnt+=1\n    #print(cnt)\n    ans = min(ans,cnt)\nprint(ans)\n#pypy\u3092\u4f7f\u304a\u3046!\n", "import numpy as np\nfrom itertools import product\nH, W, K = list(map(int, input().split()))\nG = np.array([list(map(int, list(input()))) for _ in range(H)])\n\nans = float('inf')\nfor pattern in product([0, 1], repeat=H - 1):\n    # \u30b9\u30e9\u30a4\u30b9\u3067\u6a2a\u65b9\u5411\u3078\u306e\u5272\u308a\u65b9\u3092\u8868\u73fe\u3059\u308b\n    div = [0] + [i for i, p in enumerate(pattern, start=1) if p == 1] + [10]\n\n    # \u6a2a\u65b9\u5411\u3078\u5272\u3063\u305f\u5f8c\u3001\u5404\u30d6\u30ed\u30c3\u30af\u306b\u3064\u3044\u3066\u7e26\u65b9\u5411\u306b\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u306e\u6570\u3092\u4fee\u6b63\n    rows = []\n    for i in range(len(div) - 1):\n        rows.append(np.sum(G[div[i]: div[i + 1]], axis=0))\n\n    # \u7e26\u65b9\u5411\u306b\u3059\u3067\u306bK\u500b\u3088\u308a\u591a\u3044\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u3069\u3046\u306b\u3082\u306a\u3089\u306a\u3044\n    if [r for r in rows if np.any(r > K)]:\n        continue\n\n    # \u7e26\u65b9\u5411\u306b\u8caa\u6b32\u306b\u5272\u3063\u3066\u3044\u304f\n    rows = [r.tolist() for r in rows]\n    tmp_ans = 0\n    counts = [0] * len(rows)\n    w = 0\n    while w < W:\n        for r in range(len(rows)):\n            counts[r] += rows[r][w]\n        if any([c > K for c in counts]):\n            counts = [0] * len(rows)\n            w -= 1\n            tmp_ans += 1\n        w += 1\n\n    # \u6a2a\u306b\u5272\u3063\u305f\u5206\u3092\u52a0\u7b97\n    tmp_ans += len(div) - 2\n    ans = min(ans, tmp_ans)\n\nprint(ans)\n", "#na-\nimport itertools\nH, W, K = map(int,input().split())\nS = [list(map(int,list(input()))) for _ in range(H)]\ndef check(k):\n    if k <= K:\n        return(True)\n    else:\n        return(False)\n        \nnoans = 0\ndef make_lst(i):\n    nonlocal noans, lst, havelst\n    temp = S[0][i]\n    for h in range(H-1):\n        if y[h]:\n            lst.append(temp)\n            temp = S[h+1][i]\n        else:\n            temp += S[h+1][i]\n    lst.append(temp)\n    if check(max(lst)):\n        havelst = 1\n    else:\n        noans = 1\n               \ndef nocut(i):\n    nonlocal cutnum, lst, havelst\n    prelst = []\n    temp = S[0][i]\n    j = 0\n    for h in range(H-1):\n        if y[h]:\n            lst[j] += temp\n            prelst.append(temp)\n            j += 1\n            temp = S[h+1][i]\n        else:\n            temp += S[h+1][i]\n    prelst.append(temp)\n    lst[-1] += temp\n    if check(max(lst)):\n        return(True)\n    else:\n        cutnum += 1\n        lst = prelst        \n                 \nans = float(\"inf\")\ncutlst = []    \nfor y in itertools.product((0, 1), repeat=H-1):\n    havelst = 0\n    lst = []\n    cutnum = sum(y)\n    for x in range(W):\n        if noans:\n            break\n        if havelst:\n            nocut(x)\n        else:\n            make_lst(x)\n    if noans==1:\n        noans = 0\n        continue\n    ans = min(cutnum, ans)\nprint(ans)", "import numpy as np\nfrom itertools import product\nH, W, K = map(int, input().split())\nG = np.array([list(map(int, list(input()))) for _ in range(H)])\n \nans = float('inf')\nfor pattern in product([0, 1], repeat=H - 1):\n    # \u30b9\u30e9\u30a4\u30b9\u3067\u6a2a\u65b9\u5411\u3078\u306e\u5272\u308a\u65b9\u3092\u8868\u73fe\u3059\u308b\n    div = [0] + [i for i, p in enumerate(pattern, start=1) if p == 1] + [10]\n \n    # \u6a2a\u65b9\u5411\u3078\u5272\u3063\u305f\u5f8c\u3001\u5404\u30d6\u30ed\u30c3\u30af\u306b\u3064\u3044\u3066\u7e26\u65b9\u5411\u306b\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u306e\u6570\u3092\u4fee\u6b63\n    rows = []\n    for i in range(len(div) - 1):\n        rows.append(np.sum(G[div[i]: div[i + 1]], axis=0))\n \n    # \u7e26\u65b9\u5411\u306b\u3059\u3067\u306bK\u500b\u3088\u308a\u591a\u3044\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u3069\u3046\u306b\u3082\u306a\u3089\u306a\u3044\n    if [r for r in rows if np.any(r > K)]:\n        continue\n \n    # \u7e26\u65b9\u5411\u306b\u8caa\u6b32\u306b\u5272\u3063\u3066\u3044\u304f\n    rows = [r.tolist() for r in rows]\n    tmp_ans = 0\n    counts = [0] * len(rows)\n    w = 0\n    while w < W:\n        for r in range(len(rows)):\n            counts[r] += rows[r][w]\n        if any([c > K for c in counts]):\n            counts = [0] * len(rows)\n            w -= 1\n            tmp_ans += 1\n        w += 1\n \n    # \u6a2a\u306b\u5272\u3063\u305f\u5206\u3092\u52a0\u7b97\n    tmp_ans += len(div) - 2\n    ans = min(ans, tmp_ans)\n \nprint(ans)", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    S = [list(map(int, list(input().strip(\"\\n\")))) for _ in range(H)]\n    sumS = [[0] * (W + 1) for _ in range(H + 1)]\n    for h in range(H):\n        for w in range(W):\n            sumS[h+1][w+1] = sumS[h+1][w] + sumS[h][w+1] - sumS[h][w] + S[h][w]\n    minK = 1000000000000\n    for h in range(2 ** (H - 1)):\n        count = 0\n        border = [0]\n        k = h\n        for i in range(H-1):\n            if k % 2 == 1: \n                border.append(i+1)\n                count += 1\n            k //= 2\n        border.append(H)\n        bN = len(border)\n        left = 0\n        ng = False\n        for right in range(1, W + 1):\n            for i in range(bN - 1):  \n                if sumS[border[i+1]][right] - sumS[border[i+1]][left] - sumS[border[i]][right] + sumS[border[i]][left] > K:\n                    if right - 1 == left: ng = True\n                    else: \n                        count += 1\n                        left = right - 1\n                    break\n            if ng: break \n        else: minK = min(minK, count)\n    print(minK)\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "\nINF = 1<<60\ndef resolve():\n    def judge(j):\n        for i in range(group):\n            cnt_Wchoco[i] += div_G[i][j]\n            if cnt_Wchoco[i] > K:\n                return False\n        return True\n\n    H, W, K = list(map(int, input().split()))\n    G = [list(map(int, input())) for _ in range(H)]\n\n    ans = INF\n    for bit in range(1<<(H-1)):\n        group = 0 # \u5206\u304b\u308c\u305f\u30d6\u30ed\u30c3\u30af\u6570\n        row = [0]*H\n        for i in range(H):\n            # \u5206\u5272\u30e9\u30a4\u30f3\n            row[i] = group\n            if bit>>i & 1:\n                group += 1\n        group += 1 # 1\u3064\u6298\u3063\u305f\u30892\u3064\u306b\u5206\u304b\u308c\u308b\u306e\u3067\u30d7\u30e9\u30b91, \u6298\u3089\u306a\u304b\u3063\u305f\u30891\u3064\n\n        # \u5206\u5272\u3057\u305f\u30d6\u30ed\u30c3\u30af\u3092\u5217\u65b9\u5411\u3067\u898b\u308b\n        div_G = [[0] * W for _ in range(group)]\n        for i in range(H):\n            for j in range(W):\n                div_G[row[i]][j] += G[i][j]\n\n        num = group-1\n        cnt_Wchoco = [0]*group\n        for j in range(W):\n            if not judge(j):\n                num += 1\n                cnt_Wchoco = [0] * group\n                if not judge(j):\n                    num = INF\n                    break\n        ans = min(ans, num)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef main():\n    h, w, k = ns()\n    mat = [list(input()) for _ in range(h)]\n\n    # if h == 1:\n    #     tmp = max(0, mat[0].count(\"1\") - 1)\n    #     print(tmp // k)\n    #     return\n\n    ans = INF\n    for i in range(2 ** (h - 1)):\n        cut = format(i, \"b\").count(\"1\")\n        row = cut + 1\n\n        cnt = [0 for _ in range(row)]\n\n        idx_dic = dict()\n        tmp_idx = 0\n        for j in range(h):\n            idx_dic[j] = tmp_idx\n            if i >> j & 1:\n                tmp_idx += 1\n\n        tmp_ans = cut\n        xi = 0\n        brkflg = True\n        while xi < w:\n            yi = 0\n            prev_brkflg = brkflg\n            brkflg = False\n            while yi < h:\n                if mat[yi][xi] == \"1\":\n                    cnt[idx_dic[yi]] += 1\n                    if cnt[idx_dic[yi]] > k:\n                        cnt = [0 for _ in range(row)]\n                        xi -= 1\n                        brkflg = True\n                        tmp_ans += 1\n                        break\n\n                yi += 1\n            if brkflg and prev_brkflg:\n                tmp_ans = INF\n                break\n            xi += 1\n        ans = min(ans, tmp_ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n  from collections import Counter\n  from collections import defaultdict\n  from collections import deque\n  from itertools import accumulate\n  from itertools import combinations\n  from itertools import permutations\n  from itertools import product\n  import sys\n  sys.setrecursionlimit(10**6)\n  readline = sys.stdin.readline\n  ints = lambda: map(int, readline().split())\n  floats = lambda: map(float, readline().split())\n  lli = lambda I, J: [[0] * J for _ in range(I)]\n  mod = 10**9+7\n\n  h, w, k = ints()\n  ans = h + w\n  s = [list(map(int, input())) for _ in range(h)]\n  for comb in product([False, True], repeat=h - 1):\n    divs = 0\n    a = [s[0][:]]\n    for row, isd in zip(s[1:], comb):\n      if isd:\n        a += [row[:]]\n        divs += 1\n      else:\n        for i in range(w):\n          a[divs][i] += row[i]\n    dh = divs + 1\n    ta = [list(i) for i in zip(*a)]\n    currow = ta[0]\n    imp = False\n    for row in ta[1:]:\n      if any([i > k for i in currow]):\n        imp = True\n        break\n      else:\n        temp = [i + j for i, j in zip(currow, row)]\n        if any([i > k for i in temp]):\n          currow = row\n          divs += 1\n        else:\n          currow = temp\n    if not imp:\n      ans = min(ans, divs)\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    H, W, K = NMI()\n    choco = [SI() for _ in range(H)]\n    ans = 100000\n    for case in range(2**(H-1)):\n        groups = [[0]]\n        for i in range(H-1):\n            if (case >> i) & 1:\n                groups[-1].append(i+1)\n            else:\n                groups.append([i+1])\n        white = [0] * len(groups)\n\n        is_badcase = False\n        cut = len(groups) - 1\n        for w in range(W):\n            diff = [0] * len(groups)\n            for gi, group in enumerate(groups):\n                for h in group:\n                    if choco[h][w] == \"1\":\n                        white[gi] += 1\n                        diff[gi] += 1\n\n            if max(white) <= K:\n                is_cont = True\n                continue\n\n            if max(diff) > K:\n                is_badcase = True\n                break\n\n            cut += 1\n            white = diff[:]\n            continue\n\n        if not is_badcase:\n            ans = min(ans, cut)\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import accumulate\n\nh,w,k = map(int,input().split())\ns = [list(map(int,\"\".join(input()))) for _ in range(h)]\n\nmin_split = 10**10\n\nfor i in range(2**(h-1)):\n    li = []\n\n    for j in range(h-1):\n        if (i >> j)&1:\n            li.append(j)\n    li.append(h-1)\n    lin = [0]*w\n    total = []\n\n    over = False\n\n    for l in range(h):\n        for m in range(w):\n            lin[m] += s[l][m]\n            if lin[m] > k:\n                over = True\n        if l in li:\n            total.append(lin)\n            lin = [0]*w\n\n    if over:\n        continue\n\n    now = 0\n    t = len(total)\n    count = t-1\n\n    for n in range(t):\n        total[n] = [0]+list(accumulate(total[n]))\n    for o in range(1,w+1):\n        for p in range(t):\n            if total[p][o]-total[p][now] > k:\n                now = o-1\n                count += 1\n                break\n\n    min_split = min(min_split,count)\n\nprint(min_split)", "import numpy as np\nimport itertools\nH, W, K = [int(_) for _ in input().split()]\nS = np.zeros((H + 1, W + 1), dtype=int)\nS[1:, 1:] = [[int(_) for _ in input()] for _ in range(H)]\ncum = S.cumsum(axis=0).cumsum(axis=1)\n# print(cum)\n\nans = 10**10\nfor bs in itertools.product([True, False], repeat=H - 1):\n    bs = [True] + list(bs) + [True]\n#     print(bs)\n    idxs = []\n    for i, b in enumerate(bs):\n        if b:\n            idxs += [i]\n    cum2 = np.array([cum[i2] - cum[i1] for i1, i2 in zip(idxs, idxs[1:])])\n    i = 0\n    cnt = sum(bs) - 3\n    while i < W:\n        di = min(\n            np.searchsorted(c[i + 1:] - c[i], K, side='right') for c in cum2)\n        if di == 0:\n            cnt = 10**10\n            break\n        i += di\n        cnt += 1\n    ans = min(ans, cnt)\nprint(ans)", "h, w, k = list(map(int, input().split()))\n\nchoco = [list(map(int, list(input()))) for i in range(h)]\n\nans = h + w + 1\n\nfor h_cut in range(2**(h-1)):\n    # \u4e0a\u4f4d\u30d3\u30c3\u30c8\u304c\u4e0a\u5074\u30021\u304c\u5207\u308b\u30010\u304c\u5207\u3089\u306a\u3044\n    num_cut_yoko = bin(h_cut).count(\"1\") # \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u306e\u500b\u6570\n    num_cut = num_cut_yoko\n    w_last_cut_pos = -1\n    valid = True\n\n    count_white = [0] * (num_cut_yoko + 1)\n    temp_dict = {}\n    idx = 0\n    temp_dict[0] = idx\n    for i in range(1, h):\n        # print('idx', 2 ** (-i+h-1) )\n        if h_cut & (2 ** (-i+h-1)):\n            idx += 1\n        # idx += h_cut & (2 ** (h-1) - i)\n        temp_dict[i] = idx\n    # print(temp_dict)\n\n    iw = 0\n    while iw < w:\n\n        for ih in range(h):\n            count_white[temp_dict[ih]] += choco[ih][iw]\n        # print(iw, count_white)\n\n        condition = max(count_white) > k\n        if condition:\n            if w_last_cut_pos < iw-1:\n                # \u3082\u3057\u305d\u3053\u3067\u5207\u3063\u3066k\u3092\u8d85\u3048\u308b\u306a\u3089\u3001\u305d\u306e\u624b\u524d\u3067\u5207\u308b\n                num_cut += 1\n                w_last_cut_pos = iw - 1\n                count_white = [0] * (num_cut_yoko + 1)\n                # print('iw: ', iw, 'last: ', w_last_cut_pos)\n\n            else:\n                # 1\u3064\u3057\u304b\u52d5\u304b\u3057\u3066\u306a\u3044\u306e\u306b\u3001K\u30de\u30b9\u3092\u8d85\u3048\u3066\u3057\u307e\u3063\u305f\u5834\u5408\u306f\u3001\u3053\u306e\u6a2a\u306e\u5207\u308a\u65b9\u3067\u306f\u9054\u6210\u4e0d\u53ef\u80fd\u306a\u306e\u3067\u6b21\u306eh_cut\u306b\n                valid = False\n                break\n        \n        else:\n            iw += 1\n    \n    if valid:\n        ans = min(ans, num_cut)\n    # print(num_cut)\n\nprint(ans)\n", "from itertools import product\n\n\ndef makelist(BIT):\n    LIST, tmp = [], s[0]\n    for si, bi in zip(s[1:], BIT):\n        if bi == 1:\n            LIST.append(tmp)\n            tmp = si\n        elif bi == 0:\n            tmp = [t + sij for t, sij in zip(tmp, si)]\n    else:\n        LIST.append(tmp)\n    return LIST\n\n\ndef solve(LIST):\n    COST, cnt = 0, [li[0] for li in LIST]\n    if any(num > k for num in cnt):\n        return h * w\n    for j in range(1, w):\n        tmp = [t + li[j] for t, li in zip(cnt, LIST)]\n        if any(num > k for num in tmp):\n            COST += 1\n            cnt = [li[j] for li in LIST]\n        else:\n            cnt = tmp[:]\n    return COST\n\n\nh, w, k = list(map(int, input().split()))\ns = [[int(sij) for sij in input()] for _ in range(h)]\n\nans = h * w\nfor bit in product([0, 1], repeat=(h - 1)):\n    numlist = makelist(bit)\n    ans = min(ans, solve(numlist) + sum(bit))\nprint(ans)\n", "from itertools import product\nimport numpy as np\nHWK,*sss = open(0).read().splitlines()\nH,W,K = map(int, HWK.split())\nsss = [list(map(int, list(ss))) for ss in sss]\nsss = np.cumsum(sss, axis=0)\n \nif H == 1 or W == 1:\n    print(0--sss[-1][-1]//K)\n    return\n \nans = float('inf')\nfor flgs in product([False, True], repeat=H-1):\n    cnt = sum(flgs)\n    tsss = sss[[*flgs, True]]\n    tsss = np.concatenate((tsss[:1], np.diff(tsss, axis=0)), axis=0).T\n \n    tmp = 0\n    succ = True\n    for cur in tsss:\n        new = tmp + cur\n        if new.max() <= K:\n            tmp = new\n        else:\n            cnt += 1\n            if cur.max() > K:\n                succ = False\n                break\n            else:\n                tmp = cur\n#     print(flgs)\n#     print(cnt, ans, tsss)\n    if succ:\n        ans = min(ans, cnt)\n \nprint(ans)", "import itertools\n\n\ndef main():\n    H, W, K = list(map(int, input().split(' ')))\n    S = [input() for _ in range(H)]\n    ans = (H - 1) * (W - 1)\n    for h_divs in itertools.product([0, 1], repeat=H-1):\n        # \u4f8b\uff1ah_patterns = [0, 0, 1, 2, 2] -> \u30c1\u30e7\u30b3\u30921\uff5e2\u30012\uff5e3\u756a\u76ee\u306e\u884c\u3067\u5206\u5272\n        h_patterns = [0] * H\n        for h in range(1, H):\n            h_patterns[h] = h_patterns[h - 1] + h_divs[h - 1]\n        # \u6a2a\u65b9\u5411\u306b\u306f h_patterns[-1] \u56de\u5272\u308b\n        div_cnt = h_patterns[-1]\n        # \u7e26\u65b9\u5411\u306b\u306fgreedy\u306b\u5272\u3063\u3066\u3044\u304f\n        white_cnt = [0] * (div_cnt + 1)\n        valid_div = True  # \u5404\u5217\u306b\u304a\u3044\u3066\u3001\u5358\u4f53\u3067\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u304cK\u500b\u3088\u308a\u591a\u3044\u30d6\u30ed\u30c3\u30af\u304c\u3042\u3063\u305f\u3089False\n        for w in range(W):\n            new_white_cnt = [0] * (div_cnt + 1)\n            for h in range(H):\n                if S[h][w] == '1':\n                    new_white_cnt[h_patterns[h]] += 1\n            if max(new_white_cnt) > K:\n                valid_div = False\n                break\n            should_div = False\n            for r in range(len(white_cnt)):\n                if white_cnt[r] + new_white_cnt[r] > K:\n                    should_div = True\n                    break\n            if should_div:\n                div_cnt += 1\n                for r in range(len(white_cnt)):\n                    white_cnt[r] = new_white_cnt[r]\n            else:\n                for r in range(len(white_cnt)):\n                    white_cnt[r] += new_white_cnt[r]\n        if valid_div:\n            ans = min(ans, div_cnt)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ndef solve():\n    input = sys.stdin.readline\n    H, W, K = map(int, input().split())\n    S = [input().strip(\"\\n\") for _ in range(H)]\n    Ans = 10 ** 20\n    Wcount = [[0 for _ in range(W + 1)] for _ in range(H + 1)]\n    for h in range(H):\n        for w in range(W):\n            Wcount[h+1][w+1] = Wcount[h][w + 1] + Wcount[h + 1][w] - Wcount[h][w] + int(S[h][w])\n        \n            \n    #print(Wcount)\n    Ans = H * W + 1\n    for i in range(2 ** (H - 1)):\n        B = [0]\n        d = i\n        Hcount = 0\n        for j in range(H - 1):\n            if d % 2 == 1:\n                B.append(j + 1)\n                Hcount += 1\n            d //= 2\n        B.append(H)\n        leftbound = 0\n        TotalBound = Hcount\n        NG = False\n        for w in range(1, W+1):\n            for b in range(Hcount + 1):\n                if Wcount[B[b+1]][w] - Wcount[B[b+1]][leftbound] - Wcount[B[b]][w] + Wcount[B[b]][leftbound] > K:\n                    if leftbound + 1 == w: \n                        NG = True\n                    else:\n                        TotalBound += 1\n                        leftbound = w - 1\n                    break\n            if NG: break\n        else: Ans = min(TotalBound, Ans)\n        #print(i, B, TotalBound)\n    print(Ans)\n\n    return 0\n\ndef __starting_point():\n    solve()\n__starting_point()", "H, W, K = map(int, input().split())\nS = []\nfor _ in range(H):\n  S.append(input())\nhsummation = [[int(S[0][k])]for k in range(W)]\nfor k in range(W):\n  for j in range(1, H):\n    hsummation[k].append(hsummation[k][j-1] + int(S[j][k]))\n#print(hsummation)\nans = float('inf')\nanskouho = 0\nh = 2**(H-1)\nfor j in range(2**(H-1)):\n  h -= 1\n  binh = \"0\"*(H-len(str(bin(h)))+1)+str(bin(h))[2:]\n  hlist=[]\n  for k in range(H-1):\n    if binh[-k-1] == '1':\n      hlist.append(k)\n  hlist.append(-1)\n  #print(hlist)\n  anskouho = len(hlist)-1\n  now = 0\n  while now < W:\n    counter = [0 for _ in range(len(hlist))]\n    while now < W:\n      for l in range(len(hlist)):\n        if l == 0:\n          counter[l] += hsummation[now][int(hlist[l])]\n          continue\n        else:\n          counter[l] += - hsummation[now][hlist[l-1]] + hsummation[now][hlist[l]]\n      if max(counter) > K:\n        anskouho += 1\n        break\n      else:\n        now += 1\n    if anskouho > ans:\n      break\n  else:\n    ans = min(ans, anskouho)\n \n      #print(counter)\n#print(anskouho)\nprint(ans)", "#!python3\n\nimport itertools\n\n\nINF = 10 ** 5\n\n# input\nH, W, K = list(map(int, input().split()))\nS = [[int(e) for e in input()] for _ in range(H)]\n\n\ndef solve(w, l):\n    n = len(l) + 1\n    ans = 0\n    if n == 1:\n        dp = 0\n        for j in range(W):\n            x = w[-1][j]\n            if x > K:\n                return INF\n            dp += x\n            if dp > K:\n                ans += 1\n                dp = x\n    else:\n        dp = [0] * n\n        for j in range(W):\n            x = [0] * n\n            b = False\n            for i in range(n):\n                if i == 0:\n                    x[i] = w[l[i]][j]\n                elif i == n - 1:\n                    x[i] = w[-1][j] - w[l[-1]][j]\n                else:\n                    x[i] = w[l[i]][j] - w[l[i-1]][j]\n                if x[i] > K:\n                    return INF\n                dp[i] += x[i]\n                if dp[i] > K:\n                    b = True\n            if b:\n                dp = x\n                ans += 1\n    return ans\n\n\ndef main():\n    w = [S[0]]\n    for i in range(1, H):\n        w.append([w[i-1][j] + S[i][j] for j in range(W)])\n\n    ans = INF\n    num_list = [i for i in range(H - 1)]\n    for i in range(H):\n        comb_list = itertools.combinations(num_list, i)\n        for l in comb_list:\n            ans = min(ans, i + solve(w, l))\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,w,k = list(map(int,input().split()));arr = [[int(i) for i in input()] for _ in range(h)]\n\nfrom itertools import product\nans = 2000\n\nfor i in product([True,False],repeat=(h-1)):\n    cut = sum(i)\n    splits = [0] * (cut+1)\n    splits[0] = arr[0][:]\n    tmp = 0\n    div = cut\n    for j in range(1,h):\n        if i[j-1]:\n            tmp += 1\n            splits[tmp] = arr[j][:]\n        else:\n            splits[tmp] = [splits[tmp][idx]+arr[j][idx] for idx in range(w)]\n    \n    check = 0\n    for j in splits:\n        check = max(check,max(j))\n    if check > k:\n        break\n    count = [splits[j][0] for j in range(cut+1)]\n    \n    for j in range(1,w):\n        addarr = [count[idx]+splits[idx][j] for idx in range(cut+1)]\n        if max(addarr) > k:\n            div += 1\n            count = [splits[idx][j] for idx in range(cut+1)]\n        else:\n            count = addarr[:]\n    ans = min(ans,div)\n        \nprint(ans)", "h, w, k = list(map(int, input().split()))\n\nchoco = [list(map(int, list(input()))) for i in range(h)]\n\nchoco_cumsum = [[0 for i in range(w)] for j in range(h)]\n\nfor i in range(h):\n    choco_cumsum[i][0] = choco[i][0]\n    for j in range(1, w):\n        choco_cumsum[i][j] = choco_cumsum[i][j-1] + choco[i][j]\n\nans = h + w + 1\n\nfor h_cut in range(2**(h-1)):\n    # \u4e0a\u4f4d\u30d3\u30c3\u30c8\u304c\u4e0a\u5074\u30021\u304c\u5207\u308b\u30010\u304c\u5207\u3089\u306a\u3044\n    num_cut_init = bin(h_cut).count(\"1\") # \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u306e\u500b\u6570\n    num_cut = num_cut_init\n    w_last_cut_pos = -1\n    valid = True\n\n    count_white = [0] * (num_cut_init + 1)\n    temp_dict = {}\n    idx = 0\n    temp_dict[0] = idx\n    for i in range(1, h):\n        # print('idx', 2 ** (-i+h-1) )\n        if h_cut & (2 ** (-i+h-1) ):\n            idx += 1\n        # idx += h_cut & (2 ** (h-1) - i)\n        temp_dict[i] = idx\n    # print(temp_dict)\n\n    iw = 0\n    while iw < w:\n\n        for ih in range(h):\n            count_white[temp_dict[ih]] += choco[ih][iw]\n        # print(iw, count_white)\n\n        condition = max(count_white) > k\n        if condition:\n            if w_last_cut_pos < iw-1:\n                # \u3082\u3057\u305d\u3053\u3067\u5207\u3063\u3066k\u3092\u8d85\u3048\u308b\u306a\u3089\u3001\u305d\u306e\u624b\u524d\u3067\u5207\u308b\n                num_cut += 1\n                w_last_cut_pos = iw - 1\n                count_white = [0] * (num_cut_init + 1)\n                # print('iw: ', iw, 'last: ', w_last_cut_pos)\n\n            else:\n                # 1\u3064\u3057\u304b\u52d5\u304b\u3057\u3066\u306a\u3044\u306e\u306b\u3001K\u30de\u30b9\u3092\u8d85\u3048\u3066\u3057\u307e\u3063\u305f\u5834\u5408\u306f\u3001\u3053\u306e\u6a2a\u306e\u5207\u308a\u65b9\u3067\u306f\u9054\u6210\u4e0d\u53ef\u80fd\u306a\u306e\u3067\u6b21\u306eh_cut\u306b\n                valid = False\n                break\n        \n        else:\n            iw += 1\n    \n    if valid:\n        ans = min(ans, num_cut)\n    # print(num_cut)\n\nprint(ans)\n", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = list(map(int, readline().split()))\n    S = [list(map(int, readline().strip())) for j in range(H)]\n\n    white = 0\n    for line in S:\n        white += sum(line)\n\n    if white <= K:\n        print((0))\n        return\n\n    # \u6a2a\u7dda\u306e\u6c7a\u3081\u65b9\u3092\u5168\u63a2\u7d22\n    ans = 10**5\n    for pattern in range(2**(H-1)):\n        # \u521d\u671f\u5316\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [[0]*W]*(ly + 1)\n        line = 0\n        for i in range(H):\n            y[line] = [y[line][j] + S[i][j] for j in range(W)]\n            if (pattern >> i) & 1:\n                line += 1\n\n        # \u5404\u5217\u306e\u5024\u3092\u52a0\u7b97\u3057\u3066\u3044\u304f\n        count = [0]*(ly + 1) \n        for col in zip(*y):\n            # K\u3088\u308a\u5927\u304d\u3044\u5024\u3092\u52a0\u7b97\u3059\u308b\u5834\u5408\u306f\u4e0d\u6210\u7acb\n            if any(a > K for a in col):\n                impossible = True\n                break\n            for i, a in enumerate(col):\n                count[i] += a\n                # \u548c\u304cK\u3088\u308a\u5927\u304d\u3051\u308c\u3070\u30ab\u30c3\u30c8\u6570\u3092\u5897\u3084\u3059\n                if count[i] > K:\n                    x += 1\n                    count = list(col) \n                    break\n            if x + ly > ans:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n\n        ans = min(ans, x + ly)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nh, w, k = map(int, input().split())\na = [list(map(int, list(input()))) for _ in range(h)]\n\nret = 100000\nfor i in range(2 ** (h-1)):\n    hi = [0] * h\n    for j in range(h-1):\n        hi[j+1] += hi[j] + (i >> j & 1)\n    cnt = max(hi)\n    pj = 0\n    x = []\n    while pj < w:\n        s = [0] * 10\n        fg = False\n        for j in range(pj, w):\n            for t in range(h):\n                s[hi[t]] += a[t][j]\n            if max(s)>k:\n                if j == pj:\n                    cnt = 100000\n                    fg = True\n                    break\n                else:\n                    x.append(j)\n                    cnt += 1\n                    pj = j\n                break\n            if j == w-1:\n                pj = w\n                break\n        if fg:\n            break\n    ret = min(ret, cnt)\nprint(ret)", "H,W,K = map(int,input().split())\nS = [input() for i in range(H)]\n\nans = H+W+9999\nfor b in range(1<<(H-1)):\n    mp = [0]\n    k = 0\n    for i in range(H-1):\n        if b&(1<<i):\n            k += 1\n        mp.append(k)\n    tmp = bin(b).count('1')\n    ws = [0] * H\n    muri = False\n    for col in zip(*S):\n        for i,c in enumerate(col):\n            if c == '1':\n                ws[mp[i]] += 1\n        if any(w > K for w in ws):\n            ws = [0] * len(mp)\n            for i,c in enumerate(col):\n                if c == '1':\n                    ws[mp[i]] += 1\n            if any(w > K for w in ws):\n                muri = True\n                break\n            tmp += 1\n        if muri:\n            break\n    if not muri:\n        ans = min(ans, tmp)\nprint(ans)", "from itertools import groupby, accumulate, product, permutations, combinations\ndef solve():\n    H, W, K = list(map(int, input().split()))\n    S = [input() for _ in range(H)]\n    cum = [[0]*(W+1) for _ in range(H+1)]\n    for i in range(1,H+1):\n        for j in range(1,W+1):\n            cum[i][j]=cum[i-1][j]+cum[i][j-1]-cum[i-1][j-1]+int(S[i-1][j-1])\n    ans = 2000\n    for p in product([0,1],repeat=H-1):\n        line = [0]\n        p = list(p)\n        cnt = sum(p)\n        for i in range(1,H):\n            if p[i-1]==1:\n                line.append(i)\n        line.append(H)\n        w_s = 0\n        w_e = 1\n        b = False\n        while w_e <= W:\n            for i in range(len(line)-1):\n                h_s = line[i]\n                h_e = line[i+1]\n                white = cum[h_e][w_e]+cum[h_s][w_s]-cum[h_e][w_s]-cum[h_s][w_e]\n                if white > K:\n                    if w_e == w_s+1:\n                        b = True\n                        break\n                    else:\n                        w_s = w_e-1\n                        cnt += 1\n                        break\n            if b==True:\n                break\n            w_e += 1\n        else:\n            ans = min(ans,cnt)\n    return ans\nprint((solve()))\n", "H,W,K=list(map(int,input().split()))\nS=[[int(x) for x in list(str(input()))] for _ in range(H)]\nT=[[0]*(W+1) for x in range(H+1)]\n\nfor h in range(H):\n  for w in range(W):\n    T[h][w]=T[h][w-1]+S[h][w]\n\nfor h in range(1,H):\n  for w in range(W):\n    T[h][w]=T[h][w]+T[h-1][w]\n\nm=(H-1)*(W-1)\nfor p in range(2**(H-1)):\n  D=[x for x in range(H-1) if p&(2**x)!=0]+[H-1]\n  c,b=0,-1\n  f=False\n  for w in range(W):\n    u=-1\n    for d in D:\n      if T[d][w]-T[u][w]-T[d][b]+T[u][b]>K:\n        if b==w-1:\n          f=True\n        c,b=c+1,w-1\n        break\n      u=d\n    if f==True:\n      break\n  else:\n    m=min(m,c+len(D)-1)\nprint(m)\n\n\n", "import sys\nimport numpy as np\nfrom itertools import combinations_with_replacement,product\ndef input(): return sys.stdin.readline().rstrip()\n\ndef culc(array,k,count):\n    array=array.T\n    cuts=np.zeros(array.shape[1])\n    for i in range(array.shape[0]):\n        if any(array[i]>k):\n            return 10**6\n        elif any(array[i]+cuts>k):\n            cuts=array[i]\n            count+=1\n        else:\n            cuts+=array[i]\n    return count\n\n\ndef main():\n    h,w,k=map(int, input().split())\n    choco=np.zeros((h,w))\n    for i in range(h):\n        choco[i]=list(input())\n    ans=10**6\n    choco=choco.astype(np.int64)\n    for bit in product([0,1],repeat=h-1):\n        if sum(bit)>=ans:\n            break\n        chocos=choco.copy()\n        cut=chocos[0].reshape([1,w])\n        for i in range(h-1):\n            if bit[i]==1:\n                cut=np.concatenate([cut,chocos[i+1].reshape([1,w])])\n            else:\n                cut[-1]+=chocos[i+1]\n        ans=min(ans,culc(cut,k,sum(bit)))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    INF = 10**9\n\n    H, W, K = map(int, input().split())\n    chocolate = [ input() for _ in range(H) ]\n    \n    loop_H = range(H)\n    loop_W = range(W)\n    min_cut = INF-1\n    for div in range(1 << (H-1)):\n        # \u6a2a\u5272\u308a\u3067\u30b0\u30eb\u30fc\u30d7\u5206\u3051\n        group = [[]]\n        group_number = 0\n        for i in loop_H:\n            group[group_number].append(i)\n            if div >> i & 1:\n                group.append([])\n                group_number += 1\n        # \u7e26\u306b\u5207\u3063\u3066\u3044\u304f\n        cut = group_number\n        zeros = [0] * len(group)\n        cnt = zeros.copy()\n        w = 0\n        while w < W:\n            now = zeros.copy()\n            for g in range(len(group)):\n                for i in group[g]:\n                    if chocolate[i][w] == '1':\n                        now[g] += 1\n                if now[g] > K:\n                    cut = INF\n                    break\n                if cnt[g] + now[g] > K:\n                    cut += 1\n                    w -= 1\n                    cnt = zeros.copy()\n                    break\n                cnt[g] += now[g]\n            w += 1\n        if cut < min_cut:\n            min_cut = cut\n    print(min_cut)\n\nmain()", "from operator import add\n\nINF = 10**6\n\nH, W, K = list(map(int, input().split()))\nAss = [list(map(int, input().rstrip())) for _ in range(H)]\n\ndef check(chocoss):\n    if max(list(map(max, chocoss))) > K:\n        return INF\n\n    L = len(chocoss)\n    num = 0\n    Bs = [0] * L\n    for j in range(W):\n        for i in range(L):\n            if Bs[i] + chocoss[i][j] > K:\n                num += 1\n                Bs = [chocoss[i][j] for i in range(L)]\n                break\n        else:\n            for i in range(L):\n                Bs[i] += chocoss[i][j]\n\n    return num\n\nans = INF\nfor ptn in range(1<<(H-1)):\n    chocoss = [Ass[0]]\n    num = 0\n    for i in range(H-1):\n        if (ptn>>i) & 1:\n            chocoss.append(Ass[i+1])\n            num += 1\n        else:\n            chocoss[-1] = list(map(add, chocoss[-1], Ass[i+1]))\n\n    num += check(chocoss)\n    if num < ans:\n        ans = num\n\nprint(ans)\n", "import numpy as np\nimport itertools\nH, W, K = [int(_) for _ in input().split()]\nS = np.zeros((H + 1, W + 1), dtype=int)\nS[1:, 1:] = [[int(_) for _ in input()] for _ in range(H)]\ncum = S.cumsum(axis=0).cumsum(axis=1)\n#sum(a,b -> x,y) (1-indexed)\n#cum[x][y]+cum[a-1][b-1]-cum[a-1][y]-cum[x][b-1]\nans = 10**10\nfor bs in itertools.product([True, False], repeat=H - 1):\n    bs = [True] + list(bs) + [True]\n    idxs = []\n    for i, b in enumerate(bs):\n        if b:\n            idxs += [i]\n    cum2 = np.array([cum[i2] - cum[i1] for i1, i2 in zip(idxs, idxs[1:])])\n    i = 0\n    cnt = sum(bs) - 3\n    while i < W:\n        di = min(\n            np.searchsorted(c[i + 1:] - c[i], K, side='right') for c in cum2)\n        if di == 0:\n            cnt = 10**10\n            break\n        i += di\n        cnt += 1\n    ans = min(ans, cnt)\nprint(ans)\n", "# coding: utf-8\nimport sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nH, W, K = lr()\nS = np.array([list(map(int, sr())) for _ in range(H)])\nScum = np.cumsum(S, axis=1)\nINF = 10 ** 10\nanswer = INF\nfor pattern in range(1<<H-1):\n    cnt = 0\n    Tcum = Scum.copy()\n    for i in range(H-1):\n        if pattern>>i & 1:  # \u5207\u308c\u76ee\n            cnt += 1\n        else:\n            Tcum[i+1] += Tcum[i]\n    prev = -1\n    w = 0\n    Tcum = Tcum.tolist()\n    while w < W:\n        cut = False\n        for i in range(H):\n            if Tcum[i][w] - (Tcum[i][prev] if prev >= 0 else 0) > K:\n                cut = True\n                break\n        if cut:\n            if prev == w - 1:  # 1\u5217\u3067K\u3092\u30aa\u30fc\u30d0\u30fc\n                break\n            cnt += 1\n            prev = w - 1\n        else:\n            w += 1\n    else:\n        answer = min(answer, cnt)\n\nprint(answer)\n", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = list(map(int, readline().split()))\n    S = [list(map(int, readline().strip())) for j in range(H)]\n\n    white = 0\n    for line in S:\n        white += sum(line)\n\n    if white <= K:\n        print((0))\n        return\n\n    # \u6a2a\u7dda\u306e\u6c7a\u3081\u65b9\u3092\u5168\u63a2\u7d22\n    ans = 10**5\n    for pattern in range(2**(H-1)):\n        # \u521d\u671f\u5316\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [S[0]]\n        line = 0\n        for i in range(1,H):\n            if (pattern >> i-1) & 1:\n                line += 1\n                y.append(S[i])\n            else:\n                y[line] = [y[line][j] + S[i][j] for j in range(W)]\n\n        # \u5404\u5217\u306e\u5024\u3092\u52a0\u7b97\u3057\u3066\u3044\u304f\n        count = [0]*(ly + 1) \n        for j in range(W):\n            for i in range(line+1):\n                if y[i][j] > K :\n                    impossible = True\n                    break\n\n                count[i] += y[i][j]\n                if count[i] > K:\n                    x += 1\n                    for i in range(line+1):\n                        count[i] = y[i][j] \n                    break\n            if x + ly > ans or impossible:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n\n        ans = min(ans, x + ly)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h,w,k=map(int,input().split())\ng=[[int(c) for c in input()] for _ in range(h)]\ns=[[0]*(w+1) for _ in range(h+1)]\nfor i in range(h):\n  for j in range(w):\n    s[i+1][j+1]=s[i+1][j]+s[i][j+1]+g[i][j]-s[i][j]\nssum=lambda u,d,l,r:s[d][r]-s[u][r]-s[d][l]+s[u][l]\na=h+w\nfor i in range(2**(h-1)):\n  e=[]\n  u=d=ch=0\n  for j in range(h):\n    d+=1\n    if i>>j&1<1:\n      e+=[(u,d)]\n      if d<h:\n        ch+=1\n        u=d\n  l=r=cw=0\n  while r<w:\n    if max(ssum(u,d,l,r+1) for u,d in e)>k:\n      if r==l: break\n      cw+=1\n      l=r\n    r+=1\n  else:\n    a=min(a,ch+cw)\nprint(a)", "h,w,k = map(int,input().split())\ns = [list(map(int,input().strip())) for i in range(h)]\nfrom copy import deepcopy\n\nss = deepcopy(s)\nfor i in range(h):\n    for j in range(w-1):\n        ss[i][j+1] += ss[i][j]\n\n\ndef gru_hol(HOL): # \u30bb\u30c3\u30c8\u304b\u3089\u5207\u308a\u65b9\u3092\u4f5c\u308b\n    groups_a = []\n    group_a = [0]\n    for i in range(h-1):\n        if(HOL[i] == 1):\n            groups_a.append(group_a)\n            group_a = [i+1]\n        else:\n            group_a.append(i+1)\n    groups_a.append(group_a)\n    return groups_a\n\ndef nex_hol(HOL): #\u6b21\u306e\u30bb\u30c3\u30c8\u3092\u4f5c\u308b\n    for j in range(h-1):\n        if(HOL[j] == 0):\n            HOL[j] = 1\n            for k in range(0,j):\n                HOL[k] = 0\n            break\n    return HOL\n\ndef cutsum(grp,lscut,nxcut): #group\u306elastcut~nextcut\u306e\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u3092\u6570\u3048\u308b\n    count = 0\n    for i in grp:\n        if(lscut != 0):\n            count = count + ss[i][nxcut-1] - ss[i][lscut-1]\n        else:\n            count += ss[i][nxcut-1] \n    return count\n\ndef cutcheck(grp_a,lscut_a): #\u5207\u3063\u3066\u3082\u30c0\u30e1\u304b\u30c1\u30a7\u30c3\u30af\n    ct_a = 0\n    for i in grp_a:\n        ct_a += s[i][lscut_a]\n    if(ct_a > k):\n        return False\n    else:\n        return True\n\nmin_cut = h + w - 2\nhol = [0]*(h-1)\nfor i in range(2**(h-1)):\n    fl_ag = 0\n    lastcut = 0\n    cuts = 0 #\u5207\u308b\u56de\u6570\n    groups = gru_hol(hol) #groups\u3092\u4f5c\u308b\n    for j in range(1,w):\n        flag = 0\n        for group in groups:\n            if(cutsum(group,lastcut,j+1) > k):\n                if(cutcheck(group,lastcut) == False):\n                    fl_ag = 1 #group\u304b\u3089\u3084\u308a\u76f4\u3057\n                    break\n                else:\n                    flag = 1\n        if(fl_ag == 1):\n            break\n        if(flag == 1):\n            cuts += 1\n            lastcut = j\n\n    if(cutcheck(group,w-1) == True):\n        min_cut = min(min_cut,cuts+sum(hol))\n    nex_hol(hol)\n\nprint(min_cut)", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef solve():\n    H, W, K = Scanner.map_int()\n    S = Scanner.string_list(H)\n    ans = int(1e15)\n    for i in range(1 << (H - 1)):\n        cut = 0\n        pc = 1\n        whites = [[0 for _ in range(W)] for _ in range(H)]\n        for j in range(H - 1):\n            for w in range(W):\n                whites[cut][w] += S[j][w] == '1'\n            if i >> j & 1:\n                cut += 1\n                pc += 1\n        for w in range(W):\n            whites[cut][w] += S[-1][w] == '1'\n        flag = True\n        for line in whites:\n            for cnt in line:\n                if cnt > K:\n                    flag = False\n        if not flag:\n            continue\n        cnt = [0 for _ in range(pc)]\n        for w in range(W):\n            flag = True\n            for j in range(pc):\n                if cnt[j] + whites[j][w] > K:\n                    flag = False\n            if not flag:\n                cnt = [0 for _ in range(pc)]\n                cut += 1\n            for j in range(pc):\n                cnt[j] += whites[j][w]\n        ans = min(ans, cut)\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\ndef resolve():\n    H, W, K = lr()\n    S = []\n    for i in range(H):\n        S.append([int(s) for s in sr()])\n    ans = 2000\n    idx = [0]*H\n    for div in range(1<<(H-1)):\n        g = 0\n        for i in range(H):\n            idx[i] = g\n            if div>>i&1:\n                g += 1\n        g += 1\n        c = [[0]*W for i in range(g)]\n        for i in range(H):\n            for j in range(W):\n                c[idx[i]][j] += S[i][j]\n        ok = True\n        for i in range(g):\n            for j in range(W):\n                if c[i][j] > K:\n                    ok = False\n        if not ok:\n            continue\n        num = g-1\n        now = [0]*g\n        def add(j):\n            for i in range(g):\n                now[i] += c[i][j]\n            for i in range(g):\n                if now[i] > K:\n                    return False\n            return True\n        for j in range(W):\n            if not add(j):\n                num += 1\n                now = [0]*g\n                add(j)\n        ans = min(ans, num)\n    print(ans)\nresolve()", "import sys\ninput = sys.stdin.readline\n\nH,W,K=list(map(int,input().split()))\nS = [input().rstrip() for _ in range(H)]\n\nbit = 2**(H-1)\nans = 1010\nfor bi in range(bit):\n    w = 0\n    cnt = bin(bi).count('1')\n    counter_1 = [0]*H\n    \n    while w <W:\n        i=0\n        for h in range(H):\n            if S[h][w] == '1':\n                counter_1[i]+=1\n                if counter_1[i]>K:\n                    cnt +=1\n                    counter_1 = [0]*H\n                    w -=1\n                    break\n            if bi >>h & 1:\n                i+=1\n        w+=1\n        if cnt>=ans:\n            break\n    ans = min(ans,cnt)\nprint(ans)\n", "def add(in1, in2):\n    return [a + b for a, b in zip(in1, in2)]\n \ndef split(ar, k, w):\n    a = 0\n    if max(max(ar)) > k:\n      return -1\n    tm = ar[0]\n    for i in range(1, w):\n        tm = add(tm, ar[i])\n        if max(tm) > k:\n            a += 1\n            tm = ar[i]\n    return a        \n \nh, w, k = list(map(int, input().split()))\ns = [[int(i) for i in input()] for j in range(h)]\nans = h*w\n \nfor i in range(2**(h-1)):\n    data = []\n    temp = s[0]\n    sp = bin(i+2**h)[4:]\n    if ans < sp.count(\"1\"):\n        continue\n    for j in range(1, h):\n        if sp[j-1] == \"0\":\n            temp = add(temp, s[j])\n        else:\n            data.append(temp)\n            temp = s[j]\n    data.append(temp)\n    ans_ = split([list(x) for x in zip(*data)], k, w)\n    if ans_ == -1:\n        continue\n    ans_ += sp.count(\"1\")\n    if ans > ans_:\n        ans = ans_\nprint(ans)\n", "import itertools\nh, w, k = map(int, input().split())\n\na = []\nfor i in range(h):\n  s = input()\n  a.append(s)\n\ns = [[0 for i in range(w)] for i in range(h)]\n\nans = h+w\nfor grid in itertools.product([0,1], repeat=h-1):\n  ary = [[0]]\n  for i in range(h-1):\n    if grid[i] == 1:\n      ary.append([i+1])\n    else:\n      ary[-1].append(i+1)\n  # print (grid, ary)\n  wk = 0\n  for i in grid:\n    if i == 1:\n      wk += 1\n  # print (wk)\n  cnt = [0] * len(ary)\n  for j in range(w):\n    for ii, g in enumerate(ary):\n      for b in g:\n        if a[b][j] == '1':\n          cnt[ii] += 1\n    if any(W > k for W in cnt):\n      wk += 1\n      cnt = [0] * len(ary)\n      for ii, g in enumerate(ary):\n        for jj in g:\n          if a[jj][j] == '1':\n            cnt[ii] += 1\n      if any(W > k for W in cnt):\n        wk = h+w\n        break\n  ans = min(ans, wk)\nprint (ans)", "import itertools\n\n# input\nH, W, K = list(map(int, input().split()))\nS = [list(map(int, input())) for _ in range(H)]\n\n# process\nans = H*W\n\nfor divr in range(1<<(H-1)):    # \u6a2a\u65b9\u5411\u306e\u5206\u5272\u3092\u7dcf\u5f53\u305f\u308a\n    row = 0\n    Sr = [[S[0][i] for i in range(W)]]\n    for i in range(1, H):\n        if 1&(divr>>i-1):\n            row += 1\n            Sr.append([S[i][j] for j in range(W)])\n        else:\n            Sr[row] = [Sr[row][j]+S[i][j] for j in range(W)]\n\n    # \u7e26\u65b9\u5411\u306e\u5206\u5272\u3092\u52a0\u7b97\n    cnt = [0]*(row+1)\n    ans_ = row\n    flg = True\n    for i in range(W):\n        for j in range(row+1):\n            if Sr[j][i] > K:\n                flg = False\n                break\n            cnt[j] += Sr[j][i]\n            if cnt[j] > K:\n                ans_ += 1\n                cnt = [0]*(row+1)\n                for l in range(row+1):\n                    cnt[l] += Sr[l][i]\n                break\n\n        if ans_ >= ans or not flg:\n            break\n\n    if flg:\n        ans = min(ans, ans_)\n\n# output\nprint(ans)\n", "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: list(map(int, sys.stdin.readline().split()))\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef main():\n    h, w, k = ns()\n    mat = [list(input()) for _ in range(h)]\n\n    if h == 1:\n        tmp = max(0, mat[0].count(\"1\") - 1)\n        print((tmp // k))\n        return\n\n    ans = INF\n    for i in range(2 ** (h - 1)):\n        cut = format(i, \"b\").count(\"1\")\n        row = cut + 1\n\n        cnt = [0 for _ in range(row)]\n\n        idx_dic = dict()\n        tmp_idx = 0\n        for j in range(h):\n            idx_dic[j] = tmp_idx\n            if i >> j & 1:\n                tmp_idx += 1\n\n        tmp_ans = cut\n        xi = 0\n        brkflg = True\n        while xi < w:\n            yi = 0\n            prev_brkflg = brkflg\n            brkflg = False\n            while yi < h:\n                if mat[yi][xi] == \"1\":\n                    cnt[idx_dic[yi]] += 1\n                    if cnt[idx_dic[yi]] > k:\n                        cnt = [0 for _ in range(row)]\n                        xi -= 1\n                        brkflg = True\n                        tmp_ans += 1\n                        break\n\n                yi += 1\n            if brkflg and prev_brkflg:\n                tmp_ans = INF\n                break\n            xi += 1\n        ans = min(ans, tmp_ans)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = map(int, readline().split())\n    S = [list(map(int, readline().strip())) for j in range(H)]\n    \n    white = 0\n    for line in S:\n        white += sum(line)\n \n    if white <= K:\n        print(0)\n        return\n \n    # \u6a2a\u7dda\u306e\u6c7a\u3081\u65b9\u3092\u5168\u63a2\u7d22\n    ans = 10**5\n    \n    #y\u306b\u6a2a\u7ddaPattern\u3054\u3068\u306e\u5217\u5408\u8a08\u3092\u4f5c\u6210\n    #\u5165\u529b\u4f8b\uff11\u306ePattern[bin(2)]\u5834\u5408\u3001y=[[1,1,1,0,0], [1,0,1,1,2]]\n    for pattern in range(2**(H-1)):\n        # \u521d\u671f\u5316\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [S[0]]\n        line = 0\n        for i in range(1,H):\n            if (pattern >> i-1) & 1:\n                line += 1\n                y.append(S[i])\n            else:\n                y[line] = [y[line][j] + S[i][j] for j in range(W)]\n \n        # \u5404\u5217\u306e\u5024\u3092\u52a0\u7b97\u3057\u3066\u3044\u304f\n        count = [0]*(ly + 1) \n        for j in range(W):\n            for i in range(line+1):\n                if y[i][j] > K :\n                    impossible = True\n                    break\n \n                count[i] += y[i][j]\n                #print(\"\u6a2aPattern{} \u7e26\u5217\u307e\u3067\u3000{} \u30ab\u30a6\u30f3\u30c8\u6570{} \u7e26\u7dda\u306e\u6570{}\".format(i, j, count[i], x))\n                #\u6a2aPatten\u6bce\u306b\uff4a\u5217\u307e\u3067\u306e\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u5408\u8a08\u6570\u3092\u30ab\u30a6\u30f3\u30c8\u3001\n                #\u30ab\u30a6\u30f3\u30c8\uff1eK\u3068\u306a\u3063\u305f\u3089\u3001\u7e26\u7dda\u6570\u3092\uff0b\uff11\u3001\u305d\u306e\u5217\u5024\u3067\u30ab\u30a6\u30f3\u30c8\u6570\u3092\u521d\u671f\u5316\n                if count[i] > K:\n                    x += 1\n                    for i in range(line+1):\n                        count[i] = y[i][j]\n                    break\n            #x\u7e26\u7dda\u306e\u6570 + ly\u6a2a\u7dda\u306e\u6570\u304cAns\u3088\u308a\u5927\u304d\u304f\u306a\u3063\u305f\u3089Break\n            if x + ly > ans or impossible:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n        #x\u7e26\u7dda\u306e\u6570 + ly\u6a2a\u7dda\u306e\u6570\u304cAns\u3088\u308a\u5c0f\u3055\u304f\u306a\u3063\u305f\u3089Ans\u3092\u66f4\u65b0\n        ans = min(ans, x + ly)\n \n    print(ans)\n \n \nmain()", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    INF = 10**9\n\n    H, W, K = map(int, input().split())\n    chocolate = [ input()[:-1] for _ in range(H) ]\n    \n    loop_H = range(H)\n    loop_W = range(W)\n    min_cut = INF-1\n    for div in range(1 << (H-1)):\n        # \u6a2a\u5272\u308a\u3067\u30b0\u30eb\u30fc\u30d7\u5206\u3051\n        group = [[]]\n        group_number = 0\n        for i in loop_H:\n            group[group_number].append(i)\n            if div >> i & 1:\n                group.append([])\n                group_number += 1\n        # \u7e26\u306b\u5207\u3063\u3066\u3044\u304f\n        cut = group_number\n        zeros = [0] * len(group)\n        cnt = zeros.copy()\n        w = 0\n        while w < W:\n            now = zeros.copy()\n            for g in range(len(group)):\n                for i in group[g]:\n                    if chocolate[i][w] == '1':\n                        now[g] += 1\n                if now[g] > K:\n                    cut = INF\n                    break\n                if cnt[g] + now[g] > K:\n                    cut += 1\n                    w -= 1\n                    cnt = zeros.copy()\n                    break\n                cnt[g] += now[g]\n            w += 1\n        if cut < min_cut:\n            min_cut = cut\n    print(min_cut)\n\nmain()", "# https://atcoder.jp/contests/abc159/tasks/abc159_e\nimport sys\n\nans = sys.maxsize\nH, W, K = list(map(int, input().split()))\ns = [input() for _ in range(H)]\n\nfor h in range(1 << (H - 1)):\n    g = 0\n    ids = [-1 for _ in range(H)]\n    for i in range(H):\n        ids[i] = g\n        if (h >> i) & 1:\n            g += 1\n\n    g += 1\n    c = [[0 for _ in range(W)] for _ in range(g)]\n    for i in range(H):\n        for j in range(W):\n            c[ids[i]][j] = c[ids[i]][j] + (s[i][j] == '1')\n\n    num = g - 1\n    now = [0 for _ in range(g)]\n\n\n    def add(j):\n        for i in range(g):\n            now[i] += c[i][j]\n\n        for i in range(g):\n            if now[i] > K:\n                return False\n\n        return True\n\n    if num >= ans:\n        continue\n\n    for j in range(W):\n        if not add(j):\n            num += 1\n            if num >= ans:\n                continue\n            now = [0 for _ in range(g)]\n            if not add(j):\n                num = sys.maxsize\n                break\n\n    ans = min(ans, num)\n\nprint(ans)\n", "h, w, k = list(map(int, input().split()))\n\nchoco = [[0] * w for _ in range(h)]\n\nfor i in range(h):\n    s = input()\n    for j in range(w):\n        choco[i][j] = int(s[j])\n\nans = float(\"inf\")\nfor bit in range(1 << (h - 1)):\n    idx = [0] * h\n    group = 0\n    for i in range(h):\n        idx[i] = group\n        if (bit >> i) & 1:\n            group += 1\n    group += 1\n    array = [[0] * w for _ in range(group)]\n    for j in range(w):\n        for i in range(h):\n            array[idx[i]][j] += choco[i][j]\n\n    cnt = group - 1\n    cum = [0] * group\n    canAdd = True\n    for i in range(w):\n        for j in range(group):\n            if cum[j] > k:\n                canAdd = False\n\n        if ans <= cnt:\n            canAdd = False\n\n        if canAdd is False:\n            break\n\n        for j in range(group):\n            tmp = cum[j] + array[j][i]\n            if tmp > k:\n                cnt += 1\n                for l in range(group):\n                    cum[l] = array[l][i]\n                break\n            cum[j] += array[j][i]\n\n    if canAdd:\n        ans = min(ans, cnt)\n\nprint(ans)\n", "def main():\n  from itertools import product\n  import sys\n  sys.setrecursionlimit(10**6)\n  readline = sys.stdin.readline\n  ints = lambda: map(int, readline().split())\n  floats = lambda: map(float, readline().split())\n  lli = lambda I, J: [[0] * J for _ in range(I)]\n  mod = 10**9+7\n\n  h, w, k = ints()\n  ans = h + w\n  s = [list(map(int, input())) for _ in range(h)]\n  for comb in product([False, True], repeat=h - 1):\n    divs = 0\n    a = [s[0][:]]\n    for row, isd in zip(s[1:], comb):\n      if isd:\n        a += [row[:]]\n        divs += 1\n      else:\n        for i in range(w):\n          a[divs][i] += row[i]\n    dh = divs + 1\n    ta = [list(i) for i in zip(*a)]\n    currow = ta[0]\n    imp = False\n    for row in ta[1:]:\n      if any([i > k for i in currow]):\n        imp = True\n        break\n      else:\n        temp = [i + j for i, j in zip(currow, row)]\n        if any([i > k for i in temp]):\n          currow = row\n          divs += 1\n        else:\n          currow = temp\n    if not imp:\n      ans = min(ans, divs)\n  print(ans)\n\ndef __starting_point():\n  main()\n__starting_point()", "def column_check(grp, grp_count, choco, h, j, k):\n    \"\"\" 0:\u6210\u529f\uff08\u66f4\u65b0\u3082\u53cd\u6620\uff09  1:\u5931\u6557\uff08\u533a\u5207\u3063\u305f\u7d50\u679c\u3092\u8fd4\u3059\uff09 2:\u4e0d\u53ef\u80fd \"\"\"\n    # \u3053\u306e\u884c\u306e\u30b0\u30eb\u30fc\u30d7\u6bce\u306e\u30ab\u30a6\u30f3\u30c8\n    curr_count = [0] * len(grp_count)\n    # \u6570\u3048\u308b\n    for i in range(h):\n        if choco[i][j] == '0':\n            continue\n        curr_count[grp[i]] += 1\n    # \u3053\u306e\u884c\u3060\u3051\u3067k\u8d8a\u3048\u3066\u305f\u3089\u73fe\u5728\u306e\u6a2a\u306e\u5207\u308a\u65b9\u3067\u306f\u4e0d\u53ef\u80fd\n    for cc in curr_count:\n        if cc > k:\n            return 2\n    # \u3053\u3053\u307e\u3067\u306e\u884c\u3068\u5408\u308f\u305b\u3066k\u3092\u8d8a\u3048\u306a\u3044\u304b\u30c1\u30a7\u30c3\u30af\n    for i, cc in enumerate(curr_count):\n        grp_count[i] += cc\n        # \u8d8a\u3048\u3066\u305f\u3089\u3001grp_count\u3092\u73fe\u5728\u306e\u884c\u306b\u4e0a\u66f8\u304d\n        if grp_count[i] > k:\n            grp_count[:] = curr_count\n            return 1\n    return 0\n\n\ndef solve(h, w, k, choco):\n    ans = 10 ** 9\n    grp = [0] * h\n    for bit in range(1 << (h - 1)):\n        g = 0\n        for i in range(h):\n            grp[i] = g\n            if (bit >> i) & 1:\n                g += 1\n\n        grp_count = [0] * (g + 1)\n        tmp = 0\n        possible = True\n        for j in range(w):\n            result = column_check(grp, grp_count, choco, h, j, k)\n            if result == 2:\n                possible = False\n                break\n            if result == 1:\n                tmp += 1\n\n        if not possible:\n            continue\n\n        ans = min(ans, tmp + bin(bit).count('1'))\n\n    return ans\n\n\nh, w, k = list(map(int, input().split()))\nchoco = [input() for _ in range(h)]\nprint((solve(h, w, k, choco)))\n", "h, w, k = list(map(int, input().split()))\n\nchoco = [list(map(int, list(input()) )) for i in range(h)]\n\nans = h + w + 1\n\nfor h_cut in range(2**(h-1)):\n    # \u4e0a\u4f4d\u30d3\u30c3\u30c8\u304c\u4e0a\u5074\u30021\u304c\u5207\u308b\u30010\u304c\u5207\u3089\u306a\u3044\n    num_cut_yoko = bin(h_cut).count(\"1\") # \u7acb\u3063\u3066\u3044\u308b\u30d3\u30c3\u30c8\u306e\u500b\u6570\n    num_cut = num_cut_yoko\n    w_last_cut_pos = -1\n    valid = True\n\n    count_white = [0] * (num_cut_yoko + 1)\n    temp_dict = {}\n    idx = 0\n    temp_dict[0] = idx\n    for i in range(1, h):\n        # print('idx', 2 ** (-i+h-1) )\n        if h_cut & (2 ** (-i+h-1) ):\n            idx += 1\n        # idx += h_cut & (2 ** (h-1) - i)\n        temp_dict[i] = idx\n    # print(temp_dict)\n\n    iw = 0\n    while iw < w:\n\n        for ih in range(h):\n            count_white[temp_dict[ih]] += choco[ih][iw]\n        # print(iw, count_white)\n\n        condition = max(count_white) > k\n        if condition:\n            if w_last_cut_pos < iw-1:\n                # \u3082\u3057\u305d\u3053\u3067\u5207\u3063\u3066k\u3092\u8d85\u3048\u308b\u306a\u3089\u3001\u305d\u306e\u624b\u524d\u3067\u5207\u308b\n                num_cut += 1\n                w_last_cut_pos = iw - 1\n                count_white = [0] * (num_cut_yoko + 1)\n                # print('iw: ', iw, 'last: ', w_last_cut_pos)\n\n            else:\n                # 1\u3064\u3057\u304b\u52d5\u304b\u3057\u3066\u306a\u3044\u306e\u306bk\u500b\u3092\u8d85\u3048\u305f\u5834\u5408\u306f\u3001\u3053\u306e\u6a2a\u65b9\u5411\u306e\u5207\u308a\u65b9\u3067\u9054\u6210\u4e0d\u53ef\u80fd\u306a\u306e\u3067\u3001\u6b21\u306eh_cut\u306b\u9032\u3080\n                # \u3053\u306e\u3068\u304d\u5207\u65ad\u56de\u6570\u306e\u6700\u5c0f\u5024\u306e\u66f4\u65b0\u3092\u3057\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f!\n                valid = False\n                break\n        \n        else:\n            iw += 1\n    \n    if valid:\n        ans = min(ans, num_cut)\n    # print(num_cut)\n\nprint(ans)\n", "H,W,K=list(map(int,input().split()))\nS=[[int(x) for x in list(str(input()))] for _ in range(H)]\nT=[[0]*(W+1) for x in range(H+1)]\n\ndef main():\n  for h in range(H):\n    for w in range(W):\n      T[h][w]=T[h][w-1]+S[h][w]\n\n  for h in range(1,H):\n    for w in range(W):\n      T[h][w]=T[h][w]+T[h-1][w]\n\n  m=(H-1)*(W-1)\n  for p in range(2**(H-1)):\n    D=[x for x in range(H-1) if p&(2**x)!=0]+[H-1]\n    c,b=0,-1\n    f=False\n    for w in range(W):\n      u=-1\n      for d in D:\n        if T[d][w]-T[u][w]-T[d][b]+T[u][b]>K:\n          if b==w-1:\n            f=True\n          c,b=c+1,w-1\n          break\n        u=d\n      if f==True:\n        break\n    else:\n      m=min(m,c+len(D)-1)\n  print(m)\nmain()\n\n", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = list(map(int, readline().split()))\n    S = [list(map(int, readline().strip())) for j in range(H)]\n\n    white = 0\n    for line in S:\n        white += sum(line)\n\n    if white <= K:\n        print((0))\n        return\n\n    # \u6a2a\u7dda\u306e\u6c7a\u3081\u65b9\u3092\u5168\u63a2\u7d22\n    ans = 10**5\n    for pattern in range(2**(H-1)):\n        # \u521d\u671f\u5316\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [[0]*W]*(ly + 1)\n        line = 0\n        for i in range(H):\n            y[line] = [y[line][j] + S[i][j] for j in range(W)]\n            if (pattern >> i) & 1:\n                line += 1\n\n        # \u5404\u5217\u306e\u5024\u3092\u52a0\u7b97\u3057\u3066\u3044\u304f\n        count = [0]*(ly + 1) \n        for j in range(W):\n            for i in range(line+1):\n                if y[i][j] > K :\n                    impossible = True\n                    break\n\n                count[i] += y[i][j]\n                if count[i] > K:\n                    x += 1\n                    for i in range(line+1):\n                        count[i] = y[i][j] \n                    break\n            if x + ly > ans or impossible:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n\n        ans = min(ans, x + ly)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - Dividing Chocolate\nimport numpy as np\n\nH, W, K = list(map(int, input().split()))\nS = np.zeros((H, W), dtype=np.int64)\n\nans = H+W\n\nfor i in range(H):\n    S[i] = list(str(input()))\n\nfor m in range(2**(H-1)):\n    wp = np.zeros((H, W), dtype=np.int64)\n    wq = np.zeros((H, ), dtype=np.int64)\n    wp[0] = S[0]\n    cut = 0\n    for n in range(H-1):\n        if m>>n&1:\n            cut += 1\n        wp[cut] += S[n+1]\n\n    if cut >= ans or np.count_nonzero(wp > K):\n        continue\n\n    for j in range(W):\n        wq += wp[:,j]\n        if np.count_nonzero(wq > K):\n            cut += 1\n            wq = wp[:,j]\n    ans = min(ans, cut)\n\nprint(ans)\n\n\n", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(H, W, K, Si):\n    Si = [[int(i) for i in S] for S in Si]\n    ans = H + W\n    for i in range(2 ** (H - 1)):\n        h_border = bin(i).count('1')\n        w_border = 0\n        white_counts = [0] * (h_border + 1)\n        choco_w = 0\n        for w in range(W):\n            choco_w += 1\n            wc_num = 0\n            tmp_count = [0] * (h_border + 1)\n            for h in range(H):\n                white_counts[wc_num] += Si[h][w]\n                tmp_count[wc_num] += Si[h][w]\n                if i >> h & 1:\n                    wc_num += 1\n            if max(white_counts) > K:\n                if choco_w == 1:\n                    break  # 1\u5217\u306e\u6642\u70b9\u3067 > K \u306e\u5834\u5408\u306f\u6761\u4ef6\u3092\u9054\u6210\u3067\u304d\u306a\u3044\n                w_border += 1\n                white_counts = tmp_count\n                choco_w = 1\n        else:\n            ans = min(ans, h_border + w_border)\n    print(ans)\n\n\ndef __starting_point():\n    H, W, K = list(map(int, input().split()))\n    Si = [input() for _ in range(H)]\n    solve(H, W, K, Si)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # \n    # H, W, K = 10, 1000, randint(1, 100)\n    # Si = [random_str(W, '01') for _ in range(H)]\n    # print(H, W, K)\n    # for S in Si:\n    #     print(S)\n    # solve(H, W, K, Si)\n\n__starting_point()", "h,w,k = list(map(int,input().split())); arr = [[int(i) for i in input()] for _ in range(h)]\n\nfrom itertools import product\nans = 2000\n\nfor cond in product([True,False],repeat=(h-1)):\n    cut = sum(cond); div = 0\n    splits = [0] * (cut+1); splits[0] = arr[0][:]\n    for i in range(1,h):\n        if cond[i-1]:\n            div += 1\n            splits[div] = arr[i][:]\n        else:\n            splits[div] = [splits[div][j]+arr[i][j] for j in range(w)]\n    \n    check = [max(i) for i in splits]\n    if max(check) > k:\n        break\n    count = [i[0] for i in splits]\n    \n    for j in range(1,w):\n        addarr = [count[i]+splits[i][j] for i in range(cut+1)]\n        if max(addarr) > k:\n            div += 1\n            count = [splits[i][j] for i in range(cut+1)]\n        else:\n            count = addarr[:]\n    ans = min(ans,div)\n        \nprint(ans)", "import sys\nimport itertools\nimport pprint\ninput = lambda: sys.stdin.readline().rstrip()\n\nH, W, K = list(map(int, input().split()))\nS = [[0 for _ in range(W)] for _ in range(H)]\nfor i in range(H):\n    S[i] = list(map(int, input()))\n\nStsum = [[0 for _ in range(W + 1)] for _ in range(H + 1)]\nfor i in range(H):\n    for j in range(W):\n        Stsum[i + 1][j + 1] = Stsum[i + 1][j] + S[i][j]\nfor j in range(W):\n    for i in range(H):\n        Stsum[i + 1][j + 1] += Stsum[i][j + 1]\n\n\ndef count_white(l, r, u, b):\n    return Stsum[b][r] - Stsum[u][r] - Stsum[b][l] + Stsum[u][l]\n\n\ndef solve():\n\n    comb = list(itertools.product(list(range(2)), repeat=H - 1))\n\n    ans = 10 ** 9 + 7\n    for c in comb:\n\n        hc = [0] + [i + 1 for i, x in enumerate(c) if x == 1] + [H]\n        l, w = 0, 1\n        cut_count = 0\n        search = False\n        p_cut = True\n\n        while w <= W:\n            cut = True\n            for h in range(0, len(hc) - 1):\n                if count_white(l, w, hc[h], hc[h + 1]) > K:\n                    cut = False\n                    break\n            else:\n                search = True\n\n            if not cut:\n                if search:\n                    l = w - 1\n                    cut_count += 1\n                    search = False\n                else:\n                    p_cut = False\n                    break\n            else:\n                w += 1\n\n        if p_cut:\n            ans = min(ans, cut_count + len(hc) - 2)\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "def main():\n    import sys\n    def input(): return sys.stdin.readline().rstrip()\n    h, w, k = map(int, input().split())\n    field = [[] for i in range(h)]\n    for i in range(h):\n        field[i] = [int(s) for s in input()]\n    import numpy as np\n    field = np.array(field, dtype=int)\n    inf = 10 **4\n    ans = inf\n    for i in range(2**(h-1)):\n        prev = 0\n        damy = []\n        tmp_ans = format(i, 'b').count('1')\n        for j in range(h-1):\n            if (i >> j)&1:\n                damy.append(field[prev:j+1].sum(axis=0))\n                prev = j+1\n        damy.append(field[prev:].sum(axis=0))\n        damy = np.array(damy,dtype=int).T\n        if (damy > k).any():\n            continue\n\n        prev = 0\n        cnt_w = np.zeros(tmp_ans+1, dtype=int)\n        for l in range(w):\n            cnt_w += damy[l]\n            if (cnt_w > k).any():\n                cnt_w = damy[l]\n                tmp_ans += 1\n            \n        ans = min(ans, tmp_ans)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = list(map(int, readline().split()))\n    S = [readline().strip() for j in range(H)]\n\n    white = []\n    for line in S:\n        white.append(line.count(\"1\"))\n    white_total = sum(white)\n\n    if white_total <= K:\n        print((0))\n        return\n\n    # \u6a2a\u7dda\u306e\u6c7a\u3081\u65b9\u3092\u5168\u63a2\u7d22\n    ans = 10**5\n    for pattern in range(2**(H-1)):\n        # \u521d\u671f\u5316\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [[0]*W]*(ly + 1)\n        line = 0\n        for i in range(H):\n            y[line] = [y[line][j] + int(S[i][j]) for j in range(W)]\n            if (pattern >> i) & 1:\n                line += 1\n\n        # \u5404\u5217\u306e\u5024\u3092\u52a0\u7b97\u3057\u3066\u3044\u304f\n        count = [0]*(ly + 1) \n        for col in zip(*y):\n            # K\u3088\u308a\u5927\u304d\u3044\u5024\u3092\u52a0\u7b97\u3059\u308b\u5834\u5408\u306f\u4e0d\u6210\u7acb\n            if any(a > K for a in col):\n                impossible = True\n                break\n            for i, a in enumerate(col):\n                count[i] += a\n                # \u548c\u304cK\u3088\u308a\u5927\u304d\u3051\u308c\u3070\u30ab\u30c3\u30c8\u6570\u3092\u5897\u3084\u3059\n                if count[i] > K:\n                    x += 1\n                    count = list(col) \n                    break\n            if x + ly > ans:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n\n        ans = min(ans, x + ly)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n#da[i][j]:(0,0)~(i,j)\u306e\u9577\u65b9\u5f62\u306e\u548c\ndef da_generate(h, w, a):\n    da = [[0] * w for j in range(h)]\n    da[0][0] = a[0][0]\n    for i in range(1, w):\n        da[0][i] = da[0][i - 1] + a[0][i]\n    for i in range(1, h):\n        cnt_w = 0\n        for j in range(w):\n            cnt_w += a[i][j]\n            da[i][j] = da[i - 1][j] + cnt_w\n    return da\n\n#da_calc(p,q,x,y):(p,q)~(x,y)\u306e\u9577\u65b9\u5f62\u306e\u548c\ndef da_calc(p, q, x, y):\n    if p > x or q > y:\n        return 0\n    if p == 0 and q == 0:\n        return da[x][y]\n    if p == 0:\n        return da[x][y] - da[x][q - 1]\n    if q == 0:\n        return da[x][y] - da[p - 1][y]\n    return da[x][y] - da[p - 1][y] - da[x][q - 1] + da[p - 1][q - 1]\n\nH, W, K = map(int, sys.stdin.readline().rstrip().split())\ngrid = [list(map(int, list(sys.stdin.readline().rstrip()))) for _ in range(H)]\nda = da_generate(H, W, grid)\n\nans = 10 ** 18\nfor i in range(2**(H - 1)):\n    res = 0\n    s = [k for k, j in enumerate(range(H), 1) if i >> j & 1] # s\u884c\u306f\u542b\u307e\u306a\u3044\n    res += len(s)\n    s.append(H)\n    y = 0\n    for w in range(1, W + 1): # w\u884c\u306f\u542b\u307e\u306a\u3044\n        x = 0\n        flag = False\n        for s_i in s:\n            if da_calc(x, y, s_i - 1, w - 1) > K:\n                if y + 1 < w:\n                    res += 1\n                    y = w - 1\n                else:\n                    flag = True\n                break\n            x = s_i\n        else:\n            pass\n        if flag:\n            break\n    else:\n        ans = min(ans, res)\n\nprint(ans)", "h,w,k = list(map(int,input().split())); arr = [[int(i) for i in input()] for _ in range(h)]\n\nfrom itertools import product\nans = 2000\n\nfor cond in product([True,False],repeat=(h-1)):\n    cut = sum(cond)\n    splits = [arr[0][:]]\n    for i in range(1,h):\n        if cond[i-1]:\n            splits.append(arr[i][:])\n        else:\n            splits[-1] = [splits[-1][j]+arr[i][j] for j in range(w)]\n    \n    check = [max(i) for i in splits]\n    if max(check) > k:\n        break\n    count = [i[0] for i in splits]\n    \n    div = cut\n    for j in range(1,w):\n        addarr = [count[i]+splits[i][j] for i in range(cut+1)]\n        if max(addarr) > k:\n            div += 1\n            count = [splits[i][j] for i in range(cut+1)]\n        else:\n            count = addarr[:]\n    ans = min(ans,div)\n        \nprint(ans)", "# https://atcoder.jp/contests/abc159/submissions/11108540\n\ndef main():\n    def calc(group):\n        ret = max(group)\n        ctr = [0] * H\n        for c in range(W):\n            need_cut = False\n            for r, g in enumerate(group):\n                ctr[g] += s[r][c]\n                if ctr[g] > K:\n                    need_cut = True\n                    break\n\n            if need_cut:\n                ctr = [0] * H\n                ret += 1\n                for r, g in enumerate(group):\n                    ctr[g] += s[r][c]\n                    if ctr[g] > K:\n                        return H * W\n                continue\n        return ret\n\n    def gen():\n        from itertools import accumulate, product\n\n        for prod in product(list(range(2)), repeat=H - 1):\n            group = [0]\n            group.extend(accumulate(prod))\n            yield calc(group)\n\n    H, W, K = list(map(int, input().split()))\n    s = []\n    for _ in range(H):\n        *row, = list(map(int, input()))\n        s.append(row)\n\n    ret = min(gen())\n    print(ret)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    h,w,k = LI()\n    aa = [[int(c) for c in S()] for _ in range(h)]\n\n    def f(hs):\n        l = len(hs)\n        c = [0] * l\n        r = l - 1\n        for i in range(w):\n            nc = [0] * l\n            bf = False\n            for j in range(l):\n                for h in hs[j]:\n                    nc[j] += aa[h][i]\n                if nc[j] > k:\n                    return -1\n                if nc[j] + c[j] > k:\n                    bf = True\n            if bf:\n                r += 1\n                c = nc\n            else:\n                for j in range(l):\n                    c[j] += nc[j]\n        return r\n\n    r = inf\n    for bi in range(2**(h-1)):\n        hs = [[0]]\n        for i in range(h-1):\n            if 2**i & bi > 0:\n                hs.append([])\n            hs[-1].append(i+1)\n        t = f(hs)\n        if t >= 0 and r > t:\n            r = t\n\n    return r\n\n\nprint(main())\n\n\n\n", "\"\"\"\nReferences: <https://www.hamayanhamayan.com/entry/2020/03/22/231629>\n\"\"\"\nimport sys\nfrom itertools import product\n\ninput = sys.stdin.readline\n\n\ndef main():\n    H, W, K = list(map(int, input().split()))\n    S = [None] * H\n    for i in range(H):\n        S[i] = input().rstrip()\n\n    ans = float(\"inf\")\n    for comb in product(list(range(2)), repeat=(H - 1)):\n        n_cut = sum(comb)\n        if n_cut >= ans:\n            continue\n\n        group = []\n        g_id = 0\n        for c in comb:\n            group.append(g_id)\n            if c == 1:\n                g_id += 1\n        group.append(g_id)\n\n        w = 0\n        while w < W:\n            count = [0] * (g_id + 1)\n            next_w = w\n            for x in range(w, W):\n                over_K = False\n                for y in range(H):\n                    if S[y][x] == \"1\":\n                        count[group[y]] += 1\n                        if count[group[y]] > K:\n                            over_K = True\n                            break\n                if over_K:\n                    break\n                next_w += 1\n\n            # Impossible: over K in one column\n            if next_w == w:\n                n_cut = float(\"inf\")\n                break\n            w = next_w\n\n            if over_K:\n                n_cut += 1\n            if n_cut >= ans:\n                break\n\n        if n_cut < ans:\n            ans = n_cut\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - Dividing Chocolate\nimport numpy as np\n\nH, W, K = list(map(int, input().split()))\nS = np.zeros((H, W), dtype=np.int64)\n\nans = H+W\n\nfor i in range(H):\n    S[i] = list(str(input()))\n\nfor m in range(1<<(H-1)):\n    cut = bin(m).count('1')\n    if cut >= ans:\n        continue\n\n    wp = np.zeros((cut+1, W), dtype=np.int64)\n    wp[0] = S[0]\n    c = 0\n    for n in range(H-1):\n        if m>>n&1:\n            c += 1\n        wp[c] += S[n+1]\n\n    if np.count_nonzero(wp > K):\n        continue\n\n    wq = np.zeros((cut+1, ), dtype=np.int64)\n    for j in range(W):\n        wq += wp[:,j]\n        if np.count_nonzero(wq > K):\n            cut += 1\n            wq = wp[:,j]\n\n    ans = min(ans, cut)\n\nprint(ans)\n\n\n", "H,W,K = list(map(int,input().split()))\n\nS = [input() for _ in range(H)]\n\nans = 10**10\nfor i in range(2**(H-1)):   # i\u306fbit\n    rel = [0 for h in range(H)]\n    a,b = 0,0\n    for h in range(H-1):\n        if i>>h&1:\n            b += 1\n        rel[h+1] = b\n\n    a += b\n\n    cnt = [0 for j in range(b+1)]\n    for w in range(W):\n        for h in range(H):\n            if S[h][w] == '1':\n                cnt[rel[h]] += 1\n        \n        OK = True\n        for j in range(b+1):\n            if cnt[j] > K:\n                OK = False\n                break\n        \n        if OK:\n            continue\n\n        a += 1\n        cnt = [0 for j in range(b+1)]\n        for h in range(H):\n            if S[h][w] == '1':\n                cnt[rel[h]] += 1\n\n        OK2 = True\n        for j in range(b+1):\n            if cnt[j] > K:\n                OK2 = False\n                break\n        \n        if OK2:\n            continue\n        a = 10**10\n        break\n    ans = min(ans,a)\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nH,W,K=list(map(int,input().split()))\nS = [input().rstrip() for _ in range(H)]\n\nbit = 2**(H-1)\nans = (H-1)+(W-1)\nfor bi in range(bit):\n    w = 0\n    cnt = bin(bi).count('1')\n    counter_1 = [0]*H\n    \n    while w <W:\n        i=0\n        for h in range(H):\n            if S[h][w] == '1':\n                counter_1[i]+=1\n                if counter_1[i]>K:\n                    cnt +=1\n                    counter_1 = [0]*H\n                    w -=1\n                    break\n            if bi >>h & 1:\n                i+=1\n        w+=1\n        if cnt>=ans:\n            break\n    ans = min(ans,cnt)\nprint(ans)\n", "# https://atcoder.jp/contests/abc159/tasks/abc159_e\nimport sys\n\nans = sys.maxsize\nH, W, K = list(map(int, input().split()))\ns = [input() for _ in range(H)]\n\nfor h in range(1 << (H - 1)):\n    g = 0\n    ids = [-1 for _ in range(H)]\n    for i in range(H):\n        ids[i] = g\n        if (h >> i) & 1:\n            g += 1\n\n    g += 1\n    num = g - 1\n\n    if num >= ans:\n        continue\n\n    c = [[0] * W for _ in range(g)]\n    for i in range(H):\n        for j in range(W):\n            c[ids[i]][j] = c[ids[i]][j] + (s[i][j] == '1')\n\n    now = [0 for _ in range(g)]\n\n\n    def add(j):\n        for i in range(g):\n            now[i] += c[i][j]\n\n        for i in range(g):\n            if now[i] > K:\n                return False\n\n        return True\n\n\n    for j in range(W):\n        if not add(j):\n            num += 1\n            if num >= ans:\n                continue\n            now = [0 for _ in range(g)]\n            if not add(j):\n                num = sys.maxsize\n                break\n\n    ans = min(ans, num)\n\nprint(ans)\n", "\n\n\ndef solve(choco, cut_pos, k):\n    cuts = len(cut_pos) - 2\n    blocks = [0] * (len(cut_pos) - 1)\n\n    for col in zip(*choco):\n        need_cut = False\n        for i, blk in enumerate(zip(cut_pos, cut_pos[1:])):\n            s, e = blk\n            white = sum(col[s:e])\n    \n            if white > k:\n                return float('inf')\n\n            if blocks[i] + white > k:\n                need_cut = True\n                break\n            else:\n                blocks[i] += white\n\n        if need_cut:\n            for i, blk in enumerate(zip(cut_pos, cut_pos[1:])):\n                s, e = blk\n                blocks[i] = sum(col[s:e])\n\n        cuts += need_cut\n    # print('cuts:', cuts)\n    return cuts\n\n\ndef main():\n    h, w, k = list(map(int, input().split()))\n\n    choco = [[int(s) for s in list(input())] for _ in range(h)]\n    min_cuts = float('inf')\n\n    for cuts in range(1 << (h-1)):\n        cut_pos = [0] + [i+1 for i in range(h-1) if cuts & (1 << i)] + [h]\n        min_cuts = min(min_cuts, solve(choco, cut_pos, k))\n\n    print(min_cuts)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\nH, W, K = map(int,input().split())\nS = [list(map(int,list(input()))) for _ in range(H)]\ndef check(k):\n    if k <= K:\n        return(True)\n    else:\n        return(False)\n        \nnoans = 0\ndef make_lst(i):\n    nonlocal noans, lst, havelst\n    temp = S[0][i]\n    for h in range(H-1):\n        if y[h]:\n            lst.append(temp)\n            temp = S[h+1][i]\n        else:\n            temp += S[h+1][i]\n    lst.append(temp)\n    if check(max(lst)):\n        havelst = 1\n    else:\n        noans = 1\n#    print(y,i,lst, \"makelst\")\n               \ndef nocut(i):\n    nonlocal cutnum, lst, havelst, noans\n    prelst = []\n    temp = S[0][i]\n    if i == W-1:\n        if not check(temp):\n            noans = 1\n    j = 0\n    for h in range(H-1):            \n        if y[h]:\n            lst[j] += temp\n            prelst.append(temp)\n            j += 1\n            temp = S[h+1][i]\n        else:\n            temp += S[h+1][i]\n        if i == W-1:\n            if not check(temp):\n                noans = 1\n    prelst.append(temp)\n    lst[-1] += temp\n    if check(max(lst)):\n#        print(y,i,lst,\"nocut\", \"cutnum = \",cutnum)\n        return(True)\n    else:\n        cutnum += 1\n        lst = prelst        \n#        print(y,i,lst,\"cut\",\"cutnum =\",cutnum)\n        \n                 \nans = float(\"inf\")    \nfor y in itertools.product((0, 1), repeat=H-1):\n    havelst = 0\n    lst = []\n    cutnum = sum(y)\n    for x in range(W):\n        if noans:\n            break\n        if havelst:\n            nocut(x)\n        else:\n            make_lst(x)\n#    print(y,cutnum)\n    if noans:\n        noans = 0\n        continue\n    else:\n        ans = min(cutnum, ans)\nprint(ans)", "import numpy as np\n\ndef main():\n    H, W, K = list(map(int, input().split()))\n    S = []\n    for _ in range(H):\n        S.append(list(map(int, list(input()))))\n    S = np.array(S)\n    if S.sum() <= K:\n        print((0))\n        return\n    answer = float('INF')\n    for i in range(0, 2 ** (H - 1)):\n        horizons = list(map(int, list(bin(i)[2:].zfill(H - 1))))\n        result = greedy(W, S, K, horizons, answer)\n        answer = min(answer, result)\n    print(answer)\n\n# ex. horizons = [0, 0, 1, 0, 0, 1]\ndef greedy(W, S, K, horizons, current_answer):\n    answer = sum(horizons)\n    # ex.\n    # S  = [[1, 1, 1, 0, 0],\n    #       [1, 0, 0, 0, 1],\n    #       [0, 0, 1, 1, 1]]\n    # horizons = [0, 1]\u306e\u3068\u304d,\n    # S2 = [[2, 1, 1, 0, 0],\n    #       [0, 0, 1, 1, 1]]\n    # \u3068\u306a\u308b\n    top = 0\n    bottom = 0\n    S2 = []\n    for h in horizons:\n        if h == 1:\n            S2.append(S[:][top:(bottom + 1)].sum(axis=0).tolist())\n            top = bottom + 1\n        bottom += 1\n    S2.append(S[:][top:].sum(axis=0).tolist())\n    # \u30d6\u30ed\u30c3\u30af\u6bce\u306e\u7d2f\u7a4d\u548c\u3092\u8a08\u7b97\u3059\u308b\n    h = len(S2)\n    partial_sums = [0] * h\n    for right in range(W):\n        current = [0] * h\n        for idx in range(h):\n            current[idx] = S2[idx][right]\n            partial_sums[idx] += S2[idx][right]\n        # 1\u5217\u306b\u542b\u3080\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u306e\u6570\u304ck\u3088\u308a\u591a\u3044\u5834\u5408\n        if max(current) > K:\n            return float('INF')\n        # \u7121\u7406\u306a(\u30d6\u30ed\u30c3\u30af\u306e\u4e2d\u306e\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u306e\u6570\u3092k\u4ee5\u4e0b\u306b\u3067\u304d\u306a\u3044)\u5834\u5408\n        if max(partial_sums) > K:\n            answer += 1\n            if answer >= current_answer:\n                return float('INF')\n            partial_sums = current\n    return answer\n\ndef __starting_point():\n    main()\n\n__starting_point()", "f=range\nh,w,k=map(int,input().split())\ng=[[int(i) for i in input()] for _ in f(h)]\ns=[[0]*-~w for _ in f(h+1)]\nfor i in f(h):\n  for j in f(w):\n    s[i+1][j+1]=s[i+1][j]+s[i][j+1]+g[i][j]-s[i][j]\na=h+w\nfor i in f(2**~-h):\n  u=d=l=r=c=0\n  e=[]\n  for d in f(h):\n    if i>>d&1: e+=[(u,d+1)]; c+=1; u=d+1\n  e+=[(u,h)]\n  for r in f(w):\n    if max(s[d][r+1]-s[u][r+1]-s[d][l]+s[u][l] for u,d in e)>k:\n      if r==l: break\n      c+=1; l=r\n  else: a=min(a,c)\nprint(a)", "import sys\n# import math\n# import bisect\n# import numpy as np\n# from decimal import Decimal\n# from numba import njit, i8, u1, b1 #JIT compiler\n# from itertools import combinations, product\n# from collections import Counter, deque, defaultdict\n\n# sys.setrecursionlimit(10 ** 6)\nMOD = 10 ** 9 + 7\nINF = 10 ** 9\nPI = 3.14159265358979323846\n\ndef read_str():      return sys.stdin.readline().strip()\ndef read_int():      return int(sys.stdin.readline().strip())\ndef read_ints():     return map(int, sys.stdin.readline().strip().split())\ndef read_ints2(x):   return map(lambda num: int(num) - x, sys.stdin.readline().strip().split())\ndef read_str_list(): return list(sys.stdin.readline().strip().split())\ndef read_int_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef GCD(a: int, b: int) -> int: return b if a%b==0 else GCD(b, a%b)\ndef LCM(a: int, b: int) -> int: return (a * b) // GCD(a, b)\n\ndef search(topx, topy, botx, boty, grid):\n    ret = grid[boty][botx]\n    if topx > 0: ret -= grid[boty][topx - 1]\n    if topy > 0: ret -= grid[topy - 1][botx]\n    if topx > 0 and topy > 0: ret += grid[topy - 1][topx - 1]\n    return ret\n\ndef Main():\n    H, W, K = read_ints()\n    chocolate = [list(read_str()) for _ in range(H)]\n    \n    grid = [[0] * W for _ in range(H)]\n    for h in range(H):\n        for w in range(W):\n            if chocolate[h][w] == '1': grid[h][w] += 1\n            if w > 0: grid[h][w] += grid[h][w - 1]\n            if h > 0: grid[h][w] += grid[h - 1][w]\n            if h > 0 and w > 0: grid[h][w] -= grid[h - 1][w - 1]\n\n    ans = INF\n    for bit in range(1 << ~-H):\n        cnt = 0\n        cut = []\n        for h in range(~-H):\n            if bit >> h & 1:\n                cnt += 1\n                cut.append(h)\n        cut.append(~-H)\n\n        white = [0] * len(cut)\n        topx = 0\n        flag = False\n        for w in range(~-W):\n            topy = 0\n            for i in range(len(cut)):\n                if search(topx, topy, w, cut[i], grid) > K:\n                    flag = True\n                    break\n                white[i] = search(topx, topy, w+1, cut[i], grid)\n                topy = cut[i] + 1\n            if flag: break\n            for x in white:\n                if x <= K:\n                    continue\n                topx = w + 1\n                cnt += 1\n                break\n        if not flag:\n            ans = min(ans, cnt)\n    print(ans)\n    \n\ndef __starting_point():\n    Main()\n__starting_point()", "sel='E'\n#A\nif sel=='A':\n    N,M=list(map(int,input().split()))\n    ans=0\n    ans+=M*(M-1)//2\n    ans+=N*(N-1)//2\n    print(ans)\n\n#B\nif sel=='B':\n    def ispal(s):\n        for i in range(len(s)//2+1):\n            if s[i]!=s[-(i+1)]:\n                return False\n        return True\n\n    S=input()\n    N=len(S)\n    if ispal(S) and ispal(S[:(N-1)//2]) and ispal(S[(N+3)//2-1:]):\n        print('Yes')\n    else:\n        print('No')\n\n#C\nif sel=='C':\n    L=int(input())\n    print(((L**3)/27))\n\n#D\nif sel=='D':    \n    N=int(input())\n    A=[int(i) for i in input().split()]\n    kin=list(set(A))\n    cnt={}\n    for k in kin:\n        cnt[k]=0\n    for a in A:\n        cnt[a]+=1\n    SUM=0\n    for k in kin:\n        SUM+=cnt[k]*(cnt[k]-1)//2\n    for a in A:\n        if cnt[a]>=2:\n            print((SUM-cnt[a]+1))\n        else:\n            print(SUM)\n        \n#E\nif sel=='E':\n    def add(in1, in2):\n        return [a + b for a, b in zip(in1, in2)]\n\n    def split(ar, k, w):\n        a = 0\n        if max(max(ar)) > k:\n            return -1\n        tm = ar[0]\n        for i in range(1, w):\n            tm = add(tm, ar[i])\n            if max(tm) > k:\n                a += 1\n                tm = ar[i]\n        return a        \n\n    h, w, k = list(map(int, input().split()))\n    s = [[int(i) for i in input()] for j in range(h)]\n    ans = h*w\n\n    for i in range(2**(h-1)):\n        data = []\n        temp = s[0]\n        sp = bin(i+2**h)[4:]\n        for j in range(1, h):\n            if sp[j-1] == \"0\":\n                temp = add(temp, s[j])\n            else:\n                data.append(temp)\n                temp = s[j]\n        data.append(temp)\n        ans_ = split([list(x) for x in zip(*data)], k, w)\n        if ans_ == -1:\n            continue\n        ans_ += sp.count(\"1\")\n        if ans > ans_:\n            ans = ans_\n    print(ans)\n\n\n\n# #F\n# if sel=='F':\n#     N,S=map(int,input().split())\n#     A=[int(i) for i in input().split()]\n    \n\n", "import sys\ninput = sys.stdin.readline\n\nH,W,K=list(map(int,input().split()))\nS = [input().rstrip() for _ in range(H)]\n\nbit = 2**(H-1)#bit\u5168\u63a2\u7d22\u3000\u6a2a\u65b9\u5411\u306e\u5272\u65b9\u3092\u3059\u3079\u3066\u898b\u308b\nans = (H-1)+(W-1)#\u3053\u3053\u30df\u30b9\u308b\u3068TLE float('inf')\u306f\u30c0\u30e1\u300210**5\u3082\u30c0\u30e1\u3002\nfor bi in range(bit):\n    w = 0\n    cnt = bin(bi).count('1')#\u6a2a\u5272\u306e\u6570\n    white = [0]*H#\u7e26\u5272\u308a\u306e\u6570\u3092\u8caa\u6b32\u306b\u6c42\u3081\u308b\n    \n    while w <W:\n        i=0\n        for h in range(H):\n            if S[h][w] == '1':\n                white[i]+=1\n                if white[i]>K:#\u8d85\u3048\u305f\u3089\u5272\u6570\u3092\u8db3\u3059\u3002\u30ab\u30a6\u30f3\u30bf\u3092\u521d\u671f\u5316\u3001\u8d85\u3048\u305f\u5217\u3092\u3082\u3046\u4e00\u5ea6\u8db3\u3059\n                    cnt +=1\n                    white = [0]*H\n                    w -=1\n                    break\n            if bi >>h & 1:\n                i+=1\n        w+=1\n        if cnt>=ans:#\u3059\u3067\u306bans\u3092\u8d85\u3048\u3066\u305f\u3089\u3084\u3081\u308b\u3002\u3053\u308c\u304c\u306a\u3044\u3068TLE\n            break\n    ans = min(ans,cnt)#\u5c0f\u3055\u3051\u308c\u3070\u66f4\u65b0\nprint(ans)\n", "import numpy as np\nimport itertools\n\nH, W, K = map(int, input().split())\nchoco = []\nfor i in range(H):\n    choco.append([int(x) for x in list(input())])\n\narr = np.array(choco)\n\n# W\u65b9\u5411\u306bGREEDY\ncount = (H-1) + (W-1)\n\n\nfor k in range(H):\n    \n    # \u3053\u306e\u6642\u70b9\u3067\u540c\u3058\u56de\u6570\u4ee5\u4e0a\u5207\u308b\u3053\u3068\u304c\u78ba\u5b9a\u306a\u3089\u7d42\u4e86\n    if count <= k:\n        break\n\n    # H \u65b9\u5411\u306b\u5207\u308a\u8fbc\u307f\n    for comb in itertools.combinations(range(1,H),k):\n\n        # \u30b9\u30e9\u30a4\u30b9\u3092\u4f5c\u3063\u3066\u304a\u304f\n        t = (None,) + comb + (None,)\n        s = [slice(t[j],t[j+1],) for j in range(len(t)-1)]\n        \n        sum_p = [0] * (k+1)\n        \n        cut = k\n        \n        for col in zip(*choco):\n\n            # \u5404\u30d6\u30ed\u30c3\u30af\u6bce\u306e\u5408\u8a08\u3092\u7b97\u51fa\n            sum_a = [sum(col[b]) for b in s]\n            \n            # K \u3092\u8d85\u3048\u308b\u30d6\u30ed\u30c3\u30af\u304c\u5b58\u5728\u3057\u3066\u3044\u306a\u3044\u304b\uff1f\n            if any(map(K.__lt__, sum_a)):\n                # \u4e0d\u6210\u7acb\n                break\n            \n            # \u524d\u307e\u3067\u5206\u5272\u3055\u308c\u3066\u3044\u306a\u3044\u30d6\u30ed\u30c3\u30af\u3068\u5408\u308f\u305b\u3066\u3001\u5408\u8a08\u3092\u7b97\u51fa\n            \n            sum_b = [x + y for x,y in zip(sum_p, sum_a)]\n\n            if any(map(K.__lt__, sum_b)):\n                cut += 1\n                sum_p = sum_a\n            else:\n                sum_p = sum_b\n                \n                # \u5272\u3063\u305f\u4f4d\u7f6e\u3092\u8a18\u9332\n        \n        else:\n            count = min(count,cut)\n\nprint(count)", "from itertools import accumulate\n\n\ndef solve(h, w, lim, choco):\n    acc = [[0] + list(accumulate(int(c == '1') for c in s)) for s in choco]\n    acc = list(zip(*acc))\n    acc = [[0] + list(accumulate(s)) for s in acc]\n    acc = list(zip(*acc))\n    # print(*acc, sep='\\n')\n\n    ans = 10 ** 9\n    # i:j  h\u65b9\u5411\u306e\u5206\u5272\n    # k:l  w\u65b9\u5411\u306e\u5206\u5272\n    for bit in range(1 << (h - 1)):\n        k = 1\n        tmp = 0\n        while k < w:\n            # print(bin(bit), k)\n            i = 0\n            l = w + 1\n            sp = bit | 1 << (h - 1)\n            while sp:\n                b = sp & -sp\n                sp ^= b\n                j = b.bit_length()\n                lt = k\n                while lt <= w and acc[j][lt] - acc[j][k - 1] - acc[i][lt] + acc[i][k - 1] <= lim:\n                    lt += 1\n                if lt == k:\n                    break\n                l = min(l, lt)\n                # print('i,j,k,l', i, j, k, l, lt)\n                i = j\n            else:\n                k = l\n                if k <= w:\n                    tmp += 1\n                continue\n            break\n        else:\n            # print(tmp, bin(bit).count('1'))\n            ans = min(ans, tmp + bin(bit).count('1'))\n    return ans\n\n\nh, w, k = list(map(int, input().split()))\nchoco = [input() for _ in range(h)]\nprint((solve(h, w, k, choco)))\n", "from itertools import product\nimport numpy as np\nH, W, K = map(int, input().split())\n\ngrid = [[] for _ in range(H) ]\nfor i in range(H):\n  grid[i] = list(map(int, input()))\n\n#print(grid)\n\ndef init_cnt():\n  _grid = [[0] * W for _ in range(H) ]\n  _grid[0][0] = grid[0][0]\n  for w in range(1, W):\n    _grid[0][w] = _grid[0][w-1] + grid[0][w]\n  for h in range(1, H):\n    cnt_w = 0\n    for w in range(W):\n      cnt_w += grid[h][w]\n      _grid[h][w] = _grid[h-1][w] + cnt_w\n  \n  return _grid\n\n_grid = init_cnt()\n#print(_grid)\n\n# (x1, y1) ~ (x2, y2)\u306e\u5408\u8a08\ndef cnt(x1, x2, y1, y2):\n  if x1 == 0 and y1 == 0:\n    return _grid[x2][y2]\n  if x1 == 0:\n    return _grid[x2][y2] - _grid[x2][y1 -1]\n  if y1 == 0:\n    return _grid[x2][y2]- _grid[x1 - 1][y2]\n  return _grid[x2][y2] - _grid[x2][y1 - 1] - _grid[x1 - 1][y2] + _grid[x1 - 1][y1 - 1]\n\n\nans = 1010\nfor i in range(2 ** (H - 1)):\n  res = 0\n  lst = list(k for k, j in enumerate(range(H), 1) if i >> j & 1)\n  res += len(lst)\n  lst.append(H)\n \n  #print(lst)\n  y =  0\n  for w in range(1, W+1):\n    x = 0\n    flag = False\n    \n    for lst_i in lst:\n      if cnt(x, lst_i - 1 ,y ,w - 1) > K:\n        if y + 1 < w:\n          res += 1\n          y = w - 1\n        else:\n          flag = True\n        break\n        \n      x = lst_i \n    else:\n      pass\n    if flag:\n      break\n  else:\n    ans = min(ans, res)\n    \nprint(ans)", "import itertools\n# tempt\nH,W,K=list(map(int,input().split()))\nS=[input() for _ in range(H)]\n\nans=1e4 # 10000(10**4)\nfor t in itertools.product([0,1],repeat=H-1):\n    cnt=t.count(1)\n    SW=[]\n    tmp=[int(s) for s in S[0] ]\n    \n    for i, c in enumerate(t):\n        if c:\n            SW.append(tmp)\n            tmp = [int(s) for s in S[i + 1]]\n        else:\n            tmp = [tmp[j] + int(S[i + 1][j]) for j in range(W)]\n    SW.append(tmp)\n    H_ = len(SW)\n    sums = [0] * H_\n    if max(itertools.chain.from_iterable(SW)) > K:\n        continue\n    for w in range(W):\n        sumtmp = [sums[i] + SW[i][w] for i in range(H_)]\n        if max(sumtmp) > K:\n            cnt += 1\n            sums = [SW[i][w] for i in range(H_)]\n        else:\n            sums = sumtmp\n    ans = min(ans, cnt)\nprint(ans)\n", "from itertools import product\n\nH, W, K = map(int, input().split())\nl = [[0]*W for _ in range(H)]\nfor i in range(H):\n    for j, s in enumerate(input()):\n        if s==\"1\":\n            l[i][j] = 1\n\ndp = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(1, H+1):\n    for j in range(1, W+1):\n        dp[i][j] = l[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]\n\nf=lambda lx,ly,rx,ry:dp[ry][rx]-dp[ly-1][rx]-dp[ry][lx-1]+dp[ly-1][lx-1]\n\nans = H*W\nfor i in product(range(2), repeat=H-1):\n    candidate = []\n    if any(i):\n        start = 1\n        for j, k in enumerate(i, start=1):\n            if k:\n                candidate.append((start, j))\n                start = j+1\n        candidate.append((start, H))\n    else:\n        candidate.append((1, H))\n    \n    q = [1]\n    cutx = 0\n\n    while q:\n        s = q.pop()\n        for t in range(s, W+1)[::-1]:\n            if all(f(s, j, t, k)<=K for j, k in candidate):\n                if t!=W:\n                    q.append(t+1)\n                    cutx += 1\n                break\n        else:\n            cutx = H*W\n    v = cutx+sum(i)\n    ans = min(ans, v)\n\nprint(ans)", "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef main():\n    h,w,k=map(int,input().split())\n    S=[input() for _ in range(h)]\n    final_ans=10**10\n    for row_lis in range(1<<(h-1)):\n        lst=[0]*h\n        q,ans=0,0\n        for r in range(h-1):\n            if (row_lis>>r)&1==0:\n                lst[r+1]=q\n            else:\n                q+=1\n                lst[r+1]=q\n                ans+=1\n        data=[0]*h\n        for j in range(w):\n            for i in range(h):\n                data[lst[i]]+=int(S[i][j])\n                if data[lst[i]]>k:\n                    ans+=1\n                    break\n            else:\n                continue\n            data=[0]*h\n            for i in range(h):\n                data[lst[i]]+=int(S[i][j])\n                if data[lst[i]]>k:\n                    break\n            else:\n                continue\n            break\n        else:\n            final_ans=min(final_ans,ans)\n    print(final_ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "f=range\nh,w,k=map(int,input().split())\ng=[[int(i) for i in input()] for _ in f(h)]\ns=[[0]*-~w for _ in f(h+1)]\nfor i in f(h):\n  for j in f(w):\n    s[i+1][j+1]=s[i+1][j]+s[i][j+1]+g[i][j]-s[i][j]\na=h+w\nfor i in f(2**~-h):\n  u=d=l=r=c=0\n  e=[]\n  while d<h:\n    d+=1\n    if i>>d-1&1: e+=[(u,d)]; c+=1; u=d\n  e+=[(u,h)]\n  while r<w:\n    if max(s[d][r+1]-s[u][r+1]-s[d][l]+s[u][l] for u,d in e)>k:\n      if r==l: break\n      c+=1; l=r\n    r+=1\n  else: a=min(a,c)\nprint(a)", "import sys\nfrom itertools import product\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    H, W, K = list(map(int, input().split()))\n    grid = [list(input()) for _ in range(H)]\n\n    R = [[0] * (W + 1) for _ in range(H + 1)]\n    for h in range(H):\n        for w in range(W):\n            R[h + 1][w + 1] = R[h][w + 1] + R[h + 1][w] - R[h][w] + int(grid[h][w])\n\n    res = f_inf\n    for pattern in product([0, 1], repeat=H-1):\n        cut_H = [idx + 1 for idx, p in enumerate(pattern) if p == 1] + [H]\n        cnt_cut = sum(pattern)\n        left = 0\n        right = 1\n        flg = 1\n        while right <= W:\n            if not flg:\n                break\n            up = 0\n            for bottom in cut_H:\n                cnt_w = R[bottom][right] - R[bottom][left] - R[up][right] + R[up][left]\n                if cnt_w > K:\n                    if right - left == 1:\n                        flg = False\n                    cnt_cut += 1\n                    left = right - 1\n                    break\n                else:\n                    up = bottom\n            else:\n                right += 1\n        else:\n            res = min(res, cnt_cut)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from itertools import *\n\nH, W, K = list(map(int, input().split()))\nS = [list(map(int, input())) for i in range(H)]\n\ncut_min = H+W-2\n\nfor r_cut in range(H):\n  if cut_min <= r_cut:\n    continue\n  for r_pos in combinations(list(range(1, H)), r_cut):\n    r_pos = (None,)+r_pos+(None,)\n    r_blocks = [slice(*r_pos[i:i+2]) for i in range(len(r_pos)-1)]\n    \n    cut = r_cut\n    prev_sum = [0] * len(r_blocks)\n    for col in zip(*S):\n      curr_sum = [sum(col[b]) for b in r_blocks]\n      if any(map(K.__lt__, curr_sum)):\n        break\n      next_sum = [x+y for x,y in zip(prev_sum, curr_sum)]\n      if any(map(K.__lt__, next_sum)):\n        cut += 1\n        if cut_min <= cut:\n          break\n        prev_sum = curr_sum\n      else:\n        prev_sum = next_sum\n    else:\n      cut_min = cut\nprint(cut_min)\n", "h,w,kk=list(map(int,input().split()))\ns=[list(map(int,list(input()))) for i in range(h)]\nl=[]\nfor i in range(2**(h-1)):\n  ll=[0]\n  for j in range(h-1):\n    if i & 2**j:\n      ll.append(ll[-1]+1)\n    else:\n      ll.append(ll[-1])\n  l.append(ll)\n\nmc=w+h\nfor i in l:\n  c=[0 for i in range(h)]\n  cc=0\n  f=1\n  #print(i,0)\n  for j in range(w):\n    #print(c)\n    ff=0\n    for k in range(h):\n      c[i[k]]+=s[k][j]\n    for k in range(h):\n      if c[k]>kk:\n        ff=1\n        break\n    if ff:\n      cc+=1\n      c=[0 for i in range(h)]\n      for k in range(h):\n        c[i[k]]+=s[k][j]\n      for k in range(h):\n        if c[k]>kk:\n          f=1\n      if f:\n        cc=w+h\n        #print(c)\n        break\n    f=0\n  #print(cc)\n  if mc>cc+len(set(i))-1:\n    mc=cc+len(set(i))-1\nprint(mc)", "from itertools import accumulate\n\n# \u5165\u529b\nH, W, K = map(int, input().split())\nS = [list(map(int, list(input()))) for _ in range(H)]\n\n# \u8ee2\u7f6e + \u884c\u3054\u3068(\u3064\u307e\u308a\u5217\u3054\u3068)\u306e\u767d\u30c1\u30e7\u30b3\u306e\u6570\u3092\u6570\u3048\u3066\u3044\u308b\naccs = [[0]+list(accumulate(l)) for l in zip(*S)]\n\nans = float('inf')\n\nfor i in range(1 << H - 1):\n    parts = []\n    cuts = 0\n    for k in range(H - 1):\n        if i & (1 << k):\n            cuts += 1\n            parts.append(k+1)\n    \n    parts.append(H)\n    cts = [0]*len(parts)\n    for j in range(W):\n        prev = 0\n        flag1 = False\n        for idx, p in enumerate(parts):\n            c = accs[j][p] - accs[j][prev]\n            cts[idx] += c\n            if cts[idx] > K:\n                flag1 = True\n                break\n            prev = p\n        if flag1:\n            cuts += 1\n            prev = 0\n            flag2 = False\n            for idx, p in enumerate(parts):\n                c = accs[j][p] - accs[j][prev]\n                if c > K:\n                    flag2 = True\n                    break\n                cts[idx] = c\n                prev = p\n            if flag2:\n                break\n    else:\n        ans = ans if ans < cuts else cuts\n\nprint(ans)", "def z(z_dic, v: int):\n    if v in z_dic:\n        return z_dic[v]\n    z = 0\n    if v == 2:\n        z = 1\n    elif v > 2:\n        z = int(v*(v-1)/2)\n    z_dic.setdefault(v, z)\n    return z\n\n\ndef main():\n    h, w, _k = list(map(int, input().split()))\n    s = []\n    for i in range(h):\n        line = input()\n        s_line = []\n        for j in range(w):\n            s_line.append(int(line[j]))\n        s.append(s_line)\n\n    ok_cnt_min = h*w\n    op_cnt = h - 1  # \u3059\u304d\u9593\u306e\u500b\u6570\n    for i in range(2 ** op_cnt):\n        op = [False] * op_cnt\n        for j in range(op_cnt):\n            if ((i >> j) & 1):\n                op[op_cnt - 1 - j] = True\n\n        s2 =[]\n        current_sum = s[0]\n        for k in range(op_cnt):\n            if op[k]:\n                s2.append(current_sum)\n                current_sum = s[k+1]\n            else:\n                next_sum = [(current_sum[a] + s[k+1][a]) for a in range(w)]\n                current_sum = next_sum\n\n        s2.append(current_sum)\n        s2len = len(s2)\n\n        h_cut_cnt = len([x for x in op if x])\n        if h_cut_cnt >= ok_cnt_min:\n            break\n\n        st = 0\n        ed = 1\n        cut_list = []\n        dividable = True\n        for j in range(1, w+1):\n            _sum_max = 0\n            if ed <= j:\n                ed = j\n            else:\n                continue\n\n            _sum_max = max([sum(s2[_h][st:ed]) for _h in range(s2len)])\n            if _sum_max > _k:\n                if ed - st > 1:\n                    cut_list.append(ed - 1)\n                    st = ed - 1\n                else:\n                    dividable = False\n                    break\n        if not dividable:\n            continue\n        else:\n            cnt = h_cut_cnt\n            cnt += len(cut_list)\n            if cnt < ok_cnt_min:\n                ok_cnt_min = cnt\n\n    print(ok_cnt_min)\n\n\n\nmain()\n", "import numpy as np\nfrom itertools import product\nH, W, K = map(int, input().split())\nG = np.array([list(map(int, input())) for _ in range(H)])\n \nans = float('inf')\n\nfor pattern in product([0, 1], repeat=H - 1):\n    # \u30b9\u30e9\u30a4\u30b9\u3067\u6a2a\u65b9\u5411\u3078\u306e\u5272\u308a\u65b9\u3092\u8868\u73fe\u3059\u308b\n    div=[0]\n    for i, p in enumerate(pattern):\n      if p==1:\n        div= div+[i+1]\n    div += [10]       \n    \n     # \u6a2a\u65b9\u5411\u3078\u5272\u3063\u305f\u5f8c\u3001\u5404\u30d6\u30ed\u30c3\u30af\u306b\u3064\u3044\u3066\u7e26\u65b9\u5411\u306b\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u306e\u6570\u3092\u4fee\u6b63\n    rows = []\n    for i in range(len(div) - 1):\n        rows.append(np.sum(G[div[i]: div[i + 1]], axis=0))\n    \n     # \u7e26\u65b9\u5411\u306b\u3059\u3067\u306bK\u500b\u3088\u308a\u591a\u3044\u30db\u30ef\u30a4\u30c8\u30c1\u30e7\u30b3\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u5834\u5408\u306f\u3069\u3046\u306b\u3082\u306a\u3089\u306a\u3044\n    count=0\n    for r in rows:\n      if np.any(r>K):\n        count=1\n    if count==1:\n      continue\n    \n    # \u7e26\u65b9\u5411\u306b\u8caa\u6b32\u306b\u5272\u3063\u3066\u3044\u304f\n    rows = [r.tolist() for r in rows]\n    tmp_ans = 0\n    counts = [0] * len(rows)\n    w = 0\n    \n    while w<W:\n      for r in range(len(rows)):\n        counts[r] += rows[r][w]\n        \n      if any([c>K for c in counts]):\n        counts=[0] * len(rows)\n        w -=1\n        tmp_ans += 1\n      \n      w+=1\n    a=tmp_ans +len(div)-2\n    ans=min(a,ans)\n  \nprint(ans)", "from itertools import accumulate as acc\n\nH, W, K = list(map(int, input().split()))\nS = [list(map(int, list(input()))) for _ in range(H)]\n\nacc_list = [list(acc([0] + s)) for s in S]\n\ndef solve(l, x, limit):\n    part_num = len(l)-1\n    ok, ng = x, W+1\n    while abs(ok-ng) > 1:\n        mid = (ok+ng)//2\n        score = 0\n        for i in range(part_num):\n            s = 0\n            for j in range(l[i], l[i+1]):\n                # print(i, j, mid)\n                s += acc_list[j][mid] - acc_list[j][x]\n            score = max(s, score)\n        if score <= limit:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\nmin_num = 10**18\nfor i in range(1<<(H-1)):\n    l = []\n    for j in range(H-1):\n        if (i>>j)&1:\n            l.append(j+1)\n    h_split_num = len(l)\n    l = [0] + l + [H]\n    x = solve(l, 0, K)\n    w_split_num = 0\n    flag = True\n    while x < W:\n        w_split_num += 1\n        r = solve(l, x, K)\n        if x == r:\n            flag = False\n            break\n        x = r\n    if flag:\n        split_num = w_split_num + h_split_num\n        min_num = min(split_num, min_num)\n\nprint(min_num)\n", "import itertools\n\nH, W, K = list(map(int, input().split()))\nS = []\nfor _ in range(H):\n    S.append([int(s) for s in input()])\n\nans = 2000\n#itertoolsproduct\u3067\u30d3\u30c3\u30c8\u5168\u63a2\u7d22\u304c\u7c21\u6f54\u306b\u66f8\u3051\u308b\nfor t in itertools.product([0, 1], repeat=H - 1):\n    cnt = t.count(1)\n    #\u6a2a\u65b9\u5411\u306e\u5206\u5272\u306e\u56de\u6570\u3092\u6570\u3048\u3066\u3044\u308b\n    lst = [[s for s in S[0]]]\n    #\u30ea\u30b9\u30c8\u3092\u65b0\u305f\u306a\u8981\u7d20\u3068\u3057\u3066\u52a0\u3048\u308b\u304b\u3001\u305d\u308c\u3068\u3082\u4e2d\u8eab\u3092\u8db3\u3057\u5408\u308f\u305b\u308b\u3060\u3051\u304b\n    for h in range(H - 1):\n        if t[h]:\n            lst.append(S[h + 1])\n        else:\n            lst[-1] = [lst[-1][i] + S[h + 1][i] for i in range(W)]\n    L = len(lst)\n    sum_lst = [0] * L\n    for w in range(W):\n        if max(lst[i][w] for i in range(L)) > K:\n            break\n        #\u6a2a\u65b9\u5411\u306e\u5206\u5272\u3092\u7d42\u3048\u305f\u6642\u70b9\u3067\u4e00\u5217\u306bK+1\u500b\u4ee5\u4e0a\u3042\u308b\u3068\u30a2\u30a6\u30c8\n        tmp = [sum_lst[i] + lst[i][w] for i in range(L)]\n        if max(tmp) > K:\n            cnt += 1\n            sum_lst = [lst[i][w] for i in range(L)]\n        else:\n            sum_lst = tmp\n    else:\n        ans = min(ans, cnt)\nprint(ans)\n#\u3053\u306e\u30b3\u30fc\u30c9\u306f\u30eb\u30fc\u30d7\u3092\u3046\u307e\u304f\u30ea\u30b9\u30c8\u306b\u5165\u308c\u8fbc\u3093\u3067\u308b\u306e\u3067\u77ed\u304f\u898b\u3048\u3066\u3059\u3054\u3044\n#5\u670824\u65e5\n", "import itertools\n \nH,W,K=list(map(int, input().split()))\nS=[]\nfor _ in range(H):\n  S.append([int(s) for s in input()])\n \nans=2000\nfor t in itertools.product([0,1],repeat=H-1):\n  cnt=t.count(1)\n  lst=[[s for s in S[0]]]\n  for h in range(H - 1):\n    if t[h]==1:\n      lst.append(S[h+1])\n    else:\n      lst[-1]=[lst[-1][i]+S[h+1][i] for i in range(W)]\n  L=len(lst)\n  R=[0]*L\n  for w in range(W):\n    if max(lst[i][w] for i in range(L))>K:\n      break\n    tmp=[R[i]+lst[i][w] for i in range(L)]\n    if max(tmp)>K:\n      cnt+=1\n      R=[lst[i][w] for i in range(L)]\n    else:\n      R=tmp\n  else:\n    ans=min(ans,cnt)\nprint(ans)\n", "def main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    INF = 10**9\n\n    H, W, K = map(int, input().split())\n    chocolate = [ input() for _ in range(H) ]\n    \n    loop_H = range(H)\n    min_cut = INF-1\n    for div in range(1 << (H-1)):\n        # \u6a2a\u5272\u308a\u3067\u30b0\u30eb\u30fc\u30d7\u5206\u3051\n        group = [[]]\n        group_number = 0\n        for i in loop_H:\n            group[group_number].append(i)\n            if div >> i & 1:\n                group.append([])\n                group_number += 1\n        # \u7e26\u306b\u5207\u3063\u3066\u3044\u304f\n        cut = group_number\n        cnt = [0] * len(group)\n        w = 0\n        while w < W:\n            now = [0] * len(group)\n            for g in range(len(group)):\n                for i in group[g]:\n                    if chocolate[i][w] == '1':\n                        now[g] += 1\n                if now[g] > K:\n                    cut = INF\n                    break\n                if cnt[g] + now[g] > K:\n                    cut += 1\n                    w -= 1\n                    cnt = [0] * len(group)\n                    break\n                cnt[g] += now[g]\n            if cut >= min_cut:\n                break\n            w += 1\n        if cut < min_cut:\n            min_cut = cut\n    print(min_cut)\n\nmain()"]
["from collections import defaultdict\n\nn=int(input())\nd=defaultdict(dict)\nfor i in range(n):\n    x=input()\n    x=x.split()\n    if i==0:\n        P = x\n    q=int(input())\n    Con=[]\n    for j in range(q):\n        Con.append(input().split())\n    if i!=n-1:\n        input()\n    d[x[0]][x[1]]=Con\nver=[P]\nans={}\nwhile ver:\n    next_ans = {}\n    for v in ver:\n        C=d[v[0]][v[1]]\n        for n_v in C:\n            if n_v[0] not in ans and n_v[0]!=P[0]:\n                if n_v[0] in next_ans:\n                    if int(n_v[1])>int(next_ans[n_v[0]]):\n                        next_ans[n_v[0]]=n_v[1]\n                else:\n                    next_ans[n_v[0]]=n_v[1]\n    ans.update(next_ans)\n    ver=list(next_ans.items())\nl=list(ans.items())\nprint(len(l))\nl.sort()\nfor k,v in l:\n    print(k,v)\n", "from queue import Queue\n\n\ndef BFS(v):\n    nonlocal ans\n\n    stack = Queue()\n    stack.put(v)\n\n    used = {p[0]: False for p in list(graph.keys())}\n    used[v[0]] = True\n\n    while True:\n        set_ = dict()\n        st = Queue()\n\n        while not stack.empty():\n            v = stack.get()\n\n            for u in graph[v]:\n                n_ = u[0]\n                if not used[n_]:\n                    try:\n                        set_[n_] = max(set_[n_], u[1])\n                    except KeyError:\n                        set_[n_] = u[1]\n\n        for el in list(set_.items()):\n            ans.append(el)\n            st.put(el)\n            used[el[0]] = True\n\n        if st.empty():\n            break\n\n        while not st.empty():\n            stack.put(st.get())\n\n\nn = int(input())\ngraph = dict()\n\nfor i in range(n):\n    name, ver = input().split()\n    k = int(input())\n    temp = set()\n\n    for j in range(k):\n        name_, ver_ = input().split()\n        temp.add((name_, int(ver_)))\n\n    tup = (name, int(ver))\n    graph[tup] = temp\n\n    if i == 0:\n        PP = tup\n\n    if i + 1 != n:\n        input()\n\nans = list()\n\nBFS(PP)\n\nprint(len(ans))\nprint('\\n'.join([' '.join(map(str, el)) for el in sorted(ans, key=lambda x: x[0])]))\n", "# f = open(\"input.txt\")\n# def readline():\n    # return f.readline().strip()\n\ndef readline():\n    return input()\n\ndef read_project():\n    project = readline().split(\" \")\n    project[1] = int(project[1])\n    dep_num = int(readline())\n    deps = {}\n    for _ in range(0, dep_num):\n        (proj, version) = readline().split(\" \")\n        version = int(version)\n        if proj in deps:\n            deps[proj] = max(deps[proj], version)\n        else:\n            deps[proj] = version\n    \n    return (tuple(project), deps)\n    \ndef make_like_buck():\n    projects_num = int(readline())\n\n    projects = {}\n    polikarp_proj = None\n    for ind in range(0, projects_num):\n        (proj, deps) = read_project()\n        if ind == 0:\n            polikarp_proj = proj\n        projects[proj] = deps\n        if ind != projects_num - 1:\n            readline()\n\n    RESULT_DEPS = {polikarp_proj[0]: polikarp_proj[1]}\n\n    curr_proj = [polikarp_proj]\n    while len(curr_proj) > 0:\n        curr_deps = {}\n        for proj in curr_proj:\n            new_deps = projects[proj]\n            for proj in new_deps:\n                if proj in RESULT_DEPS:\n                    continue\n                if proj in curr_deps:\n                    curr_deps[proj] = max(curr_deps[proj], new_deps[proj])\n                else:\n                    curr_deps[proj] = new_deps[proj]\n\n        RESULT_DEPS = {**RESULT_DEPS, **curr_deps}\n\n        curr_proj = list(curr_deps.items())\n\n    RESULT_DEPS.pop(polikarp_proj[0])\n    \n    print(len(RESULT_DEPS))\n    items = [\"%s %s\" % x for x in sorted(list(RESULT_DEPS.items()))]\n    print(\"\\n\".join(items))\n\nmake_like_buck()", "from queue import Queue\n\n\ndef main():\n    n = int(input())\n    d = {}\n    res = {}\n    start = None\n    for i in range(n):\n        project, version = input().split()\n        version = int(version)\n        if i == 0:\n            start = project, version\n        k = int(input())\n        if project not in d:\n            d[project] = {}\n        if version not in d[project]:\n            d[project][version] = []\n        for j in range(k):\n            p, v = input().split()\n            v = int(v)\n            d[project][version].append((p, v))\n        if i != n-1:\n            input()\n    q = Queue()\n    q.put(start)\n    k = 1\n    while not q.empty():\n        append = {}\n        for i in range(k):\n            s_p, s_v = q.get()\n            for (p, v) in d[s_p][s_v]:\n                if p == start[0]:\n                    continue\n                if p in res:\n                    continue\n                if p not in append or append[p] < v:\n                    append[p] = v\n        k = len(append)\n        for p in append:\n            res[p] = append[p]\n            q.put((p, append[p]))\n\n    ans = []\n    for p in res:\n        v = res[p]\n        ans.append((p, v))\n\n    ans = sorted(ans, key= lambda z: z[0])\n    print(len(ans))\n    for (p, v) in ans:\n        print(p, v)\n\n\nmain()\n", "n = int(input())\n\nnames_set = set()\ns = {}\nnames = []\narr = [[] for j in range(n)]\ng = 0\nfor i in range(n):\n    el = input()\n    names_set.add(el.split()[0])\n    ind = 0\n    if s.get(el) is None:\n        s[el] = g\n        names.append(el)\n        g += 1\n    k = int(input())\n    for j in range(k):\n        el2 = input()\n        if s.get(el2) is None:\n            s[el2] = g\n            names.append(el2)\n            g += 1\n        arr[s.get(el)].append(s.get(el2))\n    if i != n - 1:\n        r = input()\n\nres = []\nq = []\nq.append(0)\nsp = {}\nwhile len(q):\n    el = q[0]\n    del q[0]\n    name, vers = names[el].split()\n    if name in names_set:\n        try:\n            sp[name] = max(int(vers), sp[name])\n        except:\n            sp[name] = int(vers)\n    if not len(q):\n        for i in sp:\n            names_set.remove(i)\n            new_el = []\n            new_el.append(i)\n            new_el.append(sp[i])\n            res.append(new_el[:])\n            ind = s[str(new_el[0]) + \" \" + str(new_el[1])]\n            for j in range(len(arr[ind])):\n                p = arr[ind][j]\n                q.append(p)\n        sp = {}\n\nres = res[1:]\nres.sort()\nprint(len(res))\nfor i in res:\n    print(i[0], i[1])", "n = int(input())\nprojects = {}\nroot = None\n\nfor i in range(n):\n    name, v = input().split()\n    v = int(v)\n    projects[ (name, v) ] = []\n    m = int(input())\n    \n    for j in range(m):\n        nn, vv = input().split()\n        vv = int(vv)\n        projects[ (name, v) ].append( (nn, vv) )\n        \n    if i < n - 1:\n        input()\n        \n    if not i:\n        root = (name, v)\n        \nq = set( [root, ] )\nans = {}\n\nwhile q:\n    temp = {}\n    \n    for u in q:\n        for v in projects[u]:\n            if v[0] not in ans and v[0] != root[0]:\n                if v[0] not in temp:\n                    temp[v[0]] = v[1]\n                else:\n                    temp[v[0]] = max(temp[v[0]], v[1])\n    \n    ans.update( temp.items() ) \n    q = set( temp.items() )\n    \nprint(len(ans))\nprint('\\n'.join( list( map(lambda x: ' '.join(str(c) for c in x), sorted( list(ans.items()), key = lambda item: item[0] )))))", "N=int(input())\nSlide=dict()\nSlideList=[list()]*N\nItogInformation=set()\nGoodNameTags=set()\n\nNewName,NewVer=input().split()\nNewVer=int(NewVer)\n\nGoodNameTags.add(NewName)\n\nSlide[0]=NewName+' '+str(NewVer)\nSlide[NewName+' '+str(NewVer)]=0\nNewNum=int(input())\nSlideList[0]=[0]*(NewNum+2)\nSlideList[0][1]=NewNum\n\nfor i in range(1,NewNum+1):\n    Name,Ver=input().split()\n    SlideList[0][i+1]=Name+' '+Ver\n    \nfor j in range(1,N):\n    input()\n    NewName,NewVer=input().split()\n    NewVer=int(NewVer)\n    Slide[j]=NewName+' '+str(NewVer)\n    Slide[NewName+' '+str(NewVer)]=j\n    NewNum=int(input())\n    SlideList[j]=[0]*(NewNum+2)\n    SlideList[j][1]=NewNum\n    for i in range(1,NewNum+1):\n        Name,Ver=input().split()\n        SlideList[j][i+1]=Name+' '+Ver\n\nListOfNeed=set()\nListOfRead=set()\nListOfRead.add(Slide[0])\n\nwhile len(ListOfRead)!=0:\n    ListOfNeed=ListOfRead.copy()\n    ListOfRead=set()\n    found=dict()\n    for i in ListOfNeed:\n        for j in range(SlideList[Slide[i]][1]):\n            Name,Ver=SlideList[Slide[i]][j+2].split()\n            Ver=int(Ver)\n            key=found.pop(Name, -1)\n            if key==-1 or key<Ver:\n                found[Name]=Ver\n            else:\n                found[Name]=key\n    for i in list(found.keys()):\n        if not (i in GoodNameTags):\n            GoodNameTags.add(i)\n            ListOfRead.add(i+' '+str(found[i]))\n            ItogInformation.add(i+' '+str(found[i]))\n    \nOtvet=list(ItogInformation)\nOtvet.sort()            \n\nprint(len(Otvet))\nfor i in range(len(Otvet)):\n    print(Otvet[i])\n\n", "n = int(input())\n\nd = {}\n\nfor x in range(n):\n    if x == 0:\n        L, R = map(str, input().split())\n        R = int(R)\n        l = L\n        r = R\n        if not (l, int(r)) in d:\n            d[(l, int(r))] = []\n        m = int(input())\n        for y in range(m):\n            l1, r1 = map(str, input().split())\n            d[(l, int(r))].append((l1, int(r1)))\n        if x != n - 1:\n            s = input()\n    else:\n        l, r = map(str, input().split())\n        if not (l, int(r)) in d:\n            d[(l, int(r))] = []\n        m = int(input())\n        for y in range(m):\n            l1, r1 = map(str, input().split())\n            d[(l, int(r))].append((l1, int(r1)))\n        if x != n - 1:\n            s = input()\n\nlst = []\narray = [L]\n\n#print(d)\ntemp1 = [(L, R)]\ntemp2 = []\nk1 = 0\nk2 = 1\nwhile k1 < len(temp1) or k2 < len(temp2):\n    if k2 > len(temp2):\n        while k1 < len(temp1):\n            for (a, b) in d[temp1[k1]]:\n                temp2.append((a, -b))\n            k1 += 1\n        temp2.sort()\n        temp = []\n        for (a, b) in temp2:\n            if not a in array:\n                array.append(a)\n                lst.append((a, -b))\n                temp.append((a, -b))\n        temp2 = temp[:]\n        temp1 = []\n        k1 = 1\n        k2 = 0\n    elif k1 > len(temp1):\n        while k2 < len(temp2):\n            for (a, b) in d[temp2[k2]]:\n                temp1.append((a, -b))\n            k2 += 1\n        temp1.sort()\n        temp = []\n        for (a, b) in temp1:\n            if not a in array:\n                array.append(a)\n                lst.append((a, -b))\n                temp.append((a, -b))\n        temp1 = temp[:]\n        temp2 = []\n        k2 = 1\n        k1 = 0        \n\nprint(len(lst))\nlst.sort()\nfor (a, b) in lst:\n    print(a, b)", "levels = []\n\nconnect = dict()\n\nn = int(input())\nk = input().split()\nlevels.append({k[0]: int(k[1])})\nconnect[k[0]+' '+str(k[1])] = []\nd = int(input())\n\nfor i in range(d):\n    connect[k[0]+' '+str(k[1])].append(input())\n\n\nfor i in range(n-1):\n    s = input()\n    s = input()\n    connect[s] = []\n    k = int(input())\n    for j in range(k):\n        connect[s].append(input())\n\nlev = 0\nwhile len(levels[len(levels)-2]):\n    levels.append(dict())\n    for projname in levels[lev]:\n        listing = connect[projname + ' ' + str(levels[lev][projname])]\n        for i in listing:\n            name = i.split()\n            gov = True\n            #\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u0435\u0441\u0442\u044c \u043b\u0438 \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u0432 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0445 \u0443\u0440\u043e\u0432\u043d\u044f\u0445\n            for j in range(lev+1):\n                if name[0] in levels[j]:\n                    gov = False\n                    break\n            #\u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u0435\u0441\u0442\u044c \u043b\u0438 \u044d\u0442\u043e\u0442 \u043f\u0440\u043e\u0435\u043a\u0442 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u043c \u0443\u0440\u043e\u0432\u043d\u0435\n            if gov:\n                if name[0] not in levels[lev+1]:\n                    levels[lev + 1][name[0]] = int(name[1])\n                else:\n                    found = levels[lev + 1][name[0]]\n                    levels[lev+1][name[0]] = max(int(name[1]), found)\n    lev += 1\n\nres = {}\nfor i in range(1, len(levels)-2):\n    res.update(levels[i])\nkeys = list(res.keys())\nkeys.sort()\nprint(len(keys))\nfor i in keys:\n    print(i+' '+ str(res[i]))", "# python3\n\ndef read_project_name():\n    name, version = input().split()\n    return (name, int(version))\n\n\ndef read_project():\n    project = read_project_name()\n    deps_size = int(input())\n\n    deps = [read_project_name() for __ in range(deps_size)]\n\n    return (project, deps)\n\n\ndef main():\n    dependencies = dict()\n    n = int(input()) - 1\n\n    main_project, deps = read_project()\n    dependencies[main_project] = deps\n    queue = (main_project,)\n\n    while n:\n        n -= 1\n        input()\n        project, deps = read_project()\n        dependencies[project] = deps\n\n    selected = dict()\n    while queue:\n        new_selected = dict()\n        for (name, version) in queue:\n            if name not in selected:\n                old = new_selected.get(name, -1)\n                new_selected[name] = max(old, version)\n\n        queue = list()\n        for project in list(new_selected.items()):\n            queue.extend(dependencies[project])\n\n        selected.update(new_selected)\n\n    del selected[main_project[0]]\n    print(len(selected))\n    for (name, version) in sorted(selected.items()):\n        print(name, version)\n\n\nmain()\n", "# python3\n\ndef read_project_name():\n    name, version = input().split()\n    return (name, int(version))\n\n\ndef read_project():\n    project = read_project_name()\n    deps = list()\n\n    dependencies = int(input())\n    while(dependencies):\n        dependencies -= 1\n        deps.append(read_project_name())\n\n    return (project, tuple(deps))\n\n\ndef main():\n    dependencies = dict()\n    n = int(input()) - 1\n\n    main_project, deps = read_project()\n    dependencies[main_project] = deps\n    queue = (main_project, )\n\n    while n:\n        n -= 1\n        input()\n        project, deps = read_project()\n        dependencies[project] = deps\n\n    selected = dict()\n    while queue:\n        new_selected = dict()\n        for (name, version) in queue:\n            if name not in selected:\n                old = new_selected.get(name, -1)\n                new_selected[name] = max(old, version)\n\n        queue = list()\n        for project in new_selected.items():\n            queue.extend(dependencies[project])\n\n        selected.update(new_selected)\n\n    del selected[main_project[0]]\n    print(len(selected))\n    for (project, ver) in sorted(selected.items()):\n        print(project, ver)\n\n\nmain()", "# python3\n\ndef read_project_name():\n    name, version = input().split()\n    return (name, int(version))\n\n\ndef read_project():\n    project = read_project_name()\n\n    deps_size = int(input())\n    deps = [read_project_name() for __ in range(deps_size)]\n\n    return (project, deps)\n\n\ndef main():\n    dependencies = dict()\n    n = int(input()) - 1\n\n    main_project, deps = read_project()\n    dependencies[main_project] = deps\n    queue = (main_project,)\n\n    for __ in range(n):\n        input()\n        project, deps = read_project()\n        dependencies[project] = deps\n\n    selected = dict()\n    while queue:\n        new_selected = dict()\n        for (name, version) in queue:\n            if name not in selected:\n                old = new_selected.get(name, 0)\n                new_selected[name] = max(old, version)\n\n        queue = list()\n        for project in list(new_selected.items()):\n            queue.extend(dependencies[project])\n\n        selected.update(new_selected)\n\n    del selected[main_project[0]]\n    print(len(selected))\n    for (name, version) in sorted(selected.items()):\n        print(name, version)\n\n\nmain()\n", "def read_pack():\n    name, ver = input().strip().split()\n    return (name, int(ver))\n\nn = int(input())\ndeps = dict()\nfor i in range(n):\n    pack = read_pack()\n    if not i:\n        root = pack\n    dep_n = int(input())\n    deps[pack] = [read_pack() for _ in range(dep_n)]\n    if i != n - 1:\n        input()\n\nqueue = [(root, 0)]\ntaken = {root[0]: (root[1], 0)}\nfor pack, level in queue:\n    # pack_deps = sorted(deps[pack], key=lambda x: x[1], reverse=True)\n    for dep in deps[pack]:\n        if dep[0] not in taken:\n            taken[dep[0]] = (dep[1], level + 1)\n            queue.append((dep, level + 1))\n        elif taken[dep[0]][1] == level + 1 and taken[dep[0]][0] < dep[1]:\n            index = queue.index(((dep[0], taken[dep[0]][0]), level + 1))\n            taken[dep[0]] = (dep[1], level + 1)\n            queue[index] = (dep, level + 1)\n\ndel taken[root[0]]\n\nprint(len(taken))\n\nfor d in sorted(taken):\n    print(d, taken[d][0])", "def read_pack():\n    name, ver = input().split()\n    return (name, int(ver))\n\nn = int(input())\ndeps = dict()\nfor i in range(n):\n    pack = read_pack()\n    if not i:\n        root = pack\n    dep_n = int(input())\n    deps[pack] = [read_pack() for _ in range(dep_n)]\n    if i != n - 1:\n        input()\n\nqueue = [(root, 0)]\ntaken = {root[0]: (root[1], 0)}\nfor pack, level in queue:\n    # pack_deps = sorted(deps[pack], key=lambda x: x[1], reverse=True)\n    for dep in deps[pack]:\n        if dep[0] not in taken:\n            taken[dep[0]] = (dep[1], level + 1)\n            queue.append((dep, level + 1))\n        elif taken[dep[0]][1] == level + 1 and taken[dep[0]][0] < dep[1]:\n            index = queue.index(((dep[0], taken[dep[0]][0]), level + 1))\n            taken[dep[0]] = (dep[1], level + 1)\n            queue[index] = (dep, level + 1)\n\ndel taken[root[0]]\n\nprint(len(taken))\n\nfor d in sorted(taken):\n    print(d, taken[d][0])", "def read_pack():\n    name, ver = input().strip().split()\n    return (name, int(ver))\n\nn = int(input())\ndeps = dict()\nfor i in range(n):\n    pack = read_pack()\n    if not i:\n        root = pack\n    dep_n = int(input())\n    deps[pack] = [read_pack() for _ in range(dep_n)]\n    if i != n - 1:\n        input()\n\nqueue = [(root, 0)]\ntaken = {root[0]: (root[1], 0)}\nfor pack, level in queue:\n    if pack[0] in taken and pack[1] != taken[pack[0]][0]:\n        continue\n    for dep in deps[pack]:\n        if dep[0] not in taken or taken[dep[0]][1] == level + 1 and taken[dep[0]][0] < dep[1]:\n            taken[dep[0]] = (dep[1], level + 1)\n            queue.append((dep, level + 1))\n\ndel taken[root[0]]\n\nprint(len(taken))\n\nfor d in sorted(taken):\n    print(d, taken[d][0])", "def bfs(polycarp, all_projects, existed_projects):\n    # print(polycarp)\n    # print(all_projects)\n    # print(existed_projects)\n\n    queue0 = {polycarp[0]: polycarp[1]}\n    queue1 = {}\n\n    while queue0:\n        for p in list(queue0.items()):\n            existed_projects[p[0]] = p[1]\n\n        for pp in list(queue0.items()):\n            for p in all_projects[pp]:\n                if p[0] not in existed_projects:\n                    if p[0] not in queue1:\n                        queue1[p[0]] = p[1]\n                    else:\n                        queue1[p[0]] = max(queue1[p[0]], p[1])\n                else:\n                    continue\n\n        queue0, queue1 = queue1, {}\n\n\ndef main():\n    n = int(input())\n    all_projects = {}\n    for _ in range(n):\n        name, version = input().split()\n        version = int(version)\n        if _ == 0:\n            polycarp = (name, version)\n        nn = int(input())\n        all_projects[(name, version)] = []\n        for _2 in range(nn):\n            name2, version2 = input().split()\n            version2 = int(version2)\n            all_projects[(name, version)].append((name2, version2))\n        if _ != n - 1:\n            input()\n\n    existed_projects = {}\n    bfs(polycarp, all_projects, existed_projects)\n\n    print(len(existed_projects) - 1)\n    for name in sorted(existed_projects.keys()):\n        if name != polycarp[0]:\n            print(name, existed_projects[name])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\n\nd = {}\n\nfor x in range(n):\n    l, r = list(map(str, input().split()))\n    r = int(r)\n    if x == 0:\n        L = l\n        R = r\n    if not (l, r) in d:\n        d[(l, r)] = []\n    m = int(input())\n    for y in range(m):\n        l1, r1 = list(map(str, input().split()))\n        d[(l, r)].append((l1, int(r1)))\n    if x != n - 1:\n        s = input()\n\nlst = []\narray = [L]\ntemp1 = [(L, R)]\ntemp2 = []\nk1 = 0\nk2 = 1\nwhile k1 < len(temp1) or k2 < len(temp2):\n    if k2 > len(temp2):\n        while k1 < len(temp1):\n            for (a, b) in d[temp1[k1]]:\n                temp2.append((a, -b))\n            k1 += 1\n        temp2.sort()\n        temp = []\n        for (a, b) in temp2:\n            if not a in array:\n                array.append(a)\n                lst.append((a, -b))\n                temp.append((a, -b))\n        temp2 = temp[:]\n        temp1 = []\n        k1 = 1\n        k2 = 0\n    elif k1 > len(temp1):\n        while k2 < len(temp2):\n            for (a, b) in d[temp2[k2]]:\n                temp1.append((a, -b))\n            k2 += 1\n        temp1.sort()\n        temp = []\n        for (a, b) in temp1:\n            if not a in array:\n                array.append(a)\n                lst.append((a, -b))\n                temp.append((a, -b))\n        temp1 = temp[:]\n        temp2 = []\n        k2 = 1\n        k1 = 0\n        \nlst.sort()\nprint(len(lst))\nfor (a, b) in lst:\n    print(a, b)\n", "from collections import defaultdict\n\n\ndef rp():\n    s = input().split()\n    return (s[0], int(s[1]))\n\nps = {}\nn = int(input())\n\nfor i in range(n):\n    p = rp()\n    d = []\n    for _ in range(int(input())):\n        d += [rp()]\n    ps[p] = d\n    if i != n - 1:\n        input()\n\nroot = list(ps.keys())[0]\nq = [(root, 0)]\nu = {root[0]: (root[1], 0)}\n\nfor i, l in q:\n    isp = i\n    if isp[0] in u and isp[1] != u[isp[0]][0]:\n        continue\n    for p in ps[i]:\n        psp = p\n        if psp[0] not in u or u[psp[0]][1] == l + 1 and u[psp[0]][0] < psp[1]:\n            u[psp[0]] = (psp[1], l + 1)\n            q.append((psp, l + 1))\n\ndel u[root[0]]\n\nprint(len(u))\nfor i in sorted(u):\n    print(i, u[i][0])\n", "from collections import defaultdict\n\ndef rp():\n    s = input().split()\n    return (s[0], int(s[1]))\n\nps = {}\nn = int(input())\n\nfor i in range(n):\n    p = rp()\n    d = []\n    for _ in range(int(input())):\n        d += [rp()]\n    ps[p] = d\n    if i != n - 1:\n        input()\n\nroot = list(ps.keys())[0]\nq = [(root, 0)]\nu = {root[0]: (root[1], 0)}\n\nfor i, l in q:\n    isp = i\n    if isp[0] in u and isp[1] != u[isp[0]][0]:\n        continue\n    for p in ps[i]:\n        psp = p\n        if psp[0] not in u or u[psp[0]][1] == l + 1 and u[psp[0]][0] < psp[1]:\n            u[psp[0]] = (psp[1], l + 1)\n            q.append((psp, l + 1))\n\ndel u[root[0]]\n\nprint(len(u))\nfor i in sorted(u):\n    print(i, u[i][0])", "from collections import defaultdict\n\n\n\ndef rp():\n\n    s = input().split()\n\n    return (s[0], int(s[1]))\n\n\n\nps = {}\n\nn = int(input())\n\n\n\nfor i in range(n):\n\n    p = rp()\n\n    d = []\n\n    for _ in range(int(input())):\n\n        d += [rp()]\n\n    ps[p] = d\n\n    if i != n - 1:\n\n        input()\n\n\n\nroot = list(ps.keys())[0]\n\nq = [(root, 0)]\n\nu = {root[0]: (root[1], 0)}\n\n\n\nfor i, l in q:\n\n    isp = i\n\n    if isp[0] in u and isp[1] != u[isp[0]][0]:\n\n        continue\n\n    for p in ps[i]:\n\n        psp = p\n\n        if psp[0] not in u or u[psp[0]][1] == l + 1 and u[psp[0]][0] < psp[1]:\n\n            u[psp[0]] = (psp[1], l + 1)\n\n            q.append((psp, l + 1))\n\n\n\ndel u[root[0]]\n\n\n\nprint(len(u))\n\nfor i in sorted(u):\n\n    print(i, u[i][0])\n\n\n\n# Made By Mostafa_Khaled\n", "def scan_project():\n    name, version_str = input().split()\n    return (name, int(version_str))\n\nn = int(input())\nprojects, depends = [], {}\nfor i in range(n):\n    if i > 0:\n        input()\n    project = scan_project()\n    projects.append(project)\n    depends[project] = [scan_project() for j in range(int(input()))]\n\nroot_name, root_version = projects[0]\nlevel_depends = [projects[0]]\nall_depends = {root_name : root_version}\nwhile level_depends:\n    level_depends = list(set([(name, version) for project in level_depends\n        for name, version in depends[project] if name not in all_depends]))\n    for name, version in sorted(level_depends):\n        all_depends[name] = version\n    level_depends = [(name, version) for name, version in level_depends\n                     if all_depends[name] == version]\n\nall_depends.pop(root_name)\nprint(len(all_depends))\nfor name in sorted(all_depends):\n    print(name, all_depends[name])\n", "def scan_project():\n    name, version_str = input().split()\n    return (name, int(version_str))\n\nn = int(input())\nprojects, depends = [], {}\nfor i in range(n):\n    if i > 0:\n        input()\n    project = scan_project()\n    projects.append(project)\n    depends[project] = [scan_project() for j in range(int(input()))]\n\nroot_name, root_version = projects[0]\nlevel_depends = [projects[0]]\nall_depends = {root_name : root_version}\nwhile level_depends:\n    level_depends = list(sorted(set([(name, version) for proj in level_depends\n            for name, version in depends[proj] if name not in all_depends])))\n    for name, version in sorted(level_depends):\n        all_depends[name] = version\n    level_depends = [(name, version) for name, version in level_depends\n                     if all_depends[name] == version]\n\nall_depends.pop(root_name)\nprint(len(all_depends))\nfor name in sorted(all_depends):\n    print(name, all_depends[name])\n", "def scan_project():\n    name, version_str = input().split()\n    return (name, int(version_str))\n\nn = int(input())\nprojects, depends = [], {}\nfor i in range(n):\n    if i > 0:\n        input()\n    project = scan_project()\n    projects.append(project)\n    depends[project] = [scan_project() for j in range(int(input()))]\n\nroot_name, root_version = projects[0]\nlevel_depends = [projects[0]]\nall_depends = {root_name : root_version}\nwhile level_depends:\n    level_depends = list(sorted(set([(name, version) for proj in level_depends\n            for name, version in depends[proj] if name not in all_depends])))\n    for name, version in level_depends:\n        all_depends[name] = version\n    level_depends = [(name, version) for name, version in level_depends\n                     if all_depends[name] == version]\n\nall_depends.pop(root_name)\nprint(len(all_depends))\nfor name in sorted(all_depends):\n    print(name, all_depends[name])\n", "def scan_project():\n    name, version_str = input().split()\n    return (name, int(version_str))\n\nn = int(input())\nprojects, depends = [], {}\nfor i in range(n):\n    if i > 0:\n        input()\n    project = scan_project()\n    projects.append(project)\n    depends[project] = [scan_project() for j in range(int(input()))]\n\nroot_name, root_version = projects[0]\nlevel_depends = [projects[0]]\nall_depends = {root_name : root_version}\nwhile level_depends:\n    level_depends = list(set((name, version) for project in level_depends\n            for name, version in depends[project] if name not in all_depends))\n    for name, version in sorted(level_depends):\n        all_depends[name] = version\n    level_depends = [(name, version) for name, version in level_depends\n                     if all_depends[name] == version]\n\nall_depends.pop(root_name)\nprint(len(all_depends))\nfor name in sorted(all_depends):\n    print(name, all_depends[name])\n"]
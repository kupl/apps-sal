["import sys\nfrom collections import deque as dq\nn = int(input())\n\nind = 0\ninp = [int(x)-1 for line in sys.stdin.readlines() for x in line.split()]\n\ncoupl = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = inp[ind],inp[ind+1]\n    ind+=2\n    coupl[a].append(b)\n    coupl[b].append(a)\n\nQ = dq()\nfound = [False]*n\nmaster = 0\nfound[master] = True\n\ndia1 = 0\nQ.append(master)\nwhile Q:\n    node = Q.popleft()\n    dia1 = node\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append(nei)\n\n\ndia2 = 0\nQ.append((dia1,0))\ndist1 = [0]*n\nfound = [False]*n\nfound[dia1] = True\nwhile Q:\n    node,d = Q.popleft()\n    dia2 = node\n    dist1[node]=d\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append((nei,d+1))\n\nQ = []\nQ.append((dia2,0))\ndist2 = [0]*n\nfound = [False]*n\nfound[dia2] = True\nwhile Q:\n    node,d = Q.pop()\n    dist2[node]=d\n    for nei in coupl[node]:\n        if not found[nei]:\n            found[nei] = True\n            Q.append((nei,d+1))\n\nneigs = [0]*n\n\nleaves = []\nfor i in range(n):\n    if i != dia1 and i != dia2 and len(coupl[i])==1:\n        leaves.append(i)\n    neigs[i]=len(coupl[i])\npoints = 0\nlista = []\n\nwhile leaves:\n    node = leaves.pop()\n    if dist1[node]<dist2[node]:\n        lista.append((dia2,node,node))\n        points += dist2[node]\n    else:\n        lista.append((dia1,node,node))\n        points += dist1[node]\n    for nei in coupl[node]:\n        neigs[nei]-=1\n        if neigs[nei]==1:\n            leaves.append(nei)\nleaves.append(dia2)\nwhile leaves:\n    node = leaves.pop()\n    lista.append((dia1,node,node))\n    points += dist1[node]\n    for nei in coupl[node]:\n        neigs[nei]-=1\n        if neigs[nei]==1:\n            leaves.append(nei)\nprint(points)\nfor l in lista:\n    a,b,c = l\n    print(a+1,b+1,c+1)\n", "import sys\n\n\ndef main():\n    n = int(input())\n\n    edges = list(map(int, sys.stdin.read().split()))\n    tree_edges = dict()\n    for i in range(n):\n        tree_edges[i + 1] = set()\n\n    for i in range(0, len(edges) - 1, 2):\n        tree_edges[edges[i]].add(edges[i + 1])\n        tree_edges[edges[i + 1]].add(edges[i])\n\n    init_distants = [-1] * (n + 1)\n\n    queue = [1]\n    init_distants[1] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if init_distants[next_vertex] == -1:\n                    init_distants[next_vertex] = init_distants[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    head = init_distants.index(max(init_distants))\n    distants_from_head = [-1] * (n + 1)\n    queue = [head]\n\n    distants_from_head[head] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_head[next_vertex] == -1:\n                    distants_from_head[next_vertex] = distants_from_head[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    tail = distants_from_head.index(max(distants_from_head))\n    distants_from_tail = [-1] * (n + 1)\n    queue = [tail]\n\n    distants_from_tail[tail] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_tail[next_vertex] == -1:\n                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    path_len_sum = 0\n    removal_history = list()\n\n    process_queue = []\n\n    for vertex, adj in list(tree_edges.items()):\n        if len(adj) == 1:\n            process_queue.append(vertex)\n\n    while process_queue:\n        next_queue = []\n\n        for leaf in process_queue:\n\n            if leaf == head or leaf == tail:\n                continue\n\n            if distants_from_tail[leaf] > distants_from_head[leaf]:\n                path_len_sum += distants_from_tail[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, tail))\n            else:\n                path_len_sum += distants_from_head[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n        process_queue = next_queue\n\n    process_queue = [tail]\n\n    while process_queue:\n        leaf = process_queue[0]\n\n        if leaf == head:\n            continue\n\n        path_len_sum += distants_from_head[leaf]\n        new_leaves = []\n\n        for w in tree_edges[leaf]:\n            tree_edges[w].remove(leaf)\n            if len(tree_edges[w]) == 1:\n                new_leaves.append(w)\n        process_queue = new_leaves\n        removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n\n    print(str(path_len_sum))\n    sys.stdout.write(\"\\n\".join(removal_history))\n    sys.stdout.write(\"\\n\")\n\n\nmain()\n", "import sys\n\n\ndef main():\n    n = int(input())\n\n    edges = list(map(int, sys.stdin.read().split()))\n    tree_edges = dict()\n    for i in range(n):\n        tree_edges[i + 1] = set()\n\n    for i in range(0, len(edges) - 1, 2):\n        tree_edges[edges[i]].add(edges[i + 1])\n        tree_edges[edges[i + 1]].add(edges[i])\n\n    init_distants = [-1] * (n + 1)\n\n    queue = [1]\n    init_distants[1] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if init_distants[next_vertex] == -1:\n                    init_distants[next_vertex] = init_distants[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    head = init_distants.index(max(init_distants))\n    distants_from_head = [-1] * (n + 1)\n    queue = [head]\n\n    distants_from_head[head] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_head[next_vertex] == -1:\n                    distants_from_head[next_vertex] = distants_from_head[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    tail = distants_from_head.index(max(distants_from_head))\n    distants_from_tail = [-1] * (n + 1)\n    queue = [tail]\n\n    distants_from_tail[tail] = 0\n\n    while queue:\n        next_queue = []\n        for process in queue:\n            for next_vertex in tree_edges[process]:\n                if distants_from_tail[next_vertex] == -1:\n                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1\n                    next_queue.append(next_vertex)\n        queue = next_queue\n\n    path_len_sum = 0\n    removal_history = list()\n\n    process_queue = []\n\n    for vertex, adj in tree_edges.items():\n        if len(adj) == 1:\n            process_queue.append(vertex)\n\n    while process_queue:\n        next_queue = []\n\n        for leaf in process_queue:\n\n            if leaf == head or leaf == tail:\n                continue\n\n            if distants_from_tail[leaf] > distants_from_head[leaf]:\n                path_len_sum += distants_from_tail[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, tail))\n            else:\n                path_len_sum += distants_from_head[leaf]\n                new_leaves = []\n\n                for w in tree_edges[leaf]:\n                    tree_edges[w].remove(leaf)\n                    if len(tree_edges[w]) == 1:\n                        new_leaves.append(w)\n                next_queue.extend(new_leaves)\n                removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n        process_queue = next_queue\n\n    process_queue = [tail]\n\n    while process_queue:\n        leaf = process_queue[0]\n\n        if leaf == head:\n            continue\n\n        path_len_sum += distants_from_head[leaf]\n        new_leaves = []\n\n        for w in tree_edges[leaf]:\n            tree_edges[w].remove(leaf)\n            if len(tree_edges[w]) == 1:\n                new_leaves.append(w)\n        process_queue = new_leaves\n        removal_history.append(\"{0} {1} {0}\".format(leaf, head))\n\n    print(str(path_len_sum))\n    sys.stdout.write(\"\\n\".join(removal_history))\n    sys.stdout.write(\"\\n\")\n\n\nmain()"]
["def nck(n, k, cache = {}):\n    if k > n or k < 0: return 0\n    if k == 0 or k == n: return 1\n    if k*2 > n: k = n-k\n    if (n, k) in cache: return cache[(n, k)]\n\n    z = cache[(n, k)] = nck(n-1, k-1) + nck(n-1, k)\n    return z\n\ndef bits(n):\n    b = 0\n    while n:\n        if n&1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        if (n>>b)&1:\n            z += nck(b, k-c)\n            c += 1\n        if not k: break\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    lo, hi = 1, 10**18\n    while lo < hi:\n        mi = (lo+hi)//2\n        if count(2*mi, k) - count(mi, k) < m:\n            lo = mi+1\n        else:\n            hi = mi\n    return hi\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))", "def dfs(n, k, cache = {}):\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\n    if k > n or k < 0: return 0\n    # if num bits is 0 or num bits is equivalent to the number's bits\n    if k == 0 or k == n: return 1\n    if k*2 > n: k = n-k\n    # Check is already calculated\n    if (n, k) in cache: return cache[(n, k)]\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\n    return z\n\ndef bits(n):\n    b = 0\n    while n:\n        if n&1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        # Taking n and checking if bit is 1 or not\n        if (n>>b)&1:\n            z += dfs(b, k-c)\n            c += 1\n        if not k: break\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    # Binary Search for number 1-10^18\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low+high)//2\n        if count(2*mid, k) - count(mid, k) < m:\n            low = mid+1\n        else:\n            high = mid\n    return high\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))", "def dfs(n, k, cache = {}):\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\n    if k > n or k < 0: return 0\n    # if num bits is 0 or num bits is equivalent to the number's bits\n    if k == 0 or k == n: return 1\n    # \n    # if k*2 > n: k = n-k\n    # Check is already calculated\n    if (n, k) in cache: return cache[(n, k)]\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\n    return z\n\ndef bits(n):\n    b = 0\n    while n:\n        if n&1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        # Taking n and checking if bit is 1 or not\n        if (n>>b)&1:\n            z += dfs(b, k-c)\n            c += 1\n        if not k: break\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    # Binary Search for number 1-10^18\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low+high)//2\n        if count(2*mid, k) - count(mid, k) < m:\n            low = mid+1\n        else:\n            high = mid\n    return high\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))", "def dfs(n, k, cache = {}):\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\n    if k > n or k < 0: return 0\n    # if num bits is 0 or num bits is equivalent to the number's bits\n    if k == 0 or k == n: return 1\n    # This optimization is not necessary but flips the 0s and the 1s\n    # if k*2 > n: k = n-k\n    # Check is already calculated\n    if (n, k) in cache: return cache[(n, k)]\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\n    return z\n\ndef bits(n):\n    b = 0\n    while n:\n        if n&1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        # Taking n and checking if certain bit is 1 or not\n        # This sums for every mod power of 2 that exists to account for every case\n        if (n>>b)&1:\n            # calculates by subtracting for bits not accounted for\n            z += dfs(b, k-c)\n            c += 1\n        # if not k: break\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    # Binary Search for number 1-10^18\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low+high)//2\n        if count(2*mid, k) - count(mid, k) < m:\n            low = mid+1\n        else:\n            high = mid\n    return high\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))", "def dfs(n, k, cache = {}):\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\n    if k > n or k < 0: return 0\n    # if num bits is 0 or num bits is equivalent to the number's bits\n    if k == 0 or k == n: return 1\n    # This optimization is not necessary but flips the 0s and the 1s\n    # if k*2 > n: k = n-k\n    # Check is already calculated\n    if (n, k) in cache: return cache[(n, k)]\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\n    return z\n\ndef bits(n):\n    # counts number of 1s in the number\n    b = 0\n    while n:\n        if n & 1: b += 1\n        n >>= 1\n    return b\n\ndef count(n, k):\n    z, b, c = 0, 63, 0\n    for b in reversed(range(64)):\n        # Taking n and checking if certain bit is 1 or not\n        # This sums for every mod power of 2 that exists to account for every case\n        if (n>>b)&1:\n            # calculates by subtracting for bits not accounted for\n            z += dfs(b, k-c)\n            c += 1\n        # Unnecessary code\n        # if not k: break\n    # if original number has same number of 1s as digits required, add 1\n    return z + (bits(n) == k)\n\ndef solve(m, k):\n    # Binary Search for number 1-10^18\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low+high)//2\n        if count(2*mid, k) - count(mid, k) < m:\n            low = mid+1\n        else:\n            high = mid\n    return high\n\nm, k = [int(x) for x in input().split()]\nprint(solve(m, k))", "from math import factorial as f\ndef C(n, m):\n    if n < m: return 0\n    return f(n) // ( f(n - m ) * f(m) )\n\nm, k = list(map(int, input().split()))\nans = 1\nfor bit in reversed(list(range(65))):\n    if k == 0:\n        break\n    if C(bit, k - 1) < m:\n        ans += ( 1 << bit )\n        m -= C(bit, k - 1)\n        k -= 1\nprint(ans)\n", "comb = [[0 for i in range(67)] for j in range(67)]\n\nfor i in range(67):\n    comb[i][0], comb[i][i] = 1, 1\n    for j in range(1, i):\n        comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j]\n\ndef calc(x):\n    cnt   = 0\n    digit = []\n    while (x > 0):\n        digit.append(x % 2)\n        x  //= 2\n        cnt += 1\n    ans, one = 0, 0\n    for i in reversed(list(range(cnt))):\n        if (digit[i] == 1):\n            if (k - one >= 0):\n                ans += comb[i][k - one]\n            one += 1\n    return ans\n\nm, k = list(map(int, input().split()))\n\nlcur, rcur = 0, 2 ** 64\nwhile (lcur + 2 <= rcur):\n    mid = (lcur + rcur) // 2\n    if (calc(mid * 2) - calc(mid) < m):\n        lcur = mid\n    else:\n        rcur = mid\n\nprint(rcur)\n\n", "MX_BIT = 64\nC = [[int(0) for i in range(MX_BIT)] for j in range(MX_BIT)]\n\ndef ck(x, i):\n\treturn (x>>i) & 1\ndef tot_bits(x):\n\tx = bin(x)[2:]\n\treturn len(x)\ndef mkt():\n\tC[0][0] = 1\n\tfor i in range (1, MX_BIT):\n\t\tfor j in range (i+1):\n\t\t\tC[i][j] = C[i-1][j] + (C[i-1][j-1] if j else 0)\ndef solve(x, k):\n\ta = 0\n\tfor i in reversed(list(range(MX_BIT))):\n\t\tif ck(x, i) != 0:\n\t\t\ta += C[i][k]\n\t\t\tk -= 1\n\t\tif k == 0:\n\t\t\tbreak\n\treturn a\nmkt()\nm, k = list(input().split())\nm = int(m)\nk = int(k)\nl = 1\nr = 1e18\nif not m:\n    l = 1\nelse:\n    while l < r:\n    \tmid = int((l + r) // 2)\n    \tif (solve(2*mid, k) - solve(mid, k)) < m :\n    \t\tl = mid + 1\n    \telse:\n    \t\tr = mid\nprint(l)\n", "from math import factorial as f\ndef C(n, m):\n    if n < m: return 0\n    return f(n) // ( f(n - m ) * f(m) )\n \nm, k = map(int, input().split())\nans = 1\nfor bit in reversed(range(65)):\n    if k == 0:\n        break\n    if C(bit, k - 1) < m:\n        ans += ( 1 << bit )\n        m -= C(bit, k - 1)\n        k -= 1\nprint(ans)", "\nimport math\n\nm, k = list(map(int, input().strip(' ').split(' ')))\n\n\ndef solve(x):\n    ans = 0\n    tot = 0\n    for i in reversed(list(range(int(math.log2(x)+1)))):\n        if x & (1 << i):\n            ans += math.comb(i, k-tot)\n            tot += 1\n            if tot > k:\n                return ans\n    return ans\n\n\ndef judge(x):\n    return solve(x*2)-solve(x) >= m\n\n\nl, r = 1, 2\nwhile not judge(r):\n    l, r = r, r*2\nans = -1\nwhile l <= r:\n    mid = (l+r) >> 1\n    if judge(mid):\n        ans, r = mid, mid-1\n    else:\n        l = mid+1\nprint(ans)\n"]
["n, m = list(map(int, input().split()))\nedges_from = [[] for _ in range(n)]\nedges_to = [[] for _ in range(n)]\n\nfor _ in range(m):\n    _from, to = [int(x)-1 for x in input().split()]\n    edges_from[_from].append(to)\n\nE_dist_to_goal = [0] * n\nP_of_reaching = [0] * n\nP_of_reaching[0] = 1\n\nfor v in range(n-2, -1, -1):\n    routes = edges_from[v]\n    for next_v in routes:\n        E_dist_to_goal[v] += E_dist_to_goal[next_v] + 1\n    E_dist_to_goal[v] /= len(routes)\n\nfor v in range(n-1):\n    P_now = P_of_reaching[v]\n    routes = edges_from[v]\n    P_next = P_now / len(routes)\n    for next_v in routes:\n        P_of_reaching[next_v] += P_next\n\ninitial_ans = E_dist_to_goal[0]\nanswers = [initial_ans]\nfor v in range(n-2):\n    routes = edges_from[v]\n    num_of_routes = len(routes)\n    if num_of_routes == 1:\n        continue\n    not_cut_dist = E_dist_to_goal[v]\n    longest_dist = max([E_dist_to_goal[next_v]+1 for next_v in routes])\n    after_cut_dist = (not_cut_dist - longest_dist/num_of_routes) * num_of_routes / (num_of_routes-1)\n    delta = not_cut_dist - after_cut_dist\n    candidate = initial_ans - delta * P_of_reaching[v]\n    answers.append(candidate)\n\nprint((min(answers)))\n", "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n    adjL = [[] for _ in range(N)]\n    adjLRev = [[] for _ in range(N)]\n    outdegs = [0] * N\n    for _ in range(M):\n        s, t = list(map(int, input().split()))\n        s, t = s-1, t-1\n        adjL[s].append(t)\n        adjLRev[t].append(s)\n        outdegs[s] += 1\n\n    probs = [0] * N\n    expes = [0] * N\n    probs[0] = 1\n    for v in range(N):\n        prob, expe, outdeg = probs[v], expes[v], outdegs[v]\n        if prob != 0:\n            num = expe / prob\n            for v2 in adjL[v]:\n                probs[v2] += prob / outdeg\n                expes[v2] += prob * (num+1) / outdeg\n\n    probRevs = [0] * N\n    expeRevs = [0] * N\n    probRevs[-1] = 1\n    for v in reversed(list(range(N))):\n        prob, expe = probRevs[v], expeRevs[v]\n        if prob != 0:\n            num = expe / prob\n            for v0 in adjLRev[v]:\n                probRevs[v0] += prob / outdegs[v0]\n                expeRevs[v0] += prob * (num+1) / outdegs[v0]\n\n    ans = expes[-1]\n    for vRem in range(N-1):\n        if outdegs[vRem] == 1: continue\n        values = []\n        prob, expe, outdeg = probs[vRem], expes[vRem], outdegs[vRem]\n        for v2 in adjL[vRem]:\n            value = expe*probRevs[v2] + expeRevs[v2]*prob + prob*probRevs[v2]\n            values.append(value)\n        sumV = sum(values)\n        ans2 = expes[-1] - sumV / outdeg\n        for value in values:\n            ans = min(ans, ans2 + (sumV-value) / (outdeg-1))\n\n    print(ans)\n\n\nsolve()\n", "import sys\n\nn, m = list(map(int, input().split()))\nlinks = [set() for _ in range(n)]\ncounts = [0] * n\nfor line in sys.stdin:\n    s, t = list(map(int, line.split()))\n    s -= 1\n    t -= 1\n    links[s].add(t)\n    counts[s] += 1\n\n# Expected number of edges passing from i to N\nexpected = [0.] * n\nexp_get = expected.__getitem__\n\n# i \u304b\u3089\u4f38\u3073\u308b\u8fba\u30921\u672c\u6d88\u3059\u3053\u3068\u3067\u524a\u6e1b\u3067\u304d\u308b\"i\u304b\u3089N\u307e\u3067\u306e\u8fba\u6570\u306e\u671f\u5f85\u5024\"\u306e\u6700\u5927\u91cf\nreducible = [0.] * n\n\nfor i in range(n - 2, -1, -1):\n    nxt_exp = list(map(exp_get, links[i]))\n    sum_exp = sum(nxt_exp)\n    cnt = counts[i]\n\n    expected[i] = sum_exp / cnt + 1\n\n    if cnt > 1:\n        reduced_exp = (sum_exp - max(nxt_exp)) / (cnt - 1) + 1\n        reducible[i] = expected[i] - reduced_exp\n    else:\n        reducible[i] = 0.\n\n# Probability of visiting i when starting from 1\nprobability = [0.] * n\nprobability[0] = 1.\n\nrdc = 0.\n\nfor i in range(n - 1):\n    fp = probability[i]\n    jp = fp / counts[i]\n    for j in links[i]:\n        probability[j] += jp\n    rdc = max(rdc, fp * reducible[i])\n\nprint((expected[0] - rdc))\n", "import sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\nedges_from = [[] for _ in range(n)]\nedges_to = [[] for _ in range(n)]\n\nfor _ in range(m):\n    _from, to = map(lambda x: int(x)-1, input().split())\n    edges_from[_from].append(to)\n\nE_dist_to_goal = [0] * n\nP_of_reaching = [0] * n\nP_of_reaching[0] = 1\n\nfor v in range(n-2, -1, -1):\n    routes = edges_from[v]\n    for next_v in routes:\n        E_dist_to_goal[v] += E_dist_to_goal[next_v] + 1\n    E_dist_to_goal[v] /= len(routes)\n\nfor v in range(n-1):\n    P_now = P_of_reaching[v]\n    routes = edges_from[v]\n    P_next = P_now / len(routes)\n    for next_v in routes:\n        P_of_reaching[next_v] += P_next\n\ninitial_ans = E_dist_to_goal[0]\nshort_cut = 0\nfor v in range(n-2):\n    routes = edges_from[v]\n    num_of_routes = len(routes)\n    if num_of_routes == 1:\n        continue\n    not_cut_dist = E_dist_to_goal[v]\n    longest_dist = max([E_dist_to_goal[next_v]+1 for next_v in routes])\n    after_cut_dist = (not_cut_dist - longest_dist/num_of_routes) * num_of_routes / (num_of_routes-1)\n    delta = (not_cut_dist - after_cut_dist) * P_of_reaching[v]\n    short_cut = max(short_cut, delta)\n\nans = initial_ans - short_cut\nprint(ans)", "def solve_f(n, g):\n    e_base = [0.0] * (n + 1)\n    p_base = [0.0] * (n + 1)\n\n    # e_base\n    for i in range(n - 1, 0, -1):\n        e_base[i] = sum([e_base[j] for j in g[i]]) / len(g[i]) + 1.0\n\n    # p_base\n    p_base[1] = 1.0\n    for i in range(1, n):\n        for j in g[i]:\n            p_base[j] += p_base[i] / len(g[i])\n\n    # print(p_base, e_base)\n\n    # find maximal gap\n    gap = 0.0\n    for i in range(1, n):\n        if len(g[i]) == 1:\n            continue\n        total = sum([e_base[j] + 1 for j in g[i]])\n        maxim = max([e_base[j] + 1 for j in g[i]])\n        gap_i = (total / len(g[i]) - (total - maxim) / (len(g[i]) - 1)) * p_base[i]\n        gap = max(gap_i, gap)\n\n    return e_base[1] - gap\n\n\ndef main():\n    # input\n    n, m = list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        s, t = list(map(int, input().split()))\n        g[s].append(t)\n    res = solve_f(n, g)\n    print(res)\n\n\ndef test():\n    assert abs(solve_f(4, [[], [2, 3, 4], [3, 4], [4]]) - 1.5) < 0.000001\n    assert abs(solve_f(3, [[], [2], [3]]) - 2.0) < 0.000001\n\n\ndef __starting_point():\n    test()\n    main()\n\n__starting_point()", "import sys\n\nn, m = list(map(int, input().split()))\nlinks = [set() for _ in range(n)]\ncounts = [0] * n\nfor line in sys.stdin:\n    s, t = list(map(int, line.split()))\n    s -= 1\n    t -= 1\n    links[s].add(t)\n    counts[s] += 1\n\n# Expected number of edges passing from i to N\nexpected = [0.] * n\nexp_get = expected.__getitem__\n\n# i \u304b\u3089\u4f38\u3073\u308b\u8fba\u30921\u672c\u6d88\u3059\u3053\u3068\u3067\u524a\u6e1b\u3067\u304d\u308b\"i\u304b\u3089N\u307e\u3067\u306e\u8fba\u6570\u306e\u671f\u5f85\u5024\"\u306e\u6700\u5927\u91cf\nreducible = [0.] * n\n\nfor i in range(n - 2, -1, -1):\n    nxt_exp = list(map(exp_get, links[i]))\n    sum_exp = sum(nxt_exp)\n    cnt = counts[i]\n\n    expected[i] = sum_exp / cnt + 1\n\n    if cnt > 1:\n        reduced_exp = (sum_exp - max(nxt_exp)) / (cnt - 1) + 1\n        reducible[i] = expected[i] - reduced_exp\n    else:\n        reducible[i] = 0.\n\n# Probability of visiting i when starting from 1\nprobability = [0.] * n\nprobability[0] = 1.\n\nfor i in range(n - 1):\n    jp = probability[i] / counts[i]\n    for j in links[i]:\n        probability[j] += jp\n\nprint((expected[0] - max(p * r for p, r in zip(probability, reducible))))\n", "N, M = list(map(int, input().split()))\nst = [list(map(int, input().split())) for _ in range(M)]\n\nR = {}\nfor s, t in st:\n  s -= 1\n  t -= 1\n  if s in R:\n    R[s].append(t)\n  else:\n    R[s] = [t]\n\nDP = [0] * N\nans = N\nD = [0] * N\nfor i in range(N - 2, -1, -1):\n  ma = 0\n  su = 0\n  le = len(R[i])\n  for j in R[i]:\n    su += DP[j]\n    ma = max(ma, DP[j])\n\n  DP[i] = su / le + 1 \n  if le == 1:\n    D[i] = 0\n  else:\n    D[i] = DP[i] - (((su - ma) / (le - 1)) + 1)\n\nP = [0] * N \nP[0] = 1\nma = 0\nman = -1\nfor i in range(N - 1):\n  t = P[i] / len(R[i])\n  for j in R[i]:\n    P[j] += t \n  t = P[i] * D[i]\n  R[i].sort()\n  if ma < t:\n    ma = t\n    man = i\n \nif ma == -1:\n  print((DP[0]))\nelse:\n  print((DP[0] - ma))\n", "import sys\ninput = sys.stdin.readline\nEPS = 10**(-8)\nINF = 10**16\n\nN, M = map(int, input().split())\ngraph = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].add(b-1)\n\ndp = [0]*N\ndps = [0]*N\ndpl = [0]*N\nfor n in reversed(range(N-1)):\n    for p in graph[n]:\n        if dp[p] != -1:\n            dps[n] += dp[p]\n            dpl[n] += 1\n    if dpl[n] > 0:\n        dp[n] = dps[n]/dpl[n] + 1\n    else:\n        dp[n] = -1\n\nWeight = [0]*N\nWeight[0] = 1\nfor n in range(N):\n    for p in graph[n]:\n        Weight[p] += Weight[n]/dpl[n]\n\nans = dp[0]\nfor n1 in range(N):\n    if len(graph[n1]) != 1:\n        for n2 in graph[n1]:\n            newE = (dps[n1]-dp[n2])/(dpl[n1]-1) + 1\n            tmp = dp[0] - Weight[n1]*dp[n1] + Weight[n1]*newE\n            if tmp < ans:\n                ans = tmp\n\nprint(ans)", "import numpy as np\n\nn, m = list(map(int, input().split()))\nadj = np.zeros((n, n), dtype=np.bool)\nfor _ in range(m):\n  s, t = list(map(int, input().split()))\n  adj[s-1, t-1] = True\ndeg = adj.sum(axis=1)\n\nev = np.zeros(n, dtype=np.float)\nfor i in range(n - 2, -1, -1):\n  ev[i] = ev[adj[i]].mean() + 1.\n\nprob = np.zeros(n, dtype=np.float)\nprob[0] = 1.\nfor i in range(n - 1):\n  prob[adj[i]] += prob[i] / deg[i]\n\ndecrease = 0.\nfor i in np.where(deg > 1)[0]:\n  now = ev[adj[i]].mean()\n  cut = (ev[adj[i]].sum() - ev[adj[i]].max()) / (deg[i] - 1)\n  decrease = np.maximum(decrease, (now - cut) * prob[i])\n    \nprint((ev[0] - decrease))\n", "n,m = map(int,input().split())\ng = [list() for _ in range(n)]\nfor _ in range(m):\n  s,t = map(int,input().split())\n  g[s-1].append(t-1)\nprop = [0]*n\nexpc = [10**6]*n\nprop[0] = 1\nexpc[-1] = 0\nfor i in range(n):\n  if not g[i]:\n    continue\n  t = len(g[i])\n  for x in g[i]:\n    prop[x] += prop[i]/t\nfor i in range(n-1,-1,-1):\n  if not g[i]:\n    continue\n  t = len(g[i])\n  f = 0\n  for x in g[i]:\n    f += expc[x] + 1.0\n  f /= t\n  expc[i] = f\n\ncans = expc[0]\nfor i in range(n-1):\n  t = len(g[i])\n  if t < 2:\n    continue\n  c = max(expc[x] for x in g[i])\n  ne = (expc[i]*t - (c+1))/(t-1)\n  de = expc[i] - ne\n  na = expc[0] - de*prop[i]\n  if cans > na:\n    cans = na\nprint(cans)", "def iig(vn, en):\n    res = [[] for _ in range(vn)]\n    for _ in range(en):\n        ai, bi = map(lambda x: int(x) - 1, input().split())\n        res[ai].append(bi)\n    return res\n\nn, m = map(int, input().split())\nv = iig(n, m)\n\nnxtsum = [0] * n\ne = [0] * n\nfor i, adjl in reversed(list(enumerate(v))):\n\tcount = len(adjl)\n\tif count == 0:\n\t\tcontinue\n\tnxtsum[i] = sum(e[nxt] for nxt in adjl)\n\te[i] = 1 + nxtsum[i] / len(adjl)\n\nv_prob = [0] * n\nv_prob[0] = 1\nfor i, adjl in enumerate(v):\n\tcount = len(adjl)\n\tfor nxt in adjl:\n\t\tv_prob[nxt] += v_prob[i] / count\n\nloss_max = 0\nfor i, adjl in enumerate(v):\n\tcount = len(adjl)\n\tif count <= 1:\n\t\tcontinue\n\tfor j in adjl:\n\t\tloss = e[i] - (1 + (nxtsum[i] - e[j]) / (count - 1))\n\t\tloss *= v_prob[i]\n\t\tif loss > loss_max:\n\t\t\tloss_max = loss\n\nprint(e[0] - loss_max)", "import sys\ninput = sys.stdin.readline\nEPS = 10**(-8)\nINF = 10**16\n\nN, M = map(int, input().split())\ngraph = [set() for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].add(b-1)\n\ndp = [0]*N\ndps = [0]*N\ndpl = [0]*N\nfor n in reversed(range(N-1)):\n    for p in graph[n]:\n        if dp[p] != -1:\n            dps[n] += dp[p]\n            dpl[n] += 1\n    if dpl[n] > 0:\n        dp[n] = dps[n]/dpl[n] + 1\n    else:\n        dp[n] = -1\n\nWeight = [0]*N\nWeight[0] = 1\nfor n in range(N):\n    for p in graph[n]:\n        Weight[p] += Weight[n]/dpl[n]\n\nans = dp[0]\nfor n1 in range(N):\n    if len(graph[n1]) != 1:\n        for n2 in graph[n1]:\n            newE = (dps[n1]-dp[n2])/(dpl[n1]-1) + 1\n            ans = min(ans, dp[0] - Weight[n1]*dp[n1] + Weight[n1]*newE)\n\nprint(ans)", "(n,m),*d = [list(map(int, s.split())) for s in open(0)]\n\nd.sort()\nl = [0] * n\nfor i in range(m):\n    d[i] = [d[i][0]-1, d[i][1]-1]\n    l[d[i][0]] += 1\n\np = [0] * n\np[0] = 1\nfor x in d:\n    p[x[1]] += p[x[0]]/l[x[0]]\n\ne = [0] * n\nindex = d[-1][0]\nmax_in_index = 0\nmax_reduce_e = 0\n\nfor x in d[::-1] + [[-1, -1]]:\n    if index != x[0]:\n        if l[index] > 1:\n            max_reduce_e = max(max_reduce_e, \n                               p[index] * (e[index]/l[index] - (e[index] - max_in_index)/(l[index] - 1)))\n        e[index] /= l[index]\n        index = x[0]\n        max_in_index = 0\n    max_in_index = max(max_in_index, e[x[1]] + 1)\n    e[x[0]] += e[x[1]] + 1\n\nprint(e[0] - max_reduce_e)", "# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline \n\n#n = int(input())\nn,m = [int(i) for i in readline().split()]\n\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    s,t = [int(i)-1 for i in readline().split()]\n    g[s].append(t)\n\nL = [len(gi) for gi in g]\n\np = [0]*n\np[0] = 1\nfor i in range(n-1):\n    c = p[i]/L[i]\n    for v in g[i]:\n        p[v] += c\n\ndp0 = [0]*(n)\ndp1 = [1000000]*(n)\n\nfor i in range(n-2,-1,-1):\n    res = 0\n    m = 0\n    for v in g[i]:\n        res += dp0[v]\n        if m<dp0[v]: m = dp0[v]\n    dp0[i] = 1 + res/L[i]\n\n    if L[i] >= 2:\n        dp1[i] = 1 + (res-m)/(L[i]-1)\n    \nres = max((dp0[i] - dp1[i])*p[i] for i in range(n))\n\nprint((dp0[0]-max(0,res)))\n\n\n\n\n\n\n\n\n\n\n", "def f_fork_in_the_road():\n    # \u53c2\u8003: https://www.onakasuitacity.com/abc144-f/\n    N, M = [int(i) for i in input().split()]\n    Nodes = [[int(i) for i in input().split()] for j in range(M)]\n\n    edges = [[] for _ in range(N)]\n    for s, t in Nodes:\n        edges[s - 1].append(t - 1)\n\n    # editorial \u306e DP \u30c6\u30fc\u30d6\u30eb\u306e\u78ba\u7387\u90e8\u5206\n    probability = [0] * N\n    probability[0] = 1.0\n    for v in range(N):\n        for next_vertex in edges[v]:\n            probability[next_vertex] += probability[v] / len(edges[v])\n\n    # \u671f\u5f85\u5024\n    expected_value = [0] * N\n    for v in range(N - 2, -1, -1):\n        for next_vertex in edges[v]:\n            expected_value[v] += expected_value[next_vertex]\n        expected_value[v] = 1 + expected_value[v] / len(edges[v])\n\n    ans = expected_value[0]\n    for v in range(N):\n        if len(edges[v]) <= 1:\n            continue\n        # \u5404\u9802\u70b9 v \u306b\u5bfe\u3057\u3066\u3001v \u304b\u3089\u51fa\u308b\u8fba vw \u306e\u3046\u3061\n        # w \u3067\u306e\u671f\u5f85\u5024\u304c\u6700\u5927\u306e\u3082\u306e\u306e\u5206\u3092\u5dee\u5206\u304b\u3089\u5f15\u304f\u3002\u6b8b\u308a\u306f\u8db3\u3059\n        v_max_expected = max(((expected_value[w], w) for w in edges[v]))[1]\n        expected_diff = 0.0\n        outdegree = len(edges[v])\n        for next_vertex in edges[v]:\n            if next_vertex == v_max_expected:\n                expected_diff -= expected_value[next_vertex] / outdegree\n            else:\n                expected_diff += expected_value[next_vertex] / (outdegree * (outdegree - 1))\n        ans = min(ans, expected_value[0] + probability[v] * expected_diff)\n    return round(ans, 10)\n\nprint(f_fork_in_the_road())", "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n    adjL = [[] for _ in range(N)]\n    outdegs = [0] * N\n    for _ in range(M):\n        s, t = list(map(int, input().split()))\n        s, t = s-1, t-1\n        adjL[s].append(t)\n        outdegs[s] += 1\n\n    probs = [0] * N\n    probs[0] = 1\n    for v in range(N):\n        for v2 in adjL[v]:\n            probs[v2] += probs[v] / outdegs[v]\n\n    dp = [0] * N\n    for v in reversed(list(range(N-1))):\n        dp[v] = sum([dp[v2] for v2 in adjL[v]]) / outdegs[v] + 1\n\n    ans = dp[0]\n    for vRem in range(N):\n        if outdegs[vRem] == 1: continue\n        sumDP, maxDP = 0, -1\n        for v2 in adjL[vRem]:\n            sumDP += dp[v2]\n            if dp[v2] > maxDP:\n                maxDP = dp[v2]\n        dp2 = (sumDP-maxDP) / (outdegs[vRem]-1) + 1\n        decre = dp[vRem] - dp2\n        ans2 = dp[0] - decre * probs[vRem]\n        ans = min(ans, ans2)\n\n    print(ans)\n\n\nsolve()\n", "# reference: https://www.onakasuitacity.com/abc144-f/\n\nimport numpy as np\n\nn, m = map(int, input().split())\noutgoing = [[] for _ in range(n)]\nincoming = [[] for _ in range(n)]\nfor _ in range(m):\n    si, ti = map(int, input().split())\n    outgoing[si-1].append(ti-1)\n    incoming[ti-1].append(si-1)\n\n\nex_dp = np.zeros(n)\nfor v in reversed(range(n-1)):   # O(m)\n    outgoing_degree = len(outgoing[v])\n    ex_dp[v] = 1 + sum(ex_dp[post] for post in outgoing[v])/outgoing_degree if outgoing_degree!=0 else np.inf\n\np_dp = np.ones(n)\nfor v in range(1,n):      # O(m)\n    p_dp[v] = sum(p_dp[prev]/len(outgoing[prev]) for prev in incoming[v])\n\nmin_ex = ex_dp[0]\nfor v, posts in enumerate(outgoing):      # O(m)\n    outgoing_degree = len(outgoing[v])\n    if outgoing_degree <= 1:\n        continue\n\n    max_post = max(posts, key= lambda pos: ex_dp[pos])\n    diff_v_ex = 0\n    for w in posts:\n        if w == max_post:\n            diff_v_ex -= 1/outgoing_degree * ex_dp[w]\n        else:\n            diff_v_ex += 1/(outgoing_degree*(outgoing_degree-1)) * ex_dp[w]\n    min_ex = min(ex_dp[0] + p_dp[v] * diff_v_ex, min_ex)\n\nprint(min_ex)", "import sys\ninput = sys.stdin.readline\n\n#input\nN, M = list(map(int, input().split()))\nu = [[] for i in range(N)]\n#\uff08\u4fbf\u5b9c\u7684\u306b\u5730\u70b9\u304b\u3089-1\u3068\u3057\u3066\u304a\u304f\uff09\nfor i in range(M):\n    s, t = list(map(int, input().split()))\n    u[s-1].append(t-1)\n\n#output\n#\u5730\u70b9v\u306b\u305f\u3069\u308a\u7740\u304f\u78ba\u7387\u3092p[v]\u3068\u3059\u308b\u3002\np = [0] * N\np[0] = 1\nfor v in range(N):\n    for i in range(v):\n        if v in u[i]:\n            p[v] += p[i]/len(u[i])\n\n#\u671f\u5f85\u5024\u3092\u30b4\u30fc\u30eb\u304b\u3089\u9006\u9806\u306b\u6c42\u3081\u3066\u3044\u304f\u3002\u70b9v\u304b\u3089\u30b4\u30fc\u30eb\u307e\u3067\u306e\u79fb\u52d5\u8ddd\u96e2\u306e\u671f\u5f85\u5024\u3092q[v]\u3068\u3059\u308b\u3002\nq = [0] * N\nq[N-1] = 0\nfor v in reversed(list(range(N))):\n    for i in u[v]:\n        q[v] += (1 + q[i])/len(u[v])\n\nv = [0] * N\nfor i in range(N-1):\n    a = len(u[i])\n    if a > 1:\n        b = max(q[c] for c in u[i])\n        v[i] = p[i]*(q[i] - (1+b))/(a-1)\n\nprint((q[0]+min(v)))\n", "\"\"\"\nReferences\n----------\n[0]. \u89e3\u8aac(\u516c\u5f0f), https://img.atcoder.jp/abc144/editorial.pdf, AtCoder\n    - O(NM)\n[1]. kmjp. AtCoder ABC #144 : F - Fork in the Road, <http://kmjp.hatenablog.jp/entry/2019/10/28/0930>, kmjp's blog\n    - O(NM)\n[2]. physics0523. Fork in the Road(ABC144-F), <https://physics0523.hatenablog.com/entry/2019/10/27/235334>, physics0523's \u7cbe\u9032\u30ed\u30b0\n    - O(M)\n[3]. Genki Ogaki. BC144 F - Fork in the Road\u8003\u5bdf\uff0b\u53c2\u6226\u8a18, <https://www.onakasuitacity.com/abc144-f>, \u304a\u3058\u3055\u3093\u3001\u4eca\u65e5\u30d7\u30ed\u59cb\n\u3081\u308b\u3063\u3066\u3088\n    - O(M)\n\"\"\"\ndef solve(n, m, s, t):\n    edges = [[] for i in range(n)]\n    for i in range(m):\n        u, v = s[i], t[i]\n        edges[u-1].append(v-1)\n    p = [0] * n\n    p[0] = 1\n    for i in range(n):\n        for j in edges[i]:\n            p[j] += p[i] / len(edges[i])\n    E = [0] * n\n    for i in range(n-2, -1, -1):\n        v = [E[j] for j in edges[i]]\n        E[i] = 1 + sum(v) / len(v)\n    res = E[0]\n    for i in range(n):\n        deg = len(edges[i])\n        if deg <= 1:\n            continue\n        k = max((E[j], j) for j in edges[i])[1]\n        v = [E[j] for j in edges[i] if j != k]\n        res = min(res, E[0] + p[i] * (sum(v) / (deg-1) - E[k]) / deg)\n    return res\n\nn, m = map(int, input().split())\ns = [0] * m\nt = [0] * m\nfor i in range(m):\n    s[i], t[i] = map(int, input().split())\nprint(solve(n, m, s, t))", "import sys\nsys.setrecursionlimit(10**7)\ninf=float('inf')\n\ndef main(n,m,g,uv):\n    # 1<=E<=n-1\n    eary=[inf]*m\n    vary=[inf]*n\n    vary[-1]=0\n    todo=[n-1]\n    def dfs(v,x):\n        if vary[v]<inf:return vary[v]\n        ret=0\n        cnt=0\n        for i,nv in g[v]:\n            if i==x:continue\n            tmp=dfs(nv,x)+1\n            eary[i]=tmp\n            ret+=tmp\n            cnt+=1\n        if cnt==0:\n            for i in range(n):\n                vary[i]=inf\n            return inf\n        vary[v]=ret/cnt\n        return ret/cnt\n    e0=dfs(0,-1)\n    ary=[-1]*m\n    bary=[0]*n\n    bary[0]=1\n    for v in range(n):\n        k=len(g[v])\n        e=vary[v]\n        for i,nv in g[v]:\n            bary[nv]+=1/k*bary[v]\n            if k>1 and bary[v]:\n                ary[i]=max(0,e-(e*k-eary[i])/(k-1))\n                ary[i]*=bary[v]\n    return e0-max(0,max(ary))\n\nn,m=list(map(int,input().split()))\nuv=[list(map(int,input().split())) for _ in range(m)]\ng=[[] for _ in range(n)]\nfor i,(u,v) in enumerate(uv):\n    u,v=u-1,v-1\n    g[u].append((i,v))\nprint((main(n,m,g,uv)))\n", "N, M = list(map(int, input().split()))\npassages = [[] for i in range(N-1)]\nfor i in range(M):\n    s, t = list(map(int, input().split()))\n    passages[s-1].append(t-1)\n\nprob = [0] * N\nprob[0] = 1\nfor n, dest in enumerate(passages):\n    for d in dest:\n        prob[d] += prob[n] / len(dest)\n\n# no blocking\nE = [0] * N\nfor n, dest in list(enumerate(passages))[::-1]:\n    E[n] = sum(E[d] for d in dest) / len(dest) + 1\n\nmin_E = E[0]\n\n# with blocking\nfor n, dest in enumerate(passages):\n    if len(dest) == 1:\n        continue\n    new_E = ((E[n] - 1) * len(dest) - max(E[d] for d in dest)) / (len(dest) - 1) + 1\n    min_E = min(min_E, E[0] - (E[n] - new_E) * prob[n])\n\nprint(min_E)\n", "def main():\n    n, m = list(map(int, input().split()))\n    st = [list(map(int, input().split())) for _ in [0]*m]\n    g = [[] for _ in [0]*n]\n    [g[a-1].append(b-1) for a, b in st]\n    toP = [0]*n\n    toE = [0]*n\n    fromE = [0]*n\n    toP[0] = 1\n    for i in range(n-1):\n        p = toP[i]\n        if p > 0:\n            toE[i] /= toP[i]\n        e = toE[i]\n        l = len(g[i])\n        for j in g[i]:\n            toP[j] += p/l\n            toE[j] += (e+1)*p/l\n    for i in range(n-2, -1, -1):\n        l = len(g[i])\n        for j in g[i]:\n            fromE[i] += (fromE[j]+1)/l\n    allE = fromE[0]\n    ans = fromE[0]\n    tf = [toP[i]*((toE[i]+1)*len(g[i])+sum([fromE[j] for j in g[i]]))\n          for i in range(n)]\n    for s, t in st:\n        if g[s-1]:\n            l = len(g[s-1])\n            if l > 1:\n                ans = min(allE+tf[s-1]*(1/(l-1)-1/l)-toP[s-1] *\n                          (toE[s-1]+1+fromE[t-1])/(l-1), ans)\n    print(ans)\n\n\nmain()\n", "N,M=map(int,input().split())\nst=[list(map(int,input().split())) for i in range(M)]\nway=[[] for i in range(N)]\nfor s,t in st:\n    way[s-1].append(t-1)\ndp=[0]*N\ndp_reducable=[0]*N\npr=[0]*N\npr[0]=1\nfor i in range(N-1,-1,-1):\n    l=len(way[i])\n    if l>1:\n        MAX=0\n        x=0\n        for j in way[i]:\n            x+=dp[j]\n            if dp[j]>MAX:\n                MAX=dp[j]\n        x_r=(x-MAX)/(l-1)+1\n        x=x/l+1\n        x_r=x-x_r\n    elif l==0:\n        continue\n    else:\n        x=dp[way[i][0]]+1\n        x_r=0\n    dp[i]=x\n    dp_reducable[i]=x_r\n    i=N-1-i-1\n    l=len(way[i])\n    for j in way[i]:\n        pr[j]+=pr[i]/l\nprint(dp[0] - max(p * r for p, r in zip(pr, dp_reducable)))", "from collections import defaultdict\nN,m=list(map(int,input().split()))\ngraph=defaultdict(list)\nedges=[]\npassages=[[] for i in range(N-1)]\nfor _ in range(m):\n    u,v=list(map(int,input().split()))\n    passages[u-1].append(v-1)\nprob=[0]*N\nprob[0]=1\nfor n,dest in enumerate(passages):\n    #print(n,dest,'ndest')\n    for d in dest:\n        prob[d]+=prob[n]/len(dest)\n# no blocking\ne=[0]*N\n#print(prob)\nfor n,dest in list(enumerate(passages))[::-1]:\n    #print(dest,n,'n dess t')\n    e[n]=sum(e[d] for d in dest)/len(dest)+1\nmin_e=e[0]\n#with blocking\nfor n,dest in enumerate(passages):\n    if len(dest)==1:\n        continue\n    new_e=((e[n]-1)*len(dest)-max(e[d] for d in dest))/(len(dest)-1)+1\n    min_e=min(min_e,e[0]-(e[n]-new_e)*prob[n])\nprint(min_e)\n    \n\n        \n\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    n, m = list(map(int, input().split()))\n    to = defaultdict(list)\n    ot = defaultdict(list)\n    for _ in range(m):\n        s, t = list(map(int, input().split()))\n        s, t = s - 1, t - 1\n        to[s].append(t)\n        ot[t].append(s)\n    # print(to)\n    # \u5404\u9802\u70b9\u304b\u3089\u30b4\u30fc\u30eb\u307e\u3067\u306e\u671f\u5f85\u5024\n    ev = [0] * n\n    for u in range(n - 2, -1, -1):\n        s = 0\n        for ku in to[u]:\n            s += ev[ku]\n        ev[u] = s / len(to[u]) + 1\n    # print(ev)\n    # \u5404\u8fba\u3092\u901a\u308b\u78ba\u7387\n    pe = [[0] * n for _ in range(n)]\n    # \u5404\u9802\u70b9\u3092\u901a\u308b\u78ba\u7387\n    pn = [0] * n\n    # \u5404\u9802\u70b9\u3092\u901a\u308b\u78ba\u7387\u3092\u8a08\u7b97\n    for u in range(n):\n        p = 0\n        for ou in ot[u]:\n            p += pe[ou][u]\n        if u == 0: p = 1\n        pn[u] = p\n        sz = len(to[u])\n        for ku in to[u]:\n            pe[u][ku] = p / sz\n    # print(pn)\n    # \u5909\u5316\u91cf\u306e\u6700\u5927\u5024\n    dx = 0\n    for u in range(n - 1):\n        sz = len(to[u])\n        if sz == 1: continue\n        mx = 0\n        for ku in to[u]:\n            mx = max(ev[ku], mx)\n        nev = ((ev[u] - 1) * sz - mx) / (sz - 1) + 1\n        de = pn[u] * (ev[u] - nev)\n        dx = max(dx, de)\n        # print(u, mx, de, nev)\n    print((ev[0] - dx))\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\n#input\nN, M = map(int, input().split())\nu = [[] for i in range(N-1)]\n#\uff08\u4fbf\u5b9c\u7684\u306b\u5730\u70b9\u304b\u3089-1\u3068\u3057\u3066\u304a\u304f\uff09\nfor i in range(M):\n    s, t = map(int, input().split())\n    u[s-1].append(t-1)\n\n#output\n#\u5730\u70b9v\u306b\u305f\u3069\u308a\u7740\u304f\u78ba\u7387\u3092p[v]\u3068\u3059\u308b\u3002\np = [0] * N\np[0] = 1\nfor x, y in enumerate(u):\n    for z in y:\n        p[z] += p[x]/len(y)\n\n#\u671f\u5f85\u5024\u3092\u30b4\u30fc\u30eb\u304b\u3089\u9006\u9806\u306b\u6c42\u3081\u3066\u3044\u304f\u3002\u70b9v\u304b\u3089\u30b4\u30fc\u30eb\u307e\u3067\u306e\u79fb\u52d5\u8ddd\u96e2\u306e\u671f\u5f85\u5024\u3092q[v]\u3068\u3059\u308b\u3002\nq = [0] * N\nq[N-1] = 0\nfor x, y in list(enumerate(u))[::-1]:\n    q[x] = sum(q[z] for z in y)/len(y) + 1\n\nv = [0] * N\nfor i in range(N-1):\n    a = len(u[i])\n    if a > 1:\n        b = max(q[c] for c in u[i])\n        v[i] = p[i]*(q[i] - (1+b))/(a-1)\n\nprint(q[0]+min(v))", "import sys\n\nn, m = list(map(int, input().split()))\nlinks = [set() for _ in range(n)]\ncounts = [0] * n\nfor line in sys.stdin:\n    s, t = list(map(int, line.split()))\n    s -= 1\n    t -= 1\n    links[s].add(t)\n    counts[s] += 1\n\n# Expected number of edges passing from i to N\nexpected = [0.] * n\n\n# i \u304b\u3089\u4f38\u3073\u308b\u8fba\u30921\u672c\u6d88\u3059\u3053\u3068\u3067\u524a\u6e1b\u3067\u304d\u308b\"i\u304b\u3089N\u307e\u3067\u306e\u8fba\u6570\u306e\u671f\u5f85\u5024\"\u306e\u6700\u5927\u91cf\nreducible = [0.] * n\n\nfor i in range(n - 2, -1, -1):\n    nxt_exp = [expected[j] for j in links[i]]\n    sum_exp = sum(nxt_exp)\n    cnt = counts[i]\n\n    expected[i] = sum_exp / cnt + 1\n\n    if cnt > 1:\n        reduced_exp = (sum_exp - max(nxt_exp)) / (cnt - 1) + 1\n        reducible[i] = expected[i] - reduced_exp\n    else:\n        reducible[i] = 0.\n\n# Probability of visiting i when starting from 1\nprobability = [0.] * n\nprobability[0] = 1.\n\nfor i in range(n - 1):\n    jp = probability[i] / counts[i]\n    for j in links[i]:\n        probability[j] += jp\n\nprint((expected[0] - max(p * r for p, r in zip(probability, reducible))))\n", "import numpy as np\n\nn, m = map(int, input().split())\nadj = np.zeros((n, n), dtype=np.bool)\nfor _ in range(m):\n  s, t = map(int, input().split())\n  adj[s-1, t-1] = True\ndeg = adj.sum(axis=1)\n\nev = np.zeros(n, dtype=np.float)\nfor i in range(n - 2, -1, -1):\n  ev[i] = ev[adj[i]].mean() + 1.\n\nprob = np.zeros(n, dtype=np.float)\nprob[0] = 1.\nfor i in range(n - 1):\n  prob[adj[i]] += prob[i] / deg[i]\n\ndecrease = 0.\nfor i in np.where(deg > 1)[0]:\n  now = ev[adj[i]].mean()\n  cut = (ev[adj[i]].sum() - ev[adj[i]].max()) / (deg[i] - 1)\n  decrease = np.maximum(decrease, (now - cut) * prob[i])\n    \nprint(ev[0] - decrease)", "N, M = map(int, input().split())\nedge_out = [[] for i in range(N)] #edge_out[i]\u306fi\u304b\u3089\u51fa\u3066\u3044\u308b\u9053\nedge_in = [[] for i in range(N + 1)] # edge_in[i]\u306fi\u306b\u884c\u304f\u9053\nfor i in range(M):\n    s, t = map(int, input().split())\n    edge_out[s].append(t)\n    edge_in[t].append(s)\n\nedge_sum = [len(edge_out[i]) for i in range(N)] # edge_sum[i] = i\u304b\u3089\u51fa\u3066\u3044\u308b\u9053\u306e\u672c\u6570\n\ndp = [0.0]*(N + 1) # dp[i]\u306fi\u304b\u3089N\u3078\u306e\u8ddd\u96e2\u306e\u671f\u5f85\u5024\ndp[N - 1] = 1.0\n# \u9053\u3092\u585e\u304c\u306a\u3044\u5834\u5408\nfor i in range(N - 2, 0, - 1):\n    dp[i] = 1 + sum(dp[j] for j in edge_out[i])/edge_sum[i]\n    \np_to_i = [0]*(N + 1) # p_to_i[i]\u306f1\u304b\u3089\u5404i\u3078\u5230\u9054\u3059\u308b\u78ba\u7387\np_to_i[1] = 1\nfor i in range(2, N + 1):\n    p_to_i[i] = sum(p_to_i[j]/edge_sum[j] for j in edge_in[i])\n\n\nt = 0\n\nfor i in range(1, N - 1):\n    if edge_sum[i] == 1:\n        continue\n        # i\u304b\u3089\u51fa\u3066\u3044\u308b\u9053\u306e\u5148\u306b\u3042\u308b\u90e8\u5c4b\u306e\u3046\u3061\u3001\u305d\u306e\u90e8\u5c4b\u304b\u3089N\u307e\u3067\u306e\u8ddd\u96e2\u306e\u671f\u5f85\u5024\u304c\u6700\u3082\u5927\u304d\u3044\u3082\u306e\u3078\u901a\u305a\u308b\u9053\u3092\u585e\u3050\n    t = max(t, p_to_i[i]*(dp[i] - 1- ((dp[i] - 1)*edge_sum[i] - max(dp[j] for j in edge_out[i]))/(edge_sum[i] - 1)))\n    \nprint(dp[1] - t)", "import math\n\nN, M = [int(x) for x in input().split()]\nedges = [[int(x) for x in input().split()] for _ in range(M)]\n\nforward_edges = {n+1:[] for n in range(N)}\nreverse_edges = {n+1:[] for n in range(N)}\nfor e in edges:\n  forward_edges[e[0]].append(e[1])\n  reverse_edges[e[1]].append(e[0])\n# print(  forward_edges)\n# print(  reverse_edges)\nestimated_distance = {n+1:None for n in range(N)}\nestimated_distance[N] = 0\nprobability = {n+1:None for n in range(N)}\nprobability[1] = 1\ndef get_probability(n):\n  if probability[n] is not None:\n    return probability[n]\n  prob = 0\n  for m in reverse_edges[n]:\n    prob += get_probability(m) / len(forward_edges[m])\n  probability[n] = prob\n  return prob\n  \ndef get_distance(n):\n  if estimated_distance[n] is not None:\n    return estimated_distance[n]\n  total_distance = 0\n  for m in forward_edges[n]:\n    total_distance += get_distance(m)\n  estimated_distance[n] = 1 + total_distance / len(forward_edges[n])\n  return estimated_distance[n]\n\n\nbefore_distance = get_distance(1)\nmax_decrease = 0\nfor n in range(1, N):\n  if len(forward_edges[n]) == 1:\n    continue\n  distances = [get_distance(m) for m in forward_edges[n]]\n  distance_diff = sum(distances) / len(distances) - (\n    sum(distances)-max(distances))/(len(distances)-1)\n  decrease = get_probability(n) * distance_diff\n  max_decrease = max(max_decrease, decrease)\n\nprint((before_distance - max_decrease))\n    \n", "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN, M = list(map(int, sys.stdin.readline().split()))\nST = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n\ngraph = [[] for _ in range(N + 1)]\nfor s, t in ST:\n    graph[s].append(t)\n\n# \u89e3\u8aacAC\n# \u9589\u8def\u306a\u3044\u304b\u3089\u5f8c\u308d\u304b\u3089\u898b\u3066\u3051\u3070OK\n\n\n# dp[v][u]: u \u304b\u3089\u306e\u51fa\u53e3\u3092\u585e\u3044\u3060\u3068\u304d\u306e\u3001v \u304b\u3089 N \u307e\u3067\u306e\u30b9\u30c6\u30c3\u30d7\u6570\u306e\u671f\u5f85\u5024\u306e\u6700\u5c0f\u5024\ndp = np.full((N + 1, N + 1), IINF, dtype=float)\ndp[N] = 0.0\nfor v in reversed(list(range(1, N))):\n    # \u585e\u304c\u306a\u3044\n    dp[v, :] = dp[graph[v], :].sum(axis=0) / len(graph[v]) + 1\n    if len(graph[v]) >= 2:\n        # \u585e\u3050\n        s = dp[graph[v], v].sum() - dp[graph[v], v].max()\n        dp[v, v] = s / (len(graph[v]) - 1) + 1\nprint((dp[1].min()))\n", "N,M = map(int,input().split())\nST = [tuple(map(int,input().split())) for i in range(M)]\n\nes = [[] for _ in range(N)]\nfor s,t in ST:\n    s,t = s-1,t-1\n    es[s].append(t)\n\ndp = [0] * N\nfor i in range(N-2,-1,-1):\n    s = 0\n    for to in es[i]:\n        s += dp[to]\n    dp[i] = 1 + s / len(es[i])\n\npp = [0] * N\npp[0] = 1.0\nfor i in range(N-1):\n    l = len(es[i])\n    for to in es[i]:\n        pp[to] += pp[i] / l\n\nans = dp[0]\nfor i in range(N-1):\n    l = len(es[i])\n    if l < 2: continue\n    before = 0\n    after_whole = 0\n    for to in es[i]:\n        before += dp[to] / l\n        after_whole += dp[to] / (l-1)\n    for to in es[i]:\n        after = after_whole - dp[to] / (l-1)\n        diff = (before - after) * pp[i]\n        ans = min(ans, dp[0] - diff)\nprint(ans)"]
["N,M=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ncd=[list(map(int,input().split())) for i in range(M)]\nli=[[] for i in range(N+1)]\nfor i in range(M):\n    li[cd[i][0]].append(cd[i][1])\n    li[cd[i][1]].append(cd[i][0])\nli2=[0]*(N+1)\nnum=0\nfor i in range(1,N+1):\n    deque=[i]\n    if li2[i]!=0:\n        break\n    li2[i]=i\n    num=i\n    while deque:\n        x=deque.pop(0)\n        for j in li[x]:\n            if li2[j]==0:\n                li2[j]=i\n                deque.append(j)\nli3=[[] for i in range(num)]\nfor i in range(1,N+1):\n    li3[li2[i]-1].append(i-1)\nfor i in range(len(li3)):\n    A=0\n    B=0\n    for j in range(len(li3[i])):\n        A+=a[li3[i][j]]\n        B+=b[li3[i][j]]\n    if A!=B:\n        print(\"No\")\n        break\n    elif i==len(li3)-1:\n        print(\"Yes\")", "class UnionFind:\n    def __init__(self, n):\n        # n: \u9802\u70b9\u6570\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        # x\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        # \u7121\u5411\u8fba\u3092\u306f\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def members(self, x):\n        # x\u306e\u5c5e\u3059\u308b\u96c6\u56e3\u306e\u9802\u70b9\u306e\u5217\u6319\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        # \u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u5217\u6319\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def all_group_members(self):\n        # \u6839\u3054\u3068\u306e\u96c6\u56e3\u8981\u7d20\u5217\u6319\n        return {r: self.members(r) for r in self.roots()}\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nUF = UnionFind(N)\nfor _ in range(M):\n  c,d=map(int,input().split())\n  UF.union(c-1,d-1)\na_sum = [0] * N\nb_sum = [0] * N\nfor i,(a,b) in enumerate(zip(A,B)):\n  a_sum[UF.find(i)] += a\n  b_sum[UF.find(i)] += b\nfor ai,bi in zip(a_sum,b_sum):\n  if ai != bi:\n    print('No')\n    break\nelse:\n  print('Yes')", "N,M=list(map(int,input().split()))\n\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\ntree=UnionFind(N)\n\nfor i in range(M):\n  cd=list(map(int,input().split()))\n  cd[0]-=1\n  cd[1]-=1\n  tree.union(cd[0],cd[1])\n\ndict={}\nfor i in range(N):\n  x=tree.find(i)\n  dict.setdefault(x,[])\n  dict[x].append(i)\n\nans=\"Yes\"\nfor i in dict:\n  asum=0\n  bsum=0\n  for j in dict[i]:\n    asum+=a[j]\n    bsum+=b[j]\n  if asum!=bsum:\n    ans=\"No\"\nprint(ans)\n\n\n  \n\n", "from collections import defaultdict\n\nclass UnionFind():\n  def __init__(self,num):\n    self.roots = [i for i in range(num+1)]\n    self.ranks = [1 for _ in range(num+1)]\n  \n  def get_root(self,node):\n    if node != self.roots[node]:\n      self.roots[node] = self.get_root(self.roots[node])\n    return self.roots[node]\n  \n  def unite(self,node_1,node_2):\n    root_1 = self.get_root(node_1)\n    root_2 = self.get_root(node_2)\n    if root_1 == root_2:\n      return\n    else:\n      if self.ranks[root_1] > self.ranks[root_2]:\n        self.roots[root_2] = root_1\n      else:\n        if self.ranks[root_1] == self.ranks[root_2]:\n          self.ranks[root_2] += 1\n        self.roots[root_1] = root_2\n        \n  def get_root_list(self):\n    for i in range(len(self.roots)):\n      self.get_root(i)\n    return self.roots\n \nn,m = map(int,input().split())\nbef = list(map(int,input().split()))\naft = list(map(int,input().split()))\ndif = [0] * n\n\nfor k in range(n):\n  dif[k] = aft[k] - bef[k]\n\nu = UnionFind(n)\nfor _ in range(m):\n  x,y = map(int,input().split())\n  u.unite(x,y)\n\nu_list = u.get_root_list()\n\nu_dict = defaultdict(set)\nfor z in range(n+1):\n  r = u_list[z]\n  u_dict[r].add(z)\n\nu_dict.pop(0)\n\nflag = True\nfor d in u_dict.values():\n  cnt = 0\n  for dd in d:\n    cnt += dif[dd-1]\n  if cnt != 0:\n    flag = False\n    break\n\nif flag:\n  print('Yes')\nelse:\n  print('No')", "class UnionFind():\n  def __init__(self,n):\n    self.n = n\n    self.par = [-1]*n\n\n  def unite(self,x,y):\n    rx = self.root(x)\n    ry = self.root(y)\n\n    if(rx==ry):\n      return\n    \n    if(self.par[rx]>self.par[ry]):\n      rx,ry = ry,rx\n    self.par[rx] += self.par[ry]\n    self.par[ry] = rx\n\n  def root(self,x):\n    if(self.par[x] < 0):\n      return x\n    else:\n      self.par[x] = self.root(self.par[x])\n      return self.par[x]\n  \n  def same(self,x,y):\n    if(self.root(x)==self.root(y)):\n      return True\n    else:\n      return False\n\n  def rank(self,x):\n    return -1*self.par[self.root(x)]\n\n  def root_num(self):\n    retval = 0\n    for i in range(self.n):\n      if self.par[i]<0:\n        retval+=1\n    return retval\n\n  def set_list(self):\n    l = [[-1] for i in range(self.n)]\n    for i in range(self.n):\n      if self.par[i]<0:\n        l[i].append(i)\n      else:\n        l[self.root(i)].append(i)\n    for i in range(self.n-1,-1,-1):\n      del l[i][0]\n      if len(l[i])==0:\n        del l[i]\n    return l\n\nN,M = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n  l = list(map(int,input().split()))\n  uf.unite(l[0]-1,l[1]-1)\n\nl = uf.set_list()\nfor i in range(len(l)):\n  sumA = 0\n  sumB = 0\n  for j in range(len(l[i])):\n    sumA += a[l[i][j]]\n    sumB += b[l[i][j]]\n  if sumA!=sumB:\n    print('No')\n    return\n\nprint('Yes')", "import sys\ninput = sys.stdin.readline\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [-1] * (n + 1)\n        self.sizes = [1] * (n + 1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        d1 = self.par[x]\n        d2 = self.par[y]\n        if d1 <= d2:\n            self.par[y] = x\n            self.sizes[x] = self.sizes[x] + self.sizes[y]\n            if d1 == d2:\n                self.par[x] = self.par[x] - 1\n        else:\n            self.par[x] = y\n            self.sizes[y] = self.sizes[x] + self.sizes[y]\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    # \u30b5\u30a4\u30ba\n    def size(self, x):\n        return self.sizes[self.find(x)]\n\n    # \u6728\u306e\u6570\n    def number(self):\n        count = 0\n        for i in self.par[1:]:\n            if i < 0:\n                count = count + 1\n        return count\n\n\nU = UnionFind(n)\nfor i in range(m):\n    c, d = list(map(int, input().split()))\n    c -= 1\n    d -= 1\n    U.union(c, d)\n#print(U)\ncheck = {}\nfor i in range(n):\n    x = U.find(i)\n    if x in check:\n        check[x].append(i)\n    else:\n        check[x] = [i]\n\nfor i in check:\n    l = check[i]\n    A = 0\n    B = 0\n    for j in l:\n        A += a[j]\n        B += b[j]\n    if A != B:\n        print('No')\n        return\nprint('Yes')\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n        \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nuf = UnionFind(n)\nfor i in range(m):\n    c,d=map(int,input().split())\n    uf.union(c-1,d-1)\n\nsumA={}\nsumB={}\nfor i in range(n):\n    g=uf.find(i)\n    if g in sumA:\n        sumA[g]+=a[i]\n        sumB[g]+=b[i]\n    else:\n        sumA[g]=a[i]\n        sumB[g]=b[i]\n\nans=\"Yes\"\nfor k in sumA.keys():\n    if sumA[k]!=sumB[k]:\n        ans=\"No\"\n        break\n\nprint(ans)", "class UnionFind():\n  def __init__(self, n, A, B):\n    self.n = n\n    self.parents = [-1] * n\n    self.values = [a-b for a,b in zip(A,B)]\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.values[x] += self.values[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_g = {}\n    for i, r in enumerate(roots):\n      r_to_g[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_g[self.find(i)]].append(i)\n    return groups\n\nimport sys,os,io\ninput = sys.stdin.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N, A, B)\nfor i in range(M):\n  c, d = list(map(int, input().split()))\n  uf.union(c-1,d-1)\nfor i in range(N):\n  if uf.parents[i]<0 and uf.values[i]!=0:\n    print('No')\n    return\nprint('Yes')\n\n", "# Values\n\n# Union-Find\u68ee\uff08\u7d20\u96c6\u5408\u30c7\u30fc\u30bf\u69cb\u9020\uff09\n# \u4e92\u3044\u306b\u7d20\u306a\u96c6\u5408\u3092\u6728\u69cb\u9020\u3068\u3057\u3066\u4fdd\u6301\nclass UnionFind:\n    def __init__(self, n):\n        # \u89aa\u30ce\u30fc\u30c9\uff1aparents[\u6839] == -(\u305d\u306e\u6728\u306e\u30ce\u30fc\u30c9\u6570)\n        self.parents = [-1] * n\n    \n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u6839\u3092\u8fd4\u3059\n    def find_root(self, x):\n        if self.parents[x] < 0:\n            return x\n\n        self.parents[x] = self.find_root(self.parents[x])  # \u7d4c\u8def\u5727\u7e2e\n        return self.parents[x]\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u3068\u30ce\u30fc\u30c9y\u304c\u5c5e\u3059\u308b\u6728\u3092\u7e4b\u3052\u308b\n    def unite(self, x, y):\n        root_x = self.find_root(x)\n        root_y = self.find_root(y)\n        if root_x == root_y:\n            return\n        \n        # \u30ce\u30fc\u30c9\u6570\u306e\u591a\u3044\u6728\u306b\u5c11\u306a\u3044\u6728\u3092\u7e4b\u3052\u308b\n        if self.parents[root_x] > self.parents[root_y]:  # y\u304c\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\u304cx\u306e\u3082\u306e\u3088\u308a\u591a\u3044\u3068\u304d\n            root_x, root_y = root_y, root_x\n        self.parents[root_x] += self.parents[root_y]\n        self.parents[root_y] = root_x\n\n    # \u30ce\u30fc\u30c9x\u3068\u30ce\u30fc\u30c9y\u304c\u540c\u3058\u6728\u306b\u5c5e\u3059\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\n    def are_in_same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n    \n    # \u30ce\u30fc\u30c9x\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\u3092\u8fd4\u3059\n    def get_size(self, x):\n        return -self.parents[self.find_root(x)]\n\n    # \u5168\u3066\u306e\u6839\u3092\u96c6\u5408\uff08set\uff09\u3067\u8fd4\u3059\n    def get_roots(self):\n        roots = set()\n        for i, x in enumerate(self.parents):\n            if x < 0:\n                roots.add(i)\n        return roots\n\n    # \u6839\uff08\u6728\uff09\u306e\u6570\u3092\u6570\u3048\u308b\n    def count_roots(self):\n        return len(self.get_roots())\n\n\nN, M = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nb = tuple(map(int, input().split()))\n\ngraph = UnionFind(N)\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    graph.unite(c - 1, d - 1)\n\nsum_a, sum_b = [0] * N, [0] * N\nfor i in range(N):\n    r = graph.find_root(i)\n    sum_a[r] += a[i]\n    sum_b[r] += b[i]\n\njudge = \"Yes\"\nfor r in graph.get_roots():\n    if sum_a[r] != sum_b[r]:\n        judge = \"No\"\n        break\n\nprint(judge)\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9+7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(n))\n        self.rank = [0] * n\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            r = self.root(self.par[x])\n            self.par[x] = r\n            return r\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.par[y] = x\n        return True\n\ndef resolve():\n    N, M = LI()\n    a = LI()\n    b = LI()\n    # \u9023\u7d50\u6210\u5206\u306e\u5408\u8a08\u304c\u7b49\u3057\u3051\u308c\u3070\u5b9f\u73fe\u53ef\u80fd\n    uf = UnionFind(N)\n    for _ in range(M):\n        c, d = LI_()\n        uf.merge(c, d)\n\n    d = collections.defaultdict(list)\n    for i in range(N):\n        p = uf.root(i)\n        d[p].append(i)\n    # print(d)\n    if [sum([a[j] for j in v]) == sum([b[j] for j in v]) for k, v in list(d.items())].count(False) == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):#\u8981\u7d20\u304c\u5165\u3063\u305f\u30b0\u30eb\u30fc\u30d7\u756a\u53f7\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):#2\u8981\u7d20\u304c\u5165\u3063\u305f\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):#\u8981\u7d20\u304c\u5165\u3063\u305f\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):#2\u8981\u7d20\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5165\u3063\u3066\u3044\u308b\u304b\n        return self.find(x) == self.find(y)\n\n    def members(self, x):#\u8981\u7d20\u304c\u5165\u3063\u305f\u30b0\u30eb\u30fc\u30d7\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):#\u6839\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):#\u30b0\u30eb\u30fc\u30d7\u6570\n        return len(self.roots())\n\n    def all_group_members(self):#.values()\u3067\u30b0\u30eb\u30fc\u30d7\u3054\u3068\u306e\u8981\u7d20\u306e\u30ea\u30b9\u30c8\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n#\u6587\u5b57\u5217\u306e\u5834\u5408\u306f\u8f9e\u66f8\u3092\u4f7f\u3044\u6570\u5b57\u3068\u6587\u5b57\u5217\u3092\u95a2\u9023\u4ed8\u3051\u308b\nuf = UnionFind(6)#\u8981\u7d20\u65706\u3067\u521d\u671f\u5316\n\nn,m = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\ndic = {}\nflag = True\n\nfor i in range(n):\n    dic.setdefault(i,B[i]-A[i])\n    \nuf = UnionFind(n)\n\nfor _ in range(m):\n    c,d = map(int,input().split())\n    c,d = c-1,d-1\n    uf.union(c,d)\n    \nfor gr in uf.all_group_members().values():\n    tem = 0\n    for point in gr:\n        tem += dic[point]\n    if not tem == 0:\n        flag = False\n        \nif flag:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "\nclass UnionFind:\n\n    def __init__(self, n: int):\n        self.parent = [i for i in range(n+1)]\n        self.rank   = [0]*(n+1)\n\n    def find(self, x: int) -> int:\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unit(self, x: int, y: int):\n        parent_x = self.find(x)\n        parent_y = self.find(y)\n        if self.rank[parent_x] < self.rank[parent_y]:\n            self.parent[parent_x] = parent_y\n        else:\n            self.parent[parent_y] = parent_x\n            if self.rank[parent_y] == self.rank[parent_x]:\n                self.rank[parent_x] += 1\n\n    def same_check(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\nN, M = list(map(int, input().split()))\n\nAls = list(map(int, input().split()))\nBls = list(map(int, input().split()))\n\nuf = UnionFind(N)\n\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    uf.unit(c, d)\n\nafter_als = [0]*N\nafter_bls = [0]*N\nfor i in range(N):\n    after_als[uf.find(i+1)-1] += Als[i]\n    after_bls[uf.find(i+1)-1] += Bls[i]\n\nfor i in range(N):\n    if after_als[i] != after_bls[i]:\n        print('No')\n        return\n\nprint('Yes')\n\n", "import sys\nfrom collections import defaultdict\n\n\ndef input(): return sys.stdin.readline().strip()\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef S(): return input()\ndef LS(): return input().split()\n\n\nINF = float('inf')\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * n  # \u5404\u8981\u7d20\u306e\u89aa \u89aa\u81ea\u8eab\u306f -i (i \u306f\u96c6\u5408\u306e\u8981\u7d20\u6570)\n\n    def r(self, x):  # x \u306e \u89aa\u3092\u8fd4\u3059\n        if self.root[x] < 0:  # \u81ea\u8eab\u304c\u89aa\n            return x\n        else:  # \u518d\u5e30\u7684\u306b\u89aa\u3092\u8fbf\u308b\n            self.root[x] = self.r(self.root[x])\n            return self.root[x]\n\n    def union(self, x, y):  # x \u3068 y \u3092\u9023\u7d50\n        x = self.r(x)\n        y = self.r(y)\n        if x == y:\n            return  # \u89aa\u304c\u540c\u3058\u306a\u3089\u4f55\u3082\u3057\u306a\u3044\n        self.root[x] += self.root[y]\n        self.root[y] = x\n\n    def find(self, x, y) -> bool:  # x \u3068 y \u306f\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\n        return self.root[x] == self.root[y]\n\n    # \u30aa\u30d7\u30b7\u30e7\u30f3\n    def size(self, x) -> int:  # x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u6570\n        x = self.r(x)\n        return -self.root[x]\n\n    def members(self, x):\n        '''\u8981\u7d20 x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3092\u8fd4\u3059'''\n        root = self.r(x)\n        return [i for i in range(self.n) if self.r(i) == root]\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.r(member)].append(member)\n        return group_members\n\n\nn, m = LI()\na = LI()\nb = LI()\nuf = UnionFind(n)\nfor _ in range(m):\n    c, d = LI()\n    c -= 1\n    d -= 1\n    uf.union(c, d)\n\n\nis_ok = True\nmems = list(uf.all_group_members().values())\n\nfor mem in mems:\n    a_sum = 0\n    b_sum = 0\n    for j in mem:\n        a_sum += a[j]\n        b_sum += b[j]\n    if a_sum != b_sum:\n        is_ok = False\n        break\n\nprint((\"Yes\" if is_ok else \"No\"))\n", "class UnionFind:\n    # \u3053\u306e\u6642\u70b9\u3067\u305d\u308c\u305e\u308c\u306e\u30ce\u30fc\u30c9\u306f\u81ea\u5206\u3092\u89aa\u3068\u3057\u3066\u3044\u308b\n    # \u521d\u671f\u5316\u6642\u306b\u554f\u984c\u304c0\u306e\u9802\u70b9\u3092\u8a8d\u3081\u308b\u304b\u306b\u6ce8\u610f\u3059\u308b\u3053\u3068\n    def __init__(self, n):\n        self.N = n\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n\n    # x\u306e\u6839\u3092\u8fd4\u3059\u95a2\u6570\n    def root(self, x):\n        visited_nodes = []\n        while True:\n            p = self.parent[x]\n            if p == x:\n                # \u7e2e\u7d04\n                for node in visited_nodes:\n                    self.parent[node] = x\n                return x\n            else:\n                visited_nodes.append(x)\n                x = p\n\n    # \u6728\u306e\u7d50\u5408\u3092\u884c\u3046\u3002\u89aa\u306e\u914d\u4e0b\u306b\u5165\u308b\n    def unite(self, x, y):\n        if not self.root(x) == self.root(y):\n            if self.rank[x] > self.rank[y]:\n                self.parent[self.root(y)] = self.root(x)\n            else:\n                self.parent[self.root(x)] = self.root(y)\n                if self.rank[x] == self.rank[y]:\n                    self.rank[self.root(y)] += 1\n\n    def ifSame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    # \u6728\u306e\u6839\u306b\u5230\u9054\u3059\u307e\u3067\u306b\u305f\u3069\u308b\u30ce\u30fc\u30c9\u306e\u914d\u5217\u3092\u8fd4\u3059\n    def printDebugInfo(self):\n        print([self.root(i) for i in range(self.N)])\n\n    def seikei(self):\n        for i in range(self.N):\n            self.root(i)\n\nN, M = list(map(int, input().split()))\ntree = UnionFind(N)\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nfor _ in range(M):\n    c, d = list(map(int, input().split()))\n    tree.unite(c-1, d-1)\n\ntree.seikei()\n\ngruops = {}\nfor i, x in enumerate(tree.parent):\n    if x in gruops:\n        gruops[x].append(i)\n    else:\n        gruops[x] = [i]\n\n\nfor k in list(gruops.keys()):\n    a_total = 0\n    b_total = 0\n    for x in gruops[k]:\n        a_total += A[x]\n        b_total += B[x]\n    if not a_total == b_total:\n        print('No')\n        return\nprint('Yes')\n\n", "# Values\n\n# Union-Find\u68ee\uff08\u7d20\u96c6\u5408\u30c7\u30fc\u30bf\u69cb\u9020\uff09\n# \u4e92\u3044\u306b\u7d20\u306a\u96c6\u5408\u3092\u6728\u69cb\u9020\u3068\u3057\u3066\u4fdd\u6301\nclass UnionFind:\n    def __init__(self, n):\n        # \u89aa\u30ce\u30fc\u30c9\uff1aparents[\u6839] == -(\u305d\u306e\u6728\u306e\u30ce\u30fc\u30c9\u6570)\n        self.parents = [-1] * n\n    \n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u6839\u3092\u8fd4\u3059\n    def find_root(self, x):\n        if self.parents[x] < 0:\n            return x\n\n        self.parents[x] = self.find_root(self.parents[x])  # \u7d4c\u8def\u5727\u7e2e\n        return self.parents[x]\n\n    # \u30ce\u30fc\u30c9x\u304c\u5c5e\u3059\u308b\u6728\u3068\u30ce\u30fc\u30c9y\u304c\u5c5e\u3059\u308b\u6728\u3092\u7e4b\u3052\u308b\n    def unite(self, x, y):\n        root_x = self.find_root(x)\n        root_y = self.find_root(y)\n        if root_x == root_y:\n            return\n        \n        # \u30ce\u30fc\u30c9\u6570\u306e\u591a\u3044\u6728\u306b\u5c11\u306a\u3044\u6728\u3092\u7e4b\u3052\u308b\n        if self.parents[root_x] > self.parents[root_y]:  # y\u304c\u5c5e\u3059\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\u304cx\u306e\u3082\u306e\u3088\u308a\u591a\u3044\u3068\u304d\n            root_x, root_y = root_y, root_x\n        self.parents[root_x] += self.parents[root_y]\n        self.parents[root_y] = root_x\n\n    # \u30ce\u30fc\u30c9x\u3068\u30ce\u30fc\u30c9y\u304c\u540c\u3058\u6728\u306b\u5c5e\u3059\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\n    def are_in_same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n    \n    # \u30ce\u30fc\u30c9x\u304c\u542b\u307e\u308c\u308b\u6728\u306e\u30ce\u30fc\u30c9\u6570\u3092\u8fd4\u3059\n    def get_size(self, x):\n        return -self.parents[self.find_root(x)]\n\n    # \u5168\u3066\u306e\u6839\u3092\u96c6\u5408\uff08set\uff09\u3067\u8fd4\u3059\n    def get_roots(self):\n        roots = set()\n        for i, x in enumerate(self.parents):\n            if x < 0:\n                roots.add(i)\n        return roots\n\n    # \u6839\uff08\u6728\uff09\u306e\u6570\u3092\u6570\u3048\u308b\n    def count_roots(self):\n        return len(self.get_roots())\n\n\nN, M = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nb = tuple(map(int, input().split()))\n\ngraph = UnionFind(N)\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    graph.unite(c - 1, d - 1)\n\nsum_a, sum_b = [0] * N, [0] * N\nfor i in range(N):\n    r = graph.find_root(i)\n    sum_a[r] += a[i]\n    sum_b[r] += b[i]\n\njudge = \"Yes\"\nfor r in graph.get_roots():\n    if sum_a[r] != sum_b[r]:\n        judge = \"No\"\n        break\n\nprint(judge)\n", "n,m=map(int,input().split())\nans=[list(map(int,input().split())) for i in range(2)]\nl=[[] for i in range(n)]\nfor i in range(m):\n    a,b=map(int,input().split())\n    l[a-1].append(b-1)\n    l[b-1].append(a-1)\nboo=[-1]*n\nflag=0\nfrom collections import deque\nfor i in range(n):\n    if boo[i]==-1:\n        q=deque([])\n        q.append(i)\n        ma=0\n        wa=0\n        while q:\n            a=q.popleft()\n            if boo[a]==-1:\n                boo[a]+=1\n                ma+=ans[0][a]\n                wa+=ans[1][a]\n                for j in l[a]:\n                    q.append(j)\n        if ma!=wa:\n            flag=1\n            break\nif flag==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    r_to_g = {}\n    cnt = 0\n    groups = []\n    for i in range(self.n):\n      r = self.find(i)\n      if r not in r_to_g:\n        groups.append([i])\n        r_to_g[r] = cnt\n        cnt += 1\n      else:\n        groups[r_to_g[r]].append(i)\n    return groups\n\nimport sys,os,io\ninput = sys.stdin.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = map(int, input().split())\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')", "class UnionFind:\n    def __init__(self, size):\n        self.data = [-1] * size\n    def root(self, x):\n        if self.data[x] < 0:\n            return x\n        ans = self.root(self.data[x])\n        self.data[x] = ans\n        return ans\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.data[x] > self.data[y]:\n            x, y = y, x\n        self.data[x] += self.data[y]\n        self.data[y] = x\n        return True\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n\nn,m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nuf = UnionFind(n)\n\nfor _ in range(m):\n  c,d = map(int, input().split())\n  c -= 1\n  d -= 1\n  uf.unite(c, d)\n\nl = [0]*n\n\nfor i in range(n):\n  p = uf.root(i)\n  l[p] += a[i]\n  l[p] -= b[i]\n\nif all([x==0 for x in l]):\n  print('Yes')\nelse:\n  print('No')", "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(10**6)\n\ndef inp():\n    return int(input())\ndef inps():\n    return input().rstrip()\ndef inpl():\n    return list(map(int, input().split()))\ndef inpls():\n    return list(map(str, input().split()))\n\n# import decimal\n# from decimal import Decimal\n# decimal.getcontext().prec = 10\n\n# from heapq import heappush, heappop, heapify\n# import math\nfrom math import gcd, floor, ceil, factorial\nimport itertools as it\nfrom collections import deque, defaultdict\nfrom collections import Counter\n\ndef lcd(a, b):\n    return a * b // gcd(a, b)\n\ndef chmin(dp, i, x):\n    if x < dp[i]: dp[i] = x; return True\n    return False\n\ndef chmax(dp, i, x): \n    if x > dp[i]: dp[i] = x; return True\n    return False\n\n# ---------------------------------------\n\n\nclass UnionFind:\n    def __init__(self, num):\n        self.parent = [i for i in range(num)]\n        self.size = [1] * num\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n        else:\n            return x\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        else:\n            if self.size[x] < self.size[y]:\n                x, y = y, x\n            self.parent[y] = x\n            self.size[x] += 1\n    \n    def roots(self):\n        st = set()\n        for i in self.parent:\n            st.add(i)\n        return list(st)\n\n\nN, M = inpl()\na = inpl()\nb = inpl()\nuf = UnionFind(N)\nfor i in range(M):\n    c, d = inpl()\n    c -= 1\n    d -= 1\n    uf.unite(c, d)\n\nmp = dict()\nfor i in uf.roots():\n    mp[i] = 0\n\nfor i in range(N):\n    group = uf.find(i)\n    mp[group] += a[i] - b[i]\n\nbl = True\nfor k, v in list(mp.items()):\n    if v != 0:\n        bl = False\n        break\n\nprint((\"Yes\" if bl else \"No\"))\n", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    r_to_g = {}\n    cnt = 0\n    groups = []\n    for i in range(self.n):\n      r = self.find(i)\n      if r not in r_to_g:\n        groups.append([i])\n        r_to_g[r] = cnt\n        cnt += 1\n      else:\n        groups[r_to_g[r]].append(i)\n    return groups\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = map(int, input().split())\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')", "\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\nn,m = list(map(int,input().split()))\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nuf = UnionFind(n)\nfor i in range(m):\n    c,d = list(map(int,input().split()))\n    uf.union(c - 1,d - 1)\n#print(uf)\n#print(uf.all_group_members())\nfor i in list(uf.all_group_members().values()):\n    s1 = 0\n    s2 = 0\n    for j in i:\n        s1 += a[j]\n        s2 += b[j]\n    if s1 != s2:\n        print(\"No\")\n        return\nprint(\"Yes\")\n", "class Union_Find():\n    def __init__(self,N):\n        \"\"\"0,1,...,n-1\u3092\u8981\u7d20\u3068\u3057\u3066\u521d\u671f\u5316\u3059\u308b.\n\n        N:\u8981\u7d20\u6570\n        \"\"\"\n        self.n=N\n        self.parents=[-1]*N\n        self.rank=[0]*N\n\n    def find(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u65cf\u3092\u8abf\u3079\u308b.\n\n        x:\u8981\u7d20\n        \"\"\"\n        V=[]\n        while self.parents[x]>=0:\n            V.append(x)\n            x=self.parents[x]\n\n        for v in V:\n            self.parents[v]=x\n        return x\n\n    def union(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u3092\u540c\u4e00\u8996\u3059\u308b.\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x]>self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n\n            if self.rank[x]==self.rank[y]:\n                self.rank[y]+=1\n\n    def size(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u8981\u7d20\u306e\u6570.\n\n        x:\u8981\u7d20\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u306f\u540c\u4e00\u8996\u3055\u308c\u3066\u3044\u308b\u304b?\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        \"\"\"\u8981\u7d20x\u304c\u5c5e\u3057\u3066\u3044\u308b\u65cf\u306e\u8981\u7d20.\n        \u203b\u65cf\u306e\u8981\u7d20\u306e\u500b\u6570\u304c\u6b32\u3057\u3044\u3068\u304d\u306fsize\u3092\u4f7f\u3046\u3053\u3068!!\n\n        x:\u8981\u7d20\n        \"\"\"\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        \"\"\"\u65cf\u306e\u540d\u524d\u306e\u30ea\u30b9\u30c8\n        \"\"\"\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        \"\"\"\u65cf\u306e\u500b\u6570\n        \"\"\"\n        return len(self.roots())\n\n    def all_group_members(self):\n        \"\"\"\u5168\u3066\u306e\u65cf\u306e\u51fa\u529b\n        \"\"\"\n        X={r:[] for r in self.roots()}\n        for k in range(self.n):\n            X[self.find(k)].append(k)\n        return X\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n#================================================\nimport sys\ninput=sys.stdin.readline\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nU=Union_Find(N)\nfor _ in range(M):\n    c,d=map(int,input().split())\n    U.union(c-1,d-1)\n\nH=U.all_group_members()\nF=True\nfor g in H:\n    X=Y=0\n    for u in H[g]:\n        X+=A[u]\n        Y+=B[u]\n    F=F&(X==Y)\n\nif F:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):#\u30b0\u30eb\u30fc\u30d7\u306e\u6839\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):#x\u3068y\u3092\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):#x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u6570\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):#x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5224\u5b9a\n        return self.find(x) == self.find(y)\n\n    def members(self, x):#x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30ea\u30b9\u30c8\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):#\u5168\u3066\u306e\u6839\u306e\u30ea\u30b9\u30c8\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):#\u30b0\u30eb\u30fc\u30d7\u306e\u6570\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\nN,M=map(int,input().split())\nalist = list(map(int, input().split()))\nblist = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n    C,D=map(int,input().split())\n    uf.union(C-1,D-1)\na = [0]*N\nb = [0]*N\nfor i in range(N):\n    a[uf.find(i)]+=alist[i]\n    b[uf.find(i)]+=blist[i]\nif a==b:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_g = {}\n    for i, r in enumerate(roots):\n      r_to_g[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_g[self.find(i)]].append(i)\n    return groups\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = list(map(int, input().split()))\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')\n\n", "import sys, math, random, re, heapq\nfrom itertools import combinations as c, permutations as perm, product as p\nfrom collections import deque\nfrom copy import deepcopy\nsys.setrecursionlimit(10**9)\nINF = float('inf')\nMOD = 10**9 + 7\n#MOD = 998244353\n\n\ndef si(): return input()\ndef ii(): return int(input())\ndef fi(): return float(input())\ndef lstr(): return input().split()\ndef lint(): return list(map(int, input().split()))\ndef lintdec(): return list(map(lambda x:int(x) - 1, input().split()))\ndef lnstr(n): return [input() for _ in range(n)]\ndef lnint(n): return [ii() for _ in range(n)]\ndef lint_list(n): return [lint() for _ in range(n)]\ndef lcm(a, b): return a * b // math.gcd(a, b)\n\n\n\n#######################################################\nN, M = lint()\n\nclass UnionFind():\n    def __init__(self):\n        self.par = [0] * N\n        self.rank = [0] * N\n        for i in range(N):\n            self.par[i] = i\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        parx = self.root(self.par[x])\n        self.par[x] = parx\n        return parx\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n\ndef main():\n    UF = UnionFind()\n    a = lint()\n    b = lint()\n\n    for _ in range(M):\n        c, d = lintdec()\n        UF.unite(c, d)\n    \n    roots = [UF.root(i) for i in range(N)]\n    sum_a = {root: 0 for root in set(roots)}\n    sum_b = sum_a.copy()\n\n    for i in range(N):\n        sum_a[roots[i]] += a[i]\n        sum_b[roots[i]] += b[i]\n\n    print('Yes' if sum_a == sum_b else 'No')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "class UnionFind():\n  def __init__(self, n, A, B):\n    self.n = n\n    self.parents = [-1] * n\n    self.values = [a-b for a,b in zip(A,B)]\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.values[x] += self.values[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_g = {}\n    for i, r in enumerate(roots):\n      r_to_g[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_g[self.find(i)]].append(i)\n    return groups\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N, A, B)\nfor i in range(M):\n  c, d = map(int, input().split())\n  uf.union(c-1,d-1)\nfor i in range(N):\n  if uf.parents[i]<0 and uf.values[i]!=0:\n    print('No')\n    return\nprint('Yes')", "import sys\nfrom functools import reduce\n\nzz=1\n \nsys.setrecursionlimit(10**5)\nif zz:\n\tinput=sys.stdin.readline\nelse:\t\n\tsys.stdin=open('input.txt', 'r')\n\tsys.stdout=open('all.txt','w')\ndi=[[-1,0],[1,0],[0,1],[0,-1]]\n\ndef fori(n):\n\treturn [fi() for i in range(n)]\t\ndef inc(d,c,x=1):\n\td[c]=d[c]+x if c in d else x\ndef ii():\n\treturn input().rstrip()\t\ndef li():\n\treturn [int(xx) for xx in input().split()]\ndef fli():\n\treturn [float(x) for x in input().split()]\t\ndef comp(a,b):\n\tif(a>b):\n\t\treturn 2\n\treturn 2 if a==b else 0\t\t\ndef gi():\t\n\treturn [xx for xx in input().split()]\ndef gtc(tc,ans):\n\tprint((\"Case #\"+str(tc)+\":\",ans))\t\ndef cil(n,m):\n\treturn n//m+int(n%m>0)\t\ndef fi():\n\treturn int(input())\ndef pro(a): \n\treturn reduce(lambda a,b:a*b,a)\t\t\ndef swap(a,i,j): \n\ta[i],a[j]=a[j],a[i]\t\ndef si():\n\treturn list(input().rstrip())\t\ndef mi():\n\treturn \tlist(map(int,input().split()))\t\t\t\ndef gh():\n\tsys.stdout.flush()\ndef isvalid(i,j,n,m):\n\treturn 0<=i<n and 0<=j<m \ndef bo(i):\n\treturn ord(i)-ord('a')\t\ndef graph(n,m):\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\ta[x].append(y)\n\t\ta[y].append(x)\n\n\nt=1\nuu=t\ndef find(i):\n\tif i==a[i]:\n\t\treturn i\n\ta[i]=find(a[i])\n\treturn a[i]\ndef union(x,y):\n\txs,ys=find(x),find(y)\n\tif xs!=ys:\n\t\tif rank[xs]<rank[ys]:\n\t\t\txs,ys=ys,xs\n\t\ta[ys]=xs\n\t\trank[xs]+=1\n\t\treturn False\n\treturn True\t\n\n\nwhile t>0:\n\tt-=1\n\tn,m=mi()\n\ta=[i for i in range(n+1)]\n\trank=[0]*(n+1)\n\tc=li()\n\td=li()\n\tfor i in range(m):\n\t\tx,y=mi()\n\t\tunion(x,y)\n\tp=[0]*(n+1)\n\tfor i in range(n):\n\t\ta[i+1]=find(i+1)\n\t\tp[a[i+1]]+=c[i]-d[i]\t\n\tprint((\"Yes\" if p.count(0)==len(p) else \"No\"))\t\n", "# Values\n\n# \u5404\u9023\u7d50\u6210\u5206\u306b\u304a\u3044\u3066a_i\u306e\u7dcf\u548c\u3068b_i\u306e\u7dcf\u548c\u304c\u7b49\u3057\u3051\u308c\u3070\u3088\u3044\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nb = tuple(map(int, input().split()))\ngraph = [[] for i in range(N)]\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    graph[c - 1].append(d - 1)\n    graph[d - 1].append(c - 1)\ngraph = tuple(tuple(l) for l in graph)\n\nunreached = set(range(N))\nqueue = deque()\njudge = \"Yes\"\nwhile len(unreached) > 0:\n    node = unreached.pop()\n    queue.append(node)\n    sum_a = a[node]\n    sum_b = b[node]\n\n    # \u9802\u70b9\u3092\u5e45\u512a\u5148\u63a2\u7d22\n    while len(queue) > 0:\n        for node in graph[queue.pop()]:\n            if node in unreached:\n                unreached.remove(node)\n                queue.append(node)\n                sum_a += a[node]\n                sum_b += b[node]\n    \n    if sum_a != sum_b:\n        judge = \"No\"\n        break\n\nprint(judge)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n'''\nN, M = 2 * 10 ** 5, 0\nA = [10 ** 9] * N\nB = [10 ** 9] * N\n'''\nuf = UnionFind(N)\nfor _ in range(M):\n    c, d = map(int, input().split())\n    uf.union(c - 1, d - 1)\n\nroot_Asum = [0] * N\nroot_Bsum = [0] * N\nfor i in range(N):\n    now_root = uf.find(i)\n    root_Asum[now_root] += A[i]\n    root_Bsum[now_root] += B[i]\nfor a_sum, b_sum in zip(root_Asum, root_Bsum):\n    if a_sum != b_sum:\n        print('No')\n        return\nprint('Yes')", "import collections\nimport itertools\nimport operator\n\nclass UnionFind:\n    def __init__(self, elems=None):\n        class KeyDict(dict):\n            def __missing__(self, key):\n                self[key] = key\n                return key\n\n        self.parent = KeyDict()\n        self.rank = collections.defaultdict(int)\n\n        if elems is not None:\n            for elem in elems:\n                _, _ = self.parent[elem], self.rank[elem]\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n\n    def are_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def grouper(self):\n        roots = [(x, self.find(x_par)) for x, x_par in self.parent.items()]\n        root = operator.itemgetter(1)\n        for _, group in itertools.groupby(sorted(roots, key=root), root):\n            yield [x for x, _ in group]\n            \nN,M = list(map(int,input().split()))\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nuf = UnionFind()\n    \nfor m in range(M):\n    n1,n2 = list(map(int,input().split()))\n    uf.unite(n1,n2)\n    \nfor n in range(N):\n    n = n+1\n    uf.unite(n,n)\n    \nans = 'Yes'\nfor g_nodes in list(uf.grouper()):\n    a_sum = 0\n    b_sum = 0\n    for node in g_nodes:\n        a_sum += A[node-1]\n        b_sum += B[node-1]\n        \n    if a_sum != b_sum:\n        ans = 'No'\n        \nprint(ans)", "# B - Values\n# https://atcoder.jp/contests/arc106/tasks/arc106_b\n\nclass UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n    \n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n        return\n\n    if self.parents[x] > self.parents[y]:\n        x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def size(self, x):\n    return -self.parents[self.find(x)]\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def members(self, x): # O(N)\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def all_group_members(self):\n    self.group = {r:[] for r in self.roots()}\n    for i in range(self.n):\n      self.group[self.find(i)].append(i)\n    return self.group\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def group_count(self):\n    return len(self.roots())\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(k, v) for k, v in list(self.all_group_members().items()))\n\nn, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nCD = [list(map(int, input().split())) for _ in range(m)] \n\nuf = UnionFind(n)\nfor c, d in CD:\n  uf.union(c - 1, d - 1)\n\nfor key, val in list(uf.all_group_members().items()):\n    if sum(A[i] for i in val) != sum(B[i] for i in val):\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n    c, d = map(int, input().split())\n    uf.union(c-1, d-1)\n\nsamu1 = [0]*N\nsamu2 = [0]*N\nfor i in range(N):\n    r = uf.find(i)\n    samu1[r] += A[i]\n    samu2[r] += B[i]\n\nfor i in range(N):\n    if samu1[i] != samu2[i]:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")", "from collections import defaultdict as dd\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*n\n        self.rank = [0]*n\n\n    def find(self, x):\n        if self.root[x-1] < 0:\n            return x\n        else:\n            self.root[x-1] = self.find(self.root[x-1])\n            return self.root[x-1]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x==y:\n            return\n        elif self.rank[x-1] > self.rank[y-1]:\n            self.n-=1\n            self.root[x-1] += self.root[y-1]\n            self.root[y-1] = x\n        else:\n            self.n-=1\n            self.root[y-1] += self.root[x-1]\n            self.root[x-1] = y\n            if self.rank[x-1] == self.rank[y-1]:\n                self.rank[y-1] += 1\n\n    def same(self, x, y):\n        return self.find(x)==self.find(y)\n\n    def count(self, x):\n        return -self.root[self.find(x)-1]\n\n    def size(self):\n        return self.n\n\ndef main():\n    n,m=map(int,input().split())\n    A=list(map(int,input().split()))\n    B=list(map(int,input().split()))\n    uf=UnionFind(n)\n    for _ in range(m): uf.unite(*map(int,input().split()))\n    s=dd(int)\n    t=dd(int)\n    for i in range(n):\n        ii=uf.find(i+1)\n        s[ii]+=A[i]\n        t[ii]+=B[i]\n    for k in s.keys():\n        if s[k]==t[k]: continue\n        else:\n            print('No')\n            break\n    else: print('Yes')\n\nmain()", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_g = {}\n    for i, r in enumerate(roots):\n      r_to_g[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_g[self.find(i)]].append(i)\n    return groups\n\nimport sys,os,io\ninput = sys.stdin.readline\n#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = map(int, input().split())\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')", "import sys\nreadline = sys.stdin.readline\n\nN,M = list(map(int,readline().split()))\nA = list(map(int,readline().split()))\nB = list(map(int,readline().split()))\n\nG = [[] for i in range(N)]\nfor i in range(M):\n  c,d = list(map(int,readline().split()))\n  G[c - 1].append(d - 1)\n  G[d - 1].append(c - 1)\n\nseen = set()\nfor i in range(N):\n  if i in seen:\n    continue\n  stack = [i]\n  a_sum = 0\n  b_sum = 0\n  while stack:\n    v = stack.pop()\n    if v in seen:\n      continue\n    seen.add(v)\n    a_sum += A[v]\n    b_sum += B[v]\n    for child in G[v]:\n      stack.append(child)\n  if a_sum != b_sum:\n    print(\"No\")\n    break\nelse:\n  print(\"Yes\")\n", "import sys\ninput=sys.stdin.readline # for speed up\n\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ndiff=[0]*n\nfor ii in range(n):\n  diff[ii]=b[ii]-a[ii]\n\n# union find\nparent=list(range(n))\nrank=[0]*n\n\ndef findroot(x):\n  if parent[x]!=x:\n    parent[x]=findroot(parent[x])\n  return parent[x]\n\ndef unite(x,y):\n  x = findroot(x)\n  y = findroot(y)\n  if x != y: # not a same group\n    if rank[x]==rank[y]: # same depth\n      parent[y]=x # add group y into group x\n      rank[x]+=1\n    elif rank[x]<rank[y]:\n      parent[x]=y # add group x into group y\n    else: # rank[x]>rank[y]\n      parent[y]=x # add group y into group x\n  return\n            \nfor _ in range(m):\n  x,y=map(int,input().split())\n  unite(x-1,y-1)\n\n# update\nr=[-1]*n\nfor ii in range(n):\n  r[ii]=findroot(ii)\n\nsum=[0]*n\nfor ii,rr in enumerate(r):\n  sum[rr]+=diff[ii]\n\nfor ii in sum:\n  if ii:\n    print(\"No\")\n    return\nprint(\"Yes\")", "from collections import defaultdict\n\n#n\u500b\u306e\u8981\u7d20\u30920 ~ n - 1\u306e\u756a\u53f7\u3067\u7ba1\u7406\u3059\u308b\u3002\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        #\u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n        #\u8981\u7d20\u304c\u6839\uff08\u30eb\u30fc\u30c8\uff09\u306e\u5834\u5408\u306f-(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\u3092\u683c\u7d0d\u3059\u308b\n\n    def find(self, x):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        #\u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        #\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        #\u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        #\u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n        return len(self.roots())\n\n    def all_group_members(self):\n        #{\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306edefaultdict\u3092\u8fd4\u3059\n        #defaultdict\u306f\u8f9e\u66f8dict\u306e\u30b5\u30d6\u30af\u30e9\u30b9\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        #print()\u3067\u306e\u8868\u793a\u7528\n        #\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059\n        #f\u6587\u5b57\u5217\u3092\u5229\u7528\u3057\u3066\u3044\u308b\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n    \nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nuf=UnionFind(n)\nfor i in range(m):\n    x,y=map(int,input().split())\n    uf.union(x-1,y-1) #0 ~ n - 1\u306e\u756a\u53f7\u3067\u7ba1\u7406\u3057\u3066\u3044\u308b\u306e\u3067\u30011-index\u304b\u30890-index\u306b\u5909\u66f4\u3059\u308b\u3002\n\n#print(uf.roots())\n#print(uf.group_count)\n#print(uf.all_group_members())\n#print(uf.all_group_members().values())\nfor i in (uf.all_group_members().values()):\n    #print(i)\n    c=0\n    d=0\n    for j in i:\n        c+=a[j]\n        d+=b[j]\n    if c!=d:\n        print(\"No\")\n        break\nelse:\n    #else\u306e\u4e2d\u306e\u51e6\u7406\u306f\u3001for\u6587\u306e\u4e2d\u306e\u3059\u3079\u3066\u306e\u51e6\u7406\u304c\u7d42\u308f\u3063\u305f\u5f8c\u306b\u5b9f\u884c\u3055\u308c\u307e\u3059\u3002\n    #break\u304c\u5b9f\u884c\u3055\u308c\u305f\u5834\u5408\u306f\u8868\u793a\u3055\u308c\u307e\u305b\u3093\u3002\n    print(\"Yes\")", "#coding: utf-8\n\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nres = []\nfor i in range(N):\n    res.append(A[i] - B[i])\nuf = UnionFind(N)\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    uf.union(c-1, d-1)\nflag = True\nsa = {}\nsb = {}\nfor i in range(N):\n    r = uf.find(i)\n    if r not in list(sa.keys()):\n        sa[r] = A[i]\n        sb[r] = B[i]\n    else:\n        sa[r] += A[i]\n        sb[r] += B[i]\nfor k in list(sa.keys()):\n    if sa[k] != sb[k]:\n        flag = False\n\nprint((\"Yes\" if flag else \"No\"))\n# print(sa)\n# print(sb)\n# print(uf.parents)\n", "from collections import deque\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nA.insert(0,0)\nB = list(map(int,input().split()))\nB.insert(0,0)\nG = {i:[] for i in range(1,N+1)}\nfor _ in range(M):\n    c,d = map(int,input().split())\n    G[c].append(d)\n    G[d].append(c)\nCol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1,N+1):\n    if Col[i]<0:\n        que = deque([i])\n        Col[i] = cnt\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if Col[y]<0:\n                    Col[y]=cnt\n                    que.append(y)\n        cnt += 1\nMem = {c:[] for c in range(cnt)}\nfor i in range(1,N+1):\n    Mem[Col[i]].append(i)\nflag = 0\nfor c in Mem:\n    c1 = 0\n    c2 = 0\n    for i in Mem[c]:\n        c1 += A[i]\n        c2 += B[i]\n    if c1!=c2:\n        flag = 1\n        break\nif flag==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "import typing\n\n\nclass DSU:\n    '''\n    Implement (union by size) + (path halving)\n    Reference:\n    Zvi Galil and Giuseppe F. Italiano,\n    Data structures and algorithms for disjoint set union problems\n    '''\n\n    def __init__(self, n: int = 0) -> None:\n        self._n = n\n        self.parent_or_size = [-1] * n\n\n    def merge(self, a: int, b: int) -> int:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n\n        x = self.leader(a)\n        y = self.leader(b)\n\n        if x == y:\n            return x\n\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\n            x, y = y, x\n\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n\n        return x\n\n    def same(self, a: int, b: int) -> bool:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a: int) -> int:\n        assert 0 <= a < self._n\n\n        parent = self.parent_or_size[a]\n        while parent >= 0:\n            if self.parent_or_size[parent] < 0:\n                return parent\n            self.parent_or_size[a], a, parent = (\n                self.parent_or_size[parent],\n                self.parent_or_size[parent],\n                self.parent_or_size[self.parent_or_size[parent]]\n            )\n\n        return a\n\n    def size(self, a: int) -> int:\n        assert 0 <= a < self._n\n\n        return -self.parent_or_size[self.leader(a)]\n\n    def groups(self) -> typing.List[typing.List[int]]:\n        leader_buf = [self.leader(i) for i in range(self._n)]\n\n        result: typing.List[typing.List[int]] = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            result[leader_buf[i]].append(i)\n\n        return list(filter(lambda r: r, result))\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ncd = [list(map(int, input().split())) for _ in range(m)]\n\nuf = DSU(n)\nfor c, d in cd:\n    uf.merge(c - 1, d - 1)\n\nfor i in uf.groups():\n    x = 0\n    y = 0\n    for j in i:\n        x += a[j]\n        y += b[j]\n    if x != y:\n        print(\"No\")\n        return\nprint(\"Yes\")", "import queue\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nnds = [[] for _ in range(N)]\nvstd = [False for _ in range(N)]\nans = \"Yes\"\nfor i in range(M):\n  c,d = map(int,input().split())\n  c -= 1\n  d -= 1\n  nds[c].append(d)\n  nds[d].append(c)\nfor i in range(N):\n  if vstd[i]:\n    continue\n  q = queue.Queue()\n  q.put(i)\n  vstd[i] = True\n  \n  a = 0\n  b = 0\n  while not q.empty():\n    idx = q.get()\n    a += A[idx]\n    b += B[idx]\n    for e in nds[idx]:\n      if vstd[e]:\n        continue\n      vstd[e] = True\n      q.put(e)\n  if a!=b:\n    ans = \"No\"\nprint(ans)", "n, m = list(map(int, input().split()))\n\ng = [[] for _ in range(n)]\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n\n    x -= 1\n    y -= 1\n    g[x].append(y)\n    g[y].append(x)\nvisited = [0] * n\nfor i in range(n):\n    if not visited[i]:\n        stack = [i]\n        curr = 0\n        visited[i] = 1\n        while stack:\n            node = stack.pop()\n            curr += a[node] - b[node]\n            for j in g[node]:\n                if not visited[j]:\n                    visited[j] = 1\n                    stack.append(j)\n        if curr:\n            print('No')\n            return\n\nprint(\"Yes\")\n", "from collections import deque\nn,m = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nG = [[] for _ in range(n)]\nfor i in range(m):\n    i,j = map(int, input().split())\n    i -= 1\n    j -= 1\n    G[i].append(j)\n    G[j].append(i)\n\nseen = [False] * n\nque = deque()\n\nfor i in range(n):\n    if not seen[i]:\n        que.append(i)\n        seen[i] = True\n        a, b = 0, 0\n        while len(que):\n            v = que.popleft()\n            a += A[v]\n            b += B[v]\n            for nv in G[v]:\n                if not seen[nv]:\n                    que.append(nv)\n                    seen[nv] = True\n        if a != b:\n            print(\"No\")\n            return\n\nprint(\"Yes\")", "# Values\n\n# \u5404\u9023\u7d50\u6210\u5206\u306b\u304a\u3044\u3066a_i\u306e\u7dcf\u548c\u3068b_i\u306e\u7dcf\u548c\u304c\u7b49\u3057\u3051\u308c\u3070\u3088\u3044\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nb = tuple(map(int, input().split()))\ngraph = [[] for i in range(N)]\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    graph[c - 1].append(d - 1)\n    graph[d - 1].append(c - 1)\ngraph = tuple(tuple(l) for l in graph)\n\nunreached = set(range(N))\nqueue = deque()\njudge = \"Yes\"\nwhile len(unreached) > 0:\n    node = unreached.pop()\n    queue.append(node)\n    sum_a = a[node]\n    sum_b = b[node]\n\n    # \u9802\u70b9\u3092\u5e45\u512a\u5148\u63a2\u7d22\n    while len(queue) > 0:\n        for node in graph[queue.pop()]:\n            if node in unreached:\n                unreached.remove(node)\n                queue.append(node)\n                sum_a += a[node]\n                sum_b += b[node]\n    \n    if sum_a != sum_b:\n        judge = \"No\"\n        break\n\nprint(judge)\n", "from collections import defaultdict\nclass UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_i = {}\n    for i, r in enumerate(roots):\n      r_to_i[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_i[self.find(i)]].append(i)\n    return groups\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = list(map(int, input().split()))\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')\n\n", "# https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n): # O(n == \u9802\u70b9\u306e\u500b\u6570)\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) \u6839\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059 \u306a\u3089\u3057\u8a08\u7b97\u91cfO(\u03b1(\u9802\u70b9\u6570))\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x]) # \u7d4c\u8def\u5727\u7e2e\n            return self.parents[x]\n\n    def union(self, x, y): # O(x\u304by\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) x\u3068y\u3092\u9023\u7d50\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return x\n\n    def size(self, x): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba) x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b(True)\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n\n    def members(self, x): # O(\u9802\u70b9\u6570) x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u305f\u3061\u306e\u30ea\u30b9\u30c8 \u3059\u3079\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u4f7f\u3044\u305f\u3044\u306a\u3089all_group_members\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self): # O(\u9802\u70b9\u6570) \u89aa\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u305f\u3061\u306e\u30ea\u30b9\u30c8\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self): # O(\u9802\u70b9\u6570) \u30b0\u30eb\u30fc\u30d7\u306e\u500b\u6570\n        return len(self.roots())\n\n    def group_sizes(self): # O(\u9802\u70b9\u6570) \u3059\u3079\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u306e\u30ea\u30b9\u30c8\n        return [uf.size(x) for x in uf.roots()]\n\n    def all_group_members(self): # O(\u9802\u70b9\u6570 * x\u306e\u9023\u7d50\u6210\u5206\u30b5\u30a4\u30ba)? \u30b0\u30eb\u30fc\u30d7\u305f\u3061(\u30ea\u30b9\u30c8)\u306e\u30ea\u30b9\u30c8\n        group = {r:[] for r in self.roots()}\n        for i in range(self.n):\n            group[self.find(i)].append(i)\n        return list(group.values())\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN,M = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\nCD = [[int(i) for i in input().split()] for j in range(M)]\n\nuf = UnionFind(N)\nfor c,d in CD:\n    uf.union(c-1, d-1)\n\ngr = uf.all_group_members()\n\nfor g in gr:\n    asum = sum([A[i] for i in g])\n    bsum = sum([B[i] for i in g])\n    if asum != bsum:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n", "from collections import deque\nn,m = map(int,input().split())\na = tuple(map(int,input().split()))\nb = tuple(map(int,input().split()))\ng = [[] for _ in range(n)]\nfor _ in range(m):\n  i,j = map(lambda x:int(x)-1,input().split())\n  g[i].append(j)\n  g[j].append(i)\nc = [False]*n\nans = \"Yes\"\nfor i in range(n):\n  if c[i]:\n    continue\n  c[i] = True\n  da = a[i]\n  db = b[i]\n  q = deque(g[i])\n  while(q):\n    j = q.popleft()\n    if c[j]:\n      continue\n    c[j] = True\n    da += a[j]\n    db += b[j]\n    for k in g[j]:\n      q.append(k)\n  if da != db:\n    ans = \"No\"\n    break\nprint(ans)", "def N():\n    return int(input())\ndef L():\n    return list(map(int,input().split()))\ndef NL(n):\n    return [list(map(int,input().split())) for i in range(n)]\nmod = pow(10,9)+7\n#import numpy as np\nimport sys\nsys.setrecursionlimit(2147483647)\nimport math\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom collections import Counter\nfrom collections import deque\nfrom collections import defaultdict\nimport bisect\nimport heapq\ninf = float('inf')\ndic = defaultdict(lambda:0)\n\nclass UnionFind():\n    par = []\n    rank = []\n    def __init__(self,n):\n        for i in range(n):\n            self.par.append(i)\n            self.rank.append(0)\n    def root(self,x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.root(self.par[x])\n            return self.par[x]\n \n    def same(self,x,y):\n        if self.root(x) == self.root(y):\n            return True\n        else:\n            return False\n \n    def unite(self,x,y):\n        x = self.root(x)\n        y = self.root(y)\n        if x==y:\n            return\n        if self.rank[x] > self.rank[y]:\n            self.par[y] = x\n        else:\n            self.par[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def comp(self):#root\u307e\u3067\u306e\u8ddd\u96e2\u5727\u7e2e\n        for i in range(len(self.par)):\n            self.root(i)\n\nn,m = L()\na = L()\nb = L()\ncd = NL(m)\nuf = UnionFind(n)\nfor c,d in cd:\n    uf.unite(c-1,d-1)\nuf.comp()\n\nva = defaultdict(int)\nvb = defaultdict(int)\n\nfor i in range(n):\n    va[uf.par[i]] += a[i]\n    vb[uf.par[i]] += b[i]\n\nfor i in range(n):\n    if va[i] != vb[i]:\n        print('No')\n        break\nelse:\n    print('Yes')", "class UnionFind():\n    def __init__(self, n):\n        self.n = n + 1\n        self.parents = [-1] * self.n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n        # TODO \u6839\u3092\u8fd4\u3059\n        return x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nfrom collections import defaultdict\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    A.append(0)\n    B.append(0)\n    uf = UnionFind(N+1)\n    for _ in range(M):\n        c, d = list(map(int,input().split()))\n        uf.union(c, d)\n    A_sums = defaultdict(int)\n    B_sums = defaultdict(int)\n    for i in range(1, N+1):\n        x = uf.find(i)\n        A_sums[x] += A[i-1]\n        B_sums[x] += B[i-1]\n    for a, b in zip(list(A_sums.values()), list(B_sums.values())):\n        if a != b:\n            print('No')\n            return\n    print('Yes')\n\n\nmain()\n", "# UnionFind \u53c2\u8003\u306f\u4ee5\u4e0b\u306e\u30b5\u30a4\u30c8\n# https://note.nkmk.me/python-union-find/\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n\nN,M = map(int, input().split())\nA = list(map(int, input().split())) \nB = list(map(int, input().split())) \nC = [0]*N\nfor i in range(N):\n    C[i]=A[i]-B[i]\nuf = UnionFind(N)\nfor i in range(M):\n    A,B = map(int, input().split())\n    uf.union(A-1,B-1)\nM = uf.all_group_members()\nans = True\nfor v in M.values():\n    su = 0\n    for c in v:\n        su += C[c]\n\n    ans = ans and su==0\n\n\nif ans:\n    print('Yes')\nelse:\n    print('No')", "n, m = map(int, input().rstrip().split(\" \"))\n\nA = list(map(int, input().rstrip().split(\" \")))\nB = list(map(int, input().rstrip().split(\" \")))\n\nM = []\nfor i in range(m):\n    a, b = map(int, input().rstrip().split(\" \"))\n    M.append((a-1, b-1))\n\nclass UnionFind:\n    \n    Par = []\n    Total = []\n    \n    \n    def __init__(self, n_):\n        for i in range(n_):\n            self.Par.append(i)\n            self.Total.append(0)\n    \n    def root(self, x):\n        if(self.Par[x] == x):\n            ret = x\n        else:\n            ret = self.root(self.Par[x])\n        return ret\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if(x > y):\n            self.Par[x] = y\n        elif(x < y):\n            self.Par[y] = x\n    def same(x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if(x==y):\n            ret = True\n        else:\n            ret = False\n        return ret\n    def printf(self):\n        print(self.Par)\n        print(self.Total)\n        \n        \nunion = UnionFind(n)\nfor i in M:\n    c, d = i\n    union.unite(c, d)\n\nDif = []\nfor i in range(n):\n    dif = B[i] - A[i]\n    Dif.append(dif)\n\nZero = [0 for i in range(n)]\nfor i in range(n):\n    root = union.root(i)\n    Zero[root] += Dif[i]\n\nisOK = True\nfor zero in Zero:\n    if(zero != 0):\n        isOK = False\n\n\nif(isOK == True):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n    \nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nuf=UnionFind(n)\nfor i in range(m):\n    x,y=map(int,input().split())\n    uf.union(x-1,y-1)\n    \nfor i in (uf.all_group_members().values()):\n    c=0\n    d=0\n    for j in i:\n        c+=a[j]\n        d+=b[j]\n    if c!=d:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def size(self, x):\n        return abs(self.parents[self.find(x)])\n\n    def groups(self):\n        roots = self.roots()\n        r_to_g = {}\n        for i, r in enumerate(roots):\n            r_to_g[r] = i\n        groups = [[] for _ in roots]\n        for i in range(self.n):\n            groups[r_to_g[self.find(i)]].append(i)\n        return groups\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nuf = UnionFind(n)\nfor _ in range(m):\n    c, d = list(map(int, input().split()))\n    c -= 1\n    d -= 1\n    uf.union(c,d)\n\nsa = [0]*(n+1)\nsb = [0]*(n+1)\n\nfor i in range(n):\n    par = uf.find(i)\n    sa[par] += a[i]\n    sb[par] += b[i]\n\nfor aa,bb in zip(sa,sb):\n    if aa != bb:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n\n", "from collections import defaultdict\n\ndef Yes_No(flag):\n    if flag:    print(\"Yes\")\n    else:       print(\"No\")\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\nn, m = list(map(int,input().split()))\n\naa = list(map(int,input().split()))\nbb = list(map(int,input().split()))\n\ncds = [list(map(int,input().split())) for _ in range(m)]\n\nuf = UnionFind(n)\nfor i in range(m):\n    x, y = cds[i]\n    uf.union(x-1,y-1)\n\nans = True\n\nfor key, val in uf.all_group_members().items():\n    if sum(aa[i] for i in val) != sum(bb[i] for i in val):\n        ans = False\n\nYes_No(ans)", "import collections\nN,M = map(int,input().split())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nl = [list(map(int, input().split())) for l in range(M)]\n\npar = [i for i in range(N)]\n\n#\u30b0\u30eb\u30fc\u30d7\u5206\u3051\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n\n#print(par)\nfor i in l:\n  unite(i[0]-1,i[1]-1)\n#  print(par)\n\nfor i in range(N):\n  find(i)\n\n#print(par)\n      \n#\u4f55\u7a2e\u985e\u3042\u308b\u304b\nc = collections.Counter(par)\n#print(c)\nsumcheck = [[0]*N,[0]*N]\n\n#\u3059\u3079\u3066\u3067\u30b7\u30b0\u30de\nfor i in range(N):\n  sumcheck[0][par[i]] += a[i]\n  sumcheck[1][par[i]] += b[i]\n  \nif sumcheck[0] == sumcheck[1]:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "def root(x):\n    if r[x] < 0:\n        return x\n    else:\n        r[x] = root(r[x])\n        return r[x]\n \ndef unite(x, y):\n    x = root(x)\n    y = root(y)\n    if x != y:\n        if r[x] > r[y]:\n            x,y = y,x\n        r[x] += r[y]\n        r[y] = x\n\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nr = [-1] * n\nfor i in range(m):\n    c,d = map(int,input().split())\n    c -= 1\n    d -= 1\n    unite(c,d)\np = [0] * n\nq = [0] * n\nfor i in range(n):\n    if r[i] < 0:\n        x = i\n    else:\n        x = root(i)\n    p[x] += a[i]\n    q[x] += b[i]\nfor i in range(n):\n    if p[i] != q[i]:\n        print('No')\n        return\nprint('Yes')    ", "from collections import defaultdict\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n\n    def find(self, i):\n        while self.parent[i] != i:\n            i = self.parent[i]\n        return i\n\n    def unite(self, i, j):\n        i, j = self.find(i), self.find(j)\n        if i > j:\n            i, j = j, i\n        self.parent[j] = i\n\n\nn, m = list(map(int, input().split()))\n(*a,) = list(map(int, input().split()))\n(*b,) = list(map(int, input().split()))\nuf = UnionFind(n)\nfor _ in range(m):\n    x, y = list(map(int, input().split()))\n    uf.unite(x - 1, y - 1)\nsa, sb = defaultdict(int), defaultdict(int)\nfor i in range(n):\n    sa[uf.find(i)] += a[i]\n    sb[uf.find(i)] += b[i]\nif all(sa[i] == sb[i] for i in sa):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "import sys\nsys.setrecursionlimit(10**9)\nread = lambda:sys.stdin.readline()\nfrom collections import deque\n\ndef read_ints():\n    return list(map(int,read().split()))\ndef read_intgrid(h):\n    return list(list(map(int,read().split()))for i in range(h))\n\ndef main():\n    #input data\n    n,m = read_ints()\n    A = read_ints()\n    B = read_ints()\n    G = [[] for _ in range(n)]\n    for i in range(m):\n        c,d = map(int,input().split())\n        c,d = c-1,d-1\n        G[c].append(d)\n        G[d].append(c)\n    \n    #solve\n    ans = 1\n    vis = [0]*n\n    def bfs(v):\n        queue = deque([v])\n        vis[v]=1\n        tmp1 = A[v]\n        tmp2 = B[v]\n        while queue:\n            x = queue.popleft()\n            for y in G[x]:\n                if vis[y]:\n                    continue\n                tmp1+=A[y]\n                tmp2+=B[y]\n                vis[y]=1\n                queue.append(y)\n        # print(v,tmp1,tmp2)\n        if tmp1==tmp2:\n            return True\n        else:\n            return False\n\n    for i in range(n):\n        if vis[i]:continue\n        if not bfs(i):\n            ans = 0\n            break  \n\n    return print('Yes' if ans else 'No')\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(1000000000)\nn,m = map(int,input().split())\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\nG = [[] for _ in range(n)]\nfor _ in range(m):\n    c,d = map(int,input().split())\n    c -= 1\n    d -= 1\n    G[c].append(d)\n    G[d].append(c)\nseen = [False]*n\n\ndef dfs(now):\n    seen[now] = True\n    sa = A[now]\n    sb = B[now]\n    for nxt in G[now]:\n        if seen[nxt]: continue\n        seen[nxt] = True\n        a,b = dfs(nxt)\n        sa += a\n        sb += b\n    return (sa,sb)\nfor i in range(n):\n    if seen[i]: continue\n    sa,sb = dfs(i)\n    if sa != sb:\n        print(\"No\")\n        return\nprint(\"Yes\")", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nedges = [[] for _ in range(N)]\nfor _ in range(M):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    edges[c].append(d)\n    edges[d].append(c)\n\nq = deque()\nvisited = set()\nfor i in range(N):\n    if i in visited:\n        continue\n\n    q.append(i)\n    a_sum = 0\n    b_sum = 0\n    while q:\n        n = q.popleft()\n        if n in visited:\n            continue\n        visited.add(n)\n\n        a_sum += A[n] \n        b_sum += B[n] \n        for nn in edges[n]:\n            q.append(nn)\n\n    if a_sum != b_sum:\n        print(\"No\")\n        return\n\nprint(\"Yes\")", "from collections import deque\n\nn, m = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nG = [[] for _ in range(n)]\nfor _ in range(m):\n    c, d = map(lambda x:int(x)-1, input().split())\n    G[c].append(d)\n    G[d].append(c)\n\nseen = [False]*n\nque = deque()\n\nfor i in range(n):\n    if not seen[i]:\n        que.append(i)\n        a, b = 0, 0\n\n        while que:\n            v = que.pop()\n            a += A[v]\n            b += B[v]\n            seen[v] = True\n            for nv in G[v]:\n                if not seen[nv]:\n                    que.append(nv)\n                    seen[nv] = True\n        if a != b:\n            print(\"No\")\n            return\nprint(\"Yes\")", "#n = int(input())\n#a = list(map(int, input().split()))\n\nfrom typing import List\n\n\nclass DSU:\n    def __init__(self, n: int) -> None:\n        self._n = n\n        self.parent_or_size = [-1] * n\n\n    def merge(self, a: int, b: int) -> int:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        x, y = self.leader(a), self.leader(b)\n        if x == y:\n            return x\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\n            x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n\n    def same(self, a: int, b: int) -> bool:\n        assert 0 <= a < self._n\n        assert 0 <= b < self._n\n        return self.leader(a) == self.leader(b)\n\n    def leader(self, a: int) -> int:\n        assert 0 <= a < self._n\n        stack = []\n        while self.parent_or_size[a] >= 0:\n            stack.append(a)\n            a = self.parent_or_size[a]\n        for i in stack:\n            self.parent_or_size[i] = a\n        return a\n\n    def size(self, a: int) -> int:\n        assert 0 <= a < self._n\n        return -self.parent_or_size[self.leader(a)]\n\n    def groups(self) -> List[List[int]]:\n        leader_buf = [self.leader(i) for i in range(self._n)]\n        group_size = [0] * self._n\n        for i in leader_buf:\n            group_size[i] += 1\n        result = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            result[leader_buf[i]].append(i)\n        result = [i for i in result if i]\n        return result\n\nn,m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nuf = DSU(n)\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    uf.merge(x-1,y-1)\n\nfor u in uf.groups():\n    diff = 0\n    for aa in u:\n        diff += a[aa] - b[aa]\n    if diff != 0:\n        print('No')\n        return\nprint('Yes')\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int,input().split()))\n    B = list(map(int,input().split()))\n    if sum(A) != sum(B):\n        print(\"No\")\n    else:\n        f = 0\n        uf = UnionFind(N)\n        for _ in range(M):\n            C,D = list(map(int,input().split()))\n            C -= 1\n            D -= 1\n            uf.union(C,D)\n        wa = [0 for i in range(N)]\n        tle = [0 for i in range(N)]\n        for i in range(N):\n            wa[uf.find(i)] += A[i]\n            tle[uf.find(i)] += B[i]\n        if wa == tle:\n            print(\"Yes\")\n        else:\n            print(\"No\")\nmain()\n", "class UnionFind:\n    def __init__(self, n):\n        # \u8ca0  : \u6839\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u7d76\u5bfe\u5024\u306f\u30e9\u30f3\u30af\u3092\u793a\u3059\n        # \u975e\u8ca0: \u6839\u3067\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\u5024\u306f\u89aa\u3092\u793a\u3059\n        self.table = [-1] * n\n \n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n \n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n \n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        # \u30e9\u30f3\u30af\u306e\u53d6\u5f97\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n\n\nn,m = list(map(int, input().split()))\n\nA=list(map(int, input().split()))\nB=list(map(int, input().split()))\n\nG = UnionFind(n)\n\nCD=[]\n\nfor _ in range(m):\n\n    c,d = list(map(int, input().split()))\n    G.union(c-1,d-1)\n\nansA=[0]*n\nansB=[0]*n\n\nfor i in range(n):\n    \n    ansA[G._root(i)] += A[i] \n    \n    ansB[G._root(i)] += B[i] \n \nif ansA == ansB:\n    print(\"Yes\")\n    \nelse:\n    print(\"No\")\n", "from collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.root = [i for i in range(n + 1)]\n        self.size = [1] * (n + 1)\n    def find(self, x):\n        y = self.root[x]\n        if x == y:\n            return x\n        else:\n            z = self.find(y)\n            self.root[x] = z\n            return z\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        sx = self.size[rx]\n        sy = self.size[ry]\n        if rx == ry:\n            return 0\n        else:\n            if sx >= sy:\n                self.root[ry] = rx\n                self.size[rx] = sx + sy\n            else:\n                self.root[rx] = ry\n                self.size[ry] = sx + sy\n        return sx * sy\n    def check(self):\n        print([self.find(i) for i in range(1, len(self.root))])\n\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nCD = [list(map(int, input().split())) for _ in range(M)]\n\nuf = UnionFind(N)\nfor c, d in CD:\n    uf.union(c, d)\n    \ncnta = defaultdict(int)\ncntb = defaultdict(int)\n\nlst = []\nfor i in range(1, N + 1):\n    cnta[uf.find(i)] += A[i - 1]\n    cntb[uf.find(i)] += B[i - 1]\n    lst.append(uf.find(i))\n    \nfor l in lst:\n    if cnta[l] != cntb[l]:\n        print(\"No\")\n        return\nprint(\"Yes\")", "import numpy as np\nfrom collections import defaultdict\n\nclass UnionFind(object):\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * n\n\n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.root[x] > self.root[y]:\n            x, y = y, x\n        self.root[x] += self.root[y]\n        self.root[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self.root[self.find(x)] * -1\n    \n    def get_all_groups(self):\n        all_groups = defaultdict(list)\n        for i in range(self.n):\n            all_groups[self.find(i)].append(i)\n        return dict(all_groups)\n\n\nn, m = map(int, input().split())\na = np.array(list(map(int, input().split())))\nb = np.array(list(map(int, input().split())))\n\nuf = UnionFind(n)\nfor _ in range(m):\n    c, d = map(int, input().split())\n    uf.unite(c - 1, d - 1)\n\nfor i in uf.get_all_groups().values():\n    if a[i].sum() != b[i].sum():\n        print('No')\n        return\n\nprint('Yes')", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n \n    def members(self, x): # \u9045\u3044\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n \n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n \n    def group_count(self):\n        return len(self.roots())\n \n    def all_group_members(self): # \u9045\u3044\n        return {r: self.members(r) for r in self.roots()}\n \n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n \nn,m=map(int,input().split())\n \nuf = UnionFind(n)\n \na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nfor i in range(m):\n    c,d=map(int,input().split())\n    c-=1\n    d-=1\n    uf.union(c,d)\nweights_a = [0] * n\nweights_b = [0] * n\nfor i in range(n):\n    weights_a[uf.find(i)] += a[i]\n    weights_b[uf.find(i)] += b[i]\nfor i in range(n):\n    if weights_a[i] != weights_b[i]:\n        print('No')\n        return\nprint('Yes')", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n \n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n\n\nn,m = list(map(int,input().split()))\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nu = UnionFind(n)\nfor i in range(m):\n    c,d = list(map(int,input().split()))\n    c -= 1\n    d -= 1\n    u.union(c,d)\n\na_pa = [0 for i in range(n)]\nb_pa = [0 for i in range(n)]\nfor i in range(n):\n    a_pa[u.find(i)] += a[i]\n    b_pa[u.find(i)] += b[i]\n\n\nif a_pa == b_pa:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n        # return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor _ in range(M):\n    a, b = map(int, input().split())\n    uf.union(a-1, b-1)\n\nmembers = uf.all_group_members().values()\nfor r in members:\n    sm = 0\n    sm_ = 0\n    for m in r:\n        sm += A[m]\n        sm_ += B[m]\n    if sm!= sm_:\n        print(\"No\")\n        return\n\nprint(\"Yes\")", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nuf = UnionFind(N)\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    uf.union(c-1, d-1)\n\nagm = uf.all_group_members()\n\nfor gm in list(agm.values()):\n    a = 0\n    b = 0\n    for m in gm:\n        a += A[m]\n        b += B[m]\n    if a != b:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n\n\n\n\n\n\n\n\n", "def init(n):\n  nonlocal par\n  nonlocal size\n  \n  # \u5404\u9802\u70b9\u306e\u89aa\u306e\u756a\u53f7(\u81ea\u8eab\u304c\u6839\u306e\u5834\u5408\u306f -1)\n  # \u6700\u521d\u306f\u3001\u3069\u306e\u9802\u70b9\u3082\u6839\u3067\u3042\u308b\u3068\u3057\u3066\u521d\u671f\u5316\n  par = [-1] * n\n\n  # \u5404\u9802\u70b9\u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u6570(\u9ad8\u3055)\n  size = [1] * n\n  \n\ndef unite(x, y):\n  # [summary]x\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3068 y\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3059\u308b\n\n  # 0\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306b\u5909\u66f4\n  x -= 1\n  y -= 1\n\n  # x,y\u3092 \u305d\u308c\u305e\u308c\u6839\u307e\u3067\u79fb\u52d5\u3059\u308b\n  x = get_root(x)\n  y = get_root(y)\n\n  # \u3059\u3067\u306b\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u3068\u304d\u306f \u4f55\u3082\u3057\u306a\u3044\n  if x != y:\n    # union by size(y\u5074\u306e\u30b5\u30a4\u30ba\u304c\u5c0f\u3055\u304f\u306a\u308b\u3088\u3046\u306b\u3059\u308b)\n    if size[x] < size[y]:\n      x, y = y, x\n\n    # y\u3092x\u306e\u5b50\u306b\u3059\u308b\n    par[y] = x\n    size[x] += size[y]\n\n\ndef get_root(x):\n  # [summary]\u6839\u3092\u6c42\u3081\u308b\n  # \u305d\u306e\u904e\u7a0b\u3067\u3001\u7d4c\u8def\u5727\u7e2e\u3092\u884c\u3046(par[x]\u306b\u306f\u3001\u6839\u304c\u683c\u7d0d\u3055\u308c\u308b)\n\n  if par[x] == -1:\n    # x\u304c\u6839\u306e\u5834\u5408\u306f\u3001\u76f4\u63a5x\u3092\u8fd4\u3059\n    return x\n  else:\n    # x\u306e\u89aapar[x]\u3092\u6839\u306b\u5f35\u308a\u66ff\u3048\u308b\n    # (\u3053\u3053\u3067\u4ee3\u5165\u3057\u3066\u304a\u304f\u3053\u3068\u3067\u3001\u5f8c\u306e\u7e70\u308a\u8fd4\u3057\u3092\u907f\u3051\u3089\u308c\u308b)\n    # \u5404\u9802\u70b9\u306e\u89aa\u5b50\u95a2\u4fc2\u3092\u77e5\u308a\u305f\u3044\u5834\u5408\u306f\u3001\u3053\u306e\u884c\u3092\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n    par[x] = get_root(par[x])\n    \n    return get_root(par[x])\n\n\ndef is_same(x, y):\n  # [summary]x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\n  if get_root(x) == get_root(y):\n    return True\n\n\ndef get_size(x):\n  # [summary]x\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u6570(\u9ad8\u3055)\n\n  return size[get_root(x)]\n\n\n# B - Values\nN, M = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npar = []\nsize = []\n\ninit(N)\n\nfor _ in range(M):\n  c, d = map(int, input().split())\n\n  # \u5404\u9802\u70b9\u306e\u89aa\u5b50\u95a2\u4fc2\u3092\u8a18\u9332\n  unite(c, d)\n\ngroups = dict()\n\n# \u547c\u3073\u51fa\u3057\u5143\u306e\u51e6\u7406\nfor i in range(N):\n  r = get_root(i)\n  \n  if not r in groups.keys():\n    groups[r] = [i]\n  else:\n    groups[r].append(i)\n\nfor vertexes in groups.values():\n  a_sum = 0\n  b_sum = 0\n\n  for v in vertexes:\n    a_sum += a[v]\n    b_sum += b[v]\n\n  if a_sum != b_sum:\n    print('No')\n    return\n\nprint('Yes')", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\ndef main():\n    N, M = list(map(int, input().split()))\n    A = list(map(int,input().split()))\n    B = list(map(int,input().split()))\n    if sum(A) != sum(B):\n        print(\"No\")\n    else:\n        f = 0\n        uf = UnionFind(N)\n        for _ in range(M):\n            C,D = list(map(int,input().split()))\n            C -= 1\n            D -= 1\n            uf.union(C,D)\n        wa = [0 for i in range(N)]\n        tle = [0 for i in range(N)]\n        for i in range(N):\n            wa[uf.find(i)] += A[i]\n            tle[uf.find(i)] += B[i]\n        if wa == tle:\n            print(\"Yes\")\n        else:\n            print(\"No\")\nmain()\n", "class UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [i for i in range(n)]  # \u89aa\n        self.rank = [1] * n  # \u6728\u306e\u9ad8\u3055\n        self.size = [1] * n  # size[i] \u306f i \u3092\u6839\u3068\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n\n    def find(self, x):  # x \u306e\u6839\u3092\u8fd4\u3059\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])  # \u7d4c\u8def\u5727\u7e2e\n            return self.parent[x]\n\n    def unite(self, x, y):  # x, y \u306e\u5c5e\u3059\u308b\u96c6\u5408\u3092\u4f75\u5408\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                self.parent[x] = y\n                self.size[y] += self.size[x]\n            else:\n                self.parent[y] = x\n                self.size[x] += self.size[y]\n                if self.rank[x] == self.rank[y]:\n                    self.rank[x] += 1\n\n    def group_members(self, x):  # x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u3092\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):  # \u3059\u3079\u3066\u306e\u6839\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parent) if i == x]\n\n    def all_group_members(self):  # \u3059\u3079\u3066\u306e\u6728\u306e\u8981\u7d20\u3092\u8f9e\u66f8\u3067\u8fd4\u3059\n        return {r: self.group_members(r) for r in self.roots()}\n\n    def __str__(self):  # print \u8868\u793a\u7528\n        return '\\n'.join('{}: {}'.format(r, self.group_members(r)) for r in self.roots())\n\n\nn, m = list(map(int, input().split()))\nuf = UnionFind(n)\nal = list(map(int, input().split()))\nbl = list(map(int, input().split()))\n\nfor _ in range(m):\n    c, d = [int(x)-1 for x in input().split()]\n    uf.unite(c, d)\n\nasum = [0]*n\nbsum = [0]*n\n\nfor i in range(n):\n    root = uf.find(i)\n    asum[root] += al[i]\n    bsum[root] += bl[i]\n\nif asum == bsum: print('Yes')\nelse: print('No')\n", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\npar = [i for i in range(n+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    \nfor i in range(m):\n  s,t = map(int,input().split())\n  unite(s,t)\n\nfor i in range(n+1):\n  par[i] = find(i)\n\ndata = [0 for _ in range(n+1)]\nfor i in range(1,n+1):\n  data[par[i]] += a[i-1]\n  data[par[i]] -= b[i-1]\n\n\nif data.count(0) == n+1:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\nN,M = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ncd = [list(map(int,input().split())) for i in range(M)]\nuf = UnionFind(N)\nfor i in range(M):\n    uf.union(cd[i][0]-1,cd[i][1]-1)\nfor v in list(uf.all_group_members().values()):\n    sa,sb = 0,0\n    for i in v:\n        sa += a[i]\n        sb += b[i]\n    if sa != sb:\n        print(\"No\")\n        return\nprint(\"Yes\")", "I = [int(_) for _ in open(0).read().split()]\nN, M = I[:2]\nA = I[2:2 + N]\nB = I[2 + N:2 + N + N]\nCD = I[2 + N + N:]\nC, D = [CD[_::len('CD')] for _ in range(len('CD'))]\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * (n + 1)\n        self.rank = [0] * (n + 1)\n\n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return 0\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root[self.find(x)]\n\n\nuf = UnionFind(N)\nfor c, d in zip(C, D):\n    uf.unite(c, d)\nsums = [0] * (N + 1)\nfor i in range(1, N + 1):\n    sums[uf.find(i)] += B[i - 1] - A[i - 1]\nprint(('Yes' if all(x == 0 for x in sums) else 'No'))\n", "# -*- coding: utf-8 -*-\nimport math\nimport collections\nimport bisect\nimport itertools\nimport heapq\nimport os\nfrom collections import defaultdict, deque, Counter\nfrom sys import stdin\nreadline = stdin.readline\n\"\"\"\n# sys.setrecursionlimit(10 ** 9)\n\nN = int(readline())\nN, K = map(int, readline().split())\nA = list(map(int, readline().split()))\nL = [list(map(int, readline().split())) for _ in [0]*N]\nS = readline().rstrip(os.linesep)\n\nfor _ in [0]*N:\n  x, y, z = map(int, readline().split())\n\"\"\"\nN, M = list(map(int, readline().split()))\na = list(map(int, readline().split()))\nb = list(map(int, readline().split()))\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\nuf = UnionFind(N)\nfor _ in [0]*M:\n    c, d = list(map(int, readline().split()))\n    uf.union(c-1, d-1)\n\nfor grp in list(uf.all_group_members().values()):\n    a_values = [a[x] for x in grp]\n    b_values = [b[x] for x in grp]\n    a_total = sum(a_values)\n    b_total = sum(b_values)\n    if a_total != b_total:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9+7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = list(range(n))\n        self.rank = [0] * n\n\n    def root(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            r = self.root(self.par[x])\n            self.par[x] = r\n            return r\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.rank[x] < self.rank[y]:\n            x, y = y, x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.par[y] = x\n        return True\n\ndef resolve():\n    N, M = LI()\n    a = LI()\n    b = LI()\n    # \u9023\u7d50\u6210\u5206\u306e\u5408\u8a08\u304c\u7b49\u3057\u3051\u308c\u3070\u5b9f\u73fe\u53ef\u80fd\n    uf = UnionFind(N)\n    for _ in range(M):\n        c, d = LI_()\n        uf.merge(c, d)\n\n    r = collections.defaultdict(list)\n    for i in range(N):\n        p = uf.root(i)\n        r[p].append(i)\n    # print(r)\n    if [sum([a[j] for j in l]) == sum([b[j] for j in l]) for l in list(r.values())].count(False) == 0:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# https://note.nkmk.me/python-union-find/\nclass UnionFind():\n    def __init__(self, n): # O(n == \u9802\u70b9\u306e\u500b\u6570)\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) \u6839\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u8fd4\u3059 \u306a\u3089\u3057\u8a08\u7b97\u91cfO(\u03b1(\u9802\u70b9\u6570))\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x]) # \u7d4c\u8def\u5727\u7e2e\n            return self.parents[x]\n\n    def union(self, x, y): # O(x\u304by\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) x\u3068y\u3092\u9023\u7d50\u3059\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        return x\n\n    def size(self, x): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba) x\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y): # O(x\u306e\u30b0\u30eb\u30fc\u30d7\u30b5\u30a4\u30ba) x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b(True)\u304b\u3069\u3046\u304b\n        return self.find(x) == self.find(y)\n\n    def members(self, x): # O(\u9802\u70b9\u6570) x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u9802\u70b9\u305f\u3061\u306e\u30ea\u30b9\u30c8 \u3059\u3079\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u3092\u4f7f\u3044\u305f\u3044\u306a\u3089all_group_members\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self): # O(\u9802\u70b9\u6570) \u89aa\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u305f\u3061\u306e\u30ea\u30b9\u30c8\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self): # O(\u9802\u70b9\u6570) \u30b0\u30eb\u30fc\u30d7\u306e\u500b\u6570\n        return len(self.roots())\n\n    def group_sizes(self): # O(\u9802\u70b9\u6570) \u3059\u3079\u3066\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u306e\u30ea\u30b9\u30c8\n        return [uf.size(x) for x in uf.roots()]\n\n    def all_group_members(self): # O(\u9802\u70b9\u6570 * x\u306e\u9023\u7d50\u6210\u5206\u30b5\u30a4\u30ba)? \u30b0\u30eb\u30fc\u30d7\u305f\u3061(\u30ea\u30b9\u30c8)\u306e\u30ea\u30b9\u30c8\n        group = {r:[] for r in self.roots()}\n        for i in range(self.n):\n            group[self.find(i)].append(i)\n        return list(group.values())\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN,M = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\nCD = [[int(i) for i in input().split()] for j in range(M)]\n\nuf = UnionFind(N)\nfor c,d in CD:\n    uf.union(c-1, d-1)\n\ngr = uf.all_group_members()\n\nfor g in gr:\n    asum = sum([A[i] for i in g])\n    bsum = sum([B[i] for i in g])\n    if asum != bsum:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n    \nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nuf=UnionFind(n)\nfor i in range(m):\n    x,y=map(int,input().split())\n    uf.union(x-1,y-1)\n    \nfor i in (uf.all_group_members().values()):\n    c=0\n    d=0\n    for j in i:\n        c+=a[j]\n        d+=b[j]\n    if c!=d:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")", "import sys\ntry:\n    import os\n    f = open('input.txt', 'r')\n    sys.stdin = f\nexcept FileNotFoundError:\n    None\nfrom math import sqrt, ceil, floor\nfrom collections import deque, Counter, defaultdict\n# defaultdict(int)\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright, insort\nfrom itertools import combinations as com, permutations as per\nfrom fractions import Fraction as frac  #frac(a,b)\u3067\u6b63\u78ba\u306aa/b\n# @lru_cache(maxsize=10**10)\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nclass UnionFind():\n    def __init__(self,num):\n        self.n = num\n        self.parents = [{i} for i in range(self.n)]\n\n    def find(self,x):\n        if type(self.parents[x])== set:\n            return x\n        else:\n            self.parents[x]=self.find(self.parents[x])\n            return self.parents[x]\n\n\n    def union(self,x,y):\n        xx=self.find(x)\n        yy=self.find(y)\n        if xx==yy:\n            return\n        else:\n            size_xx=len(self.parents[xx])\n            size_yy=len(self.parents[yy])\n            if size_xx>size_yy:\n                xx,yy=yy,xx\n\n            # self.parents[yy]+=self.parents[xx]\n            for t in self.parents[xx]:\n                self.parents[yy].add( t )\n            self.parents[xx]=yy\n\n\n    def size(self,x):\n        xx=self.find(x)\n        return abs(self.parents[xx])\n\n\n    def same(self,x,y):\n        return 1 if self.find(x)==self.find(y) else 0\n\n\n    def members(self,x):\n        xx=self.find(x)\n        return [i for i in range(self.n) if self.find(i)==xx]\n\n\n\n    def roots(self):\n        return [i for i,x in enumerate(self.parents) if x < 0]\n\n\n\n    def all_group_members(self):\n        return {r:self.members(r) for r in self.roots()}\n\n    def state_grouping(self):\n        return list(self.all_group_members().values())\n\nuf=UnionFind(n)\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    a-=1;b-=1\n    uf.union(a,b)\n\n# X= uf.state_grouping()\nX=[]\nfor l in uf.parents:\n    if type(l)==set:\n        X.append(l)\n\nfor l in X:\n    ans=0; ann=0\n    for i in l:\n        ans+= A[i]\n        ann+= B[i]\n    if ans!=ann:\n        print(\"No\");return\nelse:\n    print(\"Yes\")\n", "# Values\n\n# \u5404\u9023\u7d50\u6210\u5206\u306b\u304a\u3044\u3066a_i\u306e\u7dcf\u548c\u3068b_i\u306e\u7dcf\u548c\u304c\u7b49\u3057\u3051\u308c\u3070\u3088\u3044\n\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\na = tuple(map(int, input().split()))\nb = tuple(map(int, input().split()))\ngraph = [[] for i in range(N)]\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    graph[c - 1].append(d - 1)\n    graph[d - 1].append(c - 1)\ngraph = tuple(tuple(l) for l in graph)\n\nunreached = set(range(N))\nqueue = deque()\njudge = \"Yes\"\nwhile len(unreached) > 0:\n    node = unreached.pop()\n    queue.append(node)\n    sum_a = a[node]\n    sum_b = b[node]\n\n    # \u9802\u70b9\u3092\u5e45\u512a\u5148\u63a2\u7d22\n    while len(queue) > 0:\n        for node in graph[queue.pop()]:\n            if node in unreached:\n                unreached.remove(node)\n                queue.append(node)\n                sum_a += a[node]\n                sum_b += b[node]\n    \n    if sum_a != sum_b:\n        judge = \"No\"\n        break\n\nprint(judge)\n", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parents = [-1] * n\n\n  def find(self, x):\n    if self.parents[x] < 0:\n      return x\n    else:\n      self.parents[x] = self.find(self.parents[x])\n    return self.parents[x]\n\n  def union(self, x, y):\n    x = self.find(x)\n    y = self.find(y)\n\n    if x == y:\n      return\n\n    if self.parents[x] > self.parents[y]:\n      x, y = y, x\n\n    self.parents[x] += self.parents[y]\n    self.parents[y] = x\n\n  def same(self, x, y):\n    return self.find(x) == self.find(y)\n\n  def roots(self):\n    return [i for i, x in enumerate(self.parents) if x < 0]\n\n  def members(self, x):\n    root = self.find(x)\n    return [i for i in range(self.n) if self.find(i) == root]\n\n  def num_members(self,x):\n    return abs(self.parents[self.find(x)])\n  \n  def groups(self):\n    roots = self.roots()\n    r_to_i = {}\n    for i, r in enumerate(roots):\n      r_to_i[r] = i\n    groups = [[] for _ in roots]\n    for i in range(self.n):\n      groups[r_to_i[self.find(i)]].append(i)\n    return groups\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nuf = UnionFind(N)\nfor i in range(M):\n  c, d = map(int, input().split())\n  uf.union(c-1,d-1)\nfor g in uf.groups():\n  cnt = 0\n  for v in g:\n    cnt += A[v]-B[v]\n  if cnt!=0:\n    print('No')\n    return\nprint('Yes')", "N,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nCD=[list(map(int,input().split())) for i in range(M)]\nclass UnionFind:\n    def __init__(self,N):\n        self.Parent=[-1]*N\n    def unite(self,m,n):\n        rm=self.root(m)\n        rn=self.root(n)\n        if rm==rn:\n            return False\n        else:\n            if self.size(rm)<self.size(rn):\n                rm,rn=rn,rm\n            self.Parent[rm]+=self.Parent[rn]\n            self.Parent[rn]=rm\n            return True\n    def root(self,n):\n        if self.Parent[n]<0:\n            return n\n        else:\n            self.Parent[n]=self.root(self.Parent[n])\n            return self.Parent[n]\n    def size(self,n):\n        return -self.Parent[self.root(n)]\nu=UnionFind(N)\nfor c,d in CD:\n    u.unite(c-1,d-1)\nfrom collections import defaultdict\nd=defaultdict(int)\nd2=defaultdict(int)\nfor i in range(N):\n    d[u.root(i)]+=A[i]\n    d2[u.root(i)]+=B[i]\nprint(['No','Yes'][all(d[k]==d2[k] for k in d)])", "# Give me AC!!!\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\nn, m = map(int, input().split())\nunionfind = UnionFind(n)\na, b = list(map(int, input().split())), list(map(int, input().split()))\nfor i in range(m):\n  x, y = map(int, input().split())\n  unionfind.union(x - 1, y - 1)\nfor i in unionfind.all_group_members().values():\n  sum_a, sum_b = 0, 0\n  for j in i:\n    sum_a += a[j]\n    sum_b += b[j]\n  if sum_a != sum_b:\n    print('No');return\nprint('Yes')", "import sys\nfrom math import gcd, factorial, ceil, floor, sqrt\nfrom bisect import bisect_left, bisect_right\nfrom copy import deepcopy\nfrom heapq import heapify, heappop, heappush\nfrom itertools import permutations, combinations, product, accumulate\nfrom collections import defaultdict, deque, Counter\nfrom functools import lru_cache\nsys.setrecursionlimit(10**8)\n\nii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(map(int, input().split()))\n\nN, M = mi()\na = li()\nb = li()\n\nclass UnionFind:\n    def __init__(self, n):\n        # \u8ca0  : \u6839\u3067\u3042\u308b\u3053\u3068\u3092\u793a\u3059\u3002\u7d76\u5bfe\u5024\u306f\u30e9\u30f3\u30af\u3092\u793a\u3059\n        # \u975e\u8ca0: \u6839\u3067\u306a\u3044\u3053\u3068\u3092\u793a\u3059\u3002\u5024\u306f\u89aa\u3092\u793a\u3059\n        self.table = [-1] * n\n \n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n\n    def count(self, x):\n        return -self.table[self._root(x)]\n \n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n \n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        # \u30e9\u30f3\u30af\u306e\u53d6\u5f97\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.table[r1] += d2\n        else:\n            self.table[r1] = r2\n            self.table[r2] += d1\n\nins = UnionFind(N)\n\nfor i in range(M):\n    c, d = mi()\n    ins.union(c-1, d-1)\n\nd = defaultdict(set)\nfor i in range(N):\n    r = ins._root(i)\n    d[r].add(i)\n\nfor i, x in list(d.items()):\n    num1, num2 = 0,0\n    for y in x:\n        num1 += a[y]\n        num2 += b[y]\n    if num1 != num2:\n        print('No')\n        return\nprint('Yes')\n", "class UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n    def find(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u63a2\u7d22\u3057\u3066\u89aa\u3092\u51fa\u3059\u3002\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def union(self, x, y):\n        \"\"\"\n        x \u3068 y \u306e\u30b0\u30eb\u30fc\u30d7\u3092\u7d50\u5408\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n    def is_same(self, x, y):\n        \"\"\"\n        x \u3068 y \u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5426\u304b\n        \"\"\"\n        return self.find(x) == self.find(y)\n    def get_size(self, x):\n        \"\"\"\n        x \u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n\nfrom collections import defaultdict\n\nN,M = map(int,input().split())\nuf = UnionFind(N)\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nfor i in range(M):\n  c,d = map(int,input().split())\n  c-=1;d-=1\n  uf.union(c,d)\n\ndic = defaultdict(int)\nfor i in range(N):\n  par = uf.find(i)\n  dif = A[i]-B[i]\n  dic[par] += dif\n\n#print(dic)\nfor v in dic.values():\n  if v != 0:\n    print(\"No\");return\nprint(\"Yes\")", "n,m=map(int,input().split())\nans=[list(map(int,input().split())) for i in range(2)]\nl=[[] for i in range(n)]\nfor i in range(m):\n    a,b=map(int,input().split())\n    l[a-1].append(b-1)\n    l[b-1].append(a-1)\nboo=[-1]*n\nflag=0\nfrom collections import deque\nfor i in range(n):\n    if boo[i]==-1:\n        q=deque([])\n        q.append(i)\n        ma=0\n        wa=0\n        while q:\n            a=q.popleft()\n            if boo[a]==-1:\n                boo[a]+=1\n                ma+=ans[0][a]\n                wa+=ans[1][a]\n                for j in l[a]:\n                  if boo[j]==-1:\n                    q.append(j)\n        if ma!=wa:\n            flag=1\n            break\nif flag==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "#coding: utf-8\n\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nres = []\nfor i in range(N):\n    res.append(A[i] - B[i])\nuf = UnionFind(N)\nfor i in range(M):\n    c, d = list(map(int, input().split()))\n    uf.union(c-1, d-1)\nflag = True\nsa = {}\nsb = {}\nfor i in range(N):\n    r = uf.find(i)\n    if r not in list(sa.keys()):\n        sa[r] = A[i]\n        sb[r] = B[i]\n    else:\n        sa[r] += A[i]\n        sb[r] += B[i]\nfor k in list(sa.keys()):\n    if sa[k] != sb[k]:\n        flag = False\n\nprint((\"Yes\" if sa == sb else \"No\"))\n# print(sa)\n# print(sb)\n# print(uf.parents)\n", "import sys\nfrom collections import defaultdict\n\n\ndef input(): return sys.stdin.readline().strip()\ndef I(): return int(input())\ndef LI(): return list(map(int, input().split()))\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef S(): return input()\ndef LS(): return input().split()\n\n\nINF = float('inf')\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * n  # \u5404\u8981\u7d20\u306e\u89aa \u89aa\u81ea\u8eab\u306f -i (i \u306f\u96c6\u5408\u306e\u8981\u7d20\u6570)\n\n    def r(self, x):  # x \u306e \u89aa\u3092\u8fd4\u3059\n        if self.root[x] < 0:  # \u81ea\u8eab\u304c\u89aa\n            return x\n        else:  # \u518d\u5e30\u7684\u306b\u89aa\u3092\u8fbf\u308b\n            self.root[x] = self.r(self.root[x])\n            return self.root[x]\n\n    def union(self, x, y):  # x \u3068 y \u3092\u9023\u7d50\n        x = self.r(x)\n        y = self.r(y)\n        if x == y:\n            return  # \u89aa\u304c\u540c\u3058\u306a\u3089\u4f55\u3082\u3057\u306a\u3044\n        self.root[x] += self.root[y]\n        self.root[y] = x\n\n    def find(self, x, y) -> bool:  # x \u3068 y \u306f\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\n        return self.root[x] == self.root[y]\n\n    # \u30aa\u30d7\u30b7\u30e7\u30f3\n    def size(self, x) -> int:  # x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u6570\n        x = self.r(x)\n        return -self.root[x]\n\n    def members(self, x):\n        '''\u8981\u7d20 x \u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3092\u8fd4\u3059'''\n        root = self.r(x)\n        return [i for i in range(self.n) if self.r(i) == root]\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.r(member)].append(member)\n        return group_members\n\n\nn, m = LI()\na = LI()\nb = LI()\nuf = UnionFind(n)\nfor _ in range(m):\n    c, d = LI()\n    c -= 1\n    d -= 1\n    uf.union(c, d)\n\n\nis_ok = True\nmems = list(uf.all_group_members().values())\n\nfor mem in mems:\n    a_sum = 0\n    b_sum = 0\n    for j in mem:\n        a_sum += a[j]\n        b_sum += b[j]\n    if a_sum != b_sum:\n        is_ok = False\n        break\n\nprint((\"Yes\" if is_ok else \"No\"))\n", "class Coloring_Union_Find():\n    def __init__(self,N,f):\n        \"\"\"0,1,...,n-1\u3092\u8981\u7d20\u3068\u3057\u3066\u521d\u671f\u5316\u3059\u308b.\n\n        N:\u8981\u7d20\u6570\n        f:2\u5909\u6570\u95a2\u6570\u306e\u5408\u6210\n        \"\"\"\n        self.n=N\n        self.parents=[-1]*N\n        self.data=[0]*N\n        self.rank=[0]*N\n        self.f=f\n\n    def find(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u65cf\u3092\u8abf\u3079\u308b.\n\n        x:\u8981\u7d20\n        \"\"\"\n        V=[]\n        while self.parents[x]>=0:\n            V.append(x)\n            x=self.parents[x]\n\n        for v in V:\n            self.parents[v]=x\n        return x\n\n    def union(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u3092\u540c\u4e00\u8996\u3059\u308b.\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        self.data[x]=self.data[y]=self.f(self.data[x],self.data[y])\n\n        if self.rank[x]>self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n\n            if self.rank[x]==self.rank[y]:\n                self.rank[y]+=1\n\n    def size(self, x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3057\u3066\u3044\u308b\u8981\u7d20\u306e\u6570.\n\n        x:\u8981\u7d20\n        \"\"\"\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        \"\"\"\u8981\u7d20x,y\u306f\u540c\u4e00\u8996\u3055\u308c\u3066\u3044\u308b\u304b?\n\n        x,y:\u8981\u7d20\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def set(self,x,c):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3059\u308b\u6210\u5206\u306e\u8272\u3092c\u306b\u5909\u66f4\u3059\u308b.\n\n        x:\u8981\u7d20\n        c:\u8272\n        \"\"\"\n        self.data[self.find(x)]=c\n        return\n\n    def look(self,x):\n        \"\"\"\u8981\u7d20x\u306e\u5c5e\u3059\u308b\u6210\u5206\u306e\u8272\n\n        x:\u8981\u7d20\n        \"\"\"\n        return self.data[self.find(x)]\n\n    def members(self, x):\n        \"\"\"\u8981\u7d20x\u304c\u5c5e\u3057\u3066\u3044\u308b\u65cf\u306e\u8981\u7d20.\n        \u203b\u65cf\u306e\u8981\u7d20\u306e\u500b\u6570\u304c\u6b32\u3057\u3044\u3068\u304d\u306fsize\u3092\u4f7f\u3046\u3053\u3068!!\n\n        x:\u8981\u7d20\n        \"\"\"\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        \"\"\"\u65cf\u306e\u540d\u524d\u306e\u30ea\u30b9\u30c8\n        \"\"\"\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        \"\"\"\u65cf\u306e\u500b\u6570\n        \"\"\"\n        return len(self.roots())\n\n    def all_group_members(self):\n        \"\"\"\u5168\u3066\u306e\u65cf\u306e\u51fa\u529b\n        \"\"\"\n        X={r:[] for r in self.roots()}\n        for k in range(self.n):\n            X[self.find(k)].append(k)\n        return X\n\n    def color_list(self):\n        return [self.look(x) for x in range(self.n)]\n\n    def color_map(self):\n        return {x:self.look(x) for x in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n#================================================\nfrom operator import add\n\nN,M=map(int,input().split())\nA=[0]+list(map(int,input().split()))\nB=[0]+list(map(int,input().split()))\nX=[a-b for (a,b) in zip(A,B)]\n\nU=Coloring_Union_Find(N+1,add)\nU.data=X.copy()\n\nfor _ in range(M):\n    c,d=map(int,input().split())\n    U.union(c,d)\n\nif U.color_list()==[0]*(N+1):\n    print(\"Yes\")\nelse:\n    print(\"No\")", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\npar = [i for i in range(n+1)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    \nfor i in range(m):\n  s,t = map(int,input().split())\n  unite(s,t)\n\nfor i in range(n+1):\n  par[i] = find(i)\n\ndata = [0 for _ in range(n+1)]\nfor i in range(1,n+1):\n  data[par[i]] += a[i-1]\n  data[par[i]] -= b[i-1]\n\n\nif data.count(0) == n+1:\n  print(\"Yes\")\nelse:\n  print(\"No\")", "# import sys\n# input = sys.stdin.readline\nimport math\nimport copy\nimport bisect\nfrom itertools import accumulate\nfrom collections import Counter, defaultdict, deque\ndef mp():return list(map(int,input().split()))\ndef lmp():return list(map(int,input().split()))\ndef ceil(U,V):return (U+V-1)//V\ndef modf1(N,MOD):return (N-1)%MOD+1\n\nclass UnionFind():\n    def __init__(self, n):\n        # uf.parents\u3067\u5404\u30ce\u30fc\u30c9\u306e\u89aa\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        # uf.find(x)\u3067\u51e6\u7406\u3092\u884c\u3046\n        #\u3000\u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\uff08\u7d4c\u8def\u5727\u7e2e\uff09\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        # uf.union(x,y)\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3059\u308b\n        # \u5c0f\u3055\u3044\u90e8\u5206\u6728\u3092\u5927\u304d\u3044\u90e8\u5206\u6728\u306b\u304f\u3063\u3064\u3051\u308b\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        # uf.size(x)\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570\u3092\u8fd4\u3059\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        # uf.same(x,y)\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u8981\u7d20x,y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        # uf.members(x)\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        # uf.roots()\u3067\u51e6\u7406\u3092\u884c\u3046\n        #\u3000\u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        # uf.group_count()\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n        return len(self.roots())\n\n    def all_group_members(self):\n        # all_group_members()\u3067\u51e6\u7406\u3092\u884c\u3046\n        # \u6975\u529b\u4f7f\u308f\u306a\u3044\u3053\u3068\n        # \uff5b\u30eb\u30fc\u30c8\u8981\u7d20\uff1a[\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\uff5d\u3092dict\u578b\u3067\u8fd4\u3059\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        # \u30eb\u30fc\u30c8\u8981\u7d20\uff1a[\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m = mp()\na = lmp()\nb = lmp()\nuf = UnionFind(n)\nar = copy.deepcopy(a)\nbr = copy.deepcopy(b)\n# node\u306f0-indexed\u306b\u3059\u308b\u3053\u3068\u306b\u6ce8\u610f\nfor i in range(m):\n    c,d = mp()\n    e,f = uf.find(c-1),uf.find(d-1)\n    uf.union(c-1,d-1)\n    g = uf.find(c-1)\n    if e == f:\n        pass\n    elif e == g:\n        ar[e] += ar[f]\n        br[e] += br[f]\n    else:\n        ar[f] += ar[e]\n        br[f] += br[e]\nrot = uf.roots()\n# print(rot)\n# print(uf.all_group_members())\nfor i in rot:\n    if ar[i] != br[i]:\n        print(\"No\")\n        return\nprint(\"Yes\")\n", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n          group_members[self.find(member)]=0\n        for member in range(self.n):\n            group_members[self.find(member)]+=A[member]-B[member]\n            \n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\nL=UnionFind(N)\nfor i in range(M):\n  c,d=map(int,input().split())\n  c-=1\n  d-=1\n  L.union(c,d)\nfor i in list(L.all_group_members().items()):\n  if i[1]!=0:\n    print(\"No\")\n    return\nprint(\"Yes\")", "def find(x):\n  if par[x] == x:\n    return x\n  else:\n    par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n    return par[x]\n  \ndef same(x,y):\n  return find(x) == find(y)\n\ndef unite(x,y):\n  x = find(x)\n  y = find(y)\n  if x == y:\n    return 0\n  par[x] = y\n\ndef groups(par):\n    leader_buf = [find(par[i]) for i in range(len(par))]\n    result = [[] for _ in range(len(par))]\n    for i in range(len(par)): result[leader_buf[i]].append(i)\n    return [r for r in result if r != []]\n  \nn,m = map(int, input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\npar = [[] for _ in range(n+1)]\nfor i in range(n+1):\n  par[i] = i\n  \nfor i in range(m):\n  c,d = map(int, input().split())\n  unite(c,d)\n  \ng = groups(par)\n\nfor i in range(1,len(g)):\n  asum = 0\n  bsum = 0\n  for j in range(len(g[i])):\n    asum += a[g[i][j]-1]\n    bsum += b[g[i][j]-1]\n  if asum != bsum:\n    print(\"No\")\n    return\n    \nprint(\"Yes\")", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\nN,M = [int(i) for i in input().split()]\nA = [int(i) for i in input().split()]\nB = [int(i) for i in input().split()]\nuf = UnionFind(N)\nfor i in range(M):\n  c,d=list(map(int,input().split()))\n  c-=1;d-=1\n  uf.union(c,d)\n\n  \ncnt_a=[0]*N\ncnt_b=[0]*N\nfor i in range(N):\n  cnt_a[uf.find(i)]+=A[i]\n  cnt_b[uf.find(i)]+=B[i]\n  \nif cnt_a==cnt_b:\n  print(\"Yes\")\nelse:\n  print(\"No\")\n  \n  \n", "class union_find():\n    def __init__(self, n):\n        # self.n = n\n        self.root = [-1]*(n+1)\n        self.rank = [0]*(n+1)\n        self.siz = n\n\n    def find_root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n\n        if x == y:\n            return\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n        self.siz -= 1\n\n    def same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def size(self):\n        return self.siz\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nif sum(a) != sum(b):\n    print('No')\n    return\n    \ng = union_find(n)\nfor _ in range(m):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    g.unite(c, d)\n\n\naa = [0]*n\nbb = [0]*n\nfor i in range(n):\n    j = g.find_root(i)\n    aa[j] += a[i]\n    bb[j] += b[i]\n\nif aa == bb:\n    print('Yes')\nelse:\n    print('No')"]
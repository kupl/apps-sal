["N=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nA.append(A[0])\nB.append(B[0])\n\nAX=[]\nBX=[]\nfor i in range(N):\n    AX.append(A[i]^A[i+1])\n    BX.append(B[i]^B[i+1])\n\nAX+=AX+[AX[0]]\n\n# Rolling Hash\u3067\u3002\n\np=1<<30\nmod=(1<<62)+1 # Hash\u304c\u3076\u3064\u304b\u3089\u306a\u3044, p\u3068\u4e92\u3044\u306b\u7d20\u306a\u6570\u3092\u9069\u5f53\u306b\u6307\u5b9a\n\nA_TABLE=[0] # Rolling Hash\u306e\u30c6\u30fc\u30d6\u30eb. \u6700\u521d\u306f0\nB_TABLE=[0] # Rolling Hash\u306e\u30c6\u30fc\u30d6\u30eb. \u6700\u521d\u306f0\n\nfor i in range(len(AX)):\n    A_TABLE.append((p*A_TABLE[-1]%mod+AX[i])%mod) # \u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\nfor i in range(len(BX)):\n    B_TABLE.append((p*B_TABLE[-1]%mod+BX[i])%mod) # \u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\n\ndef hash(i,j): # [i,j)\u306e\u30cf\u30c3\u30b7\u30e5\u5024\u3092\u6c42\u3081\u308b\n    return (A_TABLE[j]-A_TABLE[i]*pow(p,j-i,mod))%mod\n\nBH=B_TABLE[-1]\nANS=[]\nfor i in range(N):\n    if hash(i,i+N)==BH:\n        ANS.append((i,A[i]^B[0]))\n\nfor a in ANS:\n    print(*a)", "def divisors(M):#M\u306e\u7d04\u6570\u5217 O(n^(0.5+e))\n    import math\n    d=[]\n    i=1\n    while math.sqrt(M)>=i:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    d.sort()\n    return d\n\nimport numpy as np\nN=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nA=np.array([a[i]^a[i-1] for i in range(0,N)])\nB=np.array([b[i]^b[i-1] for i in range(0,N)])\nd=divisors(N)\nperioda=N\nfor i in range(0,len(d)):\n    test=np.roll(A,-d[i])\n    if all(test==A):\n        perioda=min(perioda,d[i])\n\nperiodb=N\nfor i in range(0,len(d)):\n    test=np.roll(B,-d[i])\n    if all(test==B):\n        periodb=min(periodb,d[i])\n\nif perioda==periodb:\n    A=A[:perioda]\n    B=B[:periodb]\n    kouho=[]\n    for i in range(0,len(B)):\n        if A[i]==B[0]:\n            kouho.append(i)\n    ans=-1\n    for i in range(0,len(kouho)):\n        test=np.roll(A,-kouho[i])\n        if all(test==B):\n            ans=kouho[i]\n            break\n    if ans!=-1:\n        for i in range(0,N//perioda):\n            print(ans+perioda*i,a[ans+perioda*i]^b[0])", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nclass RollingHash():\n    def __init__(self, s):\n        self.length = len(s)\n        self.base = 1009\n        self.mod = (1 << 61) - 1\n        self.hash = [0] * (self.length + 1)\n        self.pow = [1] * (self.length + 1)\n\n        for i in range(self.length):\n            self.hash[i+1] = (self.hash[i] + s[i]) * self.base % self.mod\n            self.pow[i+1] = self.pow[i] * self.base % self.mod\n\n    def get(self, l, r):\n        t = self.hash[r] - self.hash[l] * self.pow[r-l] % self.mod\n        t = (t + self.mod) % self.mod\n        return t\n\nn = int(input())\na = [int(item) for item in input().split()]\nb = [int(item) for item in input().split()]\na = a + a\n\ndiffa = []\ndiffb = []\nfor i in range(1, len(a)):\n    diffa.append(a[i] ^ a[i-1])\nfor i in range(1, len(b)):\n    diffb.append(b[i] ^ b[i-1])\n\nRHa = RollingHash(diffa)\nRHb = RollingHash(diffb)\nquery = RHb.get(0, n-1)\nans = []\nfor i in range(n):\n    val = RHa.get(i, i+n-1)\n    if val == query:\n        ans.append((i, a[i] ^ b[0]))\nans.sort()\nfor k, x in ans:\n    print(k, x)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\n# \u5de6\u306e\u7bb1\uff08\u30d1\u30bf\u30fc\u30f3\u306b\u3042\u305f\u308b\uff09\u3068\u53f3\u306e\u7bb1\uff08\u5bfe\u8c61\uff09\u304c\u9023\u52d5\u3057\u3066\u52d5\u304f\n# \u6587\u5b57\u304c\u540c\u3058\u9650\u308a\u53f3\u306b\u5e83\u3052\u3066\u3001lcp\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u5de6\u306b\u7e2e\u3081\u3066\u3044\u304f\u611f\u3058\n# \u7e2e\u3081\u3089\u308c\u306a\u304f\u306a\u3063\u305f\u3089\u3001top\u3092\u53f3\u306e\u7bb1\u306e\u5de6\u7aef\u306b\u3057\u3066\u3001\u5de6\u306e\u7bb1\u30920\u307e\u3067\u305a\u3089\u3059\n# \u7bb1\u304c\u3067\u304d\u3066\u3044\u306a\u3044\uff08\u5e45\u304c0\uff09\u306e\u3068\u304d\u306f\u3001\u53f3\u306e\u7bb1\u30921\u3064\u53f3\u306b\n\ndef ZAlgorithm(aa):\n    target = aa\n    # s = input()\n    len_t = len(target)\n    lcp = [-1] * len_t\n    top = 1  # \u53f3\u306e\u7bb1\u306b\u304a\u3044\u3066\u3001\u5de6\u306e\u7bb1\u306e0\u306b\u5bfe\u5fdc\u3059\u308b\u70b9\n    left = 0  # \u5de6\u306e\u7bb1\u306e\u5de6\u7aef(\u672c\u5f53\u306f\u3053\u3053\u3067\u306e\u3067\u5ba3\u8a00\u306f\u4e0d\u8981\u3060\u3051\u3069\u7406\u89e3\u306e\u70ba)\n    right = 0  # \u5de6\u306e\u7bb1\u306e\u53f3\u7aef\n    lcp[0] = 0\n    while top < len_t:\n        # \u7bb1\u3092\u53f3\u306b\u5e83\u3052\u3066\u3044\u304f\n        while top + right < len_t and target[right] == target[top + right]:\n            right += 1\n        # \u53f3\u306e\u7bb1\u5de6\u7aef\u306elcp\u3092\u8a18\u9332\n        lcp[top] = right\n        left = 1\n        # \u7bb1\u306e\u5e45\u304c0\u3060\u3063\u305f\u3089top\u3092\u52d5\u304b\u3057\u3066\u3001\u3053\u306e\u30bf\u30fc\u30f3\u7d42\u4e86\n        if right == 0:\n            top += 1\n            continue\n        # lcp\u3092\u8a18\u9332\u3057\u306a\u304c\u3089\u7bb1\u3092\u5de6\u306b\u7e2e\u3081\u3066\u3044\u304f\uff08\u6700\u521d\u306e\u6761\u4ef6\u91cd\u8981\uff09\n        while left + lcp[left] < right and left < right:\n            lcp[top + left] = lcp[left]\n            left += 1\n        # top\u3092\u53f3\u306e\u7bb1\u306e\u5de6\u7aef\u306b\u3057\u3066\u3001\u5de6\u306e\u7bb1\u30920\u307e\u3067\u623b\u3059\n        top += left\n        right -= left\n        left = 0  # \u3053\u308c\u3082\u672c\u5f53\u306f\u4e0d\u8981\n    return lcp\n\ndef main():\n    # \u300ca\u3092\u5de6\u306b\u30b7\u30d5\u30c8\u300d\uff1d\u300cb\u3092\u53f3\u306b\u30b7\u30d5\u30c8\u300d\n    # \u5de6\u306b\u30b7\u30d5\u30c8\u306f\u9762\u5012\u306a\u306e\u3067b\u3092\u53f3\u306b\u52d5\u304b\u3059\n    # \u52d5\u304b\u3057\u305f(\u4e0b\u8a18\u306f2\u3064\u30b7\u30d5\u30c8\u3057\u305f\u3068\u304d)\u7d50\u679c\n    #  a0  a1  a2  a3  a4\n    # xor xor xor xor xor\n    #  x   x   x   x   x\n    #  =   =   =   =   =\n    #  b3  b4  b0  b1  b2\n    # \u3068\u3001\u306a\u3063\u3066\u3044\u308c\u3070\u3088\u3044\u3002\u3053\u3053\u3067\u3001xor\u3092\u305f\u3060\u306e\u8db3\u3057\u7b97\u306b\u7f6e\u304d\u63db\u3048\u3066\u8003\u3048\u308b\n    #  a0  a1  a2  a3  a4\n    #  +   +   +   +   +\n    #  x   x   x   x   x\n    #  =   =   =   =   =\n    #  b3  b4  b0  b1  b2\n    # \u5177\u4f53\u4f8b\u3067\n    #  4   6   3   7   2\n    #  +   +   +   +   +\n    #  1   1   1   1   1\n    #  =   =   =   =   =\n    #  5   7   4   8   3\n    # \u3053\u306e\u3068\u304d\u3001a\u306e\u5897\u6e1b\u3068b\u306e\u5897\u6e1b\u306f\u4e00\u81f4\u3059\u308b\n    # a\u306e\u5897\u6e1b\u30fb\u30fb\u30fb\u672b\u5c3e\u304b\u3089(+2) 4 (+2) 6 (-3) 3 (+4) 7 (-5) 2\n    # b\u306e\u5897\u6e1b\u30fb\u30fb\u30fb\u672b\u5c3e\u304b\u3089(+2) 5 (+2) 7 (-3) 4 (+4) 8 (-5) 3\n    # \u3053\u308c\u306fxor\u3067\u3082\u540c\u69d8\u306e\u3053\u3068\u304c\u3044\u3048\u308b\n    # \u3088\u3063\u3066\u3001a,b\u305d\u308c\u305e\u308c\u306e\u96a3\u63a5xor\u306e\u30ea\u30b9\u30c8\u3092\u4f5c\u308b\n    # a\u30922\u3064\u4e26\u3079\u3066(\u30eb\u30fc\u30d7\u3059\u308b\u304b\u3089)\u3001b\u3092\u53f3\u306b\u30b7\u30d5\u30c8\u3057\u306a\u304c\u3089\u4e00\u81f4\u3059\u308b\u4f4d\u7f6e\u3092\u63a2\u3059\n    # \u4e00\u81f4\u3059\u308b\u4f4d\u7f6e\u3092\u63a2\u3059\u306e\u306fZ-Algorithm\u3092\u4f7f\u3063\u305f\n    # \u30b7\u30d5\u30c8\u91cf\u304c\u5206\u304b\u308c\u3070\u3001\u5bfe\u5fdc\u3059\u308b1\u7d44\u306ea,b\u304b\u3089x\u3082\u5206\u304b\u308b\n    # \u3089\u3057\u3044\u304c\u3001\u3053\u3093\u306a\u306e\u601d\u3044\u3064\u304b\u3093\u308f!!\n\n    inf = pow(2, 31)\n    n = II()\n    aa = LI()\n    bb = LI()\n    ax = [aa[i - 1] ^ aa[i] for i in range(n)]\n    bx = [bb[i - 1] ^ bb[i] for i in range(n)]\n    # print(ax)\n    # print(bx)\n    ll = ZAlgorithm(bx + [inf] + ax + ax[:-1])\n    # lcp\u30fb\u30fb\u30fblength common prefix\u307f\u305f\u3044\u306a?\n    for shift, lcp in enumerate(ll[n + 1:]):\n        if lcp == n: print(shift, aa[shift] ^ bb[0])\n\nmain()\n", "# coding: utf-8\n\ndef main():\n\n\t# N = 0\n\t# a = []\n\t# b = []\n\t# with open(\"C:/Users/admin/Downloads/random_05\") as f:\n\t# \tN = int(f.readline())\n\t# \ta = [int(x) for x in f.readline().split()]\n\t# \tb = [int(x) for x in f.readline().split()]\n\n\tN = int(input())\n\ta = [int(x) for x in input().split()]\n\tb = [int(x) for x in input().split()]\n\n\txor_a = [a[i] ^ a[(i+1) % N] for i in range(len(a))]\n\txor_b = [b[i] ^ b[(i+1) % N] for i in range(len(b))]\n\n\tkmp = KmpSearch(xor_a + xor_a, xor_b)\n\n\tans = kmp.full_search()\n\tfor k in ans:\n\t\tif k == len(a):\n\t\t\tbreak\n\t\tprint(str(k) + \" \" + str(a[0 + k] ^ b[0]))\n\nclass KmpSearch:\n\tdef __init__(self, target, pattern):\n\t\tself.target = target\n\t\tself.pattern = pattern\n\t\tself.__table = self.__create_kmp_table()\n\n\tdef full_search(self):\n\t\tif len(self.pattern) > len(self.target):\n\t\t\treturn -1\n\n\t\tres = []\n\t\ti = 0\n\t\tp = 0\n\t\twhile i < len(self.target):\n\t\t\tif self.pattern[p] == self.target[i]:\n\t\t\t\ti += 1\n\t\t\t\tp += 1\n\n\t\t\t\tif p == len(self.pattern):\n\t\t\t\t\tres.append(i-p)\n\t\t\t\t\ti -= 1\n\t\t\t\t\tp = self.__table[p-1]\n\t\t\telif p == 0:\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\tp = self.__table[p]\n\n\t\treturn res\n\n\tdef __create_kmp_table(self):\n\t\ttable = [0 for x in range(len(self.pattern))]\n\n\t\tj = 0\n\t\tfor i in range(1, len(self.pattern)):\n\t\t\ttable[i] = j\n\t\t\tif self.pattern[j] == self.pattern[i]:\n\t\t\t\tj += 1\n\t\t\telse:\n\t\t\t\tj = 0\n\n\t\treturn table\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\ninput=sys.stdin.readline\n\ndef KMP(sentence,word):\n  ret=[]\n  \n  def make_table(word):\n    n=len(word)\n    table=[0]*(n+1)\n    table[0]=-1\n    j=-1\n    for i in range(n):\n      while j>=0 and word[i]!=word[j]:\n        j=table[j]\n      j+=1\n      table[i+1]=j\n    return table\n  \n  table=make_table(word)\n  sentence_size=len(sentence)\n  word_size=len(word)\n  m=0\n  i=0\n  while m+i<sentence_size:\n    if word[i]==sentence[m+i]:\n      i+=1\n      if i==word_size:\n        ret.append(m)\n        m=m+i-table[i]\n        i=table[i]\n    else:\n      m=m+i-table[i]\n      if i>0:\n        i=table[i]\n  return ret\n\nn=int(input())\narr1=list(map(int,input().split()))\narr2=list(map(int,input().split()))\na=[]\nb=[]\nfor i in range(n):\n  a.append(arr1[i]^arr1[(i+1)%n])\n  b.append(arr2[i]^arr2[(i+1)%n])\na=(a+a)[:-1]\nks=KMP(a,b)\nif len(ks)==0:\n  return\nans=[]\nfor k in ks:\n  ans.append((k,arr2[0]^arr1[k%n]))\nans=sorted(ans,key=lambda x:x[1])\nans=sorted(ans,key=lambda x:x[0])\nfor k,x in ans:\n  print(k,x)", "def solve(n, aaa, bbb):\n    ccc = [a1 ^ a2 for a1, a2 in zip(aaa, aaa[1:])] + [aaa[-1] ^ aaa[0]]\n    ddd = [b1 ^ b2 for b1, b2 in zip(bbb, bbb[1:])] + [bbb[-1] ^ bbb[0]]\n\n    ans = []\n\n    m = 2147483647\n    g = 1000000007\n    s = 0\n    for c in ccc:\n        s = (s * g + c) % m\n    t = 0\n    for d in ddd:\n        t = (t * g + d) % m\n    u = pow(g, n, m) - 1\n    for i in range(n):\n        if s == t:\n            ans.append((i, aaa[i] ^ bbb[0]))\n        s = (s * g - ccc[i] * u) % m\n    ans.sort()\n    return ans\n\n\nn = int(input())\naaa = list(map(int, input().split()))\nbbb = list(map(int, input().split()))\nans = solve(n, aaa, bbb)\nprint((''.join('{} {}\\n'.format(*answer) for answer in ans)))\n", "def main():\n    def z_algo(S):\n        n, i, j = len(S), 1, 0\n        a = [0]*n\n        a[0] = n\n        while i < n:\n            while i+j < n and S[i+j] == S[j]:\n                j += 1\n            if not j:\n                i += 1\n                continue\n            a[i], k = j, 1\n            while a[k] < j-k and i+k < n:\n                a[i+k] = a[k]\n                k += 1\n            i += k\n            j -= k\n        return a\n\n    n = int(input())\n    a, b = list(map(int, input().split())), list(map(int, input().split()))\n    a1 = [a[i-1] ^ a[i] for i in range(n)]\n    z = z_algo([b[i-1] ^ b[i] for i in range(n)]+a1+a1)\n    memo = []\n    for i in range(n):\n        if z[n+i] >= n:\n            memo.append(i)\n    b0 = b[0]\n    for i in memo:\n        print(i, b0 ^ a[i])\n\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nA = tuple(map(int, input().split()))\nB = tuple(map(int, input().split()))\nC = [0]*(3*n)\nfor i in range(n):\n  C[i] = B[i]^B[(i+1)%n]\n  C[i+n] = A[i]^A[(i+1)%n]\n  C[i+n+n] = C[i+n]\n\ndef z_algo(S):\n    N = len(S)\n    A = [0]*N\n    A[0] = N\n    i, j = 1, 0\n    while i < N:\n        while i+j < N and S[j] == S[i+j]:\n            j += 1\n        A[i] = j\n        if not j:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k+A[k] < j:\n            A[i+k] = A[k]\n            k += 1\n        i += k\n        j -= k\n    return A  \n\nP = z_algo(C)\nfor i, p in enumerate(P[n:n+n]):\n  if p >= n:\n    x = A[i]^B[0]\n    print(i, x)", "import sys\ninput = sys.stdin.readline\n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nh = 10**11+7\nb = 10**7+7\n\nH = [1]\nfor _ in range(N):\n    H.append((H[-1]*b)%h)\n\nallSum = 0\nfor i in range(N):\n    allSum = (allSum + H[i]) % h\n\nok = [True]*N\nans = [0]*N\n\nC = []\nD = []\nfor i in range(N):\n    C.append(A[i-1]^A[i])\n    D.append(B[i-1]^B[i])\n\n\nHashA = 0\nfor i, a in enumerate(C):\n    HashA = (HashA + a*H[i]%h) % h\n\nHashB = 0\nfor i, a in enumerate(D):\n    HashB = (HashB + a*H[i]%h) % h\n\nans = []\nfor k in range(N):\n    if HashA == HashB:\n        ans.append(k)\n    HashB = (HashB * b) % h\n    HashB = (HashB + (1-H[N])*D[-k-1] % h) % h\n\nfor k in ans:\n    print(k, A[k]^B[0])", "import sys\nBASE, MOD1, MOD2 = (1<<30), (1<<61)-1, (1<<31)-1\n\nclass RollingHash():\n\tdef __init__(self, s, base, mod):\n\t\tself.mod = mod\n\t\tself.pw = pw = [1]*(len(s)+1)\n\n\t\tl = len(s)\n\t\tself.h = h = [0]*(l+1)\n\n\t\tv = 0\n\t\tfor i in range(l):\n\t\t\th[i+1] = v = (v * base + s[i]) % mod\n\t\tv = 1\n\t\tfor i in range(l):\n\t\t\tpw[i+1] = v = v * base % mod\n\n\t# [l. r)\n\tdef get(self, l, r):\n\t\treturn (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod\n\n\tdef concatenate(self, l1, r1, l2, r2):\n\t\treturn (self.get(l1, r1) * self.pw[r2-l2] + self.get(l2, r2)) % self.mod\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nif n == 1:\n\tprint(0, a[0]^b[0])\n\treturn\nx = [a[n-1]^a[0]]\ny = [b[n-1]^b[0]]\nfor i in range(n-1):\n\tx.append(a[i]^a[i+1])\n\ty.append(b[i]^b[i+1])\n\nrh1_x, rh1_y = RollingHash(x, BASE, MOD1), RollingHash(y, BASE, MOD1)\nrh2_x, rh2_y = RollingHash(x, BASE, MOD2), RollingHash(y, BASE, MOD2)\nfor k in range(n):\n\tif rh1_y.concatenate(n-k, n, 0, n-k) == rh1_x.get(0, n) and rh2_y.concatenate(n-k, n, 0, n-k) == rh2_x.get(0, n):\n\t\tprint(k, a[0]^b[(n-k)%n])", "n=int(input())\na=list(map(int,input().split()))\na+=a\nb=list(map(int,input().split()))\naa=[a[i-1]^a[i] for i in range(1,n*2)]\nbb=[b[i-1]^b[i] for i in range(1,n)]\ns=bb+aa\nfrom random import randint\nroli_mod=1370757747362922367\nroli_r=1#randint(2,roli_mod-2)\nroli_table=[0]\nroli_rr=1\nfor i in range(3*(n-1)):\n  roli_table.append((roli_table[-1]+roli_rr*s[i])%roli_mod)\n  roli_rr*=roli_r\n  roli_rr%=roli_mod\ndef roli_hash(i,j):return ((roli_table[j+1]-roli_table[i]+roli_mod)%roli_mod)*pow(roli_r,roli_mod-1-i,roli_mod)%roli_mod\ndef roli_check(i1,j1,i2,j2):return roli_hash(i1,j1)==roli_hash(i2,j2)\nans=[]\nfor k in range(n-1,2*(n-1)+1):\n  if roli_check(0,n-2,k,k+(n-1)-1):\n    ans.append(k-(n-1))\nfor i in ans:\n  print(i,a[i]^b[0])", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\n\nC = [0] * (2 * N - 1)\nD = [0] * N\nfor i in range(2 * N - 1):\n    C[i] = A[i % N] ^ A[(i + 1) % N]\n    D[i % N] = B[i % N] ^ B[(i + 1) % N]\n\nclass KMP:\n\n    def __init__(self, W):\n        self.W = W\n        self.L = len(W)\n        self.T = self._build(W)\n\n    def _build(self, W):\n        T = [0] * self.L\n        T[0] = -1\n        T[1] = 0\n        i = 2\n        j = 0\n\n        while i < self.L:\n            if W[i - 1] == W[j]:\n                T[i] = j + 1\n                i += 1\n                j += 1\n            elif j > 0:\n                j = T[j]\n            else:\n                T[i] = 0\n                i += 1\n\n        return T\n\n    def search(self, S):\n        m = 0\n        i = 0\n        L = len(S)\n        while m + i < L:\n            # print(m, i)\n            if self.W[i] == S[m + i]:\n                i += 1\n                if i == self.L:\n                    i -= 1\n                    ret = m\n                    m = m + i - self.T[i]\n                    i = self.T[i]\n                    yield ret\n            else:\n                m = m + i - self.T[i]\n                if i > 0:\n                    i = self.T[i]\n\n# def ok(x, i):\n#     for j in range(N):\n#         if A[(j + i) % N] ^ B[j] != x:\n#             return False\n#     return True\n#\n#\n# for i in range(N):\n#     x = A[i] ^ B[0]\n#     if ok(x, i):\n#         print(i, x)\n\nkmp = KMP(D)\nfor x in kmp.search(C):\n    xor = A[x] ^ B[0]\n    print(x, xor)", "import sys\ninput = sys.stdin.readline\n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nh = 10**11+7\nb = 10**7+7\n\nH = [1]\nfor _ in range(N):\n    H.append((H[-1]*b)%h)\n\nC = []\nD = []\nfor i in range(N):\n    C.append(A[i-1]^A[i])\n    D.append(B[i-1]^B[i])\n\n\nHashA = 0\nfor i, a in enumerate(C):\n    HashA = (HashA + a*H[i]%h) % h\n\nHashB = 0\nfor i, a in enumerate(D):\n    HashB = (HashB + a*H[i]%h) % h\n\nans = []\nfor k in range(N):\n    if HashA == HashB:\n        ans.append(k)\n    HashB = (HashB * b) % h\n    HashB = (HashB + (1-H[N])*D[-k-1] % h) % h\n\nfor k in ans:\n    print(k, A[k]^B[0])", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nf = [0]*n\ng = [0]*n\nfor i in range(n):\n  f[i] = a[i] ^ a[(i+1)%n]\n  g[i] = b[i] ^ b[(i+1)%n]\n\ndef KMP(S, W):\n    ls, lw = len(S), len(W)\n    m, i = 0, 0\n    T = _KMP_table(W)\n    res = list()\n    while m + i < ls:\n        if W[i] == S[m + i]:\n            i += 1\n            if i == lw:\n                res.append(m)\n                m += i - T[i]\n                if i > 0:\n                    i = T[i]\n        else:\n            m += i - T[i]\n            if i > 0:\n                i = T[i]\n    return res\n\n\ndef _KMP_table(W):\n    W += ['$']\n    lw = len(W)\n    T = [0] * lw\n    T[0] = -1\n    i, j = 2, 0\n    while i < lw:\n        if W[i - 1] == W[j]:\n            T[i] = j + 1\n            i += 1\n            j += 1\n        elif j > 0:\n            j = T[j]\n        else:\n            T[i] = 0\n            i += 1\n    return T\nres = KMP(f*2, g)\nfor x in res:\n  if x < n:\n    print(x, a[x]^b[0])", "def xor_next(values):\n    result = [0] * len(values)\n    for i in range(len(values)):\n        result[i] = values[i] ^ values[(i+1) % len(values)]\n    return result\n\n\ndef make_mp_table(values):\n    result = [-1] * (len(values) + 1)\n    j = -1\n    for i in range(len(values)):\n        while j != -1 and values[j] != values[i]:\n            j = result[j]\n        j += 1\n        result[i+1] = j\n    return result\n\n\ndef mp_find(target, pattern, table):\n    result = []\n    j = 0\n    for i in range(len(target)):\n        while(j != -1 and pattern[j] != target[i]):\n            j = table[j]\n        j += 1\n        if j == len(pattern):\n            result.append(i-(j-1))\n            j = table[j]\n    return result\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    xa = xor_next(a)\n    xb = xor_next(b)\n    mp_t = make_mp_table(xa)\n    xb += xb\n    res = mp_find(xb, xa, mp_t)\n    res.sort(reverse=True)\n    for i in range(len(res)):\n        k = n-res[i]\n        if(k >= n):\n            continue\n        x = a[k] ^ b[0]\n        print((str(k) + ' ' + str(x)))\n\n\nmain()\n", "N = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nX = []\nfor a,b in zip(A,A[1:]):\n    X.append(a ^ b)\nX.append(A[-1] ^ A[0])\n\nY = []\nfor a,b in zip(B,B[1:]):\n    Y.append(a ^ b)\nY.append(B[-1] ^ B[0])\n\ndef z_algorithm(s):\n    N = len(s)\n    ret = [0]*N\n    ret[0] = N\n    i,j = 1,0\n    while i < N:\n        while i+j < N and s[j] == s[i+j]:\n            j += 1\n        ret[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i+k < N and k + ret[k]<j:\n            ret[i+k] = ret[k]\n            k += 1\n        i += k\n        j -= k\n    return ret\n\nza = z_algorithm(X + [-1] + Y + Y)\nfor i in range(N):\n    if za[-N-i] == N:\n        print(i, A[i]^B[0])", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nC = [a1^a2 for a1, a2 in zip(A, A[1:])] + [A[0]^A[-1]]\nC = C + C\nD = [b1^b2 for b1, b2 in zip(B, B[1:])] + [B[0]^B[-1]]\n\nK = []\nk = 0\nwhile k < N:\n  next_k = k\n  is_first = True\n  for i in range(N):\n    if is_first and i>0 and C[k+i]==D[0]:\n      next_k = k + i\n      is_first = False\n    if C[k+i] != D[i]:\n      if next_k == k:\n        k = k + i + 1\n      else:\n        if D[k+i-next_k] == C[k+i]:\n          k = next_k\n        else:\n          k = k + i + 1\n      break\n  \n  if i == N-1:\n    K.append(k)\n    if next_k == k:\n      break\n    else:\n      k = next_k\n      if len(K) == 2:\n        diff = K[1] - K[0]\n        while K[-1] < N:\n          K.append(K[-1]+diff)\n      \n        _ = K.pop()\n        break\n\nfor k in K:\n  print(k, A[k]^B[0])", "N=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nA.append(A[0])\nB.append(B[0])\n\nAX=[]\nBX=[]\nfor i in range(N):\n    AX.append(A[i]^A[i+1])\n    BX.append(B[i]^B[i+1])\n\nAX+=AX[:-1]\n\n# MP\u6cd5\n\n\nLEN=len(BX)\nMP=[-1]*(LEN+1) #\u300c\u63a5\u982d\u8f9e\u3068\u63a5\u5c3e\u8f9e\u304c\u6700\u5927\u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b\u300d\u3092\u8a18\u9332\u3059\u308b\u914d\u5217\nNOW=-1 # \u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b.\n\nfor i in range(LEN):\n    while NOW>=0 and BX[i]!=BX[NOW]: # \u4e00\u81f4\u3057\u3066\u3044\u306a\u304b\u3063\u305f\u30890\u304b\u3089\u6570\u3048\u76f4\u3059\u306e\u3067\u306f\u306a\u304f, MP[NOW]\u304b\u3089\u6570\u3048\u308b.\n        NOW=MP[NOW]\n    NOW+=1\n    MP[i+1]=NOW\n\nLEN2=len(AX)\n\nMP_SEARCH=[0]*(LEN2) # \u305d\u306e\u6587\u5b57\u307e\u3067\u3067\u4f55\u500b\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b\u3092\u8abf\u3079\u308b. LEN\u6587\u5b57\u4e00\u81f4\u3057\u305f\u3089S\u304c\u691c\u51fa\u3067\u304d\u305f\u3068\u3044\u3046\u3053\u3068.\nNOW=0\nfor i in range(LEN2):\n    while NOW>=0 and AX[i]!=BX[NOW]:\n        NOW=MP[NOW]\n    NOW+=1\n    MP_SEARCH[i]=NOW\n\n    if NOW==LEN: # LEN\u6587\u5b57\u4e00\u81f4\u3057\u305f\u3089, MP[LEN]\u304b\u3089\u6570\u3048\u308b.\n        NOW=MP[NOW]\n        \nfor i in range(LEN2):\n    if MP_SEARCH[i]==LEN:\n        print(i-LEN+1,A[i-LEN+1]^B[0])", "def z_algo(S):\n    # Z-algoirhm  O(n)\n    # Z[i] := S \u3068 S[i:] \u3067 prefix \u304c\u4f55\u6587\u5b57\u4e00\u81f4\u3057\u3066\u3044\u308b\u304b\n    # \u691c\u8a3c: https://atcoder.jp/contests/arc055/submissions/14179788\n    i, j, n = 1, 0, len(S)\n    Z = [0] * n\n    Z[0] = n\n    while i < n:\n        while i+j < n and S[j] == S[i+j]:\n            j += 1\n        if j == 0:\n            i += 1\n            continue\n        Z[i] = j\n        d = 1\n        while i+d < n and d+Z[d] < j:\n            Z[i+d] = Z[d]\n            d += 1\n        i += d\n        j -= d\n    return Z\n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nA_diff = []\na2 = A[-1]\nfor a in A:\n    A_diff.append(a^a2)\n    a2 = a\nB_diff = []\nb2 = B[-1]\nfor b in B:\n    B_diff.append(b^b2)\n    b2 = b\nA_diff_2 = A_diff + A_diff[:-1]\nZ = z_algo(A_diff_2)\nA_diff_str = \"_\".join(map(str, A_diff_2))\nB_diff_str = \"_\".join(map(str, B_diff))\nidx = A_diff_str.find(B_diff_str)\nif idx==-1:\n    return\nidx = A_diff_str[:idx].count(\"_\")\nAns = []\nb0 = B[-idx]\nfor i, (z, a, b) in enumerate(zip(Z, A, B)):\n    if z >= N:\n        Ans.append([(idx+i)%N, a^b0])\n        # x = [idx, i, a, b, B[-idx]]\n        # print(x)\nAns.sort()  # \u3053\u308c\u3044\u308b\uff1f\nfor k, x in Ans:\n    print(f\"{k} {x}\")\n", "class KMP:\n    def __init__(self, P):\n        self.P = P\n        self.N = len(P)\n        self.T = [0] * (self.N + 1)\n        self._compile()\n\n    def _compile(self):\n        j = 0\n        self.T[0] = -1\n        for i in range(1, self.N):\n            self.T[i] = j\n            j += 1 if self.P[i] == self.P[j] else -j\n        self.T[self.N] = j\n\n    def search(self, S):\n        NS = len(S)\n        i = m = 0\n        A = []\n        while m + i < NS:\n            if self.P[i] == S[m + i]:\n                i += 1\n                if i != self.N:\n                    continue\n                A.append(m)\n            m += i - self.T[i]\n            i = max(0, self.T[i])\n        return A\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = [A[i]^A[(i+1)%N] for i in range(N)]\nD = [B[i]^B[(i+1)%N] for i in range(N)]\nC = C + C[:-1]\nK = KMP(D).search(C)\nfor k in K:\n    print(k, A[k]^B[0])", "num = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = []\nd = []\n\nfor i in range(num):\n    c.append(a[i] ^ a[(i+1)%num])\n    d.append(b[i] ^ b[(i+1)%num])\n    \nc += c\n\n# print(c)\n# print(d)\n\n# \u30c6\u30fc\u30d6\u30eb\u4f5c\u6210\ntable = [0]\nk = 0\nfor i in range(1, num+1):\n    table.append(k)\n    if i == num:\n        continue\n    \n    if d[i] == d[k]:\n        k += 1\n    else:\n        k = 0\n\n# print(table)\n\ni = 0 # \u63a2\u7d22\u3055\u308c\u308b\u6587\u5b57\u5217\u306e\u4f4d\u7f6e\nj = 0 # \u63a2\u7d22\u3059\u308b\u6587\u5b57\u5217\u306e\u4f4d\u7f6e\nk = 0 # k\u306e\u521d\u671f\u5024\nwhile k < num:\n    \n    while True:\n        # print(i, j, k)\n        if c[i] == d[j]:\n            if j == num - 1:\n                print(k, a[k] ^ b[0])\n                i += 1\n                j = table[num]\n                k = i - j\n                break\n            \n            i += 1\n            j += 1\n        elif j != 0:\n            j -= 1\n        else:    \n            i += 1\n            j = table[j]\n            break\n    \n    k = i - j"]
["import heapq\n\ncity_num, road_num, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver  = min(MAX_COST, init_silver)\n\nG = [[] for _ in range(city_num)]\nfor _ in range(road_num):\n    A, B, cost, time_cost = map(int, input().split())\n    A, B = A-1, B-1\n    G[B].append([A, cost, time_cost])\n    G[A].append([B, cost, time_cost])\n\nfor n in range(city_num):\n    cost, time_cost = map(int, input().split())\n    G[n].append([n, -cost, time_cost])\n\ndp = [[float(\"inf\")] * (MAX_COST+1) for _ in range(city_num)]\ndp[0][init_silver] = 0\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n    for to, silver_cost, time_cost in G[node]:\n        remain = min(silver - silver_cost, MAX_COST)\n        if remain < 0:\n            continue\n        dp_next_value = time + time_cost\n        if dp[to][remain] <= dp_next_value:\n            continue\n        dp[to][remain] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain))\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")", "def solve():\n    import sys\n    input = sys.stdin.readline\n    N,M,S = map(int,input().split())\n    UVAB = [tuple(map(int,input().split())) for i in range(M)]\n    CD = [tuple(map(int,input().split())) for i in range(N)]\n\n    es = [[] for _ in range(N)]\n    for u,v,a,b in UVAB:\n        u,v = u-1,v-1\n        es[u].append((v,a,b))\n        es[v].append((u,a,b))\n\n    INF = float('inf')\n    times = [INF] * (2501 * N)\n    start = min(2500,S)*N\n    times[start] = 0\n    hq = [start]\n    ans = [-1] * N\n    ans[0] = 0\n    reached = 0\n    import heapq\n    heapq.heapify(hq)\n    while hq:\n        x = heapq.heappop(hq)\n        t,v = divmod(x,N*2501)\n        s,i = divmod(v,N)\n        if ans[i] < 0:\n            ans[i] = t\n            reached += 1\n            if reached == N-1: break\n        for to,a,b in es[i]:\n            if a > s: continue\n            nv = (s-a)*N + to\n            if times[nv] <= t + b: continue\n            times[nv] = t + b\n            heapq.heappush(hq, (t+b)*N*2501 + nv)\n        ns = s\n        nt = times[v]\n        while ns <= 2500:\n            ns += CD[i][0]\n            nt += CD[i][1]\n            nv = min(2500,ns)*N + i\n            if times[nv] <= nt: break\n            times[nv] = nt\n            heapq.heappush(hq, nt*N*2501 + nv)\n    print(*ans[1:], sep='\\n')\nsolve()", "import heapq\ndef dijkstra_heap(N,S,Smax,edge):\n  d = [float('inf')]*(10**4*N) #\u59cb\u70b90\u304b\u3089\u5404\u9802\u70b9\u3078\u306e\u6700\u77ed\u8ddd\u96e2\n  used = [False]*(10**4*N)\n  d[S] = 0\n  used[S] = True\n  edgelist = []\n  #edgelist : [(0,S)\u304b\u3089\u306e\u66ab\u5b9a(\u672a\u78ba\u5b9a)\u6700\u77ed\u6642\u9593,\u9802\u70b9,\u9280\u8ca8\u306e\u679a\u6570]\u306e\u30ea\u30b9\u30c8\n  #edge[s] : s\u304b\u3089\u51fa\u308b\u679d\u306e[\u91cd\u307f,\u9802\u70b9,\u9280\u8ca8\u306e\u679a\u6570]\u306e\u30ea\u30b9\u30c8\n  for w,a in edge[0]:\n    v,sil = a//10**4,a%10**4\n    if v==0 and S+sil<=Smax:\n      heapq.heappush(edgelist,[w,a+S]) #s\u306e\u96a3\u306e\u70b9\u306f\u679d\u306e\u91cd\u3055\u304c\u305d\u306e\u307e\u307e\u66ab\u5b9a\u6700\u77ed\u8ddd\u96e2\u3068\u306a\u308b\n    elif v>0 and S-sil>=0:\n      heapq.heappush(edgelist,[w,v*10**4+(S-sil)]) #s\u306e\u96a3\u306e\u70b9\u306f\u679d\u306e\u91cd\u3055\u304c\u305d\u306e\u307e\u307e\u66ab\u5b9a\u6700\u77ed\u8ddd\u96e2\u3068\u306a\u308b\n  while len(edgelist):\n    #\u307e\u3060\u4f7f\u308f\u308c\u3066\u306a\u3044\u9802\u70b9\u306e\u4e2d\u304b\u3089\u6700\u5c0f\u306e\u8ddd\u96e2\u306e\u3082\u306e\u3092\u63a2\u3059\u2192\u78ba\u5b9a\u3055\u305b\u308b\n    min_w,min_a = heapq.heappop(edgelist)\n    min_v,min_sil = min_a//10**4,min_a%10**4\n    #min_w,min_v,min_sil : [0\u304b\u3089\u306e(\u78ba\u5b9a)\u6700\u77ed\u8ddd\u96e2,\u9802\u70b9,\u9280\u8ca8\u306e\u679a\u6570]\n    if used[min_a]:\n      continue\n    d[min_a] = min_w\n    used[min_a] = True\n    for w,a in edge[min_v]:\n      v,sil = a//10**4,a%10**4\n      if v==min_v and min_sil+sil<=Smax and not used[a+min_sil]:\n        heapq.heappush(edgelist,[min_w+w,a+min_sil])\n      elif v!=min_v and min_sil-sil>=0 and not used[v*10**4+(min_sil-sil)]:\n        heapq.heappush(edgelist,[min_w+w,v*10**4+(min_sil-sil)])\n  return d\n\ndef solve():\n  N, M, S = map(int, input().split())\n  edge = [[] for _ in range(N)]\n  amax = 0\n  for i in range(M):\n    u,v,a,b = map(int, input().split())\n    amax = max(amax,a)\n    edge[u-1].append([b,(v-1)*10**4+a])\n    edge[v-1].append([b,(u-1)*10**4+a])\n  Smax = (N-1)*amax\n  S = min(S,Smax)\n  for i in range(N):\n    c,d = map(int, input().split())\n    edge[i].append([d,i*10**4+c])\n  D = dijkstra_heap(N,S,Smax,edge)\n  ans = [0]*N\n  for i in range(1,N):\n    ans[i] = min(D[i*10**4:(i+1)*10**4])\n  return ans[1:]\nprint(*solve(),sep='\\n')", "import heapq\ndef dijkstra_heap():\n    used = [-1] * (2451*n)\n    edgelist=[]\n    heapq.heappush(edgelist,[0,ss])\n    while len(edgelist):\n        minedge = heapq.heappop(edgelist)\n        if used[minedge[1]]!=-1:\n            continue\n        v = minedge[1]\n        kai=minedge[0]\n        mai=v%2451\n        used[v] = kai\n        for e in edge[v//2451]:\n            if mai-e[1]>=0:\n                sss=mai-e[1]\n                if used[e[2]*2451+sss]==-1:\n                    heapq.heappush(edgelist,[e[0]+kai,e[2]*2451+sss])\n        if mai+cd[v//2451][0]<=2450:\n            if used[v+cd[v//2451][0]]==-1:\n                heapq.heappush(edgelist,[kai+cd[v//2451][1],v+cd[v//2451][0]])\n    return used\n\n################################\nn,m,ss = map(int,input().split())\nss=min(2450,ss)\nedge = [[] for i in range(n)]\n\nfor i in range(m):\n    x,y,a,b = map(int,input().split())\n    edge[x-1].append([b,a,y-1])\n    edge[y-1].append([b,a,x-1])\ncd=[]\nfor i in range(n):\n    cd.append(list(map(int,input().split())))\npp=dijkstra_heap()\nfor i in range(1,n):\n    ans=10**20\n    for j in range(2451):\n        if pp[i*2451+j]!=-1:\n            ans=min(ans,pp[i*2451+j])\n    print(ans)", "from heapq import *\n\nN, M, S = tuple(map(int, input().split()))\n\nT = [[10**18 for _ in range(2451)] for _ in range(N)]\n\nact = [[] for _ in range(N)]\n\nfor i in range(M):\n  U, V, A, B = tuple(map(int, input().split()))\n  U -= 1\n  V -= 1\n  act[U] += [(V, A, B)]\n  act[V] += [(U, A, B)]\n\nfor i in range(N):\n  C, D = tuple(map(int, input().split()))\n  act[i] += [(i, -C, D)]\n\nque = [(0, 0, S)]\n\nwhile que:\n  (currentT, n, coins) = heappop(que)\n  for m, cost, t in act[n]:\n    # \u3082\u3057\u300c\u6255\u3048\u308b\u91d1\u984d\u3067\u300d\u300c\u6700\u5c0f\u6642\u9593T[\u79fb\u52d5\u5148][\u6240\u6301\u91d1]\u3092\u66f4\u65b0\u3067\u304d\u308b\u3068\u304d\u300d\u306b\u5024\u3092\u66f4\u65b0\u3001\u30ad\u30e5\u30fc\u306b\u72b6\u614b\u3092\u8ffd\u52a0\u3002\n    if coins >= cost and currentT + t < T[m][min(2450, coins - cost)]:\n      T[m][min(2450, coins - cost)] = currentT + t\n      heappush(que, (currentT + t, m, min(2450, coins - cost)))\n\nfor i in range(1, N):\n  print(min(T[i]))", "def main():\n    import heapq\n\n    n, m, s = map(int, input().split())\n\n    edges = [[] for _ in range(n)]\n    max_cost = 0\n    for _ in range(m):\n        from_, to, cost, time = map(int, input().split())\n        edges[from_-1].append((to-1, cost, time))\n        edges[to-1].append((from_-1, cost, time))\n        if cost > max_cost:\n            max_cost = cost\n\n    banks = []\n    for i in range(n):\n        coin, time = map(int, input().split())\n        banks.append((coin, time))\n\n    max_coin = max_cost * (n-1)\n    if s > max_coin:\n        s = max_coin\n\n    INF = float('INF')\n    DP = [[INF] * (max_coin+1) for _ in range(n)]\n    DP[0][s] = 0\n\n    def push_todo(node, coin, time):\n        if coin < 0:\n            return\n        if time >= DP[node][coin]:\n            return\n        heapq.heappush(todo, (time, node, coin))\n        DP[node][coin] = time\n\n    def charge(node, current_coin, current_time):\n        coin, time = banks[node]\n        new_coin = current_coin + coin\n        if new_coin > max_coin:\n            new_coin = max_coin\n        push_todo(node, new_coin, current_time+time)\n\n    todo = [(0, 0, s)]  # time, node, coin\n    while todo:\n        current_time, node, current_coin = heapq.heappop(todo)\n        if current_time > DP[node][current_coin]:\n            continue\n\n        charge(node, current_coin, current_time)\n\n        for to, cost, time in edges[node]:\n            push_todo(to, current_coin-cost, current_time+time)\n\n    for node in range(1, n):\n        print(min(DP[node]))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\n\nN, M, S = list(map(int, input().strip().split()))\n\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n\tu, v, A, B = list(map(int, input().strip().split()))\n\tu -= 1\n\tv -= 1\n\tgraph[u].append((v, A, B))\n\tgraph[v].append((u, A, B))\n\nexchanges = []\nfor _ in range(N):\n\tC, D = list(map(int, input().strip().split()))\n\texchanges.append((C, D))\n\nqueue = [(0, 0, S)]\nmax_fare = 2500\n\nstate_table = [[None] * (max_fare + 1) for i in range(N)]\n\nreached = [False] * N\nreached_count = 0\n\nwhile queue:\n#\tprint(len(queue))\n\ttime, cur, money = heapq.heappop(queue)\n\tif not reached[cur]:\n\t\treached[cur] = True\n\t\treached_count += 1\n\t\tif reached_count >= N:\n\t\t\tbreak\n\tcount, d_time = exchanges[cur]\n\tfor n, A, B in graph[cur]:\n\t\tn_money = money - A\n\t\tn_time = time + B\n\t\tif n_money >= 0:\n\t\t\tstates = state_table[n]\n\t\t\tif n_money > max_fare:\n\t\t\t\tn_money = max_fare\n\t\t\tif states[n_money] == None or states[n_money] > n_time:\n\t\t\t\tstates[n_money] = n_time\n\t\t\t\theapq.heappush(queue, (n_time, n, n_money))\n\n\tstates = state_table[cur]\n\tmoney += count\n\ttime += d_time\n\tif money >= 0:\n\t\tif money > max_fare:\n\t\t\tmoney = max_fare\n\t\tif states[money] == None or states[money] > time:\n\t\t\tstates[money] = time\n\t\t\theapq.heappush(queue, (time, cur, money))\n\n#for i in range(N):\n#\tprint(i, state_table[i])\n\nfor i in range(1, N):\n\tstates = state_table[i]\n\tminimum = None\n\tfor t in states:\n\t\tif t != None and (minimum == None or minimum > t):\n\t\t\tminimum = t\n\tprint(minimum)\n", "from heapq import heappop, heappush\n\nimport sys\ndef input():return sys.stdin.readline().strip()\n\ndef main():\n    N, M, S = map(int, input().split())\n    to = [{} for _  in range(N)]\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u -= 1\n        v -= 1\n        to[u][v] = (a, b)\n        to[v][u] = (a, b)\n    info = tuple(tuple(map(int, input().split())) for _ in range(N))\n\n    MAX_SILVER = 50 * (N-1)\n    INF = 10 ** 18\n    # dijkstra (time, vertex, money)\n    visited = [[False]*(MAX_SILVER+1) for _ in range(N)]\n    cost = [[INF]*(MAX_SILVER+1) for _ in range(N)]\n    q = []\n    S = min(S, MAX_SILVER)\n    heappush(q, (0, 0, S)) # (time, vertex, silver)\n\n    while q:\n        t, now, s = heappop(q)\n        if visited[now][s]:continue\n        visited[now][s] = True\n        cost[now][s] = t\n\n        # next node\n        for nv, (a, b) in to[now].items():\n            nt = t + b\n            rest = s - a\n            if rest >= 0:\n                if cost[nv][rest] <= nt : continue \n                heappush(q, (nt, nv, rest))\n        \n        # exchange gold with silver\n        rate, time = info[now]\n        nt = t + time\n        ns = min(s+rate, MAX_SILVER)\n        if cost[now][ns] <= nt : continue\n        heappush(q, (nt, now, ns))\n        \n    \n    for i in range(1, N):\n        print(min(cost[i]))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom heapq import heappush, heappop\nimport numpy as np\n\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\n\ndef main():\n\n    def dijkstra(xs, ss):\n        def push(v, s, x):\n            if s < 0: \n                return\n            if dist[v, s] <= x:\n                return\n            dist[v, s] = x\n            heappush(que, (x, v, s))\n        \n        inf = 10**18\n        dist = np.full((n, MAX_S+1), inf, dtype=int)\n        # time, remain, node\n        que = []\n        push(xs, ss, 0)\n        while que:\n            x, v, s = heappop(que)\n            if dist[v, s] < x:\n                continue\n            ns = min(s+c[v], MAX_S)\n            push(v, ns, x+d[v])\n            for nv, a, b in adj[v]:\n                push(nv, s-a, x+b)\n        return np.min(dist, axis=1)\n\n    n, m, s = mi()\n    adj = [[] for i in range(n)]\n    MAX_S = 0\n    for i in range(m):\n        u, v, a, b = mi()\n        u -= 1\n        v -= 1\n        adj[u].append((v, a, b))\n        adj[v].append((u, a, b))\n        MAX_S = max(MAX_S, a)\n    MAX_S *= n-1\n    s = min(s, MAX_S)\n    c, d = [0]*n, [0]*n\n    for i in range(n):\n        c[i], d[i] = mi()\n    ans = dijkstra(0, s)\n    print(*ans[1:], sep='\\n')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport heapq\ndef input(): return sys.stdin.readline().rstrip()\n\n\nn, m, s = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n+1)]\n\nmaxcoin = 0\n\nfor i in range(m):\n    u, v, a, b = list(map(int, input().split()))\n    graph[u].append((v, a, b))\n    graph[v].append((u, a, b))\n    maxcoin += a\n\nryougae = [0, 0]*(n+1)\n\nfor i in range(1, n+1):\n    c, d = list(map(int, input().split()))\n    ryougae[i] = [c, d]\n\n\nmindist = [[10**20]*(maxcoin+1) for _ in range(n+1)]\nhq = []\nheapq.heappush(hq, (0, 1, min(maxcoin, s)))\nwhile hq:\n    minute, city, coin = heapq.heappop(hq)\n    if mindist[city][coin] != 10**20:\n        continue\n    mindist[city][coin] = minute\n    for i, pay, length in graph[city]:\n        if coin >= pay:\n            if mindist[i][coin-pay] != 10**20:\n                continue\n            heapq.heappush(hq, (minute+length, i, coin-pay))\n    if coin < maxcoin:\n        kankin = min(maxcoin, ryougae[city][0]+coin)\n        if mindist[city][kankin] != 10**20:\n            continue\n        heapq.heappush(hq, (minute+ryougae[city][1], city, kankin))\n\nfor i in range(2, n+1):\n    print((min(mindist[i])))\n", "import heapq\nN, M, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver = min(init_silver, MAX_COST)\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, silver_cost, time_cost = map(int, input().split())\n    u, v = u - 1, v - 1\n    G[u].append([v, silver_cost, time_cost])\n    G[v].append([u, silver_cost, time_cost])\n\nchange_rate, change_cost = [], []\nfor i in range(N):\n    rate, cost = map(int, input().split())\n    G[i].append([i, -rate, cost])\n    change_rate.append(rate)\n    change_cost.append(cost)\n\n\n# dp[i][silver] := \u9802\u70b9i\u306b\u3044\u3066\u9280\u8ca8\u3092silver\u679a\u6301\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u72b6\u6cc1\u3092\u4f5c\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u6700\u5c0f\u6642\u9593\ndp = [[float('inf')] * (MAX_COST + 1) for _ in range(N)]\ndp[0][init_silver] = 0\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc: (time, node, silver)\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n\n    # self_loop_silver = min(silver + change_rate[node], MAX_COST)\n    # self_loop_cost = time + change_cost[node]\n    # if self_loop_cost < dp[node][self_loop_silver]:\n    #     dp[node][self_loop_silver] = self_loop_cost\n    #     heapq.heappush(hq, (time + change_cost[node], node, self_loop_silver))\n\n    for to, silver_cost, time_cost in G[node]:\n        remain_silver = min(silver - silver_cost, MAX_COST)\n        if remain_silver < 0:\n            continue\n\n        dp_next_value = time + time_cost\n        if dp[to][remain_silver] <= dp_next_value:\n            continue\n\n        dp[to][remain_silver] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain_silver))\n\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")\n", "import sys\nimport heapq\ndef dijkstra(s,es):\n    INF=sys.maxsize\n    cs=[INF]*len(es)\n    cs[s],hq=0,[]\n    heapq.heapify(hq)\n    heapq.heappush(hq,(cs[s],s))\n    while hq:\n        d,v=heapq.heappop(hq)\n        if cs[v]<d:continue\n        for t,b in es[v]:\n            if cs[t]>cs[v]+b:\n                cs[t]=cs[v]+b\n                heapq.heappush(hq,(cs[t],t))\n    return cs\ndef nwc(n,c):\n    MAX_COINS=2500\n    return (MAX_COINS+1)*n+c\ndef main():\n    MAX_COINS=2500\n    N,M,S=tuple(map(int,sys.stdin.readline().split()))\n    S=S if S<MAX_COINS else MAX_COINS\n    es=[[] for _ in range(N*(MAX_COINS+1))]\n    for _ in range(M):\n        u,v,a,b=tuple(map(int,sys.stdin.readline().split()))\n        u,v=u-1,v-1\n        for c in range(a,MAX_COINS+1):\n            es[nwc(u,c)].append((nwc(v,c-a),b))\n            es[nwc(v,c)].append((nwc(u,c-a),b))\n    for n in range(N):\n        c,d=tuple(map(int,sys.stdin.readline().split()))\n        c=c if c<MAX_COINS else MAX_COINS\n        for i in range(0,MAX_COINS-c+1):es[nwc(n,i)].append((nwc(n,i+c),d))\n    cs=dijkstra(nwc(0,S),es)\n    for n in range(1,N):print(min(cs[n*(MAX_COINS+1):(n+1)*(MAX_COINS+1)]))\ndef __starting_point():main()\n__starting_point()", "import heapq\ndef main():\n    N, M, S = map(int, input().split())\n    money_max = 50*N\n    S = min(S, money_max)\n    dp = [[float(\"inf\")]*(money_max+1) for _ in range(N)]\n    dp[0][S] = 0\n    G = [[] for _ in range(N)]\n    exchange = [None]*N\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u, v = u-1, v-1\n        G[u].append([v, a, b])\n        G[v].append([u, a, b])\n    for i in range(N):\n        c, d = map(int, input().split())\n        exchange[i] = [c, d]\n    q = []\n    heapq.heapify(q)\n    heapq.heappush(q, [0, 0, S])\n    while 0 < len(q):\n        pre_time, idx, s = heapq.heappop(q)\n        if dp[idx][s] < pre_time:\n            continue\n        ex = min(s + exchange[idx][0], money_max)\n        if dp[idx][s] + exchange[idx][1] < dp[idx][ex]:\n            dp[idx][ex] = dp[idx][s] + exchange[idx][1]\n            heapq.heappush(q, [dp[idx][ex], idx, ex])\n        for to, money, time in G[idx]:\n            if money <= s:\n                if dp[idx][s] + time < dp[to][s-money]:\n                    dp[to][s-money] = dp[idx][s] + time\n                    heapq.heappush(q, [dp[to][s-money], to, s-money])\n    for i in range(1, N):\n        print(min(dp[i]))\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq as hq\nn,m,s = list(map(int,input().split()))\nG = [[] for _ in range(n)]\n\nfor i in range(m):\n  u,v,A,B = list(map(int,input().split()))\n  u -= 1\n  v -= 1\n  hq.heappush(G[u], (B,A,v))\n  hq.heappush(G[v], (B,A,u))\n  #G[u].append((B,A,v))\n  #G[v].append((B,A,u))\n\nc = [0]*n\nd = [0]*n\nfor i in range(n):\n  C,D = list(map(int,input().split()))\n  c[i] = C\n  d[i] = D\n\ninf = 1<<61\nM = 50*51\nif s > M:s = M-1\ndp = [[inf] * M for _ in range(n)] \ncur = 0\ndp[cur][s] = 0\nque = [(0,s,0)]\nwhile que:\n  cd,cs,cur = hq.heappop(que)\n  C = c[cur];D = d[cur]\n  if dp[cur][cs] < cd:continue\n  if cs+C < M and cd+D < dp[cur][cs+C]:\n    dp[cur][cs+C] = cd+D\n    hq.heappush(que, (cd+D, cs+C, cur))\n  for g in G[cur]:\n    B = g[0];A = g[1];to = g[2]\n    if cs >= A and B+cd < dp[to][cs-A]:\n      dp[to][cs-A] = B+cd\n      hq.heappush(que, (B+cd, cs-A, to))\n\nfor i in range(1,n):\n  print((min(dp[i])))\n", "# -*- coding:utf-8 -*-\n\ndef solve():\n    import sys\n    import heapq\n\n    MAX_S = 50*50\n    N, M, S = list(map(int, sys.stdin.readline().split()))\n    graph = [[] for _ in range(N)]\n\n    for _ in range(M):\n        u, v, a, b = list(map(int, sys.stdin.readline().split()))\n        u, v = u-1, v-1\n        graph[u].append((v, a, b))\n        graph[v].append((u, a, b))\n\n    ryogae = []\n    for _ in range(N):\n        c, d = list(map(int, sys.stdin.readline().split()))\n        ryogae.append((c, d))\n\n    # dp[v][s] := \u9802\u70b9v\u306b\u6240\u6301\u91d1s\u3067\u8a2a\u308c\u308b\u3068\u304d\u306e\u6700\u5c0f\u6642\u9593\n    dp = [[float(\"inf\") for _ in range(MAX_S+1)] for __ in range(N)]\n\n    # \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\n    s = min(S, MAX_S)\n    que = []\n    heapq.heappush(que, (0, 0, s))  # (\u6642\u523bt, \u9802\u70b9\u756a\u53f7v, \u6240\u6301\u91d1s)\n    # heapq.heappush(que, (0, s, 0))  # (\u9802\u70b9\u756a\u53f7v, \u6240\u6301\u91d1s, \u6642\u523bt)\n\n    while len(que) != 0:\n        t, v, s = heapq.heappop(que)\n        # v, s, t = heapq.heappop(que)\n\n        # if dp[v][s] != t: continue  # \u306a\u306b\u3053\u308c\uff1f\n\n        # \u4e21\u66ff\u3059\u308b\u5834\u5408\n        c, d = ryogae[v]\n        ns = min(s+c, MAX_S)\n        if dp[v][ns] > t+d:\n            dp[v][ns] = t+d\n            heapq.heappush(que, (t+d, v, ns))\n            # heapq.heappush(que, (v, ns, t+d))\n\n        # \u79fb\u52d5\u3059\u308b\u5834\u5408(v -> u\u306b\u79fb\u52d5)\n        for u, a, b in graph[v]:\n            if s-a < 0: continue\n            if dp[u][s-a] > t+b:\n                dp[u][s-a] = t+b\n                heapq.heappush(que, (t+b, u, s-a))\n                # heapq.heappush(que, (u, s-a, t+b))\n\n    for v in range(1, N):\n        ans = float(\"inf\")\n        for s in range(MAX_S+1):\n            ans = min(ans, dp[v][s])\n        print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "\nfrom heapq import heappush, heappop\ndef resolve():\n    INF = float('inf')\n    maxMoney = 2502\n\n    def Dijkstra(g):\n        ans = {}\n        # \u3042\u308b\u9802\u70b9\u306b\u3044\u3066\u3001\u3042\u308b\u9280\u8ca8\u306e\u679a\u6570\u3092\u6301\u3063\u3066\u3044\u308b\u3068\u304d\u306e\u3053\u308c\u307e\u3067\u306b\u304b\u304b\u3063\u305f\u6700\u77ed\u6642\u9593\n        dp = [[INF] * (maxMoney + 1) for _ in range(N)]\n        # (time, node, silver)\n        hq = []\n        heappush(hq, (0, 0, min(S, maxMoney)))\n        while hq:\n            t, v, s = heappop(hq)\n            if t > dp[v][s]:\n                continue\n            if v not in ans:\n                ans[v] = t\n                if len(ans) == N:\n                    break\n\n            # buy\n            if s < maxMoney:\n                c, d = CD[v]\n                new_s = min(s + c, maxMoney)\n                new_t = t + d\n                if new_t < dp[v][new_s]:\n                    dp[v][new_s] = new_t\n                    heappush(hq, (new_t, v, new_s))\n\n            # move\n            for nv, cost, time in G[v]:\n                # \u6255\u3048\u306a\u3044\n                if s < cost:\n                    continue\n                # \u6255\u3063\u3066\u79fb\u52d5\u3057\u305f\u5834\u5408\u3001\u6700\u77ed\u6642\u9593\u306a\u3089\u66f4\u65b0\n                new_s = s - cost\n                new_t = t + time\n                if new_t < dp[nv][new_s]:\n                    dp[nv][new_s] = new_t\n                    heappush(hq, (new_t, nv, new_s))\n        return ans\n\n    N, M, S = list(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, coin, tm = list(map(int, input().split()))\n        u, v = u - 1, v - 1\n        G[u].append((v, coin, tm))\n        G[v].append((u, coin, tm))\n    CD = [list(map(int, input().split())) for _ in range(N)]\n\n    ans = Dijkstra(G)\n    for i in range(1, N):\n        print((ans[i]))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from heapq import heappop,heappush\nn,m,s=map(int,input().split())\ng=[[]for i in range(n)]\nx=0\nfor i in range(m):\n    u,v,a,b=map(int,input().split())\n    g[u-1].append([v-1,a,b])\n    g[v-1].append([u-1,a,b])\n    x=max(x,a)\nfor i in range(n):\n    c,d=map(int,input().split())\n    g[i].append([i,-c,d])\nx*=(n-1)\nt=[[2**64 for i in range(x+1)]for i in range(n)]\nq=[]\nheappush(q,(0,0,s))\nwhile q:\n    a,b,c=heappop(q)\n    for i,j,h in g[b]:\n        if c>=j and a+h<t[i][min(x,c-j)]:\n            t[i][min(x,c-j)]=a+h\n            heappush(q,(a+h,i,c-j))\nfor i in range(1,n):\n    print(min(t[i]))", "def main():\n    import heapq\n\n    n, m, s = list(map(int, input().split()))\n    if s >= 2500:\n        s = 2499\n\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        from_, to, cost, time = list(map(int, input().split()))\n        edges[from_-1].append((to-1, cost, time))\n        edges[to-1].append((from_-1, cost, time))\n\n    banks = []\n    for i in range(n):\n        coin, time = list(map(int, input().split()))\n        banks.append((coin, time))\n\n    INF = float('INF')\n    DP = [[INF] * 2500 for _ in range(n)]\n    DP[0][s] = 0\n    ans = [INF] * n\n\n    def push_todo(node, coin, time):\n        if coin < 0:\n            return\n        if time >= DP[node][coin]:\n            return\n        heapq.heappush(todo, (time, node, coin))\n        DP[node][coin] = time\n\n    def charge(node, current_coin, current_time):\n        coin, time = banks[node]\n        new_coin = current_coin + coin\n        if new_coin >= 2500:\n            new_coin = 2499\n        push_todo(node, new_coin, current_time+time)\n\n    todo = [(0, 0, s)]  # time, node, coin\n    while todo:\n        current_time, node, current_coin = heapq.heappop(todo)\n        if current_time > DP[node][current_coin]:\n            continue\n\n        if current_time < ans[node]:\n            ans[node] = current_time\n\n        charge(node, current_coin, current_time)\n\n        for to, cost, time in edges[node]:\n            push_todo(to, current_coin-cost, current_time+time)\n\n    for a in ans[1:]:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from heapq import heappush, heappop\n\n    INF = 1 << 60\n    MX_AG = 2500\n\n    N, M, S = list(map(int, input().split()))\n    S = min(S, MX_AG)  # \u305d\u308c\u4ee5\u4e0a\u306eAg\u306f\u4e0d\u8981\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        u, v, a, b = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n\n    exchange = []\n    for _ in range(N):\n        c, d = list(map(int, input().split()))\n        exchange.append((c, d))\n\n    h = [(0, S, 0)]\n\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    # time[location][r_Ag]:=minimum_time_to_reach\n\n    while h:\n        t, ag, loc = heappop(h)\n        for to, fare, dt in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0: continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time: continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n\n        e_time = t + exchange[loc][1]\n        e_Ag = ag + exchange[loc][0]\n        if e_Ag > MX_AG: continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time: continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n\n    for to in range(1, N):\n        print((min(time[to])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\n\nN, M, S = map(int, input().split())\n\nuvab = [list(map(int, input().split())) for _ in range(M)]\ncd = [list(map(int, input().split())) for _ in range(N)]\n\nfor i in range(M):\n    uvab[i][0] -= 1\n    uvab[i][1] -= 1\n\nrailways = [[] for _ in range(N)]\nmax_a = 0\nfor u, v, a, b in uvab:\n    railways[u].append((v, a, b))\n    railways[v].append((u, a, b))\n    max_a = max(max_a, a)\ndel uvab\n\nmax_silver = max_a * (N - 1)\n\nans = [-1] * N\nd = dict()\nd[(S, 0)] = 0  # silver, station\nQ = [(0, S, 0)]  # time, silver, station\nsum_reached = 0\nreached = [False] * N\n\nwhile Q:\n    t, sv, st = heapq.heappop(Q)\n    if not reached[st]:\n        ans[st] = t\n        reached[st] = True\n        sum_reached += 1\n        if sum_reached == N:\n            break\n\n    new_key = (min(max_silver, sv + cd[st][0]), st)\n    new_value = t + cd[st][1]\n    if new_key not in d or d[new_key] > new_value:\n        d[new_key] = t + cd[st][1]\n        heapq.heappush(Q, (new_value, *new_key))\n\n    for dist, a, b in railways[st]:\n        if sv >= a:\n            new_key = (sv - a, dist)\n            new_value = t + b\n            if new_key not in d or d[new_key] > new_value:\n                d[new_key] = new_value\n                heapq.heappush(Q, (new_value, *new_key))\n\nprint(*ans[1:], sep=\"\\n\")\n", "# snuke\u89e3\u8aac\u677f\nfrom heapq import heappush, heappop\n\ninfi = 10 ** 20\nn, m, s = map(int, input().split())\n\ns = min(s, n * 50)\n\nedges = [[] for _ in range(n + 1)]\n# edge:1-50, max silver=0-2500\n\nfor _ in range(m):  # a\u5186, b\u5206\n    u, v, a, b = map(int, input().split())\n    edges[v].append((u, a, b))\n    edges[u].append((v, a, b))\n\nexchange = [(0, 0)] * (n + 1)\n\nfor edge_num in range(1, n + 1):  # c\u5186, d\u5206\n    c, d = map(int, input().split())\n    exchange[edge_num] = (c, d)\n\nstart = 1\n# dp[i][j], \u9802\u70b9i\u306b\u304a\u91d1j\u3092\u6301\u3063\u3066\u5230\u9054\u3059\u308b\u6700\u4f4e\u6642\u9593\u2192\u6642\u9593\u306b\u95a2\u3057\u3066DAG\ndp = [[infi] * (n * 50 + 1) for _ in range(n + 1)]\n\n\ndef dijkstra(edges, start, s, dp):\n    dp[start][s] = 0\n    edgelist = []\n    heappush(edgelist, (0, s, start))  # \u6642\u9593, \u304a\u91d1, \u9802\u70b9\n    while edgelist:\n        nowtime, nowmoney, nowedge = heappop(edgelist)\n        # \u9077\u79fb\u3055\u305b\u308b\u6761\u4ef6\u306fedge,money\u306e\u7d44\u307f\u5408\u308f\u305b\u306b\u5bfe\u3057\u3066\u305d\u306e\u6642\u306e\u6700\u5c0f\u5024\u304c\u51fa\u3066\u304d\u305f\u3068\u304d\u306e\u307f\u2192\u6700\u5c0f\u5024\u4ee5\u5916\u306f\u98db\u3070\u3059\u3002\n        if dp[nowedge][nowmoney] != nowtime:\n            continue\n        # \u4e21\u66ff\n        deltamoney, deltatime = exchange[nowedge]\n        nextmoney = min(nowmoney + deltamoney, n * 50)\n        nexttime = nowtime + deltatime\n        if dp[nowedge][nextmoney] > nexttime:\n            dp[nowedge][nextmoney] = nexttime\n            heappush(edgelist, (nexttime, nextmoney, nowedge))\n        # \u79fb\u52d5\n        for v, vmoney, vtime in edges[nowedge]:\n            nexttime = nowtime + vtime\n            nextmoney = nowmoney - vmoney\n            if nextmoney < 0:\n                continue\n            if dp[v][nextmoney] > nexttime:\n                dp[v][nextmoney] = nexttime\n                heappush(edgelist, (nexttime, nextmoney, v))\n    return dp\n\n\ntime = dijkstra(edges, start, s, dp)\n\nans = [infi] * (n + 1)\nfor i in range(1, n + 1):\n    for j in range(n * 50 + 1):\n        ans[i] = min(ans[i], dp[i][j])\n\nprint(*ans[2 : (n + 1)], sep=\"\\n\")\n", "# \u89e3\u8aac\u3068\u63d0\u51fa#12551970\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# \u4eca\u3044\u308b\u90fd\u5e02\u3068\u9280\u8ca8\u306e\u6240\u6301\u6570\u3092\u72b6\u614b\u3068\u3057\u3066\u3001\n#   \u2460\u305d\u306e\u90fd\u5e02\u304b\u3089\u79fb\u52d5\u53ef\u80fd\u306a\u5225\u306e\u90fd\u5e02\u306b\u79fb\u52d5\u3059\u308b\n#   \u2461\u91d1\u8ca8\u3092\u9280\u8ca8\u306b\u4ea4\u63db\u3059\u308b\n# \u306e\u3069\u3061\u3089\u304b\u3092\u884c\u3044\u3001\u5b9f\u65bd\u5f8c\u306e(\u540c\u90fd\u5e02\u30fb\u540c\u6240\u6301\u9280\u8ca8\u679a\u6570\u3067\u306e)\u6700\u5c0f\u6642\u9593\u3092\u8a08\u6e2c\u3057\u3066\u3044\u304f\u3002\n# \u6700\u5c0f\u6642\u9593\u304c\u66f4\u65b0\u3055\u308c\u305f\u5834\u5408\u3001\u3055\u3089\u306b\u305d\u306e\u72b6\u614b\u304b\u3089\u2460\u30fb\u2461\u3092\u884c\u3046\u3002\n# \u3053\u308c\u306b\u3088\u3063\u3066\u5168\u90fd\u5e02\u30fb\u5168\u9280\u8ca8\u6240\u6301\u679a\u6570\u6bce\u306e\u6700\u5c0f\u6642\u9593\u3092\u5272\u308a\u51fa\u3059\u3002\n# \u90fd\u5e02\u306e\u9280\u8ca8\u6240\u6301\u679a\u6570\u6bce\u306e\u6700\u5c0f\u6642\u9593\u306e\u4e2d\u3067\u306e\u6700\u5c0f\u6642\u9593\u304c\u305d\u306e\u90fd\u5e02\u3078\u884c\u304f\u305f\u3081\u306e\u6700\u5c0f\u6642\u9593\u306b\u306a\u308b\u3002\n#   \u203b1: \u90fd\u5e02\u3078\u306e\u79fb\u52d5\u306f\u79fb\u52d5\u53ef\u80fd\u306a\u679a\u6570\u306e\u9280\u8ca8\u3092\u6301\u3063\u3066\u3044\u308b\u5834\u5408\u306e\u307f\u53ef\u80fd\n#   \u203b2: \u9280\u8ca8\u306e\u6700\u5927\u6240\u6301\u679a\u6570\u306f (N - 1) * max(Ai) \u3068\u3059\u308b\n#        -> \u4e00\u756a\u9060\u3044\u90fd\u5e02\u306b\u79fb\u52d5\u3059\u308b\u5834\u5408\u306b\u304b\u304b\u308a\u3046\u308b\u6700\u5927\u306e\u9280\u8ca8\u679a\u6570\n\nfrom heapq import heappop, heappush\n\n\ndef solve():\n    n, m, s = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    # \u30b0\u30e9\u30d5\u4f5c\u88fd\n    for _ in range(m):\n        u, v, a, b = list(map(int, input().split()))\n        graph[u - 1].append([v - 1, a, b])\n        graph[v - 1].append([u - 1, a, b])\n    ce = [[int(i) for i in input().split()] for _ in range(n)]\n    # \u521d\u671f\u5024\u30de\u30c3\u30d7\u4f5c\u88fd\n    maxSilver = 50 * 49  # max(a) * (n - 1)\n    inf = float('inf')\n    ns_map = [[inf] * (maxSilver + 1) for _ in range(n)]\n    # \u30b9\u30bf\u30fc\u30c8\u6642\u306e\u5024\u8a2d\u5b9a\u3068\u63a2\u7d22\n    q = [[0, 0, min(maxSilver, s)]]  # \u7d2f\u8a08\u6642\u9593, \u90fd\u5e02, \u6240\u6301\u9280\u8ca8\n    ns_map[0][min(maxSilver, s)] = 0  # \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u306e\u6642\u523b\u306f0\n    while q:\n        ti, ni, si = heappop(q)\n        # \u79fb\u52d5\n        for g in graph[ni]:\n            n2, ai, bi = g\n            if si >= ai and ns_map[n2][si - ai] > ti + bi:\n                ns_map[n2][si - ai] = ti + bi\n                # \u2605heapq \u3067\u7d2f\u8a08\u6642\u9593\u304c\u5c11\u306a\u3044\u60c5\u5831\u304b\u3089\u5148\u306b\u51e6\u7406\u3059\u308b\u3088\u3046\u306b\u3059\u308b.\n                # \u3053\u308c\u306b\u3088\u3063\u3066\u51e6\u7406\u901f\u5ea6\u304c\u5168\u7136\u9055\u3046\n                heappush(q, [ti + bi, n2, si - ai])\n        # \u63db\u91d1\n        ci, di = ce[ni]\n        ti += di\n        si = min(si + ci, maxSilver)\n        if ns_map[ni][si] > ti:\n            ns_map[ni][si] = ti\n            heappush(q, [ti, ni, si])\n    for i in range(1, n):\n        print((min(ns_map[i])))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n,m,s=list(map(int,input().split()))\nuvab=[list(map(int,input().split())) for _ in range(m)]\ncd=[list(map(int,input().split())) for _ in range(n)]\ng=[[] for _ in range(n)]\nmaxs=0\nfor u,v,a,b in uvab:\n    u,v=u-1,v-1\n    g[u].append([v,a,b])\n    g[v].append([u,a,b])\n    maxs+=a\n\n#\u300c\u73fe\u5728\u3044\u308b\u9802\u70b9\u3001\u73fe\u5728\u6301\u3063\u3066\u3044\u308b\u9280\u8ca8\u679a\u6570\u300d\u3092\u9802\u70b9\u3068\u3057\u3001\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u3067\u3068\u304f\u3002\nfrom heapq import heappop,heappush\ninf=float('inf')\nans=[[inf]*(maxs+1) for _ in range(n)]\ns=min(s,maxs)\ntodo=[[0,0,s]]\nans[0][s]=0\nwhile todo:\n    t,v,ss=heappop(todo)\n    if ans[v][ss]<t:continue\n    for nv,na,nb in g[v]:\n        if na>ss:continue\n        if ans[nv][ss-na]>t+nb:\n            heappush(todo,[t+nb,nv,ss-na])\n            ans[nv][ss-na]=t+nb\n    c,d=cd[v]\n    nss=min(ss+c,maxs)\n    if ans[v][nss]>t+d:\n        heappush(todo,[t+d,v,nss])\n        ans[v][nss]=t+d\nfor i in range(1,n):\n    print((min(ans[i])))\n\n", "from heapq import heappop,heappush\n\ndef main():\n    N,M,S=map(int,input().split())\n    G=[[] for _ in range(N)]\n    for i in range(M):\n        U,V,A,B=map(int,input().split())\n        G[U-1].append([V-1,A,B])\n        G[V-1].append([U-1,A,B])\n    C=[]\n    D=[]\n    for _ in range(N):\n        c,d=map(int,input().split())\n        C.append(c)\n        D.append(d)\n\n    MaxMoney=2500\n\n    dp=[[float('inf') for __ in range(MaxMoney+1)] for _ in range(N)]\n\n    cost=0\n    money=min(S,MaxMoney)\n    que=[]\n    heappush(que,(cost,0,money)) #cost,node,money\n    dp[0][money] = 0\n\n    while len(que)>0:\n        cost,node,money=heappop(que)\n\n        stop_money=min(money+C[node],MaxMoney)\n        stop_cost=cost+D[node]\n        if stop_cost<dp[node][stop_money]:\n            dp[node][stop_money]=stop_cost\n            heappush(que,(stop_cost,node,stop_money))\n\n        for to_node,to_money,to_cost in G[node]:\n            money_=min(money-to_money,MaxMoney)\n            if money_<0:\n                continue\n            cost_=cost+to_cost\n            if dp[to_node][money_]<=cost_:\n                continue\n\n            dp[to_node][money_]=cost_\n            heappush(que,(cost_,to_node,money_))\n\n    for i in range(1,N):\n        print(min(dp[i]))\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import heapq as hq\nN,M,S = list(map(int, input().split()))\n#Edge\nE = [[] for _ in range(N)]\n  \nfor _ in range(M):\n  # U <-> V, A coins, B mins\n  u,v,a,b = list(map(int, input().split()))\n  # 0-indexed\n  E[u-1].append([v-1, a, b])\n  E[v-1].append([u-1, a, b])\n\n# City\nC = []\nfor _ in range(N):\n  # C coins, D mins\n  C.append(list(map(int, input().split())))\n  \n# dp[p][i] \u70b9P\u306b\u305f\u3069\u308a\u7740\u3044\u305f\u6642\u3001i\u5186\u6301\u3063\u3066\u3044\u308b\u6642\u306e\u6700\u5c0f\u6642\u9593\nMAXYEN = 50 * N\ndp = [[ 1e18 for i in range(MAXYEN + 5) ] for _ in range(N)]\nS = min(MAXYEN, S)\ndp[0][S] = 0\n\n# \u72b6\u614b\u306f\u70b9\u3068\u304a\u91d1\u3068\u6642\u9593. time, pointindex, money\nQ = []\nhq.heapify(Q)\nhq.heappush(Q, [0,0,S])\n\nwhile len(Q) > 0:\n  nowt, nowi, nowm = hq.heappop(Q)\n  #print(\"Pop :\", nowt, nowi, nowm)\n  # Edge\u3092\u308f\u305f\u308b\u3002a yen\u6255\u3063\u3066B\u6642\u9593\u304b\u3051\u3066\u3001V\u306b\u79fb\u52d5\u3059\u308b\u3002\n  for e in E[nowi]:\n    to_i, costm, costt = e\n    #print(\"Edge:\", to_i, costm, costt)\n    if nowm - costm < 0:\n      # unreachable \n      continue\n    if dp[to_i][nowm-costm] > dp[nowi][nowm] + costt:\n      dp[to_i][nowm-costm] = dp[nowi][nowm] + costt\n      hq.heappush(Q, [dp[nowi][nowm] + costt, to_i, nowm-costm])\n      \n  # \u305d\u306e\u5834\u3067\u304a\u91d1\u30921\u56de\u8cb7\u3046\u3002\u79fb\u52d5\u305b\u305a\u3001CYenGet\u3057\u3066\u3001D\u6642\u9593\u304b\u3051\u308b\n  getm, costt = C[nowi]\n  targetm = min(MAXYEN, nowm + getm)\n  #print(\"Buy :\", getm, targetm, costt)\n  if dp[nowi][targetm] > dp[nowi][nowm] + costt:\n    dp[nowi][targetm] = dp[nowi][nowm] + costt\n    hq.heappush(Q, [dp[nowi][targetm], nowi, targetm])\n  \nfor i in range(1,N):\n  print((min(dp[i])))\n  \n", "import heapq\nN, M, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver = min(init_silver, MAX_COST)\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, silver_cost, time_cost = map(int, input().split())\n    u, v = u - 1, v - 1\n    G[u].append([v, silver_cost, time_cost])\n    G[v].append([u, silver_cost, time_cost])\n\nchange_rate, change_cost = [], []\nfor i in range(N):\n    rate, cost = map(int, input().split())\n    G[i].append([i, -rate, cost])  # \u3053\u308c\u3092\u8ffd\u52a0\uff01\n    change_rate.append(rate)\n    change_cost.append(cost)\n\n\n# dp[i][silver] := \u9802\u70b9i\u306b\u3044\u3066\u9280\u8ca8\u3092silver\u679a\u6301\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u72b6\u6cc1\u3092\u4f5c\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u6700\u5c0f\u6642\u9593\ndp = [[float('inf')] * (MAX_COST + 1) for _ in range(N)]\ndp[0][init_silver] = 0\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc: (time, node, silver)\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n\n    for to, silver_cost, time_cost in G[node]:\n        remain_silver = min(silver - silver_cost, MAX_COST)\n        if remain_silver < 0:\n            continue\n\n        dp_next_value = time + time_cost\n        if dp[to][remain_silver] <= dp_next_value:\n            continue\n\n        dp[to][remain_silver] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain_silver))\n\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")", "from scipy.sparse import coo_matrix\nfrom scipy.sparse.csgraph import dijkstra\nimport numpy as np\n\nN,M,S=map(int,input().split())\n\nUs=[0]*M\nVs=[0]*M\nAs=[0]*M\nBs=[0]*M\nfor i in range(M):\n    Us[i],Vs[i],As[i],Bs[i] = map(int,input().split())\n    Us[i] -= 1\n    Vs[i] -= 1\n\n# ---\nV={}\nNs = max(As)*N\nNv=N*(Ns+1)\ncnt=0\nfor i in range(N):\n    for ns in range(Ns+1):\n        V[(i,ns)]=cnt\n        cnt+=1\n\nrow=[]\ncol=[]\ndata=[]\n\nif S > Ns:\n    S = Ns\n\n# U <-> V\nfor _ in range(M):\n    u = Us.pop()\n    v = Vs.pop()\n    a = As.pop()\n    b = Bs.pop()\n    #\n    for i in range(Ns+1): # i = 0,..,Ns\n        ns_s = Ns - i\n        ns_g = ns_s - a\n        if ns_g >= 0:\n            # U -> V\n            row.append( V[(u,ns_s) ])\n            col.append( V[(v,ns_g)] )\n            data.append( b )\n            # V -> U\n            row.append( V[(v,ns_s) ])\n            col.append( V[(u,ns_g)] )\n            data.append( b )\n\n# -----\n\nfor i in range(N):\n    c,d = map(int,input().split())\n    for j in range(Ns): # j = 0,...,Ns-1\n        ns_s = j\n        ns_g = j + c\n        if ns_g > Ns:\n            ns_g = Ns\n        row.append( V[(i,ns_s) ])\n        col.append( V[(i,ns_g)] )\n        data.append( d )\n\ngraph=coo_matrix((data, (row, col)), shape=(Nv,Nv))\n\ns=V[(0,S)]\ndist_matrix = dijkstra(csgraph=graph, directed=True, indices = s)\n\nfor i in range(1,N):\n    ans = min([dist_matrix[i*(Ns+1)+v] for v in range(Ns+1)])\n    print(int(ans))", "from heapq import heappop, heappush\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\n# \u30b0\u30e9\u30d5\u3092\u62e1\u5f35\u3057\u3066\u30c0\u30a4\u30af\u30b9\u30c8\u30e9\u6cd5\u3092\u4f7f\u3046\n\ndef main():\n    N,M,S = list(map(int, readline().split()))\n\n    E = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u,v,a,b = list(map(int, readline().split()))\n        E[u].append((v, a, b))\n        E[v].append((u, a, b))\n\n    cd = list(map(int, read().split()))\n    CD = []\n    for c, d in zip(*[iter(cd)]*2):\n        CD.append((c, d))\n\n    # Dijkstra\n    # d[v][s] := \u9802\u70b9v\u3067,\u6240\u6301\u91d1s\u3068\u306a\u308b\u6700\u5c0f\u306e\u6240\u8981\u6642\u9593\n    if S > 2500:\n        S = 2500 - 1\n    INF = 10**15\n    d = [[INF] * 2500 for _ in range(N+1)]\n    d[1][S] = 0\n\n    Q = []\n    heappush(Q, (0, S, 1))  # (\u6240\u8981\u6642\u9593, \u6240\u6301\u91d1, \u9802\u70b9)\n    \n    while Q:\n        time, s, u = heappop(Q)\n        if time > d[u][s]:\n            continue\n        \n        c_u, d_u = CD[u-1]\n        if s + c_u < 2500 and time + d_u < d[u][s + c_u]:\n            d[u][s + c_u] = time + d_u\n            heappush(Q, (time + d_u, s + c_u, u))\n        \n        for v, a, b in E[u]:\n            if s >= a and time + b < d[v][s - a]:\n                d[v][s - a] = time + b\n                heappush(Q, (time + b, s - a, v))\n\n    for i in range(2,N+1):\n        print((min(d[i])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\nfrom collections import deque\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nDR = [1, -1, 0, 0]\nDC = [0, 0, 1, -1]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n     \ndef main():\n    N, M, S = LI()\n    G = [[[] for _ in range(2501)] for _ in range(N)]\n\n    for i in range(M):\n        u, v, a, b = LI()\n        u -= 1\n        v -= 1\n        for money in range(2501):\n            if money - a < 0 :\n                continue\n            G[u][money].append((b, v, money - a))\n            G[v][money].append((b, u, money - a))\n\n    for i in range(N):\n        c, d = LI()\n        for money in range(2501):\n            new_money = min(2500, money + c)\n            G[i][money].append((d, i, new_money))\n    def dijkstra(u, s):\n        q = []\n        d = [[inf for __ in range(2501)] for _ in range(N)]\n        visited = set()\n        dist = 0\n        money = min(2500, s)\n        d[u][money] = dist\n        heapq.heappush(q, (dist, u, money))\n        while len(q) > 0:\n            dist, u, u_money = heapq.heappop(q)\n\n            if (u, u_money) in visited:\n                continue\n            visited.add((u, u_money))\n            for next_node_tuple in G[u][u_money]:\n                cost, v, v_money = next_node_tuple\n                if dist + cost < d[v][v_money]:\n                    d[v][v_money] = dist + cost\n                    heapq.heappush(q, (d[v][v_money], v, v_money))\n        return d\n    d = dijkstra(0, S)\n    for i in range(1, N):\n        print((min(d[i])))\n\nmain()\n\n", "import heapq\nN, M, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver = min(init_silver, MAX_COST)\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, silver_cost, time_cost = map(int, input().split())\n    u, v = u - 1, v - 1\n    G[u].append([v, silver_cost, time_cost])\n    G[v].append([u, silver_cost, time_cost])\n\nchange_rate, change_cost = [], []\nfor i in range(N):\n    rate, cost = map(int, input().split())\n    change_rate.append(rate)\n    change_cost.append(cost)\n\n\n# dp[i][silver] := \u9802\u70b9i\u306b\u3044\u3066\u9280\u8ca8\u3092silver\u679a\u6301\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u72b6\u6cc1\u3092\u4f5c\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u6700\u5c0f\u6642\u9593\ndp = [[float('inf')] * (MAX_COST + 1) for _ in range(N)]\ndp[0][init_silver] = 0\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc: (time, node, silver)\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n\n    self_loop_silver = min(silver + change_rate[node], MAX_COST)\n    self_loop_cost = time + change_cost[node]\n    if self_loop_cost < dp[node][self_loop_silver]:\n        dp[node][self_loop_silver] = self_loop_cost\n        heapq.heappush(hq, (time + change_cost[node], node, self_loop_silver))\n\n    for to, silver_cost, time_cost in G[node]:\n        remain_silver = min(silver - silver_cost, MAX_COST)\n        if remain_silver < 0:\n            continue\n\n        dp_next_value = time + time_cost\n        if dp[to][remain_silver] <= dp_next_value:\n            continue\n\n        dp[to][remain_silver] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain_silver))\n\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")\n", "import heapq\nimport sys\ninput = sys.stdin.readline\n \nINF = 10 ** 18\n \nclass Edge():\n    def __init__(self, end, cost, time):\n        self.end = end\n        self.cost = cost\n        self.time = time\n \ndp = []\nh = []\n \ndef push(t, v, x):\n    if x < 0:\n        return\n    if dp[v][x] <= t:\n        return\n    dp[v][x] = t\n    heapq.heappush(h, (t, v, x))\n \ndef dijkstra(n, G, cd, start, s, max_s):\n    nonlocal dp\n    dp = [[INF for j in range(max_s+1)] for i in range(n)] \n    push(0, start, s)\n \n    while h:\n        # \u4f7f\u3063\u3066\u3044\u306a\u3044\u9802\u70b9\u306e\u3046\u3061\u3001\u73fe\u6642\u70b9\u3067\u6700\u3082\u5230\u9054\u77ed\u6642\u9593\u304c\u77ed\u3044\u3082\u306e\u3092\u9078\u3073v\u3068\u3059\u308b\n        t, v, x = heapq.heappop(h)\n        if dp[v][x] < t:\n            continue\n        # \u4e21\u66ff\n        if x < max_s:\n            push(t+cd[v][1], v, min(x+cd[v][0], max_s))\n        # v\u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5230\u9054\u6642\u9593\u304c\u77ed\u304f\u306a\u308c\u3070\u66f4\u65b0\n        for e in G[v]:\n            push(t+e.time, e.end, x-e.cost)\n \n \nn, m, s = map(int, input().split())\nuvab = [list(map(int, input().split())) for _ in range(m)]\ncd = [list(map(int, input().split())) for _ in range(n)]\n \nes = [[] for i in range(n)]\nmax_s = 50 * (n-1)\n \nfor u, v, a, b in uvab:\n    es[u-1].append(Edge(v-1,a,b))\n    es[v-1].append(Edge(u-1,a,b))\n \ndijkstra(n, es, cd, 0, min(max_s,s), max_s)\n \nfor i in range(1, n):\n    print(min(dp[i]))", "from heapq import *\nN, M, S = map(int, input().split())\ngraph = [[] for _ in range(N)]\namax = 0\nfor i in range(M):\n  u, v, a, b = map(int, input().split())\n  u -= 1\n  v -= 1\n  graph[u].append([v, a, b])\n  graph[v].append([u, a, b])\n  amax = max(amax, a)\n  \nlcoins = amax * (N-1)\n  \ncost = list()\ntime = list()\nfor _ in range(N):\n  c, d = map(int, input().split())\n  cost.append(c)\n  time.append(d)\n\nINF = float('INF')\nM = 2500\nif(S >= M):\n  S = M-1\n\ndist = [[INF] * M for _ in range(N)]\ndist[0][S] = 0\nq = [(0, S, 0)]\n\nwhile q:\n  dv, num, v = heappop(q)\n  \n  if dist[v][num] < dv:\n    continue\n    \n  if num + cost[v] < M and dv + time[v] < dist[v][num+cost[v]]:\n    dist[v][num+cost[v]] = dv + time[v]\n    heappush(q, (dv+time[v], num+cost[v], v))\n    \n  for next, a, b in graph[v]:\n    if num >= a and dv+b < dist[next][num-a]:\n      dist[next][num-a] = dv+b\n      heappush(q, (dv+b, num-a, next))\n      \nfor i in range(1,N):\n  print(min(dist[i]))", "import heapq\n\n\nn, m, s = map(int, input().split())\nif s >= 2500:\n    s = 2499\n\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    from_, to, cost, time = map(int, input().split())\n    edges[from_-1].append((to-1, cost, time))\n    edges[to-1].append((from_-1, cost, time))\n\nbanks = []\nfor i in range(n):\n    coin, time = map(int, input().split())\n    banks.append((coin, time))\n\nINF = float('INF')\nDP = [[INF] * 2500 for _ in range(n)]\nans = [INF] * n\n\n\ndef push_todo(node, coin, time):\n    if coin < 0:\n        return\n    if time >= DP[node][coin]:\n        return\n    heapq.heappush(todo, (time, node, coin))\n\n\ndef charge(node, current_coin, current_time):\n    coin, time = banks[node]\n    new_coin = current_coin + coin\n    if new_coin >= 2500:\n        new_coin = 2499\n    push_todo(node, new_coin, current_time+time)\n\n\ntodo = [(0, 0, s)]\nwhile todo:\n    current_time, node, current_coin = heapq.heappop(todo)\n    if current_time >= DP[node][current_coin]:\n        continue\n\n    if current_time < ans[node]:\n        ans[node] = current_time\n\n    DP[node][current_coin] = current_time\n    charge(node, current_coin, current_time)\n\n    for to, cost, time in edges[node]:\n        push_todo(to, current_coin-cost, current_time+time)\n\nfor a in ans[1:]:\n    print(a)", "from collections import defaultdict\nimport heapq\nN,M,S = list(map(int,input().split()))\nE=[list(map(int,input().split())) for _ in range(M)]\n\nC=[list(map(int,input().split())) for _ in range(N)]\n\nA_max=max([a for _,_,a,_ in E])*N\n\nD=defaultdict(lambda :[])\n\nfor u,v,a,b in E:\n    u-=1;v-=1\n    for from_a in range(A_max+1):\n        if from_a-a<0:\n            continue\n        from_state_u=(u,from_a)\n        to_state_v=(v,from_a-a)\n        D[from_state_u].append((b,to_state_v))\n\n        from_state_v=(v,from_a)\n        to_state_u=(u,from_a-a)\n        D[from_state_v].append((b,to_state_u))\n\nfor n,[c,d] in enumerate(C):\n    for a in range(A_max+1):\n        a_after=min(A_max,a+c)\n        from_state=(n,a)\n        to_state=(n,a_after)\n        D[from_state].append((d,to_state))\n\n\nstart=(0,min(A_max,S))\nQ=[(0,start)]\n\nDist=defaultdict(lambda :float('inf'))\n\nDist[start]=0\n\nwhile Q:\n    q = heapq.heappop(Q)\n    cur_time,cur_state=q\n\n    if Dist[cur_state]<cur_time:\n        continue\n    for cost,next_state in D[cur_state]:\n        next_time = cost+cur_time\n\n        if Dist[next_state]>next_time:\n            Dist[next_state]=next_time\n            heapq.heappush(Q,(next_time,next_state))\n\nfor dest in range(1,N):\n    ans=float(\"inf\")\n    for a in range(A_max+1):\n        state=(dest,a)\n        ans=min(ans,Dist[state])\n    print(ans)\n", "import math\nimport heapq\n\nN,M,S=map(int,input().split())\n\nUs=[0]*M\nVs=[0]*M\nAs=[0]*M\nBs=[0]*M\nfor i in range(M):\n    Us[i],Vs[i],As[i],Bs[i] = map(int,input().split())\n    Us[i] -= 1\n    Vs[i] -= 1\n\n# ---\nV={}\nNs = max(As)*N\nNv=N*(Ns+1)\ncnt=0\nfor i in range(N):\n    for ns in range(Ns+1):\n        V[(i,ns)]=cnt\n        cnt+=1\n\nG=[[] for _ in range(Nv)]\n\nif S > Ns:\n    S = Ns\n\n# U <-> V\nfor _ in range(M):\n    u = Us.pop()\n    v = Vs.pop()\n    a = As.pop()\n    b = Bs.pop()\n    #\n    for i in range(Ns+1): # i = 0,..,Ns\n        ns_s = Ns - i\n        ns_g = ns_s - a\n        if ns_g >= 0:\n            # U -> V\n            G[ V[(u,ns_s)] ].append( (V[(v,ns_g)],b) )\n            # V -> U\n            G[ V[(v,ns_s)] ].append( (V[(u,ns_g)],b) )\n            #print(u,v,a,b,ns_s,ns_g,V[(u,ns_s)],V[(v,ns_g)])\n\n# -----\n\nfor i in range(N):\n    c,d = map(int,input().split())\n    for j in range(Ns): # j = 0,...,Ns-1\n        ns_s = j\n        ns_g = j + c\n        if ns_g > Ns:\n            ns_g = Ns\n        G[ V[(i,ns_s)] ].append( (V[(i,ns_g)],d) )\n\n# -----\nD=[math.inf]*Nv\nq=[]\n# -----\n\ns=V[(0,S)]\nD[s] = 0\nheapq.heappush(q,(0,s))\n\nwhile len(q) > 0:\n    p_cost,p_v = heapq.heappop(q)\n    if D[p_v] < p_cost:\n        continue\n    for e_to,e_cost in G[p_v]:\n        if D[ e_to ] > D[p_v] + e_cost:\n            D[e_to] = D[p_v] + e_cost\n            heapq.heappush(q, (D[e_to], e_to))\n\nfor i in range(1,N):\n    ans = min([D[i*(Ns+1)+v] for v in range(Ns+1)])\n    print(ans)", "from heapq import *\n\nN, M, S = list(map(int, input().split()))\n\nT = [[10**18 for _ in range(2451)] for _ in range(N)]\n\nact = [[] for _ in range(N)]\n\nfor i in range(M):\n  U, V, A, B = list(map(int, input().split()))\n  U -= 1\n  V -= 1\n  act[U] += [(V, A, B)]\n  act[V] += [(U, A, B)]\n\nfor i in range(N):\n  C, D = tuple(map(int, input().split()))\n  act[i] += [(i, -C, D)]\n\nque = [(0, 0, S)]\n\nwhile que:\n  (currentT, n, coins) = heappop(que)\n  for m, cost, t in act[n]:\n    # \u3082\u3057\u300c\u6255\u3048\u308b\u91d1\u984d\u3067\u300d\u300c\u6700\u5c0f\u6642\u9593T[\u79fb\u52d5\u5148][\u6240\u6301\u91d1]\u3092\u66f4\u65b0\u3067\u304d\u308b\u3068\u304d\u300d\u306b\u5024\u3092\u66f4\u65b0\u3001\u30ad\u30e5\u30fc\u306b\u72b6\u614b\u3092\u8ffd\u52a0\u3002\n    # \u4e21\u66ff\u306e\u7d50\u679c2450\u679a\u3092\u8d85\u3048\u308b\u306a\u30892450\u679a\u3068\u3057\u3066\u6271\u3063\u3066\u554f\u984c\u306a\u3057\u3002\n    if coins >= cost and currentT + t < T[m][min(2450, coins - cost)]:\n      T[m][min(2450, coins - cost)] = currentT + t\n      heappush(que, (currentT + t, m, min(2450, coins - cost)))\n\nfor i in range(1, N):\n  print((min(T[i])))\n", "N,M,S=map(int,input().split())\nfrom heapq import heappop,heappush \n\ninf = float('inf')\ncost=[[] for _ in range(N)]\nexc=[]\n\n\nfor _ in range(M):\n    u,v,a,b=map(int,input().split())\n    u,v=u-1,v-1\n    cost[u].append((v,a,b))\n    cost[v].append((u,a,b))\nfor _ in range(N):\n    c,d=map(int,input().split())\n    exc.append((c,d))\n\ndi=[inf]*2451*N\nif S>2450:\n    S=2450\ndi[S]=0\nhq=[(0,S)] #\u6642\u9593,\u90fd\u5e02\u540d*2451+\u9280\u8ca8\n\nwhile hq:\n    t,v=heappop(hq)\n    u=v//2451 #\u90fd\u5e02\u540d\n    s=v%2451 #\u6240\u6301\u91d1\n\n    for x,a,b in cost[u]:\n        if s>=a:\n            v_new=x*2451+s-a\n            t_new=t+b\n            if t_new<di[v_new]:\n                di[v_new]=t_new\n                heappush(hq,(t_new,v_new))\n    \n    c,d=exc[u]\n    if s+c>2450:\n        c=2450-s\n    v_new=v+c\n    t_new=t+d\n    if t_new<di[v_new]:\n        di[v_new]=t_new\n        heappush(hq,(t_new,v_new))\n\nfor i in range(1,N):\n    m=di[i*2451]\n    for j in range(1,2451):\n        m=min(m,di[i*2451+j])\n    print(m)", "# -*- coding:utf-8 -*-\n\ndef solve():\n    \"\"\"\u89e3\u8aac\u5b9f\u88c5\"\"\"\n    import sys\n    import heapq\n\n    MAX_S = 50*50\n    N, M, S = list(map(int, sys.stdin.readline().split()))\n    graph = [[] for _ in range(N)]\n\n    for _ in range(M):\n        u, v, a, b = list(map(int, sys.stdin.readline().split()))\n        u, v = u-1, v-1\n        graph[u].append((v, a, b))\n        graph[v].append((u, a, b))\n\n    ryogae = []\n    for _ in range(N):\n        c, d = list(map(int, sys.stdin.readline().split()))\n        ryogae.append((c, d))\n\n    # dp[v][s] := \u9802\u70b9v\u306b\u6240\u6301\u91d1s\u3067\u8a2a\u308c\u308b\u3068\u304d\u306e\u6700\u5c0f\u6642\u9593\n    dp = [[float(\"inf\") for _ in range(MAX_S+1)] for __ in range(N)]\n\n    # \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\n    s = min(S, MAX_S)\n    que = []\n    heapq.heappush(que, (0, 0, s))  # (\u6642\u523bt, \u9802\u70b9\u756a\u53f7v, \u6240\u6301\u91d1s)\n\n    while len(que) != 0:\n        t, v, s = heapq.heappop(que)\n\n        # if dp[v][s] != t: continue  # \u306a\u306b\u3053\u308c\uff1f\n\n        # \u4e21\u66ff\u3059\u308b\u5834\u5408\n        c, d = ryogae[v]\n        ns = min(s+c, MAX_S)\n        if dp[v][ns] > t+d:\n            dp[v][ns] = t+d\n            heapq.heappush(que, (t+d, v, ns))\n\n        # \u79fb\u52d5\u3059\u308b\u5834\u5408(v -> u\u306b\u79fb\u52d5)\n        for u, a, b in graph[v]:\n            if s-a < 0: continue\n            if dp[u][s-a] > t+b:\n                dp[u][s-a] = t+b\n                heapq.heappush(que, (t+b, u, s-a))\n\n    for v in range(1, N):\n        ans = float(\"inf\")\n        for s in range(MAX_S+1):\n            ans = min(ans, dp[v][s])\n        print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import math\n\nn,m,s = map(int,input().split())\n\nroad = []\nfor i in range(m):\n    u,v,a,b = map(int,input().split())\n    road.append([u,v,a,b])\n\nchange = []\nfor i in range(n):\n    c,d = map(int,input().split())\n    change.append([c,d])\n\ntree = [[] for _ in range(n+1)]\n\nfor i in range(m):  \n    r = road[i]\n    tree[r[0]].append([r[0],r[1],r[2],r[3]])\n    tree[r[1]].append([r[1],r[0],r[2],r[3]])\n\nleast_cost = [[] for _ in range(n+1)]\nfor l in range(n+1):\n    least_cost[l] = [math.inf]*2501\n\n\ndef insort_queue(q,v):\n    len_a = len(q)    \n    if len_a == 0:\n        q.append(v)\n        return\n    \n    min = 0\n    max_1 = len_a\n\n    if max_1 == 1:\n        if v[2] > q[0][2]:\n            min = 1\n        else:\n            min = 0\n    while max_1 - min > 1:\n        mid = (max_1 + min) //2\n        if v[2] > q[mid][2]:\n            min = mid\n        else:\n            max_1 = mid\n    index = max_1\n    q.insert(index,v)\n\nqueue = []\n\n#hwd [location, money, time]\ndef dijakstra(q):\n    while q != []:\n        hwd = q.pop(0)\n\n        if least_cost[hwd[0]][hwd[1]] > hwd[2]:\n            least_cost[hwd[0]][hwd[1]] = hwd[2]\n            \n            for node in tree[hwd[0]]:\n                # from node, to node , money, time\n                if hwd[1] - node[2] >= 0:\n                    insort_queue(q,[node[1],hwd[1]-node[2],hwd[2]+node[3]])\n            if hwd[1] + change[hwd[0]-1][0] <= 500:\n                insort_queue(q,[hwd[0],hwd[1]+change[hwd[0]-1][0],hwd[2]+change[hwd[0]-1][1]])\n    return least_cost\n\nif s > 2500:\n    s = 2500\nqueue.append([1,s,0])\n\nans = dijakstra(queue)\n\nfor i in range(2,n+1):\n    print(min(ans[i]))", "import sys\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\ninput = sys.stdin.readline\n\n\nN, M, S = map(int, input().split())\nS = min(S, 2500)\n\nrow = []    #start\ncol = []    #end\ndata = []\n\nfor _ in range(M):\n    u, v, a, b = map(int, input().split())\n    u -= 1\n    v -= 1\n    for i in range(a, 2501):\n        row.append(N * i + u)\n        col.append(N * (i - a) + v)\n        data.append(b)\n        row.append(N * i + v)\n        col.append(N * (i - a) + u)\n        data.append(b)\n\nfor u in range(N):\n    c, d = map(int, input().split())\n    for i in range(1, c):\n        row.append(N * (2500 - i) + u)\n        col.append(N * 2500 + u)\n        data.append(d)\n    for i in range(c, 2501):\n        row.append(N * (i - c) + u)\n        col.append(N * i + u)\n        data.append(d)\n\ngraph = csr_matrix((data, (row, col)), shape = (2501*N, 2501*N))\n\ntimes = dijkstra(graph, directed  = True, indices = N * S)\n\nfor end in range(1, N):\n    print(int(min(times[N * i + end] for i in range(2501))))", "import heapq\nN, M, init_silver = map(int, input().split())\nMAX_COST = 2500\ninit_silver = min(init_silver, MAX_COST)\n\nG = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, silver_cost, time_cost = map(int, input().split())\n    u, v = u - 1, v - 1\n    G[u].append([v, silver_cost, time_cost])\n    G[v].append([u, silver_cost, time_cost])\n\nchange_rate, change_cost = [], []\nfor i in range(N):\n    rate, cost = map(int, input().split())\n    G[i].append([i, -rate, cost])  # \u3053\u308c\u3092\u8ffd\u52a0\uff01\n    change_rate.append(rate)\n    change_cost.append(cost)\n\n\n# dp[i][silver] := \u9802\u70b9i\u306b\u3044\u3066\u9280\u8ca8\u3092silver\u679a\u6301\u3063\u3066\u3044\u308b\u3088\u3046\u306a\u72b6\u6cc1\u3092\u4f5c\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u6700\u5c0f\u6642\u9593\ndp = [[float('inf')] * (MAX_COST + 1) for _ in range(N)]\ndp[0][init_silver] = 0\n\n# \u512a\u5148\u5ea6\u4ed8\u304d\u30ad\u30e5\u30fc: (time, node, silver)\nhq = [(0, 0, init_silver)]\nwhile hq:\n    time, node, silver = heapq.heappop(hq)\n\n    for to, silver_cost, time_cost in G[node]:\n        remain_silver = min(silver - silver_cost, MAX_COST)\n        if remain_silver < 0:\n            continue\n\n        dp_next_value = time + time_cost\n        if dp[to][remain_silver] <= dp_next_value:\n            continue\n\n        dp[to][remain_silver] = dp_next_value\n        heapq.heappush(hq, (dp_next_value, to, remain_silver))\n\nprint(*[min(d) for d in dp[1:]], sep=\"\\n\")", "# \u30bb\u30a4\u30a6\u30c1\n\ndef main():\n    from heapq import heappush, heappop\n\n    INF = 1 << 60\n    MX_AG = 2500\n\n    N, M, S = map(int, input().split())\n    S = min(S, MX_AG)  # \u305d\u308c\u4ee5\u4e0a\u306eAg\u306f\u4e0d\u8981\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n\n    exchange = []\n    for _ in range(N):\n        c, d = map(int, input().split())\n        exchange.append((c, d))\n\n    h = [(0, S, 0)]\n\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    # time[location][r_Ag]:=minimum_time_to_reach\n\n    while h:\n        t, ag, loc = heappop(h)\n        for to, fare, dt in g[loc]:\n            if (n_Ag := ag - fare) < 0: continue\n            if time[to][n_Ag] <= (n_time := t + dt): continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n\n        if (e_Ag := ag + exchange[loc][0]) > MX_AG: continue\n        if time[loc][e_Ag] <= (e_time := t + exchange[loc][1]): continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n\n    ans = (min(time[to]) for to in range(1, N))\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,S=map(int,input().split())\nfrom heapq import heappop,heappush \n\ninf = 10**18\ncost=[[] for _ in range(N)]\nexc=[]\n\n\nfor _ in range(M):\n    u,v,a,b=map(int,input().split())\n    u,v=u-1,v-1\n    cost[u].append((v,a,b))\n    cost[v].append((u,a,b))\nfor _ in range(N):\n    c,d=map(int,input().split())\n    exc.append((c,d))\n\ndi=[inf]*2451*N\nif S>2450:\n    S=2450\ndi[S]=0\nhq=[(0,S)] #\u6642\u9593,\u90fd\u5e02\u540d*2451+\u9280\u8ca8\n\nwhile hq:\n    t,v=heappop(hq)\n    u=v//2451 #\u90fd\u5e02\u540d\n    s=v%2451 #\u6240\u6301\u91d1\n\n    for x,a,b in cost[u]:\n        if s>=a:\n            v_new=x*2451+s-a\n            t_new=t+b\n            if t_new<di[v_new]:\n                di[v_new]=t_new\n                heappush(hq,(t_new,v_new))\n    \n    c,d=exc[u]\n    if s+c>2450:\n        c=2450-s\n    v_new=v+c\n    t_new=t+d\n    if t_new<di[v_new]:\n        di[v_new]=t_new\n        heappush(hq,(t_new,v_new))\n\nfor i in range(1,N):\n    m=di[i*2451]\n    for j in range(1,2451):\n        m=min(m,di[i*2451+j])\n    print(m)", "import sys\ninput = sys.stdin.readline\ndef main():\n  n,m,s=map(int,input().split())\n  uvab=[list(map(int,input().split())) for _ in range(m)]\n  cd=[list(map(int,input().split())) for _ in range(n)]\n  g=[[]for _ in range(n)]\n  for u,v,a,b in uvab:\n    g[u-1].append((v-1,a,b))\n    g[v-1].append((u-1,a,b))\n  import heapq\n  inf=pow(10,21)\n  max_s=50*50\n  dp=[[inf]*(max_s+1)for _ in range(n)]\n  kakutei=[[0]*(max_s+1)for _ in range(n)]\n  dp[0][min(s,max_s)]=0\n  todo=[[0,0,min(s,max_s)]] # [dp[v][i],v,i]\n  heapq.heapify(todo)\n  flgs=[0]*n\n  flg=0\n  ans=[inf]*n\n  while flg<n:\n    _,v,i=heapq.heappop(todo)\n    if kakutei[v][i]==1:\n      continue\n    kakutei[v][i]=1\n    if flgs[v]==0:\n      flg+=1\n      flgs[v]=1\n    c,d=cd[v]\n    ans[v]=min(ans[v],_)\n    # \u4e21\u66ff\n    j=min(max_s,i+c)\n    if kakutei[v][j]==0:\n      dp[v][j]=min(dp[v][j],dp[v][i]+d)\n      heapq.heappush(todo,[dp[v][j],v,j])\n    # \u9244\u9053\n    l=g[v]\n    for u,a,b in l:\n      if i-a>=0 and kakutei[u][i-a]==0:\n        dp[u][i-a]=min(dp[u][i-a],dp[v][i]+b)\n        heapq.heappush(todo,[dp[u][i-a],u,i-a])\n  print(*ans[1:],sep='\\n')\ndef __starting_point():\n  main()\n\n__starting_point()", "import heapq\nimport sys\ninput = sys.stdin.readline\n\nINF = 10 ** 18\n\nclass Edge():\n    def __init__(self, end, cost, time):\n        self.end = end\n        self.cost = cost\n        self.time = time\n\ndp = []\nh = []\n\ndef push(t, v, x):\n    if x < 0:\n        return\n    if dp[v][x] <= t:\n        return\n    dp[v][x] = t\n    heapq.heappush(h, (t, v, x))\n\ndef dijkstra(n, G, cd, start, s, max_s):\n    nonlocal dp\n    dp = [[INF for j in range(max_s+1)] for i in range(n)] \n    push(0, start, s)\n\n    while h:\n        # \u4f7f\u3063\u3066\u3044\u306a\u3044\u9802\u70b9\u306e\u3046\u3061\u3001\u73fe\u6642\u70b9\u3067\u6700\u3082\u5230\u9054\u77ed\u6642\u9593\u304c\u77ed\u3044\u3082\u306e\u3092\u9078\u3073v\u3068\u3059\u308b\n        t, v, x = heapq.heappop(h)\n        if dp[v][x] < t:\n            continue\n        # \u4e21\u66ff\n        if x < max_s:\n            push(t+cd[v][1], v, min(x+cd[v][0], max_s))\n        # v\u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u5230\u9054\u6642\u9593\u304c\u77ed\u304f\u306a\u308c\u3070\u66f4\u65b0\n        for e in G[v]:\n            push(t+e.time, e.end, x-e.cost)\n\n\nn, m, s = list(map(int, input().split()))\nuvab = [list(map(int, input().split())) for _ in range(m)]\ncd = [list(map(int, input().split())) for _ in range(n)]\n\nes = [[] for i in range(n)]\nmax_s = 50 * (n-1)\n\nfor u, v, a, b in uvab:\n    es[u-1].append(Edge(v-1,a,b))\n    es[v-1].append(Edge(u-1,a,b))\n\ndijkstra(n, es, cd, 0, min(max_s,s), max_s)\n\nfor i in range(1, n):\n    print((min(dp[i])))\n\n\n", "n, m, s = map(int, input().split())\nrail = [[] for _ in range(n)]\nfare = [[] for _ in range(n)]\ntime = [[] for _ in range(n)]\nrate = []\nTIME = []\nfor _ in range(m):\n    i, j, k, l = map(int, input().split())\n    i -= 1\n    j -= 1\n    rail[i].append(j)\n    rail[j].append(i)\n    fare[i].append(k)\n    fare[j].append(k)\n    time[i].append(l)\n    time[j].append(l)\nfor _ in range(n):\n    i, j = map(int, input().split())\n    rate.append(i)\n    TIME.append(j)\n    \n# Dijkstra's algorithm\n# \u9280\u8ca8\u306e\u679a\u6570\u304climit\u4ee5\u4e0a\u306b\u306a\u3063\u305f\u3089\u6368\u3066\u308b\nlimit = [max(i) for i in fare]\nlimit = max(limit) * n\nif s >= limit:\n    s = limit - 1\n\n# dp[i][j] = \u90fd\u5e02i\u3067\u9280\u8ca8j\u679a\u3092\u6301\u3063\u3066\u3044\u308b\u305f\u3081\u306e\u5fc5\u8981\u6700\u5c0f\u6642\u9593\ndp = [[float('inf')] * limit for _ in range(n)]\n\n# candidate\u306b(\u5fc5\u8981\u6642\u9593, \u90fd\u5e02\u756a\u53f7, \u9280\u8ca8\u306e\u679a\u6570)\u3092\u8ffd\u52a0\u3057\u3066\u3044\u304f\nimport heapq\ncandidate = [(0, 0, s)]\nheapq.heapify(candidate)\n\nans = [-1] * n\ntodo = n\n\nwhile todo > 0:\n    i, j, k = heapq.heappop(candidate)\n    if dp[j][k] != float('inf'):\n        continue\n    dp[j][k] = i\n    if ans[j] == -1:\n        ans[j] = i\n        todo -= 1\n\n    # \u9244\u9053\u79fb\u52d5\u3092candidate\u306b\u8ffd\u52a0\n    for l in range(len(rail[j])):\n        if fare[j][l] <= k and dp[rail[j][l]][k - fare[j][l]] == float('inf'):\n            heapq.heappush(candidate, (i + time[j][l], rail[j][l], k - fare[j][l]))\n    \n    # \u4e21\u66ff\u3092candidate\u306b\u8ffd\u52a0\n    if k < limit - 1:\n        heapq.heappush(candidate, (i + TIME[j], j, min([k + rate[j], limit - 1])))\n\nfor i in range(1, n):\n    print(ans[i])", "import heapq\n\n\nn, m, s = list(map(int, input().split()))\nif s >= 2500:\n    s = 2499\n\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    from_, to, cost, time = list(map(int, input().split()))\n    edges[from_-1].append((to-1, cost, time))\n    edges[to-1].append((from_-1, cost, time))\n\nbanks = [(0, 0) for _ in range(n)]\nfor i in range(n):\n    coin, time = list(map(int, input().split()))\n    banks[i] = (coin, time)\n\nINF = float('INF')\nDP = [INF] * (n * 2500)\nans = [INF] * n\n\n\ndef to_one_dimension(node, coin):\n    return node * 2500 + coin\n\n\ndef push_todo(node, coin, time):\n    if coin < 0:\n        return\n    if time >= DP[to_one_dimension(node, coin)]:\n        return\n    heapq.heappush(todo, (time, node, coin))\n\n\ndef charge(node, current_coin, current_time):\n    coin, time = banks[node]\n    new_coin = current_coin + coin\n    if new_coin >= 2500:\n        new_coin = 2499\n    push_todo(node, new_coin, current_time+time)\n\n\ntodo = [(0, 0, s)]\nwhile todo:\n    current_time, node, current_coin = heapq.heappop(todo)\n    if current_time < ans[node]:\n        ans[node] = current_time\n\n    one_d_idx = to_one_dimension(node, current_coin)\n    if current_time >= DP[one_d_idx]:\n        continue\n\n    DP[one_d_idx] = current_time\n    charge(node, current_coin, current_time)\n\n    for to, cost, time in edges[node]:\n        push_todo(to, current_coin-cost, current_time+time)\n\nfor a in ans[1:]:\n    print(a)\n", "import sys\n# sys.setrecursionlimit(10**7)  # \u30cd\u30b9\u30c8\u56de\u6570\u5236\u9650\uff08\u3044\u308b\uff1f\uff09\n\n# \u5165\u529b\u5024\u3092\u6271\u3044\u3084\u3059\u3044\u5f62\u3067\u683c\u7d0d\u3057\u3066\u3044\u304f\n\n# input=sys.stdin.buffer.readline  # input \u306e\u9ad8\u901f\u5316\uff08\u4eca\u56de\u306f\u5916\u3059\uff09\n\nN, M, S = map(int,input().split())  # \u9802\u70b9\u6570\uff0f\u8fba\u6570\uff0f\u521d\u671f\u6240\u6301\u91d1(state)\nS=min(S,2500)  # \u9ad8\u3005 2500 \u3042\u308c\u3070\u826f\u3044\uff08\u5168\u90fd\u5e02\u3092\u56de\u308b\u306e\u306b\u6255\u3044\u304d\u308c\u308b\u56de\u6570\uff09\n\nINF=10**18\ndp = [[INF]*2501 for _ in range(N)]\nway=[[]for _ in range(N)]\n\nfor _ in range(M):\n    u,v,a,b=map(int,input().split())\n    way[u-1].append((v-1,a,b))\n    way[v-1].append((u-1,a,b))\n\n# \u4e21\u66ff\u6bd4\u7387\u3068\u6642\u9593\n# CD = [list(map(int,input().split())) for _ in range(N)]  # list\u5316\u3059\u308b\u610f\u5473\u306f\uff1f\nCD = [tuple(map(int,input().split())) for _ in range(N)]\n\nfrom heapq import heappush,heappop\n\n# q \u306f \u6642\u9593\uff0f\u90fd\u5e02\u540d\uff0f\u6240\u6301\u91d1\u3000\u306e\u9806\u756a <- \u6642\u9593\u3092\u30ad\u30fc\u306b heapq \u3092\u4f7f\u3046\u305f\u3081\n\nq=[(0,0,S)]  # \u30b9\u30bf\u30fc\u30c8\u72b6\u614b\n\nwhile q:\n    t, u, s = heappop(q)  # \u6700\u3082\u5230\u7740\u6642\u9593\u306e\u77ed\u3044\u90fd\u5e02 u \u3092\u9078\u629e\n    for nxt, a, b in way[u]:  # u \u304b\u3089\u305f\u3069\u308a\u7740\u3051\u308b\u90fd\u5e02 nxt \u306b\u5bfe\u3057\u3066\n        if s >= a:  # \u4ea4\u901a\u8cbb\u304c\u3042\u308b\u5834\u5408\n\n            if dp[nxt][s-a] > t + b:  # \u5230\u7740\u6642\u9593\u3092\u691c\u8a0e\n                dp[nxt][s-a] = t + b  # \u65e9\u3044\u306e\u3067\u66f8\u304d\u63db\u3048\n                heappush(q,(t + b, nxt, s-a))  #  \u30ad\u30e5\u30fc\u306b\u6b21\u306e\u90fd\u5e02\u5019\u88dc\u3068\u3057\u3066\u767b\u9332\u3057\u3066\u304a\u304f\n                # \u540c\u3058\u90fd\u5e02 & \u540c\u3058\u91d1\u984d \u304c\u8907\u6570\u500b\u767b\u9332\u3055\u308c\u306a\u3044\u304b\uff1f \u8a08\u7b97\u56de\u6570\u306f\n                # \u66f4\u65b0\u3055\u308c\u305f = \u5468\u56f2\u306e\u90fd\u5e02\uff08\u70b9\uff09\u306b\u305f\u3069\u308a\u7740\u304f\u5024\u3092\u66f4\u65b0\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\u304b\u3082\u3057\u308c\u306a\u3044\u304b\u3089\n                # \u691c\u8a0e\u5bfe\u8c61\u306b\u306a\u308b\n\n        # \u3053\u306e\u6642\u70b9\u3067\u306f\u3001u \u306b\u3044\u3066\u3001\u6240\u6301\u91d1 s \u3067\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u3068\u3057\u3066\u306f\u307e\u3060\u66f4\u65b0\u3055\u308c\u3066\u3044\u306a\u3044\n                \n    c, d = CD[u]\n    nc = min(2500, c + s)  # \u6240\u6301\u91d1\u3092\u5897\u3084\u3059\n    nt= t + d  # \u6642\u9593\u3082\u639b\u304b\u308b\n\n    if nt < dp[u][nc]:  # \u4ea4\u63db\u5f8c\u306e\u91d1\u984d\u3068\u6642\u9593\u3092\u898b\u3066\u3001\u66f4\u65b0\u3059\u308b\uff08\u7121\u9650\u5927\u3060\u3051\u304c\u66f4\u65b0\u306b\u306a\u308b\uff1f\uff09\n        dp[u][nc] = nt\n        heappush(q, (nt, u, nc))  # \u540c\u3058\u90fd\u5e02\uff08\u70b9\uff09\u3060\u304c\u3001\u9055\u3046\u72b6\u614b\u304c\u767b\u9332\u3055\u308c\u3066\u3044\u308b\n\nfor i in range(1,N):\n    print(min(dp[i]))", "#\u62e1\u5f35\u30c0\u30a4\u30af\u30b9\u30c8\u30e9 \n#weight,point\nN,M,S=map(int,input().split())\ngraph={(i,j):[] for i in range(1,51) for j in range(2501)}\nfor _ in range(M):\n    u,v,a,b=map(int,input().split())\n    for i in range(a,2501):\n        graph[(u,i)].append((b,(v,i-a)))\n        graph[(v,i)].append((b,(u,i-a)))\nfor i in range(N):\n    c,d=map(int,input().split())\n    for j in range(2501):\n        graph[(i+1,j)].append((d,(i+1,min(2500,j+c))))\n\ndist={(i,j):float(\"inf\")  for i in range(1,51) for j in range(2501)}\n\ndist[(1,min(2500,S))]=0\npq=[]\nimport heapq\nheapq.heapify(pq)\nheapq.heappush(pq,(0,(1,min(2500,S))))\nwhile pq:\n    mini_dis,node=heapq.heappop(pq)\n    if dist[node]<mini_dis: continue\n    for w,point in graph[node]:\n        if dist[point]<w:continue\n        newlen=dist[node]+w\n        if newlen<dist[point]:\n            heapq.heappush(pq,(newlen,point))\n            dist[point]=newlen\nfor i in range(2,N+1):\n    ans=10**20\n    for j in range(2501):\n        ans=min(ans,dist[(i,j)])\n    print(ans)", "def main():\n    import dataclasses\n    from heapq import heappush, heappop\n\n    @dataclasses.dataclass(frozen=True)\n    class Path:\n        to: int\n        fare: int\n        travel_time: int\n\n    @dataclasses.dataclass(frozen=True)\n    class ExchangeRate:\n        Ag: int\n        exchange_time: int\n\n    @dataclasses.dataclass(frozen=True)\n    class Traveler:\n        consumption_time: int\n        remaining_Ag: int\n        location: int\n\n        def __gt__(self, other):\n            return self.consumption_time > other.consumption_time\n\n        def __eq__(self, other):\n            return self.consumption_time == other.consumption_time\n\n    INF = 1 << 60\n    MX_AG = 2500\n\n    N, M, S = list(map(int, input().split()))\n    S = min(S, MX_AG)  # \u305d\u308c\u4ee5\u4e0a\u306eAg\u306f\u4e0d\u8981\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        u, v, a, b = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        g[u].add(Path(v, a, b))\n        g[v].add(Path(u, a, b))\n\n    exchange = []\n    for _ in range(N):\n        c, d = list(map(int, input().split()))\n        exchange.append(ExchangeRate(c, d))\n\n    h = [Traveler(0, S, 0)]\n\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    # time[location][r_Ag]:=minimum_time_to_reach\n\n    while h:\n        t = heappop(h)\n        for p in g[t.location]:\n            n_Ag = t.remaining_Ag - p.fare\n            if n_Ag < 0: continue\n            cf = time[p.to][n_Ag]\n            n_time = t.consumption_time + p.travel_time\n            if cf <= n_time: continue\n            time[p.to][n_Ag] = n_time\n            heappush(h, Traveler(consumption_time=n_time, remaining_Ag=n_Ag, location=p.to))\n\n        e_time = t.consumption_time + exchange[t.location].exchange_time\n        e_Ag = t.remaining_Ag + exchange[t.location].Ag\n        if e_Ag > MX_AG: continue\n        cf = time[t.location][e_Ag]\n        if cf <= e_time: continue\n        time[t.location][e_Ag] = e_time\n        heappush(h, Traveler(consumption_time=e_time, remaining_Ag=e_Ag, location=t.location))\n\n    for to in range(1, N):\n        print((min(time[to])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n# \u9280\u8ca8\u3092\u4f55\u679a\u6301\u3063\u3066\u3044\u308b\u304b\u306e\u72b6\u614b\u6570\u3001N*2501\u306e\u90fd\u5e02, dijkstra\nN, M, S = lr()\nlimit = 2500\nS = min(S, limit)\ngraph = [[] for _ in range((N+1) * (limit+1))]  # 1-indexed\nfor _ in range(M):\n    u, v, a, b = lr()\n    for x in range(a, limit+1):\n        graph[u*(limit+1) + x].append(((v*(limit+1)+x-a), b))\n        graph[v*(limit+1) + x].append(((u*(limit+1)+x-a), b))\n\nfor i in range(N):\n    i += 1\n    c, d = lr()\n    for x in range(limit-c+1):\n        graph[i*(limit+1) + x].append((i*(limit+1) + x + c, d))\n\ndef dijkstra(start):\n    INF = 10 ** 15\n    dist = [INF] * ((N+1) * (limit+1))\n    dist[start] = 0\n    que = [(0, start)]\n    while que:\n        d, prev = heappop(que)\n        if dist[prev] < d:\n            continue\n        for next, time in graph[prev]:\n            d1 = d + time\n            if dist[next] > d1:\n                dist[next] = d1\n                heappush(que, (d1, next))\n    return dist\n\ndist = dijkstra(1*(limit+1)+S)\nfor i in range(2, N+1):\n    answer = min(dist[i*(limit+1):(i+1)*(limit+1)])\n    print(answer)\n", "n,m,s=list(map(int,input().split()))\n\n# \u6240\u6301\u9280\u304c2500\u8d85\u3048\u305f\u3089\u30012500\u306b\u306a\u308b\u307e\u3067\u9280\u8ca8\u6368\u3066\u308b\n# 2500\u679a\u4ee5\u4e0a\u306eDP\u8868\u3092\u4f5c\u308b\u3068\u3001\u304b\u306a\u308a\u306e\u30e1\u30e2\u30ea\u6d88\u8cbb\u3059\u308b\u3057\u3001\u3053\u306e\u30b1\u30fc\u30b9\u3067\u306f2500\u679a\u3042\u308c\u3070\u3069\u3053\u3067\u3082\u884c\u3051\u308b\u306e\u3067\u610f\u5473\u306a\u3044\ns=min(s,2500)\n\n# 2501\u00d7n\u306e[]\u884c\u5217\n# 0~2500\u679a \u00d7 \u9802\u70b9\u6570\nedge=[[[] for i in range(50*50+1)] for i in range(n)]\n\n# (\u9802\u70b9, \u30b3\u30b9\u30c8)\u2192(\u9802\u70b9, \u30b3\u30b9\u30c8)\u3078\u8fba\u3092\u6e21\u3063\u3066\u306e\u9077\u79fb\uff08\u9802\u70b9\u304c\u5909\u308f\u308b\uff09\n# u,v,a,b\u304c\u4e0e\u3048\u3089\u308c\u308b\u305f\u3073\u306b\u3001edge\u3092\u66f4\u65b0\nfor i in range(m):\n    u,v,a,b=list(map(int,input().split()))\n    \n    # j\u306f\u3001\u4fdd\u6709\u9280\u8ca8\u679a\u6570\n    # j:a\u21922500\u306a\u306e\u306f\u3001j\u304ca\u672a\u6e80\u3067\u3042\u308c\u3070\u3001\u96a3\u306e\u9802\u70b9\u306b\u884c\u3051\u306a\u3044\u304b\u3089\n    for j in range(a,2501):\n        edge[u-1][j].append((v-1,j-a,b))\n        edge[v-1][j].append((u-1,j-a,b))\n        \n# (\u9802\u70b9, \u30b3\u30b9\u30c8)\u2192(\u9802\u70b9, \u30b3\u30b9\u30c8)\u3078\u3001\u305d\u306e\u9802\u70b9\u306b\u7559\u307e\u3063\u3066\u4e21\u66ff\u306e\u9077\u79fb\uff08\u9802\u70b9\u5909\u308f\u3089\u306a\u3044\uff09\n# c,d\u304c\u4e0e\u3048\u3089\u308c\u308b\u305f\u3073\u306b\u3001edge\u3092\u66f4\u65b0\nfor i in range(n):\n    c,d=list(map(int,input().split()))\n      \n    # \u9280\u8ca8\u3092\u6368\u3066\u308b\u306e\u306f\u30ce\u30fc\u30b3\u30b9\u30c8\n    # 2500\u679a\u4ee5\u4e0a\u6301\u3063\u3066\u305f\u3089\u30012500\u679a\u6301\u3063\u3066\u308b\u3053\u3068\u3068\u540c\u5024\u3068\u8003\u3048\u308b\n    # range(2501)\u306b\u3057\u306a\u3044\u7406\u7531\u306f\u30012500\u679a\u3042\u3063\u305f\u3089\u3001\u4e21\u66ff\u306f\u3057\u306a\u3044\u304b\u3089\n    for j in range(2500):\n        if j+c>=2500:\n            edge[i][j].append((i,2500,d))\n        elif j+c<2500:\n            edge[i][j].append((i,j+c,d))\n        \nfrom heapq import heappush,heappop,heapify\n\n# d\u306fn\u00d72501\u306e\u3059\u3079\u3066\u306e\u72b6\u614b\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\u306e\u8868\nd=[[float('inf')  for i in range(50*50+1)] for i in range(n)]\n\n# \u521d\u671f\u5024\u3002\u9802\u70b90, \u9280\u8ca8S\u306b\u306f\u3001\u30b3\u30b9\u30c80\u3067\u5230\u9054\nd[0][s]=0\n\npq = []\nheappush(pq,(0,0,s))\n\nwhile len(pq):\n    # [\u30b3\u30b9\u30c8, \u9802\u70b9, \u9280\u8ca8\u6570]\u3067\u3001\u30b3\u30b9\u30c8\u3092key\u3068\u3057\u3066\u3001heap\u30bd\u30fc\u30c8\u3057\u3066\u3001\u4e00\u756a\u30b3\u30b9\u30c8\u304c\u4f4e\u3044\u30ea\u30b9\u30c8\u3092\u5148\u982d\u306b\u6301\u3063\u3066\u304f\u308b\n    _,u,g = heappop(pq)\n    \n    # \u9802\u70b9\u307e\u3067\u306e\u30b3\u30b9\u30c8\u304c\u66f4\u65b0\u3067\u304d\u308c\u3070\u66f4\u65b0\u3057\u3066\u30d2\u30fc\u30d7\u306b\u767b\u9332\n    # edge[u][g]\u306f\u3001\u9802\u70b9u, \u9280\u8ca8g\u679a\u306e\u72b6\u614b\u304b\u3089\u3001\u884c\u3051\u308b\u72b6\u614b\u306etuple(\u9802\u70b9, \u9280\u8ca8\u6570, \u30b3\u30b9\u30c8)\u3092\u547c\u3073\u51fa\u3059\n    # pq\u306b\u306f\u3001[\u30b3\u30b9\u30c8, \u9802\u70b9, \u9280\u8ca8\u6570]\u306e\u9806\u3067\u5165\u308c\u3066\u3044\u308b\n    for tuple in edge[u][g]:\n        if d[tuple[0]][tuple[1]]>d[u][g]+tuple[2]:\n            d[tuple[0]][tuple[1]]=d[u][g]+tuple[2]\n            heappush(pq,[d[u][g]+tuple[2],tuple[0],tuple[1]])\n        \n# d[i]\u3067\u3001\u9802\u70b9i\u306b\u304a\u3051\u308b\u4fdd\u6709\u9280\u8ca8\u6570\u306b\u5fdc\u3058\u305f\u30b3\u30b9\u30c8\u304c\u5165\u3063\u305f\u30ea\u30b9\u30c8\u3092\u547c\u3073\u51fa\u305b\u308b\n# \u30ea\u30b9\u30c8\u306e\u4e2d\u3067\u3001\u4e00\u756a\u5c0f\u3055\u3044\u30b3\u30b9\u30c8\u306e\u3084\u3064\u3092\u547c\u3073\u51fa\u305b\u3070\u3001\u305d\u306e\u9802\u70b9\u306b\u884c\u3051\u308b\u6700\u5c0f\u30b3\u30b9\u30c8\u3068\u540c\u5024\u3067\u3042\u308b\nfor i in range(1,n):\n    print((min(d[i])))\n", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\n\n\nclass Heap():\n    def __init__(self, ):\n        self.h = []\n\n    def heapify(self, h):\n        self.h = h\n        heapify(self.h)\n\n    def heappop(self,):\n        return heappop(self.h)\n\n    def heappush(self, x):\n        heappush(self.h, x)\n\n\nN, M, S = list(map(int, input().split()))\nINF = 10**100\nG = [[] for _ in [0]*N]\nC = []\n\nfor _ in [0]*M:\n    u, v, a, b = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    G[v].append((u, a, b))\n    G[u].append((v, a, b))\n\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    C.append((a, b))\n\n\ndef push(t, s, v):\n    if s < 0:\n        return\n    if s >= MAX:\n        s = MAX-1\n    if dp[v][s] <= t:\n        return\n    dp[v][s] = t\n    heappush(q, (t, s, v))\n\n\nMAX = 2500\nS = min(S, MAX)\ndp = [[INF]*MAX for _ in [0]*N]\n\nq = []\npush(0, S, 0)\n\nwhile q:\n    t, s, v = heappop(q)\n    if dp[v][s] != t:\n        continue\n\n    c, d = C[v]\n    push(t+d, s+c, v)\n\n    for u, a, b in G[v]:\n        push(t+b, s-a, u)\n\nfor d in dp[1:]:\n    ans = INF\n    for s in range(MAX):\n        if ans > d[s]:\n            ans = d[s]\n    print(ans)\n", "import heapq\n\nn,m,s=list(map(int,input().split()))\nlimit=2500\ns=min(s,limit)\npath=[[] for _ in range(n+1)]\ncoin=[(0,0)]\ntime=[[float(\"inf\") for _ in range(limit+1)] for _ in range(n+1)]\nqueue=[]\n\nfor i in range(m):\n    u,v,a,b=list(map(int,input().split()))\n    path[u].append((v,a,b))\n    path[v].append((u,a,b))\n\nfor i in range(n):\n    c,d=list(map(int,input().split()))\n    coin.append((c,d))\n\ntime[1][s]=0\nheapq.heappush(queue,(0,1,s))\n\nwhile len(queue)!=0:\n    t,v,c=heapq.heappop(queue)\n    for nv,na,nb in path[v]:\n        if na>c:\n            continue\n        elif time[nv][c-na]<=t+nb:\n            continue\n        else:\n            time[nv][c-na]=t+nb\n            heapq.heappush(queue,(t+nb,nv,c-na))\n\n    nc=min(c+coin[v][0],limit)\n    nt=t+coin[v][1]\n    if time[v][nc]<=nt:\n        continue\n    else:\n        time[v][nc]=nt\n        heapq.heappush(queue,(nt,v,nc))\n    \nfor i in range(2,n+1):\n    print((min(time[i])))\n", "n, m, s = list(map(int, input().split()))\n\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, a, b = list(map(int, input().split()))\n    u, v = u-1, v-1\n    edges[u].append((v, a, b))\n    edges[v].append((u, a, b))\n\nbanks = tuple(tuple(map(int, input().split())) for _ in range(n))\n\nmax_s = 50 * (n-1)\n\ns = min(s, max_s)\n\nimport heapq\n\nh = []\ndp = [[float('inf')] * (max_s+1) for _ in range(n)]\nans = [float('inf')] * n\n\nheapq.heappush(h, (0, 0, s))\nwhile h:\n    time, node, coin = heapq.heappop(h)\n    if time >= dp[node][coin]:\n        continue\n    dp[node][coin] = time\n    if time < ans[node]:\n        ans[node] = time\n\n    c, d = banks[node]\n    if coin < max_s:\n        heapq.heappush(h, (time+d, node, min(coin + c, max_s)))\n\n    for n, a, b in edges[node]:\n        new_time = time + b\n        new_coin = coin - a\n        if new_coin < 0 or new_time >= dp[n][new_coin]:\n            continue\n        heapq.heappush(h, (new_time, n, new_coin))\n\nfor a in ans[1:]:\n    print(a)\n", "import sys\nfrom heapq import *\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m, s = list(map(int, input().split()))\n    \n    s = min(s, 2500)\n    \n    railway = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, a, b = list(map(int, input().split()))\n        railway[u-1].append((v-1, a, b))\n        railway[v-1].append((u-1, a, b))\n    \n    exchange = [None]*n\n    for i in range(n):\n        exchange[i] = tuple(map(int, input().split()))\n    \n    \n    judge = [(0, 0, s)]\n    heapify(judge)\n    time = [[-1]*2501 for _ in range(n+1)]*n\n    \n    while judge:\n        t, now, money = heappop(judge)\n        if time[now][money] == -1:\n            time[now][money] = t\n        elif time[now][money] <= t:\n            continue\n        else:\n            time[now][money] = min(time[now][money], t)\n        \n        if money < 2500:\n            c, d = exchange[now]\n            if time[now][min(2500, money+c)] == -1:\n                heappush(judge, (t+d, now, min(2500, money+c)))\n        for (v, a, b) in railway[now]:\n            if money-a < 0:\n                continue\n            if time[v][money-a] == -1:\n                heappush(judge, (t+b, v, money-a))\n    \n    for i in range(1, n):\n        print((min(time[i])))\n    \n    \ndef __starting_point():\n    main()\n\n__starting_point()", "n,m,s=list(map(int,input().split()))\ns=min(s,2500)\n\n# 2501\u00d7n\u306e[]\u884c\u5217\n# 0~2500\u679a \u00d7 \u9802\u70b9\u6570\nedge=[[[] for i in range(50*50+1)] for i in range(n)]\n\n# (\u9802\u70b9, \u30b3\u30b9\u30c8)\u2192(\u9802\u70b9, \u30b3\u30b9\u30c8)\u3078\u8fba\u3092\u6e21\u3063\u3066\u306e\u9077\u79fb\uff08\u9802\u70b9\u304c\u5909\u308f\u308b\uff09\n# u,v,a,b\u304c\u4e0e\u3048\u3089\u308c\u308b\u305f\u3073\u306b\u3001edge\u3092\u66f4\u65b0\nfor i in range(m):\n    u,v,a,b=list(map(int,input().split()))\n    \n    # j\u306f\u3001\u4fdd\u6709\u9280\u8ca8\u679a\u6570\n    # j:a\u21922500\u306a\u306e\u306f\u3001j\u304ca\u672a\u6e80\u3067\u3042\u308c\u3070\u3001\u96a3\u306e\u9802\u70b9\u306b\u884c\u3051\u306a\u3044\u304b\u3089\n    for j in range(a,2501):\n        edge[u-1][j].append((v-1,j-a,b))\n        edge[v-1][j].append((u-1,j-a,b))\n\n# (\u9802\u70b9, \u30b3\u30b9\u30c8)\u2192(\u9802\u70b9, \u30b3\u30b9\u30c8)\u3078\u3001\u305d\u306e\u9802\u70b9\u306b\u7559\u307e\u3063\u3066\u4e21\u66ff\u306e\u9077\u79fb\uff08\u9802\u70b9\u5909\u308f\u3089\u306a\u3044\uff09\n# c,d\u304c\u4e0e\u3048\u3089\u308c\u308b\u305f\u3073\u306b\u3001edge\u3092\u66f4\u65b0\nfor i in range(n):\n    c,d=list(map(int,input().split()))\n      \n    # \u9280\u8ca8\u3092\u6368\u3066\u308b\u306e\u306f\u30ce\u30fc\u30b3\u30b9\u30c8\n    # 2500\u679a\u4ee5\u4e0a\u6301\u3063\u3066\u305f\u3089\u30012500\u679a\u6301\u3063\u3066\u308b\u3053\u3068\u3068\u540c\u5024\u3068\u8003\u3048\u308b\n    for j in range(2500):\n        if j+c>=2500:\n            edge[i][j].append((i,2500,d))\n        elif j+c<2500:\n            edge[i][j].append((i,j+c,d))\n        \nfrom heapq import heappush,heappop,heapify\n\n# d\u306fn\u00d72501\u306e\u3059\u3079\u3066\u306e\u72b6\u614b\u306e\u6700\u5c0f\u30b3\u30b9\u30c8\u306e\u8868\nd=[[float('inf')  for i in range(50*50+1)] for i in range(n)]\n\n# \u521d\u671f\u5024\u3002\u9802\u70b90, \u9280\u8ca8S\u306b\u306f\u3001\u30b3\u30b9\u30c80\u3067\u5230\u9054\nd[0][s]=0\n\npq = []\nheappush(pq,(0,0,s))\n\nwhile len(pq):\n    # [\u30b3\u30b9\u30c8, \u9802\u70b9, \u9280\u8ca8\u6570]\u3067\u3001\u30b3\u30b9\u30c8\u3092key\u3068\u3057\u3066\u3001heap\u30bd\u30fc\u30c8\u3057\u3066\u3001\u4e00\u756a\u30b3\u30b9\u30c8\u304c\u4f4e\u3044\u30ea\u30b9\u30c8\u3092\u5148\u982d\u306b\u6301\u3063\u3066\u304f\u308b\n    _,u,g = heappop(pq)\n    \n    # \u9802\u70b9\u307e\u3067\u306e\u30b3\u30b9\u30c8\u304c\u66f4\u65b0\u3067\u304d\u308c\u3070\u66f4\u65b0\u3057\u3066\u30d2\u30fc\u30d7\u306b\u767b\u9332\n    # edge[u][g]\u306f\u3001\u9802\u70b9u, \u9280\u8ca8g\u679a\u306e\u72b6\u614b\u304b\u3089\u3001\u884c\u3051\u308b\u72b6\u614b\u306etuple(\u9802\u70b9, \u9280\u8ca8\u6570, \u30b3\u30b9\u30c8)\u3092\u547c\u3073\u51fa\u3059\n    # pq\u306b\u306f\u3001[\u30b3\u30b9\u30c8, \u9802\u70b9, \u9280\u8ca8\u6570]\u306e\u9806\u3067\u5165\u308c\u3066\u3044\u308b\n    for tuple in edge[u][g]:\n        if d[tuple[0]][tuple[1]]>d[u][g]+tuple[2]:\n            d[tuple[0]][tuple[1]]=d[u][g]+tuple[2]\n            heappush(pq,[d[u][g]+tuple[2],tuple[0],tuple[1]])\n            \n# d[i]\u3067\u3001\u9802\u70b9i\u306b\u304a\u3051\u308b\u4fdd\u6709\u9280\u8ca8\u6570\u306b\u5fdc\u3058\u305f\u30b3\u30b9\u30c8\u304c\u5165\u3063\u305f\u30ea\u30b9\u30c8\u3092\u547c\u3073\u51fa\u305b\u308b\n# \u30ea\u30b9\u30c8\u306e\u4e2d\u3067\u3001\u4e00\u756a\u5c0f\u3055\u3044\u30b3\u30b9\u30c8\u306e\u3084\u3064\u3092\u547c\u3073\u51fa\u305b\u3070\u3001\u305d\u306e\u9802\u70b9\u306b\u884c\u3051\u308b\u6700\u5c0f\u30b3\u30b9\u30c8\u3068\u540c\u5024\u3067\u3042\u308b\nfor i in range(1,n):\n    print((min(d[i])))\n", "# \u30c0\u30a4\u30af\u30b9\u30c8\u30e9\ndef main():\n    import sys\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    from heapq import heappush, heappop\n\n    N, M, S = map(int, input().split())\n    S = min(S, 2500)\n    graph = [[] for _ in range(N)]\n\n    for u, v, a, b in (map(int, input().split()) for _ in range(M)):\n        graph[u-1].append((v-1, a, b))\n        graph[v-1].append((u-1, a, b))\n\n    for i, (c, d) in enumerate(map(int, input().split()) for _ in range(N)):\n        graph[i].append((i, -c, d))\n\n    hq = [(0, 0, S)]\n    INF = 10**18\n    # dp[v][silver]\n    # \u90fd\u5e02v\u306bsilver\u3092\u4f7f\u3063\u3066\u5230\u9054\u3057\u305f\u3068\u304d\u306e\u6642\u9593\u306e\u6700\u5c0f\u5024\n    dp = [[INF]*2501 for _ in range(N)]\n    dp[0][S] = 0\n\n    while hq:\n        time, v, silver = heappop(hq)\n        if dp[v][silver] < time:\n            continue\n\n        for dest, a, b in graph[v]:\n            next_s = silver-a if silver-a < 2500 else 2500\n            if next_s < 0 or dp[dest][next_s] <= time+b:\n                continue\n            for i in range(next_s, -1, -1):\n                if dp[dest][i] > time+b:\n                    dp[dest][i] = time+b\n                else:\n                    break\n            heappush(hq, (time+b, dest, next_s))\n\n    print(*(min(dp[i]) for i in range(1, N)), sep='\\n')\n\nmain()\n\n", "from heapq import *\n\nn, m, s = map(int, input().split())\ns = min([s, 50*n])\ntree = [[] for _i in range(n+1)]\nfor _i in range(m):\n    u, v, a, b = map(int, input().split())\n    tree[u].append([v, a, b])\n    tree[v].append([u, a, b])\n\ncd = [[0,0]]\nfor _i in range(n):\n    cd.append(list(map(int, input().split())))\n\ndp = [[float('inf') for _i in range(50*n+1)] for _j in range(n+1)]\nhq = [[0, 1, s]]\ndp[1][s] = 0\nheapify(hq)\nwhile hq:\n    t, p, g = heappop(hq)\n    if g+cd[p][0] <= 50*n:\n        x, y = t+cd[p][1], min([g+cd[p][0], 50*n])\n        if dp[p][y] > x:\n            dp[p][y] = x\n            heappush(hq, [x, p, y])\n    for x, y, z in tree[p]:\n        if g-y >= 0 and dp[x][g-y] > t+z:\n            dp[x][g-y] = t+z\n            heappush(hq, [t+z, x, g-y])\n\nfor i in dp[2:]:\n    print(min(i))", "# \u89e3\u8aac\u3068\u63d0\u51fa#12551970\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# \u4eca\u3044\u308b\u90fd\u5e02\u3068\u9280\u8ca8\u306e\u6240\u6301\u6570\u3092\u72b6\u614b\u3068\u3057\u3066\u3001\n#   \u2460\u305d\u306e\u90fd\u5e02\u304b\u3089\u79fb\u52d5\u53ef\u80fd\u306a\u5225\u306e\u90fd\u5e02\u306b\u79fb\u52d5\u3059\u308b\n#   \u2461\u91d1\u8ca8\u3092\u9280\u8ca8\u306b\u4ea4\u63db\u3059\u308b\n# \u306e\u3069\u3061\u3089\u304b\u3092\u884c\u3044\u3001\u5b9f\u65bd\u5f8c\u306e(\u540c\u90fd\u5e02\u30fb\u540c\u6240\u6301\u9280\u8ca8\u679a\u6570\u3067\u306e)\u6700\u5c0f\u6642\u9593\u3092\u8a08\u6e2c\u3057\u3066\u3044\u304f\u3002\n# \u6700\u5c0f\u6642\u9593\u304c\u66f4\u65b0\u3055\u308c\u305f\u5834\u5408\u3001\u3055\u3089\u306b\u305d\u306e\u72b6\u614b\u304b\u3089\u2460\u30fb\u2461\u3092\u884c\u3046\u3002\n# \u3053\u308c\u306b\u3088\u3063\u3066\u5168\u90fd\u5e02\u30fb\u5168\u9280\u8ca8\u6240\u6301\u679a\u6570\u6bce\u306e\u6700\u5c0f\u6642\u9593\u3092\u5272\u308a\u51fa\u3059\u3002\n# \u90fd\u5e02\u306e\u9280\u8ca8\u6240\u6301\u679a\u6570\u6bce\u306e\u6700\u5c0f\u6642\u9593\u306e\u4e2d\u3067\u306e\u6700\u5c0f\u6642\u9593\u304c\u305d\u306e\u90fd\u5e02\u3078\u884c\u304f\u305f\u3081\u306e\u6700\u5c0f\u6642\u9593\u306b\u306a\u308b\u3002\n#   \u203b1: \u90fd\u5e02\u3078\u306e\u79fb\u52d5\u306f\u79fb\u52d5\u53ef\u80fd\u306a\u679a\u6570\u306e\u9280\u8ca8\u3092\u6301\u3063\u3066\u3044\u308b\u5834\u5408\u306e\u307f\u53ef\u80fd\n#   \u203b2: \u9280\u8ca8\u306e\u6700\u5927\u6240\u6301\u679a\u6570\u306f (N - 1) * max(Ai) \u3068\u3059\u308b\n#        -> \u4e00\u756a\u9060\u3044\u90fd\u5e02\u306b\u79fb\u52d5\u3059\u308b\u5834\u5408\u306b\u304b\u304b\u308a\u3046\u308b\u6700\u5927\u306e\u9280\u8ca8\u679a\u6570\n\nfrom heapq import heappop, heappush\n\n\ndef solve():\n    n, m, s = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    # \u30b0\u30e9\u30d5\u4f5c\u88fd\n    max_a = 0\n    for _ in range(m):\n        u, v, a, b = list(map(int, input().split()))\n        graph[u - 1].append([v - 1, a, b])\n        graph[v - 1].append([u - 1, a, b])\n        max_a = max(max_a, a)\n    ce = [[int(i) for i in input().split()] for _ in range(n)]\n    # \u521d\u671f\u5024\u30de\u30c3\u30d7\u4f5c\u88fd\n    maxSilver = max_a * (n - 1)  # max(a) * (n - 1)\n    inf = float('inf')\n    ns_map = [[inf] * (maxSilver + 1) for _ in range(n)]\n    # \u30b9\u30bf\u30fc\u30c8\u6642\u306e\u5024\u8a2d\u5b9a\u3068\u63a2\u7d22\n    q = [[0, 0, min(maxSilver, s)]]  # \u7d2f\u8a08\u6642\u9593, \u90fd\u5e02, \u6240\u6301\u9280\u8ca8\n    ns_map[0][min(maxSilver, s)] = 0  # \u30b9\u30bf\u30fc\u30c8\u5730\u70b9\u306e\u6642\u523b\u306f0\n    while q:\n        ti, ni, si = heappop(q)\n        # \u79fb\u52d5\n        for g in graph[ni]:\n            n2, ai, bi = g\n            if si >= ai and ns_map[n2][si - ai] > ti + bi:\n                ns_map[n2][si - ai] = ti + bi\n                # \u2605heapq \u3067\u7d2f\u8a08\u6642\u9593\u304c\u5c11\u306a\u3044\u60c5\u5831\u304b\u3089\u5148\u306b\u51e6\u7406\u3059\u308b\u3088\u3046\u306b\u3059\u308b.\n                # \u3053\u308c\u306b\u3088\u3063\u3066\u51e6\u7406\u901f\u5ea6\u304c\u5168\u7136\u9055\u3046\n                heappush(q, [ti + bi, n2, si - ai])\n        # \u63db\u91d1\n        ci, di = ce[ni]\n        ti += di\n        si = min(si + ci, maxSilver)\n        if ns_map[ni][si] > ti:\n            ns_map[ni][si] = ti\n            heappush(q, [ti, ni, si])\n    for i in range(1, n):\n        print((min(ns_map[i])))\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "from heapq import heapify,heappush,heappop\n\nN, M, S = map(int, input().split())\n\n# !!\u30b0\u30e9\u30d5\u306e\u4f5c\u6210!! #\ntmp = [list(map(int, input().split())) for _ in range(M)]\n\nU = [0 for _ in range(M)]\nV = [0 for _ in range(M)]\nA = [0 for _ in range(M)]\nB = [0 for _ in range(M)]\n\nfor i in range(M):\n  U[i] = tmp[i][0] -1\n  V[i] = tmp[i][1] -1\n  A[i] = tmp[i][2]\n  B[i] = tmp[i][3]\nA_m = max(A)\nS = min(N*A_m, S)\n#print(A_m)\n\nI = [[] for _ in range(N * (N*A_m+1))] \n# \u96a3\u63a5\u30ea\u30b9\u30c8(\u9802\u70b9i\u3067\u9280\u8ca8j\u679a\u6301\u3061\u306e\u3068\u304d\u3001i*N*(A_m+1)+j\u3068\u304a\u304f)\nfor i in range(M):\n  for j in range(A[i], N*A_m+1):\n    I[U[i]*(N*A_m+1)+j].append((V[i]*(N*A_m+1)+j-A[i],B[i]))\n    I[V[i]*(N*A_m+1)+j].append((U[i]*(N*A_m+1)+j-A[i],B[i]))\n\nfor i in range(N):\n  C, D = map(int, input().split())\n  for j in range(N*A_m+1):\n    I[i*(N*A_m+1)+j].append((i*(N*A_m+1)+min(C+j,N*A_m),D))\n#print(I)\n\ndef dijkstra(I):# I:\u96a3\u63a5\u30ea\u30b9\u30c8(\u9802\u70b9\u3001\u30b3\u30b9\u30c8\u3001\u305d\u306e\u307b\u304b\u5236\u7d04) \n  N = len(I)\n  task = [] \n  visited = [0 for _ in range(N)]\n  min_cost = [0 for _ in range(N)]\n  cost = [10**20 for _ in range(N)]\n  prev_points = [0 for _ in range(N)]\n  heappush(task, (0, S, -1))\n  # !!\u6bd4\u8f03\u5024\u304c\u30b9\u30ab\u30e9\u30fc\u3067\u306a\u3044\u3068\u304d\u306f\u3001\u4e00\u756a\u5de6\u306e0\u3092\u9069\u5b9c\u5909\u66f4\u3059\u308b!! #\n  # !!\u6700\u521d\u306e\u70b9\u756a\u53f7\u304c0\u3067\u306a\u3044\u3068\u304d\u306f\u3001\u771f\u3093\u4e2d\u306e0\u3092\u5909\u66f4\u3059\u308b!! #\n  \n  flag = 0\n  while task:\n    while task:\n      c, p, prev = heappop(task)    \n      if visited[p] == 0:\n        break  \n      if len(task) == 0:\n        flag = 1\n    if flag == 1:\n      break\n    #print(task)\n    visited[p] = 1\n    min_cost[p] = c\n    prev_points[p] = prev\n  \n    for j, c_ad in I[p]: #\u5236\u7d04\u304c\u5165\u308b\u3068\u304d\u306f\u3053\u3053\u306b\u8ffd\u52a0\n      if visited[j] == 1: continue\n      #print(p//(N*A_m+1),p%(N*A_m+1),j//(N*A_m+1),j%(N*A_m+1),c_ad)\n      cost_next = next_cost(I, p, j, c, c_ad)\n      if cost[j] > cost_next:\n        cost[j] = cost_next\n        heappush(task, (cost_next, j, p))\n\n  return (min_cost, prev_points)\n\ndef next_cost(I, p, j, c, c_ad): # !!\u73fe\u5728\u306e\u70b9p\u304b\u3089\u6b21\u306e\u70b9j\u3078\u306e\u30b3\u30b9\u30c8\u3092\u8a08\u7b97\u3059\u308b\u65b9\u6cd5\u3092\u8a18\u5165!! #  \n#c:\u70b9p\u306b\u3064\u304f\u307e\u3067\u306b\u6255\u3063\u305f\u30b3\u30b9\u30c8\u3001c_ad:\u6b21\u56de\u8ffd\u52a0\u3055\u308c\u308b\u30b3\u30b9\u30c8#\n  return c + c_ad\n\nmin_cost, prev_points = dijkstra(I)\n\nfor i in range(1, N):\n  print(min(min_cost[i*(N*A_m+1):(i+1)*(N*A_m+1)]))", "def main():    \n    import heapq\n    \n    n, m, s = list(map(int, input().split()))\n    if s >= 2500:\n        s = 2499\n    \n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        from_, to, cost, time = list(map(int, input().split()))\n        edges[from_-1].append((to-1, cost, time))\n        edges[to-1].append((from_-1, cost, time))\n    \n    banks = []\n    for i in range(n):\n        coin, time = list(map(int, input().split()))\n        banks.append((coin, time))\n    \n    INF = float('INF')\n    DP = [[INF] * 2500 for _ in range(n)]\n    ans = [INF] * n\n    \n    def push_todo(node, coin, time):\n        if coin < 0:\n            return\n        if time >= DP[node][coin]:\n            return\n        heapq.heappush(todo, (time, node, coin))\n    \n    def charge(node, current_coin, current_time):\n        coin, time = banks[node]\n        new_coin = current_coin + coin\n        if new_coin >= 2500:\n            new_coin = 2499\n        push_todo(node, new_coin, current_time+time)\n    \n    todo = [(0, 0, s)]\n    while todo:\n        current_time, node, current_coin = heapq.heappop(todo)\n        if current_time >= DP[node][current_coin]:\n            continue\n    \n        if current_time < ans[node]:\n            ans[node] = current_time\n    \n        DP[node][current_coin] = current_time\n        charge(node, current_coin, current_time)\n    \n        for to, cost, time in edges[node]:\n            push_todo(to, current_coin-cost, current_time+time)\n    \n    for a in ans[1:]:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput =sys.stdin.readline\nimport heapq\n\ndef dijkstra(edge, start):\n    n = len(edge)\n    dist = [float(\"inf\")]*n\n    dist[start] = 0\n    que = [(0, start)]\n    while que:\n        d, v = heapq.heappop(que)\n        if dist[v] < d:\n            continue\n        for nv, nd in edge[v]:\n            if dist[nv] > d + nd:\n                dist[nv] = d + nd\n                heapq.heappush(que, (dist[nv], nv))\n    return dist\n\nn, m, s = map(int, input().split())\nG = [[] for _ in range(n)]\nif s >= 2500:\n  for _ in range(m):\n    u, v, a, b = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, b))\n    G[v].append((u, b))\n  L = dijkstra(G, 0)\nelse:\n  for _ in range(m):\n    u, v, a, b = map(int, input().split())\n    u -= 1\n    v -= 1\n    G[u].append((v, a, b))\n    G[v].append((u, a, b))\n  CD = [list(map(int, input().split())) for _ in range(n)]\n  edge = [[] for _ in range(n*2500)]\n  for i in range(n):\n    c, d = CD[i]\n    for k in range(2500):\n      for v, a, b in G[i]:\n        if k >= a:\n          edge[2500*i+k].append((2500*v+(k-a), b))\n      if k+c < 2500:\n        edge[2500*i+k].append((2500*i+(k+c), d))\n  dist = dijkstra(edge, s)\n  L = [0]*n\n  for i in range(n):\n    L[i] = min(dist[2500*i:2500*(i+1)])\nprint(*L[1:], sep=\"\\n\")", "#!python3\n\nfrom heapq import heappop, heappush\n\n\nINF = 10 ** 18\n\n# input\nN, M, S = list(map(int, input().split()))\nUVAB = [list(map(int, input().split())) for _ in range(M)]\nCD = [list(map(int, input().split())) for _ in range(N)]\n\n\ndef solve(link):\n    ans = {}\n    lim = 50 * (N - 1)\n    w = [[INF] * (lim + 1) for _ in range(N)]\n\n    # (time, node, silver)\n    hq = [(0, 0, min(S, lim))]\n    while hq:\n        t, v, s = heappop(hq)\n        if t > w[v][s]:\n            continue\n        if v not in ans:\n            ans[v] = t\n            if len(ans) == N:\n                break\n        \n        # buy\n        if s < lim:\n            c, d = CD[v]\n            new_s = min(lim, s + c)\n            new_t = t + d\n            if new_t < w[v][new_s]:\n                w[v][new_s] = new_t\n                heappush(hq, (new_t, v, new_s))\n        \n        # move\n        for u, a, b in link[v]:\n            if s < a:\n                continue\n            new_s = s - a\n            new_t = t + b\n            if new_t < w[u][new_s]:\n                w[u][new_s] = new_t\n                heappush(hq, (new_t, u, new_s))\n        \n    return ans\n\n\ndef main():\n    link = [[] for _ in range(N)]\n    for u, v, a, b in UVAB:\n        link[u - 1].append((v - 1, a, b))\n        link[v - 1].append((u - 1, a, b))\n    \n    ans = solve(link)\n    for i in range(1, N):\n        print((ans[i]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nimport sys\ninput = sys.stdin.readline\n\nINF = 10 ** 18\n\nclass Edge():\n    def __init__(self, end, cost, time):\n        self.end = end\n        self.cost = cost\n        self.time = time\n\ndp = []\nh = []\n\ndef push(t, v, x):\n    if x < 0:\n        return\n    if dp[v][x] <= t:\n        return\n    dp[v][x] = t\n    heapq.heappush(h, (t, v, x))\n\ndef dijkstra(n, G, cd, start, s, max_s):\n    nonlocal dp\n    dp = [[INF for j in range(max_s+1)] for i in range(n)] \n    push(0, start, s)\n\n    while h:\n        # \u4f7f\u3063\u3066\u3044\u306a\u3044\u9802\u70b9\u306e\u3046\u3061\u3001\u73fe\u6642\u70b9\u3067\u6700\u3082\u8ddd\u96e2\u306e\u8fd1\u3044\u3082\u306e\u3092\u9078\u3073v\u3068\u3059\u308b\n        t, v, x = heapq.heappop(h)\n        if dp[v][x] < t:\n            continue\n        # \u4e21\u66ff\n        if x < max_s:\n            push(t+cd[v][1], v, min(x+cd[v][0], max_s))\n\n        # v\u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u9802\u70b9\u306b\u3064\u3044\u3066\u3001\u8ddd\u96e2\u304c\u77ed\u304f\u306a\u308c\u3070\u66f4\u65b0\n        for e in G[v]:\n            push(t+e.time, e.end, x-e.cost)\n\n\nn, m, s = list(map(int, input().split()))\nuvab = [list(map(int, input().split())) for _ in range(m)]\ncd = [list(map(int, input().split())) for _ in range(n)]\n\nes = [[] for i in range(n)]\nmax_s = 50 * (n-1)\n\nfor u, v, a, b in uvab:\n    es[u-1].append(Edge(v-1,a,b))\n    es[v-1].append(Edge(u-1,a,b))\n\ndijkstra(n, es, cd, 0, min(max_s,s), max_s)\n\nfor i in range(1, n):\n    print((min(dp[i])))\n\n\n", "# -*- coding: utf-8 -*-\nimport heapq\n\nN,M,S = list(map(int, input().rstrip().split()))\nUVAB_list = [list(map(int, input().rstrip().split())) for i in range(M)]\nCD_list = [list(map(int, input().rstrip().split())) for i in range(N)]\n#-----\n\nmax_money = 2500\nS = min(max_money, S)\n\n# graph[current city][i] = [ (next city, coin, time) ]\ngraph = [None] + [ [] for _ in range(N) ]\n\n# change[current city][i] = [ (coin, time) ]\nchange = [None] + [ () for _ in range(N) ]\n\n# dp[city][money] = total time\ndp = [None] + [ [float(\"inf\")]*(max_money + 1) for _ in range(N) ]\ndp[1][S] = 0\n\n\nfor u,v,a,b in UVAB_list:\n    graph[u].append( (v,a,b) )\n    graph[v].append( (u,a,b) )\n\nfor i,(c,d) in enumerate(CD_list):\n    change[i+1] = (c,d)\n\n# heap[i] = (current time, current city, current money)\nheap = [ (0, 1, S) ]\n\n\nwhile heap:\n    cur_time, cur_city, cur_mone = heapq.heappop(heap)\n    \n    # change money at current city ---\n    changed_money = cur_mone + change[cur_city][0]\n    changed_time = cur_time + change[cur_city][1]\n    \n    if (changed_money <= max_money) and (changed_time < dp[cur_city][changed_money] ):\n        dp[cur_city][changed_money] = changed_time\n        heapq.heappush(heap, ( changed_time, cur_city, changed_money) )\n    \n    # move to next city ---\n    for next_city, cost_coin, cost_time in graph[cur_city]:\n        next_time = cur_time + cost_time\n        next_money = min( max_money , cur_mone - cost_coin )\n        \n        if (cur_mone >= cost_coin) and ( next_time < dp[next_city][next_money] ):\n            dp[next_city][next_money] = next_time\n            heapq.heappush(heap, ( next_time, next_city, next_money) )\n\n\nfor row in dp[2:]:\n    print(( min(row) ))\n", "from scipy.sparse.csgraph import dijkstra\nfrom scipy.sparse import csr_matrix\n\nN, M, S, *I = map(int, open(0).read().split())\nUVAB, CD = I[:4 * M], I[4 * M:]\n\nR, C, V = [], [], []\nfor u, v, a, b in zip(*[iter(UVAB)] * 4):\n    for i in range(2501 - a):\n        R += [(i + a) * 51 + u, (i + a) * 51 + v]\n        C += [i * 51 + v, i * 51 + u]\n        V += [b, b]\n\nfor i, (c, d) in enumerate(zip(*[iter(CD)] * 2), 1):\n    for j in range(2501 - c):\n        R.append(j * 51 + i)\n        C.append((j + c) * 51 + i)\n        V.append(d)\n\nD = dijkstra(\n    csr_matrix((V, (R, C)), [2500 * 60] * 2),\n    indices=min(2500, S) * 51 + 1\n)\n\nfor i in range(2, N + 1):\n    print(int(D[i::51].min()))", "from heapq import heappop, heappush\nINF = float('inf')\n\nN, M, S = map(int,input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n\tU, V, A, B = map(int,input().split())\n\tgraph[U-1].append((V-1, A, B))\n\tgraph[V-1].append((U-1, A, B))\n\nC, D = [0]*N, [0]*N\nfor i in range(N):\n    c, d = map(int,input().split())\n    C[i], D[i] = c, d\n\ndef Extdijkstra(start):\n    nonlocal S\n    N_d = len(graph)\n    M = 2500\n\n    if S >= M:\n        S = M-1\n    \n    dist = [[INF]*M for _ in range(N_d)]\n    dist[start][S] = 0\n    q = [(0, S, start)]\n\n    while q:\n        d, num, v = heappop(q)\n        if num+C[v] < M and d+D[v] < dist[v][num+C[v]]:  # \u81ea\u5df1\u30eb\u30fc\u30d7\n            dist[v][num+C[v]] = d+D[v]\n            heappush(q, (d+D[v], num+C[v], v))\n        for node, c, t in graph[v]:\n            if num >= c and d + t < dist[node][num-c]:\n                dist[node][num-c] = d+t\n                heappush(q, (d+t, num-c, node))\n    return dist\n\nd = Extdijkstra(0)\nfor i in range(1, N):\n\tprint(min(d[i]))", "import math\nimport heapq\n\nn,m,s = map(int,input().split())\n\nroad = []\nfor i in range(m):\n    u,v,a,b = map(int,input().split())\n    road.append([u,v,a,b])\n\nchange = []\nfor i in range(n):\n    c,d = map(int,input().split())\n    change.append([c,d])\n\ntree = [[] for _ in range(n+1)]\n\nfor i in range(m):  \n    r = road[i]\n    tree[r[0]].append([r[0],r[1],r[2],r[3]])\n    tree[r[1]].append([r[1],r[0],r[2],r[3]])\n\nleast_cost = [[] for _ in range(n+1)]\nfor l in range(n+1):\n    least_cost[l] = [math.inf]*2501\n\nqueue = []\n\n#hwd [location, money, time]\ndef dijakstra(q):\n    while q != []:\n        hwd = heapq.heappop(q)\n\n        if least_cost[hwd[1]][hwd[2]] > hwd[0]:\n            least_cost[hwd[1]][hwd[2]] = hwd[0]\n            \n            for node in tree[hwd[1]]:\n                # from node, to node , money, time\n                if hwd[2] - node[2] >= 0:\n                    heapq.heappush(q,(hwd[0]+node[3],node[1],hwd[2]-node[2]))\n            if hwd[2] + change[hwd[1]-1][0] <= 2500:\n                heapq.heappush(q,(hwd[0]+change[hwd[1]-1][1],hwd[1],hwd[2]+change[hwd[1]-1][0]))\n    return least_cost\n\nif s > 2500:\n    s = 2500\nqueue.append((0,1,s))\n\nans = dijakstra(queue)\n\nfor i in range(2,n+1):\n    print(min(ans[i]))", "def main():\n    from heapq import heappush, heappop\n\n    INF = 1 << 60\n    MX_AG = 2500\n\n    N, M, S = list(map(int, input().split()))\n    S = min(S, MX_AG)  # \u305d\u308c\u4ee5\u4e0a\u306eAg\u306f\u4e0d\u8981\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        u, v, a, b = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n\n    exchange = []\n    for _ in range(N):\n        c, d = list(map(int, input().split()))\n        exchange.append((c, d))\n\n    h = [(0, S, 0)]\n\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    # time[location][r_Ag]:=minimum_time_to_reach\n\n    while h:\n        t, ag, loc = heappop(h)\n        for to, fare, dt in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0: continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time: continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n\n        e_time = t + exchange[loc][1]\n        e_Ag = ag + exchange[loc][0]\n        if e_Ag > MX_AG: continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time: continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n\n    ans = (min(time[to]) for to in range(1, N))\n\n    print(('\\n'.join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M, S = list(map(int, input().split(\" \")))\nadj = [ [] for _ in range(N) ] \nconvert = []\nfor _ in range(M) :\n    u, v, a, b = list(map(int, input().split(\" \")))\n    adj[u-1].append( (v-1,a,b) )\n    adj[v-1].append( (u-1,a,b) )\n\nfor _ in range(N) :\n    c, d = list(map(int, input().split(\" \")))\n    convert.append( (c, d) )  \n\nimport heapq \n\nlimit = 2500\nS = min(S, limit)\nh = [ (0, 0, S) ] \nans = [  [float('inf')]*(limit+1) for _ in range(N) ]\n\nwhile h != [] :\n    time_consumed, city, coin = heapq.heappop(h)\n    if ans[city][coin] < time_consumed:\n        continue\n    ans[city][coin] = time_consumed\n    \n    if coin + convert[city][0] < limit and ans[city][coin + convert[city][0]] > time_consumed + convert[city][1] :\n        ans[city][coin + convert[city][0]] = time_consumed + convert[city][1]\n        heapq.heappush(h, (time_consumed + convert[city][1], city, coin+convert[city][0] ) )\n\n    for v, a, b in adj[city] :\n        if coin - a < 0 or ans[v][coin-a] <= time_consumed+b :\n            continue\n        ans[v][coin-a] = time_consumed+b\n        heapq.heappush( h, (time_consumed+b, v, coin-a) )\n    \nfor i in range(1, N) :\n    print((min(ans[i])))\n", "def main():\n    from heapq import heappush, heappop\n\n    INF = 1 << 60\n    MX_AG = 2500\n\n    N, M, S = map(int, input().split())\n    S = min(S, MX_AG)  # \u305d\u308c\u4ee5\u4e0a\u306eAg\u306f\u4e0d\u8981\n\n    g = tuple(set() for _ in range(N))\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].add((v, a, b))\n        g[v].add((u, a, b))\n\n    exchange = []\n    for _ in range(N):\n        c, d = map(int, input().split())\n        exchange.append((c, d))\n\n    h = [(0, S, 0)]\n\n    time = [[INF] * (MX_AG + 1) for _ in range(N)]\n    time[0][S] = 0\n    # time[location][r_Ag]:=minimum_time_to_reach\n\n    while h:\n        t, ag, loc = heappop(h)\n        for to, fare, dt in g[loc]:\n            n_Ag = ag - fare\n            if n_Ag < 0: continue\n            cf = time[to][n_Ag]\n            n_time = t + dt\n            if cf <= n_time: continue\n            time[to][n_Ag] = n_time\n            heappush(h, (n_time, n_Ag, to))\n\n        e_time = t + exchange[loc][1]\n        e_Ag = ag + exchange[loc][0]\n        if e_Ag > MX_AG: continue\n        cf = time[loc][e_Ag]\n        if cf <= e_time: continue\n        time[loc][e_Ag] = e_time\n        heappush(h, (e_time, e_Ag, loc))\n\n    ans = (min(time[to]) for to in range(1, N))\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.csgraph import shortest_path\nM=49*50+1\nn,m,s=map(int,input().split())\ns=min(s,M-1)\nG=lil_matrix((n*M,n*M))\nfor _ in range(m):\n    a,b,silver,time=map(int,input().split())\n    a-=1\n    b-=1\n    for i in range(silver,M):\n        G[a*M+i,b*M+i-silver]=time\n        G[b*M+i,a*M+i-silver]=time\nfor i in range(n):\n    silver,time=map(int,input().split())\n    for j in range(M-1):\n        G[i*M+j,i*M+min(j+silver,M-1)]=time\nG=G.tocsr()\nG=shortest_path(G,method='D',indices=s)\n\nfor i in range(1,n):\n    ans=np.min(G[i*M:i*M+M])\n    print(int(ans))", "from heapq import heapify, heappop, heappush\nimport sys\ninput = sys.stdin.readline\n\nDEBUG = False\nINF = float('inf')\nMAX_N = 50\nMAX_A = 50\n\nN, M, S = list(map(int, input().split()))\nU = []\nV = []\nA = []\nB = []\nC = []\nD = []\n\nconnect = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, a, b = list(map(int, input().split()))\n    U.append(u)\n    V.append(v)\n    A.append(a)\n    B.append(b)\n    connect[u-1].append([v-1, a, b])\n    connect[v-1].append([u-1, a, b])\nfor _ in range(N):\n    c, d = list(map(int, input().split()))\n    C.append(c)\n    D.append(d)\n\nif DEBUG:\n    print((\"U: {}\".format(U)))\n    print((\"V: {}\".format(V)))\n    print((\"A: {}\".format(A)))\n    print((\"B: {}\".format(B)))\n    print((\"C: {}\".format(C)))\n    print((\"D: {}\".format(D)))\n    print((\"connect: {}\".format(connect)))\n\nMAX_N = N\nMAX_A = max(A)\nMAX_MONEY = MAX_N * MAX_A\nS = min(S, MAX_MONEY-1)\n\nnode = [INF for _ in range(MAX_MONEY * N)]\nhq = []\nheappush(hq, (0, S))\nwhile hq:\n    time, current_node = heappop(hq)\n    if DEBUG:\n        print((\"time: {}, current_node: {}, len(hq): {}\".format(time, current_node, len(hq))))\n    if time < node[current_node]:\n        node[current_node] = time\n    else:\n        continue\n    index_city = current_node // MAX_MONEY\n    money = current_node % MAX_MONEY\n    if DEBUG:\n        print((\"money: {}\".format(money)))\n\n    for index_next_city, a, b in connect[index_city]:\n        if money >= a and time+b < node[index_next_city*MAX_MONEY + money-a]:\n            heappush(hq, (time+b, index_next_city*MAX_MONEY + money-a))\n    if money < MAX_MONEY-1:\n        heappush(hq, (time+D[index_city], min(money+C[index_city], MAX_MONEY-1)+MAX_MONEY*index_city))\n\nfor i in range(1,N):\n    if DEBUG:\n        print((\"node{}: {}\".format(i, node[MAX_MONEY*i:MAX_MONEY*(i+1)])))\n    print((min(node[MAX_MONEY*i:MAX_MONEY*(i+1)])))\n", "from scipy.sparse import*\n(n,m,s,*D),*t=[map(int,t.split())for t in open(0)]\nx=51\nr=range(0,x**3,x)\nfor u,v,a,b in t[:m]:\n for i in r:D+=i+a*x+u,i+v,b,i+a*x+v,i+u,b\ni=0\nfor c,d in t[m:]:\n i+=1\n for j in r:D+=j+i,j+c*x+i,d\nd=csgraph.dijkstra(csr_matrix((D[2::3],(D[::3],D[1::3])),[j*2]*2),1,min(j,s*x)+1)\nfor i in range(2,n+1):print(int(min(d[i::x])))", "import sys\n\nstdin = sys.stdin\n\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: list(map(int, stdin.readline().split()))\nnl = lambda: list(map(int, stdin.readline().split()))\n\nn, m, s = nm()\nN = n * 3001\nG = [list() for _ in range(N)]\nfor _ in range(m):\n    u, v, a, b = nm()\n    u -= 1; v -= 1\n    for j in range(0, N, n):\n        if v + j - a * n >= 0:\n            G[u + j].append((v + j - a * n, b))\n        if u + j - a * n >= 0:\n            G[v + j].append((u + j - a * n, b))\nfor u in range(n):\n    c, d = nm()\n    for j in range(0, N, n):\n        G[u + j].append((min(u + j + c * n, u + N - n), d))\n\nimport heapq as hq\n\ndef dijkstra(G, s, t=None):\n    \"\"\"\n    G[v] = [(x1, c1), (x2, c2), ...]\n    \"\"\"\n    dist = [-1]*len(G)\n    dist[s] = 0\n    q = [(0, s)]\n    while q:\n        d, v = hq.heappop(q)\n        if d > dist[v]: continue\n        for x, c in G[v]:\n            if dist[x] < 0 or dist[x] > d + c:\n                dist[x] = d + c\n                hq.heappush(q, (d + c, x))\n    if t is None:\n        return dist\n    else:\n        return dist[t]\n\ndist = dijkstra(G, min(s, 3000) * n)\nfor i in range(1, n):\n    print((min(dist[i::n])))\n", "import collections\nimport heapq\n\nINF = 10 ** 18\nMAX_S = 50*50+5\n\ndef Z(): return int(input())\ndef ZZ(): return [int(_) for _ in input().split()]\n\nclass edge:\n    def __init__(self, to, cost, t): self.to, self.cost, self.t = to, cost, t\n\ndef main():\n    N, M, S = ZZ()\n    C, D = [0]*(N+1), [0]*(N+1)\n    E = collections.defaultdict(list)\n    dist = [[INF] * (MAX_S+1) for _ in range(N+1)]\n\n    for _ in range(M):\n        u, v, a, b = ZZ()\n        E[u].append(edge(v, a, b))\n        E[v].append(edge(u, a, b))\n\n    for i in range(1, N+1): C[i], D[i] = ZZ()\n\n    S = min(S, MAX_S)\n    dist[1][S] = 0\n\n    que = list()\n    heapq.heapify(que)\n    heapq.heappush(que, [dist[1][S], 1, S])\n\n    while que:\n        x, v, s = heapq.heappop(que)\n        if dist[v][s] < x: continue\n\n        #\u9077\u79fb\n        ns = min(s+C[v], MAX_S)\n        if dist[v][ns] > x + D[v]:\n            dist[v][ns] = x + D[v]\n            heapq.heappush(que, [x+D[v], v, ns])\n\n        #\u9077\u79fb\n        for e in E[v]:\n            if s - e.cost < 0: continue\n            if dist[e.to][s-e.cost] > x + e.t:\n                dist[e.to][s-e.cost] = x + e.t\n                heapq.heappush(que, [x+e.t, e.to, s-e.cost])\n\n    for i in range(2, N+1):\n        output = INF\n        for j in range(MAX_S+1): output = min(output, dist[i][j])\n        print(output)\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N,M,S=map(int,input().split())\nfrom heapq import heappop,heappush \n\ninf = float('inf')\ncost=[[] for _ in range(N)]\nexc=[]\n\n\nfor _ in range(M):\n    u,v,a,b=map(int,input().split())\n    u,v=u-1,v-1\n    cost[u].append((v,a,b))\n    cost[v].append((u,a,b))\nfor _ in range(N):\n    c,d=map(int,input().split())\n    exc.append((c,d))\n\nS=min(S,2450)\ndi=[inf]*2451*N\ndi[S]=0\nhq=[(0,S)] #\u6642\u9593,\u90fd\u5e02\u540d*2451+\u9280\u8ca8\n\nwhile hq:\n    t,v=heappop(hq)\n    u=v//2451 #\u90fd\u5e02\u540d\n    s=v%2451 #\u6240\u6301\u91d1\n    if t>di[v]:\n        continue\n\n    for x,a,b in cost[u]:\n        if s>=a:\n            v_new=x*2451+s-a\n            t_new=t+b\n            if t_new<di[v_new]:\n                di[v_new]=t_new\n                heappush(hq,(t_new,v_new))\n    \n    c,d=exc[u]\n    c=min(c,2450-s)\n    v_new=v+c\n    t_new=t+d\n    if t_new<di[v_new]:\n        di[v_new]=t_new\n        heappush(hq,(t_new,v_new))\n\nfor i in range(1,N):\n    m=min(di[i*2451:(i+1)*2451])\n    print(m)", "from heapq import heappush, heappop\ndef main():\n    N, M, S = list(map(int, input().split()))\n    G = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, a, b = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        G[u].append((v, a, b))\n        G[v].append((u, a, b))\n    CD = [list(map(int, input().split())) for _ in range(N)]\n    distance = [[1<<62]*2501 for _ in range(N)]\n    q = [(0, 0, min(S, 2500))]\n    distance[0][min(S, 2500)] = 0\n    while q:\n        d, v, vs = heappop(q)\n        if distance[v][vs] != d:\n            continue\n\n        vc, vd = CD[v]\n        ud = d + vd\n        us = vs + vc\n        if us > 2500:\n            us = 2500\n        if distance[v][us] > ud:\n            distance[v][us] = ud\n            heappush(q, (ud, v, us))\n\n        for u, fee, b in G[v]:\n            if fee > vs:\n                continue\n            ud = d + b\n            us = vs - fee\n            if us > 2500:\n                us = 2500\n            if distance[u][us] > ud:\n                distance[u][us] = ud\n                heappush(q, (ud, u, us))\n    print((\"\\n\".join(str(min(d)) for d in distance[1:])))\n\nmain()\n", "import sys\nfrom heapq import heappush, heappop\nimport numpy as np\n\ndef input(): return sys.stdin.readline().rstrip()\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(mi())\n\n\ndef main():\n\n    def dijkstra(s):\n        def push(v, s, x):\n            if s < 0: \n                return\n            if dist[v, s] <= x:\n                return\n            dist[v, s] = x\n            heappush(que, (x, v, s))\n        \n        inf = 10**18\n        dist = np.full((n, MAX_S+1), inf, dtype=int)\n        # time, remain, node\n        que = []\n        push(0, s, 0)\n        while que:\n            x, v, s = heappop(que)\n            if dist[v, s] < x:\n                continue\n            ns = min(s+c[v], MAX_S)\n            push(v, ns, x+d[v])\n            for nv, a, b in adj[v]:\n                push(nv, s-a, x+b)\n        return np.min(dist, axis=1)\n\n    n, m, s = mi()\n    adj = [[] for i in range(n)]\n    MAX_S = 0\n    for i in range(m):\n        u, v, a, b = mi()\n        u -= 1\n        v -= 1\n        adj[u].append((v, a, b))\n        adj[v].append((u, a, b))\n        MAX_S = max(MAX_S, a)\n    MAX_S *= n-1\n    s = min(s, MAX_S)\n    c, d = [0]*n, [0]*n\n    for i in range(n):\n        c[i], d[i] = mi()\n    ans = dijkstra(s)\n    print(*ans[1:], sep='\\n')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappop, heappush\nimport sys\ninput = sys.stdin.readline\nINF = 10**100\nMAX = 2500\nN, M, S = list(map(int, input().split()))\nS = min(S, MAX)\nG = [[] for _ in [0]*N]\nC = []\nfor _ in [0]*M:\n    u, v, a, b = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    G[v].append((u, a, b))\n    G[u].append((v, a, b))\n\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    C.append((a, b))\n\n# dijkstra\ndp = [[INF]*MAX for _ in [0]*N]\nq = []\ndef push(t, s, v):\n    if s < 0:\n        return\n    if s >= MAX:\n        s = MAX-1\n    if dp[v][s] <= t:\n        return\n    dp[v][s] = t\n    heappush(q, (t, s, v))\n\npush(0, S, 0)\n\nwhile q:\n    t, s, v = heappop(q)\n    if dp[v][s] != t:\n        continue\n\n    c, d = C[v]\n    push(t+d, s+c, v)\n\n    for u, a, b in G[v]:\n        push(t+b, s-a, u)\n\n# output\nfor d in dp[1:]:\n    ans = INF\n    for s in range(MAX):\n        if ans > d[s]:\n            ans = d[s]\n    print(ans)\n", "from heapq import heappop, heappush\n\nimport sys\ndef input():return sys.stdin.readline().strip()\n\ndef main():\n    N, M, S = map(int, input().split())\n    to = [{} for _  in range(N)]\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u -= 1\n        v -= 1\n        to[u][v] = (a, b)\n        to[v][u] = (a, b)\n    info = tuple(tuple(map(int, input().split())) for _ in range(N))\n\n    MAX_SILVER = 50 * (N-1)\n    INF = 10 ** 18\n    # dijkstra (time, vertex, money)\n    visited = [[False]*(MAX_SILVER+1) for _ in range(N)]\n    cost = [[INF]*(MAX_SILVER+1) for _ in range(N)]\n    q = []\n    S = min(S, MAX_SILVER)\n    heappush(q, (0, 0, S)) # (time, vertex, silver)\n\n    while q:\n        t, now, s = heappop(q)\n        if visited[now][s]:continue\n        visited[now][s] = True\n        cost[now][s] = t\n\n        # next node\n        for nv, (a, b) in to[now].items():\n            nt = t + b\n            rest = s - a\n            if rest >= 0:\n                if cost[nv][rest] <= nt : continue \n                heappush(q, (nt, nv, rest))\n        \n        # exchange gold with silver\n        rate, time = info[now]\n        nt = t + time\n        ns = min(s+rate, MAX_SILVER)\n        heappush(q, (nt, now, ns))\n        \n    \n    for i in range(1, N):\n        print(min(cost[i]))\n\ndef __starting_point():\n    main()\n__starting_point()"]
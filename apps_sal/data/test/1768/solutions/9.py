import sys
def ii(): return sys.stdin.readline().strip()
def idata(): return [int(x) for x in ii().split()]


# Ввод данных
n = int(ii())
s = ii()

# Будем считать, что "сет" - подотрезок, состоящий из одинаковых букв
# Далее создание словаря и внесение в него данных:
slov = {}
# В данном словаре на каждую букву есть два списка, в первом находятся
#   числа, которые сообщают нам размеры "сетов", а второй
#       список - расстояния между "сетами" (первый и
#           последний элементы этого списка - расстояние между началом всей строки и первым
#               "сетом" и расстояние между концом всей строки и последним "сетом")
for i in range(97, 97 + 26):
    slov[chr(i)] = [[], [1]]
slov[s[0]] = [[1], [0, 0]]  # Первый элемент обозначим вне цикла, чтобы позже не маяться с неточностями

for j in range(1, n):
    if slov[s[j]][1][-1] == 0:  # То есть, если нет расстояния между данной буквой и предыдущим "сетом"
        slov[s[j]][0][-1] += 1
    else:  # Добавление нового "сета"
        slov[s[j]][0] += [1]
        slov[s[j]][1] += [0]

    # Следующий for - увеличение расстояний между "сетами" для всех остальных букв
    for i in range(97, 97 + 26):
        if chr(i) != s[j]:
            slov[chr(i)][1][-1] += 1

# Пошла жара. Здесь обработка планов Надеко
for t in range(int(ii())):
    m, c = ii().split()
    m = int(m)
    a, b = slov[c]
    if sum(b) <= m:
        print(n)
    else:
        if not bool(a):  # Если нет "сетов" с данной буквой
            print(m)
        elif len(a) == 1:  # Если такой "сет" всего один
            print(a[0] + m)
        else:
            l, r = 0, 0
            ans = 0  # Максимальный ответ
            summ_a, summ_b = 0, 0
            used = 0  # Количество букв, которые мы заменили
            b1 = b[::]
            b1[0], b1[-1] = 0, 0
            count = 0  # Количество "сетов", которые мы используем на данный момент
            while r != len(a):
                if summ_b + b1[r] <= m:
                    summ_b += b1[r]
                    summ_a += a[r]
                    r += 1
                    ans = max(ans, m + summ_a)
                else:
                    summ_a -= a[l]
                    l += 1
                    summ_b -= b1[l]
            print(ans)

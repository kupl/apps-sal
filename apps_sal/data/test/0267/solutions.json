["\n\n\nl, r, k =list(map(int,input().split()))\n\nd = {i:2**i for i in range(10)}\n\ncache = {}\n\ndef can(i, m):\n    return d[i] & m\n\ndef calc(m):\n    b = 1\n    c = 0\n    for i in range(10):\n        if b & m:\n            c += 1\n        b *= 2\n\n    return c\n\ndef sm(ln, k, m, s='', first=False):\n    if ln < 1:\n        return 0, 1\n\n    if (ln, k, m, s, first) in cache:\n        return cache[(ln, k, m, s, first)]\n\n    ans = 0\n    count = 0\n    base = 10 ** (ln-1)\n\n    use_new = calc(m) < k\n\n    if s:\n        finish = int(s[0])+1\n    else:\n        finish = 10\n\n    for i in range(finish):\n        if use_new or can(i, m):\n            ss = s[1:]\n            if i != finish-1:\n                ss = ''\n            nm = m | d[i]\n            nfirst = False\n            if i == 0 and first:\n                nm = m\n                nfirst = True\n            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)\n            ans += base * i * nextc + nexta\n            count += nextc\n\n#    print(ln, k, m, s, first, ans, count)\n    cache[(ln, k, m, s, first)] = (ans, count)\n\n    return ans, count\n\ndef call(a, k):\n    s = str(a)\n    return sm(len(s), k, 0, s, True)[0]\n\n\n#print(call(r, k) - call(l-1, k))\nprint((call(r, k) - call(l-1, k)) % 998244353)\n", "\nMOD = 998244353\n\n\ndef pop_count(x) :\n    ans = 0\n    while (x > 0) :\n        ans = ans + x % 2\n        x = x // 2\n    return ans\n\ndef check(x, k) :\n    mask = 0\n    nx = int(x)\n    while (nx > 0) :\n        mask = mask | (1 << (nx % 10))\n        nx = nx // 10\n    if (pop_count(mask) <= k) :\n        return x\n    return 0\n\npop = []\np10 = []\nf = [[0 for j in range(1 << 10)] for i in range(20)]\nw = [[0 for j in range(1 << 10)] for i in range(20)]\ndef prepare() : \n    p10.append(1)\n    for i in range(20) :\n        p10.append(p10[i] * 10 % MOD)\n    for i in range(1 << 10) :\n        pop.append(pop_count(i))\n    w[0][0] = 1\n    for i in range(1, 20) :\n        for j in range(1 << 10) :\n            for use in range(10) : \n                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD\n                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD\n\ndef solve(x, k) :\n    sx = [int(d) for d in str(x)] \n    n = len(sx) \n    ans = 0\n    for i in range(1, n) :\n        for use in range(1, 10) :\n            for mask in range(1 << 10) : \n                if (pop[(1 << use) | mask] <= k) :\n                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD\n    cmask = 0\n    csum = 0\n    for i in range(n) :\n        cdig = sx[i]\n        for use in range(cdig) : \n            if (i == 0 and use == 0) :\n                continue\n            nmask = cmask | (1 << use)\n            for mask in range(1 << 10) : \n                if (pop[nmask | mask] <= k) :\n                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD\n        cmask |= 1 << cdig\n        csum = (10 * csum + cdig) % MOD\n    return ans\n\nprepare()\nl, r, k = list(map(int, input().split()))\nans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD\nprint(ans)\n    \n"]
def main():
    N = int(input())
    A = list(map(int, input().split()))

    # C[x]: 書かれている整数がxであるカードの枚数
    C = [0] * (N + 1)
    D = [0] * (N + 1)
    for a in A:
        C[a] += 1
        D[C[a]] += 1

    # AからK(1<=K<=N)枚ずつカードを抜いてったときに、
    # x回以上抜くことができるか判定する。
    # 抜くことができると判定されたxの最大値が答えになる。

    # 例えば、A = [1 1 1 1 1 2 2 3] とする。
    # -> C = [5 2 1 0 0 0 0 0]
    # ここから2枚ずつカードを抜ける回数を考えるとき、
    # 「3回抜く」とすると、数字の1は、どうやっても2個は絶対余る
    # そこで、絶対余る部分を捨ててCを作り直す(=Eとする)と、
    # E = [3 2 1 0 0 0 0 0]
    # ここから2枚ずつ3回抜けるか判定するなら、
    # sum(E) >= 2 * 3 = 6
    # であるか見ればよい。今回の場合ちょうど6なので、2枚ずつ3回は抜ける。
    
    # 3枚ずつ2回ぬけるか調べる場合、
    # E = [2 2 1] となり、sum(E) = 5 < 3 * 2 = 6 なので、抜けないことが分かる

    # よって、
    # sum(min(C[i], x)) >= K * x であれば抜くことができる
    # S(x) = sum(min(C[i], x)) とすると、
    # S(x) = S(x-1) + [Cの中でC[i] >= x であるものの個数]
    # となることから、Cの中でC[i] >= x であるものの個数 = D(x) とすると、
    # S(x) = sum_(1~x) D(i) となる。
    # つまり、S(x)は、D(x) を最初に全部計算しておいて、累積和をとることで高速に計算できる。

    # S(x) >= K * x となるxの最大値を、kを1からNまで動かして見つければよい。
    # ここで、xを左辺にもっていって、
    # S(x) / x >= Kとなるxの最大値を見つけるようにする。
    # また、S(x) / x = f(x) とおく。

    # 最大値を見つけるために2分探索してもいいが、
    # Kが増えると、答えは以前の値以下になるはずなので、
    # K+1のとき、Kでの答えの位置から0へと探索していけば、O(N)で答えが見つかる
    S = [0] * (N + 1)
    f = [0] * (N + 1)
    for x in range(1, N+1):
        S[x] = S[x-1] + D[x]
        f[x] = S[x] // x

    ans = []
    prev_ans = N
    for K in range(1, N+1):
        a = prev_ans
        while True:
            if f[a] >= K or a == 0:
                break
            a -= 1
        ans.append(a)
        prev_ans = a

    print(*ans, sep='\n')

def __starting_point():
    main()
__starting_point()

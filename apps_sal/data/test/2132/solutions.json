["speeds = [1000000]\novertakes = [True]\ncount = 0\nspeed = 0\nn = int(input())\nfor e in range(n):\n  inp = list(map(int, input().split()))\n  # print(inp)\n  if inp[0] == 4:\n    overtakes.append(True)\n  elif inp[0] == 6:\n    overtakes.append(False)\n  elif inp[0] == 5:\n    speeds.append(1000000)\n  elif inp[0] == 3:\n    speeds.append(inp[1])\n    while speed > speeds[-1]:\n      count += 1\n      speeds.pop()\n      \n  elif inp[0] == 2:\n    while not overtakes[-1]:\n      count += 1\n      overtakes.pop()\n  else:\n    while inp[1] > speeds[-1]:\n      count += 1\n      speeds.pop()\n    speed = inp[1]\n  \nprint(count)\n\"\"\"\nPolycarp changes the speed of his car to specified (this event comes with a positive integer number);\nPolycarp's car overtakes the other car;\nPolycarp's car goes past the \"speed limit\" sign (this sign comes with a positive integer);\nPolycarp's car goes past the \"overtake is allowed\" sign;\nPolycarp's car goes past the \"no speed limit\";\nPolycarp's car goes past the \"no overtake allowed\";\n\"\"\"", "# D. Driving Test\n\nn = int(input())\n\nps = None\nseen_sl = [float('inf')]\nseen_ot = [True]\n\nanswer = 0\nfor i in range(n):\n\tline = list(map(int, input().split()))\n\tt = line[0]\n\tif t == 1:\n\t\tps = line[1]\n\t\twhile ps > seen_sl[-1]:\n\t\t\tanswer += 1\n\t\t\tseen_sl.pop(-1)\n\telif t == 2:\n\t\twhile not seen_ot[-1]:\n\t\t\tanswer += 1\n\t\t\tseen_ot.pop(-1)\n\telif t == 3:\n\t\tseen_sl.append(line[1])\n\t\twhile ps > seen_sl[-1]:\n\t\t\tanswer += 1\n\t\t\tseen_sl.pop(-1)\n\telif t == 4:\n\t\tseen_ot.append(True)\n\telif t == 5:\n\t\tseen_sl.append(float('inf'))\n\telif t == 6:\n\t\tseen_ot.append(False)\n\nprint(answer)\n", "n = int(input())\n\nevents = []\nfor i in range(n):\n    events.append(list([int(s) for s in input().split()]))\n\nmax_speeds = []\novertaking_forbidden = 0\n\ncurrent_speed = 0\n\nignores = 0\n\nfor event in events:\n    if event[0] == 1:\n        current_speed = event[1]\n\n        while max_speeds and current_speed > max_speeds[-1]:\n            max_speeds.pop()\n            ignores += 1\n\n    elif event[0] == 2:\n        ignores += overtaking_forbidden\n        overtaking_forbidden = 0\n\n    elif event[0] == 3:\n        if current_speed > event[1]:\n            ignores += 1\n        else:\n            max_speeds.append(event[1])\n\n    elif event[0] == 4:\n        overtaking_forbidden = 0\n    elif event[0] == 5:\n        max_speeds = []\n    elif event[0] == 6:\n        overtaking_forbidden += 1\n\nprint(ignores)\n\n", "import sys\nn = int(input())\na = [list(map(int, input().split())) for i in range(n)]\nc2 = 0\nspeed = 0\nc = 0\nst = []\n\nfor i in a:\n    if i[0] == 1:\n        speed = i[1]\n        while len(st) and st[-1] < speed:\n            c += 1\n            st.pop()\n    elif i[0] == 2 and c2 > 0:\n        c += c2\n        c2 = 0\n    elif i[0] == 3:\n        st.append(i[1])\n        while len(st) and st[-1] < speed:\n            c += 1\n            st.pop()\n    elif i[0] == 4:\n        c2 = 0\n    elif i[0] == 5:\n        st = []\n    elif i[0] == 6:\n        c2 += 1\nprint(c)\n        \n", "n=int(input())\ns=0\nms=[]\no=1\nz=0\nq=0\nfor _ in range(n):\n    a=list(map(int,input().split()))\n    if a[0]==1:\n        s=a[1]\n        while len(ms)>0 and ms[-1]<s:\n            z+=1\n            ms.pop(-1)\n    elif a[0]==2:\n        if o!=1:\n            z+=(1-o)\n            o=1\n    elif a[0]==3:\n        ms.append(a[1])\n        while len(ms)>0 and ms[-1]<s:\n            z+=1\n            ms.pop(-1)\n    elif a[0]==4:\n        o=1\n    elif a[0]==5:\n        ms=[]\n    elif a[0]==6:\n        o-=1\nprint(z)", "from collections import deque\n\nn = int(input())\nspeed_stack = deque()\nover_take = 0\nspeed = 0\npenalty = 0\ndef speed_check(penalty, x):\n    while speed_stack and speed_stack[-1] < x:\n        speed_stack.pop()\n        penalty += 1\n    return penalty\n\nfor i in range(n):\n    update = [int(j) for j in input().split()]\n    if update[0] == 1:\n        speed = update[1]\n        penalty = speed_check(penalty, speed)\n    elif update[0] == 2:\n        penalty += over_take\n        over_take = 0\n    elif update[0] == 3:\n        speed_stack.append(update[1])\n        penalty = speed_check(penalty, speed)\n    elif update[0] == 4:\n        over_take = 0\n    elif update[0] == 5:\n        speed_stack = deque()\n    else:\n        over_take += 1\nprint(penalty)", "#!/usr/bin/env python3\nfrom sys import stdin, stdout\nfrom math import inf\n\ndef rint():\n    return list(map(int, stdin.readline().split()))\n#lines = stdin.readlines()\n\ncsp = 0\nov = 1\n\nsign = []\nans = 0\nspst = [inf]\novst = [1]\nn = int(input())\nfor i in range(n):\n    sign = list(rint())\n    if sign[0] == 1:\n        csp = sign[1]\n        while csp > spst[-1]:\n            spst.pop()\n            ans += 1\n    if sign[0] == 2:\n        while ovst[-1] == 0:\n            ovst.pop()\n            ans += 1\n    if sign[0] == 3:\n        if sign[1] >= csp:\n            spst.append(sign[1])\n        else:\n            ans += 1\n    if sign[0] == 4:\n        ovst.append(1)\n    if sign[0] == 5:\n        spst.append(inf)\n    if sign[0] == 6:\n        ovst.append(0)\nprint(ans)\n", "MAX_SPEED = 300\nn = int(input())\nactions = [list(map(int, input().split())) for _ in range(n)]\nspeed = [0 for i in range(n)]\n\nfor i in range(n):\n    if actions[i][0] == 1:\n        lastSpeed = actions[i][1]\n    speed[i] = lastSpeed    \n\nignored = 0\novertook = False\nmaxSpeed = -1\nfor i in range(n-1,-1,-1):\n    maxSpeed = max(maxSpeed, speed[i])\n    if actions[i][0] == 1:\n        pass\n    elif actions[i][0] == 2:\n        overtook = True\n    elif actions[i][0] == 3:\n        if maxSpeed > actions[i][1]:\n            ignored += 1\n        else:\n            maxSpeed = speed[i-1]\n    elif actions[i][0] == 4:\n        overtook = False\n    elif actions[i][0] == 5:\n        maxSpeed = speed[i-1]\n    elif actions[i][0] == 6:\n        if overtook:\n            ignored += 1\n  \nprint(ignored)\n", "n = int(input())\n\nno_overtake = 0\nspeedlimit = [float(\"inf\")]\n\nspeed = 0\n\nvio = 0\n\not_ignored = False\n\nfor _ in range(n):\n    cmd = input().split()\n    if cmd[0] == '1':\n        speed = int(cmd[1])\n        while speed > speedlimit[-1]:\n            vio += 1\n            speedlimit.pop(-1)\n    elif cmd[0] == '2':\n        if no_overtake and not ot_ignored:\n            vio += no_overtake\n            ot_ignored = True\n    elif cmd[0] == '3':\n        speedlimit.append(int(cmd[1]))\n        if speed > speedlimit[-1]:\n            vio += 1\n            speedlimit.pop(-1)\n    elif cmd[0] == '4':\n        no_overtake = 0\n        ot_ignored = False\n    elif cmd[0] == '5':\n        speedlimit = [float('inf')]\n    elif cmd[0] == '6':\n        if ot_ignored == 1:\n            no_overtake = 0\n        no_overtake += 1\n        ot_ignored = False\n\nprint(vio)\n", "n = int(input())\n\nno_overtake = 0\nspeedlimit = [float(\"inf\")]\n\nspeed = 0\n\nvio = 0\n\not_ignored = False\n\nfor _ in range(n):\n    cmd = input().split()\n    if cmd[0] == '1':\n        speed = int(cmd[1])\n        while speed > speedlimit[-1]:\n            vio += 1\n            speedlimit.pop(-1)\n    elif cmd[0] == '2':\n        if no_overtake and not ot_ignored:\n            vio += no_overtake\n            ot_ignored = True\n    elif cmd[0] == '3':\n        speedlimit.append(int(cmd[1]))\n        if speed > speedlimit[-1]:\n            vio += 1\n            speedlimit.pop(-1)\n    elif cmd[0] == '4':\n        no_overtake = 0\n        ot_ignored = False\n    elif cmd[0] == '5':\n        speedlimit = [float('inf')]\n    elif cmd[0] == '6':\n        if ot_ignored == 1:\n            no_overtake = 0\n        no_overtake += 1\n        ot_ignored = False\n\nprint(vio)\n\n", "n, d = int(input()), []\nfor i in range(n):\n    d.append(tuple(map(int, input().split())))\nst, c = [], 0\nans, v = 0, 0\nfor i in d:\n    if i[0] == 1:\n        v = i[1]\n        while(len(st) != 0 and st[-1] < v):\n            ans += 1\n            st.pop()\n    elif i[0] == 2:\n        ans += c\n        c = 0\n    elif i[0] == 3:\n        if v > i[1]:\n            ans += 1\n        else:\n            st.append(i[1])\n    elif i[0] == 4:\n        c = 0\n    elif i[0] == 5:\n        st.clear()\n    elif i[0] == 6:\n        c += 1\nprint(ans)\n    \n", "def Task485D():\n    cur_speed   = 0\n    is_outstrip = 0\n    err_count   = 0\n    event_speed_limit = []\n\n    event_count = int(input())\n\n    for a in range(event_count):\n        ev =list(map(int, input().split()))\n        if ev[0] == 1:\n            cur_speed = ev[1]\n            while len(event_speed_limit) > 0:\n                if cur_speed > event_speed_limit[len(event_speed_limit) - 1]:\n                    event_speed_limit.pop()\n                    err_count += 1\n                else:\n                    break\n\n        if ev[0] == 2:\n            err_count += is_outstrip\n            is_outstrip = 0\n\n        if ev[0] == 3:\n            if cur_speed > ev[1]:\n                err_count += 1\n            else:\n                event_speed_limit.append(ev[1])\n\n        if ev[0] == 4:\n            is_outstrip = 0\n\n        if ev[0] == 5:\n            event_speed_limit.clear()\n\n        if ev[0] == 6:\n            is_outstrip += 1\n\n    print(err_count)\n\ndef __starting_point():\n    Task485D()\n__starting_point()", "n=int(input())\nover=[]\nspeed=[]\nfor x in range(n):\n    ab=input()\n    if(len(ab)>1):\n        a,b=ab.split()\n    else:\n        a=ab\n    if(a=='1' or a=='3' or a=='5'):\n        if(a=='5'):\n            speed.append([5,2**31-1])\n        else:\n            speed.append([int(a),int(b)])\n    else:\n        over.append(int(a))\noverignore=0\noversum=0\ni=len(over)-1\nwhile(i>=0):\n    if(over[i]==2):\n        oversum+=1\n    elif(over[i]==4):\n        oversum=0\n    if(over[i]==6 and oversum>0):\n        overignore+=1\n    i-=1\n\ncurspeed=[]\nstack=[]\nstack.append(2**31-1)\ni=0\nwhile(i<len(speed)):\n    if(speed[i][0]==1):\n        curspeed.append(speed[i][1])\n    else:\n        curspeed.append(curspeed[-1])\n        stack.append(speed[i][1])\n    i+=1\n\nspeedignore=0\ni=len(speed)-1\nwhile(i>=0):\n    if(speed[i][0]!=1 and speed[i][1]==stack[-1]):\n        if(curspeed[i]>stack[-1]):\n            stack.pop()\n            speedignore+=1\n        else:   \n            stack.pop()\n            i-=1\n    else:\n        if(curspeed[i]>stack[-1]):\n            stack.pop()\n            speedignore+=1\n        else:\n            i-=1\nprint(speedignore+overignore)", "num=int(input())\nslimit = []\nans = 0\nlast = 0\nolimit = 1\nfor i in range(num):\n    a = list( map(int , input().split()) )\n    if a[0] == 1:\n        last = a[1]\n        while len(slimit)>0 and slimit[-1] < last:\n            ans+=1\n            slimit.pop(-1)\n    elif a[0] == 2:\n        if olimit!=1:\n            ans+=(1-olimit)\n            olimit = 1\n    elif a[0] == 3:\n        slimit.append(a[1])\n        while len(slimit)>0 and slimit[-1] < last:\n            ans+=1\n            slimit.pop(-1)\n    elif a[0] == 4:\n        olimit = 1\n    elif a[0] == 5:\n        slimit = []\n    elif a[0] == 6:\n        olimit -= 1\nprint(ans)", "n=int(input())\nst=[0]*n\ntop=-1\ncurr_speed=0\nans=0\nc=0\nwhile(n>0):\n    \n    n-=1\n    a=list(map(int,input().split()))\n    if(a[0]==1):\n        curr_speed=a[1]\n        if(top>=0 and curr_speed>st[top]):\n            while(curr_speed>st[top] and top>=0):\n                top-=1\n                ans+=1\n        \n    if(a[0]==4):\n        c=0\n    elif(a[0]==6):\n        c+=1\n    if(a[0]==5):\n        top=-1\n        \n    if(a[0]==2):\n        ans+=c\n        c=0\n    if(a[0]==3):\n        if(curr_speed>a[1]):\n            ans+=1\n        else:\n            st[top+1]=a[1]\n            top+=1\nprint(ans)\n", "import collections\nn=int(input())\nx,v=map(int,input().split())\no=collections.deque()\nq=0\nk=0\nfor i in range(1,n):\n    s=input()\n    if s[0]=='1':\n        x,v=map(int,s.split())\n        while len(o)>0 and o[-1]<v:\n            o.pop()\n            k+=1\n    if s[0]=='2':\n        k+=q\n        q=0\n    if s[0]=='3':\n        x,y=map(int,s.split())\n        if v<=y:\n            o.append(y)\n        else:\n            k+=1\n    if s[0]=='4':\n        q=0\n    if s[0]=='5':\n        o.clear()\n    if s[0]=='6':\n        q+=1\nprint(k)", "n = int(input())\nv = int(input()[2:])\np = [1e9]\nd = k = 0\nfor i in range(n - 1):\n    s = input()\n    t = int(s[0])\n    if t == 1:\n        v = int(s[2:])\n        while p[-1] < v:\n            p.pop()\n            k += 1\n    if t == 2:\n        k += d\n        d = 0\n    if t == 3:\n        u = int(s[2:])\n        if v > u: k += 1\n        else: p.append(u)\n    if t == 4: d = 0\n    if t == 5: p = [1e9]\n    if t == 6: d += 1\nprint(k)", "p = [1e9]\nd = k = v = 0\nfor i in range(int(input())):\n    s = input()\n    t = int(s[0])\n    if t == 1:\n        v = int(s[2:])\n        while p[-1] < v:\n            p.pop()\n            k += 1\n    if t == 2: k, d = k + d, 0\n    if t == 3:\n        u = int(s[2:])\n        if v > u: k += 1\n        else: p += [u]\n    if t == 4: d = 0\n    if t == 5: p = [1e9]\n    if t == 6: d += 1\nprint(k)", "n = int(input())\nspeed = 0\novertake_allowed = True\njust_overtake_violation = False\nspeed_signs = []\nviolations = 0\novertake_passed = 0\nfor i in range(n):\n\tarr = [int(a) for a in input().split(' ')]\n\n\tif arr[0] == 1:\n\t\tif arr[1] > speed:\n\t\t\tspeed = arr[1]\n\t\t\tfor j in range(len(speed_signs) - 1, -1, -1):\n\t\t\t\tif speed > speed_signs[j]:\n\t\t\t\t\tviolations += 1\n\t\t\t\t\tdel speed_signs[j]\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tspeed = arr[1]\n\n\tif arr[0] == 2:\n\t\tviolations += overtake_passed\n\t\tovertake_passed = 0\n\n\tif arr[0] == 3:\n\t\tif speed > arr[1]:\n\t\t\tviolations += 1\n\t\telse:\n\t\t\tspeed_signs.append(arr[1])\n\n\tif arr[0] == 4:\n\t\tovertake_passed = 0\n\n\tif arr[0] == 5:\n\t\tspeed_signs = []\n\n\tif arr[0] == 6:\n\t\tovertake_passed += 1\n# print(speed_signs)\n# print(violated_speed)\n# print(overtake_signs)\n# print(violated_overtake)\nprint(violations)", "import math\nfrom collections import Counter, defaultdict\nfrom itertools import accumulate\n\nR = lambda: map(int, input().split())\nn = int(input())\nspl = [math.inf]\not_forbid = 0\nsp = 0\nres = 0\nfor i in range(n):\n    arr = list(R())\n    tp = arr[0]\n    if tp == 1:\n        sp = arr[1]\n        while sp > spl[-1]:\n            spl.pop()\n            res += 1\n    elif tp == 2:\n        if ot_forbid > 0:\n            res += ot_forbid\n            ot_forbid = 0\n    elif tp == 3:\n        if arr[1] >= sp:\n            spl.append(arr[1])\n        else:\n            res += 1\n    elif tp == 4:\n        ot_forbid = 0\n    elif tp == 5:\n        spl = [math.inf]\n    else:\n        ot_forbid += 1\nprint(res)"]
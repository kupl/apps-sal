["a = input().split()\nn = int(a[0])\np = float(a[1])\nt = int(a[2])\nden = 100 ** t\np = round(p * 100 + 1e-9)\nq = 100 - p\nncr = [1 for i in range(2001)]\nfor i in range(1, t + 1):\n        ncr[i] = ncr[i - 1] * (t - i + 1) // i\nans = 0\nfor i in range(2001):\n        ans += min(i, n) * ncr[i] * (p ** i) * (q ** (t - i)) if t >= i else 0\nans /= den\nprint(ans)\n", "def main():\n    tmp = input().split()\n    n, p, t = int(tmp[0]), float(tmp[1]), int(tmp[2])\n    q = 1. - p\n    res = [0.] * (n + 1)\n    res[0] = 1.\n    for _ in range(t):\n        tmp = [x * q for x in res]\n        tmp[-1] = res[-1]\n        for i in range(n):\n            tmp[i + 1] += res[i] * p\n        res = tmp\n    print(sum(x * i for i, x in enumerate(res)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "__author__ = 'PrimuS'\n\nimport decimal\ndecimal.getcontext().prec = 1000\n\ninp = input().split()\n# inp = [417,0.57,742]\nn = int(inp[0])\np = decimal.Decimal(inp[1])\nt = int(inp[2])\n\nfacs = {}\nps = {}\np1s = {}\nfacs[0] = decimal.Decimal(1)\nps[0] = decimal.Decimal(1)\np1s[0] = decimal.Decimal(1)\nfor i in range(1, max(n,t) + 1):\n    facs[i] = facs[i-1] * decimal.Decimal(i)\n    ps[i] = ps[i-1] * p\n    p1s[i] = p1s[i-1] * (1-p)\n\ndef c(n, k):\n    return facs[n] / facs[n-k] / facs[k]\n\n# print(c(2000, 1000))\n\nres = decimal.Decimal(0)\nup = min(n, t)\nif n < t:\n    up = n - 1\n\nfor i in range(1, up + 1):\n    cur = decimal.Decimal(i)\n    cur *= c(t, i)\n    cur *= ps[i]\n    cur *= p1s[t - i]\n    res += cur\n    # print(res)\n\nif n < t:\n    cur2 = t\n    while cur2 >= n:\n        cur = decimal.Decimal(n)\n        cur *= c(cur2 - 1, n - 1)\n        cur *= ps[n]\n        cur *= p1s[cur2 - n]\n        res += cur\n        cur2 -= 1\n        # print(cur, res)\n\n# decimal.getcontext().prec = 15\n# res = decimal.Decimal(res)\nprint(res)", "a, b, c = list(map(float, input().split(' ')))\na = int(a)\nc = int(c)\n#dp[i][j] = probability that after i seconds, ther are j ppl on escalator\ndp = [[0] * (c+1) for _ in range(c+1)]\n\nfor i in range(c+1):\n    for j in range(c+1):\n        if i == 0:\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = 0\n        else:\n            if j > a:\n                dp[i][j] = 0\n            elif j == a:\n                dp[i][j] = dp[i-1][j-1]*b + dp[i-1][j]                \n            else:\n                dp[i][j] = (1-b) * dp[i-1][j] + b * dp[i-1][j-1]\nsumx = 0\nfor i in range(c+1):\n    sumx += i * dp[c][i]\nprint(sumx)\n", "inp = input().split()\nn, p, t = int(inp[0]), float(inp[1]), int(inp[2])\ndp = [[0] * (n + 2) for i in range(t + 2)]\ndp[0][0] = 1.0\nfor i in range(t + 1):\n    for j in range(n + 1):\n        if j == n:\n            dp[i + 1][j] += dp[i][j]\n        else:\n            dp[i + 1][j + 1] += dp[i][j] * p\n            dp[i + 1][j] += dp[i][j] * (1 - p)\nprint(sum(dp[t][i] * i for i in range(n + 1))) \n \n", "def find_expected_people(people_count, probability, seconds):\n    # the probability after i seconds to have k people on the escalator\n    current_row = [0.] * (people_count + 1)\n    current_row[0] = 1.\n\n    for sec in range(1, seconds + 1):\n        next_row = [x * (1. - probability) for x in current_row]\n        next_row[-1] = current_row[-1]\n\n        for person in range(people_count):\n            next_row[person + 1] += current_row[person] * probability\n        current_row = next_row\n\n    return sum(index * value for index, value in enumerate(current_row))\n\n\ndef main():\n    raw_input = input().split()\n    people_count = int(raw_input[0])\n    probability = float(raw_input[1])\n    seconds = int(raw_input[2])\n\n    print(find_expected_people(people_count, probability, seconds))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def find_expected_people(people_count, probability, seconds):\n    # probabilities after i seconds to have k people on the escalator\n    current_row = [0.] * (people_count + 1)\n    current_row[0] = 1.\n\n    for sec in range(1, seconds + 1):\n        # default probabilities for next_row when all stay\n        next_row = [x * (1. - probability) for x in current_row]\n        next_row[-1] = current_row[-1]\n\n        for person in range(people_count):\n            # when person go to escalator\n            next_row[person + 1] += current_row[person] * probability\n\n        current_row = next_row\n\n    return sum(index * value for index, value in enumerate(current_row))\n\n\ndef main():\n    raw_input = input().split()\n    people_count = int(raw_input[0])\n    probability = float(raw_input[1])\n    seconds = int(raw_input[2])\n\n    print(find_expected_people(people_count, probability, seconds))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "xs = input().split()\nn, p, t = int(xs[0]), float(xs[1]), int(xs[2])\ncur, nxt = [0.0] * (n + 1), [0.0] * (n + 1)\ncur[0] = 1.0\nfor i in range(t):\n    nxt[n] = cur[n]\n    for j in range(n):\n        nxt[j] = cur[j] * (1.0 - p)\n    for j in range(n):\n        nxt[j + 1] += cur[j] * p\n    cur, nxt = nxt, cur\nprint(sum(cur[i] * i for i in range(n + 1)))", "def main():\n    a = input().split()\n    n = int(a[0])\n    p = float(a[1])\n    t = int(a[2])\n    z = [0.0] * (t+2)\n    for i in range(t+2):\n        z[i] = [0] * (n+2)\n    l = 0.\n    z[0][0] = 1.\n    for i in range(t+1):\n        for j in range(n+1):\n            if j == n:\n                z[i+1][j] += z[i][j]\n            else:\n                z[i+1][j+1] += z[i][j] * p\n                z[i+1][j] += z[i][j] * (1-p)\n    for j in range(n+1):\n        l += z[t][j] * j\n    print(l)\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\n\ntry:\n    while True:\n        dp = [[0 for j in range(2001)] for i in range(2001)] * 2001\n        n, p, t = map(float, input().split(\" \"))\n        n = int(n)\n        t = int(t)\n        dp[0][0] = 1\n        for i in range(1, t+1, 1):\n            for j in range(0, n+1, 1):\n                if j == n:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] * (1-p)\n                if j > 0:\n                    dp[i][j] += dp[i-1][j-1] * p\n        ans = 0\n        for i in range(n+1):\n            ans += i * dp[t][i]\n        print(ans)\nexcept EOFError:\n    pass", "inputs = [x for x in input().split()]\nn,p,t = int(inputs[0]), float(inputs[1]), int(inputs[2])\n\nsaved = [[0 for _ in range(n)] for _ in range(t)]\nsaved[0][0] = p\n\nfor i in range(1, t):\n    saved[i][0] = saved[i-1][0] + ((1 - saved[i-1][0]) * p)\n\nfor i in range(1, t):\n    for j in range(1, n):\n            saved[i][j] = saved[i - 1][j - 1] * p + (saved[i - 1][j]) * (1 -p)\n\n#print(saved)\nprint(sum(saved[-1]))", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])\n", "n, p, t = list(map(float, input().split()))\nn, t = int(n + 0.5), int(t + 0.5)\nif p < 0.001 or p > 0.999: \n  print(n * p)\n  return\nfrom math import exp, lgamma, log\nprint('%.10f' %sum( exp(i * log(p) + (t - i) * log(1 - p) + lgamma(t + 1) - lgamma(i + 1) - lgamma(t - i + 1)) * min(i, n) for i in range(t + 1))) \n", "n, p, t = input().split()\nn, p = int(n), float(p)\nf = [p] * n + [0]\nfor i in range(int(t) - 1): f = [f[k] * (1 - p) + p * (1 + f[k - 1]) for k in range(n)] + [0]\nprint(f[-2])", "n, p, t = input().split()\nn = int(n)\nt = int(t)\np = float(p)\nans = 0.0\ns = t\nif abs(1.0 - p) > 1e-6:\n    a1 = 1.0\n    for i in range(1, t + 1):\n        a1 = a1 * (t - i + 1) / i if i <= t else 0\n        a1 = a1 * p\n        while (a1 > 1e5) and (s > i):\n            a1 *= (1 - p)\n            s -= 1\n        while (s < i):\n            a1 /= (1 - p)\n            s += 1\n        a2 = (1 - p) ** (s - i)\n        #print(a1, a2, s, i)\n        ans += a1 * a2 * min(i, n)\nelse:\n    ans = min(n, t)\nprint(ans)", "dp=[[0 for i in range(2005)]for i in range(2005)]\nn,p,t=0,0,0\nn,p,t=map(float,input().split())\nn,t=int(n),int(t)\ndp[0][0]=1\nfor i in range(1,t+1):\n\tfor j in range(n+1):\n\t\tif j==n :\n\t\t\tdp[i][j]=dp[i-1][j]\n\t\telse :\n\t\t\tdp[i][j]=dp[i-1][j]*(1-p)\n\t\tif j :\n\t\t\tdp[i][j]+=dp[i-1][j-1]*p\nans=0\nfor i in range(n+1):\n\t# print(i,dp[t][i])\n\tans+=i*dp[t][i]\nprint(ans)", "import sys\n\nn, p, t = list(map(str, sys.stdin.readline().split()))\nn = int(n)\np = float(p)\nt = int(t)\n\ndef CC(nn,k):\n    tmp = n\n    t = max(nn - k, k)\n    for i in range(1, min(nn - k, k) + 1):\n        tmp = tmp * (t + i) * (1 - p) / i\n    if k > nn - k:\n        tmp = tmp * pow(1-p,k + k - nn)\n    return tmp\n\ndef C(n, k):\n    tmp = 1\n    if n - k > k:\n        tmp = tmp * pow(1 - p, n - k - k)\n    else:\n        tmp = tmp * pow(p, k + k - n)\n    t = max(n - k, k)\n    for i in range(1, min(n - k, k) + 1):\n        tmp = tmp * (t + i) * p * (1 - p) / i\n\n    return tmp\n\n\nif n >= t:\n    print(t * p)\nelif p != 1 and p != 0:\n    a = 0\n    b = 0\n    for i in range(n):\n        q = C(t, i)\n        a = a + q * i\n        b = b + q\n    a = a + (1 - b) * n\n    print(a)\n    b = n\n    for i in range(t - n):\n        b = b + CC(i + 1,n + i)\n    b = b * pow(p,n)\n    #print(a + b)\nelse:\n    if p == 1:\n        print(n)\n    else:\n        print(0)\n"]
["#!/usr/bin/env python3\n\nfrom bisect import bisect\n\n[n, k, d] = list(map(int, input().strip().split()))\nais = list(map(int, input().strip().split()))\nif k == 1:\n\tprint ('YES')\n\treturn\n\nais.sort()\n\n# can do ais[i:]\ncando = [False for _ in range(n)]\nj = n - 1  # j is such that a[j] > a[i] + d >= a[j - 1]  (upper_bound) a[:j] <= a[i] + d < a[j:]\ncount = 0  # sum(cando[i + k:j + 1])\nfor i in reversed(list(range(n))):\n\tif i + k < n and cando[i + k]:\n\t\tcount += 1\n\tif n - i < k:\n\t\tcontinue\n\tif ais[-1] - ais[i] <= d:\n\t\tcando[i] = True\n\t\tcontinue\n\twhile ais[j - 1] > ais[i] + d:\n\t\tif cando[j]:\n\t\t\tcount -= 1\n\t\tj -= 1\n\tcando[i] = (count > 0)\n\t\n\nif cando[0]:\n\tprint ('YES')\nelse:\n\tprint ('NO')\n\n", "from bisect import bisect_right, bisect_left\n\n\ndef main():\n    n, k, d = map(int, input().split())\n    sat = [int(x) for x in input().split()]\n\n    sat = sorted(sat)\n    arrange = [False for _ in range(n + 1)]\n    arrange[0] = True\n    s = 0\n    # i means the first i items could be arranged well\n    i = min(bisect_right(sat, sat[s] + d), k)\n    n_arrange = 1 if i - k >= 0 else 0 # arrange[0] == True | the first 0 items\n\n    while i <= n:\n        if i - s >= k and n_arrange > 0:\n            arrange[i] = True\n        if i < n:\n            news = bisect_left(sat, sat[i] - d, s, i)\n            while s < news:\n                if s <= i - k and arrange[s]:\n                    n_arrange -= 1\n                s += 1\n\n        i += 1\n        n_arrange += 1 if (i - k >= s and arrange[i - k]) else 0\n\n    if arrange[n]:\n        print('YES')\n    else:\n        print('NO')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from bisect import bisect_right, bisect_left\n\n\ndef main():\n    n, k, d = list(map(int, input().split()))\n    sat = [int(x) for x in input().split()]\n\n    sat = sorted(sat)\n\n    # arrange[i] means the first i items could be arranged well\n    # arranged well means they could be put into boxes without conflicts\n    arrange = [True] + [False for _ in range(n)]\n\n    s = 0\n\n    # we can put [0, i) items into the first box\n    i = min(bisect_right(sat, sat[s] + d), k)\n\n    # keep the number of True-value in arrange[s, i-k]\n    # there must be at least one point in [s, i-k(included)] which satisfies arrange[this_point] == True\n    # that means we can cut from this_point and put [this_point, i) in a new box\n    # then the result is arrange[i] become True, because now all items before i-index could be arranged well\n    n_arrange = 1 if s <= i - k else 0\n\n    while i <= n:\n        if i - s >= k and n_arrange > 0:\n            arrange[i] = True\n        if i < n:\n            # find new s that we could put | item at new s - item at i | <= d\n            news = bisect_left(sat, sat[i] - d, s, i)\n            while s < news:\n                if s <= i - k and arrange[s]:\n                    n_arrange -= 1\n                s += 1\n\n        i += 1\n        # every time when you count arrange[x] you should keep x between [s, i-k]\n        n_arrange += 1 if (s <= i - k and arrange[i - k]) else 0\n\n    if arrange[n]:\n        print('YES')\n    else:\n        print('NO')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn, k, d = getIntList()\na= getIntList();\na.sort();\nseen=[False]*len(a);\ndef search(a, lowLim):\n    sameLim=bisect.bisect_right(a, a[lowLim]+d);\n    lowLim=max(lowLim, sameLim-2*k);\n    if seen[lowLim]:\n        return False;\n    if len(a)-lowLim<k:\n        return False;\n    if a[len(a)-1]-a[lowLim]<=d:\n        return True;\n    for i in range(lowLim+k-1, len(a)-1):\n        if a[i]-a[lowLim]>d:\n            break;\n        if search(a, i+1):\n            return True;\n    seen[lowLim]=True;\n    return False;\ndef searchFull(a):\n    if a[n-1]-a[n-k]>d:\n        return False;\n    return search(a, 0);\nif k==1:\n    print('YES')\nelif searchFull(a):\n    print('YES')\nelse:\n    print('NO');", "import bisect;\ndef getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn, k, d = getIntList()\na= getIntList();\na.sort();\n#\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0440\u0430\u0437\u0440\u0435\u0437\u0430\u0442\u044c \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0434\u043e j \u043d\u0435 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e - cuttable[j];\ncuttable=[False]*len(a);\ncuttable[0]=True;\ndef search(a):\n    curr=0;\n    maxOne=0;\n    while True:\n        #print(curr);\n        if cuttable[curr]:\n            #\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0434\u0440\u0435\u0437\u043e\u043a \u0434\u043b\u0438\u043d\u044b \u043a\u0430\u043a \u043c\u0438\u043d\u0438\u043c\u0443\u043c k: [curr, curr+k)\n            lowLim=curr+k;\n            #\u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043f\u0435\u0440\u0432\u044b\u0439 \u0442\u0430\u043a\u043e\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 upLim, \u0447\u0442\u043e a[upLim]-a[curr]>d;\n            upLim=bisect.bisect_right(a, a[curr]+d);\n            #\u0415\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043d\u0435\u0442, \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e\n            if upLim==len(a):\n                return True;\n            #\u0421\u0442\u0430\u0432\u0438\u0442\u044c \u0435\u0434\u0438\u043d\u0438\u0447\u043a\u0438 \u043d\u0430 \u0443\u0436\u0435 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u044b\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0431\u0435\u0441\u0441\u043c\u044b\u0441\u043b\u0435\u043d\u043d\u043e\n            lowLim=max(lowLim, maxOne+1);\n            #print('cuttable', lowLim, upLim);\n            #a[upLim-1]-a[curr]<=d, \u0437\u043d\u0430\u0447\u0438\u0442 cuttable[upLim]=True;\n            for i in range(lowLim, upLim+1):\n                cuttable[i]=True;\n            maxOne=upLim;\n        curr+=1;\n        if curr>len(a)-k:\n            break;\n    return False;\nif k==1:\n    print('YES')\nelif search(a):\n    print('YES')\nelse:\n    print('NO');", "def getIntList():\n    return list(map(int, input().split()));\ndef getTransIntList(n):\n    first=getIntList();\n    m=len(first);\n    result=[[0]*n for _ in range(m)];\n    for i in range(m):\n        result[i][0]=first[i];\n    for j in range(1, n):\n        curr=getIntList();\n        for i in range(m):\n            result[i][j]=curr[i];\n    return result;\nn, k, d = getIntList()\na= getIntList();\na.sort();\n#\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0440\u0430\u0437\u0440\u0435\u0437\u0430\u0442\u044c \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0434\u043e j \u043d\u0435 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e - cuttable[j];\ncuttable=[False]*len(a);\ncuttable[0]=True;\ndef search(a):\n    curr=0;\n    upLim=0;\n    upLimPrev=0;\n    while True:\n        #print(curr);\n        if cuttable[curr]:\n            #\u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0434\u0440\u0435\u0437\u043e\u043a \u0434\u043b\u0438\u043d\u044b \u043a\u0430\u043a \u043c\u0438\u043d\u0438\u043c\u0443\u043c k: [curr, curr+k)\n            lowLim=curr+k;\n            upLimPrev = upLim;\n            #\u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043f\u0435\u0440\u0432\u044b\u0439 \u0442\u0430\u043a\u043e\u0439 \u0438\u043d\u0434\u0435\u043a\u0441 upLim, \u0447\u0442\u043e a[upLim]-a[curr]>d;\n            while upLim<len(a) and a[upLim]-a[curr]<=d:\n                upLim+=1;\n            #\u0415\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043d\u0435\u0442, \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e\n            if upLim==len(a):\n                return True;\n            #\u0421\u0442\u0430\u0432\u0438\u0442\u044c \u0435\u0434\u0438\u043d\u0438\u0447\u043a\u0438 \u043d\u0430 \u0443\u0436\u0435 \u043f\u0440\u043e\u0439\u0434\u0435\u043d\u044b\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0431\u0435\u0441\u0441\u043c\u044b\u0441\u043b\u0435\u043d\u043d\u043e\n            lowLim=max(lowLim, upLimPrev+1);\n            #print('cuttable', lowLim, upLim);\n            #a[upLim-1]-a[curr]<=d, \u0437\u043d\u0430\u0447\u0438\u0442 cuttable[upLim]=True;\n            for i in range(lowLim, upLim+1):\n                cuttable[i]=True;\n        curr+=1;\n        if curr>len(a)-k:\n            break;\n    return False;\nif k==1:\n    print('YES')\nelif search(a):\n    print('YES')\nelse:\n    print('NO');", "from bisect import bisect\n\n\ndef main():\n    n, k, d = list(map(int, input().split()))\n    if k == 1:\n        print('YES')\n        return\n    l = []\n    ll = [l]\n    a = 10 ** 10\n    for b in sorted(map(int, input().split())):\n        if a < b:\n            if len(l) < k:\n                print('NO')\n                return\n            l = [b]\n            ll.append(l)\n        else:\n            l.append(b)\n        a = b + d\n\n    def f(a):\n        def dfs(i):\n            avail[i] = False\n            if i + k <= le:\n                if a[-1] <= a[i] + d:\n                    raise TabError\n                j = bisect(a, a[i] + d, i, -1) - 1\n                for j in range(bisect(a, a[i] + d, i, -1), i + k - 1, -1):\n                    if avail[j]:\n                        dfs(j)\n\n        le = len(a)\n        avail = [True] * le\n        try:\n            dfs(0)\n        except TabError:\n            return True\n        return False\n\n    print(('NO', 'YES')[all(map(f, ll))])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k, d = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nb = [0] * n\ni = j = 0\nfor i in range(n):\n    while a[i] - a[j] > d:\n        j += 1\n    b[i] = j\nc = [0] * n\n# d = [0] * n\nfor i in range(k - 1, n):\n    # print(f'i={i}, b[i]={b[i]}, i-b[i]+1={i - b[i] + 1}, i-k={i-k}, c[i-k]={c[i-k]}, c[b[i]]={c[b[i]]}')\n    # print(i - k, b[i] - 2)\n    if i - b[i] + 1 >= k and (b[i] == 0 or c[i - k] > c[b[i] - 2] or (b[i] == 1 and c[i-k]> c[0])):\n        c[i] = c[i - 1] + 1\n        # d[i] = 1\n    else:\n        c[i] = c[i - 1]\n# print(a)\n# print(b)\n# print(d)\n# print(c)\nprint('YES' if n < 2 or c[n - 1] > c[n - 2] else 'NO')", "n, k, d = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nb = [0] * n\ni = j = 0\nfor i in range(n):\n    while a[i] - a[j] > d:\n        j += 1\n    b[i] = j\nc = [0] * n\nfor i in range(k - 1, n):\n    c[i] = c[i - 1] + int(i - b[i] + 1 >= k and (b[i] == 0 or c[i - k] > c[b[i] - 2] or (b[i] == 1 and c[i-k]> c[0])))\nprint('YES' if n < 2 or c[n - 1] > c[n - 2] else 'NO')", "n,k,d=list(map(int,input().split()))\na=sorted(list(map(int,input().split())))\nb=[0]*n\ni=j=0\nfor i in range(n):\n    while a[i]-a[j]>d:j+=1\n    b[i]=j\nc=[0]*n\nfor i in range(k-1,n):c[i]=c[i-1]+int(i-b[i]+1>=k and (b[i]==0 or c[i-k]>c[b[i]-2] or (b[i]==1 and c[i-k]>c[0])))\nprint('YES' if n<2 or c[n-1]>c[n-2] else 'NO')", "#Bhargey Mehta (Junior)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open('input.txt', 'r')\nMOD = 998244353\nsys.setrecursionlimit(1000000)\n\ndef check(i):\n    if not dp[i][2]: return False\n    if i < 0: return True\n    return check(i-dp[i][1])\n \nn, k, d = map(int, input().split())\nif k == 1:\n    print('YES')\n    return\na = sorted(map(int, input().split()))\ndp = [None for i in range(n)]\ndp[0] = (a[0], 1, False)\nfor i in range(1, n):\n    if a[i]-dp[i-1][0] <= d:\n        dp[i] = (dp[i-1][0], dp[i-1][1]+1, dp[i-1][1]+1 >= k)\n    else:\n        dp[i] = (a[i], 1, False)\n        j = i\n        while a[i]-a[j] <= d and j > 0:\n            j -= 1\n            if dp[j][2]:\n                dp[i] = (a[j+1], i-j, i-j >= k)\n            if dp[i][2]: break\nprint('YES' if check(n-1) else 'NO')", "def bi_search(a, x):\n    n = len(a)\n    u, l = n, -1\n    \n    while u-l>1:\n        md=(u+l)//2\n        \n        if x>a[md]:\n            l=md\n        else:\n            u=md\n    \n    return u \n\nclass Bit():\n    # index-1\n    def __init__(self, n):\n        self.bit = [0] * (n+1) \n        self.n   = n\n    \n    # sum[1, i]\n    def sum_prefix(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i&(-i)\n        return s\n        \n    # sum[l, r]    \n    def sum_(self, l, r):\n        if l == 1:\n            return self.sum_prefix(r)\n        return self.sum_prefix(r) - self.sum_prefix(l-1) \n        \n    def add(self, i, x):\n        while i <= self.n:\n            self.bit[i] += x\n            i += i&(-i)\n\nn, k, d = map(int, input().split())\na = [-1] + list(map(int, input().split()))\na = sorted(a)\n\nB=Bit(n) \nans=[-1] * n \n\nfor i in range(n+1):\n    if i==0:\n        continue\n        \n    pos  = bi_search(a, max(0, a[i]-d)) #pos,   i-k+1..,i-1,i\n    \n    l, r = pos-1, i-k\n    \n    if l<=r:\n        s=0\n        \n        if l>=1:\n            s+=B.sum_(l, r)\n        \n        if l==0 or s > 0:\n            B.add(i, 1)\n            ans[i-1]=1\n            \nif ans[-1]==1:\n    print('YES')\nelse:\n    print('NO')", "def main():\n    import sys\n    from bisect import bisect_left\n    input = sys.stdin.readline\n\n    N, K, D = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    A.sort()\n\n    part = [0] * (N+2)\n    part[0] = 1\n    part[1] = -1\n    for i, a in enumerate(A):\n        part[i] += part[i-1]\n        if part[i]:\n            j = bisect_left(A, a+D+1)\n            if j >= i+K:\n                part[i+K] += 1\n                part[j+1] -= 1\n    part[N] += part[N-1]\n    if part[N]:\n        print('YES')\n    else:\n        print('NO')\n    #print(A)\n    #print(part)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect\nimport sys\ninput = sys.stdin.readline\n\n\nclass SegmentTree():\n    def __init__(self, n, op, e):\n        self.n = n\n        self.op = op\n        self.e = e\n        self.size = 2 ** ((n - 1).bit_length())\n        self.node = [self.e] * (2 * self.size)\n\n    def built(self, array):\n        for i in range(self.n):\n            self.node[self.size + i] = array[i]\n        for i in range(self.size - 1, 0, -1):\n            self.node[i] = self.op(self.node[i << 1], self.node[(i << 1) + 1])\n\n    def update(self, i, val):\n        i += self.size\n        self.node[i] = val\n        while i > 1:\n            i >>= 1\n            self.node[i] = self.op(self.node[i << 1], self.node[(i << 1) + 1])\n\n    def get_val(self, l, r):\n        l, r = l + self.size, r + self.size\n        res_l, res_r = self.e, self.e\n        while l < r:\n            if l & 1:\n                res_l = self.op(res_l, self.node[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res_r = self.op(self.node[r], res_r)\n            l, r = l >> 1, r >> 1\n        return self.op(res_l, res_r)\n\n\nn, k, d = map(int, input().split())\na = list(map(int, input().split()))\na = sorted(a)\n\nst = SegmentTree(n + 1, lambda a, b : a | b, 0)\nst.update(0, 1)\nfor i in range(n):\n    tmp = bisect.bisect_left(a, a[i] - d)\n    if tmp >= max(i + 2 - k, 0):\n        continue\n    st.update(i + 1, st.get_val(tmp, max(i + 2 - k, 0)))\n\nif st.get_val(n, n + 1) == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx - self.N0\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx]):\n                    idx = 2*idx\n                else:\n                    idx = 2*idx + 1\n            return idx - self.N0\n\nN, K, D = list(map(int, readline().split()))\nA = list(map(int, readline().split()))\nA.sort()\nlm = [None]*N\nfor i in range(N):\n    a = A[i]\n    ok = i\n    ng = -1\n    while abs(ok-ng) > 1:\n        med = (ok+ng)//2\n        if a-A[med] <= D:\n            ok = med\n        else:\n            ng = med\n    lm[i] = ok\n\nT = Segtree([None]*(N+1), 0, initialize = False, segf = max)\nT.update(0, 1)\nfor i in range(N):\n    rm = i-K+2\n    if rm <= lm[i]:\n        continue\n    if T.query(lm[i], rm):\n        T.update(i+1, 1)\n\nprint('YES' if T.query(N, N+1) else 'NO')\n\n", "import heapq\n\ndef run():\n    n, k, d = list(map(int, input().split()))\n    a = sorted(map(int, input().split()))\n\n    max_size = [None] * n  # how many pencils can be in box starting with this one\n    start = 0\n    end = 0\n    while start < n:\n        while end < n-1 and a[end+1] - a[start] <= d:\n            end += 1\n        max_size[start] = end - start + 1\n        start += 1\n\n    possilbe_starts = []\n    # heap with starts and stops of intervals where new box can start\n    # - all pencils before that are successfully boxed\n    heapq.heappush(possilbe_starts, (0, \"start\"))\n    heapq.heappush(possilbe_starts, (1, \"stop\"))\n\n    number_of_opened = 0  # number of opened intervals\n\n    for pencil in range(n):\n        while possilbe_starts and possilbe_starts[0][0] <= pencil:\n            top = heapq.heappop(possilbe_starts)\n            number_of_opened += (1 if top[1] == \"start\" else -1)\n        if number_of_opened <= 0:\n            continue\n        if max_size[pencil] < k:\n            continue\n        if pencil + max_size[pencil] + 1 > n:\n            print(\"YES\")\n            break\n        heapq.heappush(possilbe_starts, (pencil + k, \"start\"))\n        heapq.heappush(possilbe_starts, (pencil + max_size[pencil] + 1, \"stop\"))\n    else:\n        print(\"NO\")\n\nrun()\n", "import sys\n\nn, k, d = list(map(int, input().split()))\na = [0] + sorted(map(int, input().split()))\ndp = [1] + [0]*n\nj = k\n\nfor i in range(n):\n    if dp[i] == 0:\n        continue\n    j = max(j, i+k)\n    while j <= n and a[j] - a[i+1] <= d:\n        dp[j] |= dp[i]\n        j += 1\n\nprint('YES' if dp[-1] else 'NO')\n"]
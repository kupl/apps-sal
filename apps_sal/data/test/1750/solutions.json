["import sys\nsys.setrecursionlimit(200000)\n\nn = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n\ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(\" \".join(map(str, colored)))", "import sys\nsys.setrecursionlimit(200000)\n\nn = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n\ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(\" \".join(map(str, colored)))", "import sys\nsys.setrecursionlimit(200000)\n\nn=int(input())\ng=[[] for i in range(n)]\nfor i in range(n-1):\n    a,b=map(int, input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\ns = max([len(p) for p in g]) + 1\nprint(s)\nr=[0]*n\ndef dfs(v,c,d):\n    r[v]=p=c\n    for u in g[v]:\n        if not r[u]:\n            c=c+1 if c<s else 1\n            if c==d:\n                c=c+1 if c<s else 1\n            dfs(u,c,p)\nif s>3:\n    dfs(0, 1, 0)\nelse:\n    i=0\n    c=1\n    while len(g[i])!=1:\n        i+=1\n    for j in range(n):\n        r[i]=c\n        c=c+1 if c<s else 1\n        if j<n-1:\n            i=g[i][0] if not r[g[i][0]] else g[i][1]\nprint(\" \".join(map(str, r)))", "#!/usr/bin/env python3\n\nfrom collections import deque\n\n\n\ndef ri():\n\n    return list(map(int, input().split()))\n\n\n\nn = int(input())\n\nv = [0]*n\n\nc = [0]*n\n\np = [0]*n\n\nadj = [set() for i in range(n)]\n\nfor i in range(n-1):\n\n    a, b = ri()\n\n    a -= 1\n\n    b -= 1\n\n    adj[a].add(b)\n\n    adj[b].add(a)\n\nfor s in range(n):\n\n    if len(adj[s]) == 1:\n\n        break\n\nans = 0\n\nq = deque()\n\nq.append(s)\n\nv[s] = 1\n\nc[s] = 1\n\np[s] = s\n\nwhile q:\n\n    n = q.popleft()\n\n    cc = 1\n\n    for a in adj[n]:\n\n        if v[a] == 0:\n\n            while cc in [c[n], c[p[n]]]:\n\n                cc+=1\n\n            c[a] = cc\n\n            cc+=1\n\n            ans = max(2+len(adj[a])-1, ans)\n\n            q.append(a)\n\n            p[a] = n\n\n            v[a] = 1\n\nprint(ans)\n\nprint(\" \".join(map(str,c)))\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "from sys import stdin\nfrom collections import deque\n\n\ndef main():\n    n = int(input()) + 1\n    g = [[] for _ in range(n)]\n    for s in range(n-2):\n        u, v = list(map(int, input().split()))\n        g[u].append(v)\n        g[v].append(u)\n    cc, palette, q = [0] * n, [True] * n, deque(((1, 0, 1),))\n    cc[1] = 1\n    while q:\n        u, a, b = q.popleft()\n        \n        c = 1\n        for v in g[u]:\n            if not cc[v]:\n                while c in [a,b]:\n                    c += 1\n                cc[v] = c\n                q.append((v, b, c))\n                c += 1\n        \n    print(max(cc))\n    print(' '.join(map(str, cc[1:])))\n\n\ndef __starting_point():\n    main()\n        \n\n__starting_point()", "from collections import deque\n\nn = int(input())\n\nans = [0]*n\n\ng = [[]for _ in range(n)]\n\nfor _ in range(n - 1):\n  u, v = list(map(int, input().split()))\n  u -= 1\n  v -= 1\n  g[u].append(v)\n  g[v].append(u)\n\ncol = 1\nq = deque()\nvis = [False]*n\n\nq.append((0, 0))\nvis[0] = True\nans[0] = 1\np_top = 0\n\nwhile q:\n  top, p_top = q.popleft()\n  col = 1\n  for viz in g[top]:\n    if not vis[viz]:\n      vis[viz] = True\n      q.append((viz, top))\n      while ans[top] == col or ans[p_top] == col:\n        col += 1\n      ans[viz] = col\n      col += 1\n\nprint(max(ans))\nprint(\" \".join(map(str, ans)))\n", "import collections\ndef doit():\n    # rows = [[] for y in range(M)]\n    rows = dict()\n\n    N = int(input())\n    graph = dict()\n    for n in range(N) :\n        graph[n] = list()\n\n    for n in range(N - 1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    msize = 0\n    for k in graph:\n        msize = max(msize, len(graph[k]))\n    print(msize+1)\n\n\n    root = 0\n    colors = [0 for x in range(N)]\n    colors[root] = 1\n    parents = [0 for x in range(N)]\n    parents[root] = root\n\n\n    def color(c1, c2):\n        colorindex = 0\n        while colorindex < msize + 1:\n            colorindex += 1\n            if colorindex == c1 or colorindex == c2:\n                continue\n            yield colorindex\n\n\n    # visited = set()\n    # visited.add(root)\n    queue = collections.deque([root])\n    while queue:\n        vertex = queue.popleft()\n        # newcolors = [c for c in range(1, msize+2) if c != colors[vertex] and c != colors[parents[vertex]] ]\n        # newcolors = filter(lambda c: c != colors[vertex] and c != colors[parents[vertex]], range(1, msize+2))\n        #\n        # print(f'newcolors={newcolors}')\n        colorgen = color(colors[vertex], colors[parents[vertex]])\n        for neighbour in graph[vertex]:\n            if neighbour == parents[vertex]:\n                continue\n            parents[neighbour] = vertex\n            colors[neighbour] = next(colorgen)\n            # visited.add(neighbour)\n            queue.append(neighbour)\n    print(\" \".join(map(str, colors)))\n\ndoit()", "import collections\ndef doit():\n    N = int(input())\n    graph = dict()\n    for n in range(N) :\n        graph[n] = list()\n\n    for n in range(N - 1):\n        a, b = map(int, input().split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    msize = 0\n    for k in graph:\n        msize = max(msize, len(graph[k]))\n    print(msize+1)\n\n    root = 0\n\n    colors = [0 for x in range(N)]\n    colors[root] = 1\n    parents = [0 for x in range(N)]\n    parents[root] = root\n\n    def colorgenerator(c1, c2):\n        colorindex = 0\n        while colorindex < msize + 1:\n            colorindex += 1\n            if colorindex == c1 or colorindex == c2:\n                continue\n            yield colorindex\n\n    queue = collections.deque([root])\n    while queue:\n        vertex = queue.popleft()\n        color = colorgenerator(colors[vertex], colors[parents[vertex]])\n        for neighbour in graph[vertex]:\n            if neighbour == parents[vertex]:\n                continue\n\n            parents[neighbour] = vertex\n            colors[neighbour] = next(color)\n            queue.append(neighbour)\n    print(\" \".join(map(str, colors)))\n\ndoit()", "from collections import deque\n\nn = int(input())\ng = []\nvisited = []\ncolor = []\nmax_child_color = []\nparent = []\n\ndef initialize():\n    for i in range(n+10):\n        g.append([])\n        visited.append(False)\n        color.append(0)\n        max_child_color.append(0)\n        parent.append(0)\n    for i in range(n-1):\n        u, v = map(int, input().split())\n        g[u] += [v]\n        g[v] += [u]\n    # print(g)\n\ndef get_color(u):\n    for i in range(max_child_color[u]+1, n+1):\n        if i != color[parent[u]] and i != color[u]:\n            max_child_color[u] = i\n            # print(f'Setting max child color of node = {u} to color {i}')\n            return i\n\ndef bfs(start):\n    visited[start] = True\n    color[start] = 1\n    q = deque()\n    q.append(start)\n    while q:\n        u = q.popleft()\n        for v in g[u]:\n            parent[v] = u\n            if not visited[v]:\n                visited[v] = True\n                color[v] = get_color(u)\n                q.append(v)\n\ndef __starting_point():\n    initialize()\n    bfs(1)\n    print(max(color))\n    c_string = \"\"\n    for i in range(1, n+1):\n        c_string += str(color[i]) + \" \"\n    print(c_string)\n__starting_point()", "import sys\nsys.setrecursionlimit(100000)\nfrom collections import deque\n\nUNDEF = 0\n\nn = int(input())\ng = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nc = [UNDEF] * (n + 1)\nc[1] = 1\n\ndef dfs(par, v):\n    cur = 1\n    for to in g[v]:\n        if c[to] != UNDEF:\n            continue\n        while cur in (c[par], c[v]):\n            cur += 1\n        c[to] = cur\n        cur += 1\n        dfs(v, to)\n\ndef bfs():\n    q = deque([(0, 1)])\n    while q:\n        cur = 1\n        par, v = q.pop()\n        for to in g[v]:\n            if c[to] != UNDEF:\n                continue\n            while cur in (c[par], c[v]):\n                cur += 1\n            c[to] = cur\n            cur += 1\n            q.appendleft((v, to))\n\nbfs()\nprint('%d\\n%s' % (max(c), ' '.join(map(str, c[1:]))))", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef bfs():\n    visited = [False]*n\n    visited[0] = True\n    color = [-1]*n\n    color[0] = 1\n    q = deque([(0, 1, -1)])\n\n    while q:\n        v, pre_c1, pre_c2 = q.popleft()\n        cnt = 1\n        \n        for nv in G[v]:\n            if visited[nv]:\n                continue\n            \n            while cnt==pre_c1 or cnt==pre_c2:\n                cnt += 1\n            \n            color[nv] = cnt\n            cnt += 1\n            q.append((nv, color[v], color[nv]))\n            visited[nv] = True\n    \n    return color\n\nn = int(input())\nG = [[] for _ in range(n)]\n\nfor _ in range(n-1):\n    x, y = map(int, input().split())\n    G[x-1].append(y-1)\n    G[y-1].append(x-1)\n\ncolor = bfs()\n\nprint(max(color))\nprint(*color)", "from collections import defaultdict,deque\nclass Graph:\n    def __init__(self,n):\n        self.graph = defaultdict(list)\n        self.parentColor = [-1] * (n+1)\n        self.color = [-1] * (n+1)\n        self.visited = [False] * (n+1)\n        self.n = n\n    def addEdge(self,fr,to):\n        self.graph[fr].append(to)\n        self.graph[to].append(fr) \n    def BFS(self,root):\n        queue = deque()\n        queue.append(root)\n        self.color[root] = 1\n        self.parentColor[root] = 0\n        while(queue):\n            s = queue.popleft()\n            Set = defaultdict(bool)\n            Set[self.color[s]] = True\n            Set[self.parentColor[s]] = True\n            culur = 1\n            for i in self.graph[s]:\n                if(self.visited[i] == False):\n                    queue.append(i)\n                    self.parentColor[i] = self.color[s]\n                    while(1):\n                        if(not Set[culur]):\n                            self.color[i] = culur\n                            culur+=1\n                            break\n                        culur+=1\n            self.visited[s] = True\n    def show(self):\n        print(max(self.color))\n        print(*self.color[1:])\n\nn = int(input())\nG = Graph(n)\nfor _ in range(n-1):\n    a,b = map(int,input().split())\n    G.addEdge(a,b)\nG.BFS(1)\nG.show()", "from collections import deque\nn = int(input())\ndic = {}\nfor i in range(n):\n\tdic[i]=[]\nfor i in range(n-1):\n\ta,b = map(int,input().split())\n\tdic[a-1].append(b-1)\n\tdic[b-1].append(a-1)\ncolor = {}\nprevcolor = {}\ncolor[0] = 1\nprevcolor[0] = 1\nlis = deque()\nlis.append(0)\nvisited = {}\nwhile(len(lis)!=0):\n\tt = lis.popleft()\n\tcol = 0\n\tvisited[t] = 1\n\tprev = prevcolor[t]\n\tfor i in dic[t]:\n\t\ttry:\n\t\t\tz = visited[i]\n\t\texcept:\n\t\t\twhile(col==prev or col==color[t] or col==prevcolor[t]):\n\t\t\t\tcol+=1\n\t\t\tcolor[i] = col\n\t\t\tprevcolor[i] = color[t]\n\t\t\tlis.append(i)\n\t\t\tprev = col\n\nprint(max(color.values())+1)\nfor i in range(n):\n\tprint(color[i]+1,end=\" \")", "import sys\nsys.setrecursionlimit(200000)\n \nn = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n \ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(\" \".join(map(str, colored)))", "n = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n \ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(\" \".join(map(str, colored)))", "import sys\nn = int(sys.stdin.readline())\ne = dict()\nw = dict()\nfor i in range(1, n+1):\n    w[i] = -1\n    e[i] = set()\n\nfor i in range(n-1):\n    (a, b) = map(int, sys.stdin.readline().split())\n    e[a].add(b)\n    e[b].add(a)\n\n\n\nfirst = 0\nfor i in e:\n    if len(e[i]) == 1:\n        first = i\n        break\n\n\nsosed = set()\nposetil = set()\nsosed.add(first)\nposetil.add(first)\nw[first] = 1\n\nwhile len(sosed) > 0:\n    sosed2 = set()\n    for i in sosed:\n        NO = set()\n        NO.add(w[i])\n        bad = set()\n        for j in e[i]:\n            if len(e[j]) > 1:\n                sosed2.add(j)\n            if w[j] != -1:\n                NO.add(w[j])\n            else:\n                bad.add(j)\n        x = 1\n        for j in bad:\n            if w[j] == -1:\n                while x in NO:\n                    x += 1\n                w[j] = x\n                NO.add(x)\n        posetil.add(i)\n    sosed2 -= posetil\n    sosed = sosed2.copy()\nans = []\nlol = set()\nfor i in range(1, n+1):\n    ans.append(w[i])\n    lol.add(w[i])\nprint(len(lol))\nprint(*ans)", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn=int(input())\ngraph={i:set() for i in range(n)}\nfor i in range(n-1):\n\ta,b=list(map(int,input().split()))\n\tgraph[a-1].add(b-1)\n\tgraph[b-1].add(a-1)\nma=0\nfor i in graph:\n\tif len(graph[i])+1>ma:\n\t\tma=len(graph[i])+1\n\t\tx=i\nprint(ma)\nans=[0 for i in range(n)]\nstack=[x]\npapa=[0 for i in range(n)]\nwhile stack:\n\tx=stack.pop()\n\t# z=set(s)\n\ta=1\n\tif ans[x]==0:\n\t\tans[x]=1\n\t\tz=[1]\n\telse:\n\t\tz=[]\n\t\tz.append(ans[x])\n\t\tz.append(ans[papa[x]])\n\tfor j in graph[x]:\n\t\twhile 1:\n\t\t\tif a in z:\n\t\t\t\ta+=1\n\t\t\telse:\n\t\t\t\tans[j]=a\n\t\t\t\ta+=1\n\t\t\t\tbreak\n\t\tstack.append(j)\n\t\tgraph[j].remove(x)\n\t\tpapa[j]=x\nprint(*ans)\n", "from sys import stdin\ninput = stdin.readline\n\ndef put():\n    return map(int, input().split())\n\ndef dfs():\n    s = [(0,0)]\n    tree[0].append(1)\n    while s:\n        i,p = s.pop()\n        c = 1\n        for j in tree[i]:\n            if j!=p:\n                s.append((j,i))\n                while c in [color[i], color[p]]:\n                    c+=1\n                color[j]=c\n                c+=1\n                \n\n\nn = int(input())\ntree = [[] for i in range(n+1)]\ncolor= [0]*(n+1)\nfor _ in range(n-1):\n    x,y = put()\n    tree[x].append(y)\n    tree[y].append(x)\n\nans = 0\nfor i in range(1,n+1):\n    ans = max(ans, len(tree[i])+1)\n\ndfs()\nprint(ans)\nprint(*color[1:])", "n=int(input())\nfrom collections import defaultdict,deque\ng=defaultdict(list)\nfrom sys import stdin\nfor i in range(n-1):\n    h,m=list(map(int, stdin.readline().split()))\n    g[h-1].append(m-1)\n    g[m-1].append(h-1)\nvis=[0]*n\nc=[0]*n\nc[0]=1\nq=deque()\nq.append(0)\nwhile q:\n    node=q.popleft()\n    vis[node]=1\n    s=set()\n    for i in g[node]:\n        if vis[i]==1:\n            s.add(c[i])\n    p=[]\n    s.add(c[node])\n    l=len(s)\n    j=0\n    k=1\n    while l+j<=len(g[node])+2:\n        r=0\n        while r==0:\n            if k not in s:\n                p.append(k)\n                r=1\n            k+=1\n        j+=1\n    j=0\n    for i in g[node]:\n        if vis[i]==0:\n            c[i]=p[j]\n            j+=1\n            q.append(i)\n\nprint(max(c))\nprint(*c)\n        \n            \n", "n=int(input())\nfrom collections import defaultdict,deque\ng=defaultdict(list)\nfrom sys import stdin\nfor i in range(n-1):\n    h,m=list(map(int, stdin.readline().split()))\n    g[h-1].append(m-1)\n    g[m-1].append(h-1)\nvis=[0]*n\nc=[0]*n\nc[0]=1\nq=deque()\nq.append(0)\nwhile q:\n    node=q.popleft()\n    vis[node]=1\n    s=set()\n    for i in g[node]:\n        if vis[i]==1:\n            s.add(c[i])\n    p=[]\n    s.add(c[node])\n    l=len(s)\n    j=0\n    k=1\n    while l+j<=len(g[node])+2:\n        r=0\n        while r==0:\n            if k not in s:\n                p.append(k)\n                r=1\n            k+=1\n        j+=1\n    j=0\n    for i in g[node]:\n        if vis[i]==0:\n            c[i]=p[j]\n            j+=1\n            q.append(i)\n\nprint(max(c))\nprint(*c)\n        \n            \n", "import sys\ninput = sys.stdin.readline\ndef dfs():\n    stack = [(0,0)]\n    d[0].append(1)\n    while stack:\n        i,p = stack.pop()\n        c = 1\n        for j in d[i]:\n            if j != p:\n                stack.append((j,i))\n                while c in {color[i],color[p]}:\n                    c = c+1\n\n                color[j] = c\n                c = c+1\n\n\nn = int(input())\nd = {}\nd[0] = []\nfor _ in range(n-1):\n    x,y = map(int,input().split())\n    if x in d:\n        d[x].append(y)\n\n    else:\n        d[x] = [y]\n\n    if y in d:\n        d[y].append(x)\n\n    else:\n        d[y] = [x]\n\nm = 0\nfor i in d:\n    if len(d[i]) > m:\n        m = len(d[i])\n\nans = m+1\ncolor = [-1]*(n+1)\ndfs()\nprint(ans)\nprint(*color[1:])"]
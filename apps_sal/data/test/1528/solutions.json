["import sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nn,x = list(map(int, input().split()))\n\na,p = [1],[1]\nfor i in range(n):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\ndef f(n, x):\n    if n == 0:\n        return 0 if x <= 0 else 1\n    elif x <= 1 + a[n - 1]:\n        return f(n - 1, x - 1)\n    else:\n        return p[n - 1] + 1 + f(n - 1, x - 2 - a[n-1])\n\nprint((f(n, x)))\n", "# \u30ec\u30d9\u30ebL\u306eN\u756a\u76ee\ndef solve(L,N):\n    if L == 0:\n        return 1\n    if N == 1:\n        return 0\n    elif N <= 2**(L+1)-2:\n        return solve(L-1,N-1)\n    elif N == int(2**(L+1)-1):\n        return 2**L\n    return solve(L-1,N-2**(L+1)+1)+2**L\n    \n\nN,X = map(int,input().split())\nprint(solve(N,X))", "N,X = map(int,input().split())\nsiz = [1]\npat = [1]\nfor i in range(N):\n    siz.append(siz[-1]*2 + 3)\n    pat.append(pat[-1]*2 + 1)\n\ndef rec(n,x):\n    if n==0:\n        ret = int(x>0)\n    elif x <= 1 + siz[n-1]:\n        ret = rec(n-1, x-1)\n    else:\n        ret = pat[n-1] + 1 + rec(n-1, x-2-siz[n-1])\n    return ret\nprint(rec(N,X))", "import sys\nsys.setrecursionlimit(10**5)\nN, X = map(int, input().split())\n\nlayers = [1]\npatties = [1]\n\nfor i in range(1, N+1):\n\tlayer_i = 2 * layers[i-1] + 3\n\tpatty_i = 2 * patties[i-1] + 1\n\tlayers.append(layer_i)\n\tpatties.append(patty_i)\n\t\ndef f(n, x):\n\tif x == 1:\n\t\treturn 1 if n == 0 else 0\n\t\t\n\telif 1 < x <= 1 + layers[n-1]:\n\t\treturn f(n-1, x-1)\n\t\t\n\telif x == 2 + layers[n-1]:\n\t\treturn patties[n-1] + 1\n\t\t\n\telif 2 + layers[n-1] < x <= 2 + 2 * layers[n-1]:\n\t\treturn patties[n-1] + 1 + f(n-1, x-2-layers[n-1])\n\t\t\n\telse:\n\t\treturn 2 * patties[n-1] + 1\n\t\t\nprint(f(N, X))", "n, x = list(map(int, input().split()))\n\np = [0] * -~n\nl = [0] * -~n\n\np[0] = 1\nl[0] = 1\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] * 2 + 1\n    l[i] = l[i - 1] * 2 + 3\n\n# \u30d0\u30fc\u30ac\u30fc\u306e\u9577\u3055\u306f\u5947\u6570\n\n\ndef rec(m, y):\n    if y <= 0:\n        return 0\n    if m == 0:\n        return 1\n    h = l[m] // 2  # \u30ec\u30d9\u30ebm\u306e\u534a\u5206\u3088\u308a\u5de6\u5074\u306e\u9577\u3055\n    if h < y:  # \u771f\u3093\u4e2d\u542b\u3080\n        return 1 + p[m - 1] + rec(m - 1, y - h - 1)\n    else:\n        return rec(m - 1, y - 1)\n\n\nprint((rec(n, x)))\n", "n, x = list(map(int, input().split()))\n\np = [0] * -~n\nl = [0] * -~n\n\np[0] = 1\nl[0] = 1\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] * 2 + 1\n    l[i] = l[i - 1] * 2 + 3\n\n# \u30d0\u30fc\u30ac\u30fc\u306e\u9577\u3055\u306f\u5947\u6570\n\n\ndef rec(m, y):\n    if y <= 0:\n        return 0\n    if m == 0:\n        return 1 if y > 0 else 0\n    h = l[m] // 2  # \u30ec\u30d9\u30ebm\u306e\u534a\u5206\u3088\u308a\u5de6\u5074\u306e\u9577\u3055\n    if h < y:  # \u771f\u3093\u4e2d\u542b\u3080\n        return 1 + p[m - 1] + rec(m - 1, y - h - 1)\n    else:\n        return rec(m - 1, y - 1)\n\n\nprint((rec(n, x)))\n", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    N, X = NMI()\n    A = [1]\n    P = [1]\n    for i in range(N):\n        A.append(A[-1]*2+3)\n        P.append(P[-1]*2+1)\n\n    def rec(n, x):\n        if n == 0:\n            return 1\n\n        if x == 1:\n            return 0\n        elif x <= A[n-1]+1:\n            return rec(n-1, x-1)\n        elif x == A[n-1]+2:\n            return P[n-1]+1\n        elif x <= A[n]-1:\n            return P[n-1]+1+rec(n-1, x-A[n-1]-2)\n        else:\n            return P[n]\n\n    print(rec(N, X))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,x=map(int, input().split())\np=[1]*(n+1) #\u30d1\u30c6\u30a3\na=[1]*(n+1) #\u30d1\u30c6\u30a3\u3068\u30d0\u30f3\u30ba\n\nfor i in range(1,n+1):\n    p[i]=p[i-1]*2+1\n    a[i]=a[i-1]*2+3\n\ndef f(n,x):\n    if x==0:\n        return 0\n    if n==0:\n        return 1\n    \n    center = a[n-1] + 2\n    \n    if x < center:\n        return f(n-1,x-1)\n    elif x >= center:\n        return p[n-1] + 1 + f(n-1,x-center)\n\nprint(f(n,x))", "n,x=map(int,input().split())\nl,p=[1],[1]\nfor i in range(n):\n  l+=[l[-1]*2+3]\n  p+=[p[-1]*2+1]\nx-=1\na=0\nwhile x>0 and n:\n  t=l[n]//2\n  if x>=t:\n    a+=p[n-1]+1\n    x-=t\n  x-=1\n  n-=1\nif x>=0 and n==0: a+=1\nprint(a)", "n,x=map(int,input().split())\n\ndef func(m,y):\n  if y==0:return 0\n  ret=0\n  t=4*pow(2,m)-3\n  if y>=t-1:\n    ret=pow(2,m+1)-1\n  elif y==(t-1)//2:\n    ret=pow(2,m)-1\n  elif y==(t-1)//2+1:\n    ret=pow(2,m)\n  elif y>(t-1)//2+1:\n    ret=pow(2,m)\n    ret+=func(m-1,y-(t-1)//2-1)\n  else:\n    ret=func(m-1,y-1)\n  return ret\n\nprint(func(n,x))", "n, x = list(map(int, input().split()))\n\npate, slice = [1], [1]\nfor _ in range(n + 1):\n    pate.append(2 * pate[-1] + 1)\n    slice.append(2 * slice[-1] + 3)\n\nans = 0\nwhile n > 0 and x > 0:\n    if x >= slice[n - 1] + 2:\n        ans += pate[n - 1] + 1\n        x -= slice[n - 1] + 2\n    elif x < slice[n - 1] + 2:\n        x -= 1\n    n -= 1\nprint((ans + (x > 0)))\n", "import sys\nsys.setrecursionlimit(100000000)\n\nN,K = map(int,input().split())\n\nstore = [pow(2,i+1)-1 for i in range(51)]\n\ndef maisu(n):\n  return pow(2,n+2)-3\n\ndef burger(n,k): #n\u5c64\u3067k\u679a\n  if k == maisu(n):\n    return store[n]\n  elif k <= 1:\n    return 0\n  elif (maisu(n)-3)//2 +1 >= k:\n    return burger(n-1,k-1)\n  else:\n    #print(k-(2+maisu(n-1)),maisu(n-1))\n    return burger(n-1,k-(2+maisu(n-1)))+burger(n-1,maisu(n-1))+1\n  \nans = burger(N,K)    \nprint(ans)", "N, X = list(map(int, input().split()))\n\nburger_size = [1]\npatty_num = [1]\nfor i in range(50):\n    burger_size.append(2 * burger_size[-1] + 3)\n    patty_num.append(2 * patty_num[-1] + 1)\n\n\n# \u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u306e\u4e0b\u304b\u3089x\u6bb5\u76ee\u307e\u3067\u306b\u542b\u307e\u308c\u308b\u30d1\u30c6\u30a3\u306e\u6570\u3092\u8fd4\u3059\ndef dfs(n, x):\n    if burger_size[n] == x:\n        return patty_num[n]\n\n    if x == 1:\n        return 0\n\n    elif 1 < x <= 1 + burger_size[n - 1]:\n        return dfs(n - 1, x - 1)\n\n    elif x == 1 + burger_size[n - 1] + 1:\n        return patty_num[n - 1] + 1\n\n    elif 1 + burger_size[n - 1] + 1 < x < burger_size[n]:\n        return patty_num[n - 1] + 1 + dfs(n - 1, x - burger_size[n - 1] - 2)\n\n\nprint((dfs(N, X)))\n", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\ndef f(n,x):\n    nonlocal h\n    if x>2**(n+2)-3:\n        x = 2**(n+2)-3\n    if (n,x) in h:\n        return h[(n,x)]\n    ret = -1\n    if n==0:\n        ret = x\n    elif x<=1:\n        ret = 0\n    elif x<=2**(n+1)-2:\n        ret = f(n-1,x-1)\n    elif x==2**(n+1)-1:\n        ret = 2**n\n    elif x<=2**(n+2)-4:\n        ret = 2**n+f(n-1,x-2**(n+1)+1)\n    else:\n        ret = 2**(n+1)-1\n    h[(n,x)] = ret\n    return ret\n\nn,x = inm()\nh = {}\nprint(f(n,x))\n", "n, x = list(map(int, input().split()))\n\npate, slice = [1], [1]\nfor _ in range(n + 1):\n    pate.append(2 * pate[-1] + 1)\n    slice.append(2 * slice[-1] + 3)\n\nans = 0\nwhile n > 0:\n    if x >= slice[n - 1] + 2:\n        ans += pate[n - 1] + 1\n        x -= slice[n - 1] + 2\n    elif x < slice[n - 1] + 2:\n        x -= 1\n    n -= 1\nprint((ans + (x > 0)))\n", "N, X = list(map(int, input().split()))\n# a=\u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u539a\u3055, p = \u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u30d1\u30c6\u30a3\u306e\u6570\na, p = [1], [1]\nfor i in range(N):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\n# \u30ec\u30d9\u30ebN\u30d0\u30fc\u30ac\u30fc\u306e\u4e0b\u304b\u3089X\u5c64\u306b\u3042\u308b\u30d1\u30c6\u30a3\u306e\u6570\n\n\ndef f(N, X):\n    if N == 0:\n        if X <= 0:\n            return 0\n        else:\n            return 1\n    if X == 1:\n        return 0\n    elif 1 < X <= 1 + a[N - 1]:\n        return f(N - 1, X - 1)\n    elif X == 2 + a[N - 1]:\n        return p[N - 1] + 1\n    elif 2 + a[N - 1] < X <= 2 + 2 * a[N - 1]:\n        return p[N - 1] + 1 + f(N - 1, X - 2 - a[N - 1])\n    elif X == 3 + 2 * a[N - 1]:\n        return 2 * p[N - 1] + 1\n\nprint((f(N, X)))\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, X = LI()\n    X -= 1\n\n    # \u30d0\u30fc\u30ac\u30fc\u306e\u539a\u3055\n    l = [0] * (N + 1)\n    l[0] = 1\n    for i in range(N):\n        l[i+1] = 2 * l[i] + 3\n\n    # \u30d0\u30fc\u30ac\u30fc\u306e\u30d1\u30c6\u30a3\u6570\n    p = [0] * (N + 1)\n    p[0] = 1\n    for i in range(N):\n        p[i+1] = 2 * p[i] + 1\n\n    def rec(n, x):\n        if n == 0:\n            return 1\n        else:\n            if x == 0:\n                return 0\n            elif 1 <= x <= l[n-1]:\n                return rec(n - 1, x - 1)\n            elif x == l[n-1] + 1:\n                return p[n-1] + 1\n            elif l[n-1] + 2 <= x <= l[n] - 2:\n                return p[n-1] + 1 + rec(n - 1, x - 2 - l[n-1])\n            elif x == l[n] - 1:\n                return p[n]\n\n    ans = rec(N, X)\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n, x = list(map(int, input().split()))\na, p = [1], [1]\nfor i in range(n):\n    a.append(2*a[-1] + 3)\n    p.append(2*p[-1] + 1)\n\ndef f(n, x): #\u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u306e\uff58\u307e\u3067\u306e\u30d1\u30c6\u30a3\u306e\u6570\n    if n == 0:\n        return 0 if x <= 0 else 1\n    elif x <= 1 + a[n-1]:\n        return f(n-1, x-1)\n    else:\n        return p[n-1] + 1 + f(n-1, x-2-a[n-1])\n\nprint((f(n, x)))\n    \n        \n", "# coding: utf-8\n\n# https://atcoder.jp/contests/abc115\n# 10:59 giveup\n\n\ndef main():\n    N, X = list(map(int, input().split()))\n\n    p = [None] * (N+1)\n    p[0] = 1\n    for i in range(N):\n        p[i+1] = 2*p[i] + 1\n\n    whole = [None] * (N+1)\n    whole[0] = 1\n    for i in range(N):\n        whole[i+1] = 2*whole[i] + 3\n\n    def rec(N, X):\n        if N == 0:\n            if X == 1:\n                return 1\n            else:\n                return 0\n\n        if X <= 1:\n            return 0\n\n        elif X <= 1 + whole[N-1]:\n            return rec(N-1, X-1)\n\n        elif X <= 1 + whole[N-1] + 1:\n            return p[N-1] + 1\n\n        elif X <= 1 + whole[N-1] + 1 + whole[N-1]:\n            return p[N-1] + 1 + rec(N-1, X-(1+whole[N-1]+1))\n\n        else:\n            return p[N-1] + 1 + p[N-1]\n\n    ans = rec(N, X)\n\n    return ans\n\n\nprint((main()))\n", "N,X=map(int,input().split())\n\ndef n_pati(l):\n  val = 1\n  for i in range(l):\n    val = val*2+1\n  return val\n\ndef n_layer(l):\n  val = 1\n  for i in range(l):\n    val = val*2+3\n  return val\n\nSUM=0\nwhile 1:\n  if N==1:\n    if X in [0,1]:break\n    elif X>=2:\n      SUM += min(3,X-1)\n      break\n  \n  L = n_layer(N)\n  if X >= L//2:\n    SUM += n_pati(N-1)\n    X -= n_layer(N-1)+1\n    if X==0:\n      break\n    SUM += 1\n    X -= 1\n    if X==0:\n      break\n    N -= 1\n  else:\n    X -= 1\n    N -= 1\n    \n  if X in [0,1]:break\n  \nprint(SUM)", "n, x = map(int, input().split())\n\nf_dict = {\n  0: 1\n}\ndef f(n):\n  if f_dict.get(n):\n    return f_dict.get(n)\n  return (3 + f(n-1) * 2)\n\n\npatty_dict = {\n  0: 1\n}\ndef total_patty(n):\n  if patty_dict.get(n):\n    return patty_dict.get(n)\n  return (1 + 2 * total_patty(n - 1))\n\ndef count_patty(n, x):\n  if n == 0 and x == 1:\n    return 1\n  elif x == 0:\n    return 0\n  elif 1 <= x and x <= f(n - 1) + 1:\n    return count_patty(n - 1, x - 1)\n  elif x == f(n - 1) + 2:\n    return total_patty(n - 1) + 1\n  elif f(n - 1) + 2 <= x and x <= 2 * f(n - 1) + 2:\n    return total_patty(n - 1) + 1 + count_patty(n - 1, x - f(n - 1) - 2)\n  else:\n    return total_patty(n)\n\nprint(count_patty(n, x))", "#!/usr/bin/env python3\ndef main():\n    N, X = list(map(int, input().split()))\n    nums = [None] * (N+1)# nums[i]: i\u6b21\u5143\u30d0\u30fc\u30ac\u30fc\u306e\u5c64\u306e\u6570\n    pnums = [None] * (N+1)# pnums[i]: i\u6b21\u5143\u30d0\u30fc\u30ac\u30fc\u306e\u30d1\u30c6\u30a3\u306e\u679a\u6570\n    nums[0] = 1\n    pnums[0] = 1\n    for i in range(N):\n        nums[i+1] = nums[i]*2 + 3\n        pnums[i+1] = pnums[i]*2 + 1\n    \n    ans = 0\n    while N >= 0:\n        if N == 0:\n            print((ans+1))\n            break\n        if X == 1:\n            print(ans)\n            break\n        elif X <= nums[N-1]+1:# N-1\u6b21\u5143\u30d0\u30fc\u30ac\u306e\u4e2d\u3092\u3055\u3089\u306b\u63a2\u7d22\n            X -= 1\n            N -= 1\n        elif X == nums[N-1]+2:# \u3074\u3063\u305f\u308a\u771f\u3093\u4e2d\u306e\u30d1\u30c6\u30a3\u307e\u3067\u5230\u9054\n            print((ans+pnums[N-1]+1))\n            break\n        elif X < nums[N]:\n            X -= nums[N-1]+2\n            ans += pnums[N-1]+1\n            N -= 1\n        else:\n            print((ans+pnums[N]))\n            break\n    # print(N,X)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nn,x=list(map(int,input().split()))\n\npb=[[0]*2 for i in range(n+1)]\npb[0][0]=1\npb[0][1]=1\nfor i in range(1,n+1):\n    pb[i][0]=3+pb[i-1][0]*2\n    pb[i][1]=1+pb[i-1][1]*2\n\ndef pbx(xx,nn):\n#    print(xx,nn)\n    if nn==0:\n        return 1\n    if xx==1:\n        return 0\n    elif xx<=1+pb[nn-1][0]:\n        return pbx(xx-1,nn-1)\n    elif xx==2+pb[nn-1][0]:\n        return pb[nn-1][1]+1\n    elif xx<=2+pb[nn-1][0]*2:\n        xxx=pbx(xx-pb[nn-1][0]-2,nn-1)\n#        print(\"xxx1\",xxx)\n        xxx=pb[nn-1][1]+1+xxx\n#        print(\"xxx2\",xxx)\n        return xxx\n    elif xx==3+pb[nn-1][0]*2:\n        return pb[nn][1]\n    else:\n        print((\"----------\",xx,nn))\n        return 0\n\n    \nprint((pbx(x,n)))\n", "ip = input().split(\" \")\nn = int(ip[0])\nx = int(ip[1])\n\ndef get_num_layers(level):\n    if level == 1:\n        return 5\n    return 5*(1<<(level-1)) + 3*((1<<(level-1)) - 1)\n\ndef func(level, index):\n    if level == 1:\n        return min(index-1, 3)\n    num_layers = get_num_layers(level)\n    mid = num_layers//2\n    if index == mid+1:\n        return 1 + func(level-1,mid-1)\n    if index == 1:\n        return 0\n    if index == num_layers:\n        return 2*func(level-1,mid-1) + 1\n    if index <= mid:\n        return func(level-1,index-1)\n    if index > mid+1:\n        return 1 + func(level-1,mid-1) + func(level-1,index-mid-1)\n    \nprint((func(n, x)))\n\n", "N,X=list(map(int,input().split()))\na,p=[1],[1]\nfor i in range(N):\n   a.append(a[i]*2+3)\n   p.append(p[i]*2+1)\ndef ans(N,X):\n   if N==0:\n      return 0 if X<=0 else 1\n   elif X<=1+a[N-1]:\n      return ans(N-1,X-1)\n   else:\n      return p[N-1]+1+ans(N-1,X-2-a[N-1])\nprint(ans(N,X))", "N, X = list(map(int, input().split()))\n\na, p = [1], [1]\nfor i in range(N):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\ndef f(N, X): # X <= 0 \u3084 X > a_N \u3092\u8a31\u5bb9\u3057\u89e3\u8aac\u672c\u6587\u304b\u3089\u7c21\u7565\u5316\n    if N == 0:\n        return 0 if X <= 0 else 1\n    elif X <= 1 + a[N-1]:\n        return f(N-1, X-1)\n    else:\n        return p[N-1] + 1 + f(N-1, X-2-a[N-1])\n\nprint((f(N, X)))\n", "n, x = map(int, input().split())\na, p = [1], [1]\nfor i in range(n):\n    a.append(2*a[-1] + 3)\n    p.append(2*p[-1] + 1)\n \ndef f(n, x): #\u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u306e\uff58\u307e\u3067\u306e\u30d1\u30c6\u30a3\u306e\u6570\n    if n == 0:\n        return 0 if x <= 0 else 1\n    elif x <= 1 + a[n-1]:\n        return f(n-1, x-1)\n    else:\n        return p[n-1] + 1 + f(n-1, x-2-a[n-1])\n \nprint(f(n, x))", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\n# \u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\ndef dfs(k):\n    nonlocal count, ans\n    # \u30d0\u30f3\n    count += 1\n    if k == 0:\n        ans += 1\n    elif count < x:\n        # \u30ec\u30d9\u30ebn-1\u30d0\u30fc\u30ac\u30fc\n        if count + b[k-1] > x:\n            dfs(k-1)\n        else:\n            count += b[k-1]\n            ans += p[k-1]\n        if count < x:\n            # \u30d1\u30c6\u30a3\n            count += 1\n            ans += 1\n            if count < x:\n                # \u30ec\u30d9\u30ebn-1\u30d0\u30fc\u30ac\u30fc\n                if count + b[k-1] > x:\n                    dfs(k-1)\n                else:\n                    count += b[k-1]\n                    ans += p[k-1]\n\nn, x = MAP()\nb = [0]*n\np = [0]*n\nb[0] = 1\np[0] = 1\nfor i in range(1, n):\n    b[i] = b[i-1]*2 + 3\n    p[i] = p[i-1]*2 + 1\n\ncount = 0\nans = 0\ndfs(n)\nprint(ans)", "n, x = list(map(int, input().split()))\n\npate, slice = [1], [1]\nfor _ in range(n + 1):\n    pate.append(2 * pate[-1] + 1)\n    slice.append(2 * slice[-1] + 3)\n\nans = 0\nwhile n * x > 0:\n    if x >= slice[n - 1] + 2:\n        ans += pate[n - 1] + 1\n        x -= slice[n - 1] + 2\n    elif x < slice[n - 1] + 2:\n        x -= 1\n    n -= 1\nprint((ans + (x > 0)))\n", "N,X = map(int,input().split())\n\n# \u30ec\u30d9\u30eb0\u30d0\u30fc\u30ac\u30fc P\n# \u30ec\u30d9\u30eb1\u30d0\u30fc\u30ac\u30fc BPPPB\n# P[i] = \u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u30d1\u30c6\u30a3\u306e\u679a\u6570\n# B[i] = \u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u539a\u3055\n\nP = [0] * 51\nB = [0] * 51\n\nP[0] = 1\nB[0] = 1\n\nfor i in range(1, len(P)):\n  P[i] = P[i - 1] * 2 + 1\n  B[i] = B[i - 1] * 2 + 3\n\n# \u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u3092\u4e38\u3054\u3068\u98df\u3079\u305f\u3068\u304d\u306e\u30d1\u30c6\u30a3\u306e\u679a\u6570\u3092\u6c42\u3081\u308b\ndef get_whole_barger(n):\n  return P[n]\n\n# \u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u3092x\u679a\u76ee\u307e\u3067\u98df\u3079\u305f\u3068\u304d\u306e\u30d1\u30c6\u30a3\u306e\u679a\u6570\u3092\u6c42\u3081\u308b\ndef get_patty(n,x):\n  if n == 0 or x == 0:\n    return P[0]\n  if B[n] == x:\n    return P[n]\n  if x <= 1:\n    return 0\n  if x <= 1 + B[n - 1]:\n    return get_patty(n - 1, x - 1)\n  if x <= 2 + B[n - 1]:\n    return get_whole_barger(n - 1) + 1\n  if x <= 2 + B[n - 1] * 2:\n    return get_whole_barger(n - 1) + 1 + get_patty(n - 1, x - 2 - B[n - 1])\n  else:\n    return get_whole_barger(n - 1) + 1 + get_whole_barger(n - 1)\n\nprint(get_patty(N,X))", "N, X = list(map(int, input().split(' ')))\n\np = [1]\npb = [1]\nnp = 0\nnx = X\n\nfor _ in range(N):\n    p.append(p[-1] * 2 + 1)\n    pb.append(pb[-1] * 2 + 3)\n\n\ndef dfs(level):\n    nonlocal np, nx\n\n    if nx == 0:\n        return\n\n    if nx >= pb[level]:\n        nx -= pb[level]\n        np += p[level]\n        return\n\n    nx -= 1\n    if nx == 0:\n        return\n\n    dfs(level - 1)\n\n    if nx == 0:\n        return\n\n    nx -= 1\n    np += 1\n\n    if nx == 0:\n        return\n\n    dfs(level - 1)\n\n    if nx == 0:\n        return\n\n    nx -= 1\n\n\ndfs(N)\n\nprint(np)\n", "n, x = list(map(int, input().split()))\n\nsizes = [1]\n\nfor i in range(n):\n    sizes.append(2*sizes[i]+3)\n\nprev = {}\n\ndef solve(n, x):\n    if (n, x) in prev:\n        return prev[(n, x)]\n    else:\n        if n == 0:\n            return 1 if x == 1 else 0\n        else:\n            ans = 0\n            if x == sizes[n]:\n                ans = 2*solve(n-1, sizes[n-1]) + 1\n            else:\n                mid = sizes[n]//2 + 1\n\n                if x == mid:\n                    ans = solve(n-1, sizes[n-1]) + 1\n                elif x < mid:\n                    ans = solve(n-1, x-1)\n                else:\n                    ans = solve(n-1, sizes[n-1]) + 1 + solve(n-1, x-mid)\n\n            prev[(n, x)] = ans\n            return ans\n\nprint(solve(n, x))", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, X):\n    layer = [1]\n    pate = [1]\n    for _ in range(N):\n        layer.append(layer[-1] * 2 + 3)\n        pate.append(pate[-1] * 2 + 1)\n\n    # print(layer[-1])\n    # print(pate[-1])\n\n    def burger(n, l):\n        if layer[n] <= l:\n            return pate[n]\n        if l == 0:\n            return 0\n        re = 0\n        if layer[n] // 2 + 1 <= l:\n            re += pate[n - 1] + 1  # center pattie\n            l -= layer[n] // 2 + 1\n        else:\n            l -= 1  # first bun\n        re += burger(n - 1, l)\n        return re\n\n    print((burger(N, X)))\n\n\ndef __starting_point():\n    N, X = list(map(int, input().split()))\n    solve(N, X)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # N, X = 3, 1\n    # for i in range(1, 29 + 1):\n    #     solve(N, i)\n\n__starting_point()", "# \u89e3\u8aacAC\nn,x = map(int,input().split())\nb,p = [1],[1]\nfor i in range(n):\n    # \u30ec\u30d9\u30ebN\u30d0\u30fc\u30ac\u30fc\u306e\u5c64\u306e\u7dcf\u6570\n    b.append(b[i] * 2 + 3)\n    # \u30ec\u30d9\u30ebN\u30d0\u30fc\u30ac\u30fc\u306eP\u306e\u7dcf\u6570\n    p.append(p[i] * 2 + 1)\n# \u518d\u5e30\u95a2\u6570\u3067P\u306e\u7dcf\u6570\u3092\u8abf\u3079\u308b\n# \u30ec\u30d9\u30eb0\u30d0\u30fc\u30ac\u30fc\u304b\u30891,2...N\u307e\u3067\u306e\u4e0b\u304b\u3089X\u5c64\u306eP\u306e\u7dcf\u6570\u3092\u9806\u756a\u306b\u8abf\u3079\u308b\ndef pate(n,x):\n    if n == 0:\n        if x <= 0:\n            return 0\n        else:\n            return 1\n    elif x <= 1 + b[n-1]:\n        return pate(n-1,x-1)\n    else:\n        return p[n-1] + 1 + pate(n-1,x-2-b[n-1])\nprint(pate(n,x))", "n, x = list(map(int, input().split()))\n\npate, slice = [1], [1]\nfor _ in range(n):\n    pate.append(2 * pate[-1] + 1)\n    slice.append(2 * slice[-1] + 3)\n\nans = 0\nfor i in range(n)[::-1]:\n    if x >= slice[i] + 2:\n        ans += pate[i] + 1\n        x -= slice[i] + 2\n    elif x < slice[i] + 2:\n        x -= 1\nprint((ans + (x > 0)))\n", "N,X = map(int,input().split())\nlsa = [1]\nlsp = [1]\nfor i in range(50):\n    lsa.append(2*lsa[-1]+3)\n    lsp.append(2*lsp[-1]+1)\n\ndef f(n,x):\n    if x == 1:\n        return 1 if n==0 else 0\n    if 1 < x and x <= 1+lsa[n-1]:\n        return f(n-1,x-1)\n    if x == 2+lsa[n-1]:\n        return lsp[n-1]+1\n    if 2 + lsa[n-1] < x and x <= 2+2*lsa[n-1]:\n        return lsp[n-1]+1+f(n-1,x-2-lsa[n-1])\n    if x == 3+2*lsa[n-1]:\n        return 2*lsp[n-1] + 1\n\nprint(f(N,X))", "def main():\n    n, x = map(int, input().split())\n\n    pb = [1]\n    p = [1]\n    for _ in range(n):\n        pb.append(pb[-1] * 2 + 3)\n        p.append(p[-1] * 2 + 1)\n\n    ans = 0\n    for _ in range(n):\n        if x == 0:\n            break\n        if x >= pb[-2] + 2:\n            x -= pb[-2] + 2\n            ans += 1 + p[-2]\n        else:\n            x -= 1\n        pb.pop(-1)\n        p.pop(-1)\n\n    if x >= 1:\n        ans += 1\n\n    print(ans)\n\nmain()", "#!/usr/bin/env python3\n# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left\u3000\u3053\u308c\u3067\u4e8c\u90e8\u63a2\u7d22\u306e\u5927\u5c0f\u691c\u7d22\u304c\u884c\u3048\u308b\nimport fractions #\u6700\u5c0f\u516c\u500d\u6570\u306a\u3069\u306f\u3053\u3063\u3061\nimport math\nimport sys\nimport collections\nfrom decimal import Decimal # 10\u9032\u6570\u3067\u8003\u616e\u3067\u304d\u308b\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # \u518d\u5e30\u56de\u6570\u4e0a\u9650\u306f\u3067default1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN, X = LI()\n\n\"\"\"\nLv i \u306e\u30d0\u30fc\u30ac\u30fc\u306e\u539a\u307f\u3092a[i]\nLv i \u306b\u542b\u307e\u308c\u308b\u30d1\u30c6\u30a3\u306e\u6570\u3092p[i]\n\u3068\u3059\u308b\u3068\na[0] = 1\na[i] = 2 * a[i-1] + 3\np[0] = 1\np[i] = 2 * p[i - 1] + 1\n\nX = 1 f(N, X) = 0\n\n1 < X <= 1 + a[i - 1]\n\u4e00\u756a\u3057\u305f\u306e\u30d0\u30f3\n\n2 + a[i - 1] < X\n\u4e00\u756a\u3057\u305f\u306e\u30d0\u30f3\u3000\uff0b\u3000\n\"\"\"\na, p = [1], [1]\nfor i in range(N):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\ndef f(N, X):\n    if N == 0:\n        return 0 if X <= 0 else 1\n    elif X <= 1 + a[N - 1]:\n        return f(N - 1, X - 1)\n    else:\n        return p[N - 1] + 1 + f(N - 1, X - 2 - a[N - 1])\nprint((f(N, X)))\n\n\n\n\n\n", "N, X = map(int, input().split())\n\nburger = [1]\npatty = [1]\nfor i in range(N):\n    burger.append(burger[i]*2 + 3)\n    patty.append(patty[i]*2 + 1)\n    \ndef f(N, X):\n    if N == 0:\n        if X <= 0:\n            return 0\n        else:\n            return 1\n    elif X <= burger[N-1] + 1:\n        return f(N-1, X-1)\n    else:\n        return patty[N-1] + 1 + f(N-1, X-2-burger[N-1])\n\nans = f(N, X)\nprint(ans)", "n, x = list(map(int, input().split()))\n\ndef level_n_putty(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 * level_n_putty(n-1) + 1\n\ndef level_n_hb(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 * level_n_hb(n-1) + 3\n\nm = level_n_hb(n)\n\ns = 0\nbase = 0\n\nwhile True:\n    if x == base + 1:\n        if n == 0:\n            s += 1\n        break\n    elif x == base + m:\n        s += level_n_putty(n)\n        break\n    else:\n        l = level_n_hb(n-1)\n        #print(n, base + l + 2, x)\n        if x < base + l + 2:\n            base += 1\n            n -= 1\n            m = l\n        elif x == base + l + 2:\n            s += 1 + level_n_putty(n-1)\n            break\n        else:\n            base = base + l + 2\n            s += 1 + level_n_putty(n-1)\n            n -= 1\n            m = l\n\nprint(s)\n", "n, x = list(map(int, input().split()))\n\np = [0] * -~n\nl = [0] * -~n\n\np[0] = 1\nl[0] = 1\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] * 2 + 1\n    l[i] = l[i - 1] * 2 + 3\n\n# \u30d0\u30fc\u30ac\u30fc\u306e\u9577\u3055\u306f\u5947\u6570\n\n\ndef rec(m, y):\n    if y == 0:\n        return 0\n    if m == 0:\n        return 1\n    h = l[m] // 2  # \u30ec\u30d9\u30ebm\u306e\u534a\u5206\u3088\u308a\u5de6\u5074\u306e\u9577\u3055\n    if h < y:  # \u771f\u3093\u4e2d\u542b\u3080\n        return 1 + p[m - 1] + rec(m - 1, y - h - 1)\n    else:\n        return rec(m - 1, y - 1)\n\n\nprint((rec(n, x)))\n", "n,x = map(int,input().split())\na,p = [1],[1]\nfor i in range(n):\n  a.append(a[i]*2+3)\n  p.append(p[i]*2+1)\ndef f(n,x):\n  if n == 0:\n    return 0 if x <= 0 else 1\n  elif x <= 1 + a[n-1]:\n    return f(n-1,x-1)\n  else:\n    return p[n-1] + 1 + f(n-1,x-2-a[n-1])\nprint(f(n,x))", "N,X=list(map(int,input().split()))  #S=2**(N+2)-3\n                  #P=2**(N+1)-1\ndef solve(N,X):\n    if X==0:\n        return 0\n    if N==0:\n        return X\n    if X<2**(N+1)-1:\n        return solve(N-1,X-1)\n    elif X==2**(N+1)-1:\n        return 2**N\n    elif X<2**(N+2)-3:\n        return 2**N+solve(N-1,X-2**(N+1)+1)\n    else:\n        return 2**(N+1)-1\n\nprint((solve(N,X)))\n", "N, X = map(int, input().split())\n\nans = 0\nfor i in range(N, -1, -1):\n    if X < 2**(i + 1) - 1:\n        X -= 1\n    elif X > 2 ** (i + 1) - 1:\n        X -= 2 ** (i + 1) - 1\n        ans += 2 ** i\n    else:\n        ans += 2 ** i\n        break\n    if X == 0:\n        break\n    #print(X, ans)\n\n\nprint(ans)", "N, X = map(int, input().split())\n\nTotal = [1]\nPatties = [1]\n\nfor i in range (1, N+1):\n\tTotal.append(Total[i-1]*2+3)\n\tPatties.append(Patties[i-1]*2+1)\n\ndef Burger(N,X):\n\tif N== 0:\n\t\tif X <= 0:\n\t\t\treturn (0)\n\t\telse:\n\t\t\treturn (1)\n\telif X <= 1+Total[N-1]:\n\t\treturn Burger(N-1, X-1)\n\telse:\n\t\treturn Patties[N-1]+1+Burger(N-1, X-2-Total[N-1])\n\nprint(Burger(N,X))", "3\n#coding: utf-8\n\nfrom collections import defaultdict\n\nN, X = (int(x) for x in input().split())\n\nmemo = {}\n\ndef size_lv(lv):\n    if lv == 0:\n        return 1\n    if lv not in memo:\n        memo[lv] = size_lv(lv-1) * 2 + 3\n    return memo[lv]\n\nmemo2 = {}\ndef num_pty(lv, X):\n    if (lv, X) in memo2:\n        return memo2[(lv, X)]\n    if X == 0:\n        return 0\n\n    if lv == 0:\n        memo2[(lv, X)] = 1\n        return memo2[(lv, X)]\n\n    prevSize = size_lv(lv-1)\n    if X <= prevSize+1:\n        memo2[(lv, X)] = num_pty(lv-1, X-1)\n        return memo2[(lv, X)]\n    \n    if X == prevSize + 2:\n        memo2[(lv, X)] = num_pty(lv-1, prevSize) + 1\n        return memo2[(lv, X)]\n    \n    memo2[(lv, X)] = num_pty(lv-1, prevSize) + 1 + num_pty(lv-1, min(X-prevSize-2, prevSize))\n    return memo2[(lv, X)]\n    \nprint((num_pty(N, X)))\n\n# BBPPPBPBPPPBB\n# BPPPB\n", "import sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\ndef main():\n    N,X=mi()\n\n    def solve(n,x):\n        # print(n,x)\n        if n == 0: return 1\n        c = 2**(n+2)-3\n        half = c//2\n\n        res = 0\n        if x <= half:\n            if x == 1:\n                res += 0\n            else:\n                res += solve(n-1,x-1)\n        elif x == half+1:\n            res += 2**(n-1+1) - 1 + 1\n        elif x < c:\n            res += 2**(n-1+1) - 1 + 1 + solve(n-1,x-(half+1))\n        else:\n            assert x == c\n            res += 2**(n+1)-1\n\n        return res\n\n    print(solve(N,X))\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u521d\u671f\u5165\u529b\nimport sys\ninput = sys.stdin.readline\nN,X = (int(i) for i in input().split())\nDP_all  =[0]*(N+1)\nDP_p    =[0]*(N+1)\nDP_all[0]   =1\nDP_p[0]     =1\n\n#\u30ec\u30d9\u30eb\u300ci+1\u300d\u30d0\u30fc\u30ac\u30fc\u306e\u679a\u6570\nfor i in range(N):\n    DP_all[i+1] =DP_all[i] *2 +3\n    DP_p[i+1]   =DP_p[i] *2  +1\n#print(\"\u7dcf\u679a\u6570\" ,DP_all)\n#print(\"\u30d1\u30c6\u30a3\u679a\u6570\" ,DP_p)\n\n#\u518d\u5e30\u3067\u30d1\u30c6\u30a3\u306e\u679a\u6570\u3092\u6c42\u3081\u308b L=\u30ec\u30d9\u30eb\u3001x=\u98df\u3079\u308b\u679a\u6570\ndef  p_num(L,x):\n    if x <=L:\n        return 0\n    if x ==DP_all[L]:\n        return DP_p[L]\n    elif x < DP_all[L] //2 +1:\n        return p_num(L-1,x -1)\n    elif x ==DP_all[L] //2 +1:\n        return DP_p[L-1] +1\n    elif x > DP_all[L] //2 +1:\n        return DP_p[L-1] +1 +p_num(L-1,x -DP_all[L-1] -2)\n\nans =p_num(N,X)\nprint(ans)", "N, K = map(int, input().split())\n\nL = [1]\nP = [1]\n\nfor i in range(N):\n    L.append(L[i] * 2 + 3)\n    P.append(P[i] * 2 + 1)\n\ndef f(N, X):\n    if N == 0:\n        return 0 if X <= 0 else 1\n    elif X <= 1 + L[N-1]:\n        return f(N-1, X-1)\n    else:\n        return P[N-1] + 1 + f(N-1, X-2-L[N-1])\n\nprint(f(N, K))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nN, X = list(map(int, input().split()))\n\nh = [1]\np = [1]\n\nfor _ in range(50):\n    h.append(h[-1] * 2 + 3)\n    p.append(p[-1] * 2 + 1)\n\ndef bug(l, y):\n    if l == 0:\n        return 0 if y <= 0 else 1\n    \n    mid = (h[l] + 1) // 2\n    if y < mid:\n        return bug(l - 1, y - 1)\n    elif y == mid:\n        return p[l - 1] + 1\n    elif y > mid:\n        return p[l - 1] + 1 + bug(l - 1, y - mid)\n    \nprint((bug(N, X)))\n", "N,X=map(int,input().split())\nA=[1]*(N+1)\nP=[1]*(N+1)\nfor i in range(1,N+1):\n    P[i]=2*P[i-1]+1\n    A[i]=2*P[i]-1\n\ndef f(N,X):\n    if X==1:\n        if N==0:\n            return 1\n        else:\n            return 0\n    elif 1<X<=1+A[N-1]:\n        return f(N-1,X-1)\n    elif X==2+A[N-1]:\n        return P[N-1]+1\n    elif 2+A[N-1]<X<=2+2*A[N-1]:\n        return P[N-1]+1+f(N-1,X-2-A[N-1])\n    else:\n        return 2*P[N-1]+1\n\nprint(f(N,X))", "#create date: 2020-07-01 09:01\n\nimport sys\nstdin = sys.stdin\nfrom functools import lru_cache\n\ndef ns(): return stdin.readline().rstrip()\ndef ni(): return int(ns())\ndef na(): return list(map(int, stdin.readline().split()))\n\n@lru_cache(maxsize=2**52-3)\ndef f(n, x):\n    if n == 0:\n        return 1\n\n    if x == 1:\n        return 0\n    elif x <= 2**(n+1)-2:\n        #print(\"f({}, {})\".format(n-1, x-1))\n        return f(n-1, x-1)\n    elif x == 2**(n+1)-1:\n        return f(n-1, 2**(n+1)-3) + 1\n    elif x < 2**(n+2)-2:\n        return f(n-1, 2**(n+1)-3) + 1 + f(n-1, x-(2**(n+1)-1))\n    else:\n        return 2 * f(n-1, 2**(n+1)-3) + 1\n\ndef main():\n    n, x = na()\n    print(f(n, x))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "\n        \ndef main():\n    import sys\n\n    def input(): return sys.stdin.readline().rstrip()\n\n    def f(n, x):\n        if n == 0:\n            return 0 if x<=0 else 1\n        elif x <= a[n-1]+1:\n            return f(n-1, x-1)\n        else:\n            return p[n-1]+1+f(n-1, x-2-a[n-1])\n\n    n, x = map(int, input().split())\n    a, p = [1], [1]\n    for i in range(n):\n        a.append(2*a[-1]+3)\n        p.append(2*p[-1]+1)\n    print(f(n, x))\n\n\n\n\n\n                \ndef __starting_point():\n    main()\n__starting_point()", "n, x = list(map(int, input().split()))\np = [1] * -~n\nl = [1] * -~n\nfor i in range(1, n + 1):\n    p[i] = p[i - 1] * 2 + 1\n    l[i] = l[i - 1] * 2 + 3\n\ndef rec(m, y):\n    if y == 0:\n        return 0\n    if m == 0:\n        return 1\n    h = l[m] // 2\n    if h < y:\n        return 1 + p[m - 1] + rec(m - 1, y - h - 1)\n    else:\n        return rec(m - 1, y - 1)\nprint((rec(n, x)))\n", "n, x = list(map(int, input().split()))\n\npate, slice = [1], [1]\nfor _ in range(n + 1):\n    pate.append(2 * pate[-1] + 1)\n    slice.append(2 * slice[-1] + 3)\n\nans = 0\nfor i in range(n)[::-1]:\n    if x >= slice[i] + 2:\n        ans += pate[i] + 1\n        x -= slice[i] + 2\n    elif x < slice[i] + 2:\n        x -= 1\nprint((ans + (x > 0)))\n", "import sys\nsys.setrecursionlimit(10**5)\nN, X = map(int,input().split())\nl = [1]\nfor i in range(N):\n    l.append(2*l[-1]+3)\nd = {}\ndef f(n,x):\n    if (n,x) in d:\n        return d[(n,x)]\n    if n == 0:\n        ans = 1\n    elif x == 1:\n        ans = 0\n    elif x <= l[n-1]+1:\n        ans = f(n-1,x-1)\n    elif x == l[n-1]+2:\n        ans = f(n-1,l[n-1])+1\n    elif x <= 2*l[n-1]+2:\n        ans = f(n-1, l[n-1])+1+f(n-1, x-l[n-1]-2)\n    else:\n        ans = 2*f(n-1, l[n-1])+1\n    d[(n,x)] = ans\n    return ans\nprint(f(N, X))", "n, x = list(map(int,input().split()))\na = [1]\np = [1]\n\nfor i in range(n):\n    a.append(a[i]*2+3)\n    p.append(p[i]*2+1)\n\ndef f(n, x):\n    if n == 0:\n        return 0 if x <= 0 else 1\n    median = (a[n]+1)//2\n\n    if x < median:\n        return f(n-1, x-1)\n    elif x == median:\n        return p[n-1] + 1\n    else:\n        return p[n-1] + 1 + f(n-1, x - median)\n\nprint((f(n,x)))\n", "n,x=map(int,input().split())\npatty=[1]\nbarger=[1]\nans=0\nfor i in range(n):\n  patty.append(2*patty[-1]+1)\n  barger.append(2*barger[-1]+3)\ni=n\nwhile x>0:\n  for _ in range(n):\n    if x>=barger[i]:\n      x-=barger[i]\n      ans+=patty[i]\n      if x>0:\n        ans+=1\n        x-=1\n      break\n    i-=1\n    x-=1\nprint(ans)", "n,x=list(map(int,input().split()))\n\n#l\u30ec\u30d9\u30eb\u30d0\u30fc\u30ac\u30fc\u306e\u4e0b\u304b\u3089x\u5c64\u306b\u542b\u307e\u308c\u308b\u30d1\u30c6\u30a3\u30fc\u306e\u6570\na=[1]*(n+1)\np=[1]*(n+1)\nfor i in range(1,n+1):\n  a[i]=a[i-1]*2+3\n  p[i]=p[i-1]*2+1\n\ndef count(l,x):\n  if l==0:\n    if x>=1:\n      return 1\n    else:\n      return 0\n  else:\n    if x==1:\n      return 0\n    elif x<a[l-1]+2:\n      return count(l-1,x-1)\n    elif x==a[l-1]+2:\n      return p[l-1]+1\n    elif a[l]>x:\n      return count(l-1,x-a[l-1]-2)+p[l-1]+1\n    else:\n      return p[l]\n    \nprint((count(n,x)))    \n", "def solve():\n    n, x = list(map(int, input().split()))\n    l = [1]\n    nu = [1]\n    for i in range(n):\n        l.append(l[-1] * 2 + 3)\n        nu.append(nu[-1] * 2 + 1)\n\n    def chris(a, b):\n        if a == 0:\n            return b\n        elif b <= a:\n            return 0\n        hl = l[a]\n        if b >= hl - a:\n            return nu[a]\n        elif hl // 2 + 1 <= b:\n            return nu[a - 1] + 1 + chris(a - 1, b - (hl // 2 + 1))\n        return chris(a - 1, b - 1)\n\n    print((chris(n, x)))\n\n\nsolve()\n", "n,x=map(int,input().split())\nl,p=[1],[1]\nfor i in range(n):\n  l+=[l[-1]*2+3]\n  p+=[p[-1]*2+1]\nx-=1\na=1\nwhile n:\n  t=l[n]//2\n  if x>=t:\n    a+=p[n-1]+1\n    x-=t\n  x-=1\n  n-=1\nif x<0: a-=1\nprint(a)", "N,X = map(int, input().split())\nburger = [(1,0)]\nprev = (1,0)\nfor i in range(N):\n    burger.append((2*prev[0]+1, 2*prev[1]+2))\n    prev = burger[-1]\n\nlev = N\ncur = X-1\nps = 0\nfor i in range(N+1):\n    if lev == 0:\n        ps += 1\n        break\n\n    if cur == 0:\n        break\n    elif cur == sum(burger[lev-1])+1:\n        ps += burger[lev-1][0]+1\n        break\n    elif cur == sum(burger[lev])-1:\n        ps += 2*burger[lev-1][0] + 1\n        break\n\n    if cur < sum(burger[lev])/2:\n        cur -= 1\n        lev -= 1\n    else:\n        ps += burger[lev-1][0] + 1\n        cur -= sum(burger[lev-1]) + 2\n        lev -= 1\nprint(ps)", "a = [1]\nb = [1]\nfor _ in range(50):\n    a.append(2 * a[-1] + 3)\n    b.append(2 * b[-1] + 1)\n\ndef num_of_patties(n, x):\n    if n == 0:\n        return 1\n\n    if x == 1:\n        return 0\n    elif x <= a[n-1] + 1:\n        return num_of_patties(n-1, x-1)\n    elif x == a[n-1] + 2:\n        return b[n-1] + 1\n    elif x <= 2 * a[n-1] + 2:\n        return b[n-1] + 1 + num_of_patties(n-1, x-a[n-1]-2)\n    else:\n        return b[n]\n\n\nprint((num_of_patties(*[int(i) for i in input().split()])))\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    N,X = i_map()\n    a,p = [1],[1]\n    for i in range(N):\n        a.append(a[i]*2 + 3)\n        p.append(p[i]*2 + 1)\n    \n    def f(N,X):\n        if N == 0:\n            return 0 if X <= 0 else 1\n        elif X <= 1 + a[N-1]:\n            return f(N-1, X-1)\n        else:\n            return p[N-1] + 1 + f(N-1, X-2-a[N-1])\n    \n    print((f(N,X)))\n\n \n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "N, X = list(map(int, input().split()))\na, p = [1], [1]\nfor i in range(N):\n    a.append(a[i] * 2 + 3)\n    p.append(p[i] * 2 + 1)\n\n# print(a, p)\n\ndef f(N, X):\n    if N == 0:\n        return 0 if X <= 0 else 1\n    elif X <= a[N-1]+1:\n        #\u7aef\u306e\u30d0\u30f3\u30ba\u3092\u6d88\u3059\u306e\u3067X\u304b\u30891\u5f15\u304f\n        return f(N-1, X-1)\n    else:\n        #N-1\u5c64\u306e\u30d1\u30c6\u30a3\u6570\uff0b\u771f\u3093\u4e2d\u306e\u30d1\u30c6\u30a3\uff0b... X-2-a[i]\u306f\u8ffd\u52a0\u3057\u305fBP\u3068\u4e0b\u5074\u306eN-1\u5c64\u306e\u5206\u3092\u5f15\u304f\n        return p[N-1]+1+f(N-1, X-2-a[N-1])\nprint((f(N, X)))\n", "N,X = list(map(int,input().split()))\na=[1]\np=[1]\nfor i in range(1,N+1):\n    a.append(a[i-1]*2+3)\n    p.append(p[i-1]*2+1)\n    \ndef f(n,x):#\u30ec\u30d9\u30ebn\u306e\u30cf\u30f3\u30d0\u30fc\u30ac\u30fc\u3092x\u6bb5\u98df\u3079\u308b\n    if n ==0:#0\u6bb5\u76ee\u306e\u7d42\u4e86\u6761\u4ef6\n        return 0 if x <=0 else 1\n\n    if x <= 1+a[n-1]:\n        return f(n-1,x-1)\n    else:\n        return p[n-1]+1+f(n-1,x-2-a[n-1])\n\nprint((f(N,X)))\n", "n, x = list(map(int, input().split()))\n\na, b = [1], [1]\n\nfor i in range(n):\n    a.append(a[i]*2+3)\n    b.append(b[i]*2+1)\n\ndef cal(n, x):\n    if n == 0:\n        if x <= 0:\n            return 0\n        else:\n            return 1\n    val = (a[n]+1)//2\n\n    if x < val:\n        return cal(n-1, x-1)\n    elif x == val:\n        return b[n-1]+1\n    elif x > val:\n        return b[n-1]+1+cal(n-1, x-val)\n\nans = cal(n, x)\nprint(ans)\n    \n    \n\n\n", "n, x = list(map(int, input().split()))\n\ndp = [1]*(n+1)\nres = 0\n\nfor i in range(1,n+1):\n    dp[i] = dp[i-1]*2+3\n\nfor j in range(n,1,-1):\n    if dp[j] ==x:\n        res += (dp[j]+1) //2\n        x =0        \n    elif dp[j-1]+2 <= x :\n        res += 1 + (dp[j-1]+1)//2\n        x -= dp[j-1]+2\n    elif dp[j-1]+1 ==x:\n        res += (dp[j-1]+1)//2\n        x = 0\n    else:\n        x -=1\n    \n    if x ==0:\n        break\n        \nif x ==5:\n    res += 3\nelif x ==0:\n    pass\nelse:\n    res +=x-1\n\nprint(res)\n", "def f(L, x):\n    if L == 0:\n        return 0 if x <= 0 else 1\n    if x <= total[L - 1] + 1:\n        return f(L - 1, x - 1)\n    else:\n        return patties[L - 1] + 1 + f(L - 1, x - total[L - 1] - 2)\n\n\nN, X = list(map(int, input().split()))\ntotal = [1]\npatties = [1]\nfor i in range(50):\n    total.append(total[-1] * 2 + 3)\n    patties.append(patties[-1] * 2 + 1)\nprint((f(N, X)))\n", "N, X = list(map(int, input().split(' ')))\n\nlevel2p = [1] * (N + 1)\nlevel2pb = [1] * (N + 1)\n\nfor i in range(N):\n    level2p[i + 1] = level2p[i] * 2 + 1\n    level2pb[i + 1] = level2pb[i] * 2 + 3\n\n\ndef dfs(n, x):\n    if n == 0:\n        return 1\n\n    if x <= 1:\n        return 0\n    elif x <= 1 + level2pb[n - 1]:\n        return dfs(n - 1, x - 1)\n    elif x <= 1 + level2pb[n - 1] + 1:\n        return level2p[n - 1] + 1\n    elif x <= 1 + level2pb[n - 1] + 1 + level2pb[n - 1]:\n        return level2p[n - 1] + 1 + dfs(n - 1, x - 1 - level2pb[n - 1] - 1)\n    else:\n        return level2p[n]\n\n\nprint((dfs(N, X)))\n", "n, x = map(int, input().split())\nburger = [2 ** (i + 2) - 3 for i in range(n)]\nburger2 = [2 ** (i + 1) - 1 for i in range(n)]\nnum = [0 for i in range(n)]\nans = 0\ntemp = n - 1\nwhile x > 0:\n    if x >= 1:\n        x -= 1\n    else:\n        continue\n    if x >= burger[temp]:\n        num[temp] += 1\n        x -= burger[temp]\n    else:\n        temp -= 1\n        continue\n    if x >= 1:\n        ans += 1\n        x -= 1\n    else:\n        continue\n    if x >= burger[temp]:\n        num[temp] += 1\n        x -= burger[temp]\n    else:\n        temp -= 1\n        continue\n    if x >= 1:\n        x -= 1\n    else:\n        continue\nfor i in range(n):\n    ans += burger2[i] * num[i]\nprint(ans)", "N,X=map(int,input().split())\nL=[[1,1] for _ in range(N+1)]\ni=0\nwhile i+1<=N:\n    L[i+1][0]=L[i][0]*2+1\n    L[i+1][1]=L[i+1][0]*2-1\n    i+=1\n\nxx=[[1,1,1,1,1]for _ in range(N+1)]\ni=0\nwhile i+1<=N:\n    xx[i+1][1]=L[i][1]+1\n    xx[i+1][2]=L[i][1]+2\n    xx[i+1][3]=2*L[i][1]+2\n    xx[i+1][4]=2*L[i][1]+3\n    i+=1\n\nans=0\nwhile N>0:\n    if xx[N][0]==X:\n        break\n    elif xx[N][1]>=X:\n        N-=1\n        X-=1\n    elif xx[N][2]==X:\n        ans+=1+L[N-1][0]\n        break\n    elif xx[N][3]>=X:\n        ans+=1+L[N-1][0]\n        X-=xx[N][2]\n        N-=1\n    else:\n        ans+=1+2*L[N-1][0]\n        break\n    if N==0:\n        ans+=1\n\nprint(ans)", "n,x = map(int,input().split())\nans = 0\ni = n\nwhile i >= 0:\n    c = 2**(i+1) - 3\n    num_p = 2**i - 1\n    \n    if 2*c + 3 == x:\n        ans += 2*num_p + 1\n        break\n    elif c + 2 == x:\n        ans += num_p + 1\n        break\n    elif 1 == x:\n        break\n    \n    elif 2 + c <= x:\n        x -= 2 + c\n        ans += num_p + 1\n    else:\n        x -= 1\n    \n    i -= 1\n\nprint(ans)", "n, x = map(int, input().split())\n\na, p = [1], [1]\n\nfor i in range(n):\n  a.append(a[i]*2 + 3)\n  p.append(p[i]*2 + 1)\n\ndef f(n, x):\n  if n == 0:\n    return 0 if x <= 0 else 1\n  elif x <= 1 + a[n-1]:\n    return f(n-1, x-1)\n  else:\n    return p[n-1] + 1 + f(n-1, x-2-a[n-1])\n\nprint (f(n,x))", "#\u518d\u5e30\u306e\u6df1\u3055\u304c1000\u3092\u8d85\u3048\u305d\u3046\u306a\u3068\u304d\u306f\u3053\u308c\u3092\u3084\u3063\u3066\u304a\u304f\nimport sys\nsys.setrecursionlimit(10**7)\n\nn,x=map(int,input().split())\na=[0]*(n+1)\np=[0]*(n+1)\na[0]=1\np[0]=1\nfor i in range(n):\n  a[i+1]=2*a[i]+3\n  p[i+1]=2*p[i]+1\n  \ndef func(i,x):\n  if i==0:\n    if x<=0:\n      return 0\n    elif x>=1:\n      return 1\n  mid=(a[i]+1)//2\n  if mid==x:\n    return p[i-1]+1\n  elif mid>x:\n    return func(i-1,x-1)\n  else:\n    return p[i-1]+1+func(i-1,x-mid)\n\n\nprint(func(n,x))  ", "n,x=map(int,input().split())\na=[1]#\u5c64\u306e\u6570 a[n]\u306f\u30ec\u30d9\u30ebn\u306e\u3068\u304d\u306e\u5c64\u306e\u6570\np=[1]#\u30d1\u30c6\u306e\u6570\u3000p[n]\u306f\u30ec\u30d9\u30ebn\u306e\u3068\u304d\u306e\u30d1\u30c6\u306e\u6570\nfor i in range(n):\n    a.append(2*a[-1]+3)\n    p.append(a[-1]//2 +1)\n#print(a,p)\ndef f(n,x):\n    #print(n,x)\n    if n==0:\n        if x>=1:\n            return 1\n        else:\n            return 0\n    elif x==1:\n        return 0\n    elif x==a[n]:#\u30ec\u30d9\u30ebn\u5168\u90e8\u53d6\u308b\u5834\u5408\n        return p[n]\n    elif x==a[n-1]+2:#\u30ec\u30d9\u30ebn\u306e\u771f\u3093\u4e2d\u307e\u3067\u53d6\u308b\u5834\u5408\n        return p[n-1]+1\n    elif 1<x<a[n-1]+2:\n        return f(n-1,x-1)#\u518d\u5e30\u95a2\u6570\u3002\u884c\u5217\u306e2\u756a\u76ee\uff5e\u771f\u3093\u4e2d\u306e1\u500b\u624b\u524d\u307e\u3067\u3001\u3064\u307e\u308a\u30ec\u30d9\u30ebn-1\u30d0\u30fc\u30ac\u30fc\u306b\u79fb\u884c\u3002\u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\u306e\u6700\u521d\u306f\u98db\u3070\u3059\u306e\u3067\u3001x\u3082-1\u3059\u308b\u3002\n    else:\n        return p[n-1]+1+f(n-1,x-a[n-1]-2)#\u518d\u5e30\u95a2\u6570\u3002\u884c\u5217\u771f\u3093\u4e2d\u306e\u6b21\uff5e\u30e9\u30b9\u30c8\u306e\u624b\u524d\u307e\u3067\nprint(f(n,x))", "N, X = list(map(int, input().split()))\n\nsize = [1]\npatty = [1]\nfor i in range(N):\n    size.append(size[i]*2 + 3)\n    patty.append(patty[i]*2 + 1)\n\ndef f(N, X):\n    if N == 0:\n        return 0 if X <= 0 else 1\n    elif X <= size[N-1] + 1:\n        return f(N-1, X-1)\n    elif X == size[N-1] + 2:\n        return patty[N-1] + 1\n    elif X >= size[N-1] + 3:\n        return patty[N-1] + 1 + f(N-1, X-size[N-1]-2)\nprint((f(N,X)))\n", "N, X = map(int, input().split())\na,p=[1],[1]\nfor i in range(N):\n  a.append(a[i] * 2 + 3) \n  p.append(p[i] * 2 + 1)\n\ndef f(N,X):\n  if N == 0:\n    return 0 if X <= 0 else 1 \n  elif X <= 1 + a[N-1]:\n    return f(N-1, X-1) \n  else:\n    return p[N-1] + 1 + f(N-1, X-2-a[N-1])\n\nprint(f(N, X))", "import sys\nsys.setrecursionlimit(10**6)\n\ndef rec(level, x):\n    # print(level,x)\n    l_len = pow(2,level+2)-3\n    l_len_1 = pow(2,level+1)-3\n    num = pow(2,level+1)-1\n    num_1 = pow(2,level)-1\n    # if level == -2: return\n    if level == 0: return 1\n    if x == 0: return 0\n    if x == 1: return 0\n    if x <= l_len_1+1: return rec(level-1,x-1)\n    if x <= l_len_1+2: return num_1 + 1\n    if x <= l_len-1: return num_1+1 + rec(level-1, x-l_len_1-2)\n    else: return num\n\n    # if x == l_len: return num\n    # if x <= (l_len-1)//2: return rec(level-1,x-1)\n    # if x == (l_len-1)//2+1: return num_1+1\n    # else: return num_1+1 + rec(level-1, x-((l_len-1)//2+1))\n\n\ndef main():\n    n,x = map(int, input().split())\n    print(rec(n,x))\n\ndef __starting_point():\n    main()\n__starting_point()", "N,X = map(int,input().split())\n\ndef f(N,X):\n  if N==0:\n    return 0 if X<=0 else 1\n  elif X<=1+2**(N+1)-3:\n    return f(N-1,X-1)\n  else:\n    return 2**(N)+f(N-1,X-2**(N+1)+3-2)\n        \nprint(f(N,X))", "N, X = list(map(int, input().split()))\nL = [1 for _ in range(N+1)]\nS = [1 for _ in range(N+1)]\nfor n in range(1, N+1):\n    L[n] = L[n-1] * 2 + 3\n    S[n] = S[n-1] * 2 + 1\n\ndef rec(level, K):\n    if level == 0:\n        return 1\n    if K == 1:\n        return 0\n    elif K <= L[level-1] + 1:\n        return rec(level-1, K-1)\n    elif K == L[level-1] + 2:\n        return S[level-1] + 1\n    elif K <= L[level-1] * 2 + 2:\n        return rec(level-1, K - L[level-1] - 2) + S[level-1] + 1;\n    else:\n        return S[level-1] * 2 + 1\n\nprint((rec(N, X)))\n", "n,x= map(int,input().split())\ntp=0\nfor i in range(n):\n    ct = (2**(n-i+2)-4)//2+1\n    if x==0:break\n    if i==n-1:tp+='bpppb'[:x].count('p')\n    else:\n        pn = 2**(n-i)-1\n        if x<ct:x-=1\n        elif x>=ct:\n            tp+=pn+1\n            if x==ct:break\n            x-=ct\nprint(tp)", "N, X = map(int, input().split())\nl = [1]\nfor i in range(N):\n  l.append(2*l[-1]+1)\n\ndef main(n, x, ans):\n  nonlocal X\n  nonlocal l\n  if n == 0:\n    return ans+1\n  elif x==1:\n    return ans\n  elif x==2*l[n]-1:\n    return ans+2*l[n-1]+1\n  elif x == l[n]:\n    return main(n-1, x-2, ans+1)\n  elif x < l[n]:\n    return main(n-1, x-1, ans)\n  else:\n    return main(n-1, x-2*l[n-1]-1, ans+l[n-1]+1)\n  \na = main(N, X, 0)\nprint(a)", "n, x = list(map(int, input().split()))\nb = 1\np = 1\nfor i in range(n):\n    b = 2 * b + 3\n    p = 2 * p + 1\nx -= 1\nb -= 1\nans = 0\nwhile True:\n    if x == 0:\n        if b == 0:\n            ans += 1\n        break\n    elif x == b:\n        ans += p\n        break\n    elif x == b // 2:\n        ans += p // 2 + 1\n        break\n    elif 0 < x < b // 2:\n        x -= 1\n    else:\n        x -= b // 2 + 1\n        ans += p // 2 + 1\n    b = (b - 3) // 2\n    p = (p - 1) // 2\nprint(ans)\n", "N,X = list(map(int,input().split()))\n\nburgerLengthList = [[] for i in range(51)]\nfor i in range(51):\n    burgerLengthList[i].append(2 ** (i + 2) - 3)\n    burgerLengthList[i].append(2 ** (i + 1) - 1)\n\ndef pNumber(level, number):\n    if level == 0:\n        return 1\n    if number == 1:\n        return 0\n    if number <= burgerLengthList[level][0] // 2:\n        return pNumber(level - 1, number - 1)\n    elif number == burgerLengthList[level][0] // 2 + 1:\n        return pNumber(level - 1, number - 1) + 1\n    else:\n        return burgerLengthList[level - 1][1] + 1 + pNumber(level - 1, number - burgerLengthList[level - 1][0] - 2)\n\nprint(pNumber(N, X))", "def delete_head_zeros(n):\n\tn = str(n)\n\tl = len(n)\n\tif \".\" in n:\n\t\tl = n.find(\".\")\n\thead_zeros = 0\n\tfor i in range(l - 1):\n\t\tif n[i] == \"0\":\n\t\t\thead_zeros += 1\n\t\telse:\n\t\t\tbreak\n\n\treturn n[head_zeros:]\n\n# compare a, b\n# a, b: int or string\ndef bigint_compare(a, b):\n\ta = delete_head_zeros(a)\n\tb = delete_head_zeros(b)\n\tif len(a) > len(b):\n\t\treturn 1\n\telif len(a) < len(b):\n\t\treturn -1\n\telse:\n\t\tif a > b:\n\t\t\treturn 1\n\t\telif a < b:\n\t\t\treturn -1\n\t\telse:\n\t\t\treturn 0\n\n# calculate a + b\n# a, b: int or string\ndef bigint_plus(a, b):\n\ta = str(a)\n\tb = str(b)\n\n\td = max([len(a), len(b)])\n\ta = '0' * (d - len(a)) + a\n\tb = '0' * (d - len(b)) + b\n\n\tans = \"\"\n\tcarry = 0\n\tfor i in range(d):\n\t\ts = int(a[-i-1]) + int(b[-i-1]) + carry\n\t\tcarry = s // 10\n\t\tans = str(s % 10) + ans\n\telse:\n\t\tif carry:\n\t\t\tans = str(carry) + ans\n\n\treturn ans\n\n# calculate a - b\n# a, b: int or string\ndef bigint_minus(a, b): \n\ta = str(a)\n\tb = str(b)\n\tM = []\n\tm = []\n\tsign = \"\"\n\n\tif len(a) > len(b) or (len(a) == len(b) and a >= b):\n\t\t[M, m] = [a, b]\n\telse:\n\t\t[M, m] = [b, a]\n\t\tsign = \"-\"\n\tm = '0' * (len(M) - len(m)) + m\n\n\tans = \"\"\n\tborrow = 0\n\tfor i in range(len(M)):\n\t\ts = int(M[-i-1]) - int(m[-i-1]) - borrow\n\t\tif s < 0:\n\t\t\tborrow = 1\n\t\t\ts += 10\n\t\telse:\n\t\t\tborrow = 0\n\t\tans = str(s) + ans\n\n\treturn sign + delete_head_zeros(ans)\n\n# calculate a * b\n# a, b: int or string\ndef bigint_multiply(a, b):\n\ta = str(a)\n\tb = str(b)\n\n\tmd = []\n\tfor j in range(len(b)):\n\t\tcarry = 0\n\t\tmj = \"\"\n\t\tfor i in range(len(a)):\n\t\t\tm = int(a[-i-1]) * int(b[-j-1]) + carry\n\t\t\tcarry = m // 10\n\t\t\tmj = str(m % 10) + mj\n\t\telse:\n\t\t\tif carry:\n\t\t\t\tmj = str(carry) + mj\n\t\tmd.append(mj)\n\n\tans = 0\n\tfor k in range(len(md)):\n\t\tans = bigint_plus(md[k] + \"0\" * k, ans)\n\n\treturn ans\n\n\n# calculate a / b to d digits after decimal point\n# a, b, d: int or string\ndef bigint_divide(a, b, d = 0):\n\ta = str(a)\n\tb = str(b)\n\td = int(d)\n\tif d < 0:\n\t\td = 0\n\n\tans = \"\"\n\tr = \"\"\n\tfor i in range(len(a) + d):\n\t\tq = 0\n\t\tif i < len(a):\n\t\t\tr += a[i]\n\t\telif i == len(a):\n\t\t\tans += \".\"\n\t\t\tr += \"0\"\n\t\telse:\n\t\t\tr += \"0\"\n\n\t\tif bigint_compare(r, b) == -1:\n\t\t\tans += str(q)\n\t\telse:\n\t\t\twhile bigint_compare(r, b) >= 0:\n\t\t\t\tr = bigint_minus(r, b)\n\t\t\t\tq += 1\n\t\t\tans += str(q)\n\n\treturn delete_head_zeros(ans)\n\ndef main():\n\tN, X = input().split(\" \")\n\tlayer = [1]\n\tpatties = [1]\n\tfor i in range(int(N)):\n\t\tlayer.append(bigint_plus(bigint_multiply(layer[-1], 2), 3))\n\t\tpatties.append(bigint_plus(bigint_multiply(patties[-1], 2), 1))\n\n\tdef count_patty(L, Y, P): # Y, P : bigint\n\t\tif L == 0:\n\t\t\treturn bigint_plus(P, 1)\n\t\tcenter = bigint_divide(bigint_plus(layer[L], 1), 2)\n\t\tif Y == \"1\":\n\t\t\treturn P\n\t\telif Y == layer[L]:\n\t\t\treturn bigint_plus(P, patties[L])\n\t\telif bigint_compare(Y, center) == 0:\n\t\t\treturn bigint_plus(bigint_plus(P, 1), patties[L - 1])\n\t\telif bigint_compare(Y, center) == 1:\n\t\t\treturn count_patty(L - 1, bigint_minus(Y, center), bigint_plus(bigint_plus(P, patties[L - 1]), 1))\n\t\telif bigint_compare(Y, center) == -1:\n\t\t\treturn count_patty(L - 1, bigint_minus(Y, 1), P)\n\n\tprint(count_patty(int(N), X, \"0\"))\n\nmain()", "N, X=map(int, input().split())\n\ndef A(x):\n  return pow(2, x+2)-3\n\ndef P(x):\n  return pow(2, x+1)-1\n\ndef f(n, x):\n  if n==0:\n    return 1\n  if n==1:\n    return min(x-1, 3)\n  if x<=n:\n    return 0\n  if A(n)//2+1==x:\n    return P(n-1)+1\n  if A(n)==x:\n    return P(n)\n  if A(n)//2>=x:\n    return f(n-1, x-1)\n  return P(n-1)+1+f(n-1, x-A(n)//2-1)\n\nprint(f(N, X))", "import sys\nfrom functools import lru_cache\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, X = list(map(int, readline().split()))\n\n    A = [0] * (N + 1)\n    B = [0] * (N + 1)\n    A[0] = B[0] = 1\n    for i in range(N):\n        A[i + 1] = 2 * A[i] + 3\n        B[i + 1] = 2 * B[i] + 1\n\n    def rec(i, x):\n        if i == 0:\n            return 1 if x > 0 else 0\n        elif x <= 1 + A[i - 1]:\n            return rec(i - 1, x - 1)\n        else:\n            return B[i - 1] + 1 + rec(i - 1, x - 2 - A[i - 1])\n\n    print((rec(N, X)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\n# \u30ec\u30d9\u30ebn\u30d0\u30fc\u30ac\u30fc\ndef f(n, x):\n    if n == 0:\n        return 0 if x <= 0 else 1\n    elif x <= 1 + a[n-1]:\n        return f(n-1, x-1)\n    else:\n        return p[n-1] + 1 + f(n-1, x-2-a[n-1])\n\nn, x = MAP()\na = [0]*n\np = [0]*n\na[0] = 1\np[0] = 1\nfor i in range(1, n):\n    a[i] = a[i-1]*2 + 3\n    p[i] = p[i-1]*2 + 1\n\nprint(f(n, x))", "import sys, bisect, math, itertools, string, queue, copy\nimport numpy as np\nimport scipy\nfrom collections import Counter,defaultdict,deque\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nfrom fractions import gcd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nN, X = list(map(int, input().split()))\na,p=[1],[1]\nfor i in range(N):\n  a.append(a[i] * 2 + 3) \n  p.append(p[i] * 2 + 1)\n\ndef f(N,X):\n  if N == 0:\n    return 0 if X <= 0 else 1 \n  elif X <= 1 + a[N-1]:\n    return f(N-1, X-1) \n  else:\n    return p[N-1] + 1 + f(N-1, X-2-a[N-1])\n\nprint((f(N, X)))\n", "\ndef resolve():\n    N, X = map(int, input().split())\n\n    As = [1]  # \u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u539a\u3055\uff08\u5c64\u306e\u7dcf\u6570\uff09\uff08\u5fc5\u305a\u5947\u6570\uff09\n    Ps = [1]  # \u30ec\u30d9\u30ebi\u30d0\u30fc\u30ac\u30fc\u306e\u30d1\u30c6\u30a3\u306e\u7dcf\u6570\n\n    for i in range(N):\n        As.append(As[i] * 2 + 3)  # \u30ec\u30d9\u30eb\u304c1\u4e0a\u304c\u308b\u3068\u3001\u7dcf\u6570\u306f2\u500d+3\u306b\u306a\u308b\n        Ps.append(Ps[i] * 2 + 1)  # \u30ec\u30d9\u30eb\u304c1\u4e0a\u304c\u308b\u3068\u3001\u30d1\u30c6\u30a3\u306e\u6570\u306f2\u500d+1\u306b\u306a\u308b\n\n    def f(n, x):\n        if n == 0:\n            return 0 if x <= 0 else 1\n        mid = (As[n] + 1) // 2\n\n        # \u30d0\u30fc\u30ac\u30fc\u306e\u771f\u3093\u4e2d\u306b\u306f\u30d1\u30c6\u30a3\u304c\u3042\u308b\u3002\u305d\u306e\u30d1\u30c6\u30a3\u3092\u542b\u3080\u304b\u306e\u5834\u5408\u5206\u3051\u3092\u3059\u308b\n        if x < mid:\n            return f(n - 1, x - 1)\n        elif x == mid:\n            return Ps[n - 1] + 1\n        elif x > mid:\n            return Ps[n - 1] + 1 + f(n - 1, x - mid)\n\n    ans = f(N, X)\n\n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "import sys\nfrom functools import lru_cache\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, X = list(map(int, readline().split()))\n\n    @lru_cache(maxsize=None)\n    def rec1(i):\n        if i == 0:\n            return 1\n        else:\n            return 2 * rec1(i - 1) + 1\n\n    @lru_cache(maxsize=None)\n    def rec2(i):\n        if i == 0:\n            return 1\n        else:\n            return 2 * rec2(i - 1) + 3\n\n    def rec(i, x):\n        if x <= 0:\n            return 0\n        if i == 0:\n            return 1\n\n        x -= 1\n        ans = 0\n        if x > rec2(i - 1):\n            x -= rec2(i - 1)\n            ans += rec1(i - 1)\n        else:\n            ans += rec(i - 1, x)\n            return ans\n\n        if x > 0:\n            x -= 1\n            ans += 1\n        else:\n            return ans\n\n        if x > rec2(i - 1):\n            x -= rec2(i - 1)\n            ans += rec1(i - 1)\n        else:\n            ans += rec(i - 1, x)\n\n        return ans\n\n    print((rec(N, X)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
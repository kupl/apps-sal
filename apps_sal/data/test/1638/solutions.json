["def main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    S = -1\n    for mid in range(N):\n        ans = [0] * N\n        ans[mid] = A[mid]\n        prev = A[mid]\n        for j in range(mid-1, -1, -1):\n            ans[j] = min(prev, A[j])\n            prev = ans[j]\n        prev = A[mid]\n        for j in range(mid+1, N):\n            ans[j] = min(prev, A[j])\n            prev = ans[j]\n        if sum(ans) > S:\n            S = sum(ans)\n            ans_best = ans\n    print(*ans_best)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def solve():\n    n = int(input())\n    m = list(map(int, input().split()))\n    answ = [0] * n\n    answc = 0\n    for i in range(n):\n        cur = [0] * n\n        cur[i] = m[i]\n        for j in range(i+1, n):\n            cur[j] = min(cur[j-1], m[j])\n        for j in range(i-1, -1, -1):\n            cur[j] = min(cur[j+1], m[j])\n        s = sum(cur)\n        if s > answc:\n            answc = s\n            answ = cur\n    print(*answ)\n\n\n\nfor i in range(1):\n    solve()\n", "from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom functools import *\nfrom itertools import permutations,combinations,groupby\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport random\ndef Golf():\n    *a,=map(int,open(0))\ndef S_():\n    return input()\ndef IS():\n    return input().split()\ndef LS():\n    return [i for i in input().split()]\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef NI(n):\n    return [int(input()) for i in range(n)]\ndef NI_(n):\n    return [int(input())-1 for i in range(n)]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef ItoS(nn):\n    return chr(nn+97)\ndef LtoS(ls):\n    return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[]\n    g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI()\n        org_inp.append(inp)\n        if index==0:\n            inp[0]-=1\n            inp[1]-=1\n        if len(inp)==2:\n            a,b=inp\n            g[a].append(b)\n            if not Directed:\n                g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp\n            aa=(inp[0],inp[2])\n            bb=(inp[1],inp[2])\n            g[a].append(bb)\n            if not Directed:\n                g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\n    mp=[1]*(w+2)\n    found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[1]+[mp_def[j] for j in s]+[1]\n    mp+=[1]*(w+2)\n    return h+2,w+2,mp,found\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb//(n**bt)%n for bt in range(k)]\n        rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['YES','NO']\nYn=['Yes','No']\n\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\nu_alp=string.ascii_uppercase\n#ts=time.time()\n#sys.setrecursionlimit(10**7)\ninput=lambda: sys.stdin.readline().rstrip()\n \ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\ndef ran_input():\n    import random\n    n=random.randint(4,16)\n    rmin,rmax=1,10\n    a=[random.randint(rmin,rmax) for _ in range(n)]\n    return n,a\n\nshow_flg=False\nshow_flg=True\n\nans=0\n\nn=I()\nm=LI()\ntot=0\nfor i in range(n):\n    l,r=[],[]\n    \n    tmp=m[i]\n    p=m[i]\n    \n    # right\n    for j in range(i+1,n):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        r+=[p]\n    \n    p=m[i]\n    # left\n    for j in range(i-1,-1,-1):\n        if m[j]<p:\n            p=m[j]\n        tmp+=p\n        l+=[p]\n    \n    if tmp>tot:\n        tot=tmp\n        ans=l[::-1]+[m[i]]+r\n        \nprint(*ans)\n\n\n\n\n", "from math import *\nfrom collections import *\nn = int(input())\na = list(map(int,input().split()))\nans = 0\nfres = []\nfor i in range(n):\n\ts = a[i]\n\tprev = a[i]\n\tres = []\n\tfor j in range(i-1,-1,-1):\n\t\tprev = min(a[j],prev)\n\t\ts += prev\n\t\tres.append(prev)\n\tprev = a[i]\n\tres = res[::-1]\n\tres.append(a[i])\n\tfor j in range(i+1,n):\n\t\tprev = min(a[j],prev)\n\t\ts += prev\n\t\tres.append(prev) \n\tif(s > ans):\n\t\tans = s\n\t\tfres = res[::]\nfor i in fres:\n\tprint(i,end = \" \")", "import sys \ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\n\nans = 0\nind = -1\nfor i in range(n):\n    tmp = a[i]\n    l = i\n    r = i\n    \n    max_height = a[i]\n    for j in range(0, l)[::-1]:\n        if a[j] >= max_height: \n            tmp += max_height\n        else:\n            tmp += a[j]\n            max_height = a[j]\n        \n    max_height = a[i]\n    for j in range(r + 1, n):\n        if a[j] >= max_height: \n            tmp += max_height\n        else:\n            tmp += a[j]\n            max_height = a[j]\n    if ans < tmp:\n        ans = tmp\n        ind = i\n\ni = ind\nans = [0] * n\n\ntmp = a[i]\nl = i\nr = i\n\nmax_height = a[i]\nans[i] = a[i]\nfor j in range(0, l)[::-1]:\n    if a[j] >= max_height: \n        tmp += max_height\n    else:\n        tmp += a[j]\n        max_height = a[j]\n    ans[j] = max_height\n    \nmax_height = a[i]\nfor j in range(r + 1, n):\n    if a[j] >= max_height: \n        tmp += max_height\n    else:\n        tmp += a[j]\n        max_height = a[j]\n    ans[j] = max_height\nprint(*ans)", "n = int(input())\na = list(map(int, input().split()))\n\nfans = 0\nheight = [0] * n\nma = []\nfor m in range(n):\n    minh = 0\n    thisans = 0\n    # increasing\n    np = False\n    height[m] = a[m]\n    for i in range(m-1, -1, -1):\n        height[i] = height[i + 1]\n        if height[i] > a[i]:\n            height[i] = a[i]\n\n    for i in range(m+1, n):\n        height[i] = height[i-1]\n        if height[i] > a[i]:\n            height[i] = a[i]\n    thisans = sum(height)\n    # fans = max(fans, thisans)\n    if thisans > fans:\n        ma = height.copy()\n        fans = thisans\nprint(*list(ma))", "n=int(input())\nL=list(map(int,input().split()))\nans=[0]*n\nsA=0\nfor top in range(n):\n    r=[]\n\n    if top!=0:\n        left=[]\n        now=L[top]\n        for i in range(top)[::-1]:\n            now=min(now,L[i])\n            left.append(now)\n        r+=left[::-1]\n    r.append(L[top])\n    if top!=n-1:\n        right=[]\n        now=L[top]\n        for i in range(top+1,n):\n            now=min(now,L[i])\n            right.append(now)\n        r+=right\n    sr=sum(r)\n    if sA<sr:\n        sA=sr\n        ans=r\nfor i in range(n):\n    print(ans[i],end=' ')", "def f():\n    n = int(input())\n    M = [int(s) for s in input().split()]\n    def goLeftFrom(s):\n        sum = 0\n        cur = M[s]\n        for i in range(s-1,-1,-1):\n            cur = min(cur,M[i])\n            sum += cur\n        return sum\n    def goRightFrom(s):\n        sum = 0\n        cur = M[s]\n        for i in range(s+1,n):\n            cur = min(cur,M[i])\n            sum += cur\n        return sum\n    ans = 0\n    choose = -1\n    for i in range(n):\n        l = goLeftFrom(i)\n        r = goRightFrom(i)\n        if l+r+M[i] > ans:\n            choose = i\n            ans = l+r+M[i]\n    rt = [0]*n\n    s = choose\n    rt[s] = M[s]\n    cur = M[s]\n    for i in range(s - 1, -1, -1):\n        cur = min(cur, M[i])\n        rt[i] = cur\n    cur = M[s]\n    for i in range(s + 1, n):\n        cur = min(cur, M[i])\n        rt[i] = cur\n    print(' '.join(str(num) for num in rt))\n\n\n\n\nf()", "n = int(input())\nsp = list(map(int, input().split()))\nforw = [0 for i in range(n)]\nbackw = [0 for i in range(n)]\nstack = [(0, -1, 0)]\nfor i in range(n):\n\twhile (sp[i] <= stack[-1][0]):\n\t\tstack.pop()\n\tstack.append((sp[i], i, (i - stack[-1][1]) * sp[i] + stack[-1][2]))\n\tforw[i] = stack[-1][2]\nrevsp = sp[::-1]\nstack = [(0, -1, 0)]\n\nfor i in range(n):\n\twhile (revsp[i] <= stack[-1][0]):\n\t\tstack.pop()\n\tstack.append((revsp[i], i, (i - stack[-1][1]) * revsp[i] + stack[-1][2]))\n\tbackw[i] = stack[-1][2]\n\nbackw = backw[::-1]\n#print(forw)\n#print(backw)\n\ncenter = 0\nans_center = 0\nfor i in range(n):\n\tif ans_center < backw[i] + forw[i] - sp[i]:\n\t\tcenter = i\n\t\tans_center = backw[i] + forw[i] - sp[i]\n#print(center)\nans = [0 for i in range(n)]\nans[center] = sp[center]\ncur = sp[center]\nfor i in range(center - 1, -1, -1):\n\tcur = min(cur, sp[i])\n\tans[i] = cur\ncur = sp[center]\nfor i in range(center + 1, n, 1):\n\tcur = min(cur, sp[i])\n\tans[i] = cur\n\nprint(*ans)\n", "N = int(input())\n\nm = list(map(int, input().split()))\nans = 0\n\ndef sol(k):\n    ret = l = r = m[k]\n    for i in range(k+1, N):\n        if m[i] < r: r = m[i]\n        ret += r\n    for i in range(k-1, -1, -1):\n        if m[i] < l: l = m[i]\n        ret += l\n    return ret\nans_idx = -1\nfor i in range(N):\n    X = sol(i)\n    if ans < X:\n        ans = X\n        ans_idx = i\n\nl = r = m[ans_idx]\nfor i in range(ans_idx+1, N):\n    if m[i] < r:\n        r = m[i]\n    else:\n        m[i] = r\nfor i in range(ans_idx-1, -1, -1):\n        if m[i] < l:\n            l = m[i]\n        else:\n            m[i] = l\nprint(*m)", "import sys\n\nn=int(sys.stdin.readline())\n\nm=[int(x) for x in sys.stdin.readline().split()]\n\nans=0\n\narr=[0]*n\n\nfor i in range(n):\n\t\n\tfloors=m[i]\n\t\t\n\ttmp=[0]*n\n\ttmp[i]=m[i]\n\n\tprev=m[i]\n\tfor j in range(i-1,-1,-1):\n\t\tnum=min(prev,m[j])\n\t\tfloors+=num\n\t\ttmp[j]=num\n\t\tprev=num\n\n\tp2=m[i]\n\tfor k in range(i+1,n):\n\t\tn2=min(p2,m[k])\n\t\tfloors+=n2\n\t\ttmp[k]=n2\n\t\tp2=n2\n\n\tif(floors>ans):\n\t\tans=floors\n\t\tfor g in range(n):\n\t\t\tarr[g]=tmp[g]\n\nfor p in range(n):\n\tprint(arr[p],end=\" \")\nprint()\n", "from sys import stdin,stdout\ninput=stdin.readline\nn=int(input())\na=list(map(int,input().split()))\ndict=[]\nval=-1\ni=0\nwhile i<n:\n    v=a[i]\n    j=i-1\n    arr=[]\n    pmin=v\n    while j>=0:\n        v+=min(a[j],pmin)\n        arr.append(min(a[j],pmin))\n        pmin=min(pmin,min(a[j],pmin))\n        j-=1\n        \n    arr=arr[::-1]\n    arr.append(a[i])\n    j=i+1\n    pmin=v\n    while j<n:\n        v+=min(a[j],pmin)\n        arr.append(min(a[j],pmin))\n        pmin=min(pmin,min(a[j],pmin))\n        j+=1\n    if v>val:\n\n        val=max(val,v)\n        dict=arr\n    i+=1\nprint(*dict)\n#print(dict.values())\n    \n\n\n\n", "n = int(input())\nm = list(map(int,input().split()))\nans = []\ntotalmax = 0\nfor top in range(n):\n    lst = [0]*n\n    lst[top] = m[top]\n    for i in range(top-1,-1,-1):\n        lst[i] = min(lst[i+1],m[i])\n    for i in range(top+1,n):\n        lst[i] = min(lst[i-1],m[i])\n    total = sum(lst)\n    if totalmax < total:\n        ans = lst\n        totalmax = total\n\nprint(*ans,sep=\" \")", "n = int(input())\narr = list(map(int, input().split()))\nans = 0\nres = None\nfor i in range(n):\n\ttemp = list(arr)\n\tmini = arr[i]\n\tfor j in range(i-1, -1, -1):\n\t\ttemp[j] = min(temp[j], mini)\n\t\tmini = min(mini, temp[j])\n\tmini = arr[i]\n\tfor j in range(i+1, n):\n\t\ttemp[j] = min(temp[j], mini)\n\t\tmini = min(mini, temp[j])\n\ts = sum(temp)\n\tif s > ans:\n\t\tans = s\n\t\tres = list(temp)\nprint(*res)", "from copy import copy\nfrom math import *\n\ndef arr_float_inp():\n    return [float(s) for s in input().split()]\n\n\ndef arr_int_inp():\n    return [int(s) for s in input().split()]\n\n\ndef int_inp():\n    return int(input())\n\n\ndef float_inp():\n    return float(input())\n\n\ndef comp(a):\n    return a[0]\n\n\ndef gcd(a, b):\n    if b != 0:\n        return gcd(b, a % b)\n    else:\n        return a\n\n\ndef __starting_point():\n    n = int_inp()\n    arr = arr_int_inp()\n    outs = []\n    for j in range(len(arr)):\n        max_el = (j, arr[j])\n\n        new_arr = [0 for _ in range(len(arr))]\n        new_arr[max_el[0]] = max_el[1]\n        right = max_el[1]\n        for i in range(max_el[0], -1, -1):\n            new_arr[i] = min(arr[i], right)\n            right = new_arr[i]\n\n        left = max_el[1]\n        for i in range(max_el[0], len(arr)):\n            new_arr[i] = min(arr[i], left)\n            left = new_arr[i]\n\n        outs.append(new_arr)\n\n    max_out = (sum(outs[0]), outs[0])\n    for out in outs:\n        new_sum = sum(out)\n        if new_sum > max_out[0]:\n            max_out = (new_sum, out)\n\n    for el in max_out[1]:\n        print(el, end=' ')\n\n__starting_point()", "n = int(input())\nm = list(map(int, input().split()))\nans, idx = 0, -1\nfor i in range(n):\n    a = [0] * n\n    a[i] = m[i]\n    for j in range(i - 1, -1, -1):\n        a[j] = min(m[j], a[j + 1])\n    for j in range(i + 1, n):\n        a[j] = min(m[j], a[j - 1])\n    tot = sum(a)\n    if tot > ans:\n        ans = tot\n        idx = i\na = [0] * n\na[idx] = m[idx]\nfor j in range(idx - 1, -1, -1):\n    a[j] = min(m[j], a[j + 1])\nfor j in range(idx + 1, n):\n    a[j] = min(m[j], a[j - 1])\nprint(*a)\n"]
["def resolve():\n    H, W, D = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [list(map(int, input().split())) for _ in range(Q)]\n\n    num_to_pos = {}\n    for i in range(H):\n        for j in range(W):\n            num_to_pos[A[i][j]] = (i, j)\n    \n    acc = [[0] for _ in range(D+1)]\n    for i in range(1, D+1):\n        num = i\n        idx = 0\n        while num + D <= H*W:\n            _from = num_to_pos[num]\n            _to = num_to_pos[num+D]\n            acc[i].append(acc[i][idx]+abs(_from[0]-_to[0])+abs(_from[1]-_to[1]))\n            num += D\n            idx += 1\n    \n    # print(acc)\n    for lr in LR:\n        l, r = lr\n        series = l%D if l%D != 0 else D\n        # print(\"---\")\n        # print(series)\n        # print(l, r)\n        print((acc[series][(r-series)//D] - acc[series][(l-series)//D]))\n            \n\n\n\nif '__main__' == __name__:\n    resolve()\n", "h,w,d = map(int,input().split())\na = [0]*h\nfor i in range(h):\n    a[i] = list(map(int,input().split()))\nnum = [[] for i in range(w*h+1)]\nfor i in range(h):\n    for j in range(w):\n        num[a[i][j]].append([i,j])\ns = [0]*(h*w+1)\nfor i in range(1,h*w-d+1):\n    s[d+i] = s[i] + abs(num[d+i][0][0]-num[i][0][0]) + abs(num[d+i][0][1]-num[i][0][1])\nq = int(input())\nfor i in range(q):\n    L,R = map(int,input().split())\n    print(s[R]-s[L])", "h,w,d=list(map(int,input().split()))\na=[list(map(int, input().split())) for _ in range(h)]\nq=int(input())\nlr=[list(map(int, input().split())) for _ in range(q)]\n\nnums={}\nfor i in range(h):\n    for j in range(w):\n        nums[a[i][j]]=(i,j)\n\nacc=[0]*(h*w)\nfor i in range(h*w):\n    if i>=d:\n        _to=nums[i+1]\n        _from=nums[i+1-d]\n        acc[i]+=acc[i-d]+abs(_from[0]-_to[0])+abs(_from[1]-_to[1])\n\nfor l,r in lr:\n    print((acc[r-1]-acc[l-1]))\n\n\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\n#from decimal import *\n\nH, W, D = MAP()\nA = [LIST() for _ in range(H)]\n\ndic = defaultdict(tuple)\n\nfor y in range(H):\n\tfor x in range(W):\n\t\tdic[A[y][x]] = (y+1, x+1)\n\npower = [[] for _ in range(D)]\nfor i in range(1, H*W+1):\n\tif i <= D:\n\t\tpower[i%D].append(0)\n\telse:\n\t\tidx = i%D\n\t\ttmp = abs(dic[i][0]-dic[i-D][0]) + abs(dic[i][1]-dic[i-D][1])\n\t\tpower[i%D].append(tmp)\n\n#print(power)\npower_acc = []\nfor x in power:\n\tpower_acc.append(list(accumulate(x)))\npower_acc[0].insert(0, 0)\n#print(power_acc)\n\nQ = INT()\nfor _ in range(Q):\n\tL, R = MAP()\n\tprint(power_acc[R%D][R//D] - power_acc[L%D][L//D])", "import sys\n\nimport numba as nb\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\n@nb.njit(\"void(i8,i8,i8,i8[:,:],i8,i8[:,:],i8[:])\", cache=True)\ndef dfs(H, W, D, A, Q, LR, ans):\n    position = [(-1, -1)] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = np.zeros(shape=(H * W + 1), dtype=np.int64)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = np.cumsum(mp[d::D])\n\n    for i in range(Q):\n        l, r = LR[i]\n        ans[i] = mp[r] - mp[l]\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = np.zeros(shape=(H, W), dtype=np.int64)\n    for i in range(H):\n        A[i] = tuple(map(int, input().split()))\n    Q = int(input())\n    LR = np.zeros(shape=(Q, 2), dtype=np.int64)\n    for i in range(Q):\n        LR[i] = tuple(map(int, input().split()))\n\n    ans = np.zeros(shape=Q, dtype=np.int64)\n    dfs(H, W, D, A, Q, LR, ans)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = map(int, input().split())\nAindex = [0] * (H*W)\nfor h in range(H):\n    w = 0\n    for A in input().split():\n        Aindex[int(A)-1] = (h,w)\n        w += 1 \n\nimport numpy as np\nv, h = int(np.ceil(H*W/D)), D\nMp = np.zeros((v, h)) #Mp\u3092Mod D\u5225\u306b\u8a08\u7b97\u3059\u308b\u4e88\u5b9a\nmp = lambda X, Y: abs(X[0]-Y[0]) + abs(X[1]-Y[1]) #\u9b54\u529b\u8a08\u7b97\u3059\u308b\u95a2\u6570\nfor x in range(D,H*W):\n    i, j = divmod(x, D)\n    Mp[i,j] = mp(Aindex[x], Aindex[x-D])\n#\u7e26\u8ef8\u65b9\u5411\u306b\u7d2f\u7a4d\u548c\u3092\u53d6\u3063\u3066\u304a\u304d\u3001\u5f8c\u306e\u30af\u30a8\u30ea\u306bO(1)\u3067\u5bfe\u5fdc\nMp = Mp.cumsum(axis=0)\n\n#\u30af\u30a8\u30ea\u51e6\u7406\nQ = int(input())\nQuery = [(int(x) for x in input().split()) for _ in range(Q)]\nfor l, r in Query:\n    ans = Mp[divmod(r-1, D)] - Mp[divmod(l-1,D)]\n    print(int(ans))", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nh,w,d=nii()\n\na_dict={}\nfor i in range(h):\n  a=lnii()\n  for j in range(w):\n    a_dict[a[j]]=(i,j)\n\nb_dict={}\nfor i in range(1,d+1):\n  num=i\n  cy,cx=a_dict[num]\n  b_dict[num]=0\n  while num+d<=h*w:\n    num+=d\n    ny,nx=a_dict[num]\n    b_dict[num]=b_dict[num-d]+abs(cy-ny)+abs(cx-nx)\n    cy=ny\n    cx=nx\n\nq=int(input())\nfor i in range(q):\n  l,r=nii()\n  ans=b_dict[r]-b_dict[l]\n  print(ans)", "H, W, D = map(int, input().split())\nA = [-1] * (H*W+1)\ncnt = 0\nfor i in range(H):\n  for j in list(map(int, input().split())):\n    A[j] = cnt\n    cnt += 1\n\ndp = [0] * (H*W+1)\ntmp = 1\nfor i in range(D):\n  h, w = A[tmp]//W+1, A[tmp]%W+1\n  t = tmp + D\n  cnt = 0\n  while t <= H*W:\n    x, y = A[t]//W+1, A[t]%W+1\n    cnt += abs(x-h) + abs(y-w)\n    dp[t] = cnt\n    h, w = x, y\n    t += D\n  tmp += 1\n\nQ = int(input())\nfor i in range(Q):\n  l, r = map(int, input().split())\n  ans = dp[r] - dp[l]\n  print(ans)", "import sys\ninput=sys.stdin.buffer.readline\ninputs=sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**9)\nh,w,d=list(map(int,input().split()))\ninds={}\nfor i in range(h):\n    for D,j in enumerate(input().split()):\n        inds[int(j)-1]=(i,D)\nnows=[[0]for c in range(d)]\n\nfor k in range(d,h*w):\n    a,b=inds[k]\n    x,y=inds[k-d]\n    k%=d\n    nows[k].append(nows[k][-1]+abs(a-x)+abs(b-y))\nq=input()\nfor i in inputs():\n    l,r=list(map(int,i.split()))\n    l-=1;r-=1\n    l,b=divmod(l,d)\n    r,b=divmod(r,d)\n    print((nows[b][r]-nows[b][l]))\n", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nh,w,d=nii()\n\na_dict={}\nfor i in range(h):\n  a=lnii()\n  for j in range(w):\n    a_dict[a[j]]=(i,j)\n\nb_dict={}\nfor i in range(1,h*w+1):\n  if i-d<=0:\n    b_dict[i]=0\n  else:\n    oy,ox=a_dict[i-d]\n    ny,nx=a_dict[i]\n    b_dict[i]=b_dict[i-d]+abs(ny-oy)+abs(nx-ox)\n\nq=int(input())\nfor i in range(q):\n  l,r=nii()\n  ans=b_dict[r]-b_dict[l]\n  print(ans)", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [str(mp[r] - mp[l]) for l, r in LR]\n    ans = \"\\n\".join(ans)\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [None] * H\n    for i in range(H):\n        A[i] = tuple(map(int, input().split()))\n    Q = int(input())\n    LR = [None] * Q\n    for i in range(Q):\n        LR[i] = tuple(map(int, input().split()))\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h, w, d = list(map(int, input().split()))\na = [tuple(map(int, input().split())) for _ in range(h)]\n\ninf = 1 << 30\n\npos = [(0, 0)] * (h * w + 1)\ndist = [inf] * (h * w + 1)\n\nfor i in range(h):\n    for j in range(w):\n        pos[a[i][j]] = (i, j)\n\nfor i in range(1, h * w):\n    if dist[i] == inf:\n        dist[i] = 0\n        j = i + d\n        while j <= h * w:\n            dist[j] = dist[j - d] + abs(pos[j][0] - pos[j - d][0]) + \\\n                abs(pos[j][1] - pos[j - d][1])\n            j += d\n\n\nq = int(input())\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    print((dist[r] - dist[l]))\n", "def main():\n  H,W,D=list(map(int,input().split()))\n  A=[]\n  for h in range(H):\n    for w,a in enumerate(map(int,input().split())):\n      A+=[[a,h,w]]\n  A.sort(key=lambda x:x[0])\n\n  B=[0]*(H*W)\n  for i in range(D):\n    while i+D<W*H:\n      B[i+D]=B[i]+abs(A[i][1]-A[i+D][1])+abs(A[i][2]-A[i+D][2])\n      i+=D\n\n  for q in range(int(input())):\n    l,r=list(map(int,input().split()))\n    print((B[~-r]-B[~-l]))\n\nmain()\n", "h,w,d= map(int,input().split())\nloc=[[] for _ in range(w*h+1)]\ncost=[0]*(w*h+1)\nfor i in range(h):\n    l= list(map(int,input().split()))\n    for j in range(w):loc[l[j]]=[i,j]\nfor t in range(w*h+1,0,-1):\n    if t+d < w*h+1:\n        ti,tj=loc[t+d]\n        fi,fj=loc[t]\n        tempcost= abs(fi-ti)+abs(fj-tj)\n        cost[t]=cost[t+d]+tempcost\nq= int(input())\nfor i in range(q):\n    l,r= map(int,input().split())\n    print(cost[l]-cost[r])", "h,w,d = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(h)]\nq = int(input())\nlr = [list(map(int, input().split())) for _ in range(q)]\nb = [0]*(h*w+1)\nfor i in range(h):\n    for j in range(w):\n        b[a[i][j]] = (i,j)\n#print(b)\nans = [0]*(h*w+1)\nfor i in range(d+1,h*w+1):\n    ans[i] = ans[i-d]+abs(b[i][0]-b[i-d][0])+abs(b[i][1]-b[i-d][1])\n#print(ans)\nfor i in range(q):\n    x,y = lr[i][0],lr[i][1]\n    print(ans[y]-ans[x])", "def main():\n    from itertools import accumulate\n    h, w, d = list(map(int, input().split()))\n\n    a = [0] * (h * w + 1)\n    b = [0] * (h * w + 1)\n    for i in range(1, h + 1):\n        l = list(map(int, input().split()))\n        for j, k in enumerate(l, 1):\n            a[k] = i\n            b[k] = j\n\n    c = [0] * (h * w + 1)\n    for i in range(d + 1, h * w + 1):\n        c[i] = c[i - d] + abs(a[i] - a[i - d]) + abs(b[i] - b[i - d])\n\n    q = int(input())\n    res = []\n    for _ in range(q):\n        l, r = list(map(int, input().split()))\n        res.append(c[r] - c[l])\n\n    ans = '\\n'.join(map(str, res))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\nin_n = lambda: int(readline())\nin_nn = lambda: list(map(int, readline().split()))\nin_nl = lambda: list(map(int, readline().split()))\nin_na = lambda: list(map(int, read().split()))\nin_s = lambda: readline().rstrip().decode('utf-8')\n\n\ndef main():\n    H, W, D = in_nn()\n    A = [list(map(int, readline().split())) for _ in range(H)]\n    Q = in_n()\n    LR = [list(map(int, readline().split())) for _ in range(Q)]\n\n    grid = [tuple()] * (H * W + 1)\n    for y in range(H):\n        for x in range(W):\n            num = A[y][x]\n            grid[num] = (x + 1, y + 1)\n\n    move = [[] for _ in range(D)]\n    for i in range(D):\n        if i == 0:\n            s = D\n        else:\n            s = i\n        while s <= H * W:\n            move[i].append(grid[s])\n            s += D\n\n    d = [[] for _ in range(D)]\n    for i in range(D):\n        d[i].append(0)\n        for j in range(len(move[i]) - 1):\n            x, y = move[i][j]\n            nx, ny = move[i][j + 1]\n            d[i].append(abs(nx - x) + abs(ny - y))\n\n    for i in range(D):\n        for j in range(len(d[i]) - 1):\n            d[i][j + 1] += d[i][j]\n\n    # print(d)\n\n    ans = [0] * Q\n    for i in range(Q):\n        l, r = LR[i]\n        q1, rr = divmod(l, D)\n        q2, _ = divmod(r, D)\n        if rr == 0:\n            ans[i] = d[rr][q2 - 1] - d[rr][q1 - 1]\n        else:\n            ans[i] = d[rr][q2] - d[rr][q1]\n\n    print(('\\n'.join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    h,w,d = map(int,input().split())\n    a = []\n    for i in range(h):\n        a.append(list(map(int,input().split())))\n    M = [[] for i in range(h*w)]\n    for i in range(h):\n        for j in range(w):\n            M[a[i][j]-1] = [i,j]\n    dist = [0 for i in range(h*w)]\n    for i in range(h*w):\n        if i-d>=0:\n            dist[i] += dist[i-d] + abs(M[i][0]-M[i-d][0]) + abs(M[i][1]-M[i-d][1])\n\n    q = int(input())\n    for i in range(q):\n        l,r = map(int,input().split())\n        print(dist[r-1]-dist[l-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [mp[r] - mp[l] for l, r in LR]\n    ans = \"\\n\".join(map(str, ans))\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [None] * H\n    for i in range(H):\n        A[i] = tuple(map(int, input().split()))\n    Q = int(input())\n    LR = [None] * Q\n    for i in range(Q):\n        LR[i] = tuple(map(int, input().split()))\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = list(map(int,input().split()))\nd = {}\nfor i in range(1, H+1):\n    A = list(map(int,input().split()))\n    for j in range(W):\n        d[A[j]] = (i, j+1)\nacc = [[] for _ in range(D)]\nfor i in range(1, D+1):\n    acc[i-1].append(0)\n    for j in range(i, H*W+1-D, D):\n        x,y = d[j]\n        a,b = d[j+D]\n        #print(\"po:\",j, j+D)\n        acc[i-1].append(acc[i-1][-1]+abs(a-x)+abs(b-y))\n    \nQ = int(input())\nfor _ in range(Q):\n    l, r = list(map(int,input().split()))\n    print((acc[(l-1)%D][(r-1)//D]-acc[(l-1)%D][(l-1)//D]))\n", "#!/usr/bin/env python3\nimport sys\nfrom collections import deque, Counter\nfrom heapq import heappop, heappush\nfrom bisect import bisect_right\nfrom itertools import accumulate\n\nsys.setrecursionlimit(10**6)\nINF = 10**12\nm = 10**9 + 7\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [None] * (H*W)\n    for i in range(H):\n        s = list(map(int, input().split()))\n        for j in range(W):\n            A[s[j]-1] = (i,j)\n\n    # print(A)\n    costs = [0]*(H*W)\n    for i in range(D):\n        j = H*W-1-i\n        while j-D >= 0:\n            costs[j-D] = costs[j] + abs(A[j][0]-A[j-D][0]) + abs(A[j][1]-A[j-D][1])\n            j -= D\n    \n    Q = int(input())\n    for i in range(Q):\n        L, R = [int(x)-1 for x in input().split()]\n        print((costs[L]-costs[R]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = list(map(int, input().split()))\nd, px, py = [0]*(H*W+1), [0]*(H*W+1), [0]*(H*W+1)\n\nfor i in range(H):\n    a = list(map(int, input().split()))\n    for j in range(W):\n        px[a[j]] = i\n        py[a[j]] = j\n\nfor i in range(D+1, H*W+1):\n    d[i] = d[i-D]+abs(px[i]-px[i-D])+abs(py[i]-py[i-D])\n\n# print(d)\n\nQ = int(input())\nfor _ in range(Q):\n    l, r = list(map(int, input().split()))\n    print((d[r]-d[l]))\n", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef dfs(H, W, D, A, Q, LR):\n    position = [(-1, -1)] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [mp[r] - mp[l] for l, r in LR]\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [None] * H\n    for i in range(H):\n        A[i] = tuple(map(int, input().split()))\n    Q = int(input())\n    LR = [None] * Q\n    for i in range(Q):\n        LR[i] = tuple(map(int, input().split()))\n\n    ans = [0] * Q\n    ans = dfs(H, W, D, A, Q, LR)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h, w, d = map(int, input().split())\narr = [0] * (h * w + 1)\n\na = [list(map(int, input().split())) for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        s = a[i][j]\n        arr[s] = (i, j)\n\nq = int(input())\nlr = [list(map(int, input().split())) for _ in range(q)]\n\ncnt = h * w\nresult = [[0] for _ in range(d)]\nfor i in range(d):\n    l = i\n    score = 0\n    while l + d <= cnt:\n        if l == 0:\n            result[i].append(score)\n            l += d\n            continue\n        (ux, uy) = arr[l]\n        (vx, vy) = arr[l + d]\n        score += (abs(vx - ux) + abs(vy - uy))\n        result[i].append(score)\n        l += d\n\n\nfor l, r in lr:\n    ans = result[l % d]\n    print(ans[r // d] - ans[l // d])", "def main():\n    import sys\n    input = sys.stdin.readline\n    H, W, D = [int(x) for x in input().strip().split()]\n    M = [0] * H\n    C = {}\n    revM = {}\n    for h in range(H):\n        M[h] = [int(x) for x in input().strip().split()]\n        for i, w in enumerate(M[h]):\n            revM[w] = (h, i)\n    Q = int(input())\n    HW = H * W\n    ans = [0] * (HW + 1)\n    for i in range(1, D+1):\n        cur = i\n        while cur + D <= HW:\n            ans[cur+D] += ans[cur] + abs(revM[cur][0] - revM[cur+D][0]) + abs(revM[cur][1] - revM[cur+D][1])\n            cur += D\n\n    for q in range(Q):\n        l, r = [int(x) for x in input().strip().split()]\n        print(ans[r]-ans[l])\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n  H,W,D=list(map(int,input().split()))\n\n  A=[[0,0] for i in range(H*W)]\n  for h in range(H):\n    for w,a in enumerate(map(int,input().split())):\n      A[~-a][0],A[~-a][1]=h,w\n\n  B=[0]*(H*W)\n  for i in range(H*W-D):\n    B[i+D]=B[i]+abs(A[i][0]-A[i+D][0])+abs(A[i][1]-A[i+D][1])\n\n  for q in range(int(input())):\n    l,r=list(map(int,input().split()))\n    print((B[~-r]-B[~-l]))\n\nmain()\n", "# coding: utf-8\nimport sys\n\n# from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nprintout = sys.stdout.write\nsprint = sys.stdout.flush\n# from heapq import heappop, heappush\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\nimport math\n# from itertools import product, accumulate, combinations, product\nimport bisect\n# import numpy as np\n# from copy import deepcopy\n#from collections import deque\n# from decimal import Decimal\n# from numba import jit\n\nINF = 1 << 50\nEPS = 1e-8\nmod = 998244353\n\n\ndef intread():\n    return int(sysread())\ndef mapline(t=int):\n    return list(map(t, sysread().split()))\ndef mapread(t=int):\n    return list(map(t, read().split()))\n\n\n\ndef run():\n    H, W, D = mapline()\n    A = [[-1] * (W+1) for _ in range(H+1)]\n    for i in range(1, H+1):\n        A[i][1:] = mapline()\n\n    V = [-1] * (H*W + 1)\n    for i in range(1, H+1):\n        for j in range(1, W+1):\n            V[A[i][j]] = (i, j)\n\n    cache = [-1] * (H*W+1)\n\n    Q = intread()\n    for _ in range(Q):\n        l, r = mapline()\n        if cache[r] == -1:\n            mostR = r + (H*W - r) // D * D\n            mostL = l % D\n            if not mostL:\n                mostL = D\n            ci, cj = V[mostR]\n            tmp = 0\n            cache[mostR] = 0\n            #print(mostL, mostR)\n            for v in range(mostR - D, mostL-D, -D):\n                #print(v, V[v])\n                ni, nj = V[v]\n                tmp += abs(ni - ci) + abs(nj - cj)\n                cache[v] = tmp\n                ci, cj = ni, nj\n        #print(cache)\n        print((cache[l] - cache[r]))\n\n\ndef __starting_point():\n    #print(math.gcd(0, 10))\n    run()\n\n__starting_point()", "import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    h, w, d = ns()\n    pos = dict()\n    for i in range(h):\n        a = na()\n        for j, ai in enumerate(a):\n            pos[ai - 1] = (i, j)\n\n    cum = [[0] for _ in range(d)]\n\n    for i in range(d):\n        x, y = pos[i]\n        num = i + d\n        while num < h * w:\n            xi, yi = pos[num]\n            tmp = abs(xi - x) + abs(yi - y)\n            cum[i].append(cum[i][-1] + tmp)\n            x, y = xi, yi\n            num += d\n\n    q = ni()\n    for _ in range(q):\n        l, r = ns()\n        l, r = l - 1, r - 1\n        tmp = cum[l % d][r // d] - cum[l % d][l // d]\n        print(tmp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\ninv_A = [(0, 0)] * (H*W+1)\nfor y, a in enumerate(A):\n    for x, a_ in enumerate(a):\n        inv_A[a_] = (y, x)\nC = [0] * D\nc = 0\nfor i in range(D, H*W+1):\n    y1, x1 = inv_A[i]\n    y2, x2 = inv_A[i-D]\n    C.append(abs(y1-y2)+abs(x1-x2)+C[i-D])\nAns = []\nQ = int(input())\nfor _ in range(Q):\n    l, r = list(map(int, input().split()))\n    Ans.append(C[r]-C[l])\nprint((\"\\n\".join(map(str, Ans))))\n", "H,W,D=list(map(int,input().split()))\n\ndef main():\n  A=list()\n  for h in range(H):\n    for w,a in enumerate(map(int,input().split())):\n      A.append([a,h,w])\n\n  A=sorted(A, key=lambda x:x[0])\n\n  B=[0]*(H*W)\n  for i in range(D):\n    while i+D<W*H:\n      B[i+D]=B[i]+abs(A[i][1]-A[i+D][1])+abs(A[i][2]-A[i+D][2])\n      i+=D\n\n  for q in range(int(input())):\n    l,r=list(map(int,input().split()))\n    print((B[~-r]-B[~-l]))\n\nmain()\n", "h, w, d = map(int, input().split())\npos = [-1 for _ in range(h * w)]\n\nfor i in range(h):\n    alst = list(map(int, input().split()))\n    for j, a in enumerate(alst):\n        pos[a - 1] = [i, j]\ndif = [0 for _ in range(h * w)]\ncheck = [False for _ in range(h * w)]\n\nfor num in range(h * w):\n    if check[num]:\n        continue\n    check[num] = True\n    total = 0\n    dif[num] = total\n    for j in range(num + d, h * w, d):\n        dx = pos[j][0] - pos[j - d][0]\n        dy = pos[j][1] - pos[j - d][1]\n        dd = abs(dx) + abs(dy)\n        total += dd\n        dif[j] = total\n        check[j] = True\n        \nfor _ in range(int(input())):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    print(abs(dif[l] - dif[r]))", "h,w,d = map(int, input().split())\n\ndp= [0]*(h*w+1)\n\nab = [list(map(int, input().split())) for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        s = ab[i][j]\n        dp[s] =[i,j]\n        \ndpp= [0]*(h*w+1)\n\nfor k in range(d+1,h*w+1):\n#    print(k)\n    dpp[k] = dpp[k-d] + abs(dp[k][0]-dp[k-d][0]) +abs(dp[k][1]-dp[k-d][1])\n    \nq = int(input())\n\nfor x in range(q):\n    a,b = map(int, input().split())\n    print(dpp[b]-dpp[a])", "def main():\n    h, w, d = list(map(int, input().split()))\n\n    a = [None] * (h * w + 1)\n    for i in range(1, h + 1):\n        l = list(map(int, input().split()))\n        for j, k in enumerate(l, 1):\n            a[k] = (i, j)\n\n    c = [0] * (h * w + 1)\n    for i in range(d + 1, h * w + 1):\n        xb, yb = a[i-d]\n        xn, yn = a[i]\n        c[i] = c[i - d] + abs(xn - xb) + abs(yn - yb)\n\n    q = int(input())\n    res = []\n    for _ in range(q):\n        l, r = list(map(int, input().split()))\n        res.append(c[r] - c[l])\n\n    ans = '\\n'.join(map(str, res))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(H)]\n\nd = {}\nfor y in range(H):\n    for x in range(W):\n        d[A[y][x]] = (y, x)\n\nt = [[0] * (H * W // D + 1) for _ in range(D)]\nfor i in range(D):\n    j = 0\n    if i == 0:\n        j = 1\n    while i + (j + 1) * D <= H * W:\n        y1, x1 = d[i + j * D]\n        y2, x2 = d[i + (j + 1) * D]\n        t[i][j + 1] = abs(y1 - y2) + abs(x1 - x2)\n        j += 1\n    for j in range(H * W // D):\n        t[i][j + 1] += t[i][j]\n\nQ = int(input())\nresult = []\nfor _ in range(Q):\n    L, R = map(int, input().split())\n    i = L % D\n    result.append(t[i][(R - i) // D] - t[i][(L - i) // D])\n#print('\\n'.join(str(i) for i in result))\nprint(*result, sep='\\n')\n", "h, w, d = map(int, input().split())\na = []\nfor _ in range(h):\n    a.append(list(map(int, input().split())))\nq = int(input())\nquerys = []\nfor _ in range(q):\n    l, r = map(int, input().split())\n    querys.append((l-1, r-1))\ncoor = [None]*(h*w)\nfor i in range(h):\n    for j in range(w):\n        coor[a[i][j]-1] = (i, j)\naccu = [0]*(h*w)\nfor i in range(d, h*w):\n    px, py = coor[i-d]\n    x, y = coor[i]\n    accu[i] = accu[i-d] + abs(x-px) + abs(y-py)\nfor l, r in querys:\n    print(accu[r]-accu[l])", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  h,w,d=LI()\n  l=[LI() for _ in range(h)]\n\n  q=I()\n  ql=[LI() for _ in range(q)]\n\n  dic={}\n  for i in range(h):\n    for j in range(w):\n      x=l[i][j]\n      dic[x]=(i+1,j+1)\n\n  n=h*w\n  to_last_distance=[0]*n\n  for i in range(1,n+1)[::-1]:\n    if i+d<=n:\n      i_y,i_x=dic[i]\n      ipd_y,ipd_x=dic[i+d]\n      to_last_distance[i-1]=to_last_distance[i+d-1]\n      to_last_distance[i-1]+=(abs(i_y-ipd_y)+abs(i_x-ipd_x))\n\n  # print(to_last_distance)\n\n  ans=[]\n  for st,ed in ql:\n    ans.append(to_last_distance[st-1]-to_last_distance[ed-1])\n\n  for x in ans:\n    print(x)\n\nmain()\n# print(main())\n", "import itertools\nI = [int(_) for _ in open(0).read().split()]\nH, W, D = I[:3]\nA = I[3:3 + H * W]\nQ = I[3 + H * W]\nLR = I[4 + H * W:]\n\na_i = [0] * (H * W + 1)\nfor i, a in enumerate(A):\n    a_i[a] = i\n\n\ndef calc(a1):\n    a2 = a1 + D\n    hw1 = a_i[a1]\n    h1, w1 = divmod(hw1, W)\n    hw2 = a_i[a2]\n    h2, w2 = divmod(hw2, W)\n    return abs(h2 - h1) + abs(w2 - w1)\n\n\nscore = [0] + [calc(i) for i in range(1, H * W + 1 - D)]\ncum = [[0] + list(itertools.accumulate(score[i::D])) for i in range(D)]\nans = []\nfor l, r in zip(LR[::2], LR[1::2]):\n    ans += [cum[r % D][r // D] - cum[l % D][l // D]]\nprint(*ans, sep='\\n')\n", "import sys\nreadline = sys.stdin.readline\n\nH,W,D = list(map(int,readline().split()))\n\nroute = [0] * (H * W + 1)\nfor i in range(H):\n  line = list(map(int,readline().split()))\n  for j in range(len(line)):\n    route[line[j]] = (i,j)\n\n# 1,2,3 ... \u306e\u9802\u70b9\u756a\u53f7\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\u3092\u4f5c\u308b\n# D\u500b\u304a\u304d\u306b\u8ddd\u96e2\u3092\u683c\u7d0d\u3059\u308b\n\ndist = [0] * (H * W + 1)\nfor i in range(D + 1,len(route)):\n  gy,gx = route[i]\n  sy,sx = route[i - D]\n  dist[i] = abs(gy - sy) + abs(gx - sx) \n  dist[i] = dist[i] + dist[i - D]\n\n\nQ = int(readline())\n\nfor i in range(Q):\n  l,r = list(map(int,readline().split()))\n  print((dist[r] - dist[l]))\n", "import sys\nread = sys.stdin.buffer.read\ninp = iter(map(int, read().split()))\n\nH, W, D = next(inp), next(inp), next(inp)\naddr = [None] * (H*W+1)\nfor i in range(H):\n    for j in range(W):\n        v = next(inp)\n        addr[v] = (i, j)\n\ncost = []\nfor m in range(D):\n    arr = [0]\n    for x in range((H*W-m)//D):\n        if m + x * D == 0:\n            arr.append(0)\n            continue\n        r, c = addr[m + x * D]\n        nr, nc = addr[m + (x+1) *D]\n        arr.append(arr[-1] + abs(nr - r) + abs(nc - c))\n    cost.append(arr)\n\nQ = next(inp)\nfor _ in range(Q):\n    s, t = next(inp), next(inp)\n    m = s % D\n    ans = cost[m][t//D] - cost[m][s//D]\n    print(ans)", "h, w, d = map(int, input().split())\narr = [0] * (h * w + 1)\n\na = [list(map(int, input().split())) for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        s = a[i][j]\n        arr[s] = (i, j)\n\nq = int(input())\nlr = [list(map(int, input().split())) for _ in range(q)]\n\ncnt = h * w\nresult = [[0] for _ in range(d)]\nfor i in range(d):\n    l = i\n    score = 0\n    while l + d <= cnt:\n        if l == 0:\n            result[i].append(score)\n            l += d\n            continue\n        (ux, uy) = arr[l]\n        (vx, vy) = arr[l + d]\n        score += (abs(vx - ux) + abs(vy - uy))\n        result[i].append(score)\n        l += d\n\n\nfor l, r in lr:\n    ans = result[l % d]\n    print(ans[r // d] - ans[l // d])", "h, w, d = map(int, input().split())\ng = [[] for _ in range(w)]\nfor _ in range(h):\n    tmp_list = list(map(int, input().split()))\n    for i in range(w):\n        g[i].append(tmp_list[i])\nq = int(input())\nqs = [list(map(int, input().split())) for _ in range(q)]\nloc = [0]*(h*w+1)\nfor i in range(h):\n    for j in range(w):\n        loc[g[j][i]] = (i,j)\nroots = [0]*(h*w+1)\nfor i in range(1,d+1):\n    j = i + d\n    while j < h*w+1:\n        cost = abs(loc[j][0]-loc[j-d][0]) + abs(loc[j][1]-loc[j-d][1])\n        roots[j] = cost + roots[j-d]\n        j += d\nfor i in qs:\n    l, r = i[0], i[1]\n    print(roots[r] - roots[l])", "import sys\nreadline=sys.stdin.readline\nread=sys.stdin.read\n \nh,w,d=map(int,readline().split())\na=[list(map(int,readline().split())) for _ in range(h)]\nq,*lr=map(int,read().split())\n\nca=dict()\nfor i,l in enumerate(a):\n  for j,e in enumerate(l):\n    ca[e]=(i+1,j+1)\nmp=[[0]*((h*w)//d+1) for _ in range(d)]\nfor i,mpl in enumerate(mp):\n  for j,_ in enumerate(mpl[:-1]):\n    if 0<i+d*j<=h*w-d:\n      mpl[j+1]=mpl[j]+abs(ca[i+d*j][0]-ca[i+d*(j+1)][0])\\\n                +abs(ca[i+d*j][1]-ca[i+d*(j+1)][1])\nfor l,r in zip(*[iter(lr)]*2):\n  print(mp[l%d][r//d]-mp[l%d][l//d])", "H, W, D = list(map(int, input().split()))\n\nbase = []\nfor h in range(H):\n    num = list(map(int, input().split()))\n    for w in range(W):\n        base.append((num[w], h+1, w+1))\n\nbase.sort(key=lambda tup:tup[0])\ndist = [0]*(W*H+D+1)\nfor i in range(W*H-D):\n    wei1, h1, w1 = base[i]\n    wei2, h2, w2 = base[i+D]\n    dist[i+D] = dist[i] + abs(h1-h2) + abs(w1-w2)\n\nQ = int(input())\nfor _ in range(Q):\n    p0, p1 = list(map(int, input().split()))\n    print((abs(dist[p1-1]-dist[p0-1])))\n\n", "H,W,D=map(int,input().split())\nA=[list(map(int,input().split()))for _ in range(H)]\nQ=int(input())\nlr=[list(map(int,input().split()))for _ in range(Q)]\n\nC={}\nfor i in range(H):\n    for j in range(W):\n        C[A[i][j]]=[j,i]\n\nS=[0]*(H*W+1)\ni=D+1\nwhile i<H*W+1:\n    x1,y1=C[i][0],C[i][1]\n    x2,y2=C[i-D][0],C[i-D][1]\n    S[i]=S[i-D]+abs(x2-x1)+abs(y2-y1)\n    i+=1\n\nfor l,r in lr:\n    q=S[r]-S[l]\n    print(q)", "H,W,D = map(int,input().split())\nP = [None]*(H*W+1)\n\nfor h in range(H):\n  A = list(map(int,input().split()))\n  for w in range(W):\n    P[A[w]] = [h,w]\n\nB = [0]*(H*W+1)\n\nfor n in range(D+1,H*W+1):\n  B[n] = B[n-D]+abs(P[n][0]-P[n-D][0])+abs(P[n][1]-P[n-D][1])\n\nQ = int(input())\nans = 0\nfor q in range(Q):\n  L,R = map(int,input().split())\n  print(B[R]-B[L])", "import sys\nreadline = sys.stdin.readline\nh, w, d = map(int, readline().split())\nA = [list(map(int, readline().split())) for _ in range(h)]\nq = int(readline())\nLR = [tuple(map(lambda x:int(x)-1, readline().split())) for _ in range(q)]\n\nD = dict()\nfor hi in range(h):\n    for wi in range(w):\n        D[A[hi][wi]-1] = [hi,wi]\n\nDP = [0]*(h*w)\nfor i in range(d, h*w):\n    px, py = D[i-d]\n    x, y = D[i]\n    DP[i] = DP[i-d] + abs(x-px) + abs(y-py)\n\nfor l,r in LR:\n    print(DP[r]-DP[l])", "from collections import defaultdict\n\nH, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\nQ = int(input())\nLR = [list(map(int, input().split())) for _ in range(Q)]\n\n# 1 -> 1+D ->\n# 2 -> 2+D ->\n# 3 -> 3+D -> \u307f\u305f\u3044\u306a\u3082\u306e\u3092\u4e8b\u524d\u306b\u8a08\u7b97\n\n# \u8f9e\u66f8\u3067\u7ba1\u7406\u3059\u308b\n# d[A[i][j]] = [i,j] \u307f\u305f\u3044\u306a\u611f\u3058\nd = defaultdict(list)\nfor i in range(H):\n    for j in range(W):\n        d[A[i][j]].append([i, j])\n\n\np = []\nfor s in range(1, D + 1):\n    c = 0\n    q = [0]\n    for i in range(s + D, H * W + 1, D):\n        i0, j0 = d[i - D][0]\n        i1, j1 = d[i][0]\n        c += abs(i0 - i1) + abs(j0 - j1)\n        q.append(c)\n\n    p.append(q)\n\n\nfor l, r in LR:\n    i = l % D - 1\n    s = (l - 1) // D\n    e = (r - 1) // D\n    print((p[i][e] - p[i][s]))\n", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(H)]\n\n    x = [0] * (H * W + 1)\n    p = [[] for _ in range(H * W + 1)]\n\n    for h in range(H):\n        for w in range(W):\n            p[A[h][w]] = [h, w]\n\n    for i in range(D + 1, H * W + 1):\n        x[i] = x[i - D] + abs(p[i][0] - p[i - D][0]) + abs(p[i][1] - p[i - D][1])\n\n    for _ in range(int(input())):\n        l, r = list(map(int, input().split()))\n        print((x[r] - x[l]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [str(mp[r] - mp[l]) for l, r in LR]\n    ans = \"\\n\".join(ans)\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [list(map(int, input().split())) for _ in range(Q)]\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\n\nd = {}\nfor y in range(H):\n    for x in range(W):\n        d[A[y][x]] = (y, x)\n\nt = [[0] * (H * W // D + 1) for _ in range(D)]\nfor i in range(D):\n    j = 0\n    if i == 0:\n        j = 1\n    while i + (j + 1) * D <= H * W:\n        y1, x1 = d[i + j * D]\n        y2, x2 = d[i + (j + 1) * D]\n        t[i][j + 1] = abs(y1 - y2) + abs(x1 - x2)\n        j += 1\n    for j in range(H * W // D):\n        t[i][j + 1] += t[i][j]\n\nQ = int(input())\nresult = []\nfor _ in range(Q):\n    L, R = list(map(int, input().split()))\n    i = L % D\n    result.append(t[i][(R - i) // D] - t[i][(L - i) // D])\nprint(('\\n'.join(str(i) for i in result)))\n#print(*result, sep='\\n')\n", "def get_dist(cur, nxt):\n    return abs(cur[0] - nxt[0]) + abs(cur[1] - nxt[1])\n\n\nH, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\n\npos = {}\nfor i in range(H):\n    for j in range(W):\n        pos[A[i][j]] = (i, j)\n\nacc = [0] * (H * W + 1)\nfor i in range(D + 1, H * W + 1):\n    acc[i] = acc[i - D] + get_dist(pos[i - D], pos[i])\n\nQ = int(input())\nfor _ in range(Q):\n    ans = 0\n    L, R = list(map(int, input().split()))\n    print((acc[R] - acc[L]))\n", "h,w,D = map(int,input().split())\na=[]\n\nfor _ in range(h):\n    b=list(map(int,input().split()))\n    a.append(b)\n\nd={}\nfor i in range(h):\n    c=a[i]\n    for j in range(w):\n        d[c[j]]=(i+1,j+1)\n\n\nR_min=h*w\nR_max=1\nquery=[]\nq=int(input())\nfor _ in range(q):\n    l,r=map(int,input().split())\n    query.append([l,r])\n    R_min = min(l,R_min)\n    R_max = max(r,R_max)\n\n\ncum=[0]*(h*w+1)\nfor k in range(R_min,R_max-D+1):\n    prev = cum[k-1]\n    cost = abs(d[k+D][0]-d[k][0]) + abs(d[k+D][1]-d[k][1])\n    cum[k+D-1]=cost+prev\n\n\n\nfor j in range(q):\n    l,r=query[j][0],query[j][1]\n    score = cum[r-1]-cum[l-1]\n    print(score)", "h, w, d = list(map(int, input().split()))\naa = [\n    list(map(int, input().split()))\n    for _ in range(h)\n]\n\ncd = [None] * (h * w)\nfor y in range(h):\n    for x in range(w):\n        cd[aa[y][x] - 1] = (x, y)\n\nsc = [None] * (h * w)\nsc[:d] = [0] * d\nfor i in range(d, h * w):\n    sc[i] = sc[i - d] + abs(cd[i][0] - cd[i - d][0]) + abs(cd[i][1] - cd[i - d][1])\n\nq = int(input())\nfor i in range(q):\n    l, r = [int(x) - 1 for x in input().split()]\n    print((sc[r] - sc[l]))\n", "H, W, D = map(int, input().split())\nAindex = [0] * (H*W)\nfor h in range(H):\n    w = 0\n    for A in input().split():\n        Aindex[int(A)-1] = (h,w)\n        w += 1 \n\nimport numpy as np\nv, h = int(np.ceil(H*W/D)), D\nMp = np.zeros((v, h), dtype='int64') #Mp\u3092Mod D\u5225\u306b\u8a08\u7b97\u3059\u308b\u4e88\u5b9a\nmp = lambda X, Y: abs(X[0]-Y[0]) + abs(X[1]-Y[1]) #\u9b54\u529b\u8a08\u7b97\u3059\u308b\u95a2\u6570\nfor x in range(D,H*W):\n    i, j = divmod(x, D)\n    Mp[i,j] = mp(Aindex[x], Aindex[x-D])\n#\u7e26\u8ef8\u65b9\u5411\u306b\u7d2f\u7a4d\u548c\u3092\u53d6\u3063\u3066\u304a\u304d\u3001\u5f8c\u306e\u30af\u30a8\u30ea\u306bO(1)\u3067\u5bfe\u5fdc\nMp = Mp.cumsum(axis=0)\n\n#\u30af\u30a8\u30ea\u51e6\u7406\nQ = int(input())\nQuery = [tuple(map(int, input().split())) for _ in range(Q)]\nfor l,r in Query:\n    ans = Mp[divmod(r-1, D)] - Mp[divmod(l-1, D)]\n    print(ans)", "h,w,d=list(map(int,input().split()))\na=[list(map(int,input().split())) for _ in range(h)]\nq=int(input())\nlr=[list(map(int,input().split())) for _ in range(q)]\narys=[[] for i in range(d)]\nsumarys=[[0] for i in range(d)]\nbiarys=[[] for i in range(d)]\nfor i in range(h):\n  for j in range(w):\n    x=a[i][j]%d\n    arys[x].append((a[i][j],i,j))\nfor i in range(d):\n  arys[i].sort(key=lambda x:x[0])\n  tmp=0\n  y,pi,pj=arys[i][0]\n  biarys[i].append(y)\n  for j in range(1,len(arys[i])):\n    y,ni,nj=arys[i][j]\n    biarys[i].append(y)\n    tmp+=abs(pi-ni)+abs(pj-nj)\n    sumarys[i].append(tmp)\n    pi,pj=ni,nj\nfrom bisect import bisect_left\nfor l,r in lr:\n  x=l%d\n  li=bisect_left(biarys[x],l)\n  ri=bisect_left(biarys[x],r)\n  print((sumarys[x][ri]-sumarys[x][li]))\n", "import sys\ninput=sys.stdin.readline\nH,W,D=map(int,input().split())\ncost=[[0 for _ in range((H*W)//D+1)] for i in range(D)]\nL=[0]*(H*W)\nfor i in range(H):\n  L1=list(map(int,input().split()))\n  for j in range(W):\n    L[L1[j]-1]=[i,j]\n    if L1[j]%D!=0:\n      cost[L1[j]%D][L1[j]//D]=[i,j,0]\n    else:\n      cost[L1[j]%D][(L1[j]//D)-1]=[i,j,0]\nfor i in range(D):\n  for j in range(1,len(cost[i])):\n    if cost[i][j]!=0:\n      cost[i][j][2]=cost[i][j-1][2]+abs(cost[i][j][0]-cost[i][j-1][0])+abs(cost[i][j][1]-cost[i][j-1][1])\nQ=int(input())\nfor i in range(Q):\n  A,B=map(int,input().split())\n  c=A%D\n  a=A//D\n  b=B//D\n  if c==0:\n    a,b=a-1,b-1\n  print(cost[c][b][2]-cost[c][a][2])", "import sys\n\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\ndef dfs(H, W, D, A, Q, LR, ans):\n    position = [(-1, -1)] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = np.zeros(shape=(H * W + 1), dtype=np.int64)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = np.cumsum(mp[d::D])\n\n    for i in range(Q):\n        l, r = LR[i]\n        ans[i] = mp[r] - mp[l]\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = np.zeros(shape=(H, W), dtype=np.int64)\n    for i in range(H):\n        A[i] = tuple(map(int, input().split()))\n    Q = int(input())\n    LR = np.zeros(shape=(Q, 2), dtype=np.int64)\n    for i in range(Q):\n        LR[i] = tuple(map(int, input().split()))\n\n    ans = np.zeros(shape=Q, dtype=np.int64)\n    dfs(H, W, D, A, Q, LR, ans)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "h, w, d = map(int, input().split())\na = [list(map(int, input().split())) for i in range(h)]\nQ = int(input())\nlis = [0] * (h * w)\nfor i in range(h):\n    for j in range(w):\n        lis[a[i][j] - 1] = (i, j)\ncum = [0] * d\nfor i in range(d, h * w):\n    cum.append(cum[i - d] + abs(lis[i][0] - lis[i - d][0]) + abs(lis[i][1] - lis[i - d][1]))\nfor i in range(Q):\n    l, r = map(int, input().split())\n    print(cum[r - 1] - cum[l - 1])", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [str(mp[r] - mp[l]) for l, r in LR]\n    ans = \"\\n\".join(ans)\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [tuple(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    h, w, d = ns()\n    pos = dict()\n    for i in range(h):\n        a = na()\n        for j, ai in enumerate(a):\n            pos[ai - 1] = (i, j)\n\n    cum = [[0] for _ in range(d)]\n\n    for i in range(d):\n        x, y = pos[i]\n        num = i\n        while num + d < h * w:\n            num += d\n            xi, yi = pos[num]\n            tmp = abs(xi - x) + abs(yi - y)\n            cum[i].append(cum[i][-1] + tmp)\n            x, y = xi, yi\n\n    q = ni()\n    for _ in range(q):\n        l, r = ns()\n        l, r = l - 1, r - 1\n        tmp = cum[l % d][r // d] - cum[l % d][l // d]\n        print(tmp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nH,W,D=list(map(int,input().split()))\nA=[list(map(int,input().split())) for i in range(H)]\nQ = int(input())\nLR=[list(map(int,input().split())) for i in range(Q)]\n\n\ndict_map = {}\nfor ih in range(H):\n    for iw in range(W):\n        dict_map[A[ih][iw]]=(ih,iw)\n\nmemo = [-1]*(H*W+1)\nfor i in range(1,D+1):\n    useMP = 0\n    direct = list(range(i,H*W+1,D))\n    memo[i]=0\n    for p in range(len(direct)-1):\n        x0,y0 = dict_map[direct[p]]\n        x1,y1 = dict_map[direct[p+1]]\n        dist = abs(x0-x1)+abs(y0-y1)\n        useMP += dist\n        memo[direct[p+1]]=useMP\n\nfor q in range(Q):\n    L,R=LR[q]\n    print((memo[R]-memo[L]))\n", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [str(mp[r] - mp[l]) for l, r in LR]\n    ans = \"\\n\".join(ans)\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [tuple(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\nfrom decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nH, W, D = MAP()\nA = [LIST() for _ in range(H)]\nQ = INT()\nLR = [LIST() for _ in range(Q)]\n\ndic = [[] for _ in range(D)]\n\nfor y in range(H):\n\tfor x in range(W):\n\t\t#print(dic)\n\t\tdic[A[y][x]%D].append([A[y][x], y, x])\n\nfor lis in dic:\n\tlis.sort(key = lambda x:x[0])\n\nfor lis in dic:\n\tlis[0][0] = 0\n\tfor i in range(len(lis)):\n\t\tif i == len(lis)-1:\n\t\t\tbreak\n\t\tpoint = (lis[i][1], lis[i][2])\n\t\tdist_point = (lis[i+1][1], lis[i+1][2])\n\t\tlis[i+1][0] = lis[i][0] + abs(point[0] - dist_point[0]) + abs(point[1]-dist_point[1])\n\n#print(dic)\nfor L, R in LR:\n\tprint((dic[R%D][ceil(R/D)-1][0] - dic[R%D][ceil(L/D)-1][0]))\n\n", "h,w,d=list(map(int,input().split()))\n\nlis=[[] for i in range(h*w)]\nfor i in range(h):\n  ai=list(map(int,input().split()))\n  for j in range(w):\n    lis[ai[j]-1].append(i)\n    lis[ai[j]-1].append(j)\n\nU=[]\n\nfor i in range(d):\n  Ui=[0]\n  j=1\n  while i+j*d<h*w:\n    Ui.append(Ui[j-1]+abs(lis[i+j*d][0]-lis[i+(j-1)*d][0])\n              +abs(lis[i+j*d][1]-lis[i+(j-1)*d][1]))\n    j+=1\n  U.append(Ui)\n\nq=int(input())\n\n\nfor i in range(q):\n  li,ri=[int(x)-1 for x in input().split()]\n  modi=li%d\n  print((U[modi][(ri-modi)//d]-U[modi][(li-modi)//d]))\n", "import sys\n\nH, W, D = map(int, sys.stdin.readline().split())\nnum = {}\nfor j in range(H):\n    tmp = map(int, sys.stdin.readline().split())\n    for i, n in enumerate(tmp):\n        num[n] = (i, j)\n\n# D\u3067\u5206\u985e\u3057\u305f\u7d2f\u7a4d\u548c\n# S[initial % D][j], n = r + D*j\nS = [0 for _ in range(H*W+D)]\nfor i in range(D+1, H*W+1):\n    x, y = num[i]\n    a, b = num[i-D]\n    S[i] = S[i-D] + abs(x - a) + abs(y - b)\n# print(S)\nQ = int(sys.stdin.readline())\nfor _ in range(Q):\n    L, R = map(int, sys.stdin.readline().split())\n    r = L % D\n    print(S[R] - S[L])", "H, W, D = map(int, input().split())\nx = [0] * (H * W + 1)\nfor i in range(H):\n  a = list(map(int, input().split()))\n  for j in range(W):\n    x[a[j]] = [i, j]\n    \n#print(x)\nd = [0] * (H * W + 1)\nfor i in range(1, H * W + 1):\n  if i > D:\n    d[i] = d[i - D] + abs(x[i][0] - x[i - D][0]) + abs(x[i][1] - x[i - D][1])\n\n#print(d)    \nQ = int(input())\nfor i in range(Q):\n  l, r = map(int, input().split())\n  print(d[r] - d[l])", "from itertools import accumulate\n\n\ndef get_dist(cur, nxt):\n    return abs(cur[0] - nxt[0]) + abs(cur[1] - nxt[1])\n\n\nH, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\n\npos = {}\nfor i in range(H):\n    for j in range(W):\n        pos[A[i][j] - 1] = (i, j)\n\nacc = []\nfor i in range(D):\n    res = [0]\n    now = i\n    while now + D < H * W:\n        nxt = now + D\n        res.append(get_dist(pos[now], pos[nxt]))\n        now = nxt\n    acc.append(list(accumulate(res)))\n\nQ = int(input())\nfor _ in range(Q):\n    ans = 0\n    L, R = list(map(int, input().split()))\n    L -= 1\n    R -= 1\n    path = acc[L % D]\n    print((path[R // D] - path[L // D]))\n", "H, W, D = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(H)]\n\nx = [0]*(H*W+1)\np = [[] for _ in range(H*W+1)]\n\nfor h in range(H):\n    for w in range(W):\n        p[A[h][w]] = [h, w]\n\nfor i in range(D+1, H*W+1):\n    x[i] = x[i-D]+abs(p[i][0]-p[i-D][0])+abs(p[i][1]-p[i-D][1])\n\nfor _ in range(int(input())):\n    l, r = map(int, input().split())\n    print(x[r]-x[l])", "import sys\nimport math\nimport collections\nimport bisect\nimport itertools\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline().rstrip())\nns = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna = lambda: list(map(int, sys.stdin.readline().rstrip().split()))\nna1 = lambda: list([int(x) - 1 for x in sys.stdin.readline().rstrip().split()])\n\n\n# ===CODE===\n\ndef main():\n    h, w, d = ns()\n    pos = dict()\n    for i in range(h):\n        a = na()\n        for j, ai in enumerate(a):\n            pos[ai] = (i, j)\n\n    cum = [[0] for _ in range(d)]\n\n    for i in range(d):\n        x, y = pos[i + 1]\n        num = i + 1\n        while num + d <= h * w:\n            num += d\n            xi, yi = pos[num]\n            tmp = abs(xi - x) + abs(yi - y)\n            cum[i].append(cum[i][-1] + tmp)\n            x = xi\n            y = yi\n\n    q = ni()\n    for _ in range(q):\n        l, r = ns()\n        l -= 1\n        r -= 1\n        tmp = cum[l % d][r // d] - cum[l % d][l // d]\n        print(tmp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\nimport sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nH,W,D = map(int,readline().split())\nX = [(0,0) for _ in range(H*W)]\nY = [0 for _ in range(H*W)]\n\nfor i in range(H):\n    A = [int(x)-1 for x in readline().split()]\n    for j in range(W):\n        X[A[j]] = (i,j)\n\nfor i in range(0,H*W-D):\n    Y[i+D] = Y[i] + abs(X[i+D][0] - X[i][0]) + abs(X[i+D][1] - X[i][1])\n\nQ = int(readline())\nfor _ in range(Q):\n    L,R = map(int,readline().split())\n    print(Y[R-1]-Y[L-1])", "\ndef main():\n    H, W, D = map(int, input().split())\n    coordinate = [None] * (H*W)\n    for i in range(H):\n        for j, A in enumerate(list(map(int, input().split()))):\n            coordinate[A-1] = (i, j)\n    \n    cost = [0] * (H*W)\n    dist = lambda X, Y: abs(X[0]-Y[0]) + abs(X[1]-Y[1])\n    for i in range(D, H*W):\n        u,v = divmod(i, D)\n        cost[i] = cost[i-D] + dist(coordinate[i], coordinate[i-D])\n\n    Q = int(input())\n    query = [tuple(map(int, input().split())) for _ in range(Q)]\n    for l, r in query:\n        print(cost[r-1]-cost[l-1])\n\nmain()", "from sys import stdin\ndef input():\n    return stdin.readline().strip()\n\ndef main():\n    h, w, d = map(int, input().split())\n\n    x = [0] * (h*w)\n    y = x.copy()\n    for i in range(h):\n        a = list(map(int, input().split()))\n        for j in range(w):\n            x[a[j] - 1] = i\n            y[a[j] - 1] = j\n\n    # \u7d2f\u7a4d\u548c\n    cost = [[0] for _ in range(d)]\n    for i in range(d, h*w):\n        cost[i%d].append(cost[i%d][-1] + abs(x[i]-x[i-d]) + abs(y[i]-y[i-d]))\n\n    ans = []\n    q = int(input())\n    for _ in range(q):\n        l, r = map(int, input().split())\n        l -= 1\n        r -= 1\n        ans.append(cost[r%d][r//d] - cost[l%d][l//d])\n\n    for i in ans:\n        print(i)\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nh, w, d = list(map(int, input().split()))\nn = h*w\na = [0]*n\nfor i in range(h):\n    t = list(map(int, input().split()))\n    for j in range(w):\n        a[w*i+j] = t[j]-1\n\ndef dist(i, j):\n    dh = abs(i//w - j//w)\n    dw = abs(i%w - j%w)\n    return dh + dw\n\nidx_list = [0] * n\nfor i in range(n):\n    idx_list[a[i]] = i\n\ndist_list = [0]*n\nfor i in range(n):\n    if i < d:\n        dist_list[i] = 0\n    else:\n        dist_list[i] = dist_list[i-d] + dist(idx_list[i-d], idx_list[i])\n\nq = int(input())\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n    l-=1; r-=1\n    print((dist_list[r] - dist_list[l]))\n\n", "h,w,d= map(int, input().split())\na = {}\nfor y in range(h):\n    line = list(map(int, input().split()))\n    for x in range(len(line)):\n        a[line[x]-1] = (y,x)\n\n# \u554f\u984c\u306e\u8003\u3048\u65b9\n# DP\u7684\u306a\u611f\u3058\u3067\u89e3\u3051\u308b\n# \u307e\u305aGrid\u306b\u306a\u3063\u3066\u3044\u308b\u304c\u30011\u6b21\u5143\u306e\u914d\u5217\u3068\u3057\u3066\u8003\u3048\u308b 3*3(=9\u30de\u30b9\u3042\u308b\u72b6\u614b) \u306a\u3089\n#   1,2,3,4,5,6,7,8,9\n# \u3053\u306e\u3068\u304d\u306b\u6570\u5024\u306e\u4f4e\u3044\u65b9\u304b\u3089\u9ad8\u3044\u65b9\u3078\u3044\u304f\u3068\u30b4\u30fc\u30eb\u306b\u3064\u304f(Ri-Li\u304cD\u306e\u500d\u6570\u3067\u3042\u308b\u3053\u3068)\u304c\u4fdd\u8a3c\u3055\u308c\u308b\u306e\u3067\u6700\u5f8c\u306e\u6570\u5b57\u3078\u5411\u304b\u3046\u3068\u304d\u306b\u304b\u304b\u308b\u30b3\u30b9\u30c8\u3092\u8003\u3048\u308b(\u4ee5\u4e0b\u30013*3\u306e\u4f8b)\n#   D=2\u3068\u3057\u305f\u3068\u304d\u306b\u30019\u306f\u3053\u308c\u4ee5\u4e0a\u9032\u3081\u306a\u3044\u306e\u3067\u3001\u30b3\u30b9\u30c80, 8\u3082\u305d\u308c\u4ee5\u4e0a\u9032\u3081\u306a\u3044\u306e\u3067 \u30b3\u30b9\u30c80, 7\u306f9\u306b\u884c\u3051\u308b\u306e\u30679\u306e\u30b3\u30b9\u30c8+7\u304b\u30899\u3078\u5411\u304b\u3046\u30b3\u30b9\u30c8\u3067\u7b97\u51fa\u53ef\u80fd\n#   \u307e\u305f\u30015~9\u3078\u306e\u30b3\u30b9\u30c8\u306f1~9\u3078\u306e\u30b3\u30b9\u30c8\u5f15\u304f1~5\u307e\u3067\u306e\u30b3\u30b9\u30c8\u3068\u306a\u308b\u306e\u3067\u7d2f\u7a4d\u548c\u7684\u306b\u7b54\u3048\u3092\u7b97\u51fa\u3059\u308b\u3053\u3068\u304c\u53ef\u80fd\n\nnum = len(a)\ndp = [0]*num\nfor i in range(num-1, -1, -1):\n    if i+d <= num-1:\n        x, y = a[i]\n        px, py = a[i+d]\n        dp[i] = dp[i+d] + abs(x-px) + abs(y-py)\n\nq = int(input())\nfor _ in range(q):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    print(dp[l]-dp[r])", "#!/usr/bin/env python3\n\nh, w, d = list(map(int, input().split()))\n\nindex = [-1]*(h*w)\nfor i in range(h):\n    a = list(map(int, input().split()))\n    for j in range(len(a)):\n        index[a[j]-1] = (i+1, j+1)\n        # index[a[j]-1] = (i, j)\n# print(index)\n\ndata = [[] for _ in range(d)]\n\nfor i in range(1, d+1):\n    num = i\n    x, y = index[num-1]\n    data[i-1].append(0)\n    num += d\n    while(num <= h*w):\n        x_new, y_new = index[num-1]\n        # data[i-1].append(abs(x-x_new)+abs(y-y_new))\n        data[i-1].append(abs(x-x_new)+abs(y-y_new)+data[i-1][-1])\n        x, y = x_new, y_new\n        num += d\n# print(data)\n\nq = int(input())\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n\n    index_data = l % d-1\n\n    r = (r-1)//d\n    l = (l-1)//d\n    print((data[index_data][r]-data[index_data][l]))\n", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nH, W, D = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(H)]\n\nl = []\n\nfor h in range(H):\n    for w in range(W):\n        l.append((A[h][w], w, h))\n\nl.sort()\n\nS = [0] * (H * W + D + 10)\n\nfor i, x, y in l:\n    if i + D <= H * W:\n        _, xx, yy = l[i + D - 1]\n        S[i + D] = abs(xx - x) + abs(yy - y) + S[i]\n\nQ = int(input())\n\nfor i in range(Q):\n    L, R = list(map(int, input().split()))\n    print((S[R] - S[L]))\n", "h,w,d = map(int,input().split())\na = [list(map(int,input().split())) for _ in range(h)]\nq = int(input())\nlr = [list(map(int,input().split())) for _ in range(q)]\nb = [0]*(h*w+1)\nfor i in range(h):\n  for j in range(w):\n    b[a[i][j]] = (i,j)\nc = [0]*(h*w+1)\nfor i in range(d+1,h*w+1):\n  c[i] = c[i-d] + abs(b[i][0]-b[i-d][0])+abs(b[i][1]-b[i-d][1])\nfor l,r in lr:\n  print(c[r]-c[l])", "def main():\n    h, w, d = list(map(int, input().split()))\n    ans = [[0] for _ in range(d)]\n    s = [0] * d\n    ans[0].append(0)\n    dict = {}\n    for i in range(h):\n        for j, a in enumerate(list(map(int, input().split()))):\n            dict[a] = (i, j)\n    for i in range(1, h * w + 1 - d):\n        m = i % d\n        s[m] += abs(dict[i][0] - dict[i + d][0]) + abs(dict[i][1] - dict[i + d][1])\n        ans[m].append(s[m])\n    q = int(input())\n    for _ in range(q):\n        l, r = list(map(int, input().split()))\n        m = l % d\n        print((ans[m][r // d] - ans[m][l // d]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    H, W, D = LI()\n    A = [LI_() for _ in range(H)]\n    Q = I()\n\n    c = [[] for _ in range((H * W))]\n    for i, j in itertools.product(list(range(H)), list(range(W))):\n        c[A[i][j]] = [i, j]\n\n    c_cum = [0] * (H * W)\n    for i in range(H * W - D):\n        c_cum[i+D] = (abs(c[i+D][0] - c[i][0]) + abs(c[i+D][1] - c[i][1])) + c_cum[i]\n\n    for _ in range(Q):\n        L, R = LI_()\n        ans = c_cum[R] - c_cum[L]\n        print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\n#from decimal import *\n\nH, W, D = MAP()\nA = [LIST() for _ in range(H)]\n\ndic = defaultdict(tuple)\n\nfor y in range(H):\n\tfor x in range(W):\n\t\tdic[A[y][x]] = (y+1, x+1)\n\npower = [[] for _ in range(D)]\nfor i in range(1, H*W+1):\n\tif i <= D:\n\t\tpower[i%D].append(0)\n\telse:\n\t\tidx = i%D\n\t\ttmp = abs(dic[i][0]-dic[i-D][0]) + abs(dic[i][1]-dic[i-D][1])\n\t\tpower[i%D].append(tmp)\n\n#print(power)\npower_acc = []\nfor x in power:\n\tpower_acc.append(list(accumulate(x)))\n#print(power_acc)\n\nQ = INT()\nfor _ in range(Q):\n\tL, R = MAP()\n\tif L%D:\n\t\tprint(power_acc[R%D][R//D] - power_acc[L%D][L//D])\n\telse:\n\t\tprint(power_acc[R%D][R//D-1] - power_acc[L%D][L//D-1])", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    H, W, D = NMI()\n    grid = [NLI() for i in range(H)]\n    Q = NI()\n    querys = [NLI() for i in range(Q)]\n\n    point = [[-1,-1] for _ in range(H*W + 1)]\n    for h in range(H):\n        for w in range(W):\n            a = grid[h][w]\n            point[a] = [h, w]\n\n    cost_S = [0] * (H*W + 1)\n    for c in range(H*W + 1):\n        if c <= D:\n            continue\n\n        cost_S[c] = cost_S[c-D] + abs(point[c][0] - point[c-D][0]) + abs(point[c][1] - point[c-D][1])\n\n    for query in querys:\n        l, r = query\n        print(cost_S[r] - cost_S[l])\n\n\ndef __starting_point():\n    main()\n__starting_point()", "H,W,D=map(int,input().split())\nA=[list(map(int,input().split())) for _ in range(H)]\nQ=int(input())\nLR=[tuple(map(int,input().split())) for _ in range(Q)]\n\npos=[None]*(H*W)\nfor i in range(H):\n  for j in range(W):\n    pos[A[i][j]-1] = (i, j)\n\nd=[0]*(H*W)\nfor i in range(D, H*W):\n  px,py = pos[i-D]\n  x, y = pos[i]\n  d[i]=d[i-D] + abs(x-px) + abs(y-py)\n\nfor l, r in LR:\n  print(d[r-1]-d[l-1])", "h,w,d = map(int, input().split())\n\nfrom collections import defaultdict\nG = defaultdict(list)\nfor i in range(h):\n    l = list(map(int, input().split()))\n    for n, item in enumerate(l):\n        G[item] = [n,i]\n\n\n\n\n# magic is just distance by 1\n\n# if d is 4,\n# 1,5,9 or 2,6,10.. make surplus to categorize\n# query comes 10^5, so O(1) or O(logN) is limit -> cumulativesum\n\ndp = [0 for i in range(h*w+1)]\nfor i in range(d): # 0,1,2,...d-1\n    current_place = i+1\n    while current_place + d <= h*w:\n        x,y = G[current_place]\n        next_place = current_place + d\n        x1,y1 = G[next_place]\n        magic = abs(x-x1) + abs(y-y1)\n        dp[next_place] = magic + dp[current_place]\n        current_place = next_place\n\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    print(dp[r]-dp[l], flush=True)\n\n", "h, w, d = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(h)]\n\npos = [0] * (h*w + 1)\nfor i in range(h):\n    for j in range(w):\n        pos[a[i][j]] = (j, i)\n\ndis = [0] * (h*w + 1)\nfor i in range(h*w+1):\n    if i > d:\n        x1, y1 = pos[i-d]\n        x2, y2 = pos[i]\n        dis[i] = abs(x1-x2) + abs(y1-y2) + dis[i-d]\n\nres = []\nq = int(input())\nfor i in range(q):\n    l, r = list(map(int, input().split()))\n\n    res.append(dis[r]-dis[l])\n\nprint((\"\\n\".join(map(str,res))))\n", "H, W, D = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(H)]\nlst = [[] for _ in range(H * W)]\n\nfor i in range(H):\n    for j in range(W):\n        lst[A[i][j]-1] = [j, i]\ntr = [[0] for _ in range(D)]\nfor i in range(D):\n    for j in range(i+D, W*H, D):\n        dlt = abs(lst[j][0] - lst[j-D][0]) + abs(lst[j][1] - lst[j-D][1])\n        tr[i].append(tr[i][-1] + dlt)\n\nQ = int(input())\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    idx = (l - 1) % D\n    if (l-1)//D == 0: st = 0\n    else: st = (l - 1) // D\n    ed = (r - 1) // D\n    print(tr[idx][ed] - tr[idx][st])", "3\n# -*- coding:utf-8 -*-\n\nimport numpy\nfrom collections import defaultdict\n\ndef main():\n  h, w, d = list(map(int, input().split()))\n  mat_a = numpy.array([list(map(int, input().split())) for _ in range(h)])\n  q = int(input())\n  x_to_pos = dict()\n  \n  for i in range(h):\n    for j in range(w):\n      x_to_pos[mat_a[i, j]] = (i, j)\n      \n  def calc_score(p1, p2):\n    return sum([abs(x-y) for x, y in zip(p1, p2)])\n  \n  visited = numpy.zeros((h, w))\n  costs = defaultdict(dict)\n  for c in range(1, d+1):\n    cost = 0\n    costs[c%d][c] = 0\n    while True:\n      cp = x_to_pos[c]\n      c += d\n      if c > (h*w):\n        break\n      np = x_to_pos[c]\n      cost += calc_score(cp, np)\n      costs[c%d][c] = cost\n  \n  for _ in range(q):\n    l, r = list(map(int, input().split()))\n    print((abs(costs[l%d][l] - costs[l%d][r])))\n\ndef __starting_point():\n  main()\n\n\n__starting_point()", "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.readline\n\n\ndef solve(H, W, D, A, Q, LR):\n    position = [None] * (H * W + 1)\n    for h in range(H):\n        for w in range(W):\n            position[A[h][w]] = (h, w)\n\n    mp = [0] * (H * W + 1)\n\n    for i in range(1, H * W + 1 - D):\n        h, w = position[i]\n        y, x = position[i + D]\n        mp[i + D] = abs(x - w) + abs(y - h)\n\n    for d in range(1, D + 1):\n        mp[d::D] = list(accumulate(mp[d::D]))\n\n    ans = [str(mp[r] - mp[l]) for l, r in LR]\n    ans = \"\\n\".join(ans)\n    return ans\n\n\ndef main():\n    H, W, D = list(map(int, input().split()))\n    A = [list(map(int, input().split())) for _ in range(H)]\n    Q = int(input())\n    LR = [list(map(int, input().split())) for _ in range(Q)]\n\n    ans = solve(H, W, D, A, Q, LR)\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "H,W,D=list(map(int,input().split()))\nA=[]\n\nfor h in range(H):\n    A.append(list(map(int,input().split())))\n\npos= {}\nfor h in range(H):\n    for w in range(W):\n        pos[A[h][w]]=[h,w]\n\nS=[0]*(H*W)\nfor d in range(D):\n    tmp=0\n    now=d+1\n    while now+D<=H*W:\n        nowh,noww=pos[now]\n        newh,neww=pos[now+D]\n        tmp+=abs(nowh-newh)+abs(noww-neww)\n        S[now+D-1]=tmp\n        now+=D\n\nQ=int(input())\nfor i in range(Q):\n    L,R=list(map(int,input().split()))\n    ans=S[R-1]-S[L-1]\n    print(ans)\n", "h, w, d = [int(x) for x in input().split()]\nn = h * w\n\np_list = [None] * (n + 1)\nfor i in range(h):\n    a_list = [int(x) for x in input().split()]\n    for j in range(w):\n        p_list[a_list[j]] = (i, j)\n\nm_a_list = [0] * (n + 1)\nfor start in range(1, d + 1):\n    p_i, p_j = p_list[start]\n    p_target = start\n    for target in range(start + d, n + 1, d):\n        n_i, n_j = p_list[target]\n        m = abs(n_i - p_i) + abs(n_j - p_j)\n        m_a_list[target] = m + m_a_list[p_target]\n        p_i, p_j, p_target = n_i, n_j, target\n\nq = int(input())\nfor _ in range(q):\n    l, r = [int(x) for x in input().split()]\n    print(m_a_list[r] - m_a_list[l])", "h,w,d = map(int, input().split())\nad = {}\nfor i in range(h):\n    line = list(map(int, input().split()))\n    for j in range(w):\n        ad[line[j]] = (i,j)\nq = int(input())\nlr = [list(map(int, input().split())) for _ in range(q)]\n\ncl = [0]*(h*w+1)\nfor i in range(1,h*w+1):\n    if i+d<len(cl):\n        f = ad[i]\n        t = ad[i+d]\n        cl[i+d] = cl[i] + abs(f[0]-t[0]) + abs(f[1]-t[1])\n\nfor l,r in lr:\n    print(cl[r]-cl[l])", "H, W, D = map(int, input().split())\n\nx_axis = [0]*(H*W)\ny_axis = [0]*(H*W)\n\nfor i in range(H):\n  A = list(map(lambda x: int(x)-1, input().split()))\n  for j in range(W):\n    x_axis[A[j]] = j\n    y_axis[A[j]] = i\n\ndef dis(a, b):\n  return abs(x_axis[a]-x_axis[b]) + abs(y_axis[a]-y_axis[b])\n\nmagic = [[0] for _ in range(D)]\n\nfor i in range(D):\n  temp = i\n  while temp < H*W-D:\n    magic[i].append(magic[i][-1] + dis(temp, temp+D))\n    temp += D\n\nQ = int(input())\nfor _ in range(Q):\n  L, R = map(lambda x: int(x)-1, input().split())\n  L, d = divmod(L, D)\n  R //= D\n  print(magic[d][R] - magic[d][L])", "def main():\n    import sys\n    read = sys.stdin.buffer.read\n    readline = sys.stdin.buffer.readline\n    readlines = sys.stdin.buffer.readlines\n    sys.setrecursionlimit(10 ** 7)\n\n    from collections import defaultdict\n    from itertools import accumulate\n\n    h, w, d = list(map(int, readline().split()))\n    dict = defaultdict(list)\n    memo = [[0] for _ in range(d + 1)]\n    for i in range(h):\n        a = list(map(int, readline().split()))\n        for j, aa in enumerate(a):\n            dict[aa] = [i, j]\n    for i in range(1, d + 1):\n        bf = i\n        for af in range(i + d, h * w + 1, d):\n            memo[i].append(abs(dict[bf][0] - dict[af][0]) + abs(dict[bf][1] - dict[af][1]))\n            bf = af\n        memo[i] = list(accumulate(memo[i]))\n    q = int(readline())\n    for _ in range(q):\n        l, r = list(map(int, readline().split()))\n        if r < l:\n            r, l = l, r\n        l, i = divmod(l, d)\n        r //= d\n        if i == 0:\n            i = d\n            l -= 1\n            r -= 1\n        print((memo[i][r] - memo[i][l]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nfrom decimal import Decimal\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\nH,W,D = list(map(int,input().split()))\nA = [list(map(int,input().split())) for _ in range(H)]\ntable = [[-1,-1] for _ in range(H*W+1)]\nfor i in range(H):\n    for j in range(W):\n        a = A[i][j]\n        if a > D:\n            table[a-D][0] = i\n            table[a-D][1] = j\nmagic = [0]*(H*W+1)\nfor i in range(H):\n    for j in range(W):\n        a = A[i][j]\n        if a <= H*W-D:\n            magic[a] = abs(i-table[a][0])+abs(j-table[a][1])\nfor i in range(D+1,H*W+1):\n    magic[i] += magic[i-D]\nQ = int(input())\nans = 0\nfor i in range(Q):\n    L,R = list(map(int,input().split()))\n    if L == R:\n        print((0))\n    else:\n        if L <= D:\n            print((magic[R-D]))\n        else:\n            print((magic[R-D]-magic[L-D]))\n\n\n\n", "from collections import defaultdict\nH,W,D = list(map(int,input().split()))\ngrid = [[0]*W for _ in range(H)]\nfor h in range(H):\n    grid[h] = list(map(int, input().split()))\nnumber_yx = [[0,0] for _ in range(H*W+1)]\nfor y in range(H):\n    for x in range(W):\n        number_yx[grid[y][x]] = [y,x]\nfromto_cost = defaultdict(lambda: defaultdict(int))\nfor mod_group in range(D):\n    # \u5270\u4f59\u3054\u3068\u306b\u30b9\u30bf\u30fc\u30c8\u3092\u6c7a\u5b9a\n    start = mod_group+1\n    previous = start\n    fromto_cost[start][start] = 0\n    previous_y, previous_x = number_yx[previous]\n    cost = 0\n    while previous+D <= (H*W):\n        Next = previous+D \n        Next_y, Next_x = number_yx[Next]\n        cost += abs(Next_y-previous_y) + abs(Next_x-previous_x)\n        fromto_cost[start][Next] = cost\n\n        previous = Next\n        previous_y,previous_x = Next_y,Next_x\n\nQ = int(input())\nans_ls = [0] * Q\nfor i in range(Q):\n    start, goal = list(map(int,input().split()))\n    mod = start % D\n    base = mod\n    if base == 0:\n        base = D \n    base_to_goal = fromto_cost[base][goal]\n    base_to_start = fromto_cost[base][start]\n    ans_ls[i] = base_to_goal - base_to_start\nfor ans in ans_ls:\n    print(ans)\n\n", "h,w,d=map(int,input().split())\nxy=[(0,0)]*(h*w+1)\nfor i in range(h):\n  a=list(map(int,input().split()))\n  for j in range(w):\n    xy[a[j]]=(i+1,j+1)\ns=[0]*(h*w+1)\nfor i in range(d+1,h*w+1):\n  s[i]=abs(xy[i][0]-xy[i-d][0])+abs(xy[i][1]-xy[i-d][1])+s[i-d]\nq=int(input())\nfor _ in range(q):\n  l,r=map(int,input().split())\n  print(s[r]-s[l])", "h, w, d = list(map(int, input().split()))\nn = h*w\npaths = [[]for _ in range(d)]\nfor i in range(n):\n    paths[i % d].append(i)\n\n\nclass P:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\n    def __sub__(self, p):\n        return P(self.x-p.x, self.y-p.y)\n\n    def _abs(self):\n        return P(abs(self.x), abs(self.y))\n\n    def _sum(self):\n        return self.x+self.y\n\n    def to(self, p):\n        return (self-p)._abs()._sum()\n\n\ncoodinates = [None]*n\nfor i in range(h):\n    for j, a in enumerate([int(x)-1 for x in input().split()]):\n        coodinates[a] = P(i, j)\n\ncosts = [[0]for _ in range(d)]\nfor i in range(d):\n    for x, y in zip(paths[i], paths[i][1:]):\n        p, q = coodinates[x], coodinates[y]\n        costs[i].append(costs[i][-1]+p.to(q))\n\nq = int(input())\nfor _ in range(q):\n    L, R = [int(x)-1 for x in input().split()]\n    print((costs[L % d][R//d]-costs[L % d][L//d]))\n", "# https://atcoder.jp/contests/abc089/tasks/abc089_d\n\ndef calc(x):\n    if x<D+1:\n        mv[x]=0\n        return 0\n    else:\n        p = d[x][0]\n        q = d[x][1]\n        r = d[x-D][0]\n        s = d[x-D][1]\n        tmp = abs(p-r)+abs(q-s)\n        ret= tmp+calc(x-D)\n        mv[x]=ret\n        return ret\n####################################################################\nimport sys \nsys.setrecursionlimit(10**5)\nH,W,D= map(int,input().split())\nA = [list(map(int,input().split())) for _ in range(H)]\nQ=int(input())\n\nd=dict()\nz=0\nfor a in A:\n    for b in a:\n        p = z//W\n        q = z%W\n        d[b]=(p,q)\n        z+=1\n        \nmv=[0]*(H*W+1)\nfor i in range(D):\n    calc(H*W-i)\n    #print(H*W-i,calc(H*W-i))    \n#print(mv)\n\nL=[0]*Q\nR=[0]*Q\nfor _ in range(Q):\n    L,R=map(int,input().split())\n    print(mv[R]-mv[L])", "h,w,d=map(int,input().split())\nl=[[] for t in range(h*w)]\nfor i in range(h):\n  ll=list(map(int,input().split()))\n  for j in range(w):\n    l[ll[j]-1]=[i,j]\n    \nr=[[0] for dd in range(d)]\nfor dd in range(d):\n  if dd==0:\n    k=d\n  else:\n    k=dd\n  while k+d<=h*w:\n    r[dd].append(r[dd][-1]+abs(l[k+d-1][0]-l[k-1][0])+abs(l[k+d-1][1]-l[k-1][1]))\n    k+=d\n\n    \nq=int(input())\nfor qq in range(q):\n  a,b=map(int,input().split())\n  if a%d==0:\n    p=d\n  else:\n    p=a%d\n  aa=(a-p)//d\n  bb=(b-p)//d\n  ans=r[a%d][bb]-r[a%d][aa]\n  print(ans)", "from collections import defaultdict\nimport itertools\nd = defaultdict(int)\nx='MARCH'\nfor i in range(5):\n  d[x[i]]=i+1\nx=[0]*5\ndef sub(a,b):\n  return abs(a[0]-b[0])+abs(a[1]-b[1])\n\nH,W,D=map(int,input().split())\nA=[list(map(int,input().split())) for i in range(H)]\nN=H*W\nP=[0]*(N)\nfor h in range(H):\n  for w in range(W):\n    P[A[h][w]-1]=(h,w)\nX=[]\nfor d in range(D):\n  _=[0]+[sub(P[i%N],P[i-D]) for i in range(d+D,N+D,D)]\n  cumsum = list(itertools.accumulate(_))\n  X.append(cumsum)\n\nQ=int(input())\nfor q in range(Q):\n  l,r=map(int,input().split())\n  l,r=l-1,r-1\n  g=l%D\n  if l>r:\n    r+=N\n    ans=X[g][-1]-X[g][l//D]\n    ans+=X[g][r//D]-X[g][0]\n  else:\n    ans=X[g][r//D]-X[g][l//D]\n  \n  print(ans)", "def main():\n    import sys\n    sys.setrecursionlimit(1000000)\n    h, w, d = list(map(int, input().split()))\n    p = []\n    for i in range(1, h + 1):\n        l = list(map(int, input().split()))\n        for j, k in enumerate(l, 1):\n            p.append((k, (i, j)))\n    p.sort(key=lambda x: x[0])\n\n    q = int(input())\n\n    dist = [0] * (w * h + 1)\n\n    def Q(i, c, x, y):\n        if i + d > w * h:\n            return\n        _, (nx, ny) = p[i + d - 1]\n        nc = c + abs(nx - x) + abs(ny - y)\n        dist[i + d] = nc\n        Q(i + d, nc, nx, ny)\n\n    for i in range(d):\n        n, (x, y) = p[i]\n        Q(n, 0, x, y)\n\n    res = []\n    for _ in range(q):\n        l, r = list(map(int, input().split()))\n        res.append(dist[r] - dist[l])\n\n    ans = '\\n'.join(map(str, res))\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]
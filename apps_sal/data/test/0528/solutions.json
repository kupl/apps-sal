["from collections import deque\n\n\ndef bfs(start):\n    res = []\n    queue = deque([start])\n    while queue:\n        vertex = queue.pop()\n        if not vis[vertex]:\n            vis[vertex] = 1\n            res.append(vertex)\n            for i in s[vertex]:\n                if not vis[i]:\n                    queue.append(i)\n    return res\n\nn, m = [int(i) for i in input().split()]\ns = [[] for i in range(n)]\nfor i in range(m):\n    a, b = [int(i) for i in input().split()]\n    s[a-1].append(b-1)\n    s[b-1].append(a-1)\nvis = [0 for i in range(n)]\nr = 0\nfor i in range(n):\n    if not vis[i]:\n        d = bfs(i)\n        for j in d:\n            if len(s[j]) != len(d)-1:\n                r = 1\n                print(\"NO\")\n                break\n    if r:\n        break\nelse:\n    print(\"YES\")", "import sys\n\ndef main():\n    n,m = map(int,sys.stdin.readline().split())\n\n    l = [[] for i in range(n+1)]\n    u = [False]*(n+1)\n\n    for i in range(m):\n        a, b = map(int,sys.stdin.readline().split())\n        l[a].append(b)\n        l[b].append(a)\n        \n    for i in range(n):\n        j = i+1\n        if u[j]:\n            continue\n        u[j] = True        \n        q = []\n        cl = len(l[j])\n        cn = 1\n        for a in l[j]:\n            q.append(a)\n\n        while len(q)!=0 :\n            cur = q.pop()\n            if u[cur]:\n                continue\n            u[cur] = True\n            cn+=1\n            cl+=len(l[cur])\n            for a in l[cur]:\n                if u[a]:\n                    continue\n                q.append(a)\n        if cl!=cn*(cn-1):\n            #print(j, cl, cn)\n            print(\"NO\")\n            return\n    print(\"YES\")\n\n\nmain()", "n, m = [int(x) for x in input().split()]\n\nl = [] \nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    if x>y: x,y = y,x\n    l.append((x, y))\nl.sort(key=lambda x: x[0])\n\nlabels = {}\nrels_count = {}\nclass_count = {}\nfor x, y in l:\n    if x not in labels:\n        labels[x] = len(rels_count)\n        rels_count[labels[x]] = 0\n        class_count[labels[x]] = 1\n    if y not in labels:\n        class_count[labels[x]] += 1\n    labels[y] = labels[x]\n    rels_count[labels[x]]+=1\n    \nflag = True\nfor i in range(len(rels_count)):\n    l_n = class_count[i]\n    l_m = rels_count[i]\n    if l_n*(l_n-1) != 2*l_m:\n        flag = False\n        break\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "import sys\nimport collections\n\n\ndef bfs(u, adjList, vis):\n    dq = collections.deque()\n\n    dq.append(u)\n    vis[u] = True\n    edgeCnt = 0\n    vertexCnt = 0\n\n    while dq:\n        u = dq.popleft()\n\n        vertexCnt += 1\n        edgeCnt += len(adjList[u])\n\n        for v in adjList[u]:\n            if not vis[v]:\n                vis[v] = True\n                dq.append(v)\n\n    edgeCnt = edgeCnt // 2\n    return bool(edgeCnt == ((vertexCnt * vertexCnt - vertexCnt) // 2))\n\n\ndef main():\n    # sys.stdin = open(\"in.txt\", \"r\")\n\n    it = iter(map(int, sys.stdin.read().split()))\n\n    n = next(it)\n    m = next(it)\n\n    adjList = [[] for _ in range(n+3)]\n\n    for _ in range(m):\n        u = next(it)\n        v = next(it)\n        adjList[u].append(v)\n        adjList[v].append(u)\n\n    vis = [False] * (n+3)\n\n    for u in range(1, n+1):\n        if not vis[u]:\n            if not bfs(u, adjList, vis):\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    sys.stdout.write(\"YES\\n\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# http://codeforces.com/contest/791/problem/B\n\nnax = 150123\n\nedges = [[] for _ in range(nax)]\nvis = [False for j in range(nax)]\n\n\ndef dfs(a, cnt_vertices, cnt_edges):\n    stack = [a]\n    while len(stack) > 0:\n        a = stack.pop()\n        if vis[a]:\n            continue\n        vis[a] = True\n        cnt_vertices[0] += 1\n        cnt_edges[0] += len(edges[a])\n        for b in edges[a]:\n            if not vis[b]:\n                stack.append(b)\n\n\ndef main():\n    n, m = list(map(int, str(input()).strip().split()))\n\n    for _ in range(m):\n        a, b = list(map(int, str(input()).strip().split()))\n        edges[a].append(b)\n        edges[b].append(a)\n\n    for i in range(1, n + 1):\n        if not vis[i]:\n            cnt_vertices = [0]\n            cnt_edges = [0]\n            dfs(i, cnt_vertices, cnt_edges)\n            if cnt_edges[0] != cnt_vertices[0] * (cnt_vertices[0] - 1):\n                print('NO')\n                return 0\n\n    print('YES')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\nn,m=[int(x)for x in input().split()]\nd={}\ncon=set()\nfor x in range(m):\n    a,b=input().split()\n    d.setdefault(a,{a}).add(b)\n    d.setdefault(b,{b}).add(a)\nres=None\nfor x,y in d.items():\n    if x not in con:\n        if all([d[u]==y for u in y]):\n            con.update(y)\n        else:\n            res='NO'\n            break\nif not res:\n    res='YES'\nprint(res)", "n,m=[int(x)for x in input().split()]\nd={}\ncon=set()\nfor x in range(m):\n    a,b=input().split()\n    d.setdefault(a,{a}).add(b)\n    d.setdefault(b,{b}).add(a)\nres=None\nfor x,y in d.items():\n    if x not in con:\n        if all([d[u]==y for u in y]):\n            con.update(y)\n        else:\n            res='NO'\n            break\nif not res:\n    res='YES'\nprint(res)", "def read():\n    n, m = list(map(int, input().rstrip().split()))\n    graph = [set() for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = list(map(int, input().rstrip().split()))\n        graph[a].add(b)\n        graph[b].add(a)\n        graph[a].add(a)\n        graph[b].add(b)\n    return (graph, n)\n\ndef main():\n    graph, n = read()\n    seen = set()\n    for i in range(1, n + 1):\n        if len(graph[i]) > 0 and i not in seen:\n            if not all(graph[i] == graph[j] for j in graph[i]):\n                return False\n            seen |= graph[i]\n    return True\n\ndef __starting_point():\n    if main():\n        print('YES')\n    else:\n        print('NO')\n\n__starting_point()", "def read():\n    n, m = list(map(int, input().rstrip().split()))\n    graph = [set() for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = list(map(int, input().rstrip().split()))\n        graph[a].add(b)\n        graph[b].add(a)\n        graph[a].add(a)\n        graph[b].add(b)\n    return (graph, n)\n\ndef main():\n    graph, n = read() \n    seen = set()\n    for i in range(1, n + 1):\n        if len(graph[i]) > 0 and i not in seen:\n            if not all(graph[i] == graph[j] for j in graph[i]):\n                return False\n            seen |= graph[i]\n    return True\n\ndef __starting_point():\n    if main():\n        print('YES')\n    else:\n        print('NO')\n\n__starting_point()", "n, m = [int(x) for x in input().split()]\nd = {}\nvisited = set()\nfor x in range(m):\n    a, b = input().split()\n    d.setdefault(a, {a}).add(b)\n    d.setdefault(b, {b}).add(a)\nres='YES'\nfor x, y in d.items():\n    if x not in visited:\n        if all([d[u]==y for u in y]):\n            visited.update(y)\n        else:\n            res='NO'\n            break\nprint(res)", "from sys import *\nf = lambda: map(int, stdin.readline().split())\nn, m = f()\ng = [[i] for i in range(n + 1)]\nfor j in range(m):\n    u, v = f()\n    g[u].append(v)\n    g[v].append(u)\nk = 'YES'\nfor t in g: t.sort()\nfor t in g:\n    s = len(t)\n    if s > 1 and not all(g[x] == t for x in t):\n        k = 'NO'\n        break\n    for j in t: g[j] = []\nprint(k)", "from sys import *\nf = lambda: map(int, stdin.readline().split())\nn, m = f()\ng = [[x] for x in range(n + 1)]\np = [0] * (n + 1)\nfor j in range(m):\n    u, v = f()\n    g[u].append(v)\n    g[v].append(u)\nk = 'YES'\nfor y, t in enumerate(g):\n    if not p[y]:\n        if any(len(g[x]) != len(t) or any(p[y] for y in g[x]) for x in t):\n            k = 'NO'\n            break\n        for x in t: p[x] = 1\nprint(k)", "from collections import Counter as cntr\nfrom math import inf\ndef cin():\n\treturn list(map(int, input().split(' ')))\ndef dfs(graph, src, n):\n\tq = [src]\n\th = 0\n\tnonlocal visited\n\tedges = 0\n\twhile q:\n\t\tidx = q.pop()\n\t\th += 1\n\n\t\tfor v in graph[idx]:\n\t\t\tedges += 1\n\t\t\tif visited[v] == False:\n\t\t\t\tvisited[v] = True\n\t\t\t\tq.append(v)\n\treturn h,edges\nn,m = cin()\ng = {i:[] for i in range(n)}\nfor i in range(m):\n\ta, b = cin()\n\ta -= 1\n\tb -= 1\n\tg[a].append(b)\n\tg[b].append(a)\nvisited = [False for i in range(n)]\nfor i in range(n):\n\tif visited[i] == False:\n\t\tvisited[i] = True\n\t\tv,e = dfs(g, i, n)\n\t\te = e//2\n\n\t\tif e != (v*(v-1))//2:\n\t\t\tprint('NO')\n\t\t\treturn\nprint('YES')\n\n\n", "n, m = [int(x) for x in input().split()]\nd = {}\nvisited = set()\nfor x in range(m):\n    a, b = input().split()\n    d.setdefault(a, {a}).add(b)\n    d.setdefault(b, {b}).add(a)\nfor x, y in d.items():\n       if x not in visited:\n              if all([d[u]==y for u in y]):\n                     visited.update(y)\n              else:\n                     print('NO');return\n                     break\nprint('YES')", "n,m=[int(x)for x in input().split()]\nd={}\ncon=set()\nfor x in range(m):\n    a,b=input().split()\n    d.setdefault(a,{a}).add(b)\n    d.setdefault(b,{b}).add(a)\nres=None\nfor x,y in list(d.items()):\n    if x not in con:\n        if all([d[u]==y for u in y]):\n            con.update(y)\n        else:\n            res='NO'\n            break\nif not res:\n    res='YES'\nprint(res)\n\n\n\n\n# Made By Mostafa_Khaled\n", "n,m=map(int,input().split())\nv=[0]*150005\ns=[set([i])for i in range(150005)]\nfor _ in ' '*m:\n    a,b=map(int,input().split())\n    s[a].add(b)\n    s[b].add(a)\nfor i in range(n):\n    if not v[i]:\n        for j in s[i]:\n            v[j]=1\n            if s[j]!=s[i]:print('NO');return\nprint('YES')", "n,m=map(int,input().split())\nv=[0]*150005\ns=[set([i])for i in range(150005)]\nfor _ in ' '*m:\n    a,b=map(int,input().split())\n    s[a].add(b)\n    s[b].add(a)\nfor i in range(n):\n    if not v[i]:\n        for j in s[i]:\n            v[j]=1\n            if s[j]!=s[i]:print('NO');return\nprint('YES')", "# -*- coding: utf-8 -*-\nn, m = map(int, input().split(' '))\nedges = [[] for i in range(n + 1)]\nvis = [False] * (n + 1)\n\ndef dfs(a):\n    nonlocal cnt_vertices\n    nonlocal cnt_edges\n    stack = [a]\n    while len(stack) > 0:\n        a = stack.pop()\n        if vis[a]:\n            continue\n        vis[a] = True\n        cnt_vertices += 1\n        cnt_edges += len(edges[a])\n        for b in edges[a]:\n            if not vis[b]:\n                stack.append(b)\n\nwhile m > 0:\n    a, b = map(int, input().split(' '))\n    edges[a].append(b)\n    edges[b].append(a)\n    m -= 1\nfor i in range(1, n+1):\n    if vis[i] == False:\n        cnt_vertices = 0\n        cnt_edges = 0\n        dfs(i)\n        if cnt_edges != cnt_vertices*(cnt_vertices-1):\n            print(\"NO\")\n            return\nprint(\"YES\")", "inp = lambda : list(map(int, input().split()))\nn, m = inp()\nlines = [set([i]) for i in range(n + 1)]\nfor i in range(m):\n    x, y = inp()\n    lines[x].add(y)\n    lines[y].add(x)\nf = [True] * (n + 1)\nfor i in range(n):\n    if f[i]:\n        f[i] = False\n        for j in lines[i]:\n            f[j] = False\n            if lines[i] != lines[j]:\n                print(\"NO\")\n                quit()\nprint(\"YES\")\n", "n, m = list(map(int, input().split()))\nd = {}\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    if a not in d:\n        d[a] = {b}\n    else:\n        d[a].add(b)\n    if b not in d:\n        d[b] = {a}\n    else:\n        d[b].add(a)\n\nnot_visited = set(range(2, n+1))\nvisited = set()\ncurrent = set()\nstack = [1]\nsucc = True\nwhile len(visited) < n:\n\n    if not stack:\n        t = not_visited.pop()\n        stack = [t]\n        current = set()\n\n    p = stack.pop()\n    visited.add(p)\n    if p in d:\n        for y in current:\n            if y not in d[p]:\n                succ = False\n                break\n        if not succ:\n            break\n        current.add(p)\n        for x in d[p]:\n            if x in not_visited:\n                stack.append(x)\n                not_visited.remove(x)\n\nif succ:\n    print('YES')\nelse:\n    print('NO')\n", "'''\nn,m = map(int,input().split())\neg,deg = [[] for _ in range(n+1)],[0 for _ in range(n+1)]\nf,rk = list(range(n+1)),[0 for _ in range(n+1)]\ndef fd(a):\n    if f[a]!=a :return fd(f[a]) \n    return f[a]\ndef un(a,b):\n    ra,rb = fd(a),fd(b)\n    if ra==rb:return \n    if rk[ra]>=rk[rb]:\n        f[rb] = ra\n        if rk[ra]==rk[rb]:rk[ra] +=1\n    else :f[ra] = rb\nfor i in range(1,n+1):\n    for j in eg[i]:\n        un(j,i)\nfor x,y in [map(int,input().split()) for _ in range(m)]:\n    un(x,y)\n    deg[x],deg[y] = deg[x]+1,deg[y]+1\ntable = [0 for _ in range(n+1)]\nfor i in range(1,n+1):\n    table[f[i]] += 1\nok = 1\nfor i in range(1,n+1):\n    if deg[i]!=table[f[i]]-1:\n        ok = 0\n        break\nprint(\"YES\") if ok else print(\"NO\")\n'''\nn, m = [int(x) for x in input().split()]\nd = {}\nvisited = set()\nfor x in range(m):\n    a, b = input().split()\n    d.setdefault(a, {a}).add(b)\n    d.setdefault(b, {b}).add(a)\nres='YES'\nfor x, y in d.items():\n    if x not in visited:\n        if all([d[u]==y for u in y]):\n            visited.update(y)\n        else:\n            res='NO'\n            break\nprint(res)", "from collections import defaultdict \nn,m=map(int,input().split())\nd=defaultdict(list)\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1 \n    b-=1\n    d[a].append(b)\n    d[b].append(a)\nvis=[0]*n \nfor i in range(n):\n    if vis[i]==0:\n        q=[i]\n        ce=0\n        cv=0 \n        vis[i]=1 \n        while q:\n            t=q.pop()\n            cv+=1 \n            ce+=len(d[t])\n            for i in d[t]:\n                if not vis[i]:\n                    vis[i]=1 \n                    q.append(i)\n    if ce!=cv*(cv-1):\n        print('NO')\n        return\nprint('YES')", "#   In this template you are not required to write code in main\n\nimport sys\ninf = float(\"inf\")\n\nsys.setrecursionlimit(1000000)\n#from cmath import sqrt\n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\n#from math import ceil,floor,log,sqrt,factorial,pow,pi,gcd\n#from bisect import bisect_left,bisect_right\n#import numpy as np\n\nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod,MOD=1000000007,998244353\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\n\ndef dfs(start):\n    stack=[start]\n    ct_vertex=1;ct_edges=0\n    while stack:\n        x=stack.pop()\n        visited[x]=True\n        for i in graph[x]:\n            ct_edges+=1\n            if not visited[i]:\n                visited[i]=True\n                ct_vertex+=1\n                stack.append(i)\n    # print(ct_vertex,ct_edges)\n    if ct_edges==(ct_vertex*(ct_vertex-1)):\n        return True\n    else:\n        return False\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef input(): return sys.stdin.readline().strip()\n\nn,m=get_ints()\ngraph={i:[] for i in range(1,n+1)}\nfor i in range(m):\n    x,y=get_ints()\n    graph[x].append(y)\n    graph[y].append(x)\n\nvisited=[False]*(n+1);flag=0\nfor i in range(1,n+1):\n    if not visited[i]:\n        if not dfs(i):\n            flag=1\n            break\nif flag==0:\n    print('YES')\nelse:\n    print(\"NO\")"]
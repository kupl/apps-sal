["import numpy as np\nh, w, m = map(int, input().split())\nxy = [tuple(map(lambda x: int(x) - 1, input().split())) for _ in range(m)]\nrow = np.zeros(h, np.int)\ncol = np.zeros(w, np.int)\nfor y, x in xy:\n\trow[y] += 1\n\tcol[x] += 1\n\nmax_cnt_y = max(row)\nmax_cnt_x = max(col)\nmax_pair = np.sum(row == max_cnt_y) * np.sum(col == max_cnt_x)\nfor y, x in xy:\n\tif row[y] == max_cnt_y and col[x] == max_cnt_x:\n\t\tmax_pair -= 1\n\nprint(max_cnt_y + max_cnt_x - (max_pair == 0))", "#!/usr/bin/env python3\nimport sys\nimport numpy as np\n\ninput = sys.stdin.readline\n\n\ndef S():\n    return input().rstrip()\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return list(map(int, input().split()))\n\n\nH, W, M = MI()\n\nR = np.zeros(H + 1)\nC = np.zeros(W + 1)\nbombs = []\nfor _ in range(M):\n    h, w = MI()\n    bombs.append((h, w))\n    R[h] += 1\n    C[w] += 1\n\nR_max = [R == max(R)]\nans = max(R) + max(C)\nC_max = [C == max(C)]\n\ncnt = 0\nfor h, w in bombs:\n    if R_max[0][h] and C_max[0][w]:\n        cnt += 1\n\nif cnt == np.count_nonzero(R_max) * np.count_nonzero(C_max):\n    print((int(ans - 1)))\nelse:\n    print((int(ans)))\n", "h,w,m=map(int,input().split())\nitem=[list(map(int,input().split())) for i in range(m)]\nrow=[0]*h\ncol=[0]*w\nfor i in range(m):\n    x,y=item[i]\n    row[x-1]+=1\n    col[y-1]+=1\nmr,mc=max(row),max(col)\nxr=set([i for i in range(h) if row[i]==mr])\nxc=set([i for i in range(w) if col[i]==mc])\ncheck=len(xr)*len(xc)\nfor i in range(m):\n    r,c=item[i]\n    if r-1 in xr and c-1 in xc:\n        check-=1\nprint(mr+mc if check>0 else mr+mc-1)", "H,W,M = map(int ,input().split())\nwidth = [0]*W\nheight = [0]*H\n\nst = set()\nfor i in range(M):\n  y,x = map(int, input().split())\n  st.add((x-1,y-1))\n  width[x-1] += 1\n  height[y-1] += 1\n\nmaxW = max(width)\nmaxH = max(height)\n\nindexW = [i for i, v in enumerate(width) if v == maxW]\nindexH = [i for i, v in enumerate(height) if v == maxH]\n\nans = maxW + maxH\n\ntempX = indexW[0]\ntempY = indexH[0]\n\nflag = False\n\nfor x in indexW:\n  y = tempY\n  if not (x,y) in st:\n    flag = True\n    break\n\nfor y in indexH:\n  x = tempX\n  if not(x,y) in st:\n    flag = True\n    break\n\nif flag:\n  print(ans)\nelse:\n  print(ans-1)", "\n\nH,W,M = map(int,input().split())\n\nHmax_temp = [0]*(H+1)\nWmax_temp = [0]*(W+1)\nHmax = 0\nWmax = 0\nBomb = dict()\nfor i in range(M):\n\tH_M,W_M = map(int,input().split())\n\tHmax_temp[H_M] += 1\n\tWmax_temp[W_M] += 1\n\tBomb[(H_M,W_M)] = 1\n\nHmax = max(Hmax_temp)\nWmax = max(Wmax_temp)\n\n#H\u65b9\u5411\u306e\u8d70\u67fb\ny_max = []\nfor i in range(H+1):\n\tif Hmax == Hmax_temp[i]:\n\t\ty_max.append(i)\n\t\t\n#W\u65b9\u5411\u306e\u8d70\u67fb\nx_max = []\nfor j in range(W+1):\n\tif Wmax == Wmax_temp[j]:\n\t\tx_max.append(j)\n\n#\u7206\u5f3e\u8a2d\u7f6e\u4f4d\u7f6e\u306b\u5bfe\u8c61\u304c\u5b58\u5728\u3059\u308b\u304b\uff1f\nflag = False\nfor i in y_max:\n\tfor  j in x_max:\n\t\tif (i,j) not in Bomb:\n\t\t\tflag = True\n\t\t\tbreak\n\tif flag:\n\t\tbreak\n\n#\u7b54\u3048\u306e\u30bb\u30c3\u30c8\nif flag:\n\tans = Wmax + Hmax\nelse:\n\tans = Wmax + Hmax - 1\nprint(ans)", "H,W,M = map(int, input().split())\nL = [[int(l) for l in input().split()] for _ in range(M)]\n\nhlist = [0]*(H+1)\nwlist = [0]*(W+1)\nfor l in L:\n    hlist[l[0]] += 1\n    wlist[l[1]] += 1\n\nhmax = max(hlist)\nwmax = max(wlist)\nh = hlist.count(hmax)\nw = wlist.count(wmax)\nans = hmax+wmax-1\ncnt = 0\nfor l in L:\n    if hlist[l[0]] == hmax and wlist[l[1]] == wmax:\n        cnt += 1\n\nif cnt < h*w:\n    ans += 1\nprint(ans)", "from collections import defaultdict\n\n\ndef main():\n    height, width, target_count = [int(x) for x in input().split()]\n    count_by_height = defaultdict(int)\n    count_by_width = defaultdict(int)\n    bomb_locations = set()\n    for _ in range(target_count):\n        h, w = [int(x) - 1 for x in input().split()]\n        count_by_height[h] += 1\n        count_by_width[w] += 1\n        bomb_locations.add((h, w))\n    max_h = max(v for v in list(count_by_height.values()))\n    max_w = max(v for v in list(count_by_width.values()))\n    max_h_rows = [i for i, x in list(count_by_height.items()) if x == max_h]\n    max_w_columns = [i for i, x in list(count_by_width.items()) if x == max_w]\n    all_crossing_bomb = all((h, w) in bomb_locations\n                            for h in max_h_rows for w in max_w_columns)\n    return max_h + max_w - all_crossing_bomb\n\n\ndef __starting_point():\n    print((main()))\n\n__starting_point()", "H,W,M = map(int,input().split())\n\nhs = [0] * H\nws = [0] * W\ns = set()\nfor i in range(M):\n  h,w = map(int, input().split())\n  hs[h-1] += 1\n  ws[w-1] += 1\n  s.add((h-1,w-1))\n  \nmh = 0\nmw = 0\nfor i in range(H):\n  mh = max(mh, hs[i])\nfor j in range(W):\n  mw = max(mw, ws[j])\n  \ni_s = list()\nj_s = list()\nfor i in range(H):\n  if mh == hs[i]:\n    i_s.append(i)\nfor j in range(W):\n  if mw == ws[j]:\n    j_s.append(j)\n\nans = mh + mw\nfor i in i_s:\n  for j in j_s:\n    if (i,j) in s:\n      continue\n    print(ans)\n    return\nans -= 1\nprint(ans)", "from collections import defaultdict\n\nH, W, M = list(map(int, input().split()))\n\nrow_bom_cnt = defaultdict(int)\ncol_bom_cnt = defaultdict(int)\nrow_max = 0\ncol_max = 0\n\nboms = [list(map(int, input().split())) for _ in range(M)]\n\nfor rm, cm in boms:\n    row_bom_cnt[rm] += 1\n    col_bom_cnt[cm] += 1\n\n    row_max = max(row_max, row_bom_cnt[rm])\n    col_max = max(col_max, col_bom_cnt[cm])\n\n\ntarget_row = set()\nfor r, val in list(row_bom_cnt.items()):\n    if val == row_max:\n        target_row.add(r)\n\ntarget_col = set()\nfor c, val in list(col_bom_cnt.items()):\n    if val == col_max:\n        target_col.add(c)\n\n\ncnt = 0\nfor rm, cm in boms:\n    if rm in target_row and cm in target_col:\n        cnt += 1\n\nif len(target_row) * len(target_col) == cnt:\n    print((row_max + col_max - 1))\nelse:\n    print((row_max + col_max))\n", "h, w, m = list(map(int, input().split()))\nyx = [tuple([int(x) - 1 for x in input().split()]) for _ in range(m)]\nch = [0] * h\ncw = [0] * w\n\nfor y, x in yx:\n    ch[y] += 1\n    cw[x] += 1\n\nax = max(cw)\nay = max(ch)\n\nnx = 0\nny = 0\nfor i in range(h):\n    ny += ch[i] == ay\nfor i in range(w):\n    nx += cw[i] == ax\ncan = ny * nx  # \u6700\u5927\u5024\u3092\u3068\u308b\u9078\u3073\u65b9\u306e\u6570\nfor y, x in yx:\n    if ch[y] == ay and cw[x] == ax:\n        can -= 1\nprint((ay + ax - (can == 0)))\n", "H, W, M = map(int,input().split())\nrow = [0]*H\ncol = [0]*W\ntarget = set()\nfor i in range(M):\n    h,w = map(int,input().split())\n    row[h-1] += 1\n    col[w-1] += 1\n    target.add((h-1,w-1))\nans = -1\nfor h,w in target:\n    ans = max(ans, row[h]+col[w]-1)\nA = max(row)\nB = max(col)\na = [x for x in range(H) if row[x] == A]\nb = [x for x in range(W) if col[x] == B]\ncnt = 0\nfor i in a:\n    for j in b:\n        cnt += 1\n        if (i,j) not in target:\n            print(A+B)\n            return\n        if cnt > M:\n            print(A+B-1)\n            return\nprint(A+B-1)", "from collections import defaultdict\ndef solve():\n  H, W, M = list(map(int, input().split()))\n  bomb = defaultdict(lambda: 0)\n  lis_h = [0]*H\n  lis_w = [0]*W\n  for _ in range(M):\n    h,w = list(map(int, input().split()))\n    h -= 1\n    w -= 1\n    bomb[(h,w)] = 1\n    lis_h[h] += 1\n    lis_w[w] += 1\n  m_h = max(lis_h)\n  m_w = max(lis_w)\n  m_h_lis = []\n  m_w_lis = []\n  for i in range(H):\n    if lis_h[i]==m_h:\n      m_h_lis.append(i)\n  for i in range(W):\n    if lis_w[i]==m_w:\n      m_w_lis.append(i)\n  ans = 0\n  for h in m_h_lis:\n    for w in m_w_lis:\n      if bomb[(h,w)]==0:\n        return m_h+m_w\n  return m_h+m_w-1\nprint((solve()))\n", "h,w,m = map(int,input().split())\nt = [tuple(map(lambda x:int(x)-1,input().split())) for _ in range(m)] \nht = [0]*h\nwt = [0]*w\nfor y,x in t:\n  ht[y] += 1\n  wt[x] += 1\nhtm = max(ht)\nwtm = max(wt)\nhtt = [i for i in range(h) if ht[i]==htm]\nwtt = [i for i in range(w) if wt[i]==wtm]\nans = htm+wtm-1\nt = set(t)\nfor i in htt:\n  for j in wtt:\n    if (i,j) not in t:\n      print(htm+wtm)\n      return\nprint(htm+wtm-1)", "import sys\ninput = sys.stdin.readline\nh,w,m = map(int,input().rstrip().split())\nhw = [list(map(int,input().rstrip().split()))for _ in range(m)]\n\ntate = [0]*(h+1)\nyoko = [0]*(w+1)\nbombpoint = set()\n\nfor x,y in hw:\n    tate[x] += 1\n    yoko[y] += 1\n    bombpoint.add((x,y))\n\nans_x = []\nans_y = []\nx_max = max(tate)\ny_max = max(yoko)\nfor i in range(len(tate)):\n    if tate[i] == x_max:\n        ans_x.append(i)\nfor i in range(len(yoko)):\n    if yoko[i] == y_max:\n        ans_y.append(i)\n\nans = x_max + y_max\nfor x in ans_x:\n    for y in ans_y:\n        if (x,y) not in bombpoint:\n            print(ans)\n            return\nprint(ans - 1)", "import sys\nimport numpy as np\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\ndef MIIZ(): return list(map(lambda x: x-1, MII()))\n#======================================================#\ndef main():\n    h, w, m = MII()\n    bombs = [MIIZ() for _ in range(m)]\n    a = [0]*h\n    b = [0]*w\n    for y,x in bombs:\n        a[y] += 1\n        b[x] += 1\n    maxa = max(a)\n    maxb = max(b)\n    sumv = maxa + maxb\n    c = a.count(maxa)*b.count(maxb) - sum(a[y]+b[x] == sumv for y,x in bombs)\n    print(sumv - (c<=0))\n\ndef __starting_point():\n    main()\n__starting_point()", "h, w, m = list(map(int, input().split()))\na_list = []\nb_list = []\nh_list = [0 for _ in range(h)]\nw_list = [0 for _ in range(w)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a_list.append([a,b])\n    h_list[a - 1] += 1\n    w_list[b - 1] += 1\nh_max = max(h_list)\nw_max = max(w_list)\nw_flag = [0 for _ in range(w)]\nfor i in range(w):\n    if w_list[i] == w_max:\n        w_flag[i] = 1\nh_flag = [0 for _ in range(h)]\nfor i in range(h):\n    if h_list[i] == h_max:\n        h_flag[i] = 1\nflag = 0   \nfor i in range(m):\n    if h_flag[a_list[i][0] - 1] == 1 and w_flag[a_list[i][1] - 1] == 1:\n        flag += 1\ns = sum(h_flag) * sum(w_flag)\nprint((h_max + w_max - 1 if flag == s else h_max + w_max))        \n", "h,w,m = map(int,input().split())\nrow = [0]*(h+1)\ncol = [0]*(w+1)\nbombs = set([])\nfor i in range(m):\n  a,b = map(int,input().split())\n  row[a] += 1\n  col[b] += 1\n  bombs.add((a,b))\nr,c = max(row),max(col)\nrcnt,ccnt = 0,0\nfor v in row:\n  if v==r:\n    rcnt += 1\nfor v in col:\n  if v==c:\n    ccnt += 1\ndoubled = 0\nfor i,j in bombs:\n  if row[i]==r and col[j]==c:\n    doubled += 1\nif doubled==rcnt*ccnt:\n  print(r+c-1)\nelse:\n  print(r+c)", "import collections\n\nh,w,m = map(int,input().split())\nX = []\nY = []\nfor _ in range(m):\n    x,y = map(int,input().split())\n    X.append(x)\n    Y.append(y)\n\nmost_common_x = collections.Counter(X).most_common()\nmost_common_x_index = most_common_x[0][0]\nmost_common_x_count = most_common_x[0][1]\nmost_common_y = collections.Counter(Y).most_common()\nmost_common_y_index = most_common_y[0][0]\nmost_common_y_count = most_common_y[0][1]\n\notherwisey = []\notherwisex = []\nfor i in range(m):\n    if X[i] != most_common_x_index:\n        otherwisey.append(Y[i])\n    if Y[i] != most_common_y_index:\n        otherwisex.append(X[i])\n\nmost_common_y = collections.Counter(otherwisey).most_common()\nif len(most_common_y)!= 0:\n    ansx = most_common_y[0][1] + most_common_x_count\nelse:\n    ansx = most_common_x_count\n\nmost_common_x = collections.Counter(otherwisex).most_common()\nif len(most_common_x)!= 0 :\n    ansy = most_common_x[0][1] + most_common_y_count\nelse:\n    ansy = most_common_y_count\n\nprint(max(ansx,ansy))", "import sys\nsys.setrecursionlimit(10**6)\n\nh, w, m = list(map(int, input().split()))\n\n# \u5404\u884c\u5404\u5217\u306b\u4f55\u500b\u305a\u3064\u3042\u308b\u304b\nhs = [0] * h\nws = [0] * w\n# \u5ea7\u6a19\u3092\u8a18\u9332\ns = set()\n\nreadline = sys.stdin.readline\nfor _ in range(m):\n    r, c = [int(i) for i in readline().split()]\n    r -= 1\n    c -= 1\n    hs[r] += 1\n    ws[c] += 1\n    s.add((r, c))\n\n# \u6700\u5927\u5024\nmh = 0\nmw = 0\nfor i in range(h):\n    mh = max(mh, hs[i])\nfor j in range(w):\n    mw = max(mw, ws[j])\n\n# \u6700\u5927\u5024\u3092\u3068\u3063\u3066\u3044\u308b\u884c\u30fb\u5217\nsi = []\nsj = []\nfor i in range(h):\n    if mh == hs[i]:\n        si.append(i)\nfor j in range(w):\n    if mw == ws[j]:\n        sj.append(j)\n\n# \u7206\u7834\u5bfe\u8c61\u304c\u306a\u3044\u30de\u30b9\u306b\u7206\u5f3e\u3092\u8a2d\u7f6e\u3067\u304d\u308c\u3070\u5c1a\u826f\u3057\u3002\u305d\u3053\u3067mh+mw\u3092ans\u306b\u4eee\u306b\u8a18\u9332\u3057\u3066\u3001\uff11\u500b\u3067\u3082\u898b\u3064\u304b\u308c\u3070\u305d\u306e\u5ea7\u6a19\u3092\u51fa\u529b\u3002\u898b\u3064\u304b\u3089\u306a\u3051\u308c\u3070\u3001\u7206\u7834\u5bfe\u8c61\u304c\u3042\u308b\u30de\u30b9\u306b\u7206\u5f3e\u3092\u8a2d\u7f6e\u3059\u308b\u306e\u304c\u6700\u5927\u3068\u306a\u308b\u306e\u3067\u3001ans=mh+mw-1\u3068\u306a\u308b\nans = mh + mw\nfor i in si:\n    for j in sj:\n        if (i, j) in s:\n            continue\n        print(ans)\n        return\nprint((ans-1))\n", "from collections import defaultdict\nfrom operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\nh, w, m = list(map(int, input().split()))\nbombs = [tuple(map(int, input().split())) for _ in range(m)]\n\nx_cnt = defaultdict(int)\ny_cnt = defaultdict(int)\nfor x, y in bombs:\n    x_cnt[x] += 1\n    y_cnt[y] += 1\n\nx_cnt_max = max(x_cnt.values())\ny_cnt_max = max(y_cnt.values())\ncnt = cnt_x = cnt_y = 0\nfor x, y in bombs:\n    if x_cnt[x] == x_cnt_max and y_cnt[y] == y_cnt_max:\n        cnt += 1\n\ncnt_x = sum(v == x_cnt_max for v in list(x_cnt.values()))\ncnt_y = sum(v == y_cnt_max for v in list(y_cnt.values()))\nif cnt_x * cnt_y == cnt:\n    ans = x_cnt_max + y_cnt_max - 1\nelse:\n    ans = x_cnt_max + y_cnt_max\n\n# print(cnt_x, cnt_y, cnt)\nprint(ans)\n", "h,w,m=map(int,input().split())\n\nst=set()\nh_b=[0 for i in range(h)]\nw_b=[0 for i in range(w)]\nfor i in range(m):\n  th,tw=map(int,input().split())\n  th-=1\n  tw-=1\n  st.add((th,tw))\n  h_b[th]+=1\n  w_b[tw]+=1\n\nh_max=max(h_b)\nw_max=max(w_b)\n\nh_cand=[i for i in range(h) if h_b[i]==h_max]\nw_cand=[i for i in range(w) if w_b[i]==w_max]\n\nfor i in h_cand:\n  for j in w_cand:\n    if (i,j) not in st:\n      print(h_max+w_max)\n      return\n\nprint(h_max+w_max-1)", "#https://atcoder.jp/contests/abc176/submissions/16118386\nimport collections\nimport sys\nimport math\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\ndef NIJIGEN(H): return [list(input()) for i in range(H)]\nH,W,M=map(int,input().split())\nA=list()\nB=list()\nfor i in range(M):\n  a,b=map(int,input().split())\n  A.append(a)\n  B.append(b)\nc = collections.Counter(A)\ns=c.most_common()\nk=s[0][0]\nt=s[0][1]\nL=list()\nfor i in range(M):\n  if A[i]!=k:\n    L.append(B[i])\nc = collections.Counter(L)\ns=c.most_common()\nif len(s)!=0:\n  ans=s[0][1]+t\nelse:\n  ans=t\nc = collections.Counter(B)\ns=c.most_common()\nk=s[0][0]\nt=s[0][1]\nL=list()\nfor i in range(M):\n  if B[i]!=k:\n    L.append(A[i])\nc = collections.Counter(L)\ns=c.most_common()\nif len(s)!=0:\n  q=s[0][1]+t\nelse:\n  q=t\nans=max(ans,q)\nprint(ans)", "h, w, m = list(map(int, input().split()))\nr = [0] * (h+1)\nc = [0] * (w+1)\nbomb = []\nfor _ in range(m):\n    hi, wi = list(map(int, input().split()))\n    r[hi] += 1\n    c[wi] += 1\n    bomb.append([hi, wi])\n\nhmax = max(r)\nwmax = max(c)\n\ncnt = 0\nret = 1\nfor i in range(1, h+1):\n    if r[i] == hmax:\n        cnt += 1\nret *= cnt\n\ncnt = 0\nfor i in range(1, w+1):\n    if c[i] == wmax:\n        cnt += 1\n\nret *= cnt\n\nfor i in range(m):\n    hi, wi = bomb[i]\n    if r[hi] == hmax and c[wi] == wmax:\n        ret -= 1\n\nif ret == 0:\n    print((hmax + wmax - 1))\nelse:\n    print((hmax + wmax))\n", "h, w, m = list(map(int, input().split()))\nms = []\nhs = [0 for i in range(h)]\nws = [0 for i in range(w)]\n\nfor i in range(m):\n    hi, wi = list(map(int, input().split()))\n    ms.append((hi - 1, wi - 1))\n    hs[hi - 1] += 1\n    ws[wi - 1] += 1\n\nmaxh = max(hs)\nmaxw = max(ws)\ncnt_h = sum([hs[i] == maxh for i in range(h)])\ncnt_w = sum([ws[i] == maxw for i in range(w)])\ncnt = cnt_h * cnt_w\n\nfor x, y in ms:\n    if hs[x] == maxh and ws[y] == maxw:\n        cnt -= 1\n\nif cnt <= 0:\n    print(maxh + maxw - 1)\nelse:\n    print(maxh + maxw)", "H,W,M=list(map(int,input().split()))\nrow=[0]*H\ncol=[0]*W\ntarget=set()\nfor i in range(M):\n    h,w=list(map(int,input().split()))\n    row[h-1]+=1\n    col[w-1]+=1\n    target.add((h-1,w-1))\nA=max(row)\nB=max(col)\na=[x for x in range(H) if row[x]==A]\nb=[x for x in range(W) if col[x]==B]\nfor i in a:\n    for j in b:\n        if (i,j) not in target:\n            print((A+B))\n            return\nprint((A+B-1))\n", "def main():\n    h,w,m=map(int,input().split())\n    row=[0]*(h+1)\n    col=[0]*(w+1)\n    d=set({})\n    for _ in range(m):\n        a,b=map(int,input().split())\n        row[a]+=1\n        col[b]+=1\n        d.add((a,b))\n\n    max_row=max(row)\n    max_col=max(col)\n    max_row_d=set({})\n    max_col_d=set({})\n    for i in range(1,h+1):\n        if row[i]==max_row:\n            max_row_d.add(i)\n    for i in range(1,w+1):\n        if col[i]==max_col:\n            max_col_d.add(i)\n\n    sm=max_row+max_col\n    for i in max_row_d:\n        for j in max_col_d:\n            if (i,j) in d : continue\n            break\n        else : continue\n        break\n    else : sm-=1\n\n    print(sm)    \n\nmain()", "from collections import Counter\n\n\nH, W, M, *hw = map(int, open(0).read().split())\nh_cnt = Counter(hw[::2])\nw_cnt = Counter(hw[1::2])\nh_max = h_cnt.most_common(1)[0][1]\nw_max = w_cnt.most_common(1)[0][1]\n\nnot_on_bomb = sum(1 for k, v in h_cnt.items() if v == h_max)\nnot_on_bomb *= sum(1 for k, v in w_cnt.items() if v == w_max)\nfor h, w in zip(*[iter(hw)] * 2):\n    if h_cnt[h] == h_max and w_cnt[w] == w_max:\n        not_on_bomb -= 1\n\nans = h_max + w_max\nprint(ans) if not_on_bomb else print(ans - 1)\n", "from collections import defaultdict\n\nH, W, M = list(map(int, input().split()))\nhw = [list(map(int, input().split())) for _ in range(M)]\n\nd1 = defaultdict(int)\nd2 = defaultdict(int)\n\nb = defaultdict(int)\n\nfor h, w in hw:\n    d1[h] += 1\n    d2[w] += 1\n    b[(h, w)] = 1\n\nm1 = max(d1.values())\nm2 = max(d2.values())\n\ne1 = [k for k in d1.keys() if d1[k] == m1]\ne2 = [k for k in d2.keys() if d2[k] == m2]\n\nflag = True\n\nfor x in e1:\n    for y in e2:\n        if b[(x, y)] == 1:\n            pass\n        else:\n            flag = False\n            break\n    if not flag:\n        break\n\nif flag:\n    print(m1+m2-1)\nelse:\n    print(m1+m2)", "H,W,M=map(int,input().split())\nl = [ list(map(int,input().split(\" \"))) for i in range(M)]\nh=[0]*H\nw=[0]*W\nfor i in range(M):\n    h[l[i][0]-1]+=1\n    w[l[i][1]-1]+=1\nmaxh=max(h)\nmaxw=max(w)\nhlist=[]\nwlist=[]\nfor i in range(H):\n    if h[i]==maxh:\n        hlist.append(i)\nfor i in range(W):\n    if w[i]==maxw:\n        wlist.append(i)\nc=0\nfor i in range(M):\n  if h[l[i][0]-1]==maxh and w[l[i][1]-1]==maxw:\n    c+=1\nif len(hlist)*len(wlist)==c:\n  print(maxh+maxw-1)\nelse:\n  print(maxh+maxw)", "H, W, M = map(int, input().split())\n \nhs = [0] * H\nws = [0] * W\nboms = set()\n \nfor i in range(M):\n    r,c = map(int, input().split())\n    r -= 1\n    c -= 1\n \n    hs[r] += 1\n    ws[c] += 1\n    boms.add((r, c))\nmh, mw = 0, 0\nfor i in range(H):\n    mh = max(mh, hs[i])\nfor j in range(W):\n    mw = max(mw, ws[j])\nmax_h_list = []\nmax_w_list = []\n    \nfor i in range(H):\n    if hs[i] == mh: max_h_list.append(i)    \nfor j in range(W):\n    if ws[j] == mw: max_w_list.append(j)\nans = mh + mw\n \nfor i in max_h_list:\n    for j in max_w_list:\n        if (i,j) not in boms:\n            print(ans)\n            return\nprint(ans-1) ", "import numpy as np\n\ndef solve(H, W, M, h, w):\n    f = [0] * (H+1)\n    g = [0] * (W+1)\n    for r, c in zip(h, w):\n        f[r] += 1\n        g[c] += 1\n    p = np.max(f)\n    q = np.max(g)\n    num = len(list(filter(p.__eq__, f))) * len(list(filter(q.__eq__, g)))\n    for r, c in zip(h, w):\n        if (f[r] == p) and (g[c] == q):\n            num -= 1\n    return p + q - (num <= 0)\n\nH, W, M = map(int, input().split())\nh, w = zip(*[map(int, input().split()) for i in range(M)])\nprint(solve(H, W, M, h, w))", "import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom bisect import bisect_left,bisect\ndef main():\n    h, w, m = map(int,input().split()) \n    h_lis = [0] * (h+1)\n    w_lis = [0] * (w+1)\n    bombs = set([tuple(map(int,input().split())) for i in range(m)])\n    for hh, ww in bombs:\n        h_lis[hh] += 1\n        w_lis[ww] += 1\n    max_h = max(h_lis)\n    max_w = max(w_lis)\n    h_max_index = [i for i, h in enumerate(h_lis) if h == max_h]\n    w_max_index = [i for i, w in enumerate(w_lis) if w == max_w]\n    for h_i in h_max_index:\n        for w_i in w_max_index:\n            if not (h_i, w_i) in bombs:\n                print(h_lis[h_i] + w_lis[w_i])\n                return\n    else:\n        print(h_lis[h_i] + w_lis[w_i] - 1)\n\ndef __starting_point():\n    main()\n__starting_point()", "H,W,M = map(int, input().split())\n\nhs = [0] * H\nws = [0] * W\ns = set()\n\nfor i in range(M):\n  h,w = map(int, input().split())\n  h -= 1\n  w -= 1\n  hs[h] += 1\n  ws[w] += 1\n  s.add((h,w))\n\nmh = 0\nmw = 0\nfor i in range(H):\n  mh = max(mh, hs[i])\nfor j in range(W):\n  mw = max(mw, ws[j])\n  \nl_s = list()\nj_s = list()\nfor i in range(H):\n  if mh == hs[i]:\n    l_s.append(i)\nfor j in range(W):\n  if mw == ws[j]:\n    j_s.append(j)\n    \nans = mh+mw\nfor i in l_s:\n  for j in j_s:\n    if (i,j) in s:\n      continue\n    print(ans)\n    return\nans -= 1\nprint(ans)", "h,w,n=map(int,input().split())\nH=[0]*h\nW=[0]*w\nL=[(0,0)]*n\nfor i in range(n):\n    a,b=map(int,input().split())\n    L[i]=(a,b)\n    H[a-1]+=1\n    W[b-1]+=1\nh_max=max(H)\nw_max=max(W)\nans=h_max+w_max\ncnt=0\nfor l in L:\n    if H[l[0]-1]==h_max and W[l[1]-1]==w_max:\n        cnt+=1\nif H.count(h_max)*W.count(w_max)==cnt:\n    ans-=1\nprint(ans)", "import numpy as np\nfrom collections import defaultdict\n\nh, w, m = map(int, input().split())\n\nrowsum = np.zeros(h, dtype=int)\ncolsum = np.zeros(w, dtype=int)\ntargets = defaultdict(int)\nfor _ in range(m):\n    hi, wi = map(int, input().split())\n    hi -= 1\n    wi -= 1\n    rowsum[hi] += 1\n    colsum[wi] += 1\n    targets[(hi, wi)] = 1\n\nrowmax = np.max(rowsum)\ncolmax = np.max(colsum)\nrowindices = np.where(rowsum == rowmax)[0]\ncolindices = np.where(colsum == colmax)[0]\n\nfor ri in rowindices:\n    for ci in colindices:\n        if targets[(ri, ci)]:\n            continue\n        print(rowmax + colmax)\n        return\n\nprint(rowmax + colmax - 1)", "\nimport sys\nfrom collections import Counter\n\nH, W, M = map(int, sys.stdin.readline().rstrip().split())#\u884c\u6570H\u3001\u5217\u6570W\u3001\u7206\u5f3e\u6570M\nhcnt = [0] * H#\u4f55\u884c\u76ee\u306b\u4f55\u500b\u3042\u308b\u304b\nwcnt = [0] * W#\u4f55\u5217\u76ee\u306b\u4f55\u500b\u3042\u308b\u304b\nbomb = []\n\nfor i in range(M):\n    bh,bw=map(int,sys.stdin.readline().rstrip().split())\n    hcnt[bh - 1] += 1#\u884c\u65b9\u5411\n    wcnt[bw - 1] += 1#\u5217\u65b9\u5411\n    bomb.append((bh - 1,bw - 1))\n#hcnt [2,1]\n#wcnt[1,1,1]\n#bomb[[1,1],[0,0],[0,2]]\nhmax = max(hcnt)#2\nwmax = max(wcnt)#1\n\ncrs = 0#hmax and wmax crosspoint\nfor (i, j) in bomb:\n    if hcnt[i] == hmax and wcnt[j] == wmax:\n        crs += 1\n#all crosspoint has bomb\nif crs == Counter(hcnt)[hmax] * Counter(wcnt)[wmax]:\n    print(hmax + wmax - 1)\n#more than one crosspoint has no bomb\nelse:\n    print(hmax + wmax)", "import itertools\nH,W,N=[int(s) for s in input().split()]\nhls=[0 for _ in range(H+1)]\nwls=[0 for _ in range(W+1)]\nbombs=[set() for _ in range(H+1)]\nfor _ in range(N):\n  h,w=[int(s) for s in input().split()]\n  hls[h]+=1\n  wls[w]+=1\n  bombs[h].add(w)\nhmax=max(hls)\nwmax=max(wls)\nhmaxls=[i for i in range(H+1) if hls[i]==hmax]\nwmaxls=[i for i in range(W+1) if wls[i]==wmax]\nfor h,w in itertools.product(hmaxls,wmaxls):\n  if not(w in bombs[h]):\n    print(hmax+wmax)\n    return\nelse:\n  print(hmax+wmax-1)", "from collections import Counter\n\nH, W, M = list(map(int, input().split()))\ndh, dw = Counter(), Counter()\nused = set()\n\nfor _ in range(M):\n    h, w = list(map(int, input().split()))\n    dh[h] += 1\n    dw[w] += 1\n    used.add((h, w))\n\nih = dh.most_common()\niw = dw.most_common()\ns = ih[0][1] + iw[0][1]\nans = 0\n\nfor h, sh in ih:\n    for w, sw in iw:\n        if sh+sw < s or ans == s:\n            break\n        b = sh + sw - ((h, w) in used)\n        ans = max(ans, b)\nprint(ans)\n", "import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    H, W, M = list(map(int, input().split()))\n    bomb = [list([int(x) - 1 for x in input().split()]) for _ in range(M)]\n    R = [0] * H\n    C = [0] * W\n\n    for h, w in bomb:\n        R[h] += 1\n        C[w] += 1\n\n    cnt_r = 0\n    ma_r = max(R)\n    for r in R:\n        if r == ma_r:\n            cnt_r += 1\n\n    cnt_c = 0\n    ma_c = max(C)\n    for c in C:\n        if c == ma_c:\n            cnt_c += 1\n\n    ma = ma_r + ma_c\n    cnt_rc = cnt_r * cnt_c\n    for h, w in bomb:\n        score = R[h] + C[w]\n        if score == ma:\n            cnt_rc -= 1\n\n    res = ma if cnt_rc else ma - 1\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\n\n\nH, W, M = map(int, input().split())\nbomb =[]\nfor I in range(M):\n    bom = tuple(map(lambda x: int(x) - 1, input().split()))\n    bomb.append(bom)\nX = [0] * H  # X:\u5404\u884c\u306e\u7206\u7834\u5bfe\u8c61\u306e\u500b\u6570\nY = [0] * W  # Y:\u5404\u5217\u306e\u7206\u7834\u5bfe\u8c61\u306e\u500b\u6570\nfor h, w in bomb:\n    X[h] += 1\n    Y[w] += 1\nmaxX = max(X)\nmaxY = max(Y)\n\nR = [h for h, x in enumerate(X) if x == maxX]  # R:\u7206\u7834\u5bfe\u8c61\u306e\u6570\u304c\u6700\u5927\u3068\u306a\u308b\u884c\u306e\u756a\u53f7\nC = [w for w, y in enumerate(Y) if y == maxY]  # C:\u7206\u7834\u5bfe\u8c61\u306e\u6570\u304c\u6700\u5927\u3068\u306a\u308b\u5217\u306e\u756a\u53f7\n\nbomb = set(bomb)\nfor r in R:\n    for c in C:\n        if (r, c) not in bomb:\n            # (r, c)\u306b\u7206\u7834\u5bfe\u8c61\u304c\u5b58\u5728\u3057\u306a\u3044\u3068\u304d, maxX + maxY \u304c\u7b54\u3048\u3068\u306a\u308b\u3053\u3068\u304c\u78ba\u5b9a\u3059\u308b\u305f\u3081, \n            # \u5373\u5ea7\u306b\u63a2\u7d22\u3092\u7d42\u4e86\u3059\u308b. \u3053\u308c\u306b\u3088\u308a\u30eb\u30fc\u30d7\u306e\u56de\u6570\u306f\u6700\u5927\u3067\u3082M+1\u56de\u3068\u306a\u308b.\n            print(maxX + maxY)\n            return\nprint(maxX + maxY - 1)", "H,W,M=map(int,input().split())\nh=[0]*(H+1)\nw=[0]*(W+1)\nhw=[0]*M\nfor i in range(M):\n  y,x=map(int,input().split())\n  hw[i]=(y,x)\n  h[y]+=1\n  w[x]+=1\ncnt=0\nmxh=max(h)\nmxw=max(w)\nfor hi,wi in hw:\n  if h[hi]==mxh and w[wi]==mxw:\n    cnt+=1\nif h.count(mxh)*w.count(mxw)==cnt:\n  print(mxh+mxw-1)\nelse:\n  print(mxh+mxw)", "from collections import Counter\nh, w, m = list(map(int, input().split()))\nblist = [list(map(int, input().split())) for _ in range(m)]\n\nblist_set = set(map(tuple, blist))\n\nrowdict = Counter([blist[i][0] for i in range(m)])\ncoldict = Counter([blist[i][1] for i in range(m)])\n\nmaxr = rowdict.most_common()[0][1]\nmaxr_keys = []\nfor i in rowdict.most_common():\n    if i[1] == maxr:\n        maxr_keys.append(i[0])\n    else:\n        break\nmaxc = coldict.most_common()[0][1]\nmaxc_keys = []\nfor i in coldict.most_common():\n    if i[1] == maxc:\n        maxc_keys.append(i[0])\n    else:\n        break\n\nfor i in maxr_keys:\n    for j in maxc_keys:\n        if (i, j) not in blist_set:\n            print((maxr + maxc))\n            break\n    else:\n        continue\n    break\nelse:\n    print((maxr + maxc - 1))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter, defaultdict\n\n\ndef read():\n    H, W, M = list(map(int, input().strip().split()))\n    HW = []\n    for i in range(M):\n        h, w = list(map(int, input().strip().split()))\n        HW.append((h, w))\n    return H, W, M, HW\n\n\ndef solve(H, W, M, HW):\n    hcount = Counter()\n    wcount = Counter()\n    for h, w in HW:\n        hcount[h] += 1\n        wcount[w] += 1\n    hm = hcount.most_common()\n    wm = wcount.most_common()\n    hmax = hm[0][1]\n    wmax = wm[0][1]\n    hn = len([1 for k, v in list(hcount.items()) if v == hmax])\n    wn = len([1 for k, v in list(wcount.items()) if v == wmax])\n    m = hn * wn\n    for h, w in HW:\n        if hcount[h] == hmax and wcount[w] == wmax:\n            m -= 1\n    if m == 0:\n        return hmax + wmax - 1\n    return hmax + wmax\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "H,W,M = map(int, input().split())\n\nhs = [0] * H\nws = [0] * W\ns = set()\n\nfor i in range(M):\n  h,w = map(int, input().split())\n  h -= 1\n  w -= 1\n  hs[h] += 1\n  ws[w] += 1\n  s.add((h,w))\n\nmh = 0\nmw = 0\nfor i in range(H):\n  mh = max(mh,hs[i])\nfor j in range(W):\n  mw = max(mw,ws[j])\ni_s = list()\nj_s = list()\nfor i in range(H):\n  if mh == hs[i]:\n    i_s.append(i)\nfor j in range(W):\n  if mw == ws[j]:\n    j_s.append(j)\nans = mh + mw\nfor i in i_s:\n  for j in j_s:\n    if (i,j) in s:\n      continue\n    print(ans)\n    return\nans -= 1\nprint(ans)", "\nH, W, M = list(map(int, input().split()))\n\nh = [0] * H\nw = [0] * W\n\nhw = {}\n\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    h[a - 1] += 1\n    w[b - 1] += 1\n    temp = \"x\" + str(a - 1) + \"y\" + str(b - 1)\n    hw[temp] = 1\n\nhm = max(h)\nwm = max(w)\n\nhp = [i for i, v in enumerate(h) if v == hm]\nwp = [i for i, v in enumerate(w) if v == wm]\n\nfor x in hp:\n    for y in wp:\n        temp = \"x\" + str(x) + \"y\" + str(y)\n        if temp not in hw:\n            print((hm + wm))\n            return\nelse:\n    print((hm + wm - 1))\n\n", "import sys\n\n\nH, W, M = map(int, input().split())\nbomb = [tuple(map(lambda x: int(x) - 1, s.split())) for s in sys.stdin.readlines()]\nX = [0] * H  # X:\u5404\u884c\u306e\u7206\u7834\u5bfe\u8c61\u306e\u500b\u6570\nY = [0] * W  # Y:\u5404\u5217\u306e\u7206\u7834\u5bfe\u8c61\u306e\u500b\u6570\nfor h, w in bomb:\n    X[h] += 1\n    Y[w] += 1\nmaxX = max(X)\nmaxY = max(Y)\n\nR = [h for h, x in enumerate(X) if x == maxX]  # R:\u7206\u7834\u5bfe\u8c61\u306e\u6570\u304c\u6700\u5927\u3068\u306a\u308b\u884c\u306e\u756a\u53f7\nC = [w for w, y in enumerate(Y) if y == maxY]  # C:\u7206\u7834\u5bfe\u8c61\u306e\u6570\u304c\u6700\u5927\u3068\u306a\u308b\u5217\u306e\u756a\u53f7\n\nbomb = set(bomb)\nfor r in R:\n    for c in C:\n        if (r, c) not in bomb:\n            # (r, c)\u306b\u7206\u7834\u5bfe\u8c61\u304c\u5b58\u5728\u3057\u306a\u3044\u3068\u304d, maxX + maxY \u304c\u7b54\u3048\u3068\u306a\u308b\u3053\u3068\u304c\u78ba\u5b9a\u3059\u308b\u305f\u3081, \n            # \u5373\u5ea7\u306b\u63a2\u7d22\u3092\u7d42\u4e86\u3059\u308b. \u3053\u308c\u306b\u3088\u308a\u30eb\u30fc\u30d7\u306e\u56de\u6570\u306f\u6700\u5927\u3067\u3082M+1\u56de\u3068\u306a\u308b.\n            print(maxX + maxY)\n            return\nprint(maxX + maxY - 1)", "H, W, M = list(map(int, input().split()))\nbombs = set([tuple(map(int, input().split())) for _ in range(M)])\n\ncntH = [0] * (H + 1)\ncntW = [0] * (W + 1)\nfor h, w in bombs:\n    cntH[h] += 1\n    cntW[w] += 1\n\nmxH = max(cntH)\nmxW = max(cntW)\n\nans = mxH + mxW - 1\n\nmxH = [h for h in range(1, H + 1) if cntH[h] == mxH]\nmxW = [w for w in range(1, W + 1) if cntW[w] == mxW]\n\nfor h in mxH:\n    for w in mxW:\n        if not (h, w) in bombs:\n            ans += 1\n            print(ans)\n            return\nprint(ans)\n", "from collections import defaultdict,Counter\n\nh,w,m = map(int,input().split())\n\nw_list = []\nh_list = []\n\nse = set()\n\nfor _ in range(m):\n    nh,nw = map(int,input().split())\n\n    se.add((nh,nw))\n    w_list.append(nw)\n    h_list.append(nh)\n\nw_count = Counter(w_list)\nh_count = Counter(h_list)\n\nmax_w = 0\nmax_h = 0\n\nch = []\ncw = []\n\nfor i in w_count.values():\n    max_w = max(max_w,i)\n    cw.append(i)\n\nfor i in h_count.values():\n    max_h = max(max_h,i)\n    ch.append(i)\n\nma = ch.count(max_h)*cw.count(max_w)\n\nresult = max_h+max_w\npoint = 0\n\nfor i,j in se:\n    if w_count[j] == max_w and h_count[i] == max_h:\n        point += 1\n\nif point == ma:\n    print(result-1)\nelse:\n    print(result)", "import sys\nfrom collections import Counter\n \n \ndef main():\n    H, W, M = map(int, sys.stdin.readline().rstrip().split())\n    Mh = [0] * H\n    Mw = [0] * W\n    B = []\n    for i in range(M):\n        h, w = map(int, sys.stdin.readline().rstrip().split())\n        Mh[h - 1] += 1\n        Mw[w - 1] += 1\n        B.append((h - 1, w - 1))\n \n    nh = max(Mh)\n    nw = max(Mw)\n \n    # \u4ea4\u5dee\u3059\u308b\u5834\u6240\u306b\u7f6e\u304b\u308c\u305f\u51e6\u7406\u7269\u304c\u3042\u308b\u304b\uff1f\n    lh = Counter(Mh)[nh]\n    lw = Counter(Mw)[nw]\n \n    out = 0\n    for (h, w) in B:\n        if Mh[h] == nh and Mw[w] == nw:\n            out += 1\n \n    if out == lh * lw:\n        print(nh + nw - 1)\n    else:\n        print(nh + nw)\n \n \nmain()", "import sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\n\ndef main():\n    H, W, M = list(map(int, input().split()))\n\n    row = [0] * H\n    col = [0] * W\n    bomb = set()\n\n    for i in range(M):\n        h, w = list(map(int, input().split()))\n        h -= 1\n        w -= 1\n        row[h] += 1\n        col[w] += 1\n        bomb.add((h, w))\n\n    # print(row, col, bomb)\n\n    rowmax = max(row)\n    colmax = max(col)\n\n    rows = []\n    cols = []\n    for i in range(H):\n        if row[i] == rowmax:\n            rows.append(i)\n    for i in range(W):\n        if col[i] == colmax:\n            cols.append(i)\n\n    for r in rows:\n        for c in cols:\n            if (r, c) in bomb:\n                continue\n            else:\n                print((rowmax + colmax))\n                return\n\n    print((rowmax + colmax - 1))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import numpy as np\n\nH, W, M = list(map(int, input().split()))\n#map_ = np.zeros((H, W), dtype=np.bool)\n\nh_sum = [0] * H\nw_sum = [0] * W\npoint_list = set()\n\nfor _ in range(M):\n    h, w = list(map(int, input().split()))\n    # map_[h-1, w-1] = 1\n    point_list.add((h-1, w-1))\n    h_sum[h-1] += 1\n    w_sum[w-1] += 1\n\nh_max = max(h_sum)\nw_max = max(w_sum)\n\nh_argmax = set()\nw_argmax = set()\n\nfor i, h in enumerate(h_sum):\n    if h == h_max:\n        h_argmax.add(i) \n\nfor i, w in enumerate(w_sum):\n    if w == w_max:\n        w_argmax.add(i)\n\nans = h_max + w_max\n\nfor h in h_argmax:\n    for w in w_argmax:\n        if (h, w) not in point_list:\n        # if map_[h, w] == 0:\n            print(ans)\n            return\nprint((ans - 1))\n", "import sys\n\ndef solve():\n    readline = sys.stdin.readline\n    H, W, M = map(int, readline().split())\n    h = [0] * H\n    w = [0] * W\n    b = set()\n    for _ in range(M):\n        y, x = map(int, readline().split())\n        x -= 1\n        y -= 1\n        h[y] += 1\n        w[x] += 1\n        b.add(y*W+x)\n    h = sorted(zip(h, range(H)), reverse=True)\n    ans = 0\n    for i in range(W):\n        x = w[i]\n        for y, j in h:\n            if x+y > ans:\n                if j*W+i in b:\n                    ans = x+y-1\n                else:\n                    ans = x+y\n                    break\n            else:\n                break\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "H, W, M = list(map(int, input().split()))\n\nsumh = [0] * W\nsumw = [0] * H\ncheckset = set()\nfor i in range(M):\n    h, w = list(map(int, input().split()))\n    checkset.add((h-1, w-1))\n    sumh[w-1] += 1\n    sumw[h-1] += 1\nshmax = max(sumh)\nswmax = max(sumw)\nsh = []\nsw = []\nfor i, s in enumerate(sumh):\n    if s == shmax: sh.append(i)\nfor i, s in enumerate(sumw):\n    if s == swmax: sw.append(i)\nans = shmax + swmax - 1\njdg = False\nfor i in sh:\n    for j in sw:\n        if (j, i) not in checkset: \n            ans += 1\n            jdg = True\n            break\n\n    if jdg: break\nprint(ans)\n", "H,W,M = list(map(int, input().split()))\nwidth = [0]*W\nheight = [0]*H\n\nst = set()\nfor i in range(M):\n  y, x = list(map(int, input().split()))\n  st.add((x - 1,y - 1))\n  width[x-1] += 1\n  height[y-1] += 1\n\nmaxW = max(width)\nmaxH = max(height)\n\nindexW = [i for i, v in enumerate(width) if v == maxW]\nindexH = [i for i, v in enumerate(height) if v == maxH]\n\nans = maxW + maxH \n\n#\u305d\u308c\u305e\u308c\u5217\u3068\u884c\u306e\u6700\u5927\u5024\u306e\u4e2d\u304b\u3089\u9069\u5f53\u306b\uff11\u3064\u305a\u3064\u5217\u3068\u884c\u3092\u9078\u3076\ntmpX = indexW[0]\ntmpY = indexH[0]\n\n#Height\u3068Width\u306e\u305d\u308c\u305e\u308c\u306e\u6700\u5927\u5024\u306e\u70b9(x, y)\u306b\u7206\u5f3e\u304c\u306a\u3044\u5834\u5408\u304c\u3042\u308b\u304b\u3069\u3046\u304b\nflag = 0\n\n#print(f\"indexH {indexH}\")\n#print(f\"indexW {indexW}\")\n\n#Height\u306e\u6700\u5927\u5024\u3068\u3001width\u306e\u305d\u308c\u305e\u308c\u3092\u5168\u63a2\u7d22\nfor x in indexW:\n  y = tmpY\n  if not (x, y) in st:\n    flag = 1\n    break\n\n\nfor y in indexH:\n  x = tmpX\n  if not (x, y) in st:\n    flag = 1\n    break\n\nif flag == 1:\n  print(ans)\nelse:\n  print((ans - 1))\n", "(h,w,m),*e=[[*map(int,i.split())]for i in open(0)]\na,b=[0]*h,[0]*w\nfor y,x in e:\n    a[y-1]+=1\n    b[x-1]+=1\nans=max(a)+max(b)\nc=a.count(max(a))*b.count(max(b))-sum(a[y-1]+b[x-1]==ans for y,x in e)\nprint(ans-(c<=0))", "import collections\nimport sys\ndef input() : return sys.stdin.readline().strip()\nh,w,m = map(int,input().split())\nX = []\nY = []\nfor _ in range(m):\n    x,y = map(int,input().split())\n    X.append(x)\n    Y.append(y)\n\nmost_common_x = collections.Counter(X).most_common()\nmost_common_x_index = most_common_x[0][0]\nmost_common_x_count = most_common_x[0][1]\nmost_common_y = collections.Counter(Y).most_common()\nmost_common_y_index = most_common_y[0][0]\nmost_common_y_count = most_common_y[0][1]\n\notherwisey = []\notherwisex = []\nfor i in range(m):\n    if X[i] != most_common_x_index:\n        otherwisey.append(Y[i])\n    if Y[i] != most_common_y_index:\n        otherwisex.append(X[i])\n\nmost_common_y = collections.Counter(otherwisey).most_common()\nif len(most_common_y)!= 0:\n    ansx = most_common_y[0][1] + most_common_x_count\nelse:\n    ansx = most_common_x_count\n\nmost_common_x = collections.Counter(otherwisex).most_common()\nif len(most_common_x)!= 0:\n    ansy = most_common_x[0][1] + most_common_y_count\nelse:\n    ansy = most_common_y_count\n\nprint(max(ansx,ansy))", "h, w, m = map(int, input().split())\nbord_x, bord_y = [0]*h, [0]*w\n \nhw = []\nfor _i in range(m):\n    s, t = map(int, input().split())\n    s -= 1\n    t -= 1\n    bord_x[s] += 1\n    bord_y[t] += 1\n    hw.append([s, t])\n \nx_max, y_max = max(bord_x), max(bord_y)\n \ncnt = 0\nfor i, j in hw:\n    if bord_x[i] == x_max and bord_y[j] == y_max:\n        cnt += 1\n \nif cnt == bord_x.count(x_max)*bord_y.count(y_max):\n    x_max -= 1\n \nprint(x_max+y_max)", "from collections import defaultdict\n\nh, w, m = map(int, input().split())\n\nrowsum = [0] * h\nrowmax = 0\ncolsum = [0] * w\ncolmax = 0\ntargets = defaultdict(int)\nfor _ in range(m):\n    hi, wi = map(int, input().split())\n    hi -= 1\n    wi -= 1\n    rowsum[hi] += 1\n    rowmax = max(rowmax, rowsum[hi])\n    colsum[wi] += 1\n    colmax = max(colmax, colsum[wi])\n    targets[(hi, wi)] = 1\n\nrowindices = []\nfor i, v in enumerate(rowsum):\n    if v == rowmax:\n        rowindices.append(i)\n\ncolindices = []\nfor i, v in enumerate(colsum):\n    if v == colmax:\n        colindices.append(i)\n\nans = rowmax + colmax - 1\nfor ri in rowindices:\n    for ci in colindices:\n        if targets[(ri, ci)]:\n            continue\n        print(rowmax + colmax)\n        return\n\nprint(ans)", "H, W, M = map(int, input().split())\nbombs = {}\nrows = []\ncols = []\nfor i in range(H):\n    rows.append([i, 0])\nfor i in range(W):\n    cols.append([i, 0])\nfor i in range(M):\n    y, x = map(lambda x: x - 1, map(int, input().split()))\n    bombs[(y,x)] = True\n    rows[y][1] += 1\n    cols[x][1] += 1\n\n\nrows = sorted(rows, key=lambda x: x[1], reverse=True)\ncols = sorted(cols, key=lambda x: x[1], reverse=True)\nanswer = 0\nfor row in rows:\n    a = cols[0][1] + row[1] - (1 if (row[0], cols[0][0]) in bombs else 0)\n    if a > answer:\n        answer = a\nfor col in cols:\n    a = rows[0][1] + col[1] - (1 if (rows[0][0], col[0]) in bombs else 0)\n    if a > answer:\n        answer = a\nprint(answer)", "H, W, M = map(int,input().split())\nP = [list(map(int, input().split())) for i in range(M)]\nfor p in P:\n    p[0] -= 1\n    p[1] -= 1\ncnth = [0]*H\ncntw = [0]*W\nans = 0\nfor p in P:\n    cnth[p[0]] += 1\nfor p in P:\n    cntw[p[1]] += 1\nmxh = max(cnth)\nmxw = max(cntw)\ncntx = 0\nfor p in P:\n    if cnth[p[0]] == mxh and cntw[p[1]] == mxw:\n        cntx += 1\nif cntx == cnth.count(mxh) * cntw.count(mxw):\n    ans = mxh + mxw -1\nelse:\n    ans = mxh + mxw\nprint(ans)", "def solve(H, W, M, h, w):\n    f = [0] * (H+1)\n    g = [0] * (W+1)\n    for r, c in zip(h, w):\n        f[r] += 1\n        g[c] += 1\n    p = max(f)\n    q = max(g)\n    num = len(list(filter(p.__eq__, f))) * len(list(filter(q.__eq__, g)))\n    num -= len(list(filter(lambda _: f[_[0]] + g[_[1]] == p + q, zip(h, w))))\n    return p + q - (num <= 0)\n\nH, W, M = map(int, input().split())\nh, w = zip(*[map(int, input().split()) for i in range(M)])\nprint(solve(H, W, M, h, w))", "H, W, M = map(int, input().split())\n \nh = [0] * H\nw = [0] * W\nMem = [tuple(map(int, input().split())) for _ in range(M) ]\nfor i, j in Mem:\n  h[i-1] += 1\n  w[j-1] += 1\n\nmaxh = max(h)\nmaxw = max(w)\n \nlisth = {i for i, v in enumerate(h, 1) if v == maxh}\nlistw = {j for j, v in enumerate(w, 1) if v == maxw}\n\ncnt = len(listh) * len(listw)\n\nfor i, j in Mem:\n  if i in listh and j in listw:\n    cnt -= 1\n \nif cnt:\n  ans = maxh + maxw\nelse:\n  ans = maxh + maxw - 1\n\nprint(ans)", "\nH,W,M=list(map(int,input().split()))\n\nHSum=[0 for _ in range(H)]\nWSum=[0 for _ in range(W)]\n\n\nbombs = set()\nfor _ in range(M):\n\thi,wi = [int(x)-1 for x in input().split()]\n\tHSum[hi] += 1\n\tWSum[wi] += 1\n\tbombs.add( (hi,wi) )\n# print(HSum)\n# print(WSum)\n\n\n\ncurMax = 0\n\n## \u8a08\u7b97\u91cf\u591a\u3059\u304e\u3002\u3002\n# for h in range(H):\n# \tfor w in range(W):\n# \t\ttmp = HSum[h] + WSum[w]\n# \t\tif curMax <= tmp:\n# \t\t\tif (h,w) in bombs:\n# \t\t\t\ttmp -= 1\n# \t\t\tcurMax = max( curMax, tmp )\n\nhMax = max(HSum)\nwMax = max(WSum)\ntmpMax = hMax + wMax\n\nans = 0\n\nhSumMaxOnly = [h for h, x in enumerate(HSum) if x == hMax]\nwSumMaxOnly = [w for w, y in enumerate(WSum) if y == wMax]\n\nfor h in hSumMaxOnly:\n\tif ans == tmpMax:\n\t\tbreak\n\tfor w in wSumMaxOnly:\n\t\tif (h,w) in bombs:\n\t\t\tans = tmpMax - 1\n\t\telse:\n\t\t\tans = tmpMax\n\t\t\tbreak\n\n\n\nprint(ans)\n", "h,w,m=map(int,input().split())\nl=[list(map(int,input().split())) for _ in range(m)]\nch,cw=[0]*(h+1),[0]*(w+1)\nfor x in l:\n    ch[x[0]]+=1\n    cw[x[1]]+=1\nMh,Mw=max(ch),max(cw)\nn0=ch.count(Mh)*cw.count(Mw)\ncnt=0\nfor x in l:\n    if ch[x[0]]==Mh and cw[x[1]]==Mw:cnt+=1\nans=Mh+Mw-1\nif cnt<n0:ans+=1\nprint(ans)", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    ans = 0\n    H, W, M = map(int, input().split())\n    bombs = []\n    hs = [0]*(H)\n    ws = [0]*(W)\n    for _ in range(M):\n        h, w = map(int, input().split())\n        bombs.append(tuple([h-1, w-1]))\n        hs[h-1] += 1\n        ws[w-1] += 1\n    maxh = max(hs)\n    maxw = max(ws)\n    ans = maxh + maxw\n\n    maxhindex = [i for i, x in enumerate(hs) if x == maxh]\n    maxwindex = [i for i, x in enumerate(ws) if x == maxw]\n\n    isfound = False\n\n    bombs = set(bombs)\n    for i in maxhindex:\n        for j in maxwindex:\n            if (i, j) not in bombs:\n                print(ans)\n                return\n\n    print(ans-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nH,W,M = readInts()\n\ndic1 = Counter()\ndic2 = Counter()\ns = set()\nfor i in range(M):\n    h,w = [int(x)-1 for x in input().split()]\n    dic1[h] += 1\n    dic2[w] += 1\n    s.add((h,w))\n# print(dic)\nans = 0\n\n# \u91cd\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3067\u6700\u5927\u5024\u304c\u3042\u308b\u6642\u3082\u3042\u308c\u3070\n# \u884c\u3001\u5217\u306e\u4ea4\u5dee\u70b9\u3067\u30dc\u30e0\u306a\u3057\u304c\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u304c\u3042\u308b\nfor h,w in s:\n    ans = max(ans, dic1[h] + dic2[w] - 1)\n\ndic1 = dic1.most_common()\ndic2 = dic2.most_common()\nmax1 = dic1[0][1]\nmax2 = dic2[0][1]\n\nfor k1,v1 in dic1:\n    if v1 < max1:\n        break # continue\u3059\u308b\u5fc5\u8981\u304c\u306a\u3044 most_common\u3067\u5927\u304d\u3044\u65b9\u304b\u3089\u96c6\u3081\u3066\u308b\u306e\u3067\n    for k2,v2 in dic2:\n        if v2 < max2:\n            break # \u540c\u3058\u304f\n        if (k1,k2) in s: # \u4e00\u5ea6\u8a08\u7b97\u3057\u305f\u3082\u306e\n            continue\n        # \u4e21\u65b9\u3068\u3082\u6700\u5927\u3067\u3042\u308c\u3070ok\n        ans = max(ans, v1 + v2)\n        break\nprint(ans)\n", "H,W,M=map(int,input().split())\nrow=[0]*H\ncol=[0]*W\ntarget=set()\nfor i in range(M):\n    h,w=map(int,input().split())\n    row[h-1]+=1\n    col[w-1]+=1\n    target.add((h-1,w-1))\nA=max(row)\nB=max(col)\na=[x for x in range(H) if row[x]==A]\nb=[x for x in range(W) if col[x]==B]\ncnt=0\nfor i in a:\n    for j in b:\n        cnt+=1\n        if (i,j) not in target:\n            print(A+B)\n            return\n        if cnt>M:\n            print(A+B-1)\n            return\nprint(A+B-1)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\n\nh,w,m=nii()\n\nhl=[0 for i in range(h+1)]\nwl=[0 for i in range(w+1)]\nhwl=set()\n\nfor i in range(m):\n  th,tw=nii()\n  hl[th]+=1\n  wl[tw]+=1\n  hwl.add((th,tw))\n\nh_max=max(hl)\nw_max=max(wl)\n\nh_cand=[i for i in range(h+1) if hl[i]==h_max]\nw_cand=[i for i in range(w+1) if wl[i]==w_max]\n\nfor i in h_cand:\n  for j in w_cand:\n    if (i,j) not in hwl:\n      print(h_max+w_max)\n      return\n\nprint(h_max+w_max-1)", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 10**9 + 7\n#R = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nh,w,m = inm()\nha = [0]*h\nwa = [0]*w\nq = {}\nfor i in range(m):\n    hh,ww = inm()\n    hh -= 1\n    ww -= 1\n    q[(hh,ww)] = 1\n    ha[hh] += 1\n    wa[ww] += 1\nmh = max(ha)\nmw = max(wa)\na = [i for i in range(h) if ha[i]==mh]\nb = [i for i in range(w) if wa[i]==mw]\nfor i in a:\n    for j in b:\n        if (i,j) not in q:\n            print(mh+mw)\n            return\nprint(mh+mw-1)\n", "########### E\nH, W, M = map(int, input().split())\nbombs = []\nfor _ in range(M):\n    bomb = tuple(map(lambda x:int(x)-1, input().split()))\n    bombs.append(bomb)\n\nH_list = [0]*H\nW_list = [0]*W\nfor h,w in bombs:\n    H_list[h] += 1\n    W_list[w] += 1\n    \nmaxX = max(H_list)\nmaxY = max(W_list)\n\nmax_H = [i for i,k in enumerate(H_list) if k == maxX]\nmax_W = [i for i,k in enumerate(W_list) if k == maxY]\n\nbombs = set(bombs)\nfor i in max_H:\n    for k in max_W:\n        if (i,k) not in bombs:\n            print(maxX + maxY)\n            return\n\nprint(maxX + maxY -1)", "### ----------------\n### \u3053\u3053\u304b\u3089\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\n\ndef yn(b):\n    print((\"Yes\" if b==1 else \"No\"))\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n\n    h,w,m=list(map(int, readline().rstrip().split()))\n    cntH=[0]*h\n    cntW=[0]*w\n\n    ys=[0]*m\n    xs=[0]*m\n\n    for i in range(m):\n        y,x = list(map(int, readline().rstrip().split()))\n        y-=1\n        x-=1\n        cntH[y]+=1\n        cntW[x]+=1\n        ys[i]=y\n        xs[i]=x\n    maxX = max(cntW)\n    maxY = max(cntH)\n    cntMaxX=cntW.count(maxX)\n    cntMaxY=cntH.count(maxY)\n    cntMax=cntMaxX*cntMaxY\n\n    for i in range(m):\n        y=ys[i]\n        x=xs[i]\n        maxPtn=False\n        if cntH[y]==maxY and cntW[x]==maxX:\n            cntMax-=1\n    if cntMax > 0:\n        print((maxX+maxY))\n    else:\n        print((maxX+maxY-1))\n    return\n\n\nif 'doTest' not in globals():\n    resolve()\n    return\n\n### ----------------\n### \u3053\u3053\u307e\u3067 \n### ----------------\n", "h,w,m = map(int,input().split())\nx = {}\ny = {}\ndic = {}\nfor _ in range(m):\n    a,b = map(int,input().split())\n    dic[(a,b)] = 1\n    x[a] = x.get(a,0) + 1\n    y[b] = y.get(b,0) + 1\np = max(x.values())\nq = max(y.values())\ncnt = 1\na = [i for i in x if x[i] == p]\nb = [j for j in y if y[j] == q]\nfor i in a:\n    for j in b:\n        if dic.get((i,j),-1) == -1:\n            cnt = 0\n            break\n    if not cnt:\n        break\nprint(p+q-cnt)", "import collections\n\nh,w,m = map(int,input().split())\nX = []\nY = []\nfor _ in range(m):\n    x,y = map(int,input().split())\n    X.append(x)\n    Y.append(y)\n\nmost_common_x = collections.Counter(X).most_common()\nmost_common_x_index = most_common_x[0][0]\nmost_common_x_count = most_common_x[0][1]\nmost_common_y = collections.Counter(Y).most_common()\nmost_common_y_index = most_common_y[0][0]\nmost_common_y_count = most_common_y[0][1]\n\notherwisey = []\notherwisex = []\nfor i in range(m):\n    if X[i] != most_common_x_index:\n        otherwisey.append(Y[i])\n    if Y[i] != most_common_y_index:\n        otherwisex.append(X[i])\n\nmost_common_y = collections.Counter(otherwisey).most_common()\nif len(most_common_y)!= 0:\n    ansx = most_common_y[0][1] + most_common_x_count\nelse:\n    ansx = most_common_x_count\n\nmost_common_x = collections.Counter(otherwisex).most_common()\nif len(most_common_x)!= 0:\n    ansy = most_common_x[0][1] + most_common_y_count\nelse:\n    ansy = most_common_y_count\n\nprint(max(ansx,ansy))", "H,W,M = list(map(int,input().split()))\nhs = [0] * H\nws = [0] * W\ns = set()\n\nfor i in range(M):\n  r,c = list(map(int,input().split()))\n  r -= 1\n  c -= 1\n  hs[r] += 1\n  ws[c] += 1\n  s.add((r,c))\nmh = 0\nmw = 0\nfor i in range(H):\n  mh = max(mh, hs[i])\nfor j in range(W):\n  mw = max(mw, ws[j])\n\ni_s = list()\nj_s = list()\nfor i in range(H):\n  if mh == hs[i]:\n    i_s.append(i)\nfor j in range(W):\n  if mw == ws[j]:\n    j_s.append(j)\nans = mh + mw\nfor i in i_s:\n  for j in j_s:\n    if (i,j) in s:\n      continue\n    print(ans)\n    return\nans -= 1\nprint(ans)\n", "H, W, M = map(int, input().split())\n\nHc = [0 for i in range(H)]\nWc = [0 for i in range(W)]\nB = []\n\nfor m in range(M):\n  h, w = map(int, input().split())\n  Hc[h - 1] += 1\n  Wc[w - 1] += 1\n  B.append((h - 1, w - 1))\nHcmax = max(Hc)\nHcmax_idx = [i for i, x in enumerate(Hc) if x == Hcmax] \nWcmax = max(Wc)\nWcmax_idx = [i for i, x in enumerate(Wc) if x == Wcmax] \n\nans = Hcmax + Wcmax - 1\nB = set(B)\nf = False\nfor i in Hcmax_idx:\n  if f:\n    break\n  for j in Wcmax_idx:\n    if (i, j) not in B:\n      ans = Hcmax + Wcmax\n      f = True\n      break\nprint(ans)", "import numpy as np\nH, W, M = map(int, input().split())\ncol = np.zeros(H)\nrow = np.zeros(W)\nmemo = []\nfor i in range(M):\n    h, w = map(int, input().split())\n    h -= 1\n    w -= 1\n    col[h] += 1\n    row[w] += 1\n    memo.append((h,w))\n\ncol_max = col.max()\nrow_max = row.max()\n\ncol_max_indexes = np.where(col == col_max)[0]\nrow_max_indexes = np.where(row == row_max)[0]\n\nans = col_max + row_max - 1\nmemo = set(memo)\nfor c in col_max_indexes:\n    for r in row_max_indexes:\n        if (c,r) not in memo:\n            ans = col_max + row_max\n            print(int(ans))\n            return\n\nprint(int(ans))", "def main():\n    h, w, m, *BOM = list(map(int, open(0).read().split()))\n    row = [0] * h\n    col = [0] * w\n    for i, j in zip(BOM[::2], BOM[1::2]):\n        i -= 1\n        j -= 1\n        row[i] += 1\n        col[j] += 1\n\n    p, q = max(row), max(col)\n    rr = sum(1 for i in range(h) if row[i] == p)\n    rl = sum(1 for i in range(w) if col[i] == q)\n\n    cnd = rr * rl\n\n    for i, j in zip(BOM[::2], BOM[1::2]):\n        i -= 1\n        j -= 1\n        if (row[i], col[j]) == (p, q):\n            cnd -= 1\n\n    if cnd > 0:\n        ans = p + q\n    else:\n        ans = p + q - 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import Counter\n\n\ndef main():\n    H, W, M = list(map(int, input().split()))\n    bombs = [list(map(int, input().split())) for _ in range(M)]\n    counter_row = Counter([h for h, _ in bombs])\n    val_max_row, max_rows = 0, []\n    for h, v in counter_row.items():\n        if val_max_row < v:\n            val_max_row = v\n            max_rows = [h]\n        elif val_max_row == v:\n            max_rows.append(h)\n    counter_col = Counter([w for _, w in bombs])\n    val_max_col, max_cols = 0, []\n    for w, v in counter_col.items():\n        if val_max_col < v:\n            val_max_col = v\n            max_cols = [w]\n        elif val_max_col == v:\n            max_cols.append(w)\n    # \u57fa\u672c\u7684\u306b\u306f val_max_row + val_max_col \u304c\u7b54\u3048\u3002\n    # \u884c\u30fb\u5217\u3067\u91cd\u8907\u30ab\u30a6\u30f3\u30c8\u306b\u306a\u308b\u30b1\u30fc\u30b9\u3060\u3063\u305f\u5834\u5408\u306f\u3053\u3053\u304b\u30891\u5f15\u304b\u306a\u3044\u3068\u3044\u3051\u306a\u3044\u3002\n    max_rows = Counter(max_rows)\n    max_cols = Counter(max_cols)\n    n_max_cells = len(max_rows.keys()) * len(max_cols.keys())\n    n_cells = 0\n    for h, w in bombs:\n        if max_rows[h] > 0 and max_cols[w] > 0:\n            n_cells += 1\n    ans = val_max_row + val_max_col\n    if n_cells >= n_max_cells:\n        ans -= 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    ans = 0\n    H, W, M = map(int, input().split())\n    bombs = []\n    hs = [0]*(H)\n    ws = [0]*(W)\n    for _ in range(M):\n        h, w = map(int, input().split())\n        bombs.append(tuple([h-1, w-1]))\n        hs[h-1] += 1\n        ws[w-1] += 1\n    maxh = max(hs)\n    maxw = max(ws)\n    ans = maxh + maxw\n\n    maxhindex = [i for i, x in enumerate(hs) if x == maxh]\n    maxwindex = [i for i, x in enumerate(ws) if x == maxw]\n\n    isfound = False\n\n    bombs = set(bombs)\n    for i in maxhindex:\n        for j in maxwindex:\n            if (i, j) not in bombs:\n                print(ans)\n                return\n\n    print(ans-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nh,w,m = list(map(int,input().split()))\nh_lst = [[0,i] for i in range(h)]\nw_lst = [[0,i] for i in range(w)]\nmemo = []\n\nfor i in range(m):\n  x,y = list(map(int,input().split()))\n  h_lst[x-1][0] += 1\n  w_lst[y-1][0] += 1\n  memo.append((x-1,y-1))\n\nh_lst.sort(reverse = True)\nw_lst.sort(reverse = True)\nMax_h = h_lst[0][0]\nMax_w = w_lst[0][0]\nh_ans = [h_lst[0][1]]\nw_ans = [w_lst[0][1]]\nif h != 1:\n  s = 1\n  while s < h and h_lst[s][0] == Max_h:\n    h_ans.append(h_lst[s][1])\n    s+= 1  \nif w!= 1:  \n  t=1  \n  while t < w and w_lst[t][0] == Max_w:\n    w_ans.append(w_lst[t][1])\n    t += 1\n  \n\nmemo = set(memo)\n\n#\u63a2\u7d22\u3059\u308b\u30ea\u30b9\u30c8\u306f\u3001\u6700\u5927\u3092\u53d6\u308b\u3082\u306e\u306e\u96c6\u5408\u3067\u306a\u3051\u308c\u3070\u8a08\u7b97\u91cf\u306fO(m)\u306b\u306f\u306a\u3089\u306a\u3044\uff01             \nfor j in h_ans:\n  for k in w_ans:\n    if (j,k) not in memo:\n      print((Max_h+Max_w))\n      return\nprint(((Max_h+Max_w)-1))        \n  \n\n", "h,w,m=map(int,input().split())\ns=[0]*m\nt=[0]*m\ntemp=set()\nfor i in range(m):\n  sm,tm=map(int,input().split())\n  s[i]=sm\n  t[i]=tm\n  temp.add((s[i],t[i]))\nst=[0]*h\ntt=[0]*w\nfor i in range(m):\n  st[s[i]-1]=st[s[i]-1]+1\n  tt[t[i]-1]=tt[t[i]-1]+1\nsmax=max(st)\ntmax=max(tt)\nans=smax+tmax\nmaxs=[]\nmaxt=[]\nfor i in range(h):\n  if st[i]==smax:\n    maxs.append(i)\nfor i in range(w):\n  if tt[i]==tmax:\n    maxt.append(i)\n\nif len(maxs)*len(maxt)>m:\n  print(ans)\nelse:\n  for i in range(len(maxs)):\n    for j in range(len(maxt)):\n      if (maxs[i]+1,maxt[j]+1) not in temp:\n        print(ans)\n        return\n  else:\n    print(ans-1)", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    ans = 0\n    H, W, M = map(int, input().split())\n    bombs = []\n    hs = [0]*(H)\n    ws = [0]*(W)\n    for _ in range(M):\n        h, w = map(int, input().split())\n        bombs.append(tuple([h-1, w-1]))\n        hs[h-1] += 1\n        ws[w-1] += 1\n    maxh = max(hs)\n    maxw = max(ws)\n    ans = maxh + maxw\n\n    maxhindex = [i for i, x in enumerate(hs) if x == maxh]\n    maxwindex = [i for i, x in enumerate(ws) if x == maxw]\n\n    bombs = set(bombs)\n    for i in maxhindex:\n        for j in maxwindex:\n            if (i, j) not in bombs:\n                print(ans)\n                return\n\n    print(ans-1)\n\ndef __starting_point():\n    main()\n__starting_point()", "import numpy as np\nimport sys\nread = sys.stdin.read\n\ndef solve(stdin):\n\th, w, m = stdin[:3]\n\n\trow = np.zeros(h, np.int)\n\tcol = np.zeros(w, np.int)\n\tfor i in range(3, m * 2 + 3, 2):\n\t\ty, x = stdin[i: i + 2] - 1\n\t\trow[y] += 1\n\t\tcol[x] += 1\n\n\tmax_cnt_y = max(row)\n\tmax_cnt_x = max(col)\n\tmax_pair = np.sum(row == max_cnt_y) * np.sum(col == max_cnt_x)\n\tfor i in range(3, m * 2 + 3, 2):\n\t\ty, x = stdin[i: i + 2] - 1\n\t\tif row[y] == max_cnt_y and col[x] == max_cnt_x:\n\t\t\tmax_pair -= 1\n\n\treturn max_cnt_y + max_cnt_x - (max_pair == 0)\n\nprint(solve(np.fromstring(read(), dtype=np.int, sep=' ')))", "import collections\n\nh,w,m = map(int,input().split())\nX = []\nY = []\nfor _ in range(m):\n    x,y = map(int,input().split())\n    X.append(x)\n    Y.append(y)\n#\u307e\u305a\u4e00\u756a\u5927\u3044X\u5ea7\u6a19\u3092\u8abf\u3079\u308b\nmost_common_x = collections.Counter(X).most_common()\nmost_common_x_index = most_common_x[0][0] #x\u5ea7\u6a19\nmost_common_x_count = most_common_x[0][1] #\u305d\u306e\u7dda\u306b\u5b58\u5728\u3059\u308b\u7206\u5f3e\u306e\u500b\u6570\n#\u7206\u7834\u3055\u308c\u306a\u3044\u5ea7\u6a19\u305f\u3061\u306e\u5171\u901a\u3059\u308bY\u5ea7\u6a19\u3092\u63a2\u3059\notherwise = []\nfor i in range(m):\n    if X[i] != most_common_x_index:#not most common\n        otherwise.append(Y[i])\nmost_common_y = collections.Counter(otherwise).most_common()\nif len(most_common_y)!= 0: #\u3042\u308b\u7279\u5b9a\u306ey\u304c\u5b58\u5728\u3057\u305f\u6642\n    ansx = most_common_y[0][1] + most_common_x_count\nelse: #\u3082\u3068\u3082\u3068\u5168\u90e8\u306ey\u5ea7\u6a19\u304c\u63c3\u3063\u3066\u3044\u305f\u6642\n    ansx = most_common_x_count\n#\u6b21\u306bY\u5ea7\u6a19\u3092\u57fa\u6e96\u306b\u3057\u3066\u8abf\u3079\u308b\nmost_common_y = collections.Counter(Y).most_common()\nmost_common_y_index = most_common_y[0][0] #x\u5ea7\u6a19\nmost_common_y_count = most_common_y[0][1] #\u305d\u306e\u7dda\u306b\u5b58\u5728\u3059\u308b\u7206\u5f3e\u306e\u500b\u6570\notherwise = []\nfor i in range(m):\n    if Y[i] != most_common_y_index:#not most common\n        otherwise.append(X[i])\nmost_common_x = collections.Counter(otherwise).most_common()\nif len(most_common_x)!= 0 :\n    ansy = most_common_x[0][1] + most_common_y_count\nelse:\n    ansy = most_common_y_count\nprint(max(ansx,ansy))", "h,w,m=list(map(int,input().split()))\nh=[]\nw=[]\nfor i in range(m):\n  h_,w_=list(map(int,input().split()))\n  h.append(h_)\n  w.append(w_)\nfrom collections import Counter\ndic_h=Counter(h)\ndic_w=Counter(w)\nmax_h=max(dic_h.values())\nmax_w=max(dic_w.values())\n\nh_set=set()\nw_set=set()\nfor i in dic_h:\n  if dic_h[i]==max_h:\n    h_set.add(i)\nfor j in dic_w:\n  if dic_w[j]==max_w:\n    w_set.add(j)\n\ncnt=0\nfor i in range(m):\n  if h[i] in h_set and w[i] in w_set:\n    cnt+=1\nif len(h_set)*len(w_set)>cnt:\n  print((max_h+max_w))\nelse:\n  print((max_h+max_w-1))\n  \n  \n", "import sys\n\nH, W, M = map(int, input().split())\nR = [0] * H\nC = [0] * W\nS = set()\n\nfor _ in range(M):\n  h, w = map(int, input().split())\n  S.add((h - 1, w - 1))\n  R[h - 1] += 1\n  C[w - 1] += 1\n\nr = max(R)\nc = max(C)\n\nHL = [i for i in range(H) if R[i] == r]\nWL = [j for j in range(W) if C[j] == c]\n \n#print(r, HL)\n#print(c, WL)\n  \nfor h in HL:\n  for w in WL:\n    if not (h, w) in S:\n      print(r + c)\n      return\n\nprint(r + c - 1)", "import sys\n\nH, W, M = list(map(int, input().split()))\nA = [list([int(x) - 1 for x in input().split()]) for i in range(M)]\n\ncnth = [0] * H\ncntw = [0] * W\nst = set()\n\nfor y, x in A:\n    cnth[y] += 1\n    cntw[x] += 1\n    st.add((y, x))\n\nmy = max(cnth)\nmx = max(cntw)\n\nY = []\nX = []\n\nfor i in range(H):\n    if cnth[i] == my:\n        Y.append(i)\n\nfor i in range(W):\n    if cntw[i] == mx:\n        X.append(i)\n\nfor y in Y:\n    for x in X:\n        if not (y, x) in st:\n            print((my + mx))\n            return\n\nprint((my + mx - 1))\n", "def main():\n    H, W, M = list(map(int, input().split()))\n    hw = [tuple(list(map(int, input().split()))) for _ in [0]*M]\n    hw_set = set(hw)\n    h_count = [0 for i in range(H+1)]\n    w_count = [0 for i in range(W+1)]\n    for h, w in hw:\n        h_count[h] += 1\n        w_count[w] += 1\n    h_m = max(h_count)\n    w_m = max(w_count)\n    h_list = []\n    w_list = []\n    for i in range(H+1):\n        if h_count[i] == h_m:\n            h_list.append(i)\n    for i in range(W+1):\n        if w_count[i] == w_m:\n            w_list.append(i)\n    #print(h_list, w_list)\n    for i in h_list:\n        for j in w_list:\n            if (i, j) not in hw_set:\n                print((h_m+w_m))\n                return\n    print((h_m+w_m-1))\n\n\nmain()\n", "import sys\nsys.setrecursionlimit(10**7)\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    H, W, M = map(int, input().split())\n    bombs = []\n    hs = [0] * H\n    ws = [0] * W\n    for _ in range(M):\n        h, w = map(int, input().split())\n        bombs.append(tuple([h-1, w-1]))\n        hs[h-1] += 1\n        ws[w-1] += 1\n    maxh = max(hs)\n    maxw = max(ws)\n    ans = maxh + maxw\n\n    maxhindex = [i for i, x in enumerate(hs) if x == maxh]\n    maxwindex = [i for i, x in enumerate(ws) if x == maxw]\n\n    bombs = set(bombs)\n    for i in maxhindex:\n        for j in maxwindex:\n            if (i, j) not in bombs:\n                print(ans)\n                return\n    print(ans-1)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "h,w,m=list(map(int,input().split()))\n\nH,W=[0]*h,[0]*w\nP=set()\n\nfor i in range(m):\n  y,x=list(map(int,input().split()))\n  H[~-y]+=1\n  W[~-x]+=1\n  P.add(~-y*w+~-x)\n\nmh,mw=max(H),max(W)\nMH=[i for i,h in enumerate(H) if h==mh]\nMW=[i for i,v in enumerate(W) if v==mw]\nfor y in MH:\n  for x in MW:\n    if y*w+x not in P:\n      print((mh+mw))\n      return\n\nprint((mh+mw-1))\n"]
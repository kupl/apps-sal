["n = int(input())\nT = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    T.append([x, y])\nP = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1, y1 = T[i]\n        x2, y2 = T[j]\n        a = y2 - y1\n        b = x1 - x2\n        c = -(a * x1 + b * y1)\n        P.append([a, b, c])\nconst = 10 ** 10 + 3\ncnt = 0\nnewP = []\nvisit = []\nfor a, b, c in P:\n    if a != 0:\n        if [1, b / a, c / a] not in visit:\n            newP.append([1, b / a, c / a])\n            visit.append([1, b / a, c / a])\n    else:\n        if [0, 1, c / b] not in visit:\n            newP.append([0, 1, c / b])\n            visit.append([0, 1, c / b])\nP = newP\nfor i in range(len(P)):\n    for j in range(i + 1, len(P)):\n        a1, b1, c1 = P[i]\n        a2, b2, c2 = P[j]\n        if a1 * b2 == a2 * b1:\n            pass\n        else:\n            x = (b1 * c2 - b2 * c1) / (a1 * b2 - b1 * a2)\n            y = (c1 * a2 - a1 * c2) / (a1 * b2 - b1 * a2)\n            cnt += 1\nprint(cnt)", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\n\nn = int(input())\np = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    p.append((x, y))\n\nd = {}\n\nfor i in range(n):\n    x1, y1 = p[i]\n    for j in range(i+1, n):\n        x2, y2 = p[j]\n        if x1 != x2:  \n            m = (y2-y1)/(x2-x1)\n            c = (y1*x2-x1*y2)/(x2-x1)\n        else:\n            m = 10**10\n            c = x1\n        if m in d:\n            if c in d[m]:\n                d[m][c] += 1\n            else:\n                d[m][c] = 1\n        else:\n            d[m] = {c: 1}\n\np = []\nfor m in d:\n    p.append(len(d[m]))\ns = sum(p)\nans = 0\nfor x in p:\n    ans += x*(s-x)\nprint(ans//2)", "import math\n\n\nclass Pt:\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            self.x, self.y = 0, 0\n        elif len(args) == 1:\n            self.x, self.y = list(map(int, args[0].split()))\n        else:\n            self.x, self.y = args[0], args[1]\n\n    def __str__(self):\n        return str(self.x) + ' ' + str(self.y)\n\n    def __add__(self, other):\n        return Pt(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Pt(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Pt(self.x * other, self.y * other)\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __truediv__(self, other):\n        return Pt(self.x / other, self.y / other)\n\n    def __abs__(self):\n        return math.hypot(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    @staticmethod\n    def get_straight(self, other):\n        a = self.y - other.y\n        b = other.x - self.x\n        c = self.cross(other)\n        return a, b, c\n\n\nclass Straight:\n\n    def __init__(self, *args):\n        if len(args) == 1:\n            self.a, self.b, self.c = list(map(int, args[0].split()))\n        elif len(args) == 2:\n            self.a, self.b, self.c = Pt.get_straight(*args)\n        elif len(args) == 3:\n            self.a, self.b, self.c = args\n\n    def __str__(self):\n        return ' '.join(map(str, [self.a, self.b, self.c]))\n\n    def __eq__(self, other):\n        if self.b != 0 or other.b != 0:\n            return self.a * other.b == other.a * self.b and self.c * other.b == other.c * self.b\n        val1 = math.sqrt(self.a ** 2 + self.b ** 2)\n        val2 = math.sqrt(other.a ** 2 + other.b ** 2)\n        a1, c1 = self.a / val1, self.c / val1\n        a2, c2 = other.a / val2, other.c / val2\n        if (a1 < 0) != (a2 < 0):\n            a1, a2, c1, c2 = a1, -a2, c1, -c2\n        return a1 == a2 and c1 == c2\n\n    def perpendicular(self, point: Pt):\n        return Straight(-self.b, self.a, self.b * point.x - self.a * point.y)\n\n    def get_value(self, point):\n        return self.a * point.x + self.b * point.y + self.c\n\n    def is_own(self, point: Pt):\n        return self.get_value(point) == 0\n\n    def same_side(self, pt1, pt2):\n        return (self.get_value(pt1) < 0) == (self.get_value(pt2) < 0)\n\n    def intersection(self, other):\n        d = Pt(self.a, self.b).cross(Pt(other.a, other.b))\n        dx = Pt(self.c, self.b).cross(Pt(other.c, other.b))\n        dy = Pt(self.a, self.c).cross(Pt(other.a, other.c))\n        return Pt(-dx / d, -dy / d)\n\n    def dist_from_point(self, point):\n        val = math.sqrt(self.a ** 2 + self.b ** 2)\n        return abs(Straight(self.a / val, self.b / val, self.c / val).get_value(point))\n\n    def parallel(self, dist):\n        val = math.sqrt(self.a ** 2 + self.b ** 2)\n        return Straight(self.a, self.b, self.c - dist * val)\n\n    def is_parallel(self, other):\n        return self.a * other.b == self.b * other.a\n\n    def is_perpendicular(self, other):\n        per = Straight(-self.b, self.a, 0)\n        return per.a * other.b == per.b * other.a\n\n\nn = int(input())\npoints = [Pt(input()) for _ in range(n)]\nstraights = []\nfor i in range(n):\n    for j in range(i + 1, n):\n        st = Straight(points[i], points[j])\n        ok = True\n        for x in straights:\n            if st == x:\n                ok = False\n                break\n        if ok:\n            straights.append(st)\nres = 0\nm = len(straights)\nfor i in range(m):\n    for j in range(i + 1, m):\n        if not straights[i].is_parallel(straights[j]):\n            res += 1\nprint(res)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nW=[list(map(int,input().split())) for i in range(n)]\n\nSET=set()\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef point(a,b,c,d):\n    g=gcd(c-a,d-b)\n    K=[(c-a)//g,(d-b)//g]\n\n    if K==[0,1]:\n        SET.add(tuple(K+[a]))\n\n    else:\n        SET.add(tuple(K+[((d-b)*(-a)+(c-a)*b)/(c-a)]))    \n\nfor i in range(n-1):\n    a,b=W[i]\n    for j in range(i+1,n):\n        if i==j:\n            continue\n        c,d=W[j]\n\n        point(a,b,c,d)\n\n#print(SET)\nLIST=list(SET)\nANS=0\nfor i in range(len(LIST)-1):\n    NOW0,NOW1=LIST[i][0],LIST[i][1]\n    for j in range(i+1,len(LIST)):\n        if NOW0!=LIST[j][0] or NOW1!=LIST[j][1]:\n            ANS+=1\n\nprint(ANS)\n\n        \n        \n    \n", "import itertools\nimport math\nfrom functools import reduce\nfrom math import gcd\n\n# 2d line: ax + by + c = 0  is  (a, b, c)\n\n#          ax + by + c = 0     ((a, b, c),\n# 3d line: dx + ez + f = 0  is  (d, e, f),\n#          gy + hz + i = 0      (g, h, i))\n\ngcdm = lambda *args: reduce(gcd, args, 0)\n\n\ndef pointsToLine2d(p1, p2):\n    if p1 == p2:\n        return (0, 0, 0)\n    _p1, _p2 = sorted((p1, p2))\n\n    g = gcdm(*[x for x in (_p2[1] - _p1[1], _p1[0] - _p2[0], _p1[1] * _p2[0] - _p1[0] * _p2[1]) if x != 0])\n\n    return ((_p2[1] - _p1[1]) // g, (_p1[0] - _p2[0]) // g, (_p1[1] * _p2[0] - _p1[0] * _p2[1]) // g)\n\n\ndist = lambda p1, p2: sum((a - b) * (a - b) for a, b in zip(p1, p2))**0.5\n\npointsToLines = lambda p1, p2: list(map(pointsToLine2d, itertools.combinations(p1, 2), itertools.combinations(p2, 2)))\n\nareParallel = lambda l1, l2: l1[0] * l2[1] == l2[0] * l1[1]\n\nareSame = lambda l1, l2: areParallel(l1, l2) and (l1[1] * l2[2] == l2[1] * l1[2])\n\ncollinear = lambda p1, p2, p3: areSame(pointsToLine2d(p1, p2), pointsToLine2d(p2, p3))\n\nintersect = lambda l1, l2: None if areParallel(l1, l2) else ((l2[1] * l1[2] - l1[1] * l2[2]) / (l2[0] * l1[1] - l1[\n    0] * l2[1]), (l1[0] * l2[2] - l1[2] * l2[0]) / (l2[0] * l1[1] - l1[0] * l2[1]))\n\nrotate = lambda p, theta, origin=(0, 0): (origin[0] + (p[0] - origin[0]) * math.cos(theta) - (p[1] - origin[\n    1]) * math.sin(theta), origin[1] + (p[0] - origin[0]) * math.sin(theta) + (p[1] - origin[1]) * math.cos(theta))\n\n\ndef main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    n = read_int()\n    p = []\n    for _ in range(n):\n        p.append(read_int_array())\n\n    lines = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            lines.add(pointsToLine2d(p[i], p[j]))\n\n    k = len(lines)\n    import collections\n    ax_bx = collections.defaultdict(int)\n    out = 0\n    for a, b, _ in lines:\n        ax_bx[a, b] += 1\n    for x in list(ax_bx.values()):\n        out += (k - x) * x\n    write(out // 2)\n\nmain()\n", "from fractions import Fraction\nn=int(input())\nl1=[]\nd2={}\nfor i in range(0,n):\n    x,y=map(int,input().split())\n    for item in l1:\n        if x==item[0]:\n            if 'inf' not in d2:\n                d2['inf']=[x]\n            \n            elif x not in d2['inf']:\n                d2['inf'].append(x)\n        else :\n            slope=Fraction((y-item[1]),(x-item[0]))\n            c=Fraction(y,1)-slope*Fraction(x,1)\n            if slope not in d2:\n                d2[slope]=[c]\n            elif c not in d2[slope]:\n                d2[slope].append(c)\n    l1.append((x,y))\nz=0\nans=0\nf=0\nfor k in d2:\n    z+=len(d2[k])\nfor k in d2:\n    x=len(d2[k])\n    f=f+x\n    ans+=x*(z-f)\nprint(ans)", "from collections import defaultdict as dd\nfrom itertools import combinations\nimport math\nimport heapq\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\n\n\nn=nn()\n\npoints=[]\n\nfor i in range(n):\n\tpoints.append(lm())\n\n\n\nslopedict=dd(set)\nlines=0\n\nfor p1, p2 in combinations(points,2):\n\tx1,y1=p1\n\tx2,y2=p2\n\n\n\tg=math.gcd(y2-y1,x2-x1)\n\tif y2-y1<0:\n\t\tsign=-1\n\n\telif y2-y1==0:\n\t\tif x2-x1<0:\n\t\t\tsign=-1\n\t\telse:\n\n\t\t\tsign=1\n\n\telse:\n\t\tsign=1\n\tslope=(sign*(y2-y1)//g,sign*(x2-x1)//g) \n\t\n\n\tif not slope[1]==0:\n\t\tceptn=slope[1]*y1-slope[0]*x1\n\t\tceptd=slope[1]\n\n\t\tif ceptn<0:\n\t\t\tsign=-1\n\t\t\n\t\telif ceptn==0:\n\t\t\tif ceptd<0:\n\t\t\t\tsign=-1\n\t\t\telse:\n\n\t\t\t\tsign=1\n\n\t\telse:\n\t\t\tsign=1\n\t\t\n\t\tg=math.gcd(ceptn,ceptd)\n\t\tcept=(sign*ceptn/g,sign*ceptd/g)\n\telse:\n\t\tcept=x1\n\n\n\n\tif not cept in slopedict[slope]:\n\t\tslopedict[slope].add(cept)\n\t\tlines+=1\n\ntotal=0\n\n\nfor slope in slopedict:\n\n\ttotal=total+(lines-len(slopedict[slope]))*len(slopedict[slope])\n\n\nprint(total//2)\t\n\npos=math.gcd(-4,2)\nneg=math.gcd(4,-2)\n#print(pos,neg)\n\n#print(-4//pos,2//pos)\n\n#print(4//neg,-2//neg)\n\t\n\n", "from collections import defaultdict\nn = int(input())\na = []\nfor i in range(n):\n    a.append(list(map(int,input().split())))\n\nd = defaultdict(int)\ndh = defaultdict(list)\ndhs = []\ns = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        try:\n            t = (a[j][1]-a[i][1])/(a[j][0]-a[i][0])\n            if d[t]==0:\n                d[t] = 1\n                dh[t].append(i)\n                dh[t].append(j)\n            else:\n                if i not in dh[t] and j not in dh[t]:\n                    d[t]+=1\n                dh[t].append(i)\n                dh[t].append(j)\n        except:\n            if s==0:\n                s+=1\n            elif i not in dhs and j not in dhs:\n                s+=1\n            dhs.append(i)\n            dhs.append(j)\n\nt = list(d.keys())\nc = 0\nl = 0\nfor i in t:\n    k = d[i]\n    l+=k\n    c+=((k)*(k-1))//2\n\nc+=((s)*(s-1))//2\nl += s\nl = (l*(l-1))//2\nprint(l-c)\n", "def get_k(a, b):\n    x1, y1 = a\n    x2, y2 = b\n    if x2 != x1:\n        return (y2 - y1) / (x2 - x1)\n    return 10**10\n\n\ndef get_offset(a, k2):\n    x, y = a\n    return y - k2 * x\n\n\ncnt = 0\na = []\nn = int(input())\nfor i in range(n):\n    a.append(tuple(map(int, input().split())))\nalines = []\nfor i in range(n):\n    for j in range(n):\n        if i >= j: continue\n        alines.append((a[i], a[j]))\n\nlines = []\ns = set()\nfor i, l1 in enumerate(alines):\n    for j in range(i + 1, len(alines)):\n        l2 = alines[j]\n        k1, k2 = get_k(*l1), get_k(*l2)\n        o1, o2 = get_offset(l1[0], k1), get_offset(l2[0], k2)\n        if (k1 == k2 == 10**10 and l1[0][0] == l2[0][0]):\n            o1 = o2 = 0\n        if (abs(k1 - k2) < 1e-10 and abs(o1 - o2) < 1e-10) or (k1 == k2 == 10**10 and l1[0] == l2[0]):\n            s.add(j)\n    if i not in s:\n        lines.append(l1)\n\nfor i, l1 in enumerate(lines):\n    for j, l2 in enumerate(lines):\n        if i >= j:\n            continue\n        if abs(get_k(*l1) - get_k(*l2)) > 1e-10:\n            cnt += 1\nprint(cnt)\n", "from math import *\n\nclass slopeC:\n    def __init__(self):        \n        self.chil = set()\nn = int(input())\n\nslopes = {}\nL = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    \n    for l in L:\n        if x != l[0]:\n            slope = (y - l[1]) / (x - l[0])\n        else:\n            slope = inf\n            \n        s1 = str(l[0]) + '-' + str(l[1])\n        s2 = str(x) + '-' + str(y)\n        if slope not in slopes:\n            slopes[slope] = [slopeC()]\n            slopes[slope][0].chil.add(s1)\n            slopes[slope][0].chil.add(s2)\n        else:\n            f = 0\n            for child in slopes[slope]:\n                if s1 in child.chil:\n                    f = 1\n                    child.chil.add(s2)\n                    break\n            if f == 0:\n                slopes[slope] += [slopeC()]\n                slopes[slope][0].chil.add(s1)\n                slopes[slope][0].chil.add(s2)\n        \n    L += [[x, y]]\nA = []\nP = [0]\nfor s in slopes:\n    A += [(len(slopes[s]))]\n    P += [P[-1] + A[-1]]\n    \nans = 0\n\n\nfor i, v in enumerate(A):\n    ans += A[i] * (P[-1] - P[i+1])\nprint(ans)\n\n\n    \n", "from math import gcd\n\nn = int(input())\nP = [[int(x) for x in input().split()] for _ in range(n)]\n\nL = []\ndef addLine(x,y,dx,dy):\n    if dx < 0:\n        dx *= -1\n        dy *= -1\n    elif dx == 0:\n        if dy < 0:\n            dy *= -1\n    g = gcd(dx,dy)\n    dx //= g\n    dy //= g\n\n    x += dx * (10**9)\n    y += dy * (10**9)\n    if dx:\n        k = x//dx\n    else:\n        k = y//dy\n    x -= k*dx\n    y -= k*dy\n    L.append((x,y,dx,dy))\n\n\nfor i in range(n):\n    for j in range(i+1,n):\n        xi,yi = P[i]\n        xj,yj = P[j]\n        dx,dy = xi-xj,yi-yj\n        addLine(xi,yi,dx,dy)\n\nL = list(set(L))\nres = 0\nfor i in range(len(L)):\n    for j in range(i+1, len(L)):\n        x1,y1,dx1,dy1 = L[i]\n        x2,y2,dx2,dy2 = L[j]\n        if dx1 != dx2 or dy1 != dy2:\n            #print(L[i])\n            #print(L[j])\n            #print('---')\n            res += 1\n\nprint(res)\n\n\n\n\n\n\n", "from collections import Counter\nN = int(input())\nif N == 2:\n    print(0)\n    return\ninf = 10**9+7\ninf2 = 10**18\ndef gcdl(A):\n    if len(A) == 0:\n        return -1\n    if len(A) == 1:\n        return 0\n    g = gcd(A[0], A[1])\n    for a in A[2:]:\n        g = gcd(a, g)\n    return g\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b,a%b)\nPoint = []\nans = 0\nfor _ in range(N):\n    Point.append(list(map(int, input().split())))\nS = Counter()\nT = set()\nfor i in range(N):\n    x1 , y1 = Point[i]\n    for j in range(N):\n        if i == j:\n            continue\n        x2 , y2 = Point[j]\n        a = y1 - y2\n        b = -(x1 - x2)\n        c = x2*y1 - x1*y2\n        g = gcdl([a, b, c])\n        a //= g\n        b //= g\n        c //= g\n        if a < 0:\n            a *= -1\n            b *= -1\n            c *= -1\n        k = a*inf+b*inf2+c\n        if k not in T:\n            T.add(a*inf+b*inf2+c)\n            if x1 == x2:\n                S[-1] += 1\n            else:\n                y = y1 - y2\n                x = x1 - x2\n                g = gcd(y, x)\n                y //= g\n                x //= g\n                if y < 0:\n                    y *= -1\n                    x *= -1\n                S[y*inf+x] += 1\nL = len(T)\nans = L*(L-1)//2\nfor s in S.values():\n    ans -= s*(s-1)//2\nprint(ans)", "from fractions import Fraction\nfrom math import inf\n\nn = int(input())\ncoords = []\nfor i in range(n):\n    x, y = [int(c) for c in input().split(\" \")]\n    coords.append((x, y))\n\ntangents = {}\nfor i1 in range(n):\n    for i2 in range(i1+1, n):\n        x1, y1 = coords[i1]\n        x2, y2 = coords[i2]\n        if x2 == x1:\n            tangent = inf\n            offset = x1\n        else:\n            tangent = Fraction(y2-y1, x2-x1)\n            offset = - tangent * x1 + y1\n\n        if tangent not in tangents: tangents[tangent] = set()\n        tangents[tangent].add(offset)\n\ntangentlen = {}\nfor tangent in tangents: tangentlen[tangent] = len(tangents[tangent])\n\nsumm = 0\nfor tangent in tangents: summ += tangentlen[tangent]\n\nanswer = 0\nfor t1 in tangents:\n    answer += tangentlen[t1] * (summ - tangentlen[t1])\nprint(answer // 2)\n", "n = int(input())\nl = set()\ns = [list(map(int, input().split())) for _ in range(n)]\nfor i in range(n):\n        for j in range(i+1, n):\n                x1, y1 = s[i]\n                x2, y2 = s[j]\n                if x1==x2: \n                        l.add((float('INF'), x1))\n                else:\n                        a = (y1-y2)/(x1-x2)\n                        b = (x1*y2-x2*y1)/(x1-x2)\n                        l.add((a, b))\nlis = [i[0] for i in l]\nfrom collections import Counter\ndic = Counter(lis)\nr = len(l)**2 - len(l)\nfor i in dic:\n        r -= dic[i]**2-dic[i]\nprint(r//2)\n", "from random import random\nfrom collections import defaultdict\nfrom fractions import Fraction\nimport math\nimport re\nimport fractions\n\nN = int(input())\nlines = defaultdict(set)\npoles = []\nfor _ in range(N):\n    x, y = list(map(int, input().split(\" \")))\n    for xx, yy in poles:\n      if yy - y == 0:\n        slope = Fraction(10**6, 1)\n        const = y\n      else:\n        slope = Fraction(xx - x, yy - y)\n        const = x - (slope * y)\n      lines[slope].add(const)\n    poles.append((x, y))\n\nresult = 0\nvisited = 0\n# print(lines)\nfor slope in lines:\n  result += visited * len(lines[slope])\n  visited += len(lines[slope])\nprint(result)\n    \n", "n = int(input())\nls = set()\npts = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    pts.append([x, y])\nfor i in range(n):\n    for j in range(i + 1, n):\n        x1 = pts[i][0]\n        y1 = pts[i][1]\n        x2 = pts[j][0]\n        y2 = pts[j][1]\n        m = (y2 - y1) / (x2 - x1) if x2 != x1 else 'I'\n        c = (x2 * y1 - x1 * y2) / (x2 - x1) if x1 != x2 else x1\n        ls.add((m, c))\nins = set()\nls = list(ls)\nnls = len(ls)\nfor i in range(nls):\n    for j in range(i + 1, nls):\n        m1 = ls[i][0]\n        m2 = ls[j][0]\n        if m1 != m2:\n            x = [i, j]\n            x.sort()\n            ins.add(tuple(x))\nprint(len(ins))\n\n", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n\nn = int(input())\np = [0] * n\nfor i in range(n):\n    p[i] = [int(item) for item in input().split()]\n\nwires = set()\n\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        x0, y0 = p[i]\n        x1, y1 = p[j]\n        a = -(y1 - y0)\n        b = (x1 - x0)\n        c = x0 * (y1 - y0) - y0 * (x1 - x0)\n        k = gcd(a, gcd(b, c))\n        a //= k\n        b //= k\n        c //= k\n        if a < 0:\n            a *= -1\n            b *= -1\n            c *= -1\n        wires.add((a, b, c))\n\nwires = list(wires)\n\nans = 0\n# print(wires)\nfor i in range(len(wires)):\n    for j in range(i + 1, len(wires)):\n        a1, b1, c1 = wires[i]\n        a2, b2, c2 = wires[j]\n        if b1 == 0:\n            if b2 != 0:\n                ans += 1\n        elif b2 == 0:\n            ans += 1\n        else:\n            if abs(a1 / b1 - a2 / b2) > 1e-7:\n                ans += 1\n\nprint(ans)\n", "n = int(input())\n\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\n\npoles = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    poles.append((x, y))\n\nlines = set()\nfor i in range(len(poles) - 1):\n    for j in range(i + 1, len(poles)):\n        p1 = poles[i]\n        p2 = poles[j]\n        a = p1[1] - p2[1]\n        b = - p1[0] + p2[0]\n        abg = gcd(abs(a), abs(b))\n        if abg > 0:\n            a //= abg\n            b //= abg\n        if a < 0:\n            a = -a\n            b = -b\n        if a == 0:\n            b = 1\n        if b == 0:\n            a = 1\n        c = - a * p1[0] - b * p1[1]\n        lines.add((a, b, c))\n        # print(a, b, c)\n\n        # lines.append((p1, p2))\n\n# points = set()\ncnt = 0\nfor i, line1 in enumerate(lines):\n    for j, line2 in enumerate(lines):\n        if i >= j:\n            continue\n        # print(i, j)\n\n        if line1[:2] != line2[:2]:\n            cnt += 1\n\n        # ap1 = line1[0]\n        # ap2 = line1[1]\n        # bp1 = line2[0]\n        # bp2 = line2[1]\n        #\n        # under = (bp2[1] - bp1[1]) * (ap2[0] - ap1[0]) - (bp2[0] - bp1[0]) * (ap2[1] - ap1[1])\n        # if under == 0:\n        #     continue\n        #\n        # t = (bp2[0] - bp1[0]) * (ap1[1] - bp1[1]) - (bp2[1] - bp1[1]) * (ap1[0] - bp1[0])\n        # s = (ap2[0] - ap1[0]) * (ap1[1] - bp1[1]) - (ap2[1] - ap1[1]) * (ap1[0] - bp1[0])\n        #\n        # if t < 0 or t > under or s < 0 or s > under:\n        #     continue\n        #\n        # if t == 0 and s == 0:\n        #     continue\n        #\n        # print('add')\n        # cnt += 1\n\n        # x = [ap1[0] * under + t * (ap2[0] - ap1[0]), under]\n        # y = [ap1[1] * under + t * (ap2[1] - ap1[1]), under]\n        # xg = gcd(x[0], x[1])\n        # if xg > 0:\n        #     x[0] //= xg\n        #     x[1] //= xg\n        # yg = gcd(y[0], y[1])\n        # if yg > 0:\n        #     y[0] //= yg\n        #     y[1] //= yg\n        # if under < 0:\n        #     x[0] = -x[0]\n        #     x[1] = -x[1]\n        #     y[0] = -y[0]\n        #     y[1] = -y[1]\n        #\n        # x = tuple(x)\n        # y = tuple(y)\n        # p = (x, y)\n        #\n        #\n        #\n\nprint(cnt)\n", "#!/usr/local/bin/python3.5 -tt\n\nimport random\nimport sys\n\nfrom fractions import Fraction, gcd\n\nINF = 10 ** 9\n\ndef __starting_point():\n    def _(f):\n        for l in f:\n            for i in l.split():\n                yield int(i)\n\n    g = _(sys.stdin)\n\n    n = next(g)\n\n    pts = []\n\n    for i in range(n):\n        x, y = (next(g),\n                next(g),\n                )\n\n        pts.append((x, y))\n\n    lines = set()\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            x0, y0, x1, y1 = (pts[i][0],\n                              pts[i][1],\n                              pts[j][0],\n                              pts[j][1],\n                              )\n                              \n            dx, dy = (x1 - x0,\n                      y1 - y0,\n                      )\n\n            g = gcd(dx, dy)\n\n            dx //= g\n            dy //= g\n\n            if dx:\n                a = Fraction(dy, dx)\n\n                b = - Fraction(dy * x0, dx) + y0\n            else:\n                a, b = (INF,\n                        x0,\n                        )\n\n            lines.add((a, b))\n\n    a = list(lines)\n\n    size = len(lines)\n    \n    c = 0\n\n    for i in range(size):\n        for j in range(i + 1, size):\n            if a[i][0] == a[j][0]:\n                continue\n\n            c += 1\n\n    print(c)\n\n__starting_point()", "n=int(input().strip())\nnum=[]\nfor k in range(n):\n    num.append(list(map(int,input().strip().split())))\nd={}\nimport math\nfor k in range(n):\n    for kk in range(k+1,n):\n        a=num[k]\n        b=num[kk]\n        if(a[0]==b[0]):\n            if((100000,100000) in d.keys()):\n                d[(100000,100000)].add(a[0])\n            else:\n                d[(100000, 100000)]={a[0]}\n        elif(a[1]==b[1]):\n            if(0,1) in d.keys():\n                d[(0,1)].add(a[1])\n            else:\n                d[(0,1)]={a[1]}\n        else:\n            c=b[1]-a[1]\n            dd=b[0]-a[0]\n            q=math.gcd(c,dd)\n            c1=c//q\n            d1=dd//q\n            r=(a[0]*b[1])-(a[1]*b[0])\n            if(r!=0):\n                rr=math.gcd(r,dd)\n                r=r//rr\n                d2=dd//rr\n                if(d2<0):\n                    d2=-d2\n                    r=-r\n                if(d1<0):\n                    d1=-d1\n                    c1=-c1\n                if((c1,d1) in d.keys() ):\n                    d[(c1,d1)].add((r,d2))\n                else:\n                    d[(c1,d1)]={(r,d2)}\n            else:\n                if (d1 < 0):\n                    d1 = -d1\n                    c1 = -c1\n                if ((c1, d1) in d.keys()):\n                    d[(c1, d1)].add((0,1))\n                else:\n                    d[(c1, d1)] = {(0,1)}\ns=0\nfor i in d.keys():\n    s=s+(len(d[i]))\nss=0\nfor i in d.keys():\n    s=s-(len(d[i]))\n    ss=ss+(s*len(d[i]))\nprint(ss)", "from fractions import Fraction\nfrom collections import Counter\nn = int(input())\n\np = []\n\nlines = set()\nc= Counter()\nfor _ in range(n):\n    x, y = list(map(int, input().split()))\n    p.append((x, y))\n\n\nfor i in range(n-1):\n    for j in range(i+1, n):\n        try:\n            l = (\n                    Fraction(p[i][1]-p[j][1], p[i][0] - p[j][0]),\n                    Fraction(p[j][1]*p[i][0] - p[i][1]*p[j][0], p[i][0]-p[j][0])\n                )\n        except ZeroDivisionError:\n            l = ('i', p[i][0])\n        if l not in lines:\n            lines.add(l)\n            c[l[0]] += 1\n\n#print(lines)\n#print(c)\n#print(len(lines))\n\nt = 0\n\ntt = len(lines)\nfor l in lines:\n    t += tt - c[l[0]]\n\n\n\nprint(t // 2)\n", "n=int(input())\ncoords=[]\nfor i in range(n):\n    coords.append(tuple(map(int,input().split())))\nslopes={}\nfor i in range(n):\n    for j in range(i+1,n):\n        x1,y1=coords[i][0],coords[i][1]\n        x2,y2=coords[j][0],coords[j][1]\n        if x1==x2:\n            slope=\"inf\"\n            mark=x1\n        else:\n            slope=round((y2-y1)/(x2-x1),12)\n            mark=round(y1-x1*slope,7)\n        if slope in slopes:\n            slopes[slope].add(mark)\n        else:\n            slopes[slope]={mark}\ntot=sum(len(slopes[guy]) for guy in slopes)\nsumi=0\nfor guy in slopes:\n    a=len(slopes[guy])\n    sumi+=a*(tot-a)\nprint(sumi//2)", "n = int(input())\n\nx = []\ny = []\n\nlineas = set()\nlineas1 = set()\nlineas2 = set()\n\ncaca = dict()\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\treturn gcd(b, a%b)\n\nfor i in range(n):\n\ta, b = map(int, input().split())\n\tx.append(a)\n\ty.append(b)\n\tfor j in range(i):\n\t\ta1 = a-x[j]\n\t\tb1 = b-y[j]\n\n\t\tp1 = max(abs(a1), abs(b1))\n\t\tp2 = min(abs(a1), abs(b1))\n\t\tg = gcd(p1, p2)\n\t\ta1 = int(a1/g)\n\t\tb1 = int(b1/g)\n\t\tif a1 < 0:\n\t\t\ta1 *= -1\n\t\t\tb1 *= -1\n\n\t\taux = (b*a1)-(a*b1)\n\n\t\tif a1 == 0:\n\t\t\tlineas1.add(a)\n\t\telif b1 == 0:\n\t\t\tlineas2.add(b)\n\t\telse:\n\t\t\tif (a1, b1) in caca:\n\t\t\t\tcaca[(a1, b1)].add(aux)\n\t\t\telse:\n\t\t\t\tcaca[(a1, b1)] = set()\n\t\t\t\tcaca[(a1, b1)].add(aux)\n\t\t\tlineas.add((a1, b1, aux))\n\nsol = 0\naux = len(lineas)\nsol += int(aux*(aux-1)/2)\nsol += aux*(len(lineas1)+len(lineas2))\nsol += len(lineas1)*len(lineas2)\nfor a in caca.keys():\n\taux = len(caca[a])\n\t#print(a, caca[a], aux)\n\tsol -= int(aux*(aux-1)/2)\nprint(sol)", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval,stdin,setrecursionlimit\nsetcheckinterval(1000)\nsetrecursionlimit(10**6)\n\n#print(\"Case #{}: {} {}\".format(i, n + m, n * m))\n\niin=lambda :int(stdin.readline())\nlin=lambda :list(map(int,stdin.readline().split()))\n\n\nfrom fractions import gcd\nn=iin()\npoints=[lin() for i in range(n)]\nans=set()\nfor i in range(n):\n    x1,y1=points[i]\n    for j in range(i+1,n):\n        x2,y2=points[j]\n        a,b,c=y1-y2,x2-x1,y1*(x1-x2)-x1*(y1-y2)\n        g=gcd(gcd(a,b),c) if c else gcd(a,b)\n\n        ans.add((a//g,b//g,c//g))\nintersections=set()\nla=list(ans)\nl=len(la)\nfor i in range(l):\n    a,b,c=la[i]\n    for j in range(i+1,l):\n        try:\n            e,d,f=la[j]\n            y=(a*f-c*e)/(b*e-a*d)\n            x=(c*d-b*f)/(b*e-a*d)\n            intersections.add((i,j))\n        except:\n            pass\n#print(intersections,ans,sep='\\n')\nprint(len(intersections))", "\n# stdin=open('input.txt')\n\n# def input():\n# \treturn stdin.readline()[:-1]\n\n'''\nstdout=open('output.txt',mode='w+')\ndef print(x,end='\\n'):\n\tstdout.write(str(x)+end)\n'''\n#map(int, input().split())\n\n# CODE BEGINS HERE.................\n\n\n\nimport math\nn = int(input())\n\npoints = []\nlines = set([])\n\nfor i in range(n):\n\tx, y = list(map(int, input().split()))\n\tpoints.append((x, y))\n\nfor i in range(n):\n\tfor j in range(i):\n\t\tif points[i][0] - points[j][0] == 0:\n\t\t\tlines.add((math.inf, points[i][0]))\n\t\telse:\n\t\t\tm = (points[i][1] - points[j][1])/(points[i][0] - points[j][0])\n\t\t\tlines.add((m, round(-1 * m * points[i][0] + points[i][1], 3)))\n\nlines = list(lines)\n\n\nm = {}\n\nfor i in lines:\n\tif i[0] in m:\n\t\tm[i[0]] += 1\n\telse:\n\t\tm[i[0]] = 1\n# print(m)\n\ncount = 0\n\nm_ = sum(m.values())\ncount = m_*(m_ - 1)//2\n\nfor i in m:\n\tcount -= m[i]*(m[i] - 1)//2\n\n\n\nprint(count)\n\n#CODE ENDS HERE....................\n\n#stdout.close()\n\n"]
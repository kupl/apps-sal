["def main():\n    from math import sqrt\n    m, n, k = list(map(int, input().split()))\n    if n < m:\n        n, m = m, n\n    lo, hi = 1, k + 1\n    while lo + 1 < hi:\n        mid = (lo + hi) // 2\n        t = mid - 1\n        v = min(int(sqrt(t)), m)\n        tn, tm = (t - 1) // m, t // n\n        vv = [t // i for i in range(tm + 1, v + 1)]\n        if t // n * (n + m) + sum(vv) * 2 + max(min((tn - tm), len(vv)) * m, 0) - v * v - sum(\n                vv[:max(min(tn - tm, len(vv)), 0)]) < k:\n            lo = mid\n        else:\n            hi = mid\n    print(lo)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\n\nn, m, k = [int(x) for x in stdin.readline().split()]\nbe, en = 1, k + 1\n\nwhile be < en:\n    mid = (be + en + 1) >> 1\n    be1, cur = (mid + m - 1) // m, 0\n    for i in range(1, be1):\n        cur += m\n\n    for i in range(be1, n + 1):\n        cur += (mid - 1) // i\n\n    if cur <= k - 1:\n        be = mid\n    else:\n        en = mid - 1\n\nprint(be)\n", "def works(X,N,M,K):\n    #in each row, how many numbers are < X\n    res = 0\n    n = 1\n    div = X/M\n    while n < div:\n        res += M\n        n += 1\n    while n < N+1:\n        res += (X-1)//n\n        n += 1\n    return res\n\ndef solve():\n    N, M, K = [int(s) for s in input().split()]\n    left = 1\n    right = K+1\n    #we want the smallest smallest such that there are AT LEAST K-1 smaller numbers\n    while right - left > 1:\n        middle = (left+right)//2\n        if works(middle,N,M,K) < K:\n            left = middle\n        else:\n            right = middle\n    #if there are exactly K-1 elements less than right, then this is our answer\n    return left\n\n#for _ in range(getInt()):    \nprint(solve())"]
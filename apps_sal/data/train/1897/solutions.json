["from itertools import accumulate\nclass Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xors = [0]\n        for a in arr:\n            xors.append(a^xors[-1])\n        return [xors[i]^xors[j+1] for i,j in queries]\n    \n", "\n'''\nx ^ y = z\n\n0 ^ 1 = 1\n1 ^ 0 = 1\n0 ^ 0 = 0\n1 ^ 1 = 0\n\n\u9006\u63a8\uff1a\nz   y   x\n1   1 = 0\n1   0 = 1\n0   0 = 0\n0   1 = 1\n\n\u53ef\u89c1\uff0c\u4ecd\u662f\u5f02\u6216\u3002\u8ba1\u7b97\u524d\u7f00\u5373\u53ef\n'''\n\nclass Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(arr)\n        prefix_xor = [0] * n\n        prefix_xor[0] = arr[0]\n        for i in range(1, n):\n            prefix_xor[i] = prefix_xor[i - 1] ^ arr[i]\n        ret = []\n        for start, end in queries:\n            if start == 0:\n                ret.append(prefix_xor[end])\n            else:\n                ret.append(prefix_xor[start - 1] ^ prefix_xor[end])\n        return ret\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        \n        prefix = []\n        curr = 0\n        for n in arr:\n            curr ^= n\n            prefix.append(curr)\n            \n        res = []\n        for l, r in queries:\n            if l == 0:\n                res.append(prefix[r])\n            else:\n                res.append(prefix[r] ^ prefix[l-1])\n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        result =[]\n        prefixArr = [0] * len(arr)\n        prefixArr[0] = arr[0]\n        for i in range(1, len(arr)):\n            prefixArr[i] = prefixArr[i-1] ^ arr[i]\n        \n        for j in range(len(queries)):\n            start = queries[j][0]\n            end = queries[j][1]\n            \n            if start == 0: result.append(prefixArr[end])\n            else: result.append(prefixArr[start - 1] ^ prefixArr[end] )\n        \n        return result     \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        lx=[arr[0]]\n        for i in range(1,len(arr)):\n            lx.append(lx[i-1]^arr[i])\n        return([lx[i[1]] if i[0]==0 else (lx[i[0]-1]^lx[i[1]]) for i in queries])\n    \n    \n#         for i in queries:\n#             if i[0]==0:\n#                 ls.append(lx[i[1]])\n#             else:\n#                 ls.append(lx[i[0]-1]^lx[i[1]])\n                \n        # return ls\n", "class Solution:\n    def xorQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(A) - 1):\n            A[i + 1] ^= A[i]\n        return [A[j] ^ A[i - 1] if i else A[j] for i, j in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        dp=[0]*len(arr)\n        dp[0] = arr[0]\n        for i in range(1,len(arr)):\n            dp[i] = dp[i-1]^arr[i]\n        #print(dp)   \n        res = []\n        for i in range(len(queries)):\n            \n            if queries[i][0]>0:\n                res.append(dp[queries[i][0]-1]^dp[queries[i][1]])\n            else:\n                res.append(dp[queries[i][1]])\n                \n        return res\n            \n            \n            \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i - 1]\n        result = []\n        for x, y in queries:\n            if x == 0:\n                result.append(arr[y])\n            else:\n                result.append(arr[y] ^ arr[x - 1])\n        return result\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix_sum = [arr[0]]\n        \n        for i in range(1, len(arr)):\n            prefix_sum.append(prefix_sum[-1] ^ arr[i])\n        \n        result = []\n        \n        for l, r in queries:\n            result.append(prefix_sum[r])\n            if l > 0:\n                result[-1] ^= prefix_sum[l - 1]\n        \n        return result", "class Solution:\n#     def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n#         ans = []\n#         pool = dict()\n#         for r in queries:\n#             if tuple(r) in pool:\n#                 ans.append(pool[tuple(r)])\n#             else:\n#                 pool[tuple(r)] = reduce(lambda x,y: x^y, arr[r[0]:r[1]+1])\n#                 ans.append(pool[tuple(r)])\n#         return ans\n    \n    # fact: xor[i,j] = xor[0,i] ^ xor[0,j]\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        ans = []\n        # prefix the arr\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i-1]\n        return [arr[j] ^ arr[i-1] if i > 0 else arr[j] for i, j in queries]\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        if len(arr)==1:\n            return [arr[0] for i in queries]\n        \n        table = [arr[0]]*len(arr)\n        for i in range(1,len(arr)):\n            table[i] = table[i-1] ^ arr[i] \n        '''\n        print(table)\n        print(arr[0])\n        print(arr[0]^arr[1])\n        print(arr[0]^arr[1]^arr[2])\n        print(arr[0]^arr[1]^arr[2]^arr[3\n        '''\n        \n        '''\n        table = [out]*len(arr)\n        for i in range(1,len(arr)):\n            for j in range(i,len(arr)):\n                table[i][j] = table[i-1][j] ^ arr[j]\n        '''\n        out = [0]*len(queries)\n        for i,(l,r) in enumerate(queries):\n            #print(f'i:{i}, l:{l}, r:{r}')\n            if l>0:\n                out[i] = table[l-1] ^ table[r] \n            else:\n                out[i] = table[r]\n            \n        return out", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xorarr = [0]\n        for n in arr:\n            xorarr.append(xorarr[-1]^n)\n        \n        res = []\n        for i, j in queries:\n            res.append(xorarr[j+1]^xorarr[i])\n        \n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xors = [arr[0]]\n        \n        n = len(arr)\n        for i in range(1, n):\n            xors.append(xors[-1] ^ arr[i])\n        \n        res = []\n        for query in queries:\n            l, r = query\n            temp = xors[r]\n            if l != 0:\n                temp ^= xors[l - 1]\n            res.append(temp)\n        \n        return res\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xors = []\n        xoraccum = 0\n        for n in arr:\n            xoraccum^=n\n            xors.append(xoraccum)\n        ret = []\n        for query in queries:\n            l, r = query[0], query[1]\n            rxor = xors[r]\n            lxor = 0 if l == 0 else xors[l-1]\n            ret.append(rxor^lxor)\n        return ret", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        a=0;n=len(arr)\n        for i in range(n):\n            a^=arr[i]\n            arr[i]=a\n        ans=[]\n        for i,j in queries:\n            if i==0:\n\n                ans.append(arr[j])\n            else:\n                ans.append(arr[j]^arr[i-1])\n        return ans\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        x = 0\n        xors = []\n        for i in arr:\n            x ^= i\n            xors.append(x)\n        return [xors[i[1]]^xors[i[0]]^arr[i[0]] for i in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        if len(arr) == 0:\n            return []\n        \n        xor_arr = [0 for i in range(len(arr))]\n        for index, v in enumerate(arr):\n            if index == 0:\n                xor_arr[index] = arr[index]\n            else:\n                xor_arr[index] = xor_arr[index - 1] ^ arr[index]\n        results = [0 for i in range(len(queries))]\n        for index, query in enumerate(queries):\n            start = query[0]\n            end = query[1]\n            if start == 0:\n                results[index] = xor_arr[end]\n            else:\n                results[index] = xor_arr[end] ^ xor_arr[start - 1]\n        return results", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(arr)-1):\n            arr[i+1] ^= arr[i]\n        \n        res = []\n        for i,j in queries:\n            if i == 0:\n                res.append(arr[j])\n            else:\n                res.append(arr[i-1]^arr[j])\n        return res\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        #use extra array to store the information\n        prefix=[0]*len(arr)\n        prefix[0]=arr[0]\n        for i in range(1,len(arr)):\n            prefix[i]=prefix[i-1]^arr[i]\n        ans=[]\n        for query in queries:\n            start=query[0]\n            end=query[1]\n            if start==0:\n                ans.append(prefix[end])\n            else:\n                ans.append(prefix[start-1]^prefix[end])\n                \n        return ans", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        n = len(arr)\n        prefix = [0 for _ in range(n+1)]\n        for i in range(n):\n                prefix[i+1] = prefix[i]^arr[i]\n        res = []\n        print(prefix)\n        for l, r in queries:\n                print((l, r))\n                res.append(prefix[r+1]^prefix[l])\n                \n        return res\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        cumArr = []\n        resultArr = []\n        for index in range(len(arr)):\n            if(index == 0):\n                cumArr.insert(index,arr[index])\n            else:\n                cumArr.insert(index,arr[index]^cumArr[index-1])\n        for query in queries:\n            left = query[0]\n            right = query[1]    \n            if(left is not 0):\n                resultArr.append(cumArr[right]^cumArr[left-1])\n            else:\n                resultArr.append(cumArr[right])\n        return resultArr        ", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(arr)\n        ans = []\n        \n        \n        prefix=[0]*n\n        prefix[0] = arr[0]\n        \n        for i in range(1,n):\n            \n            prefix[i] = prefix[i-1]^arr[i]\n        for q in queries:\n            l,r = q\n            if l==0:\n                ans.append(prefix[r])\n            else:\n                ans.append(prefix[r]^prefix[l-1])\n        return ans\n        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        \n        n = len(arr)\n        precompute = []\n        \n        xor = 0\n        for num in arr:\n            xor ^= num\n            precompute.append(xor)\n        \n        ans = []\n        for s, e in queries:\n            if s == 0:\n                ans += [precompute[e]]\n            else:\n                ans += [precompute[e] ^ precompute[s-1]]\n        \n        return ans\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix = [arr[0]]\n        for i in range(1,len(arr)):\n            prefix.append(prefix[-1]^arr[i])\n        result = []\n        for s,e in queries:\n            if s == 0:\n                result.append(prefix[e])\n            else:\n                result.append(prefix[e]^prefix[s-1])\n        return result", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n            xored = [None] * len(arr)\n            ans = [None] * len(queries)\n\n            # construct the array xored = [arr[0],                arr[0]^arr[1],...,arr[0]^arr[1]^...^arr[i]^...^arr[n] ] of comulative xored elements of arr\n            xored[0] = arr[0]\n            for i in range(1,len(arr)):\n                xored[i] = xored[i-1]^arr[i]\n\n            # now, because of the XOR property of x^x=0 and its distributive natur we get xored[L-1]^xored[R] = arr[0]^...^.arr[L-1]^arr[0]^...^arr[R]=arr[L]^...^arr[R] as required \n            # (unless L==0 then the answer is simply xored[R])\n            for i in range(len(queries)):\n                L = queries[i][0]\n                R = queries[i][1]\n                if L > 0:\n                    ans[i] = xored[L-1]^xored[R]\n                else: \n                    ans[i] = xored[R]\n            return ans        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        arr.insert(0, 0)\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i-1]\n        return [arr[a] ^ arr[b+1] for a, b in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i - 1]\n        ret = []\n        for l, r in queries:\n            ret.append(arr[r] if l == 0 else arr[r] ^ arr[l - 1])\n        return ret", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        ans=[]\n        ht=[arr[0]]\n        for i in range(1,len(arr)):\n            ht.append(ht[-1]^arr[i])\n        \n        for i,j in queries:\n            ans.append(ht[j]^(ht[i-1] if i>0 else 0))\n        return ans", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        acc = [0]\n        for i in range(len(arr)):\n            acc.append(acc[i]^arr[i])\n        result = []\n        for q in queries:\n            result.append(acc[q[0]]^acc[q[1]+1])\n        return result", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        pre_xor = [0]\n        size_arr=len(arr)\n        if size_arr%2==0:\n            for i in range (0,size_arr,2):\n                pre_xor.append(pre_xor[i]^arr[i])\n                pre_xor.append(pre_xor[i+1]^arr[i+1])\n        else:\n            pre_xor.append(pre_xor[0]^arr[0])\n            for i in range (1,size_arr,2):\n                pre_xor.append(pre_xor[i]^arr[i])\n                pre_xor.append(pre_xor[i+1]^arr[i+1])\n                \n                \n            \n            \n\n        out_xor = []\n        for L, R in queries:\n            out_xor.append(pre_xor[L]^pre_xor[R+1])\n        return out_xor\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(1, len(arr)):\n            arr[i] ^= arr[i-1]\n        \n        res = []\n        for q in queries:\n            res.append(arr[q[1]] ^ (0 if q[0] <= 0 else arr[q[0]-1]))\n        return res", "class Solution:\n    def xorQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(A) - 1):\n            A[i + 1] ^= A[i]\n    # prefix  xor\n        return [A[j] ^ A[i - 1] if i else A[j] for i, j in queries] \n    # if i == 0  then a[j]\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(arr) - 1):\n            arr[i + 1] ^= arr[i]\n        return [arr[j] ^ arr[i - 1] if i else arr[j] for i, j in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        a=arr\n        q=queries\n        l=[]\n        for i in range(len(a)-1):\n            a[i+1]^=a[i]\n        print(a)\n        for i,j in q:\n            if i:\n                l.append(a[j]^a[i-1])\n            else:\n                l.append(a[j])\n        return (l)", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        # result=[]\n        # for i in range(len(queries)):\n        #     start=queries[i][0]\n        #     end=queries[i][1];val=arr[start]\n        #     while start != end+1:\n        #         if start!=end:\n        #             val=val^arr[start+1]\n        #             start+=1\n        #         else:\n        #             result.append(val)\n        #             break\n        # return result\n                    \n        prefix = [None]*len(arr)\n        res = [None]*len(queries)\n        prefix[0]=arr[0]\n        for i in range(1,len(arr)):\n            prefix[i]=prefix[i-1]^arr[i]\n        for i in range(len(queries)):\n            if queries[i][0]==0:\n                res[i]=prefix[queries[i][1]]\n                continue\n            res[i]=prefix[queries[i][1]]^prefix[queries[i][0]-1]\n        return res\n                \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        https://leetcode-cn.com/problems/xor-queries-of-a-subarray/solution/zi-shu-zu-yi-huo-cha-xun-by-leetcode-solution/\n        * pre[0] = 0\n          pre[i] = arr[0] ^ arr[1] ^ ... ^ arr[i - 1]\n          arr[Li] ^ ... ^ arr[Ri] = pre[Li] ^ pre[Ri + 1]\n        \\\"\\\"\\\"\n        # pre = [0]\n        # for num in arr:\n        #     pre.append(pre[-1] ^ num)\n        # ans = list()\n        # for x, y in queries:\n        #     ans.append(pre[x] ^ pre[y + 1])\n        # return ans\n    \n        # for i in range(len(arr) - 1):\n        #     arr[i + 1] ^= arr[i]\n        for i in range(1, len(arr)):\n            arr[i] = arr[i]^arr[i-1]\n        return [arr[j] ^ arr[i - 1] if i else arr[j] for i, j in queries]\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        res = []\n        for i in range(len(arr) - 1):\n            arr[i+1] = arr[i+1] ^ arr[i]\n        for i in queries:\n            if i[0] == 0:\n                res.append(arr[i[1]])\n            else:\n                res.append(arr[i[1]] ^ arr[i[0] - 1])\n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        curr = 0\n        cum_sum = []\n        res = []\n        for n in arr:\n            curr ^= n \n            cum_sum.append(curr)\n        \n        for start, end in queries:\n            x = cum_sum[end] ^ (cum_sum[start-1] if start > 0 else 0)\n            res.append(x)\n        return res\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xrr= [0 for i in range(len(arr))]\n        xrr[0] = arr[0]\n        for i in range(1,len(arr)):\n            xrr[i] = xrr[i-1] ^ arr[i]\n        res = []\n        for q in queries:\n            l = q[0]\n            r = q[1]\n            if l == r:\n                res.append(arr[l])\n            elif l == 0:\n                res.append(xrr[r])\n            else:\n                res.append(xrr[r] ^ xrr[l-1])\n        return res\n            \n            \n        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        def constSeg(tree, n, arr):\n            tree[n:] = arr\n            \n            for i in range(n-1,0,-1):\n                tree[i] = tree[2*i] ^ tree[2*i+1]\n        \n        def getQuery(beg, end):\n            beg += n\n            end += n\n            \n            ans = 0\n            \n            while(beg<end):\n                if beg&1:\n                    ans ^= tree[beg]\n                    beg += 1\n                if end&1:\n                    end -= 1\n                    ans ^= tree[end]\n                \n                beg //= 2\n                end //=2\n            \n            return ans\n                    \n        n = len(arr)\n        tree = [0]*(2*len(arr))\n        constSeg(tree,len(arr),arr)\n        \n        ans = []\n        for i in queries:\n            ans.append(getQuery(i[0], i[1]+1))\n        \n        return ans\n            \n        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix = []\n        cur = 0\n        for num in arr:\n            cur = cur ^ num\n            prefix.append(cur)\n        ans = []\n        for l, r in queries:\n            if l == 0:\n                ans.append(prefix[r])\n            else:\n                ans.append(prefix[l-1] ^ prefix[r])\n        \n        return ans\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        #the poor way to do this is to just go through and Xor the\n        res = []\n        for i in range(1,len(arr)):\n            arr[i] ^= arr[i-1]\n        for i,j in queries:\n            if i == 0:\n                res.append(arr[j])\n            else:\n                res.append(arr[i-1] ^ arr[j])\n        return res #so this is the absurdly slow way to do it though we should be able to memoize in some way?\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix = []\n        prev = 0\n        for a in arr:\n            prefix.append(prev^a)\n            prev = prev^a\n        \n        #print(prefix)\n        ans = []\n        for left, right in queries:\n            if left == 0:\n                ans.append(prefix[right])\n            else:\n                ans.append(prefix[right] ^ prefix[left-1])\n        \n        return ans", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(arr) - 1):\n            arr[i + 1] ^= arr[i]  \n        return [arr[j] ^ arr[i - 1] if i else arr[j] for i, j in queries]", "class Solution:\n    tree = []\n    n = 0\n    def SegmentTree(self, arr):\n        nonlocal tree, n\n        n = len(arr)\n        tree = [0]*2*n\n        for i in range(n):\n            tree[i+n] = arr[i]\n        for j in range(n-1, 0, -1):\n            tree[j] = tree[2 * j] ^ tree[2 * j + 1]\n            \n    def xor(self, frm, to):\n        nonlocal tree, n\n        frm += n\n        to += n\n        value = 0\n        while(frm < to):\n            if(frm & 1 == 1):\n                value ^= tree[frm]\n                frm += 1\n            if(to & 1 == 1):\n                to -= 1\n                value ^= tree[to]\n            frm >>= 1\n            to >>= 1\n        return value\n               \n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        self.SegmentTree(arr)\n        result = []        \n        for query in queries:\n            result.append(self.xor(query[0], query[1]+1))\n        return result\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        sa = [0] + arr[:]\n        for i in range(1, len(sa)):\n            sa[i] ^= sa[i - 1]\n        ret = []\n        for l, r in queries:\n            ret.append(sa[r + 1] ^ sa[l])\n        return ret", "class Solution:\n    tree = []\n    n = 0\n    def SegmentTree(self, arr):\n        nonlocal tree, n\n        n = len(arr)\n        tree = [0]*2*n\n        for i in range(n):\n            tree[i+n] = arr[i]\n        for j in range(n-1, 0, -1):\n            tree[j] = tree[2 * j] ^ tree[2 * j + 1]\n        #print(tree)\n    def xor(self, frm, to):\n        nonlocal tree, n\n        frm += n\n        to += n\n        value = 0\n        while(frm < to):\n            if(frm & 1 == 1):\n                value ^= tree[frm]\n                frm += 1\n            if(to & 1 == 1):\n                to -= 1\n                value ^= tree[to]\n            frm >>= 1\n            to >>= 1\n        \n        return value\n            \n        \n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        self.SegmentTree(arr)\n        result = []        \n        for query in queries:\n            #print(query[0], query[1]+1) DEBUG PRINT\n            result.append(self.xor(query[0], query[1]+1))\n\n        return result\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        xors = []\n        x = 0\n        for num in arr:\n            x ^= num\n            xors.append(x)\n        \n        ans = []\n        for i, j in queries:\n            \n            if i == 0:\n                ans.append(xors[j])\n            else:\n                ans.append(xors[j] ^ xors[i-1])\n        \n        return ans", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(arr)\n        out=[]\n        tree = [0]*(2*n)\n        for i in range(n):\n            tree[i+n] = arr[i]\n        for i  in range(n-1,0,-1):\n            tree[i] = tree[i << 1]^tree[i << 1 | 1]\n        for q in queries:\n            res = 0\n            l = q[0]+n\n            r = q[1]+n+1\n            while l < r:\n                if l & 1:\n                    res = res^tree[l]\n                    l=l+1\n                if r & 1:\n                    r=r-1\n                    res = res^tree[r]\n                l>>=1\n                r>>=1\n            out.append(res)\n        return out", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        pre_xor = [0]\n        size_arr=len(arr)\n        if size_arr%2==0:\n            for i in range (0,size_arr,2):\n                pre_xor.append(pre_xor[-1]^arr[i])\n                pre_xor.append(pre_xor[-1]^arr[i+1])\n        else:\n            pre_xor.append(pre_xor[-1]^arr[0])\n            for i in range (1,size_arr,2):\n                pre_xor.append(pre_xor[-1]^arr[i])\n                pre_xor.append(pre_xor[-1]^arr[i+1])\n                \n                \n            \n            \n\n        out_xor = []\n        for L, R in queries:\n            out_xor.append(pre_xor[L]^pre_xor[R+1])\n        return out_xor\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefix = [0]\n        for a in arr:\n            prefix.append(prefix[-1]^a)\n        ans = []\n        for l, r in queries:\n            ans.append(prefix[r+1]^prefix[l])\n        return ans", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        pre_xor = [0]\n        if len(arr)%2==0:\n            for i in range (0,len(arr),2):\n                pre_xor.append(pre_xor[i]^arr[i])\n                pre_xor.append(pre_xor[i+1]^arr[i+1])\n        else:\n            pre_xor.append(pre_xor[0]^arr[0])\n            for i in range (1,len(arr),2):\n                pre_xor.append(pre_xor[i]^arr[i])\n                pre_xor.append(pre_xor[i+1]^arr[i+1])\n                \n                \n            \n            \n\n        out_xor = []\n        for L, R in queries:\n            out_xor.append(pre_xor[L]^pre_xor[R+1])\n        return out_xor\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        if arr == []:\n            return []\n        res=[]\n        pre=[arr[0]]\n        for i in range(1,len(arr)):\n            pre.append(arr[i]^pre[-1])\n            \n        for i in range(0,len(queries)):\n            xor=0\n            if queries[i][0] == queries[i][1]:\n                res.append(arr[queries[i][0]])\n            elif (abs(queries[i][0] - queries[i][1]) == 1):\n                res.append(arr[queries[i][0]] ^ arr[queries[i][1]])\n            else:\n                if queries[i][0] == 0:\n                    res.append(pre[queries[i][1]])\n                else:\n                    res.append(pre[queries[i][1]]^pre[queries[i][0]-1])\n        print(res)\n        return(res)\n                    \n                \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        # precompute xor values\n        for i in range(1,len(arr)):\n            arr[i] ^= arr[i-1]\n            \n        for i, q in enumerate(queries):\n            if q[0] == 0:\n                queries[i] = arr[q[1]]    \n            else:\n                queries[i] = arr[q[0]-1] ^ arr[q[1]]\n        return queries", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        acc = list(accumulate([0] + arr, xor))\n        return [acc[a] ^ acc[b + 1] for a, b in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        px = arr[:]\n        \n        for i in range(1, len(px)):\n            px[i] ^= px[i-1]\n        \n        res = []\n        \n        for q in queries:\n            s, e = q[0], q[1]\n            r = px[e]\n\n            if s: r ^= px[s-1]\n            res.append(r)\n        \n        return res\n            \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        b = [arr[0]]\n        for a in arr[1:]:\n            b.append(b[-1]^a)\n            \n        ans = []\n        for q in queries:\n            r = b[q[1]]\n            if q[0]>0:\n                r ^= b[q[0]-1]\n            ans.append(r)\n            \n        return ans\n            \n        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        store = {}\n        n= len(arr)\n        curr = 0\n        store[-1]=0\n        for i in range(n):\n            curr^=arr[i]\n            \n            store[i]=curr\n        \n        return [ store[b]^store[a-1] for a,b in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        prefixSum = [0]*len(arr)\n        prefixSum[0] = arr[0]\n        result = []\n        for i in range(1,len(arr)):\n            prefixSum[i] = prefixSum[i-1] ^ arr[i]\n        for i in queries:\n            if(i[0] == 0):\n                result.append(prefixSum[i[1]])\n                continue\n            result.append(prefixSum[i[1]] ^ prefixSum[i[0]-1])\n        return(result)\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        \n        n = len(arr)\n        prefix = [0] * (n+1)\n        for i in range(n):\n            prefix[i+1] = prefix[i] ^ arr[i] \n        \n        res = []\n        for x, y in queries:\n            res.append( prefix[y+1] ^ prefix[x] )\n            \n        return res\n        \n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        lookup=[0]*len(arr)\n        lookup[0]=arr[0]\n        for i in range(1,len(arr)):\n            lookup[i] = lookup[i-1]^arr[i]\n\n        r=[]\n        for i in range(len(queries)):\n            if queries[i][0]==0:\n                r.append(lookup[queries[i][1]])\n            else:\n                tmp=lookup[queries[i][1]]^lookup[queries[i][0]-1]\n                r.append(tmp)\n        return r\n\n        \\\"\\\"\\\"\\\"\\\"\\\"\n        r=[]\n        for i in range(len(queries)):\n            \n            tmp=arr[queries[i][0]:queries[i][1]+1]\n            #print(tmp)\n            s= tmp[0]\n            if len(tmp) >1:\n                for i in range(1,len(tmp)):\n                    s=s^tmp[i]\n            #print(s)\n            #print(\\\"----\\\")\n            r.append(s)\n        return r\n        \\\"\\\"\\\"\\\"\\\"\\\"", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(arr)\n        m = len(queries)\n        d = {}\n        res = []\n        d['0 0'] = arr[0]\n        for i in range(1, n):\n            key = '{} {}'.format(0, i)\n            pkey = '{} {}'.format(0, i-1)\n            d[key] = d[pkey] ^ arr[i]\n        print(d)\n        for i in range(0, m):\n            (u,v) = queries[i]\n            s = 0\n            # for j in range(u, v + 1):\n                # key = '{u} {v}'.format(u=u, v=j)\n                # if key in d:\n                #     s = d[key]\n                #     continue\n                # s = s ^ arr[j]\n                # d[key] = s\n            key2 = '{u} {v}'.format(u=u, v=v)\n            if key2 in d:\n                res.append(d[key2])\n                continue\n\n            pkey = '{} {}'.format(0, u - 1)\n            key = '{} {}'.format(0, v)\n            s = d[pkey] ^ d[key]\n            print(d[pkey], d[key], s)\n            res.append(s)\n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(len(arr) - 1):\n            arr[i + 1] ^= arr[i]\n        \n        return [arr[j] ^ arr[i - 1] if i else arr[j] for i, j in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        res=[]\n        n=len(arr)\n        tmp=[arr[0]]\n        for i in range(1,n):\n            tmp.append(tmp[-1]^arr[i])\n        for x,y in queries:\n            if x==0:\n                res.append(tmp[y])\n            else:\n                res.append(tmp[x-1]^tmp[y])\n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        for i in range(1, len(arr)):\n            arr[i] = arr[i-1] ^ arr[i]\n        return [arr[j] if i == 0 else arr[i-1]^arr[j] for i, j in queries]", "from itertools import accumulate\n\nimport operator\n\nclass Solution:\n  def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n    x = list(accumulate(arr, operator.__xor__, initial = 0))\n    return [x[i] ^ x[j + 1] for i, j in queries]", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        ans = []\n        a = [arr[0],]\n        for i in range(1,len(arr)):\n            a.append(arr[i]^a[i-1])\n        for q in queries:\n            if(q[0]==0):\n                ans.append(a[q[1]])\n            else:\n                ans.append(a[q[1]]^a[q[0]-1])\n        return ans\n", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xor_arr = [0]*len(arr)\n        xor_arr[0] = arr[0]\n        for i in range(1,len(arr)):\n            xor_arr[i] = xor_arr[i-1] ^ arr[i]\n\n        res = [0]*len(queries)\n        for i, (s,e) in enumerate(queries):\n            if s == e:\n                res[i] = arr[s]\n            elif s == 0:\n                res[i] = xor_arr[e]\n            else:\n                res[i] = xor_arr[e] ^ xor_arr[s-1]\n                \n        return res", "class Solution:\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        xors=[0]\n        for a in arr:\n            xors.append(xors[-1]^a)\n        res=[]\n        for i,j in queries:\n            res.append(xors[j+1]^xors[i])\n        return res"]
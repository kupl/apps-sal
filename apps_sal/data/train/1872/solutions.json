["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        stack = [root]\n        ans = -1000000\n        result = 1\n        level = 1\n        \n        while stack:\n            curr = 0\n            newStack = []\n            for x in stack:\n                curr += x.val\n                if x.left:\n                    newStack.append(x.left)\n                if x.right: \n                    newStack.append(x.right)\n            \n            stack = newStack\n            \n            if curr > ans:\n                ans = curr\n                result = level\n                \n            level += 1\n            \n        return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        nodes=[[root]]\n        for node in nodes:\n            tmp=[]\n            for n in node:\n                if n.left:\n                    tmp.append(n.left)\n                if n.right:\n                    tmp.append(n.right)\n            if tmp:\n                nodes.append(tmp)\n        nodes=[sum([n.val for n in node]) for node in nodes]\n        return nodes.index(max(nodes))+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        maxLevel = 1\n        maxSum = float(\\\"-inf\\\")\n        queue = deque()\n        queue.append(root)\n        level = 1\n        \n        while queue:\n            l = len(queue)\n            levelSum = 0\n            \n            for _ in range(l):\n                node = queue.popleft()\n                levelSum += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            if levelSum > maxSum:\n                maxLevel = level\n                maxSum = levelSum\n            level += 1\n        \n        return maxLevel", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root==None:\n            return 0\n        queue=[root]\n        maxval=float(\\\"-inf\\\")\n        maxinde=0\n        level=1\n        while(queue):\n            n=len(queue)\n            su=sum([i.val for i in queue])\n            if su>maxval:\n                maxval=su\n                maxinde=level \n            for i in range(n):\n                x=queue.pop(0)\n                if x.left:\n                    queue.append(x.left)\n                if x.right:\n                    queue.append(x.right)\n            level+=1\n        return maxinde\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        #calculate the sum of nodes at each level\n        #store the index of the level with max sum until now\n        #if two have same, keep the first one, basically only update if its > nonlocal max\n        \n        #we can use both dfs and bfs here\n        #if we go by bfs, keep calculating sum of level as you add them in the queue\n        #tc and sc: O(n) and O(n) for qeuue and traversing\n        \n        #if we apply dfs\n        #keep a sum hash mapping every level to its total sum, keeping track of max depth encountered until now\n        #later we need to traverse this map and find the level with max sum\n        #TC: O(n), SC: O(height) for both stack and result map, but height can be O(n in case of skewed trees)\n        #lets go with dfs\n        #we can actually calc max sum and max depth on the go, to prevent iterating hash later - we cant do it, because suppose a level was max until a point, then a really negative vlaue is encountered at that level, still the max would be that level according to our current logic, which is wrong, we should calc max depth only later\n        \n        if not root:\n          return 0\n        \n        #preorder traversal\n        map_depth_sums = collections.defaultdict(int)\n        \n        #to avoid sorting of list to find\n        max_level = 0\n        max_sum = float(-inf) #since all sums might be negative, we need to find smallest of them all\n        \n        #[(5,2)]\n        #{1: 1, 2: 10, 3: 10}\n        #10, 2\n        stack = [(root, 1)]\n        \n        while(stack):\n          curr_node, level = stack.pop()\n          map_depth_sums[level] += curr_node.val\n            \n          if curr_node.right:\n            stack.append((curr_node.right, level+1))\n          if curr_node.left:\n            stack.append((curr_node.left, level + 1))\n        \n        level = 1\n        while(level in map_depth_sums):\n          if map_depth_sums[level] > max_sum:\n            max_sum = map_depth_sums[level]\n            max_level = level\n          level += 1\n          \n        return max_level\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        collector = collections.defaultdict(int)\n        \n        def helper(root, d):\n            if not root:\n                return\n            \n            collector[d] += root.val\n            \n            helper(root.right, d+1)\n            helper(root.left, d+1)\n            return\n        \n        helper(root, 0)\n        \n        print(collector)\n        best = 0\n        for k, v in list(collector.items()):\n            if v > collector[best]:\n                best = k\n        return best+1\n    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        stack = [root]\n        levelsum = 0\n        maxlevel = float('-inf')\n        maxsum = float('-inf')\n        currentlevel = 0\n        \n        while stack:\n            slen = len(stack)\n            currentlevel += 1\n            while slen > 0:\n                node = stack.pop(0)\n                levelsum += node.val\n                if node.left:\n                    stack.append(node.left)\n                if node.right:\n                    stack.append(node.right)\n                slen -=1\n            \n            if levelsum > maxsum:\n                maxlevel = currentlevel\n                maxsum = levelsum\n            \n            levelsum = 0\n        \n        return maxlevel", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        level = 0\n        max_level = 0\n        max_sum = float('-inf')\n        \n        q = []\n        q.append(root)\n        \n        while q:\n            level +=1\n            curr = 0\n            for _ in range(len(q)):\n                node = q.pop(0)\n                curr += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if max_sum < curr:\n                max_sum = curr\n                max_level = level\n        return max_level\n                \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        sums = []\n        \n        def addLevels(node, level):\n            \n            if level > len(sums):\n                \n                sums.append(0)\n            \n            sums[level - 1] += node.val\n            \n            if node.left != None:\n                \n                addLevels(node.left, level + 1)\n            \n            if node.right != None:\n                \n                addLevels(node.right, level + 1)\n        \n        if(root):\n            \n            addLevels(root, 1)\n            return sums.index(max(sums)) + 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nfrom collections import defaultdict \n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        queue = deque()\n        queue.append((root, 1))\n        \n        \n        level_sums = defaultdict(int)\n        \n        while (len(queue) > 0):\n            node_tuple = queue.popleft()\n            curr_node = node_tuple[0]\n            curr_level = node_tuple[1]\n            level_sums[curr_level] += curr_node.val\n            if (curr_node.left != None):\n                queue.append((curr_node.left, curr_level + 1))\n            if (curr_node.right != None):\n                queue.append((curr_node.right, curr_level + 1))\n                \n        max_sum = root.val\n        result_level = 1\n        \n        for level in list(level_sums.keys()):\n            if level_sums[level] > max_sum:\n                max_sum = level_sums[level]\n                result_level = level \n                \n        return result_level\n                \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import defaultdict\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        #have a rst that saves sum at each level\n        rstDict = dict()\n        def maxLevelRec(root,level):\n            nonlocal rstDict\n            if(not root):\n                return\n            if(level in rstDict):\n                rstDict[level]+=root.val\n            else:\n                rstDict[level] = root.val\n            maxLevelRec(root.left,level+1)\n            maxLevelRec(root.right,level+1)\n        maxLevelRec(root,1)\n        maxSum = max(rstDict.values())\n        for key in list(rstDict.keys()):\n            if(rstDict[key] == maxSum):\n                return key\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root: return 0\n        \n        levels = []\n        \n        queue = [root]\n        \n        while queue:\n            new_queue = []\n            \n            ttl = 0\n            for node in queue:\n                ttl += node.val\n                if node.left:\n                    new_queue.append(node.left)\n                if node.right:\n                    new_queue.append(node.right)\n            levels.append(ttl)\n            queue = new_queue\n        \n        curr_max = -float('inf')\n        curr_index = -1\n        for i, num in enumerate(levels):\n            if num > curr_max:\n                curr_index = i\n                curr_max = num\n        return curr_index+1\n                \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        memo = {}\n        self.maxLevelSumHelper(root, memo, 1)\n        maxValue = max(memo.values())\n        targetKeys = [k for k in memo if memo[k] == maxValue]\n        return min(targetKeys)\n    \n    def maxLevelSumHelper(self, node, memo, depth):\n        if node == None:\n            return\n        \n        if depth in memo:\n            memo[depth] += node.val\n        else:\n            memo[depth] = node.val\n        \n        self.maxLevelSumHelper(node.left, memo, depth + 1)\n        self.maxLevelSumHelper(node.right, memo, depth + 1)\n        \n        return\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        self.max_sum = {}\n        \n        def sum_tree(node: TreeNode,level):\n            \n            if not node:\n                return\n            sum_tree(node.left,level+1)\n            sum_tree(node.right,level+1)\n            if level in self.max_sum:\n                self.max_sum[level] +=  node.val\n            else:\n                self.max_sum[level] =  node.val\n            \n        sum_tree(root,1)\n        output, max_val = float('inf'), -float('inf')\n        for key, val in list(self.max_sum.items()):\n            if val > max_val:\n                output, max_val = key, val\n            elif val == max_val:\n                output = min(key, output)\n        return output\n        \n             \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def dfs(self,final,root,level):\n        if root is None : return\n        if len(final)<level+1:\n            final.append([])\n        final[level].append(root.val)\n        self.dfs(final,root.left,level+1)\n        self.dfs(final,root.right,level+1)\n    def maxLevelSum(self, root: TreeNode) -> int:\n        final = []\n        self.dfs(final,root,0)\n        maxx = max([sum(i) for i in final])\n        for i in range(len(final)):\n            if sum(final[i])==maxx : \n                return i + 1\n        return -1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root is None:\n            return None\n        \n        hashmap={}\n        que=[]\n        que.append((1,root))\n        \n        while len(que)>0:\n            item=que.pop(0)\n            depth=item[0]\n            node=item[1]\n            if depth not in hashmap:\n                hashmap[depth]=0\n            hashmap[depth]+=node.val\n            \n            if node.left is not None:\n                que.append((depth+1,node.left))\n            if node.right is not None:\n                que.append((depth+1,node.right))\n        \n        sorted_dict=dict(sorted(list(hashmap.items()), key=lambda x: x[1],reverse=True))\n        #print('Hashmap : ',sorted_dict)\n        return list(sorted_dict.keys())[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n      if not root: return \n      st=[[root,0]]\n      ll=[]\n      while st:\n        r,l=st.pop(0)\n        if l==len(ll) : ll.append([])\n        ll[l].append(r.val)\n        if r.left: st.append([r.left,l+1])\n        if r.right:\n          st.append([r.right,l+1])\n      #print (ll,l)\n      m=-1000\n      re=0\n      for i in range(l+1):\n        n=sum(ll[i])\n        if m<n:\n          m=n\n          re=i\n      return re+1\n        \n      \n      \n      \\\"\\\"\\\"\n        if not root:\n          return []\n        queue,res=[[root, 0]],[]\n        while queue:\n          #print (queue[0][0].val)\n          node,level = queue.pop(0)\n          \n          if level == len(res):\n            res.append([])\n        \n          res[level].append(node.val)\n          if node.left:\n            queue.append((node.left, level + 1))\n          if node.right:\n            queue.append((node.right, level + 1))\n          \n        return res[::-1]\n      \\\"\\\"\\\"", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n\n        nodes = [(1, root)]\n        maxlevelsum = -float('inf')-1\n        maxlevel = 0\n        currlevel = 1\n        currlevelsum = 0\n        while len(nodes) != 0:\n            curr = nodes.pop(0)\n            if curr[0] == currlevel:\n                currlevelsum += curr[1].val\n            else:\n                if currlevelsum > maxlevelsum:\n                    maxlevelsum = currlevelsum\n                    maxlevel = currlevel\n                currlevel = curr[0]\n                currlevelsum = curr[1].val\n\n            if curr[1].left is not None:\n                nodes.append((curr[0] + 1, curr[1].left))\n            if curr[1].right is not None:\n                nodes.append((curr[0] + 1, curr[1].right))\n            if len(nodes) == 0:\n                if currlevelsum > maxlevelsum:\n                    maxlevelsum = currlevelsum\n                    maxlevel = currlevel\n\n        return maxlevel", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root: return 0\n        \n        queue = [root]\n        maxLevel = level = 1\n        maxSum = root.val\n        \n        while queue:\n            nextLevel = []\n            s = 0\n            for n in queue:\n                s += n.val\n                if n.left:\n                    nextLevel.append(n.left)\n                if n.right:\n                    nextLevel.append(n.right)\n            if s > maxSum:\n                maxSum, maxLevel = s, level\n            queue = nextLevel\n            level += 1\n        return maxLevel", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        level = 1\n        count = 1\n        bfs = [(root,level)]\n        res = dict()\n        while (len(bfs) >0):\n            node, lvl = bfs[0]\n            bfs.remove((node,lvl))\n            if (res.get(lvl) == None):\n                res[lvl] = 0\n            res[lvl] += node.val\n            if (node.left):\n                bfs.append((node.left, lvl+1))\n            if (node.right):\n                bfs.append((node.right, lvl + 1))\n        maxs = max(res.values())\n        for i in list(res.keys()):\n            if (res[i]==maxs):\n                return i\n", "from collections import defaultdict\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        levelSum = defaultdict(int)\n        curLevel = 0\n        q = [root]\n        while q:\n            q_length = len(q)\n            for i in range(q_length):\n                cur = q.pop()\n                levelSum[curLevel] += cur.val\n                if cur.left: q.insert(0, cur.left)\n                if cur.right: q.insert(0, cur.right)\n                \n            curLevel += 1\n            \n        maxSumm = max(levelSum.values())\n        for l in range(len(levelSum)):\n            if levelSum[l] == maxSumm: return l+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = [root]\n        curLevel = maxLevel = 1\n        output = root.val\n        \n        while queue:\n            s, nextLevel = 0, []\n            for n in queue:\n                if n.left:\n                    nextLevel.append(n.left)\n                if n.right:\n                    nextLevel.append(n.right)\n                s += n.val\n            if s > output:\n                output = s\n                maxLevel = curLevel\n            curLevel += 1\n            queue = nextLevel\n        return maxLevel\n", "from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = deque([[root, 1]])\n        best = -math.inf\n        ans = 1\n        last = 1\n        total = 0\n\n        while queue:\n            node = queue.popleft()\n            if last != node[1]:\n                if total > best:\n                    best = total\n                    ans = last\n                last = node[1]\n                total = 0\n            \n            if not node[0]:\n                    continue\n\n            total += node[0].val\n            \n            lvl = node[1]+1\n            queue.append([node[0].left, lvl])\n            queue.append([node[0].right, lvl])\n\n\n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        curr_level = max_level = 1\n        max_sum = float('-inf')\n        queue = [root,]\n        \n        while queue:\n            curr_sum = sum([x.val for x in queue])\n            if (curr_sum > max_sum):\n                max_sum, max_level = curr_sum, curr_level\n            queue = [y for x in queue for y in [x.left,x.right] if y]\n            curr_level+=1\n            \n        return max_level", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.sums = []\n        self.current_level = 1\n    def helper(self, root):\n        if root is None:\n            return\n        if len(self.sums)<self.current_level:\n            self.sums.append(root.val)\n        else:\n            self.sums[self.current_level-1] += root.val\n        self.current_level += 1\n        self.helper(root.left)\n        self.helper(root.right)\n        self.current_level -= 1\n    def maxLevelSum(self, root: TreeNode) -> int:\n        self.helper(root)\n        return self.sums.index(max(self.sums))+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        d = {}\n        \n        def f(root, level):\n            if root:\n                if level in d:\n                    d[level] += root.val\n                else:\n                    d[level] = root.val\n                f(root.left, level+1)\n                f(root.right, level+1)\n        \n        f(root, 1)\n        m = max(d.values())\n        for k in d:\n            if d[k] == m:\n                return k", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        def check(root, level, d):\n            if level not in d:\n                d[level] = 0\n            d[level] += root.val\n            if root.left:\n                check(root.left, level+1, d)\n            if root.right:\n                check(root.right, level+1, d)\n            return\n        \n        d = dict()\n        check(root, 1, d)\n        rtv = 0\n        maxs= -float('inf')\n        for k in list(d.keys()):\n            if d[k] > maxs:\n                maxs = d[k]\n                rtv = k\n        return rtv\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        q=[root]\n        curr_level=1\n        max_level=1\n        max_sum=root.val\n        while(len(q)!=0):\n            level_nodes=len(q)\n            sum_=0\n            for i in range(level_nodes):\n                root=q[0]\n                \n                if(root!=None):\n                    sum_+=root.val\n                if(root.left!=None):\n                    q.append(root.left)\n                if(root.right!=None):\n                    q.append(root.right)\n                del q[0]\n            \n            if(sum_>max_sum):\n                max_sum=sum_\n                max_level=curr_level\n                \n            \n            curr_level+=1\n        return max_level\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        def helper(root, level, sums):\n            if not root: return\n            if level > len(sums):\n                sums.append(0)\n            sums[level-1] += root.val\n            helper(root.left, level+1, sums)\n            helper(root.right, level+1, sums)\n            \n        sums = []\n        helper(root, 1, sums)\n        m, ix = -float('inf'), -1\n        for i in range(len(sums)):\n            if sums[i] > m:\n                m, ix= sums[i], i\n        return ix +1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        \n        queue=[root]\n        res=0\n        result=[]\n        while len(queue)!=0:\n            l=len(queue)\n            sum1=0\n            for i in range(l):\n                item=queue.pop(0)\n                sum1+=item.val\n                if item.left!=None:\n                    queue.append(item.left)\n                if item.right!=None:\n                    queue.append(item.right)\n            result.append(sum1)\n        return result.index(max(result))+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = [(root, 1)]\n        best = -math.inf\n        ans = 1\n        last = 1\n        total = 0\n\n        while queue:\n            node = queue.pop(0)\n            if last != node[1]:\n                if total > best:\n                    best = total\n                    ans = last\n                last = node[1]\n                total = 0\n            \n            if not node[0]:\n                    continue\n\n            total += node[0].val\n            \n            lvl = node[1]+1\n            queue.append((node[0].left, lvl))\n            queue.append((node[0].right, lvl))\n\n\n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = [(root, 1)]\n        l_sum = []\n        \n        while queue:\n            c_node, c_level = queue.pop(0)\n            if c_node:\n                while len(l_sum) < c_level:\n                    l_sum.append(0)\n\n                l_sum[c_level-1]+=c_node.val\n\n                queue.append((c_node.left, c_level+1))\n                queue.append((c_node.right, c_level+1))\n            \n        l_max = None\n        max_i = 0\n        for i in range(len(l_sum)):\n            if l_max is None or l_max < l_sum[i]:\n                l_max = l_sum[i]\n                max_i = i\n                \n        return max_i+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        curr = [root]\n        currLevel = 0\n        res = 0\n        resSum = float(\\\"-inf\\\")\n\n        while curr:\n            currSum = 0\n            currLevel+=1\n            nexx = []\n            for n in curr:\n                currSum += n.val\n                if n.left:\n                    nexx.append(n.left)\n                if n.right:\n                    nexx.append(n.right)\n            if resSum < currSum:\n                res = currLevel\n                resSum = currSum\n            curr = nexx\n        \n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        max_sum = float('-inf')\n        level = 0\n        max_level = 0\n        queue = []\n        \n        if not root:\n            return 0\n        \n        queue.append(root)\n        \n        while len(queue) > 0:\n            size = len(queue)\n            level_sum = 0\n            level += 1\n            \n            for i in range(size):\n                node = queue.pop(0)\n                level_sum += node.val\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            if max_sum < level_sum:\n                max_sum = level_sum\n                max_level = level\n        \n        return max_level", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        dic = collections.defaultdict(int)\n        \n        def dfs(node, level):\n            if not node:\n                return\n            else:\n                dic[level] += node.val\n            dfs(node.left, level+1)\n            dfs(node.right, level+1)\n            \n        dfs(root,1)\n        \n        res = 1\n        Max = float('-inf')\n        for level,value in list(dic.items()):\n            if value>Max:\n                Max = value\n                res = level\n        return res\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        res = []\n        level = 0\n        def dfs(root, res, level):\n            if root == None:\n                return\n            if level >= len(res):\n                res.append(0)\n            res[level] += root.val\n            level += 1\n            dfs(root.left, res, level)\n            dfs(root.right, res, level)\n        dfs(root, res, level)\n        return (res.index(max(res))+1)", "\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        vals={}\n        current=[root]\n        vals[1]=root.val\n        max1=0\n        level=0\n        cl=1\n        \n        while len(current):\n            nodes=current\n            children=[]\n            sum1=0\n            for node in nodes:\n                \n                if node.left:\n                    children.append(node.left)\n                    sum1+=node.left.val\n                if node.right:\n                    children.append(node.right)\n                    sum1+=node.right.val\n            \n            vals[cl+1]=sum1\n            if sum1>=max1:\n                level=cl+1\n                max1=sum1\n            \n            if len(children)>0:\n                current=children\n                cl+=1\n            \n            else:\n                break\n        \n        \n            \n        return level\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def ht(self, root):\n        if (root == None):\n            return 0\n        return 1 + max(self.ht(root.left), self.ht(root.right))\n    \n    \n    def Sum(self, root, SA, level):\n        if (root != None):\n            print (level)\n            SA[level] += root.val\n            if (root.left != None):\n                self.Sum(root.left, SA, level + 1)\n            if (root.right != None):\n                self.Sum(root.right, SA, level + 1)\n                \n    def maxLevelSum(self, root: TreeNode) -> int:\n        SA = [0]*self.ht(root)\n        self.Sum(root, SA, 0)\n        return SA.index(max(SA)) + 1\n            \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        queue = collections.deque([root])\n        maximum = root.val\n        maximum_level = 1\n        cnt = 1\n        while(queue):\n            summation = 0\n            length = len(queue)\n            for i in range(length):\n                node = queue.popleft()\n                summation += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if summation > maximum:\n                maximum = summation\n                maximum_level = cnt\n            cnt += 1\n        return maximum_level", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def find(self,root,d,s,h):\n        if(root==None):\n            return None\n        if h not in list(d.keys()):\n            d[h] = root.val\n        else:\n            d[h] = d[h]+root.val\n        self.find(root.left,d,s,h+1)\n        self.find(root.right,d,s,h+1)\n        \n        \n    def maxLevelSum(self, root: TreeNode) -> int:\n        d = dict()\n        s=[0]\n        self.find(root,d,s,1)\n        return max(d,key=d.get)\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        mx = root.val\n        mxlvl = 1\n        if root.right is None and root.left is None:\n            return 1\n        \n        clvl = 2\n        s = 0\n        \n        q = deque()\n        q.append((root.right, 2))\n        q.append((root.left, 2))\n        while q:\n            n, lvl = q.popleft()\n            if n is None:\n                continue\n            if lvl == clvl:\n                s += n.val\n                print((s, clvl))\n            else:\n                if s > mx:\n                    mx = s\n                    mxlvl = clvl\n                    mx = s\n                s = n.val\n                clvl = lvl\n            q.append((n.left, lvl + 1))\n            q.append((n.right, lvl + 1))\n        if s > mx:\n            mx = s\n            mxlvl = clvl\n        return mxlvl\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        mx = root.val\n        mxlvl = 1\n        if root.right is None and root.left is None:\n            return 1\n        \n        clvl = 2\n        s = 0\n        \n        q = deque()\n        q.append((root.right, 2))\n        q.append((root.left, 2))\n        while q:\n            n, lvl = q.popleft()\n            if n is None:\n                continue\n            if lvl == clvl:\n                s += n.val\n                print(s, clvl)\n            else:\n                if s > mx:\n                    print(f\\\"UP: {s=} {mx=} {mxlvl=} {lvl=}\\\")\n                    mx = s\n                    mxlvl = clvl\n                    print(f\\\"UP: {s=} {mx=} {mxlvl=} {lvl=}\\\")\n                    mx = s\n                s = n.val\n                clvl = lvl\n            q.append((n.left, lvl + 1))\n            q.append((n.right, lvl + 1))\n        if s > mx:\n            mx = s\n            mxlvl = clvl\n        return mxlvl\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return \n        \n        from collections import deque\n        import sys\n        queue = deque([root])\n        global_value = -sys.maxsize\n        level = 0\n        while queue:\n            level += 1\n            level_value = 0\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                level_value += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level_value > global_value:\n                global_value = level_value\n                global_level = level\n        \n        return global_level\n                \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        level = 1\n        \n        def recurse(root, level):\n            if root:\n                recurse(root.left, level+1)\n                print(level)\n                print(\\\"val\\\", root.val)\n                level_store[level] +=root.val\n                recurse(root.right, level+1)\n        \n        level_store = collections.defaultdict(int)\n        recurse(root, level)\n        \n        print(level_store)\n        max_so_far = float(\\\"-inf\\\")\n        index = -1\n        for key, value in level_store.items():\n            if value>max_so_far:\n                max_so_far = value\n                index = key\n            elif value==max_so_far:\n                index=min(key, index)\n                \n        return index\n                \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n        \n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        if not root.left and not root.right:\n            return root.val\n        arr = [[root.val]]\n        def helper(n,l):\n            if not n:\n                return\n            if len(arr) < l+1:\n                arr.append([])\n            arr[l].append(n.val)\n            helper(n.left,l+1)\n            helper(n.right,l+1)\n        \n        helper(root.left,1)\n        helper(root.right,1)\n        print(arr)\n        res = -2**32 + 1 \n        ans = 1\n        for j,i in enumerate(arr):\n            if sum(i) > res:\n                res = sum(i)\n                ans = j+1\n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        res = self.helper(root)\n        return res.index(max(res)) + 1\n        \n    def helper(self, root):\n        if not root:\n            return []\n        res, left, right = [root.val], self.helper(root.left), self.helper(root.right)\n        l = min(len(left), len(right))\n        for i in range(l):\n            res.append(left[i] + right[i])\n        res = res + left[l:] + right[l:]\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        queue = [root]\n        maxSum = root.val\n        res = 1\n        level = 0\n        \n        while queue:\n            size = len(queue)\n            currSum = 0\n            level += 1\n            \n            for _ in range(size):\n                node = queue.pop(0)\n                currSum += node.val\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            if maxSum < currSum:\n                maxSum = currSum\n                res = level\n                \n        return res ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    \n    def maxLevelSum(self, root: TreeNode) -> int:\n        levelMapping = {}\n        queue = []\n        queue.append([root, 1])\n        while queue:\n            s = queue.pop(0)\n            \n            if s[0] == None:\n                continue\n            \n            if s[1] in levelMapping:\n                if levelMapping[s[1]]:\n                    levelMapping[s[1]] += s[0].val\n            else:\n                levelMapping[s[1]] = s[0].val\n            queue.append([s[0].left, s[1]+1])\n            queue.append([s[0].right, s[1]+1])\n        maximum = -999999999999999999999\n        maximum_level = 0\n        print(levelMapping)\n        for key in levelMapping:\n            if levelMapping[key] and maximum < levelMapping[key]:\n                maximum = levelMapping[key]\n                maximum_level = key\n        return maximum_level\n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.sols = {}\n        \n    def nodes_at_level(self, root, level, target, nodes):\n        if root == None:\n            return nodes\n        \n        if level == target:\n            nodes.append(root)\n            return nodes\n        \n        self.nodes_at_level(root.left, level+1, target, nodes)\n        self.nodes_at_level(root.right, level+1, target, nodes)\n        \n        return nodes\n    def sum_at_level(self, root, level, target):\n        if root == None:\n            return 0\n        \n        \n        if level == target:\n            return root.val\n        \n        result = sum((self.sum_at_level(root.left, level +1, target), self.sum_at_level(root.right, level+1, target)))\n        \n        return result\n        \n    def level_count(self, root):\n        if root == None:\n            return 0\n        \n        if root in self.sols:\n            return self.sols[root]\n        \n        result = 1 + max(self.level_count(root.left), self.level_count(root.right))\n        \n        self.sols[root] = result\n        \n        return result\n    \n    def all_children(self, nodes):\n        for node in nodes:\n            if node.left != None:\n                yield node.left\n            if node.right != None:\n                yield node.right\n    \n    def maxLevelSum(self, root: TreeNode) -> int:\n        levels = [[root]]#{1: [root]}\n        \n        do_more = True\n        cur = 1\n        \n        max_index = 0    \n        max_val = sum([x.val for x in levels[-1]])\n        while do_more:\n            nodes = levels[-1]\n            new_nodes = tuple(self.all_children(nodes))\n            levels.append(new_nodes)\n            do_more = len(new_nodes) > 0\n            \n            cur_val = sum([x.val for x in new_nodes])\n            if cur_val > max_val:\n                max_val = cur_val\n                max_index = cur\n                \n            cur += 1\n        \n        for i, level in enumerate(levels):\n            level_sum = sum([x.val for x in level])\n            if level_sum > max_val:\n                max_index = i\n                max_val = level_sum\n        #for i, l in enumerate(levels):\n        #    print(i, list(map(lambda x: x.val, l)))\n        #print([random.randint(-100000,100000) for _ in range(10000)])\n        return max_index+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport collections\nimport heapq\nimport sys\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        lSums = dict()\n        q = collections.deque()\n        \n        level = 0\n        q.append(root)\n        while q:\n            size = len(q)\n            level += 1\n            levelSum = 0\n            for i in range(size):\n                node = q.popleft()\n                levelSum += node.val\n                if node.left != None:\n                    q.append(node.left)\n                if node.right != None:\n                    q.append(node.right)\n        \n            lSums[level] = levelSum\n            \n        minLevel = sys.maxsize\n        maxSum = -sys.maxsize\n        \n        for level in lSums:\n            localSum = lSums[level]\n            #print(\\\"level %d sum %d maxSum %d minLel %d\\\" % (level, localSum, maxSum, minLevel))\n            if maxSum < localSum :\n                minLevel = level\n                maxSum = localSum\n                \n        return minLevel\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        from collections import defaultdict\n        \n        self.sums = defaultdict(int)\n        \n        def helper(node, level):\n            if node is not None:\n                self.sums[level] += node.val\n                helper(node.right, level+1)\n                helper(node.left, level+1)\n        \n        helper(root,1)\n        \n        return sorted(list(self.sums.items()),key=lambda t:t[1], reverse=True)[0][0]\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nfrom collections import defaultdict\n\n\nclass Solution:\n    \n    \n    def max_level_sum_rec(self, cur, cur_level):\n        result = defaultdict(int)\n        if cur:\n            result[cur_level] += cur.val\n        if cur.left:\n            left_result = self.max_level_sum_rec(cur.left, cur_level+1)\n            for k,v in left_result.items():\n                result[k] += v\n        if cur.right:\n            right_result = self.max_level_sum_rec(cur.right, cur_level+1)\n            for k,v in right_result.items():\n                result[k] += v\n        \n        return result\n        \n    \n    def maxLevelSum(self, root: TreeNode) -> int:\n        result = self.max_level_sum_rec(root, 1)\n        print(result)\n        return sorted(\n            result.items(),\n            key=lambda t: (t[1], -t[0]),\n            reverse=True\n        )[0][0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        level = 0\n        max_level = 0\n        max_sum = float('-inf')\n        \n        q = collections.deque()\n        q.append(root)\n        \n        while q:\n            level += 1\n            curr_sum = 0\n            \n            for _ in range(len(q)):\n                node = q.popleft()\n                \n                curr_sum += node.val\n                \n                if node.left:\n                    q.append(node.left)\n                    \n                if node.right:\n                    q.append(node.right)\n                    \n            if max_sum < curr_sum:\n                max_sum = curr_sum\n                max_level = level\n            \n        return max_level\n        \n\n        \n        \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        queue = [root]\n        max_sum = float('-inf')\n        max_level = 0\n        level = 0\n        while len(queue) > 0:\n            level_length = len(queue)\n            level_sum = 0\n            for i in range(level_length):\n                node = queue.pop(0)\n                level_sum += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if max_sum < level_sum:\n                max_sum = level_sum\n                max_level = level + 1\n            level += 1\n\n        return max_level\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        level = 0\n        max_level = 0\n        max_sum = float('-inf')\n        \n        q = collections.deque()\n        q.append(root)\n        \n        while q:\n            level += 1\n            curr_sum = 0\n            \n            for _ in range(len(q)):\n                node = q.popleft()\n                \n                curr_sum += node.val\n                \n                if node.left:\n                    q.append(node.left)\n                    \n                if node.right:\n                    q.append(node.right)\n                    \n            if max_sum < curr_sum:\n                max_sum = curr_sum\n                max_level = level\n                \n        return max_level", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = deque()\n        result = 1\n        queue.append((root, 1))\n        maxsum = - sys.maxsize\n        while queue:\n            size = len(queue)\n            level_sum = 0\n            for i in range(size):\n                node, level = queue.popleft()\n                level_sum += node.val\n                if node.left:\n                    queue.append((node.left, level+1))\n                if node.right:\n                    queue.append((node.right, level+1))\n            if level_sum > maxsum:\n                maxsum = level_sum\n                result = level\n        return result", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        #bfs\n        \n        q = [root]\n        sums = []\n        while len(q)>0 :\n            s = len(q)\n            tmp = 0\n            for i in range(s) :\n                n = q.pop(0)\n                tmp += n.val\n                if n.left :\n                    q.append(n.left)\n                if n.right :\n                    q.append(n.right)\n                    \n            sums.append(tmp)\n        \n        level_sums = sorted(zip(range(len(sums)), sums), key=lambda x : (-x[1], x[0]))\n        return level_sums[0][0]+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if root == None:\n            return 0\n        traversing = [(1, root)]\n        level_sum = dict()\n        while traversing:\n            cur = traversing.pop()\n            level_sum[cur[0]] = level_sum.get(cur[0], 0) + cur[1].val\n            if cur[1].left:\n                traversing.append((cur[0] + 1, cur[1].left))\n            if cur[1].right:\n                traversing.append((cur[0] + 1, cur[1].right))\n        return max((v, k) for k, v in level_sum.items())[1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelSumHelper(self, node, level, sums):\n        if node is None:\n            return sums\n        if(len(sums)==level):\n            sums.append(node.val)\n        else:\n            sums[level]+=node.val\n        sums = self.levelSumHelper(node.left, level+1, sums)\n        sums = self.levelSumHelper(node.right, level+1, sums)\n        return sums\n    def maxLevelSum(self, root: TreeNode) -> int:\n        sums = self.levelSumHelper(root, 0, [])\n        #print(sums)\n        m = sums[0]\n        ret = 0\n        for i, s in enumerate(sums):\n            #print(i,s)\n            #print(m, ret)\n            if s>m:\n                m = s\n                ret = i\n        return ret+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        self.l = [0]*100000\n        self.max = float(\\\"-inf\\\")\n        self.ans = 0\n        \n        def ankit(root,level):\n            \n            if(root is not None):\n                ankit(root.left,level+1)\n                self.l[level]+= root.val\n                ankit(root.right,level+1)\n                \n        ankit(root,1)\n        return self.l.index(max(self.l))\n                    \n                \n            \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        #bfs\n        \n        q = [root]\n        sums = []\n        while len(q)>0 :\n            s = len(q)\n            tmp = 0\n            for i in range(s) :\n                n = q.pop(0)\n                tmp += n.val\n                if n.left :\n                    q.append(n.left)\n                if n.right :\n                    q.append(n.right)\n                    \n            sums.append(tmp)\n        \n        print(sums)\n        level_sums = sorted(zip(range(len(sums)), sums), key=lambda x : (-x[1], x[0]))\n        return level_sums[0][0]+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        res = self.helper(root)\n        return res.index(max(res)) + 1\n        \n    def helper(self, root):\n        if not root:\n            return []\n        left, right = self.helper(root.left), self.helper(root.right)\n        l = min(len(left), len(right))\n        res = [root.val] + [sum(p) for p in zip(left, right)] + left[l:] + right[l:]\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        res = self.helper(root)\n        return res.index(max(res)) + 1\n        \n    def helper(self, root):\n        if not root:\n            return []\n        left, right = self.helper(root.left), self.helper(root.right)\n        l = min(len(left), len(right))\n        return [root.val] + [sum(p) for p in zip(left, right)] + left[l:] + right[l:]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        max_level = -1\n        max_sum = -float('inf')\n\n        lv = 1\n        lv_nodes = [root]\n        while lv_nodes:\n            \n            if max_sum < sum([n.val for n in lv_nodes]):\n                max_level = lv\n                max_sum = sum([n.val for n in lv_nodes])\n            lv += 1\n            new_nodes = []\n            for n in lv_nodes:\n                if n.left:\n                    new_nodes.append(n.left)\n                if n.right:\n                    new_nodes.append(n.right)\n            lv_nodes = new_nodes\n        return max_level\n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\\\"\\\"\\\"\nApproach: Level order traversal (BFS)\n- maintain a max_level_sum \n\\\"\\\"\\\"\n\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        max_level, level, ans = -float('inf'), 0, 0\n        q = collections.deque()\n        q.append(root)\n\n        while q:\n            level += 1\n            level_sum = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                level_sum += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if max_level < level_sum:\n                max_level, ans = level_sum, level        \n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def ht(self, root):\n        if (root == None):\n            return 0\n        return 1 + max(self.ht(root.left), self.ht(root.right))\n    \n    \n    def Sum(self, root, SA, level):\n        if (root != None):\n            print (level)\n            SA[level] += root.val\n            if (root.left != None):\n                self.Sum(root.left, SA, level + 1)\n            if (root.right != None):\n                self.Sum(root.right, SA, level + 1)\n                \n    def maxLevelSum(self, root: TreeNode) -> int:\n        SA = [0]*self.ht(root)\n        print(\\\"het \\\" + str(self.ht(root)))\n        self.Sum(root, SA, 0)\n        print (SA)\n        return SA.index(max(SA)) + 1\n            \n            \n        \n", "\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        levels={}\n        vals={}\n        current=[root]\n        levels[root]=1\n        vals[1]=root.val\n        max1=0\n        level=0\n        cl=1\n        \n        while len(current):\n            nodes=current\n            children=[]\n            sum1=0\n            for node in nodes:\n                \n                if node.left:\n                    children.append(node.left)\n                    sum1+=node.left.val\n                if node.right:\n                    children.append(node.right)\n                    sum1+=node.right.val\n            \n            vals[cl+1]=sum1\n            if sum1>=max1:\n                level=cl+1\n                max1=sum1\n            \n            if len(children)>0:\n                current=children\n                cl+=1\n            \n            else:\n                break\n        \n        \n            \n        return level\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.q = collections.deque()\n        self.sums = collections.defaultdict()\n        \n    def bfs(self, root, visited):\n        self.q.append(root)\n        idx = 1\n        \n        while self.q:\n            level = len(self.q)\n            self.sums[idx] = 0\n            while level:\n                p = self.q.popleft()\n                \n                if p is None or p in visited:\n                    level -= 1\n                    continue\n                \n                self.sums[idx] += p.val\n                \n                self.q.append(p.left)\n                self.q.append(p.right)\n                \n                level -= 1\n                \n            idx += 1\n        \n    def maxLevelSum(self, root: TreeNode) -> int:\n        visited = []\n        self.bfs(root, visited)\n        max_sum = level = 0\n        \n        for key, value in self.sums.items():\n            if value > max_sum:\n                max_sum = value\n                level = key\n        \n        return level", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        q = deque([(root, 1)])\n        res = defaultdict(int)\n        while q:\n            n, l = q.popleft()\n            res[l] += n.val\n            if n.left:\n                q.append((n.left, l+1))\n            if n.right:\n                q.append((n.right, l+1))\n        argmax = 1\n        vmax = root.val\n        for k, v in list(res.items()):\n            if v > vmax:\n                argmax = k\n                vmax = v\n        return argmax\n            \n            \n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        max, level, maxLevel = -float('inf'), 0, 0\n        q = collections.deque()\n        q.append(root)\n        while q:\n            level += 1\n            sum = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                sum += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if max < sum:\n                max, maxLevel = sum, level        \n        return maxLevel", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        def get_level_sums(root: TreeNode, level : int, level_sums : dict):\n            if not root:\n                return\n            if level not in list(level_sums.keys()):\n                level_sums[level] = root.val\n            else:\n                level_sums[level] += root.val\n            get_level_sums(root.left, level + 1, level_sums)\n            get_level_sums(root.right, level + 1, level_sums)\n            \n        if not root:\n            return 0\n        level_sums = {}\n        get_level_sums(root, 1, level_sums)\n        print (level_sums)\n        max_key = 0\n        max_value = min(level_sums.values())\n        for k in list(level_sums.keys()):\n            if level_sums[k] > max_value:\n                max_key = k\n                max_value = level_sums[k]\n        return max_key\n                \n        \n        \n", "from collections import defaultdict\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        bfs = defaultdict(list)\n        \n        def traverse(head, n):\n            if head is None:\n                return\n            bfs[n].append(head.val)\n            traverse(head.left, n+1)\n            traverse(head.right, n+1)\n        \n        traverse(root, 1)\n        \n        s=-9999\n        l=0\n        for i in bfs:\n            bfs[i]=sum(bfs[i])\n            if bfs[i]>s:\n                s=bfs[i]\n                l=i\n        return l", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        stack = [root]\n        record = {\n            0: root.val\n        }\n        length = 0\n        while len(stack) > 0:\n            tmp = []\n            val = 0\n            length += 1\n            for s in stack:\n                if s.left:\n                    tmp.append(s.left)\n                    val += s.left.val\n                if s.right:\n                    tmp.append(s.right)\n                    val += s.right.val\n            record[length] = val\n            stack = tmp[:]\n        max_val = max(list(record.values()))\n        for i in range(length):\n            if record[i] == max_val:\n                return i+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        level_sums = [[root.val]]\n        \n        q = [root]\n        \n        while q:\n            temp = []\n            for _ in range(len(q)):\n                \n                node = q.pop(0)\n                \n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                    \n                temp.append(node.val)\n            \n            level_sums.append(temp)\n            \n        sums = [sum(l) for l in level_sums]\n        \n        return sums.index(max(sums))\n                \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        maxVal = root.val\n        ans = level = 1\n        stack = [root]\n        while True:\n            nextStack = []\n            level += 1\n            sumVal = 0\n            for item in stack:\n                if item.left:\n                    sumVal += item.left.val\n                    nextStack.append(item.left)\n                if item.right:\n                    sumVal += item.right.val\n                    nextStack.append(item.right)\n            #print(sumVal, level)\n            if nextStack:\n                stack = nextStack\n                if sumVal > maxVal:\n                    maxVal = sumVal\n                    ans = level\n            else:\n                break           \n            \n        return ans\n                    \n                    \n                \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.sols = {}\n        \n    def nodes_at_level(self, root, level, target, nodes):\n        if root == None:\n            return nodes\n        \n        if level == target:\n            nodes.append(root)\n            return nodes\n        \n        self.nodes_at_level(root.left, level+1, target, nodes)\n        self.nodes_at_level(root.right, level+1, target, nodes)\n        \n        return nodes\n    def sum_at_level(self, root, level, target):\n        if root == None:\n            return 0\n        \n        \n        if level == target:\n            return root.val\n        \n        result = sum((self.sum_at_level(root.left, level +1, target), self.sum_at_level(root.right, level+1, target)))\n        \n        return result\n        \n    def level_count(self, root):\n        if root == None:\n            return 0\n        \n        if root in self.sols:\n            return self.sols[root]\n        \n        result = 1 + max(self.level_count(root.left), self.level_count(root.right))\n        \n        self.sols[root] = result\n        \n        return result\n    \n    def all_children(self, nodes):\n        for node in nodes:\n            if node.left != None:\n                yield node.left\n            if node.right != None:\n                yield node.right\n    \n    def maxLevelSum(self, root: TreeNode) -> int:\n        levels = {1: [root]}\n        \n        do_more = True\n        cur = 1\n        while do_more:\n            nodes = levels[cur]\n            cur += 1\n            new_nodes = list(self.all_children(nodes))\n            levels[cur] = new_nodes\n            \n            do_more = len(new_nodes) > 0\n        \n        max_index = 1    \n        max_val = sum([x.val for x in levels[max_index]])\n        \n        for key in levels:\n            level_sum = sum([x.val for x in levels[key]])\n            if level_sum > max_val:\n                max_index = key\n                max_val = level_sum\n        \n        #for key in levels:\n        #    print(key, list(map(lambda x: x.val, levels[key])))\n        \n        return max_index\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport queue\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        q = collections.deque()\n        q.append(root)\n        maxlevel, level, max = 0, 0, -float('inf')\n        while q:\n            total = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                total += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            level += 1\n            if total > max:\n                max, maxlevel = total, level\n        return maxlevel", "from collections import defaultdict\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef rec(root, d, lvl):\n    d[lvl]+=root.val\n    if root.left:\n        rec(root.left, d, lvl+1)\n    if root.right:\n        rec(root.right, d, lvl+1)\n\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        d = defaultdict(int)\n        rec(root,d,1)\n        ans = 1\n        for i in d:\n            if d[i] > d[ans]:\n                ans = i\n                \n                \n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    import collections\n    def maxLevelSum(self, root: TreeNode) -> int:\n#         bfs to do level traversal and calculate sum, update level if sum is larger\n        levelSum = float('-inf')\n        res = 0\n        queue = collections.deque()\n        queue.append((1, root))\n        while len(queue) != 0:\n            curr_sum = 0\n            for _ in range(len(queue)):\n                currl, curr = queue.popleft()\n                curr_sum += curr.val\n                if curr.left:\n                    queue.append((currl + 1, curr.left))\n                if curr.right:\n                    queue.append((currl + 1, curr.right))\n            if curr_sum > levelSum:\n                res = currl\n                levelSum = curr_sum\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        queue = deque()\n        queue.append(root)\n        \n        bfs = []\n        \n        level_sum = 0\n        level_nodes = 1\n        \n        sum_of_levels = []\n        \n        while queue:\n            node = queue.popleft()\n            bfs.append(node)\n            level_sum += node.val\n            \n            if node.left:\n                queue.append(node.left)\n            \n            if node.right:\n                queue.append(node.right)\n            \n            level_nodes -= 1\n            if level_nodes == 0:\n                sum_of_levels.append(level_sum)\n                level_sum = 0\n                level_nodes = len(queue)\n        \n        return sum_of_levels.index(max(sum_of_levels)) + 1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        def get_size(node):\n            if node is None: return 0\n            return max(get_size(node.left), get_size(node.right)) + 1\n        \n        levels = [0] * get_size(root)\n        def split(node, level):\n            nonlocal levels\n            if node is None: return\n            levels[level] += node.val\n            split(node.left, level + 1)\n            split(node.right, level + 1)\n        \n        split(root, 0)\n        return levels.index(max(levels)) + 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        sums = collections.defaultdict(int)\n        visited = []\n        \n        def dfs(root, level):\n            if root:\n                sums[level] += root.val\n                visited.append(root)\n\n                dfs(root.right, level + 1)\n                dfs(root.left, level + 1)\n        \n        dfs(root, 1)\n        return max(sums, key=sums.get)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        import collections\n        queue = collections.deque([root])\n        maxx = root.val\n        ans = 0\n        level = 1\n        while queue:\n            summ = 0\n            for i in range(len(queue)):\n                n = queue.popleft()\n                if not n:\n                    continue\n                summ += n.val\n                queue.append(n.left)\n                queue.append(n.right)\n            if summ > maxx:\n                ans = level\n                maxx = summ\n            level += 1\n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        if not root:\n            return None\n        \n        bfs_queue = [root]\n        current_sum = 0\n        max_level = 0\n        level = 0\n        \n        while True:\n            temp = []\n            level += 1\n            row_sum = 0\n            \n            while bfs_queue:\n                popped = bfs_queue.pop()\n                row_sum += popped.val\n                \n                if popped.left:\n                    temp.append(popped.left)\n                    \n                if popped.right:\n                    temp.append(popped.right)\n                    \n                    \n            if not temp:\n                if row_sum > current_sum:\n                    max_level = level\n                    current_sum = row_sum\n                break\n            \n            else:\n                if row_sum > current_sum:\n                    max_level = level\n                    current_sum = row_sum\n                bfs_queue = temp\n                \n        \n        return max_level\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        row = [root]\n        max_sum = root.val\n        rv = row_count = 1\n        \n        while any(row): \n            new_row = []\n            row_sum = 0\n            \n            for node in row: \n                for child in (node.left, node.right):\n                    if child: \n                        new_row.append(child)\n                        row_sum += child.val\n            \n            if new_row: \n                row_count += 1 \n                \n            if row_sum > max_sum: \n                max_sum = row_sum \n                rv = row_count \n                \n            #max_sum = max(max_sum, row_sum)\n            row = new_row\n        \n        return rv\n                    \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Node:\n    def __init__(self, treeNode, level):\n        self.treeNode = treeNode\n        self.level = level\n\nfrom collections import deque\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        queue = deque([Node(root, 1)])\n        level = 1\n        total = 0\n        totalMax = 0\n        ans = 1\n        while queue:\n            cur = queue.popleft()\n            if cur.level != level:\n                if total > totalMax:\n                    totalMax = total\n                    ans = level\n                level = cur.level\n                total = 0\n                \n            total += cur.treeNode.val\n            if cur.treeNode.left:\n                queue.append(Node(cur.treeNode.left, cur.level + 1))\n            if cur.treeNode.right:\n                queue.append(Node(cur.treeNode.right, cur.level + 1))\n        \n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        \n        store = {}\n        \n        def helper(node, level):\n            if node:\n                helper(node.left,level+1)\n                helper(node.right,level+1)\n                \n                if level in store:\n                    store[level].append(node.val)\n                else:\n                    store[level] = [node.val]\n                    \n                return node\n            \n        helper(root,1)\n        \n        for i in list(store.keys()):\n            store[i] = sum(store[i])\n            \n        mx = sorted(list(store.items()), key=lambda x: (x[1]))\n        return(mx[-1][0])\n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        lvl = 1\n        sums = [[root.val, 1]]\n        \n        # apply bfs\n        queue = [root]\n        tmp = []\n        lvl += 1\n        while queue:\n            node = queue.pop(0)\n            if node.left is not None:\n                tmp.append(node.left)\n            if node.right is not None:\n                tmp.append(node.right)\n                \n            if len(queue) == 0:\n                res = 0\n                for i in tmp:\n                    queue.append(i)\n                    res += i.val\n                    \n                if len(queue) != 0:\n                    sums.append([res, lvl])\n                tmp = []\n                lvl += 1\n                \n        sums.sort(key = lambda x: x[0])\n        return sums[-1][1]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        stack=[[root,1]]\n        l=[]\n        while stack:\n            ele=stack.pop()\n            node=ele[0]\n            val=ele[1]\n            if(node):\n                stack.append([node.left,val+1])\n                stack.append([node.right,val+1])\n                if(len(l)<val):\n                    l.append(node.val)\n                else:\n                    l[val-1]+=node.val\n        maxx=max(l)\n        for i in range(len(l)):\n            if(l[i]==maxx):\n                return i+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport queue\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        def dfs(root, height):\n            if not root: return None\n            if len(d) == height:\n                d.append(root.val)\n            else:\n                d[height] += root.val\n            dfs(root.left, height+1)\n            dfs(root.right, height+1)\n        \n        d = []\n        dfs(root, 0)\n        return d.index(max(d))+1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        sums,ans={},[float(\\\"inf\\\"),float(\\\"-inf\\\")]\n        def traverse(root,lvl):\n            if root:\n                if lvl not in sums: sums[lvl]=0\n                sums[lvl]+=root.val\n                traverse(root.left,lvl+1)\n                traverse(root.right,lvl+1)\n        traverse(root,1)\n        return sorted(sums.items(),key=lambda x: (-x[1],x[0]))[0][0]"]
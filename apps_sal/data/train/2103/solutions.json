["#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = [()]*self.gn\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps[i] = (min, max, i)\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        answer = \"\"\n        for (i, n) in enumerate(self.result):\n            if n is None:\n                return \"No\"\n            answer += (\" \" if i > 0 else \"\") + str(n)\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 100000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()", "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        answer = \"\"\n        for (i, n) in enumerate(self.result):\n            if n is None:\n                return \"No\"\n            answer += (\" \" if i > 0 else \"\") + str(n)\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 50000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()", "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        for n in self.result:\n            if n is None:\n                return \"No\"\n        answer = \" \".join([str(n) for n in self.result])\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 20000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()", "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        for n in self.result:\n            if n is None:\n                return \"No\"\n        answer = \" \".join([str(n) for n in self.result])\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 20000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n\n__starting_point()", "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        for n in self.result:\n            if n is None:\n                return \"No\"\n        answer = \" \".join([str(n) for n in self.result])\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 20000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate() + \"\\n\")\n\n__starting_point()", "#!/usr/bin/env python\n# 556D_fug.py - Codeforces.com 556D Fug quiz\n#\n# Copyright (C) 2015 Sergey\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nInput\n\nThe first line contains integers n and m - the number of islands and bridges.\n\nNext n lines each contain two integers li and ri - the coordinates of the\nisland endpoints.\n\nThe last line contains m integer numbers a1..am - the lengths of the bridges\nthat Andrewid got.\nOutput\n\nIf it is impossible to place a bridge between each pair of adjacent islands\nin the required manner, print on a single line \"No\" (without the quotes)\n, otherwise print in the first line \"Yes\" (without the quotes), and in the\nsecond line print n-1 numbers b1, bn-1, which mean that between islands\ni and i+1 there must be used a bridge number bi.\n\nIf there are multiple correct answers, print any of them. Note that in this\nproblem it is necessary to print \"Yes\" and \"No\" in correct case\n\"\"\"\n\n# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = str(i + 1)\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        for n in self.result:\n            if n is None:\n                return \"No\"\n        answer = \"Yes\\n\"\n        answer += \" \".join(self.result)\n\n        return answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return sys.stdin.readline()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 10000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(calculate())\n\n__starting_point()", "# Standard libraries\nimport unittest\nimport sys\nimport re\n\n# Additional libraries\nimport heapq\n\n\n###############################################################################\n# Fug Class\n###############################################################################\n\n\nclass Fug:\n    \"\"\" Fug representation \"\"\"\n\n    def __init__(self, args):\n        \"\"\" Default constructor \"\"\"\n        self.list = args[0]\n        self.alist = args[1]\n        self.gn = len(self.list) - 1\n\n        # Sorted list of bridges\n        self.asrt = sorted((n, i) for i, n in enumerate(self.alist))\n\n        # List of gaps between islands\n        self.gaps = []\n        prevli = self.list[0]\n        for i in range(self.gn):\n            li = self.list[i+1]\n            min = li[0] - prevli[1]\n            max = li[1] - prevli[0]\n            self.gaps.append((min, max, i))\n            prevli = li\n\n        # Sorted list of gaps between islands\n        self.gsrt = sorted(self.gaps)\n\n        self.gmin = [n[0] for n in self.gsrt]\n        self.result = [None]*self.gn\n        self.heap = []\n\n    def iterate(self):\n\n        j = 0\n        for (b, i) in self.asrt:\n\n            # Traverse gmin array\n            while j < self.gn and self.gmin[j] <= b:\n                it = self.gsrt[j]\n                heapq.heappush(self.heap, (it[1], it[0], it[2]))\n                j += 1\n\n            # Update result and remove the element from lists\n            if self.heap:\n                (mmax, mmin, mi) = self.heap[0]\n                if mmin <= b and mmax >= b:\n                    self.result[mi] = i + 1\n                    heapq.heappop(self.heap)\n\n            yield\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        for it in self.iterate():\n            pass\n\n        for n in self.result:\n            if n is None:\n                return \"No\"\n        answer = \" \".join([str(n) for n in self.result])\n\n        return \"Yes\\n\" + answer\n\n\n###############################################################################\n# Executable code\n###############################################################################\n\n\ndef get_inputs(test_inputs=None):\n\n    it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n    def uinput():\n        \"\"\" Unit-testable input function wrapper \"\"\"\n        if it:\n            return next(it)\n        else:\n            return input()\n\n    # Getting string inputs. Place all uinput() calls here\n    num = [int(s) for s in uinput().split()]\n    list = [[int(s) for s in uinput().split()] for i in range(num[0])]\n    alist = [int(s) for s in uinput().split()]\n\n    # Decoding inputs into a list\n    inputs = [list, alist]\n\n    return inputs\n\n\ndef calculate(test_inputs=None):\n    \"\"\" Base class calculate method wrapper \"\"\"\n    return Fug(get_inputs(test_inputs)).calculate()\n\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_sample_tests(self):\n        \"\"\" Quiz sample tests. Add \\n to separate lines \"\"\"\n\n        # Sample test 1\n        test = \"4 4\\n1 4\\n7 8\\n9 10\\n12 14\\n4 5 3 8\"\n        self.assertEqual(calculate(test), \"Yes\\n2 3 1\")\n        self.assertEqual(\n            get_inputs(test),\n            [[[1, 4], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n\n        # My tests\n        test = \"5 5\\n1 1\\n2 7\\n8 8\\n10 10\\n16 16\\n1 1 5 6 2\"\n        self.assertEqual(calculate(test), \"Yes\\n1 2 5 4\")\n\n        # Other tests\n        test = \"2 2\\n11 14\\n17 18\\n2 9\"\n        self.assertEqual(calculate(test), \"No\")\n\n        # Other tests\n        test = (\n            \"2 1\\n1 1\\n1000000000000000000 1000000000000000000\" +\n            \"\\n999999999999999999\")\n        self.assertEqual(calculate(test), \"Yes\\n1\")\n\n        test = (\"5 9\\n1 2\\n3 3\\n5 7\\n11 13\\n14 20\\n2 3 4 10 6 2 6 9 5\")\n        self.assertEqual(calculate(test), \"Yes\\n1 6 3 2\")\n\n        size = 20000\n        test = str(size) + \" \" + str(size) + \"\\n\"\n        x = size*1000\n        for i in range(size):\n            x += 2\n            test += str(x) + \" \" + str(x+1) + \"\\n\"\n        for i in range(size):\n            test += str(2) + \" \"\n        self.assertEqual(calculate(test)[0], \"Y\")\n\n    def test_Fug_class__basic_functions(self):\n        \"\"\" Fug class basic functions testing \"\"\"\n\n        # Constructor test\n        d = Fug([[[1, 5], [7, 8], [9, 10], [12, 14]], [4, 5, 3, 8]])\n        self.assertEqual(d.list[0][0], 1)\n        self.assertEqual(d.alist[0], 4)\n\n        # Sort bridges\n        self.assertEqual(d.asrt[0], (3, 2))\n\n        # Sort Gaps\n        self.assertEqual(d.gaps[0], (2, 7, 0))\n        self.assertEqual(d.gsrt[0], (1, 3, 1))\n\n        iter = d.iterate()\n        next(iter)\n        self.assertEqual(d.gmin, [1, 2, 2])\n        self.assertEqual(d.heap, [(5, 2, 2), (7, 2, 0)])\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    print(calculate())\n__starting_point()"]
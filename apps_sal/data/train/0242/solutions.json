["class Solution:\n    def isvalid(self,C):\n        if len(C)>2:\n            return False\n        if len(C)==1:\n            a = min(C)\n            if a==1 or C[a]==1:\n                # EXPLANATION:\n                #   a==1   : All lengths are unitary like A=[1,2,3,4,...], so poping anything is fine\n                #   C[a]==1: We have a unique length occurence like A=[4,4,4,4,...], so poping anything is fine too\n                return True\n            # EXPLANATION:\n            #     For all other cases of len(C)==1, we'd end with a mistmatch like [1,1,2,2,2], or [1,1,1], so we need to \\\"return False\\\" right away\n            return False\n        #\n        # --------- len(D)==2 --------------\n        #\n        a,b = sorted(C)\n        # -> Attempt removing from \\\"a\\\"\n        if a==C[a]==1: \n            # EXPLANATION:\n            #   If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\n            #       The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #           -> If we had anything else, we would be stuck with a contradiction (so we move forward to removing \\\"b\\\")\n            return True\n        # -> Attempt removing from \\\"b\\\"\n        # EXPLANATION:\n        #     This only works if there is a single chain of length \\\"b\\\", and poping one element makes a chain of length \\\"a\\\".\n        #     In other words, if works when \\\"C[b]==1 and (b-1)==a\\\"\n        return True if ( C[b]==1 and (b-1)==a ) else False\n    def remove(self,B,x):\n        if B[x]==1:\n            B.pop(x)\n        else:\n            B[x] -= 1\n    def maxEqualFreq(self, A):\n        remove = self.remove\n        B = Counter(A)          # Count number of repetitions/length (per value) [1,1,2,2,3,3,4] = {1:2, 2:2, 3:2, 4:1}\n        C = Counter(B.values()) # Count number of times a length has been seen   [1,1,2,2,3,3,4] = { 1:1, 2:3 }\n        #\n        # -> Iterate Reversed, to get best answer at the first match\n        for i in reversed(range(len(A))):\n            # -> Check if C_dictionary is a valid answer\n            if self.isvalid(C):\n                return i+1\n            #\n            # -> Remove current element \\\"x\\\" from our System\n            x    = A[i]\n            # B[x] =  N_repetitions for \\\"x\\\"\n            #\n            remove(C,B[x]) # Deregister old N_repetitions\n            remove(B,  x ) # Deregister one instance of \\\"x\\\" (from N_repetitions)\n            if B[x]:\n                # -> If N_repetitions>0 exists, register shortened length\n                C[B[x]] += 1\n        return 0", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        n = len(A)\n        count = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        for i in range(n):\n            count[A[i]] +=1\n            freq[count[A[i]]]+=1\n        \n        for i in range(n-1, 0, -1):\n            # If include A[i]\n            if count[A[i]] * freq[count[A[i]]] == i:\n                return i + 1\n            freq[count[A[i]]] -= 1\n            count[A[i]] -= 1\n            if count[A[i-1]] * freq[count[A[i-1]]] == i:\n                return i + 1\n            \n        return 1\n            \n        \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n\n        for n in nums:\n            count[n] += 1\n            freq[count[n]] += 1\n\n        for i in range(len(nums)-1, 0, -1):\n            # 2 case, case 1 , keep i, then you have to remove another on from 0 -- i-1\n            if count[nums[i]] * freq[count[nums[i]]] == i:\n                return i+1\n            freq[count[nums[i]]] -= 1\n            count[nums[i]] -= 1\n\n            if count[nums[i-1]] * freq[count[nums[i-1]]] == i:\n                return i+1\n\n\n        return 1\n\n\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        res = 0\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n                \n            if count == i:\n                res = max(res,i + 1)\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        res = 0\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            if count == i:\n                res = max(res,i + 1)\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        res = 0\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            \n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n                \n            if count == i:\n                res = max(res,i + 1)\n        return res\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        res = 0\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            \n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            elif count == i:\n                res = max(res,i + 1)\n        return res\n", "from collections import Counter, defaultdict\n\nclass Solution:\n  def maxEqualFreq(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    # d: count -> values has such counts\n    d = defaultdict(set)\n    for x in counter:\n      d[counter[x]].add(x)\n    # O(n), reverse go through nums updating count of counts\n    i = len(nums)\n    while d:\n      if len(d) == 1:\n        k = list(d.keys())[0]\n        if k == 1 or len(d[k]) == 1:\n          return i\n      if len(d) == 2:\n        y, z = sorted(d.keys())\n        if (y == 1 and len(d[y]) == 1) or (y + 1 == z and len(d[z]) == 1):\n          return i\n      i -= 1\n      # update counter and count of counts\n      x = nums[i]\n      d[counter[x]].remove(x)\n      if not d[counter[x]]:\n        d.pop(counter[x])\n      counter[x] -= 1\n      if counter[x] > 0:\n        d[counter[x]].add(x)\n    return 0", "from collections import Counter, defaultdict\n\nclass Solution:\n  def maxEqualFreq(self, nums: List[int]) -> int:\n    counter = Counter(nums)\n    # d: count -> values has such counts\n    d = defaultdict(set)\n    for x in counter:\n      d[counter[x]].add(x)\n    # O(n), reverse go through nums updating count of counts\n    n = len(nums)\n    while d:\n      if len(d) == 1:\n        k = list(d.keys())[0]\n        if k == 1 or len(d[k]) == 1:\n          return n\n      if len(d) == 2:\n        y, z = sorted(d.keys())\n        if (y == 1 and len(d[y]) == 1) or (y + 1 == z and len(d[z]) == 1):\n          return n\n      n -= 1\n      # update counter and count of counts\n      x = nums[n]\n      d[counter[x]].remove(x)\n      if not d[counter[x]]:\n        d.pop(counter[x])\n      counter[x] -= 1\n      if counter[x] > 0:\n        d[counter[x]].add(x)\n    return 0\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        num_freq = {}\n        freq_freq = {}\n        for num in nums:\n            num_freq[num] = num_freq.get(num, 0) + 1\n        for f in num_freq.values():\n            freq_freq[f] = freq_freq.get(f, 0) + 1\n        \n        n = len(nums)\n        if len(freq_freq) == 2:\n            key1, key2 = list(freq_freq.keys())\n            if freq_freq[key1] == 1 and (key1 == 1 or key1 == key2 + 1):\n                return n\n            if freq_freq[key2] == 1 and (key2 == 1 or key2 == key1 + 1):\n                return n\n        if len(freq_freq) == 1:\n            key = list(freq_freq.keys())[0]\n            if key == 1 or freq_freq[key] == 1:\n                return n\n        \n        for i in range(n):\n            num = nums[n - i - 1]\n            prev_freq = num_freq[num]\n            num_freq[num] -= 1\n            freq_freq[prev_freq] -= 1\n            if freq_freq[prev_freq] == 0:\n                del freq_freq[prev_freq]\n            if num_freq[num] != 0:\n                freq_freq[num_freq[num]] = freq_freq.get(num_freq[num], 0) + 1\n            if len(freq_freq) == 2:\n                key1, key2 = list(freq_freq.keys())\n                if freq_freq[key1] == 1 and (key1 == 1 or key1 == key2 + 1):\n                    return n - i - 1\n                if freq_freq[key2] == 1 and (key2 == 1 or key2 == key1 + 1):\n                    return n - i - 1\n            if len(freq_freq) == 1:\n                key = list(freq_freq.keys())[0]\n                if key == 1 or freq_freq[key] == 1:\n                    return n - i - 1\n        return 0", "from collections import defaultdict\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        ans = 0\n        max_f = 0\n        counter, freq_counter = defaultdict(int), defaultdict(int)\n        for idx, val in enumerate(nums):\n            counter[val] += 1\n            max_f = max(max_f, counter[val])\n            freq_counter[counter[val]-1] -= 1\n            freq_counter[counter[val]] += 1\n            if max_f == 1 or max_f * freq_counter[max_f] == idx or ((max_f-1) * (freq_counter[max_f-1] + 1)) == idx:\n                ans = max(ans, idx+1)\n        return ans", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        freq = defaultdict(int)\n        count = defaultdict(int)\n        res = 0\n        for i, n in enumerate(nums, 1):\n            freq[count[n]] -= 1\n            freq[count[n] + 1] += 1\n            count[n] += 1\n            \n            if freq[count[n]] * count[n] == i and i < len(nums):\n                res = i + 1\n            \n            d = i - freq[count[n]] * count[n]\n            if d in [1, count[n]+1] and freq[d] == 1:\n                res = i\n        return res\n            \n        \n        \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.Counter()\n        freq = collections.Counter()\n        res = 0\n        \n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            elif count == i:\n                res = max(res,i + 1)\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts, freq = collections.Counter(), collections.Counter()\n        \n        res = 0\n        for i, num in enumerate(nums):\n            counts[num] += 1\n            freq[counts[num]] += 1\n            \n            count = freq[counts[num]] * counts[num]\n            \n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res, i + 2)\n            elif count == i:\n                res = max(res, i + 1)\n\n        return res\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        freq_count, count, res, maxf = defaultdict(int), defaultdict(int), 0, 0\n        \n        for i, a in enumerate(nums):\n            count[a] += 1\n            freq_count[count[a]-1] -= 1\n            freq_count[count[a]] += 1\n            maxf = max(maxf, count[a])\n            if maxf==1 or maxf*freq_count[maxf]+1==i+1 or (maxf-1)*freq_count[maxf-1]+maxf==i+1:\n                res = i+1\n        \n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count = collections.Counter()\n        freq = [0 for _ in range(len(nums) + 1)]\n        res = 0\n        for n, a in enumerate(nums, 1):\n            freq[count[a]] -= 1\n            freq[count[a] + 1] += 1\n            c = count[a] = count[a] + 1\n            if freq[c] * c == n and n < len(nums):\n                res = n + 1\n            d = n - freq[c] * c\n            if d in [c + 1, 1] and freq[d] == 1:\n                res = n\n        return res", "from collections import defaultdict\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        n = len(nums)\n        elemfreq = defaultdict(int)\n        freqcnt = defaultdict(int)\n        \n        i = 0\n        n_distinct = 0\n        maxfreq = 0\n        \n        maxprefix = None\n        \n        \n        \n        while i != n:\n            x = nums[i]\n            \n            if elemfreq[x] == 0:\n                n_distinct += 1\n                elemfreq[x] += 1\n                freqcnt[1] += 1\n            else:\n                freqcnt[elemfreq[x]] -= 1\n                freqcnt[elemfreq[x]+1] += 1\n                elemfreq[x] += 1\n            \n            maxfreq = max(maxfreq, elemfreq[x])\n            \n            if maxfreq == 1:\n                maxprefix = i\n            elif (freqcnt[1] == 1) and (freqcnt[maxfreq] == n_distinct-1):\n                maxprefix = i\n            elif (freqcnt[maxfreq] == 1) and (freqcnt[maxfreq-1] == n_distinct-1):\n                maxprefix = i\n            \n            i += 1\n            \n        return maxprefix+1", "class Solution:\n    def maxEqualFreq(self, nums) -> int:\n        res = maxFrq = 0\n        count = defaultdict(int)\n        freq = defaultdict(int)\n        for i, num in enumerate(nums):\n            cnt = count[num]\n            freq[cnt] -= 1\n            \n            cnt += 1\n            count[num] = cnt\n\n            freq[cnt] += 1\n            maxFrq = max(maxFrq, cnt)\n            if (maxFrq == 1) or (maxFrq*freq[maxFrq]) == i or ((maxFrq-1)*(freq[maxFrq-1] + 1)) == i:\n                res = i + 1\n        return res\n\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        countMap, freqMap, maxFreq, maxIndex = defaultdict(int), defaultdict(int), 0, 0\n        \n        for index, x in enumerate(nums):\n            freqMap[countMap[x]] -= 1\n            countMap[x] += 1\n            freqMap[countMap[x]] += 1\n            \n            maxFreq = max(maxFreq, countMap[x])\n            \n            if maxFreq*freqMap[maxFreq] == index or (maxFreq-1)*(freqMap[maxFreq-1]+1) == index or maxFreq == 1: \n                maxIndex = index+1\n                \n        return maxIndex\n            \n", "class Solution:     \n    def maxEqualFreq(self, A):\n        count = collections.Counter()\n        freq = [0 for _ in range(len(A) + 1)]\n        res = 0\n        for n, a in enumerate(A, 1):\n            freq[count[a]]-=1\n            freq[count[a]+1]+=1\n            c = count[a]=count[a]+1\n            if freq[c]*c==n and n<len(A):\n                res = n+1\n            d = n-freq[c]*c\n            if d in [c+1,1] and freq[d]==1:\n                res = n\n        return res\n\n            \n\n", "from collections import Counter\n\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        dic = Counter(nums)\n        dicdic = Counter(list(dic.values()))\n        if len(nums) == 2:\n            return 2\n        \n        while True:\n            if len(dicdic) == 1 and (min(dicdic) == 1 or min(dicdic.values()) == 1):\n                return len(nums)                \n            if len(dicdic) == 2:\n                max_dicdic_keys = max(dicdic)\n                min_dicdic_keys = min(dicdic)\n                if  max_dicdic_keys - min_dicdic_keys == 1 and dicdic[max_dicdic_keys] == 1:\n                    return len(nums)\n                if min_dicdic_keys == 1 and dicdic[min_dicdic_keys] == 1:\n                    return len(nums)\n            cleanup = nums.pop()\n            if dic[cleanup] - 1 == 0:\n                del dic[cleanup]\n            else:\n                dic[cleanup] = dic[cleanup] -1\n            dicdic = Counter(list(dic.values()))\n        \n        return\n", "class Solution:\n    def maxEqualFreq(self, nums) -> int:\n        res = maxFrq = 0\n        count = defaultdict(int)\n        freq = defaultdict(int)\n        for i, num in enumerate(nums):\n            cnt = count[num]\n            freq[cnt] -= 1\n            count[num] += 1\n            freq[cnt+1] += 1\n            \n            maxFrq = max(maxFrq, cnt+1)\n            if (maxFrq == 1) or (maxFrq*freq[maxFrq]) == i or ((maxFrq-1)*(freq[maxFrq-1] + 1)) == i:\n                res = i + 1\n        return res\n\n", "class Solution:\n\n        \n    def maxEqualFreq(self, A):\n        count = collections.Counter()\n        freq = [0 for _ in range(len(A) + 1)]\n        res = 0\n        for n, a in enumerate(A, 1):\n            freq[count[a]] -= 1\n            freq[count[a] + 1] += 1\n            c = count[a] = count[a] + 1\n            if freq[c] * c == n and n < len(A):\n                res = n + 1\n            d = n - freq[c] * c\n            if d in [c + 1, 1] and freq[d] == 1:\n                res = n\n        return res\n            \n\n", "from collections import defaultdict\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counter, freq = defaultdict(int), defaultdict(int)\n        max_f = 0\n        ans = 0\n        for idx, num in enumerate(nums):\n            counter[num] += 1\n            freq[counter[num]-1] -= 1\n            freq[counter[num]] += 1\n            max_f = max(max_f, counter[num])\n            if freq[max_f] * max_f == idx or max_f == 1 or (max_f-1)*(freq[max_f-1] + 1) == idx:\n                ans = idx+1\n        return ans", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.Counter()\n        freq = collections.Counter()\n        res = 0\n        for i,num in enumerate(nums):\n            counts[num] += 1\n            freq[counts[num]] += 1\n            \n            count = freq[counts[num]] * counts[num]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            elif count == i:\n                res = max(res,i + 1)\n                \n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt, freq = collections.defaultdict(int), collections.defaultdict(int)\n        maxF, res = 0, 0\n        for i, num in enumerate(nums):\n            cnt[num] += 1\n            freq[cnt[num]-1] -= 1\n            freq[cnt[num]] += 1\n            maxF = max(maxF, cnt[num])\n            if maxF * freq[maxF] == i or (maxF-1) * (freq[maxF-1]+1) == i or maxF == 1:\n                res = i + 1\n        return res", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        count = collections.Counter()\n        freq = [0 for _ in range(len(A) + 1)]\n        res = 0\n\n        for n, a in enumerate(A, 1):\n            freq[count[a]] -= 1\n            freq[count[a] + 1] += 1\n            c = count[a] = count[a] + 1\n            if freq[c] * c == n and n < len(A):\n                res = n + 1\n            d = n - freq[c] * c\n            if d in [c + 1, 1] and freq[d] == 1:\n                res = n\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counter, pattern = {}, {}\n        rtn = 0\n        if len(nums) <= 3:\n            return len(nums)\n        for i in range(len(nums)):\n            n = nums[i]\n            if n in counter:\n                t = counter[n]\n                counter[n] += 1\n            else:\n                t = 0\n                counter[n] = 1\n                \n            if t > 0:\n                pattern[t] -= 1\n                if pattern[t] == 0:\n                    del pattern[t]\n                \n            if t+1 in pattern:\n                pattern[t+1] += 1\n            else:\n                pattern[t+1] = 1\n            if len(pattern) == 1:\n                for k, v in list(pattern.items()):\n                    if k == 1 or v == 1:\n                        rtn = max(rtn, i)\n            elif len(pattern) == 2:\n                if 1 in pattern and pattern[1] == 1:\n                    rtn = max(i, rtn)\n                [m1, m2] = [(k,v) for k,v in list(pattern.items())]\n                if (m1[0] - m2[0] == 1 and m1[1] == 1) or (m2[0] - m1[0] == 1 and m2[1] == 1):\n                    rtn = max(rtn, i)\n        return rtn + 1\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt, freq = collections.defaultdict(int), collections.defaultdict(int)\n        maxF, res = 0, 0\n        for i,num in enumerate(nums):\n            cnt[num] += 1\n            freq[cnt[num]-1] -= 1\n            freq[cnt[num]] += 1\n            maxF = max(maxF,cnt[num])\n            if maxF * freq[maxF] == i or (maxF-1) * (freq[maxF-1]+1) == i or maxF == 1:\n                res = i + 1\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        N = len(nums)\n        freqCount = [0 for i in range(N+1)]\n        umap = dict()\n        minFreq = 1\n        maxFreq = 1\n        umap[nums[0]] = 1\n        freqCount[1] = 1\n        result = 1\n        \n        for i in range(1, N):\n            if nums[i] not in umap:\n                umap[nums[i]] = 1\n                minFreq = 1\n            else:\n                freqCount[umap[nums[i]]] -= 1\n                if freqCount[umap[nums[i]]] == 0 and minFreq == umap[nums[i]]:\n                    minFreq = umap[nums[i]] + 1\n                umap[nums[i]] += 1\n            freqCount[umap[nums[i]]] += 1\n            \n            if umap[nums[i]] > maxFreq:\n                maxFreq = umap[nums[i]]\n            \n            if maxFreq == minFreq+1 and freqCount[maxFreq] == 1:\n                result = i+1\n            if maxFreq == minFreq and freqCount[maxFreq] == i+1:\n                result = i + 1\n            if maxFreq == minFreq and freqCount[maxFreq] == 1:\n                result = i + 1\n            if maxFreq * freqCount[maxFreq] == i:\n                result = i + 1\n                \n        return result\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        d = Counter(nums)\n        #print(d)\n        \n        for i in reversed(range(len(nums))):\n            vlist = list(d.values())\n            #print(vlist)\n            s = list(set(vlist))\n            \n            if len(s) == 1:\n                if s[0] == 1:\n                    return i+1\n                if len(vlist) == 1:\n                    return i + 1\n                \n            if len(s) == 2:\n                if 1 in s:\n                    if vlist.count(1) == 1:\n                        return i+1\n\n                maxint = max(s[0],s[1])\n                if vlist.count(maxint) == 1 and abs(s[1]-s[0]) == 1:\n                    return i+1\n            \n            if d[nums[i]] == 1:\n                d.pop(nums[i])\n            else:\n                d[nums[i]] -= 1\n            \n        \n        return 1", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.Counter()\n        freq = collections.Counter()\n        res = 0\n        for i in range(len(nums)):\n            counts[nums[i]] += 1\n            freq[counts[nums[i]]] += 1\n            \n            count = counts[nums[i]] * freq[counts[nums[i]]]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            if count == i:\n                res = max(res,i + 1)\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        freqs = defaultdict(int)\n        freqfreq = defaultdict(int)\n        \n        rec = 0\n        \n        for i, n in enumerate(nums):\n            freqs[n]+= 1\n            freqfreq[freqs[n]] +=1\n            \n            if freqs[n] != 1:\n                freqfreq[freqs[n]-1] -=1\n                if freqfreq[freqs[n]-1] == 0:\n                    del freqfreq[freqs[n]-1]\n            \n            \n            if len(freqfreq)<3:\n                if len(freqfreq)==1 and len(freqs)==1:\n                    rec = i+1\n                elif len(freqfreq)==1 and list(freqfreq.keys())[0]==1:\n                    rec = i+1\n                elif len(freqfreq)==2:\n                    fs = sorted(freqfreq.keys())\n                    if fs[0]==1 and freqfreq[fs[0]]==1:\n                        rec = i+1\n                    elif fs[0]+1 == fs[1] and freqfreq[fs[1]]==1:\n                        rec = i+1\n        return rec", "class Solution:\n    def maxEqualFreq(self, nums) -> int:\n        res = maxFrq = 0\n        count = defaultdict(int)\n        freq = defaultdict(int)\n        for i in range(len(nums)):\n            cnt = count[nums[i]]\n            freq[cnt] -= 1\n            count[nums[i]] += 1\n\n            cnt = count[nums[i]]\n            freq[cnt] += 1\n            maxFrq = max(maxFrq, count[nums[i]])\n            if (maxFrq == 1) or (maxFrq*freq[maxFrq]) == i or ((maxFrq-1)*(freq[maxFrq-1] + 1)) == i:\n                res = i + 1\n        return res\n\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        if len(nums)==1: return 0\n        counts, freq = collections.Counter(), collections.Counter()\n        res = 0\n        for i, num in enumerate(nums):\n            # update counts\n            counts[num] += 1\n            # update counts with that frequency\n            freq[counts[num]] += 1\n\n            count = freq[counts[num]] * counts[num]\n            if count == i + 1 and i != len(nums) - 1: # case 1\n                res = max(res, i + 2)\n            elif count == i: # case 2\n                res = max(res, i + 1)\n        return res\n            \n            \n            \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counter, pattern = {}, {}\n        rtn = 0\n        if len(nums) <= 3:\n            return len(nums)\n        for i in range(len(nums)):\n            n = nums[i]\n            if n in counter:\n                t = counter[n]\n                counter[n] += 1\n            else:\n                t = 0\n                counter[n] = 1\n                \n            if t > 0:\n                pattern[t] -= 1\n                if pattern[t] == 0:\n                    del pattern[t]\n                \n            if t+1 in pattern:\n                pattern[t+1] += 1\n            else:\n                pattern[t+1] = 1\n            if len(pattern) == 1:\n                for k, v in list(pattern.items()):\n                    if k == 1 or v == 1:\n                        rtn = max(rtn, i)\n            elif len(pattern) == 2:\n                for k,v in list(pattern.items()):\n                    if k == 1 and v == 1:\n                        rtn = max(i, rtn)\n                [m1, m2] = [(k,v) for k,v in list(pattern.items())]\n                if (m1[0] - m2[0] == 1 and m1[1] == 1) or (m2[0] - m1[0] == 1 and m2[1] == 1):\n                    rtn = max(rtn, i)\n        return rtn + 1\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count = collections.Counter()\n        n = len(nums)\n        freq = collections.Counter()\n        res = 0\n        \n        for i, a in enumerate(nums, 1):\n            if count[a] in freq:\n                freq[count[a]] -= 1\n            freq[count[a]+1] += 1\n            count[a] += 1\n            f = count[a]\n            if freq[f] * f == i and i < n:\n                res = i+1\n            else:\n                d = i - freq[f]*f\n                if d in [1, f+1] and freq[d] == 1:\n                    res = i\n        return res\n            \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        res = 0\n        numToCount = {}\n        countToNum = {}\n        for i in range(len(nums)):\n            num = nums[i]\n            if num not in numToCount:\n                numToCount[num] = 0\n            count = numToCount[num]\n            if count != 0:\n                countToNum[count].remove(num)\n                if len(countToNum[count]) == 0:\n                    del countToNum[count]\n            count += 1\n            if count not in countToNum:\n                countToNum[count] = set()\n            countToNum[count].add(num)\n            numToCount[num] = count\n            if len(countToNum) == 1:\n                if count == 1 or len(countToNum[count]) == 1:\n                    res = i + 1\n            elif len(countToNum) == 2:\n                keys = sorted(list(countToNum.keys()))\n                if (keys[0] == 1 and len(countToNum[keys[0]])) == 1 or (keys[0] + 1 == keys[1] and len(countToNum[keys[1]]) == 1):\n                    res = i + 1\n            # print(countToNum)\n        return res\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        \n        hashtable = {}\n        hashcount = {}\n        m  =0\n        \n        for i in range(len(nums)):\n            \n            if nums[i] not in list(hashtable.keys()):\n                hashtable[nums[i]]=1\n                if 1 not in list(hashcount.keys()):\n                    hashcount[1] = [nums[i]]\n                else:\n                    hashcount[1].append(nums[i])\n            else:\n                c = hashtable[nums[i]]\n                hashtable[nums[i]]+=1\n                \n                hashcount[c].remove(nums[i])\n                if len(hashcount[c])==0:\n                    del hashcount[c]\n                if c+1 in list(hashcount.keys()):\n                    hashcount[c+1].append(nums[i])\n                else:\n                    hashcount[c+1]=[nums[i]]\n            \n            #print(hashcount)\n                \n            if (len(list(hashtable.keys()))==1):\n                m = i+1\n                \n            else:\n                l = list(hashcount.keys())\n                \n                if (len(l)==1 and l[0]==1):\n                    m = max(m,i+1)\n                if len(list(hashcount.keys()))==2:\n                    if 1 in list(hashcount.keys()) and len(hashcount[1])==1:\n                        m = max(m,i+1)\n                    if abs(l[0]-l[1])==1 and len(hashcount[max(l[0],l[1])])==1:\n                        m = max(m,i+1)\n                \n        return m\n            \n            \n", "from collections import Counter\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        val_occurences = Counter(nums)\n        occ_count = Counter([v for k, v in list(val_occurences.items())])\n        M = len(nums)\n        for i in range(M - 1, -1, -1):\n            if len(occ_count) == 2:\n                for k, v in list(occ_count.items()):\n                    #case where if we reduce we have all the same keys\n                    if v == 1 and (k - 1 in occ_count or k - 1 == 0):\n                        return i + 1\n            elif len(occ_count) == 1:\n                if 1 in list(occ_count.keys()) or 1 in list(occ_count.values()):\n                    return i + 1\n\n            val = nums[i]\n            count = val_occurences[val]\n            val_occurences[val]-=1\n            if val_occurences[val] == 0:\n                del val_occurences[val]\n            occ_count[count]-=1\n            if occ_count[count] == 0:\n                del occ_count[count]\n            if count-1 != 0:\n                occ_count[count-1]+=1\n        return 0\n", "from collections import Counter\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts, freq = Counter(), Counter()\n        ans, maxF = 0, 0\n        for i, num in enumerate(nums):\n            counts[num] += 1\n            freq[counts[num] - 1] -= 1\n            freq[counts[num]] += 1\n            maxF = max(maxF, counts[num])\n            if maxF*freq[maxF] == i or (maxF - 1)*(freq[maxF-1] + 1) == i or maxF == 1:\n                ans = i + 1\n        return ans\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        freq={}\n        num={}\n        m=0\n        for i in range(len(nums)):\n            if nums[i] in num:\n                num[nums[i]]+=1\n                if((num[nums[i]]) in freq):\n                    freq[num[nums[i]]]+=1\n                    if((num[nums[i]]-1) in freq):\n                        freq[num[nums[i]]-1]-=1\n                    if((num[nums[i]]-1) in freq)and(freq[num[nums[i]]-1]==0):\n                        freq.pop(num[nums[i]]-1)\n                else:\n                    freq[num[nums[i]]]=1\n                    if((num[nums[i]]-1) in freq):\n                        freq[num[nums[i]]-1]-=1\n                    if((num[nums[i]]-1) in freq)and(freq[num[nums[i]]-1]==0):\n                        freq.pop(num[nums[i]]-1)\n            else:\n                num[nums[i]]=1\n                if 1 in freq:\n                    freq[1]+=1\n                    if(0 in freq)and(freq[0]==0):\n                        freq.pop(0)\n                else:\n                    freq[1]=1\n                    if(0 in freq)and(freq[0]==0):\n                        freq.pop(0)\n            if(len(freq)==1)and(1 in freq):\n                m=i+1\n            elif(len(freq)==2):\n                a=list(freq.keys())\n                b=max(a)\n                c=min(a)\n                if(b-c==1)and(freq[b]==1):\n                    m=i+1\n                if(1 in freq)and(freq[1]==1):\n                    m=i+1\n        if(len(freq)==1)and(len(set(nums))==1):\n            return len(nums)\n        return m\n                \n", "class Solution:\n    # O(n) time, O(n) space\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count2num = defaultdict(set)\n        num_count = Counter()\n        max_len = 0\n        \n        def is_valid(count2num):\n            counts = list(count2num.keys())\n            # each element appears only once, or there is only 1 kind of element \n            if len(counts) == 1 and (counts[0] == 1 or len(count2num[counts[0]]) == 1):\n                return True\n            # Otherwise, if there are not 2 different counts, this prefix should be invalid\n            if len(counts) != 2:\n                return False\n            # 2 different counts\n            counts.sort()\n            # Only 1 element has count 1, and others have a same different count\n            if counts[0] == 1 and len(count2num[1]) == 1:\n                return True\n            # Two consecutive counts, and the larger one only has 1 element\n            if counts[0] + 1 == counts[1] and len(count2num[counts[1]]) == 1:\n                return True\n            \n            return False\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            num_count[num] += 1\n            count = num_count[num]\n            count2num[count].add(num)\n            if count > 1:\n                count2num[count - 1].remove(num)\n                if not count2num[count - 1]:\n                    count2num.pop(count - 1)\n            if is_valid(count2num):\n                max_len = max(max_len, i + 1)\n        \n        return max_len", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count2num = defaultdict(set)\n        num_count = Counter()\n        max_len = 0\n        \n        def is_valid(count2num):\n            counts = list(count2num.keys())\n            # each element appears only once, or there is only 1 kind of element \n            if len(counts) == 1 and (counts[0] == 1 or len(count2num[counts[0]]) == 1):\n                return True\n            # Otherwise, if there are not 2 different counts, this prefix should be invalid\n            if len(counts) != 2:\n                return False\n            # 2 different counts\n            counts.sort()\n            # Only 1 element has count 1, and others have a same different count\n            if counts[0] == 1 and len(count2num[1]) == 1:\n                return True\n            # Two consecutive counts, and the larger one only has 1 element\n            if counts[0] + 1 == counts[1] and len(count2num[counts[1]]) == 1:\n                return True\n            \n            return False\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            num_count[num] += 1\n            count = num_count[num]\n            count2num[count].add(num)\n            if count > 1:\n                count2num[count - 1].remove(num)\n                if not count2num[count - 1]:\n                    count2num.pop(count - 1)\n            if is_valid(count2num):\n                max_len = max(max_len, i + 1)\n        \n        return max_len", "class Solution:\n    def isvalid(self,D):\n        if len(D)>2:\n            return False\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                # a==1: all lengths are unitary (like [1,2,3,4,...]), so removing anything is fine\n                # D[a]==1, we have a unique length occurence (like [4,4,4,4,...]), so...\n                #          so we can pop one element and be fine\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1: \n            # If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\n            # The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #     - If we have more of the smallest length, we're into trouble\n            return True\n        # Remove from \\\"b\\\"\n        return True if ( D[b]==1 and (a+1)==b ) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            if B[x]:\n                # If we had seen B before, deregister its \\\"old\\\" length\n                if C[B[x]] == 1:\n                    C.pop( B[x] )\n                else:\n                    C[B[x]] -= 1\n            B[x]    += 1 # increase rep. counter\n            C[B[x]] += 1 # Register new length seen\n            #\n            if self.isvalid(C):\n                best = i+1\n        return best", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counter = Counter()\n        freq_counter = Counter()\n        res = 0\n        \n        for i, num in enumerate(nums):\n            if counter[num]:\n                freq_counter[counter[num]]-=1\n                if not freq_counter[counter[num]]:\n                    del freq_counter[counter[num]]\n            counter[num] += 1\n            freq_counter[counter[num]]+=1\n    \n            if len(freq_counter)==1:\n                for k in freq_counter:\n                    if k==1 or freq_counter[k]==1:\n                        res = max(res, i+1)\n            if len(freq_counter)==2:\n                k0, k1 = sorted(freq_counter)\n                if freq_counter[1]==1 or k1-k0==1 and freq_counter[k1]==1:\n                    res = max(res, i+1)\n            # print(i, num, res, freq_counter)\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts, freq = collections.Counter(), collections.Counter()\n        res = 0\n        for i, num in enumerate(nums):\n        \n            counts[num] += 1\n           \n            freq[counts[num]] += 1\n\n            count = freq[counts[num]] * counts[num]\n            if count == i + 1 and i != len(nums) - 1: \n                res = max(res, i + 2)\n            elif count == i:\n                res = max(res, i + 1)\n        return res\n", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        \n        # Life is hard especially when you think it's easy.\n        # Oh my god!!! Please read the problem again. It needs an array prefix of nums!!! Therefore it should start from the first. Shit!!\n        \n        \n        counter = collections.Counter()\n        fre = [0] * (len(A) + 1)\n        res = 0\n        for n, a in enumerate(A, 1):\n            c = counter[a]\n            fre[c] -= 1\n            fre[c + 1] += 1\n            c += 1\n            counter[a] += 1\n            if c * fre[c] == n and n < len(A):\n                res = n + 1\n            d = n - c*fre[c]\n            if d in [1, c+1] and fre[d] == 1:\n                res = n\n            \n        return res\n        \n        \n#         count = collections.Counter()\n#         freq = [0 for _ in range(len(A) + 1)]\n#         res = 0\n#         for n, a in enumerate(A, 1):\n            \n#             # the frequence update, since some number appear again, its appearance affect its count and the frequence.\n            \n#             freq[count[a]] -= 1\n#             freq[count[a] + 1] += 1\n#             c = count[a] = count[a] + 1\n#             if freq[c] * c == n and n < len(A):\n#                 res = n + 1\n#             d = n - freq[c] * c\n#             if d in [c + 1, 1] and freq[d] == 1:\n#                 res = n\n#         return res\n", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        n = len(A)\n        count = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n        for i in range(n):\n            count[A[i]] +=1\n            freq[count[A[i]]]+=1\n        \n        print((count, freq))\n        for i in range(n-1, 0, -1):\n            # If include A[i]\n            if count[A[i]] * freq[count[A[i]]] == i:\n                return i + 1\n            freq[count[A[i]]] -= 1\n            count[A[i]] -= 1\n            if count[A[i-1]] * freq[count[A[i-1]]] == i:\n                return i + 1\n            \n        return 1\n            \n        \n", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        \n        # Life is hard especially when you think it's easy.\n        # Oh my god!!! Please read the problem again. It needs an array prefix of nums!!! Therefore it should start from the first. Shit!!\n        \n        \n        counter = collections.Counter()\n        fre = [0] * (len(A) + 1)\n        res = 0\n        for n, a in enumerate(A, 1):\n            \n            fre[counter[a]] -= 1\n            fre[counter[a] + 1] += 1\n            c = counter[a] = counter[a] + 1\n            if c * fre[c] == n and n < len(A):\n                res = n + 1\n            d = n - c*fre[c]\n            if d in [1, c+1] and fre[d] == 1:\n                res = n\n            \n        return res\n        \n        \n#         count = collections.Counter()\n#         freq = [0 for _ in range(len(A) + 1)]\n#         res = 0\n#         for n, a in enumerate(A, 1):\n            \n#             # the frequence update, since some number appear again, its appearance affect its count and the frequence.\n            \n#             freq[count[a]] -= 1\n#             freq[count[a] + 1] += 1\n#             c = count[a] = count[a] + 1\n#             if freq[c] * c == n and n < len(A):\n#                 res = n + 1\n#             d = n - freq[c] * c\n#             if d in [c + 1, 1] and freq[d] == 1:\n#                 res = n\n#         return res\n", "from collections import defaultdict\n\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        num_to_count = defaultdict(int)\n        count_to_distinct_num = defaultdict(int)\n        result = 0\n        \n        \n        for i, n in enumerate(nums):\n            prev_count = num_to_count[n]\n            new_count = prev_count + 1\n            num_to_count[n] = new_count\n            \n            if prev_count > 0:\n                count_to_distinct_num[prev_count] -= 1\n                \n                if count_to_distinct_num[prev_count] == 0:\n                    del count_to_distinct_num[prev_count]\n                    \n            count_to_distinct_num[new_count] += 1\n            \n            if valid_prefix(count_to_distinct_num, new_count):\n                result = i + 1\n                \n        return result\n    \ndef valid_prefix(count_to_distinct_num, hint):\n    assert len(count_to_distinct_num) > 0\n    assert 0 not in count_to_distinct_num\n    assert hint in count_to_distinct_num\n    \n    if 1 in count_to_distinct_num:\n        if len(count_to_distinct_num) == 1:\n            return True\n        \n        if len(count_to_distinct_num) == 2 and count_to_distinct_num[1] == 1:\n            return True\n        \n    if len(count_to_distinct_num) == 1:\n        if count_to_distinct_num[hint] == 1:\n            return True\n    \n    if len(count_to_distinct_num) != 2:\n        return False\n    \n    if hint-1 in count_to_distinct_num:\n        return count_to_distinct_num[hint] == 1\n    \n    if hint+1 in count_to_distinct_num:\n        return count_to_distinct_num[hint+1] == 1\n    \n    return False\n                    \n            \n        \n", "from collections import Counter\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        res = 1        \n        count = defaultdict(int)\n        inverseCount = defaultdict(set)\n        for i in range(len(nums)):\n            if count[nums[i]] in inverseCount:\n                inverseCount[count[nums[i]]].remove(nums[i])\n                if len(inverseCount[count[nums[i]]]) == 0:\n                    inverseCount.pop(count[nums[i]])\n            count[nums[i]] += 1\n            inverseCount[count[nums[i]]].add(nums[i])\n\n            if self.canBeEqualFreq(inverseCount):\n                res = i+1\n        \n        return res\n            \n            \n    def canBeEqualFreq(self, ic):\n        ickeys, icvalues = list(ic.keys()), list(ic.values())\n        if len(ic) == 1:\n            return len(icvalues[0])==1 or 1 in list(ic.keys())\n        \n        if len(ic) > 2:\n            return False\n        # case 1: 1,2,2,2,3,3,3\n        if 1 in ickeys and len(ic[1])==1:\n            return True\n        # case 2: 1,1,2,3\n        if (ickeys[0] - ickeys[1] == 1 and len(ic[ickeys[0]])==1) or (ickeys[1] - ickeys[0] == 1 and len(ic[ickeys[1]])==1) :\n            return True\n        \n        return False\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        freq = collections.Counter()\n        counts = collections.Counter()\n        res = 0\n        for i, val in enumerate(nums):\n            save = freq[val]\n            if save:\n                counts[save] -= 1\n                if not counts[save]:\n                    del counts[save]\n            freq[val] += 1\n            counts[freq[val]] += 1\n            if len(counts) == 1 and (counts[1] > 0 or len(freq) == 1):\n                res = i + 1\n            if len(counts) == 2:\n                (a, b) = list(counts.keys())\n                if abs(a - b) == 1 and counts[max(a, b)] == 1:\n                    res = i + 1\n                if counts[1] == 1:\n                    res = i + 1\n            # print(freq, counts)\n        return res\n", "class Solution:\n    def isvalid(self,D):\n        if len(D)>2:\n            return False\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                # a==1: all lengths are unitary (like [1,2,3,4,...]), so removing anything is fine\n                # D[a]==1, we have a unique length occurence (like [4,4,4,4,...]), so...\n                #          so we can pop one element and be fine\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1:\n            return True\n        return True if (a==(b-1) and D[b]==1) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            if B[x]:\n                # If we had seen B before, deregister its \\\"old\\\" length\n                if C[B[x]] == 1:\n                    C.pop( B[x] )\n                else:\n                    C[B[x]] -= 1\n            B[x]    += 1 # increase rep. counter\n            C[B[x]] += 1 # Register new length seen\n            #\n            if self.isvalid(C):\n                best = i+1\n        return best", "class Solution:\n    def maxEqualFreq(self, A: List[int]) -> int:\n        \n        \n        count = collections.Counter()\n        freq = [0 for _ in range(len(A) + 1)]\n        res = 0\n        for n, a in enumerate(A, 1):\n            freq[count[a]] -= 1\n            freq[count[a] + 1] += 1\n            c = count[a] = count[a] + 1\n            if freq[c] * c == n and n < len(A):\n                res = n + 1\n            d = n - freq[c] * c\n            if d in [c + 1, 1] and freq[d] == 1:\n                res = n\n        return res", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt,freq,maxF,res = collections.defaultdict(int), collections.defaultdict(int),0,0\n        for i,num in enumerate(nums):\n            cnt[num] += 1\n            freq[cnt[num]-1] -= 1\n            freq[cnt[num]] += 1\n            maxF = max(maxF,cnt[num])\n            if maxF*freq[maxF] == i or (maxF-1)*(freq[maxF-1]+1) == i or maxF == 1:\n                res = i + 1\n        return res\n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counts = collections.Counter()\n        freq = collections.Counter()\n        res = 0\n        for i,num in enumerate(nums):\n            counts[num] += 1\n            freq[counts[num]] += 1\n            \n            count = freq[counts[num]] * counts[num]\n            if count == i + 1 and i != len(nums) - 1:\n                res = max(res,i + 2)\n            elif count == i:\n                res = max(res,i + 1)\n        return res\n", "class Solution:\n    def isvalid(self,D):\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                # a==1: all lengths are unitary (like [1,2,3,4,...]), so removing anything is fine\n                # D[a]==1, we have a unique length occurence (like [4,4,4,4,...]), so...\n                #          so we can pop one element and be fine\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1: \n            # If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\n            # The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #     - If we have more of the smallest length, we're into trouble\n            return True\n        # Remove from \\\"b\\\"\n        return True if ( D[b]==1 and (a+1)==b ) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            old = B[x]\n            if old:\n                if C[old]==1:\n                    C.pop(old)\n                else:\n                    C[old] -= 1\n            B[x]    += 1 # increase rep. counter\n            C[B[x]] += 1 # Register new length seen\n            #\n            if len(C)<=2 and self.isvalid(C):\n                best = i+1\n        return best", "\nclass Solution:\n    def maxEqualFreq(self, nums) -> int:\n        '''\n\n        :param nums: : List[int]\n        :return:\n        '''\n\n        n = len(nums)\n        a= Counter(nums)\n\n        # print(nums)\n        for i in range(n-1,0,-1):\n            if len(a) == 1:\n                p = [i for i in list(a.keys())][0]\n                return a[p]\n            b = Counter(list(a.values()))\n\n            if len(b) > 2:\n                a[nums[i]] -= 1\n                if not a[nums[i]]:\n                     a.pop(nums[i])\n                continue\n            elif len(b) == 1:\n                if 1 in list(a.values()):\n                    return i+1\n                return i\n            elif len(b) == 2:\n                if 1 in list(b.keys()) and b[1]==1:\n                    return i+1\n                if 1 in list(b.values()):\n                    mia,aa =[la for la in list(b.keys())]\n                    mia,aa = min(mia,aa),max(mia,aa)\n                    if b[aa]==1 and aa-mia ==1 :\n                        return i+1\n                    a[nums[i]] -= 1\n                    if not a[nums[i]]:\n                        a.pop(nums[i])\n                else:\n                    a[nums[i]] -= 1\n                    if not a[nums[i]]:\n                        a.pop(nums[i])\n                    continue\n\n", "class LinkedList:\n    def __init__(self):\n        self.map = {}\n        self.min = -1\n        self.max = -1\n    def add_to_key(self, key):\n        if key in self.map:\n            self.map[key][0] += 1\n            new_key = self.map[key][1]\n            while new_key >= 1 and self.map[key][0] > self.map[new_key][0]:\n                self.map[key][1], self.map[new_key][1] = self.map[new_key][1], key\n                self.map[new_key][2], self.map[key][2] = self.map[key][2], new_key\n                if self.map[new_key][2] > 0:\n                    self.map[self.map[new_key][2]][1] = new_key\n\n                \n                # update min\n                if self.min == key:\n                    self.min = new_key\n                new_key = self.map[key][1]\n            if new_key >= 1:\n                self.map[new_key][2] = key\n        else:\n            self.map[key] = [1, self.min, -1]\n            if self.min > 0:\n                self.map[self.min][2] = key\n            # update min\n            self.min = key\n        # update max\n        if self.max <= 0 or self.map[self.max][0] < self.map[key][0]:\n            self.max = key\n        \n    def check(self):\n        A = self.biggest()\n        B = self.smallest()\n        if A == 1:\n            return True\n        elif B == 1:\n            C = self.unique_min()\n            if not C:\n                if A == 2 and self.unique_max():\n                    return True\n                else:\n                    return False\n            else:\n                next_min = self.map[self.min][1]\n                if self.map[next_min][0] == A:\n                    return True\n                else:\n                    return False\n        else:\n            D = self.unique_max()\n            if D:\n                return A == B + 1 or A == B\n            else:\n                return False\n            \n    def smallest(self):\n        if self.min == -1:\n            return 0\n        else:\n            return self.map[self.min][0]\n    def biggest(self):\n        if self.max == -1:\n            return 0\n        else:\n            return self.map[self.max][0]\n    def unique_min(self):\n        if self.min <= 0:\n            return True\n        else:\n            next_min = self.map[self.min][1]\n            return next_min >= 1 and self.map[self.min][0] != self.map[next_min][0]\n    def unique_max(self):\n        if self.max <= 0:\n            return True\n        else:\n            next_max = self.map[self.max][2]\n            if next_max > 0:\n                return self.map[self.max][0] != self.map[next_max][0]\n            else:\n                return True\n        \nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        out = LinkedList()\n        result = 2\n        for length, num in enumerate(nums):\n            out.add_to_key(num)\n            #print(length + 1, out.check(), out.map, out.max, out.min, out.unique_max())\n            #xx = [str(length)]\n            #elem = out.max\n            #limit = 100\n            #while elem != -1 and limit > 0:\n            #    xx.append(str(elem))\n            #    elem = out.map[elem][2]\n            #    limit -= 1\n            #print(\\\">\\\".join(xx))\n            if out.check():\n                result = length + 1\n        return result\n        \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        counterCounter = defaultdict(int)\n        numCounter = defaultdict(int)\n        ans = 0\n        maxRepeat = 0\n        for i, num in enumerate(nums):\n            numCounter[num] += 1\n            counterCounter[numCounter[num]] += 1\n            maxRepeat = max(numCounter[num], maxRepeat)\n            if numCounter[num] > 1:\n                counterCounter[numCounter[num]-1] -= 1\n            if (counterCounter[maxRepeat] == 1 and (maxRepeat-1)*(counterCounter[maxRepeat-1]+1) == i) or (counterCounter[1] == 1 and (maxRepeat)*(counterCounter[maxRepeat]) == i):\n                ans = i+1\n            if maxRepeat == 1 or maxRepeat == i+1:\n                ans = i+1 \n            \n            # print(counterCounter, maxRepeat)\n        return ans", "from collections import defaultdict\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        counter, freq = defaultdict(int), defaultdict(int)\n        max_f, ans = 0, 0\n        for idx, num in enumerate(nums):\n            counter[num] += 1\n            max_f = max(max_f, counter[num])\n            freq[counter[num]-1] -= 1\n            freq[counter[num]] += 1\n            if max_f == 1 or max_f * freq[max_f] == idx or (max_f-1) * (freq[max_f-1] + 1) == idx:\n                ans = idx + 1\n        return ans\n", "class Solution:\n    def isvalid(self,D):\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                # a==1: all lengths are unitary (like [1,2,3,4,...]), so removing anything is fine\n                # D[a]==1, we have a unique length occurence (like [4,4,4,4,...]), so...\n                #          so we can pop one element and be fine\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1: \n            # If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\n            # The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #     - If we have more of the smallest length, we're into trouble\n            return True\n        # Remove from \\\"b\\\"\n        return True if ( D[b]==1 and (a+1)==b ) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            old = B[x]\n            if old:\n                if C[old]==1:\n                    C.pop(old)\n                else:\n                    C[old] -= 1\n            B[x]     += 1 # increase rep. counter\n            C[old+1] += 1 # Register new length seen\n            #\n            if len(C)<3 and self.isvalid(C):\n                best = i+1\n        return best", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        r = 0\n        c = collections.Counter()\n        countToNums = collections.Counter()\n        high = 0\n        unique = 0\n        \n        for i in range(len(nums)):\n            if not c[nums[i]]:\n                unique += 1\n            \n            countToNums[c[nums[i]]] -= 1\n            c[nums[i]] += 1\n            countToNums[c[nums[i]]] += 1\n            if c[nums[i]] > high:\n                high = c[nums[i]]\n                \n            if countToNums[high] == 1 and countToNums[high-1] == unique-1 or countToNums[1] == 1 and countToNums[high] == unique-1 or high == 1:\n                r = i+1\n                \n        return r\n            \n", "class Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        r = 1\n        c = collections.Counter()\n        countToNums = collections.Counter()\n        high = 0\n        unique = 0\n        \n        for i in range(len(nums)):\n            if not c[nums[i]]:\n                unique += 1\n            \n            countToNums[c[nums[i]]] -= 1\n            c[nums[i]] += 1\n            countToNums[c[nums[i]]] += 1\n            if c[nums[i]] > high:\n                high = c[nums[i]]\n                \n            if countToNums[high] == 1 and countToNums[high-1] == unique-1 or countToNums[1] == 1 and countToNums[high] == unique-1 or countToNums[1] == unique:\n                r = i+1\n                \n        return r\n            \n", "class Solution:\n    def isvalid(self,D):\n        if len(D)>2:\n            return False\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1:\n            return True\n        return True if (a==(b-1) and D[b]==1) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            if B[x]:\n                # If we had seen B before, deregister its \\\"old\\\" length\n                if C[B[x]] == 1:\n                    C.pop( B[x] )\n                else:\n                    C[B[x]] -= 1\n            B[x]    += 1 # increase rep. counter\n            C[B[x]] += 1 # Register new length seen\n            #\n            if self.isvalid(C):\n                best = i+1\n        return best", "class Solution:\n    def isvalid(self,D):\n        if len(D)==1:\n            a = min(D)\n            if a==1 or D[a]==1:\n                # a==1: all lengths are unitary (like [1,2,3,4,...]), so removing anything is fine\n                # D[a]==1, we have a unique length occurence (like [4,4,4,4,...]), so...\n                #          so we can pop one element and be fine\n                return True\n            return False\n        # len(D)==2 now\n        a,b = min(D),max(D)\n        if a==D[a]==1: \n            # If we remove from a chain of length \\\"a\\\", we will create something smaller than \\\"b\\\", so...\n            # The only way to be fine is to have a single element, like [1,2,2,2,3,3,3,...]\n            #     - If we have more of the smallest length, we're into trouble\n            return True\n        # Remove from \\\"b\\\"\n        return True if ( D[b]==1 and (a+1)==b ) else False\n    def maxEqualFreq(self, A):\n        best = 0\n        B = Counter() # Count number of repetitions/length (per value)\n        C = Counter() # Count number of times a length has been seen\n        for i,x in enumerate(A):\n            if B[x]:\n                # If we had seen B before, deregister its \\\"old\\\" length\n                if C[B[x]] == 1:\n                    C.pop( B[x] )\n                else:\n                    C[B[x]] -= 1\n            B[x]    += 1 # increase rep. counter\n            C[B[x]] += 1 # Register new length seen\n            #\n            if len(C)<=2 and self.isvalid(C):\n                best = i+1\n        return best", "from collections import Counter \n    \n\nclass Solution:\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        cnt = Counter(nums)\n        n = len(nums)\n        res = n\n        if n <= 2:\n            return n\n        \n        c = set(cnt.values())\n        min_c = min(cnt.values())\n        max_c = max(cnt.values())\n        if (len(c) == 2 and ((sum([1 for k in cnt if cnt[k] == max_c]) == 1 and max_c == min_c + 1) or (sum([1 for k in cnt if cnt[k] == min_c]) == 1 and min_c == 1))) or (len(c) == 1 and min_c == 1) or (len(cnt) == 1):\n            return res\n        # print(cnt, min_c, max_c)\n        \n        for i in reversed(nums[2:]):\n            res -= 1\n            cnt[i] -= 1\n            if cnt[i] == 0:\n                del cnt[i]\n            \n            if not cnt:\n                return res\n            c = set(cnt.values())\n            min_c = min(cnt.values())\n            max_c = max(cnt.values())\n            if (len(c) == 2 and ((sum([1 for k in cnt if cnt[k] == max_c]) == 1 and max_c == min_c + 1) or (sum([1 for k in cnt if cnt[k] == min_c]) == 1 and min_c == 1))) or (len(c) == 1 and min_c == 1) or (len(cnt) == 1):\n                return res\n        \n        return 2\n", "class Solution:\n    # hashmap\n    # review\n    def maxEqualFreq(self, nums: List[int]) -> int:\n        count = collections.defaultdict(int)\n        freq = collections.defaultdict(int)\n\n        # for test case [1,1,1,2,2,2] , the ans is 5, [1,1,1,2,2], len=5, you can remove 1, then 1 and 2 occur 2 times\n        # we will get count {1:3, 2:3}\n        # for freq: we would get {1:2, 2:2, 3: 2}, notice we loop from left to right, so we would get\n        # freq : {1:1}, {1:1, 2:1}, {1:1,2:1,3:1}, {1:2,2:1,3:1}, {1:2,2:2,3:1},{1:2,2:2,3:2}\n        for n in nums:\n            count[n] += 1\n            freq[count[n]] += 1\n\n        for i in range(len(nums) - 1, 0, -1):\n            # 2 case, case 1 , keep i, then you have to remove another on from 0 -- i-1\n            # for test case [1,1,1,2,2,2], at index i = 5, 3 * 2 = 6 != 5, because we need to remove one element if we\n            # want to keep ith element\n            # but i = 4,  count[2] = 2, freq[2] = 2, 2 * 2 = 4, ie, when i = 4, total 5 elements, remove 1 ele, remain 4.\n            # notice we need to return ri+1, because w need to prefix length, which include the removed element\n\n            # this means from 0->i , each num appear equal times, then we just need to remove i+1\n            if count[nums[i]] * freq[count[nums[i]]] == i:\n                return i + 1\n            freq[count[nums[i]]] -= 1\n            count[nums[i]] -= 1\n\n            if count[nums[i - 1]] * freq[count[nums[i - 1]]] == i:\n                return i + 1\n\n        return 1\n\n\n"]
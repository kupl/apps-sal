["def dfs(x, y):\n    vis.append((x, y))\n    y += 1\n    nonlocal flag\n    if flag or str.isalpha(grid[x][y]):\n        return\n    if y >= n - 1:\n        flag = True\n        return\n    \n    # stay idle\n    if not str.isalpha(grid[x][y + 1]) and not str.isalpha(grid[x][y + 2]) and (x, y + 2) not in vis:\n        dfs(x, y + 2)\n\n    # move down\n    if x > 0 and  not str.isalpha(grid[x - 1][y]) and not str.isalpha(grid[x - 1][y + 1]) and not str.isalpha(grid[x - 1][y + 2]) and (x - 1, y + 2) not in vis:\n        dfs(x - 1, y + 2)\n\n    #move up\n    if x < 2 and not str.isalpha(grid[x + 1][y]) and not str.isalpha(grid[x + 1][y + 1]) and not str.isalpha(grid[x + 1][y + 2]) and (x + 1, y + 2) not in vis:\n        dfs(x + 1, y + 2)\n    \n\nT = int(input())\nfor loop in range(T):\n    n, k = [ int(i) for i in input().split() ]\n    grid = list()\n    grid.append(input() + \"    \")\n    grid.append(input() + \"    \")\n    grid.append(input() + \"    \")\n    vis = list()\n    flag = False\n    for i in  range(3):\n        if grid[i][0] == 's':\n            grid[i] = \" \" + grid[i][1:]\n            dfs(i, 0)\n            break\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "T = int(input())\n\nfor t in range(T):\n    n, k = list(map(int, input().split(' ')[:2]))\n    s = [\"\",\"\",\"\"]\n    for i in range(3):\n        s[i] = input()\n\n    s[0] += '.' * (n*3)\n    s[1] += '.' * (n*3)\n    s[2] += '.' * (n*3)\n\n    def top():\n        return [s[0][0] != '.', s[1][0] != '.', s[2][0] != '.']\n\n    def shift():\n        s[0] = s[0][1:]\n        s[1] = s[1][1:]\n        s[2] = s[2][1:]\n        return top()\n\n    p = [s[0][0] == 's', s[1][0] == 's', s[2][0] == 's']\n\n    for i in range(1, n):\n        np = [False, False, False]\n        if p[0] == True and s[0][1] == '.':\n            np[0] = True\n            np[1] = True\n        if p[1] == True and s[1][1] == '.':\n            np[0] = True\n            np[1] = True\n            np[2] = True\n        if p[2] == True and s[2][1] == '.':\n            np[1] = True\n            np[2] = True\n\n        p = np\n\n        s0, s1, s2 = shift()\n\n        if s0: p[0] = False\n        if s1: p[1] = False\n        if s2: p[2] = False\n\n        # my move ended\n\n        s0, s1, s2 = shift()\n\n        if s0: p[0] = False\n        if s1: p[1] = False\n        if s2: p[2] = False\n\n        s0, s1, s2 = shift()\n\n        if s0: p[0] = False\n        if s1: p[1] = False\n        if s2: p[2] = False\n\n    if p[0] or p[1] or p[2]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "def dfs(x,y):\n    nonlocal f\n    pos.append((x,y))\n    y+=1\n    if f or str(gr[x][y]).isalpha():\n        return\n    if y>=q-1:\n        f=True\n        return\n    if not str(gr[x][y+1]).isalpha():\n        if not str(gr[x][y+2]).isalpha():\n            if (x,y+2) not in pos:\n                dfs(x,y+2)\n    if x>0:\n        if not str(gr[x-1][y]).isalpha():\n            if not str(gr[x-1][y+1]).isalpha():\n                if not str(gr[x-1][y+2]).isalpha():\n                    if (x-1,y+2) not in pos:\n                        dfs(x-1,y+2)\n    if x<2:\n        if not str(gr[x+1][y]).isalpha():\n            if not str(gr[x+1][y+1]).isalpha():\n                if not str(gr[x+1][y+2]).isalpha():\n                    if (x+1,y+2) not in pos:\n                        dfs(x+1,y+2)\n\n\nn=int(input())\nfor i in range(n):\n    q,w=[int(i) for i in input().split()]\n    gr=list()\n    gr.append(input()+\"     \")\n    gr.append(input()+\"     \")\n    gr.append(input()+\"     \")\n    pos=[]\n    f=False\n    for i in range(3):\n        if gr[i][0]=='s':\n            gr[i]=\" \"+gr[i][1:]\n            dfs(i,0)\n            break\n    if f:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "import sys\nflag = False\nt = int(input())\nfor kek in range(t):\n    n, k = [int(i) for i in input().split()]\n    if t == 10 and n == 95 and k == 6:\n        flag = True\n    a = [[0] * n for i in range(3)]\n    for i in range(3):\n        a[i] = [i for i in input()]\n\n    dp = [[False] * n for i in range(3)]\n    l = 0\n    if a[0][0] == 's':\n        l = 0\n    if a[1][0] == 's':\n        l = 1\n    if a[2][0] == 's':\n        l = 2\n\n    dp[l][0] = True\n    first = [[False] * n for i in range(3)]\n    bad = [True] * 3\n    for i in range(1, n):\n        if 3 * i < n and a[0][3 * i] == '.' and a[0][3 * i - 2] == '.':\n            if (dp[0][i - 1] or first[0][i - 1]) or (a[1][3 * i - 2] == '.' and dp[1][i - 1]):\n                dp[0][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[0][i - 1] and a[0][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.'):\n                dp[0][i] = True\n        elif 3 * i >= n and (dp[0][i - 1] or dp[1][i - 1]):\n            dp[0][i] = True\n        if 3 * i < n and a[1][3 * i] == '.' and a[1][3 * i - 2] == '.':\n            if (dp[1][i - 1] or first[1][i - 1]) or (a[0][3 * i - 2] == '.' and dp[0][i - 1]) or (a[2][3 * i - 2] == '.' and dp[2][i - 1]):\n                dp[1][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[0][i - 1] and a[0][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.') or (dp[2][i - 1] and a[2][3 * i - 2] == '.'):\n                dp[1][i] = True\n        elif 3 * i >= n and (dp[0][i - 1] or dp[1][i - 1] or dp[2][i - 1]):\n            dp[1][i] = True\n        if 3 * i < n and a[2][3 * i] == '.' and a[2][3 * i - 2] == '.':\n            if (dp[2][i - 1] or first[2][i - 1]) or (a[1][3 * i - 2] == '.' and dp[1][i - 1]):\n                dp[2][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[2][i - 1] and a[2][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.'):\n                dp[2][i] = True\n        elif 3 * i >= n and (dp[1][i - 1] or dp[2][i - 1]):\n            dp[2][i] = True\n    #for i in range(3):\n    #    print(dp[i])\n    if max(dp[0][n - 1], dp[1][n - 1], dp[2][n - 1]):\n        print('YES')\n    else:\n        print('NO')\n", "t = int(input())\nfor kek in range(t):\n    n, k = [int(i) for i in input().split()]\n    a = [[0] * n for i in range(3)]\n    for i in range(3):\n        a[i] = [i for i in input()]\n    dp = [[False] * n for i in range(3)]\n    l = 0\n    if a[0][0] == 's':\n        l = 0\n    if a[1][0] == 's':\n        l = 1\n    if a[2][0] == 's':\n        l = 2\n    dp[l][0] = True\n    first = [[False] * n for i in range(3)]\n    for i in range(1, n):\n        if 3 * i < n and a[0][3 * i] == '.' and a[0][3 * i - 2] == '.':\n            if (dp[0][i - 1] or first[0][i - 1]) or (a[1][3 * i - 2] == '.' and dp[1][i - 1]):\n                dp[0][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[0][i - 1] and a[0][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.'):\n                dp[0][i] = True\n        elif 3 * i >= n and (dp[0][i - 1] or dp[1][i - 1]):\n            dp[0][i] = True\n        if 3 * i < n and a[1][3 * i] == '.' and a[1][3 * i - 2] == '.':\n            if (dp[1][i - 1] or first[1][i - 1]) or (a[0][3 * i - 2] == '.' and dp[0][i - 1]) or (a[2][3 * i - 2] == '.' and dp[2][i - 1]):\n                dp[1][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[0][i - 1] and a[0][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.') or (dp[2][i - 1] and a[2][3 * i - 2] == '.'):\n                dp[1][i] = True\n        elif 3 * i >= n and (dp[0][i - 1] or dp[1][i - 1] or dp[2][i - 1]):\n            dp[1][i] = True\n        if 3 * i < n and a[2][3 * i] == '.' and a[2][3 * i - 2] == '.':\n            if (dp[2][i - 1] or first[2][i - 1]) or (a[1][3 * i - 2] == '.' and dp[1][i - 1]):\n                dp[2][i] = True\n        elif 3 * i >= n > 3 * i - 2:\n            if (dp[2][i - 1] and a[2][3 * i - 2] == '.') or (dp[1][i - 1] and a[1][3 * i - 2] == '.'):\n                dp[2][i] = True\n        elif 3 * i >= n and (dp[1][i - 1] or dp[2][i - 1]):\n            dp[2][i] = True\n    #for i in range(3):\n    #    print(dp[i])\n    if max(dp[0][n - 1], dp[1][n - 1], dp[2][n - 1]):\n        print('YES')\n    else:\n        print('NO')\n", "# import sys\n\n# sys.stdin = open('cf586d.in')\n\n\n\ndef handle_test():\n\n\tn, k = [int(v) for v in input().split()]\n\n\n\n\tfield = [input() for _ in range(3)]\n\n\n\n\tif field[0][0] == 's':\n\n\t\tcpos = [0, 0]\n\n\telif field[1][0] == 's':\n\n\t\tcpos = [1, 0]\n\n\telse:\n\n\t\tcpos = [2, 0]\n\n\n\n\tavailable = [[False] * len(field[0]) for _ in range(3)]\n\n\tavailable[cpos[0]][cpos[1]] = True\n\n\n\n\tfor i in range(n):\n\n\t\tfor j in range(3):\n\n\t\t\tif available[j][i]:\n\n\t\t\t\tif i + 1 >= n:\n\n\t\t\t\t\treturn True\n\n\t\t\t\telif field[j][i + 1] != '.':\n\n\t\t\t\t\tcontinue\n\n\t\t\t\tfor offset in (-1, 0, 1):\n\n\t\t\t\t\tif not (0 <= j + offset < 3) or field[j + offset][i + 1] != '.':\n\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif i + 2 >= n:\n\n\t\t\t\t\t\treturn True\n\n\t\t\t\t\telif field[j + offset][i + 2] != '.':\n\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\telif i + 3 >= n:\n\n\t\t\t\t\t\treturn True\n\n\t\t\t\t\telif field[j + offset][i + 3] != '.':\n\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\telse:\n\n\t\t\t\t\t\tavailable[j + offset][i + 3] = True\n\n\n\n\treturn False\n\n\n\n\n\nt = int(input())\n\nfor _ in range(t):\n\n\tprint(['NO', 'YES'][handle_test()])\n\n\n\n# Made By Mostafa_Khaled\n", "def bfs(mat,x,y,n):\n    queue = [[x,y,0]]\n    mark = {j:{u:False for u in range(n)} for j in range(3)}\n    n-=1\n    while queue:\n        q = queue.pop(0)\n        a,b,c = q[0],q[1],q[2]\n        if mark[a][b]==True:\n            continue\n        mark[a][b]=True\n        if b==n:\n            return 'YES'\n        c+=2\n        e,r,f = 0,0,0\n        p = min(b-1+c,n)\n        z = min(b+2+c,n)\n        for i in range(p,z):\n            if mat[0][i]!='.':\n                e=1\n            if mat[1][i]!='.':\n                r=1\n            if mat[2][i]!='.':\n                f=1\n        if mat[a][p]=='.' or p==n:\n            if e==0:\n                if a==1 or a==0:\n                    if mark[0][b+1]==False:\n                        queue.append([0,b+1,c])\n            if r==0:\n                if mark[1][b+1]==False:\n                    queue.append([1,b+1,c])\n            if f==0:\n                if a==1 or a==2:\n                    if mark[2][b+1]==False:\n                        queue.append([2,b+1,c])\nt = int(input())\nfor i in range(t):\n    n,k = map(int,input().split())\n    mat = {j:{u:x for u,x in enumerate(input())} for j in range(3)}\n    if mat[0][0]=='s':\n        res = bfs(mat,0,0,n)\n    elif mat[1][0]=='s':\n        res = bfs(mat,1,0,n)\n    else:\n        res = bfs(mat,2,0,n)\n    if res==None:\n        print('NO')\n    else:\n        print('YES')", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int,minp().split())\n\ndef main():\n\tn,k = mints()\n\ta = [list(minp()) for i in range(3)]\n\tw = [[False]*(n+1) for i in range(3)]\n\tfor j in range(3):\n\t\tif a[j][0] == 's':\n\t\t\ta[j][0] = '.'\n\t\t\tw[j][0] = True\n\tfor i in range(n):\n\t\tfor j in range(3):\n\t\t\tif w[j][i]:\n\t\t\t\tif i*3+1>=n or a[j][i*3+1] == '.':\n\t\t\t\t\tfor z in range(max(j-1,0),min(j+2,3)):\n\t\t\t\t\t\tif (i*3+1>=n or a[z][i*3+1] == '.') and (i*3+2>=n or a[z][i*3+2] == '.') and (i*3+3>=n or a[z][i*3+3] == '.'):\n\t\t\t\t\t\t\tw[z][i+1] = True\n\tcan = w[0][n] or w[1][n] or w[2][n]\n\t#print(w)\n\tif can:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\nt = mint()\nfor i in range(t):\n\tmain()", "from queue import Queue\nfrom collections import defaultdict\n\n\nclass PhilipTrains():\n    def __init__(self, n, k, state):\n        self.n = n\n        self.k = k\n        self.state = state\n        self.graph = [[[0 for i in range(n+1)] for j in range(n)] for k in range(3)]\n        for i in range(len(state)):\n            for j in range(len(state[i])):\n                if 'A' <= state[i][j] <= 'Z':\n                    for k in range(n):\n                        nj = j-(2*k)\n                        if nj >= 0:\n                            self.graph[i][nj][k] = -1\n                        else:\n                            break\n        for i in range(len(state)):\n            if state[i][0] == 's':\n                self.r = i\n                self.c = 0\n\n    def check_reach(self):\n        q = Queue()\n        check = defaultdict(int)\n\n        changes = [(1,1,1),(-1,1,1), (0,1,1)]\n\n        q.put((self.r, self.c, 0))\n        check[(self.r, self.c, 0)] = 1\n\n        while not q.empty():\n            pr, pc, pt = q.get()\n            if self.graph[pr][pc][pt] == -1:\n                continue\n            if pc == self.n-1:\n                return 'YES'\n            if self.graph[pr][pc+1][pt] != -1:\n                if check[(pr, pc+1,pt+1)] != 1:\n                    q.put((pr, pc+1,pt+1))\n                    check[(pr, pc+1, pt+1)] = 1\n                for ch in [1,-1]:\n                    if 0 <= pr+ch <= 2 and check[(pr+ch, pc+1,pt+1)] != 1 and self.graph[pr+ch][pc+1][pt] != -1:\n                        q.put((pr+ch, pc+1,pt+1))\n                        check[(pr+ch, pc+1, pt+1)] = 1\n        return 'NO'\n\nt = int(input())\n\nfor i in range(t):\n    n, k = list(map(int,input().strip(' ').split(' ')))\n    arr = []\n    for i in range(3):\n        arr.append(input().strip(' '))\n    graph = PhilipTrains(n, k, arr)\n    print(graph.check_reach())\n\n\n", "def safe(mat, x, y, n):\n    if not x in [0,1,2]:\n        return False\n    for i in range(1, 4):\n        if y+i<n and mat[x][y+i] != '.':\n            return False\n    return True\n\ndef dfs(mat, n):\n    pos = 0\n    for k in range(3):\n        if mat[k][0]=='s':\n            pos = k\n    vis = {}\n    s = [(pos,0)]\n    while s:\n        x,y = s.pop()\n        if y>=n:\n            return \"YES\"\n        if (x,y) in vis:\n            continue\n        vis[(x,y)] = 1\n        for i in [-1, 0, 1]:\n            if y+1>=n or (y+1<n and mat[x][y+1]=='.' and safe(mat, x+i, y, n)):\n                s.append((x+i, y+3))\n    return 'NO'\n    \n\nt = int(input())\nfor _ in range(t):\n    n,k = map(int, input().split())\n    mat = [input() for i in range(3)]\n    print(dfs(mat, n))", "t = int(input())\nfor test in range(t):\n\tn,k = [int(i) for i in input().split()]\n\tgrid = [[True for i in range(3)] for i in range(n)]\n\tok = [[False for i in range(3)] for i in range(n)]\n\t#x-col, y-row\n\n\trx = 0; ry = 0\n\tfor i in range(3):\n\t\trow = input()\n\t\tj=0\n\t\tfor v in row:\n\t\t\tif v=='s':\n\t\t\t\t#print(\"here\")\n\t\t\t\trx = j\n\t\t\t\try = i\n\t\t\telif v!='.':\n\t\t\t\tgrid[j][i] = False\n\t\t\tj+=1\n\n\tdef verify(x,y):\n\t\tif x<n and y<3 and x>=0 and y>=0:\n\t\t\treturn grid[x][y]\n\t\telse:\n\t\t\treturn False\n\n\tdef dfs(x,y):\n\t\tnonlocal ok\n\t\tif not ok[x][y]:\n\t\t\t#print(x,' ',y)\n\t\t\tok[x][y]=True\n\t\t\tif verify(x+1, y) and verify(x+3,y):\n\t\t\t\tdfs(x+3,y)\n\t\t\tif verify(x+1,y) and verify(x+1,y+1) and verify(x+3,y+1):\n\t\t\t\tdfs(x+3,y+1)\n\t\t\tif verify(x+1,y) and verify(x+1,y-1) and verify(x+3,y-1):\n\t\t\t\tdfs(x+3,y-1)\n\n\n\t\t\t#end game(tap in)\n\t\t\tif x+2>=n-1:\n\t\t\t\tif verify(x+1,y):\n\t\t\t\t\tdfs(x+1,y)\n\n\tdfs(rx, ry)\n\t#print(rx, ry)\n\t#print(ok)\n\n\tres = False\n\tfor i in range(3):\n\t\tif ok[n-1][i]:\n\t\t\tres=True\n\n\tif res:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")"]
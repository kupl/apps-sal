["import re\n\nADDSUB, MULDIV = '+-', '*$'\n\ndef calculate(expression):\n    return \"400: Bad request\" if re.search(r'[^+*$\\d.-]', expression) else parseAndEval(expression, ADDSUB)\n\ndef parseAndEval(expression, ops):\n    v = 0\n    for op,part in re.findall(r'([{0}])?([^{0}]+)'.format(ops), expression):\n        if not op:    v  = float(part) if ops == MULDIV else parseAndEval(part, MULDIV)\n        elif op=='*': v *= float(part)\n        elif op=='$': v /= float(part)\n        elif op=='+': v += parseAndEval(part, MULDIV)\n        elif op=='-': v -= parseAndEval(part, MULDIV)\n    return v", "def tokenize(expression):\n    result = []\n    curr = ''\n    for chr in expression:\n        if chr.isdigit() or chr == '.':\n            curr += chr\n        elif chr in '$*-+':\n            result.extend([float(curr), chr])\n            curr = ''\n        else:\n            raise ValueError('invalid input')\n    if curr:\n        result.append(float(curr))\n    return result\n    \ndef calculate(expression):\n    ops = {\n        '+': lambda x, y: x + y,\n        '-': lambda x, y: x - y,\n        '*': lambda x, y: x * y,\n        '$': lambda x, y: x / y,\n    }\n    \n    try:\n        l = tokenize(expression)\n    except ValueError:\n        return '400: Bad request'\n    \n    for op in '$*-+':\n        while op in l:\n            i = l.index(op)\n            l = l[:i-1] + [ops[op](l[i-1], l[i+1])] + l[i+2:]\n    \n    return l[0]", "def calculate(s):\n    if any(c not in '.0123456789+-*$' for c in s): return '400: Bad request'\n    \n    tokens = [float(e) if e not in '$*-+' else e for e in s.replace('+', ' + ').replace('-', ' - ').replace('*', ' * ').replace('$', ' $ ').split()]\n    \n    for c in '$*-+':\n        r = []\n        for t in tokens:\n            if r and r[-1] == c:\n                r.pop()\n                t = {'$':lambda a,b: a/b, '*':lambda a,b: a*b, '-':lambda a,b: a-b, '+':lambda a,b: a+b}[c](r.pop(), t)\n            r.append(t)\n                \n        tokens = r\n    \n    return tokens.pop()", "from operator import truediv, mul, sub, add\noperators = {'/':truediv,'*':mul,'+':add,'-':sub}\norder = [{'/', '*'}, {'-', '+'}]\n    \ndef calculate(expression):\n    expression = expression.replace('$','/') \n    for i in '+*/-':\n        expression = expression.replace(i,' '+i+' ')\n    l = expression.split()\n    try:\n        for i in range(2):\n            n = 0\n            while n < len(l):\n                if l[n] in order[i]:\n                    l[n-1] = operators[l[n]](float(l.pop(n-1)),float(l.pop(n)))\n                else:n+=1   \n        return float(l[0])\n    except:\n        return '400: Bad request'", "import re\ndef calculate(expression):\n    if re.search(r'[^\\.0123456789+\\-*$]', expression): return '400: Bad request'\n    if re.match('^(?:\\d+\\.)?\\d+$', expression): return float(expression)\n    return (\n        (\n            lambda m:\n                (lambda x, o, y: ({ '+': x + y, '-': x - y, '*': x * y, '$': x / y })[o])\n                (calculate(m.group(1)), m.group(2), calculate(m.group(3)))\n                if m else 0\n        )\n        (re.search('(.+)([+-])(.+)', expression) or re.search('(.+)([*$])(.+)', expression))\n    )\n", "def calculate(s):\n    try:\n        s = re.sub(r'([+*\\-$])', r' \\1 ', s).split()\n        def doall(s_):\n              while s_ in s:\n                  find = s.index(s_)\n                  t ,t1 = float(s[find-1]),float(s.pop(find+1))\n                  s[find-1] = t/t1 if s_==\"$\"else t*t1 if s_==\"*\"else t-t1 if s_== \"-\"else t+t1\n                  s.pop(find)\n        doall('$')\n        doall('*')\n        doall('-')\n        doall('+')\n        return float(s[0])\n    except : return \"400: Bad request\"", "def operation(op1, op2, op):\n    if op == \"*\":\n        return op1 * op2\n    elif op == \"+\":\n        return op1 + op2\n    elif op == \"-\":\n        return op1 - op2\n    else:\n        return op1 / op2\n\ndef calculate(expression):\n    i, lst, num = 0, [], \"\"\n    if \".\" in expression:\n        if expression.replace(\".\", \"\").isdigit():\n            return float(expression)\n    while i < len(expression):\n        if not expression[i].isdigit():\n            if expression[i] in \"+-*$\":\n                lst.append(int(num))\n                lst.append(expression[i])\n                num = \"\"\n            else:\n                return \"400: Bad request\"\n        else:\n            num += expression[i]\n        i += 1\n    if expression[i-1].isdigit():\n        lst.append(int(num))\n    length = len(lst)\n    while(True):\n        if \"*\" in lst and \"$\" in lst:\n            index1, index2 = lst.index('*'), lst.index('$')\n            if index1 < index2 and index1-1 > -1 and index1+1 < length and (type(lst[index1-1]) == int or type(lst[index1-1]) == float) and (type(lst[index1+1]) == int or type(lst[index1+1]) == float):\n                lst[index1-1] = operation(lst.pop(index1-1), lst.pop(index1), lst[index1-1])\n            elif index2-1 > -1 and index2+1 < length and (type(lst[index2-1]) == int or type(lst[index2-1]) == float) and (type(lst[index2+1]) == int or type(lst[index2+1]) == float):\n                lst[index2-1] = operation(lst.pop(index2-1), lst.pop(index2), lst[index2-1])\n            else:\n                return \"400: Bad request\"\n        elif \"*\" in lst:\n            index = lst.index(\"*\")\n            if index-1 > -1 and index+1 < length and (type(lst[index-1]) == int or type(lst[index-1]) == float) and (type(lst[index+1]) == int or type(lst[index+1]) == float):\n                lst[index-1] = operation(lst.pop(index-1), lst.pop(index), lst[index-1])\n            else:\n                return \"400: Bad request\"\n        elif \"$\" in lst:\n            index = lst.index(\"$\")\n            if index-1 > -1 and index+1 < length and (type(lst[index-1]) == int or type(lst[index-1]) == float) and (type(lst[index+1]) == int or type(lst[index+1]) == float):\n                lst[index-1] = operation(lst.pop(index-1), lst.pop(index), lst[index-1])\n            else:\n                return \"400: Bad request\"\n        elif \"+\" in lst and \"-\" in lst:\n            index1, index2 = lst.index('+'), lst.index('-')\n            if index1 < index2 and index1-1 > -1 and index1+1 < length and (type(lst[index1-1]) == int or type(lst[index1-1]) == float) and (type(lst[index1+1]) == int or type(lst[index1+1]) == float):\n                lst[index1-1] = operation(lst.pop(index1-1), lst.pop(index1), lst[index1-1])\n            elif index2-1 > -1 and index2+1 < length and (type(lst[index2-1]) == int or type(lst[index2-1]) == float) and (type(lst[index2+1]) == int or type(lst[index2+1]) == float):\n                lst[index2-1] = operation(lst.pop(index2-1), lst.pop(index2), lst[index2-1])\n            else:\n                return \"400: Bad request\"\n        elif \"+\" in lst:\n            index = lst.index(\"+\")\n            if index-1 > -1 and index+1 < length and (type(lst[index-1]) == int or type(lst[index-1]) == float) and (type(lst[index+1]) == int or type(lst[index+1]) == float):\n                lst[index-1] = operation(lst.pop(index-1), lst.pop(index), lst[index-1])\n            else:\n                return \"400: Bad request\"\n        elif \"-\" in lst:\n            index = lst.index(\"-\")\n            if index-1 > -1 and index+1 < length and (type(lst[index-1]) == int or type(lst[index-1]) == float) and (type(lst[index+1]) == int or type(lst[index+1]) == float):\n                lst[index-1] = operation(lst.pop(index-1), lst.pop(index), lst[index-1])\n            else:\n                return \"400: Bad request\"\n        else:\n            break\n    return lst.pop()", "################################################################\nADD=\"+\"\nSUB=\"-\"\nMUL=\"*\"\nDIV=\"$\"\n\nOPS={\n  ADD : lambda x,y: x+y,\n  SUB : lambda x,y: x-y,\n  MUL : lambda x,y: x*y,\n  DIV : lambda x,y: x/y,\n}\n\nDIGITS=\"0123456789\"\n\nDECIMAL=\".\"\n\neMsg=\"400: Bad request\"\n\n################################################################\nclass RouteError(ValueError):\n  pass\n\n  '''\n  IT IS NOT ALLOWED TO USE DOUBLE UNDERSCORE SEQUENSE IN THIS C_O_D_E,\n  SO I HAVE TO WRITE MY CLASSES WITHOUT _ _init_ _\n  def _ _init_ _(self, text):\n    self.text=text\n  '''\n\n################################################################\nclass Scaner:\n  '''\n  scans for tokens in input -\n  arithmetic operations:    +   -   *   $\n  and numbers:              1   2.  .3  4.5\n  a decimal point is NOT a valid number, an exception is raised\n  any other character also raises an exception\n  '''\n\n  '''\n  IT IS NOT ALLOWED TO USE DOUBLE UNDERSCORE SEQUENSE IN THIS C_O_D_E,\n  SO I HAVE TO WRITE MY CLASSES WITHOUT _ _init_ _\n  def _ _init_ _(self, expression):\n    self.exp=expression\n    self.pos=0\n    self.len=len(expression)\n  '''\n\n  def init(self, expression):\n    self.exp=expression\n    self.pos=0\n    self.len=len(expression)\n\n  def get_digits(self):\n    res=\"\"\n\n    while self.pos<self.len:\n      chr=self.exp[self.pos]\n      if chr not in DIGITS: break\n      res+=chr\n      self.pos+=1\n\n    return res\n\n  def get_number(self):\n    num=self.get_digits()\n    if self.pos>=self.len: return num\n\n    if self.exp[self.pos]==DECIMAL:\n      self.pos+=1\n      num+=DECIMAL+self.get_digits()\n    if num==DECIMAL: raise RouteError(\"No digits in number.\")\n    return num\n\n  def token(self):\n    if self.pos>=self.len: return None\n\n    chr=self.exp[self.pos]\n    if chr in OPS:\n      self.pos+=1\n      return chr\n\n    if chr in DIGITS or chr==DECIMAL:\n      return self.get_number()\n\n    self.pos+=1       # NOT nesessary\n    raise RouteError(\"Illegal character in expression.\")\n\n################################################################\nclass Parser:\n  '''\n  parses tokens into reverse polish notation\n  at first, all tokens are put into self.stk\n  then they are rearranged and put into self.rpn\n  1+2*3 -> 1 2 3 * +\n  4-5+6 -> 4 5 - 6 +\n  this class detects all errors in expression (except division by zero)\n  so later we can evaluate rpn without error checking\n  '''\n\n  '''\n  IT IS NOT ALLOWED TO USE DOUBLE UNDERSCORE SEQUENSE IN THIS C_O_D_E,\n  SO I HAVE TO WRITE MY CLASSES WITHOUT _ _init_ _\n  def _ _init_ _(self):\n    self.stk=[]\n    self.rpn=[]\n  '''\n\n  def init(self):\n    self.stk=[]\n    self.rpn=[]\n\n  def pop(self):\n    return self.stk.pop(0) if self.stk else None\n\n  def token(self):\n    return self.stk[0] if self.stk else None\n\n  def generate_rpn(self):\n    self.generate_subtraction()\n    while self.token()==ADD:\n      self.pop()\n      self.generate_subtraction()\n      self.generate_op(ADD)\n\n    if self.stk:\n      raise RouteError(\"Unexpected token \"+self.token()+\".\")\n\n  def generate_subtraction(self):\n    self.generate_multiplication()\n    while self.token()==SUB:\n      self.pop()\n      self.generate_multiplication()\n      self.generate_op(SUB)\n\n  def generate_multiplication(self):\n    self.generate_division()\n    while self.token()==MUL:\n      self.pop()\n      self.generate_division()\n      self.generate_op(MUL)\n\n  def generate_division(self):\n    if self.token()==None:\n      raise RouteError(\"Missing operand 1.\")\n    self.generate_operand()\n    while self.token()==DIV:\n      self.pop()\n      self.generate_operand()\n      self.generate_op(DIV)\n\n  def generate_operand(self):\n    if not self.stk:\n      raise RouteError(\"Missing operand 2.\")\n    if self.token() in OPS:\n      raise RouteError(\"Unexpected operator \"+self.token()+\".\")\n    tok=self.pop()\n    self.rpn.append(float(tok) if DECIMAL in tok else int(tok))\n\n  def generate_op(self, op):\n    self.rpn.append(op)\n\n################################################################\ndef tryint(num):\n  '''\n  converts numbers like 2.0 to 2 without fractional part,\n  like it is given in examples\n  '''\n  inum=int(num)\n  return inum if num==inum else num\n\ndef Evaluate(rpn):\n  '''\n  evaluates rpn; error checking is not needed, because the data\n  is sintacticaly correct after Parser\n  (i. e., we will never get something like [1 2 + -] or [5 5])\n  '''\n  stk=[]\n  for t in rpn:\n    if t in OPS:\n      op0=stk.pop()\n      stk[-1]=OPS[t](stk[-1], op0)\n    else:\n      stk.append(t)\n\n  return tryint(stk[0])\n\n################################################################\ndef calculate(expression):\n  s=Scaner()\n  s.init(expression)\n  p=Parser()\n  p.init()\n\n  try:\n    while True:\n      t=s.token()\n      if t: p.stk.append(t)\n      else:\n        p.generate_rpn()\n        break\n\n    res=Evaluate(p.rpn)\n\n  except RouteError:\n    res=eMsg\n  except ZeroDivisionError:\n    res=eMsg\n\n  return res\n", "def calculate(exp):\n    import re\n    s = [float(i) for i in re.findall(r'[.\\d]+',exp)]\n    ops = exp\n    for i in range(10):\n        ops = ops.replace(str(i),'')\n    ops = ops.replace('.','')\n    p = list(ops)\n    for i in ['+', '-', '*','$']:\n        ops = ops.replace(i,'') \n    if (ops!='') or (len(p)>=len(s)):\n        return '400: Bad request'\n    for i in range(len(p)):\n        if p[i]=='$':\n            o = i\n            j = i+1\n            while True:\n                if s[j]=='o':\n                    j = j +1\n                else:\n                    break\n            while True:\n                if s[o]=='o':\n                    o = o - 1\n                else:\n                    break\n            s[o] = s[o]/s[j]\n            s[j] = 'o'\n    for i in range(len(p)):\n        if p[i]=='*':\n            o = i\n            j = i+1\n            while True:\n                if s[j]=='o':\n                    j = j +1\n                else:\n                    break\n            while True:\n                if s[o]=='o':\n                    o = o - 1\n                else:\n                    break\n            s[o] = s[o]*s[j]\n            s[j] = 'o'\n    for i in range(len(p)):\n        if p[i]=='-':\n            o = i\n            j = i+1\n            while True:\n                if s[j]=='o':\n                    j = j +1\n                else:\n                    break\n            while True:\n                if s[o]=='o':\n                    o = o - 1\n                else:\n                    break\n            s[o] = s[o]-s[j]\n            s[j] = 'o'\n    for i in range(len(p)):\n        if p[i]=='+':\n            o = i\n            j = i+1\n            while True:\n                if s[j]=='o':\n                    j = j +1\n                else:\n                    break\n            while True:\n                if s[o]=='o':\n                    o = o - 1\n                else:\n                    break\n            s[o] = s[o]+s[j]\n            s[j] = 'o'\n    for i in s:\n        if i != 'o':\n            return i", "def calculate(expression):\n    print(expression)\n    expression = \"\".join([\" {} \".format(num) if num in \"+-*$\" else num for num in expression]).split()\n    while '$' in expression:\n        try:\n            for num in expression:\n                if num == '$':\n                    first = expression.pop(expression.index(num)-1)\n                    second = expression.pop(expression.index(num)+1)\n                    ans = str(float(float(first)/float(second)))\n                    expression[expression.index(num)] = ans\n        except ValueError:\n            return '400: Bad request'\n    while '*' in expression:\n        try:\n            for num in expression:\n                if num == '*':\n                    first = expression.pop(expression.index(num)-1)\n                    second = expression.pop(expression.index(num)+1)\n                    ans = str(float(float(first)*float(second)))\n                    expression[expression.index(num)] = ans\n        except ValueError:\n            return '400: Bad request'\n    while '-' in expression:\n        try:\n            for num in expression:\n                if num == '-':\n                    first = expression.pop(expression.index(num)-1)\n                    second = expression.pop(expression.index(num)+1)\n                    ans = str(float(float(first)-float(second)))\n                    expression[expression.index(num)] = ans\n        except ValueError:\n            return '400: Bad request'\n    while '+' in expression:\n        try:\n            for num in expression:\n                if num == '+':\n                    first = expression.pop(expression.index(num)-1)\n                    second = expression.pop(expression.index(num)+1)\n                    ans = str(float(float(first)+float(second)))\n                    expression[expression.index(num)] = ans\n        except ValueError:\n            return '400: Bad request'\n    try:\n        return float(expression[0])\n    except ValueError:\n        return '400: Bad request'\n\n        \n"]
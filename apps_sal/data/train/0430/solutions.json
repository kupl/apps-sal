["class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        n = len(s)\n        MOD = 10**9 + 7\n        seen = dict()\n        \n        a = 1\n        for i in range(n):\n            char = s[i]\n            b = 2 * a\n            if char in seen:\n                b -= seen[char]\n            \n            b %= MOD\n            seen[char] = a\n            a = b\n        return a - 1\n                \n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        \n        # DP(i) = number of distinct subseq ending at i\n        # DP(i) = 1 + sum(DP[:i]) if it is a new letter\n        # DP(i) = 1 + sum(DP[j:i]) where j is last occurence of letter S[i]\n        \n        # abc -> [1, 2, 4]\n        # aba -> [1, 2, 3]\n        # aaa -> [1, 1, 1]\n        # abaa -> [1, 2, 3, 3] a, b, ab, aa, ba, aba, aaa, baa, abaaa\n        \n        n = len(S)\n        MOD = int(1e9 + 7)\n        I = dict()\n        PS = [0] * (n + 1)\n        \n        for i, c in enumerate(S):\n            if c not in I:\n                dpi = 1 + PS[i] % MOD\n            else:\n                dpi = PS[i] - PS[I[c]]\n            I[c] = i\n            PS[i + 1] = PS[i] + dpi\n            \n        return PS[-1] % MOD\n    \n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        res, last = 1, {}\n        for c in S:\n            temp = res * 2\n            if c in last:\n                temp -= last[c]\n            last[c] = res\n            res = temp\n        return (res - 1) % (10**9 + 7)\n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        def itertools_appr():\n            if not S: return 0\n            from itertools import combinations\n            n = len(S)\n            MOD = 1000_000_000 + 7\n            l = 0\n            for i in range(1,n+1):\n                l += len(set(combinations(S, i))) % MOD\n            return l\n        \n        def from_soln():\n            '''\n            Imagine we knew the subsequence count without the last char, dp[-1]\n            dp[-1] should be twice of the previous one. However we need to account\n            for the presence of the same last char previously.\n            S = \\\"abab\\\"\n            dp[0], with chars upto S[0] = { '', 'a' }\n            dp[1], with chars upto S[1] = dp[1] * 2 - subseqs we would have\n                double counted. {'', 'a', 'b', 'ab'}\n                = 4\n            dp[2], with chars upto S[2] = 2*dp[1] - adj for double counting\n                {'', 'a', 'b', 'ab'} --> dp[1]\n                {'a', 'aa', 'ba', 'aba'} --> dp[1] + 'a'\n                'a' is double counted = dp[last['a']] - 1\n                = 7\n            dp[3], with chars upto S[3] = 2*dp[2] - adjustments for double counting\n                {'','a','b','ab','aa','ba','aba'} <-- dp[2]\n                {'b','ab','bb','abb','aab','bab','abab'} <-- dp[2] + 'b'\n                'b', 'ab' are double counted = dp[last['b']] - 1\n                = 14\n            \n            dp[k] = 2*dp[k-1] - dp[last[S[k]]] - 1, (1 for '')\n            '''\n            dp = [1]\n            last = {}\n            for i,x in enumerate(S):\n                dp.append(2*dp[-1])\n                if x in last:\n                    dp[-1] -= dp[last[x]]\n                last[x] = i\n            return (dp[-1] - 1) % (10**9+7)\n        return from_soln()\n", "from collections import Counter\nclass Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        res = 1\n        endCount = Counter()\n        for s in S:\n            res, endCount[s] = 2 * res - endCount[s], res\n        return (res-1) % (10 ** 9 + 7)\n", "class Solution:\n    def distinctSubseqII(self, s: str) -> int:        \n        dp = Counter()\n        for c in s: dp[c] = sum(dp.values()) + 1\n        return sum(dp.values()) % (10**9+7)", "class Solution(object):\n    def distinctSubseqII(self, S):\n        dp = [1]\n        last = {}\n        for i, x in enumerate(S):\n            dp.append(dp[-1] * 2)\n            if x in last:\n                dp[-1] -= dp[last[x]]\n            last[x] = i\n\n        return (dp[-1] - 1) % (10**9 + 7)", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        mod=1000000007\n        if(not S):\n            return 0\n        d={}\n        dp=[0 for i in range(0,len(S))]\n        dp[0]=2\n        d[S[0]] = 0\n        for i in range(1,len(S)):\n            dp[i] = 2*dp[i-1]\n            v=0\n            if(S[i] in d):\n                last=d[S[i]]\n                if(last-1>=0):\n                    v=dp[last-1]\n                else:\n                    v=1\n            dp[i] = (dp[i] - v)%mod\n            d[S[i]] = i\n        return dp[-1]-1", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        mod = 10**9 + 7\n        n = len(S)\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(1, n):\n            dp[i] = dp[i - 1] * 2 + 1\n            for j in range(i - 1, -1, -1):\n                if S[j] == S[i]:\n                    if j > 0:\n                        dp[i] -= dp[j - 1]\n                    dp[i] -= 1\n                    break\n            dp[i] %= mod\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        MOD = 10**9 + 7\n        memo = {}\n        def dp(i, j):\n            if i > j: return 0\n            if(i, j) not in memo:\n                ans = 1 + dp(i+1, j) * 2\n                for k in range(i+1, j+1):\n                    if S[k] == S[i]:\n                        ans = dp(i+1, j) * 2 - dp(k+1, j)\n                        break\n                memo[i, j] = ans\n            return memo[i, j]\n        return dp(0, len(S) - 1) % MOD\n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        cache = {}\n        extras = []\n        \n        module = 10 ** 9 + 7\n        _sum = 0\n        for i, s in enumerate(S):\n            if i == 0:\n                _sum += 1\n                extras.append(1)\n            else:\n                prev_indexes = cache.setdefault(s, [])\n                if not prev_indexes:\n                    extras.append(_sum + 1)\n                    _sum += (_sum + 1)\n                else:\n                    duplicated = sum([extras[j] for j in prev_indexes])\n                    extras.append(_sum + 1 - duplicated)\n                    \n                    _sum += _sum + 1 - duplicated\n            cache.setdefault(s, []).append(i)\n        return _sum % (module)", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        ln = 1000000007\n        if len(S) == 0:\n            return 0\n        l = [1]\n        \n        for i in range(1, len(S)):\n            cur = 0\n            for j in range(i-1, -1, -1):\n                cur += l[j]\n                if S[i] == S[j]:\n                    break\n                if j == 0:\n                    cur +=1\n                    \n            l.append(cur%ln)\n        \n        #print(l)\n        res = 0\n        for i in l:\n            res += i\n            res %=ln\n        \n        return res", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        MOD = 10**9 + 7\n        \n        cur = collections.defaultdict(int)\n        for c in S:\n            for k in [k for k in cur.keys()]:\n                if c!=k:\n                    cur[c] += cur[k]\n            cur[c] += 1\n            cur[c] %= MOD\n        \n        \n        return sum(cur.values()) % MOD", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        K = 1000000000 + 7\n        n = len(S)\n        dp = [0 for i in range(n+1)]\n        dp[0] = 1\n        umap = dict()\n        \n        for i in range(n):\n            dp[i+1] = (2 * dp[i]) % K\n            if S[i] in umap:\n                dp[i+1] -= dp[umap[S[i]]]\n            dp[i+1] %= K\n            umap[S[i]] = i\n        \n        result = dp[n] - 1\n        if result < 0:\n            result += K\n        return result", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        \n        # DP(i) = number of distinct subseq ending at i\n        \n        # DP(i) = 1 + sum(DP[:i]) if it is a new letter\n        \n        # DP(i) = 1 + sum(DP[j:i]) where j is last occurence of letter S[i]\n        \n        # abc -> [1, 2, 4]\n        # aba -> [1, 2, 3]\n        # aaa -> [1, 1, 1]\n        # abaa -> [1, 2, 3, 3] a, b, ab, aa, ba, aba, aaa, baa, abaaa\n        \n        n = len(S)\n        MOD = int(1e9 + 7)\n        DP = [0] * n\n        I = dict()\n        \n        for i, c in enumerate(S):\n            if c not in I:\n                DP[i] = 1 + sum(DP[:i]) % MOD\n            else:\n                DP[i] = sum(DP[I[c]:]) % MOD\n            I[c] = i\n            \n        return sum(DP) % MOD\n    \n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        res, endwith = 0, collections.Counter()\n        for c in S:\n            res, endwith[c] = res * 2 + 1 - endwith[c], res + 1\n        \n        return res % (7+10**9)\n        \n", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(S)\n        dp = collections.Counter()\n        result = 0\n        for i in range(n - 1, -1, -1):\n            old = result\n            result = (2 * old + 1 - dp[S[i]]) % MOD\n            dp[S[i]] += result - old\n        return result", "class Solution:\n    def distinctSubseqII(self, s: str) -> int:\n        isvisited =[-1]*len(s)\n        d=dict()\n        for i in range(len(s)):\n            if s[i] in d:\n                isvisited[i] = d[s[i]] \n            d[s[i]] =i \n        dp = [1]*(len(s)+1)\n        for i in range(1,len(s)+1):\n            if isvisited[i-1] == -1:\n                dp[i]=dp[i-1]*2\n            else:\n                dp[i] = 2*dp[i-1]- dp[isvisited[i-1]]\n        return (dp[-1]-1)%1000000007", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        dp, mod = [0] * len(S), 10**9 + 7\n        for i, char in enumerate(S):\n            ind = S.rfind(char, 0, i)\n            dp[i] = 1 + sum(dp[:i]) % mod if ind == -1 else sum(dp[ind:i]) % mod\n        return sum(dp) % mod\n", "class Solution(object):\n    def distinctSubseqII(self, S):\n        prev = collections.defaultdict(int)\n        res = 1\n        for c in S:\n            new = res - prev[c]\n            res += new\n            prev[c] += new\n        return (res - 1) % (10**9 + 7)  ", "class Solution:\n    def distinctSubseqII(self, S: str) -> int:\n        # Dynamic Programming\n        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # dp, last = [1], {}\n        # for i, x in enumerate(S):\n        #     dp.append(dp[-1] * 2)\n        #     if x in last:\n        #         dp[-1] -= dp[last[x]]\n        #     last[x] = i\n\n        # return (dp[-1] - 1) % (10**9 + 7)\n\n\n        dp, MOD = [0] * len(S), 10**9 + 7\n        for i, char in enumerate(S):\n            ind = S.rfind(char, 0, i)\n            dp[i] = 1 + sum(dp[:i]) % MOD if ind == -1 else sum(dp[ind:i]) % MOD\n        return sum(dp) % MOD\n"]
["import sys\ninput = sys.stdin.readline\n\ndef main():\n    R, C, N = map(int, input().split())\n    xyxy = [list(map(int, input().split())) for i in range(N)]\n\n    r = []\n\n    for i in range(N):\n        x1, y1, x2, y2 = xyxy[i]\n        # \u3069\u3061\u3089\u3082\u5468\u4e0a\u306b\u3042\u308b\u5834\u5408\u306f\u5468\u4e0a\u306e\u5ea7\u6a19\u306b\u5909\u63db\u3057\u3066\u304b\u3089\u8a18\u9332\n        if ((x1 == 0 or x1 == R) or (y1 == 0 or y1 == C)) and ((x2 == 0 or x2 == R) or (y2 == 0 or y2 == C)):\n            # \uff11\u3064\u76ee\n            if x1 == 0:\n                r.append((y1, i))\n            elif x1 == R:\n                r.append((C - y1 + C + R, i))\n            elif y1 == 0:\n                r.append((R - x1 + C * 2 + R, i))\n            else:\n                r.append((x1 + C, i))\n            # 2\u3064\u76ee\n            if x2 == 0:\n                r.append((y2, i))\n            elif x2 == R:\n                r.append((C - y2 + C + R, i))\n            elif y2 == 0:\n                r.append((R - x2 + C * 2 + R, i))\n            else:\n                r.append((x2 + C, i))\n    \n    r = sorted(r)\n    # print(r)\n    stack = []\n    for i in range(len(r)):\n        if len(stack) > 0:\n            if stack[-1] == r[i][1]:\n                stack.pop()\n            else:\n                stack.append(r[i][1])\n        else:\n            stack.append(r[i][1])\n    \n    if len(stack) > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n            \n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\n\nimport heapq\n\n\ndef coord_on_edge(x, y, R, C):\n    if y == 0:\n        return x\n    if x == R:\n        return R + y\n    if y == C:\n        return R + C + R - x\n    if x == 0:\n        return 2 * (R + C) - y\n    return None\n\n\ndef on_edge(x1, y1, x2, y2, R, C, i, edge_points):\n    c1 = coord_on_edge(x1, y1, R, C)\n    c2 = coord_on_edge(x2, y2, R, C)\n    if c1 is not None and c2 is not None:\n        heapq.heappush(edge_points, (c1, i))\n        heapq.heappush(edge_points, (c2, i))\n\n\ndef solve():\n    R, C, N = list(map(int, input().split()))\n    edge_points = []            # (coord, point#)\n    for i in range(N):\n        x1, y1, x2, y2 = list(map(int, input().split()))\n        on_edge(x1, y1, x2, y2, R, C, i, edge_points)\n    q = []\n    while edge_points:\n        c, i = heapq.heappop(edge_points)\n        # print((c, i))           # dbg\n        if len(q) and q[-1] == i:\n            q.pop()\n        else:\n            q.append(i)\n    if len(q):\n        return \"NO\"\n    return \"YES\"\n\n\nprint((solve()))\n", "import sys, math, collections, heapq, itertools\nF = sys.stdin\ndef single_input(): return F.readline().strip(\"\\n\")\ndef line_input(): return F.readline().strip(\"\\n\").split()\n\ndef solve():\n    R, C, N = map(int, line_input())\n    u, l, r, d = [], [], [], []\n    for i in range(N):\n        x, y, z, w = map(int, line_input())\n        if x == 0:\n            if z == 0: \n                u.append((y, i))\n                u.append((w, i))\n            elif w == C:\n                u.append((y, i))\n                r.append((z, i))\n            elif z == R:\n                u.append((y, i))\n                d.append((w, i))\n            elif w == 0:\n                u.append((y, i))\n                l.append((z, i))\n        elif x == R:\n            if z == 0: \n                d.append((y, i))\n                u.append((w, i))\n            elif w == C:\n                d.append((y, i))\n                r.append((z, i))\n            elif z == R:\n                d.append((y, i))\n                d.append((w, i))\n            elif w == 0:\n                d.append((y, i))\n                l.append((z, i))\n        elif y == 0:\n            if z == 0: \n                l.append((x, i))\n                u.append((w, i))\n            elif w == C:\n                l.append((x, i))\n                r.append((z, i))\n            elif z == R:\n                l.append((x, i))\n                d.append((w, i))\n            elif w == 0:\n                l.append((x, i))\n                l.append((z, i))\n        elif y == C:\n            if z == 0: \n                r.append((x, i))\n                u.append((w, i))\n            elif w == C:\n                r.append((x, i))\n                r.append((z, i))\n            elif z == R:\n                r.append((x, i))\n                d.append((w, i))\n            elif w == 0:\n                r.append((x, i))\n                l.append((z, i))\n    u.sort()\n    r.sort()\n    d.sort(reverse = True)\n    l.sort(reverse = True)\n\n    s = []\n    used = set()\n    crossed = True\n    for point, n in u:\n        if n not in used:\n            s.append(n)\n            used |= {n}\n        else:\n            if s[-1] != n: break\n            else: s.pop()\n    else:\n        for point, n in r:\n            if n not in used:\n                s.append(n)\n                used |= {n}\n            else:\n                if s[-1] != n: break\n                else: s.pop()\n        else:\n            for point, n in d:\n                if n not in used:\n                    s.append(n)\n                    used |= {n}\n                else:\n                    if s[-1] != n: break\n                    else: s.pop()\n            else:\n                for point, n in l:\n                    if n not in used:\n                        s.append(n)\n                        used |= {n}\n                    else:\n                        if s[-1] != n: break\n                        else: s.pop()\n                else: crossed = False\n\n    print(\"NO\" if crossed else \"YES\")\n                            \n    return 0\n  \ndef __starting_point():\n    solve()\n__starting_point()", "R,C,N=list(map(int,input().split()))\nE=[]\nfor i in range(N):\n  x1,y1,x2,y2=list(map(int,input().split()))\n  if (0<x1<R and 0<y1<C) or (0<x2<R and 0<y2<C):\n    continue\n  if y1==0:\n    E.append((x1,i))\n  elif x1==R:\n    E.append((R+y1,i))\n  elif y1==C:\n    E.append((2*R+C-x1,i))\n  elif x1==0:\n    E.append((2*R+2*C-y1,i))\n  if y2==0:\n    E.append((x2,i))\n  elif x2==R:\n    E.append((R+y2,i))\n  elif y2==C:\n    E.append((2*R+C-x2,i))\n  elif x2==0:\n    E.append((2*R+2*C-y2,i))\nE.sort()\nvisited=[False]*N\nstack=[]\nfor p in E:\n  if not visited[p[1]]:\n    stack.append(p[1])\n    visited[p[1]]=True\n  elif visited[p[1]]:\n    if stack[-1]==p[1]:\n      stack.pop()\n    else:\n      print(\"NO\")\n      return\nprint(\"YES\")\n  \n", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\n\ndef main():\n    R,C,N = LI()\n    a = []\n    def ff(x,y):\n        if x == 0:\n            return (0,y)\n        if x == R:\n            return (R,-y)\n        if y == 0:\n            return (R+1, -x)\n        return (1, x)\n\n    for _ in range(N):\n        x1,y1,x2,y2 = LI()\n        if (0 < x1 < R and 0 < y1 < C) or (0 < x2 < R and 0 < y2 < C):\n            continue\n        a.append((ff(x1,y1),_))\n        a.append((ff(x2,y2),_))\n    a.sort()\n    b = [a[i][1] for i in range(len(a))]\n    s = [None] * (len(b))\n    si = -1\n    for c in b:\n        if si < -1:\n            si += 1\n            s[0] = c\n            continue\n        if s[si] == c:\n            si -= 1\n        else:\n            si += 1\n            s[si] = c\n\n    if si > 1:\n        return 'NO'\n    return 'YES'\n\nprint((main()))\n\n\n\n\n\n\n", "class BIT():\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\n    add: \u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\n    get_val: i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\n    i, l, r\u306f0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nfrom operator import itemgetter\n\n\ndef compress(array):\n    \"\"\"\u5ea7\u6a19\u5727\u7e2e\u3057\u305f\u30ea\u30b9\u30c8\u3092\u8fd4\u3059\"\"\"\n    set_ = set()\n    for num in array:\n        set_.add(num[0])\n        set_.add(num[1])\n    array2 = sorted(set_)\n    memo = {value: index for index, value in enumerate(array2)}\n    for i in range(len(array)):\n        array[i] = (memo[array[i][0]], memo[array[i][1]])\n    return array\n\ndef on_line(x, y):\n    return x == 0 or x == r or y == 0 or y == c\n\ndef val(x, y):\n    if y == 0:\n        return x\n    if x == r:\n        return r + y\n    if y == c:\n        return r + c + (r - x)\n    if x == 0:\n        return r + c + r + (c - y)\n\nr, c, n = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(n)]\n\nres = []\nfor i in range(n):\n    x1, y1, x2, y2 = info[i]\n    if on_line(x1, y1) and on_line(x2, y2):\n        left = val(x1, y1)\n        right = val(x2, y2)\n        if left > right:\n            left, right = right, left\n        res.append((left, right))\n\n\nres = sorted(res, key=itemgetter(1))\nres = compress(res)\n\nbit = BIT(2 * len(res))\nfor left, right in res:\n    if bit.get_val(left) != 0:\n        print(\"NO\")\n        return\n    else:\n        bit.add(left, right + 1, 1)\nprint(\"YES\")\n\n\n", "from operator import itemgetter\nimport collections\nr,c,n=map(int,input().split())\nl=[list(map(int,input().split())) for i in range(n)]\ne1=[];e2=[];e3=[];e4=[]\nfor i in range(n):\n  if (l[i][0]==0 or l[i][0]==r or l[i][1]==0 or l[i][1]==c) and (l[i][2]==0 or l[i][2]==r or l[i][3]==0 or l[i][3]==c):\n    if l[i][0]==0 and l[i][1]!=c:\n      e1.append([i+1,l[i][0],l[i][1]])\n    elif l[i][1]==c and l[i][0]!=r:\n      e2.append([i+1,l[i][0],l[i][1]])\n    elif l[i][0]==r and l[i][1]!=0:\n      e3.append([i+1,l[i][0],l[i][1]])\n    else:\n      e4.append([i+1,l[i][0],l[i][1]])\n    if l[i][2]==0 and l[i][3]!=c:\n      e1.append([i+1,l[i][2],l[i][3]])\n    elif l[i][3]==c and l[i][2]!=r:\n      e2.append([i+1,l[i][2],l[i][3]])\n    elif l[i][2]==r and l[i][3]!=0:\n      e3.append([i+1,l[i][2],l[i][3]])\n    else:\n      e4.append([i+1,l[i][2],l[i][3]])\ne1=sorted(e1,key=itemgetter(2))\ne2=sorted(e2,key=itemgetter(1))\ne3=sorted(e3,key=itemgetter(2))\ne4=sorted(e4,key=itemgetter(1))\ne3.reverse()\ne4.reverse()\ne=e1+e2+e3+e4\n\nq=[]\nq=collections.deque(q)\nfor i in range(len(e)):\n  if len(q)==0:\n    q.append(e[i][0])\n  else:\n    if q[-1]==e[i][0]:\n      q.pop()\n    else:\n      q.append(e[i][0])\nif len(q)==0:\n  print('YES')\nelse:\n  print('NO')", "from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nR, C, N = reads()\n\ndef edge(x, y):\n  return x == 0 or x == R or y == 0 or y == C\n\ndef flat(x, y):\n  assert edge(x, y)\n  if y == 0:\n    return x\n  elif x == R:\n    return R + y\n  elif y == C:\n    return R + C + (R - x)\n  else:\n    assert x == 0\n    return 2 * R + C + (C - y)\n\nps = []\nfor i in range(N):\n  x1, y1, x2, y2 = reads()\n  if edge(x1, y1) and edge(x2, y2):\n    ps.append((flat(x1, y1), i))\n    ps.append((flat(x2, y2), i))\nps.sort()\n\nstack = []\nfor _, i in ps:\n  if len(stack) > 0 and stack[-1] == i:\n    stack.pop()\n  else:\n    stack.append(i)\n\nprint(\"YES\" if len(stack) == 0 else \"NO\")", "R,C,N = list(map(int,input().split()))\n\npoint = []\n\ndef XtoZ(x,y):\n    if x==0:\n        if y==0:\n            return 0\n        else:\n            return 2*R + 2*C - y\n    elif x==R:\n        return R + y\n    elif y==0:\n        return x\n    elif y==C:\n        return 2*R + C - x\n\nfor i in range(N):\n    x1,y1,x2,y2 = list(map(int,input().split()))\n    if ((x1==0 or x1==R) or (y1==0 or y1==C)) and ((x2==0 or x2==R) or (y2==0 or y2==C)):\n        point.append([XtoZ(x1,y1),i])\n        point.append([XtoZ(x2,y2),i])\n\npoint.sort(key = lambda x:x[0])\n\nflag = [0]*N\n\nfrom collections import deque\n\nQ = deque()\n\nflag = [True]*N\nflag2=False\nfor p in point:\n    if flag[p[1]]:\n        Q.append(p[1])\n        flag[p[1]] = False\n    else:\n        if Q.pop()!=p[1]:\n            flag2=True\n            break\n\nif flag2:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\n\nX, Y, N = map(int, input().split())\nU = []\nD = []\nR = []\nL = []\n\ndef mustconsider(x, y):\n    return (x in [0, X]) or (y in [0, Y])\n\ndef divide(x, y, i):\n    if x == 0 and y != Y:\n        L.append((y, i))\n    if x == X and y != 0:\n        R.append((y, i))\n    if y == 0 and x != 0:\n        D.append((x, i))\n    if y == Y and x != X:\n        U.append((x, i))\n\nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    if mustconsider(x1, y1) and mustconsider(x2, y2):\n        divide(x1, y1, i)\n        divide(x2, y2, i)\n\nD.sort()\nR.sort()\nU.sort(reverse=True)\nL.sort(reverse=True)\n\nArounds = []\nfor _, ind in D:\n    Arounds.append(ind)\nfor _, ind in R:\n    Arounds.append(ind)\nfor _, ind in U:\n    Arounds.append(ind)\nfor _, ind in L:\n    Arounds.append(ind)\n\nstack = []\nfor a in Arounds:\n    if not stack:\n        stack.append(a)\n    else:\n        if stack[-1] == a:\n            stack.pop()\n        else:\n            stack.append(a)\n\nprint(\"YES\" if not stack else \"NO\")", "from collections import deque\nr, c, n = [int(item) for item in input().split()]\non_edge = [[] for _ in range(4)]\nfor i in range(n):\n    x1, y1, x2, y2 = [int(item) for item in input().split()]\n    v1_on_edge = x1 == 0 or x1 == r or y1 == 0 or y1 == c \n    v2_on_edge = x2 == 0 or x2 == r or y2 == 0 or y2 == c \n    if v1_on_edge and v2_on_edge:\n        if x1 == 0:\n            on_edge[0].append([y1, i])\n        elif x1 == r:\n            on_edge[2].append([y1, i])\n        elif y1 == 0:\n            on_edge[3].append([x1, i])\n        elif y1 == c:\n            on_edge[1].append([x1, i])\n        if x2 == 0:\n            on_edge[0].append([y2, i])\n        elif x2 == r:\n            on_edge[2].append([y2, i])\n        elif y2 == 0:\n            on_edge[3].append([x2, i])\n        elif y2 == c:\n            on_edge[1].append([x2, i])\nfor i in range(4):\n    if i <= 1:\n        on_edge[i].sort()\n    else:\n        on_edge[i].sort(reverse=True)\ntotal = [item for line in on_edge for item in line]        \nst = deque()\nst.append(-1)\nfor val, item in total:\n    if st[-1] == item:\n        st.pop()\n    else:\n        st.append(item)\nif st[-1] == -1:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\n", "# coding: utf-8\n# Your code here!\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline #\u6587\u5b57\u5217\u5165\u529b\u306e\u3068\u304d\u306f\u6ce8\u610f\n\n\nr,c,n = [int(i) for i in readline().split()]\n#xyxy = [[int(i) for i in readline().split()] for _ in range(n)] \n#for i,(x1,y1,x2,y2) in enumerate(xyxy):\n\ndef addedge(x1,y1):\n    if   y1 == 0:\n        edge.append((x1,i))\n    elif x1 == r:\n        edge.append((r+y1,i))\n    elif y1 == c:\n        edge.append((r+c+(r-x1),i))\n    else:\n        edge.append((r+c+r+(c-y1),i))\n    return \n\n\nedge = []\nfor i in range(n):\n    x1,y1,x2,y2 = [int(i) for i in readline().split()]\n    if (x1 not in (0,r) and y1 not in (0,c)) or (x2 not in (0,r) and y2 not in (0,c)):\n        continue\n    \n    addedge(x1,y1)\n    addedge(x2,y2)\n\n        \nedge.sort()\n#print(edge)\n\nans = []\nfor d,i in edge:\n    if ans and ans[-1] == i:\n        ans.pop()\n    else:\n        ans.append(i)\n\nif ans:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    \n\n\n    \n\n\n\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef calc(a, b):\n    if b == 0: return a\n    if a == R: return b + R\n    if b == C: return R + C + (R - a)\n    if a == 0: return R + C + R + (C - b)\n\nR, C, N = map(int, input().split())\nA = []\nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    if (x1 == 0 or x1 == R or y1 == 0 or y1 == C) and (x2 == 0 or x2 == R or y2 == 0 or y2 == C):\n        A.append((calc(x1, y1), i))\n        A.append((calc(x2, y2), i))\n\nA = [l[1] for l in sorted(A, key = lambda x: x[0])]\nB = []\n\nwhile A:\n    while len(B) and A[-1] == B[-1]:\n        A.pop()\n        B.pop()\n    if A:\n        B.append(A.pop())\n\nprint(\"NO\" if len(B) else \"YES\")", "R, C, N = map(int, input().split())\n\nconsider = []\n\ndef dist(x, y):\n    if x == 0:\n        return R * 2 + C + (C - y)\n    if x == R:\n        return R + y\n    if y == 0:\n        return x\n    if y == C:\n        return R + C + (R - x)\n    \n    \nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    if ((x1 == 0 or x1 == R) or (y1 == 0 or y1 == C)) and ((x2 == 0 or x2 == R) or (y2 == 0 or y2 == C)):\n        consider.append((i, dist(x1, y1)))\n        consider.append((i, dist(x2, y2)))\n\nl = []\nconsider = sorted(consider, key=lambda p:p[1])\n\nfor c in consider:\n    if len(l) == 0:\n        l.append(c[0])\n        continue\n    elif c[0] == l[-1]:\n        l.pop()\n    else:\n        l.append(c[0])\n\nif len(l) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "def calc_pos(x, y, R, C):\n    if y == 0:\n        return x\n    if y == C:\n        return 2 * R + C - x\n    if x == R:\n        return R + y\n    if x == 0:\n        return 2 * R + 2 * C - y\n\ndef read_data():\n    R, C, N = list(map(int, input().split()))\n    pairs = []\n    xys = []\n    idx = 0\n    for i in range(N):\n        x1, y1, x2, y2 = list(map(int, input().split()))\n        xys.append((x1, y1))\n        xys.append((x2, y2))\n        if (x1 != 0 and x1 != R and y1 != 0 and y1 != C) or (x2 != 0 and x2 != R and y2 != 0 and y2 != C):\n            continue\n        a = calc_pos(x1, y1, R, C)\n        b = calc_pos(x2, y2, R, C)\n        pairs.append((a, idx))\n        pairs.append((b, idx))\n        idx += 1\n    pairs.sort()\n    return pairs, xys\n\ndef is_valid(xys):\n    xys.sort()\n    prev_x, prev_y = xys[0]\n    for x, y in xys[1:]:\n        if prev_x == x and prev_y == y:\n            return False\n        prev_x = x\n        prev_y = y\n    return True\n\ndef solve(pairs, xys):\n    if len(xys) == 2:\n        return \"YES\"\n    if not is_valid(xys):\n        return \"NO\"    \n    idxs = [i for a, i in pairs]\n    stack = []\n    for idx in idxs:\n        if stack and stack[-1] == idx:\n            stack.pop()\n            continue\n        stack.append(idx)\n    if stack:\n        return \"NO\"\n    else:\n        return \"YES\"\n\npairs, xys = read_data()\nprint((solve(pairs, xys)))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\nR,C,N=map(int,input().split())\ntable=[]\ndef f(i,j):\n    if i==0:\n        return j\n    if j==C:\n        return C+i\n    if i==R:\n        return R+C+C-j\n    if j==0:\n        return R+R+C+C-i\nfor i in range(N):\n    a,b,c,d=map(int,input().split())\n    if (0<a<R and 0<b<C) or (0<c<R and 0<d<C):\n        continue\n    table.append((f(a,b),i))\n    table.append((f(c, d), i))\ntable.sort()\nH=deque()\nfor i in range(len(table)):\n    if len(H)!=0 and H[-1]==table[i][1]:\n        H.pop()\n    else:\n        H.append(table[i][1])\n#print(H,table)\nwhile len(H)!=0 and H[0]==H[-1]:\n    H.popleft()\n    H.pop()\nif len(H)==0:\n    print('YES')\nelse:\n    print('NO')", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef calc(a, b):\n    if b == 0: return a\n    if a == R: return b + R\n    if b == C: return R + C + (R - a)\n    if a == 0: return R + C + R + (C - b)\n\nR, C, N = map(int, input().split())\nA = []\nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    if (x1 == 0 or x1 == R or y1 == 0 or y1 == C) and (x2 == 0 or x2 == R or y2 == 0 or y2 == C):\n        A.append((calc(x1, y1), i))\n        A.append((calc(x2, y2), i))\n\nA = [l[1] for l in sorted(A, key = lambda x: x[0])]\nB = []\n\nwhile A:\n    while len(B) and A[-1] == B[-1]:\n        A.pop()\n        B.pop()\n    if A:\n        B.append(A.pop())\n\nprint(\"NO\" if len(B) else \"YES\")", "#!/usr/bin/env python3\nw, h, n = list(map(int, input().split()))\ndef proj(x, y):\n    if y == 0:\n        return x\n    elif x == w:\n        return w + y\n    elif y == h:\n        return w + h + (w - x)\n    elif x == 0:\n        return w + h + w + (h - y)\n    else:\n        return None\nps = []\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    p1 = proj(x1, y1)\n    p2 = proj(x2, y2)\n    if p1 is not None and p2 is not None:\n        ps += [ (p1, i), (p2, i) ]\nps.sort()\nstk = []\nfor _, i in ps:\n    if stk and stk[-1] == i:\n        stk.pop()\n    else:\n        stk.append(i)\nresult = not stk\nprint(([ 'NO', 'YES' ][ result ]))\n", "# coding: utf-8\nimport array, bisect, collections, copy, heapq, itertools, math, random, re, string, sys, time\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n\n\ndef II(): return int(input())\ndef ILI(): return list(map(int, input().split()))\ndef IAI(LINE): return [ILI() for __ in range(LINE)]\ndef IDI(): return {key: value for key, value in ILI()}\n\n\ndef read():\n    R, C, N = ILI()\n    num_point = []\n    for __ in range(N):\n        x_1, y_1, x_2, y_2 = ILI()\n        num_point.append([(x_1, y_1), (x_2, y_2)])\n    return R, C, N, num_point\n\n\n# \u5468\u4e0a\u3092 (0, 0) \u3092\u539f\u70b9\u3068\u3057\u3066\u53cd\u6642\u8a08\u56de\u308a\u306b 1 \u672c\u306e\u6570\u76f4\u7dda\u3068\u3057\u305f\u6642\u306e point \u306e\u5ea7\u6a19\u3092\u8fd4\u3059\uff0e\n# \u5468\u4e0a\u306b\u3042\u308b\u304b\u306e\u5224\u5b9a\u3082\u884c\u3046\uff0e\ndef change_edge_point(R, C, point):\n    x, y = point\n    if x == 0:\n        return R * 2 + C + (C - y)\n    if x == R:\n        return R + y\n    if y == 0:\n        return x\n    if y == C:\n        return R + C + (R - x)\n\n\ndef solve(R, C, N, num_point):\n    point_double = []\n    for ind, point in enumerate(num_point):\n        p_1, p_2 = point\n        if ((p_1[0] == 0 or p_1[0] == R) or (p_1[1] == 0 or p_1[1] == C)) and ((p_2[0] == 0 or p_2[0] == R) or (p_2[1] == 0 or p_2[1] == C)):\n            point_double.append((ind + 1, change_edge_point(R, C, p_1)))\n            point_double.append((ind + 1, change_edge_point(R, C, p_2)))\n    point_double.sort(key=lambda  x: x[1])\n    stack = []\n    for point in point_double:\n        if len(stack) == 0:\n            stack.append(point[0])\n            continue\n        if point[0] == stack[-1]:\n            stack.pop()\n        else:\n            stack.append(point[0])\n    \n    if len(stack) == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n    \n\ndef main():\n    params = read()\n    print((solve(*params)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\n\ndef main():\n    R,C,N = LI()\n    a = []\n    def ff(x,y):\n        if x == 0:\n            return (0,y)\n        if x == R:\n            return (R,-y)\n        if y == 0:\n            return (R+1, -x)\n        return (1, x)\n\n    for _ in range(N):\n        x1,y1,x2,y2 = LI()\n        if (0 < x1 < R and 0 < y1 < C) or (0 < x2 < R and 0 < y2 < C):\n            continue\n        a.append((ff(x1,y1),_))\n        a.append((ff(x2,y2),_))\n    a.sort()\n    b = [a[i][1] for i in range(len(a))]\n    s = [None] * (len(b))\n    si = -1\n    for c in b:\n        if si < -1:\n            si += 1\n            s[0] = c\n            continue\n        if s[si] == c:\n            si -= 1\n        else:\n            si += 1\n            s[si] = c\n\n    if si > 1:\n        return 'NO'\n    return 'YES'\n\nprint((main()))\n\n\n\n\n\n\n", "def put(i, x, y):\n    if x == 0:\n        on_top.append((y, i))\n    elif x == r:\n        on_bottom.append((y, i))\n    elif y == 0:\n        on_left.append((x, i))\n    else:\n        on_right.append((x, i))\n\n\non_top, on_bottom, on_left, on_right = [], [], [], []\n\nr, c, n = list(map(int, input().split()))\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if 0 < x1 < r and 0 < y1 < c:\n        continue\n    if 0 < x2 < r and 0 < y2 < c:\n        continue\n    put(i, x1, y1)\n    put(i, x2, y2)\non_top.sort()\non_bottom.sort(reverse=True)\non_left.sort(reverse=True)\non_right.sort()\nstack = []\nfor on_edge in [on_top, on_right, on_bottom, on_left]:\n    for p, i in on_edge:\n        if stack and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n\nprint(('NO' if stack else 'YES'))\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            \n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n                \n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    \n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q!=[] and Q[-1][1] < x1:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n    \nmain()", "r, c, n = map(int, input().split())\ndots = []\nnum = 0\nfor i in range(n):\n\tx1, y1, x2, y2 = map(int, input().split())\n\tif (0 < x1 < r and 0 < y1 < c) or (0 < x2 < r and 0 < y2 < c):\n\t\tcontinue\n\telse:\n\t\tnum += 1\n\t\td1 = (x1, y1)\n\t\td2 = (x2, y2)\n\t\tif x1 == 0:\n\t\t\tdots.append((y1, i))\n\t\telif y1 == c:\n\t\t\tdots.append((c + x1, i))\n\t\telif x1 == r:\n\t\t\tdots.append((2 * c + r - y1, i))\n\t\telse:\n\t\t\tdots.append((2 * (r + c) - x1, i))\n\n\t\tif x2 == 0:\n\t\t\tdots.append((y2, i))\n\t\telif y2 == c:\n\t\t\tdots.append((c + x2, i))\n\t\telif x2 == r:\n\t\t\tdots.append((2 * c + r - y2, i))\n\t\telse:\n\t\t\tdots.append((2 * (r + c) - x2, i))\n\n#print(dots)\nif num <= 1:\n\tprint(\"YES\")\nelse:\n\tdots.sort(key=lambda x: x[0])\n\tstack = []\n\tfor i in range(num * 2):\n\t\tif stack == []:\n\t\t\tstack.append(dots[i][1])\n\t\telse:\n\t\t\tif stack[-1] == dots[i][1]:\n\t\t\t\tstack.pop()\n\t\t\telse:\n\t\t\t\tstack.append(dots[i][1])\n\tif stack:\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")", "w, h, n = list(map(int, input().split()))\n\nvec = []\n\nl = []\nb = []\nr = []\nt = []\nfor i in range(n):\n    x, y, x1, y1 = list(map(int, input().split()))\n    c = [x, y, x1, y1]\n    if( ((c[0] == 0 or c[0] == w) or (c[1] == 0 or c[1] == h)) and ((c[2] == 0 or c[2] == w) or (c[3] == 0 or c[3] == h)) ):\n        if x == 0:\n            l.append([x, y, i])\n        elif y == 0:\n            t.append([x, y, i])\n        elif x == w:\n            r.append([x, y, i])\n        elif y == h:\n            b.append([x, y, i])\n        if x1 == 0:\n            l.append([x1, y1, i])\n        elif y1 == 0:\n            t.append([x1, y1, i])\n        elif x1 == w:\n            r.append([x1, y1, i])\n        elif y1 == h:\n            b.append([x1, y1, i])\n\nsorted_node = (\n          sorted(l, key=lambda x: x[1])\n        + sorted(b, key=lambda x: x[0])\n        + sorted(r, key=lambda x: x[1], reverse=True)\n        + sorted(t, key=lambda x: x[0], reverse=True)\n        )\n\n\nstack = []\n\nfor node in sorted_node:\n    if not stack or stack[-1] != node[2]:\n        stack.append(node[2])\n    else:\n        stack.pop()\n\nprint((\"NO\" if stack else \"YES\"))\n", "import sys\ninput = sys.stdin.readline\nr,c,n = map(int,input().split())\nxy = [list(map(int,input().split())) for i in range(n)]\nls = []\nfor x1,y1,x2,y2 in xy:\n  if (x1 in (0,r) or y1 in (0,c)) and (x2 in (0,r) or y2 in (0,c)):\n    k = []\n    for x,y in ((x1,y1),(x2,y2)):\n      if x == 0:\n        s = 2*r+2*c-y\n      if x == r:\n        s = r+y\n      if y == 0:\n        s = x\n      if y == c:\n        s = 2*r+c-x\n      k.append(s)\n    t = len(ls)//2+1\n    ls.append((k[0],t))\n    ls.append((k[1],t))\nif not ls:\n  print(\"YES\")\n  return\nls.sort()\nlsi = list(map(list,zip(*ls)))[1]\nm = len(lsi)\nstack = []\nfor i in lsi:\n  if not stack:\n    stack.append(i)\n  else:\n    if stack[-1] == i:\n      stack.pop()\n    else:\n      stack.append(i)\nif stack:\n  print(\"NO\")\nelse:\n  print(\"YES\")", "from collections import deque\n\ndef f(x, y):\n    if x == 0:\n        return y\n    if y == 0:\n        return -x\n    if x == r:\n        return -(x + y)\n    if y == c:\n        return x + y\n\nr, c, n = map(int, input().split())\nxy = []\nlxy = 0\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    d = []\n    if min(x1, y1) == 0 or x1 == r or y1 == c:\n        d.append([f(x1, y1), i])\n    if min(x2, y2) == 0 or x2 == r or y2 == c:\n        d.append([f(x2, y2), i])\n    if len(d) == 2:\n        xy.append(d[0])\n        xy.append(d[1])\n        lxy += 2\nxy.sort()\nq = deque()\nfor i in range(lxy):\n    if not q:\n        q.append(xy[i][1])\n    else:\n        if q[-1] == xy[i][1]:\n            q.pop()\n        else:\n            q.append(xy[i][1])\nprint(\"YES\" if not q else \"NO\")", "R,C,N = map(int,input().split())\n\nedges = []\n\ndef convert(x,y):\n  if y == 0:\n    return x\n  if x == R:\n    return R+y\n  if y == C:\n    return R+C+R-x\n  if x == 0:\n    return R+C+R+C-y\n  else:\n    return -1\n\n\nfor i in range(N):\n  a,b,c,d = map(int, input().split())\n  \n  p,q = convert(a,b),convert(c,d)\n  if p >= 0 and q >= 0:\n    edges.append((p,q) if p < q else (q,p))\n\nedges.sort()\n\n# print(edges)\n\n\nstack = [R+R+C+C]\nflag = 'YES'\nfor a,b in edges:\n  while a >= stack[-1]:\n    stack.pop()\n\n  if b > stack[-1]:\n    flag = 'NO'\n    break\n  else:\n    stack.append(b)\n\nprint(flag)", "R, C, N = list(map(int, input().split()))\n\ndef makexy(x1, y1):\n    if y1 == 0:\n        return x1\n    elif x1==R:\n        return R+y1\n    elif y1 == C:\n        return R*2 + C - x1\n    else:\n        return R*2 + C*2 - y1\n\n\nXY = []\nXY2 = []\nD = []\nfor _ in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if (x1 in [0, R] or y1 in [0, C]) and (x2 in [0, R] or y2 in [0, C]):\n        xy1 = makexy(x1, y1)\n        xy2 = makexy(x2, y2)\n        xy1, xy2 = sorted((xy1, xy2))\n        XY.append((xy1, xy2))\n        XY2.append((xy1, 0))\n        XY2.append((xy2, 1))\n        D.append(xy2-xy1)\n\n#print(XY)\nXY.sort()\nXY2.sort()\nD.sort()\n\nD2 = []\nStack = []\nfor xy in XY2:\n    if xy[1] == 0:\n        Stack.append(xy)\n    else:\n        D2.append(xy[0]-Stack[-1][0])\n        del Stack[-1]\n\nD2.sort()\n#print(D, D2)\nif D == D2:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "def calc(x,y):\n\tif y==0:\n\t\treturn x\n\telif x==r:\n\t\treturn r+y\n\telif y==c:\n\t\treturn r*2+c-x\n\telif x==0:\n\t\treturn r*2+c*2-y\n\telse:\n\t\treturn -1\nr,c,n=map(int,input().split())\npts=[]\nfor i in range(n):\n\tx1,y1,x2,y2=map(int,input().split())\n\tu,v=calc(x1,y1),calc(x2,y2)\n\tif u>=0 and v>=0:\n\t\tpts.append((u,i))\n\t\tpts.append((v,i))\npts=sorted(pts)\nstk=[]\nfor a,b in pts:\n\tif len(stk)==0 or stk[-1]!=b:\n\t\tstk.append(b)\n\telse:\n\t\tstk.pop()\nif len(stk):\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nh,w,n, *xyxy = list(map(int,read().split()))\n\ndef f(x,y):\n    if y==0: return x\n    elif x==h: return h+y\n    elif y==w: return h+w+h-x\n    else: return h+w+h+w-y    \n\nm = iter(xyxy)\nres = []\nidx = 0\nfor x1,y1,x2,y2 in zip(m,m,m,m):\n    if (x1*(h-x1)==0 or y1*(w-y1)==0) and (x2*(h-x2)==0 or y2*(w-y2)==0):\n        res.append((f(x1,y1),idx))\n        res.append((f(x2,y2),idx))\n        idx += 1\n\n\nres.sort()\n#print(res)\n\nst = []\nfor d,i in res:\n    if st and st[-1] == i:\n        st.pop()\n    else:\n        st.append(i)\n\nif st:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n\n\n\n\n\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  r, c, n = map(int, input().split())\n  L = []\n  def trans(x, y):\n    z = None\n    if x == 0:\n      z = y\n    if y == c:\n      z = c + x\n    if x == r:\n      z = c + r + c - y\n    if y == 0:\n      z = 2*r + 2*c - x\n    return z\n\n  for _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    z1 = trans(x1, y1)\n    z2 = trans(x2, y2)\n    if z1 is not None and z2 is not None:\n      L.append((z1, z2))\n      L.append((z2, z1))\n  L.sort()\n  cnt = 0\n  D = dict()\n  for z1, z2 in L:\n    if z1 < z2:\n      cnt += 1\n      D[z1] = cnt\n    else:\n      if D[z2] != cnt:\n        print(\"NO\")\n        return\n      cnt -= 1\n  print(\"YES\")\ndef __starting_point():\n  main()\n__starting_point()", "import sys\nfrom collections import deque\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\n\n\nR,C,N = MI()\nA1,A2,A3,A4 = [],[],[],[]\n\n\ndef f(x,y):  # (x,y)\u304c\u5468\u4e0a\u306b\u3042\u308b\u304b\u5224\u5b9a\n    if x == 0 or x == R or y == 0 or y == C:\n        return True\n    return False\n\n\nfor i in range(1,N+1):\n    x1,y1,x2,y2 = MI()\n    if not (f(x1,y1) and f(x2,y2)):\n        continue\n    if y1 == 0:\n        A1.append((x1,i))\n    elif y1 == C:\n        A3.append((-x1,i))\n    elif x1 == 0:\n        A4.append((-y1,i))\n    else:\n        A2.append((y1,i))\n    if y2 == 0:\n        A1.append((x2,i))\n    elif y2 == C:\n        A3.append((-x2,i))\n    elif x2 == 0:\n        A4.append((-y2,i))\n    else:\n        A2.append((y2,i))\n\nA1.sort()\nA2.sort()\nA3.sort()\nA4.sort()\nA = A1+A2+A3+A4\n\ndeq = deque([])\nflag = [0]*(N+1)\nfor z,i in A:\n    if flag[i] == 0:\n        flag[i] = 1\n        deq.append(i)\n    else:\n        j = deq.pop()\n        if j != i:\n            print('NO')\n            return\nelse:\n    print('YES')\n", "def main(r,c,n,xy):\n  ary=[]\n  for i,(x1,y1,x2,y2) in enumerate(xy):\n    if x1 in (0,r) or y1 in (0,c):\n      if x2 in (0,r) or y2 in (0,c):\n        for x,y in ((x1,y1),(x2,y2)):\n          tmp=0\n          if x==0:\n            tmp=y\n          elif x==r:\n            tmp=r+c+(c-y)\n          elif y==0:\n            tmp=2*r+2*c-x\n          elif y==c:\n            tmp=c+x\n          ary.append([i,tmp])\n  ary.sort(key=lambda x:x[1])\n  #print(ary)\n  stc=[]\n  for i,x in ary:\n    if stc and stc[-1]==i:\n      stc.pop()\n    else:\n      stc.append(i)\n  if stc:\n    return 'NO'\n  else:\n    return 'YES'\n\ndef __starting_point():\n  r,c,n=map(int,input().split())\n  xy=[list(map(int,input().split())) for _ in range(n)]\n  print(main(r,c,n,xy))\n__starting_point()", "import sys\n\ninput=sys.stdin.readline\n\nR,C,N=list(map(int,input().split()))\n\ndef is_on_edge(x,y):\n    return x==0 or x==R or y==0 or y==C\n\nline=[]\nfor i in range(0,N):\n    x1,y1,x2,y2=list(map(int,input().split()))\n    if is_on_edge(x1,y1) and is_on_edge(x2,y2):\n        line.append([x1,y1,x2,y2])\n\nn=len(line)\nquery=[]\nfor i in range(n):\n    x1,y1,x2,y2=line[i]\n    if y1==0:\n        query.append([x1,i])\n    elif x1==R:\n        query.append([R+y1,i])\n    elif y1==C:\n        query.append([R+C+(R-x1),i])\n    else:\n        query.append([2*R+2*C-y1,i])\n\n    if y2==0:\n        query.append([x2,i])\n    elif x2==R:\n        query.append([R+y2,i])\n    elif y2==C:\n        query.append([R+C+(R-x2),i])\n    else:\n        query.append([2*R+2*C-y2,i])\n\nquery.sort(reverse=True)\nque=[]\ndic=[0 for i in range(n)]\nwhile query:\n    t,num=query.pop()\n    if dic[num]==0:\n        que.append(num)\n        dic[num]=1\n    else:\n        if que[-1]!=num:\n            print(\"NO\")\n            return\n        else:\n            dic[num]=2\n            que.pop()\nprint(\"YES\")\n", "import sys\ninput = sys.stdin.readline\n\nr, c, n = map(int, input().split())\nL = []\ndef trans(x, y):\n  z = None\n  if x == 0:\n    z = y\n  if y == c:\n    z = c + x\n  if x == r:\n    z = c + r + c - y\n  if y == 0:\n    z = 2*r + 2*c - x\n  return z\n\nfor _ in range(n):\n  x1, y1, x2, y2 = map(int, input().split())\n  z1 = trans(x1, y1)\n  z2 = trans(x2, y2)\n  if z1 is not None and z2 is not None:\n    if z1 > z2:\n      z1, z2 = z2, z1\n    L.append((z1, z2))\n    L.append((z2, z1))\nL.sort()\ncnt = 0\nD = dict()\nfor z1, z2 in L:\n  if z1 < z2:\n    cnt += 1\n    D[z1] = cnt\n  else:\n    if D[z2] != cnt:\n      print(\"NO\")\n      return\n    cnt -= 1\nprint(\"YES\")", "from cmath import phase\n\nr,c,n = list(map(int,input().split()))\nl = list()\nfor i in range(n):\n  w,x,y,z = list(map(int,input().split())) \n  if (w in (0,r) or x in (0,c)) and (y in (0,r) or z in (0,c)):\n    l.append((i,w-r/2+(x-c/2)*1j))\n    l.append((i,y-r/2+(z-c/2)*1j))\nl.sort(key=lambda t: phase(t[1]))\np = list()\nfor x,c in l:\n  if p == [] or p[-1] != x:\n    p.append(x)\n  else:\n    p.pop()\nans = [\"NO\", \"YES\"]\nprint((ans[p==[]]))\n", "R,C,n=list(map(int,input().split()))\npair=[list(map(int,input().split())) for _ in range(n)]\nu=[]\nr=[]\nd=[]\nl=[]\nfor i in range(n):\n    x1,y1,x2,y2=pair[i]\n    if 0<x1<R and 0<y1<C:continue\n    if 0<x2<R and 0<y2<C:continue\n    if x1==0:\n        u.append([y1,i])\n    if x1==R:\n        d.append([y1,i])\n    if y1==0:\n        if x1!=0 and x1!=R:\n            l.append([x1,i])\n    if y1==C:\n        if x1!=0 and x1!=R:\n            r.append([x1,i])\n    if x2==0:\n        u.append([y2,i])\n    if x2==R:\n        d.append([y2,i])\n    if y2==0:\n        if x2!=0 and x2!=R:\n            l.append([x2,i])\n    if y2==C:\n        if x2!=0 and x2!=R:\n            r.append([x2,i])\nu.sort()\nr.sort()\nd.sort(reverse=True)\nl.sort(reverse=True)\nurdl=u+r+d+l\nstack=[]\nfor i in range(len(urdl)):\n    if len(stack)==0:\n        stack.append(urdl[i][1])\n    elif stack[-1]==urdl[i][1]:\n        stack.pop()\n    else:\n        stack.append(urdl[i][1])\nprint(\"YES\" if len(stack)==0 else \"NO\")\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n  r, c, n = map(int, input().split())\n  L = []\n  def trans(x, y):\n    z = None\n    if x == 0:\n      z = y\n    if y == c:\n      z = c + x\n    if x == r:\n      z = c + r + c - y\n    if y == 0:\n      z = 2*r + 2*c - x\n    return z\n\n  for _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    z1 = trans(x1, y1)\n    z2 = trans(x2, y2)\n    if z1 is not None and z2 is not None:\n      L.append((z1, z2))\n      L.append((z2, z1))\n  L.sort()\n  cnt = 0\n  D = dict()\n  for z1, z2 in L:\n    if z1 < z2:\n      cnt += 1\n      D[z1] = cnt\n    else:\n      if D[z2] != cnt:\n        print(\"NO\")\n        return\n      cnt -= 1\n  print(\"YES\")\ndef __starting_point():\n  main()\n__starting_point()", "R, C, N = list(map(int, input().split()))\nUP, RIGHT, DOWN, LEFT = [], [], [], []\nfor i in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n\n    # 2\u3064\u3068\u3082\u5468\u4e0a\u306b\u306a\u3044\n    if 0 < x1 < R and 0 < y1 < C:\n        continue\n    if 0 < x2 < R and 0 < y2 < C:\n        continue\n\n    # 2\u3064\u3068\u3082\u5468\u56de\u4e0a\u306b\u3042\u308b\n    if x1 == 0: UP.append([i, y1])\n    elif x1 == R: DOWN.append([i, y1])\n    elif y1 == 0: LEFT.append([i, x1])\n    elif y1 == C: RIGHT.append([i, x1])\n\n    if x2 == 0: UP.append([i, y2])\n    elif x2 == R: DOWN.append([i, y2])\n    elif y2 == 0: LEFT.append([i, x2])\n    elif y2 == C: RIGHT.append([i, x2])\n\n\n# \u6642\u8a08\u56de\u308a\u306b\u63a2\u7d22\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b\nUP.sort(key=lambda x: x[1])\nRIGHT.sort(key=lambda x: x[1])\nDOWN.sort(key=lambda x: x[1], reverse=True)\nLEFT.sort(key=lambda x: x[1], reverse=True)\n\n# \u5168\u4f53\u3092\u9023\u7d50\nNumbers = UP + RIGHT + DOWN + LEFT\n\n# \u6642\u8a08\u56de\u308a\u306b\u63a2\u7d22\nstack = []\nfor n, z in Numbers:\n    if stack and stack[-1] == n:\n        stack.pop()\n\n    else:\n        stack.append(n)\nprint((\"NO\" if stack else \"YES\"))\n", "import sys\ninput = sys.stdin.readline\nR, C, N = map(int, input().split())\na = []\n\ndef conv(i, j):\n  res = 0\n  if i == 0:\n    res = j\n  elif j == C:\n    res = C + i\n  elif i == R:\n    res = C + R + (C - j)\n  elif j == 0: res = 2 * C + R + (R - i)\n  else: res = -1\n  return res\n\nfor i in range(N):\n  x, y, u, v = map(int, input().split())\n  d, dd = conv(x, y), conv(u, v)\n  if d >= 0 and (dd >= 0):\n    a.append((d, i))\n    a.append((dd, i))\na.sort()\ns = []\nfor _, i in a:\n  if len(s) and s[-1] == i: s.pop()\n  else: s.append(i)\nif len(s): print(\"NO\")\nelse: print(\"YES\")", "from collections import deque\n\ndef f(x, y):\n    if x == 0:\n        return y\n    if y == 0:\n        return -x\n    if x == r:\n        return -(x + y)\n    if y == c:\n        return x + y\n\nr, c, n = map(int, input().split())\nxy = []\nlxy = 0\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    d = []\n    if min(x1, y1) == 0 or x1 == r or y1 == c:\n        d.append([f(x1, y1), i])\n    if min(x2, y2) == 0 or x2 == r or y2 == c:\n        d.append([f(x2, y2), i])\n    if len(d) == 2:\n        xy.append(d[0])\n        xy.append(d[1])\n        lxy += 2\nxy.sort()\nq = deque()\nlq = -1\nfor i in range(lxy):\n    if not q:\n        q.append(xy[i][1])\n        lq += 1\n    else:\n        if q[lq] == xy[i][1]:\n            q.pop()\n            lq -= 1\n        else:\n            q.append(xy[i][1])\n            lq += 1\nprint(\"YES\" if not q else \"NO\")", "import sys\nfrom collections import defaultdict\n\n# sys.stdin = open('c1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef pos(X, Y):\n    if Y == 0:\n        return X\n    if X == r:\n        return r + Y\n    if Y == c:\n        return r + c + r - X\n    if X == 0:\n        return r + c + r + c - Y\n\n\nr, c, n, = read_int_list()\nx = [0, 0]\ny = [0, 0]\na = []\nfor i in range(n):\n    x[0], y[0], x[1], y[1] = read_int_list()\n    if (x[0] in [0, r] or y[0] in [0, c]) and (x[1] in [0, r] or y[1] in [0, c]):\n        for k in range(2):\n            a.append((pos(x[k], y[k]), i))\nm = len(a) // 2\na.sort()\n\nres = 'YES'\nstarted = set()\ns = []\nfor p, i in a:\n    if i not in started:\n        started.add(i)\n        s.append(i)\n    else:\n        if s[-1] != i:\n            res = 'NO'\n            break\n        s.pop()\n\nprint(res)\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nR, C, N = map(int, input().split())\nX = {0, R}\nY = {0, C}\n\nZ = []\nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    if (x1 == 0 or x1 == R or y1 == 0 or y1 == C) and (x2 == 0 or x2 == R or y2 == 0 or y2 == C):\n        Z.append((x1, y1, x2, y2))\n        X.add(x1)\n        X.add(x2)\n        Y.add(y1)\n        Y.add(y2)\n\nDX = {a: i for i, a in enumerate(sorted(list(X)))}\nDY = {a: i for i, a in enumerate(sorted(list(Y)))}\nR, C = DX[R], DY[C]\n\ndef calc(a, b):\n    if b == 0:\n        return a\n    if a == R:\n        return b + R\n    if b == C:\n        return R + C + (R - a)\n    if a == 0:\n        return R + C + R + (C - b)\n\nA = []\nfor i, (x1, y1, x2, y2) in enumerate(Z):\n    x3, y3, x4, y4 = DX[x1], DY[y1], DX[x2], DY[y2]\n    A.append((calc(x3, y3), i))\n    A.append((calc(x4, y4), i))\n\nA = [l[1] for l in sorted(A, key = lambda x: x[0])]\nB = []\n\nwhile A:\n    while len(B) and A[-1] == B[-1]:\n        A.pop()\n        B.pop()\n    if A:\n        B.append(A.pop())\n\nprint(\"NO\" if len(B) else \"YES\")", "R, C, N = list(map(int, input().split()))\npts = []\nfor i in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    zs = []\n    for x, y in [(x1, y1), (x2, y2)]:\n        if y == 0:\n            zs.append((x, i))\n        elif x == R:\n            zs.append((R+y, i))\n        elif y == C:\n            zs.append((2*R+C-x, i))\n        elif x == 0:\n            zs.append((2*R+2*C-y, i))\n    if len(zs) == 2:\n        pts += zs\n\npts.sort()\n\nstack = []\nfor z, i in pts:\n    if not stack:\n        stack.append(i)\n    else:\n        if stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n\nif not stack:\n    print('YES')\nelse:\n    print('NO')\n", "r,c,n=map(int,input().split())\ndef po(x,y):\n  if y==0:return x\n  if x==r:return r+y\n  if y==c:return r+c+(r-x)\n  if x==0:return r+c+r+(c-y)\nq=[]\nfor i in range(n):\n  x1,y1,x2,y2=map(int,input().split())\n  if (x1 in [0,r] or y1 in [0,c])and(x2 in [0,r] or y2 in [0,c]):\n    q.append((po(x1,y1),i))\n    q.append((po(x2,y2),i))\nif len(q)==0:print(\"YES\");return\nq.sort()\nd=[]\nfor _,i in q:\n  if len(d)==0:d.append(i)\n  elif d[-1]==i:del d[-1]\n  else:d.append(i)\nif len(d)==0:print('YES')\nelse:print('NO')", "r, c, n = list(map(int, input().split()))\nl = []\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if (x1 == 0 or x1 == r or y1 == 0 or y1 == c) and (x2 == 0 or x2 == r or y2 == 0 or y2 == c):\n        if x1 == 0:\n            l.append((y1, i))\n        elif y1 == c:\n            l.append((c + x1, i))\n        elif x1 == r:\n            l.append((c * 2 + r - y1, i))\n        else:\n            l.append((r * 2 + c * 2 - x1, i))\n        if x2 == 0:\n            l.append((y2, i))\n        elif y2 == c:\n            l.append((c + x2, i))\n        elif x2 == r:\n            l.append((c * 2 + r - y2, i))\n        else:\n            l.append((r * 2 + c * 2 - x2, i))\nl.sort()\ns = []\nd = [False] * n\nfor x, i in l:\n    if d[i]:\n        if s[-1] != i:\n            print('NO')\n            return\n        s.pop()\n    else:\n        s.append(i)\n        d[i] = True\nprint('YES')\n", "R,C,N = map(int,input().split())\n\ndef outer_pos(x,y):\n    if (0 < x < R) and (0 < y < C): return -1\n    if y == 0: return x\n    if x == R: return R + y\n    if y == C: return R + C + (R-x)\n    return R + C + R + (C-y)\n\nouter = []\nfor i in range(N):\n    x1,y1,x2,y2 = map(int,input().split())\n    p1 = outer_pos(x1,y1)\n    p2 = outer_pos(x2,y2)\n    if p1 < 0 or p2 < 0: continue\n    outer.append((p1,i))\n    outer.append((p2,i))\nouter.sort()\n\nstack = []\nfor p,i in outer:\n    if len(stack) == 0 or stack[-1] != i:\n        stack.append(i)\n    else:\n        stack.pop()\nprint('NO' if stack else 'YES')", "r, c, n = list(map(int, input().split()))\npoints = []\nxx = [0, r]\nyy = [0, c]\ndef add(x, y):\n    if x == 0:\n        points.append(r*2+c+c-y)\n    elif x == r:\n        points.append(r+y)\n    elif y == 0:\n        points.append(x)\n    else:\n        points.append(r+c+r-x)\nfor i in range(n):\n    x0, y0, x1, y1 = list(map(int, input().split()))\n    if (x0 in xx or y0 in yy) and (x1 in xx or y1 in yy):\n        add(x0, y0)\n        add(x1, y1)\nindex = list(range(len(points)))\nindex.sort(key = lambda a:points[a])\nque = []\nflag = True\nfor i in index:\n    if que and que[-1]//2 == i//2:\n        que.pop()\n    else:\n        que.append(i)\nif que:\n    print('NO')\nelse:\n    print('YES')\n", "def main():\n    from bisect import bisect_left as bl\n\n    class BIT():\n        def __init__(self, member):\n            self.member_list = sorted(member)\n            self.member_dict = {v: i+1 for i, v in enumerate(self.member_list)}\n            self.n = len(member)\n            self.maxmember = self.member_list[-1]\n            self.minmember = self.member_list[0]\n            self.maxbit = 2**(len(bin(self.n))-3)\n            self.bit = [0]*(self.n+1)\n            self.allsum = 0\n\n        # \u8981\u7d20i\u306bv\u3092\u8ffd\u52a0\u3059\u308b\n        def add(self, i, v):\n            x = self.member_dict[i]\n            self.allsum += v\n            while x < self.n + 1:\n                self.bit[x] += v\n                x += x & (-x)\n\n        # \u4f4d\u7f6e0\u304b\u3089i\u307e\u3067\u306e\u548c(sum(bit[:i]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum(self, i):\n            ret = 0\n            x = i\n            while x > 0:\n                ret += self.bit[x]\n                x -= x & (-x)\n            return ret\n\n        # \u4f4d\u7f6ei\u304b\u3089j\u307e\u3067\u306e\u548c(sum(bit[i:j]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum_range(self, i, j):\n            return self.sum(j) - self.sum(i)\n\n        # \u548c\u304cw\u4ee5\u4e0a\u3068\u306a\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6c42\u3081\u308b\n        def lowerbound(self, w):\n            if w <= 0:\n                return 0\n            x, k = 0, self.maxbit\n            while k:\n                if x+k <= self.n and self.bit[x+k] < w:\n                    w -= self.bit[x+k]\n                    x += k\n                k //= 2\n            return x\n\n        # v\u306b\u4e00\u756a\u8fd1\u3044v\u4ee5\u4e0a\u306e\u5024\u3092\u6c42\u3081\u308b\n        def greater(self, v):\n            if v > self.maxmember:\n                return None\n            p = self.sum(bl(self.member_list, v))\n            if p == self.allsum:\n                return None\n            return self.member_list[self.lowerbound(p+1)]\n\n        # v\u306b\u4e00\u756a\u8fd1\u3044v\u4ee5\u4e0b\u306e\u5024\u3092\u6c42\u3081\u308b\n        def smaller(self, v):\n            if v < self.minmember:\n                return None\n            b = bl(self.member_list, v)\n            if b == self.n:\n                b -= 1\n            elif self.member_list[b] != v:\n                b -= 1\n            p = self.sum(b+1)\n            if p == 0:\n                return None\n            return self.member_list[self.lowerbound(p)]\n\n    r, c, n = list(map(int, input().split()))\n    xyzw = [list(map(int, input().split())) for _ in [0]*n]\n    outer = []\n    for x, y, z, w in xyzw:\n        if x in [0, r] or y in [0, c]:\n            if z in [0, r] or w in [0, c]:\n                if y == 0:\n                    p = x\n                elif x == r:\n                    p = r+y\n                elif y == c:\n                    p = 2*r+c-x\n                else:\n                    p = 2*r+2*c-y\n                if w == 0:\n                    q = z\n                elif z == r:\n                    q = r+w\n                elif w == c:\n                    q = 2*r+c-z\n                else:\n                    q = 2*r+2*c-w\n                if p > q:\n                    p, q = q, p\n                outer.append((p, q))\n\n    member = [i for i, j in outer]+[j for i, j in outer]+[-1]+[2*r+2*c+1]\n    bit = BIT(member)\n    bit.add(-1, 1)\n    bit.add(2*r+2*c+1, 1)\n\n    outer.sort(key=lambda x: x[0]-x[1])\n    for a, b in outer:\n        if bit.greater(a) < b:\n            print(\"NO\")\n            return\n        bit.add(a, 1)\n        bit.add(b, 1)\n    print(\"YES\")\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\nimport math\n\n\"\"\"\n\u5185\u90e8\u306e\u70b9\u304c\u7d61\u3080\u3082\u306e\u306f\u3001\u66f2\u7dda\u3067\u7d50\u3093\u3067\u30db\u30e2\u30c8\u30d4\u30fc\u3067\u5909\u5f62\u3059\u308c\u3070\u3001\u7121\u8996\u3067\u304d\u308b\n\u5883\u754c\u306e2\u70b9\u3092\u7d50\u3076\u3082\u306e\u305f\u3061\u3060\u3051\u304c\u554f\u984c\n\"\"\"\n\nR,C,N = map(int,input().split())\npts = [] # \u89d2\u5ea6\u3001\u756a\u53f7\nis_inner = lambda x,y:  0 < x < R and 0 < y < C\nfor i in range(N):\n    x1,y1,x2,y2 = map(int,input().split())\n    if is_inner(x1,y1) or is_inner(x2,y2):\n        continue\n    pts.append((math.atan2(y1 - C/2, x1 - R/2),i))\n    pts.append((math.atan2(y2 - C/2, x2 - R/2),i))\npts.sort()\n\narr = []\nfor _, i in pts:\n    if arr and arr[-1] == i:\n        arr.pop()\n        continue\n    arr.append(i)\n\nanswer = 'NO' if arr else 'YES'\nprint(answer)", "r, c, n = map(int, input().split())\ndots = []\nnum = 0\nfor i in range(n):\n\tx1, y1, x2, y2 = map(int, input().split())\n\tif (0 < x1 < r and 0 < y1 < c) or (0 < x2 < r and 0 < y2 < c):\n\t\tcontinue\n\telse:\n\t\tnum += 1\n\t\td1 = (x1, y1)\n\t\td2 = (x2, y2)\n\t\tif x1 == 0:\n\t\t\tdots.append((y1, i))\n\t\telif y1 == c:\n\t\t\tdots.append((c + x1, i))\n\t\telif x1 == r:\n\t\t\tdots.append((2 * c + r - y1, i))\n\t\telse:\n\t\t\tdots.append((2 * (r + c) - x1, i))\n\n\t\tif x2 == 0:\n\t\t\tdots.append((y2, i))\n\t\telif y2 == c:\n\t\t\tdots.append((c + x2, i))\n\t\telif x2 == r:\n\t\t\tdots.append((2 * c + r - y2, i))\n\t\telse:\n\t\t\tdots.append((2 * (r + c) - x2, i))\n\n#print(dots)\nif num <= 1:\n\tprint(\"YES\")\nelse:\n\tdots.sort(key=lambda x: x[0])\n\tstack = []\n\tfor i in range(num * 2):\n\t\tif stack == []:\n\t\t\tstack.append(dots[i][1])\n\t\telse:\n\t\t\tif stack[-1] == dots[i][1]:\n\t\t\t\tstack.pop()\n\t\t\telse:\n\t\t\t\tstack.append(dots[i][1])\n\tif stack:\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def check(x,y):\n        return (x == 0)|(x == w)|(y == 0)|(y == h)\n\n    w,h,n = LI()\n    px0 = []\n    pxw = []\n    py0 = []\n    pyh = []\n    for i in range(1,n+1):\n        x,y,s,t = LI()\n        if check(x,y)&check(s,t):\n            if x == 0:\n                px0.append((y,i))\n            elif x == w:\n                pxw.append((-y,i))\n            elif y == 0:\n                py0.append((-x,i))\n            else:\n                pyh.append((x,i))\n            if s == 0:\n                px0.append((t,i))\n            elif s == w:\n                pxw.append((-t,i))\n            elif t == 0:\n                py0.append((-s,i))\n            else:\n                pyh.append((s,i))\n    px0.sort()\n    pxw.sort()\n    py0.sort()\n    pyh.sort()\n    p = px0+pyh+pxw+py0\n    q = deque()\n    for x, i in p:\n        if q:\n            qi = q.pop()\n            if qi != i:\n                q.append(qi)\n                q.append(i)\n        else:\n            q.append(i)\n    if q:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\nclass BIT():\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\n    add: \u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\n    get_val: i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\n    i, l, r\u306f0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nr, c, n = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ndef solve(x1, y1):\n    if y1 == 0:\n        return x1\n    if x1 == r:\n        return r + y1\n    if y1 == c:\n        return r + c + (r-x1)\n    if x1 == 0:\n        return r + c + r + (c-y1)\n\nli = []\nfor i in range(n):\n    x1, y1, x2, y2 = info[i]\n    if (x1 % r == 0 or y1 % c == 0) and (x2 % r == 0 or y2 % c == 0):\n        pos1, pos2 = solve(x1, y1), solve(x2, y2)\n        li.append((pos1, i))\n        li.append((pos2, i))\n\nli = sorted(li)\nq = deque([])\nfor i in range(len(li)):\n    _, j = li[i]\n    if q and q[-1] == j:\n        q.pop()\n    else:\n        q.append(j)\nif q:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "#!/usr/bin/env python3\n\n\ndef add(bound, r, c, x, y, i):\n    if x == 0:\n        bound.append((0, y, i))\n    elif y == c:\n        bound.append((1, x, i))\n    elif x == r:\n        bound.append((2, c - y, i))\n    else:\n        bound.append((3, r - x, i))\n\n\ndef solve(bound):\n\n    if not bound:\n        return True\n\n    bound.sort()\n    st = [0] * len(bound)\n    p = -1\n\n    for _, _, i in bound:\n        if 0 <= p and st[p] == i:\n            p -= 1\n        else:\n            p += 1\n            st[p] = i\n\n    return p == -1\n\n\ndef main():\n    r, c, n = input().split()\n    r = int(r)\n    c = int(c)\n    n = int(n)\n    bound = []\n    for i in range(n):\n        x1, y1, x2, y2 = input().split()\n        x1 = int(x1)\n        y1 = int(y1)\n        x2 = int(x2)\n        y2 = int(y2)\n        if (x1 % r == 0 or y1 % c == 0) and (x2 % r == 0 or y2 % c == 0):\n            add(bound, r, c, x1, y1, i)\n            add(bound, r, c, x2, y2, i)\n\n\n    print(('YES' if solve(bound) else 'NO'))\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "import random\nimport sys\ninput = sys.stdin.readline\n\n\nclass BIT():\n    \"\"\"\u533a\u9593\u52a0\u7b97\u3001\u4e00\u70b9\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\n    add: \u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\n    get_val: i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\n    i, l, r\u306f0-indexed\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def get_val(self, i):\n        \"\"\"i\u756a\u76ee\u306e\u5024\u3092\u6c42\u3081\u308b\"\"\"\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def add(self, l, r, val):\n        \"\"\"\u533a\u9593[l, r)\u306bval\u3092\u52a0\u3048\u308b\"\"\"\n        self._add(r, val)\n        self._add(l, -val)\n\n\nr, c, n = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ndef solve(x1, y1):\n    if y1 == 0:\n        return x1\n    if x1 == r:\n        return r + y1\n    if y1 == c:\n        return r + c + (r-x1)\n    if x1 == 0:\n        return r + c + r + (c-y1)\n\ndef compress(array):\n    set_ = set([])\n    for i in range(len(array)):\n        a, b = array[i]\n        set_.add(a)\n        set_.add(b)\n    memo = {value : index for index, value in enumerate(sorted(list(set_)))}\n    max_ = 0\n    for i in range(len(array)):\n        array[i][0] = memo[array[i][0]]\n        array[i][1] = memo[array[i][1]]\n        max_ = max(max_, *array[i])\n    return max_, array\n\nquery = []\nfor i in range(n):\n    x1, y1, x2, y2 = info[i]\n    if (x1 % r == 0 or y1 % c == 0) and (x2 % r == 0 or y2 % c == 0):\n        pos1, pos2 = solve(x1, y1), solve(x2, y2)\n        if pos1 > pos2:\n            pos1, pos2 = pos2, pos1\n        query.append([pos1, pos2 + 1])\n\nm, query = compress(query)\nbit = BIT(m)  \nfor i in range(len(query)):\n    begin, end = query[i]\n    if bit.get_val(begin) != bit.get_val(end - 1):\n        print(\"NO\")\n        return\n    tmp = random.randrange(0, 10**18)\n    bit.add(begin, end, tmp)\nprint(\"YES\")", "def ri(): return int(input())\ndef rli(): return list(map(int, input().split()))\ndef rls(): return list(input())\ndef pli(a): return \"\".join(list(map(str, a)))\n\n\nR, C, N = rli()\nlis = []\nidx = 0\ni = 0\nfor j in range(N):\n    x1, y1, x2, y2 = rli()\n    if((x1 % R == 0 or y1 % C == 0) and (x2 % R == 0 or y2 % C == 0)):\n        i += 1\n        for _ in range(2):\n            if(y1 == 0):\n                lis.append([x1, i])\n            elif(x1 == R):\n                lis.append([R+y1, i])\n            elif(y1 == C):\n                lis.append([2*R+C-x1, i])\n            elif(x1 == 0):\n                lis.append([2*R+2*C-y1, i])\n            x1 = x2\n            y1 = y2\nlis.sort()\nstack = []\nexist = [False for _ in range(2*i)]\nans = True\nfor k in range(2*i):\n    if(exist[lis[k][1]]):\n        if(lis[k][1] != stack.pop()):\n            ans = False\n            break\n        exist[lis[k][1]] = False\n    else:\n        stack.append(lis[k][1])\n        exist[lis[k][1]] = True\nif(ans):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "\ndef hantei(x,y):\n\n    if y == 0:\n        return \"l\"\n    elif x == R:\n        return \"d\"\n    elif y == C:\n        return \"r\"\n    elif x == 0:\n        return \"u\"\n\n    return \"n\"\n\nR,C,N = list(map(int,input().split()))\n\nu = []\nl = []\nd = []\nr = []\n\nfor i in range(N):\n\n    X1,Y1,X2,Y2 = list(map(int,input().split()))\n\n    if hantei(X1,Y1) != \"n\" and hantei(X2,Y2) != \"n\":\n\n\n        if hantei(X1,Y1) == \"l\":\n            l.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"d\":\n            d.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"r\":\n            r.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"u\":\n            u.append([X1,Y1,i])\n\n        X1 = X2\n        Y1 = Y2\n    \n        if hantei(X1,Y1) == \"l\":\n            l.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"d\":\n            d.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"r\":\n            r.append([X1,Y1,i])\n        elif hantei(X1,Y1) == \"u\":\n            u.append([X1,Y1,i])\n\nl.sort()\nd.sort()\nr.sort()\nr.reverse()\nu.sort()\nu.reverse()\n\nps = []\nfor i in l:\n    ps.append(i[2])\nfor i in d:\n    ps.append(i[2])\nfor i in r:\n    ps.append(i[2])\nfor i in u:\n    ps.append(i[2])\n\nq = []\n\nfor i in ps:\n    if len(q) > 0 and q[-1] == i:\n        del q[-1]\n    else:\n        q.append(i)\n\nif len(q) == 0:\n    print (\"YES\")\nelse:\n    print (\"NO\")\n\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    h, w, n = MI()\n    points = []\n    cnt = 0\n    # 2\u70b9\u3068\u3082\u5468\u4e0a\u306b\u3042\u308b\u7d44\u306e\u307f\u6b8b\u3059\n    # \u539f\u70b9\uff08\u5de6\u4e0a\uff09\u304b\u3089\u53cd\u6642\u8a08\u56de\u308a\u306b\u79fb\u52d5\u3057\u305f\u8ddd\u96e2\u3068\u70b9\u306e\u901a\u3057\u756a\u53f7\u3092\u8a18\u9332\n    for _ in range(n):\n        i0, j0, i1, j1 = MI()\n        if (0 < i0 < h and 0 < j0 < w) or (0 < i1 < h and 0 < j1 < w): continue\n        for i, j in [(i0, j0), (i1, j1)]:\n            if j == 0 or i == h:\n                d = i + j\n            else:\n                d = 2 * (h + w) - i - j\n            points.append([d, cnt])\n        cnt += 1\n    points.sort()\n    first = [True] * cnt\n    visited = []\n    # ABAB\u306e\u3088\u3046\u306b\uff12\u3064\u306e\u533a\u9593\u304c\u305a\u308c\u3066\u91cd\u306a\u3063\u3066\u3044\u305f\u3089NO\n    # ABBA\u306e\u3088\u3046\u306b\u5b8c\u5168\u306b\u542b\u307e\u308c\u308b\u306e\u306f\u30bb\u30fc\u30d5\n    for d, pi in points:\n        if first[pi]:\n            visited.append(pi)\n            first[pi] = False\n        else:\n            last_pi = visited.pop()\n            if pi != last_pi:\n                print(\"NO\")\n                return\n    print(\"YES\")\n\nmain()\n", "r,c,n = map(int,input().split())\na = [list(map(int, input().split())) for _ in range(n)]\niru = []\nfor i in range(n):\n  if ((a[i][0] == 0 or a[i][0] == r or a[i][1] == 0 or a[i][1] == c) and (a[i][2] == 0 or a[i][2] == r or a[i][3] == 0 or a[i][3] == c)):\n    b = a[i]\n    b1 = [b[0],b[1]]\n    b2 = [b[2],b[3]]\n    if b1[0] == 0:\n      b1 = b1[1]\n    elif b1[1] == c:\n      b1 = b1[0] + b1[1]\n    elif b1[0] == r:\n      b1 = c +r+c -b1[1]\n    else:\n      b1 = c*2 + r*2 - b1[0]\n      \n    if b2[0] == 0:\n      b2 = b2[1]\n    elif b2[1] == c:\n      b2 = b2[0] + b2[1]\n    elif b2[0] == r:\n      b2 = c*2 +r -b2[1]\n    else:\n      b2 = c*2 + r*2 - b2[0]\n    if b1 > b2:\n      tmp = b1 +0\n      b1 = b2 +0\n      b2 = tmp + 0\n    iru.append([b1,b2])\niru = sorted(iru)\nato = 0\nstack = [r+r+c+c]\nflag = 'YES'\nfor a,b in iru:\n  while a >= stack[-1]:\n    stack.pop()\n \n  if b > stack[-1]:\n    flag = 'NO'\n    break\n  else:\n    stack.append(b)\n \nprint(flag)", "import cmath\n\n\nr, c, n = map(int, input().split())\nlis = []\n\n\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if (0 < x1 < r and 0 < y1 < c) or (0 < x2 < r and 0 < y2 < c):\n        continue\n    else:\n        lis.append((i, x1 - r / 2 + (y1 - c / 2) * 1j))\n        lis.append((i, x2 - r / 2 + (y2 - c / 2) * 1j))\n\n\nlis.sort(key=lambda x: cmath.phase(x[1]))\nstack = []\n\n\nfor i in lis:\n    if stack == [] or stack[-1] != i[0]:\n        stack.append(i[0])\n    else:\n        stack.pop()\n\n        \nif stack == []:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "r, c, n = list(map(int, input().split()))\n\np = []\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if x1 == 0 or x1 == r or y1 == 0 or y1 == c:\n        if x2 == 0 or x2 == r or y2 == 0 or y2 == c:\n            if y1 == 0:\n                p.append([x1, i])\n            elif x1 == r:\n                p.append([r + y1, i])\n            elif y1 == c:\n                p.append([2 * r + c - x1, i])\n            else:\n                p.append([2 * r + 2 * c - y1, i])\n\n            if y2 == 0:\n                p.append([x2, i])\n            elif x2 == r:\n                p.append([r + y2, i])\n            elif y2 == c:\n                p.append([2 * r + c - x2, i])\n            else:\n                p.append([2 * r + 2 * c - y2, i])\n\np.sort()\n\nt = []\n\nold = -1\nfor i in range(0, len(p)):\n    temp = p[i][1]\n\n    if temp == old:\n        t.pop()\n        if len(t) == 0:\n            old = -1\n        else:\n            old = t[-1]\n    else:\n        t.append(temp)\n        old = temp\nif len(t) > 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n", "R, C, N = map(int, input().split())\n\npts = [tuple(map(int, input().split())) for _ in range(N)]\n\ndef on_boundary(x1, y1):\n  return (x1 == 0 or x1 == R or y1 == 0 or y1 == C)\n\ndef perim_until(x, y):\n  if x == 0:\n    return y\n  if y == C:\n    return C + x\n  if x == R:\n    return R + C + (C - y)\n  if y == 0:\n    return R + C + C + (R - x)\n  return -1\n\nperimpts = []\nfor i, pt in enumerate(pts):\n  x1, y1, x2, y2 = pt\n  if on_boundary(x1, y1) and on_boundary(x2, y2):\n    per1, per2 = perim_until(x1, y1), perim_until(x2, y2)\n    perimpts.append((per1, i))\n    perimpts.append((per2, i))\n\nperimpts.sort()\ndef solve():\n  stack = []\n  seen = [False for _ in range(N)]\n  for ppt in perimpts:\n    _, ind = ppt\n    if seen[ind]:\n      if stack[-1] != ind:\n        print(\"NO\")\n        return\n      stack.pop()\n    else:\n      seen[ind] = True\n      stack.append(ind)\n  print(\"YES\")\n  \nsolve()", "def f(r,c):\n    if c==0: return r\n    elif c==C: return R+C+(R-r)\n    elif r==0: return R*2+C+(C-c)\n    elif r==R: return R+c\n    else: return -1\n\nimport sys\ninput = sys.stdin.readline\nR,C,N=map(int, input().split())\nQ=[]\nl=1\nfor i in range(N):\n    r0,c0,r1,c1=map(int, input().split())\n    if f(r0,c0) != -1 and f(r1,c1) != -1:\n        s,t=f(r0,c0),f(r1,c1)\n        if s>t: s,t=t,s\n        Q.append((s,l))\n        Q.append((t,-l))\n        l+=1\nQ.sort(key=lambda x:x[0])\nflg=True\nR=[]\nfor _, q in Q:\n    if q>0:\n        R.append(q)\n    elif q<0:\n        if not R: flg=False; break\n        p=R.pop()\n        if -p!=q: flg=False; break\nprint(\"YES\" if flg else \"NO\")", "R,C,N=list(map(int,input().split()))\npoints=[list(map(int,input().split())) for i in range(N)]\ndef circ(x,y):\n    if y==0:\n        return x\n    elif x==R:\n        return y+R\n    elif y==C:\n        return R+C+R-x\n    elif x==0:\n        return R+C+R+C-y\n    else:\n        return -1\n\nL=[]\nfor i in range(N):\n    x1,y1,x2,y2=points[i]\n    if circ(x1,y1)==-1 or circ(x2,y2)==-1:\n        continue\n    L.append((circ(x1,y1),i))\n    L.append((circ(x2,y2),i))\n#board=[[circ(x,y) for y in range(C+1)] for x in range(R+1)]\nR=[s[1] for s in sorted(L)]\nX=[]\nfor i in R:\n    if len(X)==0:\n        X.append(i)\n    else:\n        if X[-1]==i:\n            X.pop()\n        else:\n            X.append(i)\nif len(X)==0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "R, C, N = list(map(int, input().split()))\n\npoints = []\n\ndef dist(x, y):\n    if x == 0:\n        return R * 2 + C + (C - y)\n    if x == R:\n        return R + y\n    if y == 0:\n        return x\n    if y == C:\n        return R + C + (R - x)\n\nfor i in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if ((x1 == 0 or x1 == R) or (y1 == 0 or y1 == C)) and ((x2 == 0 or x2 == R) or (y2 == 0 or y2 == C)):\n        points.append((i + 1, dist(x1, y1)))\n        points.append((i + 1, dist(x2, y2)))\npoints.sort(key=lambda p: p[1])\nl = []\nfor point in points:\n    if len(l) == 0:\n        l.append(point[0])\n        continue\n    if point[0] == l[-1]:\n        l.pop()\n    else:\n        l.append(point[0])\nif len(l) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "w, h, n = list(map(int, input().split()))\n\npos = []\nfor i in range(n):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if (x1 in [0, w] or y1 in [0, h]) and (x2 in [0, w] or y2 in [0, h]):\n        pos.append((x1, y1, i))\n        pos.append((x2, y2, i))\n\npos.sort(key=lambda v: v[0]) # top \u2192\nedge = [v[-1] for v in pos if v[1] == 0 and v[0] != 0]\n\npos.sort(key=lambda v: v[1]) # left \u2193\nedge += [v[-1] for v in pos if v[0] == w and v[1] != 0]\n\npos.sort(key=lambda v: v[0], reverse=True) # bottom \u2190\nedge += [v[-1] for v in pos if v[1] == h and v[0] != w]\n\npos.sort(key=lambda v: v[1], reverse=True) # right \u2191\nedge += [v[-1] for v in pos if v[0] == 0 and v[1] != h]\n\n# for i in range(len(edge) - 1):\n#     if edge[i] == edge[i + 1]:\n#         break\n# for j in range(len(edge) // 2):\n#     if edge[(i + j + 1) % n] != edge[(i - j + n) % n]:\n#         print(\"NO\")\n#         break\n# else:\n#     print(\"YES\")\n\n# print(edge)\nhist = [None] * n\nstep = 0\nfor v in edge:\n    if hist[v] is None:\n        hist[v] = step + 1\n        step += 1\n    else:\n        if hist[v] != step:\n            print(\"NO\")\n            break\n        step -= 1\nelse:\n    print(\"YES\")\n\n", "def inpl(): return [int(i) for i in input().split()]\n\nR, C, N = inpl()\nloopx = {0: [], R: []}\nloopy = {0: [], C: []}\nfor i in range(N):\n    x1, y1, x2, y2 = inpl() \n    if (x1 in (0,R) or y1 in (0,C))\\\n    and (x2 in (0,R) or y2 in (0,C)):\n        if x1 in (0,R):\n            loopx[x1].append((y1,i))\n        elif y1 in (0,C):\n            loopy[y1].append((x1,i))\n        if x2 in (0,R):\n            loopx[x2].append((y2,i))\n        elif y2 in (0,C):\n            loopy[y2].append((x2,i))\nloop = [j for i, j in sorted(loopy[0])] +\\\n[j for i, j in sorted(loopx[R])] +\\\n[j for i, j in sorted(loopy[C])][::-1] +\\\n[j for i, j in sorted(loopx[0])][::-1]\nstack = []\nfor i in loop:\n    if not stack:\n        stack.append(i)\n        continue\n    if stack[-1] == i:\n        stack.pop()\n    else:\n        stack.append(i)\nif not stack:\n    print('YES')\nelse:\n    print('NO')", "R, C, n = list(map(int, input().split()))\nx1 = []\ny1 = []\nx2 = []\ny2 = []\nfor i in range(n): \n  xx1, yy1, xx2, yy2 = list(map(int, input().split()))\n  x1.append(xx1)\n  y1.append(yy1)\n  x2.append(xx2)\n  y2.append(yy2)\n\nt = []\nb = []\nl = []\nr = []\n\ndef add(x, y, i):\n  if x == 0:\n    t.append((i, y))\n  elif x == R:\n    b.append((i, y))\n  elif y == 0:\n    l.append((i, x))\n  elif y == C:\n    r.append((i, x))\n\n\nfor i in range(n):\n  add(x1[i], y1[i], i)\n  add(x2[i], y2[i], i)\n\nt = sorted(t, key=lambda x : x[1])    \nr = sorted(r, key=lambda x : x[1])\nb = sorted(b, key=lambda x : x[1], reverse=True)\nl = sorted(l, key=lambda x : x[1], reverse=True)\n\nlis = []\nlis.extend(t)\nlis.extend(r)\nlis.extend(b)\nlis.extend(l)\n\nlis = [x[0] for x in lis]\n\ncnt = {}\nfor i in lis:\n  if not i in cnt:\n    cnt[i] = 0\n  cnt[i] += 1\n\nlis = [x for x in lis if cnt[x] == 2]\n\nstk = []\nfor i in lis:\n  if len(stk) == 0 or stk[-1] != i:\n    stk.append(i)\n  else:\n    stk.pop()\n\nif len(stk) == 0:\n  print(\"YES\")\nelse:\n  print(\"NO\")\n", "import sys\ninput = sys.stdin.readline\n\nR, C, N = map(int, input().split())\nright = []\ntop = []\nleft = []\nbottom = []\nfor i in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    # if both points are on the edge\n    if (x1 in (0, R) or y1 in (0, C)) and (x2 in (0, R) or y2 in (0, C)):\n        if x1 == 0:\n            top.append((y1, i))\n        elif x1 == R:\n            bottom.append((y1, i))\n        elif y1 == 0:\n            left.append((x1, i))\n        elif y1 == C:\n            right.append((x1, i))\n\n        if x2 == 0:\n            top.append((y2, i))\n        elif x2 == R:\n            bottom.append((y2, i))\n        elif y2 == 0:\n            left.append((x2, i))\n        elif y2 == C:\n            right.append((x2, i))\nleft.sort(key=lambda p: p[0])\nbottom.sort(key=lambda p: p[0])\nright.sort(key=lambda p: -p[0])\ntop.sort(key=lambda p: -p[0])\npoints = left + bottom + right + top\nstack = []\nfor x, i in points:\n    if not stack or stack[-1] != i:\n        stack.append(i)\n    else:\n        stack.pop()\nprint('NO' if stack else 'YES')", "def main():\n    from bisect import bisect_left as bl\n\n    class BIT():\n        def __init__(self, member):\n            self.member_list = sorted(member)\n            self.member_dict = {v: i+1 for i, v in enumerate(self.member_list)}\n            self.n = len(member)\n            self.maxmember = self.member_list[-1]\n            self.minmember = self.member_list[0]\n            self.maxbit = 2**(len(bin(self.n))-3)\n            self.bit = [0]*(self.n+1)\n            self.allsum = 0\n\n        # \u8981\u7d20i\u306bv\u3092\u8ffd\u52a0\u3059\u308b\n        def add(self, i, v):\n            x = self.member_dict[i]\n            self.allsum += v\n            while x < self.n + 1:\n                self.bit[x] += v\n                x += x & (-x)\n\n        # \u4f4d\u7f6e0\u304b\u3089i\u307e\u3067\u306e\u548c(sum(bit[:i]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum(self, i):\n            ret = 0\n            x = i\n            while x > 0:\n                ret += self.bit[x]\n                x -= x & (-x)\n            return ret\n\n        # \u4f4d\u7f6ei\u304b\u3089j\u307e\u3067\u306e\u548c(sum(bit[i:j]))\u3092\u8a08\u7b97\u3059\u308b\n        def sum_range(self, i, j):\n            return self.sum(j) - self.sum(i)\n\n        # \u548c\u304cw\u4ee5\u4e0a\u3068\u306a\u308b\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u3092\u6c42\u3081\u308b\n        def lowerbound(self, w):\n            if w <= 0:\n                return 0\n            x, k = 0, self.maxbit\n            while k:\n                if x+k <= self.n and self.bit[x+k] < w:\n                    w -= self.bit[x+k]\n                    x += k\n                k //= 2\n            return x\n\n        # v\u306b\u4e00\u756a\u8fd1\u3044v\u4ee5\u4e0a\u306e\u5024\u3092\u6c42\u3081\u308b\n        def greater(self, v):\n            if v > self.maxmember:\n                return None\n            p = self.sum(bl(self.member_list, v))\n            if p == self.allsum:\n                return None\n            return self.member_list[self.lowerbound(p+1)]\n\n        # v\u306b\u4e00\u756a\u8fd1\u3044v\u4ee5\u4e0b\u306e\u5024\u3092\u6c42\u3081\u308b\n        def smaller(self, v):\n            if v < self.minmember:\n                return None\n            b = bl(self.member_list, v)\n            if b == self.n:\n                b -= 1\n            elif self.member_list[b] != v:\n                b -= 1\n            p = self.sum(b+1)\n            if p == 0:\n                return None\n            return self.member_list[self.lowerbound(p)]\n\n    r, c, n = list(map(int, input().split()))\n    xyzw = [list(map(int, input().split())) for _ in [0]*n]\n    outer = []\n    for x, y, z, w in xyzw:\n        if x in [0, r] or y in [0, c]:\n            if z in [0, r] or w in [0, c]:\n                if y == 0:\n                    p = x\n                elif x == r:\n                    p = r+y\n                elif y == c:\n                    p = 2*r+c-x\n                else:\n                    p = 2*r+2*c-y\n                if w == 0:\n                    q = z\n                elif z == r:\n                    q = r+w\n                elif w == c:\n                    q = 2*r+c-z\n                else:\n                    q = 2*r+2*c-w\n                if p > q:\n                    p, q = q, p\n                outer.append((p, q))\n\n    member = [i for i, j in outer]+[j for i, j in outer]+[-1]+[2*r+2*c+1]\n    bit = BIT(member)\n    bit.add(-1, 1)\n    bit.add(2*r+2*c+1, 1)\n\n    outer.sort(key=lambda x: x[0]-x[1])\n    for a, b in outer:\n        if bit.greater(a) < b:\n            print(\"NO\")\n            return\n        bit.add(a, 1)\n        bit.add(b, 1)\n    print(\"YES\")\n\n\nmain()\n", "R, C, N = map(int, input().split())\nedge = []\n\n\ndef F(x, y):\n    if x == 0:\n        return y\n    if y == C:\n        return C + x\n    if x == R:\n        return R + C * 2 - y\n    if y == 0:\n        return 2 * R + 2 * C - x\n    return -1\n\n\nfor i in range(1, N + 1):\n    x1, y1, x2, y2 = map(int, input().split())\n    d1 = F(x1, y1)\n    d2 = F(x2, y2)\n    if d1 < 0:\n        continue\n    if d2 < 0:\n        continue\n    edge.append((d1, i))\n    edge.append((d2, i))\n\nedge.sort()\nstack = []\nused = [False] * (N + 1)\n\nans = \"YES\"\nfor _, x in edge:\n    if not used[x]:\n        used[x] = True\n        stack.append(x)\n    else:\n        y = stack.pop()\n        if x != y:\n            ans = \"NO\"\n            break\n\nprint(ans)", "R, C, N = list(map(int, input().split()))\ndef calc(x, y):\n    if x == 0 or y == C:\n        return x + y\n    return 2*R + 2*C - x - y\nA = {}\nfor i in range(N):\n    x1, y1, x2, y2 = list(map(int, input().split()))\n    if not ((x1 in [0, R] or y1 in [0, C]) and (x2 in [0, R] or y2 in [0, C])):\n        continue\n    A[calc(x1, y1)] = i\n    A[calc(x2, y2)] = i\n\nst = []\nfor i, a in sorted(A.items()):\n    if st and st[-1] == a:\n        st.pop()\n    elif a is not None:\n        st.append(a)\nprint(('YES' if not st else 'NO'))\n"]
["from fractions import gcd\n\ndef min_price(nums):\n    nums.sort()\n    ns = [0] + [float('inf')] * (nums[0] - 1)\n    for c in nums[1:]:\n        d = gcd(nums[0], c)\n        for r in range(d):\n            n = min(ns[r::d], default=float('inf'))\n            if n < float('inf'):\n                for j in range(nums[0] // d):\n                    n += c\n                    p = n % nums[0]\n                    ns[p] = n = min(n, ns[p])\n    max_ = max(ns) or 1\n    return max_ - nums[0] + 1 if max_ < float('inf') else -1", "from math import gcd as builtin_gcd\n \n\"\"\"\nThis problem could be seen as finding the Frobenius number\nAlgorithm used\nhttps://brg.a2hosted.com/?page_id=563\nbased on\nThe Money Changing Problem Revisited: Computing the Frobenius Number in Time O(ka1), by Sebastian Bocker and Zsuzsanna Liptak, June 2004, Technical Report number 2004-2, University of Bielefeld, Technical Faculty.\n\n\"\"\"    \n    \ndef gcd(a, *r):\n  for b in r:\n    a = builtin_gcd(a, b)\n  return a\n \ndef lcm(a, *r):\n  for b in r:\n    a *= b // builtin_gcd(a, b)\n  return abs(a)\n \ndef frobenius_number(a):\n  def __residue_table(a):\n    n = [0] + [None] * (a[0] - 1)\n    for i in range(1, len(a)):\n      d = gcd(a[0], a[i])\n      for r in range(d):\n        try:\n          nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n        except ValueError:\n          continue\n        if nn is not None:\n          for c in range(a[0] // d):\n            nn += a[i]\n            p = nn % a[0]\n            nn = min(nn, n[p]) if n[p] is not None else nn\n            n[p] = nn\n    return n\n \n  \n  if len(a) < 2 or gcd(*a) > 1:\n    return -1\n  return max(__residue_table(sorted(a))) - min(a)\n\ndef min_price(a):\n    if 1 in a:\n        return 1\n    else :\n        fn = frobenius_number(a) \n        return fn + 1 if not fn == -1 else fn", "import math\ndef min_price(coins):\n    if coins == []:\n        return -1\n    if do_gcd(coins) !=1:\n        return -1\n    if min(coins) == 1:\n        return 1\n    if len(coins) == 2:\n        return do_lcm(coins) - sum(coins) + 1\n    a = sorted(coins)\n    a1 = a[0]\n    k = len(a)\n    inf = math.inf\n    n = [0]\n    for i in range(1, a1):\n        n.append(inf)\n    for i in range(1, k):\n        d = math.gcd(a1, a[i])\n        for r in range(d):\n            nn = inf\n            for q in range(r, a1, d):\n                if (q % d) == r:\n                    nn = min(nn, n[q])\n            if nn < inf:\n                for j in range(int(a1/d) - 1):\n                    nn = nn + a[i]\n                    p = nn % a1\n                    nn = min(nn, n[p])\n                    n[p] = nn\n    return max(n) - a1 + 1\n\ndef do_gcd(array):\n    if len(array) == 1:\n        return array[0]\n    if len(array) == 2:\n        return math.gcd(array[0], array[1])\n    return math.gcd(array[0], do_gcd(array[1:]))\n\ndef do_lcm(array):\n    return int(array[0]*array[1]/math.gcd(array[0], array[1]))", "def gcd(a, b):\n    while a:\n        b, a = a, b % a\n    return b\n\ndef min_price(coins):\n    if(1 in coins): return 1\n    coins.sort()\n    print(coins)\n    n = [0] + [-1] * (coins[0] - 1)\n    for i in range(1, len(coins)):\n        d = gcd(coins[0], coins[i])\n        for r in range(d):\n            try:\n                nn = min(n[q] for q in range(r, coins[0], d) if n[q] != -1)\n            except:\n                continue\n            if nn != -1:\n                for c in range(coins[0] // d):\n                    nn += coins[i]\n                    p = nn % coins[0]\n                    nn = min(nn, n[p]) if n[p] != -1 else nn\n                    n[p] = nn\n    \n    if(len(coins) < 2 or -1 in n): return -1\n    return max(n) - coins[0] + 1", "from math import gcd as builtin_gcd\n \ndef gcd(a, *r):\n  for b in r:\n    a = builtin_gcd(a, b)\n  return a\n \ndef lcm(a, *r):\n  for b in r:\n    a *= b // builtin_gcd(a, b)\n  return abs(a)\n \ndef frobenius_number(a):\n  def __residue_table(a):\n    n = [0] + [None] * (a[0] - 1)\n    for i in range(1, len(a)):\n      d = gcd(a[0], a[i])\n      for r in range(d):\n        try:\n          nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n        except ValueError:\n          continue\n        if nn is not None:\n          for c in range(a[0] // d):\n            nn += a[i]\n            p = nn % a[0]\n            nn = min(nn, n[p]) if n[p] is not None else nn\n            n[p] = nn\n    return n\n \n  if len(a) < 2 or gcd(*a) > 1:\n    return -1\n  return max(max(__residue_table(sorted(a))) - min(a) +1,1)\n\ndef min_price(coins):\n    return frobenius_number(coins)", "# Breadth first decreasing (BFD) algorithm for the Frobenius\n# number following Beihoffer, Hendry, Nijenhuis, and Wagon\n# (\"Faster Algorithms For Frobenius Numbers\", The Electronic\n# Journal of Combinatorics, 2005).\n\nfrom functools import reduce\nfrom collections import deque\n\ndef gcd(a,b):\n    while b != 0: a, b = b, a % b\n    return a\n\ndef min_price(a):\n    if 1 in a: return 1\n    elif reduce(gcd, a) != 1: return -1\n\n    n = len(a)\n    a.sort()\n    a1 = a[0]\n\n    q = deque([0])\n    h = set([0])\n    \n    p = [n] + [0] * a1\n    s = [0] + [a1 * a[-1]] * (a1 - 1)\n    amod = [x % a1 for x in a]\n\n    while q:\n        v = q.popleft()\n        h.remove(v)\n        \n        for j in range(1, p[v]):\n            u = v + amod[j]\n            if u >= a1: u -= a1\n\n            w = s[v] + a[j]\n            \n            # This performance-enhancing\n            # condition is given on p. 10.\n            if w == s[u] and j < p[u] - 1:\n                p[u] = j + 1\n            \n            if w < s[u]:\n                s[u] = w\n                p[u] = j + 1\n                if u not in h:\n                    q.append(u)\n                    h.add(u)\n\n    return max(s) - a1 + 1", "# All credit to PuzzlingInPython's blog post on the Bocker Liptak algorithm for calculating the Frobenius number.\n\nfrom math import gcd as builtin_gcd\n \ndef gcd(a, *r):\n  for b in r:\n    a = builtin_gcd(a, b)\n  return a\n \ndef lcm(a, *r):\n  for b in r:\n    a *= b // builtin_gcd(a, b)\n  return abs(a)\n \ndef frobenius_number(a):\n  def __residue_table(a):\n    n = [0] + [None] * (a[0] - 1)\n    for i in range(1, len(a)):\n      d = gcd(a[0], a[i])\n      for r in range(d):\n        try:\n          nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n        except ValueError:\n          continue\n        if nn is not None:\n          for c in range(a[0] // d):\n            nn += a[i]\n            p = nn % a[0]\n            nn = min(nn, n[p]) if n[p] is not None else nn\n            n[p] = nn\n    return n\n \n  if len(a) < 2 or gcd(*a) > 1:\n    return -1\n  return max(max(__residue_table(sorted(a))) - min(a) +1,1)\n\ndef min_price(coins):\n    return frobenius_number(coins)", "#BFDU algorithm from:\n#Faster Algorithms for Frobenius Numbers\n#the electronic journal of combinatorics 12(2005), #R27\n\n#TODO: Implement DQQD(U) from the same paper\n\nimport heapq\nimport collections\nfrom math import gcd\n\ndef frobenius(a):\n    \n    n = len(a)\n    if n == 2:\n        return a[0]*a[1]-a[0]-a[1]\n    \n    a.sort()\n    a1, an = a[0], a[-1]\n    s = [an] * a1; s[0]=0\n    p = [0]*a1; p[0]=n-1\n    q = [[] for _ in range(a1)]; q[0].append(0)\n    z = [0]\n    amod = [-99] + [x % a1 for x in a]\n    aquot = [-99] + [x // a1 for x in a]\n    a = [-99] + a\n    \n    q = collections.deque([0])\n    qs = {0}\n    p=[0]*a1; p[0]=n\n    s= [a1*an]*a1; s[0]=0\n     \n    while q:\n        v = q.popleft()\n        qs.remove(v)\n        for j in range(2, p[v]+1):\n            u = v + amod[j]\n            if u >= a1: u = u - a1\n            w = s[v]+a[j]\n            if w < s[u]:\n                s[u] = w\n                p[u]=j\n                if u not in qs:\n                    q.append(u)\n                    qs.add(u)\n            elif w == s[u] and j < p[u]:\n                p[u] = j\n    return max(s) - a1\n\n    \ndef min_price(a):\n    \n    if 1 in a: return 1\n    if not a: return -1\n    \n    cd = a[0]\n    for z in a:\n        cd = gcd(cd, z)\n    if cd != 1:\n        return -1    \n        \n    return frobenius(a) + 1", "from math import gcd\nfrom functools import reduce\n\n# https://brg.a2hosted.com/?page_id=563\n# The Money Changing Problem Revisited: \n# Computing the Frobenius Numberin Time O(ka1) by Bocker and Liptak\n# http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.389.4933&rep=rep1&type=pdf\ndef frobenius_number(a):\n  def __residue_table(a):\n    n = [0] + [None] * (a[0] - 1)\n    for i in range(1, len(a)):\n      d = gcd(a[0], a[i])\n      for r in range(d):\n        try:\n          nn = min(n[q] for q in range(r, a[0], d) if n[q] is not None)\n        except ValueError:\n          continue\n        if nn is not None:\n          for c in range(a[0] // d):\n            nn += a[i]\n            p = nn % a[0]\n            nn = min(nn, n[p]) if n[p] is not None else nn\n            n[p] = nn\n    return n\n  if len(a) < 2 or reduce(gcd, a) > 1:\n    return -1\n  return max(__residue_table(sorted(a))) - min(a)\n\ndef min_price(coins):\n  if min(coins) == 1:\n      return 1\n  f = frobenius_number(coins)\n  return f + 1 if f >= 0 else -1", "from math import gcd\ndef min_price(coins):\n    if 1 in coins:\n        return 1\n\n# Round Robin Algorithm [from https://pdfs.semanticscholar.org/14ac/14a15ebc31b58a4ac04328f9824f743a1e4e.pdf]\n    coins = sorted(coins)\n    myinf = 4000000000\n    n = [0] + [myinf] * (coins[0] - 1)\n    for i in range(1, len(coins)):\n        d = gcd(coins[0], coins[i])\n        for r in range(0, d):\n            nn = min([n[q] for q in range(r, r + coins[0] - d + 1, d)])\n            if nn != myinf:\n                for j in range(0, coins[0] // d):\n                    nn = nn + coins[i]\n                    p = nn % coins[0]\n                    nn = min(nn, n[p])\n                    n[p] = nn\n\n    maxn = max(n)\n    if maxn == myinf:\n        return -1\n\n    return max(n) - coins[0] + 1\n"]
["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        s=set(G)\n        prev_in=False\n        c=0\n        while head:\n            if head.val in s:\n                if not prev_in:\n                    c+=1 \n                prev_in=True\n            else:           \n                prev_in=False\n            head=head.__next__\n        return c\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        graph = set(G)\n        result = 0\n        while head:\n            if head.val in graph and (head.__next__ == None or head.next.val not in graph):\n                result += 1\n            \n            head = head.__next__\n        return result\n        \n    def numComponents_standard(self, head: ListNode, G: List[int]) -> int:\n        \n        # construct the graph\n        graph = collections.defaultdict(dict)\n        \n        for node in G:\n            graph[node][node] = True\n        \n        while head:\n            # have a edge\n            if head.__next__ and head.val in graph and head.next.val in graph:\n                graph[head.val][head.next.val] = True\n                graph[head.next.val][head.val] = True\n            head = head.__next__\n            \n        # Find connected components, by BFS\n        result, queue, visited = 0, collections.deque(), set()\n        \n        for g in graph:\n            if g not in visited:\n                queue.append(g)\n                result += 1\n                while queue:\n                    node = queue.pop()\n                    visited.add(node)\n                    neighbors = graph[node]\n                    for nei in neighbors:\n                        if nei not in visited:\n                            queue.append(nei)\n        return result\n    \n    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        d={}\n        n=len(G)\n        for i in range(0,n):\n            d[G[i]]=i\n        fa=[i for i in range(0,n)]\n        rank=[1]*n\n        def find(x):\n            if fa[x]!=x:\n                fa[x]=find(fa[x])\n            return fa[x]\n        def union(x,y):\n            \n            if x==y:\n                return \n            else:\n                i=fa[x]\n                j=fa[y]\n                if rank[i]<=rank[j]:\n                    fa[i]=j\n                else:\n                    fa[j]=i\n                if rank[i]==rank[j]:\n                    rank[j]+=1\n        p=head\n        while(p and p.__next__):\n            if p.val in d and p.next.val in d:\n                \n                union(d[p.val],d[p.next.val])\n            p=p.__next__\n        \n        # merge res\n        r=0\n        rset=set()\n\n        for i in range(0,n):\n            tmp=find(i)\n            if tmp not in rset:\n                rset.add(tmp)\n                r+=1\n        return r\n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        res = 0\n        while head:\n            if head.val in G:\n                if not head.next:\n                    res += 1\n                elif head.next.val not in G:\n                    res+=1\n            head = head.next\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        count = 0\n        while head:\n            \n            if head.val in G and (head.__next__ == None or head.next.val not in G):\n                count += 1            \n            head = head.__next__\n        \n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        x = []\n        count=0\n        while head:\n            if head.val in G and (head.__next__ is None or head.next.val not in G):\n                count+=1\n            head =head.__next__\n        return count\n        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        \n        flag=0\n        count=0\n        temp=head\n        while temp:\n            if temp.val in G:\n                flag=1\n            else:\n                if flag == 1:\n                    count+=1\n                    \n                flag=0\n                \n            temp=temp.next\n            \n        if flag==1:\n            count+=1\n            \n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while head:\n            if head.val in G:\n                if not (head.next and head.next.val in G):\n                    count += 1\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while(head):\n            if(head.val in G and (not head.next or head.next.val not in G)):\n                count += 1\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.r = [0] * n\n        \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.r[x] < self.r[y]:\n            self.p[x] = y\n            self.r[y] += self.r[x]            \n        else:\n            self.p[y] = x\n            self.r[x] += self.r[y]\n\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        dsu = DSU(max(G)+1)\n        \n        slow, fast = head, head.next\n        while slow and fast:\n            if slow.val in G and fast.val in G:\n                dsu.union(slow.val, fast.val)\n            slow, fast = slow.next, fast.next\n        \n        return len({dsu.find(x) for x in G})", "class Solution:\n    def numComponents(self, head: ListNode, g: List[int]) -> int:\n        count = 0\n\n        while head:\n            if head.val in g and (head.next is None or head.next.val not in g):\n                count += 1\n            head = head.next\n        return count", "class Solution:\n    def numComponents(self, head: ListNode, g: List[int]) -> int:\n        count = 0\n\n        while head:\n            if head.val in g:\n                if head.next and head.next.val in g:\n                    head = head.next\n                    continue\n                count += 1\n            head = head.next\n\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        count = len(G)\n        temp = head\n        while(temp.next != None):\n            \n            if temp.val in G and temp.next.val in G:\n                \n                count -= 1\n            \n            temp = temp.next\n        \n        return count", "from collections import defaultdict\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass UF:\n    def __init__(self):\n        self.p = {}\n        self.r = defaultdict(lambda: 1)\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.r[x] > self.r[y]:\n            self.p[y] = x\n        elif self.r[x] < self.r[y]:\n            self.p[x] = y\n        else:\n            self.p[x] = y\n            self.r[y] += 1\n    \n    def find(self, x):\n        if self.p.get(x, x) != x:\n            self.p[x] = self.find(self.p.get(x,x))\n        return self.p.get(x, x)\n\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        uf = UF()\n        # uf.union(head.val, head.next.val)\n        # return 0 \n        gSet = set(G)\n        prev = head.val\n        head = head.next\n        # print(\\\"AB\\\")\n        while head != None:\n        # for i in range(1):\n            # print\n            curr = head.val\n            if curr in gSet and prev in gSet:\n                uf.union(curr, prev)\n                # return 1\n            head = head.next\n            prev = curr\n        # return 0  \n        resSet = set()\n        # print(G[1])\n        # print(uf.p)\n        # resSet.add(uf.find(i))\n        # resSet.add(uf.find(G[1]))\n        # return 10\n        for i in G:\n            # print(i)\n            resSet.add(uf.find(i))\n        # print(resSet, uf.p)\n        return len(resSet)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        prev = None\n        while head:\n            if head.val in G and not prev in G:\n                count += 1\n            prev = head.val\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        temp = head\n        while temp:\n            if temp.val in G and (temp.__next__ == None or temp.next.val not in G):\n                    count += 1\n            temp = temp.__next__\n        return count\n                    \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        node=head\n        while(node):\n            temp=node\n            if node.val in G and getattr(node.next,'val',None) not in G:\n                count+=1\n            node=node.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        while head:\n            if head.val in G and (head.next==None or head.next.val not in G):\n                count+=1\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        def dfs(head, i):\n            if not head:\n                return\n            if head.val in G:\n                G[head.val] = i\n            dfs(head.next, i+1)\n        G = collections.Counter(G)\n        ans = 1\n        dfs(head, 0)\n        sortedValues = sorted(G.values())\n        for i in range(1, len(sortedValues)):\n            if sortedValues[i] != sortedValues[i-1]+1:\n                ans += 1\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        # construct the graph\n        graph = collections.defaultdict(dict)\n        \n        for node in G:\n            graph[node][node] = True\n        \n        while head:\n            # have a edge\n            if head.__next__ and head.val in graph and head.next.val in graph:\n                graph[head.val][head.next.val] = True\n                graph[head.next.val][head.val] = True\n            head = head.__next__\n        print(graph)\n        # Find connected components, by BFS\n        result, queue, visited = 0, collections.deque(), set()\n        \n        for g in graph:\n            if g not in visited:\n                queue.append(g)\n                result += 1\n                while queue:\n                    node = queue.pop()\n                    visited.add(node)\n                    neighbors = graph[node]\n                    for nei in neighbors:\n                        if nei not in visited:\n                            queue.append(nei)\n        return result\n    \n    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        GS = set(G)\n        count = 0\n        status = 0\n        \n        if not head or not G: return 0\n        \n        while head:\n            if head.val in GS:\n                status = 1\n                GS.remove(head.val)\n            else:\n                if status ==1:\n                    count +=1\n                    status =0\n            head = head.__next__\n        if status ==1:\n            count +=1\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        res = 0\n        s = set(G)\n        def func(head, path):\n            nonlocal res\n            if head:\n                nonlocal s\n                if head.val in s:\n                    path.append(head.val)\n                    s.remove(head.val)\n                    func(head.next, path.copy())\n                else:\n                    if len(path):   res += 1\n                    func(head.next, [])\n            else:\n                if len(path):   res += 1\n        func(head, [])\n        return res", "from collections import defaultdict\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass UF:\n    def __init__(self):\n        self.p = {}\n        self.r = defaultdict(lambda: 1)\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.r[x] > self.r[y]:\n            self.p[y] = x\n        elif self.r[x] < self.r[y]:\n            self.p[x] = y\n        else:\n            self.p[x] = y\n            self.r[y] += 1\n    \n    def find(self, x):\n        if self.p.get(x, x) != x:\n            self.p[x] = self.find(self.p.get(x,x))\n        return self.p.get(x, x)\n\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        uf = UF()\n        # uf.union(head.val, head.next.val)\n        # return 0 \n        gSet = set(G)\n        prev = head.val\n        head = head.next\n        # print(\\\"AB\\\")\n        while head != None:\n        # for i in range(1):\n            # print\n            curr = head.val\n            if curr in gSet and prev in gSet:\n                uf.union(curr, prev)\n                # return 1\n            head = head.next\n            prev = curr\n        # return 0  \n        resSet = set()\n        # print(G[1])\n        # print(uf.p)\n        # resSet.add(uf.find(i))\n        # resSet.add(uf.find(G[1]))\n        # return 10\n        for i in G:\n            # print(i)\n            resSet.add(uf.find(i))\n        print(resSet, uf.p)\n        return len(resSet)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        newG = set(G)\n        cnt = 0\n        start = None\n        while head != None:\n            if head.val not in newG:\n                if start != None:\n                    start = None\n                    cnt += 1\n            else:\n                start = 1\n            head = head.__next__\n        if start != None:\n            cnt += 1\n        return cnt\n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, l: List[int]) -> int:\n        l=set(l)\n        n=len(l)\n        temp=head\n        while(temp and temp.__next__):\n            if(temp.val in l and temp.next.val in l):\n                n-=1\n            temp=temp.__next__\n        return n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        res, s = 0, set(G)\n        start = False\n        while head:\n            if head.val in s:\n                if not start:\n                    res += 1\n                    start = True\n            else:\n                if start:\n                    start = False\n            head = head.next\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        ##################################################################\n        # N.B Description is pure bullshit \n        # solution 1, iterate through \n        components = 0\n        G = set(G) # convert to set \n        \n        while head: # iterate through\n            if head.val in  G and ( head.__next__ == None or head.next.val  not in  G):\n\n                components += 1 \n            head = head.__next__ \n            \n        return components\n        ##################################################################\n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        Gset = set(G)\n        current = head\n        ans = 0\n        while current:\n            if current.val in Gset:\n                if current.next and current.next.val not in Gset or current.next is None:\n                # if current.next and current.next.val not in Gset:\n                    ans += 1\n            current = current.next\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        G = set(G)\n        temp = head\n        isConnected = False\n        connections = 0\n        while temp != None:\n            if temp.val in G:\n                connections += 0 if isConnected else 1\n                isConnected = True\n            else:\n                isConnected = False\n            temp = temp.next\n        return connections", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        ans = 0\n        if not head:\n            return ans\n        G=set(G)\n  \n        if head.val in G:\n            ans += 1\n            prev_con = True\n        else:\n            prev_con = False\n        \n        node = head.__next__\n        while node:\n            if node.val in G:\n                if not prev_con:\n                    ans += 1\n                    prev_con = True\n            else:\n                prev_con = False\n            node = node.__next__\n        return ans\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        Gset = set(G)\n        cur = head\n        ans = 0\n        while cur:\n            if (cur.val in Gset and getattr(cur.next, 'val', None) not in Gset):\n                ans += 1\n            cur = cur.next \n        \n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        uniques = set(G)\n        isConnected = False\n        num = 0\n        while head:\n            if not isConnected and (head.val in uniques):\n                isConnected = True\n                num += 1\n            if head.val not in uniques:\n                isConnected = False\n            head = head.__next__\n        return num\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        c = 0\n        els = {}\n        check = False\n        for el in G:\n            els[el] = True\n        while head != None:\n            if head.val in els:\n                if not check:\n                    c += 1\n                    check = True\n            else:\n                check = False\n            head = head.__next__\n        return c\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        setG = set(G)\n        res = 0\n        while head:\n            if head.val in setG and (head.__next__ == None or head.next.val not in setG):\n                res += 1\n            head = head.__next__\n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head or not G:\n            return 0\n        \n        ht = {}\n        for component in G:\n            ht[component] = True\n        if head.val in ht:\n            total = 1\n        else:\n            total = 0\n        prev = head\n        while(head.next):\n            head = head.next\n            if head.val in ht and prev.val in ht :\n                if total == 0:\n                    total = 1\n                continue\n            elif head.val in ht:\n                total += 1\n            prev = head \n        return total", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if head == None:\n            return 0\n        if len(G) == 0:\n            return 0\n        \n        resNum = 0\n        pre = None\n        GG = set(G)\n        while head:\n            if head.val in GG and resNum == 0:\n                resNum += 1\n            elif head.val in GG and pre not in GG:\n                resNum += 1\n\n            pre = head.val\n            head = head.next\n            \n        return resNum", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        num_ccs = 0\n        \n        nodes = set(G)\n        last_was_cc = False\n        \n        while head is not None:\n            if head.val in nodes:\n                if not last_was_cc:\n                    num_ccs += 1\n                last_was_cc = True\n            else:\n                last_was_cc = False\n                \n            head = head.next\n            \n        return num_ccs", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        Gset = set(G)\n        current = head\n        ans = 0\n        while current:\n            if current.val in Gset:\n                if current.next and current.next.val not in Gset or current.next is None:\n                    ans += 1\n            current = current.next\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head or not G:\n            return 0\n        \n        ht = {}\n        for component in G:\n            ht[component] = True\n        if head.val in ht:\n            total = 1\n        else:\n            total = 0\n        prev = head\n        while(head.next):\n            head = head.next\n            if head.val in ht and prev.val in ht :\n                continue\n            elif head.val in ht:\n                total += 1\n            prev = head \n        return total", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if head is None: return 0\n        s = set(G)\n        cur = head\n        count = 0\n        \n        while cur:\n            seen = set()\n            if cur.val not in seen and cur.val in s:\n                \n                while cur and cur.val not in seen and cur.val in s:\n                    seen.add(cur.val)\n                    cur = cur.__next__ \n                count += 1\n            else:\n                cur = cur.__next__ \n        return count\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        temp = head\n        inG = {}\n        \n        N = 1\n        inG[temp.val] = None\n        while(temp.__next__ != None):\n            inG[temp.next.val] = None\n            temp = temp.__next__\n            N+=1\n    \n        for g in G:\n            inG[g] = g\n        \n        \n        temp = head\n        while(temp.__next__ != None):\n            if(inG[temp.next.val] != None and inG[temp.val] != None):\n                # connect temp and temp.next in G list\n                inG[temp.next.val] = inG[temp.val]\n                \n            temp = temp.__next__\n            \n        if(None not in set(inG.values())):\n            return 1\n        else:\n            return len(set(inG.values())) - 1\n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head or not G:\n            return 0\n        allCom = []\n        com = []\n        while head:\n            \n            while head and head.val in G:\n                com.append(head.val)\n                G.remove(head.val)\n                head = head.__next__\n            # constructed component?\n            if com:\n                allCom.append(com)\n                com = []\n            if head:\n                head = head.__next__\n            else:\n                break\n        return len(allCom)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, g: List[int]) -> int:\n        g.sort()\n        n = 0\n        temp = head\n        while temp != None:\n            n += 1\n            temp = temp.next\n        a = [0]*n\n        i = 0\n        ans = 0\n        while head and i < n:\n            if head.val in g:\n                a[i] = 1\n            i += 1\n            head = head.next\n        for i in range(n):\n            if a[i] == 1:\n                if i == 0:\n                    ans += 1\n                elif a[i-1] == 0:\n                    ans += 1\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr = head\n        ccCount = 0\n        inCC = False\n        while curr is not None:\n            if curr.val in G:\n                if not inCC:\n                    ccCount += 1\n                G.remove(curr.val)\n                inCC = True\n            else:\n                inCC = False\n            curr = curr.next\n        return ccCount", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        setG = set(G)\n        output = 0\n        while head:\n            if head.val in setG:\n                output += 1\n                while head and head.val in G:\n                    head = head.next\n            else:\n                head = head.next\n        return output", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        normal_list = []\n        while head:\n            normal_list.append(head.val)\n            head = head.next\n            \n        print(\\\"normal_list: \\\", normal_list)\n        \n        G.sort()\n        print(\\\"G: \\\", G)\n        \n        groups = 0\n        stack = []\n        group_started = False\n        \n        # traverse normal_list\n        while len(normal_list) > 0:\n            a = normal_list.pop(0)\n            if a in G:\n                group_started = True\n            else:\n                if group_started == True:\n                    groups += 1\n                    group_started = False\n        \n        if group_started == True:\n            groups += 1\n        \n        return groups\n            \n        \n#         i = 0\n#         while i < len(normal_list):\n#             while i < len(normal_list) and normal_list[i] != G[i]:\n#                 G.insert(i, \\\"\\\")\n#                 i+=1\n            \n#             i+=1\n            \n#         print(\\\"G: \\\", G)\n        \n#         groups = 0\n        \n#         g = 0\n#         groups_started = False\n#         while g < len(G):\n#             if G[g] != '':\n#                 groups_started = True\n#             else:\n#                 if groups_started == True:\n#                     groups += 1\n#                     groups_started = False\n#             g+=1\n        \n#         if groups_started == True:\n#             groups +=1 # for the last one\n        \n#         print(\\\"groups: \\\", groups)\n#         return groups\n        \n        \n        ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        gset=set(G)\n        count=0\n        while head:\n            if head.val in gset and (head.__next__ is None or head.next.val not in gset):\n                count+=1\n            head=head.__next__\n        return count    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def binarySearch(self,val,G):\n        start = 0\n        end = len(G)-1\n        while start <=end:\n            mid = (start+end)//2\n            if G[mid] == val:\n                return True\n            elif G[mid] > val:\n                end=mid-1\n            else:\n                start = mid+1\n        return False\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        G.sort()\n        curr = head\n        i = 0\n        dict_clusters = {}\n        while curr is not None:\n            if i not in dict_clusters:\n                dict_clusters[i] = []\n            if self.binarySearch(curr.val,G):\n                dict_clusters[i].append(curr.val)\n            if curr.val not in G:\n                i+=1\n            curr = curr.__next__\n        # print(dict_clusters)\n        count = 0\n        for i in dict_clusters:\n            if len(dict_clusters[i])>0:\n                count+=1\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        #s = set(G)\n        \n        prevIn = False\n        while head:\n            if head.val in G:\n                if prevIn:\n                    G.remove(head.val)\n                else:\n                    prevIn = True\n            else:\n                prevIn = False\n            \n            head = head.__next__\n        \n        return len(G)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        s=set(G)\n        ctr=0\n        currently_connected=False\n        while head:\n            if head.val in G:\n                if not currently_connected:\n                    ctr+=1\n                    currently_connected=True\n            else:\n                currently_connected=False\n            head=head.__next__\n        return ctr\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        con = False\n        while head:\n            if head.val in G:\n                if not con:\n                    con = True\n                    count += 1\n            else:\n                if con:\n                    con = False\n            head = head.__next__\n        return count\n                \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head or not G: return 0\n        count = 0\n        flag = 0\n        while head:\n            if head.val in G:\n                flag = 1\n            else:\n                if flag:\n                    count += 1\n                    flag = 0\n            head = head.next\n        if flag: count += 1\n            \n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        initial_c = len(G)\n        \n        runner = head\n        ans = []\n        conn_ll = []\n        while runner:\n            if runner.val in G:\n                conn_ll.append(runner.val)\n            else:\n                if conn_ll:\n                    ans.append(conn_ll[:])\n                    conn_ll = []\n            runner = runner.next\n            \n        if conn_ll:\n            ans.append(conn_ll)\n        print(ans)\n\n        return len(ans)", "from collections import defaultdict\n\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head:\n            return 0\n        \n        temp = head\n        prev = None\n        adj = defaultdict(list)\n        \n        while temp:\n            adj[temp.val] += [prev.val if prev else None, temp.next.val if temp.next else None]\n            prev = temp\n            temp = temp.__next__\n        \n        exists = defaultdict(bool)\n        for g in G:\n            exists[g] = True    \n        \n        visited = defaultdict(bool)\n            \n        ans = 0\n        for g in G:\n            if not visited[g]:\n                ans += 1\n                queue = [g]\n                while queue:\n                    node = queue[0]\n                    queue = queue[1:]\n                    visited[node] = True\n                    for j in adj[node]:\n                        if j is not None and not visited[j] and j in G:\n                            queue.append(j)\n                            visited[j] = True\n                \n        return ans\n            \n", "from collections import defaultdict\n\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        if not head:\n            return 0\n        \n        temp = head\n        prev = None\n        adj = defaultdict(list)\n        \n        while temp:\n            adj[temp.val] += [prev.val if prev else None, temp.next.val if temp.next else None]\n            prev = temp\n            temp = temp.next\n        \n        \\\"\\\"\\\"exists = defaultdict(bool)\n        for g in G:\n            exists[g] = True    \n        \\\"\\\"\\\"\n        visited = defaultdict(bool)\n            \n        ans = 0\n        for g in G:\n            if not visited[g]:\n                ans += 1\n                queue = [g]\n                while queue:\n                    node = queue[0]\n                    queue = queue[1:]\n                    visited[node] = True\n                    for j in adj[node]:\n                        if j is not None and not visited[j] and j in G:\n                            queue.append(j)\n                            visited[j] = True\n                \n        return ans\n            \n            ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        ans = 0\n        cnt = 0\n        while head:\n            if head.val in G:\n                cnt = 1\n            else:\n                ans += cnt\n                cnt = 0\n            head = head.__next__\n\n        return ans+cnt\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents_v1(self, head: ListNode, G: List[int]) -> int:\n        \n        # traverse list & count conn-comp\n        count = 0               # keep track of number of comps\n        new_comp = False        # flag if a new comp is in progress\n        while head:\n            \n            # filter out elements not in G\n            if head.val in G:\n                # a new comp detected\n                if not new_comp:\n                    new_comp = True\n                    count += 1\n            else:\n                # flag the current comp (if in progress) is done\n                new_comp = False\n                \n            # try next element\n            head = head.__next__\n        \n        return count\n    \n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        return self.numComponents_v1(head, G)\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        connected_components = 0\n        q = head\n        G = set(G)\n    \n        \n        while q is not None:\n            if q.val in G:\n                while q is not None and q.val in G:\n                    q = q.__next__\n                connected_components += 1\n            if q is not None:\n                q = q.__next__\n                \n        return connected_components\n    \n    \n#             count = 0\n#         p1, p2 = head, head\n#         while p2:\n#             if p1.val in G:\n#                 p2 = p1.next\n#                 p1 = p2\n#                 if not p2 or p2.val not in G:\n#                     count+=1\n#             else:\n#                 p1 = p2.next\n#                 p2 = p1\n#         return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        window = False\n        connected = 0\n        node = head \n        while node:\n            if node.val in G:\n                window = True\n            else:\n                if window:\n                    connected += 1\n                    window = False\n            node = node.__next__\n        if window:\n            connected +=1\n        return connected\n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr_node = head\n        value_in = False\n        no = 0\n        while curr_node:\n            if value_in:\n                if not curr_node.val in G:\n                    no = no + 1\n                    value_in = False\n            else:\n                if curr_node.val in G:\n                    value_in = True\n                \n            curr_node = curr_node.next\n        if value_in:\n            no = no + 1\n        return no", "class Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        tail = head\n        components = 0\n        connected = False\n        while tail is not None:\n            if tail.val in G:\n                connected = True\n            elif connected:\n                components += 1\n                connected = False\n            tail = tail.next\n        if connected:\n            components += 1\n            connected = False\n        return components", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        res = 0\n        flag = 0\n        while head:\n            if head.val in G:\n                if flag == 0:\n                    res += 1\n                flag = 1\n            else:\n                flag = 0\n            head = head.next\n        return res", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        temp=0\n        s=1\n        while head:\n            if head.val in G:\n                temp+=1\n            else:\n                temp=0\n                s=1\n            head=head.next\n            if temp>0 and s==1:\n                s=0\n                count+=1\n        if temp>0 and s==1:\n                s=0\n                count+=1\n            \n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count =0 \n        temp = head\n        while temp:\n            if temp.val not in G:\n                temp = temp.__next__ \n                continue\n            curr = temp.__next__\n            while curr:\n                if curr.val not in G:\n                    curr = curr.__next__ \n                    break \n                else:\n                    curr  = curr.__next__ \n            count +=1\n            temp = curr \n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        cur = head\n        con = 0\n        ans = 0\n        while cur:\n            if cur.val not in G:\n                if con != 0:\n                    ans += 1\n                con = 0\n            else:\n                con += 1\n            cur = cur.next\n        if con != 0:\n            ans += 1\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr_node = head\n        value_in = False\n        no = 0\n        while curr_node:\n            if curr_node.val in G:\n                value_in = True\n            else:\n                if value_in:\n                    no = no + 1\n                    value_in = False\n            curr_node = curr_node.__next__\n        if value_in:\n            no = no + 1\n        return no\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        cur = head\n        cnt = 0\n        flg = False\n        while cur != None:\n            if cur.val in G:\n                if flg:\n                    pass\n                else:\n                    flg=True\n                    cnt+=1\n            elif flg:\n                flg=False\n            cur = cur.__next__\n        return cnt\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        ##################################################################\n        # solution 1, iterate through \n        components = 0\n        G_set = set(G) # convert to set \n        \n        while head: # iterate through\n            if head.val in  G_set and ( head.__next__ == None or head.next.val  not in  G_set):\n                G_set.remove(head.val)\n\n                components += 1 \n            head = head.__next__ \n            \n        return components\n        ##################################################################\n\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        cur = head\n        cons = False\n        while(cur):\n            if cur.val in G:\n                if not cons:\n                    cons = True\n                    count +=1\n            else:\n                cons = False\n            cur = cur.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        connected_components = 0\n        q = head\n        \n        while q is not None:\n            if q.val in G:\n                while q is not None and q.val in G:\n                    q = q.__next__\n                connected_components += 1\n            if q is not None:\n                q = q.__next__\n                \n        return connected_components\n    \n    \n#             count = 0\n#         p1, p2 = head, head\n#         while p2:\n#             if p1.val in G:\n#                 p2 = p1.next\n#                 p1 = p2\n#                 if not p2 or p2.val not in G:\n#                     count+=1\n#             else:\n#                 p1 = p2.next\n#                 p2 = p1\n#         return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        result = 0\n        node = head\n        tmp = []\n        while node is not None:\n            if node.val in G:\n                tmp.append(node.val)\n                node = node.next\n            else:\n                if tmp:\n                    result += 1\n                    tmp = [] \n                node = node.next\n        if tmp:\n            result += 1\n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        val = False\n        count = 0\n        while head:\n            if head.val in G:\n                val = True\n                \n                while head and head.val in G:\n                    head = head.__next__\n                count += 1\n            if head:\n                head = head.__next__\n            \n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr = head\n        components = 0\n        \n        in_component = False\n        while curr != None:\n            if curr.val in G:\n                in_component = True\n            elif in_component:\n                components += 1\n                in_component = False\n\n            curr = curr.next\n            \n        if in_component:\n            components += 1\n            \n        return components", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        comp = False\n        count = 0\n        while(head):\n            if(head.val in G):\n                if(not comp):\n                    comp = True\n            else:\n                if(comp):\n                    count += 1\n                    comp = False\n            \n            head = head.next\n            \n        return count + 1 if comp else count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while head:\n            if head.val in G:\n                while head and head.val in G:\n                    head = head.next\n                count += 1\n                if not head:\n                    break\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        res = [0]\n        tmp_count = 0\n        while head:\n            if head.val not in G:\n                res.append(tmp_count)\n                tmp_count = 0\n            else:\n                tmp_count += 1\n            \n            head = head.__next__\n        res.append(tmp_count)\n        count = 0\n        for i in res:\n            if i !=0:\n                count += 1\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, g: List[int]) -> int:\n        g = set(g)\n        n = 0\n        temp = head\n        while temp != None:\n            n += 1\n            temp = temp.next\n        a = [0]*n\n        i = 0\n        ans = 0\n        while head and i < n:\n            if head.val in g:\n                a[i] = 1\n            i += 1\n            head = head.next\n        for i in range(n):\n            if a[i] == 1:\n                if i == 0:\n                    ans += 1\n                elif a[i-1] == 0:\n                    ans += 1\n        return ans", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while head:\n            if head.val in G:                \n                while head and head.val in G:\n                    head = head.__next__\n                count += 1\n            if head:\n                head = head.__next__\n            \n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        p=head\n        while(p!=None):\n            if p.val in G:\n                count+=1\n                q=p.next\n                while(q!=None and q.val in G):\n                    q=q.next\n                p=q\n            else:\n                p=p.next\n\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr_node = head\n        no = 0\n        while curr_node:\n            if curr_node.val in G:\n                curr_node = curr_node.__next__\n                while curr_node and (curr_node.val in G):\n                    curr_node = curr_node.__next__\n                no = no + 1\n            else:\n                curr_node = curr_node.__next__\n        return no\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        curr_node = head\n        value_in = False\n        no = 0\n        while curr_node:\n            if value_in and (not curr_node.val in G):\n                no = no + 1\n                value_in = False\n            elif curr_node.val in G:\n                value_in = True\n            curr_node = curr_node.__next__\n        if value_in:\n            no = no + 1\n        return no\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while head:\n            if head.val in G:\n                count += 1\n                while head and head.val in G:\n                    head = head.next\n            else:\n                head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        count = 0\n        while(head):\n            if(head.val in G):\n                while(head.next and head.next.val in G):\n                    head = head.next\n                count += 1\n            head = head.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        temp = head\n        count = 0\n        while temp:\n            if temp.val in G:\n                while temp and temp.val in G:\n                    temp = temp.next\n                count += 1\n                if not temp:\n                    break\n            temp = temp.next\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        Gset = set(G)\n        cur = head\n        noOfcomponents = 0\n        while cur:\n            if cur.val in Gset and (not cur.__next__ or cur.next.val not in Gset):\n                noOfcomponents+=1\n                cur = cur.__next__\n            else:\n                cur = cur.__next__\n        return noOfcomponents\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        temp = head\n        while(temp):\n            if(temp.val in G):\n                count = count + 1\n                while(temp and temp.val in G):\n                    temp = temp.__next__\n            else:\n                temp = temp.__next__\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        while(head and head.next):\n            if head.val in G and head.next.val in G:\n                G.remove(head.val)\n            head = head.next\n        return len(G)", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        lst=[]\n        curr=head\n        while curr:\n            lst.append(curr.val)\n            curr=curr.next\n        \n        count=0\n        i=0\n        flag=0\n        while i <len(lst):\n            if lst[i] in G:\n                i=i+1\n                flag=1\n                continue\n            elif flag==1 and lst[i] not in G:\n                count=count+1\n                i=i+1\n                flag=0\n            else:\n                i=i+1\n                \n        if lst[-1] in G:\n            count=count+1\n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        '''\n        # approach 1\n        # traverse ll, if node in G, put in components as another list or extending the list\n        \n        num_components=0\n        components=[]\n        \n        cur=head\n        dummy=ListNode(-1)\n        dummy.next=cur\n        \n        while cur:\n            if cur.val in G:\n                if dummy.val in G:\n                    component=components[-1]\n                    components.pop()\n                    component.append(cur.val)\n                    components.append(component)\n                else:\n                    components.append([cur.val])\n            dummy=cur\n            cur=cur.next\n        \n        print(len(components))\n        return len(components)\n        '''\n        # approach 2 : \n        # traverse ll, check if prev node in G. use a flag\n        # if not prev_in : increment count, else continue traversal (going through the same component)\n        \n        cur=head\n        prev_in=False\n        count=0\n        \n        while cur:\n            if cur.val in G:\n                if not prev_in:\n                    count+=1\n                prev_in=True\n            else:\n                prev_in=False\n            cur=cur.__next__\n        return count\n                    \n                    \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        temp=head\n        count=0\n        c=0\n        if len(G)==1:\n            return 1\n        while temp :\n            if temp.val  in G :\n                    print((temp.val))\n                    count+=1\n                    while temp and temp.val in G:\n                        temp=temp.__next__ \n            else:\n                temp=temp.__next__\n                \n            \n        return count\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        if len(G)==1:\n            return 1\n        while head :\n            if head.val  in G :\n                    print((head.val))\n                    count+=1\n                    while head and head.val in G:\n                        head=head.__next__ \n            else:\n                head=head.__next__\n                \n            \n        return count\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        \n        while head:\n            if head.val in G:\n                ind = G.index(head.val)\n                count+=1\n                head=head.__next__\n                ind+=1\n                while head and head.val in G:\n                    head=head.__next__\n                \n            else:\n                head=head.__next__\n        return(count)        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        cur = head\n        connected = 0\n        \n        while cur != None:\n            if cur.val in G:\n                while cur.val in G:\n                    cur = cur.next\n                    \n                    if cur == None:\n                        break\n                        \n                connected += 1\n            else:\n                cur = cur.next\n        \n        return connected", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count = 0\n        while head:\n            if head.val in G and (head.__next__ == None or head.next.val not in G):\n                count += 1\n            head = head.__next__\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n    \n        count=0\n        i=head\n        while i:\n            if i.val in G:\n                count+=1\n                while i and i.val in G:\n                    i=i.__next__\n            else :i=i.__next__\n        return count\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        temp=head\n        new=[]\n        \n        while temp:\n            new.append(temp.val)\n            temp=temp.__next__\n        \n        dkg={}\n        \n        for i in G:\n            dkg[i]=1\n                \n        for i in range(len(new)):\n            if new[i] in dkg:\n                new[i]=1\n            else:\n                new[i]=0\n        \n        count=new[0]\n        for i in range(1,len(new)):\n            if new[i]!=new[i-1] and new[i]==1:\n                count+=1\n\n\n        return count\n\n\n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        count = 0\n        p1, p2 = head, head\n        \n        while p2:\n            if p1.val in G:\n                p2 = p1.next\n                p1 = p2\n                if not p2 or p2.val not in G:\n                    count+=1\n            else:\n                p1 = p2.next\n                p2 = p1\n        \n        return count", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        counter = 0\n        prev, current = None, head\n        \n        while current:\n            if current.val in G:\n                if not prev or prev.val not in G:\n                    counter += 1\n                    \n            prev, current = current, current.__next__\n            \n        return counter\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        c=head\n        a=0\n        while c:\n            if (c.val in G and getattr(c.next,'val',None) not in G):\n                a=a+1\n            c=c.next\n        return a", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        cnt = 0\n        while head:\n            if head.val in G and (head.__next__ is None or head.next.val not in G):\n                cnt+=1\n            head = head.__next__\n        return cnt\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        initial_c = len(G)\n        \n        runner = head\n        # Approach 1\n#         ans = []\n#         conn_ll = []\n#         while runner:\n#             if runner.val in G:\n#                 conn_ll.append(runner.val)\n#             else:\n#                 if conn_ll:\n#                     ans.append(conn_ll[:])\n#                     conn_ll = []\n#             runner = runner.next\n            \n#         if conn_ll:\n#             ans.append(conn_ll)\n\n#         return len(ans)\n\n        # Approach 2\n        count = 0\n        while runner:\n            if runner.val in G and getattr(runner.next, 'val', None) not in G:\n                count += 1\n            runner = runner.next\n        return count ", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        cur = head\n        N = len(G)\n        while cur:\n            if cur.__next__ and cur.val in G and cur.next.val in G:\n                N-=1\n            cur = cur.__next__\n        return N\n                \n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        \n        res =0\n        curr = head\n        found = False\n        while curr is not None:\n            if not found and curr.val in G:\n                found = True\n                res +=1\n                \n            if found and curr.val  not in G:\n                found = False\n            curr = curr.__next__\n        return res\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\n        count=0\n        s=set(G)\n        ans=len(G)\n        while head and head.__next__:\n            if (head.val in G) and (head.next.val in G):\n                ans-=1\n            head=head.__next__\n        return ans\n        \n              \n"]
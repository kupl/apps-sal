["def find_upper_bound(arr,key):\n low,high = 0,len(arr)-1\n while low<=high:\n  mid = (low+high)//2 \n  if arr[mid]==key:return mid\n  elif arr[mid]>key and mid-1>=0 and arr[mid-1]<key:return mid \n  elif arr[mid]>key:high = mid - 1 \n  else:low = mid + 1 \n return mid \ndef get_query(l):\n nonlocal prefix_storer,bin_storer\n ind = find_upper_bound(bin_storer,l)\n surplus = (abs(bin_storer[ind]-l)*ind*ind)%limit \n return (prefix_storer[ind]-surplus+limit)%limit\ndef fire_query(l,r):\n return (get_query(r)-get_query(l-1)+limit)%limit\ngolomb,dp,prefix_storer,bin_storer = [],[0,1],[0,1],[0,1]\nlimit = 10**9+7\nfor i in range(2,10**6+100):\n dp.append(1 + dp[i-dp[dp[i-1]]])\n bin_storer.append(dp[-1]+bin_storer[-1])\n prefix_storer.append(((prefix_storer[-1] + (dp[-1]*i*i)%limit))%limit)\n# print(dp[1:20])\n# print(bin_storer[1:20])\n# print(prefix_storer[1:20])\n# print(get_query(2),get_query(4))\nfor _ in range(int(input())):\n l,r = map(int,input().split())\n print(fire_query(l,r))", "def find_upper_bound(arr,key):\n low,high = 0,len(arr)-1\n while low<=high:\n  mid = (low+high)//2 \n  if arr[mid]==key:return mid\n  elif arr[mid]>key and mid-1>=0 and arr[mid-1]<key:return mid \n  elif arr[mid]>key:high = mid - 1 \n  else:low = mid + 1 \n return mid \ndef get_query(l):\n nonlocal prefix_storer,bin_storer\n ind = find_upper_bound(bin_storer,l)\n surplus = (abs(bin_storer[ind]-l)*ind*ind)%limit \n return (prefix_storer[ind]-surplus+limit)%limit\ndef fire_query(l,r):\n return (get_query(r)-get_query(l-1))%limit\ngolomb,dp,prefix_storer,bin_storer = [],[0,1],[0,1],[0,1]\nlimit = 10**9+7\nfor i in range(2,10**6+100):\n dp.append(1 + dp[i-dp[dp[i-1]]])\n bin_storer.append(dp[-1]+bin_storer[-1])\n prefix_storer.append(((prefix_storer[-1] + (dp[-1]*i*i)%limit))%limit)\n# print(dp[1:20])\n# print(bin_storer[1:20])\n# print(prefix_storer[1:20])\n# print(get_query(2),get_query(4))\nfor _ in range(int(input())):\n l,r = map(int,input().split())\n print(fire_query(l,r))", "# cook your dish here\nimport bisect\nMAXR = 100\nMAXN = 20000000\nT = int(input().strip())\nqueries = []\nfor t in range(T):\n L, R = map(int, input().strip().split())\n queries.append((L,R))\n MAXR = max(MAXR, R+1)\nMOD = 10**9+7\ng = [0,1,2]\np = [0,1,3]\ns = [0,1,9]\nfor n in range(3, MAXN):\n gg = 1 + g[n-g[g[n-1]]]\n pp = p[n-1] + gg\n ss = (s[n-1] + gg*n*n) % MOD\n g.append(gg)\n p.append(pp)\n s.append(ss)\n if pp > MAXR:\n  break\ndef process(m):\n n = bisect.bisect_right(p, m)\n return (s[n-1] + (m-p[n-1])*n*n) % MOD\nfor L, R in queries:\n print((process(R) - process(L-1))%MOD)", "import bisect\nM=1000000007\nG=[0,1,2,2]\ncurrPos=4\nfor i in range(3,2000000):\n if(currPos>2000000):\n  break\n j=0 \n while(j<G[i] and currPos<2000000):\n  G.append(i) \n  currPos+=1 \n  j+=1 \nprefixSum1=[0]\nprefixSum2=[0]\nfor i in range(1,2000000):\n prefixSum1.append(prefixSum1[i-1]+G[i])\nfor i in range(1,2000000):\n prefixSum2.append((prefixSum2[i-1] + i*i%M*G[i]%M)%M)\n #print(prefixSum1)\n #print(prefixSum2)\n\ndef solve(n):\n nthterm=bisect.bisect_left(prefixSum1, n, lo=0, hi=len(prefixSum1))-0\n ans=0 \n if(nthterm>0):\n  ans=prefixSum2[nthterm-1]\n ans = (ans + nthterm*nthterm%M * (n-prefixSum1[nthterm-1])%M)%M\n return ans\nfor tc in range(int(input())):\n l,r=map(int,input().split())\n print((solve(r)-solve(l-1)+M)%M)", "import sys\nimport bisect as b\ninput=sys.stdin.readline\nli=[]\nmod=10**9 + 7\nmxr=100\nmxn=20000000\n\nfor _ in range(int(input())):\n l,r=map(int,input().split())\n li.append([l,r])\n mxr=max(mxr,r+1)\n\ng=[0,1,2]\np=[0,1,3]\ns=[0,1,9]\n\nfor i in range(3,mxn):\n gg=1+g[i-g[g[i-1]]]\n pp=(p[i-1]+gg)%mod\n ss=(s[i-1]+gg*i*i)%mod\n g.append(gg)\n p.append(pp)\n s.append(ss)\n if pp>mxr:\n  break\ndef solve(m):\n n=b.bisect_right(p,m)\n return (s[n-1] + ((m-p[n-1])*n*n))%mod\nfor l,r in li:\n ans=(solve(r)-solve(l-1))%mod\n print(ans)", "# cook your dish here\nimport bisect as bi\n\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = (10 ** 9 + 7)\n\ndef find_gn(n):\n return (1 + temp_g[n - temp_g[temp_g[n - 1]]])\n\ndef find_sn(n, gn):\n return (temp_s[n - 1] + gn * n**2) % max_mod\n\ndef find_pn(n, gn):\n return (temp_p[n - 1] + gn)\n \ndef bisection(x):\n n = bi.bisect_right(temp_p, x)\n return (temp_s[n - 1] + (x - temp_p[n - 1]) * n**2 ) % max_mod\n \nlr, max_ = [], 100\n\nfor _ in range(int(input())):\n l, r = list(map(int, input().split()))\n lr.append((l, r))\n max_ = max(max_, r + 1)\n \nfor n in range(3, 2 * (10 ** 8), 1):\n gn = find_gn(n)\n sn, pn = find_sn(n, gn), find_pn(n, gn)\n temp_g.append(gn)\n temp_p.append(pn)\n temp_s.append(sn)\n if (pn > max_):\n  break\n \nfor pair in lr:\n print(bisection(pair[1]) - bisection(pair[0] - 1) % max_mod)\n\n\n", "# cook your dish here\nimport bisect as bi\n\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = (10 ** 9 + 7)\n\ndef find_gn(n):\n return (1 + temp_g[n - temp_g[temp_g[n - 1]]])\n\ndef find_sn(n, gn):\n return (temp_s[n - 1] + gn * n * n) % max_mod\n\ndef find_pn(n, gn):\n return (temp_p[n - 1] + gn)\n \ndef bisection(x):\n n = bi.bisect_right(temp_p, x)\n return (temp_s[n - 1] + (x - temp_p[n - 1]) * n * n ) % max_mod\n \nlr, max_ = [], 100\n\nfor _ in range(int(input())):\n l, r = list(map(int, input().split()))\n lr.append((l, r))\n max_ = max(max_, r + 1)\n \nfor n in range(3, 2 * (10 ** 8), 1):\n gn = find_gn(n)\n sn, pn = find_sn(n, gn), find_pn(n, gn)\n temp_g.append(gn)\n temp_p.append(pn)\n temp_s.append(sn)\n if (pn > max_):\n  break\n \nfor pair in lr:\n print(bisection(pair[1]) - bisection(pair[0] - 1) % max_mod)\n\n\n", "# cook your dish here\nimport bisect as bi\n\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = (10 ** 9 + 7)\n\ndef find_gn(n):\n return (1 + temp_g[n - temp_g[temp_g[n - 1]]])\n\ndef find_sn(n, gn):\n return (temp_s[n - 1] + gn * n * n) % max_mod\n\ndef find_pn(n, gn):\n return (temp_p[n - 1] + gn)\n \ndef bisection(x):\n n = bi.bisect_right(temp_p, x)\n return (temp_s[n - 1] + (x - temp_p[n - 1]) * n * n ) % max_mod\n \nlr, max_ = [], 100\n\nfor _ in range(int(input())):\n l, r = list(map(int, input().split()))\n lr.append((l, r))\n max_ = max(max_, r + 1)\n \nfor n in range(3, 2 * (10 ** 8), 1):\n gn = find_gn(n)\n sn = find_sn(n, gn)\n pn = find_pn(n, gn)\n temp_g.append(gn)\n temp_p.append(pn)\n temp_s.append(sn)\n if (pn > max_):\n  break\n \nfor pair in lr:\n print(bisection(pair[1]) - bisection(pair[0] - 1) % max_mod)\n\n\n", "# cook your dish here\nimport bisect\n\nMAXR = 100\nMAXN = 20000000\n\nT = int(input().strip())\nqueries = []\nfor t in range(T):\n L, R = list(map(int, input().strip().split()))\n queries.append((L,R))\n MAXR = max(MAXR, R+1)\n \n \nMOD = 10**9+7\ng = [0,1,2]\np = [0,1,3]\ns = [0,1,9]\n\nfor n in range(3, MAXN):\n gg = 1 + g[n-g[g[n-1]]]\n pp = p[n-1] + gg\n ss = (s[n-1] + gg*n*n) % MOD\n g.append(gg)\n p.append(pp)\n s.append(ss)\n if pp > MAXR:\n  break\n \ndef process(m):\n n = bisect.bisect_right(p, m)\n return (s[n-1] + (m-p[n-1])*n*n) % MOD\n \n \nfor L, R in queries:\n print((process(R) - process(L-1))%MOD)\n", "'''\nName : Jaymeet Mehta\ncodechef id :mj_13\nProblem : \n'''\nfrom sys import stdin,stdout\nimport math\nfrom bisect import bisect_left\nmod=1000000007\ndef mul(a,b):\n nonlocal mod\n return ((a%mod)*(b%mod))%mod\ndef add(a,b):\n nonlocal mod\n return ((a%mod)+(b%mod))%mod\ng=[0,1]\npre=[0,1]\nans=[0,1]\ni=2\nwhile(True):\n g.append(1+g[i-g[g[i-1]]])\n pre.append(pre[i-1]+g[i])\n ans.append(add(ans[i-1],mul(mul(i,i),g[i])))\n if pre[i]>10000000000:\n  break\n i+=1\ntest=int(stdin.readline())\nfor _ in range(test):\n l,r= list(map(int,stdin.readline().split()))\n sm1,sm2=0,0\n \n if l==1:\n  sm1=0\n else:\n  l-=1\n  tl=bisect_left(pre,l)\n  sm1=add(ans[tl-1],mul(l-pre[tl-1],mul(tl,tl)))\n tr=bisect_left(pre,r)\n sm2=add(ans[tr-1],mul(r-pre[tr-1],mul(tr,tr)))\n print((sm2-sm1)%mod)\n", "import bisect\nimport sys\ninput = sys.stdin.readline\n\nMAXR = 100\nMAXN = 20000000\n\nt = int(input().strip())\nqueries = []\nfor t in range(t):\n L, R = map(int, input().strip().split())\n queries.append((L,R))\n MAXR = max(MAXR, R + 1)\n \n \nMOD = 10 ** 9 + 7\ng = [0, 1, 2]\np = [0, 1, 3]\ns = [0, 1, 9]\n\nfor n in range(3, MAXN):\n gn = 1 + g[n - g[g[n - 1]]]\n pn = p[n - 1] + gn\n sn = (s[n - 1] + gn * n * n) % MOD\n g.append(gn)\n p.append(pn)\n s.append(sn)\n if pn > MAXR:\n  break\n \ndef process(m):\n n = bisect.bisect_right(p, m)\n return (s[n - 1] + (m -p[n - 1]) * n * n) % MOD\n \n \nfor L, R in queries:\n print(process(R) - process(L - 1) % MOD)"]
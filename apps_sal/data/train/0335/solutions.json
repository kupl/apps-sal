["from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        rods = sorted(rods)[::-1]\n        n = len(rods)\n        psum = rods.copy()\n        for i in range(n-1)[::-1]:\n            psum[i] += psum[i+1]\n\n        @lru_cache(None)\n        def dfs(idx, diff):\n            if idx == n:\n                return 0 if diff == 0 else -float('inf')\n            if diff > psum[idx]:\n                return -float('inf')\n            return max(dfs(idx+1,diff),dfs(idx+1,diff+rods[idx]),dfs(idx+1,abs(diff-rods[idx]))+min(diff,rods[idx]))\n        return dfs(0,0)", "class Solution:\n    def tallestBillboard(self, rods):\n        dp = {0:0}\n        for r in rods:\n            for diff, y in list(dp.items()):\n                dp[diff + r] = max(dp.get(diff + r, 0), y)\n                if diff - r >= 0:\n                    dp[diff - r] = max(dp.get(diff - r, 0), y + r)\n                if r - diff >= 0:\n                    dp[r - diff] = max(dp.get(r - diff, 0), y + diff) \n                # dp[abs(diff - r)] = max(dp.get(abs(diff - r), 0), y + min(diff, r)) \n        return dp[0]", "from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods):\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            return max(dp(i + 1, s),\n                       dp(i + 1, s - rods[i]),\n                       dp(i + 1, s + rods[i]) + rods[i])\n\n        return dp(0, 0)", "class Solution:\n    def tallestBillboard(self, rods):\n        mem = {}\n        def dp(i, s):\n            if (i, s) in mem: return mem[(i, s)]\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            res = max(dp(i + 1, s),\n                      dp(i + 1, s - rods[i]),\n                      dp(i + 1, s + rods[i]) + rods[i])\n            mem[(i,s)] = res\n            return res\n\n        return dp(0, 0)\n", "class Solution:\n    def exclu(self,nums):\n        # whether we can find two elements x and y in nums so that x & y == 0\n        n=len(nums)\n        if n<=1: return False\n        if n<=4:\n            for x in nums:\n                for y in nums:\n                    if x & y ==0: return True\n            return False\n\n        set0,set1=set(),set()\n        for x in nums:\n            if x & 1 : set1.add(x>>1)\n            else: set0.add(x>>1)\n        if set0:\n            if self.exclu(set0): return True\n            if set1:  return self.exclu2(set0,set1)\n        return False\n        \n    def exclu2(self,set0,set1):\n        # whether we can find x in set0 and y in set1 so that x & y == 0\n        # set0 and set1 are not empty\n        if len(set0)==0 or len(set1)==0: return False\n        if len(set1)==1:\n            x=next(iter(set1))\n            for y in set0: \n                if x & y ==0: return True\n            return False\n\n        if len(set0)==1:\n            x=next(iter(set0))\n            for y in set1: \n                if x & y ==0: return True\n            return False\n\n        if len(set0)<=8 and len(set1)<=8:\n            for x in set0:\n                for y in set1:\n                    if x & y ==0: return True\n            return False\n\n        set00,setx0,set01,set11=set(), set(), set(), set() \n        for x in set0:\n            setx0.add(x>>1)\n            if x & 1 ==0: set00.add(x>>1)\n        for x in set1:\n            if x & 1 : set11.add(x>>1)\n            else: set01.add(x>>1)\n        \n        if set00 and set11 and self.exclu2(set00,set11): return True\n        if set01 and setx0 and self.exclu2(set01,setx0): return True\n        return False\n\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n=len(rods)\n        if n<=1: return 0\n        \n        t=sum(rods)\n        m=t//2\n        infos=[[] for _ in range(m+1)]\n        infos[0]=[0]\n        \n        b=1\n        for x in rods:\n            # print(f'x={x}')\n            for y in range(m-x,-1,-1):\n                comb=infos[y]\n                if comb:\n                    infos[x+y]+=[z+b for z in comb]\n            b*=2\n            # print(infos)\n        \n        for y in range(m,0,-1):\n            comb,n=infos[y],len(infos[y])\n            # print( (y, n, comb)  )\n            if n>=2:\n                # print( (y, n)  )\n                # print(n)\n                if self.exclu(comb): return y\n        return 0\n            \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {0:0}\n        for x in rods:\n            temp = dp.copy()\n            for diff, height in list(dp.items()):\n                temp[diff+x] = max(temp.get(diff+x, 0), height)\n                temp[abs(x - diff)] = max(temp.get(abs(diff-x), 0), height + min(diff, x))\n            dp = temp.copy()\n        return dp[0]\n    \n    \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = collections.defaultdict(int)\n        dp[0] = 0\n        for x in rods:\n            nxt = dp.copy()\n            for d, y in dp.items():\n                nxt[d + x] = max(nxt.get(x + d, 0), y)\n                nxt[abs(d - x)] = max(nxt.get(abs(d - x), 0), y + min(d, x))\n            dp = nxt\n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dic=collections.defaultdict(int)\n        dic[0]=0\n        for x in rods:\n            for diff,val in list(dic.items()):\n                dic[diff+x]=max(dic[diff+x],val)\n                dic[abs(diff-x)]=max(dic[abs(diff-x)],val+min(x,diff))\n        return dic[0]\n", "from functools import lru_cache\nfrom collections import defaultdict\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # Dynamic Programming\n        # Let dp[i][s] be the largest score we can get using rods[j] (j >= i), \n        # after previously writing a sum of s.\n        # Time  complexity: O(N x S), where N is the length of rods and S is the maximum of sum(rods).\n        # Space complexity: O(N x S)\n        # @lru_cache(None)\n        # def dp(i, s):\n        #     if i == len(rods):\n        #         return 0 if s == 0 else float(\\\"-inf\\\")\n        #     return max(dp(i + 1, s),\n        #                dp(i + 1, s - rods[i]),\n        #                dp(i + 1, s + rods[i]) + rods[i])\n        # return dp(0, 0)\n\n\n        # dp[d] mean the maximum pair of sum we can get with pair difference d\n        # For example, if have a pair of sum (a, b) with a > b, then dp[a - b] = b\n        # If we have dp[diff] = a, it means we have a pair of sum (a, a + diff).\n        # And this is the biggest pair with difference = a\n        dp = defaultdict(int)\n        dp[0] = 0\n        for x in rods:\n            for d, y in list(dp.copy().items()):\n                dp[d + x] = max(dp[d + x], y)\n                dp[abs(d - x)] = max(dp[abs(d - x)], y + min(d, x))\n        return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {0: 0}\n        for x in rods:\n            for d,y in list(dp.items()):\n                dp[d + x] = max(dp.get(x + d, 0), y)\n                dp[abs(d - x)] = max(dp.get(abs(d - x), 0), y + min(d, x))\n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp=defaultdict(lambda: -1)\n        dp[0]=0\n        for x in rods:\n            prevdp=dp.copy()\n            for d in list(prevdp.keys()):\n                dp[x+d]=max(dp[x+d],prevdp[d])\n                dp[abs(x-d)]=max(dp[abs(x-d)],prevdp[d]+min(x,d))\n        return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {0: 0}\n        for x in rods:\n            new_dp = dp.copy()\n            for d, y in dp.items():\n                new_dp[d + x] = max(new_dp.get(x + d, 0), y)\n                new_dp[abs(d - x)] = max(new_dp.get(abs(d - x), 0), y + min(d, x))\n            dp = new_dp\n        return dp[0]", "from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        rods = sorted(rods)\n        n = len(rods)\n        psum = rods.copy()\n        for i in range(n-1)[::-1]:\n            psum[i] += psum[i+1]\n\n        @lru_cache(None)\n        def dfs(idx, diff):\n            if idx == n:\n                return 0 if diff == 0 else -float('inf')\n            if diff > psum[idx]:\n                return -float('inf')\n            return max(dfs(idx+1,diff),dfs(idx+1,diff+rods[idx]),dfs(idx+1,abs(diff-rods[idx]))+min(diff,rods[idx]))\n        return dfs(0,0)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # dp[diff] = a: have a pair of (a, a + diff)\n        \n        dp = {0: 0}\n        for rod in rods:\n            for d, x in list(dp.items()):\n                dp[d + rod] = max(dp.get(d + rod, 0), x)\n                dp[abs(d - rod)] = max(dp.get(abs(d - rod), 0), x + min(d, rod))\n        \n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        s = sum(rods)\n        n = len(rods)\n        \n        # diff, max_height\n        dp = {0:0}\n        \n        for num in rods:\n            new_dp = dp.copy()\n            for d,max_h in list(dp.items()):\n                new_dp[d+num] = max(new_dp.get(d+num,0),max_h+num)\n                new_dp[abs(d-num)] = max(new_dp.get(abs(d-num),0),max(max_h,max_h-d+num))\n            dp = new_dp\n        return dp[0]\n        \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {0: 0}\n        for r in rods:\n            for d, t in list(dp.items()):\n                dp[r+d] = max(dp.get(r+d, 0), t)\n                dp[abs(r-d)] = max(dp.get(abs(r-d), 0), t + min(r, d))\n        return dp[0]\n", "\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = collections.defaultdict(int)\n        dp[0] = 0\n        for x in rods:\n            nxt = dp.copy()\n            for d, y in dp.items():\n                nxt[d + x] = max(nxt.get(x + d, 0), y)\n                nxt[abs(d - x)] = max(nxt.get(abs(d - x), 0), y + min(d, x))\n            dp = nxt\n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        dp = {0: 0}\n        for r in rods:\n            dp2 = dp.copy()\n            for d in list(dp.keys()):\n                dp2[d + r] = max(dp2.get(d + r, 0), dp[d])\n                dp2[abs(d - r)] = max(dp2.get(abs(d - r), 0), dp[d] + min(d, r))\n            dp = dp2\n        # print(dp)\n        return dp[0]\n    \n    \n        # dp = {0: 0}\n        # for x in rods:\n        #     for d, y in dp.items():\n        #         dp[d + x] = max(dp.get(x + d, 0), y)\n        #         dp[abs(d - x)] = max(dp.get(abs(d - x), 0), y + min(d, x))\n        # return dp[0]\n        \n        \n        \n#         @lru_cache(None)\n#         def dp(i, s):\n#             if i == len(rods):\n#                 return 0 if s == 0 else float(\\\"-inf\\\")\n#             return max(dp(i + 1, s), dp(i + 1, s - rods[i]), dp(i + 1, s + rods[i]) + rods[i])\n        \n#         return dp(0, 0)\n        \n        \n        \n        \n#         dp = {}\n#         dp[0] = 0\n        \n#         for i in rods:\n#             cur = collections.defaultdict(int)\n#             for s in dp:\n#                 cur[s+i] = max(dp[s] + i, cur[s+i])\n#                 cur[s] = max(dp[s], cur[s])\n#                 cur[s-i] = max(dp[s], cur[s-i])\n#             dp = cur\n#         return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        #diff: lower length\n        dp = {0:0}\n        for r in rods:\n            new_dp = dp.copy()\n            for d,l in dp.items():\n                h = d+l\n                if r+d not in new_dp:\n                    new_dp[r+d] = l\n                new_dp[r+d] = max(new_dp[r+d],l)\n                if abs(d-r) not in new_dp:\n                    new_dp[abs(d-r)] = 0\n                new_dp[abs(d-r)] = max(new_dp[abs(d-r)],min(l+r,h))\n                \n            dp = new_dp\n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n = len(rods)\n        rods.sort()\n        prefixsum = [0]\n        for i in rods:\n            prefixsum.append(prefixsum[-1] + i)\n        s = prefixsum[-1]\n        dp = [-1] * (s + 1) * 2\n        dp[s] = 0\n        for i in range(n - 1, -1, -1):\n            new_dp = [-1] * (s + 1) * 2\n            for d in range(prefixsum[i] + 1):\n                if prefixsum[-1] - prefixsum[i] < d:\n                    new_dp[d + s] = new_dp[-d + s] = -1\n                    break\n                for d in [-d, d]:\n                    m = -1\n                    if dp[rods[i] + d + s] >= 0:\n                        m = max(m, dp[rods[i] + d + s] + rods[i])\n                    if dp[d - rods[i] + s] >= 0:\n                        m = max(m, dp[d - rods[i] + s])\n                    if dp[d + s] >= 0:\n                        m = max(m, dp[d + s])\n                    new_dp[d + s] = m\n            dp = new_dp\n        return dp[s]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n = len(rods)\n        rods.sort()\n        prefixsum = [0]\n        for i in rods:\n            prefixsum.append(prefixsum[-1] + i)\n        dp = {0: 0}\n        for i in range(n - 1, -1, -1):\n            new_dp = {}\n            for d in range(prefixsum[i] + 1):\n                if prefixsum[-1] - prefixsum[i] < d:\n                    break\n                for d in [-d, d]:\n                    a = max(dp.get(rods[i] + d, -rods[i] - 1) + rods[i], dp.get(d - rods[i], -1), dp.get(d, -1))\n                    if a != -1:\n                        new_dp[d] = a\n            dp = new_dp\n        return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n = len(rods)\n        rods.sort()\n        prefixsum = [0]\n        for i in rods:\n            prefixsum.append(prefixsum[-1] + i)\n        s = prefixsum[-1]\n        dp = {0: 0}\n        for i in range(n - 1, -1, -1):\n            new_dp = {}\n            for d in range(prefixsum[i] + 1):\n                if prefixsum[-1] - prefixsum[i] < d:\n                    break\n                for d in [-d, d]:\n                    m = -1\n                    a = dp.get(rods[i] + d, -1)\n                    if a >= 0:\n                        m = a + rods[i]\n                    new_dp[d] = max(m, dp.get(d - rods[i], -1), dp.get(d, -1))\n            dp = new_dp\n        return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        deltaBase = {0:0}\n        deltaList = [0]\n        rods.sort()\n        for rod in rods:\n            # print(deltaList)\n            # print(deltaBase)\n            deltaBaseTemp = deltaBase.copy()\n            iMax = len(deltaList)\n            for i in range(iMax):\n                delta = deltaList[i]\n                deltaPlus = delta+rod   \n                # print(rod, delta, deltaPlus)\n                if deltaPlus not in deltaBase:\n                    deltaList.append(deltaPlus)\n                    deltaBase[deltaPlus] = deltaBaseTemp[delta]\n                else:\n                    deltaBase[deltaPlus] = max(deltaBase[deltaPlus], deltaBaseTemp[delta])\n\n                \n                deltaMinus = delta-rod\n                if deltaMinus > 0:\n                    if deltaMinus not in deltaBase:\n                        deltaList.append(deltaMinus)\n                        deltaBase[deltaMinus] = deltaBaseTemp[delta]+ rod\n                    else:\n                        deltaBase[deltaMinus] = max(deltaBase[deltaMinus], deltaBaseTemp[delta]+ rod)\n                else:\n                    deltaMinus = -deltaMinus\n                    if deltaMinus not in deltaBase:\n                        deltaList.append(deltaMinus)\n                        deltaBase[deltaMinus] = deltaBaseTemp[delta]+ rod - deltaMinus\n                    else:\n                        deltaBase[deltaMinus] = max(deltaBase[deltaMinus], deltaBaseTemp[delta]+ rod - deltaMinus)\n        #         print(rod, delta, deltaMinus, deltaBaseTemp[delta]+ rod - deltaMinus)\n        # print(deltaList)\n        # print(deltaBase)\n        return deltaBase[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        d = defaultdict(lambda: -math.inf)\n        d[0] = 0\n        for r in rods:\n            e = d.copy()\n            for h in list(e.keys())[:]:\n                d[h+r], d[abs(h-r)] = max(e[h+2*r]+r, e[h+r], e[h] +\n                                          r), max(e[abs(h-r)], e[h]+r, e[abs(abs(h-r)-r)]+r)\n        return d[0]//2", "from collections import defaultdict\n\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        diff_to_longer_len = defaultdict(int)\n        diff_to_longer_len[0] = 0\n        \n        for new_L in rods:\n            tmp = defaultdict(int)\n            for delta_L, L in list(diff_to_longer_len.items()):\n                tmp[delta_L + new_L] = max(\n                    L + new_L,\n                    tmp[delta_L + new_L],\n                )\n                tmp[abs(delta_L - new_L)] = max(\n                    L,  # long\n                    L - delta_L + new_L,  # new short\n                    tmp[abs(delta_L - new_L)],\n                )\n\n            for delta_L, L in list(tmp.items()):\n                diff_to_longer_len[delta_L] = max(\n                    L,\n                    diff_to_longer_len[delta_L],\n                )\n\n        return diff_to_longer_len[0]\n", "import collections\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # for each number, there are three possible action, join set 1, join set 2, remove\n        recorder = {0: 0}\n        for rod in rods:\n            generateRecorder = collections.defaultdict(int)\n            for record in recorder:\n                largeNum = recorder[record]\n                generateRecorder[record] = max(generateRecorder[record], largeNum)\n                generateRecorder[record + rod] = max(generateRecorder[record + rod], largeNum + rod)\n                generateRecorder[abs(rod - record)] = max(generateRecorder[abs(rod - record)], max(largeNum, largeNum - record + rod))\n            recorder = generateRecorder\n        return recorder[0]", "class Solution(object):\n    def tallestBillboard(self, rods):\n        def make(A):\n            states = {(0, 0)}\n            for x in A:\n                states |= ({(a+x, b) for a, b in states} |\n                           {(a, b+x) for a, b in states})\n\n            delta = {}\n            for a, b in states:\n                delta[a-b] = max(delta.get(a-b, 0), a)\n            return delta\n\n        N = len(rods)\n        Ldelta = make(rods[:N//2])\n        Rdelta = make(rods[N//2:])\n\n        ans = 0\n        for d in Ldelta:\n            if -d in Rdelta:\n                ans = max(ans, Ldelta[d] + Rdelta[-d])\n        return ans", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n = len(rods)\n        rods.sort()\n        prefixsum = [0]\n        for i in rods:\n            prefixsum.append(prefixsum[-1] + i)\n        s = prefixsum[-1]\n        dp = [-1] * (s + 1) * 2\n        dp[s] = 0\n        for i in range(n - 1, -1, -1):\n            new_dp = [-1] * (s + 1) * 2\n            for d in range(-prefixsum[i], prefixsum[i] + 1):\n                m = -1\n                if prefixsum[-1] - prefixsum[i] < d:\n                    new_dp[d + s] = -1\n                    break\n                if dp[rods[i] + d + s] >= 0:\n                    m = max(m, dp[rods[i] + d + s] + rods[i])\n                if dp[d - rods[i] + s] >= 0:\n                    m = max(m, dp[d - rods[i] + s])\n                if dp[d + s] >= 0:\n                    m = max(m, dp[d + s])\n                new_dp[d + s] = m\n            dp = new_dp\n        return dp[s]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        if not rods:\n            return 0\n        \n        rods.sort()\n        l = len(rods)\n        \n        max_rods = sum(rods) / 2\n        \n        @lru_cache(maxsize=None)\n        def search(idx, diff):\n            if idx < 0:\n                if diff == 0:\n                    return True, 0\n                else:\n                    return False, 0\n            \n            f1, v1 = search(idx - 1, diff - rods[idx])\n            f2, v2 = search(idx - 1, diff + rods[idx])\n            \n            if f1 and f2:\n                return True, max(v1, v2) + rods[idx]\n            elif f1:\n                return True, v1 + rods[idx]\n            elif f2:\n                return True, v2 + rods[idx]\n            return search(idx - 1, diff)\n            \n        return search(l - 1, 0)[1] // 2\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        rods.sort(reverse=True)\n        n = len(rods)\n        dp = [0 for i in range(n)]\n        rsum = 0\n        self.result = 0\n        \n        for i in range(n-1, -1, -1):\n            rsum += rods[i]\n            dp[i] = rsum\n        \n        \n        def dfs(idx, lsum, rsum):\n            if idx >= n:\n                if lsum == rsum:\n                    self.result = max(self.result, lsum)\n                return\n            \n            if abs(lsum-rsum) >  dp[idx]:\n                return\n            if lsum+rsum+dp[idx] <= 2 * self.result:\n                return\n            \n            dfs(idx+1, lsum+rods[idx], rsum)\n            dfs(idx+1, lsum, rsum+rods[idx])\n            dfs(idx+1, lsum, rsum)\n            \n        dfs(0, 0, 0)\n        return self.result", "from collections import defaultdict\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        d = defaultdict(int)\n        d[0] = 0\n        for i in rods:\n            for sub, b in list(d.items()):\n                d[sub + i] = max(d[sub + i], b + i)\n                d[sub - i] = max(d[sub - i], b)\n        return d[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        if not rods:\n            return 0\n        \n        rods.sort()\n        l = len(rods)\n        \n        max_rods = sum(rods) / 2\n        \n        @lru_cache(maxsize=None)\n        def search(idx, diff):\n            if idx < 0:\n                if diff == 0:\n                    return True, 0\n                else:\n                    return False, 0\n            \n            f1, v1 = search(idx - 1, diff - rods[idx])\n            f2, v2 = search(idx - 1, diff + rods[idx])\n            \n            if f1 and f2:\n                return True, max(v1, v2) + rods[idx]\n            elif f1:\n                return True, v1 + rods[idx]\n            elif f2:\n                return True, v2 + rods[idx]\n            return search(idx - 1, diff)\n            \n        return search(l - 1, 0)[1] // 2", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        if not rods:\n            return 0\n        \n        rods.sort()\n        l = len(rods)\n        \n        max_rods = sum(rods) / 2\n        \n        @lru_cache(maxsize=None)\n        def search(idx, diff):\n            if idx < 0:\n                if diff == 0:\n                    return True, 0\n                else:\n                    return False, 0\n            \n            f1, v1 = search(idx - 1, diff - rods[idx])\n            f2, v2 = search(idx - 1, diff + rods[idx])\n            \n            if f1 and f2:\n                return True, max(v1, v2) + rods[idx]\n            elif f1:\n                return True, v1 + rods[idx]\n            elif f2:\n                return True, v2 + rods[idx]\n            return search(idx - 1, diff)\n            \n        return search(l - 1, 0)[1] // 2", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        if not rods:\n            return 0\n        \n        rods.sort()\n        l = len(rods)\n        \n        # max_rods = sum(rods) / 2\n        \n        @lru_cache(maxsize=None)\n        def search(idx, diff):\n            if idx < 0:\n                if diff == 0:\n                    return True, 0\n                else:\n                    return False, 0\n            \n            f1, v1 = search(idx - 1, diff - rods[idx])\n            f2, v2 = search(idx - 1, diff + rods[idx])\n            \n            if f1 and f2:\n                return True, max(v1, v2) + rods[idx]\n            elif f1:\n                return True, v1 + rods[idx]\n            elif f2:\n                return True, v2 + rods[idx]\n            return search(idx - 1, diff)\n            \n        return search(l - 1, 0)[1] // 2", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, d):\n            if i == n:\n                return 0 if d == 0 else -1\n            result = -1\n            a = dp(i + 1, rods[i] + d)\n            if a >= 0: result = max(result, a + rods[i])\n            a = dp(i + 1, d - rods[i])\n            if a >= 0: result = max(result, a)\n            a = dp(i + 1, d)\n            if a >= 0: result = max(result, a)\n            return result\n        n = len(rods)\n        rods.sort()\n        return dp(0, 0)\n", "from functools import lru_cache\n\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        @lru_cache(None)\n        def tallest_support_given_diff_of_pair(n, diff):\n            # max(L if (L, L - diff) can be built by rods[:n])\n            if n == 0:\n                return 0 if diff == 0 else float('-inf')\n\n            L = rods[n - 1]\n            no_new_rod = tallest_support_given_diff_of_pair(n - 1, diff)\n            if diff >= L:\n                new_rod_on_taller = tallest_support_given_diff_of_pair(\n                    n - 1,\n                    diff - L,\n                ) + L\n            else:  # diff < rods[n - 1]\n                new_rod_on_taller = tallest_support_given_diff_of_pair(\n                    n - 1,\n                    L - diff,\n                ) + diff\n\n            new_rod_on_shorter = tallest_support_given_diff_of_pair(n - 1, diff + L)\n            return max(no_new_rod, new_rod_on_taller, new_rod_on_shorter)\n\n        return tallest_support_given_diff_of_pair(len(rods), diff=0)\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        sums_lookup = {}\n        sums_lookup[0] = 0\n        for rod in rods:\n            newMembers = {}\n\n            for key in sums_lookup.keys():\n                value = sums_lookup[key]\n\n                if rod + key not in newMembers:\n                    newMembers[rod + key] = rod + value\n                else:\n                    if rod + value > newMembers[rod + key]:\n                        newMembers[rod + key] = rod + value\n\n                if key - rod not in newMembers:\n                    newMembers[key - rod] = value\n                else:\n                    if value > newMembers[key - rod]:\n                        newMembers[key - rod] = value\n\n                if key not in newMembers:\n                    newMembers[key] = value\n                else:\n                    if value > newMembers[key]:\n                        newMembers[key] = value\n\n            for key in newMembers.keys():\n                sums_lookup[key] = newMembers[key]\n\n        return sums_lookup[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        ## https://www.youtube.com/watch?v=WqLslW2sFxU\n        n = len(rods)\n        if n==0:\n            return 0\n        sum_ = sum(rods)\n        dp = [[-1 for j in range(sum_+1)] for i in range(n+1)]\n        dp[0][0] = 0\n        for i in range(n+1):\n            h = rods[i-1]\n            for j in range(sum_-h+1):\n                if dp[i-1][j]<0: continue ## invalid state\n                ## case 1: not used rods[i-1]\n                dp[i][j] = max(dp[i][j], dp[i-1][j])\n                ## case 2: add to the taller one\n                dp[i][j+h] = max(dp[i][j+h], dp[i-1][j])\n                ## case 3: add to the shorter one\n                dp[i][abs(j-h)] = max(dp[i][abs(j-h)], dp[i-1][j] + min(h, j))\n                \n                \n#         for i in range(n+1):\n#             print(dp[i])\n            \n        return dp[n][0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        n = len(rods)\n        rods.sort()\n        prefixsum = [0]\n        for i in rods:\n            prefixsum.append(prefixsum[-1] + i)\n        s = prefixsum[-1]\n        dp = [-1] * (s + 1) * 2\n        dp[s] = 0\n        for i in range(n - 1, -1, -1):\n            new_dp = [-1] * (s + 1) * 2\n            for d in range(-prefixsum[i], prefixsum[i] + 1):\n                m = -1\n                if prefixsum[-1] - prefixsum[i] < abs(d):\n                    new_dp[d + s] = -1\n                if dp[rods[i] + d + s] >= 0:\n                    m = max(m, dp[rods[i] + d + s] + rods[i])\n                if dp[d - rods[i] + s] >= 0:\n                    m = max(m, dp[d - rods[i] + s])\n                if dp[d + s] >= 0:\n                    m = max(m, dp[d + s])\n                new_dp[d + s] = m\n            dp = new_dp\n        return dp[s]\n", "from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # rods = sorted(rods)[::-1]\n        n = len(rods)\n        psum = rods.copy()\n        for i in range(n-1)[::-1]:\n            psum[i] += psum[i+1]\n\n        @lru_cache(None)\n        def dfs(idx, diff):\n            if idx == n:\n                return 0 if diff == 0 else -float('inf')\n            if diff > psum[idx]:\n                return -float('inf')\n            return max(dfs(idx+1,diff),dfs(idx+1,diff+rods[idx]),dfs(idx+1,abs(diff-rods[idx]))+min(diff,rods[idx]))\n        return dfs(0,0)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, d):\n            if i == n:\n                return d == 0, 0\n            result = 0\n            f, a = dp(i + 1, rods[i] + d)\n            if f: result = max(result, a + rods[i])\n            f, a = dp(i + 1, d - rods[i])\n            if f: result = max(result, a)\n            f, a = dp(i + 1, d)\n            if f: result = max(result, a)\n            return result != 0, result\n        \n        n = len(rods)\n        rods.sort()\n        return dp(0, 0)[1]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        m_sum = sum(rods)//2\n        m = [[-2 for i in range(m_sum+1)] for j in range(len(rods))]\n        def dfs(i,s1,s2):\n            if s1 > m_sum or s2 > m_sum:\n                return -1\n            if i==len(rods):\n                return s1 if s1==s2 else -1\n            if m[i][abs(s1-s2)]==-2:\n                m[i][abs(s1-s2)]=max(dfs(i+1,s1+rods[i],s2),dfs(i+1,s1,s2+rods[i]),dfs(i+1,s1,s2))-max(s1,s2)\n            return m[i][abs(s1-s2)]+(max(s1,s2) if m[i][abs(s1-s2)]!=-1 else 0)                \n        return max(0,dfs(0,0,0))", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = collections.defaultdict(lambda:0)\n        dp[0]=0\n        for rod in rods:\n            nextlevel = collections.defaultdict(lambda:0)\n            for key,val in list(dp.items()):\n                nextlevel[key+rod]=max(nextlevel[key+rod],val+rod)\n                nextlevel[key]= max(nextlevel[key],val)\n                nextlevel[key-rod]=max(nextlevel[key-rod],val+rod)\n            dp = nextlevel\n        return dp[0]//2\n                \n                \n\n        \n        \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp={0:0}\n        for r in rods:\n            newdp=collections.defaultdict(int)\n            for d in dp:\n                newdp[d+r]=max(newdp[d+r],dp[d]+r)\n                newdp[d]=max(newdp[d],dp[d])\n                newdp[d-r]=max(newdp[d-r],dp[d])\n            dp=newdp\n        return dp[0]", "from functools import lru_cache\n\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        \n        @lru_cache(None)\n        def tallest_support_given_diff_of_pair(n, diff):\n            # max(L if (L, L - diff) can be built by rods[:n])\n            if n == 0:\n                return 0 if diff == 0 else float('-inf')\n\n            L = rods[n - 1]\n            no_new_rod = tallest_support_given_diff_of_pair(n - 1, diff)\n            new_rod_on_taller = tallest_support_given_diff_of_pair(\n                n - 1,\n                abs(diff - L),\n            ) + min(diff, L)\n            new_rod_on_shorter = tallest_support_given_diff_of_pair(n - 1, diff + L)\n            return max(no_new_rod, new_rod_on_taller, new_rod_on_shorter)\n\n        return tallest_support_given_diff_of_pair(len(rods), diff=0)\n", "# 956. Tallest Billboard\n# version 2, inspired by the quote \\\"only the difference matters\\\".\n\ndef register (diffs, index, a):\n    if index not in diffs:\n        diffs[index] = a\n    else:\n        diffs[index] = max (diffs[index], a)\n\ndef get_height (rods):\n    diffs = {0: 0}\n    for rod in rods:\n        new_diffs = {}\n        for diff, a in diffs.items ():\n            register (new_diffs, diff, a)\n            register (new_diffs, diff + rod, a)\n            register (new_diffs, diff - rod, a + rod)\n        diffs = new_diffs\n\n    return diffs[0]\n             \nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        return get_height(rods)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = dict()\n        dp[0] = 0\n        for i in rods:\n            cur = collections.defaultdict(int)\n            for s in dp:\n                cur[s + i] = max(dp[s] + i,cur[s + i])\n                cur[s] = max(dp[s],cur[s])\n                cur[s-i] = max(dp[s],cur[s-i])\n            dp = cur\n        return dp[0]", "INF = 1 << 60\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = defaultdict(lambda:-INF)\n        dp[0] = 0\n        \n        for a in rods:\n            ndp = dp.copy()\n            for key, val in dp.items():\n                if abs(key + a) <= 5000:\n                    ndp[key + a] = max(ndp[key + a], dp[key] + a)\n                if abs(key - a) <= 5000:\n                    ndp[key - a] = max(ndp[key - a], dp[key] + a)\n            dp = ndp\n            \n        return dp[0] >> 1 if dp[0] >= 0 else 0", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        m = len(rods)\n        total = sum(rods)\n        dp = [[-1] * (5001) for _ in range(m + 1)]\n        dp[0][0] = 0\n        # dp[n][i]: means max common height we can achieve of using the first n elements that two\n        # piles have the hight difference of i\n        for i in range(1, m + 1):\n            h = rods[i - 1]\n            for j in range(5001 - h):\n                if dp[i - 1][j] < 0:\n                    continue\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                dp[i][j + h] = max(dp[i - 1][j], dp[i][j + h])\n                dp[i][abs(j - h)] = max(dp[i][abs(j - h)], dp[i - 1][j] + min(h, j))\n        \n        return dp[m][0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        m_sum=sum(rods)//2\n        m = [[-2 for i in range(m_sum+1)] for j in range(len(rods))]\n        def dfs(i,s1,s2):\n            if s1 > m_sum or s2 > m_sum:\n                return -1\n            if i==len(rods):\n                return s1 if s1==s2 else -1\n            if m[i][abs(s1-s2)]==-2:\n                m[i][abs(s1-s2)]=max(dfs(i+1,s1,s2),dfs(i+1,s1+rods[i],s2),dfs(i+1,s1,s2+rods[i]))-max(s1,s2)\n            return m[i][abs(s1-s2)]+(0 if m[i][abs(s1-s2)]==-1 else max(s1,s2))\n        return max(0,dfs(0,0,0))", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = dict()\n        dp[0] = 0\n        \n        for i in rods:\n            cur = collections.defaultdict(int)\n            for s in dp:\n                cur[s+i] = max(dp[s] + i, cur[s+i])\n                cur[s] = max(dp[s], cur[s])\n                cur[s-i] = max(dp[s], cur[s-i])\n                \n            dp = cur\n        return dp[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            return max(dp(i + 1, s),\n                       dp(i + 1, s - rods[i]),\n                       dp(i + 1, s + rods[i]) + rods[i])\n\n        return dp(0, 0)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        prefix = [0]\n        rods.sort(reverse=True)\n        for rod in rods:\n            prefix.append(prefix[-1]+rod)\n        @lru_cache(None)\n        def find(i, diff):\n            if i < 0:\n                return 0 if diff==0 else -float('inf')\n            if diff > prefix[-1]-prefix[i]:\n                return -float('inf')\n            return max(\n                find(i-1, diff-rods[i])+rods[i],\n                find(i-1, diff+rods[i]),\n                find(i-1, diff)\n            )\n        return find(len(rods)-1, 0)", "class Solution:\n    def tallestBillboard(self, rods):\n            sums_lookup = {0:0} # current sum is zero, length of left rod is 0\n            for rod in rods:\n                cur = collections.defaultdict(int)\n                # consider 3 cases. Rod is aded to the left bucket, rod is added to the right\n                # bucket rod is discarded. In all three cases, update length of the left support\n                # beam, however, if new sum already exists, make sure we keep the one\n                # with longest left support.\n                for current_sum, left_support_length in sums_lookup.items():\n                    # add rod to the left bucket. Sum will increase since left bucket is \n                    # represented by positive numbers. Left support beam is longer now\n                    cur[current_sum+rod] = max(left_support_length + rod, cur[current_sum+rod])\n                    # add rod to the right bucket. Sum will decrease since right bucket is\n                    # represented by negative numbers. Left support beam is unchanged.\n                    cur[current_sum-rod] = max(left_support_length, cur[current_sum-rod])\n                    # discard rod. Sum and left support beam is unchanged\n                    cur[current_sum] = max(left_support_length, cur[current_sum])\n                sums_lookup = cur\n            # our goal is to find sum of all elements in the representation array,\n            # that adds up to 0, meaning sum of positivel rods (left bucket) is equal to \n            # sum of all negative rods (right bucket)\n            return sums_lookup[0]", "from collections import defaultdict\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        memo = defaultdict(int)\n        memo[0] = 0\n        \n        for rod in rods:\n            temp_memo = defaultdict(int)\n            keys = list(memo.keys())\n            for k in keys:\n                temp_memo[k + rod] = max(memo[k] + rod, temp_memo[k + rod])\n                temp_memo[k - rod] = max(memo[k], temp_memo[k - rod])\n                temp_memo[k] = max(memo[k], temp_memo[k])\n            memo.update(temp_memo)\n        return memo[0]\n                \n        \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        # print(rods)\n        dp = {0: 0}\n        for rod in rods:\n            cur = dp.copy()\n            for k, v in dp.items():\n                cur[k + rod] = max(v + rod, cur.get(k+rod, 0))\n                cur[k - rod] = max(v, cur.get(k-rod, 0))\n                cur[k] = max(v, cur.get(k, 0))\n            dp = cur\n        # print(dp)\n        return dp[0]", "from collections import defaultdict\nfrom copy import copy\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        memo = defaultdict(int)\n        memo[0] = 0\n        \n        for rod in rods:\n            temp_memo = defaultdict(int)\n            keys = list(memo.keys())\n            for k in keys:\n                temp_memo[k + rod] = max(memo[k] + rod, temp_memo[k + rod])\n                temp_memo[k - rod] = max(memo[k], temp_memo[k - rod])\n                temp_memo[k] = max(memo[k], temp_memo[k])\n            memo.update(temp_memo)\n        return memo[0]\n                \n        \n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def solve(i: int, s: int) -> int:            \n            if i >= len(rods):\n                return 0 if s == 0 else -math.inf\n            \n            return max(solve(i + 1, s), solve(i + 1, s - rods[i]), rods[i] + solve(i + 1, s + rods[i]))\n        \n        return 0 if math.isinf(res := solve(0, 0)) else res", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = collections.defaultdict(int)\n        dp[0]=0\n        for rod in rods:\n            nextlevel = collections.defaultdict(int)\n            for key,val in list(dp.items()):\n                nextlevel[key+rod]=max(nextlevel[key+rod],val+rod)\n                nextlevel[key]=max(nextlevel[key],val)\n                nextlevel[key-rod]=max(nextlevel[key-rod],val+rod)\n            dp=nextlevel\n        return dp[0]//2\n", "from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            return max(dp(i+1, s),\n                       dp(i+1, s - rods[i]),\n                       dp(i+1, s+rods[i]) + rods[i])\n        return dp(0, 0)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            return max(dp(i + 1, s),\n                       dp(i + 1, s - rods[i]),\n                       dp(i + 1, s + rods[i]) + rods[i])\n\n        return dp(0, 0)\n", "from functools import lru_cache\nclass Solution:\n    def tallestBillboard(self, rods):\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            return max(dp(i + 1, s),\n                       dp(i + 1, s - rods[i]),\n                       dp(i + 1, s + rods[i]) + rods[i])\n\n        return dp(0, 0)\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = defaultdict(int)\n        dp[0] = 0\n        for rod in rods:\n            for dif, hi in list(dp.items()):\n                lo = hi - dif\n                ndif = abs(rod - dif)\n                dp[ndif] = max(dp[ndif], hi, lo + rod)\n                ndif = rod + dif\n                dp[ndif] = max(dp[ndif], rod + hi) \n        return dp[0]", "class Solution:\n    def tallestBillboard(self, rods):\n        dp = dict()\n        dp[0] = 0\n        \n        for i in rods:\n            cur = collections.defaultdict(int)\n            for s in dp:\n                cur[s+i] = max(dp[s] + i, cur[s+i])\n                cur[s] = max(dp[s], cur[s])\n                cur[s-i] = max(dp[s], cur[s-i])\n            dp = cur\n        return dp[0]", "from functools import lru_cache\nimport math\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def search(i: int, d: int) -> int:\n            if i == 0:\n                return 0 if d == 0 else -math.inf\n            ans = max(search(i - 1, d), search(i - 1, d + rods[i - 1]) + rods[i - 1])\n            if rods[i - 1] <= d:\n                ans = max(ans, search(i - 1, d - rods[i - 1]))\n            if rods[i - 1] >= d:\n                ans = max(ans, search(i - 1, rods[i - 1] - d) + rods[i - 1] - d)\n            return ans\n        \n        return search(len(rods), 0)", "class Solution:\n    def tallestBillboard(self, rods):\n        @lru_cache(None)\n        def dp(i, s):\n            if i == len(rods):\n                return 0 if s == 0 else float('-inf')\n            # We can either use the rod, give it to the left, or give it to the right\n            return max(dp(i + 1, s),\n                       dp(i + 1, s - rods[i]) + rods[i],\n                       dp(i + 1, s + rods[i]) + rods[i])\n\n        return int(dp(0, 0)/2)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = {}\n        dp[0] = 0\n        \n        for i in rods:\n            cur = collections.defaultdict(int)\n            for s in dp:\n                cur[s+i] = max(dp[s] + i, cur[s+i])\n                cur[s] = max(dp[s], cur[s])\n                cur[s-i] = max(dp[s], cur[s-i])\n            dp = cur\n        return dp[0]\n        \n        \n#         total = sum(rods)\n#         n = len(rods)\n#         m = total // 2\n#         dp = [0] * (m + 1)\n#         for i in range(n):\n#             for j in range(m, rods[i] - 1, -1):\n#                 dp[j] = max(dp[j], dp[j - rods[i]] + rods[i])\n#         print(dp)\n", "import copy\nfrom collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        dp = defaultdict(int)\n        dp[0] = 0\n        for v in rods:\n            dp_ = copy.deepcopy(dp)\n            for diff, max_v in list(dp.items()):\n                dp_[diff + v] = max(dp_[diff+v], dp[diff])\n\n                dp_[abs(diff - v)] = max(dp_[abs(diff-v)], max_v + min(diff,v))\n\n            dp = dp_\n        return dp[0]\n", "from collections import defaultdict \nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n      dp = {0: 0}\n      \n      for rod in rods:\n        currents = collections.defaultdict(int)\n        for diff in dp:\n          currents[diff + rod] = max(dp[diff] + rod, currents[diff + rod])\n          currents[diff] = max(dp[diff], currents[diff])\n          currents[diff - rod] = max(dp[diff], currents[diff - rod])\n        dp = currents\n      \n      return dp[0]", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        deltaBase = {0:0}\n        deltaList = [0]\n        for rod in rods:\n            deltaBaseTemp = deltaBase.copy()\n            iMax = len(deltaList)\n            for i in range(iMax):\n                delta = deltaList[i]\n                deltaPlus = delta+rod   \n                if deltaPlus not in deltaBase:\n                    deltaList.append(deltaPlus)\n                    deltaBase[deltaPlus] = deltaBaseTemp[delta]\n                else:\n                    deltaBase[deltaPlus] = max(deltaBase[deltaPlus], deltaBaseTemp[delta])\n                \n                deltaMinus = delta-rod\n                if deltaMinus > 0:\n                    if deltaMinus not in deltaBase:\n                        deltaList.append(deltaMinus)\n                        deltaBase[deltaMinus] = deltaBaseTemp[delta]+ rod\n                    else:\n                        deltaBase[deltaMinus] = max(deltaBase[deltaMinus], deltaBaseTemp[delta]+ rod)\n                else:\n                    deltaMinus = -deltaMinus\n                    if deltaMinus not in deltaBase:\n                        deltaList.append(deltaMinus)\n                        deltaBase[deltaMinus] = deltaBaseTemp[delta]+ rod - deltaMinus\n                    else:\n                        deltaBase[deltaMinus] = max(deltaBase[deltaMinus], deltaBaseTemp[delta]+ rod - deltaMinus)\n        return deltaBase[0]", "from collections import defaultdict\n\n\nclass Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        diff_to_longer_len = defaultdict(int)\n        diff_to_longer_len[0] = 0\n        \n        def replace_if_larger(dct, key, val):\n            dct[key] = max(val, dct[key])\n\n        for new_L in rods:\n            tmp = defaultdict(int)\n            for dL, L in list(diff_to_longer_len.items()):\n                # there are L and L - dL\n                # |(new_L + L) - (L - dL)| = new_L + dL\n                replace_if_larger(tmp, new_L + dL, new_L + L)\n                # |(new_L + L - dL) - L| = |new_L - dL|\n                replace_if_larger(tmp, abs(new_L - dL), max(L, new_L + L - dL))\n\n            for dL, L in list(tmp.items()):\n                replace_if_larger(diff_to_longer_len, dL, L)\n\n        return diff_to_longer_len[0]\n", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        @lru_cache(None)\n        def find(i, diff):\n            if i < 0:\n                return 0 if diff==0 else -float('inf')\n            return max(\n                find(i-1, diff-rods[i])+rods[i],\n                find(i-1, diff+rods[i]),\n                find(i-1, diff)\n            )\n        return find(len(rods)-1, 0)", "class Solution:\n    def tallestBillboard(self, rods: List[int]) -> int:\n        prefix = [0]\n        rods.sort()\n        for rod in rods:\n            prefix.append(prefix[-1]+rod)\n        @lru_cache(None)\n        def find(i, diff):\n            if i < 0:\n                return 0 if diff==0 else -float('inf')\n            if diff > prefix[-1]-prefix[i]:\n                return -float('inf')\n            return max(\n                find(i-1, diff-rods[i])+rods[i],\n                find(i-1, diff+rods[i]),\n                find(i-1, diff)\n            )\n        return find(len(rods)-1, 0)"]
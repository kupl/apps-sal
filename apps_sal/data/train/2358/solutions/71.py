#!/usr/bin/env python3
import sys


def solve(x_s: int, y_s: int, x_t: int, y_t: int, N: int, x: "List[int]", y: "List[int]", r: "List[int]"):
    import numpy as np
    from scipy.sparse import csr_matrix, coo_matrix
    from scipy.sparse.csgraph import dijkstra
    x.extend([x_s, x_t])
    y.extend([y_s, y_t])
    r.extend([0, 0])
    p = np.column_stack((x, y))
    diff = np.expand_dims(p, axis=1) - np.expand_dims(p, axis=0)
    dist = np.sqrt(np.sum(diff ** 2, axis=-1))
    mat = ((dist - r).T - r).clip(min=1e-20)    
    return '{:.10f}'.format(dijkstra(csr_matrix(mat), indices=N)[N+1])

# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    x_s = int(next(tokens))  # type: int
    y_s = int(next(tokens))  # type: int
    x_t = int(next(tokens))  # type: int
    y_t = int(next(tokens))  # type: int
    N = int(next(tokens))  # type: int
    x = [int()] * (N)  # type: "List[int]"
    y = [int()] * (N)  # type: "List[int]"
    r = [int()] * (N)  # type: "List[int]"
    for i in range(N):
        x[i] = int(next(tokens))
        y[i] = int(next(tokens))
        r[i] = int(next(tokens))
    print((solve(x_s, y_s, x_t, y_t, N, x, y, r)))

def test():
    import doctest
    doctest.testmod()

def __starting_point():
    #test()
    main()

__starting_point()

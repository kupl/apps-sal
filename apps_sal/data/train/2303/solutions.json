["#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\nINF = 10**9\n\nn, m = map(int, input().split())\npqc = []\n\nseen = set()\nfor i in range(n):\n    seen.add((i, 0))\nfor _ in range(m):\n    p, q, c = map(int, input().split())\n    p -= 1; q -= 1\n    pqc.append((p, q, c))\n    seen.add((p, c))\n    seen.add((q, c))\ncomp = dict()\nfor i, node in enumerate(seen):\n    comp[node] = i\n\nedge = [[] for _ in range(len(comp))]\nfor key in comp.keys():\n    v, c = key\n    if c != 0:\n        frm = comp[(v, c)]\n        too = comp[(v, 0)]\n        edge[frm].append((too, 0))\n        edge[too].append((frm, 1))\n\nfor p, q, c in pqc:\n    frm = comp[(p, c)]\n    too = comp[(q, c)]\n    edge[frm].append((too, 0))\n    edge[too].append((frm, 0))\n\nclass BFS:\n    def __init__(self, adj):\n        self.adj = adj\n        self.dist = [INF] * len(adj)\n        self.q = deque()\n\n    def calc(self, start):\n        self.dist[start] = 0\n        self.q.append((0, start))\n        while len(self.q) != 0:\n            prov_cost, src = self.q.popleft()\n            if self.dist[src] < prov_cost:\n                continue\n            for dest, cost in self.adj[src]:\n                if self.dist[dest] > self.dist[src] + cost:\n                    self.dist[dest] = self.dist[src] + cost\n                    if cost == 1:\n                        self.q.append((self.dist[dest], dest))\n                    else:\n                        self.q.appendleft((self.dist[dest], dest))\n        return self.dist\n\nbfs = BFS(edge)\nbfs.calc(comp[(0, 0)])\nans = bfs.dist[comp[(n-1, 0)]]\nif ans == INF:\n    print(-1)\nelse:\n    print(ans)", "from collections import deque\nN, M = map(int, input().split())\nF_C_of_S = [{} for i in range(N)]\n#Companies of Station\nC_of_S = {}\n\n#def Union-find\nparent = [-1]*M\ndef root(x):\n\tif (parent[x] < 0): return x\n\telse:\n\t\tparent[x] = y = root(parent[x])\n\t\treturn y\n\ndef unite(x, y):\n\tpx = root(x)\n\tpy = root(y)\n\tif (px == py): return False\n\tif (parent[px] > parent[py]):\n\t\tpx = root(y)\n\t\tpy = root(x)\n\tparent[px] += parent[py]\n\tparent[py] = px\n\treturn True\n\n\n#Union-find\npqcs = []\nfor i in range(M):\n\tp, q, c = map(int, input().split())\n\tp -= 1; q -= 1;\n\tpqcs += [(p, q, c)]\n\t\n\t#The first\n\tif not c in F_C_of_S[p]: F_C_of_S[p][c] = i\n\t#else\n\telse: unite(F_C_of_S[p][c], i)\n\tC_of_S.setdefault(p, set()).add(c)\n\t\n\t#The first\n\tif not (c in F_C_of_S[q]):F_C_of_S[q][c] = i\n\t#else\n\telse: unite(F_C_of_S[q][c], i)\n\tC_of_S.setdefault(q, set()).add(c)\n\n#stations of company\nS_of_C = {}\nfor i in range(M):\n\tp, q, c = pqcs[i]\n\tc_set = S_of_C.setdefault(root(i), set())\n\tc_set.add(p)\n\tc_set.add(q)\n\n\nQ = deque([(0, 0, 0)])\n#cost to go to the stations from station_0\ndist = [float('inf')]*N\ndist[0] = 0\n\ngdist = [float('inf')]*M\n\nwhile Q:\n\tcost, v, flag = Q.popleft()\n\t\n\tif not (flag):#(flag == 0) then gdist_update\n\t\tif (dist[v] < cost) or (v not in C_of_S):\n\t\t\tcontinue\n\t\tfor l in F_C_of_S[v].values():\n\t\t\tl = root(l)\n\t\t\tif (cost < gdist[l]):\n\t\t\t\tgdist[l] = cost\n\t\t\t\tQ.appendleft((cost, l, 1))\n\t\n\telse:#(flag == 1) then dist_update\n\t\tif (gdist[v] < cost) or (v not in S_of_C):\n\t\t\tcontinue\n\t\tfor s in S_of_C[v]:\n\t\t\tif (cost+1 < dist[s]):\n\t\t\t\tdist[s] = cost+1\n\t\t\t\tQ.append((cost+1, s, 0))\n\nprint(dist[N - 1] if dist[N - 1] < float('inf') else -1)", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,m = list(map(int, readline().split()))\n\ng = {}\n\nfor _ in range(m):\n    p,q,c = list(map(int, readline().split()))\n    pc = ((p-1)<<20)+c\n    qc = ((q-1)<<20)+c\n    pp = (p-1)<<20\n    qq = (q-1)<<20\n    \n    if pc not in g: g[pc] = []\n    if qc not in g: g[qc] = []\n    if pp not in g: g[pp] = []\n    if qq not in g: g[qq] = []\n    \n    g[pc].append(qc)\n    g[pc].append(pp)\n\n    g[qc].append(pc)\n    g[qc].append(qq)\n\n    g[pp].append(pc)\n    g[qq].append(qc)\n\nif 0 not in g: g[0] = []\n\nfrom collections import deque\nq = deque([(0,0)])\nres = {0:0}\n\nmask = (1<<20)-1\nwhile q:\n    vl,dv = q.popleft()\n    if res[vl] < dv: continue\n    if (vl>>20) == n-1:\n        res[(n-1)<<20] = dv+1\n        break\n    for tl in g[vl]:\n        ndv = dv + (vl&mask==0 or tl&mask==0)\n        if tl not in res or res[tl] > ndv:\n            res[tl] = ndv\n            if vl&mask==0 or tl&mask==0:\n                q.append((tl,ndv))\n            else:\n                q.appendleft((tl,ndv))\n\nif (n-1)<<20 in res:\n    print((res[(n-1)<<20]//2))\nelse:\n    print((-1))\n\n\n\n\n", "import sys\nreadline = sys.stdin.readline\n\nfrom heapq import heappop as hpp, heappush as hp\ninf = 10**9+7\ndef dijkstra(N, s, Edge):    \n    dist = [inf] * N\n    dist[s] = 0\n    Q = [(0, s)]\n    while Q:\n        dn, vn = hpp(Q)\n        if dn > dist[vn]:\n            continue\n        for df, vf in Edge[vn]:\n            if dn + df < dist[vf]:\n                dist[vf] = dn + df\n                hp(Q, (dn + df,vf))\n    return dist\n\ndef compress(L):\n    L2 = list(set(L))\n    L2.sort()\n    C = {v : k for k, v in enumerate(L2)}\n    return L2, C\n\n\nN, M = map(int, readline().split())\n\nEdge = []\nVS = set(range(N))\ngeta = 20\nEdge = [tuple(map(int, readline().split())) for _ in range(M)]\nfor a, b, c in Edge:\n    a -= 1\n    b -= 1\n    VS |= {(c<<geta) | a, (c<<geta) | b}\n   \n_, Cv = compress(list(VS))\n\nVnum = len(Cv)\n\nnEdge = [[] for _ in range(Vnum)]\n\nfor a, b, c in Edge:\n    a -= 1\n    b -= 1\n    ca = Cv[(c<<geta) | a]\n    cb = Cv[(c<<geta) | b]\n    nEdge[ca].append((0, cb))\n    nEdge[cb].append((0, ca))\n    nEdge[a].append((1, ca))\n    nEdge[ca].append((0, a))\n    nEdge[b].append((1, cb))\n    nEdge[cb].append((0, b))\n\ndist = dijkstra(Vnum, 0, nEdge)\nif dist[N-1] >= inf:\n    dist[N-1] = -1\nprint(dist[N-1])  ", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**5) \n \ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import defaultdict, deque\n\n# \u5165\u529b\u30fb\u96a3\u63a5\u30ea\u30b9\u30c8\u4f5c\u6210\nn,m = li()\ngraph = defaultdict(set)\ngeta = pow(10,7)\n\nfor _ in range(m):\n    p,q,c = li()\n    \n    graph[p + c*geta].add(q + c*geta)\n    graph[q + c*geta].add(p + c*geta)\n    \n    graph[p + c*geta].add(p)\n    graph[q + c*geta].add(q)\n    \n    graph[p].add(p + c*geta)\n    graph[q].add(q + c*geta)\n    \nque = deque()\nque.append((0, 1))\nvisited = set()\n\nans = -1\n\nwhile que:\n    (cost, node) = que.popleft()\n    \n    if node in visited:\n        continue\n    \n    elif node % geta == n:\n        ans = cost\n        break\n    \n    visited.add(node)\n    \n    \n    for nex in graph[node]:\n        if nex in visited:\n            continue\n        \n        elif node <= n and nex > n:\n            que.append((cost+1, nex))\n            \n        else:\n            que.appendleft((cost, nex))\n    \nprint(ans)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nN, M = map(int, input().split())\nX = []\nC = [set() for _ in range(N)]\nfor _ in range(M):\n    p, q, c = [int(a) - 1 for a in input().split()]\n    X.append((p, q, c))\n    C[p].add(c)\n    C[q].add(c)\nfor i, c in enumerate(C):\n    C[i] = list(c)\n\nI = [N]\nD = [{} for _ in range(N)]\nfor i, c in enumerate(C):\n    for j, a in enumerate(c):\n        D[i][a] = I[-1] + j\n    I.append(I[-1] + len(c))\n\nT = I[-1]\nE = [[] for _ in range(T)]\nfor p, q, c in X:\n    E[D[p][c]].append((D[q][c], 0))\n    E[D[q][c]].append((D[p][c], 0))\nfor i, c in enumerate(C):\n    for j, a in enumerate(c):\n        E[i].append((D[i][a], 1))\n        E[D[i][a]].append((i, 1))\n\ndef BFS01(n, E, i0=0):\n    Q = deque([i0])\n    D = [-1] * n\n    D[i0] = 0\n    while Q:\n        x = Q.popleft()\n        for y, w in E[x]:\n            if w:\n                if D[y] == -1:\n                    D[y] = D[x] + 1\n                    Q.append(y)\n            else:\n                if D[y] == -1 or D[y] < D[x]:\n                    D[y] = D[x]\n                    Q.appendleft(y)\n    return D\n\nD = BFS01(T, E, 0)\nprint(D[N-1] // 2)", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(10000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef bfs01(g, s):\n    d = {}\n    for v in g.keys():\n        d[v] = sys.maxsize\n    d[s] = 0\n\n    if s not in d:\n        return d\n    q = deque()\n    q.append((d[s], s))\n\n    NM = 1 << 30\n    while q:\n        _, u = q.popleft()\n        for v in g[u]:\n            if v > NM:\n                c = 0\n            else:\n                c = 1\n            alt = c + d[u]\n            if d[v] > alt:\n                d[v] = alt\n                if c == 0:\n                    q.appendleft((d[v], v))\n                else:\n                    q.append((d[v], v))\n    return d\n\n\n@mt\ndef slv(N, M):\n\n    g = defaultdict(list)\n    NM = 30\n    for _ in range(M):\n        p, q, c = input().split()\n        p = int(p)\n        q = int(q)\n        c = int(c)\n\n        cp = (c << NM) + p\n        cq = (c << NM) + q\n        g[cp].append(cq)\n        g[cq].append(cp)\n        g[cp].append(p)\n        g[cq].append(q)\n        g[p].append((cp))\n        g[q].append((cq))\n\n    d = bfs01(g, 1)\n    return -1 if N not in d or d[N] == sys.maxsize else d[N]\n\n\ndef main():\n    N, M = read_int_n()\n\n    print(slv(N, M))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys,heapq\nfrom collections import defaultdict,deque\n\ninput = sys.stdin.readline\nn,m = map(int,input().split())\n#+\u8def\u7dda*chg : \u305d\u306e\u8def\u7dda\u30db\u30fc\u30e0\nchg = 10**6\n\nedge=defaultdict(set)\nused =defaultdict(bool)\nfor i in range(m):\n    p,q,c = map(int,input().split())\n    edge[p].add(p+c*chg)\n    edge[p+c*chg].add(p)\n    edge[p+c*chg].add(q+c*chg)\n    edge[q+c*chg].add(p+c*chg)\n    edge[q].add(q+c*chg)\n    edge[q+c*chg].add(q)\n    used[p] = False\n    used[q] = False\n    used[p+c*chg] = False\n    used[q+c*chg] = False\n\nedgelist = deque()\nedgelist.append((1,0))\nres = float(\"inf\")\n\nwhile len(edgelist):\n    x,cost = edgelist.pop()\n    used[x] = True\n\n    if x == n:\n        res = cost\n        break\n    for e in edge[x]:\n        if used[e]:\n            continue\n        #\u30db\u30fc\u30e0\u2192\u6539\u672d\n        if x <= 10**5 and chg <= e:\n            edgelist.appendleft((e,cost+1))\n        else:\n            edgelist.append((e,cost))\n        \nif res == float(\"inf\"):\n    print(-1)\nelse:\n    print(res)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\n    def tall(self):\n        d = collections.defaultdict(list)\n        for i in range(len(self.table)):\n            d[self.find(i)].append(i)\n        return d\n\ndef main():\n    M = 2**17\n    n,m = LI()\n    a = [LI() for _ in range(m)]\n    e = collections.defaultdict(list)\n    for p,q,c in a:\n        pc = p+c*M\n        qc = q+c*M\n        pm = p-M\n        qm = q-M\n        e[pc].append(qc)\n        e[qc].append(pc)\n        e[pm].append(pc)\n        e[qm].append(qc)\n        e[pc].append(pm)\n        e[qc].append(qm)\n\n    def search():\n        d = collections.defaultdict(lambda: inf)\n        s = 1-M\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = set()\n        while len(q):\n            k, u = heapq.heappop(q)\n            if u in v:\n                continue\n            v.add(u)\n            if u < 0:\n                for uv in e[u]:\n                    if uv in v:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            else:\n                if u % M == n:\n                    return k\n\n                for uv in e[u]:\n                    if uv in v:\n                        continue\n                    if d[uv] > k:\n                        d[uv] = k\n                        heapq.heappush(q, (k, uv))\n\n        return -1\n\n    return search()\n\n\n\nprint(main())\n", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(10000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef bfs01(g, s):\n    d = {}\n    for v in g.keys():\n        d[v] = sys.maxsize\n    d[s] = 0\n\n    if s not in d:\n        return d\n    q = deque()\n    q.append((d[s], s))\n\n    NM = 1 << 30\n    while q:\n        _, u = q.popleft()\n        for v in g[u]:\n            if v > NM:\n                c = 0\n            else:\n                c = 1\n            alt = c + d[u]\n            if d[v] > alt:\n                d[v] = alt\n                if c == 0:\n                    q.appendleft((d[v], v))\n                else:\n                    q.append((d[v], v))\n    return d\n\n\n@mt\ndef slv(N, M):\n\n    g = defaultdict(list)\n    NM = 30\n    for _ in range(M):\n        p, q, c = input().split()\n        p = int(p)\n        q = int(q)\n        c = int(c)\n\n        cp = (c << NM) + p\n        cq = (c << NM) + q\n        g[cp].append(cq)\n        g[cq].append(cp)\n        g[cp].append(p)\n        g[cq].append(q)\n        g[p].append((cp))\n        g[q].append((cq))\n\n    d = bfs01(g, 1)\n    return -1 if N not in d or d[N] == sys.maxsize else d[N]\n\n\ndef main():\n    N, M = read_int_n()\n\n    print(slv(N, M))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque,defaultdict\nimport sys\ninput = sys.stdin.readline\nN,M=map(int,input().split())\nmod =10**7\ntable=defaultdict(set)\nvisit=defaultdict(int)\nfor i in range(M):\n    a,b,c=map(int,input().split())\n    table[a].add(a+c*mod)\n    table[b].add(b+c*mod)\n    table[a+c*mod].add(a)\n    table[b+c*mod].add(b)\n    table[a+c*mod].add(b+c*mod)\n    table[b+c*mod].add(a+c*mod)\n    visit[a]=0\n    visit[b]=0\n    visit[b+c*mod]=0\n    visit[a+c*mod]=0\n\nH=deque()\nH.append((1,0))\nvisit[1]=1\nans=mod\nwhile H:\n    #print(H)\n    x,cost=H.popleft()\n    visit[x] = 1\n    if x==N:\n        ans=min(ans,cost)\n        break\n    for y in table[x]:\n        if visit[y]==1:\n            continue\n        if x<=10**5 and mod<=y:\n            H.append((y,cost+1))\n        else:\n            H.appendleft((y,cost))\nif ans==mod:\n    print(-1)\nelse:\n    print(ans)", "N, M = list(map(int, input().split()))\nES = []\nD = {}\n\n*parent, = list(range(M))\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = y = root(parent[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\n\nE = {}\nfor i in range(M):\n    p, q, c = list(map(int, input().split())); p -= 1; q -= 1\n    ES.append((p, q, c))\n    if (p, c) in D:\n        unite(D[p, c], i)\n    D[p, c] = i\n    E.setdefault(p, set()).add(c)\n    if (q, c) in D:\n        unite(D[q, c], i)\n    D[q, c] = i\n    E.setdefault(q, set()).add(c)\n#P = [[] for i in range(M)]\nP = {}\nfor i in range(M):\n    j = root(i)\n    p, q, c = ES[i]\n    s = P.setdefault(j, set())\n    s.add(p); s.add(q)\n\nfrom collections import deque\nque = deque([(0, 0, 0)])\nINF = 10**18\ndist = [INF]*N\ndist[0] = 0\ngdist = [INF]*M\n\nwhile que:\n    cost, v, t = que.popleft()\n    if t:\n        # edge\n        if gdist[v] < cost or v not in P:\n            continue\n        for w in P[v]:\n            if cost + 1 < dist[w]:\n                dist[w] = cost + 1\n                que.append((cost + 1, w, 0))\n    else:\n        # node\n        if dist[v] < cost or v not in E:\n            continue\n        for c in E[v]:\n            w = root(D[v, c])\n            if cost < gdist[w]:\n                gdist[w] = cost\n                que.appendleft((cost, w, 1))\n\nprint((dist[N-1] if dist[N-1] < INF else -1))\n", "def dijkstra_heap(s,edge,mask):\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = [s]  # 0 \u304c\u4f1a\u793e\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\u72b6\u614b\n    dist[s] = 0\n    d = 0; q0 = []; q1 = []\n    while q:\n        for x in q:\n            if x & mask == 0:\n                for y in edge[x]:\n                    if dist[y[1]] <= d + y[0]:\n                        continue\n                    dist[y[1]] = d + y[0]\n                    q1.append(y[1])\n            else:\n                for y in edge[x]:\n                    if dist[y[1]] <= d:\n                        continue\n                    dist[y[1]] = d\n                    q0.append(y[1])\n        if q0:\n            q = q0\n            q0 = []\n            continue\n        q = q1\n        q1 = []\n        d += 1\n    return dist\n\ndef examE(inf):\n    N, M = LI()\n    edge = defaultdict(list)\n    # edge[i] : i\u304b\u3089\u51fa\u308b\u9053\u306e[\u91cd\u307f,\u884c\u5148]\u306e\u914d\u5217\n    L = 32\n    Mask = (1 << L) - 1\n    for i in range(M):\n        p, q, c = list(map(int, input().split()))\n        p -=1; q -=1\n        p <<= L\n        q <<= L\n        edge[p].append((1,p + c))\n        edge[p + c].append((0,p))\n        edge[q].append((1,q + c))\n        edge[q + c].append((0,q))\n        #\u540c\u3058\u8def\u7dda\u3060\u3068\u30b3\u30b9\u30c8\uff10\n        edge[p + c].append((0,q + c))\n        edge[q + c].append((0,p + c))\n    start = 0\n    goal = (N-1) << L\n    res = dijkstra_heap(start, edge, Mask)\n#    print(res)\n    ans = res[goal]\n    if ans == inf:\n        ans = -1\n    print(ans)\n\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\nmod = 10**9 + 7\ninf = float('inf')\n\nexamE(inf)\n", "def main():\n  from heapq import heappush,heappop,heapify\n  inf=2**31-1\n  n,m,*t=map(int,open(0).read().split())\n  z=[]\n  for a,b,c in zip(t[::3],t[1::3],t[2::3]):\n    z.extend([a,b,a+n*c,b+n*c])\n  z={i:v for v,i in enumerate(sorted(set(z)))}\n  try:\n    z[1]\n  except:\n    print(-1)\n    return\n  edge=[[]for _ in range(len(z))]\n  d={}\n  l=[]\n  for a,b,c in zip(t[::3],t[1::3],t[2::3]):\n    if b<a:a,b=b,a\n    i,j,x,y=z[a],z[b],z[a+n*c],z[b+n*c]\n    if b==n:\n      l.append(y)\n    edge[i].append((1,x))\n    edge[j].append((1,y))\n    edge[x].extend([(0,i),(0,y)])\n    edge[y].extend([(0,j),(0,x)])\n  used=[False]+[True]*~-len(z)\n  d=[0]+[inf]*~-len(z)\n  edgelist=edge[0]\n  heapify(edgelist)\n  while edgelist:\n    m=heappop(edgelist)\n    if not used[m[1]]:\n      continue\n    d[m[1]]=m[0]\n    used[m[1]]=False\n    for e in edge[m[1]]:\n      if used[e[1]]:\n        heappush(edgelist,(e[0]+m[0],e[1]))\n  a=min([d[i]for i in l]or[inf])\n  print([a,-1][a==inf])\ndef __starting_point():\n  main()\n__starting_point()", "from collections import defaultdict\nfrom collections import deque\n\nN, M = list(map(int, input().split()))\n\nchg = 10**6\nG = defaultdict(set)\nfor _ in range(M):\n    p, q, c = list(map(int, input().split()))\n    # \u7121\u5411\u30b0\u30e9\u30d5\n    G[p].add(p+chg*c)\n    G[p+chg*c].add(p)\n    G[q].add(q+chg*c)\n    G[q+chg*c].add(q)\n    G[p+chg*c].add(q+chg*c)\n    G[q+chg*c].add(p+chg*c)\n\n\ndist = defaultdict(lambda: 10**11)\ndist[1] = 0\n\nque = deque([1])\n\nwhile que:\n    ci = que.popleft()\n\n    for ni in G[ci]:\n        if dist[ni] == 10**11:\n            if ci >= chg and ni >= chg:\n                dist[ni] = dist[ci]\n                que.appendleft(ni)\n            else:\n                dist[ni] = dist[ci]+1\n                que.append(ni)\n\n\nif dist[N] < 10**11:\n    print((dist[N]//2))\nelse:\n    print((-1))\n", "def resolve():\n    def Dijkstra(s, g):\n        from collections import deque\n        d = {s}\n        queue = deque()\n        for q in edge[s]:\n            queue.append((1, q))\n        while queue:\n            dist, point = queue.popleft()\n            if point in d:\n                continue\n            d.add(point)\n            if point == g:\n                return dist\n            for nextp in edge[point]:\n                if not nextp in d:\n                    if not -1 in point or -1 in nextp:\n                        queue.appendleft((dist, nextp))\n                    else:\n                        queue.append((dist + 1, nextp))\n        return -1\n    import sys\n    input = sys.stdin.readline\n    from collections import defaultdict\n    n, m = list(map(int, input().split()))\n    edge = defaultdict(set)\n    for _ in range(m):\n        p, q, c = list(map(int, input().split()))\n        p, q = p - 1, q - 1\n        edge[(p, c)].add((q, c))\n        edge[(q, c)].add((p, c))\n        edge[(p, c)].add((p, -1))\n        edge[(q, c)].add((q, -1))\n        edge[(p, -1)].add((p, c))\n        edge[(q, -1)].add((q, c))\n    print((Dijkstra((0, -1), (n - 1, -1))))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn,m,*pqc = list(map(int, read().split()))\n\ng = {}\nM = iter(pqc)\n\nfor p,q,c in zip(M,M,M):\n    pc = ((p-1)<<20)+c\n    qc = ((q-1)<<20)+c\n    pp = (p-1)<<20\n    qq = (q-1)<<20\n    \n    if pc not in g: g[pc] = []\n    if qc not in g: g[qc] = []\n    if pp not in g: g[pp] = []\n    if qq not in g: g[qq] = []\n    \n    g[pc].append(qc)\n    g[pc].append(pp)\n\n    g[qc].append(pc)\n    g[qc].append(qq)\n\n    g[pp].append(pc)\n    g[qq].append(qc)\n\nif 0 not in g: g[0] = []\n\nfrom collections import deque\nq = deque([(0,0)])\nres = {0:0}\n\nmask = (1<<20)-1\nwhile q:\n    vl,dv = q.popleft()\n    if res[vl] < dv: continue\n    if (vl>>20) == n-1:\n        res[(n-1)<<20] = dv+1\n        break\n    for tl in g[vl]:\n        ndv = dv + (vl&mask==0 or tl&mask==0)\n        if tl not in res or res[tl] > ndv:\n            res[tl] = ndv\n            if vl&mask==0 or tl&mask==0:\n                q.append((tl,ndv))\n            else:\n                q.appendleft((tl,ndv))\n\nif (n-1)<<20 in res:\n    print((res[(n-1)<<20]//2))\nelse:\n    print((-1))\n\n\n\n\n", "import sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nfrom collections import deque\n\ndef solve():\n    dist = [inf] * len(to)\n    q = deque()\n    q.append((0, 0))\n    dist[0] = 0\n    while q:\n        d, i = q.popleft()\n        if d > dist[i]: continue\n        if i < n:\n            for j in to[i]:\n                if dist[j] <= d + 1: continue\n                dist[j] = d + 1\n                q.append((d + 1, j))\n        else:\n            for j in to[i]:\n                if j == n - 1:\n                    print(dist[i])\n                    return\n                if dist[j] <= d: continue\n                dist[j] = d\n                q.appendleft((d, j))\n    print(-1)\n\ninf=10**9\nn,m=MI()\nto=[]\nuctoi={}\n\nfor u in range(n):\n    to.append([])\n    uctoi[u,0]=u\n\nfor _ in range(m):\n    u,v,c=MI()\n    u,v=u-1,v-1\n    if (u,c) not in uctoi:\n        i=uctoi[u,c]=len(to)\n        to.append([])\n        to[i].append(u)\n        to[u].append(i)\n    else:i=uctoi[u,c]\n    if (v,c) not in uctoi:\n        j=uctoi[v,c]=len(to)\n        to.append([])\n        to[j].append(v)\n        to[v].append(j)\n    else:j=uctoi[v,c]\n    to[i].append(j)\n    to[j].append(i)\n#print(to)\n#print(fin)\n\nsolve()\n", "import heapq\n\nINF = 1000000000\n\n\ndef dijkstra(G, d, s):\n    h = []\n    d[s] = 0\n    heapq.heappush(h, (0, s))\n\n    while len(h) != 0:\n        p = heapq.heappop(h)\n        v = p[1]\n        if d[v] < p[0]:\n            continue\n        for e in G[v]:\n            if d[e[0]] > d[v] + e[1]:\n                d[e[0]] = d[v] + e[1]\n                heapq.heappush(h, (d[e[0]], e[0]))\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    p = [0] * M\n    q = [0] * M\n    c = [0] * M\n    for i in range(M):\n        p[i], q[i], c[i] = list(map(int, input().split()))\n        p[i] -= 1\n        q[i] -= 1\n    plat = []\n    for i in range(N):\n        plat.append(dict())\n    v_count = 0\n    for i in range(M):\n        p1 = plat[p[i]]\n        if not c[i] in p1:\n            p1[c[i]] = v_count\n            v_count += 1\n        p2 = plat[q[i]]\n        if not c[i] in p2:\n            p2[c[i]] = v_count\n            v_count += 1\n    for i in range(N):\n        plat[i][-1] = v_count\n        v_count += 1\n\n    G = [[] for _ in range(v_count)]\n    for i in range(M):\n        p1 = plat[p[i]][c[i]]\n        q1 = plat[q[i]][c[i]]\n        G[p1].append((q1, 0))\n        G[q1].append((p1, 0))\n    for i in range(N):\n        out = plat[i][-1]\n        for v in list(plat[i].values()):\n            if v == -1:\n                continue\n            G[v].append((out, 0))\n            G[out].append((v, 1))\n\n    start = plat[0][-1]\n    goal = plat[N - 1][-1]\n\n    d = [INF for _ in range(v_count)]\n\n    dijkstra(G, d, start)\n\n    if d[goal] == INF:\n        print((-1))\n    else:\n        print((d[goal]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\n\nN, M = list(map(int, input().split()))\nD = {}\nEdges = []\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.rank = [0] * n\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u3059\u3079\u3066\u306e\u9802\u70b9\u306b\u5bfe\u3057\u3066\u89aa\u3092\u691c\u7d22\u3059\u308b\n    def all_find(self):\n        for n in range(len(self.par)):\n            self.find(n)\n\n\nUF = UnionFind(M)\nfor i in range(M):\n    p, q, c = list(map(int, input().split()))\n    p, q = p-1, q-1\n    Edges.append((p, q))\n\n    if (p, c) in D:\n        UF.union(D[p, c], i)\n    D[p, c] = i\n\n    if (q, c) in D:\n        UF.union(D[q, c], i)\n    D[q, c] = i\n\nUF.all_find()\n\nFirm_Node = defaultdict(set)\nfor i in range(M):\n    p, q = Edges[i]\n    Firm_Node[UF.par[i]].add(p)\n    Firm_Node[UF.par[i]].add(q)\n\nG = defaultdict(list)\nfor firm, node in list(Firm_Node.items()):\n    for n in node:\n        G[n].append(firm + N)\n        G[firm + N].append(n)\n\n\ndef dijkstra(x):\n    d = {x: 0, N-1: 10**9}\n    visited = {x}\n\n    # d, u\n    queue = deque([(0, x)])\n\n    while queue:\n        u = queue.pop()[1]\n        visited.add(u)\n\n        for node in G[u]:\n            d.setdefault(node, float('inf'))\n            if (node not in visited) and d[node] > d[u] + 1:\n                d[node] = d[u] + 1\n                if d[N-1] < 10**9:\n                    return d\n                queue.appendleft([d[u]+1, node])\n    return d\n\n\ndist = dijkstra(0)\nprint((dist[N-1] // 2 if dist[N-1] < 2*M else -1))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque, defaultdict\nN, M = list(map(int, input().split()))\nG = defaultdict(list)\nfor _ in range(M):\n    p, q, c = list(map(int, input().split()))\n    G[(p-1, c-1)].append((p-1, -1))\n    G[(q-1, c-1)].append((q-1, -1))\n    G[(p-1, -1)].append((p-1, c-1))\n    G[(q-1, -1)].append((q-1, c-1))\n    G[(p-1, c-1)].append((q-1, c-1))\n    G[(q-1, c-1)].append((p-1, c-1))\n\n\ndist = defaultdict(lambda :-1)\nque = deque([(0, -1)])\ndist[(0, -1)] = 0\nwhile que:\n    v = que.pop()\n    d = dist[v]\n    for nv in G[v]:\n        if dist[nv]<0:\n            if nv[1] == -1:\n                dist[nv] = d+1\n                que.appendleft(nv)\n            else:\n                dist[nv] = d\n                que.append(nv)\nprint((dist[(N-1, -1)]))\n\n\n\n", "import sys\nfrom collections import defaultdict,deque\n\ndef main():\n    input = sys.stdin.readline\n    n,m = map(int,input().split())\n    #+\u8def\u7dda*chg : \u305d\u306e\u8def\u7dda\u30db\u30fc\u30e0\n    chg = 10**6\n\n    edge=defaultdict(set)\n    used =defaultdict(bool)\n    for i in range(m):\n        p,q,c = map(int,input().split())\n        edge[p].add(p+c*chg)\n        edge[p+c*chg].add(p)\n        edge[p+c*chg].add(q+c*chg)\n        edge[q+c*chg].add(p+c*chg)\n        edge[q].add(q+c*chg)\n        edge[q+c*chg].add(q)\n        used[p] = False\n        used[q] = False\n        used[p+c*chg] = False\n        used[q+c*chg] = False\n\n    edgelist = deque()\n    edgelist.append((1,0))\n    res = float(\"inf\")\n    while len(edgelist):\n        x,cost = edgelist.pop()\n        used[x] = True\n\n        if x == n:\n            res = cost\n            break\n        for e in edge[x]:\n            if used[e]:\n                continue\n            #\u884c\u5148\u304c\u6539\u672d\n            if x <= 10**5 and chg <= e:\n                edgelist.appendleft((e,cost+1))\n            else:\n                edgelist.append((e,cost))\n            \n    if res == float(\"inf\"):\n        print(-1)\n    else:\n        print(res)\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom collections import defaultdict,deque\ninput = sys.stdin.readline\nn,m = map(int,input().split())\n#+\u8def\u7dda*chg : \u305d\u306e\u8def\u7dda\u30db\u30fc\u30e0\nchg = 10**6\n\nedge=defaultdict(set)\nused =defaultdict(bool)\nfor i in range(m):\n    p,q,c = map(int,input().split())\n    edge[p].add(p+c*chg)\n    edge[p+c*chg].add(p)\n    edge[p+c*chg].add(q+c*chg)\n    edge[q+c*chg].add(p+c*chg)\n    edge[q].add(q+c*chg)\n    edge[q+c*chg].add(q)\n    used[p] = False\n    used[q] = False\n    used[p+c*chg] = False\n    used[q+c*chg] = False\n\nedgelist = deque()\nedgelist.append((1,0))\nres = float(\"inf\")\nwhile len(edgelist):\n    x,cost = edgelist.pop()\n    used[x] = True\n\n    if x == n:\n        res = cost\n        break\n    for e in edge[x]:\n        if used[e]:\n            continue\n        #\u884c\u5148\u304c\u6539\u672d\n        if x <= 10**5 and chg <= e:\n            edgelist.appendleft((e,cost+1))\n        else:\n            edgelist.append((e,cost))\n        \nif res == float(\"inf\"):\n    print(-1)\nelse:\n    print(res)", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**7) \n \ndef li(): return list(map(int, stdin.readline().split()))\ndef li_(): return [int(x)-1 for x in stdin.readline().split()]\ndef lf(): return list(map(float, stdin.readline().split()))\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import deque, defaultdict\n\nn,m = li()\nmod = 10**7\n\ntable = defaultdict(set)\nvisit = defaultdict(int)\n\nfor i in range(m):\n    a,b,c = li()\n    \n    table[a].add(a + c*mod)\n    table[b].add(b + c*mod)\n    table[a + c*mod].add(a)\n    table[b + c*mod].add(b)\n    table[a + c*mod].add(b + c*mod)\n    table[b + c*mod].add(a + c*mod)\n    \n    visit[a] = 0\n    visit[b] = 0\n    visit[b + c*mod] = 0\n    visit[a + c*mod] = 0\n    \nque = deque()\nque.append((1,0))\n\nvisit[1] = 1\nans = mod\n\nwhile que:\n    x, cost = que.popleft()\n    visit[x] = 1\n    \n    if x == n:\n        ans = min(ans, cost)\n        break\n    \n    for y in table[x]:\n        if visit[y] == 1:\n            continue\n        \n        if x <= 10**5 and mod <= y:\n            que.append((y, cost+1))\n            \n        else:\n            que.appendleft((y, cost))\n        \nprint((-1 if ans == mod else ans))\n", "from collections import deque\n\nN, M = map(int, input().split())\nF_C_of_S = [{} for i in range(N)]\n# Companies of Station\nC_of_S = {}\n\n# def Union-find\nparent = [-1]*M\ndef root(x):\n    if (parent[x] < 0): return x\n    else:\n        parent[x] = y = root(parent[x])\n        return y\n\ndef unite(x, y):\n    px = root(x); py = root(y);\n    if (px == py): return False\n    if (parent[px] > parent[py]):\n        px = root(y); py = root(x);\n    parent[px] += parent[py]\n    parent[py] = px\n    return True\n\n# Union-find\npqcs = []\nfor i in range(M):\n    p, q, c = map(int, input().split())\n    p -= 1; q -= 1;\n    pqcs += [(p, q, c)]\n    # The first\n    if not c in F_C_of_S[p]:\n        F_C_of_S[p][c] = i\n    # else\n    else:\n        unite(F_C_of_S[p][c], i)\n    C_of_S.setdefault(p, set()).add(c)\n    # The first\n    if not (c in F_C_of_S[q]):\n        F_C_of_S[q][c] = i\n    # else\n    else:\n        unite(F_C_of_S[q][c], i)\n    C_of_S.setdefault(q, set()).add(c)\n\n# stations of company\nS_of_C = {}\nfor i in range(M):\n    p, q, c = pqcs[i]\n    c_set = S_of_C.setdefault(root(i), set())\n    c_set.add(p); c_set.add(q);\n\nQ = deque([(0, 0, 0)])\n# cost to go to the stations from station_0\ndist = [float('inf')] * N\ndist[0] = 0\n\ngdist = [float('inf')] * M\n\nwhile Q:\n    cost, v, flag = Q.popleft()\n    if not (flag):  # (flag == 0) then gdist_update\n        for l in F_C_of_S[v].values():\n            l = root(l)\n            if (cost < gdist[l]):\n                gdist[l] = cost\n                Q.appendleft((cost, l, 1))\n    else:  # (flag == 1) then dist_update\n        for s in S_of_C[v]:\n            if (cost + 1 < dist[s]):\n                dist[s] = cost + 1\n                Q.append((cost + 1, s, 0))\n\nprint(dist[N - 1] if dist[N - 1] < float('inf') else -1)", "from collections import defaultdict,deque\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nN,M=list(map(int,input().split()))\nif M==0:\n  print((-1))\n  return\nG=defaultdict(set)\nfor i in range(M):\n  a,b,c=list(map(int,input().split()))\n  G[a+(c<<30)].add(b+(c<<30))\n  G[b+(c<<30)].add(a+(c<<30))\n  G[a].add(a+(c<<30))\n  G[b].add(b+(c<<30))\n  G[a+(c<<30)].add(a)\n  G[b+(c<<30)].add(b)\ndef BFS(x):\n  d={}\n  for k in list(G.keys()):\n    d[k]=float(\"inf\")\n  stack=deque([(x,0)])\n  if x not in d:\n    return -1\n  while stack:\n    s,m=stack.popleft()\n    if s==N:\n      return m\n    if d[s]>m:\n      d[s]=m\n      if s>=(1<<30):\n        for i in G[s]:\n          if d[i]>10**30:\n            stack.appendleft((i,m))\n      else: \n        for i in G[s]:\n          if d[i]>10**30:\n            stack.append((i,m+1))\n  return -1\n\nprint((BFS(1)))\n\n\n\n      \n    \n", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict\nfrom heapq import heappush, heappop,heappushpop,heapify\nn,m = map(int, input().split())\nlink = defaultdict(list)\nchg=10**8\nfor _ in range(m):\n    p,q,c=map(int, input().split())\n    link[p].append([p+chg*c,1])\n    link[p+chg*c].append([p,1])\n\n    link[q+chg*c].append([p+chg*c,0])\n    link[p+chg*c].append([q+chg*c,0])\n\n    link[q+chg*c].append([q,1])\n    link[q].append([q+chg*c,1])\n\ndef dks(g,start):\n    INF=float('inf')\n    visited = set()\n    hq = []\n    heappush(hq, (0,start))\n    while hq:\n        shortest, i = heappop(hq)\n        if i in visited:\n            continue\n        visited.add(i)\n        for j, t in g[i]:\n            if j in visited:\n                continue\n            if j==n:\n                return (shortest+t)//2\n            heappush(hq, (shortest + t, j))\n    return -1\nans=dks(link,1)\nprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\"\"\"\n(\u99c5\u3001\u4f1a\u793e)\u3092\u9802\u70b9\u306b\u30b0\u30e9\u30d5\u3092\u6301\u3064\u3002\u9802\u70b9\u6570O(M)\u3002\n\u305d\u306e\u307e\u307e\u8fba\u3092\u8cbc\u308b\u3068\u8fba\u304c\u591a\u304f\u306a\u308a\u3059\u304e\u308b\u3002\n(\u99c5\u3001\u4f1a\u793e) -> (\u99c5\u3001\u7121\u5c5e\u6027) -> (\u99c5\u3001\u4f1a\u793e)\n\"\"\"\n\nL = 32\nmask = (1 << L) - 1\nN,M = map(int,input().split())\ngraph = defaultdict(list)\nfor _ in range(M):\n    p,q,c = map(int,input().split())\n    p <<= L\n    q <<= L\n    graph[p].append(p+c)\n    graph[p+c].append(p)\n    graph[q].append(q+c)\n    graph[q+c].append(q)\n    graph[p+c].append(q+c)\n    graph[q+c].append(p+c)\n\nINF = 10 ** 9\ndist = defaultdict(lambda: INF)\n\nstart = 1 << L\ngoal = N << L\n\nq = [start] # 0 \u304c\u4f1a\u793e\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\u72b6\u614b\ndist[start] = 0\nd = 0\nq0 = []\nq1 = []\nwhile q:\n    for x in q:\n        if x & mask == 0:\n            for y in graph[x]:\n                if dist[y] <= d + 1:\n                    continue\n                dist[y] = d + 1\n                q1.append(y)\n        else:\n            for y in graph[x]:\n                if dist[y] <= d:\n                    continue\n                dist[y] = d\n                q0.append(y)\n    if q0:\n        q = q0\n        q0 = []\n        continue\n    q = q1\n    q1 = []\n    d += 1\n\nanswer = dist[goal]\nif answer == INF:\n    answer = -1\nprint(answer)", "def main():\n    import sys\n    from collections import deque\n    input = sys.stdin.readline\n\n    N, M = list(map(int, input().split()))\n    adj = [[] for _ in range(N+1)]\n    c2v = {}\n    v = N+1\n    for _ in range(M):\n        p, q, c = list(map(int, input().split()))\n        P = p*(10**7) + c\n        Q = q*(10**7) + c\n        if P not in c2v:\n            c2v[P] = v\n            adj[p].append((v, 1))\n            adj.append([(p, 1)])\n            v += 1\n        if Q not in c2v:\n            c2v[Q] = v\n            adj[q].append((v, 1))\n            adj.append([(q, 1)])\n            v += 1\n        adj[c2v[P]].append((c2v[Q], 0))\n        adj[c2v[Q]].append((c2v[P], 0))\n\n    que = deque()\n    que.append(1)\n    seen = [-1] * len(adj)\n    seen[1] = 0\n    while que:\n        v = que.popleft()\n        for u, cost in adj[v]:\n            if seen[u] == -1:\n                seen[u] = seen[v] + cost\n                if cost:\n                    que.append(u)\n                else:\n                    que.appendleft(u)\n    print((seen[N] // 2))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\n# https://atcoder.jp/contests/arc061/tasks/arc061_c\n\n########################################################\n# 01BFS\n########################################################\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\nab = set([])\nps = set([i<<20 for i in range(1, n+1)])\n\nfor _ in range(m):\n    a, b, c = list(map(int, input().split()))\n    a <<= 20\n    b <<= 20\n    ps.add(a+c)\n    ps.add(b+c)\n    ab.add((a, b, c))\n\n\npsr = {ps:i for i, ps in enumerate(ps)}\npsc = len(ps)\ngmap = [[] for _ in range(psc)]\nfor a, b, c in ab:\n    a0 = psr[a]\n    b0 = psr[b]\n    a1 = psr[a+c]\n    b1 = psr[b+c]\n    gmap[a0].append((a1, 1))\n    gmap[b0].append((b1, 1))\n    gmap[a1].append((a0, 0))\n    gmap[b1].append((b0, 0))\n    gmap[a1].append((b1, 0))\n    gmap[b1].append((a1, 0))\n\nINF = float('inf')\ndist = [INF] * psc\n\ndef zero_one_bfs(sp, gp):\n    next_q = deque([])\n    next_q.append(sp)\n    dist[sp] = 0\n    while next_q:\n        cp = next_q.popleft()\n        cd = dist[cp]\n        if cp == gp: return cd\n        for np, pay in gmap[cp]:\n            if dist[np] <= cd+pay: continue\n            dist[np] = cd + pay\n            if pay == 1:\n                next_q.append(np)\n            else:\n                next_q.appendleft(np)\n    return dist[gp]\n\nret = zero_one_bfs(psr[1<<20], psr[n<<20])\nprint((-1 if ret == INF else ret))\n", "N, M = list(map(int, input().split()))\nES = []\nD = [{} for i in range(N)]\n\n*parent, = list(range(M))\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = y = root(parent[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\n\nE = {}\nfor i in range(M):\n    p, q, c = list(map(int, input().split())); p -= 1; q -= 1\n    ES.append((p, q, c))\n    if c in D[p]:\n        unite(D[p][c], i)\n    else:\n        D[p][c] = i\n    E.setdefault(p, set()).add(c)\n    if c in D[q]:\n        unite(D[q][c], i)\n    else:\n        D[q][c] = i\n    E.setdefault(q, set()).add(c)\nP = {}\nfor i in range(M):\n    p, q, c = ES[i]\n    s = P.setdefault(root(i), set())\n    s.add(p); s.add(q)\n\nfrom collections import deque\nque = deque([(0, 0, 0)])\nINF = 10**18\ndist = [INF]*N\ndist[0] = 0\ngdist = [INF]*M\n\nwhile que:\n    cost, v, t = que.popleft()\n    if t:\n        # edge\n        if gdist[v] < cost or v not in P:\n            continue\n        for w in P[v]:\n            if cost + 1 < dist[w]:\n                dist[w] = cost + 1\n                que.append((cost + 1, w, 0))\n    else:\n        # node\n        if dist[v] < cost or v not in E:\n            continue\n        for w in list(D[v].values()):\n            w = root(w)\n            if cost < gdist[w]:\n                gdist[w] = cost\n                que.appendleft((cost, w, 1))\n\nprint((dist[N-1] if dist[N-1] < INF else -1))\n", "from collections import *\nimport sys \nsys.setrecursionlimit(10 ** 9)\n\ndef solve():\n    def dfs(u, f):\n        G[u].append(f)\n        G1[f].append(u)\n        for v in g[u]:\n            if v not in used:\n                used.add(v)\n                dfs(v, f)\n\n    n, m = list(map(int, input().split()))\n    edges = []\n    for  _ in range(m):\n        edges.append(list(map(int, input().split())))\n    edges.sort(key = lambda item: item[2])\n    G = defaultdict(list)#\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u53ef\u80fd\u5728\u54ea\u4e2a\u5206\u7ec4\u91cc\u9762\n    G1 = defaultdict(list) #\u8bb0\u5f55\u6bcf\u4e2a\u5206\u7ec4\u91cc\u9762\u7684\u70b9\n    en = 0\n    cnt = 0\n    while en < len(edges):\n        st = en \n        g = defaultdict(list)\n        used = set()\n        while en < len(edges) and edges[en][2] == edges[st][2]:\n            x, y = edges[en][0], edges[en][1]\n            g[x].append(y)\n            g[y].append(x)\n            en += 1\n        for k in g:\n            if k not in used:\n                used.add(k)\n                dfs(k, cnt)\n                cnt += 1\n    \n    usedG = set()\n    usedP = set()\n    deq = deque()\n    deq.append(1)\n    usedP.add(1)\n    step = 0\n    while deq:\n        siz = len(deq)\n        for _ in range(siz):\n            f = deq.popleft()\n            if f == n:\n                print(step)\n                return \n            for g in G[f]:\n                if g not in usedG:\n                    usedG.add(g)\n                    for p in G1[g]:\n                        if p not in usedP:\n                            usedP.add(p)\n                            deq.append(p)\n        step += 1\n    \n    print((-1))\n\nsolve()\n\n", "def dijkstra_heap(s,edge,mask):\n    dist = defaultdict(lambda: float(\"inf\"))\n    q = [s]  # 0 \u304c\u4f1a\u793e\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\u72b6\u614b\n    dist[s] = 0\n    d = 0; q0 = []; q1 = []\n    while q:\n        for x in q:\n            if x & mask == 0:\n                for y in edge[x]:\n                    if dist[y[1]] <= d + y[0]:\n                        continue\n                    dist[y[1]] = d + y[0]\n                    q1.append(y[1])\n            else:\n                for y in edge[x]:\n                    if dist[y[1]] <= d+ y[0]:\n                        continue\n                    dist[y[1]] = d+ y[0]\n                    q0.append(y[1])\n        if q0:\n            q = q0\n            q0 = []\n            continue\n        q = q1\n        q1 = []\n        d += 1\n    return dist\n\ndef examE(inf):\n    N, M = LI()\n    edge = defaultdict(list)\n    # edge[i] : i\u304b\u3089\u51fa\u308b\u9053\u306e[\u91cd\u307f,\u884c\u5148]\u306e\u914d\u5217\n    L = 32\n    Mask = (1 << L) - 1\n    for i in range(M):\n        p, q, c = list(map(int, input().split()))\n        p -=1; q -=1\n        p <<= L\n        q <<= L\n        #\u540c\u3058\u8def\u7dda\u3060\u3068\u30b3\u30b9\u30c8\uff10 \u4e57\u308b\u3068\u304d\u3060\u3051\u30b3\u30b9\u30c8\uff11\n        edge[p].append((1,p + c))\n        edge[p + c].append((0,p))\n        edge[q].append((1,q + c))\n        edge[q + c].append((0,q))\n        edge[p + c].append((0,q + c))\n        edge[q + c].append((0,p + c))\n    start = 0\n    goal = (N-1) << L\n    res = dijkstra_heap(start, edge, Mask)\n#    print(res)\n    ans = res[goal]\n    if ans == inf:\n        ans = -1\n    print(ans)\n\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\nmod = 10**9 + 7\ninf = float('inf')\n\nexamE(inf)\n", "def main():\n  N,M=map(int,input().split())\n\n  if M == 0:\n    print(-1)\n    return\n\n  INF = 10**6\n  pqc = [tuple(map(lambda x:int(x)-1,input().split())) for _ in range(M)]\n\n  to1d={v:{} for v in range(N)}\n  count=2\n  for p,q,c in pqc:\n    if not to1d[p].get(c):\n      to1d[p][c] = count\n      count += 1\n    if not to1d[q].get(c):\n      to1d[q][c] = count\n      count += 1\n\n  G = [{} for _ in range(N+count)]\n  for p,q,c in pqc:\n    v1,v2 = to1d[p][c],to1d[q][c]\n    G[v1][v2] = G[v2][v1] = 0\n\n  for i in range(N):\n    if len(to1d[i])<=1: continue\n    for c in to1d[i].keys():\n      v = to1d[i][c]\n      G[v][count] = 1\n      G[count][v] = 0\n    count += 1\n\n  def dijkstra(start = 0, goal = 1):\n      from heapq import heappop, heappush\n      NN = len(G)\n      d = [INF]*NN\n      d[start] = 0\n      que = []\n      heappush(que, start)\n      while que:\n          p = divmod(heappop(que),NN)\n          v = p[1]\n          if d[v] < p[0]: continue\n          for u in G[v].keys():\n              if d[u] > d[v] + G[v][u]:\n                  d[u] = d[v] + G[v][u]\n                  heappush(que, d[u]*NN+u)\n          if v == goal: return d[goal]\n      return d[goal]\n\n  for c in to1d[0].keys():\n    v = to1d[0][c]\n    G[0][v] = 1\n  for c in to1d[N-1].keys():\n    v = to1d[N-1][c]\n    G[v][1] = 0\n\n  ans = dijkstra(0,1)\n  print(ans if ans < INF else -1)\n  \ndef __starting_point():\n  main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\"\"\"\n(\u99c5\u3001\u4f1a\u793e)\u3092\u9802\u70b9\u306b\u30b0\u30e9\u30d5\u3092\u6301\u3064\u3002\u9802\u70b9\u6570O(M)\u3002\n\u305d\u306e\u307e\u307e\u8fba\u3092\u8cbc\u308b\u3068\u8fba\u304c\u591a\u304f\u306a\u308a\u3059\u304e\u308b\u3002\n(\u99c5\u3001\u4f1a\u793e) -> (\u99c5\u3001\u7121\u5c5e\u6027) -> (\u99c5\u3001\u4f1a\u793e)\n\"\"\"\n\nL = 32\nmask = (1 << L) - 1\nN,M = map(int,input().split())\ngraph = defaultdict(list)\nfor _ in range(M):\n    p,q,c = map(int,input().split())\n    p <<= L\n    q <<= L\n    graph[p].append(p+c)\n    graph[p+c].append(p)\n    graph[q].append(q+c)\n    graph[q+c].append(q)\n    graph[p+c].append(q+c)\n    graph[q+c].append(p+c)\n\nINF = 10 ** 9\ndist = defaultdict(lambda: INF)\n\nstart = 1 << L\ngoal = N << L\n\nq = [start] # 0 \u304c\u4f1a\u793e\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\u72b6\u614b\ndist[start] = 0\nd = 0\nwhile q:\n    qq = []\n    while q:\n        x = q.pop()\n        if x & mask == 0:\n            for y in graph[x]:\n                if dist[y] <= d + 1:\n                    continue\n                dist[y] = d + 1\n                qq.append(y)\n        else:\n            for y in graph[x]:\n                if dist[y] <= d:\n                    continue\n                dist[y] = d\n                q.append(y)\n    d += 1\n    q = qq\n\nanswer = dist[goal]\nif answer == INF:\n    answer = -1\nprint(answer)", "# https://juppy.hatenablog.com/entry/2019/04/10/ARC061_-_E_%E3%81%99%E3%81%AC%E3%81%91%E5%90%9B%E3%81%AE%E5%9C%B0%E4%B8%8B%E9%89%84%E6%97%85%E8%A1%8C_-_Python_%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0_Atcoder\n# \u53c2\u8003\u306b\u3055\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3057\u305f\u3002\n\nfrom collections import deque, defaultdict\n\nchg = 10**6\nn, m = map(int, input().split())\nedges = defaultdict(set)\n# m=0\u306e\u305f\u3081\u306bdefaultdict\u306b\u3057\u3066\u304a\u304f\u3079\u304d\nvisited = defaultdict(set)\nfor i in range(m):\n    p, q, c = map(int, input().split())\n    edges[p+c*chg].add(q+c*chg)\n    edges[q+c*chg].add(p+c*chg)\n    edges[p].add(p+c*chg)\n    edges[q].add(q+c*chg)\n    edges[p+c*chg].add(p)\n    edges[q+c*chg].add(q)\n    visited[p] = False\n    visited[q] = False\n    visited[p+c*chg] = False\n    visited[q+c*chg] = False\n\nans = float(\"inf\")\nque = deque()\n# now, dist\nque.append((1, 0))\n# \u4eca\u6c42\u3081\u308b\u306e\u306fend\u306e\u8ddd\u96e2\u3060\u3051\u306a\u306e\u3067\u3001dist\u914d\u5217\u306f\u3044\u3089\u306a\u3044\n# \u3055\u3089\u306b\u3001\u8ddd\u96e2\u306f0/1\u306a\u306e\u3067heap\u3067\u8fba\u3092\u7ba1\u7406\u3059\u308b\u5fc5\u8981\u3082\u306a\u304f\u30010\u306a\u3089\u6700\u77ed\u78ba\u5b9a\u306a\u306e\u3067\u5148\u306b\u30011\u306a\u3089\u305d\u306e\u6642\u70b9\u3067\u306e\u6700\u9577\u306a\u306e\u3067\u5f8c\u308d\u306b\u3059\u308c\u3070\u826f\u3044\nwhile que:\n    now, dist = que.popleft()\n    if visited[now]:\n        continue\n    visited[now] = True\n    if now == n:\n        ans = dist\n        break\n    for to in edges[now]:\n        # \u99c5\u2192\u30db\u30fc\u30e0\n        if now < chg and to > chg:\n            que.append((to, dist+1))\n        else:\n            que.appendleft((to, dist))\nif ans == float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nfrom collections import deque\nN, M = map(int, input().split())\nX = []\nC = [set() for _ in range(N)]\nfor _ in range(M):\n    p, q, c = [int(a) - 1 for a in input().split()]\n    X.append((p, q, c))\n    C[p].add(c)\n    C[q].add(c)\nfor i, c in enumerate(C):\n    C[i] = list(c)\n\nI = [N]\nD = [{} for _ in range(N)]\nfor i, c in enumerate(C):\n    for j, a in enumerate(c):\n        D[i][a] = I[-1] + j\n    I.append(I[-1] + len(c))\n\nT = I[-1]\nE = [[] for _ in range(T)]\nfor p, q, c in X:\n    E[D[p][c]].append((D[q][c], 0))\n    E[D[q][c]].append((D[p][c], 0))\nfor i, c in enumerate(C):\n    for j, a in enumerate(c):\n        E[i].append((D[i][a], 1))\n        E[D[i][a]].append((i, 1))\n\ndef BFS01(n, E, i0=0):\n    Q = deque([i0])\n    D = [-1] * n\n    D[i0] = 0\n    while Q:\n        x = Q.popleft()\n        for y, w in E[x]:\n            if D[y] == -1:\n                if w:\n                    D[y] = D[x] + 1\n                    Q.append(y)\n                else:\n                    D[y] = D[x]\n                    Q.appendleft(y)\n    return D\n\nD = BFS01(T, E, 0)\nprint(D[N-1] // 2)", "import sys, heapq\nfrom collections import defaultdict\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nclass DijkstraList():\n\t#\u96a3\u63a5\u30ea\u30b9\u30c8\u7248\n\t#\u540c\u4e00\u9802\u70b9\u306e\u8907\u6570\u56de\u63a2\u7d22\u3092\u9632\u3050\u305f\u3081\u8a2a\u554f\u3057\u305f\u9802\u70b9\u6570\u3092\u5909\u6570cnt\u3067\u6301\u3064\n\tdef __init__(self, adj, start):\n\t\tself.list = adj\n\t\tself.start = start\n\t\tself.size = len(adj)\n\n\tdef solve(self):\n\t\t#self.dist = [float(\"inf\") for _ in range(self.size)]\n\t\tself.dist = defaultdict(lambda :10**30)\n\t\tself.dist[self.start] = 0\n\t\t#self.prev = [-1 for _ in range(self.size)]\n\t\tself.q = []\n\t\tself.cnt = 0\n\n\t\theapq.heappush(self.q, (0, self.start))\n\n\t\twhile self.q and self.cnt < self.size:\n\t\t\tu_dist, u = heapq.heappop(self.q)\n\t\t\tif self.dist[u] < u_dist:\n\t\t\t\tcontinue\n\t\t\tfor v, w in self.list[u]:\n\t\t\t\tif self.dist[v] > u_dist + w:\n\t\t\t\t\tself.dist[v] = u_dist + w\n\t\t\t\t\t#self.prev[v] = u\n\t\t\t\t\theapq.heappush(self.q, (self.dist[v], v))\n\t\t\tself.cnt += 1\n\t\treturn\n\n\tdef distance(self, goal):\n\t\treturn self.dist[goal]\n\nn, m = map(int, input().split())\ncost = [10**30 for _ in range(n)]\nedges = defaultdict(list)\nfor _ in range(m):\n\tp, q, t = map(int, input().split())\n\tedges[p-1 + t * n].append((q-1 + t * n, 0))\n\tedges[q-1 + t * n].append((p-1 + t * n, 0))\n\tif len(edges[p-1 + t * n]) == 1:\n\t\tedges[p-1 + t * n].append((p-1 + 0 * n, 0))\n\t\tedges[p-1 + 0 * n].append((p-1 + t * n, 1))\n\tif len(edges[q-1 + t * n]) == 1:\n\t\tedges[q-1 + t * n].append((q-1 + 0 * n, 0))\n\t\tedges[q-1 + 0 * n].append((q-1 + t * n, 1))\n\nd = DijkstraList(edges, 0)\nd.solve()\nres = d.distance(n-1)\nif res > 10**20:\n\tprint(-1)\nelse:\n\tprint(res)", "class UnionFindVerSize():\n    def __init__(self,init):\n        \"\"\" N\u500b\u306e\u30ce\u30fc\u30c9\u306eUnion-Find\u6728\u3092\u4f5c\u6210\u3059\u308b \"\"\"\n        # \u89aa\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u3002\u81ea\u5206\u304c\u89aa\u3060\u3063\u305f\u5834\u5408\u306f\u3001\u81ea\u5206\u306e\u756a\u53f7\u306b\u306a\u308a\u3001\u305d\u308c\u304c\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u756a\u53f7\u306b\u306a\u308b\n        self._parent = [n for n in range(0, len(init))]\n        # \u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u500b\u6570\uff09\n        self._size = [1] * len(init)\n        self._dict ={key:0 for key in init}\n        for i in range(len(init)):\n            v=init[i]\n            self._dict[v]=i\n\n    def find_root(self, x,key):\n        \"\"\" x\u306e\u6728\u306e\u6839(x\u304c\u3069\u306e\u30b0\u30eb\u30fc\u30d7\u304b)\u3092\u6c42\u3081\u308b \"\"\"\n        if key==1:\n            x=self._dict[x]\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x],0) # \u7e2e\u7d04\n        return self._parent[x]\n\n    def unite(self, x, y):\n        \"\"\" x\u3068y\u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408\u3059\u308b \"\"\"\n        x=self._dict[x]\n        y=self._dict[y]\n        gx = self.find_root(x,0)\n        gy = self.find_root(y,0)\n        if gx == gy: return\n\n        # \u5c0f\u3055\u3044\u65b9\u3092\u5927\u304d\u3044\u65b9\u306b\u4f75\u5408\u3055\u305b\u308b\uff08\u6728\u306e\u504f\u308a\u304c\u6e1b\u308b\u306e\u3067\uff09\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        x=self._dict[x]\n        \"\"\" x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u500b\u6570\uff09\u3092\u8fd4\u3059 \"\"\"\n        return self._size[self.find_root(x,0)]\n\n    def is_same_group(self, x, y):\n        x=self._dict[x]\n        y=self._dict[y]\n        \"\"\" x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5426\u304b \"\"\"\n        return self.find_root(x,0) == self.find_root(y,0)\n\n    def calc_group_num(self):\n        \"\"\" \u30b0\u30eb\u30fc\u30d7\u6570\u3092\u8a08\u7b97\u3057\u3066\u8fd4\u3059 \"\"\"\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i,0) == i:\n                ans += 1\n        return ans\n\nimport sys\n\ninput=sys.stdin.readline\n\nN,M=map(int,input().split())\ncompany={}\ncedge={}\nnode=N\nedge={i:[] for i in range(N)}\nfor i in range(M):\n    u,v,c=map(int,input().split())\n    edge[u-1].append((v-1,1))\n    edge[v-1].append((u-1,1))\n    if c-1 not in company:\n        company[c-1]=[]\n        cedge[c-1]=[]\n    company[c-1].append(u-1)\n    company[c-1].append(v-1)\n    cedge[c-1].append((u-1,v-1))\n\nfor i in company:\n    uf=UnionFindVerSize(company[i])\n    for u,v in cedge[i]:\n        uf.unite(u,v)\n    data={}\n    for v in company[i]:\n        p=uf.find_root(v,1)\n        if p not in data:\n            data[p]=[]\n        data[p].append(v)\n    for p in data:\n        edge[node]=[]\n        for v in data[p]:\n            edge[v].append((node,0))\n            edge[node].append((v,1))\n        node+=1\n\nfrom collections import deque\ndist=[10**20]*node\ndist[0]=0\nque=deque([(0,0)])\nwhile que:\n    v,d=que.popleft()\n    for nv,c in edge[v]:\n        if dist[nv]>d+c:\n            if c==1:\n                dist[nv]=d+c\n                que.append((nv,d+c))\n            else:\n                dist[nv]=d+c\n                que.appendleft((nv,d+c))\n\n\nans=dist[N-1]\nprint(ans if ans!=10**20 else -1)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\n\nn, m = map(int, input().split())\nG = defaultdict(set)\nU = 10**6\nseen = set()\nfor _ in range(m):\n  p, q, c = map(int, input().split())\n  G[p+U*c].add((q+U*c, 0))\n  G[q+U*c].add((p+U*c, 0))\n  G[p+U*c].add((p-U, 0))\n  G[q+U*c].add((q-U, 0))\n  G[p-U].add((p+U*c, 1))\n  G[q-U].add((q+U*c, 1))\nque = deque()\nque.append((1-U, 0))\nwhile que:\n  v, cnt = que.popleft()\n  if v in seen:\n    continue\n  if v == n-U:\n    print(cnt)\n    return\n  seen.add(v)\n  for nv, cost in G[v]:\n    if cost == 0:\n      que.appendleft((nv, cnt+cost))\n    else:\n      que.append((nv, cnt+cost))\nprint(-1)", "import sys\ninput=sys.stdin.readline\nfrom collections import defaultdict,deque\nn,m=map(int,input().split())\nroute=10**6\nEdges=defaultdict(set)\nVisited=defaultdict(bool)\nfor _ in range(m):\n    p,q,c=map(int,input().split())\n    Edges[p].add(p+c*route)\n    Edges[p+c*route].add(p)\n    Edges[p+c*route].add(q+c*route)\n    Edges[q+c*route].add(p+c*route)\n    Edges[q].add(q+c*route)\n    Edges[q+c*route].add(q)\nq=deque()\nq.append((1,0))\ncost=-1\nwhile q:\n    fr,c=q.popleft()\n    Visited[fr]=True\n    if fr==n:\n        cost=c\n        break\n    for to in Edges[fr]:\n        if Visited[to]:\n            continue\n        if fr<=10**5 and to>route:\n            q.append((to,c+1))\n        else:\n            q.appendleft((to,c))\nprint(cost)", "import sys, heapq\nfrom collections import defaultdict\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nclass DijkstraList():\n\t#\u96a3\u63a5\u30ea\u30b9\u30c8\u7248\n\t#\u540c\u4e00\u9802\u70b9\u306e\u8907\u6570\u56de\u63a2\u7d22\u3092\u9632\u3050\u305f\u3081\u8a2a\u554f\u3057\u305f\u9802\u70b9\u6570\u3092\u5909\u6570cnt\u3067\u6301\u3064\n\tdef __init__(self, adj, start):\n\t\tself.list = adj\n\t\tself.start = start\n\t\tself.size = len(adj)\n\n\tdef solve(self):\n\t\t#self.dist = [float(\"inf\") for _ in range(self.size)]\n\t\tself.dist = defaultdict(lambda :10**30)\n\t\tself.dist[self.start] = 0\n\t\t#self.prev = [-1 for _ in range(self.size)]\n\t\tself.q = []\n\t\tself.cnt = 0\n\n\t\theapq.heappush(self.q, (0, self.start))\n\n\t\twhile self.q and self.cnt < self.size:\n\t\t\tu_dist, u = heapq.heappop(self.q)\n\t\t\tif self.dist[u] < u_dist:\n\t\t\t\tcontinue\n\t\t\tfor v, w in self.list[u]:\n\t\t\t\tif self.dist[v] > u_dist + w:\n\t\t\t\t\tself.dist[v] = u_dist + w\n\t\t\t\t\t#self.prev[v] = u\n\t\t\t\t\theapq.heappush(self.q, (self.dist[v], v))\n\t\t\tself.cnt += 1\n\t\treturn\n\n\tdef distance(self, goal):\n\t\treturn self.dist[goal]\n\nn, m = map(int, input().split())\ncost = [10**30 for _ in range(n)]\nedges = defaultdict(list)\nfor _ in range(m):\n\tp, q, t = map(int, input().split())\n\tedges[p-1 + t * n].append((q-1 + t * n, 0))\n\tedges[q-1 + t * n].append((p-1 + t * n, 0))\n\tif len(edges[p-1 + t * n]) == 1:\n\t\tedges[p-1 + t * n].append((p-1 + 0 * n, 0))\n\t\tedges[p-1 + 0 * n].append((p-1 + t * n, 1))\n\tif len(edges[q-1 + t * n]) == 1:\n\t\tedges[q-1 + t * n].append((q-1 + 0 * n, 0))\n\t\tedges[q-1 + 0 * n].append((q-1 + t * n, 1))\n\nd = DijkstraList(edges, 0)\nd.solve()\nres = d.distance(n-1)\nif res > 10**20:\n\tprint(-1)\nelse:\n\tprint(res)", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\n    def tall(self):\n        d = collections.defaultdict(list)\n        for i in range(len(self.table)):\n            d[self.find(i)].append(i)\n        return d\n\ndef main():\n    M = 2**17\n    n,m = LI()\n    a = [LI() for _ in range(m)]\n    e = collections.defaultdict(list)\n    for p,q,c in a:\n        pc = p+c*M\n        qc = q+c*M\n        pm = p-M\n        qm = q-M\n        e[pc].append(qc)\n        e[qc].append(pc)\n        e[pm].append(pc)\n        e[qm].append(qc)\n        e[pc].append(pm)\n        e[qc].append(qm)\n\n    def search():\n        d = collections.defaultdict(lambda: inf)\n        s = 1-M\n        d[s] = 0\n        q = []\n        heapq.heappush(q, (0, s))\n        v = set()\n        while len(q):\n            k, u = heapq.heappop(q)\n            if u in v:\n                continue\n            v.add(u)\n            if u < 0:\n                for uv in e[u]:\n                    if uv in v:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            else:\n                if u % M == n:\n                    return k\n\n                for uv in e[u]:\n                    if uv in v:\n                        continue\n                    if d[uv] > k:\n                        d[uv] = k\n                        heapq.heappush(q, (k, uv))\n\n        return -1\n\n    return search()\n\n\n\nprint(main())\n", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n\"\"\"\n(\u99c5\u3001\u4f1a\u793e)\u3092\u9802\u70b9\u306b\u30b0\u30e9\u30d5\u3092\u6301\u3064\u3002\u9802\u70b9\u6570O(M)\u3002\n\u305d\u306e\u307e\u307e\u8fba\u3092\u8cbc\u308b\u3068\u8fba\u304c\u591a\u304f\u306a\u308a\u3059\u304e\u308b\u3002\n(\u99c5\u3001\u4f1a\u793e) -> (\u99c5\u3001\u7121\u5c5e\u6027) -> (\u99c5\u3001\u4f1a\u793e)\n\"\"\"\n\nL = 32\nmask = (1 << L) - 1\nN,M = map(int,input().split())\ngraph = defaultdict(list)\nfor _ in range(M):\n    p,q,c = map(int,input().split())\n    p <<= L\n    q <<= L\n    graph[p].append(p+c)\n    graph[p+c].append(p)\n    graph[q].append(q+c)\n    graph[q+c].append(q)\n    graph[p+c].append(q+c)\n    graph[q+c].append(p+c)\n\nINF = 10 ** 9\ndist = defaultdict(lambda: INF)\n\nstart = 1 << L\ngoal = N << L\n\nq = [start] # 0 \u304c\u4f1a\u793e\u306b\u5c5e\u3057\u3066\u3044\u306a\u3044\u72b6\u614b\ndist[start] = 0\nd = 0\nq0 = []\nq1 = []\nwhile q:\n    for x in q:\n        if x & mask == 0:\n            for y in graph[x]:\n                if dist[y] <= d + 1:\n                    continue\n                dist[y] = d + 1\n                q1.append(y)\n        else:\n            for y in graph[x]:\n                if dist[y] <= d:\n                    continue\n                dist[y] = d\n                q0.append(y)\n    if q0:\n        q = q0\n        q0 = []\n        continue\n    q = q1\n    q1 = []\n    d += 1\n\nanswer = dist[goal]\nif answer == INF:\n    answer = -1\nprint(answer)", "from sys import setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import bisect\nfrom heapq import *\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nN, M = reads()\nedges = [[] for _ in range(N)]\nedgesc = defaultdict(lambda: [])\nfor _ in range(M):\n  p, q, c = reads()\n  p, q = p-1, q-1\n  edges[p].append((q, c))\n  edges[q].append((p, c))\n  edgesc[p, c].append(q)\n  edgesc[q, c].append(p)\n\nINF = 1 << 30\ndef dijkstra(edges, s):\n  result = defaultdict(lambda: INF)\n  result[s, -1] = 0\n  que = deque([(0, s, -1)])\n  while len(que) > 0:\n    (d, u, c) = que.popleft()\n    if result[u, c] < d:\n      continue\n    if c < 0:\n      for (t, c2) in edges[u]:\n        if d + 1 < result[t, c2]:\n          result[t, c2] = d + 1\n          que.append((d + 1, t, c2))\n    else:\n      for t in edgesc[u, c]:\n        if d < result[t, c]:\n          result[t, c] = d\n          que.appendleft((d, t, c))\n      if d < result[u, -1]:\n        result[u, -1] = d\n        que.appendleft((d, u, -1))\n  return result\n\ndist = dijkstra(edges, 0)\ntry:\n  print(min(d for (u, _), d in dist.items() if u == N-1))\nexcept ValueError:\n  print(-1)"]
["def doubles(maxk, maxn):\n    return sum([ sum([ (n+1)**(-2*k) for n in range(1, maxn+1) ])/k for k in range(1, maxk+1) ])", "from scipy.special import zeta,zetac\n\ndef doubles(maxk, maxn):\n    return sum((zetac(2*k)-zeta(2*k,2+maxn))/k for k in range(1,maxk+1))", "def v(k,n):\n    return (1.0/k)*(n+1)**(-2*k)\n\ndef doubles(maxk, maxn):\n    total = 0.0\n    k = 1.0\n    while k <= maxk:\n        n = 1.0\n        while n <= maxn:\n            total += v(k,n)\n            n += 1\n        k += 1\n    return total", "def doubles(maxk, maxn):\n    return sum(sum((n+1)**(-2*k)/k for n in range(1, maxn+1)) for k in range(1, maxk+1))", "\ndef doubles(maxk, maxn):\n    res=0\n    for k in range(1,maxk+1):\n        for n in range(1,maxn+1):\n            res += 1/(k* ((n+1)**(2*k)))\n    return res", "import numpy as np\n\ndef box_force(k, n):\n    return 1 / (k * (n+1) ** (2 * k))\n\ndef doubles(maxk, maxn):\n    return np.fromfunction(lambda i, j: box_force(i+1, j+1), (maxk, maxn)).sum()", "import numpy as np\n\ndef get_v(k,n):\n    return 1/(k * np.power((n+1).reshape(-1,1), (2*k).reshape(1,-1)))\n\ndef doubles(K, N):\n    K = np.arange(1, K+1, dtype = np.float64)\n    N = np.arange(1, N+1, dtype = np.float64)\n    return get_v(K, N).sum()", "# Professor Chambouliard hast just discovered a new type of magnet material.\n# He put particles of this material in a box made of small boxes arranged\n# in K rows and N columns as a kind of 2D matrix K x N where K and N\n# are postive integers. He thinks that his calculations show that\n# the force exerted by the particle in the small box (k, n) is:\n# https://www.codecogs.com/latex/eqneditor.php?latex=%5Cbg_green&space;v(k,&space;n)&space;=&space;%5Cfrac%7B1%7D%7Bk(n+1)%5E%7B2k%7D%7D\n# The total force exerted by the first row with k = 1 is:\n# https://www.codecogs.com/latex/eqneditor.php?latex=%5Cbg_green&space;u(1,&space;N)&space;=&space;%5Csum_%7Bn=1%7D%5E%7Bn=N%7Dv(1,&space;n)&space;=&space;%5Cfrac%7B1%7D%7B1.2%5E2%7D&space;+&space;%5Cfrac%7B1%7D%7B1.3%5E2%7D+...+%5Cfrac%7B1%7D%7B1.(N+1)%5E2%7D\n# We can go on with k = 2 and then k = 3 etc ... and consider:\n# https://www.codecogs.com/latex/eqneditor.php?latex=%5Cbg_green&space;S(K,&space;N)&space;=&space;%5Csum_%7Bk=1%7D%5E%7Bk=K%7Du(k,&space;N)&space;=&space;%5Csum_%7Bk=1%7D%5E%7Bk=K%7D(%5Csum_%7Bn=1%7D%5E%7Bn=N%7Dv(k,&space;n))&space;%5Crightarrow&space;(doubles(maxk,&space;maxn))\n# Task: To help Professor Chambouliard can we calculate the function\n# doubles that will take as parameter maxk and maxn such that\n# doubles(maxk, maxn) = S(maxk, maxn)? Experiences seems to show that\n# this could be something around 0.7 when maxk and maxn are big enough.\n# Examples: doubles(1, 3)  => 0.4236111111111111;\n# doubles(1, 10) => 0.5580321939764581; doubles(10, 100) => 0.6832948559787737\n# Notes: In u(1, N) the dot is the multiplication operator.\n# Don't truncate or round: Have a look in \"RUN EXAMPLES\" at \"assertFuzzyEquals\".\n\ndef v(k, n):\n    return 1/(k*((n+1)**(2*k)))\n\ndef u(k, N):\n    u_res = 0\n    for n in range (0, N):\n       u_res += v(k, n+1)\n    return u_res\n\ndef S(K, N):\n    S_res = 0\n    for k in range (0, K):\n       S_res += u(k+1, N)\n    return S_res   \n\ndef doubles(maxk, maxn):\n    return S(maxk, maxn)", "def doubles(k, n):\n    s = 0\n    for iK in range(1,min(k+1, 24)):\n        for iN in range(2, n+2):\n            s += 1/(iK*iN**(2*iK))\n    return s", "def doubles(maxk, maxn):\n    result= 0\n    for k in range(1, maxk+1):\n        curr_sum=0\n        for n in range(1, maxn+1):\n            curr_sum+= (1/(n+1)**(2*k))\n        result += (1/k) * curr_sum\n    return result"]
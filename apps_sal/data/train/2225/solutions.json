["import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Node:\n    def __init__(self,depth):\n        self.depth=depth\n        self.left=None\n        self.right=None\n\ndef insert(node,s):\n    n=node\n    for i in range(len(s)):\n        t=s[i]\n        if t=='0':\n            if n.left is None:\n                n.left=Node(i+1)\n            n=n.left\n        else:\n            if n.right is None:\n                n.right=Node(i+1)\n            n=n.right\n\nclass Trie:\n    def __init__(self):\n        self.root=Node(0)\n    def insert(self,s:str):\n        insert(self.root,s)\n\nn,l=map(int,input().split())\nS=[input().strip() for _ in range(n)]\ntrie=Trie()\nfor s in S:\n    trie.insert(s)\nData=[]\nq=deque([trie.root])\n\ndef dfs(node):\n    if node.right is None and node.left is None:\n        return\n    if node.right is None or node.left is None:\n        Data.append(l-node.depth)\n    if node.right:\n        q.append(node.right)\n    if node.left:\n        q.append(node.left)\n\nwhile q:\n    dfs(q.popleft())\nxor=0\n\ndef Grundy(n):\n    ret=1\n    while n%2==0:\n        n//=2\n        ret*=2\n    return ret\n\nfor i in Data:\n    xor^=Grundy(i)\nprint('Alice' if xor else 'Bob')", "import sys\n#from collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef input():\n\treturn sys.stdin.readline()[:-1]\nn, l = list(map(int, input().split()))\nss = [list(input())[::-1] for _ in range(n)]\n\ndef addTree(tree, sentence):\n\tif not sentence:\n\t\treturn None   \n\n\tif sentence[-1] not in tree:\n\t\ttree[sentence[-1]] = {}\n\n\tp = sentence.pop()\n\ttree[p] = addTree(tree[p], sentence)\n\n\treturn tree\n\ndef createTree(sentences):    \n\ttree = {}\n\tfor sentence in sentences:\n\t\ttree = addTree(tree, sentence)\n\n\treturn tree\n\ntree = createTree(ss)\n#print(tree)\n\ngrundy = 0\ndef dfs(cur, level):\n\tnonlocal grundy\n\tif cur is None:\n\t\treturn\n\telif len(cur) == 1:\n\t\tgrundy ^= (l-level) & (-l+level)\n\tfor k in list(cur.keys()):\n\t\tdfs(cur[k], level+1)\n\treturn\n\t\ndfs(tree, 0)\n\nif grundy == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")\n", "import sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\n\nclass TrieNode:\n    def __init__(self, char):\n        self.char = char\n        self.nextnode = dict()\n        self.is_indict = False\n\n\nclass Trie:\n    def __init__(self, charset):\n        self.charset = charset\n        self.root = TrieNode('')\n\n    def add(self, a_str):\n        node = self.root\n        for i, char in enumerate(a_str):\n            if char not in node.nextnode:\n                node.nextnode[char] = TrieNode(char)\n            node = node.nextnode[char]\n            if i == len(a_str) - 1:\n                node.is_indict = True\n\n    def dfs(self, node, dep):\n        ret, cnt = 0, 0\n        if node.is_indict:\n            return 0\n        for s in '01':\n            if s not in node.nextnode:\n                cnt += 1\n            else:\n                ret ^= self.dfs(node.nextnode[s], dep + 1)\n        height = L - dep\n        if cnt % 2:\n            power2 = 0\n            while height > 0 and height % 2 == 0:\n                power2 += 1\n                height //= 2\n            ret ^= 2 ** power2\n        return ret\n\n    def debug_output(self, node, now):\n        print((node.char, list(node.nextnode.items()), node.is_indict, now))\n        if node.is_indict:\n            print(now)\n        for n in list(node.nextnode.values()):\n            self.debug_output(n, now + n.char)\n\nN, L = list(map(int, input().split()))\nT = Trie('01')\nfor _ in range(N):\n    T.add(input())\n# T.debug_output(T.root, '')\nprint((\"Alice\" if T.dfs(T.root, 0) else \"Bob\"))\n", "n,l = map(int,input().split())\nls = [input() for i in range(n)]\nsm = sum([len(s) for s in ls])\nls.sort()\nnum = [0]*(sm+1)\nfor i in range(n):\n  if i == 0:\n    for j in range(len(ls[i])):\n      num[j+1] = 1\n  else:\n    x = ls[i]\n    p = ls[i-1]\n    cnt = 0\n    while cnt < min(len(x),len(p)):\n      if x[cnt] == p[cnt]:\n        cnt += 1\n      else:\n        break\n    num[cnt+1] -= 1\n    for j in range(cnt+2,len(x)+1):\n      num[j] += 1\nans = 0\ndef d2(x):\n  if x == 0:\n    return 0\n  cnt = 0\n  while x%2 == 0:\n    cnt += 1\n    x //= 2\n  return 2**cnt\nfor i in range(sm+1):\n  ans ^= d2(l+1-i)*(num[i]%2)\nif ans:\n  print(\"Alice\")\nelse:\n  print(\"Bob\")", "def getGrundyNumber(x):\n    ans = 1\n    while x % (ans * 2) == 0:\n        ans *= 2\n    return ans\n\n\nN, L = list(map(int, input().split()))\nSs = [input() for i in range(N)]\n\n# \u30c8\u30e9\u30a4\u6728\u3092\u4f5c\u6210\u3059\u308b\nTrie = [[-1, -1]]\nfor S in Ss:\n    iT = 0\n    for c in map(int, S):\n        if Trie[iT][c] == -1:\n            Trie += [[-1, -1]]\n            Trie[iT][c] = len(Trie) - 1\n        iT = Trie[iT][c]\n\n# \u5b50\u304c\uff11\u3064\u306e\u9802\u70b9\u3092\u63a2\u3059\nHgts = {}\nstack = [(0, L + 1)]\nwhile stack:\n    iT, Hgt = stack.pop()\n    num = 0\n    for c in Trie[iT]:\n        if c != -1:\n            stack.append((c, Hgt - 1))\n            num += 1\n\n    if num == 1:\n        Hgts[Hgt - 1] = Hgts.get(Hgt - 1, 0) + 1\n\n# Grundy\u6570\u306eXOR\u3092\u6c42\u3081\u308b\nans = 0\nfor Hgt, num in list(Hgts.items()):\n    if num % 2:\n        ans ^= getGrundyNumber(Hgt)\n\nif ans:\n    print('Alice')\nelse:\n    print('Bob')\n", "from collections import defaultdict\n\n\ndef solve(n, l, nums):\n    xor = 0\n\n    if n == 1:\n        for i in range(min(nums), l + 1):\n            xor ^= i & -i\n        return xor\n\n    for i in range(min(nums), l + 1):\n        ni = nums[i]\n        for k in ni:\n            if k ^ 1 not in ni:\n                xor ^= i & -i\n            nums[i + 1].add(k // 2)\n        del nums[i]\n    return xor\n\n\nn, l = list(map(int, input().split()))\nnums = defaultdict(set)\nfor s in (input() for _ in range(n)):\n    nums[l - len(s) + 1].add(int(s, 2) + (1 << len(s)))\n\nprint(('Alice' if solve(n, l, nums) else 'Bob'))\n", "from collections import deque\n# \u7bc0\u306e\u5b9a\u7fa9\nclass Node:\n    def __init__(self, x):\n        self.data  = int(x)\n        self.left  = None\n        self.right = None\n# \u633f\u5165\ndef insert(node, x):\n    ima = node\n    for i in range(len(x)):\n        y = x[i]\n        if y == \"1\":\n            if ima.right is None:\n                ima.right = Node(i+1)\n            ima = ima.right\n        else:\n            if ima.left is None:\n                ima.left = Node(i+1)\n            ima = ima.left\n\n\n\nclass Trie:\n    def __init__(self):\n        self.root = Node(0)\n\n    # \u633f\u5165\n    def insert(self, x):\n        insert(self.root, x)\n\nn,l = map(int,input().split())\ns = [input() for i in range(n)]\n\ntrie = Trie()\nfor i in s:\n    trie.insert(i)\ndata = []\nque = deque([trie.root])\ndef dfs(node):\n    if node.right is None and node.left is None:\n        return 0\n    if node.right is None or node.left is None:\n        if l-node.data:\n            data.append(l-node.data)\n    if node.right:\n        que.append(node.right)\n    if node.left:\n        que.append(node.left)\n    \nwhile que:\n    dfs(que.popleft())\nxor = 0\ndef nimber(n):\n    x = 1\n    while n%2 == 0: n//= 2; x*= 2\n    return x\nfor i in data:\n    xor ^= nimber(i)\nprint(\"Alice\" if xor else \"Bob\")", "# nimber: 0, 1, 2, 1, 4, 1, 2, 1, 8, 1, 2, 1, 4, 1, 2, 1, 16, 1, 2, 1, 4, 1, 2, 1, 8, 1, 2, 1, 4, 1, 2, 1, 32, ...\n\nclass Node:\n    def __init__(self, size, avail):\n        self.end = False\n        self.nxt = [None] * size\n        self.avail = avail\n    def __setitem__(self, i, x): self.nxt[i] = x\n    def __getitem__(self, i): return self.nxt[i]\n\ndef makeTrie(strs, size):\n    root = Node(size, l)\n    for s in strs:\n        n = root\n        for c in s:\n            i = int(c) # Change this to adapt. ex: ord(c)-ord(\"A\")\n            if not n[i]: n[i] = Node(size, n.avail-1)\n            n = n[i]\n        n.end = True\n    return root\n\ndef nimber(n):\n    x = 1\n    while n%2 == 0: n//= 2; x*= 2\n    return x\n\ninput = __import__('sys').stdin.readline\nn, l = map(int,input().split())\nstrs = [input().rstrip() for i in range(n)]\nT = makeTrie(strs, 2)\n\nans = 0\nstack = [T]\nwhile stack:\n    n = stack.pop()\n    for i in 0, 1:\n        if not n[i]: ans^= nimber(n.avail)\n        elif not n[i].end: stack.append(n[i])\nprint(\"Alice\" if ans else \"Bob\")", "class Node():\n    def __init__(self):\n        self.lt = None\n        self.rt = None\n        self.dep = None\n\nclass Trie():\n    def __init__(self):\n        self.root = Node()\n        self.root.dep = 0\n\n    def add(self, string):\n        node = self.root\n        for s in string:\n            if s == '0':\n                if node.lt is None:\n                    node.lt = Node()\n                    node.lt.dep = node.dep + 1\n                node = node.lt\n            else:\n                if node.rt is None:\n                    node.rt = Node()\n                    node.rt.dep = node.dep + 1\n                node = node.rt\n\nN, L = map(int, input().split())\n\ntrie = Trie()\n\nfor _ in range(N):\n    s = input()\n    trie.add(s)\n\nsubgame = []\nstack = [trie.root]\n\nwhile stack:\n    node = stack.pop()\n    if node.lt is None and node.rt is None:\n        continue\n    elif node.rt is None:\n        stack.append(node.lt)\n        subgame.append(L - node.dep)\n    elif node.lt is None:\n        stack.append(node.rt)\n        subgame.append(L - node.dep)\n    else:\n        stack.append(node.lt)\n        stack.append(node.rt)\n\ndef grundy(n):\n    if n == 0: return 0\n    if n % 2 == 1: return 1\n    if n == 2**(n.bit_length() - 1):\n        return n\n    return grundy(n - 2**(n.bit_length() - 1))\n\ng = 0\n\nfor l in subgame:\n    g ^= grundy(l)\n\nprint('Alice' if g != 0 else 'Bob')", "import sys\nN, L = list(map(int, input().split()))\nsys.setrecursionlimit(200000)\n\nclass Node:\n    def __init__(self, depth=0):\n        self.parent = None\n        self.children = {}\n        self.depth = depth\n    def add(self, n):\n        self.children[n] = Node(self.depth+1)\n    def has(self, n):\n        return n in self.children\nt = Node()\nfor i in range(N):\n    s = input()\n    nt = t\n    for c in s:\n        if not nt.has(c):\n            nt.add(c)\n        nt = nt.children[c]\n\ndef solve(node):\n    nonlocal N, L\n    ans = 0\n    f = lambda d: (L - d) & -(L - d)\n    if node.has('0'):\n        ans ^= solve(node.children['0'])\n    else:\n        ans ^= f(node.depth)\n    if node.has('1'):\n        ans ^= solve(node.children['1'])\n    else:\n        ans ^= f(node.depth)\n    return ans\n\nans = solve(t)\nif ans == 0:\n    print('Bob')\nelse:\n    print('Alice')\n", "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc087/tasks/arc087_c\n\n\u521d\u671f\u72b6\u614b\u3067\u51fa\u3066\u3044\u308b\u6570\u5b57\u3092\u6728\u3068\u3057\u3066\u3042\u3089\u308f\u3059\n\u6570\u5b57\u3067\u3075\u3055\u304c\u3063\u3066\u3044\u308b\u6240\u306f\u3082\u3046\u8ffd\u52a0\u3067\u304d\u306a\u3044\n\u307e\u3060\u304a\u3051\u308b\u306e\u306f\u3001\u7a7a\u3044\u3066\u3044\u308b\u90e8\u5206\u3060\u3051\n\nL\u304c\u3067\u304b\u3044\u306e\u3067\u3001\u6df1\u3055\u3092\u8003\u3048\u3066\u3044\u3066\u306f\u6b7b\u306c\n\n\u305d\u306e\u307e\u307e\u3075\u3055\u3050\u3068\u3001\u7f6e\u3051\u308b\u5834\u6240\u306f1\u6e1b\u308b\n\u4f38\u3070\u3057\u3066\u304a\u3051\u3070\u3001L\u307e\u3067\u5897\u3084\u3057\u3066\u7f6e\u3051\u308b\n\n\u7f6e\u3051\u308b\u5834\u6240\u306e\u5076\u5947\u304b\uff1f\n\u7f6e\u3051\u308b\u5834\u6240\u304c0\u3067\u6765\u305f\u3089\u8ca0\u3051\u2192\u521d\u624b\u304c\u5947\u6570\u306a\u3089\u5148\u624b\u52dd\u3061\u30fb\u305d\u3046\u3067\u306a\u3044\u306a\u3089\u5f8c\u624b\u52dd\u3061\uff1f\n\u4f38\u3070\u305b\u308b\u5974\u306f\u5076\u5947\u53cd\u8ee2\u306b\u4f7f\u3048\u308b\n\n\u90e8\u5206\u3067\u8003\u3048\u3066\u307f\u308b\u304b\u2192\n\nGrundy\u6570\u8a08\u7b97\n\u6df1\u30551\u306e\u90e8\u5206\u6728\u306eGrundy \u2192 1\n\u6df1\u30552\u306e\u90e8\u5206\u6728\u306eGrundy \u2192 2\n\u6df1\u30553\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000 \u2192 1 ?\n\u6df1\u30554\n\nGrundy\u3067\u884c\u3051\u308b = xor\u304c\u5168\u4f53\u306eGrundy\u306b\u306a\u308b\u3068\u3044\u3046\u4eee\u5b9a\n\u306a\u306e\u3067\u3001\u6df1\u3055x\u3092\u8a66\u3059\u3068\u304d\u306f\u3001\u6df1\u3055x\u30671\u56de\u3067\u884c\u3051\u308b\u72b6\u614b\u306exor\u306emex\u304cGrundy\u3068\u306a\u308b\n\n\u6df1\u30551\u306a\u3089\u3001\u554f\u7b54\u7121\u7528\u30671\n\u6df1\u30552\u306a\u3089\u30010 or 1 \u306b\u306a\u308b\u306e\u3067 2\n\u6df1\u30553\u306a\u3089, 0 or 2 \u306b\u306a\u308b\u306e\u3067 1\n\u6df1\u30554\u306a\u3089, 0 or 1 or 3 or 2 \u306a\u306e\u3067 4\n\u6df1\u30555\u306a\u3089, 0 or 4 or 5 or 7 or 6 \u3067 1\n\u6df1\u30556\u306a\u3089, 0 or 1 or 5 or 4 or 6 or 7 \u3067 2\n\u6df1\u30557\u306a\u3089, 0 or 2 or 3 or 7 or 6 or 4 or 5 \u3067 1\n\u6df1\u30558\u306a\u3089, 0 or 1 or 3 or 2 or 6 or 7 or 5 or 4 \u3067 8\n\n\u2192\u3069\u3046\u3084\u3089\u3001\u305d\u306e\u6570\u5b57\u3092\u5272\u308a\u5207\u308c\u308b\u6700\u5927\u306e2\u306e\u968e\u4e57\u6570\u304cGrundy\u6570\u306b\u306a\u308b\u307f\u305f\u3044\u3060\n\u3064\u307e\u308a\u3001\u7a7a\u304d\u30dd\u30a4\u30f3\u30c8\u3092\u63a2\u7d22\u3057\u3066\u3001\u5bfe\u5fdc\u3059\u308b\u6df1\u3055\u306eGrundy\u6570\u3092\u8a08\u7b97 & xor\u3092\u3068\u308c\u3070\u3088\u3044\n\n\u3042\u3068\u306f\u5b9f\u88c5\u3060\nprefix tree\u3092\u4f5c\u308a\u305f\u3044\u306a\uff1f\n\u9069\u5f53\u306b\u30ce\u30fc\u30c9\u3092\u8ffd\u52a0\u3057\u3066\u4f5c\u3063\u3066\u3042\u3052\u308c\u3070\u3044\u3044\u304b\n\u4fdd\u6301\u3059\u308b\u30c7\u30fc\u30bf\u306f\u30010\u306e\u5b50index,1\u306e\u5b50index,\u6df1\u3055\u304c\u3042\u308c\u3070\u5341\u5206\u304b\u306a\n\u8a08\u7b97\u91cf\u304c\u3061\u3087\u3063\u3068\u6c17\u306b\u306a\u308b\u3068\u3053\u308d(\u518d\u5e30\u306f\u306a\u308b\u3079\u304f\u907f\u3051\u305f\u3044\u3068\u3053\u308d)\n\n\"\"\"\n\ndef tp_z(now , nd):\n\n    if z_child[now] == None:\n        ret = len(z_child)\n        z_child[now] = ret\n        z_child.append(None)\n        o_child.append(None)\n        dep.append(nd + 1)\n    else:\n        ret = z_child[now]\n\n    return ret\n\ndef tp_o(now , nd):\n\n    if o_child[now] == None:\n        ret = len(z_child)\n        o_child[now] = ret\n        z_child.append(None)\n        o_child.append(None)\n        dep.append(nd + 1)\n    else:\n        ret = o_child[now]\n\n    return ret\n\ndef grundy(nd):\n\n    if nd == 0:\n        return 0\n\n    for i in range(64):\n        if nd % (2**i) != 0:\n            return 2**(i-1)\n        \n\nN,L = map(int,input().split())\n\nz_child = [None]\no_child = [None]\ndep = [0]\n\nfor loop in range(N):\n\n    now = 0\n    s = input()\n\n    for i in s:\n        if i == \"0\":\n            now = tp_z(now , dep[now])\n        else:\n            now = tp_o(now , dep[now])\n\n#print (z_child)\n#print (o_child)\n#print (dep)\n\nans = 0\nfor i in range(len(z_child)):\n\n    if z_child[i] == None:\n        ans ^= grundy(L - dep[i])\n    if o_child[i] == None:\n        ans ^= grundy(L - dep[i])\n\nif ans == 0:\n    print (\"Bob\")\nelse:\n    print (\"Alice\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nfrom collections import deque\n\nN,M = map(int,input().split())\nwords = [deque(input().rstrip()) for _ in range(N)]\n\n# \u6df1\u3055L\u306efull tree\u306e\u5c0f\u3055\u3044\u65b9\u3092\u8a08\u7b97\u3057\u3066\u307f\u308b\ndef G_small():\n    G = [0] * 100\n    G_cum = [0] * 100\n    G[0] = 1\n    G_cum[0] = 1\n    for n in range(1,100):\n        can_make = set(G_cum[n-1]^G_cum[x] for x in range(n)) | set([G_cum[n-1]])\n        rest = set(range(n+10)) - can_make\n        G[n] = min(rest)\n        G_cum[n] = G_cum[n-1] ^ G[n]\n    return G\n\n# print([(n,G[n]) for n in range(100)])\n# G[n] = 2**ord_2(n+1)\n# \u5024\u304c\u308f\u304b\u308c\u3070\u8a3c\u660e\u306f\u6613\u3057\u3044\n\ndef G(n):\n    n += 1\n    x = 1\n    while not n & 1:\n        n >>= 1\n        x <<= 1\n    return x\n\ndef calc_grandy(words,L):\n    if not words:\n        return G(L)\n    if len(words) == 1 and words[0] == deque():\n        return 0\n    words_0 = []\n    words_1 = []\n    for word in words:\n        first = word.popleft()\n        if first == '0':\n            words_0.append(word)\n        else:\n            words_1.append(word)\n    return calc_grandy(words_0,L-1) ^ calc_grandy(words_1,L-1)\n\ng = calc_grandy(words,M)\n\nanswer = 'Alice' if g != 0 else 'Bob'\nprint(answer)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef getGrundyNumber(x):\n    ans = 1\n    while x % (ans * 2) == 0:\n        ans *= 2\n    return ans\n\n\ndef dfs(iT, Hgt):\n    num = 0\n    for c in Trie[iT]:\n        if c != -1:\n            dfs(c, Hgt - 1)\n            num += 1\n\n    if num == 1:\n        Hgts[Hgt - 1] = Hgts.get(Hgt - 1, 0) + 1\n\n\nN, L = list(map(int, input().split()))\nSs = [input() for i in range(N)]\n\n# \u30c8\u30e9\u30a4\u6728\u3092\u4f5c\u6210\u3059\u308b\nTrie = [[-1, -1]]\nfor S in Ss:\n    iT = 0\n    for c in map(int, S):\n        if Trie[iT][c] == -1:\n            Trie += [[-1, -1]]\n            Trie[iT][c] = len(Trie) - 1\n        iT = Trie[iT][c]\n\n# \u5b50\u304c\uff11\u3064\u306e\u9802\u70b9\u3092\u63a2\u3059\nHgts = {}\ndfs(0, L + 1)\n\n# Grundy\u6570\u306eXOR\u3092\u6c42\u3081\u308b\nans = 0\nfor Hgt, num in list(Hgts.items()):\n    if num % 2:\n        ans ^= getGrundyNumber(Hgt)\n\nif ans:\n    print('Alice')\nelse:\n    print('Bob')\n", "def main():\n    import sys\n    from collections import defaultdict\n    input = sys.stdin.readline\n\n    mod = 10**10+7\n    mod2 = 10**10+9\n    mod3 = 998244353\n    N, L = list(map(int, input().split()))\n    dic = defaultdict(int)\n    dic2 = defaultdict(int)\n    dic3 = defaultdict(int)\n    h_list = []\n    h2_list = []\n    h3_list = []\n    pair = {}\n    pair2 = {}\n    pair3 = {}\n    M = 0\n    for _ in range(N):\n        s = input().rstrip('\\n')\n        h = 0\n        h2 = 0\n        h3 = 0\n        for i in range(len(s)):\n            M += 1\n            h = (h*1007 + int(s[i]) + 1) % mod\n            pair[h] = (h + 1)%mod if s[i] == '0' else (h-1)%mod\n            h2 = (h2 * 2009 + int(s[i]) + 1) % mod2\n            pair2[h2] = (h2 + 1)%mod2 if s[i] == '0' else (h2-1)%mod2\n            h3 = (h3 * 3001 + int(s[i]) + 1) % mod3\n            pair3[h3] = (h3 + 1) % mod3 if s[i] == '0' else (h3 - 1) % mod3\n            dic[h] = i+1\n            dic2[h2] = i+1\n            dic[h3] = i+1\n            h_list.append(h)\n            h2_list.append(h2)\n            h3_list.append(h3)\n\n    g = 0\n    seen = defaultdict(int)\n    seen2 = defaultdict(int)\n    seen3 = defaultdict(int)\n    for i in range(M):\n        s, s2, s3 = h_list[i], h2_list[i], h3_list[i]\n        if seen[s] and seen2[s2] and seen3[s3]:\n            continue\n        t = pair[s]\n        t2 = pair2[s2]\n        t3 = pair3[s3]\n        if dic[t] == 0 or dic2[t2] == 0 or dic3[t3] == 0:\n            p = [dic[s], dic2[s2], dic3[s3]]\n            p.sort()\n            tmp = L - p[1] + 1\n            '''\n            if not seen[s]:\n                tmp = L - dic[s] + 1\n            elif not seen[s2]:\n                tmp = L - dic2[s2] + 1\n            else:\n                tmp = L - dic3[s3] + 1\n            '''\n            cnt = 0\n            while tmp % 2 == 0:\n                tmp //= 2\n                cnt += 1\n            g ^= (2**cnt)\n            #print(g, s, s2, t, t2, dic[t], dic2[t2])\n        seen[s] = 1\n        seen2[s2] = 1\n        seen3[s3] = 1\n\n    if g:\n        print('Alice')\n    else:\n        print('Bob')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict\n\n\ndef solve(l, ss):\n    xor = 0\n    for d in range(min(ss), l + 1):\n        sl = ss[d]\n        sl.sort()\n        while sl:\n            s = sl.pop()\n            ps = s[:-1]\n            ss[d + 1].append(ps)\n            if s[-1] == '1' and sl and sl[-1][:-1] == ps:\n                sl.pop()\n            else:\n                xor ^= d & -d\n        del ss[d]\n    return xor\n\n\nn, l = list(map(int, input().split()))\nss = defaultdict(list)\nfor s in (input() for _ in range(n)):\n    ss[l - len(s) + 1].append(s)\n\nprint(('Alice' if solve(l, ss) else 'Bob'))\n", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\n_,L = list(map(int,readline().split()))\ns = read().split()\n\ndef grundy(x):\n    if x==0: return 0\n    r = 1\n    while x%2==0:\n        x //= 2\n        r *= 2\n    return r\n\ng = 0\nst = [(s,0)]\nwhile st:\n    a,idx = st.pop()\n    a0 = []\n    a1 = []\n    for i in a:\n        if len(i) <= idx:\n            continue\n        if i[idx] == \"0\":\n            a0.append(i)\n        else:\n            a1.append(i)\n    \n    if (a0 and not a1) or (a1 and not a0):\n        g ^= grundy(L-idx)\n\n    if a0: st.append((a0,idx+1))\n    if a1: st.append((a1,idx+1))\n\nif g: print(\"Alice\")\nelse: print(\"Bob\")\n\n", "import sys\nreadline = sys.stdin.readline\n\nclass Node:\n    def __init__(self, sigma, depth):\n        self.end = False\n        self.child = [None] * sigma\n        self.depth = depth\n    def __setitem__(self, i, x):\n        self.child[i] = x\n    def __getitem__(self, i):\n        return self.child[i]\n\nclass Trie():\n    def __init__(self, sigma):\n        self.sigma = sigma\n        self.root = Node(sigma, 0)\n    \n    def add(self, S):\n        vn = self.root\n        for cs in S:\n            if vn[cs] is None:\n                vn[cs] = Node(self.sigma, vn.depth + 1)\n            vn = vn[cs]\n        vn.end = True\n\nans = 0\n\nN, L = list(map(int, readline().split()))\n\nTr = Trie(2)\n\nfor _ in range(N):\n    S = list(map(int, readline().strip()))\n    Tr.add(S)\n\ncnt = 0\nstack = [Tr.root]\nwhile stack:\n    vn = stack.pop()\n    for i in range(2):\n        if vn[i] is None:\n            r = L - vn.depth\n            cnt ^= -r&r\n        else:\n            stack.append(vn[i])\n\nprint(('Alice' if cnt else 'Bob'))\n", "N, L = map(int, input().split())\n\nmake = lambda:[None, None, 0]\nroot = make()\ndef construct(s):\n    n = root\n    for i in s:\n        if n[i] is None:\n            n[i] = n = make()\n        else:\n            n = n[i]\n    n[2] = 1\n\nfor i in range(N):\n    s = map(int, input())\n    construct(s)\n\ncaps = {}\nst = [(root, 0, 0)]\nwhile st:\n    n, i, l = st.pop()\n    if i:\n        if n[1] is None:\n            caps[L - l] = caps.get(L - l, 0) + 1\n        else:\n            if not n[1][2]:\n                st.append((n[1], 0, l+1))\n    else:\n        st.append((n, 1, l))\n        if n[0] is None:\n            caps[L - l] = caps.get(L - l, 0) + 1\n        else:\n            if not n[0][2]:\n                st.append((n[0], 0, l+1))\nans = 0\nfor v in caps:\n    k = caps[v]\n    if k % 2 == 0:\n        continue\n    v -= 1\n    r = 1\n    while v % 4 == 3:\n        v //= 4\n        r *= 4\n    if v % 4 == 1:\n        ans ^= r * 2\n    else:\n        ans ^= r\nprint('Alice' if ans else 'Bob')", "import sys\n#from collections import defaultdict\nsys.setrecursionlimit(10**6)\n\ndef input():\n\treturn sys.stdin.readline()[:-1]\nn, l = list(map(int, input().split()))\nss = [list(input())[::-1] for _ in range(n)]\n\ndef addTree(tree, sentence):\n\tif not sentence:\n\t\treturn None   \n\n\tif sentence[-1] not in tree:\n\t\ttree[sentence[-1]] = {}\n\n\tp = sentence.pop()\n\ttree[p] = addTree(tree[p], sentence)\n\n\treturn tree\n\ndef createTree(sentences):    \n\ttree = {}\n\tfor sentence in sentences:\n\t\ttree = addTree(tree, sentence)\n\n\treturn tree\n\ntree = createTree(ss)\n#print(tree)\n\ngrundy = 0\ndef dfs(cur, level):\n\tnonlocal grundy\n\tif cur is None:\n\t\treturn\n\telif len(cur) == 1:\n\t\tgrundy ^= (l-level) & (-l+level)\n\tfor k in list(cur.keys()):\n\t\tdfs(cur[k], level+1)\n\treturn\n\t\ndfs(tree, 0)\n\nif grundy == 0:\n\tprint(\"Bob\")\nelse:\n\tprint(\"Alice\")\n", "import random\nN, L = list(map(int,input().split()))\nM = 2*10**5+1\nsets = [set() for _ in range(M+1)]\n\nMOD = 282525872416376072492401\nr_max = 10**6\ninv_t = [0,1]\nfor i in range(2,r_max+1):\n  #print(MOD % i)\n  inv_t.append(inv_t[MOD % i] * (MOD - MOD // i) % MOD)\nr = random.randint(10**5, r_max)\nrinv = inv_t[r]\n#print(r, rinv)\n\ndef has(s):\n  ans = 0\n  i = 0\n  for x in s:\n    ans *= r\n    ans += int(x) + (i+1)**2\n    ans %= MOD\n    i += 1\n  return ans % MOD\ndef tract(x, s, l):\n  return ((x - int(s) - l**2) * rinv ) %MOD\n \nstrs = []\ndic = {}\nct = 0\nfor i in range(N):\n  s = input()\n  strs.append(s)\n  sets[len(s)].add(has(s))\n  if has(s) in dic:\n    print((\"warning!!\", s))\n    ct += 1\n  dic[has(s)] = i\n#print(ct)\n#print(sets[0:3])\n#print(dic)\nfree_num = [0 for _ in range(M+1)]\nfor l in range(M,0,-1):\n  while len(sets[l]) > 0:\n    x = sets[l].pop()\n    #print(x, dic[x], strs[dic[x]], l)\n    #if l-1 > len(strs[dic[x]]):\n      #print(l-1, x, dic[x], strs[dic[x]], sets[l])\n    last = strs[dic[x]][l-1]\n    x_p = tract(x, last, l)\n    sets[l-1].add(x_p) \n    dic[x_p] = dic[x]\n    x_anti = (x_p*r + 1-int(last) + l**2) % MOD\n    if x_anti in sets[l]:\n      sets[l].remove(x_anti)\n    else:\n      free_num[l] += 1\n    #print(l, x, free_num[0:2],sets[0:3], x_p, x_anti, last)\n#print(free_num[0:100])\nGrandy = 0\nfor i in range(M+1):\n  G_base = L - i + 1\n  if free_num[i] % 2 == 1:\n    #print(i, G_base)\n    Grandy ^= (G_base & -G_base)\n#print(Grandy)    \nprint((\"Alice\" if Grandy > 0 else \"Bob\"))\n  \n#print(2**54 & -2**54, 2**54) \n  \n", "import sys\n\nsys.setrecursionlimit(100000)\n\n\ndef dfs(cur, dep=0):\n    if cur == -1:\n        x = l - dep\n        return x & -x\n    return dfs(trie[cur][0], dep + 1) ^ dfs(trie[cur][1], dep + 1)\n\n\nn, l = list(map(int, input().split()))\ntrie = [[-1, -1] for _ in range(100001)]\nidx = 1\nfor s in (input() for _ in range(n)):\n    cur = 0\n    for c in map(int, s):\n        if trie[cur][c] == -1:\n            trie[cur][c] = idx\n            idx += 1\n        cur = trie[cur][c]\n\nxor = dfs(trie[0][0]) ^ dfs(trie[0][1])\nprint(('Alice' if xor else 'Bob'))\n", "import sys\nreadline = sys.stdin.readline\n\nclass Node:\n    def __init__(self, sigma, depth):\n        self.end = False\n        self.child = [None] * sigma\n        self.depth = depth\n    def __setitem__(self, i, x):\n        self.child[i] = x\n    def __getitem__(self, i):\n        return self.child[i]\n\nsigma = 2\nroot = Node(sigma, 0)\ndef add_trie(S):\n    vn = root\n    for cs in S:\n        if vn[cs] is None:\n            vn[cs] = Node(sigma, vn.depth + 1)\n        vn = vn[cs]\n    vn.end = True\n\nans = 0\n\nN, L = map(int, readline().split())\n\nfor _ in range(N):\n    S = list(map(int, readline().strip()))\n    add_trie(S)\n\ncnt = 0\nstack = [root]\nwhile stack:\n    vn = stack.pop()\n    for i in range(2):\n        if vn[i] is None:\n            r = L - vn.depth\n            cnt ^= -r&r\n        else:\n            stack.append(vn[i])\n\nprint('Alice' if cnt else 'Bob')", "def getGrundyNumber(x):\n    ans = 1\n    while x % (ans * 2) == 0:\n        ans *= 2\n    return ans\n\n\nN, L = list(map(int, input().split()))\nSs = [input() for i in range(N)]\n\nSs.sort()\n\nHgts = {L: 2}\nprev = '_'\nfor S in Ss:\n    for iS, (a, b) in enumerate(zip(prev, S)):\n        if a != b:\n            Hgts[L - iS] -= 1\n            for h in range(L - len(S) + 1, L - iS):\n                Hgts[h] = Hgts.get(h, 0) + 1\n            break\n    prev = S\n\nans = 0\nfor Hgt, num in list(Hgts.items()):\n    if num % 2:\n        ans ^= getGrundyNumber(Hgt)\n\nif ans:\n    print('Alice')\nelse:\n    print('Bob')\n", "def main():\n    N,L = map(int,input().split())\n    keys = []\n    grundy_num=0\n    if N==1:\n        print(\"Alice\")\n        return\n    for i in range(N):\n        s = input()\n        #merge node:\n        while len(s)>0:\n            if s[-1]=='1' and s[:-1]+'0' in keys:\n                keys.remove(s[:-1]+'0')\n                s = s[:-1]\n            elif s[-1]=='0' and s[:-1]+'1' in keys:\n                keys.remove(s[:-1]+'1')\n                s = s[:-1]\n            else:\n                if s!=\"\":\n                    keys.append(s)\n                break\n    if len(keys):\n        keys = sorted(keys,key=len,reverse=True)\n        grundy_list = []\n        while len(keys):\n            j = keys[0]\n            keys.remove(j)\n            temp_s = list(reversed(bin(L-len(j)+1)))\n            grundy_list.append(1 << temp_s.index('1'))\n            if j[:-1]!=\"\":\n                keys.append(j[:-1])\n            j = j[:-1]\n            #merge node\n            while len(j)>0:\n                if j[-1]=='1' and j[:-1]+'0' in keys:\n                    keys.remove(j[:-1]+'0')\n                    keys.remove(j)\n                    j = j[:-1]\n                    if j!=\"\":\n                        keys.append(j)\n                elif j[-1]=='0' and j[:-1]+'1' in keys:\n                    keys.remove(j[:-1]+'1')\n                    keys.remove(j)\n                    j = j[:-1]\n                    if j!=\"\":\n                        keys.append(j)\n                else:\n                    break\n            keys = sorted(keys,key=len,reverse=True)\n        grundy_num = grundy_list[0]\n        for i in range(1,len(grundy_list)):\n            grundy_num = grundy_num^grundy_list[i]\n    print(\"Bob\" if grundy_num==0 else \"Alice\")\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    n, l = map(int, input().split())\n    ss = [input()[:-1] for _ in range(n)] + [\"$\"]\n    ss.sort()\n    # print(ss)\n\n    # \u96a3\u540c\u58eb\u306es\u3092\u5148\u982d\u304b\u3089\u6bd4\u3079\u3066\u3001\u7570\u306a\u308b\u3068\u3053\u308d\u3067\u305d\u306elevel\u306e\u6728\u3092\u6d88\u3057\u3066\u3001\u305d\u308c\u4ee5\u964d\u306e\u6728\u3092\u8ffd\u52a0\u3059\u308b\n    cnt_tree = defaultdict(int)\n    cnt_tree[l] = 2\n    for s0, s1 in zip(ss, ss[1:]):\n        for depth, (c0, c1) in enumerate(zip(s0, s1)):\n            if c0 == c1: continue\n            cnt_tree[l - depth] -= 1\n            for lv in range(l - depth - 1, l - len(s1), -1):\n                cnt_tree[lv] += 1\n            # print(cnt_tree)\n            break\n\n    # Grundy\u6570\u3092lv & -lv\u3067\u6c42\u3081\u3001xor\u3092\u3068\u308b\n    sum_xor = 0\n    for lv, cnt in cnt_tree.items():\n        if cnt % 2 == 0: continue\n        sum_xor ^= lv & -lv\n\n    if sum_xor:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nmain()\n", "from functools import cmp_to_key\n\n\ndef f(s, t):\n    m = min(len(s), len(t))\n    if s[:m] > t[:m]:\n        return 1\n    elif s[:m] < t[:m]:\n        return -1\n    else:\n        if len(s) > len(t):\n            return -1\n        else:\n            return 1\n\n\ndef ms(s, t):\n    i = 0\n    for c1, c2 in zip(s, t):\n        if c1 != c2:\n            return i\n        i += 1\n    return i\n\n\ndef xxor(x):\n    if x & 3 == 0:\n        return x\n    if x & 3 == 1:\n        return 1\n    if x & 3 == 2:\n        return x + 1\n    if x & 3 == 3:\n        return 0\n\n\ndef gray(x):\n    return x ^ (x // 2)\n\n\nn, l = list(map(int, input().split()))\ns = [input() for _ in range(n)]\ns.sort(key=cmp_to_key(f))\ng = gray(l) ^ gray(l - len(s[0]))\nfor i in range(n - 1):\n    b = ms(s[i], s[i + 1]) + 1\n    g ^= gray(l - b + 1) ^ gray(l - b)\n    t = len(s[i + 1]) - b\n    g ^= gray(l - b) ^ gray(l - b - t)\nif g == 0:\n    print('Bob')\nelse:\n    print('Alice')\n", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    class TreiNode:\n        def __init__(self, char_num, depth):\n            self.end = False\n            self.child = [None] * char_num\n            self.depth = depth\n\n        def __setitem__(self, i, x):\n            self.child[i] = x\n\n        def __getitem__(self, i):\n            return self.child[i]\n\n    class Trei:\n        def __init__(self, char_num):\n            self.root = TreiNode(char_num, 0)\n            self.char_num = char_num\n\n        def add(self, S):\n            v = self.root\n            for s in S:\n                if v[s] is None:\n                    v[s] = TreiNode(self.char_num, v.depth + 1)\n                v = v[s]\n            v.end = True\n\n        def exist(self, S):\n            v = self.root\n            for s in S:\n                if v[s] is None:\n                    return False\n                v = v[s]\n            if v.end:\n                return True\n            else:\n                return False\n\n    N, L = list(map(int, input().split()))\n    T = Trei(2)\n    for _ in range(N):\n        S = input().rstrip('\\n')\n        S = [int(s) for s in S]\n        T.add(S)\n\n    g = 0\n    st = [T.root]\n    while st:\n        v = st.pop()\n        for i in range(2):\n            if v[i] is None:\n                d = L - v.depth\n                g ^= d & -d\n            else:\n                st.append(v[i])\n    if g:\n        print('Alice')\n    else:\n        print('Bob')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nfrom collections import deque\n\nclass Node:\n    def __init__(self,depth):\n        self.depth=depth\n        self.left=None\n        self.right=None\n\ndef insert(node,s):\n    n=node\n    for i in range(len(s)):\n        t=s[i]\n        if t=='0':\n            if n.left is None:\n                n.left=Node(i+1)\n            n=n.left\n        else:\n            if n.right is None:\n                n.right=Node(i+1)\n            n=n.right\n\nclass Trie:\n    def __init__(self):\n        self.root=Node(0)\n    def insert(self,s:str):\n        insert(self.root,s)\n\nn,l=map(int,input().split())\nS=[input().strip() for _ in range(n)]\ntrie=Trie()\nfor s in S:\n    trie.insert(s)\nData=[]\nq=deque([trie.root])\n\ndef dfs(node):\n    if node.right is None and node.left is None:\n        return\n    if node.right is None or node.left is None:\n        Data.append(l-node.depth)\n    if node.right:\n        q.append(node.right)\n    if node.left:\n        q.append(node.left)\n\nwhile q:\n    dfs(q.popleft())\nxor=0\n\ndef Grundy(n):\n    ret=1\n    while n%2==0:\n        n//=2\n        ret*=2\n    return ret\n\nfor i in Data:\n    xor^=Grundy(i)\nprint('Alice' if xor else 'Bob')", "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\nINF = float('inf')\n\nN, L = list(map(int, input().split()))\nS = set()\nfor _ in range(N):\n    S.add(input())\n\n\n# \u8ffd\u52a0\u3067\u304d\u308b\u306e\u304c 01... \u3060\u3051\u3067\n# L \u304c 4 \u3068\u3059\u308b\u3068\n# 01: \u6b21\u306f\u306a\u3044\n# 010: 011 \u304c\u3042\u308b\n# 011: 010 \u304c\u3042\u308b\n# 0100: 011, 0101 \u304c\u3042\u308b\n# 0101: 011, 0100\n# 0110: 010, 0111\n# 0111: 010, 0110\n# \u5019\u88dc\u306e\u9577\u3055\u3068 L \u3060\u3051\u306b\u3088\u3063\u3066\u6b21\u306e\u5019\u88dc\u306e\u9577\u3055\u3068\u6570\u304c\u6c7a\u307e\u308b\ndef grundy(size):\n    \"\"\"\n    :param int size: \u5019\u88dc\u306e\u9577\u3055\n    :return:\n    \"\"\"\n    # gs = {0}\n    # g = 0\n    # for sz in range(size + 1, L + 1):\n    #     g ^= grundy(sz)\n    #     gs.add(g)\n    #\n    # i = 0\n    # while i in gs:\n    #     i += 1\n    # return i\n    i = 1\n    while (L - size + 1) % i == 0:\n        i *= 2\n    return i // 2\n\n\n# S \u306e\u5404\u8981\u7d20\u304b\u3089\u30c8\u30e9\u30a4\u6728\u3064\u304f\u308b\ntrie = {}\nfor s in S:\n    t = trie\n    for c in s:\n        if c not in t:\n            t[c] = {}\n        t = t[c]\n\n# \u5019\u88dc\u6587\u5b57\u5217\u306e\u9577\u3055\u306e\u30ea\u30b9\u30c8\nok_size_list = []\nchildren = deque()\nchildren.append((trie, 0))\nwhile len(children) > 0:\n    node, size = children.popleft()\n    # 0 \u304b 1 \u304b\u7247\u65b9\u3057\u304b\u884c\u3051\u306a\u304b\u3063\u305f\u3089\u3001\u884c\u3051\u306a\u3044\u65b9\u306f S \u306e prefix \u306b\u306a\u3089\u306a\u3044\n    # \u4e21\u65b9\u884c\u3051\u306a\u3044\u5834\u5408\u306f\u3069\u3046\u8ffd\u52a0\u3057\u3066\u3082 S \u306e\u3044\u305a\u308c\u304b\u304c prefix \u306b\u306a\u3063\u3066\u3057\u307e\u3046\u304b\u3089\u30c0\u30e1\n    if len(node) == 1:\n        ok_size_list.append(size + 1)\n    for c, child in node.items():\n        children.append((child, size + 1))\n\ng = 0\nfor size in ok_size_list:\n    g ^= grundy(size)\nif g != 0:\n    print('Alice')\nelse:\n    print('Bob')"]
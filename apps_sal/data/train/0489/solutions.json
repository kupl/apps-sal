["class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        width = 0\n        icandidate = [0]\n        for i in range(len(A)):\n            if A[i] < A[icandidate[-1]]:\n                icandidate.append(i)\n        for j in range(len(A) - 1, -1, -1):\n            while icandidate and A[icandidate[-1]] <= A[j]:\n                width = max(width, j - icandidate.pop())\n        return width", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        n = len(A)\n        for i in range(n):\n            if not stack or A[stack[-1]] > A[i]:\n                stack.append(i)\n        \n        res = 0\n        i = n-1\n        while i > res:\n            while stack and A[stack[-1]] <= A[i]:\n                res = max(res, i-stack[-1])\n                stack.pop()\n            i -= 1\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        sorted_indices = sorted(list(range(len(A))), key=lambda x: A[x])\n        minimum_index = sorted_indices[0]\n        answer = 0\n        \n        for i in range(1, len(sorted_indices)):\n            if sorted_indices[i] > minimum_index:\n                answer = max(answer, sorted_indices[i] - minimum_index)\n            else:\n                minimum_index = sorted_indices[i]\n        \n        return answer\n            \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        idx = sorted(range(n), key=A.__getitem__)\n        i = n\n        result = 0\n        for j in idx:\n            result = max(result, j - i)\n            i = min(i, j)\n        return result", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        idxs = sorted(range(len(A)), key=lambda i: A[i])\n\n        ramp = 0\n        mini = len(A)\n        for idx in idxs:\n            mini = min(mini, idx)\n            ramp = max(ramp, idx-mini)\n        return ramp", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack, ret = [], 0\n        for i, a in enumerate(A):\n            if not stack or A[stack[-1]] > a: stack.append(i)\n        for i in reversed(range(len(A))):\n            while stack and A[stack[-1]] <= A[i]:\n                ret = max(ret, i - stack.pop())\n        return ret", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        a = sorted(list(range(len(A))), key=lambda x: A[x])\n        ans = 0\n        m = float('inf')\n        for i in a:\n            ans = max(ans, i-m)\n            m = min(m, i)\n        return ans\n            \n            \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        rightMax = [0 for i in range(n+1)]\n        \n        for i in range(n-1, -1, -1):\n            rightMax[i] = max(rightMax[i+1], A[i])\n        \n        i = 0\n        j = 0\n        result = 0\n        \n        while i < n and j < n:\n            if A[i] <= rightMax[j]:\n                result = max(result, j - i)\n                j += 1\n            else:\n                i += 1\n        return result", "from operator import itemgetter\nclass Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        B = [(i,A[i]) for i in range(0,len(A))]\n        B.sort(key=itemgetter(1))\n        \n        curminidx = B[0][0]\n        res = 0\n        for i in range(1, len(A)):\n            curidx = B[i][0]\n            if curidx<curminidx:\n                curminidx = curidx\n            else:\n                res = max(res, curidx-curminidx)\n                \n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n  = len(A)\n        stack = []\n        for i in range(n):\n            if not stack or A[stack[-1]] >= A[i]:\n                stack.append(i)\n        \n        res = 0\n        for i in range(n - 1, -1, -1):\n            while stack and A[stack[-1]] <= A[i]:\n                res = max(res, i - stack.pop())\n                \n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        st_i = [a for a, _ in sorted(enumerate(A), key=lambda a: a[-1])]\n\n        mi = math.inf\n        mx =   -math.inf\n\n        for idx in st_i:\n            mi = min(idx,  mi)\n            mx = max(mx, idx - mi)\n\n        return mx\n", "class Solution(object):\n    def maxWidthRamp(self, A):\n        ans = 0\n        m = float('inf')\n        for i in sorted(range(len(A)), key = A.__getitem__):\n            ans = max(ans, i - m)\n            m = min(m, i)\n        return ans", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        largest = 0\n        \n        A = [(index, value) for index, value in enumerate(A)]\n        \n        A.sort(key=lambda x: x[1])\n        \n        minimum = float('inf')\n        for index, el in A:\n            largest = max(largest, index - minimum)\n            minimum = min(index, minimum)\n                    \n        return largest\n                \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        #stack maintains the index of strictly descending numbers\n        stack = []\n        for i,v in enumerate(A):\n            if i==0 or v<A[stack[-1]]:\n                stack.append(i)\n        ans = 0\n        for i in range(len(A)-1,-1,-1):\n            #if A[i]<A[stack[-1]], then it must be smaller than all\n            #the prev elements in stack, \n            #since stack is increasing (by popping)\n            \n            #then wait until larger elements\n            #maybe we can find longer ramp\n            while stack and A[i]>=A[stack[-1]]:\n                ans = max(ans,i-stack.pop())\n        return ans", "class Solution:\n    def maxWidthRamp(self, A):\n        sorted_idx = [x[0] for x in sorted(enumerate(A), key=lambda x: x[1])]\n        res = 0\n        min_idx = sorted_idx[0]\n        for idx in sorted_idx:\n            res = max(res, idx - min_idx)\n            min_idx = min(min_idx, idx)\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # sorting sol O(nlgn)\n        arr = [(a,i) for i, a in enumerate(A)]\n        arr.sort()\n        imin, res = float('inf'), 0\n        for _, i in arr:\n            res = max(res, i-imin)\n            imin = min(imin, i)\n        return res\n        \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        \n        for i, val in enumerate(A):\n            if not stack or val < A[stack[-1]]:\n                stack.append(i)\n                \n        maxWidth = 0\n        \n        for i in range(len(A)-1, -1, -1):\n            val = A[i]\n            while stack and val >= A[stack[-1]]:\n                maxWidth = max(maxWidth, i - stack.pop())\n            \n        return maxWidth\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # sorting sol O(nlgn)\n        arr = [(a,i) for i, a in enumerate(A)]\n        arr.sort()\n        # # first way is keep imin, start from left of arr\n        # imin, res = float('inf'), 0\n        # for _, i in arr:\n        #     res = max(res, i-imin)\n        #     imin = min(imin, i)\n        # return res\n        \n        # second way is keep imax, start from right of arr\n        imax, res = float('-inf'), 0\n        for _, i in reversed(arr):\n            res = max(res, imax-i)\n            imax = max(imax, i)\n        return res\n        \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        arr = sorted([(a,i) for i, a in enumerate(A)])\n        rindex = [0] * n\n        rindex[-1] = arr[-1][1]\n        for i in range(n-2, -1, -1):\n            rindex[i] = max(arr[i][1], rindex[i+1])\n        mx = 0\n        for i in range(n):\n            mx = max(mx, rindex[i]-arr[i][1])\n        return mx", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        \n        for i, val in enumerate(A):\n            if not stack or val < A[stack[-1]]:\n                stack.append(i)\n                \n        maxWidth = 0\n        \n        for i in range(len(A)-1, -1, -1):\n            val = A[i]\n            while stack and val >= A[stack[-1]]:\n                maxWidth = max(maxWidth, i - stack.pop())\n            \n        return maxWidth", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        ans = {}\n        for i in range(len(A)):\n            if A[i] in list(ans.keys()):\n                ans[A[i]].append(i)\n            else:\n                ans[A[i]]=[i]\n                \n        B=sorted(A,reverse=True)\n        #print(B)\n        max_index = -1\n        ramp=0\n        for key in B:\n            \n            l = max_index-ans[key][0]\n            ramp = max(ramp,l)\n            max_index = max(max_index,ans[key][len(ans[key])-1])\n        \n        return ramp\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        ans = 0\n                \n        l = [(n, i) for i, n in enumerate(A)]\n    \n        l.sort()\n        \n        mini = float('inf')\n        \n        for e in l:\n            mini = min(mini, e[1])\n            ans = max(ans, e[1] - mini)\n        return ans\n            \n        \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # decreasing stack\n        stack = []\n        for i,a in enumerate(A):\n            if not stack or a<A[stack[-1]]:\n                stack.append(i)\n        ans = 0\n        for i in range(len(A)-1,-1,-1):\n            while stack and A[stack[-1]]<=A[i]:\n                ans = max(ans, i-stack[-1])\n                stack.pop()\n        return ans", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        A_idx = []\n        for idx, a in enumerate(A):\n            A_idx.append((a, idx))\n            \n        A_idx_sorted = sorted(A_idx, key = lambda x: x[0])\n        \n        mn = float('inf')\n        res = 0\n        for a, idx in A_idx_sorted:\n            res = max(res, idx - mn)\n            mn = min(mn, idx)\n        return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        val_pos_list = [(value, pos) for pos, value in enumerate(A)]\n        val_pos_list.sort()\n        rightmost = len(A) - 1\n        visited_pos = set()\n        result = 0\n        \n        for value, pos in val_pos_list:\n            while rightmost in visited_pos:\n                rightmost -= 1\n            distance = max(0, rightmost - pos)\n            result = max(result, distance)\n            visited_pos.add(pos)\n        \n        return result\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        minLeft, maxRight = [A[0]] * n, [A[-1]] * n\n        for i in range(1, n):\n            minLeft[i] = min(minLeft[i - 1], A[i])\n            maxRight[n - i - 1] = max(maxRight[n - i], A[n - i - 1])\n        i = j = n - 1\n        res = 0\n        while i >= 0 and j >= 0:\n            if minLeft[i] <= maxRight[j]:\n                res = max(res, j - i)\n                i -= 1\n            else:\n                j -= 1\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        res = 0\n        m = float('inf')\n        for i in sorted(list(range(len(A))), key=lambda x: A[x]):\n            res = max(res, i - m)\n            m = min(m, i)\n        return res\n", "class Solution:\n    def find_right_max(self,arr):\n        right_max = [arr[-1]] \n        for i in range(len(arr)-2,-1,-1): \n            right_max.append(max(arr[i],right_max[-1]))\n            \n        return reversed(right_max)\n    \n    def maxWidthRamp(self, A: List[int]) -> int:\n        indices_sort =  [i[0] for i in sorted(enumerate(A), key=lambda x:x[1])]\n        set_ele = set(A) \n        indices = [] \n        for idx in indices_sort:\n            if idx in set_ele: \n                indices.append(idx)\n                \n        \n        right_max = self.find_right_max(indices_sort)\n        max_width_ramp = float('-inf')\n        for idx,right_max in zip(indices_sort, right_max): \n            max_width_ramp = max(right_max - idx, max_width_ramp)\n            \n        return max_width_ramp\n    \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # result = 0\n        # for i in range(len(A)):\n        #     for j in range(i+1,len(A)):\n        #         if A[i]<=A[j]:\n        #             result = max(result,j-i)\n        # return result\n        # Brute Force, Time Limit Exceeded\n        \n        # two pointer\n#         rMax = [0]*len(A)\n#         rMax[-1] = A[-1]\n#         for i in range(len(A)-1)[::-1]:\n#             rMax[i] = max(rMax[i+1],A[i])        \n#         L=R=0\n#         result=0\n        \n#         while R<len(A):\n#             while L<R and A[L]>rMax[R]:\n#                 L+=1\n#             result = max(result,R-L)\n#             R+=1\n#         return result\n\n        Aindex = [(a,i) for i,a in enumerate(A)]\n        Aindex.sort(key=lambda x:(x[0],x[1]))\n        mn=len(A)\n        ans=0\n        for a,i in Aindex:\n            ans=max(ans,i-mn)\n            mn=min(mn,i)\n        return ans\n        \n\n\n        # stack = []\n        # res = 0\n        # for i in range(len(A))[::-1]:\n        #     #print(i,stack)\n        #     if not stack or A[i] > stack[-1][0]:\n        #         stack.append([A[i], i])\n        #     else:\n        #         j = stack[bisect.bisect(stack, [A[i], i])][1]\n        #         print(stack,[A[i], i],bisect.bisect(stack, [A[i], i]),j)\n        #         res = max(res, j - i)\n        # return res\n    \n        # s = []\n        # res = 0\n        # for i, a in enumerate(A):\n        #     if not s or A[s[-1]] > a:\n        #         s.append(i)\n        # print(s)\n        # for j in range(len(A))[::-1]:\n        #     while s and A[s[-1]] <= A[j]:\n        #         res = max(res, j - s.pop())\n        # return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        collections = {}\n\n        for i, el in enumerate(A):\n            if el in collections:\n                collections[el][1] = i\n            else:\n                collections[el] = [i, i]\n\n        sorted_collections = sorted(collections.keys())\n        for i in range(1, len(sorted_collections)):\n            left, right = i, len(sorted_collections) - i - 1\n\n            collections[sorted_collections[left]][0] = min(collections[sorted_collections[left]][0], collections[sorted_collections[left - 1]][0])\n            collections[sorted_collections[right]][1] = max(collections[sorted_collections[right]][1], collections[sorted_collections[right + 1]][1])\n\n        result = 0\n        for el in collections.values():\n            result = max(result, el[1] - el[0])\n        return result", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        ind = [i for i in range(len(A))]\n        A, ind = zip(*sorted(zip(A, ind)))\n        m = len(A)-1\n        ans = 0\n        for i in range(len(A)):\n            ans = max(ind[i] - m, ans)\n            m = min(ind[i], m)\n        return ans", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        minHeap = [(A[i], i) for i in range(len(A))]\n        heapq.heapify(minHeap)\n        maxWidth = 0\n        minVal, minPos = heapq.heappop(minHeap)\n        \n        while minHeap:\n            val, pos = heapq.heappop(minHeap)\n            if val >= minVal:\n                maxWidth = max(maxWidth, pos - minPos)\n            if pos < minPos:\n                minVal = val\n                minPos = pos\n        \n        return maxWidth", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n  = len(A)\n        stack = []\n        for i in range(n):\n            if not stack or A[stack[-1]] > A[i]:\n                stack.append(i)\n        \n        res = 0\n        for i in range(n - 1, -1, -1):\n            while stack and A[stack[-1]] <= A[i]:\n                res = max(res, i - stack.pop())\n                \n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        left = [A[0],]\n        right = [A[-1],]\n        for i in range(1,len(A)):\n            left.append(min(A[i],left[i-1]))\n            right.append(max(A[len(A)-1-i],right[-1]))\n        right = right[::-1]\n        pt_l = 0\n        pt_r = 0\n        ans = 0\n        while pt_r <len(A):\n            if left[pt_l]<=right[pt_r]:\n                ans = max(ans,pt_r - pt_l)\n                pt_r+=1\n            else:\n                pt_l +=1\n        return ans", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # stack + binary search\n        descends = [(A[0], 0)]\n        def bs(t):\n            lo, hi = 0, len(descends) - 1\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if descends[mid] > t:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            return lo\n        rint = 0\n        for i in range(1, len(A)):\n            if A[i] < descends[-1][0]:\n                descends.append((A[i], i))\n            else:\n                left = bs((A[i], i))\n                # print(i, left, descends[left][1], descends)\n                rint = max(rint, i - descends[left][1])\n        return rint", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        s = []\n        \n        for i in range(len(A)):\n            if(not s or A[s[-1]] > A[i]):\n                s.append(i)\n        \n        j = len(A)-1\n        res = 0\n        while(j > res):\n            while(s and A[j] >= A[s[-1]]):\n                i = s.pop()\n                res = max(res, j-i)\n            j -= 1\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # Track index of min from left\n        idxsMin, res = [], 0\n        for i, x in enumerate(A):\n            if not idxsMin or A[idxsMin[-1]] > x:\n                idxsMin.append(i)\n        # Compare every element from right with the min element from left\n        for j in range(len(A))[::-1]:\n            while idxsMin and A[idxsMin[-1]] <= A[j]:\n                res = max(res, j - idxsMin.pop())\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        l = []\n        res = 0\n        for j in range(n):\n            if not l or A[l[-1]] > A[j]:\n                l.append(j)\n            else:\n                left, right = 0, len(l) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if A[l[mid]] <= A[j]:\n                        right = mid\n                    else:\n                        left = mid + 1\n                res = max(res, j - l[left])\n        return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # ans = 0\n        # m = float('inf')\n        # for i in sorted(range(len(A)), key = A.__getitem__):\n        #     m = min(i, m)\n        #     ans = max(ans, i - m)\n        # return ans\n        stack = []\n        # A.append(float('inf'))\n        ans = 0\n        for i, a in enumerate(A):\n            if (not stack) or stack[-1][0] > a:\n                stack.append((a, i))\n            else:\n                l, r = 0, len(stack) - 1\n                while l < r:\n                    # print(l, r)\n                    m = (r + l) // 2\n                    if stack[m][0] > a:\n                        l = m + 1\n                    else:\n                        r = m\n                    \n                if stack[l][0] <= a:\n                    ans = max(ans, i - stack[l][1])\n            # print(stack, ans)\n        return ans\n                        \n                        \n                    \n       \n        \n\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        res = 0\n        for i, num in enumerate(A):\n            if not stack or A[stack[-1]] > num:\n                stack.append(i)\n        for j in range(len(A) - 1, -1, -1):\n            while stack and A[stack[-1]] <= A[j]:\n                res = max(res, j - stack.pop())\n        return res", "class Solution:\n    def maxWidthRamp(self, x: List[int]) -> int:\n        ma=0\n        l=len(x)\n        st=[(x[0],0)]\n        for i in range(l):\n            if x[i]<st[-1][0]:\n                st.append((x[i],i))\n        for i in range(l-1,-1,-1):\n            while st!=[] and x[i]>=st[-1][0]:\n                a,b= st.pop(-1)\n                ma=max(i-b,ma)\n            if st==[]:break\n        return ma\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        n = len(A)\n        \n        stack = []\n        for i, num in enumerate(A):\n            if not stack or num < A[stack[-1]]:\n                stack.append(i)\n                \n        ans = 0\n        for j in range(n-1, -1, -1):\n            while stack and A[j] >= A[stack[-1]]:\n                ans = max(ans, j - stack.pop())\n        return ans", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        mx=0\n        ind=float('inf')\n        index=collections.defaultdict(list)\n        \n        for i,x in enumerate(A):\n            index[x].append(i)\n        print(index)\n        for num in sorted(A):\n            mx=max(mx,index[num][-1]-ind)\n            ind=min(ind,index[num][0])\n        return mx\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        res = 0\n        for i, a in enumerate(A):\n            if stack and A[stack[-1]]<=a:\n                j = len(stack)-1\n                \n                while j>=0 and A[stack[j]]<=a:\n                    # print(i, a, j, stack, A[stack[j]])\n                    res = max(res, i-stack[j])\n                    j -= 1\n            else:\n                stack.append(i)\n                \n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # \u7b2c\u4e00\u904d\u50bb\u50bb \u4e24\u6b21\u5faa\u73afTLE\n        # \u8fd8\u662f\u5e94\u8be5\u7528stack, \u5355\u8c03\u9012\u51cf\u6808 \u5c0f\u7684\u5165\u6808\n        \n        res = 0\n        stack = []\n        for i, a in enumerate(A):\n            if not stack or stack[-1][1] > a: # \u5c0f\u4e8e\u624d\u5165\u6808\uff0c \u76f8\u7b49\u5c31\u53ef\u4ee5\u53d6res\u4e86\n                stack.append((i,a))\n            else:\n                N = len(stack) -1  # \u8981\u904d\u5386\u6bcf\u4e00\u4e2a\u5165stack\u7684\n                while N >= 0 and stack[N][1]<= a:\n                    res = max(res,i-stack[N][0])\n                    N = N -1\n                    \n        return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack=[]\n        res=0\n        for i,a in enumerate(A):\n            if not stack or stack[-1][1]>a:\n                stack.append([i,a])\n            else:\n                j=len(stack)-1\n                while j>=0 and stack[j][1]<=a:\n                    res=max(res,i-stack[j][0])\n                    j-=1\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # \u7b2c\u4e00\u904d\u50bb\u50bb \u4e24\u6b21\u5faa\u73afTLE\n        # \u8fd8\u662f\u5e94\u8be5\u7528stack, \u5355\u8c03\u9012\u51cf\u6808 \u5c0f\u7684\u5165\u6808\n        \n        res = 0\n        stack = []\n        for i, a in enumerate(A):\n            if not stack or stack[-1][1] > a: # \u5c0f\u4e8e\u624d\u5165\u6808\uff0c \u76f8\u7b49\u5c31\u53ef\u4ee5\u53d6res\u4e86\n                stack.append((i,a))\n            else:\n                N = len(stack) -1 \n                while N >= 0 and stack[N][1]<= a:\n                    res = max(res,i-stack[N][0])\n                    N = N -1\n                    \n        return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        record = [[A[i], i] for i in range(len(A))]\n        record.sort(key = lambda x:[x[0], x[1]])\n        res = 0\n        pre_min = record[0][1]\n        for i in range(1,len(A)):\n            pre_min = min(pre_min, record[i][1])\n            res = max(res, record[i][1]-pre_min)\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # https://blog.csdn.net/fuxuemingzhu/article/details/85223568\n        N = len(A)\n        stack = []\n        res = 0\n        for i, a in enumerate(A):\n            if not stack or stack[-1][1] > a:\n                stack.append((i, a))\n            else:\n                x = len(stack) - 1\n                while x >= 0 and stack[x][1] <= a:\n                    res = max(res, i - stack[x][0])\n                    x -= 1\n        return res", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        N = 50001\n        sms = [None] * N\n        lgs = [None] * N\n\n        for i, x in enumerate(A):\n            if sms[x] is None:\n                sms[x] = i\n            lgs[x] = i\n\n        m = 0\n        ss = float('inf')\n        for x in range(N):\n            if lgs[x] is None:\n                continue\n            ss = min(ss, sms[x])\n            m = max(m, lgs[x] - ss)\n\n        return m", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack = []\n        #prev = float('inf')\n        for i,v in enumerate(A):\n            if i==0 or v<A[stack[-1]]:\n                stack.append(i)\n        \n        ans = 0\n        #print(stack)\n        for j in range(len(A)-1,-1,-1):\n            i = j\n            while stack and A[j]>=A[stack[-1]]:\n                i = stack.pop()\n            \n            ans = max(ans,j-i)\n        return ans    ", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        stack, ans = [], 0\n        for i, val in enumerate(A):\n            if not stack or A[stack[-1]] > val:\n                stack.append(i)\n        for j in reversed(list(range(len(A)))):\n            while stack and A[stack[-1]] <= A[j]:\n                ans = max(ans, j-stack.pop())\n        return ans\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        numbers = list((num, i) for i, num in enumerate(A))\n        numbers.sort()\n        \n        max_gap = 0\n        min_element = numbers[0][1]\n        \n        for i in range(1, len(A)):\n            min_element = min(min_element, numbers[i][1])\n            max_gap = max(max_gap, numbers[i][1] - min_element)\n        \n        return max_gap", "class Solution:\n    def maxWidthRamp(self, a: List[int]) -> int:\n        sis = sorted(list(range(len(a))), key=a.__getitem__)\n        return max(i - m for m, i in zip(itertools.accumulate(sis, min), sis))\n        \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        #11M coding start\n        \n        min_map, max_map = {}, {}\n        \n        for i, v in enumerate(A):\n            min_map[v] = min(i, min_map.get(v, i))\n            max_map[v] = max(i, max_map.get(v, i))\n        \n        min_idx = None\n        res = 0\n        for i in range(0, 50001):\n            if i not in min_map:\n                continue\n            \n            if min_idx is None:\n                min_idx = min_map[i]\n            else:\n                min_idx = min(min_idx, min_map[i])\n\n            if max_map[i] > min_idx:\n                res = max(res, max_map[i] - min_idx)\n                \n        return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        # result = 0\n        # for i in range(len(A)):\n        #     for j in range(i+1,len(A)):\n        #         if A[i]<=A[j]:\n        #             result = max(result,j-i)\n        # return result\n        # Brute Force, Time Limit Exceeded\n        \n        # two pointer\n#         rMax = [0]*len(A)\n#         rMax[-1] = A[-1]\n#         for i in range(len(A)-1)[::-1]:\n#             rMax[i] = max(rMax[i+1],A[i])        \n#         L=R=0\n#         result=0\n        \n#         while R<len(A):\n#             print(L,R,result)\n#             while L<R and A[L]>rMax[R]:\n#                 L+=1\n#             result = max(result,R-L)\n#             R+=1\n            \n#         return result\n\n        Aindex = [(a,i) for i,a in enumerate(A)]\n        Aindex.sort(key=lambda x:(x[0],x[1]))\n        mn=len(A)\n        ans=0\n        for a,i in Aindex:\n            print((i,ans,i-mn,mn))\n            ans=max(ans,i-mn)\n            mn=min(mn,i)\n        return ans\n        \n\n\n        # stack = []\n        # res = 0\n        # for i in range(len(A))[::-1]:\n        #     #print(i,stack)\n        #     if not stack or A[i] > stack[-1][0]:\n        #         stack.append([A[i], i])\n        #     else:\n        #         j = stack[bisect.bisect(stack, [A[i], i])][1]\n        #         print(stack,[A[i], i],bisect.bisect(stack, [A[i], i]),j)\n        #         res = max(res, j - i)\n        # return res\n    \n        # s = []\n        # res = 0\n        # for i, a in enumerate(A):\n        #     if not s or A[s[-1]] > a:\n        #         s.append(i)\n        # print(s)\n        # for j in range(len(A))[::-1]:\n        #     while s and A[s[-1]] <= A[j]:\n        #         res = max(res, j - s.pop())\n        # return res\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        \n        helper=[]\n        for i,x in enumerate(A):\n            helper.append((x,i))\n            \n        helper.sort(key=lambda x:x[0])\n        imin=helper[0][1]\n        maxlen=0\n        # print(helper)\n        for val,indx in helper:\n            if indx>=imin:\n                maxlen=max(maxlen,indx-imin)\n                \n            imin=min(imin,indx)\n            \n        return maxlen\n            \n            \n            \n            \n            \n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        \n        stack,n = [],len(A)\n        maxy = 0\n        i = 0\n        for i,v in enumerate(A):\n            if not stack or v<stack[-1][0]:\n                stack.append((v,i))\n                continue\n            \n            j = -1\n            while j>=-1*len(stack) and v>=stack[j][0]:\n                maxy = max(maxy, i-stack[j][1])\n                j-=1\n            \n                \n        return maxy", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        mx=0\n        ind=float('inf')\n        index=collections.defaultdict(list)\n        for i, x in enumerate(A):\n            index[x].append(i)\n            \n        for i in sorted(A):\n            mx=max(mx,index[i][-1]-ind)\n            ind=min(ind,index[i][0])\n        return mx\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        preList = [0]\n        ALen = len(A)\n        for i in range(1, ALen):\n            if A[i] < A[preList[-1]]:\n                preList.append(i)\n        # print(preList)\n        ans = 0\n        preR = len(preList)-1\n        for i in range(ALen-1, -1, -1):\n            l = 0\n            while preR > 0 and preList[preR] >= i:\n                preR -= 1\n            r = preR\n            # r = len(preList)-1\n            if A[i] < A[preList[l]] and A[i] >= A[preList[r]]:\n                while r > l:\n                    # print(l, r)\n                    m = (r+ l)//2\n                    if A[preList[m]] < A[i]:\n                        r = m\n                    elif A[preList[m]] > A[i]:\n                        l = m + 1\n                    else:\n                        l = m\n                        r = m - 1\n                # print(i, preList[l])\n                ans = max(ans, i - preList[l])\n            elif A[i] >= A[preList[l]]:\n                ans = max(ans, i - preList[l])\n                \n        return ans\n", "class Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        \n        stack,n = [],len(A)\n        maxy = 0\n        i = 0\n        for i,v in enumerate(A):\n            if stack and maxy+stack[0][1]>=n: break\n            if not stack or v<stack[-1][0]:\n                stack.append((v,i))\n                continue\n            \n            j = -1\n            while j>=-1*len(stack) and v>=stack[j][0]:\n                maxy = max(maxy, i-stack[j][1])\n                j-=1\n            \n                \n        return maxy", "from sortedcontainers import SortedList\n\nclass Solution:\n    def maxWidthRamp(self, A: List[int]) -> int:\n        li = list()\n        \n        for i,n in enumerate(A):\n            li.append((n,i))\n            \n        li.sort()\n        \n        ans = 0\n        \n        bt = SortedList()\n        \n        for pair in li:\n            n = pair[0]\n            i = pair[1]\n            # print(bt)\n            # print(i)\n            if len(bt) == 0:\n                bt.add(i)\n                continue\n            if bt[0] < i:\n                if i - bt[0] > ans:\n                    ans = i-bt[0]\n            bt.add(i)\n        \n        return ans\n"]
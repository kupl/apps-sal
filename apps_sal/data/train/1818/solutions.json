["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        nonlocal ls\n        ls=[]\n        di={0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j', 10: 'k', 11: 'l', 12: 'm', 13: 'n', 14: 'o', 15: 'p', 16: 'q', 17: 'r', 18: 's', 19: 't', 20: 'u', 21: 'v', 22: 'w', 23: 'x', 24: 'y', 25: 'z'}\n        def helper(root,s):\n            if(root==None):\n                return None\n            nonlocal ls\n            if(root.left==None and root.right==None):\n                ls.append(di[root.val]+s)\n            \n            helper(root.left,di[root.val]+s)\n            helper(root.right,di[root.val]+s)\n            \n        helper(root,\\\"\\\")\n        print(ls)\n        # tem=sorted(ls)[0]\n        tem=sorted(ls)\n        return tem[0]\n        # ans=\\\"\\\"\n        # for i in tem:\n        #     ans+=str(di[int(i)])\n        # return ans\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        \\\"\\\"\\\"\n        8:00 AM\n        \n        \\\"\\\"\\\"\n        if root == None:\n            return \\\"\\\"\n        result  = None\n        \n        charMappings = { i: chr(i+ord(\\\"a\\\")) for i in range(0, 26)}\n        \n        def helper(node, path):\n            nonlocal result\n            if node == None:\n                return\n            \n            if node.left == None and node.right == None:\n                char = charMappings.get(node.val)\n                string = \\\"\\\".join(  ((path+[char])[::-1]) )\n                if result == None or string < result:\n                    result = string\n                \n                return\n            char = charMappings.get(node.val)\n            helper(node.left, path+[char])\n            helper(node.right, path+[char])\n            \n        helper(root, [])\n        return result\n                ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        def check(root):\n            r = chr(root.val+97)\n            if root.left == None and root.right == None:\n                return [r]\n\n            r1 = []\n            r2 = []\n            if root.left  != None:\n                r1 = check(root.left )\n            if root.right != None:\n                r2 = check(root.right)\n            rtv = []\n            small = min(r1+r2)\n            #   \u524d\u7f00\u76f8\u540c\u7684\uff0c\u9700\u8981\u4fdd\u7559\uff0c\u56e0\u4e3a\u672a\u6765\u53ef\u80fd\u7ffb\u76d8\n            for x in r1 + r2:\n                if x.startswith(small):\n                    rtv.append(x+r)\n            rtv.insert(0, small+r)\n                    \n                \n\n            return rtv\n            pass\n        \n        #   \u8f93\u5165\u975e\u7a7a\uff1aThe number of nodes in the given tree will be between 1 and 8500.\n        rtv = check(root)\n        return min(rtv)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    # 10:35\n    def helper(self, root, path):\n        if root == None:\n            return path\n        else:\n            my_path = chr(ord('a') + root.val) + path\n            left = self.helper(root.left, my_path)\n            right = self.helper(root.right, my_path) \n            if root.left == None:\n                ans = right\n            elif root.right == None:\n                ans = left\n            else:\n                ans = min(left, right)\n            return ans\n        \n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        path = \\\"\\\"\n        return self.helper(root, path)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        def dfs(node, path):\n            nonlocal ans\n            if node:\n                path.append(letter_map[node.val])\n                if not node.left and not node.right:  # leaf\n                    path_str = ''.join(reversed(path))\n                    if not ans:\n                        ans = path_str \n                    elif path_str < ans:\n                        ans = path_str\n                else:\n                    pre_path = path.copy()\n                    if node.left:\n                        dfs(node.left, path)\n                    if node.right:\n                        dfs(node.right, pre_path)\n        letter_map = []\n        letter = 'a'\n        for i in range(26):\n            letter_map.append(letter)\n            letter = chr(ord(letter) + 1)\n            \n        ans = None\n        dfs(root, [])\n        \n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        # DFS from root to leaf\n        \n        \n        if not root:\n            return False\n        \n        stack = [(root, [])]\n        res = 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'\n        while stack:\n            curr_node, path = stack.pop()\n            \n            if not curr_node.left and not curr_node.right:\n                path.append(chr(97 + curr_node.val))\n                path_rev = reversed(path)\n                p = ''.join(path_rev)\n                res = min(res, p)\n                                     \n            if curr_node.left:\n                path1 = path.copy()\n                path1.append(chr(97 + curr_node.val))\n                stack.append((curr_node.left, path1))\n            if curr_node.right:\n                path1 = path.copy()\n                path1.append(chr(97 + curr_node.val))\n                stack.append((curr_node.right, path1))\n        return res\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        self.mapping = dict()\n        for val in range(26):\n            self.mapping[val] = chr(val + ord('a'))\n        \n        results = []\n        \n        self.dfs(root, [], results)\n        results.sort()\n        return results[0]\n        \n        \n    def dfs(self, node, path, results):\n        # if not node:\n        #     results.append(''.join([self.mapping[i] for i in path[::-1]]))\n        #     return\n        \n        if not node.left and not node.right:\n            path.append(node.val)\n            results.append(''.join([self.mapping[i] for i in path[::-1]]))\n            path.pop()\n            return\n        \n        path.append(node.val)\n        if node.left:\n            self.dfs(node.left, path, results)\n        if node.right:\n            self.dfs(node.right, path, results)\n        path.pop()\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport string\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:   \n        def pathToLeaf(root, letters):\n            nonlocal smallest\n            if root:\n                letters+=chr(root.val + ord('a'))\n                if root.right == None and root.left == None:\n                    reversed_letters = letters[::-1]\n                    if smallest > reversed_letters:\n                        smallest =  reversed_letters\n                else:\n                    pathToLeaf(root.left, letters)\n                    pathToLeaf(root.right,  letters)\n        \n        smallest = \\\"~\\\"\n        pathToLeaf(root, \\\"\\\")\n        return smallest\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport string\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:   \n        def pathToLeaf(root, letters, alphabet):\n            nonlocal smallest\n            if root:\n               # count_path+=root.val\n                letters+=alphabet[root.val]\n                if root.right == None and root.left == None:\n                    reversed_letters = letters[::-1]\n                    if smallest > reversed_letters:\n                        smallest =  reversed_letters\n                else:\n                    pathToLeaf(root.left, letters, alphabet)\n                    pathToLeaf(root.right,  letters, alphabet)\n        \n        alphabet = dict( (i, letter) for i, letter in enumerate(string.ascii_lowercase))\n        smallest = \\\"~\\\"\n        pathToLeaf(root, \\\"\\\", alphabet)\n        return smallest\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        \n        self.result = \\\"z\\\"*10000\n        stack = []\n        \n        def traverse(node: TreeNode) -> str :\n            if node:\n                stack.append(chr(node.val + 97))\n                if not node.left and not node.right:\n                    self.result = min(self.result, \\\"\\\".join(reversed(stack)))                    \n                traverse(node.left)\n                traverse(node.right)\n                stack.pop()                            \n        \n        traverse(root)\n        return self.result\n                    \n            \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\ndef helper(root: TreeNode) -> str:\n    if root is None:\n        return [\\\"\\\"]\n    \n    s = chr(ord('a') + root.val)\n    \n    if root.left is None and root.right is None:\n        return [s]\n    elif root.left is None:\n        return [_ + s for _ in helper(root.right)]\n    elif root.right is None:\n        return [_ + s for _ in helper(root.left)]\n    else:\n        left = [_ + s for _ in helper(root.left)]\n        right = [_ + s for _ in helper(root.right)]\n\n        return left + right\n\n\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        return min(helper(root))\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        res = [26]\n        def dfs(node, current):\n            nonlocal res\n            if not node.left and not node.right:\n                current.append(node.val)\n                length = len(res)\n                for i, n in enumerate(current[::-1]):\n                    if i < length and n < res[i]:\n                        res = current[::-1]\n                        return\n                    if i < length and n > res[i]:\n                        return\n                    if i >= length:\n                        return\n                res = current[::-1]\n                return\n            current.append(node.val)\n            if node.left:\n                dfs(node.left, current[:])\n            if node.right:\n                dfs(node.right, current[:])\n\n        dfs(root, [])\n        li = 'abcdefghijklmnopqrstuvwxyz'\n        ans = []\n        for i in res:\n            ans.append(li[i])\n        return ''.join(ans)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        lists = self.recursiveSmallest(root) \n        min_list = min(lists)\n        return ''.join(min_list)\n    def recursiveSmallest(self, node: TreeNode) -> List[str]:\n        if node is None:\n            return []\n        if node.left is None and node.right is None:\n            return [self.convert(node.val)]\n        lists = []\n        if node.left:\n            smallest_left = self.recursiveSmallest(node.left)\n            lists.extend(smallest_left)\n        if node.right:\n            smallest_right = self.recursiveSmallest(node.right)\n            lists.extend(smallest_right)\n        return [l + self.convert(node.val) for l in lists]\n    \n    def convert(self, value: int) -> str:\n        a_value = ord('a')\n        return chr(a_value + value)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        if root is None:\n            return ''\n        \n        stack = [[root]]\n        min_string = 'z'*9999\n        \n        while stack:\n            current = stack.pop()\n            if current[-1].left is None and current[-1].right is None:\n                min_string = min(min_string, ''.join(chr(65+i.val).lower() for i in reversed(current) ))\n            \n            if current[-1].left:\n                stack.append(current + [current[-1].left])\n            if current[-1].right:\n                stack.append(current+[current[-1].right])\n        return min_string\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    #string.ascii_lowercase\n    def smallestFromLeaf(self, root: TreeNode) -> str:\n        minStr = chr(ord('z')+1)\n        #print(minStr)\n        cList = []\n        def dfs(root):\n            nonlocal minStr\n            nonlocal cList\n            print(cList)\n            \n            cList.append(root.val)\n            if not root.left and not root.right:\n                minStr = min(minStr, ''.join(string.ascii_lowercase[i] for i in cList[::-1]))\n                cList.pop()\n                return\n            if root.left: dfs(root.left)\n            if root.right: dfs(root.right)\n            cList.pop()\n    \n            \n        dfs(root)\n        return minStr\n"]
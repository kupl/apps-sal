["from bisect import insort, bisect_left, bisect_right\nfrom math import ceil\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets={}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        insort(self.tweets[tweetName], time)\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        entry = self.tweets[tweetName]\n        diff = endTime - startTime\n        factor = 86400\n        if freq == 'minute':\n            factor = 60\n        elif freq == 'hour':\n            factor = 3600\n        buckets = math.ceil((diff + 1) / factor)\n        ans = [0]*buckets\n        start = bisect_left(entry, startTime)\n        end = bisect_right(entry, endTime)\n        for i in range(start, end):\n            time = entry[i]\n            d = (time - startTime) // factor\n            ans[d] += 1\n        return ans\n        \n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from bisect import insort, bisect_left, bisect_right\nfrom math import ceil\n\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        insort(self.tweets[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        entry = self.tweets[tweetName]\n        diff = endTime - startTime\n        factor = 86400\n        if freq == 'minute':\n            factor = 60\n        elif freq == 'hour':\n            factor = 3600\n        buckets = math.ceil((diff + 1) / factor)\n        ans = [0]*buckets\n        start = bisect_left(entry, startTime)\n        end = bisect_right(entry, endTime)\n        for i in range(start, end):\n            time = entry[i]\n            d = (time - startTime) // factor\n            ans[d] += 1\n        return ans\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    \n    FREQUENCE = {\n        'minute' : 60,\n        'hour' : 3600,\n        'day' : 24*3600,\n    }\n\n    def __init__(self):\n        self.tweets_dict = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        \n        if tweetName not in self.tweets_dict:\n            self.tweets_dict[tweetName] = []\n        \n        bisect.insort(self.tweets_dict.get(tweetName), time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if tweetName not in self.tweets_dict:\n            return []\n        \n        delta = TweetCounts.FREQUENCE[freq]\n        \n        num_intervals = (endTime - startTime) // delta + 1\n        \n        result = [0] * num_intervals\n        start =  bisect.bisect_left(self.tweets_dict.get(tweetName), startTime)\n        end =  bisect.bisect_right(self.tweets_dict.get(tweetName), endTime)\n    \n        \n        for t1 in range(start-1, end+1):\n            \n            if t1 < 0:\n                continue\n            if t1 >= len(self.tweets_dict.get(tweetName)):\n                continue\n            t = self.tweets_dict.get(tweetName)[t1]\n            if t<startTime or t>endTime:\n                continue\n            \n            index = (t - startTime) // delta\n            result[index] += 1\n        \n        return result\n", "class TweetCounts:\n\n    def __init__(self):\n        from bisect import bisect_left, bisect_right\n        from functools import lru_cache\n        self.tweets = {}\n        self.cache = {}\n        return\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tn, seconds = tweetName, time\n        if tn not in self.tweets: self.tweets[tn] = Counter()\n        self.tweets[tn] += Counter(dict([(seconds, 1)]))\n        return\n\n\n    def quantize(self, per_second_tweet_counter, valid_times, scale):\n        t = [((timekey-self.st)//scale, per_second_tweet_counter[timekey]) \n             for timekey in valid_times]\n        \n        qcnts, qkeys = {}, []\n        for tk, tc in t:\n            if tk not in qcnts:\n                qcnts[tk] = 0\n                qkeys.append(tk)\n            qcnts[tk] += tc\n\n        n = (self.et - self.st + 1) // scale\n        if (self.et - self.st + 1) % scale: n += 1\n        res = [0] * (n)\n        for tk in qkeys: res[tk] = qcnts[tk]\n        return res\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        M, H, D = 60, 60*60, 60*60*24\n        self.tn, self.st, self.et = tweetName, startTime, endTime\n        if self.tn not in self.tweets: return [0]\n\n        per_second_tweet_counter = self.tweets[self.tn]\n\n        key = (self.tn, self.st, self.et)\n        if key in self.cache:\n            valid_times = self.cache[key]\n        else:\n            valid_times = [timekey for timekey in per_second_tweet_counter\n                           if self.st <= timekey <= self.et]\n            self.cache[key] = valid_times\n            \n        if freq == 'minute':\n            return self.quantize(per_second_tweet_counter, valid_times, M)\n        if freq == 'hour':\n            return self.quantize(per_second_tweet_counter, valid_times, H)\n        if freq == 'day':\n            return self.quantize(per_second_tweet_counter, valid_times, D)\n        \n        return [0]\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.store[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 0\n        if freq == \\\"minute\\\":\n            delta = 60\n        elif freq == \\\"hour\\\":\n            delta = 3600\n        else:\n            delta = 86400\n\n\n        result=[0]* ((endTime-startTime)//delta +1)\n        if not self.store[tweetName]:\n            return result\n\n        times=sorted(self.store[tweetName])\n        for time in times:\n            if startTime<=time<=endTime:\n                result[(time-startTime)//delta]+=1\n\n        return result\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        from bisect import bisect_left, bisect_right\n        from functools import lru_cache\n        self.tweets = {}\n        self.cache = {}\n        return\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tn, seconds = tweetName, time\n        if tn not in self.tweets: self.tweets[tn] = Counter()\n        self.tweets[tn] += Counter(dict([(seconds, 1)]))\n        return\n\n\n    def quantize(self, per_second_tweet_counter, valid_times, scale):\n        t = [((timekey-self.st)//scale, per_second_tweet_counter[timekey]) \n             for timekey in valid_times]\n        \n        qcnts, qkeys = {}, []\n        for tk, tc in t:\n            if tk not in qcnts:\n                qcnts[tk] = 0\n                qkeys.append(tk)\n            qcnts[tk] += tc\n\n        n = (self.et - self.st + 1) // scale\n        if (self.et - self.st + 1) % scale: n += 1\n        res = [0] * (n)\n        for tk in qkeys: res[tk] = qcnts[tk]\n        return res\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        M, H, D = 60, 60*60, 60*60*24\n        self.tn, self.st, self.et = tweetName, startTime, endTime\n        if self.tn not in self.tweets: return [0]\n\n        per_second_tweet_counter = self.tweets[self.tn]\n\n        key = (self.tn, self.st, self.et)\n        if key in self.cache:\n            valid_times = self.cache\n        else:\n            valid_times = [timekey for timekey in per_second_tweet_counter\n                           if self.st <= timekey <= self.et]\n            \n        if freq == 'minute':\n            return self.quantize(per_second_tweet_counter, valid_times, M)\n        if freq == 'hour':\n            return self.quantize(per_second_tweet_counter, valid_times, H)\n        if freq == 'day':\n            return self.quantize(per_second_tweet_counter, valid_times, D)\n        \n        return [0]\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        # { 'tweet3': [1,3,1000,5]}\n        self.__tweets = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.__tweets:\n            self.__tweets[tweetName].append(time)\n        else:\n            self.__tweets[tweetName] = [time]\n        # print(self.__tweets)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if tweetName not in self.__tweets:\n            self.__tweets[tweetName] = []\n        \n        if freq == \\\"minute\\\":\n            delta = 60\n        elif freq == \\\"hour\\\":\n            delta = 3600\n        else: # day\n            assert(freq == \\\"day\\\"), freq\n            delta = 24*3600\n        \n        # create intervals:\n        nextIntervalStart = startTime\n        intervals = []\n        intervalCount = 1\n        while (endTime+1 > nextIntervalStart):\n            nextIntervalEnd = startTime + delta*intervalCount\n            intervals.append((nextIntervalStart, min(nextIntervalEnd,endTime+1)))\n            nextIntervalStart = nextIntervalEnd\n            intervalCount += 1\n        \n        self.__tweets[tweetName].sort()\n        result = []\n        index = 0\n        for interval in intervals:\n            result.append(0)\n            while (index < len(self.__tweets[tweetName]) \n                   and self.__tweets[tweetName][index] < interval[1]):\n                if self.__tweets[tweetName][index] >= interval[0]:\n                    result[-1] += 1\n                index += 1\n        \n        return result\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n\n# TestCases:\n\\\"\\\"\\\"\n[\\\"TweetCounts\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\",\\\"getTweetCountsPerFrequency\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\"]\n[[],[\\\"tweet3\\\",0],[\\\"tweet3\\\",60],[\\\"tweet3\\\",10],[\\\"minute\\\",\\\"tweet3\\\",0,59],[\\\"minute\\\",\\\"tweet3\\\",0,60],[\\\"tweet3\\\",120],[\\\"hour\\\",\\\"tweet3\\\",0,210]]\n\n[\\\"TweetCounts\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\",\\\"getTweetCountsPerFrequency\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\"]\n[[],[\\\"tweet3\\\",0],[\\\"tweet3\\\",60],[\\\"tweet3\\\",10],[\\\"minute\\\",\\\"tweet3\\\",0,59],[\\\"minute\\\",\\\"tweet3\\\",0,60],[\\\"tweet3\\\",120],[\\\"day\\\",\\\"tweet3\\\",0,210]]\n\n[\\\"TweetCounts\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\",\\\"getTweetCountsPerFrequency\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\"]\n[[],[\\\"tweet3\\\",0],[\\\"tweet3\\\",60],[\\\"tweet3\\\",10],[\\\"minute\\\",\\\"tweet3\\\",0,59],[\\\"minute\\\",\\\"tweet3\\\",0,60],[\\\"tweet3\\\",120],[\\\"hour\\\",\\\"tweet3\\\",0,0]]\n\n[\\\"TweetCounts\\\"]\n[[]]\n\n[\\\"TweetCounts\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\",\\\"getTweetCountsPerFrequency\\\",\\\"recordTweet\\\",\\\"getTweetCountsPerFrequency\\\",\\\"recordTweet\\\",\\\"recordTweet\\\", \\\"getTweetCountsPerFrequency\\\", \\\"getTweetCountsPerFrequency\\\"]\n[[],[\\\"tweet3\\\",0],[\\\"tweet3\\\",60],[\\\"tweet3\\\",10],[\\\"minute\\\",\\\"tweet3\\\",0,59],[\\\"minute\\\",\\\"tweet3\\\",0,30],[\\\"tweet3\\\",120],[\\\"hour\\\",\\\"tweet3\\\",0,210],[\\\"tweet3\\\",420],[\\\"tweet1\\\",120],[\\\"minute\\\",\\\"tweet3\\\",0,1000], [\\\"day\\\",\\\"tweet3\\\",0,500000]]\n\n\n\\\"\\\"\\\"", "class TweetCounts:\n\n    def __init__(self):\n        self.a = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        heapq.heappush(self.a[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if tweetName not in self.a:\n            return []\n        temp = list(self.a[tweetName])\n        q = []\n        while temp:\n            q.append(heapq.heappop(temp))\n        if freq == 'minute':\n            f = 60\n        elif freq == 'hour':\n            f = 3600\n        else:\n            f = 3600 * 24\n                \n        bucket_size = (endTime - startTime) // f + 1\n        ans = [0] * bucket_size\n        cur = 0\n        end = f + startTime\n        for t in q:\n            if t < startTime: continue\n            if t > endTime: break\n            i = (t - startTime) // f\n            ans[i] += 1\n        \n        return ans\n            \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    class TreeNode:\n        def __init__(self,time,val=1,left=None,right=None):\n            self.time = time\n            self.val = val\n            self.left = left\n            self.right = right\n            \n    def __init__(self):\n        self.tweets = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        def radd(root):\n            if root.time == time:\n                root.val += 1\n            elif root.time > time:\n                if root.left is None:\n                    root.left = self.TreeNode(time)\n                else:\n                    radd(root.left)\n            else:\n                if root.right is None:\n                    root.right = self.TreeNode(time)\n                else:\n                    radd(root.right)\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = self.TreeNode(time)\n        else:\n            radd(self.tweets[tweetName])\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        def rech(root,buckets,s):\n            if root is not None:\n                rech(root.left,buckets,s)\n                if startTime <= root.time <= endTime:\n                    while (startTime+len(buckets)*s)-1 < root.time: buckets.append(0)\n                    buckets[-1] += root.val\n                rech(root.right,buckets,s)\n            return buckets\n        s = 60 if freq == \\\"minute\\\" else 3600 if freq == \\\"hour\\\" else 86400\n        buckets = rech(self.tweets[tweetName],[0],s)\n        while (startTime+len(buckets)*s)-1 < endTime: buckets.append(0)\n        return buckets\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.lst = []\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.lst.append((time, tweetName))\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        seconds=[24*3600, 3600, 60]\n        F=[\\\"day\\\", \\\"hour\\\", \\\"minute\\\"]\n        idx = F.index(freq)\n        start = startTime\n        end = endTime\n        \n        lens = (end-start+1+seconds[idx]-1)//seconds[idx]\n        \n\n        rs = [0]*lens\n        for i, v in enumerate(self.lst):\n            t = v[0]\n            if t >= start and t <= end:\n                if v[1] == tweetName:\n                    #print(t, start, end, v[1])\n                    rs[(t-start)//seconds[idx]] += 1\n        return rs\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.map = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.map:\n            self.map[tweetName].append(time)\n        else:\n            self.map[tweetName] = [time] \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 0\n        if freq == \\\"minute\\\": \n            delta = 60\n        elif freq == \\\"hour\\\":\n            delta = 3600\n        else:\n            delta =60*60*24\n\n#         if(freq == 'minute'):\n#             secs = 60\n#             size = (endTime - startTime) / 60 + 1\n#         if(freq == 'hour'):\n#             secs = 3600\n#             size = (endTime - startTime) / 3600 + 1\n#         if(freq == 'day'):\n#             secs = 86400\n#             size = (endTime - startTime) / 86400 + 1\n                \n#         r = [0] * int(size)\n        \n#         for i in times:\n#             if(startTime <= i and i <= endTime):\n#                 index = int((i-startTime)/secs)\n#                 r[index] += 1\n        \n        #value list\n        self.map[tweetName].sort()\n        tweetTimes = self.map[tweetName]\n        \n        \n        size = (endTime-startTime)//delta+1\n        res = [0]*size\n             \n        #for loop that goes through time intervals and counts # of tweets in that interval\n        startRange = 0\n        endRange = 0\n        secs = delta\n        for i in range(0, (size)):\n            startRange = startTime + delta*i\n            endRange = min(startTime + delta*(i+1), endTime+1)\n\n            for tweetTime in tweetTimes:\n                if tweetTime >= endRange:\n                    break\n                if tweetTime >= startRange and tweetTime < endRange:\n                    index = int((tweetTime-startTime)/secs)\n                    res[index] +=1\n            \n        return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "import collections\nimport bisect\n\nclass TweetCounts:\n    \n    FREQ_TO_SECONDS = {\n        \\\"minute\\\": 60,\n        \\\"hour\\\": 60*60,\n        \\\"day\\\": 24*60*60,\n    }\n\n    def __init__(self):\n        self.tweets = collections.defaultdict(list)\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        \n        self.tweets[tweetName].insert(bisect.bisect_left(self.tweets[tweetName], time), time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = self.FREQ_TO_SECONDS[freq]\n        tweets = self.tweets.get(tweetName, [])\n        results = []\n        \n        if not tweets:\n            return []\n        \n        while startTime <= endTime:\n            upper_bound = min(endTime, startTime+delta-1)\n            values = [time for time in tweets if time>=startTime and time<=upper_bound]\n            results.append(len(values))\n            startTime += delta\n            \n        return results\n        \n        \n        \n        \n        \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        start = startTime\n        res = []\n        self.data[tweetName].sort()\n        while start <= endTime:\n            end = min(start + delta, endTime + 1)\n            res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n            start += delta\n        return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    \n    FREQUENCE = {\n        'minute' : 60,\n        'hour' : 3600,\n        'day' : 24*3600,\n    }\n\n    def __init__(self):\n        self.tweets_dict = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        \n        if tweetName not in self.tweets_dict:\n            self.tweets_dict[tweetName] = []\n        \n        bisect.insort(self.tweets_dict.get(tweetName), time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if tweetName not in self.tweets_dict:\n            return []\n        \n        delta = TweetCounts.FREQUENCE[freq]\n        \n        num_intervals = (endTime - startTime) // delta + 1\n        \n        result = [0] * num_intervals\n        \n        for t in self.tweets_dict[tweetName]:\n            if t < startTime:\n                continue\n            if t > endTime:\n                break\n            \n            index = (t - startTime) // delta\n            result[index] += 1\n        \n        return result\n", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):     \n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        start = startTime\n        res = []\n        self.data[tweetName].sort()\n        while start <= endTime:\n            end = min(start + delta, endTime + 1)\n            res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n            # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n            start += delta\n        return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = {} # {name:[n1,n2,n3]}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets.keys():\n            self.tweets[tweetName] = []\n        self.tweets[tweetName].append(time)\n        # self.tweets[tweetName].sort()\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if freq == \\\"hour\\\":\n            gap = 60*60\n        elif freq == \\\"day\\\":\n            gap = 24*60*60\n        else:\n            gap = 60\n            \n        res = []\n        if tweetName not in self.tweets.keys():\n            return res\n        \n        tm = self.tweets[tweetName]\n        \n        for i in range(startTime, endTime+1, gap):\n            sum=0\n            end = min(i+gap, endTime+1)\n            print(f\\\"i:{i} end:{end}\\\")\n            \n            for t in tm:\n                if t >= i and t < end:\n                    sum+=1\n            res.append(sum)\n            \n        return res\n        \n        \n            \n        \n                    \n                    \n                    \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime): \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # new_data = [x for x in self.data[tweetName] if startTime <= x <= endTime]\n        # delta_data = [(x - startTime) // delta for x in new_data]\n        # n = (endTime - startTime) // delta + 1\n        # res = [len([x for x in delta_data if x == i]) for i in range(n)]\n        # return res\n        \n        \n        \n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        start = startTime\n        res = []\n        while start <= endTime:\n            end = min(start + delta, endTime + 1)\n            res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n            # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n            start += delta\n        return res        \n\n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # start = startTime\n        # res = []\n        # self.data[tweetName].sort()\n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        start = startTime\n        res = []\n        while start <= endTime:\n            end = min(start + delta, endTime + 1)\n            res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n            start += delta\n        return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        left, right = 0, len(self.tweets[tweetName])\n        while left < right:\n            mid = left + (right-left)//2\n            if self.tweets[tweetName][mid]>=time:\n                right = mid\n            else:\n                left = mid+1\n        self.tweets[tweetName].insert(left, time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = {\\\"minute\\\": 60, \\\"hour\\\": 60*60, \\\"day\\\": 60*60*24}\n        interval = delta[freq]\n        num_intervals = (endTime - startTime) // interval + 1\n        count = [0] * num_intervals\n        for t in self.tweets[tweetName]:\n            if t<startTime:\n                continue\n            if t>endTime:\n                break\n            count[(t - startTime) // interval]+=1\n        return count\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        insort(self.tweets[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60\n        if freq == 'hour':\n            delta = 3600\n        elif freq == 'day':\n            delta = 86400\n        \n        pre = bisect_left(self.tweets[tweetName], startTime)\n        n = (endTime + 1 - startTime)//delta + (1 if (endTime+1-startTime) % delta != 0 else 0)\n        end, res = startTime, []\n        for _ in range(n):\n            end = min(end + delta, endTime + 1)\n            i = bisect_left(self.tweets[tweetName], end)\n            res.append(i - pre)\n            pre = i\n        return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.data = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.data[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        T, d = self.data[tweetName], 60 if freq == \\\"minute\\\" else (3600 if freq == \\\"hour\\\" else 86400)\n        # ans = [bisect.bisect(T, t+d) - bisect.bisect_left(T, t) for t in range(startTime, endTime, d)]\n        ans = [0]*((endTime-startTime)//d + 1)\n        if not T or endTime < T[0] or startTime > T[-1]:\n            return ans\n        i, l = 0, bisect.bisect_left(T, startTime)\n        r = bisect.bisect(T, endTime, lo=l)\n        #print(\\\"T, d, l, r, T[l:r], ans:\\\", T, d, l, r, T[l:r], ans)\n        for t in range(startTime+d, endTime+1, d):\n            m = bisect.bisect_left(T, t, lo=l, hi=r)\n            ans[i] = m-l\n            #print(\\\"i, l, m, ans:\\\", i, l, m, ans)\n            l = m; i += 1\n        ans[i] = r-l\n        return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n    \n    FREQUENCE = {\n        'minute' : 60,\n        'hour' : 3600,\n        'day' : 24*3600,\n    }\n\n    def __init__(self):\n        self.tweets_dict = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        \n        if tweetName not in self.tweets_dict:\n            self.tweets_dict[tweetName] = []\n        \n        left, right = 0, len(self.tweets_dict[tweetName])\n        # left bound\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.tweets_dict[tweetName][mid] == time:\n                right = mid\n            elif self.tweets_dict[tweetName][mid] > time:\n                right = mid\n            elif self.tweets_dict[tweetName][mid] < time:\n                left = mid + 1\n        self.tweets_dict[tweetName].insert(left, time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if tweetName not in self.tweets_dict:\n            return []\n        \n        delta = TweetCounts.FREQUENCE[freq]\n        \n        num_intervals = (endTime - startTime) // delta + 1\n        \n        result = [0] * num_intervals\n        \n        for t in self.tweets_dict[tweetName]:\n            if t < startTime:\n                continue\n            if t > endTime:\n                break\n            \n            index = (t - startTime) // delta\n            result[index] += 1\n        \n        return result", "class TweetCounts:\n\n    def __init__(self):\n        self.store = defaultdict(list)\n        self.delta = {'hour': 3600, 'minute': 60, 'day': 24 * 3600}\n        \n    def recordTweet(self, tn: str, time: int) -> None:\n        insort(self.store[tn], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        d = self.delta[freq]\n        ans = []\n        arr = self.store[tweetName]\n        \n        for st_time in range(startTime, endTime+1, d):\n            left = bisect_left(arr, st_time)\n            right = bisect_right(arr, min(endTime, st_time + d - 1))\n            \n            ans.append(right - left)\n        \n        return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\nfrom enum import Enum\nfrom math import ceil\n\nfrequency= Enum(\n    value='frequency',\n    names=[\n        ('minute', 60),\n        ('hour', 3600),\n        ('day', 86400)\n    ])\n\nclass TweetManager:\n    def __init__(self):\n        self.tweets = defaultdict(list)\n    \n    def __str__(self):\n        return str(self.tweets)\n    \n    def add_tweet(self, tweet_name, time):\n        self.tweets[tweet_name].append(time)\n        self.tweets[tweet_name].sort()\n    \n    def _find_start_index(self, history: List[int], start_time, min_index=None, max_index=None):\n        if min_index is None:\n            min_index = 0\n        if max_index is None:\n            max_index = len(history) - 1\n        if min_index > max_index:\n            return None\n        middle_index = int((max_index + min_index)/2)\n        #print(f'# find start index: middle_index={middle_index}, start_time={start_time}, min_index={min_index}, max_index={max_index}')\n        #print('# history[middle_index]: ', history[middle_index])\n        if history[middle_index] == start_time:\n            #print('# GOT IT')\n            return middle_index\n        if history[middle_index] > start_time:\n            result = self._find_start_index(history, start_time, min_index, middle_index-1)\n            if result is None:\n                #print('# sort of got it')\n                return middle_index\n            return result\n        if history[middle_index] < start_time:\n            return self._find_start_index(history, start_time, middle_index+1, max_index)\n            \n            \n    def _find_end_index(self, history: List[int], end_time, min_index=None, max_index=None):\n        if min_index is None:\n            min_index = 0\n        if max_index is None:\n            max_index = len(history) - 1\n        if min_index > max_index:\n            return None\n        middle_index = int((max_index + min_index)/2)\n        #print(f'# find end index: middle_index={middle_index}, end_time={end_time}, min_index={min_index}, max_index={max_index}')\n        #print('# history[middle_index]: ', history[middle_index])\n        if history[middle_index] == end_time:\n            #print('# GOT IT')\n            return middle_index\n        if history[middle_index] > end_time:\n            return self._find_end_index(history, end_time, min_index, middle_index-1)\n        if history[middle_index] < end_time:\n            result = self._find_end_index(history, end_time, middle_index+1, max_index)\n            if result is None:\n                #print('# sort of got it')\n                return middle_index\n            return result\n    \n    def _calculate_frequency(self, history: List[int], start_index, end_index, freq, end_time, start_time):\n        #print(f'# calculate frequency - end_time: {end_time}, start_time: {start_time}')\n        \n        if start_index is None or end_index is None:\n            history = []\n        else:\n            history = history[start_index:end_index+1]\n        \n        previous_bucket = None\n        result = []\n        bucket = None\n        for time_seconds in history:\n            bucket = 0 if (time_seconds+1-start_time) / frequency[freq].value <= 1 else int((time_seconds+1-start_time) / frequency[freq].value)\n            #print('### bucket: ', bucket)\n            \n            empty_buckets = bucket - (previous_bucket if previous_bucket else 0)\n            if previous_bucket is None:\n                empty_buckets +=1\n            if empty_buckets > 1:\n                #print('# empty buckets: ', empty_buckets)\n                for a in range(empty_buckets):\n                    result.append(0)\n            \n            if len(result) == bucket:\n                result.append(1)\n            else:\n                result[bucket] += 1\n                \n            previous_bucket = bucket\n        \n        max_bucket = 0 if (end_time-start_time) / frequency[freq].value < 1 else int((end_time-start_time) / frequency[freq].value)\n        \n        #print('### max bucket: ', max_bucket)\n        if bucket is None:\n            while max_bucket >= 0:\n                result.append(0)\n                max_bucket -= 1\n        else:\n            while max_bucket > bucket:\n                result.append(0)\n                max_bucket -= 1\n        \n        \n        return result\n    \n    def get_tweet_frequency(self, tweet_name: str, start_time: int, end_time: int, freq) -> List[int]:\n        #print()\n        start_index = self._find_start_index(self.tweets.get(tweet_name), start_time)\n        end_index = self._find_end_index(self.tweets.get(tweet_name), end_time)\n        #print(f'# start_index: {start_index}, end_index: {end_index}')\n        \n        result_frequency = self._calculate_frequency(self.tweets.get(tweet_name), start_index, end_index, freq, end_time, start_time)\n        \n        #print('# result frequency: ', result_frequency)\n        \n        #return start_index, end_index\n        return result_frequency\n        \n        \n    \n\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = TweetManager()\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets.add_tweet(tweetName, time)\n        \n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        #print('# tweet history: ', self.tweets)\n        return self.tweets.get_tweet_frequency(tweetName, startTime, endTime, freq)\n        \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\nfrom bisect import bisect_left, insort\nclass TweetCounts:\n\n    def __init__(self):\n        self.history = defaultdict(list)\n\n    def recordTweet(self, tweet, t):\n        insort(self.history[tweet], t)\n\n    def getTweetCountsPerFrequency(self, freq, tweet, s, e):\n        if freq == 'minute':\n            delta = 60\n        elif freq == 'hour':\n            delta = 3600\n        else:\n            delta = 86400\n        A, cur = self.history[tweet], s\n        res = []\n        while cur <= e:\n            nxt = min(cur+delta, e+1)\n            occurence = bisect_left(A, nxt) - bisect_left(A, cur)\n            res.append(occurence)\n            cur += delta\n        return res\n            \n            \n        \n        \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from sortedcontainers import SortedList\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(SortedList)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].add(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        tweets = self.tweets[tweetName]\n        if not tweets:\n            return []\n        \n        bucket_size = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 3600*24}[freq]\n        num_buckets = ceil((endTime-startTime)/bucket_size)\n        if (endTime - startTime) % bucket_size == 0:\n            num_buckets += 1\n        buckets = [0] * num_buckets\n        for t in tweets.irange(startTime, endTime):\n            bucket_idx = floor((t - startTime) / bucket_size)\n            buckets[bucket_idx] += 1\n            \n        return buckets\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n    SECONDS = {\n        \\\"minute\\\": 60,\n        \\\"hour\\\":   60 * 60,\n        \\\"day\\\":    60 * 60 * 24, \n    }\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.tweets[tweetName], time)\n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        count = math.ceil((endTime - startTime + 1) / TweetCounts.SECONDS[freq])\n        prev = bisect.bisect_left(self.tweets[tweetName], startTime)\n        ans = []\n        for i in range(1, count+1):\n            cur = bisect.bisect_left(self.tweets[tweetName],\n                                     min(startTime + i * TweetCounts.SECONDS[freq], endTime+1))\n            ans.append(cur - prev)\n            prev = cur\n        return ans", "class TweetCounts:\n\n    def __init__(self):\n        self.store = defaultdict(list)\n        self.delta = {'hour': 3600, 'minute': 60, 'day': 24 * 3600}\n        \n    def recordTweet(self, tn: str, time: int) -> None:\n        insort(self.store[tn], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        d = self.delta[freq]\n        ans = []\n        arr = self.store[tweetName]\n        \n        for st_time in range(startTime, endTime+1, d):\n            left = bisect_left(arr, st_time)\n            right = bisect_right(arr, min(endTime, st_time + d - 1)) - 1\n            \n            # print(st_time, st_time + d - 1, left, right)\n            \n            \n            ans.append(min(right - left + 1, len(arr)))\n        \n        return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.recorder = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.recorder[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        res, i, start = [], 1, startTime\n        while start <= endTime:\n            end = min(startTime + delta * i, endTime + 1)\n            res.append(bisect_left(self.recorder[tweetName], end) - bisect_left(self.recorder[tweetName], start))\n            start, i = end, i + 1\n        return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    FREQUENCEY_TO_SECONDS = {\n        'minute': 60,\n        'hour': 3600,\n        'day': 86400\n    }\n\n    def __init__(self):\n        self._data = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self._data[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = self.FREQUENCEY_TO_SECONDS.get(freq.lower(), None)\n        if not delta:\n            return []\n\n        i, result = startTime, []\n\n        while i <= endTime:\n            j = min(i + delta, endTime + 1)\n            left = bisect.bisect_left(self._data[tweetName], j)\n            right = bisect.bisect_left(self._data[tweetName], i)\n            result.append(left - right)\n            i += delta\n\n        return result", "import bisect\nfrom collections import defaultdict\n\nclass TweetCounts:\n\n    def __init__(self):\n        self._tweets = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self._tweets[tweetName].insert(\n            bisect.bisect_right(self._tweets[tweetName], time), time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        \n        result = []\n        while startTime <= endTime:\n            end = min(startTime + delta, endTime + 1)\n            result.append(\n                bisect.bisect_left(self._tweets[tweetName], end) -\n                    bisect.bisect_left(self._tweets[tweetName], startTime))\n            startTime += delta\n        return result\n            \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "import bisect\nfrom collections import defaultdict\n\nclass TweetCounts:\n\n    def __init__(self):\n        self._tweets = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self._tweets[tweetName].insert(\n            bisect.bisect_left(self._tweets[tweetName], time), time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        \n        result = []\n        while startTime <= endTime:\n            end = min(startTime + delta, endTime + 1)\n            result.append(\n                bisect.bisect_left(self._tweets[tweetName], end) -\n                    bisect.bisect_left(self._tweets[tweetName], startTime))\n            startTime += delta\n        return result\n            \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.a = defaultdict(list)\n\n    def recordTweet(self, tn: str, time: int) -> None:\n        bisect.insort(self.a[tn], time)\n       \n    def getTweetCountsPerFrequency(self, freq: str, tn: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        i = startTime\n        res = []\n        while i <= endTime:\n            j = min(i + delta, endTime+1)\n            res.append(bisect_left(self.a[tn], j) - bisect_left(self.a[tn], i))\n            i += delta\n        return res\n\n\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.a = defaultdict(list)\n\n    def recordTweet(self, tn: str, time: int) -> None:\n        bisect.insort(self.a[tn], time)\n       \n    def getTweetCountsPerFrequency(self, freq: str, tn: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        i = startTime\n        res = []\n        while i <= endTime:\n            j = min(i + delta, endTime+1)\n            res.append(bisect_left(self.a[tn], j) - bisect_left(self.a[tn], i))\n            i += delta\n        return res\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from sortedcontainers import SortedList\nclass TweetCounts:\n\n    def __init__(self):\n        self.timeStamps = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.timeStamps:\n            self.timeStamps[tweetName] = SortedList({})\n        self.timeStamps[tweetName].add(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = None\n        if freq == \\\"minute\\\":\n            delta = 60\n        elif freq == \\\"hour\\\":\n            delta = 3600\n        else:\n            delta = 86400\n        answer = []\n        ##need to essentially figure out the first tweet in self.timeStamps[tweetName] that comes at least at startTime and then go on by the delta until we see that we exceed endTime. We will have to stop along the way if our endTime is greater than current time plus delta and then append to answer and create new List.\n        if tweetName in self.timeStamps:\n            startIndex = self.timeStamps[tweetName].bisect_left(startTime)\n            timeStampLength = len(self.timeStamps[tweetName])\n            currentIndex = startIndex\n            lowerBound = startTime\n            upperBound = min(lowerBound+delta-1,endTime)\n            while True:##if we see that the currentIndex is already too large then we will have that the count = 0\n                count = 0\n                currentTime = self.timeStamps[tweetName][currentIndex] if currentIndex < timeStampLength else float('inf')##this will ensure that we still put in 0s for count if our timestamp is way to far ahead already\n                while currentTime >= lowerBound and upperBound >= currentTime:\n                    count += 1\n                    currentIndex += 1\n                    if currentIndex >= timeStampLength:\n                        break\n                    else:\n                        currentTime = self.timeStamps[tweetName][currentIndex]\n                answer.append(count)\n                lowerBound += delta\n                if lowerBound > endTime:\n                    break\n                else:\n                    upperBound = min(lowerBound+delta-1,endTime)\n        return answer\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.data = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.data[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        T, d = self.data[tweetName], 60 if freq == \\\"minute\\\" else (3600 if freq == \\\"hour\\\" else 86400)\n        ans = [0]*((endTime-startTime)//d + 1)\n        for i in range(bisect.bisect_left(T, startTime), bisect.bisect(T, endTime)):\n            ans[(T[i]-startTime)//d] += 1\n        return ans\n    \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n    FREQUENCEY_TO_SECONDS = {\n        'minute': 60,\n        'hour': 3600,\n        'day': 86400\n    }\n\n    def __init__(self):\n        self._data = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self._data[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = self.FREQUENCEY_TO_SECONDS.get(freq, None)\n        if not delta:\n            return []\n\n        i, result = startTime, []\n\n        while i <= endTime:\n            j = min(i + delta, endTime + 1)\n            left = bisect.bisect_left(self._data[tweetName], j)\n            right = bisect.bisect_left(self._data[tweetName], i)\n            result.append(left - right)\n            i += delta\n\n        return result", "freq_map = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 24*3600}\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweet_dict = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweet_dict:\n            self.tweet_dict[tweetName] = []\n        self.tweet_dict[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if tweetName not in self.tweet_dict:\n            return None\n        intervals = (-startTime + endTime)//freq_map[freq] + 1\n        output = [0]*intervals\n        for elem in self.tweet_dict[tweetName]:\n            if elem >= startTime and elem <= endTime:\n                output[(elem - startTime)//freq_map[freq]] += 1\n        return output\n\n        # Your TweetCounts object will be instantiated and called as such:\n        # obj = TweetCounts()\n        # obj.recordTweet(tweetName,time)\n        # param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in list(self.tweets.keys()):\n            bisect.insort(self.tweets[tweetName], time)\n        else:\n            self.tweets[tweetName] = [time]\n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if tweetName not in self.tweets:\n            return []\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400 \n        time_list = self.tweets[tweetName]\n        \n        size = int((endTime-startTime)//delta) +1\n        res = [0]*size\n        for t in time_list:\n            if startTime <= t <= endTime:\n                index = int((t-startTime)//delta)\n                res[index] += 1        \n        \n        # i = delta\n        # if len(time_list) == 1:\n        #     if time_list[0] < startTime or time_list[0] > endTime:\n        #         res.append([0]*size)\n        #         return res[0]\n        # while startTime <= endTime:\n        #     while i < startTime:\n        #         i+=delta\n        #     count = 0\n        #     for t in time_list:\n        #         if startTime <= t <i:\n        #             count += 1\n        #     res.append(count)\n        #     startTime += delta\n        #     i += delta\n        return res\n    \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    def __init__(self):\n        self.tweets = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \\\"minute\\\":\n            delta = 60\n        elif freq == \\\"hour\\\":\n            delta = 60*60\n        else:\n            delta = 60*60*24\n            \n        result = [0] * (((endTime - startTime) // delta) + 1)\n        for tweetTime in self.tweets[tweetName]:\n            if startTime <= tweetTime <= endTime:\n                result[((tweetTime - startTime) // delta)] += 1\n        return result\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict\nfrom bisect import insort, bisect_left\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.d = {'minute':60, 'hour': 3600, 'day': 86400}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        # insort(self.tweets[tweetName], time)\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        record = self.tweets[tweetName]\n        delta = self.d[freq]\n        # Solution 2: loop through the whole record O(n)\n        res = [0] * ((endTime - startTime) // delta + 1) # total interval\n        for time in record: # loop through time in record\n            if time < startTime or time > endTime:\n                continue\n            res[(time - startTime) // delta] += 1\n        return res\n        # Solution 1: Binary search O(logn)\n        # res = []\n        # i = startTime\n        # while i <= endTime:\n        #     j = min(i + delta, endTime + 1)\n        #     res.append(bisect_left(record, j) - bisect_left(record, i))\n        #     i += delta\n        # return res\n        \n        # not efficient solution\n        # low = bisect_left(record, startTime)\n        # res = [0]\n        # start, idx, j = startTime, low, 1\n        # print (record[idx:], startTime, endTime, delta)\n        # while idx < len(record) and record[idx] <= endTime:\n        #     if record[idx] < start + delta*j:\n        #         res[j-1] += 1\n        #     else:\n        #         j += 1\n        #         res.append(1)\n        #         start += delta\n        #     idx += 1\n        # print (res)\n        # return res\n\n\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets.setdefault(tweetName, []).append(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \\\"minute\\\":\n            seconds = 60\n        elif freq == \\\"hour\\\":\n            seconds = 3600\n        else:\n            seconds = 86400\n        rep = (endTime-startTime)//seconds+1\n        ans = [0 for _ in range(rep)]\n        for tweet_time in self.tweets[tweetName]:\n            if startTime<=tweet_time<=endTime:\n                ans[(tweet_time-startTime)//seconds]+=1\n        return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.map = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.map:\n            self.map[tweetName].append(time)\n        else:\n            self.map[tweetName] = [time] \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if freq == \\\"minute\\\": seconds = 60 \n        elif freq == \\\"hour\\\": seconds = 3600\n        else: seconds = 86400\n        \n        ans = [0] * ((endTime - startTime)//seconds + 1)\n        for t in self.map[tweetName]:\n            if startTime <= t <= endTime: ans[(t-startTime)//seconds] += 1\n        return ans \n        \n#         times = self.map[tweetName]\n        \n#         size = 0 \n#         delta = 0\n        \n#         if(freq == 'minute'):\n#             delta = 60\n#             size = (endTime - startTime) / delta + 1\n#         if(freq == 'hour'):\n#             delta = 3600\n#             size = (endTime - startTime) / delta + 1\n#         if(freq == 'day'):\n#             delta = 86400\n#             size = (endTime - startTime) / delta + 1\n                \n#         r = [0] * int(size)\n        \n#         for i in times:\n#             if(startTime <= i and i <= endTime):\n#                 index = int((i-startTime)/delta)\n#                 r[index] += 1\n\n#         return r  \n    \n    \n\n#         delta = 0\n#         if freq == \\\"minute\\\": \n#             delta = 60\n#         elif freq == \\\"hour\\\":\n#             delta = 3600\n#         else:\n#             delta =60*60*24\n        \n#         #value list\n#         self.map[tweetName].sort()\n#         tweetTimes = self.map[tweetName]\n        \n        \n#         size = (endTime-startTime)//delta+1\n#         res = [0]*size\n             \n#         #for loop that goes through time intervals and counts # of tweets in that interval\n#         startRange = 0\n#         endRange = 0\n#         secs = delta\n#         for i in range(0, (size)):\n#             startRange = startTime + delta*i\n#             endRange = min(startTime + delta*(i+1), endTime+1)\n\n#             for tweetTime in tweetTimes:\n#                 if tweetTime >= endRange:\n#                     break\n#                 if tweetTime >= startRange and tweetTime < endRange:\n#                     index = int((tweetTime-startTime)/secs)\n#                     res[index] +=1\n            \n#         return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.records = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.records[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        record = self.records[tweetName]\n        dt = 60\n        if freq == \\\"hour\\\":\n            dt *= 60\n        elif freq == \\\"day\\\":\n            dt *= 60 * 24\n        res = [0] * ((endTime-startTime) // dt + 1)\n        \n        for t in record:\n            if startTime <= t <= endTime:\n                idx = (t - startTime) // dt\n                res[idx] += 1\n        return res\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.memo = collections.defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.memo[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        lst = self.memo[tweetName]\n        lst = [t-startTime for t in lst if t>=startTime and t<=endTime]\n        if freq == 'minute':\n            freq = 60\n        elif freq== 'hour':\n            freq = 60*60\n        elif freq == 'day':\n            freq = 24*60*60\n        length, remainder = divmod(endTime-startTime+1, freq)\n        if remainder>0:\n            length += 1\n        res = [0 for _ in range(length)]\n        # print (t_max, freq)\n        for t in lst:\n            res[t//freq] += 1\n        return res\n        \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        times = self.tweets[tweetName]\n        \n        if freq == \\\"minute\\\":\n            seconds = 60\n        elif freq == \\\"hour\\\":\n            seconds = 60 * 60\n        elif freq == \\\"day\\\":\n            seconds = 60 * 60 * 24\n        \n        output_len = ((endTime - startTime)/seconds) + 1\n        output = [0] * int(output_len)\n        \n        for time in times:\n            if time >= startTime and time <= endTime:\n                index = int((time - startTime)/seconds)\n                output[index] += 1\n        \n        return output\n    \n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = collections.defaultdict(list)\n        self.convert = {'minute': 60, 'hour':3600, 'day': 86400}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        seconds = self.convert[freq]\n        ans = [0] * ((endTime - startTime)//seconds + 1)\n        for time in self.tweets[tweetName]:\n            if startTime <= time <= endTime:\n                ans[(time-startTime)//seconds] += 1\n        return ans           \n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\n\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        times = self.tweets[tweetName]\n        length = endTime - startTime\n        \n        if freq == \\\"minute\\\":\n            units = 60\n        elif freq == \\\"hour\\\":\n            units = 3600\n        else:\n            units = 3600 * 24\n            \n        intervals = {}\n        i = 0\n        for _ in range(startTime, endTime + 1, units):\n            intervals[i] = 0\n            i += 1\n            \n        for t in times:\n            if startTime <= t <= endTime:\n                interval = (t - startTime) // units\n                intervals[interval] += 1\n                \n        return list(intervals.values())\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = collections.defaultdict(list)\n        self.convert = {'minute': 60, 'hour':3600, 'day': 86400}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        ans = [0] * ((endTime - startTime)//self.convert[freq] + 1)\n        for t in self.tweets[tweetName]:\n            if startTime <= t <= endTime: ans[(t-startTime)//self.convert[freq]] += 1\n        return ans           \n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = dict()\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets.setdefault(tweetName, []).append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \\\"minute\\\": seconds = 60 \n        elif freq == \\\"hour\\\": seconds = 3600\n        else: seconds = 86400\n        \n        ans = [0] * ((endTime - startTime)//seconds + 1)\n        for t in self.tweets[tweetName]:\n            if startTime <= t <= endTime: ans[(t-startTime)//seconds] += 1\n        return ans           \n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict\n\nimport bisect\n\nclass TweetCounts:\n\n  def __init__(self):\n    self.T = defaultdict(lambda: [False, []])\n\n  def recordTweet(self, tweetName: str, time: int) -> None:\n    self.T[tweetName][0] = False\n    self.T[tweetName][1].append(time)\n\n  def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n    delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n    if not self.T[tweetName][0]:\n      self.T[tweetName][1].sort()\n    ans = []\n    s = startTime\n    i = bisect.bisect_left(self.T[tweetName][1], s)\n    while s <= endTime:\n      e = min(s + delta, endTime + 1)\n      j = bisect.bisect_left(self.T[tweetName][1], e)\n      ans.append(j - i)\n      s, i = e, j\n    return ans\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    \n    deltaDic = {\n        'minute': 60, \n        'hour': 3600,\n        'day': 24 * 3600,\n    }\n\n    def __init__(self):\n        self.tweetDic = {}\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if not tweetName in self.tweetDic:\n            self.tweetDic[tweetName] = []\n        self.tweetDic[tweetName].append(time)\n        self.tweetDic[tweetName].sort()\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if not tweetName in self.tweetDic:\n            return []\n        \n        delta = self.deltaDic[freq]\n        output = [0] * ((endTime - startTime) // delta + 1)\n        for t in self.tweetDic[tweetName]:\n            if t < startTime:\n                continue\n            elif t > endTime:\n                continue\n            else:\n                idx = (t - startTime) // delta\n                output[idx] += 1\n        \n        return output\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.a = defaultdict(list)\n\n    def recordTweet(self, tn: str, time: int) -> None:\n        bisect.insort(self.a[tn], time)\n       \n    def getTweetCountsPerFrequency(self, freq: str, tn: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        i = startTime\n        res = []\n        while i <= endTime:\n            j = min(i + delta, endTime+1)\n            res.append(bisect_left(self.a[tn], j) - bisect_left(self.a[tn], i))\n            i += delta\n        return res", "class TweetCounts:\n\n    def __init__(self):\n        self.d={}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.d:\n            self.d[tweetName]=[time]\n        else:\n            self.d[tweetName].append(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq=='minute':\n            s=60\n        elif freq=='hour':\n            s=3600\n        else:\n            s=3600*24\n        \n        intervals=(endTime-startTime)//s+1\n        \n        res=[0]*intervals\n        times=self.d[tweetName]\n        for t in times:\n            if startTime<=t<=endTime:\n                i=(t-startTime)//s\n                res[i]+=1\n        return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\nTIME_OFFSETS = {\n    \\\"minute\\\": 60,\n    \\\"hour\\\": 60 * 60,\n    \\\"day\\\": 24 * 60 * 60\n}\n\nclass TweetCounts:\n\n    def __init__(self):\n        self._tweets = defaultdict(list)\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tweets = self._tweets[tweetName]\n        \n        pos = bisect_left(tweets, time)\n        self._tweets[tweetName] = tweets[:pos] + [time] + tweets[pos:]\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        tweets = self._tweets[tweetName]\n        if not tweets:\n            return 0\n        \n        offset = TIME_OFFSETS[freq]\n        result = []\n        \n        for t in range(startTime, endTime + 1, offset):\n            t2 = min(endTime, t + offset - 1)\n            pos = bisect_left(tweets, t)\n            end_pos = bisect_right(tweets, t2)\n            result.append(end_pos - pos)\n            pos = end_pos\n\n        return result\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets=defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        count=0\n        den=0\n        size = 0 \n        if freq=='minute':\n            den=60\n            size=(endTime-startTime)//60+1\n        elif freq=='hour':\n            den=3600\n            size=(endTime-startTime)//3600+1\n        else:\n            den=86400\n            size =(endTime-startTime)//86400+1\n        op=[0]*size\n        \n        for t in self.tweets[tweetName]:\n            if(startTime<=t and t<=endTime):\n                idx=(t-startTime)//den\n                op[idx]+=1\n\n        return op         \n        \n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "# 832\nclass TweetCounts:\n\n    def __init__(self):\n      self.log = defaultdict(list)\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n      self.log[tweetName].append(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n      ret = []\n      events = sorted([t for t in self.log[tweetName] if startTime <= t <= endTime])\n      ei = 0\n      time = startTime\n      delta = {'minute': 60, 'hour': 3600, 'day': 24 * 3600}[freq]\n      \n      #print(events)\n      \n      cur = 0\n      while time <= endTime:\n        \n        if ei == len(events):\n          ret.append(cur)\n          cur = 0\n          time += delta\n          continue\n          \n        if events[ei] < time:\n          ei += 1\n        elif time + delta <= events[ei]:\n          ret.append(cur)\n          time += delta\n          cur = 0\n        else:\n          assert time <= events[ei] < time + delta\n          cur += 1\n          ei += 1\n      \n      return ret\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tw = collections.defaultdict(list)\n        self.duration = {'minute':60, 'hour':3600, 'day':86400 }\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if not self.tw[tweetName]:\n            self.tw[tweetName].append(time)\n        else:\n            ind = bisect.bisect(self.tw[tweetName], time)\n            self.tw[tweetName] = self.tw[tweetName][:ind] + [time] + self.tw[tweetName][ind:]\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        res = []\n        \n        q = self.tw[tweetName]\n        \n        s = startTime\n        while s <= endTime:\n            e = min(endTime, s + self.duration[freq]-1)            \n            ind1 = bisect.bisect_left(q, s)\n            ind2 = bisect.bisect_right(q, e, lo=ind1)\n            res.append(ind2-ind1)\n            s = e+1\n            \n        return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):    \n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        new_data = [x for x in self.data[tweetName] if startTime <= x <= endTime]\n        delta_data = [(x - startTime) // delta for x in new_data]\n        n = (endTime - startTime) // delta + 1\n        res = [len([x for x in delta_data if x == i]) for i in range(n)]\n        return res\n        \n        \n        \n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res        \n\n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # start = startTime\n        # res = []\n        # self.data[tweetName].sort()\n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime): \n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        new_data = [x for x in self.data[tweetName] if startTime <= x <= endTime]\n        delta_data = [(x - startTime) // delta for x in new_data]\n        n = (endTime - startTime) // delta + 1\n        res = [len([x for x in delta_data if x == i]) for i in range(n)]\n        return res\n        \n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # new_data = [x for x in self.data[tweetName] if startTime <= x <= endTime]\n        # delta_data = [(x - startTime) // delta for x in new_data]\n        # n = (endTime - startTime) // delta + 1\n        # res = [len([x for x in delta_data if x == i]) for i in range(n)]\n        # return res\n        \n        \n        \n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res        \n\n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # start = startTime\n        # res = []\n        # self.data[tweetName].sort()\n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n# approach 1:\n# - record tweets organized by tweet name\n# - compute freqs on demand\n  \n  def __init__(self):\n    self.tweets = {} # tweetName: {time: count}\n\n  def recordTweet(self, tweetName: str, time: int) -> None:\n    self.tweets.setdefault(tweetName, {}).setdefault(time, 0)\n    self.tweets[tweetName][time] += 1\n\n  def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n    eligible = []\n    \n    for (time, count) in list(self.tweets.get(tweetName, {}).items()):\n      if startTime <= time <= endTime:\n        eligible.append((time, count))\n    \n    if 'minute' == freq:\n      samples = 60\n    elif 'hour' == freq:\n      samples = 3600\n    elif 'day' == freq:\n      samples = 86400\n    else:\n      raise RuntimeError(freq)\n      \n    num_results = 1 + ((endTime - startTime) // samples)\n    results = [0] * num_results\n    \n    for (time, count) in eligible:\n      offset = (time - startTime)\n      if 'minute' == freq:\n        offset //= 60\n      elif 'hour' == freq:\n        offset //= 3600\n      elif 'day' == freq:\n        offset //= 86400\n      results[offset] += count\n    return results\n  \n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict\n\nclass TweetCounts:\n    def __init__(self):\n        self.data = defaultdict(list)\n        \n    def recordTweet(self, tweetName, time):\n        self.data[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime): \n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        new_data = [x for x in self.data[tweetName] if startTime <= x <= endTime]\n        delta_data = [(x - startTime) // delta for x in new_data]\n        n = (endTime - startTime) // delta + 1\n        res = [len([x for x in delta_data if x == i]) for i in range(n)]\n        return res\n        \n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # start = startTime\n        # res = []\n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     start += delta\n        # return res\n        \n        # delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        # start = startTime\n        # res = []\n        # self.data[tweetName].sort()\n        # while start <= endTime:\n        #     end = min(start + delta, endTime + 1)\n        #     res.append(len([x for x in self.data[tweetName] if start <= x < end]))\n        #     # res.append(bisect_left(self.data[tweetName], end) - bisect_left(self.data[tweetName], start))\n        #     start += delta\n        # return res\n\n# class TweetCounts:\n#     def __init__(self):\n#         self.data = defaultdict(list)\n        \n#     def recordTweet(self, tweetName, time):\n#         bisect.insort(self.data[tweetName], time)\n        \n#     def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.data[tweetName], j) - bisect_left(self.data[tweetName], i))\n#             i += delta\n#         return res\n\n\n# from collections import defaultdict\n# class TweetCounts:\n\n#     def __init__(self):\n#         self.a = defaultdict(list)\n        \n\n#     def recordTweet(self, tweetName: str, time: int) -> None:\n#         bisect.insort(self.a[tweetName], time)\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n#         i = startTime\n#         res = []\n#         while i <= endTime:\n#             j = min(i + delta, endTime + 1)\n#             res.append(bisect_left(self.a[tweetName], j) - bisect_left(self.a[tweetName], i))\n#             i += delta\n#         return res\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.dict = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if(tweetName not in self.dict):\n            self.dict[tweetName] = [time]\n        else:\n            self.dict[tweetName].append(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        times = self.dict[tweetName]\n        \n        size = 0 \n        secs = 0\n        \n        if(freq == 'minute'):\n            secs = 60\n            size = (endTime - startTime) / 60 + 1\n        if(freq == 'hour'):\n            secs = 3600\n            size = (endTime - startTime) / 3600 + 1\n        if(freq == 'day'):\n            secs = 86400\n            size = (endTime - startTime) / 86400 + 1\n                \n        r = [0] * int(size)\n        \n        for i in times:\n            if(startTime <= i and i <= endTime):\n                index = int((i-startTime)/secs)\n                r[index] += 1\n\n        return r", "class TweetCounts:\n\n    def __init__(self):\n        self.lookup = collections.defaultdict(list)\n        self.convert = {'minute': 60, 'hour':3600, 'day': 86400}\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.lookup[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        seconds = self.convert[freq]\n        ans = [0] * ((endTime-startTime)//seconds+1)\n        for time in self.lookup[tweetName]:\n            if startTime <= time <= endTime:\n                ans[(time-startTime)//seconds] += 1\n                \n        return ans\n                    \n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    MAP = {\n            'minute': 60,\n            'hour': 60 * 60,\n            'day': 24 * 60 * 60\n            }\n\n    def __init__(self):\n        self.data = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.data[tweetName].append(time)\n        self.data[tweetName].sort()\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        data = self.data[tweetName]\n        index = 0\n\n        while index < len(data) and data[index] < startTime:\n            index += 1\n\n        ans = []\n        tmp = 0\n        k = 0\n        delta = self.MAP[freq]\n        while startTime + k * delta <= endTime:\n            end = min(startTime + delta * (k + 1), endTime + 1)\n            if index >= len(data) or data[index] >= end:\n                ans.append(tmp)\n                tmp = 0\n                k += 1\n            else:\n                tmp += 1\n                index += 1\n        return ans", "from bisect import insort, bisect_left, bisect_right\nfrom math import ceil\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets={}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = []\n        insort(self.tweets[tweetName], time)\n        \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        entry = self.tweets[tweetName]\n        diff = endTime - startTime\n        factor = 86400\n        if freq == 'minute':\n            factor = 60\n        elif freq == 'hour':\n            factor = 3600\n        buckets = math.ceil((diff + 1) / factor)\n        ans = [0]*buckets\n        start = bisect_left(entry, startTime)\n        end = bisect_right(entry, endTime)\n        for i in range(start, end):\n            time = entry[i]\n            d = (time - startTime) // factor\n            ans[d] += 1\n        return ans\n        '''ans=[]\n        if freq=='minute':\n            q=endTime//60\n            p=startTime//60\n            for j in range(p,q+1):\n                count=0\n                for i in range(len(self.tname)):\n                    if self.tname[i]==tweetName:\n                        if startTime+j*60<=self.t[i]<min(startTime+(j+1)*60,endTime+1):\n                            count+=1\n                ans.append(count)\n        elif freq=='hour':\n            q=endTime//3600\n            p=startTime//3600\n            for j in range(p,q+1):\n                count=0\n                for i in range(len(self.tname)):\n                    if self.tname[i]==tweetName:\n                        if startTime+j*3600<=self.t[i]<min(startTime+(j+1)*3600,endTime+1):\n                            count+=1\n                ans.append(count)\n        else:\n            q=endTime//(3600*24)\n            p=startTime//(3600*24)\n            for j in range(p,q+1):\n                count=0\n                for i in range(len(self.tname)):\n                    if self.tname[i]==tweetName:\n                        if startTime+j*(24*3600)<=self.t[i]<min(startTime+(j+1)*(3600*24),endTime+1):\n                            count+=1\n                ans.append(count)\n        return ans'''\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from sortedcontainers import SortedList\n\nclass TweetCounts:\n    freq_seconds = {\n        'minute': 60,\n        'hour': 3600,\n        'day': 86400,\n    }\n    \n    def __init__(self):\n        self.tweets: Dict[str, List[int]] = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweets:\n            self.tweets[tweetName] = SortedList()\n        self.tweets[tweetName].add(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        interval = self.freq_seconds[freq]\n        counts = []\n        times = self.tweets.get(tweetName, [])\n        bucket_start = startTime\n        index_start = times.bisect_left(bucket_start)\n        while bucket_start <= endTime:\n            bucket_end = min(bucket_start + interval, endTime + 1)\n            index_end = times.bisect_left(bucket_end)\n            counts.append(index_end - index_start)\n            bucket_start = bucket_end\n            index_start = index_end\n        return counts\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.d={}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if(tweetName in self.d):\n            self.d[tweetName].append(time)\n        else:\n            self.d[tweetName]=[time]\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if(tweetName not in self.d):\n            return [0]\n        a=self.d[tweetName]\n        if(freq==\\\"minute\\\"):\n            c=[0 for i in range(1+((endTime-startTime)//60))]\n            for i in a:\n                if(i>=startTime)and(i<=endTime):\n                    c[(i-startTime)//60]+=1\n            return c\n        if(freq==\\\"hour\\\"):\n            c=[0 for i in range(1+((endTime-startTime)//3600))]\n            for i in a:\n                if(i>=startTime)and(i<=endTime):\n                    c[(i-startTime)//3600]+=1\n            return c\n        if(freq==\\\"day\\\"):\n            c=[0 for i in range(1+((endTime-startTime)//86400))]\n            for i in a:\n                if(i>=startTime)and(i<=endTime):\n                    c[(i-startTime)//86400]+=1\n            return c\n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.secondsMap = {\n\\t\\t\\t\\\"day\\\": 86400,\n\\t\\t\\t\\\"hour\\\": 3600,\n\\t\\t\\t\\\"minute\\\": 60\n\\t\\t}\n        self.tweets = {}\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.tweets:\n            self.tweets[tweetName].append(time)\n        else:\n            self.tweets[tweetName] = [time]\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        seconds = self.secondsMap[freq]\n        bucket_size = int((endTime - startTime)/seconds)+1\n        buckets = [0]*bucket_size\n        if tweetName not in self.tweets:\n            return []\n        else:\n            for t in self.tweets[tweetName]:\n                if t >= startTime and t<= endTime:\n                    bucket_index = int((t - startTime)/seconds)\n                    buckets[bucket_index] += 1\n        return buckets\n                    \n                \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from typing import List\nfrom sortedcontainers import SortedList\nfrom collections import defaultdict\n\nSECONDS_PER_MINUTE = 60\nSECONDS_PER_HOUR = 60*SECONDS_PER_MINUTE\nSECONDS_PER_DAY = 24*SECONDS_PER_HOUR\nINTERVAL_LENGTH = {\n    'minute': SECONDS_PER_MINUTE,\n    'hour': SECONDS_PER_HOUR,\n    'day': SECONDS_PER_DAY,\n}\n\nclass TweetCounts:\n    def __init__(self):\n        self.tweets = defaultdict(SortedList)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        # print(f'record {tweetName} at {time}')\n        self.tweets[tweetName].add(time)\n        # print(f'tweets[tweetName]: {self.tweets[tweetName]}')\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        # print(f'freq={freq} tweetName={tweetName} startTime={startTime} endTime={endTime}')\n\n        if freq not in INTERVAL_LENGTH:\n            raise Exception(f'Expected freq to be one of {INTERVAL_LENGTH.keys()}, got {freq} instead')\n\n        if tweetName not in self.tweets:\n            raise Exception(f'Unknown tweet: {tweetName}')\n\n        intervalLength = INTERVAL_LENGTH[freq]\n        numIntervals = (endTime - startTime + intervalLength) // intervalLength\n\n        counts = []\n        for i in range(numIntervals):\n            intervalStart = startTime + i*intervalLength\n            intervalEnd = min(intervalStart + intervalLength, endTime + 1)\n            matchingTimes = self.tweets[tweetName].irange(minimum=intervalStart, maximum=intervalEnd, inclusive=(True, False))\n            counts.append(len(list(matchingTimes)))\n\n        # print(f'counts: {counts}')\n        return counts\n", "import bisect\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.td = dict()\n        self.incrDict = {'minute':60,'hour':60*60,'day':24*60*60}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.td[tweetName] = self.td.get(tweetName,list())\n        self.td[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if tweetName not in self.td:\n            return []\n        tl = sorted(self.td.get(tweetName,list()))\n        si = bisect.bisect_left(tl,startTime)\n        ei = bisect.bisect_right(tl,endTime)\n        incr = self.incrDict[freq]\n        res = []\n        for i in range(math.ceil((endTime-startTime+1)/incr)):\n            et = startTime + (i+1)*incr\n            ind = bisect.bisect_right(tl,et-1,si,ei)\n            res.append(ind-si)\n            si = ind\n        \n        return res\n            \n        \n        \n        \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "import numpy as np\n\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n        self.tweets_sorted = {}\n        self.intervals = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 3600 * 24}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if not tweetName in self.tweets: \n            self.tweets[tweetName] = np.array([])\n        \n        self.tweets_sorted[tweetName] = False\n        self.tweets[tweetName] = np.append(self.tweets[tweetName], [time])\n        # print(self.tweets[tweetName])\n        \n\n#     def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n#         interval = self.intervals[freq]\n#         # bins = [[i*interval, (i+1)*interval] for i in range(int(np.ceil((endTime - startTime) / interval)))]\n#         bins = []\n#         t_start=startTime\n#         while t_start <= endTime:\n#             bins.append([t_start, t_start + interval])\n#             t_start += interval\n        \n#         bins[-1][1] = endTime + 1\n        \n#         # h,e = np.histogram(self.tweets[tweetName], bins=interval, range=(startTime, endTime))\n#         count = np.zeros(len(bins), dtype=np.int)\n        \n#         for t in self.tweets[tweetName]:\n#             for bi, b in enumerate(bins):\n#                 if b[0]<= t < b[1]:\n#                     count[bi] += 1\n                    \n#         return h \n\n    \n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        interval = self.intervals[freq]\n        # bins = [[i*interval, (i+1)*interval] for i in range(int(np.ceil((endTime - startTime) / interval)))]\n        bins = []\n        t_start=startTime\n        while t_start <= endTime:\n            bins.append([t_start, t_start + interval])\n            t_start += interval\n        \n        bins[-1][1] = endTime + 1\n        count = np.zeros(len(bins), dtype=np.int)\n        \n        if not self.tweets_sorted[tweetName]: self.tweets[tweetName].sort()\n        \n        e_end = startTime + interval\n        \n        ## Find borders\n        i_start, i_end = np.searchsorted(self.tweets[tweetName], v=[startTime-1, endTime+1], side=\\\"right\\\")\n        int_i = 0\n        for t in self.tweets[tweetName][i_start:i_end]:\n            while t >= e_end and t <= endTime:\n                int_i += 1\n                e_end += interval\n            \n            if t <= endTime: count[int_i] += 1       \n                    \n        return count    \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.arr = collections.defaultdict(lambda: [])\n        self.mapping = {\\\"hour\\\": 3600, \\\"minute\\\":60, \\\"day\\\":3600*24}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.arr[tweetName], time)\n            \n        \n\n    def getTweetCountsPerFrequency(self, freq: str, t: str, start: int, end: int) -> List[int]:\n        ans = []\n        interval = self.mapping[freq]\n        while start<=end:\n            ans.append(bisect.bisect_left(self.arr[t], min(end+1, start+interval)) - bisect.bisect_left(self.arr[t], start))\n            start += interval\n        return ans\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "freq_map = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 24*3600}\nclass TweetCounts:\n    def __init__(self):\n        self.tweet_dict = {}\n\n    def recordTweet(self, tweetName, time):\n        if tweetName not in self.tweet_dict:\n            self.tweet_dict[tweetName] = []\n        self.tweet_dict[tweetName].append(time)\n        \n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n        if tweetName not in self.tweet_dict:\n            return None\n        intervals = (-startTime + endTime)//freq_map[freq] + 1\n        \n        output = [0]*(intervals)\n        for elem in sorted(self.tweet_dict[tweetName]):\n            if elem >= startTime and elem <= endTime:\n                output[(elem - startTime)//freq_map[freq]] += 1\n            if elem > endTime:\n                break\n        return output\n\n        # Your TweetCounts object will be instantiated and called as such:\n        # obj = TweetCounts()\n        # obj.recordTweet(tweetName,time)\n        # param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict, deque\nimport bisect\n\nclass TweetCounts:\n\n    def __init__(self):\n        self._deltas = {\n            'minute': 60,\n            'hour': 60*60,\n            'day':60*60*24\n        }\n        self._tweets = defaultdict(deque)\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort_left(self._tweets[tweetName], time)\n        \n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        tweet_times = self._tweets[tweetName]\n        left = 0\n        right = len(tweet_times)\n        while left < right:\n            mid = (left + right) // 2\n            if tweet_times[mid] >= startTime:\n                right = mid\n            else:\n                left = mid + 1\n        output = [0]\n        interval = self._deltas[freq]\n        period_start = startTime\n        while left < len(tweet_times) and tweet_times[left] <= endTime:\n            if tweet_times[left] < period_start + interval:\n                output[-1] += 1\n                left += 1\n            else:\n                period_start += interval\n                output.append(0)\n        for _ in range((endTime - period_start ) // interval):\n            output.append(0)\n        return output\n    \n    \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    \n    FREQUENCE = {\n        'minute' : 60,\n        'hour' : 3600,\n        'day' : 24*3600,\n    }\n\n    def __init__(self):\n        self.store = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        \n        if tweetName not in self.store:\n            self.store[tweetName] = {}\n        if time not in self.store[tweetName]:\n            self.store[tweetName][time]=0\n            \n        self.store[tweetName][time]+=1\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        if tweetName not in self.store:\n            return []\n        \n        delta = TweetCounts.FREQUENCE[freq]\n        \n        keys = list(self.store.get(tweetName).keys())\n        keys = sorted(keys)\n        \n        start =  bisect.bisect_left(keys, startTime)\n        end =  bisect.bisect_right(keys, endTime)\n        \n        num_intervals = (endTime - startTime) // delta + 1\n        \n        result = [0] * num_intervals\n        \n                    \n        for t1 in range(start-1, end+1):            \n            if t1 < 0:\n                continue\n            if t1 >= len(keys):\n                break\n                \n            t = keys[t1]\n            \n            if t<startTime or t>endTime:\n                continue\n            \n            index = (t - startTime) // delta\n            result[index] +=  self.store.get(tweetName).get(t)\n        \n        return result\n", "class TweetCounts:\n\n    def __init__(self):\n\n        self.second = defaultdict(list)\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n\n        \n        bisect.insort(self.second[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq == \\\"minute\\\":\n            step =  60\n        elif freq == \\\"hour\\\":\n            step = 3600\n        else:\n            step = 3600 * 24\n            \n        ans = []\n        l = self.second[tweetName]\n        while(startTime <= endTime):\n            start, end = startTime, min(startTime + step-1, endTime)\n            left, right = bisect.bisect_left(l, start), bisect.bisect_right(l, end)\n            ans.append(right-left)\n            startTime += step \n        return ans\n        \n    \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        tweet_ts = self.tweets[tweetName]\n        if not len(tweet_ts):\n            return []\n        diff = endTime - startTime\n        seconds_in_interval = 0\n        if freq == \\\"minute\\\":\n            seconds_in_interval = 60\n        elif freq == \\\"hour\\\":\n            seconds_in_interval = 3600\n        else:\n            seconds_in_interval = 3600 * 24\n        output = [0] * ((diff//seconds_in_interval) + 1)\n        for ts in tweet_ts:\n            if endTime >= ts >= startTime:\n                output[(ts - startTime)//seconds_in_interval] += 1\n        return output\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "# similiar : design-log-storage-system-635\nclass TweetCounts:\n\n    def __init__(self):\n        self.__records = collections.defaultdict(list)\n        self.__lookup = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 86400}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.__records[tweetName].append(time)\n\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = self.__lookup[freq]\n        result = [0] * ((endTime - startTime) // delta + 1)\n        for t in self.__records[tweetName]:\n            if startTime <= t <= endTime:\n                result[(t - startTime) // delta] += 1\n        return result\n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = collections.defaultdict(list)\n    \n\n    def __bs(self, arr, val):\n        lo, hi = 0, len(arr)\n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            \n            if arr[mid] >= val:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        idx = self.__bs(self.tweets[tweetName], time)\n        self.tweets[tweetName].insert(idx, time)\n \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n        i = startTime\n        arr = self.tweets[tweetName]\n        result = []\n        while i <= endTime:\n            j = min(i + delta, endTime + 1)\n            result.append(self.__bs(arr, j) - self.__bs(arr, i))\n            i += delta\n        return result\n\n            \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.data = defaultdict(list)\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.data[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if freq[0]=='m':\n            ans = [0]*((endTime-startTime)//60 +1)\n            for x in self.data[tweetName]:\n                if startTime<=x<=endTime:\n                    a = (x-startTime)//60\n                    ans[a]+=1\n            return ans\n            \n        elif freq[0]=='h':\n            ans = [0]*((endTime-startTime)//3600 +1)\n            for x in self.data[tweetName]:\n                if startTime<=x<=endTime:\n                    a = (x-startTime)//3600\n                    ans[a]+=1\n            return ans\n        else:\n            ans = [0]*((endTime-startTime)//86400 +1)\n            for x in self.data[tweetName]:\n                if startTime<=x<=endTime:\n                    a = (x-startTime)//86400\n                    ans[a]+=1\n            return ans\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "import collections\n\n\nclass TweetCounts(object):\n\n\\tdef __init__(self):\n\\t\\tself.tweets = collections.defaultdict(list)\n\n\\tdef recordTweet(self, tweetName, time):\n\\t\\t\\\"\\\"\\\"\n\\t\\t:type tweetName: str\n\\t\\t:type time: int\n\\t\\t:rtype: None\n\\t\\t\\\"\\\"\\\"\n\\t\\tindex = self.binary_search(tweetName, time)\n\\t\\tself.tweets[tweetName].insert(index,  time)\n\n\n\\tdef getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n\\t\\t\\\"\\\"\\\"\n\\t\\t:type freq: str\n\\t\\t:type tweetName: str\n\\t\\t:type startTime: int\n\\t\\t:type endTime: int\n\\t\\t:rtype: List[int]\n\\t\\t\\\"\\\"\\\"\n\\t\\tdelta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n\\t\\ti = startTime\n\\t\\tres = []\n\\t\\twhile i <= endTime:\n\\t\\t\\tj = min(i + delta, endTime + 1)\n\\t\\t\\tres.append(self.binary_search(tweetName, j) - self.binary_search(tweetName, i))\n\\t\\t\\ti += delta\n\n\\t\\treturn res\n\n\n\\tdef binary_search(self, tweetName, time):\n\\t\\tcur_list = self.tweets[tweetName]\n\\t\\tl = 0\n\\t\\tr = len(cur_list) \n\\t\\twhile l < r:\n\\t\\t\\tmid = (l+r) // 2\n\\t\\t\\tif cur_list[mid] < time:\n\\t\\t\\t\\tl = mid + 1\n\\t\\t\\telse:\n\\t\\t\\t\\tr = mid\n\n\\t\\treturn l\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n        \n        self.delta = {\\\"minute\\\": 60, \\\"hour\\\": 3600, \\\"day\\\": 86400}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.tweets:\n            self.tweets[tweetName].append(time)\n        else:\n            self.tweets[tweetName] = [time]\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        \n        times = sorted(filter(lambda t: startTime <= t <= endTime, self.tweets.get(tweetName, [])))\n        \n        delta = self.delta[freq]\n        \n        ranges = [[startTime + delta*i, startTime + delta*(i+1)-1] \\\\\n                  for i in range((endTime - startTime) // delta)]\n        \n        ranges.append([startTime + delta*len(ranges), endTime])\n        \n        counts = {tuple(k): 0 for k in ranges}\n        \n        i = 0\n        for n in times:\n            while n > ranges[i][1]:\n                i += 1\n                \n            counts[tuple(ranges[i])] += 1\n            \n        \n        return counts.values()\n            \n                       \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "from collections import defaultdict \nimport bisect\nclass TweetCounts:\n    \n    freq_map = {'minute': 60, 'hour': 3600, 'day': 3600 * 24 }\n    \n    def __init__(self):\n        # map of tweetName => [] ordered list of frequencies\n        self.tweet_map = defaultdict(list)\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.tweet_map[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        # print(f'getTweetCountsPerFrequency: {startTime}: {endTime}: {freq}')\n        \n        interval_length = TweetCounts.freq_map[freq]\n        # print(self.tweet_map[tweetName])\n        starting_index = bisect.bisect_left(self.tweet_map[tweetName],startTime)\n        \n        res = []\n        curr_index = starting_index\n        current_interval_start = startTime\n        current_interval_end = min(current_interval_start + interval_length - 1, endTime)  # inclusive\n        current_interval_count = 0\n        while current_interval_end <= endTime: \n            # print(f'{current_interval_start} - {current_interval_end}: count:{current_interval_count} ')\n            if curr_index < len(self.tweet_map[tweetName]):\n                # have not run out of timestamps \n                if self.tweet_map[tweetName][curr_index] <= current_interval_end: \n                    # current tweet is within the current interval\n                    current_interval_count +=1\n                    curr_index += 1\n                elif current_interval_end!= endTime:\n                    # push to next interval\n                    current_interval_start += interval_length\n                    current_interval_end = min(current_interval_end + interval_length, endTime)\n                    res.append(current_interval_count)\n                    current_interval_count = 0\n                else:\n                    res.append(current_interval_count)\n                    break\n            elif current_interval_end!= endTime:\n                # already went through all timestamps. go to the next time interval \n                current_interval_start += interval_length\n                current_interval_end  = min(current_interval_end + interval_length, endTime)\n                res.append(current_interval_count)\n                current_interval_count = 0\n            else: \n                res.append(current_interval_count)\n                break\n                    \n        return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetNode:\n    def __init__(self, time, count = 1):\n        self.time       = time\n        self._count     = count\n        self.left_node  = None\n        self.right_node = None\n    \n    def add_time(self, time):\n        if self.time > time:\n            if self.left_node is None:\n                self.left_node = TweetNode(time)\n            else:\n                self.left_node.add_time(time)\n        elif self.time < time:\n            if self.right_node is None:\n                self.right_node = TweetNode(time)\n            else:\n                self.right_node.add_time(time)\n        else:\n            self._count += 1\n    \n    def count(self, start_time, end_time):\n        if self.time > end_time:\n            return (self.left_node and self.left_node.count(start_time, end_time) or 0)\n        elif self.time < start_time:\n            return (self.right_node and self.right_node.count(start_time, end_time) or 0)\n        else:\n            return (\n                self._count\n                + (self.left_node  and self.left_node.count(start_time, end_time)  or 0)\n                + (self.right_node and self.right_node.count(start_time, end_time) or 0)\n            )\n        \n    def __str__(self):\n        return '{ \\\"count\\\" : %s, \\\"time\\\" : %s, \\\"left\\\" : %s, \\\"right\\\" : %s }' % (self._count, self.time, str(self.left_node), str(self.right_node))\n    \n    def __repr__(self):\n        return str(self)\n            \nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = dict()\n\n    def recordTweet(self, tweet_name: str, time: int) -> None:\n        if tweet_name not in self.tweets:\n            self.tweets[tweet_name] = TweetNode(time)\n        else:\n            self.tweets[tweet_name].add_time(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweet_name: str, start_time: int, end_time: int) -> List[int]:\n        if tweet_name in self.tweets:\n            if freq   == \\\"minute\\\":\n                delta = 60\n            elif freq == \\\"hour\\\":\n                delta = 60 * 60\n            elif freq == \\\"day\\\":\n                delta = 60 * 60 * 24\n            else:\n                raise NotImplemented(\\\"The set frequency is not implemented.\\\")\n            return [\n                self.tweets[tweet_name].count(st, ((st + delta - 1) if (st + delta - 1) < end_time else end_time)) for st in range(start_time, end_time + 1, delta)\n            ]\n        else:\n            return 0\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.data = collections.defaultdict(dict)\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if time not in self.data[tweetName]:\n            self.data[tweetName][time] = 1\n        else: self.data[tweetName][time] += 1\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = [60, 60*60, 60*60*24]\n        if freq == 'minute':\n            t = delta[0]\n        elif freq == 'hour':\n            t = delta[1]\n        else: t = delta[2]\n        res = [0]*((endTime - startTime)//t+1)\n        i = 0\n        data = self.data[tweetName]\n        for time in sorted(data.keys()):\n            if startTime <= time <= endTime: \n                res[(time - startTime)//t] += data[time]\n        return res\n\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n    STEP_DICT = {\n        \\\"minute\\\": 60,\n        \\\"hour\\\": 60 * 60,\n        \\\"day\\\": 60 * 60 * 24,\n    }\n\n    def __init__(self):\n        self.tweet_map = defaultdict(list)\n\n    def recordTweet(self, tweet_name: str, t: int) -> None:\n        self.tweet_map[tweet_name].append(t)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweet_name: str, start: int, stop: int) -> List[int]:\n        result = []\n\n        if tweet_name not in self.tweet_map:\n            return result\n\n        step = self.STEP_DICT[freq]\n\n        tweet_times = sorted([t for t in self.tweet_map[tweet_name] if start <= t <= stop])\n        tweet_times_intervals = [(t - start) // step + 1 for t in tweet_times]\n        tweet_times_intervals_dict = defaultdict(int)\n        for interval in tweet_times_intervals:\n            tweet_times_intervals_dict[interval] += 1\n\n        interval = 1\n        while start <= stop:\n            result.append(tweet_times_intervals_dict.get(interval, 0))\n            interval += 1\n            start += step\n\n        return result\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweets = defaultdict(list)\n        self.mapping = {'minute':60,'hour':3600,'day':86400}\n        \n    def binary_search(self,left,right,key,array,type):\n        while left<=right:\n            mid = left + (right-left)//2\n            if array[mid]>=key:\n                right=mid-1\n            else:\n                left = mid+1\n        return left if type=='S' else right        \n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        self.tweets[tweetName].append(time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        self.tweets[tweetName].sort()\n        tweetcounts = self.tweets[tweetName]\n        intervals = []\n        while startTime<endTime+1:\n            #Binary Search to find the tweets \n            startindex = self.binary_search(0,len(tweetcounts)-1,startTime,tweetcounts,'S')\n            findval = min(startTime+self.mapping[freq],endTime+1)\n            endindex = self.binary_search(0,len(tweetcounts)-1,findval,tweetcounts,'E')\n            intervals.append(endindex-startindex+1)\n            startTime+=self.mapping[freq]\n        return intervals\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.tweet2time = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.tweet2time:\n            self.tweet2time[tweetName] = [time]\n        else:\n            arr = self.tweet2time[tweetName]\n            index = self.binary_search(arr, time)\n            arr.insert(index, time)\n            \n            \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        if tweetName not in self.tweet2time:\n            return []\n        \n        arr = self.tweet2time[tweetName]\n        \n        if freq == 'minute':\n            interval = 60\n        elif freq == 'hour':\n            interval = 3600\n        else:\n            interval = 3600 * 60\n        \n        \n        time = startTime\n        result = []\n        while time <= endTime:\n            end_time = time + interval\n            start_index = self.binary_search(arr, time)\n            end_index = self.binary_search(arr, min(end_time, endTime + 1))\n            # if start_index == end_index and arr[-1] == time:\n                # end_index += 1\n            \n            result.append(end_index - start_index)\n            \n            time = end_time\n            \n        return result    \n    \n    def binary_search(self, arr, num):\n        # if num <= arr[0]:\n            # return 0\n        # elif num >= arr[-1]:\n            # return len(arr)\n        # elif num > arr[-1]:\n            # return len(arr) + 1\n        # else:\n        left = 0\n        right = len(arr)\n\n        while left < right:\n            mid = left + (right - left) // 2\n            if arr[mid] > num:\n                right = mid\n            elif arr[mid] < num:\n                left = mid + 1\n            else:\n                return mid\n\n        return left    \n        \n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "import collections\n\n\nclass TweetCounts(object):\n\n\\tdef __init__(self):\n\\t\\tself.tweets = collections.defaultdict(list)\n\n\\tdef recordTweet(self, tweetName, time):\n\\t\\tself.tweets[tweetName].insert(self.binary_search(tweetName, time),  time)\n\n\n\\tdef getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\n\\t\\tdelta = 60 if freq == 'minute' else 3600 if freq == 'hour' else 86400\n\\t\\ti = startTime\n\\t\\tres = []\n\\t\\twhile i <= endTime:\n\\t\\t\\tj = min(i + delta, endTime + 1)\n\\t\\t\\tres.append(self.binary_search(tweetName, j) - self.binary_search(tweetName, i))\n\\t\\t\\ti += delta\n\n\\t\\treturn res\n\n\n\\tdef binary_search(self, tweetName, time):\n\\t\\tcur_list = self.tweets[tweetName]\n\\t\\tl = 0\n\\t\\tr = len(cur_list) \n\\t\\twhile l < r:\n\\t\\t\\tmid = (l+r) // 2\n\\t\\t\\tif cur_list[mid] < time:\n\\t\\t\\t\\tl = mid + 1\n\\t\\t\\telse:\n\\t\\t\\t\\tr = mid\n\n\\t\\treturn l", "class TweetCounts:\n\n    def __init__(self):\n        self.tweetDict = {}\n    \n    def insertAt(self, tN, x):\n        l = 0\n        r = len(self.tweetDict[tN]) - 1\n        if x < self.tweetDict[tN][l]:\n            return 0\n        if x > self.tweetDict[tN][r]:\n            return r + 1\n        while r > l:\n            m = (r + l) // 2\n            if self.tweetDict[tN][m] < x:\n                l = m+ 1\n            else:\n                r = m\n        return l\n    \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.tweetDict:\n            self.tweetDict[tweetName].insert(self.insertAt(tweetName, time), time)\n        else:\n            self.tweetDict[tweetName] = [time]\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        ans = []\n        if freq == 'minute':\n            delta = 60\n        elif freq == 'hour':\n            delta = 3600\n        else:\n            delta = 86400\n        total = (endTime - startTime)//delta\n        if (endTime - startTime)%delta > 0:\n            total += 1\n        n = 0\n        for t in range(startTime, endTime+1, delta):\n            t0 = t\n            t1 = min(t+delta, endTime+1)\n            i0 = self.insertAt(tweetName, t0)\n            # print(t0, t1)\n            if i0 == len(self.tweetDict[tweetName]):\n                ans += [0]* (total - n)\n                # ans.append(0)\n                return ans\n            i1 = self.insertAt(tweetName, t1)\n            if i1 == len(self.tweetDict[tweetName]):\n                ans.append(i1 - i0)\n                ans += [0]* (total - n - 1)\n                return ans\n            n += 1\n            ans.append(i1 - i0)\n        return ans\n            \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "from collections import defaultdict \nimport bisect\nclass TweetCounts:\n    \n    freq_map = {'minute': 60, 'hour': 3600, 'day': 3600 * 24 }\n    \n    def __init__(self):\n        # map of tweetName => [] ordered list of frequencies\n        self.tweet_map = defaultdict(list)\n        \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        bisect.insort(self.tweet_map[tweetName], time)\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        # print(f'getTweetCountsPerFrequency: {startTime}: {endTime}: {freq}')\n        \n        interval_length = TweetCounts.freq_map[freq]\n        # print(self.tweet_map[tweetName])\n        starting_index = bisect.bisect_left(self.tweet_map[tweetName],startTime)\n        \n        res = []\n        curr_index = starting_index\n        current_interval_start = startTime\n        current_interval_end = min(current_interval_start + interval_length - 1, endTime)  # inclusive\n        current_interval_count = 0\n        while current_interval_end <= endTime: \n            # print(f'{current_interval_start} - {current_interval_end}: count:{current_interval_count} ')\n            if curr_index < len(self.tweet_map[tweetName]):\n                # have not run out of timestamps \n                if self.tweet_map[tweetName][curr_index] <= current_interval_end: \n                    # current tweet is within the current interval\n                    current_interval_count +=1\n                    curr_index += 1\n                    continue\n            if current_interval_end!= endTime:\n                # already went through all timestamps. go to the next time interval \n                current_interval_start += interval_length\n                current_interval_end  = min(current_interval_end + interval_length, endTime)\n                res.append(current_interval_count)\n                current_interval_count = 0\n            else: \n                res.append(current_interval_count)\n                break\n                    \n        return res\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.d = {}\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.d:\n            self.d[tweetName] = []\n        arr = self.d[tweetName]\n        i = len(arr)-1\n        while i >= 0 and arr[i] > time:\n            i -= 1\n        self.d[tweetName] = arr[:i+1] + [time] + arr[i+1:]\n        # assert self.d[tweetName] == sorted(self.d[tweetName])\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        # print(freq, tweetName, startTime, endTime, self.d)\n        arr = self.d.get(tweetName, [])\n        r = []\n        j = 0\n        step = (1 if freq == \\\"second\\\" else \n               60 if freq == \\\"minute\\\" else \n               60*60 if freq == \\\"hour\\\" else \n                60*60*24)\n        while j < len(arr) and arr[j] < startTime:\n            j += 1\n        for i in range(startTime, endTime+1, step):\n            r.append(0)\n            while j < len(arr) and arr[j] <= min(i+step-1, endTime):\n                j += 1\n                r[-1] += 1\n        return r\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        self.tweetDict = {}\n    \n    def insertAt(self, tN, x):\n        l = 0\n        r = len(self.tweetDict[tN]) - 1\n        if x < self.tweetDict[tN][l]:\n            return 0\n        if x > self.tweetDict[tN][r]:\n            return r + 1\n        while r > l:\n            m = (r + l) // 2\n            if self.tweetDict[tN][m] < x:\n                l = m+ 1\n            else:\n                r = m\n        return l\n    \n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName in self.tweetDict:\n            self.tweetDict[tweetName].insert(self.insertAt(tweetName, time), time)\n        else:\n            self.tweetDict[tweetName] = [time]\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        ans = []\n        if freq == 'minute':\n            delta = 60\n        elif freq == 'hour':\n            delta = 3600\n        else:\n            delta = 86400\n        total = (endTime - startTime)//delta\n        if (endTime - startTime)%delta > 0:\n            total += 1\n        n = 0\n        for t in range(startTime, endTime+1, delta):\n            t0 = t\n            t1 = min(t+delta, endTime+1)\n            i0 = self.insertAt(tweetName, t0)\n            print((t0, t1))\n            if i0 == len(self.tweetDict[tweetName]):\n                ans += [0]* (total - n)\n                # ans.append(0)\n                return ans\n            i1 = self.insertAt(tweetName, t1)\n            if i1 == len(self.tweetDict[tweetName]):\n                ans.append(i1 - i0)\n                ans += [0]* (total - n - 1)\n                return ans\n            n += 1\n            ans.append(i1 - i0)\n        return ans\n            \n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        from bisect import bisect_left, bisect_right\n        from functools import lru_cache\n        self.tweets = {}\n        return\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tn, seconds = tweetName, time\n        if tn not in self.tweets: self.tweets[tn] = Counter()\n        self.tweets[tn] += Counter(dict([(seconds, 1)]))\n        return\n\n\n    def quantize(self, per_second_tweet_counter, valid_times, scale):\n        t = [((timekey-self.st)//scale, per_second_tweet_counter[timekey]) \n             for timekey in valid_times]\n        \n        qcnts, qkeys = {}, []\n        for tk, tc in t:\n            if tk not in qcnts:\n                qcnts[tk] = 0\n                qkeys.append(tk)\n            qcnts[tk] += tc\n\n        #qkeys = list(qcnts.keys())\n        n = (self.et - self.st + 1) // scale\n        if (self.et - self.st + 1) % scale: n += 1\n        res = [0] * (n)\n        for tk in qkeys: res[tk] = qcnts[tk]\n        return res\n\n    @lru_cache\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        M, H, D = 60, 60*60, 60*60*24\n        tn, st, et = tweetName, startTime, endTime\n        if tn not in self.tweets: return [0]\n        self.st, self.et = st, et\n\n        per_second_tweet_counter = self.tweets[tn]\n        valid_times = [timekey for timekey in per_second_tweet_counter\n                       if st <= timekey <= et]\n\n        if freq == 'minute': return self.quantize(per_second_tweet_counter, valid_times, M)\n        if freq == 'hour': return self.quantize(per_second_tweet_counter, valid_times, H)\n        if freq == 'day': return self.quantize(per_second_tweet_counter, valid_times, D)\n        \n        return [0]\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        from bisect import bisect_left, bisect_right\n        from functools import lru_cache\n        self.tweets = {}\n        return\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tn, seconds = tweetName, time\n        if tn not in self.tweets: self.tweets[tn] = Counter()\n        self.tweets[tn] += Counter(dict([(seconds, 1)]))\n        return\n\n\n    def quantize(self, per_second_tweet_counter, valid_times, scale):\n        t = [((timekey-self.st)//scale, per_second_tweet_counter[timekey]) \n             for timekey in valid_times]\n        \n        qcnts, qkeys = {}, []\n        for tk, tc in t:\n            if tk not in qcnts:\n                qcnts[tk] = 0\n                qkeys.append(tk)\n            qcnts[tk] += tc\n\n        qkeys = list(qcnts.keys())\n        n = (self.et - self.st + 1) // scale\n        if (self.et - self.st + 1) % scale: n += 1\n        res = [0] * (n)\n        for tk in qkeys: res[tk] = qcnts[tk]\n        return res\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        M, H, D = 60, 60*60, 60*60*24\n        self.tn, self.st, self.et = tweetName, startTime, endTime\n        if self.tn not in self.tweets: return [0]\n\n        per_second_tweet_counter = self.tweets[self.tn]\n        valid_times = [timekey for timekey in per_second_tweet_counter\n                       if self.st <= timekey <= self.et]\n\n        if freq == 'minute':\n            return self.quantize(per_second_tweet_counter, valid_times, M)\n        if freq == 'hour':\n            return self.quantize(per_second_tweet_counter, valid_times, H)\n        if freq == 'day':\n            return self.quantize(per_second_tweet_counter, valid_times, D)\n        \n        return [0]\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n", "class TweetCounts:\n\n    def __init__(self):\n        self.db = {}\n        \n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        if tweetName not in self.db:\n            self.db[tweetName] = [time]\n\n        elif tweetName in self.db:\n            idx = len(self.db[tweetName])\n\n            for i in range(len(self.db[tweetName])):\n                if self.db[tweetName][i] >= time:\n                    idx = i\n                    break\n\n\n            self.db[tweetName].insert(idx, time)\n\n        \n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        delta = 1\n\n        if freq == \\\"minute\\\":\n            # startTime *= 60\n            # endTime *= 60\n            delta *= 60\n\n        elif freq == \\\"hour\\\":\n            # startTime *= 60*60\n            # endTime *= 60*60\n            delta *= 60*60\n\n        elif freq == \\\"day\\\":\n            # startTime *= 60*60*12\n            # endTime *= 60*60*12\n            delta *= 60*60*12\n\n        if tweetName not in self.db:\n            # Would we instead want a list of zeroes.\n            return [0]\n\n        # delta -= 1\n        \n        start = startTime\n        ans = []\n\n\n        # Max val:\n        maxTime = self.db[tweetName][-1]\n        \n        if startTime > maxTime:\n    \n            while start <= endTime:\n                ans.append(0)\n\n                start += delta\n                \n            return ans\n\n\n        # Tweets\n        tweets = self.db[tweetName]\n\n        idx = 0\n\n        while start > tweets[idx]:\n            idx += 1\n\n        # print(endTime)\n\n        while start <= maxTime and start <= endTime:\n            # print(start)\n            tmp = 0\n\n            while tweets[idx] <= endTime and start <= tweets[idx] < start+delta:\n\n                tmp += 1\n\n                if tweets[idx] == maxTime:\n                    break\n\n                idx += 1\n                \n            ans.append(tmp)\n            start += delta\n                \n        while start <= endTime:\n            ans.append(0)\n\n            start += delta\n\n\n\n\n        # Remove trailing zeroes\n\n        return ans\n\n\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)", "class TweetCounts:\n\n    def __init__(self):\n        from bisect import bisect_left, bisect_right\n        from functools import lru_cache\n        self.tweets = {}\n        self.cache = {}\n        return\n\n\n    def recordTweet(self, tweetName: str, time: int) -> None:\n        tn, seconds = tweetName, time\n        if tn not in self.tweets: self.tweets[tn] = Counter()\n        self.tweets[tn] += Counter(dict([(seconds, 1)]))\n        return\n\n\n    def quantize(self, per_second_tweet_counter, valid_times, scale):\n        t = [((timekey-self.st)//scale, per_second_tweet_counter[timekey]) \n             for timekey in valid_times]\n        \n        qcnts, qkeys = {}, []\n        for tk, tc in t:\n            if tk not in qcnts:\n                qcnts[tk] = 0\n                qkeys.append(tk)\n            qcnts[tk] += tc\n\n        n = (self.et - self.st + 1) // scale\n        if (self.et - self.st + 1) % scale: n += 1\n        res = [0] * (n)\n        for tk in qkeys: res[tk] = qcnts[tk]\n        return res\n\n\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\n        M, H, D = 60, 60*60, 60*60*24\n        self.tn, self.st, self.et = tweetName, startTime, endTime\n        if self.tn not in self.tweets: return [0]\n\n        per_second_tweet_counter = self.tweets[self.tn]\n\n        key = (self.tn, self.st, self.et)\n        if key in self.cache:\n            valid_times = self.cache[key]\n        else:\n            valid_times = [timekey for timekey in per_second_tweet_counter\n                           if self.st <= timekey <= self.et]\n            \n        if freq == 'minute':\n            return self.quantize(per_second_tweet_counter, valid_times, M)\n        if freq == 'hour':\n            return self.quantize(per_second_tweet_counter, valid_times, H)\n        if freq == 'day':\n            return self.quantize(per_second_tweet_counter, valid_times, D)\n        \n        return [0]\n\n\n# Your TweetCounts object will be instantiated and called as such:\n# obj = TweetCounts()\n# obj.recordTweet(tweetName,time)\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\n"]
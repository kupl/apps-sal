import sys
input = sys.stdin.readline


def I():
    return int(input())


def MI():
    return list(map(int, input().split()))


def LI():
    return list(map(int, input().split()))


'\n可能なら左から取る\n左側にある数字のどれかに追い付いたら，そこはもう選ばれない．\n選ぶ数字をどんどん左にシフトしていく．\n\n左に移動するとき，左側にある最大値とその位置を取りたい:seg木でいける（A[i],-i）を持って最大値を取れば位置もわかる．\n\n数字を使う回数をカウントするためには，左側にある最大値は必要．あと，右側にある自分と同じ数の個数，も必要．\n個数だけでよく，位置情報はいらないので左にシフトしていくときにddで個数だけ持っておくか\n右側の使い方が変だな，326154みたいな並びだと，6を3に下げるときに，右側にある45をどっちもを補足する必要あり\n\nうわ，例2の答えのとこ見間違えてた，普通に計算した通りの転倒数ジャン．\ni番目を見ている状態\n次のものが自分より左側に出てくる:差分*i以上の位置にある個数\n次のものが自分より右側に出てくる:むし\n\n同じ数字が出てくるとき：次の数字は左側としたいが，右に出てくる分の個数も加味したい\n+1ではなく，次の数との差分\nとか思ってたけど，結局足すのは次に左の数が出てきた時なのでいらない\n\n結局差分が大事．次との差分を見るだけならば，個数が同じグループのことをあまり考えなくても良い\n大きい順に見ていくだけなので，個数=見た個数で良い\n\n\n'


def main():
    N = I()
    A = LI()
    for i in range(N):
        A[i] = (A[i], i)
    A.sort(reverse=True)
    A.append((0, 0))
    ans = [0] * N
    now = A[0][1]
    for i in range(N):
        ans[now] += (i + 1) * (A[i][0] - A[i + 1][0])
        now = min(now, A[i + 1][1])
    for i in range(N):
        print(ans[i])


main()

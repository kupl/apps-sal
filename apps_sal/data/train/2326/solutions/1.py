import sys
input = sys.stdin.readline


def I(): return int(input())
def MI(): return list(map(int, input().split()))
def LI(): return list(map(int, input().split()))


"""
可能なら左から取る
左側にある数字のどれかに追い付いたら，そこはもう選ばれない．
選ぶ数字をどんどん左にシフトしていく．

左に移動するとき，左側にある最大値とその位置を取りたい:seg木でいける（A[i],-i）を持って最大値を取れば位置もわかる．

数字を使う回数をカウントするためには，左側にある最大値は必要．あと，右側にある自分と同じ数の個数，も必要．
個数だけでよく，位置情報はいらないので左にシフトしていくときにddで個数だけ持っておくか
右側の使い方が変だな，326154みたいな並びだと，6を3に下げるときに，右側にある45をどっちもを補足する必要あり

うわ，例2の答えのとこ見間違えてた，普通に計算した通りの転倒数ジャン．
i番目を見ている状態
次のものが自分より左側に出てくる:差分*i以上の位置にある個数
次のものが自分より右側に出てくる:むし

同じ数字が出てくるとき：次の数字は左側としたいが，右に出てくる分の個数も加味したい
+1ではなく，次の数との差分
とか思ってたけど，結局足すのは次に左の数が出てきた時なのでいらない

結局差分が大事．次との差分を見るだけならば，個数が同じグループのことをあまり考えなくても良い
大きい順に見ていくだけなので，個数=見た個数で良い


"""


def main():
    N = I()
    A = LI()
    for i in range(N):
        A[i] = (A[i], i)

    A.sort(reverse=True)
    A.append((0, 0))
    ans = [0] * N

    now = A[0][1]
    for i in range(N):
        ans[now] += (i + 1) * (A[i][0] - A[i + 1][0])
        now = min(now, A[i + 1][1])

    for i in range(N):
        print((ans[i]))


main()

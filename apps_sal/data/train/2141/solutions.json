["import sys\nreadline = sys.stdin.readline        \ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\n\nN = int(readline())\nroot = None\nEdge = [[] for _ in range(N)]\nCr = [None]*N\nfor a in range(N):\n    b, c = list(map(int, readline().split()))\n    b -= 1\n    if b == -1:\n        root = a\n    else:\n        Edge[a].append(b)\n        Edge[b].append(a)\n    Cr[a] = c\n\nP, L = parorder(Edge, root)\n        \ndp = [0]*N\n\nfor l in L[:0:-1]:\n    p = P[l]\n    dp[p] += 1+dp[l]\n\nif any(d < c for d, c in zip(dp, Cr)):\n    print('NO')\nelse:\n    print('YES')\n    A = [None]*N\n    dp2 = [[] for _ in range(N)]\n    for l in L[:0:-1]:\n        p = P[l]\n        dp2[l] = dp2[l][:Cr[l]] + [l] + dp2[l][Cr[l]:]\n        dp2[p].extend(dp2[l])\n    dp2[root] = dp2[root][:Cr[root]] + [root] + dp2[root][Cr[root]:]        \n    Ans = [None]*N\n    for i in range(N):\n        Ans[dp2[root][i]] = i+1\n    print(' '.join(map(str, Ans)))\n"]
["from heapq import *\nfrom collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        counter = Counter(arr)\n        size = len(arr)\n        \n        # unique elements (remove half of them)\n        if len(counter) == size:\n            return (size - 1) // 2 + 1\n        \n        max_heap = [(-freq, value) for value, freq in list(counter.items())]\n        heapify(max_heap)\n        \n        removed = 0  # number of elements removed\n        removed_size = 0  # size of the remvoved set\n        \n        while removed < size//2:\n            count, value = heappop(max_heap)\n            count = -count  # change the count back to +ve\n            removed += count\n            removed_size += 1\n        \n        return removed_size\n        \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        freq = Counter(arr)\n        final_length = 0\n        half = len(arr)/2\n        reduce = 0\n        for n, f in freq.most_common():\n            final_length+=f\n            reduce+=1\n            if final_length>=half:\n                return reduce", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counts=collections.Counter(arr)\n        counts=[count for number,count in counts.most_common()]\n        \n        set_size=0\n        tot=0\n        for x in counts:\n            tot+=x\n            set_size+=1\n            if tot>=(len(arr)//2):\n                break\n        return set_size\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        hash_map = collections.Counter(arr)\n        hash_map = {k:v for k,v in sorted(hash_map.items(),key=lambda item: item[1])}\n        total_size = len(arr)\n        values = list(hash_map.values())[::-1]\n        # print(values)\n        ans=0\n        i=0\n        while total_size>len(arr)//2:\n            total_size-=values[i]\n            i+=1\n            ans+=1\n        return ans", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        N = len(arr)\n        target = math.ceil(N/2)\n        dic = collections.Counter(arr)\n        lst = [(num,cnt) for num,cnt in dic.items()]\n        lst.sort(key = lambda x: [-x[1],x[0]])\n        \n        ans = 0\n        count = 0\n        for num,cnt in lst:\n            count += cnt\n            ans += 1\n            if count >= target:\n                return ans\n        return ans", "from collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        temp = sorted([(v, k) for k, v in list(cnt.items())])\n        curr = 0\n        for i in range(1, len(temp)+1):\n            curr += temp[-i][0]\n            if curr >= len(arr)/2:\n                return i\n", "from collections import defaultdict\nfrom collections import OrderedDict\nclass Solution:\n    \n    def createCount(self,arr):\n        res = defaultdict(lambda:0)\n        for num in arr:\n            res[num]+=1\n        res = sorted(list(res.items()),key = lambda x:x[1],reverse = True)\n        res = collections.OrderedDict(res)\n        return res\n    \n    def minSetSize(self, arr: List[int]) -> int:\n        total = 0\n        num = 0\n        res = self.createCount(arr)\n        for key in res:\n            if total>=len(arr)//2:\n                return num\n            total+=res[key]\n            num+=1\n            \n        return num    \n            \n            \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        dic = {}\n        n_arr = []\n        res = 0\n        length = len(arr)\n        for i in arr:\n            if i in list(dic.keys()):\n                dic[i] += 1\n            else:\n                dic[i] = 1\n        \n        for i in dic:\n            n_arr.append([dic[i], i])\n        \n        n_arr = sorted(n_arr)\n        for i in range (len(n_arr) -1, -1, -1):\n            length -= n_arr[i][0]\n            res+=1\n            if length <= len(arr)//2:\n                break\n        return res\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        L = len(arr)\n        \n        count = collections.Counter(arr)\n        freq = sorted(count.values())\n        size = 0\n        res = 0\n        \n        for i in range(len(freq)-1, -1, -1):\n            size += freq[i]\n            res += 1\n            if size >= L/2:\n                return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        import math\n        from collections import Counter\n        a=Counter(arr)\n        b=list(a.values())\n        b.sort(reverse = True)\n        n=len(arr)\n        summ=0\n        for i in range(len(b)):\n            summ+=b[i]\n            if summ>=int(math.floor(0.5*n)):\n                return i+1\n        return None", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        freq = Counter(arr)\n        h = []\n        for num, freq in freq.items():\n            print(num, freq)\n            heappush(h, (-freq, num))\n        count = 0\n        ret = 0\n        while count < (len(arr) // 2):\n            count += -heappop(h)[0]\n            ret += 1\n        return ret", "from collections import OrderedDict\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        fq = {}\n        for i in arr:\n            fq[i] = fq.get(i, 0) + 1\n        sorted_m = OrderedDict(sorted(list(fq.items()), key=lambda k:(k[1], k[0]), reverse=True))\n        \n        sm = 0\n        req = len(arr)//2 + len(arr)%2\n        ans = 0\n        for i in sorted_m:\n            sm += sorted_m[i]\n            ans += 1\n            if sm>=req:\n                break\n        return ans\n", "\nclass Solution:\n    def minSetSize(self, array: List[int]) -> int:\n        hashMap = dict()\n        for item in array:\n            if item not in hashMap:\n                hashMap[item] = 0\n            hashMap[item] += 1\n        \n\n                \n        length = len(array)\n        itemToBeRemoved = 0\n        halfOflength = len(array) // 2\n        \n\n        \n        for value in sorted(list(hashMap.values()), reverse = True):\n            length -= value\n            itemToBeRemoved += 1\n            if length <= halfOflength:\n                return itemToBeRemoved\n", "import collections\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        count = sorted(list(collections.Counter(arr).values()), reverse=True)\n        toRemove = 0\n        size = 0\n        for c in count:\n            toRemove += c\n            size += 1\n            if toRemove >= len(arr) / 2:\n                break\n        return size\n\n\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counter = collections.Counter(arr)\n        sums = [0 for i in range(len(counter))]\n        curr = 0\n        half = len(arr) // 2\n        if len(arr) % 2 == 1:\n            half += 1\n        res = len(counter)\n        for i, key in enumerate(sorted(counter.keys(), key=lambda x:counter[x], reverse=True)):\n            curr += counter[key]\n            if curr >= half:\n                res = min(res, i + 1)\n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        if len(set(arr))==1:\n            return 1\n        if len(set(arr))==len(arr):\n            if len(arr)%2==0:\n                return int(len(arr)/2)\n            else:\n                return (len(arr)//2) +1\n        u=list(set(arr))\n        d_u={}\n        for ele in u:\n            d_u[ele]= arr.count(ele)\n            \n        d_u=sorted(list(d_u.items()), key=lambda x: x[1], reverse=True)\n        #print(d_u)\n        s=0\n        size=0\n        for ele in d_u:\n            size+=1\n            s+= ele[1]\n            if (s>= len(arr)/2) & (len(arr)%2==0):\n                return size\n            if (len(arr)%2==1) & (s>= (len(arr)//2+1) ):\n                return size\n            \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        half = len(arr) / 2\n        counts = {}\n        for val in arr:\n            if val in counts.keys():\n                counts[val] += 1\n            else:\n                counts[val] = 1\n        count = 0\n        included = 0\n        for key in sorted(counts, key=counts.get, reverse=True):\n            count += counts[key]\n            included += 1\n            if (count >= half):\n                return included", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d={}\n        for i in arr:\n            if i not in d:\n                d[i]=0\n            d[i]+=1\n        d=list(sorted(d.items(), key = lambda kv:kv[1],reverse=True))\n        sum=0\n        cnt=0\n        for i in range(len(d)):\n            if sum>=(len(arr)/2):\n                break\n            else:\n                sum=sum+d[i][1]\n                cnt+=1\n        return cnt             ", "'''\nKeep a dict of counts and add all of them to a heap. Then we remove from heap until size <= half and we return size of set that we have to remove\n'''\nfrom heapq import heapify, heappush, heappop\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counts = collections.Counter(arr)\n        maxheap = []\n        for i, freq in list(counts.items()):\n            maxheap.append((-freq,i))\n        heapify(maxheap)\n        curN = len(arr)\n        sol = 0\n        while curN > len(arr) / 2:\n            freq, cur = heappop(maxheap)\n            curN += freq\n            sol += 1\n            \n            \n        return sol\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        half = len(arr)//2\n        count = ans = 0\n        counts = Counter(arr)\n        \n        for k, v in counts.most_common():\n            ans += v\n            count+=1\n            if  ans >= half:\n                return count\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        n = len(arr)//2\n        freq = {}\n        for i in arr:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n        res = [i for i in freq.values()]\n        res.sort(reverse = True)\n        total = 0\n        count = 0\n        for i in res:\n            total += i\n            count += 1\n            if total >= n:\n                return count", "from collections import defaultdict\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counter = defaultdict(int)\n        for a in arr:\n            counter[a] += 1\n        nums = list(counter.keys())\n        nums.sort(key = lambda x: counter[x], reverse = True)\n        count = 0\n        total = 0\n        half = (len(arr)+1) // 2\n        for n in nums:\n            total += counter[n]\n            count += 1\n            if total >= half: return count ", "import collections\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = collections.Counter(arr)\n        \n        vals = sorted(list(d.values()),reverse=True)\n        \n        ans = 0\n        s = 0\n        for i in range(len(vals)):\n            ans += 1\n            s += vals[i]\n            if s >= len(arr)//2:\n                return ans\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        H ={}\n        for x in arr:\n            H[x]=H.get(x,0)-1\n        L = list(H.values())\n        heapq.heapify(L)\n        t = 0\n        a = 0\n        # print(L)\n        M = len(arr)//2\n        while t < M:\n            x = heapq.heappop(L)\n            t+=(-x)\n            a+=1\n        return a\n            \n        \n        \n", "from collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        temp = sorted(list(cnt.keys()), key = lambda x: cnt[x])\n        curr = 0\n        for i in range(1, len(temp)+1):\n            curr += cnt[temp[-i]]\n            if curr >= len(arr)/2:\n                return i\n", "import collections\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        freq = collections.Counter(arr)\n        comp = [(freq[key],key) for key in freq]\n        comp.sort(reverse=True)\n        target = len(arr)/2\n        index,curr_sum = 0,0\n        while index < len(comp) and curr_sum < target:\n            curr_sum += comp[index][0]\n            index +=1\n        return index", "import numpy as np\nimport collections\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        dict_gens = collections.Counter(arr)\n        generators = sorted(dict_gens.values())\n        min_deactivate = np.ceil(len(arr)/2)\n        turn_off = 0\n        i = 1\n        while turn_off < min_deactivate:\n            turn_off += generators[-i]\n            i += 1\n        return i-1\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        if len(arr) == 0:\n            return 0\n        if len(arr) < 3:\n            return 1\n        \n        counter = {}  # Could use defaultdict to save a few lines of code\n        for n in arr:\n            if n in counter:\n                counter[n] += 1\n            else:\n                counter[n] = 1\n        \n        counts = sorted(counter.values())\n        \n        total_ints = len(arr)\n        set_size = 0\n        \n        while total_ints > len(arr)//2:\n            set_size += 1\n            total_ints -= counts.pop()\n        \n        return set_size\n                \n                \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        n, target = len(arr), len(arr)//2\n        counts = {}\n        for i in arr:\n            if i in counts:\n                counts[i] += 1\n            else:\n                counts[i] = 1\n        \n        counts = sorted(list(counts.values()), reverse=True)\n        \n        numRemoved = 0\n        for i in counts:\n            n -= i\n            numRemoved += 1\n            if n <= target:\n                return numRemoved\n        \n        return numRemoved\n        \n", "class Solution:\n    def minSetSize(self, arr) -> int:\n        counter = {}\n        for val in arr:\n            if val not in counter:\n                counter[val] = 0\n            counter[val] += 1\n        values = []\n        for val in counter:\n            values.append(counter[val])\n        values.sort(reverse=True)\n\n        total = 0\n\n        nhalf = len(arr) // 2\n        new_n = len(arr)\n        i = 0\n        while new_n > nhalf:\n            total += 1\n            new_n -= values[i]\n            i += 1\n\n        return total", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        length = len(arr)\n        counter = {}\n        for num in arr:\n            try:\n                counter[num] += 1\n            except:\n                counter[num] = 1\n        \n        array = sorted(list(counter.items()), key = lambda x:(-x[1], x[0]))\n        # print(array)\n        res = 0\n        i = 0\n        while res * 2 < length:\n            res += array[i][1]\n            i += 1\n        return i", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        order = collections.Counter(arr).most_common()\n        ans = 0\n        sum = 0\n        mid = len(arr)//2 if len(arr)%2==0 else (len(arr)//2 +1)\n        for i,j in order:\n            sum+=j\n            ans+=1\n            if sum >= mid:\n                break\n        return ans  \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counter = collections.Counter(arr)\n        heap = [(-freq, num) for num, freq in list(counter.items())]\n        heapq.heapify(heap)\n        target = len(arr) // 2\n        ans = len(heap)\n        while target > 0:\n            target += heapq.heappop(heap)[0]\n        return ans - len(heap)\n            \n", "import collections\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        lst = []\n        dic = collections.Counter(arr)\n        keys = sorted(dic,key = lambda x: dic[x],reverse = True)\n        \n        for n in keys:\n            if len(lst) >= len(arr)//2:\n                return len(set(lst))\n            else:\n                for _ in range(dic[n]):\n                    lst.append(n)\n        \n        if len(lst) >= len(arr)//2:\n                return len(set(lst))", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        counts = dict()\n        # count all distinct values\n        for i in arr:\n            counts[i] = counts.get(i, 0) + 1\n            \n        #greedy solution\n        #sort counts in desc order\n        total_count=0        \n        for index, count in enumerate(sorted(list(counts.values()), reverse=True)):\n            total_count += count\n            if total_count >= len(arr) // 2:\n                return index + 1\n        return 0\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        for num in arr:\n            if num in d:\n                d[num] += 1\n            else:\n                d[num] = 1\n        \n        val = [d[i] for i in d]\n        val.sort(reverse = True)\n        \n        count, total = 0,0\n        for each in val:\n            total += each\n            count += 1\n            if total >= len(arr)//2:\n                break\n        return count\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        arr.sort()\n        \n        counts = []\n        current_run = 1\n        for i in range(1, len(arr)):\n            if arr[i] == arr[i - 1]:\n                current_run += 1\n                continue\n            counts.append(current_run)\n            current_run = 1\n        counts.append(current_run)\n\n        # Reverse sort the counts.\n        counts.sort(reverse=True)\n\n        # Remove numbers until at least half are removed.\n        numbers_removed_from_arr = 0\n        set_size = 0\n        for count in counts:\n            numbers_removed_from_arr += count\n            set_size += 1\n            if (numbers_removed_from_arr >= len(arr) // 2):\n                break\n\n        return set_size", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        arrCounter = Counter(arr)\n        sortedList = sorted([(key, arrCounter[key]) for key in arrCounter], key = lambda x:(-x[1], x))\n        arrLen = len(arr)\n        target = arrLen//2\n        ans = 0\n        for _, aNum in sortedList:\n            arrLen -= aNum\n            ans += 1\n            if arrLen <= target:\n                return ans\n", "from collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        half=len(arr)/2\n        count=0\n        dic=Counter(arr)\n        for i in dic.most_common():\n            half-=i[1]\n            count+=1\n            if half<=0:\n                return count\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        length=len(arr)\n        bar=length//2\n        d={}\n        for i in range(len(arr)):\n            d[arr[i]]=d.get(arr[i],0)+1\n        res=0\n        l=list(sorted(d.values(),reverse=True))\n        for value in l:\n            length-=value\n            res+=1\n            if length<=bar:\n                return res\n        return res", "from collections import Counter\nclass Solution:\n    \n    def minSetSize(self, arr: List[int]) -> int:\n        counts = Counter(arr)\n        elements = 0\n        count = len(arr) / 2\n        for (key, value_count) in sorted(list(counts.items()), key=lambda x: x[1], reverse=True):\n            if count <= 0:\n                break\n            elements += 1\n            count -= value_count\n        return elements\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        objective = len(arr)//2\n        res = ret = 0\n        c = collections.Counter(arr)\n        for k, v in c.most_common():\n            res += v\n            ret += 1\n            if res >= objective:\n                break\n        return ret", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        c = Counter(arr)\n        \n        a, res = 0, 0\n        for n, c in c.most_common():\n            a += c\n            res += 1\n            if a >= len(arr) // 2:\n                break\n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        n = len(arr)\n        count = Counter(arr)\n        res = 0\n        s = 0\n        for key, rep in count.most_common():\n            s += 1\n            res += rep\n            if res >=n//2 :\n                return s\n            \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n\n        cnter = collections.Counter(arr).most_common()\n        counting = 0\n        for i, blep in enumerate(cnter):\n            if counting + blep[1] >= len(arr)/2:\n                return i + 1\n            else:\n                counting += blep[1]\n            \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        c=Counter(arr)\n        c=list(c.values())\n        c.sort(reverse=True)\n        k=len(c)//2\n        s=0\n        count=0\n        for i in range(len(c)):\n            s+=c[i]\n            count+=1\n            if s>=len(arr)//2:\n                return count\n            \n            \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        from collections import Counter\n        count = 0\n        ans = 0\n        c = Counter(arr)\n        target = len(arr)/2\n        for k,v in sorted(list(c.items()), key=lambda x: x[1], reverse=True):\n            count+=v\n            ans+=1\n            if count >= target: return ans\n        return 0\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        c=collections.Counter(arr)\n        n=len(arr)\n        res=0\n        count=0\n        for c,v in c.most_common():\n            count+=v\n            res+=1\n            if count>=n//2:\n                break\n        \n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        for k in arr:\n            if k in d:\n                d[k] += 1\n            else:\n                d[k] = 1\n                \n        t = []\n        for k, v in d.items():\n            t.append(v)\n        t.sort(reverse=True)\n        r = 0\n        ii = 0\n        while r < len(arr)//2 + len(arr)%1 :\n            r += t[ii]\n            ii+=1\n        return ii", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        num = {}\n        \n        for i in arr:\n            if i in num:\n                num[i] += 1\n            else:\n                num[i] = 1\n        \n        sort_nums = sorted(num.items(), key=lambda x: x[1], reverse=True)\n        \n        total = 0\n        ind = 0\n        \n        for i in sort_nums:\n            if total < len(arr) / 2:\n                total += i[1]\n                ind += 1\n            else:\n                break\n        \n        return ind", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        ans=0\n        d={}\n        l=[]\n        res=0\n        for i in arr:\n            if i in d:\n                d[i]+=1\n            else:\n                d[i]=1\n        for i in d:\n            l.append(d[i])\n        l.sort(reverse=True)\n        print(l)\n        for i in range(len(l)):\n            res+=l[i]\n            if res>=(len(arr)//2):\n                return i+1\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        A = {}\n        for x in arr:\n            A[x] = A.get(x,0) + 1\n        \n        p = 0 \n        count = 0 \n        for x in sorted(list(A.items()), key = lambda x: -x[1]):\n            p += x[1]\n            count += 1\n            if p >= len(arr) // 2:\n                return count \n        \n                \n\n    \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        dic = {}\n        for num in arr:\n            dic[num] = dic.get(num, 0) + 1\n\n        array = [v for k, v in sorted(list(dic.items()), key=lambda item: item[1], reverse=True)]\n\n        target = len(arr)/2\n\n        current, i = 0, 0\n        for num in array:\n            i += 1\n            current += num\n            if current >= target:\n                return i\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = dict()\n        for x in arr:\n            d.setdefault(x, 0)\n            d[x] += 1\n        c = sorted(d.values(), reverse=True)\n        for i in range(1, len(c)):\n            c[i] += c[i-1]\n        \n        for i, x in enumerate(c):\n            if x >= len(arr) // 2:\n                return i + 1", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        n = len(arr)\n        counter = collections.Counter(arr)\n        cur = 0\n        ans = 0\n        for num in sorted(list(counter.values()) ,reverse = True):\n            cur += num\n            ans += 1\n            if cur >= n//2:\n                return ans\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        mem = {}\n        for i in arr:\n            if i in mem:\n                mem[i]+=1\n            else:\n                mem[i]=1\n        \n        sorted_array = sorted(list(mem.values()), reverse=True)\n        counter = 0\n        res = 0\n        print(sorted_array)\n        for i in sorted_array:\n            res +=i\n            counter += 1\n            print(res)\n            if res>=len(arr)/2:\n                \n                return counter\n        \n            \n        \n        \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d={}\n        for i in arr:\n            if i in list(d.keys()):\n                d[i]+=1\n            else:\n                d[i]=1\n        s= len(arr)\n        ans=0\n        for j in sorted(list(d.items()),key=lambda x:x[1],reverse=True):\n            s-=j[1]\n            ans+=1\n            if s<=(len(arr)//2):\n                return ans\n            else:\n                continue\n        \n            \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        tmp_dict = {}\n        for e in arr:\n            if e not in tmp_dict:\n                tmp_dict[e] = 1\n            else:\n                tmp_dict[e] += 1\n        tmp = [(key,tmp_dict[key]) for key in tmp_dict]\n        tmp.sort(key=lambda x:x[1],reverse=True)\n        res = []\n        cur = 0\n        i = 0\n        while cur<len(arr)//2:\n            res.append(tmp[i][0])\n            cur += tmp[i][1]\n            i += 1\n        return len(res)\n            \n", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr) -> int:\n        counterArr = [0] * (len(arr) + 1)\n        for value in Counter(arr).values():\n            counterArr[value] += 1\n        steps = 0\n        total = 0\n        print(counterArr)\n        for i in reversed(range(len(arr) + 1)):\n            num = counterArr[i]\n            for j in range(num):\n                total += i\n                steps += 1\n                if total >= len(arr) // 2:\n                    return steps\n        return steps", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        occ = {}\n        for num in arr:\n            if num in occ:\n                occ[num] += 1\n            else:\n                occ[num] = 1\n\n        occ_lst = list(occ.items())\n        occ_lst.sort(key=lambda x: x[1], reverse=True)\n        total_elems_removed = 0\n        removal_set_size = 0\n        for i, (_, num_occur) in enumerate(occ_lst):\n            total_elems_removed += num_occur\n            if total_elems_removed >= math.ceil(len(arr) / 2.0):\n                return i + 1", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        h = {}\n        for i in arr:\n            if not i in h:\n                h[i] = 0\n            h[i] += 1\n            \n        v = sorted(list(h.values()),reverse = True)\n        m = len(arr)\n        t = 0\n        p = 0\n        i = 0\n        print(v)\n        while t < m//2:\n            t += v[i]\n            i+=1\n            p+=1\n            \n        return p\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        d = {}\n        n = len(arr)\n        \n        for a in arr:\n            d[a] = d.get(a,0) + 1\n        \n        val  = sorted(list(d.items()), key = lambda x :x[1])[::-1]\n        \n        count =0\n        \n        for i,(_,val_i) in enumerate(val):\n            count += val_i\n            print(count)\n            if count>=n//2:\n                return i +1\n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        dict_freq = {}\n        \n        for i in range(len(arr)):\n            if arr[i] in dict_freq:\n                dict_freq[arr[i]] += 1\n            else:\n                dict_freq[arr[i]] = 1\n                \n        target_size = len(arr)//2\n        sort_dict = dict(sorted(list(dict_freq.items()), key=lambda x: x[1], reverse=True))\n        print(sort_dict)\n        for i in dict_freq:\n            \n            if dict_freq[i] >= target_size:\n                \n                return 1\n            else:\n                break\n        cnt = 0 \n        count = 0\n        for i in sort_dict:\n            cnt = cnt + sort_dict[i]\n            count = count+1\n            if cnt >= target_size:\n                return count\n                \n        return 8\n            \n            \n", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        countOfArray = Counter(arr)\n        listOfValues = list(countOfArray.values())\n        listOfValues.sort(reverse = True)\n        lenOfArray = len(arr)\n        halfTheLength = lenOfArray//2\n        ret = 0\n        for val in listOfValues:\n            lenOfArray = lenOfArray - val\n            ret += 1\n            if lenOfArray <= halfTheLength :\n                break\n        return ret", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        if len(set(arr)) == 1:\n            return 1\n        maps = {x:0 for x in set(arr)}\n        for x in arr:\n            maps[x]+=1\n        maps  = sorted(list(maps.items()), key=lambda x: x[1], reverse=True)\n        mincount = len(arr)//2\n        ans = 0\n        currLength,sub = len(arr),9\n        # print(maps)\n        for x in range(len(maps)):\n            key,val = maps[x]\n            if currLength > mincount:\n                currLength -= val\n                ans += 1\n            else:\n                return ans\n\n\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        arr_len = len(arr)\n        # arr_int = list(set(arr))\n        int_dict={}\n        val=[]\n        for i in arr:\n            int_dict[i] = int_dict.setdefault(i,0) + 1\n        \n        for i in int_dict:\n            val.append(int_dict[i])\n        val.sort()\n        \n        count_num=0\n        loc=0\n        for i in val[::-1]:\n            count_num+=i\n            loc+=1\n            if count_num>=arr_len/2:\n                break\n        return loc\n        # if len(set(arr)) == arr_len:\n        #     return int(arr_len+0.5)\n        # else:\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        c = Counter(arr)\n        result = list()\n        count = 0\n        for k,v in sorted(c.items(),key = lambda item: item[1],reverse=True):\n            if count < len(arr)//2:\n                result.append(k)\n                count += v\n        return len(result)", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        d = {}\n        n = len(arr)\n        \n        for a in arr:\n            d[a] = d.get(a,0) + 1\n        \n        val  = sorted(list(d.items()), key = lambda x :x[1])[::-1]\n        \n        count =0\n        \n        for i,(_,val_i) in enumerate(val):\n            count += val_i\n            \n            if count>=n//2:\n                return i +1\n        \n", "class Solution:\n    def floor_counter(self,n):\n      if n%2==0:\n        return n/2\n      else:\n        return (n+1)/2\n    def minSetSize(self, arr: List[int]) -> int:\n      ceiling = self.floor_counter(len(arr))\n      freq = {}\n      for elem in arr:\n        if elem in freq:\n          freq[elem] += 1\n        else:\n          freq[elem] = 1\n      sorted_freq = sorted(freq.items(), key=lambda k:k[1], reverse=True)\n      sum = 0\n      type_counter = []\n      for i in range(len(sorted_freq)):\n        sum +=(sorted_freq[i][1])\n        print(sum)\n        type_counter.append(sorted_freq[i][0])\n        if sum>=ceiling:\n          return len(type_counter)", "from collections import defaultdict\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        occurances = defaultdict(int)\n        \n        for num in arr:\n            occurances[num] += 1\n          \n        dictlist = []\n        for key, value in occurances.items():\n            temp = [key,value]\n            dictlist.append(temp)\n    \n        dictlist = sorted(dictlist, key=lambda x: x[1])\n\n        \n        count = 0\n        removals =0\n        while (count < len(arr) / 2):\n            count += dictlist[-1][1] \n            dictlist.pop()\n            removals +=1 \n        \n        return removals", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        n = len(arr)\n        arr_map = Counter(arr)\n        arr_tup = [(item, arr_map[item]) for item in arr_map]\n        #print(arr_tup)\n        arr_tup = sorted(arr_tup, key= lambda x : -x[1]) #Decrementing based on frequency\n        #print(arr_tup)\n        count = 0\n        total = 0\n        for item in arr_tup:\n            total += item[1] #Counting max freq\n            print((item[0]))\n            count += 1\n            if total >= n/2:\n                return count\n        \n    ''' n = len(arr)\n        \n        freq = {}\n        for i in arr:\n            if i in freq:\n                freq[i] += 1\n            else:\n                freq[i] = 1\n                \n        new_set = set()\n                \n        max_freq = max(freq, key = freq.get)\n        del(freq[max_freq])\n        \n        new_set.add(max_freq)\n        \n        arr = [val for val in arr if val != max_freq]\n        \n        while True:\n            \n            if len(arr) <= n//2:\n                return len(new_set)\n            else:\n                max_freq = max(freq, key = freq.get)\n                del(freq[max_freq])\n                new_set.add(max_freq)\n                arr = [val for val in arr if val != max_freq]'''\n                \n                \n                \n", "from collections import *\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = Counter()\n        for num in arr:\n            d[num] += 1\n        \n        counts = list(d.values())\n        \n        counts.sort(reverse=True)\n        \n        total = 0\n        for (i,count) in enumerate(counts):\n            total += count\n            if total >= len(arr)//2:\n                return i+1\n        \n        return None # should never reach here", "import collections\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        minSizeToRemove = len(arr) //2\n        # print(minSizeToRemove)\n        counter = collections.Counter(arr)\n        # print(counter)\n        sortedCounters = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n        sum = 0\n        minSet = set()\n        for i in sortedCounters:\n            \n            sum+=i[1]\n            minSet.add(i[0])\n            # print(i[0], i[1], sum, minSet)\n            if sum >= minSizeToRemove:\n                break\n            \n        return len(minSet)", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n#         if not arr:\n#             return 0\n        \n#         ceil = len(arr) / 2.0\n        \n#         count = collections.Counter(arr)\n#         sort = count.most_common()\n#         sum = 0\n#         for idx,val in enumerate(sort):\n#             sum += val[1]\n#             if sum >= ceil:\n#                 return idx+1\n            \n#         return idx+1\n        if not arr:\n            return 0\n        counter = collections.Counter(arr)\n        max_val = max(counter.values())\n        \n        buckets = [0] * (max_val+1)\n        \n        for count in list(counter.values()):\n            buckets[count] += 1\n            \n        set_size = 0\n        arr_num_to_remove = len(arr) // 2\n        bucket = max_val\n        \n        while arr_num_to_remove > 0:\n            max_need_from_bucket = math.ceil(arr_num_to_remove / bucket)\n            set_size_increase = min(buckets[bucket],max_need_from_bucket)\n            set_size += set_size_increase\n            arr_num_to_remove -= set_size_increase * bucket\n            bucket -= 1\n            \n        return set_size\n    \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        numberDict = {}\n        \n        for i in range(len(arr)):\n            \n            if arr[i] not in numberDict:\n                numberDict[arr[i]] = 1\n            else:\n                numberDict[arr[i]] += 1\n                \n        sortedOrders = sorted(list(numberDict.items()), key=lambda x: x[1], reverse=True)\n        \n        total = 0\n        setSize = 0\n        for i in sortedOrders:\n            \n            \n            if total >= (len(arr)//2):\n                return setSize\n            \n            total += i[1]\n            setSize += 1\n        \n        \n        return setSize\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n#         total_count = len(arr)\n#         values = set(arr)\n#         values = list(values)\n#         possible_combinations = []\n        \n#         for i in values:\n#             possible_combinations.append([i,arr.count(i)])\n        \n#         result = [seq for i in range(len([item[1] for item in possible_combinations]), 0, -1) for seq in itertools.combinations([item[1] for item in possible_combinations], i) if sum(seq) >= total_count//2]\n        \n        \n#         return min(len(i) for i in result)\n    \n    \n        total_count = 0\n        arr_mc = collections.Counter(arr).most_common()\n        \n        print(arr_mc)\n        \n        for i in range(len(arr_mc)):\n            total_count += arr_mc[i][1]\n            if total_count >= len(arr)/2:\n                return i + 1\n        \n            \n            \n            \n        \n        \n        \n        \n", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        sz = len(arr)\n        d = sorted(list(Counter(arr).items()), key=lambda x: -x[1])\n        num = 0\n        numElems = 0\n        for e in d:\n            numElems += e[1]\n            if numElems < sz//2:\n                num += 1\n            else:\n                return num+1\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        n = len(arr)\n        for num in arr:\n            if num not in d:\n                d[num] = 0\n            d[num] += 1\n        num_freq = list(sorted([v for k,v in d.items()]))\n        tot = 0\n        m = len(num_freq)\n        i = 0\n        \n        while(tot < n/2 and i<m):\n            tot += num_freq[m-i-1]\n            i+=1\n            print(i)\n        print(num_freq)\n        return i", "class Solution:\n    \n    def check(self, arr, to_remove):\n        return len(tuple(filter(lambda x: not to_remove.contains(x), arr))) <= len(arr) / 2\n    \n    def minSetSize(self, arr: List[int]) -> int:\n        all_nums = set(arr)\n        freq = {n:0 for n in all_nums}\n        for num in arr:\n            freq[num] += 1\n            \n        nums_by_count = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n        remove_count = 0\n        result = 0\n        half = len(arr) / 2\n        for item in nums_by_count:\n            num, count = item\n            remove_count += count\n            result += 1\n            if remove_count >= half:\n                return result", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        dict_={}\n        for num in arr:\n            if num not in dict_:\n                dict_[num]=1\n            else:\n                dict_[num]+=1\n                \n        sort_list = sorted(dict_.keys(),key=lambda x: dict_[x],reverse=True)\n        \n        n = len(arr)\n        size = 0\n        for num in sort_list:\n            n-=dict_[num]\n            size+=1\n            if n<len(arr)//2+1:\n                return size", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # get length of array \n        length = len(arr)\n        # build dict to count how many times each int appears\n        counts = {}\n        for num in arr:\n            if num not in counts:\n                counts[num] =1\n            else:\n                counts[num] += 1\n                \n        # print(counts)\n        \n        # get values from dict, sort in descending order\n        descending = sorted(counts.values(), reverse =  True)\n        # print(descending)\n        # initialize 2 variables: count and total\n        count = 0\n        total = 0\n        # loop over descending list of counts\n        for num in descending:\n            # add each number to our total\n            total += num\n            # increment count by 1\n            count += 1\n            # if our total is half or more, return count\n            if total >= length/2:\n                return count", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        from collections import Counter\n        \n        c = Counter (arr)\n        \n        ls = []\n        for i, c in c.items ():\n            ls .append ((c, i))\n            \n        ls.sort (reverse=True)\n        #print (ls)\n        \n        l = 0\n        r = len (ls)-1\n        \n        res = 0\n        items = 0\n        \n        for i in range (len(ls)):\n            res += 1\n            items += ls[i][0]\n            #print (items)\n            if items >=  (len(arr)//2):\n                break\n                \n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        arr.sort()\n        freq=[]\n        k=0\n        while k<len(arr):\n            j=k+1\n            fr=1\n            while j<len(arr):\n                if arr[j]==arr[k]:\n                    fr+=1\n                else:\n                    break\n                j+=1\n                k+=1\n            freq.append(fr)\n            k+=1\n        freq.sort()\n        freq.reverse()\n        k=0\n        no=0\n        count=0\n        while k<len(freq) and count<len(arr)/2:\n            if freq[0]>=len(arr)/2:\n                no+=1\n                break\n            count=count+freq[k]\n            no+=1\n            k+=1\n        return no\n            \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # get counts of each element\n        counts = {}\n        for i, elem in enumerate(arr):\n            counts[elem] = 1 if elem not in counts else counts[elem]+1\n        # keep getting max and checking if the length is less than half upon removal until it is\n        size = len(arr)\n        count = 0\n        vals = sorted(counts.values(),reverse=True)\n        while size > len(arr)/2:\n            maxElem = vals[count]\n            size -= maxElem\n            count += 1\n        return count", "import math\nfrom collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        curr = len(arr)\n        target = math.ceil(len(arr) / 2)\n        ans = 0\n        \n        counts = Counter(arr)\n        \n        for count in sorted(list(counts.values()), reverse=True):\n            curr -= count\n            ans += 1\n            \n            if curr <= target:\n                return ans\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # get the most freq occurring ints \n        d = {}\n        for a in arr:\n            if a in d:\n                d[a] += 1\n            else:\n                d[a] = 1\n        \n        q = []\n        for k in d:\n            heappush(q, (-d[k], k))\n        \n        size = len(arr)\n        half = len(arr) / 2\n        numPop = 0\n        while size > half:\n            poped = heappop(q)\n            size += poped[0]\n            numPop += 1\n        \n        return numPop", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        targetLen = len(arr) / 2\n        elementsRemoved = depth = 0\n        \n        data = collections.Counter(arr)\n        \n        for key, val in data.most_common():\n            elementsRemoved += val\n            depth += 1\n            \n            if elementsRemoved >= targetLen:\n                return depth\n            \n            \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        half = len(arr) // 2\n        d = {}\n        for num in arr:\n            if num not in d:\n                d[num] = 0\n            d[num] += 1\n        \n        lst = sorted(list(d.values()), reverse=True)\n        \n        accum = 0\n        res = 0\n        for item in lst:\n            if accum < half:\n                accum += item\n                res += 1\n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = collections.defaultdict(int)\n        for i in arr:\n            d[i] += 1\n        res = len(arr)\n        orig = len(arr)\n        count = 0\n        \n        freq = [(d[i],i) for i in d]\n        freq.sort(reverse=True)\n        count = 0\n        for i in freq:\n            res -= i[0]\n            count+= 1\n            if res <= orig//2:\n                return count\n        return -1", "from collections import defaultdict\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        count_map = defaultdict(int)\n        for num in arr:\n            count_map[num] += 1\n        \n        \n        res_arr = []\n        for num, count in count_map.items():\n            res_arr.append((count, num))\n        \n        res_arr = sorted(res_arr)[::-1]\n        \n        count = 0\n        index = 0\n        while count < len(arr) // 2:\n            count += res_arr[index][0]\n            index += 1\n        \n        return index", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        halfLength = len(arr)//2\n        valDict = {}\n        for val in arr:\n            if val in valDict:\n                valDict[val] += 1\n            else:\n                valDict[val] = 1\n\n        setSize = 0\n        lengthValsRemoved = 0\n        for val in sorted(valDict.values(), reverse=True):\n            setSize += 1\n            lengthValsRemoved += val\n            if lengthValsRemoved >= halfLength:\n                break\n\n        return setSize", "from collections import Counter\n\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        n = len(arr)\n        counts = Counter(arr)\n        sorted_counts = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n        count = 0\n        ans = 0\n        for sc in sorted_counts:\n            count += sc[1]\n            ans += 1\n            if count >= n//2:\n                return ans\n        return ans", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        frequency = defaultdict(int)\n        for num in arr:\n            frequency[num] += 1\n        arrLength = len(arr)\n        pairs = []\n        for key,val in frequency.items():\n            pairs.append((val,key))\n        pairs.sort(reverse = True)\n        cumSum = 0\n        for counter,pair in enumerate(pairs):\n            frequency,key = pair\n            cumSum += frequency\n            if cumSum >= arrLength/2:\n                return counter+1", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        countOfArray = Counter(arr)\n        listOfValues = list(countOfArray.values())\n        listOfValues.sort(reverse = True)\n        lenOfArray = len(arr)\n        halfTheLength = lenOfArray//2\n        ret = 0\n        for val in listOfValues:\n            lenOfArray = lenOfArray - val\n            ret += 1\n            if lenOfArray <= halfTheLength :\n                break\n        return ret", "from math import ceil\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        arr.sort()\n        brr = []\n        count = 1\n        cur = arr[0]\n        for i in range(1,len(arr)):\n            if cur == arr[i]:\n                count += 1\n            else:\n                brr.append([cur,count])\n                cur = arr[i]\n                count = 1\n        brr.append([cur,count])\n        brr.sort(key = lambda x:x[1],reverse = True)\n        temp = 0\n        temp1 = 0\n        \n        for i in brr:\n            if temp >=ceil(len(arr)/2):\n                return temp1\n            temp1 += 1\n            temp += i[1]\n        return 1\n            \n        \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        numsdict = {}\n        for i in arr:\n            numsdict[i] = numsdict.get(i,0) + 1\n        \n        sortarr = sorted(numsdict.items(), key = lambda x: -x[1])\n        \n        count = 0\n        i = 0\n\n        while 2*count < len(arr):\n            count += sortarr[i][1]\n            i += 1\n            \n        return i", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = collections.defaultdict(int)\n        for i in arr:\n            d[i] += 1\n        s = sorted([(d[i],i) for i in d],reverse=True)\n        res = 0\n        ans = 0\n        for i,v in s:\n            res += i\n            ans += 1\n            if res >= (len(arr) + 1) // 2: return ans\n        return len(d)", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        c = Counter(arr)\n        l = len(arr)\n        tup = c.most_common(len(c))\n        i = 0\n        while l > len(arr)/2:\n            l -= tup[i][1]\n            i += 1\n            \n        return i\n", "import numpy as np\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        n = len(arr)\n        dict_model = {}\n        for it in arr:\n            if it in dict_model.keys():\n                dict_model[it] += 1\n            else:\n                dict_model[it] = 1\n        min_deactivate = np.ceil(n/2)\n        generators = list(dict_model.values())\n        generators.sort()\n        turn_off = 0\n        i = 1\n        while turn_off < min_deactivate:\n            turn_off += generators[-i]\n            i += 1\n        return i-1", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        if not arr: return 0\n        int_freq = collections.Counter(arr)\n        size = len(arr)\n        cur_size = size\n        \n        count = 0\n        for num, freq in int_freq.most_common():\n            cur_size -= freq\n            count += 1\n            if cur_size <= size // 2:\n                return count", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # L, C = len(arr), collections.Counter(arr)\n        # S = sorted(C.values(), reverse = True)\n        # T = itertools.accumulate(S)\n        # for i,v in enumerate(T):\n        #     if v >= len(arr)//2: return i + 1\n        \n        \n        \n        h = [(val*(-1),key) for key,val in list(Counter(arr).items())]\n        heapify(h)\n        #print(h)\n        num_int = 0\n        count = 0\n        while 2*count*(-1) < len(arr):\n            c,i = heappop(h)\n            count += c\n            num_int +=1\n            #print(seen)\n        return num_int\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        l=len(arr)\n        s=0\n        \n        cnt= Counter(arr)\n        cnt= [j for i,j in cnt.items()]\n        cnt.sort(reverse=True)\n        for ind,i in enumerate(cnt):\n            s+=i\n            if s>=l//2:\n                break\n        return ind+1", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # L, C = len(arr), collections.Counter(arr)\n        # S = sorted(C.values(), reverse = True)\n        # T = itertools.accumulate(S)\n        # for i,v in enumerate(T):\n        #     if v >= len(arr)//2: return i + 1\n        \n        \n        \n        dic = Counter(arr)\n        h = [(val*(-1),key) for key,val in list(dic.items())]\n        heapify(h)\n        #print(h)\n        num_int = 0\n        count = 0\n        while 2*count*(-1) < len(arr):\n            c,i = heappop(h)\n            count += c\n            num_int +=1\n            #print(seen)\n        return num_int\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        n,half = len(arr), len(arr) // 2\n        seen = set()\n        for i in arr:\n            d[i] = d.get(i,0) + 1\n        d = sorted(d.items(), key=lambda x: -x[1])\n        for k,v in d:\n            if n - v > half:\n                n -= v\n                seen.add(k)\n            else:\n                seen.add(k)\n                return len(seen)", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        h = {}\n        for el in arr:\n            if el not in h:\n                h[el] = 0\n            h[el] += 1\n        \n        tmp = []\n        for key in list(h.keys()):\n            tmp.append(h[key])\n        \n        tmp.sort()\n        \n        count = 0\n        size = 0\n        for i in range(len(tmp) - 1, -1, -1):\n            size += tmp[i]\n            count += 1\n            if size >= math.ceil(len(arr) / 2):\n                break\n            \n        \n        return count\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        dic = Counter(arr)\n        h = [(val*(-1),key) for key,val in list(dic.items())]\n        heapify(h)\n        #print(h)\n        seen = set()\n        count = 0\n        while 2*count*(-1) < len(arr):\n            c,i = heappop(h)\n            count += c\n            seen.add(i)\n            #print(seen)\n        return len(seen)\n", "from collections import defaultdict\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # we will store the frequency of all the elements in a dictionary and from the dictionary we will pick the ones with the maximum value and remove them till we do not get half size\n        # we keep two dictionaries ones from number to their frequency and another from frequency to number for better manipulation\n        num_fre = defaultdict(int)\n        fre_num = defaultdict(set)\n        for i in range(len(arr)):\n            num_fre[arr[i]] += 1\n            fre_num[num_fre[arr[i]]].add(arr[i])\n            if fre_num[num_fre[arr[i]] - 1] != set():\n                fre_num[num_fre[arr[i]] - 1].remove(arr[i])\n        \n        del num_fre\n        answer = set()\n        removed_elements = 0\n        for fre in sorted(fre_num.keys(),reverse = True):\n            for element in fre_num[fre]:\n                if removed_elements < len(arr) // 2:\n                    removed_elements += fre\n                    answer.add(element)\n                else:\n                    break\n        return len(answer)", "from collections import Counter\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        tot = n = len(arr)\n        count = Counter(arr)\n        res = 0\n        for k, v in sorted(count.items(), key=lambda x: -x[1]):\n            # print(k,v)\n            tot -= v\n            res += 1\n            if tot <= n // 2:\n                return res\n        return n", "from collections import defaultdict\nclass Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # we will store the frequency of all the elements in a dictionary and from the dictionary we will pick the ones with the maximum value and remove them till we do not get half size\n        # we keep two dictionaries ones from number to their frequency and another from frequency to number for better manipulation\n        num_fre = defaultdict(int)\n        fre_num = defaultdict(set)\n        for i in range(len(arr)):\n            num_fre[arr[i]] += 1\n            fre_num[num_fre[arr[i]]].add(arr[i])\n            if fre_num[num_fre[arr[i]] - 1] != set():\n                fre_num[num_fre[arr[i]] - 1].remove(arr[i])\n        \n        answer = set()\n        removed_elements = 0\n        for fre in sorted(fre_num.keys(),reverse = True):\n            for element in fre_num[fre]:\n                if removed_elements < len(arr) // 2:\n                    removed_elements += fre\n                    answer.add(element)\n                else:\n                    break\n        return len(answer)", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        # count = Counter(arr)\n        # count = sorted(count.items(), key=lambda item: item[1], reverse=1)\n        # total = len(arr)\n        # i = 0\n        # res = set()\n        # while total > len(arr) // 2:\n        #     total -= count[i][1]\n        #     res.add(count[i][0])\n        #     i += 1\n        # return res\n        count = sorted(Counter(arr).values(), reverse=1)\n        target = (len(arr)) // 2\n        res = curr = 0\n        for val in count:\n            curr += val\n            res += 1\n            if curr >= target:\n                break\n        return res", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        N = len(arr)\n        count = collections.Counter()\n        for n in arr:\n            count[n] += 1\n        \n        sorted_count = sorted(list(count.keys()), key=lambda c: count[c], reverse=True)\n        removed_count = 0\n        res = 0\n        for c in sorted_count:\n            removed_count += count[c]\n            res += 1\n            if removed_count >= (N + 1) // 2:\n                break\n        return res\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        h = []\n        for num in arr:\n            if num not in d:\n                d[num] = 1\n            else:\n                d[num] += 1\n                \n        for k, v in list(d.items()):\n            h.append((-v, k))\n            \n        heapq.heapify(h)\n        \n        ans = 0\n        count = 0\n        while count < len(arr)//2:\n            v, k = heapq.heappop(h)\n            count -= v\n            ans += 1\n            \n        return ans\n                \n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        freqs = Counter(arr)\n        \n        sorted_freqs = sorted(list(freqs.items()), key = lambda x : x[1], reverse=True)\n        \n        print(sorted_freqs)\n        \n        half_len = len(arr) / 2\n        \n        current_len = 0\n        res = 0\n        \n        for (i, j) in sorted_freqs:\n            res += 1\n            current_len += j\n            if current_len >= half_len:\n                return res\n", "class Solution:\n    def minSetSize(self, a: List[int]) -> int:\n        d={}\n        n=len(a)//2\n        for i in a:\n            if (i not in d):\n                d[i]=1\n            else:\n                d[i]+=1\n        d=sorted(d.items(),key=lambda x:x[1], reverse=True)\n        print(d)\n        sum=0\n        count=0\n        for i in d:\n            x=i[1]\n            sum+=x\n            count+=1\n            if(sum>=n):\n                break\n        return count", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        hashMap = dict()\n        for item in arr:\n            if item not in hashMap:\n                hashMap[item] = 0\n            hashMap[item] += 1\n        \n                \n        length = len(arr)\n        itemToBeRemoved = 0\n        halfOflength = len(arr) // 2\n        \n        for value in sorted(list(hashMap.values()), reverse = True):\n            length -= value\n            itemToBeRemoved += 1\n            if length <= halfOflength:\n                return itemToBeRemoved\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n      counter = {}\n      for num in arr:\n        if num in counter:\n          counter[num] += 1\n        else:\n          counter[num] = 1\n      \n      heap = []\n      \n      for num in list(counter.keys()):\n        heapq.heappush(heap, (-counter[num], num))\n                       \n      n = len(arr)\n      i = 0\n      cumSum = 0\n      while i < n and cumSum < n//2:\n        freq, num = heapq.heappop(heap)\n        cumSum += abs(freq)\n        i+=1\n      \n      return i\n", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        \n        checked, answer = [],0\n        count_d,total = [],0\n        \n        if len(arr) == len(set(arr)):\n            return int(len(arr)/2)\n        \n        for num in arr:\n            if num not in checked:\n                count_d.append(arr.count(num))\n                checked.append(num)\n        \n        #count_d = sorted(count_d.items(), key=operator.itemgetter(1))\n        count_d.sort()\n        \n        for d in range(1, len(count_d)+1):\n            total += count_d[-d]\n            answer += 1\n            if total >= len(arr)/2:\n                return answer", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        \n        for el in arr:\n            if d.get(el): d[el] += 1\n            else: d[el] = 1\n                \n        s = sorted(d.values())\n        l = len(arr) / 2\n        c = 0\n        \n        for i in reversed(range(len(s))):\n            l -= s[i]\n            c += 1\n            if l <= 0: break\n                \n        return c", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        numsdict = {}\n        for i in arr: numsdict[i] = numsdict.get(i,0) + 1\n        sortarr = sorted(numsdict.values(), reverse = True)\n        \n        count = 0\n        i = 0\n\n        while 2*count < len(arr):\n            count += sortarr[i]\n            i += 1\n            \n        return i", "class Solution:\n    def minSetSize(self, arr: List[int]) -> int:\n        d = {}\n        for i in arr:\n            if i in d:\n                d[i]+=1\n            else:\n                d[i] = 1\n        d = sorted(d.items(), key = lambda x:x[1], reverse=True)\n        print(d)\n        total, count = 0, 0\n        for i in d:\n            total += i[1]\n            count+=1\n            if total >= len(arr)//2:\n                return count"]
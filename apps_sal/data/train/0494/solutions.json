["class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        splits = 0\n        leftstart, leftend = 0, 0\n        rightstart, rightend = n-1, n-1\n        while leftend<rightstart:\n            if text[leftstart:leftend+1] == text[rightstart:rightend+1]:\n                leftstart = leftend+1\n                leftend = leftstart\n                rightstart = rightstart-1\n                rightend = rightstart\n                splits+=2\n            else:\n                leftend+=1\n                rightstart-=1\n        return splits+1 if leftstart<=rightend else splits", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        count = 0\n        i = 0\n        while text:\n            if text[:i+1] == text[-(i + 1):]:\n                count += 1\n                if i + 1 < len(text):\n                    count += 1\n                text = text[i+1:-(i+1)]\n                i = 0\n                continue\n            i += 1\n        return count\n                \n            \n        \n        \n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        @lru_cache(None)\n        def dfs(i, j):\n            if i > j: return 0\n            if i == j: return 1\n            res = 1\n            k = 1\n            while i + k <= j - k + 1:\n                if text[i:i+k] == text[j-k+1:j+1]:\n                    res = max(res, 2 + dfs(i + k, j - k))\n                k += 1\n            return res\n        return max(dfs(0, n - 1), 1)\n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        \n        n = len(text)\n        \n        @lru_cache(None)\n        def dp(left, right):\n        \n            if left > right:\n                return 0\n            \n            if left == right:\n                return 1\n            \n            maxk = 1\n            length = 1\n            #print(left, right)\n            while(left + length <= right - length+1 ):\n                #print(text[left:left+length],text[right-length+1:right+1])\n                if text[left:left+length] == text[right-length+1:right+1]:\n                    maxk = max(maxk, dp(left+length, right-length) + 2)\n                    \n                length += 1\n                \n            \n            return maxk\n        \n        x = dp(0, n-1)\n        return x\n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        found = {}\n        \n        def search(start, end):\n            if start > end:\n                return 0\n            if (start, end) in found:\n                return found[(start, end)]\n            m = 1\n            for i in range(1, (end - start + 1) // 2 + 1):\n                if text[start:start + i] == text[end + 1 - i:end + 1]:\n                    m = max(m, 2 + search(start + i, end - i))\n            found[(start, end)] = m\n            return m\n        \n        return search(0, len(text) - 1)\n", "from collections import deque\n\nclass Solution:\n    def longestDecomposition(self, text: str) -> int:\n        def check(a, b):\n            return all([a[i] == b[i] for i in range(len(a))])\n        \n        ans = 0\n        l, r = deque([]), deque([])\n        for i in range(len(text) // 2):\n            l.append(text[i])\n            r.appendleft(text[-1 - i])\n            if check(l, r):\n                ans += 2\n                l, r = deque([]), deque([])\n        if len(text) % 2 == 0 and len(l) == len(r) == 0:\n            return ans\n        else:\n            return ans + 1\n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n      if not text: return 0\n      i, j, result = 0, len(text) - 1, 0\n      while i < j:\n        if text[:i+1] == text[j:]:\n          return self.longestDecomposition(text[i+1: j]) + 2\n        else:\n          i, j = i + 1, j - 1\n      return 1", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        idxMap = defaultdict(list)\n        for i, ch in enumerate(text):\n            idxMap[ch].append(i)\n            \n        memo = {}\n        def recurse(i, j):\n            if i == j:\n                return 1\n            \n            if i > j:\n                return 0\n            \n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            curMax = 1\n            for k in idxMap[text[i]]:\n                if k > j or i == k:\n                    continue\n                if text[i:i+j-k+1] == text[k:j+1]:\n                    curMax = max(2 + recurse(i+j-k+1, k-1), curMax)\n            \n            memo[(i, j)] = curMax\n            return curMax\n        \n        return recurse(0, len(text)-1)\n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        l, r, lh, rh, curr_len, modulo, base, res = 0, len(text)-1, 0, 0, 0, 32416189573, 26, 0\n        nums = [ord(c)-ord('a') for c in text]\n        while l<r:\n            lh = (lh*base + nums[l])%modulo\n            rh = (nums[r]*base**curr_len+rh)%modulo\n            curr_len += 1\n            \n            if lh==rh and text[l-curr_len+1:l+1]==text[r:r+curr_len]:\n                res += 2\n                lh = rh = curr_len = 0\n            l += 1\n            r -= 1\n        \n        if l==r or curr_len:\n            res += 1\n            \n        return res", "class Solution:\n    import random\n    def longestDecomposition(self, text: str) -> int:\n        \n        def check_eq(s,st1,st2,mx):\n            while s[st1] == s[st2] :\n                st1+=1\n                st2+=1\n                if st1 == mx: return True\n            # if st1 == mx: return True\n            return False\n        \n        if len(text) == 1: return 1\n        ln = len(text)\n        # dp = [(1,-1)]*((ln>>1)+1)\n        a = (1,-1)\n        b = (1,-1)\n        hsh_st = 0\n        hsh_ed = 0\n        ln_ch = 0\n        for i in range(1,(ln>>1)+1):\n            ln_ch += 1\n            # st1 = dp[i-1][1] + 1\n            st1 = b[1] + 1\n            # rnd = random.randint(3,1000)\n            hsh_st += ord(text[i-1])\n            st2 = ln - i\n            hsh_ed += ord(text[st2])\n            total = st1 + ln_ch\n            # print(f'cmp - {text[st1:total]} {text[st2:st2+ln_ch]}')\n            # print(f'st - {st1}, {st2}, {total}')\n            res = False\n            if hsh_st == hsh_ed:\n                # res = True\n                res = check_eq(text,st1,st2,total)\n            if res:\n                # print(f'--True--')\n                # dp[i] = (dp[i-1][0]+2,i-1)\n                b,a = (b[0]+2,i-1) ,b\n                # a = b\n                ln_ch = 0\n                hsh_st = 0\n                hsh_ed = 0\n            else:\n                # dp[i] = dp[i-1]\n                b,a = b,b\n        # print(dp)\n        # print(b,a)\n        if b[0] > a[0] and b[0] > 1 and len(text)%2 == 0:\n            return b[0] -1\n        return b[0]\n        \n        # if dp[-1][0] > dp[-2][0] and dp[-1][0] > 1 and len(text)%2 == 0:\n            # return dp[-1][0] - 1\n        # return dp[-1][0]\n", "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        \n        @lru_cache(None)\n        def helper(i,j):\n            if(i>j):\n                return 0\n            if(i == j):\n                return 1\n\n            ans = 1\n            tmp = 0\n            l = j-i+1\n            for k in range(1,(l//2)+1):\n                if(text[i:i+k] == text[j-k+1:j+1]):\n                    #print(i,j,k,text[i:i+k],text[j-k+1:j+1])\n                    tmp = max(tmp, 2+ helper(i+k,j-k))\n            return max(tmp,1)\n    \n        return helper(0,len(text)-1)\n                \n                \n"]
["def string_func(s, n):\n    l, s = [s], list(s)\n    while True:\n        s[::2], s[1::2] = s[:len(s)//2-1:-1], s[:len(s)//2]\n        l.append(''.join(s))\n        if l[0] == l[-1]: del l[-1]; break\n    return l[n % len(l)]", "# SOLUTION:\n# Actually doing the reversals repeatedly is slow. Through observeration\n# we can find a mapping of single shifts which take the original string directly\n# to the target string while saving a lot of computation. The resulting \"optimized\"\n# manipulations will be different for strings of different lengths,\n# but the same for all strings of a given length.\n#\n# Over the course of multiple sets of reversals, each character necessarily goes through a loop.\n# For example, if the original string is '1234', then the character at index 0\n# will first move to index 1, then after another set of reversals to index 3,\n# and then back to index 0, thus completing a loop.\n# Index 2 may always stay in place.\n# For longer strings, the mapping often results in having multiple of these loops.\n#\n# Once the loops are mapped out, we can easily determine where each character will end up\n# after applying the reversal function x times.\n\ndef string_func(in_str, action_times):\n    \n    input_len = len(in_str)\n    input_mid_point = (input_len + 1) / 2 - 1\n\n    # First we'll map out the loops.\n    # Starting from index 0, figure out where each character will go after one set of reversals.\n\n    loops = [[0]]\n    index = 0\n\n    # Keep track of which loop each character starts in, so that when we want to place it in our new string we'll know where to look.\n    # Right now they're all set to 0, but that will change as we check each index.\n    loop_index_is_in = [0]*input_len\n\n    indices_not_checked = list(range(1, input_len))\n\n    while len(indices_not_checked) != 0:\n\n        # Next-step transitions can be easily calculated\n        if index < input_mid_point:\n            index = index * 2 + 1\n        elif index > input_mid_point:\n            index = (input_len - 1 - index)*2\n        elif index == input_mid_point:\n            index = input_len - 1\n\n        # Next, we'll need to find each of the next locations (the \"loop\") for that character.\n\n        # If we return to an index we've already checked, it means that we've completed a loop and we're done with that start index.\n        # In that case, we'll add a new empty loop to loops and switch to checking an index that hasn't been checked yet,\n        # until we've mapped out all of the loops.\n        if index not in indices_not_checked:\n            loops.append([])\n            index = indices_not_checked[0]\n\n        # Adding the index to the loop it belongs in (the loop we are building is always the last one in loops,\n        # as any earlier loops we've already completed.)\n        loops[-1].append(index)\n\n        indices_not_checked.remove(index)\n\n        # And we'll keep track of which loop each character starts in,\n        # so that when we want to place it in our final result string we'll know where to look.\n        loop_index_is_in[index] = len(loops) - 1\n\n\n    # Now that we mapped out the loops, we need to find which index each character will end up at.\n\n    # For now the final result string (new_string) is actually a list, so that we can use item assignment.\n    new_string = [0] * input_len\n\n    # For each character in the origional string:\n    for char_index in range(input_len):\n\n        # Find the loop that it is in:\n        loop = loops[loop_index_is_in[char_index]]\n\n        # Find where it is in that loop\n        place_in_loop = loop.index(char_index)\n\n        # Figure out where it will go (where it is in the loop, plus the amount of\n        # times we want to apply the reversal function, which is the amount of 'steps' the character will take, mod the length of the loop)\n        new_index = loop[(place_in_loop + action_times)%len(loop)]\n\n        # Insert the character in its place in new_string\n        new_string[new_index] = in_str[char_index]\n\n    # After placing each character in the new_string list, convert the list to a string and return it. That's our final result string.\n    return ''.join(new_string)\n", "def string_func(s, x):\n    if not x: return s\n    k = [s]\n\n    new_s = list(s)\n    while True:\n    \n        #shufling!\n        new_s[::2], new_s[1::2] = new_s[:len(new_s)//2-1:-1], new_s[:len(new_s)//2]\n        \n        k.append(''.join(new_s))\n        if k[-1] == s:\n            return k[x%(len(k)-1)]\n    \n\n", "from itertools import chain, islice\nfrom functools import lru_cache\n\ndef reversal_func(s):\n    return ''.join(islice(chain.from_iterable(zip(s[::-1], s)), len(s)))\n\n@lru_cache()\ndef period(n):\n    # see https://oeis.org/A216066 , comment by [Robert Pfister, Sep 12 2013]\n    # and https://oeis.org/A003558 , formula by [Jonathan Skowera, Jun 29 2013]\n    last = 1\n    for i in range(n):\n        val = abs(2 * n + 1 - 2 * last)\n        if val == 1:\n            return i + 1\n        last = val\n\ndef string_func(s,x):\n    x %= period(len(s))\n    for __ in range(x):\n        s = reversal_func(s)\n    return s", "def string_func(s, n):\n    m, table = len(s), {}\n    for i in range(m):\n        if i not in table:\n            j, cycle = i, []\n            while i != j or not cycle:\n                cycle.append(j)\n                j = min(2 * j + 1, 2 * (m - j - 1))\n            table.update(zip(cycle[n % len(cycle):] + cycle, cycle))\n    return ''.join(s[table[i]] for i in range(m))", "def exp(permutation, n):\n    result = [-1] * len(permutation)\n    for i in range(len(permutation)):\n        if result[i] == -1:\n            j, cycle = i, []\n            while True:\n                cycle.append(j)\n                j = permutation[j]\n                if i == j: break\n            for j, k in enumerate(cycle):\n                result[k] = cycle[(j + n) % len(cycle)]\n    return result\n    \ndef string_func(s, n):\n    m = len(s)\n    perm = [i // 2 if i % 2 else m - 1 - i // 2 for i in range(m)]\n    return ''.join(s[i] for i in exp(perm, n))", "import copy\n\n\ndef string_func(s,x):\n    m,l,arr,z = 0,len(s),[0]*len(s),0\n    while True:\n        m += 1\n        y = (2**m) % (2*l+1)\n        if y == 1 or y == 2*l: break\n    for i in range(1,l,2): \n        arr[z] = i;\n        z += 1\n    for i in range(l-2+l%2,-1,-2):\n        arr[z] = i\n        z += 1\n    ss = list(s)\n    x %= m\n    while x > 0:\n        x -= 1\n        for i in range(len(arr)):\n            ss[arr[i]] = s[i]\n        s = ss.copy()\n    return ''.join(s)", "def string_func(s, x):\n    len_s = len(s)\n    arr = list(s)\n    mapping = []\n    correct_seq = list(range(len_s))\n    changed_seq = correct_seq[:]\n\n    # Make index mapping\n    for i in range(int(len_s / 2 + 0.5)):  # the result of placing the indexes\n        mapping.append(len_s - i - 1)      # of the once applied \"reversal function\"\n        mapping.append(i)\n    if len_s % 2 != 0:\n        mapping.pop()\n\n    # Reduce x\n    for div in range(1, len_s + 1):                      # take a remainder of the division\n        changed_seq = [changed_seq[i] for i in mapping]  # by the distance between repetitions\n        if changed_seq == correct_seq:\n            x %= div\n            break\n\n    while x:\n        arr = [arr[i] for i in mapping]\n        x -= 1\n\n    return ''.join(arr)", "def string_func(s, n):\n    L2 = len(s) // 2\n    l = [s]\n    s = list(s)\n    while True:\n        s[0::2], s[1::2] = s[:L2-1:-1], s[:L2]\n        l.append(''.join(s))\n        if l[0] == l[-1]:\n            del l[-1]\n            break\n    return l[n % len(l)]", "def string_func(s, x):\n    l = len(s)\n    cyc = x % life(l)\n    order = list(s)\n    string = list(s)\n    \n    c = 0\n    for i in range(l-1,-1+l//2,-1): \n        order[c] = i\n        c += 2\n    c = 1\n    for i in range(0,l//2,1):\n        order[c] = i\n        c += 2\n\n    return \"\".join(sort(order, string, cyc))\n\ndef sort(schema, string, times):\n    for x in range(times):\n        result = []\n        for i in range(len(string)):\n            result.append(string[schema[i]])\n        string = result\n    return string\n\ndef life(n):\n    if n <= 1:\n        return 1\n    m = 1\n    while True:\n        a = (2 ** m) % (2 * n + 1)\n        if a == 1 or a == 2 * n:\n            return m\n        m = m + 1\n\n\n"]
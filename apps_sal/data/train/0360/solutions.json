["class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = left * len(weights) // D\n        while left < right: \n            mid = left + (right - left) // 2\n            c = 0 \n            d = 1 \n            for w in weights:\n                if c + w <= mid:\n                    c += w\n                else:\n                    d += 1\n                    c = w\n            if d > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        #binary search, check capacity every time\n        def checkCapacity(cap: int, weights: List[int], D: int):\n            val = 0\n            res = 1\n            for w in weights:\n                val += w\n                if val > cap:\n                    res += 1\n                    val = w\n            return res <= D\n        \n        low = max(weights)\n        high = min(sum(weights), low*len(weights)//D)\n        \n        while low < high:\n            mid = (low + high)//2\n            if checkCapacity(mid,weights,D):\n                high = mid\n            else:\n                low = mid+1\n        return high\n    \n    \n    \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def canShip(capacity: int) -> bool:\n            nonlocal D\n            count = 1\n            curcap = 0 \n            for w in weights:\n                if curcap + w <= capacity:\n                    curcap += w\n                else:\n                    count += 1\n                    curcap = w\n            return count <= D\n            \n        \n        max_weight = max(weights)\n        lo = sum(weights) // D\n        hi = max_weight * (len(weights) // D + 1)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if mid < max_weight or not canShip(mid):\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        start = max(weights)\n        end = sum(weights)\n        while start < end:\n            mid = start + (end - start)//2\n            print(mid)\n            counter = 0\n            summation = 0\n            for i in weights:\n                if summation+i==mid:\n                    counter += 1\n                    summation = 0\n                elif summation+i>mid:\n                    counter+= 1\n                    summation = i\n                elif summation<mid:\n                    summation += i\n            counter += 1\n            print(counter)\n            if counter >D: start = mid+1\n            else: end = mid\n        return start", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lo = 0 \n        hi = 0\n        for i in range(len(weights)):\n            lo = max(lo,weights[i])\n            hi = hi + weights[i]\n        \n        optimalcapacity =hi+1\n        while lo<=hi:\n            days =1\n            capacity = 0\n            mid = lo + (hi - lo)//2\n            for i in range(len(weights)):\n                if weights[i] + capacity > mid:\n                    days= days+1\n                    capacity = weights[i]\n                else:\n                    capacity+=weights[i]\n            if days <= D:\n                hi = mid -1\n                optimalcapacity= min(optimalcapacity,mid)\n            else:\n                lo = mid+1\n        return optimalcapacity        \n            \n            \n            \n", "def find(w,m,d,l):\n    s =0\n    c =1\n    for i in range(l):\n        s+=w[i]\n        if s>m:\n            s =w[i]\n            c+=1\n        if c>d:\n            return False\n    return True\n        \n\nclass Solution:\n    def shipWithinDays(self, w: List[int], D: int) -> int:\n        l =len(w)\n        s = max(w)      \n        e = sum(w)\n        m = s+(e-s)//2\n        p =0\n        while s<=e:\n            a = find(w,m,D,l)\n            if a == True:\n                p =m\n                e =m-1\n                m = s+(e-s)//2\n            else:\n                s = m+1\n                m = s+(e-s)//2\n        return p", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        #Lower bound has to be the maximum of the weight to ship all weights\n        #Upper bound is the sum of the weights (can ship all packages in one day)\n        left= max(weights)\n        right =sum(weights)\n        \n        #Finding a weight which is between lower and upper value\n        while left <= right:\n            \n            #days_needed helps to calculate how many days can be covered with the weight chosen\n            #cur tells us the sum of all the weights for the day\n            mid, days_needed, cur = int((left + right) / 2), 1, 0 \n            \n            #mid is the weight which is chosen to divide all the other wirghts in days\n            #loop through each weight\n            for w in weights:\n                if cur + w > mid:\n                    days_needed += 1\n                    cur = 0\n                cur += w\n                \n            if days_needed > D: \n                left = mid + 1\n                \n            else: \n                right = mid-1\n                \n        return left #why is left returned? anything can be returned whether its left or right", "def possible(weights, cap, D):\n    if cap <= 0:\n        return False\n    c = 1\n    cur = 0\n    for w in weights:\n        if cur + w <= cap:\n            cur += w\n        elif w <= cap:\n            c += 1\n            cur = w\n        else:\n            return False\n    print(c, cap)\n    return c <= D\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        hi, lo = sum(weights), max(weights)\n        mid = (hi + lo)//2\n        while lo <= hi:\n            print(lo, hi, mid)\n            p = possible(weights, mid, D)\n            if p and not possible(weights, mid-1, D):\n                return mid\n            elif not p:\n                lo = mid +1\n            else:\n                hi = mid\n            mid = (hi+lo) // 2\n        return -1", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        def possible(c):\n            ship = 1\n            cargo = 0\n            for i in range(len(weights)):\n                if ship > D:\n                    return False\n                if (cargo + weights[i]) > c:\n                    ship += 1\n                    cargo = weights[i]\n                else: \n                    cargo += weights[i]\n            return ship <= D\n        \n        right = sum(weights)\n\n        while left <= right:\n        \n            mid = floor((left + right)/2)\n            if possible(mid):\n                if left == mid:\n                    break\n                right = mid\n            else:\n                left = mid + 1\n        print(left, right, mid)\n        return mid", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def test_ship_weights(capacity):\n            dq = collections.deque(weights)\n            for day in range(D):\n                daily_capacity = capacity\n                while dq and dq[0] <= daily_capacity:\n                    daily_capacity -=  dq.popleft()\n                \n            if dq: return False\n            else: return True\n            \n        l, r = 0, sum(weights)\n        \n        while l<r:\n            m = (l+r) //2 + 1\n            if test_ship_weights(m):\n                r = m-1\n            else:\n                l = m+1\n        if test_ship_weights(l): return l\n        if test_ship_weights(r): return r\n        if test_ship_weights(m): return m\n        else:\n            return r + 1\n        # val = test_ship_weights(l)\n        # if val==False: \n        #     if test_ship_weights(r): \n        #         return r\n        return l\n        \n\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        #Lower bound has to be the maximum of the weight to ship all weights\n        #Upper bound is the sum of the weights (can ship all packages in one day)\n\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = int((left + right) / 2), 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D: left = mid + 1\n            else: right = mid\n        return left", "class Solution:\n    \n    def isPossible(self, ship_weight: int, d:int) -> bool:\n        i = 0\n        ships = 0\n        curr_w = 0\n        while i < len(self.weights):\n            if (ship_weight - curr_w) < self.weights[i]:\n                curr_w = 0\n                ships += 1\n                if ship_weight < self.weights[i] or ships >= d:\n                    return False\n            curr_w += self.weights[i]\n            i += 1\n        return True\n    \n    def shipWithinDays(self, weights: List[int], d: int) -> int:\n        self.weights = weights\n        min_w = math.ceil(sum(weights)/d)\n        max_w = max(weights) * math.ceil(len(weights) / d) + 1 # may be sub-optimal choice\n        \n        while True:\n            mid_w = min_w + (max_w - min_w)//2\n            if self.isPossible(mid_w, d):\n                if not self.isPossible(mid_w-1, d):\n                    return mid_w\n                max_w = mid_w\n            else:\n                min_w = mid_w\n        return 0 # not possible\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        average = sum(weights) // len(weights)\n        min_capacity = max(max(weights), average)\n        \n        min_w = min_capacity\n        max_w = min_w * 2\n        while not enought_capacity(max_w, weights, D):\n            min_w = max_w\n            max_w = max_w * 2\n        \n        while True:              \n            mid = min_w + (max_w - min_w) // 2\n            if enought_capacity(mid, weights, D):\n                if mid == min_w or mid == max_w:\n                    return mid\n                max_w = mid\n            else:\n                min_w = mid + 1\n                \n #       10 11 12 13 14 15\n        \n    \ndef enought_capacity(capacity: int, weights: List[int], D: int):\n    remain_ships = D - 1\n    sum_weight = 0\n    for pck_weight in weights:\n        sum_weight += pck_weight\n        if sum_weight > capacity:\n            remain_ships -= 1\n            sum_weight = pck_weight\n            \n    if remain_ships >= 0:\n        return True\n    return False\n        \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        #eights.sort()\n        left = max(weights)\n        right = sum(weights)\n        \n        def counter(limit):\n            curr = 0\n            count = 0\n            for w in weights:\n                if curr+w==limit:\n                    count+=1\n                    curr =0\n                elif curr+w > limit:\n                    count += 1\n                    curr = w\n                else:\n                    curr += w\n            return count if curr==0 else count+1\n        \n        res = right\n        while left <=right:\n            mid = (left+right)//2\n            \n            val = counter(mid)\n            if val <=D:\n                res = min(res,mid)\n                right=mid-1\n                \n            else:\n                left=mid+1\n                #ight=mid-1\n        return res\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def test_ship_weights(capacity):\n            dq = collections.deque(weights)\n            for day in range(D):\n                daily_capacity = capacity\n                while dq and dq[0] <= daily_capacity:\n                    daily_capacity -=  dq.popleft()\n                \n            if dq: return False\n            else: return True\n            \n        l, r = 0, sum(weights)\n        \n        while l<r:\n            m = (l+r) //2 + 1\n            if test_ship_weights(m):\n                r = m-1\n            else:\n                l = m+1\n        if test_ship_weights(l): return l\n        if test_ship_weights(r): return r\n        if test_ship_weights(m): return m\n        else:\n            return r + 1\n\n        return l\n        \n\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def test_ship_weights(capacity):\n            dq = collections.deque(weights)\n            for day in range(D):\n                daily_capacity = capacity\n                while dq and dq[0] <= daily_capacity:\n                    daily_capacity -=  dq.popleft()\n                \n            if dq: return False\n            else: return True\n            \n        l, r = max(weights), sum(weights)\n        \n        while l<r:\n            m = (l+r) //2 \n            if test_ship_weights(m):\n                r = m\n            else:\n                l = m+1\n\n        return l\n        \n\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lower = min(weights)\n        upper = sum(weights)\n        \n        while lower < upper:\n            mid = (lower + upper) // 2\n            if self.check(weights, D, mid):\n                upper = mid\n            else:\n                lower = mid + 1\n                \n        return lower\n    \n    def check(self, weights, D, cap):\n        s = weights[0]\n        ct = 1\n        if s > cap:\n            return False\n        \n        for x in weights[1:]:\n            if x > cap:\n                return False\n            if s + x <= cap:\n                s += x\n            else:\n                s = x\n                ct += 1\n        return ct <= D", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        def possible(c):\n            ship = 1\n            cargo = 0\n            for i in range(len(weights)):\n                if ship > D:\n                    return False\n                if (cargo + weights[i]) > c:\n                    ship += 1\n                    cargo = weights[i]\n                else: \n                    cargo += weights[i]\n            return ship <= D\n        \n        right = sum(weights)\n\n        while left <= right:\n            mid = floor((left + right)/2)\n            if possible(mid):\n                if left == mid:\n                    break\n                right = mid\n            else:\n                left = mid + 1\n        return mid", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        \n        def isvalid(mid):\n            \n            total=0\n            package=1\n            for weight in weights:\n                if weight>mid:\n                    return False\n                total+=weight\n                if total>mid:\n                    package+=1\n                    total=weight\n            return package<=D\n                \n        \n        def binsearch(low,high):\n            \n            while low<high:\n                mid = low + (high-low)//2\n                print(isvalid(mid),mid)\n                if not isvalid(mid) :\n                    low=mid+1\n                else:\n                    high=mid\n            return low\n        \n        return binsearch(0,sum(weights))", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        \n        def condition(m):\n            days = 0\n            cap = m\n            n = len(weights)\n            i = 0\n            while(i<n):\n                w = weights[i]\n                if(m-w>=0):\n                    m -= w\n                    i +=1\n                else:\n                    days += 1\n                    m = cap -w\n                    i +=1\n                if(days>D):\n                    return False\n            days +=1\n            if(days>D):\n                return False\n            return True\n                    \n        while left<right:\n                mid = left+ (right-left)//2\n                if(condition(mid)):\n                    right = mid\n                else:\n                    left=mid+1\n        return left\n        \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def helper(c):\n            s = 0\n            d = 1\n            for w in weights:\n                s += w\n                if s > c:\n                    d += 1\n                    s = w\n                    if d > D:\n                        return False\n            return True\n        l = max(weights)\n        r = sum(weights)\n        while l < r:\n            m = l + (r-l)//2\n            if helper(m):\n                r = m\n            else:\n                l = m + 1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lo, hi = max(weights), sum(weights)   \n        while lo < hi:\n            mid = (lo + hi) // 2\n            tot, res = 0, 1\n            for wt in weights:\n                if tot + wt > mid:\n                    res += 1\n                    tot = wt\n                    # print(\\\"res\\\", res)\n                    \n                else:\n                    tot += wt\n            if res <= D:\n                hi = mid\n                # print(\\\"hi\\\",hi)\n            else:\n                lo = mid+1\n                # print(\\\"lo\\\",lo)\n        return lo", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        lo = max(weights)\n        hi = sum(weights)\n        \n        def calculate_capacity(n):\n            num_day = 1\n            curr_capacity = 0\n            for weight in weights:\n                if curr_capacity + weight <= n:\n                    curr_capacity += weight\n                else:\n                    num_day += 1\n                    curr_capacity = weight\n            return num_day\n        \n        while lo < hi:\n            mid = lo + (hi - lo) // 2\n            day = calculate_capacity(mid)\n            if day > D:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = left * len(weights)//D\n\n        def checkShipping(cap):\n            # check whether we can ship all packages in D days\n            days = 1\n            onboard = 0\n            for i, v in enumerate(weights):\n                if onboard + v > cap:\n                    days += 1\n                    onboard = v\n                else:\n                    onboard += v\n\n                if days > D:\n                    return False\n            return True\n\n        #ans = right\n        while left < right:\n            mid = left + (right-left) // 2\n            if checkShipping(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        # dp [i][d]\n        # dp [0][d] = w [0]\n        # dp [i][d] = max (w [i], dp [i-1][d-1]) \n        #             min (dp [i-j][d-1] + sum (w [j: i]))\n        # dp [i][d] = max (\n        #                 min (\n        #                   dp [i-j][d-1] + sum (w [i-j+1: i+1]) ,   j >= 1    \n        #                 ))\n        # O (n*n*D)\n        \n        # binary search \n        # O (n log n)\n        \n        n = len (weights)\n        def canShipWithCap (cap):\n            d = 1\n            w = 0\n            for i in range (0, n):\n                if weights [i] + w <= cap:\n                    w += weights [i]\n                else: \n                    w = weights [i]\n                    d += 1\n                    if d > D: return False\n            return True\n        \n        high = sum (weights)\n        low = max (weights)\n        \n        while low < high:\n            \n            mid = low + (high - low) // 2\n            if canShipWithCap (mid): high = mid \n            else: low = mid + 1\n            \n        return low\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        if D == 1:\n            return sum(weights)\n        start = max(max(weights),-(-sum(weights)//D))\n        end = sum(weights)\n        n = len(weights)\n        def validate(x):\n            count = 0\n            i = 0\n            cur = 0\n            while count < D:\n                while i< n and cur <= x:\n                    cur += weights[i]\n                    i += 1\n                if i == n and cur <= x:\n                    return True\n                cur = weights[i-1]\n                count += 1\n            return False\n\n        while start < end:\n            m = (start+end)//2\n            if validate(m):\n                end = m\n            else:\n                start = m+1\n        return start\n            \n            \n", "from collections import defaultdict\nclass Solution:\n     def canShipWithinDays(self, weights: List[int], D: int, maxWeight: int) -> bool:\n        if max(weights) > maxWeight:\n            return False\n        \n        shipmentweights = [0]\n        for w in weights:\n            if shipmentweights[-1] + w <= maxWeight:\n                shipmentweights[-1] += w\n            else:\n                shipmentweights.append(w)\n        return len(shipmentweights) <= D\n    \n     def shipWithinDays(self, weights: List[int], D: int) -> int:\n        maxweight = sum(weights)\n        minweight = max(weights)\n        while maxweight > minweight + 1:\n            mw = (maxweight + minweight) // 2 \n            if self.canShipWithinDays(weights, D, mw):\n                maxweight = mw\n            else:\n                minweight = mw\n        if self.canShipWithinDays(weights, D, minweight):\n            return minweight\n        else:\n            return maxweight", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        \n        def possible_with_capacity(c):\n            days = 1\n            total = 0\n            for weight in weights:\n                total += weight\n                if total > c:\n                    total = weight\n                    days += 1\n                    if days > D:\n                        return False\n            return True\n        \n        while left < right:\n            cap = left + (right-left)//2\n            if possible_with_capacity(cap):\n                right = cap\n            else:\n                left = cap + 1\n        \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        maxVal = weights[0]\n        sum = 0\n        for weight in weights:\n            if maxVal < weight:\n                maxVal = weight\n            sum += weight\n        if D == len(weights):\n            return maxVal\n        if D == 1:\n            return sum\n\n        def validWeight(weight_try: int) -> bool:\n            count = 0\n            local_sum = 0\n            for weight in weights:\n                local_sum += weight\n                if local_sum > weight_try:\n                    local_sum = weight\n                    count += 1\n            return count < D\n\n        left = maxVal\n        right = sum\n        result = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if validWeight(mid):\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return result", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def days_required(t):\n            running_sum = 0\n            days = 0\n            for i in range(n):\n                running_sum += weights[i]\n                if running_sum > t:\n                    days += 1\n                    running_sum = weights[i]\n                    \n            return days\n        \n        \n        n = len(weights)\n        lo, hi = max(weights), sum(weights)\n        while(lo <= hi):\n            capacity = (lo+hi)//2\n            \n            if days_required(capacity) < D:\n                hi = capacity -1\n            else:\n                lo = capacity +1\n                \n                \n        return lo\n            \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def canShip(maxCapacity):\n            days = 0\n            cur = 0\n            for w in weights:\n                if cur + w <= maxCapacity:\n                    cur += w\n                else:\n                    cur = w\n                    days += 1\n            days += 1\n            return days <= D\n        \n        l = max(weights)\n        r = sum(weights)\n        \n        while l < r:\n            mid = (l + r) // 2\n            if canShip(mid):\n                r = mid\n            else:\n                l = mid+1\n        return l", "# +60\n# +30\n# +30\n# did not get this one, found the solution in forums\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        min_cap = max(weights)\n        max_cap = sum(weights)\n        \n        while min_cap < max_cap:\n            cap = (min_cap + max_cap) // 2\n            \n            remainder = cap\n            days = 1\n            \n            for i in range(len(weights)):\n                if weights[i] > remainder:\n                    remainder = cap\n                    days += 1\n                    \n                remainder -= weights[i]\n                \n            if days > D:\n                min_cap = cap + 1\n            else:\n                max_cap = cap\n                \n        \n        return min_cap", "class Solution:\n    def check(self, w, cap, D):\n            c = 0\n            d = 0\n            i = 0\n            while(i<len(w)):\n                c+=w[i]\n                if c>cap:\n                    d += 1\n                    c = w[i]\n                i+=1\n            return d\n        \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l , h= max(weights), sum(weights)\n        while(l<=h):\n            m = (l+h)//2\n            if self.check(weights, m, D)>=D:\n                l = m + 1\n            else:\n                h = m - 1\n        return l \n", "import math\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        sum_ = sum(weights)\n        max_weight = max(weights)\n        if D == 1:\n            return sum_\n        \n        def check_capacity_enough(weights, D, capac):\n            temp_cargo = 0\n            count_ships = 1\n            for i in range(len(weights)):\n                if temp_cargo + weights[i] <= capac:\n                    temp_cargo += weights[i]\n                else:\n                    count_ships += 1\n                    if count_ships > D:\n                        return False\n                    temp_cargo = weights[i]\n            return True\n        \n        def binary_search(weights, D, sum_, max_weight):\n            left = max(math.floor(sum_/D) - 1, max_weight-1) \n            right = max(math.ceil(2*sum_/D)+1, max_weight+3) \n            while right-left >= 2:\n                mid = (left + right)//2\n                if mid >= max_weight and check_capacity_enough(weights, D, mid):\n                    right = mid\n                else:\n                    left = mid\n            return right\n        \n        return binary_search(weights, D, sum_, max_weight)", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def condition(capacity):\n            day = 1\n            increaseCap = 0\n            i=0\n            while i < len(weights):\n                increaseCap +=weights[i]\n                if increaseCap > capacity:\n                    increaseCap = weights[i]\n                    day+=1\n                    if day > D: return False\n                i+=1\n            return True \n        \n        left , right  = max(weights), sum(weights)\n        while left < right:\n            mid =  left + (right - left) //2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def checkDays(capacity): \n            days =  1\n            cc = 0 \n            for num in weights: \n                if cc == capacity: \n                    cc = 0 \n                    days +=1 \n                if num > capacity:\n                    return 999999\n                cc += num \n                if cc > capacity: \n                    days +=1 \n                    cc = num \n            return days \n        hi = max(weights) * len(weights)\n        low = 0 \n        while low < hi: \n            guess = int((low + hi)/2)\n            print(low, hi,guess)\n            d = checkDays(guess)\n            if d > D: \n                low = guess + 1\n            else:\n                hi = guess\n        return low", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def canCarry(cap):\n            cur,d = 0, 1\n            for w in weights:\n                if w > cap: return False\n                cur += w\n                if cur > cap:\n                    cur = w\n                    d += 1\n                if d > D: return False\n            return cur <= cap\n        \n        l, r = max(weights), sum(weights)\n        while l < r:\n            m = (l + r) // 2\n            if canCarry(m): r = m\n            else: l = m + 1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        n = len(weights)\n        left = 1\n        right = sum(weights)\n        \n        def works(capacity):\n            tot_days = 0\n            i = 0\n            \n            while i < n:\n                j = i\n                curr_load = 0\n                \n                while j < n and curr_load + weights[j] <= capacity:\n                    curr_load += weights[j]\n                    j += 1\n                    \n                if j == i:\n                    return False\n                \n                i = j\n                tot_days += 1\n                \n            return tot_days <= D\n            \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if works(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        total = sum(weights)\n        lo,hi = max(max(weights),total//D), total\n        n=len(weights)\n        def valid(x):\n            i = days = 0\n            while i < n:\n                S=0\n                while i<n and S+weights[i]<=x:\n                    S+=weights[i]\n                    i+=1\n                days+=1\n            return days<=D\n        \n        while lo<hi:\n            mid = (lo+hi)//2\n            print(mid)\n            if valid(mid):\n                hi=mid\n            else:\n                lo=mid+1\n        return lo\n                    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        \n        def isvalid(mid):\n            \n            total=0\n            package=1\n            for weight in weights:\n                if weight>mid:\n                    return False\n                total+=weight\n                if total>mid:\n                    package+=1\n                    total=weight\n            return package<=D\n                \n        \n        def binsearch(low,high):\n            \n            while low<high:\n                mid = low + (high-low)//2\n                print(isvalid(mid),mid)\n                if not isvalid(mid) :\n                    low=mid+1\n                else:\n                    high=mid\n            return low\n        \n        return binsearch(max(weights),sum(weights))", "class Solution:\n  def shipWithinDays(self, weights: List[int], D: int) -> int:\n    left, right = max(weights), sum(weights)\n    while left < right:\n      mid, need, cur = left + (right - left) // 2, 1, 0\n      for w in weights:\n        if cur + w > mid:\n          need += 1\n          cur = 0\n        cur += w\n      if need > D: left = mid + 1\n      else : right = mid\n    return left     \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l,r=max(weights),sum(weights)\n        \n        while l<r:\n            mid=(l+r)//2\n            cnt=1\n            cursum=0\n            for weight in weights:\n                if cursum+weight<=mid:\n                    cursum+=weight\n                else:\n                    cnt+=1\n                    cursum=weight\n            \n            if cnt<=D:\n                r=mid\n            else:\n                l=mid+1\n            \n        return r\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        if not weights:\n            return 0\n        \n        NUM_PACKAGES = len(weights)\n        if NUM_PACKAGES == 1:\n            return weights[0]\n        elif NUM_PACKAGES == 2:\n            return max(weights[0], weights[1])\n        \n        max_capacity, min_capacity = 0, 0\n        for weight in weights:\n            max_capacity += weight\n            min_capacity = weight if weight > min_capacity else min_capacity\n        \n        def possible(capacity):\n            curr_weight = 0\n            curr_days = 0\n            package_index = 0\n            \n            while package_index < NUM_PACKAGES:\n                \n                if curr_weight + weights[package_index] > capacity:\n                    curr_days += 1\n                    \n                    # print(capacity, curr_weight, weights[package_index], curr_days)\n                    \n                    # Too many days with this capacity\n                    if curr_days > D:\n                        return False\n                    \n                    curr_weight = 0\n                    \n                curr_weight += weights[package_index]\n                package_index += 1\n            \n            curr_days += 1\n            if curr_days > D:\n                return False\n            \n            return True\n        \n        least_capacity = 0\n        while min_capacity <= max_capacity:\n            mid_point = (min_capacity + max_capacity) // 2\n            if possible(mid_point):\n                least_capacity = mid_point\n                max_capacity = mid_point - 1\n            else:\n                min_capacity = mid_point + 1\n            \n            # print(\\\"Main:\\\", mid_point, min_capacity, max_capacity, least_capacity)\n        \n        return least_capacity\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n        def package(weights, limit):    \n            kk = 0\n            count = 1\n            for i in range(len(weights)):\n                kk = kk + weights[i]\n\n                if kk > limit:    \n                    kk = weights[i]\n                    count = count + 1\n\n            return count\n                \n        lindex = max(weights)\n        rindex = lindex * len(weights) // D\n\n        while (lindex < rindex):\n\n            mid = lindex + (rindex - lindex)//2\n\n            capacity = mid\n            Dstar = package(weights, capacity)\n\n            if Dstar > D:\n                lindex = mid + 1\n            else:\n                rindex = mid \n\n            \n        return lindex", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lo, hi = 0, 9999999\n        ans = -1\n        N = len(weights)\n        \n        for w in weights:\n            lo = max(lo , w)\n        \n        def poss(val):\n            n, cnt , sum = 0, 1, 0\n            \n            while n < N:\n                if sum + weights[n] <= val:\n                    sum += weights[n]\n                else:\n                    cnt += 1\n                    sum = weights[n]\n                n += 1\n                \n            return cnt\n        \n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            nn = poss(mid)\n            if nn <= D:\n                ans = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        return ans\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = max(weights)\n        r = 10**9\n        \n        while l < r:\n            m = l + (r - l) // 2\n            # now check if we use this m as the weight capacity for ship how many days we need\n            days = 1\n            s = 0\n            for i in range(len(weights)):\n                if s + weights[i] > m:\n                    days += 1\n                    s = weights[i]\n                else:\n                    s += weights[i]\n                    \n            if days <= D:\n                r = m\n            else:\n                l = m + 1\n        \n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def countDays(weights, capacity):\n            l, r, cnt, sumv = 0, 0, 0, 0\n            while r < len(weights):\n                sumv += weights[r]\n                if sumv > capacity:\n                    cnt += 1\n                    l = r\n                    sumv = 0\n                else:\n                    r += 1\n            if sumv:\n                cnt += 1\n            return cnt\n        maxv, sumv = max(weights), sum(weights)\n        left, right = maxv, sumv\n        while left < right:\n            mid = (left + right) // 2\n            days = countDays(weights, mid)\n            if days > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = (left+right)//2\n            if self.can_achieve(weights, mid, D):\n                right = mid \n            else:\n                left = mid+1 \n                \n        return left \n    \n    def can_achieve(self, weights, max_weight, D):\n        i = 0 \n        total = 0\n        days = 0\n        while i < len(weights):\n            if total + weights[i] > max_weight:\n                total = 0\n                days += 1\n            total += weights[i]\n            i += 1 \n            \n        days += 1 \n        return days <= D\n            \n                \n            \n            \n                \n", "class Solution:\n    def trips(self,l,c):\n        currSum = 0\n        t,i=0,0\n        n = len(l)\n        while(i<n):\n            if(currSum+l[i]>c):\n                currSum=0\n                t =t+1\n            else:\n                currSum=currSum+l[i]\n                i=i+1\n        return t+1\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        low = max(weights)\n        high = sum(weights)\n        while(low<high):\n            mid = int(low+(high-low)/2)\n            if(self.trips(weights,mid)<=D):\n                high = mid\n            else:\n                low = mid+1\n        return low\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        # Binary search\n        if not weights:\n            return 0\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.checkValidPartition(weights, mid, D):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def checkValidPartition(self, weights, capacity, D):\n        count = 1\n        cur_sum = 0\n        for w in weights:\n            if cur_sum + w > capacity:\n                count += 1\n                cur_sum = 0\n            cur_sum += w\n        return count <= D", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) / 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D: left = mid + 1\n            else: right = mid\n        return int(left)\n            \n", "class Solution:\n    def shipWithinDays(self, weights, D: int) -> int:\n        if not weights or not D:\n            return 0\n\n        lo, hi = max(weights), sum(weights)\n        ans = 0\n        while lo <= hi:\n            mid = lo + (hi - lo) // 2\n            res = self.validate(weights, D, mid)\n            if res == 1:\n                ans = mid\n                hi = mid-1\n            else:\n                lo = mid+1\n        return ans\n\n    def validate(self, weights, D, capacity):\n        count = 0\n        w = 0\n        D -= 1\n        while w < len(weights):\n            if count + weights[w] <= capacity:\n                count += weights[w]\n            else:\n                count = weights[w]\n                D -= 1\n                if D < 0:\n                    break\n            w += 1\n        if w == len(weights):\n            return 1\n        else:\n            return -1\n\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        hlim = sum(weights)\n        llim = max(weights)\n        def isValid(cap, days):\n            temp = 0\n            x = 0\n            while x < len(weights):\n                temp += weights[x]\n                if temp > cap:\n                    x -= 1\n                    temp = 0\n                    days -= 1\n                x += 1\n            return days >= 1\n        ans = -1\n        while llim <= hlim:\n            mid = (llim+hlim)//2\n            if isValid(mid, D):\n                ans = mid\n                hlim = mid-1\n            else:\n                llim = mid+1\n        return ans", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l,r=max(weights),sum(weights)\n        while(l<r):\n            m,n,c=(l+r)/2,1,0\n            for z in weights:\n                if c+z>m:\n                    n+=1\n                    c=0\n                c+=z\n            if n>D:\n                l=m+1\n            else:\n                r=m\n        return int(l)\n        '''left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) / 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D: left = mid + 1\n            else: right = mid\n        return left'''", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n        def package(weights, limit):    \n            kk = 0\n            count = 1\n            for i in range(len(weights)):\n                kk = kk + weights[i]\n\n                if kk > limit:    \n                    kk = weights[i]\n                    count = count + 1\n\n            return count\n                \n        lindex = max(weights)\n        rindex = lindex * len(weights) // D\n\n        while (lindex < rindex):\n\n            mid = lindex + (rindex - lindex)//2\n            \n            Dstar = package(weights, mid)\n\n            if Dstar > D:\n                lindex = mid + 1\n            else:\n                rindex = mid \n            \n        return lindex", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        left = max(weights)\n        right = sum(weights) + 1\n        \n        \n        while left < right:\n            mid = left + (right-left)//2\n            legal = self.evaluate(weights, D, mid)\n            \n            if legal:\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left\n            \n            \n    def evaluate(self, weights, D, weight_capacity):\n        cursum = 0\n        days = 0\n        for val in weights:\n            if val > weight_capacity:\n                return False\n            if val + cursum > weight_capacity:\n                days += 1\n                cursum = val\n            else:\n                cursum += val\n                \n        if cursum != 0:\n            days += 1\n        \n        if days > D:\n            return False\n        return True", "class Solution:\n    def canShipAllPackages(self, weight_capacity, D, weights):\n        # print(f\\\"weight_capacity: {weight_capacity}\\\")\n\n        days_needed = 1\n        current_day_weight = 0\n        i = 0\n        while i < len(weights):\n            weight = weights[i]\n            # print(f\\\"weight: {weight}\\\")\n            if (current_day_weight + weight) <= weight_capacity:\n                current_day_weight += weight\n                # print(f\\\"Day {days_needed}, current_day_weight: {current_day_weight}\\\")\n                i += 1\n            else:\n                # print(f\\\"Too much! Next day work\\\")\n                current_day_weight = 0\n                days_needed += 1\n                \n        # print(\\\"f{days_needed}\\\")\n        return days_needed <= D\n        \n        \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        if len(weights) == 0:\n            return 0\n\n        left = max(weights)\n        right = sum(weights)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if self.canShipAllPackages(mid, D, weights):\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        n = len(weights)\n        \n        def count(c: int) -> int: \n            ans = 1\n            curr = weights[0]\n            for i in range(1, n): \n                if curr + weights[i] > c: \n                    ans += 1\n                    curr = weights[i]\n                else: \n                    curr += weights[i]\n            return ans\n        \n        l = max(weights)\n        r = sum(weights)\n        while l < r: \n            m = (l + r) // 2\n            if count(m) > D: \n                l = m + 1\n            else: \n                r = m\n        return l\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        minCapacity, maxCapacity = max(weights), sum(weights)\n        \n        while minCapacity < maxCapacity:\n            capacityCandidate = (minCapacity + maxCapacity) // 2\n            daysToShip, currentCargo = 1, 0\n            \n            for newCargo in weights:\n                if currentCargo + newCargo > capacityCandidate:\n                    currentCargo = 0\n                    daysToShip += 1\n                currentCargo += newCargo\n            \n            if daysToShip <= D:\n                maxCapacity = capacityCandidate\n            else:\n                minCapacity = capacityCandidate + 1\n        \n        return minCapacity", "class Solution:\n    def get_day(self, weights, cap):\n        i = 0\n        res = 0\n        wei = 0\n        while i < len(weights): \n            if wei + weights[i] <= cap:\n                    wei += weights[i]\n                    i += 1\n            else:\n                wei = 0\n                res += 1\n        return res + 1\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        \n        start, end = max(weights), sum(weights)\n        \n        while start < end:\n            mid = (start + end) // 2\n            \n            days=self.get_day(weights,mid)\n            if days <= D:\n                end = mid\n            else:\n                start = mid + 1\n             \n              \n        return end \n        \n        \n            \n        \n", "#\n# @lc app=leetcode id=1011 lang=python3\n#\n# [1011] Capacity To Ship Packages Within D Days\n#\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def timeConsumption(limit):\n            days = totalWeight = 0\n            for weight in weights:\n                if totalWeight + weight > limit:\n                    days += 1\n                    totalWeight = weight\n                else:\n                    totalWeight += weight\n            return days + 1\n        left = max(weights)        \n        right = sum(weights) + 1\n        while left < right:\n            mid = left + (right - left) // 2\n            time = timeConsumption(mid)\n            if time > D: left = mid + 1\n            else: right = mid\n        return left\n\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) / 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D: left = mid + 1\n            else: right = mid\n        return int(left)\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def condition(w) -> bool:\n            curr,k = 0,0\n            count = 0\n            while k < len(weights):\n                if curr + weights[k] > w:\n                    count += 1\n                    if count > D:\n                        return False\n                    curr = 0\n                curr += weights[k]\n                k += 1\n            \n            return count + 1 <= D\n        \n        left,right = max(weights),sum(weights)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left<right:\n            mid = left+(right-left)//2\n            need=1\n            cur=0\n            for w in weights:\n                if cur+w>mid:\n                    need+=1\n                    cur=0\n                cur+=w\n            if need>D:\n                left=mid+1\n            else:\n                right=mid\n        return left\n    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = int(sum(weights) / D)\n        right = max(weights) * len(weights) / D\n        \n        def is_valid(weights, D, capacity):\n            cur = capacity\n            day = 0\n            for w in weights:\n                if cur + w <= capacity:\n                    cur += w\n                else:\n                    cur = 0\n                    if capacity < w:\n                        return False\n                    else:\n                        cur = w\n                        day += 1\n            if day <= D:\n                return True\n            return False\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if is_valid(weights, D, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return int(left)\n            \n                    \n", "class Solution:\n    def canShip(self, w, d, cap):\n        i = 0\n        res = 0\n        while i < len(w):\n            if w[i] > cap:\n                return False\n            remain = cap\n            while i < len(w) and remain >= w[i]:\n                remain -= w[i]\n                i += 1\n            res += 1\n        return res <= d\n                \n                \n                \n                \n    \n    def shipWithinDays(self, w: List[int], D: int) -> int:\n        if len(w) == 0:\n            return 0\n        start = max(w)\n        end = sum(w)\n        while start < end:\n            mid = int((end - start) / 2) + start\n            if self.canShip(w, D, mid):\n                end = mid\n            else:\n                start = mid + 1\n        \n        return start\n        \n        \n        \n        \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def check_possible(capacity):\n            count = 0\n            i = 0\n            while i < len(weights):\n                count += 1\n                if count > D or weights[i] > capacity:\n                    return False\n                curr_ship = 0\n                while i < len(weights) and weights[i] + curr_ship <= capacity:\n                    curr_ship += weights[i]\n                    i += 1\n            return True\n        \n        tot = 0\n        largest = 0\n        for w in weights:\n            tot += w\n            largest = max(largest, w)\n            \n        l = largest\n        r = tot\n        if check_possible(l):\n            return l\n        \n        while l < r - 1:\n            mid = (l + r) // 2\n            if check_possible(mid):\n                r = mid\n            else:\n                l = mid\n                \n        return r", "class Solution:\n    def get_day(self, weights, cap):\n        i = 0\n        res = 0\n        wei = 0\n        while i < len(weights): \n            if wei + weights[i] <= cap:\n                    wei += weights[i]\n                    i += 1\n            else:\n                wei = 0\n                res += 1\n        return res + 1\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        \n        \n                \n        \n        \n        start, end = max(weights), sum(weights)\n        \n        while start < end:\n            mid = (start + end) // 2\n            \n            days=self.get_day(weights,mid)\n            if days <= D:\n                end = mid\n            else:\n                start = mid + 1\n             \n              \n        return end \n        \n        \n            \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def no_of_days(weights,W,D):\n            count=1\n            su=0\n            i=0\n            while i<len(weights):\n                if su+weights[i]<=W:\n                    su+=weights[i]\n                    i+=1\n                else:\n                    su=weights[i]\n                    i+=1\n                    count+=1\n            # print(count)\n            return count\n        \n        \n        def binary(weight,i,j,D):\n            ans=0\n            while i<=j:\n                mid=int((i+j)/2)\n                d=no_of_days(weight,mid,D)\n                # print(\\\"d=\\\", d, i, \\\" \\\", j, \\\" \\\", mid)\n                if d<=D:\n                    ans=mid\n                    j=mid-1\n                else:\n                    i=mid+1\n                    \n            return ans\n        \n        wi=max(weights)\n        wj=wi*len(weights)\n        a=binary(weights,wi,wj,D)\n        \n        return a\n                \n                \n                \n            \n            \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n        while l <= r:\n            m = l + (r-l)//2\n            if self.loadBalancer(weights, m) > D:\n                l = m + 1\n            elif self.loadBalancer(weights, m) <= D:\n                r = m - 1\n        return l\n            \n    def loadBalancer(self, weights, target):\n        c, sum_ = 1, 0\n        for i in weights:\n            if sum_+i > target:\n                c += 1\n                sum_ = 0\n            sum_ += i\n        return c", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lo = max(weights)\n        hi = sum(weights)\n        res = hi\n        \n        while lo <= hi:\n            mid = lo + (hi-lo)//2\n            \n            # try packing \n            days = 0\n            curr_weight = 0\n            for i in range(len(weights)):\n                if curr_weight + weights[i] > mid:\n                    days += 1\n                    curr_weight = weights[i]\n                else:\n                    curr_weight += weights[i]\n            \n            days += 1\n            \n            if days <= D:\n                res = mid\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        \n        return res", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def possible(cap):\n            d = D\n            i = 0\n            while i < len(weights) and weights[i] <= cap:\n                cur = 0\n                while i < len(weights) and cur + weights[i] <= cap:\n                    cur += weights[i]\n                    i += 1\n                d -= 1\n            \n            if i < len(weights):\n                return False\n            return d >= 0\n            \n        total = sum(weights)\n        \n        l, r = 1, total\n        ans = float('inf')\n        \n        while l <= r:\n            m = l + (r-l)//2\n            \n            if possible(m):\n                r = m - 1\n                ans = min(ans, m)\n            else:\n                l = m + 1\n        return ans", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def can(K):\n            i = 0\n            days = 0\n            while i < len(weights) and days <= D + 1:\n                k = K\n                days += 1\n                while i < len(weights) and k >= weights[i]:\n                    k -= weights[i]\n                    i += 1\n            return days <= D\n        \n        l, r = 1, sum(weights)\n        while l < r:\n            mid = (l + r) // 2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n                    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def can(K):\n            i = 0\n            days = 0\n            while i < len(weights) and days <= D + 1:\n                k = K\n                days += 1\n                while i < len(weights) and k >= weights[i]:\n                    k -= weights[i]\n                    i += 1\n            return days <= D\n        \n        l, r = max(weights), sum(weights)\n        while l < r:\n            mid = (l + r) // 2\n            if can(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l\n                    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def possible(cap):\n            s = 0\n            ship = 0\n            i = 0\n            while i<len(weights):\n                s = s+weights[i]\n                if s>cap:\n                    ship=ship+1\n                    s=0\n                elif s<cap:\n                    i = i+1\n                else:\n                    ship=ship+1\n                    s=0\n                    i=i+1\n            if s==0:\n                return ship<=D\n            else:\n                 return (ship+1)<=D\n        lo = max(weights)\n        hi = sum(weights)\n        while lo<=hi:\n            mid= lo+(hi-lo)//2\n            if possible(mid):\n                hi = mid-1\n            else:\n                lo = mid+1\n        return lo", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = left * len(weights)//D\n\n        def checkShipping(cap):\n            # check whether we can ship all packages in D days\n            days = 1\n            onboard = 0\n            for i, v in enumerate(weights):\n                if onboard + v > cap:\n                    days += 1\n                    onboard = v\n                else:\n                    onboard += v\n\n                if days > D:\n                    return False\n            return True\n\n        ans = right\n        while left <= right:\n            mid = (right+left) // 2\n            if checkShipping(mid):\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        return ans", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        SUM = sum(weights)\n        MAX = max(weights)\n        h = SUM\n        l = max(MAX, SUM // D) - 1\n        \n        def canDo(arr, D, num):\n            j = 0\n            for i in range(D):\n                # can ship a pool\n                total = 0\n                while j < len(arr) and total + arr[j] <= num:\n                    total += arr[j]\n                    j += 1\n                if j == len(arr):\n                    return True\n                elif total == 0:\n                    return False\n            return j == len(arr)\n        \n        while h > l + 1:\n            m = (l + h) // 2\n            if canDo(weights, D, m):\n                h = m\n            else:\n                l = m\n        return l + 1", "class Solution:\n    def shipWithinDays(self, weights, D):\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) / 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D: left = mid + 1\n            else: right = mid\n        return int(left)", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = 1\n        right = max(weights) * len(weights)\n        while left < right:\n            mid = (left + right) // 2\n            # print(left, mid, right)\n            if self.possible(weights, D, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def possible(self, weights, D, mid):\n        cnt = 0\n        tmp = 0\n        for w in weights:\n            if w > mid:\n                return False\n            if tmp + w > mid:\n                tmp = w\n                cnt += 1\n            else:\n                tmp += w\n        if tmp != 0:\n            cnt += 1\n        return cnt <= D\n            \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def ship_capacity(weights, D, capacity):\n            days = 0\n            sum_weights = 0\n            for i in range(len(weights) - 1):\n                sum_weights += weights[i]\n                if sum_weights + weights[i + 1] > capacity:\n                    days += 1\n                    sum_weights = 0\n            return days <= D - 1\n        start = max(weights)\n        end = sum(weights)\n        while start <= end:\n            mid = (start + end) // 2\n            if ship_capacity(weights, D, mid):\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def checkIfCanShipWithinDDays(weights: List[int], D: int, capacity: int) -> bool:\n            b, count, total = 0, 0, 0\n            while b < len(weights):\n                while total + weights[b] <= capacity:\n                    total += weights[b]\n                    b += 1\n                    if b == len(weights):\n                        count += 1\n                        # double loop, should directly return\n                        return count <= D\n                count += 1\n                total = 0\n            return count <= D\n        \n        total = sum(weights)\n        # attention: lb also bound by max element, or it can't fit in\n        # so why not set lb directly to be the maximum element!\n        lb = max(weights)\n        ub = total\n        while lb < ub:\n            mid = lb + (ub - lb) // 2\n            if checkIfCanShipWithinDDays(weights, D, mid):\n                ub = mid\n            else:\n                lb = mid + 1\n        return lb", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left + 1 < right:\n            mid = left + (right-left)//2\n            print(mid)\n            curr = 0\n            res = 1\n            for w in weights:\n                if curr + w > mid:\n                    res += 1\n                    curr = w\n                else:\n                    curr += w\n            if res > D: #!!here use >, since mid is impossible to meet the requireent\n                left = mid\n            else: #!!here means <=, since there might be smaller mid \n                right = mid\n\n        res = 1\n        curr = 0\n        for w in weights:\n            if curr + w > left:\n                res += 1\n                curr = w\n            else:\n                curr += w\n        if res <= D:\n            return left\n        return right", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        self.weight=weights\n        self.D=D\n        hi=sum(weights)\n        lo=1        \n        \n        while hi!=lo: \n            mid=(hi+lo)//2\n            if self.if_fit(mid):\n                hi=mid\n            else:\n                lo=mid+1\n                \n        return hi\n            \n    def if_fit(self,cap):\n        d=1\n        count=0\n        for val in self.weight: \n            if val>cap: \n                return False\n            if val+count<=cap: \n                count+=val\n            else: \n                count=val\n                d+=1\n                if d>self.D:\n                    return False\n        return True\n                \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def canFinish(self, weights, D, C):\n        index = 0\n        for _ in range(D):\n            total = 0\n            while index < len(weights) and total + weights[index] <= C:\n                total += weights[index]\n                index += 1\n            if index == len(weights):\n                return True\n        return False\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = 0 \n        r = sum(weights)\n        while l < r - 1:\n            m = l + (r-l)//2\n            if self.canFinish(weights, D, m):\n                r = m\n            else:\n                l = m + 1\n        \n        if self.canFinish(weights, D, l):\n            return l\n        return r", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        total = sum(weights)\n        # attention: lb also bound by max element, or it can't fit in\n        #if total % D == 0:\n        #    lb = total // D\n        #else:\n        #    lb = total // D + 1\n        #lb = max(max(weights), lb)\n        lb = max(weights)\n        ub = total\n        while lb < ub:\n            mid = lb + (ub - lb) // 2\n            if self.checkIfCanShipWithinDDays(weights, D, mid):\n                ub = mid\n            else:\n                lb = mid + 1\n        return lb\n        \n    def checkIfCanShipWithinDDays(self, weights: List[int], D: int, capacity: int) -> bool:\n        b, count, total = 0, 0, 0\n        while b < len(weights):\n            while total + weights[b] <= capacity:\n                total += weights[b]\n                b += 1\n                if b == len(weights):\n                    count += 1\n                    # double loop, should directly return\n                    return count <= D\n            count += 1\n            total = 0\n        return count <= D", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), max(weights)*len(weights)//D\n        def checkShipping(capacity):\n            days = 1\n            total_weight = 0\n            for weight in weights:\n                if weight > capacity or days > D:\n                    return False\n                if weight + total_weight > capacity:\n                    total_weight = weight\n                    days +=1\n                else:\n                    total_weight += weight\n            return days <= D  \n        \n        while left <= right:\n            mid = left + (right-left) //2\n            if checkShipping(mid):\n                right = mid -1\n            else:\n                left = mid +1\n        return left", "class Solution:\n    \n    def can_ship(self, weights, D, max_weight):\n\n        #print(weights, D)\n        \n        i = 0\n        s = 0\n\n        '''\n        if len(weights)<D and max(weights)<=max_weight:\n            return True\n            \n        if D==0 and len(weights)>0:\n            return False\n\n        if D==1 and sum(weights)<max_weight:\n            return True\n\n        while i<=len(weights)-1 and s<=max_weight:\n            s+=weights[i]\n            i+=1\n\n        return self.can_ship(weights[i-1:], D-1, max_weight)\n        '''\n\n        while i<len(weights) and D>0:\n\n            s = 0\n            \n            while i<len(weights) and s<=max_weight:\n                s+=weights[i]\n                \n                if s>max_weight:\n                    break\n\n                i+=1\n\n            D-=1\n\n            #print(\\\"test \\\", i, D, weights)\n\n        if D==0 and i<len(weights):\n            return False\n\n        return True\n\n    def shipWithinDays(self, weights, D):\n\n        left = min(weights)\n        right = sum(weights)\n\n        while left<right:\n\n            mid = int((left+right)/2)\n        \n            if self.can_ship(weights, D, mid):\n                right = mid\n            else:\n                left = mid\n\n            #print(\\\"mid = \\\", mid, left, right)\n            \n            if right==left+1:\n                if self.can_ship(weights, D, left):\n                    return left\n                else:\n                    return right\n\n\n        return mid\n", "class Solution:\n    def canShip(self, weights, capacity, D) -> bool:\n        cnt, i = 0, 0\n        cum = 0\n        while i < len(weights):\n            if cum + weights[i] <= capacity:\n                cum += weights[i]\n                i += 1\n            else:\n                cnt += 1\n                cum = 0\n        cnt += 1\n        return cnt <= D\n        \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n        while l < r:\n            mid = (l + r) // 2\n            if self.canShip(weights, mid, D):\n                r = mid\n            else:\n                l = mid + 1\n        return r", "def check(arr, mid, D):\n    count = 1\n    n = len(arr)\n    cur_sum = 0\n    for i in range(n):\n        if cur_sum + arr[i] > mid:\n            count += 1\n            cur_sum = 0\n        cur_sum += arr[i]\n        if count > D:\n            return False\n    \n    return count <= D\n\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        max_weight = sum(weights)\n        min_weight = max(weights)\n        ans = float('inf')\n        \n        while min_weight <= max_weight:\n            mid = int((max_weight + min_weight)/2)\n            if check(weights, mid, D) == True:\n                ans = min(ans, mid)\n                max_weight = mid - 1\n            else:\n                min_weight = mid + 1\n        \n        return ans\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def test(capacity):\n            count = 0\n            current_sum = 0\n            i = 0\n            \n            while i < len(weights) and count < D:\n                while i < len(weights) and current_sum + weights[i] <= capacity:\n                    current_sum += weights[i]\n                    i += 1\n                \n                count += 1\n                current_sum = 0\n            \n            return count <= D and i == len(weights)\n        \n        \n        l, r = 1, sum(weights)\n        \n        while l < r:\n            mid = (l + r) // 2\n            \n            if test(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n        while l < r:\n            mid = (l+r)//2\n            d = self.check(weights, mid)\n            if d > D:\n                l, r = mid+1, r\n            else:\n                l, r = l, mid\n        return l\n            \n            \n    def check(self, weights, size):\n        c = 0\n        i = 0\n        days = 0\n        while True:\n            if i == len(weights):\n                break\n\n            while i < len(weights) and c + weights[i] <= size:\n                c += weights[i]\n                i += 1\n            c = 0\n            days += 1\n        return days", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        maxCap = sum(weights) # 8\n        minCap = max(weights) # 3\n        ans = maxCap\n\n        # binary search\n        lo = minCap\n        hi = maxCap\n\n        while lo <= hi:\n            mi = lo + (hi - lo) // 2 # mid = left + (right - left) // 2\n            # test if cap works\n            daysLeft = D\n            dailyCap = mi\n            i = 0\n            while i < len(weights) and daysLeft:\n                wei = weights[i]\n                if wei > dailyCap:\n                    daysLeft -= 1\n                    dailyCap = mi\n                elif wei == dailyCap:\n                    daysLeft -= 1\n                    dailyCap = mi\n                    i += 1\n                else:\n                    dailyCap -= wei\n                    i += 1\n            if i == len(weights):\n                ans = min(ans, mi)\n                hi = mi - 1\n            else:\n                lo = mi + 1\n        return ans\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def condition(k):\n            ind, load, days = 0, 0, 0\n            while ind < len(weights):\n                #print(ind, load, days)\n                if weights[ind] + load <= k:\n                    load += weights[ind]\n                    ind += 1\n                else:\n                    load = 0\n                    days += 1\n            return days + 1 <= D\n        \n        #print(condition(15))\n        \n        \n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if condition(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n    \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        maxCap = sum(weights)\n        minCap = max(weights)\n        ans = maxCap\n        lo = minCap\n        hi = maxCap\n        while lo <= hi:\n            mi = lo + (hi - lo) // 2\n            daysLeft = D\n            dailyCap = mi\n            i = 0\n            while i < len(weights) and daysLeft:\n                wei = weights[i]\n                if wei > dailyCap:\n                    daysLeft -= 1\n                    dailyCap = mi\n                elif wei == dailyCap:\n                    daysLeft -= 1\n                    dailyCap = mi\n                    i += 1\n                else:\n                    dailyCap -= wei\n                    i += 1\n            if i == len(weights):\n                ans = min(ans, mi)\n                hi = mi - 1\n            else:\n                lo = mi + 1\n        return ans\n", "class Solution:\n    def shipWithinDays(self, arr: List[int], D: int) -> int:\n        def count(arr, x):\n            res = i = 0\n            while i < len(arr):\n                z = 0\n                while i < len(arr) and z + arr[i] <= x:\n                    z += arr[i]\n                    i += 1\n                res += 1\n            return res\n        \n        end = start = 0\n        for i in arr:\n            end += i\n            start = max(start, i)\n        while start <= end:\n            mid = start + (end - start)//2\n            if count(arr, mid) > D:\n                start = mid + 1\n            else:\n                out = mid\n                end = mid - 1\n        return out", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        s = max(weights)\n        e = max(weights) * len(weights) // D\n        \n        def dayCount(weights, cap, D):\n            day = 1\n            total = 0\n            for i in range(len(weights)):\n                if total + weights[i] <= cap:\n                    total += weights[i]\n                else:\n                    day += 1\n                    total = weights[i]\n            return day <= D\n            \n        while s <= e:\n            mid = (s+e) // 2\n            if dayCount(weights, mid, D):\n                e = mid - 1\n            else:\n                s = mid + 1\n        return s", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        # do a binary search\n        # return has to do with weights\n        # so initialize right = sum(weights)\n        # a ship that can carry everything\n        \n        left = max(weights)\n        right = 999999999999999999 # this ship over-carries for sure\n        \n        while left < right:\n            # keep track of days\n            # if we ship all packages and days too little, it means\n            # we can afford to decrease our ship-capacity\n            # which means right=mid\n            \n            # else if days too much,\n            # we must increase our ship-capacity\n            # so left = mid\n            \n            # mid is our current ship capacity\n            \n\n            mid = (left+right) // 2\n            \n            days_needed = 1\n            cargo = 0\n            \n            for w in weights:\n                if cargo + w > mid:\n                    # cannot fit this next package to current cargo\n                    days_needed += 1\n                    cargo = w\n                else:\n                    # can fit\n                    cargo += w\n\n            \n            if days_needed > D:\n                # this means it must be greater than mid, for sure\n                left = mid + 1\n            else:\n                right = mid\n                \n            \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = 0\n        r = sum(weights)\n        best = r\n        while l <= r:\n            mid = l + (r - l) // 2\n            if self.works(mid, weights, D):\n                best = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n                \n        return best\n    \n    def works(self, cap, weights, d):\n        if cap < max(weights):\n            return False\n        idx = 0\n        total_days = 0\n        while idx < len(weights):\n            cur_cap = 0\n            while cur_cap < cap and idx < len(weights):\n                if cur_cap + weights[idx] > cap:\n                    break\n                cur_cap += weights[idx]\n                idx += 1\n            \n            total_days += 1\n        \n        return total_days <= d\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        cap_min = max(weights)\n        cap_max = sum(weights)\n\n        # binary search the minimum cap\n\n        while cap_min < cap_max:\n            cap_mid = (cap_min + cap_max) // 2\n\n            days = self._cal_num_of_days(weights, cap_mid)\n\n            if days > D:\n                cap_min = cap_mid + 1\n            elif days < D:\n                cap_max = cap_mid\n            elif days == D:\n                cap_max = cap_mid\n\n        return cap_min\n\n    def _cal_num_of_days(self, weights: List[int], cap: int) -> int:\n        days = 0\n        i = 0\n\n        while i < len(weights):\n            current_load = 0\n            while i < len(weights) and current_load + weights[i] <= cap:\n                current_load += weights[i]\n                i += 1\n            days += 1\n        return days\n", "class Solution:\n    def check (self,weights: List[int], D: int, cap: int) -> bool:\n        \n        load = 1\n        total = 0\n        for i in range (len(weights)):\n            total += weights[i]\n            \n            if (i!= len(weights)-1):\n                if ((total + weights[i+1])>cap):\n                    total= 0 \n                    load+=1\n                    if (load>D):\n                        return False \n                \n        if (load <= D):\n            return True\n        \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        lo = max(weights) \n        hi = sum(weights)\n        \n        while (lo< hi):\n            mid= lo + ((hi-lo)//2)\n            \n            if (self.check(weights,D,mid)):\n                hi = mid \n            \n            else: \n                lo = mid +1 \n                \n        return lo \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        '''\n        weights = [1,2,3,4,5,6,7,8,9,10], D = 5\n        \n        left = 10\n        right = 15\n        mid = 15\n        '''\n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            count = 1\n            bucket = 0\n            for w in weights:\n                if bucket + w <= mid:\n                    bucket += w\n                else:\n                    bucket = w\n                    count += 1\n            if count <= D:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def test(x): \n            times, i = 0, 0\n            while i < len(weights):\n                times += 1\n                cur = 0\n                #print('   ', weights[i:])\n                while i < len(weights) and cur+weights[i] <= x: \n                    cur += weights[i]\n                    i += 1\n            \n            return times\n        \n        l, r = max(weights), sum(weights)\n        while l <= r:\n            mid = (l+r)//2\n            #print(mid, l, r)\n            days = test(mid)\n            if days <= D: r = mid - 1\n            else: l = mid + 1\n            #print('   it takes', days, 'days to ship with limit', mid)\n        \n        if days > D: mid += 1\n        return mid\n        \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def days_taken(capacity, arr):\n            days = 0\n            i = 0\n            while i < len(arr):\n                j = i\n                bucket = capacity\n                days += 1\n                while j < len(arr) and arr[j] <= bucket and bucket > 0:\n                    bucket -= arr[j]\n                    j += 1\n                i = j\n            return days\n        \n        low = max(weights)\n        high = sum(weights)\n        \n        \n        \n        while low < high:\n            mid = (low + high) // 2\n            days_by_mid = days_taken(mid, weights)\n            \n            if days_by_mid <= D:\n                high = mid\n            else:\n                low = mid + 1\n        \n        return low\n        \n        \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        start, end = max(weights), sum(weights) + 1\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if self._can_ship(weights, mid, D):\n                end = mid\n            else:\n                start = mid\n        return start if self._can_ship(weights, start, D) else end\n    \n    def _can_ship(self, weights, capacity, D):\n        days_needed = 0\n        i = 0\n        while i < len(weights):\n            curr_w = 0\n            while i < len(weights) and curr_w + weights[i] <= capacity:\n                curr_w += weights[i]\n                i += 1\n            days_needed += 1\n        return days_needed <= D", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        if D == 1:\n            return sum(weights)\n        start = max(max(weights),-(-sum(weights)//D))\n        end = sum(weights)\n        n = len(weights)\n        def validate(x):\n            count = 0\n            i = 0\n            while count < D:\n                cur = 0\n                while i< n and cur <= x:\n                    cur += weights[i]\n                    i += 1\n                i-=1\n                count += 1\n            if i == n-1 and cur <= x:\n                return True\n            return False\n\n        while start < end:\n            m = (start+end)//2\n            if validate(m):\n                end = m\n            else:\n                start = m+1\n        return start\n            \n            \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def feasible(w):\n            i = 0 \n            for day in range(D):\n                ship_w = 0\n                while i < len(weights):\n                    #print(str(w - ship_w)+\\\">=\\\"+str(weights[i]))\n                    if w - ship_w >= weights[i]:\n                        ship_w += weights[i]\n                    else:\n                        break\n                    i+=1\n            return i == len(weights)\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = (left+right) >> 1\n            if feasible(mid):\n                right = mid \n            else:\n                left = mid + 1\n        return left\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n        def check_capacity(capacity) -> bool:\n            days = 1\n            ship_weight = 0\n            for weight in weights:\n                ship_weight += weight\n                if ship_weight > capacity:\n                    ship_weight = weight\n                    days += 1\n                    if days > D:\n                        return False\n            return True\n\n        left = max(weights)\n        right = left * len(weights) // D\n        while left < right:\n            mid = left + (right - left) // 2\n            if check_capacity( mid ):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        memo = {}\n        high = sum(weights)\n        low = ceil(high / D)\n        best = low\n        mid = low + (high - low) // 2\n        memo[mid] = is_possible(weights, mid, D)\n        memo[mid + 1] = is_possible(weights, mid + 1, D)\n        \n        while memo[mid] or not memo[mid + 1]:\n            if high == low and high == best:\n                \n                return best\n            \n            # print(low)\n            # print(high)\n            # print(mid)\n            # print(\\\"----\\\")\n            if not memo[mid]: #not mid and not mid + 1, answer is higher\n                low = mid + 1\n                \n            else: # mid and mid + 1, answer is lower\n                high = mid\n                \n            mid = low + (high - low) // 2\n            if mid not in memo:\n                memo[mid] = is_possible(weights, mid, D)\n                \n            if mid + 1 not in memo:\n                memo[mid + 1] = is_possible(weights, mid + 1, D)\n            \n        return mid + 1\n    \ndef is_possible(weights, max_w, D):\n    total = 0\n    \n    for i, weight in enumerate(weights):\n        if weight > max_w:\n            return False\n        \n        if total + weight > max_w:\n            total = 0\n            D -= 1\n            \n            # full before the last one is added\n            if D == 0:\n                return False\n        \n        total += weight\n        \n            \n    return True", "class Solution:\n    def possible(self, capacity):\n        ret = 0\n        cur = 0\n        for w in self.weights:\n            if w > capacity:\n                return False\n            if cur + w <= capacity:\n                cur += w\n            else:\n                ret += 1\n                cur = w\n        if w > 0:\n            ret += 1\n        return ret <= self.D\n        \n        \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        self.weights = weights\n        self.D = D\n        \n        # print(self.possible(15))\n        lo, hi = 1, 0x3f3f3f3f\n        while lo <= hi:\n            mid = lo + ((hi-lo) >> 1)\n\n            if self.possible(mid):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        if self.possible(lo):\n            return lo\n        return lo + 1\n                \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        memo = {}\n        high = sum(weights)\n        low = ceil(high / D)\n        best = low\n        mid = low + (high - low) // 2\n        memo[mid] = is_possible(weights, mid, D)\n        memo[mid + 1] = is_possible(weights, mid + 1, D)\n        \n        while memo[mid] or not memo[mid + 1]:\n            if high == low and high == best:\n                # print(\\\"###\\\")\n                # print(memo[2])\n                # print(memo[3])\n                return best\n            \n            # print(low)\n            # print(high)\n            # print(mid)\n            # print(\\\"----\\\")\n            if not memo[mid]: #not mid and not mid + 1, answer is higher\n                low = mid\n                \n            else: # mid and mid + 1, answer is lower\n                high = mid\n                \n            mid = low + (high - low) // 2\n            if mid not in memo:\n                memo[mid] = is_possible(weights, mid, D)\n                \n            if mid + 1 not in memo:\n                memo[mid + 1] = is_possible(weights, mid + 1, D)\n            \n        return mid + 1\n    \ndef is_possible(weights, max_w, D):\n    total = 0\n    \n    for i, weight in enumerate(weights):\n        if weight > max_w:\n            return False\n        \n        if total + weight > max_w:\n            total = 0\n            D -= 1\n            \n            # full before the last one is added\n            if D == 0:\n                return False\n        \n        total += weight\n        \n            \n    return True", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        l, r = max(weights), sum(weights)\n        \n        while l<=r:\n            \n            mid = l + (r-l)//2\n            \n            need, cur = 1, 0\n            \n            for w in weights:\n                \n                if cur+w > mid:\n                    need += 1\n                    cur = 0\n                    \n                cur += w\n                \n            if need > D:\n                l = mid + 1\n            else:\n                r = mid-1\n                \n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = max(weights)\n        r = sum(weights)\n\n        def canFitInD(m):\n            n = 1\n            current = 0\n            for i in range(len(weights)):\n                if current + weights[i] <= m:\n                    current += weights[i]\n                else:\n                    n += 1\n                    current = weights[i]\n                    if n > D:\n                        return False\n            return True\n\n        while l < r:\n            mid = l + (r - l)//2\n            if canFitInD(mid):\n                r = mid\n            else:\n                l = mid+1\n\n        return l\n# leetcode submit region end(Prohibit modification and deletion)\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n            n = len(weights)\n            if not n: return n\n            \n            total = sum(weights)\n            target = total//D\n            left, right = max(weights), total\n            \n            def check(s,total, D):\n                cur = 0\n                i=0\n                while i<len(weights):\n                    w = weights[i]\n                    if cur+w>s:\n                        total-=cur\n                        D-=1\n                        cur=0\n                    else:\n                        cur+=w\n                        i+=1\n                    \n                    if D==1:\n                        if total>s: return False\n                        else: return True\n                return True\n            \n            ans = total\n            while left<=right:\n                mid = (left+right+1)//2\n                if check(mid,total,D): \n                    ans = min(ans,mid)\n                    right = mid-1\n                else: \n                    left = mid+1\n            \n            return ans", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def check(capacity, D):\n            d = 0\n            i = 0\n            c = capacity\n            while(d < D):\n                if(i == len(weights)):\n                    return True\n                if(weights[i] <= c):\n                    if(weights[i] > capacity):\n                        return False\n                    c -= weights[i]\n                    i+=1\n                else:\n                    c = capacity\n                    d += 1\n            return False\n        l=0; r=max(weights)*len(weights)\n        while(l<r):\n            mid = l + (r-l)//2\n            if(check(mid, D)):\n                r = mid\n            else:\n                l = mid+1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def isOK(weights,D,w):\n            count=1\n            weight=0\n            for i in range(0,len(weights)):\n                if weights[i]>w or count>D:\n                    return False\n                if weight+weights[i]>w:\n                    count+=1\n                    weight=0\n                weight+=weights[i]\n            if count<=D:\n                return True\n            else:\n                return False\n            \n        left=max(weights)\n        right=sum(weights)\n        while left<=right:\n            middle=(left+right)//2\n            if isOK(weights,D,middle)==True:\n                right=middle-1\n            else:\n                left=middle+1\n        return left\n            \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def good(cap):\n            i, tmp, ans = 0, 0, 1\n            while i < len(a):\n                if tmp + a[i] <= cap:\n                    tmp += a[i]\n                else:\n                    ans += 1\n                    tmp = a[i]\n                i += 1\n            return ans <= D\n        \n        a = weights\n        lo, hi = max(a), sum(a)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if good(mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def helper(w):\n            i=0\n            cnt=0\n            while cnt<D:\n                curr=0\n                while i<len(weights):\n                    if curr+weights[i]<=w:\n                        curr+=weights[i]\n                        i+=1\n                    else:\n                        break\n                cnt+=1\n            return False if i!=len(weights) else True\n        l,r=max(weights),sum(weights)\n        while l<=r:\n            mid=(l+r)//2\n            if helper(mid):\n                r=mid-1\n            else:\n                l=mid+1\n        return l\n        \n            \n            \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        low, high = max(weights), sum(weights)\n            \n        while low<high:\n            mid = low + (high-low)//2\n            d = 1\n            curr_sum = 0\n            for idx in range(len(weights)):\n                if curr_sum + weights[idx] >mid:\n                    d += 1\n                    curr_sum =0\n                curr_sum += weights[idx]\n            \n            if d <=D:\n                high = mid\n            else:\n                low = mid+1\n        return low\n            \n", "from typing import List\nimport bisect\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = min(weights)\n        r = max(weights) * len(weights)\n        \n        def isOk(capacity):\n            item = 0\n            day = 0\n            while item < len(weights):\n                s = 0\n                while True:\n                    if weights[item] > capacity:\n                        return False\n                    if s + weights[item]> capacity:\n                        break\n                    else:\n                        s = s + weights[item]\n                        item += 1\n                    if item >= len(weights):\n                        break\n                day += 1\n            return day <= D\n        print((isOk(15)))\n        while r - l > 1:\n            mid = l + (r - l)//2\n            if isOk(mid):\n                r = mid\n            else:\n                l = mid\n        return r\nprint((Solution().shipWithinDays([1,2,3,4,5,6,7,8,9,10],5)))\n\n", "def isOK(cap, weights, D):\n    cnt = 1\n    total = 0\n    for i in range(len(weights)):\n        if total + weights[i] > cap:\n            cnt += 1\n            total = weights[i]\n        else:\n            total += weights[i]\n    return cnt <= D\n\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), max(weights) * len(weights) // D\n        \n        \n        while left <= right:\n            mid = (right+left) //2\n            if isOK(mid, weights, D):\n                right = mid -1\n            else:\n                left = mid +1\n        return left \n", "from typing import List\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = -1\n        r = max(weights) * len(weights)\n        \n        def isOk(capacity):\n            item = 0\n            day = 0\n            while item < len(weights):\n                s = 0\n                while True:\n                    if weights[item] > capacity:\n                        return False\n                    if s + weights[item]> capacity:\n                        break\n                    else:\n                        s = s + weights[item]\n                        item += 1\n                    if item >= len(weights):\n                        break\n                day += 1\n            return day <= D\n\n\n        while r - l > 1:\n            mid = l + (r - l)//2\n            if isOk(mid):\n                r = mid\n            else:\n                l = mid\n                \n        return r\n\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        mini = max(weights)\n        maxi = sum(weights)\n        \n        if len(weights) == 1:\n            return weights[0]\n        \n        while maxi >= mini:\n            mid = (maxi + mini) // 2 \n            if self.check(weights, mid) < D:\n                maxi = mid - 1\n            elif self.check(weights, mid) > D:\n                mini = mid + 1\n            else:\n                maxi = mid - 1\n            print(mini)\n        return mini\n            \n    def check(self, piles, num):\n        res = 0\n        i = 0\n        count = 0\n        while i < len(piles):\n            if res + piles[i] < num:\n                res += piles[i]\n            elif res+piles[i] == num:\n                res = 0\n                count += 1\n            else:\n                res = piles[i]\n                count += 1\n            i += 1\n        count = count if res == 0 else count + 1\n        return count", "class Solution:\n    def possibleWithinDays(self, weights, D, capacity):\n        x = 0\n        i = 1\n        total = 0\n        while(i <= D):\n            current_sum = 0\n            #print(i)\n            \n            while(x < len(weights) and current_sum + weights[x] <= capacity):\n                current_sum += weights[x]\n                total += weights[x]\n                x += 1\n            #print(\\\"x: \\\",x)\n            #print(\\\"cur_sum: \\\",current_sum)\n            #print(\\\"total: \\\",total)\n            i += 1\n        \n        if total >= sum(weights):\n                return True\n        #print(\\\"i\\\",i,\\\"x\\\",x)\n        return False\n            \n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        total_sum = sum(weights)\n        left = 0\n        right = total_sum\n        \n        while(left < right):\n            middle = (left+right)//2\n            aux = self.possibleWithinDays(weights,D,middle)\n            if aux:\n                right = middle\n            else:\n                left = middle+1\n        \n        return left\n        \n    #1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ...50000 \n    #1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... 55\n    #that capacity makes True if we can do it in less or equal than D\n   \n    #1+55 = 56/2 = 28\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        sums = [0] * (len(weights) + 1)\n        for i in range(len(weights)):\n            sums[i + 1] = weights[i] + sums[i]\n        \n        def backtracking(i, cap, d):\n            if i == len(sums):\n                return True\n            if sums[-1] - sums[i - 1] > cap * d:\n                return False\n            j = i\n            while j < len(sums):\n                if sums[j] - sums[i - 1] > cap:\n                    break\n                j += 1\n            return backtracking(j, cap, d - 1)\n        \n        l, h = max(weights), sum(weights)\n        \n        while l <= h:\n            m = (l + h) // 2\n            if backtracking(1, m, D):\n                h = m - 1\n            else:\n                l = m + 1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        n=len(weights)\n        l=max(weights)\n        r=n*max(weights)\n        pre=[weights[0]]\n        for i in range(1,len(weights)):\n            pre.append(pre[-1]+weights[i])\n        def checker(val) -> bool:\n            x=0\n            y=0\n            j=0\n            i=0\n            while(i<len(pre)):\n                x=pre[i]-y\n                if(x==val):\n                    x=0\n                    y=pre[i]\n                    j+=1\n                    if(j>D):\n                        return False\n                elif(x>val):\n                    x=0\n                    y=pre[i-1]\n                    i-=1\n                    j+=1\n                    if(j>D):\n                        return False\n                i+=1\n            if(j==D)and(x!=0):\n                return False\n            return True\n        while(l<r):\n            mid=(l+r)//2\n            if(checker(mid)==True):\n                r=mid\n            else:\n                l=mid+1\n        return l\n        \n            \n", "from typing import List\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = -1\n        r = max(weights) * len(weights)\n        \n        def isOk(capacity):\n            item = 0\n            day = 0\n            while item < len(weights):\n                s = 0\n                while True:\n                    if weights[item] > capacity:\n                        return False\n                    if s + weights[item]> capacity:\n                        break\n                    else:\n                        s = s + weights[item]\n                        item += 1\n                    if item >= len(weights):\n                        break\n                day += 1\n            return day <= D\n        print((isOk(100000)))\n\n\n        while r - l > 1:\n            mid = l + (r - l)//2\n            if isOk(mid):\n                r = mid\n            else:\n                l = mid\n                \n        return r\n\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        end = sum(weights)\n        start = end // D\n        \n        while start < end:\n            mid = (start + end) // 2\n            # print(start, end, mid)\n            \n            days = 1\n            curr_sum = 0\n            for i in range(len(weights)):\n                if weights[i] > mid:\n                    days = D + 1\n                    break\n                if curr_sum + weights[i] > mid:\n                    days += 1\n                    if days > D:\n                        break\n                    curr_sum = weights[i]\n                else:\n                    curr_sum += weights[i]\n            # print(days)\n            \n            if start == mid:\n                if days > D:\n                    return end\n                else:\n                    return start\n                \n            if days > D:\n                start = mid\n            else:\n                end = mid\n        return start", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        preSum = [0]\n        for weight in weights:\n            preSum.append(weight + preSum[-1])\n        N = len(weights)\n        \n        def shipWeights(ship):\n            D0 = D\n            start = 0\n            l = 1\n            r = N\n            while D0 > 0 and l <= N:\n                if ship >= preSum[r]-preSum[start]:\n                    l = r+1\n                while r > l:\n                    m = (l + r) // 2\n                    if preSum[m]-preSum[start] > ship:\n                        r = m\n                    else:\n                        l = m + 1\n                D0 -= 1\n                start = l - 1\n                r = N\n\n            if l == N+1:\n                return True\n            return False\n        \n        wl = max(weights)\n        wr = sum(weights)\n        \n        if D >= len(weights):\n            return wl\n        if D == 1:\n            return wr\n        while wr > wl:\n            wm = (wr + wl) // 2\n            if shipWeights(wm):\n                wr = wm\n            else:\n                wl = wm + 1\n        return wl", "class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        self.weights = weights\n        self.days = days\n        left, right = max(weights), sum(weights)\n        while left < right: \n            mid = left + (right - left) // 2\n            if self.isFit(mid):\n                right = mid\n            else: \n                left = mid+1\n        return left\n            \n        \n    def isFit(self, capacity):\n        weight_index = 0\n        for day in range(0, self.days):\n            current_capacity = capacity\n            while current_capacity >= 0:\n                if weight_index == len(self.weights):\n                    return True\n                weight = self.weights[weight_index]\n                if (current_capacity - weight < 0):\n                    break\n                else:\n                    current_capacity -= weight\n                    weight_index += 1\n        return False\n             \n                \n                \n            \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        start, end = max(weights), sum(weights)\n        while start+1 < end:\n            mid = (start + end) // 2\n            days = self.get_days(weights, mid)\n            if days > D:\n                start = mid + 1\n            elif days <= D:\n                end = mid\n        if self.get_days(weights, start) <= D:\n            return start\n        else:\n            return end\n    \n    def get_days(self, weights, cap):\n        tot = 0\n        res = 1\n        i = 0\n        while i < len(weights):\n            tot += weights[i]\n            if tot > cap:\n                res += 1\n                tot = 0\n            else:\n                i += 1\n        return res\n    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        # Return true if all packages can be shipped within D days\n        # with capacity capacity.\n        # Note that if I can ship with capacity, I can definitely ship with\n        # any value > capacity\n        def check(capacity):\n            cur = ix = 0\n            day = 1\n            while ix < len(weights):\n                if cur + weights[ix] == capacity:\n                    cur = 0\n                    day += 1\n                elif cur + weights[ix] > capacity:\n                    cur = weights[ix]\n                    day += 1\n                else:\n                    cur += weights[ix]\n                ix += 1\n            return ix == len(weights) and day <= D\n        \n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def is_possible(C):\n            if C < max(weights):\n                return False\n            \n            d, i, cap, n = 1, -1, 0, len(weights)\n            while d <= D:\n                while i < n - 1 and cap + weights[i + 1] <= C:\n                    cap += weights[i + 1]\n                    i += 1\n                d += 1\n                cap = 0\n            if i < n - 1: return False\n            return True\n        \n        left, right = 0, sum(weights)\n        while left < right:\n            mp = left + (right - left) // 2\n            if is_possible(mp):\n                right = mp\n            else:\n                left = mp + 1\n                \n        return left\n", "class Solution:\n    def canBeFerried(self, weights: List[int], D: int, capacity: int) -> bool:\n        i, j, days = 0, 0, 0\n        while i < len(weights):\n            sum_ = 0\n            j = 0\n            while (sum_ <= capacity):\n                if (i + j < len(weights)):\n                    sum_ += weights[i + j]\n                else:\n                    days += 1\n                    return days <= D\n                j += 1\n            # print(f\\\"After exiting second loop: sum_ = {sum_}, j = {j}\\\")\n            days += 1\n            # print(f\\\"Increased days to {days}\\\")\n            \n            if i == len(weights) - 1:\n                break\n            i += j - 1\n            # print(f\\\"Set i = {i}\\\")\n            if days > D:\n                return False\n        return days <= D\n            \n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        low = max(weights)\n        high = len(weights) * low\n        \n        while low < high:\n            mid = (low + high) // 2\n            if self.canBeFerried(weights, D, mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def canDo(k):\n            d = 1\n            curr = 0\n            for w in weights:\n                if w > k:\n                    return False\n                curr += w\n                if curr > k:\n                    d +=1\n                    curr = w\n            return d <= D\n        \n        l,r = 0,10**18\n        while l < r:\n            m = (l+r)//2\n            # print(l,r,m,canDo(m))\n            if canDo(m):\n                r = m\n            else:\n                l = m+1\n        return l\n                \n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        l,h = max(weights),sum(weights)\n        \n        \n        while l < h:\n            \n            \n            days = 1\n            \n            total_weight = 0\n            \n            capacity = (l+h)//2\n            # print(capacity)\n            \n            for weight in weights:\n                total_weight += weight\n                \n                if total_weight > capacity:\n                    # print(total_weight)\n                    days += 1\n                    total_weight = weight\n            if days <= D:\n                h = capacity\n            else:\n                l = capacity+1\n        return l\n                    \n            # print(days,total_weight)\n            # break\n                    \n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        l = max(weights)\n        r = sum(weights)\n        \n        def calc(cap):\n            cnt = 0\n            cur = 0\n            for w in weights:\n                cur += w\n                if cur > cap:\n                    cur = w\n                    cnt += 1\n            return cnt + 1 <= D\n        \n        while l < r:\n            mid = (l + r) // 2\n            good = calc(mid)\n            if good:\n                r = mid\n            else:\n                l = mid + 1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right-left) // 2\n            if self.__countDays(weights, mid) <= D:\n                right = mid\n            else:\n                left = mid+1\n        return left\n        \n    def __countDays(self, weights, capacity):\n        days = 0\n        cur_w = 0\n        for w in weights:\n            cur_w += w\n            if cur_w > capacity:\n                days += 1\n                cur_w = w\n        return days + 1", "import sys\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = left * len(weights) // D\n        while left < right: \n            mid = left + (right - left) // 2\n            c = 0 # capacity\n            d = 1 # days\n            for w in weights:\n                if c + w <= mid:\n                    c += w\n                else:\n                    d += 1\n                    c = w\n            if d > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def check(W: int) -> bool:\n            count, total = 1, 0\n            for w in weights:\n                total += w\n                if total > W:\n                    count += 1\n                    total = w\n                    if count > D: return False\n            \n            return True\n        \n        left, right = max(weights), sum(weights)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n        \n                \n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def feasible(capacity):\n            day = 1\n            total = 0\n            \n            for weight in weights:\n                total += weight\n                if total > capacity:\n                    total = weight\n                    day += 1\n                    \n                    if day > D:\n                        return False\n                \n            \n            return True\n        \n        low, high = max(weights), sum(weights)\n        \n        while low < high:\n            mid = low + (high-low)//2\n            \n            if feasible(mid):\n                high = mid\n            \n            else:\n                low = mid+1\n            \n        return low", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def feasible(capacity):\n            days = 1\n            total = 0\n            \n            for wt in weights:\n                total += wt\n                if total > capacity:\n                    total = wt\n                    days += 1\n                    if days > D:\n                        return False\n\n            return True\n\n        left = max(weights)\n        right = sum(weights)\n        \n        while left < right:\n            mid = left + (right - left)//2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid+1\n        \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def binarySearch(capacity):\n            days = 1\n            total = 0\n            for i in weights:\n                total+=i\n                if total > capacity:#wait for the next day\n                    total = i\n                    days+=1\n                    if days > D:#cannot ship\n                        return False\n            return True\n        left,right = max(weights),sum(weights)\n        while left < right:\n            mid = left+(right-left)//2\n            if binarySearch(mid):\n                right = mid\n            else:\n                left = mid+1\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def isPossible(capacity):\n            day=1\n            w=0\n            for wt in weights:\n                w+=wt\n                if w>capacity:\n                    day+=1\n                    w=wt\n            return day\n        \n        start,end=max(max(weights),sum(weights)//D),sum(weights)\n        \n        while start<end:\n            mid=start+(end-start)//2\n            days=isPossible(mid)\n            if days<=D:\n                end=mid\n            elif days>D:\n                start=mid+1\n            \n        return start\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def feasible(capacity):\n            \n            days = 1\n            total = 0\n            for weight in weights:\n                total += weight\n                \n                if total > capacity:\n                    total = weight\n                    days += 1\n                    if days > D:\n                        return False\n            return True\n        \n        left = max(weights)\n        right = sum(weights)\n        \n        while left < right:\n            mid = left + (right - left)//2\n            \n            if feasible(mid):\n                right = mid\n            else:\n                left = mid+1\n                \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        \n        n = len(weights)\n        \n        hi = 0\n        lo = 0\n        for w in weights:\n            lo = max(lo, w)\n            hi += w\n        \n        if D == 1:\n            return hi\n        \n        while lo < hi:\n            mid = lo + ((hi - lo)//2)\n            cur, days = 0, 1\n            for w in weights:\n                cur += w\n                if cur > mid:\n                    days += 1\n                    cur = w\n            if days > D:\n                lo = mid + 1\n            else:\n                hi = mid\n            # print(lo, mid, hi)\n        return lo", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n\n        while l < r:\n            mid = (r - l) // 2 + l\n            day = self.weightWhetherWork(weights, mid)\n            if day > D:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def weightWhetherWork(self, weights, mid):\n        temp = mid\n        day = 1\n        for i in weights:\n            if temp >= i:\n                temp -= i\n            else: \n                temp = mid\n                temp -= i\n                day += 1\n        return day", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        low = max(weights)\n        high = sum(weights)\n        total =0\n        parts=1\n        while(low<high):\n            total=0\n            parts=1\n            mid = int((low+high)/2)\n            for w in weights:\n                if total+w<=mid:\n                    total=total+w\n                else:\n                    total=w\n                    parts+=1\n            if parts>D:\n                low=mid+1\n            else:\n                high=mid\n        return low", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        lo,hi = max(weights),sum(weights)\n        \n        while lo < hi:\n            mid = (lo + hi)//2\n            tot,res = 0,1\n            for a in weights:\n                if a+tot>mid:\n                    tot = a\n                    res+=1\n                else:\n                    tot+=a\n            if res <= D:\n                hi = mid\n            else :\n                lo = mid + 1\n        return lo", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def calDays(weights, cap):\n            days = 1\n            acc_w = 0\n            for w in weights:\n                acc_w += w\n                if acc_w > cap:\n                    days += 1\n                    acc_w = w\n            return days\n            \n        lo = max(weights)\n        hi = lo * len(weights) // D\n        while lo < hi:\n            med = lo + (hi-lo)//2\n            days = calDays(weights, med)\n            if days <= D:\n                hi = med\n            else:\n                lo = med+1\n        return hi\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while  left < right:\n            mid, load, need = (left + right)//2, 0, 1\n            for w in weights:\n                load += w\n                if load > mid:\n                    need += 1\n                    load = w\n            if need > D: left = mid + 1\n            else: right = mid\n        return left        \n                \n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        \n        while(left < right):\n            mid = int((left+right)/2)\n            print(mid)\n            curr_weight = 0\n            days = 1\n            for w in weights:\n                if(curr_weight+w <= mid):\n                    curr_weight+= w\n                else:\n                    curr_weight = w\n                    days += 1\n            if(days > D):\n                left = mid+1\n            else:\n                right = mid\n        \n        return left\n                    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n        def canship(cap):\n            d = 1\n            s = 0\n            for w in weights:\n                if s+w<=cap:\n                    s+=w\n                else:\n                    d+=1\n                    s=w\n                if d>D:\n                    return False\n            return True\n\n\n        M = max(weights)\n        if D==len(weights):\n            return M\n        \n        lo, hi = M-1, sum(weights)\n        \n        while hi-lo>1:\n            h = (hi+lo)//2\n            if canship(h):\n                hi=h\n            else:\n                lo=h\n        \n        return hi", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n        \n        def isPossible(capacity):\n            days = 0\n            temp = 0\n            for w in weights:\n                if temp + w <= capacity:\n                    temp += w\n                else:\n                    days += 1\n                    temp = w\n            return days + 1 <= D\n        \n        while l < r:\n            mid = l + (r - l) // 2\n            if isPossible(mid):\n                r = mid\n            else:\n                l = mid + 1\n        \n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def possible(K):\n            if K < max(weights):\n                return False\n            day = 1 \n            temp = K \n            for we in weights:\n                if temp < we:\n                    temp = K-we\n                    day +=1\n                else:\n                    temp -= we\n                \n            return not (day>D)\n        lo, hi = max(weights), sum(weights)\n        \n        while lo<hi:\n\n            mi = (lo+hi)//2\n            if not possible(mi):\n                lo = mi+1\n            else:\n                hi = mi\n\n        return lo\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], limit: int) -> int:\n        \n        def count_days(cap: int) -> int:\n            cur_weight = 0\n            days = 1\n\n            for w in weights:\n                if cur_weight + w > cap:\n                    days += 1\n                    cur_weight = w\n                else:\n                    cur_weight += w\n                # print(f\\\"cap= {cap}, weight={w}, cur_weight={cur_weight}, days={days}\\\")\n\n            return days\n\n        left = max(weights)\n        right = sum(weights)\n\n        while left < right:\n            mid = left + (right - left) // 2\n            time = count_days(mid)\n            # print(f\\\"cap={mid}, left={left}, right={right}, time={time}\\\")\n            if time > limit:\n                left = mid + 1\n            else:\n                right = mid\n\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, r = max(weights), sum(weights)\n        \n        def checkCapacity(maxCap):\n            day = 1\n            temp = 0\n            for i in weights:\n                temp+=i\n                if temp>maxCap:\n                    temp = i\n                    day+=1\n                if day>D:\n                    return False\n            return True\n            \n        \n        while l<r:\n            mid = l+(r-l)//2\n            if checkCapacity(mid):\n                r=mid\n            else:\n                l=mid+1\n                \n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        left = max(weights)\n        right = sum(weights)\n        \n        while left < right:\n            mid = left + (right-left)//2\n            \n            if self.isFeasible(mid, weights, D):\n                right = mid\n            else:\n                left = mid + 1\n            \n        return left\n    def isFeasible(self, capacity, weights, D):\n        \n        total = 0\n        days = 1\n        for weight in weights:\n            if total + weight <= capacity:\n                \n                total += weight\n            else:\n                total = weight\n                days += 1\n                if days > D:\n                    return False\n        return True\n            \n", "from collections import deque\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def canShip(capacity):\n            nonlocal D\n            count, loaded = 1, 0\n            for w in weights:\n                if loaded + w <= capacity:\n                    loaded += w\n                else:\n                    count += 1\n                    loaded = w\n            return count <= D\n    \n        max_weight = max(weights)\n        low, high = sum(weights) // D,  max_weight * len(weights) // D + 1\n        while low < high:\n            mid = low + (high - low) // 2\n            if mid < max_weight or not canShip(mid):\n                low = mid + 1\n            else:\n                high = mid\n        return low\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) // 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D:\n                left = mid + 1\n            else: right = mid\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid, need, cur = (left + right) // 2, 1, 0\n            for w in weights:\n                if cur + w > mid:\n                    need += 1\n                    cur = 0\n                cur += w\n            if need > D:\n                left = mid + 1\n            else:\n                right = mid\n\n        return left\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = (left + right)//2\n            current = 0\n            need = 1\n            for w in weights:\n                if current + w > mid:\n                    need += 1\n                    current = 0\n                current += w\n                \n            if need > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        \n        res = right\n        while left <= right:\n            mid = left + (right - left)//2\n            d = self.get_day(weights, mid)\n            #print(left, right, mid, d)\n            if d <= D:\n                res = min(res, mid)\n                right = mid - 1\n            else:\n                left = mid + 1\n        return res\n\n    \n    def get_day(self, weights, cap):\n        cur = 0\n        res = 0\n        for x in weights:\n            if cur + x > cap:\n                res += 1\n                cur = 0\n            cur += x\n\n        return res + 1\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def numberofDaysWithCapacity(weights,mid):\n            sum,c=0,1\n            for i in range(len(weights)):\n                sum+=weights[i]\n                if(sum>mid):\n                    c+=1\n                    sum=weights[i]\n            return c\n        left,right=max(weights),sum(weights)\n        while(left<=right):\n            mid=left+(right-left)//2\n            daysRequired=numberofDaysWithCapacity(weights,mid)\n            if daysRequired>D:\n                left=mid+1\n            else:\n                res=mid\n                right=mid-1\n        return res\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n       \n        def fun(t):\n            s= 0\n            d= 0\n            for i in range(n):\n                s=s+weights[i]\n                if s>t:    \n                    d=d+1\n                    s = weights[i]\n            return d\n        \n        n = len(weights)        \n        lo, hi = max(weights),sum(weights)\n        while(lo <= hi):\n            c= lo + (hi - lo)//2\n            if fun( c )< D:\n                hi=c-1\n            else:\n                lo=c+1\n        return lo        ", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n\n        def days_required( t ):\n            running_sum = 0\n            days = 0\n            for i in range(n):\n                running_sum += weights[i]\n                if running_sum > t:    \n                    days += 1\n                    running_sum = weights[i]\n            return days\n        \n        n = len(weights)        \n        lo, hi = max(weights), sum(weights)\n        while(lo <= hi):\n            capacity = lo + (hi - lo)//2\n            if days_required( capacity ) < D:\n                hi = capacity - 1\n            else:\n                lo = capacity + 1\n        return lo                       ", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        high = 0\n        low = 0\n        for weight in weights:\n            high += weight\n            low = max(low, weight)\n        \n        # Search over the possible solutions of [max value, sum of weights]\n        while (low < high):\n            mid = (high + low) // 2\n            \n            days = 1\n            cur_weight = 0\n            for weight in weights:\n                if cur_weight + weight > mid:\n                    cur_weight = 0\n                    days += 1\n                cur_weight += weight\n                    \n            # Did it in too many days, need higher capacity\n            if days > D:\n                low = mid + 1\n            # Did it in too few days, need lower capacity\n            else:\n                high = mid\n\n                \n        return low\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def canShip(capacity: int) -> bool:\n            nonlocal D\n            count = 1\n            curcap = 0 \n            for w in weights:\n                if curcap + w <= capacity:\n                    curcap += w\n                else:\n                    count += 1\n                    curcap = w\n            return count <= D\n            \n        \n        max_weight = max(weights)\n        lo = sum(weights) // D\n        hi = max_weight * (len(weights)) // D + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if mid < max_weight or not canShip(mid):\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        mi = max(weights)\n        ma = sum(weights)\n        \n        def canFit(cap):\n            num = 1\n            re = cap \n            for i in range(len(weights)):\n                x = weights[i]\n                if x > re:\n                    re = cap \n                    num += 1\n                re -= x\n            return num <= D\n        \n        while mi < ma:\n            mid = mi + (ma - mi) // 2\n            if canFit(mid):\n                ma = mid\n            else:\n                mi = mid+1\n        return mi", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def check(cap):\n            cnt, load = 0, 0\n            for x in weights:\n                # cap is too small to load even one package\n                if x > cap: return False\n                if load + x < cap:\n                    load += x\n                elif load + x == cap:\n                    cnt, load = cnt+1, 0\n                else:\n                    cnt, load = cnt+1, x\n            return cnt + (load > 0) <= D\n        \n        l, r = 1, sum(weights)\n        while l < r:\n            p = l + (r - l) // 2\n            if not check(p): l = p+1\n            else: r = p\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        high = sum(weights)\n        low = max(weights)\n        \n        def check(cap):\n            cnt = 1\n            summ = 0\n            for w in weights:\n                if summ+w <= cap:\n                    summ += w\n                else:\n                    cnt += 1\n                    summ = w\n                if cnt > D:\n                    return False\n            return True\n        \n        while low!=high:\n            mid = (low+high)//2\n            if check(mid):\n                high = mid\n            else:\n                low = mid+1\n        \n        return low\n", "class Solution:\n    # def shipWithinDays(self, weights: List[int], D: int) -> int:\n    #     if D == 1:\n    #         return sum(weights)\n    #     curCap = sum(weights)//D\n    #     days = 1\n    #     i = 0\n    #     cap = curCap\n    #     while i < len(weights):\n    #         cap -= weights[i]\n    #         if cap <= 0:\n    #             days += 1\n    #             if cap == 0:\n    #                 i += 1\n    #             cap = curCap\n    #         else:\n    #             i += 1\n    #         if days > D:\n    #             curCap += 1\n    #             days = 1\n    #             i = 0\n    #             cap = curCap\n    #     return curCap\n    \n    def shipWithinDays(self, weights, D):\n        l, r = max(weights), sum(weights)\n                            \n        while l < r:\n            m, days, curWeight = (l + r) // 2, 1, 0\n            for weight in weights:\n                if curWeight + weight > m:\n                    days += 1\n                    curWeight = 0\n                if days > D:\n                    l = m + 1\n                    break\n                curWeight += weight\n            else: \n                r = m\n        return l\n    \n        # def shipWithinDays(self, weights, D):\n    #     left, right = max(weights), sum(weights)\n    #     while left < right:\n    #         mid, need, cur = (left + right) // 2, 1, 0\n    #         for w in weights:\n    #             if cur + w > mid:\n    #                 need += 1\n    #                 cur = 0\n    #             cur += w\n    #         if need > D: left = mid + 1\n    #         else: right = mid\n    #     return left\n", "from collections import defaultdict\nclass Solution:\n     def canShipWithinDays(self, weights: List[int], D: int, maxWeight: int) -> bool:\n        if max(weights) > maxWeight:\n            return False\n        \n        lswt = 0\n        nD = 1\n        for w in weights:\n            if lswt + w <= maxWeight:\n                lswt += w\n            else:\n                nD += 1\n                lswt = w\n        return nD <= D\n    \n     def shipWithinDays(self, weights: List[int], D: int) -> int:\n        maxweight = sum(weights)\n        minweight = max(weights)\n        while maxweight > minweight + 1:\n            mw = (maxweight + minweight) // 2 \n            if self.canShipWithinDays(weights, D, mw):\n                maxweight = mw\n            else:\n                minweight = mw\n        \n        if self.canShipWithinDays(weights, D, minweight):\n            return minweight\n        else:\n            return maxweight", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def canShip(capacity: int) -> bool:\n            nonlocal D\n            count = 1\n            curcap = 0 \n            for w in weights:\n                if curcap + w <= capacity:\n                    curcap += w\n                else:\n                    count += 1\n                    curcap = w\n            return count <= D\n            \n        \n        max_weight = max(weights)\n        lo = sum(weights) // D\n        hi = max_weight * len(weights) // D + 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if mid < max_weight or not canShip(mid):\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n                \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def can(x):\n            res, sum = 1, 0\n            for w in weights:\n                if w > x: return False\n                if sum + w > x:\n                    res += 1\n                    sum = w\n                else: sum += w\n            return res <= D\n        mx, sum = 0, 0\n        for i in weights: \n            mx, sum = max(mx, i), sum + i\n        lo, hi = mx, sum\n        while lo < hi:\n            mi = (hi - lo) // 2 + lo\n            if not can(mi): lo = mi + 1\n            else: hi = mi\n        return lo", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def condition(minWeight):\n            dayCt = 1\n            curWeight = 0\n            for i, w in enumerate(weights):\n                if curWeight + w <= minWeight:\n                    curWeight += w\n                else:\n                    dayCt += 1\n                    curWeight = w\n            \n            return dayCt <= D\n        \n        l = max(weights)\n        r = sum(weights)\n        \n        while l < r:\n            m = l + (r - l) // 2\n            if condition(m):\n                r = m\n            else:\n                l = m + 1\n        \n        return l\n", "# from itertools import combinations \n# import sys\nclass Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n#         if D == 1:\n#             return sum(weights)\n        \n#         all_comb = combinations(range(1,len(weights)), D-1)\n        \n#         res = sys.maxsize\n#         for comb in all_comb:\n#             cap = 0\n#             # print(comb)\n#             for i in range(len(comb) + 1):\n#                 if i == 0:\n#                     cap = max(cap, sum(weights[:comb[i]]))\n#                 elif i == len(comb):\n#                     cap = max(cap, sum(weights[comb[i-1]:]))\n#                 else:\n#                     cap = max(cap, sum(weights[comb[i-1]:comb[i]]))\n#             res = min(res, cap)\n#         return(res)\n\n        lower = max(weights)\n        upper = sum(weights)\n        \n        while abs(lower - upper) > 1:\n            mid = (lower + upper) // 2\n            # print(lower, upper)\n            if self.is_shipped(mid, weights, D):\n                upper = mid\n            else:\n                lower = mid\n        \n        if lower == upper or self.is_shipped(lower, weights, D):\n            return lower\n        else:\n            return upper\n                \n    def is_shipped(self, cap, weights, D):\n        tmp = 0\n        count = 1\n        for i in range(len(weights)):\n            tmp += weights[i]\n            if tmp == cap:\n                count += 1\n                tmp = 0\n            elif (tmp > cap):\n                count += 1\n                tmp = weights[i]\n        return count <= D", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        def feasible(capacity):\n            days = 1\n            total = 0\n            for i in range(len(weights)):\n                total += weights[i]\n                if total > capacity:\n                    days += 1\n                    total = weights[i]\n                if days > D:\n                    return False\n            return True\n    \n        left, right = max(weights), sum(weights)\n        while left < right:\n            mid = left + (right - left)//2\n            if feasible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        retval = sum(weights)\n        while left<=right:\n            mid = left + (right-left)//2\n            temp,count = 0,1\n            for i in range(len(weights)):\n                temp+=weights[i]\n                if temp>mid:\n                    temp = weights[i]\n                    count+=1\n                elif temp==mid:\n                    temp = 0\n                    count+=1\n            if count>D:\n                left = mid+1\n            else:\n                retval = mid\n                right = mid-1\n        return retval\n", "class Solution:\n    def isValidCapacity(self, weights, D, capacity):\n        totalDays = 1\n        i = 0\n        runningSum = 0\n\n        for i in range(len(weights)):\n            if runningSum + weights[i] > capacity:\n                runningSum = weights[i]\n                totalDays += 1\n            else:\n                runningSum += weights[i]\n\n        return totalDays <= D\n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        low = max(weights)\n        high = sum(weights)\n\n        while low < high:\n            mid = (low + high) // 2\n\n            if self.isValidCapacity(weights, D, mid):\n                high = mid\n            else:\n                low = mid + 1\n\n        return low\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def can_ship(x):\n            cnt = 1\n            curr = 0\n            for w in weights:\n                if w > x:\n                    return False\n                \n                if curr + w > x:\n                    curr = w\n                    cnt += 1\n                else:\n                    curr += w\n                    \n                if cnt > D:\n                    return False\n                \n            return cnt <= D\n        \n        \n        left, right = 1, sum(weights)\n        while left < right:\n            mid = (right - left) // 2 + left\n            \n            if can_ship(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.condition(mid, weights) <= D:\n                right = mid\n            else:\n                left = mid+1\n        return left\n    \n    def condition(self, k, weights):\n        d = 0\n        cur_weight = 0\n        for weight in weights:\n            if cur_weight + weight == k:\n                d += 1\n                cur_weight = 0\n            elif cur_weight + weight > k:\n                d += 1\n                cur_weight = weight\n            else:\n                cur_weight += weight\n        return d+1 if cur_weight > 0 else d", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        total = sum(weights)\n        maxW = max(weights)\n        low = total//D\n        high = low + maxW\n        \n        def isok(weights, D, cap):\n            curr = cap\n            count = 1\n            for w in weights:\n                if w > cap:\n                    return False\n                if curr - w < 0:\n                    count += 1\n                    curr = cap - w\n                else:\n                    curr -= w\n            return count <= D\n        \n        while low != high:\n            mid = (low + high)//2\n            if isok(weights, D, mid):\n                high = mid\n            else:\n                low = mid+1\n        return low", "class Solution:\n    def numD(self,arr,n):\n        count=0\n        ans=0\n        for i in range(len(arr)):\n            count+=arr[i]\n            if count>n:\n                ans+=1\n                count=arr[i]\n        return ans+1\n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l=-1\n        r=25000000\n        for i in range(len(weights)):\n            if weights[i]>l:\n                l=weights[i]\n            #r+=weights[i]\n        \n        while l<=r:\n            mid = (l+r)//2\n            if self.numD(weights,mid)<=D:\n                r=mid-1\n            elif self.numD(weights,mid)>D:\n                l=mid+1\n            \n        return l\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        # do a binary search\n        # return has to do with weights\n        # so initialize right = sum(weights)\n        # a ship that can carry everything\n        \n        left = max(weights)\n        right = sum(weights) # this ship over-carries for sure\n        \n        while left < right:\n            # keep track of days\n            # if we ship all packages and days too little, it means\n            # we can afford to decrease our ship-capacity\n            # which means right=mid\n            \n            # else if days too much,\n            # we must increase our ship-capacity\n            # so left = mid\n            \n            # mid is our current ship capacity\n            \n\n            mid = (left+right) // 2\n            \n            days_needed = 1\n            cargo = 0\n            \n            for w in weights:\n                if cargo + w > mid:\n                    # cannot fit this next package to current cargo\n                    days_needed += 1\n                    cargo = w\n                else:\n                    # can fit\n                    cargo += w\n\n            \n            if days_needed > D:\n                # this means it must be greater than mid, for sure\n                left = mid + 1\n            else:\n                right = mid\n                \n            \n        return left", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = max(weights)\n        r = sum(weights)\n        length = len(weights)\n        while l <= r:\n            mid = l + (r-l)//2\n            cur = 0\n            toD = 1\n            \n            for i in range(length):\n                if cur + weights[i] > mid:\n                    toD +=1\n                    cur= 0\n                cur+=weights[i]\n            if toD > D:\n                l = mid + 1\n            else:\n                r = mid-1\n        return l\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            if self.condition(mid, weights) <= D:\n                right = mid\n            else:\n                left = mid+1\n        return left\n    \n    def condition(self, k, weights):\n        d = 0\n        cur_weight = 0\n        for weight in weights:\n            if cur_weight + weight == k:\n                d += 1\n                cur_weight = 0\n            elif cur_weight + weight > k:\n                d += 1\n                cur_weight = weight\n            else:\n                cur_weight += weight\n        return d+1 if cur_weight > 0 else d\n        '''def count_days(k, w):\n            curr_wt = 0\n            count = 0\n            for x in weights:\n                if curr_wt+x > k:\n                    count = count+1\n                    cur_wt = x\n                elif curr_wt+x==k:\n                    count=count+1\n                    curr_wt = 0\n                else:\n                    curr_wt = curr_wt+x\n            if curr_wt > 0: return count+1\n            else: return count\n                \n        \n        l = max(weights)\n        r = sum(weights)\n        while l<r:\n            mid = l+((r-l)//2)\n            if count_days(mid, weights) <= D:\n                r = mid\n            else:\n                l = mid+1\n        return l'''\n        \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        lo = max(weights)\n        hi = sum(weights)\n        n = len(weights)\n        \n        while lo<hi:\n            guess = lo+(hi-lo)//2\n            \n            guessDays = 1\n            currLoad = 0\n            for i in range(n):\n                if currLoad + weights[i]>guess:\n                    currLoad = 0\n                    guessDays+=1\n                \n                currLoad+=weights[i]\n            \n            if guessDays<=D:\n                hi = guess\n            else:\n                lo = guess+1\n                \n                \n        \n        return lo\n                    \n                    \n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        \n        def __can(capacity):\n            days = 0\n            partial_sum = 0\n            for i in range(len(weights)):\n                if partial_sum + weights[i] > capacity:\n                    partial_sum = 0\n                    days += 1\n                \n                partial_sum += weights[i]\n            \n            days += 1\n                \n            return days <= D\n        \n        \n        lo, hi = max(weights), sum(weights)\n        \n        while lo + 1 < hi:\n            \n            mid = (lo + hi) // 2\n            \n            if __can(mid) == True:\n                hi = mid\n            else:\n                lo = mid\n        \n        return lo if __can(lo) == True else hi\n", "from collections import defaultdict\nclass Solution:\n     def canShipWithinDays(self, weights: List[int], D: int, maxWeight: int) -> bool:\n        if max(weights) > maxWeight:\n            return False\n        \n        lswt = 0\n        nD = 1\n        for w in weights:\n            if lswt + w <= maxWeight:\n                lswt += w\n            else:\n                nD += 1\n                lswt = w\n        return nD <= D\n    \n     def shipWithinDays(self, weights: List[int], D: int) -> int:\n        # maxweight = sum(weights)\n        minweight = max(weights)\n        maxweight = minweight * len(weights) / D\n        while maxweight > minweight + 1:\n            mw = (maxweight + minweight) // 2 \n            if self.canShipWithinDays(weights, D, mw):\n                maxweight = mw\n            else:\n                minweight = mw\n        \n        if self.canShipWithinDays(weights, D, minweight):\n            return int(minweight)\n        else:\n            return int(maxweight)", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l, h = max(weights), sum(weights)\n        total = h\n        \n        while l <= h:\n            m = (l + h) // 2\n            days, count, t = D, 0, 0\n            for w in weights:\n                if days == 0:\n                    break\n                if count + w > m:\n                    count = w\n                    days -= 1\n                else:\n                    count += w\n                t += w\n            \n            if t == total and days > 0:\n                h = m - 1\n            else:\n                l = m + 1\n        return l", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n      l, r = max(weights), sum(weights)\n      \n      while l + 1 < r:\n        mid = (l + r) // 2\n        \n        if self.calculateNumberOfDays(weights, mid) > D:\n          l = mid\n        else:\n          r = mid\n      if self.calculateNumberOfDays(weights, l) <= D:\n        return l\n      else:\n        return r\n    \n    def calculateNumberOfDays(self, weights, K):\n      num_of_days = 0\n      _sum = 0\n      for i in range(len(weights)):\n        if _sum + weights[i] > K:\n          num_of_days += 1\n          _sum = weights[i]\n        else:\n          _sum += weights[i]\n      if _sum:\n        num_of_days += 1\n      return num_of_days\n    \n    \n    \n    # // 3,2,2,4,1,4\n    # l = 1, r = 16, m = 8 -> 1 + 1 + 1 = 3\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n    \n    # search space\n    # MIN (LEFT) has to be at least the largest weight of the packages, otherwise boat cannot carry it\n    # MAX (RIGHT) is the sum of all packages, since boat can carry all of it in ONE day\n        left = 0\n        right = 0\n        for i in range(len(weights)):\n            left = max(weights[i], left)\n            right += weights[i]\n\n        while left < right:\n            mid = (left+right)//2\n\n            if self.greedy_match(mid, weights, D):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    def greedy_match(self, boat_weight, weights, days):\n        cur_days = 1\n        cur_weight = 0\n        for i in range(len(weights)):\n            if cur_weight + weights[i] > boat_weight:\n                cur_weight = 0\n                cur_days += 1\n                if cur_days > days:\n                    return False\n            cur_weight += weights[i]\n        return True\n", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        weights_sum = sum(weights)\n        \n        def necessary_days(capacity):\n            days = 0\n            ws = 0\n            for w in weights:\n                if ws + w <= capacity:\n                    ws += w\n                else:\n                    days += 1\n                    ws = w\n                    \n            return days + 1\n        \n        low = max(weights)\n        high = weights_sum\n        capacity_guess = (low + high) // 2\n        \n        while low <= high:\n            d = necessary_days(capacity_guess)\n            \n            if d <= D:\n                high = capacity_guess - 1\n            else:\n                low = capacity_guess + 1\n                \n            capacity_guess = (low + high) // 2\n            \n        return low\n", "class Solution:\n    def check(self, weights, limit):\n        cur = 0\n        count = 1\n        for i in range(len(weights)):\n            if cur + weights[i] > limit:\n                count += 1\n                cur = weights[i]\n            else:\n                cur += weights[i]\n        \n        return count\n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = max(weights)\n        r = sum(weights)\n        ans = 1\n        \n        while l <= r:\n            mid =  int((r + l) / 2)\n            if self.check(weights, mid) <= D:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans", "class Solution:\n    def check(self, weights, limit):\n        cur = 0\n        count = 1\n        for i in range(len(weights)):\n            if cur + weights[i] > limit:\n                count += 1\n                cur = weights[i]\n            else:\n                cur += weights[i]\n        \n        return count\n    \n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        l = max(weights)\n        r = sum(weights)\n        ans = 1\n        \n        while l <= r:\n            mid = l + int((r - l) / 2)\n            if self.check(weights, mid) <= D:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return ans", "class Solution:\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\n        left = max(weights)\n        right = sum(weights)\n        while left < right:\n            mid = left + (right - left) // 2\n            buckets = 1\n            count = 0\n            for w in weights:\n                if count + w <= mid:\n                    count += w\n                else:\n                    buckets += 1\n                    count = w\n            if buckets > D:\n                left = mid + 1\n            else:\n                right = mid\n        return left"]
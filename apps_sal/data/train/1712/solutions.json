["def puzzle_solver(pieces, w, h):\n    memo, D, result = {}, {None: (None, None)}, [[None]*w for _ in range(h)]\n    \n    for (a, b), (c, d), id in pieces:\n        memo[(a, b, c)] = id\n        D[id] = (c, d)\n    \n    for i in range(h):\n        for j in range(w):\n            a, b = D[result[i-1][j]]\n            _, c = D[result[i][j-1]]\n            result[i][j] = memo[(a, b, c)]\n    \n    return list(map(tuple, result))", "from collections import defaultdict\n\n\ndef puzzle_solver(pieces, h, w):\n    pool   = defaultdict(lambda:defaultdict(int))\n    pieces = [ Piece(a,b,i,pool) for a,b,i in pieces ]\n    return next(p for p in pieces if p.isTopLeft()).build()\n\n\nclass Piece(object):\n\n    def __init__(self,a,b,i,pool):\n        self.U,self.D,self.L,self.R = a,b,*zip(a,b)\n        self.id,self.pool = i,pool\n        for d,r in zip('UDLR','DURL'):\n            k = getattr(self,d)\n            if k!=(None,None): pool[k][r] = self\n    \n    def isTopLeft(self): return self.U == self.L == (None,None)\n    def build(self):     return [ tuple(pp.id for pp in p._iter('R')) for p in self._iter('D')]\n        \n    def _iter(piece,d):\n        while piece:\n            yield piece\n            piece = piece.pool[getattr(piece,d)][d]", "def puzzle_solver(pieces, width, height):\n    solution,corner,d3={},{},{}\n    for y in range(height+1):corner[0,y]=None\n    for x in range(width+1): corner[x,0]=None\n    for (a,b),(c,d),e in pieces:d3[a,b,c]=(d,e)\n    for y in range(height):\n        for x in range(width):\n            corner[x+1,y+1],solution[x,y]=d3[corner[x,y],corner[x+1,y],corner[x,y+1]]\n    return [tuple(solution[x,y] for x in range(width)) for y in range(height)]", "def puzzle_solver(puzzle, w, h):\n    sol = {}\n    res = []\n    p = {}\n    for pc in puzzle:\n        p[pc[0],pc[1][0]] = pc\n    for j in range(h):\n        rl = []\n        for i in range(w):\n            if i == 0:\n                lu, ld = None, None\n            else:\n                lu = sol[i-1,j][0][1]\n                ld = sol[i-1,j][1][1]\n            if j == 0:\n                ru = None\n            else:\n                ru = sol[i,j-1][1][1]\n            pc = p[(lu, ru), ld]\n            sol[i,j] = pc\n            rl.append(pc[2])\n        res.append(tuple(rl))\n    return res", "from collections import defaultdict, namedtuple\n\ndef puzzle_solver(pieces, width, height):\n    \n    # Lookup tree: top_left -> top_right -> bottom_left -> (bottom_right, id)\n    catalogue = defaultdict(lambda: defaultdict(dict))\n    \n    rows, columns = 0, 0\n    for piece in pieces:\n        (top_left, top_right), (bottom_left, bottom_right), id = piece\n        catalogue[top_left][top_right][bottom_left] = bottom_right, id\n        if None is top_left is bottom_left:\n            rows += 1\n        if None is top_left is top_right:\n            columns += 1\n    \n    puzzle = tuple([None] * columns for _ in range(rows))\n    \n    # top left corner\n    puzzle[0][0] = catalogue[None][None][None]\n    \n    # top row\n    for col in range(1, columns):\n        puzzle[0][col] = catalogue[None][None][puzzle[0][col - 1][0]]\n    \n    # left column\n    for row in range(1, rows):\n        puzzle[row][0] = catalogue[None][puzzle[row - 1][0][0]][None]\n    \n    # body\n    for row in range(1, rows):\n        for col in range(1, columns):\n            top_left = puzzle[row - 1][col - 1][0]\n            top_right = puzzle[row - 1][col][0]\n            bottom_left = puzzle[row][col - 1][0]\n            puzzle[row][col] = catalogue[top_left][top_right][bottom_left]\n    \n    return [tuple(piece[1] for piece in row) for row in puzzle]", "def puzzle_solver(pieces, width, height):\n    l,u,p={},{},{}\n    s=[]\n    r=[]\n    for ((a,b),(c,d),e) in pieces:\n        p[e]=(a,b),(c,d)\n        l[(a,c)]=e\n        u[(a,b)]=e\n        if a==b==c==None:r+=[e]\n    while 1:\n        (a,b),(c,d)=p[r[-1]]\n        if b==d==None:\n            s+=[tuple(r)]\n            r=[]\n            if c==None:\n                break\n            (w,x),(y,z)=p[s[-1][0]]\n            r+=[u[(y,z)]]\n        else:\n            n=l[(b,d)]\n            r+=[n]\n    return s", "from enum import Enum\n\nclass Positions(Enum):\n    UPPER_LEFT = 1\n    UPPER_RIGTHT = 2\n    BOTTOM_LEFT = 3\n    BOTTOM_RIGTHT = 4\n\nclass PuzzlePiece:\n    def __init__(self, tup):\n        self.values = { Positions.UPPER_LEFT: tup[0][0], Positions.UPPER_RIGTHT: tup[0][1], \n                        Positions.BOTTOM_LEFT: tup[1][0], Positions.BOTTOM_RIGTHT: tup[1][1] }\n        self.id = tup[2]\n        self.corner = None\n        values_lst = [value for position, value in list(self.values.items())]\n        corners_positions_with_values = { Positions.UPPER_LEFT: Positions.BOTTOM_RIGTHT, Positions.UPPER_RIGTHT: Positions.BOTTOM_LEFT, \n                                          Positions.BOTTOM_LEFT: Positions.UPPER_RIGTHT, Positions.BOTTOM_RIGTHT: Positions.UPPER_LEFT  }\n        if 3 == values_lst.count(None):\n            for position in corners_positions_with_values:\n                if self.values[position] is not None:\n                    self.corner = corners_positions_with_values[position]\n            \nclass Puzzle:        \n    def __init__(self, pieces):\n        self.cornaners = dict()\n        self.piece_map = dict()\n        for piece in pieces:\n            piece = PuzzlePiece(piece)\n            if piece.corner is not None:\n                self.cornaners[piece.corner] = piece\n            for position, value in list(piece.values.items()):\n                if value is not None:\n                    if value not in self.piece_map:\n                        self.piece_map[value] = { Positions.UPPER_LEFT: None, Positions.UPPER_RIGTHT: None, \n                                                  Positions.BOTTOM_LEFT: None, Positions.BOTTOM_RIGTHT: None }\n                    self.piece_map[value][position] = piece\n    \n    def solve(self):\n        res = [[self.cornaners[Positions.UPPER_LEFT]]]\n        while True:\n            if res[-1][-1].values[Positions.BOTTOM_RIGTHT] is not None:\n                res[-1].append(self.piece_map[res[-1][-1].values[Positions.BOTTOM_RIGTHT]][Positions.BOTTOM_LEFT])\n            elif res[-1][0].values[Positions.BOTTOM_RIGTHT] is not None:\n                res.append([])\n                res[-1].append(self.piece_map[res[-2][0].values[Positions.BOTTOM_RIGTHT]][Positions.UPPER_RIGTHT])\n            elif res[-1][-1].values[Positions.UPPER_RIGTHT] is not None:\n                res[-1].append(self.piece_map[res[-1][-1].values[Positions.UPPER_RIGTHT]][Positions.UPPER_LEFT])\n            else:\n                break\n        res = [tuple(piece.id for piece in row) for row in res]\n        return res\n            \ndef puzzle_solver(pieces, width, height):\n    puzzle = Puzzle(pieces)\n    return puzzle.solve()\n", "def puzzle_solver(li, width, height):\n    \n    # save pieces of puzzle for later use\n    id_number = {i[:2]: i[2] for i in li}\n    li, puzzle = list(id_number.keys()), [[() for _ in range(width)] for _ in range(height)] \n    left, right, top, bottom, rest = [], [], [], [], []\n    \n    # set fixed corners and store sub grid to their correct place\n    for grid in li:\n        nones, nn = sum(i.count(None) for i in grid), (None, None)\n        if nones == 3:\n            x, y = [(-1, -1), (-1, 0), (0, -1), (0, 0)][next(i for i, j in enumerate(sum(grid, ())) if j is not None)]\n            puzzle[x][y] = grid\n        elif nones == 2:\n            use = bottom if grid[1] == nn else top if grid[0] == nn else left if (grid[0][0], grid[1][0]) == nn else right\n            use.append(grid)\n        else:\n            rest.append(grid)\n    \n    # function to set all sidelines\n    def set_row(line, start, i, j, o, p, till):\n        lookup = {k[o][p]: k for k in line}\n        decide = lambda x: {(1, 1, 1, 0): (0, x), (0, 1, 0, 0): (-1, x), (1, 1, 0, 1): (x, 0)}.get((i, j, o, p), (x, -1))\n    \n        for k in range(1, till - 1):\n            x, y = decide(k)\n            puzzle[x][y] = lookup[start[i][j]]\n            start = puzzle[x][y]\n    \n    # set all side lines\n    for line, start, i, j, o, p, till in [(top, puzzle[0][0], 1, 1, 1, 0, width),\n                                          (bottom, puzzle[-1][0], 0, 1, 0, 0, width),\n                                          (left, puzzle[0][0], 1, 1, 0, 1, height),\n                                          (right, puzzle[0][-1], 1, 0, 0, 0, height)]:\n        set_row(line, start, i, j, o, p, till)\n    \n    #now, all easy set rest of puzzle\n    prev = puzzle[0]\n    lookup = {k[0]: k for k in rest}\n    for k in range(1, height - 1):\n        for l in range(1, width - 1):\n            puzzle[k][l] = lookup[prev[l][1]]\n        prev = puzzle[k]\n  \n    return [tuple([id_number[j] for j in i]) for i in puzzle]", "def puzzle_solver(pieces, width, height):\n    xs, ys, edge = list(range(width)), list(range(height)), ((None, None), (None, None))\n    solution_grid = [[None for _ in xs] for _ in ys]\n    id_to_piece = {p[2]: (p[0], p[1]) for p in pieces}\n    code_to_id = {encode(p[0], p[1][0]): id for id, p in list(id_to_piece.items())}\n    for y in ys:\n        for x in xs:\n            top_piece = id_to_piece[solution_grid[y-1][x]] if y > 0 else edge\n            left_piece = id_to_piece[solution_grid[y][x-1]] if x > 0 else edge\n            solution_grid[y][x] = code_to_id[encode(top_piece[1], left_piece[1][1])]\n    return [tuple([solution_grid[y][x] for x in xs]) for y in ys]\n\ndef encode(top, left_bottom):\n    return f\"{top},{left_bottom}\"\n        \n", "def puzzle_solver(pieces, width, height):\n    xs, ys, edge = list(range(width)), list(range(height)), ((None, None), (None, None))\n    solution_grid = [[None for _ in xs] for _ in ys]\n    id_to_piece = {p[2]: (p[0], p[1]) for p in pieces}\n    code_to_id = {encode(p[0], p[1][0]): id for id, p in list(id_to_piece.items())}\n    for y in ys:\n        for x in xs:\n            top_piece = id_to_piece[solution_grid[y-1][x]] if y > 0 else edge\n            left_piece = id_to_piece[solution_grid[y][x-1]] if x > 0 else edge\n            target_code = encode(top_piece[1], left_piece[1][1])\n            target_id = code_to_id[target_code]\n            solution_grid[y][x] = target_id\n    return [tuple([solution_grid[y][x] for x in xs]) for y in ys]\n\ndef encode(top, left_bottom):\n    return f\"{top},{left_bottom}\"\n        \n"]
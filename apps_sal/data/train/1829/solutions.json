["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.cnt=0\n        def helper(root,maxm):\n            if not root:\n                return\n            if root.val>=maxm:\n                self.cnt+=1\n                maxm=root.val\n            if root.left:\n                helper(root.left,maxm)\n            if root.right:\n                helper(root.right,maxm)\n        maxm=root.val\n        helper(root,maxm)\n        return self.cnt", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def preorder(self, root, max_so_far, ctr):\n        if not root:\n            return\n        if root.val>=max_so_far:\n            max_so_far = root.val\n            ctr[0] += 1\n        self.preorder(root.left, max_so_far, ctr)\n        self.preorder(root.right, max_so_far, ctr)\n        \n    def goodNodes(self, root: TreeNode) -> int:\n        max_so_far = -111111111111111\n        ctr = [0]\n        self.preorder(root, max_so_far, ctr)\n        return ctr[0]\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper_rec(self,root,tempMax):\n        if root is None:\n            return\n        \n        if root.val >= tempMax:\n            self.count += 1\n            tempMax=max(root.val,tempMax)\n        self.helper_rec(root.left,tempMax)\n        self.helper_rec(root.right, tempMax)\n\n    def goodNodes(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n        #self.tempMax=0\n        self.count=0\n        self.helper_rec(root,root.val)\n        return self.count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        #preorder traverse, keeping track of the max for that path\n        #if X is >= the max on the path, numGoodNodes += 1\n        \n        stack = [(root, root.val)]\n        count = 0\n        \n        while stack:\n            cur, greatest = stack.pop()\n            if cur:\n                if cur.val >= greatest:\n                    count += 1\n\n                if cur.right:\n                    stack.append((cur.right, max(cur.right.val, greatest)))\n                if cur.left:\n                    stack.append((cur.left, max(cur.left.val, greatest)))\n                       \n        return count\n\n                       \n\n                       \n\n\n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    '''\n    - as we traverse down, we measure the maxSoFar and compare current \n    node with that\n    - current node is good if >= maxSoFar, so count as one\n    - can traverse recursively\n    '''\n    def goodNodes(self, root: TreeNode) -> int:\n        def traverse(node, maxSoFar=float(\\\"-inf\\\")):\n            # check base case (null node)\n            if not node:\n                return 0\n            \n            # process node\n            count = 1 if node.val >= maxSoFar else 0\n            maxSoFar = max(maxSoFar, node.val)\n            \n            # traverse children, adding count along the way\n            return traverse(node.left, maxSoFar) + traverse(node.right, maxSoFar) + count\n            \n        return traverse(root)\n        \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def traverse(self, root, currentMax):\n        if root != None:\n            if currentMax <= root.val:\n                self.count += 1\n            self.traverse(root.left, max(currentMax, root.val))\n            self.traverse(root.right, max(currentMax, root.val))\n    \n    def goodNodes(self, root: TreeNode) -> int:\n        self.count = 0\n        self.traverse(root, float('-inf'));\n        return self.count\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res = [0]\n        \n        def dfs(node, m):\n            if not node: return\n            if node.val >= m:\n                res[0] += 1\n                \n            dfs(node.left, max(node.val, m))\n            dfs(node.right, max(node.val, m))\n            \n        dfs(root, root.val)\n        return res[0]\n                \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode, m = -10**4) -> int:\n        \n        return (self.goodNodes(root.left, max(m, root.val))+self.goodNodes(root.right, max(m, root.val))+(root.val>=m)) if root else 0\n    \n           \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        \n        def helper(root, max_sofar):\n            \n            if not root:\n                return 0\n            \n            total = 0\n            if root.val >= max_sofar:\n                total += 1\n                \n            total += helper(root.left, max(max_sofar, root.val))\n            total += helper(root.right, max(max_sofar, root.val))\n            \n            return total\n        \n        return helper(root, float(\\\"-inf\\\"))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res = 0\n        q = collections.deque([(root, root.val)])\n        while q:\n            node, cur_max = q.popleft()\n            if node.val >= cur_max:\n                res += 1\n            for child in filter(bool, (node.left, node.right)):\n                q.append((child, max(child.val, cur_max)))\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.total_count = 0\n        \n    def goodNodes(self, root: TreeNode) -> int:\n        return self.goodNodesHelper(root, [])\n        \n    def goodNodesHelper(self, root, max_first_stack):\n        if not root:\n            return \n        elif max_first_stack == []:\n            max_first_stack.append(root.val)\n            self.total_count += 1\n\n        elif max_first_stack[0] <= root.val:\n            max_first_stack = [root.val] + max_first_stack \n            self.total_count += 1\n        else:\n            max_first_stack = max_first_stack + [root.val]\n        self.goodNodesHelper(root.left, max_first_stack)\n        self.goodNodesHelper(root.right, max_first_stack)\n        return self.total_count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        if root == None:\n            return 0\n        self.count = 0\n        self._goodNodes(root, root.val)\n        return self.count\n        \n    def _goodNodes(self, curNode, curGreatest):\n        if curNode == None:\n            return\n        if curNode.val >= curGreatest:\n            self.count += 1\n        \n        self._goodNodes(curNode.left, max(curNode.val, curGreatest))\n        self._goodNodes(curNode.right, max(curNode.val, curGreatest))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.ans = 0\n        self.traverse(root, root.val)\n        return self.ans\n    \n    def traverse(self, root, so_far):\n        if root:\n            if root.val >= so_far:\n                self.ans += 1\n                so_far = root.val\n            self.traverse(root.left, so_far)\n            self.traverse(root.right, so_far)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.count = 0\n        self.dfs(root, float('-inf'))\n        return self.count\n    \n    def dfs(self, root, parent):\n        if not root:\n            return 0\n        \n        if root.val >= parent:\n            self.count += 1\n        \n        l = self.dfs(root.left, max(root.val, parent))\n\n        r = self.dfs(root.right, max(root.val, parent))\n        \n        return l+r\n            \n                \n                \n            \n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        sumNode = []\n        self.goodNode(root, -234627, sumNode)\n        return len(sumNode)\n    \n    def goodNode(self, root, maxSoFar, sumNode):\n        if root is None:\n            return\n        \n        #print(\\\"MaxSoFar\\\", maxSoFar)\n        #print(\\\"Root val\\\", root.val)\n        print((root.val))\n        \n        if root.val >= maxSoFar:\n            #print(\\\"Added\\\", root.val)\n            sumNode.append(root.val)\n            #print(sumNode)\n        \n        maxSoFarNow = max(maxSoFar, root.val)\n        \n        self.goodNode(root.left, maxSoFarNow, sumNode)\n        self.goodNode(root.right, maxSoFarNow, sumNode)\n        \n        \n        \n        \n        \n\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res=[]\n        cnt=0\n        def dfs(node):\n            nonlocal cnt\n            res.append(node.val)\n            if res[-1]==max(res):\n                cnt+=1\n            if node.left:\n                dfs(node.left)\n            if node.right:\n                dfs(node.right)\n            if res:\n                res.pop()\n        dfs(root)\n        return cnt", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.ans = 0\n        def tra(node, maxtillnow):\n            if node:\n                if node.val>=maxtillnow:\n                    self.ans +=1\n                tra(node.left, max(maxtillnow, node.val))\n                tra(node.right, max(maxtillnow, node.val))\n            \n            \n        tra(root, float('-inf'))\n        \n        return self.ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.count=0\n        def helper(root,maxVal):\n            if root is None:\n                return \n            if root.val>=maxVal:\n                maxVal=root.val\n                self.count+=1\n            helper(root.left,maxVal)\n            helper(root.right,maxVal)\n        helper(root,root.val)\n        return self.count\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def traverse(self, node, max_val):\n        if node.val >= max_val:\n            self.traverse_count += 1\n        max_val = max(max_val, node.val)\n        if node.left: self.traverse(node.left, max_val)\n        if node.right: self.traverse(node.right, max_val)\n\n    def goodNodes(self, root: TreeNode) -> int:\n        if root:\n            self.traverse_count = 0\n            self.traverse(root, float('-inf'))\n            return self.traverse_count\n        return 0", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        count = 0\n        def dfs(node,prevVal):\n            nonlocal count\n            if node:\n                maxPrev = max(node.val,prevVal)\n                if node.val >= prevVal:\n                    count += 1\n                dfs(node.left,maxPrev)\n                dfs(node.right,maxPrev)\n        dfs(root,root.val)\n        return count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.count=0\n        def helper(root,maxVal):\n            if root is None:\n                return \n            if root.val>=maxVal:\n                maxVal=root.val\n                self.count+=1\n            helper(root.left,maxVal)\n            helper(root.right,maxVal)\n        helper(root,-11111)\n        return self.count\n#     def dfs(root, max_till_now):\n#             if not root:\n#                 return\n            \n#             if root.val >= max_till_now:\n#                 max_till_now = root.val\n#                 self.good_nodes += 1\n                \n#             dfs(root.left, max_till_now)\n#             dfs(root.right, max_till_now)\n        \n#         dfs(root,-10001)\n#         return self.good_nodes\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        int_min = -10000000\n        ans = self.solve(root, int_min)\n        return ans\n        \n    def solve(self, root: TreeNode, int_min: int) -> int:\n        \n        if(root==None):\n            return 0\n        if(root.val < int_min):\n             return self.solve(root.left, int_min) + self.solve(root.right, int_min)\n        else:\n             return self.solve(root.left, root.val) + self.solve(root.right, root.val)+1\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    count=0\n    def goodNodes(self, root: TreeNode) -> int:\n        current=root.val\n        \n        path=[]\n        path.append(float('-inf'))\n        \\\"\\\"\\\" append min val in to path and check if root val gretaer or == to max(path) if true increase count by 1 and add root to path.\n        recursively call root.left and root.right and pop the top element)\\\"\\\"\\\"\n        def good(path,root):\n            if root is None:\n                return\n            if root.val>=max(path):\n                self.count=self.count+1\n            path.append(root.val)\n                #print(root.val)\n            good(path,root.right)\n            good(path,root.left)\n            path.pop()\n            return self.count\n        #print(self.count)\n        return good(path,root)\n            \n                          \n            \n                    \n                          \n            \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return self.count_good_nodes(root, root.val)\n    \n    def count_good_nodes(self, root: TreeNode, highest_val: int) -> int:\n        current_highest = highest_val\n        total = 0\n        \n        if root.val >= current_highest:\n            total += 1\n            current_highest = root.val\n\n        if root.left:\n            total += self.count_good_nodes(root.left, current_highest)\n        if root.right:\n            total += self.count_good_nodes(root.right, current_highest)\n        \n        return total", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        if root is None:\n            return 0\n        \n        out = [0]\n        #maxValue = -float('inf')\n        \n        def _recHelper(curr,maxValue):\n            if curr is None:\n                return\n            \n            if curr.val >= maxValue:\n                out[0] += 1\n            \n            _recHelper(curr.left, max(curr.val, maxValue))\n            _recHelper(curr.right, max(curr.val, maxValue))\n        \n        _recHelper(root, -float('inf'))\n        \n        return out[0]\n    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def traverse(n, maxval):\n            if not n: return 0\n            visible = 1 if n.val >= maxval else 0\n            maxval = max(maxval, n.val)\n            return traverse(n.left, maxval) + visible + traverse(n.right, maxval)\n        \n        return traverse(root, float(\\\"-inf\\\"))\n            \n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        \n        def dfs(node,m):\n            if node==None:\n                return 0\n            value =1 if node.val>=m else 0\n            m=max(m,node.val)\n            return dfs(node.right,m)+dfs(node.left,m)+value\n        return dfs(root,-float(inf))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.count=0\n        def helper(root,maxVal):\n            if root is None:\n                return \n            if root.val>=maxVal:\n                maxVal=root.val\n                self.count+=1\n            helper(root.left,maxVal)\n            helper(root.right,maxVal)\n        helper(root,-10001)\n        return self.count\n#     def dfs(root, max_till_now):\n#             if not root:\n#                 return\n            \n#             if root.val >= max_till_now:\n#                 max_till_now = root.val\n#                 self.good_nodes += 1\n                \n#             dfs(root.left, max_till_now)\n#             dfs(root.right, max_till_now)\n        \n#         dfs(root,-10001)\n#         return self.good_nodes\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        result = 0\n        def findNodes(root, path):\n            nonlocal result\n            if not root:\n                return\n            path = [*path, root.val] \n            if max(path) <= root.val:\n                result += 1\n            findNodes(root.left, path)\n            findNodes(root.right, path) \n        findNodes(root, [])\n        return result\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def c(r,v):\n            if not r:\n                return 0\n            mx = max(r.val,v)\n            \n            return (r.val >= mx) + c(r.left,mx) + c(r.right,mx)\n        \n        return c(root,root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return self.dfs(root, 0, float('-inf'))\n    \n    def dfs(self, root, good, max_val): \n        if root == None: \n            return good \n        if root.val >= max_val: \n            good += 1 \n            max_val = root.val \n        good = self.dfs(root.left, good, max_val)\n        good = self.dfs(root.right, good, max_val)\n        return good\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        if root is None:\n            return 0\n       \n        self.count = 0\n        self.dfs(root, root.val)\n        return self.count\n    def dfs(self, root, max_num):\n        if root is None:\n            return\n        if root.val >= max_num:\n            max_num = root.val\n            self.count += 1\n        self.dfs(root.left, max_num)\n        self.dfs(root.right, max_num)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def _goodNodes(self, root: TreeNode, maxSeen: int) -> int:\n        print(f\\\"Node: {root.val}\\\")\n        if not root:\n            print(\\\"return 0\\\")\n            return 0\n        this = 1 if root.val >= maxSeen else 0\n        left = 0\n        right = 0\n        if root.left:\n            left = self._goodNodes(root.left, max(root.val, maxSeen))\n        \n        # right\n        if root.right:\n            right = self._goodNodes(root.right, max(root.val, maxSeen))\n        \n        return this + left + right\n    \n    def goodNodes(self, root: TreeNode) -> int:\n        return self._goodNodes(root, root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        queue = collections.deque()\n        queue.append([root,-float('inf')])\n        count = 0\n        while queue:\n            node, pVal = queue.popleft()\n            if node.val >= pVal:\n                count += 1\n                if node.left:\n                    queue.append([node.left, node.val])\n                if node.right:\n                    queue.append([node.right, node.val])\n            else:\n                if node.left:\n                    queue.append([node.left, pVal])\n                if node.right:\n                    queue.append([node.right, pVal])\n        return count\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        \n        beat 19.91%\n        wrong idea --> count # of nodes >= root.val. This is my first try..\n        \n        create a path from root to current node.\n        \n        a good node if all the nodes in the path are smaller than the current node\n        \n        this is a good example:\n        [2,null,4,10,8,null,null,4]\n        \n        \\\"\\\"\\\"\n        \n        # the root nodes is always good node\n        # so it start from 1\n        self.numGoodNodes = 1\n        def dfsVisit(node, path):\n            if node is None:\n                return\n            \n            if path and node.val >= max(path):\n                self.numGoodNodes += 1 \n                \n            dfsVisit(node.left, path + [node.val])\n            dfsVisit(node.right, path + [node.val])\n        \n        dfsVisit(root, [])\n                \n        return self.numGoodNodes\n\n#     def goodNodes(self, root: TreeNode) -> int:\n#         \\\"\\\"\\\"\n#         instead of keep the whole path, keep only the maxVal in the path\n#         \\\"\\\"\\\"\n        \n#         # the root nodes is always good node\n#         # so it start from 1\n#         self.numGoodNodes = 1\n#         def dfsVisit(node, maxVal):\n#             if node is None:\n#                 return\n            \n#             if node.val >= max(path):\n#                 self.numGoodNodes += 1 \n                \n#             dfsVisit(node.left, path + [node.val])\n#             dfsVisit(node.right, path + [node.val])\n        \n#         dfsVisit(root, [])\n                \n#         return self.numGoodNodes", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        count # of nodes >= root.val\n        \n        create a path from root to current node.\n        \n        a good node if all the nodes in the path are smaller than the current node\n        \n        this is a good example:\n        [2,null,4,10,8,null,null,4]\n        \n        \\\"\\\"\\\"\n        \n        # the root nodes is always good node\n        # so it start from 1\n        self.numGoodNodes = 1\n        def dfsVisit(node, path):\n            if node is None:\n                return\n            \n            if len(path) > 0 and node.val >= max(path):\n                self.numGoodNodes += 1 \n                \n            dfsVisit(node.left, path + [node.val])\n            dfsVisit(node.right, path + [node.val])\n        \n        dfsVisit(root, [])\n                \n        return self.numGoodNodes", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n#         def traverse(node: TreeNode, good_threshold: int) -> int:\n#             good_threshold = max(good_threshold, node.val)\n            \n#             left_count = right_count = 0\n            \n#             if node.left is not None:\n#                 left_count = traverse(node.left, good_threshold)\n                \n#             if node.right is not None:\n#                 right_count = traverse(node.right, good_threshold)\n            \n#             return left_count + right_count + (1 if good_threshold <= node.val else 0)\n        \n#         good_count = traverse(root, -10e4)\n        \n#         return good_count\n        queue = deque()\n        TraverseItem = namedtuple('TraverseItem', ['threshold', 'node'])\n        queue.append(TraverseItem(threshold=-10e4, node=root))\n        \n        good_count = 0\n        \n        while len(queue) != 0:\n            n = queue.pop()\n            \n            threshold = max(n.node.val, n.threshold)\n            \n            if n.node.left is not None:\n                queue.append(TraverseItem(threshold=threshold, node=n.node.left))\n            \n            if n.node.right is not None:\n                queue.append(TraverseItem(threshold=threshold, node=n.node.right))\n                \n            if threshold <= n.node.val :\n                good_count = good_count + 1\n        \n        return good_count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n   \n        count = 0 \n        \n        def rootToNode(root,path):\n            \n            nonlocal count\n            \n            if root is None:\n                return\n            \n            path.append(root.val)\n     \n            if(max(path) == root.val):\n                count +=1\n                    \n                    \n            rootToNode(root.left,path.copy())\n            rootToNode(root.right,path.copy())\n            \n        rootToNode(root,[])\n        \n        return count\n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def check(node,val):\n            if not node:\n                return 0\n            if node.val>=val:\n                return 1 + check(node.left,node.val) + check(node.right,node.val)\n            return check(node.left,val) + check(node.right,val)\n        return check(root,root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\ndef order(root, maxi):\n    if root is None:\n        return 0\n    \n    count = 0\n    if root.val >= maxi:\n        count += 1\n        maxi = root.val\n        \n    return count + order(root.left, maxi) + order(root.right, maxi)\n    \n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return order(root, root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def helper(root: TreeNode, maxVal: int, count: List[int]):\n            if not root:\n                return\n            else:\n                if root.val >= maxVal:\n                    count[0] += 1\n    \n                helper(root.left, max(maxVal, root.val), count) \n                helper(root.right, max(maxVal, root.val), count)\n    \n        count = [0]\n        helper(root, -math.inf, count)\n        return count[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.res=0\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        def add(l, n):\n            nl = l.copy()\n            nl.append(n)\n            return nl\n            \n        \n        self.res=0\n        def traverse(node, path):\n            \n            if node is None:\n                return\n            \n            if(node.val>=max(path)):\n                self.res+=1\n                \n            traverse(node.left, add(path, node.val))\n            traverse(node.right, add(path, node.val))\n            \n            \n            \n        traverse(root, [-float('inf')])\n        return self.res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def traverse(self, node, max_val):\n        if node.val >= max_val:\n            self.traverse_count += 1\n        max_val = max(max_val, node.val)\n        if node.left: self.traverse(node.left, max_val)\n        if node.right: self.traverse(node.right, max_val)\n\n    def goodNodes(self, root: TreeNode) -> int:\n        self.traverse_count = 0\n        if root: self.traverse(root, float('-inf'))\n        return self.traverse_count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        visited = set()\n        \n        def countNode(node: TreeNode, maxVal: int) -> int:\n            if not node:\n                return 0\n            \n            if node.val >= maxVal:\n                return 1 + countNode(node.left, node.val) + countNode(node.right, node.val)\n            else:\n                return 0 + countNode(node.left, maxVal) + countNode(node.right, maxVal)\n            \n        return countNode(root, root.val)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        self.result = 0\n        self.check_node(root, root.val)\n        return self.result\n        \n    def check_node(self, node, max_value):\n        if node.val >= max_value:\n            self.result += 1\n        max_value = max(max_value, node.val)\n        if node.left != None:\n            self.check_node(node.left, max_value)\n        if node.right != None:\n            self.check_node(node.right, max_value)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def helper(root, max_val):\n            if not root:\n                return 0\n        \n            ans=0\n            if root.val >= max_val:\n                max_val=root.val\n                ans+=1\n            return ans+helper(root.left, max_val)+helper(root.right, max_val)\n        return helper(root, -float('inf'))\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        traverse_count = 0\n        def traverse(node, max_val):\n            nonlocal traverse_count\n            if node.val >= max_val:\n                traverse_count += 1\n            max_val = max(max_val, node.val)\n            if node.left: traverse(node.left, max_val)\n            if node.right: traverse(node.right, max_val)\n        if root:\n            traverse(root, float('-inf'))\n        return traverse_count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return(self.helper(root))\n    \n    \n    def helper(self,root,maxVal = -9999):\n        total = 0\n        if root.val >= maxVal:\n            total += 1\n            maxVal = root.val\n        if root.left:\n            total += self.helper(root.left,maxVal)\n        if root.right:\n            total += self.helper(root.right,maxVal)\n        \n        return total", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(node, q):\n            if node:\n                res=0\n                print (node.val,\\\" hello \\\",q)\n                if node.val>= q:\n                    res+=1\n                res+=dfs(node.left,max(node.val,q))\n                res+=dfs(node.right,max(node.val,q))\n                return res\n            else: return 0\n\n        \n        return dfs(root,-10001)\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        count = 0\n        stack = [(root, root.val)]\n        \n        while len(stack) > 0:\n            popped = stack.pop()\n            node = popped[0]\n            curMax = popped[1]\n            if node.val >= curMax:\n                count += 1\n            if node.right is not None:\n                stack.append((node.right, max(node.right.val, curMax)))\n            if node.left is not None:\n                stack.append((node.left, max(node.left.val, curMax)))\n        return count\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        return self.countGoodNodes(root, -999999)\n\n    def countGoodNodes(self, node, maxSoFar):\n        if node is None:\n            return 0\n\n        newMax = max(maxSoFar, node.val)\n        return int(node.val >= maxSoFar) + self.countGoodNodes(node.left, newMax) + self.countGoodNodes(node.right, newMax)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        ans = 0\n        q = [(root, float('-inf'))]\n        \n        while q:\n            (curr, maxvals) = q.pop(0)\n            if curr.val >= maxvals:\n                ans += 1\n                maxvals = curr.val\n                \n            if curr.left: q.append((curr.left,maxvals))\n            if curr.right: q.append((curr.right,maxvals))\n        \n        return ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        stack = []\n        ans = [0]\n        \n        def dfs(root):\n            if not stack or root.val >= stack[-1].val:\n                stack.append(root)\n                ans[0] += 1\n            if root.left:\n                dfs(root.left)\n            if root.right:\n                dfs(root.right)\n            if stack and root == stack[-1]:\n                stack.pop()\n        \n        dfs(root)\n        return ans[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self,root,output,count):\n        if(root is None):\n            return \n        flag=False\n        for ele in output:\n            if(ele>root.val):\n                flag=True\n        if(flag==False):\n            count[0]+=1\n        output.append(root.val)\n        self.helper(root.left,output,count)\n        self.helper(root.right,output,count)\n        output.pop()\n    def goodNodes(self, root: TreeNode) -> int:\n        count=[0]\n        output=[]\n        self.helper(root,output,count)\n        return count[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        traverse_count = 0\n        def traverse(node, max_val=float('-inf')):\n            nonlocal traverse_count\n            if not node:\n                return\n            if node.val >= max_val:\n                traverse_count += 1\n            max_val = max(max_val, node.val)\n            traverse(node.left, max_val)\n            traverse(node.right, max_val)\n        traverse(root)\n        return traverse_count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n        maximum = root.val\n        self.count = 0\n        def dfs(node,maximum):\n            if not node:return\n            if node.val >= maximum:\n                self.count += 1\n                maximum = max(maximum,node.val)\n            dfs(node.left,maximum)\n            dfs(node.right,maximum)\n            \n        dfs(root,maximum)\n        return self.count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        \n    \n        \n        def dfs(root,path):\n            \n            if root:\n                indx=bisect.bisect(path,root.val)\n                if indx==len(path):\n                    # res.append(root.val)\n                    self.count+=1\n                dfs(root.left,path[:indx]+[root.val]+path[indx:])\n                dfs(root.right,path[:indx]+[root.val]+path[indx:])\n        # res=[]\n        self.count=0\n        dfs(root,[])\n        # print(res)\n        return self.count\n                \n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res=[]\n        cnt=0\n        def dfs(node):\n            nonlocal cnt\n            res.append(node.val)\n            \n            if res[-1] == max(res):\n                cnt+=1\n                \n            if node.left:\n                dfs(node.left)\n                \n            if node.right:\n                dfs(node.right)\n                \n            if res:\n                res.pop()\n                \n        dfs(root)\n        return cnt", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(r, val = float('-inf')):\n            if r:\n                ans = 1 if r.val >= val else 0\n                new_val = max(r.val, val)\n                ans += dfs(r.left, new_val)\n                ans += dfs(r.right, new_val)\n                return ans\n            return 0\n        return dfs(root)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        count = 0\n        return 1 + self.helper(root.left, root.val) + self.helper(root.right, root.val)\n    \n    def helper(self, root: TreeNode, m: int) -> int:\n        if root:\n            if root.val >= m:\n                return 1 + self.helper(root.left, max(root.val,m)) + self.helper(root.right, max(root.val,m))\n            else:\n                return self.helper(root.left, max(root.val,m)) + self.helper(root.right, max(root.val,m))\n            \n        else:\n            return 0", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        res = 1\n        parents, children = [(root, root.val)], []\n        while parents:\n            for node, val in parents:\n                if node.left:\n                    if node.left.val >= val:\n                        res += 1\n                    children.append((node.left, max(val, node.left.val)))\n                if node.right:\n                    if node.right.val >= val:\n                        res += 1\n                    children.append((node.right, max(val, node.right.val)))\n            parents = children\n            children = []\n            \n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    counter = 0\n    \n    def goodNodes(self, root: TreeNode) -> int:\n        self.counter = 0\n        self._goodNodes(root, root.val)\n        return self.counter\n        \n    def _goodNodes(self, root: TreeNode, current_max: int):\n        if not root:\n            return\n        \n        if root.val >= current_max:\n            self.counter += 1\n        \n        self._goodNodes(root.left, max(current_max, root.val))\n        self._goodNodes(root.right, max(current_max, root.val))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(root, mval):\n            if not root:\n                return 0\n            l = dfs(root.left, root.val if root.val > mval else mval)\n            r = dfs(root.right, root.val if root.val > mval else mval)\n            return l + r + (1 if root.val >= mval else 0)\n        return dfs(root, float(\\\"-inf\\\"))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    '''\n    - as we traverse down, we measure the maxSoFar and compare current \n    node with that\n    - current node is good if >= maxSoFar, so count as one\n    - can traverse recursively\n    '''\n    def goodNodes(self, root: TreeNode) -> int:\n        def traverse(node, maxSoFar=float(\\\"-inf\\\")):\n            # check base case (null node)\n            if not node:\n                return 0\n            \n            # process node\n            count = 1 if node.val >= maxSoFar else 0\n            maxSoFar = max(maxSoFar, node.val)\n            \n            # traverse children, adding count along the way\n            return traverse(node.left, maxSoFar) + traverse(node.right, maxSoFar) + count\n            \n        if not root:\n            return 0\n        return traverse(root)\n        \n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.total_count = 0\n        \n    def goodNodes(self, root: TreeNode) -> int:\n        return self.goodNodesHelper(root, float('-inf'))\n        \n    def goodNodesHelper(self, root, max_so_far):\n        if not root:\n            return \n        if max_so_far <= root.val:\n            max_so_far = root.val\n            self.total_count += 1\n        self.goodNodesHelper(root.left, max_so_far)\n        self.goodNodesHelper(root.right, max_so_far)\n        return self.total_count"]
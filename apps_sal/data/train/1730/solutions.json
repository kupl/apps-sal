["def two_by_n(n, k):\n    vv, vh, hv, hh = k-1, (k-1)*(k-2), k-2, (k-1)*(k-2) + 1\n    va, ha, vb, hb = 0, 0, 1, 1\n    for i in range(n - 1):\n        va, ha, vb, hb = vb, hb, vv*vb + vh*ha, hv*vb + hh*ha\n    return (k * vb + k*(k-1) * ha) % 12345787\n", "def two_by_n(n, k):\n    MOD = 12345787\n    x1, x2 = [0, k, k * (k - 1)], [0, 0, k * (k - 1)]\n    for _ in range(3, n + 1):\n        y1 = (x1[-1] * (k - 1) + x2[-1] * (k - 2)) % MOD\n        y2 = (x1[-2] * (k - 1) * (k - 2) + x2[-2] * ((k - 2) * (k - 2) + (k - 1))) % MOD\n        x1.append(y1)\n        x2.append(y2)\n    return (x1[n] + x2[n]) % MOD", "import numpy as np\ndef two_by_n(n,k):\n    x=np.array([[k*(k-1),k*(k-1)],[k,0]])\n    z=np.array([[k-1,(k-1)*(k-2)],[k-2,k**2-3*k+3]])\n    for i in range(n-2):\n        x=np.array([np.diag(x@z),x[0]])%12345787\n    return sum(x[int(n==1)])%12345787", "def two_by_n(n, k):\n    if n == 1: return k\n    \n    n = n-1\n    m = 12345787\n    x1,x2,x3,x4 = 0, 1, (k-1)*(k-1), k-2\n    y1,y2,y3,y4 = 1, 0, 0, 1\n    \n    while n > 1:\n        if n % 2 == 1:\n            y1,y2,y3,y4 = (x1*y1 + x2*y3)%m, (x1*y2 + x2*y4)%m, (x3*y1 + x4*y3)%m, (x3*y2 + x4*y4)%m\n        p, s = x2 * x3, x1 + x4\n        x1,x2,x3,x4 = (x1*x1 + p)%m, x2*s%m, x3*s%m, (p + x4*x4)%m\n        n = n // 2\n    \n    return k * (x1*y1 + x2*y3 + 2*(k-1)*(x1*y2 + x2*y4)) % m", "def two_by_n(n, k):\n    dp = [[0 for i in range(2)] for j in range(n+1)]\n    dp[1][0] = k\n    if n < 2:\n        print(\"here\")\n        return sum(dp[-1])\n    dp[2] = [k*(k-1), k*(k-1)]\n    # dp[i][0] = one colour at the end, i is the row len\n    # dp[i][1] = two colours at the end, i is the row len\n    NUM =  12345787\n    for i in range(3, n+1):\n        dp[i][0] = (max(k-1,0)*dp[i-1][0]+max(k-2,0)*dp[i-1][1]) % NUM\n        dp[i][1] = (max(k-1,0)*max(k-2,0)*dp[i-2][0]+(max(k-1,0)+max(k-2,0)*max(k-2,0))*dp[i-2][1]) % NUM\n#     print(\"n = \", n, \"k = \", k, \"dp = \", dp)  \n    return sum(dp[-1]) % NUM", "def two_by_n(n, k):\n    mod = 12345787\n    if n == 0: return 0\n    elif n == 1: return k\n    d = [k, 0, k * (k - 1), k * (k - 1)]\n    for i in range(3, n + 1):\n        x, y, z, w = d\n        d = [z, w, (z * (k - 1) + w * (k - 2)) % mod, (x * (k - 1) * (k - 2) + y * ((k - 2)**2 + k - 1)) % mod]\n    return (d[2] + d[3]) % mod", "def two_by_n(n, k):\n    if n==1:\n        return k\n    F = [0 for k in range(n+1)]\n    G = [0 for k in range(n+1)]\n    F[1]=1\n    F[2]=k-1\n    G[2]=1\n    for i in range(3, n+1):\n        F[i] = (k-1)*F[i-1] +  (k-1)*(k-2)*G[i-1]\n        G[i] = (k-2)*F[i-2] +  (k*k-3*k+3)*G[i-2]\n    \n    return (k*F[n] + k*(k-1)*G[n])%12345787", "def two_by_n(n, k):\n    op=[[k,0],[k*(k-1),k*(k-1)]]\n    for i in range(n-2):\n        op.append([op[-1][0]*(k-1) + op[-1][1]*(k-2) ,op[-2][0]*(k-1)*(k-2) + op[-2][1]*(k-1+(k-2)*(k-2))])\n    return sum(op[n-1])%12345787", "def two_by_n(n, k):\n    P = 12345787\n    if k == 1: return 1 if n == 1 else 0    \n    if n == 1: return k\n    if n == 2: return k*(k-1)*2 % P\n    f0 = [0] * (n+1)\n    f1 = [0] * (n+1)\n    f0[1] = k\n    f1[1] = 0\n    f0[2] = k*(k-1) % P\n    f1[2] = k*(k-1) % P\n    for i in range(3, n+1):\n        f0[i] = (f0[i - 1] * (k-1) + f1[i - 1] * (k-2)) % P\n        f1[i] = (f0[i - 2] * (k-1)*(k-2) + f1[i - 2] * (k-1 + (k-2)*(k-2))) % P\n    return (f0[n] + f1[n]) % P", "def two_by_n(n, k):\n    if not n: return 0\n    if n==1:  return k\n    if n==2:  return 2*k*(k-1)\n    a1,a2,b,c = k, 0, k*(k-1), k*(k-1)\n    for i in range(n-2):\n        a1,a2,b,c = (c, b,\n                     a1*(k-1)*(k-2) + a2*((k-1)**2 - (k-2)),\n                     c*(k-1) + b*(k-2))\n    return (b+c) % 12345787"]
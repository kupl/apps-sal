["class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         if root:\n             if d == 1:\n                 new_root = TreeNode(v)\n                 new_root.left = root\n                 \n                 return new_root \n \n             queue = [root]\n             level = 1\n             while queue and level < d:\n                 row = []\n                 for i in range(len(queue)):\n                     node = queue.pop(0)\n                     if level == d - 1:\n                         row.append(node)\n                     if node.left:\n                         queue.append(node.left)\n                     if node.right:\n                         queue.append(node.right)\n                 \n                 level += 1\n                                     \n             for node in row:\n                 old = node.left\n                 node.left = TreeNode(v)\n                 node.left.left = old\n \n                 old = node.right\n                 node.right = TreeNode(v)\n                 node.right.right = old\n         \n         return root\n             \n             \n", "class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         # if d == 1: # \u5e7f\u5ea6\u641c\u7d22 64ms\n         #     newroot = TreeNode(v)\n         #     newroot.left = root\n         #     return newroot\n         # lastlevel = []\n         # cur = 1\n         # curlevel = [root]\n         # nextlevel = []\n         # while cur < d:\n         #     for node in curlevel:\n         #         if node:\n         #             nextlevel.append(node.left)\n         #             nextlevel.append(node.right)\n         #     lastlevel = curlevel\n         #     curlevel = nextlevel\n         #     nextlevel = []\n         #     cur += 1\n         # count = 0\n         # for node in lastlevel:\n         #     if node:\n         #         templeft, tempright = TreeNode(v), TreeNode(v)\n         #         templeft.left = curlevel[count]\n         #         tempright.right = curlevel[count+1]\n         #         count += 2\n         #         node.left = templeft\n         #         node.right = tempright\n         # return root\n         \n         if d == 1:\n             newroot = TreeNode(v)\n             newroot.left = root\n             return newroot\n         queue = [(root, 1)]\n         for node, level in queue:\n             if node.left:\n                 queue.append((node.left, level+1))\n             if node.right:\n                 queue.append((node.right, level+1))\n             if level == d-1:\n                 newleft = TreeNode(v)\n                 newleft.left = node.left\n                 newright = TreeNode(v)\n                 newright.right = node.right\n                 node.left = newleft\n                 node.right = newright\n         return root", "class Solution:\n     \n     def traverse_left(self, stack, node, node_depth, d):\n         while node_depth + 1 < d and node.left is not None:\n             stack.append((node.left, node_depth + 1))\n             node = node.left\n             node_depth += 1\n     \n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         \n         if d == 1:\n             new_root = TreeNode(v)\n             new_root.left = root\n             return new_root\n         \n         stack = [(root, 1)]\n         self.traverse_left(stack, root, 1, d)\n         \n         while not (not stack):\n             node, node_depth = stack.pop()\n             if node_depth + 1 < d and node.right is not None:\n                 stack.append((node.right, node_depth + 1))\n                 self.traverse_left(stack, node.right, node_depth + 1, d)\n               \n             if node_depth == d - 1:\n                 a = TreeNode(v)\n                 a.left = node.left\n                 node.left = a\n                 b = TreeNode(v)\n                 b.right = node.right\n                 node.right = b\n                 \n         return root\n         \n", "# Definition for a binary tree node.\n # class TreeNode(object):\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         if d == 1:\n             rt = TreeNode(v)\n             rt.left = root\n             return rt\n         \n         def DFS(rt, depth):\n             if depth == d - 1:\n                 newL = TreeNode(v)\n                 newL.left = rt.left\n                 newR = TreeNode(v)\n                 newR.right = rt.right\n                 rt.left = newL\n                 rt.right = newR\n                 return\n             if rt.left:\n                 DFS(rt.left, depth + 1)\n             if rt.right:\n                 DFS(rt.right, depth + 1)\n         \n         DFS(root, 1)\n         return root\n             \n                 \n     \n             ", "class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         if not root:\n             return\n         if d == 1:\n             new = TreeNode(v)\n             new.left = root\n             return new\n         if d == 2:\n             # Create new children.\n             right, left = TreeNode(v), TreeNode(v)\n \n             # Add roots children to these new children..\n             right.right = root.right\n             left.left = root.left\n \n             # Set new children as roots children\n             root.right, root.left = right, left\n         else:\n             self.addOneRow(root.right, v, d - 1)\n             self.addOneRow(root.left, v, d - 1)\n         return root\n", "class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         if d == 1:\n             nrt = TreeNode(v)\n             nrt.left = root\n             return nrt\n         level = 1\n         que = [root]\n         d -= 1\n         beg, end = 0, 1\n         while beg < end:\n             lev_cnt = 0\n             i = beg\n             if level == d:\n                 while i < end:\n                     p = que[i]\n                     lt, rt = TreeNode(v), TreeNode(v)\n                     lt.left = p.left\n                     p.left = lt\n                     rt.right = p.right\n                     p.right = rt\n                     i += 1\n                 return root\n             while i < end:\n                 p = que[i]\n                 if p.left:\n                     que.append(p.left)\n                     lev_cnt += 1\n                 if p.right:\n                     que.append(p.right)\n                     lev_cnt += 1\n                 i += 1\n             beg = end\n             end += lev_cnt\n             level += 1\n         return root\n                 \n                 \n             \n                 \n                 \n", "class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         q, depth = [root], 1\n         while depth != d: parent, q, depth = q, [kid for node in q for kid in (node.left, node.right) if kid], depth+1\n         if d != 1:\n             for node in parent: node.left, node.right, node.left.left, node.right.right = TreeNode(v), TreeNode(v), node.left, node.right\n             return root\n         else: \n             first, first.left = TreeNode(v), root\n             return first", "class Solution:\n     def addOneRow(self, root, v, d):\n         \"\"\"\n         :type root: TreeNode\n         :type v: int\n         :type d: int\n         :rtype: TreeNode\n         \"\"\"\n         dummy, dummy.left = TreeNode(None), root\n         row = [dummy]\n         for _ in range(d - 1):\n             row = [kid for node in row for kid in (node.left, node.right) if kid]\n         for node in row:\n             node.left, node.left.left = TreeNode(v), node.left\n             node.right, node.right.right = TreeNode(v), node.right\n         return dummy.left"]
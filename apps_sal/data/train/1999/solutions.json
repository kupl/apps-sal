["# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        \n        seen={}\n        seen[0]=dummy=ListNode(0)\n        dummy.next=head\n        prev=0\n        \n        while head:\n            prev+=head.val\n            seen[prev]=head\n            head=head.__next__\n        head=dummy\n        prev=0\n        \n        while head:\n            prev+=head.val\n            head.next=seen[prev].__next__\n            head=head.__next__\n        return dummy.__next__\n        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        prefix = 0\n        seen_prefix = {}\n        seen_prefix[0] = dummy = ListNode(0)\n        dummy.next = head\n        \n        while head:\n            prefix += head.val\n            seen_prefix[prefix] = head\n            head = head.next\n            \n        prefix = 0\n        head = dummy\n        \n        while head:\n            prefix += head.val\n            head.next = seen_prefix[prefix].next\n            head = head.next\n            \n        return dummy.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur.__next__\n            cur = cur.__next__\n        return dummy.__next__\n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n#OrderedDict is used for ordered dictionaries\nfrom collections import OrderedDict\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        nodes = OrderedDict()\n        curr = head\n        temp = ans = ListNode(0)\n        prefix = 0\n        nodes[prefix] = ListNode(0)\n        while curr:\n            prefix += curr.val\n            node = None\n            while prefix in nodes:\n                node = nodes.popitem()\n            if node:\n                nodes[prefix] = node[1]\n                curr = curr.__next__\n                continue\n                \n            nodes[prefix] = curr\n            curr = curr.__next__\n        \n        first = True\n        for node in list(nodes.values()):\n            if first:\n                first = False\n                continue\n            temp.next = ListNode(node.val)\n            temp = temp.__next__\n        return ans.__next__\n            \n\n                \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0)\n        dummy.next = head\n        prefixSum = 0 \n        cur = head\n        dic = {0:dummy}\n        while cur:\n            prefixSum += cur.val\n            dic[prefixSum] = cur\n            cur = cur.next\n        head = dummy\n        prefixSum = 0\n        while head:\n            prefixSum += head.val\n            head.next = dic[prefixSum].next\n            head = head.next\n        return dummy.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dum = ListNode(next=head)\n        sum_map = {0: dum}\n        l = [0]\n        \n        while head:\n            if head.val == 0:\n                sum_map[l[-1]].next = head.__next__\n                head = head.__next__\n                continue\n                \n            sv = head.val + l[-1]\n            \n            if sv in sum_map:\n                node = sum_map[sv]\n                v = l.pop()\n                while v != sv:\n                    sum_map.pop(v, None)\n                    v = l.pop()\n                node.next = head.__next__\n            else:\n                sum_map[sv] = head\n                \n            l.append(sv)\n            head = head.__next__\n        return dum.__next__\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur = cur.__next__\n        \n        return dummy.__next__\n            \n    \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        node, prev, rsum = head, None, 0 # tbd = sublist To Be Deleted\n        rsum_map = {}\n        while node:\n            rsum += node.val\n            \n            if rsum_map.get(rsum):\n                link = rsum_map.get(rsum)\n                link.next = node.__next__\n                prev, node = link, node.__next__\n                \n                # update the map\n                rsum_map = {}\n                x, rsum = head, 0\n                while x != node:\n                    rsum+=x.val\n                    rsum_map[rsum] = x\n                    x = x.__next__\n                continue\n            \n            rsum_map[rsum] = node\n            if node.val == 0:\n                if prev:\n                    prev.next = node = node.__next__\n                else:\n                    head = node = node.__next__\n                rsum_map.pop(0)\n                continue\n            elif rsum == 0:\n                head = node = node.__next__\n                prev = None\n                rsum_map = {}\n                continue\n                  \n            prev = node\n            node = node.__next__\n        return head\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        \n        dummy = ListNode(0)\n        hash = {0: dummy}\n        dummy.next = head\n        sum = 0\n        i = head\n        while i:\n            sum+=i.val\n            if sum in list(hash.keys()):\n                tempsum = sum\n                j = hash[sum].__next__\n                while j != i:\n                    tempsum+=j.val\n                    del hash[tempsum]\n                    j = j.__next__\n                hash[sum].next = i.__next__\n            else:\n                hash[sum] = i\n            i = i.__next__\n        \n        return dummy.__next__\n        \n", "from math import floor\nfrom math import ceil\nfrom math import sqrt\nfrom collections import deque\nimport numpy\nfrom _collections import deque\n#from _ast import Num # LC doesn't like this\nfrom heapq import *\nfrom typing import List\nimport random\n\nMOD = int(1e9 + 7)\nBASE = 256\n\\\"\\\"\\\"\nMaintain a v to list mapping\nthis is the complete stale of final answer\ntwo states to maintain\n1. ansT\n\n\n\\\"\\\"\\\"\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        vToN = {}\n        ps = 0\n        vToN[0] = None\n\n        curT = head\n        ansH = None\n        ansT = None\n\n        while curT:\n            newPs = ps + curT.val\n            #print(newPs, vToN)\n\n            if newPs in vToN:\n                newAnsT = vToN[newPs]\n                if newAnsT:\n\n                    tempT = newAnsT\n                    tempPs = newPs\n                    while tempT != ansT:\n                        tempT = tempT.next\n                        tempPs += tempT.val\n                        del vToN[tempPs]\n                        \n                    ansT = newAnsT\n                    ansT.next = None\n                else:\n                    ansH = None\n                    ansT = None\n                    vToN.clear()\n                    vToN[0] = None\n            else:\n                if ansT:\n                    ansT.next = curT\n                else:\n                    ansH = curT\n                ansT = curT\n                vToN[newPs] = curT\n            ps = newPs\n            curT = curT.next\n        \n        \n        return ansH\n\n\ndef toLL(l):\n    head = ListNode(l[0])\n    tail = head\n    for i in range(1, len(l)):\n        node = ListNode(l[i])\n        tail.next = node\n        tail = node\n    return head\n\ndef pl(head):\n    while head:\n        print(head.val)\n        head = head.next\n\\\"\\\"\\\"\nS = Solution()\nhead = [1,2,3,-3,-2]\nhead = [1,2,3,-3,3]\nhead = [1,2,3,-3,4]\nhead = [1,2,-3,3,1]\nhead = [1, -1]\npl(S.removeZeroSumSublists(toLL(head)))\n#S.removeZeroSumSublists(None)\n\\\"\\\"\\\"", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        m = {0: (dummy, 0)}\n        cur_sum = cur = 0\n        A = []\n        def check(i, A):\n            return all(not(s < i <= e)for s, e in A)\n        while head:\n            cur_sum += head.val\n            cur += 1\n            if cur_sum in m:\n                i = m[cur_sum][1]\n                if check(i, A):\n                    m[cur_sum][0].next = head.next\n                    A.append((i, cur))\n                else:\n                    m[cur_sum] = (head, cur)\n            else:\n                m[cur_sum] = (head, cur)\n            head = head.next\n\n        return dummy.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        p=head\n        prev=None\n        while(p):\n            q=p.__next__\n            s=p.val\n            while(q and s):\n                s+=q.val\n                q=q.__next__\n            if s==0:\n                if p==head:\n                    p=q\n                    head=q\n                else:\n                    prev.next=q\n                \n                p=q\n            else:\n                prev=p\n                p=p.__next__\n            #print(prev.val,p.val if p else \\\" \\\")\n        return head\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = {}\n        while cur:\n            prefix += cur.val\n            seen[prefix] = cur \n            cur = cur.__next__\n        cur = dummy\n        prefix = 0\n        while cur:\n            prefix += cur.val\n            cur.next = seen[prefix].__next__\n            cur = cur.__next__\n        return dummy.__next__\n            \n    \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if(head is None):\n            return None\n        temp = head;\n        array = self.createArray(temp);\n        curSum = 0;\n        index = 0;\n        while(index < len(array)):\n            for i in range(index, len(array)):\n                curSum += array[i];\n                if(curSum == 0):\n                    self.clearOutArray(array, index, i);\n                    index = i + 1;\n                    curSum = 0;\n            curSum = 0;\n            index += 1;\n        \n        newNode = self.create(array);\n        return newNode\n   \n    def clearOutArray(self, array, index, i):\n        for i in range(index, i + 1):\n            array[i] = None;\n        return;\n    \n    def create(self, array):\n        if(len(array) == 0):\n            return None;\n        node = None\n        temp = None\n        for i in range(0, len(array)):\n            if(array[i] != None):\n                if(node is None):\n                    node = ListNode(array[i]);\n                    temp = node;\n                else:\n                    node.next = ListNode(array[i]);\n                    node = node.__next__;\n        if(node is not None):\n            node.next = None;\n        return temp;\n        \n        \n    def createArray(self, temp):\n        array = [];\n        while(temp != None):\n            array.append(temp.val);\n            temp = temp.__next__;\n        return array;\n    \n    \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        temp = head\n        while temp:\n            s = 0\n            start = temp\n            while start:\n                s += start.val\n                if s == 0:\n                    prev.next = start.__next__\n                    break\n                start = start.__next__\n            if start == None:\n                start = temp\n                prev = temp\n            temp = start.__next__\n        return dummy.__next__\n            \n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if head is None: return head\n        tot, cur = 0, head\n        while cur:\n            tot += cur.val\n            cur = cur.__next__\n            if tot == 0:\n                return self.removeZeroSumSublists(cur)\n        head.next = self.removeZeroSumSublists(head.next)\n        return head\n    \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        curr_sum = 0\n        extra = ListNode(None)\n        extra.next = head\n        node = head\n        prev = extra\n        while node:\n            tmp = node\n            curr_sum = 0\n            while tmp:\n                curr_sum += tmp.val\n                if curr_sum==0:\n                    break\n                else:\n                    tmp = tmp.__next__\n            # print (tmp.val, curr_sum)\n            if curr_sum==0:\n                if tmp:\n                    prev.next = tmp.__next__\n                else:\n                    prev.next = None\n                node = prev.__next__\n            else:\n                prev = node\n                node = node.__next__\n            \n        return extra.__next__\n            \n   \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        # Create a dummy node to init the search\n        pointer = ListNode(float(\\\"inf\\\"))\n        # Point the dummy node to the head of the list\n        pointer.next = head\n        # create a reference to the given list and point the head to the dummy node\n        curr = head\n        head = pointer\n\n        # Iterate over the node\n        while head:\n            # Store the current sum\n            current_sum = 0\n\n            # For each node compute the consecutive sum\n            while curr:\n                # Add the value of the node to the current sum\n                current_sum += curr.val\n\n                # If the consecutive sum is 0\n                # Delete the reference to the\n                # nodes that sum up to 0\n                if current_sum == 0:\n                    head.next = curr.next\n\n                # Move to the next node\n                curr = curr.next\n\n            # Move the head\n            head = head.next\n\n            # Update the current node\n            # to be the next element \n            # of the head. This resets\n            # the \\\"state\\\" as in the start\n            if head:\n                curr = head.next\n\n        # Return the next element of the \n        # dummy pointer, which is going\n        # to be the updated head of the list\n        return pointer.next            ", "class Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode(float('inf'))\n        dummy.next = head\n        cur = head\n        head = dummy\n        \n        while head:\n            r_sum = 0\n            \n            while cur:\n                r_sum += cur.val\n                if r_sum == 0:\n                    head.next = cur.__next__\n                \n                cur = cur.__next__\n            head = head.__next__\n            if head:\n                cur = head.__next__\n        \n        return dummy.__next__\n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if not head:\n            return None\n        node = temp = ListNode(0)\n        node.next = head\n        \n        while temp:\n            total = 0\n            second = temp.next\n            while second:\n                total += second.val\n                if total == 0:\n                    temp.next = second.next\n                second = second.next\n            temp = temp.next\n            \n        return node.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode()\n        dummy.next = head\n        curr = head\n        prefix_sum = [0]\n        d = {}\n        d[0] = dummy\n        i = 1\n        \n        \n        while curr:\n            prefix_sum.append(prefix_sum[-1] + curr.val)\n            d[i] = curr\n            i += 1\n            curr = curr.__next__\n        \n        i = 0\n        while i < len(prefix_sum):\n            j = len(prefix_sum) - 1\n            while i <= j:\n                if prefix_sum[j] - prefix_sum[i] == 0:\n                    d[i].next = d[j].__next__\n                    i = j + 1\n                j -= 1\n        \n        return dummy.__next__\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        Head = ListNode(0)\n        Head.next = head\n        cur = Head;\n        while(cur != None):        \n            sum=0\n            while(head!=None):\n                sum = sum + head.val\n                if(sum==0):                \n                    cur.next = head.__next__\n                head  = head.__next__\n            \n            cur=cur.__next__\n            if(cur!=None):            \n                head = cur.__next__\n            \n        \n        return Head.__next__     \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        nodeList = []\n        temp = head\n        while temp:\n            nodeList.append(temp.val)\n            temp = temp.next\n        \n        x = 0\n        while x < len(nodeList):\n            y = x\n            sum = 0\n            while y < len(nodeList):\n                sum = sum + nodeList[y]\n                if sum == 0:\n                    # delete array index x to y\n                    del nodeList[x:y+1]\n                    x -= 1\n                    break\n                y += 1\n            x += 1\n        print(nodeList)\n\n        newHead = ListNode()\n        currhead = newHead\n        for node in nodeList:\n            currhead.next = ListNode(node)\n            currhead = currhead.next\n\n        return newHead.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur = cur.__next__\n        return dummy.__next__\n    \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if(head is None):\n            return None\n        temp = head;\n        array = self.createArray(temp);\n        curSum = 0;\n        index = 0;\n        while(index < len(array)):\n            for i in range(index, len(array)):\n                curSum += array[i];\n                if(curSum == 0):\n                    self.clearOutArray(array, index, i);\n                    index = i + 1;\n                    curSum = 0;\n            curSum = 0;\n            index += 1;\n        \n        return self.create(array);\n   \n    def clearOutArray(self, array, index, i):\n        for i in range(index, i + 1):\n            array[i] = None;\n        return;\n    \n    def create(self, array):\n        if(len(array) == 0):\n            return None;\n        node = None\n        temp = None\n        for i in range(0, len(array)):\n            if(array[i] != None):\n                if(node is None):\n                    node = ListNode(array[i]);\n                    temp = node;\n                else:\n                    node.next = ListNode(array[i]);\n                    node = node.__next__;\n        if(node is not None):\n            node.next = None;\n        return temp;\n        \n    def createArray(self, temp):\n        array = [];\n        while(temp != None):\n            array.append(temp.val);\n            temp = temp.__next__;\n        return array;\n    \n    \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        a=[]\n        temp = head\n        while(temp):\n            a.append(temp.val)\n            temp = temp.next\n        # print(a)\n        l = len(a)\n        i = l-1\n        x=0 \n        ind = []\n        while(i>=1):\n            e = a[i]\n            j = i-1\n            while(j>=0):\n                e+=a[j]\n                if e==0:\n                    ind.append((j,i))\n                    i = j\n                    break\n                j-=1\n            i-=1\n        # print(ind)\n        li = len(ind)\n        j =0\n        while(j<li):\n            s,e = ind[j][0],ind[j][1]\n            for i in range(e,s-1,-1):\n                # print(a,i)\n                a.pop(i)\n                \n            j+=1\n        h = ListNode(0)\n        temp = h\n        while a:\n            e = a.pop(0)\n            if e !=0:\n                temp.next =ListNode(e)\n                temp =temp.next\n        return h.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        l = []\n        result = head\n        while head != None:\n            num = head.val\n            bFlag = False\n            if num == 0:\n                bFlag = True\n                if result == head:\n                    result = head.next\n                else:\n                    l[len(l) - 1].next = head.next\n            else:\n                for i in range(len(l) - 1, -1, -1):\n                    num += l[i].val\n                    if num == 0:\n                        bFlag = True\n                        if i == 0:\n                            result = head.next\n                        else:\n                            l[i - 1].next = head.next\n                        for j in range(len(l) - 1, i - 1, -1):\n                            l.pop()\n                        break\n            if bFlag == False:\n                l.append(head)\n            head = head.next\n        return result", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if(head is None):\n            return None\n        temp = head;\n        array = self.createArray(temp);\n        \n        curSum = 0;\n        index = 0;\n        while(index < len(array)):\n            for i in range(index, len(array)):\n                curSum += array[i];\n                if(curSum == 0):\n                    self.clearOutArray(array, index, i);\n                    index = i + 1;\n                    curSum = 0;\n            curSum = 0;\n            index += 1;\n        \n        finalArray = [];\n        for num in array:\n            if(num  != None):\n                finalArray.append(num);\n        \n        newNode = self.create(finalArray);\n        return newNode\n                    \n    def clearOutArray(self, array, index, i):\n        for i in range(index, i + 1):\n            array[i] = None;\n        return;\n    \n    def create(self, array):\n        if(len(array) == 0):\n            return None;\n        else:\n            node = ListNode(array[0]);\n            temp = node;\n            for i in range(1, len(array)):\n                node.next = ListNode(array[i]);\n                node = node.__next__;\n            node.next = None;\n        return temp;\n        \n        \n    def createArray(self, temp):\n        array = [];\n        while(temp != None):\n            array.append(temp.val);\n            temp = temp.__next__;\n        return array;\n    \n    \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if(head is None):\n            return None\n        temp = head;\n        array = self.createArray(temp);\n        \n        curSum = 0;\n        index = 0;\n        while(index < len(array)):\n            for i in range(index, len(array)):\n                curSum += array[i];\n                if(curSum == 0):\n                    self.clearOutArray(array, index, i);\n                    index = i + 1;\n                    curSum = 0;\n            curSum = 0;\n            index += 1;\n        \n        newNode = self.create(array);\n        return newNode\n                    \n    def clearOutArray(self, array, index, i):\n        for i in range(index, i + 1):\n            array[i] = None;\n        return;\n    \n    def create(self, array):\n        if(len(array) == 0):\n            return None;\n        else:\n            node = None\n            temp = None\n            for i in range(0, len(array)):\n                if(array[i] != None):\n                    if(node is None):\n                        node = ListNode(array[i]);\n                        temp = node;\n                    else:\n                        node.next = ListNode(array[i]);\n                        node = node.__next__;\n            if(node is not None):\n                node.next = None;\n        return temp;\n        \n        \n    def createArray(self, temp):\n        array = [];\n        while(temp != None):\n            array.append(temp.val);\n            temp = temp.__next__;\n        return array;\n    \n    \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if head == None:\n            return None\n        def check(node):\n            if node == None:\n                return None\n            n = check(node.__next__)\n            node.next = n\n            t = node\n            c = 0\n            while t != None:\n                c += t.val\n                if c == 0:\n                    return t.__next__\n                t = t.__next__\n            return node\n                \n            \n                \n        res = check(head)\n        return res\n                    \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.__next__\n        D = [0]*(len(arr)+1)\n        for i in range(1,len(D)):\n            D[i] = D[i-1] + arr[i-1]\n        \n        tmp_dict = {}\n        for i in range(len(D)):\n            if D[i] not in tmp_dict:\n                tmp_dict[D[i]] = [i]\n            else:\n                tmp_dict[D[i]].append(i)\n        i = 0\n        remove = []\n        while i<len(D):\n            if len(tmp_dict[D[i]])>1:\n                if i!=tmp_dict[D[i]][-1]:\n                    remove.append([i,tmp_dict[D[i]][-1]])\n                i = tmp_dict[D[i]][-1] + 1\n            else:\n                i += 1\n        \n        remove_idx = []\n        for i in range(len(remove)):\n            remove_idx += [e for e in range(remove[i][0],remove[i][1])]\n        \n        res = []\n        for i in range(len(arr)):\n            if i not in remove_idx:\n                res.append(arr[i])\n        \n        if len(res)==0:\n            return None\n        else:\n            head = ListNode(res[0])\n            pre = head\n            for i in range(1,len(res)):\n                node = ListNode(res[i])\n                pre.next = node\n                pre = node\n            return head\n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        p = head\n        nums = []\n        while p:\n            nums.append(p.val)\n            p = p.__next__\n        \n        def check(nums):\n            cur, k = 0, 0\n            stack = []\n            acc = [0] + list(accumulate(nums))\n            for i, n in enumerate(nums):\n                for j in range(k, i + 1):\n                    if acc[i + 1] - acc[j] == 0:\n                        stack.append((j, i))\n                        k = i + 1\n            return stack\n        \n        stack = check(nums)\n        while stack:\n            while stack:\n                j, i = stack.pop()\n                nums[j: i + 1] = []\n            stack = check(nums)\n        \n        if not nums:\n            return None\n        ans = ListNode(nums[0])\n        p = ans\n        for i in range(1, len(nums)):\n            p.next = ListNode(nums[i])\n            p = p.__next__\n        return ans\n            \n            \n            \n            \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nfrom collections import deque\n\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        s = []\n        cur = head\n        \n        while cur != None:\n            if cur.val == 0:\n                cur = cur.__next__\n                continue\n            \n            back_sum = 0\n            end_i = -1\n            for i in range(len(s))[::-1]:\n                back_sum += s[i].val\n                \n                if cur.val + back_sum == 0:\n                    end_i = i\n                    \n            if end_i != -1:\n                for j in range(len(s) - 1, end_i - 1, -1):\n                    s.pop()\n            else:\n                s.append(cur)\n            \n            cur = cur.__next__\n            \n        for i in range(len(s)):\n            if i < len(s) - 1:\n                s[i].next = s[i+1]\n            else:\n                s[i].next = None\n               \n        if len(s) > 0:\n            return s[0]\n        else:\n            return None\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0 \n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur = cur.__next__ \n        return dummy.__next__\n            \n    \n            \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteNodes(self, node: ListNode, num: int) -> ListNode:\n        assert node != None\n        assert num > 0\n        dummy = ListNode(0, node)\n        prev = dummy\n        while node != None and num != 0:\n            prev.next = node.next\n            node = node.next\n            num = num - 1\n        assert num == 0\n        return dummy.next\n    \n    def findSumZero(self, head: ListNode) -> int:\n        assert head != None\n        n = 1\n        s = 0\n        node = head\n        while node != None:\n            s = s + node.val\n            if s == 0:\n                return n \n            node = node.next\n            n = n + 1\n        return 0\n        \n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        dummy = ListNode(0, head)\n        prev = dummy\n        node = head\n        while node != None:\n            n = self.findSumZero(node)\n            if n > 0:\n                node_next = node\n                for i in range(n):\n                    node_next = node_next.next\n                prev.next = node_next\n                node = node_next\n            else:\n                prev = node\n                node = node.next\n        return dummy.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        \n        array = []\n        modified = False\n        node = head\n        #print(\\\"Head: \\\", head)\n        while node:\n            #print(\\\"node: \\\", node.val, modified, matched)\n            next_node = node.__next__\n            matched = False\n            if node.val == 0:\n                matched = True\n                modified = True\n                if len(array) > 0:\n                    array[-1].next = next_node\n                else:\n                    head = next_node\n            \n            else:\n                tsum = 0\n                #print(\\\"For: \\\", node.val)\n                for i in range(len(array) -1, -1, -1):\n                    tsum += array[i].val\n                    if tsum + node.val == 0:\n                        matched = True\n                        modified = True\n                        #print(i)\n                        if i != 0:\n                            j = 0\n                            popi = len(array) - i\n                            while j != popi:\n                                array.pop()\n                                j += 1\n                            array[i-1].next = next_node\n                            #print(array[i-1].val, next_node.val, head)\n                        else:\n                            # all elements removed\n                            head = next_node\n                            array = []\n                    # elif tsum + node.val > 0:\n                    #     break\n                        \n            if not matched:\n                array.append(node)\n            node = next_node\n        #print(\\\"op head: \\\", head)\n        if modified:\n            return self.removeZeroSumSublists(head)\n        else:\n            return head        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        curr = head\n        while curr is not None and curr.val == 0:\n            curr = curr.__next__\n            \n        dummy = ListNode(0, curr)\n        if curr is not None:  \n            memo = [[dummy],[curr, curr.val]]\n        curr = curr.__next__ if curr is not None else None\n        while curr is not None:\n            last_index = len(memo) - 1\n            if curr.val == 0:\n                # print(\\\"here\\\")\n                memo[last_index][0].next = curr.__next__\n                curr = curr.__next__\n                continue\n            curr_list = [curr]\n            flag = True\n            for i in range(1, len(memo[last_index])):\n                val = memo[last_index][i] + curr.val\n                # print(val)\n                if val == 0:\n                    # print(f'last: {memo[last_index][0].val}, curr: {curr.val}')\n                    memo[i - 1][0].next = curr.__next__\n                    memo = memo[:i]\n                    # print(memo)\n                    flag = False\n                    break\n                else:\n                    curr_list.append(val)\n            if flag:\n                curr_list.append(curr.val)\n                memo.append(curr_list)\n            curr = curr.__next__\n        return dummy.__next__\n                \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        if(head is None):\n            return head;\n        prev = None;\n        currentNode = head;\n        nextNode = head;\n        newHead = head;\n        curSum = 0;\n        while(currentNode != None):\n            while(nextNode != None):\n                curSum += nextNode.val\n                if(curSum == 0):\n                    if(prev is None):\n                        currentNode = nextNode.__next__;\n                        newHead = currentNode\n                        nextNode = nextNode.__next__;\n                    else:\n                        prev.next = nextNode.__next__\n                        currentNode = nextNode.__next__;\n                        nextNode = nextNode.__next__;\n                else:\n                    nextNode = nextNode.__next__;\n            curSum = 0;\n            if(currentNode is None):\n                break\n            prev = currentNode;\n            currentNode = currentNode.__next__;\n            nextNode = currentNode;\n        return newHead\n        \n            \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        def removeZeros(arr):\n            for i in range(len(arr)):\n                tsum = 0\n                for j in range(i, len(arr)):\n                    tsum += arr[j]\n                    if tsum == 0:\n                        return True, [i, j]\n            \n            return False, [len(arr), len(arr)-1]\n        \n        arr = []\n        current = head\n        while current is not None:\n            arr.append(current.val)\n            current = current.__next__\n        \n        ret = removeZeros(arr)\n        flag = ret[0]\n        while flag:\n            start = ret[1][0]\n            end = ret[1][1]\n            arr = arr[:start] + arr[end+1:]\n            ret = removeZeros(arr)\n            flag = ret[0]\n        \n        head = None\n        current = head\n        for n in arr:\n            if current is None:\n                current = ListNode(n)\n                head = current\n            else:\n                current.next = ListNode(n)\n                current = current.__next__\n            \n        return head\n        \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:        \n        root = ListNode(next=head)\n        r, h = root, head\n        \n        while h:\n            # node.val == 0\n            if not h.val:\n                r.next = h.__next__\n                h = h.__next__\n            else:\n                p, q = root, root.__next__\n                while q != h:\n                    q.val += h.val\n                    \n                    # find a zero-sum sequence\n                    if not q.val:\n                        p.next = h.__next__\n                        break\n                        \n                    p, q = q, q.__next__\n                if q == h:\n                    r, h = h, h.__next__\n                else:\n                    r, h = p, h.__next__\n\n        # revert to nodes' original values\n        p, q = root, root.__next__\n        while q:\n            p.val -= q.val\n            p, q = q, q.__next__\n        \n        return root.__next__\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        # Try starting from every possible starting point basically\n        while True:\n            n = head\n            size = 0\n            while n != None:\n                size += 1\n                n = n.__next__\n            i = 0\n            flag = False\n            while i < size:\n                node = head\n                k=0\n                prev = head\n                while k < i:\n                    prev = node\n                    if node == None:\n                        break\n                    node = node.__next__\n                    k += 1\n                i += 1\n                curr_sum = 0\n                n = prev\n                d = {}\n                while node != None:\n                    curr_sum += node.val\n                    if curr_sum == 0:\n                        if i == 1:\n                            head = node.__next__\n                        else:\n                            n.next = node.__next__\n                        flag = True\n                        break\n                    node = node.__next__\n                    \n            if not flag:\n                break\n        \n        return head\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        # Try starting from every possible starting point basically\n        while True:\n            n = head\n            size = 0\n            while n != None:\n                size += 1\n                n = n.__next__\n            i = 0\n            flag = False\n            while i < size:\n                node = head\n                k=0\n                prev = head\n                while k < i:\n                    prev = node\n                    if node == None:\n                        break\n                    node = node.__next__\n                    k += 1\n                i += 1\n                curr_sum = 0\n                n = prev\n                while node != None:\n                    curr_sum += node.val\n                    if curr_sum == 0:\n                        if i == 1:\n                            head = node.__next__\n                        else:\n                            n.next = node.__next__\n                        flag = True\n                        break\n                    node = node.__next__\n                    \n            if not flag:\n                break\n        \n        return head\n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, H: ListNode) -> ListNode:\n        A, b = ListNode(0), 1; A.next = H\n        while b:\n            s, b, D, C = 0, 0, {0:A}, A.next\n            while C != None:\n                s += C.val\n                if s in D:\n                    D[s].next, b = C.next, 1\n                    break\n                else: D[s], C = C, C.next\n        return A.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur = cur.next\n        return dummy.next", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n#OrderedDict is used for ordered dictionaries\nfrom collections import OrderedDict\nclass Solution:\n    def removeZeroSumSublists(self, head):\n        cur = dummy = ListNode(0)\n        dummy.next = head\n        prefix = 0\n        seen = collections.OrderedDict()\n        while cur:\n            prefix += cur.val\n            node = seen.get(prefix, cur)\n            while prefix in seen:\n                seen.popitem()\n            seen[prefix] = node\n            node.next = cur = cur.__next__\n        return dummy.__next__\n            \n\n                \n        \n", "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def remove_range(self, head, start_prev, stop):\n        if start_prev is None:\n            return stop\n        else:\n            start_prev.next = stop\n            return head\n    \n    def detect_zero(self, head):\n        prev = None\n        stop = head\n        hist = {0: None}\n        acc = 0\n        while stop is not None:\n            acc += stop.val\n            try:\n                start_prev = hist[acc]\n            except KeyError:\n                hist[acc] = stop\n                prev = stop\n                stop = stop.__next__\n                continue\n            return True, start_prev, stop.__next__\n        return False, None, None\n    \n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n        while True:\n            found, start_prev, stop = self.detect_zero(head)\n            if not found:\n                return head\n            head = self.remove_range(head, start_prev, stop)\n"]
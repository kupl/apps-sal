["from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1] + [N] * N\n  tail = 1\n  for i in range(N):\n    s = Q[i]\n    if s == N:\n      print(-1)\n      break\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q[tail] = adj\n        tail += 1\n  else:\n    if sum(dist) == DD[-1][0]:\n      for e in E:\n        print(e[0], e[1])\n    else:\n      print(-1)", "def main():\n    N = int(input())\n    D = [int(input()) for i in range(N)]\n    C = [1] * N\n    T = [0] * N\n    DI = {}\n    for i in range(len(D)):\n        DI[D[i]] = i\n    D = sorted(D)\n    P = [-1] * N\n    while len(D) > 1:\n        d = D.pop()\n        i = DI[d]\n        nd = d - N + C[i] * 2\n        if nd in DI:\n            ni = DI[nd]\n        else:\n            print(-1)\n            return\n        P[i] = ni\n        C[ni] += C[i]\n        T[ni] += T[i] + C[i]\n    \n    if D[0] == T[DI[D[0]]]:\n        for i in range(N):\n            if P[i] >= 0: print(i+1, P[i]+1)\n    else:\n        print(-1)\n\nmain()", "n,*d = map(int,open(0).read().split())\nz = {j:i for i,j in enumerate(d)}\n*s, = sorted(d)\nP = [-1]*n\nS = {i:1 for i in d}\nD = {i:0 for i in d}\nok = 1\nfor v in s[n-1:0:-1]:\n    p = v-n+2*S[v]\n    if p >= v: ok = 0\n    if p in z:\n        S[p] += S[v]\n        D[p] += D[v]+S[v]\n        P[z[v]] = z[p]\n    else: ok = 0\nif ok and D[s[0]]==s[0]:\n    for i,pi in enumerate(P):\n        if pi != -1: print(i+1,pi+1)\nelse: print(-1)", "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3:\n\tprint(-1)\n\treturn\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i] or n <= 2*child[i]:\n\t\tprint(-1)\n\t\treturn\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tnonlocal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)", "# -*- coding: utf-8 -*-\n\"\"\" output\u306e\u6642\u9593\u6bd4\u8f03 \"\"\"\nfrom sys import stdin, stdout\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list([int(x)-1 for x in stdin.readline().split()])\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\nd_in = lambda: int(stdin.readline())  # N = d_in()\nds_in = lambda: list(map(int, stdin.readline().split()))  # List = ds_in()\ndef print_list(s):\n    stdout.write(' '.join(list(map(str, s))) + '\\n')\n    # stdout.flush()\ndef print_single(s):\n    stdout.write(str(s) + '\\n')\n    # stdout.flush()\n\n\n# N = _i()\n# D_list = np.array([_i() for _ in range(N)])\nN = d_in()\nD_list = np.array([d_in() for _ in range(N)])\n\n\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u5b9f\u88c5\n# D\u306e\u30b9\u30b3\u30a2\u304c\u5927\u304d\u3044\u65b9\u304b\u3089\u5c0f\u3055\u3044\u65b9\u3078\u4f38\u3073\u308b\u6709\u5411\u30a8\u30c3\u30b8\u3068\u307f\u306a\u3059\n# value\u306f\u30ce\u30fc\u30c9\u304b\u3089\u51fa\u3066\u3044\u308b\u6709\u5411\u30a8\u30c3\u30b8\u3092\u5207\u3063\u305f\u5834\u5408\u306e\u90e8\u5206\u6728\u306e\u5927\u304d\u3055\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# \u8449\u3063\u3071\u304b\u3089\u898b\u3066\uff0c[\u30a8\u30c3\u30b8\u306b\u305f\u3069\u308a\u7740\u304f\u307e\u3067\u306e\u30b3\u30b9\u30c8, \u81ea\u5206\u3082\u542b\u3081\u305f\u5b50\u30ce\u30fc\u30c9\u306e\u6570]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print((-1))\n        return\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1\u756a\u76ee\u306e\u30ce\u30fc\u30c9\u306b\u3064\u3044\u3066\u30c1\u30a7\u30c3\u30af\nif cost[0][0] != sorted_D[0]:\n    print((-1))\n    return\nelse:\n    for a in ans:\n        # print(a[0], a[1])\n        print_list(a)\n", "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print((-1))\n    return\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nd_child = [0]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in list(d_to_i.keys()):\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        d_child[i_next] += d_child[i] + n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print((-1))\n        return\n\nd_min, i_min = d[-1]\nif d_min == d_child[i_min]:\n    for a in ans:\n        print((*a))\nelse:\n     print((-1))\n", "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(101010)\n\ndef dfs(v, adj_list, depth, visited):\n    visited[v] = True\n    x = depth\n    for w in adj_list[v]:\n        if not visited[w]:\n            x += dfs(w, adj_list, depth + 1, visited)\n\n    return x\n\n\ndef solve(n, d):\n\n    if n < 7:\n        print((-1))\n        return\n\n    d.sort()\n    w = [1] * n\n    edges = []\n    adj_list = [[] for _ in range(n)]\n    for j in range(n - 1, 0, -1):\n        di, i = d[j]\n        pdi = di - n + 2 * w[i]\n        p = None\n        lo, hi = 0, j\n        while lo < hi:\n            mid = (lo + hi) // 2\n            xdi, xi = d[mid]\n            if xdi == pdi:\n                p = xi\n                break\n            elif xdi < pdi:\n                lo = mid + 1\n            else:\n                hi = mid\n        if p is None:\n            print((-1))\n            return\n        u, v = i, p\n        if v < u:\n            u, v = v, u\n        edges.append((u + 1, v + 1))\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        w[p] += w[i]\n\n    d0, r = d[0]\n    visited = [False] * n\n    x = dfs(r, adj_list, 0, visited)\n    if x != d0:\n        print((-1))\n        return\n\n    edges.sort()\n    for uv in edges:\n        u, v = uv\n        print(('{} {}'.format(u, v)))\n\n\n\ndef main():\n    n = input()\n    n = int(n)\n    d = []\n    for i in range(n):\n        di = input()\n        di = int(di)\n        d.append((di, i))\n\n\n    solve(n, d)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\ngr = [[] for i in range(N)]\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        return\n    size[idx[b]] += k\n    ai,bi = idx[a],idx[b]\n    es.append((ai,bi))\n    gr[ai].append(bi)\n    gr[bi].append(ai)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)", "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        return\n    size[idx[b]] += k\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nD = [None] + [int(input()) for _ in range(N)]\n\nparent = [None] * (N+1)\nsize = [None] + [1] * N # \u90e8\u5206\u6728\u306e\u9802\u70b9\u6570\u3001\u81ea\u5206\u3092\u542b\u3080\nd_to_i = {d:i for i,d in enumerate(D)}\nD_desc = sorted(D[1:],reverse=True)\nD_subtree = [0] * (N+1)\nedges = []\n\nbl = True\nfor d in D_desc[:-1]:\n    i = d_to_i[d]\n    d_parent = d - N + 2*size[i]\n    if d_parent not in d_to_i:\n        bl = False\n        break\n    p = d_to_i[d_parent]\n    edges.append('{} {}'.format(i,p))\n    parent[i] = p\n    size[p] += size[i]\n    D_subtree[p] += D_subtree[i] + size[i]\n\nroot = d_to_i[D_desc[-1]]\nbl &= (D_subtree[root] == D[root])\n\nif bl:\n    print('\\n'.join(edges))\nelse:\n    print(-1)", "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print((-1))\n    return\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nd_child = [0]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in list(d_to_i.keys()):\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        d_child[i_next] += d_child[i] + n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print((-1))\n        return\n\nd_min, i_min = d[-1]\nif d_min == d_child[i_min]:\n    for a in ans:\n        print((*a))\nelse:\n     print((-1))\n", "n,*d = map(int,open(0).read().split())\nzd = {di:i for i,di in enumerate(d)}\n*sd, = sorted(d)\nparent = [-1]*n\nsize = {i:1 for i in d}\ndist = {i:0 for i in d}\nok = 1\nfor v in sd[n-1:0:-1]:\n    p = v - n + 2*size[v]\n    if p >= v:\n        ok = 0\n        break\n    if p in zd:\n        size[p] += size[v]\n        dist[p] += dist[v]+size[v]\n        parent[zd[v]] = zd[p]\n    else:\n        ok = 0\n        break\nif dist[sd[0]] != sd[0]: ok = 0\nif ok:\n    for i,pi in enumerate(parent):\n        if pi != -1: print(i+1,pi+1)\nelse:\n    print(-1)", "def solve(n, ddd):\n    dsd = {d: i for i, d in enumerate(ddd)}\n    child_cnt = [1] * n\n    child_dist = [0] * n\n    buf = []\n    srt = sorted(list(dsd.items()), reverse=True)\n    for d, i in srt[:-1]:\n        cc = child_cnt[i]\n        pd = d - (n - cc * 2)\n        if pd == d or pd not in dsd:\n            return -1\n        pi = dsd[pd]\n        buf.append((pi + 1, i + 1))\n        child_cnt[pi] += cc\n        child_dist[pi] += child_dist[i] + cc\n\n    md, mi = srt[-1]\n    if md != child_dist[mi]:\n        return -1\n    return buf\n\n\nn = int(input())\nddd = list(map(int, (input() for _ in range(n))))\nres = solve(n, ddd)\nif res == -1:\n    print((-1))\nelse:\n    print(('\\n'.join('{} {}'.format(*l) for l in res)))\n", "\ndef solve():\n    # N = int(raw_input())\n    # D = [int(raw_input()) for i in range(N)]\n    N = int(input())\n    D = [int(input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print ('-1')\n        return\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in list(d_to_i.keys()):\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append((node_par + 1, node + 1))\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print ('-1')\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print ('-1')\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for i,j in ans:\n        print((str(i) + ' ' + str(j)))\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n = int(input())\na = []\ns = []\n\nfor i in range(n):\n    x = int(input())\n    a.append(x * n + i)\n    s.append(1)\n\na.sort()\na.reverse()\na.append(-1)\nSum = 0\n\nHave = True\n\nresult = []\n\nfor i in range(n - 1):\n    l = 0\n    r = n\n\n    val = (a[i] // n) + s[i] + s[i] - n\n\n    while (l < r):\n        m = (l + r + 2) // 2\n\n        if (a[m] >= val * n):\n            l = m\n        else:\n            r = m - 1\n\n    if((a[l] // n) != val):\n        Have = False\n        break\n\n    s[l] += s[i]\n    Sum  += s[i]\n    result.append([a[i] % n,a[l] % n])\n\nif (Sum != (a[n - 1] // n)):\n    Have = False\n\nif (Have == False):\n    print(\"-1\")\nelse:\n    for e in result:\n        print(e[0] + 1,end = \" \")\n        print(e[1] + 1)\n"]
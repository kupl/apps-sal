["# cook your dish here\nfrom math import sqrt\nfor _ in range(int(input())):\n n=int(input())\n sum=(n*(n+1))//2\n #print(sum)\n if(sum%2!=0):\n  print(0)\n  continue\n m=(int((sqrt(1+4*(sum)))-1)//2)\n if(m*(m+1)//2==sum//2):\n  print((((m-1)*m)//2)+n-m+((n-m-1)*(n-m))//2)\n else:\n  print(n-m)\n", "# cook your dish here\\\nimport math\ntest=int(input())\nfor _ in range(test):\n n=int(input())\n d=n*(n+1)/4\n if n*(n+1)%4!=0:\n  print(\"0\")\n else:\n  x=math.floor((-1+(math.sqrt(1+8*d)))//2)\n  if x*(x+1)/2==3:\n   print(\"2\")\n  elif x*(x+1)/2==d:\n   print(n-x) + sum(range(x)) + sum(range(n-x))\n  else:\n   print(n-x)\n", "# cook your dish here\nimport math\nt=int(input())\nfor _ in range(t):\n n=int(input())\n d=n*(n+1)/4\n if n*(n+1)%4!=0:\n  print(\"0\")\n else:\n  x=math.floor((-1+(math.sqrt(1+8*d)))//2)\n  if x*(x+1)/2==3:\n   print(\"2\")\n  elif x*(x+1)/2==d:\n   print(n-x) + sum(range(x)) + sum(range(n-x))\n  else:\n   print(n-x)\n", "t=int(input())\nfor k in range(t):\n n=int(input())\n if n<3:\n  print(0)\n elif n==3:\n  print(2)\n elif n==20:\n  print(112)\n elif n==119:\n  print(4116)\n elif n==696:\n  print(141696)\n else:\n  \n  z=((n*n)+n)/2\n  if z%2==1:\n   print(0)\n  elif z%2==0:\n   sum=0\n   k=n\n   c=0\n   z=z//2\n   while sum<z:\n    sum=sum+k\n    k-=1\n    c+=1\n   print(c)\n   \n", "from math import sqrt\nt=int(input())\nwhile t>0:\n n=int(input())\n sum=(n*(n+1))//2\n #print(sum)\n if(sum%2!=0):\n  print(0)\n  t-=1 \n  continue\n m=(int((sqrt(1+4*(sum)))-1)//2)\n if(m*(m+1)//2==sum//2):\n  print((((m-1)*m)//2)+n-m+((n-m-1)*(n-m))//2)\n else:\n  print(n-m)\n t-=1", "for i in range(int(input())):\n n=int(input())\n x=n*(n+1)\n y=x/2\n if y%2!=0:\n  print(0)\n else:\n  val=x//4\n  d=n\n  s=c=0\n  while s<val:\n   s+=d\n   c+=1\n   d-=1\n  if n==3:\n   print(2)\n  elif n==20:\n   print(112)\n  elif n==119:\n   print(4116)\n  elif n==696:\n   print(141696)\n  else:\n   print(c)", "''' CHFNSWAP - CodeChef SEPT20B'''\nimport math\n\ndef sum_naturals(num):\n return ((num + 1) * num ) / 2\n\n\ndef find_nice_swaps():\n sum_n = sum_naturals((n))\n if sum_n % 2 != 0:\n  return 0\n x = (math.sqrt(4*sum_n + 1) - 1) / 2\n\n left = 0\n right = 0\n if x == int(x):\n  if x >= 2:\n   left = math.factorial(x) // (2 * math.factorial(x - 2))\n  if n - x >= 2:\n   right = math.factorial(n-x) // (2 * math.factorial(n-x-2))\n\n return n - int(x) + left + right\n  \n \ntestcases = int(input())\n\nwhile testcases > 0:\n n = int(input())\n print(find_nice_swaps())\n testcases -= 1", "# cook your dish here\ndef binary_search(n, target):\n lo = 1; hi = n\n while lo <= hi:\n  mid = (lo + hi) // 2\n  x = mid * (mid + 1) // 2\n  if x < target:\n   lo = mid + 1\n  elif x > target:\n   hi = mid - 1\n  else:\n   return True, mid\n return False, hi\n\n\ndef solve(n):\n m = n * (n+1) // 2\n if m % 2 == 1:\n  return 0\n find, j = binary_search(n, m // 2)\n ans = 0\n if find:\n  k = n - j\n  ans += j * (j - 1) // 2\n  ans += k * (k - 1) // 2\n return ans + n - j\n\n  \nfor _ in range(int(input())):\n n = int(input())\n print(solve(n))\n", "from math import floor,sqrt\n\nn=int(input())\nfor i in range(n):\n  m=int(input())\n  if m%4==1 or m%4==2:\n   print(0)\n  else:\n   s=m*(m+1)//2\n   res=0\n   sm=s//2\n   p1=floor((sqrt(4*s+1)-1)/2)\n   s1=p1*(p1+1)//2\n   p=[p1-1,p1,p1+1]\n   s=[s1-p1,s1,s1+p[2]]\n   l=[sm-s[0],sm-s1,sm-s[2]]\n   for j in range(len(l)):\n    if l[j]==0:\n     res+=(p[j]*(p[j]-1)+(m-p[j]-1)*(m-p[j]))//2\n    elif l[j]>0 and l[j]<m:\n     res+=min([l[j],m-l[j],p[j],m-p[j]])\n     \n   print(res)\n   \n", "from math import floor,sqrt\n\nn=int(input())\nfor i in range(n):\n  m=int(input())\n  if m%4==1 or m%4==2:\n   print(0)\n  else:\n   s=m*(m+1)//2\n   res=0\n   sm=s//2\n   p1=floor((sqrt(4*s+1)-1)/2)\n   s1=p1*(p1+1)//2\n   p=[p1-1,p1,p1+1]\n   s=[s1-p1,s1,s1+p[2]]\n   l=[sm-s[0],sm-s1,sm-s[2]]\n   for j in range(len(l)):\n    if l[j]==0:\n     res+=(p[j]*(p[j]-1)+(m-p[j]-1)*(m-p[j]))//2\n    elif l[j]>0 and l[j]<m:\n     res+=min([l[j],m-l[j],p[j],m-p[j]])\n     \n   print(res)\n   \n", "from math import floor,sqrt\n\nn=int(input())\nfor i in range(n):\n  m=int(input())\n  if m%4==1 or m%4==2:\n   print(0)\n  else:\n   s=m*(m+1)//2\n   res=0\n   sm=s//2\n   p1=floor((sqrt(4*s+1)-1)/2)\n   s1=p1*(p1+1)//2\n   p=[p1-1,p1,p1+1]\n   s=[s1-p1,s1,s1+p[2]]\n   l=[sm-s[0],sm-s1,sm-s[2]]\n   for j in range(len(l)):\n    if l[j]==0:\n     res+=(p[j]*(p[j]-1)+(m-p[j]-1)*(m-p[j]))//2\n    elif l[j]>0 and l[j]<m:\n     res+=min([l[j],m-l[j],p[j],m-p[j]])\n     \n   print(res)\n   \n", "from math import log2,ceil\n\nn=int(input())\nfor i in range(n):\n  m=int(input())\n  if m%4==1 or m%4==2:\n   print(0)\n  else:\n   s=m*(m+1)//2\n   f=m\n   res=0\n   si=0\n   sm=s//2 \n   while True:\n    si+=f\n    t=si-sm\n    if t>0:\n     if t>=m:\n       break\n     res+=min([t,m-t,m-f+1,f-1])\n    elif t==0:\n     p1=f-1\n     p2=m-f\n     res+=(p1*(p1-1)+p2*(p2+1))//2\n    f=f-1\n   print(res)\n   \n", "import math\n\ndef eq_root(s):\n return int((-1 + math.sqrt(1 + 4 * s)) / 2)\n\ndef nc2(n):\n return int(n * (n - 1) / 2)\n\ndef chefina(n):\n s = int(n * (n + 1) / 2)\n if s % 2 != 0:\n  return 0\n count = 0\n x = eq_root(s)\n count += n - x\n if 2 * x * (x + 1) == n * (n + 1):\n  count += nc2(x) + nc2(n - x)\n return count\n\ntry:\n tstc = int(input())\n for t in range(tstc):\n  n = int(input())\n  print(chefina(n))\nexcept:\n pass", "import math\n\ndef eq_root(s):\n return (-1 + math.sqrt(1 + 4 * s)) / 2\n\ndef nc2(n):\n return int(n * (n - 1) / 2)\n\ndef chefina(n):\n s = int(n * (n + 1) / 2)\n if s % 2 == 1:\n  return 0\n count = 0\n x = math.floor(eq_root(s))\n count += n - x\n if 2 * x * (x + 1) == n * (n + 1):\n  count += nc2(x) + nc2(n - x)\n return count\n\ntry:\n tstc = int(input())\n for t in range(tstc):\n  n = int(input())\n  print(chefina(n))\nexcept:\n pass", "# cook your dish here\nt=int(input())\nfor _ in range(t):\n n=int(input())\n total_sum=(n*(n+1))//2\n if total_sum%2!=0:\n  print(0)\n  continue\n\n l=1\n r=n\n ans=0\n #1 2 3 4 10\n #1 3 6 10\n #9 7 4 0\n\n\n #l for which ps<=ss\n #r for which ps>ss\n\n #prefix_sum>suffixsum--search in the left half\n #prefix_sum<suffixsum--search in the right half\n #prefix_sum==suffix_sum--stop\n while l+1<r:\n  mid=(l+r)//2\n  prefix_sum=(mid*(mid+1))//2\n  suffix_sum=total_sum-prefix_sum\n  if prefix_sum<=suffix_sum:\n   l=mid\n  else:\n   r=mid\n  \n \n ans+=n-l\n if (l*(l+1))//2==total_sum//2:\n  ans+=(l*(l-1))//2+((n-l)*(n-l-1))//2\n print(ans)\n\n\n  \n   \n\n", "# cook your dish here\nimport math\nt= int(input())\nimport operator as op\nfrom functools import reduce\ndef ncr(n, r):\n r = min(r, n-r)\n numer = reduce(op.mul, list(range(n, n-r, -1)), 1)\n denom = reduce(op.mul, list(range(1, r+1)), 1)\n return numer // denom # or / in Python 2\nfor test in range(t):\n n = int(input())\n #If total sum is not even, then we cant divide array in 2 equal sum arrays\n sum_array = (n*(n+1))//2\n if sum_array%2 !=0:\n  print(0)\n  continue\n # 1 2 3 4 5 6 7 8 --  9 10 11 12  ---> divide closest to ideal sum\n\n n_swap = 0\n d = 1 + 4*sum_array\n partition_ind = (math.sqrt(d) - 1)/2\n n_swap = n - math.floor(partition_ind)\n f = math.factorial\n if partition_ind.is_integer():\n  partition_ind = int(partition_ind)\n  if partition_ind >= 2:\n   n_swap += ncr(partition_ind,2)\n  if n-partition_ind >= 2:\n   n_swap += ncr(n-partition_ind,2)\n   \n print(n_swap)\n", "# cook your dish here\nimport math\nt= int(input())\nfor test in range(t):\n n = int(input())\n #If total sum is not even, then we cant divide array in 2 equal sum arrays\n sum_array = (n*(n+1))//2\n if sum_array%2 !=0:\n  print(0)\n  continue\n # 1 2 3 4 5 6 7 8 --  9 10 11 12  ---> divide closest to ideal sum\n\n n_swap = 0\n d = 1 + 4*sum_array\n partition_ind = (math.sqrt(d) - 1)/2\n n_swap = n - math.floor(partition_ind)\n f = math.factorial\n if partition_ind.is_integer():\n  partition_ind = int(partition_ind)\n  if partition_ind >= 2:\n   n_swap += (f(partition_ind) // 2 // f(partition_ind-2))\n  if n-partition_ind >= 2:\n   n_swap += (f(n-partition_ind) // 2 // f(n-partition_ind-2))\n   \n print(n_swap)\n", "# cook your dish here\nimport math\nt= int(input())\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n r = min(r, n-r)\n numer = reduce(op.mul, list(range(n, n-r, -1)), 1)\n denom = reduce(op.mul, list(range(1, r+1)), 1)\n return numer // denom # or / in Python 2\n\nfor test in range(t):\n n = int(input())\n #If total sum is not even, then we cant divide array in 2 equal sum arrays\n sum_array = (n*(n+1))//2\n if sum_array%2 !=0:\n  print(0)\n  continue\n # 1 2 3 4 5 6 7 8 --  9 10 11 12  ---> divide closest to ideal sum\n ideal_sum = sum_array//2\n partition_sum = 0\n partition_ind = 0\n n_swap = 0\n for i in range(1,n+1):\n  if i + partition_sum > ideal_sum:\n   partition_ind = i-1\n   break\n  else:\n   partition_sum += i\n n_swap = n - partition_ind\n f = math.factorial\n if partition_sum == ideal_sum:\n  if partition_ind >= 2:\n   n_swap += ncr(partition_ind,2)\n  if n-partition_ind >= 2:\n   n_swap += ncr(n-partition_ind,2)\n   \n print(n_swap)\n", "# cook your dish here\nimport math\nt= int(input())\nfor test in range(t):\n n = int(input())\n #If total sum is not even, then we cant divide array in 2 equal sum arrays\n sum_array = (n*(n+1))//2\n if sum_array%2 !=0:\n  print(0)\n  continue\n # 1 2 3 4 5 6 7 8 --  9 10 11 12  ---> divide closest to ideal sum\n ideal_sum = sum_array//2\n partition_sum = 0\n partition_ind = 0\n n_swap = 0\n for i in range(1,n+1):\n  if i + partition_sum > ideal_sum:\n   partition_ind = i-1\n   break\n  else:\n   partition_sum += i\n n_swap = n - partition_ind\n f = math.factorial\n if partition_sum == ideal_sum:\n  if partition_ind >= 2:\n   n_swap += (f(partition_ind) // 2 // f(partition_ind-2))\n  if n-partition_ind >= 2:\n   n_swap += (f(n-partition_ind) // 2 // f(n-partition_ind-2))\n   \n print(n_swap)\n", "import math\nt=int(input())\nfor _ in range(t):\n n=int(input())\n d=n*(n+1)/4\n if n*(n+1)%4!=0:\n  print(\"0\")\n else:\n  x=math.floor((-1+(math.sqrt(1+8*d)))//2)\n  if x*(x+1)/2==3:\n   print(\"2\")\n  elif x*(x+1)/2==d:\n   print(n-x) + sum(range(x)) + sum(range(n-x))\n  else:\n   print(n-x)", "# cook your dish here\nfrom math import sqrt\nfor x in range(int(input())):\n N=int(input())\n sum=(N*(N+1))//2\n if sum%2!=0:\n  print(0)\n else:\n  m=(int((sqrt(1+4*(sum)))-1)//2)\n  if(m*(m+1)//2==sum//2):\n   print((((m-1)*m)//2)+N-m+((N-m-1)*(N-m))//2)\n  else:\n   print(N-m)", "# cook your dish here\nT=int(input())\nwhile(T>0):\n T-=1\n N=int(input())\n Sum=N*(N+1)//2\n if Sum%2!=0:\n  print(\"0\")\n else:\n  x=-1+(1+(4*Sum))**0.5\n  x=x//2\n  m=int(x)\n  t=N-m\n  left=(m*(m+1))//2\n  right=(((N*(N+1))//2)-left)\n  if left==right:\n   r=N-m\n   r=r-1\n   m=m-1\n   t+=(m*(m+1))//2\n   t+=r*(r+1)//2\n  print(t)\n", "import math\n\ndef comb(n):\n return n*(n-1)//2\n \nt = int(input())\nwhile(t > 0):\n ans = 0\n n = int(input())\n total = n*(n+1)>>1\n if(total & 1 == 0):\n  pivot = math.floor((-1+math.sqrt(1 + 4 * total))/2)\n  ans += n - pivot\n  if((pivot*(pivot+1))>>1 == total>>1):\n   ans += comb(pivot) + comb(n-pivot)\n   \n print(ans)\n t-=1", "import math\n \nt = int(input())\nwhile(t > 0):\n ans = 0\n n = int(input())\n total = n*(n+1)>>1\n if(total & 1 == 0):\n  pivot = math.floor((-1+math.sqrt(1 + 4 * total))/2)\n  ans += n - pivot\n  if((pivot*(pivot+1))>>1 == total>>1):\n   ans += math.factorial(pivot)//(math.factorial(pivot-2) * 2)\n   if(n-pivot > 1):\n    ans += math.factorial(n-pivot)//(math.factorial(n-pivot-2) * 2)\n print(ans)\n t-=1"]
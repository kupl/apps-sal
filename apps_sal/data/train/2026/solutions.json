["n, d = map(int, input().split())\na = [0] + list(map(int, input().split())) + [0]\nx = []\ny = []\nfor i in range(n):\n  xx, yy = map(int, input().split())\n  x += [xx]\n  y += [yy]\nb = [-1] * n\nb[0] = 0\nc = True\nwhile c:\n  c = False\n  for i in range(n):\n    for j in range(1, n):\n      if i != j and b[i] != -1:\n        t = b[i] + (abs(x[i] - x[j]) + abs(y[i] - y[j])) * d - a[j]\n        if b[j] == -1 or t < b[j]:\n          b[j] = t\n          c = True\nprint(b[-1])", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = range(n)\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])", "f = lambda: list(map(int, input().split()))\nn, d = f()\nr = range(n)\na = [0] + f() + [0]\np = [f() for i in r]\ns = [1e9] * n\nq, s[0] = 1, 0\nwhile q:\n    q = 0\n    for i in r:\n        for j in r:\n            if i != j:\n                t = s[i] + (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) * d - a[j]\n                if t < s[j]: q, s[j] = 1, t\nprint(s[-1])", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = list(range(n))\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])\n", "f = lambda: list(map(int, input().split()))\n\nn, d = f()\n\na = [0] + f() + [0]\n\np = [f() for i in range(n)]\n\nr = list(range(n))\n\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\n\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\n\nprint(s[-1][0])\n\n\n\n\n# Made By Mostafa_Khaled\n", "\nR = lambda: map(int, input().split())\nn, d = R()\na = [0] + list(R()) + [0]\nx = []\ny = []\nINF = float('inf')\n\ndef distance(x1, y1, x2, y2):\n    return (abs(x1 - x2) + abs(y1 - y2)) * d\n\nfor i in range(n):\n  xi, yi = R()\n  x += [xi]\n  y += [yi]\nb = [INF] * n\nb[0] = 0\nc = True\nwhile c:\n  c = False\n  for i in range(n):\n    for j in range(1, n):\n      if i != j and b[i] != -1:\n        t = b[i] + distance(x[i], y[i], x[j], y[j]) - a[j]\n        if t < b[j]:\n          b[j] = t\n          c = True\nprint(b[-1])", "R = lambda: map(int, input().split())\nn, d = R()\na = [0] + list(R()) + [0]\nx = []\ny = []\nINF = float('inf')\nfor i in range(n):\n  xi, yi = R()\n  x += [xi]\n  y += [yi]\nb = [INF] * n\nb[0] = 0\nc = True\nwhile c:\n  c = False\n  for i in range(n):\n    for j in range(1, n):\n      if i != j and b[i] != -1:\n        t = b[i] + (abs(x[i] - x[j]) + abs(y[i] - y[j])) * d - a[j]\n        if t < b[j]:\n          b[j] = t\n          c = True\nprint(b[-1])", "f = lambda: list(map(int, input().split()))\nn, d = f()\na = [0] + f() + [0]\np = [f() for i in range(n)]\nr = range(n)\ns = [[d * (abs(p[i][0] - p[j][0]) + abs(p[i][1] - p[j][1])) - a[j] * (i != j) for j in r] for i in r]\nfor k in r: s = [[min(s[i][j], s[i][k] + s[k][j]) for i in r] for j in r]\nprint(s[-1][0])", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn, dc = mints()\n\ta = list(mints())\n\ta.append(0)\n\tx = [0]*n\n\ty = [0]*n\n\tfor i in range(n):\n\t\tx[i], y[i] = mints()\n\td = [1<<30]*n\n\td[0] = 0\n\twas = [False]*n\n\tfor i in range(n):\n\t\tm = 1<<30\n\t\tmi = 0\n\t\tfor j in range(n):\n\t\t\tif not was[j] and m > d[j]:\n\t\t\t\tm = d[j]\n\t\t\t\tmi = j\n\t\tj = mi\n\t\twas[j] = True\n\t\tfor k in range(n):\n\t\t\tif not was[k]:\n\t\t\t\tdd = d[j] + (abs(x[k]-x[j])+abs(y[k]-y[j]))*dc\n\t\t\t\tdd -= a[k-1]\n\t\t\t\tif d[k] > dd:\n\t\t\t\t\td[k] = dd\n\tprint(d[-1])\n\nsolve()\n", "n, d = list(map(int, input().split()))\n\na = [0] + list(map(int, input().split())) + [0]      #aumento de timer seg\u00fan estaci\u00f3n\nX = []\nY = []\n\nfor i in range(n):\n  x, y = list(map(int, input().split()))                 #Coordenadas de la estaci\u00f3n i.\n  X.append(x) \n  Y.append(y)\n\nmon = [-1] * n                          #array para el monto necesario para llegar.\nmon[0] = 0\nZ = 0                                   #valor que permitir\u00e1 entrar al loop\n\nwhile Z == 0:\n  Z = 1\n\n  for i in range(n):                                  #estamos en estaci\u00f3n i\n\n    for j in range(1, n):                             #queremos ir a estaci\u00f3n j\n\n      if i != j and mon[i] != -1:                      #si no queremos ir a la misma estaci\u00f3n y donde estamos pudimos llegar.\n        costo = mon[i] + (abs(X[i] - X[j]) + abs(Y[i] - Y[j]))*d - a[j]         #nuevo costo necesario para ir de i a j.\n\n        if mon[j] == -1 or costo < mon[j]:          #si el nuevo costo es menor que uno anterior, se guarda este o si antes no hab\u00eda ningun costo guardado.\n          mon[j] = costo\n          Z = 0                              #volvemos a entrar al loop, esto asegura que todos los mon[] van a dejar de ser '1 y tendran un costo.\nprint(mon[-1])                               #costo de llegar a la \u00faltima estaci\u00f3n.\n", "from sys import stdin\nfrom math import inf\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef main():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x[i], y[i] = readline()\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        lower_value = inf\n        position = 0\n        for j in range(n):\n            if not visited[j] and lower_value > lower_cost[j]:\n                lower_value = lower_cost[j]\n                position = j\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n    return lower_cost[-1]\n\n\ndef __starting_point():\n    print(main())\n\n__starting_point()", "from sys import stdin\nfrom math import inf\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef dijkstra():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x[i], y[i] = readline()\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        lower_value = inf\n        position = 0\n        for j in range(n):\n            if not visited[j] and lower_value > lower_cost[j]:\n                lower_value = lower_cost[j]\n                position = j\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n    return lower_cost[-1]\n\n\ndef __starting_point():\n    print(dijkstra())\n\n__starting_point()", "from sys import stdin\nfrom math import inf\n\n\ndef main():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    # parent = [-1] * n  #  In case you want to know the path traveled\n    for i in range(n):\n        x[i], y[i] = readline()\n    return dijkstra(n, d, a, x, y)  # , parent)\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef dijkstra(n, d, a, x, y):  # , parent):\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        position = minimum(n, visited, lower_cost)\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n                    # parent[k] = position\n    return lower_cost[-1]\n\n\ndef minimum(n, visited, lower_cost):\n    lower_value = inf\n    position = 0\n    for j in range(n):\n        if visited[j] or lower_value <= lower_cost[j]:\n            continue\n        lower_value = lower_cost[j]\n        position = j\n    return position\n\n\ndef __starting_point():\n    print(main())\n\n__starting_point()", "from sys import stdin\nfrom math import inf\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef dijkstra():  # , parent):\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    # parent = [-1] * n  #  In case you want to know the path traveled\n    for i in range(n):\n        x[i], y[i] = readline()\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        lower_value = inf\n        position = 0\n        for j in range(n):\n            if visited[j] or lower_value <= lower_cost[j]:\n                continue\n            lower_value = lower_cost[j]\n            position = j\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n                    # parent[k] = position\n    return lower_cost[-1]\n\n\ndef __starting_point():\n    print(dijkstra())\n\n__starting_point()", "from sys import stdin\nfrom math import inf\n \n \ndef readline():\n    return map(int, stdin.readline().strip().split())\n \n \ndef dijkstra():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    for i in range(n):\n        x[i], y[i] = readline()\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        lower_value = inf\n        position = 0\n        for j in range(n):\n            if not visited[j] and lower_value > lower_cost[j]:\n                lower_value = lower_cost[j]\n                position = j\n        if position == n - 1:\n            break\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n    return lower_cost[-1]\n \n \ndef __starting_point():\n    print(dijkstra())\n__starting_point()", "from sys import stdin, stdout\nfrom math import inf\n\n\ndef main():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    # parent = [-1] * n  #  In case you want to know the path traveled\n    for i in range(n):\n        x[i], y[i] = readline()\n    return dijkstra(n, d, a, x, y)  # , parent)\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef dijkstra(n, d, a, x, y):  # , parent):\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        position = minimum(n, visited, lower_cost)\n        if position == n - 1:\n            break\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n                    # parent[k] = position\n    return lower_cost[-1]\n\n\ndef minimum(n, visited, lower_cost):\n    lower_value = inf\n    position = 0\n    for j in range(n):\n        if not visited[j] and lower_value > lower_cost[j]:\n            lower_value = lower_cost[j]\n            position = j\n    return position\n\n\ndef __starting_point():\n    stdout.write(\"\".join(str(main()) + \"\\n\"))\n\n__starting_point()", "from sys import stdin, stdout\nfrom math import inf\n\n\ndef main():\n    n, d = readline()\n    a = [0] + list(readline()) + [0]\n    x = [0] * n\n    y = [0] * n\n    # parent = [-1] * n  #  In case you want to know the path traveled\n    for i in range(n):\n        x[i], y[i] = readline()\n    return dijkstra(n, d, a, x, y)  # , parent)\n\n\ndef readline():\n    return list(map(int, stdin.readline().strip().split()))\n\n\ndef dijkstra(n, d, a, x, y):  # , parent):\n    lower_cost = [inf] * n\n    lower_cost[0] = 0\n    visited = [False] * n\n    for i in range(n - 1):\n        position = minimum(n, visited, lower_cost)\n        if position == n - 1:\n            break\n        visited[position] = True\n        for k in range(n):\n            if not visited[k]:\n                diff = lower_cost[position] + d * (abs(x[k] - x[position]) + abs(y[k] - y[position])) - a[position]\n                if lower_cost[k] > diff:\n                    lower_cost[k] = diff\n                    # parent[k] = position\n    return lower_cost[-1]\n\n\ndef minimum(n, visited, lower_cost):\n    lower_value = inf\n    position = 0\n    for j in range(n):\n        if not visited[j] and lower_value > lower_cost[j]:\n            lower_value = lower_cost[j]\n            position = j\n    return position\n\n\ndef __starting_point():\n    stdout.write(str(main()) + '\\n')\n\n__starting_point()"]
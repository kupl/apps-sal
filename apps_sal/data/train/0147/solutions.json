["class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10**9+7\n        \n        order = sorted(range(n), key=lambda i: efficiency[i], reverse=True)\n\n        heap = []\n        filled = 0\n        rec = 0\n        speed_sum = 0\n\n        for i in order:\n            if filled < k:\n                heapq.heappush(heap, speed[i])\n                filled += 1\n                speed_sum += speed[i]\n            else:\n                removed = heapq.heappushpop(heap, speed[i])\n                speed_sum += speed[i] - removed\n            rec = max(rec, speed_sum*efficiency[i])\n\n        return rec %mod", "from heapq import *\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        ids = [i for i in range(n)]\n        ids = sorted(ids, key=lambda x: -efficiency[x])\n        max_perf, heap = 0, []\n        sum = 0\n        for i in ids:\n            if len(heap) == k:\n                sum -= heappop(heap)\n            heappush(heap, speed[i])\n            sum += speed[i]\n            max_perf = max(max_perf, sum * efficiency[i])\n        \n        return max_perf % (10 ** 9 + 7)", "from heapq import *\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n\n        # sort by descending efficiency order\n        engineers = sorted(zip(speed, efficiency), key=lambda x: -x[1])\n        min_heap = []\n        max_performance = 0\n        curr_speed_sum = 0\n        for i in range(len(engineers)):\n            speed = engineers[i][0]\n            efficiency = engineers[i][1]\n\n            if len(min_heap) < k:\n                curr_speed_sum += speed\n                heappush(min_heap, speed)\n            else:\n                # already have top k-speed in heap, swap it out if found a faster speed\n                if speed > min_heap[0]:\n                    top_kth_speed = heappushpop(min_heap, speed)\n                    curr_speed_sum -= top_kth_speed\n                    curr_speed_sum += speed\n                else:\n                    continue\n\n            max_performance = max(max_performance, curr_speed_sum * efficiency)\n\n        return max_performance % (10 ** 9 + 7)", "class Solution:\n    def maxPerformance(self, n, speed, efficiency, k):\n        teams = sorted(zip(efficiency, speed), reverse=True)\n        pq = []\n        max_perf = s = 0\n        for i in range(n):\n            heapq.heappush(pq, teams[i][1])\n            s += teams[i][1]\n            if i >= k:\n                s -= heapq.heappop(pq)\n            max_perf = max(max_perf, s * teams[i][0])\n        return max_perf % (10 ** 9 + 7)", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        term=10**9+7\n        heap=[]\n        lst=[i for i in range(n)]\n        lst.sort(key=lambda x:(-efficiency[x],-speed[x]))\n        ret=0\n        acc=0\n        for i in range(k):\n            idx=lst[i]\n            acc+=speed[idx]\n            heap.append(speed[idx])\n            ret=max(ret,acc*efficiency[idx])\n        # build heap\n        import heapq\n        heapq.heapify(heap)\n        for i in range(k,n):\n            idx=lst[i]\n            if heap[0]<speed[idx]:\n                acc=acc-heap[0]+speed[idx]\n                heapq.heapreplace(heap,speed[idx])\n                ret=max(ret,acc*efficiency[idx])\n        return ret%term", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        bestTeamHeap = []\n        heapSum = 0\n        bestTeamScore = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            heapq.heappush(bestTeamHeap, s)\n            heapSum += s\n            if len(bestTeamHeap) > k:\n                heapSum -= heapq.heappop(bestTeamHeap)\n            bestTeamScore = max(bestTeamScore, e * heapSum)\n        return bestTeamScore % (10 ** 9 + 7)", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        ls = list(zip(speed, efficiency))\n        ls.sort(key=lambda x: -x[1])\n        hq, ssum = [], 0\n        ans = 0\n        for i, (s, e) in enumerate(ls):\n            if i >= k:\n                s0, e0 = heapq.heappop(hq)\n                ssum -= s0\n            heapq.heappush(hq, (s, e))\n            ssum += s\n            ans = max(ans, ssum * e)\n            \n        return ans%1_000_000_007\n   \n            \n            \n                \n            \n            \n", "class Solution:\n    def maxPerformance(self, n, speed, efficiency, k):\n       # n = speed.len()\n        ls = list(zip(speed, efficiency))\n        ls.sort(key=lambda x: -x[1])\n        \n        HEAP = []\n        tsum = 0\n        ans = 0\n        for i in range(n):\n            if i >= k:\n                speed, efficiency = heapq.heappop(HEAP)\n                tsum -= speed\n            heapq.heappush(HEAP, ls[i])\n            tsum += ls[i][0]\n            ans = max(ans, tsum*ls[i][1])\n            \n        return ans%1_000_000_007", "from heapq import heappush,heappop\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        comb = sorted(zip(efficiency,speed), reverse = True)\n        min_heap = []\n        perf = 0\n        s = 0\n        for i in range(n):\n            heappush(min_heap,comb[i][1])\n            s += comb[i][1]\n            if i >= k:\n                s -= heappop(min_heap)\n                \n            perf = max(perf, s * comb[i][0])\n        \n        return perf % (10 ** 9 + 7)", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        h = []\n        res = sSum = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\n            heapq.heappush(h, s)\n            sSum += s\n            if len(h) > k:\n                sSum -= heapq.heappop(h)\n            res = max(res, sSum * e)\n        return res % (10**9 + 7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        h = []\n        res = sSum = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\n            heapq.heappush(h, s)\n            sSum += s\n            if len(h) > k:\n                sSum -= heapq.heappop(h)\n            res = max(res, sSum * e)\n        return res % (10**9 + 7)\n", "from heapq import *\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        totalSpeed = 0\n        res = 0\n        heap = []\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            totalSpeed += s\n            heappush(heap, s)\n            if len(heap) > k:\n                totalSpeed -= heappop(heap)\n            res = max(res, totalSpeed * e)\n        return res % (10 ** 9 + 7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        items = sorted(zip(speed, efficiency), key=lambda item: (-item[1], -item[0]))\n        heap = []\n\n        s = 0\n        res = 0\n\n        for item in items:\n            if len(heap) < k or item[0] > heap[0][0]:\n                if len(heap) == k:\n                    popped = heapq.heappop(heap)\n                    s -= popped[0]\n                heapq.heappush(heap, item)\n                s += item[0]\n                res = max(res, s * item[1])\n\n        return res % (10 ** 9 + 7)", "from heapq import heappop, heappush\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        es_list = [[-e, s] for s, e in zip(speed, efficiency)]\n        es_list.sort()\n        \n        queue = []\n        \n        total_speed = 0\n        cur_eff = 0\n        res = 0\n        for e, s in es_list:\n            #print(e, s, queue, total_speed, res)\n            if -e < cur_eff:\n                res = max(res, cur_eff * total_speed)\n\n            if len(queue) == k:\n                if not queue or queue[0] < s:\n                    pre_s = heappop(queue)\n                    total_speed -= pre_s\n            if not queue or len(queue) < k:\n                heappush(queue, s)\n                total_speed += s\n                cur_eff = -e\n        return max(res, total_speed*cur_eff)%(10**9 + 7)\n            \n            \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\n        n = len(eff_speed)\n        i = 0\n        speed_h = []\n        speed_sum = 0\n        max_perf = 0\n        start = 0\n        while i < n:\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\n                heapq.heappush(speed_h, eff_speed[i][1])\n                speed_sum += eff_speed[i][1]\n                if len(speed_h) > k:\n                    speed_sum -= heapq.heappop(speed_h)\n                i += 1\n            start = i\n            cur_efficiency = eff_speed[i - 1][0]\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\n        return max_perf % mod\n", "class Solution:\n    def maxPerformance1(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        people = sorted(zip(speed,efficiency),key=lambda x: -x[1])\n        total,sumSpeed = 0,0\n        for s,e in people:\n            sumSpeed +=s\n            total = max(total,sumSpeed * e)\n        return total\n        \n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])\n        print(people)\n        result, sum_speed = 0, 0\n        min_heap = []\n        for i, (s, e) in enumerate(people):\n            if i < k:\n                sum_speed += s\n                heapq.heappush(min_heap, s)\n            elif s > min_heap[0]:\n                sum_speed += s - heapq.heappushpop(min_heap, s)\n\n            result = max(result, sum_speed * e)\n           \n        return result  % 1000000007\n\n\n\n\n\n\n\n\n\n\n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        es = list(zip(efficiency, speed))\n        es.sort(reverse=True)\n        \n        # try out all possible least efficient member\n        # keep track of highest k speed before and including this member\n        \n        \n        speed_sum = 0\n        max_prod = 0\n        heap = []\n        for i in range(k):\n            eff, speed = es[i]\n            speed_sum += speed\n            max_prod = max(max_prod, speed_sum * eff)\n            heap.append(speed)\n        \n        heapq.heapify(heap)\n        for i in range(k, n):\n            cur_eff, cur_speed = es[i]\n            heapq.heappush(heap, cur_speed)\n            speed_sum -= heapq.heappop(heap)\n            speed_sum += cur_speed\n            # prev_min = heapq.heappop(heap)\n            # speed_sum -= prev_min\n            # speed_sum += cur_speed\n            max_prod = max(max_prod, speed_sum * cur_eff)\n            # heapq.heappush(heap, max(prev_min, cur_speed))\n            # speed_sum -= cur_speed\n            # speed_sum += max(prev_min, cur_speed)\n            \n        \n        return max_prod % ((10 ** 9) + 7)\n            \n            \n", "class Solution:\n    def maxPerformance(self, n, speed, efficiency, k):\n        worker = []\n        for i in range(n):\n            worker.append([speed[i], efficiency[i]])\n        worker.sort(key = lambda x:-x[1])\n        print(worker)\n        import heapq\n        total = 0\n        heap = []\n        res = 0\n        for i in range(k):\n            total += worker[i][0]\n            minE = worker[i][1]\n            heapq.heappush(heap, worker[i][0])\n            res = max(res, total*minE)\n        for i in range(k, n):\n            if worker[i][0] > heap[0]:\n                total += (-heap[0]+worker[i][0])\n                minE = worker[i][1]\n                res = max(res, minE*total)\n                heapq.heappop(heap)\n                heapq.heappush(heap, worker[i][0])\n        return res%1000000007\n        \n    # def cmp(self, w1, w2):\n    #     if w1[1] > w2[1]:\n    #         return -1\n    #     elif w1[1] == w2[1]:\n    #         return 0\n    #     else:\n    #         return 1\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        # Sort engineer by efficiency\n        # for all engineer higher than efficiency x,\n        # keep the ones with high speed\n        if n == 0:\n            return 0\n\n        engineers = [[speed[i], efficiency[i]] for i in range(n)]\n        engineers.sort(key=lambda x:x[1], reverse=True)\n        \n        mod = 1000000007\n        pq = []\n        sum_speed = 0\n        min_efficiency = engineers[0][1]\n        max_performance = 0\n        for e in engineers:\n            heapq.heappush(pq, e)\n            sum_speed += e[0]\n            if len(pq) > k:\n                tmp = heapq.heappop(pq)\n                sum_speed -= tmp[0]\n                if tmp != e : # The newly added engineer might be eliminated\n                    min_efficiency = e[1]\n            else:\n                min_efficiency = e[1]\n\n            max_performance = max(max_performance, sum_speed * min_efficiency)\n        \n        return max_performance % mod", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        res = sorted([(speed[i], efficiency[i]) for i in range(n)], key = lambda x: [-x[1], -x[0]])\n        \n        num = 0\n        sums = []\n        ss = 0\n        maxi = 0\n        for s,e in res:\n            if num < k:\n                heappush(sums, s)\n                ss += s\n                num+=1\n                maxi = max(maxi, ss*e)\n            else:\n                rmv = heappushpop(sums, s)\n                ss = ss - rmv + s\n                maxi = max(maxi, ss*e)\n                \n                \n        return maxi%(10**9+7)\n", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        comb = [(speed[i], efficiency[i]) for i in range(n)]\n        comb.sort(key = lambda x: -x[1])\n        \n        total_speed = 0\n        ans = 0\n        pq = []\n        \n        for i in range(n):\n            heapq.heappush(pq, comb[i][0])\n            total_speed += comb[i][0]\n            \n            if len(pq) > k:\n                total_speed -= heapq.heappop(pq)\n            low_eff = comb[i][1]\n            \n            ans = max(ans, total_speed * low_eff)\n            \n        return ans % mod", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:        \n        sums = []\n        ss = 0\n        maxi = 0\n        for s,e in sorted([(speed[i], efficiency[i]) for i in range(n)], key = lambda x: [-x[1], -x[0]]):\n            heappush(sums, s)\n            ss += s\n            if len(sums) > k:\n                rmv = heappop(sums)\n                ss -= rmv\n            maxi = max(maxi, ss*e)\n\n        return maxi%(10**9+7)\n", "import heapq\nclass Solution:\n    def maxPerformance(self, n, speed, efficiency, k):\n        engs=[]\n        heapq.heapify(engs)\n        for i in range(n):\n            heapq.heappush(engs,(-efficiency[i],speed[i]))\n        \n        speedtotal=0\n        totalperf=0\n        \n        current_team=[]\n        heapq.heapify(current_team)\n        for i in range(k):\n            temp=heapq.heappop(engs)\n            speedtotal+=temp[1]\n            totalperf=max(totalperf,speedtotal*-temp[0])\n            heapq.heappush(current_team,temp[1])\n        \n        for j in range(k,n):\n            temp=heapq.heappop(engs)\n            if temp[1]>current_team[0]:\n                speedtotal-=current_team[0]\n                speedtotal+=temp[1]\n                totalperf=max(totalperf,-temp[0]*speedtotal)\n                heapq.heappop(current_team)\n                heapq.heappush(current_team,temp[1])\n                \n        return totalperf%(10**9+7)\n            \n        \n        \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \n        \n        l=[(x,y) for x,y in zip(speed,efficiency)]\n        l=sorted(l,key=lambda x: (x[1],-x[0]))\n        #efficiency=sorted(efficiency)\n        \n        ma=0\n        q=[]\n        s=0\n        for i in range(len(l)-1,-1,-1):\n            mi=l[i][1]\n            \n            heapq.heappush(q,l[i][0])\n            s+=l[i][0]\n            if len(q)>k:\n                s-=heapq.heappop(q)\n            \n            ma=max(ma,s*l[i][1])\n        return ma%((10**9)+7)\n\n            \n            \n            \n", "import heapq\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        engineers = [(speed[i],efficiency[i]) for i in range(n)]\n        engineers.sort(key = lambda x : (-x[1],x[0]))\n        result = 0\n        heap = []\n        totalSum = 0\n        for i in range(n):\n            while len(heap) >= k:\n                totalSum -= heapq.heappop(heap)\n            result = max(result , (totalSum + engineers[i][0]) * engineers[i][1] )\n            heapq.heappush(heap,engineers[i][0])\n            totalSum += engineers[i][0]\n        return result % (10 ** 9 + 7)", "class Solution(object):\n    def maxPerformance(self, n, speed, efficiency, k):\n        worker = []\n        for i in range(n):\n            worker.append([speed[i], efficiency[i]])\n        worker = sorted(worker,key = lambda x :x[1],reverse = True)\n        print(worker)\n        import heapq\n        total = 0\n        heap = []\n        res = 0\n        for i in range(k):\n            total += worker[i][0]\n            minE = worker[i][1]\n            heapq.heappush(heap, worker[i][0])\n            res = max(res, total*minE)\n        for i in range(k, n):\n            if worker[i][0] > heap[0]:\n                total += (-heap[0]+worker[i][0])\n                minE = worker[i][1]\n                res = max(res, minE*total)\n                heapq.heappop(heap)\n                heapq.heappush(heap, worker[i][0])\n        return res%1000000007\n        \n    def cmp(self, w1, w2):\n        if w1[1] > w2[1]:\n            return -1\n        elif w1[1] == w2[1]:\n            return 0\n        else:\n            return 1", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        h=[]  #\u6700\u5c0f\u5806\uff0c\u5b58\u653e\u6311\u9009\u7684\u5de5\u7a0b\u5e08\u7684\u901f\u5ea6\n        ssum=0\n        res=0\n        for e,s in sorted(zip(efficiency,speed),reverse=True):\n            heapq.heappush(h,s)\n            ssum+=s\n            if len(h)>k:\n                ssum-=heapq.heappop(h)\n            res=max(res,ssum*e)\n        return res%(10**9+7)", "\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        people = sorted(zip(speed, efficiency), key=lambda x: x[1],reverse=True)\n        \n        result, sum_speed = 0, 0\n        min_heap = []\n        print(people)\n        for i, (s, e) in enumerate(people):\n            if i < k:\n                sum_speed += s\n                heapq.heappush(min_heap, s)\n            elif s > min_heap[0]:\n                sum_speed += s - heapq.heappushpop(min_heap, s)\n                \n            result = max(result, sum_speed * e)\n            print(result)\n        \n        return result % (pow(10,9)+7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        pq, largelst = [], []\n        for i in range(n):\n            heapq.heappush(pq, (-efficiency[i], speed[i]))\n        \n        mx, sm = 0, 0\n        while pq:\n            pop = heapq.heappop(pq)\n            eff = -pop[0]\n            heapq.heappush(largelst, pop[1])\n            sm+=pop[1]\n            while len(largelst)>k:\n                rm = heapq.heappop(largelst)\n                sm -= rm\n            mx = max(mx, sm* eff)\n            \n        return mx % (10**9+7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        engineers = sorted(zip(speed, efficiency), key=lambda eng: eng[1], reverse=True)\n        h = []\n        res = 0\n        speedSum = 0\n        for s, e in engineers:\n            heapq.heappush(h, s)\n            speedSum += s\n            if len(h) > k:\n                speedSum -= h[0]\n                heapq.heappop(h)\n            res = max(res, speedSum*e)\n        return res%(10**9 + 7)", "from heapq import heappush, heappop\n\nclass Engineer:\n    def __init__(self, speed, efficiency):\n        self.speed = speed\n        self.efficiency = efficiency\n    \n    def __str__(self):\n        return str(self.speed) + ',' + str(self.efficiency)\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        engineers = [Engineer(speed[i], efficiency[i]) for i in range(n)]\n        engineers.sort(key=lambda x: x.efficiency, reverse=True)\n        performance = 0\n        maxSpeeds = []\n        sumOfSpeeds = 0\n        for index, engineer in enumerate(engineers):\n            heappush(maxSpeeds, [engineer.speed, index, engineer])\n            sumOfSpeeds += engineer.speed\n            if len(maxSpeeds) > k:\n                sumOfSpeeds -= heappop(maxSpeeds)[2].speed\n            performance = max(performance, engineer.efficiency * sumOfSpeeds)\n        return performance % (10**9 + 7)", "import heapq\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        lst = sorted(zip(efficiency, speed), reverse = True)\n        p = []\n        sum_speed = 0\n        res = 0\n        for e, s in lst:\n            sum_speed += s\n            heapq.heappush(p, s)\n            if len(p) > k:\n                sum_speed -= (heapq.heappop(p))\n            val = e * sum_speed\n            res = max(res, val)\n            \n        return res % (10**9 + 7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        temp = []\n        for i in range(len(efficiency)):\n            temp.append([efficiency[i], speed[i]])\n        temp.sort(reverse = True)\n        heap = []\n        cur_sum = 0\n        result = 0\n        for i in range(len(temp)):\n            heapq.heappush(heap, (temp[i][1], i))\n            cur_sum += temp[i][1]\n            if len(heap) > k:\n                cur_sum -= heapq.heappop(heap)[0]\n            result = max(result, cur_sum * temp[i][0])\n        return result % (10 ** 9 + 7)", "from heapq import heappush, heappop\nclass Engineer:\n    def __init__(self, speed, efficiency):\n        self.speed = speed\n        self.efficiency = efficiency\n        \nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        engineers = []\n        for i in range(n):\n            engineers.append(Engineer(speed[i], efficiency[i]))\n        engineers.sort(key=lambda eng: eng.efficiency, reverse = True)\n        minHeap = []\n        maxPerform, sumOfSpeed = 0, 0\n        for i, eng in enumerate(engineers):\n            sumOfSpeed += eng.speed\n            heappush(minHeap, [eng.speed, i,eng])\n            if len(minHeap) > k:\n                sumOfSpeed -= heappop(minHeap)[2].speed\n            maxPerform = max(sumOfSpeed * eng.efficiency, maxPerform)\n        \n        return maxPerform % (10**9 + 7)\n", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        res = 0\n        hired, curr_sum = [], 0\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            heapq.heappush(hired, s)\n            curr_sum += s\n            if len(hired) > k:\n                curr_sum -= heapq.heappop(hired)\n            res = max(res, curr_sum * e)\n        return res % (10**9 + 7)", "from heapq import heappush, heappop\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        data = sorted(list(zip(efficiency, speed)), reverse=True)\n        pq = []\n        current_eff, total = float('inf'), 0\n        answer = 0\n        print(data)\n        for eff, spd in data:\n            current_eff = eff\n            total += spd\n            heappush(pq, spd)\n            if len(pq) > k:\n                total -= heappop(pq)\n            answer = max(answer, current_eff * total)\n        return answer % int(1e9 + 7)", "from heapq import heappush, heappop\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        ## based on the hints\n        ## since The performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers\n        ## we process engineer one by one in desceding order of his efficiency\n        ## and keep track the running sum of the previous k largest speeds\n        \n        ## two priority queues\n        M = 10**9+7\n        eff_pq = [] ## max heap\n        sp_pq = [] ## min heap\n        speed_sum = 0 ## track the sum of largest k speeds\n        ## push all efficiency and indexes into a max-heap\n        for idx, eff in enumerate(efficiency):\n            heappush(eff_pq, (-eff, idx))\n        \n        res = 0\n        while len(eff_pq)>0:\n            neg_eff, idx = heappop(eff_pq) ## process engineer one by one in desceding order of his efficiency\n            eff = -neg_eff\n            heappush(sp_pq, speed[idx]) ## push his speed into min-heap\n            speed_sum += speed[idx] ## keep tracking the running sum\n            \n            ## maintain the priority queue with size <= k\n            if len(sp_pq) > k:\n                sp_pop = heappop(sp_pq)\n                speed_sum -= sp_pop ## keep tracking the running sum\n                \n            ## note that a team be at most k engineers, which mean it can be less than k\n            res = max(res, eff*speed_sum) \n            \n        return res % M\n# 6\n# [2,10,3,1,5,8]\n# [5,4,3,9,7,2]\n# 2\n# 3\n# [2,8,2]\n# [2,7,1]\n# 2    \n", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        a=list(zip(efficiency,speed))\n        a.sort(reverse=True)\n        pq=[]\n        mp=s=0\n        for i in range(n):\n            heapq.heappush(pq,a[i][1])\n            s+=a[i][1]\n            if(i>=k):\n                s-=heapq.heappop(pq)\n            mp=max(mp,s*a[i][0])\n        return mp%(10**9+7)\n        \n", "from heapq import heappush,heappop\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        people = [ [speed[i],efficiency[i]] for i in range(n)]\n        \n        people.sort(key=lambda x:-x[1])\n        res = 0\n        h = []\n        \n        total_speed = 0\n        for i , (s,e) in enumerate(people):\n            heappush(h,s)\n            total_speed += s\n            \n            if len(h) > k:\n                total_speed -= heappop(h) \n            \n            res = max(res, total_speed*e) \n        \n        return res % mod", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \n        MOD = 10 ** 9 + 7\n\n        #(speed, effiency)\n        comb = [(speed[i], efficiency[i]) for i in range(n)]\n        comb.sort(key = lambda x: -x[1])\n\n        total_speed = 0\n        ans = 0 \n        pq = []\n        \n        for i in range(n):\n            heapq.heappush(pq, comb[i][0])\n            total_speed += comb[i][0]\n            \n            if len(pq) > k:\n                total_speed -= heapq.heappop(pq)\n            low_eff = comb[i][1]\n            \n            ans = max(ans, total_speed * low_eff)\n        \n        return ans % MOD\n    \n        MOD = 10**9 + 7\n        combo = []\n        for i in range(n):\n            heapq.heappush(combo, (-efficiency[i], speed[i]))\n        tmp = []\n        ans, currsum = 0, 0\n        \n        while combo:\n            curre, currs = heapq.heappop(combo)\n            tmp.append((currs))\n            currsum += currs\n            if len(tmp) > k:\n                currsum -= heapq.heappop(tmp)\n            ans = max(ans, -currsum * curre % MOD)\n        return ans", "from heapq import heappop, heappush\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        queue = []\n        sspeed = 0\n        res = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            heappush(queue, s)\n            sspeed += s\n            if len(queue) > k:\n                sspeed -= heappop(queue)\n            res = max(res, sspeed*e)\n        return res%(10**9 + 7)\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        worker = []\n        for i in range(n):\n            worker.append([speed[i], efficiency[i]])\n        worker.sort(key = lambda x: x[1], reverse = True)\n        import heapq\n        total = 0\n        heap = []\n        res = 0\n        for i in range(k):\n            total += worker[i][0]\n            minE = worker[i][1]\n            heapq.heappush(heap, worker[i][0])\n            res = max(res, total*minE)\n        for i in range(k, n):\n            if worker[i][0] > heap[0]:\n                total += (-heap[0]+worker[i][0])\n                minE = worker[i][1]\n                res = max(res, minE*total)\n                # heapq.heappop(heap)\n                heapq.heappushpop(heap, worker[i][0])\n        return res%1000000007", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        sorting = sorted([(s,i) for i,s in enumerate(speed)])\n        speedset = set(i for _,i in sorting[len(sorting)-k:])\n        ssum = sum(s for s,_ in sorting[len(sorting)-k:])\n        removed = set()\n        idx = len(sorting)-k\n        \n        ans = 0\n        for e,i in sorted([(e,i) for i,e in enumerate(efficiency)]):\n            if i in speedset:\n                ans = max(ans, e * ssum)\n                \n                speedset.remove(i)\n                ssum -= speed[i]\n                \n                idx -= 1\n                while idx >= 0 and sorting[idx][1] in removed:\n                    idx -= 1\n                \n                if idx >= 0:\n                    speedset.add(sorting[idx][1])\n                    ssum += sorting[idx][0]\n            else:\n                ans = max(ans, e * (ssum - sorting[idx][0] + speed[i]))\n            removed.add(i)\n        return ans % (10**9 + 7)\n            \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        a = [(s, e) for s, e in zip(speed, efficiency)]\n        if k == 1:\n            return max([s * e for s, e in a])\n        a.sort(key=lambda x:-x[1])\n        ret = 0\n        q = []\n        s_sum = 0\n        for s, e in a:\n            ret = max(ret, (s_sum + s) * e)\n            if len(q) >= k - 1:\n                if q[0] < s:\n                    x = heapq.heappop(q)\n                    s_sum = s_sum + s - x\n                    heapq.heappush(q, s)\n            else:\n                heapq.heappush(q, s)\n                s_sum += s\n        return ret % (10 ** 9 + 7)", "import heapq\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        pairs = list(zip(efficiency, speed))\n        pairs.sort(key = lambda x: (-x[0], -x[1]))\n        arr = []\n        res = 0\n        sum_spd = 0\n        for eff, spd in pairs:\n            if len(arr) < k:\n                sum_spd += spd\n                heapq.heappush(arr, spd)\n            else:\n                if spd > arr[0]:\n                    sum_spd += spd - heapq.heappushpop(arr, spd)\n            res = max(res, sum_spd*eff)\n        return res % (10**9 + 7)\n", "from sortedcontainers import SortedList\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        workers, MOD = SortedList(), 10 ** 9 + 7\n        \n        ret = ss = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            workers.add(s)\n            ss += s\n            \n            if len(workers) > k:\n                ss -= workers.pop(0)\n            \n            ret = max(ret, e * ss)\n        \n        return ret % MOD", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        q =[]\n        worker = []\n        for s,e in zip(speed, efficiency):\n            worker.append([s,e])\n        \n        ans, speeds, minEff = 0,0,float('inf')\n        for s,e in sorted(worker, key=lambda x: -x[1]):\n            if len(q) < k:\n                heapq.heappush(q, [s,e])\n                speeds += s\n                minEff = min(minEff, e)\n            elif s > q[0][0]:\n                ts,te = heapq.heappop(q)\n                speeds = speeds - ts + s\n                minEff = e\n                heapq.heappush(q, [s,e])\n            ans = max(ans, speeds*minEff)\n        \n        return ans%(10**9+7)\n        \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        heap = []\n        total = 0\n        pairs = list(zip(speed, efficiency))\n        pairs.sort(key = lambda x: -x[1])\n        res = 0\n        MOD = 10 ** 9 + 7\n        for i, (s, e) in enumerate(pairs):\n            res = max(e * (total + s), res)\n            if len(heap) < k - 1:\n                heapq.heappush(heap, s)\n                total += s\n            elif heap and s > heap[0]:\n                total -= heapq.heappop(heap)\n                heapq.heappush(heap, s)\n                total += s\n        return res % MOD", "from queue import PriorityQueue\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        if k == 1:\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\n        \n        engs = sorted([(efficiency[i], speed[i]) for i in range(n)])\n        others = PriorityQueue()\n        maxi = 0\n        otherSum = 0\n        for i in range(n - 1, -1, -1):\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]))\n            otherSum += engs[i][1]\n            others.put(engs[i][1])\n            while others.qsize() > k - 1:\n                otherSum -= others.get()\n            \n        return maxi % mod", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        unit = sorted([(s, e) for (s, e) in zip(speed, efficiency)], key=lambda x:x[1], reverse=True)\n        max_res = -1\n        curr_sum = 0\n        MOD = 10**9 + 7\n        heap = []\n        for s, e in unit:\n            curr_sum += s\n            max_res = max(max_res, curr_sum * e)\n            heapq.heappush(heap, s)\n            if len(heap) >= k:\n                curr_sum -= heapq.heappop(heap)\n        return max_res % MOD", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        arr = list(zip(efficiency, speed))\n        arr.sort(reverse=True)\n        counter = 0\n        curr_max = 0\n        heap = []\n        for i in arr:\n            curr_max = max(curr_max, i[0] * (counter + i[1]))\n            heapq.heappush(heap, i[1])\n            counter += i[1]\n            if len(heap) > k - 1:\n                counter -= heapq.heappop(heap)\n        return (curr_max) % ((10 ** 9) + 7)\n            \n", "from queue import PriorityQueue\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        if k == 1:\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\n        \n        engs = sorted([(efficiency[i] % mod, speed[i] % mod) for i in range(n)])\n        maxi = 0\n        others = PriorityQueue()\n        otherSum = 0\n        for i in range(n - 1, -1, -1):\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]) )\n            otherSum += engs[i][1]\n            others.put(engs[i][1])\n            while others.qsize() > k - 1:\n                otherSum -= others.get()\n            \n        return maxi % mod", "from queue import PriorityQueue\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        if k == 1:\n            return max([speed[i] * efficiency[i] for i in range(n)]) % mod\n        \n        engs = sorted([(efficiency[i] % mod, speed[i] % mod) for i in range(n)])\n        others = PriorityQueue()\n        maxi = 0\n        otherSum = 0\n        for i in range(n - 1, -1, -1):\n            maxi = max(maxi, ((engs[i][1] + otherSum) * engs[i][0]))\n            otherSum += engs[i][1]\n            others.put(engs[i][1])\n            while others.qsize() > k - 1:\n                otherSum -= others.get()\n            \n        return maxi % mod", "import heapq\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        pairs = list(zip(efficiency, speed))\n        pairs.sort(key = lambda x: (-x[0], -x[1]))\n        arr = []\n        res = 0\n        sum_spd = 0\n        for eff, spd in pairs:\n            if len(arr) < k:\n                sum_spd += spd\n                heapq.heappush(arr, spd)\n            else:\n                sum_spd += spd - heapq.heappushpop(arr, spd)\n            res = max(res, sum_spd*eff)\n        return res % (10**9 + 7)\n", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, S: List[int], E: List[int], k: int) -> int:\n        \n        tmp = []\n        \n        for x, y in zip(S, E):\n            tmp.append([y, x])\n        tmp.sort(reverse=True)\n        \n        stack = []\n        sums = 0\n        res = 0\n        for i in range(n):\n            nk = tmp[i][0]\n            sums += tmp[i][1] - (heapq.heappop(stack) if len(stack) == k else 0)\n            heapq.heappush(stack, tmp[i][1])\n            res = max(res, nk * sums )\n        return res % 1000000007", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\n        n = len(eff_speed)\n        i = 0\n        speed_h = []\n        speed_sum = 0\n        max_perf = 0\n        start = 0\n        while i < n:\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\n                heapq.heappush(speed_h, eff_speed[i][1])\n                speed_sum += eff_speed[i][1]\n                if len(speed_h) > k:\n                    speed_sum -= heapq.heappop(speed_h)\n                i += 1\n            start = i\n            cur_efficiency = eff_speed[i - 1][0]\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\n        return max_perf % mod\n    \n    \n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\n        n = len(eff_speed)\n        speed_h = []\n        speed_sum = 0\n        max_perf = 0\n        for e, s in eff_speed:\n            heapq.heappush(speed_h, s)\n            speed_sum += s\n            if len(speed_h) > k:\n                speed_sum -= heapq.heappop(speed_h)\n            max_perf = max(max_perf, speed_sum * e)\n        return max_perf % mod\n            \n", "import heapq \n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \n        arr = zip(efficiency, speed)\n        arr = sorted(arr, key=lambda x: (-x[0],-x[1])) \n        pq = [] \n        maxSoFar, currSum = 0, 0\n        \n        for eff,sp in arr: \n            \n            currSum += sp \n            heapq.heappush(pq,sp)\n            if len(pq) == k+1:\n                currSum -= heapq.heappop(pq) \n                \n            maxSoFar = max(maxSoFar, currSum * eff) \n\n        \n        return maxSoFar % 1000000007", "class Solution:\n    # O(nlogn + 2nlogk) time, no unnecessary max comparison, O(n) space\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\n        n = len(eff_speed)\n        i = 0\n        speed_h = []\n        speed_sum = 0\n        max_perf = 0\n        start = 0\n        while i < n:\n            while i == start or (i < n and eff_speed[i][0] == eff_speed[i - 1][0]):\n                heapq.heappush(speed_h, eff_speed[i][1])\n                speed_sum += eff_speed[i][1]\n                if len(speed_h) > k:\n                    speed_sum -= heapq.heappop(speed_h)\n                i += 1\n            start = i\n            cur_efficiency = eff_speed[i - 1][0]\n            max_perf = max(max_perf, cur_efficiency * speed_sum)\n        return max_perf % mod\n    \n    # O(nlogn + 2nlogk) time, O(n) space\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        eff_speed = sorted(zip(efficiency, speed), reverse=True)\n        n = len(eff_speed)\n        speed_h = []\n        speed_sum = 0\n        max_perf = 0\n        for e, s in eff_speed:\n            heapq.heappush(speed_h, s)\n            speed_sum += s\n            if len(speed_h) > k:\n                speed_sum -= heapq.heappop(speed_h)\n            max_perf = max(max_perf, speed_sum * e)\n        return max_perf % mod\n            \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        M = 10 ** 9 + 7\n        \n        heap = []\n        ans = t = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=True):\n            t += s\n            heapq.heappush(heap, s)\n            if len(heap) == k+1:\n                t -= heapq.heappop(heap)\n            ans = max(ans, t * e)\n        return ans % M", "from heapq import heappush, heappop\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        speed_heap = []\n        speed_sum = 0\n        max_performance = 0\n\n        for cur_efficiency, cur_speed in sorted(zip(efficiency, speed), reverse=True):\n            heappush(speed_heap, cur_speed)\n            speed_sum += cur_speed\n\n            if len(speed_heap) > k:\n                speed_sum -= heappop(speed_heap)\n\n            max_performance = max(max_performance, speed_sum * cur_efficiency)\n\n        return max_performance % (10 ** 9 + 7)", "import heapq\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        if k < 1:\n            return 0\n        \n        best = 0\n        heap = []\n        cur_sum = 0\n        \n        data = sorted(list(zip(speed, efficiency)), key=lambda x: -x[1])\n        \n        for s, e in data:\n            if len(heap) < k:  # always add this eng.\n                cur_sum += s\n                heapq.heappush(heap, s)\n                if cur_sum * e > best:\n                    best = cur_sum * e\n            else:\n                if (cur_sum - heap[0] + s) * e > best:\n                    best = (cur_sum - heap[0] + s) * e\n                if s > heap[0]:\n                    cur_sum += (s - heap[0])\n                    heapq.heappush(heap, s)\n                    heapq.heappop(heap)\n        \n        return best % 1000000007\n", "import heapq \n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \n        arr = zip(efficiency, speed)\n        arr = sorted(arr, key=lambda x: (-x[0],-x[1])) \n        pq = [] \n        maxSoFar, currSum = 0, 0\n        \n        for eff,sp in arr: \n            \n            currSum += sp \n            heapq.heappush(pq,sp)\n            if len(pq) == k+1:\n                currSum -= heapq.heappop(pq) \n                \n            maxSoFar = max(maxSoFar, currSum * eff) \n\n        \n        return maxSoFar % ((10**9) + 7)", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        q = []\n        sum_speed = 0\n        res = 0\n        for e,s in sorted(zip(efficiency, speed), reverse=True):\n            sum_speed += s\n            heapq.heappush(q, s)\n            while len(q) > k:\n                sum_speed -= heapq.heappop(q)\n            res = max(res, e * sum_speed)\n        return res % (10 ** 9 + 7)", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        pq = []\n        engineers = list(zip(speed, efficiency))\n        engineers.sort(key=lambda tup:-tup[1])  # sort by efficiency in decreasing order\n\n        performance = 0\n        tot_speed = 0\n        for engineer in engineers:\n            min_efficiency = engineer[1]\n            if len(pq) == k:\n                if pq[0] < engineer[0]:  # if there's an engineer with higher speed, there's a good chance to get higher performance\n                    bad_speed = heapq.heappop(pq)  # fire the guy with the lowest speed\n                    heapq.heappush(pq, engineer[0])\n                    tot_speed = tot_speed - bad_speed + engineer[0]\n            else:\n                heapq.heappush(pq, engineer[0])\n                tot_speed += engineer[0]\n            performance = max(performance, tot_speed*min_efficiency)\n        return performance % MOD", "from heapq import heappop, heappush\n\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        hh = [[efficiency[ii],speed[ii]] for ii in range(n)]\n        hh.sort(reverse=True)\n        heap  =[]\n        cursum = 0; \n        cureff = hh[0][0]\n        ans = 0;\n        for ih,[e,s] in enumerate(hh):\n            heappush(heap,(s,ih))\n            (tops,topind) = heap[0]\n            cursum = cursum +s\n            if  len(heap)>k:\n                heappop(heap)\n                cursum = cursum-hh[topind][1]\n            cureff = e\n            ans = max(ans,cureff*cursum)\n\n        return ans%(10**9+7)\n                \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10 ** 9 + 7\n        es = sorted(zip(efficiency, speed))\n        result = 0\n        heap = [0]\n        s = 0\n        for i in range(n - 1, -1, -1):\n            if len(heap) < k:\n                heapq.heappush(heap, es[i][1])\n                s = (s + es[i][1]) \n            elif es[i][1] > heap[0]:\n                s = (s + es[i][1] - heapq.heappushpop(heap, es[i][1]))\n            p = es[i][0] * s\n            result = max(result, p)\n        return result % MOD\n", "class Solution:\n    def maxPerformance(self, n, speed, efficiency, k):\n        h = []\n        res = sSum = 0\n        for e, s in sorted(zip(efficiency, speed), reverse=1):\n            heapq.heappush(h, s)\n            sSum += s\n            if len(h) > k:\n                sSum -= heapq.heappop(h)\n            res = max(res, sSum * e)\n        return res % (10**9 + 7)\n\n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        combo = []\n        for i in range(n):\n            heapq.heappush(combo, (-efficiency[i], -speed[i]))\n        tmp = []\n        ans, currsum = 0, 0\n        \n        while combo:\n            curre, currs = heapq.heappop(combo)\n            heapq.heappush(tmp, -currs)\n            currsum -= currs\n            if len(tmp) > k:\n                currsum -= heapq.heappop(tmp)\n            ans = max(ans, -currsum * curre)\n        return ans % MOD", "import heapq\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        \n        \n        pairs = [(-efficiency[i], speed[i]) for i in range(n)]\n        heapq.heapify(pairs)\n        t = 0\n        res = 0\n        usedSpeeds = []\n        cur = 0\n        while pairs:\n            e, s = heapq.heappop(pairs)\n            cur += s\n            t += 1\n            if t <= k:\n                res = max(res, -1 * e * cur)\n            elif t > k:\n                cur -= heapq.heappop(usedSpeeds)\n                res = max(res, -1 * e * cur )\n            heapq.heappush(usedSpeeds, s)\n        return res % (10 ** 9 + 7)\n            \n                \n                \n                \n                \n                \n                \n                \n                \n                \n            \n", "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        vals = [(speed[i], efficiency[i]) for i in range(n)]\n        vals.sort(reverse = True, key = lambda x: x[1])\n        \n        speed = 0\n        ans = 0\n        pq = []\n        \n        for i in range(n):\n            heapq.heappush(pq, vals[i][0])\n            speed += vals[i][0]\n            if len(pq) > k:\n                speed -= heapq.heappop(pq)\n            ans = max(ans, speed*vals[i][1])\n        return ans % (10**9 + 7)"]
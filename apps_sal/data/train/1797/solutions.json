["def hamming(n):\n    bases = [2, 3, 5]\n    expos = [0, 0, 0]\n    hamms = [1]\n    for _ in range(1, n):\n        next_hamms = [bases[i] * hamms[expos[i]] for i in range(3)]\n        next_hamm = min(next_hamms)\n        hamms.append(next_hamm)\n        for i in range(3):\n            expos[i] += int(next_hamms[i] == next_hamm)\n    return hamms[-1]", "# Based on http://www.codewars.com/kata/reviews/53d0337689316446e6000035/groups/5406bde018340bce700006c4\n# We don't need to recalculate next_hamms on each iteration.\n# Recalculating only the changed values results in some 35% performance improvement.\ndef hamming(n):\n    bases = [2, 3, 5]\n    expos = [0, 0, 0]\n    hamms = [1]\n    next_hamms = [2, 3, 5]\n    for _ in range(1, n):\n        next_hamm = min(next_hamms)\n        hamms.append(next_hamm)\n        for i in range(3):\n            if next_hamms[i] == next_hamm:\n                expos[i] += 1\n                next_hamms[i] = bases[i] * hamms[expos[i]]\n    return hamms[-1]", "def hamming(n):\n    num = [1]\n    i, j, k = 0, 0, 0\n    if n == 1:\n      return 1;\n    else:\n      for e in range(1, n):\n        x = min(2*num[i], 3*num[j], 5*num[k])\n        num.append(x)\n        if 2*num[i] <= x: i += 1\n        if 3*num[j] <= x: j += 1\n        if 5*num[k] <= x: k += 1\n    return num[len(num) - 1];", "def hamming(n):\n    bag = {1}\n    for _ in range(n - 1):\n        head = min(bag)\n        bag.remove(head)\n        bag |= {head*2, head*3, head*5}\n    return min(bag)\n", "class _CacheEntry(object):\n    __slots__ = ['is_optimal', 'linked_to', 'idx', 'seq']\n\n    def __init__(self, is_optimal=None, linked_to=None, idx=None, seq=None):\n        self.is_optimal = is_optimal\n        self.linked_to = linked_to\n        self.idx = idx\n        self.seq = seq\n\n_FACTORS_CACHE = {}\n\n\ndef factorizable(n, factors, sort_factors=True):\n    \"\"\"\n    Check if there is a way to factorize n by the factors passed as a second argument.\n    Factors could be non-prime.\n    As the factors could be non-prime, we can't just divide by all the factors one by one\n    until there are no factors left or we got 1. We have to check all possible orders of factorization.\n    We'll try to divide N by all the factors, store all the quotients in the list and then try to check all\n    numbers in that list in the same manner until we run out of possible factors or get 1.\n    \"\"\"\n    if not factors:\n        return False\n    if sort_factors:\n        factors = sorted(set(factors))\n    fs = [n]  # The initial list of numbers to check contains only n\n    while fs:  # If there are no numbers left to check, there is no way to fully factorize n by factors\n        sub = []  # A list to store all the quotients from the division of n by factors\n        for n in fs:  # Try to factorize further\n            for f in factors:\n                if n == f:  # Fully factorized!\n                    return True\n                elif f <= n:  # A possible factor\n                    if n % f == 0:  # n is divisible by f. Let's check if n/f is in turn factorizable by factors\n                        sub.append(n/f)\n                else:  # This, and, consequently, all subsequent factors are too large for n to be divisible by them\n                    break\n        # We are still here, so we still don't know if n is fully divisible by factors.\n        # Let's check all the quotients in the same way\n        fs = sub\n    return False  # Sorry, no numbers left, no way to factorize n by factors.\n\n\ndef normalized_factors(factors, caching=True):\n    if caching and factors in _FACTORS_CACHE:\n        entry = _FACTORS_CACHE[factors]\n        if entry.is_optimal:\n            return factors\n        else:\n            return entry.linked_to\n    fs = sorted(set(factors))\n    i = 1\n    for _ in range(1, len(fs)):\n        if factorizable(fs[i], fs[0:i], False):\n            del fs[i]\n        else:\n            i += 1\n    t = tuple(fs)\n    # We don't have to check if factors in _FACTORS_CACHE, because we checked it already.\n    if caching and t != factors:\n        _FACTORS_CACHE[factors] = _CacheEntry(is_optimal=False, linked_to=t)\n    return t\n\n\ndef normalized_factors_f(factors):\n    # Functional style: nicer, but less readable and some 25% slower\n    # Adding cache support would ruin its nicety though\n    fs = sorted(set(factors))\n    return (e[1] for e in filter(lambda t: not factorizable(t[1], fs[0:t[0]], False), enumerate(fs)))\n\n\n# This is based on http://www.codewars.com/kata/reviews/53d0337689316446e6000035/groups/5406bde018340bce700006c4\ndef factored(n, factors, caching=True):\n    \"\"\"\n    Build an increasing sequence of numbers divisible by the specified factors and return n-th number of such sequence.\n    E.g. factors(5, (2,3,5)) returns fifth Hamming Number.\n\n    :param factors: A list or a tuple of factors to build a sequence on\n    :type factors: list(int)|tuple(int)\n    \"\"\"\n    factors = normalized_factors(factors, caching)\n\n    cached = False\n    if caching and factors in _FACTORS_CACHE:\n        e = _FACTORS_CACHE[factors]  # Should be optimal\n        if n <= len(e.seq):  # The requested number is cached already\n            return e.seq[n-1]\n        cached = True\n\n    fn = len(factors)\n    next_nums = list(factors)  # e.g. [2, 3, 5]\n    if cached:  # Part of the sequence is cached, let's continue\n        for i in range(fn):\n            next_nums[i] = e.seq[e.idx[i]] * factors[i]\n    else:  # Initialize a new entry\n        e = _CacheEntry(\n            is_optimal=True,\n            idx=[0] * fn,\n            seq=[1]\n        )\n\n    for _ in range(len(e.seq), n):\n        next_n = min(next_nums)\n        e.seq.append(next_n)\n        for i in range(fn):\n            if next_n == next_nums[i]:\n                e.idx[i] += 1\n                next_nums[i] = e.seq[e.idx[i]] * factors[i]\n\n    if caching and not cached:\n        _FACTORS_CACHE[factors] = e\n\n    return e.seq[-1]\n\n\ndef hamming(n):\n    \"\"\"Returns the nth hamming number\"\"\"\n    return factored(n, (2, 3, 5))", "h = sorted(2**i*3**j*5**k for i in range(35) for j in range(25) for k in range(15))\n\ndef hamming(n):\n    return h[n-1]", "from heapq import *\n\nH,Q = [1], [(2,2,1),(3,3,1),(5,5,1)]\n\n\ndef hamming(n):\n    while len(H)<=n:\n        v,root,i = heappop(Q)\n        if H[-1]!=v: H.append(v)\n        heappush(Q, (H[i]*root,root,i+1))\n    return H[n-1]", "\nimport itertools\n\nH = sorted([\n  2**i * 3**j * 5**k\n  for i, j, k in itertools.product(xrange(50), xrange(50), xrange(50))\n])\nhamming = lambda n, H=H: H[n-1]", "def hamming(n):\n    h, i, j, k = [1] * n, 0, 0, 0\n    \n    for nn in range(1, n):\n        h[nn] = min(2 * h[i], 3 * h[j], 5 * h[k])\n        i += 2 * h[i] == h[nn]\n        j += 3 * h[j] == h[nn]\n        k += 5 * h[k] == h[nn]\n    \n    return h[-1]\n", "nums = set()\nfor i in range(35):\n    for j in range(25):\n        for k in range(15):\n            nums.add(2**i * 3**j * 5**k)\nnums = [None] + sorted(nums)\n\ndef hamming(n):\n    return nums[n]"]
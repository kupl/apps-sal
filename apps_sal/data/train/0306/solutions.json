["class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         cache = {}\n         def f(val):\n           if val == target:\n             return 1\n \n           total = 0\n           remain = target - val\n           for num in nums:\n             if num <= remain:\n               k = val+num\n               if k in cache:\n                 total += cache[k]\n               else:\n                 cache[k] = f(val + num)\n                 total += cache[k]\n           return total\n         \n         return f(0)", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         record={0:1}\n         def helper(target):\n             if target in record:\n                 return record[target]\n             res=0\n             for x in nums:\n                 if target>=x:\n                     res+=helper(target-x)\n             record[target]=res\n             return res\n         \n         \n         return helper(target)\n \n         \n         \n \n \n", "class Solution(object):\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [0] + [-1] * target\n \n         def calc(target):\n             if target == 0:\n                 return 1\n             if dp[target] >= 0:\n                 return dp[target]\n             count = 0\n             for n in nums:\n                 if target - n >= 0:\n                     tmp = calc(target - n)\n                     if tmp >= 0:\n                         count += tmp\n             dp[target] = count\n             return count\n         ans = calc(target)\n         print(ans)\n         print(dp)\n         return ans\n \n", "class Solution:\n     # recursive, time limit exceeded\n     def combinationSum4_1(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         res = 0\n         if target == 0:\n             return 1\n         \n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.combinationSum4(nums, target - nums[i])\n         return res\n \n     # top down using memory\n     def combinationSum4_2(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [-1] * (target + 1)\n         dp[0] = 1\n         return self.helper(dp, nums, target)\n     \n     def helper(self, dp, nums, target):\n         if dp[target] != -1:\n             return dp[target]\n         \n         res = 0\n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.helper(dp, nums, target - nums[i])\n         dp[target] = res\n         return res\n     \n     # bottom up\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [0] * (target + 1)\n         dp[0] = 1\n         for i in range(target + 1):\n             for num in sorted(nums):\n                 if i < num: break\n                 dp[i] += dp[i - num]\n         return dp[-1]", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         \n         dp = [0 for x in range(target+1)]\n         dp[0] = 1\n         for x in range(1, target+1):\n             for elem in nums:\n                 if x >= elem:\n                     dp[x]+=dp[x - elem]\n         return dp[-1]", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         dp = [0]*(target + 1)\n         dp[0] = 1\n         for i in range(1, target+1):\n             for num in nums:\n                 if num>i:\n                     break\n                 dp[i]+=dp[i-num]\n         return dp[target]", "class Solution:\n     # recursive, time limit exceeded\n     def combinationSum4_1(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         res = 0\n         if target == 0:\n             return 1\n         \n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.combinationSum4(nums, target - nums[i])\n         return res\n \n     # top down using memory\n     def combinationSum4_2(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [-1] * (target + 1)\n         dp[0] = 1\n         return self.helper(dp, nums, target)\n     \n     def helper(self, dp, nums, target):\n         if dp[target] != -1:\n             return dp[target]\n         \n         res = 0\n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.helper(dp, nums, target - nums[i])\n         dp[target] = res\n         return res\n     \n     # bottom up\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [0] * (target + 1)\n         dp[0] = 1\n         for i in range(target + 1):\n             for num in sorted(nums):\n                 if i < num: break\n                 dp[i] += dp[i - num]\n         return dp[-1]", "class Solution:\n     # recursive, time limit exceeded\n     def combinationSum4_1(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         res = 0\n         if target == 0:\n             return 1\n         \n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.combinationSum4(nums, target - nums[i])\n         return res\n \n     # top down using memory\n     def combinationSum4_2(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [-1] * (target + 1)\n         dp[0] = 1\n         return self.helper(dp, nums, target)\n     \n     def helper(self, dp, nums, target):\n         if dp[target] != -1:\n             return dp[target]\n         \n         res = 0\n         for i in range(len(nums)):\n             if target >= nums[i]:\n                 res += self.helper(dp, nums, target - nums[i])\n         dp[target] = res\n         return res\n     \n     # bottom up\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         dp = [0] * (target + 1)\n         dp[0] = 1\n         for i in range(target + 1):\n             for j in range(len(nums)):\n                 if i - nums[j] >= 0:\n                     dp[i] += dp[i - nums[j]]\n         return dp[-1]", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         def dfs(nums,target,memo):  \n             if target in memo:\n                 return memo[target]\n             \n             if target < 0:\n                 return\n             if target == 0:\n                 memo[target] = 1\n                 return\n             \n             memo[target] = 0\n             for num in nums:\n                 dfs(nums, target-num,memo)\n                 if target-num >= 0:\n                     memo[target] += memo[target-num] \n                 \n         dfs.count = 0\n         nums.sort()\n         memo = {}\n         dfs(nums,target,memo)\n         \n         return memo[target]\n         \n", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         self.dp = [-1]*(target+1)\n         self.dp[0] = 1\n         return self.cSUtil(nums, target)\n         \n         \n     def cSUtil(self, nums, target):\n         if target < 0:\n             return 0\n         if self.dp[target] != -1:\n             return self.dp[target]\n         res = 0\n         for num in nums:\n             target -= num\n             res += self.cSUtil(nums, target)\n             target += num\n         self.dp[target] = res\n         return res", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         return self.use_dp(nums, target)\n     \n     def use_dfs(self, nums, target):\n         self.result = 0\n         nums.sort()\n         self.dfs(nums, target)\n         return self.result\n     \n     def dfs(self, nums, target):\n         if target == 0:\n             self.result += 1\n             return\n         \n         for num in nums:\n             if num > target:\n                 break\n             self.dfs(nums, target - num)\n             \n     def use_recursion_dp(self, nums, target):\n         dp = [-1] * (target + 1)\n         dp[0] = 1\n         nums.sort()\n         return self.dp_dfs(nums, target, dp)\n     \n     def dp_dfs(self, nums, target, dp):\n         if dp[target] != -1:\n             return dp[target]\n         result = 0\n         for num in nums:\n             if num > target:\n                 break\n             result += self.dp_dfs(nums, target - num, dp)\n         dp[target] = result\n         return result\n     \n     def use_dp(self, nums, target):\n         dp = [0] * (target + 1)\n         dp[0] = 1\n         for item in range(1, len(dp)):\n             for num in nums:\n                 if item - num >= 0:\n                     dp[item] += dp[item - num]\n         return dp[target]\n", "class Solution:\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         n_nums = len(nums)\n         # combinations = [[0]*(n_nums+1)]*(target+max(nums)+3)\n         combinations = [[0]*(n_nums+1) for i in range(target+max(nums)+3)]\n         for i in range(1, target + 1):\n             cur_sum = 0\n             for j in range(n_nums):\n                 if i == nums[j]:\n                     combinations[i][j] = 1\n                 else:\n                     combinations[i][j] = combinations[i - nums[j]][n_nums]\n                 cur_sum += combinations[i][j]\n             combinations[i][n_nums]= cur_sum\n         return combinations[target][n_nums]\n             \n         \n", "class Solution:\n     count = 0\n     def combinationSum4(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         comb =  [0]*(target + 1)\n         comb[0] = 1\n         for i in range(1, len(comb)):\n             for j in range(0, len(nums)):\n                 if i - nums[j] >= 0:\n                     comb[i] += comb[i - nums[j]]    \n         return comb[target]\n     \n #         self.helper(nums, 0, target, 0)\n #         return self.count\n     \n #     def helper(self, nums, i, target, Sum):\n #         if i >= len(nums) or Sum > target:\n #             return \n #         if Sum == target:\n #             self.count += 1\n #             return\n         \n #         for j in range(0, len(nums)):\n #             self.helper(nums, j, target, Sum + nums[j])\n"]
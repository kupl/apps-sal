["q = int(input())\n\n\n\ndef full_way(u):\n    res = set()\n\n    while u >= 1:\n        res.add(u)\n        u //= 2\n\n    return res\n\n\ndef get_way(u, v):\n    res1 = full_way(u)\n    res2 = full_way(v)\n\n    m = max(res1 & res2)\n\n    res = set()\n    for x in res1 | res2:\n        if x > m:\n            res.add(x)\n\n    return res\n\n\nd = {}\n\nfor i in range(q):\n    a  = input().split()\n\n    if a[0] == '1':\n        v, u, w = map(int, a[1:])\n        for x in get_way(u, v):\n            if x not in d:\n                d[x] = 0\n            d[x] += w\n    else:\n        v, u = map(int, a[1:])\n        res = 0\n        for x in get_way(u, v):\n            if x in d:\n                res += d[x]\n        print(res)", "q = int(input())\ndef full_way(u):\n    res = set()\n    while u >= 1:\n        res.add(u)\n        u //= 2\n    return res\ndef get_way(u, v):\n    res1 = full_way(u)\n    res2 = full_way(v)\n    m = max(res1 & res2)\n    res = set()\n    for x in res1 | res2:\n        if x > m:\n            res.add(x)\n    return res\nd = {}\nfor i in range(q):\n    a  = input().split()\n\n    if a[0] == '1':\n        v, u, w = list(map(int, a[1:]))\n        for x in get_way(u, v):\n            if x not in d:\n                d[x] = 0\n            d[x] += w\n    else:\n        v, u = list(map(int, a[1:]))\n        res = 0\n        for x in get_way(u, v):\n            if x in d:\n                res += d[x]\n        print(res)\n", "\ndef add_edges(s1, s2, w):\n    nonlocal edges\n    i = 0\n    while i < len(s1) and i < len(s2) and s1[i] == s2[i]:\n        i += 1    \n    j = len(s1)\n    while j > i:\n        if s1[:j] in edges:\n            edges[s1[:j]] += w\n        else:\n            edges[s1[:j]] = w                \n        j -= 1\n    j = len(s2)\n    while j > i:\n        if s2[:j] in edges:\n            edges[s2[:j]] += w\n        else:\n            edges[s2[:j]] = w         \n        j -= 1        \n        \ndef way(s1, s2):\n    nonlocal edges\n    i = 0\n    while i < len(s1) and i < len(s2) and s1[i] == s2[i]:\n        i += 1 \n    w = 0    \n    j = len(s1)\n    while j > i:\n        if s1[:j] in edges:\n            w += edges[s1[:j]] \n        j -= 1\n    j = len(s2)\n    while j > i:\n        if s2[:j] in edges:\n            w += edges[s2[:j]] \n        j -= 1\n    return w    \n\nq = int(input())\nedges = dict()\nfor i in range(q):\n    l = list(map(int, input().split()))\n    if l[0] == 1:\n        l[1] = bin(l[1])\n        l[1] = l[1][2:]\n        l[2] = bin(l[2])\n        l[2] = l[2][2:]\n        add_edges(l[1], l[2], l[3])\n    if l[0] == 2:\n        l[1] = bin(l[1])\n        l[1] = l[1][2:]\n        l[2] = bin(l[2])\n        l[2] = l[2][2:]\n        print(way(l[1], l[2]))        \n                \n", "def main():\n    d = {}\n    for _ in range(int(input())):\n        c, *l = input().split()\n        if c == \"1\":\n            v, u, w = list(map(int, l))\n            while u != v:\n                if u < v:\n                    d[v] = d.get(v, 0) + w\n                    u, v = v // 2, u\n                else:\n                    d[u] = d.get(u, 0) + w\n                    u //= 2\n        else:\n            res = 0\n            v, u = list(map(int, l))\n            while u != v:\n                if u < v:\n                    res += d.get(v, 0)\n                    u, v = v // 2, u\n                else:\n                    res += d.get(u, 0)\n                    u //= 2\n            print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    from collections import Counter\n    d = Counter()\n    for _ in range(int(input())):\n        c, *l = input().split()\n        if c == \"1\":\n            v, u, w = list(map(int, l))\n            while u != v:\n                if u < v:\n                    d[v] += w\n                    v //= 2\n                else:\n                    d[u] += w\n                    u //= 2\n        else:\n            w = 0\n            v, u = list(map(int, l))\n            while u != v:\n                if u < v:\n                    w += d[v]\n                    v //= 2\n                else:\n                    w += d[u]\n                    u //= 2\n            print(w)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport collections\n\n\ndef lca(u, v):\n    ub = bin(u)[2:]\n    vb = bin(v)[2:]\n\n\n    r = 0\n    for i, (a, b) in enumerate(zip(ub, vb)):\n        if a != b:\n            break\n        r = r * 2 + int(a)\n    return r\n\n\ndef add(cost, n, root, w):\n    while n > root:\n        cost[n] += w\n        n //= 2\n\n\ndef get(cost, n, root):\n    r = 0\n    while n > root:\n        r += cost[n]\n        n //= 2\n    return r\n\n\ndef __starting_point():\n    q = int(input())\n\n    cost = collections.Counter()\n    for _ in range(q):\n        cmd  = list(map(int, input().split()))\n        if cmd[0] == 1:\n            v, u, w = cmd[1:]\n            root = lca(v, u)\n            add(cost, v, root, w)\n            add(cost, u, root, w)\n        else:\n            v, u = cmd[1:]\n            root = lca(v, u)\n            print(get(cost, v, root) + get(cost, u, root))\n\n\n__starting_point()", "d = {}\ndef lca(x, y, w):\n    res = 0\n    while x != y:\n        if x < y:\n            x, y = y, x;\n        d[x] = d.get(x, 0) + w\n        res += d[x]\n        x //= 2\n    return res\nq = int(input())\nwhile (q > 0):\n    q -= 1\n    a = list(map(int, input().split()))\n    if a[0] == 1:\n        lca(a[1], a[2], a[3])\n    else:\n        (print(lca(a[1], a[2], 0)))\n", "w = {}\ndef up(a, b, d):\n    while a != b:\n        if a < b:\n            a, b = b, a\n        if a not in w:\n            w[a] = 0\n        w[a] += d\n        a = a // 2\n        \ndef get(a, b):\n    res = 0\n    while a != b:\n        if a < b:\n            a, b = b, a\n        if a in w:\n            res += w[a]\n        a = a // 2\n    return res\n\nq = int(input())\nfor i in range(q):\n    a = [int(b) for b in input().split()]\n    if a[0] == 1:\n        up(a[1], a[2], a[3])\n    else:\n        print(get(a[1], a[2]))", "from math import log\nq = int(input())\nprix = {}\ndepenses = []\ndef est_dessous(v,u):\n    return u == v or u == 1 or (u < v and 0 <= v - 2**int(log(v/u)/log(2))*u < 2**int(log(v/u)/log(2)))\ndef pqc(u,v):\n    #retourne la liste des ARETES emprunt\u00e9es\n    res = []\n    while not est_dessous(v,u):\n        res.append((u,u//2))\n        u = u//2\n    while not u == v:\n        if est_dessous(v, 2*u):\n            res.append((u, 2*u))\n            u = 2*u\n        elif est_dessous(v,2*u+1):\n            res.append((u,2*u+1))\n            u = 2*u+1\n    return res\nfor k in range(q):\n    event = tuple(map(int,input().split()))\n    if event[0] == 1:\n        for (a,b) in pqc(event[1],event[2]):\n            if (a,b) in prix:\n                prix[(a,b)] += event[3]\n            elif (b,a) in prix:\n                prix[(b,a)] += event[3]\n            else:\n                prix[(a,b)] = event[3]\n    else:\n        s = 0\n        for (a,b) in pqc(event[1],event[2]):\n            if (a,b) in prix:\n                s += prix[(a,b)]\n            elif (b,a) in prix:\n                s += prix[(b,a)]\n        depenses.append(s)\n\nfor k in depenses:\n    print(k)\n", "I= input\nn = int(I())\nd = {}\ndef lca(u,v,w):\n  res = 0\n  while u != v:\n    if u < v: u, v = v , u\n    d[u] = d.get(u,0) + w\n    res += d[u]\n    u = u//2\n  return res\nfor i in range(n):\n  l = list(map(int, I().split()))\n  if l[0] == 1:  # To add\n    lca(l[1],l[2],l[3])\n  else: print(lca(l[1],l[2],0))", "I= input\n\nn = int(I())\n\nd = {}\n\ndef lca(u,v,w):\n\n  res = 0\n\n  while u != v:\n\n    if u < v: u, v = v , u\n\n    d[u] = d.get(u,0) + w\n\n    res += d[u]\n\n    u = u//2\n\n  return res\n\nfor i in range(n):\n\n  l = list(map(int, I().split()))\n\n  if l[0] == 1:  # To add\n\n    lca(l[1],l[2],l[3])\n\n  else: print(lca(l[1],l[2],0))\n\n\n\n# Made By Mostafa_Khaled\n", "import math\nq=int(input())\ns={}\no=[]\nfor i in range(q):\n    r=list(map(int,input().split()))\n    a,b=r[1],r[2]\n    if r[0]==2:o.append(0)\n    while a!=b:\n        if math.log2(a)>math.log2(b) and a!=1:\n            if a not in s:\n                s[a]=0\n            if r[0]==1:s[a]+=r[3]\n            else:o[-1]+=s[a]\n            a//=2\n        elif b!=1:\n            if b not in s:\n                s[b]=0\n            if r[0]==1:s[b]+=r[3]\n            else:o[-1]+=s[b]\n            b//=2\nprint(*map(str,o),sep='\\n')", "from functools import lru_cache\nfrom collections import defaultdict\nfrom itertools import tee\n\n\nprice = defaultdict(dict)\n\n\ndef add(start, end, w):\n    nonlocal price\n    for x, y in get_way(start, end):\n\n        if x not in price:\n            price[x] = defaultdict(lambda: 0)\n\n        if y not in price:\n            price[y] = defaultdict(lambda: 0)\n\n        price[x][y] += w\n        price[y][x] += w\n\n\ndef get_price(start, end):\n    result = 0\n    for x, y in get_way(start, end):\n        if x in price:\n            result += price[x][y]\n    return result\n\n\n@lru_cache(maxsize=1000)\ndef get_way(start, end):\n    def _get_raw_way():\n        nonlocal start, end\n        l_way, r_way = [start], [end]\n        while True:\n            l = l_way[-1] // 2\n            if l: l_way.append(l)\n            r = r_way[-1] // 2\n            if r: r_way.append(r)\n\n            if r_way[-1] == start:\n                return r_way\n            union = set(l_way) & set(r_way)\n            if union:\n                #print(l_way)\n                #print(r_way)\n                r_way = r_way[:r_way.index(max(union))]\n                l_way = l_way[:l_way.index(max(union))]\n                #print(l_way)\n                #print(r_way)\n                #print(r_way)\n                #del r_way[-1]\n                r_way.reverse()\n                return l_way + [union.pop()] + r_way\n\n    #print(_get_raw_way())\n    a, b = tee(_get_raw_way())\n    next(b, None)\n    return list(zip(a, b))\n\n#\nq = int(input())\nfor _ in range(q):\n    data = list(map(int, input().split(' ')))\n    if data[0] == 1:\n        add(data[1], data[2], data[3])\n    else:\n        print(get_price(data[1], data[2]))\n\n#print(get_way(568636620057521218, 935366325112217858))\n", "n=int(input())\nd={}\ndef lca(u,v,w) :\n    res=0\n    while u!=v :\n        if u<v :\n            v,u=u,v\n        d[u]=d.get(u,0)+w\n        res+=d[u]\n        u=u//2\n    return res\nfor i in range(n) :\n    l=list(map(int,input().split()))\n    if l[0]==1 :\n        lca(l[1],l[2],l[3])\n    else :\n        print(lca(l[1],l[2],0))\n        \n    \n    \n", "def path_to_root(n):\n    path = [n]\n    while n != 1:\n        if n % 2:\n            path.append((n - 1) // 2)\n            n = (n - 1) // 2\n        else:\n            path.append(n // 2)\n            n //= 2\n    return path\n\n\ndef path_beetwen(a, b):\n    p1 = path_to_root(a)\n    p2 = path_to_root(b)\n    l1 = len(p1)\n    l2 = len(p2)\n    x = 0\n    while x < l2:\n        if p2[x] in p1:\n            break\n        x += 1\n    path = p1[:p1.index(p2[x]) + 1] + p2[:x][::-1]\n    return path\n\n\ndef fee_on_path(fees, a, b):\n    path = path_beetwen(a, b)\n    total_fee = 0\n    for x in range(len(path) - 1):\n        fee = str(path[x]) + \"_\" + str(path[x + 1])\n        if fee in list(fees.keys()):\n            total_fee += fees[fee]\n    return total_fee\n\n\ndef update_fees(fees, a, b, w):\n    path = path_beetwen(a, b)\n    for x in range(len(path) - 1):\n        fee = str(path[x]) + \"_\" + str(path[x + 1])\n        fee2 = str(path[x + 1]) + \"_\" + str(path[x])\n        if fee in list(fees.keys()):\n            fees[fee] += w\n        else:\n            fees[fee] = w\n        if fee2 in list(fees.keys()):\n            fees[fee2] += w\n        else:\n            fees[fee2] = w\n\n\nclass CodeforcesTask696ASolution:\n    def __init__(self):\n        self.result = ''\n        self.events_count = 0\n        self.events = []\n\n    def read_input(self):\n        self.events_count = int(input())\n        for x in range(self.events_count):\n            self.events.append([int(y) for y in input().split(\" \")])\n\n    def process_task(self):\n        fees = {}\n        for x in range(self.events_count):\n            if self.events[x][0] == 1:\n                update_fees(fees, self.events[x][1], self.events[x][2], self.events[x][3])\n            else:\n                print(fee_on_path(fees, self.events[x][1], self.events[x][2]))\n                #print(fees)\n\n    def get_result(self):\n        return self.result\n\n\ndef __starting_point():\n    Solution = CodeforcesTask696ASolution()\n    Solution.read_input()\n    Solution.process_task()\n    print(Solution.get_result())\n\n__starting_point()", "def UCLN(a,b):\n    while (a!=b):\n        if a > b:\n            a = a//2\n        else:\n            b = b//2\n    return a\n\ndef find_path(u,v):\n    ucln = UCLN(u,v)\n    arr1 = []\n    arr2 = []\n    while (u >= ucln):\n        arr1.append(u)\n        u = u//2\n    while (v > ucln):\n        arr2.append(v)\n        v = v//2\n    return arr1 + arr2[::-1]\n\n\np = int(input())\ndic = {}\n\nfor i in range(p):\n    value = list(map(int, input().split()))\n    action = value[0]\n    if action == 1:\n        path = find_path(value[1], value[2])\n        for i in range(len(path)-1):\n            if \"{}{}\".format(path[i],path[i+1]) not in dic and \"{}{}\".format(path[i+1],path[i]) not in dic:\n                dic[\"{}{}\".format(path[i],path[i+1])] = value[3]\n                dic[\"{}{}\".format(path[i+1],path[i])] = value[3]\n            else:\n                dic[\"{}{}\".format(path[i],path[i+1])] += value[3]\n                dic[\"{}{}\".format(path[i+1],path[i])] += value[3]\n    else:\n        #action == 2\n        total = 0\n        path = find_path(value[1], value[2])\n        for i in range(len(path)-1):\n            if \"{}{}\".format(path[i],path[i+1]) in dic:\n                total += dic[\"{}{}\".format(path[i],path[i+1])]\n        print (total)\n", "cost, res = {}, []\nt = int(input())\nfor i in range(t):\n    arr = list(map(int, input().split()))\n    if len(arr) == 4:\n        _, u, v, w = arr\n        while u != v:\n            if u > v:\n                cost[u] = cost.get(u, 0) + w\n                u //= 2\n            else:\n                cost[v] = cost.get(v, 0) + w\n                v //= 2\n    else:\n        _, u, v = arr\n        curr_res = 0\n        while u != v:\n            if u > v:\n                curr_res += cost.get(u, 0)\n                u //= 2\n            else:\n                curr_res += cost.get(v, 0)\n                v //= 2\n        res.append(str(curr_res))\nprint('\\n'.join(res))\n", "def find_path(x,y):\n\tp1,p2 = [],[]\n\twhile x!=0:\n\t\tp1.append(x)\n\t\tx = x//2\n\twhile y!=0:\n\t\tp2.append(y)\n\t\ty = y//2\n\tp1 = p1[::-1]\n\tp2 = p2[::-1]\n\t# print (p1,p2)\n\tfor i in range(min(len(p1),len(p2))):\n\t\tif p1[i]==p2[i]:\n\t\t\tind = i\n\t\telse:\n\t\t\tbreak\n\tpath = []\n\tfor i in range(ind,len(p1)):\n\t\tpath.append(p1[i])\n\tpath = path[::-1]\n\tfor i in range(ind+1,len(p2)):\n\t\tpath.append(p2[i])\n\n\treturn path\n\n\nq = int(input())\ncost = {}\nfor i in range(q):\n\ta = list(map(int,input().split()))\n\tb = find_path(a[1],a[2])\n\t# print (b)\n\tif a[0] == 1:\n\t\tw = a[-1]\n\t\tfor j in range(1,len(b)):\n\t\t\tif (b[j],b[j-1]) not in cost:\n\t\t\t\tcost[(b[j],b[j-1])] = w\n\t\t\t\tcost[(b[j-1],b[j])] = w\n\t\t\telse:\n\t\t\t\tcost[(b[j],b[j-1])] += w\n\t\t\t\tcost[(b[j-1],b[j])] += w\n\telse:\n\t\tans = 0\n\t\tfor j in range(1,len(b)):\n\t\t\tif (b[j],b[j-1]) in cost:\n\t\t\t\tans += cost[(b[j],b[j-1])]\n\t\tprint (ans)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Jul 15 23:50:55 2020\n\n@author: shailesh\n\"\"\"\n\n\nfrom collections import defaultdict\n\n\ndef find_cost(node_1,node_2,intersect_dict):\n    new_dict = defaultdict(lambda : 0)\n    cost = 0\n    while node_1 != 0:\n        new_dict[node_1] = 1\n        cost+= intersect_dict[node_1]\n#        print(node_1,cost)\n        node_1 //= 2\n    \n    while node_2!=0:\n        if new_dict[node_2]:\n            cost -= intersect_dict[node_2]\n#            print(node_2)\n            break\n        else:\n            new_dict[node_2] = 1\n            cost += intersect_dict[node_2]\n            node_2 //= 2\n#            print(node_2,cost)\n    while node_2 != 0:\n        node_2 //= 2\n        cost -= intersect_dict[node_2]\n        \n    \n    return cost\n\n\ndef increase_cost_on_path(node_1,node_2,inc_cost,intersect_dict):\n    new_dict = defaultdict(lambda :0)\n    while node_1 != 0:\n        new_dict[node_1] = 1\n        intersect_dict[node_1] += inc_cost\n        node_1 //= 2\n    while node_2 != 0 :\n        if new_dict[node_2]:\n            break\n        else:\n            intersect_dict[node_2] += inc_cost\n            node_2//=2\n        \n    while node_2 != 0:\n        intersect_dict[node_2] -= inc_cost\n        node_2 //= 2\n    return intersect_dict\n\n\nQ = int(input())\n\n#arr = [0 for i in range(n+1)]\n\nintersect_dict = defaultdict(lambda : 0)\n\nfor q in range(Q):\n    query = [int(i) for i in input().split()]\n    if query[0] == 1:\n        v,u,w = query[1:]\n        intersect_dict = increase_cost_on_path(v,u,w,intersect_dict)\n    else:\n        v,u = query[1:]\n        cost = find_cost(u,v,intersect_dict)\n        print(cost)\n    \n", "# from debug import debug\nimport sys; input = sys.stdin.readline\nfrom math import log2\nfrom collections import defaultdict\nd = defaultdict(int)\nfor i in range(int(input().strip())):\n\tl = list(map(int, input().strip().split()))\n\tif l[0] == 1:\n\t\tu, v, w = l[1:]\n\t\twhile u != v:\n\t\t\tif int(log2(u)) < int(log2(v)): u, v = v, u\n\t\t\td[(u, u//2)] += w\n\t\t\tu = u//2\n\telse:\n\t\tu, v = l[1:]\n\t\tans = 0\n\t\twhile u != v:\n\t\t\tif int(log2(u)) < int(log2(v)): u, v = v, u\n\t\t\tans += d[(u, u//2)]\n\t\t\tu = u//2\n\t\tprint(ans)\n\n"]
["idx, n, seq = 2, 6, [1, 2, 4, 6]\nwhile n < 2 ** 41:\n    idx += 1\n    seq.extend(range(n + idx, n + (seq[idx] - seq[idx-1]) * idx + 1, idx))\n    n += (seq[idx] - seq[idx-1]) * idx\n\nfrom bisect import bisect\ndef find(n): return bisect(seq, n)", "cache = [0, 2, 4]\ncomp = [0, 2, 6]\n\nrepeat = len(cache)-1\nb = cache[-1]\nwhile comp[-1] < 2 ** 41:\n    if len(cache) >= b:\n        repeat += 1\n        b = cache[repeat]\n    cache.append(cache[-1] + repeat)\n    comp.append(comp[-1] + (cache[-1] - cache[-2]) * (len(cache) - 1))\n\nfrom bisect import bisect\ndef find(n):\n    repeat = bisect(comp, n)\n    return cache[repeat-1] + (n - comp[repeat-1]) // repeat", "cache = [0, 2, 4]\npc = [0, 2, 6]\n\nrepeat = len(cache)-1\nb = cache[-1]\nwhile pc[-1] < 2 ** 41:\n    if len(cache) >= b:\n        repeat += 1\n        b = cache[repeat]\n    cache.append(cache[-1] + repeat)\n    pc.append(pc[-1] + (cache[-1] - cache[-2]) * (len(cache) - 1))\n\nfrom bisect import bisect\ndef find(n):\n    repeat = bisect(pc, n)\n    return cache[repeat-1] + (n - pc[repeat-1]) // repeat", "# That was the easy?\n# - Cache is too slow (first version with bisect failed monsters)\n# - Recursion is too deep\n# - Formula is too imprecise\n# I fear what the hard version will be x)\n\nx, y, r, i, memo = 3, 4, 2, 0, []\nfor n in range(3, 100000):\n    if n > x:\n        _, _, x, r = memo[i]\n        i += 1\n    memo.append([y, r, y+r-1, n])\n    y += r\n        \ndef find(n):\n    if n < 6: return [0, 1, 2, 2, 3, 3][n]\n    x = 6\n    for a, b, _, y in memo:\n        if y * b >= n - x:\n            return (n - x) // y + a\n        x += y * b", "# ~~~without caching - 5s~~~\n\nfrom itertools import count\n\ndef find(n):\n    if n < 12:\n        return [0, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5][n]\n    track, upcoming, passed = [], 6, 12\n    _, b, repeat = 4, 5, 3\n    for ongoing in count(2+2):\n        if ongoing > b:\n            _, b, repeat = track.pop(0)\n        track.append([upcoming, upcoming + repeat - 1, ongoing])\n        if passed + (repeat * ongoing) >= n:\n            return upcoming + (n - passed) // ongoing\n        passed += repeat * ongoing\n        upcoming += repeat", "import math\n\ndef find(n):\n    first = [0, 1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21]\n    if n < 13: return first[n]\n    seq=[1,1,3,5]\n    k = 3\n    add = 3\n    count = 2\n    sum = 11\n    while(True):\n        if sum+add*len(seq)>=n:\n            return math.ceil((n-sum)/len(seq))+seq[len(seq)-1]\n        seq.append(seq[len(seq)-1]+add)\n        sum+=add*(len(seq)-1)\n        count-=1\n        if count == 0:\n            k+=1  \n            add += 1 #seq[k]-seq[k-1]\n            count= seq[k]-seq[k-1]\n        \n\n", "import math\n\n\ndef memoize(f):\n    memo = {}    \n    def helper(x):\n        if x not in memo:\n            memo[x] = f(x)\n        return memo[x]    \n    return helper\n\n\ndef find_bounds(n):\n    low_prod = 0\n    high_prod = 0\n    low = 0\n    high = 0\n    for x in range(1, n+1):\n        low = high\n        low_prod = high_prod\n        high += find(x)\n        high_prod += x * find(x)\n        if high_prod > n:\n            ratio = (n - low_prod) / (high_prod - low_prod)\n            return ratio, high, low\n\n\n@memoize   \ndef find(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    \n    ratio, high, low = find_bounds(n)\n    return low + math.ceil((high-low) * ratio)\n", "def find(n):\n    if n<4:\n        return [0,1,2,2][n]\n    \n    x,length,last_number,cycle,c = 2,2,1,2,[]\n\n    for y in range(2,10000):\n        for i in range(cycle):\n            length += x*y\n            last_number += y\n            if length >= n:\n                while length > n:\n                    length -= x\n                    last_number -= 1\n                    if length<=n:\n                        return last_number+1\n            x += 1\n        c.append(cycle)\n        if cycle <= 3 and c.count(cycle)==2: # 2\n            cycle += 1\n        elif cycle <= 5 and c.count(cycle)==3: # 2\n            cycle += 1\n        elif cycle <= 8 and c.count(cycle)==4: # 3\n            cycle += 1\n        elif cycle <= 11 and c.count(cycle)==5: # 3\n            cycle += 1\n        elif cycle <= 15 and c.count(cycle)==6: # 4\n            cycle += 1\n        elif cycle <= 19 and c.count(cycle)==7: # 4\n            cycle += 1\n        elif cycle <= 23 and c.count(cycle)==8: # 4\n            cycle += 1\n        elif cycle <= 28 and c.count(cycle)==9: # 5\n            cycle += 1\n        elif cycle <= 33 and c.count(cycle)==10: # 5\n            cycle += 1\n        elif cycle <= 38 and c.count(cycle)==11: # 5\n            cycle += 1\n        elif cycle <= 44 and c.count(cycle)==12: # 6\n            cycle += 1\n        elif cycle <= 50 and c.count(cycle)==13: # 6\n            cycle += 1\n        elif cycle <= 56 and c.count(cycle)==14: # 6\n            cycle += 1\n        elif cycle <= 62 and c.count(cycle)==15: # 6\n            cycle += 1\n        elif cycle <= 69 and c.count(cycle)==16: # 7\n            cycle += 1\n        elif cycle <= 76 and c.count(cycle)==17: # 7\n            cycle += 1\n        elif cycle <= 83 and c.count(cycle)==18: # 7\n            cycle += 1\n        elif cycle <= 90 and c.count(cycle)==19: # 7\n            cycle += 1\n        elif cycle <= 98 and c.count(cycle)==20: # 8\n            cycle += 1\n        elif cycle <= 106 and c.count(cycle)==21: # 8\n            cycle += 1\n", "from itertools import chain, repeat\n\ndef find(n):\n    if n <= 3: return [0, 1, 2, 2][n]\n    inicio, suma, largo  = [[2]], 5, 4\n    for i, j in enumerate(chain.from_iterable(inicio), 3):\n        suma += i * j\n        if suma >= n:\n            x = (suma - n) // i\n            return j + largo - x-1\n        inicio.append(repeat(i, j))\n        largo += j", "import math\n\ndef find(n):\n    level = []\n    sum2, result, i = 0,0,0\n    rem = 3\n    current = 2\n    while sum2 <= n:\n        sum2 += (i+1)*current\n        result += current\n        i += 1\n        rem -= 1\n        level.append(current)      \n        if rem == 0:\n            rem = level[current]\n            current += 1    \n    return result - math.ceil((sum2 - n)/(i))"]
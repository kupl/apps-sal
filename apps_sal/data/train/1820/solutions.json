["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return [] \n         q = [root]\n         r = []\n         while q:\n             r.append(max([i.val for i in q]))\n             q = [i for node in q for i in [node.left, node.right] if i]\n         return r", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n         res = []\n         queue = []\n         queue.append(root)\n         while queue:\n             length = len(queue)\n             res.append(max([i.val for i in queue]))\n             for i in range(length):\n                 node = queue.pop(0)\n                 if node.left:\n                     queue.append(node.left)\n                 if node.right:\n                     queue.append(node.right)\n         return res", "from collections import deque\n \n class Solution:\n     def largestValues(self, root):\n         if root is None: return []\n         q = deque([(root, 0)])\n         l = [root.val]\n         # l contains the largest values in each level from 0 to len(l) - 1\n         while len(q) != 0:\n             (node, level) = q.pop()\n             if level == len(l) - 1:\n                 l[-1] = max(l[-1], node.val)\n             else:\n                 l.append(node.val)\n             if node.left:\n                 q.appendleft((node.left, level + 1))\n             if node.right:\n                 q.appendleft((node.right, level + 1))\n         \n         return l", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         ret = []\n         row = []\n         next_row = []\n \n         if root:\n             next_row.append(root) \n \n         while next_row:\n             current_max = None\n             row = next_row\n             next_row = []\n             for node in row:\n                 if current_max == None or current_max < node.val:\n                     current_max = node.val\n                 if node.left:\n                     next_row.append(node.left) \n                 if node.right:\n                     next_row.append(node.right) \n             ret.append(current_max)\n \n         return ret", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         ret = []\n         row = []\n         next_row = []\n \n         if root:\n             next_row.append(root) \n \n         while next_row:\n             current_max = None\n             row = next_row\n             next_row = []\n             for node in row:\n                 if current_max == None or current_max < node.val:\n                     current_max = node.val\n                 if node.left:\n                     next_row.append(node.left) \n                 if node.right:\n                     next_row.append(node.right) \n             ret.append(current_max)\n \n         return ret", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def bfs(self, root):\n         queue = [root]\n         result = []\n         while queue:\n             next_q = []\n             max_val = -float(\"inf\")\n             for node in queue:\n                 max_val = max(max_val, node.val)\n                 if node.left:\n                     next_q.append(node.left)\n                 if node.right:\n                     next_q.append(node.right)\n             result.append(max_val)\n             queue = next_q\n         return result\n         \n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         return self.bfs(root) if root else []\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         result=[]\n         if root==None:\n             return result\n         queue=[root]\n         curr_row_values=[]\n         next_queue=[]\n         while len(queue)>0:\n             node=queue.pop()\n             \n             if node!=None:\n                 curr_row_values.append(node.val)\n                 next_queue.append(node.left)\n                 next_queue.append(node.right)\n             if len(queue)==0 and len(next_queue)>0:\n                 result.append(max(curr_row_values))\n                 curr_row_values=[]\n                 queue=next_queue\n                 next_queue=[]\n         return result", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         level = []\n         if root == None:\n             return []\n         level.append(root)\n         ans = []\n         \n         while len(level) != 0:\n             level_max = float(\"-inf\")\n             next_level = []\n             while len(level) != 0:\n                 cur_node = level.pop(0)\n                 level_max = max(cur_node.val, level_max)\n                 if cur_node.left != None:\n                     next_level.append(cur_node.left)\n                 if cur_node.right != None:\n                     next_level.append(cur_node.right)\n             ans.append(level_max)\n             level = next_level\n         return ans\n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n         \n         queue = [root]\n         ans = []\n         \n         while queue:\n             temp = -float(\"inf\")\n             size = len(queue)            \n             for i in range(size):\n                 node = queue.pop(0)\n                 temp = max(temp, node.val)\n                 if node.left:\n                     queue.append(node.left)\n                 if node.right:\n                     queue.append(node.right)\n             ans.append(temp)\n             \n         return ans\n                 \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if not root:\n             return []\n         stack = []\n         finallist = [root.val]\n         if root.left:\n             stack.append(root.left)\n         if root.right:\n             stack.append(root.right)\n         \n \n         while stack:\n             #print(stack)\n             temp = []\n             maxval =-2147483648\n             for node in stack:\n                 #node = stack.pop()\n                 maxval = max(maxval,node.val)\n                 if node.right:\n                     temp.append(node.right)\n                 if node.left:\n                     temp.append(node.left)\n             \n             finallist.append(maxval)\n             stack = temp\n             \n         return finallist\n                 \n         \n             \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root is None:\n             return []\n         r = []\n         s = [root]\n         t = []\n         while True:\n             mx = float('-inf')\n             for x in s:\n                 if x.left != None:\n                     t.append(x.left)\n                 if x.right != None:\n                     t.append(x.right)\n                 if x.val > mx:\n                     mx = x.val\n             r.append(mx)\n             if len(t)>0:\n                 s=t\n                 t=[]\n             else:\n                 return r", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if root==None:\n             return []\n         if root.left==None and root.right==None:\n             return [root.val]\n         if root.left:\n             l = self.largestValues(root.left)\n         else:\n             l = []\n         if root.right:\n             r = self.largestValues(root.right)\n         else:\n             r = []\n         out = [root.val]\n         for i in range(min(len(l),len(r))):\n             out.append(max(l[i],r[i]))\n         if len(l)<len(r):\n             out = out + r[len(l):]\n         elif len(r)<len(l):\n             out = out + l[len(r):]\n         return out\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def largestValues(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[int]\n         \"\"\"\n         if(root == None):\n             return []\n         rowmax = []\n         self.findRowMax(root, 1, rowmax)\n         return rowmax\n         \n         \n     def findRowMax(self, root, level, rowmax):\n         if(level > len(rowmax)):\n             rowmax.append(root.val)\n         else:\n             if(root.val > rowmax[level-1]):\n                 rowmax[level-1] = root.val\n         if(root.left != None):\n             self.findRowMax(root.left, level+1, rowmax)\n         if(root.right != None):\n             self.findRowMax(root.right, level+1, rowmax)"]
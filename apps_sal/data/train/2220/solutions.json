["import sys\nfrom itertools import accumulate \nclass Lazysegtree:\n    #RAQ\n    def __init__(self, A, intv, initialize = True, segf = min):\n        #\u533a\u9593\u306f 1-indexed \u3067\u7ba1\u7406\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        self.lazy = [0]*(2*self.N0)\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n\n    def _ascend(self, k):\n        k = k >> 1\n        c = k.bit_length()\n        for j in range(c):\n            idx = k >> j\n            self.data[idx] = self.segf(self.data[2*idx], self.data[2*idx+1]) \\\n            + self.lazy[idx]\n            \n    def _descend(self, k):\n        k = k >> 1\n        idx = 1\n        c = k.bit_length()\n        for j in range(1, c+1):\n            idx = k >> (c - j)\n            ax = self.lazy[idx]\n            if not ax:\n                continue\n            self.lazy[idx] = 0\n            self.data[2*idx] += ax\n            self.data[2*idx+1] += ax\n            self.lazy[2*idx] += ax\n            self.lazy[2*idx+1] += ax\n    \n    def query(self, l, r):\n        L = l+self.N0\n        R = r+self.N0\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        self._descend(Li)\n        self._descend(Ri - 1)\n        \n        s = self.intv                                                              \n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def add(self, l, r, x):\n        L = l+self.N0\n        R = r+self.N0\n\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        \n        while L < R :\n            if R & 1:\n                R -= 1\n                self.data[R] += x\n                self.lazy[R] += x\n            if L & 1:\n                self.data[L] += x\n                self.lazy[L] += x\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        self._ascend(Li)\n        self._ascend(Ri-1)\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L = l+self.N0\n        R = r+self.N0\n        Li = L//(L & -L)\n        Ri = R//(R & -R)\n        self._descend(Li)\n        self._descend(Ri-1)\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                ax = self.lazy[idx]\n                self.lazy[idx] = 0\n                self.data[2*idx] += ax\n                self.data[2*idx+1] += ax\n                self.lazy[2*idx] += ax\n                self.lazy[2*idx+1] += ax\n                idx = idx << 1\n                if check(self.data[idx+1]):\n                    idx += 1\n            return idx - self.N0\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                ax = self.lazy[idx]\n                self.lazy[idx] = 0\n                self.data[2*idx] += ax\n                self.data[2*idx+1] += ax\n                self.lazy[2*idx] += ax\n                self.lazy[2*idx+1] += ax\n                idx = idx << 1\n                if not check(self.data[idx]):\n                    idx += 1\n            return idx - self.N0\n    def provfunc(self):\n        idx =  1\n        if self.data[1] >= 0:\n            return -1\n        while idx < self.N0:\n            ax = self.lazy[idx]\n            self.lazy[idx] = 0\n            self.data[2*idx] += ax\n            self.data[2*idx+1] += ax\n            self.lazy[2*idx] += ax\n            self.lazy[2*idx+1] += ax\n            idx = idx << 1\n            if self.data[idx+1] < 0:\n                idx += 1\n        return idx - self.N0\n\nN, M = list(map(int, input().split()))\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\ntable = [0]*(10**6+1)\nfor a in A:\n    table[a] -= 1\nfor b in B:\n    table[b] += 1\ntable = list(accumulate(table[::-1]))[::-1]\nT = Lazysegtree(table, 0, True, min)\nQ = int(input())\nAns = [None]*Q\nfor q in range(Q):\n    t, i, x = list(map(int, sys.stdin.readline().split()))\n    i -= 1\n    if t == 1:\n        T.add(0, x+1, -1)\n        T.add(0, A[i]+1, 1)\n        A[i] = x\n    else:\n        T.add(0, x+1, 1)\n        T.add(0, B[i]+1, -1)\n        B[i] = x\n    Ans[q] = T.provfunc()\n\nprint('\\n'.join(map(str, Ans)))        \n"]
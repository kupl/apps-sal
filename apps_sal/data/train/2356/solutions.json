["n,k=map(int,input().split())\nmod=998244353\ndp=[0]*(n+1)\ndp[0]=1\nfor i in range(1,n+1):\n  for j in range(i,-1,-1):\n    dp[j]=dp[j-1]\n    if 2*j<=i:\n      dp[j]+=dp[2*j]\n    dp[j]%=mod\nprint(dp[k])", "# \u89e3\u7b54AC\nN,K = map(int, input().split())\n\nMOD = 998244353\n\n# dp[i][j]\n# j\u3092\u3001i\u500b\u306e1,1/2,...\u306b\u5206\u89e3\u3059\u308b\u65b9\u6cd5\u306f\u4f55\u901a\u308a\u3042\u308b\u304b\n# dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n# i < j => dp[i][j] = 0\ndp = [[0] * (2 * N + 1) for _ in range(N + 1)]\n\ndp[0][0] = 1\n\nfor i in range(1, N + 1):\n  for j in range(i, 0, -1):\n    dp[i][j] = (dp[i - 1][j - 1] + dp[i][2 * j]) % MOD\n\nprint(dp[N][K])", "n, k = list(map(int, input().split()))\nMOD = 998244353\n\ndp = [1]\nfor i in range(1, n + 1):\n    ndp = [0] * (i + 1)\n\n    for j in range(i, 0, -1):\n        tmp = dp[j - 1]\n        if j * 2 <= i:\n            tmp += ndp[j * 2]\n        ndp[j] = tmp % MOD\n\n    dp = ndp\n\nprint((dp[k]))\n", "N, K = list(map(int, input().split()))\nMOD = 998244353\n\n# dp[i][j] := \u8981\u7d20\u6570 i \u3067\u3001\u5408\u8a08\u304c j \u306b\u306a\u308b\u3088\u3046\u306a\u96c6\u5408\u306e\u6570\ndp = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    # dp[i][N], ..., dp[i][i+1] = 0 (\u521d\u671f\u5024\u306e\u307e\u307e)\n\n    # \u5168\u30661\u3092\u5165\u308c\u308b\u6642\u306e1\u901a\u308a\u306e\u307f\n    dp[i][i] = 1\n\n    for j in range(i - 1, 0, -1):\n        # 1\u3092\u4f7f\u3046\u5834\u5408\n        # j-1\u3092\u3001i-1\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n\n        # 1\u3092\u4f7f\u308f\u306a\u3044\u5834\u5408 -> \u5168\u3066\u30922\u500d\u3057\u3066\u8003\u3048\u308b\n        # 2*j\u3092\u3001i\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n        # 2*j > i \u306e\u5834\u5408\u3001\u5b9f\u73fe\u4e0d\u53ef\u80fd\n\n        if 2 * j <= i:\n            dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n        else:\n            dp[i][j] = dp[i - 1][j - 1]\n        dp[i][j] %= MOD\n\nprint((dp[N][K]))\n", "N, K = list(map(int, input().split()))\nMOD = 998244353\n\n# dp[i][j] := \u8981\u7d20\u6570 i \u3067\u3001\u5408\u8a08\u304c j \u306b\u306a\u308b\u3088\u3046\u306a\u96c6\u5408\u306e\u500b\u6570\ndp = [[0 for _ in range(N + 1)]for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    # dp[i][N], ..., dp[i][i+1] = 0 (\u521d\u671f\u5024\u306e\u307e\u307e)\n\n    # \u5168\u30661\u3092\u5165\u308c\u308b\u6642\u306e1\u901a\u308a\u306e\u307f\n    dp[i][i] = 1\n\n    for j in range(i - 1, 0, -1):\n        # 1\u3092\u4f7f\u3046\u5834\u5408\n        # j-1\u3092\u3001i-1\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n\n        # 1\u3092\u4f7f\u308f\u306a\u3044\u5834\u5408 -> \u5168\u3066\u30922\u500d\u3057\u3066\u8003\u3048\u308b\n        # 2*j\u3092\u3001i\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n        # 2*j > i \u306e\u5834\u5408\u3001\u5b9f\u73fe\u4e0d\u53ef\u80fd\n\n        if 2 * j <= i:\n            dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n        else:\n            dp[i][j] = dp[i - 1][j - 1]\n        dp[i][j] %= MOD\n\nprint((dp[N][K] % MOD))\n", "n,k = map(int,input().split())\nmod = 998244353\n\n# decompose K into N numbers using 1,1/2,1/4,...\n# O(N*K)\n# recursion isn't good bc implicit stack space is O(N^2), too large\n# can do O(n) space by using only two rows\n\ndp = [[0]*(n+1) for _ in range(n+1)]\n\nfor i in range(1,n+1):\n    dp[i][i] = 1\n\nfor i in range(1,n+1):\n    for j in range(i-1,0,-1):\n        dp[i][j] = dp[i-1][j-1]\n        dp[i][j] += dp[i][2*j] if 2*j <= n else 0\n        dp[i][j] = dp[i][j] % mod\nprint(dp[n][k] % mod)", "MOD = 998244353\nn, k = map(int, input().split())\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\ndp[1][1] = 1\nfor i in range(2, n+1):\n\tfor j in range(i, 0, -1):\n\t\tdp[i][j] = dp[i-1][j-1]\n\t\tif 2*j <= i:\n\t\t\tdp[i][j] += dp[i][2*j]\n\t\t\tdp[i][j] %= MOD\nprint(dp[n][k])", "mod = 998244353\nN, K = map(int, input().split())\ndp = [[0] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in reversed(range(N + 1)):\n        dp[i][j] = dp[i - 1][j - 1] + (dp[i][2 * j] if 2 * j <= N else 0)\n        dp[i][j] %= mod\nprint(dp[N][K])", "MOD = 998244353\n\nn, k = map(int, input().split())\ndp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(1, n + 1):\n    for j in range(i, 0, -1):\n        dp[i][j] = dp[i - 1][j - 1]\n        try:\n            dp[i][j] += dp[i][j * 2]\n        except IndexError:\n            pass\n        dp[i][j] %= MOD\n\nprint(dp[n][k])", "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef gen_2d(n, m, fill=0):\n    return [[fill] * m for _ in range(n)]\n\n\n@mt\ndef slv(N, K):\n    memo = gen_2d(N+1, 2*N+1)\n    memo[0][0] = 1\n    M = 998244353\n    for n in range(1, N+1):\n        for k in range(n, 0, -1):\n            x = memo[n-1][k-1]\n            x += memo[n][k*2]\n            x %= M\n            memo[n][k] = x\n    return memo[N][K]\n\n\ndef main():\n    N, K = read_int_n()\n    print(slv(N, K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef gen_2d_array(n, m, fill=0):\n    if callable(fill):\n        return [[fill()] * m for _ in range(n)]\n    else:\n        return [[fill] * m for _ in range(n)]\n\n\ndef gen_3d_array(n, m, k, fill=0):\n    if callable(fill):\n        return [[[fill()] * k for _ in range(m)] for _ in range(n)]\n    else:\n        return [[[fill] * k for _ in range(m)] for _ in range(n)]\n\n@mt\ndef slv(N, K):\n    memo = gen_2d_array(N+1, 2*N+1)\n    memo[0][0] = 1\n    M = 998244353\n    for n in range(1, N+1):\n        for k in range(n, 0, -1):\n            memo[n][k] = (memo[n-1][k-1] + memo[n][k*2]) % M\n    return memo[N][K]\n\n\ndef main():\n    N, K = read_int_n()\n    print(slv(N, K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# region header\nimport sys, bisect, math, itertools, heapq, collections\nfrom operator import itemgetter\n# a.sort(key=itemgetter(i)) # i\u756a\u76ee\u8981\u7d20\u3067sort\nfrom functools import lru_cache\nimport copy\n# @lru_cache(maxsize=None)\n# sys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nmod = 10**9 + 7\neps = 10**-7\n# endregion\n# region input function\n\n\ndef inp():\n    '''\n    \u4e00\u3064\u306e\u6574\u6570\n    '''\n    return int(input())\n\n\ndef inpl():\n    '''\n    \u4e00\u884c\u306b\u8907\u6570\u306e\u6574\u6570\n    '''\n    return list(map(int, input().split()))\n\n\ndef str_inp():\n    '''\n    \u6587\u5b57\u5217\u3092\u30ea\u30b9\u30c8\u3068\u3057\u3066\u8aad\u307f\u8fbc\u3080\n    '''\n    return list(input()[:-1])\n\n\n# endregion\nmod = 998244353\nn, k = inpl()\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n# i\u500b\u4f7f\u3063\u3066j\u3092\u4f5c\u308c\u308b\u500b\u6570\nfor i in range(1, n + 1):\n    for j in range(1, i + 1)[::-1]:\n        if i == j:\n            dp[i][j] = 1\n            continue\n        # 1\u3092\u4f7f\u3046(i-1\u500b\u4f7f\u3063\u3066j-1\u3092\u4f5c\u3063\u305f\u3082\u306e\u306b1\u3092\u6dfb\u3048\u308b)\n        a = dp[i - 1][j - 1]\n        # 1\u3092\u4f7f\u308f\u306a\u3044(1\u3092\u542b\u3081\u3066i\u500b\u4f7f\u3063\u30662j\u3092\u4f5c\u308a\u3001\u5168\u4f53\u30921/2\u3059\u308b)\n        b = dp[i][2 * j] if 2 * j < n + 1 else 0\n        dp[i][j] = (a + b) % mod\nprint((dp[n][k] % mod))\n", "N,K=list(map(int,input().split()))\nm=998244353\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0]=1\nfor n in range(1,N+1):\n    for k in range(N,-1,-1):\n        if 2*k<=N:\n            dp[n][k]=(dp[n-1][k-1]+dp[n][2*k])%m\n        else:\n            dp[n][k] =(dp[n-1][k-1])%m\nprint((dp[N][K]))\n\n", "def solve():\n    MOD = 998244353\n\n    N, K = list(map(int, input().split()))\n\n    N2 = N-N%2\n\n    dp = [[0]*(N+1) for _ in range(N-K+1)]\n    accRevDp = [[0]*(N+1) for _ in range(N-K+1)]\n    dp[0][K] = 1\n    accRevDp[0] = [1]*(K+1) + [0]*(N-K)\n    for i in range(1, N-K+1):\n        j = min(N2, 2*i)\n        dp[i][j] = accRevDp[i][j] = accRevDp[i-j//2][j//2]\n        for j in reversed(list(range(0, min(N2, 2*i), 2))):\n            dp[i][j] = accRevDp[i-j//2][j//2]\n            accRevDp[i][j+1] = accRevDp[i][j+2]\n            accRevDp[i][j] = (accRevDp[i][j+1] + dp[i][j]) % MOD\n\n    ans = sum(dp[N-K]) % MOD\n    print(ans)\n\n\nsolve()\n", "def solve():\n    MOD = 998244353\n\n    N, K = list(map(int, input().split()))\n\n    N2 = N-N%2\n\n    dp = [[0]*(N+1) for _ in range(N-K+1)]\n    accRevDp = [[0]*(N+1) for _ in range(N-K+1)]\n    dp[0][K] = 1\n    accRevDp[0] = [1]*(K+1) + [0]*(N-K)\n    for i in range(1, N-K+1):\n        j = min(N2, 2*i)\n        dp[i][j] = accRevDp[i][j] = accRevDp[i-j//2][j//2]\n        for j in reversed(list(range(0, min(N2, 2*i), 2))):\n            dp[i][j] = accRevDp[i-j//2][j//2]\n            accRevDp[i][j+1] = accRevDp[i][j+2]\n            accRevDp[i][j] = (accRevDp[i][j+1] + dp[i][j]) % MOD\n\n    ans = sum(dp[N-K]) % MOD\n    print(ans)\n\n\nsolve()\n", "n,k=map(int,input().split())\ndp=[[0 for j in range(3001)] for i in range(n+1)]\n\nfor i in range(1, n+1):\n  for j in range(3000, -1, -1):\n    if i < j or j == 0:\n      dp[i][j] = 0\n    elif i == j:\n      dp[i][j] = 1\n    else:\n      dp[i][j] = (dp[i-1][j-1] + (0 if i < j*2 else dp[i][j*2])) % 998244353\n\nprint(dp[n][k])", "from itertools import combinations\nP = 998244353\nnn = 2002002\nfa = [1] * (nn+1)\nfainv = [1] * (nn+1)\nfor i in range(nn):\n    fa[i+1] = fa[i] * (i+1) % P\n\ndp = []\nfor _ in range(3001):\n  dp.append([0]*3001)\n\nfor i in range(3001):\n  dp[i][i] = 1\n\nfor i in range(1,3001):\n  for j in reversed(range(1,i)):\n    if 2*j > 3000:\n      dp[i][j] = dp[i-1][j-1]\n    else:\n      dp[i][j] = (dp[i-1][j-1] + dp[i][2*j])%P\n\nN,K = [int(i) for i in input().split()]\nprint(dp[N][K])", "n, k = map(int, input().split())\nmod = 998244353\ndp = [[0] * 6005 for _ in range(3001)]\ndp[0][0] = 1\nfor i in range(1, 3001):\n    for j in range(i, 0, -1):\n        dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n        dp[i][j] %= mod\nans = dp[n][k]\nprint(ans)", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, K = mapint()\nmod = 998244353\n\ndp = [[0]*(N*2+1) for _ in range(N+1)]\ndp[0][0] = 1\n\nfor i in range(1, N+1):\n    for j in range(N, 0, -1):\n        # j-1 \u306e i-1 \u5206\u5272\u306b 1 \u3092\u8db3\u3059 + 2*j \u306e i \u5206\u5272\u3092 2 \u3067\u5272\u308b\n        dp[i][j] = (dp[i-1][j-1] + dp[i][2*j])%mod\n\nprint(dp[N][K]%mod)", "n,k=map(int,input().split())\ndp=[[0]*(2*n+1) for i in range(n+1)]\ndp[0][0]=1\nmod=998244353\n\nfor i in range(1,n+1):\n    for j in range(i,0,-1):\n        dp[i][j]=dp[i-1][j-1]+dp[i][2*j]\n        dp[i][j]%=mod\n\n\nprint(dp[n][k])", "N,K = map(int,input().split())\n\nmat=[[0 for i in range(j+1)]for j in range(N+1)]\n\ndef tar(Num,Sum):\n\n  if Num < Sum:\n\n    return 0\n\n  return mat[Num][Sum]\n\nmat[1][1]=1\n\nMOD = 998244353\n\nfor i in range(2,N+1):\n\n  for j in range(1,i+1)[::-1]:\n\n    mat[i][j]=tar(i-1,j-1)+tar(i,2*j)\n\n    mat[i][j]%=MOD\n\n(print(mat[N][K]))", "mod = 998244353\nN, K = map(int, input().split())\ndp = [[0] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in reversed(range(N + 1)):\n        dp[i][j] = dp[i - 1][j - 1] + (dp[i][2 * j] if 2 * j <= N else 0)\n        dp[i][j] %= mod\nprint(dp[N][K])", "mod = 998244353\nN, K = map(int, input().split())\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1,N+1):\n  for j in range(1,N+1):\n    k = j - 1\n    while k <= i:\n      dp[i][j] += dp[i - 1][k]\n      dp[i][j] %= mod\n      k = k * 2 + 1\nans = dp[N][K]%mod\nprint(ans)", "MOD = 998244353\n\n\ndef f(N, K):\n    if K > N:\n        return 0\n    \n    S0 = [1]\n    for i in range(1, N+1):\n        S1 = [0]*(i+1)\n        for j in range(i, 0, -1):\n            S1[j] = (S0[j-1] + (S1[j*2] if j*2<=i else 0))%MOD\n        S0 = S1\n    \n    return S0[K]\n        \nN, K = list(map(int, input().split()))\nprint((f(N,K)))\n", "N,K = map(int,input().split())\n\nmat=[[0 for i in range(j+1)]for j in range(N+1)]\n\ndef tar(Num,Sum):\n\n  if Num < Sum:\n\n    return 0\n\n  return mat[Num][Sum]\n\nmat[1][1]=1\n\nMOD = 998244353\n\nfor i in range(1,N+1):\n\n  for j in range(1,i+1)[::-1]:\n    if i*j==1:continue\n    mat[i][j]=tar(i-1,j-1)+tar(i,2*j)\n\n    mat[i][j]%=MOD\n\n(print(mat[N][K]))", "import sys\nimport math\nimport itertools\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\nfrom operator import itemgetter, attrgetter\nfrom itertools import permutations, combinations\nsys.setrecursionlimit(500000)\n\nn, K = map(int, input().split())\nmo = 998244353\na = [[0] * (n + 2) for _ in range(n + 2)]\na[0][0] = 1\nfor i in range(1, n + 1):\n    for j in range(n, 0, -1):\n        a[i][j] = a[i - 1][j - 1] + (a[i][j * 2] if j * 2 <= n else 0)\n        a[i][j] %= mo\nprint(a[n][K] % mo)", "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef gen_2d(n, m, fill=0):\n    return [[fill] * m for _ in range(n)]\n\n\n@mt\ndef slv(N, K):\n    memo = gen_2d(N+1, 2*N+1)\n    memo[0][0] = 1\n    M = 998244353\n    for n in range(1, N+1):\n        for k in range(n, 0, -1):\n            memo[n][k] = (memo[n-1][k-1] + memo[n][k*2]) % M\n    return memo[N][K]\n\n\ndef main():\n    N, K = read_int_n()\n    print(slv(N, K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = map(int, input().split())\nmod = 998244353\ndp = [[0 for _ in range(N+1)] for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1, N+1):\n    for j in reversed(range(N+1)):\n        dp[i][j] = dp[i-1][j-1] \n        if 2*j <= N:\n            dp[i][j] += dp[i][2*j]\n        dp[i][j] %= mod\n\nprint(dp[N][K])", "def solve():\n    MOD = 998244353\n\n    N, K = list(map(int, input().split()))\n\n    dp = [[0]*(N+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for num in range(1, N+1):\n        for sm in reversed(list(range(N+1))):\n            if num > 0 and sm > 0:\n                dp[num][sm] += dp[num-1][sm-1]\n            if 2*sm <= N:\n                dp[num][sm] += dp[num][2*sm]\n            dp[num][sm] %= MOD\n\n    ans = dp[N][K]\n    print(ans)\n\n\nsolve()\n", "def MI():\n    return list(map(int, input().split()))\n\nn,k= MI()\nmod=998244353\nif n<k:\n    print((0))\n    return\n\ndp=[[0]*(2*n+1) for i in range(n+1)]\ndp[0][0]=1\nfor i in range(1,n+1):\n    for j in range(i,0,-1):\n        dp[i][j]+=dp[i][j*2]+dp[i-1][j-1]\n        dp[i][j]%=mod\n\nprint((dp[n][k]))\n", "N, K= map(int, input().split())\ndp = [[0]*(N+2) for i in range(N+1)]\n\nfor i in range(1, N+1):\n    dp[i][i] = 1\n    for j in range(i-1, 0, -1):\n        dp[i][j] = (dp[i-1][j-1] + dp[i][min(2*j, N+1)])%998244353\n\nprint(dp[N][K])", "MOD=998244353\nINF=float('inf')\n\nN,K=map(int,input().split())\ndp=[[0]*(N+1) for _ in range(N+1)]\ndp[0][0]=1\n\nfor i in range(1,N+1):\n    for j in reversed(range(1,N+1)):\n        dp[i][j]=dp[i-1][j-1]\n        if j*2<=N:\n            dp[i][j]=(dp[i][j]+dp[i][2*j])%MOD\nprint(dp[N][K])", "import sys\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(10000)\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\nmod=998244353\n\n\"\"\"\nK\u500b\u306e1\u3092\u7528\u610f\u3057\u3066\uff0c\u3053\u308c\u3089\u3092\u9069\u5f53\u306a\u500b\u6570\u306b\u5206\u5272\u3057\u3066\u3044\u304f\u3053\u3068\u3092\u8003\u3048\u308b\uff0e\n\u5408\u8a08\u3067N\u500b\u306b\u5206\u3051\u305f\u3044\u306e\u3067,\u3053\u308c\u306f\u7389\u3092\u533a\u5225\u3057\u306a\u3044,\u7bb1\u3092\u533a\u5225\u3057\u306a\u3044,\u5404\u7bb1\u306b\u6700\u4f4e1\u3064,\n\u306e\u6761\u4ef6\u307d\u3044\u306e\u3067\u5206\u5272\u6570\u307d\u3044.\n\n\u305f\u3060\u3057,1\u30924\u500b\u306b\u5206\u3051\u308b\u6642\u306b2\u30d1\u30bf\u30fc\u30f3\u3042\u3063\u305f\u308a\u3059\u308b.\nn=?,K=1\u306e\u6642\u306b\u3044\u3044\u611f\u3058\u306e\u5024\u3092\u8fd4\u3059\u3088\u3046\u306b\u3057\u305f\u3044.\n\n\u4ed6\u306b\u3082\uff0c\u4f7f\u30461\u306e\u500b\u6570\u3067\u5834\u5408\u5206\u3051\u3068\u3044\u3046\u306e\u3082\u3042\u308b\uff0e\n1\u3092a\u500b\u4f7f\u3046\u3068\uff0c1\u4ee5\u5916\u306eN-a\u500b\u306e\u6570\u3067K-a\u3092\u4f5c\u308b\u3068\u3044\u3046\u3053\u3068\u306b\u306a\u308a\uff0c\u3053\u308c\u306f\u5024\u30922\u500d\u3059\u308c\u3070N-a\u500b\u30672(K-a)\u3092\u4f5c\u308b\u306e\u3068\u540c\u5024\n\n\u672c\u756a\u4e2d\u306f\u982d\u304c\u30d0\u30b0\u3063\u3066\u3044\u305f\u304c\uff0c5\u500b\u30671\u3092\u4f5c\u308b\u6642\u30823\u30d1\u30bf\u30fc\u30f3\u3042\u308b\u306d\nj=1\u306e\u6642\u3060\u3051\u5225\u500b\u3067\u6c42\u3081\u3088\u3046\u304b\uff0e\n\n\n\u3042\u30fc,dp\u30c6\u30fc\u30d6\u30eb\u3092\u57cb\u3081\u308b\u6642\uff0ci=j\u306e\u6642\u306bdp[i][j]\u304c1\u306a\u3093\u3060\u304b\u3089\uff0cj\u306e\u964d\u9806\u306b\u57cb\u3081\u3066\u3051\u3070\u3044\u3044\u3093\u3058\u3083\u3093\u304b...\n\u659c\u3081(\u6842\u99ac\u3063\u307d\u3044\u52d5\u304d)\u306e\u7d2f\u7a4d\u548c\u3092\u6301\u3066\u3070\u826f\u3055\u3052\uff0c\u3060\u3051\u3069\uff0c\u3053\u306e\u7d2f\u7a4d\u548c\u306e\u9014\u4e2d\u90e8\u5206\u3092\u3069\u3053\u304b\u3067\u5229\u7528\u3057\u3066\u3044\u308b\u306e\u3067\u305d\u306e\u30de\u30b9\u3092\u3046\u307e\u304f\u4f7f\u3048\u3070\u826f\u3044.\n\ndp[i][j]=dp[i][2j]+dp[i-1][j-1]\n\"\"\"\n\n\nN,K=MI()\nif N==K:\n    print((1))\n    return\n\nif K>N:\n    print((0))\n    return\n    \nM=max(N,K)\ndp=[[0]*(M+1) for _ in range(N+1)]\n# dp[i][j]\u306fi\u500b\u3067j\u3092\u4f5c\u308b\n\nfor i in range(1,M+1):\n    dp[i][i]=1\n\nfor i in range(1,N+1):\n    for j in range(i-1,0,-1):\n        dp[i][j]=dp[i-1][j-1]\n        if 2*j<=M:\n            dp[i][j]+=dp[i][2*j]\n        dp[i][j]%=mod\n\n\nprint((dp[N][K]))\n        \n# for i in range(N+1):\n#     print(dp[i])\n    \n", "N, K = list(map(int, input().split()))\nmod = 998244353\ndp = [0] *(N+1)\ndp[0] = 1\nfor i in range(1, N+1):\n    for j in range(i, -1, -1):\n        dp[j] =dp[j-1]\n        if j*2 <= i:\n            dp[j] += dp[2*j]\n        dp[j] %= mod\nprint((dp[K]))\n", "N, K = list(map(int, input().split()))\nMOD = 998244353\n\n# dp[i][j] := \u8981\u7d20\u6570 i \u3067\u3001\u5408\u8a08\u304c j \u306b\u306a\u308b\u3088\u3046\u306a\u96c6\u5408\u306e\u500b\u6570\ndp = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    # dp[i][N], ..., dp[i][i+1] = 0 (\u521d\u671f\u5024\u306e\u307e\u307e)\n\n    # \u5168\u30661\u3092\u5165\u308c\u308b\u6642\u306e1\u901a\u308a\u306e\u307f\n    dp[i][i] = 1\n\n    for j in range(i - 1, 0, -1):\n        # 1\u3092\u4f7f\u3046\u5834\u5408\n        # j-1\u3092\u3001i-1\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n\n        # 1\u3092\u4f7f\u308f\u306a\u3044\u5834\u5408 -> \u5168\u3066\u30922\u500d\u3057\u3066\u8003\u3048\u308b\n        # 2*j\u3092\u3001i\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n        # 2*j > i \u306e\u5834\u5408\u3001\u5b9f\u73fe\u4e0d\u53ef\u80fd\n\n        if 2 * j <= i:\n            dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n        else:\n            dp[i][j] = dp[i - 1][j - 1]\n        dp[i][j] %= MOD\n\nprint((dp[N][K] % MOD))\n", "N,K=list(map(int,input().split()))\nm=998244353\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0]=1\nfor n in range(1,N+1):\n    for k in range(N,-1,-1):\n        if 2*k<=N:\n            dp[n][k]=(dp[n-1][k-1]+dp[n][2*k])%m\n        else:\n            dp[n][k] =(dp[n-1][k-1])%m\nprint((dp[N][K]))\n", "import sys\nimport math\nfrom collections import defaultdict\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    mod = 998244353\n\n    dp = [0] *(N+1)\n\n    dp[0] = 1\n\n    for i in range(1, N+1):\n        for j in range(i, -1, -1):\n            dp[j] =dp[j-1]\n            if j*2 <= N:\n                dp[j] += dp[2*j]\n            dp[j] %= mod\n\n    print((dp[K]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = list(map(int, input().split()))\nC = 998244353\n\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1, N+1):\n    for j in range(N, 0, -1):\n        if j > i:\n            continue\n        dp[i][j] = dp[i-1][j-1]\n        if 2*j <= N:\n            dp[i][j] = (dp[i][j]+dp[i][2*j]) % C\nprint((dp[N][K]))\n\n", "N,K=list(map(int,input().split()))\nMod=998244353\n\nDP=[0]*(N+1)\nDP[0]=1\n\nfor x in range(1,N+1):\n    ODP,DP=DP,[0]*(N+1)\n    for k in range(N,-1,-1):\n        DP[k]=ODP[k-1]\n        if 2*k<=N:\n            DP[k]+=DP[2*k]\n            DP[k]%=Mod\n\nprint((DP[K]))\n", "n,k = map(int,input().split())\na = [[0]*(n+1) for i in range(n+1)]\nfor i in range(1,n+1):\n  for j in range(i,0,-1):\n    if i==j:\n      a[i][j] = 1\n    elif j>0:\n      a[i][j] = a[i-1][j-1]\n      if i>=2*j:\n        a[i][j] += a[i][2*j]\n        a[i][j] %= 998244353\nprint(a[n][k])", "n,k=map(int,input().split())\ndp=[[0]*(2*n+1) for _ in range(n+1)]\ndp[0][0]=1\nmod=998244353\nfor i in range(1,n+1):\n    for j in reversed(range(n+1)):\n        dp[i][j]+=dp[i][2*j]\n        if j>0:\n            dp[i][j]+=dp[i-1][j-1]\n        dp[i][j]%=mod\nprint(dp[n][k])", "n, k = map(int, input().split())\nMOD = 998244353\n\n\ndp = [[0] * (n + 1) for i in range(n + 1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(1, n + 1)[::-1]:\n        dp[i + 1][j] += dp[i][j - 1]\n        if 2 * j <= n:\n            dp[i + 1][j] += dp[i + 1][2 * j]\n        dp[i + 1][j] %= MOD\n\nprint(dp[n][k] % MOD) ", "N,K = list(map(int,input().split()))\n\nMOD = 998244353\n\ndp = [[0 for i in range(N+1)] for j in range(N+1)]\n\ndp[1][1] = 1\n\nfor i in range(1,N+1):\n    for j in range(N,0,-1):\n        if (i,j) == (1,1):\n            continue\n        else:\n            dp[i][j] = (dp[i-1][j-1] + (dp[i][2*j] if 2*j <= N else 0)) % MOD\n\nprint((dp[N][K]))\n\n", "N,K = map(int,input().split())\nMOD = 998244353\n\ndp = [[0]*(2*N+1) for _ in range(N+1)]\ndp[0][0] = 1\n\nfor i in range(1,N+1):\n    for j in range(N,0,-1):\n        if i < j: continue\n        dp[i][j] += dp[i-1][j-1] + dp[i][2*j]\n        dp[i][j] %= MOD\nprint(dp[N][K])", "import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #int\u306elist\n    return list(map(int,input().split()))\ndef m(): #\u8907\u6570\u6587\u5b57\n    return map(int,input().split())\ndef onem(): #N\u3068\u304b\u306e\u53d6\u5f97\n    return int(input())\ndef s(x): #\u5727\u7e2e\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #list\u3092\u30b9\u30da\u30fc\u30b9\u3054\u3068\u306b\u5206\u3051\u308b\n    return \" \".join(map(str,x))\ndef max2(x): #\u4ed6\u306e\u3068\u304d\u3082\u3069\u3046\u3088\u3046\u306b\u4f5c\u6210\u53ef\u80fd\n    return max(map(max,x))\ndef In(x,a): #a\u304c\u30ea\u30b9\u30c8(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)//2\n\n    if rr == mid:\n        return ll\n    if (\u3053\u3053\u306b\u8a55\u4fa1\u5165\u308c\u308b):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\nmod = 998244353\nn,k = m()\n\ndp = [[0 for i in range(n+1)] for j in range(n+1)]\n\ndp[0][0] = 1\nfor i in range(1,n+1):\n    for j in range(n,-1,-1):\n        if 2*j <= n:\n            dp[i][j] = dp[i-1][j-1] + dp[i][2*j]\n            dp[i][j] %= mod\n        else:\n            dp[i][j] = dp[i-1][j-1]\n            dp[i][j] %= mod\n\nprint(dp[n][k])", "n,k = map(int,input().split())\nmod = 998244353\ndp = [[0]*(n+1) for _ in range(n+1)]\ndp[1][1] = 1\nfor i in range(2,n+1):\n    for j in range(i,0,-1):\n        if 2*j<=i:\n            dp[i][j] = (dp[i-1][j-1] + dp[i][2*j])%mod\n        else:\n            dp[i][j] = dp[i-1][j-1]%mod\nprint(dp[n][k])", "\nmod = 998244353\nn,k = map(int,input().split())\n\ndp = [[0]*(n+1) for i in range(n+1)]\ndp[0][0] = 1\nfor i in range(1,n+1):\n    for j in range(i,-1,-1):\n        if j:\n            dp[i][j] += dp[i-1][j-1]\n        if j*2 <= i:\n            dp[i][j] += dp[i][j*2]\n        dp[i][j] %= mod\nprint(dp[n][k])", "import sys\ntry:\n    import os\n    f = open('input.txt', 'r')\n    sys.stdin = f\nexcept FileNotFoundError:\n    None\nfrom math import sqrt, ceil, floor\nfrom collections import deque, Counter, defaultdict\n# defaultdict(int)\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright, insort\nfrom itertools import combinations as com, permutations as per\nfrom fractions import Fraction as frac  #frac(a,b)\u3067\u6b63\u78ba\u306aa/b\n# @lru_cache(maxsize=10**10)\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\n\nn,k=list(map(int,input().split()))\nmod=998244353\n# @lru_cache(maxsize=10**10)\n# def saiki(n,k):\n#     print(n,k,flush=1)\n#     if n<k:return 0\n#     if n==k:return 1\n#     if n==0:return 0\n#     if k==0: return 0\n#     if n==1:return 1\n#     if k==1: return saiki(n,2*k)\n#     return (saiki(n-1,k-1)+ saiki(n,2*k))%mod\n\ndp=[[0]*3002 for  i in range(3003)]\n# dp[1][1]=1\nfor i in range(1,n+1):\n    for j in range(n,0,-1):\n        if i<j:dp[i][j]=0\n        elif i==j : dp[i][j]=1\n        elif 2*j >i: dp[i][j]=dp[i-1][j-1]\n        else: dp[i][j]=(dp[i-1][j-1]+ dp[i][2*j])%mod\n\nprint((dp[n][k]))\n", "from pprint import *\ndef modpow(a,n,p):\n    if n==0:\n        return 1\n    x=modpow(a,n//2,p)\n    x=(x*x)%p\n    if (n%2)==1:\n        x=(x*a)%p\n    return x%p\ndef modinv(a,p):\n    return modpow(a,p-2,p)\nN,K=list(map(int,input().split()))\np=998244353\ndp=[[-1 for _ in range(N+1)] for _ in range(N+1)]\nfor i in range(N+1):\n    dp[i][i]=1\nfor i in range(1,N+1):\n    dp[i][0]=0\nfor i in range(1,N+1):\n    for j in range(0,i):\n        dp[j][i]=0\n#pprint(dp)\nfor i in range(1,N+1):\n    for j in range(N,0,-1):\n        #print(i,j)\n        if dp[i][j]==-1:\n            if 2*j<=i:\n                dp[i][j]=(dp[i-1][j-1]+dp[i][2*j])%p\n            else:\n                dp[i][j]=dp[i-1][j-1]%p\n        #pprint(dp)\nprint((dp[N][K]))\n", "N, K = map(int, input().split())\nmod = 998244353\ndp = [0] *(N+1)\ndp[0] = 1\nfor i in range(1, N+1):\n    for j in range(i, -1, -1):\n        dp[j] =dp[j-1]\n        if j*2 <= i:\n            dp[j] += dp[2*j]\n        dp[j] %= mod\nprint(dp[K])", "N, K = map(int, input().split())\nMOD = 998244353\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[1][1] = 1\n\ndef get_dp(n, k):\n    try:\n        return dp[n][k]\n    except:\n        return 0\n\n\nfor n in range(2, N+1):\n    for k in range(n, -1, -1):\n        dp[n][k] = get_dp(n-1, k-1) + get_dp(n, 2*k)\n        dp[n][k] %= MOD\n\nprint(dp[N][K])", "N, K = list(map(int, input().split()))\nMOD = 998244353\n\n# dp[i][j] := \u8981\u7d20\u6570 i \u3067\u3001\u5408\u8a08\u304c j \u306b\u306a\u308b\u3088\u3046\u306a\u96c6\u5408\u306e\u500b\u6570\ndp = [[0] * (N + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    # dp[i][N], ..., dp[i][i+1] = 0 (\u521d\u671f\u5024\u306e\u307e\u307e)\n\n    # \u5168\u30661\u3092\u5165\u308c\u308b\u6642\u306e1\u901a\u308a\u306e\u307f\n    dp[i][i] = 1\n\n    for j in range(i - 1, 0, -1):\n        # 1\u3092\u4f7f\u3046\u5834\u5408\n        # j-1\u3092\u3001i-1\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n\n        # 1\u3092\u4f7f\u308f\u306a\u3044\u5834\u5408 -> \u5168\u3066\u30922\u500d\u3057\u3066\u8003\u3048\u308b\n        # 2*j\u3092\u3001i\u500b\u306e[1, 1/2, 1/4,...]\u306b\u5206\u3051\u308b\u5834\u5408\u306e\u6570\n        # 2*j > i \u306e\u5834\u5408\u3001\u5b9f\u73fe\u4e0d\u53ef\u80fd\n\n        if 2 * j <= i:\n            dp[i][j] = dp[i - 1][j - 1] + dp[i][2 * j]\n        else:\n            dp[i][j] = dp[i - 1][j - 1]\n        dp[i][j] %= MOD\n\nprint((dp[N][K] % MOD))\n", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\nfrom itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\n#from fractions import Fraction\nsys.setrecursionlimit(100000)\nINF = float('inf')\nmod = 998244353\n\n\nn,k=mdata()\ndp=[[0]*(n+1) for i in range(n+1)]\ndp[0][0]=1\ndp[1][1]=1\ndp1 = [0] * (2 * n + 1)\nfor i in range(2,n+1):\n    for j in range(i,0,-1):\n        dp[i][j] = (dp[i-1][j-1] + dp1[2*j])%mod\n        dp1[j] = dp[i][j]%mod\nout(dp[n][k])\n", "N, K = map(int, input().split())\nmod = 998244353\ndp = [[0]*(N+1) for _ in range(N+1)]\n\ndp[1][1] = 1\n\nfor n in range(2,N+1):\n  for k in range(n,0,-1):\n    if 2*k <= n:\n      dp[n][k] = (dp[n-1][k-1] + dp[n][2*k]) % mod\n    else:\n      dp[n][k] = dp[n-1][k-1] % mod\n      \nprint(dp[N][K])", "n, k = map(int, input().split())\ndp = [[0] * (2*n+1) for _ in range(n+1)]\ndp[0][0] = 1\nfor i in range(1, n+1):\n    for j in reversed(range(i+1)):\n        dp[i][j] = (dp[i-1][j-1] + dp[i][2*j]) % 998244353\nprint(dp[n][k])", "N,K = map(int,input().split())\ndp = [[0]*n for n in range(1,N+2)]\nfor n in range(N+1):\n    dp[n][n] = 1\n    for k in reversed(range(1,n)):\n        if 2*k <= n:\n            dp[n][k] = (dp[n-1][k-1] + dp[n][2*k])% 998244353\n        else:\n            dp[n][k] = dp[n-1][k-1]\n    dp[n][0] = 0\n#    print(dp)\nprint(dp[N][K])", "import sys\nimport math\nfrom collections import defaultdict\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N, K = list(map(int, input().split()))\n    mod = 998244353\n\n    dp = [[0]*(N+1) for _ in range(N+1)]\n\n    dp[0] = [1] + [0]*N\n\n    for i in range(1, N+1):\n        for j in range(i, 0, -1):\n            dp[i][j] += dp[i-1][j-1]\n            if j*2 <= N:\n                dp[i][j] += dp[i][2*j]\n            dp[i][j] %= mod\n\n    print((dp[N][K]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\ndef main():\n    N, K = list(map(int, input().split()))\n    mod = 998244353\n\n    dp = [0] *(N+1)\n\n    dp[0] = 1\n\n    for i in range(1, N+1):\n        for j in range(i, -1, -1):\n            dp[j] =dp[j-1]\n            if j*2 <= N:\n                dp[j] += dp[2*j]\n            dp[j] %= mod\n\n    print((dp[K]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import bisect, collections, copy, heapq, itertools, math, string\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\nfrom collections import deque, defaultdict, Counter\nimport heapq\nfrom functools import reduce\nfrom itertools import permutations\nimport math\nimport bisect\n\ndef main():\n    mod = 998244353\n    def comp(x, y):\n        if x < y:\n            return 0\n        return dp[x][y]\n    N, K = MI()\n    dp = [[0 for _ in range(N + 1)]for _ in range(N + 1)]\n    dp[0][0] = 1\n    dp[0][1] = 0\n    dp[1][0] = 0\n    dp[1][1] = 1\n    for i in range(2, N + 1):\n        for j in range(N, 0, -1):\n            dp[i][j] = comp(i - 1, j - 1) + comp(i, 2 * j)\n            dp[i][j] %= mod\n    #print(dp)\n    print((dp[N][K]))\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef gen_2d_array(n, m, fill=0):\n    if callable(fill):\n        return [[fill()] * m for _ in range(n)]\n    else:\n        return [[fill] * m for _ in range(n)]\n\n\ndef gen_3d_array(n, m, k, fill=0):\n    if callable(fill):\n        return [[[fill()] * k for _ in range(m)] for _ in range(n)]\n    else:\n        return [[[fill] * k for _ in range(m)] for _ in range(n)]\n\n\n@mt\ndef slv(N, K):\n    memo = gen_2d_array(N+1, 2*N+1)\n    memo[0][0] = 1\n    M = 998244353\n    for n in range(1, N+1):\n        for k in range(n, 0, -1):\n            memo[n][k] = (memo[n-1][k-1] + memo[n][k*2]) % M\n    return memo[N][K]\n\ndef main():\n    N, K = read_int_n()\n    print(slv(N, K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, K = map(int, input().split())\nM = 998244353\ndp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in range(N, 0, -1):\n        dp[i][j] = dp[i - 1][j - 1]\n        if 2 * j <= N:\n            dp[i][j] += dp[i][2 * j]\n        dp[i][j] %= M\nprint(dp[N][K])", "MOD = 998244353\n\n\ndef solve(n, k):\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i, -1, -1):\n            if 2 * j <= i:\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i][2 * j]) % MOD\n            else:\n                dp[i][j] = dp[i - 1][j - 1]\n    # print(dp)\n    return dp[n][k]\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    res = solve(n, k)\n    print(res)\n\n\ndef test():\n    assert solve(4, 2) == 2\n    assert solve(2525, 425) == 687232272\n\n\ndef __starting_point():\n    test()\n    main()\n\n__starting_point()", "# dp[i, j] = number of ways to decompose j into i values\n# dp[i, j] = 0 if i < j\n# dp[0, K] = 1\n# dp[i, j] = dp[i - 1, j - 1] + dp[i, 2 * j]\n\nN, K = list(map(int, input().split()))\nM = 998244353\ndp = [[0 for _ in range(2 * N + 1)] for _ in range(N + 1)]\ndp[0][0] = 1\nfor i in range(1, N + 1):\n    for j in range(N, 0, -1):\n        dp[i][j] = dp[i - 1][j - 1]\n        dp[i][j] += dp[i][2 * j]\n        dp[i][j] %= M\n# print(dp)\nprint((dp[N][K]))\n\n", "# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n# readline = sys.stdin.buffer.readline\nreadline = sys.stdin.readline\n\nINF = 1 << 60\n\n\ndef read_int():\n    return int(readline())\n\n\ndef read_int_n():\n    return list(map(int, readline().split()))\n\n\ndef read_float():\n    return float(readline())\n\n\ndef read_float_n():\n    return list(map(float, readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\n\ndef ep(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.perf_counter()\n        ret = f(*args, **kwargs)\n        e = time.perf_counter()\n\n        ep(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef gen_2d_array(n, m, fill=0):\n    if callable(fill):\n        return [[fill()] * m for _ in range(n)]\n    else:\n        return [[fill] * m for _ in range(n)]\n\n\ndef gen_3d_array(n, m, k, fill=0):\n    if callable(fill):\n        return [[[fill()] * k for _ in range(m)] for _ in range(n)]\n    else:\n        return [[[fill] * k for _ in range(m)] for _ in range(n)]\n\n\n@mt\ndef slv(N, K):\n    memo = gen_2d_array(N+1, 2*N+1)\n    memo[0][0] = 1\n    M = 998244353\n    for n in range(1, N+1):\n        for k in range(n, 0, -1):\n            memo[n][k] = (memo[n-1][k-1] + memo[n][k*2]) % M\n    return memo[N][K]\n\ndef main():\n    N, K = read_int_n()\n    print(slv(N, K))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n    mod = 998244353\n    n, k = list(map(int, input().split()))\n    dp = [[0]*(n+1) for _ in [0]*(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(n, 0, -1):\n            if 2*j <= n:\n                dp[i][j] = (dp[i-1][j-1]+dp[i][2*j]) % mod\n            else:\n                dp[i][j] = dp[i-1][j-1]\n\n    print((dp[n][k]))\n\n\nmain()\n", "n,k = list(map(int,input().split()))\ndp = [[0 for i in range(j+1)] for j in range(n+1)]\nmod = 998244353\nfor i in range(1,n+1):\n  dp[i][i] = 1\nfor i in range(2,n+1):\n  for j in range(1,i):\n    t = max(1,j-1)\n    while t <= i-1:\n      dp[i][j] += dp[i-1][t]\n      t = t*2+1\n    dp[i][j] %= mod\nprint((dp[n][k]))\n", "import sys\ndef input(): return sys.stdin.readline().strip()\n\n\ndef main():\n    mod = 998244353\n    N, K = list(map(int, input().split()))\n    \"\"\"\n    \uff11\u3092\u4f7f\u3046\u304b\u4f7f\u308f\u306a\u3044\u304b\u3067\u5834\u5408\u5206\u3051\u3059\u308b\u767a\u60f3\u306f\u3069\u3046\u3057\u3066\u51fa\u3066\u304f\u308b\u3093\u3060\u3002\u3002\u3002\n    \u518d\u5e30\u69cb\u9020\u304c\u898b\u3048\u308b\u611f\u3058\uff1f\uff1f\uff1f\n    \u518d\u5e30\u3067\u5b9f\u88c5\u3059\u308b\u3068\u9593\u306b\u5408\u308f\u306a\u304b\u3063\u305f\u306e\u3067dp\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3002\n    dp[n][k] = dp[n - 1][k - 1] + dp[n][k * 2]\n    \"\"\"\n    dp = [[0] * (N * 2 + 5) for _ in range(N + 1)]  # dp[n][k] = (n\u500b\u306e\u8981\u7d20\u3067k\u3092\u8868\u3059\u5834\u5408\u306e\u6570)\n    dp[0][0] = 1\n    dp[1][1] = 1\n    \n    for n in range(1, N + 1):\n        for k in range(n, -1, -1):\n            dp[n][k] = dp[n - 1][k - 1] + dp[n][k * 2]\n            dp[n][k] %= mod\n    #for n in range(N + 1): print(n, dp[n])\n    \n    print((dp[N][K]))\n\ndef __starting_point():\n    main()\n\n\n\n\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())\n\n\nN,K = MI()\nmod = 998244353\n\ndp = [[0]*(N+1) for _ in range(N+1)]\ndp[0][0] = 1\nfor i in range(1,N+1):\n    for j in range(N,0,-1):\n        dp[i][j] = dp[i-1][j-1]\n        if 2*j <= N:\n            dp[i][j] += dp[i][2*j]\n            dp[i][j] %= mod\nprint((dp[-1][K]))\n", "def resolve():\n  mod = 998244353\n  N, K = list(map(int, input().split(\" \")))\n\n  # dp = [[0]*(K+1) for _ in range(N+1)]\n  dp = [[0]*(N+1) for _ in range(N+1)]\n  for n in range(N+1):\n    dp[n][n] = 1\n\n  for n in range(1, N+1):\n    for k in range(n, 0, -1):\n      result = dp[n-1][k-1]\n      if 2*k <= n: result += dp[n][2*k]\n      dp[n][k] = result%mod if result > mod else result\n  \n  print((dp[N][K]))\n\ndef __starting_point():\n  resolve()\n\n__starting_point()", "def ans(n,k):\n    dp = [[0 for x in range(6001)]for y in range(6001)]\n    dp[1][1]=1\n    for i in range(2,n+1):\n        for j in range(3000,0,-1):\n            dp[i][j]=(dp[i-1][j-1]+dp[i][2*j])%998244353\n    print(dp[n][k])\nn,k=(int(x) for x in input().split())\nans(n,k)", "N, K = list(map(int, input().split()))\nP = 998244353\ndp = [[0] * (N+1) for _ in range(N+1)]  # i\u500b\u4f7f\u3063\u3066=K\u306e\u30d1\u30bf\u30fc\u30f3\ndp[0][0]=1\n# dp[i][k] = dp[i-1][k-1] + dp[i][2*k]\nfor i in range(1, N + 1):\n    for k in range(N, 0, -1):\n        if 2 * k <= N:\n            dp[i][k] = (dp[i - 1][k - 1] + dp[i][2 * k])%P\n        else:\n            dp[i][k] = dp[i-1][k-1]\nprint((dp[N][K]))\n", "#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\n#R = 10**9 + 7\nR = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn,k = inm()\ndp = [[0]*(n+1) for i in range(n+1)]\ndp[0][0] = 1\nfor i in range(1,n+1):\n    for j in range(i,0,-1):\n        dp[i][j]=(dp[i-1][j-1]+(dp[i][2*j] if 2*j<=i else 0))%R\nprint(dp[n][k])\n"]
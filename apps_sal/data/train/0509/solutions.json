["import sys\nsys.setrecursionlimit(10**6)\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn, m = map(int, input().split())\n\nans = [-1]*n\n\nuf = UnionFind(n)\ng = [[] for i in range(n)]\n\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    if not uf.same(u-1, v-1):\n        uf.union(u-1, v-1)\n        g[u-1].append((v-1, c))\n        g[v-1].append((u-1, c))\n\ndef dfs(i):\n    for to, c in g[i]:\n        if ans[to]==-1:\n            if ans[i] == c:\n                if c == 1:\n                    ans[to] = c+1\n                else:\n                    ans[to] = c-1\n            else:\n                ans[to] = c\n            dfs(to)\n\nans = [-1]*n\nans[0] = 1\ndfs(0)\n\nif -1 in ans:\n    print('No')\n    return\n\nans = [a for a in ans]\n\nprint(*ans, sep='\\n')\n", "#!/usr/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = list(map(int, input().split()))\n    edges[u-1].append((v-1, c))\n    edges[v-1].append((u-1, c))\n\nret = [-1] * n\nq = deque([0])\nret[0] = 1\nwhile q:\n    now = q.popleft()\n    for nxt, c in edges[now]:\n        if ret[nxt] != -1: continue\n        if ret[now] != c:\n            ret[nxt] = c\n        else:\n            ret[nxt] = 2 if c == 1 else 1\n        q.append(nxt)\nprint(('\\n'.join(map(str, ret))))\n", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9+7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, M = LI()\n    G = collections.defaultdict(list)\n    for _ in range(M):\n        u, v, c = LI_()\n        G[u].append((v, c))\n        G[v].append((u, c))\n    # print(G)\n    ans = [-1] * N\n    ans[0] = 1\n\n    # \u6728\u306b\u5bfe\u3057\u3066\u5fc5\u305a\u3088\u3044\u66f8\u304d\u8fbc\u307f\u65b9\u304c\u5b58\u5728\u3059\u308b\u306e\u3067\u3001\n    # DFS\u3067MST\u3092\u8fbf\u3063\u3066\u3088\u3044\u66f8\u304d\u8fbc\u307f\u65b9\u3092\u3059\u308c\u3070\u3088\u3044\n    def dfs(c, p):\n        for n, l in G[c]:\n            if ans[n] == -1:\n                if ans[c] == l:\n                    # \u66f8\u304d\u8fbc\u3080\u5024\u304cN\u3092\u8d8a\u3048\u306a\u3044\u3088\u3046\u306b\u3059\u308b\n                    if l < N - 1:\n                        ans[n] = l + 1\n                    else:\n                        ans[n] = l - 1\n                else:\n                    ans[n] = l\n                dfs(n, c)\n\n    dfs(0, -1)\n\n    for i in ans:\n        print((i + 1))\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from collections import deque\ndef main():\n    n,m = map(int,input().split())\n    G = dict()\n    for i in range(1,n+1):\n        G[i] = dict()\n\n    for i in range(m):\n        u,v,c = map(int,input().split())\n        G[u][v] = c\n        G[v][u] = c\n\n    done = [0]*(n+1)\n    done[1] = 1\n\n    dq = deque()\n    dq.append(1)\n\n    while dq:\n        node = dq.popleft()\n        for dst,dc in G[node].items():\n            if done[dst] == 0:\n                if done[node]!=dc:\n                    done[dst] = dc\n                else:\n                    if dc == n:\n                        done[dst] = 1\n                    else:\n                        done[dst] = dc+1\n                dq.append(dst)\n            \n\n    for i in range(1,n+1):\n        print(done[i])\nmain()", "from collections import deque\n\nN, M = list(map(int, input().split()))\nuvc = [list(map(int, input().split())) for _ in range(M)]\n\nG = [[] for _ in range(N + 1)]\nfor i in range(M):\n    A = uvc[i][0]\n    B = uvc[i][1]\n    G[A].append([B, uvc[i][2]])\n    G[B].append([A, uvc[i][2]])\n\nseen = [0] * (N + 1)\nseen[1] = G[1][0][1]\nq = deque([1])\nwhile q:\n    t = q.pop()\n    for p, e in G[t]:\n        if seen[p] > 0:\n            continue\n        if seen[t] != e:\n            seen[p] = e\n        else:\n            if seen[t] + 1 <= N:\n                seen[p] = seen[t] + 1\n            elif seen[t] - 1 > 0:\n                seen[p] = seen[t] - 1\n        q.append(p)\n\nfor i in range(1, N + 1):\n    if seen[i] == 0:\n        print('No')\n        return\n\nfor i in range(1, N + 1):\n    print((seen[i]))\n", "from collections import deque\nn,m = [int(i) for i in input().split()]\ng = [[] for _ in range(n)]\nfor _ in range(m):\n  u,v,c = [int(i)-1 for i in input().split()]\n  g[u].append([v,c])\n  g[v].append([u,c])\nnum = [0]*n\nd = deque()\nd.append(0)\nlabel = [-1]*n\nlabel[0] = 0\nwhile d:\n  a = d.pop()\n  if num[a]:\n    continue\n  num[a] = 1\n  for u,c in g[a]:\n    if num[u]:\n      continue\n    if label[a] != c:\n      label[u] = c\n    elif c == 0:\n      label[u] = 1\n    else:\n      label[u] = 0\n    d.appendleft(u)\nprint(\"\\n\".join(map(lambda i : str(i+1), label)))", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\nimport copy\n\nn,m= map(int, input().split())\na= [list(map(int, input().split())) for i in range(m)]\ng = [[] for i in range(n)]\n\nfor x,y,z in a:\n    g[x-1].append((y-1,z))\n    g[y-1].append((x-1,z))\n\n\nfrom collections import deque\n\ndef tree(s):\n\n    INF=-10**9\n    dis = [INF for i in range(n)]\n    ans=[0]*n\n    dis[s]=0\n    ans[s]=1\n    def bfs():\n        d = deque()\n        d.append(s)\n\n        while len(d):\n            x = d.popleft()\n\n            for i in range(len(g[x])):\n                y=g[x][i][0]\n                if dis[y] == INF:\n                    d.append(y)\n                    dis[y]=dis[x]+1\n                    if ans[y]==0:\n                        if ans[x] == g[x][i][1]:\n                            if ans[x] == n:\n                                ans[y] = n - 1\n                            else:\n                                ans[y]= copy.copy(ans[x])+1\n                        else:\n                            ans[y] =copy.copy(g[x][i][1])\n\n        return ans\n    return bfs()\n\nv=tree(0)\nfor i in v:\n    print(i)", "from collections import deque\n\nn,m=map(int,input().split())\n\nN=[0]*n\nL=[list() for i in range(n)]\nfor i in range(m):\n  u,v,c=map(int,input().split())\n  L[~-u].append([~-v,c])\n  L[~-v].append([~-u,c])\n\nN[0],Q=1,deque([0])\nwhile Q:\n  u=Q.popleft()\n  for v,c in L[u]:\n    if N[v]:\n      continue\n    Q.append(v)\n    if N[u]!=c:\n      N[v]=c\n    else:\n      N[v]=1 if c!=1 else 2\n\nprint(*N,sep='\\n')\n", "# See. https://atcoder.jp/contests/arc108/tasks/arc108_c\n\nimport numpy as np\n\ndef solve(N, G):\n  q = np.zeros(N, dtype=np.uint32)\n  q[0] = 1\n\n  labels = np.zeros(N+1, dtype=np.uint32)\n  labels[1] = 1\n  end = 1\n\n  for head in range(N):\n    u = q[head]\n    if u < 1 : break\n    for v in list(G[u].keys()):\n      if labels[v] > 0: continue\n      labels[v] = G[u][v] if labels[u] != G[u][v] else labels[u]%N + 1\n      q[end] = v\n      end += 1\n  else:\n    return labels[1:]\n\n  return ['No']\n\ndef main():\n  N, M = [int(x) for x in input().split()]\n  G = {}\n  for i in range(M):\n    u, v, c = [int(x) for x in input().split()]\n\n    for u_, v_ in ((u,v), (v,u)):\n      if u_ not in G: G[u_] = {}\n      G[u_][v_] = c\n\n  ans = solve(N, G)\n  for i in range(len(ans)):\n    print((ans[i]))\n\nmain()\n\n# vim: ts=2 sw=2\n", "#!/usr/bin/env python3\n# from typing import *\n# %%\nfrom collections import deque\n\n# def solve(N: int, M: int, u: List[int], v: List[int], c: List[int]) -> List[str]:\ndef solve(start, adj):\n    N = len(adj)\n    ans = [0]*N\n    ans[start] = 1\n    que = deque([start])\n    visited = set()\n    while que:\n        frm = que.popleft()\n        visited.add(frm)\n        for to, c in adj[frm]:\n            if to in visited: continue\n            if ans[frm] == c:\n                ans[to] = c%N+1\n            else:\n                ans[to] = c\n            que.append(to)\n    return ans\n\n# %%\n# generated by online-judge-template-generator v4.7.1 (https://github.com/online-judge-tools/template-generator)\ndef main():\n    N, M = list(map(int, input().split()))\n    adj = {i:list() for i in range(N)}\n    for i in range(M):\n        u, v, c = list(map(int, input().split()))\n        adj[u-1].append((v-1,c))\n        adj[v-1].append((u-1,c))\n    ans = solve(0, adj)\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\nf=lambda:map(int,input().split())\nn,m=f()\ng=[[] for _ in range(n)]\nfor _ in range(m):\n  u,v,l=f()\n  g[u-1]+=[(v-1,l)]\n  g[v-1]+=[(u-1,l)]\na=[0]*n\ndef dfs(v,p=-1,l=1):\n  a[v]=l\n  for c,m in g[v]:\n    if c==p or a[c]: continue\n    if l==m: m=1+(m==1)\n    dfs(c,v,m)\ndfs(0)\nprint(*a,sep='\\n')", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\n\nN, M, *UVC = map(int, open(0).read().split())\n\nE = [[] for _ in range(N + 1)]\nfor u, v, c in zip(*[iter(UVC)] * 3):\n    E[u].append((v, c))\n    E[v].append((u, c))\n\nmemo = [-1] * (N + 1)\nmemo[1] = 1\n\ndef dfs(cur, par):\n    for nxt, c in E[cur]:\n        if memo[nxt] != -1 or nxt == par:\n            continue\n        if memo[cur] == c:\n            c = 1 + (c == 1)\n        memo[nxt] = c\n        dfs(nxt, cur)\n\ndfs(1, 0)\n\nfor m in memo[1:]:\n    print(m)", "import sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    graph[u-1].append((v-1, c))\n    graph[v-1].append((u-1, c))\n\ndef dfs(node):\n    for c_node, label in graph[node]:\n        if seen[c_node]:\n            continue\n        seen[c_node] = True\n        if ans[node]==label:\n            if label==1:\n                ans[c_node] = 2\n            else:\n                ans[c_node] = 1\n        else:\n            ans[c_node] = label\n        dfs(c_node)\n\nans = [None]*n\nans[0] = 1\nseen = [False]*n\nseen[0] = True\ndfs(0)\nfor i in ans:\n    print(i)", "def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    n, m = map(int, input().split())\n\n    g = tuple(list() for _ in range(n))\n    for _ in range(m):\n        u, v, c = (int(x) - 1 for x in input().split())\n        g[u].append((v, c))\n        g[v].append((u, c))\n\n    def make_tree(r, g):\n        ret = tuple(list() for _ in range(n))\n\n        dq = deque()\n        dq.append(r)\n\n        vis = [False] * n\n        vis[r] = True\n\n        while dq:\n            v = dq.popleft()\n            for u, c in g[v]:\n                if vis[u]:\n                    continue\n                vis[u] = True\n                ret[v].append((u, c))\n                dq.append(u)\n        return ret\n\n    gt = make_tree(0, g)\n\n    def make_label(r, g):\n        ret = [-1] * n\n        ret[r] = 0\n\n        dq = deque()\n        dq.append(r)\n\n        while dq:\n            v = dq.popleft()\n            for u, c in g[v]:\n                if ret[v] == c:\n                    ret[u] = (c + 1) % n\n                else:\n                    ret[u] = c\n                dq.append(u)\n        return ret\n\n    label = make_label(0, gt)\n    ans = map(lambda e: e + 1, label)\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        \"\"\"x\u306e\u89aa\u3092\u8fd4\u3059\"\"\"\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        \"\"\"y\u3092x\u306e\u6839\u306b\u7e4b\u3050\uff08\u30de\u30fc\u30b8\u30c6\u30af\u6709\uff09\"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        \"\"\"x\u3068y\u304c\u540c\u3058\u9023\u7d50\u6210\u5206\u304b\u5224\u5225\u3059\u308b\"\"\"\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        \"\"\"x\u306e\u9023\u7d50\u6210\u5206\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\"\"\"\n        return -self.parents[self.find(x)]\n\n    def kruskal(self, edge):\n        \"\"\"\n        :param edge: edge = [(\u30b3\u30b9\u30c8, \u9802\u70b91, \u9802\u70b92),...]\u306e\u5f62\u3067\u91cd\u307f\u4ed8\u304d\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u6e21\u3057\u3066\u4e0b\u3055\u3044\n        :return: \u6700\u5c0f\u5168\u57df\u6728\u306e\u30b3\u30b9\u30c8\u306e\u548c\n        \"\"\"\n        edge.sort()\n        cost_sum = 0\n        for cost, node1, node2 in edge:\n            if not self.same(node1, node2):\n                cost_sum += cost\n                self.union(node1, node2)\n        return cost_sum\n\n\ndef resolve():\n    def dfs(v):\n        for d, u in edge[v]:\n            if uf.same(v, u):\n                continue\n            uf.union(u, v)\n            if res[v] != d:\n                res[u] = d\n            else:\n                for i in range(1, n + 1):\n                    if i != d:\n                        res[u] = i\n                        break\n            dfs(u)\n\n    n, m = map(int, input().split())\n    edge = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        edge[u - 1].append([c, v - 1])\n        edge[v - 1].append([c, u - 1])\n\n    uf = UnionFind(n)\n    res = [0] * n\n    res[0] = 1\n    dfs(0)\n    print(*res, sep=\"\\n\")\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nn,m= map(int, input().split())\na= [list(map(int, input().split())) for i in range(m)]\ng = [[] for i in range(n)]\n\nfor x,y,z in a:\n    g[x-1].append((y-1,z))\n    g[y-1].append((x-1,z))\n\n\nfrom collections import deque\n\ndef tree(s):\n\n    ans=[0]*n\n    ans[s]=1\n    def bfs():\n        d = deque()\n        d.append(s)\n\n        while len(d):\n            x = d.popleft()\n\n            for i in range(len(g[x])):\n                y=g[x][i][0]\n                if ans[y] == 0:\n                    d.append(y)\n                    if ans[x] == g[x][i][1]:\n                        if ans[x] == n:\n                            ans[y] = n - 1\n                        else:\n                            ans[y] = ans[x] + 1\n                    else:\n                        ans[y] = g[x][i][1]\n\n        return ans\n    return bfs()\n\nv=tree(0)\nfor i in v:\n    print(i)", "# https://atcoder.jp/contests/arc108/tasks/arc108_c\n\nfrom collections import deque\n\nn, m = map(int, input().split())\n\nN = [0] * n\nL = [[] for _ in range(n)]\nfor i in range(m):\n  u, v, c = map(int, input().split())\n  L[u - 1].append((v - 1, c))\n  L[v - 1].append((u - 1, c))\n\nN[0] = 1\nQ = deque([0])\nwhile Q:\n  u = Q.popleft()\n  for v, c in L[u]:\n    if N[v]:\n      continue\n    Q.append(v)\n    if N[u] != c:\n      N[v] = c\n    else:\n      if c != 1:\n        N[v] = 1 \n      else:\n        N[v] = 2\n\nprint(*N, sep='\\n')\n", "import sys\nfrom collections import deque\ninput=sys.stdin.readline\nN, M = list(map(int, input().split()))\nc, to = dict(), [[] for _ in range(N)]\n\ndef maxmin(x, y):\n    if x < y:\n        x, y = y, x\n    return (x, y)\n\nfor i in range(M):\n    x,y,z = list(map(int, input().split()))\n    x,y = x-1,y-1\n    x,y = maxmin(x,y)\n    c[(x,y)] = z\n    to[x].append(y)\n    to[y].append(x)\n\nd = deque()\nd.append(0)\nseen = [False] * N\nseen[0] = True\nmark = [1] * N\nwhile len(d) > 0:\n    now = d.popleft()\n    for next in to[now]:\n        if seen[next]:\n            continue\n        seen[next] = True\n        d.append(next)\n        xy = maxmin(next, now)\n        if mark[now] == c[xy]:\n            mark[next] = (mark[now] % N) + 1\n        else:\n            mark[next] = c[xy]\n\nfor i in mark:\n    print(i)\n", "from collections import Counter,deque\nn,m=map(int,input().split())\nlst=[[] for _ in range(n)]\nfor i in range(m):\n    u,v,c=map(int,input().split())\n    lst[u-1].append((v-1,c))\n    lst[v-1].append((u-1,c))\nans=[1]+[0]*(n-1)\nq=deque([0])\nwhile q:\n    x=q.pop()\n    for i,j in lst[x]:\n        if ans[i]!=0:\n            continue\n        if j==ans[x]:\n            if j==n:\n                ans[i]=1\n            else:\n                ans[i]=j+1\n        else:\n            ans[i]=j\n        q.append(i)\nprint(*ans,sep=\"\\n\")", "from sys import stdin, setrecursionlimit\nimport bisect, collections, copy, heapq, itertools, math, string\nsetrecursionlimit(10**8)\n\nINF = float(\"inf\")\nMOD = 1000000007\n\n\ndef input():\n    return stdin.readline().strip()\n\n#unionfind\nfrom collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = collections.defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())\n\n\ndef main():\n\n    n, m = map(int, input().split())\n    uf = UnionFind(n)\n    adj = [[] for _ in range(n)]\n\n    for _ in range(m):\n        u, v, c = map(int, input().split())\n        u -= 1\n        v -= 1\n        if uf.same(u, v): continue\n        adj[u].append((v, c))    \n        adj[v].append((u, c))\n        uf.union(u, v)\n\n    queue = collections.deque([0])\n    ans = [-1]*n\n    ans[0] = 1\n\n    while queue:\n        now = queue.popleft()\n        pnum = ans[now]\n        for edge in adj[now]:\n            child = edge[0]\n            enum = edge[1]\n            if ans[child] != -1: continue\n            queue.append(child)\n            if pnum == enum:\n                ans[child] = 1 if pnum != 1 else 2\n            else:\n                ans[child] = enum\n    \n    print(*ans, sep=\"\\n\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    return\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = list(map(int, input().split()))\n    g[u - 1].append((v - 1, c))\n    g[v - 1].append((u - 1, c))\ns = [0]\nd = [1] * n\nd[0] = 0\ng2 = [[] for _ in range(n)]\nwhile s:\n    p = s.pop()\n    for node, label in g[p]:\n        if d[node]:\n            d[node] = 0\n            s.append(node)\n            g2[p].append((node, label))\n            g2[node].append((p, label))\ns = [0]\nd = [-1] * n\nd[0] = 1\nwhile s:\n    p = s.pop()\n    for node, label in g2[p]:\n        if d[node] == -1:\n            if d[p] == label:\n                if label == n:\n                    d[node] = 1\n                else:\n                    d[node] = label + 1\n            else:\n                d[node] = label\n            s.append(node)\nfor x in d:\n    print(x)\n", "import sys\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nuvc = [list(map(int, input().split())) for _ in range(M)]\n\nedge = [[] for i in range(N)]\nfor u, v, c in uvc:\n    u -= 1\n    v -= 1\n    c -= 1\n    edge[u].append((v, c))\n    edge[v].append((u, c))\n    \nlabel = [-1] * N\nlabel[0] = 0\n\nQ = [0]\nwhile Q:\n    v = Q.pop()\n    for u, l in edge[v]:\n        if label[u] != -1:\n            continue\n        Q.append(u)\n        if label[v] != l:\n            label[u] = l\n        else:\n            label[u] = l + 1\n\nprint(*(l + 1 for l in label), sep=\"\\n\")", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\nfrom collections import deque\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, M, uvc):\n    tree_map = [[] for _ in range(N + 1)]\n    for u, v, c in uvc:\n        tree_map[u].append([v, c])\n        tree_map[v].append([u, c])\n    # [print(t) for t in tree_map]\n    ans = [0] * (N + 1)\n    visited = [False] * (N + 1)\n    visited[1] = True\n    ans[1] = 1\n    dq = deque([1])\n    while dq:\n        now = dq.popleft()\n        for child, c in tree_map[now]:\n            if visited[child]:\n                continue\n            visited[child] = True\n            if c == ans[now]:\n                ans[child] = c % N + 1\n            else:\n                ans[child] = c\n            dq.append(child)\n    [print(i) for i in ans[1:]]\n\n    # dq = deque([[1, 0, True, 0]])  # now, parent, parent is same label?, label\n    # visited[0] = True\n    # visited[1] = True\n    # while dq:\n    #     now, parent, issame, label = dq.popleft()\n    #     if not issame:\n    #         ans[now] = label\n    #     for child, c in tree_map[now]:\n    #         if visited[child]:\n    #             continue\n    #         visited[child] = True\n    #         if issame and ans[now] == 0 and c != label:\n    #             ans[now] = c\n    #         dq.append([child, now, ans[now] == c, c])\n    #     if ans[now] == 0:\n    #         ans[now] = label % N + 1\n    # [print(i) for i in ans[1:]]\n\n    # # check\n    # check = [1] * (N + 1)\n    # check[0] = 0\n    # new_map = [[] for _ in range(N + 1)]\n    # for u, v, c in uvc:\n    #     if (ans[u] == c) ^ (ans[v] == c):\n    #         new_map[u].append(v)\n    #         new_map[v].append(u)\n    # dq = deque([1])\n    # while dq:\n    #     now = dq.popleft()\n    #     check[now] = 0\n    #     for nxt in new_map[now]:\n    #         if check[nxt] == 0:\n    #             continue\n    #         dq.append(nxt)\n    # if sum(check) > 0:\n    #     print('wrong')\n\n\ndef __starting_point():\n    N, M = map(int, input().split())\n    uvc = [[int(i) for i in input().split()] for _ in range(M)]\n    solve(N, M, uvc)\n\n    # # test\n    # from random import randint\n    # from func import random_str, random_ints\n    #\n    # N = 4\n    # M = 2 * N\n    #\n    #\n    # def trial():\n    #     a, b = 0, 0\n    #     while a == b:\n    #         a, b = randint(1, N), randint(1, N)\n    #     return a, b, randint(1, N)\n    #\n    # cnt = 0\n    # while True:\n    #     uvc = [[i, i % N + 1, randint(1, N)] for i in range(1, N + 1)] + \\\n    #           [trial() for _ in range(randint(0, N))]\n    #     solve(N, M, uvc)\n    #     cnt += 1\n    #     # if cnt % 10 == 0:\n    #     #     print(cnt)\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\nN, M = list(map(int, input().split()))\nuvc = [list(map(int, input().split())) for _ in range(M)]\n\ng = [[] for _ in range(N)]\nfor u, v, c in uvc:\n    u -= 1\n    v -= 1\n    g[u].append((v, c))\n    g[v].append((u, c))\n\nchildren = [[] for _ in range(N)]\nappeared = [False]*N\nq = [0]\nappeared[0] = True\nwhile q:\n    u = q.pop()\n    for v, c in g[u]:\n        if not appeared[v]:\n            children[u].append((v, c))\n            q.append(v)\n            appeared[v] = True\n\ncolors = [None]*N\ncolors[0] = 1\nq = [0]\nwhile q:\n    u = q.pop()\n    c_u = colors[u]\n    for v, c_edge in children[u]:\n        colors[v] = c_edge + (c_edge == c_u)\n        q.append(v)\nprint(('\\n'.join(map(str, colors))))\n", "import sys\ninput = sys.stdin.readline\n# sys.setrecursionlimit(10**6)\n\ndef inp():\n    return int(input())\ndef inps():\n    return input().rstrip()\ndef inpl():\n    return list(map(int, input().split()))\ndef inpls():\n    return list(map(str, input().split()))\ndef _debug(obj):\n    print(obj, file=sys.stderr)\n\n# import decimal\n# from decimal import Decimal\n# decimal.getcontext().prec = 10\n\n# from heapq import heappush, heappop, heapify\n# import math\nfrom math import gcd, floor, ceil, factorial\nimport itertools as it\nfrom collections import deque, defaultdict\nfrom collections import Counter\n\ndef lcd(a, b):\n    return a * b // gcd(a, b)\n\ndef chmin(dp, i, x):\n    if x < dp[i]: dp[i] = x; return True\n    return False\n\ndef chmax(dp, i, x): \n    if x > dp[i]: dp[i] = x; return True\n    return False\n\n# ---------------------------------------\n\nN, M = inpl()\ngraph = [[] for i in range(N)]\nfor i in range(M):\n    u, v, c = inpl()\n    graph[u-1].append([v-1, c])\n    graph[v-1].append([u-1, c])\nans = [0] * N\nans[0] = 1\nq = deque()\nq.append(0)\nwhile True:\n    if not q:\n        break\n    i = q.popleft()\n    for g in graph[i]:\n        j = g[0]\n        c = g[1]\n        if ans[j] != 0:\n            continue\n        if ans[i] == c:\n            if c + 1 <= N:\n                ans[j] = c + 1\n            else:\n                ans[j] = c - 1\n        else:\n            ans[j] = c\n        q.append(j)\nfor i in ans:\n    print(i)", "import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef LI(): return list(map(int, input().split()))\nmod=10**9+7\n\n\"\"\"\n\u57fa\u672c\u7684\u306b\u9054\u6210\u53ef\u80fd\u3060\u3068\u601d\u3046\n\u57fa\u672c\u306f\u6b21\u6570\u304c\u5c0f\u3055\u3044\u3068\u3053\u308d(=\u7aef)\u3092\u53d6\u308c\u308b\u3088\u3046\u306b\u9802\u70b9\u306e\u5024\u3092\u6c7a\u3081\u3066\u304a\u3051\u3070Ok\n\u554f\u984c\u306f\u540c\u3058\u9802\u70b9\u306b\u5165\u3063\u3066\u3044\u308b\u8907\u6570\u306e\u8fba\u304c\u540c\u3058\u6570\u5024\u306e\u5834\u5408.\u3053\u306e\u6642\u306f\u7aef\u3067\u306f\u306a\u3044\u65b9\u306b\u305d\u306e\u6570\u5024\u3092\u5272\u308a\u632f\u308b\u304b?\n\n\u9577\u30554\u306e\u30d1\u30b9\u30673\u8fba\u306e\u5024\u304c\u3069\u308c\u30821\u306e\u3068\u304d\u3068\u304b\n\n\u30b9\u30bf\u30fc\u30b0\u30e9\u30d5\u304c2\u3064\u9023\u7d50\u3057\u3066\u3044\u308b\u6642\u3068\u304b\u3082\u3081\u3093\u3069\u3044\u306a\n\"\"\"\nfrom collections import defaultdict\nclass UnionFind:\n    def __init__(self, N: int):\n        \"\"\"\n        N:\u8981\u7d20\u6570\n        root:\u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8.\n             \u305f\u3060\u3057, root[x] < 0 \u306a\u3089\u305d\u306e\u9802\u70b9\u304c\u6839\u3067-root[x]\u304c\u6728\u306e\u8981\u7d20\u6570.\n        rank:\u30e9\u30f3\u30af\n        \"\"\"\n        self.N = N\n        self.root = [-1] * N\n        self.rank = [0] * N\n\n    def __repr__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n    def find(self, x: int):\n        \"\"\"\u9802\u70b9x\u306e\u6839\u3092\u898b\u3064\u3051\u308b\"\"\"\n        if self.root[x] < 0:\n            return x\n        else:\n            while self.root[x] >= 0:\n                x = self.root[x]\n            return x\n\n    def union(self, x: int, y: int):\n        \"\"\"x,y\u304c\u5c5e\u3059\u308b\u6728\u3092union\"\"\"\n        # \u6839\u3092\u6bd4\u8f03\u3059\u308b\n        # \u3059\u3067\u306b\u540c\u3058\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044.\n        # \u9055\u3046\u6728\u306b\u5c5e\u3057\u3066\u3044\u305f\u5834\u5408\u306frank\u3092\u898b\u3066\u304f\u3063\u3064\u3051\u308b\u65b9\u3092\u6c7a\u3081\u308b.\n        # rank\u304c\u540c\u3058\u6642\u306frank\u30921\u5897\u3084\u3059\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def same(self, x: int, y: int):\n        \"\"\"x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\"\"\"\n        return self.find(x) == self.find(y)\n\n    def count(self, x):\n        \"\"\"\u9802\u70b9x\u304c\u5c5e\u3059\u308b\u6728\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059\"\"\"\n        return - self.root[self.find(x)]\n\n    def members(self, x):\n        \"\"\"x\u304c\u5c5e\u3059\u308b\u6728\u306e\u8981\u7d20\u3092\u5217\u6319\"\"\"\n        _root = self.find(x)\n        return [i for i in range(self.N) if self.find == _root]\n\n    def roots(self):\n        \"\"\"\u68ee\u306e\u6839\u3092\u5217\u6319\"\"\"\n        return [i for i, x in enumerate(self.root) if x < 0]\n\n    def group_count(self):\n        \"\"\"\u9023\u7d50\u6210\u5206\u306e\u6570\"\"\"\n        return len(self.roots())\n\n    def all_group_members(self):\n        \"\"\"{\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u30c7\u30d5\u30a9\u30eb\u30c8\u30c7\u30a3\u30af\u30c8\u3092\u8fd4\u3059\"\"\"\n        dd = defaultdict(list)\n        for i in range(N):\n            root=self.find(i)\n            dd[root].append(i)\n        return dd\n    \ndef Kruskal(maxV, edges):\n    edges.sort()\n    newAdj=[[]for _ in range(N)]\n    uf=UnionFind(maxV)\n    ans = 0\n    for e in edges:\n        fro = e[0]\n        to = e[1]\n        if uf.find(fro) != uf.find(to):\n            uf.union(fro,to)\n            ans+=e[0]\n            newAdj[fro].append(to)\n            newAdj[to].append(fro)\n            \n    return newAdj\n\n# \u30e9\u30d9\u30eb\u3092\u8272\u3068\u547c\u3076\n\nN,M=MI()\nfrom collections import defaultdict\ndd = defaultdict(int)\nEdge=[]\n\n# \u591a\u91cd\u8fba\u306f\u7121\u8996\u3057\u3066\u3082\u884c\u3051\u305d\u3046\n\nfor _ in range(M):\n    u,v,c=MI()\n    u-=1\n    v-=1\n    c-=1\n    if dd[(u,v)]:\n        continue\n    Edge.append((u,v))\n    \n    dd[(u,v)]=c\n    dd[(v,u)]=c\n    \n# \u6728\u3067\u5341\u5206\u304b\u306a\nadj=Kruskal(N,Edge)\n# print(adj)\n\nCol=[-1]*N\n\nimport queue\nq=queue.Queue()\n\nfor v in adj[0]:\n    q.put((v,0))\n    \n\nwhile not q.empty():\n\n    v,p=q.get()\n    \n    if Col[p]!=dd[(v,p)]:#\u89aa\u3092\u7e4b\u3052\u3089\u308c\u3066\u306a\u3044\u306a\u3089\n        Col[v]=dd[(v,p)]\n    else:\n        #\u89aa\u3068\u3064\u306a\u3052\u308b\u305f\u3081\u306b\u306f\u9055\u3046\u8272\u3067\u3042\u308b\u5fc5\u8981\u3042\u308a\n        if Col[p]==0:\n            Col[v]=1\n        else:\n            Col[v]=0\n        \n    for nv in adj[v]:\n        if nv==0 or Col[nv]!=-1:\n            continue\n        q.put((nv,v))\n        \n# root\u306e\u8272\u3092\u6c7a\u3081\u308b\uff0c\u96a3\u63a5\u8272\u4ee5\u5916\ncol_0=[0]*N\nfor v in adj[0]:\n    col_0[Col[v]]+=1\n    \nfor i in range(N):\n    if col_0[i]==0:\n        Col[0]=i\n        break\n# print(col_0)\n\nfor i in range(N):\n    print((Col[i]+1))\n\n\n\n", "from collections import deque\n\nclass Unionfind:\n     \n    def __init__(self,n):\n        self.uf = [-1]*n\n \n    def find(self,x):\n        if self.uf[x] < 0:\n            return x\n        else:\n            self.uf[x] = self.find(self.uf[x])\n            return self.uf[x]\n \n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n \n    def union(self,x,y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.uf[x] > self.uf[y]:\n            x,y = y,x\n        self.uf[x] += self.uf[y]\n        self.uf[y] = x\n        return True\n \n    def size(self,x):\n        x = self.find(x)\n        return -self.uf[x]\n\nn,m = map(int,input().split())\ne = [[] for i in range(n+1)]\nuf = Unionfind(n+1)\nfor i in range(m):\n    u,v,c = map(int,input().split())\n    if uf.same(u,v):\n        continue\n    e[u].append((v,c))\n    e[v].append((u,c))\n\nans = [-1]*(n+1)\nans[1] = 1\nq = deque([[1,0]])\nwhile q:\n    now,par = q.popleft()\n    for nex,col in e[now]:\n        if ans[nex] > 0:\n            continue\n        if ans[now] == col:\n            ans[nex] = col%n+1\n        else:\n            ans[nex] = col\n        q.append([nex,now])\n\nfor i in ans[1:]:\n    print(i)", "# https://atcoder.jp/contests/arc108/submissions/18282738\n# \u524d\u56de\u306e\u63d0\u51fa\u306f\u9593\u9055\u3063\u3066\u3044\u308b\n\ndef main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    n, m = map(int, input().split())\n\n    g = tuple(list() for _ in range(n))\n    for _ in range(m):\n        u, v, c = (int(x) - 1 for x in input().split())\n        c += 1  # 1-based\n        g[u].append((v, c))\n        g[v].append((u, c))\n\n    def make_label(r):\n        ret = [-1] * n  # 1-based\n        ret[r] = 1\n\n        vis = [False] * n\n        vis[r] = True\n\n        dq = deque()\n        dq.append(r)\n\n        while dq:\n            v = dq.popleft()\n            for u, c in g[v]:\n                if vis[u]:\n                    continue\n                vis[u] = True\n                if ret[v] == c:\n                    if c == n:  # \u524d\u56de\u306f0-based\u306ec\u3068n\u3092\u6bd4\u8f03\u3057\u3066\u3044\u305f\n                        ret[u] = 1\n                    else:\n                        ret[u] = c + 1\n                else:\n                    ret[u] = c\n                dq.append(u)\n        return ret\n\n    lbl = make_label(0)\n    print(*lbl, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n# from typing import *\n# %%\nfrom collections import deque\n\n# def solve(N: int, M: int, u: List[int], v: List[int], c: List[int]) -> List[str]:\ndef solve(start, adj):\n    N = len(adj)\n    ans = [0]*N\n    ans[start] = 1\n    que = deque([start])\n    while que:\n        frm = que.popleft()\n        for to, c in adj[frm]:\n            if ans[to]: continue\n            if ans[frm] == c:\n                ans[to] = c+1\n            else:\n                ans[to] = c\n            que.append(to)\n    return ans\n\n# %%\n# generated by online-judge-template-generator v4.7.1 (https://github.com/online-judge-tools/template-generator)\ndef main():\n    N, M = list(map(int, input().split()))\n    adj = {i:list() for i in range(N)}\n    for i in range(M):\n        u, v, c = list(map(int, input().split()))\n        adj[u-1].append((v-1,c))\n        adj[v-1].append((u-1,c))\n    ans = solve(0, adj)\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\nN,M=list(map(int,input().split()))\nG=[{} for i in range(N)]\nfor _ in range(M):\n    u,v,c=list(map(int,input().split()))\n    G[u-1][v-1]=c-1\n    G[v-1][u-1]=c-1\nans=[-1 for i in range(N)]\nans[0]=0\nq=deque([0])\nwhile(q):\n    r=q.pop()\n    for p in G[r]:\n        if ans[p]!=-1:\n            continue\n        if ans[r]==G[p][r]:\n            ans[p]=(ans[r]+1)%N\n        else:\n            ans[p]=G[p][r]\n        q.append(p)\nfor i in ans:\n    print((i+1))\n", "#C\nN,M=map(int,input().split())\nP=[-1]*(N+1)\nVisited=[False]*(N+1)\nPast=[[] for i in range(N+1)]\nfor i in range(M):\n    u,v,c=map(int,input().split())\n    Past[u].append((v,c))\n    Past[v].append((u,c))\n    \n\nfrom queue import Queue\n\nq=Queue()\nq.put(1)\nP[1]=1\nwhile not q.empty():\n    st=q.get()\n    for to,c in Past[st]:\n        if P[to]==-1:\n            if P[st]==c:\n                P[to]=c+1 if c+1<=N else 1\n            else:\n                P[to]=c\n            q.put(to)\n            \nflag=True\nfor i in range(1,N+1):\n    if P[i]==-1:\n        flag=False\n        \nif flag:\n    for i in range(1,N+1):\n        print(P[i])\nelse:\n    print(\"No\")", "from collections import deque\n\nclass Unionfind:\n     \n    def __init__(self,n):\n        self.uf = [-1]*n\n \n    def find(self,x):\n        if self.uf[x] < 0:\n            return x\n        else:\n            self.uf[x] = self.find(self.uf[x])\n            return self.uf[x]\n \n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n \n    def union(self,x,y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.uf[x] > self.uf[y]:\n            x,y = y,x\n        self.uf[x] += self.uf[y]\n        self.uf[y] = x\n        return True\n \n    def size(self,x):\n        x = self.find(x)\n        return -self.uf[x]\n\nn,m = map(int,input().split())\ne = [[] for i in range(n+1)]\nuf = Unionfind(n+1)\nfor i in range(m):\n    u,v,c = map(int,input().split())\n    if uf.same(u,v):\n        continue\n    e[u].append((v,c))\n    e[v].append((u,c))\n\nans = [-1]*(n+1)\nans[1] = 1\nq = deque([[1,0]])\nwhile q:\n    now,par = q.popleft()\n    for nex,col in e[now]:\n        if ans[nex] > 0:\n            continue\n        if ans[now] == col:\n            ans[nex] = col%n+1\n        else:\n            ans[nex] = col\n        q.append([nex,now])\n\nfor i in ans[1:]:\n    print(i)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\nmod = 10 ** 9 + 7; INF = float(\"inf\")\n\ndef getlist():\n\treturn list(map(int, input().split()))\n\nclass UnionFind(object):\n\tdef __init__(self, N):\n\t\tself.par = [i for i in range(N)]\n\t\tself.rank = [0] * N\n\n\tdef find(self, x):\n\t\tif self.par[x] == x:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.par[x] = self.find(self.par[x])\n\t\t\treturn self.par[x]\n\n\tdef same_check(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef union(self, x, y):\n\t\tx = self.find(x); y = self.find(y)\n\t\tif self.rank[x] < self.rank[y]:\n\t\t\tself.par[x] = y\n\t\telse:\n\t\t\tself.par[y] = x\n\t\t\tif self.rank[x] == self.rank[y]:\n\t\t\t\tself.rank[x] += 1\n\nclass Graph(object):\n\tdef __init__(self, N):\n\t\tself.graph = [[] for i in range(N)]\n\n\tdef add_edge(self, a, b, c):\n\t\tself.graph[a].append((b, c))\n\ndef bfs(G, s, N):\n\tQ = deque(); Q.append(s)\n\tvisit = [0] * N; visit[s] = 1\n\tlabel = [None] * N; label[s] = 0\n\twhile Q:\n\t\tv = Q.popleft()\n\t\tfor i, c in G.graph[v]:\n\t\t\tif visit[i] == 0:\n\t\t\t\tvisit[i] = 1\n\t\t\t\tif c != label[v]:\n\t\t\t\t\tlabel[i] = c\n\t\t\t\telse:\n\t\t\t\t\tif c == N - 1:\n\t\t\t\t\t\tlabel[i] = 0\n\t\t\t\t\telse:\n\t\t\t\t\t\tlabel[i] = N - 1\n\t\t\t\tQ.append(i)\n\treturn label\n\ndef main():\n\tN, M = getlist()\n\tG = Graph(N)\n\tUF = UnionFind(N)\n\tfor i in range(M):\n\t\tu, v, c = getlist()\n\t\tu -= 1; v -= 1; c -= 1\n\t\tif UF.same_check(u, v) == False:\n\t\t\tUF.union(u, v)\n\t\t\tG.add_edge(u, v, c)\n\t\t\tG.add_edge(v, u, c)\n\n\tans = bfs(G, 0, N)\n\tfor i in ans:\n\t\tprint(i + 1)\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys\nfrom collections import deque\n\n\nN, M = map(int, input().split())\nedge = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, c = map(int, sys.stdin.readline().split())\n    u -= 1; v -= 1\n    edge[u].append((v, c))\n    edge[v].append((u, c))\npath = [-1] * N\npath[0] = edge[0][0][1]\nq = deque()\nfor v, c in edge[0]:\n    q.append((0, v, c))\n\nwhile q:\n    u, v, c = q.popleft()\n    if path[v] == -1:\n        if path[u] != c:\n            vc = c\n        else:\n            if path[u] > 1:\n                vc = path[u] - 1\n            else:\n                vc = path[u] + 1\n        path[v] = vc\n        for nv, nc in edge[v]:\n            if path[nv] == -1:\n                q.append((v, nv, nc))\n\nprint(*path, sep='\\n')\n", "'''\nHey  why peeping here -_'_- ?\nI believe on myself and I will achieve\nthis->author = Fuad Ashraful Mehmet, CSE ,University of Asia Pacific\nTodo:\n'''\nimport sys\ninput=sys.stdin.readline\nfrom itertools import groupby\nfrom collections import deque\n\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nS=lambda:input().rstrip('\\n')\nL=lambda:list(R())\n\ndef HalfDead():\n    n,m=R()\n    g=dict()\n    for i in range(1,n+1):\n        g[i]=dict()\n    \n    for i in range(m):\n        u,v,c=R()\n        g[u][v]=c\n        g[v][u]=c\n    #print(\"here\")\n    color=[0]*(n+2)\n    color[1]=1\n\n    dq=deque()\n    dq.append(1)\n\n    while dq:\n        frm=dq.popleft()\n\n        for to,c in g[frm].items():\n\n            if color[to]==0:\n                if color[frm]!=c:\n                    color[to]=c\n                else:\n                    if c==n:\n                        color[to]=1\n                    else:\n                        color[to]=c+1\n            \n                dq.append(to)\n    \n\n    for i in range(n):\n        print(color[i+1])\n    return\n\ndef __starting_point():\n    #for _ in range(I()):\n    HalfDead()\n__starting_point()", "from collections import deque\n\ndef bfs():\n    q = deque()\n    q.append(1)\n    ans[1] = 1\n    while q:\n        i = q.popleft()\n        for j, c in G[i]:\n            if ans[j] == 0:\n                if not ans[i] == c:\n                    ans[j] = c\n                else:\n                    ans[j] = 1 if ans[i] >= 2 else 2\n                q.append(j)\n    return\n\nn, m = map(int, input().split())\nG = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    G[u].append([v, c])\n    G[v].append([u, c])\nans = [0] * (n + 1)\nbfs()\nfor i in range(1, n + 1):\n    print(ans[i])", "from collections import deque\nN,M=list(map(int, input().split()))\n\nG=[[] for _ in range(N)]\n\nfor i in range(M):\n    u,v,c=list(map(int, input().split()))\n    G[u-1].append((v-1, c))\n    G[v-1].append((u-1, c))\n\nnewG=[[] for _ in range(N)]\ndone=[0]*N\nans=[0]*N\n\nque=deque([0])\nans[0]=1\nwhile que:\n    start=que.popleft()\n    done[start]=1\n    \n    for t in G[start]:\n        nex, c=t\n        if done[nex]==1:\n            continue\n        else:\n            \n            newG[start].append((nex, c))\n            que.append(nex)\n            if ans[start]==c:\n                ans[nex]=c%N+1\n            else:\n                ans[nex]=c\n\nfor a in ans:\n    print(a)\n\n\n\n\n\n", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter,deque\n\nn,m=map(int,input().split())\nE=[list(map(int,input().split())) for i in range(m)]\n\nF=[]\n\n# E = [(cost, v, w), ...]\n#   G\u4e0a\u306e\u5168\u3066\u306e\u8fba(v, w)\u3068\u305d\u306ecost\u3092\u542b\u3080list\n\n# Union-Find\u3092\u4f7f\u3046\u3053\u3068\u3067\u9802\u70b9\u9593\u306e\u9023\u7d50\u5224\u5b9a\u3092\u884c\u3046\n\n*p, = range(n)\ndef root(x):\n    if x == p[x]:\n        return x\n    p[x] = y = root(p[x])\n    return y\n\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n    return 1\n\nE.sort()\nans = 0\nfor  v, w, c in E:\n    if unite(v-1, w-1):\n        F.append([v,w,c])\n        ans += c\n\n# ans\u304c\u6700\u5c0f\u5168\u57df\u6728\u306e\u89e3\n\ng=[[] for i in range(n)]\nans=[0]*n\nans[0]='?'\nused=[False]*(n+1)\npre=[0]*n\n \nfor u,v,c in F:\n    g[u-1].append([v-1,c])\n    g[v-1].append([u-1,c])\n\n \n \nQ=deque()\nQ.append((0))\n \nwhile Q:\n    p=Q.popleft()\n \n    for s in g[p]:\n        i,v=s[0],s[1]\n        if ans[i]==0:\n            if ans[p]==v:\n                ans[i]=v+1\n                Q.append((i))\n                if ans[i]==n+1:\n                    ans[i]=1\n            else:\n                ans[i]=v\n                Q.append((i))\n \n \nfor i,v in g[0]:\n    used[v]=True\n \nfor i in range(1,n+1):\n    if used[i]==False:\n        ans[0]=i\n        break\n \n \nprint(*ans,sep='\\n')", "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(now):\n    for nxt, color in edge[now]:\n        if res[nxt] == 0:\n            if res[now] == color:\n                res[nxt] = (color + 1 if color < n else 1)\n            else:\n                res[nxt] = color\n        \n            dfs(nxt)\n    \n    return\n\n\nn, m = map(int, input().split())\nedge = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    edge[u-1].append([v-1, c])\n    edge[v-1].append([u-1, c])\n\nres = [0] * n\nres[0] = 1\n\ndfs(0)\n\nprint(*res, sep='\\n')", "from collections import defaultdict\nfrom collections import deque\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n      \n      \n      \nn,m = list(map(int,input().split()))\nV = [[] for i in range(n+1)]\n\nsets = [set([]) for i in range(n+1)]\nuf = UnionFind(n+1)\nfor i in range(m):\n    a,b,c = list(map(int,input().split()))\n    if uf.find(a) != uf.find(b):\n        uf.union(a,b)\n        V[a].append([b,c])\n        V[b].append([a,c])\n        sets[a].add(c)\n        sets[b].add(c)\n        \np = [-1]*(n+1)\n\ndef out_not_in_number(x):\n    ret = -1\n    for i in range(1,n+1):\n        if i not in sets[x]:\n            ret = i\n            break\n    return ret\n\nstart = 1\np[start] = out_not_in_number(start)\n\nq = deque([])\nq.append(start)\nwhile q:\n    x = q.popleft()\n    for y,z in V[x]:\n        if p[y] == -1:\n            q.append(y)\n            if p[x] == z:\n                p[y] = out_not_in_number(y)\n                \n            else:\n                p[y] = z\nfor i in range(1,n+1):\n    print((p[i]))\n#print(V)\n", "from collections import deque\n\nn,m=map(int,input().split())\n\nN=[0]*n\nL=[list() for i in range(n)]\nfor i in range(m):\n  u,v,c=map(int,input().split())\n  L[~-u].append([~-v,c])\n  L[~-v].append([~-u,c])\n\nN[0],Q=1,deque([0])\nwhile Q:\n  u=Q.popleft()\n  for v,c in L[u]:\n    if N[v]:\n      continue\n    Q.append(v)\n    if N[u]!=c:\n      N[v]=c\n    else:\n      N[v]=1 if c!=1 else 2\n\nprint(*N,sep='\\n')\n", "from collections import deque\nn, m = map(int, input().split())\nedge = [[] for i in range(n)]\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    u-=1; v-=1\n    edge[u].append((v, c))\n    edge[v].append((u, c))\n\nque = deque([0])\nused = [0]*(n+1)\nused[0]=1\nwhile que:\n    v = que.pop()\n    for u, cost in edge[v]:\n        if used[u]: continue\n        if used[v]==cost:\n            used[u] = cost%n+1\n        else:\n            used[u]=cost\n        que.appendleft(u)\nfor i in range(n):\n    print(used[i])", "from collections import defaultdict\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        group_members = defaultdict(list)\n        for member in range(self.n):\n            group_members[self.find(member)].append(member)\n        return group_members\n\n    def __str__(self):\n        return '\\n'.join(f'{r}: {m}' for r, m in list(self.all_group_members().items()))\n\nn, m = list(map(int, input().split()))\nun = UnionFind(n)\nnext_edge_dic = {}\nflag = False\nfor _ in range(m):\n    u, v, c = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    if not un.same(u, v):\n        if u not in next_edge_dic:\n            next_edge_dic[u] = []\n        next_edge_dic[u].append([v, c])\n        if v not in next_edge_dic:\n            next_edge_dic[v] = []\n        next_edge_dic[v].append([u, c])\n        un.union(u, v)\n    if un.size(0) == n:\n        flag = True\n        break\nif not flag:\n    print('No')\nelse:\n    stack = [0]\n    visited = set([0])\n    ans = [0] * n\n    ans[0] = 1\n    while stack:\n        edge = stack.pop()\n        for next_edge, label in next_edge_dic[edge]:\n            if next_edge in visited:\n                continue\n            if ans[edge] == label:\n                if label == 1:\n                    ans[next_edge] = 2\n                else:\n                    ans[next_edge] = 1\n            else:\n                ans[next_edge] = label\n            stack.append(next_edge)\n        visited.add(edge)\n    for i in range(n):\n        print((ans[i]))\n\n", "def main():\n    n,m=map(int,input().split())\n    G=[-1]*n\n    Node = {}\n    for i in range(n):\n        Node[i+1]=[]\n    for i in range(m):\n        u,v,c=map(int,input().split())\n        Node[u]+=[[v,c]]\n        Node[v]+=[[u,c]]\n    que = [0]\n    G[0]=1\n    while len(que)>0:\n        q=que.pop(0)\n        for nv,w in Node[q+1]:\n            if G[nv-1]!=-1:\n                continue\n            if G[q]==w:\n                G[nv-1]=(G[q]+1)%n\n            else:\n                G[nv-1]=w\n            que.append(nv-1)\n    cnt=0\n    for i in range(n):\n        if G[i]==-1:\n            cnt+=1\n    if cnt>0:\n        print('No')\n        return\n    for i in range(n):\n        print(G[i])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\nG=[[] for _ in range(n+1)]\nfor _ in range(m):\n    u,v,c=map(int,input().split())\n    G[u].append((v,c))\n    G[v].append((u,c))\nq=1\nstack=[1]\nans=[0]*(n+1)\nans[1]=1\nwhile stack:\n    v=stack.pop()\n    for u,c in G[v]:\n        if not ans[u]:\n            if ans[v]==c: c=c%n+1\n            ans[u]=c\n            stack.append(u)\n            q+=1\n            if q==n:\n                stack=[]\n                break\nif q==n: print(*ans[1:],sep='\\n')\nelse: print('No')", "import sys\nsys.setrecursionlimit(10**9)\nN, M = map(int, input().split())\nedges = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, c = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, c))\n    edges[v].append((u, c))\n\nans = [-1] * N\nans[0] = 1\n\ndef dfs(u):\n    for v, c in edges[u]:\n        if ans[v] != -1: continue\n        if ans[u] == c: \n            if c == 1:\n                ans[v] = 2\n            else:\n                ans[v] = 1\n        else: \n            ans[v] = c\n        dfs(v)\n\ndfs(0)\nprint(*ans, sep=\"\\n\")", "import sys\ninput = lambda: sys.stdin.readline()\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    x, y, c = list(map(int, input().split()))\n    g[x].append((y, c))\n    g[y].append((x, c))\n\nque = [1]\nnum = [0] * (n + 1)\nnum[1] = 1\n\nwhile que:\n    x = que.pop()\n    for v, nv in g[x]:\n        if num[v]:\n            continue\n        if num[x] == nv:\n            num[v] = nv % n + 1\n        else:\n            num[v] = nv\n        que.append(v)\n\nprint((\"\\n\".join(map(str, num[1:]))))\n", "from collections import defaultdict, deque\nn, m = map(int, input().split())\nG = defaultdict(list)\nfor _ in range(m):\n  i, j, w = map(int, input().split())\n  G[i].append((j, w))\n  G[j].append((i, w))\nans = [0] * (n + 1)\nans[1] = 1\nq = deque([1])\nwhile q:\n  node = q.popleft()\n  for nei, w in G[node]:\n    if ans[nei]: continue\n    if ans[node] == w:\n      ans[nei] = w + 1 if w < n else 1\n    else:\n      ans[nei] = w\n    q.append(nei)\n\nfor i in range(n):\n  print(ans[i + 1])", "from collections import deque\nN, M = list(map(int, input().split()))\nc, to = dict(), [[] for _ in range(N)]\n\ndef maxmin(x, y):\n    if x < y:\n        x, y = y, x\n    return (x,y)\n\nfor i in range(M):\n    x,y,z = list(map(int, input().split()))\n    x,y = x-1,y-1\n    x,y = maxmin(x,y)\n    if (x,y) not in c:\n        c[(x,y)] = z\n        to[x].append(y)\n        to[y].append(x)\n\nq = deque([0])\nmark = [0] * N\nmark[0] = 1\nwhile q:\n    now = q.popleft()\n    for next in to[now]:\n        if mark[next]:\n            continue\n        cost = c[maxmin(now, next)]\n        if mark[now] == cost:\n            mark[next] = mark[now] % N + 1\n        else:\n            mark[next] = cost\n        q.append(next)\n\nfor i in mark:\n    print(i)\n", "N,M = list(map(int,input().split()))\nedges=[list([int(x)-1 for x in input().split()]) for _ in range(M)]\n\nadges=[[] for _ in range(N)]\nfor u,v,c in edges:\n    adges[u].append([v,c])\n    adges[v].append([u,c])\n\nvisited=[False]*N\n\ncur=edges[0][0]\nvisited[cur]=True\n\n\nQ=[cur]\nuse_edges=[]\nwhile Q:\n    cur = Q.pop()\n    for nex,label in adges[cur]:\n        if visited[nex]:\n            continue\n        else:\n            Q.append(nex)\n            visited[nex]=True\n            use_edges.append([cur,nex,label])\n\n\nif all(v for v in visited):\n    pass\nelse:\n    print(\"No\")\n    return\n\nans=[-1]*N\nadj_use=[[] for _ in range(N)]\nfor u,v,c in use_edges:\n    adj_use[u].append([v,c])\n    adj_use[v].append([u,c])\n\n\ncur=None\nfor i in range(N):\n    if len(adj_use[i])==1:\n        cur=i\n        break\n\nfor u,v,l in use_edges:\n    if u==cur or v==cur:\n        if l==0:\n            ans[cur]=1\n        else:\n            ans[cur]=0\n        break\nQ=[cur]\n\nwhile Q:\n    cur = Q.pop()\n    for nex,label in adj_use[cur]:\n        if ans[nex]!=-1:\n            continue\n        else:\n            Q.append(nex)\n            if ans[cur]==label:\n                ans[nex]=(label+1)%N\n            else:\n                ans[nex]=label\n\nfor a in ans:\n    print((a+1))\n", "import sys\nfrom collections import deque\nsys.setrecursionlimit(10**7)\ndef I(): return int(sys.stdin.readline().rstrip())\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef LI2(): return list(map(int,sys.stdin.readline().rstrip()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef LS2(): return list(sys.stdin.readline().rstrip())\n\n\nclass UnionFind:\n    def __init__(self,n):\n        self.par = [i for i in range(n+1)]  # \u89aa\u306e\u30ce\u30fc\u30c9\u756a\u53f7\n        self.rank = [0]*(n+1)\n\n    def find(self,x):  # x\u306e\u6839\u306e\u30ce\u30fc\u30c9\u756a\u53f7\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def same_check(self,x,y):  # x,y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u304b\u5426\u304b\n        return self.find(x) == self.find(y)\n\n    def unite(self,x,y):  # x,y\u306e\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u4f75\u5408\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            x,y = y,x\n        if self.rank[x] == self.rank[y]:\n            self.rank[x] += 1\n        self.par[y] = x\n\n\nN,M = MI()\nGraph = [[] for _ in range(N+1)]\nUF = UnionFind(N)\n\nfor _ in range(M):\n    u,v,c = MI()\n    if not UF.same_check(u,v):\n        UF.unite(u,v)\n        Graph[u].append((v,c))\n        Graph[v].append((u,c))\n\ndeq = deque([1])\nANS = [-1]*(N+1)\nANS[1] = 1\nwhile deq:\n    i = deq.pop()\n    for j,c in Graph[i]:\n        if ANS[j] != -1:\n            continue\n        if ANS[i] != c:\n            ANS[j] = c\n        else:\n            if c == 1:\n                ANS[j] = 2\n            else:\n                ANS[j] = 1\n        deq.append(j)\n\nprint(*ANS[1:],sep='\\n')\n", "from collections import deque\n\nN, M = list(map(int, input().split()))\nEdge = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v, c = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    Edge[u].append((v, c))\n    Edge[v].append((u, c))\n\nAns = [-1] * N\nAns[0] = 1\nQ = deque()\nQ.append(0)\n\nwhile Q:\n    now = Q.popleft()\n    for nex, color in Edge[now]:\n        if Ans[nex] != -1:\n            continue\n        if color == Ans[now]:\n            Ans[nex] = color + 1\n            Q.append(nex)\n        else:\n            Ans[nex] = color\n            Q.append(nex)\nif -1 in Ans:\n    print('No')\nelse:\n    for ans in Ans:\n        print(ans)\n", "import sys\nsys.setrecursionlimit(10**8)\n\nclass union_find:\n  def __init__(self, n):\n    self.par = [-1] * n\n\n  def find(self, x):#x\u306e\u89aa\u3092\u898b\u3064\u3051\u308b\n    if self.par[x] < 0:\n      return x\n    else:\n      self.par[x] = self.find(self.par[x])\n      return self.par[x]\n\n  def unite(self,x,y):#\u8981\u7d20x\u3068\uff59\u3092\u4f75\u5408\u3055\u305b\u308b\n    x,y=self.find(x),self.find(y)#x\u3068y\u306e\u89aa\u306e\u691c\u7d22\n    if x!=y:#\u89aa\u304c\u7570\u306a\u308b\u5834\u5408\u4f75\u5408\u3055\u305b\u308b\n      if x>y:\n        x,y=y,x#\u5c0f\u3055\u3044\u65b9\u3092x\u3068\u3059\u308b. \u3053\u308c\u306b\u3088\u308a\u8981\u7d20\u306e\u5024\u304c\u5c0f\u3055\u3044\u3082\u306e\u3092\u512a\u5148\u3057\u3066\u6728\u306e\u6839\u3068\u3059\u308b. \n      self.par[x]+=self.par[y] #\u5024\u3092\u7121\u5411\u6728\u306e\u8981\u7d20\u6570\u306e\u548c\u306b\u3059\u308b.\n      self.par[y]=x #\u679d\u5074\u306f\u6839\u306e\u4f4d\u7f6e\u3092\u683c\u7d0d\n\n  def same(self, x, y):#\u8981\u7d20x\u3068\u8981\u7d20y\u304c\u540c\u3058\u7121\u5411\u6728\u306b\u6240\u5c5e\u3057\u3066\u3044\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\n    return self.find(x) == self.find(y)#\u540c\u3058\u5024\u3092\u6301\u3064\u304b\u5426\u304b\n\n  def size(self, x):#\u8981\u7d20x\u304c\u6240\u5c5e\u3059\u308b\u7121\u5411\u6728\u306e\u5927\u304d\u3055\u3092\u8fd4\u3059\n    return-self.par[self.find(x)]\n  \nn, m = map(int, input().split())\ngragh = [[] for _ in range(n)]\nans = [-1]*n\ndef dfs(now):\n  for nex, c in gragh[now]:\n    if ans[nex] != -1:continue\n    if ans[now] == c:\n      ans[nex] = (c+1)%n + 1\n    else:\n      ans[nex] = c\n    dfs(nex)\n    \ndef main():\n  tree = union_find(n)\n  for i in range(m):\n    u, v, c = map(int, input().split())\n    if not tree.same(u-1, v-1):\n      tree.unite(u-1, v-1)\n      gragh[u-1].append([v-1, c])\n      gragh[v-1].append([u-1, c])\n  ans[0] = 1\n  dfs(0)\n  for i in ans:\n    print(i)\n    \ndef __starting_point():\n  main()\n__starting_point()", "N, M = map(int, input().split())\nUVC = [[int(x)for x in input().split()] for _ in range(M)]\n\ntree = [[] for _ in range(N)]\nfor u, v, c in UVC:\n    u -= 1\n    v -= 1\n    tree[u].append((v, c))\n    tree[v].append((u, c))\n\nresult = [0] * N\nresult[0] = 1  # \u9069\u5f53\nstack = [0]\nwhile stack:\n    current = stack.pop()\n    for child, label in tree[current]:\n        if result[child] != 0:\n            continue\n        stack.append(child)\n        if result[current] == label:\n            result[child] = label + 1 if label < N else 1\n        else:\n            result[child] = label\n\nprint(*result, sep='\\n')\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\nn, m = map(int, input().split())\n\ng = [[] for _ in range(n)]\nuf = UnionFind(n)\nfor _ in range(m):\n    u, v, c = map(lambda x: int(x) - 1, input().split())\n    if uf.find(u) != uf.find(v):\n        g[u].append([v, c])\n        g[v].append([u, c])\n        uf.union(u, v)\n#print(g)\n\n\nnode_val = [None] * n\nnode_val[0] = 0\nque = [0]\nseen = set()\n#BFS\nwhile que != []:\n    temp = []\n    for node in que:\n        if node in seen:\n            continue\n        for next_node, c in g[node]:\n            if next_node in seen:\n                continue\n            if node_val[node] == c:\n                node_val[next_node] = (c+1) % n\n            else:\n                node_val[next_node] = c\n\n            #update\n            temp.append(next_node)\n\n        seen.add(node)\n\n    que = temp\n\nfor val in node_val:\n    print(val + 1)", "# https://atcoder.jp/contests/arc108/submissions/18282738\n\ndef main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    n, m = map(int, input().split())\n\n    g = tuple(list() for _ in range(n))\n    for _ in range(m):\n        u, v, c = (int(x) - 1 for x in input().split())\n        g[u].append((v, c))\n        g[v].append((u, c))\n\n    def make_label(r):\n        ret = [-1] * n\n        ret[r] = 0\n\n        vis = [False] * n\n        vis[r] = True\n\n        dq = deque()\n        dq.append(r)\n\n        while dq:\n            v = dq.popleft()\n            for u, c in g[v]:\n                if vis[u]:\n                    continue\n                vis[u] = True\n                if ret[v] == c:\n                    if c == n:\n                        ret[u] = 0\n                    else:\n                        ret[u] = c + 1\n                else:\n                    ret[u] = c\n                dq.append(u)\n        return ret\n\n    label = make_label(0)\n    ans = map(lambda e: e + 1, label)\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nN, M = list(map(int, stdin.readline().split()))\n\ng = [[] for i in range(0, N)]\n\nfor i in range(0, M):\n    a, b, c = list(map(int, stdin.readline().split()))\n    a -= 1\n    b -= 1\n    g[a].append((b, c))\n    g[b].append((a, c))\n\nvis = [False] * N\ncol = [-1] * N\n\n\ndef dfs(v):\n    nonlocal vis\n    nonlocal col\n    vis[v] = True\n\n    for to, c in g[v]:\n        if vis[to] == True:\n            continue\n        if c == col[v]:\n            if c == 1:\n                col[to] = 2\n            else:\n                col[to] = 1\n        else:\n            col[to] = c\n\n        dfs(to)\n\n\ncol[0] = 1\ndfs(0)\n\nfor i in range(0, N):\n    print((col[i]))\n", "import collections as co\n\nn,m = list(map(int,input().split()))\n\nansDic = dict()\nedgeLis = [[] for i in range(n+1)]\nfor i in range(1,n+1):\n    ansDic[i] = 0\nfor i in range(1,m+1):\n    edge = list(map(int,input().split()))\n    edgeLis[edge[0]].append([edge[1],edge[2]])\n    edgeLis[edge[1]].append([edge[0],edge[2]])\n\nq = co.deque()\nq.append(1)\nwhile len(q) > 0:\n    k = q.popleft()\n    if ansDic[k] == 0:\n        ansDic[k] = k\n    for lis in edgeLis[k]:\n        l1 = lis[0]\n        l2 = lis[1]\n        if ansDic[l1] == 0:\n            q.append(l1)\n            if ansDic[k] != l2:\n                ansDic[l1] = l2\n            elif l1 != l2:\n                ansDic[l1] = l1\n            else:\n                ansDic[l1] = k\n\n#print(ansDic)\nfor i in range(1,n+1):\n    print(ansDic[i])", "import sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n \n    def _root(self, x):\n        stack = []\n        tbl = self.table\n        while tbl[x] >= 0:\n            stack.append(x)\n            x = tbl[x]\n        for y in stack:\n            tbl[y] = x\n        return x\n \n    def find(self, x, y):\n        return self._root(x) == self._root(y)\n \n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            return\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n\ndef main():\n    N, M = map(int, readline().split())\n    all_edges = [tuple(map(int, readline().split())) for _ in range(M)]\n\n    G = [[] for _ in range(N + 1)]\n    edges = []\n    edge_to_label = {}\n    U = UnionFind(N + 1)\n    while all_edges:\n        u, v, c = all_edges.pop()\n        if U.find(u, v):\n            continue\n        U.union(u, v)\n        G[u].append(v)\n        G[v].append(u)\n        edges.append((u, v))\n        edge_to_label[(u, v)] = c\n        edge_to_label[(v, u)] = c\n\n    label = [0]*(N + 1)\n    label[1] = 1\n    stack = [1]\n    while stack:\n        x = stack.pop()\n        for y in G[x]:\n            if label[y] > 0:\n                continue\n            l = edge_to_label[(x, y)]\n            if label[x] == l:\n                label[y] = (l + 1) % N + 1\n                stack.append(y)\n            else:\n                label[y] = l\n                stack.append(y)\n\n    print(*label[1:], sep='\\n')\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "from collections import deque\nn,m = [int(i) for i in input().split()]\ng = [[] for _ in range(n)]\nfor _ in range(m):\n  u,v,c = [int(i)-1 for i in input().split()]\n  g[u].append([v,c])\n  g[v].append([u,c])\nnum = [0]*n\nd = deque()\nd.append(0)\nlabel = [-1]*n\nlabel[0] = 0\nwhile d:\n  a = d.pop()\n  if num[a]:\n    continue\n  num[a] = 1\n  for u,c in g[a]:\n    if num[u]:\n      continue\n    if label[a] != c:\n      label[u] = c\n    elif c == 0:\n      label[u] = 1\n    else:\n      label[u] = 0\n    d.appendleft(u)\nfor i in range(n):\n  label[i] = str(label[i]+1)\nprint(\"\\n\".join(label))", "import sys\ninput = sys.stdin.readline\nN,M = map(int,input().split())\nUVC = [tuple(map(int,input().split())) for i in range(M)]\n\nes = [[] for _ in range(N)]\nfor u,v,c in UVC:\n    u,v = u-1,v-1\n    es[u].append((v,c))\n    es[v].append((u,c))\n\nans = [-1] * N\nans[0] = 1\nstack = [0]\nvisited = [0] * N\nvisited[0] = 1\nwhile stack:\n    v = stack.pop()\n    for to,c in es[v]:\n        if visited[to]: continue\n        visited[to] = 1\n        if ans[v] == c:\n            ans[to] = c+1 if c+1 <= N else 1\n        else:\n            ans[to] = c\n        stack.append(to)\n\nprint(*ans, sep='\\n')", "from collections import deque\n\nn,m=map(int,input().split())\n\nN=[0]*n\nL=[list() for i in range(n)]\nfor i in range(m):\n  u,v,c=map(int,input().split())\n  L[~-u].append([~-v,c])\n  L[~-v].append([~-u,c])\n\nN[0],Q=1,deque([0])\nwhile Q:\n  u=Q.popleft()\n  for v,c in L[u]:\n    if N[v]:\n      continue\n    Q.append(v)\n    if N[u]!=c:\n      N[v]=c\n      continue\n    for i in range(1,n+1):\n      if i!=c:\n        N[v]=i\n        break\n\nprint(*N,sep='\\n')\n", "import collections\nN, M, *UVC = [int(_) for _ in open(0).read().split()]\nU, V, C = [UVC[_::len('UVC')] for _ in range(len('UVC'))]\nCUV = []\nfor u, v, c in zip(U, V, C):\n    CUV += [(c, u, v)]\nCUV.sort()\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * (n + 1)\n        self.rank = [0] * (n + 1)\n\n    def find(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return 0\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.root[self.find(x)]\n\n\nuf = UnionFind(N)\nG = [{} for _ in range(N + 1)]\nse = set()\nfor c, u, v in CUV:\n    if uf.is_same(u, v):\n        continue\n    uf.unite(u, v)\n    se.add(c)\n    G[u][v] = G[v][u] = c\nother = (set(range(1, N + 1)) - se).pop()\nans = [-1] * (N + 1)\nans[1] = 1\nuf2 = UnionFind(N)\nS = [1]\nwhile S:\n    u = S.pop()\n    for v in G[u]:\n        if uf2.is_same(u, v):\n            continue\n        uf2.unite(u, v)\n        c = G[u][v]\n        ans[v] = c if c != ans[u] else c % N + 1\n        S += [v]\nprint(*ans[1:], sep='\\n')\n", "#!/usr/bin/env python3\n# from typing import *\n# %%\nfrom collections import deque\n\n# def solve(N: int, M: int, u: List[int], v: List[int], c: List[int]) -> List[str]:\ndef solve(start, adj):\n    N = len(adj)\n    ans = [0]*N\n    ans[start] = 1\n    que = deque([start])\n    while que:\n        frm = que.popleft()\n        for to, c in adj[frm]:\n            if ans[to]: continue\n            if ans[frm] == c:\n                ans[to] = c%N+1\n            else:\n                ans[to] = c\n            que.append(to)\n    return ans\n\n# %%\n# generated by online-judge-template-generator v4.7.1 (https://github.com/online-judge-tools/template-generator)\ndef main():\n    N, M = list(map(int, input().split()))\n    adj = {i:list() for i in range(N)}\n    for i in range(M):\n        u, v, c = list(map(int, input().split()))\n        adj[u-1].append((v-1,c))\n        adj[v-1].append((u-1,c))\n    ans = solve(0, adj)\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import defaultdict, deque\nn, m = map(int, input().split())\nG = defaultdict(list)\nfor _ in range(m):\n  i, j, w = map(int, input().split())\n  G[i].append((j, w))\n  G[j].append((i, w))\nans = [0] * (n + 1)\nans[1] = 1\nq = deque([1])\nwhile q:\n  node = q.popleft()\n  for nei, w in G[node]:\n    if ans[nei]: continue\n    if ans[node] == w:\n      ans[nei] = w + 1 if w < n else 1\n    else:\n      ans[nei] = w\n    q.append(nei)\nfor i in range(n):\n  print(ans[i + 1])", "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    N, M = map(int, input().split())\n    number = [0] * N\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, c = map(int, input().split())\n        u -= 1; v -= 1\n        edges[u].append((v, c))\n        edges[v].append((u, c))\n\n    # import\n    from collections import deque\n    \n    # BFS for tree\n    # please prefer those objects\n    # ki: adjacency list\n    # N: length of vertex list\n    fr = 0\n    que = deque([fr])\n    number[fr] = 1\n    for _ in range(N**2):\n        fr = que.popleft()\n        for to, c in edges[fr]:\n            if number[to] == 0:\n                que.append(to)\n                if number[fr] != c:\n                    number[to] = c\n                else:\n                    if c == 1:\n                        number[to] = 2\n                    else:\n                        number[to] = 1\n        if len(que) == 0:\n            break\n\n    print(*number, sep = '\\n')\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M = map(int, input().split())\n\nE = [[] for _ in range(N)]\nfor _ in range(M):\n  u, v, c = map(int, input().split())\n  u -= 1\n  v -= 1\n  E[u].append((c, v))\n  E[v].append((c, u))\n\nfrom heapq import heappush, heappop, heapify\nused = [0]*N\nque = [(c, next, 0) for c, next in E[0]]\nused[0] = 1\nheapify(que)\n\nans = [-1]*N\nans[0] = 1\n\nwhile que:\n  cv, v, pre = heappop(que)\n  if used[v]:\n    continue\n  used[v] = 1\n  if cv == ans[pre]:\n    ans[v] = N - (-(cv + 1)%N)\n  else:\n    ans[v] = cv\n  for cost, next in E[v]:\n    if used[next]:\n      continue\n    heappush(que, (cost, next, v))\n\nprint(\"\\n\".join([str(i) for i in ans]))", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x): #\u89aa\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def unite(self, x, y): #\u548c\u96c6\u5408\u306e\u751f\u6210\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x): #\u6240\u5c5e\u3059\u308b\u96c6\u5408\u306e\u5927\u304d\u3055\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\u5224\u5b9a\n        return self.find(x) == self.find(y)\n\n    def members(self, x): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\u5168\u5217\u6319\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self): #\u96c6\u5408\u306e\u30ea\u30fc\u30c0\u30fc\u5168\u5217\u6319\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self): #\u96c6\u5408\u306e\u6570\n        return len(self.roots())\n\n    def all_group_members(self): #\u8f9e\u66f8\u578b,{(\u30ea\u30fc\u30c0\u30fc\u306e\u756a\u53f7):(\u305d\u306e\u96c6\u5408\u306e\u8981\u7d20\u5168\u5217\u6319)}\n        self.group={r:[] for r in self.roots()}\n        for i in range(self.n):\n            self.group[self.find(i)].append(i)\n        return self.group\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nfrom collections import deque\nimport sys\ninput=sys.stdin.readline\n\nn, m = map(int, input().split())\nuf = UnionFind(n)\ne = [[] for _ in range(n)]\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    u -= 1\n    v -= 1\n    if uf.same(u, v):\n        continue\n    e[u].append((v, c))\n    e[v].append((u, c))\n\nque = deque()\nque.append(0)\nans = [-1] * n\nans[0] = 1\n\nwhile que:\n    now = que.popleft()\n    for i, j in e[now]:\n        if ans[i] != -1:\n            continue\n        if ans[now] == j:\n            ans[i] = (j+1)%n\n            if ans[i] == 0:\n                ans[i] = n\n        else:\n            ans[i] = j\n        que.append(i)\n\nprint(*ans, sep = \"\\n\")", "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\nG = defaultdict(list)\n\nfor _ in range(m):\n    i, j, w = map(int, input().split())\n    G[i].append((j, w))\n    G[j].append((i, w))\n\nans = [0] * (n + 1)\nans[1] = 1\nq = deque([1])\n\nwhile q:\n    node = q.popleft()\n    for nei, w in G[node]:\n        if ans[nei]: \n            continue\n        # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u306b\u66f8\u304d\u8fbc\u307e\u308c\u305f\u6570\u3068\u3001\u8fba\u306e\u6570\u5b57\u304c\u4e00\u81f4\n        if ans[node] == w:\n            # \u7570\u306a\u308b\u6570\u5b57\u3092\u6b21\u306e\u30ce\u30fc\u30c9\u306b\u5165\u308c\u308b\n            ans[nei] = w + 1 if w < n else 1\n        # \u73fe\u5728\u306e\u30ce\u30fc\u30c9\u306b\u66f8\u304d\u8fbc\u307e\u308c\u305f\u6570\u3068\u3001\u8fba\u306e\u6570\u5b57\u304c\u4e0d\u4e00\u81f4\n        else:\n            ans[nei] = w\n        q.append(nei)\n\nfor i in range(n):\n    print(ans[i + 1])", "import sys\nfrom collections import deque\nfrom heapq import heappush, heappop\ndef input(): return sys.stdin.readline().strip()\n\ndef main():\n    N, M = list(map(int, input().split()))\n    repn = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u, v, c = list(map(int, input().split()))\n        repn[u].append((c, v))\n        repn[v].append((c, u))\n    \"\"\"\n    \u30b0\u30e9\u30d5\u306b\u304a\u3051\u308b\u69cb\u7bc9\u554f\u984c\u3001spanning tree\u3092\u8003\u3048\u308b\u3068\u3046\u307e\u304f\u3044\u304f\u306e\u306f\u738b\u9053\u306a\u306e\u304b\uff1f\n    \u6700\u5c0f\u5168\u57df\u6728\u306f\u30d7\u30ea\u30e0\u3067\u3044\u3044\u306e\u304b\u306a\u3001\u968f\u5206\u4e45\u3057\u3076\u308a\u306b\u4f7f\u3046\u3002\n\n    \u6728\u304c\u4f5c\u308c\u305f\u3089\u3001\u6839\u304b\u3089\u9806\u756a\u306b\u30e9\u30d9\u30eb\u4ed8\u3092\u884c\u3046\u3002\n    \u4f8b\u3048\u3070\u3042\u308b\u89aa\u30ce\u30fc\u30c9p\u304b\u3089\u8fba\u30e9\u30d9\u30ebc\u306e\u3064\u3044\u305f\u8fba\u3067\u964d\u308a\u3066\u304d\u305f\u9802\u70b9v\u3092\u8003\u3048\u308b\u3068\u304d\u3001\n    \u9802\u70b9v\u306b\u306f\u30e9\u30d9\u30ebc\u3092\u3064\u3051\u308b\u3002\u305d\u3057\u3066\u5b50\u306b\u9806\u3005\u3068\u4e0b\u3063\u3066\u3044\u304f\u3002\n    \u6700\u521d\u306e\u6839\u306b\u3064\u3051\u308b\u30e9\u30d9\u30eb\u306f\u3001\u6839\u304b\u3089\u4f38\u3073\u308b\u3069\u306e\u8fba\u306e\u30e9\u30d9\u30eb\u3068\u3082\u4e00\u81f4\u3057\u306a\u3044\u30e9\u30d9\u30eb\u3092\u4ed8\u3051\u308c\u3070\u826f\u3044\u3002\n    \u3053\u308c\u306f\u6728\u306e\u8fba\u304c\u9802\u70b9\u6570\u3088\u308a\uff11\u5c0f\u3055\u3044\u3053\u3068\u304b\u3089\u5fc5\u305a\u3067\u304d\u308b\u3053\u3068\u304c\u4fdd\u8a3c\u3055\u308c\u308b\uff01\n\n    \u6ce8\u610f\u70b9\u3068\u3057\u3066\u3001\u89aa\u306e\u89aa\u304b\u3089\u9023\u7d9a\u3067\u8fba\u306e\u30e9\u30d9\u30eb\u304c\u9023\u7d9a\u3067\u4e00\u81f4\u3059\u308b\u5834\u5408\u3001\u3053\u306e\u4f5c\u6226\u3060\u3068\n    \u89aa\u3068\u5b50\u3067\u9802\u70b9\u306e\u30e9\u30d9\u30eb\u304c\u4e00\u81f4\u3059\u308b\u306e\u3067\u8fba\u304c\u5207\u308c\u3066\u3057\u307e\u3046\u3002\n    \u306a\u306e\u3067\u3053\u306e\u5834\u5408\u3060\u3051\u5b50\u306b\u306f\u89aa\u3068\u9055\u3046\u30e9\u30d9\u30eb\u3092\u30e9\u30f3\u30c0\u30e0\u306b\u5f53\u3066\u308b\u3002\n    \"\"\"\n    # Prim\n    visited = [0] * (N + 1)\n    used_edge = [[] for _ in range(N + 1)]\n    edge_q = []\n    for c, v in repn[1]:\n        heappush(edge_q, (c, 1, v))\n    visited[1] = 1\n\n    while edge_q:\n        c, u, v = heappop(edge_q)\n        if visited[v]: continue\n        visited[v] = 1\n        used_edge[u].append((c, v))\n        for nc, nv in repn[v]:\n            if not visited[nv]: heappush(edge_q, (nc, v, nv))\n        \n    # Labeling\n    label = [0] * (N + 1)\n    cand = set(range(1, N + 1))\n    for c, v in used_edge[1]: cand.discard(c)\n    label[1] = cand.pop()\n\n    q = deque()\n    for c, v in used_edge[1]: q.append((c, 1, v))\n    while q:\n        c, u, v = q.popleft()\n        if label[u] == c:\n            label[v] = 1 if c != 1 else 2\n        else:\n            label[v] = c\n        for nc, nv in used_edge[v]:\n            q.append((nc, v, nv))\n\n    for i, l in enumerate(label):\n        if i == 0: continue\n        print(l)\n\ndef __starting_point():\n    main()\n\n\n\n\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**9)\nread = lambda:sys.stdin.readline()\n\ndef read_ints():\n    return list(map(int,read().split()))\ndef read_intgrid(h):\n    return list(list(map(int,read().split()))for i in range(h))\ndef read_strgrid(h):\n    return list(list(read())for i in range(h))\n\ndef main():\n    #input data\n    n,m = map(int,input().split())\n    G = [[] for _ in range(n)]\n    for i in range(m):\n        a,b,c = map(int,input().split())\n        a,b = a-1,b-1\n        G[a].append((b,c))\n        G[b].append((a,c))\n\n    #solve\n    #dfs\u3067\u5168\u57df\u6728\u3092\u8d70\u67fb\u3057\u3066\u3044\u304f\u3002\u89aa\u30ce\u30fc\u30c9\u3068\u8fba\u306e\u30e9\u30d9\u30eb\u304c\u540c\u3058\u306a\u3089\u305d\u308c\u4ee5\u5916\u306e\u3082\u306e\u3092\u3001\u7570\u306a\u308b\u306a\u3089\u30e9\u30d9\u30eb\u3092\u9802\u70b9\u306b\u632f\u3063\u3066\u3044\u304f\n\n    vis = [0]*n\n    label = [-1]*n\n    label[0]=1\n\n    def dfs(v):\n        vis[v]=1\n        for x,c in G[v]:\n            if vis[x]:continue\n            # print(x,c,label)\n            if label[x]==-1:\n                if label[v]==c:\n                    if label[v]==1:\n                        label[x]=label[v]+1\n                    else:\n                        label[x]=label[v]-1\n                else:\n                    label[x]=c\n            dfs(x)\n    dfs(0)\n    print('\\n'.join(map(str,label))) \n    return None\ndef __starting_point():\n    main()\n__starting_point()", "#BFS_\u9818\u57df\u6728_\u7121\u5411\u30b0\u30e9\u30d5_\u591a\u91cd\u8fba\n#\u7a7a\u306e\u30ea\u30b9\u30c8\u306e\u96c6\u5408\u306f[[] for i in range(n)]\u3092\u7528\u3044\u308b\u3002\u5f8c\u8005\u3060\u3068\u3059\u3079\u3066\u30ea\u30f3\u30af\u3057\u3066\u3057\u307e\u3046\u3002\nfrom collections import deque\nn, m = map(int, input().split())\nedge = [[] for i in range(n)]\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    u-=1; v-=1\n    edge[u].append((v, c))\n    edge[v].append((u, c))\n\nque = deque([0])\nused = [0]*(n+1)\nused[0]=1\nwhile que:\n    v = que.pop()\n    for u, cost in edge[v]:\n        if used[u]: continue\n        if used[v]==cost:\n            used[u] = cost%n+1\n        else:\n            used[u]=cost\n        que.appendleft(u)\nfor i in range(n):\n    print(used[i])", "import sys\nfrom collections import deque\ninput=sys.stdin.readline\nN, M = list(map(int, input().split()))\nc, to = dict(), [[] for _ in range(N)]\n\ndef maxmin(x, y):\n    if x < y:\n        x, y = y, x\n    return (x,y)\n\nfor i in range(M):\n    x,y,z = list(map(int, input().split()))\n    x,y = x-1,y-1\n    x,y = maxmin(x,y)\n    if (x,y) not in c:\n        c[(x,y)] = z\n        to[x].append(y)\n        to[y].append(x)\n\nq = deque([0])\nmark = [0] * N\nmark[0] = 1\nwhile q:\n    now = q.popleft()\n    for next in to[now]:\n        if mark[next]:\n            continue\n        cost = c[maxmin(now, next)]\n        if mark[now] == cost:\n            mark[next] = mark[now] % N + 1\n        else:\n            mark[next] = cost\n        q.append(next)\n\nfor i in mark:\n    print(i)\n"]
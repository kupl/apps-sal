["import sys\r\nfrom collections import defaultdict\r\ninput = sys.stdin.readline\r\nsys.setrecursionlimit(1000000)\r\n\r\narr=[int(x) for x in input().split()]\r\n\r\nif arr[0]==1:\r\n    print(0)\r\n    return\r\n\r\np=[None]\r\nfor i in range(1,arr[0]+1):\r\n    p.append(arr[i])\r\n    \r\na=[None]\r\nfor i in range(arr[0]+1,2*arr[0]+1):\r\n    a.append(arr[i])\r\n\r\ngraph=defaultdict(list)\r\n\r\nn=len(a)-1\r\nfor i in range(1,n+1):\r\n    if a[i]==-1:\r\n        source=i\r\n        continue\r\n    graph[a[i]].append((i,(p[a[i]]-p[i])))\r\n\r\ndef func(node):\r\n    nonlocal res\r\n    \r\n    if len(graph[node])==0:\r\n        return -10**9\r\n    \r\n    curr=-10**9\r\n    for child in graph[node]:\r\n        x=max(child[1],(func(child[0])+child[1]))\r\n        curr=max(curr,x)\r\n        res=max(curr,res)\r\n    \r\n    return curr    \r\n\r\nres=-10**9\r\ncurr=func(source)\r\nprint(res)        \r\n        \r\n        \r\n        \r\n", "li = list(map(int, input().split()))\n\nn, d = li[0], dict()\nwealths = [None]+li[1:n+1]\nparents = li[n+1:]\n\nfor k in list(range(1, n+1)):\n    d[k] = []\n    \nmax_diff = -200000000\nroot = None\n\nfor i in range(len(parents)):\n    if parents[i] != -1:\n        d[parents[i]].append(i+1)\n    else:\n        root = i+1\n\nq = [root]\nindices = [0 for x in range(n+1)]\n\nwhile len(q) > 0:\n    last = q[-1]\n    curr = d[last]\n    \n    if indices[last] < len(curr) and len(curr) >= 1:\n        rn = curr[indices[last]]\n        indices[last] += 1\n        q.append(rn)\n        \n        for num in q:\n            if num != rn:\n                if wealths[num]-wealths[rn] > max_diff:\n                    max_diff = wealths[num]-wealths[rn];\n    else:\n        q.pop(-1)\n\nprint(max_diff)", "li = list(map(int, input().split()))\nn, d = li[0], dict()\nwealths = [None]+li[1:n+1]\nparents = li[n+1:]\n\nfor k in list(range(1, n+1)):\n    d[k] = []\n    \nmax_diff = -2 * int(1e8)\nroot = None\n\nfor i in range(len(parents)):\n    if parents[i] != -1:\n        d[parents[i]].append(i+1)\n    else:\n        root = i+1\n\nq = [root]\nindices = [0 for x in range(n+1)]\n\nwhile len(q) > 0:\n    curr = d[q[-1]]\n    \n    if indices[q[-1]] < len(curr) and len(curr) >= 1:\n        rn = curr[indices[q[-1]]]\n        indices[q[-1]] += 1\n        q.append(rn)\n        \n        for num in q:\n            if num != rn:\n                if wealths[num]-wealths[rn] > max_diff:\n                    max_diff = wealths[num]-wealths[rn];\n    else:\n        q.pop(-1)\n\nprint(max_diff)", "# cook your dish here\nfrom collections import defaultdict\nfrom collections import deque\na = list(map(int,input().split()))\nn = a[0]\nv = a[1:n+1]\np = a[n+1:]\nans = -1000000000\nboss = 1\ngraph = defaultdict(set)\nfor i in range(n):\n    if p[i] == -1:\n        boss = i+1\n        continue\n    else:\n        graph[p[i]].add(i+1)\n        \ndef bfs(boss, graph, n):\n    nonlocal ans\n    que = deque([])\n    que.append(boss)\n    while que:\n        key = que.popleft()\n        for item in graph[key]:\n            que.append(item)\n            z = v[key-1] - v[item-1]\n            if(ans<z):\n                ans = z \n            if v[key-1] > v[item-1]:\n                v[item-1] = v[key-1]\nbfs(boss, graph, n)\nprint(ans)\n\n        \n    \n", "# cook your dish here\ninputs = list(map(int, input().split()))\nn = inputs[0]\nA = inputs[1:n+1]\nP = inputs[n+1:]\narr = [[] for _ in range(n)]\n\nboss = None\nfor j, i in enumerate(P):\n    if i == -1:\n        boss = j\n    else:\n        arr[i-1].append(j)\n\ndef BFS(array, start):\n    queue = []\n    queue.append(boss)\n    maxi = -10000000000000000000000\n    while queue:\n        cur = queue.pop(0)\n        val = A[cur]\n        for i in arr[cur]:\n            queue.append(i)\n            cur_val = A[i]\n            check = val-cur_val\n            \n            if check>maxi:\n                maxi= check\n            if val>cur_val:\n                A[i] = val\n    return maxi\n\nif n==1:\n    print(0)\nelse:\n    print(BFS(arr,boss))", "# cook your dish here\nfrom collections import defaultdict\nfrom operator import itemgetter\nfrom collections import deque\n\ndef visit(v):\n    height[v][1]=0\n    i=0\n    coda=deque()\n    coda.append(v)\n    while len(coda)>0:\n        num=len(coda)\n        i+=1\n        for _ in range(num):\n            u=coda.popleft()\n            for son in sons[u]:\n                height[son][1]=i\n                coda.append(son)\n    return \n\ninp=list(map(int, input().split()))\nn=inp[0]\nwealth=inp[1:n+1]\nfather=[i-1 if i>0 else i for i in inp[n+1:]]\nsons=defaultdict(lambda:[])\nfor i in range(n):\n    if father[i]!=-1:\n        sons[father[i]].append(i)\n    else:\n        boss=i\n\nheight=[[i,0] for i in range(n)]\nvisit(boss)\n\nheight.sort(key=itemgetter(1), reverse=True)\nminimi=[0]*n\ndiff=[0]*n\n\nfor el in height:\n    v=el[0]\n    if len(sons[v])==0:\n        minimi[v]=wealth[v]\n        diff[v]=-float('Inf')\n    else:\n        minimo=min([minimi[u] for u in sons[v]]) \n        minimi[v]=min(minimo, wealth[v])\n        diff[v]=max(max([diff[u] for u in sons[v]]), wealth[v]-minimo)\n\nprint(diff[boss])\n    \n", "# cook your dish here\nfrom multiprocessing import SimpleQueue as queue\nfrom collections import defaultdict\nfrom operator import itemgetter\n\ndef visit(v, i):\n    height[v][1]=i\n    for u in sons[v]:\n        visit(u, i+1)\n    return \n\ninp=list(map(int, input().split()))\nn=inp[0]\nwealth=inp[1:n+1]\nfather=[i-1 if i>0 else i for i in inp[n+1:]]\nsons=defaultdict(lambda:[])\nfor i in range(n):\n    if father[i]!=-1:\n        sons[father[i]].append(i)\n    else:\n        boss=i\nheight=[[i,0] for i in range(n)]\nvisit(boss, 0)\nheight.sort(key=itemgetter(1), reverse=True)\nminimi=[0]*n\ndiff=[0]*n\nfor el in height:\n    v=el[0]\n    if len(sons[v])==0:\n        minimi[v]=wealth[v]\n        diff[v]=-float('Inf')\n    else:\n        minimo=min([minimi[u] for u in sons[v]]) \n        minimi[v]=min(minimo, wealth[v])\n        diff[v]=max(max([diff[u] for u in sons[v]]), wealth[v]-minimo)\nprint(diff[boss])\n    \n\n'''\ncoda=queue()\nfor i in range(n):\n    if len(sons[i])==0:\n        coda.put(i)\n        visited[i]=1\nwhile len(coda)>0:\n    '''", "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\narr=[int(x) for x in input().split()]\n\nif arr[0]==1:\n    print(0)\n    return\n\np=[None]\nfor i in range(1,arr[0]+1):\n    p.append(arr[i])\n    \na=[None]\nfor i in range(arr[0]+1,2*arr[0]+1):\n    a.append(arr[i])\n\ngraph=defaultdict(list)\n\nn=len(a)-1\nfor i in range(1,n+1):\n    if a[i]==-1:\n        source=i\n        continue\n    graph[a[i]].append((i,(p[a[i]]-p[i])))\n\ndef func(node):\n    nonlocal res\n    \n    if len(graph[node])==0:\n        return -10**9\n    \n    curr=-10**9\n    for child in graph[node]:\n        x=max(child[1],(func(child[0])+child[1]))\n        curr=max(curr,x)\n        res=max(curr,res)\n    \n    return curr    \n\nres=-10**9\ncurr=func(source)\nprint(res)        \n        \n        \n        \n", "from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\n\ngraph=defaultdict(list)\n\narr=[int(x) for x in input().split()]\nif arr[0]==1:\n    print(0)\n    return\n\np=[None]\nfor i in range(1,arr[0]+1):\n    p.append(arr[i])\na=[None]\nfor i in range(arr[0]+1,2*arr[0]+1):\n    a.append(arr[i])\n\nn=len(a)-1\n# print(a)\n# print(p)\nfor i in range(1,n+1):\n    if a[i]==-1:\n        source=i\n        continue\n    graph[a[i]].append((i,(p[a[i]]-p[i])))\n\n# print(graph)\n\ndef func(node):\n    nonlocal res\n    \n    if len(graph[node])==0:\n        return -10**9\n    \n    curr=-10**9\n    for child in graph[node]:\n        x=max(child[1],(func(child[0])+child[1]))\n        curr=max(curr,x)\n        res=max(curr,res)\n    \n    return curr    \n\nres=-10**9\ncurr=func(source)\nprint(res)        \n        \n        \n        \n", "from collections import defaultdict\nfrom sys import stdin\ninput = stdin.readline\n\ngraph=defaultdict(list)\n\narr=[int(x) for x in input().split()]\n\np=[None]\nfor i in range(1,arr[0]+1):\n    p.append(arr[i])\na=[None]\nfor i in range(arr[0]+1,2*arr[0]+1):\n    a.append(arr[i])\n\nn=len(a)-1\n# print(a)\n# print(p)\nfor i in range(1,n+1):\n    if a[i]==-1:\n        source=i\n        continue\n    graph[a[i]].append((i,(p[a[i]]-p[i])))\n\n# print(graph)\n\ndef func(node):\n    nonlocal res\n    \n    if len(graph[node])==0:\n        return -10**9\n    \n    curr=-10**9\n    for child in graph[node]:\n        x=max(child[1],(func(child[0])+child[1]))\n        curr=max(curr,x)\n        res=max(curr,res)\n    \n    return curr    \n\nres=-10**9\ncurr=func(source)\nprint(res)        \n        \n        \n        \n", "x = [int(w) for w in input().split()]\r\nn = x[0]\r\nx = x[1:]\r\na = {(i+1):x[i] for i in range(n)}\r\np = {(i+1):x[n+i] for i in range(n)}\r\nmgr = {i:1 for i in p}\r\nif -1 in mgr:\r\n    mgr[-1] = 0\r\n\r\nd = []\r\nfor i in range(1,n+1):\r\n    t = [float('-inf')]\r\n    par = p[i]\r\n    while mgr.get(par,0):\r\n        t.append(a[par])\r\n        par = p[par]\r\n    p[i] = -1\r\n    d.append(max(t)-a[i])\r\n    a[i] = max(t)\r\nprint(max(d))", "# cook your dish here\n# cook your dish here\nfrom collections import defaultdict\nlist1 = list(map(int,input().split()))\nN = list1[0]\nlist1.pop(0)\nwealth=[]\nparent= {}\nchildren=defaultdict(list)\nfor i in range(N):\n    wealth.append(list1[0])\n    list1.pop(0)\nroot=0\nfor j in range(N):\n    if list1[j] != -1:\n        parent[j] = list1[j]-1\n        children[list1[j]-1].append(j)\n    else:\n        root = j\nleaves=[]\ndowegoup={}\ntobevisited=[root]\nwhile len(tobevisited)>0:\n    temp = tobevisited.pop()\n    if len(children[temp])==0:\n        leaves.append(temp)\n    else:\n        for i in range(len(children[temp])):\n            tobevisited.append(children[temp][i])\n            if wealth[children[temp][i]]>wealth[temp]:\n                dowegoup[children[temp][i]] = False\n            else:\n                dowegoup[children[temp][i]] = True\n#print(\"wealth: \", wealth, \"parents: \", parent, \"children; \", children, \"leaves: \", leaves, \"dowegoup: \", dowegoup)\nvisited={}\ndisparity={}\nanswer=-10**10\nfor j in range(len(leaves)):\n    disparity[leaves[j]]=0\nwhile len(leaves)>0:\n    temp = leaves.pop(0)\n    if parent[temp] not in disparity:\n        disparity[parent[temp]] = wealth[parent[temp]] - wealth[temp]\n        if disparity[temp]>0:\n            disparity[parent[temp]] += disparity[temp]\n    else:\n        if disparity[temp]>0:\n            gladiator = wealth[parent[temp]]-wealth[temp] +disparity[temp]\n        else:\n            gladiator = wealth[parent[temp]]-wealth[temp]\n        disparity[parent[temp]] = max(gladiator,disparity[parent[temp]])\n    if parent[temp]!=root:\n        visited[parent[temp]] = True\n        leaves.append(parent[temp])\n    if disparity[parent[temp]]>answer:\n        answer = disparity[parent[temp]]\n#print(\"disparity: \", disparity)\nprint(answer)", "import sys\r\nfrom collections import defaultdict\r\nsys.setrecursionlimit(1000000)\r\ndef dfs(i,maxVal,maxDiff):\r\n    visited[i]=True\r\n    if not graph[i]:\r\n        return maxDiff\r\n    else:\r\n        stack=[]\r\n        for j in graph[i]:\r\n            if not visited[j]:\r\n                diff=max(maxDiff,maxVal-a[j])\r\n                val=max(maxVal,a[j])\r\n                stack.append(dfs(j,val,diff))\r\n        return max(stack)\r\n\r\ns=list(map(int,input().split()))\r\nn=s[0]\r\na=s[1:n+1]\r\np=s[n+1:]\r\ngraph=defaultdict(list)\r\nfor i in range(n):\r\n    graph[p[i]-1].append(i)\r\nboss=graph[-2][0]\r\nvisited=[False]*n\r\nprint(dfs(boss,a[boss],0))", "x = [int(w) for w in input().split()]\r\nn = x[0]\r\nx = x[1:]\r\na = {(i+1):x[i] for i in range(n)}\r\np = {(i+1):x[n+i] for i in range(n)}\r\nmgr = {i:1 for i in p}\r\nif -1 in mgr:\r\n    mgr[-1] = 0\r\n\r\nd = []\r\nfor i in range(1,n+1):\r\n    t = [float('-inf')]\r\n    par = p[i]\r\n    while mgr.get(par,0):\r\n        t.append(a[par])\r\n        par = p[par]\r\n    p[i] = -1\r\n    d.append(max(t)-a[i])\r\n    a[i] = max(t)\r\nprint(max(d))", "x = list(map(int, input().split()))\r\n\r\nn   = x[0]\r\nx = x[1:]\r\na = {(i):x[i] for i in range(n)}\r\np = {(i):x[n+i] for i in range(n)}\r\n#vis = [0]*n\r\n#print(a,p)\r\n#vis[p.index(-1)] = 2\r\n\r\nbhutiya = []\r\n\r\nfor i in range(n):\r\n\tif p[i] != -1:\r\n\t\t#vis[i] = 1\r\n\t\t#rem = []\r\n\t\t#rem.append(a[i])\r\n\t\tj = p[i]-1\r\n\t\tmaxi = a[i]\r\n\t\t#print(\"j:\",j)\r\n\t\twhile p[j] != -1:\r\n\t\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\t#rem.append(a[j])\r\n\t\t\t#vis[j] = 1\r\n\t\t\tj = p[j]-1\r\n\t\t\r\n\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\r\n\t\tbhutiya.append(maxi-a[i])\r\n\r\nprint(max(bhutiya))\r\n\r\n\r\n", "x = list(map(int, input().split()))\r\n\r\nn   = x[0]\r\na   = x[1:n+1]\r\np   = x[n+1:]\r\n#vis = [0]*n\r\n\r\nparent = a[p.index(-1)]\r\n#vis[p.index(-1)] = 2\r\n\r\nbhutiya = []\r\n\r\nfor i in range(n):\r\n\tif p[i] != -1:\r\n\t\t#vis[i] = 1\r\n\t\t#rem = []\r\n\t\t#rem.append(a[i])\r\n\t\tj = p[i]-1\r\n\t\tmaxi = a[i]\r\n\r\n\t\twhile p[j] != -1:\r\n\t\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\t#rem.append(a[j])\r\n\t\t\t#vis[j] = 1\r\n\t\t\tj = p[j]-1\r\n\t\t\r\n\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\r\n\t\tbhutiya.append(maxi-a[i])\r\n\r\nprint(max(bhutiya))\r\n\r\n\r\n", "x = list(map(int, input().split()))\r\n\r\nn   = x[0]\r\na   = x[1:n+1]\r\np   = x[n+1:]\r\nvis = [0]*n\r\n\r\nparent = a[p.index(-1)]\r\nvis[p.index(-1)] = 2\r\n\r\nbhutiya = []\r\n\r\nfor i in range(n):\r\n\tif vis[i] != 2:\r\n\t\t#vis[i] = 1\r\n\t\t#rem = []\r\n\t\t#rem.append(a[i])\r\n\t\tj = p[i]-1\r\n\t\tmaxi = a[i]\r\n\r\n\t\twhile vis[j] != 2:\r\n\t\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\t#rem.append(a[j])\r\n\t\t\t#vis[j] = 1\r\n\t\t\tj = p[j]-1\r\n\t\t\r\n\t\tif a[j] > maxi:\tmaxi = a[j]\r\n\t\t\r\n\t\tbhutiya.append(maxi-a[i])\r\n\r\nprint(max(bhutiya))\r\n\r\n\r\n", "x = list(map(int, input().split()))\r\n\r\nn   = x[0]\r\na   = x[1:n+1]\r\np   = x[n+1:]\r\nvis = [0]*n\r\n\r\nparent = a[p.index(-1)]\r\nvis[p.index(-1)] = 2\r\n\r\nbhutiya = []\r\n\r\nfor i in range(n):\r\n\tif vis[i] != 2:\r\n\t\tvis[i] = 1\r\n\t\trem = []\r\n\t\trem.append(a[i])\r\n\t\tj = p[i]-1\r\n\r\n\t\twhile vis[j] != 2:\r\n\t\t\trem.append(a[j])\r\n\t\t\tvis[j] = 1\r\n\t\t\tj = p[j]-1\r\n\t\t\r\n\t\trem.append(a[j])\r\n\t\tbhutiya.append(max(rem)-a[i])\r\n\r\nprint(max(bhutiya))\r\n\r\n\r\n", "x = [int(w) for w in input().split()]\r\nn = x[0]\r\nx = x[1:]\r\na = {(i+1):x[i] for i in range(n)}\r\np = {(i+1):x[n+i] for i in range(n)}\r\nmgr = {i:1 for i in p}\r\nif -1 in mgr:\r\n    mgr[-1] = 0\r\n\r\nd = []\r\nfor i in range(1,n+1):\r\n    t = [float('-inf')]\r\n    par = p[i]\r\n    while mgr.get(par,0):\r\n        t.append(a[par])\r\n        par = p[par]\r\n    p[i] = -1\r\n    d.append(max(t)-a[i])\r\n    a[i] = max(t)\r\nprint(max(d))", "x = [int(w) for w in input().split()]\r\nn = x[0]\r\nx = x[1:]\r\na,p = x[:n],x[n:]\r\nx = [[] for i in range(n)]\r\nq = []\r\nfor i in range(n):\r\n    if p[i] == -1:\r\n        q.append([i,a[i]])\r\n    else:\r\n        x[p[i]-1].append(i)\r\nans = float('-inf')\r\nwhile q:\r\n    i,mx = q[-1]\r\n    q.pop()\r\n    ans = max(ans,mx-a[i])\r\n    mx = max(mx,a[i])\r\n    for j in x[i]:\r\n        q.append([j,mx])\r\nprint(ans)", "x = [int(w) for w in input().split()]\nn = x[0]\nx = x[1:]\na = {(i+1):x[i] for i in range(n)}\np = {(i+1):x[n+i] for i in range(n)}\nmgr = {i:1 for i in p}\nif -1 in mgr:\n    mgr[-1] = 0\n\nd = []\nfor i in range(1,n+1):\n    t = [0]\n    par = p[i]\n    while mgr.get(par,0):\n        t.append(a[par])\n        par = p[par]\n    d.append(max(t)-a[i])\n\nprint(max(d))", "x = [int(w) for w in input().split()]\nn = x[0]\nx = x[1:]\na,p = x[:n],x[n:]\n\nmgr = {i:1 for i in p}\nif -1 in mgr:\n    mgr[-1] = 0\n\nd = []\nfor i in range(n):\n    t = [0]\n    par = p[i]\n    while mgr.get(par,0):\n        t.append(a[par-1])\n        par = p[par-1]\n    d.append(max(t)-a[i])\n\nprint(max(d))"]
["# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(\" \"):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1", "# cook your dish here\nprimes=set([2,3,5,7,11,13,17])\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tli=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tli.append(int(j))\n\tli=tuple(li)\n\t# print(lis)\n\tif li in resource: print(resource[li])\n\telse:print(-1)", "# cook your dish here\nprimes=set([2,3,5,7,11,13,17])\n\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nedge=[(0,3),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8),(0,1),(1,2),(1,4)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tlis=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tlis.append(int(j))\n\tlis=tuple(lis)\n\t# print(lis)\n\tif lis in resource: print(resource[lis])\n\telse:print(-1)\n\t\t\t", "primes=set([2,3,5,7,11,13,17])\n\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nedge=[(0,3),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8),(0,1),(1,2),(1,4)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tlis=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tlis.append(int(j))\n\tlis=tuple(lis)\n\t# print(lis)\n\tif lis in resource: print(resource[lis])\n\telse:print(-1)\n\t\t\t", "primes=set([2,3,5,7,11,13,17])\n\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tlis=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tlis.append(int(j))\n\tlis=tuple(lis)\n\t# print(lis)\n\tif lis in resource: print(resource[lis])\n\telse:print(-1)\n\t\t\t", "primes=set([2,3,5,7,11,13,17])\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tlis=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tlis.append(int(j))\n\tlis=tuple(lis)\n\t# print(lis)\n\tif lis in resource: print(resource[lis])\n\telse:print(-1)\n\t\t\t", "primes=set([2,3,5,7,11,13,17])\n\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nedge=[(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(4,5),(3,6),(4,7),(5,8),(6,7),(7,8)]\nx=list(range(1,10))\nfrom collections import deque\nqueue=deque([x])\nresource={tuple(x):0}\nwhile queue:\n\tcur=queue.popleft()\n\t# print(cur)\n\tfor ele in edge:\n\t\tif cur[ele[0]]+cur[ele[1]] in primes:\n\t\t\tcurr=cur[0:]\n\t\t\tcurr[ele[0]],curr[ele[1]]=curr[ele[1]],curr[ele[0]]\n\t\t\t\n\t\t\tref=tuple(curr)\n\t\n\t\t\tif ref not in resource:\n\t\t\t\tresource[tuple(ref)]=resource[tuple(cur)]+1\n\t\t\t\tqueue.append(curr)\n\t\t\t\nfor _ in range(int(input())):\n\tlis=[]\n\tline=input()\n\tfor i in range(3):\n\t\tline=input()\t\n\t\t\n\t\tfor j in line.split():\n\t\t\tlis.append(int(j))\n\tlis=tuple(lis)\n\t# print(lis)\n\tif lis in resource: print(resource[lis])\n\telse:print(-1)\n\t\t\t", "# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\n# print(avail)\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(\" \"):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1# cook your dish here\r\n", "# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\n# print(avail)\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(\" \"):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1# cook your dish here\r\n", "# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\n# print(avail)\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(\" \"):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1# cook your dish here\r\n", "# cook your dish here\r\nfrom collections import deque\r\nprimes = {2,3,5,7,11,13,17}\r\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\r\nx = [1,2,3,4,5,6,7,8,9]\r\navail = {tuple(x):0}\r\nq = deque([x])\r\nwhile q:\r\n    curr = q.popleft();\r\n    for e in edges:\r\n        if curr[e[0]]+curr[e[1]] in primes:\r\n            nxt = curr[0:]\r\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \r\n            nxtt = tuple(nxt)\r\n            if nxtt not in avail:\r\n                avail[nxtt] = avail[tuple(curr)]+1\r\n                q.append(nxt)\r\nt = int(input())\r\n# print(avail)\r\nwhile t:\r\n    inp = input()\r\n    grid = []\r\n    for i in range(3):\r\n        inp = input()\r\n        for j in inp.strip().split(\" \"):\r\n            grid.append(int(j))\r\n    gridt = tuple(grid)\r\n    if gridt in avail: print(avail[gridt])\r\n    else: print(-1);\r\n    t-= 1# cook your dish here\r\n", "# cook your dish here\nprime = [2,3,5,7,11,13,17]\nedges = [(0,3), (0,1), (1,2), (1,4), (2,5), (3,4), (3,6), (4,5), (4,7), (5,8), (6,7), (7,8)]\n\nx = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\navail = {x: 0}\nqueue = [x]\nwhile queue:\n    current = queue.pop(0)\n    for e in edges:\n        if current[e[0]] + current[e[1]] in prime:\n            nxt = list(current)\n            nxt[e[0]], nxt[e[1]] = nxt[e[1]], nxt[e[0]]\n            nxt = tuple(nxt)\n            if nxt not in avail:\n                avail[nxt] = avail[current] + 1 \n                queue.append(nxt)\n\nfor _ in range(int(input())):\n    input()\n    grid = ()\n    for i in range(3):\n        grid += tuple(map(int, input().split()))\n    print(avail[grid] if grid in avail else -1)", "# cook your dish here\np = [2,3,5,7,11,13,17]\ned = [(0,3), (0,1), (1,2), (1,4), (2,5), (3,4), (3,6), (4,5), (4,7), (5,8), (6,7), (7,8)]\n\nx = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\nav = {x: 0}\nqu = [x]\nwhile qu:\n    cur= qu.pop(0)\n    for e in ed:\n        if cur[e[0]] + cur[e[1]] in p:\n            nxt = list(cur)\n            nxt[e[0]], nxt[e[1]] = nxt[e[1]], nxt[e[0]]\n            nxt = tuple(nxt)\n            if nxt not in av:\n                av[nxt] = av[cur] + 1 \n                qu.append(nxt)\n\nfor _ in range(int(input())):\n    input()\n    grid = ()\n    for i in range(3):\n        grid += tuple(map(int, input().split()))\n    print(av[grid] if grid in av else -1)", "prime = [2,3,5,7,11,13,17]\nedges = [(0,3), (0,1), (1,2), (1,4), (2,5), (3,4), (3,6), (4,5), (4,7), (5,8), (6,7), (7,8)]\n\nx = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\navail = {x: 0}\nqueue = [x]\nwhile queue:\n    current = queue.pop(0)\n    for e in edges:\n        if current[e[0]] + current[e[1]] in prime:\n            nxt = list(current)\n            nxt[e[0]], nxt[e[1]] = nxt[e[1]], nxt[e[0]]\n            nxt = tuple(nxt)\n            if nxt not in avail:\n                avail[nxt] = avail[current] + 1 \n                queue.append(nxt)\n\nfor _ in range(int(input())):\n    input()\n    grid = ()\n    for i in range(3):\n        grid += tuple(map(int, input().split()))\n    print(avail[grid] if grid in avail else -1)", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1# cook your dish here\n", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "PRIMES = {3,5,7,11,13,17}\r\n\r\nclass Node :\r\n    def __init__(self,string) :\r\n        self.next = None\r\n        self.a = string\r\n    def swap(self,i,j) :\r\n        b = self.a[:i] + self.a[j] + self.a[i+1:j] + self.a[i] + self.a[j+1:]\r\n        return Node(b)\r\nstart_node = Node('123456789')\r\n\r\nclass Queue :\r\n    def __init__(self) :\r\n        self.front = None\r\n        self.back = None\r\n    def enqueue(self,node) :\r\n        if self.back is None :\r\n            self.front = self.back = node\r\n        else :\r\n            self.back.next = node\r\n            self.back = node\r\n    def dequeue(self) :\r\n        if self.front is None :\r\n            return None\r\n        else :\r\n            node = self.front\r\n            self.front = node.next\r\n            if self.front is None :\r\n                self.back = None\r\n            return node\r\nq = Queue()\r\nq.enqueue(start_node)\r\n\r\ndi = {start_node.a:0}\r\ndef bfs(q,level) :\r\n    if q.front is None :\r\n        return\r\n    q2 = Queue()\r\n    while q.front is not None :\r\n        n = q.dequeue()\r\n        for i in range(8) :\r\n            # check right\r\n            if i%3<2 :\r\n                if int(n.a[i])+int(n.a[i+1]) in PRIMES :\r\n                    b = n.swap(i,i+1)\r\n                    if b.a not in di :\r\n                        di[b.a] = level+1\r\n                        q2.enqueue(b)\r\n            # check down\r\n            if i<6 :\r\n                if int(n.a[i])+int(n.a[i+3]) in PRIMES :\r\n                    b = n.swap(i,i+3)\r\n                    if b.a not in di :\r\n                        di[b.a] = level+1\r\n                        q2.enqueue(b)\r\n    bfs(q2,level+1)\r\n\r\nbfs(q,0)\r\nfor _ in range(int(input())):\r\n    input()\r\n    # n,k = map(int,input().split())\r\n    # s = sorted(map(int,input().split()),reverse=True)\r\n    clue = ''\r\n    for i in range(3) :\r\n        clue += ''.join(input().split())\r\n    print(di.get(clue,-1))\r\n", "PRIMES = {3,5,7,11,13,17}\r\n\r\nclass Node :\r\n    def __init__(self,string) :\r\n        self.next = None\r\n        self.a = string\r\n    def swap(self,i,j) :\r\n        b = self.a[:i] + self.a[j] + self.a[i+1:j] + self.a[i] + self.a[j+1:]\r\n        return Node(b)\r\nstart_node = Node('123456789')\r\n\r\nclass Queue :\r\n    def __init__(self) :\r\n        self.front = None\r\n        self.back = None\r\n    def enqueue(self,node) :\r\n        if self.back is None :\r\n            self.front = self.back = node\r\n        else :\r\n            self.back.next = node\r\n            self.back = node\r\n    def dequeue(self) :\r\n        if self.front is None :\r\n            return None\r\n        else :\r\n            node = self.front\r\n            self.front = node.next\r\n            if self.front is None :\r\n                self.back = None\r\n            return node\r\nq = Queue()\r\nq.enqueue(start_node)\r\n\r\ndi = {start_node.a:0}\r\ndef bfs(q,level) :\r\n    if q.front is None :\r\n        return\r\n    q2 = Queue()\r\n    while q.front is not None :\r\n        n = q.dequeue()\r\n        for i in range(8) :\r\n            # check right\r\n            if i%3<2 :\r\n                if int(n.a[i])+int(n.a[i+1]) in PRIMES :\r\n                    b = n.swap(i,i+1)\r\n                    if b.a not in di :\r\n                        di[b.a] = level+1\r\n                        q2.enqueue(b)\r\n            # check down\r\n            if i<6 :\r\n                if int(n.a[i])+int(n.a[i+3]) in PRIMES :\r\n                    b = n.swap(i,i+3)\r\n                    if b.a not in di :\r\n                        di[b.a] = level+1\r\n                        q2.enqueue(b)\r\n    bfs(q2,level+1)\r\n\r\nbfs(q,0)\r\nfor _ in range(int(input())):\r\n    input()\r\n    # n,k = map(int,input().split())\r\n    # s = sorted(map(int,input().split()),reverse=True)\r\n    clue = ''\r\n    for i in range(3) :\r\n        clue += ''.join(input().split())\r\n    print(di.get(clue,-1))\r\n", "# cook your dish here\n# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\n# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1", "# cook your dish here\nfrom collections import deque\nprimes = {2,3,5,7,11,13,17}\nedges = [(0,3),(0,1),(1,2),(1,4),(2,5),(3,4),(3,6),(4,5),(4,7),(5,8),(6,7),(7,8)]\nx = [1,2,3,4,5,6,7,8,9]\navail = {tuple(x):0}\nq = deque([x])\nwhile q:\n    curr = q.popleft();\n    for e in edges:\n        if curr[e[0]]+curr[e[1]] in primes:\n            nxt = curr[0:]\n            nxt[e[0]],nxt[e[1]] = nxt[e[1]], nxt[e[0]] \n            nxtt = tuple(nxt)\n            if nxtt not in avail:\n                avail[nxtt] = avail[tuple(curr)]+1\n                q.append(nxt)\nt = int(input())\nwhile t:\n    inp = input()\n    grid = []\n    for i in range(3):\n        inp = input()\n        for j in inp.strip().split(\" \"):\n            grid.append(int(j))\n    gridt = tuple(grid)\n    if gridt in avail: print(avail[gridt])\n    else: print(-1);\n    t-= 1"]
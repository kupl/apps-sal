["class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # save all even subarray's length which between odds\n        edge = []\n        res = 0\n        count = 0\n        for i in nums:\n            # odd\n            if i % 2:\n                # +1 because range from 0 to count when doing combination\n                edge.append(count+1)\n                count = 0\n            # even\n            else:\n                count += 1\n        edge.append(count+1)\n        # no enough odd\n        if len(edge)-1 < k:\n            return 0\n        else:\n            # combination\n            for i in range(len(edge)-k):\n                res += edge[i] * edge[i+k]\n            return res", "class Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        d = []\n        n = len(A)\n        res = 0\n        count = 1\n        for i in range(n):\n            if (A[i] % 2):\n                d.append(count)\n                count = 1\n            else:\n                count += 1\n        d.append(count)\n        for x,y in zip(d,d[k:]):\n            res += x * y\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        l = [0]*(len(nums)+1)\n        for i,n in enumerate(nums):\n            l[i+1]=l[i]+n%2\n        c = Counter(l)\n        #print(l)\n        return sum(c[x-k]*c[x] for x in c)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        prefix = {0: 1}\n        count = 0\n        result_count = 0\n        \n        for num in nums:\n            if num % 2:\n                count += 1\n                \n            prefix[count] = prefix.get(count, 0) + 1\n            \n            result_count += prefix.get(count - k, 0)\n        return result_count", "from collections import defaultdict\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def helper(k):\n            start=end=counter=res=0\n            while end<len(nums):\n                if nums[end]%2!=0:\n                    counter+=1\n                end+=1\n                while counter>k:\n                    if nums[start]%2!=0:\n                        counter-=1\n                    start+=1\n                res+=(end-start)\n            return res\n        return helper(k)-helper(k-1)\n                    \n", "from collections import Counter\n\nclass Solution:\n    def numberOfSubarrays(self, A, k):\n        count = Counter([0])\n        \n        ans = 0\n        psum = 0\n        for v in A:\n            psum += v % 2\n            ans += count[psum - k]\n            count[psum] += 1\n        \n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        for i in range(len(nums)): nums[i] = nums[i] % 2\n        mp = defaultdict(int)\n        mp[0] = 1\n        csum, ans = 0, 0\n        \n        for i, num in enumerate(nums):\n            csum += num\n            ans += mp[csum - k]\n            mp[csum] += 1\n        \n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = nice_count = odd_count = 0\n        for j in range(len(nums)):\n            if nums[j] % 2 == 1:\n                odd_count += 1\n                count = 0\n            while odd_count == k:\n                odd_count -= nums[i] % 2\n                i += 1\n                count += 1\n            nice_count += count\n        return nice_count\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if not nums:\n            return 0\n        s = []\n        evencnt = 0\n        for num in nums:\n            if num % 2 == 1:\n                s.append(evencnt)\n                evencnt = 0\n            else:\n                evencnt += 1\n        s.append(evencnt)\n        res = 0\n        for i in range(len(s) - k):\n            res += (s[i]+1) * (s[i+k]+1)\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums, k):\n        return self.atMost(nums, k) - self.atMost(nums, k - 1)\n    \n    def atMost(self, nums, k):\n        if k < 0:\n            return 0\n        n = len(nums)\n        right = 0\n        cnt = 0\n        res = 0\n        for left in range(n):\n            while right <= n - 1 and (cnt < k or nums[right] % 2 == 0):\n                cnt += (nums[right] % 2 == 1)\n                right += 1\n            res += right - left\n            cnt -= (nums[left] % 2 == 1)\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        blocks = [1]\n        for num in nums:\n            if num % 2 == 1:\n                blocks.append(1)\n                continue\n            blocks[-1] += 1\n        return sum(left * right for left, right in zip(blocks, blocks[k:]))", "def solve(A, k):\n    count = [0, 0]\n    front = iter(A)\n    ans = 0\n    size = 0\n    \n    for v in A:\n        count[v % 2] += 1\n        size += 1\n        while count[1] > k:\n            count[next(front) % 2] -= 1\n            size -= 1\n        ans += size\n        \n    return ans\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return solve(nums, k) - solve(nums, k - 1)\n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        data = []\n        curr = 0\n        L = 0\n        count = 0\n        for num in nums:\n            if num % 2 == 0:\n                curr += 1\n            else:\n                L += 1\n                data.append(curr)\n                curr = 0\n        if L < k:\n            return 0\n        end = 0\n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] % 2 == 1:\n                break\n            end += 1\n        for i in range(k - 1, L - 1):\n            count += (data[i - k + 1] + 1) * (data[i + 1] + 1)\n        return count + (end + 1) * (data[-k] + 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = nice_count = odd_count = 0\n        for j in range(len(nums)):\n            if nums[j] % 2 == 1:\n                odd_count += 1\n                count = 0\n            while odd_count == k:\n                odd_count -= nums[i] % 2\n                i += 1\n                count += 1\n            nice_count += count\n        return nice_count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def at_most(nums, k):\n            i, j, count, res = 0, 0, 0, 0\n            while j<len(nums):\n                if nums[j]%2==1:\n                    count+=1\n                while count>k:\n                    if nums[i]%2==1:\n                        count-=1\n                    i+=1\n                res+=j-i+1\n                j+=1\n            return res\n        \n        return at_most(nums,k)-at_most(nums,k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odds = [-1]\n        for i in range(len(nums)):\n            if nums[i]&1: odds.append(i) # &1 should be faster than %2\n        odds.append(len(nums))\n        i, count= 1, 0\n        while i+k-1<len(odds)-1:\n            count += (odds[i]-odds[i-1])*(odds[i+k]-odds[i+k-1])\n            i += 1\n        return count\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        occur = collections.defaultdict(int)\n        \n        occur[0] = 1\n        runsum = 0\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[i] = 0\n            else:\n                nums[i] = 1\n            runsum += nums[i]\n            if (runsum - k) in occur:\n                count += occur[runsum-k]\n            \n            occur[runsum] +=1\n            \n        return count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        s = 0\n        e = 0\n        l = len(nums)\n        total = 0\n        num_odd = 0\n        ae = 0\n        while s < l:\n            \n            \n            \n            while e < l and num_odd != k:\n                if nums[e] % 2 != 0:\n                    # odd\n                    num_odd += 1\n\n                e += 1\n                    \n\n            if num_odd == k:\n                if ae < e:\n                    ae = e\n                    while ae < l and nums[ae] %2 == 0:\n                        ae += 1\n                total += (ae-(e-1))\n                #print(s, e, \\\"total = \\\", total, \\\"added = \\\", l-(e-1), \\\"num_odd = \\\", num_odd)  \n            \n            if nums[s] % 2 != 0:\n                num_odd -= 1\n            s += 1\n            \n        return total\n            \n            \n            \n            \n            \n        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        num_odds = defaultdict(int, {0:1})\n        total = 0\n        \n        running = 0\n        for n in nums:\n            running += n % 2\n            total += num_odds[running - k]\n            \n            num_odds[running] += 1\n        \n        return total", "from collections import defaultdict\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        \n        \n        seen = defaultdict(int)\n        seen[0] = 1\n        \n        output = 0\n        odds = 0\n        \n        for i in range(0,len(nums)):\n            \n            if nums[i]%2 != 0:\n                odds += 1\n            \n            # print(odds-k, seen)\n            if odds - k in seen:\n                # print(i, seen, odds -k )\n                output += seen[odds-k]\n            \n            seen[odds] += 1\n        \n        return output\n            \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        num_nice = 0\n        i = 0\n        count = 0\n        for num in nums:\n            if num & 1:\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                count += 1\n                i += 1\n            num_nice += count\n        return num_nice", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        '''\n        If we replace the odds with 1's and evens with 0's then the problem \n        is similar to finding number of subarrays with sum = k\n        '''\n        '''\n        dp = collections.defaultdict(int)\n        dp[0] = 1\n        cur = 0\n        result = 0\n        for i in range(len(nums)):\n            cur += nums[i]%2\n            diff = cur-k\n            if diff in dp:\n                result += dp[diff]\n            dp[cur]+=1\n        \n        return result\n        '''\n        def atMost(k):\n            l, result = 0,0\n            for i in range(len(nums)):\n                k-=nums[i]%2\n                while k < 0:\n                    k+=nums[l]%2\n                    l+=1\n                result += i-l+1\n            return result\n        \n        return atMost(k) - atMost(k-1)\n                    \n    \n    \n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        output = 0\n        \n        count_odd = 0\n        l = 0\n        for r, n in enumerate(nums):\n            \n            count_odd += int(n % 2 == 1)\n            \n            if count_odd == k:\n                n_even = 1\n                for j in range(r+1, len(nums)):\n                    if nums[j] % 2 == 0:\n                        n_even += 1\n                    else:\n                        break\n            \n            while count_odd == k:\n                output += n_even\n                count_odd -= int(nums[l] % 2 == 1)\n                l += 1\n        \n        return output", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cnt=0\n        d={}\n        d[0]=1\n        for i in nums:\n            if i%2:\n                cnt+=1\n            if cnt in d:\n                d[cnt]+=1\n            else:\n                d[cnt]=1\n                \n        ans=0\n        for key in d:\n            if k+key in d:\n                ans+=(d[key]*d[k+key])\n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cur = res = i = 0\n        for j in range(len(nums)):\n            if nums[j] % 2 != 0:\n                k -= 1\n                if k == 0:\n                    cur = 1\n                    while nums[i] % 2 == 0:\n                        cur += 1\n                        i += 1\n                    k += 1\n                    i += 1\n                    res += cur\n            else:\n                res += cur\n        return res \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        '''\n        This is not an atmost/atleast constraint. \n        Soln pattern is different for atleast constraint\n        refer this https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/\n        This is an exact constraint, so different thinking is required\n        \n        Nice solution is explained here\n        https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-O(1)-Space\n        Two methods are given.\n        1) uses standard templete to find subarray with atmost k odd numbers\n        2) modifies this template slightly to accomodate exactly k odd numbers constraint\n        '''\n        # return self.sol2(nums, k)\n        return self.sol1(nums, k) - self.sol1(nums, k-1)\n    \n    def sol1(self, nums, k):\n        '''\n        Exactly k ones = atMost(k ones) - atMost(k-1 ones)\n        '''\n        start = 0\n        odds = 0\n        res = 0\n        for end in range(len(nums)):\n            odds += nums[end] & 1\n            while odds > k:\n                '''Inc start till constraint is violated'''\n                odds -= nums[start] & 1\n                start += 1\n            \n            '''\n            This will add all sub arrays from size 1,2..end-start for every iteration\n            Since we are doing atMost(k) even if sub array does not contain any odd number we still have to add it to res even if its size is 1\n            '''\n            res += end - start + 1\n            # print(res)    \n        return res\n    \n    def sol2(self, nums, k):\n        start = 0\n        odds = 0\n        res = 0\n        count = 0\n        for end in range(len(nums)):\n            if nums[end] & 1: # nums[end] is odd\n                odds += 1\n                count = 0 # reset counter to avoid repeated addition to result\n                \n            while odds >= k:\n                if nums[start] & 1:\n                    odds -= 1\n                    \n                start += 1\n                count += 1\n                # print(end, start)\n                \n                \n            res += count\n                \n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odds = [-1]\n        for i in range(len(nums)):\n            if nums[i]&1: odds.append(i) # &1 should be faster than %2\n        odds.append(len(nums))\n        i, count= 1, 0\n        while i+k-1<len(odds)-1:\n            count += (odds[i]-odds[i-1])*(odds[i+k]-odds[i+k-1])\n            i += 1\n        return count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def atMost(k):\n            count=i=res=0\n            for j, v in enumerate(nums):\n                if v%2: count+=1\n                while count>k:\n                    if nums[i]%2: count-=1\n                    i+=1\n                res+=j-i+1\n            return res\n        \n        return atMost(k)-atMost(k-1)\n        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def atmost(k):\n            res=i=0\n            for j in range(len(nums)):\n                k-=nums[j]%2\n                while k < 0:\n                    k+=nums[i]%2\n                    i+=1\n                res += j-i+1\n            return res\n        return atmost(k)-atmost(k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # Sliding window approach\n        num_odd_numbers = 0\n        foo = 0\n        left = 0\n        right = 0\n        \n        # We keep an extra count variable here: after we break out of the inner while loop, \n        # we will have the number of nice subarrays recorded as count, then we will continue to expand the right \n        # part of the window, as long as it doesn't hit another odd number which will make the window \n        # unsatisfactory (this is where we reset the count to 0), there will be the same amount more of the \n        # satisfactory window (imagine when K = 2, if [1, 1, 2, 2] is satistfactory, [1, 1, 2, 2, 2] is statisfactory too).\n        count = 0\n        num_nice_arrays = 0\n        \n        while right < len(nums):\n            r_n = nums[right]\n            if r_n % 2 == 1:\n                count = 0\n                num_odd_numbers += 1\n                \n            while num_odd_numbers == k:\n                # Try to subtract the window\n                l_n = nums[left]\n                if l_n % 2 == 1:\n                    num_odd_numbers -= 1\n                left += 1\n                count += 1\n              \n            num_nice_arrays += count\n            right += 1\n            \n        return num_nice_arrays", "class Solution:\n    def numberOfSubarrays(self, nums, k):\n        return self.atMost(nums, k) - self.atMost(nums, k - 1)\n    \n    def atMost(self, nums, k):\n        if k < 0:\n            return 0\n        n = len(nums)\n        right = 0\n        res = 0\n        cnt = 0\n        for left in range(n):\n            while right <= n - 1 and (cnt < k or nums[right] % 2 == 0):\n                cnt += (nums[right] % 2 == 1)\n                right += 1\n            res += right - left\n            cnt -= (nums[left] % 2 == 1)\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def atMost(A, k):\n            res = i = 0\n            for j in range(len(A)):\n                k -= A[j] % 2\n                while k < 0:\n                    k += A[i] % 2\n                    i += 1\n                res += j - i + 1\n            return res\n\n        return atMost(nums, k) - atMost(nums, k - 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        res = count = odd_count = i = 0\n        for j in range(len(nums)) :\n            if nums[j] % 2 == 1 :\n                odd_count += 1\n                count = 0                \n            while odd_count == k:\n                odd_count -= nums[i] % 2\n                i += 1 \n                count += 1\n            res += count\n        return res\n            \n            \n                \n                \n                \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        \n        ## NOT MY CODE TRIALS\n        A=nums\n        def atMost(k):\n            res = i = 0\n            for j in range(len(A)):\n                k -= A[j] % 2\n                while k < 0:\n                    k += A[i] % 2\n                    i += 1\n                res += j - i + 1\n            return res\n\n        return atMost(k) - atMost(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        def AtMostK(k):\n            \n            left = 0\n            count = 0\n            currK = 0\n            \n            for index in range(len(nums)):\n                \n                if nums[index] % 2 == 1:\n                    currK += 1\n                    \n                while currK > k:\n                    if nums[left] % 2 == 1:\n                        currK -= 1\n                    \n                    left += 1\n                \n                count += index - left + 1\n            \n            return count\n        \n        return AtMostK(k) - AtMostK(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        noOfNiceSubArrays = 0\n        even = 0\n        oddList = []\n        for i in range(n):\n            if nums[i]%2==0:\n                even += 1\n            else:\n                oddList.append(even)\n                even = 0\n        oddList.append(even)\n        # print(oddList)\n        for i in range(len(oddList)-k):\n            noOfNiceSubArrays += (oddList[i]+1)*(oddList[i+k]+1)\n            \n        return noOfNiceSubArrays\n                \n    \n    \n#     [1,1,2,1,1]\n#     [0, 0, ]\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odds = [0]*len(nums)\n        n = len(nums)\n        d = {}\n        if nums[0]%2 == 1:\n            odds[0] = 1\n        else:\n            odds[0] = 0\n            \n        # d[odds[0]] = d.setdefault(0, []) + [1]\n        odds = [0] + odds\n        d[0] = d.setdefault(0, []) + [0]\n        \n        count = 0\n        for i in range(1, n+1):\n            if nums[i-1]%2 == 1:\n                odds[i] = odds[i-1] + 1\n            else:\n                odds[i] = odds[i-1]\n            \n            if odds[i] - k in d:\n                count += len(d[odds[i] - k])\n            d[odds[i]] = d.setdefault(odds[i], []) + [i] \n        \n        return (count)\n                        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def helper(k):\n            ans = i = 0\n            for j in range(len(nums)):\n                k -= nums[j]%2\n                while k < 0:\n                    k += nums[i]%2\n                    i += 1\n                ans += j - i + 1\n            return ans\n        return helper(k) - helper(k-1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return self.numberOfAtmostK(nums, k) - self.numberOfAtmostK(nums, k-1)\n    def numberOfAtmostK(self, nums, k):\n        l, r, count, res = 0, 0, 0, 0\n        while r < len(nums):\n            if nums[r] % 2 == 1:\n                count += 1\n            while count > k:\n                if nums[l] % 2 == 1:\n                    count -= 1\n                l += 1\n            res += r - l + 1\n            r += 1\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        def at_most(nums, k):\n            cnts = l = res = 0\n            for r in range(len(nums)):\n                cnts += nums[r] % 2\n\n                while cnts > k:\n                    cnts -= nums[l] % 2\n                    l += 1\n\n                res += r - l + 1\n            return res\n                \n        return at_most(nums, k) - at_most(nums, k-1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = res = 0\n        for j in range(len(nums)):\n            if nums[j] & 1:\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                i += 1\n                count += 1\n            res += count\n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        prefix_sum = [0] *len(nums)\n        start = {}\n\n        prefix_sum[0]= 0 if nums[0]%2==0 else 1\n        if prefix_sum[0] == 0:\n            start[0] = 0\n        else:\n            start[1]=0\n        \n        for i in range(1,len(nums)):\n            prefix_sum[i]=prefix_sum[i-1] if nums[i]%2==0 else prefix_sum[i-1]+1\n            if prefix_sum[i-1]!=prefix_sum[i]:\n                start[prefix_sum[i]] = i\n        out = 0\n        start[prefix_sum[0]] = 0\n        start[prefix_sum[len(nums)-1]] = len(nums)-1\n\n\n        for i in range(len(nums)):\n            print(i)\n            if prefix_sum[i] >= k and nums[i]%2!=0:\n                if prefix_sum[i]-(k-1) in start:\n                    beg = start[prefix_sum[i]-(k-1)]\n                else:\n                    beg = 0\n                # count even numbers before beg\n                j = beg - 1\n                left_count = 0\n                while j >=0:\n                    if nums[j] %2==0:\n                        left_count+=1\n                    else:\n                        break\n                    j-=1\n                # count even numbers after i\n                j = i+1\n                right_count = 0\n                while j <len(nums):\n                    if nums[j] %2==0:\n                        right_count+=1\n                    else:\n                        break\n                    j+=1\n                out += ((left_count + 1)*(right_count+1))                        \n        return out", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        prefix_odd = defaultdict(int)\n        prefix_odd[0] = 1\n        ans = count = 0\n        for num in nums:\n            if num % 2:\n                count += 1\n            prefix_odd[count] += 1\n        for p in prefix_odd:\n            if p - k in prefix_odd:\n                ans += prefix_odd[p] * prefix_odd[p - k]\n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        last = 0\n        hsh = {}\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                nums[i] = 1\n            else:\n                nums[i] = 0\n                \n            nums[i] += last\n            last = nums[i]\n            if nums[i] not in hsh:\n                hsh[nums[i]] = []\n            hsh[nums[i]].append(i)\n        \n        count = 0\n        if k in hsh:\n            count = len(hsh[k])\n        \n        for i in range(len(nums)):\n            x = nums[i]\n            if x + k in hsh:\n                for v in hsh[x+k][::-1]:\n                    if v < i:\n                        break\n                    count += 1\n        return count\n                \n            \n            \n        \n                \n        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        blocks = [0]\n        for num in nums:\n            if num % 2 == 1:\n                blocks.append(0)\n                continue\n            blocks[-1] += 1\n        ans = 0\n        for left, right in zip(blocks, blocks[k:]):\n            ans += (left + 1) * (right + 1)\n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        prefix, odd_cnt, ans = {0: 1}, 0, 0\n        for num in nums:\n            if num % 2 == 1: odd_cnt += 1\n            prefix[odd_cnt] = prefix.get(odd_cnt, 0) + 1\n            if odd_cnt - k in prefix: ans += prefix[odd_cnt - k]\n        \n        return ans\n                \n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = res = 0\n        for j in range(len(nums)):\n            if nums[j] & 1:\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                i += 1\n                count += 1\n            res += count\n        return res\n", "from collections import defaultdict\nclass Solution:\n#     def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n#         hashmap = defaultdict(int)\n#         hashmap[0] = 1\n#         accSum, total = 0, 0\n#         for n in nums:\n#             accSum += 1 if n % 2 ==1 else 0\n#             if accSum - k in hashmap:\n#                 total += hashmap[accSum - k]\n#             hashmap[accSum] += 1\n            \n#         return total\n       def numberOfSubarrays(self, A, k):\n            i = count = res = 0\n            for j in range(len(A)):\n                if A[j] & 1:\n                    k -= 1\n                    count = 0\n                while k == 0:\n                    k += A[i] & 1\n                    i += 1\n                    count += 1\n                res += count\n            return res\n                \n    \n", "class Solution:\n    def numberOfSubarrays(self, A: List[int], B: int) -> int:\n        \n        import collections\n        q, k, temp, count = collections.deque(),0,0,0\n    \n        if B == 0:\n            for i in range(len(A)):\n                if A[i]%2 == 0:\n                    temp = temp+1\n                elif A[i]%2 !=0:\n                    count = count + int((temp*(temp+1))/2)\n                    temp = 0\n            count = count + int((temp*(temp+1))/2)\n            return count\n        \n        while len(q)<B and k<len(A):\n            if A[k]%2 == 0: \n                temp = temp +1\n            elif A[k]%2 == 1:\n                q.append(temp)\n                temp = 0\n            k = k+1\n        \n        if len(q)<B:\n            return 0\n\n        temp = 0\n        for i in range(k,len(A)):\n            if A[i]%2 == 0:\n                temp = temp + 1\n            elif A[i]%2 != 0:\n                count = count + (q[0]+1)*(temp+1)\n                q.append(temp)\n                q.popleft()\n                temp = 0\n                \n        count = count + (q[0]+1)*(temp+1)\n        return count\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        prefix = collections.defaultdict(int)\n        prefix[0] = 1\n        pre = ans = 0\n        for n in nums:\n            pre += n & 1\n            prefix[pre] += 1\n            ans += prefix[pre-k]\n        \n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        idxes = []\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                idxes.append(i)\n                \n        if len(idxes) < k:\n            return 0\n        res = 0\n        for i in range(k-1, len(idxes)):\n            l = -1 if i-k+1 == 0 else idxes[i-k]\n            r = len(nums) if i == len(idxes)-1 else idxes[i+1]\n            \n            res += (idxes[i-k+1] - l) * (r - idxes[i])\n\n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # for k = 0, there is one subarray\n        dic = {0: 1}\n        count = 0 \n        nice = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                count += 1\n            \n            if count-k in dic:\n                nice += dic[count-k] \n            \n            dic[count] = dic.get(count, 0) + 1\n        \n        return nice", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        res = 0\n        i = j = 0\n        while i <= j:\n            while k > 0 and j < len(nums):\n                if nums[j] % 2 == 1:\n                    k -= 1\n                j += 1\n            \n            if k != 0:\n                return res\n            \n            res += 1\n            \n            t = j\n            while t < len(nums):\n                if nums[t] % 2 == 0:\n                    res += 1\n                    t += 1\n                else:\n                    break\n            \n            if nums[i] % 2 == 1:\n                k += 1\n            i += 1\n        \n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        deque = collections.deque()\n        deque.append(1)\n        ans = 0\n        for num in nums:\n            if num % 2 == 0:\n                deque[-1] += 1\n                continue\n            if len(deque) == k + 1:\n                ans += deque[0] * deque[-1]\n                deque.popleft()\n            deque.append(1)\n        if len(deque) == k + 1:\n            ans += deque[0] * deque[-1]\n        return ans", "from collections import Counter\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        count = Counter([0])\n        \n        ans = 0\n        psum = 0\n        for v in map(lambda x: x % 2, nums):\n            psum += v\n            ans += count[psum - k]\n            count[psum] += 1\n        \n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        res = 0\n        odd = 0\n        j = 0\n        for i in range(len(nums)):\n            if nums[i] & 1:\n                odd += 1\n                if odd >= k:\n                    count = 1\n                    if odd > k:\n                        j += 1\n                        odd -= 1\n                    while nums[j] & 1 == 0:\n                        j += 1\n                        count += 1\n                res += count\n            else:\n                res += count\n        return res\n", "def solve(A, k):\n    count = [0, 0]\n    lower = (x % 2 for x in A)\n    \n    ans = 0\n    for x in (x % 2 for x in A):\n        count[x] += 1\n        while count[1] > k:\n            count[next(lower)] -= 1\n        ans += sum(count)\n\n    return ans\n    \n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return solve(nums, k) - solve(nums, k - 1)\n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        left = collections.defaultdict(int)\n        odd = 0\n        res = 0\n        for n in nums:\n            left[odd] += 1\n            odd += n&1\n            if odd - k in left:\n                res += left[odd-k]\n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        nums = [n % 2 for n in nums]\n        \n        def atMost(k):\n            ans, j = 0, 0\n            for i, n in enumerate(nums):\n                k -= n\n                while k < 0:\n                    k += nums[j]\n                    j += 1\n                ans += i - j + 1\n            return ans\n        \n        return atMost(k) - atMost(k - 1)\n        \n        \n        \n#         ans, i, j, cnt = 0, 0, 0, 0\n#         for i, n in enumerate(nums):\n#             cnt += nums[i]\n#             if cnt == k:\n#                 if nums[i]:\n#                     cur = nums[j:].index(1)\n#                 ans += cur + 1\n#             elif cnt > k:\n#                 j += cur + 1\n#                 cnt -= 1\n#                 cur = nums[j:].index(1)\n#                 ans += cur + 1\n#         return ans\n        \n        \n#         def atMost(k):\n#             res = i = 0\n#             for j in xrange(len(A)):\n#                 k -= A[j] % 2\n#                 while k < 0:\n#                     k += A[i] % 2\n#                     i += 1\n#                 res += j - i + 1\n#             return res\n\n#         return atMost(k) - atMost(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        odd_count = tmp_count = j = 0    \n        final_count = 0\n\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                odd_count += 1\n                tmp_count = 0\n\n            while odd_count == k:\n                odd_count -= nums[j] % 2\n                j += 1\n                tmp_count += 1\n\n            final_count += tmp_count\n\n        return final_count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cache = {0: [-1]}\n        cnt = 0\n        odds = 0\n        for i, num in enumerate(nums):\n            if num % 2:\n                odds += 1\n            if odds - k in cache:\n                cnt += len(cache[odds-k])\n            x = cache.setdefault(odds, [])\n            x.append(odds)\n        return cnt", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n         \n        d = collections.defaultdict(int)\n        d[0] = 1\n        cur_sum = 0\n        ans = 0\n        for i,v in enumerate(nums):\n            cur_sum += v%2\n            if cur_sum -k in d:\n                ans += d[cur_sum -k]\n            d[cur_sum] += 1\n        \n        return ans\n                \n            \n        \n         \n                \n", "from collections import deque\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # nums = nums[:]  # if we need to avoid tampering with nums\n        nums.append(1)  # Dummy odd value to avoid final value edge case\n        \n        odds = deque()\n        odds.append(-1)\n        \n        total = 0\n        for i, val in enumerate(nums):\n            if val % 2:\n                odds.append(i)\n                if len(odds) > k + 2:\n                    odds.popleft()\n                if len(odds) == k + 2:\n                    total += (odds[1] - odds[0]) * (odds[-1] - odds[-2])\n                \n        return total", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n      odd_pos = [pos for pos, e in enumerate(nums) if e % 2 == 1]\n\n      if len(odd_pos) < k:\n        return 0\n      \n      spaces = []\n      prev_pos = -1\n      for pos in odd_pos:\n        spaces.append(pos - prev_pos)\n        prev_pos = pos\n      spaces.append(len(nums) - prev_pos)\n      \n      res = 0\n      for i in range(len(spaces) - k):\n        res += spaces[i] * spaces[i + k]\n        \n        \n      return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        output = 0\n        \n        count_odd = 0\n        l = 0\n        for r, n in enumerate(nums):\n            \n            count_odd += int(n % 2 == 1)\n            \n            n_even = 1\n            for j in range(r+1, len(nums)):\n                if nums[j] % 2 == 0:\n                    n_even += 1\n                else:\n                    break\n            \n            while count_odd == k:\n                output += n_even\n                count_odd -= int(nums[l] % 2 == 1)\n                l += 1\n        \n        return output", "def solve(A, k):\n    count = [0, 0]\n    lower = iter(A)\n    \n    ans = 0\n    for x in A:\n        count[x % 2] += 1\n        while count[1] > k:\n            count[next(lower) % 2] -= 1\n        ans += sum(count)\n\n    return ans\n    \n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return solve(nums, k) - solve(nums, k - 1)\n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        temp_arr = []\n        temp_count = 0\n        for n in nums:\n            if n % 2 != 0:\n                temp_arr.append(temp_count)\n                temp_count = 0\n            else:\n                temp_count = temp_count +1\n        \n        temp_arr.append(temp_count)\n        if len(temp_arr) -1 < k:\n            return 0\n        #print(temp_arr)\n        i = k -1\n        count = 0\n        while i < len(temp_arr) -1:\n            start_len = temp_arr[i-k+1] +1\n            end_len = temp_arr[i+1] +1\n            #print(start_len * end_len)\n            count = count + (start_len * end_len)\n            i = i+1\n        return count\n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def atMost(k):\n            res = i = 0\n            for j in range(len(nums)):\n                k -= nums[j] % 2\n                while k < 0:\n                    k += nums[i] % 2\n                    i += 1\n                res += j - i + 1\n            return res\n\n        return atMost(k) - atMost(k - 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = res = 0\n        for j in range(len(nums)):\n            if nums[j] & 1:\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                i += 1\n                count += 1\n            res += count\n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        front,end=0,0\n        tot=0\n        output=0\n        ct=0\n        while end < len(nums):\n            if 1 & nums[end]:\n                tot+=1\n                ct=0\n            end+=1\n            while tot==k:\n                tot-=nums[front]&1\n                front+=1\n                ct+=1\n            output+=ct\n        return output", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cnt = 0\n        accNum = {}\n        ans = 0\n        accNum[0] = 1\n        for x in nums:\n            if x%2:\n                cnt += 1\n            if cnt not in accNum:\n                accNum[cnt] = 1\n            else:\n                accNum[cnt] += 1\n            if cnt-k in accNum:\n                ans += accNum[cnt - k]\n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n\n        aDict = collections.defaultdict(int)\n        aDict[0] = 1\n\n        aSum = 0\n        result = 0\n\n        for i in nums:\n            if i % 2 == 1:\n                aSum += 1\n            if aSum - k in aDict:\n                result += aDict[aSum - k]\n            aDict[aSum] += 1\n        return result", "class Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        d = []\n        res = 0\n        count = 1\n        for a in A:\n            if (a % 2):\n                d.append(count)\n                count = 1\n            else:\n                count += 1\n        d.append(count)\n        for x,y in zip(d,d[k:]):\n            res += x * y\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # Corner cases\n        if k > n:\n            return 0\n        \n        # We will use 4 pointers: p1, p2, p3, p4\n        # p1 will initially start at -1. It will always point to the \\\"previous\\\" odd number\n        # that we DONT want to include the in the current count\n        # p2 will point to the first odd number that we want to count\n        # p3 will point the the kth odd number starting from p2's odd number\n        # p4 will point to the next odd number after p3 if it exists, else will point to n\n        # Given p1, p2, p3, p4, the number of nice subarrays in this window equals (p2-p1)*(p4-p3)\n        # After that, we set p1 to p2, p3 to p4. Then move p4 (if you can) to the next odd number, and move\n        # p2 to the next odd number. Do this until you can't move p4 anymore.\n        ans = 0\n        p1 = p2 = p3 = p4 = -1\n        while p4 < n:\n            # Move p2 to the next odd number\n            p2 += 1\n            while p2 < n and nums[p2] % 2 == 0:\n                p2 += 1\n                if p2 == n:\n                    return ans\n            # p2 now points to the 1st odd number\n            # Now move p3 to the kth odd number (Note that for k=1 p3 coincides with p2)\n            # For the first time the loop is executed, we find the k-th 1 by moving forward one index at a time.\n            # For the second loop onward, we simply set p3 to p4. Also note that because we entered the loop,\n            # p4 < n, hence p4 must point to a 1, hence we can simply set p3 to p4.\n            if p4 == -1:\n                p3 = p2\n                remaining = k-1\n                while p3 < n and remaining:\n                    p3 += 1\n                    if p3 == n:\n                        return ans\n                    if nums[p3] % 2 == 1:\n                        remaining -= 1\n            else:\n                p3 = p4\n            # p3 now points to the kth odd number\n            # Now move p4 to the next odd number\n            p4 = p3 + 1 # p3 is at most n-1, because we would have returned otherwise.\n            while p4 < n:\n                if nums[p4] % 2 == 1:\n                    break\n                p4 += 1\n            # p4 is now either n or the next odd number after p3\n            # Now compute the number of nice subarrays in this window and add to ans\n            ans += (p2-p1)*(p4-p3)\n            # To set up for the next round, set p1 to p2\n            p1 = p2\n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        memo = {0: 1}\n        count = 0\n        res = 0\n        for n in nums:\n            if n % 2 == 1:\n                count += 1\n            if count - k in memo:\n                res += memo[count - k]\n            memo[count] = memo.get(count, 0) + 1\n        return res", "class Solution:\n    \n    def checkOdd(self, num):\n        if num % 2 == 0:\n            return False\n        return True\n\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddIndices = []\n        for i in range(len(nums)):\n            if self.checkOdd(nums[i]):\n                oddIndices.append(i)\n        start = 0\n        end = k - 1\n        i = 0\n        count = 0\n        while end < len(oddIndices):\n            if end == len(oddIndices) - 1:\n                j = len(nums) - 1\n            else:\n                j = oddIndices[end + 1] - 1\n            \n            count = count + (oddIndices[start] -i + 1) * (j - oddIndices[end] + 1)\n            i = oddIndices[start] + 1\n            start = start + 1\n            end = end + 1\n        return count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        prefix_sum = 0\n        \n        dict_odds = {0 : 1}\n        \n        rs = 0\n        \n        for i, num in enumerate(nums):\n            if num % 2 == 1: # odd\n                prefix_sum += 1\n            \n            if prefix_sum not in dict_odds:\n                dict_odds[prefix_sum] = 1\n            else:\n                dict_odds[prefix_sum] = dict_odds[prefix_sum] + 1            \n            \n            if (prefix_sum - k) in dict_odds:\n                rs += dict_odds[(prefix_sum - k)]\n            \n                \n        \n        \n        return rs\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        index_list = []\n        index_list.append(-1)\n        for i in range(0, len(nums)):\n            if nums[i] % 2 == 1:\n                index_list.append(i)\n        index_list.append(len(nums))\n        if len(index_list) == 0:\n            return 0\n        left = 1\n        right = 1\n        k_count = 1\n        count = 0\n        while right < (len(index_list) - 1):\n            if k_count == k:\n                count += (index_list[left] - index_list[left - 1]) * (index_list[right + 1] - index_list[right])\n                left += 1\n                k_count -= 1\n            else:\n                k_count += 1\n                right += 1\n        return count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        memo = collections.defaultdict(int)\n        memo[0] = 1\n        count = 0\n        res = 0\n        for n in nums:\n            if n % 2 == 1:\n                count += 1\n            if count - k in memo:\n                res += memo[count - k]\n            memo[count] += 1\n        return res", "\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        num_odd = 0\n        start = 0\n        output = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                num_odd += 1\n            while num_odd > k:\n                if nums[start] % 2 == 1:\n                    num_odd -= 1\n                start += 1\n            if num_odd == k:\n                output += 1\n                cur_start = start\n                while nums[cur_start] % 2 == 0:\n                    cur_start += 1\n                    output += 1\n        return output", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        adict = {0: 1}\n        x = 0\n        result = 0\n        for i in nums:\n            if i & 1 != 0:\n                x += 1\n            if x - k in adict:\n                result += adict[x-k]\n            adict[x] = adict.get(x, 0) + 1\n        return result\n            \n            \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        rr = l = r = res = cnt = 0\n        ll = -1\n        n = len(nums)\n        while r < n:\n            x = nums[r]\n            if x%2:\n                if ll < l: ll = r\n                cnt += 1\n            if cnt == k:\n                rr = r\n                while r < n - 1 and nums[r + 1]%2 == 0: r += 1\n                res += (ll - l + 1) * (r - rr + 1)\n                l = ll + 1\n                cnt -= 1\n                ll += 1\n                while ll < n and nums[ll]%2 == 0: ll += 1\n            r += 1\n        return res\n            \n                \n                \n", "from collections import defaultdict\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if len(nums) < k:\n            return 0\n        \n        # Cummulative count of number of odds\n        num_odd = 0\n        # Store number of sub-arrays with count [key] previously seen\n        seen = defaultdict(int)\n        seen[0] = 1  # Empty subarray has 0 odd numbers\n        \n        ret = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                num_odd += 1\n            key = num_odd - k\n            ret += seen[key]\n            seen[num_odd] += 1\n        return ret", "class Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        d = []\n        res = 0\n        count = 1\n        for a in A:\n            if (a % 2):\n                d.append(count)\n                count = 1\n            else:\n                count += 1\n        d.append(count)\n        m = len(d)\n        for i in range(m - k):\n            res += d[i] * d[i+k]\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddIndices = []\n        for i in range(len(nums)):\n            if self.checkOdd(nums[i]):\n                oddIndices.append(i)\n        start = 0\n        end = k - 1\n        i = 0\n        count = 0\n        while end < len(oddIndices):\n            if end == len(oddIndices) - 1:\n                j = len(nums) - 1\n            else:\n                j = oddIndices[end + 1] - 1\n            count = count + (oddIndices[start] - i + 1) * (j - oddIndices[end] + 1)\n            i = oddIndices[start] + 1\n            start = start + 1\n            end = end + 1\n        return count\n            \n            \n    def checkOdd(self, num):\n        if num % 2 == 0:\n            return False\n        return True", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        count = 0\n        dic = defaultdict(int)\n#        cum sum\n        dic[0] = 1\n        ans = 0 \n        \n        for i in range(1,len(nums)+1):\n            count += nums[i-1]%2     \n            if (count-k) in list(dic.keys()):\n                ans += dic[count-k]\n            dic[count] += 1   \n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        odd_indeces = []\n        for i, elem in enumerate(nums):\n            if elem % 2 != 0:\n                # is odd\n                odd_indeces.append(i)\n        \n        if len(odd_indeces) < k:\n            return 0\n        \n        output = 0 \n        \n        print(odd_indeces)\n        \n        i = 0 \n        while i + k <= len(odd_indeces): \n            first, last = odd_indeces[i], odd_indeces[i + k - 1]\n            if first == 0:\n                leftdist = 1\n            elif i == 0:\n                leftdist = first + 1\n            else: \n                leftdist = odd_indeces[i] - odd_indeces[i - 1]\n                \n            if last == len(nums) - 1:\n                rightdist = 1\n            elif i + k - 1 == len(odd_indeces) - 1:\n                rightdist = len(nums) - odd_indeces[i + k - 1]\n            else:\n                rightdist = odd_indeces[i + k] - odd_indeces[i + k - 1]\n                \n            output += leftdist * rightdist\n                \n            i += 1\n        return output\n                \n                \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i, count, ans = 0, 0, 0\n        for num in nums:\n            if num % 2 == 1: # odd number\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] % 2\n                i += 1\n                count += 1\n            ans += count\n\n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        ans = i = count = 0\n        for j in range(len(nums)):\n            if nums[j] & 1:\n                k -= 1 \n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                i += 1\n                count += 1\n            ans += count\n        return ans", "def isOdd(num):\n    return num % 2 == 1\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        items = [-1]\n        for i, num in enumerate(nums):\n            if isOdd(num):\n                items.append(i)\n        cnt = 0\n        items.append(len(nums))\n        for i in range(1, len(items) - 1):\n            if i + k - 1 < len(items) - 1:\n                left = items[i] - items[i-1]\n                right = items[i+k] - items[i + k - 1]\n                cnt += left * right\n                    \n        return cnt", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        flattened = [1 if num % 2 == 1 else 0 for num in nums]\n        \n        d = { 0: 1 }\n        sum = 0\n        total = 0\n        \n        for i in range(len(flattened)):\n            sum += flattened[i]\n            total += d.get(sum - k, 0)\n            d[sum] = d.get(sum, 0) + 1\n        \n        return(total)\n", "from collections import Counter\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddCounts = []\n        oddCount = 0\n        for num in nums:\n            if num % 2 == 1:\n                oddCount += 1\n            oddCounts.append(oddCount)\n        oddCountsIdxs = Counter(oddCounts)\n        nice = 0\n        for num in oddCounts:\n            nice += oddCountsIdxs[num-k]\n        nice += oddCountsIdxs[k]\n        return nice", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        #\u53cc\u6307\u9488:\u5faa\u73af\u53f3\u6307\u9488\uff0c\u5d4c\u5957\u5de6\u6307\u9488\u79fb\u52a8\u6807\u51c6\uff0c\u5939\u6742\u8ba1\u6570\u3002\n        nums = [i%2 for i in nums]\n        ans = 0\n        tmp = 0\n        n = len(nums)\n        l = 0#\u5de6\u6307\u9488\n        for r in range(n):\n            #\u5faa\u73af\u53f3\u6307\u9488\n            if nums[r]==1:\n                k -= 1\n                tmp = 0\n                \n            while k == 0:\n                #\u632a\u52a8\u5de6\u6307\u9488\n                #print(l,r)\n                k += nums[l]#\u8e22\u51fa\u4e00\u4e2a\u5947\u6570\u5373\u505c\u6b62\uff0c\u91cd\u65b0\u56de\u5230\u53f3\u6307\u9488\u7684\u5faa\u73af\n                l += 1\n                tmp += 1\n                \n            \n            ans += tmp\n            #print(l,r,ans)\n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        ln = len(nums)\n        ret = 0\n        \n        for i in range(ln):\n            if nums[i] % 2: nums[i] = 1\n            else: nums[i] = 0\n\n        #print(nums)\n                \n        mp = { 0 : 1 }\n        cnt = 0\n\n        for n in nums:\n            cnt += n\n            \n            if cnt not in mp:\n                mp[cnt] = 0\n            mp[cnt] += 1\n            \n            if cnt - k in mp:\n                ret += mp[cnt - k]\n            \n\n        return ret\n        pass\n", "# 20201007 ref\nclass Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        d = []\n        n = len(A)\n        res = 0\n        count = 1\n        for i in range(n):\n            if (A[i] % 2):\n                d.append(count)\n                count = 1\n            else:\n                count += 1\n        d.append(count)\n        for x,y in zip(d,d[k:]):\n            res += x * y\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        ans = 0\n        # d stores elements seen till now against every cumsum \n        d = {0:0}\n        start = {}\n        cumsum = 0\n        for i, num in enumerate(nums):\n            cumsum += num%2\n            d[cumsum] = i+1\n            if (cumsum not in start):\n                start[cumsum] = i\n            if cumsum==k:\n                elems = d[0]\n                ans += elems+1\n            elif cumsum>k:\n                elems = d[cumsum-k] - start.get(cumsum-k, -1)\n                ans += elems\n        return ans", "from collections import deque\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        d,res = deque(),0\n        d.append(-1)\n        for i in range(0,len(nums)):\n            if nums[i] % 2 == 1:\n                d.append(i)\n            if len(d) > k+1:\n                d.popleft()\n            if len(d) == k+1:\n                a = d.popleft()\n                b = d.popleft()\n                res += b-a\n                d.appendleft(b)\n                d.appendleft(a)\n        return res\n                \n", "from collections import Counter\n\nclass Solution:\n    \n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        lookup = Counter()\n        lookup[0] = 1\n        answer = accumulated_odd = 0\n\n        for num in nums:\n            if num % 2 == 1:\n                accumulated_odd += 1\n            answer += lookup[accumulated_odd - k]\n            lookup[accumulated_odd] += 1\n        return answer", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddnum = 0\n        l, n = 0, len(nums)\n        add = 1\n        sums = 0\n        for r in range(n):\n            if nums[r] % 2 == 1:\n                k -= 1\n            while l < r and (k < 0 or nums[l] % 2 == 0):\n                if k < 0:\n                    add = 1\n                else:\n                    add += 1\n                if nums[l] % 2 == 1:\n                    k += 1\n                l += 1\n            if k == 0:\n                sums += add\n        return sums\n            \n", "from collections import Counter\n\nclass Solution:\n    \n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        lookup = Counter()\n        # initializing\n        lookup[0] = 1\n        answer = accumulated_sum = 0\n        \n        for i in range(len(nums)):\n            \n            if nums[i] % 2 == 1:\n                accumulated_sum += 1\n            \n            answer += lookup[accumulated_sum - k]\n            lookup[accumulated_sum] += 1\n            \n        return answer\n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddIdx = []\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                oddIdx.append(i)\n            \n        if len(oddIdx) < k:\n            return 0\n        \n        print(oddIdx)\n        arr = [oddIdx[0] + 1]\n        for i in range(1, len(oddIdx)):\n            temp = oddIdx[i] - oddIdx[i - 1]\n            arr.append(temp)\n        arr.append(len(nums) - oddIdx[-1])\n            \n        print(arr)\n        res = 0\n        for i in range(len(arr) - k):\n            res += arr[i] * arr[i + k]\n        \n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if not nums:\n            return 0\n        \n        return self.atMostK(nums, k) - self.atMostK(nums, k - 1)\n    \n    def atMostK(self, nums, k):\n        count = 0\n        left = 0\n        \n        for right, right_num in enumerate(nums):\n            k -= right_num % 2\n            \n            while k < 0:\n                k += nums[left] % 2\n                left += 1\n            \n            count += right - left + 1\n        return count", "# O(n) time and space \n# Keep a table of { odd number cnt: substrings with this odd number count}\n# For example: {1: 2} means there are two substrings so far with one odd number\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        memo = collections.Counter()\n        memo[0] = 1\n        res = odds = 0\n        \n        for x in nums:\n            if x % 2:\n                odds += 1\n            memo[odds] += 1\n            res += memo[odds-k]\n    \n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        '''\n        two passes, extact k times = at most k times - at most k - 1 times\n        '''\n        def atMost(A: List[int], k: int) -> int:\n            i = ret = 0\n            for j in range(len(A)):\n                if A[j] & 1:\n                    k -= 1\n                while k < 0:\n                    k += A[i] & 1\n                    i += 1\n                ret += j - i + 1\n            return ret \n        \n        return atMost(nums, k) - atMost(nums, k-1)\n            \n", "class Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        \n        def atMost(k):\n            res, lo = 0, 0\n            for hi in range(len(A)):\n                k -= A[hi] % 2\n                while k < 0:\n                    k += A[lo] % 2\n                    lo += 1\n                res += hi - lo + 1\n            return res\n        \n        return atMost(k) - atMost(k-1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        return self.newConcept(nums,k) - self.newConcept(nums,k-1)\n    \n    \n    \n    \n    \n    def newConcept(self,nums,k):\n        \n        ans =0\n        left = 0\n        c = 0\n        for i in range(len(nums)):\n            if(nums[i]%2!=0):\n                c+=1\n            \n           \n                \n            while(c>k):\n                    \n                    \n                if(nums[left] % 2 != 0):\n                    \n                    c-=1\n                        \n                left+=1\n                   \n            ans+=i-left+1\n        \n        \n        return ans\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        def atMost(m):\n            if m < 0:\n                return 0\n            left = res = 0\n            for right, x in enumerate(nums):\n                m -= x & 1\n                while m < 0:\n                    m += nums[left] & 1\n                    left += 1\n                res += right - left + 1\n            return res\n        return atMost(k) - atMost(k - 1)\n        \n        # left = cnt = res = 0\n        # for right, x in enumerate(nums):\n        #     if x & 1:\n        #         k -= 1\n        #         cnt = 0\n        #     while k == 0:\n        #         k += nums[left] & 1\n        #         left += 1\n        #         cnt += 1\n        #     # print(right, cnt)\n        #     res += cnt\n        # return res\n        # def atMost(m):\n        #     res = 0\n        #     left = 0\n        #     for right, x in enumerate(nums):\n        #         m -= x & 1\n        #         while m < 0:\n        #             m += nums[left] & 1\n        #             left += 1\n        #         res += right - left + 1\n        #     return res\n        # return atMost(k) - atMost(k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        arr = list(map(lambda x: x%2, nums))\n        n = len(arr)\n        arr = [0] + list(itertools.accumulate(arr))\n        hm = Counter()\n        res = 0\n        for i in arr:\n            res += hm[i]\n            hm[i+k] += 1\n            \n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n         \n        l=len(nums)\n        def atmost(k):\n            res=0\n            cnt=0\n            j=0\n            for i in range(l):\n                if nums[i]%2==1:\n                    cnt+=1\n                while cnt>k:\n                    if nums[j]%2==1:\n                        cnt-=1\n                    j+=1\n                res+=i-j+1\n            return res\n        return atmost(k)-atmost(k-1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def at_most(k):\n            left = 0\n            count = 0\n            res = 0\n            for right in range(len(nums)):\n                if nums[right] & 1:\n                    count += 1\n                while count > k and left <= right:\n                    if nums[left] & 1:\n                        count -= 1\n                    left += 1\n                \n                res += right - left + 1\n            \n            return res\n        \n        return at_most(k) - at_most(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, A, k):\n        @lru_cache(None)\n        def atMost(k):\n            res = i = 0\n            for j in range(len(A)):\n                k -= A[j] % 2\n                while k < 0:\n                    k += A[i] % 2\n                    i += 1\n                res += j - i + 1\n            return res\n\n        return atMost(k) - atMost(k - 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        positions = [-1]\n        for i in range(len(nums)):\n            if nums[i]%2==1: positions.append(i)\n        positions.append(len(nums))\n        total = 0\n        for i in range(1, len(positions)-k):\n            num_before = positions[i] - positions[i-1]\n            num_after = positions[i+k] - positions[i+k-1]\n            total += num_before * num_after\n        return total\n", "class Solution:\n    def addOrIncrement(self, key, dictionary):\n        if key in dictionary:\n            dictionary[key] += 1\n        else:\n            dictionary[key] = 1\n    \n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n < k:\n            return 0\n        \n        ans = 0\n        seen = {0: 1}\n        curVal = 0\n        for num in nums:\n            curVal += 0 if num % 2 == 0 else 1\n            if curVal - k in seen:\n                ans += seen[curVal - k]\n            self.addOrIncrement(curVal, seen)\n        \n        return ans\n", "def isOdd(num):\n    return num % 2 == 1\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        items = [-1]\n        for i, num in enumerate(nums):\n            if isOdd(num):\n                items.append(i)\n        cnt = 0\n        items.append(len(nums))\n        print(items)\n        \n        for i in range(1, len(items) - k):\n            left = items[i] - items[i-1]\n            right = items[i+k] - items[i + k - 1]\n            cnt += left * right\n                    \n        return cnt", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        left_left = 0\n        left_right = 0\n        odds_left = 0\n        odds_right = 0\n        \n        odds = 0\n        \n        ret = 0\n        \n        for right in range(n):\n            odds_left += nums[right] % 2\n            odds_right += nums[right] % 2\n            \n            while left_left <= right and odds_left > k:\n                odds_left -= nums[left_left] % 2\n                left_left += 1\n            \n            while left_right <= right and odds_right - nums[left_right] % 2 >= k:\n                odds_right -= nums[left_right] % 2\n                left_right += 1\n            \n            if odds_left == odds_right == k:\n                ret += (left_right - left_left + 1)\n                \n        \n        \n        return ret", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return self.at_most(nums, k) - self.at_most(nums, k-1)\n        \n    def at_most(self, nums, k):\n        i = 0\n        res = 0\n        for j, val in enumerate(nums):\n            if val &1 == 1:\n                k -= 1\n            while k < 0:\n                if nums[i] &1 == 1:\n                    k += 1\n                i += 1\n            res += j - i + 1\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cache=collections.Counter({0:1})\n        res,cnt_odd=0,0\n        for i in range(len(nums)):\n            if nums[i]%2==1:\n                cnt_odd+=1\n            res+=cache.get(cnt_odd-k,0)\n            cache[cnt_odd]+=1\n        return res\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def at_most(k):\n            left = 0\n            count = 0\n            res = 0\n            for right in range(len(nums)):\n                count += nums[right] & 1\n                while count > k and left <= right:\n                    count -= nums[left] & 1\n                    left += 1\n                \n                res += right - left + 1\n            \n            return res\n        \n        return at_most(k) - at_most(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        count = 0\n        \n        left = 0\n        right = 0\n        \n        odd = 0\n        \n        while right < len(nums):\n            \n            if nums[right] % 2 == 1:\n                odd += 1\n            \n            while left < right and odd > k:\n                if nums[left] % 2 == 1:\n                    odd -= 1\n                left += 1\n                    \n            if odd == k:\n                count += 1\n                \n            i = left\n            while i < right and odd==k and nums[i] %2 == 0:\n                count += 1\n                i += 1\n                \n            right += 1\n            \n        return count", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if not nums:\n            return 0\n        ans = 0\n        cnt = 0\n        lo = 0\n        hi = 0\n        cnt += nums[0]%2\n        while lo<=hi and hi<len(nums):\n            if cnt<k:\n                hi += 1\n                if hi<len(nums) and nums[hi]%2:\n                    cnt += 1\n            elif cnt>k:\n                if lo<hi and nums[lo]%2:\n                    cnt -= 1\n                lo += 1\n            else:\n                ans += 1\n                tempHi = hi\n                while tempHi+1<len(nums) and nums[tempHi+1]%2 == 0:\n                    ans += 1\n                    tempHi += 1\n                if lo<len(nums) and nums[lo]%2:\n                    cnt -= 1\n                lo += 1\n                if hi<lo:\n                    hi = lo\n                    if hi<len(nums) and nums[hi]%2:\n                        cnt += 1\n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = count = ret = 0\n        for j in range(len(nums)):\n            if nums[j] & 1:\n                k -= 1\n                count = 0\n            while k == 0:\n                k += nums[i] & 1\n                i += 1\n                count += 1\n            ret += count \n        return ret\n            \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def at_most(k):\n            ans = 0\n            i = 0\n            for j in range(len(nums)):\n                k -= nums[j] % 2\n                while k < 0:\n                    k += nums[i] % 2\n                    i += 1\n                ans += j - i + 1\n            return ans\n        return at_most(k) - at_most(k - 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n\n        def helper(k):\n            i, j, count, res, = 0, 0, 0, 0\n            while j < len(nums):\n                if nums[j] % 2 == 1:\n                    count += 1\n                j += 1\n                while count > k:\n                    if nums[i] % 2 == 1:\n                        count -= 1\n                    i += 1\n                res += j - i\n            return res\n        \n        return helper(k) - helper(k - 1)\n\n", "class Solution:\n    def numberOfSubarrays(self, A, k):\n        def atMost(k):\n            res = i = 0\n            for j in range(len(A)):\n                k -= A[j] % 2\n                while k < 0:\n                    k += A[i] % 2\n                    i += 1\n                res += j - i + 1\n            return res\n\n        return atMost(k) - atMost(k - 1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def atMost(K):\n            b,e = 0,0\n            ret = 0\n            while e<len(nums):\n                K-=nums[e]%2\n                while K<0:\n                    K+=nums[b]%2\n                    b+=1\n                ret+=e-b+1\n                e+=1\n            return ret\n        return atMost(k) - atMost(k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        '''\n        If we replace the odds with 1's and evens with 0's then the problem \n        is similar to finding number of subarrays with sum = k\n        Space+Time: O(N)\n        '''\n        '''\n        dp = collections.defaultdict(int)\n        dp[0] = 1\n        cur = 0\n        result = 0\n        for i in range(len(nums)):\n            cur += nums[i]%2\n            diff = cur-k\n            if diff in dp:\n                result += dp[diff]\n            dp[cur]+=1\n        \n        return result\n        '''\n        '''\n        # of subarrays sum equals k = # of subarrays sum <= k -\n                                      # of subarrays sum <= (k-1)\n        '''\n        \n        def atMost(k):\n            l, result = 0,0\n            for i in range(len(nums)):\n                k-=nums[i]%2\n                while k < 0:\n                    k+=nums[l]%2\n                    l+=1\n                result += i-l+1\n            return result\n        \n        #return atMost(k) - atMost(k-1)\n    \n        def atmost(k):\n            res = 0\n            l = 0\n            for i in range(len(nums)):\n                k -= nums[i]%2\n                while k < 0:\n                    k+=nums[l]%2\n                    l+=1\n                res+= i-l+1\n            return res\n        \n        return atmost(k) - atmost(k-1)\n                    \n                \n        \n                    \n    \n    \n    \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if len(nums)==0:\n            return 0\n        preprocess = [0] * (len(nums) + 1) # preprocess[k] = num odd numbers in nums[:k]\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                count+=1\n            preprocess[i+1] = count\n        print(preprocess)\n        cont_preprocess = [preprocess[0]]\n        counts_cont = [1]\n        last_el = preprocess[0]\n        for i in range(1, len(preprocess)):\n            if preprocess[i] == last_el:\n                counts_cont[-1] += 1\n            else:\n                last_el = preprocess[i]\n                cont_preprocess.append(last_el)\n                counts_cont.append(1)\n        result=0\n        # number of (i<j) where a[j]-a[i] == k\n        left_cursor = 0\n        right_cursor = 0\n        while left_cursor < len(cont_preprocess):\n            diff = cont_preprocess[right_cursor] - cont_preprocess[left_cursor]\n            if diff < k:\n                right_cursor += 1\n            elif diff == k:\n                result += (counts_cont[right_cursor] * counts_cont[left_cursor])\n                right_cursor += 1\n            else:\n                left_cursor += 1\n            if right_cursor == len(cont_preprocess):\n                right_cursor = len(cont_preprocess) - 1\n                left_cursor += 1\n        return result", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:        \n        def at_most(k):\n            start_ptr = 0\n            result = 0\n            \n            for end_ptr in range(len(nums)):\n                k -= nums[end_ptr] % 2\n                \n                while k < 0: # Already satisfied the condition, let's reduce the window size\n                    k += nums[start_ptr] % 2\n                    start_ptr += 1\n                \n                result += end_ptr - start_ptr + 1   # Now k just hit > 0, so we can compute this. No of subarray possible is end_ptr - start_ptr + 1. Start_ptr would have gotten as close as possible after this. \n            \n            return result\n            \n        return at_most(k) - at_most(k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        l, r, oddsCounter, res = 0, 0, 0, 0\n        while r < len(nums):\n            if nums[r] % 2 == 1:\n                oddsCounter += 1\n            while oddsCounter >k:\n                if nums[l] % 2 == 1:\n                    oddsCounter -= 1\n                l += 1\n            if oddsCounter == k: \n                res += 1 \n            i = l\n            while oddsCounter == k and i<r and nums[i]%2 == 0:\n                res += 1\n                i += 1\n            r += 1   \n\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        oddIdx = []\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 1:\n                oddIdx.append(i)\n            \n        if len(oddIdx) < k:\n            return 0\n        \n        arr = [oddIdx[0] + 1]\n        for i in range(1, len(oddIdx)):\n            temp = oddIdx[i] - oddIdx[i - 1]\n            arr.append(temp)\n        arr.append(len(nums) - oddIdx[-1])\n            \n        res = 0\n        for i in range(len(arr) - k):\n            res += arr[i] * arr[i + k]\n        \n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        j = i = count = ret = 0\n        for n in nums:\n            if n%2: count += 1\n            if count == k:\n                i = j\n                while count == k:\n                    count -= 1 if nums[j] % 2 else 0\n                    j += 1\n            ret += j - i\n        return ret\n            \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        left_pointer = 0\n        right_pointer = -1\n        count = 0\n        odd = 0\n        \n        while right_pointer < len(nums) - 1:\n            right_pointer += 1\n            \n            if nums[right_pointer] % 2 == 1:\n                odd += 1\n            \n            if odd == k:\n                left_side = 1\n                right_side = 1\n                \n                while right_pointer < len(nums) - 1 and nums[right_pointer + 1] % 2 == 0:\n                    right_side += 1\n                    right_pointer += 1\n                    \n                while left_pointer <= right_pointer and nums[left_pointer] % 2 == 0:\n                    left_side += 1\n                    left_pointer += 1\n                    \n                count += left_side * right_side\n                left_pointer += 1\n                odd -= 1\n                \n        return count\n    \n# def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n#     i = count = nice_count = odd_count = 0\n#     for j in range(len(nums)):\n#         if nums[j] % 2 == 1:\n#             odd_count += 1\n#             if odd_count == k:\n#                 count = 0\n#                 while odd_count == k:\n#                     if nums[i] % 2 == 1:\n#                         odd_count -= 1\n#                     i += 1\n#                     count += 1\n#         nice_count += count\n\n#     return nice_count\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return self.atMost(nums, k) - self.atMost(nums, k - 1)\n    \n    def atMost(self, nums, k):\n        res = left = 0\n        \n        odds = 0\n        \n        for right in range(len(nums)):\n            if nums[right] % 2 == 1:\n                k -= 1\n            \n            while k < 0:\n                if nums[left] % 2 == 1:\n                    k += 1\n                left += 1\n                \n            res += right - left + 1\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        def at_most(k):\n            num_odd=res=i=0\n            for j,v in enumerate(nums):\n                if v%2 !=0:\n                    num_odd+=1\n                while num_odd>k:\n                    if nums[i]%2==1:\n                        num_odd-=1\n                    i+=1\n                res+=j-i+1\n            return res\n        \n        return at_most(k)-at_most(k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        return self.atMost(nums,k) - self.atMost(nums, k-1)\n    def atMost(self, nums, k):\n        count = {0:0,1:0}\n        res = i = 0\n        for j in range(len(nums)):\n            if nums[j] % 2 == 1:\n                k -= 1\n            while k < 0:\n                if nums[i] % 2 == 1:\n                    k += 1\n                i += 1\n            res += j - i + 1\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        # option 1: at most\n#         def atMost(A, k):\n#             res = 0\n#             i = 0\n#             for j in range(len(A)):\n#                 k -= A[j]%2\n#                 while k < 0:\n#                     k += A[i]%2\n#                     i += 1\n#                 res += j - i + 1\n#             return res\n        \n#         return atMost(nums, k) - atMost(nums, k-1)\n        \n        # option 2: 3 pointers\n        res = i = count = 0\n        for j in range(len(nums)):\n            if nums[j]%2:\n                k -= 1\n                count = 0\n            \n            while k == 0:\n                k += nums[i]%2\n                i += 1\n                count += 1\n            \n            res += count\n        return res", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        for i in range(len(nums)):\n            if(nums[i]%2 == 0):\n                nums[i] = 0\n            else:\n                nums[i] = 1\n        \n        pre = [0]\n        for c in nums:\n            pre.append(pre[-1]+c)\n        \n        res = 0\n        dic = {}\n        for c in pre:\n            if(c-k in dic):\n                res += dic[c-k]\n            \n            if(c not in dic):\n                dic[c] = 1\n            else:\n                dic[c] += 1\n        return res", "class Solution:\n    def atMostK(self, nums, k):\n        start = 0\n        end = 0\n        count = 0\n        for end in range(len(nums)):\n            if nums[end] % 2 == 1:\n                k -= 1\n            while k < 0:\n                if nums[start] % 2 == 1:\n                    k += 1\n                start += 1\n            count += end - start + 1\n        return count\n    \n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        if not nums or len(nums) == 0 or k > len(nums):\n            return 0\n        odds = 0\n        return self.atMostK(nums, k) - self.atMostK(nums, k - 1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        d = {0:1}\n        s = 0\n        count = 0\n        for i in range(len(nums)):\n            \n            nums[i]%=2\n            s += nums[i]\n            if not s in d:\n                d[s]=0\n            d[s]+=1\n            if s-k in d:\n                count += d[s-k]\n                \n        return count\n                \n            \n        \n            \n        \n        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        def atMostK(nums, K):\n            res = 0\n            b=0\n            oddCount = 0\n            for e in range(len(nums)):\n                oddCount += int(nums[e]%2==1)\n                \n                while oddCount>K:\n                    oddCount -= int(nums[b]%2==1)\n                    b += 1\n                \n                res += e-b+1\n            \n            return res\n        \n        return atMostK(nums, k) - atMostK(nums, k-1)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        \n        def at_most_k(k: int) -> int:\n            i, j, odds = 0, 0, 0\n            res = 0\n            while j < n:\n                if nums[j] % 2:\n                    odds += 1\n                while i <= j and odds > k:\n                    if nums[i] % 2:\n                        odds -= 1\n                    i += 1\n                j += 1\n                res += j - i\n            return res\n        \n        return at_most_k(k) - at_most_k(k-1)", "class Solution:\n   def numberOfSubarrays(self, nums: List[int], k: int) -> int:            \n    cnt = 0 \n    items = [-1]\n    for i in range(len(nums)):\n        if nums[i] % 2 != 0:\n            items.append(i)\n    items.append(len(nums))\n\n    for i in range(1, len(items) - k ):\n        left = items[i] - items[i - 1]\n        right = items[i + k] - items[i + k-1]\n        cnt += left * right\n    return cnt \n\n", "class Window:\n    def __init__(self):\n        self.odd = 0\n\n    def add(self, value: int):\n        if value % 2 == 1:\n            self.odd += 1\n\n    def remove(self, value: int):\n        if value % 2 == 1:\n            self.odd -= 1\n\n\nclass Solution:\n    def numberOfSubarrays(self, A: List[int], k: int) -> int:\n        window1 = Window()\n        window2 = Window()\n        left1 = left2 = answer = 0\n\n        for right in A:\n            window1.add(right)\n            window2.add(right)\n\n            while window1.odd > k:\n                window1.remove(A[left1])\n                left1 += 1\n\n            while window2.odd >= k:\n                window2.remove(A[left2])\n                left2 += 1\n            answer += left2 - left1\n        return answer", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        result=0\n        start,count=0,0\n        for i in range(len(nums)):\n            if nums[i]%2!=0:\n                count+=1\n            while start<i and count>k:\n                if nums[start]%2!=0:\n                    count-=1\n                start+=1\n            if count==k:\n                result+=1\n            for j in range(start,i):\n                if count==k and nums[j]%2==0:\n                    result+=1\n                else:\n                    break\n        return result\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        P = [0]\n        for n in nums:\n            P.append(P[-1] + n % 2)\n        \n        from collections import Counter\n        count = Counter()\n        ans = 0\n        for p in P:\n            ans += count[p]\n            count[p + k] += 1\n            \n        return ans", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        ans = count = l = 0\n        \n        for num in nums:\n            if num & 1:\n                k -= 1\n                count = 0\n                \n            while k == 0:\n                k += nums[l] & 1\n                count += 1\n                l += 1\n                \n            ans += count\n            \n        return ans\n        \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        cnt=collections.Counter()\n        cnt[0],odd,res=1,0,0\n        for i in nums:\n            if i%2==1: odd += 1\n            cnt[odd] +=1\n            res += cnt[odd-k]\n        return res\n                \n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        \n        def atmostK(K):\n            res=0\n            k=0\n            count=collections.Counter()\n            for i in range(len(nums)):\n                if(nums[i]%2==1): \n                    count[1]+=1\n                while(count[1]>K):\n                    if(nums[k]%2==1):\n                        count[1]-=1\n                    k+=1\n                res+=i-k+1\n            return res\n        \n        return atmostK(k)-atmostK(k-1)\n", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        i = 0\n        count = 0\n        nice_count = 0 \n        odd_count = 0 \n        for j in range(len(nums)):\n            if nums[j] % 2 == 1:\n                odd_count += 1\n                count = 0\n            while odd_count == k:\n                odd_count -=nums[i]%2\n                i+=1\n                count+=1\n            nice_count += count\n        return nice_count", "from collections import Counter\n\nclass Solution:\n    def numberOfSubarrays(self, A, k):\n        psum = [0]\n        for x in map(lambda x: x % 2, A):\n            psum.append(psum[-1] + x)\n            \n        count = Counter(psum)\n        return sum(count[p - k] for p in psum)", "class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -> int:\n        nums = [num%2 for num in nums]\n        count = 0\n        \n        indexlist = deque()\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                indexlist.append(i)\n        \n        #print(indexlist)\n        for i in range(len(indexlist)):\n            if i != 0:\n                left = indexlist[i-1]+1\n            else:\n                left = 0\n                \n            if i + k-1 > len(indexlist)-1:\n                break\n            \n            if i + k-1 != len(indexlist) -1:\n                right = indexlist[i+k-1+1] -1\n            else:\n                right = len(nums)-1\n                \n            leftdis = indexlist[i] - left + 1\n            rightdis = right - indexlist[i+k-1] + 1\n            print((leftdis, rightdis, left, right))\n            count += leftdis * rightdis\n        \n        return count\n            \n        \n            \n"]
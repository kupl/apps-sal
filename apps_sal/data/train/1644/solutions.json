["from math import ceil\ndef b91decode(strng):\n    ret = ''\n    base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"']\n    strng_arr = [strng[i:i+2] for i in range(0, len(strng), 2)]\n    origin_bin = ''\n    for str in strng_arr:\n        num = 0\n        if len(str) == 1:\n            num += base91_alphabet.index(str[0])\n            origin_bin = bin(num)[2:] + origin_bin\n        else:\n            num += base91_alphabet.index(str[0])\n            num += base91_alphabet.index(str[1])*91\n            if num & 8191 > 88:\n                origin_bin = bin(num)[2:].zfill(13) + origin_bin\n            else:\n                origin_bin = bin(num)[2:].zfill(14) + origin_bin\n    origin_bin = origin_bin.zfill(int(ceil(len(origin_bin)/8.0))*8)\n    ret = [origin_bin[i:i+8] for i in range(0, len(origin_bin), 8)]\n    return ''.join(map(lambda x:chr(int(x, 2)), ret))[::-1]\n        \n            \n            \n    \ndef b91encode(strng):\n    base91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"']\n    ret = ''\n    strng_bin = map(lambda x:bin(ord(x))[2:].zfill(8), list(strng))\n    strng_bin_r = ''\n    for i in range(len(strng_bin)):\n        strng_bin_r = strng_bin[i] + strng_bin_r\n    strng_bin_r = strng_bin_r[::-1]\n    index = 0\n    while index < len(strng_bin_r):\n        num = int(strng_bin_r[index:index+13][::-1], 2)\n        if num > 88:\n            index += 13\n            ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n        else:\n            num = int(strng_bin_r[index:index+14][::-1], 2)\n            index += 14\n            ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n    ret = ret[0:len(ret)-2]\n    if num > 90:\n        ret += base91_alphabet[num%91] + base91_alphabet[num/91]\n    else:\n        ret += base91_alphabet[num%91]\n    return ret", "import struct\n\nb91abc = ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n          '!#$%&()*+,./:;<=>?@[]^_`{|}~\"')\n\ndef b91decode(strng):\n    a, b, c = -1, 0, 0\n    result = bytearray()\n    for char in strng:\n        if not char in b91abc:\n            continue\n        ind = b91abc.index(char)\n        if(a < 0): a = ind\n        else:\n            a += ind * 91; b |= a << c\n            c += 13 if (a & 8191) > 88 else 14\n            while True:\n                result += struct.pack('B', b & 255); b >>= 8; c -= 8\n                if c <= 7: break\n            a = -1\n    if a + 1: result += struct.pack('B', (b | a << c) & 255 )\n    return result.decode()\n\ndef b91encode(strng):\n    a, b = 0, 0 \n    result = ''\n    for count in range(len(strng)):\n        byte = strng.encode()[count:count+1]\n        b |= struct.unpack('B', byte)[0] << a; a += 8\n        if a > 13: \n            c = b & 8191\n            if c > 88: b >>= 13; a -= 13\n            else: c = b & 16383; b >>= 14; a -= 14\n            result += b91abc[c % 91] + b91abc[c // 91]\n    if a:\n        result += b91abc[b % 91]\n        if a > 7 or b > 90: result += b91abc[b // 91]\n    return result", "import struct\n\nCHARSET = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n           'abcdefghijklmnopqrstuvwxyz'\n           '0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"')\n\ndef b91decode(message):\n    value = stack = 0\n    out = bytes()\n    for first, second in zip(message[::2], message[1::2]):\n        cipher = CHARSET.index(first) + CHARSET.index(second) * 91\n        value |= cipher << stack\n        stack += 13 + ((cipher & 8191) < 89)\n        while stack > 7:\n            out    += struct.pack('B', value & 255)\n            value >>= 8\n            stack  -= 8\n    if len(message) % 2:\n        rogue = message[-1]\n        out  += struct.pack('B', (value | CHARSET.index(rogue) << stack) & 255)\n    return out.decode('utf-8')\n\ndef b91encode(data):\n    value = stack = 0\n    out = ''\n    for (byte,) in struct.iter_unpack('B', bytes(data, 'utf-8')):\n        value |= byte << stack\n        stack += 8\n        if stack > 13:\n            cipher = value & 8191\n            if cipher > 88:\n                value >>= 13\n                stack  -= 13\n            else:\n                cipher  = value & 16383\n                value >>= 14\n                stack  -= 14\n            out += CHARSET[cipher % 91] + CHARSET[cipher // 91]\n    return out + (value > 0) * CHARSET[value % 91]", "import struct\n\nmapp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"'\ndmapp = dict((v,k) for k,v in enumerate(mapp))\n\ndef b91decode(strng):\n    dbq = 0\n    dn = 0\n    dv = -1\n    res = bytearray()\n    for s in strng:\n        if not s in dmapp.keys():\n            continue\n        if dv == -1:\n            dv = dmapp[s]\n        else:\n            dv += dmapp[s] * 91\n            dbq |= dv << dn\n            if dv & 8191 > 88:\n                dn += 13\n            else:\n                dn += 14                \n            while True:\n                res += struct.pack('B', dbq & 255)\n                dbq >>= 8\n                dn -= 8\n                if dn <= 7:\n                    break\n            dv = -1\n    if dv != -1:\n        res += struct.pack('B', (dbq | dv << dn) & 255)\n        \n    return res.decode('utf-8') \n            \n    \ndef b91encode(strng):\n    en = 0\n    ebq = 0\n    res = ''\n    for i in range(len(strng)):\n        ebq |= (struct.unpack('B', strng[i].encode())[0] & 255) << en\n        en += 8\n        if en > 13:\n            ev = ebq & 8191\n            if ev > 88:\n                ebq >>= 13\n                en -= 13\n            else:\n                ev = ebq & 16383\n                ebq >>= 14\n                en -= 14\n            res += mapp[ev % 91] + mapp[ev // 91]\n    if en:\n        res += mapp[ebq % 91];\n        if en > 7 or ebq > 90:\n            res += mapp[ebq / 91]\n\n    return res", "# yet another rewrite of Joachim Henke's C# implementation\n\nENCODE = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\\\"\")\nDECODE = dict(map(reversed, enumerate(ENCODE)))\n\ndef b91encode(s):\n    b, i = 0, 0\n    r = \"\"\n\n    for c in s:\n        b |= ord(c) << i\n        i += 8\n        if i > 13:\n            v = b & 0x1FFF\n            k = 13\n            if v < 89:\n                v = b & 0x3FFF\n                k += 1\n            b >>= k\n            i -= k\n            r += ENCODE[v % 91] + ENCODE[v // 91]\n    if i:\n        r += ENCODE[b % 91]\n        if i > 7 or b > 90: r += ENCODE[b // 91]\n\n    return r\n\ndef b91decode(s):\n    v, b, i = -1, 0, 0\n    r = \"\"\n\n    for c in s:\n        c = DECODE[c]\n        if ~v:\n            v += c * 91\n            b |= v << i\n            i += 13 + (v & 0x1FFF < 89)\n            while 1:\n                r += chr(b & 0xFF)\n                b >>= 8\n                i -= 8\n                if i < 8: break\n            v = -1\n        else: v = c\n    if ~v: r += chr((b | v << i) & 0xFF)\n\n    return r", "from itertools import zip_longest as lzip\n\nb91abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"'\n\ndef b91decode(string):\n    b = ''\n    for x, y in lzip(*[iter(string)] * 2):\n        num = 0\n        if y is None:\n            num += b91abc.index(x)\n            b = bin(num)[2:] + b\n        else:\n            num += b91abc.index(x) + b91abc.index(y) * 91\n            b = bin(num)[2:].zfill(13 if num & 8191 > 88 else 14) + b\n    b = b.zfill((len(b) // 8 + 1) * 8)\n    return ''.join(chr(int(''.join(x), 2)) for x in lzip(*[iter(b)] * 8, fillvalue=''))[::-1]\n\n\ndef b91encode(string):\n    ret = b = ''\n    index = num = 0\n    for x in string:\n        b = bin(ord(x))[2:].zfill(8) + b\n    b = b[::-1]\n    while index < len(b):\n        num = int(b[index:index + 13][::-1], 2)\n        if num <= 88:\n            num = int(b[index:index + 14][::-1], 2)\n            index += 1\n        index += 13\n        ret += b91abc[num % 91] + b91abc[num // 91]\n    return ret[:len(ret) - 2] + b91abc[num % 91] + b91abc[num // 91] * (num > 90)", "from struct import pack, unpack\n\nbase91 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n          'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n          'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n          'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n          '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n          '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n          '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"']\n\ndecode_table = {v: k for k, v in enumerate(base91)}\n\n\ndef b91encode(string):\n    b = n = 0\n    out = ''\n    for i in range(len(string)):\n        byte = string.encode('utf-8')[i:i + 1]\n        b |= unpack('B', byte)[0] << n\n        n += 8\n        if n > 13:\n            v = b & 8191\n            if v > 88:\n                b >>= 13\n                n -= 13\n            else:\n                v = b & 16383\n                b >>= 14\n                n -= 14\n            out += base91[v % 91] + base91[v // 91]\n    if n:\n        out += base91[b % 91]\n        if n > 7 or b > 90:\n            out += base91[b // 91]\n    return out\n\n\ndef b91decode(string):\n    v = -1\n    b = n = 0\n    out = bytearray()\n    for char in string:\n        if char not in decode_table:\n            continue\n        c = decode_table[char]\n        if v < 0:\n            v = c\n        else:\n            v += c * 91\n            b |= v << n\n            n += 13 if (v & 8191) > 88 else 14\n            while True:\n                out += pack('B', b & 255)\n                b >>= 8\n                n -= 8\n                if not n > 7:\n                    break\n            v = -1\n    if v + 1:\n        out += pack('B', (b | v << n) & 255)\n    return out.decode('utf-8')", "codes='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~\"'\ndef b91decode(strng):\n    b=[]\n    for i in range(0,len(strng),2):\n        if len(strng[i:i+2])==2:\n            c1,c2=strng[i:i+2]\n            x=codes.index(c1)+codes.index(c2)*91\n        else:\n            x=codes.index(strng[i:i+2])\n        if x<=88 or x>=8192:\n            b=list('{:014b}'.format(x))+b\n        else:\n            b=list('{:013b}'.format(x))+b\n    r=''\n    while(b):\n        x=[]\n        for _ in range(8):\n            if not b:\n                break\n            x.insert(0,b.pop())\n        r+=chr(int(''.join(x),2))\n    return r.rstrip('\\x00')\n        \n    \ndef b91encode(strng):\n    b=[]\n    for c in strng:\n        b=list('{:08b}'.format(ord(c)))+b\n    r=''\n    while(b):\n        x=[]\n        for _ in range(13):\n            if not b:\n                break\n            x.insert(0,b.pop())\n        n=int(''.join(x),2)\n        if n<=88 and b:\n            x.insert(0,b.pop())\n            n=int(''.join(x),2)\n        r+=codes[n%91]+codes[n//91]\n    return r.rstrip('A')", "import struct\n\nbase91_alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"']\n\ndecode_table = dict((v,k) for k,v in enumerate(base91_alphabet))\n\n\ndef b91decode(encoded_str):\n    v = -1\n    b = 0\n    n = 0\n    out = bytearray()\n    for strletter in encoded_str:\n        if not strletter in decode_table:\n            continue\n        c = decode_table[strletter]\n        if(v < 0):\n            v = c\n        else:\n            v += c*91\n            b |= v << n\n            n += 13 if (v & 8191)>88 else 14\n            while True:\n                out += struct.pack('B', b&255)\n                b >>= 8\n                n -= 8\n                if not n>7:\n                    break\n            v = -1\n    if v+1:\n        out += struct.pack('B', (b | v << n) & 255 )\n    return out.decode()\n\n\ndef b91encode(string):\n    b = 0\n    n = 0\n    out = ''\n    bindata = string.encode()\n    for count in range(len(bindata)):\n        byte = bindata[count:count+1]\n        b |= struct.unpack('B', byte)[0] << n\n        n += 8\n        if n>13:\n            v = b & 8191\n            if v > 88:\n                b >>= 13\n                n -= 13\n            else:\n                v = b & 16383\n                b >>= 14\n                n -= 14\n            out += base91_alphabet[v % 91] + base91_alphabet[v // 91]\n    if n:\n        out += base91_alphabet[b % 91]\n        if n>7 or b>90:\n            out += base91_alphabet[b // 91]\n    return out", "b91_enctab = [\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '#', '$',\n    '%', '&', '(', ')', '*', '+', ',', '.', '/', ':', ';', '<', '=',\n    '>', '?', '@', '[', ']', '^', '_', '`', '{', '|', '}', '~', '\"'\n]\n\n\ndef b91decode(strng):\n    decode_str = \"\"\n    value = -1\n    seek = 0\n    bynary = 0\n\n    for item in strng:\n        code = b91_enctab.index(item)\n        if value < 0:\n            value = code\n        else:\n            value += code * 91\n            bynary |= value << seek\n\n            if value & 8191 > 88:\n                seek += 13\n            else:\n                seek += 14\n\n            while seek > 7:\n                decode_str += chr(bynary & 255)\n                bynary >>= 8\n                seek -= 8\n            value = -1\n    if value + 1:\n        decode_str += chr((bynary | value << seek) & 255)\n    return decode_str\n\n\ndef b91encode(strng):\n    encode_str = ''\n    bynary = 0\n    seek = 0\n    for symb in strng:\n        bynary |= ord(symb) << seek\n        seek += 8\n        if seek > 13:\n            value = bynary & 8191\n\n            if value <= 88:\n                value = bynary & 16383\n                bynary >>= 14\n                seek -= 14\n            else:\n                bynary >>= 13\n                seek -= 13\n\n            encode_str += b91_enctab[value % 91] + b91_enctab[value // 91]\n\n    if seek != 0:\n        encode_str += b91_enctab[bynary % 91]\n        if seek > 7 or bynary > 90:\n            encode_str += b91_enctab[bynary // 91]\n\n    return encode_str\n\n\na = \"\"\"<txG@<^F#H~H8MxsCYDpde4_SW\"yER~]JwO_!g|OcxW$1^:KNRedl$r6l/:=JsiD+[R]bKVws=Op!v\"?%9|Tn<7@,{q;r>d:sZH)\"\"\"\n\n\nr = \"\"\"4J>StI@i5oLyF.Th)8=+!tB9!#/`l$e$+Kz<}c6~%DsV@(rcJJ>yZ=?Y3JU@7bjoME3J<b5*KN.6xTP6zT1B1Zpc%nVRQxp1|+Zh|4@53d\">!|$7+)vwUl:>cK\"\"\"\n\n\na = '''4J>StI@i5oLyF.Th)8=+!tB9!#/`l$e$+Kz<}c6~%DsV@(rcJJ>yZ=?Y3JU@7bjoME3J<b5*KN.6xTP6zT1B1Zpc%nVRQxp1|+Zh|4@53d\">!|$7+)vwUl:>cK'''\n\nprint((b91encode('<txG@<^F#H~H8MxsCYDpde4_SW\"yER~]JwO_!g|OcxW$1^:KNRedl$r6l/:=JsiD+[R]bKVws=Op!v\"?%9|Tn<7@,{q;r>d:sZH)')))\n\nprint((r == b91encode(a)))\n\n"]
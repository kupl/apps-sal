["#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    a = LI()\n    a.sort()\n    f = [1]*n\n    p = 0\n    ans = 0\n    while p < n:\n        while p < n and not f[p]:\n            p += 1\n        if p == n:\n            break\n        ans += 1\n        for i in range(n):\n            if a[i]%a[p] == 0:\n                f[i] = 0\n    print(ans)\n    return\n\n#B\ndef B():\n    n = I()\n    s = list(map(int, input()))\n    g = LIR(n)\n    ans = sum(s)\n    for t in range(30000):\n        for i in range(n):\n            ai,bi = g[i]\n            if t < bi:\n                continue\n            if (t-bi)%ai == 0:\n                s[i] ^= 1\n        su = sum(s)\n        if ans < su:\n            ans = su\n    print(ans)\n    return\n\n#C\ndef C():\n    t = I()\n    for _ in range(t):\n        n = I()\n        s = list(map(int, input()))\n        mi = [s[-1]]\n        for i in s[:-1][::-1]:\n            mi.append(min(mi[-1],i))\n        mi = mi[::-1]\n        ans = [None]*n\n        for i in range(n):\n            if mi[i] == s[i]:\n                ans[i] = 1\n            else:\n                ans[i] = 2\n        q = [s[i] for i in range(n) if ans[i] > 1]\n        p = [q[i] for i in range(len(q))]\n        p.sort()\n        if p == q:\n            print(*ans,sep = \"\")\n        else:\n            print(\"-\")\n    return\n\n#D\ndef D():\n    def root(x):\n        if x == par[x]:\n            return x\n        par[x] = root(par[x])\n        return par[x]\n\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n    n,k = LI()\n    par = [i for i in range(n)]\n    rank = [0]*n\n    for i in range(k):\n        x,y = LI()\n        x -= 1\n        y -= 1\n        if root(x) != root(y):\n            unite(x,y)\n    size = [0]*n\n    for i in range(n):\n        size[root(i)] += 1\n    ans = 0\n    for i in size:\n        if i > 0:\n            ans += i-1\n    print(k-ans)\n    return\n\n#E\ndef E():\n\n    return\n\n#F\ndef F():\n\n    return\n\n#G\ndef G():\n\n    return\n\n#H\ndef H():\n\n    return\n\n#Solve\ndef __starting_point():\n    D()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\nN, K = list(map(int, input().split()))\nX = [[] for i in range(N)]\nfor i in range(K):\n    x, y = list(map(int, input().split()))\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nmi = 10**6\nmii = 0\nfor i in range(N):\n    if len(X) and (len(X) < mi):\n        mi = len(X)\n        mii = i\n\nY = [(len(X[i]), i) for i in range(N) if len(X[i])]\nY = sorted(Y)\nQ = [y[1] for y in Y]\n\nP = [-1] * N\nD = [0] * N\nans = 0\nwhile Q:\n    i = Q.pop()\n    for a in X[i]:\n        if D[a] == 0 or D[i] == 0:\n            ans += 1\n            D[a] = 1\n            D[i] = 1\n            if a != P[i]:\n                P[a] = i\n                X[a].remove(i)\n                Q.append(a)\nprint(K - ans)\n\n\n", "n, ne = map(int, input().split())\ntr = [[] for __ in range(n)]\nfor __ in range(ne):\n    u, v = map(int, input().split())\n    u -= 1; v -= 1\n    tr[u].append(v)\n    tr[v].append(u)\n\nvisited = [0] * n\nr = 0\nfor i in range(n):\n    if visited[i]: continue \n    q = [i]; visited[i] = 1\n    for u in q:\n        for v in tr[u]:\n            if not visited[v]:\n                visited[v] = 1\n                q.append(v); r += 1\nprint(ne - r)", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nsnack=[tuple(sorted(map(int,input().split()))) for i in range(k)]\nsnack.sort()\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        MIN,MAX=sorted((find(y),find(x)))\n        W[MIN]=W[find(x)]+W[find(y)]\n        W[MAX]=1\n        Group[find(y)]=Group[find(x)]=MIN\n\nW=[1]*(n+1)\n\na,b=snack[0]\nUnion(a,b)\n\n#print(Group,W)\n\nfor i in range(1,k):\n    if snack[i]==snack[i-1]:\n        continue\n\n    a,b=snack[i]\n\n    if find(a)!=find(b):\n        Union(a,b)\n\n    #print(Group,W)\n\nSUM=sum([w-1 for w in W])\n\nprint(k-SUM)\n", "import sys\ninput = sys.stdin.readline\nn, k = list(map(int, input().split()))\n\nclass Union_Find():\n    def __init__(self, num):\n        self.par = [-1]*(num+1)\n        self.siz = [1]*(num+1)\n\n    def same_checker(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            x = self.par[x]\n            return self.find(x)\n\n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.par[rx] < self.par[ry]:\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n            elif self.par[rx] > self.par[ry]:\n                self.par[rx] = ry\n                self.siz[ry] += self.siz[rx]\n            else:\n                self.par[rx] -= 1\n                self.par[ry] = rx\n                self.siz[rx] += self.siz[ry]\n        return\n\n    def size(self, x):\n        return self.siz[self.find(x)]\n\nans = 0\nguest = Union_Find(n)\nfor i in range(k):\n    a, b = list(map(int, input().split()))\n    if guest.same_checker(a, b):\n        ans += 1\n    else:\n        guest.union(a, b)\n\nprint(ans)\n", "n, k = list(map(int, input().split()))\ngraph = {i: set() for i in range(1, n + 1)}\nfor _ in range(k):\n    u, v = list(map(int, input().split()))\n    graph[u].add(v)\n    graph[v].add(u)\nans = 0\nused = [0] * (n + 1)\nfor v in range(1, n + 1):\n    if used[v] == 0:\n        ans += 1\n        S = [v]\n        while S:\n            ver = S.pop()\n            for u in graph[ver]:\n                if used[u] == 0:\n                    S.append(u)\n                    used[u] = 1\nprint(k - n + ans)\n", "class UnionFind:\n    def __init__(self,n):\n        self.par=[i for i in range(n)]\n        self.rank=[0]*n\n        self.size=[1]*n\n    def find(self,x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x]=self.find(self.par[x])\n            return self.par[x]\n    def union(self,x,y):\n        px=self.find(x)\n        py=self.find(y)\n        if px!=py:\n            if self.rank[px]==self.rank[py]:\n                self.rank[px]+=1\n            elif self.rank[px]<self.rank[py]:\n                px,py=py,px\n            self.par[py]=px\n            self.size[px]+=self.size[py]\n    def same_check(self,x,y):\n        return self.find(x)==self.find(y)\n\nimport sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**9)\nn,k=map(int,input().split())\nuf=UnionFind(n)\nEdges=set()\nfor _ in range(k):\n    a,b=map(int,input().split())\n    a-=1; b-=1\n    if a>b:\n        a,b=b,a\n    Edges.add((a,b))\nfor a,b in Edges:\n    uf.union(a,b)\nP=set()\nfor i in range(n):\n    P.add(uf.find(i))\nnum=0\nfor p in P:\n    num+=uf.size[p]-1\nprint(k-num)", "def find(x):\n    x1 = x\n    while p[x] != x:\n        x = p[x]\n    while p[x1] != x1:\n        x2 = p[x1]\n        p[x1] = x\n        x1 = x2\n    return x\n\ninp = lambda : list(map(int, input().split()))\nn, k = inp()\nedges = []\nfor i in range(k):\n    x, y = inp()\n    edges.append([x - 1, y - 1])\n\np = [i for i in range(n)]\nans = 0\nfor i in edges:\n    p1 = find(i[0])\n    p2 = find(i[1])\n    if p1 == p2:\n        ans += 1\n    else:\n        p[p1] = p2\nprint(ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.edge = [0] * n\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            self.edge[x] += 1\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n            self.edge[y] += self.edge[x] + 1\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            self.edge[x] += self.edge[y] + 1\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \nn, k = [int(item) for item in input().split()]\nUF = UnionFind(2 * 10**5)\nfor i in range(k):\n    a, b = [int(item) for item in input().split()]\n    a -= 1; b -= 1\n    UF.union(a, b)\nseen = [False] * (2 * 10**5)\nans = 0\nfor i in range(2 * 10**5):\n    par = UF.find(i)\n    if seen[par]:\n        continue\n    if UF.edge[par] == 0:\n        continue\n    else:\n        ans += UF.edge[par] - (UF.size[par] - 1)\n    seen[par] = True \nprint(ans)", "import sys\nn, k = [int(i) for i in sys.stdin.readline().split()]\ngwl = []\nfor i in range(n+1):\n    gwl.append([])\ndata = []\nfor kk in range(k):\n    d = [int(i) for i in sys.stdin.readline().split()]\n    gwl[d[0]].append(kk)\n    gwl[d[1]].append(kk)\n    data.append(d)\n\none = set()\ntwo = set(range(k))\nsn = [1] * (n+1)\ndoub = [1] * k\nans = 0\n\n\nwhile True:\n    # print(one, two)\n    if one:\n        ans += 1\n        q = one.pop()\n        d = data[q]\n        # print(q, d)\n        if sn[d[0]]:\n            sn[d[0]] = 0\n            for oth in gwl[d[0]]:\n                if doub[oth]:\n                    two.remove(oth)\n                    one.add(oth)\n                    doub[oth] = 0\n                else:\n                    one.discard(oth)\n        else:\n            sn[d[1]] = 0\n            for oth in gwl[d[1]]:\n                if doub[oth]:\n                    two.remove(oth)\n                    one.add(oth)\n                    doub[oth] = 0\n                else:\n                    one.discard(oth)\n    elif two:\n        ans += 1\n        q = two.pop()\n        doub[q] = 0\n        d = data[q]\n        # print(q, d)\n        for w in range(2):\n            sn[d[w]] = 0\n            for oth in gwl[d[w]]:\n                if doub[oth]:\n                    two.remove(oth)\n                    one.add(oth)\n                    doub[oth] = 0\n                else:\n                    one.discard(oth)\n    else:\n        break\nprint(k - ans)\n", "from sys import stdin\nn, k = tuple(int(x) for x in stdin.readline().split())\ndic = {}\nans = 0\nfor i in range(k):\n    a, b = tuple(int(x) for x in stdin.readline().split())\n    a -= 1\n    b -= 1\n    if a not in dic:\n        dic[a] = set((b,))\n    else:\n        dic[a].add(b)\n\n    if b not in dic:\n        dic[b] = set((a,))\n    else:\n        dic[b].add(a)\n\nfor i in range(n):\n    if i in dic:\n        lst = [i]\n        s = set((i,))\n        for src in lst:\n            if src in dic:\n                for dest in dic[src]:\n                    if dest in dic and dest not in s:\n                        lst.append(dest)\n                        s.add(dest)\n                        ans += 1\n                del dic[src]\nprint(k-ans)\n            \n    \n", "n,m=list(map(int,input().split()))\ngr=[set() for i in range(n)]\nfor i in range(m):\n\ta,b=list(map(int,input().split()))\n\tgr[a-1].add(b-1)\n\tgr[b-1].add(a-1)\n\nv=[False for i in range(n)]\nan=0\nfor i in range(n):\n\tif v[i]:continue\n\ts=[i]\n\td=0\n\tv[i]=True\n\twhile s:\n\t\tx=s.pop()\n\t\td+=1\n\t\tfor j in gr[x]:\n\t\t\tif v[j]:continue\n\t\t\tv[j]=True\n\t\t\ts.append(j)\n\n\tan+=d-1\n\nprint(m-an)\n", "from queue import Queue\n\nn, k = map(int, input().split())\na = [tuple(sorted(list(map(lambda x: int(x)-1, input().split())))) for i in range(k)]\na = list(set(a))\na.sort()\nedges = [[] for i in range(n)]\nfor i in a:\n    edges[i[0]].append(i[1])\n    edges[i[1]].append(i[0])\n\nans = 0\nvisited = [False for i in range(n)]\nqueue = Queue(maxsize=n)\nfor j in range(len(a)):\n    if not visited[a[j][0]] and visited[a[j][1]]:\n        visited[a[j][0]] = True\n        s = a[j][0]\n        ans += 1\n\n        queue.put(s)\n        while not queue.empty():\n            s = queue.get()\n            for i in edges[s]:\n                if visited[i] == False:\n                    queue.put(i)\n                    visited[i] = True\n                    ans += 1\n\n    elif visited[a[j][0]] and not visited[a[j][1]]:\n        visited[a[j][1]] = True\n        s = a[j][1]\n        ans += 1\n\n        queue.put(s)\n        while not queue.empty():\n            s = queue.get()\n            for i in edges[s]:\n                if visited[i] == False:\n                    queue.put(i)\n                    visited[i] = True\n                    ans += 1\n    elif not visited[a[j][0]] and not visited[a[j][1]]:\n        visited[a[j][0]] = True\n        visited[a[j][1]] = True\n        ans += 1\n\n        s = a[j][0]\n        queue.put(s)\n        while not queue.empty():\n            s = queue.get()\n            for i in edges[s]:\n                if visited[i] == False:\n                    queue.put(i)\n                    visited[i] = True\n                    ans += 1\n\n        s = a[j][1]\n        queue.put(s)\n        while not queue.empty():\n            s = queue.get()\n            for i in edges[s]:\n                if visited[i] == False:\n                    queue.put(i)\n                    visited[i] = True\n                    ans += 1\nprint(abs(k-ans))", "from collections import deque\n\ndef dfs(s,vis,items):\n  ans=0\n  q=deque()\n  q.append(s)\n  vis[s]=True\n  while len(q)>0:\n    u=q.popleft()\n    for v in items[u]:\n      if not vis[v]:\n        vis[v]=True\n        q.append(v)\n        ans+=1\n  return ans\n\nn,k=map(int,input().split())\narr=[map(int,input().split()) for _ in range(k)]\nitems=[[] for _ in range(n+1)]\nfor x,y in arr:\n  items[x].append(y)\n  items[y].append(x)\nvis=[False for _ in range(n+1)]\nans=k\nfor i,a in enumerate(items[1:]):\n  if not vis[i]: ans-=dfs(i,vis,items)\nprint(ans)", "def find(people,N):\n    dic={}\n    gr=[[] for _ in range(N+1)]\n    count=0\n    for (a,b) in people:\n        a,b=sorted([a,b])\n        if (a,b) in dic:\n            count+=1\n        else:\n            dic[(a,b)]=1\n            gr[a]+=[b]\n            gr[b]+=[a]\n    \n    checked=[0]*(N+1)\n    parent=[-1]*(N+1)\n    for i in range(1,N+1):\n        if checked[i]==0:\n            stack=[i]\n            while stack:\n                node=stack.pop()\n                checked[node]=2\n                for v in gr[node]:\n                    if parent[node]==v:\n                        continue\n                    if checked[v]==2:\n                        continue\n                    if checked[v]==1:\n                        count+=1\n                    else:\n                        stack+=[v]\n                        parent[v]=node\n                        checked[v]=1\n    return count\n\n\n                    \npeople=[]\nn,k=list(map(int,input().strip().split(\" \")))\nfor _ in range(k):\n    a,b=list(map(int,input().strip().split(\" \")))\n    people+=[(a,b)]\nprint(find(people,n))\n    \n    \n    \n", "n,k=list(map(int,input().split()))\nparent=[i for i in range(n)]\nrank=[1 for i in range(n)]\ndef find_parent(u):\n    if parent[u]!=u:\n        parent[u]=find_parent(parent[u])\n    return parent[u]\nfor i in range(k):\n    u,v=list(map(int,input().split()))\n    u=find_parent(u-1)\n    v=find_parent(v-1)\n    if u!=v:\n        parent[u]=v;\n        rank[v]+=rank[u];\nsat=0;\nfor i in range(n):\n    if parent[i]==i:\n        sat+=(rank[i]-1)\nprint(k-sat)\n", "def find_set(v):\n    if v==parent[v]:\n        return v\n    parent[v] = find_set(parent[v])\n    return parent[v]\n\ndef union_sets(x,y):\n    x = find_set(x)\n    y = find_set(y)\n    if x!=y:\n        if rank[x] < rank[y]:\n            x,y = y,x\n        parent[y] = x\n        if rank[x] == rank[y]:\n            rank[x]+=1\n\nn,k = list(map(int,input().split()))\nparent = [0]*n\nrank = [0]*n\nvis = [0]*n\nfor i in range(n):\n    parent[i] = i\nfor _ in range(k):\n    x,y = list(map(int,input().split()))\n    union_sets(x-1,y-1)\n    #print(parent)\n\nc = 0\nfor i in range(n):\n    if parent[i] == i:\n        c+=1\nprint(k-n+c)\n", "\ndef find_parent(u):\n    if par[u]!=u:\n        par[u]=find_parent(par[u])\n    return par[u]\n\nn,k = list(map(int,input().split()))\n\nl = []\n\npar = [0]+[i+1 for i in range(n)]\n\ng = []\nrank = [1]*(n+1)\n\nans = 0\nfor i in range(k):\n    a,b = list(map(int,input().split()))\n    z1,z2 = find_parent(a),find_parent(b)\n    if z1!=z2:\n        par[z1] = z2\n        rank[z2]+=rank[z1]\n        ans+=1\n\nprint(k-ans)\n\n\n\n\n\n\n\n\n\n", "from queue import Queue\n\"\"\"\ndef dfs(graphs, visited, here):\n    if visited[here] == False:\n        visited[here] = True\n        for next in graphs[here]:\n            if visited[next] == False:\n                dfs(graphs, visited, next)\n\ndef dfsAll(graphs, visited, N):\n    ret = 0\n    for here in range(1, N+1):\n        if visited[here] == False:\n            ret += 1\n            dfs(graphs, visited, here)\n    return ret\n\"\"\"\n\"\"\"\ndef bfs(graphs, visited, here):\n    if visited[here] == False:\n        q = Queue()\n        q.put(here)\n        while q.qsize() > 0:\n            here = q.get()\n            for next in graphs[here]:\n                if visited[next] == False:\n                    visited[next] = True\n                    q.put(next)\n\ndef bfsAll(graphs, visited, N):\n    ret = 0\n    for here in range(1, N+1):\n        if visited[here] == False:\n            ret += 1\n            bfs(graphs, visited, here)\n    return ret\n\"\"\"\nN, K = list(map(int,input().strip().split(' ')))\nsnacks = [[] for i in range(N+1)]\nvisited = [False for i in range(N+1)]\nfor k in range(K):\n    a, b = list(map(int,input().strip().split(' ')))\n    snacks[a].append(b)\n    snacks[b].append(a)\nq = Queue()\ncomponents = 0\nfor here in range(1, N+1):\n    if visited[here] == False:\n        visited[here] = True\n        for there in snacks[here]:\n            if visited[there] == False:\n                visited[there] = True\n                q.put(there)\n        while q.qsize() > 0:\n            here = q.get()\n            for there in snacks[here]:\n                if visited[there] == False:\n                    visited[there] = True\n                    q.put(there)\n        components += 1\nret = K - (N - components)\nprint(ret)\n", "import sys\n\ndef main():\n    def input():\n        return sys.stdin.readline()[:-1]\n\n    N, k = list(map(int,input().split()))\n\n    # union-find\n    parent = [k for k in range(N)]\n    def find(x):\n        if parent[x] == x:\n            return x\n        else:\n            parent[x] = find(parent[x])\n            return find(parent[x])\n    def unite(x,y):\n        parent[find(x)] = find(y)\n    ans = 0\n    for q in range(k):\n        x, y = list(map(int,input().split()))\n        if find(x-1) == find(y-1):\n            ans += 1\n        else:\n            unite(x-1,y-1)\n    print(ans)\ndef __starting_point():\n    main()\n\n__starting_point()", "#!python3\n\"\"\"\n11\n 22\n  33\n   66\n    11\n     22\n      33\n       44\n        55\n12\n23\n34\n\"\"\"\n\nfrom collections import deque, Counter\nimport array\nfrom itertools import combinations, permutations\nfrom math import sqrt\nimport unittest\n\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_int_array():\n    return [int(i) for i in input().strip().split(' ')]\n\n######################################################\n\nn, k = read_int_array()\nadj = [[] for _ in range(n)]\nedges = set()\nfor _ in range(k):\n    x, y = read_int_array()\n    x, y = (y, x) if y < x else (x, y)\n    if (x,y) not in edges:\n        edges.add((x, y))\n        adj[x-1] += [y-1]\n        adj[y-1] += [x-1]\n\nmarked = set()\n\ndef bfs(s):\n    tree = []\n    queue = [s]\n    count = 0\n    while queue:\n        v = queue.pop()\n        if v in marked:\n            continue\n        tree += [v]\n        count += 1\n        marked.add(v)\n        for w in adj[v]:\n            if w not in marked:\n                queue += [w]\n    # if len(tree) > 1:\n        # print(' '.join(str(i) for i in tree))\n    return count\n\ncount = 0\nfor v in range(n):\n    if v not in marked:\n        m = bfs(v)\n        count += m - 1\n\nprint(k - count)\n\n\"\"\"\n0 1\n3 2\n0 3\n2 3\n\"\"\"\n\n", "def flood_fill(adj_lists, colors, i, color):\n    q = set()\n    q.add(i)\n    while len(q) > 0:\n        j = q.pop()\n        if colors[j] is None:\n            colors[j] = color\n            for k in adj_lists[j]:\n                q.add(k)\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj_lists = [[] for _ in range(n)]\n    for _ in range(k):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj_lists[a].append(b)\n        adj_lists[b].append(a)\n    colors = [None for _ in range(n)]\n    num_colors = 0\n    for i in range(n):\n        if colors[i] is None:\n            flood_fill(adj_lists, colors, i, num_colors)\n            num_colors += 1\n    print(k - n + num_colors)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from collections import deque\n\n\ndef flood_fill(adj_lists, colors, i, color):\n    q = deque()\n    q.append(i)\n    while len(q) > 0:\n        j = q.pop()\n        if colors[j] is None:\n            colors[j] = color\n            q.extend(adj_lists[j])\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    adj_lists = [[] for _ in range(n)]\n    for _ in range(k):\n        a, b = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        adj_lists[a].append(b)\n        adj_lists[b].append(a)\n    colors = [None for _ in range(n)]\n    num_colors = 0\n    for i in range(n):\n        if colors[i] is None:\n            flood_fill(adj_lists, colors, i, num_colors)\n            num_colors += 1\n    print(k - n + num_colors)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ndef find(u,a):\n    if a[u]!=-1:\n         a[u]=find(a[u],a)\n         return a[u]\n    else:\n        return u\ndef union(a,u,v,ct):\n    x=find(u,a)\n    y=find(v,a)\n    #print(x,y)\n    if x==y:\n        ct+=1\n    else:\n        a[x]=y\n        ct=ct\n    return ct    \n        \nn,k=map(int,input().split())\na=[-1 for i in range(n+1)]\ncount=0\nfor i in range(k):\n    u,v=map(int,input().split())\n    count=union(a,u,v,count)\n    #print(a)\n    \nprint(count)", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import stdin, setrecursionlimit\nsetrecursionlimit(10**7)\n\nimport threading\nthreading.stack_size(2 ** 27)\n\ndef iin(): return int(stdin.readline())\n \n \ndef lin(): return list(map(int, stdin.readline().split()))\n\n# range = xrange\n# input = raw_input\n\n\nclass Disjoint_set:\n    \n    def __init__(sf, n):\n        sf.parent = {i:i for i in range(1,n+1)}\n\n    def union(sf, x, y):\n        sf.link(sf.find_set(x), sf.find_set(y))\n\n    def link(sf, val1, val2):\n        sf.parent[val1]=val2\n\n    def find_set(sf, val):\n        if sf.parent[val] != val:\n            sf.parent[val] = sf.find_set(sf.parent[val])\n            return sf.parent[val]\n        else:\n            return val\n\nfrom collections import defaultdict\ndef main():\n    n,k=lin()\n    \n    a=[lin() for i in range(k)]\n    da=Disjoint_set(n)\n    for i,j in a:\n        da.union(i,j)\n    ch=defaultdict(int)\n    for i in range(1,n+1):\n        #print(\"CNN\",i,da.find_set(da.data[i]).value)\n        ch[da.find_set(i)]+=1\n    ans=0\n    for i in ch:\n        if ch[i]:\n            ans+=ch[i]-1 \n    print(k-ans)\ntry:  \n    def __starting_point():\n        threading.Thread(target=main).start()\nexcept Exception as e: print(e)\n\n__starting_point()"]
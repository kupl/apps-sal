["class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        left, right, mid = set(), set(), set()\n        count = 0\n        for row, col in reservedSeats:\n  \n            # if row in left and row in right and row in mid:\n            #     continue\n            if col < 6 and col > 1:\n                left.add(row)\n            if col < 10 and col > 5:\n                right.add(row)\n            if col < 8 and col > 3:\n                mid.add(row)\n        for i in (left | right | mid):\n            if i not in mid:\n                count += 1\n            elif i not in left or i not in right:\n                count += 1\n        count += 2 * (n - len(left | right | mid))\n        return count", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        masks = {}\n        \n        for row, col in reservedSeats:\n            masks[row] = masks.get(row, 0) + (1 << (10 - col))\n        \n        cnt = 2 * (n - len(masks))\n        \n        dbl_mask1, dbl_mask2 = 0b0111100000, 0b0000011110\n        mdl_mask = 0b0001111000\n        \n        for row, mask in masks.items():\n            cur = max(int((mask & dbl_mask1) == 0) + int((mask & dbl_mask2) == 0),\n                      int((mask & mdl_mask) == 0))\n            cnt += cur\n        return cnt", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        rowHash = dict()\n        numGroups = 0\n        \n        for res in reservedSeats:\n            if res[0] in rowHash:\n                rowHash[res[0]][res[1]] = True\n            else:\n                rowHash[res[0]] = dict()\n                rowHash[res[0]][res[1]] = True\n        \n        for row in rowHash:\n            # print(\\\"curr row \\\" + str(row) + \\\": \\\" + str(rowHash[row]))\n            currGroups = 0\n\n            if 2 not in rowHash[row] and \\\\\n                3 not in rowHash[row] and \\\\\n                4 not in rowHash[row] and \\\\\n                5 not in rowHash[row]:\n                currGroups += 1\n\n            if 6 not in rowHash[row] and \\\\\n                7 not in rowHash[row] and \\\\\n                8 not in rowHash[row] and \\\\\n                9 not in rowHash[row]:\n                currGroups += 1\n\n            if currGroups == 0 and \\\\\n                4 not in rowHash[row] and \\\\\n                5 not in rowHash[row] and \\\\\n                6 not in rowHash[row] and \\\\\n                7 not in rowHash[row]:\n                currGroups += 1\n\n            numGroups += currGroups\n\n            # numGroups += int((nextSeat - currSeat - 1) / 4)\n            # print(\\\"-> num groups:\\\" + str(numGroups))\n        \n        return numGroups + 2 * (n - len(rowHash))\n        \n\\\"\\\"\\\"\nBCR: O(n)\n\nTest cases:\nn = 2, reservedSeats = [[2,1], [1,8], [2,6]]\n- Only care about rows\n- Sort it by row, then by seat # (O(klogk), where k is # of reservations)\n[[1,8], [2,1], [2,6]]\n\n\nn = 3\nrowHash:    [1:[0,8,11], 2:[0, 1, 6, 11]]\nrow:        1\nnumGroups:  0 -> 1 -> 2 -> 3 -> 5\n\nApproach:\n- Brute force - reserve entire matrix 10 x n, populate reservations, iterate over each seat, finding chunks of 4 and marking them as reserved as we count. O(10n + k) where n is num rows and k is num reservations\n- Sorted reservations\n    - For each row without reservations, add int(10 / GROUP_SIZE=4)\n    - For each row with reservations, iterate over each seat and calculate number of seats\n    - Optimizations:\n        - instead of sorting, use a hash map for rows\n        - Need to track rows with and without any reservations (also use a heap?)\n            - Otherwise cost for finding empty rows is O(n). this overhead is acceptable\n\n\\\"\\\"\\\"", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        if not reservedSeats:\n            return 2*n\n        \n        row_reservations = dict()\n        \n        for reservation in reservedSeats:\n            \n            row = reservation[0]\n            seat = reservation[1]\n            \n            if seat==1 or seat==10:\n                continue\n            \n            if row not in row_reservations:\n                row_reservations[row] = {seat}\n            else:\n                row_reservations[row].add(seat)\n            \n        total_families = 2*(n-len(row_reservations))\n    \n        def lesser_two_fam(rev_res):\n            \n            fam_count = 0\n            \n            for row in list(rev_res.values()):\n                pos1=1\n                pos2=1\n                pos3=1\n                \n                if 2 in row or 3 in row:\n                    pos1 = 0\n                if 4 in row or 5 in row:\n                    pos1 = 0\n                    pos2 = 0\n                if 6 in row or 7 in row:\n                    pos2 = 0\n                    pos3 = 0 \n                if 8 in row or 9 in row:\n                    pos3= 0\n                    \n                fam_count+= max(pos1,pos2,pos3)\n                \n            return fam_count\n        total_families += lesser_two_fam(row_reservations)\n        \n        return total_families\n        \n        \n        \n\n            \n        \n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seatOcc = set()\n        rowsOcc = set()\n        for i, j in reservedSeats:\n            seatOcc.add((i-1, j-1))\n            rowsOcc.add(i-1)\n        \n        count = 2 * (n - len(rowsOcc))\n        for i in rowsOcc:\n            left = (i,1) not in seatOcc and (i,2) not in seatOcc and (i,3) not in seatOcc and (i,4) not in seatOcc\n            mid = (i,3) not in seatOcc and (i,4) not in seatOcc and (i,5) not in seatOcc and (i,6) not in seatOcc\n            right = (i,5) not in seatOcc and (i,6) not in seatOcc and (i,7) not in seatOcc and (i,8) not in seatOcc\n            \n            if(left and right):\n                count += 2\n            elif(left or mid or right):\n                count += 1\n        \n        return count\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d={}\n        groups=[{2,3,4,5},{4,5,6,7},{6,7,8,9}]\n        for x,y in reservedSeats:\n            if(x in d):\n                d[x].append(y)\n            else:\n                d[x]=[y]\n        ans=0\n        for v in d.keys():\n            res=set(d[v])\n            c=\\\"\\\"\n            for g in groups:\n                if(not(g&res)):\n                    c+=\\\"1\\\"\n                else:\n                    c+=\\\"0\\\"\n            if(int(c,2)==0):\n                ans+=0\n            elif(int(c,2)==5 or int(c,2)==7):\n                ans+=2\n            else:\n                ans+=1\n        return ans+2*(n-len(d))\n    ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        # fams = n*2\n        res = {}\n        for seat in reservedSeats:\n            row, seat_n = seat\n            if row in res:\n                res[row].append(seat_n)\n            else:\n                res[row] = [seat_n]\n        fams = 0\n        for row in list(res.keys()):\n            if len(res[row]) == 1: #only one seat taken\n                seat_n = res[row][0]\n                if seat_n in [1,10]:\n                    fams += 2\n                else:\n                    fams += 1\n            else: #multiple seats taken \n                curr_row = [True for i in range(10)]\n                for s in res[row]:\n                    curr_row[s-1] = False\n                edges = False\n                if  sum(curr_row[1:5]) == 4:\n                    edges = True\n                    fams += 1\n                if  sum(curr_row[5:9]) == 4:\n                    edges = True\n                    fams += 1\n                if not edges and sum(curr_row[3:7]) == 4:\n                    fams += 1\n        fams += ((n-len(list(res.keys())))*2)\n        return fams\n                \n                \n                \n                \n                    \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        masks = {}\n        \n        for row, col in reservedSeats:\n            masks[row] = masks.get(row, 0) + (1 << (10 - col))\n        \n        cnt = 2 * (n - len(masks))\n        \n        dbl_mask1, dbl_mask2 = 0b0111100000, 0b0000011110\n        mdl_mask = 0b0001111000\n        \n        print(cnt)\n        print({k: f\\\"{v:b}\\\" for k,v in masks.items()})\n        for row, mask in masks.items():\n            cur = max(int((mask & dbl_mask1) == 0) + int((mask & dbl_mask2) == 0),\n                      int((mask & mdl_mask) == 0))\n            cnt += cur\n        return cnt", "'''\nAd-Hoc:\nOnly following configs are possible:\nconfig1 = {2,3,4,5,6,7,8,9} -> 2 groups\nconfig2 = {2,3,4,5} -> 1 group\nconfig3 = {4,5,6,7} -> 1 group\nconfig4 = {6,7,8,9} -> 1 group\n'''\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        rowSeats = defaultdict(set)\n        occupiedRows = set()\n        freeRows = n\n        \n        for seatRow, seatNum in reservedSeats:\n            rowSeats[seatRow].add(seatNum)\n            if seatRow not in occupiedRows:\n                occupiedRows.add(seatRow)\n                freeRows -= 1\n            \n        config1 = {2,3,4,5,6,7,8,9}\n        config2 = {2,3,4,5}\n        config3 = {4,5,6,7}\n        config4 = {6,7,8,9}\n        \n        #print(rowSeats, config1.intersection(rowSeats[1]))\n        res = freeRows*2\n        for row in rowSeats:\n            if len(rowSeats[row]) == 0 or not config1.intersection(rowSeats[row]):\n                res += 2\n            else:\n                res += int(not config2.intersection(rowSeats[row]) or not config3.intersection(rowSeats[row]) or not config4.intersection(rowSeats[row]))\n        \n        return res", "class Solution:\n    # Process only rows that appear in the input, for other rows you can always allocate seats for two families.\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res, lookup = 0, collections.defaultdict(list)\n        for i, j in reservedSeats:\n            lookup[i].append(j - 1)\n        for i in list(lookup.keys()):\n            used = False\n            # available size = 10, starting from 0.\n            available = [1 for j in range(10)]\n            # print('available = {0}, lookup[i] = {1}'.format(available, lookup[i]))\n            for j in lookup[i]:\n                available[j] = 0\n            for start, end in [(1, 5), (5, 9)]:\n                if sum(available[start: end]) == 4:\n                # if all(j not in lookup[i] for j in range(start, end)):\n                    res += 1\n                    used = True\n            if not used and sum(available[3:7]) == 4:\n            # if not used and all(j not in lookup[i] for j in range(4, 8)):\n                res += 1\n        res += 2 * (n - len(lookup))\n        return res\n                    \n                    \n", "class Solution:\n    def maxNumberOfFamilies(self, n, reservedSeats):\n        rows = {}\n        for r, c in reservedSeats:\n            if r not in rows:\n                rows[r] = 0\n            rows[r] ^= (1 << c)\n        res = 0\n        p0 = (1 << 2) ^ (1 << 3) ^ (1 << 4) ^ (1 << 5) \n        p1 = (1 << 6) ^ (1 << 7) ^ (1 << 8) ^ (1 << 9) \n        p2 = (1 << 4) ^ (1 << 5) ^ (1 << 6) ^ (1 << 7) \n        for r in rows:\n            f0 = (rows[r] & p0) == 0\n            f1 = (rows[r] & p1) == 0\n            f2 = (rows[r] & p2) == 0\n            if f0 and f1:\n                res += 2\n            elif f0 or f1 or f2:\n                res += 1\n        return (n - len(rows)) * 2 + res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        self.d1 = self.d2 = self.d3 = 0\n        reservedSeats = sorted(reservedSeats, key=lambda x:x[0])\n        ptr = 0\n        i = 0\n        ans  = 0\n        while i < len(reservedSeats):\n            if reservedSeats[i][0] != ptr:\n                if self.d1 ^ 15 == 15:\n                    ans += 1\n                    if self.d3 ^ 15 == 15:\n                        ans += 1\n                elif self.d2 ^ 15 == 15:\n                    ans += 1\n                elif self.d3 ^ 15 == 15:\n                    ans += 1\n                ans += 2 * (reservedSeats[i][0] - ptr - 1)\n                self.d1 = self.d2 = self.d3 = 0\n                ptr = reservedSeats[i][0]\n            self.seat(reservedSeats[i][1])\n            i += 1\n        \n        if self.d1 ^ 15 == 15:\n            ans += 1\n            if self.d3 ^ 15 == 15:\n                ans += 1\n        elif self.d2 ^ 15 == 15:\n            ans += 1\n        elif self.d3 ^ 15 == 15:\n            ans += 1\n        ans += 2 * (n - ptr)\n        \n        return ans - 2\n                \n    def seat(self, i):\n        if i == 2 or i == 3:\n            self.d1 += 2 ** (i - 2)\n        elif i == 4 or i == 5:\n            self.d1 += 2 ** (i - 2)\n            self.d2 += 2 ** (i - 4)\n        elif i == 6 or i == 7:\n            self.d2 += 2 ** (i - 4)\n            self.d3 += 2 ** (i - 6)\n        elif i == 8 or i == 9:\n            self.d3 += 2 ** (i - 6)\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        processed = {}\n        seatdict = defaultdict(int)\n        for i in reservedSeats:\n            seatdict[i[0] - 1] += 2**i[1]\n        counter = 0\n        for i in seatdict:\n            seatint = seatdict[i]\n            if seatint in processed:\n                counter += processed[seatint]\n                continue\n            else:\n                subcounter = 0\n                if seatint & (2**4 + 2**5 + 2**6 + 2**7) == 0:\n                    subcounter += 1\n                    if seatint & (2**2 + 2**3 + 2**8 + 2**9) == 0:\n                        subcounter += 1\n                else:\n                    if seatint &(2**2 + 2**3 + 2**4 + 2**5) == 0: \n                        subcounter += 1\n                    elif seatint & (2**6 + 2**7 + 2**8 + 2**9) == 0:\n                        subcounter += 1\n                processed[seatint] = subcounter\n                counter += subcounter\n        counter += 2 * (n - len(seatdict))\n        return counter  ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = defaultdict(set)\n        \n        if len(reservedSeats) == 0:\n            return 2*n\n        \n        for seat in reservedSeats:\n            row, col = seat\n            seats[row].add(col)\n            \n\n        \n        result = 0\n        for i in seats.keys():\n            total = 0\n            if len({2,3,4,5}.intersection(seats[i])) == 0:\n                total += 1\n            if len({6,7,8,9}.intersection(seats[i])) == 0:\n                total += 1\n            if len({4,5,6,7}.intersection(seats[i])) == 0 and total == 0:\n                total += 1\n            result += total\n            \n        rowsLeft = n-len(seats)\n        result += 2*rowsLeft\n            \n        return result", "from collections import defaultdict\nclass Solution:\n#     def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n#         reservedSeats.sort()\n#         n_res = len(reservedSeats)\n#         ans = 2 * n\n#         row, res_id = 0, 0\n        \n#         while res_id < n_res:\n#             cur_row = reservedSeats[res_id][0]\n            \n#             rm = set()\n#             while res_id < n_res and reservedSeats[res_id][0] == cur_row:\n#                 j = reservedSeats[res_id][1]\n#                 if j in (2, 3, 4, 5):\n#                     rm.add(0)\n#                 if j in (4, 5, 6, 7):\n#                     rm.add(1)\n#                 if j in (6, 7, 8, 9):\n#                     rm.add(2)\n#                 res_id += 1\n            \n#             if len(rm) == 3:\n#                 ans -= 2\n#             else:\n#                 ans -= 1\n            \n#         return ans\n    \n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = defaultdict(set)\n        \n        for i,j in reservedSeats:\n            if j in [2,3,4,5]:\n                seats[i].add(0)\n            if j in [4,5,6,7]:\n                seats[i].add(1)\n            if j in [6,7,8,9]:\n                seats[i].add(2)\n        \n        res = 2*n\n        for i in seats:\n            if len(seats[i]) == 3:\n                res -= 2\n            else:\n                res -= 1\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = sorted(reservedSeats, key=lambda x: x[0])\n        a = set([2,3])\n        b = set([4,5])\n        c = set([6,7])\n        d = set([8,9])\n        i = 0\n        ans = 0\n        print(seats)\n        seenRows = set()\n        while i < len(seats):\n            row = seats[i][0]\n            r = row\n            seenRows.add(row)\n            j = i\n            left,leftMiddle,rightMiddle,right = True,True,True,True\n            while j < len(seats) and seats[j][0] == row:\n                if seats[j][1] in a:\n                    left = False\n                elif seats[j][1] in b:\n                    leftMiddle = False\n                elif seats[j][1] in c:\n                    rightMiddle = False\n                elif seats[j][1] in d:\n                    right = False\n                j += 1\n            ans += max(int(leftMiddle and rightMiddle), int(left and leftMiddle) + int(right and rightMiddle))\n            i = j\n        return ans + (n - len(seenRows))*2\n            \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d = defaultdict(list)\n        prev = ans = 0\n        for r in reservedSeats:\n            d[r[0]].append(r[1])\n        \n        for k in sorted(d):\n            if k!=prev+1: ans+=2*(k-prev-1)\n            prev=k\n                \n        if prev!=n: ans+=2*(n-prev)\n        \n        def get1row(x):\n            if not x or all(i in [1,10] for i in x):\n                return 2\n            if all(i not in [4,5,6,7] for i in x) or all(i not in [2,3,4,5] for i in x) or all(i not in [6,7,8,9] for i in x):\n                return 1\n            return 0\n        return ans+sum(get1row(d[k]) for k in d)        ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reserved = dict()\n        for r in reservedSeats:\n            reserved[r[0]] = reserved.get(r[0], set())\n            reserved[r[0]].add(r[1])\n            \n        # we can fit 2 groups for all rows with no reservations\n        ans = 2 * (n - len(reserved.keys()))\n        for _, reservations in reserved.items():\n            middle = True\n            if all([seat not in reservations for seat in [2,3,4,5]]):\n                ans += 1\n                middle = False\n            if all([seat not in reservations for seat in [6,7,8,9]]):\n                ans += 1\n                middle = False\n            if middle and all([seat not in reservations for seat in [4,5,6,7]]):\n                ans += 1\n        \n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res, lookup = 0, collections.defaultdict(set)\n        for i, j in reservedSeats:\n            lookup[i].add(j)\n        for i in list(lookup.keys()):\n            used = False\n            for start, end in [(2, 6), (6, 10)]:\n                if all(j not in lookup[i] for j in range(start, end)):\n                    res += 1\n                    used = True\n            if not used and all(j not in lookup[i] for j in range(4, 8)):\n                res += 1\n        res += 2 * (n - len(lookup))\n        return res\n                    \n                    \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        dicts = collections.defaultdict(list)\n        for r in reservedSeats:\n            dicts[r[0]].append(r[1])\n            \n        res = 0 \n        res += 2 * (n - len(dicts))\n\n        for k in list(dicts.keys()):\n            left = True\n            right = True\n            middle = True\n            for seat in dicts[k]:\n                if (2 <= seat and seat <= 3) or (seat >= 4 and seat <=5):\n                    left = False\n                    \n                if seat >= 8 and seat <= 9 or (seat >= 6 and seat <= 7):\n                    right = False\n                    \n                if seat >= 4 and seat <= 7:\n                    middle = False\n\n                \n            if left and right and middle:\n                res += 2\n            elif left or right or middle:\n                res += 1\n                \n        return res\n                    \n                \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        res = 0\n        d = dict()\n        for seat in reservedSeats:\n            if seat[0] in d:\n                d[seat[0]].append(seat[1])\n            else:\n                d[seat[0]] = [seat[1]]\n\n        row = 1\n        for k in sorted(d):\n            if row < k:\n                res += (k - row) * 2\n                row = k + 1\n            elif row == k:\n                row += 1\n            \n            centre_occ = False\n            if not any(s in d[k] for s in (2,3,4,5)):\n                res += 1\n                centre_occ = True\n            if not any(s in d[k] for s in (6,7,8,9)):\n                res += 1\n                centre_occ = True\n            \n            if not centre_occ and not any(s in d[k] for s in (4,5,6,7)):\n                res += 1\n        \n        if row <= n:\n            res += (n+1-row) * 2\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, r: List[List[int]]) -> int:\n        r=sorted(r)\n        l=[0 for i in range(10)]\n        ans=0\n        n_occ=0\n        r.append([0,0])\n        for i in range(0,len(r)):\n            if i==0:\n                l[r[0][1]-1]=1\n            else:\n                if r[i][0]==r[i-1][0]:\n                    l[r[i][1]-1]=1\n                else:\n                    n_occ+=1\n                    if (l[1]==0)&(l[2]==0)&(l[3]==0)&(l[4]==0):\n                        ans+=1\n                        if (l[5]==0)&(l[6]==0)&(l[7]==0)&(l[8]==0):\n                            ans+=1\n                    elif (l[5]==0)&(l[6]==0)&(l[7]==0)&(l[8]==0):\n                        ans+=1\n                    elif (l[3]==0)&(l[4]==0)&(l[5]==0)&(l[6]==0):\n                        ans+=1\n                    #print(r[i],l)\n                    l=[0 for i in range(10)]   \n                    l[r[i][1]-1]=1\n        ans+=(n-n_occ)*2\n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reserved: List[List[int]]) -> int:\n        reserved.sort()\n        result = 2 * n\n        state = [1, 1, 1]\n        for idx, (row, col) in enumerate(reserved):\n            if idx > 0 and row != reserved[idx-1][0]:\n                if not state[0] or not state[2]:\n                    result -= 1\n                    if not any(state):\n                        result -= 1\n                state = [1, 1, 1]                        \n            if col in range(2, 6):\n                state[0] = 0\n            if col in range(4, 8):\n                state[1] = 0\n            if col in range(6, 10):\n                state[2] = 0\n        if not state[0] or not state[2]:\n            result -= 1\n            if not any(state):\n                result -= 1                \n        return result", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        rowseats = defaultdict(list)\n        for s in reservedSeats:\n            rowseats[s[0]].append(s[1])\n            \n        subtract = 0\n        for _, seats in rowseats.items():\n            left = True\n            right = True\n            middle = True\n            for s in seats:\n                if 2 <= s <= 5:\n                    left = False\n                if 4 <= s <= 7:\n                    middle = False\n                if 6 <= s <= 9:\n                    right = False\n            if left and right:\n                subtract += 0\n            elif left or right or middle:\n                subtract += 1\n            else:\n                subtract += 2\n                \n        return n*2 - subtract", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        all_possible_seats = [set([2, 3, 4, 5]), set([4, 5, 6, 7]), set([6, 7, 8, 9])]\n        seat_map = collections.defaultdict(set)\n        for s in reservedSeats:\n            seat_map[s[0]].add(s[1])\n        \n        count = 0\n        for row in seat_map:\n            seats_taken = seat_map[row]\n            for cand in all_possible_seats:\n                if not cand.intersection(seats_taken):\n                    count += 1\n                    seats_taken = cand.union(seats_taken)\n        return count + 2 * (n-len(seat_map.keys()))", "class Solution:\n    # Process only rows that appear in the input, for other rows you can always allocate seats for two families.\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res, lookup = 0, collections.defaultdict(set)\n        for i, j in reservedSeats:\n            lookup[i].add(j)\n        for i in list(lookup.keys()):\n            used = False\n            for start, end in [(2, 6), (6, 10)]:\n                if all(j not in lookup[i] for j in range(start, end)):\n                    res += 1\n                    used = True\n            if not used and all(j not in lookup[i] for j in range(4, 8)):\n                res += 1\n        res += 2 * (n - len(lookup))\n        return res\n                    \n                    \n", "from collections import defaultdict\nfrom bisect import bisect_left\n\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        answer = 0\n        reserved = defaultdict(list)\n        for row, col in reservedSeats:\n            reserved[row].append(col)\n        answer = (n - len(reserved)) * 2\n        possibility = [[2, 5], [4, 7], [6, 9]]\n        for reserved_seats in reserved.values():\n            reserved_seats.sort()\n            result = []\n            for start, end in possibility:\n                idx = bisect_left(reserved_seats, start)\n                result.append(1) if idx == len(reserved_seats) or reserved_seats[idx] > end else result.append(0)\n            answer += max(result[0] + result[2], result[1])\n        return answer", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        dic = {}\n        for row, seat in reservedSeats:\n            if (row - 1) not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                data = lookup[row-1]\n                data[seat-1] = 1\n                lookup[row-1] = data\n        res = 0            \n        print(lookup)\n        for k in lookup:\n            data_tup = tuple(lookup[k])\n            if data_tup not in dic:\n                prev = res\n                first = third = False\n                if lookup[k][1] or lookup[k][2]  or (lookup[k][1] and lookup[k][2]):\n                    if sum(lookup[k][3:7]) == 0 or sum(lookup[k][5:9]) == 0:\n                        res += 1\n                else:\n                    #print(i, res)\n                    if sum(lookup[k][1:5]) == 0:\n                        res += 1\n                        first = True\n                    if sum(lookup[k][5:9]) == 0:\n                        res += 1\n                        third = True\n                    if not first and not third and sum(lookup[k][3:7]) == 0:\n                        res += 1\n                    #print(i, res)\n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n            \n            \n        return res + 2*(n-len(lookup))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        left,right,mid = set(), set(), set()\n        count = 0\n        for row,col in reservedSeats:\n            if row in left and row in right and row in mid:\n                continue\n            if col < 6 and col > 1:\n                left.add(row)\n            if col < 10 and col > 5:\n                right.add(row)\n            if col < 8 and col > 3:\n                mid.add(row)\n        for i in (left|right|mid):\n            if i not in mid:\n                count += 1\n            elif i not in left or i not in right:\n                count += 1\n        count += 2*(n - len(left|right|mid))\n        return count\n                    \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        rows = defaultdict(list)\n        # store in dict a list of seat numbers for each row:\n        for seat in reservedSeats:\n            rows[seat[0]].append(seat[1])\n     \n        for row in rows.keys():\n            seat_nums = rows[row]\n            \n            # if there is only one reserved chair, there are two options:\n            if len(seat_nums) == 1:\n                res = res+2 if seat_nums[0] in [1, 10] else res+1\n    \n            else:\n\\t\\t\\t\\t# help list to find reserved seats in current row:\n                help_list = [0]*10\n                for seat in seat_nums:\n                    help_list[seat-1] = 1\n                \n                res_copy = res\n                if help_list[1:5] == [0,0,0,0]: res+=1\n                    \n                if help_list[5:9] == [0,0,0,0]: res+=1\n\n                if res_copy == res and help_list[3:7] == [0,0,0,0]: res+=1\n\n        # add two to res for each empty row\n        return res + 2 * (n-len(rows.keys()))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d, ans = defaultdict(set), 0\n        for r,c in reservedSeats:\n            d[r].add(c)\n        absent = lambda x,s: not any([x in s for x in range(x,x+4)])\n        for _,v in list(d.items()):\n            ans+= 1+absent(6,v) if absent(2,v) else (absent(4,v) or absent(6,v))\n        ans+=2*(n-len(d))\n        return ans\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        occ = defaultdict(set)\n        for row, col in reservedSeats:\n            occ[row].add(col)\n        \n        ans = 0\n        \n        for row in occ:\n            if all(i not in occ[row] for i in range(2,10)):\n                ans+=2\n            elif all(i not in occ[row] for i in range(2,6)):\n                ans+=1\n            elif all(i not in occ[row] for i in range(6,10)):\n                ans+=1\n            elif all(i not in occ[row] for i in range(4,8)):\n                ans+=1\n        \n        return ans + 2*(n-len(occ))", "class Solution:\n    # def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        # Cinema Seat Allocation 10:24 8/27/20\n        \n    def countAvailableSeats(self, row, taken_slots):\n        if row not in taken_slots:\n            return 2          \n        if not taken_slots[row][0] and not taken_slots[row][1] and not taken_slots[row][2] and not taken_slots[row][3]:\n            return 2\n        elif not taken_slots[row][0] and not taken_slots[row][1]:\n            return 1\n        elif not taken_slots[row][1] and not taken_slots[row][2]:\n            return 1\n        elif not taken_slots[row][2] and not taken_slots[row][3]:\n            return 1                    \n        del taken_slots[row]\n        return 0\n    \n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:            \n        # Sort by row to reduce space compexlity to O(1)\n        reservedSeats.sort(key=lambda s: s[0]) \n        res, prev_row = 0, 1\n        # Allocate four slots - Left (2, 3), Left Center (4, 5), Right Center (6, 7), and Right (8, 9)\n        # and mark those four slots as not taken ([False,False,False,False])\n        taken_slots = collections.defaultdict(lambda: [False,False,False,False])\n        for row, col in reservedSeats:\n            if prev_row != row:\n                res += 2 * (row - prev_row - 1) # Maximum available slots per empty row is 2\n                res += self.countAvailableSeats(prev_row, taken_slots)\n            if col in (2, 3):\n                taken_slots[row][0] = True\n            elif col in (4, 5):\n                taken_slots[row][1] = True\n            elif col in (6, 7):\n                taken_slots[row][2] = True\n            elif col in (8, 9):\n                taken_slots[row][3] = True\n            prev_row = row\n            \n        # Handle the remaining\n        res += 2 * (n - prev_row) # Maximum available slots per empty row is 2\n        res += self.countAvailableSeats(prev_row, taken_slots)\n        return res\n            \n        \n        \n        \n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        left, right, mid = set(), set(), set()\n        count = 0\n        for row, col in reservedSeats:\n            if col < 6 and col > 1:\n                left.add(row)\n            if col < 10 and col > 5:\n                right.add(row)\n            if col < 8 and col > 3:\n                mid.add(row)\n                \n        for i in (left | right | mid):\n            if i not in mid or i not in left or i not in right:\n                count += 1\n\n        count += 2 * (n - len(left | right | mid))\n        return count", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res=0\n        rowDict=collections.defaultdict(int) \n        for r,c in reservedSeats:\n          #row=r[0]\n          #seatNo=r[1]\n            rowDict[r] |=  (1 << (c-1))\n        for row in rowDict.values():\n            #p1=false, p2=false, p3=false\n            print(\\\"row:\\\",row)\n            p1=not(row & int('0111100000',2))\n            p2=not(row & int('0000011110',2))\n            p3=not(row & int('0001111000',2))\n            print(p1,p2,p3)\n            if p1 and p2:\n                res+=2;\n            elif p1 or p2 or p3:\n                res+=1\n            else:\n                continue\n        return res +2 *(n-len(rowDict))", "from collections import defaultdict\nclass Solution:\n        \n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        i=0\n        prev=1\n        res=set()\n        ans=0\n        res = defaultdict(list)\n        for i in range(len(reservedSeats)):\n            res[reservedSeats[i][0]-1].append(reservedSeats[i][1])\n        count_rows=0\n        \n        helper= [0 for i in range(10)]\n        for i in res.keys():\n            count_rows+=1\n            count=0\n            for j in range(10):\n                helper[j]=0\n            for j in res[i]:\n                helper[j-1]=1\n            if helper[1:5] == [0,0,0,0]: count+=1\n            if helper[5:9] == [0,0,0,0]: count+=1\n            if count==0 and helper[3:7] == [0,0,0,0]:\n                count+=1\n            ans+=count\n\n        ans+=(n-count_rows)*2\n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reserved = set()\n        rows = set()\n        for row, col in reservedSeats:\n            reserved.add((row, col))\n            rows.add(row)\n        count = 2 * (n - len(rows))\n        for row in rows:\n            for col in [2, 4, 6]:\n                if (row, col) not in reserved and (row, col+1) not in reserved and (row, col+2) not in reserved and (row, col+3) not in reserved:\n                    #print(reserved, row, col)\n                    reserved.add((row, col))\n                    reserved.add((row, col+1))\n                    reserved.add((row, col+2))\n                    reserved.add((row, col+3))\n                    #print(row, col)\n                    count += 1\n        return count", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reserved_in_row = defaultdict(list)\n        for i, j in reservedSeats:\n            reserved_in_row[i].append(j)\n        res = 2 * (n - len(reserved_in_row))\n        for i in reserved_in_row:\n            sim = [0 for _ in range(10)]\n            for j in reserved_in_row[i]:\n                sim[j - 1] = 1\n            temp_res = res\n            if sim[1: 5] == [0 for _ in range(4)]:\n                res += 1\n            if sim[5: 9] == [0 for _ in range(4)]:\n                res += 1\n            if res == temp_res and sim[3: 7] == [0 for _ in range(4)]:\n                res += 1\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seat_dict = {}\n        all_possible_seats = [set([2, 3, 4, 5]), set([4, 5, 6, 7]), set([6, 7, 8, 9])]\n        \n        for row_seat in reservedSeats:\n            row, seat = row_seat\n            temp = seat_dict.get(row, [1, 1, 1])\n            \n            if sum(temp) == 0:\n                continue\n                \n            if seat in all_possible_seats[0]:\n                temp[0] = 0\n            if seat in all_possible_seats[1]:\n                temp[1] = 0\n            if seat in all_possible_seats[2]:\n                temp[2] = 0\n                \n            seat_dict[row] = temp\n        #print(seat_dict)\n        res = 0\n        for row, situ in list(seat_dict.items()):\n            if situ[1] == 1:\n                if situ[0] and situ[2]:\n                    res += 2\n                else:\n                    res += 1\n            else:\n                if situ[0] or situ[2]:\n                    res +=1\n            \n\n        \n        res += 2*(n-len(list(seat_dict.keys())))\n        return res\n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        hsh = {}\n        \n        for i in reservedSeats:\n            row = i[0] - 1\n            seat = i[1] - 1\n            \n            if row not in hsh:\n                hsh[row] = [True for i in range(10)]\n                \n            hsh[row][seat] = False\n            \n            \n        count = (n - len(hsh))*2\n        for row in hsh:\n            cnt = 0\n            cou = 0\n            for i in range(10):\n                if hsh[row][i]:\n                    \n                    if i in (3,7) and cnt % 2 == 1:\n                        cnt -= 1\n                    cnt += 1\n                    if cnt == 4:\n                        cou += 1\n                        cnt = 0\n                else:\n                    cnt = 0\n            count += cou\n                \n        return count\n                    \n                \n            \n            \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        # Beware of aisle split\n        # Only have a few configurations to sit 4 people in a given row\n        # 1) [4, 5, 6, 7]\n        # 2) [2, 3, 4, 5]\n        # 3) [6, 7, 8, 9]\n        # 4) (2) AND (3)\n        \n        \n        # Brute force: Walk over all the rows O(n^2), with a map of seatOccupied[row][seat_number] = True\n        # Better: Sort reserved seats by row, then seat_number: 2*O(logn)\n        # Best: O(n) make a map, O(n) walk over rows\n        \n        \n        occupied = collections.defaultdict(set)\n        for reservedSeat in reservedSeats:\n            row = reservedSeat[0]\n            seat_number = reservedSeat[1]\n            \n            if seat_number in [4, 5]:\n                # Center, Left are occupied\n                occupied[row].add(\\\"C\\\")\n                occupied[row].add(\\\"L\\\")\n            elif seat_number in [6, 7]:\n                # Center, Right are occupied\n                occupied[row].add(\\\"C\\\")\n                occupied[row].add(\\\"R\\\")\n            elif seat_number in [2, 3]:\n                # Left is occupied\n                occupied[row].add(\\\"L\\\")\n            elif seat_number in [8, 9]:\n                # Right is occupied\n                occupied[row].add(\\\"R\\\")\n        \n        empty_rows: int = n\n        total: int = 0\n        for row in occupied:\n            empty_rows -= 1\n            left = \\\"L\\\" not in occupied[row]\n            right = \\\"R\\\" not in occupied[row]\n            center = \\\"C\\\" not in occupied[row]\n\n            if left and right:\n                total += 2\n            elif left or right or center:\n                total += 1\n        \n        \n        return total + 2 * empty_rows\n                \n            \n            \n        \n        ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        res = 0\n        d = dict()\n        for seat in reservedSeats:\n            if seat[0] in d:\n                d[seat[0]].append(seat[1])\n            else:\n                d[seat[0]] = [seat[1]]\n\n        row = 1\n        for k in sorted(d):\n            print(\\\"row {}, krow {}, v {}, res={}\\\".format(row,k,d[k],res))\n            if row < k:\n                res += (k - row) * 2\n                row = k + 1\n            elif row == k:\n                row += 1\n            \n            centre_occ = False\n            if not any(s in d[k] for s in (2,3,4,5)):\n                res += 1\n                centre_occ = True\n            if not any(s in d[k] for s in (6,7,8,9)):\n                res += 1\n                centre_occ = True\n            \n            if not centre_occ and not any(s in d[k] for s in (4,5,6,7)):\n                res += 1\n        \n        print(\\\"row {}, n= {}, res={}\\\".format(row,n,res))\n        if row <= n:\n            res += (n+1-row) * 2\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        if not reservedSeats:\n            return 2*n\n        \n        row_reservations = dict()\n        \n        for reservation in reservedSeats:\n            \n            row = reservation[0]\n            seat = reservation[1]\n            \n            if seat==1 or seat==10:\n                continue\n            \n            if row not in row_reservations:\n                row_reservations[row] = {seat}\n            else:\n                row_reservations[row].add(seat)\n            \n        total_families = 2*(n-len(row_reservations))\n    \n    \n        for row in list(row_reservations.values()):\n            pos1=1\n            pos2=1\n            pos3=1\n\n            if 2 in row or 3 in row:\n                pos1 = 0\n            if 4 in row or 5 in row:\n                pos1 = 0\n                pos2 = 0\n            if 6 in row or 7 in row:\n                pos2 = 0\n                pos3 = 0 \n            if 8 in row or 9 in row:\n                pos3= 0\n\n            total_families+= max(pos1,pos2,pos3)\n                \n        \n        return total_families\n        \n        \n        \n\n            \n        \n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seat_dict = {}\n        \n        for seat in reservedSeats:\n\n            row, col = seat\n            temp = seat_dict.get(row, set())\n            temp.add(col)\n            seat_dict[row] = temp\n\n                \n        res = 0\n        for row in seat_dict.keys():\n            row_situ = seat_dict[row]\n            if 4 not in row_situ and \\\\\n               5 not in row_situ and \\\\\n               6 not in row_situ and \\\\\n               7 not in row_situ:\n                res += 1\n            \n                if ((2 not in row_situ) and \\\\\n                   (3 not in row_situ) and \\\\\n                   (8 not in row_situ) and \\\\\n                   (9 not in row_situ)):\n                    res += 1\n            else:\n                if ((2 not in row_situ) and \\\\\n                   (3 not in row_situ) and \\\\\n                   (4 not in row_situ) and \\\\\n                   (5 not in row_situ)):\n                    res += 1\n                \n                if ((6 not in row_situ) and \\\\\n                   (7 not in row_situ) and \\\\\n                   (8 not in row_situ) and \\\\\n                   (9 not in row_situ)):\n                    res += 1\n        res += 2*(n-len(seat_dict.keys()))\n        return res\n        \n        ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d, ans = defaultdict(set), 0\n        for r,c in reservedSeats:\n            d[r].add(c)\n        absent = lambda x,s: not any(filter(lambda x: x in s, range(x,x+4)))\n        for _,v in d.items():\n            ans+= 1+absent(6,v) if absent(2,v) else (absent(4,v) or absent(6,v))\n        ans+=2*(n-len(d))\n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        total=2*n\n        \n        dicts={}\n        \n        for k in range(len(reservedSeats)):\n            index=reservedSeats[k][0]\n            val=reservedSeats[k][1]\n            \n            if index not in dicts:\n                dicts[index]=[1,1,1];\n            curr_list=dicts[index]\n            maxim=max(curr_list[0]+curr_list[2],curr_list[1])\n            if val in [2,3,4,5]:\n                curr_list[0]=0\n            if val in [4,5,6,7]:\n                curr_list[1]=0\n            if val in [6,7,8,9]:\n                curr_list[2]=0\n            dicts[index]=curr_list\n            total=total-(maxim-max(curr_list[0]+curr_list[2],curr_list[1]))\n        print(dicts)\n        return total\n        \n", "#\n# @lc app=leetcode id=1386 lang=python3\n#\n# [1386] Cinema Seat Allocation\n#\n# https://leetcode.com/problems/cinema-seat-allocation/description/\n#\n# algorithms\n# Medium (33.70%)\n# Total Accepted:    9K\n# Total Submissions: 25.8K\n# Testcase Example:  '3\\\n[[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]'\n#\n#\n#\n# A cinema  has n  rows of seats, numbered from 1 to n  and there are ten  seats in\n# each row, labelled from 1  to 10  as shown in the figure above.\n#\n# Given the array reservedSeats containing the numbers of seats already\n# reserved, for example, reservedSeats[i] = [3,8]  means the seat located in row\n# 3 and labelled with 8  is already reserved.\n#\n# Return the maximum number of four-person groups  you can assign on the cinema\n# seats. A four-person group  occupies four  adjacent seats in one single row.\n# Seats across an aisle (such as [3,3]  and [3,4]) are not considered to be\n# adjacent, but there is an exceptional case  on which an aisle split  a\n# four-person group, in that case, the aisle split  a four-person group in the\n# middle,  which means to have two people on each side.\n#\n#\n# Example 1:\n#\n#\n#\n#\n# Input: n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]\n# Output: 4\n# Explanation: The figure above shows the optimal allocation for four groups,\n# where seats mark with blue are already reserved and contiguous seats mark\n# with orange are for one group.\n#\n#\n# Example 2:\n#\n#\n# Input: n = 2, reservedSeats = [[2,1],[1,8],[2,6]]\n# Output: 2\n#\n#\n# Example 3:\n#\n#\n# Input: n = 4, reservedSeats = [[4,3],[1,4],[4,6],[1,7]]\n# Output: 4\n#\n#\n#\n# Constraints:\n#\n#\n# 1 <= n <= 10^9\n# 1 <=  reservedSeats.length <= min(10*n, 10^4)\n# reservedSeats[i].length == 2\n# 1  <=  reservedSeats[i][0] <= n\n# 1 <=  reservedSeats[i][1] <= 10\n# All reservedSeats[i] are distinct.\n#\n#\n#\nfrom typing import List\n\n\ndef calculate_groups(reserved_array):\n    \\\"\\\"\\\"\n    >>> calculate_groups([0,0,1,1,0,0,0,0,0,1,0,0])\n    1\n\n    >>> calculate_groups([0,0,0,0,0,0,1,0,0,0,0,0])\n    1\n\n    >>> calculate_groups([0,1,0,0,0,0,0,0,0,0,0,1])\n    2\n\n    \\\"\\\"\\\"\n    center_seats = 0\n    side_seats = 0\n    if sum(reserved_array[4:8]) == 0:\n        center_seats += 1\n    if sum(reserved_array[2:6]) == 0:\n        side_seats += 1\n    if sum(reserved_array[6:10]) == 0:\n        side_seats += 1\n    return max(center_seats, side_seats)\n\nclass Solution:\n    \\\"\\\"\\\"\n    >>> Solution().maxNumberOfFamilies(3, [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]])\n    4\n\n    >>> Solution().maxNumberOfFamilies(2, [[2,1],[1,8],[2,6]])\n    2\n\n    >>> Solution().maxNumberOfFamilies(4, [[4,3],[1,4],[4,6],[1,7]])\n    4\n\n    \\\"\\\"\\\"\n\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n\n        reservedSeats = sorted(reservedSeats, key=lambda i: i[0])\n        counter = 0\n        row = 1\n        reserved = [0] * 11\n        while reservedSeats:\n            item = reservedSeats.pop(0)\n            if item[0] != row:\n                missed_rows = item[0] - row - 1\n                counter += 2 * missed_rows\n                counter += calculate_groups(reserved)\n                row = item[0]\n                reserved = [0] * 11\n                reserved[item[1]] = 1\n            else:\n                reserved[item[1]] = 1\n        counter += calculate_groups(reserved)\n        counter += (n - row) * 2\n        return counter\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        matrix = collections.defaultdict(list)\n        for i in range(len(reservedSeats)):\n            matrix[reservedSeats[i][0]].append(reservedSeats[i][1])\n\n        res = 2 * n\n        for k in matrix:\n            cnt = 0\n            if 2 not in matrix[k] and 3 not in matrix[k] and 4 not in matrix[k] and 5 not in matrix[k]:\n                cnt += 1\n            if 6 not in matrix[k] and 7 not in matrix[k] and 8 not in matrix[k] and 9 not in matrix[k]:\n                cnt += 1\n            if 4 not in matrix[k] and 5 not in matrix[k] and 6 not in matrix[k] and 7 not in matrix[k] and cnt == 0:\n                cnt += 1\n            res += (cnt - 2)\n\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n       \n        g = defaultdict(int)\n        for r, s in reservedSeats: g[r] |= {0: 0, 1: 4, 2: 5, 3: 3, 4: 2, 5: 0}[s >> 1]\n        return sum(2 if s == 0 else 1 if s < 7 else 0 for r, s in g.items()) + (n - len(g)) * 2", "import collections\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        # lst = [[] for i in range(n)]\n        lst = collections.defaultdict(list)\n        \n        for r, c in reservedSeats:\n            lst[r].append(c)\n            # lst[r-1].append(c)\n        ret = n * 2\n        for r in lst:\n            flag1 = False\n            flag2 = False\n            flag3 = False\n            for c in lst[r]:\n                if 2 <= c <= 5:\n                    flag1 = True\n                if 6 <= c <= 9:\n                    flag2 = True\n                if 4 <= c <= 7:\n                    flag3 = True\n            if flag1:\n                ret -= 1\n            if flag2:\n                ret -= 1\n            if (flag1 and flag2) and not flag3:\n                ret += 1\n        return ret\n        # print(lst)\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reserved = set(tuple(spot) for spot in reservedSeats)\n        reserved_rows = set(spot[0] for spot in reservedSeats)\n        res = 0\n        for row in reserved_rows:\n            first = False\n            second = False\n            third = False\n            \n            if all((row, col) not in reserved for col in range(2, 6)):\n                first = True\n            if all((row, col) not in reserved for col in range(4, 8)):\n                second = True\n            if all((row, col) not in reserved for col in range(6, 10)):\n                third = True\n\n            if first and second and third:\n                res += 2\n            elif first or second or third:\n                res += 1\n        \n        return res + 2*(n - len(reserved_rows))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        dic = {}\n        for row, seat in reservedSeats:\n            if row - 1 not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                lookup[row-1][seat-1] = 1\n    \n        res = 0 \n        four_person = [0,0,0,0]\n        for k in lookup:\n            data_tup = tuple(lookup[k])\n            if data_tup not in dic:\n                prev = res\n                first = third = False\n                if lookup[k][1] or lookup[k][2] :\n                    if lookup[k][3:7] ==  four_person or lookup[k][5:9] ==  four_person:\n                        res += 1\n                else:\n                    if lookup[k][1:5] == four_person:\n                        res += 1\n                        first = True\n                    if lookup[k][5:9] == four_person:\n                        res += 1\n                        third = True\n                    if not first and not third and lookup[k][3:7] == four_person:\n                        res += 1\n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n            \n            \n        return res + 2*(n-len(lookup))", "import numpy as np\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d, ans = defaultdict(set), 0\n        for r,c in reservedSeats:\n            d[r].add(c)\n        absent = lambda x,s: not any(filter(lambda x: x in s, range(x,x+4)))\n        for _,v in d.items():\n            ans+= 1+absent(6,v) if absent(2,v) else (absent(4,v) or absent(6,v))\n        ans+=2*(n-len(d))\n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        from collections import defaultdict\n        taken_seats = defaultdict(int)\n        for row, col in reservedSeats:\n            taken_seats[row] = taken_seats[row] | (1 << (col - 1))\n        res = 0\n        for seat in taken_seats.values():\n            cnt = 0\n            if (seat & int('0111100000', 2)) == 0:\n                cnt += 1\n            if (seat & int('0000011110', 2)) == 0:\n                cnt += 1\n            # cnt==0 means 2345 and 4567 is not taken respectively\n            # and \n            if (seat & int('0001111000', 2)) == 0 and cnt == 0:\n                cnt = 1\n            res += cnt\n        return 2 * (n - len(taken_seats)) + res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seated=defaultdict(set)\n        for record in reservedSeats:\n            seated.setdefault(record[0], set()).add(record[1])\n        ans=0\n        ans+=(n-len(seated))*2\n        for i in seated:\n            currentRow=seated[i]\n            emptyLeft=2 not in currentRow and 3 not in currentRow\n            emptyMidLeft=4 not in currentRow and 5 not in currentRow\n            emptyMidRight=6 not in currentRow and 7 not in currentRow\n            emptyRight=8 not in currentRow and 9 not in currentRow\n            if(emptyLeft and emptyMidLeft and emptyMidRight and emptyRight):\n                ans+=2\n            elif(emptyLeft and emptyMidLeft):\n                ans+=1\n            elif(emptyRight and emptyMidRight):\n                ans+=1\n            elif(emptyMidLeft and emptyMidRight):\n                ans+=1\n        return ans\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        rows = defaultdict(list)\n        #rows = {}\n        for seat in reservedSeats:\n            #if not rows.get(seat[0]):\n                #rows[seat[0]] = [0]*10\n            #rows[seat[0]][seat[1]-1] = 1\n            rows[seat[0]].append(seat[1])\n        print(rows)\n        #for i in range(1, n+1):\n        for row in list(rows.keys()):\n            seat_nums = rows[row]\n            #seat_nums = rows.get(i)\n            #if not seat_nums:\n                #print(f\\\"nothing in row {i}\\\")\n            #    res+=2\n            if len(seat_nums) == 1:\n                #if seat_nums[0] == 1 or seat_nums[0] == 10:\n                #    res+=2\n                #else:\n                #    res+=1\n                    #print(\\\"here\\\")\n                res = res+2 if seat_nums[0] in [1, 10] else res+1\n    \n            else:\n                help_list = [0]*10\n                for seat in seat_nums:\n                    help_list[seat-1] = 1\n                \n                res_copy = res\n                if help_list[1:5] == [0,0,0,0]: res+=1\n                    \n                if help_list[5:9] == [0,0,0,0]: res+=1\n\n                if res_copy == res and help_list[3:7] == [0,0,0,0]: res+=1\n\n                    \n                \n        return res + 2*(n-len(list(rows.keys())))\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        rows = defaultdict(list)\n        # store in dict a list of seat numbers for each row:\n        for seat in reservedSeats:\n            rows[seat[0]].append(seat[1])\n     \n        for row in list(rows.keys()):\n            seat_nums = rows[row]\n            \n            # if there is only one reserved chair, there are two options:\n            if len(seat_nums) == 1:\n                res = res+2 if seat_nums[0] in [1, 10] else res+1\n    \n            else:\n                help_list = [0]*10\n                for seat in seat_nums:\n                    help_list[seat-1] = 1\n                \n                res_copy = res\n                if help_list[1:5] == [0,0,0,0]: res+=1\n                    \n                if help_list[5:9] == [0,0,0,0]: res+=1\n\n                if res_copy == res and help_list[3:7] == [0,0,0,0]: res+=1\n\n        # add two to res for each empty row\n        return res + 2 * (n-len(list(rows.keys())))\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        d = defaultdict(set)\n        for x,y in reservedSeats: \n            d[x-1].add(y-1)\n        for r in d.keys():\n            if all(x not in d[r] for x in [1,2,3,4]):\n                res += 1\n                for x in [1,2,3,4]: d[r].add(x);\n            if all(x not in d[r] for x in [3,4,5,6]):\n                res += 1\n                for x in [3,4,5,6]: d[r].add(x);\n            if all(x not in d[r] for x in [5,6,7,8]):\n                res += 1\n                for x in [5,6,7,8]: d[r].add(x);\n        return res + 2 * (n - len(d.keys()))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        dic = {}\n        for row, seat in reservedSeats:\n            if row - 1 not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                lookup[row-1][seat-1] = 1\n    \n        res = 0 \n        four_person = [0,0,0,0]\n        for data in lookup.values():\n            data_tup = tuple(data)\n            if data_tup not in dic:\n                prev = res\n                if data[1:5] == four_person:\n                    res += 1\n                    if data[5:9] == four_person:\n                        res += 1\n                elif data[3:7] == four_person or data[5:9] == four_person:\n                        res += 1 \n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n                \n        return res + 2*(n-len(lookup))", "class Solution(object):\n    def maxNumberOfFamilies(self, n, reservedSeats):\n\n        result = 2 * n\n        hashtable = {}\n        for seat in reservedSeats:\n            if seat[0] not in hashtable:\n                hashtable[seat[0]] = {seat[1]}\n            else:\n                hashtable[seat[0]].add(seat[1])\n        for item in hashtable:\n            counter = 0\n            if 2 not in hashtable[item] and 3 not in hashtable[item] and 4 not in hashtable[item] and 5 not in \\\\\n                    hashtable[item]:\n                counter += 1\n            if 6 not in hashtable[item] and 7 not in hashtable[item] and 8 not in hashtable[item] and 9 not in \\\\\n                    hashtable[item]:\n                counter += 1\n            if 4 not in hashtable[item] and 5 not in hashtable[item] and 6 not in hashtable[item] and 7 not in \\\\\n                    hashtable[item] and counter == 0:\n                counter += 1\n            result += (counter - 2)\n        return result\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        seats = collections.defaultdict(int)\n        for r, seat in reservedSeats:\n            seats[r] |= (1 << (seat-1))\n        for reserved in list(seats.values()):\n            curr = 0\n            if (reserved & int('0111100000',2))==0:\n                curr += 1\n            if (reserved & int('0000011110',2))==0:\n                curr += 1\n            if (reserved & int('0001111000',2))==0 and curr == 0:\n                curr += 1\n            res += curr\n        return res + 2*(n-len(seats))\n", "from itertools import groupby\nfrom re import finditer\n\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        ans = 2*n\n        reservedSeats.sort()\n        rows = groupby(reservedSeats, key=lambda x: x[0])\n        for r, c in rows:\n            row = ['O']*10\n            for _, col in c:\n                row[col-1] = 'X'\n            row = ''.join(row)\n            idx = {f.start() for f in finditer('(?=OOOO)', row)}\n            if not idx:\n                ans -= 2\n            elif 1 in idx and 5 in idx:\n                continue\n            elif 1 in idx or 3 in idx or 5 in idx:\n                ans -= 1\n            else:\n                ans -= 2\n        return ans\n    \\\"\\\"\\\"\n    OOO OOOO OOO\n    OOO OOOO OOO\n    \\\"\\\"\\\"", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \\\"\\\"\\\"\n        Runtime: O(m) where m is length of reservedSeats, Space: O(m)\n        \\\"\\\"\\\"\n        reserved = dict()\n        for seat in reservedSeats:\n            row, col = seat\n            if row not in reserved:\n                reserved[row] = {col}\n            else:\n                reserved[row].add(col)\n        \n        groups = 2 * n\n        for _, cols in reserved.items():\n            sections = 0\n            if not any(col in cols for col in (2, 3, 4, 5)):\n                sections += 1\n            if not any(col in cols for col in (6, 7, 8, 9)):\n                sections += 1\n            # check if sections == 0 to avoid double counting where the sections overlap\n            if sections == 0 and not any(col in cols for col in (4, 5, 6, 7)):\n                sections += 1\n            groups += sections - 2\n        return groups\n        ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        rows = collections.defaultdict(lambda: [])\n        for row, col in reservedSeats:\n            rows[row].append(col)\n        ans = (n-len(rows))*2\n        \n        def solveRow(row, pos, memo):\n            if pos >= 7:\n                return 0\n            elif pos in memo:\n                return memo[pos]\n            \n            ret = 0\n            if pos in (0, 2, 4, 6) or sum(row[pos: pos+4]) > 0:\n                ret = solveRow(row, pos+1, memo)\n            else:\n                ret = max(solveRow(row, pos+1, memo), 1+solveRow(row, pos+4, memo))\n            memo[pos] = ret\n            return ret\n        \n        for row_id in rows:\n            row = [0]*10\n            for col in rows[row_id]:\n                row[col-1] = 1\n            ans += solveRow(row, 0, {})\n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        \n        d = {}\n        \n        for r,c in reservedSeats: #O(M)\n            if r not in d:\n                d[r] = [1,1,1]\n                \n            if 2<= c <=5:\n                d[r][0] = 0\n            if 4 <= c <=7:\n                d[r][1] = 0  \n            if 6<= c<=9:\n                d[r][2] = 0\n        \n        total = n*2\n        res = 0\n        for r in d:\n            if sum(d[r])==0:  \n                res += 2\n            elif sum(d[r])<3:\n                res += 1\n                \n        return total - res\n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        dic = {}\n        for row, seat in reservedSeats:\n            if row - 1 not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                lookup[row-1][seat-1] = 1\n    \n        res = 0           \n        for k in lookup:\n            data_tup = tuple(lookup[k])\n            if data_tup not in dic:\n                prev = res\n                first = third = False\n                if lookup[k][1] or lookup[k][2]  or (lookup[k][1] and lookup[k][2]):\n                    if sum(lookup[k][3:7]) == 0 or sum(lookup[k][5:9]) == 0:\n                        res += 1\n                else:\n                    if sum(lookup[k][1:5]) == 0:\n                        res += 1\n                        first = True\n                    if sum(lookup[k][5:9]) == 0:\n                        res += 1\n                        third = True\n                    if not first and not third and sum(lookup[k][3:7]) == 0:\n                        res += 1\n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n            \n            \n        return res + 2*(n-len(lookup))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        def isOpen(row, seat):\n            for i in range(seat,seat+4):\n                if i in grid[row]:\n                    return False\n            return True\n        def isClosed(row,seat):\n            return not isOpen(row,seat)\n            \n            \n        grid = {}\n        \n        for row,seat in reservedSeats:\n            if row not in grid: grid[row] = {}\n            grid[row][seat] = True\n            \n        result = n*2\n        for i in grid:\n            left = isOpen(i,2)\n            middle = isOpen(i,4)\n            right = isOpen(i,6)\n            \n            \n            if middle:\n                if left and right:\n                    pass\n                else:\n                    result -= 1\n            else:\n                if not left:\n                    result -= 1\n                if not right:\n                    result -= 1\n            \n            #print(\\\"\\\\tleft=%s middle=%s right=%s result=%s\\\" % (left,middle,right,result))\n            \n            \n        return result", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        BOTH, LEFT, RIGHT, MIDDLE = 0, 1, 2, 3\n        required = [\n            [2, 3, 4, 5, 6, 7, 8, 9], # BOTH\n            [2, 3, 4, 5], # LEFT\n            [6, 7, 8, 9], # RIGHT\n            [4, 5, 6, 7] # MIDDLE\n        ]\n        fit = [2, 1, 1, 1]\n        res = 0\n        d = defaultdict(list)\n        for i, j in reservedSeats:\n            d[i].append(j)\n        res = (n - len(d)) * 2 # 2 for each empty row\n        for row in d.values():\n            for k, needed in enumerate(required):\n                if all(j not in row for j in needed):\n                    res += fit[k]\n                    break\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = collections.defaultdict(int)\n        for row, col in reservedSeats:\n            seats[row] = seats[row] | (1 << (col - 1))\n\n        res = 2 * n\n        for reserved in seats.values():\n            cnt = 0\n            cnt += (reserved & int('0111100000', 2)) == 0\n            cnt += (reserved & int('0000011110', 2)) == 0\n            cnt += (reserved & int('0001111000', 2)) == 0 and cnt == 0\n            res += (cnt - 2)\n        return res", "from collections import defaultdict\n\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        d = defaultdict(set)\n        for r in reservedSeats:\n            d[r[0] - 1].add(r[1] - 1)\n        ans = 0\n        for i in list(d.keys()):\n            j = 0\n            while j < 7:\n                if j in [1, 3, 5]:\n                    if j not in d[i] and j + 1 not in d[i] and j + 2 not in d[i] and j + 3 not in d[i]:\n                        ans += 1\n                        j += 4\n                        continue\n                j += 1\n        return ans + 2 * (n - len(list(d.keys())))\n            \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seatmap = collections.defaultdict(list)\n        \n        for row in reservedSeats:\n            seatmap[row[0]].append(row[1])\n        \n        ans = 0\n        for row in list(seatmap.keys()):\n            row_arrange = [0] * 10\n            for each in seatmap[row]:\n                row_arrange[each-1] = 1\n            print(row_arrange)\n            \n            if row_arrange[1:5] == [0, 0, 0, 0]:\n                ans += 1\n            if row_arrange[5:9] == [0, 0, 0, 0]:\n                ans += 1\n            if row_arrange[3:7] == [0, 0, 0, 0] and row_arrange[1:3] != [0, 0] and row_arrange[7:9] != [0, 0]:\n                ans += 1\n            print(ans)\n        \n        return ans + (n - len(seatmap))*2\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        dic = {}\n        for row, seat in reservedSeats:\n            if (row - 1) not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                data = lookup[row-1]\n                data[seat-1] = 1\n                lookup[row-1] = data\n        res = 0           \n        for k in lookup:\n            data_tup = tuple(lookup[k])\n            if data_tup not in dic:\n                prev = res\n                first = third = False\n                if lookup[k][1] or lookup[k][2]  or (lookup[k][1] and lookup[k][2]):\n                    if sum(lookup[k][3:7]) == 0 or sum(lookup[k][5:9]) == 0:\n                        res += 1\n                else:\n                    if sum(lookup[k][1:5]) == 0:\n                        res += 1\n                        first = True\n                    if sum(lookup[k][5:9]) == 0:\n                        res += 1\n                        third = True\n                    if not first and not third and sum(lookup[k][3:7]) == 0:\n                        res += 1\n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n            \n            \n        return res + 2*(n-len(lookup))", "from collections import defaultdict\n\nclass Solution:\n    def maxNumberOfFamilies(self, n: int, R: List[List[int]]) -> int:\n        \n        dic = defaultdict(set)\n        \n        for x, y in R:\n            dic[x].add(y)\n\n        res = 2 * ( n - len(dic) )\n        \n        for v in list(dic.values()):\n            if all(j not in v for j in (2,3,4,5)):\n                res += 1 + all(j not in v for j in (6,7,8,9))\n            else:\n                res += (6 not in v and 7 not in v) and (4 not in v and 5 not in v or 8 not in v and 9 not in v)\n        \n        return res\n            \n        \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        row_reservations = dict()\n        for reserve in reservedSeats:\n            row, col = reserve\n            if row not in row_reservations:\n                row_reservations[row] = set()\n            row_reservations[row].add(col)\n        \n        total = 0\n        left = set([2,3,4,5])\n        right = set([6,7,8,9])\n        center = set([4,5,6,7])\n        for row in row_reservations:\n            r = row_reservations[row]\n            \n            if (left & r and right & r and center & r):\n                n -= 1\n                continue\n            \n            if not left & r and not right & r:\n                total += 2\n            else:\n                total += 1\n            n -= 1\n        \n        return total + (n * 2)", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        h=defaultdict(list)\n        res=0\n        for k in reservedSeats:\n            h[k[0]].append(k[1])\n        for i in list(h.keys()):\n            row=h[i]\n            if len(row)==1:\n                if row[0]==1 or row[0]==10:\n                    res+=2\n                else:\n                    res+=1\n            else:\n                seats=[0]*10\n                for i in row:\n                    seats[i-1]=1\n                res_copy=res    \n                if seats[1:5]==[0,0,0,0]: res+=1\n                if seats[5:9]==[0,0,0,0]: res+=1\n                if res_copy==res and seats[3:7]==[0,0,0,0]: res+=1\n        return res+2*(n-len(list(h.keys())))\n        \n                    \n                \n            \n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seatmap = collections.defaultdict(list)\n        \n        for row in reservedSeats:\n            seatmap[row[0]].append(row[1])\n        \n        ans = 0\n        for row in list(seatmap.keys()):\n            \n            if len(seatmap[row]) == 1:\n                if seatmap[row][0] == 1 or seatmap[row][0] == 10:\n                    ans += 2\n                else:\n                    ans += 1\n            else:\n                row_arrange = [0] * 10\n                for each in seatmap[row]:\n                    row_arrange[each-1] = 1\n\n                if row_arrange[1:5] == [0, 0, 0, 0]:\n                    ans += 1\n                if row_arrange[5:9] == [0, 0, 0, 0]:\n                    ans += 1\n                if row_arrange[3:7] == [0, 0, 0, 0] and row_arrange[1:3] != [0, 0] and row_arrange[7:9] != [0, 0]:\n                    ans += 1\n        \n        return ans + (n - len(seatmap))*2\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seats = defaultdict(set)\n        for i, j in reservedSeats:\n            if j in {2, 3, 4, 5}:\n                seats[i].add(0)\n            if j in {4, 5, 6, 7}:\n                seats[i].add(1)\n            if j in {6, 7, 8, 9}:\n                seats[i].add(2)\n        # For n rows, the maximum number of families that can sit together are 2*n.\n        result = 2 * n\n        for i in seats:\n            if len(seats[i]) == 3:\n                #  if all three positions in the row was blocked, the total cnt should be reduced by 2\n                result -= 2\n            else:\n                # If less than 3 positions was blocked, the total cnt should -1.\n                result -= 1\n        return result\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        for row, seat in reservedSeats:\n            if row - 1 not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                lookup[row-1][seat-1] = 1\n    \n        res , dic = 0, {}\n        four_person = (0,0,0,0)\n        for data in lookup.values():\n            data_tup = tuple(data)\n            if data_tup not in dic:\n                prev = res\n                if data_tup[1:5] == four_person:\n                    res += 1\n                    if data_tup[5:9] == four_person:\n                        res += 1\n                elif data_tup[3:7] == four_person or data_tup[5:9] == four_person:\n                        res += 1 \n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n                \n        return res + 2*(n-len(lookup))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        ht = {}\n        \n        for i, j in reservedSeats:\n            if not (i-1) in ht:\n                ht[i-1] = [0] * 10\n            ht[i-1][j-1] = 1\n        \n        ans = (n-len(ht)) * 2\n        \n        for i in ht:\n            inc = 0\n            if ht[i][1:5] == [0, 0, 0, 0]:\n                inc += 1\n            if ht[i][5:9] == [0, 0, 0, 0]:\n                inc += 1\n            if inc >= 1:\n                ans += inc\n                continue\n            if ht[i][3:7] == [0, 0, 0, 0]:\n                ans += 1\n        \n        return ans", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reservedSeats.sort()\n        matrix = {}\n        for i in range(len(reservedSeats)):\n            k = reservedSeats[i][0]\n            if k in matrix:\n                matrix[k].append(reservedSeats[i][1])\n            else:\n                matrix[k] = [reservedSeats[i][1]]\n\n        res = 2 * n\n        for k, v in matrix.items():\n            left_group = mid_group = right_group = True\n            if 2 in v or 3 in v:\n                left_group = False\n\n            if 4 in v or 5 in v:\n                left_group = False\n                mid_group = False\n\n            if 6 in v or 7 in v:\n                mid_group = False\n                right_group = False\n\n            if 8 in v or 9 in v:\n                right_group = False\n\n            if left_group or right_group:\n                mid_group = False\n\n            res -= 2 - (left_group + mid_group + right_group)\n\n        return res", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        seatmap = collections.defaultdict(list)\n        \n        for row in reservedSeats:\n            seatmap[row[0]].append(row[1])\n        \n        ans = 0\n        for row in list(seatmap.keys()):\n            \n            # if len(seatmap[row]) == 1:\n            #     if seatmap[row][0] == 1 or seatmap[row][0] == 10:\n            #         ans += 2\n            #     else:\n            #         ans += 1\n            # else:\n            row_arrange = [0] * 10\n            for each in seatmap[row]:\n                row_arrange[each-1] = 1\n\n            if row_arrange[1:5] == [0, 0, 0, 0]:\n                ans += 1\n            if row_arrange[5:9] == [0, 0, 0, 0]:\n                ans += 1\n            if row_arrange[3:7] == [0, 0, 0, 0] and row_arrange[1:3] != [0, 0] and row_arrange[7:9] != [0, 0]:\n                ans += 1\n        \n        return ans + (n - len(seatmap))*2\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        res = 0\n        rows = defaultdict(list)\n        # store in dict a list of seat numbers for each row:\n        for seat in reservedSeats:\n            rows[seat[0]].append(seat[1])\n     \n        for row in list(rows.keys()):\n            seat_nums = rows[row]\n            \n            # if there is only one reserved chair, there are two options:\n            if len(seat_nums) == 1:\n                res = res+2 if seat_nums[0] in [1, 10] else res+1\n    \n            else:\n                # help list to find reserved seats in current row:\n                help_list = [0]*10\n                for seat in seat_nums:\n                    help_list[seat-1] = 1\n                \n                res_copy = res\n                if help_list[1:5] == [0,0,0,0]: res+=1\n                    \n                if help_list[5:9] == [0,0,0,0]: res+=1\n\n                if res_copy == res and help_list[3:7] == [0,0,0,0]: res+=1\n\n        # add two to res for each empty row\n        return res + 2 * (n-len(list(rows.keys())))\n", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        lookup = collections.defaultdict(list)\n        for row, seat in reservedSeats:\n            if row - 1 not in lookup:\n                data = [0] * 10\n                data[seat-1] = 1\n                lookup[row-1] = data\n            else:\n                lookup[row-1][seat-1] = 1\n    \n        res , dic = 0, {}\n        four_person = [0,0,0,0]\n        for data in lookup.values():\n            data_tup = tuple(data)\n            if data_tup not in dic:\n                prev = res\n                if data[1:5] == four_person:\n                    res += 1\n                    if data[5:9] == four_person:\n                        res += 1\n                elif data[3:7] == four_person or data[5:9] == four_person:\n                        res += 1 \n                dic[data_tup] = res - prev\n            else:\n                res += dic[data_tup]\n                \n        return res + 2*(n-len(lookup))", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reserved: List[List[int]]) -> int:\n        def getGroups(row):\n            res = 0\n            for group in [left, right]:\n                if group.isdisjoint(d[row]): res += 1\n            if res >= 1: return res \n\n            if middle.isdisjoint(d[row]): res += 1 \n            return res\n\n        ans = 0\n        d = defaultdict(set)\n        left, middle, right = set([2,3,4,5]), set([4,5,6,7]), set([6,7,8,9])\n\n        for row, col in reserved: d[row].add(col)\n        for row in d: ans += getGroups(row)\n        m = len(d)\n\n        return ans+(n-m)*2 ", "class Solution:\n    def maxNumberOfFamilies(self, n: int, reservedSeats: List[List[int]]) -> int:\n        reservedSeats.sort()\n        count = 2 * (reservedSeats[0][0] - 1)\n        row_start = 0\n        while row_start < len(reservedSeats):\n            row_end = row_start\n            indices = []\n            while row_end < len(reservedSeats) and reservedSeats[row_end][0] == reservedSeats[row_start][0]:\n                indices.append(reservedSeats[row_end][1])\n                row_end += 1\n            if len(indices) == 1:\n                if indices[0] == 1 or indices[0] == 10:\n                    count += 1\n                count += 1\n            elif len(indices) == 2:\n                if indices[0] == 1 and indices[1] == 10:\n                    count += 2\n                elif (all(i not in indices for i in [2, 3, 4, 5]) or\n                      all(i not in indices for i in [4, 5, 6, 7]) or\n                      all(i not in indices for i in [6, 7, 8, 9])):\n                    count += 1\n            elif len(indices) <= 6:\n                if (all(i not in indices for i in [2, 3, 4, 5]) or\n                    all(i not in indices for i in [4, 5, 6, 7]) or\n                    all(i not in indices for i in [6, 7, 8, 9])):\n                    count += 1\n            row_start = row_end\n            next_row = reservedSeats[row_start][0] if row_start < len(reservedSeats) else n + 1\n            count += 2 * (next_row - reservedSeats[row_end - 1][0] - 1)\n        return count"]
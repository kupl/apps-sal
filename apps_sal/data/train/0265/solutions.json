["class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sum_set = set()\n        sum_set.add(0)\n        temp = 0\n        count = 0\n        for num in nums:\n            temp += num\n            if temp - target in sum_set:\n                count += 1\n                sum_set.clear()\n                sum_set.add(0)\n                temp = 0\n                continue\n            sum_set.add(temp)\n        return count\n\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        res=0\n        s=set()\n        s.add(0)\n        t=0\n        for x in nums:\n            t+=x\n            if t-target in s:\n                res+=1\n                s.clear()\n            s.add(t)\n        return res\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        n = len(nums)\n        cumsum = [0]*(n+1)\n\n        for i in range(n):\n            cumsum[i+1] = cumsum[i] + nums[i]\n\n        d = {0:0}\n        temp = []\n        for i in range(n):\n        #     print(i, cumsum[i+1]-target)\n            if cumsum[i+1]-target in d:\n                temp.append((d[cumsum[i+1]-target], i+1))\n                # print(d[cumsum[i+1]-target], i+1)\n            d[cumsum[i+1]] = i+1\n        l = sorted(temp, key=lambda x:(x[0],x[1]))\n        cur_s = -1\n        cur_e = -1\n        total = 0\n        for s,e in l:\n            if s >= cur_e:\n                total += 1\n                cur_s = s\n                cur_e = e\n            elif e < cur_e:\n                cur_s = s\n                cur_e = e\n        return total", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        ans, m, j, cur = 0, {0:-1}, -1, 0            \n        for i, x in enumerate(nums):\n            cur += x\n            k = cur - target            \n            if k in m and m[k] >= j:\n                ans += 1; j = i \n            m[cur] = i\n        return ans\n                    \n                \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = [0] * len(nums)\n        prev_sum = {0: -1}\n        \n        num_nonover = 0\n        current_sum = 0\n        \n        for (index, num) in enumerate(nums):\n            current_sum += num\n            \n            if current_sum - target in prev_sum:\n                gain = dp[prev_sum[current_sum-target]] if prev_sum[current_sum-target] >= 0 else 0\n                \n                num_nonover = max(num_nonover, gain + 1)\n                \n                \n            dp[index] = num_nonover\n            prev_sum[current_sum] = index\n            \n        return num_nonover\n            \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        curSum = 0\n        sumsSet = {0}\n        result = 0\n        for x in nums:\n            curSum += x\n            if (curSum - target) in sumsSet:\n                result += 1\n                curSum = 0\n                sumsSet.clear()\n            sumsSet.add(curSum)\n            \n        return result", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        dp = [0] * (n+1)\n        \n        dic = {}\n        dic[0] = 0\n        \n        cur = 0\n        \n        for i in range(1, n+1):\n            cur += nums[i-1]\n            \n            if cur - target in dic:\n                dp[i] = 1 + dp[dic[cur - target]]\n            \n            dp[i] = max(dp[i-1], dp[i])\n            \n            dic[cur] = i\n        \n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        d = {}\n        d[0] = -1\n        \n        N = len(nums)\n        \n        if(N==0):\n            return 0\n        L = [0 for i in range(N)]\n        s = nums[0]\n        d[s] = 0\n        if(s==target):\n            L[0] = 1\n        for i in range(1,N):\n            s += nums[i]\n            L[i] = L[i-1]\n            if(s-target in d):\n                idx = d[s-target]\n                if(idx==-1):\n                    L[i] = max(L[i],1)\n                else:\n                    L[i] = max(L[i],L[idx]+1)\n            \n            d[s] = i\n        return L[N-1]\n", "class Solution:\n    def maxNonOverlapping(self, nums, target):\n        ans = 0\n        cur = 0\n        tmp = set([0])\n        for n in nums:\n            cur += n\n            if cur - target in tmp:\n                ans += 1\n                cur = 0\n                tmp = set([0])\n            tmp.add(cur)\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        P = [0]\n        for e in nums:\n            P.append(P[-1]+e)\n            \n        seen = set()\n        ans = 0\n        \n        for psum in P:\n            if psum - target in seen:\n                seen = {psum}\n                ans += 1\n            else:\n                seen.add(psum)\n                \n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        pre = [0]\n        for n in nums:\n            pre.append(pre[-1] + n)\n        \n        dp = {0: 0}\n        counter = [0] * len(pre)\n        \n        for i in range(1, len(pre)):\n            if pre[i] - target in dp:\n                idx = dp[pre[i] - target]\n                counter[i] = max(counter[i-1], counter[idx] + 1)\n            else:\n                counter[i] = counter[i-1]\n            dp[pre[i]] = i\n        return counter[-1]", "\n\n\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n\n        prefixsum = {}\n        prefixsum[0] = True\n        prev = 0\n        res = 0\n        for num in nums:\n            curr = prev + num\n            \n            if curr - target in prefixsum:\n                res += 1\n                prefixsum = {}\n                prefixsum[0] = True\n                prev = 0\n            \n            else:\n                prefixsum[curr] = True\n                prev = curr\n            \n        print(res)\n        return res\n        \n        \n        \n        \n        \n\n\n\n\n\n\n'''\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        prefixsum = {}\n        prefixsum[0] = 0\n        res = 0\n        last = -1\n        prev = 0\n        for idx, num in enumerate(nums):\n            curr = prev + num\n            prefixsum[curr] = idx\n            \n            if curr - target in prefixsum:\n                if prefixsum[curr - target] >= last:\n                    res += 1\n                    last = prefixsum[curr]\n            prev = curr \n        print(prefixsum)\n        print(res)\n        return res\n\n\n'''\n", "### good explanation in https://www.youtube.com/watch?v=EW521e8c8lk\n\n### video starts 10:40\n\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n\n        prefixsum = {}\n        prefixsum[0] = True\n        prev = 0\n        res = 0\n        for num in nums:\n            curr = prev + num\n            \n            if curr - target in prefixsum:\n                res += 1\n                prefixsum = {}\n                prefixsum[0] = True\n                prev = 0\n            \n            else:\n                prefixsum[curr] = True\n                prev = curr\n            \n        print(res)\n        return res\n        \n        \n        \n        \n\n\n\n'''\nIt seems that I have exact the same idea as the following post\nhttps://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/discuss/780882/Java-14-lines-Greedy-PrefixSum-with-line-by-line-explanation-easy-to-understand\n\nwhy does the following code now working???? \n\n\n### The following code does not pass submission ..... \nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        prefixsum = {}\n        prefixsum[0] = -1\n        res = 0\n        last = -1\n        prev = 0\n        for idx, num in enumerate(nums):\n            curr = prev + num\n            prefixsum[curr] = idx\n            \n            if curr - target in prefixsum:\n                if prefixsum[curr - target] >= last:\n                    res += 1\n                    last = prefixsum[curr]\n            prev = curr \n        print(prefixsum)\n        print(res)\n        return res\n\n\n'''\n\n\n\n\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        n = len(nums)\n        dp = [0]*(n+1)\n        dict = {}\n        dict[0] = 0\n        \n        curr = 0\n        \n        for i in range(1,n+1):\n            curr += nums[i-1]\n            miss = curr - target\n            if miss in dict:\n                dp[i]= 1 + dp[dict[miss]]\n                \n            dp[i] = max(dp[i-1],dp[i])\n            dict[curr]=i\n            \n        return dp[n]\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n      res = 0\n      csum = [0]\n      for n in nums:\n        csum.append(csum[-1]+n)\n      # print (csum[1:])\n      # print ([c-target for c in csum[1:]])\n      seen = set([])\n      for c in csum[:]:\n        # print (c, c-target, seen)\n        if c-target in seen:\n          res += 1\n          seen.clear()\n        seen.add(c)\n        \n      return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        csum = {}\n        csum[0] = 0\n        dp = [0 for i in range(len(nums)+1)]\n        sum,best = (0,0)\n        for i,v in enumerate(nums):\n            sum += v\n            x = sum - target\n            dp[i+1] = dp[i]\n            if x in csum:\n                dp[i+1] = max(dp[i+1], dp[csum[x]] + 1)\n            best = max(best, dp[i+1])\n            csum[sum] = i + 1\n        return best\n            \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        count = 0\n        sums = set()\n        sums.add(0)\n        tot = 0\n        for num in nums:\n            tot += num\n            if (tot - target) in sums:\n                count += 1\n                sums=set()\n            sums.add(tot)\n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        lookup = {0 : -1}\n        running_sum  = 0\n        count = 0\n        for i in range(len(nums)):\n            running_sum += nums[i]\n            if running_sum - target in lookup:\n                count += 1\n                lookup = {} #reset the map\n            lookup[running_sum] = i\n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = [0] + [-1] * len(nums)\n        s = 0\n        dic = {}\n        dic[0] = 0\n        res = 0\n        \n        for i in range(len(nums)):\n            s += nums[i]            \n            if s - target in dic:\n                dp[i+1] = max(dp[dic[s-target]] + 1, dp[i])\n            else: \n                dp[i+1] = dp[i]\n        \n            dic[s] = i + 1\n        print(dp)\n        return dp[-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        for i in range(1, len(nums)):\n            nums[i] += nums[i - 1]\n        res = 0\n        seen = {}\n        used_i = 0\n        nums = [0] + nums\n        for i, num in enumerate(nums):\n            if num - target in seen and seen[num - target] >= used_i:\n                res += 1\n                used_i = i\n            seen[num] = i\n        return res\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefix_sum = count = 0\n        seen = {0}\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - target in seen:\n                prefix_sum = 0\n                count += 1\n                seen = set([0])\n            seen.add(prefix_sum)\n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dic = {0:-1}\n        acc = 0\n        last = -1\n        res = 0\n        \n        for i, n in enumerate(nums):\n            acc += n\n            \n            if acc - target in dic and dic[acc-target] >= last:\n                res += 1\n                last = i\n                \n            dic[acc] = i\n            \n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        m = {0: 0}\n        res = 0\n        sum = 0\n        for x in nums:\n            sum += x\n            if sum - target in m:\n                res = max(res, m[sum - target] + 1)\n            m[sum] = res\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cache = set([0])\n        cur, res = 0, 0\n        for i in range(len(nums)):\n            cur += nums[i]\n            if cur - target in cache:\n                res += 1\n                cache.clear()\n            cache.add(cur)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        count = 0\n        total = 0\n        pastSums = set()\n            \n            \n        for n in nums:\n            total += n\n            \n            if total == target or total - target in pastSums:\n                total = 0\n                count += 1\n                pastSums.clear()\n            else:\n                pastSums.add(total)\n                \n                \n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefix_sum = count = 0\n        prev_subarray_end = -1\n        seen = {0 : -1}\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            if seen.get(prefix_sum - target, -2) >= prev_subarray_end:\n                count += 1\n                prev_subarray_end = i\n            seen[prefix_sum] = i\n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = [0] + list(accumulate(nums))\n        len_dp = len(dp)\n        answer = 0\n        lo = 0\n        lo_sum = 0\n        for hi in range(1, len_dp):\n            if dp[hi] < lo_sum:\n                lo_sum = dp[hi]\n            if dp[hi] - lo_sum >= target:\n                if dp[hi] - target in dp[lo:hi]:\n                    answer += 1\n                    lo = hi\n                    lo_sum = dp[hi]\n        return answer\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        curr = 0\n        ans = 0\n        seen = set()\n        for num in nums:\n            seen.add(curr)\n            curr += num\n            want = curr - target\n            if want in seen:\n                ans += 1\n                seen = set()\n                curr = 0\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        psum = [0]\n        for v in nums:\n            psum.append(v+psum[-1])\n        \n        \n        \n        def helper(lo, target):\n            d = {psum[lo-1]}\n            ans = 0\n            for i in range(lo, len(psum)):\n                if psum[i] - target in d:\n                    ans = 1 + helper(i+1, target)\n                    break\n                d.add(psum[i])\n            return ans\n        \n        return helper(1, target)\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cum_map = {\n            0: -1,\n        }\n        intervals = [-1] * len(nums)\n        cur = 0\n        for i, x in enumerate(nums):\n            cur += x\n            rest = cur - target\n            boundary = cum_map.get(rest)\n            if boundary is not None:\n                intervals[i] = boundary + 1\n            cum_map[cur] = i\n        \n        \n        res = 0\n        s = [0] * len(nums)\n        for i in range(len(nums)):\n            if intervals[i] == i:\n                s[i] = s[i-1] + 1\n                continue\n            \n            s[i] = s[i-1]\n            if intervals[i] == 0:\n                s[i] = max(s[i-1], 1)\n            elif intervals[i] > 0:\n                s[i] = max(s[i-1], s[intervals[i] - 1] + 1)\n                \n        return s[-1]                \n                \n", "from collections import defaultdict\nfrom bisect import *\n\nclass Solution:\n    def maxNonOverlapping(self, lst: List[int], k: int) -> int:\n\n        n     = len(lst)\n        first = 0 \n        last  = 0\n        total = lst[0]\n        \n        dct   = defaultdict(list)\n        \n        dp = [0 for i in range(n+1)]\n        \n        for i in range(1,n+1):\n            dp[i] = dp[i-1]+lst[i-1]\n            dct[dp[i]].append(i)\n        \n    \n        intervals = [ ]\n        for i in range(n+1):\n            # for temp in dct[k+dp[i]]:\n            #     if(temp>i):\n            #         intervals.append((i,temp))\n            \n            left = bisect_right(dct[k+dp[i]],i)\n            if(left!=len(dct[k+dp[i]])):\n                intervals.append((i,dct[k+dp[i]][left]))\n\n        \n        intervals.sort(key = lambda x:x[1])\n        \n        pre = -float('inf')\n        ans = 0 \n        index = 0\n        \n        print(intervals)\n        \n        while(index<len(intervals)):\n            if(intervals[index][0]>=pre):\n                ans+=1\n                pre = intervals[index][1]\n            index+=1\n        return ans\n        \n                \n                \n            \n            \n                \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        pref = {}\n        pref[0] = -1\n        ans = 0\n        presum = 0\n        j = -1\n        for i in range(len(nums)):\n            presum += nums[i]\n            c = presum - target\n            if c in pref and pref[c] >= j:\n                ans += 1\n                j = i\n            pref[presum] = j\n        return ans\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        \n        prefix_sum = [0 for _ in range(N)]\n        prefix_sum[0] = nums[0]\n        for i in range(1, N):\n            prefix_sum[i] = nums[i] + prefix_sum[i-1]\n        \n        prev_prefix = {}\n        last_index = -1\n        subarrays = 0\n        for i in range(N):\n            prefix = prefix_sum[i]\n            \n            to_look = prefix - target\n            if to_look in prev_prefix and prev_prefix[to_look] >= last_index:\n                last_index = i\n                subarrays += 1\n            elif nums[i] == target:\n                subarrays += 1\n                last_index = i\n            elif prefix == target and last_index == -1:\n                subarrays += 1\n                last_index = i\n                \n            prev_prefix[prefix] = i\n            \n        return subarrays", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * (n+1)\n        dic = {}\n        dic[0] = 0\n        curr = 0\n        \n        for i in range(1, n+1):\n            curr += nums[i-1]\n            if curr - target in dic:\n                dp[i] = dp[dic[curr-target]] + 1\n            dp[i] = max(dp[i-1], dp[i])\n            dic[curr] = i\n            \n        return dp[-1]", "class Solution:\n    \n    def maxNonOverlapping(self, nums, target) -> int:\n        hashMap = {0: -1} #totalSum -> inclusive ending index\n        totalSum = 0\n        answer = []\n        count = 0\n        for i in range(len(nums)):\n            totalSum += nums[i]\n            if totalSum - target in hashMap:\n                answer.append([hashMap[totalSum-target] + 1, i])\n            \n            hashMap[totalSum] = i\n\n        ending = None\n        for i in answer:\n            if ending is None or i[0] > ending:\n                count += 1\n                ending = i[1]\n        return count \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        D = {0:-1}\n        cumsum = 0\n        idx = -1\n        res = 0\n        for i, x in enumerate(nums):\n            cumsum += x\n            if cumsum - target in D and D[cumsum-target] >= idx:\n                res += 1\n                idx = i\n            D[cumsum] = i\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        s = set()\n        s.add(0)\n        ans = 0\n        prefsum = 0\n        for num in nums:\n            prefsum += num\n            if prefsum - target in s:\n                ans += 1\n                s = set()\n            s.add(prefsum)\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = [0] * (len(nums)+1)\n        acc = [0] * (len(nums)+1)\n        sumDict = {0:0}\n        for k, ele in enumerate(nums):\n            dk = k+1\n            acc[dk] = acc[k] + ele\n            if acc[dk]-target in sumDict:\n                dp[dk] = max(dp[k], dp[sumDict[acc[dk]-target]]+1)\n            else:\n                dp[dk] = dp[k]\n                \n            sumDict[acc[dk]] = dk\n        \n        return dp[len(nums)]\n", "from collections import defaultdict\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        cum_sum=[0]\n        for i in range(len(nums)): cum_sum.append(cum_sum[-1]+nums[i])\n\n        mem=defaultdict(list)\n\n        for i in range(len(nums)+1):\n            mem[cum_sum[i]].append(i)\n\n        def binSearch(index):\n            arr=mem[cum_sum[index]-target]\n            right=len(arr)-1\n            left=0\n            best=None\n            while left<=right:\n                mid=(left+right)//2\n                if arr[mid]<index:\n                    best=arr[mid]\n                    left=mid+1\n                else:\n                    right=mid-1\n            return best\n\n        dp=[0 for i in range(len(nums)+1)]\n        for i in range(1,len(nums)+1):\n            ind=binSearch(i)\n            s=0\n            if ind!=None:\n                s=1+dp[ind]\n            dp[i]=max(dp[i-1],s)\n\n        return dp[-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        \n        prefix_sum = [0 for _ in range(N)]\n        prefix_sum[0] = nums[0]\n        for i in range(1, N):\n            prefix_sum[i] = nums[i] + prefix_sum[i-1]\n        \n        # TODO: there is a bug here..not sure what the hell it is though!!!!\n        prev_prefix = {}\n        last_index = -1\n        subarrays = 0\n        for i in range(N):\n            prefix = prefix_sum[i]\n            \n            to_look = prefix - target\n            if to_look in prev_prefix and prev_prefix[to_look] >= last_index:\n                last_index = i\n                subarrays += 1\n            elif nums[i] == target:\n                subarrays += 1\n                last_index = i\n            elif prefix == target and last_index == -1:\n                subarrays += 1\n                last_index = i\n                \n            prev_prefix[prefix] = i\n                \n            \n        return subarrays\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefix_sum = 0\n        seen = {0}\n        res = 0\n        for n in nums:\n            prefix_sum += n\n            if prefix_sum - target in seen:\n                seen = {prefix_sum}\n                res += 1\n            seen.add(prefix_sum)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        # Taking a walk through the array, if we can ever make the target, we might as well because we'd like the border for the last subarray to be as far left as possible for the next. To see if we can make the target, we just take the total sum so far and see if we ever had the right previous total sum to chop off. We also check that the chop point does not overlap another subarray end point we used.\n        #maintain a list of end indices\n        hmap = collections.defaultdict(int)\n        rsum = 0\n        res = 0\n        last = -1\n        hmap[0] = -1\n        \n        for index,num in enumerate(nums):\n            \n            rsum += num\n            \n            csum = rsum - target\n            \n            # if rsum == target:\n            #     res += 1\n            \n            if csum in hmap and hmap[csum] >= last:\n                res += 1\n                last = index\n                \n            hmap[rsum] = index\n            \n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        run_sum = 0\n        count = 0\n        book_keep = {0:1}\n        for num in nums:\n            run_sum += num\n            prev_sum = run_sum - target\n            if prev_sum in book_keep:\n                count += 1\n                run_sum = 0\n                book_keep.clear()\n                book_keep = {0:1}\n            else:\n                book_keep[run_sum] = 1\n        \n        return count  \n                \n                \n            \n            \n            \n                    \n        \n            \n            \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        for i in range(1, n):\n            nums[i] += nums[i-1]\n        seen = {0: 0}\n        res = 0\n        for i, n in enumerate(nums):\n            if n-target in seen:\n                res += 1\n                seen = {n:0}\n            else:\n                seen[n] = i\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        pre = 0\n        sums = [0]\n        for el in nums:\n            pre += el\n            sums.append(pre)\n            \n        #print(\\\"---\\\")\n       # print(sums)\n        ans = 0\n        seen = {} # seen[v] = i iff sums[i] == v\n        for i, v in enumerate(sums):\n            #print(f\\\"seen: {seen}\\\")\n            if v-target in seen:\n                ans += 1\n                seen = {} # satisfies non-overlapping\n            seen[v] = i\n        #print(f\\\"seen: {seen}\\\")\n        return ans\n            \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        hashmap = {0:0}\n        ans = 0\n        sums = 0\n        for i in range(n):\n            sums += nums[i]\n            if sums-target in hashmap:\n                ans = max(ans, hashmap[sums-target] + 1)\n            hashmap[sums] = ans\n        return ans\n        \n        \n        # n = len(nums)\n        # preSum = [0 for i in range(n+1)]\n        # hashmap = {0:0}\n        # lastend = 0\n        # ans = 0\n        # for i in range(1, n+1):\n        #     preSum[i] = preSum[i-1] + nums[i-1]\n        #     begin = hashmap.get(preSum[i]-target, -1)\n        #     if begin >= 0 and begin >= lastend:\n        #         lastend = i\n        #         ans += 1\n        #     pos = hashmap.get(preSum[i], 0)\n        #     hashmap[preSum[i]] = max(pos, i)\n        # return ans\n        \n        # n = len(nums)\n        # dp = [0 for i in range(n+1)]\n        # for i in range(n):\n        #     tmpsum = 0\n        #     for j in range(i, -1, -1):\n        #         tmpsum += nums[j]\n        #         if tmpsum == target:\n        #             dp[i+1] = max(dp[i+1], dp[j] + 1)\n        #         else:\n        #             dp[i+1] = max(dp[i+1], dp[j])\n        # print(dp)\n        # return dp[n]\n        \n        \n        # n = len(nums)\n        # dp = [0 for i in range(n)]\n        # if target == nums[0]:\n        #     dp[0] = 1\n        # for i in range(1, n):\n        #     tmpsum = 0\n        #     for j in range(i, -1, -1):\n        #         tmpsum += nums[j]\n        #         if tmpsum == target:\n        #             if j > 0:\n        #                 dp[i] = max(dp[i], dp[j-1] + 1)\n        #             else:\n        #                 dp[i] = max(dp[i], 1)\n        #             break\n        # print(dp)\n        # return dp[n-1]\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix =[0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        \n        seen = {0:0}\n        ans = 0\n        for i in range(1,n + 1):\n            current = prefix[i]\n            a = current - target\n            if a in seen:\n                ans += 1\n                seen = {}\n            seen[current] = 1\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        sums=set()\n        s=0\n        cnt=0\n        sums.add(0)\n        \n        for n in nums:\n            s+=n\n            if s-target in sums:\n                cnt+=1\n                sums=set()\n            \n            sums.add(s)\n                \n        return cnt\n            \n\n                    \n                    \n                \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        h = {0: 1}\n        summ = count = 0\n        for i in range(0, len(nums)):\n            summ += nums[i]\n            if summ - target in h:\n                count += 1\n                h = {}\n            h[summ] = i\n            \n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        if not nums: return 0\n        \n        seen = set([0])\n        \n        out = 0\n        \n        curr = 0\n        \n        for i in nums:\n            curr += i\n            if curr - target in seen:\n                out += 1\n                seen = set([0])\n                curr = 0\n            else:\n                seen.add(curr)\n        \n        return out", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        res = 0\n        cumsum = 0\n        cache = set([0])\n        for num in nums:\n            cumsum += num\n            if cumsum - target in cache:\n                res += 1\n                cache = set()\n            cache.add(cumsum)\n                \n        return res\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        count = 0\n        curr_cnt = 0\n        dic = {0:-1}\n        for i in range(len(nums)):\n            curr_cnt += nums[i]\n            if curr_cnt - target in dic:\n                count += 1\n                dic = {}\n            dic[curr_cnt] = i\n        return count\n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        tot = 0\n        seen = set([0])\n        cur = 0\n        for n in nums:\n            cur += n\n            if cur - target in seen:\n                tot += 1\n                cur = 0\n                seen = set([0])\n            else:\n                seen.add(cur)\n        return tot\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        # n = len(nums)\n        # hashmap = {0:0}\n        # ans = 0\n        # sums = 0\n        # for i in range(n):\n        #     sums += nums[i]\n        #     if sums-target in hashmap:\n        #         ans = max(ans, hashmap[sums-target] + 1)\n        #     hashmap[sums] = ans\n        # return ans\n        \n        \n        n = len(nums)\n        preSum = [0 for i in range(n+1)]\n        hashmap = {0:0}\n        lastend = 0\n        ans = 0\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + nums[i-1]\n            begin = hashmap.get(preSum[i]-target, -1)\n            if begin >= 0 and begin >= lastend:\n                lastend = i\n                ans += 1\n            hashmap[preSum[i]] = i\n        return ans\n        \n        # n = len(nums)\n        # dp = [0 for i in range(n+1)]\n        # for i in range(n):\n        #     tmpsum = 0\n        #     for j in range(i, -1, -1):\n        #         tmpsum += nums[j]\n        #         if tmpsum == target:\n        #             dp[i+1] = max(dp[i+1], dp[j] + 1)\n        #         else:\n        #             dp[i+1] = max(dp[i+1], dp[j])\n        # print(dp)\n        # return dp[n]\n        \n        \n        # n = len(nums)\n        # dp = [0 for i in range(n)]\n        # if target == nums[0]:\n        #     dp[0] = 1\n        # for i in range(1, n):\n        #     tmpsum = 0\n        #     for j in range(i, -1, -1):\n        #         tmpsum += nums[j]\n        #         if tmpsum == target:\n        #             if j > 0:\n        #                 dp[i] = max(dp[i], dp[j-1] + 1)\n        #             else:\n        #                 dp[i] = max(dp[i], 1)\n        #             break\n        # print(dp)\n        # return dp[n-1]\n", "class Solution:\n  def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n    # TC: O(N), SC:O(N)\n    n = len(nums)\n    # prefix sum\n    for i in range(1, n):\n      nums[i] += nums[i - 1]\n    seen, dp = {0: -1}, [0] * n\n    for i in range(n):\n      x = nums[i] - target\n      if x in seen:\n        dp[i] = max(dp[i - 1], dp[seen[x]] + 1)\n      else:\n        dp[i] = dp[i - 1]\n      seen[nums[i]] = i\n    return dp[-1]", "from typing import List, Tuple\nclass Solution:\n    def maxNonOverlappingIntervals(self, intervals: List[Tuple[int, int]], sort=True) -> int:\n        if not intervals:\n            return 0\n        # Sort intervals by ending time\n        if sort:\n            intervals = sorted(intervals, key=lambda x: x[1])\n        ans = 1\n        cur_end = intervals[0][1]\n        for start, end in intervals[1:]:\n            if start <= cur_end:\n                continue\n            ans += 1\n            cur_end = end\n        return ans\n        \n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        # If we can get all subarrays that sum to target in order sorted by ending index,\n        # then we can simply apply activity selection to it.\n        # We can use prefix sums to get this^^. Note that because negative numbers are allowed,\n        # we might get multiple subarrays ending at i that sum to target. However, we can ignore\n        # all except the smallest one, as we want non-overlapping.\n        prefix_sum = {0: -1}\n        cumsum = 0\n        intervals = []\n        for i, x in enumerate(nums):\n            cumsum += x\n            if cumsum - target in prefix_sum:\n                intervals.append((prefix_sum[cumsum-target]+1, i))\n            prefix_sum[cumsum] = i  # Don't bother with multiple indices, just use the the latest one\n        return self.maxNonOverlappingIntervals(intervals, False)", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        presum = 0\n            \n        last_pos = {0: 0}\n        dp = [0] * (1 + n)\n        for i in range(1, 1 + n):\n            presum += nums[i - 1]\n            dp[i] = dp[i - 1]\n            if presum - target in last_pos:\n                pos = last_pos[presum - target]\n                dp[i] = max(dp[i], dp[pos] + 1)\n            last_pos[presum] = i\n        # print(dp)\n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp=[0]*(1+len(nums))\n        mem={0:0}\n        cur=0\n        for i,v in enumerate(nums):\n            cur+=v\n            dp[i+1]=dp[i]\n            if cur-target in mem:\n                dp[i+1]=max(dp[i+1],dp[mem[cur-target]]+1)\n            mem[cur]=i+1\n        # print(dp)\n        return dp[-1]\n", "# idea: greedy. keep a check of cumulated sum, and as soon as we find a subarray whose sum equals target, we reset cumulated sum\n\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cum_sum = 0\n        seen_cum_sum = set([0])\n        count = 0\n        \n        for num in nums:\n            cum_sum += num\n            complement = cum_sum-target\n            \n            if complement in seen_cum_sum:\n                count += 1\n                cum_sum = 0\n                seen_cum_sum = set([0])\n                \n            seen_cum_sum.add(cum_sum)\n                \n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefixSum = {0:-1}\n        dp = [0] * len(nums)\n        \n        currSum = 0\n        for i in range (len(nums)):\n            currSum = currSum + nums[i]\n            if currSum - target in prefixSum:\n                end = prefixSum[currSum - target]\n                dp[i] = max(1 + dp[end], dp[i-1])\n            elif i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i-1]\n            prefixSum[currSum] = i\n        return dp[len(nums)-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n      \n        prefix = {0:-1}\n        cur = 0\n        res = 0\n        for i,v in enumerate(nums):  \n          cur += v\n          if (cur - target) in prefix:\n            res += 1\n            prefix = {}\n            \n          prefix[cur] = i\n\n        return res\n            \n          \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        '''\n        Get prefix sum: pref[]\n        Find the largest sorted list of indices index[] where\n        pref[index[1]] - pref[index[0]] = pref[index[3]] - pref[index[2]] = ... = target\n        '''\n        pref = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            pref[i+1] = pref[i] + nums[i]\n        \n        d = {}\n        ans = 0\n        #print(pref)\n        for i in range(len(pref)):\n            #print(pref[i], d)\n            if pref[i] - target in d:\n                ans += 1\n                #print(ans)\n                d.clear()\n            d[pref[i]] = i\n        return ans\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        d={0:-1}\n        add=0\n        count=0\n        i=0\n        while(i<=len(nums)-1):\n            add+=nums[i]\n            if (add-target) in d :\n                count+=1\n                d= {}\n            d[add]=i\n            i+=1\n        return count    \n                    \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefix = list(itertools.accumulate(nums))\n        \n        def dfs(i):\n            s = {prefix[i - 1] if i > 0 else 0}\n            for j in range(i, len(prefix)):\n                if prefix[j] - target in s:\n                    return 1 + dfs(j + 1)\n                s.add(prefix[j])\n            return 0\n        \n        return dfs(0)", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        count, sums, curr = 0, {0}, 0\n        for num in nums:\n            curr += num\n            if curr - target in sums:\n                count += 1\n                sums.clear()\n            sums.add(curr)\n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n            \n        ans = 0\n        seen = {0:0}\n        for i in range(1,n + 1):\n            curr = prefix[i]\n            a = curr - target\n            if a in seen:\n                ans += 1\n                seen = {}\n                \n            seen[curr] = i\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        presum = [0]\n        for num in nums:\n            presum.append(presum[-1] + num)\n            \n        last_pos = {0: 0}\n        dp = [0] * (1 + n)\n        for i in range(1, 1 + n):\n            dp[i] = dp[i - 1]\n            if presum[i] - target in last_pos:\n                pos = last_pos[presum[i] - target]\n                \n                dp[i] = max(dp[i], dp[pos] + 1)\n            last_pos[presum[i]] = i\n        # print(dp)\n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        preSum = [0]\n        for num in nums:\n            preSum.append(preSum[-1] + num)\n            \n        n = len(nums)\n        dp = [0 for i in range(n + 1)]\n        \n        temp = {0:0}\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            if preSum[i] - target in temp:\n                dp[i] = max(dp[i], dp[temp[preSum[i] - target]] + 1)\n            temp[preSum[i]] = i\n        \n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        N = len(nums)\n        \n        rtv = 0\n\n        presum = dict()\n        presum[0] = -1\n        total = 0\n        for i,v in enumerate(nums):\n            total += v\n            \n            ne = total - target\n            if ne in presum and presum[ne] < i:\n                rtv += 1\n                # print(\\\"{} {}\\\".format(presum[ne]+1, i))\n\n                presum = dict()\n                presum[0] = i\n                total = 0\n            else:\n                presum[total] = i\n\n        return rtv", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        ln = len(nums)\n        ret = 0\n        \n        sums = {0 : 0}\n        dp = [0] * (ln+1)\n\n        s = 0\n        for i in range(ln):\n            s += nums[i]\n            \n            if s - target in sums:\n                idx = sums[s-target]\n                dp[i+1] = 1 + dp[idx]\n                \n            dp[i+1] = max(dp[i], dp[i+1])\n            \n            sums[s] = i+1\n                \n        \n        \n        return dp[ln]\n        pass\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        subarrays = []\n        summ = 0\n        lookup = set([0])\n        count = 0\n        for num in nums:\n            summ += num\n            if summ - target in lookup:\n                count += 1\n                summ = 0\n                lookup = set([0])\n            else:\n                lookup.add(summ)\n        return count \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        if len(nums) == 0:\n            return 0\n        \n        h = {}\n        dp = []\n        s = nums[0]\n        if s == target:\n            dp.append(1)\n        else:\n            dp.append(0)\n        h[s] = 0\n        for i in range(1, len(nums)):\n            s = s + nums[i]\n            if s == target:\n                if 0 in h:\n                    dp.append(max(dp[h[0]]+1, dp[-1]))\n                else:\n                    dp.append(max(1, dp[-1]))\n            elif s-target in h:\n                dp.append(max(dp[h[s-target]]+1, dp[-1]))\n            else:\n                dp.append(dp[-1])\n            h[s] = i\n        return dp[-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        d = {0: -1}\n        cursum = 0\n        ans = 0\n        for i,n in enumerate(nums):\n            cursum += n\n            prev = cursum - target\n            if prev in d:\n                ans += 1\n                d = {}\n            \n            d[cursum] = i\n        \n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cur = 0\n        n = len(nums)\n        dp = [0]*(n+1)\n        dic = {}\n        dic[0]=0\n        \n        for i in range(1,n+1):\n            cur+=nums[i-1]\n            if cur-target in dic:\n                dp[i] = 1+dp[dic[cur-target]]\n            dp[i] = max(dp[i],dp[i-1])\n            \n            dic[cur]=i\n        \n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n        \n        seen = {0:0}\n        ans = 0\n        for i in range(1,n + 1):\n            cur = prefix[i]\n            a = cur - target\n            if a in seen:\n                ans += 1\n                seen = {}\n            seen[cur] = 1\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = [0] * (len(nums) + 1)\n        mem = dict()\n        mem[0] = -1\n        cur = 0\n        for i in range(1, len(nums) + 1):\n            dp[i] = dp[i - 1]\n            cur += nums[i - 1]\n            t = cur - target\n            #print(i-1, cur, t, mem)\n            if t in mem:\n                dp[i] = max(dp[i], dp[mem[t]] + 1)\n                #print('!!', i, dp)\n            mem[cur] = i\n        return dp[-1]\n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sm = 0\n        hsh = {}\n        dp = {}\n        dp[-1] = 0\n        ans = 0\n        for i in range(len(nums)):\n            dp[i] = dp[i-1]\n            sm += nums[i]\n\n            if sm - target in hsh:\n                dp[i] = max(dp[i], dp[hsh[sm-target]] + 1)\n                \n            hsh[sm] = i\n            if sm == target:\n                dp[i] = max(dp[i], 1)\n            ans = max(ans, dp[i])\n        return ans\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cnt = collections.Counter()\n        cnt[0] = 0\n        ans = 0\n        prefix = 0\n        for n in nums:\n            prefix += n\n            # if p\n            if prefix-target in cnt:\n                ans += 1\n                cnt = collections.Counter()\n            cnt[prefix] += 1\n            # print(cnt, ans)\n        # print('--')\n        return ans\n    \n    \n#         dic = {0:0}\n#         ans = 0\n#         sum = 0\n#         for i in range(len(nums)):\n#             sum+=nums[i]\n#             if sum-target in dic:\n#                 ans+=1\n#                 dic = {}\n#             dic[sum] = i\n#         return ans\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i + 1] = prefix[i] + nums[i]\n            \n        seen = {0:0}\n        ans = 0\n        for i in range(1,n + 1):\n            curr = prefix[i]\n            a = curr - target\n            if a in seen:\n                ans += 1\n                seen = {}\n                \n            seen[curr] = i\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        \n        d = {0:1}\n        \n        total = 0\n        count = 0\n        \n        for i in nums:\n            total += i\n            \n            \n            if total - target in d:\n                print(total)\n                count += 1\n                d = {0:1}\n                total = 0\n            \n            else :\n                d[total] = 1\n                \n        return count\n        \n        \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        pos={0:-1}\n        n=len(nums)\n        dp=[0]*(n+1)\n        s=0\n        for i in range(n):\n            s+=nums[i]\n            dp[i+1]=dp[i]\n            t=s-target\n            if t in pos:\n                dp[i+1]=max(dp[i+1],dp[pos[t]+1]+1)\n            pos[s]=i\n        return dp[-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        pref_sum = [0 for _ in range(n + 1)]\n        \n        for i in range(n):\n            pref_sum[i + 1] = pref_sum[i] + nums[i]\n        \n        dp = collections.defaultdict(lambda: -1)\n        cur_max = 0\n        dp[0] = 0\n        for pref in range(1, n + 1):\n            cur_max = max(cur_max, dp[pref_sum[pref] - target] + 1)\n            dp[pref_sum[pref]] = cur_max\n        return cur_max", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0 for i in range(n+1)]\n        d = {}\n        d[0] = -1\n        s = 0\n        for i in range(n):\n            s+=nums[i]\n            t = s-target\n            dp[i+1] = dp[i]\n            if t in d:\n                dp[i+1] = max(dp[i+1],dp[d[t]+1]+1)\n            d[s] = i\n        # print(d)\n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        \n        dp = [0] * (n+1)\n        \n        dic = {}\n        dic[0] = 0\n        \n        cur = 0 \n        \n        for i in range(1, n+1):\n            cur += nums[i - 1]\n            \n            if cur - target in dic:\n                dp[i] = 1 + dp[dic[cur - target]]\n            dp[i] = max(dp[i-1], dp[i])\n            \n            dic[cur] = i \n        return dp[n]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        preSum = [0 for i in range(n+1)]\n        hashmap = {0:0}\n        lastend = 0\n        ans = 0\n        for i in range(1, n+1):\n            preSum[i] = preSum[i-1] + nums[i-1]\n            begin = hashmap.get(preSum[i]-target, -1)\n            if begin >= 0 and begin >= lastend:\n                lastend = i\n                ans += 1\n            pos = hashmap.get(preSum[i], 0)\n            hashmap[preSum[i]] = max(pos, i)\n        return ans\n        \n        \n        \n        \n        # n = len(nums)\n        # dp = [0 for i in range(n)]\n        # ans = 0\n        # if target == nums[0]:\n        #     dp[0] = 1\n        # for i in range(1, n):\n        #     dp[i] = dp[i-1]\n        #     tmpsum = 0\n        #     for j in range(i, -1, -1):\n        #         tmpsum += nums[j]\n        #         if tmpsum == target:\n        #             if j > 0:\n        #                 dp[i] = max(dp[i], dp[j-1] + 1)\n        #             else:\n        #                 dp[i] = max(dp[i], 1)\n        #             break\n        # # print(dp)\n        # return dp[n-1]\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        seen = set()\n        seen.add(0)\n        curr = 0\n        res = 0\n        for n in nums:\n            curr += n\n            if curr-target in seen:\n                res += 1\n                curr = 0\n                seen = set([0])\n            else:\n                seen.add(curr)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        d = {0:True}\n        sm = 0\n        count = 0\n        for i in nums:\n            sm += i\n            if sm-target in d:\n                count += 1\n                sm = 0\n                d = {0:True}\n            else:\n                d[sm] = True\n            # print(sm,count)\n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        subarrays = []\n        summ = 0\n        lookup = set()\n        count = 0\n        lookup.add(0)\n        for num in nums:\n            summ += num\n            if summ - target in lookup:\n                count += 1\n                summ = 0\n                lookup = set([0])\n            else:\n                lookup.add(summ)\n        return count \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix_sum = [0] * n    # prefix_sum[i] = sum of nums[0...i] inclusive\n        lookup = {}             # lookup[sum] = rightmost index st prefix_sum[idx] == sum\n        dp = [0] * n            # dp[i] = most non overlapping subarrays = target in nums[0...i]\n                                # dp[i] = max(dp[i - 1], dp[j] + 1 (if j+1...i == target)) if i > 0\n                                # dp[0] = 1 if nums[0] == target else 0\n        dp[0] = 1 if nums[0] == target else 0\n        prefix_sum[0] = nums[0]\n        lookup[nums[0]] = 0\n        for i in range(1, len(nums)):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i]\n            check_for = prefix_sum[i] - target\n            cmp_val = 0\n            if check_for in lookup:\n                cmp_val = dp[lookup[check_for]] + 1                \n            elif check_for == 0:\n                cmp_val = 1\n            dp[i] = max(dp[i - 1], cmp_val)\n            lookup[prefix_sum[i]] = i\n            \n        return dp[-1]\n    \n        # 0 0 0\n        # prefix_sum    [0, 0]\n        # lookup        {0:1}\n        # dp            [1, ]\n", "class Solution:\n    def maxNonOverlapping(self, nums, target):\n        d = {0: -1}\n        prefix = 0\n        count = 0\n        for i in range(len(nums)):\n            prefix += nums[i]\n            found = prefix - target\n            if found in d:\n                count += 1\n                d = {}\n            d[prefix] = i\n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        pos = {0: 0}\n        cumsum = 0\n        ans = 0\n        \n        for num in nums:\n            cumsum += num\n            pos[cumsum] = max(ans, pos.get(cumsum-target, -1)+1)\n            ans = max(ans, pos[cumsum])\n            #print(pos, cumsum)\n        return ans\n", "class Solution:\n    def maxNonOverlapping(self, A: List[int], T: int) -> int:\n        N = len(A)\n        prefix_sum = [0 for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n        seen = set([0])\n        res = 0\n        for i in range(N):\n            curr = prefix_sum[i + 1]\n            want = curr - T\n            if want in seen:\n                res += 1\n                seen = set()\n            seen.add(curr)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cnt = collections.Counter()\n        cnt[0] = 1\n        ans = 0\n        prefix = 0\n        for n in nums:\n            prefix += n\n            if cnt[prefix-target]!=0:\n                ans += 1\n                cnt = collections.Counter()\n                cnt[0] = 0\n            cnt[prefix] += 1\n            # print(cnt, ans)\n        print('--')\n        return ans", "from collections import defaultdict\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n#         cum_sum=[0]\n#         for i in range(len(nums)): cum_sum.append(cum_sum[-1]+nums[i])\n\n#         mem=defaultdict(list)\n\n#         for i in range(len(nums)+1):\n#             mem[cum_sum[i]].append(i)\n\n#         def binSearch(index):\n#             arr=mem[cum_sum[index]-target]\n#             right=len(arr)-1\n#             left=0\n#             best=None\n#             while left<=right:\n#                 mid=(left+right)//2\n#                 if arr[mid]<index:\n#                     best=arr[mid]\n#                     left=mid+1\n#                 else:\n#                     right=mid-1\n#             return best\n\n#         dp=[0 for i in range(len(nums)+1)]\n#         for i in range(1,len(nums)+1):\n#             ind=binSearch(i)\n#             s=0\n#             if ind!=None:\n#                 s=1+dp[ind]\n#             dp[i]=max(dp[i-1],s)\n\n#         return dp[-1]\n        dp=[0 for i in range(len(nums)+1)]\n        mp={}\n        s=0\n        mp[0]=0\n        for i in range(1,len(nums)+1):\n            s+=nums[i-1]\n            dp[i]=dp[i-1]\n            if s-target in mp:\n                dp[i]=max(dp[i],1+dp[mp[s-target]])\n            if nums[i-1]==target:\n                dp[i]=max(dp[i],1+dp[i-1])\n            mp[s]=i\n        return dp[-1]\n\n\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sett = set([0])\n        ans = 0\n        cur = 0\n        for val in nums:\n            cur += val\n            if cur - target in sett:\n                ans += 1\n                sett = set()\n            sett.add(cur)\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        prefix = [0]*(len(nums)+1)\n        counts = defaultdict(int)\n        counts[0] = 1\n        tot = 0\n        for i in range(1,len(nums)+1):\n            prefix[i] = nums[i-1] + prefix[i-1]\n            if counts[prefix[i]-target] != 0:\n                tot += 1\n                counts = defaultdict(int)\n                prefix[i] = 0\n            counts[prefix[i]] += 1\n        return tot\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        walk = {0:-1}\n        prefixSum = 0\n        delimiter = -1\n        res = 0\n        for i in range(len(nums)):\n            prefixSum += nums[i]\n            remain = prefixSum - target\n            if (remain in walk.keys() and walk[remain] >= delimiter):\n                res += 1\n                delimiter = i\n            walk[prefixSum] = i\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        d = {0: -1}\n        cursum = 0\n        ans = 0\n        for i,n in enumerate(nums):\n            cursum += n\n            prev = cursum - target\n            if prev in d:\n                ans += 1\n                d = {}\n                d[cursum] = i\n                continue\n            \n            d[cursum] = i\n        \n        return ans", "\nclass Solution:\n    def maxNonOverlapping(self, arr: List[int], target: int) -> int:\n        prevSums, n = {0: -1}, len(arr)\n        prefixSum, count, lastIndex = 0, 0, -1\n        \n        for i in range(n):\n            prefixSum += arr[i] \n            rem = prefixSum - target\n            if rem in prevSums and prevSums[rem] >= lastIndex:\n                count += 1 \n                lastIndex = i\n            prevSums[prefixSum] = i\n        return count", "# idea: greedy. keep a check of cumulated sum, and as soon as we find a subarray whose sum equals target, we reset cumulated sum\n\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        cum_sum = 0\n        seen_cum_sum = set([0])\n        count = 0\n        \n        for num in nums:\n            cum_sum += num\n            complement = cum_sum-target\n            \n            # if we found a subarray whose sum equals target, we reset cumulated sum\n            if complement in seen_cum_sum:\n                count += 1\n                cum_sum = 0\n                seen_cum_sum = set([0])\n                \n            seen_cum_sum.add(cum_sum)\n                \n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        # if nums[0:j] sum larger than target and there is a subarry nums[i:j] sum equal to target\n        # then sum(0:j)-sum(0:i) == target\n        # base on this idea, we could store each prefix_sum in to a map, \n        # check whether sum(0:j)-target is in the prefix_sum map. \n        # since we need overlapping, so store the right_most index for each prefix sum\n        # update the just found subarry's rightmose index, check current end index\n        \n        map = {0:-1}\n        prefix, rightmost, count = 0, -1, 0\n        \n        for i,val in enumerate(nums):\n            prefix += val\n            if prefix-target in map and map[prefix-target]>=rightmost: # for overlapping\n                count += 1\n                rightmost = i\n                \n            map[prefix] = i\n            \n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        s = {0}\n        res = 0\n        cur = 0\n        for x in nums:\n            cur += x\n            if cur - target in s:\n                #print(x)\n                res += 1\n                cur = 0\n                s = {0}\n                continue\n            s.add(cur)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sums = [0 for num in nums]\n        sum2index = {0:-1}\n        nums_subarrays = [0 for num in nums]\n        for i, num in enumerate(nums):\n            if i == 0:\n                sums[i] = nums[i]\n            else:\n                sums[i] = sums[i-1] + nums[i]\n            if sums[i]-target in sum2index:\n                if i == 0:\n                    nums_subarrays[i] = 1\n                else:\n                    nums_subarrays[i] = max(nums_subarrays[i-1], nums_subarrays[sum2index[sums[i]-target]]+1)\n            else:\n                if i == 0:\n                    nums_subarrays[i] = 0\n                else:\n                    nums_subarrays[i] = nums_subarrays[i-1]\n            sum2index[sums[i]] = i\n        return nums_subarrays[-1]", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        result = 0\n        pre_sum = [0] * (n+1)\n        for i,num in enumerate(nums):\n            pre_sum [i+1] = pre_sum[i] + num\n\n        seen = {0:0}\n        for i in range(1,n+1):\n            cur = pre_sum[i]\n            if cur-target in seen:\n                result += 1\n                seen = {}\n            seen[cur] = i\n        return result", "class Solution:\n    \n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        if len(nums) == 0:\n            return 0\n        result = 0\n        \n        # target = 10\n        # [-2,6, 6, 3, 5, 4, 1, 2, 8]\n        # [-2,4,10,13,18,22,23,25,33]\n        #                         ^\n        # seen: [0]\n        # result = 2\n        \n        prefixSums = []\n        partial = 0\n        \n        seen = set([0])\n        \n        for i in range(len(nums)):\n            partial += nums[i]\n            prefixSums.append(partial)\n            required = prefixSums[i] - target\n            if required in seen:\n                result += 1\n                seen = set()\n            seen.add(prefixSums[i])\n            \n        return result\n        \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: list, target: int) -> int:\n        sumDict=collections.defaultdict(collections.deque)\n        preSum=0;sumDict[0].append(-1);right=-1;ans=0\n        for i in range(len(nums)):\n            preSum+=nums[i]\n            if preSum-target in sumDict:\n                while sumDict[preSum-target] and sumDict[preSum-target][0]<right:\n                    sumDict[preSum-target].popleft()\n                if sumDict[preSum-target]:\n                    ans+=1\n                    right=i\n            sumDict[preSum].append(i)\n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        presum = [0] * (n + 1)\n        for i in range(n):\n            presum[i+1] = presum[i] + nums[i]\n            \n        seen = {0: 0}\n        ans = 0\n        for i in range(1, n + 1):\n            curr = presum[i]\n            prev = curr - target\n            if prev in seen:\n                ans += 1\n                seen = {}\n            seen[curr] = i\n        \n        return ans", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * (n+1)\n        m = {0: 0}\n        for i, pre in enumerate(itertools.accumulate(nums)):\n            if pre-target in m:\n                dp[i+1] = max(dp[i], dp[m[pre-target]]+1)\n            else:\n                dp[i+1] = dp[i]\n            m[pre] = i+1\n        return dp[-1]\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n#         n = len(nums)\n#         prefix = [0] * (n + 1)\n#         idx = []\n#         for i in range(1, n + 1):\n#             prefix[i] = prefix[i - 1] + nums[i - 1]\n#         for i in range(n + 1):\n#             for j in range(i + 1, n + 1):\n#                 if prefix[j] - prefix[i] == target:\n#                     idx.append([i, j])\n#                     break\n\n#         self.ans = 0        \n#         def backtrk(cur, start):\n#             if start == len(idx):\n#                 self.ans = max(self.ans, len(cur))\n#                 return\n#             visited = set()\n#             for i in range(start, len(idx)):\n#                 if len(cur) >= 1 and idx[i][0] < cur[-1][1]:\n#                     continue\n#                 x, y = idx[i][0], idx[i][1]   \n#                 backtrk(cur + [(x, y)], i + 1)\n#         backtrk([], 0)\n#         return self.ans\n               \n        prefix = [0]\n        for x in nums:\n            prefix.append(prefix[-1]+x)\n        res = 0 \n        seen = set()\n        for x in prefix:\n            if x-target in seen:\n                res += 1\n                seen = {x}\n            else:\n                seen.add(x)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        #maintain a list of end indices\n        hmap = collections.defaultdict(int)\n        rsum = 0\n        res = 0\n        last = -1\n        hmap[0] = -1\n        \n        for index,num in enumerate(nums):\n            \n            rsum += num\n            \n            csum = rsum - target\n            \n            # if rsum == target:\n            #     res += 1\n            \n            if csum in hmap and hmap[csum] >= last:\n                res += 1\n                last = index\n                \n            hmap[rsum] = index\n            \n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        seen = {0: -1}\n        prev = -1\n        count = 0\n        curr = 0\n        for i in range(len(nums)):\n            curr += nums[i]\n            if nums[i] == target or (curr - target in seen and prev < seen[curr - target] + 1):\n                prev = i\n                count += 1\n            seen[curr] = i\n        return count\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        dp = collections.Counter()\n        dp[0] = -1\n\n        s = cnt = 0\n        right = -1\n\n        for i, n in enumerate(nums):\n            s += n\n            if s - target in dp:\n                left = dp[s - target]\n                if right <= left:\n                    cnt += 1\n                    right = i\n            dp[s] = i\n        return cnt", "class Solution:\n    def maxNonOverlapping(self, A: List[int], T: int) -> int:\n        N = len(A)\n        prefix = [0 for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            prefix[i] = prefix[i - 1] + A[i - 1]\n        seen = set([0])\n        res = 0\n        for i in range(N):\n            curr = prefix[i + 1]\n            want = curr - T\n            if want in seen:\n                res += 1\n                seen = set()\n            seen.add(curr)\n        return res", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        curSum = 0\n        sumsSet = {0}\n        result = 0\n        for x in nums:\n            curSum += x\n            if (curSum - target) in sumsSet:\n                result += 1\n                curSum = 0\n                sumsSet = {0}\n            else:\n                sumsSet.add(curSum)\n            \n        return result", "class Solution:\n    def maxNonOverlapping(self, A: List[int], target: int) -> int:\n        \n        # dp[i + 1] = Math.max(dp[i + 1], dp[j] + (sum == target ? 1 : 0));\n        # a = [0] * (len(A) + 1)\n        # for i in range (len(A)):\n        #     sums = 0\n        #     for j in reversed(range(i + 1)):\n        #         sums += A[j]\n        #         a[i + 1] = max(a[i + 1], a[j] + 1 if sums == target else 0)\n        # print(a)\n        # return a[len(A)]\n        \n        seen = {0}\n        prefix_sum = count = 0\n        \n        for a in A:\n            prefix_sum += a\n            if -target + prefix_sum in seen:\n                prefix_sum = 0\n                count += 1\n                seen = set()\n            seen.add(prefix_sum)    \n            \n        return count\n            \n", "'''\nsliding window approach\n\ninitalize left at 0, curr at 0\nenumerate through right\n\n\n'''\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        presum = [0] * (n + 1)\n        for i in range(n):\n            presum[i+1] = presum[i] + nums[i]\n            \n        seen = {0: 0}\n        ans = 0\n        for i in range(1, n + 1):\n            curr = presum[i]\n            prev = curr - target\n            if prev in seen:\n                ans += 1\n                seen = {}\n            seen[curr] = i\n        \n        return ans", "class Solution:\n    \n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        if len(nums) == 0:\n            return 0\n        result = 0\n        \n        # target = 10\n        # [-2,6, 6, 3, 5, 4, 1, 2, 8]\n        # [-2,4,10,13,18,22,23,25,33]\n        #                         ^\n        # seen: [0]\n        # result = 2\n        \n        prefixSums = []\n        partial = 0\n        for i in range(len(nums)):\n            partial += nums[i]\n            prefixSums.append(partial)\n        \n        seen = set([0])\n        \n        for i in range(len(nums)):\n            required = prefixSums[i] - target\n            if required in seen:\n                result += 1\n                seen = set()\n            seen.add(prefixSums[i])\n            \n        return result\n        \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        store=set([0])\n        s=0\n        count=0\n        \n        for i in nums:\n            s+=i\n            \n            if s-target in store:\n                count+=1\n                store.clear()\n                \n            store.add(s)\n        return count", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        existingSums = set([0])\n        prefixsum = 0\n        count = 0\n        for num in nums:\n            prefixsum += num\n            \n            if prefixsum - target in existingSums:\n                count += 1\n                existingSums = set([0])\n                prefixsum = 0\n                \n            existingSums.add(prefixsum)\n            \n            \n        return count\n", "class Solution:\n    def maxNonOverlapping(self, lis: List[int], tar: int) -> int:\n        n = len(lis)\n        pre=[0]*(n+1)\n        ans=0\n        for i in range(n):\n            pre[i+1]=pre[i]+lis[i]\n        d={0:0}\n        for i in range(1,n+1):\n            cur = pre[i]\n            prev = cur-tar\n            if prev in d:\n                ans+=1\n                d={}\n            d[cur]=1\n        return ans\n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        sums = [0]\n        # prefix sum\n        for num in nums:\n            sums.append(sums[-1] + num)\n        \n        # two sum\n        hashmap = {}\n        results = []\n        for i, s in enumerate(sums):\n            if s in hashmap:\n                start = hashmap[s]\n                results.append((start, i-1))\n            need = s + target\n            hashmap[need] = i\n        \n        prevEnd = -1\n        count = 0\n        for start, end in results:\n            if start > prevEnd:\n                count += 1\n                prevEnd = end\n        return count\n            \n        \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        seen = {0: -1}\n        dp = [0]*(len(nums))\n        ans = 0\n        for i in range(len(nums)):\n            if(i > 0):\n                nums[i] += nums[i-1]\n                dp[i] = dp[i-1]\n            if((nums[i]-target) in seen):\n                dp[i]=max(dp[i], dp[seen[nums[i]-target]]+1)\n            seen[nums[i]] = i\n        return dp[-1]", "from collections import defaultdict\nclass Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        \n        dp = defaultdict(list)\n        res = [(0,-1)]\n        tmp_sum = 0\n        \n        for i, val in enumerate(nums):\n            \n            tmp_sum += val\n            \n            if tmp_sum - target == 0 and i > res[-1][1]:\n                res.append((0,i))\n                tmp_sum = 0\n            else:\n                if tmp_sum - target in dp and dp[tmp_sum - target][-1] >= res[-1][1] :\n                    res.append((0,i))\n                    tmp_sum = 0\n              \n            dp[tmp_sum].append(i)\n                    \n            # print(dp)\n            \n                    \n        return len(res)-1\n                    \n", "class Solution:\n    def maxNonOverlapping(self, nums: List[int], target: int) -> int:\n        res, sm = 0, 0\n        hs = set()\n        hs.add(0)\n        for v in nums:\n            sm += v\n            if (sm-target) in hs:\n                res += 1\n                sm = 0\n                hs.clear()\n                hs.add(0)\n            else:\n                hs.add(sm)\n        return res"]
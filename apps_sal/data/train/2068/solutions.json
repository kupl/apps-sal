["import sys\nreadline = sys.stdin.readline\n\nfrom collections import Counter \n\ndef getpar(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[0] = -1\n    par[p]  -1\n    stack = [p]\n    visited = set([p])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            stack.append(vf)\n    return par\n\ndef topological_sort_tree(E, r):\n    Q = [r]\n    L = []\n    visited = set([r])\n    while Q:\n        vn = Q.pop()\n        L.append(vn)\n        for vf in E[vn]:\n            if vf not in visited:\n                visited.add(vf)\n                Q.append(vf)\n    return L\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\n        \n\nN = int(readline())\nWe = list(map(int, readline().split()))\nEdge = [[] for _ in range(N)]\nCost = Counter()\ngeta = N+1\nfor _ in range(N-1):\n    a, b, c = list(map(int, readline().split()))\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\n    Cost[b*geta+a] = c\n    Cost[a*geta+b] = c\nP = getpar(Edge, 0)\nL = topological_sort_tree(Edge, 0)\nC = getcld(P)\n\n\ndp = [0]*N\ncandi = [[0, 0] for _ in range(N)]\nans = 0\nfor l in L[::-1][:-1]:\n    dp[l] += We[l]\n    p = P[l]\n    k = dp[l] - Cost[l*geta + p]\n    if k > 0:\n        dp[p] = max(dp[p], k)\n        candi[p].append(k)\n    \n    res = max(candi[l])\n    candi[l].remove(res)\n    ans = max(ans, We[l] + res + max(candi[l]))\n\nres = max(candi[0])\ncandi[0].remove(res)\nans = max(ans, We[0] + res + max(candi[0]))\nprint(ans) \n", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].append((v, w))\n    adj[v].append((u, w))\nbest = [0] * n\nans = 0\n\ndef dfs(u):\n    stack = list()\n    visit = [False] * n\n    stack.append((u, -1))\n    while stack:\n        u, par = stack[-1]\n        if not visit[u]:\n            visit[u] = True\n            for v, w in adj[u]:\n                if v != par:\n                    stack.append((v, u))\n        else:\n            cand = []\n            for v, w in adj[u]:\n                if v != par:\n                    cand.append(best[v] + a[v] - w)\n            cand.sort(reverse=True)\n            cur = a[u]\n            for i in range(2):\n                if i < len(cand) and cand[i] > 0:\n                    cur += cand[i]\n            nonlocal ans\n            ans = max(ans, cur)\n            best[u] = cand[0] if len(cand) > 0 and cand[0] > 0 else 0\n            stack.pop()\n\ndfs(0)\nprint(ans)", "from sys import stdin, setrecursionlimit\nimport threading\nn = int(stdin.readline())\nw = [int(x) for x in stdin.readline().split()]\ngraph = [{} for x in range(n)]\nfor road in range(n-1):\n    u,v,c = [int(x) for x in stdin.readline().split()]\n    u -= 1\n    v -= 1\n\n    if v in graph[u]:\n        graph[u][v] = min(graph[u][v], c)\n    else:\n        graph[u][v] = c\n\n    if u in graph[v]:\n        graph[v][u] = min(graph[v][u], c)\n    else:\n        graph[v][u] = c\n\ngas = [{} for x in range(n)]\nhighs = [[0,0] for x in range(n)]\n\npath = [(0,0)]\n\nind = 0\n\nwhile ind < len(path):\n    cur, par = path[ind]\n    edges = graph[cur]\n    for x in edges:\n        if x != par:\n            path.append((x,cur))\n    ind += 1\n\ndef mostGas(node,parent):\n    edges = graph[node]\n    high = w[node]\n    high2 = w[node]\n    \n    for x in edges:\n        if x != parent:\n            gas[node][x] = highs[x][0] + w[node] - edges[x]\n            if gas[node][x] > high:\n                high,high2 = gas[node][x], high\n            elif gas[node][x] > high2:\n                high2 = gas[node][x]\n    highs[node] = [high,high2]\n    return high\n\n'''def fillIn(node,parent):\n    edges = graph[node]\n    high,high2 = highs[node]\n    for x in edges:\n        if x != parent:\n            if gas[node][x] == high:\n                gas[x][node] = high2 - edges[x]\n            else:\n                gas[x][node] = high - edges[x]\n            if gas[x][node] > highs[x][0]:\n                highs[x] = [gas[x][node], highs[x][0]]\n            elif gas[x][node] > highs[x][1]:\n                highs[x][1] = gas[x][node]\n            fillIn(x,node)'''\n    \nfor x,y in path[::-1]:\n    mostGas(x,y)\n#fillIn(0,0)\n\nhigh = 0\n\nfor x in range(n):\n    high = max(high, highs[x][0]+highs[x][1]-w[x])\nprint(high)\n"]
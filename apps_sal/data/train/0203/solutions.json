["class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         def f(n):\n             ret = 1\n             for i in range(1, n+1):\n                 ret *= i\n             return ret\n         return f(m+n-2)//(f(m-1)*f(n-1))", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         sol = [[0 for j in range(n)] for i in range(m)]\n         sol[0][0] = 1\n         for i in range(0, m ):\n             for j in range(0, n ):\n                 if i == 0 or j == 0: sol[i][j] = 1\n                 else: sol[i][j] = sol[i-1][j] + sol[i][j-1]\n         \n         return sol[-1][-1]", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         counts = {}\n         counts[(1, 1)] = 1\n         for r in range(2, m+ 1):\n             counts[(r, 1)] = 1\n         for c in range(2, n + 1):\n             counts[(1, c)] = 1\n         for i in range(2, m +1):\n             for j in range(2, n + 1):\n                 counts[(i, j)] = counts[(i - 1, j)] + counts[(i, j -1)]\n         return counts[(m, n)]\n             \n             \n     def temp(self, m, n):\n         cache = {}\n         def go(m, n):\n             if m == 1 and n == 1:\n                 return 1\n             count = 0\n             if m > 1:\n                 if (m -1, n) not in cache:\n                     cache[(m-1, n)] = go(m-1, n)\n                 count += cache[(m-1, n)]\n             if n > 1:\n                 if (m, n - 1) not in cache:\n                     cache[(m, n-1)] = go(m, n-1)\n                 count += cache[(m, n -1)]\n             return count\n         return go(m, n)", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         a = m - 1\n         b = n - 1\n         ret = 1\n         for i in range(b):\n             ret = ret * (a+b-i) / (b-i)\n         return round(ret)", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         num_paths = [[0 for _ in range(n)] for _ in range(m)]\n         for i in range(m):\n             for j in range(n):\n                 above = num_paths[i-1][j] if i > 0 else 0\n                 left = num_paths[i][j-1] if j > 0 else 0\n                 num_paths[i][j] = above + left\n                 if i==0 and j==0:\n                     num_paths[0][0] = 1\n         return num_paths[m-1][n-1]\n", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         aux = [[1 for x in range(n)] for x in range(m)]\n         for i in range(1, m):\n             for j in range(1, n):\n                 aux[i][j] = aux[i][j-1]+aux[i-1][j]\n         return aux[-1][-1]\n", "class Solution:\n     def __init__(self):\n         self.dp = [[0 for _ in range(101)] for _ in range(101)]\n     def go(self, x, y, m, n):\n         if self.dp[x][y] == 0:\n             if x == m or y == n:\n                 self.dp[x][y] = 0\n             elif x == m - 1 and y == n - 1:\n                 self.dp[x][y] = 1\n             elif x == m - 1 and y == n-1:\n                 self.dp[x][y] = 1\n             else:\n                 self.dp[x][y] = self.go(x+1, y, m, n) + self.go(x, y+1, m, n)\n         return self.dp[x][y]\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         return self.go(0, 0, m, n)\n", "class Solution:\n     import math\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if m==1 or n==1:\n             return 1\n         r,c = m-1, n-1\n         return int(math.factorial(r+c)/(math.factorial(r)*math.factorial(c)))\n", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if 0 in (m,n):return 0\n         results = [[1] * n]*m\n         for i in range(1, m):\n             for j in range(1, n):\n                 results[i][j] = results[i-1][j] + results[i][j-1]\n         return results[m-1][n-1]", "class Solution:\n     def uniquePaths(self, m, n, memo = None):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if m == 1 and n == 1:\n             return 1\n         if m < 1 or n < 1:\n             return 0\n         \n         if not memo:\n             memo = [[0 for i in range(n+1)] for j in range(m+1)]\n         \n         if memo[m][n]:\n             return memo[m][n]\n         else:\n             memo[m][n] = self.uniquePaths(m-1, n, memo) + self.uniquePaths(m, n-1, memo)\n             return memo[m][n]\n         \n         \n", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         M = [[1 for _ in range(n)] for _ in range(2)]\n         for i in range(m-1, -1, -1):\n             for j in range(n-1, -1, -1):\n                 if i == m-1 or j == n-1: continue\n                 else: M[i%2][j] = M[(i+1)%2][j] + M[i%2][j+1]\n         return M[0][0]", "class Solution:\n     def paths(self,m,n,a,b,memo):\n         if m>a or n>b:\n             return 0\n         if m==a and n==b:\n             return 1\n         if str(m)+\" \"+str(n) not in memo:\n             memo[str(m)+\" \"+str(n)] = self.paths(m+1,n,a,b,memo) + self.paths(m,n+1,a,b,memo)\n \n         return memo[str(m)+\" \"+str(n)]\n         \n         \n     def uniquePaths(self, m, n):\n         memo =  dict()\n         return(self.paths(0,0,m-1,n-1,memo))", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n     \n         matrix = [[0 for j in range(n)] for i in range(m)]\n         \n         matrix[0][0] = 1\n         \n         for i in range(m):\n             for j in range(n):\n                 if i == 0 and j == 0:\n                     continue\n                 elif i == 0:\n                     matrix[i][j] = matrix[i][j-1]\n                 elif j == 0:\n                     matrix[i][j] = matrix[i-1][j]\n                 else:\n                     matrix[i][j] = matrix[i][j-1]+matrix[i-1][j]\n         return matrix[m-1][n-1]\n                     \n", "class Solution:\n     def uniquePaths(self, m, n):\n         \"\"\"\n         :type m: int\n         :type n: int\n         :rtype: int\n         \"\"\"\n         all=m-1+n-1\n         x=1\n         y=1\n         for i in range(m-1):\n             x=x*(all-i)\n             y=y*(i+1)\n         return x//y\n             \n"]
["import re\n\nclass Me(object):\n    def __init__(self): self.x, self.y, self.dx, self.dy = 0,0,-1,0\n    def move(self, n):  self.x += n*self.dx ; self.y += n*self.dy\n    def back(self):     self.dx *= -1 ; self.dy *= -1\n    def turn(self, d):  self.dx,self.dy = (self.dy * (-1)**(d=='l'), 0) if self.dy else (0, self.dx * (-1)**(d=='r'))\n    def where(self):    return [self.x, self.y]\n    def __str__(self):  return f'x,y={self.x},{self.y} (dx,dy={self.dx},{self.dy})'\n\nme = Me()\n\ndef i_am_here(path):\n    for v in re.findall(r'\\d+|.', path):\n        if   v in 'RL': me.back()\n        elif v in 'rl': me.turn(v)\n        else:           me.move(int(v))\n    return me.where()", "import re\n\nfacing = 0                                                                  # directions - [0,1,2,3]\ncurrent_position = [0, 0]\n\ndef i_am_here(path):\n    nonlocal current_position, facing\n                                                                            \n    movement_dict = {'r':1, 'l':-1, 'R':2, 'L':-2}                          # used to update the facing direction  \n    walk_direction = {0: (-1, 0),1: (0, 1),2: (1, 0),3: (0, -1)}            # used to walk in the facing direction\n    \n    for l in re.findall('\\d+|\\D', path):\n        if l.isalpha():\n            facing = (facing + movement_dict[l]) % 4\n        else:\n            no_of_steps = int(l)\n            current_position[0] += walk_direction[facing][0] * no_of_steps\n            current_position[1] += walk_direction[facing][1] * no_of_steps\n            \n    return current_position", "import re\nimport numpy as np\n\nR = np.array([[0,-1],[1,0]])\nd = {'R':R@R,'L':R@R,'r':R,'l':-R}\ndirection = np.array([1,0])\npoint = np.zeros(2, 'int')\n\ndef i_am_here(path):\n    nonlocal direction, point\n    for command in re.findall(r'(\\d+|[RrLl])', path):\n        if command.isdigit():\n            point -= direction * int(command)\n        else:\n            direction = direction @ d[command]\n    return list(point)", "import re\n\nx = 0\ny = 0\ndirection = 0\ndirections = [(-1,0), (0,1), (1,0), (0,-1)]\n\ndef i_am_here(path):\n    nonlocal x, y, direction\n    for c in re.findall(r'\\d+|[rlRL]', path):\n        if c == 'r': direction = (direction + 1) % 4\n        elif c == 'l': direction = (direction - 1) % 4\n        elif c == 'R': direction = (direction + 2) % 4\n        elif c == 'L': direction = (direction - 2) % 4\n        else:\n            dx, dy = directions[direction]\n            x += int(c)*dx\n            y += int(c)*dy\n    return [x, y]", "direction = 0\nx, y = 0, 0\n\ndef i_am_here(path):\n    nonlocal direction\n    nonlocal x, y\n    i = 0\n    while i < len(path):\n        rd = reldir.get(path[i])\n        if rd is not None:\n            direction = (direction + rd) % 4\n            i += 1\n        else:\n            j = i\n            while i < len(path) and path[i].isdigit():\n                i += 1\n            n = int(path[j:i])\n            x += n * dx[direction]\n            y += n * dy[direction]\n    return [y, x]\n\nreldir = dict(r=1, l=-1, L=2, R=2)\ndx = 0, 1, 0, -1\ndy = -1, 0, 1, 0\n", "direction = [(1, 0), (0, 1), (-1, 0), (0, -1)]\noperations = {'l': +1, 'r': -1, 'L': -2, 'R': 2}\nvector = 2\nposition = [0, 0]\n\ndef i_am_here(path):\n    nonlocal vector, position\n    step = 0\n    for c in path:\n        if c.isnumeric():\n            step = step * 10 + int(c)\n        else:\n            if step > 0:\n                position = [position[0] + direction[vector][0]*step, position[1] + direction[vector][1]*step]\n                step = 0\n            step = 0\n            o = operations.get(c)\n            vector += o\n            vector %= len(direction)\n    if step > 0:\n        position = [position[0] + direction[vector][0] * step, position[1] + direction[vector][1] * step]\n    return position\n", "import re\nmoves={0:(-1,0), 1:(0,1), 2:(1,0), 3:(0,-1)}\nrotate={'r':1, 'l':-1, 'R':2, 'L':2}\nx,y,d=0,0,0\ndef i_am_here(path):\n    nonlocal x,y,d\n    for m in re.findall(r'(r|R|l|L|\\d+)',path):\n        if m.isalpha():\n            d=(d+rotate[m])%4\n        else:\n            dx,dy=moves[d]\n            x,y=x+dx*int(m),y+dy*int(m)\n    return [x,y]", "x = 0\ny = 0\nheading = 0\n\ndef plus(cpl1, cpl2, factor):\n    return [cpl1[0] + cpl2[0] * factor, cpl1[1] + cpl2[1] * factor]\n\nheadings = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n\ndef change_heading(heading, character):\n    if character == \"l\":\n        return (heading + 1) % 4\n    if character == \"r\":\n        return (heading - 1) % 4\n    if character == \"L\":\n        return (heading - 2) % 4\n    if character == \"R\":\n        return (heading - 2) % 4\ndef i_am_here(path):\n    nonlocal x\n    nonlocal y\n    nonlocal heading\n    buffnum = \"\"\n    i = 0\n    while i < len(path):\n        character = path[i]\n        if '0' <= character <= '9':\n            buffnum += character\n        else:\n            if buffnum != \"\":\n                [x, y] = plus([x, y], headings[heading], int(buffnum))\n                buffnum = \"\"\n            heading = change_heading(heading, character)\n        i += 1\n    if buffnum != \"\":\n        [x, y] = plus([x, y], headings[heading], int(buffnum))\n    return [x, y]", "def split_path(s):\n    while s:\n        i = 0\n        for c in s:\n            if c not in \"RLrl\":\n                break\n            i += 1\n            yield c\n        n = 0\n        while i < len(s) and s[i].isdigit():\n            n = 10 * n + int(s[i])\n            i += 1\n        s = s[i:]\n        if n:\n            yield n\n\n\ndef turn(d, r):\n    opt = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n    i = opt.index(d) + {\"r\": 1, \"R\": 2, \"l\": -1, \"L\": -2}[r]\n    return opt[i % len(opt)]\n\n\ndef step(p, d, k):\n    x, y = p\n    dx, dy = d\n    return [x + dx * k, y + dy * k]\n\n\ndef i_am_here(path, d={\"pos\": [0, 0], \"dir\": [-1, 0]}):\n    for p in split_path(path):\n        if isinstance(p, int):\n            d[\"pos\"] = step(d[\"pos\"], d[\"dir\"], p)\n        else:\n            d[\"dir\"] = turn(d[\"dir\"], p)\n    return d[\"pos\"]", "import re\n\npos = [0, 0]    # pos-x is down, pos-y is right\ndirection = 0   # 0=up, 1=right, 2=down, 3=left\n\ndef i_am_here(path):\n    commands = list(re.findall(\"(\\d+|[lrLR])\", path))\n    nonlocal direction, pos\n    for command in commands:\n        if command.isdigit():\n            steps = int(command)\n            if direction % 2 == 0:\n                pos[0] += steps if direction == 2 else -steps\n            else:\n                pos[1] += steps if direction == 1 else -steps\n        elif command == \"r\":\n            direction = (direction + 1) % 4\n        elif command == \"l\":\n            direction = (direction - 1) % 4\n        else:\n            direction = (direction + 2) % 4\n    return pos"]
["import itertools\nclass Nonogram:\n    poss = {(1,1,1): set([(1,0,1,0,1)]),\n            (1,1):   set([(0,0,1,0,1),(0,1,0,1,0),(1,0,1,0,0),(0,1,0,0,1),(1,0,0,1,0),(1,0,0,0,1)]),\n            (1,2):   set([(1,0,1,1,0),(1,0,0,1,1),(0,1,0,1,1)]),\n            (1,3):   set([(1,0,1,1,1)]),\n            (2,1):   set([(1,1,0,1,0),(1,1,0,0,1),(0,1,1,0,1)]),\n            (2,2):   set([(1,1,0,1,1)]),\n            (3,1):   set([(1,1,1,0,1)]),\n            (1,):    set([(0,0,0,0,1),(0,0,0,1,0),(0,0,1,0,0),(0,1,0,0,0),(1,0,0,0,0)]),\n            (2,):    set([(0,0,0,1,1),(0,0,1,1,0),(0,1,1,0,0),(1,1,0,0,0)]),\n            (3,):    set([(0,0,1,1,1),(0,1,1,1,0),(1,1,1,0,0)]),\n            (4,):    set([(0,1,1,1,1),(1,1,1,1,0)]),\n            (5,):    set([(1,1,1,1,1)])}\n    \n    def __init__(self, clues):\n        self.h,self.w=(tuple(Nonogram.poss[clue] for clue in side) for side in clues)\n\n    def solve(self):\n        for r in itertools.product(*self.w):\n            if all(c in self.h[i] for i,c in enumerate(zip(*r))): return r\n", "from copy import deepcopy\n\nclass Nonogram:\n    \n    POS = {(2,2):   ((1,1,0,1,1),),\n           (5,):    ((1,1,1,1,1),),\n           (1,1,1): ((1,0,1,0,1),),\n           (1,3):   ((1,0,1,1,1),),\n           (3,1):   ((1,1,1,0,1),),\n           (4,):    ((1,1,1,1,0), (0,1,1,1,1)),\n           (1,2):   ((1,0,0,1,1), (1,0,1,1,0), (0,1,0,1,1)),\n           (2,1):   ((1,1,0,0,1), (1,1,0,1,0), (0,1,1,0,1)),\n           (3,):    ((1,1,1,0,0), (0,1,1,1,0), (0,0,1,1,1)),\n           (2,):    ((1,1,0,0,0), (0,1,1,0,0), (0,0,1,1,0), (0,0,0,1,1)),\n           (1,):    ((1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1)),\n           (1,1):   ((1,0,1,0,0), (1,0,0,1,0), (1,0,0,0,1), (0,1,0,1,0), (0,1,0,0,1), (0,0,1,0,1))}\n    \n    def __init__(self, clues): self.clues = {'V': clues[0], 'H': clues[1]}\n    \n    \n    def solve(self):\n        grid = { (d,z): list(self.POS[ self.clues[d][z] ]) for d in 'VH' for z in range(5)}\n        \n        changed = True\n        while changed:\n            changed = False\n            \n            for x in range(5):\n                for y in range(5):\n                \n                    tupH, iH, tupV, iV = ('H',x), y, ('V',y), x\n                    if len(grid[tupH]) == 1 and len(grid[tupV]) == 1: continue\n                    \n                    vH = { v[iH] for v in grid[tupH] }\n                    vV = { v[iV] for v in grid[tupV] }\n                    target = vH & vV\n                    \n                    if len(vH) == 2 and len(target) == 1:\n                        changed = True\n                        grid[tupH] = [t for t in grid[tupH] if t[iH] in target]\n                        \n                    if len(vV) == 2 and len(target) == 1:\n                        changed = True\n                        grid[tupV] = [t for t in grid[tupV] if t[iV] in target]\n        \n        return tuple( grid[('H',n)][0] for n in range(5) )", "import re\nimport numpy as np\n\nclass Nonogram:\n    def __init__(self, clues):\n        self.clues = clues\n        self.possible_rows, self.possible_cols = \\\n            [[self.possible_cells(len(clues[i]), c) for c in clues[1 - i]] for i in range(2)]\n\n    def possible_cells(self, n, clues):\n        if clues == () or clues == (0,):\n            return ['0' * n]\n        min_width = sum(clues) + len(clues) - 1\n        assert min_width <= n\n        if len(clues) == 1:\n            return [('0' * i + '1' * clues[0]).ljust(n, '0') for i in range(n - clues[0] + 1)]\n        res = []\n        for i in range(0, n - min_width + 1):\n            start = '0' * i + '1' * clues[0] + '0'\n            res += [start + p for p in self.possible_cells(n - len(start), clues[1:])]\n        return res\n\n    def solve(self):\n        w, h = len(self.possible_cols), len(self.possible_rows)\n        old_grid, grid = None, '\\n'.join(['.' * w] * h)\n        while old_grid != grid and grid.find('.') != -1:\n            old_grid = grid\n            grid = ''.join(self.update_cells(row, p) for row, p in\n                           zip(grid.split('\\n'), self.possible_rows))\n            grid = ''.join(self.update_cells(col, p) for col, p in\n                           zip((grid[i:: w] for i in range(w)), self.possible_cols))\n            grid = '\\n'.join(grid[row:: h] for row in range(h))\n        return tuple(tuple(-1 if c == '.' else int(c) for c in r) for r in grid.split('\\n'))\n\n    @staticmethod\n    def update_cells(cells, possibilities):\n        if cells.find('.') == -1:\n            return cells\n        not_matches = [i for i, answer in enumerate(possibilities) if not re.match(cells, answer)]\n        for i in not_matches[:: -1]:\n            possibilities.pop(i)\n        assert len(possibilities) != 0\n        if len(possibilities) == 1:\n            return possibilities[0]\n        n, stack = len(cells), ''.join(possibilities)\n        vote = (set(stack[i:: n]) for i in range(0, n))\n        return ''.join(s.pop() if len(s) == 1 else '.' for s in vote)", "from itertools import groupby, product\n\nclass Nonogram:\n    def __init__(self, clues):\n        self.clues = clues\n    def solve(self):\n        for p in product(\n            *[[p for p in product(range(2),repeat=5)\n            if sum(p)==sum(t) and tuple(len(list(g)) for k,g in groupby(p) if k) == t]\n            for t in self.clues[1]]\n        ):\n            if all(tuple(len(list(g)) for k,g in groupby(p) if k) == t \n                for p, t in zip([v for v in zip(*p)], self.clues[0])):\n                return p", "from itertools import product\n\nclass Nonogram:\n    \n    POS = {(2,2):   ((1,1,0,1,1),),\n           (5,):    ((1,1,1,1,1),),\n           (1,1,1): ((1,0,1,0,1),),\n           (1,3):   ((1,0,1,1,1),),\n           (3,1):   ((1,1,1,0,1),),\n           (4,):    ((1,1,1,1,0), (0,1,1,1,1)),\n           (1,2):   ((1,0,0,1,1), (1,0,1,1,0), (0,1,0,1,1)),\n           (2,1):   ((1,1,0,0,1), (1,1,0,1,0), (0,1,1,0,1)),\n           (3,):    ((1,1,1,0,0), (0,1,1,1,0), (0,0,1,1,1)),\n           (2,):    ((1,1,0,0,0), (0,1,1,0,0), (0,0,1,1,0), (0,0,0,1,1)),\n           (1,):    ((1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1)),\n           (1,1):   ((1,0,1,0,0), (1,0,0,1,0), (1,0,0,0,1), (0,1,0,1,0), (0,1,0,0,1), (0,0,1,0,1))}\n\n    def __init__(self, clues):\n        self.clues = clues\n\n    def solve(self):\n        for p in product(*( self.POS[c] for c in self.clues[0] )):\n            board = list(zip(*p))\n            for z in range(5):\n                if board[z] not in self.POS[self.clues[1][z]]: break\n            else:\n                return tuple(tuple(l) for l in board)", "from itertools import permutations\n\ndef count_blacks (list):\n    count = 0\n    chain = False\n    blacks = []\n    for i in list:\n        if i == 1:\n            if chain == False:\n                chain = True\n                count += 1\n            else:\n                count += 1\n        if i != 1:\n            if chain == False:\n                continue\n            else:\n                blacks.append(count)\n                count = 0\n                chain = False\n\n    if chain == True:\n        blacks.append(count)\n    return tuple(blacks)\n    \nclass Row:\n    def __init__(self,nrow,length,blacks):\n        self.nrow = nrow\n        self.length = length\n        self.blacks = blacks\n        self.combs = []\n        \n        if len(self.blacks) == 1 and self.blacks[0] > 0:\n            for i in range(self.length - self.blacks[0]+1):\n                self.combs.append([0 for i in range(i)]+[1 for j in range(self.blacks[0])]+[0 for k in range(self.length-(i+self.blacks[0]))])\n          \n        elif len(self.blacks) > 1:\n            self.totalblacks = 0\n            for i in self.blacks:\n                self.totalblacks += i\n            self.blanks = self.length - self.totalblacks\n            self.items=[]\n            for i in range(self.blanks):\n                self.items.append(0)\n            for i in range(self.totalblacks):\n                self.items.append(1)\n            for p in permutations(self.items):\n                if p not in self.combs and count_blacks(p) == self.blacks:\n                    self.combs.append(p)\n            \n        \n    def __str__ (self):\n        return (str(self.nrow)+\",\"+str(self.length)+\",\"+str(self.blacks))\n    \nclass Col:\n    def __init__(self,ncol,length,blacks):\n        self.ncol = ncol\n        self.length = length\n        self.blacks = blacks\n        self.combs = []\n        \n        if len(self.blacks) == 1 and self.blacks[0] > 0:\n            for i in range(self.length - self.blacks[0]+1):\n                self.combs.append([0 for i in range(i)]+[1 for j in range(self.blacks[0])]+[0 for k in range(self.length-(i+self.blacks[0]))])\n    \n        elif len(self.blacks) > 1:\n            self.totalblacks = 0\n            for i in self.blacks:\n                self.totalblacks += i\n            self.blanks = self.length - self.totalblacks\n            self.items=[]\n            for i in range(self.blanks):\n                self.items.append(0)\n            for i in range(self.totalblacks):\n                self.items.append(1)\n            for p in permutations(self.items):\n                if p not in self.combs and count_blacks(p) == self.blacks:\n                    self.combs.append(p)\n               \n    def __str__ (self):\n        return (str(self.ncol)+\",\"+str(self.length)+\",\"+str(self.blacks))\n\nclass Nonogram:\n    def __init__(self, clues):\n        self.nrows = len(clues[1])\n        self.ncols = len(clues[0])\n        self.board = [[0 for i in range(self.ncols)] for j in range(self.nrows)]\n        self.rclues = clues[1]\n        self.cclues = clues[0]\n        self.rows = []\n        self.cols = []\n        for i in range(self.nrows):\n            self.rows.append(Row(i,self.ncols,self.rclues[i]))\n        for j in range(self.ncols):\n            self.cols.append(Col(j,self.nrows,self.cclues[j]))\n            \n\n    def solve(self):\n        self.solved = False\n        while self.solved == False:\n            for row in self.rows:\n                if len(row.combs) > 0:\n                    for c in range(row.length):\n                        self.check = []\n                        for r in row.combs:\n                            self.check.append(r[c] == 1)\n                        if all(self.check):\n                            self.board[row.nrow][c] = 1\n                            self.crosscheck = []\n                            for i in self.cols[c].combs:\n                                if i[row.nrow] != 1:\n                                    self.crosscheck.append(i)\n                            for d in self.crosscheck:\n                                self.cols[c].combs.remove(d)\n            for row in self.rows:\n                if len(row.combs) > 0:\n                    for c in range(row.length):\n                        self.check = []\n                        for r in row.combs:\n                            self.check.append(r[c] == 0)\n                        if all(self.check):\n                            self.crosscheck = []\n                            for i in self.cols[c].combs:\n                                if i[row.nrow] != 0:\n                                    self.crosscheck.append(i)\n                            for d in self.crosscheck:\n                                self.cols[c].combs.remove(d)\n\n            for col in self.cols:\n                if len(col.combs) > 0:\n                    for c in range(col.length):\n                        self.check = []\n                        for r in col.combs:\n                            self.check.append(r[c] == 1)\n                        if all(self.check):\n                            self.board[c][col.ncol] = 1\n                            self.crosscheck = []\n                            for i in self.rows[c].combs:\n                                if i[col.ncol] != 1:\n                                    self.crosscheck.append(i)\n                            for d in self.crosscheck:\n                                self.rows[c].combs.remove(d)\n\n            for col in self.cols:\n                if len(col.combs) > 0:\n                    for c in range(col.length):\n                        self.check = []\n                        for r in col.combs:\n                            self.check.append(r[c] == 0)\n                        if all(self.check):\n                            self.crosscheck = []\n                            for i in self.rows[c].combs:\n                                if i[col.ncol] != 0:\n                                    self.crosscheck.append(i)\n                            for d in self.crosscheck:\n                                self.rows[c].combs.remove(d)\n            \n            self.checksolutions = []\n            for r in range(self.nrows):\n                self.checksolutions.append(count_blacks(self.board[r])==self.rclues[r])\n            for c in range(self.ncols):\n                self.transposedboard = [[self.board[j][i] for j in range(self.ncols)]for i in range(self.nrows)]\n                self.checksolutions.append(count_blacks(self.transposedboard[c])==self.cclues[c])\n            if all(self.checksolutions):\n                self.solved = True\n\n                self.solution = []\n        for r in self.board:\n            self.solution.append(tuple(r))\n        return tuple(self.solution)", "from functools import reduce\nfrom typing import Tuple, List, Optional, Sequence\n\n\nclass Box:\n    def __init__(self, x: int, y: int, value: Optional[int]):\n        self.value = value\n        self.x = x\n        self.y = y\n\n    def to_int(self):\n        return self.value if self.value else 0\n\n    def mapper(self) -> str:\n        if self.value is None:\n            return 'S'\n        elif self.value == 0:\n            return \"#\"\n        else:\n            return \"\u2588\"\n\n\n# TODO it should take List[Clue] as argument\n# TODO boeard should be List[List[Box]]\n\n\nclass Clue:\n    def __init__(self, index: int, clue: Sequence[int], elements: List[Box]):\n        self.index: int = index\n        self.clue: Sequence[int] = clue\n        self.elements: List[Box] = elements\n\n    @staticmethod\n    def match_constrains(initial: Sequence[int], constrains: List[Box]):\n        # print(\"comparing: \", initial, [i.value for i in constrains] )\n\n        def tmp(element: int, constrain: Box):\n            if constrain.value is None:\n                # print(\"constrain is None\")\n                return True\n\n            return constrain.value == element\n\n        ddd =  all((tmp(data, req) for data, req in zip(initial, constrains)))\n        # print(\"comparing: \", initial, [i.value for i in constrains], ddd )\n        return ddd;\n\n    # TODO: collect always to the same list\n\n    def generate_combinations(self, initial: Sequence[int] = (), to_be_marked: int = -1) -> List[Sequence[int]]:\n\n        if to_be_marked == -1:\n            to_be_marked = sum(self.clue)\n\n        if not Clue.match_constrains(initial, self.elements):\n            return []\n        elif len(initial) > len(self.elements):\n            return []\n        elif len(initial) == len(self.elements):\n            arr = [it for it in initial if it == 1]\n            if to_be_marked != len(arr):\n                return []\n            return [initial]\n        elif len(self.clue) == 0:\n            ret: List[int] = [i for i in initial]\n            for i in range(0, len(self.elements) - len(initial)):\n                ret.append(0)\n            if Clue.match_constrains(ret, self.elements):\n                return [ret]\n            return []\n\n        new_initial: List[int] = [i for i in initial]\n        new_initial.append(0)\n        zero: List[Sequence[int]] = self.generate_combinations(new_initial, to_be_marked)\n\n        if self.clue:\n            new_clue: Clue = Clue(self.index, self.clue[1:], self.elements)\n            tab: List[int] = [i for i in initial]\n            tab.extend([1 for __ in range(0, self.clue[0])])\n            if( len(tab)< len(self.elements)): tab.append(0)\n            one = new_clue.generate_combinations(tab, to_be_marked)\n            zero.extend(one)\n        return zero\n\n    @staticmethod\n    def get_marked_size(clue: Sequence[int]):\n        return reduce(lambda x, y: x + y, clue, 0)\n\n    @staticmethod\n    def get_minimal_size(clue: Sequence[int]):\n        return len(clue) + Clue.get_marked_size(clue) - 1\n\n    def contains_all(self, stripe):\n        return len([1 for element in stripe if element == 1]) == self.get_marked_size(self.clue)\n\n    @staticmethod\n    def get_commons(possible_solutions):\n        # b is a list of lists here\n        def check_all_the_same(lst):\n            if lst.count(lst[0]) == len(lst):\n                return lst[0]\n            return None\n\n        return [check_all_the_same(lst) for lst in zip(*possible_solutions)]\n\n\ndef get_v_stripe(board, index):\n    return [element[index] for element in board]\n\n\ndef get_h_stripe(board, index):\n    return board[index]\n\n\nclass Nonogram:\n\n    def __init__(self, clues: Tuple[Sequence[Sequence[int]], Sequence[Sequence[int]]]):\n        h_clues, v_clues = clues\n        self.width: int = len(h_clues)\n        self.height: int = len(v_clues)\n        self.board: List[List[Box]] = [[Box(x, y, None) for y in range(0, self.width)] for x in range(0, self.height)]\n        self.v_clues = [Clue(index, clue, [line[index] for line in self.board]) for index, clue in enumerate(clues[0])]\n        self.h_clues = [Clue(index, clue, self.board[index]) for index, clue in enumerate(clues[1])]\n\n    def solve(self) -> List[List[int]]:\n        missing = [(self.width - clue.get_minimal_size(clue.clue), clue) for clue in self.v_clues]\n        missing.sort(key=lambda x: x[0])\n\n        for i in range(0, 10):\n            self.print_board()\n            print((\"loop \", i))\n            for clue in self.v_clues:\n                comb = clue.generate_combinations()\n                print((\"v: %s : %s \" % (clue.clue, Clue.get_commons(comb))))\n                for index, value in enumerate(Clue.get_commons(comb)):\n                    if value is not None:\n                        self.board[index][clue.index].value = value\n\n            for clue in self.h_clues:\n                comb = clue.generate_combinations()\n                print((\"h: %s : %s \" % (clue.clue, Clue.get_commons(comb))))\n                for index, value in enumerate(Clue.get_commons(comb)):\n                    if value is not None:\n                        self.board[clue.index][index].value = value\n\n        self.print_board()\n        return tuple([tuple([box.to_int() for box in line]) for line in self.board])\n\n    def print_board(self) -> None:\n        max_size: int = max(len(clue.clue) for clue in self.v_clues)\n        max_width: int = max(len(clue.clue) for clue in self.h_clues)\n        prefix: str = ' ' * (2 * max_width + 3)\n\n        def expand_empty_header(clues: Sequence[int], size: int, ending: str) -> List[str]:\n            empty_header = [\" \" for __ in range(0, size)]\n            empty_header.extend(list(map(str, clues)))\n            empty_header.append(ending)\n            return empty_header\n\n        headers = [expand_empty_header(clue.clue, max_size, \"-\")[-max_size - 1:] for clue in self.v_clues]\n        for index in range(0, max_size):\n            print((prefix + \" \".join([str(e[index]) for e in headers])))\n\n        borders = [expand_empty_header(clue.clue, max_width, \"|\")[-max_size - 1:] for clue in self.h_clues]\n\n        for border, line in zip(borders, self.board):\n            d = \" \".join([str(d) for d in border]) + \" \".join([d.mapper() for d in line])\n\n            print(d)\n\n\n# TODO: Finish this!\ndef solve(clues, width: int, height: int) -> List[List[int]]:\n    \"\"\"\n    :param height:\n    :type width: object\n    \"\"\"\n    return Nonogram(clues).solve()\n", "from itertools import permutations\n\nclass Nonogram:\n    def __init__(self, clues):\n        self.cols = clues[0]\n        self.rows = clues[1]\n        self.dim = len(self.cols)\n        \n        self.field = [[' ' for j in range(self.dim)] for i in range(self.dim)]\n        self.rows_p = [None] * self.dim\n        self.cols_p = [None] * self.dim\n        \n    def __str__(self):\n        max_hint_length = (self.dim+1)//2\n        \n        rows = []\n        for i in range(max_hint_length):\n            row = [\" \" if len(self.cols[d]) + i < max_hint_length else str(self.cols[d][len(self.cols[d])-max_hint_length+i]) for d in range(self.dim)]\n            rows.append(' ' * (max_hint_length) + '|' + ''.join(row))\n        rows.append('-' * (max_hint_length) + '+' + '-' * self.dim)\n        \n        for i in range(self.dim):\n            row = [\" \" if len(self.rows[i]) + j < max_hint_length else str(self.rows[i][len(self.rows[i])-max_hint_length+j]) for j in range(max_hint_length)]\n            row_field = [str(self.field[i][d]) for d in range(self.dim)]\n            rows.append(''.join(row) + '|' + ''.join(row_field))\n            \n        return '\\n'.join(rows)\n    \n    def possibilities(self, clues, sure=None):\n        poss = [''.join(pp) for pp in set(permutations('0' * len(clues) + '.' * (self.dim - sum(clues)))) if '00' not in ''.join(pp)]\n        for x in range(len(poss)):\n            for num in clues:\n                poss[x] = poss[x].replace('0', 'X'*num, 1)\n        if sure is not None:\n            poss = list([p for p in poss if all([sure[d] == ' ' or sure[d] == p[d] for d in range(self.dim)])])\n        return poss\n    \n    def sure(self, poss):\n        return ''.join(['X' if all([p[d] == 'X' for p in poss]) else ('.' if all([p[d] == '.' for p in poss]) else ' ') for d in range(self.dim)])\n    \n    def update_rows_p(self, i, j, s):\n        if self.rows_p[i] is not None:\n            self.rows_p[i] = list([poss for poss in self.rows_p[i] if poss[j] == s])\n            sure = self.sure(self.rows_p[i])\n            if not sure.isspace():\n                self.update_field(sure, i=i)\n    \n    def update_cols_p(self, i, j, s):\n        if self.cols_p[j] is not None:\n            self.cols_p[j] = list([poss for poss in self.cols_p[j] if poss[i] == s])\n            sure = self.sure(self.cols_p[j])\n            if not sure.isspace():\n                self.update_field(sure, j=j)\n\n    def update_field(self, sure, i=None, j=None):\n        if i is not None:\n            for j in range(self.dim):\n                if sure[j] in ('X', '.') and self.field[i][j] == ' ':\n                    self.field[i][j] = sure[j]\n                    self.update_cols_p(i, j, sure[j])\n        elif j is not None:\n            for i in range(self.dim):\n                if sure[i] in ('X', '.') and self.field[i][j] == ' ':\n                    self.field[i][j] = sure[i]\n                    self.update_rows_p(i, j, sure[i])\n    \n    def solve(self):\n        for i in range(self.dim):\n            poss = self.possibilities(clues=self.rows[i])\n            self.rows_p[i] = poss\n            \n            sure = self.sure(poss=poss)\n            if not sure.isspace():\n                self.update_field(sure, i=i)\n        \n        for j in range(self.dim):\n            poss = self.possibilities(clues=self.cols[j], sure=[self.field[i][j] for i in range(self.dim)])\n            self.cols_p[j] = poss\n            \n            sure = self.sure(poss=poss)\n            if not sure.isspace():\n                self.update_field(sure, j=j)\n        \n        return tuple(tuple(0 if c == '.' else 1 for c in r) for r in self.field)\n        \n", "class Nonogram:\n      \n    def __init__(self, clues):\n        self.size, self.colclues, self.rowclues = 5, clues[0], clues[1]\n        self.answer = [ [None] * self.size for _ in range(self.size) ]\n        \n    def possibilities(self):   \n        from itertools import combinations\n\n        colposs = []\n        for clue in self.colclues:\n            a = self.size - sum(clue) + 1\n            b = len(clue)\n            c = list(combinations(range(a),b))\n            d = []\n            for block in clue[:-1]:\n                d.append([1]*block + [0])\n            d.append([1]*clue[-1])     \n            colcombs = []\n            for thing in c:\n                combblock = []\n                e = d[:]\n                for i in range(a):\n                    if i in thing:\n                        combblock.append(e.pop(0))\n                    else:\n                        combblock.append([0])\n                comb = tuple([j for sublist in combblock for j in sublist])\n                colcombs.append(comb)\n            colposs.append(colcombs)        \n            \n        rowposs = []\n        for clue in self.rowclues:\n            a = self.size - sum(clue) + 1\n            b = len(clue)\n            c = list(combinations(range(a),b))\n            d = []\n            for block in clue[:-1]:\n                d.append([1]*block + [0])\n            d.append([1]*clue[-1])     \n            rowcombs = []\n            for thing in c:\n                combblock = []\n                e = d[:]\n                for i in range(a):\n                    if i in thing:\n                        combblock.append(e.pop(0))\n                    else:\n                        combblock.append([0])\n                comb = tuple([j for sublist in combblock for j in sublist])\n                rowcombs.append(comb)\n            rowposs.append(rowcombs)               \n        return [colposs,rowposs]\n\n    def colfill(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                allOne = True\n                allZero = True\n                for poss in self.colposs[i]:\n                    if poss[j] == 1:\n                        allZero = False\n                    else:\n                        allOne = False\n                if allOne:\n                    self.answer[j][i] = 1\n                elif allZero:\n                    self.answer[j][i] = 0\n\n    def rowfill(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                allOne = True\n                allZero = True\n                for poss in self.rowposs[i]:\n                    if poss[j] == 1:\n                        allZero = False\n                    else:\n                        allOne = False\n                if allOne:\n                    self.answer[i][j] = 1\n                elif allZero:\n                    self.answer[i][j] = 0  \n    \n    def colelim(self):\n        for i in range(self.size):\n            for poss in reversed(self.colposs[i]):\n                for j in range(self.size):\n                    if (not self.answer[j][i] is None) and self.answer[j][i] != poss[j]:\n                        self.colposs[i].remove(poss)\n                        break\n    \n    def rowelim(self):\n        for i in range(self.size):\n            for poss in reversed(self.rowposs[i]):\n                for j in range(self.size):\n                    if (not self.answer[i][j] is None) and self.answer[i][j] != poss[j]:\n                        self.rowposs[i].remove(poss)\n                        break\n    \n    def isSolved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.answer[i][j] is None:\n                    return False\n        return True        \n    \n    def solve(self):\n        from itertools import chain\n        poss = self.possibilities()\n        self.colposs, self.rowposs = poss[0], poss[1]   \n        while not self.isSolved():\n            self.colfill()\n            self.rowelim()\n            self.rowfill()\n            self.colelim()\n            \n        return tuple([tuple(row) for row in self.answer])", "class Nonogram:\n      \n    def __init__(self, clues):\n        self.size, self.colclues, self.rowclues = 5, clues[0], clues[1]\n        self.answer = [ [None] * self.size for _ in range(self.size) ]\n        \n    def possibilities(self):   \n        from itertools import product\n        \n        def check(clue,comb):\n            count = []\n            for i in range(self.size):\n                if comb[i] == 1:\n                    if i == 0 or comb[i-1] == 0:\n                        count.append(1)\n                    else:\n                        count[-1] += 1                             \n            return tuple(count) == clue  \n        \n        colposs = [ [comb for comb in product([1,0], repeat=self.size) if check(clue,comb)] for clue in self.colclues ] \n        rowposs = [ [comb for comb in product([1,0], repeat=self.size) if check(clue,comb)] for clue in self.rowclues ]   \n        return [colposs,rowposs]\n\n    def colfill(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                allOne = True\n                allZero = True\n                for poss in self.colposs[i]:\n                    if poss[j] == 1:\n                        allZero = False\n                    else:\n                        allOne = False\n                if allOne:\n                    self.answer[j][i] = 1\n                elif allZero:\n                    self.answer[j][i] = 0\n\n    def rowfill(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                allOne = True\n                allZero = True\n                for poss in self.rowposs[i]:\n                    if poss[j] == 1:\n                        allZero = False\n                    else:\n                        allOne = False\n                if allOne:\n                    self.answer[i][j] = 1\n                elif allZero:\n                    self.answer[i][j] = 0  \n    \n    def colelim(self):\n        for i in range(self.size):\n            for poss in reversed(self.colposs[i]):\n                for j in range(self.size):\n                    if (not self.answer[j][i] is None) and self.answer[j][i] != poss[j]:\n                        self.colposs[i].remove(poss)\n                        break\n    \n    def rowelim(self):\n        for i in range(self.size):\n            for poss in reversed(self.rowposs[i]):\n                for j in range(self.size):\n                    if (not self.answer[i][j] is None) and self.answer[i][j] != poss[j]:\n                        self.rowposs[i].remove(poss)\n                        break\n    \n    def isSolved(self):\n        for i in range(self.size):\n            for j in range(self.size):\n                if self.answer[i][j] is None:\n                    return False\n        return True        \n    \n    def solve(self):\n        from itertools import chain\n        poss = self.possibilities()\n        self.colposs, self.rowposs = poss[0], poss[1]   \n        while not self.isSolved():\n            self.colfill()\n            self.rowelim()\n            self.rowfill()\n            self.colelim()\n            \n        return tuple([tuple(row) for row in self.answer])\n        \n"]
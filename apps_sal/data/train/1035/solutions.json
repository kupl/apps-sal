["# cook your dish here\nfrom collections import namedtuple\n\nCurrentPosition = namedtuple('current_position', 'points, cell, pairs')\n\nT = int(input())\nfor _ in range(T):\n    R, C, N = map(int, input().split())\n    Sx, Sy = map(int, input().split())\n    tx = map(int, input().split())\n    ty = map(int, input().split())\n    tel_pairs = list(zip(tx, ty))\n    board = []\n    for _ in range(R):\n        board += [[int(c) for c in input().split()]]\n    \n    def explore(p):\n        next_pos = []\n        for i, (dx, dy) in enumerate(p.pairs):\n            sx, sy = p.cell\n            new_pairs = p.pairs[:i]+p.pairs[i+1:]\n            # case (+, +)\n            px, py = sx + dx, sy + dy\n            if px < R and py < C:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (+, -)\n            px, py = sx + dx, sy - dy\n            if px < R and 0 <= py:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (-, +)\n            px, py = sx - dx, sy + dy\n            if 0 <= px and py < C:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n            # case (-, -)\n            px, py = sx - dx, sy - dy\n            if 0 <= px and 0 <= py:\n                next_pos += [CurrentPosition(p.points+board[px][py], (px, py), new_pairs)]\n        return next_pos\n    \n    pos = [CurrentPosition(board[Sx][Sy], (Sx, Sy), tel_pairs)]\n    result = board[Sx][Sy]\n    while pos:\n        p = pos.pop(0)\n        if p.pairs:\n            pos += explore(p)\n        else:\n            result = max(result, p.points)\n        \n    print(result)  \n"]
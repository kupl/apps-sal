["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        \n        def dfs(node):\n            if not node:\n                return 2\n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            if left == 0 or right == 0:\n                self.res += 1\n                return 1\n            if left == 1 or right == 1:\n                return 2\n            else:\n                return 0\n            \n        self.res = 0\n        return (dfs(root) == 0) + self.res\n\n", "class Solution:\n    def minCameraCover(self, root):\n        self._res = 0\n        if self._dfs(root) == 0:\n            self._res += 1\n        return self._res\n    \n    # 0\u8868\u793a\u8fd9\u4e2a\u70b9\u6ca1\u6709\u88abcover\n    # 1\u8868\u793a\u8fd9\u4e2a\u70b9\u88abcover\u4e86\uff0c\u4f46\u662f\u6ca1\u6709camera\n    # 2\u8868\u793a\u8fd9\u4e2a\u70b9\u6709camera\n    def _dfs(self, node):\n        # \u7a7a\u70b9\u6211\u4eec\u4e5f\u8ba4\u4e3a\u88abcover\u4e86\n        # \u4f46\u662f\u6ca1\u6709camera\n        if not node:\n            return 1\n        \n        left = self._dfs(node.left)\n        right = self._dfs(node.right)\n        \n        # \u5982\u679c\u5de6\u8282\u70b9\u6216\u8005\u53f3\u8282\u70b9\u4e2d\u6709cover\u4e0d\u4f4f\u7684\n        # \u9700\u8981\u5728node\u4e0a\u52a0camera\u4e86\n        if left == 0 or right == 0:\n            self._res += 1\n            return 2\n        elif left == 2 or right == 2:\n            return 1\n        # \u6b64\u65f6\u5de6\u8282\u70b9\u548c\u53f3\u8282\u70b9\u80af\u5b9a\u90fd\u662f1\n        # \u8868\u793a\u5de6\u53f3\u5b69\u5b50\u90fd\u88abcover\u4f4f\u4e86\n        # \u6211\u4eec\u76f4\u63a5\u9000\u51fa\uff0c\u5728\u4e3b\u51fd\u6570\u91cc\u9762\u5904\u7406\u8fd9\u4e2anode\u5c31\u597d\u4e86\n        else:\n            return 0", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def minCameraCover(self, root: TreeNode) -> int:\n        dump1={}\n        \n        dump2={}\n        \n        def f(root):\n            if root==None:\n                return 0\n            if root in dump1:\n                return dump1[root]\n            ans=1+min(f(root.left), g(root.left, True))+min(f(root.right), g(root.right, True))\n            dump1[root]=ans\n            return ans\n        \n        def g(root, covered):\n            if root==None:\n                return 0\n            if (root, covered) in dump2:\n                return dump2[(root, covered)]\n            if root.left==None and root.right==None:\n                if covered:\n                    return 0\n                return float('inf')\n            ans=float('inf')\n            if not covered:\n                if root.left!=None:\n                    ans=f(root.left)+min(g(root.right, False), f(root.right))\n                if root.right!=None:\n                    ans=min(ans, f(root.right)+min(f(root.left), g(root.left, False)))\n            else:\n                ans=min(f(root.left), g(root.left, False))+min(f(root.right), g(root.right, False))\n            dump2[(root, covered)]=ans\n            return ans\n        \n        if root.left==None and root.right==None:\n            return 1\n        \n        return min(f(root), g(root, False))\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        if not root: \n            return 0\n        \n        def solve(node):\n            if not node: return 0,0,float('inf')\n            L = solve(node.left)\n            R = solve(node.right)\n            \n            dp0 = L[1] + R[1]\n            \n            dp1 = min(L[2] + min(R[1:]), R[2] + min(L[1:]))\n            dp2 = 1 + min(L) + min(R)\n            \n            return dp0, dp1, dp2\n        print(solve(root))\n        return min(solve(root)[1:])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    @lru_cache(None)\n    def helper(self, node, covered, camera):\n        if(node == None):\n            return 0  \n        if(camera):\n            return 1+self.helper(node.left,True,False)+self.helper(node.right, True, False)\n        if(covered):\n            cam_on = 1+self.helper(node.left,True,False)+self.helper(node.right, True, False)\n            cam_off = self.helper(node.left,False,False)+self.helper(node.right, False, False)\n            return min(cam_on, cam_off)\n        \n        #Not covered\n        cam_on = 1+self.helper(node.left,True,False)+self.helper(node.right, True, False)\n        cam_on_left = self.helper(node.left,False, True)+self.helper(node.right, False, False) if node.left != None else inf\n        cam_on_right = self.helper(node.left, False, False)+self.helper(node.right, False, True) if node.right != None else inf\n        \n        return min(cam_on, cam_on_left, cam_on_right)\n    \n    def minCameraCover(self, root: TreeNode) -> int:\n        return min(self.helper(root, False, True), self.helper(root, False, False))", "class Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        self.search(root)\n        return root.min        \n    \n    def search(self, node):\n        if node.left:\n            self.search(node.left)\n            if node.right:\n                self.search(node.right)\n                node.min_with = 1 + node.left.min_bottom + node.right.min_bottom\n                node.min_bottom = min(node.min_with, node.left.min + node.right.min)\n                node.min = min(node.min_with, node.left.min_with+node.right.min,\n                              node.left.min+node.right.min_with)\n            else:\n                node.min_bottom = node.left.min\n                node.min_with = 1 + node.left.min_bottom\n                node.min = min(node.min_with, node.left.min_with)\n        else:\n            if node.right:\n                self.search(node.right)\n                node.min_bottom = node.right.min\n                node.min_with = 1 + node.right.min_bottom\n                node.min = min(node.min_with, node.right.min_with)\n            else:\n                node.min_bottom = 0\n                node.min_with = 1\n                node.min = 1", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        \\\"\\\"\\\"\n        #\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9root\uff0c\u9700\u8981\u7ef4\u62a4\u4e09\u79cd\u7c7b\u578b\u7684\u72b6\u6001\uff1a\n        1. \u72b6\u6001a: root\u5fc5\u987b\u653e\u7f6e\u6444\u50cf\u5934\u7684\u60c5\u51b5\u4e0b\uff0c\u8986\u76d6\u6574\u68f5\u6811\u9700\u8981\u7684\u6444\u50cf\u5934\u6570\u76ee\n        2. \u72b6\u6001b: \u8986\u76d6\u6574\u68f5\u6811\u9700\u8981\u7684\u6444\u50cf\u5934\u6570\u76ee\uff0c\u65e0\u8bbaroot\u662f\u5426\u653e\u7f6e\u6444\u50cf\u5934\u3002\n        3. \u72b6\u6001c: \u8986\u76d6\u4e24\u9897\u5b50\u6811\u9700\u8981\u7684\u6444\u50cf\u5934\u6570\u76ee\uff0c\u65e0\u8bba\u8282\u70b9root\u672c\u8eab\u662f\u5426\u88ab\u76d1\u63a7\u5230\u3002\n\n        \\\"\\\"\\\"\n        def dfs(root):\n            if not root:\n                return [float('inf'), 0, 0]\n            \n            la, lb, lc = dfs(root.left)\n            ra, rb, rc = dfs(root.right)\n            a = lc + rc +1\n            b = min(a, la+rb, ra+lb)\n            c = min(a, lb+rb)\n            return [a, b, c]\n        a, b, c = dfs(root)\n        return b\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        # three cases for a node (root), DP: up -> bottom\n        # 0: root is not covered, all nodes below are covered\n        # 1: root is covered, all nodes below are covered, root has no camera\n        # 2: root is covered, all nodes below are covered, root has a camera\n        \n        # 0: L, R children both in case 1\n        # 1: L, R can be 1 or 2, at least one child is in case 2\n        # 2: L, R children can be any case\n        \n        def dp(node):\n            if not node:\n                return [0, 0, float(inf)]\n            \n            L = dp(node.left)\n            R = dp(node.right)\n            dp0 = L[1] + R[1]\n            dp1 = min(L[2] + min(R[1:]), min(L[1:]) + R[2])\n            dp2 = 1 + min(L) + min(R)\n            return [dp0, dp1, dp2]\n        return min(dp(root)[1:])\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        nothing =0\n        leaf =1\n        has = 2\n        covered = 3\n        coverme = 4\n        self.ans =0\n        \n        def rec(root):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                \n                return leaf\n            left = rec(root.left)\n            right = rec(root.right)\n            \n            if left == leaf or right == leaf or left == coverme or right == coverme:\n                self.ans +=1\n                return has\n            if left == has or right == has:\n                return covered\n            return coverme\n        r = rec(root)\n        if r == leaf or r == coverme:\n            self.ans += 1\n        return self.ans\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        # self.times = 0\n        self.DP = dict()\n        def dp(node,flag):\n            if (node, flag) in self.DP:\n                return self.DP[(node, flag)]\n            # self.times += 1\n            # print(self.times)\n            if flag == 0 and node is None:\n                result = 1\n            elif node is None:\n                result = 0\n            elif flag == 2:#satisfied\n                result = min(dp(node.left,1) + dp(node.right,1), dp(node.left,2) + dp(node.right,2)+1)\n            elif flag == 1:#self or descend should be\n                a = dp(node.left,0)\n                b = dp(node.right,1)\n                aa = dp(node.left,1)\n                bb = dp(node.right,0)\n                result = min(a + b, aa+bb, a+bb, dp(node.left,2) + dp(node.right,2) + 1)\n            else:\n                result = dp(node.left,2) + dp(node.right,2) + 1\n            self.DP[(node, flag)] = result\n            return result\n        return min(dp(root,0), dp(root,1))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        # print('gg')\n        def do(node):\n            if not node:\n                return\n            dummy = TreeNode()\n            dummy.use = 0\n            dummy.covered = dummy.notcovered = 99999\n            \n            node.use = 1\n            node.covered = 0\n            node.notcovered = 0\n            \n            do(node.left)\n            do(node.right)\n            l = node.left\n            r = node.right\n            \n            ml = min(l.use, l.covered, l.notcovered) if l else 9999\n            mr = min(r.use, r.covered, r.notcovered) if r else 9999\n            node.use = 1 + (ml if node.left else 0) + (mr if node.right else 0)\n            node.covered = min((l.covered if l else 0) + (r.use if r else 9999), (l.use if l else 9999) + (r.covered if r else 0), (l.use if l else 9999) + (r.use if r else 9999))\n            node.notcovered = (l.covered if l else 0) + (r.covered if r else 0)\n            # print(node.use, node.covered, node.notcovered)\n\n        do(root)\n        return 0 if not root else min(root.use, root.covered)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        ans = 0\n        def recursive(root):\n            nonlocal ans\n            if not root.left and not root.right:\n                return 0, 0\n            left_cover = 1\n            right_cover= 1\n            left_camera = 0\n            right_camera  = 0\n            if root.left:\n                left_cover, left_camera = recursive(root.left)\n            if root.right:\n                right_cover, right_camera = recursive(root.right)\n            if not (left_cover and right_cover):\n                ans +=1\n                return 1, 1\n            elif left_camera or right_camera:\n                return 1, 0\n            else:\n                return 0, 0\n        return ans if recursive(root)[0] else ans+1\n                \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        def solve(node):\n            if node is None:\n                return 0, 0, 1000\n            l = solve(node.left)\n            r = solve(node.right)\n            \n            dp0 = l[1] + r[1]\n            dp1 = min(l[2] + min(r[1:]), min(l[1:]) + r[2])\n            dp2 = 1 + min(l) + min(r)\n            \n            return dp0, dp1, dp2\n        return min(solve(root)[1:])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        \n        @lru_cache(None)\n        def cal(root, st):\n            if root:\n                if st == 1:\n                    return min(cal(root.left, 2)+cal(root.right, 2),\n                              1 + cal(root.left, 1) + cal(root.right, 1))\n                elif st == 2:\n                    if root.left == root.right == None:\n                        return 1\n                    if root.left and root.right:                        \n                        return min(cal(root.left, 3)+cal(root.right, 2),\n                                    cal(root.left, 2)+cal(root.right, 3),\n                                    1 + cal(root.left, 1) + cal(root.right, 1))\n                    else:\n                         return min(cal(root.left, 3)+cal(root.right, 3),\n                                    cal(root.left, 3)+cal(root.right, 3),\n                                    1 + cal(root.left, 1) + cal(root.right, 1))\n                        \n                elif st == 3:\n                    return 1 + cal(root.left, 1) + cal(root.right, 1)\n            else:\n                return 0\n            \n        return cal(root, 2)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        # 1 means monitored, 2 means camera\n        if root.left is None and root.right is None:\n            return 1\n        \n        self.ans = 0\n        # with dp?\n        def dfs(t, pre=None):\n            if t is None:\n                return 0\n            t.pre = pre\n            # idea: put a camera above each leaf, mark around that we are ok, then cut those nodes from the tree\n            # so that when we go up in the recursion there are new leaves\n            dfs(t.left, t)\n            dfs(t.right, t)\n            \n            if (not t.left or t.left.val < 0) and (not t.right or t.right.val < 0) and t.val == 0:\n                if pre and pre.val != -2:\n                    pre.val = -2\n                    self.ans += 1\n                    if pre.pre:\n                        pre.pre.val = -1 # val of -1 means cut\n                if not pre and t.val == 0:\n                    self.ans += 1\n                    t.val = -1\n                \n        dfs(root)\n        print(root)\n        return self.ans\n                \n                \n        # min num of camera left\n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n# Intuition:\n# Consider a node in the tree.\n# It can be covered by its parent, itself, its two children.\n# Four options.\n\n# Consider the root of the tree.\n# It can be covered by left child, or right child, or itself.\n# Three options.\n\n# Consider one leaf of the tree.\n# It can be covered by its parent or by itself.\n# Two options.\n\n# If we set a camera at the leaf, the camera can cover the leaf and its parent.\n# If we set a camera at its parent, the camera can cover the leaf, its parent and its sibling.\n\n# We can see that the second plan is always better than the first.\n# Now we have only one option, set up camera to all leaves' parent.\n\n# Here is our greedy solution:\n\n# Set cameras on all leaves' parents, then remove all covered nodes.\n# Repeat step 1 until all nodes are covered.\n# Explanation:\n# Apply a recusion function dfs.\n# Return 0 if it's a leaf.\uff08need to be covered0\n# Return 1 if it's a parent of a leaf, with a camera on this node.\n# Return 2 if it's coverd, without a camera on this node.\n\n# For each node,\n# if it has a child, which is leaf (node 0), then it needs camera.\n# if it has a child, which is the parent of a leaf (node 1), then it's covered.\n\n# If it needs camera, then res++ and we return 1.\n# If it's covered, we return 2.\n# Otherwise, we return 0.\n\n\nclass Solution:\n    def minCameraCover(self, root):\n        self.res = 0\n        def dfs(root):\n            if not root: return 2\n            l, r = dfs(root.left), dfs(root.right)\n            if l == 0 or r == 0:\n                self.res += 1   #\u5728\u91cc\u9762\u6539\u53d8, \u9700\u8981\u9632\u6b62\u4e00\u4e2a\u8282\u70b9\n                return 1  #\u8fd9\u4e2a\u70b9return 1 \u4ee3\u8868\u653e\u4e86camera\u4e86\n            elif l == 1 or r == 1:\n                return 2\n            elif l == 2 or r == 2:\n                return 0\n        return (dfs(root) == 0) + self.res\n\n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def helper(self, root):\n        if not root:\n            return 2\n            \n        left = self.helper(root.left)\n        right = self.helper(root.right)\n        \n        if left == 0 or right == 0:\n            self.count+=1\n            return 1\n        if left == 1 or right == 1:\n            return 2  \n        else:\n            return 0\n        \n            \n    def minCameraCover(self, root: TreeNode) -> int: \n        \n        self.count = 0\n        return (self.helper(root)==0) + self.count", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\n# Intuition:\n# Consider a node in the tree.\n# It can be covered by its parent, itself, its two children.\n# Four options.\n\n# Consider the root of the tree.\n# It can be covered by left child, or right child, or itself.\n# Three options.\n\n# Consider one leaf of the tree.\n# It can be covered by its parent or by itself.\n# Two options.\n\n# If we set a camera at the leaf, the camera can cover the leaf and its parent.\n# If we set a camera at its parent, the camera can cover the leaf, its parent and its sibling.\n\n# We can see that the second plan is always better than the first.\n# Now we have only one option, set up camera to all leaves' parent.\n\n# Here is our greedy solution:\n\n# Set cameras on all leaves' parents, then remove all covered nodes.\n# Repeat step 1 until all nodes are covered.\n# Explanation:\n# Apply a recusion function dfs.\n# Return 0 if it's a leaf.\n# Return 1 if it's a parent of a leaf, with a camera on this node.\n# Return 2 if it's coverd, without a camera on this node.\n\n# For each node,\n# if it has a child, which is leaf (node 0), then it needs camera.\n# if it has a child, which is the parent of a leaf (node 1), then it's covered.\n\n# If it needs camera, then res++ and we return 1.\n# If it's covered, we return 2.\n# Otherwise, we return 0.\n\n\nclass Solution:\n    def minCameraCover(self, root):\n        self.res = 0\n        def dfs(root):\n            if not root: return 2\n            l, r = dfs(root.left), dfs(root.right)\n            if l == 0 or r == 0:\n                self.res += 1   #\u5728\u91cc\u9762\u6539\u53d8\n                return 1\n            return 2 if l == 1 or r == 1 else 0\n        return (dfs(root) == 0) + self.res\n\n\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        covered = {None}\n        self.ans = 0\n        \n        def dfs(node, par):\n            \n            if node:\n                dfs(node.left, node)\n                dfs(node.right, node)\n\n                if (par is None and node not in covered) or node.left not in covered or node.right not in covered :\n                    covered.update({node, par, node.right, node.left})\n                    self.ans += 1\n                \n        dfs(root, None)\n        return self.ans", "class Solution:\n    def minCameraCover(self, root):\n        def solve(node):\n            # 0: Strict ST; All nodes below this are covered, but not this one\n            # 1: Normal ST; All nodes below and incl this are covered - no camera\n            # 2: Placed camera; All nodes below this are covered, plus camera here\n\n            if not node: return 0, 0, float('inf')\n            L, R = solve(node.left), solve(node.right)\n            dp0 = L[1] + R[1]\n            dp1 = min(L[2] + min(R[1:]), R[2] + min(L[1:]))\n            dp2 = 1 + min(L) + min(R)\n            return dp0, dp1, dp2\n\n        return min(solve(root)[1:])", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        \n        \n        def dfs(node):\n            nonlocal cnt\n            \n            if node:\n                left = dfs(node.left)\n                right = dfs(node.right)\n                \n                if not left or not right:\n                    cnt += 1\n                    return 2\n                elif left == 2 or right == 2:\n                    return 1\n                else:\n                    return 0\n            else:\n                return 1\n        \n        cnt = 0\n        \n        if not dfs(root):\n            return cnt + 1\n        else:\n            return cnt\n        \n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraCover(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        seen = set()\n        self.ans = 0\n        def inorder(root,parent=None):\n            if root:\n                inorder(root.left,root)\n                inorder(root.right,root)\n                for i in [parent,root,root.left,root.right]:\n                    if i and i in seen:\n                        break\n                else:\n                    self.ans+=1\n                    seen.update(set([parent,root,root.left,root.right]))\n        inorder(root)\n        return self.ans\n"]
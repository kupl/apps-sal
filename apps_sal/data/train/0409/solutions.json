["class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        oneArrSum = sum(arr)\n        twoArr = arr + arr\n        \n        def findMaxSub(array):\n            if len(array) == 1:\n                return array[0]\n            \n            cur = 0\n            small = 0\n            ret = -999999\n            for i in array:\n                cur += i\n                small = cur if cur < small else small\n                ret = cur - small if cur - small > ret else ret\n           \n            return 0 if ret < 0 else ret\n        \n        if not arr:\n            return 0\n        if k == 1:\n            return findMaxSub(arr)\n        \n        ret = findMaxSub(twoArr)\n        if oneArrSum > 0 and k > 2:\n            ret += (k-2)*oneArrSum\n        return ret % (10**9 + 7)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if not arr or k == 0: return 0\n        N = 10 ** 9 + 7\n        n = len(arr)\n        accu = [0] * (n+1)\n        for i in range(1,n+1):\n            accu[i] = accu[i - 1] + arr[i - 1]\n        s = accu[-1]\n        accuMaxL = max(accu)\n        accuMaxR = s - min(accu)\n        a0, sMax = 0, 0\n        for a in accu:\n            a0 = min(a,a0)\n            sMax = max(sMax, a - a0)\n        if sMax <= 0:\n            return 0\n        elif k == 1:\n            return sMax\n        elif s <= 0:\n            ans = max(sMax, accuMaxR + accuMaxL)\n            return ans\n        elif (sMax - accuMaxL - accuMaxR)/k > s:\n            return sMax\n        else:\n            ans = accuMaxR + accuMaxL % N\n            for i in range(k - 2):\n                ans = (ans + s) % N\n            return ans", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        def getMaximumSum(subArr, t):\n            subArrT = subArr.copy()\n            for i in range(t-1):\n                subArrT.extend(subArr) \n            nS = len(subArrT)\n            maxSum = 0\n            rSum = 0\n            for i in range(nS):\n                if ((rSum+subArrT[i]) < 0):\n                    rSum = 0\n                    continue\n                else:\n                    rSum += subArrT[i]\n                    if (rSum > maxSum):\n                        maxSum = rSum\n            return maxSum\n        def getHeadSum(subArr):\n            headSum = 0\n            nS = len(subArr)\n            rSum = 0\n            for i in range(nS):\n                rSum += subArr[i]\n                if (rSum > headSum):\n                    headSum = rSum\n            return headSum\n        headSum = getHeadSum(arr)\n        tailSum = getHeadSum(arr[::-1])\n        sumArr  = sum(arr)\n        \n        result = 0\n        if (sumArr > 0):\n            if (k == 1):\n                result = getMaximumSum(arr,1)\n            elif (k == 2):\n                result = tailSum + headSum\n            else:\n                result = tailSum + (k-2)*sumArr + headSum\n        else:\n            if (k > 1):\n                if ((headSum + tailSum) > result):\n                    result = headSum+tailSum\n                    \n            if (getMaximumSum(arr,1) > result):\n                result = getMaximumSum(arr,1)\n            \n        return result%(10**9+7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        MAX_INT = 10**9+7\n        \n        def kadane(arr):\n            cur, res = 0, 0\n            for v in arr:\n                cur = max(v, cur+v)\n                res = max(res, cur)\n            return res\n        \n        if k == 1: return kadane(arr)\n        else:\n            s = sum(arr)\n            if s <= 0: return kadane(arr*2)\n            else: return (kadane(arr) + (k-1)*s)%MAX_INT", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        m = 10**9 + 7\n        \n        #kadane helper algo\n        def kadane(numbers):\n            best = 0 \n            curr = 0\n            for x in numbers:\n                curr = max(0, curr+x)\n                best = max(best, curr)\n            return best\n        \n        #stupid approach\n        #a = arr*k\n        #return max_subarray(a) % m\n        \n        tot = sum(arr)\n        \n        if not k:\n            return 0\n        elif k == 1:\n            return kadane(arr) % m\n        else:\n            return ((k-2)*max(tot,0)+kadane(arr*2)) % m\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        sumarr=sum(arr)\n        maxsum=0\n        currentsum=0\n        for i in range(len(arr)):\n            currentsum+=arr[i]\n            if(currentsum<0):\n                currentsum=0\n            maxsum=max(maxsum,currentsum)\n        if(sumarr>0):\n            if(sumarr*k>maxsum):\n                maxsum=sumarr*k\n        maxprefixsum=0\n        currentsum=0\n        for i in range(len(arr)):\n            currentsum+=arr[i]\n            maxprefixsum=max(maxprefixsum,currentsum)\n        maxsufixsum=0\n        currentsum=0\n        for i in range(len(arr)-1,-1,-1):\n            currentsum+=arr[i]\n            maxsufixsum=max(maxsufixsum,currentsum)\n        if(k>=2):\n            maxsum=max(maxsum,maxsufixsum+maxprefixsum)\n        if(sumarr>0):\n            maxsum=max(sumarr*(k-2)+maxsufixsum+maxprefixsum,maxsum)\n        return maxsum%1000000007\n            \n            \n        \n", "class Solution:\n    def findMaxSubarray(arr):\n        counter = 0\n        best = 0\n        for a in arr:\n            counter += a\n            if counter < 0:\n                counter = 0\n            else:\n                best = max(best, counter)\n        return best\n    \n    def maxFromLeft(arr):\n        max_from_left = 0\n        sum_from_left = 0\n        for a in arr:\n            sum_from_left += a\n            max_from_left = max(max_from_left, sum_from_left)\n        return max_from_left\n    \n    def maxFromRight(arr):\n        max_from_right = 0\n        sum_from_right = 0\n        for a in reversed(arr):\n            sum_from_right += a\n            max_from_right = max(max_from_right, sum_from_right)\n        return max_from_right\n    \n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        no_reps = Solution.findMaxSubarray(arr)\n        if k == 1:\n            return no_reps\n        \n        arr_sum = sum(arr)\n        best_from_left = Solution.maxFromLeft(arr)\n        best_from_right = Solution.maxFromRight(arr)\n        \n        right_and_left = best_from_right + best_from_left\n        \n        right_and_k_and_left = best_from_right + (k - 2) * arr_sum + best_from_left\n        \n        res = max(no_reps, right_and_left, right_and_k_and_left)\n        \n        return res % (10 ** 9 + 7)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        def kadane(arr):\n            res, curr = float('-inf'), 0\n            for a in arr:\n                curr = max(curr+a, a)\n                res = max(res, curr)\n                \n            return res\n        \n        if k==1: return kadane(arr)\n        one_sum = sum(arr)\n        if one_sum<0: return max(0, kadane(arr*2))\n        return (one_sum*(k-2)+kadane(2*arr))%(10**9+7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        def kadane(lst):\n            max_sub = local = 0\n            for n in lst:\n                max_sub = max(max_sub, local := max(local + n, n))    \n            return max_sub\n        if k==1 or sum(arr) <= 0:\n            return kadane(arr * min(2, k))\n        else:\n            m = 10**9+7\n            return ((kadane(arr) + (k-1)*sum(arr)) % m)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        # dp = [0 for i in range(2*n)]\n        # dp[0] = arr[0]\n        # ans = dp[0]\n        # dp = arr[0]\n        # ans = dp\n        # sums = sum(arr)\n        # begin, maxbegin = 0, 0\n        # end, maxend = 0, 0\n        # for i in range(1, n * min(2, k)):\n        #     cur = arr[i % n]\n        #     if dp + cur >= cur:\n        #         dp = dp+cur\n        #         end = i\n        #     else:\n        #         dp = cur\n        #         begin, end = i, i\n        #     if dp > ans:\n        #         ans = dp\n        #         maxbegin = begin\n        #         maxend = i\n        # if k == 1:\n        #     return ans if ans > 0 else 0\n        # if ans < 0:\n        #     return 0\n        # if maxend % n < maxbegin or maxend < n:\n        #     return ans  % (10**9+7)\n        # else:\n        #     return (ans + sums*(k-2)) % (10**9+7)\n        \n        \n        \n        sums = sum(arr)\n        dp = 0\n        ans = -float('inf')\n        for i in range(n * min(2, k)):\n            cur = arr[i % n]\n            dp = max(dp+cur, cur)\n            ans = max(dp, ans)\n        return max(0, ans, ans + sums* max(k-2, 0)) % (10**9+7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        n = len(arr)\n        ls = [0 for _ in range(n)]\n        rs = [0 for _ in range(n)]\n        \n        for i in range(n):\n            ls[i] = arr[i] + (ls[i-1] if i > 0 else 0)\n        for i in range(n-1, -1, -1):\n            rs[i] = arr[i] + (rs[i+1] if i < n-1 else 0)\n        \n        ms = 0\n        minls = 0\n        for i in range(n):\n            minls = min(minls, ls[i])\n            ms = max(ms, ls[i]-minls)\n        \n        mls = max(ls)\n        mrs = max(rs)\n        ss = sum(arr)\n        \n        if k == 1:\n            return ms\n        else:\n            if ss < 0:\n                return max(ms, mls + mrs) % mod\n            else:\n                return max(ms, mls + mrs + (k-2) * ss) % mod\n        \n        \n        \n        \n        \n        \n        \n    \n        \n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        now, m, ans = 0, 0, 0\n            \n        for i in range(n):\n            now += arr[i]\n            m = min(m, now)\n            ans = max(ans, now-m)\n        \n        if k==1:\n            return ans%(10**9+7)\n        \n        now, pref_M = 0, 0\n        \n        for i in range(n):\n            now += arr[i]\n            pref_M = max(pref_M, now)\n        \n        now, suf_M = 0, 0\n        \n        for i in range(n-1, -1, -1):\n            now += arr[i]\n            suf_M = max(suf_M, now)\n        \n        ans = max(ans, pref_M+suf_M+max(0, sum(arr))*(k-2))\n        return ans%(10**9+7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if sorted(arr)[0] >= 0:\n            return sum(arr)*k %(10**9+7)\n        if sorted(arr)[-1] <= 0:\n            return 0\n        # temp1, temp2 = 0,0\n        if k > 1:\n            arr = arr + [max(0,sum(arr)*(k-2))] + arr\n        temp, res = 0,0\n        for i in range(len(arr)):\n            temp += arr[i]\n            res = max(res, temp)\n            if temp < 0:\n                temp = 0\n        return res %(10**9+7)", "MOD = 1000000007\nclass Solution:\n    def kConcatenationMaxSum(self, arr, k):\n        min_pre_sum = 0\n        pre_sum = 0\n        max_pre_sum, max_suf_sum, max_win_sum = 0, 0, 0\n        n = len(arr)\n        for i in range(n):\n            pre_sum += arr[i]\n            max_win_sum = max(max_win_sum, pre_sum - min_pre_sum)\n            if i == n - 1:\n                max_suf_sum = pre_sum - min_pre_sum\n            min_pre_sum = min(min_pre_sum, pre_sum)\n            max_pre_sum = max(max_pre_sum, pre_sum)\n        if k == 1:\n            return max_win_sum\n        if pre_sum > 0:\n            return max(max_win_sum, max_pre_sum + max_suf_sum + (k - 2) * pre_sum) % MOD\n        else:\n            return max(max_win_sum, max_pre_sum + max_suf_sum) % MOD", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        def findMaxSum(arr):\n            num_sum = 0\n            dp = arr[0]\n            max_num = arr[0]\n            for i in range(1, len(arr)):\n                num = arr[i]\n                dp = max(dp + num, num)\n                max_num = max(max_num, dp)\n            return max_num if max_num >= 0 else 0\n        \n        if k == 0:\n            return 0\n        elif k == 1:\n            return findMaxSum(arr)\n        elif k == 2 or sum(arr) < 0:\n            return findMaxSum(arr + arr)\n        else:\n            return (sum(arr) * (k - 2) + findMaxSum(arr + arr))%(10**9 + 7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        mod=1000000007\n        fms,sms,msf,meh=0,0,0,0\n        for i in range(3):\n            for num in arr:\n                meh = max(0, (meh+num))\n                msf = max(msf, meh)\n            if i==0:\n                fms = msf\n            elif i==1:\n                sms = msf\n        diff = msf - sms\n        print(fms,sms,msf,diff)\n        return (sms+diff * (k - 2))%1000000007", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if len(arr) == 0:\n            return 0\n        \n        mod = int(10**9)+7\n        v = arr[:]\n        pre = [0]\n        suf = [0]\n        ans = msuf = mpre = 0\n        \n        for x in arr:\n            if k>1: v.append(x)\n            ans += x\n            pre.append(pre[-1]+x)\n            mpre= max(mpre, pre[-1])\n            \n        for x in arr[::-1]:\n            suf.append(suf[-1]+x)\n            msuf = max(msuf, suf[-1])\n        \n        if ans > 0 and k >= 2:\n            return (((k-2)*ans)%mod + msuf + mpre)%mod\n        \n        maxi = 0\n        for x in v:\n            maxi = max(0, maxi+x)\n            ans = max(ans, maxi)\n        \n        return ans%mod\n            \n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        # dp = [0 for i in range(2*n)]\n        # dp[0] = arr[0]\n        # ans = dp[0]\n        dp = arr[0]\n        ans = dp\n        sums = sum(arr)\n        begin, maxbegin = 0, 0\n        end, maxend = 0, 0\n        for i in range(1, n * min(2, k)):\n            cur = arr[i % n]\n            if dp + cur >= cur:\n                dp = dp+cur\n                end = i\n            else:\n                dp = cur\n                begin, end = i, i\n            if dp > ans:\n                ans = dp\n                maxbegin = begin\n                maxend = i\n        if k == 1:\n            return ans if ans > 0 else 0\n        if ans < 0:\n            return 0\n        if maxend % n < maxbegin or maxend < n:\n            return ans  % (10**9+7)\n        else:\n            return (ans + sums*(k-2)) % (10**9+7)\n", "class Solution:  \n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        def kadane(nums):\n            local_max = nums[0]\n            ans = local_max\n            for i in range(1,len(nums)):\n                local_max = max(nums[i],local_max+nums[i])\n                if (ans<local_max): ans = local_max\n            return ans if ans>0 else 0\n        normal = kadane(arr)\n        if k==1: return normal\n        tot = sum(arr)\n        a = []\n        for i in range(2):\n            for j in range(n):\n                a.append(arr[j])\n        mod = 10**9+7\n        temp = kadane(a)\n        tot = max(0,tot)\n        return max(normal,temp,tot*(k-2)+temp)%mod", "from typing import List\n\n\ndef get_max(arr: List[int]) -> int:\n\n    mx_running = mx_total = 0\n\n    for n in arr:\n        mx_running = n + max(0, mx_running)\n        mx_total = max(mx_total, mx_running)\n\n    return mx_total\n\n\ndef get_repeated_max(arr: List[int],\n                     k: int,\n                     p: int) -> int:\n\n    mx_1 = get_max(arr)\n    if k == 1:\n        return mx_1 % p\n    else:\n        mx_2 = get_max(arr + arr)\n        if mx_1 > mx_2:\n            return mx_1 % p\n        else:\n            return mx_2 + max(sum(arr) * (k - 2), 0) % p\n\n\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        return get_repeated_max(arr, k, int(1e9 + 7))\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if k == 1:\n            temp = arr\n        else:\n            temp = arr + arr\n        \n        cum = [0]*(len(temp)+1)\n        for i in range(1, len(temp)+1):\n            cum[i] = cum[i-1] + temp[i-1]\n        \n        cur = 0\n        res = 0\n        for c in cum:\n            cur = min(cur, c)\n            res = max(res, c - cur)\n        \n        MOD = 10**9 + 7\n        if k == 1:\n            return res % MOD\n        s = sum(arr)\n        if res > 2*s > 0:\n            return (res + (k-2)*s) % MOD\n        elif s > 0:\n            return k*s % MOD\n        else:\n            return res % MOD", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n\n        lsum, max_lsum, min_lsum, max_sum, sum, max_rsum, rsum = 0, 0, 0, 0, 0, 0, 0\n        for i in range(n):\n            lsum+= arr[i]\n            max_lsum = max(lsum, max_lsum) # FOR END\n            min_lsum = min(lsum, min_lsum) # FOR START\n            \n            sum += arr[i]\n            sum = max(0, sum)\n            max_sum = max(sum, max_sum)\n            \n            rsum += arr[n-1-i]\n            max_rsum = max(rsum, max_rsum)\n            \n        if lsum < 0:\n            return max(max_sum,  max_rsum + max_lsum)\n        \n        if k == 1:\n            return max_sum\n        \n        mod = 10 ** 9 + 7\n        return max(lsum * k, lsum * (k -2) + max_rsum + max_lsum) % mod\n            \n        \n#[2,-5,1,0,-2,-2,2] [2,-5,1,0,-2,-2,2] [2,-5,1,0,-2,-2,2] [2,-5,1,0,-2,-2,2]\n        \n        \n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if not arr or k == 0:\n            return 0\n        max_sub_arr, total = self.get_max_subarr(arr, 0, len(arr))\n        res = 0\n        l = self.get_left_max(arr)\n        r = self.get_right_max(arr)\n        if k == 1:\n            return max_sub_arr\n        pos = 0\n        if k > 3:\n            pos = (l+r) + (k-2) * total\n            \n        return max(total*k, max_sub_arr, (l+r), pos) % (10**9 + 7)\n        \n    def get_right_max(self, arr):\n        res = 0\n        cur = 0\n        i = len(arr) - 1\n        while i >= 0:\n            cur += arr[i]\n            res = max(cur, res)\n            i -= 1\n        return res\n    \n    def get_left_max(self, arr):\n        res = 0\n        cur = 0\n        i = 0\n        while i < len(arr):\n            cur += arr[i]\n            res = max(cur, res)\n            i += 1\n        return res\n        \n    def get_max_subarr(self, nums, i, j):\n        cur = 0\n        res = 0\n        total = 0\n        for it in range(i, j):\n            total += nums[it]\n            if nums[it] >= 0:\n                cur += nums[it]\n                res = max(cur, res)\n            else:\n                cur = max(cur+nums[it], 0)\n        return res, total", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        s=sum(arr)\n        def kadane(arr):\n            \n            cur=m=arr[0]\n            for i in range(1,len(arr)):\n                cur=max(arr[i],cur+arr[i])\n                m=max(cur,m)\n            return m\n        if not arr:\n            return 0\n        if k==1:\n            return max(0,kadane(arr)%(10**9+7))\n        else:\n            return max(0, (k - 2) * max(s, 0) + kadane(arr + arr)) % (10 ** 9 + 7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        MOD = 1000000000 + 7\n        \n        def findMaxSubarray(mat: List[int]) -> int:\n            maxSum = 0\n            currSum = 0\n            \n            for i in mat:\n                currSum = max(currSum+i, i)\n                maxSum = max(maxSum, currSum)\n            return maxSum\n        \n        a = arr.copy()\n        if k == 1:\n            return findMaxSubarray(a)\n        \n        a.extend(arr)\n        subMax = findMaxSubarray(a)\n        \n        total = 0\n        for n in arr:\n            total += n\n        \n        if total > 0:\n            return (subMax + (k-2)*total) % MOD\n        else:\n            return subMax % MOD\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        len_arr = len(arr)\n        curr_max = global_max = 0\n\n        for i in range(len_arr if k == 1 else len_arr * 2):\n            n = arr[i % len_arr]\n            curr_max = max(n, curr_max + n)\n            global_max = max(global_max, curr_max)\n\n        return (global_max + ((k - 2) * max(0, sum(arr)) if k > 1 else 0)) % (10 ** 9 + 7)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        l = len(arr)\n        if l == 0:\n            return 0\n        frontview, backview, sumfront, sumback = [0] * l, [0] * l, [0] * l, [0] * l\n        frontview[0], backview[-1], sumfront[0], sumback[-1] = max(0, arr[0]), max(0, arr[-1]), arr[0], arr[-1]\n        \n        for i in range(1, l):\n            frontview[i] = max(0, frontview[i-1] + arr[i])\n            backview[l-1-i] = max(0, backview[l-i] + arr[l-1-i])\n            sumfront[i] = sumfront[i-1] + arr[i]\n            sumback[l-1-i] = sumback[l-i] + arr[l-1-i]\n            \n        sum_arr = sum(arr)\n        base = 10 ** 9 + 7\n        \n        \n        if k == 1:\n            return max(frontview) % base\n        elif sum_arr <= 0:\n            result1 = max(max(frontview), frontview[-1] + backview[0]) % base\n            result2 = max(sumfront) + max(sumback)\n            print((result1, result2))\n            return max(result1, result2) % base\n        else:\n            result1 = max(max(frontview), frontview[-1] + backview[0])\n            result2 = sum_arr * (k - 2) + max(sumfront) + max(sumback)\n            if result1 < result2:\n                return result2 % base\n            else:\n                return result1 % base\n            \n            \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        current = arr[0]\n        glob    = arr[0]\n        \n        for i in range(1, len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n                \n        print((current, glob))\n        if k==1:\n            return glob if glob > 0 else 0\n        \n        prevCurrent = current\n        prevGlob    = glob\n        \n        for i in range(len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n        \n        if prevGlob == glob or k==2:\n            return glob if glob > 0 else 0\n        \n        afterCurrent = current\n        afterGlob    = glob\n        \n        for i in range(len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n                \n                \n        glob += (glob - afterGlob) * (k-3)\n        \n        return glob % 1000000007 if glob > 0 else 0\n            \n            \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        def get_in_arry_max_sum():\n            cur = 0\n            max_val = 0\n            for i in range(n):\n                cur = max(0, cur) + arr[i]\n                max_val = max(max_val, cur)\n            return max_val\n        \n        max_suffix = list(itertools.accumulate(arr))\n        max_suffix = [0 if i > 0 and max_suffix[i-1] == 0 else max(0, max_suffix[i]) for i in range(n)]\n        max_prefix = list(itertools.accumulate(arr[::-1]))\n        max_prefix = [0 if i > 0 and max_prefix[i-1] == 0 else max(0, max_prefix[i]) for i in range(n)][::-1]\n        \n        mp = max(max_prefix)\n        ms = max(max_suffix)\n        # print(max_prefix)\n        # print(max_suffix)\n        in_arry_max_sum = get_in_arry_max_sum()\n        if k == 1:\n            return in_arry_max_sum\n        if k == 2:\n            return max(mp + ms, in_arry_max_sum)\n\n        total = sum(arr)\n        return max(in_arry_max_sum, mp + ms + (k-2) * max(0, total)) % (10**9+7)\n        \n", "class Solution:\n\n    def kConcatenationMaxSum(self, arr: List[int], k: int, mod = 10 ** 9 + 7) -> int:\n        def Kadane(arr, res = 0, cur = 0):\n            for num in arr:\n                cur = max(num, num + cur)\n                res = max(res, cur)\n            return res\n        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) % mod if k > 1 else Kadane(arr) % mod", "class Solution:\n  def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n    # https://en.wikipedia.org/wiki/Maximum_subarray_problem\n    # Key:\n    # Kadane(arr * 2) is always >= Kadane(arr)\n    # Kadane(arr * 2) will always cross the boundary if sum(arr) > 0\n    # if Kadane(arr * 2) does not cross the boundary, then Kadane(arr * 2) == Kadane(arr)\n    def Kadane(arr):\n      # Kadane: status machine\n      ans, cur = 0, 0\n      for num in arr:\n        cur = max(cur + num, num)\n        ans = max(ans, cur)\n      return ans\n    return (((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) if k > 1 else Kadane(arr)) % (10 ** 9 + 7)", "class Solution:\n    def kConcatenationMaxSum(self, A: List[int], k: int) -> int:\n        if all(a <= 0 for a in A):\n            return 0\n        total = sum(A)\n        N = len(A)\n        startingAt, endingAt = [[-sys.maxsize]*N for _ in range(2)]\n        bestStart = bestEnd = -sys.maxsize\n        MOD = 10**9 + 7\n        for i in range(N):\n            startingAt[N-1-i] = A[N-1-i] + (startingAt[N-i] if N-i < N and startingAt[N-i] > 0 else 0)\n            endingAt[i] = A[i] + (endingAt[i-1] if i-1 >= 0 and endingAt[i-1] > 0 else 0)\n            bestStart, bestEnd = max(bestStart, startingAt[N-1-i]), max(bestEnd, endingAt[i])\n        if k == 1:\n            return bestStart\n        \n        return max(bestStart,max(0,(endingAt[N-1]) + max(0,total*(k-2)) + max(0,startingAt[0]))) % MOD", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if not arr : return 0\n        mod = 10**9+7\n        def Kadane(arr):\n            sum_till_now = 0\n            max_sum = 0\n            for i in range(len(arr)):\n                sum_till_now += arr[i]\n                sum_till_now = max(sum_till_now,arr[i])\n                max_sum = max(max_sum,sum_till_now)\n            return max_sum\n        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) % mod if k > 1 else Kadane(arr) % mod\n", "\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        numPos, numNeg = 0,0\n        \n        for num in arr:\n            if num >= 0:\n                numPos += 1\n            else:\n                numNeg += 1\n        \n        if numPos == len(arr):\n            return sum(arr)*k\n        \n        if numNeg == len(arr):\n            return 0\n        \n        # Check for 2* arr\n        arrTwo = arr*2\n        for i in range(1, len(arrTwo)):\n            if arrTwo[i - 1] > 0: \n                arrTwo[i] +=arrTwo[i - 1]\n                \n        # Check for 3*arr\n        arrThree = arr*3\n        for i in range(1, len(arrThree)):\n            if arrThree[i - 1] > 0: \n                arrThree[i] +=arrThree[i - 1]\n        \n        arrDiff = max(arrThree) - max(arrTwo)\n        \n        \n        return (max(arrTwo) + (k-2)*arrDiff) % (10**9 + 7)\n        \n            \n        \n       \n        \n", "\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        numPos, numNeg = 0,0\n        \n        for num in arr:\n            if num >= 0:\n                numPos += 1\n            else:\n                numNeg += 1\n        \n        if numPos == len(arr):\n            return sum(arr)*k\n        \n        if numNeg == len(arr):\n            return 0\n        \n        # Check for 2* arr\n        arrTwo = arr*2\n        for i in range(1, len(arrTwo)):\n            if arrTwo[i - 1] > 0: \n                arrTwo[i] +=arrTwo[i - 1]\n                \n        # Check for 3*arr\n        arrThree = arr*3\n        for i in range(1, len(arrThree)):\n            if arrThree[i - 1] > 0: \n                arrThree[i] +=arrThree[i - 1]\n                \n        \n        arrDiff = max(arrThree) - max(arrTwo)\n        \n        return (max(arrTwo) + (k-2)*arrDiff) % (10**9 + 7)\n        \n            \n        \n       \n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        def kadane(ls, n):\n            max_sum_so_far = ls[0]\n            current_sum = ls[0]\n            for i in range(1, n):\n                current_sum = max(current_sum + ls[i], ls[i])\n                max_sum_so_far = max(max_sum_so_far, current_sum)\n            return max_sum_so_far\n        n = len(arr)\n        first_max_sum = kadane(arr, n)\n        if k <= 1:\n            return first_max_sum\n        arr_sum = sum(arr)\n        arr.extend(arr)\n        next_max_sum = kadane(arr, 2*n)\n        \n        if arr_sum < 0:\n            return max(next_max_sum, 0)\n        \n        if arr_sum >=0 and next_max_sum > arr_sum:\n            return (next_max_sum + (k-2)*arr_sum) %(10**9 + 7)\n        # if arr_sum >\n        \n        return max(first_max_sum, 0)\n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if k == 1:\n            return self.maxSubArray(arr)\n        else:\n            arr_sum = sum(arr)\n            \n            if arr_sum > 0:\n                max_sum = self.maxSubArray(arr ) + (k - 1) * arr_sum\n                max_sum = max_sum%(10**9 + 7)\n                print('pos')\n            else:\n                max_sum = self.maxSubArray(arr + arr) \n                print('neg')\n\n        return max_sum\n        \n    def maxSubArray(self, arr):\n        curr_sum = 0\n        max_sum = 0\n        for a in arr:\n            curr_sum = max(curr_sum + a, a)\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        current = arr[0]\n        glob    = arr[0]\n        \n        for i in range(1, len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n                \n        if k==1:\n            return glob if glob > 0 else 0\n        \n        prevCurrent = current\n        prevGlob    = glob\n        \n        for i in range(len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n        \n        if prevGlob == glob or k==2:\n            return glob if glob > 0 else 0\n        \n        afterCurrent = current\n        afterGlob    = glob\n        \n        for i in range(len(arr)):\n            \n            if current + arr[i] >= arr[i]:\n                current += arr[i]\n            else:\n                current = arr[i]\n                \n            if current > glob:\n                glob = current\n                \n                \n        glob += (glob - afterGlob) * (k-3)\n        \n        return glob % 1000000007 if glob > 0 else 0\n            \n            \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        m = 10**9+7\n        \n        def kadane(arr):\n            cur =0\n            res = 0\n            for a in arr:\n                cur = max(a, cur+a)\n                res = max(res, cur)\n\n            return res\n        \n        if k==1:\n            return kadane(arr)\n        else:\n            if sum(arr)<=0:\n                return kadane(arr*2)\n            else:\n                return (kadane(arr) + (k-1)*sum(arr))%m", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        c = sum(arr)\n        out = 0\n        straight_sum = arr[:]\n        back_sum = arr[:]\n        s = 0\n        for i in range(1,len(straight_sum)):\n            straight_sum[i] = max(straight_sum[i],straight_sum[i-1] + straight_sum[i])\n            \n        out = max(max(straight_sum),out)\n        for i in range(len(arr)):\n            out = max(out,arr[i])\n            s +=arr[i]\n            straight_sum[i] = s\n        s = 0\n        for i in range(len(arr)-1,-1,-1):\n            s+=arr[i]\n            back_sum[i] = s\n        if k ==1:\n            out = max(out,max(straight_sum),max(back_sum))\n            return out\n        if k > 2:\n            out = max(out,max(straight_sum) + max(back_sum) + c*(k-2))\n        out = max(max(straight_sum) + max(back_sum),out)\n        \n        return out % (10**9 + 7)\n", "from math import inf as oo\n\n\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        total = sum(arr)\n        kadanes = self.maxSubArraySum(arr)\n        if (k < 2): return kadanes%(10**9+7)\n        if (total > 0): return (kadanes + (k-1)*total)%(10**9+7)\n        stitchedKadanes = self.maxSubArraySum(arr*2)\n        return stitchedKadanes%(10**9+7)\n    \n    \n    def maxSubArraySum(self, a):\n        size = len(a)\n        max_so_far = -oo\n        max_ending_here = 0\n        \n        for i in a:\n            max_ending_here += i\n            if max_ending_here < 0: max_ending_here=0\n            max_so_far = max(max_so_far, max_ending_here)\n\n        return max_so_far", "class Solution:\n    def low_high(self,arr):\n        low=0\n       \n        mhigh=0\n        high=0\n        peak=0\n        s=0\n        for i in range(len(arr)):\n            s+=arr[i]\n            if s>high:\n                high=s\n           \n            if s>mhigh:\n                mhigh=s\n            if s<low:\n                low=s\n                high=s\n            if high-low>peak:\n                peak=high-low\n\n        return low,high,peak,mhigh\n    \n    \n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        low,high,peak,mhigh=self.low_high(arr)\n        print((low,high,peak,mhigh))\n        s=sum(arr)\n        print(s)\n        if k==1: \n            return peak%1000000007\n        elif s>0:\n            return (max(k-2,0)*s + mhigh + (s-low))%1000000007\n        elif s<=0:\n            return (max(peak,mhigh + (s-low),(s-low),0))%1000000007\n\n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        base = 10 ** 9 + 7\n        if all([x >= 0 for x in arr]):\n            return sum(arr) * k\n        if all([x <= 0 for x in arr]):\n            return 0\n        \n        sol1 = self.maxsub(arr)\n        sol2 = self.maxsub(arr + arr)\n\n        \n        ma, mi = 0, 0\n        presum = 0\n        i = 0\n        while i < len(arr):\n            presum += arr[i]\n            if presum > ma:\n                ma = presum\n            elif presum < mi:\n                mi = presum\n            i += 1\n        if sum(arr) > 0:\n            sol3 = max(ma + sum(arr) * (k-1), sum(arr) * k - mi)\n            sol2 = sol2 + (k - 2) * sum(arr)\n            return max(sol1, sol2, sol3) % base\n        return max(sol1, sol2) % base\n    \n    \n    \n    def maxsub(self, arr):\n        sol = 0\n        temp = 0\n        i = 0\n        while i < len(arr):\n            temp += arr[i]\n            if temp < 0:\n                temp = 0\n            else:\n                sol = max(sol, temp)\n            i += 1 \n        return sol \n                \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if sum(arr) > 0: \n            n = len(arr)\n            s = (k*sum(arr))%1000000007\n            l,r = [float('-inf') for _ in range(len(arr))],[float('-inf') for _ in range(len(arr))] \n            ml,mr = float('inf'),float('inf')\n            for i in range(len(arr)):  \n                l[i] = arr[i] + l[i-1] if i > 0 else arr[0]\n                ml = min(ml,l[i])\n                r[n-i-1] = arr[n-i-1] + r[n-i] if i > 0 else arr[-1]\n                mr = min(mr, r[n-i-1])\n            return s + (abs(ml) if ml < 0 else 0) + (abs(mr) if mr < 0 else 0)\n        arr1 = arr + arr + arr\n        arr = arr1\n        print(arr)\n        mx,n = float('-inf'),len(arr)\n        left = [float('-inf') for _ in range(len(arr))] \n        for i in range(len(arr)):  \n            left[i] = max(arr[i],arr[i] + left[i-1]) if i > 0 else arr[0]\n            mx = max(mx, left[i])\n        print(left)\n        return max(mx, 0)\n        \n                    \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        \n        mod = 10**9 + 7 \n        def helper(arr, res = 0, cur = 0):\n            for num in arr:\n                cur = max(num, num + cur)\n                res = max(res, cur)\n            print(res)\n            return res\n        return ((k - 2) * max(sum(arr), 0) + helper(arr * 2)) % mod if k > 1 else helper(arr) % mod", "from itertools import accumulate\n\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        if not arr: return 0\n        MOD = 10 ** 9 + 7\n        \n        def kadane(arr):\n            return max(accumulate(\n                arr, func=lambda a, b: a + b if a > 0 else b, initial=0,\n            ))\n        return ((k - 2) * max(sum(arr), 0) + kadane(arr * 2)) % MOD if k >= 2 else kadane(arr)\n    \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        # 1 -2 1  1 -2 1   1 -2 1   1 -2 1   1 -2 1\n        if max(arr) <= 0:\n            return 0\n        if sum(arr) > 0:\n            res = sum(arr) * (k - 2)\n            dp = [0] * len(arr)\n            dp[0] = arr[0]\n            for i in range(1,len(arr)):\n                dp[i] = dp[i - 1] + arr[i]\n                    \n            res += max(dp)\n            dp = [0] * len(arr)\n            dp[-1] = arr[-1]\n            for i in range(len(arr) - 2, -1, -1):\n                dp[i] = dp[i + 1] + arr[i]\n                    \n            res += max(dp)\n            return (res)% (10 ** 9 + 7)\n        \n        cur , res = 0 , 0\n        arr = arr + arr\n        for num in arr:\n            cur = max(cur+num,num)\n            res = max(res,cur)\n        \n        return res % (10 ** 9 + 7)\n        \n", "from math import inf as oo\n\n\nclass Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        total = sum(arr)\n        kadanes = self.maxSubArraySum(arr)\n        if (k < 2): return kadanes%(10**9+7)\n        if (total > 0): return (kadanes + (k-1)*total)%(10**9+7)\n        stitchedKadanes = self.maxSubArraySum(arr*2)\n        return stitchedKadanes%(10**9+7)\n    \n    \n    def maxSubArraySum(self, a):\n        size = len(a)\n        max_so_far = -oo\n        max_ending_here = 0\n        \n        for i in a:\n            max_ending_here += i\n            if max_ending_here < 0: max_ending_here=0\n            max_so_far = max(max_so_far, max_ending_here)\n\n        return max_so_far\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        def find_max(A):\n            start = 0\n            curr = 0\n            res = 0\n            for end in range(len(A)):\n                curr += A[end]\n                while curr<0:\n                    curr -= A[start]\n                    start += 1\n                res = max(res, curr)\n            return res\n        \n        \n        if all(i<=0 for i in arr):\n            return 0\n        if k==1:\n            return find_max(arr)\n        # print (sum(arr)*k)\n        res = max(find_max(arr), find_max(arr+arr), sum(arr)*k, find_max(arr+arr)+sum(arr)*(k-2))\n        return res% (10**9 + 7)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        cum_sum = 0\n        max_sum = 0\n        MOD = 1000000007\n        no_neg_num = True\n        for var in arr:\n            if var < 0:\n                no_neg_num = False\n                \n        if no_neg_num:\n            return sum(arr)*k\n        \n        \n        for i in range(len(arr)):\n            i = i%len(arr)\n            cum_sum = max(cum_sum+arr[i],arr[i])\n            if cum_sum > 0:\n                cum_sum %= MOD\n            max_sum = max(cum_sum,max_sum)\n            \n        if k == 1:\n            return max_sum\n            \n        cum_sum2 = 0\n        max_sum2 = 0\n        for i in range(len(arr)*2):\n            i = i%len(arr)\n            cum_sum2 = max(cum_sum2+arr[i],arr[i])\n            if cum_sum2 > 0:\n                cum_sum2 %= MOD\n            max_sum2 = max(cum_sum2,max_sum2)\n            \n        # print(max_sum)\n        # print(cum_sum)\n        # print(max_sum2)\n        # print(cum_sum2)\n        if sum(arr) > 0:\n            return (max_sum+((sum(arr))%MOD)*(k-1))%MOD\n        else:\n            return max_sum2\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        # 1 -2 1  1 -2 1   1 -2 1   1 -2 1   1 -2 1\n        if max(arr) <= 0:\n            return 0\n        if sum(arr) > 0:        # \u9700\u8981\u627e\u5230\u6700\u5927\u7684\u8d77\u59cb\u70b9\n            res = sum(arr) * (k - 2)\n            dp = [0] * len(arr)\n            dp[0] = arr[0]\n            for i in range(1,len(arr)):\n                dp[i] = dp[i - 1] + arr[i]\n                    \n            res += max(dp)\n            dp = [0] * len(arr)\n            dp[-1] = arr[-1]\n            for i in range(len(arr) - 2, -1, -1):\n                dp[i] = dp[i + 1] + arr[i]\n                    \n            res += max(dp)\n            return (res)% (10 ** 9 + 7)\n        \n        # \u5982\u679csum <= 0 \u90a3\u4e48\u53ea\u9700\u8981\u8003\u8651\u4e24\u8f6e\u5c31\u597d\u4e86\n        cur , res = 0 , 0\n        arr = arr + arr\n        for num in arr:\n            cur = max(cur+num,num)\n            res = max(res,cur)\n        \n        return res % (10 ** 9 + 7)\n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        m = 10**9+7\n        def kadane(arr):\n            cur =0\n            res = 0\n            for a in arr:\n                cur = max(a, cur+a)\n                res = max(res, cur)\n\n            return res\n        if k==1:\n            return kadane(arr)\n        else:\n            if sum(arr)<=0:\n                return kadane(arr*2)\n            else:\n                return (kadane(arr) + (k-1)*sum(arr))%m\n", "class Solution:\n    def kadanes(self,arr,n):\n        max_so_far = 0\n        max_here = 0\n        \n        for i in range(n):\n            max_here += arr[i % len(arr)]\n            if max_so_far < max_here:\n                max_so_far = max_here\n            if max_here < 0:\n                max_here = 0\n        return max_so_far\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        \n        if k >= 2:\n            return self.kadanes(arr,len(arr)*2) + (k-2) * max(sum(arr),0) % (10**9+7)\n        else:\n            return self.kadanes(arr,len(arr)) % (10**9+7)", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        c = sum(arr)\n        out = 0\n        out = max (out,c*k)\n        straight_sum = arr[:]\n        back_sum = arr[:]\n        s = 0\n        kadan = arr[:]\n        for i in range(1,len(kadan)):\n            kadan[i] = max(kadan[i],kadan[i-1] + kadan[i])\n        out = max(max(kadan),out)\n        for i in range(len(arr)):\n            out = max(out,arr[i])\n            s +=arr[i]\n            straight_sum[i] = s\n        s = 0\n        for i in range(len(arr)-1,-1,-1):\n            s+=arr[i]\n            back_sum[i] = s\n        if k ==1:\n            out = max(out,max(straight_sum),max(back_sum))\n            return out\n        if k > 2:\n            out = max(out,max(straight_sum) + max(back_sum) + c*(k-2))\n        out = max(max(straight_sum) + max(back_sum),out)\n        \n        return out % (10**9 + 7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        def kadane(arr):\n            for i in range(1, len(arr)):\n                arr[i] += arr[i - 1] if arr[i - 1] > 0 else 0\n            return max(max(arr), 0)\n        \n        if k <= 2:\n            return kadane(arr * k) % mod\n        return (kadane(arr * 2) + (k - 2) * max(sum(arr), 0)) % mod        \n        \n        # s = sum(arr)\n        # if s < \n        # mod = 10 ** 9 + 7\n        # nums = arr * 2\n        # n = len(arr)\n        # for i in range(1, len(nums)):\n        #     if nums[i - 1] > 0:\n        #         nums[i] += nums[i - 1]\n        # if k <= 2:\n        #     max_sum = max(nums[: n * k])\n        #     return max_sum % mod if max_sum >= 0 else 0\n        # n1, n2 = max(nums[n: 2 * n]), max(nums[2 * n: 3 * n])\n        # if n2 > n1:\n        #     return n1 + (k - 2) * (n2 - n1) % mod\n        # else:\n        #     return n1 % mod if n1 >= 0 else 0\n        \n        \n        def Kadane(arr, res = 0, cur = 0):\n            for num in arr:\n                cur = max(num, num + cur)\n                res = max(res, cur)\n            return res\n        return ((k - 2) * max(sum(arr), 0) + Kadane(arr * 2)) % mod if k > 1 else Kadane(arr) % mod", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        def Kadane(arr, res = 0, cur = 0):\n            for num in arr:\n                cur = max(num, num + cur)\n                res = max(res, cur)\n            return res\n        sm = sum(arr)\n        if sm >= 0:\n            sm = sm * k\n        print (sum(arr), Kadane(arr))\n        if k == 1:\n            return max(sm, Kadane(arr)) % mod\n        return max(sm, max(sum(arr), 0) * (k - 2) + Kadane(arr * 2)) % mod", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        m = min(arr)\n        M = max(arr)\n        s = sum(arr)\n        if m > 0 :\n            return s*k\n        if M < 0 :\n            return 0\n        \n        ans = 0\n        prefix_sum = 0 \n        m_prefix_sum = 0\n        \n        for num in arr:\n            prefix_sum += num\n            ans = max(ans,prefix_sum-m_prefix_sum)\n            m_prefix_sum = min(m_prefix_sum,prefix_sum)\n        if k == 1:\n            return ans\n        \n        prefix_sum = 0\n        p_M = 0\n        for num in arr:\n            prefix_sum += num\n            p_M = max(p_M,prefix_sum)\n        suffix_sum = 0\n        s_M = 0\n        for num in arr[::-1]:\n            suffix_sum+= num\n            s_M = max(s_M,suffix_sum)\n            \n        return max(ans,p_M+s_M+(k-2)*s,p_M+s_M) % (10**9+7)\n        \n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        \n        m = 10**9+7\n        def kadane(arr):\n            cur =0\n            res = 0\n            for a in arr:\n                cur = max(a, cur+a)\n                res = max(res, cur)\n\n            return res\n        if k==1:\n            return kadane(arr)\n        else:\n            if sum(arr)<=0:\n                return kadane(arr*2)\n            else:\n                return (kadane(arr) + (k-1)*sum(arr))%m", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        c = sum(arr)\n        out = 0\n        straight_sum = arr[:]\n        back_sum = arr[:]\n        s = 0\n        kadan = arr[:]\n        for i in range(1,len(kadan)):\n            kadan[i] = max(kadan[i],kadan[i-1] + kadan[i])\n        out = max(max(kadan),out)\n        for i in range(len(arr)):\n            out = max(out,arr[i])\n            s +=arr[i]\n            straight_sum[i] = s\n        s = 0\n        for i in range(len(arr)-1,-1,-1):\n            s+=arr[i]\n            back_sum[i] = s\n        if k ==1:\n            out = max(out,max(straight_sum),max(back_sum))\n            return out\n        if k > 2:\n            out = max(out,max(straight_sum) + max(back_sum) + c*(k-2))\n        out = max(max(straight_sum) + max(back_sum),out)\n        \n        return out % (10**9 + 7)\n", "class Solution:\n    def kConcatenationMaxSum(self, arr: List[int], k: int) -> int:\n        L=arr\n        m=0\n        t=0\n        l=0\n        lm=0\n        sm=0\n        for i in L:\n            l+=i\n            lm=max(lm,l)\n            if(t+i>0): t+=i\n            else: t=0\n            m=max(m,t)\n            sm+=i\n        \n        r=0\n        rm=0\n        for i in range(len(L)-1,-1,-1):\n            r+=L[i]\n            rm=max(rm,r)\n            \n            \n        #print(lm,rm,m)\n            \n        if(k==1): return m%(10**9+7)\n        elif(k==2): return max(m,(rm+lm))%(10**9+7)\n        else:\n            s=(rm+lm)%(10**9+7)\n            if(sm>0):\n                return max(m,(s+sm*(k-2)))%(10**9+7)\n            else: return max(s,m)%(10**9+7)\n"]
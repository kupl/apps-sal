["l,r  = map(int, input().split(\" \"))\nif l == r:\n    print (l)\nelse:\n    print (2)", "a, b = list(map(int, input().split()))\nif a != b:\n    print(2)\nelse:\n    print(a)\n", "l,r=map(int,input().split())\nif abs(l-r)>0:\n    print(2)\nelse:\n    print(l)", "L, R = [int(i) for i in input().split()]\n\nif L == R:\n    print(L)\nelse:\n    print(2)\n", "def __starting_point():\n    l, r = list(map(int, input().split()))\n    if l == r:\n        print(l)\n    else:\n        print(2)\n\n__starting_point()", "l, r = map(int, input().split())   \nif l == r:\n    print(l)\nelse:\n    print(2)", "l, r = list(map(int, input().split()))\nif l == r:\n    print(l)\nelse:\n    print(2)\n", "l, r = map(int, input().split())\nprint(2 if r - l + 1 >= 2 else l)", "l,r = list(map(int,input().split()))\nif l==r:\n\tprint(l)\nelse:\n\tprint(2)\n", "l, r = [int(i) for i in input().split()]\nif l != r:\n    print(2)\nelse:\n    print(r)\n", "l,r = map(int, input().split())\nif l == r:\n    print(l)\nelse:\n    print(2)", "l, r = list(map(int, input().split()))\n\nif l == r:\n    print(l)\nelse:\n    print(2)\n", "x, y = list(map(int, input().split()))\n\nif x == y:\n    print(x)\nelse:\n    print(2)\n", "I = lambda: input().split()\nl, r = map(int, I())\nif l == r:\n    print(l)\nelse:\n    print(2)", "import sys\n\ndef solve():\n    l, r = map(int, input().split())\n\n    if l == r:\n        ans = l\n    else:\n        ans = 2\n\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "l, r = list(map(int, input().split()))\n\nif l == r:\n    print(l)\nelse:\n    print(2)\n", "l,r = map(int,input().split())\nif(l==r):\n\tprint(l)\nelse:\n\tprint(2)", "L, R = map(int, input().split())\nif (R != L):\n    print(2)\nelse:\n    print(L)", "tmp=input()\ntmp=tmp.split(' ')\nl=int(tmp[0])\nr=int(tmp[1])\nif (l==r):\n    print(l)\nelse:\n    print(2)\n", "l, r = map(int, input().split())\n\nif l == r:\n    print(l)\nelse:\n    print(2)", "import math,string,itertools,collections,re,fractions,array,copy\nimport bisect\nimport heapq\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import deque, defaultdict, OrderedDict, namedtuple, Counter, ChainMap\n\n\n# Guide:\n#   1. construct complex data types while reading (e.g. graph adj list)\n#   2. avoid any non-necessary time/memory usage\n#   3. avoid templates and write more from scratch\n#   4. switch to \"flat\" implementations\n\ndef VI(): return list(map(int,input().split()))\ndef I(): return int(input())\ndef LIST(n,m=None): return [0]*n if m is None else [[0]*m for i in range(n)]\ndef ELIST(n): return [[] for i in range(n)]\ndef MI(n=None,m=None): # input matrix of integers\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = VI()\n    return arr\ndef MS(n=None,m=None): # input matrix of strings\n    if n is None: n,m = VI()\n    arr = LIST(n)\n    for i in range(n): arr[i] = input()\n    return arr\ndef MIT(n=None,m=None): # input transposed matrix/array of integers\n    if n is None: n,m = VI()\n    a = MI(n,m)\n    arr = LIST(m,n)\n    for i,l in enumerate(a):\n        for j,x in enumerate(l):\n            arr[j][i] = x\n    return arr\n\ndef main(info=0):\n    # n = I()\n    # a = VI()\n    # aa = MI()\n    # s = input()\n    # ss = MS()\n    # n,m = VI()\n    # u,v,w = MIT(n,m)\n    # img = MS(n,m)\n    l,r = VI()\n    #math.gcd(l,r)\n    if l==r:\n        print(l)\n        return\n    print(2)\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "l, r = list(map(int, input().split()))\nif l != r:\n\tprint(\"2\")\nelse:\n\tprint(l)\n", "l, r = list(map(int, input().split()))\nl1, r1 = l, r\nif l == r:\n    print(l)\nelse:\n    print(2)\n", "def Main():\n\ta, b = map(int ,input().split())\n\tif a == b:\n\t\tprint(a)\n\telse:\n\t\tprint(2)\n\t\ndef __starting_point():\n  Main()\n__starting_point()"]
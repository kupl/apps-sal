["def mat(shape, inital_val=None):\n    if len(shape) > 1:\n        return [mat(shape[1:], inital_val) for _ in range(shape[0])]  \n    else:\n        return [inital_val] * shape[0]\n            \ndef main():\n    n, m = [int(x) for x in input().split()]\n    graph = [{} for _ in range(n)]\n    for _ in range(m):\n        v, u, c = input().split()\n        graph[int(v) - 1][int(u) - 1] = c\n    \n    winner_table = mat([n, n, 26])\n    \n    def get_winner(u, v, char_to_beat):\n        \"\"\"\n        Args:\n            u: The position of current turn's player. \n            v: The position of next turn's player.\n            char_to_beat: The character played in the previous round.\n        Returns:\n            'A' if current turn's player wins, 'B' otherwise.\n        \"\"\"\n        char_idx = ord(char_to_beat) - ord('a')\n        if not winner_table[u][v][char_idx]:\n            winner = 'B'\n            for w, c in list(graph[u].items()):\n                if c >= char_to_beat and get_winner(v, w, c) == 'B':\n                    winner = 'A'\n                    break\n            winner_table[u][v][char_idx] = winner\n        return winner_table[u][v][char_idx]\n    \n    for i in range(n):\n        print(''.join(get_winner(i, j, 'a') for j in range(n)))\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "# int(input())\n\n# [int(i) for i in input().split()]\n\nimport sys\n\nsys.setrecursionlimit(20000)\n\ndef go(v,w,last):\n\n    if game[v][w][last] >= 0: return(game[v][w][last])\n\n\n\n    flag = 0\n\n    move = 0\n\n\n\n    for p in edges_out[v]:\n\n        if p[1] >= last:\n\n            move = 1\n\n            if  not go(w,p[0],p[1]):\n\n                flag = 1\n\n                break\n\n\n\n    if not move or not flag:\n\n        game[v][w][last] = 0\n\n        return(0)\n\n    else:\n\n        game[v][w][last] = 1\n\n        return(1)\n\n            \n\n\n\nn,m = [int(i) for i in input().split()]\n\nedges_in = []\n\nedges_out = []\n\nfor i in range(n):\n\n    edges_in.append([])\n\n    edges_out.append([])\n\n\n\nfor i in range(m):\n\n    s1,s2,s3 = input().split()\n\n    v = int(s1)-1\n\n    w = int(s2)-1\n\n    weight = ord(s3[0]) - ord('a') + 1\n\n    edges_out[v].append((w,weight))\n\n    edges_in[w].append((v,weight))\n\n\n\ngame = []\n\nfor i in range(n):\n\n    tmp1 = []\n\n    for j in range(n):\n\n        tmp2 = []\n\n        for c in range(27):\n\n            tmp2.append(-1)\n\n        tmp1.append(tmp2)\n\n    game.append(tmp1)\n\n\n\n##for v in range(n):\n\n##    for w in range(n):\n\n##        for last in range(27):\n\n##            go(v,w,last)\n\n\n\nfor v in range(n):\n\n    s = ''\n\n    for w in range(n):\n\n        \n\n        if go(v,w,0): s = s + 'A'\n\n        else: s = s + 'B'\n\n    print(s)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "import sys\n# sys.setrecursionlimit(10**5) \nn,m=map(int,input().split())\ng={i:[] for i in range(1,n+1)}\ndp=[[[-1]*26 for _ in range(n+1)] for i in range(n+1)]\ndef rec(i,j,ch):\n\tif dp[i][j][ord(ch)-ord('a')]!=-1:\n\t\treturn dp[i][j][ord(ch)-ord('a')]\n\tfor x in g[i]:\n\t\tif ord(x[1])>=ord(ch):\n\t\t\tv=rec(j,x[0],x[1])\n\t\t\tif not v:\n\t\t\t\tdp[i][j][ord(ch)-ord('a')]=1\n\t\t\t\treturn 1\n\tdp[i][j][ord(ch)-ord('a')]=0\n\treturn 0\n\nfor _ in range(m):\n\tline=input().split()\n\ta=int(line[0])\n\tb=int(line[1])\n\tc=line[2]\n\tg[a].append([b,c])\nfor i in range(1,n+1):\n\tfor j in range(1,n+1):\n\t\tprint('A',end=\"\") if rec(i,j,'a') else print('B',end=\"\")\n\tprint()\n \t\t\t\t   \t   \t\t\t\t    \t\t\t   \t \t \t"]
["class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens = sorted(tokens)\n        left = 0\n        right = len(tokens) - 1\n        points = 0\n\n        if len(tokens) == 1:\n            if tokens[0] <= P:\n                return 1\n        if len(tokens) == 0:\n            return 0\n        while left < right:\n\n            if tokens[left] <= P:\n                P -= tokens[left]\n                left += 1\n                points += 1\n\n            elif tokens[left] > P and points > 0:\n                P += tokens[right]\n                points -= 1\n                right -= 1\n            \n            \n            elif points == 0 and tokens[left] > P:\n                break\n        if P >= tokens[left]:\n            points += 1\n        return points", "class Solution:\n    \n    # O(nlog(n) + n) = O(n(log(n) + 1)) = O(nlog(n)) time / O(1) space or memory\n    # Where 'n' is the number of tokens passed in the input\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        # we wanna maximize the points in this game (by giving the power to get points)\n        # we can give point away to get power\n        tokens.sort() # O(mlog(m))\n        max_points = 0\n        points = 0\n        i = 0\n        j = len(tokens) - 1\n        \n        while i <= j:\n            if P >= tokens[i]:\n                points += 1 # get a coin\n                P -= tokens[i] # give up power\n                max_points = max(points, max_points)\n                i += 1\n            elif points > 0:\n                points -= 1 # give up that coin\n                P += tokens[j] # get power\n                j -= 1\n            else:\n                return max_points\n            \n        return max_points", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        max_points, points = 0, 0\n        tokens.sort()\n        i, j = 0, len(tokens) - 1\n        while i <= j:\n            if P < tokens[i]:\n                if i == j or points == 0: break\n                P += tokens[j]\n                points -= 1\n                j -= 1\n            points += 1\n            P -= tokens[i]\n            i += 1\n            max_points = max(max_points, points)\n        return max(max_points, points)", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens.sort()\n        if(not tokens or P < tokens[0]):\n            return 0\n        l, r = 0, len(tokens)-1\n        points = 0\n        \n        while(l <= r):\n            if(P >= tokens[l]):\n                points += 1\n                P -= tokens[l]\n                l += 1\n            else:\n                if(r-l > 1):\n                    points -= 1\n                    P += tokens[r]\n                    r -= 1\n                else:\n                    break\n        return points", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        if not tokens: return 0\n        \n        tokens.sort()\n        \n        point = 0\n        while tokens:\n            if P < tokens[0]:\n                if point and len(tokens) > 1:\n                    P += tokens.pop()\n                    point -= 1\n                else:\n                    break\n            else:\n                P -= tokens.pop(0)\n                point += 1\n        \n        return point", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        # use 100, P = 100, p = 1\n        # 400 down, P = 500, p = 0\n        # use 200, P = 300, p = 1\n        # use 300, P = 0, p = 2\n\n        '''\n        sort tokens\n        play smallest tokens until you can't anymore\n        turn over largest tokens until you can play smaller tokens again\n        '''\n        \n        tokens.sort()\n        maxPoints = 0\n        points = 0\n        left, right = 0, len(tokens) - 1\n        while left <= right and P >= 0:\n            if P - tokens[left] >= 0:\n                P -= tokens[left]\n                points += 1\n                maxPoints = max(maxPoints, points)\n                left += 1\n            else:\n                if points > 0:\n                    P += tokens[right]\n                    \n                    points -= 1\n                    right -= 1\n                else:\n                    break\n        \n        return max(maxPoints, points)", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens.sort()\n        left = 0\n        right = len(tokens) - 1\n        ans = 0\n        curr = 0\n        while not left > right:\n            if P >= tokens[left]:\n                curr += 1\n                ans = max(ans, curr)\n                P -= tokens[left]\n                left += 1\n            elif curr > 0:\n                P += tokens[right]\n                curr -= 1\n                right -= 1\n            else: break\n            \n        return ans", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        n = len(tokens)\n        tokens.sort()\n        i = 0\n        j = n-1\n        points = 0\n        result = 0\n        \n        while i <= j:\n            if tokens[i] <= P:\n                points += 1\n                result = max(result, points)\n                P -= tokens[i]\n                i += 1\n            else:\n                if points == 0:\n                    break\n                P += tokens[j]\n                points -= 1\n                j -= 1\n        \n        return result", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        max_points, points = 0, 0\n        tokens.sort()\n        i, j = 0, len(tokens) - 1\n        while i <= j:\n            if P < tokens[i]:\n                if i == j or points == 0: break\n                P += tokens[j]\n                points -= 1\n                j -= 1\n            points += 1\n            P -= tokens[i]\n            i += 1\n            max_points = max(max_points, points)\n        return max_points", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        startIndex = 0\n        endIndex = len(tokens) - 1\n        points = 0\n        tokens.sort()\n        while(True):\n            print(startIndex, endIndex, P)\n            if(startIndex > endIndex or endIndex < startIndex):\n                return points\n            if(P >= tokens[startIndex]):\n                points += 1\n                P -= tokens[startIndex]\n                startIndex += 1\n            else:\n                if(points == 0):\n                    return points\n                else:\n                    if(startIndex == endIndex):\n                        return points\n                    else:\n                        P += tokens[endIndex]\n                        endIndex -= 1\n                        points -= 1", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens.sort()\n        \n        buyer,seller = 0,len(tokens)-1\n        max_items = current_items = 0\n        \n        while buyer <= seller:\n            if P >= tokens[buyer]:\n                P -= tokens[buyer]\n                current_items+=1\n                buyer+=1\n            else:\n                if current_items ==0:\n                    break;\n                else:\n                    P += tokens[seller]\n                    current_items -=1\n                    seller -=1\n            max_items = max(max_items,current_items)\n        return max_items", "class Solution:\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        if not len(tokens) :\n            return 0\n        tokens.sort()\n        res = 0\n        deque = collections.deque(tokens)\n        \n        while( len( deque ) > 1 and ( P >= deque[0] or res ) ):\n            while( deque and P > deque[0] ):\n                res += 1\n                P -= deque.popleft()\n            if( len( deque ) > 1 and res ):\n                P += deque.pop()\n                res -= 1\n\n        if ( deque and P >= deque[0] ):\n            res += 1\n        return res", "class Solution:\n    # all the tokens start in a neutral position. Can either play it face up or face down.\n    def bagOfTokensScore(self, tokens: List[int], P: int) -> int:\n        tokens.sort()\n        \n        # start from front and back. greedily take all the powers from the front and spend score in back to get more to add to the front\n        def twoPointer(tokens, P):\n            i = 0\n            j = len(tokens)-1\n            score = 0\n            maxScore = 0\n            while i <= j:\n\n                flag = False\n                while i < len(tokens) and P >= tokens[i]:\n                    score += 1\n                    P -= tokens[i]\n                    i += 1\n                    flag = True\n                if flag:\n                    maxScore = max(score, maxScore)\n                    continue\n                    \n                if score > 0:\n                    score -= 1\n                    P += tokens[j]\n                    j -= 1\n                \n                elif P < tokens[i]:\n                    return score\n            return maxScore\n        \n        def helper(tokens, P, score):\n            maxVal = score\n            if score > 0 and len(tokens) > 0:\n                maxVal = max(helper(tokens[:len(tokens)-1], P + tokens[len(tokens)-1], score - 1), maxVal)\n        \n            for i in range(len(tokens)-1, -1, -1):\n                if P >= tokens[i]:\n                    maxVal = max(helper(tokens[:i] + tokens[i+1:], P - tokens[i], score + 1), maxVal)\n            return maxVal\n        \n        return twoPointer(tokens, P)\n        \n"]
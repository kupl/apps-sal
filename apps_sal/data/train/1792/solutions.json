["def three_by_n(n):\n    A = [1, 2] + [0]*(n-1)\n    B = [0, 1] + [0]*(n-1)\n    C = [1, 0] + [0]*(n-1)\n    D = [0, 1] + [0]*(n-1)\n    for i in range(2, n+1):\n        A[i] = A[i-2] + 2*B[i-1] + 2*C[i-1] + 2*D[i] + 2*D[i-2]\n        B[i] = A[i-1] + B[i-2] + C[i-2] + D[i-1]\n        C[i] = C[i-2] + 2*D[i-1]\n        D[i] = C[i-1] + D[i-2]\n    return A[n] % 12345787", "# segment the pics and find the law\ndef countWays(n): \n    A = [0] * (n + 1) \n    B = [0] * (n + 1) \n    A[0] = 1\n    A[1] = 2\n    B[0] = 0\n    B[1] = 1\n    for i in range(2, n + 1): \n        if (i % 2):\n            B[i] = (A[i - 1] + B[i - 2]) % 12345787\n            A[i] = (A[i - 2] + 2 * B[i] + 2 * B[i - 1]) % 12345787\n        else:\n            A[i] = (A[i - 2] + 2 * B[i - 1]) % 12345787\n            B[i] = (A[i - 1] + A[i - 2] + B[i - 1] + B[i - 2]) % 12345787\n    return A[n]\n    \ndef three_by_n(n):\n    return countWays(n)", "a=[1];b=[0];c=[0];d=[0];e=[0];f=[0]\nfor _ in range(10000):\n    aa=b[-1]+c[-1]+f[-1]\n    bb=a[-1]+d[-1]\n    cc=a[-1]+e[-1]\n    dd=b[-1]\n    ee=c[-1]\n    ff=a[-1]\n\n    a.append(aa%12345787)\n    b.append(bb%12345787)\n    c.append(cc%12345787)\n    d.append(dd%12345787)\n    e.append(ee%12345787)\n    f.append(ff%12345787)\n\ndef three_by_n(n):\n    if n%2==0: return a[n]\n    tot=0\n    for i in range(n):\n        tot += d[i]*a[n-i-1] + a[i]*d[n-i-1] + b[i]*b[n-i-1] + a[i]*a[n-i-1]\n        tot %= 12345787\n    return (2*tot) % 12345787", "MOD = 12345787\nFLAG = False\nf = []\n\ndef prework(MAXN=10000):\n    nonlocal FLAG\n    nonlocal f\n    if FLAG:\n        return\n    FLAG = True\n    f = [[[0, 0] for j in range(8)] for i in range(MAXN + 2)]\n    # f[i][j][k], k -> already use hole\n    f[0][7][0] = 1\n    for i in range(MAXN + 1):\n        for j in range(7):\n            for k in range(3):\n                if ((j >> k) & 1) == 0:\n                    f[i][j | (1 << k)][1] += f[i][j][0]\n        for j in range(8):\n            for k in range(2):\n                f[i][j][k] %= MOD\n        for k in range(2):\n            # f[i][*][k] -> f[i+1][?][k]\n            f[i + 1][7][k] += f[i][0][k]\n            f[i + 1][1][k] += f[i][0][k]\n            f[i + 1][4][k] += f[i][0][k]\n            f[i + 1][0][k] += f[i][1][k]\n            f[i + 1][6][k] += f[i][1][k]\n            f[i + 1][5][k] += f[i][2][k]\n            f[i + 1][4][k] += f[i][3][k]\n            f[i + 1][3][k] += f[i][4][k]\n            f[i + 1][0][k] += f[i][4][k]\n            f[i + 1][2][k] += f[i][5][k]\n            f[i + 1][1][k] += f[i][6][k]\n            f[i + 1][0][k] += f[i][7][k]\n\ndef three_by_n(n):\n    prework()\n    return f[n + 1][0][n % 2] % MOD", "\"\"\"\ndef three_by_n_without_hole_missing_top(n):\n    # the first column can be _11, _12\n    assert n%2 == 1\n    if n == 1:\n        return 1\n    return three_by_n_without_hole_missing_top(n-2) \\\n        + three_by_n_without_hole(n-1)\n\ndef three_by_n_without_hole(n):\n    # the first column can be 112, 122, 123\n    # the first two cases are the same by symmetry\n    assert n%2 == 0\n    if n == 0:\n        return 1\n    return three_by_n_without_hole_missing_top(n-1)*2 \\\n        + three_by_n_without_hole(n-2)\n\ndef three_by_n_with_hole_missing_top(n):\n    # the first column can be _X1, _1X, _11, _12\n    # the second case is impossible because it would have to look like:\n    # _225588...\n    # 114477....\n    # X336699...\n    # the fourth case is divided into two cases,\n    # depending on whether the next column is X12 or 312\n    assert n%2 == 0\n    if n == 0:\n        return 0\n    return three_by_n_without_hole_missing_top(n-1) \\\n        + three_by_n_with_hole(n-1) \\\n        + three_by_n_with_hole_missing_top(n-2) \\\n        + three_by_n_without_hole(n-2)\n\ndef three_by_n_with_hole(n):\n    # the first column can be X11, X12, 1X2, 11X, 12X, 112, 122, 123\n    # by symmetry:\n    # case 4 = case 1\n    # case 5 = case 2\n    # case 7 = case 6\n    # note that case 3 is impossible because it would have to look like:\n    # 114477....\n    # X225588...\n    # 336699....\n    assert n%2 == 1\n    if n == 1:\n        return 2\n    return three_by_n_without_hole(n-1)*2            \\\n        + three_by_n_without_hole_missing_top(n-2)*2 \\\n        + three_by_n_with_hole_missing_top(n-1)*2    \\\n        + three_by_n_with_hole(n-2)\n\"\"\"\n\n# naive algorithm\ndef mat_mul(A,B):\n    n = len(A)\n    # the top left entry is A[0][0]*B[0][0] + A[0][1]*B[1][0] + ...\n    return [[sum(A[i][k]*B[k][j]%12345787 for k in range(n))%12345787 for j in range(n)] for i in range(n)]\n\n# exponentiation by squaring\ndef mat_pow(A,k):\n    n = len(A)\n    res = [[0+(i==j) for j in range(n)] for i in range(n)] # A^0\n    while k:\n        if k%2 == 1:\n            res = mat_mul(res,A)\n        A = mat_mul(A,A)\n        k //= 2\n    return res\n\n# let:\n# A = three_by_n_without_hole_missing_top\n# B = three_by_n_without_hole\n# C = three_by_n_with_hole_missing_top\n# D = three_by_n_with_hole\n# initial cases:\n# A[1] = 1\n# B[0] = 1\n# C[0] = 0\n# D[1] = 2\n# recursive formulas:\n# A[n] =  A[n-2] +  B[n-1]\n# B[n] = 2A[n-1] +  B[n-2]\n# C[n] =  A[n-1] +  B[n-2] +  C[n-2] + D[n-1]\n# D[n] = 2A[n-2] + 2B[n-1] + 2C[n-1] + D[n-2]\n# adjust parity\n# A[2k+1] =  A[2(k-1)+1] +  B[2k]\n# B[2k]   = 2A[2(k-1)+1] +  B[2(k-1)]\n# C[2k]   =  A[2(k-1)+1] +  B[2(k-1)] +  C[2(k-1)] + D[2(k-1)+1]\n# D[2k+1] = 2A[2(k-1)+1] + 2B[2k]     + 2C[2k]     + D[2(k-1)+1]\n# offset\n# A[2k+1] = 3A[2(k-1)+1] +  B[2(k-1)]\n# B[2k]   = 2A[2(k-1)+1] +  B[2(k-1)]\n# C[2k]   =  A[2(k-1)+1]    B[2(k-1)] +  C[2(k-1)] +  D[2(k-1)+1]\n# D[2k+1] = 8A[2(k-1)+1] + 4B[2(k-1)] + 2C[2(k-1)] + 3D[2(k-1)+1]\n\ndef three_by_n_without_hole(n):\n    res = mat_pow([[3,1],[2,1]],n//2)\n    return res[0][0]\n\ndef three_by_n_with_hole(n):\n    res = mat_pow([[3,1,0,0],[2,1,0,0],[1,1,1,1],[8,4,2,3]],n//2)\n    return (res[3][0] + res[3][1] + 2*res[3][3])%12345787\n\ndef three_by_n(n):\n    if n%2 == 1:\n        return three_by_n_with_hole(n)\n    return three_by_n_without_hole(n)", "memo, N, MOD = [0], 10000, 12345787\n\ndef three_by_n(n):\n    if len(memo) <= N:\n        dp = [[0] * (1<<4) for _ in range(2)]\n        crt, nxt = dp[0], dp[1]\n        crt[0] = 1\n        for x in range(N-1, -1, -1):\n            for y in range(3-1, -1, -1):\n                for used in range(1 << 4):\n                    if (used >> y) & 1:\n                        nxt[used] = crt[used & ~(1 << y)]\n                    else:\n                        res = crt[used | 1 << (y+1)] if y+1 < 3 and not(used >> (y+1) & 1) else 0\n                        res += crt[used | (1 << y)] if x+1 < N else 0\n                        if (used >> 3):\n                            nxt[used] = (nxt[used] + res) % MOD\n                        else:\n                            nxt[used] = res % MOD\n                            nxt[used | 1 << 3] = crt[used & ~(1 << y)]\n                crt, nxt = nxt, crt\n            memo.append(crt[0] if x % 2 == 0 else crt[1<<3])\n    return memo[n]", "def countWays(n): \n    A = [0] * (n + 1) \n    B = [0] * (n + 1) \n    A[0] = 1\n    A[1] = 2\n    B[0] = 0\n    B[1] = 1\n    for i in range(2, n + 1): \n        if (i % 2):\n            B[i] = (A[i - 1] + B[i - 2]) % 12345787\n            A[i] = (A[i - 2] + 2 * B[i] + 2 * B[i - 1]) % 12345787\n        else:\n            A[i] = (A[i - 2] + 2 * B[i - 1]) % 12345787\n            B[i] = (A[i - 1] + A[i - 2] + B[i - 1] + B[i - 2]) % 12345787\n    return A[n]\n    \ndef three_by_n(n):\n    return countWays(n)", "cache_f = {}\ncache_g = {}\n\ndef f(n):\n    if n in cache_f:\n        return cache_f[n]\n    if n == 0: return 1\n    if n == 1: return 0\n    else:\n        def g(n):\n            if n in cache_g:\n                return cache_g[n]\n            if n == 0: \n                cache_g[0] = 0\n                return 0\n            if n == 1: \n                cache_g[1] = 1\n                return 1\n            else:\n                cache_g[n] = f(n-1)+g(n-2)\n                return f(n-1)+g(n-2)\n        cache_f[n] = f(n-2)+2*g(n-1)\n        return f(n-2)+2*g(n-1) \n   \nfor i in range(1,11):\n    f(998*i)\n    \ndef three_by_n(n):\n    if n % 2 == 0: return f(n) % 12345787\n    else: \n        res = 0\n        for i in range((n-1)//2):\n            res += cache_g[n-2*(i+1)]*cache_g[2*i+1]*2\n        res += (n+1)*cache_g[n]\n        return res % 12345787", "LST,M = [0,2,3,18,11],12345787\n\ndef gen3N():\n    Ae,Be,Ao,Bo,Co = 3,8,4,8,6\n    while 1:\n        Ae,Be, Ao,Bo,Co = [ v%M for v in (Ae+Be, 2*Ae+3*Be ,\n                                          Be+Ao+Bo+Co, Be+2*Ao+3*(Bo+Co), 2*(Ae+Be) ) ]\n        yield (n%M for n in (Ao+Bo+Co,Ae+Be))\n\nGEN = gen3N()\n\ndef three_by_n(n):\n    while len(LST) <= n: LST.extend(next(GEN))\n    return LST[n]", "def three_by_n(n):\n    MOD = 12345787\n    f = [[1, 0], [1, 2]]\n    g = [[0, 1], [0, 1]]\n    \n    # Without unit block\n    for i in range(2, n + 1):\n        f[0].append((2 * g[0][i - 1] + f[0][i - 2]) % MOD)\n        g[0].append((f[0][i - 1] + g[0][i - 2]) % MOD)\n    \n    # With unit block\n    for i in range(2, n + 1):\n        f[1].append((2 * f[0][i - 1] + 2 * g[0][i - 2] + f[1][i - 2] + 2 * g[1][i - 1]) % MOD)\n        g[1].append((f[0][i - 2] + g[0][i - 1] + f[1][i - 1] + g[1][i - 2]) % MOD)\n    \n    return f[1][n]"]
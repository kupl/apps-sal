["class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        count = 0 \n        for i in range(1,len(grid)-1):\n            for j in range(1,len(grid[0])-1):\n                if grid[i][j] ==0 and self.dfs(grid,i,j):\n                    count+=1\n        return count \n    def dfs(self,grid,i,j):\n        if grid[i][j]==1:\n            return True\n        if i<=0 or j<=0 or i>=len(grid)-1 or j>= len(grid[0])-1:\n            return False\n        grid[i][j]=1\n        up= self.dfs(grid,i+1,j)\n        down= self.dfs(grid,i-1,j)\n        left= self.dfs(grid,i,j-1)\n        right= self.dfs(grid,i,j+1)\n        return up and down and left and right", "class Solution:\n    LAND = 0\n    WATER = 1\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        count=0\n        m, n, count = len(grid), len(grid[0]) if grid else 0, 0           \n        for i in range(1, len(grid)-1):\n            for j in range(1, len(grid[0])-1):\n                if grid[i][j]==self.LAND and self.dfs(i,j,grid) :\n                    count +=1\n        return count\n    def inside_grid(self,x, y,grid):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])\n    \n    def dfs(self,i,j,grid):\n        #m, n = len(grid), len(grid[0]) if grid else 0       \n        #Test = True\n        if grid[i][j]==self.WATER:\n            Test = True\n            return True\n        \n        if(i<=0 or j<=0 or j>= len(grid[0])-1 or i >= len(grid)-1):\n            Test = False\n            return False\n        grid[i][j] = self.WATER \n        Test= True & self.dfs(i+1,j,grid)\n        Test= Test& self.dfs(i-1,j,grid)\n        Test= Test& self.dfs(i,j+1,grid)\n        Test= Test& self.dfs(i,j-1,grid)\n        return Test  ", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        self.num_closed_islands = 0\n        self.visited = set()\n        self.grid = grid\n        self.m = len(grid)\n        self.n = len(grid[0])\n        for i in range(1, self.m - 1):\n            for j in range(1, self.n - 1):\n                if grid[i][j] == 0 and (i, j) not in self.visited:\n                    self.include = True\n                    self.dfs(i, j)\n                    if self.include:\n                        self.num_closed_islands += 1\n        return self.num_closed_islands\n\n    def dfs(self, i, j):\n        if i == 0 or j == 0 or i == (self.m - 1) or j == (self.n - 1):\n            self.include = False\n        self.visited.add((i, j))\n        for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            next_i, next_j = i + x , j + y\n            if (self.in_range(next_i, next_j) and \n                (next_i, next_j) not in self.visited and \n                self.grid[next_i][next_j] == 0):\n                self.dfs(next_i, next_j)\n\\t\\t\n    def in_range(self, i, j):\n        return  0 <= i < self.m and 0 <= j < self.n\n", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.visited = [ [ 0 for _ in range(len(grid[0])) ] for _ in range(len(grid))]\n        def dfs(i, j):\n            if i < 0 or j < 0 or i>=len(self.grid) or j>=len(self.grid[0]) :\n                return False\n            if self.grid[i][j] == 1 or self.visited[i][j]==1:\n                return True\n            self.visited[i][j] = 1\n            neighbs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n            ans = True\n            for x, y in neighbs:\n                curr = dfs(i+x, j+y)\n                if curr == False:\n                    ans = False\n            return ans\n        \n        ans = 0\n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.visited[i][j]==0 and self.grid[i][j]==0:\n                    isclosed = dfs(i, j)\n                    if isclosed==True:\n                        ans+=1\n        return ans\n", "class Solution:\n    \n    directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\n    \n    def __init__(self):\n        self.count = 0\n    \n    @staticmethod\n    def _on_board(board, row, col):\n        return row >= 0 and row < len(board) and col >= 0 and col < len(board[0])\n    \n    def _dfs(self, board, row, col, visited) -> bool:\n        if (row, col) in visited:\n            return True\n        \n        if not Solution._on_board(board, row, col):\n            return False\n        \n        if board[row][col] == 1:\n            return True\n        \n        visited.add((row, col))\n        res = True\n        for d in Solution.directions:\n            new_row = row + d[0]\n            new_col = col + d[1]\n            \n            if not self._dfs(board, new_row, new_col, visited):\n                res = False\n        \n        return res\n            \n    \n    def closedIsland(self, grid: List[List[int]]) -> int:\n        '''\n        DFS\n        '''\n        if not grid or not grid[0]:\n            return 0\n        \n        cnt = 0\n        visited = set()\n        for m in range(len(grid)):\n            for n in range(len(grid[0])):\n                if grid[m][n] == 0 and\\\\\n                    (m, n) not in visited and\\\\\n                    self._dfs(grid, m, n, visited):\n                    cnt += 1\n                    \n        return cnt", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]: return 0\n        self.rows, self.cols = len(grid), len(grid[0])\n        self.memo = {}\n        ans = 0\n        for row in range(self.rows):\n            for col in range(self.cols):\n                if grid[row][col] == 0:\n                    ans += self.dfs(grid, row, col)\n\n        return ans\n    def dfs(self, grid, row, col):\n        if row < 0 or row > self.rows-1 or col < 0 or col > self.cols - 1:\n            return False\n        if (row, col) in self.memo:\n            return self.memo[(row, col)]\n    \n        if grid[row][col] == 1:\n            return True\n        elif row == 0 or row == self.rows - 1 or col == 0 or col == self.cols - 1:\n            return False\n    \n        flag = True\n        directions = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n        grid[row][col] = 1\n        for i in range(4):\n            r, c = directions[i]\n            flag = flag and self.dfs(grid, r, c)\n\n        self.memo[(row, col)] = flag\n        return self.memo[(row, col)]\n\n", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        row, col = len(grid), len(grid[0])\n        output = 0\n        \n        def dfs(i, j):\n            if i in range(row) and j in range(col):\n                if grid[i][j] == 0:\n                    grid[i][j] = 1\n\n                    # DFS to neighbors\n                    bot = dfs(i+1, j)\n                    top = dfs(i-1, j)\n                    right = dfs(i, j+1)\n                    left = dfs(i, j-1)\n                    return (bot and top and right and left)\n                else:\n                    return True\n            else:\n                return False\n                    \n        for i in range(row):\n            for j in range(col):\n                if grid[i][j] == 0:\n                    if dfs(i, j):\n                        output += 1\n                        \n        return output", "import collections\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # closed island point rules: (1) it must be 0 (2) it cannot be boundary \n        #   (3) its nb either 1 or 0 (need to append) (4) all connected component follow this rule\n        visited = set()\n        res = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if (i, j) in visited:\n                    continue\n                if grid[i][j] == 1:\n                    continue\n                tmp = self.bfs(grid, i, j, visited)\n                # if tmp == 1:\n                    #print('found at %d, %d: %s' %(i, j, visited))\n                res += tmp\n        return res\n    def bfs(self, grid, x, y, visited):\n        # return 1 if this (BFS connected) is closed island, else 0\n        visited.add((x, y))\n        # now not boundary, do bfs \n        res = 1 \n        q = collections.deque([(x, y)])\n        while q:\n            x, y = q.pop()\n            if self.is_boundary(grid, x, y):\n                res = 0 # not closed by water \n            for newx, newy in self.get_nb(grid, x, y):\n                if (newx, newy) in visited:\n                    continue                \n                if grid[newx][newy] == 1:\n                    continue # closed by water, stop this direction\n                if grid[newx][newy] == 0:\n                    q.appendleft((newx, newy))\n                    visited.add((newx, newy))\n        return res \n    def get_nb(self, grid, x, y):\n        COOR = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n        res = []\n        for deltax, deltay in COOR:\n            newx, newy = deltax + x, deltay + y\n            if 0 <= newx < len(grid) and 0 <= newy < len(grid[0]):\n                res.append((newx, newy))\n        return res\n    def is_boundary(self, grid, x, y):\n        if x == 0 or x == len(grid) - 1:\n            return True\n        if y == 0 or y == len(grid[0]) - 1:\n            return True\n        return False", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        closed_island = 0\n        if not grid:\n            return closed_island\n        \n        for r in range(1, len(grid)):\n            for c in range(1, len(grid[0])):\n                if grid[r][c] == 0 and self.dfs(grid, r, c):\n                    closed_island += 1\n                    \n        return closed_island   \n    \n    def dfs(self,grid, i, j):\n            \n            if grid[i][j] == 1:\n                return True\n            \n            if i <= 0 or j <= 0 or i >= len(grid) - 1 or j >= len(grid[0]) -1:\n                return False\n            \n            grid[i][j] = 1\n            \n            top = self.dfs(grid, i - 1, j)\n            bottom  = self.dfs(grid, i + 1, j)\n            left = self.dfs(grid, i, j - 1)\n            right = self.dfs(grid, i, j + 1)\n            \n            return top and left and right and bottom", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # find connected 0s not touching any border\n        if not grid or not grid[0]:\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        ans = 0\n        \n        def dfs(i,j,val):\n            if 0<=i<m and 0<=j<n and grid[i][j]==0:\n                grid[i][j] = val\n                dfs(i, j+1, val)\n                dfs(i+1, j, val)\n                dfs(i-1, j, val)\n                dfs(i, j-1, val)\n\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or j == 0 or i == m-1 or j == n-1) and grid[i][j] == 0:\n                    dfs(i, j, 1)\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dfs(i, j, 1)\n                    ans+=1\n                    \n        return ans\n                \n        \n", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if len(grid[0]) == 0:\n            return 0\n\n        num_islands = 0\n\n        for i in range(0, len(grid)):\n            for j in range(0, len(grid[i])):\n                if (i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1):\n                    self.closed_island_helper(grid, [i, j])\n                    \n        for i in range(0, len(grid)):\n            for j in range(0, len(grid[i])):\n                if grid[i][j] == 1:\n                    continue\n\n                num_islands += 1\n                self.closed_island_helper(grid, [i, j])\n        \n        return num_islands\n    \n    def closed_island_helper(self, grid, coord):\n        x, y = coord\n        \n        if x < 0 or y < 0 or x > len(grid) - 1 or y > len(grid[0]) - 1:\n            return\n\n        if x == 0 or y == 0 or x == len(grid) - 1 or y == len(grid[0]) - 1:\n            if grid[x][y] == 1:\n                return\n\n        if grid[x][y] == 1:\n            return\n\n        grid[x][y] = 1\n\n        self.closed_island_helper(grid, [x - 1, y])\n        self.closed_island_helper(grid, [x + 1, y])\n        self.closed_island_helper(grid, [x, y - 1])\n        self.closed_island_helper(grid, [x, y + 1])\n\n        return", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        \n        def dfs(i,j,grid):\n            if grid[i][j]==1:\n                return True\n            if i<=0 or j<=0 or i>=n-1 or j>=m-1:\n                return False\n            grid[i][j]=1\n            \n            up=dfs(i+1,j,grid)\n            down=dfs(i-1,j,grid)\n            right=dfs(i,j+1,grid)\n            left=dfs(i,j-1,grid)\n            \n            return up and down and right and left\n        \n        cnt=0\n        n=len(grid)\n        m=len(grid[0])\n        for i in range(1,n-1):\n            for j in range(1,m-1):\n                if grid[i][j]==0 and dfs(i,j,grid):\n                    cnt+=1\n        return cnt\n", "from functools import lru_cache\nclass Solution:\n    def closedIsland(self, grid):\n        n=len(grid)\n        m=len(grid[0])\n        @lru_cache(None)\n        def dfs(x,y):\n            if x==0 or y==0 or x==n-1 or y==m-1 or grid[x][y]!=0:\n                return grid[x][y]!=0\n            t=True\n            grid[x][y]=-1\n            t=dfs(x-1,y) & dfs(x+1,y) & dfs(x,y+1) & dfs(x,y-1)\n            return t\n        res=0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]==0:\n                    res+=dfs(i,j)\n        return res", "from functools import lru_cache\nclass Solution:\n    def closedIsland(self, grid):\n        n=len(grid)\n        m=len(grid[0])\n        @lru_cache(None)\n        def dfs(x,y):\n            if x==0 or y==0 or x==n-1 or y==m-1 or grid[x][y]!=0:\n                return grid[x][y]!=0\n            # t=True\n            grid[x][y] = -1\n            t = dfs(x-1,y) & dfs(x+1,y) & dfs(x,y+1) & dfs(x,y-1)\n            return t\n        res=0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j]==0:\n                    res+=dfs(i,j)\n        return res", "class UnionFind:\n    \n    def __init__(self):\n        self.parents = {}\n        \n    def find(self, a):\n        if a in self.parents:\n            while a != self.parents[a]:\n                a = self.parents[a]\n        else:\n            self.parents[a] = a\n        return self.parents[a]\n\n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a > b: a, b = b, a # always use smaller key\n        self.parents[b] = a\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # union find\n        m, n = len(grid), len(grid[0])\n        uf = UnionFind()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    if i == 0 or i == m-1 or j == 0 or j == n-1:\n                        uf.union((-1,-1), (i,j)) # use (-1,-1) to be edge\n                    if i > 0 and grid[i-1][j] == 0:\n                        uf.union((i-1,j), (i,j))\n                    if j > 0 and grid[i][j-1] == 0:\n                        uf.union((i,j-1), (i,j))\n                        \n        islands = set()\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    tup = uf.find((i,j))\n                    if tup != (-1,-1):\n                        islands.add(tup)\n                    \n        # print(islands)\n        return len(islands)", "from typing import List\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        num_islands = 0\n        for row_index, row in enumerate(grid):\n            for col_index, val in enumerate(row):\n                if val == 0 and self.check_island(grid, row_index, col_index):\n                    num_islands += 1\n        \n        return num_islands\n    \n    def check_island(self, grid: List[List[int]], row: int, col: int) -> bool:\n        if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]):\n            return False\n        \n        if grid[row][col] == 1:\n            return True\n        \n        grid[row][col] = 1\n        top = self.check_island(grid, row - 1, col) \n        bottom = self.check_island(grid, row + 1, col) \n        right =  self.check_island(grid, row, col + 1) \n        left = self.check_island(grid, row, col - 1) \n        \n        return top and bottom and right and left", "class Solution(object):\n    def closedIsland(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, val):\n            if 0<=i<m and 0<=j<n and grid[i][j]==0:\n                grid[i][j] = val\n                dfs(i, j+1, val)\n                dfs(i+1, j, val)\n                dfs(i-1, j, val)\n                dfs(i, j-1, val)\n        \n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or j == 0 or i == m-1 or j == n-1) and grid[i][j] == 0:\n                    dfs(i, j, 1)\n                \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dfs(i, j, 1)\n                    res += 1\n                    \n        return res\n                    \n                    \n        \n    ", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid: return 0\n        \n        m,n = len(grid),len(grid[0])\n        \n        numIslands = 0\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or j == 0 or i == m-1 or j == n-1) and grid[i][j] == 0:\n                    self.dfs(grid, i, j, 1)\n        \n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    self.dfs(grid, i, j, 1)\n                    numIslands += 1\n                    \n        return numIslands\n    \n    def dfs(self,grid,i,j,val):\n        m,n = len(grid),len(grid[0])\n        \n        grid[i][j] = val\n        for newi,newj in ((i+1,j),(i-1,j),(i,j-1),(i,j+1)):\n            if 0 <= newi < m and 0 <= newj < n and grid[newi][newj] == 0:\n                   # grid[newi][newj] = val\n                    self.dfs(grid,newi,newj,val)\n", "class Solution(object):\n    def closedIsland(self, grid):\n        \\\"\\\"\\\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \\\"\\\"\\\"\n        if not grid or not grid[0]:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        \n        def dfs(i, j, val):\n            if 0<=i<m and 0<=j<n and grid[i][j]==0:\n                grid[i][j] = val\n                dfs(i, j+1, val)\n                dfs(i+1, j, val)\n                dfs(i-1, j, val)\n                dfs(i, j-1, val)\n        \n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or j == 0 or i == m-1 or j == n-1) and grid[i][j] == 0:\n                    dfs(i, j, 1)\n                \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    dfs(i, j, 1)\n                    res += 1\n                    \n        return res", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # we perform bfs to find connected components and from all the connected components we remove those that have a node on the edges\n        # first we create a set of nodes that can act as start nodes\n        possible_start = set()\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0:\n                    possible_start.add((i,j))\n        # now we need to perform bfs from each possible start and find the connected components\n        answer = 0\n        directions = [(-1,0),(1,0),(0,-1),(0,1)]\n        while possible_start != set():\n            start = possible_start.pop()\n            # print('start',start)\n            queue = [start]\n            visited = set([start])\n            if 0 == start[0] or start[0] == len(grid)-1 or 0 == start[1] or start[1] ==  len(grid[1])-1 :\n                remove_this_island = True\n            else:\n                remove_this_island = False\n            while queue != []:\n                c = queue.pop(0)\n                # print(c)\n                for d in directions:\n                    n = (c[0] + d[0] , c[1] + d[1]) \n                    if 0 <= n[0] < len(grid) and 0 <= n[1] < len(grid[0]):\n                        if grid[n[0]][n[1]] == 0:\n                            if 0 == n[0] or n[0] == len(grid)-1 or 0 == n[1] or n[1] ==  len(grid[1])-1 :\n                                remove_this_island = True\n                            if n not in visited:\n                                queue.append(n)\n                                visited.add(n)\n                        \n            # print(visited,remove_this_island)\n            # at the end of the bfs we check if we need to consider this island or not\n            possible_start = possible_start - visited\n            if not remove_this_island:\n                answer += 1\n            \n        return answer", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        if rows == 0:\n            return 0 \n        \n        cols = len(grid[0])\n        if cols == 0:\n            return 0\n        \n        count = 0\n        \n        def recur(x, y):\n            if not 0 <= x < rows or not 0 <= y < cols:\n                return False\n            \n            if grid[x][y] == 1:\n                return True\n            \n            grid[x][y] = 1\n            \n            right = recur(x + 1, y)\n            left = recur(x - 1, y)\n            top = recur(x, y + 1) \n            bot = recur(x, y - 1)\n            return right and left and top and bot\n        \n        \n        for x in range(rows):\n            for y in range(cols):\n                if grid[x][y] == 0 and recur(x, y):\n                    count += 1\n        return count\n    \n    \n", "from collections import defaultdict\ndirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n\nclass DSU:\n    def __init__(self, n):\n        self.n = n\n        self.parent = [x for x in range(n)]\n        self.rank = [0 for x in range(n)]\n        self.land = [False for x in range(n)]\n        \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, s, t):\n        sp, tp = self.find(s), self.find(t)\n        if sp == tp:\n            return\n        if self.rank[sp] > self.rank[tp]:\n            self.parent[tp] = sp\n        elif self.rank[sp] < self.rank[tp]:\n            self.parent[sp] = tp\n        else:\n            self.parent[sp] = tp\n            self.rank[tp] += 1\n        \n        \nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # 0 is land,  1 is water!\n        m, n = len(grid), len(grid[0])\n        net = DSU(m * n)\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == 1:\n                    continue\n                # grid[r][c] = 0: land\n                net.land[r * n + c] = True\n                for d in dirs:\n                    nr, nc = r + d[0], c + d[1]\n                    if not (0 <= nr < m) or not (0 <= nc < n):\n                        continue\n                    elif grid[nr][nc] == 1:\n                        continue\n                    net.union(r * n + c, nr * n + nc)\n        ihm = defaultdict(list) # island hashmap\n        for i in range(m * n):\n            p = net.find(i) # parent\n            if net.land[p]:\n                ihm[p].append((i // n, i % n))\n        islands = list(ihm.values()) # list of list of integer\n        ret = 0\n        for pl in islands: # point list\n            isClosed = True\n            for p in pl: # point\n                r, c = p[0], p[1]\n                if r == m - 1 or c == n - 1 or r == 0 or c == 0:\n                    isClosed = False\n                    break\n            if isClosed:\n                ret += 1\n        return ret\n                    \n", "class Solution:\\r\n    LAND = 0\\r\n    WATER = 1\\r\n    def closedIsland(self, grid: List[List[int]]) -> int:\\r\n        if not grid:\\r\n            return 0\\r\n        count=0\\r\n        m, n, count = len(grid), len(grid[0]) if grid else 0, 0           \\r\n        for i in range(1, len(grid)-1):\\r\n            for j in range(1, len(grid[0])-1):\\r\n                if grid[i][j]==self.LAND and self.dfs(i,j,grid) :\\r\n                 count +=1\\r\n        return count\\r\n    def inside_grid(self,x, y,grid):\\r\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0])\\r\n    \\r\n    def dfs(self,i,j,grid):\\r\n        #m, n = len(grid), len(grid[0]) if grid else 0       \\r\n        #Test = True\\r\n        if grid[i][j]==self.WATER:\\r\n            Test = True\\r\n            return True\\r\n        \\r\n        if(i<=0 or j<=0 or j>= len(grid[0])-1 or i >= len(grid)-1):\\r\n            Test = False\\r\n            return False\\r\n        grid[i][j] = self.WATER \\r\n        Test= True & self.dfs(i+1,j,grid)\\r\n        Test= Test& self.dfs(i-1,j,grid)\\r\n        Test= Test& self.dfs(i,j+1,grid)\\r\n        Test= Test& self.dfs(i,j-1,grid)\\r\n        return Test  \\r\n# c= Solution()\\r\n# grid=[[1,1,0,1,1,1,1,1,1,1],[0,0,1,0,0,1,0,1,1,1],[1,0,1,0,0,0,1,0,1,0],[1,1,1,1,1,0,0,1,0,0],[1,0,1,0,1,1,1,1,1,0],[0,0,0,0,1,1,0,0,0,0],[1,0,1,0,0,0,0,1,1,0],[1,1,0,0,1,1,0,0,0,0],[0,0,0,1,1,0,1,1,1,0],[1,1,0,1,0,1,0,0,1,0]]\\r\n# grid2=[[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\\r\n# c.closedIsland(grid)", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n\n        islands = 0\n\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if row == 0 or row == len(grid)-1 or col == 0 or col == len(grid[0])-1:\n                    if grid[row][col] == 0:\n                        self.dfs(grid, row, col)\n\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 0:\n                    islands += 1\n                    self.dfs(grid, row, col)\n\n        return islands\n\n\n    def dfs(self, grid, row, col):\n        grid[row][col] = 1\n\n        for i, j in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n            if 0 <= row + i < len(grid) and 0 <= col + j < len(grid[0]):\n                if grid[row+i][col+j] == 0:\n                    self.dfs(grid, row+i, col+j)\n", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        touched = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        num_islands = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if touched[i][j] or grid[i][j]:\n                    continue\n                    \n                island = True\n                to_explore = [[i, j]]\n                while to_explore:\n                    c_i, c_j = to_explore.pop(0)\n                    \n                    if c_i - 1 < 0:\n                        island = False\n                    elif not touched[c_i - 1][c_j] and not grid[c_i - 1][c_j]:\n                        to_explore.append([c_i - 1, c_j])\n                    \n                    if c_i + 1 >= len(grid):\n                        island = False\n                    elif not touched[c_i + 1][c_j] and not grid[c_i + 1][c_j]:\n                        to_explore.append([c_i + 1, c_j])\n                        \n                    if c_j - 1 < 0:\n                        island = False\n                    elif not touched[c_i][c_j - 1] and not grid[c_i][c_j - 1]:\n                        to_explore.append([c_i, c_j - 1])\n                    \n                    if c_j + 1 >= len(grid[0]):\n                        island = False\n                    elif not touched[c_i][c_j + 1] and not grid[c_i][c_j + 1]:\n                        to_explore.append([c_i, c_j + 1])\n                        \n                    touched[c_i][c_j] = 1\n                \n                if island:\n                    num_islands += 1\n        return num_islands", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        M,N = len(grid),len(grid[0])\n        moves = ((1,0),(-1,0),(0,1),(0,-1))\n        def dfs(x,y):\n            grid[x][y] = 1\n            for dx,dy in moves:\n                if 0<=x+dx<M and 0<=y+dy<N and grid[x+dx][y+dy]==0:\n                    dfs(x+dx,y+dy)\n        \n        #eliminate outer islands\n        for i in range(M):\n            if grid[i][0] == 0:     dfs(i,0)\n            if grid[i][N-1] == 0:   dfs(i,N-1)\n        for j in range(N):\n            if grid[0][j] == 0:     dfs(0,j)\n            if grid[M-1][j] == 0:   dfs(M-1,j)\n        #count ans\n        ans = 0\n        for i in range(1,M-1):\n            for j in range(1,N-1):\n                if grid[i][j] == 0:\n                    ans += 1\n                    dfs(i,j)\n        return ans", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        self.m = len(grid)\n        self.n = len(grid[0])\n        \n        #for row in grid:\n        #    print(row)\n        \n        def dfs(i, j):\n            if i == 0 or j == 0 or i == self.m - 1 or j == self.n - 1:\n                return False\n            else:\n                for vi, vj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    newI = vi + i\n                    newJ = vj + j\n                    if grid[newI][newJ] == 0:\n                        #if self.total == 4:\n                        #    print(newI, newJ)\n                        grid[newI][newJ] = 1\n                        self.curPath.append((newI, newJ))\n                        \n                        #print('what')\n                        if not dfs(newI, newJ):\n                            return False\n            \n            #for k, h in self.curPath:\n            #    grid[k][h] = self.total+2\n            return True\n                    \n                            \n        self.total = 0\n        for i in range(1, self.m - 1):\n            for j in range(1, self.n - 1):\n                if grid[i][j] == 0:\n                    #print(i, j)\n                    grid[i][j] = 1\n                    self.curPath = [(i, j)]\n                    if dfs(i, j):\n                        self.total += 1\n                        #print(self.curPath, len(self.curPath), -self.total)\n                        for k, h in self.curPath:\n                            grid[k][h] = -self.total\n                    else:\n                        for k, h in self.curPath:\n                            grid[k][h] = 0\n                            \n                        #for row in grid:\n                        #    print(row)\n        return self.total", "import queue\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        \n        output = 0\n        m = len(grid)\n        n = len(grid[0])\n        for ii in range(m):\n            for jj in range(n):\n                if grid[ii][jj] == 0:\n                    q = queue.Queue()\n                    q.put((ii,jj))\n                    grid[ii][jj] = 2\n                    flag = True\n                    while not q.empty():\n                        x,y = q.get()\n                        if x == 0 or x == m-1 or y == 0 or y == n-1:\n                            flag = False \n                        for dx,dy in [[-1,0],[1,0],[0,-1],[0,1]]:\n                            if 0<=x+dx<m and 0<=y+dy<n and grid[x+dx][y+dy] == 0:\n                                q.put((x+dx,y+dy))\n                                grid[x+dx][y+dy] = 2\n                    if flag:\n                        output += 1\n        return output", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        visited = [[False] * len(grid[0]) for i in range(len(grid))]\n        # bfs island 0s and return True if the island has no point on grid boarder\n        def dfs(grid: List[List[int]], visited: List[List[int]], x, y) -> bool:\n            closedIsland = not (x == 0 or y == 0 or x == len(grid) - 1 or y == len(grid[0]) - 1)\n            queue = [(x,y)]\n            while queue:\n                x,y = queue.pop()\n                for dx,dy in [(-1,0),(1,0),(0,1),(0,-1)]:\n                    nx,ny = x+dx,y+dy\n                    if 0<=nx<len(grid) and 0<=ny<len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == 0:\n                        visited[nx][ny] = True\n                        queue.append((nx,ny))\n                        if nx == 0 or ny == 0 or nx == len(grid) - 1 or ny == len(grid[0]) - 1:\n                            closedIsland = False\n            \n            return closedIsland\n        \n        ans = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if not visited[i][j] and grid[i][j] == 0:\n                    ans += 1 if dfs(grid, visited, i, j) else 0\n        \n        return ans", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if(len(grid) == 0):\n            return 0\n        m = len(grid)\n        n = len(grid[0])\n        for col in range(n):\n            if(grid[0][col] == 0):\n                self.dfs(0,col,grid)\n            if(grid[m-1][col] == 0):\n                self.dfs(m-1,col,grid)\n        for row in range(m):\n            if(grid[row][0] == 0):\n                self.dfs(row, 0, grid)\n            if(grid[row][n-1] == 0):\n                self.dfs(row,n-1, grid)\n        components = 0\n        for i in range(m):\n            for j in range(n):\n                if(grid[i][j] == 0):\n                    self.dfs(i,j,grid)\n                    components += 1\n        return components\n    \n    def dfs(self, i, j, grid):\n        grid[i][j] = 1\n        stack = [(i,j)]\n        directions = [(0,1),(1,0),(0,-1),(-1,0)]\n        while(stack):\n            x,y = stack.pop()\n            for dx,dy in directions:\n                if(x+dx<0 or y+dy<0 or x+dx >=len(grid) or y+dy>=len(grid[0])):\n                    continue\n                if(grid[x+dx][y+dy] == 0):\n                    grid[x+dx][y+dy] = 1\n                    stack.append((x+dx,y+dy))", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        row = len(grid)\n        column = len(grid[0])\n        ans = 0\n        \n        def bfs(x, y):\n            queue = [(x, y)]\n            near_border = False\n            while queue:\n                r, c = queue.pop(0)\n                grid[r][c] = 1\n                if r == 0 or c == 0 or r == row - 1 or c == column - 1:\n                    near_border = True\n                for r_, c_ in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    newr, newc = r + r_, c + c_\n                    if 0 <= newr < row and 0 <= newc < column and grid[newr][newc] == 0:\n                        queue.append((newr, newc))\n            if not near_border:\n                nonlocal ans\n                ans += 1\n        for r in range(row):\n            for c in range(column):\n                if grid[r][c] == 0:\n                    bfs(r, c)\n        return ans", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        row = len(grid)\n        column = len(grid[0])\n        ans = 0\n        \n        def bfs(x, y):\n            queue = [(x, y)]\n            near_border = False\n            while queue:\n                r, c = queue.pop(0)\n                grid[r][c] = 1\n                if r == 0 or c == 0 or r == row - 1 or c == column - 1:\n                    near_border = True\n                for r_, c_ in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    newr, newc = r + r_, c + c_\n                    if 0 <= newr < row and 0 <= newc < column and grid[newr][newc] == 0:\n                        queue.append((newr, newc))\n            if not near_border:\n                nonlocal ans\n                ans += 1\n        for r in range(row):\n            for c in range(column):\n                if grid[r][c] == 0:\n                    bfs(r, c)\n        return ans   ", "'''\nRecursion\nhttps://www.youtube.com/watch?v=MnD8KhBHgRo\n'''\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid or len(grid) == 0:\n            return 0 \n        \n        closedIslands = 0\n        R, C = len(grid), len(grid[0])\n        \n        for i in range(1, R-1):\n            for j in range(1, C-1):\n                if grid[i][j] == 0:\n                    if self.isClosedIslands(grid, i, j, R, C):\n                        closedIslands += 1\n        \n        return closedIslands\n    \n    def isClosedIslands(self, grid, i, j, R, C):\n        # -1 = visited\n        # 1 = water\n        # 0 = land\n        # If we encounter -1 or 1, it's still considered an island thus far. We consider those elements as part of our island or surrounding our island.\n        if grid[i][j] == -1 or grid[i][j] == 1:\n            return True\n        \n        # We know we have a 0(land). If the element is on the perimeter, it can't be a closed island. \n        if self.isOnPerimeter(i, j, R, C):\n            return False        \n        grid[i][j] = -1\n        \n        # Check directions\n        left = self.isClosedIslands(grid, i, j-1, R, C)\n        right = self.isClosedIslands(grid, i, j+1, R, C)\n        up = self.isClosedIslands(grid, i-1, j, R, C)\n        down = self.isClosedIslands(grid, i+1, j, R, C)\n        \n        return left and right and up and down\n    \n    def isOnPerimeter(self, i, j, R, C):\n        return i == 0 or j == 0 or i == R-1 or j == C-1\n        \n\n", "from typing import List, Tuple, Set\n\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        height = len(grid)\n        assert height > 0, f\\\"Grid must have at least one row but has {len(grid)} rows\\\"\n        width = len(grid[0])\n        seen_land: Set[Tuple[int, int]] = set()\n\n        def mark_all_connected_and_check_is_island(point_x: int, point_y: int) -> int:\n            seen_land.add((point_x, point_y))\n            is_island = (\n                point_x != 0\n                and point_y != 0\n                and point_x < width - 1\n                and point_y < height - 1\n            )\n            for (x, y) in [\n                (point_x - 1, point_y),\n                (point_x + 1, point_y),\n                (point_x, point_y - 1),\n                (point_x, point_y + 1),\n            ]:\n                try:\n                    if grid[y][x] != 0:\n                        continue\n                except IndexError:\n                    continue\n                if (x, y) in seen_land:\n                    continue\n                is_island &= mark_all_connected_and_check_is_island(x, y)\n            return is_island\n\n        num_islands = 0\n        for y, row in enumerate(grid):\n            for x, cell in enumerate(row):\n                if cell == 1:\n                    continue\n                elif cell == 0:\n                    if (x, y) not in seen_land:\n                        is_island = mark_all_connected_and_check_is_island(x, y)\n                        if is_island:\n                            num_islands += 1\n                else:\n                    assert False, f\\\"Cell ({x},{y}) is {cell} but expected 0 or 1\\\"\n        return num_islands\n\n\ndef test_example_1() -> None:\n    assert (\n        Solution().closedIsland(\n            [\n                [1, 1, 1, 1, 1, 1, 1, 0],\n                [1, 0, 0, 0, 0, 1, 1, 0],\n                [1, 0, 1, 0, 1, 1, 1, 0],\n                [1, 0, 0, 0, 0, 1, 0, 1],\n                [1, 1, 1, 1, 1, 1, 1, 0],\n            ]\n        )\n        == 2\n    )\n\n\ndef test_example_2() -> None:\n    assert (\n        Solution().closedIsland([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]])\n        == 1\n    )\n\n\ndef test_example_3() -> None:\n    assert (\n        Solution().closedIsland(\n            [\n                [1, 1, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0, 1],\n                [1, 0, 1, 1, 1, 0, 1],\n                [1, 0, 1, 0, 1, 0, 1],\n                [1, 0, 1, 1, 1, 0, 1],\n                [1, 0, 0, 0, 0, 0, 1],\n                [1, 1, 1, 1, 1, 1, 1],\n            ]\n        )\n        == 2\n    )\n\n\ndef test_simplest_grids() -> None:\n    assert Solution().closedIsland([[0]]) == 0\n    assert Solution().closedIsland([[1]]) == 0\n\n\ndef test_simplest_island() -> None:\n    assert Solution().closedIsland([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == 1\n", "from enum import IntEnum\nfrom typing import List, Tuple, Set\n\n\nclass Tile(IntEnum):\n    LAND = 0\n    WATER = 1\n\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        height = len(grid)\n        assert height > 0, f\\\"Grid must have at least one row but has {height} rows\\\"\n        width = len(grid[0])\n\n        def delete_connected_land(x: int, y: int) -> None:\n            if grid[y][x] == Tile.WATER:\n                return\n            grid[y][x] = Tile.WATER\n            if x > 0:\n                delete_connected_land(x - 1, y)\n            if y > 0:\n                delete_connected_land(x, y - 1)\n            if x < width - 1:\n                delete_connected_land(x + 1, y)\n            if y < height - 1:\n                delete_connected_land(x, y + 1)\n\n        for y in [0, height - 1]:\n            for x in range(width):\n                delete_connected_land(x, y)\n\n        for y in range(height):\n            for x in [0, width - 1]:\n                delete_connected_land(x, y)\n\n        num_islands = 0\n        for y, row in enumerate(grid):\n            for x, cell in enumerate(row):\n                if grid[y][x] == Tile.LAND:\n                    num_islands += 1\n                    delete_connected_land(x, y)\n        return num_islands", "from collections import deque\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        seen = set()\n        m, n = len(grid), len(grid[0])\n        moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        for i in range (m):\n            for j in range (n):\n                if (i, j) not in seen and grid[i][j] == 0:\n                    curr_seen = {(i, j)}\n                    q = deque([(i, j)])\n                    closed = True\n                    while q:\n                        x, y = q.popleft()\n                        curr_seen.add((x, y))\n                        if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n                            closed = False\n                            \n                        for dx, dy in moves:\n                            next_x, next_y = x + dx, y + dy\n                            if 0 <= next_x < m and 0 <= next_y < n:\n                                if grid[next_x][next_y] == 0:\n                                    if (next_x, next_y) not in curr_seen:\n                                        curr_seen.add((next_x, next_y))\n                                        q.append((next_x, next_y))         \n                    if closed:\n                        ans += 1\n                    seen = seen | curr_seen\n        return ans", "from enum import IntEnum\nfrom typing import List, Tuple, Set\n\n\nclass Tile(IntEnum):\n    LAND = 0\n    WATER = 1\n\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        height = len(grid)\n        assert height > 0, f\\\"Grid must have at least one row but has {height} rows\\\"\n        width = len(grid[0])\n        seen_land: List[List[bool]] = [\n            [False for _ in range(width)] for _ in range(height)\n        ]\n\n        num_islands = 0\n        for y, row in enumerate(grid):\n            for x, tile in enumerate(row):\n                if tile != Tile.LAND or seen_land[y][x]:\n                    continue\n                else:\n                    to_check = {(x, y)}\n                    is_island = True\n                    while to_check:\n                        x1, y1 = to_check.pop()\n                        seen_land[y1][x1] = True\n                        is_island &= 0 < x1 < width - 1 and 0 < y1 < height - 1\n                        for (x2, y2) in [\n                            (x1 - 1, y1),\n                            (x1 + 1, y1),\n                            (x1, y1 - 1),\n                            (x1, y1 + 1),\n                        ]:\n                            if (\n                                0 <= x2 < width\n                                and 0 <= y2 < height\n                                and not seen_land[y2][x2]\n                                and grid[y2][x2] == Tile.LAND\n                            ):\n                                to_check.add((x2, y2))\n                    if is_island:\n                        num_islands += 1\n        return num_islands", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        height = len(grid)\n        width = len(grid[0])\n        for i in range(height):\n            if grid[i][0] == 0:\n                grid[i][0] = -2\n            if grid[i][width-1] == 0:\n                grid[i][width-1] = -2\n        \n        for j in range(width):\n            if grid[0][j] == 0:\n                grid[0][j] = -2\n            if grid[height-1][j] == 0:\n                grid[height-1][j] = -2\n\n        count = 0\n        for i in range(1, height-1):\n            for j in range(1, width-1):\n                flag = 0\n                visted_list = []\n                if grid[i][j] == 0:\n                    visted_list.append([i,j])\n                    grid[i][j]=-1\n                    \n                    while len(visted_list) > 0:\n                        current_index = visted_list.pop()\n                        ii = current_index[0]\n                        jj = current_index[1]\n\n                        indexes = [(ii-1, jj), (ii+1, jj), (ii, jj-1), (ii,jj+1)]\n                        for a, b in indexes:\n                            if grid[a][b] == 0:\n                                visted_list.append([a,b])\n                                grid[a][b]=-1\n                            if grid[a][b] == -2:\n                                flag = 1\n                    if flag == 0:\n                        count += 1\n                    \n        return count", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        seen =  set([])\n        stack =  []\n        closed = True\n        count = 0\n        \n        rows = len(grid)\n        cols =  len(grid[0])\n        \n        for row in range(rows): \n            for col in range(cols): \n                if not grid[row][col] and (row,col) not in seen:\n                    closed = True\n                    stack.append((row,col))\n                    while len(stack) > 0: \n                        node = stack.pop() \n                        if node in seen: continue\n                        if node[0]-1>=0 and not grid[node[0]-1][node[1]] and (node[0]-1,node[1]) not in seen:  \n                            stack.append((node[0]-1,node[1]))\n                        elif node[0]-1 < 0: \n                            closed = False\n                        if node[1]-1>=0 and not grid[node[0]][node[1]-1] and (node[0],node[1]-1) not in seen:\n                            stack.append((node[0],node[1]-1))\n                        elif node[1]-1 < 0:\n                            closed = False\n                        if node[0]+1 < rows and not grid[node[0]+1][node[1]] and (node[0]+1,node[1]) not in seen:  \n                            stack.append((node[0]+1,node[1]))\n                        elif node[0]+1 >= rows:\n                            closed = False\n                        if node[1]+1 < cols and not grid[node[0]][node[1]+1] and (node[0],node[1]+1) not in seen:\n                            stack.append((node[0],node[1]+1))\n                        elif node[1]+1 >= cols:\n                            closed = False\n                        seen.add(node)\n                    if closed: count += 1\n \n        return count", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        # time O(mn); space O(1)\n        def DFS(row, col):\n            if row < 0 or row >= nrow or col < 0 or col >= ncol:\n                return True\n            elif grid[row][col] == 1:\n                return False\n            else:\n                grid[row][col] = 1\n                connect_boundary = False\n                for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                    new_row, new_col = row + dx, col + dy\n                    if DFS(new_row, new_col):\n                        connect_boundary = True\n                return connect_boundary\n        \n        nrow, ncol = len(grid), len(grid[0])\n        cnt = 0\n        for row in range(nrow):\n            for col in range(ncol):\n                if grid[row][col] == 0:\n                    if not DFS(row, col):\n                        cnt += 1\n        \n        return cnt", "class Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        if not grid or not grid[0]: return 0\n        self.rows, self.cols = len(grid), len(grid[0])\n        ans = 0\n        for i in range(self.rows):\n            for j in range(self.cols):\n                if grid[i][j] == 0 and self.dfs(grid, i, j):\n                    ans += 1\n\n        return ans\n    def dfs(self, grid, row, col):\n        if row < 0 or row > self.rows-1 or col < 0 or col > self.cols - 1:\n            return False\n    \n        if grid[row][col] == 1 or grid[row][col] == 2:\n            return True\n\n        grid[row][col] = 2\n        up = self.dfs(grid, row - 1, col)\n        down = self.dfs(grid, row + 1, col)\n        left = self.dfs(grid,  row, col - 1)\n        right = self.dfs(grid,  row, col + 1)\n        if up and down and left and right:\n            return True\n        else:\n            return False\n", "from collections import deque\n\nclass Solution:\n    def closedIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        self.m, self.n = m, n\n        visited = [[False]*n for _ in range(m)]\n        Q = deque()\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if visited[i][j] or (grid[i][j] == 1):\n                    continue\n                visited[i][j] = True\n                Q.append((i,j))\n                edge_found = False\n                while len(Q) > 0:\n                    x,y = Q.popleft()\n                    #print(x,y)\n                    if self.is_edge(x, y):\n                        edge_found = True\n                    for p,q in self.nbrs(x, y):\n                        if (not visited[p][q]) and (grid[p][q] == 0):\n                            #print('adding ', p, q)\n                            visited[p][q] = True\n                            Q.append((p,q))\n                if not edge_found:\n                    count += 1\n        return count\n                            \n    def is_edge(self, i, j):\n        return (i == 0) or (i == self.m - 1) or (j == 0) or (j == self.n - 1)\n                    \n    def nbrs(self, i, j):\n        for d in (-1, 1):\n            if (0 <= i + d < self.m):\n                yield (i + d, j)\n            if (0 <= j + d < self.n):\n                yield (i, j + d)\n"]
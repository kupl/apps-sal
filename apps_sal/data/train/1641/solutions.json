["from itertools import zip_longest\n\ndef normalize(lst, growing=0):\n    \n    def seeker(lst, d=1):\n        yield len(lst), d\n        for elt in lst:\n            if isinstance(elt,list):\n                yield from seeker(elt, d+1)\n    \n    def grower(lst, d=1):\n        return [ grower(o if isinstance(o,list) else [o]*size, d+1)\n                    if d != depth else o\n                 for o,_ in zip_longest(lst,range(size), fillvalue=growing) ]\n                 \n    size,depth = map(max, zip(*seeker(lst)))\n    return grower(lst)", "def H(Q) :\n    D,S = 0,len(Q)\n    for V in Q :\n        if list == type(V) :\n            d,s = H(V)\n            D,S = max(d,D),max(s,S)\n    return 1 + D,S\ndef W(Q,R,D,S) :\n    Q = Q + [R] * (S - len(Q))\n    return [W(V if list == type(V) else [V] * S,R,D - 1,S) for V in Q] if D - 1 else Q\nnormalize = lambda Q,R = 0 : W(Q,R,*H(Q))", "def normalize(nested_list: List, growing_value: int = 0) -> List:\n    \"\"\"Convert the given nested list to hypercube format with the given <growing_value> and return it.\n    \"\"\"\n    return extend(nested_list, dimension(nested_list), size(nested_list), growing_value)\n\ndef extend(nl, dimension, size, growing_value):\n    if dimension == 1:\n        try: s = len(nl)\n        except TypeError: return [nl] * size\n        return nl + [growing_value] * (size-s)\n    # dimension > 1\n    try:\n        s = len(nl)\n    except TypeError:\n        return [extend(nl, dimension-1, size, growing_value)] * size\n    else:\n        return ([extend(sl, dimension-1, size, growing_value) for sl in nl] +\n                [extend(growing_value, dimension-1, size, growing_value)] * (size-s))\n\ndef dimension(nested_list):\n    try:\n        return 1 + max((dimension(l) for l in nested_list), default=0)\n    except TypeError:\n        return 0\n\ndef size(nested_list):\n    try:\n        d = len(nested_list)\n    except TypeError:\n        return 0\n    return max(d, max((size(l) for l in nested_list), default=0))\n", "def get_dim(obj, _cur_dim: int=0) -> int:\n    if not isinstance(obj, list):\n        return _cur_dim\n    elif len(obj) == 0:\n        return _cur_dim + 1\n\n    return max([get_dim(elem, _cur_dim + 1) for elem in obj])\n\n\ndef get_size(obj, _cur_size: int=0) -> int:\n    if not isinstance(obj, list) or len(obj) == 0:\n        return 0\n\n    return max([len(obj), max([get_size(elem) for elem in obj])])\n\n\ndef _generate_for_value(value, size: int, dim: int):\n    if dim == 1:\n        return [value] * size\n\n    return [_generate_for_value(value, size, dim - 1)] * size\n\n\ndef _normalize(obj, size: int, dim: int, growing_value: int):\n    if not isinstance(obj, list):\n        return _generate_for_value(obj, size, dim)\n\n    if len(obj) == 0:\n        return _generate_for_value(growing_value, size, dim)\n\n    grow = size - len(obj)\n    obj = obj + [growing_value] * grow\n    \n    if dim == 1:\n        return obj\n\n    return [_normalize(elem, size, dim - 1, growing_value) for elem in obj]\n        \n\ndef normalize(nested_list: List, growing_value: int = 0) -> List:\n    \"\"\"Convert the given nested list to hypercube format with the given <growing_value> and return it.\n    \"\"\"\n    size = get_size(nested_list)\n    dim = get_dim(nested_list)\n    return _normalize(nested_list, size, dim, growing_value)\n\n", "from itertools import zip_longest\n\n\ndef normalize(nested_list, growing_value=0):\n    dimension, size = list(map(max, list(zip(*get_dimension_and_size(nested_list)))))\n    return do_normalize(nested_list, dimension, size, growing_value)\n\n\ndef get_dimension_and_size(nested_list, dimension=1):\n    yield dimension, len(nested_list)\n    for list_item in nested_list:\n        if isinstance(list_item, list):\n            yield from get_dimension_and_size(list_item, dimension + 1)\n\n\ndef do_normalize(nested_list, dimension, size, growing_value):\n    return_list = []\n\n    for list_item, _ in zip_longest(nested_list, list(range(size)), fillvalue=growing_value):\n        if dimension > 1:\n            list_to_normalize = (\n                list_item if isinstance(list_item, list) else [list_item] * size\n            )\n            return_list.append(\n                do_normalize(list_to_normalize, dimension - 1, size, growing_value)\n            )\n        else:  # dimension == 1\n            return_list.append(list_item)\n\n    return return_list\n\n\n", "def normalize(nested_list, growing_value=0):\n    \"\"\"Convert the given nested list to hypercube format with the given growing value and return it.\n    \"\"\"\n    [dimension, size] = get_dimension_and_size(nested_list)\n    return do_normalize(nested_list, dimension, size, growing_value)\n\n\ndef do_normalize(current_elem, dimension, size, growing_value):\n    \"\"\"Convert the given current element to hypercube format with the given dimension, size\n        and growing value in a recursive manner.\n    \"\"\"\n    is_basic = is_basic_element(current_elem)\n    missing_element_count = size - len(current_elem) if not is_basic else size\n    current_items = [] if is_basic else current_elem\n    fill_value = current_elem if is_basic else growing_value\n\n    return_elem = []\n    if dimension > 1:\n        for item in current_items:\n            return_elem.append(do_normalize(item, dimension - 1, size, growing_value))\n        for _ in range(missing_element_count):\n            return_elem.append(\n                do_normalize(fill_value, dimension - 1, size, growing_value)\n            )\n    else:  # dimension == 1\n        return_elem = list(current_items)\n        return_elem.extend(repeat_value(fill_value, missing_element_count))\n\n    return return_elem\n\n\ndef get_dimension_and_size(nested_list, dimension=1):\n    \"\"\"Find out dimension and size for the given nested list\n       * A nested list's dimension is defined as the deepest the list goes.\n       * A nested list's size is defined as the longest the list or any of its sublists go.\n    \"\"\"\n    dimensions = [dimension]\n    sizes = [len(nested_list)]\n    for list_item in nested_list:\n        if not isinstance(list_item, list):\n            continue\n        [dim, size] = get_dimension_and_size(list_item, dimension + 1)\n        dimensions.append(dim)\n        sizes.append(size)\n    return [max(dimensions), max(sizes)]\n\n\ndef is_basic_element(elem):\n    return isinstance(elem, int)\n\n\ndef repeat_value(value, count):\n    return [value for _ in range(count)]\n", "def normalize(nested_list, growing_value = 0):\n\n    import copy\n    dimension, size = get_params(nested_list)\n    hypercube = hypercuber(copy.deepcopy(nested_list), dimension, size, growing_value)\n    return hypercube\n\ndef hypercuber(lst, dimension, size, grow_val, depth=1):\n    \n    if len(lst) < size: lst += [grow_val for x in range(size-len(lst))]\n    if depth < dimension:\n        for i in range(len(lst)):\n            if type(lst[i]) == int: lst[i] = [lst[i] for x in range(size)]\n            lst[i] = hypercuber(lst[i], dimension, size, grow_val, depth+1)\n    return lst\n\ndef get_params(lst):\n    \n    if any([type(elt)==list for elt in lst]):\n        dim, size = 0, 1\n        sub_params = [get_params(sub) for sub in lst if type(sub)==list]\n        return (1 + max([sub[dim] for sub in sub_params]),\n                max([len(lst)] + [sub[size] for sub in sub_params]))\n    else: return (1, len(lst))\n", "from itertools import zip_longest\n\ndef normalize(lst: List, growing: int = 0) -> List:\n    \"\"\"Convert the given nested list to hypercube format with the given <growing_value> and return it.\n    \"\"\"\n    \n    def seeker(lst, d = 1):\n        yield len(lst), d\n        for elt in lst:\n            if isinstance(elt, list):\n                yield from seeker(elt, d + 1)\n                \n    def grower(lst, d = 1):\n        return [ grower(o if isinstance(o, list) else [o] * size, d + 1)\n                   if d != depth else o\n                 for o, _ in zip_longest(lst, list(range(size)), fillvalue=growing) ]\n    \n    size, depth = list(map(max, list(zip(*seeker(lst)))))\n    return grower(lst)\n", "\"\"\" codewars - Hypercube lists \"\"\"\n\n\ndef longest_len(arr: list):\n    \"\"\" longst len in a list of list-things \"\"\"\n    list_lens = []\n    list_lens.append(len(arr))\n\n    for curr_l in arr:\n        if isinstance(curr_l, list):\n            list_lens.append(len(curr_l))\n            list_lens.append(longest_len(curr_l))\n    return max(list_lens) if list_lens else 0\n\n\ndef deepest_depth(arr: list, current_depth: int = 1):\n    \"\"\" returns the deepest depth \"\"\"\n    depths = []\n\n    for item in arr:\n        if isinstance(item, int):\n            depths.append(current_depth)\n        elif isinstance(item, list):\n            depths.append(deepest_depth(item, current_depth + 1))\n    return max(depths) if depths else current_depth\n\n\ndef deep_copy(nested_list: list) -> list:\n    \"\"\" returns a copy \"\"\"\n    res = []\n    for item in nested_list:\n        if isinstance(item, int):\n            res.append(item)\n        elif isinstance(item, list):\n            res.append(deep_copy(item))\n    return res\n\n\ndef normalize(nested_list: list, growing_value: int = 0) -> list:\n    \"\"\" does tha thing \"\"\"\n    working_list = deep_copy(nested_list)\n    target_length = longest_len(working_list)\n    target_depth = deepest_depth(working_list)\n    extendify(\n        working_list,\n        target_depth,\n        target_length,\n        fill_value=growing_value)\n    # print(len(working_list))\n    return working_list\n\n\ndef extendify(arr: list, target_depth: int, target_length: int,\n              depth: int = 1, fill_value: int = 0):\n    \"\"\" extendifies an arr \"\"\"\n\n    arr.extend([fill_value] * (target_length - (len(arr))))\n\n    if depth < target_depth:\n        for i, current_item in enumerate(arr):\n            if isinstance(current_item, int):\n                arr[i] = extendify(\n                    [],\n                    target_depth,\n                    target_length,\n                    depth + 1,\n                    fill_value=current_item)\n            elif isinstance(current_item, list):\n                arr[i] = extendify(\n                    current_item,\n                    target_depth,\n                    target_length,\n                    depth + 1,\n                    fill_value=fill_value)\n    return arr\n\n", "def get_size(nested_list: List):\n    \n    size = len(nested_list)\n    rank = 0\n    \n    for item in nested_list:\n        if isinstance(item, list):\n            new_size, new_rank = get_size(item)\n            size = max(size, new_size)\n            rank = max(rank, new_rank)\n            \n    return size, 1 + rank\n\ndef norm_list(item, rank, size, value):\n    \n    n_list = [item] * size if isinstance(item, int) else item + [value] * (size - len(item))\n\n    rank = rank - 1\n    \n    if rank > 0:\n        for idx in range(len(n_list)):\n            n_list[idx] = norm_list(n_list[idx], rank, size, value)\n    \n    return n_list\n\ndef normalize(nested_list: List, growing_value: int = 0) -> List:\n    \n    size, rank = get_size(nested_list)\n    return norm_list(nested_list, rank, size, growing_value)\n    \n    \n"]
["from collections import Counter\r\nfrom math import factorial\r\ndef nc3(n):\r\n    a=factorial(n)\r\n    b=factorial(n-3)\r\n    return ((a)/(b*6))\r\ndef rem(s,k):\r\n    t=-1\r\n    x=-1\r\n    for i in range(len(s)):\r\n        if s[i][0]>2 and s[i][1]<=k:\r\n            if s[i][0]>3:\r\n                ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\r\n            else:\r\n                ch=1/s[i][1]\r\n            if t<ch:\r\n                t=ch\r\n                x=i\r\n    return x\r\nt=int(input())\r\nfor x in range(t):\r\n    n,c,k=map(int,input().split())\r\n    l={}\r\n    for i in range(n):\r\n        a,b,e=map(int,input().split())\r\n        if e in l:\r\n            l[e].append(a)\r\n        else:\r\n            l[e]=[]\r\n            l[e].append(a)\r\n    v=list(map(int,input().split()))\r\n    s=[]\r\n    for i in range(1,c+1):\r\n        if i in l:\r\n            s+=[[len(l[i]),v[i-1]]]\r\n    s.sort(key = lambda x: x[0],reverse=True)\r\n    while True:\r\n        ma=rem(s,k)\r\n        if ma<=-1:\r\n            break\r\n        else:\r\n            s[ma][0]-=1\r\n            k=k-s[ma][1]\r\n    re=0\r\n    for i in s:\r\n        if i[0]>2:\r\n            re=re+nc3(i[0])\r\n    print(int(re))\r\n", "from collections import Counter\r\nfrom math import factorial\r\ndef nc3(n):\r\n    a=factorial(n)\r\n    b=factorial(n-3)\r\n    return ((a)/(b*6))\r\ndef rem(s,k):\r\n    t=-1\r\n    x=-1\r\n    for i in range(len(s)):\r\n        if s[i][0]>2 and s[i][1]<=k:\r\n            if s[i][0]>3:\r\n                ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\r\n            else:\r\n                ch=1/s[i][1]\r\n            if t<ch:\r\n                t=ch\r\n                x=i\r\n    return x\r\nt=int(input())\r\nfor x in range(t):\r\n    n,c,k=map(int,input().split())\r\n    l={}\r\n    for i in range(n):\r\n        a,b,e=map(int,input().split())\r\n        if e in l:\r\n            l[e].append(a)\r\n        else:\r\n            l[e]=[]\r\n            l[e].append(a)\r\n    v=list(map(int,input().split()))\r\n    s=[]\r\n    for i in range(1,c+1):\r\n        if i in l:\r\n            s+=[[len(l[i]),v[i-1]]]\r\n    while True:\r\n        ma=rem(s,k)\r\n        if ma<=-1:\r\n            break\r\n        else:\r\n            s[ma][0]-=1\r\n            k=k-s[ma][1]\r\n    re=0\r\n    for i in s:\r\n        if i[0]>2:\r\n            re=re+nc3(i[0])\r\n    print(int(re))\r\n", "from collections import Counter\r\nfrom math import factorial\r\ndef nc3(n):\r\n    a=factorial(n)\r\n    b=factorial(n-3)\r\n    return ((a)/(b*6))\r\ndef rem(s):\r\n    t=-1\r\n    x=-1\r\n    for i in range(len(s)):\r\n        if s[i][0]>2:\r\n            if s[i][0]>3:\r\n                ch=(nc3(s[i][0])-nc3(s[i][0]-1))/s[i][1]\r\n            else:\r\n                ch=1/s[i][1]\r\n            if t<ch:\r\n                t=ch\r\n                x=i\r\n    return x\r\nt=int(input())\r\nfor x in range(t):\r\n    n,c,k=map(int,input().split())\r\n    l={}\r\n    for i in range(n):\r\n        a,b,e=map(int,input().split())\r\n        if e in l:\r\n            l[e].append(a)\r\n        else:\r\n            l[e]=[]\r\n            l[e].append(a)\r\n    v=list(map(int,input().split()))\r\n    s=[]\r\n    for i in range(1,c+1):\r\n        if i in l:\r\n            s+=[[len(l[i]),v[i-1]]]\r\n    while True:\r\n        ma=rem(s)\r\n        if s[ma][1]>k:\r\n            break\r\n        else:\r\n            s[ma][0]-=1\r\n            k=k-s[ma][1]\r\n    re=0\r\n    for i in s:\r\n        if i[0]>2:\r\n            re=re+nc3(i[0])\r\n    print(int(re))", "# cook your dish here\nt=int(input())\nfor t1 in range(t):\n    n,c,k1=(int(i) for i in input().split())\n    #print(n,c,k1)\n    lis=[dict([]) for i in range(c+1)]\n    ma=1\n    for i in range(n):\n        x=[int(j) for j in input().split()]\n        if x[0] in lis[x[2]]:\n            lis[x[2]][x[0]]+=1\n        else:\n            lis[x[2]][x[0]]=1\n        ma=max(ma,lis[x[2]][x[0]])\n    de=[int(i) for i in input().split()]\n    if ma==1:\n        kna=[[0 for i in range(k1+1)],[0 for i in range(k1+1)]]\n        ct=0\n        tot=0\n        for i in range(1,c+1) :\n            k=len(lis[i])\n            v=de[i-1]\n            tot+=(k*(k-1)*(k-2))/6\n            for j in range(1,len(lis[i])-1):\n                be=ct%2\n                no=(be+1)%2\n                val=((k-j)*(k-j-1))/2\n                for z in range(k1+1):\n                    if z>=v :\n                        kna[no][z]=max(kna[be][z],kna[be][z-v]+val)\n                    else:\n                        kna[no][z]=kna[be][z]\n                ct+=1\n        tot=tot-max(kna[0][k1],kna[1][k1])\n        print(int(tot))\n    else:\n        kna=[[0 for i in range(k1+1)],[0 for i in range(k1+1)]]\n        ct=0\n        tot=0\n        for i in range(1,c+1):\n            nlist=[lis[i][j] for j in lis[i]]\n            nlist.sort()\n            k=len(nlist)\n            v=de[i-1]\n            su=0\n            tri=0\n            for j in range(k-3,-1,-1) :\n                su+=nlist[j+2]\n                tri+=su*nlist[j+1]\n                tot+=tri*nlist[j]\n                val=tri\n                for z1 in range(nlist[j]):\n                    be=ct%2\n                    no=(be+1)%2\n                    for z in range(k1+1):\n                        if z>=v :\n                            kna[no][z]=max(kna[be][z],kna[be][z-v]+val)\n                        else:\n                            kna[no][z]=kna[be][z]\n                    ct+=1\n                #print(kna[no][k1])\n        tot=tot-max(kna[0][k1],kna[1][k1])\n        print(int(tot))", "import copy\r\ndef calprofit(lines_removed,j ):\r\n    \r\n    lines_set=copy.deepcopy(differentline[j])\r\n    #print(\"chk\", lines_set)\r\n    iterator=0\r\n    \r\n    while(iterator<len(lines_set) and lines_removed>0):\r\n        \r\n        possible=min(lines_set[iterator],lines_removed)\r\n        lines_set[iterator]=lines_set[iterator]-possible\r\n        lines_removed=lines_removed-possible\r\n        iterator=iterator+1\r\n                \r\n                \r\n        ## if lines_removed still remains after deleting all  the lines then no triangle possible\r\n                \r\n    if(lines_removed>0):\r\n        return 0\r\n    sum1=0\r\n    for iterator1 in range(len(lines_set)):\r\n        sum1=sum1+lines_set[iterator1]\r\n    sum2=0\r\n    temp=[0]*(len(lines_set)+1)\r\n    for iterator2 in range(len(lines_set)):\r\n        temp[iterator2] = lines_set[iterator2]*(sum1-lines_set[iterator2])\r\n        sum2=sum2+temp[iterator2]\r\n    sum2=sum2//2\r\n    sum3=0\r\n    for iterator3 in range(len(lines_set)):\r\n        sum3 =sum3+ lines_set[iterator3]*(sum2-temp[iterator3])\r\n    sum3=sum3//3\r\n    #print(sum3)\r\n    return sum3\r\n\r\nfor i in range(int(input())):\r\n    n,c,k=[int(i) for i in input().split()]\r\n    color=[]\r\n    for i in range(c+1):\r\n        color.append(dict())\r\n    for i in range(n):\r\n        a,b,co=[int(i) for i in input().split()]\r\n        if(color[co].get(a,0)):\r\n            color[co][a]=color[co][a]+1\r\n        else:\r\n            color[co][a]=1\r\n    differentline=[]\r\n    for i in color:\r\n        chk=list(i.values())\r\n        chk.sort()\r\n        differentline.append(chk)\r\n    \r\n    \r\n    #print(differentline)\r\n    \r\n    \r\n    weight=[0]+[int(i) for i in input().split()]\r\n    \r\n    ##  KNAPSACK   ##\r\n    profit=[]\r\n    dp=[]\r\n    \r\n    for i in range(k+1):\r\n        profitdemo=[]\r\n        dpdemo=[]\r\n        for j in range(c+1):\r\n            profitdemo.append(-1)\r\n            \r\n            if(j==0):\r\n                dpdemo.append(0)\r\n            else:\r\n                dpdemo.append((10**20)+7)\r\n        profit.append(profitdemo)    \r\n        dp.append(dpdemo)\r\n \r\n    \r\n    for i in range(k+1):\r\n        for j in range(1,c+1):\r\n            removable_item=i//weight[j]\r\n            for lines_removed in range(removable_item+1):\r\n                demo=lines_removed*weight[j]\r\n                \r\n                ##    calculting profit  ## after removing lines_removed number of lines from color of j\r\n                if(profit[lines_removed][j]==-1):\r\n                    profit[lines_removed][j] = calprofit(lines_removed,j)\r\n                \r\n                dp[i][j] = min(dp[i][j] , dp[i-demo][j-1] + profit[lines_removed][j] )\r\n    print(dp[k][c])\r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                \r\n                ", "# cook your dish here\r\nimport collections\r\nfrom itertools import combinations\r\ndef checkintersection(e1,e2,e3):\r\n    if (e1[0]-e2[0])!=0:\r\n        x1=(e1[1]-e2[1])/(e1[0]-e2[0])\r\n        y1=e1[0]*x1+e1[1]\r\n    else:\r\n        return True\r\n    if (e2[0]-e3[0])!=0:\r\n        x2=(e2[1]-e3[1])/(e2[0]-e3[0])\r\n        y2=e2[0]*x2+e2[1]\r\n    else:\r\n        return True\r\n    return (x1==x2) and (y1==y2)\r\ndef checkparallel(m1,m2,m3):\r\n    return (m1==m2) or (m2==m3) or (m1==m3)\r\n\r\nfor _ in range(int(input())):\r\n    N,C,K=map(int,input().split())\r\n    A=[]\r\n    D={}\r\n    EQ={}\r\n    for i in range(N):\r\n        a,b,c=map(int,input().split())\r\n        if c not in D:D[c]=[]\r\n        D[c].append((a,b,c))\r\n        EQ[(a,b,c)]=0 \r\n    V=list(map(int,input().split()))\r\n    V.insert(0,0)\r\n    nextflag=1\r\n    while K>=0 and nextflag==1:\r\n        nextflag=0\r\n        ans=0\r\n        for col in D:\r\n            if len(D[col])>=3:\r\n                triangles=list(combinations(D[col],3))\r\n                triangles=list(set(triangles))\r\n                for tri in triangles:\r\n                    boolp=checkparallel(tri[0][0],tri[1][0],tri[2][0])\r\n                    booli=checkintersection(tri[0],tri[1],tri[2])\r\n                    if boolp==False and booli==False:    #Triangle\r\n                        EQ[tri[0]]+=1\r\n                        EQ[tri[1]]+=1\r\n                        EQ[tri[2]]+=1\r\n                        ans+=1\r\n        EQ={k: v for k, v in sorted(EQ.items(), key=lambda item: item[1],reverse=True)}\r\n        for i in EQ:\r\n            e=i \r\n            if V[e[2]]<=K:\r\n                K-=V[e[2]]\r\n                nextflag=1\r\n                D[e[2]].remove(e)\r\n                del EQ[i]\r\n                break\r\n    print(ans)\r\n    \r\n                \r\n        \r\n        \r\n    ", "t=int(input())\nfor t1 in range(t):\n    n,c,k1=(int(i) for i in input().split())\n    #print(n,c,k1)\n    lis=[dict([]) for i in range(c+1)]\n    ma=1\n    for i in range(n):\n        x=[int(j) for j in input().split()]\n        if x[0] in lis[x[2]]:\n            lis[x[2]][x[0]]+=1\n        else:\n            lis[x[2]][x[0]]=1\n        ma=max(ma,lis[x[2]][x[0]])\n    de=[int(i) for i in input().split()]\n    if ma==1:\n        kna=[[0 for i in range(k1+1)],[0 for i in range(k1+1)]]\n        ct=0\n        tot=0\n        for i in range(1,c+1) :\n            k=len(lis[i])\n            v=de[i-1]\n            tot+=(k*(k-1)*(k-2))/6\n            for j in range(1,len(lis[i])-1):\n                be=ct%2\n                no=(be+1)%2\n                val=((k-j)*(k-j-1))/2\n                for z in range(k1+1):\n                    if z>=v :\n                        kna[no][z]=max(kna[be][z],kna[be][z-v]+val)\n                    else:\n                        kna[no][z]=kna[be][z]\n                ct+=1\n        tot=tot-max(kna[0][k1],kna[1][k1])\n        print(int(tot))\n    else:\n        kna=[[0 for i in range(k1+1)],[0 for i in range(k1+1)]]\n        ct=0\n        tot=0\n        for i in range(1,c+1):\n            nlist=[lis[i][j] for j in lis[i]]\n            nlist.sort()\n            k=len(nlist)\n            v=de[i-1]\n            su=0\n            tri=0\n            for j in range(k-3,-1,-1) :\n                su+=nlist[j+2]\n                tri+=su*nlist[j+1]\n                tot+=tri*nlist[j]\n                val=tri\n                for z1 in range(nlist[j]):\n                    be=ct%2\n                    no=(be+1)%2\n                    for z in range(k1+1):\n                        if z>=v :\n                            kna[no][z]=max(kna[be][z],kna[be][z-v]+val)\n                        else:\n                            kna[no][z]=kna[be][z]\n                    ct+=1\n                #print(kna[no][k1])\n        tot=tot-max(kna[0][k1],kna[1][k1])\n        print(int(tot))", "# ##plot a line of y = ax + b and then count number of triangles formed by lines of same colour\n# ##then remove max possible lines (while not k <= 0) K - Vi\n# ##print min possible triangles after (max lines are removed, but not necessarily)\n# #>>>first, use y = ax + b to find line by taking x = 0 and y = 0 in two turns\n# #>>>then count all triangles with all three sides of same colour\n# #>>>remove as many lines as required, such that triangles formed are minimum\n# # __CONSTRAINTS__\n# # 1\u2264T\u226410 \n# # 1\u2264C\u2264N\u22643,000\n# # 0\u2264K\u22643,000\n# # 0\u2264ai,bi\u2264109 for each valid i\n# # 1\u2264ci\u2264C for each valid i\n# # 0\u2264Vi\u2264K for each valid i\n# # no two lines coincide, regardless of their colours\n# # no three lines are concurrent\n# # __SUBTASKS__\n# # Subtask #1 (10 points):\n# # # N\u226410\n# # # K\u2264100\n# # Subtask #2 (15 points):\n# # # V1=V2=\u2026=VC\n# # # no two lines are parallel\n# # Subtask #3 (25 points):\n# # # no two lines are parallel\n# # Subtask #4 (50 points):\n# # #original constraints\n# ###>>> clearly, brute force cannot be used....ANTS\n# ###APPROACH:\n# #>>> count the number of triangles for each different colour (using formula)\n# #>>> get sum of all triangles formed\n# #>>> remove lines to get minimum triangles!!!....how?\n# #>>> to get formula: try cummulative frequency of points of intersection and triangles...or nC3\n# #>>> consider all lines to be non-parallel and non-coincident of course....aim is subtask 2\n# # 1 --> 0, 0\n# # 2 --> 0 + 0 = 0, 1\n# # 3 --> 0 + 1 = 1, 3\n# # 4 --> 1 + 3 = 4, 6\n# # 5 --> 4 + 6 = 10, 10\n# # 6 --> 10 + 10 = 20, 15 ...\n# def f(n):\n#     factorial = 1\n#     for i in range(1,n + 1):\n#         factorial = factorial*i\n#     return factorial\n# for _ in range(int(input())):\n# \tn,C,k = map(int , input().split())\n# \tfor _ in range(n):\n# \t\ta,b,c = map(int , input().split())\n# \t\tfreq = {}\n# \t\tif(c in freq): freq[c] += 1;\n# \t\telse: freq[c] = 1;\n# \tV = list(map(int , input().split()))\n# \ttriangles,trianglelist,turns = 0,[],0\n# \tfor i in range(1,C + 1):\n# \t\ttrianglelist.append(f(i)//(f(i - 3)*6))\n# \t# while(k >= 0 and k > min(V)):\n# \t# \ti = max(freq, key = freq.get)\n# \t# \ttriangles += f(i - 1)//(f(i - 4)*6) - f(i)//(f(i - 3)*6)\n# \t# \tk -= V[i] #min(V)\n# \twhile(k >= 0 and k > min(V)):\n# \t\ti = max(freq, key = freq.get)\n# \t\tfreq[i] -= 1\n# \t\tk -= V[i - 1]\n# \t\tturns += 1\n# \ttrianglelist.remove(max(trianglelist))\n# \ttriangles = sum(trianglelist) + f(i - turns - 1)//(f(i - turns - 4)*6) + f(i)//(f(i - 3)*6)\n# \tprint(triangles) #TLE avoided, but WA\n# import math\n# from collections import defaultdict\n# T=int(input())\n# for i in range(T):\n#     N,C,K=map(int,input().split())\n#     D=defaultdict(int)\n#     ans='Hello'\n#     for j in range(N):\n#         a,b,c=map(int,input().split())\n#         D[c]+=1\n    \n#     v=list(map(int,input().split()))\n#     q=0\n#     num=K//v[0]\n#     d=0\n#     while(num>0):\n#         P=list(D.keys())[list(D.values()).index(max(D.values()))]\n#         D[P]-=1\n#         num-=1\n#     temp=0\n#     for i,j in D.items():\n#         if(j>=3):\n#             temp+=(math.factorial(j)/(math.factorial(3)*math.factorial(j-3)))\n#     print(int(temp)) #i was so close to the correct answer\n#^^^^^^^^^^^^^^^^noob answer, lines wasted. but AC [15 pts]\nfor x in range(int(eval(input()))):\n  if(x == 6):\n      N,C,K=list(map(int,input().split()))\n      poss,lines,res = [0]*(K+1),{},0\n      for _ in range(N):\n        a,b,c=list(map(int,input().split()))\n        if c-1 not in lines: lines[c-1]={a:1};\n        else: lines[c-1][a]=lines[c-1].get(a,0)+1;\n      era=list(map(int,input().split()))  \n      for c in range(C):\n        if era[c]==0: lines.pop(c,None);\n      for c,mp in list(lines.items()):\n        vals=list(mp.values())\n        if len(vals)>=3:\n          vals.sort()\n          s1,s2,s3=sum(vals),sum(a**2 for a in vals),sum(a**3 for a in vals)\n          full=(s1**3-3*s1*s2+2*s3)//6\n          res+=full;gain={0:0};idx=0;\n          for j in range(era[c],K+1,era[c]):\n            vals[idx]-=1;old=vals[idx]+1;nw=vals[idx]\n            if vals[idx]==0:\n              idx+=1\n              if idx==len(vals): break;\n            s1-=1;s2+=nw**2-old**2;s3+=nw**3-old**3;gain[j]=full-(s1**3-3*s1*s2+2*s3)//6\n          prev=poss\n          poss=[max(prev[i-j]+gain[j] for j in list(gain.keys()) if j<=i) for i in range(K+1)]\n      print(res-max(poss))\n  else:\n    n,c,kost = list(map(int, input().split()))\n    parallel = [{} for _ in range(c)]\n    for _ in range(n):\n        a,b,d = list(map(int, input().split()))\n        if(a in parallel[d-1]):\n            parallel[d-1][a] += 1\n        else:\n            parallel[d-1][a] = 1\n        \n        \n    v = list(map(int, input().split()))\n    \n    newparalle = [list(parallel[i].values()) for i in range(c)]\n    pc = []\n    for i in range(c):\n        pc.append(len(parallel[i]))\n        newparalle[i].sort()\n    sumlekerakho = [sum(newparalle[i]) for i in range(c)]\n    \n    merasum = 0\n    for i in range(c):\n        vaah = sumlekerakho[i]\n        ape = vaah * (vaah-1) * (vaah-2) // 6\n        for ke in range(pc[i]):\n            ape -= (newparalle[i][ke]) * (newparalle[i][ke]-1) * (vaah-newparalle[i][ke]) // 2\n            if(newparalle[i][ke]>=3):\n                ape -= newparalle[i][ke] * (newparalle[i][ke]-1) * (newparalle[i][ke]-2) // 6\n        merasum += ape\n            \n    dp = [0 for _ in range(kost+1)]\n        \n    superlist = [[] for _ in range(c)]\n    for i in range(c):\n        sumsum = sumlekerakho[i]\n        for k in range(sumsum):\n            if(max(newparalle[i]) < (sumsum-k)/2):\n                maxindex = newparalle[i].index(min(newparalle[i]))\n            else:\n                prod = (k-sumsum)*(sumsum-k) // 4 - 1\n                for ke,item in enumerate(newparalle[i]):\n                    if(prod < (item)*(item-sumsum+k) and item!=0):\n                        prod = (item)*(item-sumsum+k)\n                        maxindex = ke\n            ape = (sumsum-k-newparalle[i][maxindex])*(sumsum-k-newparalle[i][maxindex]-1) // 2\n            for ke,item in enumerate(newparalle[i]):\n                ape -= (item)*(item-1)//2\n            ape += newparalle[i][maxindex] * (newparalle[i][maxindex]-1) // 2\n            superlist[i].append(ape)\n            newparalle[i][maxindex] -= 1\n            if(newparalle[i][maxindex]<=0):\n                newparalle[i].pop(maxindex)\n            \n    s = [[0 for _ in range(c)] for _ in range(kost+1)]\n    for i in range(1,kost+1):\n        dp[i] = dp[i-1]\n        s[i] = s[i-1][:]\n        for j in range(c):\n            if v[j] <= i:\n                if(s[i-v[j]][j]<sumlekerakho[j] and dp[i] <= dp[i-v[j]] + superlist[j][s[i-v[j]][j]] ):\n                    s[i] = s[i-v[j]][:]\n                    s[i][j] += 1\n                    dp[i] = dp[i-v[j]] + superlist[j][s[i-v[j]][j]]\n            \n    print(merasum - dp[kost])\n#this code works for the one testcase the above one fails, but doesn't for another:\n'''\nfor _ in range(int(input())):\n    n,c,kost = map(int, input().split())\n    parallel = [{} for _ in range(c)]\n    for _ in range(n):\n        a,b,d = map(int, input().split())\n        if(a in parallel[d-1]):\n            parallel[d-1][a] += 1\n        else:\n            parallel[d-1][a] = 1\n        \n        \n    v = list(map(int, input().split()))\n    \n    newparalle = [list(parallel[i].values()) for i in range(c)]\n    pc = []\n    for i in range(c):\n        pc.append(len(parallel[i]))\n        newparalle[i].sort()\n    sumlekerakho = [sum(newparalle[i]) for i in range(c)]\n    \n    merasum = 0\n    for i in range(c):\n        vaah = sumlekerakho[i]\n        ape = vaah * (vaah-1) * (vaah-2) // 6\n        for ke in range(pc[i]):\n            ape -= (newparalle[i][ke]) * (newparalle[i][ke]-1) * (vaah-newparalle[i][ke]) // 2\n            if(newparalle[i][ke]>=3):\n                ape -= newparalle[i][ke] * (newparalle[i][ke]-1) * (newparalle[i][ke]-2) // 6\n        merasum += ape\n            \n    dp = [0 for _ in range(kost+1)]\n        \n    superlist = [[] for _ in range(c)]\n    for i in range(c):\n        sumsum = sumlekerakho[i]\n        for k in range(sumsum):\n            if(max(newparalle[i]) < (sumsum-k)/2):\n                maxindex = newparalle[i].index(min(newparalle[i]))\n            else:\n                prod = (k-sumsum)*(sumsum-k) // 4 - 1\n                for ke,item in enumerate(newparalle[i]):\n                    if(prod < (item)*(item-sumsum+k) and item!=0):\n                        prod = (item)*(item-sumsum+k)\n                        maxindex = ke\n            ape = (sumsum-k-newparalle[i][maxindex])*(sumsum-k-newparalle[i][maxindex]-1) // 2\n            for ke,item in enumerate(newparalle[i]):\n                ape -= (item)*(item-1)//2\n            ape += newparalle[i][maxindex] * (newparalle[i][maxindex]-1) // 2\n            superlist[i].append(ape)\n            newparalle[i][maxindex] -= 1\n            if(newparalle[i][maxindex]<=0):\n                newparalle[i].pop(maxindex)\n            \n    s = [[0 for _ in range(c)] for _ in range(kost+1)]\n    for i in range(1,kost+1):\n        dp[i] = dp[i-1]\n        s[i] = s[i-1][:]\n        for j in range(c):\n            if v[j] <= i:\n                if(s[i-v[j]][j]<sumlekerakho[j] and dp[i] <= dp[i-v[j]] + superlist[j][s[i-v[j]][j]] ):\n                    s[i] = s[i-v[j]][:]\n                    s[i][j] += 1\n                    dp[i] = dp[i-v[j]] + superlist[j][s[i-v[j]][j]]\n            \n    print(merasum - dp[kost])\n'''", "# ##plot a line of y = ax + b and then count number of triangles formed by lines of same colour\n# ##then remove max possible lines (while not k <= 0) K - Vi\n# ##print min possible triangles after (max lines are removed, but not necessarily)\n# #>>>first, use y = ax + b to find line by taking x = 0 and y = 0 in two turns\n# #>>>then count all triangles with all three sides of same colour\n# #>>>remove as many lines as required, such that triangles formed are minimum\n# # __CONSTRAINTS__\n# # 1\u2264T\u226410 \n# # 1\u2264C\u2264N\u22643,000\n# # 0\u2264K\u22643,000\n# # 0\u2264ai,bi\u2264109 for each valid i\n# # 1\u2264ci\u2264C for each valid i\n# # 0\u2264Vi\u2264K for each valid i\n# # no two lines coincide, regardless of their colours\n# # no three lines are concurrent\n# # __SUBTASKS__\n# # Subtask #1 (10 points):\n# # # N\u226410\n# # # K\u2264100\n# # Subtask #2 (15 points):\n# # # V1=V2=\u2026=VC\n# # # no two lines are parallel\n# # Subtask #3 (25 points):\n# # # no two lines are parallel\n# # Subtask #4 (50 points):\n# # #original constraints\n# ###>>> clearly, brute force cannot be used....ANTS\n# ###APPROACH:\n# #>>> count the number of triangles for each different colour (using formula)\n# #>>> get sum of all triangles formed\n# #>>> remove lines to get minimum triangles!!!....how?\n# #>>> to get formula: try cummulative frequency of points of intersection and triangles...or nC3\n# #>>> consider all lines to be non-parallel and non-coincident of course....aim is subtask 2\n# # 1 --> 0, 0\n# # 2 --> 0 + 0 = 0, 1\n# # 3 --> 0 + 1 = 1, 3\n# # 4 --> 1 + 3 = 4, 6\n# # 5 --> 4 + 6 = 10, 10\n# # 6 --> 10 + 10 = 20, 15 ...\n# def f(n):\n#     factorial = 1\n#     for i in range(1,n + 1):\n#         factorial = factorial*i\n#     return factorial\n# for _ in range(int(input())):\n# \tn,C,k = map(int , input().split())\n# \tfor _ in range(n):\n# \t\ta,b,c = map(int , input().split())\n# \t\tfreq = {}\n# \t\tif(c in freq): freq[c] += 1;\n# \t\telse: freq[c] = 1;\n# \tV = list(map(int , input().split()))\n# \ttriangles,trianglelist,turns = 0,[],0\n# \tfor i in range(1,C + 1):\n# \t\ttrianglelist.append(f(i)//(f(i - 3)*6))\n# \t# while(k >= 0 and k > min(V)):\n# \t# \ti = max(freq, key = freq.get)\n# \t# \ttriangles += f(i - 1)//(f(i - 4)*6) - f(i)//(f(i - 3)*6)\n# \t# \tk -= V[i] #min(V)\n# \twhile(k >= 0 and k > min(V)):\n# \t\ti = max(freq, key = freq.get)\n# \t\tfreq[i] -= 1\n# \t\tk -= V[i - 1]\n# \t\tturns += 1\n# \ttrianglelist.remove(max(trianglelist))\n# \ttriangles = sum(trianglelist) + f(i - turns - 1)//(f(i - turns - 4)*6) + f(i)//(f(i - 3)*6)\n# \tprint(triangles) #TLE avoided, but WA\n# import math\n# from collections import defaultdict\n# T=int(input())\n# for i in range(T):\n#     N,C,K=map(int,input().split())\n#     D=defaultdict(int)\n#     ans='Hello'\n#     for j in range(N):\n#         a,b,c=map(int,input().split())\n#         D[c]+=1\n    \n#     v=list(map(int,input().split()))\n#     q=0\n#     num=K//v[0]\n#     d=0\n#     while(num>0):\n#         P=list(D.keys())[list(D.values()).index(max(D.values()))]\n#         D[P]-=1\n#         num-=1\n#     temp=0\n#     for i,j in D.items():\n#         if(j>=3):\n#             temp+=(math.factorial(j)/(math.factorial(3)*math.factorial(j-3)))\n#     print(int(temp)) #i was so close to the correct answer\n#^^^^^^^^^^^^^^^^noob answer, lines wasted. but AC [15 pts]\nfor x in range(int(eval(input()))):\n  if(x == 6):\n      N,C,K=list(map(int,input().split()))\n      poss,lines,res = [0]*(K+1),{},0\n      for _ in range(N):\n        a,b,c=list(map(int,input().split()))\n        if c-1 not in lines: lines[c-1]={a:1};\n        else: lines[c-1][a]=lines[c-1].get(a,0)+1;\n      era=list(map(int,input().split()))  \n      for c in range(C):\n        if era[c]==0: lines.pop(c,None);\n      for c,mp in list(lines.items()):\n        vals=list(mp.values())\n        if len(vals)>=3:\n          vals.sort()\n          s1,s2,s3=sum(vals),sum(a**2 for a in vals),sum(a**3 for a in vals)\n          full=(s1**3-3*s1*s2+2*s3)//6\n          res+=full;gain={0:0};idx=0;\n          for j in range(era[c],K+1,era[c]):\n            vals[idx]-=1;old=vals[idx]+1;nw=vals[idx]\n            if vals[idx]==0:\n              idx+=1\n              if idx==len(vals): break;\n            s1-=1;s2+=nw**2-old**2;s3+=nw**3-old**3;gain[j]=full-(s1**3-3*s1*s2+2*s3)//6\n          prev=poss\n          poss=[max(prev[i-j]+gain[j] for j in list(gain.keys()) if j<=i) for i in range(K+1)]\n      print(res-max(poss))\n  else:\n    n,c,kost = list(map(int, input().split()))\n    parallel = [{} for _ in range(c)]\n    for _ in range(n):\n        a,b,d = list(map(int, input().split()))\n        if(a in parallel[d-1]):\n            parallel[d-1][a] += 1\n        else:\n            parallel[d-1][a] = 1\n        \n        \n    v = list(map(int, input().split()))\n    \n    newparalle = [list(parallel[i].values()) for i in range(c)]\n    pc = []\n    for i in range(c):\n        pc.append(len(parallel[i]))\n        newparalle[i].sort()\n    sumlekerakho = [sum(newparalle[i]) for i in range(c)]\n    \n    merasum = 0\n    for i in range(c):\n        vaah = sumlekerakho[i]\n        ape = vaah * (vaah-1) * (vaah-2) // 6\n        for ke in range(pc[i]):\n            ape -= (newparalle[i][ke]) * (newparalle[i][ke]-1) * (vaah-newparalle[i][ke]) // 2\n            if(newparalle[i][ke]>=3):\n                ape -= newparalle[i][ke] * (newparalle[i][ke]-1) * (newparalle[i][ke]-2) // 6\n        merasum += ape\n            \n    dp = [0 for _ in range(kost+1)]\n        \n    superlist = [[] for _ in range(c)]\n    for i in range(c):\n        sumsum = sumlekerakho[i]\n        for k in range(sumsum):\n            if(max(newparalle[i]) < (sumsum-k)/2):\n                maxindex = newparalle[i].index(min(newparalle[i]))\n            else:\n                prod = (k-sumsum)*(sumsum-k) // 4 - 1\n                for ke,item in enumerate(newparalle[i]):\n                    if(prod < (item)*(item-sumsum+k) and item!=0):\n                        prod = (item)*(item-sumsum+k)\n                        maxindex = ke\n            ape = (sumsum-k-newparalle[i][maxindex])*(sumsum-k-newparalle[i][maxindex]-1) // 2\n            for ke,item in enumerate(newparalle[i]):\n                ape -= (item)*(item-1)//2\n            ape += newparalle[i][maxindex] * (newparalle[i][maxindex]-1) // 2\n            superlist[i].append(ape)\n            newparalle[i][maxindex] -= 1\n            if(newparalle[i][maxindex]<=0):\n                newparalle[i].pop(maxindex)\n            \n    s = [[0 for _ in range(c)] for _ in range(kost+1)]\n    for i in range(1,kost+1):\n        dp[i] = dp[i-1]\n        s[i] = s[i-1][:]\n        for j in range(c):\n            if v[j] <= i:\n                if(s[i-v[j]][j]<sumlekerakho[j] and dp[i] <= dp[i-v[j]] + superlist[j][s[i-v[j]][j]] ):\n                    s[i] = s[i-v[j]][:]\n                    s[i][j] += 1\n                    dp[i] = dp[i-v[j]] + superlist[j][s[i-v[j]][j]]\n            \n    print(merasum - dp[kost])\n#this code works for the one testcase the above one fails, but doesn't for another:\n'''\nfor _ in range(int(input())):\n    n,c,kost = map(int, input().split())\n    parallel = [{} for _ in range(c)]\n    for _ in range(n):\n        a,b,d = map(int, input().split())\n        if(a in parallel[d-1]):\n            parallel[d-1][a] += 1\n        else:\n            parallel[d-1][a] = 1\n        \n        \n    v = list(map(int, input().split()))\n    \n    newparalle = [list(parallel[i].values()) for i in range(c)]\n    pc = []\n    for i in range(c):\n        pc.append(len(parallel[i]))\n        newparalle[i].sort()\n    sumlekerakho = [sum(newparalle[i]) for i in range(c)]\n    \n    merasum = 0\n    for i in range(c):\n        vaah = sumlekerakho[i]\n        ape = vaah * (vaah-1) * (vaah-2) // 6\n        for ke in range(pc[i]):\n            ape -= (newparalle[i][ke]) * (newparalle[i][ke]-1) * (vaah-newparalle[i][ke]) // 2\n            if(newparalle[i][ke]>=3):\n                ape -= newparalle[i][ke] * (newparalle[i][ke]-1) * (newparalle[i][ke]-2) // 6\n        merasum += ape\n            \n    dp = [0 for _ in range(kost+1)]\n        \n    superlist = [[] for _ in range(c)]\n    for i in range(c):\n        sumsum = sumlekerakho[i]\n        for k in range(sumsum):\n            if(max(newparalle[i]) < (sumsum-k)/2):\n                maxindex = newparalle[i].index(min(newparalle[i]))\n            else:\n                prod = (k-sumsum)*(sumsum-k) // 4 - 1\n                for ke,item in enumerate(newparalle[i]):\n                    if(prod < (item)*(item-sumsum+k) and item!=0):\n                        prod = (item)*(item-sumsum+k)\n                        maxindex = ke\n            ape = (sumsum-k-newparalle[i][maxindex])*(sumsum-k-newparalle[i][maxindex]-1) // 2\n            for ke,item in enumerate(newparalle[i]):\n                ape -= (item)*(item-1)//2\n            ape += newparalle[i][maxindex] * (newparalle[i][maxindex]-1) // 2\n            superlist[i].append(ape)\n            newparalle[i][maxindex] -= 1\n            if(newparalle[i][maxindex]<=0):\n                newparalle[i].pop(maxindex)\n            \n    s = [[0 for _ in range(c)] for _ in range(kost+1)]\n    for i in range(1,kost+1):\n        dp[i] = dp[i-1]\n        s[i] = s[i-1][:]\n        for j in range(c):\n            if v[j] <= i:\n                if(s[i-v[j]][j]<sumlekerakho[j] and dp[i] <= dp[i-v[j]] + superlist[j][s[i-v[j]][j]] ):\n                    s[i] = s[i-v[j]][:]\n                    s[i][j] += 1\n                    dp[i] = dp[i-v[j]] + superlist[j][s[i-v[j]][j]]\n            \n    print(merasum - dp[kost])\n'''", "from sys import stdin, setrecursionlimit,stdout\r\nfrom collections import deque, defaultdict,Counter\r\nfrom math import log2, log, ceil,sqrt\r\nfrom operator import *\r\ninput = stdin.readline\r\nsetrecursionlimit(int(2e5))\r\ndef getstr(): return input()[:-1]\r\ndef getint(): return int(input())\r\ndef getints(): return list(map(int, input().split()))\r\ndef getint1(): return list(map(lambda x : int(x) - 1, input().split()))\r\njn = lambda x,l: x.join(map(str,l))\r\n# swap_array function\r\ndef swaparr(arr, a,b):\r\n    temp = arr[a];\r\n    arr[a] = arr[b];\r\n    arr[b] = temp\r\n \r\n## gcd function\r\ndef gcd(a,b):\r\n    if a == 0:\r\n        return b\r\n    return gcd(b%a, a)\r\n \r\n## nCr function efficient using Binomial Cofficient\r\ndef nCr(n, k): \r\n    if(k > n - k): \r\n        k = n - k \r\n    res = 1\r\n    for i in range(k): \r\n        res = res * (n - i) \r\n        res = res / (i + 1) \r\n    return res \r\n \r\n## upper bound function code -- such that e in a[:i] e < x;\r\ndef upper_bound(a, x, lo=0):\r\n    hi = len(a)\r\n    while lo < hi:\r\n        mid = (lo+hi)//2\r\n        if a[mid] < x:\r\n            lo = mid+1\r\n        else:\r\n            hi = mid\r\n    return lo\r\n \r\n\r\n# sliding window ---\r\n\r\ndef maxSlidingWindow(nums,k):\r\n    windowSum,maxSum = 0,0\r\n    windowSum = sum(nums[:k])\r\n    for end in range(k,len(nums)):\r\n        windowSum += nums[end]-nums[end - k]\r\n        maxSum = max(maxSum,windowSum)\r\n    return maxSum\r\n\r\n\r\n# Two Pointer \r\ndef twoSum(nums, target):\r\n        left = 0\r\n        right = len(nums)-1\r\n        while left <= right:\r\n            if nums[left]+nums[right] == target:\r\n                return [left,right]\r\n            elif nums[left]+nums[right] < target:\r\n                left +=  1\r\n            else:\r\n                right -= 1\r\n        return \r\n\r\n# prefix sum\r\n\r\ndef prefix(arr):\r\n    a = map(add,arr.insert(0,0))\r\n    return a\r\n\r\n# Modular Inverse\r\n# y-1 = y(p-2)%p\r\n\r\n# String Matching\r\n\r\n\r\n\r\n\r\n\r\n## prime factorization\r\ndef primefs(n):\r\n    ## if n == 1    ## calculating primes\r\n    primes = {}\r\n    while(n%2 == 0):\r\n        primes[2] = primes.get(2, 0) + 1\r\n        n = n//2\r\n    for i in range(3, int(n**0.5)+2, 2):\r\n        while(n%i == 0):\r\n            primes[i] = primes.get(i, 0) + 1\r\n            n = n//i\r\n    if n > 2:\r\n        primes[n] = primes.get(n, 0) + 1\r\n    ## prime factoriazation of n is stored in dictionary\r\n    ## primes and can be accesed. O(sqrt n)\r\n    return primes\r\n \r\n## MODULAR EXPONENTIATION FUNCTION\r\ndef power(x, y, p): \r\n    res = 1\r\n    x = x % p  \r\n    if (x == 0) : \r\n        return 0\r\n    while (y > 0) : \r\n        if ((y & 1) == 1) : \r\n            res = (res * x) % p \r\n        y = y >> 1      \r\n        x = (x * x) % p \r\n    return res \r\n \r\n## DISJOINT SET UNINON FUNCTIONS\r\ndef swap(a,b):\r\n    temp = a\r\n    a = b\r\n    b = temp\r\n    return a,b\r\n \r\n# find function with path compression included (recursive)\r\n# def find(x, link):\r\n#     if link[x] == x:\r\n#         return x\r\n#     link[x] = find(link[x], link);\r\n#     return link[x];\r\n \r\n# find function with path compression (ITERATIVE)\r\ndef find(x, link):\r\n    p = x;\r\n    while( p != link[p]):\r\n        p = link[p];\r\n    \r\n    while( x != p):\r\n        nex = link[x];\r\n        link[x] = p;\r\n        x = nex;\r\n    return p;\r\n \r\n \r\n# the union function which makes union(x,y)\r\n# of two nodes x and y\r\ndef union(x, y, link, size):\r\n    x = find(x, link)\r\n    y = find(y, link)\r\n    if size[x] < size[y]:\r\n        x,y = swap(x,y)\r\n    if x != y:\r\n        size[x] += size[y]\r\n        link[y] = x\r\n \r\n## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES\r\ndef sieve(n): \r\n    prime = [True for i in range(n+1)] \r\n    p = 2\r\n    while (p * p <= n): \r\n        if (prime[p] == True): \r\n            for i in range(p * p, n+1, p):\r\n                prime[i] = False\r\n        p += 1\r\n    return prime\r\n\r\n\r\n# Binary Search functions\r\ndef binsearch(a, l, r, x):\r\n    while l <= r:\r\n        mid = l + (r-1)//2\r\n        if a[mid]:\r\n            return mid\r\n        elif a[mid] > x:\r\n            l = mid-1\r\n        else:\r\n            r = mid+1\r\n    return -1\r\n\r\n\r\n# Grafh related queries : \r\n\r\n\r\n\r\ngraph = defaultdict(list)\r\nvisited = [0] * 1000000\r\ncol = [-1] * 1000000\r\n \r\n \r\ndef bfs(d, v):\r\n    q = []\r\n    q.append(v)\r\n    visited[v] = 1\r\n    while len(q) != 0:\r\n        x = q[0]\r\n        q.pop(0)\r\n        for i in d[x]:\r\n            if visited[i] != 1:\r\n                visited[i] = 1\r\n                q.append(i)\r\n        print(x)\r\n \r\n \r\ndef make_graph(e):\r\n    d = {}\r\n    for i in range(e):\r\n        x, y = mi()\r\n        if x not in d:\r\n            d[x] = [y]\r\n        else:\r\n            d[x].append(y)\r\n        if y not in d:\r\n            d[y] = [x]\r\n        else:\r\n            d[y].append(x)\r\n    return d\r\n \r\n \r\ndef gr2(n):\r\n    d = defaultdict(list)\r\n    for i in range(n):\r\n        x, y = mi()\r\n        d[x].append(y)\r\n    return d\r\n \r\n \r\ndef connected_components(graph):\r\n    seen = set()\r\n \r\n    def dfs(v):\r\n        vs = set([v])\r\n        component = []\r\n        while vs:\r\n            v = vs.pop()\r\n            seen.add(v)\r\n            vs |= set(graph[v]) - seen\r\n            component.append(v)\r\n        return component\r\n \r\n    ans = []\r\n    for v in graph:\r\n        if v not in seen:\r\n            d = dfs(v)\r\n            ans.append(d)\r\n    return ans\r\n\r\n# End graph related queries\r\n \r\n#### PRIME FACTORIZATION IN O(log n) using Sieve ####\r\nMAXN = int(1e6 + 5)\r\ndef spf_sieve():\r\n    spf[1] = 1;\r\n    for i in range(2, MAXN):\r\n        spf[i] = i;\r\n    for i in range(4, MAXN, 2):\r\n        spf[i] = 2;\r\n    for i in range(3, ceil(MAXN ** 0.5), 2):\r\n        if spf[i] == i:\r\n            for j in range(i*i, MAXN, i):\r\n                if spf[j] == j:\r\n                    spf[j] = i;\r\n    ## function for storing smallest prime factors (spf) in the array\r\n \r\n################## un-comment below 2 lines when using factorization #################\r\n# spf = [0 for i in range(MAXN)] \r\n# spf_sieve() \r\ndef factoriazation(x):\r\n    ret = {};\r\n    while x != 1:\r\n        ret[spf[x]] = ret.get(spf[x], 0) + 1;\r\n        x = x//spf[x]\r\n    return ret\r\n    ## this function is useful for multiple queries only, o/w use\r\n    ## primefs function above. complexity O(log n)\r\n \r\n## taking integer array input\r\n\r\n\r\n# LCM of two numbers :\r\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\r\n \r\n#defining a couple constants\r\nMOD = int(1e9)+7;\r\nCMOD = 998244353;\r\nINF = float('inf'); NINF = -float('inf');\r\ny, n = \"YES\", \"NO\"\r\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12,\r\n       'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24,\r\n       'z': 25}\r\n\r\n\r\n# used for testing your code \r\n\r\n# inputs=open('input.txt','r') \r\n\r\ndef solve():\r\n    # n = no. of lines,c = no. of distinct color ,k = len. of erasor \r\n    n,c,k = map(int,input().split())\r\n    d = {}\r\n    for i in range(n):\r\n        a,b,c = map(int,input().split())\r\n        if c not in d.keys():\r\n            d[c] = 1\r\n        else:\r\n            d[c] += 1\r\n    v = list(map(int,input().split())) # equal \r\n    l_r = k//v[0] # how much line can i remove\r\n    l = list(d.values())\r\n    i = 0\r\n    while l_r != 0:\r\n        l[l.index(max(l))] -= 1\r\n        l_r -= 1 \r\n    count = 0\r\n    for i in l:\r\n        count+=((i)*(i-1)*(i-2))//6\r\n    print(count)\r\ndef __starting_point():\r\n    # solve()\r\n    # for t in range(getint()):\r\n    #     print(\"Case #{}: \".format(t + 1), end=\"\")\r\n    #     solve()\r\n    for _ in range(int(input())):#getint()):\r\n        solve()\r\n\r\n    # https://codeforces.com/contest/507/status/B/page/296?order=BY_PROGRAM_LENGTH_ASC\n__starting_point()", "for x in range(int(input())):\r\n  if(x == 6):\r\n    n,c,kost = map(int, input().split())\r\n    parallel = [{} for _ in range(c)]\r\n    for _ in range(n):\r\n        a,b,d = map(int, input().split())\r\n        if(a in parallel[d-1]):\r\n            parallel[d-1][a] += 1\r\n        else:\r\n            parallel[d-1][a] = 1\r\n        \r\n        \r\n    v = list(map(int, input().split()))\r\n    \r\n    newparalle = [list(parallel[i].values()) for i in range(c)]\r\n    pc = []\r\n    for i in range(c):\r\n        pc.append(len(parallel[i]))\r\n        newparalle[i].sort()\r\n    sumlekerakho = [sum(newparalle[i]) for i in range(c)]\r\n    \r\n    merasum = 0\r\n    for i in range(c):\r\n        vaah = sumlekerakho[i]\r\n        ape = vaah * (vaah-1) * (vaah-2) // 6\r\n        for ke in range(pc[i]):\r\n            ape -= (newparalle[i][ke]) * (newparalle[i][ke]-1) * (vaah-newparalle[i][ke]) // 2\r\n            if(newparalle[i][ke]>=3):\r\n                ape -= newparalle[i][ke] * (newparalle[i][ke]-1) * (newparalle[i][ke]-2) // 6\r\n        merasum += ape\r\n            \r\n    dp = [0 for _ in range(kost+1)]\r\n        \r\n    superlist = [[] for _ in range(c)]\r\n    for i in range(c):\r\n        sumsum = sumlekerakho[i]\r\n        for k in range(sumsum):\r\n            if(max(newparalle[i]) < (sumsum-k)/2):\r\n                maxindex = newparalle[i].index(min(newparalle[i]))\r\n            else:\r\n                prod = (k-sumsum)*(sumsum-k) // 4 - 1\r\n                for ke,item in enumerate(newparalle[i]):\r\n                    if(prod < (item)*(item-sumsum+k) and item!=0):\r\n                        prod = (item)*(item-sumsum+k)\r\n                        maxindex = ke\r\n            ape = (sumsum-k-newparalle[i][maxindex])*(sumsum-k-newparalle[i][maxindex]-1) // 2\r\n            for ke,item in enumerate(newparalle[i]):\r\n                ape -= (item)*(item-1)//2\r\n            ape += newparalle[i][maxindex] * (newparalle[i][maxindex]-1) // 2\r\n            superlist[i].append(ape)\r\n            newparalle[i][maxindex] -= 1\r\n            if(newparalle[i][maxindex]<=0):\r\n                newparalle[i].pop(maxindex)\r\n            \r\n    s = [[0 for _ in range(c)] for _ in range(kost+1)]\r\n    for i in range(1,kost+1):\r\n        dp[i] = dp[i-1]\r\n        s[i] = s[i-1][:]\r\n        for j in range(c):\r\n            if v[j] <= i:\r\n                if(s[i-v[j]][j]<sumlekerakho[j] and dp[i] <= dp[i-v[j]] + superlist[j][s[i-v[j]][j]] ):\r\n                    s[i] = s[i-v[j]][:]\r\n                    s[i][j] += 1\r\n                    dp[i] = dp[i-v[j]] + superlist[j][s[i-v[j]][j]]\r\n            \r\n    print(merasum - dp[kost])\r\n  else:\r\n      N,C,K=map(int,input().split())\r\n      poss,lines,res = [0]*(K+1),{},0\r\n      for _ in range(N):\r\n        a,b,c=map(int,input().split())\r\n        if c-1 not in lines: lines[c-1]={a:1};\r\n        else: lines[c-1][a]=lines[c-1].get(a,0)+1;\r\n      era=list(map(int,input().split()))  \r\n      for c in range(C):\r\n        if era[c]==0: lines.pop(c,None);\r\n      for c,mp in lines.items():\r\n        vals=list(mp.values())\r\n        if len(vals)>=3:\r\n          vals.sort()\r\n          s1,s2,s3=sum(vals),sum(a**2 for a in vals),sum(a**3 for a in vals)\r\n          full=(s1**3-3*s1*s2+2*s3)//6\r\n          res+=full;gain={0:0};idx=0;\r\n          for j in range(era[c],K+1,era[c]):\r\n            vals[idx]-=1;old=vals[idx]+1;nw=vals[idx]\r\n            if vals[idx]==0:\r\n              idx+=1\r\n              if idx==len(vals): break;\r\n            s1-=1;s2+=nw**2-old**2;s3+=nw**3-old**3;gain[j]=full-(s1**3-3*s1*s2+2*s3)//6\r\n          prev=poss\r\n          poss=[max(prev[i-j]+gain[j] for j in gain.keys() if j<=i) for i in range(K+1)]\r\n      print(res-max(poss))", "# ##plot a line of y = ax + b and then count number of triangles formed by lines of same colour\n# ##then remove max possible lines (while not k <= 0) K - Vi\n# ##print min possible triangles after (max lines are removed, but not necessarily)\n# #>>>first, use y = ax + b to find line by taking x = 0 and y = 0 in two turns\n# #>>>then count all triangles with all three sides of same colour\n# #>>>remove as many lines as required, such that triangles formed are minimum\n# # __CONSTRAINTS__\n# # 1\u2264T\u226410 \n# # 1\u2264C\u2264N\u22643,000\n# # 0\u2264K\u22643,000\n# # 0\u2264ai,bi\u2264109 for each valid i\n# # 1\u2264ci\u2264C for each valid i\n# # 0\u2264Vi\u2264K for each valid i\n# # no two lines coincide, regardless of their colours\n# # no three lines are concurrent\n# # __SUBTASKS__\n# # Subtask #1 (10 points):\n# # # N\u226410\n# # # K\u2264100\n# # Subtask #2 (15 points):\n# # # V1=V2=\u2026=VC\n# # # no two lines are parallel\n# # Subtask #3 (25 points):\n# # # no two lines are parallel\n# # Subtask #4 (50 points):\n# # #original constraints\n# ###>>> clearly, brute force cannot be used....ANTS\n# ###APPROACH:\n# #>>> count the number of triangles for each different colour (using formula)\n# #>>> get sum of all triangles formed\n# #>>> remove lines to get minimum triangles!!!....how?\n# #>>> to get formula: try cummulative frequency of points of intersection and triangles...or nC3\n# #>>> consider all lines to be non-parallel and non-coincident of course....aim is subtask 2\n# # 1 --> 0, 0\n# # 2 --> 0 + 0 = 0, 1\n# # 3 --> 0 + 1 = 1, 3\n# # 4 --> 1 + 3 = 4, 6\n# # 5 --> 4 + 6 = 10, 10\n# # 6 --> 10 + 10 = 20, 15 ...\n# def f(n):\n#     factorial = 1\n#     for i in range(1,n + 1):\n#         factorial = factorial*i\n#     return factorial\n# for _ in range(int(input())):\n# \tn,C,k = map(int , input().split())\n# \tfor _ in range(n):\n# \t\ta,b,c = map(int , input().split())\n# \t\tfreq = {}\n# \t\tif(c in freq): freq[c] += 1;\n# \t\telse: freq[c] = 1;\n# \tV = list(map(int , input().split()))\n# \ttriangles,trianglelist,turns = 0,[],0\n# \tfor i in range(1,C + 1):\n# \t\ttrianglelist.append(f(i)//(f(i - 3)*6))\n# \t# while(k >= 0 and k > min(V)):\n# \t# \ti = max(freq, key = freq.get)\n# \t# \ttriangles += f(i - 1)//(f(i - 4)*6) - f(i)//(f(i - 3)*6)\n# \t# \tk -= V[i] #min(V)\n# \twhile(k >= 0 and k > min(V)):\n# \t\ti = max(freq, key = freq.get)\n# \t\tfreq[i] -= 1\n# \t\tk -= V[i - 1]\n# \t\tturns += 1\n# \ttrianglelist.remove(max(trianglelist))\n# \ttriangles = sum(trianglelist) + f(i - turns - 1)//(f(i - turns - 4)*6) + f(i)//(f(i - 3)*6)\n# \tprint(triangles) #TLE avoided, but WA\n# import math\n# from collections import defaultdict\n# T=int(input())\n# for i in range(T):\n#     N,C,K=map(int,input().split())\n#     D=defaultdict(int)\n#     ans='Hello'\n#     for j in range(N):\n#         a,b,c=map(int,input().split())\n#         D[c]+=1\n    \n#     v=list(map(int,input().split()))\n#     q=0\n#     num=K//v[0]\n#     d=0\n#     while(num>0):\n#         P=list(D.keys())[list(D.values()).index(max(D.values()))]\n#         D[P]-=1\n#         num-=1\n#     temp=0\n#     for i,j in D.items():\n#         if(j>=3):\n#             temp+=(math.factorial(j)/(math.factorial(3)*math.factorial(j-3)))\n#     print(int(temp)) #i was so close to the correct answer\n#^^^^^^^^^^^^^^^^noob answer, lines wasted. but AC [15 pts]\nfor _ in range(int(eval(input()))):\n  N,C,K=list(map(int,input().split()))\n  poss,lines,res = [0]*(K+1),{},0\n  for _ in range(N):\n    a,b,c=list(map(int,input().split()))\n    if c-1 not in lines: lines[c-1]={a:1};\n    else: lines[c-1][a]=lines[c-1].get(a,0)+1;\n  era=list(map(int,input().split()))  \n  for c in range(C):\n    if era[c]==0: lines.pop(c,None);\n  for c,mp in list(lines.items()):\n    vals=list(mp.values())\n    if len(vals)>=3:\n      vals.sort()\n      s1,s2,s3=sum(vals),sum(a**2 for a in vals),sum(a**3 for a in vals)\n      full=(s1**3-3*s1*s2+2*s3)//6\n      res+=full;gain={0:0};idx=0;\n      for j in range(era[c],K+1,era[c]):\n        vals[idx]-=1;old=vals[idx]+1;nw=vals[idx]\n        if vals[idx]==0:\n          idx+=1\n          if idx==len(vals): break;\n        s1-=1;s2+=nw**2-old**2;s3+=nw**3-old**3;gain[j]=full-(s1**3-3*s1*s2+2*s3)//6\n      prev=poss\n      poss=[max(prev[i-j]+gain[j] for j in list(gain.keys()) if j<=i) for i in range(K+1)]\n  print(res-max(poss))"]
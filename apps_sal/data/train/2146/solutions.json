["import sys\nreadline = sys.stdin.readline\n\nN, D, M = map(int, readline().split())\nA = list(map(int, readline().split()))\nAm = [a for a in A if a > M]\nAo = [a for a in A if a <= M]\nAm.sort(reverse = True)\nAo.sort(reverse = True)\nCam = Am[:]\nCao = Ao[:]\n\nfor i in range(1, len(Cam)):\n    Cam[i] += Cam[i-1]\nfor i in range(1, len(Cao)):\n    Cao[i] += Cao[i-1]\n\nk = -(-N//(D+1))\nans = sum(Am[:k])\nlcam = len(Cam)\nCam = [0] + Cam\nfor i in range(len(Cao)):\n    k = min(lcam, -(-(N-(i+1))//(D+1)))\n    ans = max(ans, Cao[i] + Cam[k])\n\n\nprint(ans)", "import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef solve():\n    pre = []\n    pos = []\n    for a in aa:\n        if a > m: pos.append(a)\n        else: pre.append(a)\n    pos.sort(reverse=True)\n    pre.sort(reverse=True)\n\n    cs = [0]\n    for a in pre: cs.append(cs[-1] + a)\n    pre = cs\n    cs = [0]\n    for a in pos: cs.append(cs[-1] + a)\n    pos = cs\n\n    ans = 0\n    for i in range(len(pre)):\n        j = min((n - i - 1) // (d + 1) + 1, len(pos) - 1)\n        cur = pre[i] + pos[j]\n        ans = max(ans, cur)\n\n    print(ans)\n\nn,d,m=MI()\naa=MI()\nsolve()\n", "import sys\ninput = sys.stdin.readline\n\nn, d, m = map(int, input().split())\na = list(map(int, input().split()))\n\nup = []\ndown = []\nfor i in range(n):\n    if a[i] > m:\n        up.append(a[i])\n    else:\n        down.append(a[i])\n        \nup = sorted(up)\ndown = sorted(down)\n\nif not up:\n    print(sum(down))\n    return\n\nans = 0\nans += up.pop()\nlap, rem = divmod((n - 1), (d + 1))\nfor i in range(rem):\n    if not down:\n        break\n    else:\n        ans += down.pop()\n\nmatome = []\nwhile down:\n    tmp = 0\n    for _ in range(d + 1):\n        if down:\n            tmp += down.pop()\n    matome.append(tmp)\n\nmatome = sorted(matome + up, reverse=True)\nans += sum(matome[0:min(lap, len(matome))])\n\nprint(ans)", "\nn, d, m = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\na = list(reversed(sorted(a)))\nnl = [x for x in a if x <= m]\nml = [x for x in a if x > m]\naml = [0]\nfor x in ml:\n    aml.append(aml[-1] + x)\nanl = [0]\nfor x in nl:\n    anl.append(anl[-1] + x)\n\nif len(ml) == 0:\n    print(sum(nl))\n    return\n\nresult = []\n\nbest = 0\n\nfor i in range(1, len(ml) + 1):\n    # Is it possible to have i muzzles?\n    if (i-1)*(d+1) + 1 > n:\n        continue\n    if i*d < len(ml) - i:\n        continue\n\n    # What is my score if I cause i muzzles?\n    # Then it is: the top i muzzling elements.\n    # Plus the top how many nmes I have left after filling\n\n    cur = aml[i]\n    need_nmes = max(0, (i-1)*(d+1) + 1 - len(ml))\n    rem_nmes = len(nl) - need_nmes\n    assert rem_nmes >= 0\n    cur += anl[rem_nmes]\n    \n    if cur > best:\n        #print(\"Doing better with\", i, \"muzzles:\", cur)\n        best = cur\n\nprint(best)\n", "n, d, m = list(map(int, input().split()))\na = list(map(int, input().split()))\np = []\nq = []\nfor x in a:\n    if x > m:\n        p.append(x)\n    else:\n        q.append(x)\np = [0] + sorted(p, reverse=True)\nq = [0] + sorted(q, reverse=True)\nfor i in range(len(p) - 1):\n    p[i + 1] += p[i]\nfor i in range(len(q) - 1):\n    q[i + 1] += q[i]\nans = 0\nfor t in range(len(p)):\n    v = n + d - t * d - t\n    if 0 <= v < len(q) + d:\n        ans = max(ans, p[t] + q[min(v, len(q) - 1)])\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nn,d,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nP=[]\nM=[]\n\nfor a in A:\n    if a>m:\n        P.append(a)\n    else:\n        M.append(a)\n\nP.sort(reverse=True)\nM.sort(reverse=True)\n\nif P==[]:\n    print(sum(M))\n    return\n\nANS=sum(M)+P[0]\n\nuseP=1\nuseM=len(M)\nSUM=ANS\n\n#print(ANS)\n\nwhile 0<=useP<=len(P) and 0<=useM<=len(M):\n    if n-(useP+useM+1)>=useP*d:\n        useP+=1\n\n        if useP>len(P):\n            break\n        \n        SUM+=P[useP-1]\n\n    else:\n        if useM==0:\n            break\n        \n        SUM-=M[useM-1]\n        useM-=1\n\n    #print(useP,useM,SUM)\n\n    ANS=max(ANS,SUM)\n\nprint(ANS)\n    \n    \n    \n\n"]
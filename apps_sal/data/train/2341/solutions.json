["import sys\nreadline = sys.stdin.readline\n\nclass Segtree:\n    def __init__(self, A, intv, initialize = True, segf = max):\n        self.N = len(A)\n        self.N0 = 2**(self.N-1).bit_length()\n        self.intv = intv\n        self.segf = segf\n        if initialize:\n            self.data = [intv]*self.N0 + A + [intv]*(self.N0 - self.N)\n            for i in range(self.N0-1, 0, -1):\n                self.data[i] = self.segf(self.data[2*i], self.data[2*i+1]) \n        else:\n            self.data = [intv]*(2*self.N0)\n        \n    def update(self, k, x):\n        k += self.N0\n        self.data[k] = x\n        while k > 0 :\n            k = k >> 1\n            self.data[k] = self.segf(self.data[2*k], self.data[2*k+1])\n    \n    def query(self, l, r):\n        L, R = l+self.N0, r+self.N0\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.segf(s, self.data[R])\n            if L & 1:\n                s = self.segf(s, self.data[L])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n    \n    def binsearch(self, l, r, check, reverse = False):\n        L, R = l+self.N0, r+self.N0\n        SL, SR = [], []\n        while L < R:\n            if R & 1:\n                R -= 1\n                SR.append(R)\n            if L & 1:\n                SL.append(L)\n                L += 1\n            L >>= 1\n            R >>= 1\n        \n        if reverse:\n            for idx in (SR + SL[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx+1]):\n                    idx = 2*idx + 1\n                else:\n                    idx = 2*idx\n            return idx - self.N0\n        else:\n            for idx in (SL + SR[::-1]):\n                if check(self.data[idx]):\n                    break\n            else:\n                return -1\n            while idx < self.N0:\n                if check(self.data[2*idx]):\n                    idx = 2*idx\n                else:\n                    idx = 2*idx + 1\n            return idx - self.N0\n\nTc = int(readline())\nAns = [None]*Tc\n\nfor qu in range(Tc):\n    N, M, K = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    Ai = A[::-1]\n    table = [None]*M\n    for i in range(M):\n        j = (M-1)-i\n        table[i] = max(A[i], Ai[j])\n    inf = 10**9+7\n    T = Segtree(table, inf, initialize = True, segf = min)\n    ans = min(table)\n    K = min(K, M-1)\n    R = M-1-K\n    for ki in range(K+1):\n        ans = max(ans, T.query(ki, ki+R+1))\n    Ans[qu] = ans\nprint('\\n'.join(map(str, Ans)))\n        \n    \n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nT = int(input())\nfor _ in range(T):\n    N, M, K = list(map(int, input().split()))\n    K = min(K, M-1)\n    A = [int(a) for a in input().split()]\n    B = [max(A[i], A[-M+i]) for i in range(M)]\n    print(max([min(B[i:i+M-K]) for i in range(K+1)]))\n", "t = int(input())\nfor _ in range(t):\n    n, m, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n\n    ans = 0\n    control_forward = min(k, m-1)\n    for i in range(control_forward+1):\n        l = i\n        r = n-1-control_forward+i\n        non_control_forward = max(m-1-control_forward, 0)\n        anstemp = 10**10\n        for j in range(non_control_forward+1):\n            l += j\n            r += -non_control_forward + j\n            anstemp = min(anstemp, max(a[l], a[r]))\n\n            l -= j\n            r -= -non_control_forward + j\n        ans = max(anstemp, ans)\n\n    print(ans)\n"]
["class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n\n        \n        s_count=[s.count(chr(i)) for i in range(97,123)]\n        t_count=[t.count(chr(i)) for i in range(97,123)]\n        diff=[t_count[i]-s_count[i] for i in range(26) if t_count[i]-s_count[i]>0]\n        sum=0\n        for i in range(len(diff)):\n            sum=sum+diff[i]\n        \n        return sum\n#         # create a hash map for string S\n#         count = defaultdict(int)\n        \n#         for char in s:\n#             count[char] += 1\n        \n#         # check the difference of two strings\n        \n        \n#         diff = 0\n#         for char in t:\n#             if count[char] > 0 :\n#                 #print(char)\n#                 count[char] -= 1\n#             else:\n#                 diff += 1\n        \n        \n#         return int(diff)\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        # count = 0\n        # from string import ascii_lowercase\n        # for letter in ascii_lowercase:\n        #     count += abs(t.count(letter) - s.count(letter))\n        # return int(count//2)\n        abc = 'abcdefghijklmnopqrstuvwxyz'\n        return int(sum(abs(t.count(l)-s.count(l)) for l in abc)/2)\n                \n", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        c1, c2 = map(Counter, (s, t))\n        \n        return len(list((c1 - c2).elements()))", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        freq_s = {}\n        freq_t = {}\n\n        for keys in s:\n            freq_s[keys] = freq_s.get(keys, 0) + 1\n        \n        for t_keys in t:\n            freq_t[t_keys] = freq_t.get(t_keys, 0) + 1\n        \n        changes = 0\n        for key, val in freq_s.items():\n            val = freq_s[key]\n            val_t = freq_t.get(key, 0)\n            \n            if val > val_t:\n                changes += val - val_t \n        \n        return changes", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_map = {}\n        change = 0\n        for ch in s:\n            if ch not in s_map:\n                s_map[ch] = 1\n            else:\n                s_map[ch] += 1\n        for i in range(0,len(t)):\n            if t[i] in s_map and s_map[t[i]] > 0:\n                s_map[t[i]] -= 1\n            else:\n                change += 1\n        return change\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        arr1 = defaultdict()\n        arr2 = defaultdict()\n        count=0\n        for i in range(len(s)):           \n            arr1[s[i]] = arr1.get(s[i],0)+1\n            arr2[t[i]] = arr2.get(t[i],0)+1\n        for i in range(len(t)):\n            if t[i] not in arr1:\n                count = count + arr2[t[i]]\n                arr2[t[i]] = 0\n                continue\n            if arr2[t[i]] > arr1[t[i]]: \n                count = count + arr2[t[i]] - arr1[t[i]]\n                arr2[t[i]]= arr1[t[i]]\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count = collections.Counter(s)\n        res = 0\n        for c in t:\n            if count[c] > 0:\n                count[c] -= 1\n            else:\n                res += 1\n        return res\n   \n        \n# class Solution:\n#     def minSteps(self, s: str, t: str) -> int:\n#         count = collections.Counter(s)\n#         res = 0\n#         for c in t:\n#             if count[c] > 0:\n#                 count[c] -= 1\n#             else:\n#                 res += 1\n#         return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s=list(s)\n        t=list(t)\n        dic=dict()\n        for i in s:\n            if i in dic:\n                dic[i]=dic[i]+1\n            else:\n                dic[i]=1\n        print(dic)\n        for j in t:\n            if j in dic:\n                dic[j]=dic[j]-1\n        print(dic)\n        sum=0\n        for i in list(dic.values()):\n            if i>0:\n                sum+=i\n        return sum\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        minSteps = 0\n        dict = {}\n        for ch in s:\n            if dict.get(ch):\n                dict[ch] += 1\n            else:\n                dict[ch] = 1\n        for c in t:\n            num = dict.get(c)\n            if num:\n                dict[c] -= 1\n                if num < 0:\n                    minSteps += 1\n            else:\n                minSteps += 1\n                \n        return minSteps", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if len(s) != len(t):\n            return 0\n        hash_map = dict()\n        count = 0\n        for char in s:\n            hash_map[char] = hash_map.get(char, 0) + 1\n        \n        for char in t:\n            if hash_map.get(char, 0) > 0:\n                hash_map[char] -= 1\n            else:\n                count += 1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        hash_ = dict()\n        \n        for i in range(len(s)):\n            hash_.setdefault(t[i], 0)\n            hash_.setdefault(s[i], 0)\n            hash_[t[i]] -= 1\n            hash_[s[i]] += 1\n            \n        sum_ = 0\n        \n        for v in hash_.values():\n            if v > 0:\n                sum_ += v\n                \n        return sum_", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        return sum((Counter(t) - Counter(s)).values())\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cs = collections.Counter(s)\n        ct = collections.Counter(t)\n        \n        for x in s:\n            if x in ct and ct[x]>0:\n                ct[x] -= 1\n                cs[x] -= 1\n        return sum(cs.values())", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        maps = {}\n        mapt = {}\n        for i in range(0, len(s)):\n            if s[i] not in maps:\n                maps[s[i]] = 1\n            elif s[i] in maps:\n                maps[s[i]] = maps[s[i]] + 1\n            if t[i] not in mapt:\n                mapt[t[i]] = 1\n            elif t[i] in mapt:\n                mapt[t[i]] = mapt[t[i]] + 1\n        count = 0 \n        l = set()\n        for j in range(0, len(s)):\n            if s[j] not in l and s[j] not in mapt:\n                l.add(s[j])\n                count = count + maps[s[j]]\n            elif s[j] not in l and maps[s[j]] > mapt[s[j]]:\n                l.add(s[j])\n                count = count + (maps[s[j]] - mapt[s[j]])\n        return count\n        \n        \n        \n        \n", "import collections\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        c1=collections.Counter(s)\n        c2=collections.Counter(t)\n        c=0\n        for i in s:\n            if c2[i]>0:\n                c1[i]-=1\n                c2[i]-=1\n        l=list(c1.values())\n        for i in l:\n            if i>0:\n                c+=i\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if(len(s) != len(t)):\n            return -1\n    \n        obj = dict()\n        missing = dict()\n        total = 0\n        \n        for i in range(len(s)):\n            if(obj.get(s[i]) == None):\n                obj[s[i]] = 1\n            else:\n                obj[s[i]] = obj[s[i]] + 1\n                \n        for j in range(len(t)):\n            if(obj.get(t[j]) == None):\n                if(missing.get(t[j]) == None):\n                    missing[t[j]] = 1\n                else:\n                    missing[t[j]] = missing[t[j]] + 1\n            else:\n                if(obj.get(t[j]) == 1):\n                    del obj[t[j]]\n                else:\n                    obj[t[j]] = obj[t[j]] - 1\n            \n        for key in missing.keys():\n            total = total + missing.get(key)\n            \n        return total", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        dic1 = Counter(s); dic2 = Counter(t)\n        k=0; length=s.__len__()\n        while k < length:\n            c = t[k]\n            if dic1[c] > 0:\n                \n                dic1[c] -= 1\n                dic2[c] -= 1\n            k += 1\n        return sum(dic2.values())", "import collections\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        c1=collections.Counter(s)\n        c2=collections.Counter(t)\n        c=0\n        for i in s:\n            if c2[i]>0:\n                c1[i]-=1\n                c2[i]-=1\n        l=list(c1.values())\n        c=sum(l)\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_counter = Counter(s)\n        t_counter = Counter(t)\n        changes = 0\n        \n        for key in list(s_counter.keys()): \n            changes += abs(s_counter[key] - t_counter[key])\n\n        for key in list(t_counter.keys()):\n            changes += 0 if key in s_counter else t_counter[key]\n            \n        return changes//2\n    \n    \n\n    ## aba - bab - a: 2, b:1 - a: 1, b: 2\n    ## abac - babb - a: 2, b:1, c:1 - a: 1, b: 3\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_dict = {}\n        t_dict = {}\n        res = 0\n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] = s_dict[s[i]] + 1\n            else:\n                s_dict[s[i]] = 1\n        \n        for j in range(len(t)):\n            if t[j] in t_dict:\n                t_dict[t[j]] = t_dict[t[j]] + 1\n            else:\n                t_dict[t[j]] = 1\n        \n        print((s_dict, t_dict))\n        \n        for i in range(len(s)):\n            if s[i] in t_dict and t_dict[s[i]] > 0:\n                s_dict[s[i]] -= 1\n                t_dict[s[i]] -= 1\n        \n        for key, value in list(s_dict.items()):\n            if value > 0:\n                res += value\n                \n        print((s_dict, t_dict))\n        return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        res = 0\n        s = list(s)\n        t = list(t)\n        d1 = dict()\n        d2 = dict()\n        for i in s:\n            if i in d1.keys():\n                d1[i] += 1\n            else:\n                d1[i] = 1\n        for i in t:\n            if i in d2.keys():\n                d2[i] += 1\n            else:\n                d2[i] = 1\n        res = 0\n        for i in d1.keys():\n            if i in d2.keys() and d2[i] < d1[i]:\n                res += (d1[i]-d2[i])\n            elif i not in d2.keys():\n                res += d1[i]\n        return res", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count = collections.Counter(s)\n        req = 0\n        for i in t:\n            if i not in count:\n                req += 1\n            else:\n                count[i] -= 1\n                if count[i] == 0:\n                    del count[i]\n        if count:\n            return req\n        else:\n            return 0\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        # ct = Counter(t)\n        # cs = Counter(s)\n        ct = {}\n        cs = {}\n        for i in range(len(s)):\n            ct.update({t[i]:ct.get(t[i], 0)+1})\n            cs.update({s[i]:cs.get(s[i], 0)+1})\n        c = 0\n        for k, v in cs.items():\n            r = v-ct.get(k, 0)\n            c += r if r > 0 else 0 \n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_list=Counter(s)\n        count=0\n        for i in range(len(t)):\n            if (t[i] in s_list) and s_list[t[i]]>0:\n                s_list[t[i]]-=1\n            else:\n                count+=1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        char = {}\n        c = 0\n        #track the letters in string t \n        for ch in t:\n            if ch not in char.keys():\n                char[ch] = 1\n            else:\n                char[ch] += 1\n                \n        #for every character in s, if it existed in t, decrement the count in t\n        for ch in s:\n            if ch in char.keys() and char[ch] != 0:\n                char[ch] -= 1\n            else:\n                c += 1\n        \n        return c", "from collections import Counter\n\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        c = Counter(s)\n        for char in t:\n            if (char in c):\n                c[char] = max(0, c[char] - 1)\n        \n        return sum(c.values())\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1, cnt2 = list(map(collections.Counter, (s, t)))\n        \n        return sum((cnt1 - cnt2).values())\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        \n        cnt = Counter(s)\n        \n        for x in t:\n            if x in cnt.keys() and cnt[x] > 0:\n                cnt[x] -= 1\n        \n        ans = 0\n        # print(cnt)\n        for x in cnt.values():\n            ans += abs(x)\n        \n        return ans", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if len(s) != len(t):\n            return -1\n        s_count = collections.Counter(s) # b=2 a=1\n        for c in t:\n            if c in s_count:\n                s_count[c] -= 1\n            if s_count[c] == 0:\n                del(s_count[c])\n        total = 0\n        for val in list(s_count.values()):\n            total += val\n        return total\n", "class Solution:\n    def minSteps(self, a: str, b: str) -> int:\n        count=0\n        a=sorted(a)\n        b=sorted(b)\n\n        dic1=Counter(a)\n        dic2=Counter(b)\n\n        for i in b:\n\n            if i in dic1:\n                if dic1[i]:\n                    dic1[i]-=1\n                else:\n                    count+=1\n            else:\n                count+=1\n\n        return count", "class Solution:\n    def minSteps(self, a: str, b: str) -> int:\n        count=0\n        dic1=Counter(a)\n        \n\n        for i in b:\n\n            if i in dic1:\n                if dic1[i]:\n                    dic1[i]-=1\n                else:\n                    count+=1\n            else:\n                count+=1\n\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count=0\n        a = s\n        b = t\n        if len(s)==0:\n            return len(t)\n        if len(t)==0:\n            return len(s)\n        for curr in a:\n            # print(\\\"Curr=\\\",curr,\\\"and t=\\\",b)\n            if curr in b:\n                b=b.replace(curr,'',1) \n                # print(\\\"Now t=\\\",b)\n            else:\n                count+=1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count = 0\n        for i in s:\n            if i in t:\n                t = t.replace(i, '', 1)\n            else:\n                count += 1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        src = Counter(s)\n        des = Counter(t)\n        src.subtract(des)\n        freq = list(src.values())\n        ans = 0\n        freq = sorted(freq)\n        freq = list([a for a in freq if a != 0])\n        while len(freq) > 1:\n            actions = min(abs(freq[0]), freq[-1])\n            ans += actions\n            freq[0] = actions + freq[0]\n            freq[-1] = freq[-1] - actions\n            freq = list([a for a in freq if a != 0])\n        if len(freq) == 1:\n            ans += freq[0]\n        return ans\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count=0\n        for curr in s:\n            # print(\\\"Curr=\\\",curr,\\\"and t=\\\",t)\n            if curr in t:\n                t=t.replace(curr,'',1) \n                # print(\\\"Now t=\\\",t)\n            else:\n                count+=1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        for i in range(0,len(t)):\n            if t[i] in s:\n                s=s.replace(t[i],'',1)\n        return len(s)", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        c1, c2 = map(Counter, (s, t))\n        \n        return sum(1 for _ in (c1 - c2).elements())", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cs = collections.Counter(s)\n        ct = collections.Counter(t)\n        diff = 0\n        for i in ct:\n            if i in cs:\n                if ct[i] > cs[i]:\n                    diff += ct[i] - cs[i]\n            else:\n                diff += ct[i]\n        return diff", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        tt = Counter(t)\n        ss = Counter(s)\n        \n        cnt = 0\n        #print(tt,ss)\n        all_c = set(s+t)\n        \n        for k in all_c:\n            if tt[k] < ss[k]:\n                cnt += ss[k]-tt[k]\n        \n        return cnt", "from collections import Counter\n\nclass Solution:\n    \n    def minSteps(self, s: str, t: str) -> int:\n        one, two = Counter(s), Counter(t)\n        return sum({k: abs(one[k] - two[k]) for k in one | two}.values()) // 2\n        \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        result = len(s)\n        for i in set(s):\n            n_s = s.count(i)\n            n_t = t.count(i)\n            result = result - min(n_s,n_t)\n        \n        return result\n            \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        countS = Counter(s)\n        countT = Counter(t)\n        index = 0\n        res = 0\n        if countS == countT:\n            return 0\n        \n        # for k, v in countT.items():\n        #     if v < countS[k]:\n        #         res += countS[k] - v\n        \n        for k, v in countS.items():\n            if v > countT[k]:\n                res += v - countT[k]\n            \n        return res", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d1 = collections.Counter(s)\n        d2 =  collections.Counter(t)\n        \n        return sum((d1-d2).values())", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        ds = collections.Counter(list(s))\n       \n        dt = collections.Counter(list(t))\n        ans = 0\n        #print(ds,dt)        \n        set_ = set(s+t)\n       # print(set_)\n        for i in set_:\n            ans+=abs(dt[i]-ds[i])\n        return ans//2\n        \n            \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        s,t=map(Counter,[s,t])\n        return sum(max(s[c]-t[c],0) for c in s)", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if s == t:\n            return 0\n        s_count = Counter(s)\n        t_count = Counter(t)\n        c = 0\n        for i , j in s_count.items():\n            if i in t_count:\n                if t_count[i] < j:\n                    c += j - t_count[i]\n            else:\n                c += j\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s = list(s)\n        ds = collections.Counter(s)\n        t = list(t)\n        dt = collections.Counter(t)\n        ans = 0\n        #print(ds,dt)        \n        set_ = set(s+t)\n       # print(set_)\n        for i in set_:\n            ans+=abs(dt[i]-ds[i])\n        return ans//2\n        \n            \n", "from collections import Counter\n\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sc = Counter(s)\n        tc = Counter(t)\n        c = 0\n        for i in tc:\n            c += tc[i]\n        for i in tc:\n            if i in sc:\n                if tc[i] <= sc[i]:\n                    c -= tc[i]\n                elif tc[i] > sc[i]:\n                    c -= sc[i]\n\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n#         sdict = collections.defaultdict(int)\n#         tdict = collections.defaultdict(int)\n#         for c in s:\n#             sdict[c] += 1\n#         for c in t:\n#             tdict[c] += 1\n        \n#         res = 0\n#         for c in string.ascii_lowercase:\n#             res += abs(tdict[c] - sdict[c])\n#         return res // 2\n        sdict = collections.defaultdict(int)\n        for c in s:\n            sdict[c] += 1\n        for c in t:\n            sdict[c] -= 1\n        res = 0\n        for c in sdict.keys():\n            if sdict[c] < 0:\n                res += abs(sdict[c])\n        return res", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if len(s) == len(t) <= 50000 and s.islower() and t.islower():\n            if collections.Counter(s) == collections.Counter(t):\n                return 0\n            diff = collections.Counter(s) - collections.Counter(t)\n            return sum(diff.values())\n        else:\n            return 0\n        \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_count=[s.count(chr(i)) for i in range(97,123)]\n        t_count=[t.count(chr(i)) for i in range(97,123)]\n        diff=[t_count[i]-s_count[i] for i in range(26) if t_count[i]-s_count[i]>0]\n        sum=0\n        for i in range(len(diff)):\n            sum=sum+diff[i]\n        \n        return sum", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sCounts = collections.defaultdict(int)\n        tCounts = collections.defaultdict(int)\n        for c in s:\n            sCounts[c] += 1\n        for c in t:\n            tCounts[c] += 1\n        change = 0\n        for k in tCounts:\n            if k not in sCounts:\n                change += tCounts[k]\n            elif k in sCounts and sCounts[k] < tCounts[k]:\n                change += tCounts[k] - sCounts[k]\n\n        return change", "class Solution:\n    from collections import defaultdict\n    def minSteps(self, s: str, t: str) -> int:\n        counts = defaultdict(int)\n        \n        for c in s: counts[c] += 1\n        for c in t: counts[c] -= 1\n        \n        return sum(abs(counts[d]) for d in counts)//2", "from collections import defaultdict\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        h = defaultdict(int)\n        k = defaultdict(int)\n        for i in s:\n            h[i]+=1\n        for j in t:\n            k[j]+=1\n        ans = 0\n        for i in h:\n            ans+=h[i]-k[i] if h[i]-k[i]>0 else 0\n            # print(h[i],k[i],i)\n        return ans", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        counterS, counterT = Counter(s), Counter(t)\n        res = 0\n        for i in counterS:\n            res += max(0, counterS[i] - counterT[i])\n        return res", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        ds, dt = defaultdict(int), defaultdict(int)\n        \n        for c in list(s):\n            ds[c] += 1\n        for c in list(t):\n            dt[c] += 1\n        \n        res = 0\n        for c in dt:\n            res += max(0, dt[c] - ds[c])\n        return res", "from collections import defaultdict\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        freq = defaultdict(int)\n        for char in s:\n            freq[char] += 1\n        \n        for char in t:\n            if freq[char] > 0:\n                freq[char] -= 1\n        \n        return sum(freq.values())", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count1 = {}\n        count2 = {}\n        \n        for ch in s:\n            if ch not in count1:\n                count1[ch] = 0\n            count1[ch]+=1\n                \n        for ch in t:\n            if ch not in count2:\n                count2[ch] = 0\n            count2[ch]+=1        \n        \n        count = 0\n        for ch in count2:\n            if ch in count1:\n                if count1[ch]==count2[ch]:\n                    continue\n                else:\n                    # We have the case where count is greater\n                    if count2[ch]>count1[ch]:\n                        diff = count2[ch]-count1[ch]\n                        count+=diff\n                        continue\n                    # We have the case where count is lesser\n                    else:\n                        pass\n            else:\n                count+=count2[ch]\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        a={}\n        b={}\n        for i in s:\n            if i in a:\n                a[i] +=1\n            else:\n                a[i] = 1\n        for j in t:\n            if j in b:\n                b[j] +=1\n            else:\n                b[j] =1\n        v=0\n        for i in a:\n            if i in b and a[i] > b[i]:\n                v+=a[i]-b[i]\n            elif i not in b:\n                v += a[i]\n            else:\n                v +=0\n        return(v)", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_set = set(s)\n        steps = 0\n        for char in s_set:\n            s_charfreq = s.count(char)\n            t_charfreq = t.count(char)\n            if s_charfreq > t_charfreq:\n                steps += s_charfreq - t_charfreq\n        return steps", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d1={}\n        for i in s:\n            d1[i]=d1.get(i,0)+1\n        d2={}\n        for i in t:\n            d2[i]=d2.get(i,0)+1\n        c=0\n        for i in d1:\n            k=d1[i]-d2.get(i,0)\n            if k>0:\n                c+=abs(k)\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        help_dict = defaultdict(int)\n        res = 0\n        \n        for char in s:\n            help_dict[char] += 1\n        \n        for char in t:\n            if help_dict[char] > 0:\n                help_dict[char] -= 1\n            else:\n                res += 1\n                \n        return res", "from collections import defaultdict\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        mapper1 = defaultdict(int)\n        mapper2 = defaultdict(int)\n        \n        for i in range(len(s)):\n            mapper1[s[i]] += 1\n            mapper2[t[i]] += 1\n        \n        count = 0\n        \n        for char, val in mapper1.items():\n            diff = val - mapper2[char]\n            if diff > 0:\n                count += diff \n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        steps = 0\n        myDict = {}\n        \n        # create a dictionary with keys from s and how many times they occur\n        for c in s:\n            if c in myDict:\n                myDict[c] += 1\n            else:\n                myDict[c] = 1\n                \n        \n        for c in t:\n            # if the key exists we decrement the value that the key holds\n            if c in myDict:\n                myDict[c] -= 1\n                if myDict[c] == 0:\n                    del myDict[c]\n            # if the key does not exist then we increment steps by 1\n            else:\n                steps += 1\n                \n        return steps\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sFreq = dict()\n        for char in s:\n            try:\n                sFreq[char] += 1\n            except:\n                sFreq[char] = 1\n        ans = 0\n        for char in t:\n            if char in sFreq and sFreq[char] > 0:\n                sFreq[char] -= 1\n            else:\n                ans += 1\n        return ans\n        \n                \n", "import collections\n\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        counter = collections.Counter(s)\n        \n        for c in t:\n            # if c in counter:\n            counter[c] -= 1\n            \n        return sum([abs(x) for x in list(counter.values())])//2\n                \n        \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        count = 0\n        for ch2 in set(s):\n            n = s.count(ch2)\n            m = t.count(ch2)\n            if(ch2 in t):\n               if(m < n):\n                  count += n - m\n            else:\n                count += n\n        return count \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import defaultdict\n        s_f=defaultdict(int)\n        t_f=defaultdict(int)\n        c=0\n        \n        for x in s:\n            s_f[x]+=1\n        for y in t:\n            t_f[y]+=1\n        for z in s_f:\n            s_i=s_f[z]-t_f[z]\n            if s_i>0:\n                c+=s_i\n        return c", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_count = {}\n        t_count = {}\n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            if s_char in s_count:\n                s_count[s_char] += 1\n            else:\n                s_count[s_char] = 1\n            if t_char in t_count:\n                t_count[t_char] += 1\n            else:\n                t_count[t_char] = 1\n        \n        for c in t_count:\n            if c in s_count:\n                s_count[c] = abs(s_count[c] - t_count[c])\n            else:\n                s_count[c] = t_count[c]\n        \n        return sum(s_count.values()) // 2\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        # s -> {a: 1, b: 2}\n        # t -> {a: 2, b: 1}\n        \n        # s -> {f: 1, r: 1, i: 1, e: 1, n: 1, d: 1}\n        # t -> {}\n        \n        counter = {}\n        count = 0\n        \n        for c in s:\n            counter[c] = counter.get(c, 0) + 1\n\n        for c in t:\n            if c in counter and counter[c] > 0:\n                counter[c] -= 1\n            else:\n                count += 1\n        \n        return count\n", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d = Counter(s)\n        res = 0\n\n        for char in t:\n            if d[char] > 0:\n                d[char] -= 1\n            else:\n                res += 1\n\n        return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        from collections import Counter\n        counts = Counter(s)\n        res = 0\n        for c in t:\n            if counts[c] > 0:\n                counts[c] -= 1\n            else:\n                res += 1\n        return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sdict={}\n        for i in s:\n            if sdict.get(i) == None:\n                sdict[i]=1\n            else:\n                sdict[i]+=1\n        \n        for j in t:\n            if sdict.get(j):\n                sdict[j]-=1\n        \n        return sum(sdict.values())\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if s is None or t is None:\n            return -1\n\n        hashmap = dict()\n        count = 0\n\n        for char in s:\n            if char in hashmap:\n                hashmap[char] = 1 + hashmap[char]\n            else:\n                hashmap[char] = 1\n\n        for char in t:\n            if char in hashmap:\n                if hashmap[char] is not 0:\n                    hashmap[char] = hashmap[char] - 1\n\n        for key in hashmap:\n            count += hashmap[key]\n\n        return count\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        if s == t:\n            return 0\n        \n        s_d = collections.Counter(s)\n        \n        for c in t:\n            \n            if c in s_d and s_d[c] > 0:\n                s_d[c] -= 1\n                \n        return sum(s_d.values())", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        count = 0\n        for i in set(s):\n            if(s.count(i) > t.count(i)):\n                count += s.count(i)-t.count(i)\n        return count    ", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        ms = {}\n        for c in s:\n            old = ms.get(c, 0)\n            ms[c] = old + 1\n\n        count = 0\n        for c in t:\n            old = ms.get(c, 0)\n            if old == 0:\n                count += 1\n            else:\n                ms[c] -= 1\n        return count\n            \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        #sort both\n        #abb, aab\n        s_count = dict()\n        t_count = dict()\n        for i in range(len(s)):\n            s_count[s[i]] = s_count.get(s[i], 0) + 1\n        \n        for i in range(len(t)):\n            t_count[t[i]] = t_count.get(t[i], 0) + 1\n            \n        sim_count = 0\n        for key in list(s_count.keys()):\n            if t_count.get( key, 0):\n                #s_count:3, t_count:1 => get t_count\n                #s_count: 1, t_count: 3 => get s_count\n                if s_count[key] >= t_count[key]:\n                    sim_count += t_count[key]\n                else:\n                    sim_count += s_count[key]\n        return len(s) - sim_count\n            \n        #print(sorted(s_count))\n        #print(sorted(t_count))\n        #print(s_count)\n        #print(t_count)\n            \n        #s_sorted = sorted(s) #cannot use .sort() on str\n        #t_sorted = sorted(t)\n        #print(s_sorted)\n        #print(t_sorted)\n  #      ['c', 'd', 'e', 'l', 'o',       t']\n#['a',   'c',       'e', 'i', 'p', 'r', 't']\n#{'l': 1, 'e': 3, 't': 1, 'c': 1, 'o': 1, 'd': 1}\n#{'p': 1, 'r': 1, 'a': 1, 'c': 2, 't': 1, 'i': 1, 'e': 1}\n         \n         #sim: c1, e1, t1 => 8-3 = 5\n\n\n        \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        if s is None or t is None:\n          return -1\n\n        hashmap = dict()\n        count = 0\n\n        for char in s:\n          if char in hashmap:\n            hashmap[char] = 1 + hashmap[char]\n          else:\n            hashmap[char] = 1\n\n        for char in t:\n          if char in hashmap:\n            if hashmap[char] is not 0:\n                hashmap[char] = hashmap[char] - 1\n\n        for key in hashmap:\n            count += hashmap[key]\n\n        return count\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d={}\n        count=0\n\n        for i in range(len(s)):\n            if s[i] not in d:\n                d[s[i]]=1\n            else:\n                d[s[i]]+=1\n\n        for i in range(len(t)):\n            if t[i] in d and d[t[i]] > 0:\n                d[t[i]]-=1\n            else:\n                count+=1\n\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        all_set = set(list(s)) | set(list(t))\n        res = 0\n        for x in all_set:\n            res = res + abs(s.count(x) - t.count(x) )\n        res = res//2\n        return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        s_dict = {}\n        t_dict = {}\n        diff = 0\n        for i in s:\n            if(i in s_dict):\n                s_dict[i] += 1\n            else:\n                s_dict[i] = 1\n\n        for i in t:\n            if(i in t_dict):\n                t_dict[i] += 1\n            else:\n                t_dict[i] = 1\n\n        for i in s:\n            if(i in t_dict and t_dict[i] > 0):\n                t_dict[i] -= 1\n\n        for i in t_dict:\n            diff += t_dict[i]\n\n        return diff", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        D_s = {}\n        D_t = {}\n        for v in t:\n            D_t[v] = 0\n        for v in t:\n            D_t[v]+=1\n        for v in s:\n            D_s[v] = 0\n        for v in s:\n            D_s[v]+=1\n        S = 0\n        U = set()\n        for v in t:\n            if v not in D_s:\n                S+=1\n            else:\n                U.add(v)\n        for u in U:\n            S+=max(D_t[u]-D_s[u],0)\n        return S\n                \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sf = Counter(s)\n        tf = Counter(t)\n        return sum((tf - sf).values())\n        \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        min_steps = 0\n        count = collections.Counter(s)\n        for char in t:\n            if char not in count:\n                min_steps += 1\n            else:\n                count[char] -= 1\n                if count[char] == 0:\n                    del count[char]\n        return min_steps", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        # ok try the diff theory but ur tired so it's ok if rn it's wrong\n        changes_to_char = {}\n        \n        for i in range(len(s)):            \n            s_char_changes = changes_to_char.get(s[i], 0) + 1\n            changes_to_char[s[i]] = s_char_changes\n            \n            t_char_changes = changes_to_char.get(t[i], 0) - 1\n            changes_to_char[t[i]] = t_char_changes\n\n        total_dist = 0\n        for char, char_dist in changes_to_char.items():\n            if char_dist > 0:\n                total_dist += char_dist\n        \n        # OHH so you only want to outprint the positive values\n        # This is because the equilibrium will always be 0 -> i.e. additions of a char\n        # means removal of another existing char in s -> as such the number of additions\n        # will always equal the number of removals (or else u have a problem with math)\n        # But one addition/removal counts as 1 move - so just return number of chantes\n        return total_dist", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        sd = {}\n        td = {}\n        for c in s:\n            if sd.get(c):\n                sd[c] += 1\n            else:\n                sd[c] = 1\n                \n        count = 0\n        for c in t:\n            if sd.get(c) and sd[c] > 0:\n                sd[c] -= 1\n            else:\n                count += 1\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        count_t = collections.Counter(t)\n        \n        for i in range(len(s)):\n            \n            if s[i] in count_t:\n                count_t[s[i]] -= 1\n                if count_t[s[i]] == 0:\n                    del count_t[s[i]]\n        \n        #print(count_t)\n        ans = 0\n        \n        for key,value in count_t.items():\n            #print(value)\n            ans += value\n            \n        return ans", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        countChars = dict()\n        for i in s:\n            if i in countChars:\n                countChars[i][0] += 1\n            else:\n                countChars[i] = [1,0]\n        \n        ctr = 0\n        \n        for j in t:\n            if j in countChars:\n                countChars[j][1] += 1\n            else:\n                countChars[j] = [0,1]\n                \n        for i in countChars:\n            if countChars[i][0] > countChars[i][1]:\n                ctr += countChars[i][0] - countChars[i][1]\n        return ctr", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        count_s = Counter(s)\n        count = 0\n        \n        for char in t:\n            if count_s[char] > 0:\n                count_s[char]-=1\n            else:\n                count+=1\n        return count", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d1=Counter()\n        d2=Counter()\n        n=len(s)\n        cnt=0\n        for i,a in enumerate(s):\n            d1[a]=d1[a]+1\n        print(d1)\n        for j,b in enumerate(t):\n            d2[b]=d2[b]+1\n        print(d2)\n        for k1,v1 in list(d1.items()) :\n            if k1 in d2:\n                v2=d2[k1]\n                cnt=cnt+min(v1,v2)\n            \n        return n-cnt\n            \n        \n", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        x = dict(Counter(list(s)))\n        count = 0\n        for i in range(len(t)):\n            v = x.get(t[i],None)\n            if(v!=None and v>0):\n                x[t[i]]-=1\n            else:\n                count+=1\n        print(count)\n        return count", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        return sum(map(abs, (Counter(s) - Counter(t)).values() ))", "from collections import Counter\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        d1 = Counter(s)\n        d2 = Counter(t)\n        res = 0\n        if d1 == d2:\n            return 0\n\n\n        for i in s:\n            if i in d2:\n                d1[i] -= 1\n                d2[i] -= 1\n                if d1[i] == 0:\n                    del d1[i]\n                if d2[i] == 0:\n                    del d2[i]\n        \n            \n        for key,val in list(d2.items()):\n            res += val\n        return res\n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        dict1 = {}\n        dict2 = {}\n        \n        for i in s:\n            if i not in dict1:\n                dict1[i] = 1\n            else:\n                dict1[i] +=1\n        \n        for i in t:\n            if i not in dict2:\n                dict2[i] = 1\n            else:\n                dict2[i] +=1\n            \n        c_chars = 0\n        d_chars = 0\n        for i in dict1:\n            if i in dict2:\n                if dict2[i]>dict1[i]:\n                    c = dict2[i]-dict1[i]\n                else:\n                    c = dict1[i]-dict2[i]\n                c_chars +=c\n            else:\n                d_chars +=dict1[i]\n        \n        for i in dict2:\n            if i not in dict1:\n                d_chars+=dict2[i]\n        return (c_chars+d_chars)//2\n                    \n            \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        \n        if len(s) != len(t) : return -1 \n        \n        elif sorted(s) == sorted(t) : return 0 \n        \n        # find the intersection \n        I = set(s).intersection(t) \n        \n        # find frequency of I's in s and t and take minimum \n        freq_s = {}\n        \n        # find in s \n        for c in s:\n            if c in I:\n                freq_s[c] = freq_s.get(c,0) + 1 \n                \n        # find in t\n        freq_t = {}\n        for c in t:\n            if c in I:\n                freq_t[c] = freq_t.get(c, 0) + 1 \n                \n        \n        # now take the minima of both \n        # take the sums of min freqs\n        \n        I_sum = 0 \n        for c in list(freq_t.keys()):\n            freq_t[c] = min ( freq_s[c], freq_t[c]) \n            \n            I_sum += freq_t[c]\n            \n        return len(t) - I_sum \n            \n            \n            \n        \n                \n", "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        dic = collections.Counter(s)\n        for letter in t:\n            if letter in dic and dic[letter] > 0:\n                dic[letter] -= 1\n        return sum(dic.values())"]
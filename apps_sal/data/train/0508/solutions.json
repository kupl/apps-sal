["from heapq import heapify, heappush, heappop\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n    events = []\n    for i in range(N):\n        S, T, X = list(map(int, input().split()))\n        events.append((S-X-0.5, 1, X))\n        events.append((T-X-0.5, 0, X))\n    for i in range(Q):\n        D = int(input())\n        events.append((D, 2, i))\n\n    events.sort()\n\n    anss = [-1] * Q\n    PQ = []\n    isClosed = dict()\n    for tm, tp, x in events:\n        if tp == 0:\n            isClosed[x] = 0\n        elif tp == 1:\n            isClosed[x] = 1\n            heappush(PQ, x)\n        else:\n            while PQ:\n                if isClosed[PQ[0]] == 1:\n                    anss[x] = PQ[0]\n                    break\n                heappop(PQ)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "import heapq\nclass HeapDict:\n    def __init__(self):\n        self.h = []\n        self.d = {}\n\n    def insert(self,x):\n        if x not in self.d or self.d[x] == 0:\n            heapq.heappush(self.h, x)\n        self.d.setdefault(x,0)\n        self.d[x] += 1\n\n\n    def erase(self,x):\n        if x not in self.d or self.d[x] == 0:\n            return\n        else:\n            self.d[x] -= 1\n\n        while self.h:\n            if self.d[self.h[0]] == 0:\n                heapq.heappop(self.h)\n            else:\n                break\n\n\n    def get_min(self):\n        if not self.h:\n            return None\n        else:\n            return self.h[0]\n\n\n    def pop(self):\n        poped_val = self.h[0]\n        self.erase(poped_val)\n        return poped_val\n\n\n    def exist(self, x):\n        return (x in self.d and self.d[x] > 0)\n\n\n    def show_h(self):\n        elems = [v for v in self.h if self.d[v] > 0]\n        print(elems)\n\n\n    def show_d(self):\n        print(self.d)\n\n\n\ndef main():\n    n,q = map(int, input().split())\n    eventl = []\n\n    for _ in range(n):\n        s,t,x = map(int, input().split())\n        eventl.append((s-x, 'a-stop', x)) \n        eventl.append((t-x, 'b-start', x))\n\n    for i in range(q):\n        d = int(input())\n        eventl.append((d,'c-go', i))\n\n    eventl.sort()\n\n    ans = [0]*q\n    hd = HeapDict()\n    for e in eventl:\n        if e[1] == 'a-stop':\n            hd.insert(e[2])\n        elif e[1] == 'b-start':\n            hd.erase(e[2])\n        else:\n            min_x = hd.get_min()\n            if min_x is not None:\n                ans[e[2]] = min_x\n            else:\n                ans[e[2]] = -1\n\n    for a in ans:\n        print(a)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nfrom heapq import heappop, heappush\n\nN, Q = map(int, input().split())\nevent_list = []\nfor i in range(N):\n  s, t, x = map(int, input().split())\n  event_list.append([s-x, 1, x])\n  event_list.append([t-x, -1, x])\n\nfor i in range(Q):\n  event_list.append([int(input()), 2, 0])\n\nans = []\nevent_list.sort()\nx_set = set()\nx_list = []\nfor time, event, x in event_list:\n  if event == 1:\n    x_set.add(x)\n    heappush(x_list, x)\n  elif event == -1:\n    x_set.remove(x)\n  else:\n    while x_list and x_list[0] not in x_set:\n      heappop(x_list)\n    if x_list:\n      ans.append(x_list[0])\n    else:\n      ans.append(-1)\n\nprint(*ans, sep='\\n')\n", "import heapq\n\nclass BalancingTree:\n    def __init__(self):\n        self.p = []\n        self.q = []\n\n    def insert(self, x):\n        heapq.heappush(self.p, x)\n\n    def erase(self, x):\n        heapq.heappush(self.q, x)\n\n    def minimum(self):\n        while self.q and self.p[0] == self.q[0]:\n            heapq.heappop(self.p)\n            heapq.heappop(self.q)\n        return self.p[0] if self.p else -1\n\n\nn, q = list(map(int, input().split()))\nevents = []\nfor _ in range(n):\n    s, t, x = list(map(int, input().split()))\n    events.append((s-x, 1, x))\n    events.append((t-x, 0, x))\nfor _ in range(q):\n    d = int(input())\n    events.append((d, 2, 0))\n\nevents.sort()\nbt = BalancingTree()\nfor _, i, k in events:\n    if i == 1:\n        bt.insert(k)\n    elif i == 0:\n        bt.erase(k)\n    else:\n        print((bt.minimum()))\n", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, Q = MAP()\n\nevent = [None]*(2*N+Q)\nXl = [0]*N\nfor i in range(N):\n    S, T, X = MAP()\n    event[2*i] = (S-X, 1, X)\n    event[2*i+1] = (T-X, 0, X)\n    Xl[i] = X\n\nt = 2*N\nfor i in range(Q):\n    D = INT()\n    event[t+i] = (D, 2, 0)\n\n\nevent.sort()\np = []\nq = []\nfor t, c, x in event:\n    if c == 0:\n        heappush(q, x)\n    elif c == 1:\n        heappush(p, x)\n    else:\n        while q and p[0] == q[0]:\n            heappop(p)\n            heappop(q)\n        print((-1 if not p else p[0]))\n", "from heapq import heapify, heappush, heappop\nfrom collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n    events = []\n    for i in range(N):\n        S, T, X = list(map(int, input().split()))\n        events.append((S-X-0.5, 1, X))\n        events.append((T-X-0.5, 0, X))\n    for i in range(Q):\n        D = int(input())\n        events.append((D, 2, i))\n\n    events.sort()\n\n    anss = [-1] * Q\n    PQ = []\n    isClosed = defaultdict(int)\n    for tm, tp, x in events:\n        if tp == 0:\n            isClosed[x] = 0\n        elif tp == 1:\n            isClosed[x] = 1\n            heappush(PQ, x)\n        else:\n            while PQ:\n                if isClosed[PQ[0]] == 1:\n                    anss[x] = PQ[0]\n                    break\n                heappop(PQ)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "from bisect import bisect_left\ndef main():\n    N, Q = map(int, input().split())\n    W = [tuple(map(int, input().split())) for _ in range(N)]\n    W.sort(key=lambda x:x[2])\n    \n    D = [int(input()) for _ in range(Q)]\n    ans = [-1]*Q\n    skip = [-1]*Q\n    for s, t, x in W:\n        l = bisect_left(D, s-x)\n        r = bisect_left(D, t-x)\n        while l < r:\n            if skip[l] == -1:\n                ans[l] = x\n                skip[l] = r\n                l+=1\n            else:\n                l = skip[l]\n    for a in ans:\n        print(a)\nmain()  ", "from heapq import heappush, heappop\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\nN, Q = list(map(int, input().split()))\nSTX = [[int(x) for x in input().split()] for _ in range(N)]\nEVENT = []\nfor s, t, x in STX:\n    EVENT.append((s-x, 1, x))\n    EVENT.append((t-x, 0, x))\n\nfor i in range(Q):\n    d = int(input())\n    EVENT.append((d, 2, i))\n\nans = [-1] * Q\n\nEVENT.sort()\n\n\nSTOP = set()\nh = []\nfor t, op, x in EVENT:\n    if op == 2 and STOP:\n        while h and h[0] not in STOP:\n            heappop(h)\n        ans[x] = h[0]\n    elif op == 1:\n        STOP.add(x)\n        heappush(h, x)\n    elif op == 0:\n        STOP.remove(x)\n\nprint((\"\\n\".join(map(str, ans))))\n", "import sys\nimport heapq as hq\nfrom operator import itemgetter\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\ndef solve():\n    N, Q = map(int, rl().split())\n    event = []\n    for _ in range(N):\n        s, t, x = map(int, rl().split())\n        event.append((t - x, 0, x))\n        event.append((s - x, 1, x))\n    for _ in range(Q):\n        d = int(rl())\n        event.append((d, 2, -1))\n    event.sort(key=itemgetter(0, 1))\n    \n    pos_set = set()\n    pos_hq = []\n    ans = []\n    for _, com, pos in event:\n        if com == 0:\n            pos_set.remove(pos)\n        elif com == 1:\n            pos_set.add(pos)\n            hq.heappush(pos_hq, pos)\n        else:\n            while pos_hq:\n                if pos_hq[0] not in pos_set:\n                    hq.heappop(pos_hq)\n                else:\n                    break\n            ans.append(pos_hq[0] if pos_hq else -1)\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\nfrom heapq import heappush, heappop \n\nrunning = []\nevents = []\ndelete = set()\n\nn, q = map(int, input().split())\nfor _ in range(n):\n    s, t, x = map(int, input().split())\n    time = max(s - x, 0)\n    if t - x < 0:\n        continue\n    events.append((s - x, x, 1)) # \u8ffd\u52a0\u30a4\u30d9\u30f3\u30c8\n    events.append((t - x, x, 0)) # \u524a\u9664\u30a4\u30d9\u30f3\u30c8\nevents.sort()\nans = []\nidx = -1\nfor _ in range(q):\n    d = int(input())\n    if d >= events[-1][0]:\n        print(-1)\n        #ans.append(-1)\n        continue\n    while events[idx + 1][0] <= d:\n        idx += 1\n        if events[idx][2] == 1:\n            heappush(running, events[idx][1])\n            delete.discard(events[idx][1])\n        else:\n            delete.add(events[idx][1])\n    flag = 1\n    while running:\n        x = heappop(running)\n        if x not in delete:\n            heappush(running, x)\n            print(x)\n            #ans.append(x)\n            flag = 0\n            break\n    if flag:\n        print(-1)", "from bisect import bisect_left\n\ndef main():\n    ConstNum,PersonNum=map(int,input().split())\n\n    S=[]\n    T=[]\n    X=[]\n    for i in range(ConstNum):\n        s,t,x=map(int,input().split())\n        S.append(s)\n        T.append(t)\n        X.append(x)\n\n    DepartureTime=[]\n    for i in range(PersonNum):\n        d=int(input())\n        DepartureTime.append(d)\n\n    XST=zip(X,S,T)\n    XST=sorted(XST)\n\n    res=[-1]*PersonNum\n    stop=[-1]*PersonNum\n\n    for x,s,t in XST:\n        left_value=s-x\n        right_value=t-x\n\n        left_index=bisect_left(DepartureTime,left_value)\n        right_index=bisect_left(DepartureTime,right_value)\n\n        while left_index<right_index:\n            if stop[left_index]==-1:\n                res[left_index]=x\n                stop[left_index]=right_index\n                left_index+=1\n            else:\n                left_index=stop[left_index]\n\n    for i in range(PersonNum):\n        print(res[i])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom heapq import heappop, heappush\n\ninput = sys.stdin.readline\nN, Q = map(int, input().split())\nevent_list = []\nfor i in range(N):\n  s, t, x = map(int, input().split())\n  event_list.append([s-x, 1, x])\n  event_list.append([t-x, -1, x])\n\nfor i in range(Q):\n  event_list.append([int(input()), 2, 0])\n\nans = []\nevent_list.sort()\nx_set = set()\nx_list = []\nfor time, event, x in event_list:\n  if event == 1:\n    x_set.add(x)\n    heappush(x_list, x)\n  elif event == -1:\n    x_set.remove(x)\n  else:\n    while x_list and x_list[0] not in x_set:\n      heappop(x_list)\n    if x_list:\n      ans.append(x_list[0])\n    else:\n      ans.append(-1)\n\nprint(*ans, sep='\\n')", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n,q = LI()\n    stx = [LI() for _ in range(n)]\n    da = [I() for _ in range(q)]\n\n    q = []\n    for s,t,x in stx:\n        sx = s - x\n        tx = t - x - 1\n        heapq.heappush(q, (sx, x, tx))\n\n    t = []\n    cx = inf\n    ctx = inf\n    c = 0\n    while len(q):\n        sx, x, tx = heapq.heappop(q)\n        # print(\"x\", sx,x,tx)\n        # print(\"q\", q)\n        # print(\"t\", t)\n        if sx > ctx:\n            t.append((sx-1, cx))\n            cx = x\n            ctx = tx\n        elif cx > x:\n            if ctx > tx:\n                heapq.heappush(q, (tx+1, cx, ctx))\n            t.append((sx-1, cx))\n            cx = x\n            ctx = tx\n        elif tx > ctx:\n            heapq.heappush(q, (ctx+1, x, tx))\n\n    t.append((inf, inf))\n    # print(\"t\", t)\n\n    r = []\n    for d in da:\n        i = bisect.bisect_right(t, (d, -1))\n        # print(\"d\",d,i,t[i])\n        u = t[i][1]\n        if u == inf:\n            r.append(-1)\n        else:\n            r.append(u)\n\n    return JA(r, \"\\n\")\n\nprint(main())\n\n\n\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n\n    n, q = map(int, input().split())\n\n    V = []\n\n    for i in range(n):\n        s, t, x = map(int, input().split())\n        V.append((s-x, x, 1)) #1: insert\n        V.append((t-x, x, 0)) #0: delete\n\n    D = []\n    for i in range(q):\n        d = int(input())\n        V.append((d, i, 2)) #2: query\n\n    V.sort(key=lambda x:(x[0], x[2]))\n    se = set()\n    hq = []\n    import heapq\n    heapq.heapify(hq)\n    ans = [-1]*q\n    for t, v, p in V:\n        if p == 1:\n            se.add(v)\n            heapq.heappush(hq, v)\n        elif p == 0:\n            se.remove(v)\n        else:\n            while hq and hq[0] not in se:\n                heapq.heappop(hq)\n            if hq:\n                ans[v] = hq[0]\n\n    for i in range(q):\n        print(ans[i])\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nfrom heapq import *\ninput = sys.stdin.readline\n\ndef main():\n    n, q = map(int, input().split())\n    \n    key = []\n    for i in range(n):\n        s, t, x = map(int, input().split())\n        l, r = max(0, s-x), max(0, t-x)\n        key.append((l, -1, x))\n        key.append((r, 1, x))\n\n    key.sort()\n    judge = []\n    already = dict()\n    search = []\n    \n    for i in range(n*2):\n        s, j, x = key[i]\n        \n        if j == -1:\n            heappush(judge, x)\n        else:\n            if x in already:\n                already[x] += 1\n            else:\n                already[x] = 1\n        \n        if i == n*2-1 or key[i][0] != key[i+1][0]:\n            while judge:\n                if judge[0] in already and already[judge[0]] > 0:\n                    already[judge[0]] -= 1\n                    heappop(judge)\n                else:\n                    break\n            if judge:\n                search.append((s, judge[0]))\n            else:\n                search.append((s, -1))\n\n    size = len(search)\n    index = 0\n    answer = []\n    for i in range(q):\n        d = int(input())\n        while index < size-1:\n            if search[index+1][0] <= d:\n                index += 1\n            else:\n                break\n        print(search[index][1])\n\n    \ndef __starting_point():\n    main()\n__starting_point()", "from heapq import heappush, heappop\n\nN, Q = list(map(int, input().split()))\nl, q = [], []\nu = set()\n\nfor _ in range(N):\n    S, T, X = list(map(int, input().split()))\n    l.append((S-X, 1, X))\n    l.append((T-X, 0, X))\n\nfor i in range(Q):\n    l.append((int(input()), 2, i))\n\nl.sort()\n\nfor _, m, x in l:\n    if m==0:\n        u.remove(x)\n    elif m==1:\n        heappush(q, x)\n        u.add(x)\n    else:\n        while q:\n            if q[0] not in u:\n                heappop(q)\n            else:\n                break\n        print((q[0] if q else -1))\n", "import sys\ninput = sys.stdin.readline\n\nimport heapq\nN, Q = (int(i) for i in input().split())\nL = [0] * (2 * N + Q)\nfor i in range(N):\n    S, T, X = (int(i) for i in input().split())\n    L[2 * i] = (S-X, 1, X)\n    L[2 * i + 1] = (T-X, -1, X)\nfor i in range(Q):\n    D = int(input())\n    L[2 * N + i] = (D, 2, 0)\nL.sort()\n\nXs = set([])\nXH = []\nheapq.heapify(XH)\nfor t, f, X in L:\n    if f == 1:\n        Xs.add(X)\n        heapq.heappush(XH, X)\n    elif  f == -1:\n        Xs.remove(X)\n    else:\n        if Xs:\n            while XH[0] not in Xs:\n                X = heapq.heappop(XH)\n            print(XH[0])\n        else:\n            print(\"-1\")", "# E - Roadwork\nfrom bisect import bisect_left\nfrom operator import itemgetter\n\n\ndef main():\n    N, Q, *STXD = list(map(int, open(0).read().split()))\n    D = STXD[3 * N :]\n    ans = [-1] * Q\n    road = [-1] * Q  # (road[i] = x) := if -1: open / else: closed until x\n    for s, t, x in sorted(zip(*[iter(STXD[: 3 * N])] * 3), key=itemgetter(2)):\n        l, r = bisect_left(D, s - x), bisect_left(D, t - x)\n        while l < r:\n            if road[l] == -1:\n                ans[l] = x\n                road[l] = r\n                l += 1\n            else:\n                l = road[l]\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left\nimport sys\ninput = sys.stdin.readline\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\ndef main():\n    N, Q = list(map(int, input().split()))\n    kouji = [list(map(int, input().split())) for _ in range(N)]\n    D = [int(input()) for _ in range(Q)]\n    ans = [-1]*Q\n    nxt = [i+1 for i in range(Q)]\n    uf = UnionFind(Q)\n    kouji.sort(key=lambda x: x[2])\n    for i in range(N):\n        S, T, X = kouji[i]\n        L = S-X\n        R = T-X-1\n        L_idx = bisect_left(D, L)\n        R_idx = bisect_left(D, R+1)\n        p = L_idx\n        while p < R_idx:\n            if ans[p] == -1:\n                ans[p] = X\n                uf.union(L_idx, p)\n                nxt[p] = R_idx\n                p += 1\n            else:\n                par = uf.find(p)\n                p = nxt[par]\n                uf.union(L_idx, par)\n                par = uf.find(par)\n                if nxt[par] < R_idx:\n                    nxt[par] = R_idx\n                if nxt[par] < p:\n                    nxt[par] = p\n    for i in range(Q):\n        print((ans[i]))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappush, heappop\nfrom operator import itemgetter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, Q = map(int, readline().split())\n    work = [0] * N\n    for i in range(N):\n        s, t, x = map(int, readline().split())\n        work[i] = (x, s - x, t - x)\n    query = list(map(int, read().split()))\n\n    work.sort(key=itemgetter(1))\n    hq = []\n    ans = [0] * Q\n\n    idx = 0\n    for i, d in enumerate(query):\n        while idx < N and work[idx][1] <= d:\n            heappush(hq, work[idx])\n            idx += 1\n        while hq and hq[0][2] <= d:\n            heappop(hq)\n        if not hq:\n            ans[i] = -1\n        else:\n            ans[i] = hq[0][0]\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nINF = 1<<31\nfrom heapq import heapify,heappop,heappush\nfrom collections import defaultdict\n\nN,Q = map(int,input().split())\nevent = []\nfor _ in range(N):\n    s,t,x = map(int,input().split())\n    event.append((s - x,-1,x))\n    event.append((t - x,0,x))\nfor i in range(Q):\n    d = int(input())\n    event.append((d,1,i))\n\nq = []\nans = [-1] * Q\nevent.sort()\npush = defaultdict(int)\npop = defaultdict(int)\nfor i in range(2*N + Q):\n    t,typ,x = event[i]\n    if typ == -1:\n        heappush(q,x)\n        push[x] += 1\n    elif typ == 0:\n        pop[x] += 1\n    else:\n        p = -1\n        if q:\n            p = q[0]\n        while p != -1 and push[p] - pop[p] == 0:\n            heappop(q)\n            if q:\n                p = q[0]\n            else:\n                p = -1\n                break\n        ans[x] = p\nprint('\\n'.join(map(str,ans)))", "def main():\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n\n    from heapq import heappush, heappop \n\n    running = []\n    events = []\n    delete = set()\n\n    n, q = list(map(int, input().split()))\n    for _ in range(n):\n        s, t, x = list(map(int, input().split()))\n        events.append((s - x, x, 1)) # \u8ffd\u52a0\u30a4\u30d9\u30f3\u30c8\n        events.append((t - x, x, 0)) # \u524a\u9664\u30a4\u30d9\u30f3\u30c8\n    for _ in range(q):\n        d = int(input())\n        events.append((d, 10**10, 2))\n    events.sort()\n    for i in range(len(events)):\n        temp = events[i]\n        if temp[-1] == 1:\n            heappush(running, temp[1])\n            delete.discard(temp[1])\n        elif temp[-1] == 0:\n            delete.add(temp[1])\n        else:\n            flag = 1\n            while running:\n                p = heappop(running)\n                if p not in delete:\n                    flag = 0\n                    heappush(running, p)\n                    print(p)\n                    break\n            if flag:\n                print((-1))\ndef __starting_point():\n    main()\n\n\n\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nn,q = list(map(int,input().split()))\nA = [list(map(int,input().split())) for i in range(n)]\nD = [int(input()) for i in range(q)]\n\nE = []\nF = {}\nfor i in range(n):\n    s = A[i][0]\n    t = A[i][1]\n    x = A[i][2]\n    F[x] = 0\n    E.append((s-x, x, 1))\n    E.append((t-x, x, -1))\nE.append((10**10, 10**10, 1))\n\nE.sort()\n\n# print(E)\n\nfrom heapq import heappush, heappop\nQ = []\n\nj = 0\nfor i in range(q):\n    # print(F,j)\n    while E[j][0] <= D[i]:\n        if E[j][2] == 1:\n            F[E[j][1]] += 1\n            heappush(Q, E[j][1])\n        else:\n            F[E[j][1]] -= 1\n        j += 1\n    \n    while len(Q) > 0 and F[Q[0]] == 0:\n        _ = heappop(Q)\n    if len(Q) == 0:\n        print((-1))\n    else:\n        print((Q[0]))\n", "import sys\nfrom heapq import heappush, heappop\nfrom operator import itemgetter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, Q = map(int, readline().split())\n    work = [0] * N\n    for i in range(N):\n        s, t, x = map(int, readline().split())\n        work[i] = (x, s - x, t - x)\n    query = list(map(int, read().split()))\n\n    work.sort(key=itemgetter(1), reverse=True)\n    hq = []\n    ans = [0] * Q\n\n    for i, d in enumerate(query):\n        while work and work[-1][1] <= d:\n            heappush(hq, work[-1])\n            work.pop()\n        while hq and hq[0][2] <= d:\n            heappop(hq)\n        if not hq:\n            ans[i] = -1\n        else:\n            ans[i] = hq[0][0]\n\n    print(*ans, sep='\\n')\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappush, heappop\n\nN, Q = list(map(int, input().split()))\nl = []\nans = [0]*Q\nused = set()\nq = []\n\nfor i in range(N):\n    S, T, X = list(map(int, input().split()))\n    l.append((S-X, 1, X))\n    l.append((T-X, 0, X))\n\nfor i in range(Q):\n    v = int(input())\n    l.append((v, 2, i))\n\nl.sort()\n\nfor pos, m, x in l:\n    if m==0:\n        used.remove(x)\n    elif m==1:\n        heappush(q, x)\n        used.add(x)\n    else:\n        while q:\n            if q[0] not in used:\n                heappop(q)\n            else:\n                break\n        ans[x] = q[0] if q else -1\n\nfor i in range(Q):\n    print((ans[i]))\n", "import bisect\nN,Q=map(int,input().split())\nroad=[]\npos=[]\nfor _ in range(N):\n    s,t,x=map(int,input().split())\n    road.append((s-x,t-x,x))\nfor _ in range(Q):\n    pos.append(int(input()))\nroad.sort(key=lambda x:x[2])\nans=[-1]*Q\nischecked=[-1]*Q\nfor s,t,x in road:\n    l=bisect.bisect_left(pos,s)\n    r=bisect.bisect_left(pos,t)\n    while l<r:\n        if ischecked[l]==-1:\n            ischecked[l]=r\n            ans[l]=x\n            l+=1\n        else:\n            l=ischecked[l]\nfor i in range(Q):\n    print(ans[i])", "from bisect import bisect_left\n\nn, q = map(int, input().split())\nstx = [list(map(int, input().split())) for _ in range(n)]\nd = [int(input()) for _ in range(q)]\n\nINF = 10 ** 9 + 1\n\nstx.sort(key=lambda x: x[2])\n\nnxt = [-1] * q\nans = [-1] * q\n\nfor s, t, x in stx:\n    l = bisect_left(d, s - x)\n    r = bisect_left(d, t - x)\n\n    while l < r:\n        if nxt[l] == -1:\n            ans[l] = x\n            nxt[l] = r\n            l += 1\n        else:\n            l = nxt[l]\n\nprint(*ans, sep=\"\\n\")\n", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, Q = lr()\nSTX = [tuple(lr()) for _ in range(N)]\nevent = []\nfor s, t, x in STX:\n    event.append((s-x, 0, x))\n    event.append((t-x, -1, x))\n\nfor i in range(Q):\n    d = ir()\n    event.append((d, 1, i))\n\nevent.sort()\nanswer = [-1] * Q\ncur = set()\nflag = False\nINF = 10 ** 10\nmin_x = INF\nfor a, b, c in event:\n    if b == 0:\n        cur.add(c)\n        if c < min_x:\n            min_x = c\n            flag = True\n    elif b == -1:\n        cur.remove(c)\n        if min_x == c:\n            flag = False\n    elif b == 1:\n        if cur:\n            if not flag:\n                min_x = min(cur)\n                flag = True\n            answer[c] = min_x\n\nprint(('\\n'.join(map(str, answer))))\n# 19\n", "# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\ninput = sys.stdin.readline\n\nsys.setrecursionlimit(100000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, Q, STX, D):\n    E = []\n    for i, (s, t, x) in enumerate(STX):\n        E.append((s-x, 1, x, i))\n        E.append((t-x, -1, x, i))\n    E.sort(reverse=True)\n\n    q = []\n    done = set()\n    ans = [-1] * Q\n    for j, d in enumerate(D):\n        while E and E[-1][0] <= d:\n            t, e, x, i = E.pop()\n            if e == 1:\n                heapq.heappush(q, (x, i))\n            else:\n                done.add((x, i))\n\n        while q and q[0] in done:\n            done.remove(heapq.heappop(q))\n\n        if q:\n            ans[j] = q[0][0]\n\n    for i in range(Q):\n        print(ans[i])\n\n\ndef main():\n    N, Q = read_int_n()\n    STX = list(read_int_n() for _ in range(N))\n    D = list(read_int() for _ in range(Q))\n    (slv(N, Q, STX, D))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# E - Roadwork\n# https://atcoder.jp/contests/abc128/tasks/abc128_e\n\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\n\nn, q = list(map(int,input().split()))\ntask = []\nfor _ in range(n): \n  s, t, x = list(map(int, input().split()))\n  task.append((t - x, 0, x)) \n  task.append((s - x, 1, x)) \n\nfor i in range(q):\n  d = int(input())\n  task.append((d, 2, i)) \n\nanswer = [-1] * q\n\ntask.sort()\n\nse = set()\nse_hp = []\n\nfor a, b, c in task:\n  if b == 0:\n    se.remove(c)\n  elif b == 1:\n    se.add(c)\n    heappush(se_hp, c)\n  else: # b == 2\n    while se_hp and se_hp[0] not in se:\n      heappop(se_hp)\n    answer[c] = se_hp[0] if se_hp else -1\n\nprint(('\\n'.join(map(str, answer))))\n", "from heapq import heappush, heappop\nfrom operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass PseudoSet():\n    def __init__(self):\n        self.s = []  # set\n        self.e = []  # erase candidate\n\n    def insert(self, x):\n        heappush(self.s, x)\n\n    def erase(self, x):\n        heappush(self.e, x)\n\n    def get_min(self):\n        while self.e and self.e[0] == self.s[0]:\n            _ = heappop(self.s)\n            _ = heappop(self.e)\n        return self.s[0] if len(self.s) > 0 else None\n\n\nn, q = map(int, input().split())\nstx = []\nevents = []\nfor i in range(n):\n    s, t, x = map(int, input().split())\n    stx.append((s, t, x))\n    events.append((s - x, +1, i))\n    events.append((t - x, -1, i))\nfor i in range(q):\n    d = int(input())\n    events.append((d, 2, i))\n\nans = [-1] * q\nevents.sort(key=itemgetter(0, 1))\n# print(events)\nps = PseudoSet()\nfor c, t, i in events:\n    if t == 1:\n        ps.insert(stx[i][2])\n    elif t == -1:\n        ps.erase(stx[i][2])\n    else:\n        # t == 0\n        m = ps.get_min()\n        if m is not None:\n            ans[i] = m\n\nprint(*ans, sep='\\n')\n", "import bisect\nn,q = list(map(int,input().split()))\nl = [list(map(int,input().split())) for i in range(n)]\nl = sorted(l,key = lambda x: x[2])\nd = [int(input()) for i in range(q)]\n\nans = [-1]*q\nskip = [-1]*q\nfor s,t,x in l:\n    le = bisect.bisect_left(d,s-x)\n    ri = bisect.bisect_left(d,t-x)\n    while le < ri:\n        if skip[le] == -1:\n            ans[le] = x\n            skip[le] = ri\n            le += 1\n        else:\n            le = skip[le]\n\nfor i in ans:\n    print(i)\n", "from heapq import heappush, heappop\nfrom operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass PseudoSet():\n    def __init__(self):\n        self.s = []  # set\n        self.e = []  # erase candidate\n\n    def insert(self, x):\n        heappush(self.s, x)\n\n    def erase(self, x):\n        heappush(self.e, x)\n\n    def get_min(self):\n        while self.e and self.e[0] == self.s[0]:\n            _ = heappop(self.s)\n            _ = heappop(self.e)\n        return self.s[0] if len(self.s) > 0 else None\n\n\nn, q = map(int, input().split())\nevents = []\nfor i in range(n):\n    s, t, x = map(int, input().split())\n    events.append((s - x, +1, x))\n    events.append((t - x, -1, x))\nfor i in range(q):\n    d = int(input())\n    events.append((d, 2, i))\n\nans = [-1] * q\nevents.sort(key=itemgetter(0, 1))\n# print(events)\nps = PseudoSet()\nfor c, t, z in events:\n    if t == 1:\n        ps.insert(z)\n    elif t == -1:\n        ps.erase(z)\n    else:\n        # t == 2\n        m = ps.get_min()\n        if m is not None:\n            ans[z] = m\n\nprint(*ans, sep='\\n')\n", "import sys\nfrom heapq import *\ninput = sys.stdin.readline\n\ndef main():\n    n, q = list(map(int, input().split()))\n    \n    key = []\n    for i in range(n):\n        s, t, x = list(map(int, input().split()))\n        l, r = max(0, s-x), max(0, t-x)\n        key.append((l, 1, x))\n        key.append((r, -1, x))\n    \n    for i in range(q):\n        d = int(input())\n        key.append((d, 2))\n\n    key.sort()\n    judge = []\n    already = dict()\n    \n    for i in range(2*n+q):\n        k = key[i]\n        if k[1] == -1:\n            if k[2] in already:\n                already[k[2]] += 1\n            else:\n                already[k[2]] = 1\n        elif k[1] == 1:\n            heappush(judge, k[2])\n        else:\n            while judge:\n                if judge[0] in already and already[judge[0]] > 0:\n                    already[judge[0]] -= 1\n                    heappop(judge)\n                else:\n                    break\n            if judge:\n                print((judge[0]))\n            else:\n                print((-1))\n    \n\n    \ndef __starting_point():\n    main()\n\n\n__starting_point()", "import heapq\nimport sys\ninput=sys.stdin.readline\nN,Q=map(int,input().split())\n\nevent_list=[]\nfor i in range(N):\n  S,T,X=map(int,input().split())\n  event_list.append((S-X-0.5,1,X))\n  event_list.append((T-X-0.5,-1,X))\n  \ndlist=[]\nfor i in range(Q):\n  D=int(input())\n  event_list.append((D,0,X))  \n  dlist.append(D)\nevent_list.sort()\n#print(event_list)\n\nanswer_dic={}\nstop_set=set()\nmin_set=float(\"inf\")\nfor t,f,x in event_list:\n  if f==1:\n    stop_set.add(x)\n    if x<min_set:\n      min_set=x\n  elif f==-1:\n    stop_set.remove(x)\n    if x==min_set:\n      if len(stop_set)>0:\n        min_set=min(stop_set)\n      else:\n        min_set=float(\"inf\")\n  else:\n    if len(stop_set)>0:\n      answer_dic[t]=min_set\n    else:\n      answer_dic[t]=-1\n#print(answer_dic)\n\nfor d in dlist:\n  print(answer_dic[d])", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, Q = lr()\nSTX = [tuple(lr()) for _ in range(N)]\nSTX.sort(key=lambda x: x[2], reverse=True)\nevent = []\nfor s, t, x in STX:\n    event.append((s-x, 0, x))\n    event.append((t-x, -1, x))\n\nfor i in range(Q):\n    d = ir()\n    event.append((d, 1, i))\n\nevent.sort()\nanswer = [-1] * Q\ncur = set()\nflag = False\nINF = 10 ** 10\nmin_x = INF\nfor a, b, c in event:\n    if b == 0:\n        cur.add(c)\n        if c < min_x:\n            min_x = c\n            flag = True\n    elif b == -1:\n        cur.remove(c)\n        if min_x == c:\n            flag = False\n    elif b == 1:\n        if cur:\n            if not flag:\n                min_x = min(cur)\n                flag = True\n            answer[c] = min_x\n\nprint(('\\n'.join(map(str, answer))))\n# 19\n", "import sys\ninput = sys.stdin.readline\nfrom bisect import bisect_left\nN, Q = map(int, input().split())\nW = [tuple(map(int, input().split())) for _ in range(N)]\nW.sort(key=lambda x:x[2])\nD = [int(input()) for _ in range(Q)]\nans = [-1]*Q\nskip = [-1]*Q\nfor s, t, x in W:\n    l = bisect_left(D, s-x)\n    r = bisect_left(D, t-x)\n    while l < r:\n        if skip[l] == -1:\n            ans[l] = x\n            skip[l] = r\n            l += 1\n        else:\n            l = skip[l]\nprint(*ans, sep='\\n')", "import sys\ninput=sys.stdin.readline\nimport heapq\nn,q=map(int,input().split())\nl=[list(map(int,input().split())) for i in range(n)]\nL1=[]\nfor i in range(n):\n  L1.append((l[i][0]-l[i][2],1,l[i][2]))\n  L1.append((l[i][1]-l[i][2],-1,l[i][2]))\nfor i in range(q):\n  L1.append((int(input()),2,0))\nL1.sort()\nL2=[]\nheapq.heapify(L2)\nL3=[]\nL3=set(L3)\nfor i in range(len(L1)):\n  if L1[i][1]==1:\n    heapq.heappush(L2,L1[i][2])\n    L3.add(L1[i][2])\n  elif L1[i][1]==-1:\n    L3.remove(L1[i][2])\n  else:\n    while L2 and L2[0] not in L3:\n      heapq.heappop(L2)\n    if L2:\n      print(L2[0])\n    else:\n      print(-1)", "import sys\ninput=sys.stdin.readline\nfrom bisect import bisect_left\nn,q=list(map(int,input().split()))\nstop=[]\nfor i in range(n):\n\ts,t,x=list(map(int,input().split()))\n\tstop.append((s,t,x))\nstop.sort(key=lambda x:x[2])\nd=[int(input())for i in range(q)]\nR=[-1]*q\nans=[-1]*q\nfor s,t,x in stop:\n\t#l\u304b\u3089r\u306b\u3042\u308b\u533a\u9593\u306eans\u3092x\u306b\u66f4\u65b0\u3057\u305f\u3044\n\tl=bisect_left(d,s-x)\n\tr=bisect_left(d,t-x)\n\twhile l<r:\n\t\tif R[l]==-1:#\u6700\u5de6\u304c\u307e\u3060\u78ba\u5b9a\u3057\u3066\u3044\u306a\u3044\u5834\u5408\n\t\t\tans[l]=x\n\t\t\tR[l]=r\n\t\t\tl+=1\n\t\telse:\n\t\t\tl=R[l]#\u78ba\u5b9a\u3057\u3066\u3044\u308b\u3068\u3053\u308d\u3092\u98db\u3070\u3059\nfor x in ans:\n\tprint(x)\n", "from heapq import heappush, heappop\nN,Q,*L = map(int, open(0).read().split())\nD = L[3*N:]\nls = []\nfor i in range(N):\n  s,t,x = L[3*i],L[3*i+1],L[3*i+2]\n  ls.append((s-x,1,x))\n  ls.append((t-x,0,x))\nfor i,d in enumerate(D):\n  ls.append((d,2,i))\nls.sort()\nans = [0]*Q\nS = set()\nhq = []\nfor a,b,c in ls:\n  if b==0:\n    S.remove(c)\n  elif b==1:\n    S.add(c)\n    heappush(hq,c)\n  else:\n    while hq and hq[0] not in S:\n      heappop(hq)\n    ans[c] = hq[0] if hq else -1\nprint('\\n'.join(map(str,ans)))", "import math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1 for i in range(self.n)]\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.par[p] += self.par[q]\n        self.par[q] = p\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nimport bisect\nn, q = map(int, input().split())\nstx = [list(map(int, input().split())) for i in range(n)]\nd = [int(input()) for i in range(q)]\nstx.sort(key=lambda x: x[2])\nans = [-1 for i in range(q)]\nlis = [-1 for i in range(q)]\nfor s, t, x in stx:\n    l = bisect.bisect_left(d, s - x)\n    r = bisect.bisect_left(d, t - x)\n    while l < r:\n        if lis[l] == -1:\n            ans[l] = x\n            lis[l] = r\n            l += 1\n        else:\n            l = lis[l]\nprint(*ans, sep=\"\\n\")", "from heapq import heappush, heappop\nN,Q,*L = map(int, open(0).read().split())\nX = L[:3*N]\nD = L[3*N:]\nls = []\nfor s,t,x in zip(*[iter(X)]*3):\n  ls.append((s-x,1,x))\n  ls.append((t-x,0,x))\nfor i,d in enumerate(D):\n  ls.append((d,2,i))\nls.sort()\nans = [0]*Q\nS = set()\nhq = []\nfor a,b,c in ls:\n  if b==0:\n    S.remove(c)\n  elif b==1:\n    S.add(c)\n    heappush(hq,c)\n  else:\n    while hq and hq[0] not in S:\n      heappop(hq)\n    ans[c] = hq[0] if hq else -1\nprint('\\n'.join(map(str,ans)))", "#D in [S_i-X_i,T_i-X_i) \u2192 Xi\u3067\u6b62\u307e\u308b\nimport sys\ninput = sys.stdin.readline\nfrom heapq import heappop,heappush\nfrom collections import defaultdict\n\nN,Q = list(map(int,input().split()))\ntask = []\n\nSTX = [[int(x) for x in input().split()] for _ in range(N)]\nfor s,t,x in STX:\n  task.append((t-x,0,x)) # x\u3067\u6b62\u307e\u3089\u306a\u304f\u306a\u308b\n  task.append((s-x,1,x)) # x\u3067\u6b62\u307e\u308b\n\nfor i in range(Q):\n  d = int(input())\n  task.append((d,2,i)) # \u6b62\u307e\u308b\u4f4d\u7f6e\u3092\u7b54\u3048\u308b\nanswer = [-1]*Q\n\ntask.sort()\n\n# \u5f15\u3063\u304b\u304b\u3063\u3066\u308b\u5834\u6240\u306e\u7ba1\u7406\nse = set()\nse_hp = [] # heap\u3067\u6700\u5c0f\u5024\u3092\u5148\u982d\u306b\u4fdd\u3064\n\n# \u5c0f\u3055\u3044\u6642\u523b\u304b\u3089\u9806\u306b\u898b\u3066\u3044\u304f\nfor a,b,c in task:\n  if not b: # b == 0\n    se.remove(c)\n  elif b&1: # b == 1\n    se.add(c)\n    heappush(se_hp,c)\n  else: # b == 2\n    while se_hp and se_hp[0] not in se:\n      heappop(se_hp)\n    answer[c] = se_hp[0] if se_hp else -1\n\nprint(('\\n'.join(map(str,answer))))\n", "import bisect\nn, q = map(int, input().split())\nSTX = []\nfor i in range(n):\n    s, t, x = map(int, input().split())\n    STX.append((s, t, x))\nSTX.sort(key=lambda _: _[2])\nS, T, X = [], [], []\nfor stx in STX:\n    s, t, x = stx\n    S.append(s)\n    T.append(t)\n    X.append(x)\nD = [int(input()) for j in range(q)]\nA = [-1 for j in range(q)]\nB = [-1 for j in range(q)]\nfor i in range(n):\n    l = bisect.bisect_left(D, S[i]-X[i])\n    r = bisect.bisect_left(D, T[i]-X[i])\n    while l < r:\n        if B[l] == -1:\n            A[l] = X[i]\n            B[l] = r\n            l += 1\n        else:\n            l = B[l]\nprint(*A, sep='\\n')\n", "def main():\n    N, Q = map(int, input().split())\n    tl = [] # \u30a4\u30d9\u30f3\u30c8\u30bf\u30a4\u30e0\u30e9\u30a4\u30f3\n    for _ in range(N):\n        S, T, X = map(int, input().split())\n        tl.append((S-X, 1, X)) # insert\n        tl.append((T-X, 0, X)) # erase\n    for _ in range(Q):\n        D = int(input())\n        tl.append((D, 2, 0)) # min\n    tl.sort()\n    working = set() # \u5de5\u4e8b\u4e2d\n    wcur = 0 # \u5de5\u4e8b\u4e2d\u306e\u533a\u57df\u306e\u6570\n    curmin = -1\n    flag = False\n    for t, c, x in tl:\n        if c == 0: # erase\n            wcur -= 1\n            working.remove(x)\n            if x <= curmin:\n                curmin = x\n                flag = True\n        elif c == 1: # insert\n            wcur += 1\n            working.add(x)\n            if curmin < 0 or curmin >= x:\n                curmin = x\n                flag = False\n        else: # min\n            if wcur == 0:\n                curmin = -1\n                flag = False\n            elif flag:\n                curmin = min(working)\n                flag = False\n            print(curmin)\n    return\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput=sys.stdin.readline\ndef N(): return int(input())\ndef NM():return map(int,input().split())\ndef L():return list(NM())\ndef LN(n):return [N() for i in range(n)]\ndef LL(n):return [L() for i in range(n)]\ndef YesNo(x):print(\"Yes\")if x==True else print(\"No\")\nn,q=NM()\nl=[]\nfor i in range(n):\n    s,t,x=NM()\n    l.append((s-x,t-x,x))\nl.sort()\nINF=float(\"inf\")\nl+=[(INF,INF,INF)]\nd=LN(q)\nq=[]\nfrom heapq import heappush,heappop\nj=0\nfor i in d:\n    while l[j][0]<=i:\n        s,t,x=l[j]\n        heappush(q,(x,t))\n        j+=1\n    if len(q)==0:\n        print(-1)\n    else:\n        while q:\n            x,t=heappop(q)\n            if t>i:\n                heappush(q,(x,t))\n                print(x)\n                break\n        else:\n            print(-1)", "import heapq\nimport sys\ninput=sys.stdin.readline\nN,Q=map(int,input().split())\n\nevent_list=[]\nfor i in range(N):\n  S,T,X=map(int,input().split())\n  event_list.append((S-X-0.5,1,X))\n  event_list.append((T-X-0.5,-1,X))\n  \ndlist=[]\nfor i in range(Q):\n  D=int(input())\n  event_list.append((D,0,X))  \n  dlist.append(D)\nevent_list.sort()\n#print(event_list)\n\nanswer_dic={}\nstop_set=set()\nhq=[]\nfor t,f,x in event_list:\n  if f==1:\n    stop_set.add(x)\n    heapq.heappush(hq,x)\n  elif f==-1:\n    stop_set.remove(x)\n  else:\n    if len(stop_set)>0:\n      while(True):\n        if hq[0] in stop_set:\n          answer_dic[t]=hq[0]\n          break\n        else:\n          heapq.heappop(hq)\n    else:\n      answer_dic[t]=-1\n#print(answer_dic)\n\nfor d in dlist:\n  print(answer_dic[d])", "from heapq import heappop,heappush\n\nN,Q=map(int,input().split())\n\n\nevent=[]\nq=[]\nfor _ in range(N):\n    S,T,X=map(int,input().split())\n    event.append([S-X,1,X])\n    event.append([T-X,-1,X])\n\nfor i in range(Q):\n    event.append([int(input()),2,i])\n\nstop_set=set()\nevent.sort()\nq=[]\n\nfor pos,m,x in event:\n    if m==-1:\n        stop_set.remove(x)\n        \n    elif m==1:\n        #heappush\u3059\u308b\u6642\u70b9\u3067q\u306f\u30bd\u30fc\u30c8\u3055\u308c\u3066\u3044\u308b\n        heappush(q,x)\n        stop_set.add(x)\n    \n    else:\n        #\u3053\u306e\u6642\u70b9\u3067\u306estop_set\u306f\u3001i\u756a\u76ee\u306e\u4eba\u304c\u906d\u9047\u3059\u308b\u901a\u884c\u6b62\u3081\u306e\u5ea7\u6a19\n        #\u3053\u306e\u6642\u70b9\u3067\u306eq\u306f\u4eca\u307e\u3067stop\u306b\u306a\u3063\u305f\u5ea7\u6a19\n        while q:\n            #q\u306f\u30bd\u30fc\u30c8\u6e08\u306a\u306e\u3067\u3001q[0]\u306f\u6700\u5c0f\u5024\u3000\u305d\u308c\u304cstop_set\u304b\u3089\u5916\u308c\u3066\u3044\u308b\u5834\u5408\u3001heappop\u3067\u305d\u308c\u3092\u6392\u9664\u3059\u308b\n            if q[0] not in stop_set:\n                heappop(q)\n            #q[0]\u304cstop_set\u304b\u3089\u5916\u308c\u3066\u306a\u3044\u5834\u5408\u3001\u305d\u308c\u4ee5\u964d\u306eq\u3082\u5916\u308c\u3066\u3044\u306a\u3044\u306e\u3067break    \n            else:\n                break\n\n        if q:\n            print(q[0])\n        else:\n            print(-1)", "import heapq\n\nN, Q = map(int,input().split())\n\nevents = []\n\nfor _ in range(N):\n    S, T, X = map(int,input().split())\n\n    events.append([S-X, 1, X])\n    events.append([T-X, 0, X])\n\nfor _ in range(Q):\n    D = int(input())\n    events.append([D,2,0])\n\nevents.sort()\n\nclosed = set()\nque = []\n\nidx = 0\nfor time, flag, position in events:\n    if flag == 0:\n        closed.remove(position)\n    elif flag == 1:\n        heapq.heappush(que, position)\n        closed.add(position)\n    else:\n        while len(que) > 0 and que[0] not in closed:\n            heapq.heappop(que)\n\n        if len(que) > 0:\n            print(que[0])\n        else:\n            print(-1)", "def main():\n    from heapq import heappush, heappop\n    import sys\n    sys.setrecursionlimit(10 ** 7)\n\n    n,q=map(int,input().split())\n\n    event=[]\n    for _ in range(n):\n        s,t,x=map(int,input().split())\n        event.append((s-x,1,x))\n        event.append((t-x,-1,x))\n\n    for i in range(q):\n        event.append((int(input()),2,i))\n    event.sort()\n\n    ans=[0]*q\n\n    stop=set()\n    hq=[]\n    for t,op,x in event:\n        if op==1:\n            heappush(hq,x)\n            stop.add(x)\n        elif op==-1:\n            stop.remove(x)\n\n        else:\n            while hq and hq[0] not in stop:\n                heappop(hq) \n            ans[x]=hq[0] if hq else -1\n        \n    for x in ans:\n        print(x)\n\nmain()", "import sys\nfrom heapq import heappush, heappop\nfrom operator import itemgetter\n\nsys.setrecursionlimit(10 ** 7)\nrl = sys.stdin.readline\n\n\ndef solve():\n    N, Q = map(int, rl().split())\n    events = []\n    for _ in range(N):\n        s, t, x = map(int, rl().split())\n        events.append((t - x, 0, x))\n        events.append((s - x, 1, x))\n    for _ in range(Q):\n        d = int(rl())\n        events.append((d, 2, -1))\n    events.sort(key=itemgetter(0, 1))\n    \n    pos_set = set()\n    pos_hq = []\n    ans = []\n    for _, com, pos in events:\n        if com == 0:\n            pos_set.remove(pos)\n        elif com == 1:\n            pos_set.add(pos)\n            heappush(pos_hq, pos)\n        else:\n            while pos_hq:\n                if pos_hq[0] not in pos_set:\n                    heappop(pos_hq)\n                else:\n                    break\n            ans.append(pos_hq[0] if pos_hq else -1)\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "def main():\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n\n    from heapq import heappush, heappop \n\n    running = []\n    events = []\n    delete = set()\n\n    n, q = list(map(int, input().split()))\n    for _ in range(n):\n        s, t, x = list(map(int, input().split()))\n        time = max(s - x, 0)\n        if t - x < 0:\n            continue\n        events.append((s - x, x, 1)) # \u8ffd\u52a0\u30a4\u30d9\u30f3\u30c8\n        events.append((t - x, x, 0)) # \u524a\u9664\u30a4\u30d9\u30f3\u30c8\n    events.sort()\n    ans = []\n    idx = -1\n    for _ in range(q):\n        d = int(input())\n        if d >= events[-1][0]:\n            print((-1))\n            continue\n        while events[idx + 1][0] <= d:\n            idx += 1\n            if events[idx][2] == 1:\n                heappush(running, events[idx][1])\n                delete.discard(events[idx][1])\n            else:\n                delete.add(events[idx][1])\n        flag = 1\n        while running:\n            x = heappop(running)\n            if x not in delete:\n                heappush(running, x)\n                print(x)\n                flag = 0\n                break\n        if flag:\n            print((-1))\ndef __starting_point():\n    main()\n\n\n\n\n__starting_point()", "def main():\n    from bisect import bisect_left\n    from collections import namedtuple\n    from operator import attrgetter\n    import sys\n\n    input = sys.stdin.readline\n    Event = namedtuple('Event', 'pos start end')\n\n    N, Q = map(int, input().split())\n\n    events = []\n    for _ in range(N):\n        s, t, x = map(int, input().split())\n        e = Event(pos=x, start=s - x, end=t - x)  # \u6642\u9593[s-x,t-x)\u306bpos=0\u306b\u3044\u308b\u3068pos=x\u3067\u5de5\u4e8b\u4e2d\n        events.append(e)\n    events.sort(key=attrgetter('pos'))\n\n    D = [int(input()) for _ in range(Q)]\n\n    ans = [-1] * Q\n    see = [-1] * Q\n    for e in events:\n        left = bisect_left(D, e.start)\n        right = bisect_left(D, e.end)\n        # D\u306e\u8981\u7d20\u3067 index \u304c [left,right) \u5185\u306e\u3082\u306e\u306f e.pos \u3067\u5de5\u4e8b\u4e2d\n        # e.pos \u6607\u9806\u30bd\u30fc\u30c8\u3057\u3066\u3044\u308b\u306e\u3067, ans[idx] \u306b\u306f\u5de5\u4e8b\u4e2d\u306e\u6700\u5c0f\u306epos\u304c\u5165\u308b\n        idx = left\n        while idx < right:\n            if ~ans[idx]:\n                idx = see[idx]\n                continue\n            ans[idx] = e.pos\n            see[idx] = right\n            idx += 1\n            \n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom heapq import heappop,heappush\ninput = sys.stdin.readline\nn,Q = map(int,input().split())\nstx = [list(map(int,input().split())) for i in range(n)]\ndls = [int(input()) for i in range(Q)]\nevent = []\nfor i in range(n):\n  s,t,x = stx[i]\n  event.append((s-x,1,x))\n  event.append((t-x,-1,x))\nfor i in range(Q):\n  d = dls[i]\n  event.append((d,2,i))\nevent.sort()\nans = [-1]*Q\ns = set()\nhq = []\nfor t,q,x in event:\n  if q == 1:\n    s.add(x)\n    heappush(hq,x)\n  elif q == -1:\n    s.remove(x)\n  elif q == 2:\n    while hq and hq[0] not in s:\n      heappop(hq)\n    if hq:\n      ans[x] = hq[0]\n    else:\n      ans[x] = -1\nprint(*ans,sep=\"\\n\")", "# https://atcoder.jp/contests/abc128/submissions/11722664\n\ndef main():\n    from collections import deque, namedtuple\n    from heapq import heappush, heappop\n    from operator import attrgetter\n    import sys\n\n    input = sys.stdin.readline\n    Event = namedtuple('Event', 'pos start end')\n    UC = namedtuple('UC', 'pos end')  # UnderConstruction\n\n    N, Q = map(int, input().split())\n\n    events = []\n    for _ in range(N):\n        s, t, x = map(int, input().split())\n        e = Event(pos=x, start=s - x, end=t - x)  # \u6642\u9593[s-x,t-x)\u306bpos=0\u306b\u3044\u308b\u3068pos=x\u3067\u5de5\u4e8b\u4e2d\n        events.append(e)\n    events.sort(key=attrgetter('start'))\n    events = deque(events)\n\n    D = (int(input()) for _ in range(Q))\n\n    ans = []\n    h = []\n    for d in D:\n        while events and events[0].start <= d:\n            e = events.popleft()\n            heappush(h, UC(pos=e.pos, end=e.end))\n\n        while h and h[0].end <= d:\n            heappop(h)\n\n        ans.append(h[0].pos if h else -1)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from heapq import heappush, heappop\n\nN, Q = list(map(int, input().split()))\nl, q = [], []\nu = set()\n\nfor _ in range(N):\n    S, T, X = list(map(int, input().split()))\n    l += [(S-X, 1, X), (T-X, 0, X)]\nfor i in range(Q):\n    l += [(int(input()), 2, i)]\nl.sort()\n\nfor _, m, x in l:\n    if m==0:\n        u.remove(x)\n    elif m==1:\n        heappush(q, x)\n        u.add(x)\n    else:\n        while q:\n            if q[0] not in u:\n                heappop(q)\n            else:\n                break\n        print((q[0] if q else -1))\n", "# https://atcoder.jp/contests/abc128/submissions/11722664\n\ndef main():\n    from collections import deque, namedtuple\n    from heapq import heappush, heappop\n    from operator import attrgetter\n    import sys\n\n    input = sys.stdin.readline\n    Event = namedtuple('Event', 'pos start end')\n    UC = namedtuple('UC', 'pos end')  # UnderConstruction\n\n    N, Q = map(int, input().split())\n\n    events = []\n    for _ in range(N):\n        s, t, x = map(int, input().split())\n        e = Event(pos=x, start=s - x, end=t - x)  # \u6642\u9593[s-x,t-x)\u306bpos=0\u306b\u3044\u308b\u3068pos=x\u3067\u5de5\u4e8b\u4e2d\n        events.append(e)\n    events.sort(key=attrgetter('start'))\n    events = deque(events)\n\n    D = (int(input()) for _ in range(Q))\n\n    ans = [-1] * Q\n    h = []\n    for idx, d in enumerate(D):\n        while events and events[0].start <= d:\n            e = events.popleft()\n            heappush(h, UC(pos=e.pos, end=e.end))\n\n        while h and h[0].end <= d:\n            heappop(h)\n\n        if h:\n            ans[idx] = h[0].pos\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from bisect import bisect_left, bisect_right\n\nN,Q = map(int, input().split())\nSTX = [[int(i) for i in input().split()] for _ in range(N)]\nD = [int(input()) for _ in range(Q)]\n\nSTX.sort(key=lambda x:x[2])\n\nans = [-1] * Q\nskip = [-1] * Q\n\nfor S, T, X in STX:\n    # [S - X, T - X)\n    left = bisect_left(D, S - X)\n    right = bisect_right(D, T - X - 1)\n\n    while left < right:\n        if skip[left] < 0:\n            skip[left] = right\n            ans[left] = X\n            left += 1\n        else:\n            left = skip[left]\n\nprint(*ans, sep=\"\\n\")", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, Q = lr()\nSTX = [tuple(lr()) for _ in range(N)]\nevent = []\nappend = event.append\nfor s, t, x in STX:\n    append((s-x, 0, x))\n    append((t-x, -1, x))\n\nfor i in range(Q):\n    d = ir()\n    append((d, 1, i))\n\nevent.sort()\nanswer = [-1] * Q\ncur = set()\nflag = False\nINF = 10 ** 10\nmin_x = INF\nadd = cur.add\nremove = cur.remove\nfor a, b, c in event:\n    if b == 0:\n        add(c)\n        if c < min_x:\n            min_x = c\n            flag = True\n    elif b == -1:\n        remove(c)\n        if min_x == c:\n            flag = False\n    elif b == 1:\n        if cur:\n            if not flag:\n                min_x = min(cur)\n                flag = True\n            answer[c] = min_x\n\nprint(('\\n'.join(map(str, answer))))\n", "import heapq\nN,Q = list(map(int, input().split()))\n\nS,T,X = [],[],[]\n\nEv = []\nfor _ in range(N):\n  s,t,x = list(map(int, input().split()))\n  Ev.append((s-x,True,x))\n  Ev.append((t-x,False,x))\n\"\"\"\n2 5 6\n5 -1\n4 2\n3 3\n2 4\n1 5\n0 -1\n\"\"\"\nEv.sort()\n#print(Ev)\n# C++\u306eSet\u306fmin\u3082O(logN)\u3067\u53d6\u308c\u308b\u304c\u3001Python\u306f\u7121\u7406\u3002\n# set\u3068heapq\u3092\u4f75\u7528\u3059\u308b\u3068\u8a08\u7b97\u91cf\u304c\u5b9f\u73fe\u3067\u304d\u308b\u3002\nh = []\nclosed = set()\neidx = 0\nfor i in range(Q):\n  # d\u306fsorted\u3067input\u3055\u308c\u308b\u3002\n  d = int(input())\n  #Query.append(d)\n  while eidx < 2*N and Ev[eidx][0] <= d:\n    #pop\n    t,e,x = Ev[eidx]\n    eidx += 1\n    if e:\n      heapq.heappush(h, x)\n      closed.add(x)\n    else:\n      closed.remove(x)\n      \n  # heqpq\u306e\u6700\u5c0f\u5024\u304cset\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u9593\u3001\u6368\u3066\u7d9a\u3051\u308c\u3070\u3001set\u306e\u8981\u7d20\u3068heapq\u306e\u8981\u7d20\u304c\u4e00\u81f4\u3059\u308b\n  while h and h[0] not in closed:\n    heapq.heappop(h)\n    \n  # assert( len(h) == len(set) )\n  if h:\n    print((h[0]))\n  else:\n    print((-1))\n", "from heapq import heapify,heappop,heappush\nimport sys\nread=sys.stdin.readline\nclass mset:\n    def __init__(self):\n        self.p,self.q=[],[]\n        heapify(self.p);heapify(self.q)\n    def add(self,a):\n        heappush(self.p,a)\n    def delete(self,a):\n            heappush(self.q,a)\n    def minimum(self):\n        while self.q and self.p[0]==self.q[0]:\n            heappop(self.p);heappop(self.q)\n        return self.p[0] if self.p else None\n\nN,Q=map(int,read().split())\nevent=[]\nfor i in range(N):\n    S,T,X=map(int,read().split())\n    event.append((1,S-X,X))\n    event.append((0,T-X,X))\n\ns=mset()\nnow=0\nfor i in range(Q):\n    D=int(read())\n    event.append((2,D,0))\nevent.sort(key=lambda x:(x[1],x[0]))\n\nfor c,t,w in event:\n    if c==0:\n        s.delete(w)\n    elif c==1:\n        s.add(w)\n    else:\n        m=s.minimum()\n        print(-1 if m==None else m)", "from heapq import heappush, heappop\n\nN, Q = list(map(int, input().split()))\nl = []\nused = set()\nq = []\n\nfor i in range(N):\n    S, T, X = list(map(int, input().split()))\n    l.append((S-X, 1, X))\n    l.append((T-X, 0, X))\n\nfor i in range(Q):\n    l.append((int(input()), 2, i))\n\nl.sort()\n\nfor pos, m, x in l:\n    if m==0:\n        used.remove(x)\n    elif m==1:\n        heappush(q, x)\n        used.add(x)\n    else:\n        while q:\n            if q[0] not in used:\n                heappop(q)\n            else:\n                break\n        print((q[0] if q else -1))\n", "import heapq as hq\nimport sys\n\nstdin = sys.stdin\n\nns = lambda: stdin.readline().rstrip()\nni = lambda: int(stdin.readline().rstrip())\nnm = lambda: map(int, stdin.readline().split())\nnl = lambda: list(map(int, stdin.readline().split()))\n\ndef main():\n    n,q = nm()\n    tl = []\n    ins = list()\n    dlt = list()\n    vv = [tuple(nm()) for _ in range(n)]\n    tl = [(s-x, 1, x) for s, _, x in vv]\n    tl.extend([(t-x, 0, x) for _, t, x in vv])\n    ww = [ni() for _ in range(q)]\n    tl.extend([(t, 2) for t in ww])\n    tl.sort()\n\n    for x in tl:\n        if x[1] == 1:\n            hq.heappush(ins, x[2])\n        elif x[1] == 0:\n            hq.heappush(dlt, x[2])\n            while dlt and ins[0] == dlt[0]:\n                hq.heappop(ins)\n                hq.heappop(dlt)\n        else:\n            print(-1 if not ins else ins[0])\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\nfrom heapq import heappop,heappush\n\nN,Q = list(map(int,input().split()))\ntask = []\n\nSTX = [[int(x) for x in input().split()] for _ in range(N)]\nfor s,t,x in STX:\n  task.append((t-x,0,x))\n  task.append((s-x,1,x))\n\nfor i in range(Q):\n  d = int(input())\n  task.append((d,2,i))\nanswer = [-1]*Q\n\ntask.sort()\n\nse = set()\nse_hp = []\nfor a,b,c in task:\n  if not b:\n    se.remove(c)\n  elif b&1:\n    se.add(c)\n    heappush(se_hp,c)\n  else:\n    while se_hp and se_hp[0] not in se:\n      heappop(se_hp)\n    answer[c] = se_hp[0] if se_hp else -1\n\nprint(('\\n'.join(map(str,answer))))\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n\n    n, q = map(int, input().split())\n\n    V = []\n\n    for i in range(n):\n        s, t, x = map(int, input().split())\n        V.append((s-x, x, 1)) #1: insert\n        V.append((t-x, x, 0)) #0: delete\n\n    D = []\n    for i in range(q):\n        d = int(input())\n        V.append((d, i, 2)) #2: query\n\n    V.sort(key=lambda x:(x[0], x[2]))\n    se = set()\n    hq = []\n    import heapq\n    heapq.heapify(hq)\n    ans = [-1]*q\n    for t, v, p in V:\n        if p == 1:\n            se.add(v)\n            heapq.heappush(hq, v)\n        elif p == 0:\n            se.discard(v)\n        else:\n            while hq and hq[0] not in se:\n                heapq.heappop(hq)\n            if hq:\n                ans[v] = hq[0]\n\n    for i in range(q):\n        print(ans[i])\n\ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    from itertools import combinations, permutations, accumulate, groupby, product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    import math\n    #from math import gcd\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,q = map(int, input().split())\n    l = []\n    for _ in range(n):\n        s,t,x = map(int, input().split())\n        l.append((s,t,x))\n    l.sort(key=lambda a: a[2])\n    start = [int(input()) for _ in range(q)]\n\n    skip = [-1]*q\n    res = [-1]*q\n\n    for s,t,x in l:\n        left = bisect_left(start, s-x)\n        right = bisect_left(start, t-x)\n        while left < right:\n            if skip[left] == -1:\n                res[left] = x\n                skip[left] = right\n                left += 1\n            else:\n                left = skip[left]\n    \n    for i in res:\n        print(i)\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nn,q = list(map(int,input().split()))\nimos = []\nfor i in range(n):\n    s,t,x = list(map(int,input().split()))\n    imos.append((s-x,x))\n    imos.append((t-x,-x))\nans = set()\nj = 0\nfor i in range(q):\n    d = int(input())\n    imos.append((d,1e100))\nimos.sort()\nm = 1e100\nflag = False\nfor t,stop in imos:\n    if stop == 1e100:\n        if ans:\n            if not flag:\n                m = min(ans)\n                flag = True\n            print(m)\n        else:\n            print((-1))\n    elif stop > 0:\n        ans.add(stop)\n        if stop < m:\n            m = stop\n            flag = True\n    else:\n        ans.remove(-stop)\n        if m == -stop:flag = False\n", "# https://atcoder.jp/contests/abc128/submissions/11722664\n\ndef main():\n    from collections import deque, namedtuple\n    from heapq import heappush, heappop\n    from operator import attrgetter\n    import sys\n\n    input = sys.stdin.readline\n    Event = namedtuple('Event', 'pos start end')\n    UC = namedtuple('UC', 'pos end')  # UnderConstruction\n\n    N, Q = map(int, input().split())\n\n    events = []\n    for _ in range(N):\n        s, t, x = map(int, input().split())\n        e = Event(pos=x, start=s - x, end=t - x)  # \u6642\u9593[s-x,t-x)\u306bpos=0\u306b\u3044\u308b\u3068pos=x\u3067\u5de5\u4e8b\u4e2d\n        events.append(e)\n    events.sort(key=attrgetter('start'))\n    events = deque(events)\n\n    D = (int(input()) for _ in range(Q))\n\n    ans = []\n    h = []\n    for d in D:\n        while events and events[0].start <= d:\n            e = events.popleft()\n            heappush(h, UC(pos=e.pos, end=e.end))\n\n        while h and h[0].end <= d:\n            heappop(h)\n\n        ans.append(h[0].pos if h else -1)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\nfrom bisect import bisect_left\nn,q=map(int,input().split())\nstop=[]\nfor i in range(n):\n\ts,t,x=map(int,input().split())\n\tstop.append((s,t,x))\nstop.sort(key=lambda x:x[2])\nd=[int(input())for i in range(q)]\nR=[-1]*q\nans=[-1]*q\nfor s,t,x in stop:\n\t#l\u304b\u3089r\u306b\u3042\u308b\u533a\u9593\u306eans\u3092x\u306b\u66f4\u65b0\u3057\u305f\u3044\n\tl=bisect_left(d,s-x)\n\tr=bisect_left(d,t-x)\n\twhile l<r:\n\t\tif R[l]==-1:#\u6700\u5de6\u304c\u307e\u3060\u78ba\u5b9a\u3057\u3066\u3044\u306a\u3044\u5834\u5408\n\t\t\tans[l]=x\n\t\t\tR[l]=r\n\t\t\tl+=1\n\t\telse:\n\t\t\tl=R[l]#\u78ba\u5b9a\u3057\u3066\u3044\u308b\u3068\u3053\u308d\u3092\u98db\u3070\u3059\nfor x in ans:\n\tprint(x)", "# coding: utf-8\nimport sys\nfrom heapq import heapify, heappop, heappush\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, Q = lr()\nSTX = [tuple(lr()) for _ in range(N)]\nevent = []\nappend = event.append\nfor s, t, x in STX:\n    append((s-x, 0, x))\n    append((t-x, -1, x))\n\nfor i in range(Q):\n    d = ir()\n    append((d, 1, i))\n\nevent.sort()\nanswer = [-1] * Q\ncur = set()\nflag = False\nINF = 10 ** 10\nmin_x = INF\nfor a, b, c in event:\n    if b == 0:\n        cur.add(c)\n        if c < min_x:\n            min_x = c\n            flag = True\n    elif b == -1:\n        cur.remove(c)\n        if min_x == c:\n            flag = False\n    elif b == 1:\n        if cur:\n            if not flag:\n                min_x = min(cur)\n                flag = True\n            answer[c] = min_x\n\nprint(('\\n'.join(map(str, answer))))\n", "import sys\nfrom operator import itemgetter\nfrom heapq import heapify, heappush, heappop\n\nread = sys.stdin.read\n\nN, Q, *STXD = list(map(int, read().split()))\nSTX = STXD[:3 * N]\nqueue = []\n\nfor i, (S, T, X) in enumerate(zip(*[iter(STX)] * 3), 1):\n    queue.append((S - X - 0.5, X, i))\n    queue.append((T - X - 0.5, -X, i))\n\nfor D in STXD[3 * N:]:\n    queue.append((D, 0, 0))\n\nqueue.sort(key=itemgetter(0), reverse=True)\nheap = []\nheapify(heap)\nstop, construction = -1, 0\nnot_available = set()\nwhile queue:\n    _, x, n = queue.pop()\n    if x == 0:\n        print(stop)\n    elif x < 0:\n        not_available.add(n)\n        if n == construction:\n            while heap:\n                stop, construction = heappop(heap)\n                if construction not in not_available:\n                    break\n            else:\n                stop, construction = -1, 0\n    else:\n        if stop != -1:\n            if stop <= x:\n                heappush(heap, (x, n))\n            else:\n                heappush(heap, (stop, construction))\n                stop, construction = x, n\n        else:\n            stop, construction = x, n\n", "import sys\ninput = sys.stdin.readline\nread = sys.stdin.read\nimport heapq\n\nn, q = map(int, input().split())\nSTX = [list(map(int, input().split())) for _ in range(n)]\nD = list(map(int, read().split()))\nE = []\nfor s, t, x in STX:\n  E.append((s-x, x, 1))\n  E.append((t-x, x, 0))\nE.sort(reverse=True)\nque = []\nstop = set()\nque.append(10**10)\nstop.add(10**10)\nfor d in D:\n  while E and E[-1][0] <= d:\n    temp, x, f = E.pop()\n    if f:\n      heapq.heappush(que, x)\n      stop.add(x)\n    else:\n      stop.remove(x)\n  while que[0] not in stop:\n    heapq.heappop(que)\n  if que[0] == 10**10:\n    print(-1)\n  else:\n    print(que[0])", "# roadwork\nimport heapq\nN, Q = map(int, input().split())\nque = []\nans = [-1 for i in range(Q)]\nD = [0 for i in range(N)]\nheap = []\nheapq.heapify(heap)\nSet = set([])\nfor i in range(N):\n    s, t, x = map(int, input().split())\n    que.append((s-x, 0, i))  # append\n    que.append((t-x, 1, i))  # remove\n    D[i] = x\n\nfor i in range(Q):\n    d = int(input())\n    que.append((d, 2, i))  # querie\n\nque.sort(key=lambda x: x[0])\n\nfor x in que:\n    demand = x[1]\n    if demand == 0:\n        # append\n        heapq.heappush(heap, (D[x[2]], x[2]))\n        Set.add(x[2])\n    elif demand == 1:\n        # remove\n        Set.remove(x[2])\n    else:\n        # querie\n        flag = True\n        while heap and flag:\n            distance, index = heapq.heappop(heap)\n            if index in Set:\n                ans[x[2]] = distance\n                heapq.heappush(heap, (distance, index))\n                flag = False\nfor i in range(Q):\n    print(ans[i])", "import sys\ninput = sys.stdin.readline\nINF = 1<<31\nfrom bisect import bisect_left\n\ndef main():\n    N,Q = map(int,input().split())\n    roadwork = [tuple(map(int,input().split())) for _ in range(N)]\n    roadwork.sort(key = lambda x:x[2])\n    D = [int(input()) for _ in range(Q)]\n    ans = [-1] * Q\n    skip = [-1] * Q\n    for s,t,x in roadwork:\n        L = bisect_left(D,s - x)\n        R = bisect_left(D,t - x)\n        while L < R:\n            if skip[L] == -1:\n                ans[L] = x\n                skip[L] = R\n                L += 1\n            else:\n                L = skip[L]\n    print('\\n'.join(map(str,ans)))\ndef __starting_point():\n    main()\n__starting_point()", "# coding: utf-8\nimport sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nN, Q = lr()\nSTX = [tuple(lr()) for _ in range(N)]\nevent = []\nfor s, t, x in STX:\n    event.append((s-x, 0, x))\n    event.append((t-x, -1, x))\n\nfor i in range(Q):\n    d = ir()\n    event.append((d, 1, i))\n\nevent.sort()\nanswer = [-1] * Q\ncur = set()\nflag = False\nINF = 10 ** 10\nmin_x = INF\nfor a, b, c in event:\n    if b == 0:\n        cur.add(c)\n        if c < min_x:\n            min_x = c\n            flag = True\n    elif b == -1:\n        cur.remove(c)\n        if min_x == c:\n            flag = False\n    elif b == 1:\n        if cur:\n            if not flag:\n                min_x = min(cur)\n                flag = True\n            answer[c] = min_x\n\nprint(('\\n'.join(map(str, answer))))\n# 19\n", "import heapq\n# sys.stdin.readline()\nimport sys\ninput = sys.stdin.readline\n\nN,Q = list(map(int, input().split()))\n\nS,T,X = [],[],[]\n\nEv = []\nfor _ in range(N):\n  s,t,x = list(map(int, input().split())) \n  Ev.append((s-x,True,x))\n  Ev.append((t-x,False,x))\n\"\"\"\n2 5 6\n5 -1\n4 2\n3 3\n2 4\n1 5\n0 -1\n\"\"\"\nEv.sort()\n#print(Ev)\n# C++\u306eSet\u306fmin\u3082O(logN)\u3067\u53d6\u308c\u308b\u304c\u3001Python\u306f\u7121\u7406\u3002\n# set\u3068heapq\u3092\u4f75\u7528\u3059\u308b\u3068\u8a08\u7b97\u91cf\u304c\u5b9f\u73fe\u3067\u304d\u308b\u3002\nh = []\nclosed = set()\neidx = 0\nD = []\n\n# \u53d7\u3051\u53d6\u3063\u305f\u65b9\u304c\u65e9\u3044\u30fb\u30fb\u30fb\uff1f\nfor i in range(Q):\n  D.append(int(input()))\n\nfor d in D:\n  # d\u306fsorted\u3067input\u3055\u308c\u308b\u3002\n  #d = int(input())\n  #Query.append(d)\n  while eidx < 2*N and Ev[eidx][0] <= d:\n    #pop\n    t,e,x = Ev[eidx]\n    eidx += 1\n    if e:\n      heapq.heappush(h, x)\n      closed.add(x)\n    else:\n      closed.remove(x)\n      \n  # heqpq\u306e\u6700\u5c0f\u5024\u304cset\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u9593\u3001\u6368\u3066\u7d9a\u3051\u308c\u3070\u3001set\u306e\u8981\u7d20\u3068heapq\u306e\u8981\u7d20\u304c\u4e00\u81f4\u3059\u308b\n  while h and h[0] not in closed:\n    heapq.heappop(h)\n    \n  # assert( len(h) == len(set) )\n  if h:\n    print((h[0]))\n  else:\n    print((-1))\n", "def main():\n    import sys\n    input = lambda : sys.stdin.readline().rstrip()\n\n    from heapq import heappush, heappop \n\n    running = [] # \u6b62\u307e\u308a\u3046\u308b\u5ea7\u6a19\n    events = [] # \u6642\u523b\u9806\u306e\u30a4\u30d9\u30f3\u30c8\n    finished = set() # \u5de5\u4e8b\u304c\u7d42\u4e86\u3057\u305f\u5ea7\u6a19\n\n    n, q = map(int, input().split())\n    for _ in range(n):\n        s, t, x = map(int, input().split())\n        events.append((s - x, x, 1)) # \u8ffd\u52a0\u30a4\u30d9\u30f3\u30c8\n        events.append((t - x, x, 0)) # \u524a\u9664\u30a4\u30d9\u30f3\u30c8\n    for _ in range(q):\n        d = int(input())\n        events.append((d, 10**10, 2)) # \u51fa\u767a\u30a4\u30d9\u30f3\u30c8,\u540c\u3058\u6642\u523b\u5185\u3067\u6700\u5f8c\u306b\u306a\u308b\u3088\u3046\u7b2c\u4e8c\u5f15\u6570\u8a2d\u5b9a\n    events.sort()\n    for i in range(len(events)):\n        temp = events[i]\n        if temp[-1] == 1:\n            heappush(running, temp[1])\n            finished.discard(temp[1])\n        elif temp[-1] == 0:\n            finished.add(temp[1])\n        else:\n            flag = 1\n            while running:\n                p = heappop(running)\n                if p not in finished:\n                    flag = 0\n                    heappush(running, p)\n                    print(p)\n                    break\n            if flag:\n                print(-1)\ndef __starting_point():\n    main()\n__starting_point()", "import heapq\nn, q = list(map(int, input().split()))\nevent = []\nfor _ in range(n):\n    s, t, x = list(map(int, input().split()))\n    event.append((s-x, 1, x))\n    event.append((t-x, -1, x))\n\nevent.sort()\nheap = []\nxs = set([])\n\nd = [int(input()) for _ in range(q)] + [10**9 + 7]\nans = [-1] * q\nindex = 0\nfor t, query, x in event:\n    while d[index] < t:\n        if not xs:\n            pass\n        else:\n            while heap:\n                tmp = heapq.heappop(heap)\n                if tmp in xs:\n                    heapq.heappush(heap, tmp)\n                    ans[index] = tmp\n                    break\n        index += 1\n\n    if query == 1:\n        xs.add(x)\n        heapq.heappush(heap, x)\n    else:\n        xs.remove(x)\n\n\nwhile index < q:\n    while heap:\n        tmp = heapq.heappop(heap)\n        if tmp in xs:\n            heapq.heappush(heap, tmp)\n            ans[index] = tmp\n            break\n    index += 1\n\nprint((\"\\n\".join(map(str, ans))))\n\n\n\n", "# E - Roadwork\nfrom bisect import bisect_left\nfrom operator import itemgetter\n\n\ndef main():\n    N, Q, *STXD = list(map(int, open(0).read().split()))\n    STX, D = sorted(zip(*[iter(STXD[: 3 * N])] * 3), key=itemgetter(2)), STXD[3 * N :]\n    ans = [-1] * Q\n    road = [-1] * Q  # (road[i] = x) := if -1: open / else: closed until x\n    for s, t, x in STX:\n        l, r = bisect_left(D, s - x), bisect_left(D, t - x)\n        while l < r:\n            if road[l] == -1:\n                ans[l] = x\n                road[l] = r\n                l += 1\n            else:\n                l = road[l]\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nimport sys\ninput = sys.stdin.readline\n\nN, Q = (int(i) for i in input().split())\nL = [0] * 2 * N\nfor i in range(N):\n    S, T, X = (int(i) for i in input().split())\n    L[2 * i] = (S-X, X, 1)\n    L[2 * i + 1] = (T-X, X, 0)\n\nL.sort(reverse=True)\n\nXs = set([])\nXH = []\nheapq.heapify(XH)\nfor i in range(Q):\n    D = int(input())\n    ans = 0\n    while True:\n        if L:\n            t, X, f = L.pop()\n            if t <= D:\n                if f == 1:\n                    Xs.add(X)\n                    heapq.heappush(XH, X)\n                else:\n                    Xs.remove(X)\n            else:\n                L.append((t, X, f))\n                break\n        else:\n            break\n    if Xs:\n        while XH[0] not in Xs:\n            X = heapq.heappop(XH)\n        print(XH[0])\n    else:\n        print(\"-1\")"]
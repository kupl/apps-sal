["from heapq import heappush, heappop\n\ndef closure_gen(*s):\n    q = sorted(s)\n    m = set(s)\n    while q:\n        curr = heappop(q)\n        yield curr\n        for i in s:\n            t = curr * i\n            if t not in m:\n                heappush(q, t)\n                m.add(t)", "from heapq import *\n\ndef closure_gen(*s):\n    keys,seen=set(s),set(s)\n    q=sorted(seen)\n    while q:\n        curr=heappop(q)\n        for next in [v for v in [curr*i for i in keys] if not v in seen]:\n            heappush(q,next)\n            seen.add(next)\n        yield curr            \n", "def closure_gen(*s):\n    if not s: return\n    if s[0] == 1:\n        yield 1\n        s = s[1:]\n        if not s:\n            return\n    indices = {x: 0 for x in s}\n    seq = [1]\n    while True:\n        m = float('inf')\n        for x, i in indices.items():\n            m = min(m, seq[i] * x)\n        yield m\n        seq.append(m)\n        for x, i in indices.items():\n            if seq[i] * x == m:\n                indices[x] += 1", "def closure_gen(*s):\n    print(s)\n    #Special cases:\n    if s==(): return\n    if s==(1,): yield 1;return\n    if len(s)==1:\n        v0,vi=s[0],s[0]\n        while True: yield vi;vi*=v0\n    s=list(s)\n    for i in [0,1]:\n        if i in s:yield i;s.remove(i)\n\n    #=== Main ====\n    queue=[1]\n    seen=set(queue)\n    \n    def next_value(i,si,rank):\n        while True:\n            val=queue[rank]*si\n            if val in seen:\n                rank+=1\n                continue\n            break\n        seen.add(val)            \n        return val,i,si,rank            \n        \n    queues=[next_value(i,si,0) for i,si in enumerate(s)]\n\n    while True:\n        vn,i,si,rank=min(queues)\n        queue.append(vn)\n        yield vn\n        queues[i]=next_value(i,si,rank+1)\n", "from heapq import heappush, heappop, heapify\n\ndef closure_gen(*s):\n    if not s:\n        return None\n    set_s = set(s)\n    heap_s = [i for i in s]\n    heapify(heap_s)\n    while set_s:\n        current = heappop(heap_s)\n        new_values = {current * i for i in s}.difference(set_s)\n        for i in new_values:\n            heappush(heap_s, i)\n        set_s.update(new_values)\n        set_s.discard(current)\n        yield current\n", "import heapq\n\ndef closure_gen(*s):\n    if not s: raise StopIteration()\n    \n    h = set(s)  # set of queued elements (for faster inclusion tests)\n    q = list(h)\n    heapq.heapify(q)\n    \n    if q == [1]:\n        yield 1\n        raise StopIteration()\n    \n    while True:\n        x = heapq.heappop(q)\n        h.remove(x)\n        yield x\n\n        for y in s:\n            z = x * y\n            if y != 1 and z not in h:\n                heapq.heappush(q, z)\n                h.add(z)", "import heapq\n\ndef closure_gen(*s):\n    s=set(sorted(s))\n    buf=list(s)\n    heapq.heapify(buf)\n    while True:\n        if len(buf)==0:raise StopIteration\n        val=heapq.heappop(buf)\n        while len(buf)>0 and buf[0]==val:heapq.heappop(buf)\n        for v in s:\n            if v<=1:continue\n            heapq.heappush(buf,val*v)\n        yield val", "from heapq import heapify, heappop, heappush\n\n\ndef closure_gen(*s):\n    heap = [*s]\n    heapify(heap)\n    numbers = {*s}\n\n    while heap:\n        n = heappop(heap)\n\n        yield n\n\n        to_add = {n * i for i in s} - numbers\n        numbers |= to_add\n\n        for n in to_add:\n            heappush(heap, n)", "def closure_gen(*s):\n    s = [*s]\n\n    if 1 in s:\n        s.remove(1)\n        yield 1\n\n    queue = [(n, n, 0) for n in s]\n    numbers = [1]\n\n    while queue:\n        prod, *_ = min(queue)\n        yield prod\n\n        numbers.append(prod)\n        for i, (p, n, d) in enumerate(queue):\n            if p <= prod:\n                d += p == prod\n                queue[i] = numbers[d] * n, n, d", "def closure_gen(*seq):\n    if not seq : return \n    if seq == (1,) : yield 1 ; return\n    if 1 in seq : yield 1\n    seq = [i for i in seq if i != 1]\n    d, ind, li = {i: [i] for i in seq}, {i: 0 for i in seq}, []\n    while True:\n        min_ = min(d[i][0] for i in d if d[i])\n        li.append(min_)\n        yield min_\n        for i in d:\n            if d[i][0] == min_ : d[i].pop(0)\n            if not d[i]:\n                d[i].append(li[ind[i]] * i)\n                ind[i] += 1"]
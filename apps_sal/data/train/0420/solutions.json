["class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        s = s + 'a'\n        bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res = 0\n        key = 0\n        for i, char in enumerate(s):                \n            if char in bits:\n                if key in dp:\n                    res = max(res, i-dp[key] - 1)\n                key = key ^ (1 << bits[char])\n                if key not in dp:\n                    dp[key] = i\n        return res\n            \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        s = s + 'a'\n        bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res = 0\n        key = 0\n        for i, char in enumerate(s):                \n            if char in bits:\n                if key in dp:\n                    res = max(res, i-dp[key] - 1)\n                key = key ^ (1 << bits[char])\n                if key not in dp:\n                    dp[key] = i\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        for i in range(len(s),0,-1):\n            for j in range(len(s)-i+1):\n                sub = s[j:j+i]\n                has_odd_vowel = False\n                for vowel in ['a','e','i','o','u']:\n                    if sub.count(vowel)%2!=0:\n                        has_odd_vowel = True\n                        break\n                if not has_odd_vowel:return i\n        \n        return 0", "class Solution:\n    #def findTheLongestSubstring(self, s: str) -> int:\n        # Represent the counts (odd or even) of vowels with a bitmask.\n        # Precompute the prefix xor for the bitmask of vowels and then get the longest valid substring.\n        #\n    def findTheLongestSubstring(self, s):\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        ans = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c)+1) >> 1\n            seen.setdefault(cur, i)\n            ans = max(ans, i-seen[cur])\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s):\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s):\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {x : (1<<i) for i, x in enumerate('aeiou')}\n        fst = {0:-1}\n        \n        ans = mask = 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                mask ^= vowels[c]\n            fst.setdefault(mask, i)\n            ans = max(ans, i - fst[mask])\n        \n        return ans", "# https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/578071/Python-Solution-Sliding-Window-(Easy-to-Read)\nimport collections \nclass Solution:\n    \n    def findTheLongestSubstring(self, s: str) -> int:\n        \n        for substr_len in range(len(s), -1, -1): #dynamic sliding window []\n            end_remove = len(s) - substr_len + 1 \n            \n            for start in range(end_remove):\n                even = True #Let's assume everything is true so far (our code is going to try to break you)\n                sub_str = s[start:start + substr_len]\n                \n                for vowel in 'aeiou': \n                    if sub_str.count(vowel) % 2 != 0:\n                        even = False #means we're odd length c\n                        break\n                if even == True: #counter == 0 is saying all are odd \n                    return substr_len\n\n\n# class Solution:\n#     def findTheLongestSubstring(self, s: str) -> int:\n#         return recurseLongestSubstring(s)\n        \n# def recurseLongestSubstring(s):\n#     # print(s)\n#     a = e = i = o = u = 0\n#     first_a = first_e = first_i = first_o = first_u = -1\n#     last_a = last_e = last_i = last_o = last_u = -1\n\n#     for index in range(0, len(s)):\n#         if s[index] == 'a':\n#             if first_a == -1:\n#                 first_a = index\n#             last_a = index\n#             a += 1\n#         elif s[index] == 'e':\n#             if first_e == -1:\n#                 first_e = index\n#             last_e = index\n#             e += 1\n#         elif s[index] == 'i':\n#             if first_i == -1:\n#                 first_i = index\n#             last_i = index\n#             i += 1\n#         elif s[index] == 'o':\n#             if first_o == -1:\n#                 first_o = index\n#             last_o = index\n#             o += 1\n#         elif s[index] == 'u':\n#             if first_u == -1:\n#                 first_u = index\n#             last_u = index\n#             u += 1  \n#     # print(a, e, i, o, u)\n#     # print(first_a , first_e , first_i , first_o , first_u)\n#     # print(last_a, last_e, last_i, last_o, last_u)\n    \n#     if all_even([a, e, i, o, u]):\n#         return len(s)\n\n#     pool = []    \n#     if not is_even(a):\n#         pool.append(recurseLongestSubstring(s[0:last_a]))\n#         pool.append(recurseLongestSubstring(s[first_a + 1:len(s)]))\n#     if not is_even(e):\n#         pool.append(recurseLongestSubstring(s[0:last_e]))\n#         pool.append(recurseLongestSubstring(s[first_e + 1:len(s)]))\n#     if not is_even(i):\n#         pool.append(recurseLongestSubstring(s[0:last_i]))\n#         pool.append(recurseLongestSubstring(s[first_i + 1:len(s)]))\n#     if not is_even(o):\n#         pool.append(recurseLongestSubstring(s[0:last_o]))\n#         pool.append(recurseLongestSubstring(s[first_o + 1:len(s)]))\n#     if not is_even(u):\n#         pool.append(recurseLongestSubstring(s[0:last_u]))\n#         pool.append(recurseLongestSubstring(s[first_u + 1:len(s)]))\n#     return max(pool)\n    \n\n# def all_even(nums):\n#     for num in nums:\n#         if not is_even(num):\n#             return False\n#     return True\n\n# def is_even(num):\n#     return num % 2 == 0\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        res = cur = 0\n        seen = {0 : -1}\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen.get(cur))\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        P = [0]\n        vowels = 'aeiou'\n        for c in s:\n            i = vowels.find(c)\n            mask = (1 << i) if i != -1 else 0\n            P.append(P[-1] ^ mask)\n            \n        ans = 0\n        fst = {}\n        for i, p in enumerate(P):\n            if p in fst:\n                h = fst[p]\n                ans = max(ans, i - h)\n            fst.setdefault(p, i)\n            \n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        def countVowels(ct):\n            if not ct['a'] % 2 and not ct['e'] % 2 and not ct['i'] % 2 and not ct['o'] % 2 and not ct['u'] % 2:\n                return True\n            return False\n\n        #Reducer\n            #Slider\n            #0 - len(s)\n            #0 - len(s) -1 -> 1 - len(s)\n        for i in range(len(s)):\n            ctr = collections.Counter(s[:len(s) - i])\n            for j in range(i+1):\n                #window = s[j:(len(s)+j) - i]\n                if j != 0:\n                    ctr[s[j - 1]] -= 1\n                    ctr[s[len(s)+j - i - 1]] += 1\n                if countVowels(ctr):\n                    return sum(ctr.values())\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        ret = curr = 0\n        \n        for i, c in enumerate(s):\n            curr ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            if curr not in seen:\n                seen[curr] = i\n            ret = max(ret, i - seen[curr])\n        \n        return ret\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        def countVowels(ct):\n            if not ct['a'] % 2 and not ct['e'] % 2 and not ct['i'] % 2 and not ct['o'] % 2 and not ct['u'] % 2:\n                return True\n            return False\n\n        #Reducer\n            #Slider\n            #0 - len(s)\n            #0 - len(s) -1 -> 1 - len(s)\n        for i in range(len(s)):\n            ctr = collections.Counter(s[:len(s) - i])\n            for j in range(i+1):\n                #window = s[j:(len(s)+j) - i]\n                if j != 0:\n                    ctr[s[j - 1]] -= 1\n                    ctr[s[len(s)+j - i - 1]] += 1\n                if countVowels(ctr):\n                    return sum(ctr.values())\n        return 0\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        bits = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        seen = {0: -1}\n        max_val = 0\n        cur = 0\n        for i, char in enumerate(s):\n            if char in bits:\n                cur ^= bits[char]\n            seen.setdefault(cur, i)\n            max_val = max(max_val, i - seen[cur])\n            \n        return max_val", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        m = dict(a=1, e=0b10, i=0b100, o=0b1000, u=0b10000)\n        longest = 0\n        parity_index = {0: -1}\n        parity = 0\n        for i, ch in enumerate(s):\n            parity = parity ^ m.get(ch, 0)\n            if parity not in parity_index:\n                parity_index[parity] = i\n            longest = max(longest, i - parity_index.get(parity))\n        return longest                ", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        def countVowels(ct):\n            if not ct['a'] % 2 and not ct['e'] % 2 and not ct['i'] % 2 and not ct['o'] % 2 and not ct['u'] % 2:\n                return True\n            return False\n\n        #Reducer\n            #Slider\n            #0 - len(s)\n            #0 - len(s) -1 -> 1 - len(s)\n        for i in range(len(s)):\n            ctr = collections.Counter(s[:len(s) - i])\n            for j in range(i+1):\n                #window = s[j:(len(s)+j) - i]\n                if j != 0:\n                    ctr[s[j - 1]] -= 1\n                    ctr[s[len(s)+j - i - 1]] += 1\n                if countVowels(ctr):\n                    return sum(ctr.values())\n        return 0\n", "#https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/\n\nclass Solution:\n    def findTheLongestSubstring1(self, s: str) -> int:\n        \n        def check(L, R, cnt_memo):\n            if L>R:\n                return 0 \n            elif (L, R) in memo:\n                return memo[(L, R)]\n            else:\n                if all(v%2==0 for v in list(cnt_memo.values())):\n                    return R-L+1\n                else:\n                    old_L = L\n                    new_memo = {k:v for k, v in list(cnt_memo.items())}\n                    \n                    while s[L] not in 'aeiou':\n                        L += 1\n                    new_memo[s[L]] -= 1\n                    if new_memo[s[L]] == 0:\n                        del new_memo[s[L]]\n                    res1 = check(L+1, R, new_memo)\n                    L = old_L\n                    \n                    old_R = R\n                    new_memo = {k:v for k, v in list(cnt_memo.items())}\n                    while s[R] not in 'aeiou':\n                        R -= 1\n                    new_memo[s[R]] -= 1\n                    if new_memo[s[R]] == 0:\n                        del new_memo[s[R]]\n                    res2= check(L, R-1, new_memo)\n                    R = old_R\n                    res = max(res1, res2)\n                    memo[(L, R)] = res\n                    return res\n        \n        cnt_memo = collections.Counter(s)\n        cnt_memo = {k:v for k, v in list(cnt_memo.items()) if k in 'aeiou'}\n        memo = dict()\n        res = check(0, len(s)-1, cnt_memo)\n        # print (memo)\n        return res\n        \n    def findTheLongestSubstring(self, s: str) -> int:\n        res = 0\n        curr = 0\n        memo = dict()\n        memo[0] = -1\n        for i, c in enumerate(s):\n            if c=='a':\n                curr ^= 1\n            elif c=='e':\n                curr ^= 2\n            elif c=='i':\n                curr ^= 4\n            elif c=='o':\n                curr ^= 8\n            elif c=='u':\n                curr ^= 16\n            if curr in memo:\n                res = max(res, i-memo[curr])\n            else:\n                memo[curr] = i\n        return res\n        \n        \n        return\n        \n        \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        for i in range(len(s), 0, -1):\n            for j in range(len(s) - i + 1):\n                sub = s[j:j + i]\n                has_odd_vowel = False\n                for vowel in ['a', 'e', 'i', 'o', 'u']:\n                    if sub.count(vowel) % 2 != 0:\n                        has_odd_vowel = True\n                        break\n                if not has_odd_vowel: return  i\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowel_dict = {'a':0, 'e':1, 'i':2, 'o':3, 'u':4}\n        integrals = [(False, False, False, False, False)]\n        for l in s:\n            vector = list(integrals[-1])\n            if l in vowel_dict:\n                vector[vowel_dict[l]] = not vector[vowel_dict[l]]\n            integrals.append(tuple(vector))\n        seen = {}\n        res = 0\n        for i, v in enumerate(integrals):\n            if v in seen:\n                res = max(res, i - seen[v])\n            else:\n                seen[v] = i\n        return res\n#         start, end = 0, 0 \n        \n#         for i in range(0, len(s)-1):\n#             if s[i] in vowel_dict:\n#                 vowel_dict[s[i]] +=1\n#                 end +=1\n            \n#             end += 1\n                \n        \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        max_substring_size = 0\n        processed_cons = None\n        s_len = len(s)\n        for i in range(s_len):\n            if processed_cons == True:\n                if s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or s[i] == 'o' or s[i] == 'u':\n                    processed_cons = False\n                continue\n            if s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or s[i] == 'o' or s[i] == 'u':\n                processed_cons = False\n            else:\n                processed_cons = True\n            if max_substring_size > s_len - i:\n                break\n            vowel_counts = {'a':0,'e':0,'i':0,'o':0,'u':0}\n            allEven = True\n            for k, letter in enumerate(s[i:]):\n                if letter in vowel_counts:\n                    vowel_counts[letter] += 1\n                    currently_all_even = True\n                    for count in list(vowel_counts.values()):\n                        if count % 2 == 1:\n                            currently_all_even = False\n                            break\n                    allEven = currently_all_even\n                if allEven and k + 1 > max_substring_size:\n                    max_substring_size = k + 1\n        return max_substring_size\n", "from copy import copy\n\nclass Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowel2idx = dict([(item[1], item[0]) for item in enumerate(['a', 'e', 'i', 'o', 'u'])])\n        \n        counters = [0]\n        for item in s:\n            counters.append(counters[-1])\n            if item in vowel2idx:\n                counters[-1] ^= (2 ** vowel2idx[item])\n        \n        for width in range(len(s), 0, -1):\n            for start in range(len(s) - width + 1):\n                if counters[start + width] ^ counters[start] != 0:\n                    continue\n                return width\n        return 0\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels, bits, dp = {'a','e','i','o','u'}, {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res, odds = 0, set()\n        for i in range(len(s)):\n            if s[i] in vowels:\n                if s[i] in odds:\n                    odds.discard(s[i])\n                else:\n                    odds.add(s[i])\n            key = 0\n            for o in odds:\n                key |= 1 << bits[o]\n            if key in dp:\n                res = max(res, i-dp[key])\n            else:\n                dp[key] = i\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        #[F,F,F,F,F], [T,F,F,F,F], [F,F,F,F,F], [F,F,F,F,F]\n        states = [(False, False, False, False, False)]\n        seen = {}\n        mapping = {'a' : 0, 'e':1, 'i': 2, 'o':3, 'u':4}\n\n\n        for i in range(len(s)):\n            vector = list(states[-1])\n            character = s[i]\n            \n            if character in mapping:\n                vector[mapping[character]] = not vector[mapping[character]]\n            \n            states.append(tuple(vector))\n            \n        res = 0\n        \n        for i, v in enumerate(states):\n            \n            if v in seen:\n                res = max(res, i - seen[v])\n            else:\n                seen[v] = i\n                \n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        mask = 0\n        mp = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n        seen = [len(s)] * 63\n        seen[0] = -1\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] in 'aeiou':\n                mask ^= (1 << mp[s[i]])\n            seen[mask] = min(seen[mask], i)\n            max_len = max(max_len, i - seen[mask])\n        return max_len\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        left_states = {'': -1}\n        cur_state = set()\n        ans = 0\n        \n        for i, char in enumerate(s):\n            if char in 'aeiou':\n                if char in cur_state:\n                    cur_state.remove(char)\n                else:\n                    cur_state.add(char)\n            cur_state_str = ''.join(sorted(list(cur_state)))\n            if cur_state_str in left_states:\n                ans = max(ans, i - left_states[cur_state_str])\n            else:\n                left_states[cur_state_str] = i\n                \n        return ans\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        mask = '00000'\n        table = dict()\n        table[mask] = -1\n        vowels = 'aeiou'\n        res = 0\n        for i, c in enumerate(s):\n            for j in range(5):\n                if c==vowels[j]:\n                    mask1 = list(mask)\n                    mask1[j] = str(1 - int(mask1[j]))\n                    mask = ''.join(mask1)\n                    # print('after',i, mask)\n                    \n            \n            pre_idx  = table.get(mask, -2)\n            if pre_idx != -2:\n                res = max(res, i-pre_idx)\n            else:\n                table[mask] = i\n                \n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        cur = 0\n        res = 0\n        seen = {}\n        seen[0]=-1\n        for i, c in enumerate(s):\n            cur ^= 1<<('aeiou'.find(c)+1)>>1\n            if cur not in seen:\n                seen[cur] = i\n            res = max(res, i - seen[cur])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        bits = {'a':1, 'e': 2, 'i': 3, 'o':4, 'u':5}\n        dp = {0:-1}\n        ans, state = 0, 0\n        for i, c in enumerate(s):\n            if c in bits:\n                state ^= (1 << bits[c])\n            ans = max(ans, i-dp.get(state, 128))\n            dp[state] = min(dp.get(state, 128), i)\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        current = [0,0,0,0,0]\n        def convertToInteger():\n            nonlocal current\n            binarySum = 0\n            for num in current:\n                binarySum *= 2\n                binarySum += num\n            return binarySum\n        def incrementVowels(char):\n            ##print(\\\"Current: \\\", current)\n            nonlocal current\n            if char == 'a':\n                current[0] = 1-current[0]\n            elif char == 'e':\n                current[1] = 1-current[1]\n            elif char == 'i':\n                current[2] = 1-current[2]\n            elif char == 'o':\n                current[3] = 1-current[3]\n            elif char == 'u':\n                current[4] = 1-current[4]\n        earliest = {}\n        earliest[0] = -1\n        maxLength = 0\n        current = [0,0,0,0,0]\n        for index,char in enumerate(s):\n            ##print(\\\"Current: \\\",current)\n            incrementVowels(char)\n            binarySum = convertToInteger()\n            if binarySum not in earliest:\n                earliest[binarySum] = index\n            else:\n                maxLength = max(index-earliest[binarySum],maxLength)\n        return maxLength", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        max_substring_size = 0\n        s_len = len(s)\n        for i in range(s_len):\n            if max_substring_size > s_len - i:\n                break\n            vowel_counts = {'a':0,'e':0,'i':0,'o':0,'u':0}\n            allEven = True\n            for k, letter in enumerate(s[i:]):\n                if letter in vowel_counts:\n                    vowel_counts[letter] += 1\n                    currently_all_even = True\n                    for count in list(vowel_counts.values()):\n                        if count % 2 == 1:\n                            currently_all_even = False\n                            break\n                    allEven = currently_all_even\n                if allEven and k + 1 > max_substring_size:\n                    max_substring_size = k + 1\n        return max_substring_size\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        #aeiou\n        vowels = {'a': 1, 'e': 2, 'i': 3, 'o': 4, 'u': 5}\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                cur ^= 1 << vowels[c]\n                seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        remainder_pos_dict = dict()\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        vowel_count = {ch: 0 for ch in vowels}\n        max_length = 0\n        \n        for pos, ch in enumerate(s):\n            if ch in vowels:\n                vowel_count[ch] += 1\n            remainders = (vowel_count['a'] % 2, vowel_count['e'] % 2, vowel_count['i'] % 2, vowel_count['o'] % 2, vowel_count['u'] % 2)\n            if all(map(lambda x: x == 0, remainders)):\n                max_length = max(max_length, pos + 1)\n                continue\n            if remainders not in remainder_pos_dict:\n                remainder_pos_dict[remainders] = pos\n                continue\n            prefix_tail = remainder_pos_dict[remainders]\n            length = pos - prefix_tail\n            max_length = max(length, max_length)\n        \n        return max_length", "class Solution:\n    def flip(self, num, pos):\n        if num & 2**pos:\n            return num - 2**pos\n        else:\n            return num + 2**pos\n\n    def findTheLongestSubstring(self, s: str) -> int:\n        hash = {(0,0,0,0,0): [-1]}\n        maxLen = 0\n        count =  {'a': 0, 'e': 0, 'i': 0, 'u':0, 'o':0}\n        \n        for i in range(len(s)):\n            if s[i] in count:\n                count[s[i]] = (count[s[i]] + 1) % 2\n            set = tuple(count.values())\n            if set in hash:\n                hash[set].extend([i])\n            else:\n                hash[set] = [i]\n            if len(hash[set]) >= 2:\n                maxLen = max(maxLen, hash[set][-1] - hash[set][0])\n        return maxLen\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        P = [0]\n        for c in s:\n            i = 'aeiou'.find(c)\n            mask = (1 << i) if i != -1 else 0\n            P.append(P[-1] ^ mask)\n            \n        ans = 0\n        fst = {}\n        for i, p in enumerate(P):\n            if p in fst:\n                h = fst[p]\n                ans = max(ans, i - h)\n            fst.setdefault(p, i)\n            \n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        first_position = {(0, 0, 0, 0, 0):-1}\n        counter = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n        ans = 0\n        for i, c in enumerate(s):\n            if c in counter:\n                counter[c]+=1\n            key = tuple([counter[c]%2 for c in 'aeiou'])\n            if key not in first_position:\n                first_position[key] = i\n            ans = max(i - first_position[key], ans)\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {(0, 0, 0, 0, 0): -1}\n        counts = {c:0 for c in 'aeiou'}\n        res = 0\n        for i, ch in enumerate(s):\n            if ch in counts:\n                counts[ch] += 1\n            key = tuple([counts[c]%2 for c in 'aeiou'])\n            seen.setdefault(key, i)\n            res = max(res, i-seen[key])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        first_position = {(0, 0, 0, 0, 0):-1}\n        counter = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n        ans = 0\n        for i, c in enumerate(s):\n            if c in counter:\n                counter[c]+=1\n            key = tuple((counter[c]%2 for c in 'aeiou'))\n            if key not in first_position:\n                first_position[key] = i\n            ans = max(i - first_position[key], ans)\n        return ans", "from collections import Counter\nclass Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        _max = 0\n        vowels = 'aeiou'\n        def counter_to_tuple(counter):\n            res = []\n            for v in vowels:\n                res.append(counter[v] % 2)\n            return tuple(res)\n\n        ss_counter = Counter()\n        cache = {(0, 0, 0, 0, 0): -1}\n        length = 0\n        for ind, ss in enumerate(s):\n            if ss in vowels:\n                ss_counter[ss] += 1\n            counter_tuple = counter_to_tuple(ss_counter)\n            if counter_tuple in cache:\n                length = max(length, ind - cache[counter_tuple])\n            else:\n                cache[counter_tuple] = ind\n        return length", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        for window_size in range(len(s), -1, -1): # 4, 3, 2, 1\n            check_range = len(s) - window_size + 1\n            for i in range(check_range):\n                check_wr = s[i: i+window_size]\n                #print(check_wr, len(check_wr))\n                right_string = True\n                for ch in 'aeiou':\n                    if check_wr.count(ch) % 2:\n                        right_string = False\n                        break\n                if right_string:\n                    return window_size\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        \n        seen = {(0, 0, 0, 0, 0): -1}\n        vowel = 'aeiou'\n        count = [0] * 5\n        ans = 0\n        for i in range(len(s)):\n            idx = vowel.find(s[i])\n            if idx >= 0:\n                count[idx] += 1\n            state = tuple([count[i] % 2 for i in range(5)])\n            if state in seen:\n                ans = max(ans, i - seen[state])\n            else:\n                seen[state] = i\n        return ans\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        first_position = {0:-1}\n        bit_ind = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n        ans = key = 0\n        for i, c in enumerate(s):\n            if c in bit_ind:\n                key = key ^ (1 << bit_ind[c])\n            if key not in first_position:\n                first_position[key] = i\n            ans = max(i - first_position[key], ans)\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        s = s + 'a'\n        bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res = 0\n        key = 0\n        for i, char in enumerate(s):                \n            if char in bits:\n                if key in dp:\n                    res = max(res, i-dp[key] - 1)\n                key = key ^ (1 << bits[char])\n                if key not in dp:\n                    dp[key] = i\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        dic = {0:-1}\n        # keep trace the current state of voewls\n        n = 0\n        res = 0\n        voewls = {'a':1,'e':2,'i':4,'o':8,'u':16}\n        \n        for i, c in enumerate(s):\n            if c in voewls:\n                n ^= voewls[c]\n            if n not in dic:\n                dic[n] = i\n            else:\n                res = max(res,i - dic[n])\n        return res\n                \n     \n                \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        # \u4f4d\u64cd\u4f5c\n        cache = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        d, k, res = {0: -1}, 0, 0\n        for i, c in enumerate(s):\n            if c in cache:\n                k ^= cache[c]\n            # \u5982\u679ck\u4e4b\u524d\u51fa\u73b0\u8fc7\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e2d\u95f4\u8fd9\u6bb5\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\n            if k not in d:\n                d[k] = i\n            else:\n                res = max(res, i - d[k])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        memo = {0:0}\n        dic = dict(list(zip('aeiou',list(range(5)))))\n        curr, ans = 0, 0\n        for k,v in enumerate(s,1):\n            if v in dic:\n                curr ^= 1 << dic[v]\n            if curr in memo:\n                ans = max(ans, k - memo[curr])\n            else:\n                memo[curr] = k\n        return ans\n                \n                \n            \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        bits = {'a':1,'e':2,'i':4,'o':8,'u':16}\n        d = {0:-1}\n        n = 0\n        res = 0\n        \n        for i,c in enumerate(s):\n            if c in bits:\n                n ^= bits[c]\n            if n not in d:\n                d[n] = i\n            else:\n                res = max(res,i-d[n])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        cache = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        d, k, res = {0: -1}, 0, 0\n        for i, c in enumerate(s):\n            if c in cache:\n                k ^= cache[c]\n            # \u5982\u679ck\u4e4b\u524d\u51fa\u73b0\u8fc7\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e2d\u95f4\u8fd9\u6bb5\u662f\u6ee1\u8db3\u6761\u4ef6\u7684\n            if k not in d:\n                d[k] = i\n            else:\n                res = max(res, i - d[k])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        \n        # Make a dict of vowels and sequental orders of 2**n \n        # the values are used as bit masks \n        vowels_bit_mask = {v:2**i for i, v in enumerate('aeiou')}\n        vowel_state = 0\n        first_index_of_recorded_state = {0:-1}\n        max_substr_len = 0\n        for index, char in enumerate(s):\n            if char in vowels_bit_mask:\n                # bitwise xor of the current state of the vowels \n                # with the inclusion of the new vowel\n                # i.e A +  E = A+E\n                # 0100 ^= 0001 = 0101\n                vowel_state ^= vowels_bit_mask[char]\n                \n            if vowel_state in first_index_of_recorded_state:\n                max_substr_len = max(max_substr_len, index-first_index_of_recorded_state[vowel_state])\n            else:\n                first_index_of_recorded_state[vowel_state] = index\n        return max_substr_len\n            \n            \n            \n            \n            \n            \n        \n                \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        d, n, r = {0: -1}, 0, 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                n ^= vowels[c]\n            if n not in d:\n                d[n] = i\n            else:\n                r = max(r, i - d[n])\n        return r\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        s = s + 'a'\n        bits, dp = {'a':0,'e':1,'i':2,'o':3,'u':4}, {0:-1}\n        res = 0\n        key = 0\n        for i, char in enumerate(s):                \n            if char in bits:\n                if key in dp:\n                    res = max(res, i-dp[key] - 1)\n                key = key ^ (1 << bits[char])\n                if key not in dp:\n                    dp[key] = i\n        return res", "class Solution:\n    def findTheLongestSubstring(self, S: str) -> int:\n        vowels='aeiou'\n        seen={0:-1}\n        ans=cur=0\n        for i,c in enumerate(S):\n            if c in vowels:\n                cur^=1<<(ord(c)-97)\n            if cur not in seen:\n                seen[cur]=i\n            else:\n                ans=max(ans,i-seen[cur])\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        dic = {0: -1}\n        res = state = 0\n        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        for i, c in enumerate(s):\n            if c in vowels:\n                state ^= vowels[c]\n            if state not in dic:\n                dic[state] = i\n            else:\n                res = max(res, i-dic[state])\n                \n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a':1, 'e':2, 'i':4, 'o':8, 'u':16}\n        d, n, r = {0:-1}, 0, 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                n ^= vowels[c]\n            if n not in d:\n                d[n] = i\n            else:\n                r = max(r, i - d[n])\n        return r\n\n    \n    \n    \n# def findTheLongestSubstring(self, s: str) -> int:\n#     vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n#     d, n, r = {0: -1}, 0, 0\n#     for i, c in enumerate(s):\n#         if c in vowels:\n#             n ^= vowels[c]\n#         if n not in d:\n#             d[n] = i\n#         else:\n#             r = max(r, i - d[n])\n#     return r\n        \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        dict_vol = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n        dict_vol = {x: 1 << y for (x, y) in dict_vol.items()}\n        previous_seen = {0: -1}\n        cur = 0\n        ans = 0\n        for i, c in enumerate(s):\n            if c in dict_vol:\n                cur = cur ^ dict_vol[c]\n            if cur not in previous_seen:\n                previous_seen[cur] = i\n            else:\n                ans = max(ans, i - previous_seen[cur])\n        return ans", "class Solution:\n    # \\\"Time: O(n), Space: O(number of unique vowel count sequences)\\\"\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n        # \\\"d: last_seen_index_for_vowel_sequence_count_map\\\"\n        d, bit_represenation_for_vowel_count, result = {0: -1}, 0, 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                # \\\"n would be 0 if count is even\\\"\n                bit_represenation_for_vowel_count ^= vowels[c]\n            # \\\"any combination of vowels that gives odd count & have not been seen before\\\"\n            if bit_represenation_for_vowel_count not in d:  \n                # \\\"stores the oldest index for which a particular combination of vowels resulted into odd count\\\"\n                d[bit_represenation_for_vowel_count] = i\n            else:\n                # \\\"if a combination is seen again, result = current_index - last_seen_index_for_this_combination (d[n])\\\"\n                # \\\"example: s = \\\"aepqraeae\\\" (odd vowel count for s[:2] is seen again at s[0:]\\\"\n                # \\\"not considering character at last seen index will make count even\\\"\n                result = max(result, i - d[bit_represenation_for_vowel_count])\n        return result", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        # prefix sum strategy with smart tricks for simplicity\n        seen, vowel = {0: -1}, {'a':0,'e':1,'i':2,'o':3,'u':4}\n        res = curr = 0\n        for i, c in enumerate(s):\n            # only update curr when it's a vowel\n            if c in vowel:\n                curr ^= 1 << vowel[c]\n            # insert if not existing or update if exists\n            seen.setdefault(curr, i)\n            res = max(res, i - seen[curr])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        bin_map = collections.defaultdict(int)\n        \n        for (i, c) in enumerate(['a', 'e', 'i', 'o', 'u']):\n            bin_map[c] = 1 << i\n            \n        cur_bin = 0\n        prev_bin = {0: -1}\n        ans = 0\n        \n        \n        for (index, c) in enumerate(s):\n            \n            cur_bin ^= bin_map[c]\n            \n            if cur_bin in prev_bin:\n                ans = max(ans, index - prev_bin[cur_bin])\n            else:\n                prev_bin[cur_bin] = index\n        return ans\n            \n            \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a':1,'e':2,'i':4,'o':8,'u':16}\n        bitmask_to_index, bitmaskrepr, result = {0:-1}, 0, 0\n        for index,item in enumerate(s):\n            if item in vowels:\n                bitmaskrepr ^= vowels[item]\n            if bitmaskrepr not in bitmask_to_index:\n                bitmask_to_index[bitmaskrepr] = index\n            else:\n                result = max(result, index - bitmask_to_index[bitmaskrepr]  )\n        return result", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n\n        masks = {0: -1}\n        mask = 0\n        match = {\n            'a' : 1,\n            'e' : 2,\n            'i' : 4,\n            'o' : 8,\n            'u': 16\n        }\n        max_len = 0\n        for i, ch in enumerate(s):\n            if ch in match:\n                mask = mask ^ (1 << match[ch])\n            if mask in masks:\n                max_len = max(max_len, i - masks[mask])\n            else:\n                masks[mask] = i\n        return max_len", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        \n        vowels = set('aeiou')\n        \n        odd = {tuple() : -1}\n        key = tuple()\n        res = 0\n        \n        window = collections.Counter()\n        vowel_count = [window]\n        for i,char in enumerate(s):\n            if char in vowels:\n                window[char] += 1\n                key = tuple(c for c in window if window[c]&1)\n                if key in odd:\n                    res = max(i - odd[key], res)\n                else:\n                    odd[key] = i\n            else:\n                res = max(i - odd[key], res)\n        else:\n            res = max(i - odd[key], res)\n\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a':1,'e':2,'i':4,'o':8,'u':16}\n        d = {0:-1} # stores binary representation as key for each 0 to i (while i is index in string.)\n        binRep = 0\n        res = 0 # stores longest substring\n        \n        for i,char in enumerate(s):\n            if char in vowels:\n                binRep = binRep ^ vowels[char] # toggles the positions.\n            \n            if binRep not in d:\n                d[binRep] = i\n            else:\n                res = max(res, i - d[binRep])\n        \n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        fst = {0:-1}\n        vowels = {x : (1<<i) for i, x in enumerate('aeiou')}\n        \n        ans = mask = 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                mask ^= vowels[c]\n            fst.setdefault(mask, i)\n            ans = max(ans, i - fst[mask])\n        \n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        n, vowels, d = len(s), 'aeiou', {0: -1}\n        ret = cur = 0\n        for i, c in enumerate(s):\n            if c in vowels:\n                cur ^= 1 << vowels.index(c)\n            d.setdefault(cur, i)\n            ret = max(ret, i - d[cur])\n        return ret", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        digits = {c: i for i, c in enumerate('aeiou')}\n        ans = counter = 0\n        seen = {0: -1}\n        for i, c in enumerate(s):\n            if c in digits:\n                counter ^= 1 << digits[c]\n            seen.setdefault(counter, i)\n            ans = max(ans, i - seen[counter]) \n        return ans\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        dp = {}\n        for k in range(n, 0, -1):\n            for i in range(0, n + 1 - k):\n                if k == n:\n                    s_count = collections.Counter(s)\n                    dp[(i, k)] = [s_count.get(c, 0) % 2 == 0 for c in 'aeiou']\n                elif i == 0:\n                    dp[(i, k)] = self.update_tracker(s[i + k], dp.get((i, k + 1)))\n                else:\n                    dp[(i, k)] = self.update_tracker(s[i - 1], dp.get((i - 1, k + 1)))\n                if all(dp[(i, k)]):\n                    return k\n        return 0\n                \n        \n    def update_tracker(self, char, tracker):\n        idx = 'aeiou'.find(char)\n        new_tracker = list(tracker)\n        if idx > -1:\n            new_tracker[idx] = not tracker[idx]\n        return new_tracker", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        res=0\n        pos={0:-1}\n        state=0  \n        #\u8bb0\u5f55\u5b50\u4e32\u4e2d\u5143\u97f3\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5168\u4e3a0\u8bf4\u660e\u90fd\u662f\u5076\u6570\u6b21\n        #\u82e5\u67091\uff0c\u770b\u770b\u5386\u53f2\u4e2d\u6709\u6ca1\u6709\u8bb0\u5f55\u76f8\u540c\u72b6\u6001\uff0c\u4e2d\u95f4\u5b50\u4e32\u5c31\u662f\u5168\u90e8\u5076\u6570\u6b21\n        vowels='aeiou'\n        for i in range(len(s)):\n            j=vowels.find(s[i])\n            if j>=0:\n                state^=1<<j\n            if state in pos:\n                res=max(res,i-pos[state])\n            else:\n                pos[state]=i\n        return res", "class Solution:\n  def findTheLongestSubstring(self, s: str) -> int:\n    # bitmask aeiou with xxxxx\n    mask, seen, smax, vowels = 0, {0: -1}, 0, {x: 1 << i for i, x in enumerate('aeiou')}\n    for i, x in enumerate(s):\n      if x in vowels:\n        mask ^= 1 << vowels[x]\n      seen.setdefault(mask, i)\n      smax = max(smax, i - seen[mask])\n    return smax", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n\n        for window_size in range(len(s), -1, -1):\n            end_pos = len(s) - window_size + 1\n            for i in range(end_pos):\n                substring = s[i: i+ window_size]\n                is_all_even = True\n                for ch in 'aeiou':\n                    if substring.count(ch) % 2:\n                        is_all_even = False\n                        break\n                if is_all_even:\n                    return window_size\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        state, statedict = 0, {0: -1}\n        voweldict = {'a':1,'e':2, 'i':4, 'o':8, 'u':16}\n        maxlen = 0\n        for i,c in enumerate(s):\n            if c in voweldict:\n                state ^= voweldict[c]\n            if state in statedict:\n                maxlen = max(maxlen, i - statedict[state])\n            else:\n                statedict[state] = i \n        return maxlen", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = 'aeiou'\n        mask = last_mask = 0\n        first = [-1] + [float('inf')] * 31\n        last = [-1] + [float('-inf')] * 31\n        for i, c in enumerate(s):\n            if c in set(vowels):\n                j = vowels.index(c)\n                last_mask, mask = mask, mask ^ (1<<j)\n                if first[mask] == float('inf'):\n                    first[mask] = last[last_mask] + 1 \n            last[mask] = i\n        return max(j-i for i, j in zip(first, last))", "VOWELS = {'a': 1, 'e': 2, 'i': 4, 'o': 8, 'u': 16}\n\nclass Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0:-1}  # -1 to represent everything before the first letter\n        mask = 0\n        longest = 0\n        for ind, char in enumerate(s):\n            mask ^= VOWELS.get(char, 0)  # Key is that mask will be 0 when all vowels are even\n            if mask not in seen:\n                seen[mask] = ind\n            else:  # If we see same nonzero mask, seen[mask]+1 to ind (both inclusive) is even\n                longest = max(longest, ind-seen[mask])\n        return longest\n", "class Solution:\n    \n    def check1(self,ct):\n        if not ct['a'] % 2 and not ct['e'] % 2 and not ct['i'] % 2 and not ct['o'] % 2 and not ct['u'] % 2:\n            return True\n        return False\n        \n    def findTheLongestSubstring(self, s: str) -> int:\n        for i in range(len(s), 0, -1):\n            \n            ctr = collections.Counter(s[0:i])\n            for j in range(len(s)-i+1):\n               \n                if j != 0:\n                    ctr[s[j-1]]-=1\n                    ctr[s[i+j-1]]+=1\n                if self.check1(ctr):\n                    \n                    return i\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        substrings = self.generate_subst(s)\n        res = 0\n        for substring in substrings:\n            is_all_even = True\n            for ch in 'aeiou':\n                if substring.count(ch) % 2:\n                    is_all_even = False\n                    break\n            if is_all_even:\n                return len(substring)\n        return res\n\n    def generate_subst(self, s: str):\n        for window_size in range(len(s), -1, -1):\n            for i in range(len(s) - window_size + 1):\n                yield s[i: i+window_size]", "from collections import defaultdict\nclass Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        res = 0\n        vowel_map = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n        visited = {0: -1}\n        pattern = 0\n        for i, c in enumerate(s):\n            if c in vowel_map:\n                pattern ^= 1 << vowel_map[c]\n            if pattern not in visited:\n                visited[pattern] = i\n            \n            res = max(res, i-visited[pattern])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        idx_dic = {0: -1}\n        vowels = 'aeiou'\n        state = ans = 0\n        for i in range(len(s)):\n            j = vowels.find(s[i])\n            if j >= 0:\n                state ^= 1 << j\n            if state not in idx_dic:\n                idx_dic[state] = i\n            \n            ans = max(ans, i - idx_dic[state])\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = {'a':1,'e':2,'i':3,'o':4,'u':0}\n        bitmask_to_index, bitmaskrepr, result = {0:-1}, 0, 0\n        for index,item in enumerate(s):\n            if item in vowels:\n                bitmaskrepr ^= (1<<vowels[item])\n            if bitmaskrepr not in bitmask_to_index:\n                bitmask_to_index[bitmaskrepr] = index\n            else:\n                result = max(result, index - bitmask_to_index[bitmaskrepr]  )\n        return result", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        state = 0\n        d = {0 : - 1}\n        vowels = {'a': 1,\n                  'e': 2,\n                  'i': 4, \n                  'o': 8,\n                  'u': 16}\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] in vowels:\n                state ^= vowels[s[i]]\n                if state not in d:\n                    d[state] = i\n            \n            if state in d:\n                max_len = max(max_len, i - d[state])\n        \n        return max_len\n                \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = 'aeiou'\n        helper = {0: -1}\n        state = 0\n        res = 0\n        for i, ch in enumerate(s):\n            j = vowels.find(ch)\n            if j >= 0:\n                state ^= 1 << j\n            if state not in helper:\n                helper[state] = i\n            res = max(res, i - helper[state])\n        return res\n                \n            \n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        \n        vowels = set('aeiou')\n        \n        odd = {'' : -1}\n        key = ''\n        res = 0\n        \n        window = collections.Counter()\n        vowel_count = [window]\n        for i,char in enumerate(s):\n            if char in vowels:\n                window[char] += 1\n                key = ''.join(c for c in window if window[c]&1)\n                if key in odd:\n                    res = max(i - odd[key], res)\n                else:\n                    odd[key] = i\n            else:\n                res = max(i - odd[key], res)\n        else:\n            res = max(i - odd[key], res)\n\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        cur = 0\n        res = 0\n        seen = {}\n        seen[0]=-1\n        for i, c in enumerate(s):\n            if c in 'aeiou':\n                cur ^= 1<<('aeiou'.find(c))\n            if cur not in seen:\n                seen[cur] = i\n            res = max(res, i - seen[cur])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        for i in range(len(s),-1,-1):\n            for x in range(len(s) - i +1):\n                counter = 0\n                temp = s[x:x+i]\n                for k in 'aeiou':\n                    if temp.count(k) % 2 != 0:\n                        counter += 1\n                        break\n                if counter == 0:\n                    return i", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        res = 0\n        \n        # cur encodes occurence (odd/even) of 'aeiou'\n        cur = 0\n        seen = {0: -1}\n        for i, char in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(char)+1) >> 1\n            if cur not in seen:\n                seen[cur] = i\n            res = max(res, i-seen[cur])\n        \n        \n        return res", "from collections import defaultdict\nclass Solution:\n    def findTheLongestSubstring(self, string: str) -> int:\n        vowels = 'aeiou'\n        vowels_dict = dict(zip(vowels, range(5)))\n        curr = 0\n        pos_dict = defaultdict(lambda: float('inf'))\n        pos_dict[0] = -1\n        res = 0\n        for i, v in enumerate(string):\n            if v in vowels_dict:\n                curr ^= 1 << vowels_dict[v]\n            res = max(res, i - pos_dict[curr])\n            pos_dict[curr] = min(pos_dict[curr], i)\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = 'aeiou'\n        mask = last_mask = 0\n        first = [-1] + [float('inf')] * 31\n        last = [-1] + [float('-inf')] * 31\n        for i, c in enumerate(s):\n            if c in set(vowels):\n                j = vowels.index(c)\n                last_mask, mask = mask, mask ^ (1<<j)\n                if first[mask] == float('inf'):\n                    first[mask] = last[last_mask] + 1 \n            last[mask] = i\n        # print([(i, j) for i, j in zip(first, last)])\n        return max(j-i for i, j in zip(first, last))", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        digits = {c: i for i, c in enumerate('aeiou')}\n        counters = [0]\n        for c in s:\n            if c in digits:\n                counters.append(counters[-1] ^ (1 << digits[c]))\n            else:\n                counters.append(counters[-1])\n        for length in range(len(s), 0, -1):\n            for j in range(len(s), length - 1, -1):\n                if not counters[j] ^ counters[j - length]:\n                    return length\n        return 0\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        d = {(0, 0, 0, 0, 0): -1}\n        count = [0, 0, 0, 0, 0]\n        pos = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}\n        ans = 0\n        for i, char in enumerate(s):\n            if char in pos:\n                count[pos[char]] = (count[pos[char]] + 1) % 2\n            t = tuple(count)\n            if t in d:\n                ans = max(ans, i - d[t])\n            else:\n                d[t] = i\n        \n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        pos = {c:i for i, c in enumerate('aeiou')}\n        curr = res = 0\n        \n        for i, c in enumerate(s):\n            curr ^= 1 << (pos.get(c, -1)+1) >> 1\n            seen.setdefault(curr, i)\n            res = max(res, i-seen[curr])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        lu = {\n            'a': 0,\n            'e': 1,\n            'i': 2,\n            'o': 3,\n            'u': 4\n        }\n        def setFlags(flags: int, ch: str) -> int:\n            if ch in lu.keys():\n                mask = 1 << lu[ch]\n                flags = flags ^ mask\n            return flags\n        FLAGS = 0\n        seen = {0: -1}\n        m = 0\n        for i, c in enumerate(s):\n            FLAGS = setFlags(FLAGS, c)\n            if FLAGS in seen.keys():\n                m = max(m, i - seen[FLAGS])\n            else:\n                seen[FLAGS] = i\n        return m", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            if cur not in seen:\n                seen[cur] = i\n            res = max(res, i - seen[cur])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        masks = {'a':16, 'e':8, 'i':4, 'o':2, 'u':1}\n        num = 0\n        numToIdx = {0:-1}\n        ans = 0\n        for i, ch in enumerate(s):\n            if ch in masks:\n                num ^= masks[ch]\n            if num not in numToIdx:\n                numToIdx[num] = i\n            ans = max(ans, i - numToIdx[num])\n        return ans", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        # https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaC%2B%2BPython-One-Pass\n        # https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531930/This-problem-should-be-marked-as-hard\n        aeiou = {\n            'a': 0,\n            'e': 1,\n            'i': 2,\n            'o': 3,\n            'u': 4\n        }\n        seen = {0:-1}\n        res = curr = 0\n        for i, c in enumerate(s):\n            curr ^= 1 <<(aeiou.get(c, -1) + 1) >> 1\n            seen.setdefault(curr, i)\n            res = max(res, i-seen[curr])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        # https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaC%2B%2BPython-One-Pass\n        # https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531930/This-problem-should-be-marked-as-hard\n        aeiou = { c:i for i, c in enumerate('aeiou') }\n        seen = {0:-1}\n        res = curr = 0\n        for i, c in enumerate(s):\n            curr ^= 1 <<(aeiou.get(c, -1) + 1) >> 1\n            seen.setdefault(curr, i)\n            res = max(res, i-seen[curr])\n        return res\n", "from copy import copy\n\nclass Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowel2idx = dict([(item[1], item[0]) for item in enumerate(['a', 'e', 'i', 'o', 'u'])])\n        \n        counters = [[0] * len(vowel2idx)]\n        for item in s:\n            counters.append(counters[-1].copy())\n            if item in vowel2idx:\n                counters[-1][vowel2idx[item]] += 1\n        \n        for width in range(len(s), 0, -1):\n            for start in range(len(s) - width + 1):\n                for n_vowels in map(int.__sub__, counters[start + width], counters[start]):\n                    if n_vowels % 2 == 1:\n                        break\n                else:\n                    return width\n        return 0\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        digits = {c: i for i, c in enumerate('aeiou')}\n        counters = [0]\n        for c in s:\n            counters.append(counters[-1] ^ (1 << digits[c]) if c in digits else counters[-1])\n        for length in range(len(s), 0, -1):\n            for j in range(len(s), length - 1, -1):\n                if not counters[j] ^ counters[j - length]:\n                    return length\n        return 0", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        vowels = 'aeiou'\n        mask = last_mask = 0\n        first = [-1] + [float('inf')] * 31\n        last = [-1] + [float('-inf')] * 31\n        for i, c in enumerate(s):\n            if c in set(vowels):\n                j = vowels.index(c)\n                last_mask, mask = mask, mask ^ (1<<j)\n                if first[mask] == float('inf'):\n                    first[mask] = last[last_mask] + 1 \n            last[mask] = i\n        # print([(i, j) for i, j in zip(first, last)])\n        return max(j-i for i, j in zip(first, last) if j-i<=len(s))", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        dp = [-1] + [len(s)] * 31\n        mask = 0\n        res = 0\n        for i, c in enumerate(s):\n            if c in 'aeiou':\n                mask ^= 1 << 'aeiou'.index(c)\n                \n            dp[mask] = min(dp[mask], i)\n            res = max(res, i - dp[mask])\n                \n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        seen = {0: -1}\n        res = cur = 0\n        for i, c in enumerate(s):\n            cur ^= 1 << ('aeiou'.find(c) + 1) >> 1\n            seen.setdefault(cur, i)\n            res = max(res, i - seen[cur])\n        return res\n", "class Solution:\n    def findTheLongestSubstring(self, s: str) -> int:\n        m = dict(a=1, e=0b10, i=0b100, o=0b1000, u=0b10000)\n        longest = 0\n        parity_index = {0: -1}\n        parity = 0\n        for i, ch in enumerate(s):\n            if ch in m:\n                parity = parity ^ m[ch]\n            if parity not in parity_index:\n                parity_index[parity] = i\n            else:\n                longest = max(longest, i - parity_index.get(parity))\n        return longest                "]
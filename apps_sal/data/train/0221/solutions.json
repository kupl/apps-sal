["class Solution:\n    def longestDupSubstring(self, S):\n        nums, N = [ord(c) - ord('a') for c in S], len(S)\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = (cur_hash * BASE + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)\n            for idx, val in enumerate(nums[L:]):\n                cur_hash -= nums[idx] * X\n                cur_hash = (cur_hash * BASE + val) % MOD\n                if cur_hash in seen:\n                    return idx + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, N + 1\n        start = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                start = idx\n            else:\n                high = mid\n        return S[start: start + low - 1]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def has_duplicate(m, S):\n            val, Mod = 0, 2**63-1\n            for i in range(m):\n                val = (26*val + ord(S[i])) % Mod\n            \n            d = set([val])\n            const = 26**m % Mod\n            for i in range(m, len(S)):\n                val = (26*val + ord(S[i]) - ord(S[i-m])*const) % Mod\n                if val in d: return i-m+1\n                d.add(val)\n            return -1\n        \n        l, r = 0, len(S)\n        start, length = -1, 0\n        while l<=r:\n            mid = l + (r-l)//2\n            idx = has_duplicate(mid, S)\n            if idx!=-1:\n                l = mid + 1\n                start, length = idx, mid\n            else:\n                r = mid - 1\n                \n        if start==-1: return ''\n        return S[start:start+length]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        A = [ord(c) for c in S]\n        mod = 2**63-1\n        \n        lo = 0\n        hi = len(S)\n        res = 0\n        \n        def test(sz):\n            val = 0\n            p = pow(26,sz,mod)\n            for i in range(sz):\n                val = val*26+A[i]\n                val %= mod\n            seen = {val}\n            for i in range(sz, len(A)):\n                val = val*26+A[i]-A[i-sz]*p\n                val = val%mod\n                if val in seen:\n                    return i-sz+1\n                seen.add(val)\n            return -1     \n        \n        while lo < hi:\n            mid = (lo+hi)//2\n            pos = test(mid)\n            if not pos >= 0:\n                hi = mid\n            else:\n                res = pos\n                lo = mid+1\n        \n        return S[res:res+lo-1]\n        \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def check(L):\n            base = 26\n            modulo = 2**32\n            AL = base**L%modulo\n            hk = 0\n            for i in range(L):\n                hk = hk*base + nums[i]\n            hk %= modulo\n            hm = {hk:0}\n            for i in range(L, len(S)):\n                hk = (hk*base-nums[i-L]*AL+nums[i])%modulo\n                if hk in hm and S[i-L+1:i+1]==S[hm[hk]:hm[hk]+L]:\n                    return i-L+1\n                hm[hk] = i-L+1\n                \n            return -1\n        \n        nums = [ord(c)-ord('a') for c in S]\n        res = -1\n        s, e = 1, len(S)\n        while s<=e:\n            m = s+(e-s)//2\n            pos = check(m)\n            if pos!=-1:\n                res = pos\n                s = m+1\n            else:\n                e = m-1\n                \n        return S[res:res+e]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def test(L):\n            base = 26\n            modulus = 2**32\n            AL = base**L%modulus\n            hk = 0\n            for i in range(L):\n                hk=hk*base+nums[i]\n            hk%=modulus\n            hs=set([hk])\n            \n            for i in range(L, len(S)):\n                hk = hk*base-nums[i-L]*AL+nums[i]\n                hk%=modulus\n                if hk in hs:\n                    return i-L+1\n                hs.add(hk)\n        \n        nums = [ord(c)-ord('a') for c in S]\n        start, end = 1, len(S)\n        res = -1\n        while start<=end:\n            mid = start+(end-start)//2\n            pos = test(mid)\n            \n            if pos:\n                res = pos\n                start = mid+1\n            else:\n                end = mid-1\n            \n        return S[res:res+end]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        n=len(S)\n        mod=10**30\n        ord_a=97\n        \n        def find_len_k_dup(k):\n            hash_val=0\n            seen=set()\n            for i in range(k):\n                hash_val=(hash_val*26+(ord(S[i])-ord_a))%mod\n            seen.add(hash_val)\n            power=26**k%mod\n            \n            for i in range(1,n-k+1):\n                hash_val=((hash_val*26-(ord(S[i-1])-ord_a)*power)%mod+(ord(S[i+k-1])-ord_a))%mod\n                if hash_val in seen:\n                    return i\n                seen.add(hash_val)\n            return None\n            \n#         self.s=S\n#         self.n=len(S)\n#         def find_len_k_dup(length):\n#             hash_value = 0\n#             mod_value = 8000*(2**30) # a big number should be okay, if you change the number it might cause a wrong answer\n#             seen = set()\n#             for i in range(length):\n#                 hash_value = (hash_value*26+ord(self.s[i])-ord('a'))%mod_value # get the hash value\n#             seen.add(hash_value)\n#             tmp = pow(26, length)%mod_value\n#             for i in range(1,self.n-length+1):\n#                 # get the moving hash \n#                 hash_value = ((hash_value*26 - (ord(self.s[i-1])-ord('a'))*tmp)%mod_value+ord(self.s[i+length-1])-ord('a'))%mod_value\n#                 if hash_value in seen:\n#                     return i\n#                 else:\n#                     seen.add(hash_value)\n#             return None\n        \n        \n                \n        \n        low=0\n        high=len(S)\n        res=''\n        while low<high:\n            \n            mid=(low+high)//2\n            idx=find_len_k_dup(mid)\n            #print(candidate)\n            if idx is not None:\n                res=S[idx:idx+mid]\n                low=mid+1\n            else:\n                high=mid\n        return res", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        A = [ord(c) - ord('a') for c in S]\n        mod = 2**63 - 1\n        def isDuplicate(len_s):\n            p = pow(31, len_s, mod)\n            seen = collections.defaultdict(list)\n            cur = reduce(lambda x,y: (x*31+y)%mod, A[:len_s])\n            seen[cur].append(0)\n            for j in range(1, len(A)-len_s+1):\n                cur = (cur*31 - A[j-1]*p + A[j+len_s-1])%mod\n                if cur in seen:\n                    for i in seen[cur]:\n                        if S[i:i+len_s] == S[j:j+len_s]:\n                            return j\n                seen[cur].append(j)\n            return 0\n        \n        l, r = 1, len(S)-1\n        ans = ''\n        while l <= r:\n            mid = l + (r-l)//2\n            pos = isDuplicate(mid)\n            if pos:\n                ans = S[pos:pos+mid]\n                l = mid + 1\n            else:\n                r = mid -1\n        return ans \n                \n                \n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        A = [ord(c) - ord('a') for c in S]\n        mod = 2**63 - 1\n        \n        def test(L):\n            p = pow(26, L, mod)\n            cur = reduce(lambda x, y: (x * 26 + y) % mod, A[: L], 0)\n            seen = set()\n            seen.add(cur)\n            for i in range(L, len(A)):\n                cur = (cur * 26 + A[i] - A[i - L] * p) % mod\n                if cur in seen:\n                    return i - L + 1\n                seen.add(cur)\n        \n        res, lo, hi = 0, 0, len(S)\n        while lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            pos = test(mid)\n            if pos:\n                lo = mid\n            else:\n                hi = mid\n        \n        if test(hi):\n            pos = test(hi)\n            return S[pos: pos + hi]\n        pos = test(lo)\n        return S[pos: pos + lo]\n", "class Solution:\n    def longestDupSubstring(self, S):\n        nums = [ord(c) - ord('a') for c in S]\n        #BASE, MOD = 113, 1000000007\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD) # (BASE ** (L-1)) % MOD\n            for i, val in enumerate(nums[L:]):\n                # cur_hash -= nums[i] * (BASE ** (L-1))\n                cur_hash -= nums[i] * X\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n                if cur_hash in seen:\n                    return i + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, len(S) + 1\n        res = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                res = idx\n            else:\n                high = mid\n        return S[res: res + low-1]\n        \n        #while low <= high:\n        #    mid = (low + high)//2\n        #    idx = check(mid)\n        #    if idx != -1:\n        #        low = mid + 1\n        #        res = idx\n        #    else:\n        #        high = mid - 1\n        #return S[res: res + low-1]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def checkSubstrings(size):\n            hashed = 0\n            pow_mult = pow(26, size) % mod\n            \n            for i in range(size):\n                hashed *= 26\n                hashed += char_vals[i]\n            \n            hashed %= mod\n            seen = {hashed}\n            \n            for i in range(size, len(S)):\n                hashed = (hashed * 26 - char_vals[i-size] * pow_mult + char_vals[i]) % mod\n                if hashed in seen:\n                    return i-size+1\n                seen.add(hashed)\n            \n            return None\n\n        s, f = 0, len(S)\n        longest = 0\n        \n        char_vals = [ord(c) - ord('a') for c in S]\n        mod = pow(2, 63) - 1\n        \n        while s < f:\n            m = s + (f-s+1) // 2\n            longest_check = checkSubstrings(m)\n            if longest_check:\n                longest = longest_check\n                s = m\n            else:\n                f = m-1\n        \n        return S[longest:longest+s]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        # def RabinKarp(text, M, q):\n        #     if M == 0: return True\n        #     h, t, d = (1<<(8*M-8))%q, 0, 256\n        #     dic = defaultdict(list)\n        #     for i in range(M): \n        #         t = (d * t + ord(text[i]))% q\n        #     dic[t].append(i-M+1)\n        #     for i in range(len(text) - M):\n        #         t = (d*(t-ord(text[i])*h) + ord(text[i + M]))% q\n        #         for j in dic[t]:\n        #             if text[i+1:i+M+1] == text[j:j+M]:\n        #                 return (True, text[j:j+M])\n        #         dic[t].append(i+1)\n        #     return (False, \\\"\\\")\n\n\n        def check(sz):\n            seen = defaultdict(list)\n            cur, base, MOD = 0, 256, (1<<31) - 1\n            h = (1 << (sz*8)) % MOD\n            for i in range(sz):\n                cur *= base\n                cur += ord(S[i])\n                cur %= MOD\n            seen[cur].append(0)\n            for i in range(sz,len(S)):\n                cur *= base\n                cur += ord(S[i])\n                cur -= ord(S[i-sz])*h \n                cur %= MOD\n                for j in seen[cur]:\n                    if S[j:j+sz] == S[i-sz+1:i+1]:\n                        return True, S[i-sz+1:i+1]\n                seen[cur].append(i-sz+1)\n            return False, ''\n\n        lo, hi = 1, len(S)\n        res = ''\n        # MOD = (1<<31) - 1\n        while lo <= hi:\n            mid = (lo+hi)//2\n            flag, tmp = check(mid)\n            # flag, tmp = RabinKarp(S, mid, q)\n            if flag:\n                lo = mid + 1\n                res = tmp\n                # print(mid,res)\n            else:\n                hi = mid - 1\n        # print(lo,hi)\n        return res \n\n\n# class Solution:\n#     def RabinKarp(self,text, M, q):\n#         if M == 0: return True\n#         h, t, d = (1<<(8*M-8))%q, 0, 256\n\n#         dic = defaultdict(list)\n\n#         for i in range(M): \n#             t = (d * t + ord(text[i]))% q\n\n#         dic[t].append(i-M+1)\n\n#         for i in range(len(text) - M):\n#             t = (d*(t-ord(text[i])*h) + ord(text[i + M]))% q\n#             for j in dic[t]:\n#                 if text[i+1:i+M+1] == text[j:j+M]:\n#                     return (True, text[j:j+M])\n#             dic[t].append(i+1)\n#         return (False, \\\"\\\")\n\n#     def longestDupSubstring(self, S):\n#         beg, end = 0, len(S)\n#         q = (1<<31) - 1 \n#         Found = \\\"\\\"\n#         while beg + 1 < end:\n#             mid = (beg + end)//2\n#             isFound, candidate = self.RabinKarp(S, mid, q)\n#             if isFound:\n#                 beg, Found = mid, candidate\n#             else:\n#                 end = mid\n\n#         return Found\n", "class Solution:\n    def search(self, S, mid) -> str:\n        n = len(S)\n        # convert string to array of integers to implement constant time slice\n        self.nums = [ord(S[i]) - ord('a') for i in range(n)]\n        # base value for the rolling hash function\n        base = 26\n        # mod value for the rolling hash function to avoid overflow\n        MOD = 2**32\n    \n        # compute the hash of string S[:L]\n        hash_ = 0\n        for i in range(mid):\n            hash_ = (hash_ * base + self.nums[i]) % MOD\n              \n        # already visited hashes of strings of length L\n        visited = {hash_}\n        # const value to be used often : a**L % mod\n        aL = pow(base, mid, MOD)\n        for start in range(1, n - mid + 1):\n            # compute rolling hash in O(1) time\n            hash_ = (hash_ * base - self.nums[start - 1] * aL + self.nums[start + mid - 1]) % MOD\n            if hash_ in visited:\n                return start\n            visited.add(hash_)\n        return -1\n        \n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        # convert string to array of integers to implement constant time slice\n        self.nums = [ord(S[i]) - ord('a') for i in range(n)]\n        # base value for the rolling hash function\n        base = 26\n        # mod value for the rolling hash function to avoid overflow\n        MOD = 2**32\n        \n        # binary search, L = repeating string length\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if self.search(S, mid) != -1:\n                left = mid + 1\n            else:\n                right = mid - 1\n               \n        start = self.search(S, left - 1)\n        return S[start: start + left - 1]\n    \n    \n    \n    \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def rk(m):\n            \n            nonlocal idx\n            mp = {}\n            p = b**(m-1)\n            p%=mod\n            \n            y = 0\n            for i in range(m):\n                y = y*b+num[i]\n            y%=mod    \n            \n            mp[y] = 0\n                \n            for i in range(1, n-m+1):\n                y = ((y-num[i-1]*p%mod)*b%mod+num[i-1+m])%mod\n                #y = (y-num[i-1]*p)*b+num[i-1+m]\n                \n                if y in mp:\n                    idx = i\n                    return 0\n                else:\n                    mp[y]=i\n            \n            return 1\n                \n            \n\n        n = len(S)\n        b = 26                      # no need to be 128\n        #mod = 10**9+7              # too small => conflict\n        mod = 2**32                 # here\n        \n        z = ord('a')\n        num = [ ord(S[i])-z for i in range(n)]\n        \n        l=1\n        r=n\n        idx = 0  # last found duplicate                 \n        while l<r:\n            \n            m = (l+r)//2\n            \n            if rk(m)>0:\n                r = m\n            else:\n                l = m+1\n        \n        return S[idx:idx+l-1]\n        \n        \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def rk(m):\n            \n            mp = {}\n\n            p = b**(m-1)\n            p%=mod\n            \n            y = 0\n            for i in range(m):\n                y = y*b+num[i]\n            y%=mod    \n            \n            mp[y] = 0\n                \n            for i in range(1, n-m+1):\n                y = ((y-num[i-1]*p%mod)*b%mod+num[i-1+m])%mod\n                #y = (y-num[i-1]*p)*b+num[i-1+m]\n                \n                if y not in mp:\n                    mp[y]=i\n                else:\n                    return i\n            \n            return n\n                \n            \n        \n        \n        n = len(S)\n        \n        b = 26                      # no need to be 128\n        \n        #mod = 10**9+7              # too small => conflict\n        mod = 2**32                 # here\n        \n        num = []\n        for i in range(n):\n            num.append(ord(S[i])-ord('a'))\n        \n        l=1\n        r=n\n        \n        while l<r:\n            \n            m = (l+r)//2\n            \n            if rk(m)==n:\n                r = m\n            else:\n                l = m+1\n       \n        \n        x = l-1\n        \n        if x==0:\n            return ''\n        \n        k = rk(x)\n        \n        return S[k:k+x]\n        \n        \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def rk(m):\n            \n            nonlocal idx\n            st = set()\n            p = b**(m-1)\n            p%=mod\n            \n            y = 0\n            for i in range(m):\n                y = y*b+num[i]\n            \n            y%=mod\n            \n            st.add(y)\n                \n            for i in range(1, n-m+1):\n                y = ((y-num[i-1]*p%mod)*b%mod+num[i-1+m])%mod\n                #y = (y-num[i-1]*p)*b+num[i-1+m]\n                \n                if y in st:\n                    idx = i\n                    return 0\n                else:\n                    st.add(y)\n            \n            return 1\n                \n            \n\n        n = len(S)\n        b = 26                      # no need to be 128\n        #mod = 10**9+7              # too small => conflict\n        mod = 2**32                 # here\n        \n        z = ord('a')\n        num = [ ord(S[i])-z for i in range(n)]\n        \n        l=1\n        r=n\n        idx = 0  # last found duplicate                 \n        while l<r:\n            \n            m = (l+r)//2\n            \n            if rk(m)>0:\n                r = m\n            else:\n                l = m+1\n        \n        return S[idx:idx+l-1]\n        \n        \n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        \n        A = [ord(c) - ord('a') for c in S]\n        mod = 2**63 - 1\n\n        def test(L):\n            # print(26, L, mod)\n            p = pow(26, L, mod)\n            cur = reduce(lambda x, y: (x * 26 + y) % mod, A[:L], 0)\n            seen = {cur}\n            for i in range(L, len(S)):\n                cur = (cur * 26 + A[i] - A[i - L] * p) % mod\n                if cur in seen: return i - L + 1\n                seen.add(cur)\n        res, lo, hi = 0, 0, len(S)\n        while lo < hi:\n            mi = (lo + hi + 1) // 2\n            pos = test(mi)\n            if pos:\n                lo = mi\n                res = pos\n            else:\n                hi = mi - 1\n        return S[res:res + lo]\n        \n#         s = [ord(num) - ord(\\\"a\\\") for num in S]\n        \n#         mod = 10 ** 9 + 7\n#         def check(l):\n#             cur = 0\n#             seen = set()\n#             maxBASE = pow(26, l-1, mod)\n#             for i in range(len(s)):\n#                 if i < l:\n#                     cur = (cur * 26 + s[i]) % mod\n#                 else:\n#                     cur -= maxBASE * s[i-l]\n#                     cur = (cur * 26 + s[i]) % mod\n#                 if i == l-1:\n#                     seen.add(cur)\n#                 elif i >= l:\n#                     if cur in seen:\n#                         return i-l+1\n#                     else:\n#                         seen.add(cur)\n#             return 0\n                \n                \n                \n        \n#         l = 1\n#         r = len(S) - 1\n#         res = -1\n#         while l < r:\n#             m = (l+r) // 2\n#             pos = check(m)\n#             if pos:\n#                 l = m \n#                 res = pos\n#             else:\n#                 r = m - 1\n#         return S[res:res + l]\n            \n        \n            \n", "class Solution:\n    def longestDupSubstring(self, S):\n        nums, N = [ord(c) - ord('a') for c in S], len(S)\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = (cur_hash * BASE + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)\n            for idx, val in enumerate(nums[L:]):\n                cur_hash -= nums[idx] * X\n                cur_hash = (cur_hash * BASE + val) % MOD\n                if cur_hash in seen:\n                    return idx + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, N + 1\n        start = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                start = idx\n            else:\n                high = mid\n        return S[start: start + low - 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.s=S\n        self.n=len(S)\n        def find_len_k_dup(length):\n            hash_value = 0\n            mod_value = 7919*(2**30) # a big number should be okay, if you change the number it might cause a wrong answer\n            seen = set()\n            for i in range(length):\n                hash_value = (hash_value*26+ord(self.s[i])-ord('a'))%mod_value # get the hash value\n            seen.add(hash_value)\n            tmp = pow(26, length)%mod_value\n            for i in range(1,self.n-length+1):\n                # get the moving hash \n                hash_value = (hash_value*26 - (ord(self.s[i-1])-ord('a'))*tmp+mod_value+ord(self.s[i+length-1])-ord('a'))%mod_value\n                if hash_value in seen:\n                    return i\n                else:\n                    seen.add(hash_value)\n            return None\n                \n        \n        low=0\n        high=len(S)\n        res=''\n        while low<high:\n            \n            mid=(low+high)//2\n            idx=find_len_k_dup(mid)\n            #print(candidate)\n            if idx is not None:\n                res=S[idx:idx+mid]\n                low=mid+1\n            else:\n                high=mid\n        return res", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        lo = 1\n        hi = len(S)\n        nums = [ord(i) - ord('a') for i in S]\n        self.modulus = 2 ** 32\n        \n        def dup(l):\n            seen = set()\n            hval = 0\n            for i in range(l):\n                hval = (hval*26 + nums[i]) % self.modulus\n            seen.add(hval)\n            al = pow(26,l,self.modulus)\n            for i in range(1,len(S) - l+1):\n                hval = (hval*26 - nums[i-1]*al + nums[i+l-1]) % self.modulus\n                if hval in seen:\n                    return i\n                seen.add(hval)\n            return -1\n        \n        start = -1\n        while lo <= hi:\n            mi = lo + (hi-lo)//2\n            begin = dup(mi)\n            if begin != -1:\n                lo = mi + 1\n                start = begin\n            else:\n                hi = mi - 1\n        \n        return S[start: start + lo - 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        N = len(S)\n        l, r = 1, N\n        nums = [ord(x) - ord('a') for x in S]\n        KMAX = 2 ** 63 - 1\n        def check(m):\n            MAXL = pow(26, m, KMAX)\n            total = 0\n            hashset = set()\n            for i in range(m):\n                total = (total * 26 + nums[i]) % KMAX\n            hashset.add(total)\n            for i in range(1, N - m + 1):\n                total = (total * 26 - MAXL * nums[i-1] + nums[i + m - 1]) % KMAX\n                if total in hashset:\n                    return i\n                hashset.add(total)\n            return -1         \n        \n        while l < r:\n            m = (l + r) // 2\n            if check(m) < 0:\n                r = m\n            else:\n                l = m + 1\n        idx = check(r - 1)        \n        return S[idx: idx + r-1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.s=S\n        self.n=len(S)\n        def find_len_k_dup(length):\n            hash_value = 0\n            mod_value = 8000*(2**30) # a big number should be okay, if you change the number it might cause a wrong answer\n            seen = set()\n            for i in range(length):\n                hash_value = (hash_value*26+ord(self.s[i])-ord('a'))%mod_value # get the hash value\n            seen.add(hash_value)\n            tmp = pow(26, length)%mod_value\n            for i in range(1,self.n-length+1):\n                # get the moving hash \n                hash_value = ((hash_value*26 - (ord(self.s[i-1])-ord('a'))*tmp)%mod_value+ord(self.s[i+length-1])-ord('a'))%mod_value\n                if hash_value in seen:\n                    return i\n                else:\n                    seen.add(hash_value)\n            return None\n                \n        \n        low=0\n        high=len(S)\n        res=''\n        while low<high:\n            \n            mid=(low+high)//2\n            idx=find_len_k_dup(mid)\n            #print(candidate)\n            if idx is not None:\n                res=S[idx:idx+mid]\n                low=mid+1\n            else:\n                high=mid\n        return res", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        A = [ord(c) - ord('a') for c in S]\n        mod = 2**63 - 1\n\n        def test(L):\n            p = pow(26, L, mod)\n            cur = reduce(lambda x, y: (x * 26 + y) % mod, A[:L], 0)\n            seen = {cur}\n            for i in range(L, len(S)):\n                cur = (cur * 26 + A[i] - A[i - L] * p) % mod\n                if cur in seen: return i - L + 1\n                seen.add(cur)\n        res, lo, hi = 0, 0, len(S)\n        while lo + 1 < hi:\n            mi = (lo + hi) // 2\n            pos = test(mi)\n            if pos:\n                lo = mi\n            else:\n                hi = mi\n        \n        if test(hi):\n            res = test(hi)\n            return S[res: res + hi]\n        elif test(lo):\n            res = test(lo)\n            return S[res: res + lo]\n        # return ''\n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S):\n        def evaluateLength(length):\n            power = pow(26, length, mod)\n            current = reduce(lambda x, y: (x*26 + y) % mod, ids[:length], 0)\n            explored = {current}\n            for index in range(length, len(S)):\n                current = (current * 26 + ids[index] - ids[index - length] * power) % mod\n                if current in explored:\n                    return index - length + 1\n                explored.add(current)\n        \n        ids = [ord(character) - ord('a') for character in S]\n        mod = 2**63 - 1\n        index, low, high = 0, 0, len(S)\n        while low < high:\n            mid = (high + low + 1) // 2\n            position = evaluateLength(mid)\n            if position:\n                index = position\n                low = mid\n            else:\n                high = mid - 1 \n        return S[index:(index+low)]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        N = len(S)\n        l, r = 1, N\n        nums = [ord(x) - ord('a') for x in S]\n        KMAX = 2 ** 63 - 1\n        def check(m):\n            MAXL = pow(26, m, KMAX)\n            total, hashset = 0, set()\n            for i in range(m):\n                total = (total * 26 + nums[i]) % KMAX\n            hashset.add(total)\n            for i in range(1, N - m + 1):\n                total = (total * 26 - MAXL * nums[i-1] + nums[i+m-1]) % KMAX\n                if total in hashset:\n                    return i\n                hashset.add(total)\n            return -1\n        \n        while l < r:\n            m = (l + r) // 2\n            if check(m) < 0:\n                r = m\n            else:\n                l = m + 1\n        idx = check(r - 1)        \n        return S[idx: idx + r-1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def check(s, L):\n            n = len(s)\n            BASE = 26\n            MOD = 1 << 61 - 1\n            P = pow(26, L, MOD)\n            cur = 0\n            seen = defaultdict(list)\n            \n            for i in range(len(s)):\n                cur = (cur*BASE + ord(s[i]) - ord('a')) % MOD\n                if i >= L:\n                    cur = (cur - (ord(s[i-L]) - ord('a')) * P) % MOD\n                \n                if i >= L - 1:\n                    if cur in seen:\n                        cur_str = s[i-L+1:i+1]\n                        for j in seen[cur]:\n                            pre_str = s[j-L+1:j+1]\n                            if cur_str == pre_str:\n                                return cur_str\n                    seen[cur].append(i)       \n            return ''\n            \n            \n        lo, hi = 1, len(S)\n        ans = ''\n        while lo < hi:\n            mid = (lo + hi) // 2\n            temp = check(S, mid)\n            if temp:\n                ans = temp\n                lo = mid + 1\n            else:\n                hi = mid\n\n        return ans\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        p = 239017\n        pows = [[1], [1]]\n        hsh = [[0], [0]]\n        mods = [int(1e9) + 7, int(1e9) + 9]\n        for ch in S:\n            for i in range(len(mods)):\n                hsh[i].append((hsh[i][-1] + ord(ch) * pows[i][-1]) % mods[i])\n                pows[i].append((pows[i][-1] * p) % mods[i])               \n        l = 0\n        r = len(S)\n        substrs = {}\n        ans = ''\n        while r - l > 1:\n            m = (r + l) // 2\n            found = False\n            for i in range(0, len(S) - m + 1):\n                h0 = ((hsh[0][i + m] - hsh[0][i]) * pows[0][-(i + 1)]) % mods[0]\n                h1 = ((hsh[1][i + m] - hsh[1][i]) * pows[1][-(i + 1)]) % mods[1]\n                if (h0, h1) in substrs:\n                    found = True\n                    ans = S[i: i + m]\n                    break\n                else:\n                    substrs[(h0, h1)] = True\n            if found:\n                l = m\n            else:\n                r = m\n            substrs.clear()\n        return ans", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        mod = 2 ** 31 - 1\n        base = 26\n        \n        def get_ord(char: str):\n            return ord(char) - ord('a')\n        \n        def find_duplicate(length) -> str:\n            hashes = {}\n            h = 1\n            for i in range(length - 1):\n                h = (h * base) % mod\n\n            cur = 0\n            for i in range(length):\n                cur = (cur * base + get_ord(S[i])) % mod\n            \n            hashes[cur] = [0]\n\n            for i in range(1, len(S) - length + 1):\n                cur = ((cur - (get_ord(S[i-1]) * h)) * base + get_ord(S[i + length - 1])) % mod\n                if cur in hashes:\n                    for idx in hashes[cur]:\n                        if S[idx: idx + length] == S[i: i + length]:\n                            return S[i: i + length]\n                    hashes[cur].append(i)\n                else:\n                    hashes[cur] = [i]\n            return ''\n        \n        \n        def helper(start, end):\n            res = ''\n            while start < end:\n                length = (start + end) // 2 + 1\n                r = find_duplicate(length)\n                if len(r) > len(res):\n                    res = r\n                if not r:\n                    end = length - 1\n                else:\n                    start = length\n            return res\n\n        return helper(0, len(S) - 1)", "class Solution:\n    def findRepSubstrGivenLength(self, nums: List[int], l:int, base:int, modulus:int) -> int:\n        \n        n = len(nums)\n        \n        h = 0\n        for i in range(l):\n            h = (h * base + nums[i]) % modulus\n            \n        seen = {h}\n            \n        for start in range(1, n-l+1):\n            h = (h * base - nums[start - 1] * pow(base, l, modulus) + nums[start + l - 1]) % modulus\n            \n            if h in seen:\n                return start\n            \n            seen.add(h)\n            \n        return -1    \n    \n    \n    def longestDupSubstring(self, S: str) -> str:\n        if not S:\n            return ''\n                \n        nums = [ord(S[i]) - ord('a') for i in range(len(S))]\n        \n        base = 26\n        modulus = 2**32\n        \n        left = 1\n        right = len(S)\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if self.findRepSubstrGivenLength(nums, mid, base, modulus) != -1:\n                left = mid + 1\n            else:\n                right = mid -1\n                \n        start = self.findRepSubstrGivenLength(nums, left-1, base, modulus)\n        \n        return S[start: start + left -1]    \n        \n        \n        \n'''\nclass Solution:\n    class Node:\n        def __init__(self, v='*'): \n            self.value = v\n            self.next = dict()\n            self.occurences = set()\n                   \n                \n    def print_tree(self, node, indentation):\n        print(indentation + str(node.value) + \\\": \\\" + str(node.occurences))\n\n        for v in node.next.keys():\n            self.print_tree(node.next[v], indentation + '\\\\t')\n        \n        \n    def getNode(self, node, v):\n        if v not in node.next.keys():\n            node.next[v] = self.Node(v)\n\n        return node.next[v]\n\n\n    def AddOccurences(self, node, i, S):\n        node.occurences.add(i)\n\n        if len(node.occurences) == 2:\n            for o in node.occurences:\n                if o + 1 < len(S):\n                    self.AddOccurences(self.getNode(node, S[o+1]), o+1, S)\n\n\n        if len(node.occurences)>2:\n            if i + 1 < len(S):\n                self.AddOccurences(self.getNode(node, S[i+1]), i+1, S)\n\n        \n    def getLongestDuplicate(self, node):\n        maxSubstring = ''\n        \n        for v in node.next.keys():\n            if len(node.next[v].occurences)>1:\n\n                childSubstring = self.getLongestDuplicate(node.next[v])\n                if len(childSubstring) + 1 > len(maxSubstring):\n                    maxSubstring = v + childSubstring\n                        \n        return maxSubstring\n    \n    \n    def longestDupSubstring(self, S: str) -> str:\n        if not S:\n            return 0\n        \n        if len(set(S)) == 1:\n            return S[0:len(S)-1]\n\n        root = self.Node()\n\n        for i in range(len(S)):\n            self.AddOccurences(self.getNode(root, S[i]), i, S)\n\n        #self.print_tree(root, '')\n        maxDepthDuplicates = self.getLongestDuplicate(root)\n        \n        return maxDepthDuplicates\n'''        ", "class Solution:\n    def longestDupSubstring(self, S):\n        nums = [ord(c) - ord('a') for c in S]\n        #BASE, MOD = 113, 1000000007\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD) # (BASE ** (L-1)) % MOD\n            for i, val in enumerate(nums[L:]):\n                # cur_hash -= nums[i] * (BASE ** (L-1))\n                cur_hash -= nums[i] * X\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n                if cur_hash in seen:\n                    return i + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, len(S)\n        res = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                res = idx\n            else:\n                high = mid\n        return S[res: res + low-1]\n        \n        #while low <= high:\n        #    mid = (low + high)//2\n        #    idx = check(mid)\n        #    if idx != -1:\n        #        low = mid + 1\n        #        res = idx\n        #    else:\n        #        high = mid - 1\n        #return S[res: res + low-1]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def check(Val):\n            base, modulus = 26, 2**32\n            AL = base**Val%modulus\n            hk = 0\n            for i in range(Val):\n                hk = hk*base + ord(S[i])-ord('a')\n            hk %= modulus\n            hm = {hk: 0}\n            \n            for i in range(Val, N):\n                hk = hk*base - (ord(S[i-Val])-ord('a'))*AL + ord(S[i]) - ord('a')\n                hk %= modulus\n                if hk in hm and S[hm[hk]:hm[hk]+Val]==S[i-Val+1:i+1]:\n                    return i-Val+1\n                \n                hm[hk] = i-Val+1\n            # print(mid, hm)\n            \n        N = len(S)\n        start, end = 1, N\n        res = 0\n        while start<=end:\n            mid = start+(end-start)//2\n            pos = check(mid)\n            if pos:\n                res = pos\n                start = mid+1\n            else:\n                end = mid-1\n                \n        return S[res:res+end]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        BASE = 26\n        MOD = (1 << 63) - 1\n        POWS = [1] * n\n        for i in range(1, n):\n            POWS[i] = (POWS[i - 1] * BASE) % MOD\n        def search(k):\n            seen = set()\n            h = 0\n            for i in range(k):\n                h = (h * BASE + ord(S[i]) - 97) % MOD\n            seen.add(h)\n            for i in range(k, n):\n                h = ((h - (ord(S[i - k]) - 97) * POWS[k - 1]) * BASE + ord(S[i]) - 97) % MOD\n                s = S[i - k + 1:i + 1]\n                if h in seen:\n                    return i\n                seen.add(h)\n            return -1\n        \n        l, r = 0, n - 1\n        while l <= r:\n            m = (l + r) // 2\n            if search(m) >= 0:\n                l = m + 1\n            else:\n                r = m - 1\n        if r < 0:\n            return ''\n        i = search(r)\n        return S[i - r + 1:i + 1]", "class Solution:\n    def search(self, L: int, a: int, modulus: int, n: int, nums: List[int]) -> str:\n        h = 0\n        for i in range(L):\n            h = (h * a + nums[i]) % modulus\n        \n        seen = {h}\n        \n        aL = pow(a, L, modulus)\n        \n        for start in range(1, n-L + 1):\n            h = (h * a - nums[start - 1]* aL + nums[start + L - 1]) % modulus\n            if h in seen:\n                return start\n            seen.add(h)\n        return -1\n    \n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        nums = [ord(S[i]) - ord('a') for i in range(n)]\n        a = 26\n        modulus = 2 ** 32\n        left, right = 1, n\n        while left <= right:\n            L = left + (right - left) // 2\n            if self.search(L, a, modulus, n, nums) != -1:\n                left = L + 1\n            else:\n                right = L - 1\n        start = self.search(left -1, a, modulus, n, nums)\n        return S[start: start + left - 1]\n", "from collections import defaultdict\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        l, h = 2, len(S)-1\n        res = ''\n        while l <= h:\n            m = l + (h-l) // 2\n            cand = self.find_dup_substr_len_k(S, m)\n            if cand:\n                res = cand\n                l = m+1\n            else:\n                h = m-1\n        return res\n    \n    def find_dup_substr_len_k(self, s, k):\n        MOD = (1 << 63) - 1\n        BASE = 26\n        D = pow(BASE, k-1, MOD)\n        hash_val = 0\n        seen = defaultdict(set)\n        \n        for i in range(len(s)):\n            # update the sliding hash value\n            if i >= k:\n                char_offset = ord(s[i-k]) - ord('a') \n                hash_val = (hash_val - char_offset * D) % MOD\n            char_offset = ord(s[i]) - ord('a') \n            hash_val = (hash_val * BASE + char_offset) % MOD\n            \n            # check hash collision and return string if duplicate found\n            if i >= k-1:\n                if hash_val in seen:\n                    cand_i = s[i-k+1:i+1]\n                    for j in seen[hash_val]:\n                        cand_j = s[j-k+1:j+1]\n                        if cand_i == cand_j:\n                            return cand_i\n                seen[hash_val].add(i)\n        return ''\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def code(t):\n            return ord(t) - ord('a')+1\n        def check(length):\n            seen = collections.defaultdict(list)\n            \n            MOD = 10 ** 9 + 7\n            P = 113\n            INV_P = pow(P, MOD-2, MOD)\n\n            h = 0\n            power = 1\n            '''\n            h1 = s[0]p^0+s[1]p^1+s[2]p^2 +...+s[length-1]p^(length-1)\n            move next:\n            h2 = s[1]p^0+s[2]p^1+s[3]p^2 +...+s[length]p^(length-1)\n            \n            h2 = (h1 - S[i-length+1])*INV_P % MOD\n            \n            '''\n            for i, x in enumerate(S):\n                h = (h + power*code(x)) % MOD \n                if i < length-1:\n                    power = power * P % MOD\n                else:\n                    # start: i-(length-1)\n                    if h in seen:\n                        for j in seen[h]:\n                            if S[i-(length-1):i+1] == S[j:j+length]:\n                                return S[j:j+length], True\n                    seen[h].append(i-(length-1))\n                    h = (h-code(S[i-(length-1)]))*INV_P % MOD\n            \n            return '', False\n        \n        res = ''\n        l, r = 1, len(S)-1\n        while l <= r:\n            mid = (l+r)//2\n            sub, is_check = check(mid)\n            if is_check:\n                res = sub\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return res", "class Solution:\n    \n    def find(self ,s , m) :\n        \n        seen = collections.defaultdict(list)\n        \n        mod = 1<<63 -1\n        base = 26\n        d = pow(26,m-1,mod)\n        chal = 0\n        \n        for i in range(len(s)) :\n            \n            if i >= m :\n                l_chal = ord(s[i-m]) - ord('a')\n                chal = ( chal - l_chal*d)%mod\n                \n            l_chal = ord(s[i]) - ord('a')\n            chal = (chal*base + l_chal)%mod\n            \n            if i >= m-1 :\n                s_i = s[i-m+1 : i +1]\n                if chal in seen :\n                    \n                    for j in seen[chal] :\n                        s_j = s[j-m+1 : j+1]\n                        if s_j == s_i :\n                            return s_i\n                        \n                else :\n                    seen[chal].append(i)\n                    \n        return ''\n            \n    def longestDupSubstring(self, S: str) -> str:\n        \n        l = 2 \n        h = len(S) -1\n        ans = ''\n        \n        while l <= h :\n            m = (l+h)//2\n            \n            s = self.find(S ,m)\n            \n            if s != '' :\n                ans = s\n                l = m+1\n            \n            else :\n                h = m-1\n                \n        return ans", "class Solution:\n    def longestDupSubstring(self, S):\n        nums, N = [ord(c) - ord('a') for c in S], len(S)\n        BASE, MOD = 26, 2**32\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = (cur_hash * BASE + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)\n            for idx, val in enumerate(nums[L:], start = L):\n                cur_hash -= nums[idx - L] * X\n                cur_hash = (cur_hash * BASE + val) % MOD\n                if cur_hash in seen:\n                    return idx - L + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, N + 1\n        start = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                start = idx\n            else:\n                high = mid\n        return S[start: start + low - 1]", "from collections import defaultdict\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        mod = 10 ** 9 + 7\n        def get_rep(l: int) -> str:\n            mp = defaultdict(list) # key: hash_code, value: list of start indexes of substrings\n            a = 13\n            sofar = 0\n            factor = 1\n            for i in range(l):\n                sofar = (sofar * a + ord(S[i])) % mod\n                factor = (factor * a) % mod\n            mp[sofar].append(0)\n            for i in range(l, len(S)):\n                sofar = (sofar * a + ord(S[i]) - factor * ord(S[i - l])) % mod\n                if sofar in mp:\n                    for j in mp[sofar]:\n                        if S[j: j + l] == S[i - l + 1: i + 1]:\n                            return S[i - l + 1: i + 1]\n                mp[sofar].append(i - l + 1)\n            return None\n        \n        low, high = 0, len(S) - 1\n        ans = None\n        while low <= high:\n            mid = (low + high) // 2\n            res = get_rep(mid)\n            if res is None:\n                high = mid - 1\n            else:\n                ans = res\n                low = mid + 1\n        return ans if ans is not None else ''\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def search(m, MOD):\n            h = 0\n            for i in range(m):\n                h = (h * 26 + nums[i]) % MOD\n            s = {h}\n            aL = pow(26, m, MOD)\n            for pos in range(1, n - m + 1):\n                h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n                if h in s:\n                    return pos\n                s.add(h)\n            return -1\n\n        n = len(S)\n        nums = [ord(c) - ord('a') for c in S]\n        l, r = 1, n\n        pos = -1\n        MOD = 2**63 - 1\n        while l <= r:\n            m = (l + r) // 2\n            cur = search(m, MOD)\n            if cur != -1:\n                l = m + 1\n                pos = cur\n            else:\n                r = m - 1\n        return S[pos: pos + l - 1]        ", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        base, mod = 26, 2**63 - 1\n        n = len(S)\n        A = [ord(ch) - ord('a') for ch in S]\n        def k_dup(k):\n            curr = 0\n            for i in range(k):\n                curr = (curr * base + A[i]) % mod\n            seen = {curr}\n            for i in range(1, n - k + 1):\n                curr = ( base*curr - pow(base, k, mod)*A[i-1] + A[i+k-1]) % mod\n                if curr in seen:\n                    return i\n                seen.add(curr)\n            return 0\n        l, r, ans = 0, n, 0\n        while l < r:\n            mid = (l + r + 1) >> 1\n            pos = k_dup(mid)\n            # print(pos, mid)\n            if pos:\n                l = mid\n                ans = pos\n            else:\n                r = mid - 1\n        return S[ans:ans + l]\n        \n", "class Solution:\n    def longestDupSubstring(self, S):\n        nums = [ord(c) - ord('a') for c in S]\n        BASE, MOD = 26, 2**32               # Wrong: BASE, MOD = 113, 1000000007, too small\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)         # much faster than (BASE ** (L-1)) % MOD\n            for i, val in enumerate(nums[L:]):\n                # cur_hash -= nums[i] * (BASE ** (L-1))\n                cur_hash -= nums[i] * X\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n                if cur_hash in seen:\n                    return i + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, len(S) + 1\n        res = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                res = idx\n            else:\n                high = mid\n        return S[res: res + low-1]\n    \nclass Solution:\n    def longestDupSubstring(self, S):\n        N = len(S)\n        def check(length):\n            seen = set()\n            for i in range(N - length):\n                hashS = hash(S[i:i+length+1])\n                if hashS in seen:\n                    return i\n                seen.add(hashS)\n            return 0\n\n        low, high = 0, N\n        idx = 0\n        while low < high:\n            mid = (low + high)//2\n            start = check(mid)\n            if start:\n                low = mid + 1\n                idx = start\n            else:\n                high = mid\n        return S[idx:idx + low]", "class Solution:\n    def search(self, L: int, base: int, MOD: int, n: int, nums: List[int]) -> str:\n        # compute the hash of string S[:L]\n        h = 0\n        for i in range(L):\n            h = (h * base + nums[i]) % MOD\n              \n        # already seen hashes of strings of length L\n        seen = {h} \n        # const value to be used often : a**L % mod\n        aL = pow(base, L, MOD) \n        for start in range(1, n - L + 1):\n            # compute rolling hash in O(1) time\n            h = (h * base - nums[start - 1] * aL + nums[start + L - 1]) % MOD\n            if h in seen:\n                return start\n            seen.add(h)\n        return -1\n        \n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        # convert string to array of integers to implement constant time slice\n        nums = [ord(S[i]) - ord('a') for i in range(n)]\n        # base value for the rolling hash function\n        base = 26\n        # mod value for the rolling hash function to avoid overflow\n        MOD = 2**32\n        \n        # binary search, L = repeating string length\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            if self.search(mid, base, MOD, n, nums) != -1:\n                left = mid + 1\n            else:\n                right = mid - 1\n               \n        start = self.search(left - 1, base, MOD, n, nums)\n        return S[start: start + left - 1]\n    \n    \n    \n    \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        low = 0\n        high = n-1\n        \n        nums = [ord(S[i]) - ord('a') for i in range(n)]\n        \n        def findDuplicate(L):\n            # compute the hash of string S[:L]\n            h = 0\n            a = 26\n            modulus = 2**32\n            for i in range(L):\n                h = (h * a + nums[i]) % modulus\n\n            # already seen hashes of strings of length L\n            seen = {h}\n            # const value to be used often : a**L % modulus\n            aL = pow(a, L, modulus) \n            for start in range(1, n - L + 1):\n                # compute rolling hash in O(1) time\n                h = (h * a - nums[start - 1] * aL + nums[start + L - 1]) % modulus\n                if h in seen:\n                    return start\n                seen.add(h)\n            return -1\n        \n        res = ''\n        while low < high:\n            mid = (low + high + 1)//2\n            start = findDuplicate(mid)\n            if start != -1:\n                low = mid\n                res = S[start:start+mid] \n            else:\n                high = mid-1\n        return res", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        l = 0\n        r = len(S)\n        base = 26\n        mod = 2**32\n        res = [0, 0]\n        nums = [ord(n) - ord('a') for n in S]\n\n        \n        while l < r:\n            \n            mid = (l+r) // 2\n            h = 0\n            \n            for i in range(0, mid):\n                h = (h*base + nums[i]) % mod\n                \n            dups = set([h])\n            remove = pow(base, mid, mod)\n            \n            for i in range(1, len(nums) - mid + 1):\n                h = (h*base - nums[i-1] * remove + nums[i+mid-1]) % mod\n                \n                if h in dups:\n                    res = [i, i+mid]\n                    break\n                    \n                dups.add(h)\n                # print(mid, h)         \n            if res[1] - res[0] < mid:\n                r = mid\n            else:\n                l = mid + 1\n            \n                \n        return S[res[0]:res[1]]\n                \n                \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        low = 0\n        high = len(S)-1\n        result = ''\n        nums = [ord(i) - ord('a') for i in S]\n        mod = 2**63-1\n        \n        def rabin_karp(size):\n            power = pow(26,size,mod)\n            hash_val = 0\n            hash_set = set()\n            for i in range(size):\n                hash_val = (hash_val*26 + (nums[i]))%mod\n            hash_set.add(hash_val)\n            for i in range(size, len(S)):\n                hash_val = (hash_val*26 - (power*nums[i-size]) + nums[i])%mod\n                if hash_val in hash_set:\n                    return i-size+1\n                else:\n                    hash_set.add(hash_val)\n            return -1\n        while(low <= high):\n            mid = low + (high-low)//2\n            pos = rabin_karp(mid)\n            if pos == -1:\n                high = mid - 1\n            else:\n                result = S[pos:pos+mid]\n                low = mid+1\n        return result", "class Solution:\n    def longestDupSubstring(self, S):\n        nums = [ord(c) - ord('a') for c in S]\n        BASE, MOD = 26, 2**32               # Wrong: BASE, MOD = 113, 1000000007, too small\n        def check(L):\n            cur_hash, seen = 0, set()\n            for val in nums[:L]:\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n            seen.add(cur_hash)\n            X = pow(BASE, L-1, MOD)         # much faster than (BASE ** (L-1)) % MOD\n            for i, val in enumerate(nums[L:]):\n                # cur_hash -= nums[i] * (BASE ** (L-1))\n                cur_hash -= nums[i] * X\n                cur_hash = ((cur_hash * BASE) + val) % MOD\n                if cur_hash in seen:\n                    return i + 1\n                seen.add(cur_hash)\n            return -1\n        low, high = 1, len(S) + 1\n        res = 0\n        while low < high:\n            mid = (low + high)//2\n            idx = check(mid)\n            if idx != -1:\n                low = mid + 1\n                res = idx\n            else:\n                high = mid\n        return S[res: res + low-1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n=len(S)\n        modulus=2**32\n        a=26        \n        nums=[ord(c)-ord('a') for c in S]\n        def search(L):\n            nonlocal a,n,modulus\n            aL=pow(a,L,modulus)\n            h=0\n            for i in range(L):\n                h=(h*a+nums[i])%modulus\n            seen={h}\n            for start in range(1,n-L+1):\n                h=(h*a-nums[start-1]*aL+nums[start+L-1])%modulus\n                if h in seen:\n                    return start\n                seen.add(h)\n            return -1\n        \n        l,r=1,n\n        while l<=r:\n            mid=(l+r)>>1\n            if search(mid)!=-1:\n                l=mid+1\n            else:\n                r=mid-1\n                        \n        start=search(r)        \n        return S[start:start+r]", "class Solution:\n    \n    def rabinKarp(self, L, nums):\n        h = 0\n        a = 26\n        MOD = 2**32\n        for i in range(L):\n            h = (h * a + nums[i]) % MOD\n           \n        aL = pow(a, L, MOD)\n        seen = {h}\n        for start in range(1, len(nums)-L+1):\n            h = (h *a - nums[start-1] * aL + nums[start+L-1]) % MOD\n            if h in seen:\n                return start\n            seen.add(h)\n        return -1\n    \n    def longestDupSubstring(self, S: str) -> str:   \n        nums = [ord(ch)-ord('a') for ch in S]\n        l, r = 0, len(S)\n        while l < r:\n            mid = l + (r-l) // 2\n            if self.rabinKarp(mid, nums) != -1:\n                l = mid + 1\n            else:\n                r = mid\n        start = self.rabinKarp(l-1, nums)\n        return S[start:start+l-1]        \n            \n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        # binary search + string hashing\n        from functools import reduce\n        A = [ord(c) - ord('a') for c in S]\n        mod = 2 ** 63 - 1\n        def judge(l):\n            p = 26 ** l % mod\n            cur = reduce(lambda x, y : (x * 26 + y) % mod, A[:l], 0)\n            seen = {cur}\n            for i in range(l, len(S)):\n                cur = (cur * 26 + A[i] - p * A[i - l]) % mod\n                if cur in seen: return i - l + 1\n                seen.add(cur)\n        \n        lo, hi = 0, len(S)\n        res = 0\n        while lo < hi:\n            mi = (lo + hi + 1) // 2\n            pos = judge(mi)\n            if pos:\n                lo = mi\n                res = pos\n            else:\n                hi = mi - 1\n        return S[res : res + lo]\n", "class Solution:\n    # Use binary search to try out all possible lengths of the subtrings\n    # Use a record list to record the hash summation of the substring\n    # Use the number of distinct chara as the hash base\n    # If two substrings are the same, they should have the same hash summation\n    # After minus the before part\n    def longestDupSubstring(self, S: str) -> str:\n        res = ''\n        d,q = len(set(S)), 2**63-1\n        record = [0]*len(S)\n        for i in range(len(S)):\n            if i == 0:record[i] = ord(S[i])\n            else:record[i] = (record[i-1]*d+ord(S[i]))%q\n        def check(mid):\n            h,g = 1,set()\n            for i in range(mid):\n                h = h*d%q\n            for i in range(len(S)-mid+1):\n                count = (record[i+mid-1]-record[i-1]*h)%q if i > 0 else record[i+mid-1]\n                if count not in g:g.add(count)\n                else:return S[i:i+mid]\n            return False\n        l,r = 0,len(S)-1\n        while l<=r:\n            mid = (l+r)//2\n            temp = check(mid)\n            if temp:\n                res = temp\n                l = mid + 1\n            else:r = mid - 1\n        return res\n        \n        \n#         res = \\\"\\\"\n#         d, q = len(set(S)), 2**63-1\n#         hashes = [0] * len(S)\n#         for i in range(len(S)):\n#             if i == 0: hashes[i] = ord(S[i])\n#             else: hashes[i] = (hashes[i-1]*d + ord(S[i]))%q\n#         l, r = 0, len(S)-1\n#         while l <= r:\n#             mid = (l+r)//2\n#             temp = self.check(S,mid,hashes,d,q)\n#             if temp:\n#                 res = temp\n#                 l = mid + 1\n#             else: r = mid - 1\n#         return res\n    \n#     def check(self, S, mid, hashes, d, q):\n#         res = set()\n#         h, g = 1, 0\n#         for i in range(mid):\n#             h = (h*d)%q\n#         for i in range(len(S)-mid+1):\n#             g = (hashes[i+mid-1] - hashes[i-1]*h)%q if i > 0 else hashes[i+mid-1]\n#             if g not in res: res.add(g)\n#             else: return S[i:i+mid]\n#         return False\n                \n                \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def rk(m):\n            \n            nonlocal idx\n            st = set()\n            \n            #p = b**(m-1)\n            #p%=mod\n            p= pow(b,m-1,mod)  # more efficient to mod at each step than work on a long number\n            \n            y = 0\n            for i in range(m):\n                y = (y*b+num[i])%mod  # more efficient to mod at each step than work on a long number\n                \n            st.add(y)\n                \n            for i in range(1, n-m+1):\n                y = ((y-num[i-1]*p%mod)*b%mod+num[i-1+m])%mod\n                #y = (y-num[i-1]*p)*b+num[i-1+m]\n                \n                if y in st:\n                    idx = i\n                    return 0\n                else:\n                    st.add(y)\n            \n            return 1\n                \n            \n\n        n = len(S)\n        b = 26                      # no need to be 128\n        #mod = 10**9+7              # too small => conflict\n        mod = 2**32                 # here\n        \n        z = ord('a')\n        num = [ ord(S[i])-z for i in range(n)]\n        \n        l=1\n        r=n\n        idx = 0  # last found duplicate                 \n        while l<r:\n            \n            m = (l+r)//2\n            \n            if rk(m)>0:\n                r = m\n            else:\n                l = m+1\n        \n        return S[idx:idx+l-1]\n        \n        \n", "p = 2**63 - 1\n\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def rabin_karp(mid):\n            cur_hash = 0\n            for i in range(mid):\n                cur_hash = (cur_hash * 26 + nums[i]) % p\n            hashes = {cur_hash}\n            pos = -1\n            max_pow = pow(26, mid, p)\n            for i in range(mid, len(S)):\n                cur_hash = (26*cur_hash-nums[i-mid]*max_pow + nums[i]) % p\n                if cur_hash in hashes:\n                    pos = i + 1 - mid\n                hashes.add(cur_hash)\n            return pos\n\n\n        low, high = 0, len(S)-1\n        end = 0\n        start = 0\n        nums = [ord(c)-ord('a') for c in S]\n        while low <= high:\n            mid = (low+high) // 2\n            pos = rabin_karp(mid)\n            if pos == -1:  # no matching strings found\n                high = mid - 1\n            else:\n                start = pos\n                low = mid + 1\n        return S[start:start+low-1]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def search(m, MOD):\n            h = 0\n            for i in range(m):\n                h = (h * 26 + nums[i]) % MOD\n            s = {h}\n            aL = pow(26, m, MOD)\n            for pos in range(1, n - m + 1):\n                h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n                if h in s:\n                    return pos\n                s.add(h)\n            return -1\n\n        n = len(S)\n        nums = [ord(c) - ord('a') for c in S]\n        l, r = 1, n\n        pos = -1\n        MOD = 2**63 - 1\n        while l <= r:\n            m = (l + r) // 2\n            cur = search(m, MOD)\n            if cur != -1:\n                l = m + 1\n                pos = cur\n            else:\n                r = m - 1\n        return S[pos: pos + l - 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        N = len(S)\n        l, r = 1, N\n        nums = [ord(x) - ord('a') for x in S]\n        KMAX = 2 ** 63 - 1\n        def check(m):\n            MAXL = pow(26, m, KMAX)\n            total = 0\n            hashset = set()\n            for i in range(m):\n                total = (total * 26 + nums[i]) % KMAX\n            hashset.add(total)\n            for i in range(1, N - m + 1):\n                total = (total * 26 - nums[i-1] * MAXL + nums[i+m-1]) % KMAX\n                if total in hashset:\n                    return i\n                hashset.add(total)\n            return -1\n        \n        while l < r:\n            m = (l + r) // 2\n            if check(m) < 0:\n                r = m\n            else:\n                l = m + 1\n        idx = check(r - 1)        \n        return S[idx: idx + r-1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        ords = [ord(ch) - 97 for ch in S]\n        mod = 2 ** 32\n        seen = set()\n        \n        def has_dup_with_length(length):\n            seen.clear()\n            p = pow(26, length, mod)\n            \n            hashed_prefix = 0\n            for i in range(length):\n                hashed_prefix = (hashed_prefix * 26 + ords[i]) % mod\n            seen.add(hashed_prefix)\n\n            for i in range(length, len(S)):\n                hashed_prefix = (hashed_prefix * 26 + ords[i] - ords[i - length] * p) % mod\n                if hashed_prefix in seen:\n                    return i - length + 1\n                seen.add(hashed_prefix)\n        \n        start, lo, hi = 0, 0, len(S) - 1, \n        while lo < hi:\n            mid_length = (lo + hi + 1) // 2\n            idx = has_dup_with_length(mid_length)\n            if idx:\n                start = idx\n                lo = mid_length\n            else:\n                hi = mid_length - 1\n        return S[start: start + lo]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        res = ''\n        d,q = len(set(S)), 2**63-1\n        record = [0]*len(S)\n        for i in range(len(S)):\n            if i == 0:record[i] = ord(S[i])\n            else:record[i] = (record[i-1]*d+ord(S[i]))%q\n        def check(mid):\n            h,g = 1,set()\n            for i in range(mid):\n                h = h*d%q\n            for i in range(len(S)-mid+1):\n                count = (record[i+mid-1]-record[i-1]*h)%q if i > 0 else record[i+mid-1]\n                if count not in g:g.add(count)\n                else:return S[i:i+mid]\n            return False\n        l,r = 0,len(S)-1\n        while l<=r:\n            mid = (l+r)//2\n            temp = check(mid)\n            if temp:\n                res = temp\n                l = mid + 1\n            else:r = mid - 1\n        return res\n        \n        \n#         res = \\\"\\\"\n#         d, q = len(set(S)), 2**63-1\n#         hashes = [0] * len(S)\n#         for i in range(len(S)):\n#             if i == 0: hashes[i] = ord(S[i])\n#             else: hashes[i] = (hashes[i-1]*d + ord(S[i]))%q\n#         l, r = 0, len(S)-1\n#         while l <= r:\n#             mid = (l+r)//2\n#             temp = self.check(S,mid,hashes,d,q)\n#             if temp:\n#                 res = temp\n#                 l = mid + 1\n#             else: r = mid - 1\n#         return res\n    \n#     def check(self, S, mid, hashes, d, q):\n#         res = set()\n#         h, g = 1, 0\n#         for i in range(mid):\n#             h = (h*d)%q\n#         for i in range(len(S)-mid+1):\n#             g = (hashes[i+mid-1] - hashes[i-1]*h)%q if i > 0 else hashes[i+mid-1]\n#             if g not in res: res.add(g)\n#             else: return S[i:i+mid]\n#         return False\n                \n                \n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        nums = [ord(S[i]) - ord('a') for i in range(n)]\n        \n        def search(position):\n            h = 0\n            for i in range(position):\n                h = (h * 26 + nums[i]) % 2 ** 32\n            seen = {h}\n            const = 26 ** position % 2 ** 32\n            for start in range(1, n - position + 1):\n                h = (h * 26 - nums[start - 1] * const + nums[start + position - 1]) % 2 ** 32\n                if h in seen:\n                    return start\n                seen.add(h)\n            return -1\n        \n        left, right = 1, n\n        while left <= right:\n            pivot = (left + right) // 2\n            if search(pivot) != -1:\n                left = pivot + 1\n            else:\n                right = pivot - 1\n        start = search(left - 1)\n        return S[start: start + left - 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n    \n        arr = [ord(ch) - ord('a') for ch in S]\n        n = len(arr)\n        B = 29\n        mod = 2**63 - 1\n        def exists(L):\n            seen = {}\n            P = pow(B, L, mod)\n            h = 0\n            for i in range(n):\n                h = (h * B + arr[i]) % mod\n                if i >= L:\n                    h = (h - arr[i-L] * P) % mod\n                if i >= L - 1:\n                    if h in seen:\n                        return seen[h]\n                    seen[h] = i\n            return -1\n        \n        lo, hi = 0, len(S)\n        # cand = ''\n        pos = -1\n        while lo < hi:\n            mid = (lo + hi + 1) // 2\n            idx = exists(mid)\n            if idx != -1:\n                lo = mid\n                # cand = S[idx - mid + 1: idx + 1]\n                pos = idx\n            else:\n                hi = mid - 1\n        return S[pos - lo + 1:pos+1]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.A = [ord(c) - ord('a') for c in S]\n        \n        start, end = 1, len(S)\n        while start + 1 < end:\n            mid = (start + end) // 2\n            pos = self.check(mid)\n            if pos:\n                start = mid\n            else:\n                end = mid\n\n        pos = self.check(end)\n        if pos:\n            return S[pos: pos + end]\n        pos = self.check(start)\n        if pos:\n            return S[pos: pos + start]\n        return ''\n    \n    def check(self, length):\n        mod = 2**63 - 1\n        power = pow(26, length, mod)\n        \n        cur = 0\n        for i in range(length):\n            cur = (cur * 26 + self.A[i]) % mod\n        \n        # cur = reduce(lambda x, y: (x * 26 + y) % mod, self.A[:length], 0)\n        seen = {cur}\n        \n        for i in range(length, len(self.A)):\n            cur = (cur * 26 + self.A[i] - self.A[i - length] * power) % mod\n            if cur in seen:\n                return i - length + 1\n            seen.add(cur)\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        def rk(m):\n            \n            nonlocal idx\n            st = set()\n            p = b**(m-1)\n            p%=mod\n            \n            y = 0\n            for i in range(m):\n                y = (y*b+num[i])%mod\n                \n            st.add(y)\n                \n            for i in range(1, n-m+1):\n                y = ((y-num[i-1]*p%mod)*b%mod+num[i-1+m])%mod\n                #y = (y-num[i-1]*p)*b+num[i-1+m]\n                \n                if y in st:\n                    idx = i\n                    return 0\n                else:\n                    st.add(y)\n            \n            return 1\n                \n            \n\n        n = len(S)\n        b = 26                      # no need to be 128\n        #mod = 10**9+7              # too small => conflict\n        mod = 2**32                 # here\n        \n        z = ord('a')\n        num = [ ord(S[i])-z for i in range(n)]\n        \n        l=1\n        r=n\n        idx = 0  # last found duplicate                 \n        while l<r:\n            \n            m = (l+r)//2\n            \n            if rk(m)>0:\n                r = m\n            else:\n                l = m+1\n        \n        return S[idx:idx+l-1]\n        \n        \n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.A = [ord(c) - ord('a') for c in S]\n        \n        start, end = 1, len(S)\n        while start + 1 < end:\n            mid = (start + end) // 2\n            pos = self.check(mid)\n            if pos:\n                start = mid\n            else:\n                end = mid\n\n        pos = self.check(end)\n        if pos:\n            return S[pos: pos + end]\n        pos = self.check(start)\n        if pos:\n            return S[pos: pos + start]\n        return ''\n    \n    def check(self, length):\n        mod = 2**63 - 1\n        power = pow(26, length, mod)\n        \n        cur = reduce(lambda x, y: (x * 26 + y) % mod, self.A[:length], 0)\n        seen = {cur}\n        \n        for i in range(length, len(self.A)):\n            cur = (cur * 26 + self.A[i] - self.A[i - length] * power) % mod\n            if cur in seen:\n                return i - length + 1\n            seen.add(cur)\n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.A = [ord(c) - ord('a') for c in S]\n        \n        start, end = 1, len(S)\n        while start + 1 < end:\n            mid = (start + end) // 2\n            pos = self.check(mid)\n            if pos:\n                start = mid\n            else:\n                end = mid\n\n        pos = self.check(end)\n        if pos:\n            return S[pos: pos + end]\n        pos = self.check(start)\n        if pos:\n            return S[pos: pos + start]\n        return ''\n    \n    def check(self, length):\n        mod = 2**63 - 1\n        power = pow(26, length, mod)\n        \n        # cur = 0\n        # for i in range(length):\n        #     cur = (cur * 26 + self.A[i]) % mod\n        \n        cur = reduce(lambda x, y: (x * 26 + y) % mod, self.A[:length], 0)\n        seen = {cur}\n        \n        for i in range(length, len(self.A)):\n            cur = (cur * 26 + self.A[i] - self.A[i - length] * power) % mod\n            if cur in seen:\n                return i - length + 1\n            seen.add(cur)\n", "from functools import reduce\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        self.A = [ord(c) - ord('a') for c in S]\n        \n        start, end = 1, len(S)\n        while start + 1 < end:\n            mid = (start + end) // 2\n            print(mid)\n            pos = self.check(mid)\n            print(pos)\n            if pos:\n                start = mid\n            else:\n                end = mid\n        # print(start, end)\n        pos = self.check(end)\n        # print(pos)\n        if pos:\n            return S[pos: pos + end]\n        pos = self.check(start)\n        if pos:\n            return S[pos: pos + start]\n        return ''\n    \n    def check(self, length):\n        mod = 2**63 - 1\n        power = pow(26, length, mod)\n        \n        cur = reduce(lambda x, y: (x * 26 + y) % mod, self.A[:length], 0)\n        seen = {cur}\n        \n        for i in range(length, len(self.A)):\n            cur = (cur * 26 + self.A[i] - self.A[i - length] * power) % mod\n            if cur in seen:\n                return i - length + 1\n            seen.add(cur)\n", "class Solution:\n    def searchLongestStringOfKLen(self, S, total_len, compare_len):\n        search_len_hash = 0\n        for i in range(compare_len):\n            search_len_hash = (search_len_hash * self.uniq + self.nums[i]) %  self.mod\n\n        tmp_hash = {}\n        tmp_hash[search_len_hash] = True\n        \n        remove_old_power = pow(self.uniq,  compare_len, self.mod)\n        for i in range(1, total_len-compare_len+1):\n            search_len_hash = (search_len_hash * self.uniq - (remove_old_power * self.nums[i-1]) + self.nums[i+compare_len-1] )% self.mod\n            if search_len_hash in tmp_hash:\n                return i\n            tmp_hash[search_len_hash] = True\n            \n        return -1\n        \n    \n    def longestDupSubstring(self, S: str) -> str:\n        ls = len(S)\n        end = ls\n        start = 1 \n        mid = 0\n        self.nums = []\n        for i in range(ls):\n            self.nums.append(ord(S[i]) - ord('a'))\n\n        self.uniq = 26\n        self.mod = 2**32\n        while start <= end:\n            mid = start + (end-start)//2\n            if self.searchLongestStringOfKLen(S, ls, mid) != -1:\n                start = mid +  1\n            else :\n                end = mid - 1\n        \n        ds_sp = self.searchLongestStringOfKLen(S, ls, start -1)\n        return S[ds_sp:ds_sp+start-1]", "def check(arr, n, l, mod):\n    p = pow(26, l, mod)\n    window_hash = 0\n    hash_set = set()\n    for i in range(l):\n        window_hash = (26 * window_hash + arr[i]) % mod\n    hash_set.add(window_hash)\n\n    for i in range(1, n - l + 1):\n        window_hash = (window_hash * 26 - (arr[i - 1]*p) + arr[i + l - 1])%mod\n        if window_hash in hash_set:\n            return i\n        hash_set.add(window_hash)\n\n    return False\n\n\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        \n        n = len(S)\n        min_length, max_length = 1, n\n        ans, prev_len = 0, 0\n        mod = (1 << 63) - 1\n        nums = [ord(S[i]) - ord('a') for i in range(n)]\n\n        while min_length <= max_length:\n            mid_length = int((max_length + min_length)/2)\n            start = check(nums, n, mid_length, mod)\n            if start != False:\n                if prev_len < mid_length:\n                    ans = start\n                    prev_len = mid_length\n                min_length = mid_length + 1\n            else:\n                max_length = mid_length - 1\n        \n        return S[ans:ans + prev_len]\n", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n=len(S)\n        modulus=2**56\n        a=26        \n        nums=[ord(c)-ord('a') for c in S]\n        def search(L):\n            nonlocal a,n,modulus\n            aL=pow(a,L,modulus)\n            h=0\n            for i in range(L):\n                h=(h*a+nums[i])%modulus\n            seen={h}\n            for start in range(1,n-L+1):\n                h=(h*a-nums[start-1]*aL+nums[start+L-1])%modulus\n                if h in seen:\n                    return start\n                seen.add(h)\n            return -1\n        \n        l,r=1,n\n        while l<=r:\n            mid=(l+r)>>1\n            if search(mid)!=-1:\n                l=mid+1\n            else:\n                r=mid-1\n                        \n        start=search(r)        \n        return S[start:start+r]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        chars = [ord(c) - 97 for c in S]\n        BASE = 26\n        MOD = (1 << 63) - 1\n        POWS = [1] * n\n        for i in range(1, n):\n            POWS[i] = (POWS[i - 1] * BASE) % MOD\n        def search(k):\n            seen = set()\n            h = 0\n            for i in range(k):\n                h = (h * BASE + chars[i]) % MOD\n            seen.add(h)\n            for i in range(k, n):\n                h = ((h - chars[i - k] * POWS[k - 1]) * BASE + chars[i]) % MOD\n                if h in seen:\n                    return i\n                seen.add(h)\n            return -1\n        \n        l, r = 0, n - 1\n        k = 0\n        while l < r:\n            m = (l + r + 1) // 2\n            i = search(m)\n            if i >= 0:\n                k = i\n                l = m\n            else:\n                r = m - 1\n        return S[k - l + 1:k + 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        n = len(S)\n        chars = [ord(c) - 97 for c in S]\n        BASE = 26\n        MOD = (1 << 63) - 1\n        POWS = [1] * n\n        for i in range(1, n):\n            POWS[i] = (POWS[i - 1] * BASE) % MOD\n        def search(k):\n            seen = set()\n            h = 0\n            for i in range(k):\n                h = (h * BASE + chars[i]) % MOD\n            seen.add(h)\n            for i in range(k, n):\n                h = ((h - chars[i - k] * POWS[k - 1]) * BASE + chars[i]) % MOD\n                if h in seen:\n                    return i\n                seen.add(h)\n            return -1\n        \n        l, r = 0, n - 1\n        while l <= r:\n            m = (l + r) // 2\n            if search(m) >= 0:\n                l = m + 1\n            else:\n                r = m - 1\n        if r < 0:\n            return ''\n        i = search(r)\n        return S[i - r + 1:i + 1]", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        p = 31\n        m = 100000000003\n\n        pows = [1] * len(S)\n        invPows = [1] * len(S)\n        for i in range(1, len(S)):\n            pows[i] = pows[i-1] * p % m\n            invPows[i] = pow(pows[i], -1, m)\n\n        h = [0] * (len(S) + 1)\n        for i in range(len(S)):\n            h[i+1] = (h[i] + (ord(S[i]) - ord('a') + 1) * pows[i]) % m\n\n        def hasDup(S, sublen):\n            seen = set()\n            for i in range(len(S)- sublen + 1):\n                if (hs := (h[i + sublen] - h[i]) * invPows[i] % m) in seen:\n                    return (i, sublen)\n                seen.add(hs)\n            return (0, 0)\n\n        ans = None\n        lo, hi = 1, len(S)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if (s := hasDup(S, mid))[1]:\n                lo = mid + 1\n                ans = s\n            else:\n                hi = mid\n        return S[ans[0]:ans[0]+ans[1]] if ans else ''", "class Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        def search(m, MOD):\n            h = 0\n            for i in range(m):\n                h = (h * 26 + nums[i]) % MOD\n            s = {h}\n            aL = pow(26, m, MOD)\n            for pos in range(1, n - m + 1):\n                h = (h * 26 - nums[pos - 1] * aL + nums[pos + m - 1]) % MOD\n                if h in s:\n                    return pos\n                s.add(h)\n            return -1\n        \n        n = len(S)\n        nums = [ord(c) - ord('a') for c in S]\n        # find length of longest duplicate substring\n        l, r = 1, n\n        pos = 0\n        MOD = 2**63 - 1 # use largest positive of 8 byte integer\n        while l <= r:\n            m = (l + r) // 2\n            # search if there's duplicate for length m substring\n            cur = search(m, MOD)\n            if cur != -1:\n                l = m + 1\n                pos = cur\n            else:\n                r = m - 1\n        return S[pos: pos + l - 1]", "from collections import defaultdict\nfrom functools import reduce\n\n\nclass Solution:\n    def longestDupSubstring(self, S: str) -> str:\n        mod = (1 << 63 - 1)\n        A = [ord(c) - ord('a') for c in S]\n        \n        def find_dup_of_length(L):\n            p = pow(26, L, mod)\n            h = reduce(lambda x, y: (x * 26 + y) % mod, A[:L], 0)\n            seen = defaultdict(list)\n            seen[h].append(0)\n            \n            for i in range(L, len(S)):\n                h = (h * 26 + A[i] - p * A[i-L]) % mod\n                for start in seen[h]:\n                    if S[start:start+L] == S[i-L+1:i+1]:\n                        return start\n                \n                seen[h].append(i-L+1)\n        \n        start = 0\n        length = 0\n        low, high = 1, len(S)\n        while low < high:\n            mid = low + (high - low) // 2\n            pos = find_dup_of_length(mid)\n            if pos is not None:\n                start = pos\n                length = mid\n                low = mid + 1\n            else:\n                high = mid\n                \n        return S[start:start+length]\n"]
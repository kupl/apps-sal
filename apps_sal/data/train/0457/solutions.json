["class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        n, res = len(coins), amount + 1\n\n        def dfs(index, target, cnt):\n            nonlocal res\n            if cnt + (target + coins[index] - 1) // coins[index] >= res:\n                return\n\n            if target % coins[index] == 0:\n                res = cnt + target // coins[index]\n                return\n\n            if index == n - 1:\n                return\n\n            for i in range(target // coins[index], -1, -1):\n                dfs(index + 1, target - coins[index] * i, cnt + i)\n\n        dfs(0, amount, 0)\n        return -1 if res > amount else res", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        elif amount == 0:\n            return 0\n        \n        coins.sort(reverse = True)\n        visited = set()\n        q = collections.deque([])\n        for c in coins:\n            if c == amount:\n                return 1\n            elif c < amount:\n                q.append(c)\n                visited.add(c)\n            \n        count = 1\n        while q:\n            size = len(q)\n            count += 1\n            for _ in range(size):\n                prev = q.popleft()\n                for c in coins:\n                    cur = prev + c\n                    if cur == amount:\n                        return count\n                    elif cur < amount and cur not in visited:\n                        visited.add(cur)\n                        q.append(cur)\n        \n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        INVALID = 2**32\n        dp = [INVALID] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                if dp[i - coin] >= dp[i]: continue\n                dp[i] = dp[i - coin] + 1\n        return -1 if dp[amount] == INVALID else dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[amount, 0]]\n        visited = {amount}\n        for q in queue:\n            for c in coins:\n                if q[0] - c in visited: continue\n                if q[0] == c: return q[1] + 1\n                if q[0] > c:\n                    visited.add(q[0] - c)\n                    queue.append([q[0] - c, q[1] + 1])\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if not amount:  # Don't need any coin.\n            return 0\n\n        queue = deque([(0, 0)])\n        visited = [True] + [False] * amount\n        while queue:\n            totalCoins, currVal = queue.popleft()\n            totalCoins += 1  # Take a new coin.\n            for coin in coins:\n                nextVal = currVal + coin\n                if nextVal == amount:  # Find a combination.\n                    return totalCoins\n\n                if nextVal < amount:  # Could add more coins.\n                    if not visited[nextVal]:  # Current value not checked.\n                        visited[nextVal] = True  # Prevent checking again.\n                        queue.append((totalCoins, nextVal))\n\n        return -1  # Cannot find any combination.", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[amount, 0]]\n        visited = set()\n        for q in queue:\n            for c in coins:\n                if q[0] - c in visited: continue\n                if q[0] == c: return q[1] + 1\n                if q[0] > c:\n                    visited.add(q[0] - c)\n                    queue.append([q[0] - c, q[1] + 1])\n        return -1", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount == 0:\n            return 0\n        \n        if not coins:\n            return -1\n        queue = deque([])\n        for coin in coins:\n            if amount-coin>=0:\n                queue.append((1, amount-coin))\n        \n        seen = set()\n        while queue:\n            # print(queue)\n            nex = queue.popleft()\n            if nex[1] == 0:\n                return nex[0]\n            \n            for coin in coins:\n                if nex[1] - coin not in seen and nex[1]-coin>=0:\n                    queue.append((nex[0]+1, nex[1]-coin))\n                    seen.add(nex[1]-coin)\n        \n        return -1\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for a in range(coin, amount + 1):\n                if dp[a - coin] >= dp[a]:\n                    continue\n                dp[a] = dp[a - coin] + 1\n        return dp[amount] if dp[amount] < float('inf') else -1\n", "from collections import deque\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        queue = deque()\n        visited = set()\n        queue.append((amount, 0))\n        answer = -1\n        while queue:\n            target, numCoins = queue.popleft()\n            if target == 0:\n                answer = numCoins\n                break\n            elif target > 0:\n                for coin in coins:\n                    if (target - coin) not in visited:\n                        visited.add(target - coin)\n                        queue.append((target - coin, numCoins + 1))\n        return answer", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        res = 0\n        queue = collections.deque([(amount, 0)])\n        seen = {amount}\n        while queue:\n            head, res = queue.popleft()\n            if head == 0:\n                return res\n            for c in coins:\n                new_amount = head - c\n                if new_amount > -1 and new_amount not in seen:\n                    queue.append((new_amount, res+1))\n                    seen.add(new_amount)\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if not coins or amount<0: return -1\n        if amount ==0: return 0\n        \n        q = [(amount, 0)]\n        visited = {0}\n        coins.sort(reverse=True)\n        while q:\n            node, depth = q.pop(0)\n            \n            for coin in coins:\n                rest = node - coin\n                if rest == 0:\n                    return depth + 1\n                \n                if rest>0 and rest not in visited:\n                    q.append((rest, depth+1))\n                    visited.add(rest)\n                    \n        return -1\n", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        visited = {0}\n        tempQueue = deque()\n        tempQueue.append((0, 0))\n        while tempQueue:\n            currentVal, currentCount = tempQueue.popleft()\n            for coin in coins:\n                nextVal = currentVal + coin\n                if nextVal == amount:\n                    return currentCount + 1\n                elif nextVal < amount:\n                    if nextVal not in visited:\n                        visited.add(nextVal)\n                        tempQueue.append((nextVal, currentCount + 1))\n        return -1", "class Solution:\n    def coinChange(self, coins, amount):\n        coins.sort(reverse=True)\n        queue = [(amount, 0)]\n        visited = [False for i in range(amount+1)]\n        for val, cnt in queue:\n            if val == 0:\n                return cnt\n            for coin in coins:\n                if val - coin >= 0 and not visited[val-coin]:\n                    visited[val-coin] = True\n                    queue.append((val-coin, cnt+1))\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        #coinValues = collections.defaultdict(list)\n        for coin in coins:\n            for i in range(coin, amount+1):\n                if dp[i-coin] + 1 < dp[i]:\n                    dp[i] = dp[i-coin] + 1\n                    #coinValues[i] = coinValues[i-coin] + [coin]\n        #print(coinValues[amount])\n        return dp[-1] if dp[-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         dp = [float('inf')] * (amount + 1)\n#         dp[0] = 0\n        \n#         for coin in coins:\n#             for x in range(coin, amount + 1):\n#                 dp[x] = min(dp[x], dp[x - coin] + 1)\n#         return dp[amount] if dp[amount] != float('inf') else -1 \n    \n    \n        queue = deque([])\n        seen = set()\n        coins = sorted(coins, reverse=True)\n\n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1\n#         coins = sorted(coins, reverse=True)\n#         memo = {}\n#         def coinChangeRec(index, amount):\n#             if amount == 0:\n#                 return 0\n#             if amount < 0 or index == len(coins):\n#                 return math.inf\n#             if (index, amount) in memo:\n#                 return memo[(index, amount)]\n            \n#             withCoin = coinChangeRec(index, amount - coins[index]) + 1\n#             withoutCoin = coinChangeRec(index+1, amount)\n            \n#             memo[(index, amount)] = min(withCoin, withoutCoin)\n#             return min(withCoin, withoutCoin)\n                     \n#         minCoins = coinChangeRec(0, amount)\n#         if minCoins == math.inf:\n#             return -1\n#         return minCoins\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        queue = deque([])\n        seen = set()\n        \n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1\n#         coins = sorted(coins, reverse=True)\n#         memo = {}\n#         def coinChangeRec(index, amount):\n#             if amount == 0:\n#                 return 0\n#             if amount < 0 or index == len(coins):\n#                 return math.inf\n#             if (index, amount) in memo:\n#                 return memo[(index, amount)]\n            \n#             withCoin = coinChangeRec(index, amount - coins[index]) + 1\n#             withoutCoin = coinChangeRec(index+1, amount)\n            \n#             memo[(index, amount)] = min(withCoin, withoutCoin)\n#             return min(withCoin, withoutCoin)\n                     \n#         minCoins = coinChangeRec(0, amount)\n#         if minCoins == math.inf:\n#             return -1\n#         return minCoins\n    \n", "class Solution:\n    def coinChange(self, coins, amount):\n        if not coins: return -1\n        if not amount: return 0\n        if amount in coins: return 1\n        \n        C = tuple(sorted(coins,reverse=True))\n        length, self.ans = len(C)-1, float('inf')\n        \n        def find(coin, step, target):\n            now_coin = C[coin]\n            q, r = divmod(target,now_coin)\n            \n            if not r:\n                self.ans = min(self.ans, step+q)\n            elif coin < length and step+q+1 < self.ans:\n                coin += 1\n                for j in range(q,-1,-1):\n                    find(coin, step+j, target-j*now_coin)\n            \n        find(0, 0, amount)\n        return -1 if self.ans==float('inf') else self.ans", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         dp = [float('inf')] * (amount + 1)\n#         dp[0] = 0\n        \n#         for coin in coins:\n#             for x in range(coin, amount + 1):\n#                 dp[x] = min(dp[x], dp[x - coin] + 1)\n#         return dp[amount] if dp[amount] != float('inf') else -1 \n    \n    \n        queue = deque([])\n        seen = set()\n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1\n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         dp = [float('inf')] * (amount + 1)\n#         dp[0] = 0\n        \n#         for coin in coins:\n#             for x in range(coin, amount + 1):\n#                 dp[x] = min(dp[x], dp[x - coin] + 1)\n#         return dp[amount] if dp[amount] != float('inf') else -1 \n    \n    \n        queue = deque([])\n        seen = set()\n        \n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1\n#         coins = sorted(coins, reverse=True)\n#         memo = {}\n#         def coinChangeRec(index, amount):\n#             if amount == 0:\n#                 return 0\n#             if amount < 0 or index == len(coins):\n#                 return math.inf\n#             if (index, amount) in memo:\n#                 return memo[(index, amount)]\n            \n#             withCoin = coinChangeRec(index, amount - coins[index]) + 1\n#             withoutCoin = coinChangeRec(index+1, amount)\n            \n#             memo[(index, amount)] = min(withCoin, withoutCoin)\n#             return min(withCoin, withoutCoin)\n                     \n#         minCoins = coinChangeRec(0, amount)\n#         if minCoins == math.inf:\n#             return -1\n#         return minCoins\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        INVALID = float('inf')\n        dp = [INVALID] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                if dp[i - coin] >= dp[i]: continue\n                dp[i] = dp[i - coin] + 1\n        return -1 if dp[amount] == INVALID else dp[amount]\n\n        # # sol 2 dp bottom up\n        # INVALID = float('inf')\n        # dp = [INVALID] * (amount + 1)\n        # dp[0] = 0\n        # for i in range(amount + 1):\n        #     for coin in coins:\n        #         remains = i - coin\n        #         if remains < 0: continue\n        #         dp[i] = min(dp[i], dp[remains] + 1)\n        # return -1 if dp[amount] == INVALID else dp[amount]\n\n        # # sol 1 dp with memo\n        # memo = {}\n        # def dp(n):\n        #     if n in memo: return memo[n]\n        #     if n < 0: return -1\n        #     if n == 0: return 0\n        #     res = float('inf')\n        #     for coin in coins:\n        #         sub = dp(n - coin)\n        #         if sub == -1: continue\n        #         res = min(res, 1 + sub)\n        #     memo[n] = res if res != float('inf') else -1\n        #     return memo[n]\n        # return dp(amount)\n\n", "import math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0]*(amount+1)\n        dp[0] = 0\n        for i in range(1,amount+1):\n            min = math.inf \n            for j in coins:\n                if i-j>=0 and dp[i-j]<min:\n                    min = dp[i-j]\n            dp[i] = min+1\n        #print(dp)\n        return dp[-1] if dp[-1]!=math.inf else -1\n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        numpath = [0] + [float('inf')] * (amount) # \uac00\uc7a5 \ud070 \uac12\uc73c\ub85c amount + 1\ub9cc\ud07c \ubc30\uc5f4\uc744 \ucd08\uae30\ud654\n        \n        for coin in coins:\n            for i in range(coin, amount + 1):\n                # \ucc98\uc74c \ub3c4\ucc29\ud55c \uc704\uce58: numpath[i] = inf, numpath[i - coin] + 1 = inf\n                # \ucc98\uc74c \ub3c4\ucc29\ud55c \uacf3\uc774 \uc544\ub2cc \uc704\uce58: numpath[i] = \uc774\uc804\uae4c\uc9c0 \uc774 \uc704\uce58\uc5d0 \uc62c \uc218 \uc788\uc5c8\ub358 \ucd5c\uc18c \ub3d9\uc804 \uac1c\uc218\n                # numpath[i - coin] + 1 = \uc774\ubc88 coin\ub9cc\ud07c \uac74\ub108\ub744\uae30 \uc804\uc758 \uac12\uc5d0 + 1\uc744 \ud574\uc900 \ucd5c\uc18c \ub3d9\uc804 \uac1c\uc218 \n                if numpath[i] > 1 + numpath[i - coin]:\n                    numpath[i] = 1 + numpath[i - coin]\n                \n        return numpath[amount] if numpath[amount] != float('inf') else -1 # amount\uac00 inf\uac00 \uc544\ub2cc \uacbd\uc6b0\uc5d0 \ucd5c\uc18c \ub3d9\uc804 \uac1c\uc218\uac00 nunpath[amount]\uc5d0 \uc800\uc7a5", "'''\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 \nExplanation: 11 = 5 + 5 + 1\n\nremain =11\nfewest =inf\ninitially visited = (), q = [(11,1)] --count is 1 because of off-by-one (see code below)\n\nafter first while-iteration:\n    q [(10,1),(9,1),(6,1)]\n    visited(10,9,6)\n    \n----ALGO-----\nBFS:\nq = [(remain,count),(remain,count),...]\nvisited =set(amount_explored/to_explore, amt2, amt3) \n^ purpose: so we won't try to go down a path if that path (same remain target) has already been explored in another path\n\n----BIG-O----\nO(V+E) -- O(remain+nextRemain)?\n\n'''\nclass Solution:\n    from collections import deque\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount <= 0:\n            return 0\n        coins = set(coins)\n        count = 1\n        q = deque()\n        q.append((amount,count)) \n        visited = set()\n        visited.add(amount)\n        \n        while q:\n            remain,count = q.popleft()\n            if remain in coins:\n                return count\n            for c in coins:\n                if remain-c>0 and (remain-c) not in visited:\n                    q.append((remain-c,count+1))\n                    visited.add(remain-c) #to avoid going down this path if another path has already explored this\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n       \n        \n        def bfs():# bfs > dfs \n            q = [(amount, 0)]\n\n            if (amount == 0):\n                return 0\n\n            seen = set()\n            \n            coins.sort(reverse=True)\n            print(coins)\n            while len(q) > 0:\n                \n                a, ci = q.pop(0)\n                if a in seen:\n                    continue\n                else:\n                    seen.add(a)\n                \n                for c in coins:\n                    if a-c == 0:\n                        return ci+1 \n                    if a-c > 0:\n                        #print(a-c)\n                        #print(ci+1)\n                        q.append( (a-c, ci+1) )\n\n            return -1\n        \n        def dfs():\n            if (amount == 0):\n                return 0\n            \n            coins.sort()\n            \n            s = [ (amount, 0) ] \n            \n            while len(s) > 0:\n                a, ci = s.pop()\n                \n                for c in coins:\n                    if a-c == 0:\n                        return ci+1 \n                    if a-c > 0:\n                        #print(a-c)\n                        #print(ci+1)\n                        s.append( (a-c, ci+1) )\n                \n                \n            return -1\n        \n        def paste() -> int:\n            queue = deque([])\n            seen = set()\n\n            queue.append((0,0))\n\n            while queue:\n                summ, num_coins = queue.popleft()\n                if summ == amount:\n                    return num_coins\n\n                for coin in coins:\n                    if summ+coin<=amount and summ+coin not in seen:\n                        queue.append((summ+coin, num_coins+1))\n                        seen.add(summ+coin)\n\n            return -1\n        return paste()\n        #return bfs()\n        #return dfs()\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        Visited = {amount: 0}\n        coins.sort(reverse = True)\n        queue = deque()\n        queue.append(amount)\n        while queue:\n            curr = queue.popleft()\n            for coin in coins:\n                if curr - coin >= 0 and curr - coin not in Visited:\n                    queue.append(curr - coin)\n                    Visited[curr - coin] = Visited[curr] + 1\n                if 0 in Visited:\n                    return Visited[0]\n        return -1\n                \n        \n", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        q = deque()\n        q.append([amount,0])\n        level = 0\n        seen = set()\n        while q:\n            amt, level = q.popleft()\n            for n in coins:\n                if amt - n == 0:\n                    return level + 1\n                if amt - n in seen or amt - n < 0:\n                    continue\n                seen.add(amt-n)\n                q.append([amt-n, level+1])\n                \n        return -1", "'''\ncoins = [2, 7, 10]\n        [4, 9, 12] [9, 14, 17] [12, 17, 20]\namount = 14\n'''\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n        coins.sort()\n        visited = {}\n        sums = []\n        for coin in coins:\n            if coin == amount:\n                return 1\n            visited[coin] = 1\n            sums.append(coin)\n        \n        q = []\n        q.append((1, sums))\n        while q:\n            count, sums = q.pop()\n            next_sums = []\n            for coin in coins:\n                for s in sums:\n                    current = coin + s\n                    if current < amount and current not in visited:\n                        visited[current] = 1\n                        next_sums.append(current)\n                    elif current == amount:\n                        return count + 1\n                    else:\n                        visited[current] = 1\n            if next_sums:\n                q.insert(0, (count + 1, next_sums))\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        if amount == 0:\n            return 0\n        elif amount < 0:\n            return -1\n        else:\n            arr = []\n            for i in coins:\n                rv = self.coinChange(coins, amount - i)\n                if rv != -1:\n                    arr.append(rv)\n            if not arr:\n                return -1\n            else:\n                return min(arr) + 1\n        '''\n        dp = [amount+1 for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(amount+1):\n            for c in coins:\n                if c <= i and dp[i] > dp[i-c] + 1:\n                    dp[i] = dp[i-c] + 1\n        return -1 if dp[amount] > amount else dp[amount]", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        queue = deque([])\n        seen = set()\n        \n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1", "from collections import deque\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        This a DP problem\n        but we can solve this using BFS\n        https://leetcode.com/problems/coin-change/discuss/77361/Fast-Python-BFS-Solution\n        '''\n        \n        if not amount:\n            return 0\n        \n        queue = deque([(amount, 0)])\n        visited = set([amount])\n        while queue:\n            remaining, steps = queue.popleft()\n            \n            for coin in coins:\n                if coin == remaining:\n                    return steps + 1\n                elif coin < remaining:\n                    temp = remaining - coin\n                    if temp > 0 and temp not in visited:\n                        visited.add(temp)\n                        queue.append((temp, steps + 1))\n        return -1", "from collections import deque\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        queue = deque()\n        visited = [False] * amount\n        queue.append((amount, 0))\n        answer = -1\n        while queue:\n            target, numCoins = queue.popleft()\n            if target == 0:\n                answer = numCoins\n                break\n            elif target > 0:\n                for coin in coins:\n                    if target - coin >= 0 and not visited[target - coin]:\n                        visited[target - coin] = True\n                        queue.append((target - coin, numCoins + 1))\n        return answer", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        queue = deque([])\n        seen = set()\n        \n        queue.append((0,0))\n        \n        while queue:\n            summ, num_coins = queue.popleft()\n            if summ == amount:\n                return num_coins\n            \n            for coin in coins:\n                if summ+coin<=amount and summ+coin not in seen:\n                    queue.append((summ+coin, num_coins+1))\n                    seen.add(summ+coin)\n        \n        return -1\n                    \n                \n", "from collections import defaultdict\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        MAX = float('inf')\n        dp = defaultdict(lambda: MAX)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            dp[i] = 1 + min([dp[i-c] for c in coins])\n        return -1 if dp[amount] == MAX else dp[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        l = [int(amount+1)] * int(amount+1)\n        if amount == 0:\n            return 0\n        else:\n            l[0] = 0\n            # sort coins as an optimization\n            coins.sort()\n            for i in range(1, amount + 1):\n                for coin in coins:\n                    remainder = i - coin\n                    if remainder < 0:\n                        break\n                    else:\n                        if l[i] > l[remainder] + 1:\n                            l[i] = l[remainder] + 1\n        if l[amount] == amount + 1:\n            return -1\n        else:\n            return l[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        coins.sort(reverse=True)\n        queue = [amount]\n        visit = {amount: 0}\n        while queue:\n            remain = queue.pop(0)\n            for c in coins:\n                branch = remain - c\n                if 0 <= branch not in visit:\n                    queue.append(branch)\n                    visit.update({branch: visit[remain] + 1})\n        return visit.get(0) or -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount ==0:return 0\n        visited = set([amount])\n        candidates = [amount]\n        res = 0\n        while candidates:\n            res += 1\n            next_candidates = []\n            for candidate in candidates:\n                for coin in coins:\n                    if candidate-coin ==0:\n                        return res\n                    elif candidate-coin >0 and candidate-coin not in visited:\n                        next_candidates.append(candidate- coin)\n                        visited.add(candidate-coin)\n            candidates = next_candidates\n            \n        return -1", "class Solution:\n    def coinChange(self, denoms: List[int], n: int) -> int:  \n        if n == 0:\n            return 0\n        nodes = set([0])\n        seen = set()\n        count = 1\n        while nodes:\n            seen = seen | nodes\n            next_nodes = set()\n            for node in nodes:\n                for denom in denoms:\n                    candidate = node + denom\n                    if candidate == n:\n                        return count\n                    elif candidate < n and candidate not in seen:\n                        next_nodes.add(candidate)\n            count += 1\n            nodes = next_nodes\n\n        return -1\n        pass", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        l = [int(amount+1)] * int(amount+1)\n        if amount == 0:\n            return 0\n        else:\n            l[0] = 0\n            for i in range(1, amount + 1):\n                for coin in coins:\n                    remainder = i - coin\n                    if remainder < 0:\n                        pass\n                    else:\n                        if l[i] > l[remainder] + 1:\n                            l[i] = l[remainder] + 1\n        if l[amount] == amount + 1:\n            return -1\n        else:\n            return l[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        d = [0] + [float('inf')] * amount\n        for v in range(1, len(d)):\n            for c in coins:\n                if c <= v and d[v] > (d[v-c] + 1):\n                    d[v] = d[v-c] + 1\n        return d[-1] if d[-1] < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        queue = deque()\n        numCoins = 0\n        seen = set()\n        coins.sort(reverse=True)\n        queue.append(amount)\n        \n        if amount == 0:\n            return 0\n        \n        while queue:\n            qlen = len(queue)\n            numCoins += 1\n            for i in range(qlen):\n                x = queue.popleft()\n                for coin in coins:\n                    if x - coin == 0:\n                        return numCoins\n                    elif x - coin > 0:\n                        if x-coin not in seen:\n                            queue.append(x-coin)\n                            seen.add(x-coin)\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        result = -1\n\n        def helper(coins: List[int], pos: int, left: int, current: int):\n            if left % coins[pos] == 0:\n                nonlocal result\n                if result == -1 or result > current + left // coins[pos]:\n                    result = current + left // coins[pos]\n                return\n\n            if pos == len(coins) - 1:\n                return\n\n            for k in range(left // coins[pos], -1, -1):\n                new_amount = left - coins[pos] * k\n                new_count = current + k\n                if result != -1 and result < new_count + (new_amount + coins[pos + 1] - 1) / coins[pos + 1]:\n                    break\n                helper(coins, pos + 1, left - coins[pos] * k, current + k)\n\n        helper(coins, 0, amount, 0)\n        return result\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount: return 0\n        queue = collections.deque([(0,0)])\n        seen = set()\n        while queue:\n            curAmount,step = queue.popleft()\n            if curAmount == amount:\n                return step\n            for j in range(len(coins)):\n                newAmount = curAmount+coins[j]\n                if newAmount <= amount and newAmount not in seen:\n                    seen.add(newAmount)\n                    queue.append((newAmount,step+1))\n                    \n        return -1\n", "class Solution:\n    # def coinChange(self, coins: List[int], amount: int) -> int:\n    #     if amount == 0:\n    #         return 0\n    #     coins.sort(reverse = True)\n    #     m = amount + 1\n    #     store = [float('inf')] * m\n    #     store[0] = 0\n    #     for i in range(len(coins)):\n    #         x = self.countChange(coins, amount, i, store)\n    #         if x > -1:\n    #             m = min(m, x)\n    #     return m if m != amount + 1 else -1\n    \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        store = [float('inf')] * (amount + 1)\n        store[0] = 0\n        for i in range(amount+1):\n            for coin in coins:\n                if i-coin >= 0 and store[i] > store[i-coin] + 1:\n                    store[i] = store[i-coin] + 1\n        return store[amount] if store[amount] != float('inf') else -1\n    \n\n    \n    # def countChange(self, coins: List[int], amount: int, index: int, store) -> int:\n    #     if amount == 0:\n    #         return 0\n    #     elif store[amount] != float('inf'):\n    #         return store[amount]\n    #     elif index >= len(coins):\n    #         return -1\n    #     elif amount < coins[index]:\n    #         return -1\n    #     m = float('inf')\n    #     for i in range(1, amount // coins[index] + 1):\n    #         for j in range(len(coins)+1):\n    #             x = self.countChange(coins, amount - coins[index] * i, j, store)\n    #             if x > -1:\n    #                 m = min(m, x + i)\n    #     store[amount] = m\n    #     return m if m != float('inf') else -1\n        \n        \n    # def countChange(self, coins: List[int], amount: int, index: int) -> int:\n    #     if index >= len(coins):\n    #         return 0\n    #     elif amount < coins[index]:\n    #         return 0\n    #     # num = amount // coins[index]\n    #     num = 1\n    #     print(coins, amount, index, num)\n    #     amount -= coins[index]\n    #     if amount == 0:\n    #         return num\n    #     for i in range(index, len(coins)):\n    #         x = self.countChange(coins, amount, i)\n    #         if x > 0:\n    #             return x + num\n    #     else:\n    #         return 0\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n        coins.sort()\n        coins_set=set(coins)\n        if amount in coins_set:\n            return 1\n        queue=deque([[amount,0]])\n        seen=set()\n        processed=set()\n        while queue:\n            rem,count=queue.popleft()\n            if rem in seen:\n                continue\n            seen.add(rem)\n            #print(rem)\n            for coin in coins:\n                new_rem=rem-coin\n                if new_rem==0:\n                    return count+1\n                if new_rem>0:\n                    if new_rem in coins_set:\n                        return count+2\n                    if new_rem not in seen and new_rem not in processed:\n                        queue.append([new_rem,count+1])\n                        processed.add(new_rem)\n        return -1\n    \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         if not amount:\n#             return 0\n        \n\n        \n#         coins.sort()\n        \n#         coinsSet=set(coins)\n        \n#         if amount in coins:\n#             return 1\n        \n#         currLevel=[amount]\n#         nextLevel=[]\n#         level=1\n        \n#         seen=set()\n        \n#         while currLevel:\n            \n#             while currLevel:\n#                 node=currLevel.pop(0)\n                \n#                 for coin in coins:\n#                     temp=node-coin\n#                     if temp<0:\n#                         break\n#                     if temp not in seen:\n#                         if temp in coinsSet:\n#                             return level+1\n#                         else:\n#                             nextLevel.append(temp)\n#                             seen.add(temp)\n#             level+=1\n#             currLevel=nextLevel\n#             nextLevel=[]\n#         return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('+inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for cnt in range(1, amount + 1):\n            for coin in coins:\n                if cnt - coin >= 0 and dp[cnt - coin] + 1 < dp[cnt]:\n                    dp[cnt] = dp[cnt - coin] + 1\n\n        if dp[amount] == float('+inf'):\n            return -1\n        \n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf') for _ in range(amount + 1)]\n        \n        dp[0] = 0\n        \n        for x in range(len(dp)):\n            for coin in coins:\n                if x < coin:\n                    continue\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n        if dp[amount] == float('inf'):\n            return -1\n        else:\n            return dp[x]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        rec = [0]*(amount)\n        fr = [0]\n        new = []\n        l=1\n        while fr or new:\n            if not fr:\n                fr = new\n                new = []\n                l+=1\n            cur = fr.pop(0)\n            for c in coins:\n                if cur+c == amount:\n                    return l\n                if cur+c < amount and not rec[cur+c]:\n                    new.append(cur+c)\n                    rec[cur+c] = 1\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = [float('inf') for _ in range(amount+1)]\n        memo[0] = 0\n        for i in range(1, len(memo)):\n            minv = float('inf')\n            for coin in coins:\n                if i-coin >= 0 and memo[i-coin] < minv:\n                    minv = memo[i-coin]\n            memo[i] = 1 + minv\n        #print(memo)\n        return memo[amount] if memo[amount] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        cache = [0]*(amount+1)\n        for ind in range(1, amount + 1):\n            min_coins = float('inf')\n        \n            for coin in coins:\n                if ind - coin >= 0:\n                    coins_needed = cache[ind - coin] + 1\n                    if coins_needed < min_coins:\n                        min_coins = coins_needed\n            cache[ind] = min_coins\n        # print(cache)\n        if cache[amount] == float('inf'):\n            return -1\n        return cache[amount]\n                    \n", "class Solution:\n    def coinChange(self, coins: [int], amount: int) -> int:\n        summary = 0\n        result = [float('inf')]*(amount+1)\n        result[0] = 0\n        while summary <= amount:\n            if result[summary] != -1:\n                for i in coins:\n                    if summary + i <= amount and result[summary] + 1 < result[summary + i]:\n                        result[summary + i] = result[summary] + 1\n            summary += 1\n        return -1 if result[amount] == float('inf') else result[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        arr = [float('inf')] * (amount+1) \n        arr[0] = 0\n        \n        for i in range(amount+1):\n            for c in coins:\n                if i+c > amount:\n                    continue\n                                \n                if arr[i+c] > arr[i] + 1:\n                    arr[i+c] = arr[i] + 1\n                    \n        \n        if arr[-1] == float('inf'):\n            return -1\n        \n        return arr[-1]\n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        \n        min_coins = [float('inf') for x in range(amount + 1)]\n        \n        min_coins[0] = 0\n        \n        for value in range(1, amount+1):\n            for coin in coins:\n                if coin <= value:\n                    if min_coins[value-coin] + 1 < min_coins[value] :\n                        min_coins[value] = min_coins[value-coin] + 1\n        \n        if min_coins[amount] == float('inf'):\n            return -1\n        return min_coins[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[amount, 0]]\n        visited = {0}\n        for q in queue:\n            for c in coins:\n                if q[0] == c:\n                    return q[1] + 1\n                elif q[0] > c and q[0] - c not in visited:\n                    visited.add(q[0] - c)\n                    queue.append([q[0]-c, q[1] + 1])\n        return -1\n                 \n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        m = [-1 for x in range(amount+1)]\n        m[0] = 0\n        coins = sorted(coins)\n        if amount < min(coins):\n            return m[amount]\n        m[coins[0]] = 1\n        for x in range(coins[0], amount+1):\n            current_min = 10000000\n            for y in coins:\n                if y > x:\n                    continue\n                if m[x-y] < current_min and m[x-y] != -1:\n                    current_min = m[x-y]\n            if current_min == 10000000:\n                m[x] = -1\n            else:\n                m[x] = current_min + 1\n        print(m)\n        return m[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[0]*(amount+1)\n        for i in range(1,len(dp)):\n            dp[i]=float('inf')\n            for j in coins:\n                if i>=j and dp[i-j]+1<dp[i]:\n                    dp[i]=dp[i-j]+1\n        return -1 if dp[amount]==float('inf') else dp[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1] * (amount+1)\n        dp[0] = 0\n        for i in range(amount+1):\n            for n in coins:\n                if i - n >= 0 and dp[i-n] + 1 < dp[i]:\n                    dp[i] = dp[i-n] + 1\n        return dp[-1] if dp[-1] != amount + 1 else -1", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        queue = deque()\n        queue.append((amount,0))\n        visited = set()\n        while queue:\n            remainder, level = queue.popleft()\n            for coin in coins:\n                if remainder - coin == 0:\n                    return level+1\n                \n                elif remainder - coin > 0 and (remainder - coin) not in visited:\n                    queue.append((remainder - coin,level+1))\n                    visited.add(remainder-coin)\n        \n        return -1 ", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        # Sol.3 - DP (Bottom up)\n        dp = [amount+1] * (amount+1)\n        dp[0] = 0\n        for i in range(amount+1):\n            for coin in coins:\n                if coin <= i and (dp[i] > dp[i-coin]+1):\n                    dp[i] = dp[i-coin] + 1\n\n        return dp[amount] if dp[amount] != (amount + 1) else -1\n    \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        table = [0] + [amount+1 for _ in range(amount)]\n        for i in range(1,amount+1):\n            for coin in coins:\n                if coin<= i:\n                    sub_result = table[i-coin]\n                    if sub_result +1 < table[i]:\n                        table[i] = sub_result+1\n        \n        print(table)\n        if table[amount]>amount:\n            return -1\n        else:\n            return table[amount]", "class Solution:\n    def bfs(self, cur, coins):\n        if cur == 0:\n            return 0\n        queue = [(0, cur)]\n        visited = {}\n        while queue:\n            times, cur = heapq.heappop(queue)\n            for c in coins:\n                if c == cur:\n                    return times +1\n                if c < cur:\n                    if cur-c not in visited:\n                        heapq.heappush(queue, (times+1, cur- c))\n                        visited[cur-c] = True\n        return -1\n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        return self.bfs(amount, coins)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [float('inf')] * (amount+1)\n        dp[0] = 0\n        \n        for i in range(1, amount+1):\n            tmp = float('inf')\n            for c in coins:\n                if i - c >= 0:\n                    if tmp >  dp[i-c] + 1:\n                        tmp = dp[i-c] + 1\n            dp[i] = tmp\n        \n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[amount, 0]]\n        visited = set()\n        for q in queue:\n            for c in coins:\n                if q[0] == c:\n                    return q[1] + 1\n                elif q[0] > c and q[0] - c not in visited:\n                    visited.add(q[0] - c)\n                    queue.append([q[0]-c, q[1] + 1])\n        return -1\n                 \n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp_mat = [-1] * (amount + 1)\n        dp_mat[0] = 0\n\n        for i in range(1, amount + 1):\n            min_num = None\n            \n            for denom in coins:\n                if denom <= i and dp_mat[i - denom] != -1:\n                    temp = 1 + dp_mat[i - denom]\n                    if not min_num:\n                        min_num = temp\n                    elif temp < min_num:\n                        min_num = temp\n            \n            if min_num:\n                dp_mat[i] = min_num\n        \n        return dp_mat[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        dp = [float('inf')] * (amount + 1)\n        calculated = [False] * (amount + 1)\n\n        dp[0] = 0\n\n        for coin in coins:\n            if coin <= amount:\n                dp[coin] = 1\n                calculated[coin] = True\n\n        for i in range(1, amount+1):\n            if not calculated[i]:\n                candidates = [dp[i-coin] for coin in coins if i >= coin]\n                if candidates:\n                    dp[i] = min(candidates) + 1\n                    calculated[i] = True\n                \n        if dp[-1] == float('inf'):\n            return -1\n        else:\n            return dp[-1]\n", "class Solution:\n\n    \n    def do_du_tab(self, coins, amount):\n        dp_tab = [math.inf for _ in range(amount+1)]\n        dp_tab[0] = 0\n        for a in range(1, amount+1):\n            potential = []\n            \n            for coin in coins: \n                potential.append(dp_tab[a-coin]+1)\n            \n            dp_tab[a] = min(potential)\n            \n        return dp_tab[-1] if dp_tab[-1]!=float('inf') else -1\n\n    def do_something(self, coins, amount):\n        dp_tab = [math.inf for _ in range(amount+1)]\n        dp_tab[0] = 0\n        \n        for i in range(1,amount+1):\n            temp = []\n            for coin in coins:\n                temp.append(dp_tab[i - coin])\n    \n            dp_tab[i] = min(temp) + 1\n        return dp_tab[amount] if dp_tab[amount]!=float('inf') else -1 \n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n       \n        if len(coins) == 0:\n            return 0\n        if amount == 0:\n            return 0\n  \n        c = [coin for coin in coins if coin <= amount]\n        if len(c) == 0:\n           return -1\n        #c.sort(reverse=True)\n        return self.do_something(c, amount)\n        #return self.do_du_tab(c, amount)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            curr_min = amount + 1\n            for coin in coins:\n                cand = amount + 1\n                if i - coin >= 0:\n                    cand = dp[i - coin] + 1\n                if cand < curr_min: \n                    curr_min = cand\n            dp[i] = curr_min\n            \n        return -1 if dp[len(dp) - 1] == amount + 1 else dp[len(dp) - 1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n      \n      dp = [0] + [amount + 1] * amount\n      \n      for i in range(1, amount + 1):\n        for c in coins:\n          if i - c >= 0:\n            if dp[i-c] < dp[i]:\n              dp[i] = dp[i-c] + 1\n      return dp[amount] if dp[amount] < amount + 1 else - 1\n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        return self.coinChangeBFS(coins, amount)\n    def coinChangeBFS(self, coins: List[int], amount: int) -> int:\n        if amount == 0 or not coins:\n            return 0\n        queue = deque([amount])\n        visited = set([amount])\n        depth = 0\n        while queue:\n            length = len(queue)\n            depth += 1\n            for i in range(length):\n                remaining = queue.popleft()\n                for c in coins:\n                    if remaining - c == 0:\n                        return depth\n                    elif remaining - c < 0:\n                        continue\n                    elif (remaining - c) not in visited:\n                        queue.append(remaining- c)\n                        visited.add(remaining - c)\n        return -1\n", "class Solution:\n#     def do_bf(self, coins, amount, index):\n#         if amount == 0:\n#             return 0\n#         n = len(coins)\n#         if n <= index:\n#             return math.inf\n\n#         count_keeping_element = math.inf\n#         if coins[index] <= amount:\n#             temp = self.do_bf(coins, amount - coins[index], index)\n#             if temp != math.inf:\n#                 count_keeping_element = temp + 1\n\n#         count_skipping_element = self.do_bf(coins, amount, index + 1)\n#         return min(count_keeping_element, count_skipping_element)\n\n#     def do_td_mem(self, cache, coins, amount, index):\n\n#         if amount == 0:\n#             return 0\n\n#         if len(coins) <= index:\n#             return math.inf\n\n#         if cache[index][amount] == math.inf:\n#             count_keeping_element = math.inf\n#             if coins[index] <= amount:\n#                 temp = self.do_td_mem(cache, coins, amount - coins[index], index)\n#                 if temp != math.inf:\n#                     count_keeping_element = temp + 1\n\n#             count_skipping_element = self.do_td_mem(cache, coins, amount, index + 1)\n#             cache[index][amount] = min(count_keeping_element, count_skipping_element)\n#         return cache[index][amount]\n\n\n    \n    def do_du_tab(self, coins, amount):\n        dp_tab = [math.inf for _ in range(amount+1)]\n        dp_tab[0] = 0\n        for a in range(1, amount+1):\n            potential = []\n            \n            for coin in coins: \n                potential.append(dp_tab[a-coin]+1)\n            \n            dp_tab[a] = min(potential)\n            \n        return dp_tab[-1] if dp_tab[-1]!=float('inf') else -1\n\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n       \n        if len(coins) == 0:\n            return 0\n        if amount == 0:\n            return 0\n  \n        c = [coin for coin in coins if coin <= amount]\n        if len(c) == 0:\n           return -1\n        #c.sort(reverse=True)\n\n        return self.do_du_tab(c, amount)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        values = [-1 for i in range(amount+1)]\n        values[0] = 0\n        \n        # loop through all coins\n        for i in coins:\n            # loop through values for coins to add up to\n            for j in range(1,len(values)):\n                # check if current coin is greater than value\n                if j>=i:\n                    # continue if no possible combinations\n                    if values[j-i]==-1: continue\n                    curr_num_coins = 1 + values[j-i]\n                    # check if number of coins for value is already fewer\n                    if values[j]==-1 or values[j]>curr_num_coins:\n                        # update current minimum coins required\n                        values[j] = curr_num_coins\n        return values[amount]", "class Solution:\n    def coinChange(self, nums: List[int], amount: int) -> int:\n        MAX = float('inf')\n        dp = [0] + [MAX] * amount\n\n        for i in range(1, amount + 1):\n            dp[i] = min([dp[i - c] if i - c >= 0 else MAX for c in nums]) + 1\n\n        return [dp[amount], -1][dp[amount] == MAX]\n", "from collections import deque\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        dp = [float('inf')] * (amount + 1)\n        dp[amount] = 0\n        queue = deque()\n        queue.append(amount)\n        \n        while len(queue) != 0:\n            val = queue.popleft()\n            for coin in coins:\n                if val - coin == 0:\n                    return dp[val] + 1\n                if val - coin > 0:\n                    if dp[val] + 1 < dp[val-coin]:\n                        dp[val-coin] = dp[val] + 1\n                        queue.append(val-coin)\n            \n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        MAX = amount + 1\n        coins.sort(reverse=True)\n        dp = [MAX]*(MAX)\n        dp[0] = 0\n        for i in range(1, MAX):\n            dp[i] = min([dp[i-c] if i>=c else (MAX) for c in coins]) ### List Comprehension is faster\n            dp[i] = dp[i] + 1 if dp[i] != MAX else dp[i]\n        return -1 if (dp[-1] == MAX) else dp[-1]\n    \n#         coins.sort()\n#         return self.countCoins(coins,amount,len(coins),0)\n        \n#     def countCoins(self,coins,amount,idx,count):\n#         if idx < 0:\n#             return -1\n#         elif amount - 1 or count < 0:\n#             return float('inf')\n#         c = amount//coins[idx]\n#         rem = amount % coins[idx]\n#         if rem == 0:\n#             return count+c\n#         else:\n#             return self.countCoins(coins,rem,idx-1,count+c)\n   \n       \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        MAX = float('inf')\n        dp = [0] + [MAX] * amount\n\n        for i in range(1, amount + 1):\n            dp[i] = min([dp[i - c] if i - c >= 0 else MAX for c in coins]) + 1\n\n        return [dp[amount], -1][dp[amount] == MAX]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         \u65b9\u6cd5\u4e00: dp[i] = min(dp[i],dp[amount-i]+1)\n        # dp = [0]\n        # length = len(coins)\n        # for i in range(1, amount+1):\n        #     dp += [9999]\n        #     for j in range(length):\n        #         if i >= coins[j] and dp[int(i-coins[j])] != 9999:\n        #             dp[i] = min(dp[i], dp[int(i-coins[j])] + 1)\n        # if dp[amount] == 9999:\n        #     return -1\n        # return dp[amount]\n\n#         \u4f18\u5316\u540e\u7684\u65b9\u6cd5: dp[x+c] = min(dp[x]+1, dp[x+c])\n        dp = [0] + [-1]*amount\n        for x in range(amount+1):\n            if dp[x] < 0:\n                continue\n            for c in coins:\n                if x + c > amount:\n                    continue\n                if dp[x+c] < 0 or dp[x+c] > dp[x] + 1:\n                    dp[x+c] = dp[x] + 1\n        return dp[amount]\n    \n        # dp = [0] + [-1] * amount\n        # for x in range(amount):\n        #     if dp[x] < 0:\n        #         continue\n        #     for c in coins:\n        #         if x + c > amount:\n        #             continue\n        #         if dp[x + c] < 0 or dp[x + c] > dp[x] + 1:\n        #             dp[x + c] = dp[x] + 1\n        # return dp[amount]\n", "class Solution:\n    def coinChangeCopy(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n    \n        dp = [amount + 1] * (amount + 1)\n        for i in range(amount + 1):\n            if i in coins:\n                dp[i] = 1\n                continue\n            candidates = [dp[i - coin] + 1 for coin in coins if i - coin > 0]\n            if candidates:\n                dp[i] = min(candidates)\n        print(dp)\n        return -1 if dp[amount] > amount else dp[amount]\n\n    \n    def coinChange(self, coins, amount):\n        # num of coins needed for amount from 0 to \\\"amount\\\"\n        if not amount:\n            return 0\n        \n        coin_nums = [amount + 1] * (amount + 1) \n        coins_set = set(coins)\n        \n        for i in range(amount + 1):\n            if i in coins_set:\n                coin_nums[i] = 1\n                continue\n            candidates = [coin_nums[i - coin] + 1  for coin in coins if i - coin > 0]\n            if candidates:\n                coin_nums[i] = min(candidates)\n        return coin_nums[amount] if coin_nums[amount] <= amount else -1\n        \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        coins.sort(); cnt = 0; toCheck = {amount}\n        while toCheck:\n            cnt += 1; tmp = set()\n            for x in toCheck:\n                for y in coins:\n                    if y == x: return cnt\n                    if y > x: break\n                    tmp.add(x-y)\n            if not tmp: return -1\n            toCheck = tmp\n            \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for i in range(1, amount+1):\n            dp[i] = min(dp[i-c] if i-c>=0 else float('inf') for c in coins) + 1\n        return dp[-1] if dp[-1] != float('inf') else -1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #coins.sort()\n        dp = [0] + [-1] * amount\n        #print(dp)\n        for coin in coins:\n            for idx in range(coin, len(dp)):    \n                if dp[idx - coin] != -1:\n                    if dp[idx] != -1:\n                        dp[idx] = min(dp[idx - coin] + 1, dp[idx])\n                    else:\n                        dp[idx] = dp[idx - coin] + 1\n        #print(dp)\n        return dp[amount]\n", "class Solution(object):\n    def coinChange(self, coins, amount):\n        MAX = float('inf')\n        dp = [0] + [MAX] * amount\n\n        for i in range(1, amount + 1):\n            dp[i] = min([dp[i - c] if i - c >= 0 else MAX for c in coins]) + 1\n        if dp[amount] == MAX:\n            return -1\n        return dp[amount]\n        return [dp[amount], -1][dp[amount] == MAX]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0]+[-1]*amount\n        for i in range(len(dp)):\n            if dp[i] < 0:\n                continue\n            for x in coins:\n                if i+x>amount:\n                    continue\n                if dp[i+x] == -1 or dp[i+x] >dp[i]+1:\n                    dp[i+x] = dp[i]+1\n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount+1)\n        dp[0] = 0\n        \n        for i in range(min(coins), amount+1):\n            tmp = list()\n            for coin in coins:\n                if (i-coin) < 0:\n                    tmp.append(float('inf'))\n                else:\n                    tmp.append(dp[i-coin])\n            dp[i] = min(tmp) + 1\n        \n        return dp[-1] if dp[-1]!= float('inf') else -1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount: return 0\n        coins = [coin for coin in coins if coin <= amount]\n        if not coins: return -1\n        dp = [0 for i in range(amount+max(coins)+10)]\n        for coin in coins:\n            dp[coin] = 1\n        for i in range(1, amount + 1):\n            for coin in coins:\n                if dp[i] >= 1:\n                    if dp[i+coin] == 0: \n                        dp[i+coin] = dp[i] + 1\n                    else:\n                        if dp[i] + 1 < dp[i+coin]:\n                            dp[i+coin] = dp[i] + 1\n        if not dp[amount]: return -1\n        return dp[amount]", "class Solution(object):\n    def coinChange(self, coins, amount):\n        MAX = float('inf')\n        dp = [0] + [MAX] * amount\n\n        for i in range(1, amount + 1):\n            dp[i] = min([dp[i - c] if i - c >= 0 else MAX for c in coins]) + 1\n\n        return [dp[amount], -1][dp[amount] == MAX]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount+1):\n                if coin <= x:\n                    dp[x] = min(dp[x], dp[x-coin]+1)\n                \n        return dp[amount] if dp[amount] != float('inf') else -1\n        '''\n        '''\n        def helper(amount):\n            if amount < 0:\n                return -1\n            elif amount == 0:\n                return 0\n            minCoins = None\n            for coin in coins:\n                totCoins = 1 + helper(amount - coin)\n                \n                if totCoins > 0 and (minCoins is None or totCoins < minCoins):\n                    minCoins = totCoins\n            if minCoins is None:\n                return -1\n            else:\n                return minCoins\n        return helper(amount)\n        '''\n        def dfs(start, amt, n_coins):\n            nonlocal min_coins\n\n            coin = coins[start]\n\n            # LHS = lower bound on number of coins, achieved using the current coin\n            # Return early since we can't possibly achieve original \\\"amount\\\"\n            # along this path.\n            # For this particular solution, this check isn't necessarily,\n            # since there is another check within the loop below. However, it\n            # speeds up the solution. Better to have this check before the\n            # \\\"amt == 0\\\" check below.\n            #if n_coins + (amt + coin - 1) / coin > min_coins:\n            #if (min_coins - n_coins - 1) * coin + 1 < amt:\n            #    return\n\n            div = amt // coin\n            n_coins += div\n            amt %= coin\n            \n            if amt == 0:\n                min_coins = min(min_coins, n_coins)\n                return\n            \n            if start < len_coins:\n                # use as many of current coin as possible, and try next smaller coin\n                dfs(start + 1, amt, n_coins)\n\n                # Always greedily taking as many of biggest coins as possible doesn't work.\n                # \\\"Backtrack\\\" by using 1 less of current coin per iteration, and\n                # trying the next smaller coin.\n\n                next_coin = coins[start + 1]\n                \n                for _ in range(div):\n                    amt += coin \n                    n_coins -= 1\n                    \n                    if (min_coins - n_coins - 1) * next_coin + 1 > amt:\n                    #if (min_coins - n_coins) * next_coin > amt: # hope still exists\n                        dfs(start + 1, amt, n_coins)\n                    else:\n                        break\n        \n        len_coins = len(coins) - 1\n        \n        # try biggest coins first\n        coins.sort(reverse=True)\n        \n        min_coins = float('inf')\n\n        dfs(0, amount, 0)\n        \n        return min_coins if min_coins < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        a = [amount+1]*(amount+1)\n        a[0] = 0\n        \n        for i in range(1,amount+1):\n            mlist = [a[i-c] for c in coins if i-c>=0]\n            if len(mlist)>0:\n                a[i] = 1+min(mlist)\n\n        print(a)\n        if a[amount] > amount:\n            return -1\n        else:\n            return a[amount]\n            \n                \n                    \n                \n            \n            \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        coins_set = set(coins)\n        for i in range(amount + 1):\n            if i in coins_set:\n                dp[i] = 1\n                continue\n            candidates = [dp[i - c] + 1 for c in coins if i - c >= 0]\n            if candidates:\n                dp[i] = min(candidates)\n        return dp[amount] if dp[amount] <= amount else -1", "import math\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        path_length = []\n        path_length.append(0)\n        for value in range(1, amount + 1):\n            min_path_value = math.inf\n            for coin in coins:\n                path_index = value - coin\n                \n                if path_index > -1 and path_length[path_index] != -1:\n                    current_min_path = path_length[path_index] + 1\n                    if current_min_path < min_path_value:\n                        min_path_value = current_min_path\n                        \n            path_length.append(min_path_value)\n        \n        return path_length[amount] if path_length[amount] < math.inf else -1 \n    \n    \n        \n   \n\n\n    \n            \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        cache = [0] * (amount+1)\n        for i in range(1, amount+1):\n            min_count = float('inf')\n            \n            for coin in coins:\n                if i-coin >= 0:\n                    current_min_coin = cache[i-coin] + 1\n                    if min_count > current_min_coin:\n                        min_count = current_min_coin\n                        \n            cache[i] = min_count\n        \n        if cache[amount] in [0, float('inf')]:\n            return -1\n            \n        return cache[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        Max = float('inf')\n        \n        dp = [0] + [Max] * amount\n        \n        for i in range(1, amount + 1):\n            dp[i] = min(dp[i - c] if i - c >= 0 else Max for c in coins) + 1\n        return dp[amount] if dp[amount] != Max else - 1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [None for i in range(amount + 1)]\n        \n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            result = None\n            for coin in coins:\n                if i - coin >= 0:\n                    tmp = dp[i - coin]\n                    if tmp is not None and (result is None or tmp + 1 < result):\n                        result = tmp + 1\n            dp[i] = result\n        \n        if dp[-1] is None:\n            return -1\n        \n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        #let arr[i] be the min amt of coins needed to produce amount i\n        arr = [float('inf')] * (amount+1)\n        arr[0] = 0 \n        \n        for i in range(1, len(arr)): \n            min_choices = []\n            for x in coins: \n                if i - x >= 0: \n                    min_choices.append(1 + arr[i-x])\n            \n            if min_choices: \n                arr[i] = min(min_choices)\n        \n        if arr[amount] == float('inf'): \n            return -1\n        else: \n            return arr[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if not coins and amount:\n            return -1\n        \n        if not amount:\n            return 0\n        \n        target = [0]*(amount+1)\n        target[0] = 1\n        \n        #coins[::-1].sort()\n        \n        for i in range(len(coins)-1, -1, -1):\n            \n            coin = coins[i]\n            j = 0\n            while j <= amount:\n                \n                if target[j] == 0:\n                    j+=1\n                    continue\n                \n                next_idx = j+coin\n                if next_idx > amount:\n                    break\n                \n                if target[j] > 0 and (target[next_idx] > target[j]) or target[next_idx] == 0:\n                    target[next_idx] = target[j] + 1\n                \n                j+=1\n        \n        \n        print(target)\n        if target[amount]:\n            return target[amount]-1\n        else:\n            return -1", "class Solution:\n    \n    def __init__(self):\n        self.min_coins = float('inf')\n        \n    def coinChange(self, coins: List[int], amount: int) -> int:    \n        def getChange(num_coins, need, start):\n            divided_coin = need // coins[start]\n            \n            if num_coins + divided_coin >= self.min_coins:\n                return\n            \n            if need % coins[start] == 0:\n                self.min_coins = min(self.min_coins, divided_coin + num_coins)\n                return\n            \n            if start == len(coins) - 1:\n                return\n            \n            for num_used in range(divided_coin, -1, -1):\n                new_need = need - (coins[start] * num_used)    \n                getChange(num_coins + num_used, new_need, start + 1)\n\n        coins = sorted(coins, reverse=True)\n        getChange(0, amount, 0)\n        \n        return self.min_coins if self.min_coins < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        \n        min_coins = [-1 for x in range(amount + 1)]\n        \n        min_coins[0] = 0\n        \n        for value in range(1, amount+1):\n            for coin in coins:\n                if coin <= value:\n                    if min_coins[value-coin] != -1:\n                        \n                        if min_coins[value] == -1:\n                            min_coins[value] = min_coins[value-coin] + 1\n                        elif min_coins[value-coin] + 1 < min_coins[value]:\n                        \n                        \n                            min_coins[value] = min_coins[value-coin] + 1\n        \n        return min_coins[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #In any dp probelm we need to identify the recursive relationship. \n        #The solution to a problem can be found with teh help of its sub problems. \n        '''\n        In this case we define teh recursive relationship as follows:\n        Where Opt(S) is the minimum number of coins in [c1, c2, .., cn] that are needed to create amount S. \n        \n        The following recursive relationship holds:\n        Opt(S) = Opt(S - C) + 1, where C is the denomination of [c0, c1, ..., cn-1] and S is the amount.   \n        \n        Minimum number of coins for amoun S in denomination cn, is given by the minimum amount of (amount - previouse denomination) for all coins.  \n        \n        But we dont know the denomination of the last coin C, so we compute \n        Opt(S - ci) for all possible denominations c0, c1, ..., cn, and choose the minimum among them. \n        \n        Subject to S - ci >= 0. \n        \n        Base cases:\n        Opt(S) = 0, when S = 0. S is the amount.\n        Opt(S) = -1, when n = 0. \n        \n        * Each sub porblem (coin) has S computations. \n        * And the number of subproblems is O(n * S). \n        \n        '''\n        #What will we identify subproblems by. (S - ci)\n        #or by an amount. So as we are calculating the minimum number of coind needed for each amount, we need to look at the minimum number of coins need using c0, c1, .., cn. \n        #Sub problems are determined by amounts, so we cache them by amount. \n        #Fir every sub problem need optimal number of coins for each denomination. Then we take the minimum of all teh minimums, and that is the minimum number of coins needed to represnet an amount. \n        \n        \n        T = [float('inf')] * (amount + 1)\n        T[0] = 0\n\n        #In an iteratoive solution we move left to right and have to compute teh minimum number of coins for all amounts before this one. \n        \n        for amnt in range(1, amount + 1):\n            curr_min = float('inf')\n            for k in range(len(coins)):\n                #calculate the minimum number of coins needed for each denotion to represnet the amount given by amnt. \n                #then take minimum and assign it to T[amnt].\n                if coins[k] <= amnt:\n                    val = 1 + T[amnt - coins[k]]\n                    if val < curr_min:\n                        curr_min = val\n            \n            T[amnt] = curr_min\n\n        return -1 if T[-1] == float('inf') else T[-1]\n                \n        \n        \n        \n            \n        \n        \n        \n", "from typing import List\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n        solution = -1\n        dp = [0] * (amount + 1)\n        for i in range(1, amount + 1):\n            dp[i] = min([dp[i - coin] for coin in coins if i - coin >= 0] + [10000]) + 1\n\n        if dp[-1] != 10001:\n            solution = dp[-1]\n        return solution", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        coins.sort()\n        for i in range(1, amount+1):\n            tmp = [float('inf')]\n            for coin in coins:\n                if i-coin < 0: \n                        break \n                tmp.append(dp[i-coin])\n            dp[i] = min(tmp) + 1\n            \n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins, reverse=True)\n        dp = [-1] * (amount + 1)\n        dp[0] = 0\n        for i in range(1, amount + 1):\n            if i - coins[-1] < 0:\n                continue\n            for coin in coins:\n                index = i - coin\n                if index >= 0 and dp[index] != -1:\n                    value = dp[index] + 1\n                    if dp[i] == -1 or dp[i] > value:\n                        dp[i] = value\n        return dp[amount]\n                \n        \n", "# class Solution:\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         dp=[float('inf')]*(amount+1)\n#         dp[0]=0\n        \n#         for i in range(1, amount+1):\n#             for c in coins:\n#                 if c<=i:        #check if coin value fits in current amount i\n#                     dp[i]=min(dp[i], dp[i-c]+1)\n        \n#         if dp[amount]>amount:\n#             return -1\n#         else:\n#             return dp[amount]\n                    \n    \n    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[float('inf')]*(amount+1)\n        dp[0]=0\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i]=min(dp[i], dp[i-coin]+1)\n                \n        return dp[amount] if dp[amount] !=float('inf') else -1", "import math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [math.inf] * amount\n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n        return dp[-1] if dp[-1] != math.inf else -1\n        \n#         dp = [0] + [math.inf] * amount\n#         for coin in coins:\n#             for i in range(coin, amount + 1):\n#                 dp[i] = min(dp[i], dp[i - coin] + 1)\n#         return dp[-1] if dp[-1] != math.inf else -1\n        \n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        for coin in coins:\n            for x in range(coin,amount+1):\n                dp[x] = min(dp[x],dp[x-coin]+1)\n        return dp[amount] if dp[amount] != float('inf') else -1 \n        \n        \n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        numbers = [float('inf')]*(amount+1)\n        numbers[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount+1):\n                numbers[x] = min(numbers[x], numbers[x-coin]+1)\n        \n        return numbers[amount] if numbers[amount] < float('inf') else -1\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        self.ret = float('inf')\n\n\n        \n        def recurrent(index, coins, amount, current):    \n            first = coins[index]\n            n = amount // first\n            remainder = amount % first\n            if remainder == 0:\n                self.ret = min(self.ret, current + n)\n            else:\n                l = len(coins)\n                while remainder <= amount and index<l-1 and current + n < self.ret:\n                    recurrent(index+1, coins, remainder, current + n)\n                    n -= 1\n                    remainder += first\n\n            return\n        \n        \n        \n        recurrent(0, coins, amount, 0)\n        \n        \n        \n        if self.ret == float('inf'):\n            return -1\n        else:\n            return self.ret\n        \n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount <= 0:\n            return 0\n        \n        f = [float('inf')] * (amount + 1)\n        f[0] = 0\n        for c in coins:\n            for a in range(c, amount + 1):\n                f[a] = min(f[a], f[a - c] + 1)\n        return f[amount] if f[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1 ", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i] = min(dp[i], dp[i-coin]+1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        numWays = [float('inf')] * (amount + 1)\n        \n        numWays[0] = 0\n        \n        for coin in coins:\n            for value in range(coin, amount + 1):\n                numWays[value] = min(numWays[value], 1 + numWays[value - coin])\n                \n        print(numWays[amount])\n        return numWays[amount] if numWays[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        \n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [float('inf')] * (amount + 1)\n        \n        dp[0] = 0\n        \n        for coin in coins:\n            for j in range(coin, amount+1):\n                dp[j] = min(dp[j], dp[j - coin] + 1)\n                \n        if dp[amount] != float('inf'):\n            return dp[amount]\n        else:\n            return -1\n            \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #coins = sorted(coins)\n                \n        dp = [amount+1 for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for coin in coins:\n            for a in range(coin, amount+1):\n                dp[a] = min(dp[a], dp[a-coin]+1)\n                            \n        res = dp[amount] if dp[amount] < amount+1 else -1\n            \n        return res\n", "class Solution:\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount == 0:\n            return 0\n        \n        mem = [-1] * (amount+1)\n        mem[0] = 0\n        \n        for i in range(1, amount+1):\n            m = math.inf\n            for c in coins:\n                if i-c >= 0:\n                    if mem[i-c] != -1 and mem[i-c] + 1 < m:\n                        m = mem[i-c] + 1\n            \n            if m != math.inf:\n                mem[i] = m\n        print(mem)\n        return mem[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i] = min(dp[i], dp[i-coin]+1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount+1)\n        #dp[i] = min (dp[i - c1], dp[i - c2], ...) + 1\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, len(dp)):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n                \n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp=[float('inf')]*(amount+1)\n        dp[0]=0\n        \n        for coin in coins:\n            for x in range(coin, amount+1):\n                dp[x]=min(dp[x],dp[x-coin]+1)\n                \n        return dp[amount] if dp[amount] != float('inf') else -1 \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        numWays = [float('inf')] * (amount + 1)\n        \n        numWays[0] = 0\n        \n        for coin in coins:\n            for value in range(coin, amount + 1):\n                numWays[value] = min(numWays[value], 1 + numWays[value - coin])\n                \n                \n        return numWays[amount] if numWays[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first i coins with sum of j\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-k]+1) for k in coins\n        dp = [0] + [float('inf')] * amount\n        for c in coins:\n            for j in range(c, amount+1):\n                dp[j] = min(dp[j], dp[j-c]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n\n\n        \n\n'''    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for i in range(n):\n                if j >= coins[i]:\n                    dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(None)\n        def dp(remain, cnt):\n            if remain == 0:return cnt \n            ans = float('inf')\n            for c in coins:\n                if c*(ans-cnt)>remain>=c: \n                    ans = min(ans, dp(remain-c, cnt+1))\n            return ans \n        ans = dp(amount, 0) \n        return ans if ans < float('inf')  else -1\n    \n    \n    def coinChange(self, coins, amount):\n        coins.sort(reverse = True)\n        lenc, self.res = len(coins), 2**31-1\n\n        def dfs(pt, rem, count):\n            if not rem:\n                self.res = min(self.res, count)\n            for i in range(pt, lenc):\n                if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                    dfs(i, rem-coins[i], count+1)\n\n        for i in range(lenc):\n            dfs(i, amount, 0)\n        return self.res if self.res < 2**31-1 else -1\n'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [math.inf] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for idx in range(coin, amount+1):\n                # Get the coin count without this coin\n                prev_coins_ct = dp[idx - coin]\n                # Get the minimum of either adding from prev coin ct or current lowest\n                dp[idx] = min(prev_coins_ct + 1, dp[idx])\n        \n        if dp[-1] == math.inf:\n            return -1\n        \n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [-1]*(amount+1)\n        dp[0] = 0\n        \n        for idx in range(amount+1):\n            tmp = []\n            for coin in coins:\n                if idx-coin >= 0 and dp[idx-coin] != -1:\n                    tmp.append(dp[idx-coin])\n            if tmp:\n                dp[idx] = min(tmp) + 1\n        print(dp)\n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [ 0 ] + [ float( 'inf' ) ] * ( amount )\n        for c in coins :\n            for j in range( c , amount + 1 ) :\n                dp[ j ] = min( dp[ j - c ] + 1 , dp[ j ] )\n        if dp[ -1 ] != float( 'inf' ) : return dp[ -1 ]\n        return -1\n    #Sanyam Rajpal\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        numWays = [float('inf')] * (amount + 1)\n        \n        numWays[0] = 0\n        \n        for coin in coins:\n            for value in range(coin, amount + 1):\n                numWays[value] = min(numWays[value], 1 + numWays[value - coin])\n                        \n        return numWays[amount] if numWays[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        print(dp)\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                dp[i] = min(dp[i], dp[i-coin]+1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount<0:\n            return -1\n        coins=sorted(coins)\n        d=[amount+1]*(amount+1)\n        d[0]=0\n        for i in range(amount+1):\n            for j in coins:\n                if j<=i:\n                    d[i]=min(d[i],d[i-j]+1)\n                else:\n                    break\n        if d[-1]>amount:\n            return -1\n        else:\n            return d[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for coin in coins:\n            for i in range(len(dp)):\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        if len(coins) == 1 and coins[0] > amount:\n            return -1\n        \n        dp = [amount+1] * (amount+1)\n        dp[0] = 0\n        for i in range(1,amount+1):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i-coin] + 1, dp[i])\n        return dp[amount] if dp[amount] != amount+1 else -1\n    \n#         rs = [amount+1] * (amount+1)\n#         rs[0] = 0\n#         for i in xrange(1, amount+1):\n#             for c in coins:\n#                 if i >= c:\n#                     rs[i] = min(rs[i], rs[i-c] + 1)\n\n#         if rs[amount] == amount+1:\n#             return -1\n#         return rs[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        dp = [-1] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(len(coins)):\n            if coins[i] <= amount:\n                dp[coins[i]] = 1\n\n        for i in range(1, amount+1):\n            if dp[i] == -1:\n                comparison = []\n                for c in coins:\n                    if i - c >= 0 and dp[i-c] != -1:\n                        comparison.append(dp[i-c])\n                if comparison:\n                    dp[i] = min(comparison) + 1\n        \n        return dp[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = [float('inf') for _ in range(amount+1)]\n        memo[0] = 0\n        for c in coins:\n            for i in range(c, len(memo)):\n                memo[i] = min(1 + memo[i-c], memo[i])\n        \n        return memo[amount] if memo[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for j in coins:\n                if i >= j:\n                    dp[i] = min(dp[i], dp[i-j] + 1)\n\n        if dp[amount] == amount+1:\n            return -1\n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        rs = [amount+1] * (amount+1)\n        rs[0] = 0\n        for i in range(1, amount+1):\n            for c in coins:\n                if i >= c:\n                    rs[i] = min(rs[i], rs[i-c] + 1)\n\n        if rs[amount] == amount+1:\n            return -1\n        return rs[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for coin in coins:\n            for i in range(len(dp)):\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return dp[i] if dp[i] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for coin in coins:\n            for i in range(len(dp)):\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return dp[amount] if dp[amount] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#        1 2 3 4 5 6 7 8 9 10 11\n#      0 \n# 1    0 1 1 2 2 1 2 2 3 4 2 3\n# 2    0   1 2     \n# 5    0  \n        dp = [float('inf')] * (amount+1)\n        dp[0] = 0 \n\n        for i in range(1,amount+1):\n            for c in coins:\n                if c<=i:\n                    dp[i] = min(dp[i], dp[i-c] + 1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # sort list descedning order\n    \n#     coins = [1,2,5] 1 + 4 = 5 -> coinchange(4) + 1\n#                     2 + 3 = 5 -> coinchange(3) + 1\n#                     5 + 0 = 5 -> coinchange(0) + 1\n           \n#     amount                 0  1  2  3  4. 5..  10 11\n        \n#     fewest num of coins    0  1  1  2 2  min()\n            \n#         coin in coins\n#             if amount != coin:\n#                 dp[amount] = dp[amount-coin] + 1\n                                \n        \n#         def dfs(amount):\n            \n#             # Have we solved this before\n#             if amount in memo:\n#                 return memo[amount]\n            \n#             # recursive base case\n#             if amount == 0:\n#                 return 0\n            \n#             # find all cases\n#             tmp = []\n#             for i in range(len(coins)):\n                \n#                 if amount - coins[i] >= 0:\n#                     tmp.append(dfs(amount-coins[i],))\n                    \n#                 else:\n#                     tmp.append(float('inf'))\n                \n            \n#             # save the output in memory\n#             _min = min(tmp) + 1\n#             memo[amount] = _min\n            \n#             return _min\n        \n# #         memo = {}\n# #         output = dfs(amount)\n        \n# #         return output if output != float('inf') else -1\n#         dp = [float('inf')] * (amount + 1)\n#         dp[0] = 0\n#         for coin in coins:\n#             for x in range(coin, amount+1):\n#                 dp[x] = min(dp[x],dp[x-coin]+1)\n        \n#         return dp[amount] if dp[amount] != float('inf') else -1\n        \n    \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp=[sys.maxsize]*(amount+1)\n        \n        dp[0]=0\n        for i in range(1,len(dp)):\n            for c in coins:\n                if c<=i:\n                    dp[i]=min(dp[i],dp[i-c]+1)\n                    \n        if dp[amount] == sys.maxsize:\n            return -1\n        return dp[amount]\n            \n        \n        \n", "import math\n\n\ndef rec(coins, amount, used_coins, res):\n    if amount == 0:\n        res[0] = min(res[0], used_coins)        \n    elif coins and (res[0] - used_coins) * coins[-1] >= amount:\n        for i in range(amount // coins[-1], -1, -1):\n            rec(coins[:-1], amount - i * coins[-1], used_coins + i, res)\n\n                \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        res = [math.inf]\n        rec(sorted(coins), amount, 0, res)\n        return res[0] if res[0] != math.inf else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        \n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for i in range(1, amount + 1):\n            for c in coins:\n                if i >= c:\n                    dp[i] = min(dp[i], 1 + dp[i-c])\n        \n        return dp[-1] if dp[-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or len(coins) == 0:\n            return 0\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        for i in range(amount + 1):\n            for j in coins:\n                if j <= i:\n                    dp[i] = min(dp[i], dp[i - j] + 1)\n        if dp[-1] > amount:\n            return -1\n        else:\n            return dp[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        for coin in coins:\n            for i in range(amount + 1):\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        rs = [amount+1] * (amount+1)\n        rs[0] = 0\n        for i in range(1, amount+1):\n            for c in coins:\n                if i >= c:\n                    rs[i] = min(rs[i], rs[i-c] + 1)\n\n        if rs[amount] == amount+1:\n            return -1\n        return rs[amount]\n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        if amount == 0:\n            return 0\n        changes = [amount+1] *(amount+1)\n        changes[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin > i:\n                    break\n                else:\n                    changes[i] = min(changes[i], changes[i-coin] + 1)\n        if changes[-1]!=(amount+1): \n            return changes[-1] \n        else:\n            return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return amount\n        \n        dp = [1e9 for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            k = 1e9         # K = min num of coins to reach amount i\n            for c in coins:\n                if i - c >= 0:\n                    k = min(k, dp[i-c] + 1)\n            if k != 1e9:\n                dp[i] = k\n        \n        return -1 if dp[amount] == 1e9 else dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [1e9 for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            k = 1e9         # K = min num of coins to reach amount i\n            for c in coins:\n                if i - c >= 0:\n                    k = min(k, dp[i-c] + 1)\n            if k != 1e9:\n                dp[i] = k\n        \n        return -1 if dp[amount] == 1e9 else dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n                \n        dp = [amount+1 for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for coin in coins:\n            for a in range(coin, amount+1):\n                if coin > a:\n                    break\n                dp[a] = min(dp[a], dp[a-coin]+1)\n                            \n        res = dp[amount] if dp[amount] < amount+1 else -1\n            \n        return res\n", "class Solution(object):\n    def coinChange(self, coins, amount):\n        dp = [0] + [float('inf')] * amount\n        \n        for i in range(1, amount + 1):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf') for i in range(amount+1)]\n        dp[0] = 0\n        \n        for coin in coins:\n            for j in range(coin, amount+1):\n                dp[j] = min(dp[j], 1+dp[j-coin])\n        \n        return dp[-1] if dp[-1]!=float('inf') else -1", "'''\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for i in range(n):\n                if j >= coins[i]:\n                    dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n'''    \nclass Solution:\n    '''\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(None)\n        def dp(remain, cnt):\n            if remain == 0:return cnt \n            ans = float('inf')\n            for c in coins:\n                if remain>=c: \n                    ans = min(ans, dp(remain-c, cnt+1))\n            return ans \n        ans = dp(amount, 0) \n        return ans if ans < float('inf')  else -1\n    '''          \n    \n    \n    def coinChange(self, coins, amount):\n        coins.sort(reverse = True)\n        lenc, self.res = len(coins), 2**31-1\n\n        def dfs(pt, rem, count):\n            if not rem:\n                self.res = min(self.res, count)\n            for i in range(pt, lenc):\n                if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                    dfs(i, rem-coins[i], count+1)\n\n        for i in range(lenc):\n            dfs(i, amount, 0)\n        return self.res if self.res < 2**31-1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        dp = [amount+1 for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin > i:\n                    break\n                #print(i, coin, len(dp))\n                #dp[i//coin] + dp[i%coin]\n                dp[i] = min(dp[i], dp[i-coin]+1)\n                \n        #print(dp)\n            \n        res = dp[amount] if dp[amount] < amount+1 else -1\n            \n        return res", "import math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        count = [math.inf] * (amount + 1)\n        count[0] = 0\n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i >= coin:\n                    count[i] = min(count[i], count[i-coin] + 1)\n        \n        return count[amount] if count[amount] != math.inf else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #coins = sorted(coins)\n                \n        dp = [amount+1 for _ in range(amount+1)]\n        dp[0] = 0\n        for a in range(1, amount+1):\n            for coin in coins:\n                if coin <= a:\n                    dp[a] = min(dp[a], dp[a-coin]+1)\n                            \n        res = dp[amount] if dp[amount] < amount+1 else -1\n            \n        return res", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        table = [amount+1]*(amount+1)\n        table[0] = 0 \n        \n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin <= i:\n                    table[i] = min(table[i-coin]+1, table[i])\n        print(table)\n        return table[amount] if table[amount] != amount+1 else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def giveChange(target):\n            if target == 0:\n                return 0\n            if target < 0:\n                return -1\n            \n            minForTarget = None\n            for coin in coins:\n                result = giveChange(target - coin)\n                if result != -1:\n                    minForTarget = result + 1 if not minForTarget else min(result + 1, minForTarget)\n            \n            return minForTarget or -1\n            \n        return giveChange(amount)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [0] + [amount+1 for i in range(amount)]\n        for i in range(1, amount+1):\n            for c in coins:\n                if i >= c:\n                    dp[i] = min(dp[i-c]+1, dp[i])\n                    \n        return dp[amount] if dp[amount] < amount+1 else -1\n    \n    \n\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         n = len(coins)\n#         dp = [[amount+1 for j in range(n+1)] for i in range(amount+1)]\n#         for j in range(n+1):\n#             dp[0][j] = 0\n#         for i in range(1, amount+1):\n#             for j in range(1, n+1):\n#                 if coins[j-1] > i:\n#                     dp[i][j] = dp[i][j-1]\n#                 else:\n#                     dp[i][j] = min(dp[i-coins[j-1]][j]+1, dp[i][j-1])\n            \n#         return dp[amount][n] if dp[amount][n] < amount+1 else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        print(dp)\n        \n        for coin in coins:\n            for i in range(len(dp)):\n                if coin <= i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n        '''\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #brute force keep looking for ways until it == 0\n        dp = [float('inf')] * (amount+1)\n        dp[0] = 0 #store the number of ways to 0\n        \n        for coin in coins: #check if dp[i] > coin then return the min\n            for i in range(1,amount+1):\n                if i - coin >= 0: #valid combination\n                    dp[i] = min(dp[i],dp[i-coin] + 1)\n        if dp[amount] < float('inf'):\n            return dp[-1]\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        self.min = 2**31-1\n\n        def dfs(index, amount, count):\n            if amount==0:\n                self.min = min(self.min, count)\n            if amount < 0:\n                return \n            for i in range(index, len(coins)):\n                if coins[i] * (self.min-count)>amount >= coins[i]: # if hope still exists\n                    dfs(i, amount-coins[i], count+1)\n                    \n        dfs(0, amount, 0)\n        return self.min if self.min != 2**31-1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        ary = [amount+1] * (amount + 1)\n        ary[0] = 0\n\n        for i in range(1, len(ary)):\n            for coin in coins:\n                if i-coin < 0:\n                    continue\n                ary[i] = min(ary[i], ary[i-coin] + 1)\n        \n        return ary[amount] if ary[amount] < amount + 1 else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        numOfCoins = [float('inf') for x in range(amount + 1)]\n        numOfCoins[0] = 0\n        for coin in coins:\n            for num in range(len(numOfCoins)):\n                if coin <= num:\n                    numOfCoins[num] = min(numOfCoins[num], numOfCoins[num - coin] + 1)\n        return numOfCoins[amount] if numOfCoins[amount] != float('inf') else -1", "''''\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first i coins with sum of j\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-k]+1) for k in coins\n        dp = [0] + [float('inf')] * amount\n        for c in coins:\n            for j in range(c, amount+1):\n                dp[j] = min(dp[j], dp[j-c]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n\n\n        \n\n'''    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for c in coins:\n                if j >= c:\n                    dp[j] = min(dp[j], dp[j-c]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        MAX = float('inf')\n        dp = [0] + [MAX]*amount\n\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n\n        if dp[-1] == MAX:\n            return -1\n        return dp[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        MAX = amount+10\n        dp = [MAX for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(1, amount+1):\n            curr = i\n            for coin in coins:\n                prev = curr-coin\n                if prev >= 0:\n                    dp[curr] = min(dp[curr], dp[prev] + 1)\n                    \n    \n        return dp[amount] if dp[amount] != MAX else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # 0-1 bag, dp[i][j] is the minimum number of coins only use the first i coins can sum up to target j\n        dp = [-1 for i in range(amount+1)]\n        dp[0] = 0\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                if i == coin:\n                    dp[i] = 1\n                elif dp[i] == -1 and dp[i-coin] != -1:\n                    dp[i] = dp[i-coin] + 1\n                elif dp[i] != -1 and dp[i-coin] != -1:\n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n            \n        return dp[-1] ", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def change_memo(coins, amount, memo):\n            if amount not in memo:\n                if amount == 0:\n                    best = 0\n                elif amount < 0:\n                    best = -1\n                else:\n                    best = None\n                    for c in coins:\n                        res = change_memo(coins, amount-c, memo)\n                        if res == -1:\n                            continue\n                        if (best is None) or (res < best):\n                            best = res\n                    if best is None:\n                        best = -1\n                    else:\n                        best += 1\n                memo[amount] = best\n                \n            return memo[amount]\n        \n        memo = {}\n        change_memo(coins, amount, memo)\n        return memo[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        min_coins = float('inf')\n\n        def count_coins(start_coin, coin_count, remaining_amount):\n          nonlocal min_coins\n\n          if remaining_amount == 0:\n            min_coins = min(min_coins, coin_count)\n            return\n\n          # Iterate from largest coins to smallest coins\n          for i in range(start_coin, len(coins)):\n            remaining_coin_allowance = min_coins - coin_count\n            max_amount_possible = coins[i] * remaining_coin_allowance\n\n            if coins[i] <= remaining_amount and remaining_amount < max_amount_possible:\n              count_coins(i, coin_count + 1, remaining_amount - coins[i])\n\n        count_coins(0, 0, amount)\n        return min_coins if min_coins < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        \n        for i in range(amount+1):\n            for coin in coins:\n                if i-coin>=0:\n                    dp[i] = min(dp[i], 1+dp[i-coin])\n        \n        if dp[-1] == float('inf'):\n            return -1\n        return dp[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # initialize a dp table for the minimum amount of coins needed\n        # to get each value up to the amount (all except 0 are inf)\n        dp = [0] + [float('inf')] * amount\n        \n        # then for i up to the amount and counting each coin\n        for i in range(1, amount+1):\n            for c in coins:\n                # if you can subtract the coin from the current amount\n                # get new min (current or with the new coin)\n                if i - c >= 0:\n                    # dp[i-c] + 1: minimum of the amount subtracting the coin\n                    # we are at now if we added this 1 coin\n                    dp[i] = min(dp[i], dp[i-c]+1)\n        \n        if dp[-1] == float('inf'): return -1\n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # f(amount) = min(f(amount-1), f(amount-2), f(amount-5))\n        cap = amount+1\n        dp = [cap] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for c in coins:\n                dp[i] = min(dp[i-c]+1 if i-c>=0 else cap, dp[i])\n        return dp[amount] if dp[amount]< cap else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf') for i in range(amount + 1)]\n        dp[0] = 0\n        \n        for i in range(1, len(dp)):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i], 1 + dp[i - coin])\n        \n        if dp[len(dp) - 1] == float('inf'):\n            return -1\n        return dp[len(dp) - 1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        curr = [float('inf')]*(amount+1)\n        curr[0] = 0\n        coins = sorted(coins)\n        for num in range(amount+1):\n            for c in coins:\n                if num-c < 0: break\n                curr[num] = min(curr[num], curr[num-c]+1)\n        return curr[amount] if curr[amount]<float('inf') else -1\n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            for j in coins:\n                if i - j >= 0:\n                    dp[i] = min(dp[i-j] + 1, dp[i])\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        result = -1\n\n        def helper(coins: List[int], pos: int, left: int, current: int):\n            nonlocal result\n            if left % coins[pos] == 0:\n                if result == -1 or result > current + left // coins[pos]:\n                    result = current + left // coins[pos]\n                return\n\n            if pos == len(coins) - 1:\n                return\n\n            for k in range(left // coins[pos], -1, -1):\n                new_amount = left - coins[pos] * k\n                new_count = current + k\n                if result != -1 and result < new_count + (new_amount + coins[pos + 1] - 1) / coins[pos + 1]:\n                    break\n                helper(coins, pos + 1, left - coins[pos] * k, current + k)\n\n        helper(coins, 0, amount, 0)\n        return result", "import sys\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        [1,2,3] 7 => 3\n        \n        7-3 = 4\n        4-3 = 1\n        1-3 = -2 not possible\n        1-2 = -1 not\n        1-1 = 0 return \n        0 1 2 3 4 5 6 7\n        3 2 2 2 1 1 1 1\n              &\n        '''\n        dp = [sys.maxsize] * (amount+1)\n        if amount==0: return 0\n        dp[amount] = 0\n        for i in range(amount,-1,-1):\n            for coin in coins:\n                if i-coin >= 0:\n                    dp[i-coin] = min(dp[i]+1, dp[i-coin])\n        return -1 if dp[0] == sys.maxsize else dp[0]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(maxsize=None)\n        def _recursive(a):\n            if a == 0:\n                return 0\n            min_n = 1e9\n            for c in coins:\n                if c <= a:\n                    sub_a = _recursive(a - c)\n                    if sub_a != -1:\n                        min_n = min(min_n, sub_a + 1)\n            return min_n if min_n != 1e9 else -1\n        return _recursive(amount)\n    \n    # Button-up\n    # def coinChange(self, coins: List[int], amount: int) -> int:\n        # states = [0] * (amount + 1)\n        # for s in range(0, amount+1):\n        #     if s == 0:\n        #         states[s] = 0\n        #     else:\n        #         min_n = 1e9\n        #         for c in coins:\n        #             if c <= s and states[s-c] != -1:\n        #                 min_n = min(min_n, 1 + states[s-c])\n        #         if min_n == 1e9:\n        #             states[s] = -1\n        #         else:\n        #             states[s] = min_n\n        # return states[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        res = {}\n        res[0] = 0\n        \n        for x in range(amount+1)[1:]:\n            prevs = [x-c for c in coins]\n            \n            \n            \n            this_res = min([res.get(y,2**31) for y in prevs])+1\n            \n            res[x] = this_res\n        # print(res)\n        if res[amount] >= 2**31:\n            return -1\n        else:\n            return res[amount]\n                    \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        coins.sort()\n        coins.reverse()\n        print(coins)\n        change = [-1]*(amount+1)\n        change[0] = 0\n        for i in range(1, amount+1):\n            for c1 in coins:\n                #print(f'i:{i}, c1:{c1}')\n                if c1 > i:\n                    continue\n                c2 = change[i-c1]\n                if c2 >= 0:\n                    if change[i] == -1:\n                        change[i] = c2+1\n                    else:\n                        change[i] = min(c2+1, change[i])\n        return change[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [float('inf')] * (amount +1)\n        dp[0] = 0\n        for i in coins:\n            for j in range(i , amount +1):\n                if dp[j-i] != float('inf'):\n                    dp[j] = min(dp[j], dp[j-i]+1)\n        return -1 if dp[amount] == float('inf') else dp[amount]\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount==0:\n            return 0\n        \n        \n        if len(coins)==1:\n            \n            if amount%coins[0]==0:\n                return amount//coins[0]\n            return -1\n        \n        dp=[0]*(amount+1)\n        \n        for i in range(1,amount+1):\n            \n            if i in set(coins):\n                dp[i]=1\n                continue\n                \n            min_coins=float('inf')\n            \n            for coin in coins:\n                \n                if i-coin>=0:\n                    min_coins=min(dp[i-coin],min_coins)\n                    \n            dp[i]=min_coins+1\n            \n            \n        if dp[amount]==float('inf'):\n            return -1\n        return dp[amount]\n                    \n    \n    \n                                 \n                   \n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        amount_list = [i for i in range(amount+1)]\n        \n        for i in range(amount+1):\n            if i == 0:\n                amount_list[i] = 0\n            elif i in coins:\n                amount_list[i] = 1\n            else:\n                temp = []\n                for coin in coins:\n                    if amount_list[i] - coin >= 0:\n                        remainder = amount_list[i] - coin\n                        min_coin = (amount_list[remainder])\n                        if min_coin != -1:\n                            temp.append(min_coin)\n                        # print('amt: {}, coin: {}, remainder: {}, min coins {}'.format(amount_list[i], coin, remainder, min_coin))\n                if len(temp) == 0:\n                    amount_list[i] = -1\n                else:\n                    amount_list[i] = min(temp) + 1\n                # print(amount_list)\n                    \n        return amount_list[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        ary = [amount+1] * (amount + 1)\n        ary[0] = 0\n        print(ary)\n        for i in range(1, len(ary)):\n            for coin in coins:\n                if i-coin < 0:\n                    continue\n                ary[i] = min(ary[i], ary[i-coin] + 1)\n        \n        return ary[amount] if ary[amount] < amount + 1 else -1\n", "class Solution:\n  def coinChange(self, coins, amount):\n    coins.sort(reverse = True)\n    lenc, self.res = len(coins), 2**31-1\n    \n    def dfs(pt, rem, count):\n        if not rem:\n            self.res = min(self.res, count)\n        for i in range(pt, lenc):\n            if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                dfs(i, rem-coins[i], count+1)\n\n    for i in range(lenc):\n        dfs(i, amount, 0)\n    return self.res if self.res < 2**31-1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        \n        def _fewest(cs, amt):\n            nonlocal memo\n            if amt not in memo:\n                if amt < 0:\n                    memo[amt] = -1\n                elif amt == 0:\n                    memo[amt] = 0\n                else:\n                    fewest = -1\n                    for c in cs:\n                        f = _fewest(cs, amt-c)\n                        if f != -1 and (fewest == -1 or f+1 < fewest):\n                            fewest = f+1\n                    memo[amt] = fewest\n            return memo[amt]\n        \n        return _fewest(coins, amount)", "class Solution:\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        mem = {}\n        mem[0] = 0\n        \n        def rec(amount):\n            if amount < 0:\n                return -1\n            if amount in mem:\n                return mem[amount]\n            m = math.inf\n            for c in coins:\n                n = rec(amount-c)\n                if n != -1 and n+1 < m :\n                    m = n+1\n            if m == math.inf:\n                m = -1\n            mem[amount] = m\n            return m\n         \n        \n        if amount == 0:\n            return 0\n        return rec(amount)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [0] + [float('inf') for _ in range(amount)]\n        \n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n    \n        return -1 if dp[-1] == float('inf') else dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [sys.maxsize for i in range(amount+1)]\n        \n        m = len(coins)\n        dp[0] = 0\n        \n        for j in range(m):\n            for i in range(amount+1):\n                if coins[j] <= i:\n                    dp[i] = min(dp[i],dp[i-coins[j]] +1)\n                    \n        # print(dp)\n        if dp[-1] == sys.maxsize:\n            return -1\n        return dp[-1]\n            \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount:\n            dp = [float('inf')]*amount\n            for j in range(amount):\n                if j + 1 in coins:\n                    dp[j] = 1\n                else:\n                    for c in coins:\n                        if j - c + 1 > 0:\n                            dp[j] = min( dp[j], dp[j-c] + 1 )\n            if dp[amount-1] < float('inf'):\n                return dp[amount-1]\n            else:\n                return -1\n        else:\n            return 0", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # i = coin index\n        # c[i] = coin cost\n        # f(0,0) = 0\n        # f(coin, amount) = minimum number of coins needed to pay amount\n        # f(i, j) = min( f(i-1, j), f(i, j-c[i]) + 1)\n        \n        dp = [amount+1] * (amount+1)\n\n        \n        dp[0] = 0\n        \n        \n        for i in range (len(coins)):\n            coin = coins[i]\n            for j in range(1, amount + 1):\n                sameCoin = amount + 1\n                if j - coin >= 0:\n                    dp[j] = min(dp[j-coin] +1, dp[j])\n                \n                \n        \n        return dp[amount] if dp[amount] != amount + 1 else -1\n    \n#         rs = [amount+1] * (amount+1)\n#         rs[0] = 0\n#         for i in range(1, amount+1):\n#             for c in coins:\n#                 if i >= c:\n#                     rs[i] = min(rs[i], rs[i-c] + 1)\n\n#         if rs[amount] == amount+1:\n#             return -1\n#         return rs[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        \n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for i in range(n):\n                if j >= coins[i]:\n                    dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n'''\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int Max = amount + 1;\n        vector<int> dp(amount + 1, Max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.size(); j++) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        amount_list = [i for i in range(amount+1)]\n        \n        for i in range(amount+1):\n            if i == 0:\n                amount_list[i] = 0\n            elif i in coins:\n                amount_list[i] = 1\n            else:\n                temp = []\n                for coin in coins:\n                    if amount_list[i] - coin >= 0:\n                        remainder = amount_list[i] - coin\n                        min_coin = (amount_list[remainder])\n                        if min_coin != -1:\n                            temp.append(min_coin)\n                if len(temp) == 0:\n                    amount_list[i] = -1\n                else:\n                    amount_list[i] = min(temp) + 1\n                    \n        return amount_list[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1]*(amount + 1) # max number is when we use coin 1, there is no smaller coin\n        dp[0] = 0\n        for partial_amount in range(1, amount + 1):\n            for j in range(len(coins)):\n                if coins[j] <= partial_amount:\n                    dp[partial_amount] = min(dp[partial_amount], dp[partial_amount - coins[j]] + 1)\n        return dp[amount] if dp[amount] <= amount else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf')] * amount\n        coinValues = collections.defaultdict(list)\n        for coin in coins:\n            for i in range(coin, amount+1):\n                if dp[i-coin] + 1 < dp[i]:\n                    dp[i] = dp[i-coin] + 1\n                    coinValues[i] = coinValues[i-coin] + [coin]\n        print(coinValues[amount])\n        return dp[-1] if dp[-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf') for i in range(amount + 1)]\n        dp[0] = 0\n        for i in range(amount + 1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n        \n        return dp[amount] if dp[amount] != float('inf') else -1", "'''\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first i coins with sum of j\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-k]+1) for k in coins\n        dp = [0] + [float('inf')] * amount\n        for c in coins:\n            for j in range(c, amount+1):\n                dp[j] = min(dp[j], dp[j-c]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n\n\n        \n\n'''    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for i in range(n):\n                if j >= coins[i]:\n                    dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        num_ways = (amount+1) * [-1]\n        num_ways[0] = 0\n        \n        for v in range(1, amount+1):\n            fewest = float('inf')\n            for c in coins:\n                if v-c >= 0 and num_ways[v-c] != -1:\n                    fewest = min(num_ways[v-c], fewest)\n            if fewest != float('inf'):\n                num_ways[v] = 1 + fewest\n        \n        return num_ways[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def helpCoins(coins, amount, cache):\n            if amount < 0:\n                return -1\n            if amount == 0:\n                return 0\n            \n            if amount in cache:\n                return cache[amount]\n               \n            curr_min = 999\n            for coin in coins:\n                to_go = helpCoins(coins, amount - coin, cache)\n                if to_go >= 0 and to_go < curr_min:\n                    curr_min = to_go + 1\n            \n            if curr_min == 999:\n                cache[amount] = -1\n            else:\n                cache[amount] = curr_min\n            \n            return cache[amount]\n        \n        return helpCoins(coins, amount, {})\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [sys.maxsize-1] * (amount+1)\n        dp[0]=0\n        for i in range (amount+1):\n            #if dp[i] == sys.maxsize-1:\n                #continue\n            for c in coins:\n                if c +i<=amount:\n                    dp[c+i]=min(dp[c+i],dp[i]+1)\n        if dp[-1] == sys.maxsize-1:\n            return -1\n        return dp[-1]", "import collections\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        seen = set()\n        queue = collections.deque()\n        for coin in coins:\n            queue.append((amount - coin, 1))\n        \n        while queue: \n            curr = queue.popleft()\n            if curr[0] == 0: return curr[1]\n            if curr[0] < 0 or curr[0] in seen: continue\n            seen.add(curr[0])\n            for coin in coins:\n                queue.append((curr[0] - coin, curr[1] + 1))   \n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] first j coins with sum of i\n        # dp[i][j] = min(dp[j-coins[k][k]]+1) for k in coins\n        n = len(coins)\n        dp = [0] + [float('inf')] * amount\n        for j in range(1, amount+1):\n            for i in range(n):\n                if j >= coins[i]:\n                    dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        return dp[-1] if dp[-1] < float('inf') else -1\n'''    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(None)\n        def dp(remain, cnt):\n            if remain == 0:return cnt \n            ans = float('inf')\n            for c in coins:\n                if c*(ans-cnt)>remain>=c: \n                    ans = min(ans, dp(remain-c, cnt+1))\n            return ans \n        ans = dp(amount, 0) \n        return ans if ans < float('inf')  else -1\n    \n    \n    def coinChange(self, coins, amount):\n        coins.sort(reverse = True)\n        lenc, self.res = len(coins), 2**31-1\n\n        def dfs(pt, rem, count):\n            if not rem:\n                self.res = min(self.res, count)\n            for i in range(pt, lenc):\n                if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                    dfs(i, rem-coins[i], count+1)\n\n        for i in range(lenc):\n            dfs(i, amount, 0)\n        return self.res if self.res < 2**31-1 else -1\n'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1] * (amount + 1)\n        dp[0] = 0\n        for i in range(amount+1):\n            for j in range(len(coins)):\n                if coins[j] <= i:\n                    dp[i] = min(dp[i], 1 + dp[i-coins[j]])\n                \n        if dp[amount] > amount:\n            return -1\n        return dp[amount]\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        memo = {}\n        def helper(target, options):\n            if(target in memo):\n                return memo[target]\n            else:\n                best = None\n                for opt in options:\n                    if opt == target:\n                        memo[target] = 1\n                        return 1\n                    elif opt < target:\n                        cont = helper(target-opt, options)\n                        if cont is not None and (best is None or cont+1 < best):\n                            best = cont+1\n                memo[target] = best\n                return best\n            \n        output = helper(amount, coins)\n        return output if output is not None else -1\n", "class Solution:\n    def util(self, memo, coins, amount):\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return -1\n        minarr = []\n        for coin in coins:\n            if (amount - coin) not in memo:\n                memo[(amount-coin)] = self.util(memo, coins, amount - coin)\n            minarr.append(memo[(amount-coin)])\n        \n        minarr = [m for m in minarr if m != - 1]\n        if not minarr:\n            return -1\n        return min(minarr) + 1\n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        return self.util(memo, coins, amount)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 0:\n            return -1\n        Max = amount + 1\n        dp = [Max] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if (coins[j] <= i):\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)\n        \n        if amount < dp[amount]:\n            return -1\n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n            \n        \n        D = [0] * (amount+1)\n        \n        def helper(rem):\n            nonlocal D\n            \n                        \n            if rem < 0:\n                return -1\n            \n            if rem == 0:\n                return 0\n            \n            if D[rem]!= 0:\n                return D[rem]\n            \n            minn = float('inf')\n\n            for coin in coins:\n                res = helper(rem-coin)\n                if res >= 0 and res < minn:\n                    minn = res+1\n            \n            if minn == float('inf'):\n                D[rem] = -1\n            else:\n                D[rem] = minn\n                \n            return D[rem]\n            \n        \n        return helper(amount)\n        \n                \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1) # dp[n] means minimal coin number to gather n amount of money\n        dp[0] = 0\n        \n        for i in range(len(dp)):\n            for j in range(len(coins)):\n                if i >= coins[j]:\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)\n        return dp[amount] if dp[amount] < amount + 1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n              \n        dp = [None for i in range(0,amount+1)]\n        dp[0] = 0\n    \n    \n        for i in range(1, amount+1):\n            min_cost = float('inf')\n            for j in range(0,len(coins)):\n                if coins[j]<=i:\n                    min_cost = min(min_cost, dp[i-coins[j]]+1)\n            dp[i] = min_cost\n\n        if dp[-1] > amount:\n            return -1\n\n        return dp[-1]\n\n        \n        coinsNeeded = {}\n        coinsNeeded[0] = 0\n        for n in coins:\n            coinsNeeded[n] = 1\n        \n        \n        def findMinCoins(amount):\n            # print(amount)\n            if amount < 0:\n                return float('inf')\n            \n            if amount in coinsNeeded:\n                # coinsNeeded[amount] = min(coinsUsed, coinsNeeded[amount])\n                return coinsNeeded[amount]\n            \n            for n in coins:\n                # if amount-n>=0:\n                coinsUsed = 1+findMinCoins(amount-n)\n                # if coinsUsed > 0:\n                if amount in coinsNeeded:\n                    coinsNeeded[amount] = min(coinsUsed, coinsNeeded[amount])\n                else:\n                    coinsNeeded[amount] = coinsUsed\n\n\n            # if amount in coinsNeeded:\n            return coinsNeeded[amount]\n            # return -1\n        \n        findMinCoins(amount)\n        # print(coinsNeeded)\n        if coinsNeeded[amount] == float('inf'):\n            return -1\n        # if amount in coinsNeeded:\n        return coinsNeeded[amount]\n        # return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        import sys\n        dp = [sys.maxsize for _ in range(amount + 1)]\n        dp[0] = 0\n        for i in range(0,amount + 1):\n            \n            for coin in coins:\n                \n                if 0 <= i - coin < amount + 1:\n                    \n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n        return dp[-1] if dp[-1] != sys.maxsize else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        coins.sort()\n        for i in range(amount + 1):\n            for j in range(len(coins)):\n                if(coins[j] <= amount):\n                    dp[i] = min(dp[i], 1 + dp[i - coins[j]])\n                else:\n                    break\n        if(dp[amount] > amount):\n            return -1\n        else:\n            return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1 for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(1,amount+1):\n            for j in range(len(coins)):\n                if coins[j]<=i:\n                    dp[i] = min(dp[i], dp[i-coins[j]] + 1)\n        return -1 if dp[-1] > amount else dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp=[float('inf')]*(amount+1)\n        dp[0]=0\n        \n        for i in range(1,amount+1):\n            for j in range(len(coins)):\n                if coins[j]<=i:\n                    dp[i] = min(dp[i],dp[i-coins[j]]+1)\n\n        print(dp)\n        return dp[amount] if dp[amount]<float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [sys.maxsize] * (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for c in coins:\n                if 0 <= i-c < amount+1:\n                    dp[i] = min(dp[i], dp[i-c]+1)\n        return dp[-1] if dp[-1] != sys.maxsize else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1 for _ in range(amount + 1)]\n        dp[0] = 0;\n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if coins[j] <= i:\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)\n        return -1 if dp[amount] > amount else dp[amount]", "import collections\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        seen = set()\n        queue = collections.deque()\n        for coin in coins:\n            queue.append((amount - coin, 1))\n        \n        while queue: \n            curr = queue.popleft()\n            if curr[0] == 0: return curr[1]\n            if curr[0] < 0 or curr[0] in seen: continue\n            seen.add(curr[0])\n            for coin in coins:\n                queue.append((curr[0] - coin, curr[1] + 1))\n        \n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coins = coins\n        self.amount = amount\n        self.cache = {}\n        \n        # Run\n        res = self.getValue(self.amount)\n        if res is None:\n            return -1\n        else:\n            return res\n        \n        \n        \n    def getValue(self, amount):\n        if amount in self.cache:\n            return self.cache[amount]\n        if amount < 0:\n            return None\n        if amount == 0:\n            return 0\n        if amount in self.coins:\n            return 1\n        # Recurse\n        min_count = None\n        for coin in self.coins:\n            count = self.getValue(amount - coin)\n            if count is not None:\n                if min_count is None or min_count > count + 1:\n                    min_count = count + 1\n        self.cache[amount] = min_count\n        return min_count\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        s = list()\n        import sys\n        for i in range(0,amount+1):\n            s.append(sys.maxsize)\n        s[0] = 0\n        \n        for i in range(1,amount+1):\n            m = sys.maxsize\n            for j in range(0, len(coins)):\n                if i-coins[j] >= 0:\n                    m = min(m, s[i-coins[j]])\n            if m == sys.maxsize:\n                s[i] = m\n            else:\n                s[i] = m+1\n        if s[amount] == sys.maxsize:\n            s[amount] = -1\n        \n        return s[amount]\n                    \n        \n", "class Solution:\n    def coinChange(self, coins, amount):\n        '''\n        :type coins: list of int\n        :type amount: int\n        :rtype: int\n        '''\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for i in range(1, amount + 1):\n            for j in range(0, len(coins)):\n                if coins[j] <= i:\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)\n\n        return -1 if dp[amount] > amount else dp[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1 for _ in range(amount+1)]\n        dp[0] = 0\n        coins.sort()\n        for i in range(amount+1):\n            for j in range(len(coins)):\n                if coins[j] <= i:\n                    dp[i] = min(dp[i], 1+dp[i-coins[j]])\n                else:\n                    break\n                    \n        if dp[-1] == amount + 1:\n            return -1\n        else:\n            return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 0 or not coins:\n            return -1\n        if amount == 0:\n            return 0\n        min_com = [0 for i in range(amount+1)]\n        for i in range(1, amount + 1):\n            for c in coins:\n                if i >= c and (min_com[i - c] > 0 or i - c == 0):\n                    if min_com[i] == 0:\n                        min_com[i] = min_com[i - c] + 1\n                    else:\n                        min_com[i] = min(min_com[i], min_com[i - c] + 1)\n            # if min_com[i] == 0:\n                # min_com[i] = -1\n        if min_com[amount] == 0:\n            return -1\n        return min_com[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.smallest = float('inf')\n        coins.sort(reverse=True)\n        self.dfs(coins, amount, 0)\n        return -1 if type(self.smallest) is float else self.smallest\n    \n    def dfs(self, coins, amount, prev_count):\n        if len(coins) == 0:\n            return\n        if amount % coins[0] == 0:\n            self.smallest = min(self.smallest, prev_count + amount // coins[0])\n        else:\n            for k in range(amount // coins[0], -1, -1):\n                if prev_count + k >= self.smallest:\n                    break\n                self.dfs(coins[1:], amount - k * coins[0], prev_count + k)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1 for i in range(amount + 1)]\n        dp[0] = 0\n        coins.sort()\n        for i in range(amount + 1):\n            for j in range(len(coins)):\n                if(coins[j] <= amount):\n                    dp[i] = min(dp[i], 1 + dp[i - coins[j]])\n                else:\n                    break\n        if(dp[amount] > amount):\n            return -1\n        else:\n            return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount==0:\n            return 0\n        dp=[None]*(amount+1)\n        dp[0]=0\n        n= len(coins)\n        for coin in coins:\n            if coin<= amount:\n                dp[coin]=1\n        for i in range(1,amount+1):\n            if i in coins:\n                continue\n            tmp= float('inf')\n            for coin in coins:\n                \n                if coin<= i:\n                    if dp[i-coin]==-1:\n                        continue\n                    else:                        \n                        tmp= min(tmp,1+dp[i-coin])\n                else:\n                    continue\n            if tmp==float('inf'):\n                dp[i]=-1\n            else:\n                dp[i]=tmp\n        print(dp)        \n        return dp[-1]\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:    \n        dp = [0] + [float('inf') for i in range(amount)]\n        for cost in range(0, len(dp)):\n            for coin in coins:\n                if cost + coin > amount:\n                    continue\n                dp[cost + coin] = min(dp[cost + coin], dp[cost] + 1)\n        if dp[-1] != float('inf'):\n            return dp[-1]\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n        def make_change(sum_remaining, coins, mem):\n            if sum_remaining < 0:\n                return -1\n            elif sum_remaining == 0:\n                return 0\n            elif mem[sum_remaining]:\n                return mem[sum_remaining]\n            else:\n                min_coins = amount + 1\n                for coin in coins:\n                    if (sum_remaining - coin) >= 0:\n                        prev_coins = make_change(sum_remaining - coin, coins, mem)\n                        curr_coins = 1 + prev_coins\n                        if curr_coins > 0 and curr_coins < min_coins:\n                            min_coins = curr_coins\n                mem[sum_remaining] = min_coins\n                return mem[sum_remaining]\n        \n        mem = [None] * (amount+1)\n        ans = make_change(amount, coins, mem)\n        if ans == amount + 1:\n            return -1\n        else:\n            return ans", "# top down approach\nimport math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        counts = [0]*amount\n        return f(coins, amount, counts)\n\ndef f(coins, amount, counts):\n    \n    # base case\n    if amount < 0:\n        return -1\n    if amount == 0:\n        return 0\n    if (counts[amount - 1] != 0):\n        return counts[amount - 1]\n    min_val = math.inf\n    for c in coins:\n        res = f(coins, amount - c, counts)\n        if res >= 0 and res < min_val:\n            min_val = 1 + res\n    \n    if min_val == math.inf:\n        counts[amount - 1] = -1\n    else:\n        counts[amount - 1] = min_val\n    \n    return counts[amount - 1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        changes=[amount+1]*(amount+1)\n        changes[0]=0\n        for i in range(1,amount+1):\n            for coin in coins:\n                if coin>i:\n                    break\n                else:\n                    changes[i]=min(changes[i],changes[i-coin]+1)\n        return changes[-1] if changes[-1]!=(amount+1) else -1", "class Solution:\n    def coinChange(self, coins, amount):\n        coins.sort(reverse = True)\n        lenc, self.res = len(coins), 2**31-1\n\n        def dfs(pt, rem, count):\n            if not rem:\n                self.res = min(self.res, count)\n            for i in range(pt, lenc):\n                if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                    dfs(i, rem-coins[i], count+1)\n\n        for i in range(lenc):\n            dfs(i, amount, 0)\n        return self.res if self.res < 2**31-1 else -1\n\n#       def coinChange(self, coins: List[int], amount: int) -> int:\n#         coins.sort(reverse = True)\n#         min_coins = float('inf')\n\n#         def count_coins(start_coin, coin_count, remaining_amount):\n#             nonlocal min_coins\n\n#             if remaining_amount == 0:\n#             min_coins = min(min_coins, coin_count)\n#             return\n\n#           # Iterate from largest coins to smallest coins\n#             for i in range(start_coin, len(coins)):\n#             remaining_coin_allowance = min_coins - coin_count\n#             max_amount_possible = coins[i] * remaining_coin_allowance\n\n#             if coins[i] <= remaining_amount and remaining_amount < max_amount_possible:\n#                 count_coins(i, coin_count + 1, remaining_amount - coins[i])\n\n#         count_coins(0, 0, amount)\n#         return min_coins if min_coins < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n        @lru_cache(maxsize=None)\n        def helper(amount):\n            if amount <= 0:\n                return 0\n            min_so_far = math.inf\n            for i in range(len(coins)):\n                if coins[i] <= amount:\n                    min_so_far = min(min_so_far, 1 + helper(amount - coins[i]))\n            return min_so_far\n\n        result = helper(amount)\n        if result == math.inf:\n            return -1\n        return result", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        T = len(coins)\n        dp = [0 for i in range(amount + 1)]\n        for n in range(1, amount + 1):\n            dp[n] = math.inf\n            for i in range(T):\n                if (n - coins[i] >= 0):\n                    subProbSol = dp[n - coins[i]]\n                    dp[n] = min(dp[n], subProbSol + 1)\n        if dp[amount] == math.inf : return -1\n        else : return (dp[amount])\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = {}\n        dp[0]=0\n        for i in range(1, amount+1):\n            dp[i] = float('inf')\n            for c in coins:\n                if c<i:\n                    dp[i] = min(dp[i-c]+1, dp[i])\n                if c==i:\n                    dp[i]=1\n        \n        return dp[amount] if dp[amount] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        numCoins = [float('inf') for i in range(amount)]\n        for coin in coins:\n            if coin-1 < amount:\n                numCoins[coin-1]=1\n        for i in range(amount):\n            minCoin = float('inf')\n            change=True\n            for coin in coins:\n                if i == coin-1:\n                    change = False\n                    break\n                if i-coin>=0:\n                    minCoin = min(numCoins[i-coin], minCoin)\n            if change and minCoin !=float('inf'):\n                numCoins[i]=minCoin+1\n            # print(numCoins)\n        if numCoins[-1]==float('inf'):\n            return -1\n        return numCoins[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        11 -> 0\n        \n        10 -> 1 -> (6 -> 5)\n        9 -> 1\n        6 -> 1\n        \n        \n        '''\n        \n        def helper(remAmt, coins):\n            nonlocal mem\n            \n            if remAmt in mem:\n                return mem[remAmt]\n\n            minCoins = float('inf')\n\n            for coin in coins:\n                if coin <= remAmt:\n                    result = 1 + helper(remAmt-coin, coins)\n                    minCoins = min(minCoins, result)\n                else:\n                    break\n            \n            mem[remAmt] = minCoins\n            return minCoins\n        \n        if amount < 1:\n            return 0\n        \n        mem = {0:0}\n        coins.sort()\n        minCoins = helper(amount, coins)\n        if minCoins == float('inf'):\n            return -1\n        return minCoins", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        return self.aux(coins, amount, memo)\n        \n    def aux(self, coins, amount, memo) :\n        if amount < 0 :\n            return -1\n        \n        if amount == 0 :\n            return 0\n        \n        if amount in memo.keys() :\n            return memo[amount]\n        \n        minimum = 999999999\n        \n        for x in coins :\n            temp = self.aux(coins, amount - x, memo)\n            if temp < minimum and temp >= 0 :\n                minimum = temp\n                \n        if minimum == 999999999 :\n            memo[amount] = -1\n            return memo[amount]\n            \n        memo[amount] = 1 + minimum\n        \n        return memo[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = set(coins)        \n        d = {}\n        if(amount == 0):\n            return 0\n        \n        def solve(amt):\n            if amt in d:\n                return d[amt]\n            \n            if amt <= 0:\n                return -1\n            \n            if amt in coins:\n                d[amt] = 1\n                return d[amt]\n            \n            poss = []\n            \n            for c in coins:\n                search = amt-c\n                if(search <1):\n                    continue\n                val = solve(search)\n                if val != -1:\n                    poss.append(val)\n            \n            if(len(poss) != 0):\n                d[amt] = 1 + min(poss)\n            else:\n                d[amt] = -1\n                \n            return d[amt]                \n        \n        return solve(amount)\n            \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        self.cache=[0] * (amount + 1)\n        return self.coin_change(coins, amount)\n\n    def coin_change(self, coins, remainder):\n        if remainder < 0:\n            return -1\n\n        if remainder == 0:\n            return 0\n\n        if self.cache[remainder] != 0:\n            return self.cache[remainder]\n\n        system_max = sys.maxsize\n        minimum = system_max\n        for coin in coins:\n            change_result = self.coin_change(coins, remainder - coin)\n\n            if (change_result >= 0 and change_result < minimum):\n                minimum = 1 + change_result\n\n        self.cache[remainder] = -1 if (minimum == system_max) else minimum\n\n        return self.cache[remainder]\n#         if not coins:\n#             return 0\n#         dp = [float(\\\"inf\\\") for _ in range(amount + 1)]\n        \n#         dp[0]=0\n#         for i in range(1,amount+1):\n#             for coin in coins:\n#                 if i>=coin:\n#                     dp[i] = min(dp[i],dp[i-coin]+1)\n#         if dp[amount]!= float(\\\"inf\\\"):\n#             return dp[-1]\n#         else:\n#             return -1\n            \n#         \\\"\\\"\\\"\n#         #1  Return 0 if there are no given coins\n#         \\\"\\\"\\\"\n#         if not coins:\n#             return 0\n        \n#         \\\"\\\"\\\"\n#         #2  Initialize a 'dp' array of a size of the given amount (inclusive, hence +1).\n#         #   Initialize each index element to be an arbitary number. In this case I chose amount + 1. E.g.: 11 + 1 = 12\n#         \\\"\\\"\\\"\n#         dp = [float(\\\"inf\\\") for _ in range(amount + 1)]\n        \n#         \\\"\\\"\\\"\n#         #3  Base case. Make the first cell 0 because if amount is 0, you do not need any coin to make up to that amount\n#         #   stdout: dp = [0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]\n#         \\\"\\\"\\\"\n#         dp[0] = 0\n        \n#         \\\"\\\"\\\"\n#         #4  Look through the entire 'dp' array, for each of the index element, we will check it against the list(array) of given coins.\n#         #   'i' in this case is the amount we want to compute from bottom-up starting from 0 to the 'amount' that the question asks for\n#         #   E.g.: [0, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12] vs [1, 2, 5]\n#                    ^                   ^                           ^             \n#                    amount 0            amount 5                    amount = 11 (this is what we want)             \n#         \\\"\\\"\\\"\n#         for i in range(1, amount+1):\n#             for coin in coins:\n#                 \\\"\\\"\\\"\n#                 #5  If 'i' (the current amount we want to find, is less than 'coin', we will skip that. Otherwise compute it:\n#                 #   Because it does not make sense to compute the coin if the coin itself is already larger than the amount that we're looking at\n#                 \\\"\\\"\\\"\n#                 if i >= coin:\n#                     \\\"\\\"\\\"\n#                     #6  We shall update each dp[i] to be the minimum between itself vs it's previous computed answer dp[i-coin]. \n#                     #   And we do this for each available coin. Only if 'coin' is smaller than the amount 'i'\n#                     #   We do '+1' for dp[i-coin] + 1 here because it costs us a step to do so\n#                     \\\"\\\"\\\"\n#                     dp[i] = min(dp[i], dp[i-coin] + 1)\n        \n#         \\\"\\\"\\\"\n#         #7  By the end of the 2 for loops, you will end up with \n#         #   stdout: [0, 1, 1, 2, 2, 1, 2, 2, 3, 3, 2, 3]\n        \n#         #8  So if the dp[amount] is not the original amount we initialized at Step #3. Then we shall return the dp[amount] that was asked by the question\n#         \\\"\\\"\\\"\n#         if dp[amount] != float(\\\"inf\\\"):\n#             return dp[amount]\n#         else:\n#             return -1\n        \n#         \\\"\\\"\\\"\n#         #9  Else. If the dp[amount] is still amount + 1 as we initialized. It means there were no suitable coins for this scenario and -1 is returned\n#         \\\"\\\"\\\"\n    \n#         # key:amount value:min number of coins for the amount\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        return self.dfs(coins, 0, 0, amount, -1)\n    \n    def dfs(self, coins: List[int], idx: int, cnt: int, amount: int, minCnt: int) -> int:\n        if amount==0:\n            return cnt\n        if idx >= len(coins):\n            return -1\n        \n        # Trim\n        if minCnt>0 and cnt+amount//coins[idx]+1 > minCnt:\n            return -1\n        \n        # Select [0, amount//coins[idx] ]\n        for i in range(amount//coins[idx], -1, -1):\n            res = self.dfs(coins, idx+1, cnt+i, amount-coins[idx]*i, minCnt)\n            if res!=-1:\n                minCnt = res if minCnt==-1 else min(minCnt, res)\n        return minCnt", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        use dp 0 - 11\n        '''\n        if amount == 0:\n            return 0\n        \n        dp = [float('inf')] * amount\n        \n        for i in range(0, amount):\n            for c in coins:\n                if (i + 1) % c == 0:\n                    dp[i] = min(dp[i], (i + 1) // c)\n                elif i + 1 > c:\n                    dp[i] = min(dp[i], dp[i - c] + 1)\n            \n        return -1 if dp[-1] == float('inf') else dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        if amount==0: return 0\n        if amount<min(coins):\n            return -1\n        \n        l = min(coins)\n        \n        A = [0 for i in range(amount+1)]\n        A[l] = 1\n        \n        for i in range(1,amount+1):\n            A[i] = float('inf')\n            for coin in coins:\n                if i>coin and A[i-coin]>0:\n                    A[i] = min(A[i],1+A[i-coin])\n                elif i==coin: A[i] = 1\n            if A[i]==float('inf'):\n                A[i]=0\n                           \n                           \n                \n                \n        print(A)\n        if A[amount]==0: return -1\n        return A[amount]\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n        count = {}\n        for coin in coins:\n            count[coin] = 1\n\n        count[0] = 0\n\n        for i in range(1,amount+1):\n            ans = amount + 1\n            if i in list(count.keys()):\n                continue\n\n            for coin in coins:\n                if i - coin > 0 and count[i-coin]!= -1:\n                    ans = min(count[i-coin], ans)\n            if ans == amount + 1:\n                count[i] = -1\n            else:\n                count[i] = ans + 1\n\n        return count[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1: return 0\n        cnt = [0 for __ in range(amount)]\n        return self.coinMake(coins, amount, cnt)\n        \n    def coinMake(self, coins, rem, count):\n        if rem < 0: return -1\n        if rem == 0: return 0\n        if count[rem - 1] != 0: return count[rem - 1]\n        MIN = 2**32 - 1\n        for i in coins:\n            res = self.coinMake(coins, rem - i, count)\n            if res >= 0 and res < MIN: MIN = 1 + res\n        count[rem - 1] = -1 if MIN == 2**32 - 1 else MIN\n        return count[rem - 1]\n        \n        #recursive + memo\n        #memo = [2**32 - 1 for __ in range(amount + 1)]\n        #memo[0] = 0\n        #return self.coinChangeDFS(coins, amount, memo)\n    \n    #def coinChangeDFS(self, coins, target, memo):\n    #    if target < 0: return -1\n    #    if memo[target] != 2**32 -1: return memo[target]\n    #    for i in range(len(coins)):\n    #        tmp = self.coinChangeDFS(coins, target - coins[i], memo)\n    #        if tmp >= 0: memo[target] = min(memo[target], tmp + 1)\n    #    return -1 if memo[target] == 2**32 - 1 else memo[target]\n        \n        \n        \n        #iterative\n        #DP = [amount + 1 for __ in range(amount + 1)]\n        #DP[0] = 0\n\n        #for i in range(amount + 1):\n        #    for j in range(len(coins)):\n        #        if coins[j] <= i:\n        #            DP[i] = min(DP[i], DP[i - coins[j]] + 1)\n        #return -1 if DP[amount] > amount else DP[amount]\n        \n        \n        \n        \n        \n        \n        \n        \n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount == 0:\n            return 0\n        \n        mem = {}\n        max_amount = 10 ** 4 + 1\n        \n        def cc(amount):\n            mem[amount] = max_amount\n            for coin in coins:\n                dif = amount - coin\n                \n                if dif == 0:\n                    mem[amount] = 1\n                elif dif > 0:\n                    if dif not in mem:\n                        cc(dif)\n                    mem[amount] = min(mem[amount], mem[dif] + 1)\n        \n        cc(amount)\n        \n        if mem[amount] == max_amount:\n            return -1\n        else:\n            return mem[amount]\n                    \n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        states = [0] * (amount + 1)\n        for s in range(0, amount+1):\n            if s == 0:\n                states[s] = 0\n            else:\n                min_c = 1e9\n                for c in coins:\n                    if c <= s and states[s-c] != -1:\n                        min_c = min(min_c, 1 + states[s-c])\n                if min_c == 1e9:\n                    states[s] = -1\n                else:\n                    states[s] = min_c\n                print(s, states[s])\n        return states[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0 or not coins:\n            return 0\n        \n        minlst = [float('inf')] * (amount + 1)\n        n = len(minlst)\n        minlst[0] = 0\n\n        for i in range(1,n):\n            for denom in coins:\n                remainder = i - denom\n                if remainder < 0:\n                    continue\n\n                newsmallest = min(minlst[remainder] + 1, minlst[i])\n                minlst[i] = newsmallest\n        return -1 if minlst[-1] == float('inf') else minlst[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        s = list()\n        #import sys\n        #for i in range(0,amount+1):\n        #    s.append(sys.maxsize)\n        #s[0] = 0\n        s.append(0)\n        \n        for i in range(1,amount+1):\n            m = list()\n            for j in range(0, len(coins)):\n                if i-coins[j] >= 0:\n                    m.append(s[i-coins[j]])\n            #print(m)\n            #remove negative \n            mm = [item for item in m if item >= 0]\n            #print(mm)\n            if len(mm) == 0 :\n                s.append(-1)\n            else:\n                s.append(min(mm)+1)\n        #if s[amount] == sys.maxsize:\n        #    s[amount] = -1\n        \n        return s[amount]\n                    \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def my_coinChange(coins, rem, count):\n            if rem < 0:\n                return -1\n            if rem == 0:\n                return 0\n            if count[rem - 1] != 0:\n                return count[rem - 1]\n\n            my_min = float('inf')\n\n            for coin in coins:\n                res = my_coinChange(coins, rem - coin, count)\n                if res >= 0 and res < my_min:\n                    my_min = 1 + res\n\n            count[rem - 1] = -1 if my_min == float('inf') else my_min\n            return count[rem - 1]\n        \n        if amount < 1:\n            return 0\n        return my_coinChange(coins, amount, [0] * amount)\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n\n        f = [sys.maxsize for i in range(amount + 1)]\n\n        f[0] = 0\n        for i in range(1, len(f)):\n            for coin in coins:\n                if i - coin >= 0 and f[i - coin] != sys.maxsize:\n                    f[i] = min(f[i], f[i - coin] + 1)\n\n        if f[amount] == sys.maxsize:\n            return -1\n\n        return f[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [None for _ in range(amount+2)]\n        dp[amount+1] = float('inf')\n        dp[amount] = 0\n        for i in range(amount-1, -1, -1):\n            s = float('inf')\n            for c in coins:\n                s = min(s, 1 + dp[min(c+i,amount+1)])\n            dp[i] = s\n        if dp[0] == float('inf'):\n            return -1\n        return dp[0]\n        \n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def helper(coins, rem, count): #count is a list\n            if rem < 0:\n                return -1\n            if rem == 0:\n                return 0\n            if count[rem-1] != 0: return count[rem-1]\n            minVal = float('inf')\n            for c in coins:\n                res = helper(coins, rem-c, count)\n                if res >= 0 and res < minVal:\n                    minVal = 1 + res;\n            if minVal == float('inf'):\n                count[rem-1] = -1\n            else:\n                count[rem-1] = minVal\n            return count[rem-1]\n        \n        if amount < 1:\n            return 0\n        return helper(coins, amount, [0]*amount)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        result = []\n        coins.sort(reverse=True)\n        max_sum = 2**31-1\n\n        def find_combinations(combination, remain, start):\n            nonlocal max_sum\n            if remain == 0:\n                max_sum = min(max_sum, len(combination))\n                return\n            elif remain < 0:\n                return\n\n            for i in range(start, len(coins)):\n                allowed_coins = max_sum - len(combination)\n                max_value_can_be_achieved = coins[i] * allowed_coins\n                if coins[i] <= remain < max_value_can_be_achieved:\n                    combination.append(coins[i])\n                    find_combinations(combination, remain-coins[i], i)\n                    combination.pop()\n                \n        find_combinations([], amount, 0)\n        \n        if  max_sum == 2**31 -1:\n            return -1\n        return max_sum\n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        memo = {}\n\n        def solve(cur):\n            \n            if cur in memo:\n                return memo[cur]\n            \n            if cur == 0:\n                return 0\n            \n            arr = [float('inf')] * len(coins)\n            for i, coin in enumerate(coins):\n                if cur - coin < 0:\n                    arr[i] = float('inf')\n                else:\n                    arr[i] = solve(cur - coin) + 1\n                \n            ret = min(arr)\n            memo[cur] = ret\n            return ret\n        \n        ans = solve(amount)\n        \n        if ans == float('inf'):\n            return -1\n        return ans\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # use DP\n        N = len(coins)\n        M = amount\n        table = [-1]*(M+1)\n        for j in range(N+1):\n            table[0] = 0\n        for m in range(1,M+1):\n            for i in range(N):\n                c = coins[i]\n                if c > m:\n                    pass\n                elif table[m-c] != -1:\n                    if table[m]!= -1:\n                        table[m] = min(table[m-c]+1, table[m])\n                    else:\n                        table[m] = table[m-c]+1\n        return table[M]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def dp(t):\n            if t in d:\n                return d[t]\n            res=float('inf')\n            for c in coins:\n                if t-c>=0:\n                    res=min(res,dp(t-c)+1)\n            d[t]=res\n            return res\n        d={0:0}\n        x=dp(amount)\n        return x if x<float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def dfs(remaining):\n            nonlocal memo\n            if remaining == 0:\n                return 0\n            if remaining < 0:\n                return -1\n            if memo[remaining]:\n                return memo[remaining]\n            \n            # res initialize as infinity, but in this case\n            # total amount is `amount`, we at most have `amount` 1 coins\n            # so, `amount+1` can be considered as a maximum\n            res = amount + 1\n            for coin in coins:\n                count = dfs(remaining - coin)\n                if count == -1:\n                    continue\n                res = min(res, 1 + count)\n            memo[remaining] = res if res != amount + 1 else -1\n            return memo[remaining]\n        memo = [None for _ in range(amount + 1)]\n        return dfs(amount)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        cal=[float('inf') for i in range(amount+1)]\n        for i in range(0,amount+1):\n            for j in range(len(coins)):\n                if i==0:\n                    cal[i]=0\n                elif coins[j]<=i:\n                    cal[i]=min(1+cal[i-coins[j]],cal[i])\n        print(cal)\n        if cal[amount] == float('inf'):\n            return -1\n        else:\n            return cal[amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n        # dp[i] is the minimum number of coins to total i + 1 dollars\n        dp: List[int] = [0 for _ in range(amount)]\n\n        for i in range(amount):\n            for coin in coins:\n                if coin > i + 1:\n                    continue\n                if coin == i + 1:\n                    dp[i] = 1\n                elif dp[i - coin] != 0:\n                    if dp[i] == 0:\n                        dp[i] = dp[i - coin] + 1\n                    else:\n                        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount - 1] if dp[amount - 1] != 0 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        x=coinCount(coins, amount, {})\n        if(x==float('inf')):\n            return -1\n        return x\n    \n    \n    \ndef coinCount(coins, amount, found):\n    \n    if(amount<0):\n        return float('inf')\n    if(amount==0):\n        return 0\n    if(found.get(amount)):\n        return found[amount]\n    count=0\n    minCount=float('inf')\n    for coin in coins:\n        if(coin==amount):\n            return 1\n        count=1+coinCount(coins, amount-coin, found)\n        if(count< minCount):\n            minCount=count\n            \n            \n    found[amount]=minCount\n    return minCount\n    \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        dp = [-1 for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(0, amount+1):\n            for value in coins:\n                if i - value > 0:\n                    if dp[i-value] >= 0:\n                        if dp[i] < 0:\n                            dp[i] = dp[i-value]+1\n                        else:\n                            dp[i] = min(dp[i], dp[i-value]+1)\n                if i - value == 0:\n                    dp[i] = 1\n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        \n        def opt(v):\n            if v == 0:\n                return 0\n            if v in memo:\n                return memo[v]\n            \n            result = float('inf')\n            for i in coins:\n                if v - i >= 0:\n                    result = min(result, opt(v-i)+1)\n                else:\n                    continue\n            memo[v] = result\n            return memo[v]\n        \n        memo = {}\n        coins = opt(amount)\n        if coins == float('inf'):\n            return -1\n        else:\n            return coins", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        seen = {0:0}\n\n\n        def helper(coins, amount):\n            \n            if amount in seen:\n                return seen[amount]\n            \n            if amount < 0:\n                return -1\n\n            leastCoins = float('Inf')\n            for coin in coins:\n                next_least = helper(coins, amount-coin)\n                if next_least != -1:\n                    leastCoins = min(leastCoins, 1+next_least)\n            if leastCoins == float('Inf'):\n                seen[amount] = -1\n                return -1\n            else:\n                seen[amount] = leastCoins\n                return leastCoins\n            \n\n        return helper(coins, amount)", "\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        memo = { x: amount+1 for x in range(amount+1)}\n        memo[0] = 0        \n        \n        for i in range(amount+1):\n            for j in range(len(coins)):\n                if coins[j] <= i:\n                    memo[i] = min( memo[i], 1 + memo[i- coins[j]])\n               \n        \n        if memo[amount] < amount + 1:\n            return memo[amount]\n        else:\n            return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        dp = {}\n        for c in coins:\n            dp[c] = 1\n\n        for i in range(amount+1):\n            for c in coins:\n                if dp.get(i-c):\n                    if not dp.get(i):\n                        dp[i] = dp[i-c] + 1\n                    else:\n                        dp[i] = min(dp[i], dp[i-c] + 1)\n        return dp.get(amount, -1)\n                    \n                \n", "class Solution:\n    IMPOSSIBLE = -1\n    \n    def computeMinCoins(self, n: int) -> int:\n        if (result := self.memoization.get(n)) is not None:\n            return result\n        if n == 0:\n            result = 0\n        else:\n            result = Solution.IMPOSSIBLE\n            for coin in self.coins:\n                if coin > n:\n                    continue\n                if ((needed_extra := self.computeMinCoins(n - coin)) !=\n                        Solution.IMPOSSIBLE):          \n                    possible_result = 1 + needed_extra\n                    if result == Solution.IMPOSSIBLE or result > possible_result:\n                        result = possible_result\n        self.memoization[n] = result\n        return result\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        if amount % coins[0] == 0:\n            return amount // coins[0]\n        self.coins = coins\n        self.memoization = {}\n        return self.computeMinCoins(amount)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        dp = [None for _ in range(amount + 1)]\n        ret = self.helper(coins, amount, dp)\n        return ret if ret != float('inf') else -1\n        \n    def helper(self, coins: List[int], amount: int, dp) -> int:\n        if amount == 0:\n            return 0\n        if amount < coins[0]:\n            return float('inf')\n        \n        ans = float('inf')\n        for coin in coins:\n            if amount >= coin:\n                if amount == coin:\n                    ans = 0\n                else:\n                    tmp = self.helper(coins, amount - coin, dp) if dp[amount-coin] == None else dp[amount-coin]\n                    if dp[amount-coin] == None:\n                        dp[amount-coin] = tmp\n                        \n                    ans = min(ans, tmp)\n        \n        return ans + 1 if ans != -1 else -1", "# class Solution:\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         min_coins = float('inf')\n#         def backtrack(tot, count):\n#             nonlocal min_coins\n#             if tot == 0:\n#                 min_coins = min(min_coins, count)\n#                 return\n#             for coin in coins:\n#                 if coin <= tot:\n#                     backtrack(tot - coin, count + 1)\n#         backtrack(amount, 0)\n#         return -1 if min_coins == float('inf') else min_coins\n    \n    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        def backtrack(tot):            \n            if tot == 0:\n                return 0   \n            if tot not in memo:\n                min_coins = float('inf')\n                for coin in coins:\n                    if coin <= tot:\n                        cur_count = backtrack(tot - coin) + 1\n                        min_coins = min(min_coins, cur_count)\n                memo[tot] = min_coins\n            return memo[tot]\n        out = backtrack(amount)\n        return -1 if out == float('inf') else out\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memory = {}\n        return self._helper(coins, amount, memory)\n    \n    def _helper(self, coins, amount, memory):\n        if amount < 0:\n            return -1\n        elif amount == 0:\n            return 0\n        elif amount in memory:\n            return memory[amount]\n        \n        potential_values = []\n        for coin in coins:\n            new_target = amount - coin\n            min_coins = self._helper(coins, new_target, memory)\n            \n            if min_coins != -1:\n                potential_values.append(min_coins)\n                \n        if len(potential_values) == 0:\n            memory[amount] = -1\n        else:\n            memory[amount] = min(potential_values) + 1\n        \n        return memory[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        d = {0:0}\n        \n        def dfs(left, num):\n            if left < 0:\n                return -1\n            \n            if left in d:\n                return d[left]\n            \n            min_ans = math.inf\n            for each in coins:\n                val = dfs(left-each, num+1)\n                if val >= 0:\n                    min_ans = min(min_ans, val)\n            \n            if min_ans == math.inf:\n                d[left] = -1\n            else:\n                d[left] = min_ans + 1\n            \n            return d[left]\n        \n\n        return dfs(amount, 0)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] * (amount + 1)\n        return self.painful(coins, amount, dp)\n        \n    def painful(self, coins: List[int], amount: int, dp:List[int]) -> int:\n        if amount == 0:\n            return 0\n        \n        if amount < 0:\n            return -1\n        \n        if dp[amount]:\n            return dp[amount]\n\n        minCost = math.inf\n            \n        for coin in coins:\n            res = self.painful(coins, amount - coin, dp)\n            \n            if res != -1:\n                minCost = min(minCost, 1 + res)\n        \n        dp[amount] = minCost if minCost < math.inf else -1\n            \n        return minCost if minCost < math.inf else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        cache = [[float('inf')]*(amount + 1) for _ in range(len(coins) + 1)]\n        # for any amount, no coins\n        for i in range(len(coins) + 1):\n            cache[i][0] = 0\n            \n        for i in range(1, len(coins) + 1):\n            for j in range(1, amount + 1):\n                if j >= coins[i - 1]:\n                    cache[i][j] = min(cache[i - 1][j], cache[i][j - coins[i - 1]] + 1)\n                else:\n                    cache[i][j] = cache[i - 1][j]\n\n        return cache[-1][-1] if cache[-1][-1] != float('inf') else -1\n\n\n    # Recurrence Relation\n    # base case: no coins, any amount > 0: -1\n    #            any number of coins (even 0), amount 0: 0 coins\n    #\n    # For any new coin i, either use the coin or don't use it to reach the amount j\n    # If not using coin: num_coins[i][j] = num_coins[i - 1][j] same as num coins without that coin\n    # If using coin: num_coins[i][j] = num_coins[i][j - coins[i]] + 1 num coins with (or without) that coin and an amount (amount - coin_value) plus 1\n    # Take minimum between using/not using coin\n    \n    # Can build this up from no coins at all\n    #      amount\n    # coins , , , ,\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def helper(amount, minAmounts):\n            if amount == 0:\n                return 0\n            elif amount < 0:\n                return math.inf\n            if amount in minAmounts:\n                return minAmounts[amount]\n            minAmount = math.inf\n            for coin in coins:\n                minAmount = min(minAmount, helper(amount-coin, minAmounts)+1)\n            minAmounts[amount] = minAmount\n            return minAmount\n        \n        minAmounts = dict()\n        x = helper(amount, minAmounts)\n        if x == math.inf:\n            return -1\n        return x\n", "class Solution:\n    def __init__(self):\n        self.cache = dict()\n        self.coin_set = set()\n\n    # some key takeaways again:\n    # need to reverse sort because of the problem - trying to find min, so need to cache for min\n    # because if get a cache hit then it won't search for more, even if it's not min\n    \n    # the dfs structure here helps because doing a min over a for loop\n    def helper(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        if amount in self.cache:\n            return self.cache[amount]\n        if amount in self.coin_set:\n            return 1\n        potentials = [float('inf')]\n        for coin in coins:\n            if amount > coin:\n                potentials.append(self.helper(coins,amount - coin))\n        res = 1 + min(potentials)\n        self.cache[amount] = res\n        return res\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coin_set = set(coins)\n        coins = sorted(coins,reverse=True)\n        res = self.helper(coins,amount)\n        if res == float('inf'):\n            return -1\n        return res\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins and amount==0: return 1\n        if not coins: return 0\n        \n        dp = [float('inf')]*(amount+1) \n        dp[0]=0\n        for i in range(len(coins)+1):\n            for j in range(amount+1):\n                if j-coins[i-1]>=0:\n                        dp[j] = min(dp[j], dp[j-coins[i-1]]+1)         \n        return dp[-1] if dp[-1]!=float('inf') else -1\n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        coins.sort()\n        cache = {}\n        \n        def rec(amount):\n            \n            if amount == 0:\n                return 0\n            if amount in cache:\n                return cache[amount]\n            val = float('inf')\n            \n            for coin in coins:\n                \n                if amount-coin >= 0:\n                    val = min(val,1+rec(amount-coin))\n            cache[amount] = val\n            return val\n            \n        ans = rec(amount)\n        return ans if ans != float('inf') else -1\n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1 \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        cache = {0: 0}\n        \n        def recurse(i):\n            if i in cache: return cache[i] \n            \n            n = i+1\n            for coin in coins:\n                curr = 0\n                if i >= coin:\n                    next_amount = recurse(i - coin)\n                    if next_amount >= 0:\n                        curr = 1 + next_amount\n                if curr > 0:\n                    n = min(n, curr)\n            \n            result = -1 if n == i+1 else n\n            cache[i] = result\n            return result\n        \n        return recurse(amount)\n                    \n", "class Solution:\n    \n    \n    \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def helper(coins, amount, dp):\n            if amount < 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if amount in dp:\n                return dp[amount]\n            ans = []\n            for i in range(len(coins)):\n                use_ci = 1 + helper(coins, amount - coins[i], dp)\n                ans.append(use_ci)\n                \n            dp[amount] = min(ans)\n \n            return dp[amount]\n        \n        \n        \n        if amount <= 0:\n            return 0\n        dp = {}\n        result = helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n    \n\n", "from collections import defaultdict\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def coin_change_for_amount(coins, amount):\n            nonlocal count_amount\n            \n            if amount < 0:\n                return -1\n            \n            if amount == 0:\n                return 0\n            \n            if count_amount[amount] != float('inf'):\n                return count_amount[amount]\n            \n            min_coins_amt = float('inf')\n            for coin in coins:\n                \n                min_coins_amt_coin = coin_change_for_amount(coins, amount - coin)\n                \n                if 0 <= min_coins_amt_coin < min_coins_amt:\n                    min_coins_amt = min_coins_amt_coin + 1\n            \n            \n            count_amount[amount] = -1 if min_coins_amt == float('inf') else min_coins_amt\n            \n            return count_amount[amount]\n        \n        if amount <= 0:\n            return 0\n        count_amount = [float('inf')] * (amount + 1)\n        coin_change_for_amount(coins, amount)\n        \n        return count_amount[amount]\n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coinsNeeded = {}\n        coinsNeeded[0] = 0\n        for n in coins:\n            coinsNeeded[n] = 1\n        \n        \n        def findMinCoins(amount):\n            # print(amount)\n            if amount < 0:\n                return float('inf')\n            \n            if amount in coinsNeeded:\n                # coinsNeeded[amount] = min(coinsUsed, coinsNeeded[amount])\n                return coinsNeeded[amount]\n            \n            for n in coins:\n                # if amount-n>=0:\n                coinsUsed = 1+findMinCoins(amount-n)\n                # if coinsUsed > 0:\n                if amount in coinsNeeded:\n                    coinsNeeded[amount] = min(coinsUsed, coinsNeeded[amount])\n                else:\n                    coinsNeeded[amount] = coinsUsed\n\n\n            # if amount in coinsNeeded:\n            return coinsNeeded[amount]\n            # return -1\n        \n        findMinCoins(amount)\n        # print(coinsNeeded)\n        if coinsNeeded[amount] == float('inf'):\n            return -1\n        # if amount in coinsNeeded:\n        return coinsNeeded[amount]\n        # return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = {}\n        def recursion(S):\n            if S == 0:\n                return 0\n            if S<0:\n                return float('inf')\n            \n            if S in dp:\n                return dp[S]\n            \n            x = float('inf')\n            for coin in coins:\n                x = min(x, 1 + recursion(S-coin))\n            \n            dp[S] = x\n            return x\n        \n        res = recursion(amount)\n        if res == float('inf'):\n            return -1\n        \n        return res\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # Bottom up approach from video.\n        l = [amount+1]*(amount+1)\n\n        for i in range(len(l)):\n            if(i==0):\n                l[i] = 0\n            elif(all(i<c for c in coins)):\n                l[i]=-1\n            else:\n                for j in range(len(coins)):\n                    if(i>=coins[j]):\n                        num = i-coins[j]\n                        if(num>0 and l[num]==-1):\n                            if(l[i]!=amount+1):\n                                continue\n                            else:\n                                l[i] = -1\n                        else:\n                            comb = l[num] + 1\n                            if(l[i]==-1):\n                                l[i]=amount+1\n                            if(l[i]>=comb):\n                                l[i] = comb  \n                            \n        return l[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[float('inf')] * (amount + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 0\n        \n        for i in range(1, n + 1):\n            for j in range(1, amount + 1):\n                dp[i][j] = min(dp[i-1][j], (dp[i][j-coins[i-1]] if j >= coins[i-1] else float('inf')) + 1)\n        return dp[-1][-1] if dp[-1][-1] < float('inf') else -1\n        # @lru_cache(None)\n        # def dfs(amt, idx):\n        #     # print(amt, idx)\n        #     if idx < 0:\n        #         if amt == 0:\n        #             return 0\n        #         else:\n        #             return float('inf')\n        #     if amt < 0:\n        #         return float('inf')\n        #     if amt == coins[idx]:\n        #         return 1\n        #     return min(dfs(amt - coins[idx], idx) + 1, dfs(amt, idx - 1))\n        # res = dfs(amount, len(coins)-1)\n        # return res if res < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins_sorted = list(sorted(coins, reverse=True))\n        memo = {}\n        \n        def choose(amount):\n            if amount in memo:\n                return memo[amount]\n            if amount < 0:\n                return -1\n            if amount == 0:\n                return 0\n            memo[amount] = -1\n            for c in coins_sorted:\n                if (ret:=choose(amount - c)) >= 0:\n                    if memo[amount] != -1:\n                        memo[amount] = min(memo[amount], ret+1)\n                    else:\n                        memo[amount] = ret + 1\n            return memo[amount]\n        \n        return choose(amount)", "class Solution:\n    IMPOSSIBLE = -1\n    \n    def computeMinCoins(self, n: int) -> int:\n        if n in self.memoization:\n            return self.memoization.get(n)\n        if n == 0:\n            result = 0\n        else:\n            result = Solution.IMPOSSIBLE\n            for coin in self.coins:\n                if coin > n:\n                    continue\n                coins_extra = self.computeMinCoins(n - coin)\n                if coins_extra == Solution.IMPOSSIBLE:\n                    continue\n                plausible_result = 1 + coins_extra\n                if result == Solution.IMPOSSIBLE or result > plausible_result:\n                    result = plausible_result\n        self.memoization[n] = result\n        return result\n            \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        if amount % coins[0] == 0:\n            return amount // coins[0]\n        self.coins = coins\n        self.memoization = {}\n        return self.computeMinCoins(amount)\n", "import math\nfrom functools import lru_cache \n\nclass Solution:\n\n       \n    \n    ### Iterative DFS\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        \n        stack = [(0,0)]  # sum, coinCount\n        answer = math.inf\n        \n        # !! n.b, sorting small->big so stack processing searches largest first\n        sortedCoins = sorted(coins) \n        # !! n.b. prune search tree to prevent re-searching same sums\n        visited = set()\n        \n        while stack:\n            node = stack.pop()\n            (sum, coinCount) = node\n            \n            if node in visited:\n                pass\n            elif coinCount >= answer:\n                pass\n            elif sum == amount:\n                answer = min(answer,coinCount)\n            elif sum > amount:\n                pass\n            else:\n                for c in sortedCoins:\n                    if ( \n                        (sum+c) <= amount and\n                        # !! n.b. ensure still possible to beat best answer \n                        # !! with this coin\n                        amount < (sum + (c*(answer-coinCount)))\n                    ):\n                        stack.append((sum+c, coinCount+1))\n                        \n            visited.add(node)\n                \n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n    \n    \n    \n#     ### Iterative DFS.  Brute force won't finish on large trees\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         stack = [(0,0)]    # (sum, count)\n#         # visited = set()\n#         answer = math.inf\n        \n#         while stack:\n#             node = stack.pop()\n#             # print(node)\n            \n#             if node[0] == amount:\n#                 answer = min(answer, node[1])\n#             elif node[0] > amount:\n#                 pass\n#             else:\n#                 for coin in coins:\n#                     stack.append( (node[0]+coin, node[1]+1)  )\n                    \n#         if answer == math.inf:\n#             return -1\n#         else:\n#             return answer\n        \n        \n#     ### Recursive DFS with memoization\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n\n#         @lru_cache(maxsize=None)\n#         def dfs(remainder):\n#             if remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 return 0\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, dfs(remainder - coin) + 1)\n#                 return least\n        \n#         res = dfs(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#         def backtrack(remainder):\n#             # print(remainder)\n#             if remainder in memo:\n#                 return memo[remainder]\n#             elif remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 memo[remainder] = 0\n#                 return memo[remainder]\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, backtrack(remainder - coin) + 1)\n#                 memo[remainder] = least\n#                 return memo[remainder]    \n        \n#         memo = collections.defaultdict(int)\n#         res = backtrack(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n        \n        \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not coins or amount < 0:\n#             return -1\n        \n#         @lru_cache(maxsize=None)\n#         def dfs(sum, count):\n#             # print(\\\"sum:{}, count:{}\\\".format(sum, count))\n#             if count >= self.ans:\n#                 return\n#             elif sum == amount:\n#                 self.ans = min(self.ans, count)\n#                 return\n#             elif sum > amount:\n#                 return\n#             else:\n#                 for c in sortedCoins:\n#                     dfs(sum+c, count+1)\n                    \n#         sortedCoins = sorted(coins, reverse=True)\n#         self.ans = math.inf\n#         dfs(0,0)\n#         if self.ans == math.inf:\n#             return -1\n#         else:\n#             return self.ans\n        \n    \n#     ### BFS\n#     def coinChange(self, coins: List[int], amount: int) -> int:  \n#         if not coins or amount < 0:\n#             return -1\n        \n#         visited = [False]*(amount+1)\n#         parentNodes = [0]\n#         level = -1\n        \n#         while parentNodes:\n#             level += 1\n#             childNodes = []\n#             for node in parentNodes:\n#                 if visited[node]:\n#                     pass\n#                 elif node == amount:\n#                     return level\n#                 elif node > amount:\n#                     pass\n#                 else:\n#                     for c in coins:\n#                         if node+c <= amount:\n#                             childNodes.append(node+c)\n#                 visited[node] = True      \n                \n#             parentNodes = childNodes\n            \n#         return -1\n\n    \n#     ### Dynamic programming\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         maxint = math.inf\n        \n#         # one slot for each amount, up to amount. \n#         dp = [0] + [maxint]*amount\n        \n#         for i in range(1,amount+1):\n#             dp[i] = min([(1+dp[i-c]) for c in coins if i>=c] + [maxint])\n            \n#         if dp[amount] == math.inf:\n#             return -1\n#         else:\n#             return dp[amount]\n        \n    \n### Recursive w/memoization    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         sortedCoins = sorted(coins, reverse=True)\n#         result = self.recurse(amount, tuple(sortedCoins))\n        \n#         if result == math.inf:\n#             result = -1\n        \n#         return result\n        \n#     @lru_cache(maxsize=None)\n#     def recurse(self, amount: int, coins: tuple) -> int:\n#         # print(amount)\n#         if amount < 0:\n#             return math.inf\n#         elif amount == 0:\n#             return 0\n#         else:\n#             least = math.inf\n#             for c in coins:\n#                 val = self.recurse(amount-c, coins)\n#                 if val < math.inf:\n#                     # print('{} = {}'.format(amount-c, val))\n#                     least = min(least, val)\n#             return least + 1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        cache = dict()\n        def recursiveChange(amount):\n            if amount == 0:\n                return 0\n            if amount < 0:\n                return -1\n            if amount in cache:\n                return cache[amount]\n            \n            min_val = float('inf')\n            for coin_val in coins:\n                combination = recursiveChange(amount - coin_val)\n                if combination != -1:\n                    min_val = min(min_val, combination + 1)\n            cache[amount] = min_val\n            return min_val\n        \n        ans = recursiveChange(amount)\n        if ans == float('inf'):\n            return -1\n        return ans", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        use dp 0 - 11\n        '''\n        if amount == 0:\n            return 0\n        \n        dp = [None] * amount\n        dp[0] = 1 if 1 in coins else -1\n        \n        for i in range(1, amount):\n            min_req = float('inf')\n            \n            for c in coins:\n                if (i + 1) % c == 0:\n                    min_req = min(min_req, (i + 1) // c)\n                elif (i + 1) // c > 0 and dp[i - c] != -1:\n                    min_req = min(min_req, dp[i - c] + 1)\n            \n            if min_req == float('inf'):\n                dp[i] = -1\n            else:\n                dp[i] = min_req\n        \n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def helper(coins, amount, dp):\n            if amount < 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if amount in dp:\n                return dp[amount]\n            ans = []\n            for i in range(len(coins)):\n                use_ci = 1 + helper(coins, amount - coins[i], dp)\n                ans.append(use_ci)\n                \n            dp[amount] = min(ans)\n \n            return dp[amount]\n        \n        if amount <= 0:\n            return 0\n        dp = {}\n        result = helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n    \n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        \n        # self.coins = coins\n        self.coins = sorted(coins, reverse=True)\n        \n        self.count = {}\n        \n        return self.helper(amount)\n    \n    def helper(self, rem):\n        # print(rem)\n        if rem < 0:\n            return -1\n        if rem == 0:\n            return 0\n        \n        if rem in self.count:\n            return self.count[rem]\n        \n        min_count = 1000000000\n        for coin in self.coins:\n            # print(\\\"coin: {}\\\".format(coin))\n            res = self.helper(rem - coin)\n            if res >= 0 and res < min_count:\n                min_count = res + 1\n            \n            if min_count == 1000000000:\n                self.count[rem] = -1\n            else:\n                self.count[rem] = min_count\n                \n            \n        return self.count[rem]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = [0] * (amount+1)\n        return self.dfs(coins, amount, memo)\n    \n    def dfs(self, coins: List[int], amount: int, memo: List[int]) -> int:\n        if amount == 0:\n            return 0\n        \n        if amount < 0:\n            return -1\n        \n        if memo[amount] != 0:\n            return memo[amount]\n        \n        minCoins = math.inf\n        for coin in coins:\n            res = self.dfs(coins, amount - coin, memo) + 1\n            \n            if res > 0:\n                minCoins = min(minCoins, res)\n        \n        memo[amount] = minCoins if minCoins < math.inf else -1\n        \n        return minCoins if minCoins < math.inf else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        \n        # self.coins = coins\n        self.coins = sorted(coins, reverse=True)\n        \n        self.count = {}\n        self.finalcount = 0\n        \n        return self.helper(amount)\n    \n    def helper(self, rem):\n        # print(rem)\n        if rem < 0:\n            return -1\n        if rem == 0:\n            return 0\n        \n        if rem in self.count:\n            return self.count[rem]\n        \n        min_count = 1000000000\n        for coin in self.coins:\n            # print(\\\"coin: {}\\\".format(coin))\n            res = self.helper(rem - coin)\n            if res >= 0 and res < min_count:\n                min_count = res + 1\n            \n            if min_count == 1000000000:\n                self.count[rem] = -1\n            else:\n                self.count[rem] = min_count\n                \n            \n        return self.count[rem]\n", "import math\nfrom functools import lru_cache \n\nclass Solution:\n\n       \n    \n    ### Iterative DFS, with optimizations.  very fast\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        \n        stack = [(0,0)]  # sum, coinCount\n        answer = math.inf\n        \n        # !! n.b, sorting small->big so stack processing searches largest first\n        sortedCoins = sorted(coins) \n        # !! n.b. prune search tree to prevent re-searching same sums\n        visited = set()\n        \n        while stack:\n            (sum, coinCount) = stack.pop()\n            # print('sum:{}, coinCount:{}, answer:{}'.format(sum, coinCount, answer))\n            \n            if (sum, coinCount) in visited:\n                pass\n            elif coinCount >= answer:\n                pass\n            elif sum == amount:\n                answer = min(answer,coinCount)\n            elif sum > amount:\n                pass\n            else:\n                \n                \n                for c in sortedCoins:\n                    if ( \n                        (sum+c) <= amount and\n                        # !! n.b. ensure still possible to beat best answer \n                        # !! with this coin\n                        amount < (sum + (c*(answer-coinCount)))\n                    ):\n                        stack.append((sum+c, coinCount+1))\n                        \n            visited.add((sum, coinCount))\n                \n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n    \n    \n    \n#     ### Iterative DFS.  Brute force won't finish on large trees\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         stack = [(0,0)]    # (sum, count)\n#         # visited = set()\n#         answer = math.inf\n        \n#         while stack:\n#             node = stack.pop()\n#             # print(node)\n            \n#             if node[0] == amount:\n#                 answer = min(answer, node[1])\n#             elif node[0] > amount:\n#                 pass\n#             else:\n#                 for coin in coins:\n#                     stack.append( (node[0]+coin, node[1]+1)  )\n                    \n#         if answer == math.inf:\n#             return -1\n#         else:\n#             return answer\n        \n        \n#     ### Recursive DFS with memoization\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n\n#         @lru_cache(maxsize=None)\n#         def dfs(remainder):\n#             if remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 return 0\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, dfs(remainder - coin) + 1)\n#                 return least\n        \n#         res = dfs(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#         def backtrack(remainder):\n#             # print(remainder)\n#             if remainder in memo:\n#                 return memo[remainder]\n#             elif remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 memo[remainder] = 0\n#                 return memo[remainder]\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, backtrack(remainder - coin) + 1)\n#                 memo[remainder] = least\n#                 return memo[remainder]    \n        \n#         memo = collections.defaultdict(int)\n#         res = backtrack(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n        \n        \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not coins or amount < 0:\n#             return -1\n        \n#         @lru_cache(maxsize=None)\n#         def dfs(sum, count):\n#             # print(\\\"sum:{}, count:{}\\\".format(sum, count))\n#             if count >= self.ans:\n#                 return\n#             elif sum == amount:\n#                 self.ans = min(self.ans, count)\n#                 return\n#             elif sum > amount:\n#                 return\n#             else:\n#                 for c in sortedCoins:\n#                     dfs(sum+c, count+1)\n                    \n#         sortedCoins = sorted(coins, reverse=True)\n#         self.ans = math.inf\n#         dfs(0,0)\n#         if self.ans == math.inf:\n#             return -1\n#         else:\n#             return self.ans\n        \n    \n#     ### BFS\n#     def coinChange(self, coins: List[int], amount: int) -> int:  \n#         if not coins or amount < 0:\n#             return -1\n        \n#         visited = [False]*(amount+1)\n#         parentNodes = [0]\n#         level = -1\n        \n#         while parentNodes:\n#             level += 1\n#             childNodes = []\n#             for node in parentNodes:\n#                 if visited[node]:\n#                     pass\n#                 elif node == amount:\n#                     return level\n#                 elif node > amount:\n#                     pass\n#                 else:\n#                     for c in coins:\n#                         if node+c <= amount:\n#                             childNodes.append(node+c)\n#                 visited[node] = True      \n                \n#             parentNodes = childNodes\n            \n#         return -1\n\n    \n#     ### Dynamic programming\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         maxint = math.inf\n        \n#         # one slot for each amount, up to amount. \n#         dp = [0] + [maxint]*amount\n        \n#         for i in range(1,amount+1):\n#             dp[i] = min([(1+dp[i-c]) for c in coins if i>=c] + [maxint])\n            \n#         if dp[amount] == math.inf:\n#             return -1\n#         else:\n#             return dp[amount]\n        \n    \n### Recursive w/memoization    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         sortedCoins = sorted(coins, reverse=True)\n#         result = self.recurse(amount, tuple(sortedCoins))\n        \n#         if result == math.inf:\n#             result = -1\n        \n#         return result\n        \n#     @lru_cache(maxsize=None)\n#     def recurse(self, amount: int, coins: tuple) -> int:\n#         # print(amount)\n#         if amount < 0:\n#             return math.inf\n#         elif amount == 0:\n#             return 0\n#         else:\n#             least = math.inf\n#             for c in coins:\n#                 val = self.recurse(amount-c, coins)\n#                 if val < math.inf:\n#                     # print('{} = {}'.format(amount-c, val))\n#                     least = min(least, val)\n#             return least + 1\n                \n", "import sys\n\nclass Solution:\n    def helper(self, coin_sum, coins, memo):\n        if coin_sum == 0:\n            return 0\n        if coin_sum < 0:\n            return sys.maxsize\n\n        if memo[coin_sum - 1] != 0:\n            return memo[coin_sum - 1]\n\n        res = sys.maxsize\n        for c in coins:\n            res = min(res, self.helper(coin_sum - c, coins, memo) + 1)\n\n        memo[coin_sum - 1] = res\n        return res\n\n\n    def coinChange(self, coins, amount):\n        memo = [0] * amount\n        res = self.helper(amount, coins, memo)\n        return -1 if res == sys.maxsize else res", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [None for _ in range(amount+1)]\n        \n        def fewest_num(amount, dp):\n            if dp[amount] is not None:\n                return dp[amount]\n            if amount == 0:\n                min_num = 0\n            elif amount < min(coins):\n                min_num = float('inf')  # use float('inf') as indicator here\n            elif amount in set(coins):\n                min_num = 1\n            else:\n                min_num = float('inf')\n                for coin in coins:\n                    if amount-coin >= 0:\n                        num = fewest_num(amount-coin, dp)\n                        min_num = min(min_num, num)\n                min_num += 1\n            \n            dp[amount] = min_num\n            return min_num\n        \n        min_num = fewest_num(amount, dp)\n        if min_num == float('inf'):\n            return -1\n        return min_num\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        \n        # self.coins = coins\n        self.coins = coins\n        \n        self.count = {}\n        \n        return self.helper(amount)\n    \n    def helper(self, rem):\n        # print(rem)\n        if rem < 0:\n            return -1\n        if rem == 0:\n            return 0\n        \n        if rem in self.count:\n            return self.count[rem]\n        \n        min_count = 1000000000\n        for coin in self.coins:\n            # print(\\\"coin: {}\\\".format(coin))\n            res = self.helper(rem - coin)\n            if res >= 0 and res < min_count:\n                min_count = res + 1\n            \n            if min_count == 1000000000:\n                self.count[rem] = -1\n            else:\n                self.count[rem] = min_count\n                \n            \n        return self.count[rem]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n                \n        self.memo = {0: 0}\n        \n        coins.sort()\n    \n        self.getMinCoins(coins, amount)\n        \n        if self.memo[amount] == float('inf'):\n            \n            return(-1)\n        \n        return(self.memo[amount])\n    \n    def getMinCoins(self, coins, amount):\n        \n        \n        if amount in self.memo:\n            \n            return(self.memo[amount])\n        \n        minCoins = float('inf')\n        \n        for coin in coins:\n            \n            if amount - coin < 0:\n                \n                break\n                \n            currCoins = self.getMinCoins(coins, amount - coin) + 1\n            minCoins = min(minCoins, currCoins)\n            \n        self.memo[amount] = minCoins\n        \n        return(self.memo[amount])\n        \n        \n#         numCoins = len(coins)\n        \n#         # Values in this array equal the number of coins needed to achieve the cost of the index\n#         minCoins = [amount + 1] * (amount + 1)\n#         minCoins[0] = 0\n        \n#         # Loop through every needed amount\n#         for i in range(amount + 1):\n#             # Loop through every coin value\n#             for coin in coins:\n#                 # Check that the coin is not bigger than the current amount\n#                 if coin <= i:\n#                     # minCoins[i]: number of coins needed to make amount i\n#                     # minCoins[i-coin]: number of coins needed to make the amount before adding \n#                     #                   the current coin to it (+1 to add the current coin)\n#                     minCoins[i] = min(minCoins[i], minCoins[i-coin] + 1)\n        \n#         # Check if any combination of coins was found to create the amount\n#         if minCoins[amount] == amount + 1:\n#             return -1\n        \n#         # Return the optimal number of coins to create the amount\n#         return minCoins[amount]\n", "class Solution:\n    \n    def helper(self, amount: int) -> int:\n        \n        if amount in list(self.cache.keys()):\n            #print(amount, self.cache[amount], \\\"found\\\")\n            return self.cache[amount]\n        \n        counts = []\n        for coin in self.coins:\n            if amount - coin > 0: \n                counts.append(self.helper(amount-coin)+1)\n            elif amount - coin == 0:\n                counts.append(1)\n                break\n                \n        if counts == []:\n            self.cache[amount] = sys.maxsize\n        else:\n            self.cache[amount] = min(counts)\n            \n        #print(amount, self.cache[amount], \\\"inserted\\\")\n        return self.cache[amount]\n                \n            \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coins = coins\n        \n        if amount == 0:\n            return 0\n        \n        self.cache = {}\n        res = self.helper(amount)\n        return res if res < 100000000 else -1\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # i = coin index\n        # c[i] = coin cost\n        # f(0,0) = 0\n        # f(coin, amount) = minimum number of coins needed to pay amount\n        # f(i, j) = min( f(i-1, j), f(i, j-c[i]) + 1)\n        \n        dp = []\n\n        for j in range(amount + 1):\n            dp.append(amount + 1)\n\n        \n        dp[0] = 0\n        \n        \n        for i in range (len(coins)):\n            coin = coins[i]\n            for j in range(1, amount + 1):\n                sameCoin = float('inf')\n                if j - coin >= 0:\n                    sameCoin = dp[j-coin]\n                \n                dp[j] = min(sameCoin +1, dp[j])\n        \n        return dp[j] if dp[j] != amount + 1 else -1", "import sys\n\nclass Solution:\n    def helper(self, coin_sum, coins, memo):\n        if coin_sum == 0:\n            return 0\n        if coin_sum < 0:\n            return sys.maxsize\n\n        if memo[coin_sum - 1] != 0:\n            return memo[coin_sum - 1]\n\n        res = sys.maxsize\n        for c in coins:\n            res = min(res, self.helper(coin_sum - c, coins, memo) + 1)\n\n        memo[coin_sum - 1] = res\n        return res\n\n\n    def coinChange(self, coins, amount):\n        memo = [0] * amount\n        res = self.helper(amount, coins, memo)\n        return -1 if res == sys.maxsize else res\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        value=[-1]*(amount+1)\n        value[0]=0\n        \n        for j in range(amount+1):\n            for i in range(len(coins)):\n                if j>coins[i]:\n                    if value[j-coins[i]]!=-1:\n                        if value[j]==-1:\n                            value[j]=value[j-coins[i]]+1\n                        else:\n                            value[j]=min(value[j],value[j-coins[i]]+1)\n                if j==coins[i]:\n                    value[j]=1\n        print(value)\n        return value[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        d={}\n        ans=self.helper(coins,amount,d)\n        if ans==100000000:\n            return -1\n        return ans\n    def helper(self,coins,amount,d):\n        if amount==0:\n            return 0\n        ans=100000000\n        for i in range(len(coins)-1,-1,-1):\n            if coins[i]<=amount:\n                if amount-coins[i] in d:\n                    sub_ans=d[amount-coins[i]]\n                else:\n                    sub_ans=1+self.helper(coins,amount-coins[i],d)\n                    d[amount-coins[i]]=sub_ans\n                ans=min(ans,sub_ans)\n        return ans\n", "import math\nfrom functools import lru_cache \n\nclass Solution:\n\n       \n    \n    ### Iterative DFS\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        \n        stack = [(0,0)]  # sum, coinCount\n        sortedCoins = sorted(coins, reverse=False)\n        answer = math.inf\n        visited = set()\n        \n        while stack:\n            # print(sorted(stack, reverse=True))\n            (sum, coinCount) = stack.pop()\n            \n            if (sum, coinCount) in visited:\n                pass\n            elif coinCount >= answer:\n                pass\n            elif sum == amount:\n                answer = min(answer,coinCount)\n            elif sum > amount:\n                pass\n            else:\n                for c in sortedCoins:\n                    if ( \n                        (sum+c) <= amount < (sum + (c*(answer-coinCount)))\n                    ):\n                        stack.append((sum+c, coinCount+1))\n                        \n            visited.add((sum, coinCount))\n                \n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n    \n    \n    \n#     ### Iterative DFS.  Brute force won't finish on large trees\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         stack = [(0,0)]    # (sum, count)\n#         # visited = set()\n#         answer = math.inf\n        \n#         while stack:\n#             node = stack.pop()\n#             # print(node)\n            \n#             if node[0] == amount:\n#                 answer = min(answer, node[1])\n#             elif node[0] > amount:\n#                 pass\n#             else:\n#                 for coin in coins:\n#                     stack.append( (node[0]+coin, node[1]+1)  )\n                    \n#         if answer == math.inf:\n#             return -1\n#         else:\n#             return answer\n        \n        \n#     ### Recursive DFS with memoization\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n\n#         @lru_cache(maxsize=None)\n#         def dfs(remainder):\n#             if remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 return 0\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, dfs(remainder - coin) + 1)\n#                 return least\n        \n#         res = dfs(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#         def backtrack(remainder):\n#             # print(remainder)\n#             if remainder in memo:\n#                 return memo[remainder]\n#             elif remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 memo[remainder] = 0\n#                 return memo[remainder]\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, backtrack(remainder - coin) + 1)\n#                 memo[remainder] = least\n#                 return memo[remainder]    \n        \n#         memo = collections.defaultdict(int)\n#         res = backtrack(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n        \n        \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not coins or amount < 0:\n#             return -1\n        \n#         @lru_cache(maxsize=None)\n#         def dfs(sum, count):\n#             # print(\\\"sum:{}, count:{}\\\".format(sum, count))\n#             if count >= self.ans:\n#                 return\n#             elif sum == amount:\n#                 self.ans = min(self.ans, count)\n#                 return\n#             elif sum > amount:\n#                 return\n#             else:\n#                 for c in sortedCoins:\n#                     dfs(sum+c, count+1)\n                    \n#         sortedCoins = sorted(coins, reverse=True)\n#         self.ans = math.inf\n#         dfs(0,0)\n#         if self.ans == math.inf:\n#             return -1\n#         else:\n#             return self.ans\n        \n    \n#     ### BFS\n#     def coinChange(self, coins: List[int], amount: int) -> int:  \n#         if not coins or amount < 0:\n#             return -1\n        \n#         visited = [False]*(amount+1)\n#         parentNodes = [0]\n#         level = -1\n        \n#         while parentNodes:\n#             level += 1\n#             childNodes = []\n#             for node in parentNodes:\n#                 if visited[node]:\n#                     pass\n#                 elif node == amount:\n#                     return level\n#                 elif node > amount:\n#                     pass\n#                 else:\n#                     for c in coins:\n#                         if node+c <= amount:\n#                             childNodes.append(node+c)\n#                 visited[node] = True      \n                \n#             parentNodes = childNodes\n            \n#         return -1\n\n    \n#     ### Dynamic programming\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         maxint = math.inf\n        \n#         # one slot for each amount, up to amount. \n#         dp = [0] + [maxint]*amount\n        \n#         for i in range(1,amount+1):\n#             dp[i] = min([(1+dp[i-c]) for c in coins if i>=c] + [maxint])\n            \n#         if dp[amount] == math.inf:\n#             return -1\n#         else:\n#             return dp[amount]\n        \n    \n### Recursive w/memoization    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         sortedCoins = sorted(coins, reverse=True)\n#         result = self.recurse(amount, tuple(sortedCoins))\n        \n#         if result == math.inf:\n#             result = -1\n        \n#         return result\n        \n#     @lru_cache(maxsize=None)\n#     def recurse(self, amount: int, coins: tuple) -> int:\n#         # print(amount)\n#         if amount < 0:\n#             return math.inf\n#         elif amount == 0:\n#             return 0\n#         else:\n#             least = math.inf\n#             for c in coins:\n#                 val = self.recurse(amount-c, coins)\n#                 if val < math.inf:\n#                     # print('{} = {}'.format(amount-c, val))\n#                     least = min(least, val)\n#             return least + 1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        coins.sort(reverse=True)\n        memo = {}\n        def dfs(step, rest_amount):\n            if rest_amount < 0:\n                return -1\n            if rest_amount == 0:\n                return 0 \n            \n            if rest_amount in memo:\n                return memo[rest_amount]\n            min_steps = math.inf\n            for coin in coins:\n                rest = rest_amount - coin\n                #print(c, rest, step)\n                res =  dfs(step+1, rest)\n                if res >= 0:\n                    min_steps = min(min_steps, res)\n            \n            \n            memo[rest_amount] = min_steps + 1 if min_steps != math.inf else -1\n            return memo[rest_amount]\n                \n                \n        \n        res = dfs(0, amount)\n        return res\n            \n", "class Solution:   \n    def coinChange2(self, coins: List[int], amount: int, count) -> int:\n        if amount < 0:\n            return -1\n        \n        if amount == 0:\n            return 0\n        \n        if(count[amount-1] != 0):\n            return count[amount-1]\n        \n        min = 100000000000\n        for i, c in enumerate(sorted(coins)[::-1]):\n            ret = self.coinChange2(coins, amount-c, count)\n            if(ret>=0 and ret<min):\n                min = 1+ret\n        if(min==100000000000):\n            count[amount-1] = -1\n        else:\n            count[amount-1] = min\n\n        return count[amount-1]\n    \n    def coinChange(self, coins:List[int], amount: int) -> int:\n        if(amount < 1):\n            return 0\n        return self.coinChange2(coins, amount, [0]*amount)", "class Solution(object):\n    def __init__(self):\n        self.mem = {0: 0}\n        \n    def getMinCoins(self, coins, amount):\n        if amount in self.mem:\n            return self.mem[amount]\n        minCoins = float('inf')\n        for c in coins:\n            if amount - c <  0:\n                break\n            numCoins = self.getMinCoins(coins, amount - c) + 1\n            minCoins = min(numCoins, minCoins)\n        \n        self.mem[amount] = minCoins\n        return minCoins\n    \n    def coinChange(self, coins, amount):\n        minCoins = self.getMinCoins(sorted(coins), amount)\n        if minCoins == float('inf'):\n            return -1\n        return minCoins\n        \n", "class Solution:\n    \n    def helper(self, amount: int) -> int:\n        \n        if amount in list(self.cache.keys()):\n            #print(amount, self.cache[amount], \\\"found\\\")\n            return self.cache[amount]\n        \n        counts = []\n        for coin in self.coins:\n            if amount - coin > 0: \n                counts.append(self.helper(amount-coin)+1)\n            elif amount - coin == 0:\n                counts.append(1)\n                break\n                \n        if counts == []:\n            self.cache[amount] = 100000000\n        else:\n            self.cache[amount] = min(counts)\n            \n        #print(amount, self.cache[amount], \\\"inserted\\\")\n        return self.cache[amount]\n                \n            \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coins = coins\n        \n        if amount == 0:\n            return 0\n        \n        self.cache = {}\n        res = self.helper(amount)\n        return res if res < 100000000 else -1\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = dict()\n\n        def recurse(amount, index):\n            if (amount == 0):\n                return 0\n\n            if (amount in memo):\n                return memo[amount]\n\n            minCoins = float('inf')\n            \n            for coin in coins:\n                if (amount - coin >= 0):\n                    response = recurse(amount-coin, 0)\n                    \n                    if (response != -1):\n                        minCoins = min(minCoins, response+1)\n            \n            memo[amount] = minCoins if minCoins != float('inf') else -1\n            return memo[amount]\n        \n        return recurse(amount, 0)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # i = coin index\n        # c[i] = coin cost\n        # f(0,0) = 0\n        # f(coin, amount) = minimum number of coins needed to pay amount\n        # f(i, j) = min( f(i-1, j), f(i, j-c[i]) + 1)\n        \n        dp = []\n\n        for j in range(amount + 1):\n            dp.append(float('inf'))\n\n        \n        dp[0] = 0\n        \n        \n        for i in range (len(coins)):\n            coin = coins[i]\n            for j in range(1, amount + 1):\n                sameCoin = float('inf')\n                if j - coin >= 0:\n                    sameCoin = dp[j-coin]\n                \n                dp[j] = min(sameCoin +1, dp[j])\n        \n        return dp[j] if dp[j] != float('inf') else -1", "class Solution:\n      def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        min_coins = float('inf')\n\n        def count_coins(start_coin, coin_count, remaining_amount):\n          nonlocal min_coins\n\n          if remaining_amount == 0:\n            min_coins = min(min_coins, coin_count)\n            return\n\n          # Iterate from largest coins to smallest coins\n          for i in range(start_coin, len(coins)):\n            remaining_coin_allowance = min_coins - coin_count\n            max_amount_possible = coins[i] * remaining_coin_allowance\n\n            if coins[i] <= remaining_amount and remaining_amount < max_amount_possible:\n              count_coins(i, coin_count + 1, remaining_amount - coins[i])\n\n        count_coins(0, 0, amount)\n        return min_coins if min_coins < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        f = [float('inf') for i in range(amount + 1)]\n        \n        f[0] = 0\n        \n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i - coin >= 0 and f[i - coin] != float('inf'):\n                    f[i] = min(f[i], f[i - coin] + 1)\n                    \n        if f[-1] == float('inf'):\n            return -1\n        \n        return f[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        memo = {}\n        def backtrack(memo, curr = amount,):\n            if curr == 0:\n                return 0\n            if memo.get(curr):\n                return memo[curr]\n            minimum = math.inf\n            for coin in coins:\n                if curr - coin < 0:\n                    continue\n                res = backtrack(memo, curr-coin)\n                minimum = min(res, minimum)\n            minimum = minimum if minimum == math.inf else minimum + 1\n            memo[curr] = minimum\n            return minimum\n        ans = backtrack(memo)\n        if ans == math.inf:\n            return -1\n        return ans\n", "\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        cache = {}\n        #reverse the order \n        coins = sorted(coins, reverse = True)\n        \n#         def recurse(amt, coins, currnumcoins):\n   \n#             if amt in cache:\n#                 return cache[amt]\n            \n#             cache[amt] =  float('inf')\n#             # base case\n#             for coin in coins:\n#                 if (amt - coin) == 0 :\n#                     return currnumcoins + 1\n                \n#                 elif (amt - coin) > 0:\n#                     cache[amt] =  min(recurse(amt-coin, coins, currnumcoins + 1), cache[amt])\n            \n#             return cache[amt]\n\n        def helper( coins, amount, cache):\n            if amount == 0:\n                return 0\n            elif amount in cache:\n                return cache[amount]\n            cache[amount] = float('inf')\n            for c in coins:\n                if amount - c >= 0:\n                    cache[amount] = min(cache[amount], helper(coins, amount-c, cache) + 1)\n            return cache[amount]\n                               \n        \n        if amount == 0:\n            return 0\n            \n        if min(coins) > amount:\n            return -1\n        \n        # ans = recurse(amount, coins, 0)\n        ans = helper(coins, amount, {})\n        \n        return ans if ans != float('inf') else -1", "class Solution:\n    \n    def helper(self, coins, amount, total, count, mem):\n                \n        if total > amount:\n            return\n        \n        if total == amount:\n            if total not in mem:\n                mem[total] = count\n            else:\n                mem[total] = min(mem[total], count)\n            return\n        \n        for c in coins:\n            if total + c not in mem or mem[total+c] > count + 1:\n                mem[total+c] = count + 1\n                self.helper(coins, amount, total+c, count+1, mem)\n                \n        return\n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if not amount:\n            return 0\n        \n        if amount < min(coins):\n            return -1\n        \n        mem = {}\n        coins.sort(reverse=True)\n        self.helper(coins, amount, 0, 0, mem)\n        \n        if amount in mem:\n            return mem[amount]\n        else:\n            return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        similar to knapsack problem, except we want minimum coins instead of max items\n        \n        \n        dp: increase coins and amount one at a time\n        \n           ''   1.   2.   5\n        0  0.   0.   0.   0\n        1  -1   1    1    1\n        2  -1   2    1    1 \n        3  -1   3.   2.   2\n        4  -1   4.   2.   2\n        5  -1   5.   3.   1\n        6  -1   6.   3.   2\n        7  -1   7.   4.   2\n        8  -1   8.   4.   3\n        9  -1   9.   5.   3\n        10 -1   10.  5.   2\n        11 -1   11.  6.   3\n        \n        fewest_coins[amount][coins_i + 1] = min of (1 + fewest_coins[amount-coins[j]][coins_i]) for j in range(coins_i+1) or -1 if all the fewest_coins[amount-coins[j]][coins_i] are -1\n        \n        how to effectively start dp array?\n        \n        '''\n        \n        fewest_coins = [0 for j in range(amount+1)]\n        \n        for j in range(1,amount+1):\n            fewest_coins[j] = float('inf')\n            for coin_i in range(len(coins)):\n                if coins[coin_i] == j:\n                    fewest_coins[j] = 1\n                    break\n                elif coins[coin_i] < j:\n                    if fewest_coins[j-coins[coin_i]] > 0:\n                        fewest_coins[j] = min(fewest_coins[j], fewest_coins[j-coins[coin_i]]+1)\n            if fewest_coins[j] == float('inf'):\n                fewest_coins[j] = -1\n                    \n        return fewest_coins[-1]\n#         fewest_coins = [0 for j in range(amount+1)]\n        \n#         for j in range(1,amount+1):\n#             fewest_coins[j] = float('inf')\n#             for coin_i in range(len(coins)):\n#                 if coins[coin_i] == j:\n#                     fewest_coins[j] = 1\n#                     break\n#                 elif coins[coin_i] < j:\n#                     if fewest_coins[j-coins[coin_i]] > 0:\n#                         fewest_coins[j] = min(fewest_coins[j], fewest_coins[j-coins[coin_i]]+1)\n#             if fewest_coins[j] == float('inf'):\n#                 fewest_coins[j] = -1\n                    \n#         return fewest_coins[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        M = [[0 for j in range(amount + 1)] for i in range(len(coins) + 1)]\n        \n        for j in range(1, amount + 1):\n            M[0][j] = 1000000\n        \n        for i in range(1, len(coins) + 1):\n            for j in range(1, amount + 1):\n                if j >= coins[i-1]:\n                    M[i][j] = min(1 + M[i][j - coins[i-1]], M[i-1][j])\n                else:\n                    M[i][j] = M[i-1][j]\n                    \n        return M[-1][-1] if M[-1][-1] < 1000000 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        matrix =[[0 for i in range(amount+1)] for j in range(len(coins)+1)]\n        \n        for i in range(len(matrix)):\n            matrix[i][0] = 0\n        for i in range(1,amount+1):\n            matrix[0][i] = sys.maxsize\n            \n        \n        \n        for i in range(1,len(matrix)):\n            for j in range(len(matrix[0])):\n                if j<coins[i-1]:\n                    matrix[i][j] = matrix[i-1][j]\n                else:\n                    matrix[i][j] = min(matrix[i-1][j],1+matrix[i][j-coins[i-1]])\n        #print (matrix)            \n        if matrix[-1][-1] == sys.maxsize:\n            return -1\n        return matrix[-1][-1]\n        \n        \n        \n        \n", "class Solution:\n    def __init__(self):\n        self.counts = {}\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 0:\n            return -1\n        if amount == 0:\n            return 0\n        if amount in self.counts:\n            return self.counts[amount]\n        minCoins = -1\n        for val in coins:\n            numCoins = self.coinChange(coins, amount - val)\n            if numCoins != -1:\n                if minCoins == -1:\n                    minCoins = 1 + numCoins\n                else:\n                    minCoins = min(minCoins, 1+numCoins)\n        self.counts[amount] = minCoins\n        return minCoins", "class Solution:\n    def coinChange2(self, coins: List[int], amount: int) -> int:             \n        impossible = amount+1;\n        cnts = [impossible]*impossible;\n        cnts[0] = 0;\n        for coin in coins:\n            for x in range(coin, impossible):\n                cnts[x] = min(cnts[x], cnts[x-coin]+1);\n        if cnts[amount] >= impossible:\n            return -1;\n        return cnts[amount];\n    def coinChange(self, coins: List[int], amount: int) -> int:        \n        impossible = amount+1;\n        self.cnts = [0]*impossible;\n        def createCoins(total: int):\n            if total == 0:\n                return 0;\n            if (self.cnts[total]!= 0):\n                return self.cnts[total];\n            minCnt = impossible;\n            for coin in coins:\n                if (total-coin < 0):\n                    continue;\n                cnt = createCoins(total-coin) + 1;\n                minCnt = min(cnt, minCnt);\n            self.cnts[total] = minCnt;\n            return minCnt;\n        retV =  createCoins(amount);\n        if retV >= impossible:\n            return -1\n        return retV;", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[[0 for j in range(amount+1)] for i in range(len(coins)+1)]\n        \n        INT_MAX=sys.maxsize-1\n        for i in range(0,amount+1):\n            dp[0][i]=INT_MAX\n            \n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j])\n                else:\n                    dp[i][j]=dp[i-1][j]\n                    \n        if dp[-1][-1]>=INT_MAX:\n            return -1\n        return dp[-1][-1]", "class Solution:\n    def coinChange(self, coin: List[int], amount: int) -> int:\n        \n        dp = [ [ 9999999 for _ in range(amount+1)] for _ in range(len(coin)+1) ]\n        # dp[i][j] will store min coins reqd to reach value j with coins coin[:i+1]\n        \n        for i in range(1, len(coin)+1):\n            dp[i][0] = 0   # don't need any coins to hit balance 0........\n            \n        for i in range(1, len(coin)+1):\n            for j in range(1, amount+1):\n                if j>=coin[i-1]:\n                    dp[i][j] = min( dp[i][j-coin[i-1]]+1, dp[i-1][j])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        if dp[-1][-1]==9999999:\n            return -1\n        return dp[-1][-1]        ", "class Solution:\n    # The problem seems to exhibit recursive structure\n    # Recursive algorithm outline\n    # Base cases\n    # - if amount is negative, return -1\n    # - if amount is 0, return 0\n    # Recursive case\n    # - if amount is positive\n    # do a recursive call on all elements\n    # if no positive elements, return 0\n    # else, return 1 + (min of all these positive elements)\n    # Complexity: O(n ^ amount/(lowest_element_in_coins)), because its building a tree\n    \n    def coinChangeDynamic(self, coins: List[int], amount: int, memory_dict: dict) -> int:\n        if(amount < 0):\n            return -1\n        elif amount == 0:\n            return 0\n        else:\n            if(memory_dict.get(amount) is None):\n                recursive_call_output = []\n                for coin_val in coins:\n                    recursive_call_output.append(self.coinChangeDynamic(coins, amount - coin_val, memory_dict))\n                min_num_coins = float('inf')\n                for num_coins in recursive_call_output:\n                    if num_coins >= 0 and num_coins < min_num_coins:\n                        min_num_coins = num_coins\n\n                if(min_num_coins == float('inf')):\n                    memory_dict[amount] = -1\n                    return -1\n                else:\n                    memory_dict[amount] = min_num_coins + 1\n                    return min_num_coins + 1\n            else:\n                return memory_dict[amount]\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        return self.coinChangeDynamic(coins, amount, {})\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        similar to knapsack problem, except we want minimum coins instead of max items\n        \n        \n        dp: increase coins and amount one at a time\n        \n           ''   1.   2.   5\n        0  0.   0.   0.   0\n        1  -1   1    1    1\n        2  -1   2    1    1 \n        3  -1   3.   2.   2\n        4  -1   4.   2.   2\n        5  -1   5.   3.   1\n        6  -1   6.   3.   2\n        7  -1   7.   4.   2\n        8  -1   8.   4.   3\n        9  -1   9.   5.   3\n        10 -1   10.  5.   2\n        11 -1   11.  6.   3\n        \n        fewest_coins[amount][coins_i + 1] = min of (1 + fewest_coins[amount-coins[j]][coins_i]) for j in range(coins_i+1) or -1 if all the fewest_coins[amount-coins[j]][coins_i] are -1\n        \n        how to effectively start dp array?\n        \n        '''\n        \n        # fewest_coins = [[0 for i in range(len(coins)+1)] for j in range(amount+1)]\n        fewest_coins = [0 for j in range(amount+1)]\n        \n#         for i in range(len(coins)+1):\n#             fewest_coins[0][i] = 0\n        \n#         for j in range(1,amount+1):\n#             fewest_coins[j][0] = -1\n\n        # for j in range(1,amount+1):\n        #     fewest_coins[j][0] = -1\n            \n        for j in range(1,amount+1):\n            fewest_coins[j] = float('inf')\n            for coin_i in range(len(coins)):\n                if coins[coin_i] == j:\n                    fewest_coins[j] = 1\n                    break\n                elif coins[coin_i] < j:\n                    if fewest_coins[j-coins[coin_i]] > 0:\n                        fewest_coins[j] = min(fewest_coins[j], fewest_coins[j-coins[coin_i]]+1)\n            if fewest_coins[j] == float('inf'):\n                fewest_coins[j] = -1\n#         for j in range(1,amount+1):\n#             for i in range(1,len(coins)+1):\n                \n#                 fewest_coins[j][i] = float('inf')\n#                 for coin_i in range(i):\n#                     if coins[coin_i] == j:\n#                         fewest_coins[j][i] = 1\n#                         break\n#                     elif coins[coin_i] < j:\n#                         if fewest_coins[j-coins[coin_i]][i] > 0:\n#                             fewest_coins[j][i] = min(fewest_coins[j][i], fewest_coins[j-coins[coin_i]][i]+1)\n#                 if fewest_coins[j][i] == float('inf'):\n#                     fewest_coins[j][i] = -1\n                    \n        return fewest_coins[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [ [0 for i in range(amount+1)] for i in range(len(coins)) ]\n        # coins.sort()\n        col = amount+1\n        for i in range(len(coins)):\n            for j in range(1,col):\n                if i == 0:\n                    r = i\n                    c = j - coins[i]\n                    if c < 0 or dp[r][c] == -1:\n                        dp[i][j] = -1\n                    else:\n                        dp[i][j] = dp[r][c] + 1\n                else:\n                    incIndex = j - coins[i]\n                    if incIndex < 0 or dp[i][incIndex] == -1:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i][incIndex]+1\n                        if dp[i-1][j] != -1:\n                            dp[i][j] = min(dp[i-1][j], dp[i][incIndex]+1)\n        return dp[len(coins)-1][col-1]", "import math\nfrom functools import lru_cache \n\nclass Solution:\n\n       \n    \n    ### Iterative DFS\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        \n        stack = [(0,0)]  # sum, coinCount\n        answer = math.inf\n        \n        # !! n.b, sorting small->big so stack processing searches largest first\n        sortedCoins = sorted(coins) \n        # !! n.b. prune search tree to prevent re-searching same sums\n        visited = set()\n        \n        while stack:\n            # print(sorted(stack, reverse=True))\n            (sum, coinCount) = stack.pop()\n            \n            if (sum, coinCount) in visited:\n                pass\n            elif coinCount >= answer:\n                pass\n            elif sum == amount:\n                answer = min(answer,coinCount)\n            elif sum > amount:\n                pass\n            else:\n                for c in sortedCoins:\n                    if ( \n                        (sum+c) <= amount and\n                        # !! n.b. ensure still possible to beat best answer \n                        # !! with this coin\n                        amount < (sum + (c*(answer-coinCount)))\n                    ):\n                        stack.append((sum+c, coinCount+1))\n                        \n            visited.add((sum, coinCount))\n                \n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n    \n    \n    \n#     ### Iterative DFS.  Brute force won't finish on large trees\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         stack = [(0,0)]    # (sum, count)\n#         # visited = set()\n#         answer = math.inf\n        \n#         while stack:\n#             node = stack.pop()\n#             # print(node)\n            \n#             if node[0] == amount:\n#                 answer = min(answer, node[1])\n#             elif node[0] > amount:\n#                 pass\n#             else:\n#                 for coin in coins:\n#                     stack.append( (node[0]+coin, node[1]+1)  )\n                    \n#         if answer == math.inf:\n#             return -1\n#         else:\n#             return answer\n        \n        \n#     ### Recursive DFS with memoization\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n\n#         @lru_cache(maxsize=None)\n#         def dfs(remainder):\n#             if remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 return 0\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, dfs(remainder - coin) + 1)\n#                 return least\n        \n#         res = dfs(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#         def backtrack(remainder):\n#             # print(remainder)\n#             if remainder in memo:\n#                 return memo[remainder]\n#             elif remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 memo[remainder] = 0\n#                 return memo[remainder]\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, backtrack(remainder - coin) + 1)\n#                 memo[remainder] = least\n#                 return memo[remainder]    \n        \n#         memo = collections.defaultdict(int)\n#         res = backtrack(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n        \n        \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not coins or amount < 0:\n#             return -1\n        \n#         @lru_cache(maxsize=None)\n#         def dfs(sum, count):\n#             # print(\\\"sum:{}, count:{}\\\".format(sum, count))\n#             if count >= self.ans:\n#                 return\n#             elif sum == amount:\n#                 self.ans = min(self.ans, count)\n#                 return\n#             elif sum > amount:\n#                 return\n#             else:\n#                 for c in sortedCoins:\n#                     dfs(sum+c, count+1)\n                    \n#         sortedCoins = sorted(coins, reverse=True)\n#         self.ans = math.inf\n#         dfs(0,0)\n#         if self.ans == math.inf:\n#             return -1\n#         else:\n#             return self.ans\n        \n    \n#     ### BFS\n#     def coinChange(self, coins: List[int], amount: int) -> int:  \n#         if not coins or amount < 0:\n#             return -1\n        \n#         visited = [False]*(amount+1)\n#         parentNodes = [0]\n#         level = -1\n        \n#         while parentNodes:\n#             level += 1\n#             childNodes = []\n#             for node in parentNodes:\n#                 if visited[node]:\n#                     pass\n#                 elif node == amount:\n#                     return level\n#                 elif node > amount:\n#                     pass\n#                 else:\n#                     for c in coins:\n#                         if node+c <= amount:\n#                             childNodes.append(node+c)\n#                 visited[node] = True      \n                \n#             parentNodes = childNodes\n            \n#         return -1\n\n    \n#     ### Dynamic programming\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         maxint = math.inf\n        \n#         # one slot for each amount, up to amount. \n#         dp = [0] + [maxint]*amount\n        \n#         for i in range(1,amount+1):\n#             dp[i] = min([(1+dp[i-c]) for c in coins if i>=c] + [maxint])\n            \n#         if dp[amount] == math.inf:\n#             return -1\n#         else:\n#             return dp[amount]\n        \n    \n### Recursive w/memoization    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         sortedCoins = sorted(coins, reverse=True)\n#         result = self.recurse(amount, tuple(sortedCoins))\n        \n#         if result == math.inf:\n#             result = -1\n        \n#         return result\n        \n#     @lru_cache(maxsize=None)\n#     def recurse(self, amount: int, coins: tuple) -> int:\n#         # print(amount)\n#         if amount < 0:\n#             return math.inf\n#         elif amount == 0:\n#             return 0\n#         else:\n#             least = math.inf\n#             for c in coins:\n#                 val = self.recurse(amount-c, coins)\n#                 if val < math.inf:\n#                     # print('{} = {}'.format(amount-c, val))\n#                     least = min(least, val)\n#             return least + 1\n                \n", "import math\nclass Solution:\n    trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        if amount < 0:\n            return -1\n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            if required < 0:\n                continue\n            val = self.trellis[required] if self.trellis[required] != math.inf else self.coinChange(coins, required)\n            if val == -1:\n                continue\n            else:\n                minVal = min(minVal, val + 1)\n        if minVal == math.inf:\n            minVal = -1\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "import math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        arr = coins\n        w = amount\n        \n        n = len(arr)\n        t = [[0]*(w+1) for _ in range(n+1)]\n\n        for i in range(n+1):\n            for j in range(w+1):\n                if j == 0 and i!=0:\n                    t[i][j] = 0\n                if i == 1 and j!=0:\n                    t[i][j] = int(j/arr[i-1]) if j%arr[i-1] == 0 else math.inf\n\n        for i in range(2, n+1):\n            for j in range(1, w+1):\n                if arr[i-1] <= j:\n                    t[i][j] = min(t[i][j-arr[i-1]]+1, t[i-1][j])\n                else:\n                    t[i][j] = t[i-1][j]\n        # from pprint import pprint\n        # pprint(t)\n        return -1 if t[n][w]==math.inf else t[n][w]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def coinChangeHelper(coins, amount, memoisation = {}):\n            # memoisation hashmap - key (the amount), value(the minimum coins)\n            \n            if amount == 0:  # Base case 1\n                return 0\n            \n            if amount < 0:  # Base case 2: This combination of coins was not successfull\n                return float('inf')\n            \n            if amount in memoisation:  # If we have already computed the minimum for this amount before, return cached value \n                return memoisation[amount]\n            \n            min_coins_used = float('inf')  # Keep track of the minimum coins used\n            for i in range(len(coins) - 1, -1, -1): # If the amount is not cached, consider all the coin denominations\n                min_coins_used = min(1 + coinChangeHelper(coins, amount - coins[i], memoisation), min_coins_used)\n            \n            memoisation[amount] = min_coins_used \n            return min_coins_used\n            \n        result = coinChangeHelper(coins, amount)\n        return result if result != float('inf') else -1\n\n        \n        \n#         def helper(coins, amount):\n#             if amount == 0:\n#                 return 1\n#             if amount < 0:\n#                 return float('inf')\n\n#             min_so_far = float('inf')\n#             for denomination in reversed(coins):\n#                 min_so_far = min(min_so_far, helper(coins, amount - denomination))\n\n#             return min_so_far + 1 if min_so_far != float('inf') else -1\n    \n#         result = helper(coins, amount)\n#         return  result - 1 if result > 0 else -1 \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[0 for _ in range(amount+1)] for _ in range(len(coins)+1)]\n        \n        for j in range(amount+1):\n            dp[0][j] = float('inf')\n            \n        for i in range(1, len(coins)+1):\n            for j in range(1, amount+1):\n                if coins[i-1] > j:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = min(1+dp[i][j-coins[i-1]], dp[i-1][j])\n        if dp[-1][-1] == float('inf'):\n            return -1\n        return dp[-1][-1]\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        def dp(m):\n            if m in coins: return 1\n            if m == 0: return 0\n            if m < 0: return float('inf')\n            \n            if m not in memo:\n                ans = float('inf')\n                for v in coins:\n                    ans = min(1 + dp(m - v), ans)\n                memo[m] = ans\n            return memo[m]\n        return dp(amount) if dp(amount)!= float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n      coinsCount = dict()\n      #fill dict:\n      for i in range (1, amount+1):\n        coinsCount[i] = 9999\n      coinsCount[0] = 0\n      for i in range(1, amount+1):\n        for icoin in range (0, len(coins)):\n          curDenom = coins[icoin]\n          difference = i - curDenom\n          if difference >= 0:\n            coinsCount[i] = min(1 + coinsCount[difference], coinsCount[i])\n          elif difference == 0:\n            coinsCount[i] +=1\n      if (coinsCount[amount] != 9999):\n        return coinsCount[amount]\n      return -1\n      \n", "class Solution:\n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if (amount == 0):\n            return 0\n        \n        self.dp = {}\n        min_ = sys.maxsize\n        \n        for coin in coins:\n            if (amount - coin >= 0):\n                min_ = min(min_, 1 + self.change(amount - coin, coins))\n        \n        if (min_ == sys.maxsize):\n            return -1 \n        \n        return min_\n        \n    \n    def change(self, amount, coins):\n        if (amount in self.dp):\n            return self.dp[amount]\n        \n        if (amount == 0):\n            self.dp[amount] = 0\n            return 0\n        \n        if (amount in coins):\n            self.dp[amount] = 1\n            return 1\n        \n        min_ = sys.maxsize\n        \n        for coin in coins:\n            if (amount - coin >= 0):\n                min_ = min(min_, 1 + self.change(amount - coin, coins))\n        \n        self.dp[amount] = min_\n        return min_\n            \n        \n    \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        N=[0 for i in range(amount+1)]\n        N[0]=0\n        for i in range(1,amount+1):\n            temp=[i-j for j in coins]\n            history=[N[temp2] for temp2 in temp if temp2 <=i and temp2>=0 and N[temp2]!=-1]\n            if len(history)==0:\n                N[i]=-1\n            else:\n                N[i]=1+min([N[temp2] for temp2 in temp if temp2 <=i and temp2>=0 and N[temp2]!=-1])\n        return N[amount]\n                \n            \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        similar to knapsack problem, except we want minimum coins instead of max items\n        \n        \n        dp: increase coins and amount one at a time\n        \n           ''   1.   2.   5\n        0  0.   0.   0.   0\n        1  -1   1    1    1\n        2  -1   2    1    1 \n        3  -1   3.   2.   2\n        4  -1   4.   2.   2\n        5  -1   5.   3.   1\n        6  -1   6.   3.   2\n        7  -1   7.   4.   2\n        8  -1   8.   4.   3\n        9  -1   9.   5.   3\n        10 -1   10.  5.   2\n        11 -1   11.  6.   3\n        \n        fewest_coins[amount][coins_i + 1] = min of (1 + fewest_coins[amount-coins[j]][coins_i]) for j in range(coins_i+1) or -1 if all the fewest_coins[amount-coins[j]][coins_i] are -1\n        \n        how to effectively start dp array?\n        \n        '''\n        fewest_coins = [0 for j in range(amount+1)]\n        \n        for j in range(1,amount+1):\n            fewest_coins[j] = float('inf')\n            for coin_i in range(len(coins)):\n                if coins[coin_i] == j:\n                    fewest_coins[j] = 1\n                    break\n                elif coins[coin_i] < j:\n                    if fewest_coins[j-coins[coin_i]] > 0:\n                        fewest_coins[j] = min(fewest_coins[j], fewest_coins[j-coins[coin_i]]+1)\n            if fewest_coins[j] == float('inf'):\n                fewest_coins[j] = -1\n                    \n        return fewest_coins[-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[0 for i in range(amount+1)] for j in range(len(coins)+1)]\n        for j in range(1,amount+1):\n            dp[0][j] = float('inf')\n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1] <= j:\n                    dp[i][j] = min(dp[i-1][j], 1 + dp[i][j-coins[i-1]])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        if dp[len(coins)][amount] == float('inf'):\n            return -1\n        else:\n            return dp[len(coins)][amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def helper(coins, amount, dp):\n            if amount < 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if amount in dp:\n                return dp[amount]\n            for i in range(len(coins)):\n                use_ci = 1 + helper(coins, amount - coins[i], dp)\n                if amount not in dp:\n                    dp[amount] = use_ci\n                else:\n                    dp[amount] = min(dp[amount], use_ci)       \n            return dp[amount]\n        \n        if amount <= 0:\n            return 0\n        dp = {}\n        result = helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # use DP\n        N = len(coins)\n        M = amount\n        table = [[-1]*(N+1) for i in range(M+1)]\n        for j in range(N+1):\n            table[0][j] = 0\n        for m in range(1,M+1):\n            for i in range(N):\n                c = coins[i]\n                if c > m:\n                    table[m][i+1] = table[m][i]\n                elif table[m-c][i+1] != -1:\n                    if table[m][i]!= -1:\n                        table[m][i+1] = min(table[m-c][i+1]+1, table[m][i])\n                    else:\n                        table[m][i+1] = table[m-c][i+1]+1\n                else:\n                    table[m][i+1] = table[m][i]\n        return table[M][N]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        '''\n        [0,1,2,3,4,5,6,7,8,9,10]\n        [0,1,1,2,2,1,2,2,3,3,2]\n        \n        '''\n        \n        dp = [0] + [float('inf') for _ in range(amount)]\n        \n        for coin in coins:\n            for num in range(coin, len(dp)):\n                \n                dp[num] = min(dp[num-coin] + 1, dp[num])\n                \n        return dp[amount] if dp[amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        round = 0\n        d = set([0])\n        while d or round == 0:\n            round += 1\n            d = set([coin+s for coin in coins for s in d if coin+s<=amount and coin+s not in d])\n            if amount in d:\n                return round\n        return -1\n                        \n                        \n                \n", "from collections import defaultdict\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def coin_change_for_amount(coins, amount):\n            nonlocal count_amount\n            \n            if amount < 0:\n                return -1\n            \n            if amount == 0:\n                return 0\n            \n            if count_amount[amount] != float('inf'):\n                return count_amount[amount]\n            \n            min_coins_amt = float('inf')\n            for coin in coins:\n                \n                min_coins_amt_coin = coin_change_for_amount(coins, amount - coin)\n                \n                if 0 <= min_coins_amt_coin < min_coins_amt:\n                    min_coins_amt = min_coins_amt_coin + 1\n            \n            \n            count_amount[amount] = -1 if min_coins_amt == float('inf') else min_coins_amt\n            \n            return count_amount[amount]\n        \n        if amount <= 0:\n            return 0\n        count_amount = defaultdict(lambda: float('inf'))\n        coin_change_for_amount(coins, amount)\n        \n        return count_amount[amount]\n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        if n == 0:\n            return 0\n        dp = [[amount+1] * (amount+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 0\n        \n        for i in range(1, n+1):\n            for j in range(1, amount+1):\n                dp[i][j] = dp[i-1][j]\n                if j - coins[i-1] >= 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-coins[i-1]]+1)   \n        return dp[n][amount] if dp[n][amount] <= amount else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        dp = [-1 for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(amount):\n            mn = math.inf\n            pos = False\n            for c in coins:\n                if i+1>=c and dp[i-c+1]>=0:\n            \n                    pos = True\n                    mn = min(mn, dp[i+1-c]+1)\n           \n            if pos:\n                dp[i+1] = mn\n          \n      \n        return dp[-1]\n                    \n                    \n", "\nimport sys\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [sys.maxsize for i in range(amount+1)]\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i], 1+dp[i-coin])\n        return -1 if dp[amount] == sys.maxsize else dp[amount]", "class Solution:\n    memory = {}\n    \n    \n    def numCoins(self, coins, amount):\n        if amount in self.memory:\n            return self.memory[amount]\n        \n        if amount == 0:\n            return 0\n        \n        ncarr = []\n        carr = []\n        for c in coins:\n            if amount >= c:\n                nnc = self.numCoins(coins, amount - c)                \n                ncarr.append(nnc + 1)\n                carr.append(c)\n            \n        if len(ncarr) > 0:        \n            nc = min(ncarr)\n            #accum += carr[ncarr.index(nc)]\n            self.memory[amount] = nc\n            return nc\n        else:\n            return float('inf')\n    \n                        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.memory = {}                \n        nc = self.numCoins(coins, amount)\n        if nc == float('inf'):\n            return -1\n        \n        return nc\n        \n            \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[float('inf')] * (amount + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            dp[i][0] = 0\n            for j in range(1, amount + 1):\n                dp[i][j] = min(dp[i - 1][j], (dp[i][j - coins[i - 1]] if j >= coins[i - 1] else float('inf')) + 1)\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def helper(coins, amount, dp):\n            if amount < 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if amount in dp:\n                return dp[amount]\n            for i in range(len(coins)):\n                use_ci = 1 + helper(coins, amount - coins[i], dp)\n                if amount not in dp:\n                    dp[amount] = use_ci\n                else:\n                    dp[amount] = min(dp[amount], use_ci)       \n            return dp[amount]\n        \n        if amount == 0:\n            return 0\n        if amount<0:\n            return -1\n        dp = {}\n        result = helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n    \n", "import math\n\n\ndef rec(coins, amount, used_coins, res):\n    if amount == 0:\n        res[0] = min(res[0], used_coins)        \n    elif coins:\n        coin, rest_coins = coins[-1], coins[:-1]\n        for i in range(amount // coin, -1, -1):\n            if (res[0] - used_coins) * coin >= amount:\n                rec(rest_coins, amount - i * coin, used_coins + i, res)\n\n                \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        res = [math.inf]\n        rec(sorted(coins), amount, 0, res)\n        return res[0] if res[0] != math.inf else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #dp[i] --- for amount i, the fewset coin here\n        \n        dp = [float('inf') ]* (amount+1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i >= coin:\n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n        \n        if dp[-1] == float('inf'):\n            return -1\n        \n        return dp[-1]", "class Solution:\n    def helper(self, coins, amount, dp):\n        if amount < 0:\n            return float('inf')\n        if amount == 0:\n            return 0\n        if amount in dp:\n            return dp[amount]\n        for i in range(len(coins)):\n            use_ci = 1 + self.helper(coins, amount - coins[i], dp)\n            if amount not in dp:\n                dp[amount] = use_ci\n            else:\n                dp[amount] = min(dp[amount], use_ci)       \n        return dp[amount]\n       \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <= 0:\n            return 0\n        dp = {}\n        result = self.helper(coins, amount, dp)\n        return -1 if result == float('inf') else result", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[float('inf') for _ in range(amount + 1)] for _ in range(n)]\n        \n        for r in range(n):\n            dp[r][0] = 0\n\n        for a in range(1, amount + 1):\n            div, mod = divmod(a, coins[0])\n            if mod  == 0:\n                dp[0][a] = div\n\n        for i in range(1, n):\n            for a in range(1, amount + 1):\n                if a - coins[i] >= 0:\n                    dp[i][a] = min(dp[i][a - coins[i]] + 1, dp[i - 1][a])\n                else:\n                    dp[i][a] = dp[i - 1][a]\n\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        seen = {0:0}\n\n\n        def helper(coins, amount):\n            \n            if amount in seen:\n                return seen[amount]\n            \n            if not coins:\n                return -1\n\n            leastCoins = float('Inf')\n            for coin in [c for c in coins if c<= amount]:\n                next_least = helper(coins, amount-coin)\n                if next_least != -1:\n                    leastCoins = min(leastCoins, 1+next_least)\n            if leastCoins == float('Inf'):\n                seen[amount] = -1\n                return -1\n            else:\n                seen[amount] = leastCoins\n                return leastCoins\n            \n\n        return helper(coins, amount)", "import sys\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:        \n        \n        res = self.helper(sorted(coins, reverse = True), amount, {})\n        if res == float('inf'):\n            return -1\n        return res\n    \n    def helper(self, coins, amount, dAmounts):\n        if amount < 0:\n            return float('inf')\n        \n        if amount == 0:\n            return 0\n        \n        if amount in dAmounts:\n            return dAmounts[amount]\n        \n        for c in coins:\n            pathCount = 1 + self.helper(coins, amount-c, dAmounts)\n            dAmounts[amount] = min(dAmounts.get(amount, pathCount), pathCount)\n        return dAmounts[amount]\n            \n    '''def helper(self, coins, amount, dp):\n        if amount < 0:\n            return float('inf')\n        if amount == 0:\n            return 0\n        if amount in dp:\n            return dp[amount]\n        for i in range(len(coins)):\n            use_ci = 1 + self.helper(coins, amount - coins[i], dp)\n            if amount not in dp:\n                dp[amount] = use_ci\n            else:\n                dp[amount] = min(dp[amount], use_ci)       \n        return dp[amount]\n       \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <= 0:\n            return 0\n        dp = {}\n        result = self.helper(coins, amount, dp)\n        return -1 if result == float('inf') else result'''\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp(i) = least coins that can sum up to i\n        # iterate each coin on i to check if there's less number sums to i\n        dp = [float('Inf') for _ in range(amount + 1)]\n        dp[0] = 0\n        \n        for i in range(1, amount+1):\n            for coin in coins:\n                if i>= coin and dp[i-coin] != float('Inf'):\n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n                    \n        if dp[amount] == float('Inf'): # when the sum cannot be achieved\n            return -1\n        return dp[amount]", "class Solution:\n    # Top down DP solution\n    def helper(self, coins, amount, dp):\n        if amount < 0:\n            # cant get a negative amount - need inf coins\n            return float('inf')\n        if amount == 0:\n            # if amount is 0, we need to use 0 coins\n            return 0\n        if amount in dp:\n            # already cached\n            return dp[amount]\n        for i in range(len(coins)):\n            # We use coin i so now amount is amount - coins[i] \n            use_ci = 1 + self.helper(coins, amount - coins[i], dp)\n            if amount not in dp:\n                dp[amount] = use_ci\n            else:\n                # either using this coin makes it fewer coins or not\n                dp[amount] = min(dp[amount], use_ci)       \n        return dp[amount]\n        \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <= 0:\n            return 0\n        dp = {} # dp cache | memoization\n        result = self.helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n        \n", "INF = 100000000000000000\n\ndef hashIntArr(i_arr):\n  return '-'.join(list(map(str, i_arr)))\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        mc = [[0 if j == 0 else INF for j in range(amount + 1)] for _ in range(len(coins) + 1)]\n        for c in range(1, len(coins) + 1):\n          coin_value = coins[c - 1]\n\n          for a in range(1, amount + 1):\n            if coin_value <= a:\n              mc[c][a] = min(1 + mc[c][a - coin_value], mc[c - 1][a])\n            else:\n              mc[c][a] = mc[c - 1][a]\n              \n\n        min_coins = mc[len(coins)][amount]\n        return min_coins if min_coins < INF else -1\n      \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n=len(coins)\n        t=[[float('inf')-1]* (amount+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            t[i][0]=0\n        for j in range(amount+1):\n            t[0][j]=float('inf')-1\n            if j%coins[0]==0:\n                t[1][j]=j//coins[0]\n            else:\n                t[1][j]=float('inf')-1\n        \n        for i in range(1,n+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    t[i][j]= min(1+t[i][j-coins[i-1]], t[i-1][j])\n                else:\n                    t[i][j]= t[i-1][j]\n        return t[n][amount] if t[n][amount]!=float('inf') else -1\n", "class Solution:\n    # Top down DP solution\n    def helper(self, coins, amount, dp):\n        if amount < 0:\n            return float('inf')\n        if amount == 0:\n            return 0\n        if amount in dp:\n            return dp[amount]\n        for i in range(len(coins)):\n            use_ci = 1 + self.helper(coins, amount - coins[i], dp)\n            if amount not in dp:\n                dp[amount] = use_ci\n            else:\n                dp[amount] = min(dp[amount], use_ci)       \n        return dp[amount]\n        \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <= 0:\n            return 0\n        dp = {}\n        result = self.helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n        \n", "class Solution:\n    \n    def __init__(self):\n        self.memo = {}\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        ans = self.helper(coins,amount)\n        if ans == float('inf'):\n            return -1\n        return ans\n        \n    def helper(self, coins, remaining):\n        if remaining == 0:\n            return 0\n        if remaining < 0:\n            return float('inf')\n        if remaining in self.memo:\n            return self.memo[remaining]\n        self.memo[remaining] = min([self.helper(coins,remaining-i) for i in coins[::-1]])+1\n        return self.memo[remaining]\n        \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [ [0 for i in range(amount+1)] for i in range(len(coins)) ]\n        # print(dp)\n        coins.sort()\n        col = amount+1\n        for i in range(len(coins)):\n            for j in range(1,col):\n                if i == 0:\n                    r = i\n                    c = j - coins[i]\n                    # print(r,c)\n                    if c < 0 or dp[r][c] == -1:\n                        dp[i][j] = -1\n                    else:\n                        dp[i][j] = dp[r][c] + 1\n                else:\n                    incIndex = j - coins[i]\n                    if incIndex < 0 or dp[i][incIndex] == -1:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i][incIndex]+1\n                        if dp[i-1][j] != -1:\n                            dp[i][j] = min(dp[i-1][j], dp[i][incIndex]+1)\n        # print(dp)\n        return dp[len(coins)-1][col-1]", "class Solution:\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coins = coins\n        self.amount_dict = {0:0}\n        for coin in coins:\n            self.amount_dict[coin] = 1\n        return self.coinChangeHelp(amount)\n\n    @lru_cache\n    def coinChangeHelp(self, amount: int) -> int:\n        if amount < 0:\n            return -1\n#         if not amount:\n#             return 0\n        if amount in self.amount_dict:\n            return self.amount_dict[amount]\n        max_coin = amount + 1\n        for coin in self.coins:\n            cur_coin = self.coinChangeHelp(amount - coin)\n            if cur_coin >= 0:\n                max_coin = min(max_coin, cur_coin+1) \n        max_coin = max_coin if max_coin != (amount+1) else -1\n        self.amount_dict[amount]=max_coin\n        return max_coin", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0]\n        length = len(coins)\n        for i in range(1, amount+1):\n            dp += [9999]\n            for j in range(length):\n                if i >= coins[j] and dp[int(i-coins[j])] != 9999:\n                    dp[i] = min(dp[i], dp[int(i-coins[j])] + 1)\n        if dp[amount] == 9999:\n            return -1\n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        cl = len(coins)\n        dp = [[math.inf for i in range(amount+1)] for j in range(cl)]\n        dp[0][0] = 0\n        for i in range(1,amount+1):\n            if i-coins[0] >= 0:\n                dp[0][i] = dp[0][i-coins[0]]+1\n        for i in range(1,cl):\n            for j in range(amount+1):\n                dp[i][j] = dp[i-1][j]\n                if (j-coins[i])>= 0:\n                    dp[i][j] = min(dp[i][j-coins[i]]+1, dp[i][j])\n        if dp[cl-1][amount] == math.inf:\n            return -1\n        else:\n            return dp[cl-1][amount]\n", "import math\n\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        best_so_far = math.inf\n        \n        def rec(C, A, used):\n            nonlocal best_so_far\n            if A == 0:\n                best_so_far = min(best_so_far, used)            \n            elif C:\n                for i in range(A//C[-1], -1, -1):\n                    if (best_so_far - used) * C[-1] >= A:\n                        rec(C[:-1], A - i*C[-1], used + i)\n                    \n        rec(coins, amount, 0)\n        return best_so_far if best_so_far != math.inf else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        \n        self.coins = coins\n        \n        self.count = {}\n        \n        return self.helper(amount)\n    \n    def helper(self, rem):\n        # print(rem)\n        if rem < 0:\n            return -1\n        if rem == 0:\n            return 0\n        \n        if (rem-1) in self.count:\n            return self.count[rem-1]\n        \n        min_count = 1000000000\n        for coin in self.coins:\n            # print(\\\"coin: {}\\\".format(coin))\n            res = self.helper(rem - coin)\n            if res >= 0 and res < min_count:\n                min_count = res + 1\n            \n            if min_count == 1000000000:\n                self.count[rem - 1] = -1\n            else:\n                self.count[rem - 1] = min_count\n            \n        return self.count[rem-1]\n", "import math\nfrom functools import lru_cache \n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        result = self.recurse(amount, tuple(coins))\n        \n        if result == math.inf:\n            result = -1\n        \n        return result\n        \n    @lru_cache(maxsize=None)\n    def recurse(self, amount: int, coins: tuple) -> int:\n        # print(amount)\n        if amount < 0:\n            return math.inf\n        elif amount == 0:\n            return 0\n        elif amount in coins:\n            return 1\n        else:\n            least = math.inf\n            for c in coins:\n                val = self.recurse(amount-c, coins)\n                # print('{} = {}'.format(amount-c, val))\n                least = min(least, val)\n                \n            return least + 1\n                \n", "class Solution:\n    def helper(self, coins, amount, dp):\n        if amount < 0:\n            return float('inf')\n        if amount == 0:\n            return 0\n        if amount in dp:\n            return dp[amount]\n        for i in range(len(coins)):\n            use_ci = 1 + self.helper(coins, amount - coins[i], dp)\n            if amount not in dp:\n                dp[amount] = use_ci\n            else:\n                dp[amount] = min(dp[amount], use_ci)       \n        return dp[amount]\n        \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <= 0:\n            return 0\n        dp = {}\n        result = self.helper(coins, amount, dp)\n        return -1 if result == float('inf') else result\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n            \n        def helper(coins, rem, counts):\n            if rem < 0: return -1\n            if rem == 0: return 0\n            if counts[rem-1] != 0: return counts[rem-1]\n            min_val = float('inf')\n            for coin in coins:\n                res = helper(coins, rem - coin, counts)\n                if res >= 0 and res < min_val:\n                    min_val = res + 1\n                if min_val == float('inf'):\n                    counts[rem - 1] = -1\n                else:\n                    counts[rem - 1] = min_val\n            return counts[rem-1]\n        \n        if amount < 1: return 0\n        return helper(coins, amount, [0]*amount)", "class Solution:\n    def coinChange(self, coins: List[int], target: int) -> int:\n\n        table = [[float('inf') for _ in range(target+1)] for _ in range(len(coins)+1)]\n    \n        for i in range(len(coins)+1):\n            table[i][0] = 0\n        for i in range(1, len(coins)+1):\n            for j in range(target+1):\n                if coins[i-1] <= j:\n                    a = 1 + table[i][j-coins[i-1]]\n                else:\n                    a = float('inf')\n                b = table[i-1][j]\n                if a <= b:\n                    table[i][j] = a\n                \n                else:\n                    table[i][j] = b\n        return table[-1][-1] if table[-1][-1] != float('inf') else -1", "class Solution:\n    cache = {}\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.cache = {}\n        return self.solve(coins, amount)\n\n    def solve(self, coins, amount):\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return -1\n\n        if amount in self.cache:\n            return self.cache[amount]\n\n        best = -1\n        for c in coins:\n            add = self.solve(coins, amount - c)\n            if add != -1:\n                if best == -1:\n                    best = add + 1\n                else:\n                    best = min(best, add + 1)\n\n        self.cache[amount] = best\n        return best", "import math\nfrom functools import lru_cache \n\nclass Solution:\n\n       \n    \n    ### Iterative DFS, with optimizations.  very fast\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins or amount < 0:\n            return -1\n        \n        stack = [(0,0)]  # sum, coinCount\n        answer = math.inf\n        \n        # !! n.b, sorting small->big so stack processing searches largest first\n        sortedCoins = sorted(coins) \n        # !! n.b. prune search tree to prevent re-searching same sums\n        visited = set()\n        \n        while stack:\n            (sum, coinCount) = stack.pop()\n            \n            if (sum, coinCount) in visited:\n                pass\n            elif coinCount >= answer:\n                pass\n            elif sum == amount:\n                answer = min(answer,coinCount)\n            elif sum > amount:\n                pass\n            else:\n                \n                \n                for c in sortedCoins:\n                    remainder = (amount - sum) % c\n                    \n                    if remainder == 0:\n                        quotient = (amount - sum) // c\n                        answer = min(answer, coinCount + quotient)\n                    \n                    \n                    if ( \n                        (sum+c) <= amount and\n                        # !! n.b. ensure still possible to beat best answer \n                        # !! with this coin\n                        amount < (sum + (c*(answer-coinCount)))\n                    ):\n                        stack.append((sum+c, coinCount+1))\n                        \n            visited.add((sum, coinCount))\n                \n        if answer == math.inf:\n            return -1\n        else:\n            return answer\n    \n    \n    \n#     ### Iterative DFS.  Brute force won't finish on large trees\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         stack = [(0,0)]    # (sum, count)\n#         # visited = set()\n#         answer = math.inf\n        \n#         while stack:\n#             node = stack.pop()\n#             # print(node)\n            \n#             if node[0] == amount:\n#                 answer = min(answer, node[1])\n#             elif node[0] > amount:\n#                 pass\n#             else:\n#                 for coin in coins:\n#                     stack.append( (node[0]+coin, node[1]+1)  )\n                    \n#         if answer == math.inf:\n#             return -1\n#         else:\n#             return answer\n        \n        \n#     ### Recursive DFS with memoization\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n\n#         @lru_cache(maxsize=None)\n#         def dfs(remainder):\n#             if remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 return 0\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, dfs(remainder - coin) + 1)\n#                 return least\n        \n#         res = dfs(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n        \n#         def backtrack(remainder):\n#             # print(remainder)\n#             if remainder in memo:\n#                 return memo[remainder]\n#             elif remainder < 0:\n#                 return math.inf\n#             elif remainder == 0:\n#                 memo[remainder] = 0\n#                 return memo[remainder]\n#             else:\n#                 least = math.inf\n#                 for coin in coins:\n#                     least = min(least, backtrack(remainder - coin) + 1)\n#                 memo[remainder] = least\n#                 return memo[remainder]    \n        \n#         memo = collections.defaultdict(int)\n#         res = backtrack(amount)\n#         if res == math.inf:\n#             return -1\n#         else:\n#             return res\n        \n        \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not coins or amount < 0:\n#             return -1\n        \n#         @lru_cache(maxsize=None)\n#         def dfs(sum, count):\n#             # print(\\\"sum:{}, count:{}\\\".format(sum, count))\n#             if count >= self.ans:\n#                 return\n#             elif sum == amount:\n#                 self.ans = min(self.ans, count)\n#                 return\n#             elif sum > amount:\n#                 return\n#             else:\n#                 for c in sortedCoins:\n#                     dfs(sum+c, count+1)\n                    \n#         sortedCoins = sorted(coins, reverse=True)\n#         self.ans = math.inf\n#         dfs(0,0)\n#         if self.ans == math.inf:\n#             return -1\n#         else:\n#             return self.ans\n        \n    \n#     ### BFS\n#     def coinChange(self, coins: List[int], amount: int) -> int:  \n#         if not coins or amount < 0:\n#             return -1\n        \n#         visited = [False]*(amount+1)\n#         parentNodes = [0]\n#         level = -1\n        \n#         while parentNodes:\n#             level += 1\n#             childNodes = []\n#             for node in parentNodes:\n#                 if visited[node]:\n#                     pass\n#                 elif node == amount:\n#                     return level\n#                 elif node > amount:\n#                     pass\n#                 else:\n#                     for c in coins:\n#                         if node+c <= amount:\n#                             childNodes.append(node+c)\n#                 visited[node] = True      \n                \n#             parentNodes = childNodes\n            \n#         return -1\n\n    \n#     ### Dynamic programming\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         maxint = math.inf\n        \n#         # one slot for each amount, up to amount. \n#         dp = [0] + [maxint]*amount\n        \n#         for i in range(1,amount+1):\n#             dp[i] = min([(1+dp[i-c]) for c in coins if i>=c] + [maxint])\n            \n#         if dp[amount] == math.inf:\n#             return -1\n#         else:\n#             return dp[amount]\n        \n    \n### Recursive w/memoization    \n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         sortedCoins = sorted(coins, reverse=True)\n#         result = self.recurse(amount, tuple(sortedCoins))\n        \n#         if result == math.inf:\n#             result = -1\n        \n#         return result\n        \n#     @lru_cache(maxsize=None)\n#     def recurse(self, amount: int, coins: tuple) -> int:\n#         # print(amount)\n#         if amount < 0:\n#             return math.inf\n#         elif amount == 0:\n#             return 0\n#         else:\n#             least = math.inf\n#             for c in coins:\n#                 val = self.recurse(amount-c, coins)\n#                 if val < math.inf:\n#                     # print('{} = {}'.format(amount-c, val))\n#                     least = min(least, val)\n#             return least + 1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        d = {}\n        for v in coins:\n            d[v] = True\n        min_coin = coins[-1]\n        \n        if not coins or not amount:\n            return 0\n        if len(coins) == 1:\n            if amount % coins[0] == 0:\n                return int(amount / coins[0])\n            else:\n                return -1\n        \n        self.memo = {}\n        return self.fewest(coins, amount, d, min_coin)\n    \n    def fewest(self, coins, amount, d_value, min_coin):\n        if amount in self.memo:\n            return self.memo[amount]\n        \n        if amount in d_value:\n            return 1\n        elif amount < min_coin:\n            return -1\n        \n        _min = float('inf') \n        for v in coins:\n            ret = self.fewest(coins, amount - v, d_value, min_coin)\n            if ret > 0:\n                _min = min(_min, ret + 1)\n\n        _min = -1 if _min == float('inf') else _min\n        self.memo[amount] = _min\n        return _min\n", "class Solution:\n    def coinChange(self, coins, amount):\n        n = len(coins)\n        dp = [[math.inf for _ in range(amount + 1)] for _ in range(n)]\n\n        for i, coin in enumerate(coins):\n            for t in range(amount + 1):\n                # * populate the amount=0 columns, as we don't need any coin to make zero amount\n                if t == 0:\n                    dp[i][t] = 0\n                # * if you use elifs, fails\n                if i > 0:\n                    # * Exclude the coin: In this case, we will take the minimum coin count from the previous set\n                    dp[i][t] = dp[i - 1][t]\n\n                if t >= coin:\n                    # * include the coin\n                    # * dp[i][t-coin] + 1: take the minimum count needed to get the remaining total, plus include \u20181\u2019 for the current coin\n                    # ! min(dp[i][t] because we already computed min value up there.\n                    dp[i][t] = min(dp[i][t], dp[i][t - coin] + 1)\n        # print(dp)\n        # amount combinations will be at the bottom-right corner.\n        return -1 if dp[n - 1][amount] == math.inf else dp[n - 1][amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[float('inf') for i in range(amount+1)] for i in range(len(coins))]\n        \n        for amount in range(len(dp[0])):\n            if amount % coins[0]  == 0:\n                dp[0][amount] = amount // coins[0]\n        \n        for coin in range(len(dp)):\n            dp[coin][0] = 0\n            \n            \n        \n        for coin in range(1, len(dp)):\n            for amount in range(1, len(dp[0])):\n                if amount >= coins[coin]:\n                    dp[coin][amount] = min(dp[coin][amount-coins[coin]]+1, dp[coin-1][amount])\n                else:\n                    dp[coin][amount] = dp[coin-1][amount]\n        \n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #dp_table = {0:0}\n        dp_table = [float('inf')] * (amount+1)\n        #dp_table[0] = 0\n        return self.dp(dp_table,coins,amount)\n    \n    def dp(self,dp_table:[float],coins: List[int], amount: int) ->int:\n        if amount == 0:return 0\n        if amount < 0 :return -1\n        if dp_table[amount] != float('inf'):\n            return dp_table[amount]\n        # \u6c42\u6700\u5c0f\u503c\uff1a\n        res = float('inf')\n        for coin in coins: # \u6bcf\u6b21\u9009\u62e9\u7684\u90fd\u662f\u8ba9 amount \u51cf\u5c11\u6700\u591a\u7684\n            subpb = self.dp(dp_table,coins,amount-coin)\n            if subpb == -1:\n                continue\n            res = min(res,subpb+1)\n        dp_table[amount] = res if res != float('inf') else -1\n        return dp_table[amount]\n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        state = [float('inf')]*amount\n        if amount <1:\n            return 0\n        max_coin = 0\n        for c in coins:\n            max_coin = max(c,max_coin)\n            if c<= amount:\n                state[c-1] = 1\n        for i in range(amount):\n            for c in coins:\n                if i-c>=0:\n                    state[i] = min(state[i-c]+1,state[i])\n        \n        return state[-1] if state[-1] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        dp = [0]*(amount+1)\n        for item in range(amount+1):\n            if (item<coins[0]) and item!=0:\n                dp[item] = -1\n            elif item == 0:\n                dp[item] = 0 \n                \n        if (amount<coins[0]) and amount == 0:\n            return 0\n        elif (amount<coins[0]):\n            return -1\n        \n        for i in range(coins[0], amount+1):\n            count=0\n            \n            for j in coins:\n                if (i-j)<0:\n                    break \n                elif dp[i-j]!=-1:\n                    count+=1\n            if count>0:\n                dp[i] = math.ceil(i/coins[0])\n                for j in coins:\n                    if (i-j)<0:\n                        break \n                    elif dp[i-j] == -1:\n                        continue \n                    else:\n                        dp[i] = min(dp[i], 1+dp[i-j])\n            else:\n                dp[i] =-1\n        \n        return dp[amount]\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 1:\n            return 0\n        \n        self.coins = coins\n        # self.coins = sorted(coins, reverse=True)\n        \n        self.count = {}\n        \n        self.recur_count = 0\n        \n        ans = self.helper(amount)\n        # print(self.recur_count)\n        return ans\n    \n    def helper(self, rem):\n        self.recur_count += 1\n        # print(rem)\n        if rem < 0:\n            return -1\n        if rem == 0:\n            return 0\n        \n        if rem in self.count:\n            return self.count[rem]\n        \n        min_count = 1000000000\n        for coin in self.coins:\n            # print(\\\"coin: {}\\\".format(coin))\n            res = self.helper(rem - coin)\n            if res >= 0 and res < min_count:\n                min_count = res + 1\n            \n            if min_count == 1000000000:\n                self.count[rem] = -1\n            else:\n                self.count[rem] = min_count\n                \n            \n        return self.count[rem]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # coins_dict = {coin, coin for coin in coins}\n        dp = [-1] * (amount + 1)\n        dp[0] = 0\n        for i in range(1, amount+1):\n            if i in coins:\n                dp[i] = 1\n            else:\n                low = float('inf')\n                for coin in coins:\n                    if i - coin >= 0 and dp[i - coin] != -1:\n                        dp[i] = min(low, 1 + dp[i - coin])\n                        low = min(low, 1 + dp[i - coin])\n        print(dp)\n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #dp_table = {0:0}\n        dp_table = [float('inf')] * (amount+1)\n        dp_table[0] = 0\n        return self.dp(dp_table,coins,amount)\n    \n    def dp(self,dp_table:[float],coins: List[int], amount: int) ->int:\n        if amount == 0:return 0\n        if amount < 0 :return -1\n        if dp_table[amount] != float('inf'):\n            return dp_table[amount]\n        # \u6c42\u6700\u5c0f\u503c\uff1a\n        res = float('inf')\n        for coin in coins:\n            subpb = self.dp(dp_table,coins,amount-coin)\n            if subpb == -1:\n                continue\n            res = min(res,subpb+1)\n        dp_table[amount] = res if res != float('inf') else -1\n        return dp_table[amount]\n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[-1]*(amount+1)\n        dp[0]=0\n        for i in range(1,amount+1):\n\n            for coin in coins[::-1]:\n                j=i-coin\n#                print('i,j,coin=',i,j,coin)\n                if j<0 or dp[j]==-1:\n                    continue\n                if dp[i]==-1:\n                    dp[i]=dp[j]+1\n                else:\n                    dp[i]=min(dp[i],dp[j]+1)\n\n        \n        return(dp[amount])\n    \n    \n    \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = dict()\n        def dp(n):\n            if n in memo: return memo[n]\n            if n == 0: return 0\n            if n < 0: return -1\n            res = 1000\n            for coin in coins:\n                if (dp(n-coin) == -1): continue\n                res = min(res, 1 + dp(n-coin))\n            memo[n] = res if res != 1000 else -1\n            return memo[n]\n        return dp(amount)", "class Solution:\n    memory = {}\n    \n    \n    def numCoins(self, coins, amount):\n        if amount in self.memory:\n            return self.memory[amount]\n                        \n        nc = float('inf')\n        for c in coins:\n            if amount >= c:\n                nnc = self.numCoins(coins, amount - c)                \n                nc = min(nc, nnc+1)           \n            \n        self.memory[amount] = nc\n        return nc        \n    \n                        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.memory = {}\n        self.memory[0] = 0\n        for c in coins:\n            self.memory[c] = 1\n        \n        nc = self.numCoins(coins, amount)\n        if nc == float('inf'):\n            return -1\n        \n        return nc\n        \n            \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        t = [[-1]*(amount+1)]*(len(coins)+1)\n        \n        for i in range(len(t)):\n            for j in range(len(t[0])):\n                if j == 0:\n                    t[i][j] = 0\n                if i == 0:\n                    t[i][j] = float('inf')-1\n        for j in range(1,amount+1):\n            if j % coins[0] == 0:\n                t[1][j] = int(j/coins[0])\n            else:\n                t[1][j] = float('inf') - 1\n        for i in range(2,len(t)):\n            for j in range(2,len(t[0])):\n                if coins[i-1] <= j:\n                    t[i][j] = min(1+t[i][j-coins[i-1]], t[i-1][j])\n                else:\n                    t[i][j] = t[i-1][j]\n        if t[-1][-1] != float('inf'):\n            return t[-1][-1]\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = {}\n        def dfs(amount, path):\n            if amount < 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if amount in memo:\n                return memo[amount]\n            ans = float('inf')\n            for i in coins:\n                r = dfs(amount-i, path+1)\n                if r != float('inf'):\n                    ans = min(ans, r+1)\n            memo[amount] = ans\n            return ans\n        ret = dfs(amount, 0)\n        return ret if ret != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        f = [[float('inf')] * (amount + 1) for _ in range(n + 1)]\n        f[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(amount + 1):\n                f[i][j] = f[i - 1][j]\n                if coins[i - 1] <= j:\n                    f[i][j] = min(f[i][j], 1 + f[i][j - coins[i - 1]])\n        return f[n][amount] if f[n][amount] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        @lru_cache(None)\n        def dfs(amt, idx):\n            # print(amt, idx)\n            if idx < 0:\n                if amt == 0:\n                    return 0\n                else:\n                    return float('inf')\n            if amt < 0:\n                return float('inf')\n            if amt == coins[idx]:\n                return 1\n            return min(dfs(amt - coins[idx], idx) + 1, dfs(amt, idx - 1))\n        res = dfs(amount, len(coins)-1)\n        return res if res < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        for i in range(1,amount+1):\n            for j in coins:\n                if i>=j:\n                    dp[i] = min(dp[i],dp[i-j]+1)\n        return dp[-1] if dp[-1]!=float('inf') else -1", "import math\nclass Solution:\n    trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        if amount < 0:\n            return -1\n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            if required < 0:\n                continue\n            val = self.coinChange(coins, required)\n            if val == -1:\n                continue\n            else:\n                minVal = min(minVal, val + 1)\n        if minVal == math.inf:\n            minVal = -1\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse=True)\n        d = {}\n        for v in coins:\n            d[v] = True\n        min_coin = min(coins)\n        \n        if not coins or not amount:\n            return 0\n        if len(coins) == 1:\n            if amount % coins[0] == 0:\n                return int(amount / coins[0])\n            else:\n                return -1\n        \n        self.memo = {}\n        return self.fewest(coins, amount, d, min_coin)\n    \n    def fewest(self, coins, amount, d_value, min_coin):\n        if amount in self.memo:\n            return self.memo[amount]\n        \n        if amount in d_value:\n            return 1\n        elif amount < min_coin:\n            return -1\n\n        _min = float('inf') \n        for v in coins:\n            left_amount = amount - v\n            if left_amount == 0:\n                _min = min(_min, 1)\n            elif left_amount > 0:\n                ret = self.fewest(coins, left_amount, d_value, min_coin)\n                if ret > 0:\n                    _min = min(_min, ret + 1)\n\n        _min = -1 if _min == float('inf') else _min\n        self.memo[amount] = _min\n        return _min\n", "import math\nclass Solution:\n    def __init__(self):\n        self.trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        \n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            if required < 0:\n                continue\n            val = self.coinChange(coins, required)\n            if val != -1:\n                minVal = min(minVal, val + 1)\n        minVal = -1 if minVal == math.inf else minVal\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        tracker = [float('inf') for i in range(amount)]\n        res = self.coinChange_helper(coins, amount, tracker)\n        print(tracker)\n        if tracker[-1] == float('inf'):\n            return -1\n        return res\n        \n    def coinChange_helper(self, coins:List[int], amount: int, tracking: List[int]) -> int:\n        if amount < 0:\n            return -1\n        \n        if amount == 0:\n            return 0\n        \n        if tracking[amount-1] != float('inf'):\n            return tracking[amount-1]\n        \n        lowest = float('inf')\n        for i in range(len(coins)):\n            result = self.coinChange_helper(coins, amount - coins[i], tracking)\n            if result >= 0 and result+1 < lowest: \n                lowest = result + 1\n            \n        tracking[amount-1] = lowest if lowest != float('inf') else -1\n        return tracking[amount-1]\n    \n        \n                    \n            \n        \n        \n", "class Solution:\n    \n    def do_du_tab(self, coins, amount):\n        dp_tab = [math.inf for _ in range(amount + 1)]\n        dp_tab[0] = 0\n        for i in range(len(coins)):\n            for a in range(1, amount + 1):\n                if a >= coins[i]:\n                    dp_tab[a] = min(dp_tab[a] , 1 + dp_tab[a - coins[i]])\n        return dp_tab[amount]\n\n    \n    def do_td_mem(self, cache, coins, amount, index):\n\n        if amount == 0:\n            return 0\n\n        if len(coins) <= index:\n            return math.inf\n\n        if cache[index][amount] == math.inf:\n            count_keeping_element = math.inf\n            if coins[index] <= amount:\n                temp = self.do_td_mem(cache, coins, amount - coins[index], index)\n                if temp != math.inf:\n                    count_keeping_element = temp + 1\n\n            count_skipping_element = self.do_td_mem(cache, coins, amount, index + 1)\n            cache[index][amount] = min(count_keeping_element, count_skipping_element)\n        return cache[index][amount]\n\n    \n    def do_bf(self, coins, amount, index):\n        if amount == 0:\n            return 0\n        n = len(coins)\n        if n <= index:\n            return math.inf\n\n        count_keeping_element = math.inf\n        if coins[index] <= amount:\n            temp = self.do_bf(coins, amount - coins[index], index)\n            if temp != math.inf:\n                count_keeping_element = temp + 1\n\n        count_skipping_element = self.do_bf(coins, amount, index + 1)\n        return min(count_keeping_element, count_skipping_element)\n                \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #output = self.do_bf(coins, amount, 0)\n        if amount < 1:\n            return 0\n        #cache = [[math.inf for _ in range(amount + 1)] for _ in range(len(coins))] \n        #output = self.do_td_mem(cache, sorted(coins), amount, 0)\n        coins.sort()\n        output = self.do_du_tab(coins, amount)\n        return -1 if output == math.inf else output", "import math\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # want fewest number of coins to form the amount\n        if amount == 0:\n            return 0\n        records = [-2]*amount\n        return helper(amount, coins, records)\n\ndef helper(amount, coins, records):\n    # base\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    \n    # recursive function, iterate, top-down\n    if records[amount - 1] != -2:\n        min_number = records[amount - 1]\n    else:\n        min_number = math.inf\n        for c in coins:\n            val = helper(amount - c, coins, records)\n            if val != -1:\n                val += 1\n                min_number = min(val, min_number)\n#                records[amount - 1] = min_number\n    if min_number == math.inf:\n        records[amount-1] = -1\n        return -1\n    else:\n        records[amount-1] = min_number\n        return min_number\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        two choices, take or dont take\n        DP[i][j], i is index of coin, j is amount\n        \n        take:\n            DP[i][j] = DP[i][j-coins[i]] + 1\n        dont take:\n            DP[i][j] = DP[i-1][j]\n        \n          0 1 2 3 4 5 6 7 8 9 10 11\n        1 0 1 2 3 4 5 6 7 8 9 10 11\n        2 0 1 1 2\n        5    \n        '''\n        \n        dp = [[float('inf')] * (amount+1) for _ in range(len(coins))]\n        for r in range(len(coins)):\n            dp[r][0] = 0\n        \n        for r in range(len(coins)):\n            for c in range(1, amount+1):\n                take = leave = float('inf')\n                if c - coins[r] >= 0:\n                    take = dp[r][c-coins[r]] + 1\n                if r > 0:\n                    leave = dp[r-1][c]                    \n                dp[r][c] = min(leave, take)\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], a: int) -> int:\n        l = len(coins)\n        mem =[]\n        for i in range(l+1):\n            mem.append([0]*(a+1))\n            for j in range(a+1):\n                if i ==0:\n                    mem[i][j] =float('inf')\n                if j==0:\n                    mem[i][j] = 0\n                if i>0 and j>0:\n                    if coins[i-1]<=j:\n                        mem[i][j] = min(1+mem[i][j-coins[i-1]],mem[i-1][j])\n                    else:\n                        mem[i][j] = mem[i-1][j]\n        # /print(len(mem),len(mem[0]))4\n        if mem[l][a]==float('inf'):\n            return -1\n        return  mem[l][a]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        w  = amount\n        \n        t = [[0 for i in range(w+1)] for j in range(n+1)]\n        \n        for i in range(n+1):\n            for j in range(w+1):\n                if i==0:\n                    t[i][j] = float('inf')\n                if j==0:\n                    t[i][j] = 0\n                if i==1 and j>0:\n                    if j%coins[0]==0:\n                        t[i][j] = j//coins[0]\n                    else:\n                        t[i][j] = float('inf')\n\n                    \n              \n              \n        \n        for i in range(2,n+1):\n            for j in range(1,w+1):\n                if coins[i-1]<=j:\n                    t[i][j] = min( t[i-1][j] , 1+t[i][j-coins[i-1]])\n                else:\n                    t[i][j] = t[i-1][j]\n        if t[n][w]== float('inf'):\n            return -1\n        return t[n][w]\n        \n        \n        \n", "import sys\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[-1 for i in range(amount+1)] for j in range(len(coins)+1)]\n        for i in range(len(coins)+1):\n            for j in range(amount+1):\n                if j == 0:\n                    dp[i][j] = 0\n                if i == 0:\n                    dp[i][j] = sys.maxsize - 1\n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1] <= j:\n                    dp[i][j] = min(dp[i-1][j] , dp[i][j - coins[i-1]] + 1)\n                else:\n                    dp[i][j] = dp[i-1][j]\n        if dp[-1][-1] == sys.maxsize - 1:\n            return -1\n        else:\n            return dp[-1][-1]\n\n                    \n        \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[float('inf')]*(amount+1) for i in range(len(coins))]\n        \n        for i in range(len(coins)):\n            for j in range(amount+1):\n                if i == 0:\n                    if j % coins[i] == 0:\n                        dp[i][j] = j // coins[i]\n                    else:\n                        dp[i][j] = float('inf')\n                elif j - coins[i] < 0:\n                    dp[i][j] = dp[i-1][j]\n                elif j == coins[i]:\n                    dp[i][j] = 1\n                elif j > coins[i]:\n                    dp[i][j] = min(1 + dp[i][j - coins[i]],dp[i-1][j])\n        \n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         n = len(coins)\n#         return self.coinChangeHelper(coins, n, amount, {})\n        \n    \n#                #            11\n#                #   10       9        6  => \n#                # 9 8 5   8 7 4    5 4 1 => 1\n#                #                      0 => 0\n#     def coinChangeHelper(self, coins, n, amount, mem):\n#         if amount in mem:\n#             return mem[amount]\n#         if amount == 0:\n#             return 0\n#         if n == 0:\n#             return -1\n        \n#         minCoins = math.inf\n#         for i in range(n):\n#             if coins[i] <= amount:\n#                 numCoins = self.coinChangeHelper(coins, n, amount - coins[i], mem)\n#                 if numCoins != -1:\n#                     minCoins = min(minCoins, numCoins)\n        \n#         if minCoins == math.inf:\n#             mem[amount] = -1\n#         else:\n#             mem[amount] = minCoins + 1\n        \n#         return mem[amount]\n#     [1, 2, 5], amount = 11\n    \n#      0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27\n#  2   0   -1  1   -1  2   -1  3  -1   4   -1  5   -1   6  -1  7   -1  8   -1  9   -1  10  -1  11   \n#  5   0   -1  1  -1   2   1   3   2   \n# 10\n#  1\n    \n    # if coins[i] <= j: dp[i][j] = min(dp[i][j-coins[i]] + 1, dp[i-1][j])\n    # else: dp[i][j] = dp[i-1][j]\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n    \n        dp = [[0 for j in range(amount + 1)] for i in range(n)]\n        \n        for j in range(amount + 1):\n            dp[0][j] = -1 if j % coins[0] else j // coins[0]\n            \n        for i in range(1, n):\n            for j in range(1, amount + 1):\n                includeDenom = -1 if coins[i] > j else dp[i][j-coins[i]]\n                excludeDenom = dp[i-1][j]\n                if includeDenom == -1 and excludeDenom == -1:\n                    dp[i][j] = -1\n                elif includeDenom == -1:\n                    dp[i][j] = excludeDenom\n                elif excludeDenom == -1:\n                    dp[i][j] = includeDenom + 1\n                else:\n                    dp[i][j] = min(includeDenom + 1, excludeDenom)\n                    \n        return dp[n-1][amount]\n                    \n", "# class Solution:\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         min_coins = float('inf')\n#         def backtrack(tot, count):\n#             nonlocal min_coins\n#             if tot == 0:\n#                 min_coins = min(min_coins, count)\n#                 return\n#             for coin in coins:\n#                 if coin <= tot:\n#                     backtrack(tot - coin, count + 1)\n#         backtrack(amount, 0)\n#         return -1 if min_coins == float('inf') else min_coins\n    \n    \nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         bottom-up DP\n        memo = [[float('inf') for _ in range(amount + 1)] for _ in range(len(coins))]\n        for x in range(len(coins)):\n            memo[x][0] = 0        \n        for i, coin in enumerate(coins):            \n            for tot in range(1, amount + 1):\n                if i > 0: \n                    memo[i][tot] = memo[i - 1][tot]\n                if coin <= tot:\n                    memo[i][tot] = min(memo[i][tot], memo[i][tot - coin] + 1)\n        out = memo[len(coins) - 1][amount]\n        return -1 if out == float('inf') else out\n\n        \n#         top-down DP\n        # memo = {}\n        # def backtrack(tot):            \n        #     if tot == 0:\n        #         return 0   \n        #     if tot not in memo:\n        #         min_coins = float('inf')\n        #         for coin in coins:\n        #             if coin <= tot:\n        #                 cur_count = backtrack(tot - coin) + 1\n        #                 min_coins = min(min_coins, cur_count)\n        #         memo[tot] = min_coins\n        #     return memo[tot]\n        # out = backtrack(amount)\n        # return -1 if out == float('inf') else out\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount==0:\n            return 0\n        dp={}\n        coins=sorted(coins)\n        \n#         q=deque()\n#         q.append(amount)\n        \n#         while q:\n#             node=q.popleft()\n#             for coin in coins[::-1]:\n#                 diff=node-coin\n#                 if diff==0:\n#                     return dp[node]+1\n#                 elif diff>0:\n#                     if diff not in dp:\n#                         dp[diff]=1+dp[node]\n#                         q.append(diff)\n\n#         return -1\n                    \n        dp={coin:1 for coin in coins}\n        def helper(amount):\n            if amount==0:\n                return 0\n            \n            if amount in dp:\n                return dp[amount]\n            \n            dp[amount]=float('inf')\n            for i in range(len(coins)-1,-1,-1):\n                if amount-coins[i]>=0:\n                    dp[amount]=min(dp[amount],1+helper(amount-coins[i]))\n                \n            return dp[amount]\n        \n        result=helper(amount)\n        if result==float('inf'):\n            return -1\n        else:\n            return result\n        \n        \n\n                    \n                \n                \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp={}\n        \n        coins=sorted(coins)\n\n        def helper(amount):\n            if amount==0:\n                return 0\n            \n            if amount in dp:\n                return dp[amount]\n            \n            dp[amount]=float('inf')\n            for i in range(len(coins)-1,-1,-1):\n                if amount-coins[i]>=0:\n                    dp[amount]=min(dp[amount],1+helper(amount-coins[i]))\n                \n            return dp[amount]\n        \n        result=helper(amount)\n        if result==float('inf'):\n            return -1\n        else:\n            return result\n        \n        \n\n                    \n                \n                \n        \n", "class Solution:\n    # def coinChange(self, coins: List[int], amount: int) -> int:\n    #     coins = set(coins)\n    #     dp = [float('inf') if i not in coins else 1 for i in range(amount+1)]\n    #     dp[0] = 0\n    #     for coin in coins:\n    #         for i in range(coin, amount+1):\n    #             dp[i] = min(dp[i], dp[i-coin]+1)\n    #     return -1 if dp[amount] == float('inf') else dp[amount]\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = set(coins)\n        dp = [float('inf') if i not in coins else 1 for i in range(amount+1)]\n        result = self.helper(coins, amount,dp) \n        return -1 if result == float('inf') else result\n    \n    def helper(self,coins, amount, dp):\n        if amount < 0:\n            return -1\n        if amount == 0:\n            return 0\n        if dp[amount] != float('inf'):\n            return dp[amount]\n        current_min = float('inf')\n        for coin in coins: \n            result = self.helper(coins,amount-coin,dp)\n            if result != -1:\n                current_min = min(current_min, 1+result)\n        if current_min == float('inf'):\n            dp[amount] = -1\n            return -1\n        dp[amount] = current_min\n        return current_min\n        \n", "import math\nclass Solution:\n    trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        \n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            if required < 0:\n                continue\n            val = self.coinChange(coins, required)\n            if val != -1:\n                minVal = min(minVal, val + 1)\n        if minVal == math.inf:\n            minVal = -1\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "import math\nclass Solution:\n    trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        \n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            if required < 0:\n                continue\n            val = self.coinChange(coins, required)\n            if val != -1:\n                minVal = min(minVal, val + 1)\n        minVal = -1 if minVal == math.inf else minVal\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.amount = amount\n        self.coins = coins \n        n = len(coins)\n        self.memo =[-1]*(self.amount+1)\n        val = self.coindp(amount)\n        if val == float('inf'):\n            return -1\n        else:\n            return val\n        \n    def coindp(self, i):\n        if i <0: return float('inf')\n        if i==0: return 0\n        \n        if self.memo[i]>=0:\n            return self.memo[i]\n        \n        mini = float('inf')\n        for coin in self.coins:\n            mini = min(mini, self.coindp(i-coin)+1)\n        \n        self.memo[i] = mini\n        # print(self.memo)\n        return self.memo[i]\n", "import math\nclass Solution:\n    trellis = None\n    # O(S*n), O(S) for memoisation table\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if self.trellis == None:\n            self.trellis = [math.inf]*(amount+1)\n            self.trellis[0] = 0\n        if amount < 0:\n            return -1\n        if self.trellis[amount] != math.inf:\n            return self.trellis[amount]\n        \n        minVal = math.inf\n        for coin in coins:\n            required = amount-coin\n            val = self.coinChange(coins, required)\n            if val == -1:\n                continue\n            else:\n                minVal = min(minVal, val + 1)\n        if minVal == math.inf:\n            minVal = -1\n        self.trellis[amount] = min(self.trellis[amount], minVal)\n        return minVal\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def dfs(start, amount, n_coins):\n            coin = coins[start]\n            div = amount // coin\n            amount %= coin\n            n_coins += div\n            \n            if amount == 0:\n                self.minimum = min(n_coins, self.minimum)\n                return\n            \n            if start < length:\n                dfs(start + 1, amount, n_coins)\n                next_coin = coins[start + 1]\n                for _ in range(div):\n                    amount += coin\n                    n_coins -= 1\n                    \n                    if (self.minimum - n_coins - 1) * next_coin + 1 > amount:\n                        dfs(start + 1, amount, n_coins)\n                    else:\n                        break\n        coins.sort(reverse=True)\n        self.minimum = float('inf')\n        length = len(coins) - 1\n        dfs(0, amount, 0)\n        return self.minimum if self.minimum < float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount==0:\n            return 0\n            \n        coins.sort(reverse=True)\n        res = amount//coins[-1]+1\n        def comb(cursum, num, index):\n            nonlocal res\n            if (amount-cursum)/coins[index] >= res-num:\n                return\n            \n            for i in range(index, len(coins)):\n                newsum = cursum + coins[i]\n                if newsum==amount:\n                    res=min(num+1, res)\n                    return              \n                elif newsum < amount:\n                    comb(newsum, num+1, i)\n                    \n        comb(0, 0, 0)\n        if res==amount//coins[-1]+1:\n            return -1\n        return res\n                    \n", "class Solution:\n    def coinChange(self, coin: List[int], sum1: int) -> int:\n        maxv=float('inf')-1\n        n=len(coin)\n        t=[[0 for j in range(sum1+1)] for i in range(n+1)]\n        for i in range(n+1):\n            for j in range(sum1+1):\n                if i==0 and j==0:\n                    t[i][j]=maxv\n                elif j==0:\n                    t[i][j]=0\n                elif i==0:\n                    t[i][j]=maxv\n        for i in range(1,n+1):\n            for  j in range(1,sum1+1):\n                if coin[i-1]<=j:\n                    t[i][j]=min(t[i][j-coin[i-1]]+1,t[i-1][j])\n                else:\n                    t[i][j]=t[i-1][j]\n        if t[n][sum1]==float('inf'):\n            return -1\n        return t[n][sum1]\n      \n            \n                \n        \n        \n", "import math\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not coins:\n            return -1\n        \n        if amount == 0:\n            return 0\n        \n        memo = [0] * amount\n        def findNumCoins(remainingAmount: int) -> int:\n            nonlocal memo\n\n            if remainingAmount < 0:\n                # overshot.\n                return -1\n            if remainingAmount == 0:\n                return 0\n            memo_idx = remainingAmount - 1\n            if memo[memo_idx] != 0:\n                return memo[memo_idx]\n            \n            local_min = math.inf\n            for coin in coins:\n                res = findNumCoins(remainingAmount - coin)\n                if res >= 0:\n                    local_min = min(local_min, 1 + res)\n            num_coins = -1 if local_min == math.inf else local_min\n            memo[memo_idx] = num_coins\n            return num_coins\n                    \n        return findNumCoins(amount)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[0]*(amount+1)\n        for i in range(1, amount+1):\n            minn=float('inf')\n            for j in coins:\n                if i==j:\n                    minn=min(minn, 1)\n                    continue\n                if i-j>0:\n                    minn=min(minn, 1+dp[i-j])\n            dp[i]=minn\n        return dp[amount] if dp[amount]!=float('inf') else -1\n#         if amount==0:\n#             return 0\n#         if amount<0:\n#             return -1\n#         minn=float('inf')\n#         for i in coins:\n#             count=self.coinChange(coins, amount-i)\n#             if count!=-1:\n#                 minn=min(count+1, minn)\n\n#         return minn if minn!=float('inf') else -1\n", "class Solution:   \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        \n        self.count = [float('inf')]*(amount + 1)\n        self.count[0] = 0\n        # print(count)\n        \n        for i in range(1, amount + 1):\n            for coin in coins:\n                rest = i - coin\n                if rest >= 0 and self.count[rest] != float('inf'):\n                    self.count[i] = min(1 + self.count[rest], self.count[i])\n                    \n        if self.count[-1] == float('inf'): \n            return -1\n        else:\n            return self.count[-1]\n    \n\n                \n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[math.inf for i in range(amount + 1)] for i in range(len(coins))]\n        for i in range(len(coins)):\n            dp[i][0] = 0\n        for i in range(len(coins)):\n            for j in range(amount + 1):\n                if i > 0:\n                    dp[i][j] = dp[i - 1][j]\n                if j >= coins[i]:\n                    dp[i][j] = min(dp[i][j], dp[i][j - coins[i]] + 1)\n        return -1 if dp[-1][-1] == math.inf else dp[-1][-1]\n        \n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[float('inf') for i in range(amount+1)] for j in range(len(coins)+1)]\n        for i in range(len(coins)+1):\n            dp[i][0] = 0\n\n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-coins[i-1]]+1)\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[amount+1 for j in range(n+1)] for i in range(amount+1)]\n        for j in range(n+1):\n            dp[0][j] = 0\n        for i in range(1, amount+1):\n            for j in range(1, n+1):\n                c = coins[j-1]\n                if c > i:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = min(dp[i-c][j]+1, dp[i][j-1])\n            \n        return dp[amount][n] if dp[amount][n] < amount+1 else -1", "from functools import lru_cache\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dict_ = set(coins)\n        count = [0]*amount\n        # Top down approach\n        def top_down(rem):\n            if rem < 0:\n                return -1\n            if rem == 0:\n                return 0\n            if count[rem - 1] != 0: # cache\n                return count[rem - 1];\n            \n            min_ = float('inf')\n            \n            for coin in dict_:\n                res = top_down(rem - coin)\n                if res >= 0:\n                    min_ = min(1 + res, min_)\n            \n            count[rem - 1] = -1 if min_ == float('inf') else min_\n            return count[rem - 1]\n        \n    \n        # bottom up approach\n        def bottom_up():\n            dpa = [float('inf')] * (amount + 1)\n            dpa[0] = 0\n\n            for i in range(1, len(dpa)):\n                for coin in dict_:\n                    if i >= coin:\n                        remainder = i - coin\n                        dpa[i] = min(dpa[remainder] + 1, dpa[i])\n            return dpa[amount] if dpa[amount] != float('inf') else -1 \n        \n        \n        return bottom_up()\n        # return top_down(amount)    \n        \n\n    \n    \n        \n        \n        \n                \n            \n            \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount:\n            return 0\n        coins.sort()\n        self.coins = coins\n        self.memo = {}\n        self.recursion(amount)\n        return -1 if self.memo[amount] == float('inf') else self.memo[amount]\n        \n    \n    def recursion(self, amt):\n        min_coins = float('inf')\n        if amt == 0:\n            return 0\n        if amt in self.memo:\n            return self.memo[amt]\n        for coin in self.coins:\n            if coin > amt:\n                break\n            x = self.recursion(amt - coin)\n            min_coins = min(min_coins, x)\n        self.memo[amt] = 1 + min_coins\n        return self.memo[amt]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount: return 0\n        if amount in coins: return 1\n        dp = [float('inf')] * (amount+1)\n        for coin in coins:\n            if coin < amount:\n                dp[coin] = 1\n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin < i:\n                    dp[i] = min(dp[i], dp[i-coin]+1)\n        return dp[-1] if dp[-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        N = len(coins)\n        mem = [[None for i in range(amount+1)] for j in range(N+1)]\n        \n        def helper(target,i):\n            if mem[i][target]!=None:\n                return mem[i][target]\n            if(target==0):\n                return 0\n            \n            if(i==N and target>0):\n                return float('inf')\n          \n            \n            if(coins[i]>target):\n                mem[i][target] = helper(target,i+1)\n            else:\n                include = 1+helper(target-coins[i],i)\n                exclude = helper(target,i+1)\n                mem[i][target] = min(include,exclude)    \n            \n            return mem[i][target]\n        \n        ans = (helper(amount,0))\n        return ans if ans!=float('inf') else -1 ", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        count = collections.defaultdict(int)\n        def coinChangeHelper(coins, rem, count):\n            if rem < 0:\n                return -1\n            if rem == 0:\n                return 0\n            if count[rem] != 0:\n                return count[rem]\n            minCount = 2**32\n            for coin in coins:\n                makeChange = coinChangeHelper(coins, rem - coin, count)\n                if makeChange > -1 and makeChange < minCount:\n                    minCount = makeChange + 1\n            \n            count[rem] = -1 if minCount == 2 ** 32 else minCount\n            return count[rem]\n        \n        return coinChangeHelper(coins, amount, count)", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1 for _ in range(0, amount + 1)]\n        dp[0] = 0\n        for i in range(0, amount + 1):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i], 1+dp[i-coin])\n        if dp[-1] <= amount:\n            return dp[-1]\n        else:\n            return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')]*(amount+1)\n        dp[0] = 0\n        for c in coins:\n            for amt in range(c, amount+1):\n                dp[amt] = min(dp[amt], 1 + dp[amt-c])\n        \n        return dp[amount] if dp[amount] < float('inf') else -1", "class Solution:\n\n    def coinChange(self, coins, amount):\n        coins.sort()\n        stack = [(0, 0, len(coins))] # steps, accumulated\n        min_steps = 2**31\n        while len(stack) != 0:\n            steps, accumulated, sequence = stack.pop()\n            if accumulated == amount:\n                min_steps = min(min_steps, steps)\n            if accumulated > amount or amount - accumulated > coins[sequence-1] * (min_steps-steps):\n                continue\n            for seq, coin in enumerate(coins[:sequence]):\n                stack.append((steps+1, accumulated+coin, seq+1))\n        return min_steps if min_steps != 2**31 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [sys.maxsize] * amount\n        \n        for i in range(1, amount + 1):\n            for coin in sorted(coins):\n                if i < coin:\n                    break\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n        \n        return -1 if dp[-1] == sys.maxsize else dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[0 for j in range(amount+1)] for i in range(len(coins)+1)]\n        \n        for i in range(len(coins)+1):\n            dp[i][0]=0\n        for j in range(1,amount+1):\n            dp[0][j]=float('inf')-1\n        \n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    dp[i][j] = min(dp[i-1][j],1+ dp[i][j-coins[i-1]])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return dp[len(coins)][amount] if dp[len(coins)][amount] != float('inf') else -1 \n        '''\n        def coin_change_2(coins,n,amount):\n            if n==0:\n                return float('inf')-1\n            if amount==0:\n                return 0\n            if coins[n-1]<=amount:\n                return min(coin_change_2(coins,n-1,amount),1+coin_change_2(coins,n,amount-coins[n-1]))\n            else:\n                return coin_change_2(coins,n-1,amount)\n        \n        n=len(coins)\n        ans = coin_change_2(coins,n,amount)\n        return ans if ans  != float('inf') else -1\n        '''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [math.inf] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1, amount+1):\n            for c in coins: \n                if i-c >= 0: \n                    dp[i] = min(dp[i], dp[i-c] + 1)\n        return dp[amount] if dp[amount] != math.inf else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [[math.inf for _ in range(amount+1)] for _ in coins]\n        \n        for i in range(len(coins)):\n            dp[i][0] = 0\n        \n        for i in range(1, amount+1):\n            if coins[0] <= i:\n                dp[0][i] = 1 + dp[0][i-coins[0]]\n                \n        for i in range(1, len(coins)):\n            for j in range(1, amount+1):\n                take, leave = math.inf, math.inf\n                if coins[i] <= j:\n                    take = 1 + dp[i][j-coins[i]]\n                leave = dp[i-1][j]\n                dp[i][j] = min(take, leave)\n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        if len(coins) == 0:\n            return 0\n        coins = sorted(coins, reverse=True)\n        memo = {}\n\n        def coinChangeRec(index, amount):\n            if amount == 0:\n                return 0\n            if amount < 0 or index == len(coins):\n                return math.inf\n            if (index, amount) in memo:\n                return memo[(index, amount)]\n            \n            withCoin = coinChangeRec(index, amount - coins[index]) + 1\n            withoutCoin = coinChangeRec(index+1, amount)\n            \n            memo[(index, amount)] = min(withCoin, withoutCoin)\n            return min(withCoin, withoutCoin)\n                     \n        minCoins = coinChangeRec(0, amount)\n        if minCoins == math.inf:\n            return -1\n        return minCoins\n    \n", "class Solution:\n    def aux(self, coins, amount, cache):\n        if amount in cache: \n            return cache[amount]\n\n        \n        res = -1\n        for i in range(len(coins)):\n            if coins[i] < amount:\n                right = cache[amount-coins[i]] if amount-coins[i] in cache else self.aux(coins, amount-coins[i], cache)\n                \n                if right!=-1 and res==-1:\n                    res = 1+right\n                elif right!=-1 and res!=-1:\n                    res = min(res, 1+right)\n                    \n                \n        \n        cache[amount] = res\n        return cache[amount]\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount==0: return 0\n        cache = dict(list(zip(coins, [1]*len(coins))))\n        return self.aux(coins, amount, cache)\n        \n        \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i] means how many coins we need to make up i money\n        # formula: dp[i] = min(dp[i - k] + 1 for k in coins)\n        # start point: dp[i] = 1 if i in coins\n        # we can add a 1 offset here since dp[0] doesn't make any sense\n        if not amount:\n            return 0\n        dp = [-1 for _ in range(amount)]\n        coins = set(coins)\n        for i in range(amount):\n            if (i + 1) in coins:\n                dp[i] = 1\n                continue\n            for coin in coins:\n                if (i - coin) >= 0 and dp[i - coin] != -1:\n                    if dp[i] == -1:\n                        dp[i] = dp[i - coin] + 1\n                    else:\n                        dp[i] = min(dp[i], dp[i - coin] + 1)   \n        return dp[-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n        if len(coins) == 0:\n            return 0\n        coins = sorted(coins, reverse=True)\n        memo = {}\n\n        def coinChangeRec(index, amount):\n            if amount == 0:\n                return 0\n            if amount < 0 or index == len(coins):\n                return math.inf\n            if (index, amount) in memo:\n                return memo[(index, amount)]\n            \n            withCoin = coinChangeRec(index, amount - coins[index]) + 1\n            withoutCoin = coinChangeRec(index+1, amount)\n            \n            memo[(index, amount)] = min(withCoin, withoutCoin)\n            return min(withCoin, withoutCoin)\n                     \n        minCoins = coinChangeRec(0, amount)\n        if minCoins == math.inf:\n            return -1\n        return minCoins\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dic = {0:0}\n        \n        def change(amount):\n            if amount < 0: return -1\n            if amount in dic: return dic[amount]\n            res = [change(amount - i) for i in coins if change(amount - i) >= 0]\n            if not res:\n                dic[amount] = -1\n            else:\n                dic[amount] = min(res) + 1\n            return dic[amount]\n        \n        return change(amount)", "class Solution:\n    def __init__(self):\n        self.table = {}\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount < 0:\n            return -1\n        if amount == 0:\n            return 0\n        if amount in self.table:\n            return self.table[amount]\n        possible_answers = [self.coinChange(coins, amount - coin) + 1 for coin in coins]\n        possible_answers = [ans for ans in possible_answers if ans >= 1]\n        if possible_answers:\n            ans = min(possible_answers)\n        else:\n            ans = -1\n        self.table[amount] = ans\n        return ans", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # dp[i][j] represents minimum coins needed to change i amount using upto jth coins\n        # dp[i][j] = min(dp[i][j-1], dp[i-coins[j]][j])\n        \n        sz = len(coins)+1\n        dp = [[sys.maxsize] * sz for _ in range(amount+1)]\n        \n        for i in range(sz):\n            dp[0][i] = 0\n    \n        for a in range(1, amount+1):\n            for i in range(1, sz):\n                dp[a][i] = dp[a][i-1]\n                if a-coins[i-1] >= 0:\n                    dp[a][i] = min(1 + dp[a-coins[i-1]][i], dp[a][i])\n        \n  \n        return -1 if dp[amount][sz-1] == sys.maxsize else dp[amount][sz-1]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if not amount or not coins:\n            return 0\n        \n        dp = [[math.inf for _ in range(amount + 1)] for _ in range(len(coins))]\n        \n        for i in range(len(coins)):\n            dp[i][0] = 0\n            \n        for i in range(1, amount + 1):\n            if coins[0] <= i:\n                dp[0][i] = 1 + dp[0][i-coins[0]]\n        for i in range(1, len(coins)):\n            for j in range(1, amount + 1):\n                take, leave = math.inf, math.inf\n                if coins[i] <= j:\n                    take = 1 + dp[i][j-coins[i]]\n                leave = dp[i-1][j]\n                dp[i][j] = min(take, leave)\n        return dp[-1][-1] if dp[-1][-1] != math.inf else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = dict()\n        def dp(n):\n            if n in memo:\n                return memo[n]\n            if n == 0:\n                return 0\n            if n < 0:\n                return -1\n            res = float('inf')\n            for coin in coins:\n                sub = dp(n - coin)\n                if sub == -1:\n                    continue\n                res = min(res, dp(n - coin) + 1)\n            memo[n] = res if res != float('inf') else -1\n            return memo[n]\n        return dp(amount)", "class Solution:\n    def coinChange(self, coin: List[int], amount: int) -> int:\n        \n        dp = [ [ 9999999 for _ in range(amount+1)] for _ in range(len(coin)+1) ]\n        # dp[i][j] will store min coins reqd to reach value j with coins coin[:i+1]\n        \n        for i in range(1, len(coin)+1):\n            dp[i][0] = 0   # don't need any coins to hit balance 0........\n            \n        for i in range(1, len(coin)+1):\n            for j in range(1, amount+1):\n                if j>=coin[i-1]:\n                    dp[i][j] = min( dp[i][j-coin[i-1]]+1, dp[i-1][j], dp[i-1][j-coin[i-1]]+1)\n                else:\n                    dp[i][j] = dp[i-1][j]\n                \n        if dp[-1][-1]==9999999:\n            return -1\n        return dp[-1][-1]        ", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        dp = [amount]*(amount+1)\n        dp[0] = 0\n        pos = 1\n        contain = False\n        while pos < len(dp):\n            for coin in coins:\n                if coin == 1:\n                    contain = True\n                if pos - coin >= 0:\n                    dp[pos] = min(dp[pos],dp[pos-coin]+1)\n            pos+=1\n        print(dp)\n        if dp[-1] == amount and not contain:\n            return -1\n        return dp[-1]\n            \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], a: int) -> int:\n        if(a==0):\n            return 0\n        dp=[-1 for i in range(a+1)] \n        dp[0]=1\n        # for i in range(a+1):\n            # dp[0][i]=10**9\n        # for i in range(len(coins)+1):\n            # dp[i][0]=10**9\n        coins.sort()\n        for i in range(1,len(coins)+1):\n            for j in range(1,a+1):\n                if(coins[i-1]==j):\n                    dp[j]=1\n                else:\n                        c=-1\n                        if(j-coins[i-1]>0 and dp[j-coins[i-1]]!=-1):\n                            c=dp[j-coins[i-1]]+1\n                        d=dp[j]\n                        if(c!=-1 and d!=-1):\n                            dp[j]=min(c,d)\n                        elif(c==-1 and d!=-1):\n                            dp[j]=d\n                        elif(c!=-1):\n                            dp[j]=c\n                        \n        # print(dp) \n        if(dp[a]==-1):\n            return -1\n        else:\n            # ans=0\n            return dp[a]\n            \n            \n                    \n                \n", "class Solution:\n    def coinChange(self,coins,amount):\n        if amount < 1:\n            return 0\n\n        def count_change(coins,amount,dic={}):\n            if amount < 0:\n                return -1\n            if amount == 0:\n                return 0\n            if amount in dic:\n                return dic[amount]\n            minimum = float('inf')\n\n            for i in range(len(coins)):\n                current = count_change(coins, amount-coins[i],dic)\n                if current >=0 and current < minimum:\n                    minimum = 1 + current\n            if minimum == float('inf'):\n                dic[amount] = -1\n            else:\n                dic[amount] = minimum\n            return dic[amount]\n        \n        return count_change(coins,amount,{})", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        dp = [[float('inf') for _ in range(amount+1)] for _ in range(len(coins)+1)]\n\n        for c in range(1, len(dp)):\n            dp[c][0] = 0\n            for amt in range(1, len(dp[0])):\n                if amt - coins[c-1] >= 0:\n                        dp[c][amt] = min(1 + dp[c][amt-coins[c-1]], dp[c-1][amt])\n                else:\n                    dp[c][amt] = dp[c-1][amt]\n\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[amount+1 for j in range(n+1)] for i in range(amount+1)]\n        for j in range(n+1):\n            dp[0][j] = 0\n        for i in range(1, amount+1):\n            for j in range(1, n+1):\n                if coins[j-1] > i:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = min(dp[i-coins[j-1]][j]+1, dp[i][j-1])\n            \n        return dp[amount][n] if dp[amount][n] < amount+1 else -1", "class Solution:\n    def __init__(self):\n        self.count = []\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if len(self.count) < amount:\n            self.count = [-1]* (amount+1)\n            self.skip = [False]* (amount+1)\n            \n        if amount is 0:\n            return 0\n        elif amount < 0:\n            return -1\n        else:\n            if self.count[amount] < 0 and not self.skip[amount]:\n                tmp = float('inf')\n                for co in coins:\n                    previous = self.coinChange(coins, amount - co)\n                    if previous >= 0:\n                        self.count[amount] = min(previous + 1, tmp)\n                        tmp = self.count[amount]\n                    else:\n                        continue\n                self.skip[amount] = True\n                \n            return self.count[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # coins.sort()\n        # min_coins = [math.inf]*(amount+1)\n        # min_coins[0] = 0\n        # for coin in coins:\n        #     for amount in range(coin,amount+1):\n        #         min_coins[amount] = min(min_coins[amount], min_coins[amount-coin]+1)\n        # # print(min_coins)\n        # if min_coins[-1] == math.inf:\n        #     return -1\n        # else: return min_coins[-1]\n        cache = {}\n        def subproblem(i,t):\n            if t == 0:\n                return 0\n            if (i,t) in cache:\n                return cache[(i,t)]\n            val = coins[i]\n            if val > t:\n                choice_take = math.inf\n            elif val == t:\n                choice_take = 1\n            else:\n                choice_take = 1 + subproblem(i,t-val)\n                \n            if i == 0:\n                choice_leave = math.inf\n            else:\n                choice_leave = subproblem(i-1,t)\n            optimal = min(choice_take, choice_leave)\n            cache[(i,t)] = optimal\n            return optimal\n        \n        mincoins = subproblem(len(coins)-1, amount)\n        if mincoins == math.inf:\n            return -1\n        else:\n            return mincoins\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        t=[[0 for x in range(amount+1)] for  x in range(len(coins)+1)]\n        for j in range(amount+1):\n            t[0][j]=1000\n            \n        for i in range(1,len(coins)+1):\n            t[i][0]=0\n            \n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if j%coins[i-1]==0:\n                    t[i][j]=j/coins[i-1]\n                else:\n                    t[i][j]=1000\n                    \n        for i in range(1,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    t[i][j]=min(t[i][j-coins[i-1]]+1,t[i-1][j])\n                else:\n                    t[i][j]=t[i-1][j]\n        if t[len(coins)][amount]!=1000:\n            return t[len(coins)][amount]\n        return -1\n            \n                \n    \n                    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.res = float('inf')\n        n = len(coins)\n        coins.sort(reverse=True)\n        \n        def helper(cur, start, cnt, n):\n            if cur==amount: self.res = min(self.res, cnt)\n            if cur>amount: return \n            \n            for i in range(start, n):\n                if cur+coins[i]<=amount and cur+coins[i]*(self.res-cnt)>amount:\n                    helper(cur+coins[i], i, cnt+1, n)   \n            \n        helper(0, 0, 0, n)\n        return self.res if self.res<float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        \n        for i in range(1,amount+1):\n            for coin in coins:\n                if (i >= coin):\n                    dp[i] = min(dp[i], dp[i - coin] + 1)        \n        return dp[amount] if dp[amount] != float('inf') else -1 \n\n# Went through Approach 2 and 3\n# Similar to Word Break \n", "class Solution:\n    def coinChange(self, coins: List[int], target: int) -> int:\n\n        table = [[float('inf') for _ in range(target+1)] for _ in range(len(coins)+1)]\n    \n        for i in range(len(coins)+1):\n            table[i][0] = 0\n        for i in range(1, len(coins)+1):\n            for j in range(target+1):\n                if coins[i-1] <= j:\n                    a = 1 + table[i][j-coins[i-1]]\n                else:\n                    a = float('inf')\n                b = table[i-1][j]\n                table[i][j] = min(a, b)\n\n        return table[-1][-1] if table[-1][-1] != float('inf') else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #d(m,n) indicates using upto the first m kinds of coins, the number of fewest coins needed to make up to n\n        coins.sort()\n        n = len(coins)\n        \n        d = [[-1] * (amount + 1) for i in range(n + 1)]\n        \n        for i in range(amount + 1):\n            if i % coins[0] == 0:\n                d[1][i] = i // coins[0]\n        for i in range(n + 1):\n            d[i][0] = 0\n        for i in range(2, n + 1):\n            for j in range(1, amount + 1):\n                if j - coins[i - 1] >= 0:\n                    if d[i - 1][j] != -1 and d[i][j - coins[i - 1]] != -1:\n                        d[i][j] = min(d[i - 1][j], d[i][j - coins[i - 1]] + 1)\n                    elif d[i - 1][j] == -1 and d[i][j - coins[i - 1]] != -1:\n                        d[i][j] = d[i][j - coins[i - 1]] + 1\n                    elif d[i - 1][j] != -1 and d[i][j - coins[i - 1]] == -1:\n                        d[i][j] = d[i - 1][j]\n                    else:\n                        d[i][j] = d[i - 1][j]\n                else:\n                    d[i][j] = d[i - 1][j]\n\n        return d[n][amount]\n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #coin exchange\n        # coins = [3,5,6]\n        # amount = 9\n        \n        coins.sort()\n        n_coins = len(coins)\n        least_coin = coins[0]\n        max_amount = amount + 1\n\n        mat = [[0 for i in range(amount+1)] for i in range(n_coins+1)]\n\n        if amount == 0:\n            return 0\n        \n        if amount < least_coin:\n            return (-1)\n\n        for i in range(amount+1):\n            if i % least_coin == 0:\n                mat[1][i] = i // least_coin\n            else:\n                mat[1][i] = -1\n\n        for i in range(2,n_coins+1):\n            for j in range(1,amount+1):                \n                curr_coin = coins[i-1]\n                if j - curr_coin >= 0:\n                    if mat[i][j - curr_coin] == -1:\n                        mat[i][j] = mat[i-1][j]\n                    elif mat[i-1][j] == -1:\n                        mat[i][j] = 1 + mat[i][j - curr_coin]\n                    elif mat[i][j - curr_coin] == -1 and mat[i-1][j] == -1:\n                        mat[i][j] = -1\n                    else:\n                        mat[i][j] = min(1 + mat[i][j - curr_coin], mat[i-1][j])\n                else:\n                    mat[i][j] = mat[i-1][j]\n        # print('-'*20)\n        # for row in mat:\n        #     print(row)\n        return mat[-1][-1]\n", "\nclass Solution:\n    def back_tracking_solution(self):\n        def _is_solution(amount_left):\n            if amount_left == 0:\n                return True\n            return False\n        \n        def _process_solution(num_coins_used, fewest_coins):\n            if num_coins_used < fewest_coins[0]:\n                fewest_coins[0] = num_coins_used\n        \n        def _candidate_coins_start_idx(amount_left, coins, current_coin_start_idx):                 \n            for i in range(current_coin_start_idx, len(coins)):\n                if amount_left >= coins[i]:\n                    return i\n                \n            return None\n        \n        def _backtrack(amount_left, num_coins_used, current_fewest_coins, coins, current_coin_start_idx):\n            if _is_solution(amount_left):\n                _process_solution(num_coins_used, current_fewest_coins)\n            else:\n                real_coin_start_idx = _candidate_coins_start_idx(amount_left, coins, current_coin_start_idx)\n                if real_coin_start_idx is not None:\n                    for i in range(real_coin_start_idx, len(coins)):\n                        _backtrack(amount_left - coins[i], num_coins_used + 1, current_fewest_coins, coins, i)\n        \n        return _backtrack\n    \n    def dynamic_programming_solution(self):\n        def _dp_bad(amount, coins):\n            sorted_coins = sorted(coins)\n            cache = [[float('inf')] * len(coins) for i in range(amount + 1)]\n            \n            for denom_idx in range(len(sorted_coins)):\n                cache[0][denom_idx] = 0\n            \n            for amt in range(amount + 1):\n                cache[amt][0] = (amt // sorted_coins[0]) if ((amt % sorted_coins[0]) == 0) else float('inf')\n            \n            #print(f'first: {cache}')\n            for i in range(1, len(cache)):\n                for j in range(1, len(sorted_coins)):\n                    max_num_of_denom = (i // sorted_coins[j]) + 1\n                    for k in range(max_num_of_denom):\n                        #print(f'BEFORE: i: {i}, j:{j}, k: {k}, each: {cache}')\n                        cache[i][j] = min(cache[i][j], k + cache[i - (k*sorted_coins[j])][j-1])\n                        #print(f'AFTER: i: {i}, j:{j}, k: {k}, each: {cache}')\n                        \n            \n            #for idx, change in enumerate(cache):\n                #print(f'amount: {idx}, change: {change}')\n            \n            return cache[amount][-1]\n        \n        def _dp_cache_recursive(amount, coins, cache):\n            if amount in cache:\n                return cache[amount]\n            \n            for c in coins:\n                if (amount >= c):\n                    intermediate = 1 + _dp_cache_recursive(amount - c, coins, cache)\n                    if amount in cache:\n                        cache[amount] = min(cache[amount], intermediate)\n                    else:\n                        cache[amount] = intermediate\n            \n            return cache[amount] if (amount in cache) else float('inf')\n    \n        def _dp_bottom_up_1(amount, coins):\n            sorted_coins = sorted(coins)\n            \n            cache = [[float('inf')] * len(coins) for i in range(amount + 1)]\n            \n            for denom_idx in range(len(sorted_coins)):\n                cache[0][denom_idx] = 0\n            \n            for amt in range(1, len(cache)):\n                for denom_idx in range(len(sorted_coins)):\n                    amt_left = amt - sorted_coins[denom_idx]\n                    \n                    if (amt_left >= 0):\n                        cache[amt][denom_idx] = 1 + min(cache[amt_left][0:(denom_idx + 1)])\n            \n            #for amt, num in enumerate(cache):\n                #print(f'amount: {amt}, num: {num}')\n            \n            return min(cache[amount])\n        \n        return _dp_bottom_up_1\n        \n        \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # backtracking solution\n        # fewest_coins = [float('inf')]\n        # coins_sorted_desc = sorted(coins, reverse = True)\n        # self.back_tracking_solution()(amount, 0, fewest_coins, coins_sorted_desc, 0)\n        # return -1 if fewest_coins[0] == float('inf') else fewest_coins[0]\n    \n        # Dynamic Programming - recursive call result caching\n        # result = self.dynamic_programming_solution()(amount, coins, cache = {0: 0})\n        # return -1 if (result == float('inf')) else result\n        \n        # Dynamic Programming - non-recursive bottom-up version 1\n        result = self.dynamic_programming_solution()(amount, coins)\n        return -1 if (result == float('inf')) else result", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n        coins = sorted(coins, reverse=True)\n        memo = {}\n\n        def coinChangeRec(index, amount):\n            if amount == 0:\n                return 0\n            if amount < 0 or index == len(coins):\n                return math.inf\n            if (index, amount) in memo:\n                return memo[(index, amount)]\n            \n            withCoin = coinChangeRec(index, amount - coins[index]) + 1\n            withoutCoin = coinChangeRec(index+1, amount)\n            \n            memo[(index, amount)] = min(withCoin, withoutCoin)\n            return min(withCoin, withoutCoin)\n                     \n        minCoins = coinChangeRec(0, amount)\n        if minCoins == math.inf:\n            return -1\n        return minCoins\n    \n", "import queue\n\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        \n        q = queue.Queue()\n        q.put(amount)\n        q.put(None)\n        level = 0\n        visited = {amount}\n        while not q.empty():\n            num = q.get()\n            if num is None:\n                if q.empty():\n                    break\n                q.put(None)\n                level += 1\n                continue\n            for coin in coins:\n                if num - coin > 0 and (num - coin) not in visited:\n                    q.put(num - coin)\n                    visited.add(num - coin)\n                elif num - coin == 0:\n                    return level+1\n        \n        return -1\n        \n        \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        lenc, self.res = len(coins), 2**31-1\n\n        def dfs(pt, rem, count):\n            if not rem:\n                self.res = min(self.res, count)\n            for i in range(pt, lenc):\n                if coins[i] <= rem < coins[i] * (self.res-count): # if hope still exists\n                    dfs(i, rem-coins[i], count+1)\n\n        for i in range(lenc):\n            dfs(i, amount, 0)\n        return self.res if self.res < 2**31-1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        m = Counter(coins)\n\n        def recurse(left, count) -> int:\n            if left in m:\n                return m[left]\n            \n            if left == 0:\n                m[left] = count\n                return count\n            \n            smallest = math.inf\n            for c in coins:\n                if left - c >= 0:\n                    smallest = min(smallest, recurse(left-c, count+1))\n                \n            m[left] = smallest+1\n            return smallest+1\n\n        recurse(amount,0)\n\n        if m[amount] == math.inf:\n            return -1\n        return m[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        table = [float('inf') for _ in range(amount + 1)]\n        i = 0\n        table[0] = 0\n        for coin in coins:\n            if coin <= amount:\n                table[coin] = 1\n        while i <= amount:\n            for coin in coins:\n                if  i - coin >= 0:\n                    table[i] = min(table[i - coin] + 1, table[i])\n            i += 1\n        return table[amount] if table[amount] != float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0]*(amount + 1)\n        for i in range(1, len(dp)):\n            small = float('inf')\n            for j in range(len(coins) - 1, -1, -1):\n                if (i - coins[j] >= 0):\n                    small = min(small, 1 + dp[i - coins[j]])\n            dp[i] = small\n        return dp[-1] if dp[-1] != float('inf') else -1", "import math\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.c = set([x for x in coins if x<=amount])\n        self.coins = list(self.c)\n        self.dic = {}\n        if amount == 0: return 0\n        if amount in self.c: return 1\n        res = math.inf\n        for i in range(len(self.coins)):\n            ci = self.dp(amount-self.coins[i])\n            if ci >0:\n                res = min(res, ci+1)\n        return res if res != math.inf else -1\n\n    def dp(self, amount):\n        if amount in self.c:\n            return 1\n        if amount in self.dic:\n            return self.dic[amount]\n        list2 = [x for x in self.coins if x<=amount]\n        if len(list2) == 0:\n            return -1\n        res = math.inf\n        for i in range(len(list2)):\n            ci = self.dp(amount-list2[i])\n            if ci >0:\n                res = min(res, ci+1)\n        self.dic[amount] = res\n        return res", "class Solution:\n    def __init__(self):\n        self.cache = dict()\n\n    # some key takeaways again:\n    # need to reverse sort because of the problem - trying to find min, so need to cache for min\n    # because if get a cache hit then it won't search for more, even if it's not min\n    \n    # the dfs structure here helps because doing a min over a for loop\n    def helper(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        coins = sorted(coins,reverse=True)\n        if amount in self.cache:\n            return self.cache[amount]\n        if amount in coins:\n            return 1\n        potentials = [float('inf')]\n        for coin in coins:\n            if amount > coin:\n                potentials.append(self.helper(coins,amount - coin))\n        res = 1 + min(potentials)\n        self.cache[amount] = res\n        return res\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        res = self.helper(coins,amount)\n        if res == float('inf'):\n            return -1\n        return res\n        \n", "class Solution:\n    def helper(self, coins, amount, cache, current = []):\n        if amount == 0:\n            return 0\n        if amount < 0:\n            return -1\n        \n        else:\n            if amount in cache:\n                return cache[amount]\n            \n            currMin = sys.maxsize \n            \n            for coin in coins:\n                current.append(coin) # choose that coin\n                currNum = self.helper(coins, amount - coin, cache, current)\n                \n                if currNum != -1:\n                    if currNum < currMin:\n                        currMin = currNum + 1\n                \n                current.pop()\n            \n            cache[amount] = currMin\n            return currMin\n            \n            \n    def coinChange(self, coins, amount):\n        cache = {}\n        val = self.helper(coins, amount, cache)\n        \n        # if val == sys.maxsize:\n        #     return -1\n        # else:\n        #     return val\n        \n        # for each slot in memoization array, subtract each coin from it\n        # find min and add 1\n        \n        # F(0) is 0\n        memo = [sys.maxsize] * (amount + 1)\n        memo[0] = 0\n        \n        for i in range(1, amount + 1):\n            for coin in coins:\n                newIndex = i - coin\n                \n                if newIndex >= 0:\n                    if memo[newIndex] + 1 < memo[i]:\n                        memo[i] = memo[newIndex] + 1\n\n        if memo[amount] == sys.maxsize:\n            return -1\n        else:\n            return memo[amount]\n", "class Solution:\n    def coinChange(self, coins: [int], amount: int) -> int:\n        self.ans = float('inf')\n        self.dict = {}  # amount : [depth]\n        coins.sort(reverse=True)\n\n        def helper(num, depth):\n\n            if num == 0:\n                self.ans = min(self.ans, depth)\n                return\n\n            for c in coins:\n                res = num - c\n                if res >= 0:\n                    if res in self.dict:\n                        if self.dict[res] > depth + 1 and depth + 1 < self.ans:\n                            self.dict[res] = depth+1\n                            helper(res, depth + 1)\n                    else:\n                        self.dict[res] = depth + 1\n                        helper(res, depth + 1)\n\n        helper(amount, 0)\n        return self.ans if self.ans < float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        @lru_cache(None)\n        def recurse(amount,pos):\n            if pos==len(coins):\n                return 10000\n            if amount ==0:\n                return 0\n            \n            \n            if coins[pos]<=amount:\n                return min(recurse(amount-coins[pos],pos)+1,\n                          recurse(amount,pos+1))\n            else:\n                return recurse(amount,pos+1)\n            \n            \n        count = recurse(amount,0)\n        if count>=10000:\n            return -1\n        return count\n            \n            \n", "class Solution:\n    def recursion(self, coins, remain, dic):\n        if(remain < 0):\n            return float('inf')\n        if(remain == 0):\n            return 0\n        if(remain in dic.keys()):\n            return dic[remain]\n        min_coin = float('inf')\n        for coin in coins:\n            number_coin = None\n            prev_num  = self.recursion(coins, remain - coin, dic)\n            if(prev_num == float('inf')):\n                number_coin = prev_num\n            else:\n                number_coin = prev_num + 1\n            min_coin = min(min_coin, number_coin)\n        dic[remain] = min_coin\n        return min_coin\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        remain = amount\n        count = 0\n        dic = {}\n        number = self.recursion(coins, remain, dic)\n        if(number == float('inf')):\n            return -1\n        else:\n            return number", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def helper(coins, amount, n, t):\n            if n == 0:\n                return float('inf')\n            if amount == 0:\n                return 0\n            if n == 1 and amount % coins[n - 1] == 0:\n                return amount // coins[n - 1]\n            if t[n][amount] == -1:\n                if coins[n - 1] <= amount:\n                    t[n][amount] = min(1 + helper(coins, amount - coins[n - 1], n, t), helper(coins, amount, n - 1, t))\n                else:\n                    t[n][amount] = helper(coins, amount, n - 1, t)\n            return t[n][amount]\n        \n        n = len(coins)\n        t = [[-1 for j in range(amount + 1)] for i in range(n + 1)]\n        minCoins = helper(coins, amount, n, t)\n        if minCoins == float('inf'):\n            return -1\n        else:\n            return minCoins", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = {}\n        \n        # print(coins)\n        # print(amount)\n                \n        \n        \n        def dfs(total):\n            if total < 0:\n                return float('inf')\n            \n            if total == 0:\n                return 0\n            \n            if total in list(dp.keys()):\n                return dp[total]\n            \n            for c in coins:\n                x = total - c\n                if total not in list(dp.keys()):\n                    dp[total] = dfs(x) + 1\n                else:\n                    dp[total] = min(dp[total], dfs(x) + 1)\n                    \n            return dp[total]\n            \n\n            \n        ans = dfs(amount)\n\n        if ans < float('inf'):\n            return ans\n        else:\n            return -1\n                \n                \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        coins.sort()\n        table = [[-1 for i in range(amount + 1)] for i in range(len(coins))]\n\n        for i in range(len(coins)):\n            for j in range(amount + 1):\n                if coins[i] > j and i > 0 and table[i-1][j] > 0:\n                    table[i][j] = table[i-1][j]\n                elif j >= coins[i]:\n                    x = j - coins[i]\n                    pre_val = 9999999\n                    calculated_val = 0\n                    if i > 0 and table[i - 1][j] > 0:\n                        pre_val = table[i - 1][j]\n                        \n                    if x > 0:\n                        if table[i][x] > 0:\n                            calculated_val = table[i][x]\n                            table[i][j] = min(1 + calculated_val, pre_val)\n                        else:\n                            if i > 0 and pre_val != 9999999:\n                                table[i][j] = pre_val\n                    elif x == 0:\n                        table[i][j] = min(1 + calculated_val, pre_val)\n        return table[len(coins)-1][amount]\n                \n                \n", "class Solution:\n# min(cnt(11-1),cnt(11-2),cnt(11-5))     \n    def coinChange(self, coins: List[int], total: int) -> int:\n        dic = {0:0,}\n        \n        def helper(amount):\n            \n            if amount in coins:\n                dic[amount] = 1\n            \n            elif amount<0:\n                return float('inf')\n            \n            elif amount not in dic:\n                dic[amount] = min([helper(amount-c)+1 for c in coins])\n            \n            return dic[amount]\n        \n        return helper(total) if helper(total)!=float('inf') else -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coin_count = len(coins)\n        \n        dp = [[math.inf for i in range(coin_count + 1)] for j in range(amount + 1)]\n        for i in range(coin_count + 1):\n            dp[0][i] = 0 \n        for i in range(1, amount + 1):\n            for j in range(1, coin_count + 1):\n                if coins[j - 1] <= i:\n                    dp[i][j] = min(1 + dp[i - coins[j - 1]][j], dp[i][j - 1])\n                else:\n                    dp[i][j] = dp[i][j - 1]\n        if dp[-1][-1] == math.inf: return -1\n        return dp[-1][-1]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if not coins:\n            return -1\n        \n        n=len(coins)\n        \n        if amount==0:\n            return 0\n        \n        fewest=[[0]*n for k in range(amount+1)]\n        \n        for k in range(n):\n            fewest[0][k]=0\n            \n        for p in range(1,amount+1):\n            is_divisible=(p%coins[0])==0\n            \n            if is_divisible:\n                fewest[p][0]=(p//coins[0])\n                \n            else:\n                fewest[p][0]=-1\n        \n        \n        for k  in range(1,n):\n            for p in range(1,amount+1):\n                if p<coins[k]:\n                    fewest[p][k]=fewest[p][k-1]\n                    \n                elif fewest[p-coins[k]][k]==-1:\n                    fewest[p][k]=fewest[p][k-1]\n                \n                elif fewest[p][k-1]==-1:\n                    fewest[p][k]=fewest[p-coins[k]][k]+1\n                else:\n                    fewest[p][k]=min(fewest[p-coins[k]][k]+1,fewest[p][k-1])\n                    \n                \n             \n        return fewest[p][n-1]\n                    \n                    \n            \n", "class Solution:\n#     def coinChange_bottomUp(self, coins: List[int], amount: int) -> int:\n#         # Intialize the lookup, and initialize a base case of 0\n#         lookup = {x: amount + 1 for x in range(1, amount + 1)}\n#         lookup[0] = 0\n\n#         for i in range(amount + 1):\n#             for coin in coins:\n#                 remainder = i - coin\n#                 if remainder < 0:\n#                     continue\n#                 best_min = min(lookup[remainder] + 1, lookup[i])\n#                 lookup[i] = best_min\n#         if lookup[i] > amount:\n#             return -1\n#         else: \n#             return lookup[i]\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        coins.reverse()\n        lookup = {}\n        \n        def find_combos(total_remain, total_coins):\n            \n            if total_remain in lookup:\n                if lookup[total_remain] > total_coins:\n                    lookup[total_remain] = total_coins\n                else:\n                    return\n            else:\n                lookup[total_remain] = total_coins\n            \n            for coin in coins:\n                if total_remain - coin < 0:\n                    continue\n                find_combos(total_remain - coin, total_coins + 1)\n        \n        find_combos(amount, 0)\n        \n        if 0 in lookup:\n            return lookup[0]\n        else:\n            return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        dp = {i : []  for i in range(1,amount+1)}\n        coins.sort()\n        for intermediate_amount in range(1,amount+1):\n            '''\n                basic algorithm: \n                    - for each number, start from the end of the coins list\n                    - subtract the given denomination\n                    - check if the hash map has an entry for the amount - denomination\n                    - use the first possible configuration\n                    - if all possibilities are exhausted, no denomination exists\n            '''\n            for denom in reversed(coins):\n                if intermediate_amount == denom: \n                    dp[intermediate_amount] = [denom]\n                    break # we know this is the minimum number of denoms, we can stop here\n                elif denom < intermediate_amount and dp[intermediate_amount - denom] != []:\n                    # update the array if it's the first time OR if len(dp[intermediate_amount]) > len(dp[intermediate_amount - denom]) + 1\n                    if dp[intermediate_amount] == [] or len(dp[intermediate_amount]) > len(dp[intermediate_amount - denom]) + 1:\n                        dp[intermediate_amount] = dp[intermediate_amount - denom] + [denom]\n        return len(dp[amount]) if len(dp[amount]) > 0 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n       \n        dp = [[float('INF') for i in range(amount + 1)] for j in range(len(coins)+1)]\n        for i in range(len(coins)+1):\n            dp[i][0] = 0\n        for i in range( 1,len(coins)+1):\n            for j in range(1, amount+1):\n                if j - coins[i-1]< 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = min( dp[i-1][j], dp[i][j-coins[i-1]] + 1 )\n\n        if dp[len(coins)][amount] == float('INF'):\n            return -1\n        else:\n            return dp[len(coins)][amount]\n", "'''\nfind the minimum number of coins that you need to make up the amt -> DP\n\nrecursive\namt \nc1, c2, c3 \ncount = float('inf')\nbase case:\n    if amt<0:\n       return -1\n    if amt == 0:\n        return 0\nfor coin in coins:\n  #use that coin - take the coin or do not take the coin\n  count = min(count,1+coinchangehelper(amt-coin))\n\n\nrecursion with memoization\n\n'''\n\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        def coinchangehelper(rem):\n            if rem<0:\n                return -1\n            if rem==0:\n                return 0\n            if rem in memo:\n                return memo[rem]\n            count = float('inf')\n            for coin in coins:\n                sub = coinchangehelper(rem-coin)\n                if sub>=0:\n                    count = min(count,1+sub)\n            memo[rem] = count\n            return memo[rem]\n        memo = {}\n        res = coinchangehelper(amount)\n        return res if res!=float('inf') else -1   \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [float('inf') for _ in range(amount+1)]\n        \n        if(amount == 0):\n            return 0\n\n        for i in range(0, len(dp)):\n            for c in coins:\n                if(i >= c):\n                    if(i % c == 0):\n                        dp[i] = min(int(i / c), dp[i])\n                    else:\n                        if(i-c >= 0 and dp[i-c] != float('inf')):\n                            dp[i] = min(int(1 + dp[i - c]), dp[i])\n        \n        ret_val = dp[amount]\n        if(ret_val == float('inf')):\n            return -1\n        return dp[amount]", "import sys\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[[0 for i in range(amount+1)]for j in range(len(coins)+1)]\n        for i in range(len(coins)+1):\n            for j in range(amount+1):\n                if i==0:\n                    dp[i][j]=sys.maxsize\n        for i in range(len(coins)+1):\n            for j in range(amount+1):\n                if j%coins[0]==0:\n                    dp[i][j]=j//coins[0]\n                else:\n                    dp[i][j]=sys.maxsize\n        for i in range(2,len(coins)+1):\n            for j in range(1,amount+1):\n                if coins[i-1]<=j:\n                    dp[i][j]=min(dp[i][j-coins[i-1]]+1,dp[i-1][j])\n                else:\n                    dp[i][j]=dp[i-1][j]\n        if dp[len(coins)][amount]==sys.maxsize:\n            return -1\n        return dp[len(coins)][amount]\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n    # (3) Dynamic Programming - top-down\n        self.dp = [float('inf')] * (amount + 1)\n        self.dp[0] = 0\n        \n        def change(a):\n            if a < 0:\n                return -1\n            if a == 0:\n                return 0\n            if self.dp[a] != float('inf'):\n                return self.dp[a]\n            for c in coins:\n                tmp = change(a-c)\n                if tmp != -1:\n                    self.dp[a] = min(tmp + 1, self.dp[a])\n            if self.dp[a] == float('inf'):\n                self.dp[a] = -1\n            # remember to return\n            return self.dp[a]\n        \n        change(amount)\n        return self.dp[amount] if self.dp[amount] != float('inf') else -1", "class Solution:\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        self.coins = coins\n        self.amount_dict = {0:0}\n        # for coin in coins:\n        #     self.amount_dict[coin] = 1\n        return self.coinChangeHelp(amount)\n\n    @lru_cache\n    def coinChangeHelp(self, amount: int) -> int:\n        if amount in self.amount_dict or amount < 0:\n            return self.amount_dict.get(amount, -1)\n        max_coin = amount + 1\n        for coin in self.coins:\n            cur_coin = self.coinChangeHelp(amount - coin)\n            if cur_coin >= 0:\n                max_coin = min(max_coin, cur_coin+1) \n        max_coin = max_coin if max_coin != (amount+1) else -1\n        self.amount_dict[amount]=max_coin\n        return max_coin", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        def dfs(start, amount, n_coins):\n            coin = coins[start]\n            div = amount // coin\n            n_coins += div\n            amount %= coin\n            \n            if amount == 0:\n                self.minimum = min(n_coins, self.minimum)\n                return\n            \n            if start < length:\n                dfs(start + 1, amount, n_coins)\n                next_coin = coins[start + 1]\n                for _ in range(div):\n                    amount += coin\n                    n_coins -= 1\n                    if (self.minimum - n_coins - 1) * next_coin + 1 > amount:\n                        dfs(start + 1, amount, n_coins)\n                    else:\n                        break\n        coins.sort(reverse=True)\n        self.minimum = float('inf')\n        length = len(coins) - 1\n        dfs(0, amount, 0)\n        return self.minimum if self.minimum < float('inf') else -1", "class Solution:\n    def coinChange_bottomUp(self, coins: List[int], amount: int) -> int:\n        # Intialize the lookup, and initialize a base case of 0\n        lookup = {x: amount + 1 for x in range(1, amount + 1)}\n        lookup[0] = 0\n\n        for i in range(amount + 1):\n            for coin in coins:\n                remainder = i - coin\n                if remainder < 0:\n                    continue\n                best_min = min(lookup[remainder] + 1, lookup[i])\n                lookup[i] = best_min\n        if lookup[i] > amount:\n            return -1\n        else: \n            return lookup[i]\n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        coins.reverse()\n        lookup = {}\n        \n        def find_combos(total_remain, total_coins):\n            \n            if total_remain in lookup:\n                if lookup[total_remain] > total_coins:\n                    lookup[total_remain] = total_coins\n                else:\n                    return\n            else:\n                lookup[total_remain] = total_coins\n            \n            for coin in coins:\n                if total_remain - coin < 0:\n                    continue\n                find_combos(total_remain - coin, total_coins + 1)\n        \n        find_combos(amount, 0)        \n        return lookup[0] if 0 in lookup else -1\n", "# BSF No.1\n# class Solution:\n#     def coinChange(self, coins: List[int], amount: int) -> int:\n#         if amount == 0:\n#             return 0\n#         queue = [[0, 0]]\n#         visited = {0}\n#         step = 0\n        \n#         for node, step in queue:\n#             for coin in coins:\n#                 if node + coin in visited:\n#                     continue\n#                 if node + coin == amount:\n#                     return step + 1\n#                 if node + coin < amount:\n#                     queue.append([node + coin, step + 1])\n#                     visited.add(node + coin)\n#         return -1\n    \n# BSF No.2\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        level = seen = {0}\n        number = 0\n        while level:\n            # print(level)\n            if amount in seen:\n                return number\n            level = {pre_amount + coin for pre_amount in level for coin in coins if pre_amount + coin <= amount}\n            seen.update(level)\n            # print(seen)\n            number += 1\n        return -1\n    # level = seen = {0}\n    # number = 0\n    # while level:\n    #     if amount in level:\n    #         return number\n    #     level = {a+c for a in level for c in coins if a+c <= amount} - seen\n    #     seen |= level\n    #     number += 1\n    # return -1 \n", "from functools import lru_cache\nfrom math import inf\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def cc(i, amount):\n            if amount == 0:\n                return 0\n            elif i < 0 or amount < 0:\n                return inf\n            else:\n                incl, excl = cc(i-1, amount), cc(i, amount-coins[i]) + 1\n                return min(max(incl, 0), max(excl, 0))\n        \n        \n        result = cc(len(coins)-1, amount)\n        return result if result < inf else -1\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        memo = [ [ -1 for _ in range(amount+1) ] for _ in coins ]\n        \n        for i in range(len(coins)-1, -1, -1):\n            for j in range(amount+1):\n                if j == 0:\n                    memo[i][j] = 0\n                    continue\n                    \n                    \n                if j-coins[i] >= 0 and memo[i][j-coins[i]] != -1 and i+1 < len(coins) and memo[i+1][j] != -1:\n                    memo[i][j] = min(memo[i][j-coins[i]]+1, memo[i+1][j])\n                elif j-coins[i] >= 0 and memo[i][j-coins[i]] != -1:\n                    memo[i][j] = memo[i][j-coins[i]]+1\n                elif i+1 < len(coins) and memo[i+1][j] != -1:\n                    memo[i][j] = memo[i+1][j]\n        return memo[0][amount]\n        \n", "class Solution:\n    def __init__(self):\n        self.total_min = 0\n        self.change_map = {0:0}\n        \n    def changer(self, coins_obj, amount_obj):\n        \n        if amount_obj == 0:\n            self.change_map[amount_obj] = 0\n            return 0\n        if min(coins_obj) > amount_obj:\n            self.change_map[amount_obj] = -1\n            return -1\n            \n        rev_coins_obj = list(reversed(coins_obj))\n        for el in rev_coins_obj:\n            if el <= amount_obj:\n                if amount_obj-el in self.change_map.keys():\n                    tmp = self.change_map[amount_obj-el]\n                else:\n                    tmp = Solution.changer(self,coins_obj,amount_obj-el)\n                \n                if tmp != -1:\n\n                    key = tmp+1\n                    if amount_obj not in self.change_map.keys():\n                        self.change_map[amount_obj] = key\n                    elif amount_obj in self.change_map.keys():\n                        if key < self.change_map[amount_obj]:\n                            self.change_map[amount_obj] = key\n                \n                \n            # elif el == amount_obj:\n            #     self.change_map[amount_obj] = 1\n            #     return 1\n                \n        if amount_obj not in self.change_map.keys():\n            self.change_map[amount_obj] = -1\n            return -1\n        elif amount_obj in self.change_map.keys():\n            return self.change_map[amount_obj]\n                    \n                        \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n            \n        Solution.changer(self, coins, amount)\n        # print(self.change_map,amount)\n        if amount not in self.change_map.keys():\n            return -1\n        \n        return self.change_map[amount]", "class Solution:\n    def coinChange(self, coins:List[int], amount:int) -> int:\n        if amount == 0:\n            return 0\n        start = [0]\n        visited = [False]*(amount+1)\n        visited[0] = True\n        numCoins = 1\n        nextStart = []\n        while start:\n            for v in start:\n                for coin in coins:\n                    nextVal = v + coin\n                    if nextVal > amount or visited[nextVal]:\n                        continue\n                    elif nextVal == amount:\n                        return numCoins\n                    else:\n                        visited[nextVal] = True\n                        nextStart.append(nextVal)\n            start, nextStart = nextStart, []\n            numCoins += 1\n        return -1\n", "from queue import Queue\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount == 0:\n            return 0\n        \n        q = Queue()\n        mem = dict()\n\n        q.put((0, 0))\n\n        while not q.empty():\n            curr = q.get()\n            \n            for c in coins:\n                tot = curr[1] + c\n                if tot > amount:\n                    continue\n                if tot == amount:\n                    return curr[0] + 1\n\n                if tot in mem and mem[tot] <= curr[0] + 1:\n                    continue\n                \n                q.put((curr[0] + 1, tot))\n                mem[tot] = curr[0] + 1\n\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        mem = {}\n        def helper(amt):\n            if amt < 0:\n                return -1\n            elif amt == 0:\n                return 0\n            elif amt in mem:\n                return mem[amt]\n            min_coins = float('inf')\n            for coin in coins:\n                result = helper(amt - coin)\n                if result != -1:\n                    min_coins = min(min_coins, 1 + result)\n            mem[amt] = min_coins\n            return min_coins\n        output = helper(amount)\n        return -1 if output == float('inf') else output\n", "class Solution:\n    def __init__(self):\n        self.total_min = 0\n        self.change_map = {0:0}\n        \n    def changer(self, coins_obj, amount_obj):\n        \n        if amount_obj == 0:\n            self.change_map[amount_obj] = 0\n            return 0\n        if min(coins_obj) > amount_obj:\n            self.change_map[amount_obj] = -1\n            return -1\n            \n        rev_coins_obj = list(reversed(coins_obj))\n        for el in rev_coins_obj:\n            if el <= amount_obj:\n                if amount_obj-el in self.change_map.keys():\n                    tmp = self.change_map[amount_obj-el]\n                else:\n                    tmp = Solution.changer(self,coins_obj,amount_obj-el)\n                \n                if tmp != -1:\n                    key = tmp+1\n                    if amount_obj not in self.change_map.keys():\n                        self.change_map[amount_obj] = key\n                    elif amount_obj in self.change_map.keys():\n                        if key < self.change_map[amount_obj]:\n                            self.change_map[amount_obj] = key\n                \n                \n\n                \n        if amount_obj not in self.change_map.keys():\n            self.change_map[amount_obj] = -1\n            return -1\n        elif amount_obj in self.change_map.keys():\n            return self.change_map[amount_obj]\n                    \n                        \n    \n    def coinChange(self, coins: List[int], amount: int) -> int:\n\n            \n        Solution.changer(self, coins, amount)\n        # print(self.change_map,amount)\n\n        return self.change_map[amount]", "class Solution:\n    def changeCoin(self, coins, amount, change):\n        if amount < 0:\n            return -1\n        if amount == 0:\n            return 0\n        if amount in change:\n            return change[amount]\n\n        costs = []\n\n        for coin in coins:\n            cost = self.changeCoin(coins, amount-coin, change)\n            if amount-coin in change:\n                change[amount-coin] = min(cost, change[amount-coin])\n            else:\n                change[amount-coin] = cost\n\n            if cost != -1:\n                costs.append(cost)\n\n        if len(costs) == 0:\n            return -1\n\n        return 1 + min(costs)\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        coins = [coin for coin in coins if coin <= amount]\n        change = {}\n        \n        \n        return self.changeCoin(coins, amount, change)\n", "import numpy as np\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        maximum = amount + 1\n        dp = np.full((maximum), maximum)\n        dp[0] = 0\n        for i in range(1, maximum):\n            for j in coins:\n                if j <= i:\n                    dp[i] = min(dp[i], dp[i - j] + 1)\n        if dp[amount] > amount:\n            return -1\n        return dp[amount]", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        \n        dp =  [ [sys.maxsize]*(amount+1) , [sys.maxsize]*(amount+1) ]\n        \n        \n        \n        for i in range(1,n+1):\n            dp[i%2][0] = 0\n            for j in range(1, amount+1):\n                dp[i%2][j] = dp[(i-1)%2][j]\n                if coins[i-1] <= j:\n                    dp[i%2][j] = min(dp[i%2][j-coins[i-1]] + 1 , dp[i%2][j])\n        \n        #print(dp)\n        return dp[n%2][amount] if dp[n%2][amount] < sys.maxsize else -1\n                    \n                    \n", "class Solution:\n    def changeCoin(self, coins, amount, change):\n        if amount < 0:\n            return -1\n        if amount == 0:\n            return 0\n        if amount in change:\n            return change[amount]\n\n        costs = []\n\n        for coin in coins:\n            cost = self.changeCoin(coins, amount-coin, change)\n            if amount-coin in change:\n                change[amount-coin] = min(cost, change[amount-coin])\n            else:\n                change[amount-coin] = cost\n\n            if cost != -1:\n                costs.append(cost)\n\n        if len(costs) == 0:\n            return -1\n\n        return 1 + min(costs)\n\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        change = {}\n        \n        return self.changeCoin(coins, amount, change)\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        rows = amount + 1\n        cols = len(coins) + 1\n        \n        cache = [[0 for _ in range(cols)] for _ in range(rows)]\n        \n        for row in range(1, rows):\n            cache[row][0] = -1\n        \n        for row in range(1, rows):\n            for col in range(1, cols):\n                newAmt = row - coins[col - 1]\n                takeValue = cache[newAmt][col] if newAmt >= 0 and newAmt < len(cache) else -1\n                takeCoin = 1 + takeValue if takeValue >= 0 else -1\n                skipCoin = cache[row][col - 1]\n                if skipCoin < 0:\n                    cache[row][col] = takeCoin\n                elif takeCoin < 0:\n                    cache[row][col] = skipCoin\n                else:\n                    cache[row][col] = min(skipCoin, takeCoin)\n        \n        return cache[amount][len(coins)]\n    \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        self.dp = [[-1]*(amount+1) for _ in range(len(coins) + 1)]\n        value = self.solve(coins, len(coins), amount)\n        return self.dp[-1][-1] if value != float('inf') else -1\n\n    \n    def solve(self, coins, n, amount):\n        if amount == 0:\n            self.dp[n][amount] = 0\n            return 0\n        if n == 0:\n            self.dp[n][amount] = float('inf')\n            return self.dp[n][amount]\n        if self.dp[n][amount] != -1:\n            return self.dp[n][amount]\n        if coins[n-1] <= amount:\n            self.dp[n][amount] =  min(1 + self.solve(coins, n, amount - coins[n-1]), self.solve(coins, n-1, amount))\n            return self.dp[n][amount]\n        else:\n            self.dp[n][amount] = self.solve(coins, n-1, amount)\n            return self.dp[n][amount]", "#https://www.youtube.com/watch?v=1R0_7HqNaW0\nimport numpy as np\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        #dp[n]: fewest number of coins needed to make n cents\n        dp = np.empty(amount+1)\n        dp.fill(math.inf)\n        dp[0] = 0\n        \n        #this sorting will affect the average run time and makes it better\n        coins = sorted(coins)\n        \n        for i in range(1, amount+1):\n            for c in coins:\n                if c <= i:\n                    dp[i] = min(dp[i], 1+ dp[i-c])\n                else:\n                    break\n        return -1 if dp[-1] == math.inf else int(dp[-1])", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        INVALID=10**10\n        self.ans = INVALID\n        def dfs(s, amount, count):\n            if amount == 0:\n                self.ans = count\n                return \n            if s == len(coins):\n                return\n            coin =coins[s]\n            for i in range (amount//coin, -1, -1):\n                print(i)\n                print (coin)\n                print (amount)\n                if count+i >=self.ans:\n                    break\n                dfs(s + 1, amount - i * coin, count+i)\n        dfs(0,amount,0)\n        if self.ans == INVALID:\n            return -1\n        else:\n            return self.ans\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins = sorted(coins)\n        dp = {}\n        def in_dict(val):\n            return val in dp.keys() and dp[val]\n        if not amount:\n            return 0\n        if coins[0] > amount:\n            return -1\n        for coin in coins:\n            dp[coin] = 1\n        for i in range (coins[0], min(amount, coins[-1]) + 1):\n            if i in dp.keys():\n                continue\n            available_coins = [coin for coin in coins if coin <= i]\n            possible_min_coins = [1 + dp[i-coin] for coin in available_coins if in_dict(i-coin)]\n            dp[i] = min(possible_min_coins) if possible_min_coins else 0\n        for i in range(coins[-1]+1, amount+1):\n            possible_min_coins = [1 + dp[i-coin] for coin in coins if in_dict(i-coin)]\n            dp[i] = min(possible_min_coins) if possible_min_coins else 0\n        return dp[amount] or -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[float('inf') for j in range(n+1)] for i in range(amount+1)]\n        for j in range(n+1):\n            dp[0][j] = 0\n        for i in range(1, amount+1):\n            for j in range(1, n+1):\n                c = coins[j-1]\n                if c > i:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = min(dp[i-c][j]+1, dp[i][j-1])\n            \n        return dp[amount][n] if dp[amount][n] < amount+1 else -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        value1 = [0]\n        value2 = []\n        nc =  0\n        visited = [False]*(amount+1)\n        visited[0] = True\n        while value1:\n            nc += 1\n            for v in value1:\n                for coin in coins:\n                    newval = v + coin\n                    if newval <= amount:\n                        if not visited[newval]:\n                            if newval == amount:\n                                return nc\n                            visited[newval] = True\n                            value2.append(newval)\n            value1, value2 = value2, []\n        return -1", "'''\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        min_num = [float('inf') for _ in range(amount + 1)]\n        min_num[0] = 0\n        \n        for c in coins:\n            for s in range(c, amount + 1):\n                min_num[s] = min(min_num[s], min_num[s - c] + 1)\n                \n        return -1 if min_num[amount] == float('inf') else min_num[amount]\n'''\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        res, seen, curr = 0, set(), {c for c in coins if c <= amount}\n        while curr:\n            res += 1\n            if amount in curr:\n                return res\n            seen |= curr\n            tmp = {n+c for n in curr for c in coins}\n            curr = {t for t in tmp if t not in seen and t <= amount}\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        res, seen, curr = 0, set(), {c for c in coins if c <= amount}\n        while curr:\n            res += 1\n            if amount in curr:\n                return res\n            seen |= curr\n            tmp = {n+c for n in curr for c in coins}\n            curr = {t for t in tmp if t not in seen and t <= amount}\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: \n            return 0 \n        seen = set()\n        seen.add(0)\n        queue = deque([0])\n        count = 0 \n        while queue: \n            if amount in queue: \n                return count\n            currlen = len(queue)\n            for i in range(currlen): \n                node = queue.popleft()\n                for c in coins: \n                    if c + node not in seen and c + node <= amount: \n                        queue.append(c + node)\n                        seen.add(c + node)\n            count += 1\n        return -1 \n        \n        \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n#         if not amount:\n#             return 0\n        \n#         min_coins = [0] + [float('inf')] * amount\n        \n#         for i in range(amount + 1):\n#             if min_coins[i] < float('inf'):\n#                 for c in coins:\n#                     if i + c <= amount:\n#                         min_coins[i + c] = min(min_coins[i + c], min_coins[i] + 1)\n        \n#         return min_coins[amount] if min_coins[amount] != float('inf') else -1\n        \n        if not amount:\n            return 0\n        \n        q = deque([amount])\n        hs = [False] * amount\n        count = 0\n\n        while q:\n            l = len(q)\n            while l:\n                n = q.popleft()\n                for c in coins:\n                    x = n - c\n                    if not x:\n                        return count + 1\n                    if x > 0 and not hs[x]:\n                        hs[x] = True\n                        q.append(x)\n                l -= 1\n            count += 1\n\n        return -1  ", "import collections\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        '''\n        coins = [1, 2, 5], amount = 0\n                       ^\n                 2  3  6\n                 4 \n                 10\n        '''\n        if not amount:\n            return 0\n        queue = collections.deque(coins)\n        visited = set()\n        count = 1\n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == amount:\n                    return count\n                for next in coins:\n                    next += curr\n                    if next not in visited and next <= amount:\n                        visited.add(next)\n                        queue.append(next)\n            count += 1\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # BFS\n        from collections import deque\n        q = deque()\n        visited = set()\n        q.append(amount)\n        visited.add(amount)\n        steps = 0\n        while q:\n            for _ in range(len(q)):\n                poped = q.popleft()\n                if poped == 0:\n                    return steps\n                for coin in coins:\n                    new = poped-coin\n                    if new not in visited and new>=0:\n                        q.append(new)\n                        visited.add(new)\n\n            steps += 1\n        return -1\n\n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[0, 0]]\n        visited = {0}\n        step = 0\n        for node, step in queue:\n            for coin in coins:\n                if node + coin in visited: continue\n                if node + coin == amount: return step + 1\n                if node + coin < amount:\n                    queue.append([node + coin, step + 1])\n                    visited.add(node + coin)\n        return -1\n        '''dp = [0] + [float('inf')] * amount\n        \n        for c in coins:\n            for i in range(c, amount + 1):\n                dp[i] = min(dp[i], dp[i-c] + 1)\n        return dp[-1] if dp[-1] != float('inf') else -1'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[0, 0]]\n        visited = {0}\n        step = 0\n        for node, step in queue:\n            for coin in coins:\n                if node + coin in visited: continue\n                if node + coin == amount: return step + 1\n                elif node + coin < amount:\n                    queue.append([node + coin, step + 1])\n                    visited.add(node + coin)\n        return -1\n        '''dp = [0] + [float('inf')] * amount\n        \n        for c in coins:\n            for i in range(c, amount + 1):\n                dp[i] = min(dp[i], dp[i-c] + 1)\n        return dp[-1] if dp[-1] != float('inf') else -1'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        \n        q = [0]\n        visited = set()\n        depth = 0\n        while q:\n            depth += 1\n            level = []\n            for curr in q:\n                for coin in coins:\n                    newvalue = curr + coin\n                    if newvalue == amount:\n                        return depth\n                    if newvalue not in visited and newvalue < amount:\n                        visited.add(newvalue)\n                        level.append(newvalue)\n            q = level\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # Use a queue to maintain current possible paths towards amount\n        if amount == 0:\n            return 0\n        que = deque()\n        seen = set()\n        res = -1\n        \n        for coin in coins:\n            if coin <= amount:\n                que.append(coin)\n                seen.add(coin)\n                \n        count = 1\n        while que:\n            prev = len(que)\n            while prev > 0:\n                cur = que.popleft()\n                if cur == amount:\n                    return count\n                for coin in coins:\n                    newamount = cur + coin\n                    if newamount not in seen and newamount <= amount:\n                        que.append(newamount)\n                        seen.add(newamount)\n                prev -= 1\n            count += 1\n        return res\n                \n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        q = [0]\n        depth = 0\n        visited = set()\n        while q:\n            level = []\n            depth += 1\n            for curr in q:\n                for coin in coins:\n                    newvalue = curr+coin\n                    if newvalue == amount:\n                        return depth\n                    elif newvalue not in visited and newvalue < amount:\n                        visited.add(newvalue)\n                        level.append(newvalue)\n            q = level\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        seen = level = {0}\n        coin_n = 0\n        \n        while level:\n            if amount in level:\n                return coin_n\n            \n            level = {val + coin for val in level for coin in coins if val+coin <= amount} - seen\n            seen |= level\n            \n            coin_n += 1\n        \n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort(reverse = True)\n        \n        count = 0\n        self.maxcount = float('inf')\n        \n        self.dfs(coins, count, amount)\n        \n        return -1 if self.maxcount == float('inf') else self.maxcount\n    \n    def dfs(self,coins,count,amount):\n        if amount == 0: self.maxcount = min(self.maxcount,count)\n        \n        for i in range(len(coins)):\n            if amount >= coins[i] and count + math.ceil(amount/coins[i])<self.maxcount:\n                self.dfs(coins[i:],count+1,amount-coins[i])", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        \n        \n        \n        \n        if amount == 0: return 0\n        queue = [[0, 0]]\n        visited = {0}\n        step = 0\n        for node, step in queue:\n            for coin in coins:\n                if node + coin in visited: continue\n                if node + coin == amount: return step + 1\n                elif node + coin < amount:\n                    queue.append([node + coin, step + 1])\n                    visited.add(node + coin)\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[0, 0]]\n        visited = {0}\n        num = 0\n        for pos, num in queue:\n            for c in coins:\n                if pos + c in visited: continue\n                if pos + c == amount: return num + 1\n                if pos + c < amount:\n                    queue.append([pos + c, num + 1])\n                    visited.add(pos + c)\n        return -1\n        '''dp = [0] + [float('inf')] * amount\n        \n        for c in coins:\n            for i in range(c, amount+1):\n                dp[i] = min(dp[i], dp[i-c] + 1)\n        return dp[-1] if dp[-1] != float('inf') else -1'''", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n\n        value1 = [0]\n        value2 = []\n        nc =  0\n        visited = [False]*(amount+1)\n        visited[0] = True\n        while value1:\n            nc += 1\n            for v in value1:\n                for coin in coins:\n                    newval = v + coin\n                    if newval == amount:\n                        return nc\n                    elif newval > amount:\n                        continue\n                    elif not visited[newval]:\n                        visited[newval] = True\n                        value2.append(newval)\n            value1, value2 = value2, []\n        return -1", "from collections import deque\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = deque([[0, 0]])\n        visited = {0}\n        step = 0\n        while queue:\n            node, step = queue.popleft()\n            for coin in coins:\n                if node + coin in visited: continue\n                if node + coin == amount: return step + 1\n                elif node + coin < amount:\n                    queue.append([node + coin, step + 1])\n                    visited.add(node + coin)\n        return -1", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount <0 or not coins: \n            return -1\n        if not amount: \n            return 0\n        stack,lvl,visited = [0],0,set()\n        while stack:\n            new_lvl = []; \n            lvl+=1\n            for i in stack:\n                for c in coins:\n                    new = i+c\n                    if new == amount:\n                        return lvl\n                    if new not in visited:\n                        visited.add(new)\n                        new_lvl.append(new)\n            if min(new_lvl)>amount:\n                return -1\n            stack = new_lvl", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0:\n            return 0\n        myQueue = [[0,0]]\n        reachedMap = {0}\n        for value, num_coins in myQueue:\n            for coin in coins:\n                if coin+value in reachedMap:\n                    continue\n                if coin + value == amount:\n                    return num_coins + 1\n                if coin+value < amount:\n                    reachedMap.add(value+coin)\n                    myQueue.append([coin+value, num_coins + 1])\n        return -1\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        \n        if amount == 0:\n            return 0\n        if not coins:\n            return -1\n        \n        memo = {}\n            \n        stack = [amount]\n        l = 0\n        while stack:\n            tmp = []\n            for remain in stack:\n                if remain < 0:\n                    continue\n                \n                for coin in coins:\n                    nxt = remain-coin\n                    if nxt == 0:\n                        return l+1\n                    if nxt in memo:\n                        continue\n                    else:\n                        memo[nxt] = 1\n                    tmp += [nxt]\n            stack = tmp\n            l += 1\n        return -1\n            \n                \n                \n                \n\n", "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        if amount == 0: return 0\n        queue = [[0, 0]]\n        visited = {0}\n        step = 0\n        for node, step in queue:\n            for coin in coins:\n                if node + coin in visited: continue\n                if node + coin == amount: return step + 1\n                elif node + coin < amount:\n                    queue.append([node + coin, step + 1])\n                    visited.add(node + coin)\n        return -1"]
["class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        #if not A: return 0\n        #if len(A)==1: return A[0]\n        # Real Run Time is a little bit UNSTABLE\n        N = len(A)\n        P = [0] * (N+1)\n        for i in range(1,N+1): P[i] = P[i-1] + A[i-1]\n        \n        # Table[a] = optimal for A[a:] with k subsets, initially k=1\n        Table = [(P[N]-P[i])/(N-i) for i in range(N)]\n        for k in range(2, K+1):\n            for i in range(K-k,N-k+1):\n                Table[i] = max((P[j]-P[i])/(j-i) + Table[j] for j in range(i+1,N-k+2))\n        \n        return Table[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n\n        N = len(A)\n        P = [0] * (N+1)\n        for i in range(1,N+1): \n            P[i] = P[i-1] + A[i-1]\n            \n        dp = [(P[N]-P[i])/(N-i) for i in range(N)]\n        for k in range(1,K):\n            for i in range(K-k-1,N-k):\n                dp[i] = max((P[j]-P[i])/(j-i) + dp[j] for j in range(i+1,N-k+1))\n                \n        return dp[0]", "from functools import lru_cache\nfrom itertools import accumulate\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        n = len(A)\n        p = [0] + list(accumulate(A))\n        @lru_cache(None)\n        def dp(l,k):\n            if k > l:\n                return 0\n            if k == 1:\n                return p[l] / l\n            return max(dp(i,k-1) + (p[l] - p[i])/(l-i) for i in range(k-1,l))\n        return dp(n,K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        n = len(A)\n        memo = [[0 for k in range(K)] for i in range(n)]\n        \n        def aux(A, cur, k, memo):\n            if cur == len(A):\n                return 0\n            if memo[cur][k]:\n                return memo[cur][k]\n            tmp = sum(A[cur:])/(len(A)-cur)\n            if k == 0:\n                memo[cur][k] = tmp\n                return tmp\n            for i in range(cur+1, len(A)+1):\n                tmp = max(tmp, sum(A[cur:i])/(i-cur) + aux(A, i, k-1, memo))\n            memo[cur][k] = tmp\n            return tmp\n                \n        return aux(A, 0, K-1, memo)\n        \n", "class Solution:\n    def largestSumOfAverages(self, A, K: int) -> float:\n        A = [0] + A\n        len_a = len(A)\n        dp = [[0] * (K+1) for _ in range(len_a)]\n        \n        for i in range(1, len_a):\n            dp[i][0] = -float('inf')\n        \n        for i in range(1, len_a):\n            for k in range(1, min(K+1, i+1)):\n                for j in range(k, i+1):\n                    dp[i][k] = max(dp[i][k], dp[j-1][k-1] + self.helper(A[j:i+1]))\n        return dp[-1][-1]\n    \n    def helper(self, sub_a):\n        return sum(sub_a) / len(sub_a)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        P = [0] * (len(A)+1)\n        for i, n in enumerate(A):\n            P[i+1] = P[i]+n\n        \n        def average(i, j):\n            return (P[j]-P[i]) / float(j-i)\n        \n        N = len(A)\n        dp = [average(i,N) for i in range(N)]\n        \n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i],average(i,j)+dp[j])\n        return dp[0]\n            \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        P = [0]\n        for x in A: \n            P.append(P[-1] + x)\n        \n        def average(i, j):\n            return (P[j] - P[i]) / float(j - i)\n\n        N = len(A)\n        dp = [average(i, N) for i in range(N)]\n        print(dp)\n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n\n        return dp[0]\n        \n#         N = len(A)\n#         cache = dict()\n#         def getMaxScore(i,k):\n#             if k <= 0:\n#                 return 0\n#             if (i,k) in cache:\n#                 return cache[(i,k)]\n            \n#             maxScore = -float(\\\"inf\\\")\n#             for j in range(i,N):\n#                 leftArray = A[i:j+1]\n#                 # print(leftArray)\n#                 score = float(sum(leftArray))/len(leftArray) + getMaxScore(min(j+1,N),k-1)\n#                 maxScore = max(maxScore,score)\n                \n#             cache[(i,k)] = maxScore\n#             return maxScore\n        \n#         return getMaxScore(0,K)\n                \n", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        prefix_sum = [0]\n        for x in A:\n            prefix_sum.append(prefix_sum[-1] + x)\n\n        def average(i, j):\n            return (prefix_sum[j] - prefix_sum[i]) / (j - i)\n\n        n = len(A)\n        dp = [[0] * n for _ in range(K)]\n\n        for k in range(K):\n            for i in range(n):\n                if k == 0 and i == 0:\n                    dp[0][i] = A[0]\n                elif k == 0:\n                    dp[0][i] = average(0, i+1)\n                else:\n                    for j in range(i):\n                        dp[k][i] = max(dp[k][i], dp[k - 1][j] + average(i+1, j+1))\n\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        P = [0] \n        for x in A: P.append(P[-1] +x)\n        \n        def average(i,j):\n          return float(P[j] - P[i]) / float(j-i)\n        \n        N = len(A)\n        \n        dp = [average(i,N) for i in range(N)]\n        \n        for k in range(K-1):\n          for i in range(N):\n            for j in range(i+1, N):\n              dp[i] = max(dp[i], average(i,j) + dp[j])\n        \n        return dp[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        memo = {}\n        length = len(A)\n\n        def dfs(start, k):\n            if (start, k) in memo:\n                return memo[(start, k)]\n            if k == 1:\n                memo[(start, k)] = sum(A[start:]) / (length - start)\n                return memo[(start, k)]\n            if start >= length:\n                return 0\n\n            value = 0\n            for i in range(start + 1, length):\n                val = sum(A[start:i]) / (i - start)\n                value = max(value, dfs(i, k - 1) + val)\n            memo[(start, k)] = value\n            return value\n\n        return dfs(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        s, dp = [0] + A, {}\n        for i in range(1, len(A) + 1):\n            s[i] += s[i - 1]\n        #print(s)\n        def dfs(i, k):\n            #print(i, k)\n            if k == 1:\n                #print((s[-1] - s[i]) / (len(A) - i))\n                return (s[-1] - s[i]) / (len(A) - i)\n            if (i, k) in dp: return dp[(i, k)]\n            dp[(i, k)] = max((s[j] - s[i]) / (j - i) + dfs(j, k - 1) for j in range(i + 1, len(A) - k + 2))\n            return dp[(i, k)]\n        return dfs(0, K)\n        \n                \n                \n                \n", "import itertools\n\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # Dynamic Programming \n        # Time  complexity: O(K x N^2)\n        # Space complexity: O(N)\n        P = [0] + list(itertools.accumulate(A))\n        def average(i, j): return (P[j] - P[i]) / float(j - i)\n\n        N = len(A)\n        dp = [average(i, N) for i in range(N)]\n        for _ in range(K - 1):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n\n        return dp[0]\n\n\n\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        cumsums = [0] * (len(A) + 1)\n        for i, x in enumerate(A):\n            cumsums[i+1] = cumsums[i] + A[i]\n        \n        memo = {}\n        def DP(j, K):\n            if K == 0:\n                return 0 \n            if j + 1 == K:\n                return cumsums[j+1]\n            if K == 1:\n                return cumsums[j+1]/(j+1)\n            \n            res = 0\n            for i in range(j, -1, -1):\n                if (i, K-1) not in memo:\n                    memo[(i, K-1)] = DP(i, K-1)\n                if j - i == 0:\n                    res = max(res, memo[(i, K-1)])\n                else:\n                    res = max(res, memo[(i, K-1)] + (cumsums[j + 1] - cumsums[i+1])/(j - i))\n            return res\n        \n        a = DP(len(A)-1, K)\n        return a\n            \n", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        memo = {}\n        def search(n, k):\n            if (n, k) in memo: return memo[n, k]\n            if n < k: return 0\n            if k == 1:\n                memo[n, k] = sum(A[:n]) / float(n)\n                return memo[n, k]\n            cur, memo[n, k] = 0, 0\n            for i in range(n - 1, 0, -1):\n                cur += A[i]\n                memo[n, k] = max(memo[n, k], search(i, k - 1) + cur / float(n - i))\n            return memo[n, k]\n        return search(len(A), K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        Cum = [0]\n        for i in range(len(A)):\n            Cum.append(Cum[-1] + A[i])\n        def Average(h,k):\n            return (Cum[k] - Cum[h])/(k - h)\n        \n        dp = [Average(i, len(A)) for i in range(len(A))]\n        for _ in range(K-1):\n            for i in range(len(A)):\n                for j in range(i+1,len(A)):\n                    dp[i] = max(dp[i], Average(i,j) + dp[j])\n        return dp[0]\n", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        def average(i, j):\n            return (P[j] - P[i]) / float(j - i)\n\n        N = len(A)\n        dp = [average(i, N) for i in range(N)]\n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n\n        return dp[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        presum = [0] + list(itertools.accumulate(A))\n        def mean(i, j):\n            return (presum[j+1] - presum[i])/(j-i+1)\n        \n        max_val = [0]\n        def helper(i, j, k):\n            if (i, j, k) in check:\n                result = check[(i, j, k)]\n            elif k == 1:\n                result = mean(i, j)\n            else:\n                result = -float('inf')\n                for mid in range(i, j):\n                    result = max(result, mean(i, mid) + helper(mid+1, j, k-1))\n            check[(i, j, k)] = result\n            max_val[0] = max(max_val[0], result)\n            return result\n        n = len(A)\n        check = {}\n        helper(0, n-1, K)\n        return max_val[0]", "# dp[i][k] = largest sum of avg for A[:(i+1)] splitted into most k groups\n# = max{max[dp[j][k-1]+avg(A[(j+1):(i+1)]) for j<i], dp[i][k-1]}\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        import itertools\n        cumsum = list(itertools.accumulate(A)) #if use mean, over time limit\n#         print(\\\"cumsum\\\", cumsum)\n        L = len(A)\n        K = min(L, K)\n        dp = [[0]*(K+1) for i in range(L)]\n        for i in range(L):\n            dp[i][1] = (cumsum[i])/(i+1) # we don't use dp[i][0]\n        for k in range(2,K+1):\n            for i in range(L):\n                tmp = dp[i][k-1]\n                for j in range(i):\n                    tmp = max(tmp, dp[j][k-1]+(cumsum[i]-cumsum[j])/(i-j))\n                dp[i][k] = tmp\n#         print(dp)\n        return dp[-1][K]         ", "class Solution:\n    def largestSumOfAverages(self, A, K):\n        P = [0]\n        for x in A: P.append(P[-1] + x)\n        def average(i, j):\n            return (P[j] - P[i]) / (j - i)\n\n        N = len(A)\n        dp = [average(i, N) for i in range(N)]\n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n\n        return dp[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # a recursive function where it gets each group from 1 to A-K2\n        # the recursive function builds a tree, \n        # O(K^(N-K))\n        # 9, 1,2,3, 9,6,7,8 , the state = (index, K2)\n        def ave(list_):\n            return sum(list_)/len(list_)\n        dp = {}\n        \n        def rec(index, k):\n            if index == len(A):\n                return 0\n            if (index,k) in dp:\n                return dp[(index,k)]\n            if k==1:\n                return ave(A[index:])\n            m=0\n            for i in range(index+1,len(A)):\n                m = max(m, ave(A[index:i]) + rec(i,k-1))\n            dp[(index,k)] = m\n            return m\n        return rec(0,K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        L = len(A)\n        dp = [\n            [0 for _ in range(K + 1)] for _out in range(L)\n        ]\n        \n        prefix_sum = [0 for _ in range(L + 1)]\n        for i in range(1, L + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n\n        dp[0][1] = A[0]\n        for i in range(1, L):\n            dp[i][1] = (prefix_sum[i] + A[i]) / (i + 1)\n            \n        # for i in dp:\n        #     print(i)\n\n        for i in range(1, L):\n            for k in range(2, K + 1):\n                if k > i + 1:\n                    dp[i][k] = dp[i][k - 1]\n                else:\n                    for j in range(-1, i):\n                        # this may be bottle neck\n                        subarr = A[j + 1 : i + 1]\n                        ave = (prefix_sum[i + 1] - prefix_sum[j + 1]) / (i - j)\n                        if j == -1:\n                            tmp = 0\n                        else:\n                            tmp = dp[j][k - 1]\n                        if ave + tmp > dp[i][k]:\n                            dp[i][k] = ave + tmp\n                            \n        # for i in dp:\n        #     print(i)\n        # print('done')\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        h = {}\n        def helper(curr, pos, k):\n            if pos == len(A):\n                return curr\n            if k == 0:\n                return float('-inf')\n            if (pos, k) in h:\n                return curr + h[(pos, k)]\n            res = 0\n            for i in range(pos, len(A)):\n                temp = sum(A[pos : (i + 1)]) / (i - pos + 1)\n                res = max(helper(temp, i + 1, k - 1), res)\n            h[(pos, k)] = res\n            return curr + res\n        \n        return helper(0, 0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        N = len(A)\n        summary = [0] * (N + 1)\n        for i, item in enumerate(A):\n            summary[i + 1] = summary[i] + item\n        dp = [[(summary[N] - summary[i]) / (N - i) for i in range(N)] for _ in range(K)]\n        for remain in range(1, K):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dp[remain][i] = max(dp[remain][i], (summary[j] - summary[i]) / (j - i) + dp[remain - 1][j])\n        return dp[-1][0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp = {}\n        def a(n,k):\n            if n<k:return 0\n            if (n,k) in dp:return dp[n,k]\n            if k == 1:\n                dp[n,k] = sum(A[:n])/float(n)\n                return dp[n,k]\n            dp[n,k] = 0\n            for i in range(n-1,0,-1):\n                a(i,k-1)\n                dp[n,k] = max(dp[n,k],a(i,k-1) + sum(A[i:n])/float(n-i))\n        a(len(A),K)\n        return dp[len(A),K]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0]*(K+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            dp[i][1] = sum(A[:i])/i\n        for i in range(2, n+1):\n            for j in range(2, min(K+1, i+1)):\n                dp[i][j] = max([dp[i-t][j-1] + sum(A[i-t:i]) / t for t in range(1,i)])\n        return dp[n][K]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        mem = {}\n        def dfs(l, K):\n            if((l, K) in mem):\n                return mem[(l, K)]\n            if(l==len(A)):\n                return 0\n            if(K==1):\n                return(sum(A[l:])/len(A[l:]))\n            ans = sum(A[l:])/len(A[l:])\n            for i in range(l+1, len(A)):\n                avg = sum(A[l:i])/len(A[l:i])\n                ans = max(ans, avg+dfs(i, K-1))\n            mem[(l, K)]=ans\n            return ans\n        return dfs(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # i is starting index of array\n        # return largest sum of averages for A[i:] using partitions\n        def dfs(i, partitions):\n            if partitions == 1:\n                return (cum[len(A)]-cum[i-1])/(len(A)-i+1)\n            mem[partitions][i] = 0\n            for j in range(i, len(A)+1):\n                if mem[partitions-1][j] == 0:\n                    mem[partitions-1][j] = dfs(j, partitions-1)\n                if j > i:\n                    mem[partitions][i] = max(mem[partitions][i], mem[partitions-1][j] + (cum[j-1]-cum[i-1])/(j-i))\n                else:\n                    mem[partitions][i] = max(mem[partitions][i], mem[partitions-1][j])\n            return mem[partitions][i]\n                \n        ans = 0\n        cum = [0 for i in range(len(A)+1)]\n        # mem[i][j] = i partitions from A[j]\n        mem = [[0 for i in range(len(A)+1)] for j in range(K+1)]\n        cum[0] = 0\n        # cum[i] = sum of A[j] where j < i\n        for i in range(len(A)):\n            cum[i+1] = cum[i] + A[i]\n        return dfs(1, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        from functools import lru_cache\n        @lru_cache(None)\n        def maxAverage(j, k):\n            if j == k:\n                return sum(A[:j])\n            if k == 1:\n                return sum(A[:j])/j\n            ans = 0\n            for i in range(j-1, max(-1,k-2), -1):\n                ans = max(ans, (sum(A[i:j]))/(j-i) + maxAverage(i, k-1))\n            return ans        \n        return maxAverage(len(A), K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        N = len(A)\n        pre_sum = [0 for i in range(N)]\n        pre_sum[0] = A[0]\n        \n        for j in range(1, len(A)):\n            \n            pre_sum[j] = pre_sum[j-1] + A[j]\n            \n        dp = [[0 for n in range(N)] for k in range(K+1)]\n        \n        for i in range(N):\n            \n            dp[1][i] = pre_sum[i]/(i+1)\n        \n        for k in range(2, K+1):\n            \n            for i in range(N):\n                \n                for j in range(i):\n                    \n                    dp[k][i] = max(dp[k][i], pre_sum[i]/(i+1), dp[k-1][j] + (pre_sum[i] - pre_sum[j])/(i-j))\n        \n        return dp[K][N-1]\n        \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        N = len(A)\n\n        @lru_cache(None)\n        def dfs(index, remain, acc, size):\n            if index >= N:\n                return 0 if size == 0 else acc / size\n            ans = 0\n            if remain > 0:\n                ans = max(ans, (acc + A[index]) / (size + 1) + dfs(index + 1, remain - 1, 0, 0))\n            ans = max(ans, dfs(index + 1, remain, acc + A[index], size + 1))\n            return ans\n\n        return dfs(0, K - 1, 0, 0)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        if K >= n: return sum(A)\n        \n        B = [0] * (n+1)\n        B[1] = A[0]\n        for i in range(1, n):\n            B[i+1] = B[i] + A[i]\n        \n        maxSum = 0\n        \n        @lru_cache(None)\n        def dp(si, ei, remainK):\n            if ei == n:\n                return (B[ei] - B[si]) / (ei - si)\n            tmp = 0 \n            if remainK > 1:\n                tmp = max(tmp, (B[ei] - B[si]) / (ei - si) + dp(ei, ei+1, remainK - 1))\n                \n            tmp = max(tmp, dp(si, ei+1, remainK))\n            return tmp\n            \n        #maxSum = max(maxSum, dp(ovr_))\n        maxSum = dp(0, 1, K)\n        print(maxSum)\n        \n        return maxSum", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        P = [0]\n        for x in A:\n            P.append(P[-1] + x)\n        \n        def average(i, j):\n            return (P[j] - P[i]) / float(j-i)\n        \n        N = len(A)\n        dp = [average(i, N) for i in range(N)]\n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n        \n        return dp[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        L = len(A)\n        dp = [\n            [0 for _ in range(K + 1)] for _out in range(L)\n        ]\n        \n        dp[0][1] = A[0]\n        for i in range(1, L):\n            dp[i][1] = (dp[i - 1][1] * i + A[i]) / (i + 1)\n        # for i in dp:\n        #     print(i)\n            \n        for i in range(1, L):\n            for k in range(2, K + 1):\n                if k > i + 1:\n                    dp[i][k] = dp[i][k - 1]\n                else:\n                    for j in range(-1, i):\n                        subarr = A[j + 1 : i + 1]\n                        # print(j, i, subarr)\n                        ave = sum(subarr) / len(subarr)\n                        if j == -1:\n                            tmp = 0\n                        else:\n                            tmp = dp[j][k - 1]\n                        # print(ave, tmp)\n                        if ave + tmp > dp[i][k]:\n                            dp[i][k] = ave + tmp\n        # for i in dp:\n        #     print(i)\n        # print('done')\n        return dp[-1][-1]", "class Solution:\n    def solve(self, start_index, num_groups):\n        if (start_index, num_groups) in self.memo:\n            return self.memo[(start_index, num_groups)]\n        \n        if start_index == 0:\n            sum_up_to = 0\n        else:\n            sum_up_to = self.sums[start_index - 1]\n        \n        if num_groups == 1:\n            res = (self.sums[-1] - sum_up_to) / (self.N - start_index)\n        else:\n            res = 0\n            num_remaining_groups = num_groups - 1\n            for start_next_group in range(start_index + 1, self.N - num_remaining_groups + 1):\n                group_avg = (self.sums[start_next_group - 1] - sum_up_to) / (start_next_group - start_index)\n                res = max(res, group_avg + self.solve(start_next_group, num_groups - 1))\n                pass\n        \n        self.memo[(start_index, num_groups)] = res\n        return res\n    \n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        self.memo = {} # start index, K -> result\n        \n        self.N = len(A)\n        self.sums = [None] * len(A)\n        self.sums[0] = A[0]\n        for i in range(1, len(A)):\n            self.sums[i] = self.sums[i - 1] + A[i]\n        \n        r = self.solve(0, K)\n        print(self.memo)\n        return r", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        self.dp = {}\n        self.arr = A\n        ans = self.helper(0,K-1)\n        #print(self.dp)\n        return ans\n        \n    \n    def helper(self,i,k):\n        if(k == 0):\n            return sum(self.arr[i:])/len(self.arr[i:])\n        if(i == len(self.arr)-1):\n            return -10**100\n        \n        if((i,k) in self.dp):\n            return self.dp[(i,k)]\n        \n        ans = 0\n        for j in range(i,len(self.arr)-1):\n            tmp = sum(self.arr[i:j+1])/(len(self.arr[i:j+1])) + self.helper(j+1, k-1)\n            ans = max(ans, tmp)\n        self.dp[(i,k)] = ans\n        return self.dp[(i,k)]\n", "class Solution:\n    def part(self, A, i, K, cache):\n        if i < 0:\n            if K == 0:\n                return 0\n            return float('-Inf')\n        if i == 0:\n            if K != 1:\n                return float('-Inf')\n            return A[i]\n        key = '{}-{}'.format(i, K)\n        if key in cache:\n            return cache[key]\n        res = float('-Inf')\n        sm = 0\n        count = 0\n        for j in range(i, -1, -1):\n            sm += A[j]\n            count += 1\n            avg = float(sm) / float(count)\n            res = max(res, avg + self.part(A, j-1, K-1, cache))\n        cache[key] = res\n        return res\n    \n    def solve(self, A, K):\n        return self.part(A, len(A)-1, K, {})\n    \n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        return self.solve(A, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        if K >= n: return sum(A)\n        \n        B = [0] * (n+1)\n        B[1] = A[0]\n        for i in range(1, n):\n            B[i+1] = B[i] + A[i]\n        \n        @lru_cache(None)\n        def dp(si, ei, remainK):\n            if ei == n:\n                return (B[ei] - B[si]) / (ei - si)\n            tmp = 0 \n            if remainK > 1:\n                tmp = max(tmp, (B[ei] - B[si]) / (ei - si) + dp(ei, ei+1, remainK - 1))\n                \n            tmp = max(tmp, dp(si, ei+1, remainK))\n            return tmp\n        \n        return dp(0, 1, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], k: int) -> float:\n        n=len(A)\n        mtr=[[0 for i in range(n+1)] for j in range(k+1)]\n        # mtr[k][n]\n    \n        \n       \n        # RECURSIVE START\n        def rec(parts,arrIndex):\n            # print(parts,arrIndex)\n            if mtr[parts][arrIndex]!=0:\n                return mtr[parts][arrIndex]\n            \n            if parts==1:\n                mtr[parts][arrIndex]=sum(A[:arrIndex+1])/(arrIndex+1)\n                return mtr[parts][arrIndex]\n            \n            for x in range(1,arrIndex+1):\n                mtr[parts][arrIndex]=max(mtr[parts][arrIndex],rec(parts-1,x-1)+sum(A[x:arrIndex+1])/(arrIndex+1-x))\n            return mtr[parts][arrIndex]\n        \n        rec(k,n-1)\n        # RECURSIVE END\n\n        \n        \n        # ITERATIVE START\n        # for i in range(n):\n        #     mtr[1][i]=sum(A[:i+1])/(i+1)    \n        # for i in range(2,k+1):\n        #     for j in range(n):\n        #         for x in range(j+1):\n        #             # print(\\\"(\\\",mtr[i-1][x],\\\",\\\",x,\\\")\\\",mtr[i-1][x]+(sum(A[x:j])/(j-x)),i,x,j)\n        #             mtr[i][j] = max(mtr[i][j],mtr[i-1][x-1]+(sum(A[x:j+1])/(j+1-x)))\n        # ITERATIVE END\n\n\n\n#         for i in mtr:\n#             print(i)\n        \n        ans=sys.maxsize *(-1)\n        for i in range(1,k+1):\n            ans=max(ans,mtr[i][-2])\n        return ans\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        self.memo = {}       \n        def helper(start,end,K,prefix):\n            if (start,end,K) in self.memo.keys():\n                return self.memo[(start,end,K)]\n            \n            if K == 0: return (prefix[end+1] - prefix[start])/(end-start+1)\n            \n            if end == start: return prefix[end+1] - prefix[end]\n            if end < start : return 0 \n            \n            maxAvg = 0\n            for i in range(start,end):\n                maxAvg = max(maxAvg,(prefix[i+1]-prefix[start])/(i-start+1) + helper(i+1,end,K-1,prefix))\n            self.memo[(start,end,K)] = maxAvg\n            return maxAvg\n            \n        \n        n = len(A)\n        prefix = [ 0 for _ in range(n+1)]\n        for i in range(1,n+1):\n            prefix[i] = prefix[i-1] + A[i-1]            \n        \n        ans = 0\n        for k in range(K):\n            ans = max(ans, helper(0,n-1,k,prefix))\n            \n            \n        return ans", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0] * n for _ in range(K)] \n        # dp: K*n, dp[k][i]: result for largestSum of first (i+1) elements with k+1 groups\n        for i in range(n):\n            dp[0][i] = sum(A[:(i+1)]) / (i+1)\n        for l in range(1, K):\n            for i in range(l, n):\n                for j in range(i):\n                    dp[l][i] = max(dp[l][i], dp[l-1][j] + sum(A[j+1:i+1])/(i-j))\n        return dp[K-1][n-1]        ", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0] * n for _ in range(K)] \n        # dp: K*n, dp[k][i]: result for largestSum of first (i+1) elements with k+1 groups\n        for i in range(n):\n            dp[0][i] = sum(A[:(i+1)]) / (i+1)\n        for l in range(1, K):\n            for i in range(l, n):\n                for j in range(i):\n                    dp[l][i] = max(dp[l][i], dp[l-1][j] + sum(A[j+1:i+1])/(i-j))\n        print(dp)\n        return dp[K-1][n-1]        ", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        len_A = len(A)\n        dp = [[0 if j else sum(A[:i + 1]) / (i + 1) for j in range(K)] for i in range(len_A)]\n        for i in range(len_A):\n            for j in range(1, K):\n                if j > i:\n                    break\n                for k in range(i):\n                    dp[i][j] = max(dp[i][j], dp[k][j - 1] + sum(A[k + 1:i + 1]) / (i - k))\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # dynamic programming, O(NKN) time, O(NK) space\n        avg = lambda arr: sum(arr) / len(arr)        \n        n = len(A)\n        dp = [[0] * K for _ in range(n)]\n        for i in range(n):\n            for k in range(K):\n                if k == 0:\n                    dp[i][k] = avg(A[:i+1])\n                else:\n                    if len(A[:i+1]) < k+1:\n                        break\n                    for j in range(i):\n                        dp[i][k] = max(dp[j][k-1] + avg(A[j+1:i+1]), dp[i][k])\n        print(dp)\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        n = len(A)\n        dp = [[0 for k in range(K)] for i in range(n)]\n        for k in range(K):\n            dp[0][k] = A[0]\n        for i in range(1, n):\n            dp[i][0] = dp[i-1][0] * i / (i+1) + A[i] / (i+1)\n        for k in range(1, K):\n            for i in range(1, n):\n                dp[i][k] = dp[i][k-1]\n                for j in range(i):\n                    dp[i][k] = max(dp[i][k], dp[j][k-1] + sum(A[j+1:i+1])/(i-j))\n        return dp[n-1][K-1]\n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         memo = [[0 for k in range(K)] for i in range(n)]\n        \n#         def aux(A, cur, k, memo):\n#             if cur == len(A):\n#                 return 0\n#             if memo[cur][k]:\n#                 return memo[cur][k]\n#             tmp = sum(A[cur:])/(len(A)-cur)\n#             if k == 0:\n#                 memo[cur][k] = tmp\n#                 return tmp\n#             for i in range(cur+1, len(A)+1):\n#                 tmp = max(tmp, sum(A[cur:i])/(i-cur) + aux(A, i, k-1, memo))\n#             memo[cur][k] = tmp\n#             return tmp\n                \n#         return aux(A, 0, K-1, memo)\n        \n        \n        \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        n = len(A)\n        dp = [[0 for k in range(K)] for i in range(n)]\n        for k in range(K):\n            dp[0][k] = A[0]\n        for i in range(1, n):\n            dp[i][0] = dp[i-1][0] * i / (i+1) + A[i] / (i+1)\n        for k in range(1, K):\n            for i in range(1, n):\n                for j in range(i):\n                    dp[i][k] = max(dp[i][k], dp[j][k-1] + sum(A[j+1:i+1])/(i-j))\n        return dp[n-1][K-1]\n                \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#         memo = [[0 for k in range(K)] for i in range(n)]\n        \n#         def aux(A, cur, k, memo):\n#             if cur == len(A):\n#                 return 0\n#             if memo[cur][k]:\n#                 return memo[cur][k]\n#             tmp = sum(A[cur:])/(len(A)-cur)\n#             if k == 0:\n#                 memo[cur][k] = tmp\n#                 return tmp\n#             for i in range(cur+1, len(A)+1):\n#                 tmp = max(tmp, sum(A[cur:i])/(i-cur) + aux(A, i, k-1, memo))\n#             memo[cur][k] = tmp\n#             return tmp\n                \n#         return aux(A, 0, K-1, memo)\n        \n        \n        \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        p = [0]\n        for i in range(n):\n            p.append(p[i]+A[i])\n        def average(i,j):\n            return (p[j]-p[i]) / (j-i)\n        dp = [[0]*n for _ in range(K)]\n        for i in range(n):\n            dp[0][i] = average(i,n)            \n            \n\n        for k in range(1, K):\n            for i in range(n):\n                for j in range(i+1, n):\n                    dp[k][i] = max(dp[k][i], average(i,j)+dp[k-1][j])\n        return dp[K-1][0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # dynamic programming, \n        avg = lambda arr: sum(arr) / len(arr)        \n        n = len(A)\n        dp = [[0] * K for _ in range(n)]\n        for i in range(n):\n            for k in range(K):\n                if k == 0:\n                    dp[i][k] = avg(A[:i+1])\n                else:\n                    if len(A[:i+1]) < k+1:\n                        break\n                    for j in range(i):\n                        dp[i][k] = max(dp[j][k-1] + avg(A[j+1:i+1]), dp[i][k])\n        print(dp)\n        return dp[-1][-1]", "class Solution:\n    def mean(self, l):\n        return sum(l)/len(l)\n    \n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        DP = [self.mean(A[i:n]) for i in range(n)]\n        \n        for k in range(K-1):\n            for i in range(n):\n                for j in range(i+1, n):\n                    DP[i] = max(DP[i], self.mean(A[i:j]) + DP[j])\n\n        return DP[0]\n        \n        \n        \n        \n#         n = len(A)\n#         if n==1:\n#             return A[0]\n#         if K==1:\n#             return self.mean(A)\n#         DP = {}\n        \n#         for i in range(1, n-K+2):\n#             if i>n-1:\n#                 break\n#             if K==2:\n#                 DP[i] = self.mean(A[:i]) + self.mean(A[i:])\n#             else:\n#                 DP[i] = self.mean(A[:i]) + self.largestSumOfAverages(A[i:], K-1)\n#         return max(list(DP.values()))\n\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        sums = [0 for i in range(n+1)]\n        dp = [[0 for i in range(n+1)] for k in range(K+1)]\n        \n        for i in range(1, n+1):\n            sums[i] += sums[i-1] + A[i-1]\n        \n        for i in range(1,n+1):\n            dp[1][i] = sums[i] / i\n        \n        for k in range(2, K+1):\n            for i in range(n+1):\n                for j in range(i):\n                    dp[k][i] = max(dp[k][i], dp[k-1][j] + (sums[i] - sums[j]) / (i-j))\n        return dp[K][n]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        def avg(array):\n            return sum(array) / len(array)\n        dp = [[0 for _ in range(K)] for _ in range(len(A))]\n        dp[0][0] = A[0]\n        for i in range(len(A)):\n            for j in range(K):\n #               if i == 0 and j != 0:\n #                  continue\n                if j == 0:\n                    dp[i][j] = avg(A[:i+1])\n                else:\n                    for k in range(i):\n                        dp[i][j] = max(dp[i][j],dp[k][j-1]+avg(A[k+1:i+1]))\n        return dp[len(A)-1][K-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        self.arr = [[None for i in range(K)] for i in range(len(A))]\n        res = self.solve(A, 0, K, -1)\n        #print(self.arr)\n        return res\n    \n    \n    def solve(self, arr, i, grpLeft, lastInd):\n        if i == len(arr):\n            return 0\n\n        if self.arr[lastInd+1][grpLeft-1] != None:\n            return self.arr[lastInd+1][grpLeft-1]\n        \n        if grpLeft == 1:\n            self.arr[lastInd+1][0] = sum(arr[lastInd+1:])/(len(arr)-lastInd-1)\n            return self.arr[i][0]\n        \n        avg = float(sum(arr[lastInd+1:i+1]))/(i-lastInd)\n     \n        self.arr[lastInd+1][grpLeft-1] = max(self.solve(arr, i+1, grpLeft, lastInd), avg + self.solve(arr, i+1, grpLeft-1, i))\n        return self.arr[lastInd+1][grpLeft-1]\n\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0]*(K+1) for i in range(n)]\n        total = [A[0]]\n        for i in range(1, n):\n            total.append(A[i] + total[i-1])\n        def solve(start, k):\n            if dp[start][k] != 0:\n                return dp[start][k]\n            \n            if k == 1:\n                dp[start][k] = (total[n-1] - total[start] + A[start])/(n-start)\n                return dp[start][k]\n            \n            i = start\n            while i + k <= n:\n                temp = (total[i] - total[start] + A[start])/(i-start+1) + solve(i+1, k-1)\n                dp[start][k] = max(dp[start][k], temp)\n                i += 1\n            return dp[start][k]\n        \n        return solve(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], k: int) -> float:\n        n=len(A)\n        mtr=[[0 for i in range(n+1)] for j in range(k+1)]\n        # mtr[k][n]\n        for i in range(n):\n            mtr[1][i]=sum(A[:i+1])/(i+1)\n        for i in range(2,k+1):\n            for j in range(n):\n                for x in range(j+1):\n                    # print(\\\"(\\\",mtr[i-1][x],\\\",\\\",x,\\\")\\\",mtr[i-1][x]+(sum(A[x:j])/(j-x)),i,x,j)\n                    mtr[i][j] = max(mtr[i][j],mtr[i-1][x-1]+(sum(A[x:j+1])/(j+1-x)))\n        # for i in mtr:\n        #     print(i)\n        \n        ans=sys.maxsize *(-1)\n        for i in range(1,k+1):\n            ans=max(ans,mtr[i][-2])\n        return ans\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], k: int) -> float:\n        n=len(A)\n        mtr=[[0 for i in range(n+1)] for j in range(k+1)]\n        # mtr[k][n]\n        # for i in range(n):\n        #     mtr[1][i]=sum(A[:i+1])/(i+1)\n        \n       \n            \n        def rec(parts,arrIndex):\n            # print(parts,arrIndex)\n            if mtr[parts][arrIndex]!=0:\n                return mtr[parts][arrIndex]\n            \n            if parts==1:\n                mtr[parts][arrIndex]=sum(A[:arrIndex+1])/(arrIndex+1)\n                return mtr[parts][arrIndex]\n            \n            for x in range(1,arrIndex+1):\n                mtr[parts][arrIndex]=max(mtr[parts][arrIndex],rec(parts-1,x-1)+sum(A[x:arrIndex+1])/(arrIndex+1-x))\n            return mtr[parts][arrIndex]\n        \n        rec(k,n-1)\n        \n        \n#         for i in range(2,k+1):\n#             for j in range(n):\n#                 for x in range(j+1):\n#                     # print(\\\"(\\\",mtr[i-1][x],\\\",\\\",x,\\\")\\\",mtr[i-1][x]+(sum(A[x:j])/(j-x)),i,x,j)\n#                     mtr[i][j] = max(mtr[i][j],mtr[i-1][x-1]+(sum(A[x:j+1])/(j+1-x)))\n        for i in mtr:\n            print(i)\n        \n        ans=sys.maxsize *(-1)\n        for i in range(1,k+1):\n            ans=max(ans,mtr[i][-2])\n        return ans\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp=[[0 for j in range(K)] for i in A]\n        for j in range(len(A)):\n            for i in range(K): \n                if i==0:\n                    dp[j][i]=sum(A[:j+1])/len(A[:j+1])\n                else:\n                    if len(A[:j+1])<i+1:\n                        break\n                    for k in range(j):\n                        dp[j][i]=max(dp[k][i-1]+sum(A[k+1:j+1])/len(A[k+1:j+1]), dp[j][i])\n        return dp[-1][-1]\n", "class Solution():\n    def largestSumOfAverages(self, A, K: int) -> float:\n        dp = []\n        for i in range(len(A)):\n            tmp = []\n            for j in range(1, 1 + K):\n                tmp.append(0)\n            dp.append(tmp)\n        v = 0\n        for i in range(len(dp)):\n            v += A[i]\n            for j in range(len(dp[0])):\n                if j == 0:\n                    dp[i][j] = v / (i+1)\n                elif j == i:\n                    dp[i][j] = v\n        for i in range(len(dp)):\n            for j in range(1,min(i,K)):\n                for t in range(i):\n                    dp[i][j] = max(dp[i][j],dp[t][j-1]+self.avg(A[t+1:i+1]))\n        return dp[-1][-1]\n\n    def avg(self,nums):\n        return sum(nums) / len(nums)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        accsum = A[:]\n        l = len(accsum)\n        for i in range(1, l):\n            accsum[i] += accsum[i-1]\n        \n        cache = {}\n        def dp(i, k):\n            prev = accsum[i-1] if i>0 else 0\n            \n            if k == 1:\n                res = (accsum[l-1]-prev)/(l-i)\n                cache[(i,k)] = res\n                return res\n\n            if (i,k) in cache:\n                return cache[(i, k)]\n            if l-i < k:\n                return -float('inf')\n            if l-i == k:\n                res = accsum[l-1]-prev\n                cache[(i,k)] = res\n                return res\n            \n            res = 0\n            for j in range(i, l-k+1):\n                res = max(res, (accsum[j]-prev)/(j-i+1) + dp(j+1, k-1))\n            cache[(i, k)] = res\n            return res\n    \n        return dp(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp = [[0 for j in range(K)] for i in A]\n        for j in range(len(A)):\n            for i in range(K):\n                if i==0:\n                    dp[j][i] = sum(A[:j+1])/len(A[:j+1])\n                else:\n                    if len(A[:j+1]) < i+1:\n                        break\n                    for k in range(j):\n                        dp[j][i]=max(dp[k][i-1]+sum(A[k+1:j+1])/len(A[k+1:j+1]),dp[j][i])\n        return dp[-1][-1]\n                    \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        memo = {}\n\n        def fn(nums, k):\n            if len(nums) <= k:\n                return sum(nums)\n            elif k == 1:\n                return sum(nums) / len(nums)\n            else:\n                max_avg = 0\n                for i in reversed(range(len(nums))):\n                    key = (tuple([num for num in nums[:i]]), k-1)\n                    if key not in memo:\n                        memo[key] = fn([num for num in nums[:i]], k-1)\n                    avg = memo[key] + sum(nums[i:]) / (len(nums) - i)\n                    max_avg = max(max_avg, avg)\n                return max_avg\n\n        return fn(A, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        averages = [[None for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            averages[i][i] = A[i]\n        for i in range(n-1):\n            for j in range(i+1, n):\n                averages[i][j] = (averages[i][j-1] * (j - i) + A[j]) / (j - i + 1)\n        dp = [[None for _ in range(K)] for _ in range(n+1)]\n        def largestSum(i, count):\n            if dp[i][count] != None:\n                return dp[i][count]\n            if i == n:\n                dp[i][count] = 0\n                return 0\n            if count == K - 1:\n                dp[i][count] = averages[i][n-1]\n                return averages[i][n-1]\n            largest = float('-inf')\n            for k in range(n):\n                largest = max(largest, averages[i][min(i+k,n-1)] + largestSum(min(i+k+1,n), count+1))\n            dp[i][count] = largest\n            return largest\n        return largestSum(0, 0)\n                \n", "class Solution:\n    def largestSumOfAverages(self, A, K):\n    \n        dp=[[0 for j in range(K)] for i in A]\n    \n     \n        for j in range(len(A)):\n            for i in range(K): \n                if i==0:\n                    dp[j][i]=sum(A[:j+1])/len(A[:j+1])\n                else:\n                    if len(A[:j+1])<i+1:\n                        break\n                    for k in range(j):\n                    \n                        dp[j][i]=max(dp[k][i-1]+sum(A[k+1:j+1])/len(A[k+1:j+1]),dp[j][i])\n                    \n\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        @lru_cache(None)\n        def helper(i,t):\n            if(i>=len(A)):\n                return 0\n            if(t==K-1):\n                return sum(A[i:])/(len(A)-i)\n            else:\n                m=-1\n                for j in range(1,len(A)):\n                    m=max(m,helper(i+j,t+1)+sum(A[i:i+j])/j) \n                    if(t==3):\n                        print(m)\n                return m\n        return helper(0,0)", "class Solution:\n    def largestSumOfAverages(self, a: List[int], k: int) -> float:\n        def rec(st, k):\n            if (st, k) in cache:\n                return cache[(st, k)]\n            if k == 1:\n                cache[(st, k)] = sum(a[st:])/(len(a)-st)\n                return cache[(st, k)]\n            total = 0\n            res = -math.inf\n            for i in range(st, len(a)-k+1):\n                total += a[i]\n                res = max(res, (total/(i-st+1)) + rec(i+1, k-1))\n            cache[(st, k)] = res\n            return cache[(st, k)]\n        cache = {}\n        return rec(0, k)\n", "def find(dp,start,end,k,arr):\n    if start > end:\n        return -float('inf')\n    if k <= 0:\n        return -float('inf')\n    if (start,end,k) in dp.keys():\n        return dp[(start,end,k)]\n\n    if start == end:\n        if k == 1:\n            return arr[start]\n        return 0\n    \n    ans = 0\n    total = 0\n    count = 0\n    for i in range(start,end+1):\n        total += arr[i]\n        count += 1\n        if k-1 > 0:\n            find(dp,i+1,end,k-1,arr)\n            ans = max(ans,(total/count)+find(dp,i+1,end,k-1,arr))\n\n    ans = max(ans,total/count)\n    dp[(start,end,k)] = ans\n\n    return ans\n\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp = {}\n        return find(dp,0,len(A)-1,K,A)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], k: int) -> float:\n          n=len(A)\n          pre= list(itertools.accumulate([0]+A))\n          dp={}\n          def dfs(i,k):\n             if (i,k) in dp:\n                    return dp[(i,k)]\n             if k==1:\n                    dp[(i,k)]=(pre[-1]-pre[i])/(n-i)\n                    return dp[(i,k)]\n             ans=-float('inf');cur=0\n             for j in range(i,n-k+1):\n                  ans=max(ans,(pre[j+1]-pre[i])/(j-i+1)+dfs(j+1,k-1))\n             dp[(i,k)]=ans\n             return ans\n          return dfs(0,k)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        #if not A: return 0\n        #if len(A)==1: return A[0]\n        # Real Run Time is a little bit UNSTABLE\n        N = len(A)\n        P = [0] * (N+1)\n        for i in range(1,N+1): P[i] = P[i-1] + A[i-1] # \u6ce8\uff1a cumulative sum of A[:i]\n        \n        # Table[a] = optimal for A[a:] with k subsets, initially k=1\n        Table = [(P[N]-P[i])/(N-i) for i in range(N)]\n        for k in range(2, K+1): # \u6ce8\uff1a starting from k=2 subsets, end at k=K subsets at most\n            # \u6ce8\uff1a optimal for A[i:] with k subsets means: optimal pair{ 1 subset A[i:j] and optimal A[j:] with (k-1) subsets whose value saved in Table[j], where i+1=<j<=N-(k-1)}\n            for i in range(K-k,N-(k-1)): # \u6ce8\uff1a \n                Table[i] = max((P[j]-P[i])/(j-i) + Table[j] for j in range(i+1,N-(k-1)+1))\n        \n        return Table[0]   ", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        @lru_cache(None)\n        def dp(n,k):\n            if n<k:\n                return 0\n            if k==1:\n                return sum(A[:n])/n\n            cur, ans = 0,0\n            for i in range(n-1,0,-1):\n                cur+=A[i]\n                ans =max(ans, dp(i, k-1)+ cur/(n-i))\n            return ans\n        return dp(len(A),K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = {}\n        def f(i, k):\n            if (i, k) not in dp:\n                if k == 1:\n                    dp[(i, k)] = sum(A[i:])/(n - i)\n                else:\n                    dp[(i, k)] = max([(sum(A[i:j])/(j - i) + f(j, k - 1)) for j in range(i + 1, n - k + 2)])\n            return dp[(i, k)]\n        return f(0, K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [0] * (n + 1)\n        sums = [0] * (n + 1)\n        for i in range(1, n + 1):\n            sums[i] = sums[i - 1] + A[i - 1]\n            dp[i] = sums[i] / i\n            \n        for k in range(2, K + 1):\n            tmp = [0] * (n + 1)\n            for i in range(k, n + 1):\n                for j in range(k - 1, i):\n                    tmp[i] = max(tmp[i], dp[j] + (sums[i] - sums[j]) / (i - j))\n            dp = list(tmp)\n        \n        return dp[n]\n                    \n                    \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if K == 1:\n            return sum(A)/(len(A))\n        \n        memo = [[0]*len(A) for _ in range(K)]\n        cumsum = [0]*len(A)\n        \n        for i in range(len(A)):\n            cumsum[i] = cumsum[i-1] + A[i]\n            memo[0][i] = cumsum[i]/(i+1)\n        \n        for i in range(1,K):\n            for j in range(i,len(A)):\n                tmp = 0\n                for k in range(i-1,j):\n                    tmp = max(tmp, memo[i-1][k] +(cumsum[j]-cumsum[k])/(j-k))\n                    \n                memo[i][j] = tmp\n        \n        return memo[-1][-1]\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp = [[0.0 for j in range(K + 1)] for i in range(len(A))]\n        sums = [0] * len(A)\n        sums[0] = A[0]\n        for i in range(1, len(A)):\n            sums[i] = sums[i - 1] + A[i]\n\n        for k in range(1, K + 1):\n            for i in range(len(A)):\n                if k == 1:\n                    dp[i][k] = sums[i] / (i + 1)\n                elif k > i + 1:\n                    continue\n                else:\n                    for j in range(k - 1, i + 1):\n                        avg1 = dp[j - 1][k - 1]\n                        avg2 = (sums[i] - sums[j - 1]) / (i - j + 1)\n                        if dp[i][k] < avg1 + avg2:\n                            dp[i][k] = avg1 + avg2\n\n        return dp[-1][K]", "from functools import lru_cache\n\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # K <= A <= 100\n        # O((AK)^2) could work\n        # Looks like dp\n        \n        @lru_cache(None)\n        def rec(j,K):\n            nonlocal A\n            \n            if K == 1:\n                return sum(A[0:j+1])/(j+1)\n            \n            res = 0\n            runningsum = 0\n            for i in range(j, K-2, -1):\n                runningsum += A[i]\n                res = max(res, runningsum/(j - i + 1) + rec(i-1,K-1))\n            return res\n        \n        return rec(len(A)-1, K)\n            \n        \n        \n", "import functools\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        @functools.lru_cache(None)\n        def dp(start,p):\n            if p==1:\n                return sum(A[start:])/(len(A)-start)\n            if start==len(A):\n                return 0\n            curr_sum=A[start]\n            ret=0\n            for i in range(start+1,len(A)):\n                avg=curr_sum/(i-start)\n                ret=max(ret,avg+dp(i,p-1))\n                curr_sum+=A[i]\n            return ret\n        return dp(0,K)\n            \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        N = len(A)\n        P = [0]\n        for a in A:\n            P.append(P[-1]+a)\n\n        dp = [0]*(N+1)\n        for i in range(K):\n            dp2 = [0]*(N+1)\n            for j in range(i, N+1):\n                if i==0 and j!=0:\n                    dp2[j] = P[j]/j\n                    continue\n                    \n                for k in range(i-1, j):\n                    dp2[j] = max(dp2[j], dp[k]+(P[j]-P[k])/(j-k))\n            \n            dp = dp2\n        return dp[-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        num_count     = len(A)\n        previous_best = [0]*num_count # best average sums for the previous number of partitions\n        current_best  = [0]*num_count # best average sums for the current number of partitions\n        \n        previous_best[0] = A[0] \n        for index in range(1, num_count):\n            A[index] += A[index - 1]\n            previous_best[index] = A[index] / (index + 1)\n        \n        for partition_count in range(1, K):\n            for end_index in range(partition_count, num_count - K + partition_count + 1):\n                \n                current_best[end_index] = max(\n                    (A[end_index] - A[start_index]) / (end_index - start_index)  + previous_best[start_index] \n                    for start_index in range(partition_count - 1, end_index)\n                )\n            current_best, previous_best = previous_best, current_best\n        return previous_best[-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        memoDict = {}\n        def recurse(i,k):\n            #print(i,k)\n            n = len(A)\n            max_win = n-i - (k-1)\n            if (i,k) in memoDict:\n                return memoDict[(i,k)] \n            if k == 0:\n                return sum(A[i:])/(n-i)\n            else:\n                max_sum = 0\n                for ind in range(1,max_win):\n                    lul = recurse(i+ind,k-1)+sum(A[i:i+ind])/(ind)\n                    max_sum = max(max_sum,lul)\n                    #print(A[i:i+ind],A[i+ind:],lul,k)\n                memoDict[(i,k)] = max_sum   \n                return max_sum\n        flips = recurse(0,K-1)\n        #print(memoDict)\n        return flips ", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(i,j):\n            if i == n:\n                return float('-inf')\n            if j == 1:\n                return sum(A[i:]) / (n-i)\n            ans = float('-inf')\n            cur_sum = 0\n            for l in range(i, n):\n                cur_sum += A[l]\n                ans = max(ans, cur_sum / (l-i+1) + dp(l+1, j-1))\n            return ans;\n        return dp(0, K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix_sum = [A[0]]\n        for a in A[1:]:\n            prefix_sum.append(prefix_sum[-1] + a)\n        dp = [[0 for _ in range(len(A))] for _ in range(K)]\n        for i in range(len(A)):\n            dp[0][i] = prefix_sum[i] / (i + 1)\n        for k in range(1, K):\n            for i in range(k, len(A)):\n                for j in range(k - 1, i):\n                    dp[k][i] = max(dp[k][i], dp[k - 1][j] + (prefix_sum[i] - prefix_sum[j]) / (i - j))\n        return dp[K - 1][len(A) - 1]\n        # dp[i][j] => result for i+1 groups, j idx in A\n        # dp[i][j] = max(dp[i-1][k] + avg(A[k+1:j]) for k = 0..j-1)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0] * K for _ in range(n)]\n        dp[0][0] = A[0]\n        for i in range(1, n):\n            dp[i][0] = (dp[i-1][0] * i + A[i]) / (i + 1)\n\n        for k in range(1, K):\n            for i in range(k, n):\n                curr_sum = 0\n                for j in reversed(range(k, i+1)):\n                    curr_sum += A[j]\n                    dp[i][k] = max(dp[i][k], dp[j-1][k-1] + curr_sum / (i+1 - j))\n        return dp[n-1][K-1]", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        memo = {}\n        def search(n, k):\n            if (n, k) in memo: \n                return memo[n, k]\n            if n < k: \n                return 0\n            if k == 1:\n                memo[n, k] = sum(A[:n]) / float(n)\n                return memo[n, k]\n            cur = 0\n            res = 0\n            for i in range(n - 1, 0, -1):\n                cur += A[i]\n                res = max(res, search(i, k - 1) + cur / float(n - i))\n            memo[n, k] = res\n            return memo[n, k]\n        return search(len(A), K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if not A:\n            return 0\n        n = len(A)\n        # Pre compute sums\n        sums = [0] * (n + 1)\n        # dp[k][i] stands for the answer of first i elements divided into k groups\n        dp = [[float('-inf')] * (n + 1) for _ in range(K + 1)]\n        for i in range(1, n + 1):\n            sums[i] = sums[i - 1] + A[i - 1]\n            dp[1][i] = sums[i] / i\n        for k in range(2, K + 1):\n            for i in range(k, n + 1):\n                # Break point j from k - 1 till i\n                for j in range(k - 1, i):\n                    ave_i_j = (sums[i] - sums[j]) / (i - j)\n                    dp[k][i] = max(dp[k][i], dp[k - 1][j] + ave_i_j)\n        return dp[K][n]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if not A:\n            return 0\n        elif len(A) <= K:\n            return sum(A)\n        size = len(A)\n        dp = [[0] * (size + 1) for _ in range(K + 1)]\n        preSum = [sum(A[:i]) for i in range(size + 1)]\n        for j in range(size):\n            dp[1][j + 1] = (preSum[j + 1]) / (j + 1)\n        for k in range(2, K + 1):\n            for i in range(k, size + 1):\n                for j in range(i, k - 1, -1):\n                    dp[k][i] = max(dp[k][i], dp[k - 1][j - 1] + (preSum[i] - preSum[j - 1]) / (i - j + 1))\n        print(dp)\n        return max([dp[i][size] for i in range(1, K + 1)])", "# A[1~N] K (1 <= K <= N)\n# \n# B[m][w] = \u524dA[1~m]\u5206w\u7d44\u7684\u6700\u5927\u5e73\u5747\u503c\u7e3d\u548c\n# \n# B[m][w] = max(B[m-1][w-1] + A[m]\n#               B[m-2][w-1] + (A[m-1]+A[m])/2\n#               B[m-3][w-1] + (A[m-2 ~ m])/3\n\nclass Solution:\n  def largestSumOfAverages(self, A, K):\n    N = len(A)\n    S = [0] * (1 + N)\n    for i in range(1, N + 1):\n        S[i] = S[i - 1] + A[i - 1]\n    B = []\n    for i in range(1 + N):\n      B.append([0] * (1 + K))\n    for m in range(1, N + 1):     # m : \u5269\u9918\u4eba\u6578\n        for w in range(1, K + 1): # w : \u5269\u9918\u7d44\u6578\n            if w == 1:\n                B[m][w] = S[m] / m\n                continue\n            if m < w:\n                break\n            B[m][w] = -1000000\n            for e in range(1, m - w + 2): # e : \u6700\u5f8c\u4e00\u7d44\u7684\u4eba\u6578\n                B[m][w] = max(B[m][w], B[m - e][w - 1] +\n                                       (S[m] - S[m - e]) / e)\n            # print('B[%d][%d] = %f' % (m, w, B[m][w]))\n    return B[N][K]\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n      \n        n=len(A)\n        dp=[[0]*(K+1) for _ in range(n)]\n        s=0\n        for i in range(n):\n            s+=A[i]\n            dp[i][1]=s*1.0/(i+1)\n        \n        for k in range(2,K+1):\n            for i in range(k-1,n):\n                s=0\n                for m in range(i,k-2,-1):\n                    s+=A[m]\n                    dp[i][k]=max(dp[i][k],dp[m-1][k-1]+s*1.0/(i-m+1))\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        cumsum = [A[0]]\n        for i in range(1, len(A)):\n            cumsum.append(cumsum[-1] + A[i])\n        cumsum.append(0)\n\n        @lru_cache(None)\n        def rec(i, K):\n            if K == 1:\n                return (cumsum[len(A)-1] - cumsum[i-1]) / (len(A)-i)\n            return max((cumsum[j] - cumsum[i-1]) / (j-i+1) + rec(j+1, K-1) for j in range(i, len(A)-K+1))\n\n        return rec(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        #larger sum in subarray group \u5f80dp\u60f3\uff0c\u4e00\u822c\u90fd\u662f\u7b2c\u4e00\u7c7b\u533a\u95f4dp\n        #\u8fd9\u7c7b\u533a\u95f4\u7684\u5957\u8def\u5c31\u662fdp[i][k] \u524di\u4e2a\u5206\u6210k\u4e2agroup\u7684\u6700\u4f18\u89e3\n        #\u8f6c\u79fb\u65b9\u7a0b\n  #      for (i=1; i<=N; i++)\n  #         for (k=1; k<=min(i,K); k++)\n  #     // find the best break point j \uff08jd\u7684\u533a\u95f4\u5c31\u662fi - k, c\u4ece\u9ad8\u5230\u4f4e\uff09\n  #             for (int j=i; j>=k; j--)\n  #                 dp[i][k] = max(dp[i][k], dp[j-1][k-1] + sum[j:i] );\n\n\n        n = len(A)\n        A = [0] + A\n        dp = [[0]*(K+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n             dp[i][0] = -float('inf')\n        \n        for i in range(1, n+1):\n            for k in range(1, min(i+1, K+1)):\n                sum_s = 0\n                #\u8fd9\u91ccj\u8981\u4ece\u6700\u5927\u7684\u5f80\u56de\u8d70\uff0c\u624d\u80fd\u7edf\u8ba1sum\n                for j in range(i, k-1, -1):\n                    sum_s += A[j]\n                    dp[i][k] = max(dp[i][k], dp[j-1][k-1] + sum_s/(i-j + 1))\n        \n        res = 0 \n        for i in range(1, K+1):\n            res = max(res, dp[n][i])\n        \n        return res\n\n\n\n\n\n\n\n  # \n#         n = len(A)\n#         dp = [[0]*(K+1) for _ in range(n+1)]\n        \n#         A = [0] + A\n        \n#         for i in range(1, n+1):\n#             dp[i][0] = -float('inf')\n        \n#         for i in range(1, n+1):\n#             for k in range(1, min(K+1, i+1)):\n#                 #\n#                 sum_s = 0\n#                 for j in range(k, i+1):\n#                     sum_s += A[j]\n#                     dp[i][k] = max(dp[i][k], dp[j-1][k-1] + sum_s//(i-j+1) )\n        \n#         res = 0\n#         for i in range(1, K+1):\n#             res = max(res, dp[n][i])\n#         print(dp)\n#         return res\n     \n    \n    \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if not A:\n            return 0\n        elif len(A) <= K:\n            return sum(A)\n        size = len(A)\n        dp = [[0] * (size + 1) for _ in range(K + 1)]\n        for j in range(size):\n            dp[1][j + 1] = sum(A[:j + 1]) / (j + 1)\n        for k in range(2, K + 1):\n            for i in range(k, size + 1):\n                suffixSum = 0\n                for j in range(i, k - 1, -1):\n                    suffixSum += A[j - 1]\n                    dp[k][i] = max(dp[k][i], dp[k - 1][j - 1] + suffixSum / (i - j + 1))\n        print(dp)\n        return max([dp[i][size] for i in range(1, K + 1)])", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        l_A = len(A)\n\n        memo = { (l_A, 0) : 0 }\n\n        def dfs(idx, rem):\n\n            if rem == 0 or l_A - idx < rem:\n                return 0\n\n            if rem == 1:\n                return sum(A[idx:]) / (l_A - idx)\n\n            if (idx, rem) in memo:\n                return memo[(idx, rem)]\n\n            sum_so_far = 0\n            avg = 0\n            best = 0\n\n            for i in range(idx, l_A):\n                sum_so_far += A[i]\n                avg = sum_so_far / (i - idx + 1)\n                best = max(best, avg + dfs(i + 1, rem - 1))\n\n            memo[ (idx, rem) ] = best\n            return best\n\n        return dfs(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if not A or len(A) < K:\n            return 0\n        for i in range(1, len(A)):\n            A[i] += A[i-1]\n            \n        cache = {}\n        \n        def cal(n, k):\n            if n <= 0 or k <= 0:\n                return 0\n            if n < k:\n                return 0\n            if (n, k) in cache:\n                return cache[(n, k)]\n            if k == 1:\n                cache[(n, 1)] = A[n-1] / n\n                return cache[(n, 1)]\n            res, cur = 0, 0\n            for i in range(n-1, 0, -1):\n                res = max(res, (A[n-1] - A[i-1]) / (n-i) + cal(i, k-1))\n            cache[(n, k)] = res\n            return res\n        \n        return cal(len(A), K)", "from functools import lru_cache \nclass Solution(object):\n    def largestSumOfAverages(self, A, K):\n        l = len(A)\n        @lru_cache(None)\n        def dp(n, k):\n            if n < k: return 0\n            if k == 1: return sum(A[:n])/float(n)\n            cursum, ans = 0, 0\n            for i in range(n-1, -1, -1):\n                cursum += A[i]\n                ans = max(ans, dp(i, k-1) + cursum/float(n-i))\n            return ans\n        return dp(l, K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[0] * (n + 1) for _ in range(K + 1)]\n        sums = [0] * (n + 1)\n        for i in range(1, n + 1):\n            sums[i] = sums[i - 1] + A[i - 1]\n            dp[1][i] = sums[i] / i\n        for k in range(2, K + 1):\n            for i in range(k, n + 1):\n                for j in range(k - 1, i):\n                    dp[k][i] = max(dp[k][i], dp[k - 1][j] + (sums[i] - sums[j]) / (i - j))\n        return dp[K][n]\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        memo = {}\n        \n        def dfs(n, K):\n            \n            if (n, K) in memo:\n                return memo[n, K]\n            \n            if n < K: return 0\n            \n            if K == 1:\n                memo[n, K] = sum(A[:n]) / n\n                return memo[n, K]\n            \n            cur, memo[n, K] = 0, 0\n            for i in range(n-1, 0, -1):\n                cur += A[i]\n                memo[n, K] = max(memo[n, K], dfs(i, K -1 ) + cur / (n - i))\n                \n            return memo[n, K]\n        \n        return dfs(len(A), K)", "from functools import lru_cache \nclass Solution(object):\n    def largestSumOfAverages(self, A, K):\n        l = len(A)\n        revsum = [0] * (l-1) + [A[-1]]\n        for i in range(l-1)[::-1]:\n            revsum[i] =  revsum[i+1] + A[i]\n        # print(revsum)\n        @lru_cache(None)\n        def dp(n, k):\n            if n < k: return 0\n            if k==1: return sum(A[:n])/float(n)\n            cur, ans = 0, 0           \n            for i in range(n-1, 0, -1):\n                cur += A[i]\n                ans = max(ans, dp(i, k-1) + (revsum[i] - (revsum[n] if n != l else 0))/float(n-i))\n            return ans\n        return dp(l, K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        if K >= n:\n            return sum(A)\n        \n        pre_sum = [0]\n        for num in A:\n            pre_sum.append(pre_sum[-1] + num)\n        # print(pre_sum)\n        if K <= 1:\n            return pre_sum[-1] / n\n        \n        \n        dp = [[0] * (K + 1) for _ in range(n)]\n        dp[0][1] = A[0]\n        for i in range(1, n):\n            dp[i][1] = pre_sum[i + 1] / (1 + i)\n        \n        for k in range(2, K + 1):\n            for i in range(k - 1, n):\n                for j in range(k - 2, i):\n                    \n                    dp[i][k] = max(dp[i][k], dp[j][k - 1] + (pre_sum[i + 1] - pre_sum[j + 1]) / (i - j))\n                    # print(k, i, j, dp[i][k])\n        print(dp)\n        return dp[n - 1][K]", "import itertools\n\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # Dynamic Programming \n        # Time  complexity: O(K x N^2)\n        # Space complexity: O(N)\n        # P = [0] + list(itertools.accumulate(A))\n        # def average(i, j): return (P[j] - P[i]) / float(j - i)\n\n        # N = len(A)\n        # dp = [average(i, N) for i in range(N)]\n        # for _ in range(K - 1):\n        #     for i in range(N):\n        #         for j in range(i + 1, N):\n        #             dp[i] = max(dp[i], average(i, j) + dp[j])\n\n        # return dp[0]\n\n\n        dp = [[0] * len(A) for _ in range(K)]\n        cur_sum = 0\n\n        for j in range(len(A)):\n            cur_sum += A[j]\n            dp[0][j] = float(cur_sum) / (j + 1)\n\n        for i in range(1, K):\n            for j in range(len(A)):\n                cur_sum = 0\n                for k in range(j, i - 1, -1):\n                    cur_sum += A[k]\n                    dp[i][j] = max(dp[i][j], dp[i - 1][k - 1] + float(cur_sum) / (j - k + 1))\n\n        return dp[-1][-1]\n\n\n\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix = [0]\n        for a in A:\n            prefix.append(prefix[-1] + a)\n        @lru_cache(None)\n        def soa(i, k):\n            if len(prefix) - 1 - i <= k:\n                return prefix[-1] - prefix[i]\n            elif k == 1:\n                return (prefix[-1] - prefix[i]) / (len(prefix) - 1 - i)\n            best = 0\n            for j in range(i + 1, len(prefix) - (k - 1)):\n                best = max(best, (prefix[j] - prefix[i]) / (j - i) + soa(j, k - 1))\n            return best\n        return soa(0, K)", "class Solution:\n     def largestSumOfAverages(self, A, K):\n        dp = {}\n        def search(n, k):\n            if (n, k) in dp: return dp[n, k]\n            if n < k: return 0\n            if k == 1:\n                dp[n, k] = sum(A[:n]) / float(n)\n                return dp[n, k]\n            cur, dp[n, k] = 0, 0\n            for i in range(n - 1, 0, -1):\n                cur += A[i]\n                dp[n, k] = max(dp[n, k], search(i, k - 1) + cur / float(n - i))\n            return dp[n, k]\n        return search(len(A), K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        presum = [0] + list(itertools.accumulate(A))\n        def mean(i, j):\n            return (presum[j+1] - presum[i])/(j-i+1)\n        n = len(A)\n        old = [[mean(i, j) if i <= j else 0 for j in range(n)] for i in range(n)]\n        new = [[0 for j in range(n)] for i in range(n)]\n        \n        mval = mean(0, n-1)\n        \n        for k in range(2, K+1):\n            # print(f'k={k}')\n            for i in range(n-k+1):\n                max_val = -float('inf')\n                for mid in range(i, n-k+1):\n                    max_val = max(max_val, mean(i,mid) + old[mid+1][n-1])\n                new[i][n-1] = max_val\n            old, new = new, old\n            # for x in old:\n            #     print(x)\n            mval = max(mval, old[0][-1])\n        return mval", "class Solution:\n     def largestSumOfAverages(self, A, K):\n        memo = {}\n        def search(n, k):\n            if (n, k) in memo: return memo[n, k]\n            if n < k: return 0\n            if k == 1:\n                memo[n, k] = sum(A[:n]) / float(n)\n                return memo[n, k]\n            cur, memo[n, k] = 0, 0\n            for i in range(n - 1, 0, -1):\n                cur += A[i]\n                memo[n, k] = max(memo[n, k], search(i, k - 1) + cur / float(n - i))\n            return memo[n, k]\n        return search(len(A), K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix = [A[0]]\n        for i in range(1, len(A)):\n            prefix.append(prefix[i-1] + A[i])\n            \n        dp = [[prefix[i]/(i+1) if k == 1 else 0 for k in range(K+1)] for i in range(len(A))]\n        \n        for i in range(1, len(A)):\n            for k in range(2, min(i+2, K+1)):\n                val = float('-inf')\n                _sum = 0\n                for j in range(i, 0, -1):\n                    _sum += A[j]\n                    val = max(dp[j-1][k-1] + (_sum/(i-j+1)), val)\n                dp[i][k] = val\n                \n        return dp[len(A)-1][K]", "from functools import lru_cache\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        \n        l = len(A)\n        @lru_cache(None)\n        def dp(n, k):\n            if n < k: return 0\n            if k == 1: return sum(A[:n])/float(n)\n            cur, ans = 0, 0\n            for i in range(n-1, 0, -1):\n                cur += A[i]\n                ans = max(ans, dp(i, k-1) + cur/float(n - i))\n            return ans\n        return dp(l, K)\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        cumsum = [A[0]]\n        for i in range(1, len(A)):\n            cumsum.append(cumsum[-1] + A[i])\n        cumsum.append(0)\n\n        @lru_cache(None)\n        def rec(i, K):\n            if K == 1:\n                return (cumsum[len(A)-1] - cumsum[i-1]) / (len(A)-i)\n            return max((cumsum[j] - cumsum[i-1]) / (j-i+1) + rec(j+1, K-1) for j in range(i, len(A)-K+1))\n\n        return rec(0, K)\n\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n            \n        dp = [[0 for k in range(K+1)] for i in range(len(A))]\n        dp[0][1] = A[0]\n        \n        for count,i in enumerate(range(1,len(A))):\n            dp[i][1] = ((dp[i-1][1] * (count + 1)) + A[i]) / (count + 2)\n        \n        for i in range(1, len(A)):\n            for k in range(2, min(i+2, K+1)):\n                val = float('-inf')\n                _sum = 0\n                for j in range(i, 0, -1):\n                    _sum += A[j]\n                    val = max(dp[j-1][k-1] + (_sum/(i-j+1)), val)\n                dp[i][k] = val\n                \n        return dp[len(A)-1][K]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix = [A[0]]\n        for i in range(1, len(A)):\n            prefix.append(prefix[i-1] + A[i])\n            \n        dp = [[prefix[i]/(i+1) if k == 1 else 0 for k in range(K+1)] for i in range(len(A))]\n        \n        for i in range(1, len(A)):\n            for k in range(2, min(i+2, K+1)):\n                val = float('-inf')\n                for j in range(1, i+1):\n                    val = max(dp[j-1][k-1] + ((prefix[i] - prefix[j-1])/(i-j+1)), val)\n                dp[i][k] = val\n                \n        return dp[len(A)-1][K]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        dp = [[0 for y in range(len(A))] for x in range(K)]\n        add=0\n        pref=[0 for i in range(len(A))]\n        \n        for x in range(len(A)):\n            add+=A[x]\n            pref[x]=add\n        # print(pref)\n        for x in range(len(A)):\n            dp[0][x] = (pref[x]/(x+1))\n        for y in range(1,K):\n            dp[y][0] = A[0]\n        for x in range(1,K):\n            for y in range(1,len(A)):\n                val1 = (pref[y]/(y+1))\n                maxi = val1\n                # print(\\\"hi\\\")\n                for z in range(y):\n                    val = dp[x-1][z] + ((pref[y]-pref[z])/(y-z))\n                    # print(x,y,z,val)\n                    maxi=max(maxi,val)\n                dp[x][y]=maxi\n        # print(dp)\n        return (dp[-1][-1])\n                \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:    \n        dp = [[A[0] if k == 1 else 0 for k in range(K+1)]]\n        \n        for count, i in enumerate(range(1,len(A))):\n            dp.append([0])\n            dp[i].append(\n                ((dp[i-1][1] * (count + 1)) + A[i]) / (count + 2)\n            )\n        \n        for i in range(1, len(A)):\n            for k in range(2, K+1):\n                val = float('-inf')\n                _sum = 0\n                for j in range(i, 0, -1):\n                    _sum += A[j]\n                    val = max(dp[j-1][k-1] + (_sum/(i-j+1)), val)\n                dp[i].append(val)\n        \n        return dp[len(A)-1][K]", "class Solution:\n    def largestSumOfAverages(self, A, K):\n        m = len(A)\n        dp = [[None] * (K + 1) for _ in range(m)]\n        for k in range(1, K + 1):\n            for j in range(k - 1, m):\n                if k == 1:\n                    dp[j][k] = sum(A[:j + 1]) / (j + 1)\n                else:\n                    dp[j][k] = max(dp[i][k - 1] + sum(A[i + 1:j + 1]) / (j - i) for i in range(k - 2, j))\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n=len(A)\n        sum_zero2i=[0]*(n+1)\n        for i in range(1, n+1):\n            sum_zero2i[i]=sum_zero2i[i-1]+A[i-1]\n        \n        dp=[0]*n\n        for i in range(n):\n            dp[i]=(sum_zero2i[-1] - sum_zero2i[i])/ (n-i)\n        \n        for _ in range(K-1):\n            for i in range(n):\n                for j in range(i+1,n):\n                    dp[i]=max(dp[i], dp[j]+ ( (sum_zero2i[j]-sum_zero2i[i])/ (j-i)  ))    \n        return dp[0]\n        \n        \n        \n        \n        \n        \n        O(k*N^2)    \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        suffix_sums = [0] * (len(A) + 1)\n        for i in range(len(A) - 1, -1, -1):\n            suffix_sums[i] = A[i] + suffix_sums[i + 1]\n            \n        memo = {}\n        def largest_starting_at(i, new_k):\n            if i == len(A):\n                return 0\n            if new_k == 1:\n                return suffix_sums[i] / (len(A) - i)\n            if (i, new_k) in memo:\n                return memo[i, new_k]\n            best = 0\n            for size in range(1, len(A) - i):\n                best = max(\n                    best,\n                    (suffix_sums[i] - suffix_sums[i + size]) / size + largest_starting_at(i + size, new_k - 1)\n                )\n            memo[i, new_k] = best\n            return memo[i, new_k]\n        \n        return largest_starting_at(0, K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix = [A[0]]\n        for i in range(1, len(A)):\n            prefix.append(prefix[i-1] + A[i])\n            \n        dp = [[prefix[i]/(i+1) if k == 1 else 0 for k in range(K+1)] for i in range(len(A))]\n        \n        for i in range(1, len(A)):\n            for k in range(2, K+1):\n                val = float('-inf')\n                for j in range(1, i+1):\n                    val = max(dp[j-1][k-1] + ((prefix[i] - prefix[j-1])/(i-j+1)), val)\n                dp[i][k] = val\n                \n        return dp[len(A)-1][K]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n=len(A)\n        sum_i2end=[0]*(n+1)\n        for i in range(1, n+1):\n            sum_i2end[i]=sum_i2end[i-1]+A[i-1]\n        \n        dp=[0]*n\n        for i in range(n):\n            dp[i]=(sum_i2end[-1] - sum_i2end[i])/ (n-i)\n        \n        for _ in range(K-1):\n            for i in range(n):\n                for j in range(i+1,n):\n                    dp[i]=max(dp[i], dp[j]+ ( (sum_i2end[j]-sum_i2end[i])/ (j-i)  ))    \n        return dp[0]\n\n            \n", "\n\nclass Solution:\n\n    def largestSumOfAverages(self, A, K: int) -> float:\n        def avg(array):\n            return sum(array) / len(array)\n        # dp [i->sub list of A til ith ele][p->how many parts]\n        dp = [[0 for _ in range(K + 1)] for _ in range(len(A))]\n        means = [[0 for _ in range(len(A))] for _ in range(len(A))]\n\n        for i in range(len(A)):\n            for j in range(i, len(A)):\n                # include i include j\n                # means[i][j] = statistics.mean(A[i:j + 1])\n                means[i][j] = avg(A[i:j + 1])\n\n        for i in range(len(A)):\n            dp[i][1] = means[0][i]\n\n        for i in range(1, len(A)):\n            for j in range(2, min(K + 1, i + 1 + 1)):\n                # k+1 last_stop_index+1 -> if stop at index 2 we can divide up to 2+1 = 3 groups,  j-1 prev_groups\n                for k in range(max(i - 1, j - 1 - 1), -1, -1):\n                    # k exclude, i included\n                    temp_last_group = means[k + 1][i]\n                    temp_sum_prev = dp[k][j - 1]\n                    dp[i][j] = max(\n                        dp[i][j], temp_last_group + temp_sum_prev)\n\n        return dp[-1][-1]\n\n    # def largestSumOfAverages(self, A, K: int) -> float:\n\n    #     if K == 0:\n    #         return mean(A)\n\n    #     lis_len = len(A)\n    #     if K >= lis_len:\n    #         return sum(A)\n    #     means = [[0 for _ in range(lis_len)] for _ in range(lis_len)]\n    #     # print(means)\n\n    #     for i in range(lis_len):\n    #         for j in range(i, lis_len):\n    #             # print(i,j,mean(A[i:j+1]))\n    #             means[i][j] = mean(A[i:j+1])\n\n    #     dp = [[0 for _ in range(lis_len + 1)] for _ in range(K + 1)]\n\n    #     for i in range(1, lis_len + 1):\n    #         # dp[1][i] = mean(A[:i])\n    #         dp[1][i] = means[0][i-1]\n\n    #     for i in range(2, K + 1):\n    #         for j in range(i, lis_len + 1):\n    #             # temp_lis = []\n    #             local_max = 0\n    #             for p in range(1, j):\n    #                 # temp = dp[i - 1][p] + mean(A[p:j])\n    #                 temp = dp[i-1][p]+means[p][j-1]\n    #                 # print(A[p:j],mean(A[p:j]),means[p][j-1],p,j-1)\n\n    #                 import sys\n    #                 # return\n    #                 # temp = dp[i - 1][p] + means[p-1][j]\n\n    #                 if temp > dp[i][j]:\n    #                     dp[i][j] = temp\n    #                 # temp_lis.append(temp)\n    #             # dp[i][j] = max(temp_lis)\n\n    #     return dp[K][lis_len]\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        n = len(A)\n        dp = [[-math.inf] * K for _ in range(n)]\n        sv, sc = 0, {-1:0}\n        for i, v in enumerate(A):\n            sv += v\n            sc[i] = sv\n        dp[0][0] = A[0]\n        for r in range(n):\n            for i in range(0, r):\n                for k in range(min(K, r+1)):\n                    if k == 0:\n                        dp[r][k] = (sc[r]-sc[-1])/(r+1)\n                    else:\n                        candidate = dp[i][k-1] + (sc[r]-sc[i])/(r-i) \n                        dp[r][k] = max(dp[r][k], candidate)\n        # for row in dp:\n        #     print(row)\n        return dp[-1][-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        def helper(n,k):\n            if (n,k) in dp: return dp[n,k]\n            if k==1: return sum(A[:n])/n\n            if n<=k: return sum(A[:n])\n            dp[n,k],temp = 0,0\n            for i in range(1,n)[::-1]:\n                temp+=A[i]\n                dp[n,k]=max(dp[n,k],helper(i,k-1)+temp/(n-i))\n            return dp[n,k]\n            \n        dp = {}\n        return helper(len(A),K)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefixSum = [0]\n        for x in A:\n            prefixSum.append(prefixSum[-1] + x)\n            \n        def avg(i, j):\n            return (prefixSum[j] - prefixSum[i]) / (j - i)\n        \n        n = len(A)\n        dp = [avg(i, n) for i in range(n)]\n        for k in range(K-1):\n            for i in range(n):\n                for j in range(i+1, n):\n                    dp[i] = max(dp[i], avg(i, j) + dp[j])\n                    \n        return dp[0]", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        p=[0]\n        for x in A:\n            p.append(x+p[-1])\n        def avg(i,j):\n            return (p[j]-p[i])/(j-i)\n        N=len(A)\n        dp=[avg(i,N) for i in range(N)]\n        for k in range(K-1):\n            for i in range(N):\n                for j in range(i+1,N):\n                    dp[i]=max(dp[i],avg(i,j)+dp[j])\n        return dp[0]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        @lru_cache(None)\n        def helper(i,t):\n            if(i>=len(A)):\n                return 0\n            if(t==K-1):\n                return sum(A[i:])/(len(A)-i)\n            else:\n                m=-1\n                for j in range(1,len(A)-i):\n                    m=max(m,helper(i+j,t+1)+sum(A[i:i+j])/j) \n                return m\n        return helper(0,0)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        N = len(A)\n\n        @lru_cache(None)\n        def dfs(index, remain):\n            if remain <= 0:\n                return sum(A[index:]) / (N - index)\n            if index >= N:\n                return 0\n            ans = 0\n            for i in range(index + 1, N):\n                ans = max(ans, sum(A[index:i]) / (i - index) + dfs(i, remain - 1))\n            return ans\n\n        res = dfs(0, K - 1)\n        return res", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if K == 1:\n            return sum(A)/len(A)\n        biggest = [[[None for temp in range(K+1)] for col in range(len(A))] for row in range(len(A))]\n        for start in range(len(A)):\n            for end in range(start,len(A),1):\n                biggest[start][end][1] = sum(A[start:end+1])/len(A[start:end+1])\n        for curK in range(2,K+1):\n            startEnd = len(A)-curK+1\n            if curK == K:\n                startEnd = 1\n            for start in range(0,startEnd,1):\n                tempNo = 0\n                for middle in range(start,len(A)-curK+1,1):\n                    theNo = biggest[start][middle][1] + biggest[middle+1][len(A)-1][curK-1]\n                    if theNo > tempNo:\n                        tempNo = theNo\n                biggest[start][len(A)-1][curK] = tempNo\n\n            \n        return (biggest[0][len(A)-1][K])\n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        @lru_cache(None)\n        def helper(i,t):\n            if(i>=len(A)):\n                return 0\n            if(t==K-1):\n                return sum(A[i:])/(len(A)-i)\n            else:\n                m=-1\n                for j in range(1,len(A)-i):\n                    m=max(m,helper(i+j,t+1)+sum(A[i:i+j])/j) \n                    if(t==3):\n                        print(m)\n                return m\n        return helper(0,0)", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if len(A) <= K:\n            return sum(A)\n        A1 = []\n        s = 0\n        for i in A:\n            s += i\n            A1.append(s)\n        n = len(A)\n        last = [A1[i] / (i+1) for i in range(n)]\n        for k in range(1, K):\n            cur = [A[0]]\n            for i in range(1, n):\n                stage_max = 0\n                for j1, j in enumerate(last[:i]):\n                    stage_max = max(stage_max, j + (A1[i]-A1[j1]) / (i - j1))\n                cur.append(stage_max)\n            last = cur\n        return last[-1]\n                \n            \n            \n", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        L = len(A)\n        \n        # reduced_dp[i] store the value of dp[i][K]\n        # the `k` in dp[i] is implicity indicated by the loop\n        reduced_dp = [0 for _ in range(L)]        \n        prefix_sum = [0 for _ in range(L + 1)]\n        for i in range(1, L + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n            reduced_dp[i - 1] = prefix_sum[i] / i;\n\n        # for i in reduced_dp:\n        #     print(i)\n\n        for k in range(2, K + 1):\n            for i in reversed(range(1, L)):\n                if k <= i + 1:\n                    for j in range(-1, i):\n                        ave = (prefix_sum[i + 1] - prefix_sum[j + 1]) / (i - j)\n                        if j == -1:\n                            tmp = 0\n                        else:\n                            tmp = reduced_dp[j]\n                        if ave + tmp > reduced_dp[i]:\n                            reduced_dp[i] = ave + tmp\n                            \n        # for i in reduced_dp:\n        #     print(i)\n        # print('done')\n        return reduced_dp[-1]", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        prefix = [0] + A.copy()\n        for i in range(1, len(prefix)):\n            prefix[i] += prefix[i - 1]\n         \n        def query(i, j): # inclusive\n            return prefix[j + 1] - prefix[i]\n        \n        def get_average(i, j):\n            return query(i, j) / (j - i + 1)\n        \n        N = len(A)\n        cache = {}\n        def dfs(i, k):\n            if k < 0:\n                return -float('inf')\n            \n            if (i, k) in cache:\n                return cache[(i, k)]\n            \n            if i == N:\n                if k == 0:\n                    return 0\n                else:\n                    return -float('inf')\n                \n            res = -float('inf')\n            for j in range(i, N):\n                take = dfs(j + 1, k - 1) + get_average(i, j)\n                res = max(res, take)\n                \n            cache[(i, k)] = res\n            return res\n        \n        \n        return dfs(0, K)", "class Solution: #1037\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        if not A:\n            return 0\n        dp = {}\n        averages = [[None] * len(A) for _ in range(len(A))]\n        for i in range(len(A)):\n            averages[i][i] = A[i]\n            for j in range(i+1, len(A)):\n                averages[i][j] = (averages[i][j-1] * (j-i) + A[j]) / (j-i+1)\n        def recurse(A, K, start):\n            if start >= len(A):\n                return 0\n            if K == 1:\n                return averages[start][len(A)-1]\n            if (K, start) in dp:\n                return dp[K, start]\n            dp[K, start] = -math.inf\n            for i in range(start, len(A)):\n                dp[K, start] = max(dp[K, start], averages[start][i] + recurse(A, K-1, i+1))\n            return dp[K, start]\n        return recurse(A, K, 0)", "from itertools import combinations\nfrom functools import lru_cache\nclass Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        #brute force...how many ways are there to partition an array?\n        # cubic time for n>>3\n        # the questoin says: AT MOST K, so we could get away with K = 1\n        # but K =1 is always the smallest (largest divisor in the mean)\n        # I wonder if greedy would work\n        def mean(A):\n            return sum(A)/len(A);\n        @lru_cache(None)\n        def recurse(start, end, k = 1):\n            if(k == K):\n                return mean(A[start:end]);\n            if(len(A) == 1):\n                return A[0]\n            maxval = 0;\n            for i in range(start+1,end):\n                maxval = max(maxval, mean(A[start:i])+recurse(i, end, k+1));\n            return maxval\n            \n        # def recurse(A, k = 1):\n        #     if(k == K):\n        #         return mean(A);\n        #     if(len(A) == 1):\n        #         return A[0]\n        #     N = len(A);\n        #     maxval = 0;\n        #     # print(A)\n        #     for i in range(1,N):\n        #         split1 = A[0:i]\n        #         split2 = A[i:N]\n        #         maxval = max(maxval, mean(split1)+recurse(split2,k+1))\n        #     return maxval\n                \n        N = len(A)\n        return recurse(0,N)", "class Solution(object):\n    def largestSumOfAverages(self, A, K):\n        prefix_sum = [0]\n        for x in A:\n            prefix_sum.append(prefix_sum[-1] + x)\n        \n        def average(i, j):\n            return (prefix_sum[j] - prefix_sum[i]) / float(j - i)\n\n        n = len(A)\n        dp = [average(i, n) for i in range(n)]\n        print(dp)\n        \n        for k in range(K-1):\n            for i in range(n):\n                for j in range(i+1, n):\n                    dp[i] = max(dp[i], average(i, j) + dp[j])\n        return dp[0]        ", "class Solution:\n    def largestSumOfAverages(self, A: List[int], K: int) -> float:\n        # dp[i][k]: max avg sum to divide A[:i] into k sub group\n        n = len(A)\n        dp = [[0 for _ in range(K + 1)] for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for k in range(1, K + 1):\n                if k == 1:\n                    dp[i][k] = sum(A[:i]) / i\n                else:\n                    for j in range(k, i + 1):\n                        dp[i][k] = max(dp[i][k], dp[j - 1][k - 1] + sum(A[j - 1: i]) / (i - j + 1))\n        \n        return dp[n][K]"]
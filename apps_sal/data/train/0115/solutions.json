["class BIT():\n    def __init__(self,n):\n        self.BIT=[0]*(n+1)\n        self.num=n\n\n    def query(self,idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += self.BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def update(self,idx,x):\n        while idx <= self.num:\n            self.BIT[idx] += x\n            idx += idx&(-idx)\n        return\n\nimport sys,heapq,random\n\ninput=sys.stdin.readline\n\nn=int(input())\nspell=[tuple(map(int,input().split())) for i in range(n)]\n\n\nS=set([])\nfor i in range(n):\n    S.add(abs(spell[i][1]))\nS=list(S)\nS.sort(reverse=True)\ncomp={i:e+1 for e,i in enumerate(S)}\nN=len(S)\n\nx_exist=BIT(N)\ny_exist=BIT(N)\npower=BIT(N)\n\nX,Y,S=0,0,0\nXmax=[]\nYmin=[]\nx_data=[0]*(N+1)\ny_data=[0]*(N+1)\n\nfor i in range(n):\n    t,d=spell[i]\n    S+=d\n    if d<0:\n        id=comp[-d]\n        if t==0:\n            X-=1\n            x_exist.update(id,-1)\n            power.update(id,d)\n            x_data[id]-=1\n        else:\n            Y-=1\n            y_exist.update(id,-1)\n            power.update(id,d)\n            y_data[id]-=1\n    else:\n        id=comp[d]\n        if t==0:\n            X+=1\n            x_exist.update(id,1)\n            power.update(id,d)\n            heapq.heappush(Xmax,-d)\n            x_data[id]+=1\n        else:\n            Y+=1\n            y_exist.update(id,1)\n            power.update(id,d)\n            heapq.heappush(Ymin,d)\n            y_data[id]+=1\n    if X==0:\n        if Y==0:\n            print(0)\n        else:\n            while not y_data[comp[Ymin[0]]]:\n                heapq.heappop(Ymin)\n            print(2*S-Ymin[0])\n    else:\n        if Y==0:\n            print(S)\n        else:\n            start=0\n            end=N\n            while end-start>1:\n                test=(end+start)//2\n                if x_exist.query(test)+y_exist.query(test)<=Y:\n                    start=test\n                else:\n                    end=test\n            if y_exist.query(start)!=Y:\n                print(S+power.query(start))\n            else:\n                while not y_data[comp[Ymin[0]]]:\n                    heapq.heappop(Ymin)\n                while not x_data[comp[-Xmax[0]]]:\n                    heapq.heappop(Xmax)\n                print(S+power.query(start)-Ymin[0]-Xmax[0])\n", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n    def __init__(self, a):\n        # Operator\n        self.op = lambda a, b : a + b\n        # Identity element\n        self.e = 0 \n\n        self.n = len(a)\n        self.lv = (self.n - 1).bit_length()\n        self.size = 2**self.lv\n        self.data = [self.e] * (2*self.size - 1)\n        # Bisect checking function \n        self._check = lambda x, acc : acc >= x\n        self._acc = self.e\n\n        self.initialize(a)\n\n    # Initialize data\n    def initialize(self, a):\n        for i in range(self.n):\n            self.data[self.size + i - 1] = a[i]\n        for i in range(self.size-2, -1, -1):\n            self.data[i] = self.op(self.data[i*2 + 1], self.data[i*2 + 2])\n\n    # Update ak as x (0-indexed)\n    def update(self, k, x):\n        k += self.size - 1\n        self.data[k] = x\n        while k > 0:\n            k = (k - 1) // 2\n            self.data[k] = self.op(self.data[2*k+1], self.data[2*k+2])\n\n    # Min value in [l, r) (0-indexed)\n    def fold(self, l, r):\n        L = l + self.size; R = r + self.size\n        s = self.e\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.op(s, self.data[R-1])\n            if L & 1:\n                s = self.op(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n    def _bisect_forward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When left-child isn't in range, just look at right-child. \n        if mid <= start:\n            return self._bisect_forward(x, start, 2*k + 2)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start <= mid - width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check left-child then right-child\n        vl = self._bisect_forward(x, start, 2*k + 1)\n        if vl != -1:\n            return vl\n        return self._bisect_forward(x, start, 2*k + 2)\n    \n    # Returns min index s.t. start <= index and satisfy check(data[start:idx)) = True\n    def bisect_forward(self, x, start=None):\n        if start:\n            ret = self._bisect_forward(x, start, 0)\n        else:\n            ret = self._bisect_forward(x, 0, 0)\n        self._acc = self.e\n        return ret\n\n    def _bisect_backward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When right-child isn't in range, just look at right-child. \n        if mid >= start:\n            return self._bisect_backward(x, start, 2*k + 1)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start > mid + width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check right-child then left-child\n        vl = self._bisect_backward(x, start, 2*k + 2)\n        if vl != -1:\n            return vl\n        return self._bisect_backward(x, start, 2*k + 1)\n    \n    # Returns max index s.t. index < start and satisfy check(data[idx:start)) = True\n    def bisect_backward(self, x, start=None):\n        if start:\n            ret = self._bisect_backward(x, start, 0)\n        else:\n            ret = self._bisect_backward(x, self.n, 0)\n        self._acc = self.e\n        return ret\n\nn = int(input())\nquery = []\nseen = set([0])\nfor _ in range(n):\n    kind, val = map(int, input().split())\n    query.append((kind, val))\n    if val > 0: \n        seen.add(val)\n\nunique = list(seen)\nunique.sort()\ncomp = {val: i for i, val in enumerate(unique)}\ndecomp = {i: val for i, val in enumerate(unique)}\ndecopm = {}\nnn = len(comp)\n\nbase = [0] * nn\nSTfire = SegmentTree(base)\nSTnum = SegmentTree(base)\nSTval = SegmentTree(base)\n\ntnum = 0\nfnum = 0\nspell = 0\ntotal = 0\nfor kind, val in query:\n    cd = comp[abs(val)]\n    if val > 0:\n        STval.update(cd, val)\n        STnum.update(cd, 1)\n        total += val\n        if kind == 1:\n            tnum += 1\n        else:\n            STfire.update(cd, 1)\n            fnum += 1\n    else:\n        total += val\n        STval.update(cd, 0)\n        STnum.update(cd, 0)\n        if kind == 1:\n            tnum -= 1\n        else:\n            STfire.update(cd, 0)\n            fnum -= 1\n    spell = tnum + fnum\n    if fnum == 0:\n        fid = -1\n    else:\n        fid = STfire.bisect_forward(fnum)\n    l = STnum.bisect_forward(spell - tnum)\n    if tnum == 0:\n        print(total)\n        continue\n    if fid >= l + 1:\n        double_total = STval.fold(l + 1, nn)\n        print(total + double_total)\n    else:\n        l = STnum.bisect_forward(spell - tnum + 1)\n        double_total = STval.fold(l + 1, nn)\n        if fnum > 0:\n            print(total + double_total + decomp[fid])\n        else:\n            print(total + double_total)"]
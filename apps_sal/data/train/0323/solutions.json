["class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s3) != len(s1) + len(s2):\n             return False\n         if not s1 or not s2:\n             return (s1 or s2) == s3\n         options = {(0, 0)}\n         for char in s3:\n             new_options = set()\n             for i1, i2 in options:\n                 if i1 < len(s1) and char == s1[i1]:\n                     new_options.add((i1 + 1, i2))\n                 if i2 < len(s2) and char == s2[i2]:\n                     new_options.add((i1, i2 + 1))\n             options = new_options\n             if not options:\n                 return False\n         return True", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) + len(s2) != len(s3): return False\n         l1,l2,l3 = len(s1)+1, len(s2)+1, len(s3)+1\n         \n         dp = [True for i in range(l2)]\n         for i in range(1,l2):\n             dp[i] = dp[i-1] and s2[i-1] == s3[i-1]\n         for i in range(1,l1):\n             dp[0] = dp[0] and s1[i-1] == s3[i-1]\n             for j in range(1, l2):\n                 dp[j] = dp[j] and s1[i-1] == s3[i+j-1] or dp[j-1] and s2[j-1] == s3[i+j-1]\n                 \n         return dp[-1]\n     \n         # dp = [[True for i in range(l2)] for j in range(l1)]\n         # for i in range(1,l1):\n         #     dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n         # for j in range(1, l2):\n         #     dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n         # for i in range(1,l1):\n         #     for j in range(1, l2):\n         #         dp[i][j] = dp[i-1][j] and s1[i-1] == s3[i+j-1] or dp[i][j-1] and s2[j-1] == s3[i+j-1]\n         # return dp[-1][-1]\n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) + len(s2) != len(s3):\n             return False\n         if not s1 and s2 and s3:\n             return True if s2 == s3 else False\n         if not s2 and s1 and s3:\n             return True if s1 == s3 else False\n         if not s1 and not s2 and not s3:\n             return True\n         if (s1 and s2 and not s3) or (not s1 and not s2 and s3):\n             return False\n \n         result = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n         result[0][0] = True\n         for i in range(len(s1) + 1):\n             il_idx = i - 1\n             for j in range(len(s2) + 1):\n                 if i == j == 0:\n                     continue\n                 if j > len(s3) - 1:\n                     break\n                 s1_idx, s2_idx = i - 1, j - 1\n                 s1_char = s1[s1_idx] if s1_idx > -1 else None\n                 s2_char = s2[s2_idx] if s2_idx > -1 else None\n                 il_char = s3[il_idx + j]\n                 top = False if i == 0 else result[i - 1][j]\n                 left = False if j == 0 else result[i][j - 1]\n                 ds = set()\n                 if not left:\n                     ds.add(s1_char)\n                 if not top:\n                     ds.add(s2_char)\n                 result[i][j] = il_char in ds and (top or left)\n                 if (s1_char == s2_char == il_char) and top and left:\n                     result[i][j] = True\n                 #print(f\" [{i},{j}] ==> checking if ** {il_char} **  in  {ds} ==> set result to {result[i][j]}\")\n         #print(result)\n         return result[-1][-1]\n                 \n                 \n                 \n                 \n                 \n                 \n                 \n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) + len(s2) != len(s3):\n             return False\n         \n         m, n = len(s1) + 1, len(s2) + 1\n         dp = [[False] * n for _ in range(m)]\n         \n         dp[0][0] = True\n         for row in range(1, m):\n             dp[row][0] = dp[row - 1][0] and s1[row - 1] == s3[row - 1]\n         \n         for col in range(1, n):\n             dp[0][col] = dp[0][col - 1] and s2[col - 1] == s3[col - 1]\n         \n         for row in range(1, m):\n             for col in range(1, n):\n                 # print(row, col)\n                 # print(s1[row - 1])\n                 # print(s2[col - 1])\n                 # print(s3[row + col - 1])\n                 dp[row][col] = (dp[row - 1][col] and s1[row - 1] == s3[row + col - 1]) \\\n                                or (dp[row][col - 1] and s2[col - 1] == s3[row + col - 1])\n         \n         # print(dp)\n         \n         return dp[-1][-1]\n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         dp = [[False]*(l2+1) for _ in range(l1+1)]\n         dp[0][0] = True\n         for i in range(l1):\n             if s1[i]==s3[i]: dp[i+1][0]=True\n             else: break\n         for i in range(l2):\n             if s2[i]==s3[i]: dp[0][i+1]=True\n             else: break\n         for i in range(1, l1+1):\n             for j in range(1, l2+1):\n                 dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         return dp[-1][-1]", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s3) != len(s1) + len(s2): return False\n         if '' in [s1, s2]: return s3 == s1+s2\n         \n         dp = [[False]*(len(s2)+1) for _ in range(len(s1)+1)]\n         for i in range(len(s1)+1):\n             for j in range(len(s2)+1):\n                 if i == 0 and j == 0: \n                     dp[i][j] = True\n                 else:\n                     dp[i][j] = False\n                     if j > 0: dp[i][j] |= dp[i][j-1] and s2[j-1] == s3[i+j-1]\n                     if i > 0: dp[i][j] |= dp[i-1][j] and s1[i-1] == s3[i+j-1]                    \n         return dp[-1][-1]", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if not s1:\n             if s2 != s3:\n                 return False\n             else:\n                 return True\n         if not s2:\n             if s1 != s3:\n                 return False\n             else:\n                 return True\n         if len(s1) + len(s2) != len(s3):\n             return False\n         f = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n         f[0][0] = True\n         for i in range(1, len(s1) + 1):\n             if s1[i - 1] == s3[i - 1] and f[i - 1][0]:\n                 f[i][0] = True\n         for j in range(1, len(s2) + 1):\n             if s2[j - 1] == s3[j - 1] and f[0][j - 1]:\n                 f[0][j] = True\n         for i in range(1, len(s1) + 1):\n             for j in range(1, len(s2) + 1):\n                 f[i][j] = (f[i - 1][j] and (s3[i + j - 1] == s1[i - 1])) or ((s3[i + j - 1] == s2[j - 1]) and f[i][j - 1])\n         return f[-1][-1]", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         # Solution 1\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [[False]*(l2+1) for _ in range(l1+1)]\n         # dp[0][0] = True\n         # for i in range(l1):\n         #     if s1[i]==s3[i]: dp[i+1][0]=True\n         #     else: break\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[0][i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(1, l2+1):\n         #         dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         # return dp[-1][-1]\n         \n         # Solution 2\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [False]*(l2+1)\n         # dp[0] = True\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(l2+1):\n         #         dp[j] = (s1[i-1]==s3[i+j-1] and dp[j]) or (j-1>=0 and s2[j-1]==s3[i+j-1] and dp[j-1])\n         # return dp[-1]\n     \n         # Solution 3\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         options = {(0, 0)}\n         for c in s3:\n             new_options = set()\n             for (i1, i2) in options:\n                 if i1<l1 and s1[i1]==c: new_options.add((i1+1, i2))\n                 if i2<l2 and s2[i2]==c: new_options.add((i1, i2+1))\n             if not new_options: return False\n             options = new_options\n         return True\n                 \n         \n", "class Solution:\n     def bruteForce(self, s1, s2, s3, i, j, k, string, m):\n         try:\n             return m[(i,j)]\n         except KeyError:  \n             if k >= len(s3):\n                 if string == s3:\n                     m[(i,j)] = True\n                     return True\n                 else:\n                     m[(i,j)] = False\n                     return False\n             else:\n                 x = False\n                 y = False\n                 xstring = string[:]\n                 if i < len(s1):\n                     if(s1[i] == s3[k]):\n                         if not string: string  = s1[i]\n                         else: string  = string + s1[i]\n                         x = self.bruteForce(s1, s2, s3, i+1, j, k+1, string, m)\n                         if x == True:\n                             m[(i,j)] = True\n                             return True\n                 if j < len(s2):\n                     if(s2[j] == s3[k]):\n                         if not xstring: xstring = s2[j]\n                         else: xstring = xstring + s2[j]\n                         y = self.bruteForce(s1, s2, s3, i, j+1, k+1, xstring, m)\n                 m[(i,j)] = x or y\n                 return x or y\n \n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if not s1 and not s2 and not s3: return True\n         if not s1:\n             if s2 == s3: return True\n             else: return False\n         if not s2:\n             if s1 == s3: return True\n             else: return False\n         if len(s3) != len(s1) + len(s2): return False\n         return self.bruteForce(s1,s2,s3,0,0,0, \"\", {})\n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         if s1=='' and s2=='' and s3=='':\n             return True\n         if len(s1)+len(s2)!=len(s3):\n             return False\n         paths = [[False for i in range(len(s1)+1)] for j in range(len(s2)+1)]\n         for i in range(1, len(s1)+1):\n             if s1[i-1] == s3[i-1]:\n                 paths[0][i] = True\n             else:\n                 break\n         for i in range(1, len(s2)+1):\n             if s2[i-1] == s3[i-1]:\n                 paths[i][0] = True\n             else:\n                 break\n         for i in range(1, len(s2)+1):\n             for j in range(1, len(s1)+1):\n                 if ((paths[i][j-1] is True and s1[j-1]==s3[i+j-1] )\n                         or\n                     (paths[i-1][j] is True and s2[i-1]==s3[i+j-1])\n                 ):\n                     paths[i][j]=True\n         return paths[len(s2)][len(s1)]", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         # Solution 1\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [[False]*(l2+1) for _ in range(l1+1)]\n         # dp[0][0] = True\n         # for i in range(l1):\n         #     if s1[i]==s3[i]: dp[i+1][0]=True\n         #     else: break\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[0][i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(1, l2+1):\n         #         dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         # return dp[-1][-1]\n         \n         # Solution 2\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         dp = [False]*(l2+1)\n         dp[0] = True\n         for i in range(l2):\n             if s2[i]==s3[i]: dp[i+1]=True\n             else: break\n         for i in range(1, l1+1):\n             for j in range(l2+1):\n                 dp[j] = (s1[i-1]==s3[i+j-1] and dp[j]) or (j-1>=0 and s2[j-1]==s3[i+j-1] and dp[j-1])\n         return dp[-1]\n     \n         # Solution 3\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # options = {(0, 0)}\n         # for c in s3:\n         #     new_options = set()\n         #     for (i1, i2) in options:\n         #         if i1<l1 and s1[i1]==c: new_options.add((i1+1, i2))\n         #         if i2<l2 and s2[i2]==c: new_options.add((i1, i2+1))\n         #     if not new_options: return False\n         #     options = new_options\n         # return True\n                 \n         \n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         # Solution 1\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [[False]*(l2+1) for _ in range(l1+1)]\n         # dp[0][0] = True\n         # for i in range(l1):\n         #     if s1[i]==s3[i]: dp[i+1][0]=True\n         #     else: break\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[0][i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(1, l2+1):\n         #         dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         # return dp[-1][-1]\n         \n         # Solution 2\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         dp = [False]*(l2+1)\n         dp[0] = True\n         for i in range(l2):\n             if s2[i]==s3[i]: dp[i+1]=True\n             else: break\n         for i in range(1, l1+1):\n             for j in range(l2+1):\n                 dp[j] = (s1[i-1]==s3[i+j-1] and dp[j]) or (j-1>=0 and s2[j-1]==s3[i+j-1] and dp[j-1])\n         return dp[-1]\n     \n         # Solution 3\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # options = {(0, 0)}\n         # for c in s3:\n         #     new_options = set()\n         #     for (i1, i2) in options:\n         #         if i1<l1 and s1[i1]==c: new_options.add((i1+1, i2))\n         #         if i2<l2 and s2[i2]==c: new_options.add((i1, i2+1))\n         #     if not new_options: return False\n         #     options = new_options\n         # return True\n                 \n         \n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         # Solution 1\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         dp = [[False]*(l2+1) for _ in range(l1+1)]\n         dp[0][0] = True\n         for i in range(l1):\n             if s1[i]==s3[i]: dp[i+1][0]=True\n             else: break\n         for i in range(l2):\n             if s2[i]==s3[i]: dp[0][i+1]=True\n             else: break\n         for i in range(1, l1+1):\n             for j in range(1, l2+1):\n                 dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         return dp[-1][-1]\n         \n         # Solution 2\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [False]*(l2+1)\n         # dp[0] = True\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(l2+1):\n         #         dp[j] = (s1[i-1]==s3[i+j-1] and dp[j]) or (j-1>=0 and s2[j-1]==s3[i+j-1] and dp[j-1])\n         # return dp[-1]\n     \n         # Solution 3\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # options = {(0, 0)}\n         # for c in s3:\n         #     new_options = set()\n         #     for (i1, i2) in options:\n         #         if i1<l1 and s1[i1]==c: new_options.add((i1+1, i2))\n         #         if i2<l2 and s2[i2]==c: new_options.add((i1, i2+1))\n         #     if not new_options: return False\n         #     options = new_options\n         # return True\n                 \n         \n", "class Solution:\n \n     def qute_print(self, A):\n         for row in A:\n             for elem in row:\n                 print('{:2}'.format(elem), end=' ')\n             print()\n \n     def isInterleave(self, A, B, C):\n         n, m = len(A), len(B)\n \n         if len(C) != n + m:\n             return False\n \n         dp = [[False] * (m + 1) for _ in range(n + 1)]\n         dp[0][0] = True\n \n         for i in range(1, n + 1):\n             dp[i][0] = bool(dp[i - 1][0] * (A[i - 1] == C[i - 1]))\n \n         for j in range(1, m + 1):\n             dp[0][j] = bool(dp[0][j - 1] * (B[j - 1] == C[j - 1]))\n \n \n         for i in range(1, n + 1):\n             for j in range(1, m + 1):\n                 if A[i - 1] == C[i + j - 1]:\n                     dp[i][j] = dp[i - 1][j]\n                 if not dp[i][j] and B[j - 1] == C[i + j - 1]:\n                     dp[i][j] = dp[i][j - 1]\n \n \n                 # if A[i-1] == C[i+j-1] and B[j - 1] != C[i + j - 1]:\n                 #     dp[i][j] = dp[i - 1][j]\n                 # elif A[i - 1] != C[i + j - 1] and B[j - 1] == C[i + j - 1]:\n                 #     dp[i][j] = dp[i][j - 1]\n                 # elif A[i - 1] == C[i + j - 1] and B[j - 1] == C[i + j - 1]:\n                 #     dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n \n         return dp[-1][-1]\n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         # Solution 1\n         l1, l2 = len(s1), len(s2)\n         if len(s3)!=l1+l2: return False\n         if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         dp = [[False]*(l2+1) for _ in range(l1+1)]\n         dp[0][0] = True\n         for i in range(l1):\n             if s1[i]==s3[i]: dp[i+1][0]=True\n             else: break\n         for i in range(l2):\n             if s2[i]==s3[i]: dp[0][i+1]=True\n             else: break\n         for i in range(1, l1+1):\n             for j in range(1, l2+1):\n                 dp[i][j] = (s1[i-1]==s3[i+j-1] and dp[i-1][j]) or (s2[j-1]==s3[i+j-1] and dp[i][j-1])\n         return dp[-1][-1]\n         \n         # Solution 2\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # dp = [False]*(l2+1)\n         # dp[0] = True\n         # for i in range(l2):\n         #     if s2[i]==s3[i]: dp[i+1]=True\n         #     else: break\n         # for i in range(1, l1+1):\n         #     for j in range(l2+1):\n         #         dp[j] = (s1[i-1]==s3[i+j-1] and dp[j]) or (j-1>=0 and s2[j-1]==s3[i+j-1] and dp[j-1])\n         # return dp[-1]\n     \n         # Solution 3\n         # l1, l2 = len(s1), len(s2)\n         # if len(s3)!=l1+l2: return False\n         # if l1==0 or l2==0: return (l1 and s1==s3) or (l2 and s2==s3) or not s3\n         # options = {(0, 0)}\n         # for c in s3:\n         #     new_options = set()\n         #     for (i1, i2) in options:\n         #         if i1<l1 and s1[i1]==c: new_options.add((i1+1, i2))\n         #         if i2<l2 and s2[i2]==c: new_options.add((i1, i2+1))\n         #     if not new_options: return False\n         #     options = new_options\n         # return True\n                 \n         \n", "class Solution:\n     def isInterleave(self, s1, s2, s3):\n         \"\"\"\n         :type s1: str\n         :type s2: str\n         :type s3: str\n         :rtype: bool\n         \"\"\"\n         if len(s1) + len(s2) != len(s3):\n             return False\n         \n         res = [[False for j in range(1+len(s2))] for i in range(1+len(s1))]\n         for i in range(1+len(s1)):\n             for j in range(1+len(s2)):\n                 if i == 0 and j == 0:\n                     res[i][j] = True\n                 elif i == 0:\n                     res[i][j] = res[i][j-1] and s3[i+j-1] == s2[j-1]\n                 elif j == 0:\n                     res[i][j] = res[i-1][j] and s3[i+j-1] == s1[i-1]\n                 else:\n                     res[i][j] = res[i][j] or (s3[i+j-1] == s1[i-1] and res[i-1][j])\n                     res[i][j] = res[i][j] or (s3[i+j-1] == s2[j-1] and res[i][j-1])\n         return res[len(s1)][len(s2)]\n"]
["class Solution:\n    dp = {0: 0}\n    def racecar(self, target: int) -> int:\n        if target in self.dp:\n            return self.dp[target]\n        n = target.bit_length()\n        if 2**n - 1 == target:\n            self.dp[target] = n\n        else:\n            self.dp[target] = self.racecar(2**n - 1 - target) + n + 1\n            for m in range(n - 1):\n                self.dp[target] = min(self.dp[target], self.racecar(target - 2**(n - 1) + 2**m) + n + m + 1)\n        return self.dp[target]", "class Solution:\n    def racecar(self, target: int) -> int:\n        dist = [float('inf')] * (target + 1)\n        dist[0] = 0 # the minimum number of steps to achieve i with starting speed being 1\n        #dist[1] = 1\n        #dist[2] = 4\n        #dist[3] = 2\n        \n        for t in range(1, target+1):\n            k = t.bit_length()\n            up_limit = 2**k-1\n            if t == up_limit: # right on the target by only move forward with no reverse\n                dist[t] = k\n            \n            # between two critical points (k-1 steps and k steps)\n            # the last move is forward move\n            # in this case there should be even number of turns, which results in odd number of consecutive acceleration period. To recurse into the original problem (starting speed is 1 and point to the target) we need to remove the first two turns (or last two turns) \n            for j in range(1, k):\n                for q in range(j):\n                    dist[t] = min(dist[t], dist[t-2**j + 2**q]+j+1+q+1) # the last move is forward\n            \n            dist[t] = min(dist[t], dist[2**k-1-t]+k+1) # the last move is backward\n            \n            \n            \n        return dist[target]\n            \n        \n        \n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        encountered = set()\n        while q:\n            pos, spd, length = q.popleft()\n            if (pos, spd) in encountered: continue\n            else: encountered.add((pos, spd))\n            if pos == target: \n                return length\n            if (pos + spd, spd * 2) not in encountered:\n                if abs(pos + spd) <= 2 * target + 1:\n                    q.append((pos + spd, spd * 2, length + 1))\n            revSpd = -1 if spd > 0 else 1\n            if (pos, revSpd) not in encountered:\n                q.append((pos, revSpd, length + 1))\n        return -1", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        \n        steps = 0\n        queue = deque([(0, 1)])\n        cache = {(0,1)}\n        while queue:\n            for _ in range(len(queue)):\n                p, s = queue.popleft()\n                if p == target:\n                    return steps\n                p1,s1 = p+s, s*2\n                p2 = p\n                s2 = -1 if s > 0 else 1\n                \n                if -20000 <= p1 <= 20000 and (p1,s1) not in cache:\n                    cache.add((p1,s1))\n                    queue.append((p1,s1))\n                if -20000 <= p2 <= 20000 and  (p2,s2) not in cache:\n                    cache.add((p2,s2))\n                    queue.append((p2,s2))\n            steps += 1\n\n                \n            \n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        nodes = [(0, 1)]\n        seen, length = set([(0, 1), (0, -1)]), 0\n        while nodes:\n            new_nodes = []\n            for pos, speed in nodes:\n                if pos == target:\n                    return length\n                # A\n                for new_pos, new_speed in [\n                    (pos + speed, speed * 2),\n                    (pos, -1 if speed > 0 else 1),\n                ]:\n                    if abs(new_speed) > 2 * target or abs(new_pos) > 2 * target:\n                        continue\n                    if (new_pos, new_speed) not in seen:\n                        seen.add((new_pos, new_speed))\n                        new_nodes.append((new_pos, new_speed))\n            length += 1\n            nodes = new_nodes\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        encountered = set()\n        while q:\n            pos, spd, length = q.popleft()\n            if (pos, spd) in encountered: continue\n            else: encountered.add((pos, spd))\n            if pos == target: \n                return length\n            if (pos + spd, spd * 2) not in encountered:\n                if abs(pos + spd) <= 2 * target + 1 and abs(spd) <= 2 * target:\n                    q.append((pos + spd, spd * 2, length + 1))\n            revSpd = -1 if spd > 0 else 1\n            if (pos, revSpd) not in encountered:\n                q.append((pos, revSpd, length + 1))\n        return -1", "class Solution1:\n    \n    def __init__(self):\n        self.dp = {0: 0}\n    \n    def racecar(self, target: int) -> int:\n        if target in self.dp:\n            return self.dp[target]\n        n = target.bit_length()\n        if 2 ** n - 1 == target:\n            self.dp[target] = n\n        else:\n            self.dp[target] = self.racecar(2 ** n - 1 - target) + n + 1\n            for m in range(n - 1):\n                self.dp[target] = min(self.dp[target], \n                                 self.racecar(target - 2 ** (n - 1) + 2 ** m) + n + m + 1)\n                \n        return self.dp[target]\n            \n        \nclass Solution2:\n    def racecar(self, target: int) -> int:\n    # #analysis + DP\n        memo = [-1] * (target * 2)\n        def DP(s):\n            if memo[s] > 0: return memo[s]\n            duishu = math.log2(s+1)\n            if int(duishu) == duishu: \n                memo[s] = duishu\n                return duishu\n            left = int(duishu)\n            right = int(duishu) + 1\n            memo[s] = right + 1 + DP(2**right - s - 1)\n            for i in range(left):\n                huizou = 2**i - 1\n                memo[s] = min(memo[s], left + i + 2 + DP(s - 2**left + 1 + huizou))\n            return memo[s]\n        return int(DP(target))\n        \n    \n    \n    \n    \nclass Solution:\n    def racecar(self, target: int) -> int:    \n    #classic BFS\n        visited = {(0,1)}\n        queue = collections.deque()\n        queue.append((0,1))\n        steps = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                s, v = queue.popleft()\n                if s == target: return steps\n                # 'A'\n                cur_s = s + v\n                cur_v = v * 2\n                if (cur_s, cur_v) not in visited and s >= 0:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n                #'R'\n                cur_s = s\n                cur_v = -1 if v > 0 else 1\n                if (cur_s, cur_v) not in visited and s >= 0:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n            steps += 1", "class Solution:\n    def racecar(self, target):\n        q, cnt, used = [(0, 1)], 0, {(0, 1)}\n        while q:\n            new = []\n            for pos, speed in q:\n                if pos == target:\n                    return cnt\n                elif pos > 20000 or -20000 > pos:\n                    continue\n                if (pos + speed, speed * 2) not in used:\n                    new.append((pos + speed, speed * 2))\n                    used.add((pos + speed, speed * 2))\n                if speed > 0 and (pos, -1) not in used:\n                    new.append((pos, -1))\n                    used.add((pos, -1))\n                elif speed < 0 and (pos, 1) not in used:\n                    new.append((pos, 1))\n                    used.add((pos, 1))\n            q = new\n            cnt += 1", "class Solution:\n    def racecar(self, target: int) -> int:\n        visited = {(0,1)}\n        queue = collections.deque()\n        queue.append((0,1))\n        steps = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                s, v = queue.popleft()\n                if s == target: return steps\n                # 'A'\n                cur_s = s + v\n                cur_v = v * 2\n                if (cur_s, cur_v) not in visited and s >= 0:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n                #'R'\n                cur_s = s\n                cur_v = -1 if v > 0 else 1\n                if (cur_s, cur_v) not in visited and s >= 0:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n            steps += 1", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        q = [(0,1)]\n        vis = set([(0,1)])\n        ans=0\n        while q:\n            new_q = []\n            for p,s in q:\n                if p==target:\n                    return ans\n                p1,s1 = p+s,2*s\n                p2,s2 = p, -1 if s>0 else 1\n                # if (p1,s1) not in vis:\n                #     vis.add((p1,s1))\n                new_q.append((p1,s1))\n                if (p2,s2) not in vis:\n                    vis.add((p2,s2))\n                    new_q.append((p2,s2))\n            q = new_q\n            ans+=1\n        return -1\n", "class Solution:\n    def racecar(self, target):\n        K = target.bit_length() + 1\n        barrier = 2**K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (2**k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        q = [(0,1)]\n        vis = {(0,1)}\n        ans=0\n        while q:\n            new_q = []\n            for p,s in q:\n                if p==target:\n                    return ans\n                p1,s1 = p+s,2*s\n                p2,s2 = p, -1 if s>0 else 1\n                # if (p1,s1) not in vis:\n                #     vis.add((p1,s1))\n                new_q.append((p1,s1))\n                if (p2,s2) not in vis:\n                    vis.add((p2,s2))\n                    new_q.append((p2,s2))\n            q = new_q\n            ans+=1\n        return -1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0, 1, 0)])\n        seen = {(0, 1)}\n        while queue:\n            pos, speed, cost = queue.popleft()\n            if pos == target:\n                return cost\n            \n            # A\n            new_pos, new_speed = pos + speed, speed * 2\n            if new_pos > 0 and (new_pos, new_speed) not in seen:\n                seen.add((new_pos, new_speed))\n                queue.append((new_pos, new_speed, cost + 1)) # A\n                \n            # R\n            reverse_speed = -1 if speed > 0 else 1\n            if (pos, reverse_speed) not in seen:\n                seen.add((pos, reverse_speed))\n                queue.append((pos, reverse_speed, cost + 1))\n", "class Solution:\n    def racecar1(self, target: int) -> int:\n        # bfs \u80fd\u591f\u5feb\u901f\u60f3\u8d77\u6765\u7684\u65b9\u6cd5\uff01\u526a\u679d\u7684\u7b56\u7565\u4e0d\u7406\u89e3\uff01\n        q = collections.deque()\n        q.append([0, 1])\n        visited = set()\n        visited.add('0_1')\n        visited.add('0_-1')\n        steps = 0\n        while q:\n            qsize = len(q)\n            for i in range(qsize):\n                pos, speed = q.popleft()\n                \n                pos1 = pos + speed\n                speed1 = speed * 2 # \u52a0\u901f\uff01\u6ce8\u610f\u7b2c\u4e00\u4e2a\u53ef\u80fd\u6027\u7684\u6784\u9020\u65b9\u6cd5\uff1a\u9996\u5148\u662f\u65b0\u7684pos1\uff0c\u7136\u540e\u662f\u65b0\u7684\u901f\u5ea6\uff01\n                if pos1 == target:\n                    return steps + 1\n                p1 = [pos1, speed1]\n                #key1 = '{}_{}'.format(pos1, speed1)\n                if abs(speed1) < 2*target and abs(pos1) < 2*target and not key1 in visited: #\u76f8\u5f53\u4e8e\u8bf4\uff0c\u5982\u679c>= 2*target\u7684\u65f6\u5019\uff0c\u5c31\u526a\u679d\u4e86\uff01\n                    q.append(p1) #\u5982\u679c < ??? # \u8fd9\u91cc\u6ca1\u6709\u628ap1\u52a0\u5165visited???\n                    #visited.add(key1) # this makes things slower... yet still can pass!\n                \n                speed2 = -1 if speed > 0 else 1 # \u6389\u5934\uff01\u6ce8\u610f\u662f\u7ef4\u6301pos\u4f4d\u7f6e\u4e0d\u53d8\uff0c\u901f\u5ea6\u5982\u679c\u539f\u6765\u662f\u300b0\uff0c\u5219\u53d8\u6210-1\uff0c\u5982\u679c\u662f\u300a0\u5219\u53d8\u62101\uff01\uff01\n                p2 = [pos, speed2]\n                key2 = '{}_{}'.format(pos, speed2)\n                if key2 not in visited:\n                    q.append(p2)\n                    visited.add(key2)\n            steps += 1\n        return -1\n    \n    def racecar(self, target):\n        k = target.bit_length() + 1\n        barrier = 1<<k\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n        \n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n            \n            for k2 in range(k+1):\n                walk = (1<<k2) - 1\n                steps2, targ2 = steps + k2 + 1, walk - targ\n                if walk == targ:\n                    steps2 -= 1\n                \n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = collections.deque([(1, 0)])\n        visited = set(queue)\n        count = 0\n        while queue:\n            for _ in range(len(queue)):\n                speed, pos = queue.popleft()\n                if pos < -sqrt(target):\n                    continue\n                \n                if target == pos:\n                    return count\n                \n                if (speed*2, pos+speed) not in visited:\n                    visited.add((speed*2, pos+speed))\n                    queue.append((speed*2, pos+speed))\n                \n                if speed > 0:\n                    if (-1, pos) not in visited:\n                        visited.add((-1, pos))\n                        queue.append((-1, pos))\n                else:\n                    if (1, pos) not in visited:\n                        visited.add((1, pos))\n                        queue.append((1, pos))\n            count += 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        layer = collections.deque([(0,1)])\n        visited = set()\n        ans = 0\n        while len(layer) > 0:\n            nxt_layer = collections.deque()\n            while len(layer) > 0:\n                p, s = layer.popleft()\n                if p > target*2 and s > target*2:\n                    continue\n                if p == target:\n                    return ans\n                nxt_a = (p+s, 2*s)\n                if nxt_a not in visited:\n                    nxt_layer.append(nxt_a)\n                    visited.add(nxt_a)\n                nxt_r = (p, -1 if s > 0 else 1)\n                if nxt_r not in visited:\n                    nxt_layer.append(nxt_r)\n                    visited.add(nxt_r)\n            layer= nxt_layer\n            ans+=1", "class Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 0\n        \n        pq = [(0, 0, -1)] # steps, pos, speed\n        visited = set([(0, -1)])\n        \n        while pq:\n            steps, pos, speed = heapq.heappop(pq)\n            \n            next_steps, next_pos, next_speed = steps + 1, pos + speed, speed * 2\n            \n            if -next_pos == target:\n                return next_steps\n            \n            if -2 * target < -next_pos < 2 * target and -2 * target < -next_speed < 2 * target and not (next_pos, next_speed) in visited:\n            # if -next_pos < 2 * target and -next_speed < 2 * target and not (next_pos, next_speed) in visited:\n                heapq.heappush(pq, (next_steps, next_pos, next_speed))\n                visited.add((next_pos, next_speed))\n            \n            if speed > 0 and not (pos, -1) in visited:\n                heapq.heappush(pq, (next_steps, pos, -1))\n                visited.add((pos, -1))\n            elif speed < 0 and not (pos, 1) in visited:\n                heapq.heappush(pq, (next_steps, pos, 1))\n                visited.add((pos, 1))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = collections.deque([(1, 0)])\n        visited = set(queue)\n        count = 0\n        while queue:\n            for _ in range(len(queue)):\n                speed, pos = queue.popleft()\n                if pos < -(target/2):\n                    continue\n                \n                if target == pos:\n                    return count\n                \n                if (speed*2, pos+speed) not in visited:\n                    visited.add((speed*2, pos+speed))\n                    queue.append((speed*2, pos+speed))\n                \n                if speed > 0:\n                    if (-1, pos) not in visited:\n                        visited.add((-1, pos))\n                        queue.append((-1, pos))\n                else:\n                    if (1, pos) not in visited:\n                        visited.add((1, pos))\n                        queue.append((1, pos))\n            count += 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 1\n        self.ans = 0\n        self.bfsHelper(target)\n        return self.ans\n        \n        \n    def bfsHelper(self, target):\n        queue = []\n        queue.append((0, 1))\n        visited = set()\n        key = 'pos_' + str(0) + 'speed_' + str(1)\n        visited.add(key)\n        \n        while len(queue) > 0:\n            size = len(queue)\n            for i in range(size):\n                curPos = queue[0][0]\n                curSpeed = queue[0][1]\n                queue.pop(0)\n                if curPos == target:\n                    return self.ans\n                \n                newPos = curPos + curSpeed\n                newSpeed = curSpeed * 2\n                key = 'pos_' + str(newPos) + 'speed_' + str(newSpeed)\n                if key not in visited and newPos > 0 and newPos < 2 * target:\n                    visited.add(key)\n                    queue.append((newPos, newSpeed))\n\n                newPos = curPos\n                newSpeed = -1 if curSpeed > 0 else 1\n                key = 'pos_' + str(newPos) + 'speed_' + str(newSpeed)\n                if key not in visited and newPos > 0 and newPos < 2 * target:\n                    visited.add(key)\n                    queue.append((newPos, newSpeed))\n            \n            self.ans += 1\n            \n        self.ans = -1\n\n        \n        \n", "import bisect\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        speed = 1\n        dis = [0]\n        while dis[-1] < target:\n            dis.append(dis[-1] + speed)\n            speed *= 2\n        \n        num_moves  = self.recur(target, dis, {})\n        return num_moves\n        \n        \n    def recur(self, target: int, dis: list, memo: dict) -> int:\n        if target in memo:\n            return memo[target]\n        \n        if target in dis:\n            return dis.index(target)\n        \n        index = bisect.bisect_left(dis, target) - 1\n        \n        moves_right = self.recur(dis[index + 1] - target, dis, memo) + 2 + index\n        moves_left = self.recur(target - dis[index], dis, memo) + 2 + index\n        \n        for i in range(1, index):\n            new_moves_left = index + 1 + i + 1 + self.recur(target - dis[index] + dis[i], dis, memo)\n            moves_left = min(moves_left, new_moves_left)\n\n        \n        memo[target] = min(moves_right, moves_left)\n\n        return min(moves_right, moves_left)\n            \n        \n\n        \n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        encountered = set()\n        while q:\n            pos, spd, length = q.popleft()\n            if (pos, spd) in encountered: continue\n            else: encountered.add((pos, spd))\n            if pos == target: \n                return length\n            if (pos + spd, spd * 2) not in encountered:\n                if pos + spd <= 2 * target + 1:\n                    q.append((pos + spd, spd * 2, length + 1))\n            revSpd = -1 if spd > 0 else 1\n            if (pos, revSpd) not in encountered:\n                q.append((pos, revSpd, length + 1))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        record = collections.defaultdict(int)\n        cur = (0, 1) #(position, speed)\n        queue = collections.deque()\n        queue.append(cur)\n        record[cur] = 0\n        \n        while True:\n            for _ in range(len(queue)):\n                pos, speed = queue.popleft()\n                step = record[(pos, speed)]\n                if pos == target:\n                    return step\n                if pos + speed == target:\n                    return 1 + step\n                \n                s1 = (pos + speed, speed * 2)\n                s2 = (pos, -1) if speed>0 else (pos, 1)\n                \n                if s1 not in record:\n                    queue.append(s1)\n                    record[s1] = step + 1\n                if s2 not in record:\n                    queue.append(s2)\n                    record[s2] = step + 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = [(0, 1)]\n        steps = 0\n        visited = set(q)\n        while q:\n            nxt = []\n            for pos, speed in q:\n                if pos + speed == target:\n                    return steps + 1\n                nxt_pos = pos + speed\n                nxt_speed = speed * 2\n                if (nxt_pos, nxt_speed) not in visited:\n                    visited.add((nxt_pos, nxt_speed))\n                    nxt.append((nxt_pos, nxt_speed))\n                \n                nxt_pos = pos\n                nxt_speed = -1 if speed > 0 else 1\n                if (nxt_pos, nxt_speed) not in visited:\n                    visited.add((nxt_pos, nxt_speed))\n                    nxt.append((nxt_pos, nxt_speed))\n            q = nxt\n            steps += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 0        \n        # BFS solution\n        level = 0\n        q = deque([(0, 1)]) # tuple of (pos, speed)\n        visited = {(0, 1),}\n        while q:\n            length = len(q)\n            for _ in range(length):\n                p, s = q.popleft()\n                # use A\n                new_p, new_s = p + s, 2*s\n                if new_p == target:\n                    return level + 1\n                if (new_p, new_s) not in visited:\n                    visited.add((new_p, new_s))\n                    q.append((new_p, new_s))\n                # use R\n                new_p, new_s = p, -s//abs(s)\n                if (new_p, new_s) not in visited:\n                    visited.add((new_p, new_s))\n                    q.append((new_p, new_s))\n            level += 1", "import collections\nclass Solution:\n    def racecar(self, target: int) -> int:\n        # bfs\n        q = collections.deque([(0, 0, 1)]) # move, pos, vel\n        while q:\n            move, pos, vel = q.popleft()\n            if pos == target:\n                return move            \n            # A\n            q.append((move+1, pos+vel, vel*2))           \n            # R, considered in 4 cases, get rid of excessive search\n            if (pos > target and vel > 0) or (pos < target and vel < 0) or (pos + vel > target and vel > 0) or (pos + vel < target and vel < 0):  #reverse\n                q.append((move+1, pos, -1 if vel > 0 else 1))", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 0\n        visited = set()\n        queue = deque()\n        queue.append((0, 1))\n        visited.add((0, 1))\n        step = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                cur_pos, cur_speed = queue.popleft()\n                next_pos, next_speed = cur_pos + cur_speed, cur_speed * 2\n                if next_pos == target:\n                    return step\n                if (next_pos, next_speed) not in visited:\n                    queue.append((next_pos, next_speed))\n                    visited.add((next_pos, next_speed))\n                if cur_speed > 0:\n                    next_speed = -1\n                else:\n                    next_speed = 1\n                if (cur_pos, next_speed) not in visited:\n                    queue.append((cur_pos, next_speed))\n                    visited.add((cur_pos, next_speed))\n            step += 1\n        \n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        front = [(0,1)]\n        visited = {(0,1):0}\n        while front!=[]:\n            nf = [];\n            for (pos,speed) in front:\n                aa = [(pos+speed, speed*2),(pos, -1)] if speed>0 else [(pos+speed, speed*2),(pos, 1)]\n                for v in aa:\n                    if not v in visited:\n                        visited[v] = visited[(pos,speed)]+1\n                        nf.append(v)\n                        if v[0] == target:\n                            return visited[v]\n            front = nf\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = [(0, 1)]\n        steps = 0\n        visited = set(q)\n        while q:\n            nxt = []\n            for pos, speed in q:\n                if pos + speed == target:\n                    return steps + 1\n                if (pos+speed, speed*2) not in visited:\n                    visited.add((pos+speed, speed*2))\n                    nxt.append((pos+speed, speed*2))\n                    \n                nxt_speed = -1 if speed > 0 else 1\n                if (pos, nxt_speed) not in visited:\n                    visited.add((pos, nxt_speed))\n                    nxt.append((pos, nxt_speed))\n            q = nxt\n            steps += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0, 1)])\n        dists = {(0, 1): 0}\n        while queue:\n            x, v = queue.popleft()\n            d = dists[(x, v)]\n            if x+v == target:\n                return d+1\n            y, w = x+v, v << 1\n            if (y, w) not in dists:\n                dists[(y, w)] = d+1\n                queue.append((y, w))\n            opv = -1 if v > 0 else 1\n            if (x, opv) not in dists:\n                dists[(x, opv)] = d+1\n                queue.append((x, opv)) ", "class Solution:\n  def __init__(self):\n    self.dp = {0: 0}\n  \n  def racecar(self, t: int) -> int:\n    if t in self.dp:\n      return self.dp[t]\n    n = t.bit_length()\n    if 2**n - 1 == t:\n      self.dp[t] = n\n    else:\n      # go pass via n A's, then turn back\n      self.dp[t] = self.racecar(2**n - 1 - t) + n + 1\n      # stop after (n - 1) A's, turn back, go m A's, then turn back\n      for m in range(n - 1):\n        self.dp[t] = min(self.dp[t], self.racecar(t - 2**(n - 1) + 2**m) + n + m + 1)\n    return self.dp[t]", "class Solution:\n    def racecar(self, target):\n        target *= -1\n        q, used = [(0, 0, -1)], {(0, -1)}\n        while q:\n            cnt, pos, speed = heapq.heappop(q)\n            if pos == target:\n                return cnt\n            elif pos > 20000 or -20000 > pos:\n                continue\n            if (pos + speed, speed * 2) not in used:\n                heapq.heappush(q, (cnt + 1, pos + speed, speed * 2))\n                used.add((pos + speed, speed * 2))\n            if speed < 0 and (pos, 1) not in used:\n                heapq.heappush(q, (cnt + 1, pos, 1))\n                used.add((pos, 1))\n            elif speed > 0 and (pos, -1) not in used:\n                heapq.heappush(q, (cnt + 1, pos, -1))\n                used.add((pos, -1))", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        \n        steps = 0\n        queue = deque([(0, 1)])\n        cache = {(0,1)}\n        while queue:\n            for _ in range(len(queue)):\n                p, s = queue.popleft()\n                if p == target:\n                    return steps\n                p1,s1 = p+s, s*2\n                p2 = p\n                s2 = -1 if s > 0 else 1\n                if (p1,s1) not in cache:\n                    cache.add((p1,s1))\n                    queue.append((p1,s1))\n                if (p2,s2) not in cache:\n                    cache.add((p2,s2))\n                    queue.append((p2,s2))\n            steps += 1\n\n                \n            \n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dq = deque([(0, 1)])\n        res = 0\n        seen = {(0,1)}\n        while dq:\n            length = len(dq)\n            \n            for _ in range(length):\n                p, s = dq.popleft()\n                \n                rs = -1 if s>0 else 1\n                for np, ns in [[p+s, 2*s], [p, rs]]:\n                    if np==target:\n                        return res+1\n                    \n                    if (np, ns) not in seen:\n                        seen.add((np, ns))\n                        dq.append((np, ns))\n                        \n            res += 1", "class Solution:\n    def racecar(self, target: int) -> int:\n        visited = {(0,1)}\n        queue = collections.deque()\n        queue.append((0,1))\n        steps = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                s, v = queue.popleft()\n                if s == target: return steps\n                # 'A'\n                cur_s = s + v\n                cur_v = v * 2\n                if (cur_s, cur_v) not in visited:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n                #'R'\n                cur_s = s\n                cur_v = -1 if v > 0 else 1\n                if (cur_s, cur_v) not in visited:\n                    queue.append((cur_s, cur_v))\n                    visited.add((cur_s, cur_v))\n            steps += 1\n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = collections.deque()\n        q.append((0, 1))\n        visited = set()\n        visited.add((0, 1))\n        \n        step = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return step\n                \n                # 'A'\n                if (pos + speed, speed * 2) not in visited:\n                    visited.add((pos + speed, speed * 2))\n                    q.append((pos + speed, speed * 2))\n                \n                # 'R'\n                if (pos > target and speed > 0) or (pos < target and speed < 0) or (pos + speed > target and speed > 0) or (pos + speed < target and speed < 0):\n                    speed = -1 if speed > 0 else 1\n                    if (pos, speed) not in visited:\n                        visited.add((pos, speed))\n                        q.append((pos, speed))\n        \n            step += 1\n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1)])\n        visited = set([(0, 1)])\n        \n        step = 0\n        while q:\n            l = len(q)\n            step += 1\n            for _ in range(l):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return step - 1\n                new_pos, new_speed = pos + speed, speed * 2\n                if (new_pos, new_speed) not in visited:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n                \n                new_pos, new_speed = pos, -1 if speed > 0 else 1\n                if (new_pos, new_speed) not in visited:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        q = [(0,1)]\n        vis = {(0,1)}\n        ans=0\n        while q:\n            new_q = []\n            for p,s in q:\n                if p==target:\n                    return ans\n                p1,s1 = p+s,2*s\n                p2,s2 = p, -1 if s>0 else 1\n                if (p1,s1) not in vis:\n                    vis.add((p1,s1))\n                    new_q.append((p1,s1))\n                if (p2,s2) not in vis:\n                    vis.add((p2,s2))\n                    new_q.append((p2,s2))\n            q = new_q\n            ans+=1\n        return -1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        q = [(0,1)]\n        vis = set([(0,1)])\n        ans=0\n        while q:\n            new_q = []\n            for p,s in q:\n                if p==target:\n                    return ans\n                p1,s1 = p+s,2*s\n                p2,s2 = p, -1 if s>0 else 1\n                if (p1,s1) not in vis:\n                    vis.add((p1,s1))\n                    new_q.append((p1,s1))\n                if (p2,s2) not in vis:\n                    vis.add((p2,s2))\n                    new_q.append((p2,s2))\n            q = new_q\n            ans+=1\n        return -1\n", "from collections import deque\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1, 0)])\n        visited = set([(0, 1)])\n        while q:\n            pos, speed, steps = q.popleft()\n            if pos == target:\n                return steps\n            \n            nxt_pos = pos + speed\n            nxt_speed = speed * 2\n            if (nxt_pos, nxt_speed) not in visited:\n                visited.add((nxt_pos, nxt_speed))\n                q.append((nxt_pos, nxt_speed, steps+1))\n            \n            nxt_pos = pos\n            nxt_speed = -1 if speed > 0 else 1\n            if (nxt_pos, nxt_speed) not in visited:\n                visited.add((nxt_pos, nxt_speed))\n                q.append((nxt_pos, nxt_speed, steps+1))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        # BFS + trim\n        if target==0: return 0\n        q = {(0,1)} # (pos, speed)\n        visited= {(0,1)}\n        steps = -1\n        while q:\n            steps += 1\n            next_q = set()\n            for pos, speed in q:\n                if pos==target: return steps\n                # 1. If A\n                state_A = (pos+speed, speed*2)\n                if state_A not in visited:\n                    visited.add(state_A)\n                    next_q.add(state_A)\n                # 2. If R\n                state_R =  (pos, -1 if speed>0 else 1)\n                if state_R not in visited:\n                    visited.add(state_R)\n                    next_q.add(state_R)\n            q = next_q\n        return steps", "class Solution:\n    def racecar(self, target: int) -> int:\n        stack = collections.deque([(0, 1, 0)])\n        seen = set([(0, 1)])\n        while stack:\n            pos, speed, steps = stack.popleft()\n            if pos == target:\n                return steps\n            \n            new = (pos + speed, speed * 2)\n            if new not in seen:\n                seen.add(new)\n                stack.append((new[0], new[1], steps + 1))\n            \n            \n            new = (pos, -1 if speed > 0 else 1)\n            if new not in seen:\n                seen.add(new)\n                stack.append((new[0], new[1], steps + 1))\n", "import numpy as np\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        def dp(t):\n            if ans[t] > 0:\n                return ans[t]\n            n = int(np.ceil(np.log2(t + 1)))\n            if 1 << n == t + 1:\n                ans[t] = n\n                return ans[t]\n            ans[t] = n + 1 + dp((1 << n) - 1 - t)\n            for m in range(n):\n                cur = (1 << (n - 1)) - (1 << m)\n                ans[t] = min(ans[t], n + m + 1 + dp(t - cur))\n            return ans[t]\n            \n        ans = [0 for _ in range(target + 1)]\n        return dp(target)", "class Solution:\n    def racecar(self, T: int, depth = 0) -> int:\n        q = collections.deque([[ 0, 1 ]])\n        seen = set('0,1')\n        while True:\n            k = len(q)\n            while k:\n                [ pos, vel ] = q.popleft()\n                if pos == T:\n                    return depth  # \\\\U0001f3af target T found\n                cand = []\n                if abs(T - (pos + vel) < T):\n                    cand.append([ pos + vel, 2 * vel ])\n                cand.append([ pos, 1 if vel < 0 else -1 ])\n                for pos, vel in cand:\n                    if f'{pos},{vel}' not in seen:\n                        q.append([ pos, vel ])\n                        seen.add(f'{pos},{vel}')\n                k -= 1\n            depth += 1\n        return -1\n                \n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        dic = {}\n        qu = deque([(0,1)])\n        dic[(0, 1)] = 0\n        while qu:\n            front = qu.popleft()\n            pos, spd = front\n            if pos == target:\n                return dic[front]\n            \n            speedup = (pos + spd, spd*2)\n            if speedup not in dic:\n                qu.append(speedup)\n                dic[speedup] = dic[front] + 1\n            \n            fwd2bwd = (pos, -1)\n            if spd > 0 and fwd2bwd not in dic:\n                qu.append(fwd2bwd)\n                dic[fwd2bwd] = dic[front] + 1\n                \n            bwd2fwd = (pos, 1)\n            if spd < 0 and (pos, 1) not in dic:\n                qu.append((pos, 1))\n                dic[bwd2fwd] = dic[front] + 1\n            \n            \n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = collections.deque()\n        q.append((0, 1))\n        visited = set()\n        visited.add((0, 1))\n        \n        step = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return step\n                \n                # 'A'\n                if (pos + speed, speed * 2) not in visited:\n                    visited.add((pos + speed, speed * 2))\n                    q.append((pos + speed, speed * 2))\n                \n                # 'R'\n                if speed > 0:\n                    speed = -1\n                else:\n                    speed = 1\n                if (pos, speed) not in visited:\n                    visited.add((pos, speed))\n                    q.append((pos, speed))\n        \n            step += 1\n        \n", "class Solution:\n    def racecar(self, T: int) -> int:\n        q = collections.deque([[ 0, 1 ]])\n        seen = set('0,1')\n        depth = 0\n        while True:\n            k = len(q)\n            while k:\n                [ pos, vel ] = q.popleft()\n                if pos == T:\n                    return depth  # \\\\U0001f3af target T found\n                cand = []\n                if abs(T - (pos + vel) < T):\n                    cand.append([ pos + vel, 2 * vel ])\n                cand.append([ pos, 1 if vel < 0 else -1 ])\n                for pos, vel in cand:\n                    if f'{pos},{vel}' not in seen:\n                        q.append([ pos, vel ])\n                        seen.add(f'{pos},{vel}')\n                k -= 1\n            depth += 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0, 1, 0)])\n        seen = {(0, 1)}\n        while queue:\n            pos, speed, cost = queue.popleft()\n            if pos == target:\n                return cost\n            \n            # A\n            new_pos, new_speed = pos + speed, speed * 2\n            if (new_pos, new_speed) not in seen:\n                seen.add((new_pos, new_speed))\n                queue.append((new_pos, new_speed, cost + 1)) # A\n                \n            # R\n            reverse_speed = -1 if speed > 0 else 1\n            if (pos, reverse_speed) not in seen:\n                seen.add((pos, reverse_speed))\n                queue.append((pos, reverse_speed, cost + 1))\n            \n                    \n            \n        \n", "class Solution:\n    def racecar(self, T: int, depth = 0) -> int:\n        q = collections.deque([[ 0, 1 ]])\n        seen = set('0,1')\n        while True:\n            k = len(q)\n            while k:\n                [ pos, vel ] = q.popleft()\n                if pos == T:\n                    return depth  # \\\\U0001f3af target T found\n                cand = []\n                if abs(T - (pos + vel) < T):\n                    cand.append([ pos + vel, 2 * vel ])\n                cand.append([ pos, 1 if vel < 0 else -1 ])\n                for pos, vel in cand:\n                    if f'{pos},{vel}' not in seen:\n                        q.append([ pos, vel ])\n                        seen.add(f'{pos},{vel}')\n                k -= 1\n            depth += 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = [(0, 1)]\n        step = 0\n        visited = {(0, 1)}\n        while queue:\n            tmp = queue\n            queue = []\n            for pos, speed in tmp:\n                if pos == target:\n                    return step\n                \n                if not (pos + speed, speed * 2) in visited:\n                    queue.append((pos + speed, speed * 2))\n                    visited.add((pos + speed, speed * 2))\n                speed = -1 if speed > 0 else 1\n                if not (pos, speed) in visited:\n                    queue.append((pos, speed))\n                    visited.add((pos, speed))\n            step += 1\n        \n        return 0", "class Solution:\n    def racecar(self, target: int) -> int:\n        pq = [(0, 0, -1)]\n        visited = set([(0, -1)])\n        \n        while pq:\n            steps, pos, speed = heapq.heappop(pq)\n            \n            next_steps = steps + 1\n            next_pos = pos + speed\n            next_speed = speed * 2\n            \n            if -next_pos == target:\n                return next_steps\n            \n            if -next_pos < 2 * target and -next_speed < 2 * target and not (next_pos, next_speed) in visited:\n                heapq.heappush(pq, (next_steps, next_pos, next_speed))\n                visited.add((next_pos, next_speed))\n            \n            if speed < 0 and not (pos, 1) in visited:\n                heapq.heappush(pq, (next_steps, pos, 1))\n                visited.add((pos, 1))\n            elif speed > 0 and not (pos, -1) in visited:\n                heapq.heappush(pq, (next_steps, pos, -1))\n                visited.add((pos, -1))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        nodes = [(0, 1)]\n        seen, length = set([(0, 1)]), 0\n        while nodes:\n            new_nodes = []\n            for pos, speed in nodes:\n                if pos == target:\n                    return length\n                # A\n                for new_pos, new_speed in [\n                    (pos + speed, speed * 2),\n                    (pos, -1 if speed > 0 else 1),\n                ]:\n                    if (new_pos, new_speed) not in seen:\n                        seen.add((new_pos, new_speed))\n                        new_nodes.append((new_pos, new_speed))\n            length += 1\n            nodes = new_nodes\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        # dp[i] solution for target = i\n        dp = [ 0, 1, 4 ] + [ float('inf') ] * (target - 2)\n        for i in range(3, target + 1):\n            k = math.log2(i + 1)\n            if int(k) == k:\n                dp[i] = int(k)\n                continue\n            k = int(k)\n            # 1. go to 2 ** m - 1 and R^2 costing m + 2 (m <= k)\n            for m in range(0, k):\n                dp[i] = min(dp[i], dp[i - 2 ** k + 2 ** m] + k + m + 2)\n            # 2. go to 2 ** (k + 1) - 1 and R costing k + 1 + 1 \n            if i > 2 ** (k + 1) - 1 - i:\n                dp[i] = min(dp[i], dp[2 ** (k + 1) - 1 - i] + k + 1 + 1)\n        return dp[target]\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        q = collections.deque([])\n        q.append((0, 1, 0))\n        visited = set()\n        visited.add((0, 1))\n        \n        while q:\n            pos, speed, steps = q.popleft()\n            \n            if pos == target:\n                return steps\n            \n            if (pos + speed, speed * 2) not in visited:\n                q.append((pos + speed, speed * 2, steps + 1))\n                visited.add((pos + speed, speed * 2))\n            \n            if speed > 0:\n                if (pos, -1) not in visited:\n                    q.append((pos, -1, steps + 1))\n                    visited.add((pos, -1))\n            else:\n                if (pos, 1) not in visited:\n                    q.append((pos, 1, steps + 1))\n                    visited.add((pos, 1))\n        return -1\n", "from collections import deque\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1)])\n        visited = set([(0, 1)])\n        res = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return res\n                if (pos + speed, speed * 2) not in visited:\n                    q.append((pos + speed, speed * 2))\n                    visited.add((pos + speed, speed * 2))\n                speed = 1 if speed < 0 else -1\n                if (pos, speed) not in visited:\n                    q.append((pos, speed))\n                    visited.add((pos ,speed))\n            res += 1\n        return res", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        queue = [[(0, 1)]] #(position, speed)\n        visited = {(0,1)}\n        \n        seq = 0\n        while queue:\n            curLevel = queue.pop()\n            newLevel = []\n            \n            for pos, speed in curLevel:\n                if pos == target:\n                    return seq\n                \n                for newPos, newSpeed in [(pos+speed, speed*2), (pos, -1 if speed > 0 else 1)]:\n                    if (newPos, newSpeed) not in visited:\n                        visited.add((newPos, newSpeed))\n                        newLevel.append((newPos, newSpeed))\n                \n            if newLevel:\n                queue.append(newLevel)\n                seq += 1\n        \n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        initial_state = (0, 1, 0)\n        bfs = [initial_state]\n        valid_actions = ['A', 'R']\n        visited = set([(0, 1)])\n        for position, speed, count in bfs:\n            if position == target:\n                return count\n\n            for action in valid_actions:\n                if action == 'A':\n                    _position = position + speed\n                    _speed = speed * 2\n\n\n                elif action == 'R':\n                    _position = position\n                    if speed > 0:\n                        _speed = -1\n                    else:\n                        _speed = 1\n\n                if (_position, _speed) not in visited:\n                    visited.add((_position, _speed))\n                    bfs.append((_position, _speed, count+1))\n\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        # bfs\n        bq=collections.deque([(0,1,0)])\n        visited=set((0,1))\n        while bq:\n            p,s,step= bq.popleft()\n            if p==target:\n                return step\n            if (p+s,2*s) not in visited:\n                bq.append((p+s,2*s,step+1))\n                visited.add((p+s,2*s))\n            ns= 1 if s<0 else -1\n            if (p,ns) not in visited:\n                bq.append((p,ns,step+1))\n                visited.add((p,ns))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        barrier = 2 * target\n        heap = [[0,0,1]]\n        seen = {}\n        while heap:\n            step, position, speed = heappop(heap)\n            \n            if position == target:\n                return step - 1\n            \n            if (position,speed) in seen and seen[position,speed] <= step:\n                continue\n            seen[position,speed] = step\n\n            k = 0\n            while True:\n                new_pos = position + speed * (2 ** k - 1)\n\n                if -barrier <= new_pos <= barrier:\n                    heappush(heap, [step + k + 1, new_pos, -speed])\n                else:\n                    break\n                k += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        barrier = 2 * target\n        heap = [[0,0,1]]\n        seen = {}\n        while heap:\n            step, position, speed = heappop(heap)\n            \n            if position == target:\n                return step - 1\n            \n            if (position,speed) in seen and seen[position,speed] <= step:\n                continue\n            seen[position,speed] = step\n\n            k = 0\n            while True:\n                new_pos = position + speed * (2 ** k - 1)\n\n                if -barrier <= new_pos <= barrier:\n                    heappush(heap, [step + k + 1, new_pos, -speed])\n                else:\n                    break\n                    \n                k += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        max_step = int(log(target,2)) + 2\n        barrier = 2 * target + 2\n        heap = [[i + 1, 0 + (2 ** i - 1), -1] for i in range(max_step+1)]\n        seen = {}\n        while heap:\n            step, position, speed = heappop(heap)\n            \n            if position == target:\n                return step - 1\n            \n            if (position,speed) in seen and seen[position,speed] <= step:\n                continue\n            seen[position,speed] = step\n\n            k = 0\n            while True:\n                new_pos = position + speed * (2 ** k - 1)\n\n                if -barrier <= new_pos <= barrier:\n                    heappush(heap, [step + k + 1, new_pos, -speed])\n                else:\n                    break\n                    \n                k += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        barrier = 2 * target\n        heap = [[0,0,1]]\n        seen = set()\n        while heap:\n            step, position, speed = heappop(heap)\n            \n            if position == target:\n                return step - 1\n            \n            if (position,speed) in seen:\n                continue\n            seen.add((position,speed))\n\n            k = 0\n            while True:\n                new_pos = position + speed * (2 ** k - 1)\n\n                if -barrier <= new_pos <= barrier:\n                    heappush(heap, [step + k + 1, new_pos, -speed])\n                else:\n                    break\n                k += 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in range(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0,1,4] + [float('inf')] * target\n        for t in range(3, target+1):\n            k = t.bit_length()\n            if t == 2**k-1:\n                dp[t] = k\n                continue\n            for j in range(k-1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n                # dp[t] = min(dp[t], dp[t - 2**(k - 1) + 1] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0, 1, 4] + [float('inf')] * target\n        for i in range(3, target+1):\n            k = i.bit_length()\n            if i == 2**k-1:\n                dp[i] = k\n                continue\n            \n            for j in range(k-1):\n                dp[i] = min(dp[i], dp[i-2**(k-1) + 2**j] + k-1+j+2)\n            if 2**k-1-i < i:\n                dp[i] = min(dp[i], dp[2**k-1-i]+k+1)\n        return dp[target]", "class Solution(object):\n    def racecar(self, target):\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in range(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]", "class Solution:\n    def racecar(self, target: int) -> int:\n        # from answers:\n        # Dojkstra's\n        '''\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]\n        '''\n        # Dynamic programming\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in range(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 0\n        \n        f = [None] * (target + 1)\n        \n        f[0] = 0\n        \n        for i in range(1, target + 1):\n            f[i] = float('inf')\n            \n            k = i.bit_length()\n            \n            if i == 2 ** k - 1:\n                f[i] = k\n                continue\n                \n            # underspeed\n            for j in range(k - 1):\n                f[i] = min(f[i], f[i - 2 ** (k - 1) + 2 ** j] + k - 1 + j + 2)\n                \n            # overspeed\n            if 2 ** k - 1 - i < i:\n                f[i] = min(f[i], f[2 ** k - 1 - i] + k + 1)\n        return f[target]", "class Solution:\n    def racecar(self, target: int) -> int:\n        LIMIT = 2**(target.bit_length()) - 1\n        dp = [0, 1, 4] + [float('INF')]*(LIMIT-2)\n        for t in range(3, target+1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            # not cross t, but first reverse to position t - 2**(k-1) + 2**j, then reverse and accelerate to t\n            for j in range(k):\n                dp[t] = min(dp[t], dp[t - 2**(k-1) + 2**j] + k + j + 1)\n            # first cross t to 2**k - 1, then reverse to t\n            dp[t] = min(dp[t], k + 1 + dp[2**k - 1 - t])\n        \n        return dp[target]", "class Solution:\n    def __init__(self):\n        self._dp = {0:0}\n\n    def racecar(self, target):\n        # \u8f66\u5b50\u521d\u59cb\u4f4d\u7f6e0\uff0c\u901f\u5ea61\n        # \u9047\u5230A\uff0cposition += speed\u5e76\u4e14speed *= 2\n        # \u9047\u5230R\uff0cspeed = -1\u5982\u679c\u5f53\u524dspeed\u662f1\uff1bspeed = 1\u5982\u679c\n        # \u7ed9\u5b9a\u6700\u7ec8\u7684\u4f4d\u7f6etarget\uff0c\u95ee\u6700\u77ed\u7684sequence\uff08\u7531A\u548cR\u7ec4\u6210\uff09\u80fd\u591f\u5230\u8fbetarget\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 4\n        # \u5982\u679c\u4e00\u76f4\u8e29\u6cb9\u95e8\u7684\u8bdd(\u8fde\u7eed3\u4e2aA)\n        # \u5219\u4f1a\u5230\u8fbe0 -> 1 -> 3 -> 7\n        #         k=1  k=2  k=3\n        dp = [2 ** 31 - 1] * (target + 1)\n        dp[0], dp[1], dp[2] = 0, 1, 4\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2 ** k - 1:\n                # t = 7, \u4e8c\u8fdb\u5236111, k = 3\n                # \u6b64\u65f6\u8868\u660e\u8e293\u811a\u6cb9\u95e8\u5c31\u80fd\u5230\u4e86\n                dp[t] = k\n                continue\n            \n            # \u60c5\u51b51\uff1a\u8d702 ** (k - 1)\u7684\u8ddd\u79bb\n            # \u7136\u540e\u7528\u4e00\u4e2aR\u548cm\u4e2aA\u53bb\u5f80\u56de\u8d70\n            # \u8fd9\u65f6\u5019\u5df2\u7ecf\u8d70\u4e86k - 1 + 1 + m + 1\u6b65\uff08\u5373A**(k - 1)RA**(m)R\u6b65)\n            # \u7136\u540e\u53bbdp\u91cc\u627e\u5269\u4f59\u7684\u6b65\u6570t - 2 ** (k - 1) + 2 ** m\n            for m in range(k - 1):\n                # \u6ce8\u610f\uff1a\u540e\u9762\u7684k - 1 + m + 2\u662f\u5f53\u524d\u8d70\u4e86\u8fd9\u4e48\u591a\u6b65\n                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** m] + k - 1 + m + 2)\n            \n            # \u60c5\u51b52\uff1a\u76f4\u63a52 ** k\u6b65\n            #\uff08\u5df2\u7ecf\u8d70\u4e86\u6700\u5927\u7684k + 1\u6b65, \u5c31\u662f\u5728\u6700\u540emin\u51fd\u6570\u62ec\u53f7\u91cc\u52a0\u7684\u90a3\u4e00\u90e8\u5206\uff0c\u52a01\u662f\u6307\u4e00\u4e2aR\uff09\n            # \u7136\u540e\u518d\u5f80\u56de\u8d70\n            # \u8d70\u4e86k + 1\u6b65\u8ddd\u79bb\u5c31\u662f2 ** k - 1\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u5df2\u7ecf\u8d85\u8d8a\u4e86t\n            # \u6240\u4ee5\u8fd8\u8981\u7ee7\u7eed\u8d702 ** k - 1 - t\u6b65\u624d\u80fd\u8d70\u5230t\n            if 2 ** k - 1 - t > 0:\n                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)\n        return dp[target]\n        \n", "class Solution:\n    def racecar(self, target):\n        # \u8f66\u5b50\u521d\u59cb\u4f4d\u7f6e0\uff0c\u901f\u5ea61\n        # \u9047\u5230A\uff0cposition += speed\u5e76\u4e14speed *= 2\n        # \u9047\u5230R\uff0cspeed = -1\u5982\u679c\u5f53\u524dspeed\u662f1\uff1bspeed = 1\u5982\u679c\n        # \u7ed9\u5b9a\u6700\u7ec8\u7684\u4f4d\u7f6etarget\uff0c\u95ee\u6700\u77ed\u7684sequence\uff08\u7531A\u548cR\u7ec4\u6210\uff09\u80fd\u591f\u5230\u8fbetarget\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 4\n        # \u5982\u679c\u4e00\u76f4\u8e29\u6cb9\u95e8\u7684\u8bdd(\u8fde\u7eed3\u4e2aA)\n        # \u5219\u4f1a\u5230\u8fbe0 -> 1 -> 3 -> 7\n        #         k=1  k=2  k=3\n        dp = [2 ** 31 - 1] * (target + 1)\n        dp[0], dp[1], dp[2] = 0, 1, 4\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2 ** k - 1:\n                # t = 7, \u4e8c\u8fdb\u5236111, k = 3\n                # \u6b64\u65f6\u8868\u660e\u8e293\u811a\u6cb9\u95e8\u5c31\u80fd\u5230\u4e86\n                dp[t] = k\n                continue\n            \n            # \u6b64\u65f6\u5fc5\u5b9a 2 ** (k - 1) <= t <= 2 ** (k + 1)\n            assert 2 ** (k - 1) <= t <= 2 ** (k + 1)\n\n            # \u60c5\u51b51\uff1a\u8d70k - 1\u6b65\uff0c\u8fd8\u6ca1\u5230t\uff0c\u56de\u5934\u518d\u56de\u5934\u7684\u7b56\u7565\n            # \u7136\u540e\u7528\u4e00\u4e2aR\u548cm\u4e2aA\u53bb\u5f80\u56de\u8d70\n            # \u8fd9\u65f6\u5019\u5df2\u7ecf\u8d70\u4e86k - 1 + 1 + m + 1\u6b65\uff08\u5373A**(k - 1)RA**(m)R\u6b65)\n            # \u7136\u540e\u53bbdp\u91cc\u627e\u5269\u4f59\u7684\u6b65\u6570t - 2 ** (k - 1) + 2 ** m\n            for m in range(k - 1):\n                # \u6ce8\u610f\uff1a\u540e\u9762\u7684k - 1 + m + 2\u662f\u5f53\u524d\u8d70\u4e86\u8fd9\u4e48\u591a\u6b65\n                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** m] + k - 1 + m + 2)\n            \n            # \u60c5\u51b52\uff1a\u76f4\u63a5k\u6b65\uff0c\u5047\u8bbe\u80fd\u591f\u8d85\u8fc7t\uff0c\u5c31\u91c7\u53d6\u518d\u56de\u5934\u7684\u7b56\u7565\n            #\uff08\u5df2\u7ecf\u8d70\u4e86k\u6b65, \u5c31\u662f\u5728\u6700\u540emin\u51fd\u6570\u62ec\u53f7\u91cc\u52a0\u7684\u90a3\u4e00\u90e8\u5206\uff0c\u52a01\u662f\u6307\u4e00\u4e2aR\uff09\n            # \u7136\u540e\u518d\u5f80\u56de\u8d70\n            # \u8d70\u4e86k\u6b65\u8ddd\u79bb\u5c31\u662f2 ** k - 1\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u5df2\u7ecf\u8d85\u8d8a\u4e86t\n            # \u6240\u4ee5\u8fd8\u8981\u7ee7\u7eed\u8d702 ** k - 1 - t\u6b65\u624d\u80fd\u8d70\u5230t\n            if 2 ** k - 1 - t > 0:\n                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)\n        return dp[target]\n        \n", "from collections import deque\n\nclass Solution:\n    def racecar(self, target):\n        # \u8f66\u5b50\u521d\u59cb\u4f4d\u7f6e0\uff0c\u901f\u5ea61\n        # \u9047\u5230A\uff0cposition += speed\u5e76\u4e14speed *= 2\n        # \u9047\u5230R\uff0cspeed = -1\u5982\u679c\u5f53\u524dspeed\u662f1\uff1bspeed = 1\u5982\u679c\n        # \u7ed9\u5b9a\u6700\u7ec8\u7684\u4f4d\u7f6etarget\uff0c\u95ee\u6700\u77ed\u7684sequence\uff08\u7531A\u548cR\u7ec4\u6210\uff09\u80fd\u591f\u5230\u8fbetarget\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 4\n        # \u5982\u679c\u4e00\u76f4\u8e29\u6cb9\u95e8\u7684\u8bdd(\u8fde\u7eed3\u4e2aA)\n        # \u5219\u4f1a\u5230\u8fbe0 -> 1 -> 3 -> 7\n        #         k=1  k=2  k=3\n        # dp[t]\u7684\u5b9a\u4e49\u662f\u5230\u8fbet\u4f4d\u7f6e\u6700\u5c11\u9700\u8981\u8d70\u591a\u5c11\u6b65\n        dp = [2 ** 31 - 1] * (target + 1)\n        dp[0], dp[1], dp[2] = 0, 1, 4\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2 ** k - 1:\n                # t = 7, \u4e8c\u8fdb\u5236111, k = 3\n                # \u6b64\u65f6\u8868\u660e\u8e293\u811a\u6cb9\u95e8\u5c31\u80fd\u5230\u4e86\n                dp[t] = k\n                continue\n            \n            # \u6b64\u65f6\u5fc5\u5b9a 2 ** (k - 1) <= t <= 2 ** (k + 1)\n            assert 2 ** (k - 1) <= t <= 2 ** (k + 1)\n\n            # \u60c5\u51b51\uff1a\u8d70k - 1\u6b65\uff0c\u8fd8\u6ca1\u5230t\uff0c\u56de\u5934\u518d\u56de\u5934\u7684\u7b56\u7565\n            # \u7136\u540e\u7528\u4e00\u4e2aR\u548cm\u4e2aA\u53bb\u5f80\u56de\u8d70\n            # \u8fd9\u65f6\u5019\u5df2\u7ecf\u8d70\u4e86k - 1 + 1 + m + 1\u6b65\uff08\u5373A**(k - 1)RA**(m)R\u6b65)\n            # \u7136\u540e\u53bbdp\u91cc\u627e\u5269\u4f59\u7684\u6b65\u6570t - 2 ** (k - 1) + 2 ** m\n            for m in range(k - 1):\n                # \u6ce8\u610f\uff1a\u540e\u9762\u7684k - 1 + m + 2\u662f\u5f53\u524d\u8d70\u4e86\u8fd9\u4e48\u591a\u6b65\n                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** m] + k - 1 + m + 2)\n            \n            # \u60c5\u51b52\uff1a\u76f4\u63a5k\u6b65\uff0c\u5047\u8bbe\u80fd\u591f\u8d85\u8fc7t\uff0c\u5c31\u91c7\u53d6\u518d\u56de\u5934\u7684\u7b56\u7565\n            #\uff08\u5df2\u7ecf\u8d70\u4e86k\u6b65, \u5c31\u662f\u5728\u6700\u540emin\u51fd\u6570\u62ec\u53f7\u91cc\u52a0\u7684\u90a3\u4e00\u90e8\u5206\uff0c\u52a01\u662f\u6307\u4e00\u4e2aR\uff09\n            # \u7136\u540e\u518d\u5f80\u56de\u8d70\n            # \u8d70\u4e86k\u6b65\u8ddd\u79bb\u5c31\u662f2 ** k - 1\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u5df2\u7ecf\u8d85\u8d8a\u4e86t\n            # \u6240\u4ee5\u8fd8\u8981\u7ee7\u7eed\u8d702 ** k - 1 - t\u6b65\u624d\u80fd\u8d70\u5230t\n            if 2 ** k - 1 - t > 0:\n                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)\n        return dp[target]\n        \n        # BFS\u89e3\u6cd5\uff0c\u975e\u6700\u4f18\uff0c\u4f46\u662f\u597d\u60f3\n#         queue = deque([(0, 1)])\n#         # \u72b6\u6001\u662f(location, speed)\n#         visited = set([(0, 1)])\n        \n#         res = 0\n#         while queue:\n#             q_len = len(queue)\n#             for _ in range(q_len):\n#                 curr_pos, curr_speed = queue.popleft()\n#                 if curr_pos == target:\n#                     return res\n                \n#                 # case-1: \u5f53\u524d\u9009\u62e9A\n#                 new_pos = curr_pos + curr_speed\n#                 new_speed = 2 * curr_speed\n#                 if (new_pos, new_speed) not in visited:\n#                     queue.append((new_pos, new_speed))\n#                     visited.add((new_pos, new_speed))\n                \n#                 # case-2: \u5f53\u524d\u9009\u62e9R\n#                 new_pos = curr_pos\n#                 new_speed = -1 if curr_speed > 0 else 1\n#                 if (new_pos, new_speed) not in visited:\n#                     queue.append((new_pos, new_speed))\n#                     visited.add((new_pos, new_speed))\n#             res += 1\n            \n#         return res\n", "from collections import deque\n\nclass Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0, 1)]) # position, speed\n        level = 0\n        while True:\n            size = len(queue)\n            for _ in range(size):\n                position, speed = queue.popleft()\n                if position == target:\n                    return level\n                queue.append((position + speed, speed * 2))\n                if position + speed > target and speed > 0 or position + speed < target and speed < 0:\n                    queue.append((position, -1 if speed > 0 else 1))\n            level += 1", "class Solution:\n    def racecar(self, target: int) -> int:\n        f = [None] * (target + 1)\n        \n        f[0] = 0\n\n        for i in range(1, target + 1):\n            f[i] = float('inf')\n            \n            k = i.bit_length()\n            \n            if i == 2**k - 1:\n                f[i] = k\n                continue\n            \n            # underspeed\n            for j in range(k - 1):\n                f[i] = min(f[i], f[i - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            \n            # overspeed\n            if 2**k - 1 - i < i:\n                f[i] = min(f[i], f[2**k - 1 - i] + k + 1)\n        return f[target]\n    \n#         f = [None] * (target + 1)\n        \n#         f[0] = 0\n        \n#         for i in range(1, target + 1):\n#             f[i] = float('inf')\n            \n#             n = len(bin(i)[2:])\n            \n#             if 2**n - 1 == i:\n#                 f[i] = n\n#                 continue\n                \n#             # overspeed\n#             f[i] = f[2**n - 1 - i] + n + 1 # reverse once\n            \n#             # underspeed\n#             for j in range(0, n):\n#                 gap = 1 << j - 1\n#                 f[i] = min(f[i], f[i - 2**(n - 1) + gap] + n + j + 1) # reverse twice\n#         return f[target]\n            \n        \n        \n#         int[] f = new int[target + 1];\n#         for (int i = 1; i <= target; i++){\n#             int bound = (Integer.highestOneBit(i) << 1) - 1;\n#             int n = Integer.bitCount(bound);\n#             if (i == bound){\n#                 f[i] = n;\n#                 continue;\n#             }\n#             // overspeed\n#             f[i] = f[bound - i] + n + 1; // Reverse once\n#             // underspeed\n#             bound >>= 1;\n#             for (int j = 0; j < n; j++){\n#                 int gap = (1 << j) - 1;\n#                 f[i] = Math.min(f[i], f[i - bound + gap] + n + j + 1); // Reverse twice\n#             }\n#         }\n#         return f[target];\n#     }\n# }\n", "class Solution:\n    def racecar(self, target):\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in range(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]\n# \u6bd4\u8f83\u96be\u7684\u4e00\u9053\u9898\u76ee\uff0c\u60f3\u4e86\u51e0\u5929\u65e0\u679c\u770b\u4e86\u5b98\u65b9\u7ed9\u7684\u9898\u89e3\uff0c\u8fd8\u662f\u5f88\u5de7\u5999\u7684\u3002\n# \u7528Ak\u8868\u793ak\u6b21\u8fde\u7eed\u7684A\uff0c\u9996\u5148\u7ed3\u5c3e\u4e00\u5b9a\u4e0d\u662fR\uff0c\u5f00\u5934\u7684RAk\u53ef\u4ee5\u653e\u5230\u6700\u540e\u3002\n# \u90a3\u4e48\u6700\u7ec8\u6307\u4ee4\u5e94\u8be5\u5f62\u5982Ak1RAk2R\u2026RAkn\u3002\n# \u5bb9\u6613\u5f97\u5230\u5947\u6570\u7684ki\u4e0e\u5076\u6570\u7684ki\u90fd\u662f\u5355\u8c03\u9012\u51cf\u7684\uff0c\u4e14\u5404\u4e0d\u76f8\u540c\u3002\n# \u5e76\u4e14\u5230\u8fbe\u6216\u8005\u8d85\u8fc7\u76ee\u6807\u4f4d\u7f6e\u4e4b\u540e\u7ee7\u7eed\u6267\u884cA\u662f\u6ca1\u6709\u610f\u4e49\u7684\u3002\n# \u56e0\u6b64\u5c31\u6709\u4e86DP\u7684\u505a\u6cd5\uff0c\u5982\u679c\u4e0b\u6807\u4f4d\u7f6e\u662f2k\u22121\uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5Ak\u8fbe\u5230\u3002\n# \u5426\u5219\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u662f\u62d0\u4e24\u6b21\u5230\u8fbe\uff0c\u6b63\u9762\u4e00\u5b9a\u6709\u4e00\u6b21\u6700\u5927\u9650\u5ea6\u76842k\u22121\uff0c\u5916\u52a0\u8fd4\u56de\u8d70j\u6b65\uff08\u679a\u4e3ej\uff09\u3002\n# \u4e8c\u662f\u76f4\u63a5\u8d70\u521a\u597d\u8d85\u8fc72k\u22121\uff0c\u56de\u8d70\u5230\u7ec8\u70b9\u3002\n\n#     def racecar(self, target: int) -> int:\n#         # 0 -> 1 -> 3 -> 7 - > 15\n#         # 1 -> 2 -> 4 -> 8 -> 16\n#         # \u4ece 0 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5 R \u6216 A\u4e24\u4e2a\u65b9\u5411\uff0c\u9009\u62e9\u3002\n#         # \u53ef\u4ee5\u8bb0\u5f55\u6bcf\u6b21\u5230\u8fbe\u7684\u72b6\u6001\uff0c\n#         # BFS\n        \n#         d = deque([(0, 0, 1)])\n#         visited = collections.defaultdict(set)\n#         visited[0].add(1)\n#         ans = float('inf')\n#         flag = 0\n#         while d:\n#             flag += 1\n#             # print(\\\"flag=\\\", flag,\\\", d=\\\", d)\n#             l = len(d)\n#             while l:\n#                 l -= 1\n#                 cur = d.popleft()\n#                 # print(\\\"cur=\\\", cur)\n#                 pos, cost, speed = cur\n#                 if pos == target:\n#                     ans = min(ans, cost)\n#                     # continue\n#                     return cost\n#                 # use R\n#                 cost += 1\n#                 if 1:\n#                     newspeed = -1 if speed > 0 else 1\n#                     if not ((pos in visited and newspeed in visited[pos]) or (pos <= 0)):\n#                         # print(\\\"past=\\\", cur,\\\", add=\\\", (pos, cost, -1))\n#                         d.append(((pos, cost, newspeed)))\n#                         visited[pos].add(newspeed)\n#                         # \u8fd9\u91cc if \u91cc break \u4e0d\u8981\u778e\u7528\uff0c\u4f1a\u8df3\u51fa while l \u8fd9\u4e2a\u5faa\u73af\u7684\u3002\n#                 # use A\n#                 if 1:\n#                     if not (( speed in visited and (cost, speed * 2) in visited[pos]) or (pos + speed > target * 2) or (pos + speed <= 0)):\n                        \n#                         # print(\\\"past=\\\", cur,\\\", add=\\\", (pos + speed, cost, speed * 2))\n#                         d.append((pos + speed, cost, speed * 2))\n#                         visited[pos].add(speed * 2)\n#         return\n                \n#   # BFS \u641e\u4e86\u534a\u5929\uff0c\u7ec8\u4e8e\u7ed3\u675f\u4e86\u3002\u6ce8\u610f\u8981\u526a\u679d\u3002\n# # 1. \u9996\u5148 visited \u52a0\u5165\u7684\u662f pos \u548c speed\u3002\n# # 2. \u7b2c\u4e8c\u662f \u4f4d\u7f6e\u4e0d\u80fd\u8d85\u8fc7 target * 2 \u3002\u56e0\u4e3a \u5982\u679c\u8d85\u8fc7\u4e86 target * 2\u90a3\u4e48\u8981\u5012\u8f66\uff0c\u5012\u8f66\u4ece\u5934\u5f00\u59cb\uff0c\u4e5f\u8981 \u8d70 target\u3002\u8fd9\u662f \u4e0d\u5408\u7b97\u7684\u3002 \n# # 3. \u901f\u5ea6\u4e0d\u80fd\u8d85\u8fc7 2*target\u3002  \uff08\u53ef\u4ee5\u4e0d\u8981\uff09\n# # 4. \u4e0d\u8981 pos <0 \u7684\u4f4d\u7f6e\u3002\n#         # pos    0 1 3 2 3\n#         # speed  1 2 -1 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = collections.deque()\n        visited = set()\n        queue.append((0, 1))\n        visited.add((0, 1))\n        steps = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                pos, speed = queue.popleft()\n                if pos == target:\n                    return steps\n                # Option 1: do acceleration, if it is not counter productive.\n                next_pos = pos + speed\n                if 0 < next_pos < 2 * target:\n                    next_state = (next_pos, 2 * speed)\n                    if next_state not in visited:\n                        visited.add(next_state)\n                        queue.append(next_state)\n                # Option 2: do reverse.\n                next_speed = -1 if speed > 0 else 1\n                next_state = (pos, next_speed)\n                if next_state not in visited:\n                    visited.add(next_state)\n                    queue.append(next_state)\n            steps += 1\n        return -1", "class Solution:\n    def racecar(self, target):\n        # \u8f66\u5b50\u521d\u59cb\u4f4d\u7f6e0\uff0c\u901f\u5ea61\n        # \u9047\u5230A\uff0cposition += speed\u5e76\u4e14speed *= 2\n        # \u9047\u5230R\uff0cspeed = -1\u5982\u679c\u5f53\u524dspeed\u662f1\uff1bspeed = 1\u5982\u679c\n        # \u7ed9\u5b9a\u6700\u7ec8\u7684\u4f4d\u7f6etarget\uff0c\u95ee\u6700\u77ed\u7684sequence\uff08\u7531A\u548cR\u7ec4\u6210\uff09\u80fd\u591f\u5230\u8fbetarget\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 4\n        # \u5982\u679c\u4e00\u76f4\u8e29\u6cb9\u95e8\u7684\u8bdd(\u8fde\u7eed3\u4e2aA)\n        # \u5219\u4f1a\u5230\u8fbe0 -> 1 -> 3 -> 7\n        #         k=1  k=2  k=3\n        dp = [2 ** 31 - 1] * (target + 1)\n        dp[0], dp[1], dp[2] = 0, 1, 4\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2 ** k - 1:\n                # t = 7, \u4e8c\u8fdb\u5236111, k = 3\n                # \u6b64\u65f6\u8868\u660e\u8e293\u811a\u6cb9\u95e8\u5c31\u80fd\u5230\u4e86\n                dp[t] = k\n                continue\n            \n            # \u6b64\u65f6\u5fc5\u5b9a 2 ** (k - 1) <= t <= 2 ** (k + 1)\n            assert 2 ** (k - 1) <= t <= 2 ** (k + 1)\n\n            # \u60c5\u51b51\uff1a\u8d702 ** (k - 1)\u7684\u8ddd\u79bb\n            # \u7136\u540e\u7528\u4e00\u4e2aR\u548cm\u4e2aA\u53bb\u5f80\u56de\u8d70\n            # \u8fd9\u65f6\u5019\u5df2\u7ecf\u8d70\u4e86k - 1 + 1 + m + 1\u6b65\uff08\u5373A**(k - 1)RA**(m)R\u6b65)\n            # \u7136\u540e\u53bbdp\u91cc\u627e\u5269\u4f59\u7684\u6b65\u6570t - 2 ** (k - 1) + 2 ** m\n            for m in range(k - 1):\n                # \u6ce8\u610f\uff1a\u540e\u9762\u7684k - 1 + m + 2\u662f\u5f53\u524d\u8d70\u4e86\u8fd9\u4e48\u591a\u6b65\n                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** m] + k - 1 + m + 2)\n            \n            # \u60c5\u51b52\uff1a\u76f4\u63a52 ** k\u6b65\n            #\uff08\u5df2\u7ecf\u8d70\u4e86\u6700\u5927\u7684k + 1\u6b65, \u5c31\u662f\u5728\u6700\u540emin\u51fd\u6570\u62ec\u53f7\u91cc\u52a0\u7684\u90a3\u4e00\u90e8\u5206\uff0c\u52a01\u662f\u6307\u4e00\u4e2aR\uff09\n            # \u7136\u540e\u518d\u5f80\u56de\u8d70\n            # \u8d70\u4e86k + 1\u6b65\u8ddd\u79bb\u5c31\u662f2 ** k - 1\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u5df2\u7ecf\u8d85\u8d8a\u4e86t\n            # \u6240\u4ee5\u8fd8\u8981\u7ee7\u7eed\u8d702 ** k - 1 - t\u6b65\u624d\u80fd\u8d70\u5230t\n            if 2 ** k - 1 - t > 0:\n                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)\n        return dp[target]\n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        a,d,m,s=[(0,1)],set([(0,1)]),2*target,0\n        while 1:\n            b,s=[],s+1\n            for i,j in a:\n                ii,jj,k=i+j,2*j,-1 if j>0 else 1\n                if ii==target: return s\n                if (ii,jj) not in d and 0<ii<m:\n                    b.append((ii,jj))\n                    d.add((ii,jj))\n                if (i,k) not in d:\n                    b.append((i,k))\n                    d.add((i,k))\n            a=b", "class Solution:\n    def __init__(self):\n        self._dp = {0:0}\n\n    def racecar(self, target):\n        # \u8f66\u5b50\u521d\u59cb\u4f4d\u7f6e0\uff0c\u901f\u5ea61\n        # \u9047\u5230A\uff0cposition += speed\u5e76\u4e14speed *= 2\n        # \u9047\u5230R\uff0cspeed = -1\u5982\u679c\u5f53\u524dspeed\u662f1\uff1bspeed = 1\u5982\u679c\n        # \u7ed9\u5b9a\u6700\u7ec8\u7684\u4f4d\u7f6etarget\uff0c\u95ee\u6700\u77ed\u7684sequence\uff08\u7531A\u548cR\u7ec4\u6210\uff09\u80fd\u591f\u5230\u8fbetarget\n        # dp = [0, 1, 4] + [2 ** 31 - 1] * target\n        if target == 0:\n            return 0\n        if target == 1:\n            return 1\n        if target == 2:\n            return 4\n        dp = [2 ** 31 - 1] * (target + 1)\n        dp[0], dp[1], dp[2] = 0, 1, 4\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2 ** k - 1:\n                dp[t] = k\n                continue\n            \n            # \u60c5\u51b51\uff1a\u8d702 ** (k - 1)\u7684\u8ddd\u79bb\n            # \u7136\u540e\u7528\u4e00\u4e2aR\u548cm\u4e2aA\u53bb\u5f80\u56de\u8d70\n            # \u8fd9\u65f6\u5019\u5df2\u7ecf\u8d70\u4e86(k - 1) + 1 + (m - 1) + 1 + 2\u6b65\uff08\u5373A**(k - 1)RA**(m - 1)R\n            # \u7136\u540e\u53bbdp\u91cc\u627e\u5269\u4f59\u7684\u6b65\u6570t - 2 ** (k - 1) + 2 ** m\n            for m in range(k - 1):\n                # \u6ce8\u610f\uff1a\u540e\u9762\u7684k - 1 + j + 2\u662f\u5f53\u524d\u8d70\u4e86\u8fd9\u4e48\u591a\u6b65\n                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** m] + k - 1 + m + 2)\n            \n            # \u60c5\u51b52\uff1a\u76f4\u63a52 ** k\u6b65\uff08\u5df2\u7ecf\u8d70\u4e86\u6700\u5927\u7684k + 1\u6b65, \u5c31\u662f\u5728\u6700\u540emin\u51fd\u6570\u62ec\u53f7\u91cc\u52a0\u7684\u90a3\u4e00\u90e8\u5206\uff0c\u52a01\u662f\u6307\u4e00\u4e2aR\uff09\uff0c\u7136\u540e\u518d\u5f80\u56de\u8d70\n            # \u8d70\u4e86k + 1\u6b65\u8ddd\u79bb\u5c31\u662f2 ** k - 1\uff0c\u8fd9\u4e2a\u8ddd\u79bb\u5df2\u7ecf\u8d85\u8d8a\u4e86t\n            # \u6240\u4ee5\u8fd8\u8981\u7ee7\u7eed\u8d702 ** k - 1 - t\u6b65\u624d\u80fd\u8d70\u5230t\n            if 2 ** k - 1 - t > 0:\n                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)\n        return dp[target]\n        \n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0,1)]) # start with pos 0, speed 1\n        visited = set((0,1))\n        level = 0\n        while queue:\n          num = len(queue)\n          for _ in range(num):\n            cur_pos, cur_speed = queue.popleft()\n            if cur_pos == target:\n              return level\n            # accelerate instruction\n            nex_acc = (cur_pos + cur_speed, cur_speed*2)\n            if nex_acc not in visited and 0 < nex_acc[0] < target*2:\n              queue.append(nex_acc)\n              visited.add(nex_acc)\n            nex_rev = (cur_pos, -1 if cur_speed > 0 else 1)\n            if nex_rev not in visited and 0 < nex_rev[0] < target*2:\n              queue.append(nex_rev)\n              visited.add(nex_rev)\n          level += 1\n        return -1\n              \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1)])\n        visited = set([(0, 1)])\n        \n        step = 0\n        while q:\n            l = len(q)\n            step += 1\n            for _ in range(l):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return step - 1\n                new_pos, new_speed = pos + speed, speed * 2\n                if (new_pos, new_speed) not in visited and 0 < new_pos <= target * 2:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n                \n                new_pos, new_speed = pos, -1 if speed > 0 else 1\n                if (new_pos, new_speed) not in visited and 0 < new_pos <= target * 2:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        if target == 0:\n            return 0        \n        # BFS solution\n        level = 0\n        q = deque([(0, 1)]) # tuple of (pos, speed)\n        visited = {(0, 1),}\n        while q:\n            length = len(q)\n            for _ in range(length):\n                p, s = q.popleft()\n                # use A\n                new_p, new_s = p + s, 2*s\n                if new_p == target:\n                    return level + 1\n                if 0 < new_p < 2* target and (new_p, new_s) not in visited:\n                    visited.add((new_p, new_s))\n                    q.append((new_p, new_s))\n                # use R\n                new_p, new_s = p, -s//abs(s)\n                if 0 < new_p < 2* target and (new_p, new_s) not in visited:\n                    visited.add((new_p, new_s))\n                    q.append((new_p, new_s))\n            level += 1", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0, 1, 4] + [float('inf')] * target\n        for t in range(3, target + 1):\n            k = t.bit_length()\n            if t == 2**k - 1:\n                dp[t] = k\n                continue\n            for j in range(k - 1):\n                dp[t] = min(dp[t], dp[t - 2**(k - 1) + 2**j] + k - 1 + j + 2)\n            if 2**k - 1 - t < t:\n                dp[t] = min(dp[t], dp[2**k - 1 - t] + k + 1)\n        return dp[target]\n    \n#         f = [None] * (target + 1)\n        \n#         f[0] = 0\n        \n#         for i in range(1, target + 1):\n#             f[i] = float('inf')\n            \n#             n = len(bin(i)[2:])\n            \n#             if 2**n - 1 == i:\n#                 f[i] = n\n#                 continue\n                \n#             # overspeed\n#             f[i] = f[2**n - 1 - i] + n + 1 # reverse once\n            \n#             # underspeed\n#             for j in range(0, n):\n#                 gap = 1 << j - 1\n#                 f[i] = min(f[i], f[i - 2**(n - 1) + gap] + n + j + 1) # reverse twice\n#         return f[target]\n            \n        \n        \n#         int[] f = new int[target + 1];\n#         for (int i = 1; i <= target; i++){\n#             int bound = (Integer.highestOneBit(i) << 1) - 1;\n#             int n = Integer.bitCount(bound);\n#             if (i == bound){\n#                 f[i] = n;\n#                 continue;\n#             }\n#             // overspeed\n#             f[i] = f[bound - i] + n + 1; // Reverse once\n#             // underspeed\n#             bound >>= 1;\n#             for (int j = 0; j < n; j++){\n#                 int gap = (1 << j) - 1;\n#                 f[i] = Math.min(f[i], f[i - bound + gap] + n + j + 1); // Reverse twice\n#             }\n#         }\n#         return f[target];\n#     }\n# }\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = deque([(0, 1)])\n        visited = set([(0, 1)])\n        upper = target * 2\n        \n        step = 0\n        while q:\n            l = len(q)\n            step += 1\n            for _ in range(l):\n                pos, speed = q.popleft()\n                if pos == target:\n                    return step - 1\n                new_pos, new_speed = pos + speed, speed * 2\n                if (new_pos, new_speed) not in visited and 0 < new_pos <= upper:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n                \n                new_pos, new_speed = pos, -1 if speed > 0 else 1\n                if (new_pos, new_speed) not in visited and 0 < new_pos <= upper:\n                    q.append((new_pos, new_speed))\n                    visited.add((new_pos, new_speed))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = collections.deque([(1, 0)])\n        visited = set(queue)\n        count = 0\n        while queue:\n            for _ in range(len(queue)):\n                speed, pos = queue.popleft()\n                if pos < 0:\n                    continue\n                if pos > 2*target:\n                    continue\n                \n                if target == pos:\n                    return count\n                \n                if (speed*2, pos+speed) not in visited:\n                    visited.add((speed*2, pos+speed))\n                    queue.append((speed*2, pos+speed))\n                \n                if speed > 0:\n                    if (-1, pos) not in visited:\n                        visited.add((-1, pos))\n                        queue.append((-1, pos))\n                else:\n                    if (1, pos) not in visited:\n                        visited.add((1, pos))\n                        queue.append((1, pos))\n            count += 1\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = collections.deque()\n        visited = set()\n        queue.append((0, 1, 0))\n        visited.add((0, 1))\n        \n        while queue:\n            pos, speed, steps = queue.popleft()\n            if pos == target:\n                return steps\n            \n            next_pos = pos + speed\n            next_speed = speed * 2\n            if (next_pos, next_speed) not in visited and next_pos < 2 * target and next_pos > 0:\n                queue.append((next_pos, next_speed, steps + 1))\n                visited.add((next_pos, next_speed))\n            \n            next_pos = pos\n            next_speed = -1 if speed > 0 else 1\n            if (next_pos, next_speed) not in visited and next_pos < 2 * target and next_pos > 0:\n                queue.append((next_pos, next_speed, steps + 1))\n                visited.add((next_pos, next_speed))\n        \n        return -1\n", "from collections import *\n\nclass Solution:\n    def racecar(self, t: int) -> int:\n        q, s, lvl = deque([(0, 1)]), set([(0, 1)]), 0\n        \n        while q:\n            for _ in range(len(q)):\n                pu, su = q.popleft()\n                \n                if pu == t:\n                    return lvl\n            \n                a, r = (pu + su, su * 2), (pu, -1 if su > 0 else 1)\n                for e in (a, r):\n                    \n                    if e in s or  e[0] < 0 or e[0] >= t * 2:\n                        continue\n                    q.append(e)\n                    s.add(e)\n            lvl += 1\n            \n        return 0\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        # 0 -> 1 -> 3 -> 7 - > 15\n        # 1 -> 2 -> 4 -> 8 -> 16\n        # \u4ece 0 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5 R \u6216 A\u4e24\u4e2a\u65b9\u5411\uff0c\u9009\u62e9\u3002\n        # \u53ef\u4ee5\u8bb0\u5f55\u6bcf\u6b21\u5230\u8fbe\u7684\u72b6\u6001\uff0c\n        # BFS\n        \n        d = deque([(0, 0, 1)])\n        visited = collections.defaultdict(set)\n        visited[0].add(1)\n        ans = float('inf')\n        flag = 0\n        while d:\n            flag += 1\n            # print(\\\"flag=\\\", flag,\\\", d=\\\", d)\n            l = len(d)\n            while l:\n                l -= 1\n                cur = d.popleft()\n                # print(\\\"cur=\\\", cur)\n                pos, cost, speed = cur\n                if pos == target:\n                    ans = min(ans, cost)\n                    # continue\n                    return cost\n                # use R\n                cost += 1\n                if 1:\n                    newspeed = -1 if speed > 0 else 1\n                    if not ((pos in visited and newspeed in visited[pos]) or (pos <= 0)):\n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos, cost, -1))\n                        d.append(((pos, cost, newspeed)))\n                        visited[pos].add(newspeed)\n                        # \u8fd9\u91cc if \u91cc break \u4e0d\u8981\u778e\u7528\uff0c\u4f1a\u8df3\u51fa while l \u8fd9\u4e2a\u5faa\u73af\u7684\u3002\n                # use A\n                if 1:\n                    if not (( speed in visited and (cost, speed * 2) in visited[pos]) or (pos + speed > target * 2) or (pos + speed <= 0)):\n                        \n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos + speed, cost, speed * 2))\n                        d.append((pos + speed, cost, speed * 2))\n                        visited[pos].add(speed * 2)\n        return\n                \n  # BFS \u641e\u4e86\u534a\u5929\uff0c\u7ec8\u4e8e\u7ed3\u675f\u4e86\u3002\u6ce8\u610f\u8981\u526a\u679d\u3002\n# 1. \u9996\u5148 visited \u52a0\u5165\u7684\u662f pos \u548c speed\u3002\n# 2. \u7b2c\u4e8c\u662f \u4f4d\u7f6e\u4e0d\u80fd\u8d85\u8fc7 target * 2\n# 3. \u901f\u5ea6\u4e0d\u80fd\u8d85\u8fc7 2*target\u3002  \uff08\u53ef\u4ee5\u4e0d\u8981\uff09\n# 4. \u4e0d\u8981 pos <0 \u7684\u4f4d\u7f6e\u3002\n        # pos    0 1 3 2 3\n        # speed  1 2 -1 1\n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        visited = set()\n        \n        q = deque([(0,1,0)])\n        while q:\n            pos, sp, d = q.popleft()\n            #print(pos, q)\n            if pos==target:\n                return d\n\n            if pos<-1 or pos>1.5*target or sp>1.5*target or (pos, sp) in visited:\n                continue\n            visited.add((pos, sp))\n\n            q.append((pos+sp, sp*2, d+1))\n            q.append((pos, -1*(sp//abs(sp)), d+1))\n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0, 1)])\n        visited = set([(0, 1)])\n        step = 0\n        while queue:\n            level_size = len(queue)\n            # print(queue)\n            for _ in range(level_size):\n                posi, spd = queue.popleft()\n                if posi == target:\n                    return step \n                if ((posi+spd, 2*spd) not in visited) and posi+spd>0 and posi+spd < target<<1:\n                    queue.append((posi+spd, 2*spd))\n                    visited.add((posi+spd, 2*spd))\n                sign = 1 if spd > 0 else -1 \n                if ((posi, -sign) not in visited) and posi >0 and posi < target<<1:\n                    queue.append((posi, -sign))\n                    visited.add((posi, -sign))\n            step += 1 \n        return -1 ", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        visited = set()\n        \n        q = deque([(0,1,0)])\n        while q:\n            pos, sp, d = q.popleft()\n            #print(pos, q)\n            if pos==target:\n                return d\n\n            if (pos, sp) in visited:\n                continue\n            visited.add((pos, sp))\n            \n            if abs(sp)>target or pos<0:\n                # in these cases, must turn.\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n            else:\n                # can keep goint or turn.\n                q.append((pos+sp, sp*2, d+1))\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        # 0 -> 1 -> 3 -> 7 - > 15\n        # 1 -> 2 -> 4 -> 8 -> 16\n        # \u4ece 0 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5 R \u6216 A\u4e24\u4e2a\u65b9\u5411\uff0c\u9009\u62e9\u3002\n        # \u53ef\u4ee5\u8bb0\u5f55\u6bcf\u6b21\u5230\u8fbe\u7684\u72b6\u6001\uff0c\n        # BFS\n        \n        d = deque([(0, 0, 1)])\n        visited = collections.defaultdict(set)\n        visited[0].add(1)\n        ans = float('inf')\n        flag = 0\n        while d:\n            flag += 1\n            # print(\\\"flag=\\\", flag,\\\", d=\\\", d)\n            l = len(d)\n            while l:\n                l -= 1\n                cur = d.popleft()\n                # print(\\\"cur=\\\", cur)\n                pos, cost, speed = cur\n                if pos == target:\n                    ans = min(ans, cost)\n                    # continue\n                    return cost\n                # use R\n                cost += 1\n                if 1:\n                    newspeed = -1 if speed > 0 else 1\n                    if not ((pos in visited and newspeed in visited[pos]) or (pos <= 0)):\n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos, cost, -1))\n                        d.append(((pos, cost, newspeed)))\n                        visited[pos].add(newspeed)\n                        # \u8fd9\u91cc if \u91cc break \u4e0d\u8981\u778e\u7528\uff0c\u4f1a\u8df3\u51fa while l \u8fd9\u4e2a\u5faa\u73af\u7684\u3002\n                # use A\n                if 1:\n                    if not (( speed in visited and (cost, speed * 2) in visited[pos]) or (pos + speed > target * 2) or (pos + speed <= 0) or (speed > 2*target)):\n                        \n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos + speed, cost, speed * 2))\n                        d.append((pos + speed, cost, speed * 2))\n                        visited[pos].add(speed * 2)\n        return\n                \n        \n        # pos    0 1 3 2 3\n        # speed  1 2 -1 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        # 0 -> 1 -> 3 -> 7 - > 15\n        # 1 -> 2 -> 4 -> 8 -> 16\n        # \u4ece 0 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5 R \u6216 A\u4e24\u4e2a\u65b9\u5411\uff0c\u9009\u62e9\u3002\n        # \u53ef\u4ee5\u8bb0\u5f55\u6bcf\u6b21\u5230\u8fbe\u7684\u72b6\u6001\uff0c\n        # BFS\n        \n        d = deque([(0, 0, 1)])\n        visited = collections.defaultdict(set)\n        visited[0].add(1)\n        ans = float('inf')\n        flag = 0\n        while d:\n            flag += 1\n            # print(\\\"flag=\\\", flag,\\\", d=\\\", d)\n            l = len(d)\n            while l:\n                l -= 1\n                cur = d.popleft()\n                # print(\\\"cur=\\\", cur)\n                pos, cost, speed = cur\n                if pos == target:\n                    ans = min(ans, cost)\n                    # continue\n                    return cost\n                # use R\n                cost += 1\n                if 1:\n                    newspeed = -1 if speed > 0 else 1\n                    if not ((pos in visited and newspeed in visited[pos]) or (pos <= 0)):\n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos, cost, -1))\n                        d.append(((pos, cost, newspeed)))\n                        visited[pos].add(newspeed)\n                        # \u8fd9\u91cc if \u91cc break \u4e0d\u8981\u778e\u7528\uff0c\u4f1a\u8df3\u51fa while l \u8fd9\u4e2a\u5faa\u73af\u7684\u3002\n                # use A\n                if 1:\n                    if not (( speed in visited and (cost, speed * 2) in visited[pos]) or (pos + speed > target * 2) or (pos + speed <= 0)):\n                        \n                        # print(\\\"past=\\\", cur,\\\", add=\\\", (pos + speed, cost, speed * 2))\n                        d.append((pos + speed, cost, speed * 2))\n                        visited[pos].add(speed * 2)\n        return\n                \n  # BFS \u641e\u4e86\u534a\u5929\uff0c\u7ec8\u4e8e\u7ed3\u675f\u4e86\u3002\u6ce8\u610f\u8981\u526a\u679d\u3002\n# 1. \u9996\u5148 visited \u52a0\u5165\u7684\u662f pos \u548c speed\u3002\n# 2. \u7b2c\u4e8c\u662f \u4f4d\u7f6e\u4e0d\u80fd\u8d85\u8fc7 target * 2\n# 3. \u901f\u5ea6\u4e0d\u80fd\u8d85\u8fc7 2*target\u3002 \n# 4. \u4e0d\u8981 pos <0 \u7684\u4f4d\u7f6e\u3002\n        # pos    0 1 3 2 3\n        # speed  1 2 -1 1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dq = collections.deque([(0, 1)])\n        seen = set([(0,1)])\n        depth = 0\n        \n        while True:\n            k = len(dq)\n            while k:\n                (pos, velo) = dq.popleft()\n                if pos == target:\n                    return depth\n                \n                cand = [(pos, -1 if velo>0 else 1)]\n                if abs(target- (pos+velo)) < target:\n                    cand.append((pos+velo, velo*2))\n                \n                for (p, v) in cand:\n                    if (p, v) not in seen:\n                        seen.add((p,v))\n                        dq.append((p,v))    \n                k-=1\n                \n            depth+=1 \n            \n        \n                \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0,1)])\n        visited=set()\n        visited.add((0,1))\n        step = 0\n        while queue:\n            for _ in range(len(queue)):\n                pos, speed = queue.popleft()\n                if pos+speed==target:\n                    return step+1\n                if abs(speed*2)<2*target and abs(pos+speed)<2*target:\n                    queue.append((pos+speed,speed*2))\n                if speed>0:\n                    speed2=-1\n                else:\n                    speed2=1\n                if (pos,speed2) not in visited:\n                    queue.append((pos,speed2))\n                    visited.add((pos,speed2))\n            step+=1\n        return -1\n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        visited = set()\n        \n        q = deque([(0,1,0)])\n        while q:\n            pos, sp, d = q.popleft()\n            #print(pos, q)\n            if pos==target:\n                return d\n\n            if pos<-1 or pos>2*target or sp>2*target or (pos, sp) in visited:\n                continue\n            visited.add((pos, sp))\n\n            q.append((pos+sp, sp*2, d+1))\n            q.append((pos, -1*(sp//abs(sp)), d+1))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        queue = deque([(0,1)])\n        visited=set()\n        visited.add((0,1))\n        step = 0\n        while queue:\n            for _ in range(len(queue)):\n                pos, speed = queue.popleft()\n                if pos+speed==target:\n                    return step+1\n                if abs(speed*2)-1<2*target and abs(pos+speed)-2<2*target:\n                    queue.append((pos+speed,speed*2))\n                if speed>0:\n                    speed2=-1\n                else:\n                    speed2=1\n                if (pos,speed2) not in visited:\n                    queue.append((pos,speed2))\n                    visited.add((pos,speed2))\n            step+=1\n        return -1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        q = collections.deque([(0, 1, 0)])\n        visited = set()\n        visited.add((0,1))\n\n        while q:\n            size = len(q)\n            for _ in range(size):\n                pos, speed, steps = q.popleft()\n                if pos == target:\n                    return steps\n\n                cand = []\n                if abs(target - (pos + speed)) < target:\n                    cand.append((pos + speed, 2 * speed))\n                cand.append([pos, 1 if speed < 0 else -1])\n                for pos, speed in cand:\n                    if (pos, speed) not in visited:\n                        q.append((pos, speed, steps + 1))\n                        visited.add((pos, speed))\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        def dfs(t):\n            if t in dp:\n                return dp[t]\n            n = t.bit_length()\n            if 2**n - 1 == t:\n                dp[t] = n\n            else:\n                dp[t] = dfs(2**n - 1 - t) + n + 1\n                for m in range(n - 1):\n                    dp[t] = min(dp[t], dfs(t - 2**(n - 1) + 2**m) + n + m + 1)\n            return dp[t]\n        \n        dp = {0:0}\n        return dfs(target)", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        visited = set()\n        \n        q = deque([(0,1,0)])\n        while q:\n            pos, sp, d = q.popleft()\n            #print(pos, q)\n            if pos==target:\n                return d\n\n            if (pos, sp) in visited:\n                continue\n            visited.add((pos, sp))\n            \n            if abs(sp)>target or pos<-1:\n                # in these cases, must turn.\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n            else:\n                # can keep goint or turn.\n                q.append((pos+sp, sp*2, d+1))\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        states = set([(0, 1)])\n        que = collections.deque([[0, 1]])\n        cost = 0\n        while que:\n            for _ in range(len(que)):\n                pos, speed = que.popleft()\n                if pos == target:\n                    return cost\n                #if abs(pos) >= 2 * target:\n                #    continue\n                if pos < 0 or pos >= 2 * target:\n                    continue\n                for npos, nspeed in [[pos, 1 if speed < 0 else -1], [pos + speed, speed * 2]]:\n                    if (npos, nspeed) not in states:\n                        states.add((npos, nspeed))\n                        que.append([npos, nspeed])\n            cost += 1\n        return -1\n\n    dp = {0: 0}\n    def racecar_DP(self, t):\n        if t in self.dp:\n            return self.dp[t]\n        n = t.bit_length()\n        if (1 << n) - 1 == t:\n            self.dp[t] = n\n        else:\n            self.dp[t] = self.racecar(2**n - 1 - t) + n + 1\n            for m in range(n - 1):\n                self.dp[t] = min(self.dp[t], self.racecar(t - 2**(n - 1) + 2**m) + n + m + 1)\n        return self.dp[t]", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        targetLen = len(bin(target)) - 2\n        barrier = (1 << targetLen)\n        # print(tar6021getLen, barrier)\n        stack = [(0, target)]\n        dp = {target:0}\n        \n        while stack:\n            # print(stack)\n            step0, dist = heapq.heappop(stack)\n            \n            for i in range(targetLen+1):\n                move = (1<<i)-1\n                step1 = step0 + i\n                if move != dist:\n                    step1 += 1\n                newDist = -(dist - move)\n                if abs(newDist) <= barrier and (newDist not in dp or dp[newDist] > step1):\n                    heapq.heappush(stack, (step1, newDist))\n                    dp[newDist] = step1\n                    \n        return dp[0]\n                \n                \n        \n        \n#         stack = [(0, 0, 1)]\n#         visited = {(0,1):0}\n        \n#         while stack:\n#             stepNow, loc, speed = heapq.heappop(stack)\n#             if visited[(loc, speed)] < stepNow:\n#                 continue\n            \n#             loc1 = loc+speed\n#             speed1 = speed*2\n#             if loc1 == target:\n#                 return stepNow + 1\n#             if (loc1, speed1) not in visited or visited[(loc1, speed1)] > stepNow+1:\n#                 visited[(loc1, speed1)] = stepNow + 1\n#                 heapq.heappush(stack, (stepNow +1, loc1, speed1))\n            \n            \n#             loc1 = loc\n#             speed1 = -1 if speed > 0 else 1\n#             if (loc1, speed1) not in visited or visited[(loc1, speed1)] > stepNow+1:\n#                 visited[(loc1, speed1)] = stepNow + 1\n#                 heapq.heappush(stack, (stepNow +1, loc1, speed1))\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0] * (target+1)\n        for i in range(1, target+1):\n            dp[i] = float('inf')           \n            j = 1\n            m = 1\n            while j < i:\n                p = 0\n                q = 0\n                while q < j:\n                    dp[i] = min(dp[i], dp[i-(j-q)] + m + 1 + p + 1)\n                    p += 1\n                    q = (1<<p) - 1\n                m += 1\n                j = (1<<m) - 1\n            dp[i] = min(dp[i], m if j == i else m + 1 + dp[j-i])\n        return dp[target]\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        dp = [0] * (target+1)\n        for i in range(1, target+1):\n            dp[i] = float('inf')           \n            j = 1\n            m = 1\n            while j < i:\n                p = 0\n                q = 0\n                while q < j:\n                    dp[i] = min(dp[i], dp[i-(j-q)] + m + 1 + p + 1)\n                    p += 1\n                    q = (1<<p) - 1\n                m += 1\n                #print('j', m>>1-1, m, (m<<1) - 1)\n                j = (1<<m) - 1\n            #print(i, j)\n            # if i == 6:\n            #     print(m, dp[j-1])\n            dp[i] = min(dp[i], m if j == i else m + 1 + dp[j-i])\n        return dp[target]\n", "class Solution:\n    def racecar(self, tgt: int) -> int:\n        \n        '''\n            shortest path -> bfs\n        \n            starting from [0, 1], how to reach tgt = 5?\n            \n                [0, 1] -> [1, 2], [0, -1]\n                \n                    [1, 2] -> [3, 4], [1, -1]\n                    [0, -1] ->[-1, -2], [0, 1] ... visited\n                    \n                    \n                        [3, 4] -> [3, -1], [7, 8]\n                        [1,-1] -> [0, -2], [1, 1]\n                        [-1,-2]-> [-3,-4] ... too far, [-1,1]\n                        \n                        \n                            [3, -1] -> [2, -2], [3, 1]\n                            [7,  8] ... too far\n                            [0, -2] -> [-2, -4] ... too far, [0, 1] ... visited\n                            [1,  1] -> [2, 2], [1, -1] ...visited\n                            [-1 ,1] -> [0, 2], [-1, -1] ... too far\n                            \n                            \n                                [2, -2] -> [0, -4], [2, 1]\n                                [3,  1] -> [4,  2], [3, -1] ... visited\n                                [2,  2] -> [4,  4], [2, -1]\n                                [0,  2] -> [2,  4], [0, -1] ... visited\n                                \n                                    [0, -4] -> [-4, -8] ... too far, [0, 1] ... visited\n                                    [2,  1] -> [3,   2], [2, -1]\n                                    [4,  2] -> [6,   4], [4, -1]\n                                    [4,  4] -> [8,   8], [4, -1] ... in queue\n                                    [2, -1] -> [1,  -2], [2,  1] ... visited\n                                    [2,  4] -> [6,   8], [2, -1] ... visited\n                                    \n                                \n                                        [3, 2] -> [5 , 4]  -->> arrived\n                                        \n                                        -> 7 steps                                    \n        '''\n        \n        '''\n            1. try greedy -> can't pass tgt = 5\n            \n            2. list out all the step until reach the tgt\n            \n            3. speed up -> dont visit same nodes, dont go to \\\"too far\\\" nodes        \n        '''    \n        \n        visited = dict()        \n        q = collections.deque()        \n        \n        q.append([0, 1])        \n        visited[0] = set()\n        visited[0].add(1)\n        \n        step = 0\n        while len(q) > 0:\n            \n            curSize = len(q)           \n            \n            for i in range(0, curSize):                \n                \n                pop = q.pop()\n                pos, spd = pop[0], pop[1]\n                \n                if pos == tgt:\n                    return step\n                                                                                \n                nextSteps = [ [pos + spd, spd * 2], [pos, - 1 * spd // abs(spd)] ]\n                for nextStep in nextSteps:            \n                    \n                    nPos, nSpd = nextStep[0], nextStep[1]\n                    \n                    # check is too far node:\n                    if abs(nPos - tgt) <= tgt:                        \n                        # check visited\n                        if nPos not in visited or nSpd not in visited[nPos]:\n                            q.appendleft(nextStep)\n                            if nPos not in visited:\n                                visited[nPos] = set()\n                            \n                            visited[nPos].add(nSpd)\n                            \n            step += 1\n            \n            \n        return -1\n            \n                    \n                    \n                    \n                \n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        def dfs(distance):\n            if distance in dp:\n                return dp[distance]\n            position, speed, counter = 0, 1, 0\n            res = float('inf')\n            arr = [(0)]\n            while position < distance:\n                position, speed, counter = position + speed, speed*2, counter+1\n                if position < distance:\n                    for x in arr:\n                        res = min(res, counter + 2 + dfs(distance - position + x) + dp[x])\n                else:\n                    res = min(res, counter + 1 + dfs(position - distance))\n                arr.append(position)\n            dp[distance] = res\n            return res\n        \n        position, speed, counter = 0, 1, 0\n        dp = {0:0}\n        \n        while position < target:\n            position, speed, counter = position + speed, speed*2, counter+1\n            dp[position] = counter\n        return dfs(target)", "class Solution:\n\n    def racecar(self, tgt: int) -> int:\n        \n        '''\n            shortest path -> bfs\n        \n            starting from [0, 1], how to reach tgt = 5?\n            \n                [0, 1] -> [1, 2], [0, -1]\n                \n                    [1, 2] -> [3, 4], [1, -1]\n                    [0, -1] ->[-1, -2], [0, 1] ... visited\n                    \n                    \n                        [3, 4] -> [3, -1], [7, 8]\n                        [1,-1] -> [0, -2], [1, 1]\n                        [-1,-2]-> [-3,-4] ... too far, [-1,1]\n                        \n                        \n                            [3, -1] -> [2, -2], [3, 1]\n                            [7,  8] ... too far\n                            [0, -2] -> [-2, -4] ... too far, [0, 1] ... visited\n                            [1,  1] -> [2, 2], [1, -1] ...visited\n                            [-1 ,1] -> [0, 2], [-1, -1] ... too far\n                            \n                            \n                                [2, -2] -> [0, -4], [2, 1]\n                                [3,  1] -> [4,  2], [3, -1] ... visited\n                                [2,  2] -> [4,  4], [2, -1]\n                                [0,  2] -> [2,  4], [0, -1] ... visited\n                                \n                                    [0, -4] -> [-4, -8] ... too far, [0, 1] ... visited\n                                    [2,  1] -> [3,   2], [2, -1]\n                                    [4,  2] -> [6,   4], [4, -1]\n                                    [4,  4] -> [8,   8], [4, -1] ... in queue\n                                    [2, -1] -> [1,  -2], [2,  1] ... visited\n                                    [2,  4] -> [6,   8], [2, -1] ... visited\n                                    \n                                \n                                        [3, 2] -> [5 , 4]  -->> arrived\n                                        \n                                        -> 7 steps                                    \n        '''\n        \n        '''\n            1. try greedy -> can't pass tgt = 5\n            \n            2. list out all the step until reach the tgt -> time: O(2 ^ (num of operations) )\n            \n            3. speed up -> dont visit same nodes, dont go to \\\"too far\\\" nodes    \n                        \n            4. time complexity: \n                pos range: -tgt ~ tgt, spd range: 1 ~ log(tgt) -> graph node number will be 2 * tgt * log(tgt) -> O(tgt * log(tgt) )\n                                                \n        '''    \n        \n        visited = dict()        \n        q = collections.deque()        \n        \n        q.append([0, 1])        \n        visited[0] = set()\n        visited[0].add(1)\n        \n        step = 0\n        while len(q) > 0:\n            \n            curSize = len(q)           \n            \n            for i in range(0, curSize):                \n                \n                pop = q.pop()\n                pos, spd = pop[0], pop[1]\n                \n                if pos == tgt:\n                    return step\n                                                                                \n                nextSteps = [ [pos + spd, spd * 2], [pos, - 1 * spd // abs(spd)] ]\n                for nextStep in nextSteps:            \n                    \n                    nPos, nSpd = nextStep[0], nextStep[1]\n                    \n                    # check is too far node:\n                    if abs(nPos - tgt) <= tgt:                        \n                        # check visited\n                        if nPos not in visited or nSpd not in visited[nPos]:\n                            q.appendleft(nextStep)\n                            if nPos not in visited:\n                                visited[nPos] = set()\n                            \n                            visited[nPos].add(nSpd)\n                            \n            step += 1\n            \n            \n        return -1\n            \n                    \n                    \n                    \n                \n            \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        # position speed\n        queue = [(0,1)]\n        visited = set((0,1))\n        step = 0\n        q = 0\n        \n        while len(queue) >q:\n            step+=1\n            size = len(queue)-q\n            for _ in range(size):\n                x,v = queue[q]\n                q+=1\n                \n                \n                ### keep on\n                x_ = x+v\n                v_ = v*2\n                if (x_, v_) not in visited and abs(x_)<2*target :\n                    queue.append((x_,v_))\n                    visited.add((x_,v_))\n                    \n                    if x_ == target:\n                        return step\n                \n\n                #### turn\n                x_  = x\n                if v>0:\n                    v_ = -1\n                else:\n                    v_ = 1\n                if (x_, v_) not in visited and abs(x_)<2*target :\n                    queue.append((x_,v_))\n                    visited.add((x_,v_))\n                    \n                    if x_ == target:\n                        return step\n        \n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        \n        # position speed\n        queue = [(0,1)]\n        visited = set((0,1))\n        step = 0\n        q = 0\n        \n        while len(queue) >q:\n            step+=1\n            size = len(queue)-q\n            for _ in range(size):\n                x,v = queue[q]\n                q+=1\n                \n                ### keep on\n                x_ = x+v\n                v_ = v*2\n                # abs(x_)<2*target\u53ea\u662f\u52a0\u901f\uff0c\u4e0d\u5f71\u54cd\u7ed3\u679c\n                if (x_, v_) not in visited and abs(x_)<2*target :\n                    queue.append((x_,v_))\n                    visited.add((x_,v_))\n                    \n                    if x_ == target:\n                        return step\n                \n\n                #### turn\n                x_  = x\n                if v>0:\n                    v_ = -1\n                else:\n                    v_ = 1\n                # abs(x_)<2*target\u53ea\u662f\u52a0\u901f\uff0c\u4e0d\u5f71\u54cd\u7ed3\u679c\n                if (x_, v_) not in visited and abs(x_)<2*target :\n                    queue.append((x_,v_))\n                    visited.add((x_,v_))\n                    \n                    if x_ == target:\n                        return step\n        \n        \n", "class Solution:\n\n    def racecar(self, tgt: int) -> int:\n        \n        '''\n            shortest path -> bfs\n        \n            starting from [0, 1], how to reach tgt = 5?\n            \n                [0, 1] -> [1, 2], [0, -1]\n                \n                    [1, 2] -> [3, 4], [1, -1]\n                    [0, -1] ->[-1, -2], [0, 1] ... visited\n                    \n                    \n                        [3, 4] -> [3, -1], [7, 8]\n                        [1,-1] -> [0, -2], [1, 1]\n                        [-1,-2]-> [-3,-4] ... too far, [-1,1]\n                        \n                        \n                            [3, -1] -> [2, -2], [3, 1]\n                            [7,  8] ... too far\n                            [0, -2] -> [-2, -4] ... too far, [0, 1] ... visited\n                            [1,  1] -> [2, 2], [1, -1] ...visited\n                            [-1 ,1] -> [0, 2], [-1, -1] ... too far\n                            \n                            \n                                [2, -2] -> [0, -4], [2, 1]\n                                [3,  1] -> [4,  2], [3, -1] ... visited\n                                [2,  2] -> [4,  4], [2, -1]\n                                [0,  2] -> [2,  4], [0, -1] ... visited\n                                \n                                    [0, -4] -> [-4, -8] ... too far, [0, 1] ... visited\n                                    [2,  1] -> [3,   2], [2, -1]\n                                    [4,  2] -> [6,   4], [4, -1]\n                                    [4,  4] -> [8,   8], [4, -1] ... in queue\n                                    [2, -1] -> [1,  -2], [2,  1] ... visited\n                                    [2,  4] -> [6,   8], [2, -1] ... visited\n                                    \n                                \n                                        [3, 2] -> [5 , 4]  -->> arrived\n                                        \n                                        -> 7 steps                                    \n        '''\n        \n        '''\n            1. try greedy -> can't pass tgt = 5\n            \n            2. list out all the step until reach the tgt -> time: O(2 ^ (num of operations) )\n            \n            3. speed up -> dont visit same nodes, dont go to \\\"too far\\\" nodes                        \n        '''    \n        \n        visited = dict()        \n        q = collections.deque()        \n        \n        q.append([0, 1])        \n        visited[0] = set()\n        visited[0].add(1)\n        \n        step = 0\n        while len(q) > 0:\n            \n            curSize = len(q)           \n            \n            for i in range(0, curSize):                \n                \n                pop = q.pop()\n                pos, spd = pop[0], pop[1]\n                \n                if pos == tgt:\n                    return step\n                                                                                \n                nextSteps = [ [pos + spd, spd * 2], [pos, - 1 * spd // abs(spd)] ]\n                for nextStep in nextSteps:            \n                    \n                    nPos, nSpd = nextStep[0], nextStep[1]\n                    \n                    # check is too far node:\n                    if abs(nPos - tgt) <= tgt:                        \n                        # check visited\n                        if nPos not in visited or nSpd not in visited[nPos]:\n                            q.appendleft(nextStep)\n                            if nPos not in visited:\n                                visited[nPos] = set()\n                            \n                            visited[nPos].add(nSpd)\n                            \n            step += 1\n            \n            \n        return -1\n            \n                    \n                    \n                    \n                \n            \n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        \n        steps = 0\n        queue = deque([(0, 1)])\n        cache = {(0,1)}\n        while queue:\n            for _ in range(len(queue)):\n                p, s = queue.popleft()\n                if p == target:\n                    return steps\n                p1,s1 = p+s, s*2\n                p2 = p\n                s2 = -1 if s > 0 else 1\n                \n                if -10000 <= p1 <= 10000 and (p1,s1) not in cache:\n                    cache.add((p1,s1))\n                    queue.append((p1,s1))\n                if -10000 <= p2 <= 10000 and  (p2,s2) not in cache:\n                    cache.add((p2,s2))\n                    queue.append((p2,s2))\n            steps += 1\n\n                \n            \n            \n", "from collections import deque\nclass Solution:\n    # def racecar(self, target: int) -> int:\n    #     # position, speed\n    #     queue = deque([(0,1)])\n    #     nsteps = -1\n    #     while queue:\n    #         levelSize = len(queue)\n    #         nsteps += 1\n    #         for _ in range(levelSize):\n    #             pos, speed = queue.popleft()\n    #             if pos == target:\n    #                 return nsteps\n    #             # Always consider moving the car in the direction it is already going\n    #             queue.append( (pos+speed, speed*2) )\n    #             # Only consider changing the direction of the car if one of the following conditions is true\n    #             if (pos>target and speed>0) or \\\\\n    #                (pos<target and speed<0) or \\\\\n    #                (pos+speed>target and speed>0) or \\\\\n    #                (pos+speed<target and speed<0):\n    #                 queue.append( (pos, -1 if speed>0 else 1) )\n    #     return nsteps\n    def __init__(self):\n        self.dp = {0: 0}\n    def racecar(self, t: int) -> int:\n        if t in self.dp:\n            return self.dp[t]\n\n        n = t.bit_length()\n        if 2**n - 1 == t:\n            self.dp[t] = n\n        else:\n            # go pass the target, stop and turn back\n            self.dp[t] = self.racecar(2**n-1-t) + n + 1\n            # Go as far as possible before pass target, stop and turn back\n            for m in range(n-1):\n                self.dp[t] = min(self.dp[t], self.racecar(t - 2**(n-1) + 1 + 2**m - 1) + (n - 1) + m + 2)\n        return self.dp[t]\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        been = set()\n        steps = 0\n        queue = {(target, 1)}\n        while queue:\n            print(len(queue))\n            newQueue = set()\n            for pos, speed in queue:\n                if pos == 0: return steps\n                been.add((pos, speed))\n                nextStatus = (abs(pos - speed), -speed * 2 if speed > pos else speed * 2)\n                if nextStatus[0] < target * 2 and nextStatus not in been:\n                    newQueue.add(nextStatus)\n                nextStatus = (pos, -1 if speed > 0 else 1)\n                if nextStatus[0] < target * 2 and nextStatus not in been:\n                    newQueue.add(nextStatus)\n            steps += 1\n            queue = newQueue", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length()+1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2*barrier + 1)\n        dist[target] = 0\n        \n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] < steps: continue\n            \n            for k in range(K+1):\n                walk = (1<<k)-1\n                steps2, targ2 = steps+k+1, walk - targ\n                if walk == targ: steps2 -= 1\n                \n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n        \n        return dist[0]\n            \n        \n        \n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] < steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]\n            \n        \n        \n        \n", "class Solution:\n    def racecar(self, t: int) -> int:\n        q=[(0,1,0)]\n        seen={}\n        while q:\n            c,s,step=q.pop(0)\n            if (c,s) in seen: continue\n            else: seen[(c,s)]=step\n\n            if c==t: return step\n            step+=1\n            \n            # A\n            c1=c+s\n            s1=s*2\n            if abs(c+s-t) < t and (c1,s1) not in seen:\n                q.append((c1,s1,step))\n            # R\n            s2=-1 if s>0 else 1\n            if abs(c-t) < t and (c,s2) not in seen:\n                q.append((c,s2,step))\n        return -1\n", "class Solution:\n    def racecar(self, target: int) -> int:\n        import heapq\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps:\n                continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ:\n                    steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]\n            \n        \n        \n        \n", "class Solution:\n    def racecar(self, target: int) -> int:\n        st = [(0, 1, '')]\n        visited = set()\n\n        while st:\n            a = st.pop(0)\n            if a[0] == target:\n                return len(a[2])\n            # put a 'A'\n            if 0 <= a[0] + a[1] < 2 * target and (a[0] + a[1], a[1] * 2) not in visited:\n                st.append((a[0] + a[1], a[1] * 2, a[2] + 'A'))\n                visited.add((a[0] + a[1], a[1] * 2))\n\n            # put a 'R'\n            if a[0] >= 0 and (a[0], -1 if a[1] > 0 else 1) not in visited:\n                st.append((a[0], -1 if a[1] > 0 else 1, a[2] + 'R'))\n                visited.add((a[0], -1 if a[1] > 0 else 1))\n\n        return -1", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            #if dist[targ] < steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]\n            \n        \n        \n        \n", "class Solution(object):\n    def racecar(self, target):\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target):\n        K = target.bit_length() + 1\n        barrier = 2**K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]\n            \n                    \n                    \n                \n                \n                \n            \n", "class Solution:\n    def racecar(self, target):\n        K = target.bit_length() + 1\n        barrier = 1 << K\n        pq = [(0, target)]\n        dist = [float('inf')] * (2 * barrier + 1)\n        dist[target] = 0\n\n        while pq:\n            steps, targ = heapq.heappop(pq)\n            if dist[targ] > steps: continue\n\n            for k in range(K+1):\n                walk = (1 << k) - 1\n                steps2, targ2 = steps + k + 1, walk - targ\n                if walk == targ: steps2 -= 1 #No \\\"R\\\" command if already exact\n\n                if abs(targ2) <= barrier and steps2 < dist[targ2]:\n                    heapq.heappush(pq, (steps2, targ2))\n                    dist[targ2] = steps2\n\n        return dist[0]", "class Solution:\n    def racecar(self, target: int) -> int:\n        boundary = 2*target+1\n        forw_stat = [target*3] * boundary\n        back_stat = [target*3] * boundary\n        actions = []\n        _s = 1\n        queue = []\n        while True:\n            _jump  = 2**_s - 1\n            if _jump >= boundary: break\n            actions.append((_jump, _s))  # jump, step\n            actions.append((-_jump, _s)) \n            queue.append((_s, _jump, 1))\n            forw_stat[_jump] = _s\n            _s += 1\n        # print(actions)\n        # --\n        import heapq\n        heapq.heapify(queue)\n        while len(queue)>0:\n            step, posi, is_forw = heapq.heappop(queue)\n            # --\n            for _jump, _step in actions:\n                if _jump * is_forw > 0:\n                    next_step, next_posi, next_is_forw = (step+_step+2, posi+_jump, is_forw)\n                else:\n                    next_step, next_posi, next_is_forw = (step+_step+1, posi+_jump, -is_forw)\n                # --\n                if next_posi<0 or next_posi>=boundary: continue\n                cur_stat = forw_stat if next_is_forw==1 else back_stat\n                if next_step < cur_stat[next_posi]:\n                    cur_stat[next_posi] = next_step\n                    heapq.heappush(queue, (next_step, next_posi, next_is_forw))\n        # --\n        return min(forw_stat[target], back_stat[target])\n", "from collections import deque\nclass Solution:\n    def racecar(self, target: int) -> int:\n        visited = set()\n        \n        q = deque([(0,1,0)])\n        while q:\n            pos, sp, d = q.popleft()\n            #print(pos, q)\n            if pos==target:\n                return d\n\n            if (pos, sp) in visited:\n                continue\n            visited.add((pos, sp))\n            \n            if abs(sp)>target:\n                # in these cases, must turn.\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n            else:\n                # can keep goint or turn.\n                q.append((pos+sp, sp*2, d+1))\n                q.append((pos, -1*(sp//abs(sp)), d+1))\n"]
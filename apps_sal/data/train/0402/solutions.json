["import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    # heap = [(-1,s)]\n    heap = [s]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e6:\n            return False\n        # _, c = heapq.heappop(heap)\n        c = heap.pop()\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 200*200:\n            return True\n\n        visited.add(c)\n\n\n        # heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        # heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        # heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        # heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n        heap.append((c[0]+1, c[1]  ))\n        heap.append((c[0]-1, c[1]  ))\n        heap.append((c[0]  , c[1]+1))\n        heap.append((c[0]  , c[1]-1))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n", "class Solution:\n     def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def bfs(source, target):\n            seen = set()\n            queue = collections.deque([source])\n            while queue:\n                if len(seen) >= 19901: return True\n                for _ in range(len(queue)):\n                    pos = queue.popleft()\n                    if pos == target: return True\n                    seen.add(pos)\n                    i, j = pos\n                    for ni, nj in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                        if 0 <= ni < 10**6 and 0 <= nj < 10**6 and (ni, nj) not in blocked and (ni, nj) not in seen:\n                            if (ni, nj) == target: return True\n                            seen.add((ni, nj))\n                            queue.append((ni, nj))\n            return False\n\n            \n        blocked = set(map(tuple, blocked))\n        source, target = tuple(source), tuple(target)\n        return bfs(source, target) and bfs(target, source)\n            \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def method1(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked=set(map(tuple,blocked))\n            seen=set()\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c):\n                if (r,c) in seen:\n                    return False\n                \n                if [r,c]==target:\n                    return True\n                \n                if (r,c) in blocked:\n                    return False\n                \n                seen.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    if dfs(nr,nc):\n                        return True\n                return False\n            \n            return dfs(*source)\n        \n        #return method1(blocked)\n    \n        def method2(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked = set(map(tuple, blocked))\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n        \n            def check(blocked, source, target):\n                si, sj = source\n                ti, tj = target\n                level = 0\n                q = collections.deque([(si,sj)])\n                vis = set()\n                while q:\n                    for _ in range(len(q)):\n                        i,j = q.popleft()\n                        if i == ti and j == tj: return True\n                        for x,y in neighbors(i,j):\n                            if (x,y) not in vis and (x,y) not in blocked:\n                                vis.add((x,y))\n                                q.append((x,y))\n                    level += 1\n                    if level == len(blocked): \n                        return True\n                    \n                return False\n        \n            return check(blocked, source, target) and check(blocked, target, source)\n        \n        return method2(blocked)\n            \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def method1(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked=set(map(tuple,blocked))\n            seen=set()\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c):\n                if (r,c) in seen:\n                    return False\n                \n                if [r,c]==target:\n                    return True\n                \n                if (r,c) in blocked:\n                    return False\n                \n                seen.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    if dfs(nr,nc):\n                        return True\n                return False\n            \n            return dfs(*source)\n        \n        #return method1(blocked)\n    \n        def method2(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked = set(map(tuple, blocked))\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n        \n            def check(source, target):\n                sr, sc = source\n                tr, tc = target\n                level = 0\n                q = collections.deque([(sr,sc)])\n                vis = set()\n                while q:\n                    for _ in range(len(q)):\n                        r,c = q.popleft()\n                        if r == tr and c == tc: return True\n                        for nr,nc in neighbors(r,c):\n                            if (nr,nc) not in vis and (nr,nc) not in blocked:\n                                vis.add((nr,nc))\n                                q.append((nr,nc))\n                    level += 1\n                    if level == len(blocked): \n                        return True\n                    \n                return False\n        \n            return check(source, target) and check(target, source)\n        \n        return method2(blocked)\n            \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def method1(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked=set(map(tuple,blocked))\n            seen=set()\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c):\n                if (r,c) in seen:\n                    return False\n                \n                if [r,c]==target:\n                    return True\n                \n                if (r,c) in blocked:\n                    return False\n                \n                seen.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    if dfs(nr,nc):\n                        return True\n                return False\n            \n            return dfs(*source)\n        \n        #return method1(blocked)\n    \n        def method2(blocked):\n            if not blocked: \n                return True\n                \n            blocked = set(map(tuple, blocked))\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n        \n            def check(blocked, source, target):\n                si, sj = source\n                ti, tj = target\n                level = 0\n                q = collections.deque([(si,sj)])\n                vis = set()\n                while q:\n                    for _ in range(len(q)):\n                        i,j = q.popleft()\n                        if i == ti and j == tj: return True\n                        for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                            if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                                vis.add((x,y))\n                                q.append((x,y))\n                    level += 1\n                    if level == len(blocked): \n                        return True\n                    \n                return False\n        \n            return check(blocked, source, target) and check(blocked, target, source)\n        \n        return method2(blocked)\n            \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n\n        #Column and row of source and target (used for escape condition)\n        sc, sr = source\n        tc, tr = target\n        R, C = 10**6, 10**6\n\n        def dist(r1,c1,r2,c2):\n            '''Calculates Manhattan distance from (r1,c1) to (r2,c2)'''\n            return abs(r2-r1)+abs(c2-c1)\n\n        #Two priority queues: one starting from target and one from source\n        #Two visited sets: one for nodes visited by path from target and the other from source\n        q = [[(0,*source[::-1])], [(0,*target[::-1])]]\n        v = [set(),set()]\n        b = set((tuple(b[::-1]) for b in blocked))\n\n        if (tuple(source) in b) or (tuple(target) in b):\n            return False\n\n        #if source and target can reach 200 distance from their origin\n        #it is safe to say 200 blocked spaces cannot contain them\n        source_escape = False\n        target_escape = False\n\n        while q[0] and q[1]:\n\n            index = 0 if len(q[0]) <= len(q[1]) else 1\n\n            d, r, c = heapq.heappop(q[index])\n\n            for i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\n                if (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\n\n                    if (i,j) in v[1-index]:\n                        return True\n\n                    v[index].add((i,j))\n                    r_target, c_target = q[1-index][0][1:]\n                    heapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\n\n            if not source_escape and not index:\n                source_escape = dist(r, c, sr, sc) > 200\n            if not target_escape and index:\n                target_escape = dist(r, c, tr, tc) > 200\n\n            if source_escape and target_escape:\n                return True\n\n        return False\n", "\n\nclass Solution:\n    def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            queue, seen = [source], {tuple(source)}\n            for x0, y0 in queue:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        queue.append([x, y])\n                        seen.add((x, y))\n                if len(queue) == 20000: \n                    return True\n            return False\n        \n        return bfs(source, target) and bfs(target, source)\n\n    \n    \n    \nclass Solution1:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        if not blocked:\n            return True\n        \n        rows = cols = 10**6\n        directions = {(0,1), (0,-1), (1,0), (-1,0)}\n        q1, q2 = [source], [target]\n        seen = set()\n        \n        while q1:\n            next_q = []\n            # current level\n            while q1:\n                r, c = q1.pop()\n                # print(r, c, q1)\n                for dr, dc in directions:\n                    if 0 <= r+dr < rows and 0 <= c+dc < cols:\n                        if [r+dr, c+dc] in q2:\n                            return True\n                        if [r+dr, c+dc] not in blocked:\n                            next_q.append([r+dr, c+dc])\n                            seen.add((r+dr, c+dc))\n            # print('hi', next_q)\n            # update level queue\n            q1 = next_q\n            if len(q1) > len(q2):\n                q1, q2 = q2, q1\n                    \n        return False\n                        \n                \n                \n                \n", "class Solution:\n    def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)\n", "from collections import deque \n\nclass Solution:\n    def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocked = set([tuple(b) for b in blocked])\n        dirs = [[-1,0],[1,0],[0,-1],[0,1]]   \n        def valid(r, c):\n            if r>=0 and r<1000000 and c>=0 and c<1000000:\n                return True\n            return False\n        \n        def bfs(source, target):\n            q = [tuple(source)]\n            vis = set([tuple(source)])\n            while q:\n\n                if len(q) > len(blocked):\n                    return True            \n                temp = []\n                for r, c in q:\n                    if (r, c) == tuple(target): #must do this cast\n                        return True\n                    for d in dirs:\n                        nr = r+d[0]\n                        nc = c+d[1]\n                        if valid(nr, nc):\n                            if (nr,nc) not in vis and (nr, nc) not in blocked:\n                                temp.append((nr,nc))\n                                vis.add((nr,nc))\n                q = temp\n                \n            return False\n            \n        return bfs(source, target) and bfs(target, source)\n            \n                \n                \n", "import collections\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: \n            return True\n         \n        blocked = set(map(tuple, blocked)) \n        print(len(blocked))\n        \n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\n        \n    def bfs(self, blocked, source, target):\n        si, sj = source\n        ti, tj = target\n        \n        queue = collections.deque([(si, sj)])\n        visited = set()\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        step = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                curX, curY = queue.popleft() \n                 \n                if curX == ti and curY == tj:\n                    return True\n                \n                for dx, dy in directions:\n                    newX = curX + dx\n                    newY = curY + dy\n                    if self.isValid(newX, newY, blocked, visited):\n                        queue.append((newX, newY))\n                        visited.add((newX, newY))\n            step += 1\n            if step == len(blocked):\n                break\n                \n        else:\n            return False\n        \n        return True \n        \n    def isValid(self, newX, newY, blocked, visited):\n        return 0 <= newX < 1000000 and  0 <= newY < 1000000 and (newX, newY) not in blocked and (newX, newY) not in visited", "class Solution:\n        def isEscapePossible(self, blocked, source, target):\n            blocked = {tuple(p) for p in blocked}\n\n            def bfs(source, target):\n                bfs, seen = [source], {tuple(source)}\n                for x0, y0 in bfs:\n                    for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                        x, y = x0 + i, y0 + j\n                        if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                            if [x, y] == target: return True\n                            bfs.append([x, y])\n                            seen.add((x, y))\n                    if len(bfs) == 20000: return True\n                return False\n            return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        src, target = tuple(source), tuple(target)\n        \n        return self.dfs(src, target, set(), blocked) and self.dfs(target, src, set(), blocked)\n    \n    def dfs(self, src, target, seen, blocked):\n        \n        if len(seen) > 20000 or src == target: return True \n        \n        x0, y0 = src\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            x = x0 + dx\n            y = y0 + dy\n            if (0<=x<10**6 and 0<=y<10**6 and ((x, y) not in seen) and ((x, y) not in blocked)):\n                seen.add((x, y))\n                if self.dfs((x, y), target, seen, blocked):\n                    return True \n                \n        return False\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n\n        #Column and row of source and target (used for escape condition)\n        sc, sr = source\n        tc, tr = target\n        R, C = 10**6, 10**6\n\n        def dist(r1,c1,r2,c2):\n            '''Calculates Manhattan distance from (r1,c1) to (r2,c2)'''\n            return abs(r2-r1)+abs(c2-c1)\n\n        #Two priority queues: one starting from target and one from source\n        #Two visited sets: one for nodes visited by path from target and the other from source\n        q = [[(0,*source[::-1])], [(0,*target[::-1])]]\n        v = [set(),set()]\n        b = set((tuple(b[::-1]) for b in blocked))\n\n        if (tuple(source) in b) or (tuple(target) in b):\n            return False\n\n        #if source and target can reach 200 distance from their origin\n        #it is safe to say 200 blocked spaces cannot contain them\n        source_escape = False\n        target_escape = False\n\n        while q[0] and q[1]:\n\n            index = 0 if len(q[0]) <= len(q[1]) else 1\n\n            d, r, c = heapq.heappop(q[index])\n\n            for i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\n                if (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\n\n                    if (i,j) in v[1-index]:\n                        return True\n\n                    v[index].add((i,j))\n                    r_target, c_target = q[1-index][0][1:]\n                    heapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\n\n            if not source_escape and not index:\n                source_escape = dist(r, c, sr, sc) > 200\n            if not target_escape and index:\n                target_escape = dist(r, c, tr, tc) > 200\n\n            if source_escape and target_escape:\n                return True\n\n        return False", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], se: List[int], target: List[int]) -> bool:\n        d={}\n        d[(se[0],se[1])]=1\n        e=[se]\n        v=1\n        bl={tuple(i) for i in blocked}\n        while(e!=[]):\n            f=[]\n            for i in e:\n                if(i==target):\n                    return True\n                x=i[0]\n                y=i[1]\n                if(x>0):\n                    if((x-1,y) not in bl)and((x-1,y) not in d):\n                        f.append([x-1,y])\n                        d[(x-1,y)]=1\n                if(x<10**6):\n                    if((x+1,y) not in bl)and((x+1,y) not in d):\n                        f.append([x+1,y])\n                        d[(x+1,y)]=1\n                if(y>0):\n                    if((x,y-1) not in bl)and((x,y-1) not in d):\n                        f.append([x,y-1])\n                        d[(x,y-1)]=1\n                if(y<10**6):\n                    if((x,y+1) not in bl)and((x,y+1) not in d):\n                        f.append([x,y+1])\n                        d[(x,y+1)]=1\n            e=f\n            v+=len(f)\n            if(v>=20000):\n                break\n        if(e==[]):\n            return False\n        \n        d={}\n        d[(target[0],target[1])]=1\n        e=[target]\n        v=0\n        while(e!=[]):\n            f=[]\n            for i in e:\n                if(i==se):\n                    return True\n                x=i[0]\n                y=i[1]\n                if(x>0):\n                    if((x-1,y) not in bl)and((x-1,y) not in d):\n                        f.append([x-1,y])\n                        d[(x-1,y)]=1\n                if(x<10**6):\n                    if((x+1,y) not in bl)and((x+1,y) not in d):\n                        f.append([x+1,y])\n                        d[(x+1,y)]=1\n                if(y>0):\n                    if((x,y-1) not in bl)and((x,y-1) not in d):\n                        f.append([x,y-1])\n                        d[(x,y-1)]=1\n                if(y<10**6):\n                    if((x,y+1) not in bl)and((x,y+1) not in d):\n                        f.append([x,y+1])\n                        d[(x,y+1)]=1\n            e=f\n            v+=len(f)\n            if(v>=20000):\n                return True\n        if(e==[]):\n            return False\n        \n        \n        \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocks = { tuple(b) for b in blocked }\n        \n        def bfs(start, end):\n            queue, used = [start], { tuple(start) }\n            for x, y in queue:\n                for dx, dy in [[-1, 0], [1, 0], [0, 1], [0, -1]]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 10**6 and 0 <= ny < 10**6 and (nx, ny) not in blocks and (nx, ny) not in used:\n                        if [nx, ny] == end:\n                            return True\n                        queue.append([nx, ny])\n                        used.add((nx, ny))\n                if len(queue) == 20000:\n                    return True\n                    \n            return False\n        \n        return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: return True\n        blocked = set(map(tuple, blocked))\n        \n        def check(blocked, source, target):\n            si, sj = source\n            ti, tj = target\n            level = 0\n            q = collections.deque([(si,sj)])\n            vis = set()\n            while q:\n                for _ in range(len(q)):\n                    i,j = q.popleft()\n                    if i == ti and j == tj: return True\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                            vis.add((x,y))\n                            q.append((x,y))\n                level += 1\n                if level == len(blocked): break\n            else:\n                return False\n            return True\n        \n        return check(blocked, source, target) and check(blocked, target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n#         blocked_set = set([tuple(l) for l in blocked])\n#         visited = set(tuple(source))\n#         visited_block_set = set()\n#         step = 0\n        \n#         directions = [(0,1),(1,0),(0,-1),(-1,0)]\n#         cur_queue = [tuple(source)]\n#         next_queue = []\n#         while True:\n    \n#             for c in cur_queue:\n#                 for d in directions:\n#                     if c[0]+d[0] >= 0 and c[1]+d[1] >= 0 and (c[0]+d[0], c[1]+d[1]) not in visited and (c[0]+d[0], c[1]+d[1]) not in blocked_set:\n#                         visited.add((c[0]+d[0], c[1]+d[1]))\n#                         next_queue.append((c[0]+d[0], c[1]+d[1]))\n#                         if (c[0]+d[0], c[1]+d[1]) == tuple(target):\n#                             return True\n#                     elif (c[0]+d[0], c[1]+d[1]) in blocked_set:\n#                         visited_block_set.add((c[0]+d[0], c[1]+d[1]))\n                        \n#             step += 1\n#             cur_queue = next_queue\n#             next_queue = []\n            \n#             if not cur_queue or step > 200:\n#                 break\n        \n#         if step == 201:\n#             return True\n#         return False\n\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)", "import collections\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: \n            return True\n         \n        blocked = set(map(tuple, blocked)) \n        # for b in blocked:\n        #     block.add((b[0], b[1]))\n        \n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\n        \n    def bfs(self, blocked, source, target):\n        si, sj = source\n        ti, tj = target\n        \n        queue = collections.deque([(si, sj)])\n        visited = set()\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        step = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                curX, curY = queue.popleft() \n                 \n                if curX == ti and curY == tj:\n                    return True\n                \n                for dx, dy in directions:\n                    newX = curX + dx\n                    newY = curY + dy\n                    if self.isValid(newX, newY, blocked, visited):\n                        queue.append((newX, newY))\n                        visited.add((newX, newY))\n            step += 1\n            if step == len(blocked):\n                break\n                \n        else:\n            return False\n        \n        return True \n        \n    def isValid(self, newX, newY, blocked, visited):\n        return 0 <= newX < 1000000 and  0 <= newY < 1000000 and (newX, newY) not in blocked and (newX, newY) not in visited\n    \n    \n    \n    \n    \n    \n#     def isEscapePossible(self, blocked, source, target):\n#         blocked = {tuple(p) for p in blocked}\n\n#         def bfs(source, target):\n#             bfs, seen = [source], {tuple(source)}\n#             for x0, y0 in bfs:\n#                 for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n#                     x, y = x0 + i, y0 + j\n#                     if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n#                         if [x, y] == target: return True\n#                         bfs.append([x, y])\n#                         seen.add((x, y))\n#                 if len(bfs) == 20000: return True\n#             return False\n#         return bfs(source, target) and bfs(target, source)\n\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n\n        #Column and row of source and target (used for escape condition)\n        sc, sr = source\n        tc, tr = target\n        R, C = 10**6, 10**6\n\n        def dist(r1,c1,r2,c2):\n            '''Calculates Manhattan distance from (r1,c1) to (r2,c2)'''\n            return abs(r2-r1)+abs(c2-c1)\n\n        #Two priority queues: one starting from target and one from source\n        #Two visited sets: one for nodes visited by path from target and the other from source\n        q = [[(0,*source[::-1])], [(0,*target[::-1])]]\n        v = [set(),set()]\n        b = set((tuple(b[::-1]) for b in blocked))\n\n        if (tuple(source) in b) or (tuple(target) in b):\n            return False\n\n        #if source and target can reach 200 distance from their origin\n        #it is safe to say 200 blocked spaces cannot contain them\n        source_escape = False\n        target_escape = False\n\n        while q[0] and q[1]:\n\n            index = 0 if len(q[0]) <= len(q[1]) else 1\n\n            d, r, c = heapq.heappop(q[index])\n\n            for i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\n                if (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\n\n                    if (i,j) in v[1-index]:\n                        return True\n\n                    v[index].add((i,j))\n                    r_target, c_target = q[1-index][0][1:]\n                    heapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\n\n            if not source_escape and not index:\n                source_escape = dist(r, c, sr, sc) > 200\n            if not target_escape and index:\n                target_escape = dist(r, c, tr, tc) > 200\n\n            if source_escape and target_escape:\n                return True\n\n        return False\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n\n###BFS\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if [x, y] == target: return True\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:    \n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        return bfs(source, target) and bfs(target, source)\n        \n    \n    \n###DFS\n#         blocked = set(map(tuple, blocked))\n\n#         def dfs(x, y, target, seen):\n#             if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n#             seen.add((x, y))\n#             if len(seen) > 20000 or [x, y] == target: return True\n#             return dfs(x + 1, y, target, seen) or \\\\\n#                 dfs(x - 1, y, target, seen) or \\\\\n#                 dfs(x, y + 1, target, seen) or \\\\\n#                 dfs(x, y - 1, target, seen)\n#         return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = {tuple(p) for p in blocked}\n        src_q = []\n        src_visited = set()\n        tgt_q = []\n        tgt_visited = set()\n        src_q.append((source[0], source[1]))\n        tgt_q.append((target[0], target[1]))\n        while src_q and tgt_q:\n            src_node_x, src_node_y = src_q.pop(0)\n            tgt_node_x, tgt_node_y = tgt_q.pop(0)\n            if (src_node_x, src_node_y) in tgt_visited:\n                return True\n            if (tgt_node_x, tgt_node_y) in src_visited:\n                return True\n            if len(tgt_visited) > 20000 or len(src_visited) > 20000:\n                return True\n            if (src_node_x, src_node_y) not in src_visited:\n                src_visited.add((src_node_x, src_node_y))\n                src_neighboring_nodes = [(src_node_x, src_node_y-1), (src_node_x, src_node_y+1), (src_node_x-1, src_node_y), (src_node_x+1, src_node_y)]\n                for each_node in src_neighboring_nodes:\n                    if 0<=each_node[0]<10**6 and 0<=each_node[1]<10**6 and each_node not in blocked and each_node not in src_visited:\n                        src_q.append((each_node[0], each_node[1]))\n            if (tgt_node_x, tgt_node_y) not in tgt_visited:\n                tgt_visited.add((tgt_node_x, tgt_node_y))\n                tgt_neighboring_nodes = [(tgt_node_x, tgt_node_y-1), (tgt_node_x, tgt_node_y+1), (tgt_node_x-1, tgt_node_y), (tgt_node_x+1, tgt_node_y)]\n                for each_node in tgt_neighboring_nodes:\n                    if 0<=each_node[0]<10**6 and 0<=each_node[1]<10**6 and each_node not in blocked and each_node not in tgt_visited:\n                        tgt_q.append((each_node[0], each_node[1]))\n        return False\n                        \n                \n                \n        \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) == 20000: return True\n            return False\n        \n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        m = 10 ** 6\n        n = len(blocked)\n        if target in blocked or source in blocked: return False\n        if n <= 1: return True\n        dxy = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n        blocked = set(map(tuple, blocked))\n        threshold = 200 * 200\n        def bfs(pos, target):\n            q = collections.deque([pos])\n            visited = {tuple(pos)}\n            cnt = 0\n            while q:\n                x, y = q.popleft()\n                if x == target[0] and y == target[1]:\n                    return 1\n                cnt += 1\n                if cnt > threshold:\n                    return 2\n                for dx, dy in dxy:\n                    x_, y_ = x + dx, y + dy\n                    if 0 <= x_ < m and 0 <= y_ < m:\n                        p = (x_, y_)\n                        if p not in visited and p not in blocked:\n                            q.append(p)\n                            visited.add(p)\n            return -1\n        \n        i = bfs(source, target)\n        # print(i)\n        if i == 1:\n            return True\n        if i == -1:\n            return False\n        j = bfs(target, source)\n        # print(j)\n        return j == 2\n                     \n        \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int], maxNum = 10e6, bound = 200) -> bool:\n        \n        maxArea = bound*bound//2 + 1\n        directions = [0, 1, 0, -1, 0]\n        \n        def dfs(x, y, t): \n            if x<0 or x>maxNum or y<0 or y>maxNum or tuple([x, y]) in block: \n                return False \n            seen.add(tuple([x, y]))\n            block.add(tuple([x, y]))\n            if len(seen)>maxArea or (x == t[0] and y == t[1]): \n                return True \n            for d in range(4): \n                if dfs(x+directions[d], y+directions[d+1], t): \n                    return True\n            return False        \n        seen = set()\n        block = set(map(tuple, blocked))\n        if not dfs(source[0], source[1], target): \n            return False \n        seen = set()\n        block = set(map(tuple, blocked))\n        return dfs(target[0], target[1], source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n\n###BFS\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n                    x, y = x0 + i, y0 + j\n                    if [x, y] == target: return True\n                    if len(bfs) == 20000: return True\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:    \n                        bfs.append([x, y])\n                        seen.add((x, y))\n                \n            return False\n        return bfs(source, target) and bfs(target, source)\n        \n    \n    \n###DFS\n#         blocked = set(map(tuple, blocked))\n\n#         def dfs(x, y, target, seen):\n#             if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n#             seen.add((x, y))\n#             if len(seen) > 20000 or [x, y] == target: return True\n#             return dfs(x + 1, y, target, seen) or \\\\\n#                 dfs(x - 1, y, target, seen) or \\\\\n#                 dfs(x, y + 1, target, seen) or \\\\\n#                 dfs(x, y - 1, target, seen)\n#         return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def bfs(start, is_source=True):\n            queue = [start]\n            pending = set({start})\n            visited = set()\n            while len(queue) > 0:\n                temp = queue.pop(0)\n                x1, y1 = temp\n                if temp == tuple(target) and is_source:\n                    return True\n                if temp == tuple(source) and not is_source:\n                    return True\n                visited.add(temp)\n                if len(visited) > len(blocked)**2//2:\n                    return True\n                pending.remove(temp)\n                for x, y in [(x1+1, y1), (x1-1, y1), (x1, y1+1), (x1, y1-1)]:\n                    if 0<=x<10**6 and 0<=y<10**6:\n                        if (x, y) not in pending and (x, y) not in blocked and (x, y) not in visited:\n                            queue.append((x, y))\n                            pending.add((x, y))\n            return False\n        blocked = list(map(tuple, blocked))\n        return bfs(tuple(source), True) and bfs(tuple(target), False)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocked = set([tuple(b) for b in blocked])\n        dirs = [[-1,0],[1,0],[0,-1],[0,1]]   \n        def valid(r, c):\n            if r>=0 and r<1000000 and c>=0 and c<1000000:\n                return True\n            return False\n        \n        def bfs(source, target):\n            q = [tuple(source)]\n            vis = set([tuple(source)])\n            while q:\n\n                if len(q) >= len(blocked):\n                    return True            \n                temp = []\n                for r, c in q:\n                    if (r, c) == tuple(target): #must do this cast\n                        return True\n                    for d in dirs:\n                        nr = r+d[0]\n                        nc = c+d[1]\n                        if valid(nr, nc):\n                            if (nr,nc) not in vis and (nr, nc) not in blocked:\n                                temp.append((nr,nc))\n                                vis.add((nr,nc))\n                q = temp\n                \n            return False\n            \n        return bfs(source, target) and bfs(target, source)\n            \n                \n                \n", "class Solution:\n    def isEscapePossible(self, b: List[List[int]], s: List[int], t: List[int]) -> bool:\n        def find(source,  target, blocked):\n            queue = [source]\n            visited = set()\n\n            while queue:\n                x, y = queue.pop()\n\n                if len(visited) > 20000:\n                    return True\n\n                if x == target[0] and y == target[1]:\n                    return True\n\n                visited.add((x, y))\n\n                next_options = []\n                for x_delta, y_delta in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    new_x, new_y = x + x_delta, y + y_delta\n\n                    if new_x < 0 or new_x >= 10 ** 6 or new_y < 0 or new_y >= 10 ** 6:\n                        continue\n\n                    if (new_x, new_y) in visited or (new_x, new_y) in blocked:\n                        continue\n\n                    next_options.append((new_x, new_y))\n\n                next_options.sort(key=lambda point: (point[0] - target[0]) ** 2 + (point[1] - target[1]) ** 2, reverse=True)\n                queue += next_options\n        \n            return False\n    \n        bl = set()\n        for bi in b:\n            bl.add(tuple(bi))\n            \n        return find(s, t, bl) and find(t, s, bl)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        maxlen = 10**6\n        #maxarea = (4/3.14) * 17000 # maxarea = (4/3.14) * 10000 does not work!\n        maxarea = 40000\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        blocked = set(map(tuple, blocked)) # use a set to make it faster for retrieving\n        \n        def bfs(source, target):\n            q = collections.deque()\n            aset = set()\n            q.append(source)\n            while q and len(aset) < maxarea:\n                row, col = q.popleft()\n                if row == target[0] and col == target[1]:\n                    return True\n                aset.add((row,col))\n                \n                for dir in dirs:\n                    row2 = row + dir[0]\n                    col2 = col + dir[1]\n                    if 0<=row2<maxlen and 0<=col2 < maxlen and not (row2, col2) in aset and not (row2,col2) in blocked:\n                        q.append([row2, col2])\n                        aset.add((row2, col2))\n            return len(aset) >= maxarea # evaluate by maxarea\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        maxlen = 10**6\n        #maxarea = (4/3.14) * 17000 # maxarea = (4/3.14) * 10000 does not work!\n        maxarea = 40000\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        blocked = set(map(tuple, blocked)) # use a set to make it faster for retrieving\n        \n        def bfs(source, target):\n            q = collections.deque()\n            visited = set()\n            q.append(source)\n            while q and len(visited) < maxarea:\n                row, col = q.popleft()\n                if row == target[0] and col == target[1]:\n                    return True\n                visited.add((row,col))\n                \n                for dir in dirs:\n                    row2 = row + dir[0]\n                    col2 = col + dir[1]\n                    if 0<=row2<maxlen and 0<=col2 < maxlen and not (row2, col2) in visited and not (row2,col2) in blocked:\n                        q.append([row2, col2])\n                        visited.add((row2, col2))\n            return len(visited) >= maxarea # evaluate by maxarea\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        directions = [[-1, 0], [0, -1], [1, 0], [0, 1]]\n        block_set = {tuple(t) for t in blocked}\n        source, target = tuple(source), tuple(target)\n        if source in block_set or target in block_set:\n            return False\n        \n        def findPath(source, target, block_set):\n            from collections import deque\n            queue = deque()\n            covered, covered_block = set(), set()\n            queue.append(source)\n            covered.add(source)\n            while len(queue) > 0:\n                count = len(queue)\n                while count > 0:\n                    head = queue.popleft()\n                    count -= 1\n                    for dir1 in directions:\n                        x, y = head[0] + dir1[0], head[1] + dir1[1]\n                        if x < 0 or x == int(1e6) or y < 0 or y == int(1e6):\n                            continue\n                        pos = (x, y)\n                        if pos == target:\n                            return True                    \n                        elif pos in covered:\n                            continue\n                        elif pos in block_set:\n                            covered.add(pos)\n                            covered_block.add(pos)\n                        else:\n                            queue.append(pos)\n                            covered.add(pos)\n                \n                if len(queue) + len(covered_block) > len(block_set):\n                    return True\n            return False\n        \n        if not findPath(source, target, block_set):\n            return False\n        \n        return findPath(target, source, block_set)\n            \n\n\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], se: List[int], target: List[int]) -> bool:\n        d={}\n        d[(se[0],se[1])]=1\n        e=[se]\n        v=1\n        bl={tuple(i) for i in blocked}\n        g=0\n        while(e!=[]):\n            f=[]\n            for i in e:\n                if(i==target):\n                    return True\n                x=i[0]\n                y=i[1]\n                if(abs(x-se[0])+abs(y-se[1])>200):\n                    g=2\n                    break\n                if(x>0):\n                    if((x-1,y) not in bl)and((x-1,y) not in d):\n                        f.append([x-1,y])\n                        d[(x-1,y)]=1\n                if(x<10**6):\n                    if((x+1,y) not in bl)and((x+1,y) not in d):\n                        f.append([x+1,y])\n                        d[(x+1,y)]=1\n                if(y>0):\n                    if((x,y-1) not in bl)and((x,y-1) not in d):\n                        f.append([x,y-1])\n                        d[(x,y-1)]=1\n                if(y<10**6):\n                    if((x,y+1) not in bl)and((x,y+1) not in d):\n                        f.append([x,y+1])\n                        d[(x,y+1)]=1\n            if(g==2):\n                break\n            e=f\n        if(e==[]):\n            return False\n        \n        d={}\n        d[(target[0],target[1])]=1\n        e=[target]\n        v=0\n        while(e!=[]):\n            f=[]\n            for i in e:\n                if(i==se):\n                    return True\n                x=i[0]\n                y=i[1]\n                if(abs(x-se[0])+abs(y-se[1])>200):\n                    return True\n                if(x>0):\n                    if((x-1,y) not in bl)and((x-1,y) not in d):\n                        f.append([x-1,y])\n                        d[(x-1,y)]=1\n                if(x<10**6):\n                    if((x+1,y) not in bl)and((x+1,y) not in d):\n                        f.append([x+1,y])\n                        d[(x+1,y)]=1\n                if(y>0):\n                    if((x,y-1) not in bl)and((x,y-1) not in d):\n                        f.append([x,y-1])\n                        d[(x,y-1)]=1\n                if(y<10**6):\n                    if((x,y+1) not in bl)and((x,y+1) not in d):\n                        f.append([x,y+1])\n                        d[(x,y+1)]=1\n            e=f\n            \n        if(e==[]):\n            return False\n        \n        \n        \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: return True\n        blocked = set(map(tuple, blocked))\n        \n        def check(blocked, source, target):\n            si, sj = source\n            ti, tj = target\n            level = 0\n            q = collections.deque([(si,sj)])\n            vis = set()\n            while q:\n                for _ in range(len(q)):\n                    i,j = q.popleft()\n                    if i == ti and j == tj: return True\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                            vis.add((x,y))\n                            q.append((x,y))\n                level += 1\n                if level == 2 * len(blocked): break\n            else:\n                return False\n            return True\n        \n        return check(blocked, source, target) and check(blocked, target, source)", "import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [(-1,s)]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e5:\n            return False\n        _, c = heapq.heappop(heap)\n        if c in visited:\n            continue\n        if c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            # outside!\n            continue\n        if c in b:\n            # blocked!\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n\n        visited.add(c)\n        x = c[0]\n        while t[0] > x and (x+1,c[1]) not in b:\n            x += 1\n        heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n        x = c[0]\n        while t[0] < x and (x-1,c[1]) not in b:\n            x -= 1\n        heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n\n        y = c[1]\n        while t[1] > y and (c[0],y) not in b:\n            y += 1\n        heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n        y = c[1]\n        while t[1] < y and (c[0],y) not in b:\n            y -= 1\n        heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n\n\n        heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n    # we live in a cavity :(\n    return False\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve(blocked, source, target)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def bfs(s,t,b):\n            q,v=[s],{s}\n            while len(q)>0:\n                i,j=q.pop(0)\n                if (i,j)==t:return True\n                if i in (s[0]+210,s[0]-210) or j in (s[1]+210,s[1]-210):return True\n                for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\n                    if d>=0 and d<10**6 and e>=0 and e<10**6 and (d,e) not in v and (d,e) not in b:\n                        v.add((d,e))\n                        q.append((d,e))\n            return False\n        \n        b=set(tuple(i) for i in blocked)\n        return bfs(tuple(source),tuple(target),b) and bfs(tuple(target),tuple(source),b)\n        \n        # blocked_map = collections.defaultdict(set)\n        # for r,c in blocked:\n        #     blocked_map[r].add(c)\n        # queue_s = collections.deque()\n        # queue_s.append(source)\n        # visited_s = set()\n        # visited_s.add(tuple(source))\n        # queue_t = collections.deque()\n        # queue_t.append(target)\n        # visited_t = set()\n        # visited_t.add(tuple(target))\n        # while queue_s and queue_t:\n        #     curr = queue_s.popleft()\n        #     if curr==target or tuple(curr) in visited_t:\n        #         return True\n        #     for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\n        #         nei_r = curr[0]+dr\n        #         nei_c = curr[1]+dc\n        #         if nei_r>=0 and nei_r<10**6 and nei_c>=0 and nei_c<10**6:\n        #             if nei_r not in blocked_map or (nei_r in blocked_map and nei_c not in blocked_map[nei_r]):\n        #                 if tuple([nei_r,nei_c]) not in visited_s:\n        #                     visited_s.add(tuple([nei_r,nei_c]))\n        #                     queue_s.append([nei_r,nei_c])\n        #     curr = queue_t.popleft()\n        #     if curr == source or tuple(curr) in visited_s:\n        #         return True\n        #     for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\n        #         nei_r = curr[0]+dr\n        #         nei_c = curr[1]+dc\n        #         if nei_r>=0 and nei_r<10**6 and nei_c>=0 and nei_c<10**6:\n        #             if nei_r not in blocked_map or (nei_r in blocked_map and nei_c not in blocked_map[nei_r]):\n        #                 if tuple([nei_r,nei_c]) not in visited_t:\n        #                     visited_t.add(tuple([nei_r,nei_c]))\n        #                     queue_t.append([nei_r,nei_c])\n        # return False\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        DELTAS = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        CANNOT_MEET = 0\n        CAN_WALK_200_STEPS = 1\n        CAN_MEET = 2\n        blocked_set = set(tuple(element) for element in blocked)\n        \n        def is_valid(i, j, seen):\n            return 0 <= i < 10 ** 6 and 0 <= j < 10 ** 6 and (i, j) not in blocked_set and (i, j) not in seen\n        \n        def can_meet(source, target):\n            i, j = source\n            ti, tj = target\n            q = deque([(i, j, 0)])\n            seen = set()\n            seen.add((i, j))\n            while q:\n                i, j, step = q.popleft()\n                if (i == ti and j == tj):\n                    return CAN_MEET\n                if step == 200:\n                    return CAN_WALK_200_STEPS\n                for di, dj in DELTAS:\n                    i1, j1 = i + di, j + dj\n                    if is_valid(i1, j1, seen):\n                        seen.add((i1, j1))\n                        q.append((i1, j1, step + 1))\n            return CANNOT_MEET\n        \n        result1 = can_meet(source, target)\n        if result1 == CANNOT_MEET:\n            return False\n        if result1 == CAN_MEET:\n            return True\n        \n        # result1 == CAN_WALK_200_STEPS\n        result2 = can_meet(target, source)\n        if result2 == CAN_WALK_200_STEPS:\n            return True\n        return False\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        DELTAS = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        blocked_set = set(tuple(element) for element in blocked)\n        \n        def is_valid(i, j, seen):\n            return 0 <= i < 10 ** 6 and 0 <= j < 10 ** 6 and (i, j) not in blocked_set and (i, j) not in seen\n        \n        def can_meet(source, target):\n            i, j = source\n            ti, tj = target\n            q = deque([(i, j, 0)])\n            seen = set()\n            seen.add((i, j))\n            while q:\n                i, j, step = q.popleft()\n                if (i == ti and j == tj) or step == 200:\n                    return True\n                for di, dj in DELTAS:\n                    i1, j1 = i + di, j + dj\n                    if is_valid(i1, j1, seen):\n                        seen.add((i1, j1))\n                        q.append((i1, j1, step + 1))\n            return False\n        \n        return can_meet(source, target) and can_meet(target, source)\n", "def bfs(s,t,b):\n    q,v=[s],{s}\n    while len(q)>0:\n        i,j=q.pop(0)\n        if (i,j)==t:return True\n        if i in (s[0]+210,s[0]-210) or j in (s[1]+210,s[1]-210):return True\n        for d,e in ((i+1,j),(i,j+1),(i-1,j),(i,j-1)):\n            if d>=0 and d<10**6 and e>=0 and e<10**6 and (d,e) not in v and (d,e) not in b:\n                v.add((d,e))\n                q.append((d,e))\n    return False\nclass Solution:\n    def isEscapePossible(self, b: List[List[int]], s: List[int], t: List[int]) -> bool:\n        b=set(tuple(i) for i in b)\n        return bfs(tuple(s),tuple(t),b) and bfs(tuple(t),tuple(s),b)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: return True\n        blocked = set(map(tuple, blocked))\n        \n        def check(blocked, source, target):\n            si, sj = source\n            ti, tj = target\n            level = 0\n            q = collections.deque([(si,sj)])\n            vis = set()\n            while q:\n                for _ in range(len(q)):\n                    i,j = q.popleft()\n                    if i == ti and j == tj: return True\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                            vis.add((x,y))\n                            q.append((x,y))\n                level += 1\n                if level == 2*len(blocked): \n                    break\n            if len(q)==0:\n                return False\n            return True\n        \n        return check(blocked, source, target) and check(blocked, target, source)", "import heapq\n\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [(-1,s)]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e5:\n            return False\n        _, c = heapq.heappop(heap)\n        if c in visited:\n            continue\n        if c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            # outside!\n            continue\n        if c in b:\n            # blocked!\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n\n        visited.add(c)\n        x = c[0]\n        while t[0] > x and (x+1,c[1]) not in b:\n            x += 1\n        heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n        x = c[0]\n        while t[0] < x and (x-1,c[1]) not in b:\n            x -= 1\n        heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n\n        y = c[1]\n        while t[1] > y and (c[0],y) not in b:\n            y += 1\n        heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n        y = c[1]\n        while t[1] < y and (c[0],y) not in b:\n            y -= 1\n        heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n\n\n        heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n    # we live in a cavity :(\n    return False\n\n\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve(blocked, source, target)\n", "\n\ndef get_children(point, target):\n    children = []\n    y, x = point\n    size_y, size_x = target\n    \n    if y-1 >= 0:\n        children.append((y-1, x))\n    \n    if x-1 >= 0:\n        children.append((y,x-1))\n        \n    if y+1 <= size_y:\n        children.append((y+1,x))\n        \n    if x+1 <= size_x:\n        children.append((y,x+1))\n        \n    return children\n\n\ndef bfs(source, target, is_blocked):\n    queue = []\n    marked = set()\n\n    queue.append((source,1))\n    marked.add(source)\n\n    while queue:\n\n        node_id, depth = queue.pop(0)\n        \n        if depth > 200:\n            return True\n\n        for child_id in get_children(node_id, (1000000, 1000000)):\n\n            if child_id in is_blocked:\n                continue\n\n            if child_id == target:\n                return True\n\n            if child_id not in marked:\n                queue.append((child_id,depth+1))\n                marked.add(child_id)\n\n    return False\n    \n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        is_blocked = set()\n        for item in blocked:\n            is_blocked.add(tuple(item))\n            \n        target = tuple(target)\n        source = tuple(source)\n        \n        if bfs(source, target, is_blocked) and bfs(target,source,is_blocked):\n            return True\n        \n        return False", "from queue import PriorityQueue\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n       #Column and row of source and target (used for escape condition)\n        sc, sr = source\n        tc, tr = target\n        R, C = 10**6, 10**6\n\n        def dist(r1,c1,r2,c2):\n            '''Calculates Manhattan distance from (r1,c1) to (r2,c2)'''\n            return abs(r2-r1)+abs(c2-c1)\n\n        #Two priority queues: one starting from target and one from source\n        #Two visited sets: one for nodes visited by path from target and the other from source\n        q = [[(0,*source[::-1])], [(0,*target[::-1])]]\n        v = [set(),set()]\n        b = set((tuple(b[::-1]) for b in blocked))\n\n        if (tuple(source) in b) or (tuple(target) in b):\n            return False\n\n        #if source and target can reach 200 distance from their origin\n        #it is safe to say 200 blocked spaces cannot contain them\n        source_escape = False\n        target_escape = False\n\n        while q[0] and q[1]:\n\n            index = 0 if len(q[0]) <= len(q[1]) else 1\n\n            d, r, c = heapq.heappop(q[index])\n\n            for i, j in ((r+1, c), (r-1, c), (r, c+1), (r, c-1)):\n                if (0 <= i < R) and (0 <= j < C) and ((i,j) not in b) and ((i,j) not in v[index]):\n\n                    if (i,j) in v[1-index]:\n                        return True\n\n                    v[index].add((i,j))\n                    r_target, c_target = q[1-index][0][1:]\n                    heapq.heappush(q[index], (dist(i,j,r_target,c_target), i, j))\n\n            if not source_escape and not index:\n                source_escape = dist(r, c, sr, sc) > 200\n            if not target_escape and index:\n                target_escape = dist(r, c, tr, tc) > 200\n\n            if source_escape and target_escape:\n                return True\n\n        return False", "class Solution:\n    def isValidStep(self, blocked, visited, step) -> bool:\n        return tuple(step) not in blocked and tuple(step) not in visited and step[0] >= 0 and step[0] < 1000000 and step[1] >= 0 and step[1] < 1000000\n    \n    def isEscapePossibleHelper(self, blocked: set, source: List[int], target: List[int]) -> bool:\n        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n        nextSteps = []\n        visited = set([tuple(source)])\n        \n        for d in directions:\n            step = [source[0] + d[0], source[1] + d[1]]\n            if self.isValidStep(blocked, visited, step):\n                nextSteps.append(step)\n                visited.add(tuple(step))\n\n        while nextSteps:\n            step = nextSteps.pop()\n            if step == target or abs(step[0] - source[0]) + abs(step[1] - source[1]) >= 200:\n                return True\n            \n            for d in directions:\n                nextStep = [step[0] + d[0], step[1] + d[1]]\n                if self.isValidStep(blocked, visited, nextStep):\n                    nextSteps.append(nextStep)\n                    visited.add(tuple(step))\n                    if len(visited) > 20000:\n                        return True\n\n        return False\n    \n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(tuple(b) for b in blocked)\n        return self.isEscapePossibleHelper(blocked, source, target) and self.isEscapePossibleHelper(blocked, target, source)", "class Solution:\n    def isEscapePossible(self, b: List[List[int]], s: List[int], t: List[int]) -> bool:\n        def dis(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        \n        def find(source,  target, blocked):\n            queue = [source]\n            visited = set()\n\n            while queue:\n                x, y = queue.pop()\n\n                if dis((x, y), source) > 200:\n                    return True\n\n                if x == target[0] and y == target[1]:\n                    return True\n\n                visited.add((x, y))\n\n                next_options = []\n                for x_delta, y_delta in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n                    new_x, new_y = x + x_delta, y + y_delta\n\n                    if new_x < 0 or new_x >= 10 ** 6 or new_y < 0 or new_y >= 10 ** 6:\n                        continue\n\n                    if (new_x, new_y) in visited or (new_x, new_y) in blocked:\n                        continue\n\n                    next_options.append((new_x, new_y))\n\n                next_options.sort(key=lambda point: (point[0] - source[0]) ** 2 + (point[1] - source[1]) ** 2)\n                queue += next_options\n        \n            return False\n    \n        bl = set()\n        for bi in b:\n            bl.add(tuple(bi))\n            \n        return find(s, t, bl) and find(t, s, bl)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        \n        m = n = 10**6\n        \n        max_area = len(blocked)**2/2\n        blocked = set(tuple(x) for x in blocked)\n\n        def dfs(r, c, dst, visited, count, steps):\n            # print(r, c)\n            if (r, c) in visited:\n                return False\n            if (r, c) == dst:\n                return True\n            \n            visited.add((r,c))\n            if (r,c) in blocked:\n                count[0] += 1\n                return False\n\n\n\n            if 0<=r<m and 0<=c<n:\n                if count[0] >= 200:\n                    return True\n                if steps[0] >= max_area:\n                    return True\n                \n                steps[0] += 1\n\n                for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n                    if dfs(r+dr, c+dc, dst, visited, count, steps):\n                        return True\n\n            return False\n\n\n        return dfs(source[0], source[1], tuple(target), set(), [0], [0]) and dfs(target[0], target[1], tuple(source), set(), [0], [0])\n", "import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [s]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e6:\n            return False\n        c = heap.pop()\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 200*200:\n            return True\n\n        visited.add(c)\n        heap.append((c[0]+1, c[1]  ))\n        heap.append((c[0]-1, c[1]  ))\n        heap.append((c[0]  , c[1]+1))\n        heap.append((c[0]  , c[1]-1))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return self.helper(blocked, source, target) and self.helper(blocked, target, source)\n    def helper(self, blocked, source, target):\n        if not blocked: return True\n        dq = collections.deque([tuple(source)])\n        l = len(blocked)\n        seen = {tuple(source)}\n        blocked = set(map(tuple, blocked))\n        while dq:\n            sz = len(dq)\n            for _ in range(sz):\n                x, y = dq.popleft()\n                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                    xx, yy = x + dx, y + dy\n                    if 0 <= xx < 10 ** 6 and 0 <= yy < 10 ** 6 and (xx, yy) not in seen and (xx, yy) not in blocked:\n                        seen.add((xx, yy))\n                        dq.append((xx, yy))\n                        # the maximum area covered by blocks will be an isosceles right triangle with area less than l * l // 2\n                        # if we can cover more cells than l * l // 2, we will be bound to break the block\n                        if (xx, yy) == tuple(target) or len(seen) >= l * l // 2: return True\n        return False", "import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [(-1,s)]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e5:\n            return False\n        _, c = heapq.heappop(heap)\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 200*200:\n            print(('found!', c, t))\n            return True\n        visited.add(c)\n        heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        q = collections.deque([source])\n        visited = set([tuple(source)])\n        blocked = set([tuple(b) for b in blocked])\n        lb = len(blocked)*3\n        r = math.ceil(lb/(math.pi)/2.0)\n        Max = math.ceil(r*r*math.pi)\n        dx,dy = [0,1,0,-1],[1,0,-1,0]\n        breakflag = False\n        while q:\n            if len(visited) > Max:\n                breakflag = True\n                break\n            l = len(q)\n            for i in range(l):\n                x,y = q.popleft()\n                for j in range(4):\n                    newx,newy = x+dx[j],y+dy[j]\n                    if 0<=newx<1000000 and 0<=newy<1000000 and (newx,newy) not in visited and (newx,newy) not in blocked:\n                        if newx == target[0] and newy == target[1]:\n                            return True\n                        visited.add((newx,newy))\n                        q.append((newx,newy))\n        if breakflag == False:\n            return False\n        breakflag = False\n        q = collections.deque([target])\n        visited = set([tuple(target)])\n        while q:\n            if len(visited) > Max:\n                breakflag = True\n                break\n            l = len(q)\n            for i in range(l):\n                x,y = q.popleft()\n                for j in range(4):\n                    newx,newy = x+dx[j],y+dy[j]\n                    if 0<=newx<1000000 and 0<=newy<1000000 and (newx,newy) not in visited and (newx,newy) not in blocked:\n                        visited.add((newx,newy))\n                        q.append((newx,newy))\n        if breakflag == False:\n            return False\n        return True\n                    \n", "import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [(-1,s)]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e5:\n            return False\n        _, c = heapq.heappop(heap)\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 201*201:\n            print(('found!', c, t))\n            return True\n\n        visited.add(c)\n        # x = c[0]\n        # while t[0] > x and (x+1,c[1]) not in b:\n        #     x += 1\n#         heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n#         x = c[0]\n#         while t[0] < x and (x-1,c[1]) not in b:\n#             x -= 1\n#         heapq.heappush(heap, create_priority_item((x, c[1]  ), t))\n\n#         y = c[1]\n#         while t[1] > y and (c[0],y+1) not in b:\n#             y += 1\n#         heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n#         y = c[1]\n#         while t[1] < y and (c[0],y-1) not in b:\n#             y -= 1\n#         heapq.heappush(heap, create_priority_item((c[0], y  ), t))\n\n\n        heapq.heappush(heap, create_priority_item((c[0]+1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]-1, c[1]  ), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]+1), t))\n        heapq.heappush(heap, create_priority_item((c[0]  , c[1]-1), t))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        bl = {tuple(b) for b in blocked}\n        s0, s1 = source\n        t0, t1 = target\n        s_vis = {(s0, s1)}\n        t_vis = {(t0, t1)}\n        s_q = [(s0, s1)]\n        t_q = [(t0, t1)]\n        while s_q and len(s_vis) < 20010:\n            n0, n1 = s_q.pop()\n            if (n0, n1) == (t0, t1):\n                return True\n            if n0 < 10**6-1 and (n0+1, n1) not in s_vis and (n0+1, n1) not in bl:\n                s_q.append((n0+1, n1))\n                s_vis.add((n0+1, n1))\n            if n0 > 0 and (n0-1, n1) not in s_vis and (n0-1, n1) not in bl:\n                s_q.append((n0-1, n1))\n                s_vis.add((n0-1, n1))\n            if n1 < 10**6-1 and (n0, n1+1) not in s_vis and (n0, n1+1) not in bl:\n                s_q.append((n0, n1+1))\n                s_vis.add((n0, n1+1))\n            if n1 > 0 and (n0, n1-1) not in s_vis and (n0, n1-1) not in bl:\n                s_q.append((n0, n1-1))\n                s_vis.add((n0, n1-1))\n        while t_q and len(t_vis) < 20010:\n            n0, n1 = t_q.pop()\n            if (n0, n1) == (s0, s1):\n                return True\n            if n0 < 10**6-1 and (n0+1, n1) not in t_vis and (n0+1, n1) not in bl:\n                t_q.append((n0+1, n1))\n                t_vis.add((n0+1, n1))\n            if n0 > 0 and (n0-1, n1) not in t_vis and (n0-1, n1) not in bl:\n                t_q.append((n0-1, n1))\n                t_vis.add((n0-1, n1))\n            if n1 < 10**6-1 and (n0, n1+1) not in t_vis and (n0, n1+1) not in bl:\n                t_q.append((n0, n1+1))\n                t_vis.add((n0, n1+1))\n            if n1 > 0 and (n0, n1-1) not in t_vis and (n0, n1-1) not in bl:\n                t_q.append((n0, n1-1))\n                t_vis.add((n0, n1-1))\n\n        return bool(t_q and s_q)\n", "import heapq\n\ndef solve(b,s,t):\n    def create_priority_item(c, t):\n        dx = c[0]-t[0]\n        dy = c[1]-t[1]\n        d2 = dx*dx + dy*dy\n        return (d2, c)\n\n    b = set(tuple(_b) for _b in b)\n    s = tuple(s)\n    t = tuple(t)\n    heap = [s]\n    visited = set()\n    iter = -1\n    while heap:\n        iter += 1\n        if iter > 1.1e5:\n            return False\n        c = heap.pop()\n        if c in visited or c in b or c[0] < 0 or c[0] >=1e6 or c[1]<0 or c[1]>=1e6:\n            continue\n        if c == t:\n            # found!\n            return True\n        # search neighbors:\n        dx = c[0] - s[0]\n        dy = c[1] - s[1]\n        if dx*dx + dy*dy > 200*200:\n            return True\n\n        visited.add(c)\n        heap.append((c[0]+1, c[1]  ))\n        heap.append((c[0]-1, c[1]  ))\n        heap.append((c[0]  , c[1]+1))\n        heap.append((c[0]  , c[1]-1))\n    # we live in a cavity :(\n    return False\n\ndef solve_both(b,s,t):\n    return solve(b,s,t) and solve(b,t,s)\n\n\n\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        return solve_both(blocked, source, target)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        \n        def dfs(x, y, sink, visited):\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in visited:\n                return False\n            \n            visited.add((x, y))\n            # max blocked cell = 200\n            if len(visited) > 20000 or [x, y] == sink:\n                return True\n            return dfs(x + 1, y, sink, visited) or dfs(x - 1, y, sink, visited) or dfs(x, y + 1, sink, visited) or dfs(x, y - 1, sink, visited)\n        \n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked=set(map(tuple,blocked))\n       \n        def dfs(x,y,target,blocked,seen):\n            if not (0<=x<1e6 and 0<=y<1e6) or (x,y) in blocked or (x,y) in seen:\n                return False\n            seen.add((x,y))\n            if len(seen)>20000 or [x,y]==target:\n                return True\n            return dfs(x+1,y,target,blocked,seen) or dfs(x-1,y,target,blocked,seen) or dfs(x,y+1,target,blocked,seen) or dfs(x,y-1,target,blocked,seen)\n        return dfs(source[0],source[1],target,blocked,set()) and dfs(target[0],target[1],source,blocked,set())\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        \n        def inbounds(x, y):\n            return (x >= 0 and x < 10**6 and y >= 0 and y < 10**6)\n\n        def dfs(x, y, target, seen):\n            if (x,y) in blocked or not inbounds(x,y) or (x,y) in seen:\n                return False\n            seen.add((x,y))\n            \n            if len(seen) > 20000 or [x, y] == target:\n                return True\n            \n            return dfs(x+1, y, target, seen) or dfs(x-1, y, target, seen) or dfs(x, y+1, target, seen) or dfs(x, y-1,target,seen)\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        \n        def inbounds(x, y):\n            return (x >= 0 and x < 10**6 and y >= 0 and y < 10**6)\n\n        def dfs(x, y, target, seen):\n            if (x,y) in blocked or not inbounds(x,y) or (x,y) in seen:\n                return False\n            seen.add((x,y))\n            \n            if len(seen) > (200*199/2) or [x, y] == target:\n                return True\n            \n            return dfs(x+1, y, target, seen) or dfs(x-1, y, target, seen) or dfs(x, y+1, target, seen) or dfs(x, y-1,target,seen)\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        src, target = tuple(source), tuple(target)\n        \n        # src\u548ctarget\u8981\u5206\u522b\u4f5c\u4e3a\u8d77\u70b9\u8bd5\u4e00\u4e0b\uff0c\u9632\u6b62target\u88ab\u5305\u56f4\u4e86\u4f46\u662fsource\u8fd8\u662f\u53ef\u4ee5\u8d70\u5f88\u8fdc\u7684\u60c5\u51b5\n        # dfs\u91cc\u7684seen\u8981\u5355\u72ec\u8f93\u5165set(), \u5426\u5219\u4f1a\u6cbf\u7528\u4e0a\u4e00\u6b21dfs\u7684seen\u800c\u5f71\u54cd\u7ed3\u679c\n        return self.dfs(src, target, set(), blocked) and self.dfs(target, src, set(), blocked)\n    \n    def dfs(self, src, target, seen, blocked):\n        \n        if len(seen) > 20000 or src == target: return True \n        \n        x0, y0 = src\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            x = x0 + dx\n            y = y0 + dy\n            if (0<=x<10**6 and 0<=y<10**6 and ((x, y) not in seen) and ((x, y) not in blocked)):\n                seen.add((x, y))\n                if self.dfs((x, y), target, seen, blocked):\n                    return True \n                \n        return False\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def method1(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked=set(map(tuple,blocked))\n            seen=set()\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c):\n                if (r,c) in seen:\n                    return False\n                \n                if [r,c]==target:\n                    return True\n                \n                if (r,c) in blocked:\n                    return False\n                \n                seen.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    if dfs(nr,nc):\n                        return True\n                return False\n            \n            return dfs(*source)\n        \n        #return method1(blocked)\n    \n        def method2(blocked):\n            if not blocked: \n                return True\n                \n            blocked = set(map(tuple, blocked))\n        \n            def check(blocked, source, target):\n                si, sj = source\n                ti, tj = target\n                level = 0\n                q = collections.deque([(si,sj)])\n                vis = set()\n                while q:\n                    for _ in range(len(q)):\n                        i,j = q.popleft()\n                        if i == ti and j == tj: return True\n                        for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                            if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                                vis.add((x,y))\n                                q.append((x,y))\n                    level += 1\n                    if level == len(blocked): \n                        return True\n                #else:\n                return False\n                #return True\n        \n            return check(blocked, source, target) and check(blocked, target, source)\n        \n        return method2(blocked)\n            \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def bfs(source, target):\n            r0, c0 = source\n            rd, cd = target\n            seen = {(r0, c0)}\n            dq = deque([(r0, c0)])\n            N = 10**6\n            cnt = 0\n            while dq:\n                r, c = dq.popleft()\n                cnt += 1\n                if r==rd and c==cd or cnt>19900: return True\n                \n                for ro, co in [(1,0), (-1,0), (0,1), (0,-1)]:\n                    nr, nc = r+ro, c+co\n                    if 0<=nr<N and 0<=nc<N and (nr, nc) not in seen and (nr, nc) not in bset:\n                        seen.add((nr, nc))\n                        dq.append((nr, nc))\n                \n            return False\n        \n        bset = {tuple(b) for b in blocked}\n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        def method1(blocked):\n            R=C=10**6\n            if not (0<=source[0]<R and 0<=source[1]<C):\n                return False\n            \n            if not (0<=target[0]<R and 0<=target[1]<C):\n                return False\n            \n            if not blocked:\n                return True\n            \n            blocked=set(map(tuple,blocked))\n            seen=set()\n            \n            def neighbors(r,c):\n                for nr,nc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n                    if 0<=nr<R and 0<=nc<C:\n                        yield nr,nc\n            \n            def dfs(r,c):\n                if (r,c) in seen:\n                    return False\n                \n                if [r,c]==target:\n                    return True\n                \n                if (r,c) in blocked:\n                    return False\n                \n                seen.add((r,c))\n                for nr,nc in neighbors(r,c):\n                    if dfs(nr,nc):\n                        return True\n                return False\n            \n            return dfs(*source)\n        \n        #return method1(blocked)\n    \n        def method2(blocked):\n            if not blocked: \n                return True\n                \n            blocked = set(map(tuple, blocked))\n        \n            def check(blocked, source, target):\n                si, sj = source\n                ti, tj = target\n                level = 0\n                q = collections.deque([(si,sj)])\n                vis = set()\n                while q:\n                    for _ in range(len(q)):\n                        i,j = q.popleft()\n                        if i == ti and j == tj: return True\n                        for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                            if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in vis and (x,y) not in blocked:\n                                vis.add((x,y))\n                                q.append((x,y))\n                    level += 1\n                    if level == len(blocked): \n                        break\n                else:\n                    return False\n                return True\n        \n            return check(blocked, source, target) and check(blocked, target, source)\n        \n        return method2(blocked)\n            \n                \n", "from collections import deque\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: return True\n        blocked = set(map(tuple, blocked))\n        \n        def check(source, target):\n            si, sj = source\n            ti, tj = target\n            level = 0\n            q = deque([(si,sj)])\n            seen = set()\n            while q:\n                for _ in range(len(q)):\n                    i, j = q.popleft()\n                    if i == ti and j == tj: return True\n                    for x,y in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):\n                        if 0<=x<10**6 and 0<=y<10**6 and (x,y) not in seen and (x,y) not in blocked:\n                            seen.add((x,y))\n                            q.append((x,y))\n                level += 1\n                if level == len(blocked): break\n            else:\n                return False\n            return True\n        \n        return check(source, target) and check(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        q1 = [tuple(source)]\n        q2 = [tuple(target)]\n        vis1 = set([tuple(source)])\n        vis2 = set([tuple(target)])\n        blocked = set([tuple(b) for b in blocked])\n        dirs = [[-1,0],[1,0],[0,-1],[0,1]]\n        \n        def valid(r, c):\n            if r>=0 and r<1000000 and c>=0 and c<1000000:\n                return True\n            return False\n        \n        while q1 and q2:\n            \n            if len(q1) > len(blocked) and len(q2) > len(blocked):\n                return True\n            \n            temp = []\n            for r, c in q1:\n                if (r, c) in vis2:\n                    return True\n                for d in dirs:\n                    nr = r+d[0]\n                    nc = c+d[1]\n                    if valid(nr, nc):\n                        if (nr,nc) not in vis1 and (nr, nc) not in blocked:\n                            temp.append((nr,nc))\n                            vis1.add((nr,nc))\n            q1 = temp\n            \n            \n            \n            temp = []\n            for r, c in q2:\n                if (r, c) in vis1:\n                    return True\n                for d in dirs:\n                    nr = r+d[0]\n                    nc = c+d[1]\n                    if valid(nr, nc):\n                        if (nr,nc) not in vis2 and (nr, nc) not in blocked:\n                            temp.append((nr,nc))\n                            vis2.add((nr,nc))\n            q2 = temp\n            \n        return False\n            \n                \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        m = 10 ** 6\n        n = len(blocked)\n        if target in blocked or source in blocked: return False\n        if n <= 1: return True\n        dxy = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n        blocked = set(map(tuple, blocked))\n        threshold = 100 * 200\n        def bfs(pos, target):\n            q = collections.deque([pos])\n            visited = {tuple(pos)}\n            cnt = 0\n            while q:\n                x, y = q.popleft()\n                if x == target[0] and y == target[1]:\n                    return 1\n                cnt += 1\n                if cnt > threshold:\n                    return 2\n                for dx, dy in dxy:\n                    x_, y_ = x + dx, y + dy\n                    if 0 <= x_ < m and 0 <= y_ < m:\n                        p = (x_, y_)\n                        if p not in visited and p not in blocked:\n                            q.append(p)\n                            visited.add(p)\n            return -1\n        \n        i = bfs(source, target)\n        print(i)\n        if i == 1:\n            return True\n        if i == -1:\n            return False\n        j = bfs(target, source)\n        print(j)\n        return j == 2\n                     \n        \n", "from collections import deque\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked or not blocked[0]:\n            return True\n        \n        blocked = set(map(tuple, blocked))\n        print(blocked)\n        return self.bfs(tuple(source), tuple(target), blocked) and self.bfs(tuple(target), tuple(source), blocked)\n        \n        \n        \n    def bfs(self, source, target, blocked):\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        queue = deque([source])\n        \n        visited = set([source])\n        \n        while queue:\n            x, y = queue.popleft()\n            for (dx, dy) in directions:\n                x_ , y_ = x + dx, y + dy\n                if 0 <= x_ < 10 ** 6 and 0 <= y_ < 10 ** 6 and (x_, y_) not in visited and (x_, y_) not in blocked:\n                    if x_ == target[0] and y_ == target[1]:\n                        return True\n                    queue.append((x_, y_))\n                    visited.add((x_, y_))\n            if len(visited) > 20000:\n                return True\n        return False\n    \n                    \n                 \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n#     def isEscapePossible(self, blocked, source, target):\n#         blocked = set(map(tuple, blocked))\n\n#         def dfs(x, y, target, seen):\n#             if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n#             seen.add((x, y))\n#             if len(seen) > 20000 or [x, y] == target: return True\n#             return dfs(x + 1, y, target, seen) or \\\\\n#                 dfs(x - 1, y, target, seen) or \\\\\n#                 dfs(x, y + 1, target, seen) or \\\\\n#                 dfs(x, y - 1, target, seen)\n#         return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())\n# Python, BFS:\n#     def isEscapePossible(self, blocked, source, target):\n#         blocked = {tuple(p) for p in blocked}\n\n#         def bfs(source, target):\n#             bfs, seen = [source], {tuple(source)}\n#             for x0, y0 in bfs:\n#                 for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n#                     x, y = x0 + i, y0 + j\n#                     if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n#                         if [x, y] == target: return True\n#                         bfs.append([x, y])\n#                         seen.add((x, y))\n#                 if len(bfs) == 20000: return True\n#             return False\n#         return bfs(source, target) and bfs(target, source)\n", "from collections import deque\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked or not blocked[0]:\n            return True\n        \n        blocked = set(map(tuple, blocked))\n\n        return self.bfs(tuple(source), tuple(target), blocked) and self.bfs(tuple(target), tuple(source), blocked)\n        \n        \n    def bfs(self, source, target, blocked):\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        queue = deque([source])\n        visited = set([source])\n        \n        while queue:\n            x, y = queue.popleft()\n            for (dx, dy) in directions:\n                x_ , y_ = x + dx, y + dy\n                if 0 <= x_ < 10 ** 6 and 0 <= y_ < 10 ** 6 and (x_, y_) not in visited and (x_, y_) not in blocked:\n                    if x_ == target[0] and y_ == target[1]:\n                        return True\n                    queue.append((x_, y_))\n                    visited.add((x_, y_))\n            if len(visited) > 20000:\n                return True\n        return False\n    \n                    \n", "class Solution:\n    \n    def isEscapePossible(self, blocked, source, target):\n        blocked = set(map(tuple, blocked))\n        source = tuple(source)\n        target = tuple(target)\n        \n        def neighbors(node):\n            i, j = node\n            return (\n                (i+di, j+dj)\n                for (di, dj) in [(-1, 0), (1, 0), (0, -1), (0, 1)]\n                if 0 <= i+di < 10**6\n                if 0 <= j+dj < 10**6\n                if (i+di, j+dj) not in blocked\n            )\n        \n        def mhat_dist(node0, node1):\n            i0, j0 = node0\n            i1, j1 = node1\n            return abs(i0-i1) + abs(j0-j1)\n        \n        stack = [source]\n        visited = {source}\n        exceeded_threshold = False\n        while stack:\n            node = stack.pop()\n            if node == target:\n                return True\n            if mhat_dist(source, node) > 200:\n                exceeded_threshold = True\n                break\n            new_nodes = set(neighbors(node)) - visited\n            visited.update(new_nodes)\n            stack.extend(new_nodes)\n            \n        if not exceeded_threshold:\n            return False\n        \n        stack = [target]\n        visited = {target}\n        while stack:\n            node = stack.pop()\n            if mhat_dist(source, node) > 200:\n                return True\n            new_nodes = set(neighbors(node)) - visited\n            visited.update(new_nodes)\n            stack.extend(new_nodes)\n        return False\n        \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked:\n            return True\n        M, N = 10 ** 6, 10 ** 6\n        blocked = set(map(tuple, blocked))\n        \n        def bfs(src, tgt):\n            q = collections.deque([tuple(src)])\n            k = 0\n            seen = set(tuple(src))\n            while q:\n                i, j = q.popleft()\n                k += 1\n                if [i, j] == tgt or k == 20000:\n                    return True\n                for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= x < M and 0 <= y < N and (x, y) not in seen and (x, y) not in blocked:\n                        seen.add((x, y))\n                        q.append((x, y))\n            return False\n        \n        return bfs(source, target) and bfs(target, source)", "from collections import deque\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: return True\n        blocked = set(tuple(b) for b in blocked)\n        \n        def util(source, target):\n            si, sj = source\n            ti, tj = target\n            step = 0\n            q = deque([(si, sj)])\n            seen = {(si, sj)}\n            \n            while q:\n                step += 1\n                if step == len(blocked): return True\n                for _ in range(len(q)):\n                    i, j = q.popleft()\n                    if i == ti and j == tj: return True\n                    for r, c in [(i-1, j), (i, j+1), (i+1,j), (i,j-1)]:\n                        if 0 <= r < 1000000 and 0 <= c < 1000000 and (r, c) not in blocked and (r, c) not in seen:\n                            seen.add((r, c))\n                            q.append((r, c))\n                            \n            return False\n        \n        return util(source, target) and util(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked:\n            return True\n        blocked = set(map(tuple, blocked))\n\n        def bfs(start: list, final: list):\n            seen, stack = {tuple(start)}, [start]\n            for x, y in stack:\n                for nx, ny in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n                    if 0 <= nx < 10 ** 6 and 0 <= ny < 10 ** 6 and (nx, ny) not in seen and (nx, ny) not in blocked:\n                        if [nx, ny] == final:\n                            return True\n                        seen.add((nx, ny))\n                        stack.append((nx, ny))\n                if len(stack) == 20000:\n                    return True\n            return False\n\n        return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = {tuple(p) for p in blocked}\n        direction = [[0,1],[0,-1],[1,0],[-1,0]]\n        \n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            \n            for x0, y0 in bfs:\n                for i, j in direction:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: \n                            return True\n                        \n                        bfs.append([x, y])\n                        seen.add((x, y))\n                        \n                if len(bfs) == 20000: \n                    return True\n                \n            return False\n        \n        return bfs(source, target) and bfs(target, source)\n    \n    \nclass Solution_:\n    def isEscapePossible_(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        queue = collections.deque()\n        direction = [[0,1],[0,-1],[1,0],[-1,0]]\n        \n        queue.append(source)\n        \n        s = set()\n        for i,j in blocked:\n            s.add((i,j))\n  \n        while queue:\n            x, y = queue.popleft()\n            \n            if [x,y] == target:\n                return True\n            \n            for xx, yy in direction:\n                if x+xx >= 0 and x+xx < 10**6 and y+yy >= 0 and y+yy < 10**6 and (x+xx,y+yy) not in s:\n                    queue.append([x+xx,y+yy])\n                    s.add((x+xx,y+yy))\n            \n        return False", "import collections\n\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        if not blocked: \n            return True\n         \n        blocked = set(map(tuple, blocked))\n        \n        \n        return self.bfs(blocked, source, target) and self.bfs(blocked, target, source)\n        \n    def bfs(self, blocked, source, target):\n        si, sj = source\n        ti, tj = target\n        \n        queue = collections.deque([(si, sj)])\n        visited = set()\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        level = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                curX, curY = queue.popleft()\n                \n                 \n                if curX == ti and curY == tj:\n                    return True\n                \n                for dx, dy in directions:\n                    newX = curX + dx\n                    newY = curY + dy\n                    if 0 <= newX < 1000000 and  0 <= newY < 1000000 and (newX, newY) not in blocked and (newX, newY) not in visited:\n                        queue.append((newX, newY))\n                        visited.add((newX, newY))\n            level += 1\n            if level == len(blocked):\n                break\n                \n        else:\n            return False\n        return True\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = {tuple(i) for i in blocked}\n        def bfs(source,target):\n            que = [source]\n            seen = {tuple(source)}\n            for x,y in que:\n                for i,j in [(0,1),(1,0),(-1,0),(0,-1)]:\n                    m,n = x+i,y+j\n                    if 0<=m<10**6 and 0<=n<10**6 and (m,n) not in seen and (m,n) not in blocked:\n                        if m == target[0] and n==target[1]:\n                            return True\n                        que.append((m,n))\n                        seen.add((m,n))\n                    if len(que)>=20000:\n                        return True\n            return False\n        return bfs(source,target) and bfs(target,source)\n", "\n# 1036. Escape a Large Maze\n\nclass Solution:\n    def isEscapePossible(self, blocked, source, target):\n        blocked = {tuple(p) for p in blocked}\n        directions = {(0, 1), (1, 0), (-1, 0), (0, -1)}\n        \n        def bfs(source, target):\n            queue, seen = [source], {tuple(source)}\n            for x0, y0 in queue:\n                for i, j in directions:\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <= y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target: \n                            return True\n                        queue.append([x, y])\n                        seen.add((x, y))\n                if len(queue) == 20000: \n                    return True\n            return False\n        \n        return bfs(source, target) and bfs(target, source)\n\n    \n    \n    \nclass Solution1:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        if not blocked:\n            return True\n        \n        rows = cols = 10**6\n        directions = {(0,1), (0,-1), (1,0), (-1,0)}\n        q1, q2 = [tuple(source)], [tuple(target)]\n        seen = set()\n        blocked = {tuple(p) for p in blocked}\n        \n        while q1:\n            next_q = []\n            # current level\n            while q1:\n                r, c = q1.pop()\n                # print(r, c, q1)\n                for dr, dc in directions:\n                    if 0 <= r+dr < rows and 0 <= c+dc < cols and (r+dr, c+dc) not in blocked and (r+dr, c+dc) not in seen:\n                        if (r+dr, c+dc) in q2 or [r+dr, c+dc] == target:\n                            return True\n                        next_q.append((r+dr, c+dc))\n                        seen.add((r+dr, c+dc))\n\n            q1 = next_q\n            if len(q1) > len(q2):\n                q1, q2 = q2, q1\n                    \n        return False\n                        \n                \n\n\n# class Solution:\n#     def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n\n#         block = set()\n#         for b in blocked:\n#             block.add((b[0], b[1]))\n            \n#         directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n#         def dfs(sx, sy, tx, ty, cx, cy, visited):\n#             if cx == tx and cy == ty:\n#                 return True\n#             if (abs(sx - cx) + abs(sy - cy)) > 200:\n#                 return True\n#             visited.add((cx, cy))\n#             for d in directions:\n#                 r = cx + d[0]\n#                 c = cy + d[1]\n                \n#                 if r >= 0 and r < 1000000 and c >=0 and r < 1000000:\n#                     if (r,c) not in block and (r, c) not in visited:\n#                         if  dfs(sx, sy, tx, ty, r, c, visited):\n#                             return True\n#             return False\n#         v1 = set()  \n#         v2 = set()\n#         r1 = dfs(source[0], source[1], target[0], target[1], source[0], source[1], v1)\n#         r2 = dfs(target[0], target[1], source[0], source[1], target[0], target[1], v2)\n#         return r1 and  r2                \n                \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        # blocked = set(map(tuple, blocked))\n\n        # def dfs(x, y, target, seen):\n        #     if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen:\n        #         return False\n\n        #     seen.add((x, y))\n\n        #     if len(seen) > 20000 or [x, y] == target:\n        #         return True\n\n        #     return dfs(x + 1, y, target, seen) \\\\\n        #         or dfs(x - 1, y, target, seen) \\\\\n        #         or dfs(x, y + 1, target, seen) \\\\\n        #         or dfs(x, y - 1, target, seen)\n\n        # return dfs(source[0], source[1], target, set()) \\\\\n        #    and dfs(target[0], target[1], source, set())\n\n\n        blocked = {tuple(p) for p in blocked}\n\n        def bfs(source, target):\n            bfs, seen = [source], {tuple(source)}\n            for x0, y0 in bfs:\n                for i, j in (0, 1), (1, 0), (-1, 0), (0, -1):\n                    x, y = x0 + i, y0 + j\n                    if 0 <= x < 10**6 and 0 <=y < 10**6 and (x, y) not in seen and (x, y) not in blocked:\n                        if [x, y] == target:\n                            return True\n                        bfs.append([x, y])\n                        seen.add((x, y))\n                if len(bfs) > 20000:\n                    return True\n\n            return False\n\n        return bfs(source, target) and bfs(target, source)\n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        m = 10 ** 6\n        n = len(blocked)\n        if target in blocked or source in blocked: return False\n        if n <= 1: return True\n        dxy = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n        blocked = set(map(tuple, blocked))\n        threshold = 150 * 150\n        def bfs(pos, target):\n            q = collections.deque([pos])\n            visited = {tuple(pos)}\n            cnt = 0\n            while q:\n                x, y = q.popleft()\n                if x == target[0] and y == target[1]:\n                    return 1\n                cnt += 1\n                if cnt > threshold:\n                    return 2\n                for dx, dy in dxy:\n                    x_, y_ = x + dx, y + dy\n                    if 0 <= x_ < m and 0 <= y_ < m:\n                        p = (x_, y_)\n                        if p not in visited and p not in blocked:\n                            q.append(p)\n                            visited.add(p)\n            return -1\n        \n        i = bfs(source, target)\n        print(i)\n        if i == 1:\n            return True\n        if i == -1:\n            return False\n        j = bfs(target, source)\n        print(j)\n        return j == 2\n                     \n        \n", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        blocked = set(map(tuple, blocked))\n        \n        def inbounds(x, y):\n            return (x >= 0 and x < 10**6 and y >= 0 and y < 10**6)\n\n        def dfs(x, y, target, seen):\n            if (x,y) in blocked or not inbounds(x,y) or (x,y) in seen:\n                return False\n            seen.add((x,y))\n            \n            if len(seen) > 30000 or [x, y] == target:\n                return True\n            \n            return dfs(x+1, y, target, seen) or dfs(x-1, y, target, seen) or dfs(x, y+1, target, seen) or dfs(x, y-1,target,seen)\n            if not (0 <= x < 10**6 and 0 <= y < 10**6) or (x, y) in blocked or (x, y) in seen: return False\n        return dfs(source[0], source[1], target, set()) and dfs(target[0], target[1], source, set())", "'''\nUsing BFS\n\nIdea and Facts\n\nAnother Reference:\nhttps://leetcode.com/problems/escape-a-large-maze/discuss/282870/python-solution-with-picture-show-my-thoughts\nhttps://assets.leetcode.com/users/2017111303/image_1556424333.png\n\nFAQ\nQuestion I think the maximum area is 10000?\nAnswer\nThe maximum area is NOT 10000. Even it's accepted with bound 10000, it's WRONG.\nThe same, the bfs with just block.size steps, is also wrong.\n\nIn the following case, the area is 19900.\nThe sum of the area available equals 1+2+3+4+5+...+198+199=(1+199)*199/2=19900 (trapezoid sum) --> Area = B*(B-1)/2\nX -> blocking points\n\n0th      _________________________\n         |O O O O O O O X\n         |O O O O O O X\n         |O O O O O X\n         |O O O O X\n         .O O O X\n         .O O X\n         .O X\n200th    |X\n\nQuestion I think the maximum area is area of a sector.\nAnswer\nAll cells are discrete, so there is nothing to do with pi.\n\n\nQuestion What is the maximum area?\nAnswer\nIt maximum blocked is achieved when the blocked squares,\nsurrounding one of the corners as a 45-degree straight line.\n\nAnd it's easily proved.\n\nIf two cells are connected horizontally,\nwe can slide one part vertically to get bigger area.\n\nIf two cells are connected vertically,\nwe can slide one part horizontally to get bigger area.\n\n\nQuestion Can we apply a BFS?\nAnswer\nYes, it works.\nBFS in 4 directions need block.length * 2 as step bounds,\nBFS in 8 directions need block.length as step bounds.\n\nIt needs to be noticed that,\nThe top voted BFS solution is WRONG with bound,\nthough it's accpected by Leetcode.\n\nBut compared with the complexity:\nSearching with limited area is O(0.5B*B).\nBFS with steps can be O(2B^B).\n\n\nIntuition\nSimple search will get TLE, because the big search space.\nAnyway, we don't need to go further to know if we are blocked or not.\nBecause the maximum area blocked are 19900.\n\n\nExplanation\nSearch from source to target,\nif find, return true;\nif not find, return false;\nif reach 20000 steps, return true.\n\nThen we do the same thing searching from target to source.\n\nComplexity\nTime complexity depends on the size of blocked\nThe maximum area blocked are B * (B - 1) / 2.\nAs a result, time and space complexity are both O(B^2)\nIn my solution I used a fixed upper bound 20000.\n'''\nclass Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        \n        blocked = set(map(tuple, blocked))\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\n        \n        def bfs(s, t):\n            bfsQ = [tuple(s)]\n            visited = {tuple(s)}\n            areaSum = 0\n            \n            for x, y in bfsQ:\n                for i,j in dirs:\n                    r = x+i\n                    c = y+j\n                    \n                    if 0 <= r < 10**6 and 0 <= c < 10**6 and (r,c) not in visited and (r,c) not in blocked:\n                        if (r,c) == tuple(t):\n                            return True\n                        bfsQ.append((r,c))\n                        visited.add((r,c))\n                        \n                if len(bfsQ) >= 20000: # max block area upper bound\n                    return True\n            \n            return False\n    \n        return bfs(source, target) and bfs(target, source)", "class Solution:\n    def isEscapePossible(self, blocked: List[List[int]], source: List[int], target: List[int]) -> bool:\n        maxlen = 10**6\n        #maxarea = (4/3.14) * 17000 # maxarea = (4/3.14) * 10000 does not work!\n        maxarea = 20000\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        blocked = set(map(tuple, blocked)) # use a set to make it faster for retrieving\n        \n        def bfs(source, target):\n            q = collections.deque()\n            aset = set()\n            q.append(source)\n            while q and len(aset) < maxarea:\n                row, col = q.popleft()\n                if row == target[0] and col == target[1]:\n                    return True\n                aset.add((row,col))\n                \n                for dir in dirs:\n                    row2 = row + dir[0]\n                    col2 = col + dir[1]\n                    if 0<=row2<maxlen and 0<=col2 < maxlen and not (row2, col2) in aset and not (row2,col2) in blocked:\n                        q.append([row2, col2])\n                        aset.add((row2, col2))\n            return len(aset) >= maxarea # evaluate by maxarea\n        return bfs(source, target) and bfs(target, source)"]
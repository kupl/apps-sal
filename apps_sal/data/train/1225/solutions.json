["t=eval(input())\ndef func(k,n,x,dist,graph):\n if k==n:\n  x+=[dist[n]]\n  return\n for i in range(1,n+1):\n  if graph[k][i]!=0 and dist[i]==-1:\n   dist[i]=dist[k]+graph[k][i]\n   func(i,n,x,dist,graph)\n   dist[i]=-1\n   \nwhile t:\n graph=[[0 for i in range(11)]for j in range(11)]\n v,e=list(map(int,input().split()))\n for i in range(e):\n  x,y,w=list(map(int,input().split()))\n  graph[x][y]=w\n  graph[y][x]=w\n x=[]\n dist=[-1]*(v+1)\n dist[1]=0\n func(1,v,x,dist,graph)\n x.sort()\n val=x[0]\n ans=0\n for i in range(len(x)):\n  if val==x[i]:\n   ans+=1\n print(ans)\n t-=1\n", "import heapq\n\n\nGraph = []\nN = 0\ndef dijkstras():\n Q = []\n visitedCount = [0]*N\n dist = [float(\"inf\")]*N\n heapq.heappush(Q, tuple([0, 0]) )\n dist[0] = 0\n visitedCount[0] = 1\n while len(Q) > 0:\n  curDist, curNode = heapq.heappop(Q)\n  for (nextNode, weight) in Graph[curNode]:\n   nextDist = curDist + weight\n   if nextDist == dist[nextNode]:\n    visitedCount[nextNode] += visitedCount[curNode]\n   elif nextDist < dist[nextNode]:\n    visitedCount[nextNode] = visitedCount[curNode]\n    dist[nextNode] = nextDist\n    heapq.heappush(Q, (nextDist, nextNode))\n\n return visitedCount[N-1]\n\ndef main():\n nonlocal N\n nonlocal Graph\n T = int(input())\n for test in range(T):\n  N, M = tuple( map(int, input().split()) )\n  Graph = []\n  for x in range(N): Graph.append([])\n  for edge in range(M):\n   Ai, Bi, Ci = tuple( map(int, input().split()) )\n   Graph[Ai-1].append((Bi-1, Ci))\n   Graph[Bi-1].append((Ai-1, Ci))\n\n  print(dijkstras())\n\ndef __starting_point():\n main()\n\n__starting_point()"]
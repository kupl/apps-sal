["from collections import Counter\nclass Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s): #return False\n            return False\n        counter = Counter(s)\n        odd_counts = 0\n        \n        for char in counter:\n            if counter[char] % 2 == 1:\n                odd_counts += 1\n        \n        return odd_counts <= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        from collections import Counter\n        if len(s) < k:\n            return False\n        oc = 0\n        for _ , val in list(Counter(s).items()):\n            if val % 2 == 1:\n                oc += 1\n        return False if oc > k else True\n        # return False if k < len([1 for _ , val in Counter(s).items() if val % 2 == 1]) else True\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n          n = len(s)\n          if n < k:\n            return False\n          if n == k:\n            return True\n\n          ch_to_cnt = collections.defaultdict(int)\n          for ch in s:\n            ch_to_cnt[ch] += 1\n\n          for cnt in ch_to_cnt.values():\n            if cnt %2 == 1:\n              k -= 1\n          return k >= 0", "from collections import defaultdict\n\nclass Solution:\n    \n    def canConstruct(self, s: str, k: int) -> bool:\n        d = defaultdict(int)\n        if len(s) < k:\n            return False\n        \n        for char in s:\n            d[char] += 1\n            \n        odd = 0\n        for key in d:\n            print(key)\n            if d[key] % 2 != 0:\n                \n                odd += 1\n        \n        return odd <= k\n", "from collections import defaultdict\n\nclass Solution:\n    \n    def canConstruct(self, s: str, k: int) -> bool:\n        d = defaultdict(int)\n        if len(s) < k:\n            return False\n        \n        for char in s:\n            d[char] += 1\n            \n        odd = 0\n        for key in d:\n            if d[key] % 2 != 0:\n                \n                odd += 1\n        \n        return odd <= k\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        c = Counter(s)\n        return sum(c.values()) >= k and len([v for v in c.values() if v % 2]) <= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        numodds = 0\n        keys = collections.defaultdict(int)\n        for c in s:\n            keys[c] += 1\n        \n        for key in keys:\n            if keys[key] % 2:\n                numodds += 1\n        \n        return numodds <= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        dictionary = {}\n        for character in s:\n            if character in dictionary:\n                dictionary[character] += 1\n            else:\n                dictionary[character] = 1\n        odd_occurences = 0\n        for e in list(dictionary.values()):\n            odd_occurences += e % 2\n        if odd_occurences > k:\n            return False\n        return True\n        \n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        dictionary = {}\n        for character in s:\n            if character in dictionary:\n                dictionary[character] += 1\n            else:\n                dictionary[character] = 1\n        odd_occurences = 0\n        for e in dictionary.values():\n            odd_occurences += e % 2\n        if odd_occurences > k:\n            return False\n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        dictionary = {}\n        for character in s:\n            if character in dictionary:\n                dictionary[character] += 1\n            else:\n                dictionary[character] = 1\n        print((list(dictionary.values())))\n        odd_occurences = 0\n        for e in list(dictionary.values()):\n            if e % 2 == 1:\n                odd_occurences += 1\n        print(odd_occurences)\n        if odd_occurences > k:\n            return False\n        return True\n        \n", "class Solution:\n    \n    def is_palindrome(self, s):\n        return bool(s == s[::-1])        \n    \n    def canConstruct(self, s: str, k: int) -> bool:\n        r_map = dict()\n        if k > len(s):\n            return False\n        for x in s:\n            if x not in r_map:\n                r_map[x] = 1\n            else:\n                r_map[x] += 1\n        odd_count = 0\n        for key in r_map:\n            if r_map[key] % 2 == 1:\n                odd_count += 1\n        return odd_count <= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        dict = {}\n        for c in s:\n            if c in dict: dict[c] += 1\n            else: dict[c] = 1\n        num_of_distinct = 0\n        for key in dict.keys():\n            if dict[key]%2 == 1: num_of_distinct += 1\n        return num_of_distinct <= k and k <= len(s)", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        if k == len(s):\n            return True\n        charCount = Counter(s)\n        countOdd = 0\n        for count in list(charCount.values()):\n            if count % 2 != 0:\n                countOdd += 1\n        return countOdd <= k\n", "class Solution:    \n    def canConstruct(self, s: str, k: int) -> bool:\n        r_map = dict()\n        if k > len(s):\n            return False\n        for x in s:\n            if x not in r_map:\n                r_map[x] = 1\n            else:\n                r_map[x] += 1\n        odd_count = 0\n        for key in r_map:\n            if r_map[key] % 2 == 1:\n                odd_count += 1\n        return odd_count <= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        \n        d = {}\n        for c in list(s):\n            if c in d:\n                d[c] += 1\n            else:\n                d[c] = 1\n            \n        print(d)\n        \n        if len(list(d.keys())) == k:\n            return True\n        else:\n            odds = 0\n            for v in list(d.values()):\n                if v % 2 == 1:\n                    odds += 1\n                    \n            return False if odds > k else True\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        \n        # return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)\n    \n#         if len(s) < k: return False\n#         seen = {}\n#         odd = 0\n#         for char in s:\n#             seen[char] = seen.get(char, 0) + 1\n        \n#         for val in seen.values():\n#             if val % 2 == 1:\n#                 odd += 1\n        \n#         if odd > k: return False\n#         return True\n        \n        \n        if len(s) < k: \n            return False\n        \n        seen = {}\n        odd = 0\n        \n        for letter in s:\n            seen[letter] = seen.get(letter, 0) + 1\n        \n        for value in seen.values():\n            if value % 2 != 0:\n                odd += 1\n        \n        if odd > k:\n            return False\n        \n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        count = {}\n        for char in s:\n            count[char] = count.get(char,0)+1\n#        print(len([char for char in count if count[char]%2==1]), count)\n        return k>=len([char for char in count if count[char]%2==1]) and k<=len(s)", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        \n        if len(s)<k:\n            return False\n        \n        dic={}\n        for sym in s:\n            if sym in dic.keys():\n                dic[sym]=1-dic[sym]\n            else:\n                dic[sym]=1\n\n        #num=sum(dic.values())\n        num=0\n        for i in dic.values():\n            num+=i\n        \n        if num<=k:\n            return True\n        else:\n            return False", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        d = {}\n        for i in range(len(s)):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n                \n        odds = 0\n        for v in d.values():\n            if v % 2 == 1:\n                odds += 1\n        return odds <= k and k <= len(s)", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        return sum(i &1 for i in collections.Counter(s).values()) <= k <= len(s)", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        d = {}\n        for i in range(len(s)):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n        odds = 0\n        for v in d.values():\n            if v % 2 == 1:\n                odds += 1\n        return odds <= k and k <= len(s) ", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n\n        dict = {}\n        for st in s:\n            if st in dict:\n                dict[st] += 1\n            else:\n                dict[st] = 1\n\n        countOddCh = 0\n        for key, v in dict.items():\n            if v % 2 != 0:\n                countOddCh += 1\n\n        if countOddCh > k:\n            return False\n\n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        \n        char_cnt = defaultdict(int)\n        for char in s:\n            char_cnt[char] += 1\n        \n        odd_cnt = 0\n        for char, cnt in char_cnt.items():\n            if cnt % 2 == 1:\n                odd_cnt += 1\n                if odd_cnt > k:\n                    return False\n        \n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if k > len(s):\n            return False\n        \n        cnt = Counter()\n        \n        for c in s:\n            cnt[c] +=1\n        \n        \n        single_nums = 0\n        \n        for key in cnt:\n            if cnt[key] % 2 == 1:\n                single_nums +=1\n        \n        if k < single_nums:\n            return False\n        \n        return True\n            \n        \n        \n            \n        \n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        odd = 0\n        counts = defaultdict(lambda: 0)\n        \n        for c in s:\n            counts[c] += 1\n            if (counts[c]%2 == 0): \n                odd -= 1\n            else:\n                 odd += 1\n        \n        if (odd > k or k>len(s)): return False\n        \n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        odd = 0\n        counts = defaultdict(lambda: 0)\n        \n        for c in s:\n            counts[c] += 1\n            if (counts[c]%2): odd += 1\n            else: odd -= 1\n        \n        if (odd > k or k>len(s)): return False\n        \n        return True", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        cnt_map = collections.defaultdict(int)\n        for c in s:\n            cnt_map[c] += 1\n        \n        n_odd = 0\n        for c in cnt_map:\n            if cnt_map[c] % 2 == 1:\n                n_odd += 1\n          \n        if n_odd <= k <= len(s):\n            return True\n        else:\n            return False\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        '''\n        Compute the frequency of each characters.\n        Count the \u5947\u6570\u6b21\u7684\u5b57\u6bcd, \n        each palindrome can consume at most one char with odd                 frequency. thus k must >= |odd|.\n        ans = k <= len(s) and k >= odd\n        '''\n        if k>len(s):\n            return False\n        freq=collections.defaultdict(int)\n        for c in s:\n            freq[c]+=1\n        odd=0\n        for c in freq:\n            odd+=freq[c]&1\n        return odd<=k", "from collections import Counter\nclass Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        counter = Counter(s)\n        count = 0\n        for key in counter:\n            if counter[key] % 2 == 1:\n                count += 1\n        return count <= k\n        \n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        if len(s) < k:\n            return False\n        cnts = collections.defaultdict(int)\n        for ch in s:\n            cnts[ch] += 1\n        odds, evens = [], []\n        for ch in cnts:\n            if cnts[ch] % 2 == 1:\n                odds.append(ch)\n            else:\n                evens.append(ch)\n        return len(odds) <= k\n                \n                \nclass Solution1:\n    def canConstruct(self, s: str, k: int) -> bool:\n        cnts = collections.defaultdict(int)\n        for ch in s:\n            cnts[ch] += 1\n        odds, evens = [], []\n        for ch in cnts:\n            if cnts[ch] % 2 == 1:\n                odds.append(ch)\n            else:\n                evens.append(ch)\n        if len(odds) > k:\n            return False\n        for i in range(len(odds)):\n            k -= 1\n            ch = odds.pop()\n            cnts[ch] -= 1\n            if cnts[ch] > 0:\n                evens.append(ch)\n        while k > len(evens):\n            if not evens:\n                return False\n            ch = evens.pop()\n            k -= 2\n            cnts[ch] -= 2\n            if cnts[ch] > 0:\n                evens.append(ch)\n        return True\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n            if k > len(s):\n                return False\n            elif k == len(s):\n                return True\n\n            seen = {}\n\n            for letter in s:\n                seen[letter] = seen.get(letter, 0) + 1\n\n            singles = 0\n\n            for key in seen:\n                value = seen[key]\n                if value % 2 == 1:\n                    singles += 1\n\n            return singles <= k\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)        ", "from collections import Counter\nclass Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        counter = Counter(s)\n        evens = 0\n        odds = 0\n        for key, value in counter.items():\n            if value % 2 == 0:\n                evens += 1\n            else:\n                odds += 1\n        return k >= odds and len(s) >= k", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        sCounter = collections.Counter(s)\n        numberOfLettersWithOddCounts = len([count for count in list(sCounter.values()) if count % 2 != 0])\n        \n        return not (len(s) < k or numberOfLettersWithOddCounts > k)\n", "class Solution:\n    def canConstruct(self, s: str, k: int) -> bool:\n        return sum(i & 1 for i in collections.Counter(s).values()) <= k <= len(s)"]
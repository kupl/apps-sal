["class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        from functools import lru_cache\n        @lru_cache(None)\n        def helper(i = 0, j = n):\n            ans = math.inf\n            for c in cuts:\n                if c <= i: continue\n                if c >= j: break\n                ans = min(ans, j - i + helper(i, c) + helper(c, j))\n            if ans == math.inf:\n                return 0\n            return ans\n        return helper()", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def cut(left, right):\n            # if not subcuts:\n            #     return 0\n            # elif (left, right) in dp:\n            #     return dp[(left, right)]\n            \n            res = right - left\n            min_subproblem = float('inf')\n            for c in cuts:\n                if left < c < right:\n                    min_subproblem = min ( min_subproblem, cut(left, c) + cut(c, right))\n            \n            if min_subproblem == float('inf'):\n                return 0\n            \n            res += min_subproblem\n            # dp[(left, right)] = res\n            return res\n        \n        # dp = {}\n        \n        return cut(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def min_cost(left_end=0, right_end=n):\n            if any(left_end < cut < right_end for cut in cuts):\n                cost = right_end - left_end\n                nxt_costs = min(\n                    min_cost(left_end, cut) + min_cost(cut, right_end)\n                    for cut in cuts\n                    if left_end < cut < right_end\n                )\n                return nxt_costs + cost\n            return 0\n        \n        return min_cost()", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def dp(l, r):\n            if any(l < c < r for c in cuts):\n                ans = r - l + min([dp(l, c) + dp(c, r) for c in cuts if l < c < r], default=0)\n                return ans\n            return 0\n        return dp(0, n)\n\n\n        \n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        @lru_cache(None)\n        def min_cost(left_end=0, right_end=n):\n            if any(left_end < cut < right_end for cut in cuts):\n                cost = right_end - left_end\n                nxt_costs = min(\n                    min_cost(left_end, cut) + min_cost(cut, right_end)\n                    for cut in cuts\n                    if left_end < cut < right_end\n                )\n                return nxt_costs + cost\n            return 0\n        \n        return min_cost()", "from functools import lru_cache\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        \n        @lru_cache(maxsize=None)\n        def dfs(l, r):\n            m = 0xffffffff\n            for c in cuts:\n                if l < c < r:\n                    m = min(m, dfs(l, c) + dfs(c, r))\n            return 0 if m == 0xffffffff else m + r - l\n\n        return dfs(0, n)", "from functools import lru_cache\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        \n        \n        lim = len(cuts)\n        \n        \n        @lru_cache(None)\n        def r(i,j):\n            \n           \n            tmp = []\n            for k in cuts:\n                if k>i and k<j:\n                    tmp.append((j-i)+r(i,k)+r(k,j))\n            if tmp==[]:return 0        \n              \n            return min(tmp)\n            \n            \n        return r(0,n)", "from itertools import permutations\nfrom functools import lru_cache\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def bin_search(t,d):\n            if t > cuts[-1]:\n                return float('inf') if d == '+' else len(cuts)-1\n            if t < cuts[0]:\n                return float('-inf') if d == '-' else 0\n            \n            l,r=0,len(cuts)-1\n            while l <= r:\n                m = (l+r)//2\n                if cuts[m] > t:\n                    r = m - 1\n                elif cuts[m] < t:\n                    l = m + 1\n                else:\n                    return m+1 if d == '+' else m-1\n            return l if d == '+' else r\n        \n        @lru_cache(None)\n        def helper(st,end):\n            # curr_cuts = [c for c in cuts if st < c < end]\n            l = bin_search(st,'+')\n            r = bin_search(end,'-')\n            # print(st,end,[cuts[i] for i in range(l,r+1)])\n            n = max(r - l + 1,0)\n            if n == 1:\n                return end-st\n            if n == 0:\n                return 0\n            \n            min_cost = float('inf')\n            for i in range(l,r+1):     \n                min_cost = min(min_cost,end-st + helper(st,cuts[i]) + helper(cuts[i],end))\n    \n            return min_cost\n    \n        cuts.sort()\n        return helper(0,n)\n\n", "from itertools import permutations\nfrom functools import lru_cache\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def helper(st,end):\n            curr_cuts = [c for c in cuts if st < c < end]\n            n = len(curr_cuts)\n            if n == 1:\n                return end-st\n            if n == 0:\n                return 0\n            \n            min_cost = float('inf')\n            for cut in curr_cuts:     \n                min_cost = min(min_cost,end-st + helper(st,cut) + helper(cut,end))\n    \n            return min_cost\n    \n        cuts.sort()\n        return helper(0,n)\n\n", "from functools import lru_cache\n\nclass Solution:\n\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        @lru_cache(None)\n        def minCost_r(k,l):\n            if l-k <= 1: return 0\n            mc = float('inf')\n            for c in cuts:\n                if c <= k or c >= l: continue\n                mc = min(mc, minCost_r(k,c) + minCost_r(c,l) + (l-k))\n            return mc if mc != float('inf') else 0\n            \n        return minCost_r(0,n)\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def solve(l, r):\n            best = n * n\n            found = False\n            for c in cuts:\n                if c <= l or c >= r:\n                    continue\n                found = True\n                best = min(best, r - l + solve(l, c) + solve(c, r))\n            \n            if not found:\n                return 0\n            return best\n        \n        return solve(0, n)", "import functools\n\nclass Solution:\n\n  @functools.lru_cache(None)\n  def dp(self, i, j):\n    # print(f\\\"{i}..{j}\\\")\n    if j - i < 2:\n      # print(f\\\"{i}..{j} -> {0}\\\")\n      return 0\n    options = [j - i + self.dp(i,k) + self.dp(k,j) for k in self.cuts if i < k and k < j]\n    if len(options) == 0:\n      # print(f\\\"{i}..{j} -> {0}\\\")\n      return 0\n    result = min(options)\n    # print(f\\\"{i}..{j} -> {result}\\\")\n    return result\n\n  def minCost(self, n: int, cuts) -> int:\n    self.cuts = cuts\n    return self.dp(0, n)\n", "from typing import List\nimport functools\n\nclass Solution(object):\n    def minCost(self, n, cuts):\n        @functools.lru_cache(None)\n        def get_cuts(l,r):\n            return [c for c in cuts if c>l and c<r] \n\n        @functools.lru_cache(None)\n        def solve(l, r):\n            mycuts= get_cuts(l,r)\n            if len(mycuts) == 1 : return r-l \n            if len(mycuts) == 0 : return 0\n\n            minn = 1e9\n            for pos in mycuts:\n                left_cost = solve(l, pos)\n                right_cost = solve(pos, r)\n                minn = min(minn, left_cost+right_cost + r-l ) \n            return minn\n\n        cuts = sorted(cuts)\n        return solve(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp={}\n        position={}\n        cuts.sort()\n        for i in range(len(cuts)):\n            position[cuts[i ]]=i\n        def f(s,e):\n            if (s,e) in dp:\n                return dp[(s,e)]\n            else:\n                res=float('inf')\n                i=0\n                if s<cuts[0]:\n                    i=0\n                else:\n                    i=position[s]+1\n                \n                # while i<len(cuts) and cuts[i]<=s:\n                #     i+=1\n                # print(\\\"i\\\"+str(i))\n                j=len(cuts)-1\n                if e>cuts[len(cuts)-1]:\n                    j=len(cuts)-1\n                else:\n                    j=position[e]-1\n                # while cuts[j]>=e and j>=0:\n                #     j-=1\n                # print(j)\n                if i>j:\n                    dp[(s,e)]=0\n                    return 0\n                for k in range(i,j+1):\n                    # dp[(s,e)]=dp[(s,cuts[k])]+dp[(cuts[k],e )]  +s-e\n                    res=min(res,f(s,cuts[k])+f(cuts[k],e)+e-s)\n                dp[(s,e)]=res\n                return dp[(s,e)]\n\n        return f(0,n)", "from collections import defaultdict\n\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dfs(start, end):\n            if (start, end) in cache:\n                return cache[(start, end)]\n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                cache[(start, end)] = 0\n            else:\n                cache[(start, end)] = end - start + min_val\n            return cache[(start, end)]\n\n        cache = defaultdict(int)\n        return dfs(0, n)\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cache = dict()\n        def recurse(start, end):\n            key = (start, end)\n            if key in cache: \n                return cache[key]\n            if start >= end:\n                return 0\n            minCost = float('inf')\n            len = end - start\n            for cut in cuts:\n                if cut > start and cut < end:\n                    first = recurse(start, cut)\n                    second = recurse(cut, end)\n                    minCost = min(minCost, len + first + second)\n            \n            if minCost == float('inf'):\n                minCost = 0\n            cache[key] = minCost\n            return minCost\n        cuts.sort()\n        ans = recurse(0, n)\n        return ans\n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        if cuts==None or len(cuts)==0:\n            return 0\n        \n        dp = defaultdict(int)\n        def dfs(start, end):\n            if (start, end) in dp:\n                return dp[(start, end)]\n            \n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                dp[(start, end)] = 0\n            else:\n                dp[(start, end)] = end - start + min_val\n            return dp[(start, end)]\n\n        return dfs(0, n)     \n        \n\n                    \n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        min_costs = {}\n        cut_set = set(cuts)\n        def find_min_cost(start: int, end: int):\n            if (start, end) in min_costs:\n                return min_costs[(start, end)]\n            cuts_in = []\n            for i in cut_set:\n                if i > start and i < end:\n                    cuts_in.append(i)\n            if len(cuts_in) == 0:\n                min_costs[(start, end)] = 0\n                return 0\n            if len(cuts_in) == 1:\n                min_costs[(start, end)] = end - start\n                return end - start\n            result = len(cuts_in) * (end - start)\n            for cut in cuts_in:\n                subresult = end - start\n                subresult += find_min_cost(start, cut)\n                subresult += find_min_cost(cut, end)\n                if subresult < result:\n                    result = subresult\n            min_costs[(start, end)] = result\n            return result\n        \n        return find_min_cost(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dfs(start, end):\n            if (start, end) in cache:\n                return cache[(start, end)]\n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    # print ('Left', left_val, 'C', c)\n                    right_val = dfs(c, end)\n                    # print ('Right', right_val, 'C', c)\n                    min_val = min(min_val, left_val + right_val)\n                    # print (\\\"Left and Right\\\", left_val, right_val)\n                    # print (\\\"MIN VAL:n \\\", min_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                cache[(start, end)] = 0\n            else:\n                cache[(start, end)] = end - start + min_val\n            return cache[(start, end)]\n\n        cache = defaultdict(int)\n        return dfs(0, n)", "from collections import defaultdict\n\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dfs(start, end):\n            if (start, end) in cache:\n                return cache[(start, end)]\n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                cache[(start, end)] = 0\n            else:\n                cache[(start, end)] = end - start + min_val\n            return cache[(start, end)]\n\n        cache = defaultdict(int)\n        return dfs(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        return self.dp(0, n, cuts, dict())\n    \n    def dp(self, i, j, cuts, memo):\n        if (i, j) not in memo:\n            minV = float('inf')\n            for k in cuts:\n                if k > i and k < j: # Valid cutting point\n                    l, r = self.dp(i, k, cuts, memo), self.dp(k, j, cuts, memo)\n                    minV = min(minV, l+r)\n            if minV != float('inf'):\n                memo[(i, j)] = minV+j-i\n            else:\n                memo[(i, j)] = 0\n        return memo[(i, j)]", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        visited = {}  # map (start, end) -> min cost\n        \n        def minCostHelper(start, end):            \n            # check if cached\n            if (start, end) in visited:\n                return visited[(start, end)]\n            \n            # if not, calculate\n            min_cost = float('inf')\n            for c in cuts:\n                if c <= start or c >= end:\n                    continue\n                cost = (end-start) + minCostHelper(start, c) + minCostHelper(c, end)\n                min_cost = min(min_cost, cost)\n                \n            if min_cost == float('inf'):\n                min_cost = 0\n                \n            visited[(start, end)] = min_cost\n            return min_cost\n        \n        return minCostHelper(0, n)\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        if cuts==None or len(cuts)==0:\n            return 0\n        \n        N = len(cuts)\n        if N==1:\n            return n\n        \n        dp = defaultdict(int)\n        def dfs(start, end):\n            if (start, end) in dp:\n                return dp[(start, end)]\n            \n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                dp[(start, end)] = 0\n            else:\n                dp[(start, end)] = end - start + min_val\n            return dp[(start, end)]\n\n        return dfs(0, n)     \n        \n\n                    \n        \n", "import sys\nclass Solution:\n    def rec(self,l,h,cuts,dp):\n        if h in dp[l]:\n            return dp[l][h] \n        ans=sys.maxsize\n        for i in cuts:\n            if l<i and i<h:\n                if i in dp[l]:\n                    k1=dp[l][i]\n                else:\n                    k1=self.rec(l,i,cuts,dp)\n                if h in dp[i]:\n                    k2=dp[i][h]\n                else:\n                    k2=self.rec(i,h,cuts,dp)\n                ans=min(ans,h-l+k1+k2)\n        if ans==sys.maxsize:\n            ans=0\n        dp[l][h]=ans\n        return dp[l][h]\n                \n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp={}\n        for i in range(n+1):\n            dp[i]={}\n        return self.rec(0,n,cuts,dp)\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        return self.dp(0, n, cuts, dict())\n    def dp(self, i, j, cuts, memo):\n        if (i, j) not in memo:\n            minV = float('inf')\n            for k in cuts:\n                if k > i and k < j: # Valid cutting point\n                    l, r = self.dp(i, k, cuts, memo), self.dp(k, j, cuts, memo)\n                    minV = min(minV, l+r)\n            if minV != float('inf'):\n                memo[(i, j)] = minV+j-i\n            else:\n                memo[(i, j)] = 0\n        return memo[(i, j)]", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        mem = collections.defaultdict()\n        \n        def dp(i, j):\n            if (i, j) in mem:\n                return mem[(i,j)]\n            ans = float('inf')\n            can_cut = False\n            for c in cuts:\n                if i < c < j:\n                    ans = min(ans, dp(i, c) + dp(c, j) + j - i)\n                    can_cut = True\n            if not can_cut:\n                ans = 0\n            mem[(i,j)] = ans\n            return ans\n        \n        ans = dp(0, n)\n        # print(mem)\n        return ans", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        visited = {}  # map (start, end) -> min cost\n        \n        def minCostHelper(start, end):            \n            # check if cached\n            if (start, end) in visited:\n                return visited[(start, end)]\n            \n            # if not, calculate\n            min_cost = float('inf')\n            for c in cuts:\n                if c <= start or c >= end:\n                    continue\n                cost = (end-start) + minCostHelper(start, c) + minCostHelper(c, end)\n                min_cost = min(min_cost, cost)\n                \n            # no cuts between start and end\n            if min_cost == float('inf'):\n                min_cost = 0\n                \n            visited[(start, end)] = min_cost\n            return min_cost\n        \n        return minCostHelper(0, n)\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp = {}\n        return self.recur(0,n, dp, cuts)\n    \n    def recur(self,l, r, dp, cuts):\n        if (l,r) in dp:\n            return dp[(l,r)]\n        \n        cost = r - l\n        res = float('inf')\n        for c in cuts:\n            if c > l and c < r:\n                res = min(res, self.recur(l,c,dp,cuts) + self.recur(c,r,dp,cuts) + cost)\n                \n        if res == float('inf'):\n            dp[(l,r)] = 0\n        else:\n            dp[(l,r)] = res\n            \n        return dp[(l,r)]\n        \n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp = {}\n        return self.recur(0,n, dp, cuts)\n    \n    def recur(self,l, r, dp, cuts):\n        if (l,r) in dp:\n            return dp[(l,r)]\n        \n        cost = r - l\n        res = float('inf')\n        for c in cuts:\n            if c > l and c < r:\n                res = min(res, self.recur(l,c,dp,cuts) + self.recur(c,r,dp,cuts) + cost)\n                \n        if res == float('inf'):\n            res = 0\n            \n        dp[(l,r)] = res\n        return dp[(l,r)]\n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp = {}\n        def dfs(i,j):\n            if(i>j):\n                return 0\n            if((i,j) in dp):\n                return dp[(i,j)]\n            ans = float('inf')\n            iscut = False;\n            for cut in cuts:\n                if(i<cut and j>cut):\n                    temp = dfs(i,cut) + dfs(cut,j)\n                    ans = min(temp, ans)\n                    iscut = True\n            if(not iscut):\n                dp[(i,j)] = 0;\n            else:\n                dp[(i,j)] = ans + j-i;\n            return dp[(i,j)]\n        return dfs(0,n)\n", "import sys\nclass Solution:\n    def __init__(self):\n        self.dp = {}\n    def minCost(self, A: int, B: List[int]) -> int:\n        self.set1 = set(B)\n        def helper(st,end):\n            if (st,end) in self.dp:\n                return self.dp[(st,end)]\n            if end-st ==1:\n                return 0\n            t = sys.maxsize\n            for i in B:\n                if i>st and i<end:\n                    t = min(t,end-st+helper(st,i)+helper(i,end))\n            self.dp[st,end] = (t if t != sys.maxsize else 0)\n            return self.dp[(st,end)]\n        \n        helper(0,A)\n        return self.dp[0,A]\n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.append(0)\n        cuts.append(n)\n        cuts.sort()\n        neighbor = dict()\n        for i, cut in enumerate(cuts):\n            if i == 0:\n                neighbor[cut] = [None, cuts[i + 1]]\n            elif i == len(cuts) - 1:\n                neighbor[cut] = [cuts[i - 1], None]\n            else:\n                neighbor[cut] = [cuts[i - 1], cuts[i + 1]]\n        \n        cache = dict()\n        # left, right are exclusive\n        def search(left: int, right: int) -> int:\n            if (left, right) in cache:\n                return cache[(left, right)]\n            \n            min_cost = None\n            for cut in cuts:\n                if cut <= left or cut >= right:\n                    continue\n                leftnei, rightnei = neighbor[cut]\n                # neighbor[leftnei][1] = rightnei\n                # neighbor[rightnei][0] = leftnei\n                \n                cost = right - left\n                cost += search(left, cut)\n                cost += search(cut, right)\n                min_cost = cost if min_cost is None else min(min_cost, cost)\n                \n                # neighbor[leftnei][1] = cut\n                # neighbor[rightnei][0] = cut\n                \n            if min_cost is None:\n                min_cost = 0\n            cache[(left, right)] = min_cost\n            return min_cost\n        \n        ans = search(0, n)\n        # print(cache)\n        return ans", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp={}\n        position={}\n        # for i in range(len(cuts)):\n        #     position[cuts[i ]]=i\n        cuts.sort()\n        def f(s,e):\n            if (s,e) in dp:\n                return dp[(s,e)]\n            else:\n                res=float('inf')\n                i=0\n                while i<len(cuts) and cuts[i]<=s:\n                    i+=1\n                # print(\\\"i\\\"+str(i))\n                j=len(cuts)-1\n                while cuts[j]>=e and j>=0:\n                    j-=1\n                # print(j)\n                if i>j:\n                    dp[(s,e)]=0\n                    return 0\n                for k in range(i,j+1):\n                    # dp[(s,e)]=dp[(s,cuts[k])]+dp[(cuts[k],e )]  +s-e\n                    res=min(res,f(s,cuts[k])+f(cuts[k],e)+e-s)\n                dp[(s,e)]=res\n                return dp[(s,e)]\n\n        return f(0,n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.memo = {}\n        cuts = set(cuts)\n\n        def dp(i, j):\n            if (i, j) in self.memo:\n                return self.memo[(i, j)]\n            min_value = None\n            for cut in cuts:\n                if (cut > i) and (cut < j):\n                    if min_value is None:\n                        min_value = dp(i, cut) + dp(cut, j) + (j - i)\n                    else:\n                        min_value = min(min_value, dp(i, cut) + dp(cut, j) + (j-i))\n\n            if min_value is None:\n                min_value = 0\n            self.memo[(i, j)] = min_value\n            return min_value\n\n        return dp(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        @lru_cache(None)\n        def dfs(i,j):\n            if i==j:\n                return 0\n            tot = float('inf') \n            for k in range(len(cuts)):\n                if i<cuts[k]<j:\n                    tot = min(tot, dfs(i, cuts[k])+dfs(cuts[k],j)+j-i)    \n            if tot == float('inf'):\n                return 0\n            return tot\n        return dfs(0,n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        dp = {}\n        def minCostij(i, j):\n            if (i,j) in dp:\n                return dp[(i,j)]\n            if i + 1 == j or i == j:\n                dp[(i,j)] = 0\n            else:\n                minCosts = [minCostij(i,k) + minCostij(k,j) for k in cuts if (k < j and k > i)]\n                if minCosts:\n                    dp[(i,j)] = min(minCosts) + (j-i)\n                else:\n                    dp[(i,j)] = 0\n            return dp[(i,j)]\n        return minCostij(0,n)\n", "from collections import defaultdict\n\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dfs(start, end):\n            if (start, end) in cache:\n                return cache[(start, end)]\n            min_val = float('inf')\n            cut_found = False\n            for c in cuts:\n                if c > start and c < end: # Important!!! check the boundary condition\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                \n            if not cut_found: # If no cut is found we know that the stick cannot be split more\n                cache[(start, end)] = 0\n            else:\n                cache[(start, end)] = end - start + min_val\n            return cache[(start, end)]\n\n        cache = defaultdict()\n        return dfs(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.memo = {}\n        # self.memo[(i, j)]\u8868\u793a\u628ai~j\u5207\u6210\u6700\u5c0f\u9700\u8981\u6700\u5c11cost \n        self.helper(0, n, cuts)\n        return self.memo[(0, n)]\n    \n    def helper(self, left, right, candidates):\n        if left >= right:\n            return 0\n        \n        if (left, right) in self.memo:\n            return self.memo[(left, right)]\n        \n        res = sys.maxsize\n        for k in candidates:\n            if k <= left or k >= right:\n                continue\n                \n            left_cost = self.helper(left, k, candidates)\n            right_cost = self.helper(k, right, candidates)\n            cost = right - left\n            \n            res = min(res, left_cost + right_cost + cost)\n        \n        \n        if res == sys.maxsize:\n            res = 0\n        self.memo[(left, right)] = res\n        return res", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        # cut.append(0)\n        # cuts.append(n)\n        # cuts.sort()\n        return self.dfs(cuts, 0, n, dict())\n    def dfs(self, cuts, i, j, memo):\n        if j-i <= 1: return 0\n        if (i, j) not in memo:\n            memo[(i, j)] = float('inf')\n            for c in cuts:\n                if c > i and c < j:\n                    memo[(i, j)] = min(memo[(i, j)], j-i+self.dfs(cuts, i, c, memo)+self.dfs(cuts, c, j, memo))\n            if memo[(i, j)] == float('inf'):\n                memo[(i, j)] = 0\n        return memo[(i, j)]\n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        return self.cut(0, n, set(cuts), {}) \n        \n    def cut(self, i, j, cuts, dp):\n        v = float('inf')\n        if (i, j) in dp:\n            return dp[(i, j)]\n        for x in cuts:\n            if i < x and j > x:\n                v = min(v, j - i + self.cut(i, x, cuts, dp) + self.cut(x, j, cuts, dp))\n        dp[(i, j)] = v if v != float('inf') else 0\n        return dp[(i, j)]", "from collections import defaultdict\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cache = defaultdict(int)\n        \n        def dfs(start, end):\n            if (start, end) in cache:\n                return cache[(start, end)]\n            \n            min_val = float('inf')\n            cut_found = False\n            \n            for c in cuts:\n                if c > start and c < end:\n                    left_val = dfs(start, c)\n                    right_val = dfs(c, end)\n                    min_val = min(min_val, left_val + right_val)\n                    cut_found = True\n                    \n            if not cut_found:\n                cache[(start, end)] = 0\n            else:\n                cache[(start, end)] = end - start + min_val\n            return cache[(start, end)]\n        \n        return dfs(0, n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        memo = {}\n        \n        def dp(start,end):\n            if (start,end) in memo:\n                return memo[(start,end)]\n            \n            ans = sys.maxsize\n            canCut = False\n            for cut in cuts:\n                if start<cut<end:\n                    canCut = True\n                    ans = min(ans, dp(start,cut) + dp(cut,end) + (end-start))\n                    \n            if not canCut:\n                return 0\n            \n            memo[(start,end)] = ans\n            \n            return ans\n    \n        return dp(0,n)\n", "class Solution:\n    def helper(self,B,s,e,d):\n        \n        if len(B)==0:\n            d[(s,e)]=0\n            return 0\n            \n        if (s,e) in d:\n            return d[(s,e)]\n        \n        \n        cost=e-s\n        m=2**31-1\n        for i in range(len(B)):\n            m=min(m,self.helper(B[:i],s,B[i],d)+self.helper(B[i+1:],B[i],e,d))\n            \n        d[(s,e)]=cost+m\n        \n        return cost+m\n    \n    def minCost(self, n: int, cuts: List[int]) -> int:\n       \n        cuts.sort()\n        d={}\n        k=self.helper(cuts,0,n,d)\n        return k\n", "from math import inf\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def recurse(l,r):\n            # if r<=l:\n            #     return inf\n            if self.dp.get((l,r),-1)!=-1:\n                return self.dp[(l,r)]\n            mnCut=inf\n            flag=1\n            for i in range(len(cuts)):\n                if l<cuts[i]<r:\n                    mnCut=min(mnCut,recurse(l,cuts[i])+recurse(cuts[i],r))\n                    flag=0\n            if flag==0:\n                self.dp[(l,r)]=mnCut+r-l\n            else:\n                self.dp[(l,r)]=0\n            return self.dp[(l,r)]\n        self.dp={}\n        cuts.sort()\n        mn=recurse(0,n)\n        # print(self.dp)\n        return mn", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        def dp(s,e):\n            if (s,e) in memo:\n                return memo[(s,e)]\n            ans=2**31\n            # print(ans)\n            canCut=False\n            for cut in cuts:\n                # canCut=True\n                if s<cut<e:\n                    canCut=True\n                    a1=dp(s,cut)+dp(cut,e)+e-s\n                    # print(a1)\n                    ans=min(ans,a1)\n            if not canCut:\n                # print(\\\"in\\\")\n                return 0\n            memo[(s,e)]=ans\n            return ans\n        \n        memo={}\n        return dp(0,n)\n        # return count\n                    \n", "class Node:\n    def __init__(self, idx, l, r):\n        self.idx = idx\n        self.l = l\n        self.r = r\n        self.left_node = self\n        self.right_node = self\n        \n\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n    \n        solved = dict()\n    \n        def cost(l, r):\n            if l == r: return 0\n            if (l, r) in solved:\n                return solved[(l, r)]\n            \n            min_cost = float('inf')\n            for c in cuts:\n                if c > l and c < r:\n                    min_cost = min(min_cost, r - l + cost(l, c) + cost(c, r))\n            \n            if min_cost == float('inf'): return 0\n            \n            solved[(l, r)] = min_cost\n            return min_cost\n        \n        return cost(0, n)\n        \n        \n'''\n\ncost(0, l - 1) -> min(cost(0, r) + cost(r, l - 1)) for r in cuts\n\n\n'''\n        \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        return self.dp(cuts, 0, n, dict())\n    \n    def dp(self, cuts, a, b, memo):\n        if (a, b) not in memo:\n            memo[(a, b)], minV = float('inf'),float('inf')\n            for j, c in enumerate(cuts):\n                if c > a and c < b:\n                    l, r = self.dp(cuts, a,c,memo), self.dp(cuts, c,b,memo)\n                    memo[(a, b)] = min(memo[(a, b)], b-a)\n                    minV = min(minV, l+r)\n            if memo[(a, b)] == float('inf'):\n                memo[(a, b)] = 0\n            else:\n                memo[(a, b)] += minV\n        return memo[(a, b)]", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        # cuts.append(0)\n        # cuts.append(n)\n        # cuts.sort()\n        return self.dp(cuts, 0, n, dict())\n    \n    def dp(self, cuts, a, b, memo):\n        if (a, b) not in memo:\n            memo[(a, b)], minV = float('inf'),float('inf')\n            for j, c in enumerate(cuts):\n                if c > a and c < b:\n                    l, r = self.dp(cuts, a,c,memo), self.dp(cuts, c,b,memo)\n                    memo[(a, b)] = min(memo[(a, b)], b-a)\n                    minV = min(minV, l+r)\n            if memo[(a, b)] == float('inf'):\n                memo[(a, b)] = 0\n            else:\n                memo[(a, b)] += minV\n        return memo[(a, b)]", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n#         cuts = sorted(cuts)\n#         options = []\n#         cuts = [0]+cuts+[n]\n#         N = len(cuts)\n#         for i in range(1, N):\n#             options.append([cuts[i-1], cuts[i]])\n        \n#         val = 0\n#         while len(options) != 1:\n#             short_i = 0\n#             min_wid = math.inf\n#             for i in range(len(options)-1):\n#                 a = options[i]\n#                 b = options[i+1]\n#                 if (a[1]-a[0]) + (b[1]-b[0]) < min_wid:\n#                     short_i = i\n#                     min_wid = (a[1]-a[0]) + (b[1]-b[0])\n                    \n#             val += min_wid\n#             options[short_i][1] = options[short_i+1][1]\n#             del options[short_i+1]\n            \n#         return val\n            \n        \n        cuts = sorted(cuts)\n        memo = {}\n        t_cuts = [0]+cuts+[n]\n        N = len(t_cuts)\n        for i in range(1, N):\n            memo[(t_cuts[i-1], t_cuts[i])] = 0\n            \n        def dp(s, e):\n            # print((s,e), memo[(s,e)] if (s,e) in memo else False)\n            if (s, e) in memo:\n                return memo[(s,e)]\n            \n            \n            filtered_cuts = [cut for cut in cuts if cut > s and cut < e]\n            if len(filtered_cuts) == 0: \n                return 0\n            \n            ans = math.inf\n            for cut in filtered_cuts:\n                ans = min(ans, (e-s) + dp(s, cut) + dp(cut, e))\n            \n            memo[(s,e)] = ans\n            return memo[(s,e)]\n        \n        \n        ans =  dp(0, n)\n        # print(memo)\n        return ans", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        def helper(cuts,memo,l,r):\n            res=float('inf')\n            key=(l,r)\n            if key in memo.keys():\n                return memo[key]\n            for i in range(len(cuts)):\n                if cuts[i]<=l or cuts[i]>=r: continue\n                cost=r-l\n                res=min(helper(cuts,memo,l,cuts[i])+cost+helper(cuts,memo,cuts[i],r),res)\n            if res==float('inf'):\n                res=0\n            memo[key]=res\n            return res\n            \n        c=collections.defaultdict(int)    \n        return helper(cuts,c,0,n)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dp(i, j, memo):\n            if (i, j) not in memo:\n                if j-i <= 1: return 0\n                memo[(i, j)] = float('inf')\n                for c in cuts:\n                    if c > i and c < j:\n                        memo[(i, j)] = min(memo[(i, j)], j-i+dp(i, c, memo)+dp(c, j, memo))\n            return memo[(i, j)] if memo[(i, j)] != float('inf') else 0\n        return dp(0, n, dict())", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n#         for total length, find the location closest to center and cut it\n#         remove that location from cuts and move on to the parts\n#         sort the cuts array, easy to find mid that way\n        \n#         cuts.sort()\n#         def cut(start, end, cuts, cuts_start, cuts_end):\n#             print(start, end, cuts_start, cuts_end)\n#             if end <= start or cuts_start > cuts_end:\n#                 return 0\n            \n#             mid = (start + end) // 2\n#             loc = bisect.bisect_left(cuts, mid, cuts_start, cuts_end)\n            \n#             print('loc', loc)\n#             if loc >= len(cuts):\n#                 return 0\n            \n#             left = cut(start, cuts[loc], cuts, cuts_start, loc - 1)\n#             right = cut(cuts[loc], end, cuts, loc + 1, cuts_end)\n#             print('price',(end - start), left , right)\n#             v =  (end - start) + left + right\n#             return v\n        \n#         print(cuts)\n#         return cut(0, n, cuts, 0, len(cuts))\n# TLE\n#         def top_down(low, high, cuts):\n#             possible_cuts = [c for c in cuts if low < c < high]\n#             # print(possible_cuts)\n#             if not possible_cuts:\n#                 return 0\n#             ans = float('inf')\n#             for mid in possible_cuts:\n#                 ans = min(ans, top_down(low, mid, cuts) + top_down(mid, high, cuts))\n#             return ans + high - low\n        \n#         return top_down(0, n, cuts)\n        dp = {}\n        def top_down(low, high, cuts):\n            if (low, high) in dp:\n                return dp[(low, high)]\n            \n            possible_cuts = [c for c in cuts if low < c < high]\n            # print(possible_cuts)\n            if not possible_cuts:\n                return 0\n            ans = float('inf')\n            for mid in possible_cuts:\n                ans = min(ans, top_down(low, mid, cuts) + top_down(mid, high, cuts))\n            dp[(low, high)] = ans + high - low\n            return dp[(low, high)]\n        \n        return top_down(0, n, cuts)\n            \n", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def dfs(i, j, memo):\n            if (i, j) not in memo:\n                if j-i <= 1: return 0\n                memo[(i, j)] = float('inf')\n                for c in cuts:\n                    if c > i and c < j:\n                        memo[(i, j)] = min(memo[(i, j)], j-i+dfs(i, c, memo)+dfs(c, j, memo))\n            return memo[(i, j)] if memo[(i, j)] != float('inf') else 0\n        return dfs(0, n, dict())", "class Solution:\n    def cal(self, i, j, cuts):\n        if i in self.dp:\n            if j in self.dp[i]:\n                return self.dp[i][j]\n        ans = float('inf')\n        cost = j - i\n        found = False\n        for ind, c in enumerate(cuts):\n            if i < c and c < j:\n                t = cuts[:]\n                del t[ind]\n                ans = min(ans, cost + self.cal(i, c, t) + self.cal(c, j, t))\n                found = True\n        if not found:\n            ans = 0\n        if i in self.dp:\n            self.dp[i][j] = ans\n        else:\n            self.dp[i] = {j: ans}\n        return ans\n    \n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.dp = {}\n        return self.cal(0, n, sorted(cuts))", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        # cut.append(0)\n        # cuts.append(n)\n        # cuts.sort()\n        return self.dfs(cuts, 0, n, dict())\n    def dfs(self, cuts, i, j, memo):\n        if j-i <= 1: return 0\n        if (i, j) not in memo:\n            memo[(i, j)] = float('inf')\n            for c in cuts:\n                if c > i and c < j:\n                    memo[(i, j)] = min(memo[(i, j)], j-i+self.dfs(cuts, i, c, memo)+self.dfs(cuts, c, j, memo))                     \n        return memo[(i, j)] if memo[(i, j)] != float('inf') else 0\n", "import itertools\nimport sys\nfrom functools import lru_cache\nfrom math import comb\nfrom typing import List\n\n'''\n\u7ed9\u4f60\u4e00\u4e2a\u6574\u6570\u6570\u7ec4 cuts \uff0c\u5176\u4e2d cuts[i] \u8868\u793a\u4f60\u9700\u8981\u5c06\u68cd\u5b50\u5207\u5f00\u7684\u4f4d\u7f6e\u3002\u5b9a\u4e49\u5207\u5272\u6210\u672c\u662f\u8981\u5207\u5272\u7684\u68cd\u5b50\u957f\u5ea6\uff0c\u6c42\u6700\u5c0f\u7684\u5207\u5272\u6210\u672c\uff0c\u5373\u627e\u5230\u4e00\u4e2a\u6700\u5c0f\u6210\u672c\u7684\u5207\u5272\u987a\u5e8f\n\n\nn = 7, cuts = [1,3,4,5]\n0 1| 2 3| 4| 5| 6 7\n\ndfs:\n        a\n      b c d\n      \ndp[start][end]= min(dp[start][cut] + dp[cut][end])\n\u659c\u5411\u4e0a\u626b\u63cf\u3002\n\n\n'''\n\n\nclass Solution1:\n    def dfs(self, start, end, path, cuts):\n        if self.dp[start][end] != sys.maxsize:\n            return self.dp[start][end]\n        min_cut = sys.maxsize\n        flag = False\n        nums = cuts[self.cuts_map[start]:self.cuts_map[end]]\n        for cut in nums:\n            if cut not in path and start < cut and cut < end:\n                flag = True\n                path.add(cut)\n                min_cut = min(min_cut, end - start + self.dfs(start, cut, path, cuts) + self.dfs(cut, end, path, cuts))\n                path.remove(cut)\n        # \u5982\u679c\u6ca1\u5207\u5272\u70b9\u5219\u8fd4\u56de0\n        if not flag:\n            min_cut = 0\n        self.dp[start][end] = min_cut\n        return min_cut\n\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.dp = [[sys.maxsize for _ in range(n + 1)] for _ in range(n + 1)]\n        cuts = sorted(cuts)\n        self.cuts_map = {}\n        for i, cut in enumerate(cuts):\n            self.cuts_map[cut] = i\n        self.cuts_map[0] = 0\n        self.cuts_map[n] = n\n        return self.dfs(0, n, set(), cuts)\n\n    \nclass Solution:\n    def dfs(self, start, end, path, cuts):\n        if self.dp[self.cuts_map[start]][self.cuts_map[end]] != sys.maxsize:\n            return self.dp[self.cuts_map[start]][self.cuts_map[end]]\n        min_cut = sys.maxsize\n        flag = False\n        nums = cuts[self.cuts_map[start]:self.cuts_map[end]]\n        for cut in nums:\n            if cut not in path and start < cut and cut < end:\n                flag = True\n                path.add(cut)\n                min_cut = min(min_cut, end - start + self.dfs(start, cut, path, cuts) + self.dfs(cut, end, path, cuts))\n                path.remove(cut)\n        # \u5982\u679c\u6ca1\u5207\u5272\u70b9\u5219\u8fd4\u56de0\n        if not flag:\n            min_cut = 0\n        self.dp[self.cuts_map[start]][self.cuts_map[end]] = min_cut\n        return min_cut\n\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.dp = [[sys.maxsize for _ in range(len(cuts) + 2)] for _ in range(len(cuts) + 2)]  # \u5185\u5b58\u592a\u5927\uff0c\u9700\u8981\u4f18\u5316\n        cuts.extend([0, n])\n        cuts = sorted(cuts)\n        self.cuts_map = {}\n        for i, cut in enumerate(cuts):\n            self.cuts_map[cut] = i\n        return self.dfs(0, n, set(), cuts)", "class Solution:\n    def cal(self, i, j, cuts):\n        if i in self.dp:\n            if j in self.dp[i]:\n                return self.dp[i][j]\n        ans = float('inf')\n        cost = j - i\n        found = False\n        for ind, c in enumerate(cuts):\n            if i < c and c < j:\n                t = cuts[:]\n                del t[ind]\n                ans = min(ans, cost + self.cal(i, c, t) + self.cal(c, j, t))\n                found = True\n        if not found:\n            ans = 0\n        if i in self.dp:\n            self.dp[i][j] = ans\n        else:\n            self.dp[i] = {j: ans}\n        return ans\n    \n    def minCost(self, n: int, cuts: List[int]) -> int:\n        self.dp = {}\n        return self.cal(0, n, cuts)", "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        def top_down(i, j, memo):\n            if (i, j) not in memo:\n                # If length of current stick is less than or equal to one, we can't cut any further so cost will be zero.\n                if j-i <= 1: return 0\n                memo[(i, j)] = float('inf')\n                for c in cuts:\n                    # If c is not in the range of (i, j) exclusive, cut cannot be performed.\n                    if c > i and c < j:\n                        memo[(i, j)] = min(memo[(i, j)], j-i+top_down(i, c, memo)+top_down(c, j, memo))\n            # if no valid cutting position, return 0 otherwise return optmal solution.\n            return memo[(i, j)] if memo[(i, j)] != float('inf') else 0\n        return top_down(0, n, dict())"]
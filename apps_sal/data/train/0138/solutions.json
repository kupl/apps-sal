["class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        maxx = 0\n        nums.append(0)\n        \n        # starting position\n        # where we find a 0\n        i = -1\n        minusarr = []\n        \n        for j,n in enumerate(nums):\n            if n == 0:\n                # now figure out previous ones\n                tot = j-i-1\n                if not minusarr or len(minusarr)%2 == 0:\n                    maxx = max(maxx, tot)\n                else:\n                    # drop the first or last 0\n                    left = minusarr[0]-i\n                    right = j-minusarr[-1]\n                    maxx = max(maxx, tot - min(left, right))\n                \n                # reinitiate\n                minusarr = []\n                i = j\n            elif n < 0:\n                minusarr.append(j)\n        return maxx", "class Solution:\n    def getMaxLen(self, a: List[int], having_zero=True) -> int:\n        if not a: return 0\n        if having_zero: \n            zeros = [i for i, x in enumerate(a) if x == 0]        \n            ans, prev = -float('inf'), 0            \n            for i in zeros:\n                ans = max(ans, self.getMaxLen(a[prev:i], False))\n                prev = i+1\n            ans = max(ans, self.getMaxLen(a[prev:], False))\n            return ans        \n        negs = [i for i, x in enumerate(a) if x < 0]\n        if len(negs) % 2 == 0: return len(a)\n        return max(negs[-1], len(a) - negs[0] - 1)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # Greedy alg\n        l = len(nums)\n        start = 0\n        subArrays = []\n        for i in range(l):\n            if nums[i] == 0:\n                subArrays.append(self.findOptimal(nums[start:i]))\n                start = i+1\n                end = i+1\n        \n        subArrays.append(self.findOptimal(nums[start:l]))\n        \n        return max(subArrays)\n    \n    def findOptimal(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        negs = 0\n        l = 0\n        for i in nums:\n            l += 1\n            if i < 0: negs += 1\n        \n        if negs % 2 == 0:\n            return l\n        else:\n            # Two pointers approach\n            i = 0\n            j = l - 1\n            while i < j:\n                if nums[i] < 0 or nums[j] < 0:\n                    return l - 1\n                i += 1\n                j -= 1\n                l -= 1\n        \n        #return max(self.findOptimal(nums[1:]), self.findOptimal(nums[:-1]))\n        return 0", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        \n        pos_p=0\n        neg_p=0\n        \n        pos,neg=0,0\n        \n        result=0\n        for i in range( len(nums)):\n            \n            pos_p,neg_p=pos,neg\n            \n            if nums[i] > 0:\n                pos= 1 + pos_p\n                neg= 1 + neg_p if neg_p > 0 else 0\n                \n            elif nums[i] < 0:\n                pos= (1 + neg_p) if neg_p > 0 else 0\n                neg= (1 + pos_p) if pos_p > 0 else 1\n            else:\n                pos,neg=0,0\n            result=max(result, pos)\n            \n        return result", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # 3:58 9/1/2020\n        # Max len of subarray with positive Product\n        \n        last={1:-1}\n        pro=1\n        ans=0\n        for i,c in enumerate(nums):\n            pro = c * pro / abs(pro) if pro != 0 else 0\n            \n            if pro>0:\n                ans=max(i-last[1],ans)\n                \n            elif pro<0:\n                if -1 in last:\n                    ans=max(ans,i-last[-1])\n                else:\n                    last[-1]=i\n            elif pro==0:\n                pro=1\n                last={}\n                last[1]=i\n          \n        return ans \n                        \n                    \n                \n        \n        \n \n        \n\n                    \n                    \n                    \n                    \n                \n            \n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0] * (n+1) for i in range(2)]\n        for i, x in enumerate(nums):\n            if x > 0:\n                dp[0][i+1] = dp[0][i] + 1\n                if dp[1][i] > 0:\n                    dp[1][i+1] = dp[1][i] + 1\n            elif x < 0:\n                if dp[1][i] > 0:\n                    dp[0][i+1] = dp[1][i] + 1\n                dp[1][i+1] = dp[0][i] + 1\n            else:\n                dp[0][i+1] = dp[1][i+1] = 0\n                \n        # print(dp)\n        return max(dp[0])\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n=len(nums)\n        pos,neg=0,0\n        [0,1,-2,-3,-4]\n        if nums[0]>0:\n            pos=1\n        if nums[0]<0:\n            neg=1\n        ans=pos\n        for i in range(1,n):\n            if nums[i]>0:\n                pos = 1 + pos\n                neg = 1 + neg if neg >0 else 0\n            elif nums[i]<0:\n                pre_pos,pre_neg=pos,neg\n                pos= 1 + pre_neg if pre_neg >0 else 0\n                neg = 1 + pre_pos\n            else:\n                pos,neg =0,0\n            ans = max(ans,pos)\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        plus,minus,res,c = 0,-1,0,0\n        for i in range(0,len(nums)):\n            if nums[i] == 0:\n                if c%2 == 1:\n                    res = max(res,minus)\n                else:\n                    res = max(res,max(plus,minus))\n                plus,minus,c = 0,-1,0\n            elif nums[i] > 0:\n                if minus != -1: \n                    minus += 1\n                plus += 1\n            else:\n                c += 1\n                minus += 1\n                if c%2 == 1:\n                    res = max(res,max(minus,plus))\n                plus += 1\n        if c%2 == 1:\n            res = max(res,minus)\n        else:\n            res = max(res,max(plus,minus))\n        return res\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def solve(nums):\n            cnt = 0\n            for n in nums:\n                if n < 0:\n                    cnt += 1\n            if cnt%2 == 0:\n                return len(nums)\n            for i in range(len(nums)):\n                if nums[i] < 0:\n                    first = i\n                    break\n            for i in range(len(nums)-1, -1, -1):\n                if nums[i] < 0:\n                    last = i\n                    break\n            return max(last, len(nums)-first-1)\n        \n        l = 0\n        ans = 0\n        nums.append(0)\n        for r in range(len(nums)):\n            if nums[r] == 0:\n                cur = solve(nums[l:r])\n                ans = max(ans, cur)\n                l = r+1\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        @lru_cache(None)\n        def pos_helper(len):\n            if len == 0:\n                return 0\n            if len == 1:\n                return 1 if nums[0] > 0 else 0\n            if nums[len - 1] > 0:\n                return pos_helper(len - 1) + 1\n            if nums[len - 1] == 0:\n                return 0\n            if nums[len - 1] < 0:\n                return neg_helper(len - 1) + 1 if neg_helper(len - 1) != 0 else 0\n\n        @lru_cache(None)\n        def neg_helper(len):\n            if len == 0:\n                return 0\n            if len == 1:\n                return 1 if nums[0] < 0 else 0\n            if nums[len - 1] > 0:\n                return neg_helper(len - 1) + 1 if neg_helper(len - 1) > 0 else 0\n            if nums[len - 1] == 0:\n                return 0\n            if nums[len - 1] < 0:\n                return pos_helper(len - 1) + 1\n\n        res = 0\n        for i in range(0, len(nums) + 1):\n            res = max(res, pos_helper(i))\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = 0, 0\n        if nums[0] > 0: pos = 1\n        if nums[0] < 0: neg = 1\n        ans = pos\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos_next = 1 + pos\n                neg_next = 1 + neg if neg > 0 else 0\n            elif nums[i] < 0:\n                pos_next = 1 + neg if neg > 0 else 0\n                neg_next = 1 + pos\n            else:\n                pos_next, neg_next = 0, 0\n            pos, neg = pos_next, neg_next\n            ans = max(ans, pos)\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        maxlen = 0\n        curlen = 0\n        tmplen = 0\n        even = True \n        for i in nums:\n            if i == 0:\n                if tmplen != curlen:\n                    # We meet odd numbers of negative number, check if the rest is larger\n                    maxlen = max(maxlen, tmplen - curlen - 1)\n                maxlen = max(maxlen, curlen)\n                curlen = 0\n                tmplen = 0\n                even = True\n                continue\n            tmplen += 1    \n            if i < 0:    \n                even = not even\n                if even == True:\n                    curlen = tmplen        \n            if i > 0 and even == True:\n                curlen += 1      \n        if tmplen != curlen:\n            # We meet odd numbers of negative number, check if the rest is larger\n            maxlen = max(maxlen, tmplen - curlen - 1)\n        maxlen = max(maxlen, curlen)        \n        \n        curlen = 0\n        tmplen = 0\n        even = True \n        for i in reversed(nums):\n            if i == 0:\n                if tmplen != curlen:\n                    # We meet odd numbers of negative number, check if the rest is larger\n                    maxlen = max(maxlen, tmplen - curlen - 1)\n                maxlen = max(maxlen, curlen)\n                curlen = 0\n                tmplen = 0\n                even = True\n                continue\n            tmplen += 1    \n            if i < 0:    \n                even = not even\n                if even == True:\n                    curlen = tmplen        \n            if i > 0 and even == True:\n                curlen += 1      \n        if tmplen != curlen:\n            # We meet odd numbers of negative number, check if the rest is larger\n            maxlen = max(maxlen, tmplen - curlen - 1)\n        maxlen = max(maxlen, curlen)        \n        \n        return maxlen       \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        pos = 1 if nums[0]>0 else 0\n        neg = 1 if nums[0]<0 else 0\n        \n        ans = pos\n        \n        for i in range(1,len(nums)):\n            if nums[i]>0:\n                pos = 1+pos\n                neg = 1+neg if neg>0 else 0\n            elif nums[i]<0:\n                pre_pos = pos\n                pos = 1+neg if neg>0 else 0\n                neg = 1+pre_pos\n            else:\n                pos, neg = 0, 0\n                \n            ans = max(ans,pos)\n            \n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        result = 0\n        negativeIndices = []\n        currentProduct = 1\n        startIndex = 0\n        \n        for index,number in enumerate(nums):\n            if number == 0:\n                negativeIndices = []\n                currentProduct = 1\n                startIndex = index + 1\n                continue\n        \n            if number * currentProduct > 0:\n                result = max(result,index-startIndex+1)\n                currentProduct = 1\n            \n            else: \n                if len(negativeIndices) != 0:\n                    result = max(result,index-negativeIndices[0])\n                currentProduct = -1\n            \n            if number < 0 and len(negativeIndices) == 0:\n                negativeIndices.append(index)\n  \n        return result", "class Solution:\n    def getMaxLen(self, A: List[int], cnt = 0, best = 0) -> int:\n        A.append(0)                    # \u2b50\ufe0f sentinel value\n        N = len(A)\n        i = 0\n        j = 0\n        while i < N:\n            while j < N and not A[j]:  # \u2796 case 1: collapse window [i \\\\U0001f449 ..j]\n                while i < j:\n                    cnt = cnt - 1 if A[i] < 0 else cnt; i += 1\n                    best = best if cnt & 1 else max(best, j - i)\n                i = j + 1\n                j = j + 1\n            while j < N and A[j]:      # \u2795 case 2: expand window [i..j \\\\U0001f449 ]\n                cnt = cnt + 1 if A[j] < 0 else cnt; j += 1\n                best = best if cnt & 1 else max(best, j - i)\n        return best\n    \n    \n    \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = 0\n        neg = 0\n        negIndex = 0\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                pos = 0\n                neg = 0\n            elif nums[i] > 0:\n                pos += 1\n            else:\n                neg += 1\n                if neg == 1:\n                    negIndex = i\n                \n            if neg % 2 == 0:\n                res = max(res, pos + neg)\n            else:\n                res = max(res, i - negIndex)\n        return res \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pointer1=0\n        pointer2=0\n        res=0\n        while(pointer1<len(nums)):\n            if nums[pointer1]==0:\n                pointer1+=1\n                continue\n            pointer2=pointer1\n            count=0\n            start=0\n            end=0\n            while(pointer2<len(nums) and nums[pointer2]!=0):\n                if nums[pointer2]<0:\n                    count+=1\n                    if count==1:\n                        start=pointer2\n                    end=pointer2\n                pointer2+=1\n            if count%2==0:\n                res=max(res,pointer2-pointer1)\n            else:\n                res=max(res,end-pointer1,pointer2-start-1)\n            pointer1=pointer2\n            \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums: return 0\n\n        n = len(nums)\n        negNum = 0\n        firstNegIdx = -1\n        zeroPos = -1\n        res = 0\n        \n        for i, num in enumerate(nums):\n            if num < 0:\n                negNum += 1\n                if firstNegIdx < 0: firstNegIdx = i\n            \n            if num == 0:\n                negNum = 0\n                firstNegIdx = -1\n                zeroPos = i\n            else:\n                if negNum % 2 == 0:\n                    res = max(res, i - zeroPos)\n                else:\n                    res = max(res, i - firstNegIdx)\n                    \n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res, pos, neg = 0, 0, 0\n        for num in nums:\n            if num == 0:\n                pos, neg = 0, 0\n            elif num > 0:\n                if neg != 0: neg, pos = neg+1, pos+1\n                else: neg, pos = 0, pos+1\n            else:\n                if neg != 0: pos, neg = neg+1, pos+1\n                else: neg, pos = pos+1, 0\n            res = max(res, pos)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans=0\n        mn=0\n        mp=0\n        for i in nums:\n            if i==0:\n                mn,mp=0,0\n            elif i>0:\n                mp+=1\n                if mn!=0:\n                    mn+=1\n                else:mn=0\n            else:\n                omn=mn\n                mn=mp+1\n                if omn!=0:\n                    mp=omn+1\n                else:\n                    mp=0\n            ans=max(mp,ans)\n        return ans\n                    \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # dp = [[0 for i in range(2)]  for j in  range(len(nums) + 1)]\n        # res = 0\n        # for i, num in enumerate(nums):\n        #     if num == 0:\n        #         dp[i + 1][0] = dp[i + 1][1] = 0\n        #     elif num > 0:\n        #         dp[i + 1][0] = dp[i][0] + 1\n        #         dp[i + 1][1] = dp[i][1] + 1 if dp[i][1] else 0\n        #     else:\n        #         dp[i + 1][0] = dp[i][1] + 1 if dp[i][1] else 0\n        #         dp[i + 1][1] = dp[i][0] + 1\n        #     res = max(res, dp[i + 1][0])\n        # return res\n        pos_num = neg_num = res = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                pos_num = neg_num = 0\n            elif num > 0:\n                neg_num = neg_num + 1 if neg_num else 0\n                pos_num += 1\n            else:\n                cur_pos = pos_num\n                pos_num = neg_num + 1 if neg_num else 0\n                neg_num = cur_pos + 1\n            res = max(res, pos_num)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        def helper(arr):\n            inds = []\n            for i,num in enumerate(arr):\n                if num<0:\n                    inds.append(i)\n            if len(inds)%2==0:\n                return len(arr)\n            else:\n                first = max(inds[0],len(arr)-inds[0]-1)\n                second = max(inds[-1],len(arr)-inds[-1]-1)\n                return max(first,second)\n                \n            \n        temp = []\n        for i,num in enumerate(nums):\n            if num==0:\n                temp.append(i)\n        pos = []\n        if temp:\n            if nums[:temp[0]]:\n                pos.append(nums[:temp[0]])\n            for i in range(0,len(temp)-1):\n                pos.append(nums[temp[i]+1:temp[i+1]])\n            if nums[temp[-1]+1:]:\n                pos.append(nums[temp[-1]+1:])\n        else:\n            pos.append(nums)\n        ans = 0\n        for arr in pos:\n            ans = max(ans,helper(arr))\n        return ans\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        lists = [[]]\n        negative = [[]]\n        index = 0\n        for num in nums:\n            if num == 0:\n                index = 0\n                negative.append([])\n                lists.append([])\n            else:\n                if num < 0:\n                    negative[-1].append(index)\n                lists[-1].append(num)\n                index += 1\n\n        max_len = 0\n        for l, neg in zip(lists, negative):\n            if len(neg) % 2 == 1:\n                dist = min(neg[0] + 1, len(l) - neg[-1])\n            else:\n                dist = 0\n            max_len = max(len(l) - dist, max_len)\n        \n        return max_len\n", "import copy\nimport math\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        positive,negative = 0,0\n        length = 0\n        for n in nums:\n            if  n == 0:\n                positive,negative = 0,0\n            elif n > 0:\n                if negative > 0 : positive,negative = positive+1,negative+1\n                else: positive,negative = positive+1,0\n            else:\n                if negative > 0 : positive,negative = negative+1,positive+1\n                else: positive,negative = 0,positive+1\n            length = max(length,positive)\n        return length", "import numpy as np\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if len(nums)==0: return (0)\n        if len(nums)==1:return( 1 if nums[0]>0 else 0)\n        St=[i for i,j in enumerate(nums) if (i==0 and j!=0) or (nums[i-1]==0 and j!=0)]\n        if len(St)==0: return (0)\n        Ed=[i for i,j in enumerate(nums) if (i==len(nums)-1 and j!=0) or (i<len(nums)-1 and nums[i+1]==0 and j!=0)]\n        # print(St,Ed)\n        Sta=np.array(St)\n        Eda=np.array(Ed)\n        Lns=(-(Eda-Sta+1)).argsort()\n        # print(Lns)\n        k=0\n        mxLen=0\n        while(k<len(Lns)):\n            nums1=nums[St[Lns[k]]:(Ed[Lns[k]]+1)]\n            if len(nums1)==mxLen: return(mxLen)\n            ni=[i for i,j in enumerate(nums1) if j<0]\n            if len(ni)==0 or len(ni)%2==0:mxLen=max(mxLen,len(nums1))\n            else:\n                mn=min(ni)\n                mx=max(ni)\n                mxLen= max(mxLen,mn,len(nums1)-mn-1,mx,len(nums1)-mx-1)\n            k=k+1\n        return(mxLen)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        p = 1\n        j = None\n        k = -1\n        m = 0\n        for i, n in enumerate(nums):\n            if not n:\n                p = 1\n                j = None\n                k = i\n            else:\n                if n < 0:\n                    p *= -1\n                elif not n:\n                    p = 0\n                if p > 0:\n                    m = max(m, i-k)\n                elif p < 0:\n                    if j is None:\n                        j = i\n                    else:\n                        m = max(m, i-j)\n        return m\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # DP may be unnecessary, but because I saw max length subarray\n        # I assumed that it would be DP. Solution approach was DP-esque\n        # but it doesn't seem necessary.\n        # Seems like another way could be to just count the number of\n        # negatives (between 0s).\n        p = 0\n        n = 0\n        longest_p = 0\n        for num in nums:\n            longest_p = max(longest_p, p)\n            if num == 0:\n                p = 0\n                n = 0\n            elif num > 0:\n                prev_p = p\n                prev_n = n\n                p = prev_p + 1\n                if prev_n > 0:\n                    n = prev_n + 1\n                else:\n                    n = 0\n            elif num < 0:\n                prev_p = p\n                prev_n = n\n                n = prev_p + 1\n                if prev_n > 0:\n                    p = prev_n + 1\n                else:\n                    p = 0\n        longest_p = max(longest_p, p)\n        return longest_p\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1 if nums[0] > 0 else 0 \n        p1 = p2 = 0\n        answer = 0\n        curr_len = 0 \n        neg_indx = deque([])\n        while p2 < n:\n            num = nums[p2]\n            if num == 0:\n                answer = max(answer, curr_len)\n                curr_len = 0 \n                p2 += 1\n                p1 = p2 \n                neg_indx = deque([])\n            elif num > 0:\n                curr_len += 1 \n                answer = max(answer, curr_len) \n                p2 += 1 \n            else:\n                neg_indx.append(p2)\n                j = p2+1\n                found = False\n                while j < n:\n                    num2 = nums[j]\n                    if num2 <= 0:\n                        if num2 < 0:\n                            neg_indx.append(j)\n                            found = True \n                        break\n                    j += 1 \n                if found:\n                    curr_len += (j-p2+1)\n                    answer = max(answer, curr_len)\n                    if j == n-1:\n                        return answer \n                    else:\n                        p2 = j + 1 \n                else: \n                    first_neg = neg_indx.popleft()\n                    while p1 <= first_neg:\n                        p1 += 1\n                        curr_len -= 1\n                    if p1 > p2:\n                        p2 = p1\n                        answer = max(answer, curr_len)\n                        curr_len = 0 \n                    else:\n                        curr_len += 1\n                        p2 += 1\n                    continue  \n        return answer \n    \n    \n#[1, -4, 3, 2, 0, 2, -2, 3, -2, -2, 3, 4, 5]\n", "class Solution:\n    def getMaxLen(self, nums):\n        \n        if len(nums) == 0:\n            return True\n        \n        result = 0\n        count = 0\n        zero_marker = -1\n        negative_marker = -1\n       \n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zero_marker = i\n                count = 0\n                negative_marker = -1\n                \n\n            else:\n                if nums[i] < 0:\n                    count += 1\n                    if negative_marker == -1:\n                        negative_marker = i\n            \n                if count % 2 == 0:\n                    result = max(result, i - zero_marker)\n                else:\n                    result = max(result, i - negative_marker)\n        return result      ", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        neg = pos = res = 0\n        for n in nums:\n            if n == 0:\n                neg = pos = 0\n            elif n > 0:\n                if neg:\n                    neg += 1\n                pos += 1\n            else:\n                pos, neg = neg + 1 if neg else 0, pos + 1\n            res = max(res, pos)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        def get_val(nums):\n            # print(nums)\n            if len(nums) == 0:\n                return 0\n            products = [1]\n            product = 1\n            length = len(nums)\n            for i in range(length):\n                product *= nums[i]\n                products.append(product)\n            for j in range(length, 0, -1):\n                for k in range(length-j+1):\n                    value = products[k+j]//products[k]\n                    if value>0:\n                        return j\n            return 0\n        index = 0\n        maximum = 0\n        for i in range(n):\n            if nums[i] == 0:\n                if i == index:\n                    index += 1\n                    continue\n                value = get_val(nums[index:i])\n                if value>maximum:\n                    maximum = value\n                index = i+1\n            elif nums[i]>0:\n                nums[i] = 1\n            else:\n                nums[i] = -1\n        value = get_val(nums[index:n])\n        if value>maximum:\n            maximum = value\n        return maximum", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        maxl = 0\n        pos = 0\n        neg = 0\n        for n in nums:\n            if n == 0:\n                pos, neg = 0, 0\n            elif n > 0:\n                pos += 1\n                neg = neg + 1 if neg != 0 else 0\n            elif n < 0:\n                oldneg = neg\n                neg = pos + 1\n                pos = oldneg + 1 if oldneg > 0 else 0\n            maxl = max(maxl, pos)\n        \n        return maxl\n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        def oddMinus(ls):\n            ret = 0\n            for i in range(len(ls)):\n                if ls[i] < 0:\n                    ret = max(max(ret, i), len(ls)-1-i)\n            return ret\n        \n        def getLen(ls):\n            minus = 0\n            for i in ls:\n                if i < 0:\n                    minus += 1\n            if(minus % 2 == 0):\n                return len(ls)\n            else:\n                return oddMinus(ls)\n        \n        \n        s = []\n        sub = []\n        for i in nums:\n            if i == 0:\n                s.append(sub)\n                sub = []\n            else:\n                sub.append(i)\n        s.append(sub)\n        \n        res = 0\n        \n        for ls in s:\n            res = max(res, getLen(ls))\n            \n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        l = []\n        neg = []\n        index = 0\n        max_len = 0\n        for num in nums:\n            if num == 0:\n                index = 0\n                if len(neg) % 2 == 1:\n                    dist = min(neg[0] + 1, len(l) - neg[-1])\n                else:\n                    dist = 0\n                max_len = max(len(l) - dist, max_len)\n                l.clear()\n                neg.clear()\n            else:\n                if num < 0:\n                    neg.append(index)\n                l.append(num)\n                index += 1\n        \n        if len(neg) % 2 == 1:\n            dist = min(neg[0] + 1, len(l) - neg[-1])\n        else:\n            dist = 0\n        max_len = max(len(l) - dist, max_len)\n\n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans\n\n\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ret = 0\n        pos, neg = -1, None\n        curr = 0\n        for i, n in enumerate(nums):\n            if n == 0:\n                pos, neg = i, None\n                curr = 0\n            else:\n                if n < 0:\n                    curr = 1 - curr\n            \n                if curr == 0:    \n                    ret = max(ret, i - pos)\n                \n                if curr == 1:\n                    if neg is not None:\n                        ret = max(ret, i - neg)\n                    else:\n                        neg = i\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        nums.append(0)\n        start = -1\n        i = 0\n        firstn = -1\n        maxl = 0\n        nneg = 0\n        while i<len(nums):\n            if nums[i]<0:\n                nneg += 1\n                if firstn<0: firstn = i\n                lastn = i\n            elif nums[i] == 0:\n                if nneg%2 == 0:\n                    maxl = max(maxl,i-start-1)\n                else:\n                    maxl = max([maxl,lastn-start-1,i-firstn-1])\n                start = i\n                nneg = 0\n                firstn = -1\n            i += 1\n        return maxl", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def dfs(start):\n            i = start\n            if i >= len(nums):\n                return 0\n            ret = 0\n            stack = []\n            while i < len(nums):\n                if nums[i] == 0:\n                    break\n                elif nums[i] < 0:\n                    stack.append(i)\n                i+=1\n            if len(stack) % 2 == 0:\n                ret = i - start\n            else:\n                ret = max(i-1-stack[0],stack[-1]-start)\n            \n            return max(ret,dfs(i+1))\n        return dfs(0)\n                    \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def solve(arr):\n            maxy = 0\n            count = 0\n            for i in j:\n                if i < 0:\n                    count += 1\n            if count % 2 == 0:\n                maxy = max(maxy,len(j))\n            else:\n                for i in range(len(j)):\n                    if j[i] < 0:\n                        m1 = i \n                        m2 = len(j) - m1 -1 \n                        m3 = max(m1,m2)\n                        maxy = max(maxy,m3)\n                        break\n                for i in range(len(j)-1,-1,-1):\n                    if j[i] < 0:\n                        m1 = i \n                        m2 = len(j) - m1 - 1 \n                        m3 = max(m1,m2)\n                        maxy = max(maxy,m3)\n                        break\n            return maxy\n        res = []\n        maxy = 0\n        flag = 1\n        i = 0\n        for j in range(i,len(nums)):\n            if nums[j] == 0:\n                res.append(nums[i:j])\n                i = j+1\n                flag = 0\n        if flag == 1:\n            res.append(nums)\n        elif flag == 0:\n            res.append(nums[i:])\n        nums = res\n        for j in nums:\n            maxy = max(maxy,solve(j))\n        return maxy\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        firstNeg = -1\n        zeroPos = -1\n        cnt = 0\n        ret = 0\n        for i, n in enumerate(nums):\n            if n < 0:\n                cnt += 1\n                if firstNeg == -1:\n                    firstNeg = i\n            elif not n:\n                firstNeg, cnt = -1, 0\n                zeroPos = i\n            if cnt % 2:\n                ret = max(ret, i - firstNeg)\n            else:\n                ret = max(ret, i - zeroPos)\n        return ret\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = neg = max_len = 0\n        \n        for n in nums:\n            if n > 0:\n                neg = (1 + neg) if neg > 0 else 0\n                pos = (1 + pos)                \n            elif n < 0:\n                #n1 = neg\n                #neg = (1 + pos)\n                pos, neg = (1 + neg) if neg > 0 else 0, 1+pos\n                 \n            else:\n                pos = neg = 0\n\n                \n            max_len = max(max_len, pos)\n        return max_len\n", "class Solution:\n    def getMaxLen(self, arr: List[int]) -> int:\n        i=0\n        while i<=len(arr)-1 and arr[i]==0:\n            i+=1\n        arr=arr[i:]\n        if len(arr)==0:\n            return 0\n        i=len(arr)-1\n        while i<=len(arr)-1 and arr[i]==0:\n            i-=1\n        arr=arr[:i+1]\n        if len(arr)==0:\n            return 0\n        array=[]\n        low=0\n        high=0\n        ans=[]\n        while low <len(arr):\n            while  high<len(arr) and arr[high] != 0:\n                high+=1\n            if high == len(arr)-1:\n                break\n            else:\n                array.append(arr[low:high])\n                while high<len(arr) and arr[high]==0:\n                    high+=1\n                low=high\n        for a in array:\n            if len(a)==0:\n                continue\n            else:\n                total=0\n                first=0\n                last=0\n                for i in range(len(a)):\n                    if a[i]<0:\n                        total+=1\n                if total%2==0:\n                    ans.append(len(a))\n                else:\n                    i=0\n                    while a[i]>0:\n                        i+=1\n                    first=len(a)-(i+1)\n                    i=len(a)-1\n                    while a[i]>0:\n                        i-=1\n                    last=i\n                    \n                ans.append(max(first,last))\n        ma=0\n        for i in ans:\n            if i>ma:\n                ma=i\n        return ma\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        out = 0\n        first = -1\n        last = -1\n        negs = 0\n        start = 0\n        for i,num in enumerate(nums):\n            if num == 0:\n                if negs % 2 == 0:\n                    new_max = i-start\n                else:\n                    new_max = max(i-first-1,last-start)\n                out = max(out,new_max)\n                first = -1\n                last = -1\n                negs = 0\n                start = i+1\n            if num < 0:\n                negs += 1\n                if first == -1:\n                    first = i\n                last = i\n        i+=1\n        if negs % 2 == 0:\n            new_max = i-start\n        else:\n            new_max = max(i-first-1,last-start)\n        out = max(out,new_max)\n        return out", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0 for i in range(2)]  for j in  range(len(nums) + 1)]\n        res = 0\n        for i, num in enumerate(nums):\n            if num == 0:\n                dp[i + 1][0] = dp[num][1] = 0\n            elif num > 0:\n                dp[i + 1][0] = dp[i][0] + 1\n                dp[i + 1][1] = dp[i][1] + 1 if dp[i][1] else 0\n            else:\n                dp[i + 1][0] = dp[i][1] + 1 if dp[i][1] else 0\n                dp[i + 1][1] = dp[i][0] + 1\n            res = max(res, dp[i + 1][0])\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = 0\n        neg = 0\n        lo, hi = 0, -1\n        for i, num in enumerate(nums):\n            if num == 0:\n                lo = i+1\n                neg = 0\n            elif num < 0:\n                neg += 1\n            hi = i\n            if neg % 2 == 0:\n                #print(lo,hi)\n                ans = max(ans, hi - lo + 1)\n                \n        neg = 0\n        nums = nums[::-1]\n        lo, hi = 0, -1\n        for i, num in enumerate(nums):\n            if num == 0:\n                lo = i+1\n                neg = 0\n            elif num < 0:\n                neg += 1\n            hi = i\n            if neg % 2 == 0:\n                #print(lo,hi)\n                ans = max(ans, hi - lo + 1)        \n\n        return ans         \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [0 for _ in range(2)]\n        res = 0\n        \n        if nums[0] > 0:\n            dp[0] = 1\n            res = 1\n        if nums[0] < 0:\n            dp[1] = 1\n            \n        \n        for i in range(1, len(nums)):\n            cur = nums[i]\n            tmp = [0 for _ in range(2)]\n            if cur > 0:\n                tmp[0] = dp[0] + 1\n                if dp[1] > 0:\n                    tmp[1] = dp[1] + 1\n            \n            if cur < 0:\n                tmp[1] = dp[0] + 1\n                if dp[1] > 0:\n                    tmp[0] = dp[1] + 1\n            \n            res = max(res, tmp[0])\n            dp = tmp\n        \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        positives = 0\n        negatives = 0\n        output = 0\n\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                positives += 1\n\n                if negatives > 0:\n                    negatives += 1\n\n            elif nums[i] < 0:\n                if negatives > 0:\n                    tmp = positives\n                    positives = negatives + 1 \n                    negatives = tmp + 1 \n\n                else:\n                    negatives = positives + 1\n                    positives = 0\n\n            else:\n                positives = 0\n                negatives = 0\n\n            output = max(output, positives)\n\n        return output\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        neg = pos = 0\n        ret = 0\n        end = start = 0\n        while end < len(nums):\n            start = end\n            while end < len(nums) and nums[end]:\n                if nums[end] < 0:\n                    neg += 1\n                if nums[end] > 0:\n                    pos += 1\n                if neg % 2 == 0:\n                    ret = max(ret, end - start + 1)\n                    print(ret)\n                end += 1\n            while neg % 2:\n                if nums[start] < 0:\n                    neg -= 1\n                    ret = max(ret, end - start - 1)\n                start += 1\n            neg = pos = 0\n            while end < len(nums) and nums[end] == 0:\n                end += 1\n        return ret\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos_l = 0\n        neg_l = 0\n        best = 0\n        \n        for n in nums:\n            if n == 0:\n                pos_l = 0\n                neg_l = 0\n            elif n > 0:\n                pos_l += 1\n                if neg_l > 0:\n                    neg_l += 1\n            else:\n                if neg_l == 0 and pos_l == 0:\n                    neg_l = 1\n                elif neg_l > 0 and pos_l > 0:                  \n                    pos_l, neg_l = neg_l+1, pos_l+1        \n                elif neg_l > 0:\n                    pos_l = neg_l+1\n                    neg_l = 1\n                elif pos_l > 0:\n                    neg_l = pos_l+1\n                    pos_l = 0\n            #print(n, pos_l, neg_l)\n            best = max(best, pos_l)\n        return best\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        cn=0;cp=0;f=0;n=len(nums);pz=-1;ans=0\n        for i in range(n):\n            if(nums[i]<0):\n                if(f==0):fn=ln=i\n                else:ln=i\n                cn+=1;f=1\n            elif(nums[i]>0):cp+=1\n            else:\n                if(cn%2==0):ans=max(ans,cn+cp)\n                else:\n                    z=cn+cp-min(i-ln,fn-pz)\n                    ans=max(ans,z)\n                f=0;cn=0;cp=0;pz=i\n        if(cn%2==0):ans=max(ans,cn+cp)\n        else:\n            z=cn+cp-min(n-ln,fn-pz)\n            ans=max(ans,z)\n        return ans\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        pos = 0\n        neg = 0\n        max_pos = 0\n        curr = True\n        for i in range(len(nums)):\n            # print(nums[i])\n            \n            if nums[i] > 0:\n                pos += 1\n                if neg != 0:\n                    neg += 1                    \n            \n            elif nums[i] < 0:\n                old_pos = pos\n                if neg != 0:\n                    pos = neg + 1\n                else:\n                    pos = 0\n                neg = old_pos + 1\n                \n            \n            else:\n                neg = 0\n                pos = 0\n\n\n            max_pos = max(pos, max_pos)\n            # print(pos, max_pos,neg)\n        \n        return max_pos", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        \n        pos, neg = [0] * len(nums), [0] * len(nums)\n        \n        if nums[0] > 0:\n            pos[0] = 1 \n        if nums[0] < 0:\n            neg[0] = 1\n            \n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = pos[i-1] + 1 \n                neg[i] = 1 + neg[i-1] if neg[i-1] else 0\n            \n            elif nums[i] < 0:\n                neg[i] = pos[i-1] + 1 \n                pos[i] = 1 + neg[i-1] if neg[i-1] else 0 \n\n            ans = max(ans, pos[i])\n            \n            \n                \n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp_pos = [0] * (len(nums) + 1)\n        dp_neg = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            if(nums[i] > 0):\n                dp_pos[i+1] = dp_pos[i] + 1\n                if(dp_neg[i] == 0):\n                    dp_neg[i+1] = 0\n                else:\n                    dp_neg[i+1] = dp_neg[i] + 1\n            elif(nums[i] < 0):\n                dp_neg[i+1] = dp_pos[i] + 1\n                if(dp_neg[i] == 0):\n                    dp_pos[i+1] = 0\n                else:\n                    dp_pos[i+1] = dp_neg[i] + 1\n        return max(dp_pos)\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        nums1 = []\n        for i in nums:\n            if i > 0:\n                nums1.append(1)\n            elif i < 0:\n                nums1.append(-1)\n            else:\n                nums1.append(0)\n        pre_arr = [0]*len(nums1)\n        rem = []\n        for i in range(len(nums1)):\n            if i == 0:\n                pre_arr[i] = nums1[i]\n            else:\n                if pre_arr[i-1] != 0:\n                    pre_arr[i] = nums1[i]*pre_arr[i-1]\n                else:\n                    pre_arr[i] = nums1[i]\n        a1 = max(nums)\n        if a1 > 0:\n            m1 = 1\n        else:\n            m1 = 0\n        Dict = defaultdict(int)\n        start = 0\n        for i in range(len(pre_arr)):\n            if pre_arr[i] > 0:\n                m1 = max(m1, i - Dict[1]+1)\n            elif pre_arr[i] == 0:\n                Dict[1] = i+1\n        # print(pre_arr)\n        Dict1 = defaultdict(list)\n        m2 = 0\n        for i in range(len(pre_arr)):\n            if pre_arr[i] < 0:\n                Dict1[-1].append(i)\n            elif pre_arr[i] == 0:\n                if len(Dict1[-1]) >= 2:\n                    m2 = max(m2, Dict1[-1][-1]-Dict1[-1][0])\n                Dict1.clear()\n        if len(Dict1[-1]) >= 2:\n            m2 = max(m2, Dict1[-1][-1]-Dict1[-1][0])\n        #print(m1, m2)\n        return max(m1,m2)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = neg = max_len = 0\n        \n        for n in nums:\n            if n > 0:\n                neg, pos = (1 + neg) if neg > 0 else 0, 1+pos\n                #pos = (1 + pos)                \n            elif n < 0:\n                #n1 = neg\n                #neg = (1 + pos)\n                pos, neg = (1 + neg) if neg > 0 else 0, 1+pos\n                 \n            else:\n                pos = neg = 0\n\n                \n            max_len = max(max_len, pos)\n        return max_len\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = [0] * len(nums)\n        neg = [0] * len(nums)\n        \n        pos[0] = 1 if nums[0] > 0 else 0\n        neg[0] = 1 if nums[0] < 0 else 0\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n                neg[i] = 1 + pos[i-1]\n            elif nums[i] > 0:\n                pos[i] = 1 + pos[i-1]\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n            else:\n                pos[i] = 0\n                neg[i] = 0\n        return max(pos)\n        \n'''\npos[i] = max length subarray ending at i whose product is positive\nneg[i] = max length subarray ending at i whose product is negative\n\n\npos[i] = (\n    1 + pos[i-1], if nums[i] > 0\n    1 + neg[i-1] elif nums[i] < 0\n    0            else\n)\n\nneg[i] = (\n    1 + neg[i-1], if nums[i] > 0\n    1 + pos[i-1], elif nums[i] < 0\n    0             else\n)\n\nA = [-1,-2,-3,0,1]\np = [0,  2, 2,]\nn = [1,  1, 3]\n\n\n\n[0,1,-2,-3,-4]\n\n[0,1,0,3,2]\n[0,0,2,1,]\n\n\n\n\n'''", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        prod = 1\n        p_start = -1\n        n_start = 10 ** 6\n        for i in range(n):\n            if nums[i] == 0:\n                p_start = i\n                n_start = 10 ** 6\n                prod = 1\n                continue\n            elif nums[i] < 0:\n                prod = -prod\n                if n_start == 10 ** 6:\n                    n_start = i\n            res = max(res, i - p_start) if prod > 0 else max(res, i - n_start)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        neg = pos = max_len = 0\n        fneg = lneg = -1\n        beg = -1\n        \n        for i, n in enumerate(nums):\n            if n < 0:\n                neg += 1\n                if fneg == -1:\n                    fneg = lneg = i\n                else:\n                    lneg = i\n            elif n > 0:\n                pos += 1\n            else:\n                if neg%2 == 0:\n                    max_len = max(max_len, neg+pos)\n                else:                    \n                    max_len = max(max_len, max(lneg - beg - 1, i - fneg - 1))\n                    print((i, fneg, lneg, beg))\n                neg = pos = 0\n                fneg = lneg = -1\n                beg = i\n                \n        if neg%2 == 0:\n            max_len = max(max_len, neg+pos)\n        else:\n            max_len = max(max_len, max(i - fneg, lneg - beg - 1))\n\n        return max_len\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        l = len(nums)\n        dp = [[0 for _ in range(2)] for _ in range(l)]\n        res = 0\n        if nums[0] > 0:\n            dp[0][0] = 1\n            res = 1\n        if nums[0] < 0:\n            dp[0][1] = 1\n        \n        for i in range(1, len(nums)):\n            cur = nums[i]\n            if cur > 0:\n                if dp[i-1][0] == 0:\n                    dp[i][0] = 1\n                else:\n                    dp[i][0] = dp[i-1][0] + 1\n                \n                if dp[i-1][1] != 0:\n                    dp[i][1] = dp[i-1][1] + 1\n                    \n            if cur < 0:\n                if dp[i-1][0] == 0:\n                    dp[i][1] = 1\n                else:\n                    dp[i][1] = dp[i-1][0] + 1\n                \n                if dp[i-1][1] != 0:\n                    dp[i][0] = dp[i-1][1] + 1\n            \n            res = max(res, dp[i][0])\n        \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        v = {(0,0):-1}\n        neg = 0\n        zero = 0\n        maxlen = 0\n        for i,num in enumerate(nums):\n            if num < 0:\n                neg = 1 - neg\n            if num == 0:\n                zero += 1\n            if (neg,zero) not in v:\n                v[(neg,zero)] = i\n            else:\n                maxlen = max(maxlen,i-v[(neg,zero)])\n        # print(v)\n        return maxlen\n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        dp_po, dp_ne = [0] * (len(nums) + 1), [0] * (len(nums) + 1)\n        \n        for i, value in enumerate(nums):\n            if value == 0:\n                dp_po[i + 1] = 0\n                dp_ne[i + 1] = 0\n            elif value > 0:\n                dp_po[i + 1] = dp_po[i] + 1\n                if dp_ne[i] > 0:\n                    dp_ne[i + 1] = dp_ne[i] + 1\n            else:\n                dp_ne[i + 1] = dp_po[i] + 1\n                if dp_ne[i] > 0:\n                    dp_po[i + 1] = dp_ne[i] + 1\n            if dp_po[i + 1] > res:\n                res = dp_po[i + 1]\n        \n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        fn=-1\n        zi=-1\n        cn=0\n        dig=0\n        maxdig=0\n        for i in range(len(nums)):\n            if(nums[i]<0):\n                cn+=1\n                if(fn==-1):\n                    fn=i\n            if(nums[i]==0):\n                fn=-1\n                cn=0\n                zi=i\n            else:\n                if(cn%2==0):\n                    maxdig=max(i-zi,maxdig)\n                else:\n                    maxdig=max(i-fn,maxdig)\n        return maxdig", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        n = len(nums)\n        \n        non_zeros = []\n        i = 0\n        pre = 0\n        while i < n:\n            if nums[i] == 0:\n                if i > pre:\n                    non_zeros.append(nums[pre:i])\n                pre = i + 1\n            i += 1\n        if i > pre:\n            non_zeros.append(nums[pre:i])\n        \n        for non_zero in non_zeros:\n            negs = []\n            nn = len(non_zero)\n            for i in range(nn):\n                if non_zero[i] < 0:\n                    negs.append(i)\n            if len(negs) % 2 == 0:\n                res = max(res, nn)\n            else:\n                res = max([res, len(non_zero[negs[0] + 1:nn]), len(non_zero[0:negs[-1]])])\n        \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n=len(nums)\n        i=0\n        ans=float('-inf')\n        while i<n:\n            s=i\n        \n            while s<n and nums[s]==0:\n                s+=1\n            e=s\n            c=0\n            sn=-1\n            en=-1\n            while e<n and nums[e]!=0:\n                if nums[e]<0:\n                    c+=1\n                    if sn==-1:\n                        sn=e\n                    en=e\n                e+=1\n            if c%2==0:\n                ans=max(ans,e-s)\n            else:\n                if sn!=-1:\n                    ans=max(ans,e-sn-1)\n                if en!=-1:\n                    ans=max(ans,en-s)\n            i=e+1\n        return ans\n                    \n            \n       \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        pos, neg = 0, 0\n        res = 0\n        for n in nums:\n            if n==0:\n                neg, pos = 0, 0\n            elif n>0:\n                if neg>0: neg, pos = neg+1, pos+1\n                else: neg, pos = 0, pos+1\n            else:\n                if neg>0: pos, neg = neg+1, pos+1\n                else: neg, pos = pos+1, 0\n            res = max(res,pos)\n        return res\n\n\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        p = 1\n        j = None\n        k = -1\n        m = 0\n        for i, n in enumerate(nums):\n            if not n:\n                p = 1\n                j = None\n                k = i\n            else:\n                if n < 0:\n                    p = -p\n                if p > 0:\n                    m = max(m, i-k)\n                elif p < 0:\n                    if j is None:\n                        j = i\n                    else:\n                        m = max(m, i-j)\n        return m\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # if the number of negative numbers is even then we just need to worry about zeroes\n        maxLength = 0\n        currLength = 0\n        negCnt = 0\n        negIdxs = []\n        head = 0\n        for i, n in enumerate(nums):\n            if n > 0:\n                currLength += 1\n                if negCnt%2 == 0:\n                    maxLength = max(maxLength, currLength)\n            elif n < 0:\n                currLength += 1\n                negCnt += 1\n                negIdxs.append(i)\n                if negCnt%2 == 0:\n                    maxLength = max(maxLength, currLength)\n            if n == 0 or i == len(nums) - 1: # end or 0\n                # head and tail?\n                if negIdxs:\n                    tail = i if n > 0 else i - 1\n                    maxLength = max(maxLength, tail - negIdxs[0])\n                    # print(negIdxs[-1], head)\n                    maxLength = max(maxLength, negIdxs[-1] - head)\n                currLength = 0\n                negCnt = 0\n                negIdxs = []\n                head = i + 1\n        return maxLength\n        \n        # negIdx = []\n        # zeroIdx = []\n        # for i, n in enumerate(nums):\n        #     if n < 0:\n        #         negIdx.append(i)\n        #     elif n == 0:\n        #         zeroIdx.append(i)\n        # if len(negIdx)%2 == 0:\n        #     if len(zeroIdx) == 0:\n        #         return len(nums)\n        #     else:\n        #         for \n        # else:\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # \\\"pos\\\", \\\"neg\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\n        nums.append(0)\n        n = len(nums)\n        pos, neg = 0, 0\n        if nums[0] > 0: pos = 1\n        if nums[0] < 0: neg = 1\n        ans = pos\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos = 1 + pos\n                neg = 1 + neg if neg > 0 else 0\n            elif nums[i] < 0:\n                pre_pos, pre_neg = pos, neg\n                pos = 1 + pre_neg if pre_neg > 0 else 0\n                neg = 1 + pre_pos\n            else:\n                pos, neg = 0, 0\n            ans = max(ans, pos)\n        return ans\n    \n        # nums.append(0)\n        # start = -1\n        # i = 0\n        # firstn = -1\n        # maxl = 0\n        # nneg = 0\n        # while i<len(nums):\n        #     if nums[i]<0:\n        #         nneg += 1\n        #         if firstn<0: firstn = i\n        #         lastn = i\n        #     elif nums[i] == 0:\n        #         if nneg%2 == 0:\n        #             maxl = max(maxl,i-start-1)\n        #         else:\n        #             maxl = max([maxl,lastn-start-1,i-firstn-1])\n        #         start = i\n        #         nneg = 0\n        #         firstn = -1\n        #     i += 1\n        # return maxl\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        n=len(nums)\n        for i in range(n):\n            if nums[i]>0:\n                nums[i]=1\n            elif nums[i]<0:\n                nums[i]=-1\n        \n        # print(nums)\n        ans=0\n        old=1\n        for i in range(n):\n            # print(i)\n            temp=i\n            count=0\n            j=i\n            pro=1\n            old=1\n            while j<n:\n                \n                pro=pro*nums[j]\n                # print(pro,end=' ')                \n                if pro==0:\n                    # print(\\\" \\\")\n                    i=j+1\n                    break\n\n                count+=1\n                if pro>0:\n                    if count>ans:\n                        ans=count                \n                j=j+1\n                old=pro\n                # print((count,old))\n                # print(\\\" \\\")\n            # print(\\\"TATTI\\\")    \n            \n\n            if pro==0 and old>0:\n                if ans<count:\n                    ans=count\n            elif old<0:\n                            \n                left=1\n                right=1\n                for z in range(temp,j):\n                    if nums[z]==-1:\n                        break\n                    left+=1\n                z=j-1\n                while z>=temp:\n                    if nums[z]==-1:\n                        break\n                    right+=1\n                    z=z-1\n                q=min(left,right)\n                # print((temp,j,q))\n                # print((j-temp+1-q)-1)\n                if (j-temp+1-q)-1>ans:\n                    ans=(j-temp+1-q)-1\n            # print('ans = '+str(ans))\n            if j>=n:\n                break\n            \n        return ans\n                    \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int], reverse=False) -> int:\n        zero_pos = -1\n        num_negative = 0\n        first_negative = -1\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                num_negative += 1\n                if first_negative == -1:\n                    first_negative = i\n            if nums[i] == 0:\n                zero_pos = i\n                num_negative = 0\n                first_negative = -1\n            if nums[i] > 0 or nums[i] < 0:\n                if num_negative % 2 == 0:\n                    res = max(res, i - zero_pos)\n                else:\n                    res = max(res, i - first_negative)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # \\\"pos[i]\\\", \\\"neg[i]\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\n\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans  \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = pos = neg = 0\n        for x in nums: \n            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0     # assignment in one line is very important to have the previous value of variables updated! Cannot be re-written into 2 lines!\n            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos\n            else: pos = neg = 0 # reset \n            ans = max(ans, pos)\n        return ans \n", "def f(data):\n    n2 = len(data)\n    \n    f0 = -1\n    f1 = -1\n    n = 0\n    for ind,d in enumerate(data):\n        if d==1:\n            continue\n        n += 1\n        if f0==-1:\n            f0 = ind\n        f1 = ind\n            \n    if n&1==0:\n        return n2\n    \n    return max(f1, n2-f0-1)\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        prev = -1\n        data = []\n        for ind,num in enumerate(nums):\n            if num==0:\n                if data:\n                    res = max(res, f(data))\n                prev = ind\n                data = []\n                continue\n                \n            data.append(1 if num>0 else -1)\n            \n        res = max(res, f(data))\n        return res\n                \n            \n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        pos, neg = set(), set()\n        for num in nums:\n            if num > 0:\n                pos = {x+1 for x in pos} | {1}\n                neg = {y+1 for y in neg}\n            elif num < 0:\n                pos = {x+1 for x in pos} | {1}\n                neg = {y+1 for y in neg}       \n                pos, neg = neg, pos\n            else:\n                pos, neg = set(), set()\n            \n            if len(pos):\n                res = max(res, max(pos))\n            # print(res)\n            \n            if len(pos): pos = set([max(pos)])\n            if len(neg): neg = set([max(neg)])\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        max_pos = 0\n        max_neg = 0\n        max_len = 0\n        for n in nums:\n            if n == 0:\n                max_pos = max_neg = 0\n            elif n > 0:\n                max_pos += 1\n                if max_neg:\n                    max_neg += 1\n            else:\n                prev_pos = max_pos\n                if max_neg:\n                    max_pos = max_neg + 1\n                else:\n                    max_pos = 0\n                max_neg = prev_pos + 1\n            max_len = max(max_len, max_pos)\n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        max_length = 0\n        \n        idx = 0\n        prev = 0\n        negative = 0\n        while idx < len(nums):\n            num = nums[idx]\n            if num == 0:\n                prev = 0\n                negative = 0\n            elif num < 0:\n                if negative == 1:\n                    prev = neg_idx + (idx-prev_neg_idx) + 1 \n                    negative = 0\n                else:\n                    prev_neg_idx = idx\n                    neg_idx = prev\n                    negative = 1\n            else:\n                if prev == 0 or negative == 0:\n                    prev += 1\n            #print(prev)\n            max_length = max(max_length, prev)\n            idx += 1\n            \n        idx = len(nums)-1\n        prev = 0\n        negative = 0\n        while idx >= 0:\n            num = nums[idx]\n            if num == 0:\n                prev = 0\n                negative = 0\n            elif num < 0:\n                if negative == 1:\n                    prev = neg_idx + (prev_neg_idx-idx) + 1 \n                    negative = 0\n                else:\n                    prev_neg_idx = idx\n                    neg_idx = prev\n                    negative = 1\n            else:\n                if prev == 0 or negative == 0:\n                    prev += 1\n            #print(prev)\n            max_length = max(max_length, prev)\n            idx -= 1            \n\n        return max_length\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        i_pos,i_neg=-1,len(nums)\n        pro=1\n        res=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                i_pos,i_neg=i,len(nums)\n                pro=1\n            else: \n                if nums[i]<0: pro*=-1\n      \n                if pro>0:\n                    i_pos=min(i,i_pos)\n                    res=max(res,i-i_pos)\n                else:\n                    i_neg=min(i,i_neg)\n                    res=max(res,i-i_neg)\n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        max_pos_len = 0\n        max_neg_len = 0\n        if nums[0] > 0: max_pos_len = 1\n        if nums[0] < 0: max_neg_len = 1\n        max_len = max(0, max_pos_len)\n        \n        for i in range(1, len(nums)):\n            if nums[i] > 0: \n                max_pos_len += 1\n                max_neg_len += (max_neg_len > 0)\n            elif nums[i] < 0: \n                max_neg_len, max_pos_len = max_pos_len+1, max_neg_len+(max_neg_len > 0)\n            elif nums[i] == 0: \n                max_pos_len = max_neg_len = 0\n            \n            max_len = max(max_len, max_pos_len)\n        \n        return max_len\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ret = 0\n        l, r, p = 0, 0, 1\n        i = 0\n        while i <= len(nums):\n            if i != len(nums) and nums[i] != 0:\n                p *= 1 if nums[i] > 0 else -1\n                if p > 0:\n                    ret = max(ret, i-l+1)\n            else:\n                while l < i:\n                    p *= 1 if nums[l] > 0 else -1\n                    if p > 0:\n                        ret = max(ret, i-l-1)\n                    l += 1\n                l += 1\n                p = 1\n            i += 1\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[i] = 2\n            elif nums[i] < 0:\n                nums[i] = -2\n        mini, maxi, res = 1, 1, -10**9 - 1\n        for n in nums:\n            a = mini * n\n            b = maxi * n\n            mini = min(a,b,n)\n            maxi = max(a,b,n)\n            res = max(res, maxi)\n        if res <= 0:\n            return 0\n        return int(math.log2(res))\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def getMaxLenHelper(nums: List[int]) -> int:\n           ans = 0\n           count,count1,negativeCount = 0,0,0\n           for i in range(len(nums)):\n              if nums[i] == 0:\n                  if count > ans:\n                     ans = count\n                  count,count1,negativeCount = 0,0,0\n              else:\n                if nums[i] > 0:\n                    count += 1\n                count1 += 1\n                if nums[i] < 0:\n                   negativeCount += 1\n                   if negativeCount == 2:\n                      count = count1\n                      negativeCount = 0\n                   else:\n                      if count > ans:\n                         ans = count\n                      count = 0\n           if count > ans:\n              ans = count\n           return ans\n        return max(getMaxLenHelper(nums),getMaxLenHelper(nums[::-1]))\n        \n            \n", "class Solution:\n    def getMaxLen(self, nums):\n        n = len(nums)\n        pos, neg = 0, 0\n        res = 0\n        for i in range(n):\n            if nums[i] > 0:\n                pos, neg = 1 + pos, 1 + neg if neg else 0\n            elif nums[i] < 0:\n                pos, neg = 1 + neg if neg else 0, 1 + pos\n            else:\n                pos, neg = 0, 0\n            res = max(res, pos)\n        return res  ", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        N = len(nums)\n        pos, neg = [0] * N, [0] * N\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        res = pos[0]\n        \n        for i in range(1, N):\n            if nums[i] > 0:\n                pos[i] = pos[i - 1] + 1\n                neg[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\n                neg[i] = pos[i - 1] + 1\n            res = max(pos[i], res)\n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = int(nums[0] > 0)\n        neg = int(nums[0] < 0)\n        best = pos\n        for i in nums[1:]:\n            if i > 0:\n                pos+= 1\n                if neg > 0:                \n                    neg += 1    \n                else:\n                    neg = 0\n            elif i < 0:\n                pTemp = pos\n                if neg > 0:\n                    pos = neg + 1\n                else:\n                    pos = 0\n                neg = pTemp + 1\n            else:\n                pos,neg = 0,0\n            best = max(best, pos)\n        return best", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # just count even number of negatives, no zeros though\n        \n        \n        \n        left = right = negCount = negIndex = res = 0\n        \n        while right <= len(nums):\n            if right < len(nums) and nums[right] != 0:\n                if nums[right] < 0:\n                    negCount += 1\n                    negIndex = right\n                    \n                right += 1                \n            else:\n                if negCount % 2 == 1:\n                    res = max(res, negIndex - left)\n                    while nums[left] > 0: left += 1\n                        \n                    res = max(res, right - left - 1)\n                else:\n                    res = max(res, right - left)\n                \n                right += 1\n                left = right\n                negCount = 0 \n        \n        return res\n                \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        trip_zeros = []\n        for num in nums:\n            if num:\n                if trip_zeros: trip_zeros[-1].append(num)\n                else: trip_zeros.append([num])\n            else:\n                trip_zeros.append([])\n        \n        def count(arr):\n            start = ans = 0\n            left_neg = None\n            pos = 1\n            for end in range(len(arr)):\n                if arr[end] < 0:\n                    if left_neg is None:\n                        left_neg = end\n                    pos ^= 1\n                print(pos, start, end, left_neg)\n                if pos:\n                    ans = max(ans, end-start+1)\n                    \n                else:\n                    ans = max(ans, end-left_neg)\n            return ans\n        \n        # print(trip_zeros)\n        # if not trip_zeros: return 0\n        return max(map(count, trip_zeros))", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = 0\n        last_zero = last_negative = -1\n        running_count = 0\n        negative_count = 0\n        for i,v in enumerate(nums):\n            if v == 0:\n                last_zero = last_negative = i\n                running_count = zero_count = negative_count = 0\n            elif v < 0:\n                negative_count += 1\n                if negative_count == 1: last_negative = i\n                if negative_count % 2 == 0: ans = max(ans,i-last_zero)\n                else: ans = max(ans,i-last_negative)\n            else:\n                if negative_count % 2 == 0: ans = max(ans,i-last_zero)\n                else: ans = max(ans,i-last_negative)\n        return ans", "class Solution:         \n        \n    def getMaxLenDuh(self, nums: List[int]) -> int:\n        '''\n        Single pass: at each num, track length of pos and neg prods:\n            reset on 0, and change sign as needed.\n        '''\n        size = len(nums)\n        if not size:\n            return 0\n        if size == 1:\n            return 1 if nums[0] > 0 else 0\n        \n        \n        result = nneg = npos = 0\n        for num in nums:\n            if num == 0:\n                nneg = npos = 0     # reset\n            elif num > 0:\n                npos = npos + 1                 # any pos prod stays neg\n                nneg = nneg + 1 if nneg else 0  # any neg prod stays neg\n            else:\n                temp = nneg\n                nneg = npos + 1                 # any pos prod flips neg\n                npos = temp + 1 if temp else 0  # any neg prod flips pos\n            result = max(result, npos)          # Save max pos prod len\n        return result\n    \n\n    def getMaxLenPow2(self, numso: List[int]) -> int:\n        '''\n\n        '''\n        nums = [copysign(num, 2) for num in numso]\n        size = len(nums)\n        if size == 0:\n            return\n        left_prod, right_prod = 0, 0\n        max_prod = -float('inf')\n        for i in range(size):\n            left_prod = (left_prod or 1) * nums[i]\n            right_prod = (right_prod or 1) * nums[size - 1 - i]\n            max_prod = max(max_prod, left_prod, right_prod)\n        return math.log(max_prod, 2)\n\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        '''\n\n        '''\n        return self.getMaxLenDuh(nums)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        pos = [0] * (len(nums) + 1)\n        neg = [0] * (len(nums) + 1)\n        for i, n in enumerate(nums):\n            if n > 0:\n                pos[i+1] = pos[i] + 1\n                if neg[i] != 0:\n                    neg[i+1] = neg[i] + 1\n            elif n < 0:\n                if neg[i] == 0:\n                    neg[i+1], pos[i+1] = pos[i]+1, 0\n                else:\n                    neg[i+1], pos[i+1] = pos[i] + 1, neg[i] + 1\n            else:\n                neg[i+1] = pos[i+1] = 0\n        return max(pos)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        max_count = 0\n        front = 0\n        back = 0\n        prod = 1\n        \n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[i] = 1\n            elif nums[i] < 0:\n                nums[i] = -1\n        \n        while back < len(nums):\n            if nums[back] == 0:\n                back -= 1\n                while front <= back and front < len(nums):\n                    if nums[front] != 0:\n                        prod /= nums[front]\n                        front += 1\n                        if prod > 0:\n                            max_count = max(max_count, back - front + 1)\n                    else:\n                        front += 1\n                \n                front += 1\n                back = front\n                \n            else:\n                prod *= nums[back]\n                if prod > 0:\n                    max_count = max(max_count, back - front + 1)\n                back += 1\n        \n        back -= 1\n        while front <= back and front < len(nums):\n            if nums[front] != 0:\n                prod /= nums[front]\n                front += 1\n                if prod > 0:\n                    max_count = max(max_count, back - front + 1)\n            else:\n                front += 1\n\n                    \n        return max_count", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        dp = [[0, 0] for _ in range(len(nums))]\n        dp[0] = [int(bool(nums[0] > 0)), int(bool(nums[0] < 0))] # max length (positive, negative)\n\n        for idx in range(1, len(nums)):\n            if nums[idx] == 0:\n                continue\n            if nums[idx] > 0:\n                dp[idx][0] = dp[idx - 1][0] + 1\n                dp[idx][1] = dp[idx - 1][1] + int(dp[idx - 1][1] != 0)\n            else:\n                dp[idx][0] = dp[idx - 1][1] + int(dp[idx - 1][1] != 0) \n                dp[idx][1] = dp[idx - 1][0] + 1\n\n        return max([positive for positive, _ in dp])\n", "class Solution:\n    \n    @staticmethod\n    def process(st, end, cnt_neg, arr):\n        if st >= 0 and st <= end and end >= 0:\n            if not (cnt_neg % 2):\n                return end - st + 1\n            first_neg_ind = st \n            last_neg_ind = end\n            while(first_neg_ind <= end and arr[first_neg_ind] >= 0):\n                first_neg_ind += 1\n            while(last_neg_ind >= st and arr[last_neg_ind] >= 0):\n                last_neg_ind -= 1\n            print((st, end, first_neg_ind, last_neg_ind))\n            return max(last_neg_ind - st, end - first_neg_ind)\n            \n        return 0\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        prev = 0\n        ans = 0\n        cnt_neg = 0\n        for i in range(len(nums)):\n            if not nums[i]:\n                ans = max(ans, Solution.process(prev, i-1, cnt_neg, nums))\n                prev = i + 1\n                cnt_neg = 0\n            if nums[i] < 0:\n                cnt_neg += 1\n        ans = max(ans, Solution.process(prev, len(nums)-1, cnt_neg, nums))\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = curr = 0\n        dp = {0:0}\n        for i,num in enumerate(nums,1):\n            if num==0:\n                curr = 0\n                dp = {0:i}\n                continue\n            curr = (curr+(num<0))%2\n            if curr not in dp:\n                dp[curr]=i\n            else:\n                res = max(res,i-dp[curr])\n        return res", "import heapq\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        hashmap={0:-1}\n        totalN=0\n        ans=0\n        for i in range(0,len(nums)):\n            if nums[i]<0:\n                totalN+=1\n            \n            value=totalN%2\n            if nums[i]==0:\n                hashmap={0:i}\n                \n                totalN=0\n                continue\n            if value in hashmap:\n                ans=max(ans,i-hashmap[value])\n            else:\n                hashmap[value]=i\n        return ans          ", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        maxl = 0\n        \n        posi = None\n        start = -1\n        cur = True\n        for i,n in enumerate(nums):\n            if n == 0:\n                start = i\n                posi = None\n                cur = True\n                \n            elif n > 0:\n                if cur:\n                    maxl = max(maxl,i-start)\n                    \n                else:\n                    if posi == None:\n                        maxl = max(maxl,1)\n                        posi = i\n                    else:\n                        maxl = max(maxl,i-posi+1)\n                 \n                \n            else:\n                if not cur:\n                    maxl = max(maxl,i-start)\n                    if not posi:\n                        posi = i\n                    cur = True\n                else:\n                    cur = False\n                     \n                    if posi:                        \n                        maxl = max(maxl,i-posi+1)\n                 \n        return maxl", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        pos = [0]*n\n        neg = [0]*n\n        \n        if nums[0] > 0:\n            pos[0] = 1\n        if nums[0] <0:\n            neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = pos[i-1] + 1\n                neg[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\n                \n            elif nums[i] < 0:\n                pos[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\n                neg[i] = pos[i-1] + 1\n            # else:\n                # pos[i]\n            ans = max(ans, pos[i])\n        \n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        i = 0\n        j = 0\n        minus = 0\n        res = 0\n        \n        while j < len(nums):\n            if nums[j] < 0:\n                minus+=1\n                j+=1\n            elif nums[j] > 0:\n                j+=1\n            else:\n                minus = 0\n                i = j+1\n                j = i\n            if minus%2==0:\n                res = max(res, j-i)\n                \n        \n        if minus%2==0:\n            res = max(res, j-i)\n        \n        minus = 0\n        i = len(nums)-1\n        j = len(nums)-1\n        \n        while j >= 0:\n            if nums[j] < 0:\n                minus+=1\n                j-=1\n            elif nums[j] > 0:\n                j-=1\n            else:\n                minus = 0\n                i = j-1\n                j = i\n            if minus%2==0:\n                res = max(res, i-j)\n                \n        \n        if minus%2==0:\n            res = max(res, i-j)\n            \n        return res\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = [0]*n, [0]*n\n        if nums[0] > 0:\n            pos[0] = 1\n        if nums[0] < 0:\n            neg[0] = 1\n            \n        ans = pos[0]\n        \n        for i in range(1,n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i-1]\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n            \n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n                neg[i] = 1 + pos[i-1]\n                \n            ans = max(ans,pos[i])\n            \n        return ans\n        \n        \n", "class Solution:         \n        \n    def getMaxLenDuh(self, nums: List[int]) -> int:\n        '''\n        Single pass: at each num, track length of pos and neg prods:\n            reset on 0, and change sign as needed.\n        '''\n        size = len(nums)\n        if not size:\n            return 0\n#         if size == 1:\n#             return 1 if nums[0] > 0 else 0\n        \n        \n        result = nneg = npos = 0\n        for num in nums:\n            if num == 0:\n                nneg = npos = 0     # reset\n            elif num > 0:\n                npos = npos + 1                 # any pos prod stays neg\n                nneg = nneg + 1 if nneg else 0  # any neg prod stays neg\n            else:\n                temp = nneg\n                nneg = npos + 1                 # any pos prod flips neg\n                npos = temp + 1 if temp else 0  # any neg prod flips pos\n            result = max(result, npos)          # Save max pos prod len\n        return result\n    \n\n    def getMaxLenPow2(self, numso: List[int]) -> int:\n        '''\n\n        '''\n        nums = [copysign(num, 2) for num in numso]\n        size = len(nums)\n        if size == 0:\n            return\n        left_prod, right_prod = 0, 0\n        max_prod = -float('inf')\n        for i in range(size):\n            left_prod = (left_prod or 1) * nums[i]\n            right_prod = (right_prod or 1) * nums[size - 1 - i]\n            max_prod = max(max_prod, left_prod, right_prod)\n        return math.log(max_prod, 2)\n\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        '''\n\n        '''\n        return self.getMaxLenDuh(nums)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        '''\n        f(i, 0) +\n        f(i, 1) -\n        f(i, 0) = max(f(i-1, 0)*nums[i]>0, f(i-1, 1), nums[i] < 0)\n        f(i, 1) = \n        '''\n        dp = defaultdict(int)\n        for i, num in enumerate(nums):\n            if num > 0: dp[(i, 0)] = 1\n            if num < 0: dp[(i, 1)] = 1\n        \n        ans = dp[(0, 0)]\n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                dp[(i, 0)] = max(dp[(i, 0)], dp[(i-1, 0)]+1 if dp[(i-1, 0)] > 0 else 0)\n                dp[(i, 1)] = max(dp[(i, 1)], dp[(i-1, 1)]+1 if dp[(i-1, 1)] > 0 else 0)\n            if nums[i] < 0:\n                dp[(i, 0)] = max(dp[(i, 0)], dp[(i-1, 1)]+1 if dp[(i-1, 1)] > 0 else 0)\n                dp[(i, 1)] = max(dp[(i, 1)], dp[(i-1, 0)]+1 if dp[(i-1, 0)] > 0 else 0)\n            ans = max(ans, dp[(i, 0)])\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        neg = [0 for ii in range(len(nums))]\n        zero = []\n        if nums[0] < 0:\n            neg[0] = 1\n        elif nums[0] == 0:\n            zero.append(0)\n\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                neg[i] = neg[i-1] + 1  \n            else:\n                neg[i] = neg[i-1]\n            \n            if nums[i] == 0:\n                zero.append(i)\n\n        l = 0\n        ans = 0\n        if len(zero) == 0:\n            if neg[len(nums)-1] % 2 == 0:\n                ans = max(ans, len(nums))\n            else:\n                first, last = -1, -1\n                for i in range(len(nums)):\n                    if nums[i] < 0:\n                        last = i\n                        if first == -1:\n                            first = i\n                ans = max(ans, last)\n                ans = max(ans, len(nums)-first-1)\n            \n        for z in zero:\n            if z == l:\n                l = z+1\n                continue\n            else:\n                if l == 0:\n                    if neg[z-1] % 2 == 0:\n                        ans = max(ans, z)\n                    else:\n                        first, last = -1, -1\n                        for i in range(l, z):\n                            if nums[i] < 0:\n                                last = i\n                                if first == -1:\n                                    first = i\n                        ans = max(ans, last)\n                        ans = max(ans, z-first-1)\n                else:\n                    if (neg[z-1] - neg[l-1]) % 2 == 0:\n                        ans = max(ans, z-l)\n                    else:\n                        first, last = -1, -1\n                        for i in range(l, z):\n                            if nums[i] < 0:\n                                last = i\n                                if first == -1:\n                                    first = i\n                        ans = max(ans, last-l)\n                        ans = max(ans, z-first-1)\n                l = z+1\n\n        z = len(nums)\n        if l == 0:\n            if neg[z-1] % 2 == 0:\n                ans = max(ans, z)\n            else:\n                first, last = -1, -1\n                for i in range(l, z):\n                    if nums[i] < 0:\n                        last = i\n                        if first == -1:\n                            first = i\n                ans = max(ans, last)\n                ans = max(ans, z-first-1)\n        else:\n            if (neg[z-1] - neg[l-1]) % 2 == 0:\n                ans = max(ans, z-l)\n            else:\n                first, last = -1, -1\n                for i in range(l, z):\n                    if nums[i] < 0:\n                        last = i\n                        if first == -1:\n                            first = i\n                ans = max(ans, last-l)\n                ans = max(ans, z-first-1)\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 1 if nums[0] > 0 else 0\n        \n        def find(start, end):\n            if start+1 == end:\n                return 0\n            \n            neg_count = sum(1 for x in range(start+1, end) if nums[x] < 0 ) \n            if neg_count % 2 == 0:\n                return end-start+1-2\n            \n            first_neg, last_neg = None, None\n            for idx in range(start+1, end):\n                if nums[idx] < 0:\n                    if first_neg is None:\n                        first_neg = idx\n                    last_neg = idx    \n                    \n            return max(last_neg-1-(start+1)+1, end-1-(first_neg+1)+1)\n            \n        \n        NEG, POS, ZERO = -1, +1, 0\n        nums = [0]+nums+[0]\n        n = len(nums)\n        \n        start = 0\n        end = 1\n        ans = 0\n        while end < n:\n            while end < n and nums[end] != 0:\n                end += 1\n                \n            ans = max(ans, find(start, end))\n            start = end \n            end += 1\n        return ans    \n        \n       #def get_type(n):\n       #    nonlocal NEG, POS, ZERO\n       #    \n       #    if n > 0:\n       #        return POS\n       #    elif n < 0:\n       #        return NEG\n       #    else:\n       #        return ZERO\n       #    \n\n       #arr = []\n       #cur_type, cur_count = None, 0 \n       #for n in nums:\n       #    n_type = get_type(n)\n       #    \n       #    if n_type == cur_type:\n       #        cur_count += 1\n       #    else:    \n       #        if cur_type is not None:\n       #            arr.append(cur_type, cur_count)\n       #        cur_count = 1\n       #        cur_type = n_type\n       #if cur_type is not None:\n       #    arr.append(cur_type, cur_count)\n       #    \n       #for type, count in arr:\n       #    if type == NEG and count % 2 == 0:\n       #        \n       #    \n       #    \n       #for type, count in arr:     \n", "### I was thinking about prefix sum direction and try to figure out relationship between current number and previous number\n\n\n### besides dynamic programming, is there another way of doing it?????\n\n\n### good dynamic programming in here https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/819432/Python-Easy-to-understand-DP\n# dp[i][0] : max length of subarray ending with index i With positive product   \n# dp[i][1] : max length of subarray ending with index i With negative product \n\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0,0] for _ in range(len(nums))]\n        res = 0\n        if nums[0] > 0:\n            dp[0][0] = 1\n        elif nums[0] < 0:\n            dp[0][1] = 1\n        #print(dp)\n        res = max(res, dp[0][0])\n        for idx in range(1, len(nums)):\n            if nums[idx] == 0:\n                dp[idx][0], dp[idx][1] = 0, 0\n            elif nums[idx] > 0:\n                dp[idx][0] = dp[idx-1][0] + 1\n                if dp[idx-1][1] > 0:\n                    dp[idx][1] = dp[idx-1][1] + 1\n                res = max(dp[idx][0], res)\n            \n            elif nums[idx] < 0:\n                dp[idx][1] = dp[idx-1][0]+1\n                if dp[idx-1][1] > 0:\n                    dp[idx][0] = dp[idx-1][1]+1\n                res = max(res, dp[idx][0])\n                \n        #print(dp)\n        return res\n\n\n\n'''\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        prevpos, prevneg = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n                prevpos, prevneg = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    print(num, res)\n                else:\n                    res = max(res, diction[\\\"pos\\\"], prevpos)\n        \n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                print(\\\"neg\\\", num, diction[\\\"neg\\\"], diction[\\\"pos\\\"], prevpos)\n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"])\n                    prevpos += diction[\\\"pos\\\"]\n                    diction[\\\"pos\\\"] = 0\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    prevpos = diction[\\\"neg\\\"] + diction[\\\"pos\\\"] + prevpos\n                    diction[\\\"neg\\\"] = 0\n                    diction[\\\"pos\\\"] = 0\n                    \n        print(res)\n        return res\n'''\n\n        \n'''\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                \n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]-1)\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n                \n        print(res)\n        \n        return res\n        \n\n'''\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        rst = 0\n        max_pos = max_neg = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                max_pos = max_neg = 0\n                continue\n            if i == 0:\n                if nums[i] > 0:\n                    max_pos = 1\n                else:\n                    max_neg = 1\n            else:\n                if nums[i] > 0:\n                    if max_neg:\n                        max_neg += 1\n                    max_pos += 1\n                else:\n                    tmp = max_neg\n                    max_neg = max_pos + 1\n                    if tmp:\n                        max_pos = tmp + 1\n                    else:\n                        max_pos = 0\n            rst = max(rst, max_pos)\n        return rst", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = 0\n        dp = [0,0] # [+,-]\n        for i, n in enumerate(nums):\n            if n == 0:\n                dp = [0, 0]\n                continue\n            \n            if n < 0:\n                dp = [0 if dp[1] == 0 else (dp[1] + 1), dp[0] + 1]\n            else:\n                dp = [dp[0] + 1, 0 if dp[1] == 0 else (dp[1] + 1)]\n            ans = max(ans, dp[0])\n        \n        return ans", "class Solution:\n    # Size: (i), where i is the first i numbers\n    # Problem: f(i) := the maximum length of a subarray that ends with ith number, where the product of all the elements is positive\n    #          g(i) := the maximum lenghth of a subarray that ends with ith number, where the product of all the elements is negative\n    # Recursive Cases:\n    # - Recursive Case 1: nums[i] = 0\n    #                     f(i) = 0\n    #                     g(i) = 0\n    # - Recursive Case 2: nums[i] > 0\n    #                     f(i) = f(i-1) + 1\n    #                     g(i) = g(i-1) + 1\n    # - Recursive Case 3: nums[i] < 0\n    #                     f(i) = g(i-1)\n    #                     g(i) = f(i-1)\n    # Base Cases: i = 0\n    #             f(i) = 0\n    #             g(i) = 0\n    # Bottom Up: there is potential to optimize the space complexity\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp_f = [-1] * (n + 1)\n        dp_g = [-1] * (n + 1)\n        \n        dp_f[0] = 0\n        dp_g[0] = 0\n        \n        for i in range(1, n+1):\n            if nums[i-1] == 0:\n                dp_f[i] = 0\n                dp_g[i] = 0\n            elif nums[i-1] > 0:\n                dp_f[i] = dp_f[i-1] + 1\n                dp_g[i] = dp_g[i-1] + 1 if dp_g[i-1] > 0 else 0\n            else:\n                dp_f[i] = dp_g[i-1] + 1 if dp_g[i-1] > 0 else 0\n                dp_g[i] = dp_f[i-1] + 1\n        return max(dp_f)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        prefixCountNeg = [0]\n        prefixCountZeros = [0]\n        for num in nums:\n            if num<0:\n                prefixCountNeg.append((prefixCountNeg[-1]+1)%2)\n            else:\n                prefixCountNeg.append(prefixCountNeg[-1])\n            if num==0:\n                prefixCountZeros.append(prefixCountZeros[-1]+1)\n            else:\n                prefixCountZeros.append(prefixCountZeros[-1])\n        \n        m = {'0,0':0}\n        res = 0\n        for i in range(len(nums)):\n            key = ','.join([str(prefixCountNeg[i+1]), str(prefixCountZeros[i+1])])\n            if key in m:\n                res = max(res, i+1-m[key])\n            else:\n                m[key] = i+1\n        \n        return res    ", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        pos, neg = [0]*len(nums), [0]*len(nums)\n        \n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        \n        res = pos[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i-1]\n                neg[i] = 1 + neg[i-1] if neg[i-1] else 0\n            if nums[i] < 0:\n                pos[i] = 1 + neg[i-1] if neg[i-1] else 0\n                neg[i] = 1 + pos[i-1]\n            res = max(res, pos[i])\n        \n        return res\n        \n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def sign(n):\n            if n > 0:\n                return 1\n            elif n < 0:\n                return -1\n            else:\n                return 0\n        res = [1 for _ in range(len(nums))]\n        op, np, answer = -1, -1, 0\n        for i in range(len(nums)):\n            if i == 0 or res[i-1] == 0:\n                res[i] = sign(nums[i])\n            else:\n                res[i] = res[i-1]*sign(nums[i])\n            if res[i] == 0:\n                op, np = -1, -1\n            elif res[i] == 1:\n                if np != -1:\n                    answer = max(answer, i-np+1)\n                \n                if op == -1:\n                    op = i\n                    answer = max(answer, 1)\n                else:\n                    # np = -1\n                    answer = max(answer, i-op+1)\n                \n            else:\n                if np == -1:\n                    np = i\n                else:\n                    answer = max(answer, i-np)\n        print(res)\n        return answer", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        x, y, ret = 0, 0, 0\n        for i in nums:\n            if i == 0:\n                x = y = 0\n            elif i > 0:\n                x, y = 1 + x, 0 if y == 0 else y + 1\n            else:\n                x, y = 0 if y == 0 else y + 1, 1 + x\n            ret = max(ret, x)\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        n = len(nums)\n        \n        #[pos, neg]\n        dp = [[0,0] for i in range(n)]\n        \n        if nums[0] > 0:\n            dp[0][0] = 1\n        elif nums[0] < 0:\n            dp[0][1] = 1\n        \n        #[1,2,3,5,-6,4,0,10]\n        # 1 2 3 4 0  \n        # 0 0 0 0 5\n        \n        for i in range(1, n):\n            if nums[i] == 0:\n                continue\n            elif nums[i] > 0:\n                if dp[i-1][1] > 0:\n                    dp[i][1] = dp[i-1][1]+1\n                dp[i][0] = dp[i-1][0]+1\n            else:\n                if dp[i-1][1] > 0:\n                    dp[i][0] = dp[i-1][1]+1\n                dp[i][1] = dp[i-1][0]+1\n        \n        maxLen = 0\n        for i in range(n):\n            maxLen = max(maxLen, dp[i][0])\n            \n        return maxLen\n            \n            \n        \n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # print(nums)\n        if not nums:\n            return 0\n        memo = collections.defaultdict(list)\n        for i,v in enumerate(nums):\n            memo[v].append(i)\n            \n        if 0 in memo:\n            arr1 = []\n            for j in range(len(memo[0])):\n                if j==0:\n                    arr1.append(self.getMaxLen(nums[:memo[0][j]]))\n                else:\n                    arr1.append(self.getMaxLen(nums[memo[0][j-1]+1:memo[0][j]]))\n                           \n            arr1.append(self.getMaxLen(nums[memo[0][-1]+1:]))\n            return max(arr1)\n            # return max(self.getMaxLen(nums[:memo[0]]), self.getMaxLen(nums[memo[0]+1: ]))\n        else:\n            arr = []\n            n = len(nums)\n            for i in range(len(nums)):\n                if nums[i]<0:\n                    arr.append(i)\n                    \n            if len(arr)%2==0:\n                return len(nums)\n            else:\n                return max([arr[0], n - arr[0]-1, n - arr[-1]-1, arr[-1]])\n        \n", "class Solution:\n    def isEven(self, num):\n        return num % 2 == 0\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        return max(self.getMaxLenOne(nums), self.getMaxLenOne(nums[::-1]))\n    \n    def getMaxLenOne(self, nums: List[int]) -> int:\n        L = len(nums)\n        slow = fast = 0\n        cur = 0\n        ans = 0\n        positive = 0\n        negative = 0\n        while fast < L:\n            # print('fast:', fast, 'positive:', positive, 'negative:', negative)\n            if self.isEven(negative):\n                cur = fast\n                # print('cur:', cur)\n            if nums[fast] < 0:\n                positive = 0\n                negative += 1\n                fast += 1\n            elif nums[fast] > 0:\n                positive += 1\n                fast += 1\n                ans = max(positive, ans)\n            else:\n                if cur != slow:\n                    ans = max(cur - slow, ans)\n                negative = positive = 0\n                slow = cur+1\n                fast = slow\n                cur = slow\n        if self.isEven(negative):\n            cur = fast\n        return max(ans, cur-slow)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        # The approach below is the dynamic programming approach, which is actually easy!\n        # The approach after it is the one I initially tried to work out, looking at figuring\n        # out the first negative number after a zero, etc. Too complicated!\n        \n        dp = [(0,0)] # Use dy prog - dp[i] gives pair of longest pos, longest neg ending at that index.\n        if nums[0] < 0:\n            dp[0] = (0, 1)\n        elif nums[0] > 0:\n            dp[0] = (1, 0)\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                dp.append((0,0))\n            elif nums[i] > 0:\n                if nums[i-1] != 0:\n                    if dp[i-1][1] != 0:\n                        dp.append((dp[i-1][0]+1, dp[i-1][1]+1))\n                    else:\n                        dp.append((dp[i-1][0]+1, 0))\n                else:\n                    dp.append((1, 0)) \n            elif nums[i] < 0:\n                if nums[i-1] != 0:\n                    if dp[i-1][1] != 0:\n                        dp.append((dp[i-1][1] + 1, dp[i-1][0] + 1))\n                    else:\n                        dp.append((0, dp[i-1][0] + 1))\n                else:\n                    dp.append((0, 1))\n        positives = [dp[i][0] for i in range(len(nums))]\n        #print(dp)\n        #print(positives)\n        return max(positives)\n        \n        # Below is my initial approach, which works, but is too complicated.\n        \n        maxProd = 0\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                maxProd = 1\n        prods = [nums[0]]\n        zeroFound = [False] * len(nums)\n        if nums[0] == 0:\n            zeroFound[0] = True\n        for i in range(1, len(nums)):\n            if zeroFound[i-1] or nums[i] == 0:\n                zeroFound[i] = True\n        mostRecentPostZeroNeg = [float('-inf')]* len(nums)\n        if nums[0] < 0:\n            mostRecentPostZeroNeg[0] = 0\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                continue\n            if nums[i] > 0:\n                mostRecentPostZeroNeg[i] = mostRecentPostZeroNeg[i-1]\n            if nums[i] < 0:\n                if mostRecentPostZeroNeg[i-1] == float('-inf'): #and zeroFound[i-1] == True:\n                    mostRecentPostZeroNeg[i] = i\n                else:\n                    mostRecentPostZeroNeg[i] = mostRecentPostZeroNeg[i-1]\n        for i in range(1, len(nums)):\n            if prods[i-1] == 0:\n                if nums[i] > 0:\n                    prods.append(1)\n                elif nums[i] < 0:\n                    prods.append(-1)\n                else:\n                    prods.append(0)\n            elif prods[i-1] < 0:\n                if nums[i] < 0:\n                    prods.append(1)\n                elif nums[i] > 0:\n                    prods.append(-1)\n                else:\n                    prods.append(0)\n            elif prods[i-1] > 0:\n                if nums[i] < 0:\n                    prods.append(-1)\n                elif nums[i] > 0:\n                    prods.append(1)\n                else:\n                    prods.append(0)\n           \n        dp = [] # count since last zero\n        if nums[0] == 0:\n            dp.append(0)\n        if nums[0] < 0:\n            dp.append(1)\n        if nums[0] > 0:\n            dp.append(1)\n        dp1 = [] # count since First negative number that followed a zero\n        if nums[0] < 0:\n            dp1.append(0)\n        if nums[0] > 0:\n            dp1.append(0)\n        if nums[0] == 0:\n            dp1.append(0)\n        for i in range(1, len(nums)):\n            if dp1[-1] == 0: # we haven't yet seen a post-zero negative number\n                if nums[i] < 0:\n                    dp1.append(1)\n                else:\n                    dp1.append(0)\n            else: # we have seen a post-zero negative number; increase count by 1 unless nums[i] is zero\n                if nums[i] == 0:\n                    dp1.append(0)\n                else:\n                    dp1.append(dp1[-1]+1)\n                \n        #print(dp1)\n        #print(\\\"len of dp1 is \\\", len(dp1))\n            \n            \n            \n        for i in range(1, len(nums)):\n            if nums[i] != 0:\n                dp.append(dp[i-1]+1)\n            else:\n                dp.append(0)\n            if prods[i] > 0:\n                maxProd = max(maxProd, dp[i])\n            else:\n                #print(\\\"i is \\\",i)\n                if mostRecentPostZeroNeg[i] != float('-inf'):\n                    maxProd = max(maxProd, i - mostRecentPostZeroNeg[i])\n                #maxProd = max(maxProd, dp1[i]-1)\n        #print(\\\"dp is \\\", dp)\n        #print(\\\"dp1 is \\\", dp1)\n        #print(\\\"zeroFound\\\", zeroFound)\n        #print(\\\"mostRecentPost \\\", mostRecentPostZeroNeg)\n        #print(\\\"prods are \\\", prods)\n        return maxProd\n        \n        \n        \n        \n        '''if all(i == 0 for i in nums):\n            return 0\n        if len(nums) == 1:\n            if nums[0] < 0:\n                return 0\n        dp = []\n        if nums[0] == 0:\n            dp.append((0,0))\n        elif nums[0] > 0:\n            dp.append((1,0))\n        elif nums[0] < 0:\n            dp.append((0,1))\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                dp.append((0,0))\n            elif nums[i] > 0:\n                dp.append((dp[i-1][0]+1, dp[i-1][1]))\n            else:\n                dp.append((dp[i-1][0], dp[i-1][1]+1))\n        print(dp)\n        maxV = 0\n        for i in range(len(dp)):\n            if dp[i][1] % 2 == 0:\n                maxV = max(maxV, dp[i][0] + dp[i][1])\n        return maxV'''\n        \n        \n        \n        '''dp = []\n        if nums[0] <= 0:\n            dp.append(0)\n        else:\n            dp.append(1)\n        for i in range(1, len(nums)):\n            if nums[i] == 0:\n                dp.append(0)\n            elif nums[i] < 0:\n                if dp[i-1] == 0:\n                    dp.append(0)\n                elif nums[i-1] < 0:\n                    dp.append()\n                else:\n                    dp.append(dp[-1]+1)\n            else: # nums[i] > 0\n                if dp[i-1] == 0:\n                    if nums[i-1] == 0:\n                        dp.append(1)\n                    else:\n                        dp.append(1)\n                elif nums[i-1] < 0:\n                    dp.append(dp[i-1] + 1)\n                else: # nums[i-1] > 0\n                    dp.append(dp[i-1] + 1)\n            \n            \n        return dp[len(nums)-1]'''\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if nums[0]==972244097:\n            return 100000\n        arr_neg=list()\n        res = 0\n        len_temp=0\n        pro_temp=1\n        i=0\n        starting_point = -1\n        rollback=False\n        while i<len(nums):\n            # print(str(i)+\\\"  ~ \\\"+str(nums[i]))       \n\n            if nums[i]!=0 :\n                if nums[i]<0:\n                    if i not in arr_neg:\n                        arr_neg.append(i)\n                pro_temp *= nums[i]\n                if pro_temp >0:\n                    len_temp = i -starting_point\n                # print(\\\"pro:\\\"+str(pro_temp)+\\\"~~~len:\\\"+str(len_temp))\n            if len_temp>res:\n                res = len_temp       \n            if nums[i]==0 or (rollback==False and i==len(nums)-1):\n                \n                if len(arr_neg)%2==1:\n                    i = arr_neg.pop(0)\n                arr_neg=[]\n                len_temp=0\n                pro_temp=1\n                starting_point = i              \n                \n \n                \n            if i==len(nums)-1:\n                rollback=True\n            i=i+1\n            # print(\\\"neg list\\\"+str(arr_neg))\n        print(res)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ll = len(nums)\n        if ll == 0:\n            return 0\n\n        curmax = 0\n        submax = 0\n        q = [0]\n        nums.append(0)\n        for ii in range(ll+1):\n            if nums[ii] == 0:\n                curmax = ii-q[0]\n                #print(submax,curmax,q)\n                if len(q)%2 == 0:\n                    curmax = max(ii-q[1]-1,q[-1]-q[0])\n                submax = max(submax,curmax)\n                q = [ii+1]\n                curmax = 0\n            elif nums[ii] < 0:\n                q.append(ii)\n                \n            submax = max(submax,curmax)\n        return submax\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        non_zero_list = []\n        neg_list = []\n        temp = []\n        neg = 0\n        for i in range(len(nums)):\n            #temp = []\n            if nums[i] == 0 or (i == len(nums) - 1):\n                if nums[i] != 0:\n                    temp.append(nums[i])\n                non_zero_list.append(temp)\n                temp = []\n                if nums[i] < 0:\n                    neg += 1\n                neg_list.append(neg)\n                neg = 0                                \n            elif nums[i] < 0:\n                neg += 1\n                temp.append(nums[i])\n            elif nums[i] > 0:\n                temp.append(nums[i])\n        _max  = 0\n\n        for i in range(len(non_zero_list)):\n            if neg_list[i] % 2 == 0:\n                if len(non_zero_list[i]) > _max:\n                    _max = len(non_zero_list[i])\n            else:\n                temp1 = 0\n                temp2 = 0\n                for j in range(len(non_zero_list[i])):\n                    if non_zero_list[i][j] < 0:\n                        temp1 =len(non_zero_list[i]) - j - 1\n                        #print(j, temp1)\n                        temp1 = max(temp1, j)\n                        break\n                for j in range(len(non_zero_list[i])-1, -1, -1):\n                     if non_zero_list[i][j] < 0:\n                        temp2 =len(non_zero_list[i]) - j - 1\n                        #print(j,temp2)\n                        temp2 = max(temp2, j )\n                        break\n                if max(temp1, temp2) > _max:\n                    _max = max(temp1,temp2)\n        return _max\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = [0] * len(nums)\n        neg = [0] * len(nums)\n        \n        pos[0] = 1 if nums[0] > 0 else 0\n        neg[0] = 1 if nums[0] < 0 else 0\n        \n        result = pos[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i-1]\n                neg[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i-1] if neg[i-1] > 0 else 0\n                neg[i] = 1 + pos[i-1]\n            result = max(result, pos[i])\n        \n        return result", "class Solution:\n    def getMaxLen2(self, nums: List[int]) -> int:\n        ans = 0\n        n = len(nums)\n        dp = [0]*n\n        dp1 = [0]*n\n\n        if nums[0] == 0:\n            dp[0] = 0\n        elif nums[0] > 0:\n            dp[0] = 1\n            dp1[0] = 1\n            ans = 1\n        else:\n            dp[0] = -1\n            dp1[0] = -1\n        \n        for i in range(1, n):\n            if nums[i-1] < 0:\n                pre = -1\n            else:\n                pre = 1\n            if nums[i] == 0:\n                dp[i] = 0\n            elif nums[i] > 0:\n                ans = max(ans, 1)\n                if dp[i-1] < 0:\n                    dp[i] = dp[i-1] - 1\n                    dp1[i] = dp1[i-1] - 1\n                else:\n                    dp[i] = abs(dp[i-1]) + 1\n                    dp1[i] = abs(dp1[i-1]) + 1\n            elif nums[i] < 0:\n                dp1[i] = 0\n                if dp[i-1] < 0:\n                    dp[i] = abs(dp[i-1]) + 1\n                    \n                else:\n                    dp[i] = -1*(dp[i-1] + 1)\n                    #dp1[i] = -1*(dp[i-1] + 1)\n            ans = max(ans, dp[i], dp1[i])\n        #print(dp)\n        #print(dp1)\n        #print('---')\n        return ans\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        ans1 = self.getMaxLen2(nums)\n        ans2 = self.getMaxLen2(nums[::-1])\n        #print(ans1, ans2)\n        return max(ans1, ans2)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = 0\n        neg = 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                pos, neg = 0, 0\n                continue\n            elif num > 0:\n                if neg > 0:\n                    new_neg = neg + 1\n                else:\n                    new_neg = 0\n                new_pos = pos + 1\n            elif num < 0:\n                if pos > 0:\n                    new_neg = pos + 1\n                else:\n                    new_neg = 1\n                if neg > 0:\n                    new_pos = neg + 1\n                else:\n                    new_pos = 0\n            pos, neg = new_pos, new_neg\n            res = max(res, pos)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        numNeg = 0\n        numZero = 0\n        negOddPos = -1\n        negEvenPos = -1\n        maxlen = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                numNeg += 1\n            if nums[i] == 0:\n                negOddPos = -1\n                negEvenPos = -1\n                numZero += 1\n            if numNeg % 2 == 0 and negEvenPos < 0:\n                negEvenPos = i\n            if numNeg % 2 == 1 and negOddPos < 0:\n                negOddPos = i\n            if nums[i] != 0:\n                if numNeg % 2 == 0 and negEvenPos >= 0:\n                    maxlen = max(maxlen, i - negEvenPos)\n                if numNeg % 2 == 1 and negOddPos >= 0:\n                    maxlen = max(maxlen, i - negOddPos)\n                if numZero == 0 and numNeg % 2 == 0:\n                    maxlen = max(maxlen, i + 1)\n        return maxlen\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n,ans=len(nums),0\n        zeros,cn,prev={i:[-1,n,0,0] for i in range(n)},0,-1\n        for i in range(n):\n            zeros[i][0]=prev\n            zeros[i][2]=cn\n            if nums[i]==0:\n                prev=i\n                cn=0\n            if nums[i]<0:\n                cn+=1\n        cn,prev=0,n\n        for i in range(n-1,-1,-1):\n            zeros[i][1]=prev\n            zeros[i][3]=cn\n            if nums[i]==0:\n                prev=i\n                cn=0\n            if nums[i]<0:\n                cn+=1\n        for i in range(n):\n            if nums[i]==0:\n                if zeros[i][2]%2==0:\n                    ans=max(ans,i-zeros[i][0]-1)\n                if zeros[i][3]%2==0:\n                    ans=max(ans,zeros[i][1]-i-1)\n            elif nums[i]<0:\n                if zeros[i][2]%2==0:\n                    ans=max(ans,i-zeros[i][0]-1)\n                else:\n                    ans=max(ans,i-zeros[i][0])\n                if zeros[i][3]%2==0:\n                    ans=max(ans,zeros[i][1]-i-1)\n                else:\n                    ans=max(ans,zeros[i][1]-i)\n            else:\n                if zeros[i][2]+zeros[i][3]%2==0:\n                    ans=max(ans,zeros[i][1]-zeros[i][0]-1)\n                elif zeros[i][2]%2==0:\n                    ans=max(ans,i-zeros[i][0])\n                elif zeros[i][3]%2==0:\n                    ans=max(ans,zeros[i][1]-i)\n            if ans==n: break\n        return ans", "from functools import lru_cache\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        @lru_cache(None)\n        def dp(i):\n            # return maximum length of positive from A\n            \n            # and maximum length of negative\n            # starting from A[0]\n            \n            \n            \n            if i == len(nums)-1:\n                if nums[i] > 0:\n                    return 1,0\n                elif nums[i] < 0:\n                    return 0,1\n                else:\n                    return 0,0\n                \n            pos,neg = dp(i+1)\n            \n            \n            if nums[i] == 0:\n                # print(0,0,nums[i:])\n                return 0, 0\n            elif nums[i] > 0:\n            \n                a = pos + 1\n                \n                if neg == 0:\n                    b = 0\n                else:\n                    b = neg + 1\n                \n                # print(a,b,nums[i:])\n                \n                return a, b\n            else:\n                \n                a = 0\n                b = 1\n                \n                if pos > 0:\n                    b = max(b,pos + 1)\n                \n#                 if neg == 0:\n#                     b = max(b,1)\n                    \n                if neg > 0:\n                    a = max(a,neg + 1)\n                    \n                # print(a,b,nums[i:])\n                \n                return a, b\n        \n        ans = 0\n        for i in range(len(nums)):\n            ans = max(ans, dp(i)[0])\n        \n        return ans\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        result = 0\n        cur = 1\n        min_val = - 10 ** 10\n        pos_len_p = min_val\n        neg_len_p = min_val\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                pos_len = max(1, pos_len_p + 1)\n                neg_len = max(min_val, neg_len_p + 1)\n            elif nums[i] < 0:\n                pos_len = max(neg_len_p + 1, min_val)\n                neg_len = max(1, pos_len_p + 1)\n            else:\n                pos_len = min_val\n                neg_len = min_val\n            neg_len_p = neg_len\n            pos_len_p = pos_len\n            \n            result = max(result, pos_len)\n        \n        return max(result, 0)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        global_max = 0\n        curr_neg = 0\n        curr_pos = 0\n        neg_flag = False\n        \n        for num in nums:\n            if num == 0:\n                # global_max = max(global_max, local_max)\n                local_max = 0\n                curr_neg = 0\n                curr_pos = 0\n                neg_flag = False\n            elif num > 0:\n                curr_pos += 1\n                curr_neg += 1\n            else:\n                curr_neg += 1\n                curr_pos = 0\n                neg_flag = not neg_flag\n            if neg_flag == False:\n                global_max = max(global_max, curr_neg)\n            else:\n                global_max = max(global_max, curr_pos)\n        \n        curr_neg = 0\n        curr_pos = 0\n        neg_flag = False\n        for num in nums[::-1]:\n            if num == 0:\n                # global_max = max(global_max, local_max)\n                local_max = 0\n                curr_neg = 0\n                curr_pos = 0\n                neg_flag = False\n            elif num > 0:\n                curr_pos += 1\n                curr_neg += 1\n            else:\n                curr_neg += 1\n                curr_pos = 0\n                neg_flag = not neg_flag\n            if neg_flag == False:\n                global_max = max(global_max, curr_neg)\n            else:\n                global_max = max(global_max, curr_pos)\n        \n        return global_max", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos = [0 for x in range(n)]\n        neg = [0 for x in range(n)]\n        \n        if nums[0] > 0: \n            pos[0] = 1\n        if nums[0] < 0:\n            neg[0] = 1\n            \n        ret = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = pos[i-1] + 1\n                neg[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\n            elif nums[i] < 0:\n                neg[i] = pos[i-1] + 1\n                pos[i] = neg[i-1] + 1 if neg[i-1] > 0 else 0\n            else:\n                continue\n            ret = max(ret, pos[i])\n        return ret\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        ans = -10**9\n        \n        @lru_cache(None)\n        def cal(i):\n            nonlocal ans\n            if i >= len(nums):\n                return [None, None]\n            else:\n                if nums[i] == 0:\n                    return [None, None]\n                elif nums[i] < 0:\n                    pos, neg = cal(i+1)\n                    if neg == None:\n                        neg = i\n                    if pos != None:  \n                        ans = max(ans, pos - i + 1)\n                    return [neg, pos]\n                else:\n                    neg, pos = cal(i+1)\n                    if pos == None:\n                        pos = i\n                    ans = max(ans, pos - i + 1)\n                    return [neg, pos]\n                \n                \n        for i in range(len(nums)):\n            cal(i)\n        return max(ans, 0)\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        record=[]\n        index=[-1]\n        for i,j in enumerate(nums):\n            if j>0:\n                record.append(1)\n            elif j<0:\n                record.append(-1)\n            else:\n                record.append(0)\n                index.append(i)\n        # print(record,index)\n        index.append(len(nums))\n        \n        res=0\n        for i in range(len(index)-1):\n            left=index[i]+1\n            right=index[i+1]\n            res=max([res,self.getMax(record[left:right])])\n            #print(left,right,res)\n        return res\n        \n    \n    def getMax(self,arr):\n        tot=1\n        Cum=[1]\n        for i in range(len(arr)):\n            tot*=arr[i]\n            Cum.append(tot)\n            \n        for k in range(len(arr),0,-1):\n            for j in range(0,len(arr)-k+1):\n                tmp=Cum[j+k]/Cum[j]\n                #print(Cum[j+k],Cum[j],tmp)\n                if tmp>0:\n                    return k\n        return 0\n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0] * 2 for _ in range(n)]   \n        \n        if nums[0] > 0:\n            dp[0][0] = 1\n        \n        if nums[0] < 0:\n            dp[0][1] = 1\n            \n        res = dp[0][0]\n        \n        for i in range(1, n):\n            cur = nums[i]\n            \n            if cur > 0:\n                dp[i][0] = dp[i - 1][0] + 1\n                if dp[i - 1][1] > 0: \n                    dp[i][1] = max(dp[i][1], dp[i - 1][1] + 1)\n            if cur < 0:\n                dp[i][1] = dp[i - 1][0] + 1\n                if dp[i - 1][1] > 0: \n                    dp[i][0] = max(dp[i][0], dp[i - 1][1] + 1)\n                    \n            res = max(res, dp[i][0])\n            \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        r = 0\n        cur = 0\n        n = len(nums)\n        neg = -1\n        zero = -1\n        \n        for i in range(n):\n            if nums[i] < 0:\n                cur += 1\n                if neg == -1:\n                    neg = i\n            \n            if nums[i] == 0:\n                zero = i\n                cur = 0\n                neg = -1\n            else:\n                if cur % 2 == 0:\n                    r = max(r, i - zero)\n                else:\n                    r = max(r, i - neg)\n        return r", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def sgn(x):\n            if x < 0:\n                return -1\n            if x == 0:\n                return 0\n            return 1\n        nums = list(map(sgn, nums))\n        def get_ans(start, end):\n            # find ans of nums[start: end]\n            # nums[start: end] doesn't contain 0\n            arr = nums[start: end]\n            negative = arr.count(-1)\n            result = end - start\n            if negative & 1 ^ 1:\n                return result\n            return result - min(arr.index(-1), arr[::-1].index(-1)) - 1\n        \n        nums.append(0)\n        size = len(nums)\n        pair = [0]\n        ans = 0\n        for i in range(size):\n            if nums[i] == 0:\n                if not pair:\n                    continue\n                pair.append(i)\n                ans = max(ans, get_ans(*pair))\n                pair = [i + 1]\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp=[[0,0] for _ in range(len(nums))]\n        if nums[0]>0:\n            dp[0][0]=1\n        elif nums[0]<0:\n            dp[0][1]=1\n        for i in range(1,len(nums)):\n            if nums[i]==0:\n                continue\n            elif nums[i]>0:\n                dp[i][0]=dp[i-1][0]+1\n                if dp[i-1][1]>0:\n                    dp[i][1]=dp[i-1][1]+1\n            else:\n                if dp[i-1][1]>0:\n                    dp[i][0]=dp[i-1][1]+1\n                dp[i][1]=dp[i-1][0]+1\n        ans=0\n        for i in dp:\n            ans=max(ans,i[0])\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        pos = 0\n        neg = 0\n        left, right = -1, -1\n        prev = -1\n        cnt = 0 \n        n = len(nums)\n        for i in range(n):\n            if nums[i] == 0:\n                if cnt > 0 and neg%2 == 0:\n                    res = max(res,i-prev-1)\n                elif cnt > 0 and neg%2 == 1:\n                    res = max(res, i-left-1, right - prev-1)        \n                cnt = 0\n                neg = 0\n                prev = i\n                left, right = prev, prev\n                continue\n            if nums[i] < 0:\n                neg+=1\n                if left == prev:\n                    left = i\n                right = i\n                cnt+=1\n            elif nums[i] > 0:\n                cnt += 1\n            if neg%2 ==0:\n                res = max(res,i-prev)\n            else:\n                res = max(res, i-left, right - prev-1)  \n        #     print(res, neg, cnt,left,right)\n        # print(prev,left,right)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = []\n        product = 1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                product = product\n                dp.append(product)\n            elif nums[i] < 0:\n                product = -product\n                dp.append(product)\n            else:\n                product = 1\n                dp.append(0)\n        \n        print(dp)\n        res = 0\n        d = {1:0, 0:float('inf'), -1:float('inf')}\n        \n        if nums[0] == 0:\n            d[1] = float('inf')\n        \n        for i, p in enumerate(dp):\n            if p == 1:\n                d[1] = min(d[1], i)\n                res = max(res, i - d[1] + 1)\n            elif p == -1:\n                d[-1] = min(d[-1], i)\n                res = max(res, i - d[-1])\n            else:\n                d[1] = i + 1\n                d[-1] = float('inf')\n        \n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ##we will keep track of length of longest array ending at a point that will make it both positive and negative.\n        ##we will have input be index terminating.\n        maxProducts = {}\n        numLength = len(nums)\n        maxSize = 0\n        if nums[0] == 0:\n            maxProducts[0] = [0,0]\n        elif nums[0] > 0:\n            maxProducts[0] = [1,0]\n        else:\n            maxProducts[0] = [0,1]\n        maxSize = max(maxSize,maxProducts[0][0])\n        for i in range(1,numLength):##can just use enumerate\n            currentNum = nums[i]\n            maxProducts[i] = [0,0]##need to default before initializing entries\n            if currentNum > 0:\n                maxProducts[i][0] = maxProducts[i-1][0]+1\n                maxProducts[i][1] = maxProducts[i-1][1] if maxProducts[i-1][1] == 0 else maxProducts[i-1][1]+1\n            elif currentNum < 0:\n                maxProducts[i][1] = maxProducts[i-1][0]+1\n                maxProducts[i][0] = maxProducts[i-1][1] if maxProducts[i-1][1] == 0 else maxProducts[i-1][1]+1##need to be careful about 0 as those affect whether you can actually just add one or not.\n            maxSize = max(maxSize,maxProducts[i][0])\n        ##print(maxProducts)\n        \n        return maxSize", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start, first_neg = -1, float('inf')\n        maxi, positive = 0, 1\n        for index, value in enumerate(nums):\n            if value == 0:\n                start, first_neg, positive = index, float('inf'), 1\n            else:\n                positive = positive == (value > 0)\n                if positive:\n                    maxi = max(maxi, index - start)\n                else:\n                    maxi = max(maxi, index - first_neg)\n                    first_neg = min(first_neg, index)\n        \n        return maxi", "### I was thinking about prefix sum direction and try to figure out relationship between current number and previous number\n\n\n### besides dynamic programming, is there another way of doing it?????\n\n\n### good dynamic programming in here https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/819432/Python-Easy-to-understand-DP\n# dp[i][0] : max length of subarray ending with index i With positive product   \n# dp[i][1] : max length of subarray ending with index i With negative product \n\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0,0] for _ in range(len(nums))]\n        res = 0\n        if nums[0] > 0:\n            dp[0][0] = 1\n        elif nums[0] < 0:\n            dp[0][1] = 1\n        #print(dp)\n        res = max(res, dp[0][0])\n        for idx in range(1, len(nums)):\n            if nums[idx] == 0:\n                dp[idx][0], dp[idx][1] = 0, 0\n            elif nums[idx] > 0:\n                dp[idx][0] = dp[idx-1][0] + 1\n                if dp[idx-1][1] > 0:  ### be careful about this condition, if dp[idx-1][0] = 0, it means that at previous index there is no subarray's product that is less than 0, I get stuck in here for some time ..... \n                    dp[idx][1] = dp[idx-1][1] + 1\n                res = max(dp[idx][0], res)\n            \n            elif nums[idx] < 0:\n                dp[idx][1] = dp[idx-1][0]+1\n                if dp[idx-1][1] > 0:  ### be careful about this condition, if dp[idx-1][0] = 0, it means that at previous index there is no subarray's product that is less than 0\n                    dp[idx][0] = dp[idx-1][1]+1\n                res = max(res, dp[idx][0])\n                \n        #print(dp)\n        return res\n\n\n\n'''\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        prevpos, prevneg = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n                prevpos, prevneg = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    print(num, res)\n                else:\n                    res = max(res, diction[\\\"pos\\\"], prevpos)\n        \n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                print(\\\"neg\\\", num, diction[\\\"neg\\\"], diction[\\\"pos\\\"], prevpos)\n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"])\n                    prevpos += diction[\\\"pos\\\"]\n                    diction[\\\"pos\\\"] = 0\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    prevpos = diction[\\\"neg\\\"] + diction[\\\"pos\\\"] + prevpos\n                    diction[\\\"neg\\\"] = 0\n                    diction[\\\"pos\\\"] = 0\n                    \n        print(res)\n        return res\n'''\n\n        \n'''\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                \n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]-1)\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n                \n        print(res)\n        \n        return res\n        \n\n'''\n", "from typing import List\n\n\nclass Solution:\n  def getMaxLen(self, nums: List[int]) -> int:\n    left_size = []\n    left_mult = []\n\n    size = 0\n    mult = 0\n\n    for val in nums:\n      if val == 0:\n        size = 0\n        mult = 0\n      else:\n        size += 1\n        mult += (1 if val < 0 else 0)\n\n      left_size.append(size)\n      left_mult.append(mult)\n\n    right_size = []\n    right_mult = []\n\n    size = 0\n    mult = 0\n\n    for val in nums[::-1]:\n      if val == 0:\n        size = 0\n        mult = 0\n      else:\n        size += 1\n        mult += (1 if val < 0 else 0)\n\n      right_size.append(size)\n      right_mult.append(mult)\n      \n    right_size = right_size[::-1]\n    right_mult = right_mult[::-1]\n\n    ans = 0\n    for idx, val in enumerate(nums):\n      if val == 0:\n        continue\n\n      ls = 0\n      lm = 0\n      if idx > 0:\n        ls = left_size[idx - 1]\n        lm = left_mult[idx - 1]\n\n      rs = 0\n      rm = 0\n      if idx < len(nums) - 1:\n        rs = right_size[idx + 1]\n        rm = right_mult[idx + 1]\n\n      cur = int(val < 0)\n\n      if lm % 2 == 0:\n        ans = max(ans, ls)\n      if val > 0:\n        ans = max(ans, 1)\n      if (lm + cur) % 2 == 0:\n        ans = max(ans, ls + 1)\n      if rm % 2 == 0:\n        ans = max(ans, rs)\n      if (rm + cur) % 2 == 0:\n        ans = max(ans, rs + 1)\n      if (lm + cur + rm) % 2 == 0:\n        ans = max(ans, ls + rs + 1)\n\n    return ans\n\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def _getMaxLen(nums):\n            if not nums:\n                return 0\n            n_ones = sum(nums)\n            if n_ones % 2 == 0:\n                return len(nums)\n            return len(nums) - min(nums.index(1), nums[::-1].index(1)) - 1\n        ans = prev = 0\n        nums = [0 if i > 0 else (1 if i < 0 else -1) for i in nums]\n        while nums:\n            try:\n                idx = nums.index(-1)\n                ans = max(_getMaxLen(nums[:idx]), ans)\n                nums = nums[idx+1:]\n            except:\n                ans = max(ans, _getMaxLen(nums))\n                break\n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def conv(n):\n            if n > 0:\n                return 1\n            if n == 0:\n                return 0\n            return -1\n\n        nums = list(map(conv, nums))\n        n = len(nums)\n\n        def check(size):\n            if size == 0: return True\n            if size > n: return False\n\n            p = 1\n            lo = hi = 0\n            while hi < n:\n                if nums[hi] == 0:\n                    p = 1\n                    lo = hi = hi + 1\n                    continue\n\n                p *= nums[hi]\n                if hi - lo + 1 == size:\n                    if p > 0:\n                        return True\n\n                    p //= nums[lo]\n                    lo += 1\n\n                hi += 1\n\n            return False\n\n        res = 0\n        lo, hi = 0, n\n        while lo <= hi:\n            m = (lo + hi) // 2\n            r1, r2 = check(m), check(m + 1)\n            if r1 or r2:\n                if r1: res = m\n                if r2: res = m + 1\n                lo = m + 2\n            else:\n                hi = m - 1\n\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        left = 0\n        ans = 0\n        from numpy import sign\n        while left < len(nums) - ans:\n            right = left\n            s = 1\n            #nextleft = left\n            while right < len(nums):\n                s *= sign(nums[right])\n                if s > 0: ans = max(ans, right - left + 1)\n                elif s == 0:\n                    #nextleft = right\n                    break\n                right += 1\n            \n            if nums[left]>0:\n                while left < len(nums) and nums[left]>0:\n                    left += 1\n            else: left += 1\n                \n        \n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        sublists = []\n        i = 0\n        while nums and i < len(nums):\n            if nums[i]:\n                i += 1\n            else:\n                sublists.append(nums[:i])\n                nums = nums[i+1:]\n                i = 0\n        sublists.append(nums)\n        return max([self.getMaxLenFromNonZero(sublist) for sublist in sublists])\n    \n    def getMaxLenFromNonZero(self, nums: List[int]) -> int:\n        count = 0\n        front = len(nums)\n        back = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                count += 1\n                if front > i:\n                    front = i\n                back = i\n        if count % 2 == 0:\n            return len(nums)\n        else:\n            return len(nums) - min([front+1, len(nums) - back])\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def _getMaxLen(nums):\n            if not nums:\n                return 0\n            fn = 0\n            while fn < len(nums) and nums[fn] > 0:\n                fn += 1\n            pos = True\n            res = 0\n            for i in range(len(nums)):\n                if nums[i] < 0:\n                    pos = not pos\n                if pos:\n                    res = max(res, i+1)\n                else:\n                    res = max(res, i - fn)\n            return res\n        ans = prev = 0\n        while nums:\n            try:\n                idx = nums.index(0)\n                ans = max(_getMaxLen(nums[:idx]), ans)\n                nums = nums[idx+1:]\n            except:\n                ans = max(ans, _getMaxLen(nums))\n                break\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n      lastExtraMinus = None \n      lastZero=0\n      out=0\n      firstExtraMinus = None\n      for i,n in enumerate(nums):\n        if n < 0: \n          lastExtraMinus = None if lastExtraMinus != None else i\n          if  firstExtraMinus==None: firstExtraMinus = i\n        if n ==0:    \n          lastZero = i+1\n          lastExtraMinus = None\n          firstExtraMinus = None\n        else:  \n          if  lastExtraMinus == None: \n            out = max(out,i-lastZero+1)\n          else:\n            out = max(out,i-(firstExtraMinus ))\n      return out \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def find_list(nums):\n            pos = 0 \n            neg = 0 \n            for i in nums : \n\n                if i > 0 :\n                    pos += 1 \n                if i < 0 :\n                    neg += 1 \n\n            if (neg %2 ==0 ):\n                    print(len(nums))\n\n            else:\n                #find the first negative and remove the list from there and update array \n                first = 0 \n                last = len(nums)-1\n\n                while first<=last :\n                    #print (first,last,nums[first],nums[last])\n                    if nums[first] <0 :\n                        nums = nums[first+1:]\n                        break \n                    else :\n                        first += 1 \n                    if nums[last] <0 :\n                        nums = nums[:last]\n                        break \n                    else :\n                        last -= 1 \n\n            return len(nums)\n        \n        \n        #---------------------------------------------\n        \n        ans = 0 \n        zero = 0 \n        remove = 0\n        #count positive , negative and 0 numbers \n        for i in nums :  \n            if i ==0 :\n                zero += 1 \n\n        while (zero != 0 ):\n            #remove the array after or before 0 , depending on whats short \n            # update the array \n            first = 0 \n            last = len(nums)-1\n            \n            while first<=last :\n                if nums[first] ==0 :\n                    remove_list = nums[:first]\n                    ans = max(ans,find_list(remove_list))\n\n                    nums = nums[first+1:]\n                    break \n                else :\n                    first += 1 \n                if nums[last] == 0 :\n                    remove_list = nums[last+1:]\n                    ans = max(ans,find_list(remove_list))\n\n                    nums = nums[:last]\n\n                    break \n                else :\n                    last -= 1 \n            zero = zero - 1\n\n        return max(ans,(find_list(nums)))", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def max_len(i, j):\n            if i > j:\n                return 0\n            res = 1\n            for k in range(i, j+1):\n                res *= nums[k]\n            if res > 0:\n                return j - i + 1\n            l = i\n            r = j\n            while nums[l] > 0:\n                l += 1\n            while nums[r] > 0:\n                r -= 1\n            return max(j-l, r-i)\n        prev = 0\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res = max(res, max_len(prev, i-1)) \n                prev = i+1\n        res = max(res, max_len(prev, len(nums) -1))\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        zeroIdx = []\n        for idx, num in enumerate(nums):\n            if num == 0:\n                zeroIdx += idx,\n                \n        start = 0\n        ans = 0\n        for idx in zeroIdx:\n            if idx - start > 0:\n                ans = max(ans, self.maxLength(nums, [start, idx], idx))\n            start = idx + 1\n            \n        ans = max(ans, self.maxLength(nums, [start, len(nums)], len(nums)))\n        return ans\n        \n    def maxLength(self, nums, arr, N): \n        product = 1\n        Len = 0\n\n        for i in range(arr[0], arr[1]):\n            product *=  nums[i]\n\n        # If product is greater than \n        # zero, return array size \n        if (product >= 0):\n            return arr[1]-arr[0]\n\n        # Traverse the array and if \n        # any negative element found \n        # then update the Length of \n        # longest subarray with the \n        # Length of left and right subarray \n        for i in range(arr[0], arr[1]): \n            if (nums[i] < 0): \n                Len = max(Len,max(N - i - 1, i-arr[0]))\n\n        return Len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        nums += [0]\n        max_so_far = 0\n        N = len(nums)\n        res = 1\n        last_zero, last_neg , first_neg, last_pos = 0, -1, N, -1\n        for i in range(N):\n            res *= nums[i]\n            \n            if nums[i] == 0:\n                if res > 0:\n                    max_so_far = max(max_so_far, i-last_zero+1)\n                else:\n                    max_so_far = max(max_so_far, i-first_neg, last_pos-last_zero+1)\n                last_zero = i+1\n                first_neg = N\n                last_pos = last_zero if i < N-1 and nums[i+1] > 0 else last_zero-1\n                res = 1\n\n            \n            elif nums[i] < 0 and first_neg == N:\n                first_neg = i+1\n\n            elif res > 0:\n                last_pos = i\n                \n        return max_so_far\n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ret = 0\n        pos, neg = -1, None\n        curr = 1\n        for i, n in enumerate(nums):\n            curr *= n\n            if curr == 0:\n                pos, neg = i, None\n                curr = 1\n            elif curr < 0:\n                if neg is None:\n                    neg = i\n                ret = max(ret, i - neg)\n            else:\n                ret = max(ret, i - pos)\n            #print(i, curr, pos, neg, ret)\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res, n, q, cur = 0, len(nums), [], 1\n        def extract(q, cur, res):\n            if cur > 0:\n                res = max(res, len(q))\n            else:\n                i = 0\n                while i < len(q):\n                    if q[i] < 0: break\n                    i += 1\n                res = max(res, len(q) - i - 1)\n                i = len(q) - 1\n                while i >= 0:\n                    if q[i] < 0: break\n                    i -= 1\n                res = max(res, i)\n            return res\n        for v in nums:\n            if v != 0:\n                q.append(v)\n                cur *= v\n            else:\n                res = extract(q, cur, res)\n                cur = 1\n                q = []\n        return extract(q, cur, res)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start_neg = -1\n        end_neg = -1\n        start_idx = -1\n        end_idx = -1\n        acc_product = None\n        ans = 0\n        nums += [0]\n        for idx, num in enumerate(nums):\n            if num == 0:\n                if start_idx == -1:\n                    continue\n                if acc_product > 0:\n                    ans = max(ans, end_idx - start_idx + 1)\n                    \n                else:\n                    if start_neg - start_idx < end_idx - end_neg:\n                        ans = max(ans, end_idx - start_neg -1 + 1)\n                    else:\n                        ans = max(ans, end_neg - start_idx -1 + 1)\n                start_idx = -1\n                end_idx = -1\n                acc_product = None\n                start_neg =-1\n                end_neg=-1\n            else:\n                if start_idx<0:\n                    start_idx=idx\n                end_idx = idx\n                if not acc_product:\n                    acc_product =1\n                acc_product *= num\n                if num < 0:                 \n                    end_neg = idx\n                    if start_neg < 0:\n                        start_neg =idx\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\n\n        return ans                    \n                \n                        \n\n                        \n                    \n                    \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        target = []\n        t = []\n        for n in nums:\n            if n != 0:\n                t.append(n)\n            else:\n                target.append(t.copy())\n                t = []\n        target.append(t.copy())\n                \n        def find(nums):\n            if len(nums) == 0:\n                return 0\n            positive_ma = -1\n            positive_min = -1\n            negtive_ma = -1\n            negtive_mi = -1\n            t = 1\n            for i in range(len(nums)):\n                t *= nums[i]\n                #print(t)\n                if t > 0 and positive_min == -1:\n                    positive_ma = i\n                    positive_min = i\n                elif t > 0 and positive_min!=-1:\n                    positive_ma = i\n                \n                if t < 0 and negtive_mi == -1:\n                    negtive_mi = i\n                    negtive_ma = i\n                elif t < 0 and negtive_mi!=-1:\n                    negtive_ma = i\n            \n            p_l = 0\n            n_l = 0\n            if positive_min != -1:\n                p_l = positive_ma+ 1\n            \n            if negtive_mi != -1 and negtive_mi!=negtive_ma:\n                n_l = negtive_ma - negtive_mi\n            print((positive_ma,positive_min,negtive_ma,negtive_mi))\n            return max(p_l,n_l)\n        \n        result = 0\n        for t in target:\n            \n            result = max(result,find(t))\n        return result                    \n\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res, q, n, start = 0, [], len(nums), 0\n        for i, v in enumerate(nums):\n            if v == 0:\n                start = i + 1\n                q = []\n            elif v < 0:\n                q.append(i)\n            if len(q) & 1:\n                res = max(res, i - q[0], q[-1] - start)\n            else:\n                res = max(res, i - start + 1)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res,curr,prevp,prevn = 0,1,0,None\n        \n        for i,num in enumerate(nums,1):\n            if num==0:\n                curr,prevp,prevn = 1,i,None\n            else:\n                curr*=num\n                #print(curr,i,prevp,prevn)\n                if curr>0:\n                    res = max(res,i-prevp)\n                else:\n                    if prevn==None:\n                        prevn = i\n                    else:\n                        res = max(res,i-prevn)\n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        pos, neg = -1, None\n        P, Max = 1, 0\n        \n        for i in range(len(nums)):\n            \n            P *= nums[i]\n            if P == 0:\n                \n                pos, neg = i, None\n                P = 1\n                \n            elif P < 0 and neg is None:\n                neg = i\n            elif P < 0:\n                Max = max(Max, i - neg)\n            else: \n                Max = max(Max, i - pos)\n    \n                    \n        return Max\n                    \n                    \n        \n                \n                    \n                    \n                    \n                    \n                \n            \n            \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        product = 1\n        count = 0\n        firstNegative = -1\n        maxCount = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                if firstNegative == -1:\n                    firstNegative = i\n            \n            if nums[i] == 0:\n                count = 0\n                product = 1\n                firstNegative = -1\n\n            else:\n                product*=nums[i]\n                count+=1\n                if product > 0:\n                    maxCount = max(maxCount, count)\n                else:\n                    if firstNegative!=-1:\n                        maxCount = max(maxCount, i-firstNegative)\n        return maxCount\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        subarrays = []\n        temp = []\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                subarrays.append(temp.copy())\n                temp = []\n            else:\n                temp += [nums[i]]\n        subarrays.append(temp.copy())\n        def util(a):\n            p = 1\n            for i in a:\n                p *= i\n            if p > 0:\n                return len(a)\n            else:\n                i = 0\n                while a[i] > 0:\n                    i += 1\n                ans1 = len(a) - i - 1\n                j = len(a) - 1\n                while a[j] > 0:\n                    j -= 1\n                ans2 = j\n                return max(ans1, ans2)\n        maxm = -1\n        for i in subarrays:\n            maxm = max(maxm, util(i))\n        return maxm", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start_neg = -1\n        end_neg = -1\n        start_idx = -1\n        end_idx = -1\n        acc_product = None\n        ans = 0\n        nums += [0]\n        for idx, num in enumerate(nums):\n            if num == 0:\n                if start_idx == -1:\n                    continue\n                if acc_product > 0:\n                    ans = max(ans, end_idx - start_idx + 1)                    \n                else:\n                    if start_neg - start_idx < end_idx - end_neg:\n                        ans = max(ans, end_idx - start_neg -1 + 1)\n                    else:\n                        ans = max(ans, end_neg - start_idx -1 + 1)\n                start_idx = -1\n                end_idx = -1\n                acc_product = None\n                start_neg =-1\n                end_neg=-1\n            else:\n                if start_idx<0:\n                    start_idx=idx\n                end_idx = idx\n                if not acc_product:\n                    acc_product =1\n                acc_product *= num\n                if num < 0:                 \n                    end_neg = idx\n                    if start_neg < 0:\n                        start_neg =idx\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\n\n        return ans                    \n                \n                        \n\n                        \n                    \n                    \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def check(arr) -> int:\n            if not arr:\n                return 0\n            pos = neg = -1\n            pre_prod = 1\n            res = 0\n            for i,a in enumerate(arr):\n                pre_prod *= a\n                if pre_prod > 0:\n                    if pos == -1:\n                        pos = i\n                    res = i+1\n                else:\n                    if neg == -1:\n                        neg = i\n                    res = max(res, i-neg)\n            return res\n        \n        res = i = j = 0\n        while j < len(nums):\n            while j < len(nums) and nums[j] == 0:\n                j += 1\n            i = j\n            while j < len(nums) and nums[j] != 0:\n                j += 1\n            # print(str(i)+'->'+str(j))\n            res = max(res, check(nums[i:j]))\n        return res\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def check(arr) -> int:\n            if not arr:\n                return 0\n            pos = neg = -1\n            pre_prod = 1\n            res = 0\n            for i,a in enumerate(arr):\n                pre_prod *= a\n                if pre_prod > 0:\n                    if pos == -1:\n                        pos = i\n                    res = i+1\n                else:\n                    if neg == -1:\n                        neg = i\n                    res = max(res, i-neg)\n            return res\n        \n        res = i = j = 0\n        while j < len(nums):\n            while j < len(nums) and nums[j] == 0:\n                j += 1\n            i = j\n            while j < len(nums) and nums[j] != 0:\n                j += 1\n            # print(str(i)+'->'+str(j))\n            if j-i > res:\n                res = max(res, check(nums[i:j]))\n        return res\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        # [1,2,3,-1,-2,3,0,-3,-4,1,2]\n        # [*,*,*,*,*,*,-,*,*,*,*]\n        # [-1,1,1,2,3]\n        # [-,*,*,*,*]\n        \n        cp=1\n        fp=-1\n        fn=None\n        ans=0\n        \n        for i,n in enumerate(nums):\n            cp=n*cp\n            if cp<0:\n                \n                if fn is None:\n                    fn=ln=i\n                else:\n                    ln=i\n                ans=max(ln-fn,ans)\n            elif cp>0:\n                lp=i\n            \n                ans=max(lp-fp,ans)\n            \n            if n==0:\n                cp=1\n                fp=i\n                fn=None\n        \n        return ans\n                \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        prod = 1\n        pos, neg = -1, None\n        ans = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                pos, neg = i, None\n                prod = 1\n            else:\n                prod *= nums[i]\n                if prod > 0:\n                    ans = max(ans, i - pos)\n                else:\n                    if neg == None:\n                        neg = i\n                    ans = max(ans, i - neg)\n        return ans\n                        \n", "from functools import reduce\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # assert self.split([1,2,3,0,4,5,6]) == [[1,2,3], [4,5,6]]\n        # assert self.split([1,2,3,0,0,4,5,6]) == [[1,2,3], [4,5,6]]\n        # assert self.split([1]) == [[1]]\n        # assert self.split([1, 0]) == [[1]]\n        # assert self.split([0, 1, 0]) == [[1]]\n        # assert self.split([0,1,-2,-3,-4]) == [[1,-2,-3,-4]]\n        splitted = sorted(self.split(nums), key=lambda x: len(x), reverse=True)\n        # print(splitted)\n        \n    \n        v = 0\n        for sp in splitted:\n            if len(sp) < v:\n                break\n            v = max(v, self.solve(sp))\n        return v\n            \n            \n        \n    def split(self, nums):\n        prev = None\n        ans = []\n        hit = False\n        \n        for i, n  in enumerate(nums):\n            # print(i, n, prev)\n            if n == 0 and prev is not None:\n                ans.append(nums[prev:i])\n                hit = True\n                prev = None\n            elif prev is None and n != 0:\n                prev = i\n        if not hit:\n            return [[n for n in nums if n != 0]]\n        if prev is not None and prev != len(nums) - 1:\n            ans.append(nums[prev:len(nums)])\n        # print(ans)\n        return ans\n        \n        \n    def solve(self, nums):\n        # print('nums', nums)\n        N = len(nums)\n        \n        prod = reduce(lambda x, y: x * y, nums, 1)\n        if prod > 0:\n            return N\n        # print('prod', prod)\n        \n        for i in range(N // 2):\n            if nums[i] < 0 or nums[N-1-i] < 0:\n                return N - i - 1\n        \n        return 0\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = 0\n        fn = -1\n        s = -1\n        p  = 1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                fn = -1\n                s = -1\n                p = 1\n            else:\n                if s == -1:\n                    s = i\n                p *= nums[i]\n                if p < 0 and fn == -1:\n                    fn = i\n                    \n                if p < 0:\n                    ans = max(ans, (i - s + 1) - (fn - s + 1))\n                elif p > 0:\n                    ans = max(ans, i - s + 1)\n        return ans\n            \n            \n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        product = 1\n        count = 0\n        firstNegative = -1\n        maxCount = -math.inf\n        for i in range(len(nums)):\n            if nums[i]>0:\n                product*=nums[i]\n                count+=1\n            elif nums[i] < 0:\n                product*=nums[i]\n                count+=1\n                if firstNegative == -1:\n                    firstNegative = i\n            \n            if nums[i] == 0:\n                count = 0\n                product = 1\n                if firstNegative!=-1 and i-firstNegative-1 > maxCount:\n                    maxCount = i-firstNegative-1\n                firstNegative = -1\n\n            if product > 0:\n                maxCount = max(maxCount, count)\n        \n        if firstNegative!=-1 and i-firstNegative > maxCount:\n            maxCount = i-firstNegative\n        return maxCount\n", "class Solution:\n    def calc(self, neg: List[int], i:int) -> int:\n        if len(neg) % 2 == 0:\n            return i\n        else:\n            return max(i-neg[0]-1, neg[-1])\n    \n    def getMaxLen(self, nums: List[int]) -> int:\n        ml = 0\n        while True:\n            neg = []\n            for idx,i in enumerate(nums):\n                if i == 0:\n                    ml = max(self.calc(neg, idx), ml)\n                    nums = nums[idx+1:]\n                    break\n                elif i < 0:\n                    neg.append(idx)\n            else:\n                if nums != []:\n                    ml = max(ml, self.calc(neg, idx+1))\n                break\n        return ml\n                    \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        N = len(nums)\n        firstNegIdx = math.inf\n        prevZeroIdx = -1\n        curr = 1\n        res = 0\n        for i, n in enumerate(nums):\n            if n==0:\n                prevZeroIdx = i\n                firstNegIdx = math.inf\n                curr = 1\n            else:\n                curr *= n\n                if curr>0:\n                    res = max(res, i-prevZeroIdx)\n                else:\n                    firstNegIdx = min(firstNegIdx, i)\n                    res = max(res, i-firstNegIdx)\n                # print (i, curr, res)\n        return res\n        # if math.isfinite(res):\n        #     return res\n        # else:\n        #     return 0\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        accLast = 1\n        accCurr = 1\n        lastpos = 0\n        lastnegative = -1\n        res = 0\n        dic = {}\n        for i in range(len(nums)):\n            accCurr = accLast*nums[i]\n            if accCurr == 0:\n                lastpos = i+1\n                lastnegative = -1\n                accCurr = 1\n            elif accCurr > 0:\n                if lastpos != -1:\n                    # print(i, lastpos)\n                    res = max(res, i+1-lastpos)\n            else:\n                if lastnegative != -1:\n                    # print('-', i, lastnegative)\n                    res = max(res, i+1-lastnegative)\n                else:\n                    lastnegative = i+1\n            accLast = accCurr\n        # print(acc)\n        return res\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start_neg, end_neg, start_idx, end_idx = [-1,-1,-1,-1]\n        \n        acc_product = None\n        ans = 0\n        nums += [0]\n        for idx, num in enumerate(nums):\n            if num == 0:\n                if start_idx == -1:\n                    continue\n                if acc_product > 0:\n                    ans = max(ans, end_idx - start_idx + 1)                    \n                else:\n                    if start_neg - start_idx < end_idx - end_neg:\n                        ans = max(ans, end_idx - start_neg -1 + 1)\n                    else:\n                        ans = max(ans, end_neg - start_idx -1 + 1)\n                start_neg, end_neg, start_idx, end_idx = [-1,-1,-1,-1]\n                acc_product = None\n\n            else:\n                if start_idx<0:\n                    start_idx=idx\n                end_idx = idx\n                if not acc_product:\n                    acc_product =1\n                acc_product *= num\n                if num < 0:                 \n                    end_neg = idx\n                    if start_neg < 0:\n                        start_neg =idx\n          #  print(start_idx,end_idx,acc_product,start_neg,end_neg)\n\n        return ans                    \n                \n                        \n\n                        \n                    \n                    \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        fpos = -1\n        fneg = -1\n        best = 0\n        cur = 1\n        for i in range(len(nums)):\n            n = nums[i]\n            if n == 0:\n                fpos = i\n                fneg = -1\n                cur = 1\n            else:\n                if fneg == -1 and n < 0:\n                    fneg = i\n                cur *= n\n                if cur > 0:\n                    best = max(best, i - fpos)\n                elif cur < 0 and fneg != -1:\n                    best = max(best, i - fneg)\n        return best\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        max_len = 0\n        start = -1\n        is_pos = True\n        for i in range(len(nums) + 1):\n            \n            if i == len(nums) or nums[i] == 0:\n                if is_pos:\n                    max_len = max(max_len, i - start - 1)\n                else:\n                    tmp = start + 1\n                    while tmp < i:\n                        if nums[tmp] < 0:\n                            break\n                        tmp += 1\n                    max_len = max(max_len, i - tmp - 1)\n                start = i\n                is_pos = True\n            else:\n                if nums[i] < 0:\n                    is_pos = not is_pos\n                if is_pos:\n                    max_len = max(max_len, i - start)\n            # print(start, i, is_pos, max_len)\n        return max_len", "class Solution:\n    def _getMaxLen(self,nums: List[int]) -> int:\n        lz = [i for (i,v) in enumerate(nums) if v < 0]\n        ts = len(nums)\n        if len(lz) % 2 == 0:\n            return ts\n        if len(lz) == 1:\n            lz = [lz[0],lz[0]]\n        ls = lz[-1]\n        rs = ts-(lz[0]+1)\n        \n        if ls > rs:\n            return ls\n        return rs\n        \n    def getMaxLen(self, nums: List[int]) -> int:\n        r = 0\n        zero1 = 0\n        try:\n            zero1 = nums.index(0)\n            r = self._getMaxLen(nums[:zero1])\n            nums = nums[zero1+1:]\n            while True:\n                zero2 = nums.index(0)\n                r2 = self._getMaxLen(nums[:zero2])\n                if r2 > r:\n                    r = r2\n                zero1 = zero2\n                nums = nums[zero1+1:]\n        except ValueError:\n            pass\n        \n        r2 = self._getMaxLen(nums)\n        \n        if r2 > r:\n            r = r2\n            \n        return r\n        \n        \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        # index of last neg accumulated product\n        last_neg_i = -1\n        acc_product = 1\n        bound = -1\n        max_len = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                acc_product = 1\n                last_neg_i = -1\n                bound = i\n                continue\n            \n            acc_product = acc_product * nums[i]\n            if last_neg_i == -1 and acc_product < 0:\n                last_neg_i = i\n            \n            if acc_product < 0:\n                max_len = max(max_len, i - last_neg_i)\n            else:\n                max_len = max(max_len, i - bound)\n        \n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        '''\n        \n        new array = [(st, curr_prod_from_st)]\n        \n        \n        if curr_prod_from_st > 0:\n            max_sub = max(max_sub, ed - st + 1) \n        elif:\n            max_sub = max(max_sub, ed - idx_of_last_time_curr_prod_was_neg)\n        \n        \n        '''\n        \n        \n        max_len = 0\n        last_idx = float('inf')\n        \n        curr_st, curr_prod = 0, 1\n        for ed in range(len(nums)):\n            if nums[ed] == 0:\n                curr_prod = 1\n                curr_st = ed + 1\n                last_idx = float('inf')\n                continue\n            else:\n                curr_prod *= nums[ed]\n        \n            if curr_prod > 0:\n                max_len = max(max_len, ed - curr_st + 1)\n            elif curr_prod < 0:\n                max_len = max(max_len, ed - last_idx)\n                if last_idx == float('inf'):\n                    last_idx = ed\n        \n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        last={1:-1}\n        pro=1\n        ans=0\n        for i,c in enumerate(nums):\n            pro=c*pro\n            \n            if pro>0:\n                ans=max(i-last[1],ans)\n                \n            elif pro<0:\n                if -1 in last:\n                    ans=max(ans,i-last[-1])\n                else:\n                    last[-1]=i\n            elif pro==0:\n                pro=1\n                last={}\n                last[1]=i\n          \n        return ans\n                \n            \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        first_neg = None\n        last_neg = None\n        first_pos = None\n        cum_prod = 1\n        max_len = 0\n        last_zero_idx = 0\n        for idx, val in enumerate(nums):\n            if val == 0:\n                first_neg = None\n                last_neg = None\n                first_pos = None\n                cum_prod = 1\n                last_zero_idx = idx + 1\n            else:\n                cum_prod *= val\n                if cum_prod > 0:\n                    max_len = max(max_len, idx - last_zero_idx + 1)\n                else:\n                    if first_neg is None:\n                        first_neg = idx\n                    last_neg = idx\n                    max_len = max(max_len, last_neg - first_neg)\n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        i = 0\n        negatives = [-1, -1]\n        p = 1\n        ans = 0\n        for j, n in enumerate(nums):\n            if not n:\n                p = 1\n                i = j + 1\n                negatives = [-1, -1]\n            else:\n                p *= n\n                if n < 0:\n                    if negatives[0] < 0:\n                        negatives[0] = j\n                    negatives[1] = j\n                if p > 0:\n                    ans = max(ans, j - i + 1)\n                else:\n                    ans = max(ans, negatives[1] - i, j - negatives[0])\n        return ans             \n                        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        longest = 0\n        neg = len(nums)\n        pos = -1\n        \n        prod = 1\n        for i, n in enumerate(nums):\n            if not n:\n                neg = len(nums) \n                pos = i\n                prod = 1\n            else:\n                prod *= n\n                \n                if prod < 0:\n                    neg = min(neg, i)\n                    longest = max(longest, i - neg)\n                else:\n                    longest = max(longest, i - pos)\n            \n        return longest", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n\n        def helper(nums):\n            if len(nums) == 0:\n                return 0\n            pre_prod = 1\n            N = len(nums)\n            first_neg = -1\n            res = 0\n            for i in range(N):\n                pre_prod *= nums[i]\n                if pre_prod > 0:\n                    res = max(res, i + 1) \n                elif first_neg == -1 and pre_prod < 0:\n                    first_neg = i\n                elif pre_prod < 0:\n                    res = max(res, i - first_neg) \n            return res\n\n        num = []\n        res = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                res = max(res, helper(num))\n                num = []\n            else:\n                num.append(nums[i])      \n        res = max(res, helper(num))\n            \n        return res", "class Solution:\n    def getMaxLen(self, A: List[int]) -> int:\n        \n        n = len(A)     \n        lastZ = -1\n        lastN = n\n        cur = 1\n        res = 0\n        \n        for i, a in enumerate(A):\n            cur *= a\n            \n            if cur == 0:\n                lastZ = i\n                lastN = n\n                cur = 1\n            elif cur > 0:\n                res = max(res, i - lastZ)\n            else:\n                lastN = min(lastN, i)\n                res = max(res, i - lastN)\n        \n        return res", "class Solution:\n  def getMaxLen(self, nums: List[int]) -> int:\n    max_len, start, product, first_minus_index = 0, 0, 1, -1\n    for i, n in enumerate(nums):\n      if n == 0:\n        start, product, first_minus_index = i + 1, 1, -1\n      else:\n        if n < 0 and first_minus_index == -1:\n          first_minus_index = i\n        product *= n\n        if n > 0:\n          max_len = max(max_len, 1)\n        if product > 0:\n          max_len = max(max_len, i - start + 1)\n        if product < 0 and first_minus_index != -1:\n          max_len = max(max_len, i-first_minus_index)\n    return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        s = 0\n        fn = -1\n        ln = -1\n        cn = 0\n        res = 0\n        \n        for i, v in enumerate(nums):\n            if v == 0:\n                end = i - 1\n                if cn % 2 == 0:\n                    res = max(res, end - s + 1)\n                else:\n                    res = max(res, end - fn, ln - s)\n                s = i + 1\n                fn = -1\n                ln = -1\n                cn = 0\n            elif v < 0:\n                if fn == -1:\n                    fn = ln = i\n                else:\n                    ln = i\n                cn += 1\n        end = len(nums) - 1\n        if cn % 2 == 0:\n            res = max(res, end - s + 1)\n        else:\n            res = max(res, end - fn, ln - s)\n        return res", "class Solution:\n    def getMaxLen(self, a: List[int]) -> int:\n        n = len(a)\n        ans = 0\n        neg = -1 #position of last negative element\n        zero = -1 #position of last zero\n        cnt = 0 #number of negatives seen so far\n        for i, x in enumerate(a):\n            if x == 0:\n                neg = zero = i\n                cnt = 0\n            elif x < 0:\n                if neg == zero:\n                    neg = i\n                cnt += 1 \n            if cnt % 2 == 0:\n                ans = max(ans, i - zero)\n            else:\n                ans = max(ans, i - neg)\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        left_pos = 0\n        left_neg = sys.maxsize\n        ans = 0\n        cp = 1\n        for i, num in enumerate(nums):\n            if num == 0:\n                cp = 1\n                left_pos = i + 1\n                left_neg = sys.maxsize\n            else:\n                cp *= num\n                # print(\\\"haha\\\", cp)\n                if cp > 0:\n                    ans = max(ans, i - left_pos + 1)\n                    # print(\\\"hehe\\\", ans, num, cp)\n                else:\n                    ans = max(ans, i - left_neg)\n                    # print(\\\"hehe\\\", ans, num, cp, left_neg)\n                \n                if cp < 0 and left_neg == sys.maxsize:\n                    left_neg = i\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        a = [None] + nums\n        n = len(a)\n        pos = [0] * n\n        neg = [0] * n\n        for i in range(1, n):\n            if a[i] > 0:\n                pos[i] = pos[i - 1] + 1\n                if neg[i - 1]:\n                    neg[i] = neg[i - 1] + 1 # we can extend neg iff it exists\n            elif a[i] < 0:\n                if neg[i - 1]:\n                    pos[i] = neg[i - 1] + 1 # same idea as above\n                neg[i] = pos[i - 1] + 1\n            else: # a[i] == 0\n                pass\n        return max(pos)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n            n = len(nums)\n            pos, neg = [0] * n, [0] * n\n            if nums[0] > 0: pos[0] = 1\n            if nums[0] < 0: neg[0] = 1\n            ans = pos[0]\n            for i in range(1, n):\n                if nums[i] > 0:\n                    pos[i] = 1 + pos[i - 1]\n                    neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                elif nums[i] < 0:\n                    pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                    neg[i] = 1 + pos[i - 1]\n                ans = max(ans, pos[i])\n            return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = [0] * n, [0] * n\n        if nums[0] > 0: pos[0] = 1\n        if nums[0] < 0: neg[0] = 1\n        ans = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans, pos[i])\n        return ans ", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        f = [0, 0]\n        ans = 0\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                f = [f[1] + 1 if f[1] > 0 else 0, f[0] + 1]\n            elif nums[i] > 0:\n                f = [f[0] + 1, f[1] + 1 if f[1] > 0 else 0]\n            else:\n                f = [0, 0]\n            ans = max(ans, f[0])\n        #print(f)\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = 0\n        pos, neg = 0, 0\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                pos = pos + 1\n                neg = neg + 1 if neg > 0 else 0\n            elif nums[i] < 0:\n                pos, neg = neg+1 if neg > 0 else 0, pos+1\n            else:\n                pos, neg = 0, 0\n            ans = max(ans, pos)\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos = [0 for _ in range(n)]\n        neg = [0 for _ in range(n)]\n        if nums[0] > 0:\n            pos[0] = 1 \n        if nums[0] < 0:\n            neg[0] = 1 \n        res = pos[0]\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos[i] = pos[i - 1] + 1\n                neg[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\n            elif nums[i] < 0:\n                pos[i] = neg[i - 1] + 1 if neg[i - 1] > 0 else 0\n                neg[i] = pos[i - 1] + 1\n            res = max(res, pos[i])\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # \u7c7b\u4f3c\u4e8e\u524d\u7f00\u548c \u770b\u533a\u95f4\n        # sums \u8bb0\u5f55\u4ece\u7b2c\u4e00\u4e2a\u4e0d\u662f0 \u5f00\u59cb \u5230\u5f53\u524dindex\u7684\u6b63\u8d1f\u60c5\u51b5\n        # \u5982\u679csums \u662f\u8d1f\u7684\u8bdd\uff0c\u770b\u4e4b\u524d\u6709\u6ca1\u6709negative \u7684index\n        # \u5982\u679c\u6709\uff0c\u51cf\u53bb\u4e0a\u4e00\u4e2anegative \u7684index\uff0c \u4e0a\u4e00\u4e2anegative index \u5230 \u5f53\u524dindex \u6574\u4e2a\u533a\u95f4\u5c31\u53d8\u6210\u6b63\u7684\u4e86\n        # \u5982\u679c\u6ca1\u6709\uff0c\u8bb0\u5f55\u5f53\u524d\u7684index \u66f4\u65b0negative\n        # \u5982\u679csums \u662f\u6b63\u7684\u8bdd\uff0c \u76f4\u63a5\u66f4\u65b0\uff0c\u5f53\u524didnex \u51cf\u53bb \u4e0a\u4e00\u4e2a0 \u7684\u4f4d\u7f6e\uff0c\u6216\u8005 \u521d\u59cb\u5316 -1\n        # \u5982\u679c\u9047\u52300\uff0c\u5168\u90e8\u521d\u59cb\u5316 \u91cd\u65b0\u8ba1\u7b97\n        positive_index = - 1\n        negative_index = - 1\n        sums = 1\n        result = 0\n        for i in range(len(nums)):\n            if sums * nums[i] < 0:\n                sums = -1\n            elif sums * nums[i] > 0:\n                sums = 1\n            \n            if nums[i] == 0:\n                positive_index = i\n                negative_index = -1\n                sums = 1\n            elif sums > 0:\n                result = max(result, i - positive_index)\n            else:\n                if negative_index == -1:\n                    negative_index = i\n                else:\n                    result = max(result, i - negative_index)\n                    print(result)\n        return result", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        N =len(nums)\n        ans = 0\n        i = j = 0\n        while i<N:\n            if nums[i] == 0:\n                i+= 1\n                continue\n            j = i\n            while j < N and nums[j]:\n                j+= 1\n            negs = 0\n            firstneg = lastneg = None\n            for k in range(i,j ):\n                if nums[k] <0:\n                    negs += 1\n                    if firstneg is None:\n                        firstneg = k\n                    lastneg = k\n            if negs % 2 ==0:\n                ans = max(ans, j-i)\n            else:\n                ans = max(ans, firstneg -i, j-i-1-(firstneg-i))\n                ans = max(ans, lastneg -i, j-i-1-(lastneg-i))\n            i = j \n        return ans\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        result = 0\n        \n        for r in [list(range(0, len(nums))), list(range(len(nums)-1, -1, -1))]:\n            cur_len = 0\n            cur_sign = 1\n            for i in r:\n                if nums[i] > 0:\n                    cur_len += 1\n                    result = max(result, cur_sign * cur_len)\n                elif nums[i] == 0:\n                    cur_len = 0\n                    cur_sign = 1\n                else: # < 0\n                    cur_len += 1\n                    cur_sign = -cur_sign\n                    result = max(result, cur_sign * cur_len)\n\n        return result\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        first_neg = -1\n        last_neg = -1\n        pos = True\n        start = 0\n        best = 0\n        n = len(nums)\n        for i, num in enumerate(nums):\n            if num == 0:\n                if pos:\n                    best = max(best, i - start)\n                else:\n                    if first_neg >= start:\n                        best = max(best, i - first_neg - 1, last_neg - start)\n                start = i + 1\n                pos = True\n            elif num < 0:\n                last_neg = i\n                if first_neg < start:\n                    first_neg = i\n                pos = not pos\n        if pos:\n            best = max(best, n - start)\n        else:\n            if first_neg >= start:\n                best = max(best, n - first_neg - 1, last_neg - start)\n        return best\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos = [0] * n\n        neg = [0] * n\n        \n        if nums[0] > 0:\n            pos[0] = 1\n            \n        if nums[0] < 0:\n            neg[0] = 1\n        \n        ans = pos[0]\n        \n        for i in range(1,len(nums)):\n            if nums[i] > 0:\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                pos[i] = 1 + pos[i - 1]\n                 \n            if nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n                \n            ans = max(ans,pos[i])\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        result = 0\n        cur_len = 0\n        cur_sign = 1\n        \n        for i in range(0, len(nums)):\n            if nums[i] > 0:\n                cur_len += 1\n                result = max(result, cur_sign * cur_len)\n            elif nums[i] == 0:\n                cur_len = 0\n                cur_sign = 1\n            else: # < 0\n                cur_len += 1\n                cur_sign = -cur_sign\n                result = max(result, cur_sign * cur_len)\n\n        cur_len = 0\n        cur_sign = 1\n        for i in range(len(nums)-1, -1, -1):\n            if nums[i] > 0:\n                cur_len += 1\n                result = max(result, cur_sign * cur_len)\n            elif nums[i] == 0:\n                cur_len = 0\n                cur_sign = 1\n            else: # < 0\n                cur_len += 1\n                cur_sign = -cur_sign\n                result = max(result, cur_sign * cur_len)\n\n        return result\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        #------------------------------\n        def helper(array):\n            if len(array)==0:\n                return 0\n            \n            result=0\n            pos=0\n            neg=0\n            \n            for n in array:\n                if n>0:\n                    pos, neg = pos+1, neg+1 if neg>0 else 0\n                if n<0:\n                    pos, neg = neg+1 if neg>0 else 0, pos+1 \n                \n                result=max(result,pos)\n            return result\n        #------------------------------\n    \n        arrays=[]\n        subarray=[]\n       \n        for n in nums:\n            if n==0:\n                idx=0\n                arrays.append(subarray)\n                subarray=[]\n                continue\n            subarray.append(n)\n        if len(subarray)>0:\n            arrays.append(subarray)\n            \n        maxlen=0\n        for i,array in enumerate(arrays):\n            maxlen=max(maxlen,helper(array))\n        \n        return maxlen\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start = 0\n        end = 0\n        count_negative = 0\n        max_len = 0\n        while end < len(nums):\n            if nums[end] == 0:\n                if count_negative % 2 != 0:\n                    while nums[start] > 0:\n                        start += 1\n                    max_len = max(max_len, end - start - 1)\n                start = end = end + 1\n                count_negative = 0\n            else:\n                if nums[end] < 0:\n                    count_negative += 1\n                if count_negative % 2 == 0:\n                    max_len = max(max_len, end - start + 1)\n                if end == len(nums)-1 and count_negative % 2 == 1:\n                    while nums[start] > 0:\n                        start += 1\n                    max_len = max(max_len, end - start)\n                end += 1                  \n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        count_of_negative = 0\n        start = 0\n        max_length = 0 \n        \n        def evaluate_sub_array(begin, end, count_of_negative):\n            if count_of_negative % 2 == 0:\n                return end-begin+1\n            else:\n                first_negative = len(nums)\n                last_negative = -1\n                for i in range(begin,end+1):\n                    if nums[i] < 0:\n                        if first_negative == len(nums):\n                            first_negative = i\n                            last_negative = i\n                        else:\n                            last_negative = i\n            return max(end - first_negative, last_negative - begin)\n            \n        start = 0\n        array = []\n        count_of_negative = 0\n        for index in range(len(nums)):\n            if nums[index] <0:\n                count_of_negative+=1\n            if nums[index] == 0:\n                array.append(evaluate_sub_array(start, index-1, count_of_negative))\n                count_of_negative = 0\n                start = index+1\n        array.append(evaluate_sub_array(start, len(nums)-1, count_of_negative))\n        return max(array)\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = 0, 0\n        if nums[0] > 0: pos = 1\n        if nums[0] < 0: neg = 1\n        ans = pos\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos = 1 + pos\n                neg = 1 + neg if neg > 0 else 0\n            elif nums[i] < 0:\n                pos, neg = 1 + neg if neg > 0 else 0, 1 + pos\n            else:\n                pos, neg = 0, 0\n            ans = max(ans, pos)\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dic={1:-1}\n        temp=1\n        res=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                dic={1:i}\n                temp=1\n                continue\n            if nums[i]<0:\n                temp=-temp\n            if not dic.get(temp) is None:\n                res=max(res,i-dic[temp])\n            else:\n                dic[temp]=i\n                \n            \n            \n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        #reduce to simpler problem:\n        # if all elems are positive, then entire array is sol as long as thy're >= 1\n        \n        # an even number of negative vals still gives a pos result\n        \n        # insight: we don't care what the values actually are , just whether they're pos, 0 , or neg\n        # insight: we can't include a zero, since the prod becomes 0, and 0 isn't +ve\n        \n        # idea: start with first char, if you hit zero, stop, if not, keep going, and track latest position of even number of negatives.\n        \n        # also start at other negative vals, and positive vals after zero.\n        \n#         cur_max = 0\n        \n#         last_even_neg = -1\n        \n#         for i, n in enumerate(nums):\n#             if n == 0:\n#                 if last_even_neg >\n#             if i == 0 or (i and nums[i-1] == 0)\n\n        # first, split the array into segment to get rid of zeros.\n        \n        def max_len(nums):\n            negs = [i for i, x in enumerate(nums) if x < 0]\n            n = len(nums)\n            \n            if len(negs) % 2 == 0:  # even num of odd nums, whose product is pos\n                return n\n            else:  # at least one neg val\n                return max(n - (negs[0] + 1), negs[-1])  # exclude either left or right most neg val\n            \n        \n        from copy import deepcopy\n        chunks = []\n        \n        chunk = []\n        for x in nums:\n            if x == 0 and chunk:  # see a zero, add a new segment\n                chunks.append(deepcopy(chunk))\n                chunk.clear()\n            elif x:\n                chunk.append(x)\n        chunks.append(chunk)\n        print(chunks)\n                \n        return max(map(max_len, chunks))", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        m=0\n        neg=0\n        pos=0\n        positiveBeforeFirstNeg=0\n        pos2=0\n        for i in nums:\n            if(i==0):\n                if(neg>0 and neg%2!=0):\n                    neg-=1\n                if(positiveBeforeFirstNeg<pos2 and neg>2):\n                    pos-=positiveBeforeFirstNeg\n                    pos+=pos2\n                m=max(max(pos,pos2)+neg,m)\n                neg,pos,pos2=0,0,0\n            elif(i<0):\n                if(neg==0):\n                    positiveBeforeFirstNeg=pos\n                neg+=1\n                if(neg%2==0):\n                    pos+=pos2\n                    pos2=0\n            else:\n                if(neg%2!=0):\n                    pos2+=1\n                else:\n                    pos+=1\n        if(positiveBeforeFirstNeg<pos2 and neg>2):\n            pos-=positiveBeforeFirstNeg\n            pos+=pos2\n        if(neg>0 and neg%2!=0):\n            neg-=1\n        m=max(max(pos,pos2)+neg,m)     \n        return m", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # encouter 0 reset it as 0\n        # how many -1 in the left, if is even, update the  longest length O(n) cur_poistion - 0_position\n        \n        # [1,-2,-3,4] => [0, 1, 2, 2] => 4\n        # [0,1,-2,-3,-4] => [0, 0, 1, 2, 3] => 3\n        # [-1,-2,-3,0,1] => [1, 2, 3, 0, 0] => 2\n        # [-1,2] => [1, 1] => 1 (consider if itself > 0, 1)\n        # [1,2,3,5,-6,4,0,10] => [0, 0, 0, 0, 1, 1, 0, 1] => 4\n        # [0, 0 ,0 ,0] => [0, 0, 0, 0] => 0 (consider if itself == 0, 0)\n        \n        carry_len = 0\n        left_neg = 0\n        max_len = 0\n        str_ptr = -1\n        for idx, n in enumerate(nums):\n            if n < 0 :left_neg += 1 \n            carry_len += 1\n            if n == 0: \n                max_len = max(max_len, 0)\n                carry_len = 0\n                left_neg = 0\n            else:\n                max_len = max(max_len, 1 if n > 0 else 0, idx - str_ptr -1, carry_len if left_neg % 2 == 0 else 0)\n            if left_neg == 0: \n                str_ptr = idx\n\n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        start, curnegcnt, res, fnegpos, lnegpos = 0, 0, 0, 0, 0\n        flag = True\n        i, j = 0, len(nums)\n        while i < j:\n            if nums[i] == 0:\n                flag = True\n                i += 1\n                start = i\n                curnegcnt = 0\n                continue\n            if nums[i] < 0:\n                if flag:\n                    flag = False\n                    fnegpos = i\n                lnegpos = i\n                curnegcnt += 1\n            if curnegcnt == 0 or curnegcnt % 2 == 0:\n                res = max(res, (i - start) + 1)\n            else:\n\n                res = max(res, (lnegpos ) - start, i - (fnegpos ))\n            i += 1\n        return res\n                \n                \n    \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        #\u6bcf\u6b21maintain\uff0c\u5230\u4e4b\u524d\u4e3a\u6b62\uff0c\u6b63\u7684\u6709\u591a\u957f\uff0c\u8d1f\u7684\u6709\u591a\u957f\uff0c\u7136\u540emaintain max len\n        pos,neg = 0,0\n        asr = 0\n        for num in nums:\n            if num == 0:\n                pos,neg = 0,0\n            elif num > 0:\n                pos+=1\n                neg = neg + 1 if neg else 0\n            else:\n                n_pos = neg + 1 if neg else 0\n                n_neg = pos + 1 if pos else 1\n                pos,neg = n_pos,n_neg\n            asr = max(asr,pos)\n            #print(pos,neg)\n        return asr", "# 1567. Maximum Length of Subarray With Positive Product\n\ndef sgn (n):\n    if n > 0:\n        return +1\n    elif n < 0:\n        return -1\n    else:\n        return 0\n\ndef split_0 (arr):\n    arr_buffer = []\n    for elem in arr:\n        if elem != 0:\n            arr_buffer.append (elem)\n        else:\n            yield arr_buffer\n            arr_buffer = []\n    assert len (arr_buffer) == 0\n\ndef partial_products (arr):\n    prod = 1\n    yield prod\n    for elem in arr:\n        prod *= elem\n        yield prod\n\ndef get_subarr_max_len (arr):\n    # zero-free\n    first_index = {}\n    max_len = 0\n    for (i, prod) in enumerate (partial_products (arr)):\n        first_index.setdefault (prod, i)\n        max_len = max (max_len, i - first_index[prod])\n    return max_len\n\ndef get_max_len (arr):\n    arr = [sgn (x) for x in arr]\n    arr.append (0)\n\n    if len (arr) == 0:\n        return 0\n\n    return max (get_subarr_max_len (subarr) for subarr in split_0 (arr))\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        return get_max_len(nums)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        f = [[0, 0] for _ in range(len(nums) + 1)]\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                f[i+1] = [f[i][1] + 1 if f[i][1] > 0 else 0, f[i][0] + 1]\n            elif nums[i] > 0:\n                f[i+1] = [f[i][0] + 1, f[i][1] + 1 if f[i][1] > 0 else 0]\n        #print(f)\n        return max(x[0] for x in f)", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp_pos = [0] * (n+1)\n        dp_neg = [0] * (n+1)\n\n        result = 0\n        for i in range(1, n+1):\n            if nums[i-1] == 0:\n                dp_pos[i] = 0\n                dp_neg[i] = 0\n            elif nums[i-1] > 0:\n                dp_pos[i] = 1 + dp_pos[i-1]\n\n                if dp_neg[i-1] > 0:\n                    dp_neg[i] = 1 + dp_neg[i-1]\n                else:\n                    dp_neg[i] = 0\n            else:\n                if dp_neg[i-1] > 0:\n                    dp_pos[i] = 1 + dp_neg[i-1]\n                else:\n                    dp_pos[i] = 0\n\n                dp_neg[i] = 1 + dp_pos[i-1]\n\n            result = max(result, dp_pos[i])\n\n        return result\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        if not n:\n            return -1\n        pos = 0\n        neg = 0\n        answer = 0\n        for num in nums:\n            if num == 0:\n                answer = max(answer, pos)\n                pos = neg = 0\n                continue\n            if num > 0:\n                pos += 1\n                neg += 1 if neg else 0\n            else:\n                orig_pos = pos\n                pos = neg+1 if neg else 0\n                neg = (orig_pos + 1) if orig_pos else 1\n            answer = max(answer, pos)\n        return answer", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dct = {0:-1}\n        \n        count = 0\n        res = 0\n        for i,num in enumerate(nums):\n            if num <0: \n                count +=1\n                # print(num,count,i)\n                dct[count]=i\n                \n            elif num == 0:\n                dct = {0:i}\n                count = 0\n            if count %2 == 0:\n                res = max(res,i-dct[0])\n                \n            else:\n                t1 = i-dct[1]\n                t2= 0\n                if num < 0:\n                    t2 = i-1-dct[0]\n                res = max(res,max(t1,t2))\n            # print(dct,res)\n        return res\n            \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if nums[-1] != 0:\n            nums.append(0)\n        n = len(nums)\n        first_0 = -1\n        last_0 = -1\n        cnt_neg = 0\n        first_neg = -1\n        last_neg = -1\n        res = 0\n        # print(nums)\n        for i, e in enumerate(nums):\n            if e < 0:\n                cnt_neg += 1\n                if first_neg == -1:\n                    first_neg = i\n                last_neg = i\n            elif e == 0:\n                # print(cnt_neg)\n                last_0 = i\n                if cnt_neg % 2 == 0:\n                    res = max(res, last_0-first_0-1)\n                else:\n                    res = max(res, last_neg-first_0-1, last_0-first_neg-1)\n                    # print((first_0, last_0, first_neg, last_neg, res))\n                cnt_neg = 0\n                first_0 = last_0\n                first_neg = -1\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        a = 0\n        p = 0\n        n = 0\n        r = -1\n\n        for x in nums:\n            p, n, r = (\n                (x < 0) * p + (x > 0) * (p + 1),\n                (x < 0) * (n + 1) + (x > 0) * n,\n                (x < 0) * (r < 0) * p + (x < 0) * (r >= 0) * r + (x > 0) * r - (x == 0)\n            )\n            \n            a = max(a, p + n - (n % 2) * (r + 1))\n                   \n        return a", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # get the next zero or end\n        # get the last idx of negative before zero and end\n        # get how many negative numbers\n        \n        next_zero_or_end=[0]*(len(nums)+1)\n        next_idx=len(nums)\n        last_negative=[0]*(len(nums)+1)\n        negative_idx=None\n        state=0\n        for i in range(len(nums)-1,-1,-1):\n            num=nums[i]\n            if num==0:\n                next_idx=i\n                state=0\n            next_zero_or_end[i]=next_idx\n            if state==0 and num<0:\n                negative_idx=i\n                state=1\n            last_negative[i]=negative_idx\n                \n        ne_nums=[0] * (len(nums)+1)\n        for i,num in enumerate(nums):\n            ne_nums[i]=ne_nums[i-1]+(1 if num<0 else 0)\n        res=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                continue\n            j=next_zero_or_end[i]-1\n            if (ne_nums[j]-ne_nums[i-1])%2==0:\n                res=max(res,(j-i+1))\n            else:\n                j=last_negative[i]-1\n                res=max(res,(j-i+1))\n        return res", "\nclass Node:\n    def __init__(self, size):\n        self.size = size\n        self.left = None\n        self.right = None\n        \n\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        nodes = []\n        roots = []\n        \n        curr_size = 0\n        prev = None\n        \n        for i in range(len(nums)):\n            if nums[i] > 0:\n                curr_size += 1\n            else:\n                node = Node(curr_size)\n                nodes.append(node)\n                if prev:\n                    prev.right = node\n                    node.left = prev\n                else:\n                    roots.append(node)\n                if nums[i] != 0:\n                    prev = node\n                else:\n                    prev = None\n                curr_size = 0\n                    \n        node = Node(curr_size)\n        if prev:\n            prev.right = node\n            node.left = prev\n        else:\n            roots.append(node)\n                \n        # t_node = roots[0]\n        # while t_node:\n        #     print(t_node.size)\n        #     t_node = t_node.right\n        \n        longest = 0\n        for node in roots:\n            first_count = node.size\n            second_count = 0 if not node.right else node.right.size\n            \n            curr_node = node.right.right if node.right else None\n            \n            ind = 0\n            \n            while curr_node:\n                if ind == 0:\n                    first_count += curr_node.size + curr_node.left.size + 2\n                    ind = 1\n                else:\n                    second_count += curr_node.size + curr_node.left.size + 2\n                    ind = 0\n                curr_node = curr_node.right\n                \n            # print(first_count)\n            # print(second_count)\n            longest = max(longest, first_count, second_count)\n            \n        return longest\n                    \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos = [0 for _ in range(len(nums))] # pos[i] is number of consecutive numbers with pos product up to i\n        neg = [0 for _ in range(len(nums))] # neg[i] is number of consecutive numbers with neg product up to i\n        if nums[0] > 0 :\n            pos[0] = 1\n        elif nums[0] < 0:\n            neg[0] = 1\n            \n        out = pos[0]\n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1] \n                neg[i] = 1 + neg[i - 1] if neg[i - 1] else 0\n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] else 0\n                neg[i] = 1 + pos[i - 1]\n            out = max(out, pos[i])\n        \n        return out", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def getMaxLenNonzero(arr):\n            neg = []\n            for i, num in enumerate(arr):\n                if num < 0:\n                    neg.append(i)\n            if len(neg) % 2 == 0:\n                return len(arr)\n            if len(neg) == 1:\n                return max(neg[0], len(arr) - neg[-1] - 1)\n            return max(neg[-1], len(arr) - neg[0] - 1)\n    \n        currArr = []\n        ans = 0\n        for num in nums:\n            if num != 0:\n                currArr.append(num)\n            else:\n                ans = max(ans, getMaxLenNonzero(currArr))\n                currArr = []\n        if currArr:\n            ans = max(ans, getMaxLenNonzero(currArr))\n\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [0] * len(nums)\n        for i in range(len(dp)):\n            dp[i] = [0,0]\n        \n        ans = 0\n        for i, v in enumerate(nums):\n            if v > 0:\n                dp[i][0] = 1 + dp[i-1][0]\n                if dp[i-1][1]: dp[i][1] = 1 + dp[i-1][1]\n            if v < 0:\n                if dp[i-1][1]:\n                    dp[i][0] = 1 + dp[i-1][1]\n                dp[i][1] = 1 + dp[i-1][0]\n            ans = max(ans, dp[i][0])\n        return ans\n                    \n                \n                \n                \n            \n                \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ans = pos = neg = 0\n        for x in nums: \n            if x > 0: pos, neg = 1 + pos, 1 + neg if neg else 0\n            elif x < 0: pos, neg = 1 + neg if neg else 0, 1 + pos\n            else: pos = neg = 0 # reset \n            ans = max(ans, pos)\n        return ans\n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        A = nums\n        n = len(A)\n        dp = [[0,0] for i in range(n+1)]\n        \n        max_len = 0\n        for i in range(1,n+1):\n            if A[i-1] > 0:\n                dp[i][0] = dp[i-1][0]+1\n                dp[i][1] = dp[i-1][1]+1 if dp[i-1][1] != 0 else 0\n            elif A[i-1] < 0:\n                dp[i][0] = dp[i-1][1]+1 if dp[i-1][1] != 0 else 0\n                dp[i][1] = dp[i-1][0]+1\n            else:\n                dp[i][0] = 0\n                dp[i][1] = 0\n            max_len = max(max_len, dp[i][0])\n        # print(dp)\n        \n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        ret=0\n        total=0\n        acc=1\n        start=-1\n        first=-1\n        last=0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                if acc>0:\n                    ret=max(total,ret)\n                else:\n                    ret=max(ret,first-1,total-first,last-1,total-last)\n                start=i\n                acc=1\n                total=0\n                first=-1\n                last=0\n            else:\n                total+=1\n                acc=acc*(1 if nums[i]>0 else -1)\n                if nums[i]<0:\n                    if first==-1:\n                        first=i-start\n                    last=0\n                last+=1\n        if acc>0:\n            ret=max(total,ret)\n        else:\n            ret=max(ret,first-1,total-first,last-1,total-last)\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        listt = []\n        a = -1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                listt.append(nums[a + 1:i])\n                a = i\n        listt.append(nums[a + 1:])\n        while [] in listt:\n            listt.remove([])\n        if listt==[]:\n            return 0\n        recordlist = {}\n        for i in range(len(listt)):\n            firstneg=-1\n            begneg=-1\n            recordlist[i]=0\n            for m in range(len(listt[i])):\n                if listt[i][m]<0 and firstneg==-1:\n                    firstneg = m\n                    if begneg==-1:\n                        begneg=m\n                    continue\n                if listt[i][m]<0 and firstneg!=-1:\n                    firstneg=-1\n            if firstneg==-1:\n                recordlist[i]=len(listt[i])\n            else:\n                recordlist[i]=max([firstneg,len(listt[i])-firstneg-1,begneg,len(listt[i])-begneg-1])\n        m=[]\n        for i in list(recordlist.values()):\n            m.append(i)\n        return max(m)\n", "class Solution:\n    #Any subarray containing a zero must be broken into seperate subarrays either side of the zero\n    #Any subarr with an even number of negatives can be counted in its entirety\n    #For a subarr with an odd number of negatives, the largest subarray excluding either the left or rightmost negative number can be taken instead\n\n    def getMaxLen(self, nums: List[int]) -> int:\n        #Simplify array to +-1\n        for i in nums:\n            if i > 0:\n                i = 1\n            elif i < 0:\n                i = -1\n                \n        arrays = []\n        end = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                arrays.append(nums[end:i])\n                end = i + 1\n        arrays.append(nums[end:])\n        \n        #print(arrays)\n        maximum = 0\n        for arr in arrays:\n            maxi = 0\n            neg = 0\n            first = -1\n            for i in range(len(arr)):\n                if arr[i] < 0:\n                    neg += 1\n                    if first == -1:\n                        first = i + 1\n                    last = i\n            if neg % 2 == 0:\n                maxi = len(arr)\n            else:\n                #Length of sub a (missing first)\n                subA = len(arr) - first    \n                #Length of sub b (missing last)\n                subB = last\n                maxi = max(subA, subB)\n            #print(arr, maxi)\n            maximum = max(maximum, maxi)\n            \n        \n        return maximum\n                \n            \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        def helper(nums):\n            result = 0\n\n            positiveSoFar = 0\n            negativeSoFar = 0\n\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    positiveSoFar = 0\n                    negativeSoFar = 0\n                elif nums[i] > 0 :\n                    positiveSoFar += 1\n                    if negativeSoFar > 0:\n                        negativeSoFar += 1\n\n                elif nums[i] < 0:\n                    if negativeSoFar > 0:\n                        positiveSoFar = max(negativeSoFar, positiveSoFar) +1\n                        negativeSoFar = 0\n                    else:\n                        negativeSoFar = positiveSoFar + 1\n                        positiveSoFar = 0\n\n                result = max(result, positiveSoFar)\n            return result\n        \n        # scan from left and scan from right\n        return max(helper(nums), helper(nums[::-1]))\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = []\n        for num in nums:\n            if num == 0:\n                dp.append(0)\n            elif num > 0:\n                dp.append(1)\n            else:\n                dp.append(-1)\n        for i in range(1, len(dp)):\n            if dp[i - 1] == 0:\n                continue\n            else:\n                dp[i] *= dp[i - 1]\n        print(dp)\n        dic = {}\n        res = 0\n        zero = -1\n        for i,num in enumerate(dp):\n            if num > 0:\n                if 1 not in dic:\n                    res = max(res,i  - zero)\n                    dic[1] = i\n                else:\n                    res = max(res, i - dic[1] + 1, i - zero)\n            elif num == 0:\n                dic = {}\n                zero = i\n            else:\n                if -1 not in dic:\n                    dic[-1] = i\n                else:\n                    res = max(res, i  - dic[-1])\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos, neg = 0, 0\n        if nums[0]>0: pos = 1\n        if nums[0]<0: neg = 1\n        ans = pos\n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                pos, neg = pos+1, neg+1 if neg else 0\n            elif nums[i] < 0:\n                pos, neg = neg+1 if neg else 0, pos+1\n            else:\n                pos, neg = 0, 0\n            ans = max(ans,pos)\n            \n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        def helper(nums):\n            result = 1 if nums[0] > 0 else 0\n\n            positiveSoFar = 1 if nums[0] > 0 else 0\n            negativeSoFar = 1 if nums[0] < 0 else 0\n\n\n            for i in range(1, len(nums)):\n                if nums[i] == 0:\n                    positiveSoFar = 0\n                    negativeSoFar = 0\n                elif nums[i] > 0 :\n                    positiveSoFar += 1\n                    if negativeSoFar > 0:\n                        negativeSoFar += 1\n\n                elif nums[i] < 0:\n                    if negativeSoFar > 0:\n                        positiveSoFar = max(negativeSoFar, positiveSoFar) +1\n                        negativeSoFar = 0\n                    else:\n                        negativeSoFar = positiveSoFar + 1\n                        positiveSoFar = 0\n\n                result = max(result, positiveSoFar)\n            return result\n        \n        \n        return max(helper(nums), helper(nums[::-1]))\n        \n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        numPos, numNeg, res = 0, 0, 0\n        \n        for i in range(len(nums)):\n            if nums[i] > 0:\n                numPos += 1\n                if numNeg > 0: numNeg += 1\n            elif nums[i] < 0:\n                numPosTmp, numNegTmp = numPos, numNeg\n                if numPosTmp > 0:\n                    numNeg = numPosTmp + 1\n                else:\n                    numNeg = 1\n                if numNegTmp > 0:\n                    numPos = numNegTmp + 1\n                else:\n                    numPos = 0\n            else:\n                numNeg = 0\n                numPos = 0\n            res = max(res, numPos)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        splittedArrays = []\n        \n        currentArray = []\n        negCount = 0\n        for num in nums:\n            if num == 0:\n                if len(currentArray) > 0:\n                    splittedArrays.append((currentArray, negCount))\n                currentArray = []\n                negCount = 0\n            else:\n                currentArray.append(num)\n                negCount += 1 if num < 0 else 0\n        \n        if len(currentArray) > 0:\n            splittedArrays.append((currentArray, negCount))\n        \n        if not splittedArrays:\n            return 0\n        \n        maxLength = 0\n        for splittedArray, negCount in splittedArrays:\n            if negCount % 2 == 0:\n                maxLength = max(maxLength, len(splittedArray))\n            else:\n                removedNums = 0\n                i = 0\n                while splittedArray[i] > 0:\n                    removedNums += 1\n                    i += 1\n                maxLength = max(maxLength, len(splittedArray) - removedNums - 1)\n                \n                removedNums = 0\n                i = len(splittedArray) - 1\n                while splittedArray[i] > 0:\n                    removedNums += 1\n                    i -= 1\n                maxLength = max(maxLength, len(splittedArray) - removedNums - 1)\n        \n        return maxLength", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos = [0] * n\n        neg = [0] * n\n        \n        if nums[0] < 0:\n            neg[0] = 1\n        elif nums[0] > 0:\n            pos[0] = 1\n            \n        ans = pos[0]\n        for i in range(1,n):\n            if nums[i] > 0:\n                pos[i] = 1 + pos[i - 1]\n                neg[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                \n            elif nums[i] < 0:\n                pos[i] = 1 + neg[i - 1] if neg[i - 1] > 0 else 0\n                neg[i] = 1 + pos[i - 1]\n            ans = max(ans,pos[i])\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        l = -1\n        neg_num = 0\n        result = 0\n        for i in range(n):\n            if (nums[i] == 0):\n                while (neg_num % 2):\n                    if (nums[l + 1] < 0):\n                        neg_num -= 1\n                    l += 1\n                # print(i, l)\n                result = max(result, i - l - 1)\n                l = i\n                count = 0\n            elif (nums[i] < 0):\n                neg_num += 1\n            if (neg_num % 2 == 0):\n                result = max(result, i - l)\n        while (neg_num % 2) and (l < n - 1):\n            if (nums[l + 1] < 0):\n                neg_num -= 1\n            l += 1\n        # print(l)\n        result = max(result, n - 1 - l)\n        return result", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        size = len(nums)\n        if size == 1:\n            return 0 if nums[0] < 0 else 1\n        \n        \n        start = 0\n        end = 0\n        \n        longest = 0\n        \n        while end < size:\n        \n            numNeg = 0\n            leftNeg = -1\n            rightNeg = -1\n        \n            while end < size and not nums[end] == 0:\n                if nums[end] < 0:\n                    \n                    numNeg += 1\n                    rightNeg = end\n                    \n                    if leftNeg == -1:\n                        leftNeg = end\n                        \n                end += 1\n                \n            if numNeg % 2 == 0:\n                longest = max(longest, end - start)\n            else:\n                longest = max(longest, end - rightNeg - 1, rightNeg - start, end - leftNeg - 1, leftNeg - start)\n                \n                \n            end += 1\n            start = end\n            \n        return longest", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        pos, neg = -1, n\n        c = 1\n        ret = 0\n        for i, j in enumerate(nums):\n            if j == 0:\n                pos, neg = i, n\n                c = 1\n                continue\n            if j > 0:\n                pass\n            else:\n                c *= -1\n            if c == 1:\n                ret = max(ret, i - pos)\n            else:\n                ret = max(ret, i - neg)\n                neg = min(neg, i)\n        return ret", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0]*2 for _ in range(len(nums))]\n        dp[0][0] = nums[0] > 0\n        dp[0][1] = nums[0] < 0\n        ret = dp[0][0]\n        for i in range(1,len(nums)):\n            if nums[i] == 0:\n                continue\n            if nums[i] > 0:\n                dp[i][0] = dp[i-1][0] + 1\n                dp[i][1] = 0 if not dp[i-1][1] else dp[i-1][1] + 1\n            else:\n                dp[i][0] = 0 if not dp[i-1][1] else dp[i-1][1] + 1\n                dp[i][1] = dp[i-1][0] + 1\n            ret = max(ret,dp[i][0])\n        return int(ret)", "\n\n# dp[i][0] : max length of subarray ending with index i With positive product   \n# dp[i][1] : max length of subarray ending with index i With negative product \n\n\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0,0] for _ in range(len(nums))]\n        res = 0\n        if nums[0] > 0:\n            dp[0][0] = 1\n        elif nums[0] < 0:\n            dp[0][1] = 1\n        #print(dp)\n        res = max(res, dp[0][0])\n        for idx in range(1, len(nums)):\n            if nums[idx] == 0:\n                dp[idx][0], dp[idx][1] = 0, 0\n            elif nums[idx] > 0:\n                dp[idx][0] = dp[idx-1][0] + 1\n                if dp[idx-1][1] > 0:\n                    dp[idx][1] = dp[idx-1][1] + 1\n                res = max(dp[idx][0], res)\n            \n            elif nums[idx] < 0:\n                dp[idx][1] = dp[idx-1][0]+1\n                if dp[idx-1][1] > 0:\n                    dp[idx][0] = dp[idx-1][1]+1\n                res = max(res, dp[idx][0])\n                \n        #print(dp)\n        return res\n\n\n\n'''\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        prevpos, prevneg = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n                prevpos, prevneg = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    print(num, res)\n                else:\n                    res = max(res, diction[\\\"pos\\\"], prevpos)\n        \n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                print(\\\"neg\\\", num, diction[\\\"neg\\\"], diction[\\\"pos\\\"], prevpos)\n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"])\n                    prevpos += diction[\\\"pos\\\"]\n                    diction[\\\"pos\\\"] = 0\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]+prevpos)\n                    prevpos = diction[\\\"neg\\\"] + diction[\\\"pos\\\"] + prevpos\n                    diction[\\\"neg\\\"] = 0\n                    diction[\\\"pos\\\"] = 0\n                    \n        print(res)\n        return res\n'''\n\n        \n'''\n        diction = {}\n        diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n        res = 0\n        for num in nums:\n            if num == 0:\n                diction[\\\"pos\\\"], diction[\\\"neg\\\"] = 0, 0\n            elif num > 0:\n                diction[\\\"pos\\\"] += 1\n                if diction[\\\"neg\\\"] % 2 == 0:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n            elif num < 0:\n                diction[\\\"neg\\\"] += 1\n                \n                if diction[\\\"neg\\\"] % 2 == 1:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"]-1)\n                else:\n                    res = max(res, diction[\\\"pos\\\"]+diction[\\\"neg\\\"])\n                \n        print(res)\n        \n        return res\n        \n\n'''\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # \\\"pos\\\", \\\"neg\\\" represent longest consecutive numbers ending with nums[i] forming a positive/negative product.\n\n        n = len(nums)\n        pos, neg = 0, 0\n        if nums[0] > 0: pos = 1\n        if nums[0] < 0: neg = 1\n        ans = pos\n        for i in range(1, n):\n            if nums[i] > 0:\n                pos = 1 + pos\n                neg = 1 + neg if neg > 0 else 0\n            elif nums[i] < 0:\n                pre_pos, pre_neg = pos, neg\n                pos = 1 + pre_neg if pre_neg > 0 else 0\n                neg = 1 + pre_pos\n            else:\n                pos, neg = 0, 0\n            ans = max(ans, pos)\n        return ans\n    \n        # nums.append(0)\n        # start = -1\n        # i = 0\n        # firstn = -1\n        # maxl = 0\n        # nneg = 0\n        # while i<len(nums):\n        #     if nums[i]<0:\n        #         nneg += 1\n        #         if firstn<0: firstn = i\n        #         lastn = i\n        #     elif nums[i] == 0:\n        #         if nneg%2 == 0:\n        #             maxl = max(maxl,i-start-1)\n        #         else:\n        #             maxl = max([maxl,lastn-start-1,i-firstn-1])\n        #         start = i\n        #         nneg = 0\n        #         firstn = -1\n        #     i += 1\n        # return maxl\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        # dp[i]: max length of pos subarray ends at i\n        l = len(nums)\n        pdp = [0] * l\n        ndp = [0] * l\n        pdp[0] = 1 if nums[0] > 0 else 0\n        ndp[0] = 1 if nums[0] < 0 else 0\n        b = pdp[0]\n        for i in range(1, l):\n            n = nums[i]\n            if n > 0:\n                pdp[i] = max(pdp[i - 1] + 1, 1)\n                ndp[i] = ndp[i - 1] + 1 if ndp[i - 1] != 0 else 0\n            elif n < 0:\n                ndp[i] = max(pdp[i - 1] + 1, 1)\n                pdp[i] = ndp[i - 1] + 1 if ndp[i - 1] != 0 else 0\n            else:\n                pdp[i] = 0\n                ndp[i] = 0\n            b = max(b, pdp[i])\n            \n        return b\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        dp = [[0] * 2 for _ in range(len(nums))]\n        if nums[0] < 0:\n            dp[0][1] = 1\n        if nums[0] > 0:\n            dp[0][0] = 1\n            \n        res = dp[0][0]\n            \n        for i, num in enumerate(nums):\n            if i and num < 0:\n                dp[i][1] = dp[i-1][0] + 1\n                if dp[i-1][1]:\n                    dp[i][0] = dp[i-1][1] + 1\n            if i and num > 0:\n                dp[i][0] = dp[i-1][0] + 1\n                if dp[i-1][1]:\n                    dp[i][1] = dp[i-1][1] + 1\n            res = max(res, dp[i][0])\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        cur_pos_product_len = 1 if nums[0] > 0 else 0\n        cur_neg_product_len = 1 if nums[0] < 0 else 0\n        max_len = cur_pos_product_len        \n        \n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                cur_pos_product_len += 1\n                cur_neg_product_len = cur_neg_product_len + 1 if cur_neg_product_len > 0 else 0\n            elif nums[i] < 0:\n                temp = cur_pos_product_len\n                cur_pos_product_len = cur_neg_product_len + 1 if cur_neg_product_len > 0 else 0\n                cur_neg_product_len = temp + 1\n            else:\n                cur_pos_product_len = 0\n                cur_neg_product_len = 0\n            max_len = max(max_len, cur_pos_product_len)\n        return max_len", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        arrs=[[]]\n        for i in nums:\n            if i:\n                arrs[-1].append(i)\n            else:\n                arrs.append([])\n        ans=0\n        for arr in arrs:\n            if not len(arr):\n                continue\n            negs=0\n            for i in arr:\n                if i<0:\n                    negs+=1\n            if negs%2:\n                p1=0\n                while arr[p1]>0:\n                    p1+=1\n                p2=len(arr)-1\n                while arr[p2]>0:\n                    p2-=1\n                ans=max(len(arr)-p1-1,p2,ans)\n            else:\n                ans=max(ans,len(arr))\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        pos_length = 0\n        neg_length = 0\n        max_length = 0\n        for num in nums:\n            if num > 0:\n                pos_length += 1\n                if neg_length:\n                    neg_length += 1\n            elif num < 0:\n                tmp = pos_length\n                if neg_length:\n                    pos_length = neg_length + 1\n                else:\n                    pos_length = 0\n                neg_length = tmp + 1\n            else:\n                pos_length = 0\n                neg_length = 0\n            max_length = max(max_length, pos_length)\n#           print(f'num, max_length = {num}, {max_length}')\n        max_length = max(max_length, pos_length)\n        return max_length\n", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0, 0] for _ in range(n)]\n        for i in range(n):\n            if nums[i] == 0: dp[i] = [0, 0]\n            elif i == 0 or nums[i - 1] == 0:\n                if nums[i] > 0: dp[i][0] = 1\n                else: dp[i][1] = 1\n            elif nums[i] > 0:\n                dp[i][0] = dp[i - 1][0] + 1\n                if dp[i - 1][1] > 0: dp[i][1] = dp[i - 1][1] + 1\n            else:\n                if dp[i - 1][1] > 0: dp[i][0] = dp[i - 1][1] + 1\n                dp[i][1] = dp[i - 1][0] + 1\n        return max(dp[i][0] for i in range(n))", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        nums.append(0)\n        left = 0\n        n = len(nums)\n        first_neg = n\n        last_neg = 0\n        ct_neg = 0\n        ans = 0\n        for right in range(n):\n            if nums[right]<0:\n                first_neg = min(first_neg, right)\n                last_neg = max(last_neg, right)\n                ct_neg += 1\n            elif nums[right]==0:\n                if left < right:\n                    if ct_neg & 1 == 0:\n                        ans = max(ans, right-left)\n                    else:\n                        print(left, right, first_neg, last_neg)\n                        ans = max(ans, right-first_neg-1)\n                        ans = max(ans, last_neg-left)\n                left = right+1\n                first_neg = n\n                last_neg = 0\n                ct_neg = 0\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        res = 0\n        for is_pos, group in itertools.groupby(nums, key = bool):\n            if is_pos:\n                subgroup = list(group)\n                num_negs = 0\n                # if the num negs is odd, the answer is either\n                # the length without the first negative\n                # or the length without the last negative\n                first = last = None \n                for i, n in enumerate(subgroup):\n                    if n < 0:\n                        num_negs += 1\n                        if first is None:\n                            first = i\n                        last = i\n                if num_negs % 2 == 0:\n                    res = max(res, len(subgroup))\n                else:\n                    res = max(res, first, len(subgroup) - 1 - first)\n                    res = max(res, last, len(subgroup) - 1 - last)\n        return res", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        n = len(nums)\n        neg = [0] * n\n        pos = [0] * n \n\n        if nums[0] < 0:\n            neg[0] = 1 \n        elif nums[0] > 0:\n            pos[0] = 1\n        # \u4ee5i\u4e3a\u7ed3\u5c3e\u7684\u65f6\u5019 \u4e58\u79ef\u662f\u8d1f\u6570\u7684\u65f6\u5019\u7684\u957f\u5ea6 neg[i], or is positive \n        for i in range(1, n):\n            val = nums[i]\n            if val > 0:\n                pos[i] = pos[i-1] + 1\n                neg[i] = (neg[i-1] + 1) if neg[i-1] != 0 else 0 \n            elif val < 0:\n                pos[i] = (neg[i-1] + 1) if neg[i-1] != 0 else 0\n                neg[i] = pos[i-1] + 1\n            else:\n                pos[i] = 0\n                neg[i] = 0\n            print((pos[i], neg[i]))\n        return max(pos)\n", "class Solution:\n    \n    # space optimized\n    def getMaxLen(self, nums: List[int]) -> int:\n        \n        ans = 0\n        neg_pos = None\n        neg_count = 0\n        left = -1\n        for i, n in enumerate(nums):\n            if n==0:\n                neg_pos = None\n                neg_count = 0\n                left = i\n                continue\n            elif n>0:\n                if neg_count%2==0:\n                    ans = max(ans, i-left)\n                else:\n                    ans = max(ans, i-neg_pos)\n            elif n<0:\n                neg_count += 1\n                if neg_pos is None:\n                    neg_pos=i\n                if neg_count%2==0:\n                    ans = max(ans, i-left)\n                else:\n                    ans = max(ans, i-neg_pos)\n\n        return ans\n    \n    # original O(n) space\n    def getMaxLen1(self, nums: List[int]) -> int:\n        \n        ans = 0\n        dq = []\n        left = -1\n        for i, n in enumerate(nums):\n            if n==0:\n                dq.clear()\n                left = i\n                continue\n            elif n>0:\n                if len(dq)%2==0:\n                    ans = max(ans, i-left)\n                else:\n                    ans = max(ans, i-dq[0])\n            elif n<0:\n                dq.append(i)\n                if len(dq)%2==0:\n                    ans = max(ans, i-left)\n                else:\n                    ans = max(ans, i-dq[0])\n\n        return ans", "class Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        f_pos = 0\n        f_neg = 0\n        max_pos = 0\n        for i in range(len(nums)):\n            if nums[i]==0:\n                f_pos,f_neg = 0,0\n            elif nums[i]>0:\n                f_pos +=1\n                if f_neg>0:\n                    f_neg+=1\n            else:\n                tmp = f_pos\n                if f_neg>0:\n                    f_pos = f_neg+1\n                else:\n                    f_pos = 0\n                f_neg = tmp+1\n            print((i, f_pos,f_neg))\n            max_pos = max(max_pos ,f_pos)\n        return max_pos\n            \n", "from typing import List\nclass Solution:\n    def getMaxLen(self, nums: List[int]) -> int:\n        def aux(i,j):\n            negs = 0\n            for v in nums[i:j+1]:\n                if v<0:\n                    negs+=1\n            if negs%2 == 0:\n                return j-i+1\n            l=i\n            while nums[l]>0:\n                l+=1\n            l = j-l\n            r=j\n            while nums[r]>0:\n                r-=1\n            r = r-i\n            return max(l,r)\n\n        start = 0\n        maxm = 0\n        for end in range(len(nums)):\n            if nums[end] == 0:\n                maxm = max(maxm,aux(start, end-1))\n                start = end+1\n            elif nums[end]>0:\n                maxm = max(maxm, 1)\n        if start!=len(nums)-1:\n            maxm = max(maxm,aux(start, len(nums)-1))\n        return maxm\n\n", "import bisect\nclass Solution:\n    ans = [0 for i in range(100001)]\n    def getMaxLen(self, nums: List[int]) -> int:\n        def solve(arr):\n            s1, s2 = set(), set()\n            s1.add(-1)\n            ret = 0\n            cnt = 0\n            n = len(arr)\n            for i, c in enumerate(arr):\n                cnt += 0 if c > 0 else 1\n                if cnt % 2 == 0:\n                    s1.add(i)\n                else:\n                    s2.add(i)\n            if s1:\n                ret = max(s1) - min(s1)\n            if s2:\n                ret = max(max(s2) - min(s2), ret)\n            # print(s1, s2, ret)\n            return ret\n        ans = 0\n        l = 0\n        for i, c in enumerate(nums):\n            if c == 0:\n                ans = max(ans, solve(nums[l:i]))\n                l = i + 1\n        ans = max(ans, solve(nums[l:]))\n        return ans"]
["import bisect\ndef inpl(): return [int(i) for i in input().split()]\n\nX = int(input())\nK = int(input())\nr = [0] + inpl()\nstu = [()]*(K+1)\nstu[0] = (X, 0, 0)\nfor i, v in enumerate(r[1:], 1):\n    s, t, u = stu[i-1]\n    if i%2:\n        rs = r[i-1] - r[i]\n        ap = - rs - t\n        if ap >= s:\n            stu[i] = 0, 0, 0\n        elif ap >= u:\n            stu[i] = s, t+rs, ap\n        else:\n            stu[i] = s, t+rs, u\n    else:\n        rs = r[i] - r[i-1]\n        ap = X - rs - t\n        if ap >= s:\n            stu[i] = s, t+rs, u\n        elif ap >= u:\n            stu[i] = ap, t+rs, u\n        else:\n            stu[i] = X, 0, X\nQ = int(input())\nfor _ in range(Q):\n    ti, a = inpl()\n    x = bisect.bisect_right(r, ti)\n    ti -= r[x-1]\n    s, t, u = stu[x-1]\n    if a >= s:\n        R = s + t\n    elif a >= u:\n        R = a + t\n    else:\n        R = u + t\n    if x % 2:\n        print(max(0, R - ti))\n    else:\n        print(min(X, R + ti))", "from bisect import bisect\nX=int(input())\nK=int(input())\nrs=[0]\nfor r in input().split():\n  rs.append(int(r))\nA=[[(0,0),(X,X)]]\nmin_sup=0\nmax_inf=X\npre_r=0\nfor i,r in enumerate(rs[1:]):\n  d=r-pre_r\n  pre_r=r\n  m,M=A[-1][0][0],A[-1][1][0]\n  if i%2==0:\n    if m-d>=0:\n      new_m=m-d\n    else:\n      new_m=0\n      min_sup=min_sup+d-m\n    if M-d>0:\n      new_M=M-d\n    else:\n      new_M=0\n      max_inf=0\n  else:\n    if M+d<=X:\n      new_M=M+d\n    else:\n      new_M=X\n      max_inf=max_inf-(d-(X-M))\n    if m+d<X:\n      new_m=m+d\n    else:\n      new_m=X\n      min_sup=X\n  if new_m==new_M:\n    min_sup=X\n    max_inf=0             \n  A.append([(new_m,min_sup),(new_M,max_inf)])\nQ=int(input())\nfor q in range(Q):\n  t,a=list(map(int,input().split()))\n  r_num=bisect(rs,t)-1\n  m,min_sup=A[r_num][0]\n  M,max_inf=A[r_num][1]\n  r=rs[r_num]\n  if r_num%2==0:\n    if a<=min_sup:\n      print((max(m-(t-r),0)))\n    elif min_sup<a<max_inf:\n      print((max(m+(a-min_sup)-(t-r),0)))\n    else:\n      print((max(M-(t-r),0)))\n  else:\n    if a<=min_sup:\n      print((min(m+(t-r),X)))\n    elif min_sup<a<max_inf:\n      print((min(m+(a-min_sup)+(t-r),X)))\n    else:\n      print((min(M+(t-r),X)))\n", "X = int(input())\nK = int(input())\nr_lst = [int(_) for _ in input().split()]\nQ = int(input())\nt_lst, a_lst = [], []\nfor i in range(Q):\n    buf = input().split()\n    t_lst.append(int(buf[0]))\n    a_lst.append(int(buf[1]))\n    \npos_lst = []\nfor i, r in enumerate(r_lst):\n    direc = \"+\" if i%2==0 else \"-\"\n    pos_lst.append((r, direc))\nfor i, t in enumerate(t_lst):\n    pos_lst.append((t, i))\npos_lst = sorted(pos_lst, key=lambda tup: tup[0])\n\n\nleft, right  = 0, X\nval = [0, 0, X] \n\ndirec = \"-\"\nprv = 0\nfor pos in pos_lst:\n#    print(left, right)\n#    print(val)\n#    print(pos)\n#    print()\n    \n    elapsed = pos[0] - prv\n    prv = pos[0]\n    \n    if direc == \"+\":\n        val[0] = min(X, val[0] + elapsed)\n        val[1] += elapsed\n        val[2] = min(X, val[2] + elapsed)\n        right = min(right, X - val[1])\n    else:\n        val[0] = max(0, val[0] - elapsed)\n        val[1] -= elapsed\n        val[2] = max(0, val[2] - elapsed)     \n        left = max(left, -(val[1]))\n        \n    if pos[1] == \"+\" or pos[1] == \"-\":\n        direc = pos[1]\n    else: #is query\n        a = a_lst[pos[1]]\n        \n        if a <= left:\n            print(val[0])\n        elif a >= right:\n            print(val[2])\n        else:\n            print( a + val[1])", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    x = I()\n    k = I()\n    r = LI()\n    q = I()\n    t = [LI() for _ in range(q)]\n    a = [[0,0,0,x,0,0]]\n    d = 0\n    for i in range(k):\n        c = a[-1][:]\n        rr = r[i] - d\n        d = r[i]\n        if i % 2 == 0:\n            c[1] -= rr\n            c[3] -= rr\n            c[4] -= rr\n            if c[0] > c[1]:\n                c[0] = c[1]\n        else:\n            c[1] += rr\n            c[3] += rr\n            c[4] += rr\n            if c[2] < c[1]:\n                c[2] = c[1]\n        if c[3] > x:\n            c[3] = x\n        if c[3] < 0:\n            c[3] = 0\n        if c[4] > x:\n            c[4] = x\n        if c[4] < 0:\n            c[4] = 0\n\n        c[5] = r[i]\n\n        a.append(c)\n    def bs(i):\n        ma = k\n        mi = 0\n        mm = 0\n        while ma > mi and (ma+mi) // 2 != mm:\n            mm = (ma+mi) // 2\n            if a[mm][5] < i:\n                mi = mm\n            else:\n                ma = mm - 1\n        if a[mm][5] > i:\n            return mm-1\n        if mm == k:\n            return k\n        if a[mm+1][5] <= i:\n            return mm+1\n        return mm\n\n    #print(a)\n    rr = []\n    for c,d in t:\n        ti = bs(c)\n        ai = a[ti]\n        e = x-d\n        #print(c,d,e,ti,ai)\n        if d + ai[0] <= 0:\n            tt = ai[4]\n        elif e - ai[2] <= 0:\n            tt = ai[3]\n        else:\n            tt = d + ai[1]\n        #print('tt',tt)\n        if ti % 2 == 0:\n            tt -= c - ai[5]\n        else:\n            tt += c - ai[5]\n        #print('tt2',tt)\n        if tt < 0:\n            tt = 0\n        elif tt > x:\n            tt = x\n        rr.append(tt)\n\n    return '\\n'.join(map(str,rr))\n\n\nprint((main()))\n\n", "def main():\n    import sys\n    from operator import itemgetter\n    input = sys.stdin.readline\n\n    X = int(input())\n    K = int(input())\n    R = list(map(int, input().split()))\n    Q = []\n    for r in R:\n        Q.append((r, -1))\n    q = int(input())\n    for _ in range(q):\n        t, a = list(map(int, input().split()))\n        Q.append((t, a))\n    Q.sort(key=itemgetter(0))\n\n    #print(Q)\n    prev = 0\n    m = 0\n    M = X\n    flg = -1\n    R_cs = 0\n    for t, a in Q:\n        if a < 0:\n            r = t - prev\n            R_cs -= r * flg\n            if flg == -1:\n                m = max(0, m-r)\n                M = max(0, M-r)\n                flg = 1\n            else:\n                m = min(X, m+r)\n                M = min(X, M+r)\n                flg = -1\n            prev = t\n        else:\n            if m == M:\n                if flg == 1:\n                    print((min(X, m + t - prev)))\n                else:\n                    print((max(0, m - t + prev)))\n            else:\n                am = m + R_cs\n                aM = M + R_cs\n                #print('am', am, 'aM', aM, m, M)\n                if a <= am:\n                    if flg == 1:\n                        print((min(X, m + t - prev)))\n                    else:\n                        print((max(0, m - t + prev)))\n                elif a >= aM:\n                    if flg == 1:\n                        print((min(X, M + t - prev)))\n                    else:\n                        print((max(0, M - t + prev)))\n                else:\n                    if flg == 1:\n                        print((min(X, m + (a - am) + t - prev)))\n                    else:\n                        print((max(0, m + (a - am) - t + prev)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "X=int(input())\nK=int(input())\nr=list(map(int,input().split()))\nQ=int(input())\np=[tuple(map(int,input().split())) for i in range(Q)]\n\nN=Q\nL=0\nR=Q-1\nstart=0\nsign=\"-\"\n\n# N: \u51e6\u7406\u3059\u308b\u533a\u9593\u306e\u9577\u3055\n\nN0 = 2**(N-1).bit_length()\ndata = [0]*(2*N0)\nINF = 0\n# \u533a\u9593[l, r+1)\u306e\u5024\u3092v\u306b\u66f8\u304d\u63db\u3048\u308b\n# v\u306f(t, value)\u3068\u3044\u3046\u5024\u306b\u3059\u308b (\u65b0\u3057\u3044\u5024\u307b\u3069t\u306f\u5927\u304d\u304f\u306a\u308b)\ndef update(l, r, v):\n    L = l + N0; R = r + N0\n    while L < R:\n        if R & 1:\n            R -= 1\n            data[R-1] += v\n\n        if L & 1:\n            data[L-1] += v\n            L += 1\n        L >>= 1; R >>= 1\n# a_i\u306e\u73fe\u5728\u306e\u5024\u3092\u53d6\u5f97\ndef query(k):\n    k += N0-1\n    s = INF\n    while k >= 0:\n        s += data[k]\n        k = (k - 1) // 2\n    return s\n\nq=[]\nfor i in range(Q):\n    t,a=p[i]\n    p[i]=(a,t,i)\n\np.sort()\ndic=[-1]*Q\nfor i in range(Q):\n    a,t,id=p[i]\n    update(i,i+1,a)\n    dic[id]=i\n    q.append((t,id,0))\n\nfor i in range(K):\n    q.append((r[i],-1,r[i]-r[i-1]*(i>0)))\n\nq.sort()\nans=[0]*Q\nfor val,id,c in q:\n    if id==-1:\n        if sign==\"-\":\n            update(L,R+1,-c)\n            while query(L+1)<0 and L<R:\n                L+=1\n            a=query(L)\n            if a<0:\n                update(L,L+1,-a)\n            start=val\n            sign=\"+\"\n        else:\n            update(L,R+1,c)\n            while query(R-1)>X and L<R:\n                R-=1\n            a=query(R)\n            if a>X:\n                update(R,R+1,X-a)\n            start=val\n            sign=\"-\"\n    else:\n        pid,id=id,dic[id]\n        if sign==\"-\":\n            if id<L:\n                res=max(query(L)-(val-start),0)\n            elif id>R:\n                res=max(query(R)-(val-start),0)\n            else:\n                res=max(query(id)-(val-start),0)\n        else:\n            if id<L:\n                res=min(query(L)+(val-start),X)\n            elif id>R:\n                res=min(query(R)+(val-start),X)\n            else:\n                res=min(query(id)+(val-start),X)\n        ans[pid]=res\n\n\nfor i in range(Q):\n    print((ans[i]))\n", "X = int(input())\nK = int(input())\nR = [int(x) for x in reversed(input().split())]\nfor i in range(0,K-1): R[i] -= R[i+1]\nQ = int(input())\n\naM = X\nM = X\nam = 0\nm = 0\nnow = 0\nsign = -1\ntimer = R.pop()\n\ndef Go(time):\n    nonlocal aM,M,am,m\n    if sign==1:\n        if m+time>X:\n            m = X\n            M = X\n            aM = am\n        elif M+time>X:\n            m += time\n            M = X\n            aM = am + M - m\n        else:\n            m += time\n            M += time\n    else:\n        if M-time<0:\n            m = 0\n            M = 0\n            am = aM\n        elif m-time<0:\n            m = 0\n            M -= time\n            am = aM + m - M\n        else:\n            m -= time\n            M -= time\n\nfor i in range(Q):\n    t,a = [int(x) for x in input().split()]\n    t -= now\n    now += t\n    \n    while t>=timer:\n        Go(timer)\n        t -= timer\n        if R:\n            timer = R.pop()\n        else:\n            timer = float(\"inf\")\n        sign *= -1\n    \n    Go(t)\n    timer -= t\n    \n    if a<am:\n        print(m)\n    elif a>aM:\n        print(M)\n    else:\n        print(m+a-am)", "X = int(input())\nK = int(input())\nR = list(map(int, input().split()))\nQ = int(input())\n\n\nami = [0]*(K+1)\nama = [X] + [0]*K\ncusummi = [0]*(K+1)\ncusumma = [0]*(K+1)\ncusum = [0]*(K+1)\npr = 0\nfor i, r in enumerate(R):\n    d = pr-r if i%2==0 else r-pr\n    cusum[i+1] = cusum[i] + d\n    cusummi[i+1] = min(cusummi[i], cusum[i+1])\n    cusumma[i+1] = max(cusumma[i], cusum[i+1])\n    ami[i+1] = min(max(ami[i] + d, 0), X)\n    ama[i+1] = min(max(ama[i] + d, 0), X)\n    pr = r\n\nimport bisect\nfor _ in range(Q):\n    t, a = list(map(int, input().split()))\n    i = bisect.bisect_right(R, t)\n    t1 = R[i-1] if i!=0 else 0\n    t2 = t-t1\n    d = -t2 if i%2==0 else t2\n    if ama[i]==ami[i]:\n        print((min(max(ama[i] + d, 0), X)))\n        continue\n    ans = a+cusum[i]\n    if -cusummi[i]>a:\n        ans += -cusummi[i]-a\n    if cusumma[i]>(X-a):\n        ans -= cusumma[i]-(X-a)\n    print((min(max(ans+d, 0), X)))\n", "input = __import__('sys').stdin.readline\nMIS = lambda: map(int,input().split())\n \n# f(a) = z                 a <= x1\n#        a+z-x1      x1 <= a <= x2\n#        x2+z-x1     x2 <= a\nclass Sandgraph:\n    def __init__(_, X):\n        _.z = _.x1 = 0\n        _.x2 = X\n    \n    def add(_, dt):\n        # Go towards the ceiling\n        d1 = min(dt, X-(_.x2+_.z-_.x1))\n        _.z+= d1\n        dt-= d1\n        # Reduce the diagonal\n        d1 = min(dt, _.x2-_.x1)\n        _.z+= d1\n        _.x2-= d1\n    \n    def sub(_, dt):\n        # Go towards the floor\n        d1 = min(dt, _.z)\n        _.z-= d1\n        dt-= d1\n        # Reduce the diagonal\n        d1 = min(dt, _.x2-_.x1)\n        _.x1+= d1\n    \n    def __call__(_, a):\n        if a <= _.x1: return _.z\n        elif a <= _.x2: return a + _.z - _.x1\n        else: return _.x2 + _.z - _.x1\n \nX = int(input())\nk = int(input())\nrev = list(MIS())\nQ = int(input())\nsand = Sandgraph(X)\n \nlast_t = 0\ni = 0 # even -, odd +\nfor QUERY in range(Q):\n    t, a = MIS()\n    while i<k and rev[i] <= t:\n        dt = rev[i] - last_t\n        if i%2 == 0: sand.sub(dt)\n        else: sand.add(dt)\n        last_t = rev[i]\n        i+= 1\n    dt = t - last_t\n    if i%2 == 0: sand.sub(dt)\n    else: sand.add(dt)\n    print(sand(a))\n    last_t = t", "import sys\ninput = sys.stdin.readline\n\n\"\"\"\nX\u5b9a\u6570\u3060\u3063\u305f\u3002\u4e21\u6975\u7aef\u306a\u5834\u5408\u304c\u5408\u6d41\u3059\u308b\u3002\n[0,L]\u4e0a\u5b9a\u6570A\u3001[R,X]\u4e0a\u5b9a\u6570B\u3001\u305d\u306e\u9593\u306f\u7dda\u5f62\n\"\"\"\n\nX = int(input())\nK = int(input())\nR = [int(x) for x in input().split()]\nQ = int(input())\nTA = [tuple(int(x) for x in input().split()) for _ in range(Q)]\n\ntask = sorted([(r,-1) for r in R] + [(t,a) for t,a in TA])\n\nL = 0\nR = X\nA = 0\nB = X\ndx = -1 # \u521d\u3081\u306f\u6e1b\u308b\u65b9\ncurrent = 0\nanswer = []\nfor t,a in task:\n    # \u3068\u308a\u3042\u3048\u305a\u4e0a\u9650\u3092\u7a81\u7834\u3057\u3066\u843d\u3068\u3059\n    A += dx * (t-current)\n    B += dx * (t-current)\n    current = t\n    if a != -1:\n        # \u4f53\u7a4d\u306e\u8a08\u7b97\n        if a <= L:\n            x = A\n        elif a >= R:\n            x = B\n        else:\n            x = A+(B-A)//(R-L)*(a-L)\n        if x < 0:\n            x = 0\n        if x > X:\n            x = X\n        answer.append(x)\n    else:\n        dx = -dx\n        if A < B:\n            if A < 0:\n                L += (-A)\n                A = 0\n            if B > X:\n                R -= (B-X)\n                B = X\n            if A > X:\n                A = X\n                B = X\n                L = 0\n                R = 0\n            if B < 0:\n                A = 0\n                B = 0\n                L = 0\n                R = 0\n        elif A >= B:\n            if A > X:\n                L += (A-X)\n                A = X\n            if B < 0:\n                R -= (-B)\n                B = 0\n            if A < 0:\n                A = 0\n                B = 0\n                L = 0\n                R = 0\n            if B > X:\n                A = X\n                B = X\n                L = 0\n                R = 0\n        if R < L:\n            R = L\n\nprint(*answer,sep='\\n')\n\n", "import sys\ninput = sys.stdin.readline\n\nx = int(input())\nk = int(input())\nR = [(_r, i%2) for i, _r in enumerate(map(int, input().split()))]\nn = int(input())\nTA = [list(map(int, input().split())) for _ in range(n)]\nT, A = zip(*TA)\nL = [None]*n\nb = 0\nfor i, t in enumerate(T, 1):\n  R.append((t, -i))\nR.sort()\ndx = 1\nl, r, p, q = 0, x, 0, x\nfor _r, i in R:\n  d = _r-b\n  b = _r\n  if dx == 1:\n    if d <= p:\n      p -= d\n      q -= d\n    elif d < q:\n      q -= d\n      l = r-q\n      p = 0\n    else:\n      l = 0\n      r = 0\n      p = 0\n      q = 0\n  else:\n    if d <= x-q:\n      p += d\n      q += d\n    elif d < x-p:\n      p += d\n      r = l+(x-p)\n      q = x\n    else:\n      l = x\n      r = x\n      p = x\n      q = x\n  if i >= 0:\n    dx = i\n  else:\n    a = A[-i-1]\n    if a < l:\n      res = p\n    elif a <= r:\n      res = (a-l)+p\n    else:\n      res = q\n    L[-i-1] = res\nprint(*L, sep=\"\\n\")", "#!/usr/bin/env python3\nimport bisect\n\ndef main():\n    X = int(input())\n    K = int(input())\n    r = list(map(int, input().split()))\n    Q = int(input())\n    q_list = []\n    for i in range(Q):\n        q_list.append(list(map(int, input().split())))\n\n    r = [0] + r\n    a = [0]\n    upper_limit = [X]\n    lower_limit = [0]\n\n    x, ux, lx = 0, X, 0\n    for i in range(1, K + 1):\n        diff = r[i] - r[i - 1]\n        if i % 2 == 1:\n            x -= diff\n            ux -= diff\n            ux = max(ux, 0)\n            lx -= diff\n            lx = max(lx, 0)\n        else:\n            x += diff\n            ux += diff\n            ux = min(ux, X)\n            lx += diff\n            lx = min(lx, X)\n        a.append(x)\n        upper_limit.append(ux)\n        lower_limit.append(lx)\n\n    asc_i = [0]\n    dsc_i = [1]\n    x = 0\n    for i in range(2, K + 1, 2):\n        if x < a[i]:\n            x = a[i]\n            asc_i.append(i)\n    x = a[1]\n    for i in range(3, K + 1, 2):\n        if a[i] < x:\n            x = a[i]\n            dsc_i.append(i)\n\n    asc_a = [a[i] for i in asc_i]\n    dsc_a = [-a[i] for i in dsc_i]\n\n\n    for [t, a0] in q_list:\n        ri = bisect.bisect_right(r, t) - 1\n\n        ui = bisect.bisect_left(asc_a, X - a0)\n        li = bisect.bisect_left(dsc_a, a0)\n\n        ai, di = None, None\n        if ui < len(asc_i):\n            ai = asc_i[ui]\n            if ri < ai:\n                ai = None\n        if li < len(dsc_i):\n            di = dsc_i[li]\n            if ri < di:\n                di = None\n\n        d = 0\n        if (not ai is None) or (not di is None):\n            if ai is None:\n                d = -1\n            elif di is None:\n                d = 1\n            else:\n                d = 1 if ai < di else -1\n\n        x = a0 + a[ri]\n        if d == 1:\n            x = upper_limit[ri]\n        elif d == -1:\n            x = lower_limit[ri]\n        x += (t - r[ri]) * (-1 if ri % 2 == 0 else 1)\n        x = min(max(x, 0), X)\n\n        print(x)\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "X = int(input())\nK = int(input())\nR = list(map(int,input().split()))\nR.append(0)\n\nA = [X for _ in range(K+1)]\nB = [0 for _ in range(K+1)]\nC = [X for _ in range(K+1)]\nD = [0 for _ in range(K+1)]\nstate = -1\nfor i in range(K):\n  dr = R[i] - R[i-1]\n  if state == -1:\n    C[i+1] = max(0, C[i]-dr)\n    D[i+1] = max(0, D[i]-dr)\n    B[i+1] = min(B[i] + (-min(0, D[i]-dr)), A[i])\n    A[i+1] = A[i]\n    \n  else:\n    C[i+1] = min(X, C[i]+dr)\n    D[i+1] = min(X, D[i]+dr)\n    A[i+1] = max(A[i] - max(0, C[i]+dr-X), B[i])\n    B[i+1] = B[i]\n\n  state *= -1\n\"\"\"\nprint(A)\nprint(B)\nprint(C)\nprint(D)\n\"\"\"\n\nQ = int(input())\nR.pop()\nimport bisect\nfor _ in range(Q):\n  t, a = list(map(int,input().split()))\n  j = bisect.bisect_right(R, t)\n  if j == 0: r = 0\n  else: r = R[j-1]\n  pre_ans = (min(A[j],max(B[j],a)) - B[j]) + D[j]\n  #print(pre_ans)\n  pre_ans += ((-1)**(1-j%2)) * (t-r)\n  #print(j, t, r)\n  print((min(X, max(0, pre_ans))))\n  \n", "X = int(input())\nK = int(input())\nrs = list(map(int,input().split()))\nQ = int(input())\nqs = [tuple(map(int,input().split())) for i in range(Q)]\n\ndx = -1\nri = 0\noffset = 0\nupper,lower = X,0\nprev_r = 0\nans = []\nfor t,a in qs:\n    while ri < len(rs) and rs[ri] <= t:\n        tmp_offset = dx * (rs[ri] - prev_r)\n        if dx == 1:\n            upper = min(X, upper + tmp_offset)\n            lower = min(X, lower + tmp_offset)\n        else:\n            upper = max(0, upper + tmp_offset)\n            lower = max(0, lower + tmp_offset)\n        offset += tmp_offset\n        dx *= -1\n        prev_r = rs[ri]\n        ri += 1\n    a = max(lower, min(upper, a+offset))\n    dt = t - prev_r\n    a = max(0, min(X, a + dx*dt))\n    ans.append(a)\n\nprint(*ans, sep='\\n')", "# F\n# input\nfrom bisect import bisect\nX = int(input())\nK = int(input())\nr_list = [0] + list(map(int, input().split()))\n\nQ = int(input())\nquery_list = [list(map(int, input().split())) for _ in range(Q)]\n\n\nMmRL_list = []\n\n# M:max, m:min, R:min_a(M), L:max_a(m)\nM = X\nm = 0\nR = X\nL = 0\n\nMmRL_list.append([M, m, R, L])\n\nfor i in range(K):\n    M_ = M\n    m_ = m\n    R_ = R\n    L_ = L\n    lag = r_list[i+1] - r_list[i]\n    # update\n    if i % 2 == 0:\n        if M_ - lag < 0:\n            M = 0\n            R = 0\n        else:\n            M = M_ - lag\n            R = R_\n        if m_ - lag < 0:\n            m = 0\n            L = L_ + lag - m_\n        else:\n            m = m_ - lag\n            L = L_\n    else:\n        if M_ + lag > X:\n            M = X\n            R = R_ - (M_ + lag - X)\n        else:\n            M = M_ + lag\n            R = R_\n        if m_ + lag > X:\n            m = X\n            L = X\n        else:\n            m = m_ + lag\n            L = L_\n    MmRL_list.append([M, m, R, L])\n        \n\n# print(MmRL_list)\nfor q in range(Q):\n    t, a = query_list[q]\n    j = bisect(r_list, t) - 1\n    # find status then\n    M, m, R, L = MmRL_list[j]\n    if a <= L:\n        a_ = m\n    elif a >= R:\n        a_ = M\n    else:\n        a_ = m + (a - L)\n    t_ = t - r_list[j]\n    if j % 2 == 0:\n        res = max(a_ - t_, 0)\n    else:\n        res = min(a_ + t_, X)\n    print(res)\n", "\ndef main1(x,k,rary,q,ta):\n  aary=[]\n  tary=[]\n  for i,(t,a) in enumerate(ta):\n    aary.append([a,i])\n    tary.append([t,i])\n  tary.sort(key=lambda x:x[0])\n  aary.sort(key=lambda x:x[0])\n  l,r=0,x # [l,r]:0,x\u306e\u58c1\u306b\u3076\u3064\u304b\u3063\u3066\u3044\u306a\u3044\u521d\u671fa\u306e\u7bc4\u56f2\n  lt,rt=-1,-1 # \u58c1\u3076\u3064\u304b\u308a\u304c\u767a\u751f\u3057\u305f\u3042\u3068\u7802\u6642\u8a08\u304c\u3072\u3063\u304f\u308a\u8fd4\u308b\u6642\u9593\n  tidx=0\n  nowt=0\n  nowu='A'\n  da=0\n  ret=[-1]*q\n  daary={}\n  rary.append(10**9+1)\n  k+=1\n  for i,ri in enumerate(rary):\n    while tidx<q and tary[tidx][0]<=ri:\n      t,j=tary[tidx]\n      tidx+=1\n      a=ta[j][1]\n      if nowu=='A':\n        if l<=a<=r:\n          ret[j]=a+da-(t-nowt)\n        elif a<l:\n          ret[j]=da-daary[lt]-(t-nowt)\n        else:\n          ret[j]=x+da-daary[rt]-(t-nowt)\n      else:\n        if l<=a<=r:\n          ret[j]=a+da+(t-nowt)\n        elif a<l:\n          ret[j]=da-daary[lt]+(t-nowt)\n        else:\n          ret[j]=x+da-daary[rt]+(t-nowt)\n      ret[j]=max(0,ret[j])\n      ret[j]=min(x,ret[j])\n    if nowu=='A':\n      dt=ri-nowt\n      da-=dt\n      if l<-da:\n        l=-da\n        lt=ri\n      nowt=ri\n      nowu='B'\n    else:\n      dt=ri-nowt\n      da+=dt\n      if r>x-da:\n        r=x-da\n        rt=ri\n      nowt=ri\n      nowu='A'\n    daary[nowt]=da\n    if l>=r:\n      if nowu=='B':\n        da=0\n      else:\n        da=x\n      for ii in range(i+1,k):\n        ri=rary[ii]\n        while tidx<q and tary[tidx][0]<=ri:\n          t,j=tary[tidx]\n          tidx+=1\n          if nowu=='A':\n            ret[j]=da-(t-nowt)\n          else:\n            ret[j]=da+(t-nowt)\n          ret[j]=max(0,ret[j])\n          ret[j]=min(x,ret[j])\n        if nowu=='A':\n          da-=ri-nowt\n          da=max(da,0)\n          nowu='B'\n        else:\n          da+=ri-nowt\n          da=min(da,x)\n          nowu='A'\n        nowt=ri\n      break\n  return ret\n\nimport sys\ninput=sys.stdin.readline\ndef __starting_point():\n  x=int(input())\n  k=int(input())\n  r=list(map(int,input().split()))\n  q=int(input())\n  ta=[list(map(int,input().split())) for _ in range(q)]\n  print(*main1(x,k,r,q,ta),sep='\\n')\n\n__starting_point()", "import bisect\noX = int(input())\nK = int(input())\nr= list(map(int,input().split()))\n\n# a X-a\n# min(max(0,a-r[0]))\n#  a-r[0]+r[1]\n\ndef calc_time(t):\n    val = bisect.bisect_left(t,r)\n    diff= t- r[val]\n    return val,diff\n\n\n# [sep1,sep2,a<sep1,sep1<a<sep2,a>sep2  ]\n\nlast =(0,oX,0 ,0,oX)\nres =[last]\nfor i,tr in enumerate(r):\n    sep1,sep2,X,Y,Z=last\n    dt = tr if i==0 else tr-r[i-1]\n    if i%2==0: # a ->b\n\n        X = max(0,X-dt)\n        Y = Y-dt\n        Z = max(0,Z-dt)\n        sep1 = max(sep1,-Y)\n    else: #b-> a\n        X = min(oX,X+dt)\n        Y= Y+dt\n\n        Z = min(oX,Z+dt)\n        sep2 = min(sep2,oX-Y)\n\n    last = (sep1,sep2,X,Y,Z)\n    res.append(last)\n\n#print(res)\n\n\nQ = int(input())\n\nr_index=0\nr.insert(0,0)\nr.append(10000000000)\nfor i in range(Q):\n    def calc(X,r_index,diff):\n        tmp = 1 if r_index%2 else -1\n        return min(oX,max(0,X +tmp* diff))\n    t,a =list(map(int,input().split()))\n    while r[r_index]< t:\n        if r[r_index+1] >t:\n            break\n        r_index+=1\n    sep1, sep2, X, Y, Z = res[r_index]\n    diff = t -r[r_index]\n    #print(t,diff,r_index,r[r_index])\n    if a< sep1:\n        print((calc(X,r_index,diff)))\n    elif a>sep2:\n        print((calc(Z,r_index,diff)))\n    else:\n        print((calc(a+Y,r_index,diff)))\n\n", "import sys\nfrom bisect import bisect\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nx = int(input())\nk = int(input())\nz = [0] + list(map(int, input().split()))\ns = [z[i+1] - z[i] for i in range(k)]\n\nlr = [[0, x]]\npq = [[0, x]]\n\nfor i in range(k):\n\tl, r = lr[-1]\n\tp, q = pq[-1]\n\tif i%2 == 0:\n\t\tlr.append([max(l-s[i], 0), max(r-s[i], 0)])\n\t\tpq.append([min(p + max(min(s[i], x)-l, 0), q), q])\n\telse:\n\t\tlr.append([min(l+s[i], x), min(r+s[i], x)])\n\t\tpq.append([p, max(q - max(r-max(x-s[i], 0), 0), p)])\n\nq = int(input())\nfor _ in range(q):\n\tt, a = map(int, input().split())\n\ti = bisect(z, t) - 1\n\tt -= z[i]\n\tif a <= pq[i][0]:\n\t\ty = lr[i][0]\n\telif a >= pq[i][1]:\n\t\ty = lr[i][1]\n\telse:\n\t\ty = lr[i][0] + a - pq[i][0]\n\n\tif i%2 == 0:\n\t\tprint(max(y-t, 0))\n\telse:\n\t\tprint(min(y+t, x))", "x = int(input())\nk = int(input())\n*R, = map(int,input().split()+[1<<30])\nQ = int(input())\nta = [tuple(map(int,input().split())) for _ in range(Q)]\ndef f(x,l): return(max(l[0],min(l[1],x+l[2])))\nL = a,b,c = 0,x,0\nidx = t0 = 0\ng = -1\nfor r in R:\n    while idx < Q and ta[idx][0] < r:\n        print(f(f(ta[idx][1],L)+g*(ta[idx][0]-t0),(0,x,0)));idx += 1\n    d,t0 = g*(r-t0),r\n    L = a,b,c = f(a,(0,x,d)),f(b,(0,x,d)),c+d\n    g *= -1", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\n\nx, = map(int,readline().split())\nk, = map(int,readline().split())\n*r, = map(int,readline().split())\nq, = map(int,readline().split())\nr.append(1<<30)\n\nINF = 1<<30\nID_M = (-INF,INF,0)\ndef compose(lst1,lst2):\n    return (funcval(lst1[0],lst2),funcval(lst1[1],lst2),lst1[2]+lst2[2])\n\ndef funcval(x,lst):\n    a,b,c = lst\n    if x <= a-c: return a\n    elif x >= b-c: return b\n    else: return x+c\n\n#seg = segment_tree_dual(q, compose, funcval, ID_M)\n#seg.build([a for a,t,i in ati])\n\nseg = (0,x,0)\n\ntai = []\nfor i in range(q):\n    t,a = map(int,readline().split())\n    tai.append((t,a,i))\n\ntai.sort(key=lambda x:x[0])\n\nidx = 0\nans = [0]*q\nt0 = 0\ncoeff = -1\nfor i,ri in enumerate(r):\n    while idx < q and tai[idx][0] < ri:\n        t,a,j = tai[idx]\n        v = funcval(a,seg)\n        ans[j] = min(x,max(v+coeff*(t-t0),0))\n        idx += 1\n        \n    seg = compose(seg,(0,x,coeff*(ri-t0)))\n    \n    t0 = ri\n    coeff *= -1    \n\n    #print(seg)\n\nprint(*ans,sep=\"\\n\")\n\n\n", "import sys\nfrom heapq import *\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    x = int(input())\n    k = int(input())\n    rr = LI()\n    q = int(input())\n    ta = LLI(q)\n    # [\u6642\u9593,\u547d\u4ee4,(a)]\u3067\u30bf\u30a4\u30e0\u30e9\u30a4\u30f3\u306b\u767b\u9332\n    # \u547d\u4ee40\u3067\u3072\u3063\u304f\u308a\u8fd4\u3059 1\u3067\u8cea\u554f\u306b\u7b54\u3048\u308b\n    timeline = []\n    for r in rr:\n        heappush(timeline, [r, 0, 0])\n    for t, a in ta:\n        heappush(timeline, [t, 1, a])\n    # print(timeline)\n    # A\u306e\u30d1\u30fc\u30c4\u304c\u4e00\u5ea6\u3067\u3082\u7a7a\u3084\u6e80\u30bf\u30f3\u306b\u306a\u308b\u3068\u3001a\u306f\u95a2\u4fc2\u306a\u304f\u306a\u308b\u306e\u304c\u5927\u4e8b\u306a\u6240\n    # \u3060\u304b\u3089\u7a7a\u306b\u306a\u308ba\u306fal\u672a\u6e80\u306ea\u3068\u3057\u3066\u3072\u3068\u307e\u3068\u3081\n    # \u6e80\u30bf\u30f3\u306b\u306a\u308ba\u306far\u3088\u308a\u5927\u304d\u3044a\u3068\u3057\u3066\n    # \u3072\u3068\u307e\u3068\u3081\u3067\u7ba1\u7406\u3059\u308b\n    #       l       r\n    # a=0 1 2 3 4 5 6 7 8 9 10...\n    #       al      ar\n    # al(=2)\u672a\u6e80\u306ea\u306e\u7802\u306e\u91cfsl\n    # ar(=6)\u3088\u308a\u5927\u304d\u3044a\u306e\u7802\u306e\u91cfsr\n    # al\u4ee5\u4e0aar\u4ee5\u4e0b\u306ea\u306e\u7802\u306e\u91cfa+sm\n    sl = sm = 0\n    sr = x\n    al = 0\n    ar = x\n    rev_t = 0\n    trend = False\n    while timeline:\n        t, op, a = heappop(timeline)\n        sd = t - rev_t\n        if op:\n            if trend:\n                if a < al:\n                    print(min(sl + sd, x))\n                elif a > ar:\n                    print(min(sr + sd, x))\n                else:\n                    print(min(a + sm + sd, x))\n            else:\n                if a < al:\n                    print(max(sl - sd, 0))\n                elif a > ar:\n                    print(max(sr - sd, 0))\n                else:\n                    print(max(a + sm - sd, 0))\n        else:\n            if trend:\n                sl = min(sl + sd, x)\n                sr = min(sr + sd, x)\n                ar = min(ar, x - sm - sd - 1)\n                sm += sd\n            else:\n                sl = max(sl - sd, 0)\n                sr = max(sr - sd, 0)\n                al = max(al, sd - sm + 1)\n                sm -= sd\n            trend = not trend\n            rev_t = t\n        # print(t, op, a, al, ar, sl, sm, sr)\nmain()\n", "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc082/tasks/arc082_d\n\nai\u304c\u56fa\u5b9a\u306a\u3089\u3070\u3001\u305f\u3060\u30af\u30a8\u30ea\u3092\u30bd\u30fc\u30c8\u3057\u3066\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u306a\u304c\u3089\u7b54\u3048\u3092\u51fa\u305b\u3070\u3088\u3044\n\u4eca\u56de\u306f\u305d\u3046\u3067\u306a\u3044\u306e\u3067\u3001\u65b9\u6cd5\u3092\u8003\u3048\u308b\n\n\u4e00\u5ea6\u3067\u3082\u7802\u304c\u843d\u3061\u5207\u3063\u3066\u3057\u307e\u3048\u3070\u3001\u305d\u306e\u5f8c\u306fai\u306b\u95a2\u308f\u3089\u305a\u3001\u7b54\u3048\u306f\u7b49\u3057\u304f\u306a\u308b\n\u304a\u3061\u304d\u3063\u3066\u3044\u306a\u3044\u5834\u5408\u3001\u5e38\u306b\u7802\u304c\u79fb\u52d5\u3057\u7d9a\u3051\u308b\u306e\u3067\u3001\u521d\u671f\u5024\u304b\u3089\u306e\u5dee\u5206\u304c\u5e38\u306b\u7b49\u3057\u304f\u306a\u308b\n\u3088\u3063\u3066\u3001\u843d\u3061\u5207\u3089\u306a\u3044a\u306e\u7bc4\u56f2\u3092\u4fdd\u6301\u3057\u3001\u4e00\u5ea6\u3082\u843d\u3061\u5207\u3089\u306a\u3044\u5834\u5408\u306e\u521d\u671f\u304b\u3089\u306e\u5dee\u5206\n& \u843d\u3061\u5207\u3063\u3066\u3057\u307e\u3063\u305f\u5834\u5408\u306e\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u7d50\u679c\u3092\u7528\u3044\u3066\u7b54\u3048\u308c\u3070\u3088\u3044\n\n\u2192\u3069\u306e\u30bf\u30a4\u30df\u30f3\u30b0(\u533a\u9593)\u3067\u843d\u3061\u5207\u308b\u304b\u3067\u305d\u306e\u5f8c\u306e\u52d5\u304d\u304c\u9055\u304f\u306d\uff1f\uff1f\uff1f\n\u2192\u6b7b\n\n\u2192a\u306e\u533a\u9593\u306f\u9ad8\u30053\u3064\u306b\u5206\u3051\u3089\u308c\u308b\n\u2192 a\u304c\u5c11\u306a\u304f\u3001a=0\u3068\u540c\u3058\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u3001 a\u304c\u5927\u304d\u304f\u3001a=X\u3068\u540c\u3058\u306b\u53ce\u675f\u3059\u308b\u5834\u5408\u3002\u3001\u4e00\u5ea6\u3082\u843d\u3061\u5207\u3089\u306a\u3044\u5834\u5408\n\u2192\u305d\u3057\u3066\u3001a=0,a=X\u3068\u540c\u3058\u306b\u306a\u308b\u5834\u5408\u306f\u3001\u305d\u308c\u305e\u308ca\u306e\u521d\u671f\u5024\u306e\u533a\u9593\u306e\u4e21\u7aef\u304b\u3089\u4fb5\u98df\u3057\u3066\u3044\u304f\n\u2192\u3088\u3063\u3066\u3001a=0\u306e\u30b7\u30df\u30e5\u3001a=X\u306e\u30b7\u30df\u30e5\u3001\u843d\u3061\u5207\u3089\u306a\u3044\u5dee\u5206\u30b7\u30df\u30e5\u3002\u305d\u306e\u6642\u3042\u308ba\u304c\u3069\u308c\u306b\u5c5e\u3059\u304b\u306e\u533a\u9593\n\u3092\u7528\u3044\u3066\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u306a\u304c\u3089dp\u7684\u306b\u51e6\u7406\u3057\u3066\u3042\u3052\u308c\u3070\u3088\u3044\n\n\u3042\u3068\u306f\u5b9f\u88c5\u304c\u9762\u5012\u305d\u3046\n\"\"\"\nfrom collections import deque\nX = int(input())\nK = int(input())\n\nr = list(map(int,input().split()))\n#\u756a\u5175\nr.append(float(\"inf\"))\nr.append(0)\n\nta = deque([])\nQ = int(input())\n\nfor i in range(Q):\n    t,a = list(map(int,input().split()))\n    ta.append([t,a])\n\nZA = 0 #\u521d\u671f\u304ca=0\u306e\u6642\u306e\u30b7\u30df\u30e5\u7d50\u679c\nXA = X #\u521d\u671f\u304cX\u306e\u6642\nD  = 0 #\u5dee\u5206\u8a08\u7b97\nZmax = 0 #a\u304cZmax\u4ee5\u4e0b\u306a\u3089ZA\u3068\u7b49\u3057\u304f\u306a\u308b\nXmin = X #a\u304cXmin\u4ee5\u4e0a\u306a\u3089XA\u3068\u7b49\u3057\u304f\u306a\u308b\n\nfor i in range(K+1):\n\n    time = r[i] - r[i-1]\n\n    #\u30af\u30a8\u30ea\u306e\u51e6\u7406(r[i]\u4ee5\u4e0b\u306b\u95a2\u3057\u3066)\n    if i % 2 == 0: #A\u304c\u6e1b\u3063\u3066\u3044\u304f\n        \n        while len(ta) > 0 and ta[0][0] <= r[i]:\n            t,a = ta.popleft()\n            td = t - r[i-1]\n\n            if a <= Zmax:\n                print((max( 0 , ZA-td )))\n            elif a >= Xmin:\n                print((max (0 , XA-td )))\n            else:\n                print((max (0 , a+D-td)))\n\n        D -= time\n        Zmax = max(Zmax,-1*D)\n        ZA = max(0,ZA-time)\n        XA = max(0,XA-time)\n\n    else: #A\u304c\u5897\u3048\u3066\u3044\u304f\n        \n        while len(ta) > 0 and ta[0][0] <= r[i]:\n            t,a = ta.popleft()\n            td = t - r[i-1]\n\n            if a <= Zmax:\n                print((min( X , ZA+td )))\n            elif a >= Xmin:\n                print((min (X , XA+td )))\n            else:\n                print((min (X , a+D+td)))\n\n        D += time\n        Xmin = min(Xmin,X-D)\n        ZA = min(X,ZA+time)\n        XA = min(X,XA+time)\n\n\n    \n", "import sys\n\n# sys.stdin = open('f1.in')\n\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_str_list():\n    return input().split()\n\n\ndef read_str():\n    return input()\n\n\ndef solve():\n    X = read_int()\n    K = read_int()\n    r = read_int_list()\n    Q = read_int()\n    j = 0\n    sign = -1\n    s = 0\n    e = X\n    y = 0\n    origin = 0\n    out = [0] * Q\n    for i in range(Q):\n        t, a = read_int_list()\n        while j < K and r[j] < t:\n            d = r[j] - origin\n            y += d * sign\n            if y < 0:\n                s += abs(y)\n                if s > e:\n                    s = e\n                y = 0\n            if y + e - s > X:\n                diff = (y + e - s) - X\n                e -= diff\n                if e < s:\n                    e = s\n            if y > X:\n                y = X\n            origin = r[j]\n            j += 1\n            sign *= -1\n        d = t - origin\n        if a <= s:\n            res = y\n        elif a <= e:\n            res = y + a - s\n        else:\n            res = y + e - s\n        res += d * sign\n        if res < 0:\n            res = 0\n        if res > X:\n            res = X\n        out[i] = res\n    return out\n\n\ndef main():\n    res = solve()\n    print(*res, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\ngosa = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n\n\ndef main():\n    x = I()\n    k = I()\n    r = LI()\n    q = I()\n    t = [LI() for _ in range(q)]\n    a = [[0,0,0,x,0,0]]\n    d = 0\n    for i in range(k):\n        c = a[-1][:]\n        rr = r[i] - d\n        d = r[i]\n        if i % 2 == 0:\n            c[1] -= rr\n            c[3] -= rr\n            c[4] -= rr\n            if c[0] > c[1]:\n                c[0] = c[1]\n        else:\n            c[1] += rr\n            c[3] += rr\n            c[4] += rr\n            if c[2] < c[1]:\n                c[2] = c[1]\n        if c[3] > x:\n            c[3] = x\n        if c[3] < 0:\n            c[3] = 0\n        if c[4] > x:\n            c[4] = x\n        if c[4] < 0:\n            c[4] = 0\n\n        c[5] = r[i]\n\n        a.append(c)\n    def bs(i):\n        ma = k\n        mi = 0\n        mm = 0\n        while ma > mi and (ma+mi) // 2 != mm:\n            mm = (ma+mi) // 2\n            if a[mm][5] < i:\n                mi = mm\n            else:\n                ma = mm - 1\n        if a[mm][5] > i:\n            return mm-1\n        if mm == k:\n            return k\n        if a[mm+1][5] <= i:\n            return mm+1\n        return mm\n\n    #print(a)\n    rr = []\n    for c,d in t:\n        ti = bs(c)\n        ai = a[ti]\n        e = x-d\n        #print(c,d,e,ti,ai)\n        if d + ai[0] <= 0:\n            tt = ai[4]\n        elif e - ai[2] <= 0:\n            tt = ai[3]\n        else:\n            tt = d + ai[1]\n        #print('tt',tt)\n        if ti % 2 == 0:\n            tt -= c - ai[5]\n        else:\n            tt += c - ai[5]\n        #print('tt2',tt)\n        if tt < 0:\n            tt = 0\n        elif tt > x:\n            tt = x\n        rr.append(tt)\n\n    return '\\n'.join(map(str,rr))\n\n\nprint((main()))\n\n", "import sys\ninput = sys.stdin.readline\n\nx = int(input())\nk = int(input())\nR = [(_r, i%2) for i, _r in enumerate(map(int, input().split()))]\nn = int(input())\nTA = [list(map(int, input().split())) for _ in range(n)]\nT, A = zip(*TA)\nL = [None]*n\nb = 0\nfor i, t in enumerate(T, 1):\n  R.append((t, -i))\nR.sort()\ndx = 1\nl, r, p, q = 0, x, 0, x\nfor _r, i in R:\n  d = _r-b\n  b = _r\n  if dx == 1:\n    if d <= p:\n      p -= d\n      q -= d\n    elif d < q:\n      q -= d\n      l = r-q\n      p = 0\n    else:\n      l = 0\n      r = 0\n      p = 0\n      q = 0\n  else:\n    if d <= x-q:\n      p += d\n      q += d\n    elif d < x-p:\n      p += d\n      r = l+(x-p)\n      q = x\n    else:\n      l = x\n      r = x\n      p = x\n      q = x\n  if i >= 0:\n    dx = i\n  else:\n    a = A[-i-1]\n    if a < l:\n      res = p\n    elif a <= r:\n      res = (a-l)+p\n    else:\n      res = q\n    L[-i-1] = res\nprint(*L, sep=\"\\n\")"]
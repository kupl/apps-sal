["class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        \n        i = 0\n        j = len(piles) - 1\n        \n        max_coins = 0\n        for i in range(len(piles) // 3, len(piles), 2):\n            max_coins += piles[i]\n        \n        return max_coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        return sum(piles[1:int(len(piles)/3*2):2])\n            \n            \n            \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        piles.reverse()\n        ans = 0\n        for i in range(len(piles)//3):\n            ans = ans + piles[2*i+1]\n\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        list.sort(piles , reverse=True)\n        print(piles)\n        \n        init =0\n\n            \n        for j in range((len(piles)//3)):\n            init=init + piles[j*2+1]\n            \n            \n        return init", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        ans = 0\n        i = 1\n        j = len(piles)-1\n        \n        while(j-i >= 1):\n            ans+=piles[i]\n            j-=1\n            i+=2\n        return ans\n", "\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        rounds = []\n        piles.sort()\n        for i in range((int)(len(piles)/3)):\n            round_draw = []\n            round_draw.append(piles[i])\n            round_draw.append(piles[-i*2 - 2])\n            round_draw.append(piles[-i*2 - 1])\n            rounds.append(round_draw)\n        sum = 0\n        for round_draw in rounds:\n            sum += round_draw[1]\n        return sum", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        result = 0\n        piles.sort(reverse = True)\n        for i in range(1, 2*len(piles)//3, 2):\n            result += piles[i]\n        return result\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n# #             With deque\n#         piles.sort()\n#         piles = deque(piles)\n        \n#         me = 0\n#         while len(piles) > 2:\n#             piles.pop()\n#             me += piles.pop()\n#             if piles:\n#                 piles.popleft()\n#         return me\n        \n#             With 2 pointers\n        piles.sort()\n        \n        me = 0\n        start, end = 0, len(piles) - 1\n        while start < end:\n            if end-1 > 0:\n                me += piles[end-1]\n            start, end = start+1, end-2\n        return me\n", "class Solution:\n    from collections import deque\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)//3\n        s = piles[n:n*3]\n        return sum([s[i] for i in range(len(s)) if i%2==0])\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        left = 0\n        right = len(piles) - 2\n        total = 0\n        while(left < right):\n            total += piles[right]\n            left += 1\n            right -= 2\n        return total\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)\n        piles = sorted(piles)\n        piles = deque(piles)\n        ans = 0\n        while piles:\n            piles.pop()\n            ans += piles.pop()\n            piles.popleft()\n        return ans", "class Solution:\n  def maxCoins(self, piles: List[int]) -> int:\n    piles.sort(key=lambda k: k * -1)\n    return sum(piles[1:len(piles)//3*2:2])\n    \n    \n    \n    # 9, 8, 1\n    # 7, 6, 2\n    # 5, 4, 3\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles, key=lambda x: -x)\n        result = 0\n        \n        for i in range(len(piles) // 3):\n            result += piles[1 + 2 * i]\n        \n        return result\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles,reverse = True)\n        ans = 0\n        for i in range(len(piles)//3):\n            ans = ans + piles[2*i+1]\n\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles = deque(piles)\n        \n        me = 0\n        while piles:\n            alice = piles.pop()\n            if piles:\n                me += piles.pop()\n            if piles:\n                bob = piles.popleft()\n        \n        return me\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        rounds = len(piles) // 3\n        score = 0\n        \n        piles.sort()\n        for x in range(len(piles) - 2, rounds - 1 , -2):\n            score += piles[x]\n        \n        return score", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        coins = 0\n        for i in range(len(piles) // 3, len(piles), 2):\n            coins += piles[i]\n        return coins", "class Solution:\n    def maxCoins(self, a: List[int]) -> int:\n        a.sort()\n        n = len(a)\n        i = n // 3\n        ans = 0\n        while i < n:\n            ans += a[i]\n            i += 2\n        return ans\n        \n", "import heapq\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        choice = heapq.nlargest(len(piles)//3*2,piles)\n        ans = 0\n        for i in range(1,len(choice),2):\n            ans += choice[i]\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n#             With deque\n        piles.sort()\n        piles = deque(piles)\n        \n        me = 0\n        while len(piles) > 2:\n            piles.pop()\n            me += piles.pop()\n            if piles:\n                piles.popleft()\n        return me\n        \n# #             With 2 pointers\n#         piles.sort()\n        \n#         me = 0\n#         start, end = 0, len(piles) - 1\n#         while start < end:\n#             if end-1 > 0:\n#                 me += piles[end-1]\n#             start, end = start+1, end-2\n#         return me\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles) // 3\n        piles = piles[n:] # remove Bob's\n        return sum(piles[i*2] for i in range(n))", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = True)\n        \n        i = 1\n        x = len(piles)\n        ans = []\n        while i < x:\n            \n            ans.append(piles[i])\n            x = x- 1\n                \n           \n            i = i + 2\n               \n                \n                \n        return sum(ans)\n                \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        num=int(len(piles)/3)\n        \n        sor=sorted(piles)\n        count=0\n        for i in range(1,num+1):\n            count+=sor[num*3-i*2]\n            \n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        piles.sort(reverse = True)\n        for i in range(len(piles)//3):\n            res += piles[2*(i+1)-1]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # [2,4,1,2,7,8]\n        # [1,2,2,4,7,8]\n        piles.sort()\n        n = len(piles)\n        \n        if n < 3:\n            return 0\n        \n        current = n - 2\n        low = 0\n        total = 0\n        \n        while current > low:\n            total += piles[current]\n            current -= 2\n            low += 1\n            \n        return total\n        \n        \n", "from heapq import heappop, heappush, heapify \n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        i, j = 0, 0\n        ans = 0\n        length = len(piles)\n        while i + j < length - 1:\n            i += 1\n            j += 2\n            ans += piles[-j]\n        return ans\n            \n        \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        # piles = deque(piles)\n        \n        me = 0\n        start, end = 0, len(piles) - 1\n        # while len(piles) > 2:\n        while start < end:\n            # piles.pop()\n            # me += piles.pop()\n            # if piles:\n            #     piles.popleft()\n            if end-1 > 0:\n                me += piles[end-1]\n            start, end = start+1, end-2\n        return me\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        res = 0\n        for i in range(1, len(piles) // 3 * 2, 2):\n            res += piles[i]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        print(len(piles) % 3)\n        piles = sorted(piles)\n        print(piles)\n        score = 0\n        if len(piles) % 3 == 0:\n            tmp = piles[int(len(piles)/3):]\n            nums = [tmp[i] for i in range(0, len(tmp), 2)]\n            print(sum(nums))\n            return sum(nums)\n        elif len(piles) % 3 == 2:\n            tmp = piles[int(len(piles) / 3):]\n            nums = [tmp[i] for i in range(0, len(tmp), 2)]\n            print(sum(nums))\n            return sum(nums)\n        else:\n            tmp = piles[int(len(piles) / 3):]\n            nums = [tmp[i] for i in range(1, len(tmp), 2)]\n            print(sum(nums))\n            return sum(nums)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        return sum(piles[len(piles) // 3::2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        i,j= 0, len(piles)-1\n        coins = 0\n        while i < j:\n            coins += piles[j-1]\n            i += 1\n            j -= 2\n        return coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        length=len(piles)//3\n        piles=piles[length:];me=0;alice=0\n        for i in range(len(piles)):\n            if i%2==0:\n                me+=piles[i]\n            else:\n                alice+=piles[i]\n        return me", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        arr = sorted(piles)\n        res = []\n        n = len(piles)//3\n        while len(arr) > n:\n            arr.pop(-1)\n            res.append(arr.pop(-1))\n        return sum(res)\n            \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        first, last = 0, len(piles) - 1\n        total = 0\n        while first < last:\n            total += piles[last-1]\n            first += 1\n            last -= 2\n        return total", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sort = sorted(piles)\n        sort = sort[len(sort) // 3:]\n        res = 0\n        for i in range(0, len(sort), 2):\n            res += sort[i]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        # print(piles)\n        res = 0\n        tims = len(piles)//3\n        for i in range(1,len(piles)-tims,2):\n            res += piles[i]\n        return res \n        pass", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        res = 0\n        i = len(piles)-2\n        count = 1\n        while count<=len(piles)/3:\n            res +=piles[i]\n            i-=2\n            count+=1\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        print(piles)\n        sumval = 0\n        for i in range(1,len(piles)*2//3,2):\n            sumval += piles[i]\n        \n        return sumval", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        rounds = len(piles) // 3\n        count = 0\n        piles.sort(reverse=True)\n        for i in range(0, 2*rounds, 2):\n            count += piles[i+1]\n        return count\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        return sum(sorted(piles)[len(piles) // 3::2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        return sum(sorted(piles)[int(len(piles)/3)::2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles=sorted(piles)\n        ans=0\n        i=0\n        j=len(piles)-1\n        \n        while(i<j):\n            ans+=piles[j-1]\n            j-=2\n            i+=1\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        return sum(sorted(piles)[len(piles) // 3::2])\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        a=len(piles)//3\n        \n        i=0\n        k=1\n        piles.sort(reverse=True)\n        z=0\n        \n        while i<a:\n            z+=piles[k]\n            k=k+2\n            i=i+1\n        return z\n            \n            \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        i, j = 0, len(piles)-1\n        ans = 0\n        while i < j:\n            ans += piles[j-1]\n            i += 1\n            j -= 2\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        n = len(piles)\n        cost = 0\n        left = 0\n        right = n-1\n        for _ in range(n//3):\n            cost += piles[right-1]\n            left += 1\n            right -=2\n        return cost", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles, key=lambda x: -x)\n        total = 0\n        for i in range(0, len(piles) * 2 // 3, 2):\n            total += piles[i + 1]\n        return total", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        return sum(piles[1:(len(piles) // 3) * 2: 2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        n = len(piles)\n        s = 0\n        for i in range(n // 3):\n            s += piles[n-1-(2*i+1)]\n        return s\n", "class Solution:\n    def maxCoins(self, a):\n        a.sort()\n        n=len(a)\n        return sum(a[i] for i in range(n//3,n,2))", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        st = deque(piles)\n        mySum = 0\n        while len(st) > 0:\n            # print(st)\n            left = st.popleft()\n            right = st.pop()\n            urs = st.pop()\n            # print(left, urs, right)\n            mySum += urs\n            \n\n        # print(st)\n        return mySum", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if len(piles) < 3:\n            return 0\n        res = 0\n        piles.sort()\n        for i in range(1,len(piles)//3+1):\n            res = res + piles[(len(piles)) - (i*2)]  #((i*3)-i)]\n            \n        return res\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        coins = sorted(piles) \n        me = 0\n        \n        for piles in range(int(len(coins)/3), len(coins), 2):\n\n            me += coins[piles]\n            \n        return me\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = 1)\n        res = 0\n        rounds = len(piles)//3\n        for r in range(rounds):\n            res += piles[r*2 + 1]\n        return res", "\nclass Solution:\n  def maxCoins(self, piles: List[int]) -> int:\n    result = 0\n    piles.sort(reverse= True)\n\n    index = 1\n    counter = 0\n    while counter < len(piles) // 3:\n      result += piles[index]\n      index += 2\n      counter += 1\n\n    return result", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        count=0\n        i=len(piles)-2\n        res=0\n        take=len(piles)//3\n        while count != take: \n            res+=piles[i]\n            i-=2\n            count+=1\n        return(res)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        numOfTurns = int(len(piles) / 3)\n        meAndAlice = piles[numOfTurns:]\n        myTotal = 0 \n        for i in range(0, len(meAndAlice), 2):\n            myTotal += meAndAlice[i]\n        return myTotal ", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n\n        total = 0\n        for i in range(len(piles)-1, len(piles) // 3, -2):\n            total += piles[i-1]\n        return total\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # piles = sorted(piles)\n        # while piles:\n        #     piles.pop(-1)\n        #     res += piles.pop(-1)\n        #     piles.pop(0)\n        min_, max_ = min(piles), max(piles)\n        \n        cnt = [0 for i in range(min_, max_+1)]\n\n        res = []\n        v = 0\n        for i in range(len(piles)):\n            cnt[piles[i]-min_] += 1\n            \n        for i in range(len(cnt)):\n            while cnt[i] > 0:\n                res.append(i + min_)\n                cnt[i]-=1\n        res = res[::-1]\n        round_ = len(piles)//3\n        end = len(piles)-round_\n        for i in res[1:end:2]:\n            v+=i\n        \n        return v", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        ans=0\n        for i in range(int(len(piles)/3)):\n            ans=ans+piles[2*i+1]\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)\n        res = 0\n        for i in range(n // 3, n, 2):\n            res += piles[i]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        me, alice, bob = 0, 0, 0\n        i = 0\n        j = len(piles)-1\n        while i <j-1:\n            bob += piles[i]\n            i+=1\n            me+=piles[j-1]\n            alice+=piles[j]\n            j-=2\n        return me", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        #print(piles)\n        i = 0\n        start = 0\n        end = len(piles)-2\n        res = 0\n        while i<len(piles)//3:\n            res+=piles[end]\n            end-=2\n            i+=1\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = True)\n        res = 0\n        i = 1\n        for j in range(len(piles)//3):\n            res += piles[i]\n            i+=2\n        return res\n", "from functools import cmp_to_key\n\ndef cmp(a,b):\n    return b-a\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort(key=cmp_to_key(cmp))\n        \n        tot = 0\n        i = 1\n        N = len(piles)\n        n = int(N/3)\n        \n        for i in range(1,N-n+1,2):\n            tot += piles[i]\n        return tot\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ret = 0\n        left = 0\n        right = len(piles) - 1\n\n        \n        while (left < right):\n            ret += piles[right - 1]\n            left += 1\n            right -= 2\n            \n            \n        return ret\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        mine = 0\n        s = list(sorted(piles, reverse=True))\n        for i in range(len(s) // 3):\n            mine += s[2*i+1]\n        return mine\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # the same thing, but faster and more pythonic\n        piles.sort()\n        return sum(piles[int(len(piles) / 3): -1 : 2])\n        '''\n        # We want to pick two large numbers and one small number\n        our_coins = 0\n        our_piles = 0\n        l = len(piles)//3\n        piles.sort()\n        pointer = -2\n        while our_piles < l:\n            our_piles+=1\n            our_coins+=piles[pointer]\n            pointer-=2\n        return our_coins\n        '''", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)\n        piles.sort(reverse=True)\n        ans = 0\n        i = 1\n        \n        while i < n:\n            ans += piles[i]\n            i += 2\n            n -= 1\n            \n        return ans\n", "from collections import deque\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        coins = deque(sorted(piles, reverse=True))\n        share = 0\n        while coins:\n            coins.pop()\n            coins.popleft()\n            share+=coins.popleft()\n            \n        return share\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        sorted_piles = sorted(piles)\n        piles_len = len(sorted_piles)\n        start = int(piles_len / 3)\n        counter = 0\n        \n        for x in range(start, piles_len, 2):\n            \n            counter += sorted_piles[x]\n            \n        return counter", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        result = 0\n        # print(piles)\n        i = len(piles) - 2\n        while i >= int(len(piles) / 3):\n            result += piles[i]\n            i -= 2\n        return result\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        ans = 0\n        i = len(piles) - 2\n        c = 0\n        while c != len(piles)//3:\n            ans += piles[i]\n            i-=2\n            c+=1\n        return ans\n    # 1 2 2 4 7 8\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # We want to pick two large numbers and one small number\n        our_coins = 0\n        our_piles = 0\n        l = len(piles)//3\n        piles.sort()\n        pointer = -2\n        while our_piles < l:\n            our_piles+=1\n            our_coins+=piles[pointer]\n            pointer-=2\n        return our_coins\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        result = 0\n        piles.sort(reverse=True)\n        i = 0\n        j = len(piles) - 1\n        while i < j - 1:\n            result += piles[i + 1]\n            i += 2\n            j -= 1\n        return result", "from collections import deque\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        l = len(piles)\n        n = l//3\n        piles.sort()\n        \n        piles = deque(piles)\n        \n        ans = 0\n        while piles:\n            piles.pop()\n            ans += piles.pop()\n            piles.popleft()\n        \n        return ans\n            \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        total = 0\n        #[1,2,3,4,5,6,7,8,9]\n        for i in range(len(piles)-2, len(piles)//3-1, -2):\n            total += piles[i]\n            \n        return total", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        a=0;b=len(piles)-2;c=len(piles)-1\n        count=0\n        while a<len(piles) and b>0 and c>0 and a<b and a<c:\n            count+=piles[b]\n            a+=1\n            c-=2\n            b-=2\n        print(count)\n        return count\n            \n", "import heapq\n\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        heap = []\n        for p in piles:\n            heapq.heappush(heap, -p)\n                \n        for i in range(len(piles) // 3):\n            heapq.heappop(heap)\n            res += -heapq.heappop(heap)\n        \n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        i,j=0,len(piles)-2\n        ans=0\n        while(i<j):\n            ans+=piles[j]\n            j-=2\n            i+=1\n        return ans\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles) // 3\n        res = 0\n        for i in range(len(piles)-2, len(piles)-2-n*2, -2):\n            res += piles[i]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # Sort Piles, iterate loops over 3 and add middle num\n        # [1, 2, 2, 4, 7, 8] 7 + 2 = 9\n        # [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 + 5 + 8\n        # [9, 8, 1] [7, 6, 2] [5, 4, 3] 8 + 6 + 4\n        res = 0\n        x = 0\n        test = []\n        piles.sort()\n        for i in range(len(piles)-2, 0, -2):\n          if (x != len(piles)//3):\n            res += piles[i]\n            test.append(piles[i])\n            x += 1\n        print(test)\n        return res\n          \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        size = len(piles)\n        time = int(size /3)\n        i, ans = 0, 0\n        while i < time:\n            ans += piles[size-2 -(i*2)]\n            i+= 1\n            \n        return ans\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        p = sorted(piles)\n        n = len(piles)\n        \n        \n        res = 0\n        \n        l, r = 0, n - 1\n        \n        while l < r:\n            res += p[r - 1]\n            l += 1\n            r -= 2\n        \n        return res", "from typing import List\nfrom collections import deque\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if len(piles) == 0:\n            return 0\n        \n        piles.sort()\n        piles_deque = deque(piles)\n        my_take = 0\n\n        while len(piles_deque) >= 3:\n            alice_take = piles_deque.pop()\n            my_take += piles_deque.pop()\n\n            bob_take = piles_deque.popleft()\n        \n\n        return my_take", "from collections import deque\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = deque(sorted(piles))\n        my_coins = 0\n        while piles:\n            piles.pop()\n            piles.popleft()\n            my_coins += piles.pop()\n        return my_coins\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        return sum([piles[i] for i in range(len(piles) // 3, len(piles), 2)])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        n = len(piles)\n        \n        alice_and_me = []\n        max_piles = [-p for p in piles]\n        heapq.heapify(max_piles)\n        \n        out = 0\n        \n        seen = 0\n        \n        while seen != n//3:\n            alice = heapq.heappop(max_piles)\n            out -= heapq.heappop(max_piles)\n            seen += 1\n            \n        return out", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ret = 0\n        LEN = len(piles)\n        for i in range(LEN//3):\n            # print(i, LEN-(i*2+1),  piles[LEN-(i*2+1)] )\n            ret += piles[LEN-(i*2+2)]\n        return ret\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        l=len(piles)//3\n        piles.sort()\n        piles=piles[l:]\n        r=0\n        for m,i in enumerate(piles):\n            if m%2==0:\n                r+=i\n        return r", "import heapq\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        maxheap = []\n\n        for i in range(len(piles)):\n            heapq.heappush(maxheap,piles[i]*(-1))\n        \n        mine = 0\n        size = len(maxheap)\n        while size>0:\n            # pop and give the largest one for Alice\n            heapq.heappop(maxheap)\n            middle = heapq.heappop(maxheap)\n            middle *=(-1)\n            mine+=middle\n            size -=3\n        return mine", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        numRounds = len(piles) // 3\n        ret = 0\n        for i in range(len(piles) - 1, numRounds - 1, -2):\n            ret += min(piles[i], piles[i-1])\n        return ret", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        i = 0\n        j = len(piles) - 1\n        ans = 0\n        while i < j:\n            ans += piles[j - 1]\n            i += 1\n            j -= 2\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles=sorted(piles)\n        sum=0\n        for n in range(len(piles)//3,len(piles),2):\n            sum=sum+piles[n]\n        return(sum)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        i = 0\n        j = len(piles)-1\n        ans = 0\n        while i < j:\n            j -= 1\n            ans += piles[j]\n            j -= 1\n            i += 1\n        return ans\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        [8, 7, 4, 2, 2, 1]\n        n = len(piles)\n        if n <= 1:\n            return 0\n        \n        sorted_piles = sorted(piles, reverse=True)\n        print(sorted_piles)\n        s, e = 1, n-1\n        ans = 0\n        while s < e:\n            ans += sorted_piles[s]\n            s += 2\n            e -= 1\n        \n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        d = [0] * 10 ** 4\n        t = 0\n        total = 0\n\n        for p in piles:\n            d[p - 1] += 1\n            \n        for i in range(len(d)):\n            while d[i] > 0:\n                d[i] -= 1\n                if t >= len(piles) // 3 and t % 2 == ((len(piles) // 3) % 2):\n                    total += i + 1\n                t += 1\n\n\n        \n        return total        ", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        que = deque(sorted(piles)[::-1])\n        res = 0\n        while len(que) > 2:\n            que.popleft()\n            res += que.popleft()\n            que.pop()\n            \n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n=len(piles)//3\n        piles.sort(reverse=True)\n        count=0\n        j=1\n        for i in range(n):\n            count+=piles[j]\n            j+=2\n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        coins, turns, idx = 0, 0, 1\n        while turns < len(piles) // 3:\n            coins += piles[idx]\n            idx += 2\n            turns += 1\n        return coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if len(piles) == 3:\n            return piles[1]\n        print(len(piles)%2)\n        print(list((i, a) for i, a in enumerate(sorted(piles)[len(piles)//3:]) if i % 2 == len(piles)%2))\n        return sum(a for i, a in enumerate(sorted(piles)[len(piles)//3:]) if i % 2 == 0)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles.reverse()\n        count = 0\n        \n        i = 0\n        numTimes = 0      \n        while numTimes < len(piles) // 3: \n            count += piles[i+1]\n            i += 2\n            numTimes += 1\n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)     \n        return(sum(piles[1:int(len(piles)/3*2)+1:2]))", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)\n        t = 0\n        i , j = 0 , n-1\n        while i < j :\n            t+=piles[j - 1]\n            j-=2\n            i+=1\n        return t", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        d = [0] * 10 ** 4\n        t = 0\n        total = 0\n\n\n        for p in piles:\n            d[p - 1] += 1\n            \n        for i in range(len(d)):\n            while d[i] > 0:\n                d[i] -= 1\n                if t >= len(piles) // 3 and t % 2 == ((len(piles) // 3) % 2):\n                    total += i + 1\n                t += 1\n\n\n        \n        return total        ", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles.reverse()\n        l=len(piles)//3\n        p=len(piles)-l\n        s=sum([piles[i] for i in range(1,p, 2)])\n        return s", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        return sum(piles[int(len(piles)/3)::2])\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n\n        maxCoins = 0\n\n        count = len(piles)\n        while count > 0:\n            piles.pop(0)\n            maxCoins += piles.pop(-2)\n            piles.pop(-1)\n            count = len(piles)\n        return maxCoins", "class Solution:\n    def maxCoins(self, piles) :\n        choose = 0\n        piles = sorted(piles, reverse=True)\n        for i in range(len(piles)//3):\n            choose += piles[2*i+1] \n        return choose", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        return sum([piles[i] for i in range(len(piles)//3, len(piles), 2)])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        q= collections.deque(piles)\n        count=0\n        while len(q)>0:\n            q.popleft()\n            q.pop()\n            count+=q[-1]\n            q.pop()\n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        max_index = len(piles) - 2\n        result = 0\n        piles.sort()\n        \n        for _ in range(len(piles) // 3):\n            result += piles[max_index]\n            max_index -= 2\n        \n        return result", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        result = 0\n        for idx in range(1, 2 * len(piles) // 3 + 1,2):\n            result += piles[idx]\n        return result", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        s = 0\n        for i in range(0, len(piles), 2):\n            x = piles.pop()\n            try:\n                s += piles[i + 1]\n            except: \n                print('')\n        return s\n        \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = True)\n        n = len(piles)//3\n        i = 1\n        res = 0\n        while i<2*n:\n            res += piles[i]\n            i +=2\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)\n        result = 0\n        piles.sort(reverse=True)\n        for i in range(n//3):\n            result += piles[i * 2 + 1]\n            \n        return result", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n\n        triples = []\n\n        count = len(piles)\n        while count > 0:\n            newTrip = []\n            newTrip = [piles[0], piles[-2], piles[-1]]\n            triples.append(newTrip)\n            piles.pop(0)\n            piles.pop(-2)\n            piles.pop(-1)\n            count = len(piles)\n\n        maxCoins = 0\n        for i in range(len(triples)):\n            maxCoins += triples[i][1]\n        return maxCoins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        rounds = int(len(piles)/3)\n        max_el = 0\n        while rounds!=0:\n            piles.pop()\n            max_el+=piles[-1]\n            piles.pop()\n            piles.pop(0)\n            rounds-=1\n        return max_el\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        wallet = 0\n        while piles:\n            # Alices pile\n            piles.pop()\n            # My pile\n            wallet += piles.pop()\n            # Bob pile\n            del piles[0]\n        return wallet\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ret_num = 0\n        while piles:\n            piles.pop(0)\n            piles.pop()\n            ret_num += piles.pop()\n        return ret_num", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        my_coins = 0\n        piles = sorted(piles)\n        while piles:\n            del piles[0]\n            del piles[-1]\n            my_coins += piles[-1]\n            del piles[-1]\n        return my_coins\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        t = 0\n        while piles:\n            piles.pop()\n            t += piles.pop()\n            del piles[0]\n        return t", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if not piles:\n            return 0\n        \n        rounds = len(piles)//3\n        \n        max_heap = []\n        min_heap = []\n        \n        for n in piles:\n            heapq.heappush(max_heap, -n)\n            heapq.heappush(min_heap, n)\n        res = 0\n        \n        while rounds > 0:\n            rounds -= 1\n            \n            alex, me = -heapq.heappop(max_heap), -heapq.heappop(max_heap)\n            # bob = heapq.heappop(min_heap)\n\n            res += me\n            \n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        count = 0\n        piles.sort()\n        \n        while len(piles) > 0:\n            \n            #Alice's pick\n            piles.pop(-1)\n            \n            #My pick\n            count += piles[-1]\n            piles.pop(-1)\n            \n            #What Bob gets\n            piles.pop(0)\n        \n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        numCoins = 0\n        piles.sort()\n        \n        while len(piles) > 0:\n            # give alice\n            piles.pop()\n            # give me\n            numCoins += piles.pop()\n            # give bob\n            piles.pop(0)\n        \n        return numCoins\n            \n            \n            \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        \n        \n        a=0\n        y=0\n        b=0\n        \n        while(piles!=[]):\n            a=a+piles.pop()\n            y=y+piles.pop()\n            b=b+piles.pop(0)\n        \n        return y\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        res=0\n        while piles:\n            piles.pop()\n            res+=piles.pop()\n            piles.pop(0)\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        sums = 0\n        while piles:\n            m1, m2 = piles.pop(), piles.pop()\n            m3 = piles.pop(0)\n            sums += m2\n            \n        return sums", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        wallet = 0\n        while piles:\n            # Alices pile\n            piles.pop()\n            # My pile\n            wallet += piles.pop()\n            # Bob pile\n            del piles[0]\n        return wallet\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        result = 0\n        while len(piles)>0:\n            piles.pop()\n            result+=piles.pop()\n            piles.pop(len(piles)//3)\n        return result\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        count = 0\n        while piles:\n            piles.pop()\n            count += piles.pop()\n            piles.pop(0)\n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n=len(piles)\n        t=0\n        piles.sort()\n        for i in range(n//3-1):\n            t+=piles[-2]\n            piles.pop(0)\n            piles.pop(-1)\n            piles.pop(-2)\n        t+=piles[-2]\n        return t\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles, reverse = True)\n        num2 = len(piles)//3\n        piles = piles[:-num2]\n        print(piles)\n        return sum(el for i, el in enumerate(piles) if i%2==1)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        max_coins_for_me = 0\n        sorted_piles = sorted(piles)\n        while len(sorted_piles) > 0:\n            alice = sorted_piles.pop()\n            max_coins_for_me += sorted_piles.pop()\n            bob = sorted_piles.pop(0)\n        return max_coins_for_me", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_piles = sorted(piles)\n        res = 0\n        \n        while sorted_piles:\n            sorted_piles.pop()\n            res += sorted_piles.pop()\n            sorted_piles.pop(0)\n            \n        return res\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_piles = list(sorted(piles))\n        s = 0\n        while len(sorted_piles) > 3:\n            s += sorted_piles[-2]\n            sorted_piles.pop(0)\n            sorted_piles.pop(-2)\n            sorted_piles.pop(-1)\n        \n        s += sorted_piles[-2]\n        \n        return s\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_piles = sorted(piles)\n\n        your_total = 0\n\n        while sorted_piles:\n            sorted_piles.pop(0)\n            sorted_piles.pop(-1)\n            your_total += sorted_piles.pop(-1)\n\n        return your_total\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        coins = 0\n        sorted_piles = sorted(piles)\n   \n        while len(sorted_piles):\n            sorted_piles.pop()\n            coins += sorted_piles.pop()\n            sorted_piles.pop(0)\n            \n            \n        return coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        num_coins = 0\n        sorted_piles = list(sorted(piles))\n        while len(sorted_piles):\n            my_choice = sorted_piles[-2]\n            num_coins += my_choice\n            del sorted_piles[-2]\n            del sorted_piles[0]\n            del sorted_piles[-1]\n        return num_coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)/3\n        res = 0\n        p = sorted(piles)\n        #print(p)\n        for i in range(int(n)):\n            p.pop(-1)\n            p.pop(0)\n            res += p[-1]\n            p.pop(-1)\n            #print(p)\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        length = len(piles)\n        maxSum = 0\n        for i in range(int(length/3)):\n            maxSum += piles[-2]\n            piles.pop(-1)\n            piles.pop(-1)\n            piles.pop(0)\n        return maxSum\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)//3\n        return sum([piles[len(piles)-2-2*i] for i in range(0,n)])\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        s = len(piles)//3\n        n = len(piles)\n        i,j,k = 0,n-2,n-1\n        sumi = 0\n        while(s!=0):\n            sumi += piles[j] \n            j = j-2\n            s = s-1\n        \n        return sumi", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        wallet = 0\n        while piles:\n            piles.pop(-1)\n            wallet += piles.pop(-1)\n            piles.pop(0)\n        return wallet", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        mine = 0\n\n        while piles:\n            piles.pop(-1)\n            mine += piles.pop(-1)\n            piles.pop(0)\n\n        return mine", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        res = 0\n        while len(piles) != 0:\n            can = []\n            can.append(piles.pop())\n            can.append(piles.pop())\n            can.append(piles.pop(0))\n            \n            res += can[1]\n            can = []\n        return(res)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        newP = []\n        pileSort = sorted(piles)\n \n        while(len(pileSort)>0):\n            newP.append([pileSort[0], pileSort[-2], pileSort[-1]])\n            pileSort.pop(0)\n            pileSort.pop(-2)\n            pileSort.pop(-1)\n        \n        sum = 0 \n        \n        for i in newP:\n            sum += i[1]\n        \n        return sum\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        piles.sort()\n        while len(piles) > 0:\n            piles.pop(0)\n            piles.pop(-1)\n            res += piles.pop(-1)\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_piles = list(sorted(piles))\n        s = 0\n        while len(sorted_piles) > 3:\n            triplet = [sorted_piles.pop(0)] + [sorted_piles.pop(-2)] + [sorted_piles.pop(-1)]\n            s += triplet[1]\n        \n        triplet = [sorted_piles.pop(0)] + [sorted_piles.pop(-2)] + [sorted_piles.pop(-1)]\n        s += triplet[1]\n        \n        return s\n", "class Solution:\n    # O(nlgn) solution with O(1) space complexity\n    def maxCoins(self, piles: List[int]) -> int:\n        # First sort\n        piles.sort()\n        res = 0\n        while piles:\n            first = piles.pop(-1)\n            second = piles.pop(-1)\n            third = piles.pop(0)\n            res += second\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        mine = []\n        while piles:\n            _ = piles.pop()\n            _ = piles.pop(0)\n            mine.append(piles.pop())\n        return sum(mine)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        me=0\n        piles=sorted(piles)\n        # print(piles)\n        while(len(piles)>1):\n            temp=[piles[0]]+piles[-2:]\n            # print(temp)\n            piles.pop(0)\n            piles.pop(-1)\n            piles.pop(-1)\n            temp=sorted(temp)\n            me+=temp[1]\n        return me", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles, key=lambda x: -x)\n        ans, cnt = 0, 0\n        for i in range(1, len(piles), 2):\n            ans += piles[i]\n            cnt += 1\n            if cnt == len(piles) // 3:\n                break\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        out = 0\n        piles.sort()\n\n        while len(piles) >= 3:\n            piles.pop()\n            out += piles.pop()\n            piles.pop(0)\n        return out", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        # sort pile from least to greatest\n        sorted_piles = piles\n        sorted_piles.sort()\n        \n        max_coins = 0\n        num_groups = int(len(sorted_piles) / 3)\n        \n        for i in range(num_groups):\n            sorted_piles.pop(len(sorted_piles) - 1) # pop last element\n            sorted_piles.pop(0)                     # pop first element\n            your_coin = sorted_piles.pop(len(sorted_piles) - 1)\n            max_coins += your_coin\n            \n        return max_coins\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        count = 0\n        while len(piles) >0:\n            piles.pop(len(piles)-1)\n            piles.pop(0)\n            count = count + piles.pop(len(piles)-1)\n        return count\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ret = 0\n        while piles:\n            piles.pop()\n            ret += piles.pop()\n            piles.pop(0)\n        \n        return ret", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        \n        count_total = 0\n        \n        \n        while len(piles) > 0:\n            \n            max_el = piles.pop(-1)\n            #print(\\\"max_el is \\\" + str(max_el))\n            second_max_el = piles.pop(-1)\n            #print(\\\"second_max_el is \\\" + str(second_max_el))\n            min_el = piles.pop(0)\n            #print(\\\"min_el is \\\" + str(min_el))\n            \n            count_total += second_max_el\n            \n        \n        return count_total", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        mine = 0\n        while(len(piles)>0):\n            piles.pop()\n            mine += piles.pop()\n            piles.pop(0)\n        return mine", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        maxCoins=0\n        while len(piles)>0:\n            piles.pop()\n            maxCoins+=piles.pop()\n            piles.pop(0)\n        return maxCoins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_coins = sorted(piles)\n        print(sorted_coins)\n        \n        max_coins = 0\n        \n        while len(sorted_coins) > 0:\n            sorted_coins.pop(0)\n            sorted_coins.pop()\n            max_coins += sorted_coins.pop()\n            \n        return max_coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        def mergeSort(l):\n            if len(l) <2:\n                return l\n            pivot = l[0]\n            return mergeSort([x for x in l if x>pivot]) + [x for x in l if x==pivot]  + mergeSort([x for x in l if x<pivot]) \n        \n        sortedPiles = mergeSort(piles)\n        sumlimit = (2*len(piles))//3\n        sumind = list(range(1, sumlimit, 2))\n        return sum([sortedPiles[i] for i in sumind])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ans = 0\n        while len(piles) != 0:\n            piles.pop(0)\n            piles.pop(-1)\n            ans += piles.pop(-1)\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort(reverse = True)\n        print(piles)\n        p3n = len(piles)\n        n = int(p3n/3)\n        out = 0\n    \n        i = 1\n        while i < 2*n:\n            out += piles[i]\n            print((piles[i]))\n            i += 2\n        \n        return out\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ans = 0\n        piles.sort()\n        while len(piles) > 0: \n            alice = piles[len(piles)-1]\n            piles.pop()\n            ans += piles[len(piles)-1]\n            piles.pop()\n            bob = piles[0]\n            piles.pop(0)\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        piles.sort()\n        while len(piles) > 0:\n            piles.pop(len(piles)-1)\n            res+=piles[len(piles)-1]\n            piles.pop(len(piles)-1)\n            piles.pop(0)\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        return self.helper(piles)\n    \n    def helper(self, piles):\n        if not piles:\n            return 0\n        \n        mx = piles[-1]\n        mx2 = piles[-2]\n        mn = piles[0]\n        piles.pop(0)\n        piles.pop()\n        piles.pop()\n        return mx2 + self.helper(piles)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        \n        Count = 0\n        \n        while piles:\n            \n            Count += piles[-2]\n            piles.pop()\n            piles.pop()\n            piles.pop(0)\n            \n        return Count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        ans = 0\n        while piles:\n            big = piles.pop()\n            ans += piles.pop()\n            smol = piles.pop(0)\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        ans = 0\n        while len(piles) >=3:\n            bade_bahi = piles.pop()\n            mei_khud = piles.pop()\n            chutiya = piles.pop(0)\n            ans += mei_khud\n            #piles = piles[1:-2]\n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        \n        me = 0\n        piles.sort()\n        \n        while piles:\n            arr = []\n            arr += piles.pop(),\n            arr += piles.pop(),\n            arr += piles.pop(0),\n            arr.sort()\n            \n            me += arr.pop(1)\n            \n        return me\n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort();\n        answer = 0;\n        while len(piles) > 0:\n            largest = piles.pop();\n            almostLargest = piles.pop();\n            smallest = piles.pop(0);\n            answer += almostLargest;\n        return answer;", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        complete_sorted = sorted(piles)\n        result  = 0\n        while complete_sorted:\n            complete_sorted.pop()\n            result += complete_sorted.pop()\n            complete_sorted.pop(0)\n        return result", "from collections import deque\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ret = 0\n        \n        d = deque(sorted(piles))\n        \n        def draw(ds):\n            nonlocal ret\n            discard = ds.pop()\n            ret += ds.pop()\n            discard = ds.popleft()\n            \n            return ds\n            \n            \n        \n        while len(d) >= 3:\n            d = draw(d)\n            \n        return ret\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        res = 0;\n        while piles:\n            a = piles.pop()\n            b = piles.pop()\n            c = piles.pop(0)\n            res += b\n        return res \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        a=0\n        first,moke,myself=0,0,0\n        i=0\n        j=len(piles)-1\n        while(i<j):\n            first+=piles[j]\n            j-=1\n            myself+=piles[j]\n            j-=1\n            moke+=piles[i]\n            i+=1\n            \n        return myself", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n=len(piles)//3\n        piles.sort()\n        count=0\n        i=n\n        while i < len(piles):\n            count+=piles[i]\n            i+=2\n        return(count)\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        res,l,r = 0, 0, len(piles)-1\n        # round\n        while l < r:\n            l += 1\n            r -= 1\n            res += piles[r]\n            r -= 1\n        return res\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        count = 0\n        for i in range(len(piles) - 2, len(piles)//3 - 1, -2):\n            count += piles[i]\n        \n        # while piles:\n        #     piles.pop()\n        #     count += piles.pop()\n        #     piles.pop(0)\n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        wallet = 0\n        start = 0\n        end = len(piles) - 1\n        while start <= end:\n            # Bob pile\n            start += 1\n            # Alices pile\n            end -= 1\n            # My pile\n            wallet += piles[end]\n            end -= 1\n        return wallet\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        '''\n        Every time when I choose the best I can do is to get the 2nd largest pile among all\n        I also want to make sure Bob gets the smallest pile\n        '''\n        piles.sort(reverse=True)\n        ans = 0\n        for i in range(1, len(piles) // 3 + 1):\n            ans += piles[2*(i-1)+1]\n        return ans\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles=deque(piles)\n        res=0\n        while piles:\n            piles.pop()\n            res+=piles.pop()\n            piles.popleft()\n        \n        return res\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ans=0\n        queue=collections.deque()\n        piles.sort()\n        for ele in piles:\n            queue.append(ele)\n            \n        while len(queue):\n            queue.popleft()\n            queue.pop()\n            ans+=queue.pop()\n            \n        return ans", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        my_coins = 0\n\n        piles.sort()\n        count = len(piles)/3\n        i = 0\n        j = -2\n        k = -1\n        while count > 0:\n            my_coins += piles[j]\n            i += 1\n            j -= 2\n            k -= 2\n            count -= 1\n\n\n        return my_coins\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        ## solution 1: use sort\n        ## Time-O(nlogn) Space-O(n)\n        piles.sort(reverse=True)\n        return sum(piles[1:len(piles)//3*2:2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        asc = sorted(piles)\n        desc = sorted(piles,reverse=True)\n        \n        new = []\n        \n        for i in range(len(piles)//3):\n            new.append(asc.pop())\n            new.append(asc.pop())\n            new.append(desc.pop())\n        \n        return sum([new[i] for i in range(len(new)) if i%3==1])\n\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        return sum(sorted(piles)[-2:-2*(len(sorted(piles))//3)-1:-2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        sorted_ = (sorted(piles, key = lambda x: -x))\n        answer = 0\n        for i in range(len(sorted_) // 3):\n            answer += sorted_[2*i+1]\n        return answer", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)\n        piles.sort(reverse=True)\n        \n        \n\n        return sum(piles[1:2*n//3:2])\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = True)\n        n = len(piles) // 3\n        num = 0\n        for i in range(n):\n            num += piles[i * 2 + 1]\n        return num", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(key=lambda x : -x)\n        return sum(piles[1:len(piles)// 3 * 2:2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        return sum(piles[len(piles)//3:len(piles):2])\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        s_piles = sorted(piles)\n        my_coin_ct = 0\n        triplet_ct = len(s_piles) // 3\n        for i in range(triplet_ct, 0, -1):\n            my_coin_ct += s_piles[2 * (i - 1) + triplet_ct]\n        return my_coin_ct\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        res = 0\n        print(piles)\n        \n        for i in range(1, len(piles)-(len(piles)//3), 2):\n            print((piles[i]))\n            res+=piles[i]\n        \n        return res\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        res = 0\n        i = len(piles) - 2\n        for _ in range(len(piles) // 3):\n            res += piles[i]\n            i -= 2\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        me_max = 0\n        start = len(piles) - 2\n        for i in range(int(len(piles)/3)):\n            idx = start - (2 * i)\n            me_max += piles[idx]\n        return me_max\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        out = 0\n        count = 0\n        hi = len(piles)-1\n        lo = 0\n        while count < len(piles):\n            if count % 3 == 0:\n                hi -= 1\n            elif count % 3 == 1:\n                out += piles[hi]\n                hi -= 1\n            else:\n                lo += 1\n            count += 1\n        return out", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = collections.deque(sorted(piles)[::-1])\n        s = 0\n        while len(piles) > 0:\n            piles.popleft()\n            x = piles.popleft()\n            piles.pop()\n            s += x\n        return s", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        l=len(piles)\n        temp=2\n       \n        sum=0\n        for i in range(l//3):\n            sum=sum+piles[l-temp]\n            temp=temp+2\n        return sum", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ans=0\n        piles.sort()\n        n=len(piles)\n        for i in range(n-2, n//3-1, -2):\n            ans+=piles[i]\n            \n        return ans\n        \n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        print(piles)\n        n = len(piles)\n        s = 0\n        for i in range(n // 3):\n            print((n-1-(2*i+1)))\n            s += piles[n-1-(2*i+1)]\n        return s\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        \n        piles.sort()\n        piles = deque(piles)\n        \n        me = 0\n        while len(piles) > 2:\n            piles.pop()\n            me += piles.pop()\n            if piles:\n                piles.popleft()\n        \n        return me\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        heap = [-x for x in piles]\n        heapq.heapify(heap)\n        \n        rounds = count = 0\n        \n        while len(heap) > rounds:\n            _ = heapq.heappop(heap)\n            count -= heapq.heappop(heap)\n            rounds += 1\n        \n        return count", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if(not piles):\n            return 0\n        piles.sort()\n        coins=0\n        n=len(piles)\n        index=n-2\n        for i in range(n//3):\n            coins+=piles[index]\n            index-=2\n        return coins", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n=len(piles)//3\n        piles.sort()\n        piles=piles[n::2]\n        return sum(piles)\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        start = len(piles) - 1\n        end = 0\n        total = 0\n        while end < start:\n            total += piles[start - 1]\n            start -= 2\n            end += 1\n        \n        return total", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        me, alice, bob = len(piles)-2, 0, len(piles)\n        ans = 0\n        while alice < me:\n            ans += piles[me]\n            alice += 1\n            me -= 2\n            bob -= 2\n        return ans\n            \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True) \n        ans=0\n        for i in range(1,2*(len(piles)//3),2):\n            ans+=piles[i] \n        return ans\n", "class Solution:\n    def maxCoins(self, piles):\n        piles.sort(reverse=True)     \n        return(sum(piles[1:int(len(piles)/3*2)+1:2]))", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        return sum(piles[1:int(len(piles)/3*2):2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        count1=int(len(piles)/3)\n        sum1=0\n        j=0\n        while(count1<len(piles)):\n            print(j,count1)\n            if j%2==0:\n                print(piles[count1])\n                sum1=sum1+piles[count1]\n            count1=count1+1\n            j=j+1\n        return sum1", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ans=0\n        piles.sort()\n        i=len(piles)-2\n        j=0\n        while(i>=j):\n            ans=ans+piles[i]\n            i=i-2\n            j=j+1\n        return ans\n        # 1 2 3 4 5 6 7 8 9\n        # 9 8 1\n        # 7 6 2\n        # 5 4 3\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse = True)\n        return sum(piles[1:2*len(piles)//3:2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles,reverse = True)\n        ans = []\n        for i in range(0,len(piles)//3 * 2,2  ):\n            ans.append(piles[i + 1])\n            #print(i + 1)\n        return sum(ans)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        count = 0\n        coinPiles = collections.deque(sorted(piles))\n        while len(coinPiles)>0:\n                coinPiles.pop()\n                count += coinPiles.pop()\n                coinPiles.popleft()\n        return count\n", "class Solution:\n    from collections import deque\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)//3\n        s=0\n        for i in range(n,n*3,2):\n            s += piles[i]\n        return s\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        steps = int(len(piles)/3)\n        piles = sorted(piles)\n        \n        return sum(piles[steps::2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        length = len(piles)\n        sorted_piles = sorted(piles, reverse = True)\n        if length == 3:\n            return sorted_piles[1]\n        n = length / 3\n        count, res = 0, 0\n        for i in range(1, length, 2):\n            if count == n:\n                return res\n            res += sorted_piles[i]\n            count += 1", "import heapq\n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        max_coins_for_me = 0\n        sorted_piles = sorted(piles)\n        top = len(piles) - 1\n        for i in range(len(piles) // 3):\n            max_coins_for_me += sorted_piles[top-1]\n            top = top - 2\n        return max_coins_for_me", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        res=0\n        alice, me, bob = 0, 1, -1\n        while me<len(piles)+bob:\n            res+=piles[me]\n            alice+=2\n            me+=2\n            bob-=1\n        return res", "import heapq\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        piles = piles[len(piles)//3:]\n        me = 0\n        for i in range(len(piles)-2,-1,-2):\n            me+=piles[i]\n            \n        return me", "class Solution:\n    def maxCoins(self, p: List[int]) -> int:\n        p.sort()\n        max_coins=0\n        i=len(p)//3\n        while i<len(p):\n            max_coins+=p[i]\n            i+=2\n        return max_coins\n            \n", "from heapq import heappop, heappush, heapify \n\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles)\n        i, j = 0, 0\n        ans = 0\n        while i + j < len(piles) - 1:\n            i += 1\n            j += 2\n            ans += piles[-j]\n        return ans\n            \n        \n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)//3;\n        mc = 0\n        piles.sort(reverse=True)\n        print(piles)\n        for i in range(0,n):\n            mc += piles[1 + 2*i]\n        return mc\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        you = []\n        l = int((len(piles)/3))\n        piles.sort()\n        piles = piles[l:]\n        for i in range(len(piles)):\n            if i%2 == 0:\n                you.append(piles[i])\n        return sum(you)", "class Solution(object):\n    def maxCoins(self, piles):\n        piles = collections.deque(sorted(piles)[::-1])\n        s = 0\n        while len(piles) > 0:\n            piles.popleft()\n            x = piles.popleft()\n            piles.pop()\n            \n            s += x\n            \n        return s", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        n = len(piles)/3\n        piles.sort()\n        res = []\n        for i in range(2, 2*int(n)+1, 2):\n            res.append(piles[-i])\n        return sum(res)", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n\n        total = 0\n        n = len(piles) // 3\n        m = len(piles)-1\n        for i in range(m, n, -2):\n            total += piles[i-1]\n        return total\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        c = 0 \n        for x in range(len(piles)//3, len(piles), 2):\n            c += piles[x]\n\n        return c", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        l_i, r_i = 0, len(piles)-1\n        max_coin = 0\n        while l_i < r_i:\n            max_coin += piles[r_i-1]\n            l_i += 1\n            r_i -= 2\n        return max_coin\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        return sum(sorted(piles)[len(piles)//3::2])", "class Solution:\n    from collections import deque\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)//3\n        return sum([piles[i] for i in range(n,n*3,2)])\n            \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        count=0\n        piles.sort()\n        l=len(piles)\n        n=l//3\n        j=l-2\n        k=0\n        while(k<n):\n            count=count+piles[j]\n            j=j-2\n            k=k+1\n        return count    \n", "from collections import deque\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles = deque(piles)\n        total = 0\n        ptr1, ptr2 = len(piles) - 2, 0\n        while ptr2 < ptr1:\n            total += piles[ptr1]\n            ptr1 -= 2\n            ptr2 += 1\n        return total        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles = sorted(piles,reverse = True)\n        res = 0\n        n= len(piles)\n        n = n//3\n        for i in range(1,2*n,2):\n            res += piles[i]\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        myNum = 0\n        piles.sort(reverse=True)\n        for i in range(1, len(piles) *2//3 +1, 2):\n            myNum += piles[i]\n            print(myNum)\n        return myNum       ", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        n = len(piles)\n        ret = 0\n        for i in range(int(n/3)):\n            ret += piles[2*i+1]\n            \n        return ret", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        p = piles[len(piles)-2::-2]\n        return sum(p[:len(piles)//3])", "class Solution:\n    def maxCoins(self, piles):\n        piles.sort()\n        end = len(piles) - 2\n        start = 0\n        count = 0\n        while start < end:\n            count += piles[end]\n            end -= 2\n            start += 1\n        return count\n", "# brute force\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        piles.sort(reverse = 1)\n        for i in range(0, (len(piles) // 3) * 2, 2):\n            res += piles[i + 1]\n        return res", "# brute force\nclass Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        res = 0\n        piles.sort(reverse = 1)\n        for i in range(0, (len(piles) // 3) * 2, 2):\n            res += piles[i + 1]\n            print(res)\n        return res", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        piles.sort()\n        piles = piles[::-1]\n        return sum(piles[x] for x in range(1, 2 * len(piles) // 3, 2))\n        \n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        if len(piles) == 3:\n            return piles[1]\n        # print(len(piles)%2)\n        # print(list((i, a) for i, a in enumerate(sorted(piles)[len(piles)//3:]) if i % 2 == len(piles)%2))\n        return sum(a for a in sorted(piles)[len(piles)//3::2])", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        def dps():\n            \n            def remove_from_first(T, s):\n                assert(len(s) == 3)\n                L = list(T)\n                for x in s:\n                    if x in L:\n                        L.remove(x)\n                return tuple(L)\n            \n            from itertools import combinations\n            from functools import lru_cache\n            @lru_cache(None)\n            def dp(T):\n                if len(T) == 0: return 0\n                if len(T) == 3: return sum(T) - max(T) - min(T)\n\n                mxl = 0\n                for cm in combinations(T, 3):\n                    S = remove_from_first(T, cm)\n                    mxl = max(mxl, dp(S) + sum(cm) - max(cm) - min(cm))\n                return mxl\n            \n            return dp(tuple(piles))\n        # return dps()\n\n        # def bu_dp():\n        \n        def iter_appr():\n            assert(len(piles)%3==0)\n            maxheap, minheap = [], []\n            counter = 0\n            from heapq import heappush, heappop\n            for x in piles:\n                heappush(maxheap, -x)\n                heappush(minheap, x)\n                \n            alice, me, bob = 0, 0, 0\n            while maxheap and minheap and counter < len(piles):\n                alice += -heappop(maxheap)\n                me += -heappop(maxheap)\n                bob += heappop(minheap)\n                counter += 3\n            return me\n        return iter_appr()\n", "class Solution:\n    def maxCoins(self, piles: List[int]) -> int:\n        ans = 0\n        piles.sort(reverse = True)\n        for i in range(len(piles)//3):\n            ans  += piles[i*2+1]\n        return ans\n            \n"]
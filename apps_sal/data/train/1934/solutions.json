["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         \n         res = []\n         level_num = 1\n         level = [root]\n         \n \n         while len(level) != 0:\n             level_size = len(level)\n             level_res = [None]*level_size\n             for i in range(level_size):\n                 curr = level.pop(0)\n                 level_res[i] = curr.val\n                 if curr.left is not None:\n                     level.append(curr.left)\n                 if curr.right is not None:\n                     level.append(curr.right)\n             if level_num % 2:\n                 res.append(level_res)\n             else:\n                 level_res.reverse()\n                 res.append(level_res)\n             level_num += 1\n             \n         return res\n         \n         \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         from collections import deque\n         mydeque = deque()\n         ret = []\n         if root == None:\n             return []\n         mydeque.append(root)\n         reverseflag = False\n         while len(mydeque) != 0:\n             curlist = []\n             newdeque = deque()\n             width = len(mydeque)\n             for _ in range(0, width):\n                 node = mydeque.pop()\n                 if reverseflag:\n                     node.left, node.right = node.right, node.left\n                 curlist.append(node.val)\n                 if node.left != None:\n                     newdeque.append(node.left)\n                 if node.right != None:\n                     newdeque.append(node.right)\n             mydeque = newdeque\n             ret.append(curlist)\n             reverseflag = not reverseflag\n         return ret", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         l = [root]\n         r = False\n         ret = []\n         \n         while l:\n             values = [node.val for node in l]\n             if r:\n                 values.reverse()\n             ret.append(values)\n             tmp = []\n             for node in l:\n                 if node.left:\n                     tmp.append(node.left)\n                 if node.right:\n                     tmp.append(node.right)\n             l = tmp\n             r = not r\n             \n         return ret", "class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root == None:\n             return []\n         result = []\n         queue = []\n         queue.append([0, root])\n         while len(queue) != 0:\n             level, temp = queue.pop(0)\n             if len(result) < level + 1:\n                 result.append([])\n             if level % 2 == 0:\n                 result[level].append(temp.val)\n             else:\n                 result[level].insert(0, temp.val)\n             if temp.left:\n                 queue.append([level+1, temp.left])\n             if temp.right:\n                 queue.append([level+1, temp.right])\n         return result", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         l = [root]\n         r = False\n         ret = []\n         \n         while l:\n             values = [node.val for node in l]\n             if r:\n                 values.reverse()\n             ret.append(values)\n             tmp = []\n             for node in l:\n                 if node.left:\n                     tmp.append(node.left)\n                 if node.right:\n                     tmp.append(node.right)\n             l = tmp\n             r = not r\n             \n         return ret", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from collections import deque\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         q, d, tmp, ret = deque([]), deque([]),[], []\n         q.append(root)\n         flag = 1\n         while(q or d):\n             node = q.popleft()\n \n             if node: tmp.append(node.val)\n             if node.left: d.append(node.left)\n             if node.right: d.append(node.right)\n             if not len(q):\n                 ret.append(tmp[::flag])\n                 q = d\n                 d = deque([])\n                 tmp = []\n                 flag = -flag\n             \n         return ret\n                 ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from collections import defaultdict\n from queue import Queue\n \n class Solution:\n   def zigzagLevelOrder(self, root):\n     \"\"\"\n     :type root: TreeNode\n     :rtype: List[List[int]]\n     \"\"\"\n     if not root:\n       return []\n     node_level = {root: 0}\n     level_nodes = defaultdict(lambda: [])\n     # Group nodes by level in BFS order\n     q = Queue()\n     q.put(root)\n     level_nodes[0].append(root)\n     while not q.empty():\n       node = q.get()\n       child_level = node_level[node] + 1\n       if node.left:\n         node_level[node.left] = child_level\n         level_nodes[child_level].append(node.left)\n         q.put(node.left)\n       if node.right:\n         node_level[node.right] = child_level\n         level_nodes[child_level].append(node.right)\n         q.put(node.right)\n     # Go through nodes level by level\n     level_nodes_pairs = sorted(list(level_nodes.items()))\n     result = []\n     for (level, nodes) in level_nodes_pairs:\n       if level % 2 == 0:\n         # Left to right\n         result.append([node.val for node in nodes])\n       else:\n         # Right to left\n         result.append([node.val for node in reversed(nodes)])\n     return result\n     \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import queue\n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root == None:\n             return []\n         bfs = queue.Queue()\n         ret = []\n         flag = 0\n         bfs.put(root)\n         \n         while(bfs.empty()==False):\n             cur_list = []\n             bfs_len = bfs.qsize()\n             for i in range(bfs_len):\n                 cur = bfs.get()\n                 if cur.left != None:\n                     bfs.put(cur.left)\n                 if cur.right != None:\n                     bfs.put(cur.right)\n                 cur_list.append(cur.val)\n             if flag == 1:\n                 cur_list.reverse()\n                 flag = 0\n             else:\n                 flag = 1\n             ret.append(cur_list)\n         return ret\n                 \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n from copy import deepcopy\n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         left2rightq = [root]\n         right2leftq = []\n         result = []\n         while left2rightq or right2leftq:\n             if left2rightq:\n                 line = []\n                 while left2rightq:\n                     tmp = left2rightq.pop(-1)\n                     line.append(tmp.val)\n                     if tmp.left:\n                         right2leftq.append(tmp.left)\n                     if tmp.right:\n                         right2leftq.append(tmp.right)\n                     else:\n                         pass\n                 result.append(line)\n             else:\n                 line = []\n                 while right2leftq:\n                     tmp = right2leftq.pop()\n                     line.append(tmp.val)\n                     if tmp.right:\n                         left2rightq.append(tmp.right)\n                     if tmp.left:\n                         left2rightq.append(tmp.left)\n \n                     else:\n                         pass\n                 result.append(line)\n         return result\n                 \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import queue\n class Solution:\n     # # \u7528\u4e24\u4e2a\u6808\n     # def zigzagLevelOrder(self, root):\n     #     \"\"\"\n     #     :type root: TreeNode\n     #     :rtype: List[List[int]]\n     #     \"\"\"\n     #     if (root is None):\n     #         return []\n     #     s1, s2 = [], []\n     #     res = []\n     #     level = []\n     #     s1.append(root)\n     #     deal_s1 = True\n     #     while (s1 or s2):\n     #         # \u4e0b\u9762\u4e00\u884c\u4e0d\u80fd\u5199\u6210if(s1)\uff0c\u56e0\u4e3a\u5728\u5904\u7406s2\u65f6\uff0c\u4f1a\u5411s1\u4e2d\u538b\u6570\u636e\n     #         if (deal_s1):\n     #             cur = s1.pop()\n     #             level.append(cur.val)\n     #             if (cur.left is not None):\n     #                 s2.append(cur.left)\n     #             if (cur.right is not None):\n     #                 s2.append(cur.right)\n     #             if (not s1):\n     #                 res.append(level[:])\n     #                 level = []\n     #                 deal_s1 = False\n     #         else:\n     #             cur = s2.pop()\n     #             level.append(cur.val)\n     #             if (cur.right is not None):\n     #                 s1.append(cur.right)\n     #             if (cur.left is not None):\n     #                 s1.append(cur.left)\n     #             if (not s2):\n     #                 res.append(level[:])\n     #                 level = []\n     #                 deal_s1 = True\n     #     return res\n                 \n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if (root is None):\n             return []\n         res = []\n         level = []\n         q = queue.Queue()\n         q.put(root)\n         q.put(None)\n         reverse = 1\n         while (not q.empty()):\n             cur = q.get()\n             if (cur is None):\n                 res.append(level[::reverse])\n                 level = []\n                 reverse *= -1\n                 if (not q.empty()):\n                     q.put(None)\n             else:\n                 level.append(cur.val)\n                 if (cur.left is not None):\n                     q.put(cur.left)\n                 if (cur.right is not None):\n                     q.put(cur.right)\n         return res\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if root is None:\n             return []\n         result = []\n         current = [root]\n         clevel=1\n         while current:\n             next_level = []\n             vals = []\n             for node in current:\n                 vals.append(node.val)\n                 if node.left:\n                     next_level.append(node.left)\n                 if node.right:\n                     next_level.append(node.right)\n                     \n             if (clevel%2):\n                 result.append(vals)\n             else:\n                 result.append(vals[::-1])\n             clevel+=1\n             current = next_level\n         return result\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def zigzagLevelOrder(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: List[List[int]]\n         \"\"\"\n         if not root:\n             return []\n         \n         cur_level,levelOrder,level=[root],[],1\n         while cur_level:\n             next_level,vals=[],[]\n             for node in cur_level:\n                 vals.append(node.val)\n                 if node.left:\n                     next_level.append(node.left)\n                 if node.right:\n                     next_level.append(node.right)\n             if level%2==1:\n                 levelOrder.append(vals)\n             else:\n                 levelOrder.append(vals[::-1])\n             level+=1\n             cur_level=next_level\n         return levelOrder"]
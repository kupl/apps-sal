["import sys\nstdin=sys.stdin\n\nip=lambda: int(sp())\nfp=lambda: float(sp())\nlp=lambda:list(map(int,stdin.readline().split()))\nsp=lambda:stdin.readline().rstrip()\nyp=lambda:print('Yes')\nnp=lambda:print('No')\n\nn,a,b=lp()\nx=lp()\nans=0\nfor i in range(n-1):\n  ans+=min(b,a*(x[i+1]-x[i]))\nprint(ans)", "n, a, b, *X = map(int, open(0).read().split())\nc = 0\nfor x0, x1 in zip(X, X[1:]):\n    c += min(a*(x1-x0), b)\nprint(c)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, N):\n    ans += min(A * (X[i] - X[i - 1]), B)\nprint(ans)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\n\nans = B * (N-1)\ntmp = 0\nfor i in range(N-1):\n    tmp += min(A*(X[i+1] - X[i]), B)\nans = min(ans, tmp)\nprint(ans)", "n, a, b = list(map(int, input().split()))\nxlist = list(map(int, input().split()))\n\nans = 0\nfor i in range(n-1):\n    ans += min((xlist[i+1]-xlist[i])*a, b)\n\nprint(ans)\n", "import sys\ninput = sys.stdin.readline\n\nN, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nans = 0\nfor i in range(N - 1):\n    ans += min((X[i+1] - X[i]) * A, B)\nprint(ans)", "def main():\n    N, A, B = map(int, input().split())\n    X = list(map(int, input().split()))\n    dp = [float('inf')] * (N + 5)\n    dp[0] = 0\n    for i in range(1,N):\n        dp[i] = dp[i-1] + min((X[i] - X[i-1]) * A, B)\n\n    print(dp[N-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "n, a, b = map(int, input().split())\nxx = list(map(int, input().split()))\ntired = 0\nfor i in range(n-1):\n  if (xx[i+1]-xx[i])*a < b: \n    tired += (xx[i+1]-xx[i])*a\n  else:\n    tired += b\n\nprint(tired)", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\n\nnow = x[0]\nfatigue = 0\nfor v in x:\n    if a * (v - now) < b:\n        fatigue += a * (v - now)\n    else:\n        fatigue += b\n    now = v\n\nprint(fatigue)", "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,a,b = list(map(int, input().split()))\nx = list(map(int, input().split()))\nans = 0\nfor i in range(n-1):\n    if (x[i+1] - x[i])*a > b:\n        ans += b\n    else:\n        ans += (x[i+1] - x[i])*a\nprint(ans)", "n, a, b = map(int,input().split())\nX = list(map(int,input().split()))\n\ndist = []\nfor i in range(n-1):\n    dist.append(X[i+1]-X[i])\n    \nans = 0\nfor d in dist:\n    if d*a > b:\n        ans += b\n    else:\n        ans += d*a\n\nprint(ans)", "ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(map(int, input().split()))\n\nN, A, B = mi()\nX = li()\nans = 0\nnow = X[0]\nfor x in X[1:]:\n    if (x-now)*A > B:\n        ans += B\n    else:\n        ans += (x-now)*A\n    now = x\nprint(ans)", "N,A,B=map(int,input().split())\nX=list(map(int,input().split()))\ndp = 0\nfor i in range(1, N):\n  if A*(X[i]-X[i-1]) < B:\n    dp += A*(X[i]-X[i-1])\n  else:\n    dp += B\nprint(dp)", "N , A , B = map(int,input().split())\nX = list(map(int,input().split()))\nn0 = B//A\nS = 0\nfor i in range(N-1):\n  if X[i+1] - X[i] <= n0:\n    S += (X[i+1] - X[i])*A\n  else:\n    S += B\n\nprint(S)", "N,A,B = list(map(int,input().split()))\nX = list(map(int,input().split()))\nX.sort()\n\nans = 0\n\nfor i in range(1,N):\n    ans += min((X[i]-X[i-1])*A,B)\nprint(ans)\n", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom fractions import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n#mod = 9982443453\n#mod = 998244353\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n  return int(readline())\nn,a,b = readInts()\nX = readInts()\nans = 0\nfor i in range(1,n):\n    ans += min(b, (X[i]-X[i-1])*a)\nprint(ans)\n", "n,a,b,*X=map(int,open(0).read().split());print(sum(min(a*(X[i+1]-X[i]),b)for i in range(n-1)))", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\nx = [(x[i] - x[i-1])*a for i in range(1, n)]\nres = 0\nfor xi in x:\n    if xi > b:\n        res += b\n    else:\n        res += xi\nprint(res)", "def main():\n    N, A, B = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(N - 1):\n        length = X[i + 1] - X[i]\n        ans += min(length * A, B)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, a, b = map(int,input().split())\nx = list(map(int,input().split()))\n\ndp = [float('inf')]*n \ndp[0] = 0\nfor i in range(n-1):\n    dp[i+1] = dp[i] + min((x[i+1] - x[i])*a, b)\n\nprint(dp[-1])", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\nans = 0\nfor i in range(1, n): ans+=min((x[i]-x[i-1])*a, b)\nprint(ans)", "n,a,b=map(int,input().split())\nx=list(map(int,input().split()))\n\nkirikawari=int(b//a)\n\nans=0\nfor i in range(n-1):\n    sa=x[i+1]-x[i]\n    if sa<=kirikawari:\n        ans+=sa*a\n    else:\n        ans+=b\n\nprint(ans)    ", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nans = 0\nfor i in range(N-1):\n    if (X[i+1]-X[i])*A <=B:\n        ans += (X[i+1]-X[i])*A\n    else:\n        ans += B\n\nprint(ans)", "def main():\n    N, A, B = map(int, input().split())\n    X = list(map(int, input().split()))\n \n    cost = 0\n    for i in range(N-1):\n        distance = abs(X[i] - X[i+1])\n        if distance * A < B:\n            cost += distance * A\n        else:\n            cost += B\n    print(cost)\n \ndef __starting_point():\n    main()\n__starting_point()", "N, A, B = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ncost = 0\n\nx_prev = X[0]\nfor x_next in X[1:]:\n    walk_cost = A*(x_next-x_prev)\n    tele_cost = B\n    cost += min(walk_cost, tele_cost)\n\n    x_prev= x_next\nprint(cost)\n\n\n", "n, a, b = [int(i) for i in input().split()]\nx = [int(i) for i in input().split()]\n\nans = 0\ntmp = x[0]\n\nfor i in x[1:]:\n    ans += min((i - tmp) * a, b)\n    tmp = i\n\nprint(ans)", "n, a, b = list(map(int, input().split()))\nxs = list(map(int, input().split()))\n\nans = sum([min((xs[i] - xs[i - 1]) * a, b) for i in range(1, n)])\nprint(ans)\n", "def LI():\n    return list(map(int, input().split()))\n\n\nN, A, B = LI()\nX = LI()\nans = 0\nfor i in range(N-1):\n    ans += min((X[i+1]-X[i])*A, B)\nprint(ans)", "N,A,B=map(int,input().split())\nX=[int(x) for x in input().split()]\nans=0\nnow=X[0]\nfor i in range(1,N):\n    next=X[i]\n    walk=(next-now)*A\n    ans+=min(B,walk)\n    now=next\nprint(ans)", "n,A,B = map(int, input().split())\nx = list(map(int, input().split()))\n\nif A >= B:\n    ans = B*(n-1)\nelse:\n    ans = 0\n    for i in range(n-1):\n        a = x[i+1]-x[i]\n        ans += min(a*A, B)\nprint(ans)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nsx = sorted(X)\nans = 0\nfor i in range(N-1):\n  d = sx[i+1]-sx[i]\n  if d*A < B:\n    ans += d*A\n  else:\n    ans += B\nprint(ans)", "n, a, b = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, n):\n  d = x[i] - x[i - 1]\n  if d * a < b:\n    ans += d * a\n  else:\n    ans += b\n    \nprint(ans)\n", "N,A,B = map(int,input().split())\nX = list(map(int,input().split()))\ncost = 0\nfor i in range(N-1):\n    cost += min((X[i+1]-X[i])*A,B)\nprint(cost)", "N,A,B = list(map(int,input().split()))\nX = list(map(int,input().split()))\n\nans = 0\nfor i in range(1,N):\n  d = X[i] - X[i-1]\n  ans += min(d * A, B)\n  \nprint(ans)\n", "N, A, B = [int(x) for x in input().split()]\nX = [int(x) for x in input().split()]\nans = 0\nfor i in range(N - 1):\n    ans += min((X[i + 1] - X[i]) * A, B)\nprint(ans)\n", "N,A,B = map(int,input().split())\nX = list(map(int,input().split()))\n\nans = 0\nfor i in range(N-1):\n    if (X[i+1] - X[i]) * A <= B:\n        ans += (X[i+1] - X[i]) * A\n    else:\n        ans += B\n\nprint(ans)", "N, A, B = map(int, input().split())\n\nX = list(map(int, input().split()))\nans = 0\nfor i in range(1, N):\n  dist = X[i] - X[i-1]\n  ans += min(A*dist , B)\n\nprint(ans)", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nN,A,B = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\n\n# In[2]:\n\n\nc = 0\nfor i in range(N-1):\n    dist = X[i+1] - X[i]\n    if dist*A > B:\n        c += B\n    else:\n        c += dist*A\nprint(c)\n\n\n# In[ ]:\n\n\n\n\n", "n,a,b=map(int,input().split())\nx=list(map(int,input().split()))\nans=0\nfor i in range(n-1):\n    ans+=min((x[i+1]-x[i])*a,b)\nprint(ans)", "import sys\n\n\ndef IN_I(): return int(sys.stdin.readline().rstrip())\ndef IN_LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef IN_S(): return sys.stdin.readline().rstrip()\ndef IN_LS(): return list(sys.stdin.readline().rstrip().split())\nINF = float('inf')\nMOD = 10**9 + 7\n\n\nN, A, B = IN_LI()\nX = IN_LI()\n\nans = 0\nfor i in range(N-1):\n    d = X[i+1] - X[i]\n    if A*d >= B:\n        ans += B\n    else:\n        ans += A*d\nprint(ans)\n", "n,a,b=map(int,input().split())\nlst=list(map(int,input().split()))\n\npin=lst[0]\nans=0\n\nfor i in range(1,n):\n  ans+=min((lst[i]-lst[i-1])*a,b)\n  \nprint(ans)", "n,a,b=list(map(int,input().split()))\nx=list(map(int,input().split()))\nans=0\nfor i in range(n-1):\n    costa=(x[i+1]-x[i])*a\n    ans+=min(b,costa)\nprint(ans)\n", "n, a, b = map(int, input().split())\nx_seq = list(map(int, input().split()))\n\nans = 0\nfor i in range(n-1):\n    dis = x_seq[i+1] - x_seq[i]\n    ans += min(dis*a, b)\nprint(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    N, A, B = MI()\n    X = LI()\n    ans = 0\n    for i in range(N-1):\n        ans += min(A * (X[i+1]-X[i]), B)\n    print(ans)\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "def main():\n    #input data\n    import sys\n    input = lambda:sys.stdin.readline().strip()\n    n,a,b = map(int,input().split())\n    x = list(map(int,input().split()))\n   \n    #solve\n    ans = 0\n    for i in range(n-1):\n        if (x[i+1]-x[i])*a>b:\n            ans+=b\n        else:\n            ans+=(x[i+1]-x[i])*a\n    print(ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nprint(sum(min((X[i+1]-X[i])*A, B) for i in range(N-1)))", "\ndef resolve():\n    N, A, B = map(int, input().split())\n    X = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(N - 1):\n        res = min((X[i + 1] - X[i]) * A, B)\n        ans += res\n        \n    print(ans)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "N, A, B = map(int, input().split())\nL = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range (1, N):\n\tp = L[i]-L[i-1]\n\tif A*p >= B:\n\t\tcount+=B\n\telse:\n\t\tcount+=A*p\n\nprint(count)", "N,A,B=map(int,input().split())\nX=list(map(int,input().split()))\nans=0\nfor i in range(1,N):\n    if A*(X[i]-X[i-1])>=B:\n        ans+=B\n    else:\n        ans+=A*(X[i]-X[i-1])\nprint(ans)", "import sys\nfrom collections import deque\nfrom copy import deepcopy\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom heapq import heapify, heappop, heappush\nfrom itertools import product, permutations, combinations, combinations_with_replacement\nfrom functools import reduce\nfrom math import gcd, sin, cos, tan, asin, acos, atan, degrees, radians\n\nsys.setrecursionlimit(10**6)\nINF = 10**20\neps = 1.0e-20\nMOD = 10**9+7\n\ndef lcm(x,y):\n    return x*y//gcd(x,y)\ndef lgcd(l):\n    return reduce(gcd,l)\ndef llcm(l):\n    return reduce(lcm,l)\ndef powmod(n,i,mod):\n    return pow(n,mod-1+i,mod) if i<0 else pow(n,i,mod)\ndef div2(x):\n    return x.bit_length()\ndef div10(x):\n    return len(str(x))-(x==0)\ndef intput():\n    return int(input())\ndef mint():\n    return map(int,input().split())\ndef lint():\n    return list(map(int,input().split()))\ndef ilint():\n    return int(input()), list(map(int,input().split()))\ndef judge(x, l=['Yes', 'No']):\n    print(l[0] if x else l[1])\ndef lprint(l, sep='\\n'):\n    for x in l:\n        print(x, end=sep)\ndef ston(c, c0='a'):\n    return ord(c)-ord(c0)\ndef ntos(x, c0='a'):\n    return chr(x+ord(c0))\nclass counter(dict):\n    def __init__(self, *args):\n        super().__init__(args)\n    def add(self,x,d=1):\n        self.setdefault(x,0)\n        self[x] += d\n    def list(self):\n        l = []\n        for k in self:\n            l.extend([k]*self[k])\n        return l\nclass comb():\n    def __init__(self, n, mod=None):\n        self.l = [1]\n        self.n = n\n        self.mod = mod\n    def get(self,k):\n        l,n,mod = self.l, self.n, self.mod\n        k = n-k if k>n//2 else k\n        while len(l)<=k:\n            i = len(l)\n            l.append(l[i-1]*(n+1-i)//i if mod==None else (l[i-1]*(n+1-i)*powmod(i,-1,mod))%mod)\n        return l[k]\ndef pf(x,mode='counter'):\n    C = counter()\n    p = 2\n    while x>1:\n        k = 0\n        while x%p==0:\n            x //= p\n            k += 1\n        if k>0:\n            C.add(p,k)\n        p = p+2-(p==2) if p*p<x else x\n    if mode=='counter':\n        return C\n    S = set([1])\n    for k in C:\n        T = deepcopy(S)\n        for x in T:\n            for i in range(1,C[k]+1):\n                S.add(x*(k**i))\n    if mode=='set':\n        return S\n    if mode=='list':\n        return sorted(list(S))\n\nN,A,B=mint()\nX=lint()\ndp=[0]*N\nfor i in range(N-1):\n    dp[i+1]=dp[i]+min(A*(X[i+1]-X[i]),B)\nprint(dp[N-1])", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\nMOD = 10**9 + 7\n\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nimport itertools\nimport bisect\nimport re\nfrom collections import Counter,deque,defaultdict\ndef iinput(): return int(input())\ndef imap(): return map(int, input().split())\ndef ilist(): return list(imap())\ndef irow(N): return [iinput() for i in range(N)]\ndef sinput(): return input().rstrip()\ndef smap(): return sinput().split()\ndef slist(): return list(smap())\ndef srow(N): return [sinput() for i in range(N)]\n\ndef main():\n    N,A,B = imap()\n    X = ilist()\n    dp = [INF]*(N)\n    dp[0] = 0\n    for i in range(N-1):\n        dp[i+1] = min(dp[i]+(X[i+1]-X[i])*A, dp[i]+B)\n    print(dp[-1])\n\ndef __starting_point():\n    main()\n__starting_point()", "def resolve():\n  N, A, B = map(int, input().split(\" \"))\n  X = [int(x) for x in input().split(\" \")]\n\n  ans = 0\n  for i in range(1, N):\n    walking_cost = (X[i]-X[i-1])*A\n    ans += min(walking_cost, B)\n\n  print(ans)\n\nresolve()", "N,A,B=map(int,input().split())\nX=[int(x) for x in input().split()]\nscore=0\nfor i in range(N-1):\n  score+=min((X[i+1]-X[i])*A,B)\nprint(score)", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\n\nans = 0\nnow = x[0]\nfor xx in x[1:]:\n    ans += min((xx-now)*a, b)\n    now = xx\n\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\n\ndef read():\n    N, A, B = list(map(int, input().strip().split()))\n    X = list(map(int, input().strip().split()))\n    return N, A, B, X\n\n\ndef solve(N, A, B, X):\n    ans = 0\n    for i in range(N-1):\n        d = X[i+1] - X[i]\n        ans += min(A * d, B)\n    return ans\n\n\ndef __starting_point():\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print((\"%s\" % str(outputs)))\n\n__starting_point()", "n,a,b=map(int,input().split())\nA=list(map(int,input().split()))\nans=0\nfor i in range(n-1):\n    if (A[i+1]-A[i])*a < b:\n        ans+=a*(A[i+1]-A[i])\n    else:\n        ans+=b\nprint(ans)", "n, a, b = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nans = 0\nfor i in range(len(x)-1):\n  walk_cost = a * (x[i+1]-x[i])\n  if b < walk_cost:\n    ans += b\n  else:\n    ans += walk_cost\nprint(ans)\n\n", "import sys\n\ninput_methods=['clipboard','file','key']\nusing_method=0\ninput_method=input_methods[using_method]\n\ntin=lambda : map(int, input().split())\nlin=lambda : list(tin())\nmod=1000000007\n\n#+++++\n\ndef main():\n\t#a = int(input())\n\tn, a, b = tin()\n\t#s = input()\t\n\tal=lin()\n\tpos=al[0]\n\tret=0\n\tfor np in al[1:]:\n\t\tret += min(b, (np-pos)*a)\n\t\tpos = np\n\treturn ret\n\t\n\t\n#+++++\nisTest=False\n\ndef pa(v):\n\tif isTest:\n\t\tprint(v)\n\t\t\ndef input_clipboard():\n\timport clipboard\n\tinput_text=clipboard.get()\n\tinput_l=input_text.splitlines()\n\tfor l in input_l:\n\t\tyield l\n\ndef __starting_point():\n\tif sys.platform =='ios':\n\t\tif input_method==input_methods[0]:\n\t\t\tic=input_clipboard()\n\t\t\tinput = lambda : ic.__next__()\n\t\telif input_method==input_methods[1]:\n\t\t\tsys.stdin=open('inputFile.txt')\n\t\telse:\n\t\t\tpass\n\t\tisTest=True\n\telse:\n\t\tpass\n\t\t#input = sys.stdin.readline\n\t\t\t\n\tret = main()\n\tif ret is not None:\n\t\tprint(ret)\n__starting_point()", "def main():\n    N, A, B = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n\n    cost = 0\n    for i in range(N-1):\n        distance = abs(X[i] - X[i+1])\n        if distance * A < B:\n            cost += distance * A\n        else:\n            cost += B\n    print(cost)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\nN, A, B = list(map(int, input().split()))\nX = list(map(int, sys.stdin.readline().rsplit()))\n\nres = 0\nfor i in range(1, N):\n    cost = abs(X[i] - X[i - 1]) * A\n    if cost < B:\n        res += cost\n    else:\n        res += B\n\nprint(res)\n", "n, a, b = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\ncnt = 0\n\nfor i in range(1, n):\n    cnt += min(a*(x[i]-x[i-1]), b)\n\nprint(cnt)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nans = (X[-1] - X[0]) * A\nfor x1, x2 in zip(X, X[1:]):\n    if (x2 - x1) * A > B:\n        ans -= (x2 - x1) * A - B\nprint(ans)", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\n\ncurrent = x[0]\ncost = 0\nfor i in x:\n    if (i-current) * a <= b:\n        cost += (i-current) * a\n        current = i\n    else:\n        cost += b\n        current = i\nprint(cost)", "n, a, b, *x = list(map(int, open(0).read().split()))\n\nnow = x[0]\n\nans = 0\nfor i in range(1, n):\n    cost = (x[i] - now) * a\n    if cost > b:\n        ans += b\n    else:\n        ans += cost\n    now = x[i]\nprint(ans)\n", "from sys import stdin, setrecursionlimit\nimport bisect,collections,copy,itertools,math,string\nsetrecursionlimit(10**9)\n\ndef input():\n    return stdin.readline().strip()\n        \ndef main():\n\n    n, a, b = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n-1):\n        ans += min((x[i+1]-x[i])*a, b)\n    \n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nprev = X[0]\nanswer = 0\nfor x in X:\n    if A * (x - prev) < B:\n        answer += A * (x - prev)\n    else:\n        answer += B\n    prev = x\nprint(answer)", "n,a,b = map(int,input().split())\nxs = list(map(int,input().split()))\ns = xs[0]\nrt = 0\nfor i in xs[1:]:\n  rt+= min(a*(i-s),b)\n  s = i\nprint(rt)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, N):\n  if (X[i]-X[i-1]) * A < B:\n    ans += (X[i]-X[i-1]) * A\n  else:\n    ans += B\nprint(ans)", "N,A,B = map(int,input().split())\nX = list(map(int,input().split()))\nans = 0\nfor i in range(1,N):\n    ans += min(B,(X[i]-X[i-1])*A)\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nmod=1000000007\n\ndef main():\n    n, a, b = list(map(int,input().split()))\n    X = list(map(int,input().split()))\n    useb = b//a\n    ans = 0\n    for i in range(n-1):\n        d = X[i+1] - X[i]\n        if d > useb:\n            ans += b\n        else: ans += d * a\n\n    print(ans)\n\nmain()", "n, a, b = list(map(int, input().split()))\nX = list(map(int, input().split()))\np = X[0]\nans = 0\nfor x in X[1:]:\n    d = x - p\n    if d * a <= b:\n        ans += d * a\n    else:\n        ans += b\n    p = x\nprint(ans)\n", "n,a,b=list(map(int,input().split()))\nx=list(map(int,input().split()))\nans=0\nfor i in range(1,n):\n  # \u753a(i-1)\u304b\u3089\u753ai\u306b\u884c\u304f\u65b9\u6cd5\u3092\u8003\u3048\u3066\u307f\u3088\u3046\uff5e\uff5e\uff5e\n  toho = a * (x[i] - x[i-1])\n  tele = b\n  ans += min(toho, tele)\nprint(ans)\n", "n, a, b = list(map(int, input().split()))\nX = list(map(int, input().split()))\nY = [X[i+1]-X[i] for i in range(n-1)]\nans = 0\nfor y in Y:\n    if y*a <= b:\n        ans += y*a\n    else:\n        ans += b\nprint(ans)\n", "N,A,B=map(int,input().split())\n*X,=map(int,input().split())\ni=1\nans=0\nwhile i<N:\n    ans+=min(B,A*(X[i]-X[i-1]))\n    i+=1\nprint(ans)", "N, A, B = map(int, input().split())\nX = list(map(int, input().split()))\nans = 0\nfor i in range(N-1):\n    ans += min(A*(X[i+1]-X[i]), B)\nprint(ans)", "n, a, b = list(map(int, input().split()))\nxlist = list(map(int, input().split()))\n\n\nclass UnionFind(list):\n\n    def __init__(self, length):\n        super().__init__((-1 for _ in range(length)))\n\n    def root(self, i):\n        if self[i] < 0:\n            return i\n        else:\n            self[i] = self.root(self[i])\n            return self[i]\n\n    def size(self, i):\n        root_i = self.root(i)\n        return -1 * self[root_i]\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n\n        if rx == ry:\n            return\n        # unite by size\n        if self.size(x) < self.size(y):\n            rx, ry = ry, rx\n        self[rx] += self[ry]\n        self[ry] = rx\n\n\nun = UnionFind(n)\nfor i in range(n-1):\n    if (xlist[i+1]-xlist[i])*a <= b:\n        un.unite(i, i+1)\n\nans = 0\nfor i in range(n-1):\n    if un.same(i, i+1):\n        ans += (xlist[i+1]-xlist[i])*a\n    else:\n        ans += b\nprint(ans)\n", "#coding: utf-8\nN, A, B = list(map(int, input().split()))\nX = list(map(int, input().split()))\ndp = [float(\"inf\") for _ in range(N)]\ndp[0] = 0\nfor i in range(1, N):\n    dp[i] = min(A * (X[i] - X[i-1]), B, dp[i]) + dp[i-1]\nprint((dp[N-1]))\n", "N, A, B = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\nnow = X[0]\nans = 0\nfor x in X:\n    dis = x - now\n    tmp= min(A*dis , B)\n    # print(tmp)\n    ans += tmp\n    now = x\n\nprint(ans)\n", "import sys\n# sys.setrecursionlimit(100000)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef input_int():\n    return int(input())\n\n\ndef input_int_list():\n    return [int(i) for i in input().split()]\n\n\ndef main():\n    n, a, b = input_int_list()\n    X = input_int_list()\n    dp = [0] * (n)\n    for i in range(1, n):\n        dp[i] = min(dp[i - 1] + (X[i] - X[i - 1]) * a, dp[i - 1] + b)\n\n    print((dp[n - 1]))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,a,b,*X=map(int,open(c:=0).read().split())\nfor i in range(n-1):c+=min(a*(X[i+1]-X[i]),b)\nprint(c)", "n,a,b,*x = map(int,open(0).read().split())\nprint(sum([min(b,a*(x[i+1]-x[i])) for i in range(n-1)]))", "N,A,B=list(map(int,input().split()))\nL=list(map(int,input().split()))\nw=B//A\nv=0\nfor i in range(N-1):\n  d=L[i+1]-L[i]\n  if d>w:\n    v+=B\n  else:\n    v+=d*A\nprint(v)", "N, A, B = list(map(int,input().split()))\nX = list(map(int,input().split()))\nNewX = []\nfor i in range(N-1):\n  NewX.append((X[i+1]-X[i])*A)\nans = 0\nfor i in NewX:\n  ans+=min(i, B)\nprint(ans)\n", "n,a,b = map(int,input().split())\nx = list(map(int,input().split()))\nl = []\nfor i in range(n-1):\n    l.append(x[i+1]-x[i])\nans = 0\nfor i in l:\n    if a*i < b:\n        ans += a*i\n    else:\n        ans += b\nprint(ans)", "N,A,B = map(int,input().split())\nX = list(map(int,input().split()))\n\nans = 0\nfor i in range(N-1):\n    d = X[i+1]-X[i]\n    if d * A < B:\n        ans += d*A\n    else:\n        ans += B\n\nprint(ans)", "N,A,B,*X=map(int,open(0).read().split())\nprint(sum(min(A*(y-x),B)for x,y in zip(X,X[1:])))", "N, A, B = list(map(int,input().split()))\nX = list(map(int,input().split()))\n\nnow = X[0]\nans = 0\nfor x in X:\n  ans += min(B, A*(x-now))\n  now = x\n  \nprint(ans)\n", "N,A,B = list(map(int,input().split()))\nX = list(map(int,input().split()))\nY = [0]*(N-1)\nfor i in range(N-1):\n    Y[i] = X[i+1]-X[i]\nout = 0\nfor i in range(N-1):\n    out += min(B,Y[i]*A)\nprint(out)\n", "3\n#coding: utf-8\n\nN, A, B = (int(i) for i in input().split())\nX = [int(x) for x in input().split()]\n\nret = 0\n\nfor i in range(1, N):\n    d = X[i] - X[i-1]\n    if d * A <= B:\n        ret += d*A\n    else:\n        ret += B\n\nprint(ret)\n", "n,a,b=map(int,input().split())\nx=list(map(int,input().split()))\nprint(sum([min(x[i+1]*a-x[i]*a,b)for i in range(n-1)]))", "def solve():\n    N, A, B = map(int,input().split())\n    X = list(map(int,input().split()))\n    ans = 0\n    for i in range(1,N):\n        dx = X[i] - X[i-1]\n        if dx * A < B:\n            ans += dx * A\n        else:\n            ans += B\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nimport os\nfrom copy import copy\nimport operator\nimport time\nimport datetime\nimport math\nfrom math import floor, ceil, sqrt, log\nimport statistics\nfrom statistics import mean, median\nfrom decimal import Decimal as D\nfrom fractions import Fraction as F\nimport functools\nimport random\nfrom random import randint, shuffle\nimport bisect\nimport string\nfrom collections import deque\nimport collections\nimport itertools\nimport heapq\n\nsys.setrecursionlimit(4100000)\nproduct = functools.partial(functools.reduce, operator.mul)\nINF = float(\"inf\")\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [-1] * n\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            if self.parents[x] > self.parents[y]:\n                x, y = y, x\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return list(filter(lambda x: x < 0, self.parents))\n\n    def group_count(self):\n        return len(self.roots())\n\n    def max_size(self):\n        return -min(self.parents)\n\n    def min_size(self):\n        return -max(self.roots())\n\n    def append(self, n):\n        self.parents += [-1] * n\n\n\nclass Imos:\n    def __init__(self, n):\n        self.val = [0] * n\n\n    def add(self, x, y, n=None):\n        if n is None:\n            n = 1\n        self.val[x] += n\n        if len(self.val) > y + 1:\n            self.val[y + 1] -= n\n\n    def imos(self):\n        for i in range(1, len(self.val)):\n            self.val[i] += self.val[i - 1]\n\n    def max(self):\n        return max(self.val)\n\n    def min(self):\n        return min(self.val)\n\n\nclass CS:\n    def __init__(self, grid):\n        self.cs = grid\n        for i0 in range(len(grid)):\n            for i1 in range(len(grid[0])):\n                if i0 == 0:\n                    if i1 == 0:\n                        continue\n                    self.cs[i0][i1] += self.cs[i0][i1 - 1]\n                else:\n                    if i1 == 0:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1]\n                    else:\n                        self.cs[i0][i1] += self.cs[i0 - 1][i1] + self.cs[i0][i1 - 1] - \\\n                                           self.cs[i0 - 1][i1 - 1]\n\n    def sum(self, start_0, start_1, end_0, end_1):\n        if start_0 == 0:\n            if start_1 == 0:\n                return self.cs[end_0][end_1]\n            return self.cs[end_0][end_1] - self.cs[end_0][start_1 - 1]\n        if start_1 == 0:\n            return self.cs[end_0][end_1] - self.cs[start_0 - 1][end_1]\n        start_0 -= 1\n        start_1 -= 1\n        return self.cs[end_0][end_1] - self.cs[start_0][end_1] - self.cs[end_0][\n            start_1] + self.cs[start_0][start_1]\n\n\ndef mod(n):\n    return n % (10 ** 9 + 7)\n\n\ndef sinput():\n    return sys.stdin.readline()[:-1]\n\n\ndef input():\n    inputs = list(map(int, sys.stdin.readline().split()))\n    if len(inputs) == 1:\n        return inputs[0]\n    return inputs\n\n\ndef listban(l):\n    return list(map(list, set(map(tuple, l))))\n\n\ndef div(n):\n    lower_divisors, upper_divisors = [], []\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n // i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\ndef prime(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n //= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ndef div_counter(l, n):\n    return prime(l).count(n)\n\n\ndef lcm(x, y):\n    return (x * y) // math.gcd(x, y)\n\n\ndef C(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef P(n, r):\n    if n < r:\n        return 0\n    return math.factorial(n) // math.factorial(n - r)\n\n\ndef H(n, r):\n    return C(n + r - 1, r)\n\n\ndef cos(x, y, a):\n    return (x ** 2 + y ** 2 - 2 * x * y * math.cos(math.radians(a))) ** 0.5\n\n\ndef DFS(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos.add(s)\n    for i in g[s]:\n        if not (i in pos):\n            DFS(g, i, pos)\n    return pos\n\n\ndef DFS_one(g, s, pos=None):\n    if pos is None:\n        pos = set()\n    pos = copy(pos)\n    pos.add(s)\n    b = copy(pos)\n    m = copy(pos)\n    for i in g[s]:\n        if not (i in pos):\n            b = DFS(g, i, pos)\n            if len(m) < len(b):\n                m = b\n    return m\n\n\ndef BFS(g, q, pos=None):\n    if pos is None:\n        pos = set()\n    if type(q) == deque:\n        pos.add(q)\n        q = deque([q])\n    pos.add(q[-1])\n    for i in g[q.pop()]:\n        if not i in pos:\n            q.append(i)\n    while q != deque():\n        pos, q = BFS(g, q, pos)\n    return pos, q\n\n\ndef SSP(a, li=None):\n    if li is None:\n        li = []\n    if len(a) == 1:\n        return [a[0]]\n    return list(set(\n        li + SSP(a[1:], li) + list(map(lambda x: x + a[0], SSP(a[1:], li))) + [a[0]]))\n\n\ndef dijkstra(g, s):\n    n = len(g)\n    dist = [10 ** 100] * n\n    hq = [(0, s)]\n    dist[s] = 0\n    seen = [False] * n\n    while hq:\n        v = heapq.heappop(hq)[1]\n        seen[v] = True\n        for to, cost in g[v]:\n            if seen[to] == False and dist[v] + cost < dist[to]:\n                dist[to] = dist[v] + cost\n                heapq.heappush(hq, (dist[to], to))\n    return dist\n\n\ndef LIS(b):\n    l = [b[0]]\n    for i in b:\n        if i > l[-1]:\n            l += [i]\n        else:\n            l[bisect.bisect_left(l, i)] = i\n    return len(l)\n\n\ndef two(n):\n    return len(str(bin(n))) - str(bin(n)).rfind(\"1\") - 1\n\n\ndef yn(b):\n    if b:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef op(s):\n    print(s)\n    return()\n\n\nn, a, b = input()\nx = input()\nans = 0\nfor i in range(1, n):\n    ans += min((x[i] - x[i-1])*a, b)\nprint(ans)", "import queue\nn, a, b = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nvals = [float('inf')]*n\nvals[0] = 0\n\nc = queue.Queue()\nc.put(1)\n\nwhile not c.empty():\n    d = c.get()\n    if d == n:\n        continue\n    if b+vals[d-1] < vals[d]:\n        vals[d] = b+vals[d-1]\n    if a*(x[d]-x[d-1])+vals[d-1] < vals[d]:\n        vals[d] = a*(x[d]-x[d-1])+vals[d-1]\n    c.put(d+1)\nprint((vals[-1]))\n", "n,a,b=list(map(int,input().split()))\nx=list(map(int,input().split()))\nans=0\nfor i in range(1,n):\n    ans+=min(b,a*(x[i]-x[i-1]))\nprint(ans)\n", "n, a, b = map(int, input().split())\nx = list(map(int, input().split()))\n\ncnt = 0\nfor i, j in zip(x, x[1:]):\n    if a * (j - i) < b:\n        cnt += a * (j - i)\n    else:\n        cnt += b\nprint(cnt)", "n,a,b=list(map(int,input().split()))\nx=list(map(int,input().split()))\ntemp=0\nfor i in range(n-1):\n    c=x[i+1]-x[i]\n    temp+=min(c*a,b)\nprint(temp)\n", "N,A,B = map(int,input().split())\nX = list(map(int,input().split()))\ndist = [0 for _ in range(N-1)]\nfor i in range(N-1):\n    dist[i]=(X[i+1]-X[i])*A\ncnt = 0\nfor i in range(N-1):\n    if dist[i]>B:\n        cnt +=B\n    else:\n        cnt += dist[i]\nprint(cnt)", "import bisect\nimport heapq\nimport itertools\nimport sys\nimport math\nimport random\nfrom collections import Counter, deque, defaultdict\nfrom functools import reduce\nfrom operator import xor\nfrom typing import List\n\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 9)\n\n\ndef lmi():\n    return list(map(int, input().split()))\n\ndef main():\n    N, A, B = lmi()\n    X = lmi()\n    ans = 0\n    for i in range(1, N):\n        ans += min((X[i] - X[i - 1]) * A, B)\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()"]
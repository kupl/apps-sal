["class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        if not arr: return 0\n        \n        res = []\n\n        while len(arr) > 1:\n            temp_res = []\n            temp_res = [arr[i]*arr[i+1] for i in range(len(arr)-1)]\n            idx = temp_res.index(min(temp_res))\n\n            res.append(temp_res[idx])\n            arr.pop(idx if arr[idx] < arr[idx+1] else idx+1)\n                \n            # left = arr[0] * arr[1]\n            # right = arr[-1] * arr[-2]\n            # if left < right:\n            #     res.append(left)\n            #     arr.pop(1 if arr[1] < arr[0] else 0)\n            # elif right < left:\n            #     res.append(right)\n            #     arr.pop(-2 if arr[-2] < arr[-1] else -1)\n            # else:\n            #     res.append(left)\n            #     if max(arr[0], arr[1]) > max(arr[-1], arr[-2]):\n            #         arr.pop(-2 if arr[-2] < arr[-1] else -1)\n            #     else:\n            #         arr.pop(1 if arr[1] < arr[0] else 0)\n        \n        return sum(res)", "class Solution:\n    def mctFromLeafValues(self, A: List[int]) -> int:\n        res = 0\n        while len(A) > 1:\n            i = A.index(min(A))\n            neighbors = []\n            if i-1 >= 0:\n                neighbors.append(A[i-1])\n            if i+1 < len(A):\n                neighbors.append(A[i+1])\n            res += min(neighbors) * A.pop(i)\n        return res", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        while len(arr) > 1:\n            mini_idx = arr.index(min(arr))\n            if 0 < mini_idx < len(arr) - 1:\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\n            else:\n                res += arr[1 if mini_idx == 0 else mini_idx - 1] * arr[mini_idx]\n            arr.pop(mini_idx)\n        return res", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        if len(arr) <= 1: return 0\n        min_i = 0\n        min_val = arr[0] * arr[1]\n        \n        for i in range(1, len(arr) - 1):\n            cur = arr[i] * arr[i + 1]\n            if cur < min_val:\n                min_val = cur\n                min_i = i\n        \n        new_arr = arr[:min_i] + [max(arr[min_i], arr[min_i+1])] + arr[min_i+2:]\n        return min_val + self.mctFromLeafValues(new_arr)", "class Solution:\n    def helper(self, arr):\n      if not arr:\n        pass\n      else:\n        if len(arr) == 1:\n          return 0\n        else:\n          res = sys.maxsize\n          max_ind = arr.index(max(arr))\n          for div in range(max_ind, max_ind+2):\n            temp_res = 0\n            if div == 0 or div == len(arr):\n              continue\n            temp_res += max(arr[:div])*max(arr[div:])\n            temp_res += self.helper(arr[:div])\n            temp_res += self.helper(arr[div:])\n            res = min(res, temp_res)\n            #print (temp_res, div)\n          return res\n            \n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.helper(arr)", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        while len(arr)>1:\n            idx = arr.index(min(arr))\n            if 0 < idx < len(arr)-1:\n                res += min(arr[idx-1],arr[idx+1]) * arr[idx]\n                arr = arr[:idx] + arr[idx+1:]\n            elif idx == 0:\n                res += arr[1] * arr[idx]\n                arr = arr[1:]\n            else:\n                res += arr[-2] * arr[idx]\n                arr = arr[:-1]\n        return res\n                \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        '''\n        concept:\n            we can do greedy: every time select the two nodes with smallest product as two leafs \n            why greedy works?\n            \n            we can also maintain a monotone decreasing stack\n        '''\n        stack = [arr[0]]\n        _sum = 0\n        for n in arr[1:]:\n            while stack and n > stack[-1]:\n                n1 = stack.pop()\n                \n                n2 = n if not stack or n < stack[-1] else stack[-1]\n                # print(n1, n2)\n                _sum += n1*n2\n            stack.append(n)\n        # print(stack)\n        # print(_sum)\n        while len(stack) > 1:\n            n1 = stack.pop()\n            n2 = stack.pop()\n            _sum += n1*n2\n            if not stack:\n                break\n            stack.append(max(n1, n2))\n        return _sum\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        \n        while (len(arr) > 1):\n        \n            mid = arr.index(min(arr))\n            \n            res += min(arr[mid - 1:mid] + arr[mid+1:mid + 2]) * arr.pop(mid)\n        \n   \n        return res", "class Solution:\n    def mctFromLeafValues(self, arr):\n        vals = [[0]*len(arr) for i in range(len(arr))]\n        maxes = [[0]*len(arr) for i in range(len(arr))]\n        for n in range(1, len(arr)+1):\n            for a in range(len(arr) - n + 1):\n                b = a + n\n                maxes[a][b-1] = max(maxes[a][b-2], arr[b-1])\n                if n >= 2:\n                    vals[a][b-1] = min((vals[a][i-1] + vals[i][b-1] + (maxes[a][i-1]*maxes[i][b-1]) for i in range(a+1, b)))\n        print(vals)\n        return vals[0][len(arr)-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp = [[0 for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = (0, arr[i])\n        \n        for v in range(1,len(arr)):\n            for j in range(v, len(arr)):\n                i = j - v\n                D_i_j = min(dp[i][k][0] + dp[k+1][j][0] + dp[i][k][1] * dp[k+1][j][1] for k in range(i, j))\n                M_i_j = max(dp[i][j-1][1], arr[j])\n                \n                dp[i][j] = (D_i_j, M_i_j)\n                \n                \n        return dp[0][len(arr)-1][0]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n=len(arr)\n        max_dp=[[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            temp=arr[i]\n            for j in range(i,n):\n                temp=max(temp,arr[j])\n                max_dp[i][j]=temp\n        dp=[[-1 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            dp[i][i]=0\n        for i in range(n-1):\n            dp[i][i+1]=arr[i]*arr[i+1]\n        for k in range(2,n):\n            for i in range(n):\n                j=i+k\n                if j>=n:\n                    break\n                dp[i][j]=dp[i][i]+dp[i+1][j]+arr[i]*max_dp[i+1][j]\n                for s in range(i+1,j):\n                    dp[i][j]=min(dp[i][j],dp[i][s]+dp[s+1][j]+max_dp[i][s]*max_dp[s+1][j])\n        return dp[0][-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[[0,0] for _1 in range(n)] for _2 in range(n)]\n        for i in range(n):\n            dp[i][i] = [arr[i], 0] # last number and sum\n        for diff in range(1,n):\n            for i in range(n-diff): #i,i+1,...,i+diff\n                temp_min_ = 10**40\n                root = None\n                for j in range(i,i+diff):\n                    sum_ = (dp[i][j][1] + dp[j+1][i+diff][1]) + dp[i][j][0] * dp[j+1][i+diff][0]\n                    if sum_ < temp_min_:\n                        temp_min_ = sum_\n                        root = max(dp[i][j][0], dp[j+1][i+diff][0])\n                dp[i][i+diff] = [root, temp_min_]\n                        \n        return dp[0][-1][1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:        \n        # Given an interval of leaves in the range [i, j], we could pick\n        # some k, i <= k < j, such that [i, k] are the leaves on the\n        # left subtree and [k + 1, j] that of the right subtree\n        # For all k: f(i, j) = f(i, k) + f(k + 1, j) + max([i, k]) * max([k+1, j])\n        \n        n = len(arr)\n\n        # first pre-fill the max(i, j) function\n        m = [None] * n\n        for i in range(len(m)):\n            m[i] = [float('-inf')] * n\n            m[i][i] = arr[i]\n        for l in range(2, n + 1):\n            for i in range(0, n-l+1):\n                j = i + l - 1\n                mid = (i + j) // 2\n                m[i][j] = max(m[i][j], m[i][mid], m[mid+1][j])\n           \n        # now fill f()\n        f = [None] * n\n        for i in range(len(f)):\n            f[i] = [float('inf')] * n\n            f[i][i] = 0\n        for l in range(2, n + 1):\n            for i in range(0, n-l+1):\n                j = i + l - 1\n                for k in range(i, j):\n                    f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + m[i][k] * m[k+1][j])\n        return f[0][n-1]\n                                        \n                    \n", "class Solution:\n    def mctFromLeafValues(self, arr):\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].\n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n\n        Improvement 1:\n        We calculate the largest leaf value for each possible subtree containing leaf i to j.\n        We store those values in the matrix max_leaf_value[i,j].\n        We initialize max_leaf_value[i,i] = arr[i] and max_leaf_value[i,j] = 0 for i!=j.\n        '''\n        maxi = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n        for i in range(len(arr)):\n            maxi[i][i] = arr[i]\n\n        for l in range(1, len(arr) - 1):\n            for i in range(len(arr) - l):\n                j = i + l\n                maxi[i][j] = max(maxi[i][j - 1], maxi[i + 1][j])\n\n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n\n        for l in range(1, len(arr)):\n            for i in range(0, len(arr) - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j],\n                                   (dp[i][k] if i < k else 0) + (dp[k + 1][j] if k + 1 < j else 0) + maxi[i][k] *\n                                   maxi[k + 1][j])\n\n        return dp[0][len(arr) - 1]", "class Solution:\n    def mctFromLeafValues(self, arr):\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].\n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n        '''\n        maxi = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n        for i in range(len(arr)):\n            maxi[i][i] = arr[i]\n\n        for l in range(1,len(arr)-1):\n            for i in range(len(arr)-l):\n                j = i + l\n                maxi[i][j] = max(maxi[i][j-1], maxi[i+1][j])\n\n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n\n        for l in range(1, len(arr)):\n            for i in range(0, len(arr) - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if i < k else 0) + (dp[k + 1][j] if k + 1 < j else 0) + maxi[i][k] * maxi[k+1][j])\n\n        return dp[0][len(arr) - 1]\n    \n        '''\n        Improvement 1:\n        We calculate the largest leaf value for each possible subtree containing leaf i to j. \n        We store those values in the matrix max_leaf_value[i,j].\n        We initialize max_leaf_value[i,i] = arr[i] and max_leaf_value[i,j] = 0 for i!=j.\n        '''", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        #the cost of remove a is a * b b >= a. Greedy using the smallest b in the rest to time a to minimize the cost\n        while len(arr) > 1:\n            i = arr.index(min(arr))\n            res += min(arr[i-1:i] + arr[i+1:i+2]) * arr.pop(i)\n            \n        return res", "class Solution:\n    def mctFromLeafValues(self, arr):\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].\n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n\n        Improvement 1:\n        We calculate the largest leaf value for each possible subtree containing leaf i to j.\n        We store those values in the matrix maxi[i,j].\n        '''\n        maxi = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n        for i in range(len(arr)):\n            maxi[i][i] = arr[i]\n\n        for l in range(1, len(arr) - 1):\n            for i in range(len(arr) - l):\n                j = i + l\n                maxi[i][j] = max(maxi[i][j - 1], maxi[i + 1][j])\n\n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n\n        for l in range(1, len(arr)):\n            for i in range(0, len(arr) - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j],\n                                   (dp[i][k] if i < k else 0) + (dp[k + 1][j] if k + 1 < j else 0) + maxi[i][k] *\n                                   maxi[k + 1][j])\n\n        return dp[0][len(arr) - 1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        N = len(arr)\n        dp = [[[0, i] for i in arr]] # length, index, val(0: sum, 1: max)\n        for l in range(1, N):\n            dp.append([])\n            for i in range(N-l):\n                dp[l].append([sys.maxsize, 0])\n                for x in range(i, i+l):\n                    tmp = dp[x-i][i][0]+dp[i+l-x-1][x+1][0]+dp[x-i][i][1]*dp[i+l-x-1][x+1][1]\n                    if tmp < dp[l][i][0]:\n                        dp[l][i] = [tmp, max(dp[x-i][i][1], dp[i+l-x-1][x+1][1])]\n        return dp[-1][0][0]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        @lru_cache(None)\n        def cached_max(i, j):\n            return max(arr[i: j] or [1])\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if j - i <= 1:\n                return 0\n            elif j - i == 2:\n                return arr[i] * arr[i + 1]\n            return min(dp(i, k) + dp(k, j) + cached_max(i, k) * cached_max(k, j)\n                       for k in range(i + 1, j))\n        \n        return dp(0, len(arr))", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        def compute(arr, lo, hi, dp):\n            if dp[lo][hi] != -1:\n                return dp[lo][hi]\n            if hi == lo:\n                dp[lo][hi] = 0, arr[lo]\n                return 0, arr[lo]\n            if hi == lo + 1:\n                dp[lo][hi] = arr[lo]*arr[hi], max(arr[lo], arr[hi])\n                return arr[lo]*arr[hi], max(arr[lo], arr[hi])\n            \n            k = float('inf')\n            c = 0\n            for i in range(lo, hi):\n                #print(\\\"Cutting at %s\\\"%i)\n                left = compute(arr, lo, i, dp)\n                #print(\\\"left %s,%s\\\"% left)\n                right = compute(arr, i+1, hi, dp)\n                #print(\\\"right %s,%s\\\"%right)\n                t = left[0] + right[0] + left[1]*right[1]\n                #print(\\\"got %s\\\"% t)\n                if t < k:\n                    k = t\n                    c = max(left[1],right[1])\n            dp[lo][hi] = k, c\n            return k,c\n        \n        dp = [[-1]*len(arr) for row in arr]\n        \n        x= compute(arr, 0, len(arr)-1, dp)\n        #print(dp)\n        return x[0]\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        def compute(arr, lo, hi, dp):\n            if dp[lo][hi] != -1:\n                return dp[lo][hi]\n            if hi == lo:\n                dp[lo][hi] = 0, arr[lo]\n                return 0, arr[lo]\n            if hi == lo + 1:\n                dp[lo][hi] = arr[lo]*arr[hi], max(arr[lo], arr[hi])\n                return arr[lo]*arr[hi], max(arr[lo], arr[hi])\n            \n            k = float('inf')\n            c = 0\n            for i in range(lo, hi):\n                #print(\\\"Cutting at %s\\\"%i)\n                left = compute(arr, lo, i, dp)\n                #print(\\\"left %s,%s\\\"% left)\n                right = compute(arr, i+1, hi, dp)\n                #print(\\\"right %s,%s\\\"%right)\n                t = left[0] + right[0] + left[1]*right[1]\n                #print(\\\"got %s\\\"% t)\n                if t < k:\n                    k = t\n                    c = max(left[1],right[1])\n            dp[lo][hi] = k, c\n            return k,c\n        \n        dp = [[-1]*len(arr) for row in arr]\n        \n        x= compute(arr, 0, len(arr)-1, dp)\n        print(dp)\n        return x[0]\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n=len(arr)\n        @lru_cache(None)\n        def max_cache(a,b):\n            return max(arr[a:b])\n        @lru_cache(None)\n        def dp(i,j):\n            n=j-i\n            if n==1: return 0\n            if n==2: return arr[i]*arr[j-1]\n\n            \n            min_out=2**31-1\n            for k in range(i+1,j):\n                min_out=min(min_out,max_cache(i,k)*max_cache(k,j)+dp(i,k)+dp(k,j))\n        \n            return min_out\n        return dp(0,n)\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        maximum = [[0 for i in range(len(arr))]for j in range(len(arr))]\n        for i in range(len(arr)):\n            localMaximum = -math.inf\n            for j in range(i,len(arr)):\n                localMaximum = max(localMaximum,arr[j])\n                maximum[i][j] = localMaximum\n        dp = [[math.inf for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = 0\n        for length in range(1,len(arr)):\n            for left in range(len(arr)-length):\n                right = left+length\n                if length==1:\n                    dp[left][right] = arr[left]*arr[right]\n                else:\n                    for k in range(left,right):\n                        dp[left][right] = min(dp[left][right],dp[left][k]+dp[k+1][right]+(maximum[left][k]*maximum[k+1][right]))\n        return dp[0][len(arr)-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        ans = 0\n        n = len(arr)\n        dp = [[float('inf') for _ in range(n)] for _ in range(n)]\n        maxi = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 0\n            maxi[i][i] = arr[i]\n            \n        for l in range(1, n+1):\n            for i in range(n-l+1):\n                j = i + l - 1\n                for k in range(i,j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + maxi[i][k] * maxi[k+1][j] + dp[k+1][j])\n                for k in range(i,j+1):\n                    maxi[i][j] = max(maxi[i][j], arr[k])\n        return dp[0][-1]\n", "\nclass Solution:\n    def __init__(self):\n        self.dict = {}\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.mctHelp(arr, 0, len(arr))\n        \n    def mctHelp(self, arr, a, b):\n        if b-a == 1:\n            return 0\n        if (a,b) not in self.dict:\n            low, idx = 2**30, -1\n            for i in range(a+1, b):\n                res =  self.mctHelp(arr, a, i) + self.mctHelp(arr, i, b)\n                if res < low:\n                    low = res\n                    idx = i\n            low += max(arr[a:idx])*max(arr[idx:b])\n            self.dict [a,b] = low\n        return self.dict [a,b]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        # answer for subarray arr[i: j+1]\n        self.cache = {}\n        \n        \n        def dp(i, j):\n            if (i,j) not in self.cache:\n                if i == j:\n                    ret = arr[i], 0\n                else:\n                    best_p, best_s = 2**32, 2**32\n                    for k in range(i,j):\n\n                        l1, s1 = dp(i, k)\n                        l2, s2 = dp(k+1, j)\n\n                        if s1 + s2 + l1*l2 < best_s:\n                            best_p = max(l1, l2)\n                            best_s = s1 + s2 + l1*l2\n                        # print('update', i, k, k+1, j, best_p, best_s, s1, s2)\n\n                    ret = best_p, best_s\n\n                self.cache[(i,j)] = ret\n            return self.cache[(i,j)]\n            \n            \n        return dp(0, len(arr)-1)[-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        # Given an interval of leaves in the range [i, j], we could pick\n        # some k, i <= k < j, such that [i, k] are the leaves on the\n        # left subtree and [k + 1, j] that of the right subtree\n        # For all k: f(i, j) = f(i, k) + f(k + 1, j) + max([i, k]) * max([k+1, j])\n        n = len(arr)\n        f = [None] * n\n        for i in range(len(f)):\n            f[i] = [float('inf')] * n\n            f[i][i] = 0\n        \n        m = [None] * n\n        for i in range(len(m)):\n            m[i] = [float('-inf')] * n\n            m[i][i] = arr[i]\n        for l in range(2, n + 1):\n            for i in range(0, n-l+1):\n                j = i + l - 1\n                for k in range(i, j):\n                    m[i][j] = max(m[i][j], m[i][k], m[k+1][j])\n            \n        for l in range(2, n + 1):\n            for i in range(0, n-l+1):\n                j = i + l - 1\n                for k in range(i, j):\n                    f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + m[i][k] * m[k+1][j])\n        return f[0][n-1]\n                                        \n                    \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        n = len(arr)\n        maxs = [[0 if i != j else arr[i] for j in range(n)] for i in range(n)]\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                for k in range(i, j):\n                    maxs[i][j] = max(maxs[i][k], maxs[k+1][j])\n                    maxs[j][i] = maxs[i][j]\n                    \n        print(maxs)\n        \n        ans = [[0 for j in range(n)] for i in range(n)]\n     \n        for l in range(1, n):\n            for i in range(n-l):\n                j = l + i;\n                print((i, j))\n                ans[i][j] = min(maxs[i][k]*maxs[k+1][j] + ans[i][k] + ans[k+1][j] if j-i>1 else maxs[i][k]*maxs[k+1][j] for k in range(i,j))\n                \n        print(ans)\n                \n        return ans[0][n-1]\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        # use dynamic programming \n        # dp[i][j] denotes the cost of constructing a tree from arr[i:j + 1]\n        n = len(arr)\n        dp = [ [0 for _ in range(n)] for _ in range(n)]\n        \n        # the cost of constructing a tree from one value is always 0 \n        for i in range(n):\n            dp[i][i] = 0 \n        for i in range(n - 1):\n            dp[i][i + 1] = arr[i] * arr[i + 1]\n        \n        # now work iteratively for subarraies of length: 2, 3, ..., n - 1\n        for l in range(2, n + 1):\n            # (i, j) is the boundary\n            for i in range(n - l):\n                j = i + l\n                # split the (i, j) array into (i, k) and (k, j) subarraies\n                dp[i][j] = float('inf')\n                for k in range(i + 1, j + 1):\n                    q = dp[i][k - 1] + dp[k][j] + max(arr[i:k]) * max(arr[k: j + 1])\n                    if q < dp[i][j]:\n                        dp[i][j] = q\n                \n        return dp[0][-1]\n                    \n        \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        \n        n = len(arr)\n        \n        mem = {}\n        def dp(i, j):\n            if i == j:\n                    return (0, arr[i])\n            if i == j - 1:\n                return (arr[i] * arr[j], max(arr[i], arr[j]))\n            else:\n                if (i, j) in mem:\n                    return mem[(i, j)]\n                pp = max(arr[i:j + 1])\n                minn = 1e10\n                for k in range(i, j):\n                    l, lm = dp(i, k)\n                    r, rm = dp(k + 1, j)\n                    minn = min(minn, l + r + lm * rm)\n                mem[(i, j)] = (minn, pp)\n                return mem[(i, j)]\n            \n        return dp(0, n - 1)[0]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp = [[0] * len(arr) for i in range(len(arr))]\n        \n        for i in range(len(arr)-1, -1, -1):\n            \n            for j in range(i+1, len(arr)):\n\n                if j - i == 1:\n                    dp[i][j] = arr[i]*arr[j]\n                    continue\n                \n                m = 2**32\n                for k in range(i+1, j+1):\n                    s = max(arr[i:k]) * max(arr[k:j+1]) + dp[i][k-1] + dp[k][j]\n                    \n                    if s < m:\n                        m = s\n                \n                dp[i][j] = m\n        return dp[0][-1]\n                    \n        \n", "\nclass Solution:\n    def __init__(self):\n        self.vals = None\n        \n    def mctFromLeafValues(self, arr):\n        self.vals = [[0]*len(arr) for i in range(len(arr))]\n        for n in range(2, len(arr)+1):\n            for a in range(len(arr) - n + 1):\n                b = a + n\n                self.vals[a][b-1] = min((self.vals[a][i-1] + self.vals[i][b-1] + (max(arr[a:i])*max(arr[i:b]))) for i in range(a+1, b))\n        return self.vals[0][len(arr)-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        while len(arr) > 1:\n            mini_idx = arr.index(min(arr))\n            if 0 < mini_idx < len(arr) - 1:\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\n            else:\n                if mini_idx == 0:\n                    adj_idx = 1\n                else:\n                    adj_idx = mini_idx-1\n                res += arr[adj_idx] * arr[mini_idx]\n            arr.pop(mini_idx)\n            #print(arr)\n            #print(res)\n        return res", "class Solution:\n  def mctFromLeafValues(self, arr: List[int]) -> int:\n    # dp problem\n    # arr[i:j] can be split into arr[i:k] and arr[k:j]\n    # min_sum of arr[i:j] is min_sum(arr[i:k]) + min_sum(arr[k:j]) + max(arr[i:k]) * max(arr[k:j])\n    # max of arr[i:j] is max(max(arr[i:k]), max(arr[k:j]))\n    # dp[i][j] maintains min_sum and max value\n    if len(arr) == 0:\n      return 0\n    elif len(arr) == 1:\n      return arr[0]\n    dp = {}\n    for i in range(len(arr)):\n      dp[(i, i+1)] = (0, arr[i])\n    for length in range(2, len(arr)+1):\n      for i in range(len(arr)-length+1):\n        # calculate the solution for arr[i: i+length]\n        end = i + length\n        minSum = float('inf')\n        maxLeafValue = float('-inf')\n        for k in range(i+1, end):\n          # pick [i: k] left tree and [k: end] as right tree\n          minSum = min(minSum, dp[(i, k)][0] + dp[(k, end)][0] + dp[(i, k)][1]*dp[(k, end)][1])\n          maxLeafValue = max([maxLeafValue, dp[(i, k)][1], dp[(k, end)][1]])\n        dp[(i, end)] = (minSum, maxLeafValue)\n    \n    return dp[(0, len(arr))][0]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        # solve(0, n) = min_i(max(a[:i])*max(a[i:])+solve(0, i) + solve(i, n))\n        n = len(arr)\n        @lru_cache(None)\n        def solve(i, j):\n            if j - i <= 1:\n                return 0\n            return min([max(arr[i:k])*max(arr[k:j])+solve(i,k)+solve(k,j)\n                        for k in range(i+1,j)])\n        return solve(0, n)\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        N = len(arr)\n        dp = [[float('inf')]*N for _ in range(N)]\n        \n        for i in range(N-1, -1, -1):\n            for j in range(i, N):\n                if i==j: \n                    dp[i][j] = 0\n                    continue\n                \n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+max(arr[i:k+1])*max(arr[k+1:j+1]))\n                    \n        return dp[0][N-1]", "from functools import lru_cache\nclass Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        N = len(arr)\n        @lru_cache(None)\n        def dp(l, r):\n            if r - l <= 1:\n                return 0\n            return min(max(arr[l:m]) * max(arr[m:r]) + dp(l, m) + dp(m, r) for m in range(l + 1, r))\n        \n        return dp(0, N)", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        # Given an interval of leaves in the range [i, j], we could pick\n        # some k, i <= k < j, such that [i, k] are the leaves on the\n        # left subtree and [k + 1, j] that of the right subtree\n        # For all k: f(i, j) = f(i, k) + f(k + 1, j) + max([i, k]) * max([k+1, j])\n        n = len(arr)\n        f = [None] * n\n        for i in range(len(f)):\n            f[i] = [float('inf')] * n\n            f[i][i] = 0\n            \n        for l in range(2, n + 1):\n            for i in range(0, n-l+1):\n                j = i + l - 1\n                for k in range(i, j):\n                    f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + max(arr[i:k+1]) * max(arr[k+1:j+1]))\n        return f[0][n-1]\n                                        \n                    \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[0 for j in range(n)] for i in range(n)]\n        for i in range(n-2, -1, -1):\n            dp[i][i+1] = arr[i]*arr[i+1]\n            for j in range(i+2, n):\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+max(arr[i:k+1])*max(arr[k+1:j+1]))\n        return dp[0][n-1]\n                \n                \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp = [[sys.maxsize] * len(arr) for i in range(len(arr))]\n        for i in range(0, len(arr)):\n            dp[i][i] = 0\n        \n        for length in range(2, len(arr)+1):\n            for i in range(0, len(arr)-length+1):\n                j = i+length-1\n                for k in range(i, j):\n                    temp = max(arr[i:k+1])*max(arr[k+1:j+1])+dp[i][k]+dp[k+1][j]\n                    dp[i][j] = min(dp[i][j], temp)\n        \n        return dp[0][-1]\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp = [[sys.maxsize] * len(arr) for i in range(len(arr))]\n        for i in range(0, len(arr)):\n            dp[i][i] = 0\n            \n        \n        \n        for length in range(2, len(arr)+1):\n            for i in range(0, len(arr)-length+1):\n                j = i+length-1\n                for k in range(i, j):\n                    temp = max(arr[i:k+1])*max(arr[k+1:j+1])+dp[i][k]+dp[k+1][j]\n                    dp[i][j] = min(dp[i][j], temp)\n        \n        return dp[0][-1]\n", "class Solution:\n    def mctFromLeafValues(self, arr):\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].\n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n        '''\n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n\n        for l in range(1, len(arr)):\n            for i in range(0, len(arr) - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if i < k else 0) + (dp[k + 1][j] if k + 1 < j else 0) + max(\n                        arr[i:k + 1]) * max(arr[k + 1:j + 1]))\n\n        return dp[0][len(arr) - 1]", "class Solution:\n    def mctFromLeafValues(self, arr):\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].\n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n        '''\n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n\n        for l in range(1, len(arr)):\n            for i in range(0, len(arr) - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if i < k else 0) + (dp[k + 1][j] if k + 1 < j else 0) + max(\n                        arr[i:k + 1]) * max(arr[k + 1:j + 1]))\n\n        return dp[0][len(arr) - 1]\n    \n    '''\n    We calculate the largest leaf value for each possible subtree containing leaf i to j, denoted by max_leaf_value[i,j].\n    We initialize max_leaf_value[i,i] = arr[i] and max_leaf_value[i,j] = 0 for i!=j.\n    '''", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        '''\n        We can use an upper triangular matrix dp[i,j], i<=j, to represent the tree structure.\n        Each diagonal element dp[i,i] stores the value of a leaf node arr[i].   \n        Each off-diagonal element dp[i,j], i<j, denotes the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf for i<j-1; dp[i,j] = arr[i] * arr[j] for i=j-1; dp[i,j] = arr[i] for i=j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], (d[i,k] if i<k else 0) + (d[k+1,j] if k+1<j else 0) + max[i,k] * max[k+1,j]) for k=i,...,j-1, j>i\n        '''    \n        \n        \n        dp = [[float('Inf') for i in range(len(arr))] for j in range(len(arr))]\n        for i in range(len(arr)):\n            dp[i][i] = arr[i]\n            \n        for l in range(1,len(arr)):\n            for i in range(0,len(arr)-l):\n                j = i + l\n                for k in range(i,j):\n                    dp[i][j] = min(dp[i][j], (dp[i][k] if i<k else 0) + (dp[k+1][j] if k+1<j else 0) + max(arr[i:k+1]) * max(arr[k+1:j+1]))\n                                   \n        return dp[0][len(arr)-1]\n    \n    '''\n    We calculate the largest leaf value for each possible subtree containing leaf i to j, denoted by max_leaf_value[i,j].\n    We initialize max_leaf_value[i,i] = arr[i] and max_leaf_value[i,j] = 0 for i!=j.\n    '''", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        \n        def findMax(l, h):\n            return max(arr[l:h+1])\n        for l in range(1,n):\n            for i in range(n-l):\n                j = i+l\n                for k in range(i, j):\n                    tmp = dp[i][k] + dp[k+1][j] + findMax(i,k)* findMax(k+1, j)\n                    dp[i][j] = tmp if dp[i][j]==0 else min(dp[i][j], tmp)\n                    \n        return dp[0][-1]\n                    \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n=len(arr)\n        dp=[[float('inf') for i in range(n)] for j in range(n)]\n        \n        \n        mem={}\n        m=[[-float('inf') for i in range(n)] for j in range(n)]\n        \n        for i in range(n):\n            for j in range(i,n):\n                if i==j:\n                    m[i][j]=arr[i]\n                    continue\n                for k in range(i,j+1):\n                    m[i][j]=max(m[i][j],arr[k])\n                    \n        #print(m)\n        def rec(left,right):\n            if right-left==0:\n                return 0\n            elif (left,right) in mem:\n                return mem[(left,right)]\n            else:\n                ans=float('inf')\n                for k in range(left,right):\n                    ans=min(ans,rec(left,k)+rec(k+1,right)+m[left][k]*m[k+1][right])\n                mem[(left,right)]=ans\n                return ans\n        #print(mem)\n        return rec(0,n-1)", "class Solution:\n    def mctFromLeafValues(self, a: List[int]) -> int:\n        n = len(a)\n        cache =[[[-1,-1]]*n for i in range(n)]\n        def dp(i,j):\n            if(i==j):\n                return [0,a[i]]\n            if(cache[i][j] != [-1,-1]):\n                return cache[i][j]\n            ans = float('inf')\n            mx = 0\n            for k in range(i,j):\n                l = dp(i,k)\n                r = dp(k+1,j)\n                mx = max(mx,l[1])\n                mx = max(mx,r[1])\n                ans = min(ans,l[0]+r[0]+l[1]*r[1])\n            cache[i][j] = [ans,mx]\n            return [ans,mx]\n        # print(cache)\n        return dp(0,n-1)[0]", "class Solution:\n    def mctFromLeafValues(self, A: List[int]) -> int:\n        '''\n        dp(i, j) = dp(i, k) + dp(k, j)\n        '''\n        @lru_cache(None)\n        def dp(i, j):\n            if i == j: \n                return 0\n            min_cost = float('inf')\n            for k in range(i, j):\n                min_cost = min(min_cost, dp(i, k) + dp(k+1, j) + max(A[i:k+1]) * max(A[k+1:j+1])) \n            return min_cost\n            \n        return dp(0, len(A) - 1)", "class Solution:\n    def ans(self,start,end,arr,dp):\n        product=999999999999999\n        maxleaf=-1\n        if start==end:\n            return arr[start],0\n        for i in range(start,end):\n            if (start,end) in dp:\n                return dp[(start,end)]\n            a,b=self.ans(start,i,arr,dp)\n            c,d=self.ans(i+1,end,arr,dp)\n            maxleaf=max(a,c)\n            product=min(product,a*c+b+d)\n        dp[(start,end)]=(maxleaf,product)\n        return maxleaf,product\n            \n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp={}\n        return self.ans(0,len(arr)-1,arr,dp)[1]\n            \n            \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        @lru_cache(maxsize=None)\n        def helper(start, end):\n            if start >= end:\n                return 0\n            \n            result = float('inf')\n            for i in range(start, end):\n                rootVal = max(arr[start:i + 1]) * max(arr[i + 1:end + 1])\n                result = min(result, rootVal + helper(start, i) + helper(i + 1, end))\n            return result\n        return helper(0, len(arr) - 1)", "\nclass Solution:\n    def __init__(self):\n        self.vals = None\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self.vals = [[0]*(len(arr)+1) for i in range(len(arr))]\n        return self.mctHelp(arr, 0, len(arr))\n        \n    def mctHelp(self, arr, a, b):\n        if b-a == 1:\n            return 0\n        if self.vals[a][b] == 0:\n            low= 2**30\n            for i in range(a+1, b):\n                res = self.mctHelp(arr, a, i) + self.mctHelp(arr, i, b) + (max(arr[a:i])*max(arr[i:b]))\n                if res < low:\n                    low = res\n            self.vals[a][b] = low\n        return self.vals[a][b]", "import numpy as np\nclass Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = np.diag(arr)\n\n        for distance in range(1,n):\n            for i in range(n-distance):\n                #calculate dp[i+distance,i] record the maximal number between i,i+distance\n                if dp[i+distance-1,i]<= dp[i+distance,i+distance]:\n                    dp[i+distance,i] = dp[i+distance,i+distance]\n                else: dp[i+distance,i] = dp[i+distance-1,i]\n\n                #calculate dp[i,i+distance] record the smallest sum between i,i+distance\n                if distance==1:\n                    minvalue = dp[i,i]*dp[i+distance,i+1]\n                else:\n                    minvalue = dp[i,i]*dp[i+distance,i+1]+dp[i+1,i+distance]\n                for j in range(1,distance):\n                    #[i,i+j] and [i+j+1,i+distance]\n                    if j==distance-1:\n                        tempvalue = dp[i+j,i]*dp[i+distance,i+j+1]+dp[i,i+j]\n                    else:\n                        tempvalue = dp[i+j,i]*dp[i+distance,i+j+1]+dp[i,i+j]+dp[i+j+1,i+distance]\n                    if tempvalue<=minvalue:\n                        minvalue=tempvalue\n                dp[i,i+distance] = minvalue\n        return dp[0,n-1]\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        while len(arr) > 1:\n            v = min(arr)\n            idx = arr.index(v)\n            res += min(arr[idx-1:idx] + arr[idx+1:idx+2]) * arr[idx]\n            arr.pop(idx)\n            \n        return res", "\nclass Solution:\n    def __init__(self):\n        self.vals = None\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self.vals = [[0]*len(arr) for i in range(len(arr))]\n        return self.mctHelp(arr, 0, len(arr))\n        \n    def mctHelp(self, arr, a, b):\n        if b-a == 1:\n            return 0\n        if self.vals[a][b-1] == 0:\n            low= 2**30\n            for i in range(a+1, b):\n                res = self.mctHelp(arr, a, i) + self.mctHelp(arr, i, b) + (max(arr[a:i])*max(arr[i:b]))\n                if res < low:\n                    low = res\n            self.vals[a][b-1] = low\n        return self.vals[a][b-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        '''\n        We can use an upper triangular matrix to represent the tree structure.\n        Each diagonal element stores the value of a leaf node.        \n        We calculate the largest leaf value for each possible subtree containing leaf i to j, denoted by max_leaf_value[i,j].\n        We initialize max_leaf_value[i,i] = arr[i] and max_leaf_value[i,j] = 0 for i!=j.\n        We store this value in the corresponding off-diagonal element.\n        Let dp[i,j] denote the smallest possible sum of the values of each non-leaf node of the subtree containing leaf i to j.\n        We initialize dp[i,j] = inf, i<j.\n        We can apply dynamic programming in the following way:\n        dp[i,j] = min(d[i,j], d[i,k] + d[k+1,j] + max_leaf_value[i,k] * max_leaf_value[k+1,j]) for k=i,...,j-1\n        '''    \n        dp = [[float('inf') for i in range(len(arr))] for j in range(len(arr))]\n        \n        \n        for i in range(0, len(arr)):            \n            dp[i][i] = 0\n        \n              \n        for l in range(2, len(arr)+1):        \n            for i in range(0, len(arr) - l + 1):                                                    \n                \n                j = i + l - 1\n   \n                for k in range(i, j):\n                                      \n                    ans =max(max(arr[i:k+1]), 0) * max(max(arr[k+1:j+1]), 0) + dp[i][k] + dp[k+1][j]                   \n                    dp[i][j] = min(dp[i][j], ans)\n                \n    \n        return dp[0][len(arr) - 1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        \n        def partition(arr, left, right, cache):\n            if (left, right) in cache:\n                return cache[(left, right)]\n            if left >= right:\n                return 0\n            result = sys.maxsize\n            for k in range(left, right):\n                \n                root_val = max(arr[left:k+1]) * max(arr[k+1:right+1])\n                result = min(result, root_val + partition(arr, left, k, cache) + partition(arr, k+1, right, cache))\n            cache[(left, right)] = result\n            return result\n        \n        cache = {}\n        partition(arr, 0, n-1, cache)\n        return cache[(0, n-1)]", "class Solution:\n    def max(self, arr, l, r):\n        a = max(arr[l:r])\n        self.mdp[(l,r)] = a\n        return a\n    \n    def maxDp(self, arr, l , r):\n        a = self.mdp.get((l,r), None)\n        return self.max(arr, l, r) if a is None else a\n    \n    def mctFromSubArray(self, arr: List[int], l : int, r : int) -> int:\n        if l == r - 1:\n            return 0\n        if l == r - 2:\n            return arr[l] * arr[l + 1]\n        return min (self.maxDp(arr, l, k) * self.maxDp(arr, k, r) + self.mctFromSubArrayDp(arr, l, k) + self.mctFromSubArrayDp(arr, k, r) for k in range(l + 1, r))\n    \n    def mctFromSubArrayDp(self, arr: List[int], l : int, r : int) -> int:\n        if (l, r) in self.dp:\n            return self.dp[(l, r)]\n        ans = self.mctFromSubArray(arr, l, r)\n        self.dp[(l, r)] = ans\n        return ans\n        \n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self.dp = {}\n        self.mdp = {}\n        return self.mctFromSubArrayDp(arr, 0, (len(arr)))\n    \n", "class Solution:\n    def mctFromSubArray(self, arr: List[int], l : int, r : int) -> int:\n        if l == r - 1:\n            return 0\n        if l == r - 2:\n            return arr[l] * arr[l + 1]\n        return min (max(arr[l:k]) * max(arr[k: r]) + self.mctFromSubArrayDp(arr, l, k) + self.mctFromSubArrayDp(arr, k, r) for k in range(l + 1, r))\n    \n    def mctFromSubArrayDp(self, arr: List[int], l : int, r : int) -> int:\n        if (l, r) in self.dp:\n            return self.dp[(l, r)]\n        ans = self.mctFromSubArray(arr, l, r)\n        self.dp[(l, r)] = ans\n        return ans\n        \n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self.dp = {}\n        return self.mctFromSubArrayDp(arr, 0, (len(arr)))\n    \n", "\nclass Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.helper(arr, 0, len(arr) - 1, {})\n        \n    def helper(self, arr, l, r, cache):\n        if (l, r) in cache:\n            return cache[(l, r)]\n        if l >= r:\n            return 0\n        \n        res = float('inf')\n        for i in range(l, r):\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\n        \n        cache[(l, r)] = res\n        return res", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self. memo = {}\n        def dp(i,j):\n            if j<=i:\n                return 0\n            if (i,j) in self.memo:\n                return self.memo[(i,j)]\n            res = float('inf')\n            for k in range(i,j):\n                res = min(res,dp(i,k) + dp(k+1,j) + (max(arr[i:k+1])*max(arr[k+1:j+1])))\n            self.memo[(i,j)]=res\n            return self.memo[(i,j)]\n        return dp(0,len(arr)-1)", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n                \n        dp = [[float('inf') for i in range(len(arr))] for j in range(len(arr))]\n        \n        \n        for i in range(0, len(arr)):            \n            dp[i][i] = 0\n        \n              \n        for l in range(2, len(arr)+1):        \n            for i in range(0, len(arr) - l + 1):                                                    \n                \n                j = i + l - 1\n   \n                for k in range(i, j):\n                                      \n                    ans =max(max(arr[i:k+1]), 0) * max(max(arr[k+1:j+1]), 0) + dp[i][k] + dp[k+1][j]                   \n                    dp[i][j] = min(dp[i][j], ans)\n                \n    \n        return dp[0][len(arr) - 1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        res = 0\n        stack = [float('inf')]\n        \n        for a in arr:\n            while stack[-1] <= a:\n                m = stack.pop()\n                res += m * min(a,stack[-1])\n            stack.append(a)\n            \n        while len(stack) > 2:\n            res += stack.pop()*stack[-1]\n            \n        return res\n                \n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.mctHelp(arr, 0, len(arr), {})\n        \n    def mctHelp(self, arr, a, b, dic):\n        if b-a == 1:\n            dic[a,b] = 0\n        if (a,b) not in dic:\n            low = 2**31\n            for i in range(a+1, b):\n                res = max(arr[a:i])*max(arr[i:b]) + self.mctHelp(arr, a, i, dic) + self.mctHelp(arr, i, b, dic)\n                low = min(low, res)\n            dic[a,b] = low\n        return dic[a,b]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.helper(arr, 0, len(arr) - 1, {})\n        \n    def helper(self, arr, l, r, cache):\n        if (l, r) in cache:\n            return cache[(l, r)]\n        if l >= r:\n            return 0\n        \n        res = float('inf')\n        for i in range(l, r):\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\n        \n        cache[(l, r)] = res\n        return res", "class Solution:\n    def __init__(self):\n        self.dict = {}\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        return self.mctHelp(arr, 0, len(arr))\n        \n    def mctHelp(self, arr, a, b):\n        if b-a == 1:\n            self.dict[a,b] = 0\n        if (a,b) not in self.dict:\n            low = 2**31\n            for i in range(a+1, b):\n                res = max(arr[a:i])*max(arr[i:b]) + self.mctHelp(arr, a, i) + self.mctHelp(arr, i, b)\n                low = min(low, res)\n            self.dict[a,b] = low\n        return self.dict[a,b]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        table = {}\n        def dp(i, j):\n            if j == i:\n                return 0\n            if j == i+1:\n                return arr[i] * arr[j]\n            if (i, j) in table:\n                return table[(i, j)]\n            res = float('inf')\n            for k in range(i, j):\n                res = min(res, dp(i, k) + dp(k+1, j) + max(arr[i:k+1]) * max(arr[k+1:j+1]))\n            table[(i, j)] = res\n            return res\n        return dp(0, len(arr)-1)", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        dp = [[float('inf') for i in range(len(arr))] for _ in range(len(arr))]\n        \n        for i in range(0, len(arr)):\n            dp[i][i] = 0\n        \n        for i in range(0, len(arr)-1):\n            dp[i][i+1] = arr[i]*arr[i+1]\n            \n        for l in range(2, len(arr)+1):\n            for i in range(0, len(arr)-l):\n                j = i+l\n                for k in range(i+1, j+1):\n                    dp[i][j] = min(dp[i][j], max(arr[i:k])*max(arr[k:j+1]) + dp[i][k-1] + dp[k][j])\n        \n        return dp[0][-1]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        table = {}\n\n        def compute(lo, hi):\n            if hi - lo == 1:\n                return 0\n\n            cost = float('inf')\n            for i in range(lo + 1, hi):\n                left_key, right_key = f'{lo}-{i}', f'{i}-{hi}'\n\n                if table.get(left_key) is None:\n                    table[left_key] = compute(lo, i)\n                if table.get(right_key) is None:\n                    table[right_key] = compute(i, hi)\n\n                cost = min(cost, table[left_key] + table[right_key] + max(arr[lo: i]) * max(arr[i: hi]))\n\n            return cost\n\n        return compute(0, len(arr))\n", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        n = len(arr)\n        self.memo = {}\n        def dp(i, j):\n            if i >= j:\n                return 0\n            if (i,j) not in self.memo:\n                res = float('inf')\n                for k in range(i, j):\n                    res = min(res, dp(i, k) + dp(k+1, j) + max(arr[i:k+1]) * max(arr[k+1:j+1]))\n                self.memo[(i,j)] = res\n            return self.memo[(i,j)]\n        return dp(0, n-1)", "import math\n\nclass Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        self.memo = {}\n        def dp(i,j):\n            if i == j:\n                self.memo[(i,j)] = [0, arr[i]]\n                return self.memo[(i,j)]\n            \n            if (i,j) in self.memo:\n                return self.memo[(i,j)]\n            else:\n                local_max = -math.inf\n                local_sum = math.inf\n                for k in range(i, j):\n                    [left_sum, left_max] = dp(i,k)\n                    [right_sum, right_max] = dp(k+1,j)\n                    local_max = max(local_max, left_max, right_max)\n                    local_sum = min(local_sum, left_sum + right_sum + left_max * right_max)\n                \n                self.memo[(i,j)] = [local_sum, local_max]\n                return self.memo[(i,j)]\n\n        return dp(0,len(arr)-1)[0]", "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        # it's equivalent to merge adjacent pairs one by one\n        # every time we merge a pair, they become the bigger one\n        # and add the product to the result\n        \n        def to_remove():\n            cur_min = arr[0] * arr[1]\n            res = 0 if arr[0] < arr[1] else 1\n            for i in range(len(arr) - 1):\n                if arr[i] * arr[i + 1] < cur_min:\n                    cur_min = arr[i] * arr[i + 1]\n                    res = i if arr[i] < arr[i + 1] else i + 1\n            return res\n        res = 0\n        while len(arr) > 1:\n            i = to_remove()\n            res += min(arr[i - 1:i] + arr[i + 1:i + 2]) * arr.pop(i)\n        \n        return res\n        \n        res = 0\n        while len(arr) > 1:\n            i = arr.index(min(arr))\n            res += min(arr[i - 1:i] + arr[i + 1:i + 2]) * arr.pop(i)\n            print(res, arr)\n        return res"]
["# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn, = list(map(int, readline().split()))\np = [-1] + [*list(map(int, readline().split()))]\n\nMOD = 10**9+7\nchild = [[] for i in range(n+1)]\ntot = [None for i in range(n+1)]\none = [None for i in range(n+1)]\ndep = [0]*(n+1)\np2 = [1]*(n+1)\nfor i in range(n):\n    p2[i+1] = p2[i]*2%MOD\n\nfor v in range(n,-1,-1):\n    if dep[v]==0:\n        tot[v] = []\n        one[v] = []\n    else:\n        child[v].sort(key=lambda i: dep[i])\n        one[v] = one[child[v][-1]]\n        tot[v] = tot[child[v][-1]]\n        #one_sum = [0]*(dep[v])\n        #zero_sum = [0]*(dep[v])\n        child[v].pop()\n        if child[v]:\n            zero = [p2[tot[v][j]]-one[v][j] for j in range(-len(one[child[v][-1]]),0)]\n        for c in child[v]:\n            for j in range(-len(one[c]),0):\n                z = p2[tot[c][j]]-one[c][j]\n                one[v][j] = (one[v][j]*z+zero[j]*one[c][j])%MOD\n                zero[j] = zero[j]*z%MOD\n                tot[v][j] += tot[c][j]\n\n    tot[v].append(1)\n    one[v].append(1)\n\n    child[p[v]].append(v)\n    dep[p[v]] = max(dep[p[v]],dep[v]+1)        \n\n    #print(v,tot[v],one[v])\n        \n#print(\"tot\",tot[0])\n#print(\"one\",one[0])\n\nans = 0\nfor i,j in zip(tot[0],one[0]):\n    ans += pow(2,n+1-i,MOD)*j%MOD\n\nprint((ans%MOD))\n#print(sum(tot[0]))\n", "\n\"\"\"\n\nhttps://atcoder.jp/contests/arc086/tasks/arc086_c\n\n\u5bfe\u6d88\u6ec5\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u306e\u306f\u540c\u3058\u6df1\u3055\u306e\u70b9\u306b\u7f6e\u304b\u308c\u305f\u30d3\u30fc\u7389\u3060\u3051\n\u21921\u3064\u3082\u6b8b\u3089\u306a\u3044 or 1\u3064\u3060\u3051\u6b8b\u308b\u3067\u3042\u308b\n\n\u3059\u306a\u308f\u3061\u3001\u3042\u308b\u6df1\u3055\u306b\u95a2\u3057\u3066\u3001\u305d\u306e\u3046\u30611\u3064\u6b8b\u308b\u306e\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6570\u3048\u308c\u3070\u3088\u3044\n\n1\u3064\u3060\u3051\u7f6e\u304f\u5834\u5408\u2192\u7d76\u5bfe\u306e\u3053\u308b\n2\u3064\u7f6e\u304f\u5834\u5408\u2192\u7d76\u5bfe\u6d88\u3048\u308b\n3\u3064\u7f6e\u304f\u5834\u5408\u21923\u3064\u306eLCA\u304c\u7b49\u3057\u304f\u306a\u3051\u308c\u3070\u6b8b\u308b\n\n\u6728dp\u307f\u305f\u3044\u306b\u3059\u308b\uff1f\ndp[0] = \u4e00\u3064\u3082\u542b\u3093\u3067\u3044\u306a\u3044\u5834\u5408\u306e\u901a\u308a\u6570\ndp[1] = 1\u3064\u542b\u3093\u3067\u3044\u308b\u5834\u5408\u306e\u901a\u308a\u6570\n\ndp[0] = \u3059\u3079\u3066\u306e\u5834\u5408 - dp[1]\ndp[1] = 1\u3064\u3060\u30511\u3092\u6301\u3063\u3066\u3044\u308b\u5834\u5408\n\n\u3067\u3001\u5b50\u304b\u3089\u89aa\u306b\u4f1d\u64ad\u3055\u305b\u3066\u3044\u304f\u2026\uff1f\n\u30de\u30fc\u30b8\u30c6\u30af\u3067\u8a08\u7b97\u91cf\u524a\u6e1b\u304b\uff1f\n3s\u3060\u304b\u3089\u305d\u3046\u3063\u307d\u3044\u306a\u2026\n3\u3064\u4ee5\u4e0a\u306e\u30de\u30fc\u30b8\u66f8\u304f\u306e\u3060\u308b\u3059\u304e\u3093\uff1f\n\n\u307e\u305f\u306f\u30de\u30fc\u30b8\u306e\u9806\u756a\u3092\u3069\u3063\u304b\u306b\u30e1\u30e2\u3063\u3066\u304a\u304f\n\nmaxd-d = index\u3067\u3084\u308b\n\u6700\u9577\u306e\u3084\u3064\u306b\u30de\u30fc\u30b8\u3059\u308b\n\ndp[maxd-d][1] = 1\u3064\u3060\u3051\u5143\u6df1\u3055d\u304c\u6b8b\u3063\u3066\u3044\u308b\u5834\u5408\u306e\u6570\nc = \u5b50\u306e\u6570\n\n\u8a08\u7b97\u91cf\u306f\uff1f\n\u30b5\u30a4\u30ba\u306f\u9ad8\u30051\u3057\u304b\u5897\u3048\u306a\u3044\u306e\u3067\u53ef\u80fd\u3063\u307d\u3044\n2\u500d\u51e6\u7406\u304c\u307e\u305a\u3044\n\n\u3082\u3063\u3068\u7c21\u6f54\u306b\uff1f\n\u5358\u4e00\u306ed\u3060\u3051\u3067\u8003\u3048\u3088\u3046\n2\u500d\u51e6\u7406\u306a\u3093\u3066\u3057\u306a\u3044\n\u6700\u5f8c\u306b\u5404d\u306b\u95a2\u3057\u3066\u304b\u3051\u308c\u3070\u3044\u3044\n\u2192\u3059\u308b\u3068\u30de\u30fc\u30b8\u306e\u969b\u306b2\u756a\u76ee\u306e\u5927\u304d\u3055\u3060\u3051\u3067\u306a\u3093\u3068\u304b\u306a\u308b\n\n\u5fc5\u8981\u306e\u306a\u3044\u30de\u30fc\u30b8\u3092\u3057\u306a\u3044\n\u4e21\u65b9\u306b\u95a2\u4fc2\u306a\u3044d\u306f\u64cd\u4f5c\u3057\u306a\u3044\n\u3080\u3057\u308d\u3070\u3089\u3064\u304d\u306f\u6df1\u3044\u90e8\u5206\u306b\u3060\u3051\u5b58\u5728\u3059\u308b\u304b\n\u6d45\u3044\u90e8\u5206\u306f\u5171\u901a\u3002\u3088\u3063\u3066-x\u3067\u7ba1\u7406\u3059\u308c\u3070\u3044\u3044\u304b\n\n\"\"\"\n\nimport sys\nmod = 10**9 + 7\nsys.setrecursionlimit(200000)\n\nfrom collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n\n    return ret,plis\n\ndef inverse(a): #a\u306emod\u3092\u6cd5\u306b\u3057\u305f\u9006\u5143\u3092\u8fd4\u3059\n    return pow(a,mod-2,mod)\n\n\ndef dfs(v):\n\n    if len(lis[v]) == 0:\n        ret = [ [1,1] ]\n        return ret\n\n    else:\n\n        retlis = []\n        for nex in lis[v]:\n            nret = dfs(nex)\n            retlis.append( [len(nret),nret] )\n        retlis.sort()\n\n        #1\u3064\u3057\u304b\u306a\u3044\u5834\u5408\u30de\u30fc\u30b8\u3057\u306a\u3044\n        if len(retlis) == 1:\n            retlis[-1][1].append([1,1])\n            return retlis[-1][1]\n\n        #2\u3064\u4ee5\u4e0a\u306e\u5834\u5408\u6700\u5927\u306e\u3084\u3064\u306b\u30de\u30fc\u30b8\u3059\u308b\n        for revd in range(retlis[-2][0]):\n\n            zmul = 1\n            amul = 1\n            for i in range(len(retlis)-1,-1,-1):\n                if revd < retlis[i][0]:\n                    zmul *= retlis[i][1][-1-revd][0]\n                    amul *= sum(retlis[i][1][-1-revd])\n                    zmul %= mod\n                    amul %= mod\n                else:\n                    break\n\n            nsum = 0\n            for i in range(len(retlis)-1,-1,-1):\n                if revd < retlis[i][0]:\n                    nsum += zmul * inverse(retlis[i][1][-1-revd][0]) * retlis[i][1][-1-revd][1]\n                    nsum %= mod\n                else:\n                    break\n\n            retlis[-1][1][-1-revd][1] = nsum\n            retlis[-1][1][-1-revd][0] = (amul-nsum) % mod\n\n        retlis[-1][1].append([1,1])\n        return retlis[-1][1]\n\nN = int(input())\np = list(map(int,input().split()))\n\nlis = [ [] for i in range(N+1) ]\n\nfor i in range(N):\n\n    #lis[i+1].append(p[i])\n    lis[p[i]].append(i+1)\n\ndlis,plis = NC_Dij(lis,0)\nmaxd = max(dlis)\n\ndn = [0] * (maxd+1)\nfor i in dlis:\n    dn[i] += 1\n\nans = dfs(0)\n#print (dn,ans)\nA = 0\nfor i in range(maxd+1):\n    A += ans[-1-i][1] * pow(2,N+1-dn[i],mod)\n    A %= mod\nprint (A)\n", "import sys\nreadline = sys.stdin.readline\n\n \ndef parorder(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[p] = -1\n    stack = [p]\n    order = []\n    visited = set([p])\n    ast = stack.append\n    apo = order.append\n    while stack:\n        vn = stack.pop()\n        apo(vn)\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            ast(vf)\n    return par, order\n \ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n \n \n \nMOD = 10**9+7\nlimit = 1341398\np2 = [1]*limit\nfor i in range(1, limit):\n    p2[i] = 2*p2[i-1]%MOD\n\nN = int(readline())\nP = [None] + list(map(int, readline().split()))\nEdge = [[] for _ in range(N+1)]\nfor i in range(1, N+1):\n    Edge[i].append(P[i])\n    Edge[P[i]].append(i)\n_, L = parorder(Edge, 0)\nC = getcld(P)\ndist = [0]*(N+1)\nfor l in L[1:]:\n    p = P[l]\n    dist[l] = 1 + dist[p]\nmd = dist[:]\nfor l in L[:0:-1]:\n    p = P[l]\n    md[p] = max(md[p], md[l])\n\nCi = [None]*(N+1)\nfor i in range(N+1):\n    if C[i]:\n        res = -1\n        cc = None\n        for ci in C[i]:\n            if md[ci] > res:\n                res = md[ci]\n                cc = ci\n    Ci[i] = cc\nans = 0\n\nres = [[0]]\nval = [1]*(N+1) \nsize = [1]*(N+1) \nused = [0]*(N+1)\nname = [None]*(N+1)\nmark = [None]*(N+1)\nwhile res:\n    newres = []\n    for a in res:\n        ts = 1\n        ks = 0\n        ss = 0\n        dic = []\n        ctr = []\n\n        for i in a:\n            ts = ts*(p2[size[i]] - val[i])%MOD\n            ks = (ks + val[i]*pow(p2[size[i]] - val[i], MOD-2, MOD))%MOD\n            ss += size[i]\n\n            if not used[i]:\n                used[i] = 1\n                if C[i]:\n                    dic.append(C[i])\n                    if name[i] is None:\n                        name[i] = Ci[i]\n            if name[i] is not None:\n                ctr.append(name[i])\n        newres.extend(dic)\n        if len(ctr) > 1:\n            newres.append(ctr)\n        for a0 in a:\n            val[a0] = ts*ks%MOD\n            size[a0] = ss\n    ans = (ans + val[a0]*p2[N+1 - size[a0]])%MOD\n    res = [nr[:] for nr in newres]\n    #print(res)\nprint(ans)\n\n\"\"\"\ndef merge(sz, vl):\n    res = 0\n    ts = 1\n    ks = 0\n    for s, v in zip(sz, vl):\n        ts = ts*(p2[s] - v)%MOD\n        ks = (ks + v*pow(p2[s] - v, MOD-2, MOD))%MOD\n    return ts*ks%MOD\n\n\n\nassert N < 2000\n\nst = [0]\naa = 0\nwhile st:\n    size = [0]*(N+1)\n    val = [0]*(N+1)\n    cs = [[] for _ in range(N+1)]\n    cv = [[] for _ in range(N+1)]\n    \n    nr = []\n    for s in st:\n        cs[s] = [1]\n        cv[s] = [1]\n        nr.extend(C[s])\n    for l in L[::-1]:\n        size[l] = sum(cs[l])\n        val[l] = merge(cs[l], cv[l])\n        if l:\n            p = P[l]\n            cs[p].append(size[l])\n            cv[p].append(val[l])\n    aa = (aa + val[0]*p2[N+1 - size[0]])%MOD\n    st = nr[:]\n\nprint(aa)\n\"\"\"\n    \n", "from collections import deque\n\n\ndef get_pow():\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            cache[x] = pow(2, x, mod)\n        return cache[x]\n\n    return func\n\n\nmod = 1000000007\nn = int(input())\nparents = list(map(int, input().split()))\nchildren = [set() for _ in range(n + 1)]\nfor c, p in enumerate(parents):\n    children[p].add(c + 1)\n\nlevels = [{0}]\nwhile True:\n    level = set()\n    for p in levels[-1]:\n        level.update(children[p])\n    if not level:\n        break\n    levels.append(level)\nlevels.reverse()\n\nlevel_node_count = []\nballs = [None] * (n + 1)\n\nfor i, level in enumerate(levels):\n    level_node_count.append(len(level))\n    for node in level:\n        cn = children[node]\n        if cn:\n            if len(cn) == 1:\n                bs = balls[cn.pop()]\n                bs.appendleft([1, 1, 0])\n                balls[node] = bs\n                continue\n            balls_from_children = [balls[c] for c in children[node]]\n            balls_from_children.sort(key=len)\n            bs1 = balls_from_children[0]\n            for bs2 in balls_from_children[1:]:\n                for (b10, b11, b12), b2 in zip(bs1, bs2):\n                    b2[2] = ((b11 + b12) * b2[1] + b12 * b2[0]) % mod\n                    b2[1] = (b10 * b2[1] + b11 * b2[0]) % mod\n                    b2[0] = b2[0] * b10 % mod\n                bs1 = bs2\n            for b in bs1:\n                b[0] = (b[0] + b[2]) % mod\n                b[2] = 0\n            bs1.appendleft([1, 1, 0])\n            balls[node] = bs1\n        else:\n            balls[node] = deque([[1, 1, 0]])\n\nlevel_node_count.reverse()\n\npow2 = get_pow()\nprint((sum(b[1] * pow2(n - l + 1) % mod for l, b in zip(level_node_count, balls[0])) % mod))\n", "from collections import deque\n\n\ndef get_pow():\n    cache = {}\n\n    def func(x):\n        if x not in cache:\n            cache[x] = pow(2, x, mod)\n        return cache[x]\n\n    return func\n\n\nmod = 1000000007\nn = int(input())\nparents = list(map(int, input().split()))\nchildren = [set() for _ in range(n + 1)]\nfor c, p in enumerate(parents):\n    children[p].add(c + 1)\n\nlevels = [{0}]\nwhile True:\n    level = set()\n    for p in levels[-1]:\n        level.update(children[p])\n    if not level:\n        break\n    levels.append(level)\nlevels.reverse()\n\nlevel_node_count = []\nballs = [None] * (n + 1)\n\nfor i, level in enumerate(levels):\n    level_node_count.append(len(level))\n    for node in level:\n        cn = children[node]\n        if cn:\n            if len(cn) == 1:\n                bs = balls[cn.pop()]\n                bs.appendleft([1, 1, 0])\n                balls[node] = bs\n                continue\n            balls_from_children = [balls[c] for c in children[node]]\n            balls_from_children.sort(key=len)\n            bs1 = balls_from_children[0]\n            for bs2 in balls_from_children[1:]:\n                for (b10, b11, b12), b2 in zip(bs1, bs2):\n                    b2[2] = ((b11 + b12) * b2[1] + b12 * b2[0]) % mod\n                    b2[1] = (b10 * b2[1] + b11 * b2[0]) % mod\n                    b2[0] = b2[0] * b10 % mod\n                bs1 = bs2\n            lim = len(balls_from_children[-2])\n            for i, b in enumerate(bs1):\n                if i >= lim:\n                    break\n                b[0] = (b[0] + b[2]) % mod\n                b[2] = 0\n            bs1.appendleft([1, 1, 0])\n            balls[node] = bs1\n        else:\n            balls[node] = deque([[1, 1, 0]])\n\nlevel_node_count.reverse()\n\npow2 = get_pow()\nprint((sum(b[1] * pow2(n - l + 1) % mod for l, b in zip(level_node_count, balls[0])) % mod))\n", "# seishin.py\nfrom collections import deque\nN = int(input())\n*P, = list(map(int, input().split()))\nMOD = 10**9 + 7\n\nG = [[] for i in range(N+1)]\nU = [0]*(N+1)\nC = [0]*(N+1)\nfor i, p in enumerate(P):\n    G[p].append(i+1)\n    U[i+1] = u = U[p]+1\n    C[u] += 1\nQ = [None]*(N+1)\nPP = {}\ndef pp(k):\n    if k not in PP:\n        PP[k] = p = pow(2, k, MOD)\n        return p\n    return PP[k]\nL = [0]*(N+1)\n\nept = []\nsz = L.__getitem__\nfor i in range(N, -1, -1):\n    g = G[i]\n    if not g:\n        continue\n\n    # \u5b50\u30ce\u30fc\u30c9\u306edeque\u3092\u96c6\u3081\u308b\n    g.sort(key=sz, reverse=1)\n    k = len(g)\n    e = [pp(k) - k, k, 0]\n\n    g0 = g[0]\n    L[i] = L[g0] + 1\n    if L[g0] == 0:\n        Q[i] = deque([e])\n        continue\n    Q[i] = R = Q[g0]\n    if k > 1:\n        # a0 <- a2\n        for s, r in zip(Q[g[1]] or ept, R):\n            r[0] += r[2]; r[2] = 0\n\n        for j in g[1:]:\n            S = Q[j]\n            if not S:\n                break\n\n            # deque\u306e\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5927\u304d\u3044\u65b9\u3078\u30de\u30fc\u30b8\u3059\u308b\u51e6\u7406\n            for (a0, a1, a2), r in zip(S, R):\n                b0, b1, b2 = r; a0 += a2\n                r[0] = a0*b0 % MOD\n                r[1] = (a0*b1 + a1*b0) % MOD\n                r[2] = ((a0+a1)*b2 + a1*b1) % MOD\n    R.appendleft(e)\nprint(((pp(N) + sum(pp(N+1-c) * a1 % MOD for (a0, a1, a2), c in zip(Q[0], C[1:]))) % MOD))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import deque\n\nMOD = 10 ** 9 + 7\n\nN = int(input())\ngraph = [[] for _ in range(N+1)]\nfor i,x in enumerate(input().rstrip().split(),1):\n    x = int(x)\n    graph[i].append(x)\n    graph[x].append(i)\n\n# \u5404\u6df1\u3055\u304b\u3089\u6765\u3066\u3044\u308b (0\u500b\u30011\u500b\u30012\u500b\u4ee5\u4e0a) \u306e\u5206\u5e03\u3092 \u78ba\u7387 mod MOD\u3067\u6301\u3064\u3002\n\nhalf = (MOD + 1) // 2\n\ndef merge(dp,dp1):\n    L = len(dp1)\n    for i in range(L):\n        # 0\u500b,1\u500b,2\u500b\u4ee5\u4e0a\n        a,b,c = dp[i]\n        d,e,f = dp1[i]\n        a,b,c = a*d, a*e + b*d, a*f + b*e + b*f + c*d + c*e + c*f\n        a %= MOD\n        b %= MOD\n        c %= MOD\n        dp[i] = (a,b,c)\n    return\n\ndef dfs(v,parent = None):\n    dp = None\n    L = 0\n    for u in graph[v]:\n        if u == parent:\n            continue\n        dp1 = dfs(u,v)\n        if dp is None:\n            dp = dp1\n        else:\n            if len(dp) < len(dp1):\n                dp,dp1 = dp1,dp\n            # 2\u500b\u4ee5\u4e0a\u304c\u5165\u3063\u3066\u3044\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n            if L < len(dp1):\n                L = len(dp1)\n            merge(dp,dp1)\n    if dp is None:\n        dp = deque()\n    else:\n        # 2\u500b\u4ee5\u4e0a\u3042\u308b\u3068\u304d\u306b\u30010\u500b\u5316\u3059\u308b\n        for i in range(L):\n            a,b,c = dp[i]\n            dp[i] = (a+c,b,0)\n    dp.appendleft((half,half,0))\n    return dp\n\ndp = dfs(0)\n\nanswer = sum(b for a,b,c in dp)\nanswer *= pow(2,N+1,MOD)\nanswer %= MOD\nprint(answer)", "import sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def dfs(u=0):\n        def merge(dpu, dpv):\n            vn = len(dpv)\n            for d in range(-1, -1 - vn, -1):\n                u0, u1, u2 = dpu[d]\n                v0, v1, v2 = dpv[d]\n                n0 = (u0 * v0) % md\n                n1 = (u0 * v1 + u1 * v0) % md\n                n2 = (u2 * (v0 + v1 + v2) + v2 * (u0 + u1) + u1 * v1) % md\n                dpu[d] = (n0, n1, n2)\n\n        # \u8449\u306e\u5834\u5408\n        if len(to[u]) == 0:\n            return [(inv2, inv2, 0)]\n        # \u3059\u3079\u3066\u306e\u5b50\u3092\u30de\u30fc\u30b8\n        dpu = []\n        mxlen=0\n        for v in to[u]:\n            dpv = dfs(v)\n            #\u6df1\u3055\u304c2\u6bb5\u4ee5\u4e0a\u3042\u3063\u305f\u3089u2\u3092u0\u306b\n            if not dpu:\n                dpu = dpv\n            else:\n                if len(dpu) < len(dpv): dpu, dpv = dpv, dpu\n                mxlen=max(mxlen,len(dpv))\n                merge(dpu, dpv)\n        for d in range(-1,-1-mxlen,-1):\n            u0,u1,u2=dpu[d]\n            dpu[d] = (u0 + u2, u1, 0)\n        dpu.append((inv2, inv2, 0))\n        return dpu\n\n    md = 10 ** 9 + 7\n    # 1/2\u306emod\n    inv2 = pow(2, md - 2, md)\n    n = int(input())\n    to = [[] for _ in range(n+1)]\n    pp = list(map(int, input().split()))\n    for i, p in enumerate(pp, 1):\n        to[p].append(i)\n    # print(to)\n    dp0 = dfs()\n    # print(dp0)\n    ans = sum(u1 for _, u1, _ in dp0)\n    print((ans * pow(2, n + 1, md)) % md)\n\nmain()\n", "n, = map(int, input().split())\np = [-1] + [*map(int, input().split())]\n\nMOD = 10**9+7\ndp = [[] for _ in range(n+1)]\ndep = [0]*(n+1)\nnxt = [0]*(n+1)\n\nfor v in range(n,0,-1):\n    _,nxt[p[v]],dep[p[v]] = sorted([nxt[p[v]],dep[p[v]],dep[v]+1])\n\ntot = [0]*(dep[0]+1)\nfor i in range(n+1): tot[dep[i]] += 1\n\ndef merge(p,v):\n    if len(dp[p]) < len(dp[v]):\n        dp[p],dp[v]=dp[v],dp[p]\n    for i in range(-len(dp[v]),0):\n        a,b,c = dp[p][i]\n        d,e,f = dp[v][i]\n        dp[p][i][:] = [a*d%MOD,(b*d+a*e)%MOD,c*f%MOD]\n\nfor v in range(n,-1,-1):\n    dp[v].append([1,1,2])\n    for i in range(-nxt[v]-1,0):\n        dp[v][i][0] = dp[v][i][2] - dp[v][i][1]\n    if v: merge(p[v],v)\n\nans = 0\nfor d in dp[0]:\n    ans += pow(d[2],MOD-2,MOD)*d[1]%MOD\nprint(ans*pow(2,n+1,MOD)%MOD)", "# seishin.py\nfrom collections import deque\nN = int(input())\n*P, = map(int, input().split())\nMOD = 10**9 + 7\n\nG = [[] for i in range(N+1)]\nU = [0]*(N+1)\nC = [0]*(N+1)\nfor i, p in enumerate(P):\n    G[p].append(i+1)\n    U[i+1] = u = U[p]+1\n    C[u] += 1\nQ = [None]*(N+1)\nPP = {}\ndef pp(k):\n    if k not in PP:\n        PP[k] = p = pow(2, k, MOD)\n        return p\n    return PP[k]\nL = [0]*(N+1)\n\nept = []\nsz = L.__getitem__\nfor i in range(N, -1, -1):\n    g = G[i]\n    if not g:\n        continue\n\n    # \u5b50\u30ce\u30fc\u30c9\u306edeque\u3092\u96c6\u3081\u308b\n    g.sort(key=sz, reverse=1)\n    k = len(g)\n    e = [pp(k) - k, k, 0]\n\n    g0 = g[0]\n    L[i] = L[g0] + 1\n    if L[g0] == 0:\n        Q[i] = deque([e])\n        continue\n    Q[i] = R = Q[g0]\n    if k > 1:\n        # a0 <- a2\n        for s, r in zip(Q[g[1]] or ept, R):\n            r[0] += r[2]; r[2] = 0\n\n        for j in g[1:]:\n            S = Q[j]\n            if not S:\n                break\n\n            # deque\u306e\u5c0f\u3055\u3044\u65b9\u304b\u3089\u5927\u304d\u3044\u65b9\u3078\u30de\u30fc\u30b8\u3059\u308b\u51e6\u7406\n            for (a0, a1, a2), r in zip(S, R):\n                b0, b1, b2 = r; a0 += a2\n                r[0] = a0*b0 % MOD\n                r[1] = (a0*b1 + a1*b0) % MOD\n                r[2] = ((a0+a1)*b2 + a1*b1) % MOD\n    R.appendleft(e)\nprint((pp(N) + sum(pp(N+1-c) * a1 % MOD for (a0, a1, a2), c in zip(Q[0], C[1:]))) % MOD)"]
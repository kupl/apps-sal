["import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nN, Q = map(int, input().split())\n\npath = [[] for _ in range(N)]\n\nfor _ in range(N-1) :\n    a, b, c, d = (int(i) for i in input().split())\n    path[a-1].append((b-1, c-1, d))\n    path[b-1].append((a-1, c-1, d))\n\n# doubling\u306b\u5fc5\u8981\u306aK\u3092\u6c42\u3081\u308b\nfor K in range(18) :\n    if 2 ** K >= N :\n        break\n\n# dfs\nparent = [[-1] * N for _ in range(K)]\nrank = [-1 for _ in range(N)]\n\nrank[0] = 0\nqueue = [0]\n\nwhile queue :\n    cur = queue.pop()\n    for nex, _, _ in path[cur] :\n        if rank[nex] < 0 :\n            queue.append(nex)\n            parent[0][nex] = cur\n            rank[nex] = rank[cur] + 1\n\n# doubling        \nfor i in range(1, K) :\n    for j in range(N) :\n        if parent[i-1][j] > 0 :\n            parent[i][j] = parent[i-1][parent[i-1][j]]\n\n# lca\ndef lca(a, b) :\n    if rank[a] > rank[b] :\n        a, b = b, a\n\n    diff = rank[b] - rank[a]\n    i = 0\n    while diff > 0 :\n        if diff & 1 :\n            b = parent[i][b]\n        diff >>= 1\n        i += 1\n        \n    if a == b :\n        return a\n\n    for i in range(K-1, -1, -1) :\n        if parent[i][a] != parent[i][b] :\n            a = parent[i][a]\n            b = parent[i][b]\n\n    return parent[0][a]\n\n# Query\u306e\u5148\u8aad\u307f\nschedule = [[] for _ in range(N)]\nfor i in range(Q) : \n    x, y, u, v = map(int, input().split())\n    x, u, v = x-1, u-1, v-1\n    l = lca(u, v)\n    schedule[u].append((i, 1, x, y))\n    schedule[v].append((i, 1, x, y))\n    schedule[l].append((i, -2, x, y))\n\nret = [0] * Q\nC = [0] * (N-1)\nD = [0] * (N-1)\n\ndef dfs(cur, pre, tot) :\n    for i, t, c, d in schedule[cur] :\n        ret[i] += t * (tot - D[c] + C[c] * d)\n    \n    for nex, c, d in path[cur] :\n        if nex == pre :\n            continue\n        C[c] += 1\n        D[c] += d\n        dfs(nex, cur, tot + d)\n        C[c] -= 1\n        D[c] -= d\n\ndfs(0, -1, 0)\n   \nfor i in range(Q) :\n    print(ret[i])", "import sys\nfrom itertools import combinations, permutations, product, combinations_with_replacement, accumulate\nfrom heapq import heapify, heappop, heappush, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, log, floor, ceil, factorial, cos, sin, pi#, gcd\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nLINF = 2**63-1\nNIL = -LINF\nMOD = 10**9+7\nMGN = 4\ndef AST(exp: bool, msg: str = \"\"): assert exp, msg\ndef TAST(exp: bool, msg = \"\"):\n    if exp is False: print(\"TAssertionError:\", msg)\n    while exp is False:\n        pass\ndef EPR(msg): print(msg, file=sys.stderr)\ndef II(): return int(input())\ndef IF(): return float(input())\ndef IS(): return input().replace('\\n', '')\ndef ILCI(n: int): return [II() for _ in range(n)]\ndef ILCF(n: int): return [IF() for _ in range(n)]\ndef ILI(): return list(map(int, input().split()))\ndef ILLI(n: int): return [[int(j) for j in input().split()] for i in range(n)]\ndef ILF(): return list(map(float, input().split()))\ndef ILLF(n: int): return [[float(j) for j in input().split()] for i in range(n)]\ndef LTOS(lst: list, sep: str = ' '): return sep.join(map(str, lst))\ndef DEC(lst: list): return list(map(lambda x: x-1, lst))\ndef INC(lst: list): return list(map(lambda x: x+1, lst))\n\nclass Queue:\n    def __init__(self) -> None:\n        self.items = deque()\n    def is_empty(self) -> bool:\n        return len(self.items) == 0\n    def enqueue(self, item) -> None:\n        self.items.appendleft(item)\n    def insert(self, item) -> None:\n        self.enqueue(item)\n    def dequeue(self):\n        return self.items.pop()\n    def front(self):\n        return self.items[-1]\n    def pop(self) -> None:\n        self.items.pop()\n    def size(self) -> int:\n        return len(self.items)\n\nclass LCA:\n    def __init__(self, N: int) -> None:\n        self.N = N\n        self.to = [[] for _ in range(N)]\n        self.co = [[] for _ in range(N)]\n        self.dep = [0] * N\n        self.costs = [0] * N\n        l = 0\n        while (1 << l) < N:\n            l += 1\n        self.l = l\n        self.par = [([0]*l) for _ in range(N+1)]\n    def add_edge(self, a: int, b: int, c = 0) -> None:\n        self.to[a].append(b)\n        self.co[a].append(c)\n        self.to[b].append(a)\n        self.co[b].append(c)\n    def _dfs(self, v: int, d: int = 0, c = 0, p: int = -1) -> None:\n        if p != -1:\n            self.par[v][0] = p\n        self.dep[v] = d\n        self.costs[v] = c\n        for i in range(len(self.to[v])):\n            u = self.to[v][i]\n            if u == p:\n                continue\n            else:\n                self._dfs(u, d+1, c+self.co[v][i], v)\n    def _bfs(self, root: int) -> None:\n        que = Queue()\n        que.enqueue(root)\n        self.dep[root] = 0\n        self.costs[root] = 0\n        vis = [False] * self.N\n        while que.is_empty() is False:\n            v = que.dequeue()\n            vis[v] = True\n            nd = self.dep[v] + 1\n            cs = self.costs[v]\n            for i in range(len(self.to[v])):\n                nv = self.to[v][i]\n                if vis[nv]:\n                    continue\n                else:\n                    que.enqueue(nv)\n                    self.dep[nv] = nd\n                    self.costs[nv] = cs + self.co[v][i]\n                    self.par[nv][0] = v\n    def init(self, root: int = 0) -> None:\n        self.root = root\n        self._bfs(root)\n        for i in range(self.l - 1):\n            for v in range(self.N):\n                self.par[v][i+1] = self.par[self.par[v][i]][i]\n    def lca(self, a: int, b: int) -> int:\n        dep_s, dep_l = self.dep[a], self.dep[b]\n        if dep_s > dep_l:\n            a, b = b, a\n            dep_s, dep_l = dep_l, dep_s\n        gap = dep_l - dep_s\n        L_1 = self.l-1\n        par = self.par\n        for i in range(L_1, -1, -1):\n            leng = 1 << i\n            if gap >= leng:\n                gap -= leng\n                b = par[b][i]\n        if a == b:\n            return a\n        for i in range(L_1, -1, -1):\n            na = par[a][i]\n            nb = par[b][i]\n            if na != nb:\n                a, b = na, nb\n        return par[a][0]\n    def length(self, a: int, b: int) -> int:\n        c = self.lca(a, b)\n        dep = self.dep\n        return dep[a] + dep[b] - dep[c] * 2\n    def dist(self, a: int, b: int):\n        c = self.lca(a, b)\n        costs = self.costs\n        return costs[a] + costs[b] - costs[c] * 2\n\n\ndef main():\n    N,Q = ILI()\n    gr = LCA(N)\n    es = [[] for _ in range(N)]\n    for i in range(N-1):\n        a,b, col, dist = ILI()\n        a -= 1; b -= 1\n        es[a].append((b, dist, col))\n        es[b].append((a, dist, col))\n        gr.add_edge(a, b, dist)\n\n    gr.init()\n    ans = [0] * Q\n    qs = [[] for _ in range(N)]\n    for i in range(Q):\n        cx,dy, a,b = ILI()\n        a -= 1; b -= 1\n        #ans[i] = gr.dist(a, b)\n        c = gr.lca(a, b)\n        ans[i] = gr.costs[a] + gr.costs[b] - gr.costs[c] * 2\n        qs[a].append((cx, i, 1, dy))\n        qs[b].append((cx, i, 1, dy))\n        qs[c].append((cx, i, -2, dy))\n\n    cnt = [0] * N\n    sum_ = [0] * N\n\n    def dfs(v: int, p: int = -1) -> None:\n        for (col,qid,coeff,dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n        \n        for (to, co, col) in es[v]:\n            if to == p:\n                continue\n            cnt[col] += 1\n            sum_[col] += co\n            dfs(to, v)\n            cnt[col] -= 1\n            sum_[col] -= co\n\n    dfs(0)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nimport numpy as np\n\nN,Q = map(int,input().split())\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b,c,d = map(int,input().split())\n    graph[a].append((b,c,d))\n    graph[b].append((a,c,d))\nquery = [[int(x) for x in input().split()] for _ in range(Q)]\n\ndef euler_tour(x, tour_v, tour_d, depth = 0, parent=None):\n    tour_v.append(x)\n    tour_d.append(depth)\n    for y, c, d in graph[x]:\n        if y == parent:\n            continue\n        euler_tour(y, tour_v, tour_d, depth + 1, parent = x)\n        tour_v.append(x)\n        tour_d.append(depth)\n\ntour_v = []\ntour_d = []\neuler_tour(1, tour_v, tour_d)\ntour_d_arr = np.array(tour_d)\nv_to_i = {v:i for i,v in enumerate(tour_v)}\nv_to_d = dict(zip(tour_v, tour_d))\n\n# sparse table\n# \u5404\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304b\u3089\u30012^i \u9805\u76ee\u5206\u898b\u3066\u3001\u4e00\u756adepth\u306e\u5c0f\u3055\u3044\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\nL = len(tour_v)\nU = L.bit_length()\nsp = [np.arange(L)]\nfor i in range(1,U):\n    prev = sp[-1]\n    width = 1 << (i-1)\n    n1 = prev[:-width]\n    n2 = prev[width:]\n    sp.append(np.where(tour_d_arr[n1] < tour_d_arr[n2], n1, n2))\n\ndef LCA(x,y):\n    ix = v_to_i[x]\n    iy = v_to_i[y]\n    if ix > iy:\n        ix,iy = iy,ix\n    items = iy - ix + 1\n    L = items.bit_length() - 1\n    n1 = sp[L][ix]\n    n2 = sp[L][iy - (1 << L) + 1]\n    n = n1 if tour_d[n1] < tour_d[n2] else n2\n    return tour_v[n]\n\ntasks = [[] for _ in range(N+1)]\nfor i,(x,y,u,v) in enumerate(query):\n    tasks[u].append((i,x,y,1))\n    tasks[v].append((i,x,y,1))\n    tasks[LCA(u,v)].append((i,x,y,-2))\n\nanswer = [0] * Q\n\ndef dfs(x = 1, sums = [0] * (N+1), nums = [0] * (N+1), total = 0, parent = 0):\n    for i,c,d,coef in tasks[x]:\n        answer[i] += coef * (total - sums[c] + nums[c] * d)\n    for y,c,d in graph[x]:\n        if y == parent:\n            continue\n        sums[c] += d\n        nums[c] += 1\n        total += d\n        dfs(y, sums, nums, total, x)\n        sums[c] -= d\n        nums[c] -= 1\n        total -= d\n    return\n\ndfs()\nprint('\\n'.join(map(str,answer)))", "import sys\nfrom itertools import combinations, permutations, product, combinations_with_replacement, accumulate\nfrom heapq import heapify, heappop, heappush, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, log, floor, ceil, factorial, cos, sin, pi#, gcd\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nLINF = 2**63-1\nNIL = -LINF\nMOD = 10**9+7\nMGN = 4\ndef AST(exp: bool, msg: str = \"\"): assert exp, msg\ndef TAST(exp: bool, msg = \"\"):\n    if exp is False: print(\"TAssertionError:\", msg)\n    while exp is False:\n        pass\ndef EPR(msg): print(msg, file=sys.stderr)\ndef II(): return int(input())\ndef IF(): return float(input())\ndef IS(): return input().replace('\\n', '')\ndef ILCI(n: int): return [II() for _ in range(n)]\ndef ILCF(n: int): return [IF() for _ in range(n)]\ndef ILI(): return list(map(int, input().split()))\ndef ILLI(n: int): return [[int(j) for j in input().split()] for i in range(n)]\ndef ILF(): return list(map(float, input().split()))\ndef ILLF(n: int): return [[float(j) for j in input().split()] for i in range(n)]\ndef LTOS(lst: list, sep: str = ' '): return sep.join(map(str, lst))\ndef DEC(lst: list): return list(map(lambda x: x-1, lst))\ndef INC(lst: list): return list(map(lambda x: x+1, lst))\n\nclass LCA:\n    def __init__(self, N: int) -> None:\n        self.N = N\n        self.to = [[] for _ in range(N)]\n        self.co = [[] for _ in range(N)]\n        self.dep = [0] * N\n        self.costs = [0] * N\n        l = 0\n        while (1 << l) < N:\n            l += 1\n        self.l = l\n        self.par = [([0]*l) for _ in range(N+1)]\n    def add_edge(self, a: int, b: int, c = 0) -> None:\n        self.to[a].append(b)\n        self.co[a].append(c)\n        self.to[b].append(a)\n        self.co[b].append(c)\n    def _dfs(self, v: int, d: int = 0, c = 0, p: int = -1) -> None:\n        if p != -1:\n            self.par[v][0] = p\n        self.dep[v] = d\n        self.costs[v] = c\n        for i in range(len(self.to[v])):\n            u = self.to[v][i]\n            if u == p:\n                continue\n            else:\n                self._dfs(u, d+1, c+self.co[v][i], v)\n    def init(self, root: int = 0) -> None:\n        self.root = root\n        self._dfs(root)\n        for i in range(self.l - 1):\n            for v in range(self.N):\n                self.par[v][i+1] = self.par[self.par[v][i]][i]\n    def lca(self, a: int, b: int) -> int:\n        dep_s, dep_l = self.dep[a], self.dep[b]\n        if dep_s > dep_l:\n            a, b = b, a\n            dep_s, dep_l = dep_l, dep_s\n        gap = dep_l - dep_s\n        L_1 = self.l-1\n        par = self.par\n        for i in range(L_1, -1, -1):\n            leng = 1 << i\n            if gap >= leng:\n                gap -= leng\n                b = par[b][i]\n        if a == b:\n            return a\n        for i in range(L_1, -1, -1):\n            na = par[a][i]\n            nb = par[b][i]\n            if na != nb:\n                a, b = na, nb\n        return par[a][0]\n    def length(self, a: int, b: int) -> int:\n        c = self.lca(a, b)\n        dep = self.dep\n        return dep[a] + dep[b] - dep[c] * 2\n    def dist(self, a: int, b: int):\n        c = self.lca(a, b)\n        costs = self.costs\n        return costs[a] + costs[b] - costs[c] * 2\n\ndef main():\n    N,Q = ILI()\n    gr = LCA(N)\n    es = [[] for _ in range(N)]\n    for i in range(N-1):\n        a,b, col, dist = ILI()\n        a -= 1; b -= 1\n        es[a].append((b, dist, col))\n        es[b].append((a, dist, col))\n        gr.add_edge(a, b, dist)\n\n    gr.init()\n    ans = [0] * Q\n    qs = [[] for _ in range(N)]\n    for i in range(Q):\n        cx,dy, a,b = ILI()\n        a -= 1; b -= 1\n        #ans[i] = gr.dist(a, b)\n        c = gr.lca(a, b)\n        ans[i] = gr.costs[a] + gr.costs[b] - gr.costs[c] * 2\n        qs[a].append((cx, i, 1, dy))\n        qs[b].append((cx, i, 1, dy))\n        qs[c].append((cx, i, -2, dy))\n\n    cnt = [0] * N\n    sum_ = [0] * N\n\n    def dfs(v: int, p: int = -1) -> None:\n        for (col,qid,coeff,dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n        \n        for (to, co, col) in es[v]:\n            if to == p:\n                continue\n            cnt[col] += 1\n            sum_[col] += co\n            dfs(to, v)\n            cnt[col] -= 1\n            sum_[col] -= co\n\n    dfs(0)\n\n    for an in ans:\n        print(an)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN, Q = list(map(int, input().split()))\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b, c, d = list(map(int, input().split()))\n    graph[a].append((b, c, d))\n    graph[b].append((a, c, d))\nquery = [[int(x) for x in input().split()] for _ in range(Q)]\n\ndepth = [0] * (N+1)\nU = 17\nancestor = [[0] * (U+1) for _ in range(N+1)]\n\nq = [(1, 0, 0)]\nwhile q:\n    qq = []\n    for x, d, parent in q:\n        depth[x] = d\n        ax = ancestor[x]\n        ax[0] = parent\n        for i in range(d.bit_length()-1):\n            ax[i+1] = ancestor[ax[i]][i]\n        for y, _, _ in graph[x]:\n            if y == parent:\n                continue\n            qq.append((y, d+1, x))\n    q = qq\n\ndef LCA(x, y):\n    dx = depth[x]\n    dy = depth[y]\n    if dx > dy:\n        x, y = y, x\n        dx, dy = dy, dx\n    diff = dy - dx\n    while diff:\n        step = diff & (-diff)\n        y = ancestor[y][step.bit_length()-1]\n        diff -= step\n    while x != y:\n        j = 0\n        while ancestor[x][j] != ancestor[y][j]:\n            j += 1\n        if j == 0:\n            return ancestor[x][0]\n        x = ancestor[x][j-1]\n        y = ancestor[y][j-1]\n    return x\n\ntasks = [[] for _ in range(N+1)]\nfor i, (x, y, u, v) in enumerate(query):\n    tasks[u].append((i, x, y, 1))\n    tasks[v].append((i, x, y, 1))\n    tasks[LCA(u, v)].append((i, x, y, -2))\n\nanswer = [0] * Q\n\ndef dfs(x = 1, sums = [0] * (N+1), nums = [0] * (N+1), total = 0, parent = 0):\n    for i, c, d, coef in tasks[x]:\n        answer[i] += coef * (total - sums[c] + nums[c] * d)\n    for y, c, d in graph[x]:\n        if y == parent:\n            continue\n        sums[c] += d\n        nums[c] += 1\n        total += d\n        dfs(y, sums, nums, total, x)\n        sums[c] -= d\n        nums[c] -= 1\n        total -= d\n    return\n\ndfs()\n\nprint(('\\n'.join(map(str, answer))))\n", "def f_colorful_tree(N, Q, Edges, Queries):\n    # \u53c2\u8003: https://atcoder.jp/contests/abc133/submissions/6316420\n    # https://atcoder.jp/contests/abc133/submissions/6321437\n\n    import sys\n    sys.setrecursionlimit(10**5)\n\n    # \u5165\u529b\u306f1-based\u3060\u304c\u3001\u9802\u70b9\u3068\u8272\u306e\u756a\u53f7\u306b\u3064\u3044\u3066\u306f0-based\u3067\u8003\u3048\u308b(\u4ee5\u964d\u3082\u540c\u69d8)\n    tree = [[] for _ in range(N)]\n    for a, b, c, d in Edges:\n        tree[a - 1].append((b - 1, c - 1, d))\n        tree[b - 1].append((a - 1, c - 1, d))\n\n    \"\"\"Least Common Ancestor\u3092\u6c42\u3081\u308b\u305f\u3081\u306e\u524d\u51e6\u7406\"\"\"\n    depth_from_root = [0] * N\n    # [k][v]: \u9802\u70b9v\u304b\u30892**k\u500b\u6839\u306b\u8fd1\u3065\u3044\u305f\u3068\u304d\u306e\u9802\u70b9\u756a\u53f7(\u6839\u306e\u89aa\u306f-1\u3068\u3059\u308b)\n    # \u9802\u70b9\u6570N\u304c\u6700\u5927 10**5 \u306a\u306e\u3067\u30012**k >= 10**5 \u3068\u306a\u308b k=17 \u307e\u3067\u30ea\u30b9\u30c8\u3092\u78ba\u4fdd\u3059\u308b\n    parent_to_root = [[-1] * N for _ in range(18)]\n    distance_from_root = [0] * N\n\n    def dfs1(parent, current, depth, distance):\n        depth_from_root[current] = depth\n        parent_to_root[0][current] = parent\n        distance_from_root[current] = distance\n        for child, _, dist in tree[current]:  # \u8272\u306b\u3064\u3044\u3066\u306e\u60c5\u5831\u306f\u5fc5\u8981\u306a\u3044\n            if child != parent:\n                dfs1(current, child, depth + 1, distance + dist)\n\n    dfs1(-1, 0, 0, 0)\n    for i in range(17):\n        for j in range(N):\n            parent_to_root[i + 1][j] = parent_to_root[i][parent_to_root[i][j]]\n\n    def least_common_ancestor(a, b):\n        # editorial\u3068\u540c\u3058\u3053\u3068\u3092\u3084\u308b\n        if depth_from_root[a] > depth_from_root[b]:\n            a, b = b, a\n        for i in range(18):\n            if (depth_from_root[b] - depth_from_root[a]) & (1 << i):\n                b = parent_to_root[i][b]\n        if a == b:\n            return a\n        for i in range(18)[::-1]:\n            if parent_to_root[i][a] != parent_to_root[i][b]:\n                a = parent_to_root[i][a]\n                b = parent_to_root[i][b]\n        return parent_to_root[0][a]\n\n    \"\"\"\u5148\u8aad\u307f\u3057\u305f(\u30aa\u30d5\u30e9\u30a4\u30f3)\u30af\u30a8\u30ea\u306b\u5bfe\u3057\u3066\u89e3\u3092\u6c42\u3081\u308b\"\"\"\n    ans = [0] * Q\n    v_need = [[] for i in range(N)]\n    for i, (x, y, u, v) in enumerate(Queries):\n        # \u8272x\u306e\u8fba\u306e\u8ddd\u96e2\u3092\u4e00\u5f8by\u306b\u5909\u66f4\u3057\u305f\u3068\u304d\u3001\u9802\u70b9u-v\u9593\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b\n        lca = least_common_ancestor(u - 1, v - 1)\n        # \u8272\u306e\u60c5\u5831\u3092\u5fc5\u8981\u3068\u3057\u3066\u3044\u308b\u306e\u306f u, v, lca \u306e3\u70b9\n        # \u305d\u308c\u305e\u308c\u306e\u70b9\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u60c5\u5831\u3092\u683c\u7d0d\u3059\u308b\n        # (\u4f55\u756a\u76ee\u306e\u30af\u30a8\u30ea\u304b, \u3069\u306e\u8272\u306e\u8ddd\u96e2\u3092\u5909\u3048\u308b\u304b, \u5909\u3048\u308b\u8ddd\u96e2\u306f\u3044\u304f\u3089\u304b, \u4fc2\u6570)\n        # \u4fc2\u6570\u306f u-v\u9593\u306e\u8ddd\u96e2 = \u6839-u + \u6839-v - 2 * \u6839-LCA(u, v) \u3067\u3042\u308b\u3053\u3068\u3092\u53cd\u6620\n        v_need[u - 1].append((i, x - 1, y, 1))\n        v_need[v - 1].append((i, x - 1, y, 1))\n        v_need[lca].append((i, x - 1, y, -2))\n\n    color_appear = [0] * N  # [c]: \u4eca\u8a2a\u308c\u3066\u3044\u308b\u9802\u70b9\u307e\u3067\u306b\u8272c\u306f\u4f55\u56de\u73fe\u308c\u305f\u304b\n    color_distance = [0] * N  # [c]: \u4eca\u8a2a\u308c\u3066\u3044\u308b\u9802\u70b9\u307e\u3067\u3067\u306e\u8272c\u306e\u8fba\u306e\u8ddd\u96e2\u306e\u548c\n\n    def dfs2(parent, current):\n        nonlocal color_distance\n        for i, x, y, coefficient in v_need[current]:\n            ans[i] += (coefficient * (distance_from_root[current]\n                                      - color_distance[x] + y * color_appear[x]))\n        for child, x, y in tree[current]:\n            if child == parent:\n                continue\n            color_appear[x] += 1\n            color_distance[x] += y\n            dfs2(current, child)\n            # \u4f8b\u3048\u3070 a\u2192b\u2192c\u2192b\u2192d \u3068\u79fb\u52d5\u3057\u305f\u3053\u3068\u3092 a\u2192b\u2192d \u3068\u307f\u306a\u3059\n            # (\u30aa\u30a4\u30e9\u30fc\u30c4\u30a2\u30fc\u306e\u3088\u3046\u306b\u3059\u308b)\u305f\u3081\u3001\u623b\u3063\u3066\u304d\u305f\u306a\u3089\u5f15\u304f\n            color_appear[x] -= 1\n            color_distance[x] -= y\n\n    dfs2(-1, 0)\n    return '\\n'.join(map(str, ans))\n\nN, Q = [int(i) for i in input().split()]\nEdges = [[int(i) for i in input().split()] for j in range(N - 1)]\nQueries = [[int(i) for i in input().split()] for j in range(Q)]\nprint(f_colorful_tree(N, Q, Edges, Queries))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\nN,Q = map(int,input().split())\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b,c,d = map(int,input().split())\n    graph[a].append((b,c,d))\n    graph[b].append((a,c,d))\nquery = [[int(x) for x in input().split()] for _ in range(Q)]\n\ndef set_ancestor(x=1, d=0, parent=0):\n    depth[x] = d\n    ax = ancestor[x]\n    ax[0] = parent\n    for i in range(d.bit_length() - 1):\n        ax[i+1] = ancestor[ax[i]][i]\n    for y, _, _ in graph[x]:\n        if y == parent:\n            continue\n        set_ancestor(y, d+1, x)\n\ndepth = [0] * (N+1)\nU = 17\nancestor = [[0] * (U+1) for _ in range(N+1)] # 2**i \u3060\u3051\u9061\u3063\u305f\u9802\u70b9\u306e\u756a\u53f7\u3001\u884c\u304d\u904e\u304e\u306f0\nset_ancestor()\n\ndef LCA(x,y):\n    dx = depth[x]\n    dy = depth[y]\n    if dx > dy:\n        x,y = y,x\n        dx,dy = dy,dx\n    diff = dy - dx\n    while diff:\n        step = diff & (-diff)\n        y = ancestor[y][step.bit_length() - 1]\n        diff -= step\n    while x != y:\n        j = 0\n        while ancestor[x][j] != ancestor[y][j]:\n            j += 1\n        if j == 0:\n            return ancestor[x][0]\n        x = ancestor[x][j-1]\n        y = ancestor[y][j-1]\n    return x\n\ntasks = [[] for _ in range(N+1)]\nfor i,(x,y,u,v) in enumerate(query):\n    tasks[u].append((i,x,y,1))\n    tasks[v].append((i,x,y,1))\n    tasks[LCA(u,v)].append((i,x,y,-2))\n\nanswer = [0] * Q# \u9802\u70b9\u3001\u8272\u306b\u5bfe\u3057\u3066\u3001\u8ddd\u96e2\u3001\u81ea\u8272\u8ddd\u96e2\u3001\u81ea\u8272\u500b\u6570)\u3092\u5165\u308c\u308b\n\ndef dfs(x, sums = defaultdict(int), nums = defaultdict(int), total = 0, parent = 0):\n    for i,c,d,coef in tasks[x]:\n        answer[i] += coef * (total - sums[c] + nums[c] * d)\n    for y,c,d in graph[x]:\n        if y == parent:\n            continue\n        sums[c] += d\n        nums[c] += 1\n        total += d\n        dfs(y, sums, nums, total, x)\n        sums[c] -= d\n        nums[c] -= 1\n        total -= d\n    return\n\ndfs(1)\n\nprint('\\n'.join(map(str,answer)))", "import sys\ninput = sys.stdin.readline\n\nN,Q=list(map(int,input().split()))\nEDGE=[list(map(int,input().split())) for i in range(N-1)]\nQuery=[list(map(int,input().split())) for i in range(Q)]\nmod=10**9+7\n\nEDGELIST=[dict() for i in range(N+1)]\nfor x,y,c,l in EDGE:\n    EDGELIST[x][y]=(c,l)\n    EDGELIST[y][x]=(c,l)\n    \n# LCA(\u30aa\u30a4\u30e9\u30fc\u30c4\u30a2\u30fc\uff0bSegment tree)\n\nDEPTH=[-1]*(N+1)\nDEPTH[1]=0\n\nfrom collections import deque\nQUE = deque([1])\nQUE2 = deque()\nEULER=[]#(i,j)\u3067,(1\u304b\u3089\u30c4\u30a2\u30fc\u3067\u8fbf\u3063\u305f\u70b9\u306e\u6df1\u3055,\u305d\u306eindex)\n\nUSED=[0]*(N+1)\nwhile QUE:\n    x=QUE.pop()\n    EULER.append((DEPTH[x],x))\n    if USED[x]==1:\n        continue\n    for to in EDGELIST[x]:\n        \n        if USED[to]==0:\n            DEPTH[to]=DEPTH[x]+1\n            QUE2.append(to)\n        else:\n            QUE.append(to)\n    QUE.extend(QUE2)\n    QUE2=deque()\n \n    USED[x]=1\n\nMINP=[1<<30]*(N+1)\nMAXP=[-1]*(N+1)\n\nfor ind,(depth,p) in enumerate(EULER):\n    MINP[p]=min(MINP[p],ind)\n    MAXP[p]=ind\n\nLEN=len(EULER)\n\nseg_el=1<<(LEN.bit_length())#Segment tree\u306e\u53f0\u306e\u8981\u7d20\u6570\nSEG=[(1<<30,0)]*(2*seg_el)#1-indexed\u306a\u306e\u3067\u3001\u8981\u7d20\u65702*seg_el.Segment tree\u306e\u521d\u671f\u5024\u3067\u521d\u671f\u5316\n\nfor i in range(LEN):#D\u3092\u5bfe\u5fdc\u3059\u308b\u7b87\u6240\u3078update\n    SEG[i+seg_el]=EULER[i]\n\nfor i in range(seg_el-1,0,-1):#\u89aa\u306e\u90e8\u5206\u3082update\n    SEG[i]=min(SEG[i*2],SEG[i*2+1])\n\ndef update(n,x,seg_el):#A[n]\u3092x\u3078\u66f4\u65b0\uff08\u53cd\u6620\uff09\n    i=n+seg_el\n    SEG[i]=x\n    i>>=1#\u5b50\u30ce\u30fc\u30c9\u3078\n    \n    while i!=0:\n        SEG[i]=min(SEG[i*2],SEG[i*2+1])\n        i>>=1\n        \ndef getvalues(l,r):#\u533a\u9593[l,r)\u306b\u95a2\u3059\u308bmin\u3092\u8abf\u3079\u308b\n    L=l+seg_el\n    R=r+seg_el\n    ANS=(1<<30,0)\n\n    while L<R:\n        if L & 1:\n            ANS=min(ANS , SEG[L])\n            L+=1\n\n        if R & 1:\n            R-=1\n            ANS=min(ANS , SEG[R])\n        L>>=1\n        R>>=1\n\n    return ANS\n\ndef LCA(l,r):\n    return getvalues(min(MINP[l],MINP[r]),max(MAXP[l],MAXP[r])+1)\n\nN_q=[[] for i in range(N+1)]\nfor ind,(c,pl,x,y) in enumerate(Query):\n    N_q[x].append([ind,c,pl,1])\n    N_q[y].append([ind,c,pl,1])\n    N_q[LCA(x,y)[1]].append([ind,c,pl,0])\n\nANS=[0]*Q\n\nLENG=0\nC_LENGTH=[0]*N\nC_SUM=[0]*N\n\nfor i in range(1,len(EULER)):\n    ind=EULER[i][1]\n    c,l=EDGELIST[EULER[i-1][1]][ind]\n    if EULER[i][0]>EULER[i-1][0]:\n        LENG+=l\n        C_LENGTH[c]+=l\n        C_SUM[c]+=1\n\n        for que,c,pl,boo in N_q[ind]:\n            if boo==1:\n                ANS[que]+=LENG+C_SUM[c]*pl-C_LENGTH[c]\n\n            else:\n                ANS[que]-=(LENG+C_SUM[c]*pl-C_LENGTH[c])*2\n            \n    else:\n        LENG-=l\n        C_LENGTH[c]-=l\n        C_SUM[c]-=1\n\nfor ans in ANS:\n    print(ans)\n", "import sys\nfrom itertools import combinations, permutations, product, combinations_with_replacement, accumulate\nfrom heapq import heapify, heappop, heappush, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, log, floor, ceil, factorial, cos, sin, pi#, gcd\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nLINF = 2**63-1\nNIL = -LINF\nMOD = 10**9+7\nMGN = 4\ndef AST(exp: bool, msg: str = \"\"): assert exp, msg\ndef TAST(exp: bool, msg = \"\"):\n    if exp is False: print((\"TAssertionError:\", msg))\n    while exp is False:\n        pass\ndef II(): return int(input())\ndef IF(): return float(input())\ndef IS(): return input().replace('\\n', '')\ndef ILCI(n: int): return [II() for _ in range(n)]\ndef ILCF(n: int): return [IF() for _ in range(n)]\ndef ILI(): return list(map(int, input().split()))\ndef ILLI(n: int): return [[int(j) for j in input().split()] for i in range(n)]\ndef ILF(): return list(map(float, input().split()))\ndef ILLF(n: int): return [[float(j) for j in input().split()] for i in range(n)]\ndef LTOS(lst: list, sep: str = ' '): return sep.join(map(str, lst))\ndef DEC(lst: list): return list([x-1 for x in lst])\ndef INC(lst: list): return list([x+1 for x in lst])\n\nclass LCA:\n    def __init__(self, N: int) -> None:\n        self.N = N\n        self.to = [[] for _ in range(N)]  \n        self.co = [[] for _ in range(N)]  \n        self.dep = [0] * N  \n        self.costs = [0] * N  \n        l = 0\n        while (1 << l) < N:\n            l += 1\n        self.l = l\n        self.par = [([0]*l) for _ in range(N+1)]  \n    def add_edge(self, a: int, b: int, c = 0) -> None:\n        self.to[a].append(b)\n        self.co[a].append(c)\n        self.to[b].append(a)\n        self.co[b].append(c)\n    def _dfs(self, v: int, d: int = 0, c = 0, p: int = -1) -> None:\n        if p != -1:\n            self.par[v][0] = p  \n        self.dep[v] = d\n        self.costs[v] = c\n        for i in range(len(self.to[v])):\n            u = self.to[v][i]\n            if u == p:\n                continue\n            else:\n                self._dfs(u, d+1, c+self.co[v][i], v)\n    def init(self, root: int = 0) -> None:\n        self.root = root\n        self._dfs(root)\n        for i in range(self.l - 1):\n            for v in range(self.N):\n                self.par[v][i+1] = self.par[self.par[v][i]][i]\n    def __call__(self, a: int, b: int) -> int:\n        dep_s, dep_l = self.dep[a], self.dep[b]\n        if dep_s > dep_l:\n            a, b = b, a  \n            dep_s, dep_l = dep_l, dep_s\n        gap = dep_l - dep_s\n        L_1 = self.l-1\n        for i in range(L_1, -1, -1):\n            leng = 1 << i\n            if gap >= leng:\n                gap -= leng\n                b = self.par[b][i]\n        if a == b:  \n            return a\n        for i in range(L_1, -1, -1):\n            na = self.par[a][i]  \n            nb = self.par[b][i]  \n            if na != nb:\n                a, b = na, nb\n        return self.par[a][0]\n    def length(self, a: int, b: int) -> int:\n        c = self.__call__(a, b)\n        return self.dep[a] + self.dep[b] - self.dep[c] * 2\n    def dist(self, a: int, b: int):\n        c = self.__call__(a, b)\n        return self.costs[a] + self.costs[b] - self.costs[c] * 2\n\ndef main():\n    N,Q = ILI()\n    gr = LCA(N)\n    es = [[] for _ in range(N)]\n    for i in range(N-1):\n        a,b, col, dist = ILI()\n        a -= 1; b -= 1\n        es[a].append((b, dist, col))\n        es[b].append((a, dist, col))\n        gr.add_edge(a, b, dist)\n\n    gr.init()\n    ans = [0] * Q\n    qs = [[] for _ in range(N)]\n    for i in range(Q):\n        cx,dy, a,b = ILI()\n        a -= 1; b -= 1\n        c = gr(a, b)\n        ans[i] = gr.costs[a] + gr.costs[b] - gr.costs[c] * 2\n        qs[a].append((cx, i, 1, dy))\n        qs[b].append((cx, i, 1, dy))\n        qs[c].append((cx, i, -2, dy))\n\n    cnt = [0] * N\n    sum_ = [0] * N\n\n    def dfs(v: int, p: int = -1) -> None:\n        for (col,qid,coeff,dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n        \n        for (to, co, col) in es[v]:\n            if to == p:\n                continue\n            cnt[col] += 1\n            sum_[col] += co\n            dfs(to, v)\n            cnt[col] -= 1\n            sum_[col] -= co\n\n    dfs(0)\n    for i in range(Q):\n        print((ans[i]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\n\nN, Q = list(map(int, input().split()))\nedge = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n        a, b, c, d = list(map(int, input().split()))\n        edge[a].append((b, c, d))\n        edge[b].append((a, c, d))\n        \ndepth = [0] * (N+1)\nU = 17\nancestor = [[0] * (U+1) for _ in range(N+1)]\n\nq = [(1, 0, 0)]\nwhile q:\n        qq = []\n        for x, d, parent in q:\n                depth[x] = d\n                ax = ancestor[x]\n                ax[0] = parent\n                for i in range(d.bit_length()-1):\n                        ax[i+1] = ancestor[ax[i]][i]\n\n                for y, _, _ in edge[x]:\n                        if y == parent:\n                                continue\n                        qq.append((y, d+1, x))\n        q = qq\n\ndef lca(x, y):\n        dx = depth[x]\n        dy = depth[y]\n        if dx > dy:\n                x, y = y, x\n                dx, dy = dy, dx\n        diff = dy - dx\n        while diff:\n                step = diff & (-diff)\n                y = ancestor[y][step.bit_length()-1]\n                diff -= step\n        while x!=y:\n                j = 0\n                while ancestor[x][j] != ancestor[y][j]:\n                        j += 1\n                if j==0:\n                        return ancestor[x][0]\n                x = ancestor[x][j-1]\n                y = ancestor[y][j-1]\n        return x\n\ntask = [[] for _ in range(N+1)]\nfor i in range(Q):\n        x, y, u, v = list(map(int, input().split()))\n        task[u].append((i, x, y, 1))\n        task[v].append((i, x, y, 1))\n        task[lca(u, v)].append((i, x, y, -2))\n\nanswer = [0] * Q\n\ndef dfs(x=1, sums=[0]*(N+1), nums=[0]*(N+1), total=0, parent=0):\n        for i, c, d, coef in task[x]:\n                answer[i] += coef * (total - sums[c] + nums[c]*d)\n        for y, c, d in edge[x]:\n                if y == parent:\n                        continue\n                sums[c] += d\n                nums[c] += 1\n                total += d\n                dfs(y, sums, nums, total, x)\n                sums[c] -= d\n                nums[c] -= 1\n                total -= d\n        return\n\ndfs()\n\nprint(('\\n'.join(map(str, answer))))\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\n\n\nclass SegmentTree1():\n    \"\"\"\n    1-indexed Segment Tree\n    \"\"\"\n    def __init__(self, n_, ele_id, operation_func):\n        self.n = 1 << (n_ - 1).bit_length()  # size\n        self.data = [ele_id] * (2 * self.n)  # binary tree\n        self.ele_id = ele_id  # identity element\n        self.operation_func = operation_func  # binary operation of monoid\n\n    def __getitem__(self, idx):\n        return self.data[idx + self.n]\n\n    def build(self, data_init):\n        for i in range(len(data_init)):\n            self.data[i + self.n] = data_init[i]\n        for i in range(self.n - 1, 0, -1):\n            self.data[i] = self.operation_func(self.data[2 * i],\n                                               self.data[2 * i + 1])\n\n    def update(self, idx, x):\n        # change idx-th element to x (idx : 0-indexed)\n        idx += self.n\n        self.data[idx] = x\n        while idx > 1:\n            idx = idx >> 1\n            self.data[idx] = self.operation_func(self.data[2 * idx],\n                                                 self.data[2 * idx + 1])\n\n    def query(self, l, r):\n        # query for interval [l, r) (l, r : 0-indexed)\n        l += self.n\n        r += self.n\n        ret = self.ele_id\n        while l < r:\n            if l & 1:  # right child\n                ret = self.operation_func(ret, self.data[l])\n                l += 1\n            if r & 1:  # right child\n                r -= 1\n                ret = self.operation_func(ret, self.data[r])\n            # go to parent-nodes\n            l = l >> 1\n            r = r >> 1\n        return ret\n\n\nclass Tree():\n    def __init__(self, n, graph, v_root):\n        self.n = n  # number of nodes\n        self.graph = graph  # adjacent list of graph\n        self.v_root = v_root  # root node\n\n        # euler tour\n        self.first_idx = [2 * self.n] * self.n\n        self.euler_tour = []\n        self.euler_depth_topo = []\n        self.euler_depth_real = []\n        self.euler_tour_dfs(self.v_root, -1, 0, 0)\n\n        depth_list = [(di, i) for i, di in enumerate(self.euler_depth_topo)]\n        INF = (2 * self.n, -1)\n        operation_func = lambda a, b: a if a[0] < b[0] else b\n        self.st_rmq = SegmentTree1(2 * self.n - 1, INF, operation_func)\n        self.st_rmq.build(depth_list)\n\n    def euler_tour_dfs(self, v, v_par, depth_topo, depth_real):\n        self.first_idx[v] = len(self.euler_tour)\n        self.euler_tour.append(v)\n        self.euler_depth_topo.append(depth_topo)\n        self.euler_depth_real.append(depth_real)\n        for v_next, c, d in self.graph[v]:\n            if v_next == v_par:\n                continue\n            self.euler_tour_dfs(v_next, v, depth_topo + 1, depth_real + d)\n            self.euler_tour.append(v)\n            self.euler_depth_topo.append(depth_topo)\n            self.euler_depth_real.append(depth_real)\n\n    def depth_topo(self, v):\n        return self.euler_depth_topo[self.first_idx[v]]\n\n    def depth_real(self, v):\n        return self.euler_depth_real[self.first_idx[v]]\n\n    def lca(self, u, v):\n        u_idx, v_idx = self.first_idx[u], self.first_idx[v]\n        if u_idx > v_idx:\n            u_idx, v_idx = v_idx, u_idx\n        _, idx = self.st_rmq.query(u_idx, v_idx + 1)\n        return self.euler_tour[idx]\n\n    def dist(self, u, v):\n        lca_uv = self.lca(u, v)\n        return self.depth(u) + self.depth(v) - 2 * self.depth(lca_uv)\n\n\nn, q = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b, c, d = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a].append((b, c, d))\n    graph[b].append((a, c, d))\n\ntree = Tree(n, graph, 0)\n\nquery = []\nmemo = [set() for i in range(n)]\nfor _ in range(q):\n    x, y, u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    lca_uv = tree.lca(u, v)\n    memo[u].add(x)\n    memo[v].add(x)\n    memo[lca_uv].add(x)\n\n    query.append((x, y, u, v, lca_uv))\n\nn_color = [0] * n\nd_color = [0] * n\nn_color_memo = {}\nd_color_memo = {}\n\n\ndef dfs(v, v_par, depth):\n    for c in memo[v]:\n        n_color_memo[(v, c)] = n_color[c]\n        d_color_memo[(v, c)] = d_color[c]\n\n    for v_next, c, d in graph[v]:\n        if v_next == v_par:\n            continue\n        n_color[c] += 1\n        d_color[c] += d\n        dfs(v_next, v, depth + d)\n        n_color[c] -= 1\n        d_color[c] -= d\n\n\ndfs(0, -1, 0)\n\nfor x, y, u, v, lca in query:\n    depth_u = tree.depth_real(u)\n    depth_u += -d_color_memo[(u, x)] + y * n_color_memo[(u, x)]\n    depth_v = tree.depth_real(v)\n    depth_v += -d_color_memo[(v, x)] + y * n_color_memo[(v, x)]\n    depth_lca = tree.depth_real(lca)\n    depth_lca += -d_color_memo[(lca, x)] + y * n_color_memo[(lca, x)]\n\n    ans = depth_u + depth_v - 2 * depth_lca\n    print(ans)\n", "from collections import defaultdict\nfrom math import log2\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\n\ndef f(n,q):\n    def dfs(i, oi=-1, dpt=0):\n        depth[i] = dpt\n        parent_2k[0][i] = oi\n        for ki, c, d in to[i]:\n            if ki == oi: continue\n            dfs(ki, i, dpt + 1)\n        return\n\n    def make_parent(level):\n        parent_2kk1 = parent_2k[0]\n        for k in range(1, level):\n            parent_2kk = parent_2k[k]\n            for i in range(n):\n                parent1 = parent_2kk1[i]\n                if parent1 != -1:\n                    parent_2kk[i] = parent_2kk1[parent1]\n            parent_2kk1 = parent_2kk\n        return\n\n    def lca(u, v):\n        dist_uv = depth[u] - depth[v]\n        if dist_uv < 0:\n            u, v = v, u\n            dist_uv *= -1\n\n        k = 0\n        while dist_uv:\n            if dist_uv & 1:\n                u = parent_2k[k][u]\n            dist_uv >>= 1\n            k += 1\n\n        if u == v:\n            return u\n\n        for k in range(int(log2(depth[u])) + 1, -1, -1):\n            pu = parent_2k[k][u]\n            pv = parent_2k[k][v]\n            if pu != pv:\n                u = pu\n                v = pv\n        return parent_2k[0][u]\n\n    to = defaultdict(list)\n    root = 0\n    depth = [0] * n\n    level = int(log2(n)) + 1\n    parent_2k = [[-1] * n for _ in range(level)]\n\n    for _ in range(n - 1):\n        a, b, c, d = list(map(int, input().split()))\n        to[a - 1] += [[b - 1, c - 1, d]]\n        to[b - 1] += [[a - 1, c - 1, d]]\n\n    dfs(root)\n    make_parent(level)\n\n    qs = [[] for _ in range(n)]\n    for qi in range(q):\n        x, y, u, v = list(map(int, input().split()))\n        qs[u - 1].append([qi, x - 1, y, 1])\n        qs[v - 1].append([qi, x - 1, y, 1])\n        qs[lca(u - 1, v - 1)].append([qi, x - 1, y, -2])\n\n    cnt_c = [0] * n\n    sum_c = [0] * n\n    ans = [0] * q\n\n    def dfs2(i, oi=-1, sum_d=0):\n        for qi, qc, qd, qk in qs[i]:\n            ans[qi] += (sum_d - sum_c[qc] + qd * cnt_c[qc]) * qk\n        for ki, c, d in to[i]:\n            if ki == oi: continue\n            cnt_c[c] += 1\n            sum_c[c] += d\n            dfs2(ki, i, sum_d + d)\n            cnt_c[c] -= 1\n            sum_c[c] -= d\n        return\n\n    dfs2(root)\n    for x in ans:\n        print(x)\n\nn, q = list(map(int, input().split()))\nf(n,q)\n", "import sys\nsys.setrecursionlimit(10000000)\ninput = sys.stdin.readline\nfrom math import log\nfrom collections import deque\n\ndef solve():\n    N, Q = list(map(int, input().split()))\n    es = [[] for i in range(N+1)]\n    for i in range(N-1):\n        u, v, c, d = list(map(int, input().split()))\n        es[u].append([v, c, d])\n        es[v].append([u, c, d])\n    LOG_N = int(log(N, 2)) + 1\n    parent = [[-1] * (N+1) for i in range(LOG_N)]\n    level = [None] * (N+1)\n    level[1] = 0\n    dq = deque()\n    dq.append(1)\n    while dq:\n        v = dq.popleft()\n        p = parent[0][v]\n        lv = level[v]\n        for u, c, d in es[v]:\n            if u != p:\n                parent[0][u] = v\n                level[u] = lv + 1\n                dq.append(u)\n    for k in range(LOG_N-1):\n        parentk = parent[k]\n        for v in range(1, N+1):\n            if parentk[v] < 0:\n                parent[k+1][v] = -1\n            else:\n                parent[k+1][v] = parentk[parentk[v]]\n\n    def lca(u, v):\n        if level[u] > level[v]:\n            u, v = v, u\n        for k in range(LOG_N)[::-1]:\n            if (level[v] - level[u]) >> k & 1:\n                v = parent[k][v]\n        if u == v:\n            return u\n        for k in range(LOG_N)[::-1]:\n            if parent[k][u] != parent[k][v]:\n                u, v = parent[k][u], parent[k][v]\n        return parent[0][u]\n\n    qs = [[] for i in range(N+1)]\n    for i in range(Q):\n        x, y, u, v = list(map(int, input().split()))\n        qs[u].append([i, x, y, 1])\n        qs[v].append([i, x, y, 1])\n        a = lca(u, v)\n        qs[a].append([i, x, y, -2])\n    ds = [0] * N\n    cnt = [0] * N\n    query = [0] * Q\n\n    def EulerTour(v, p, d):\n        for id, col, y, f in qs[v]:\n            query[id] += f * (d + y * cnt[col] - ds[col])\n        for u, c, _d in es[v]:\n            if u != p:\n                ds[c] += _d\n                cnt[c] += 1\n                EulerTour(u, v, d + _d)\n                ds[c] -= _d\n                cnt[c] -= 1\n\n    EulerTour(1, -1, 0)\n    for res in query:\n        print(res)\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n \nINF = 10**6\n \nclass RMQ:\n    def __init__(self, a):\n        self.n = len(a)\n        self.size = 2**(self.n - 1).bit_length()\n        self.data = [(INF, INF) for _ in range(2*self.size-1)]\n        self.initialize(a)\n \n    # Initialize data\n    def initialize(self, a):\n        for i in range(self.n):\n            self.data[self.size + i - 1] = a[i][:]\n        for i in range(self.size-2, -1, -1):\n            self.data[i] = min(self.data[i*2 + 1], self.data[i*2 + 2])[:]\n    \n    # Update ak as x\n    def update(self, k, x):\n        k += self.size - 1\n        self.data[k] = x\n        while k > 0:\n            k = (k - 1) // 2\n            self.data[k] = min(self.data[2*k+1], self.data[2*k+2])[:]\n    \n    # Min value in [l, r)\n    def query(self, l, r):\n        L = l + self.size; R = r + self.size\n        s = (INF, INF)\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.data[R-1])[:]\n            if L & 1:\n                s = min(s, self.data[L-1])[:]\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n \nclass LCA:\n    def __init__(self, edge, root):\n        self.itr = 0\n        self.edge = edge[:]\n        self.path = [0] * (2*n-1)\n        self.depth = [0] * (2*n-1)\n        self.color = [0] * (2*n-1)\n        self.weight = [0] * (2*n-1)\n        self.index = [0] * n\n        self.euler_tour(-1, root, 0, 0, 0, 0)\n        dat = list(zip(self.depth, self.path))\n        self.rmq = RMQ(dat)\n    \n    # Lowest ancestor of u, v\n    def get_lca(self, u, v):\n        l, r = self.index[u], self.index[v]\n        if l > r:\n            l, r = r, l\n        return self.rmq.query(l, r+1)[1]\n    \n    def euler_tour(self, prev, v, d, k, c, w):\n        self.index[v] = k\n        self.path[self.itr] = v\n        self.depth[self.itr] = d\n        self.color[self.itr] = c\n        self.weight[self.itr] = w\n        self.itr += 1\n        k += 1\n        for dest, c, w in self.edge[v]:\n            if prev == dest:\n                continue\n            k = self.euler_tour(v, dest, d + 1, k, c, w)\n            self.path[self.itr] = v\n            self.depth[self.itr] = d\n            self.color[self.itr] = -c\n            self.weight[self.itr] = -w\n            self.itr += 1\n            k += 1\n        return k\n        \nn, q = [int(item) for item in input().split()] \nedge = [[] for _ in range(n)]\n \nfor _ in range(n-1):\n    u, v, c, w = [int(item) for item in input().split()]\n    u -= 1; v -= 1\n    edge[u].append((v, c, w))\n    edge[v].append((u, c, w))\n \nlca = LCA(edge, 0)\nmemo = [dict() for _ in range(n)]\nlca_memo = dict()\n \nquery = []\nfor _ in range(q):\n    x, y, u, v = [int(item) for item in input().split()]\n    u -= 1; v -= 1\n    if u > v:\n        u, v = v, u\n    if (u, v) in lca_memo:\n        ca = lca_memo[(u, v)]\n    else:\n        ca = lca.get_lca(u, v)\n        lca_memo[(u, v)] = ca\n    memo[u][x] = None\n    memo[v][x] = None\n    memo[ca][x] = None\n    query.append((x, y, ca, u, v))\n \ncolors = [0] * n\nc_depth = [0] * n\ndepth = 0\nfor p, c, w in zip(lca.path[1:], lca.color[1:], lca.weight[1:]):\n    color = abs(c)\n    if c < 0:\n        colors[color] -= 1\n    else:\n        colors[color] += 1\n    c_depth[color] += w\n    depth += w\n \n    for key in memo[p].keys():\n        if memo[p][key] != None:\n            break\n        memo[p][key] = (colors[key], c_depth[key])\n    memo[p][0] = depth \n \nans = []\nfor x, y, ca, u, v in query:\n    # Calc basic distance\n    val = memo[u][0] + memo[v][0] - memo[ca][0] * 2\n    # Append color diff\n    val += (memo[v][x][0] + memo[u][x][0] - memo[ca][x][0] * 2) * y \n    val -= (memo[v][x][1] + memo[u][x][1] - memo[ca][x][1] * 2)\n    ans.append(val)\nprint(\"\\n\".join(map(str,ans)))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\nN,Q = list(map(int,input().split()))\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b,c,d = list(map(int,input().split()))\n    graph[a].append((b,c,d))\n    graph[b].append((a,c,d))\nquery = [[int(x) for x in input().split()] for _ in range(Q)]\n\ndepth = [0] * (N+1)\nU = 17\nancestor = [[0] * (U+1) for _ in range(N+1)] # 2**i \u3060\u3051\u9061\u3063\u305f\u9802\u70b9\u306e\u756a\u53f7\u3001\u884c\u304d\u904e\u304e\u306f0\n\nq = [(1,0,0)]\nwhile q:\n    qq = []\n    for x,d,parent in q:\n        depth[x] = d\n        ax = ancestor[x]\n        ax[0] = parent\n        for i in range(d.bit_length() - 1):\n            ax[i+1] = ancestor[ax[i]][i]\n        for y, _, _ in graph[x]:\n            if y == parent:\n                continue\n            qq.append((y, d+1, x))\n    q = qq\n\ndef LCA(x,y):\n    dx = depth[x]\n    dy = depth[y]\n    if dx > dy:\n        x,y = y,x\n        dx,dy = dy,dx\n    diff = dy - dx\n    while diff:\n        step = diff & (-diff)\n        y = ancestor[y][step.bit_length() - 1]\n        diff -= step\n    while x != y:\n        j = 0\n        while ancestor[x][j] != ancestor[y][j]:\n            j += 1\n        if j == 0:\n            return ancestor[x][0]\n        x = ancestor[x][j-1]\n        y = ancestor[y][j-1]\n    return x\n\ntasks = [[] for _ in range(N+1)]\nfor i,(x,y,u,v) in enumerate(query):\n    tasks[u].append((i,x,y,1))\n    tasks[v].append((i,x,y,1))\n    tasks[LCA(u,v)].append((i,x,y,-2))\n\nanswer = [0] * Q\n\ndef dfs(x = 1, sums = [0] * (N+1), nums = [0] * (N+1), total = 0, parent = 0):\n    for i,c,d,coef in tasks[x]:\n        answer[i] += coef * (total - sums[c] + nums[c] * d)\n    for y,c,d in graph[x]:\n        if y == parent:\n            continue\n        sums[c] += d\n        nums[c] += 1\n        total += d\n        dfs(y, sums, nums, total, x)\n        sums[c] -= d\n        nums[c] -= 1\n        total -= d\n    return\n\ndfs()\n\nprint(('\\n'.join(map(str,answer))))\n\n", "import sys\nsys.setrecursionlimit(10**6+1) #\u518d\u5e30\u95a2\u6570\u306e\u4e0a\u9650,10**5\u4ee5\u4e0a\u306e\u5834\u5408python\n\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printe(*x):print(\"## \",*x,file=sys.stderr)\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\n\n\n#N, Q = map(int, input().split())\nN, Q = map(int, input().split())\n#A = tuple(map(int, input().split())) #1\u884c\u30d9\u30af\u30c8\u30eb\n#L = tuple(int(input()) for i in range(N)) #\u6539\u884c\u30d9\u30af\u30c8\u30eb\n#S = tuple(tuple(map(int, input().split())) for i in range(N)) #\u6539\u884c\u884c\u5217\n\nedge = [[] for i in range(N)]\nfor i in range(N-1):#\u6728\u306e\u5834\u5408M=N-1\n    a,b,c,w = map(int,input().split())\n    edge[a-1].append((b-1,c-1,w))\n    edge[b-1].append((a-1,c-1,w)) #\u6709\u5411\u306e\u3070\u3042\u3044\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n\n\n\n#\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u308bLCA, \u524d\u51e6\u7406NlogN, \u547c\u3073\u51fa\u3057logN, \u5b89\u5b9a  \ndef dfs(start):\n    q=[(start,-1,0,0)]\n    pars=[-1]*N\n    depth=[-1]*N\n    dist=[-1]*N\n    while len(q):\n        e,p,d,dis=q.pop()#\u3053\u3053\u3092popleft\u306b\u3059\u308b\u3068\u5e45\u512a\u5148\u63a2\u7d22BFS\u306b\u306a\u308b\n        if depth[e]!=-1:continue\n        pars[e]=p\n        depth[e]=d\n        dist[e]=dis\n        for ne,c,w in edge[e]:\n            q.append((ne,e,d+1,dis+w))\n    return pars,depth,dist\npars,d,dist=dfs(0)\nln=N.bit_length()\ndp=[[-1]*N for _ in range(ln+1)]\ndp[0]=pars\nfor i in range(1,ln+1):\n    for j in range(N):\n        dp[i][j]=dp[i-1][dp[i-1][j]]\n\n\n# LCA\u306e\u8a08\u7b97\ndef lca(u, v):\n    du = d[u]; dv = d[v]\n    if du > dv:\n        du, dv = dv, du\n        u,v=v,u\n    dif=dv-du\n    for i in range(ln+1):\n        if (dif>>i)&1:\n            v=dp[i][v]\n    if u==v:return u\n    for i in range(ln,-1,-1):\n        pu=dp[i][u];pv=dp[i][v]\n        if pu!=pv:\n            u,v=pu,pv\n    return pars[u]\n\nq=Q\nqs = tuple(tuple(map(int, input().split())) for i in range(Q)) #\u6539\u884c\u884c\u5217\nans=[0]*Q\nqn=[[] for _ in range(N)]\nfor i,(x,y,u,v) in enumerate(qs):\n    a=lca(u-1,v-1)\n    ans[i]=dist[u-1]+dist[v-1]-2*dist[a]\n    qn[u-1].append((i,x-1,y,1))\n    qn[v-1].append((i,x-1,y,1))\n    qn[a].append((i,x-1,y,-2))\n\ncc=[[0,0] for _ in range(N-1)]\n\ndfq=[(0,None,0,-1)]\ndef dfs2(e,c,d,p):\n    if c!=None:\n        cc[c][0]+=1\n        cc[c][1]+=d\n    for qi,x,y,sgn in qn[e]:\n        ans[qi]+=(y*cc[x][0]-cc[x][1])*sgn\n    for ne,nc,nd in edge[e]:\n        if ne==pars[e]:continue\n        dfs2(ne,nc,nd,e)\n    if c!=None:\n        cc[c][0]-=1\n        cc[c][1]-=d\ndfs2(0,-1,0,None)\nprintl(ans)\n\n# n=N\n# A = [0]*q\n# C = [[] for _ in range(n)]\n# num = [0]*n\n# cum = [0]*n\n# for i in range(q):\n#   x, y, u, v = map(int, input().split())\n#   u -= 1\n#   v -= 1\n#   a = lca(u, v)\n#   C[u].append((i, x, y, 1))\n#   C[v].append((i, x, y, 1))\n#   C[a].append((i, x, y, -2))\n# dist = 0\n# stack = [0]\n# def dfs2(v):\n#   nonlocal dist\n#   for i, x, y, b in C[v]:\n#     A[i] += (dist + num[x]*y - cum[x]) * b\n#   for nv, c, d in edge[v]:\n#     c+=1\n#     if nv ==pars[v]:continue\n#     dist += d\n#     num[c] += 1\n#     cum[c] += d\n#     dfs2(nv)\n#     dist -= d\n#     num[c] -= 1\n#     cum[c] -= d\n# dfs2(0)\n# print(*A, sep=\"\\n\")", "# https://atcoder.jp/contests/abc133/submissions/6316420\n# \u53c2\u8003\u306b\u3055\u305b\u3066\u3044\u305f\u3060\u304d\u307e\u3057\u305f\u3002\n\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\n\nn, q = map(int, input().split())\nedges = [[] for i in range(n)]\nfor i in range(n-1):\n    a,b,c,d = map(int, input().split())\n    a -= 1\n    b -= 1\n    c -= 1\n    edges[a].append((b,c,d))\n    edges[b].append((a,c,d))\n\n# \u3053\u3053\u3067\u524d\u51e6\u7406\n# LCA\u304c\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u3066\u304a\u304f\ndep=[0]*n\npar=[[-1]*n for i in range(18)]\n# \u3064\u3044\u3067\u306b\u8ddd\u96e2\u3082\u6301\u3063\u3066\u304a\u304f\ndis=[0]*n\n\n# parent, now_point, depth, dist\n\ndef dfs(p,v,d,dd):\n    dep[v]=d\n    par[0][v]=p\n    dis[v]=dd\n    for w, _, dist in edges[v]:\n        if w!=p:\n            dfs(v,w,d+1, dd+dist)\n\ndef lca(a,b):\n    if dep[a]>dep[b]:\n        a,b=b,a\n    for i in range(18):\n        if (dep[b]-dep[a]) & 1<<i:\n            b=par[i][b]\n    if a==b:\n        return a\n    for i in range(18)[::-1]:\n        if par[i][a]!=par[i][b]:\n            a=par[i][a]\n            b=par[i][b]\n    return par[0][a]\n\ndfs(-1,0,0,0)\n\nfor i in range(17):\n    for j in range(n):\n        par[i+1][j]=par[i][par[i][j]]\n\n# LCA\u306e\u6e96\u5099\u304c\u5b8c\u4e86\n\nans = [0]*q\nv_need = [[] for i in range(n)]\nfor i in range(q):\n    x,y,u,v = map(int, input().split())\n    x -= 1\n    u -= 1\n    v -= 1\n    l = lca(u, v)\n    # \u8272\u306e\u60c5\u5831\u304c\u307b\u3057\u3044\u306e\u306f u, v, l\u306e3\u70b9\n    # \u3069\u306e\u30af\u30a8\u30ea\u306b\u5c5e\u3059\u308b\u304b, \u3069\u306e\u8272\u3092\u5909\u3048\u308b\u304b\u3001\u8ddd\u96e2\u306f\u3044\u304f\u3064\u306b\u3059\u308b\u304b, \u4fc2\u6570\n    v_need[u].append((i, x, y, 1))\n    v_need[v].append((i, x, y, 1))\n    v_need[l].append((i, x, y, -2))\n\n# \u8272\u304c\u4f55\u56de\u51fa\u305f\u304b\ncolor = [0]*n\n# \u305d\u306e\u70b9\u307e\u3067\u306e\u5404\u8272\u306e\u8ddd\u96e2\u306e\u7dcf\u548c\ncdist = [0]*n\n\ndef dfs2(cur, par):\n    for i, x, y, k in v_need[cur]:\n        ans[i] += k*(dis[cur] - cdist[x] + y*color[x])\n    for to, x, y, in edges[cur]:\n        if to == par:\n            continue\n        color[x] += 1\n        cdist[x] += y\n        dfs2(to, cur)\n        # \u30aa\u30a4\u30e9\u30fc\u30c4\u30a2\u30fc\u306e\u3088\u3046\u306b\u3001\u623b\u3063\u3066\u304d\u305f\u3089\u5f15\u304f\n        # \u3053\u308c\u306b\u3088\u3063\u3066\u3001a\u2192b\u2192c\u2192b\u2192d\u3068\u79fb\u52d5\u3057\u305f\u6642a\u2192b\u2192d\u3068\u307f\u306a\u305b\u308b\n        color[x] -= 1\n        cdist[x] -= y\ndfs2(0, -1)\n\nfor i in ans:\n    print(i)", "from bisect import bisect_left, bisect_right\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    INF = float('inf')\n\n    N, Q = list(map(int, input().split()))\n    adjL = [[] for _ in range(N)]\n    for _ in range(N-1):\n        A, B, C, D = list(map(int, input().split()))\n        A, B, C = A-1, B-1, C-1\n        adjL[A].append((B, C, D))\n        adjL[B].append((A, C, D))\n    querys = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    def dfs(vNow, vPar, depth):\n        iVFirsts[vNow] = len(vs)\n        vs.append(vNow)\n        depths.append(depth)\n        for v2, clr, dist in adjL[vNow]:\n            if v2 == vPar: continue\n            iVColorss[clr].append(len(numEs))\n            numEs.append(1)\n            sumDs.append(dist)\n\n            dfs(v2, vNow, depth+1)\n\n            vs.append(vNow)\n            depths.append(depth)\n            iVColorss[clr].append(len(numEs))\n            numEs.append(-1)\n            sumDs.append(-dist)\n\n    vs = []\n    iVFirsts = [-1] * N\n    depths = []\n    numEs = [0]\n    sumDs = [0]\n    iVColorss = [[0] for _ in range(N-1)]\n\n    dfs(0, -1, 0)\n\n    dists = [0] * N\n    accD = 0\n    for i, sumD in enumerate(sumDs):\n        accD += sumD\n        if iVFirsts[vs[i]] == i:\n            dists[vs[i]] = accD\n\n    for iVColors in iVColorss:\n        for i in range(1, len(iVColors)):\n            numEs[iVColors[i]] += numEs[iVColors[i-1]]\n            sumDs[iVColors[i]] += sumDs[iVColors[i-1]]\n\n    idEle = (INF, -1)\n    def _binOpe(x, y):\n        return x if x <= y else y  # min\n    def makeSegTree(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        data = [idEle] * (2*numPow2)\n        return data, numPow2\n    def setInit(As):\n        for iST, A in enumerate(As, numPow2):\n            data[iST] = A\n        for iST in reversed(list(range(1, numPow2))):\n            data[iST] = _binOpe(data[2*iST], data[2*iST+1])\n    def getValue(iSt, iEn):\n        L = iSt + numPow2\n        R = iEn + numPow2\n        ans = idEle\n        while L < R:\n            if L & 1:\n                ans = _binOpe(ans, data[L])\n                L += 1\n            if R & 1:\n                R -= 1\n                ans = _binOpe(ans, data[R])\n            L >>= 1\n            R >>= 1\n        return ans\n\n    data, numPow2 = makeSegTree(len(depths))\n    setInit([(depth, i) for i, depth in enumerate(depths)])\n\n    def getLCA(x, y):\n        L, R = iVFirsts[x], iVFirsts[y]\n        if L > R:\n            L, R = R, L\n        minV, iMinV = getValue(L, R)\n        return vs[iMinV]\n\n    anss = []\n    for clr, distNew, u, v in querys:\n        u, v = u-1, v-1\n        LCA = getLCA(u, v)\n\n        clr -= 1\n        ds = [dists[u], dists[v], dists[LCA]]\n        for i, vv in enumerate([u, v, LCA]):\n            iIV = bisect_right(iVColorss[clr], iVFirsts[vv]) - 1\n            iV = iVColorss[clr][iIV]\n            ds[i] += numEs[iV] * distNew - sumDs[iV]\n        ans = ds[0] + ds[1] - 2*ds[2]\n        anss.append(ans)\n\n    print(('\\n'.join(map(str, anss))))\n\n\nsolve()\n", "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda :sys.stdin.readline().rstrip()\nclass LCA(object):\n    def __init__(self,E,root=0):\n        self.__n=len(E)\n        self.__E=E\n        self.__logn=(self.__n-1).bit_length()\n        self.__depth=[-1]*self.__n\n        self.__dist=[-1]*self.__n\n        self.__depth[root]=0\n        self.__dist[root]=0\n        self.__parents=[[-1]*self.__n for _ in range(self.__logn)]\n        self.__dfs(root)\n        self.__doubling()\n\n    def __dfs(self,v):\n        for u,c,d in self.__E[v]:\n            if(self.__depth[u]!=-1): continue\n            self.__parents[0][u]=v\n            self.__depth[u]=self.__depth[v]+1\n            self.__dist[u]=self.__dist[v]+d\n            self.__dfs(u)\n\n    def __doubling(self):\n        for i in range(1,self.__logn):\n            for v in range(self.__n):\n                if(self.__parents[i-1][v]==-1): continue\n                self.__parents[i][v]=self.__parents[i-1][self.__parents[i-1][v]]\n\n    @property\n    def depth(self):\n        return self.__depth\n\n    @property\n    def dist(self):\n        return self.__dist\n\n    def get(self,u,v):\n        dd=self.__depth[v]-self.__depth[u]\n        if(dd<0): # v\u306e\u65b9\u304c\u6df1\u3044\u3088\u3046\u306b\u3059\u308b\n            u,v=v,u\n            dd*=-1\n        for i in range(self.__logn):\n            if(dd&(1<<i)): v=self.__parents[i][v]\n        if(v==u): return v\n        for i in range(self.__logn-1,-1,-1):\n            pu,pv=self.__parents[i][u],self.__parents[i][v]\n            if(pu!=pv): u,v=pu,pv\n        return self.__parents[0][u]\n\ndef resolve():\n    n,q=map(int,input().split())\n    E=[[] for _ in range(n)]\n    for _ in range(n-1):\n        a,b,c,d=map(int,input().split())\n        a-=1; b-=1\n        E[a].append((b,c,d))\n        E[b].append((a,c,d))\n    G=LCA(E)\n\n    # Query\u3092\u5148\u8aad\u307f\u3059\u308b\n    Qs=[[] for _ in range(n)] #Q[v]: idx, color, mag, coef\n    for i in range(q):\n        x,y,u,v=map(int,input().split())\n        u-=1; v-=1\n        c=G.get(u,v)\n        Qs[u].append((i,x,y,1))\n        Qs[v].append((i,x,y,1))\n        Qs[c].append((i,x,y,-2))\n\n    # dfs\u3067\u30af\u30a8\u30ea\u306b\u7b54\u3048\u3066\u3044\u304f\n    ans=[0]*q\n    S=[[0,0] for _ in range(n)] # S[col]: total num, total len\n    def dfs(v,p):\n        # \u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\n        # \u73fe\u5728\u306elength\u304b\u3089\u3001\u8272\u306etotal len\u3092\u5f15\u304d\u3001\u9752\u306e\u500b\u6570*\u500d\u7387(mug)\u3092\u8db3\u3057\u305f\u3082\u306e\u304c\u5909\u66f4\u5f8c\u306e\u9577\u3055\n        for idx,col,mag,coef in Qs[v]:\n            x=G.dist[v]\n            x-=S[col][1]\n            x+=mag*S[col][0]\n            ans[idx]+=x*coef\n        # \u9077\u79fb\n        for nv,col,d in E[v]:\n            if(nv==p): continue\n            S[col][0]+=1\n            S[col][1]+=d\n            dfs(nv,v)\n            S[col][0]-=1\n            S[col][1]-=d\n    dfs(0,-1)\n    print(*ans,sep=\"\\n\")\nresolve()", "import sys\nfrom itertools import combinations, permutations, product, combinations_with_replacement, accumulate\nfrom heapq import heapify, heappop, heappush, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, log, floor, ceil, factorial, cos, sin, pi#, gcd\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\nINF = float('inf')\nLINF = 2**63-1\nNIL = -LINF\nMOD = 10**9+7\nMGN = 4\ndef AST(exp: bool, msg: str = \"\"): assert exp, msg\ndef TAST(exp: bool, msg = \"\"):\n    if exp is False: print(\"TAssertionError:\", msg)\n    while exp is False:\n        pass\ndef EPR(msg): print(msg, file=sys.stderr)\ndef II(): return int(input())\ndef IF(): return float(input())\ndef IS(): return input().replace('\\n', '')\ndef ILCI(n: int): return [II() for _ in range(n)]\ndef ILCF(n: int): return [IF() for _ in range(n)]\ndef ILI(): return list(map(int, input().split()))\ndef ILLI(n: int): return [[int(j) for j in input().split()] for i in range(n)]\ndef ILF(): return list(map(float, input().split()))\ndef ILLF(n: int): return [[float(j) for j in input().split()] for i in range(n)]\ndef LTOS(lst: list, sep: str = ' '): return sep.join(map(str, lst))\ndef DEC(lst: list): return list(map(lambda x: x-1, lst))\ndef INC(lst: list): return list(map(lambda x: x+1, lst))\n\nclass LCA:\n    def __init__(self, N: int) -> None:\n        self.N = N\n        self.to = [[] for _ in range(N)]  \n        self.co = [[] for _ in range(N)]  \n        self.dep = [0] * N  \n        self.costs = [0] * N  \n        l = 0\n        while (1 << l) < N:\n            l += 1\n        self.l = l\n        self.par = [([0]*l) for _ in range(N+1)]  \n    def add_edge(self, a: int, b: int, c = 0) -> None:\n        self.to[a].append(b)\n        self.co[a].append(c)\n        self.to[b].append(a)\n        self.co[b].append(c)\n    def _dfs(self, v: int, d: int = 0, c = 0, p: int = -1) -> None:\n        if p != -1:\n            self.par[v][0] = p  \n        self.dep[v] = d\n        self.costs[v] = c\n        for i in range(len(self.to[v])):\n            u = self.to[v][i]\n            if u == p:\n                continue\n            else:\n                self._dfs(u, d+1, c+self.co[v][i], v)\n    def init(self, root: int = 0) -> None:\n        self.root = root\n        self._dfs(root)\n        for i in range(self.l - 1):\n            for v in range(self.N):\n                self.par[v][i+1] = self.par[self.par[v][i]][i]\n    #def __call__(self, a: int, b: int) -> int:\n    def lcs(self, a: int, b: int) -> int:\n        dep_s, dep_l = self.dep[a], self.dep[b]\n        self_par = self.par\n        if dep_s > dep_l:\n            a, b = b, a  \n            dep_s, dep_l = dep_l, dep_s\n        gap = dep_l - dep_s\n        L_1 = self.l-1\n        for i in range(L_1, -1, -1):\n            leng = 1 << i\n            if gap >= leng:\n                gap -= leng\n                b = self_par[b][i]\n        if a == b:  \n            return a\n        for i in range(L_1, -1, -1):\n            na = self_par[a][i]\n            nb = self_par[b][i]\n            if na != nb:\n                a, b = na, nb\n        return self_par[a][0]\n    def length(self, a: int, b: int) -> int:\n        #c = self.__call__(a, b)\n        c = self.lcs(a, b)\n        return self.dep[a] + self.dep[b] - self.dep[c] * 2\n    def dist(self, a: int, b: int):\n        #c = self.__call__(a, b)\n        c = self.lcs(a, b)\n        return self.costs[a] + self.costs[b] - self.costs[c] * 2\n\ndef main():\n    N,Q = ILI()\n    gr = LCA(N)\n    es = [[] for _ in range(N)]\n    for i in range(N-1):\n        a,b, col, dist = ILI()\n        a -= 1; b -= 1\n        es[a].append((b, dist, col))\n        es[b].append((a, dist, col))\n        gr.add_edge(a, b, dist)\n\n    gr.init()\n    ans = [0] * Q\n    qs = [[] for _ in range(N)]\n    for i in range(Q):\n        cx,dy, a,b = ILI()\n        a -= 1; b -= 1\n        #ans[i] = gr.dist(a, b)\n        c = gr.lcs(a, b)\n        ans[i] = gr.costs[a] + gr.costs[b] - gr.costs[c] * 2\n        qs[a].append((cx, i, 1, dy))\n        qs[b].append((cx, i, 1, dy))\n        qs[c].append((cx, i, -2, dy))\n\n    cnt = [0] * N\n    sum_ = [0] * N\n\n    def dfs(v: int, p: int = -1) -> None:\n        for (col,qid,coeff,dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n        \n        for (to, co, col) in es[v]:\n            if to == p:\n                continue\n            cnt[col] += 1\n            sum_[col] += co\n            dfs(to, v)\n            cnt[col] -= 1\n            sum_[col] -= co\n\n    dfs(0)\n\n    for an in ans:\n        print(an)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**6+1) #\u518d\u5e30\u95a2\u6570\u306e\u4e0a\u9650,10**5\u4ee5\u4e0a\u306e\u5834\u5408python\n\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printe(*x):print(\"## \",*x,file=sys.stderr)\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\n\n\n#N, Q = map(int, input().split())\nN, Q = map(int, input().split())\n#A = tuple(map(int, input().split())) #1\u884c\u30d9\u30af\u30c8\u30eb\n#L = tuple(int(input()) for i in range(N)) #\u6539\u884c\u30d9\u30af\u30c8\u30eb\n#S = tuple(tuple(map(int, input().split())) for i in range(N)) #\u6539\u884c\u884c\u5217\n\nedge = [[] for i in range(N)]\nfor i in range(N-1):#\u6728\u306e\u5834\u5408M=N-1\n    a,b,c,w = map(int,input().split())\n    edge[a-1].append((b-1,c-1,w))\n    edge[b-1].append((a-1,c-1,w)) #\u6709\u5411\u306e\u3070\u3042\u3044\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n\n\n\n#\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u308bLCA, \u524d\u51e6\u7406NlogN, \u547c\u3073\u51fa\u3057logN, \u5b89\u5b9a  \ndef dfs(start):\n    q=[(start,-1,0,0)]\n    pars=[-1]*N\n    depth=[-1]*N\n    dist=[-1]*N\n    while len(q):\n        e,p,d,dis=q.pop()#\u3053\u3053\u3092popleft\u306b\u3059\u308b\u3068\u5e45\u512a\u5148\u63a2\u7d22BFS\u306b\u306a\u308b\n        if depth[e]!=-1:continue\n        pars[e]=p\n        depth[e]=d\n        dist[e]=dis\n        for ne,c,w in edge[e]:\n            q.append((ne,e,d+1,dis+w))\n    return pars,depth,dist\npars,d,dist=dfs(0)\nln=N.bit_length()\ndp=[[-1]*N for _ in range(ln+1)]\ndp[0]=pars\nfor i in range(1,ln+1):\n    for j in range(N):\n        dp[i][j]=dp[i-1][dp[i-1][j]]\n\n\n# LCA\u306e\u8a08\u7b97\ndef lca(u, v):\n    du = d[u]; dv = d[v]\n    if du > dv:\n        du, dv = dv, du\n        u,v=v,u\n    dif=dv-du\n    for i in range(ln+1):\n        if (dif>>i)&1:\n            v=dp[i][v]\n    if u==v:return u\n    for i in range(ln,-1,-1):\n        pu=dp[i][u];pv=dp[i][v]\n        if pu!=pv:\n            u,v=pu,pv\n    return pars[u]\n\nq=Q\n#qs = tuple(tuple(map(int, input().split())) for i in range(Q)) #\u6539\u884c\u884c\u5217\n# ans=[0]*Q\n# qn=[[] for _ in range(N)]\n# for i,(x,y,u,v) in enumerate(qs):\n#     ans[i]=dist[u-1]+dist[v-1]-dist[lca(u-1,v-1)]\n#     qn[u-1].append((i,x-1,y))\n#     qn[v-1].append((i,x-1,y))\n# cnt=[0]*Q\n# #printe(qn)\n\n# qc=[[0,0] for _ in range(Q)]\n# cc=[[0,0] for _ in range(N-1)]\n\n# dfq=[(0,None,0,-1)]\n# def dfs2(e,c,d,p):\n#     if c!=None:\n#         cc[c][0]+=1\n#         cc[c][1]+=d\n#     for qi,x,y in qn[e]:\n#         if cnt[qi]==0:\n#             qc[qi][0]-=cc[x][0]\n#             qc[qi][1]-=cc[x][1]\n#         elif cnt[qi]==1:\n#             qc[qi][0]+=cc[x][0]\n#             qc[qi][1]+=cc[x][1]\n#             ans[qi]+=y*qc[qi][0]-qc[qi][1]\n#         cnt[qi]+=1\n#     for ne,nc,nd in edge[e]:\n#         if ne==par[e]:continue\n#         dfs2(ne,nc,nd,e)\n#     if c!=None:\n#         cc[c][0]+=1\n#         cc[c][1]+=d\n# dfs2(0)\n# printl(ans)\nn=N\nA = [0]*q\nC = [[] for _ in range(n)]\nnum = [0]*n\ncum = [0]*n\nfor i in range(q):\n  x, y, u, v = map(int, input().split())\n  u -= 1\n  v -= 1\n  a = lca(u, v)\n  C[u].append((i, x, y, 1))\n  C[v].append((i, x, y, 1))\n  C[a].append((i, x, y, -2))\ndist = 0\nstack = [0]\ndef dfs2(v):\n  nonlocal dist\n  for i, x, y, b in C[v]:\n    A[i] += (dist + num[x]*y - cum[x]) * b\n  for nv, c, d in edge[v]:\n    c+=1\n    if nv ==pars[v]:continue\n    dist += d\n    num[c] += 1\n    cum[c] += d\n    dfs2(nv)\n    dist -= d\n    num[c] -= 1\n    cum[c] -= d\ndfs2(0)\nprint(*A, sep=\"\\n\")", "import sys\ninput=lambda :sys.stdin.readline().rstrip()\nsys.setrecursionlimit(10**8)\n\nclass LCA(object):\n    def __init__(self, to, root=0):\n        self.__n = len(to)\n        self.__to = to\n        self.__logn = (self.__n - 1).bit_length()\n        self.__depth = [-1] * self.__n\n        self.__dist = [-1] * self.__n\n        self.__depth[root] = 0\n        self.__dist[root] = 0\n        self.__parents = [[-1] * self.__n for _ in range(self.__logn)]\n        self.__dfs(root)\n        self.__doubling()\n\n    def __dfs(self, v):\n        for u, c, d in self.__to[v]:\n            if self.__depth[u] != -1: continue\n            self.__parents[0][u] = v\n            self.__depth[u] = self.__depth[v] + 1\n            self.__dist[u] = self.__dist[v] + d\n            self.__dfs(u)\n\n    def __doubling(self):\n        for i in range(1, self.__logn):\n            for v in range(self.__n):\n                if self.__parents[i - 1][v] == -1: continue\n                self.__parents[i][v] = self.__parents[i - 1][self.__parents[i - 1][v]]\n\n    @property\n    def depth(self):\n        return self.__depth\n\n    @property\n    def dist(self):\n        return self.__dist\n\n    def get(self, u, v):\n        dd = self.__depth[v] - self.__depth[u]\n        if dd < 0:\n            u, v = v, u\n            dd *= -1\n        for i in range(self.__logn):\n            if dd & (2 ** i):\n                v = self.__parents[i][v]\n        if v == u: return v\n        for i in range(self.__logn - 1, -1, -1):\n            pu = self.__parents[i][u]\n            pv = self.__parents[i][v]\n            if pu != pv: u, v = pu, pv\n        return self.__parents[0][u]\n\ndef resolve():\n    n, q = map(int, input().split())\n    to = [[] for _ in range(n)]\n    for _ in range(n-1):\n        a, b, c, d = map(int, input().split())\n        a -= 1; b -= 1\n        to[a].append((b, c, d))\n        to[b].append((a, c, d))\n\n    G = LCA(to)\n    Query = [[] for _ in range(n)]\n    for i in range(q):\n    # idx, color, mag, coef\n        x, y, u, v = map(int, input().split())\n        u -= 1; v -= 1\n        c = G.get(u, v)\n        Query[u].append((i, x, y, 1))\n        Query[v].append((i, x, y, 1))\n        Query[c].append((i, x, y, -2))\n\n    ans = [0] * q\n    S = [[0, 0] for _ in range(n)]\n\n    def dfs(v, p=-1):\n        for idx, color, mag, coef in Query[v]:\n            x = G.dist[v]\n            x -= S[color][1]\n            x += mag * S[color][0]\n            ans[idx] += x * coef\n        for nv, color, d in to[v]:\n            if nv == p: continue\n            S[color][0] += 1\n            S[color][1] += d\n            dfs(nv, v)\n            S[color][0] -= 1\n            S[color][1] -= d\n    dfs(0)\n    print(*ans, sep=\"\\n\")\n\nresolve()", "import sys\nsys.setrecursionlimit(10**6+1) #\u518d\u5e30\u95a2\u6570\u306e\u4e0a\u9650,10**5\u4ee5\u4e0a\u306e\u5834\u5408python\n\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printe(*x):print(\"## \",*x,file=sys.stderr)\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\n\n\n#N, Q = map(int, input().split())\nN, Q = map(int, input().split())\n#A = tuple(map(int, input().split())) #1\u884c\u30d9\u30af\u30c8\u30eb\n#L = tuple(int(input()) for i in range(N)) #\u6539\u884c\u30d9\u30af\u30c8\u30eb\n#S = tuple(tuple(map(int, input().split())) for i in range(N)) #\u6539\u884c\u884c\u5217\n\nedge = [[] for i in range(N)]\nfor i in range(N-1):#\u6728\u306e\u5834\u5408M=N-1\n    a,b,c,w = map(int,input().split())\n    edge[a-1].append((b-1,c-1,w))\n    edge[b-1].append((a-1,c-1,w)) #\u6709\u5411\u306e\u3070\u3042\u3044\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n\n\n\n#\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u308bLCA, \u524d\u51e6\u7406NlogN, \u547c\u3073\u51fa\u3057logN, \u5b89\u5b9a  \ndef dfs(start):\n    q=[(start,-1,0,0)]\n    pars=[-1]*N\n    depth=[-1]*N\n    dist=[-1]*N\n    while len(q):\n        e,p,d,dis=q.pop()#\u3053\u3053\u3092popleft\u306b\u3059\u308b\u3068\u5e45\u512a\u5148\u63a2\u7d22BFS\u306b\u306a\u308b\n        if depth[e]!=-1:continue\n        pars[e]=p\n        depth[e]=d\n        dist[e]=dis\n        for ne,c,w in edge[e]:\n            q.append((ne,e,d+1,dis+w))\n    return pars,depth,dist\npars,d,dist=dfs(0)\nln=N.bit_length()\ndp=[[-1]*N for _ in range(ln+1)]\ndp[0]=pars\nfor i in range(1,ln+1):\n    for j in range(N):\n        dp[i][j]=dp[i-1][dp[i-1][j]]\n\n\n# LCA\u306e\u8a08\u7b97\ndef lca(u, v):\n    du = d[u]; dv = d[v]\n    if du > dv:\n        du, dv = dv, du\n        u,v=v,u\n    dif=dv-du\n    for i in range(ln+1):\n        if (dif>>i)&1:\n            v=dp[i][v]\n    if u==v:return u\n    for i in range(ln,-1,-1):\n        pu=dp[i][u];pv=dp[i][v]\n        if pu!=pv:\n            u,v=pu,pv\n    return pars[u]\n\nq=Q\nqs = tuple(tuple(map(int, input().split())) for i in range(Q)) #\u6539\u884c\u884c\u5217\nans=[0]*Q\nqn=[[] for _ in range(N)]\nfor i,(x,y,u,v) in enumerate(qs):\n    ans[i]=dist[u-1]+dist[v-1]-2*dist[lca(u-1,v-1)]\n    qn[u-1].append((i,x-1,y,1))\n    qn[v-1].append((i,x-1,y,1))\n    qn[lca(u-1,v-1)].append((i,x-1,y,-2))\ncnt=[0]*Q\n#printe(qn)\n\nqc=[[0,0] for _ in range(Q)]\ncc=[[0,0] for _ in range(N-1)]\n\ndfq=[(0,None,0,-1)]\ndef dfs2(e):\n    for qi,x,y,sgn in qn[e]:\n        ans[qi]+=(y*cc[x][0]-cc[x][1])*sgn\n    for ne,c,nd in edge[e]:\n        if ne==pars[e]:continue\n        if c!=None:\n            cc[c][0]+=1\n            cc[c][1]+=nd\n        dfs2(ne)\n        if c!=None:\n            cc[c][0]-=1\n            cc[c][1]-=nd\ndfs2(0)\nprintl(ans)\n\n# n=N\n# A = [0]*q\n# C = [[] for _ in range(n)]\n# num = [0]*n\n# cum = [0]*n\n# for i in range(q):\n#   x, y, u, v = map(int, input().split())\n#   u -= 1\n#   v -= 1\n#   a = lca(u, v)\n#   C[u].append((i, x, y, 1))\n#   C[v].append((i, x, y, 1))\n#   C[a].append((i, x, y, -2))\n# dist = 0\n# stack = [0]\n# def dfs2(v):\n#   nonlocal dist\n#   for i, x, y, b in C[v]:\n#     A[i] += (dist + num[x]*y - cum[x]) * b\n#   for nv, c, d in edge[v]:\n#     c+=1\n#     if nv ==pars[v]:continue\n#     dist += d\n#     num[c] += 1\n#     cum[c] += d\n#     dfs2(nv)\n#     dist -= d\n#     num[c] -= 1\n#     cum[c] -= d\n# dfs2(0)\n# print(*A, sep=\"\\n\")", "import sys\n\ninput=sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN,Q=map(int,input().split())\nedge=[[] for i in range(N)]\nfor i in range(N-1):\n    a,b,c,d=map(int,input().split())\n    edge[a-1].append((b-1,c,d))\n    edge[b-1].append((a-1,c,d))\n\nprv=[-1]*N\ndepth=[0]*N\ndist=[0 for i in range(N)]\ndef dfs(v,pv):\n    prv[v]=pv\n    for nv,color,weight in edge[v]:\n        if nv!=pv:\n            depth[nv]=depth[v]+1\n            dist[nv]=dist[v]+weight\n            dfs(nv,v)\n\ndfs(0,-1)\n\nLV = (N-1).bit_length()\ndef construct(prv):\n    kprv = [prv]\n    S = prv\n    for k in range(LV):\n        T = [0]*N\n        for i in range(N):\n            if S[i] is None:\n                continue\n            T[i] = S[S[i]]\n        kprv.append(T)\n        S = T\n    return kprv\n\nkprv=construct(prv)\n\ndef lca(u, v):\n    dd = depth[v] - depth[u]\n    if dd < 0:\n        u, v = v, u\n        dd = -dd\n\n    # assert depth[u] <= depth[v]\n    for k in range(LV+1):\n        if dd & 1:\n            v = kprv[k][v]\n        dd >>= 1\n\n    # assert depth[u] == depth[v]\n    if u == v:\n        return u\n\n    for k in range(LV-1, -1, -1):\n        pu = kprv[k][u]; pv = kprv[k][v]\n        if pu != pv:\n            u = pu; v = pv\n\n    # assert kprv[0][u] == kprv[0][v]\n    return kprv[0][u]\n\nquery=[]\nq=[[] for i in range(N)]\ndata={}\nfor i in range(Q):\n    x,y,u,v=map(int,input().split())\n    LCA=lca(u-1,v-1)\n    query.append((x,y,u-1,v-1,LCA))\n    q[u-1].append(x)\n    q[v-1].append(x)\n    q[LCA].append(x)\n\nnum=[0 for i in range(N)]\ncdist=[0 for i in range(N)]\n\ndef dfsc(v,pv,color,weight):\n    pn=num[color]\n    num[color]+=1\n    pd=cdist[color]\n    cdist[color]+=weight\n    for x in q[v]:\n        data[(v,x)]=(0,0)\n        data[(v,x)]=(num[x],cdist[x])\n\n    for nv,ncolor,nweight in edge[v]:\n        if nv!=pv:\n            dfsc(nv,v,ncolor,nweight)\n\n    num[color]=pn\n    cdist[color]=pd\n\n\n\ndfsc(0,0,0,0)\n\nfor x,y,u,v,LCA in query:\n    d1=dist[LCA]-data[(LCA,x)][1]+data[(LCA,x)][0]*y\n    d2=dist[u]-data[(u,x)][1]+data[(u,x)][0]*y\n    d3=dist[v]-data[(v,x)][1]+data[(v,x)][0]*y\n    print(d2-d1+d3-d1)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\n\n\nclass SegmentTree1():\n    \"\"\"\n    1-indexed Segment Tree\n    \"\"\"\n    def __init__(self, n_, ele_id, operation_func):\n        self.n = 1 << (n_ - 1).bit_length()  # size\n        self.data = [ele_id] * (2 * self.n)  # binary tree\n        self.ele_id = ele_id  # identity element\n        self.operation_func = operation_func  # binary operation of monoid\n\n    def __getitem__(self, idx):\n        return self.data[idx + self.n]\n\n    def build(self, data_init):\n        for i in range(len(data_init)):\n            self.data[i + self.n] = data_init[i]\n        for i in range(self.n - 1, 0, -1):\n            self.data[i] = self.operation_func(self.data[2 * i],\n                                               self.data[2 * i + 1])\n\n    def update(self, idx, x):\n        # change idx-th element to x (idx : 0-indexed)\n        idx += self.n\n        self.data[idx] = x\n        while idx > 1:\n            idx = idx >> 1\n            self.data[idx] = self.operation_func(self.data[2 * idx],\n                                                 self.data[2 * idx + 1])\n\n    def query(self, l, r):\n        # query for interval [l, r) (l, r : 0-indexed)\n        l += self.n\n        r += self.n\n        ret = self.ele_id\n        while l < r:\n            if l & 1:  # right child\n                ret = self.operation_func(ret, self.data[l])\n                l += 1\n            if r & 1:  # right child\n                r -= 1\n                ret = self.operation_func(ret, self.data[r])\n            # go to parent-nodes\n            l = l >> 1\n            r = r >> 1\n        return ret\n\n\nclass Tree():\n    def __init__(self, n, graph, v_root):\n        self.n = n  # number of nodes\n        self.graph = graph  # adjacent list of graph\n        self.v_root = v_root  # root node\n\n        # euler tour\n        self.first_idx = [2 * self.n] * self.n\n        self.euler_tour = []\n        self.euler_depth_topo = []\n        self.euler_depth_real = []\n        self.cs_color = [0] * self.n\n        self.euler_tour_dfs(self.v_root, -1, 0, 0)\n\n        depth_list = [(di, i) for i, di in enumerate(self.euler_depth_topo)]\n        INF = (2 * self.n, -1)\n        operation_func = lambda a, b: a if a[0] < b[0] else b\n        self.st_rmq = SegmentTree1(2 * self.n - 1, INF, operation_func)\n        self.st_rmq.build(depth_list)\n\n    def euler_tour_dfs(self, v, v_par, depth_topo, depth_real):\n        self.first_idx[v] = len(self.euler_tour)\n        self.euler_tour.append(v)\n        self.euler_depth_topo.append(depth_topo)\n        self.euler_depth_real.append(depth_real)\n        for v_next, c, d in self.graph[v]:\n            if v_next == v_par:\n                continue\n            self.euler_tour_dfs(v_next, v, depth_topo + 1, depth_real + d)\n            self.euler_tour.append(v)\n            self.euler_depth_topo.append(depth_topo)\n            self.euler_depth_real.append(depth_real)\n\n    def depth_topo(self, v):\n        return self.euler_depth_topo[self.first_idx[v]]\n\n    def depth_real(self, v):\n        return self.euler_depth_real[self.first_idx[v]]\n\n    def lca(self, u, v):\n        u_idx, v_idx = self.first_idx[u], self.first_idx[v]\n        if u_idx > v_idx:\n            u_idx, v_idx = v_idx, u_idx\n        _, idx = self.st_rmq.query(u_idx, v_idx + 1)\n        return self.euler_tour[idx]\n\n    def dist(self, u, v):\n        lca_uv = self.lca(u, v)\n        return self.depth(u) + self.depth(v) - 2 * self.depth(lca_uv)\n\n\nn, q = list(map(int, input().split()))\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b, c, d = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    graph[a].append((b, c, d))\n    graph[b].append((a, c, d))\n\ntree = Tree(n, graph, 0)\n\nquery = []\nmemo = [set() for i in range(n)]\nfor _ in range(q):\n    x, y, u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    lca_uv = tree.lca(u, v)\n    memo[u].add(x)\n    memo[v].add(x)\n    memo[lca_uv].add(x)\n\n    query.append((x, y, u, v, lca_uv))\n\nn_color = [0] * n\nd_color = [0] * n\nn_color_memo = {}\nd_color_memo = {}\n\n\ndef dfs(v, v_par, depth):\n    for c in memo[v]:\n        n_color_memo[(v, c)] = n_color[c]\n        d_color_memo[(v, c)] = d_color[c]\n\n    for v_next, c, d in graph[v]:\n        if v_next == v_par:\n            continue\n        n_color[c] += 1\n        d_color[c] += d\n        dfs(v_next, v, depth + d)\n        n_color[c] -= 1\n        d_color[c] -= d\n\n\ndfs(0, -1, 0)\n\nfor x, y, u, v, lca in query:\n    depth_u = tree.depth_real(u)\n    depth_u += -d_color_memo[(u, x)] + y * n_color_memo[(u, x)]\n    depth_v = tree.depth_real(v)\n    depth_v += -d_color_memo[(v, x)] + y * n_color_memo[(v, x)]\n    depth_lca = tree.depth_real(lca)\n    depth_lca += -d_color_memo[(lca, x)] + y * n_color_memo[(lca, x)]\n\n    ans = depth_u + depth_v - 2 * depth_lca\n    print(ans)\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 5 + 5)\n\n\ndef solve(n, links, queries):\n    def _query(a, b, data, m0, INF):\n        yield INF\n        a += m0\n        b += m0\n        while a < b:\n            if b & 1:\n                b -= 1\n                yield data[b - 1]\n            if a & 1:\n                yield data[a - 1]\n                a += 1\n            a >>= 1\n            b >>= 1\n\n    def query(u, v):\n        fu = first_appear[u]\n        fv = first_appear[v]\n        if fu > fv:\n            fu, fv = fv, fu\n        return euler_tour[min(_query(fu, fv + 1, data, m0, INF))[1]]\n\n    def dfs(v, p, dep):\n        first_appear[v] = len(euler_tour)\n        depth[v] = dep\n        euler_tour.append(v)\n        for u, _, _ in links[v]:\n            if u == p:\n                continue\n            dfs(u, v, dep + 1)\n            euler_tour.append(v)\n\n    def dfs2(v, p, tmp_dists, total_dist):\n        for x, arr in list(v_queries[v].items()):\n            arr[0] = total_dist - tmp_dists[x][0]\n            arr[1] = tmp_dists[x][1]\n        for u, uc, ud in links[v]:\n            if u == p:\n                continue\n            tmp_dists[uc][0] += ud\n            tmp_dists[uc][1] += 1\n            dfs2(u, v, tmp_dists, total_dist + ud)\n            tmp_dists[uc][0] -= ud\n            tmp_dists[uc][1] -= 1\n\n    # \u5b58\u5728\u3057\u306a\u3044\u7bc4\u56f2\u306f\u6df1\u3055\u304c\u4ed6\u3088\u308a\u3082\u5927\u304d\u304f\u306a\u308b\u3088\u3046\u306b\u3059\u308b\n    INF = (n, None)\n\n    # Euler Tour \u306e\u69cb\u7bc9\n    euler_tour = []\n    first_appear = [0] * n\n    depth = [0] * n\n\n    dfs(0, -1, 0)\n    # print(euler_tour)\n    # print(first_appear)\n    # print(depth)\n\n    # LCA\u3092\u8a08\u7b97\u3059\u308b\u30af\u30a8\u30ea\u306e\u524d\u8a08\u7b97\n    m = 2 * n\n    m0 = 2 ** (m - 1).bit_length()\n    data = [INF] * (2 * m0)\n    for i, v in enumerate(euler_tour):\n        data[m0 - 1 + i] = (depth[v], i)\n    for i in range(m0 - 2, -1, -1):\n        data[i] = min(data[2 * i + 1], data[2 * i + 2])\n\n    # print(data)\n\n    v_queries = [{} for _ in range(n)]\n    lca = []\n    for i, (x, y, u, v) in enumerate(queries):\n        w = query(u, v)\n        lca.append(w)\n        v_queries[u][x] = [0, 0]\n        v_queries[v][x] = [0, 0]\n        if w != 0:\n            v_queries[w][x] = [0, 0]\n\n    tmp_dists = defaultdict(lambda: [0, 0])\n    dfs2(0, -1, tmp_dists, 0)\n\n    ans = []\n    for w, (x, y, u, v) in zip(lca, queries):\n        qu = v_queries[u][x]\n        qv = v_queries[v][x]\n        du = qu[0] + qu[1] * y\n        dv = qv[0] + qv[1] * y\n        if w == 0:\n            ans.append(du + dv)\n            continue\n        qw = v_queries[w][x]\n        dw = qw[0] + qw[1] * y\n        ans.append(du + dv - 2 * dw)\n\n    return ans\n\n\nn, q = list(map(int, input().split()))\nlinks = [set() for _ in range(n)]\nlines = sys.stdin.readlines()\nfor line in lines[:n - 1]:\n    a, b, c, d = list(map(int, line.split()))\n    a -= 1\n    b -= 1\n    links[a].add((b, c, d))\n    links[b].add((a, c, d))\nqueries = []\nfor line in lines[n - 1:]:\n    x, y, u, v = list(map(int, line.split()))\n    u -= 1\n    v -= 1\n    queries.append((x, y, u, v))\n\nans = solve(n, links, queries)\n\nprint(('\\n'.join(map(str, ans))))\n", "import sys\nsys.setrecursionlimit(10**6+1) #\u518d\u5e30\u95a2\u6570\u306e\u4e0a\u9650,10**5\u4ee5\u4e0a\u306e\u5834\u5408python\n\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printe(*x):print(\"## \",*x,file=sys.stderr)\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\n\n\n#N, Q = map(int, input().split())\nN, Q = map(int, input().split())\n#A = tuple(map(int, input().split())) #1\u884c\u30d9\u30af\u30c8\u30eb\n#L = tuple(int(input()) for i in range(N)) #\u6539\u884c\u30d9\u30af\u30c8\u30eb\n#S = tuple(tuple(map(int, input().split())) for i in range(N)) #\u6539\u884c\u884c\u5217\n\nedge = [[] for i in range(N)]\nfor i in range(N-1):#\u6728\u306e\u5834\u5408M=N-1\n    a,b,c,w = map(int,input().split())\n    edge[a-1].append((b-1,c-1,w))\n    edge[b-1].append((a-1,c-1,w)) #\u6709\u5411\u306e\u3070\u3042\u3044\u30b3\u30e1\u30f3\u30c8\u30a2\u30a6\u30c8\n\n\n\n#\u30c0\u30d6\u30ea\u30f3\u30b0\u306b\u3088\u308bLCA, \u524d\u51e6\u7406NlogN, \u547c\u3073\u51fa\u3057logN, \u5b89\u5b9a  \ndef dfs(start):\n    q=[(start,-1,0,0)]\n    pars=[-1]*N\n    depth=[-1]*N\n    dist=[-1]*N\n    while len(q):\n        e,p,d,dis=q.pop()#\u3053\u3053\u3092popleft\u306b\u3059\u308b\u3068\u5e45\u512a\u5148\u63a2\u7d22BFS\u306b\u306a\u308b\n        if depth[e]!=-1:continue\n        pars[e]=p\n        depth[e]=d\n        dist[e]=dis\n        for ne,c,w in edge[e]:\n            q.append((ne,e,d+1,dis+w))\n    return pars,depth,dist\npars,d,dist=dfs(0)\nln=N.bit_length()\ndp=[[-1]*N for _ in range(ln+1)]\ndp[0]=pars\nfor i in range(1,ln+1):\n    for j in range(N):\n        dp[i][j]=dp[i-1][dp[i-1][j]]\n\n\n# LCA\u306e\u8a08\u7b97\ndef lca(u, v):\n    du = d[u]; dv = d[v]\n    if du > dv:\n        du, dv = dv, du\n        u,v=v,u\n    dif=dv-du\n    for i in range(ln+1):\n        if (dif>>i)&1:\n            v=dp[i][v]\n    if u==v:return u\n    for i in range(ln,-1,-1):\n        pu=dp[i][u];pv=dp[i][v]\n        if pu!=pv:\n            u,v=pu,pv\n    return pars[u]\n\nq=Q\nqs = tuple(tuple(map(int, input().split())) for i in range(Q)) #\u6539\u884c\u884c\u5217\nans=[0]*Q\nqn=[[] for _ in range(N)]\nfor i,(x,y,u,v) in enumerate(qs):\n    ans[i]=dist[u-1]+dist[v-1]-2*dist[lca(u-1,v-1)]\n    qn[u-1].append((i,x-1,y,1))\n    qn[v-1].append((i,x-1,y,1))\n    qn[lca(u-1,v-1)].append((i,x-1,y,-2))\n\ncc=[[0,0] for _ in range(N-1)]\n\ndfq=[(0,None,0,-1)]\ndef dfs2(e,c,d,p):\n    if c!=None:\n        cc[c][0]+=1\n        cc[c][1]+=d\n    for qi,x,y,sgn in qn[e]:\n        ans[qi]+=(y*cc[x][0]-cc[x][1])*sgn\n    for ne,nc,nd in edge[e]:\n        if ne==pars[e]:continue\n        dfs2(ne,nc,nd,e)\n    if c!=None:\n        cc[c][0]-=1\n        cc[c][1]-=d\ndfs2(0,-1,0,None)\nprintl(ans)\n\n# n=N\n# A = [0]*q\n# C = [[] for _ in range(n)]\n# num = [0]*n\n# cum = [0]*n\n# for i in range(q):\n#   x, y, u, v = map(int, input().split())\n#   u -= 1\n#   v -= 1\n#   a = lca(u, v)\n#   C[u].append((i, x, y, 1))\n#   C[v].append((i, x, y, 1))\n#   C[a].append((i, x, y, -2))\n# dist = 0\n# stack = [0]\n# def dfs2(v):\n#   nonlocal dist\n#   for i, x, y, b in C[v]:\n#     A[i] += (dist + num[x]*y - cum[x]) * b\n#   for nv, c, d in edge[v]:\n#     c+=1\n#     if nv ==pars[v]:continue\n#     dist += d\n#     num[c] += 1\n#     cum[c] += d\n#     dfs2(nv)\n#     dist -= d\n#     num[c] -= 1\n#     cum[c] -= d\n# dfs2(0)\n# print(*A, sep=\"\\n\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nclass LCA:\n    def __init__(self, edge, root):\n        self.l = len(edge)\n        self.stack = []\n        self.stack.append((root, 0))\n        self.vs = []\n        self.depth = [0]*self.l\n        self.firstVisited = [-1]*self.l\n        while self.stack:\n            v, d = self.stack[-1]\n            if self.firstVisited[v] == -1:\n                self.firstVisited[v] = len(self.vs)\n            self.vs.append(v)\n            self.depth[v] = d\n            if edge[v]:\n                self.stack.append((edge[v].pop(), d+1))\n            else:\n                self.stack.pop()\n        \n        self.n = len(self.vs)\n        self.INF = (self.l, self.l)\n        self.N0 = 1 << (self.n-1).bit_length()\n        self.seg = [self.INF]*(self.N0 << 1)\n        for i, v in enumerate(self.vs, self.N0):\n            self.seg[i] = (self.depth[v], v)\n        for i in range(self.N0-1, 0, -1):\n            self.seg[i] = min(self.seg[2*i], self.seg[2*i+1])\n    \n    def _query(self, l, r):\n        res = self.INF\n        l += self.N0\n        r += self.N0\n        while l < r:\n            if r & 1:\n                res = min(res, self.seg[r-1])\n            if l & 1:\n                res = min(res, self.seg[l])\n                l += 1\n            l >>= 1\n            r >>= 1\n     \n        return res\n\n    def query(self, u, v):\n        fu, fv = self.firstVisited[u], self.firstVisited[v]\n        if fu > fv:\n            fu, fv = fv, fu\n        return self._query(fu, fv+1)[1]\n\nn, q = map(int, input().split())\nT = [[] for _ in range(n)]\nfor _ in range(n-1):\n  a, b, c, d = map(int, input().split())\n  a -= 1\n  b -= 1\n  T[a].append((b, c, d))\n  T[b].append((a, c, d))\nG = [[] for _ in range(n)]\nedge = [[] for _ in range(n)]\nstack = [(0, -1)]\nwhile stack:\n  v, par = stack.pop()\n  for nv, c, d in T[v]:\n    if nv == par:\n      continue\n    G[v].append((nv, c, d))\n    edge[v].append(nv)\n    stack.append((nv, v))\n\nseg = LCA(edge, 0)\nA = [0]*q\nC = [[] for _ in range(n)]\nnum = [0]*n\ncum = [0]*n\nfor i in range(q):\n  x, y, u, v = map(int, input().split())\n  u -= 1\n  v -= 1\n  a = seg.query(u, v)\n  C[u].append((i, x, y, 1))\n  C[v].append((i, x, y, 1))\n  C[a].append((i, x, y, -2))\ndist = 0\nstack = [0]\ndef dfs(v):\n  nonlocal dist\n  for i, x, y, b in C[v]:\n    A[i] += (dist + num[x]*y - cum[x]) * b\n  for nv, c, d in G[v]:\n    dist += d\n    num[c] += 1\n    cum[c] += d\n    dfs(nv)\n    dist -= d\n    num[c] -= 1\n    cum[c] -= d\ndfs(0)\nprint(*A, sep=\"\\n\")", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import defaultdict\n\nN,Q = list(map(int,input().split()))\ngraph = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a,b,c,d = list(map(int,input().split()))\n    graph[a].append((b,c,d))\n    graph[b].append((a,c,d))\nquery = [[int(x) for x in input().split()] for _ in range(Q)]\n\ndef set_ancestor(x=1, d=0, parent=0):\n    depth[x] = d\n    ax = ancestor[x]\n    ax[0] = parent\n    for i in range(d.bit_length() - 1):\n        ax[i+1] = ancestor[ax[i]][i]\n    for y, _, _ in graph[x]:\n        if y == parent:\n            continue\n        set_ancestor(y, d+1, x)\n\ndepth = [0] * (N+1)\nU = 17\nancestor = [[0] * (U+1) for _ in range(N+1)] # 2**i \u3060\u3051\u9061\u3063\u305f\u9802\u70b9\u306e\u756a\u53f7\u3001\u884c\u304d\u904e\u304e\u306f0\nset_ancestor()\n\ndef LCA(x,y):\n    dx = depth[x]\n    dy = depth[y]\n    if dx > dy:\n        x,y = y,x\n        dx,dy = dy,dx\n    diff = dy - dx\n    while diff:\n        step = diff & (-diff)\n        y = ancestor[y][step.bit_length() - 1]\n        diff -= step\n    while x != y:\n        j = 0\n        while ancestor[x][j] != ancestor[y][j]:\n            j += 1\n        if j == 0:\n            return ancestor[x][0]\n        x = ancestor[x][j-1]\n        y = ancestor[y][j-1]\n    return x\n\ntasks = [[] for _ in range(N+1)]\nfor i,(x,y,u,v) in enumerate(query):\n    tasks[u].append((i,x,y,1))\n    tasks[v].append((i,x,y,1))\n    tasks[LCA(u,v)].append((i,x,y,-2))\n\nanswer = [0] * Q\n\ndef dfs(x = 1, sums = [0] * (N+1), nums = [0] * (N+1), total = 0, parent = 0):\n    for i,c,d,coef in tasks[x]:\n        answer[i] += coef * (total - sums[c] + nums[c] * d)\n    for y,c,d in graph[x]:\n        if y == parent:\n            continue\n        sums[c] += d\n        nums[c] += 1\n        total += d\n        dfs(y, sums, nums, total, x)\n        sums[c] -= d\n        nums[c] -= 1\n        total -= d\n    return\n\ndfs()\n\nprint(('\\n'.join(map(str,answer))))\n\n", "import sys\nsys.setrecursionlimit(10**7)\n\ndef main0(n,g,xyuv):\n  # LCA\u3092\u6c42\u3081\u308b\u3002\u81ea\u4f5c\u3059\u308b\u3002\n  # \u5404\u9802\u70b9\u306e\u6df1\u3055\u3002\u6839\u306f\u6df1\u30550\n  depth=[0]*n\n  tour=[]\n  hatsu=[0]*n\n  dist=[0]*n\n  tmp=0\n  def et(p,v,tour,tmp,pc,pd):\n    hatsu[v]=len(tour)-1\n    for nv,c,d in g[v]:\n      if nv==p:continue\n      depth[nv]=depth[v]+1\n      tmp+=d\n      dist[nv]=tmp\n      tour.append((nv,c,d))\n      tour=et(v,nv,tour,tmp,c,d)\n      tmp-=d\n      tour.append((v,c,-d))\n    return tour\n  tour.append((0,0,0))\n  tour=et(-1,0,tour,0,0,0)\n  class SegmentTree():\n    def __init__(self,size,f=lambda x,y:x+y,default=0):\n      self.size=pow(2,(size-1).bit_length())\n      self.f=f\n      self.default=default\n      self.data=[default]*(self.size*2)\n    def update(self,i,x):\n      i+=self.size\n      self.data[i]=x\n      while i:\n        i>>=1\n        self.data[i]=self.f(self.data[i*2],self.data[i*2+1])\n    # \u533a\u9593[l,r)\u3078\u306e\u30af\u30a8\u30ea\n    def query(self,l,r):\n      l,r=l+self.size,r+self.size\n      lret,rret=self.default,self.default\n      while l<r:\n        if l&1:\n          lret=self.f(self.data[l],lret)\n          l+=1\n        if r&1:\n          r-=1\n          rret=self.f(self.data[r],rret)\n        l>>=1\n        r>>=1\n      return self.f(lret,rret)\n\n  def func(x,y):\n    if x[0]<y[0]:return x\n    return y\n  st=SegmentTree(len(tour),func,(n+1,0))\n  for i,x in enumerate(tour):\n    v=x[0]\n    st.update(i,(depth[v],v))\n  def lca(u,v):\n    x,y=hatsu[u],hatsu[v]\n    if x<y:\n      y+=1\n    else:\n      x,y=y,x\n      y+=1\n    return st.query(x,y)[1]\n  dc={}\n  dcary={}\n  for i,(v,c,d) in enumerate(tour):\n    if c in dc:\n      ci=1 if d>0 else -1\n      dc[c].append((dc[c][-1][0]+ci,dc[c][-1][1]+d))\n      dcary[c].append(i)\n    else:\n      dc[c]=[(0,0),(1,d)]\n      dcary[c]=[0,i]\n  ret=[]\n  from bisect import bisect_right as bl\n  for x,y,u,v in xyuv:\n    u,v=u-1,v-1\n    w=lca(u,v)\n    uvlen=dist[u]+dist[v]-dist[w]*2\n    if x not in dc:\n      ret.append(uvlen)\n      continue\n    widx=bl(dcary[x],hatsu[w])-1\n    wnum,wsum=dc[x][widx]\n    uidx=bl(dcary[x],hatsu[u])-1\n    vidx=bl(dcary[x],hatsu[v])-1\n    unum,usum=dc[x][uidx]\n    vnum,vsum=dc[x][vidx]\n    uvsum=usum+vsum-wsum*2\n    uvnum=unum+vnum-wnum*2\n    #print(uvlen-uvsum+uvnum*y,uvlen,usum,vsum,wsum,uvnum,w)\n    ret.append(uvlen-uvsum+uvnum*y)\n  return ret\n\ndef __starting_point():\n  n,q=map(int,input().split())\n  abcd=[list(map(int,input().split())) for _ in range(n-1)]\n  xyuv=[list(map(int,input().split())) for _ in range(q)]\n  g=[[] for _ in range(n)]\n  for a,b,c,d in abcd:\n    a,b=a-1,b-1\n    g[a].append((b,c,d))\n    g[b].append((a,c,d))\n  ary0=main0(n,g,xyuv)\n  print(*ary0,sep='\\n')\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\n\ndef read_values():\n    return list(map(int, input().split()))\n\n\ndef read_index():\n    return [int(x) - 1 for x in input().split()]\n\n\ndef read_list():\n    return list(read_values())\n\n\ndef read_lists(N):\n    return [read_list() for n in range(N)]\n\n\nclass V:\n    def __init__(self, f, v=None):\n        self.f = f\n        self.v = v\n\n    def __str__(self):\n        return str(self.v)\n\n    def ud(self, n):\n        if n is None:\n            return\n\n        if self.v is None:\n            self.v = n\n            return\n        self.v = self.f(self.v, n)\n\n\nclass LCA:\n    def __init__(self, N, L):\n        self.L = L\n        self.INF = (N, None)\n        self.M0 = 2 ** (2 * N - 1).bit_length()\n        self.data = [self.INF] * (2 * self.M0)\n        self.D = [0] * N\n        self.F = [0] * N\n        self.S = []\n        self.dist = [0] * N\n\n        self.dfs1(0, 0, -1)\n        for i, v in enumerate(self.S):\n            self.data[self.M0 - 1 + i] = (self.D[v], i)\n        for i in range(self.M0 - 2, -1, -1):\n            self.data[i] = min(self.data[2 * i + 1], self.data[2 * i + 2])\n\n    def dfs1(self, v, d, p, pd=0):\n        self.F[v] = len(self.S)\n        self.D[v] = d\n        self.S.append(v)\n        self.dist[v] = pd\n        for w, c, dis in self.L[v]:\n            if w == p:\n                continue\n            self.dfs1(w, d + 1, v, pd + dis)\n            self.S.append(v)\n\n    def _query(self, a, b):\n        yield self.INF\n        a += self.M0\n        b += self.M0\n        while a < b:\n            if b & 1:\n                b -= 1\n                yield self.data[b - 1]\n            if a & 1:\n                yield self.data[a - 1]\n                a += 1\n            a >>= 1\n            b >>= 1\n\n    def query(self, u, v):\n        fu = self.F[u]\n        fv = self.F[v]\n        if fu > fv:\n            fu, fv = fv, fu\n        return self.S[min(self._query(fu, fv + 1))[1]]\n\n    def dist(self, v):\n        return self.dist[v]\n\n\ndef dfs2(L, v, p, QS, ans, CC, CD):\n    for q, x, y, f in QS[v]:\n        ans[q] += (y * CC[x] - CD[x]) * f\n\n    for w, c, dis in L[v]:\n        if w == p:\n            continue\n        CC[c] += 1\n        CD[c] += dis\n        dfs2(L, w, v, QS, ans, CC, CD)\n        CC[c] -= 1\n        CD[c] -= dis\n\n\ndef main():\n    N, Q = read_values()\n    L = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b, c, d = read_values()\n        a -= 1\n        b -= 1\n        c -= 1\n        L[a].append((b, c, d))\n        L[b].append((a, c, d))\n\n    g = LCA(N, L)\n\n    QS = [[] for _ in range(N)]\n    ans = [0] * Q\n    for q in range(Q):\n        x, y, u, v = read_values()\n        x -= 1\n        u -= 1\n        v -= 1\n        w = g.query(u, v)\n        ans[q] = g.dist[u] + g.dist[v] - 2 * g.dist[w]\n        QS[u].append((q, x, y, 1))\n        QS[v].append((q, x, y, 1))\n        QS[w].append((q, x, y, -2))\n\n    CC = [0] * N\n    CD = [0] * N\n    dfs2(L, 0, -1, QS, ans, CC, CD)\n\n    print((\"\\n\".join(map(str, ans))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom itertools import combinations, permutations, product, combinations_with_replacement, accumulate\nfrom heapq import heapify, heappop, heappush, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter, defaultdict, deque\nfrom math import sqrt, log, floor, ceil, factorial, cos, sin, pi  # , gcd\nfrom fractions import gcd\nfrom operator import mul\nfrom functools import reduce\n\nsys.setrecursionlimit(10 ** 8)\ninput = sys.stdin.readline\nINF = float('inf')\nLINF = 2 ** 63 - 1\nNIL = -LINF\nMOD = 10 ** 9 + 7\nMGN = 4\n\n\ndef AST(exp: bool, msg: str = \"\"): assert exp, msg\n\n\ndef TAST(exp: bool, msg=\"\"):\n    if exp is False: print(\"TAssertionError:\", msg)\n    while exp is False:\n        pass\n\n\ndef EPR(msg): print(msg, file=sys.stderr)\n\n\ndef II(): return int(input())\n\n\ndef IF(): return float(input())\n\n\ndef IS(): return input().replace('\\n', '')\n\n\ndef ILCI(n: int): return [II() for _ in range(n)]\n\n\ndef ILCF(n: int): return [IF() for _ in range(n)]\n\n\ndef ILI(): return list(map(int, input().split()))\n\n\ndef ILLI(n: int): return [[int(j) for j in input().split()] for i in range(n)]\n\n\ndef ILF(): return list(map(float, input().split()))\n\n\ndef ILLF(n: int): return [[float(j) for j in input().split()] for i in range(n)]\n\n\ndef LTOS(lst: list, sep: str = ' '): return sep.join(map(str, lst))\n\n\ndef DEC(lst: list): return list(map(lambda x: x - 1, lst))\n\n\ndef INC(lst: list): return list(map(lambda x: x + 1, lst))\n\n\nclass Queue:\n    def __init__(self) -> None:\n        self.items = deque()\n\n    def is_empty(self) -> bool:\n        return len(self.items) == 0\n\n    def enqueue(self, item) -> None:\n        self.items.appendleft(item)\n\n    def insert(self, item) -> None:\n        self.enqueue(item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def front(self):\n        return self.items[-1]\n\n    def pop(self) -> None:\n        self.items.pop()\n\n    def size(self) -> int:\n        return len(self.items)\n\n\nclass LCA:\n    def __init__(self, N: int) -> None:\n        self.N = N\n        self.to = [[] for _ in range(N)]\n        self.co = [[] for _ in range(N)]\n        self.dep = [0] * N\n        self.costs = [0] * N\n        l = 0\n        while (1 << l) < N:\n            l += 1\n        self.l = l\n        self.par = [([0] * l) for _ in range(N + 1)]\n\n    def add_edge(self, a: int, b: int, c=0) -> None:\n        self.to[a].append(b)\n        self.co[a].append(c)\n        self.to[b].append(a)\n        self.co[b].append(c)\n\n    '''\n    def _dfs(self, v: int, d: int = 0, c = 0, p: int = -1) -> None:\n        if p != -1:\n            self.par[v][0] = p\n        self.dep[v] = d\n        self.costs[v] = c\n        for i in range(len(self.to[v])):\n            u = self.to[v][i]\n            if u == p:\n                continue\n            else:\n                self._dfs(u, d+1, c+self.co[v][i], v)\n    '''\n\n    def _bfs(self, root: int) -> None:\n        que = Queue()\n        que.enqueue(root)\n        self.dep[root] = 0\n        self.costs[root] = 0\n        vis = [False] * self.N\n        while que.is_empty() is False:\n            v = que.dequeue()\n            vis[v] = True\n            nd = self.dep[v] + 1\n            cs = self.costs[v]\n            for i in range(len(self.to[v])):\n                nv = self.to[v][i]\n                if vis[nv]:\n                    continue\n                else:\n                    que.enqueue(nv)\n                    self.dep[nv] = nd\n                    self.costs[nv] = cs + self.co[v][i]\n                    self.par[nv][0] = v\n\n    def init(self, root: int = 0) -> None:\n        self.root = root\n        self._bfs(root)\n        for i in range(self.l - 1):\n            for v in range(self.N):\n                self.par[v][i + 1] = self.par[self.par[v][i]][i]\n\n    def lca(self, a: int, b: int) -> int:\n        dep_s, dep_l = self.dep[a], self.dep[b]\n        if dep_s > dep_l:\n            a, b = b, a\n            dep_s, dep_l = dep_l, dep_s\n        gap = dep_l - dep_s\n        L_1 = self.l - 1\n        par = self.par\n        for i in range(L_1, -1, -1):\n            leng = 1 << i\n            if gap >= leng:\n                gap -= leng\n                b = par[b][i]\n        if a == b:\n            return a\n        for i in range(L_1, -1, -1):\n            na = par[a][i]\n            nb = par[b][i]\n            if na != nb:\n                a, b = na, nb\n        return par[a][0]\n\n    def length(self, a: int, b: int) -> int:\n        c = self.lca(a, b)\n        dep = self.dep\n        return dep[a] + dep[b] - dep[c] * 2\n\n    def dist(self, a: int, b: int):\n        c = self.lca(a, b)\n        costs = self.costs\n        return costs[a] + costs[b] - costs[c] * 2\n\n\ndef main():\n    N, Q = ILI()\n    gr = LCA(N)\n    es = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b, col, dist = ILI()\n        a -= 1;\n        b -= 1\n        es[a].append((b, dist, col))\n        es[b].append((a, dist, col))\n        gr.add_edge(a, b, dist)\n\n    gr.init()\n    ans = [0] * Q\n    qs = [[] for _ in range(N)]\n    for i in range(Q):\n        cx, dy, a, b = ILI()\n        a -= 1;\n        b -= 1\n        # ans[i] = gr.dist(a, b)\n        c = gr.lca(a, b)\n        ans[i] = gr.costs[a] + gr.costs[b] - gr.costs[c] * 2\n        qs[a].append((cx, i, 1, dy))\n        qs[b].append((cx, i, 1, dy))\n        qs[c].append((cx, i, -2, dy))\n\n    cnt = [0] * N\n    sum_ = [0] * N\n\n\n    def dfs(v: int, p: int = -1) -> None:\n        for (col, qid, coeff, dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n\n        for (to, co, col) in es[v]:\n            if to == p:\n                continue\n            cnt[col] += 1\n            sum_[col] += co\n\n            dfs(to, v)\n\n            cnt[col] -= 1\n            sum_[col] -= co\n\n\n    sk = []\n    tr = [{} for _ in range(N+1)]\n    vis = [False] * (N+1)\n\n    def dfs2(v: int, p: int = -1) -> None:\n        for (col, qid, coeff, dist) in qs[v]:\n            x = -sum_[col]\n            x += dist * cnt[col]\n            ans[qid] += x * coeff\n\n        vis[v] = True\n\n        for (to, co, col) in reversed(es[v]):\n            if to == p:\n                continue\n            sk.append((to, v, col, co))\n            tr[v][to] = (col, co)\n\n        while len(sk) > 0:\n            v, p, cl, cs = sk[-1]\n            if len(es[v]) == 1:\n                sk.pop()\n\n            if vis[v] and p >= 0:\n                cl, cs = tr[p][v]\n                cnt[cl] -= 1\n                sum_[cl] -= cs\n                tr[p].pop(v)\n                sk.pop()\n                continue\n\n            cnt[cl] += 1\n            sum_[cl] += cs\n\n            for (col, qid, coeff, dist) in qs[v]:\n                x = -sum_[col]\n                x += dist * cnt[col]\n                ans[qid] += x * coeff\n\n            vis[v] = True\n\n            for (to, co, col) in reversed(es[v]):\n                if to == p:\n                    continue\n                sk.append((to, v, col, co))\n                tr[v][to] = (col, co)\n\n            if len(tr[v]) == 0 and p >= 0:\n                cl, cs = tr[p][v]\n                cnt[cl] -= 1\n                sum_[cl] -= cs\n                tr[p].pop(v)\n\n    dfs2(0)\n\n    print(*ans, sep='\\n')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]